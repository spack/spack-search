{
    "matches": {
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/test/libdl.jl": "# This file is a part of Julia. License is MIT: http://julialang.org/license\n\n# these could fail on an embedded installation\n# but for now, we don't handle that case\ndlls = Libdl.dllist()\n@test !isempty(dlls)\n@test length(dlls) > 3 # at a bare minimum, probably have some version of libstdc, libgcc, libjulia, ...\nif @unix? true : (Base.windows_version() >= Base.WINDOWS_VISTA_VER)\n    for dl in dlls\n        if isfile(dl) && (Libdl.dlopen_e(dl) != C_NULL)\n            @test Base.samefile(Libdl.dlpath(dl), dl)\n        end\n    end\nend\n@test length(filter(dlls) do dl\n        return ismatch(Regex(\"^libjulia(?:.*)\\.$(Libdl.dlext)(?:\\..+)?\\$\"), basename(dl))\n    end) == 1 # look for something libjulia-like (but only one)\n\n# library handle pointer must not be NULL\n@test_throws ArgumentError Libdl.dlsym(C_NULL, :foo)\n@test_throws ArgumentError Libdl.dlsym_e(C_NULL, :foo)\n\ncd(dirname(@__FILE__)) do\n\n# @test !isempty(Libdl.find_library([\"libccalltest\"], [dirname(@__FILE__)]))\n\n# Find the private library directory by finding the path of libjulia (or libjulia-debug, as the case may be)\nif ccall(:jl_is_debugbuild, Cint, ()) != 0\n    private_libdir = dirname(abspath(Libdl.dlpath(\"libjulia-debug\")))\nelse\n    private_libdir = dirname(abspath(Libdl.dlpath(\"libjulia\")))\nend\n\n# dlopen should be able to handle absolute and relative paths, with and without dlext\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(abspath(joinpath(private_libdir, \"libccalltest\")))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(abspath(joinpath(private_libdir, \"libccalltest.$(Libdl.dlext)\")))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(relpath(joinpath(private_libdir, \"libccalltest\")))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(relpath(joinpath(private_libdir, \"libccalltest.$(Libdl.dlext)\")))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(\"./foo\")\n        @test dl == C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# unqualified names present in DL_LOAD_PATH\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(\"libccalltest\")\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(string(\"libccalltest\",\".\",Libdl.dlext))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# path with dlopen-able file first in load path\n#=\nlet dl = C_NULL,\n    tmpdir = mktempdir(),\n    fpath = joinpath(tmpdir,\"libccalltest\")\n    try\n        write(open(fpath,\"w\"))\n        push!(Libdl.DL_LOAD_PATH, dirname(@__FILE__))\n        push!(Libdl.DL_LOAD_PATH, dirname(fpath))\n        dl = Libdl.dlopen_e(\"libccalltest\")\n        @test dl != C_NULL\n    finally\n        pop!(Libdl.DL_LOAD_PATH)\n        pop!(Libdl.DL_LOAD_PATH)\n        rm(tmpdir, recursive=true)\n    end\nend\n=#\n\n# path with dlopen-able file second in load path\n#=\nlet dl = C_NULL,\n    tmpdir = mktempdir(),\n    fpath = joinpath(tmpdir,\"libccalltest\")\n    try\n        write(open(fpath,\"w\"))\n        push!(Libdl.DL_LOAD_PATH, dirname(fpath))\n        push!(Libdl.DL_LOAD_PATH, dirname(@__FILE__))\n        dl = Libdl.dlopen_e(\"libccalltest\")\n        @test dl != C_NULL\n    finally\n        pop!(Libdl.DL_LOAD_PATH)\n        pop!(Libdl.DL_LOAD_PATH)\n        rm(tmpdir, recursive=true)\n    end\nend\n=#\n\n# test dlpath\nlet dl = C_NULL\n    try\n        path = abspath(joinpath(private_libdir, \"libccalltest\"))\n        dl = Libdl.dlopen(path)\n        @test dl != C_NULL\n        @test Base.samefile(abspath(Libdl.dlpath(dl)),\n                            abspath(Libdl.dlpath(path)))\n        @test Base.samefile(abspath(Libdl.dlpath(dl)),\n                            string(path,\".\",Libdl.dlext))\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# opening a library that does not exist throws an ErrorException\n@test_throws ErrorException Libdl.dlopen(\"./foo\")\n\n# test dlsym\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(abspath(joinpath(private_libdir, \"libccalltest\")))\n        fptr = Libdl.dlsym(dl, :set_verbose)\n        @test fptr != C_NULL\n        @test_throws ErrorException Libdl.dlsym(dl, :foo)\n\n        fptr = Libdl.dlsym_e(dl, :set_verbose)\n        @test fptr != C_NULL\n        fptr = Libdl.dlsym_e(dl, :foo)\n        @test fptr == C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nend\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/src/sys.c": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n/*\n  sys.c\n  I/O and operating system utility functions\n*/\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#ifdef _OS_WINDOWS_\n#include <psapi.h>\n#else\n#include <sys/sysctl.h>\n#include <sys/wait.h>\n#include <sys/ptrace.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#endif\n#include <errno.h>\n#include <signal.h>\n#include <fcntl.h>\n\n#ifndef _OS_WINDOWS_\n// for getrusage\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#endif\n\n#ifdef __APPLE__\n#include <mach-o/dyld.h>\n#include <mach-o/nlist.h>\n#include <sys/types.h> // for jl_raise_debugger\n#elif !defined(_OS_WINDOWS_)\n#include <link.h>\n#endif\n\n#define __STDC_CONSTANT_MACROS\n#define __STDC_LIMIT_MACROS\n#include <llvm-c/Target.h>\n\n#ifdef __SSE__\n#include <xmmintrin.h>\n#endif\n\n#if defined _MSC_VER\n#include <io.h>\n#include <intrin.h>\n#endif\n\n#ifdef __has_feature\n#if __has_feature(memory_sanitizer)\n#include <sanitizer/msan_interface.h>\n#endif\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(_OS_WINDOWS_) && !defined(_COMPILER_MINGW_)\nDLLEXPORT char *dirname(char *);\n#else\n#include <libgen.h>\n#endif\n\nDLLEXPORT uint32_t jl_getutf8(ios_t *s)\n{\n    uint32_t wc=0;\n    ios_getutf8(s, &wc);\n    return wc;\n}\n\nDLLEXPORT int jl_sizeof_off_t(void) { return sizeof(off_t); }\n#ifndef _OS_WINDOWS_\nDLLEXPORT off_t jl_lseek(int fd, off_t offset, int whence) { return lseek(fd, offset, whence); }\nDLLEXPORT ssize_t jl_pwrite(int fd, const void *buf, size_t count, off_t offset)\n{\n    return pwrite(fd, buf, count, offset);\n}\nDLLEXPORT void *jl_mmap(void *addr, size_t length, int prot, int flags,\n                        int fd, off_t offset)\n{\n    return mmap(addr, length, prot, flags, fd, offset);\n}\n#else\nDLLEXPORT off_t jl_lseek(int fd, off_t offset, int whence) { return _lseek(fd, offset, whence); }\n#endif\nDLLEXPORT int jl_sizeof_ios_t(void) { return sizeof(ios_t); }\n\nDLLEXPORT long jl_ios_fd(ios_t *s) { return s->fd; }\n\nDLLEXPORT int32_t jl_nb_available(ios_t *s)\n{\n    return (int32_t)(s->size - s->bpos);\n}\n\n// --- dir/file stuff ---\n\nDLLEXPORT int jl_sizeof_uv_fs_t(void) { return sizeof(uv_fs_t); }\nDLLEXPORT void jl_uv_fs_req_cleanup(uv_fs_t *req)\n{\n    uv_fs_req_cleanup(req);\n}\n\nDLLEXPORT int jl_readdir(const char *path, uv_fs_t *readdir_req)\n{\n    // Note that the flags field is mostly ignored by libuv\n    return uv_fs_readdir(uv_default_loop(), readdir_req, path, 0 /*flags*/, NULL);\n}\n\nDLLEXPORT char *jl_uv_fs_t_ptr(uv_fs_t *req) { return (char*)req->ptr; }\nDLLEXPORT char *jl_uv_fs_t_ptr_offset(uv_fs_t *req, int offset) { return (char*)req->ptr + offset; }\nDLLEXPORT int jl_uv_fs_result(uv_fs_t *f) { return f->result; }\n\n// --- stat ---\nDLLEXPORT int jl_sizeof_stat(void) { return sizeof(uv_stat_t); }\n\nDLLEXPORT int32_t jl_stat(const char *path, char *statbuf)\n{\n    uv_fs_t req;\n    int ret;\n\n    // Ideally one would use the statbuf for the storage in req, but\n    // it's not clear that this is possible using libuv\n    ret = uv_fs_stat(uv_default_loop(), &req, path, NULL);\n    if (ret == 0)\n        memcpy(statbuf, req.ptr, sizeof(uv_stat_t));\n    uv_fs_req_cleanup(&req);\n    return ret;\n}\n\nDLLEXPORT int32_t jl_lstat(const char *path, char *statbuf)\n{\n    uv_fs_t req;\n    int ret;\n\n    ret = uv_fs_lstat(uv_default_loop(), &req, path, NULL);\n    if (ret == 0)\n        memcpy(statbuf, req.ptr, sizeof(uv_stat_t));\n    uv_fs_req_cleanup(&req);\n    return ret;\n}\n\nDLLEXPORT int32_t jl_fstat(int fd, char *statbuf)\n{\n    uv_fs_t req;\n    int ret;\n\n    ret = uv_fs_fstat(uv_default_loop(), &req, fd, NULL);\n    if (ret == 0)\n        memcpy(statbuf, req.ptr, sizeof(uv_stat_t));\n    uv_fs_req_cleanup(&req);\n    return ret;\n}\n\nDLLEXPORT unsigned int jl_stat_dev(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_dev;\n}\n\nDLLEXPORT unsigned int jl_stat_ino(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_ino;\n}\n\nDLLEXPORT unsigned int jl_stat_mode(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_mode;\n}\n\nDLLEXPORT unsigned int jl_stat_nlink(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_nlink;\n}\n\nDLLEXPORT unsigned int jl_stat_uid(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_uid;\n}\n\nDLLEXPORT unsigned int jl_stat_gid(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_gid;\n}\n\nDLLEXPORT unsigned int jl_stat_rdev(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_rdev;\n}\n\nDLLEXPORT uint64_t jl_stat_size(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_size;\n}\n\nDLLEXPORT uint64_t jl_stat_blksize(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_blksize;\n}\n\nDLLEXPORT uint64_t jl_stat_blocks(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_blocks;\n}\n\n/*\n// atime is stupid, let's not support it\nDLLEXPORT double jl_stat_atime(char *statbuf)\n{\n  uv_stat_t *s;\n  s = (uv_stat_t*)statbuf;\n  return (double)s->st_atim.tv_sec + (double)s->st_atim.tv_nsec * 1e-9;\n}\n*/\n\nDLLEXPORT double jl_stat_mtime(char *statbuf)\n{\n    uv_stat_t *s;\n    s = (uv_stat_t*)statbuf;\n    return (double)s->st_mtim.tv_sec + (double)s->st_mtim.tv_nsec * 1e-9;\n}\n\nDLLEXPORT double jl_stat_ctime(char *statbuf)\n{\n    uv_stat_t *s;\n    s = (uv_stat_t*)statbuf;\n    return (double)s->st_ctim.tv_sec + (double)s->st_ctim.tv_nsec * 1e-9;\n}\n\n// --- buffer manipulation ---\n\njl_array_t *jl_takebuf_array(ios_t *s)\n{\n    size_t n;\n    jl_array_t *a;\n    if (s->buf == &s->local[0]) {\n        // small data case. copies, but this can be avoided using the\n        // technique of jl_readuntil below.\n        a = jl_pchar_to_array(s->buf, s->size);\n        ios_trunc(s, 0);\n    }\n    else {\n        char *b = ios_takebuf(s, &n);\n        a = jl_ptr_to_array_1d(jl_array_uint8_type, b, n-1, 1);\n    }\n    return a;\n}\n\njl_value_t *jl_takebuf_string(ios_t *s)\n{\n    jl_array_t *a = jl_takebuf_array(s);\n    JL_GC_PUSH1(&a);\n    jl_value_t *str = jl_array_to_string(a);\n    JL_GC_POP();\n    return str;\n}\n\n// the returned buffer must be manually freed. To determine the size,\n// call position(s) before using this function.\nvoid *jl_takebuf_raw(ios_t *s)\n{\n    size_t sz;\n    void *buf = ios_takebuf(s, &sz);\n    return buf;\n}\n\njl_value_t *jl_readuntil(ios_t *s, uint8_t delim)\n{\n    jl_array_t *a;\n    // manually inlined common case\n    char *pd = (char*)memchr(s->buf+s->bpos, delim, s->size - s->bpos);\n    if (pd) {\n        size_t n = pd-(s->buf+s->bpos)+1;\n        a = jl_alloc_array_1d(jl_array_uint8_type, n);\n        memcpy(jl_array_data(a), s->buf+s->bpos, n);\n        s->bpos += n;\n    }\n    else {\n        a = jl_alloc_array_1d(jl_array_uint8_type, 80);\n        ios_t dest;\n        ios_mem(&dest, 0);\n        ios_setbuf(&dest, (char*)a->data, 80, 0);\n        size_t n = ios_copyuntil(&dest, s, delim);\n        if (dest.buf != a->data) {\n            a = jl_takebuf_array(&dest);\n        }\n        else {\n#ifdef STORE_ARRAY_LEN\n            a->length = n;\n#endif\n            a->nrows = n;\n            ((char*)a->data)[n] = '\\0';\n        }\n    }\n    return (jl_value_t*)a;\n}\n\nstatic void NORETURN throw_eof_error(void)\n{\n    jl_datatype_t *eof_error = (jl_datatype_t*)jl_get_global(jl_base_module, jl_symbol(\"EOFError\"));\n    assert(eof_error != NULL);\n    jl_exceptionf(eof_error, \"\");\n}\n\nDLLEXPORT uint64_t jl_ios_get_nbyte_int(ios_t *s, const size_t n)\n{\n    assert(n <= 8);\n    size_t space, ret;\n    do {\n        space = s->size - s->bpos;\n        ret = ios_readprep(s, n);\n        if (space == ret && ret < n)\n            throw_eof_error();\n    } while(ret < n);\n    uint64_t x = 0;\n    uint8_t *buf = (uint8_t*)&s->buf[s->bpos];\n    if (n == 8) {\n        // expecting loop unrolling optimization\n        for (size_t i = 0; i < 8; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n    }\n    else if (n >= 4) {\n        // expecting loop unrolling optimization\n        for (size_t i = 0; i < 4; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n        for (size_t i = 4; i < n; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n    }\n    else {\n        for (size_t i = 0; i < n; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n    }\n    s->bpos += n;\n    return x;\n}\n\n// -- syscall utilities --\n\nint jl_errno(void) { return errno; }\nvoid jl_set_errno(int e) { errno = e; }\n\n// -- get the number of CPU cores --\n\n#ifdef _OS_WINDOWS_\ntypedef DWORD (WINAPI *GAPC)(WORD);\n#ifndef ALL_PROCESSOR_GROUPS\n#define ALL_PROCESSOR_GROUPS 0xffff\n#endif\n#endif\n\nDLLEXPORT int jl_cpu_cores(void)\n{\n#if defined(HW_AVAILCPU) && defined(HW_NCPU)\n    size_t len = 4;\n    int32_t count;\n    int nm[2] = {CTL_HW, HW_AVAILCPU};\n    sysctl(nm, 2, &count, &len, NULL, 0);\n    if (count < 1) {\n        nm[1] = HW_NCPU;\n        sysctl(nm, 2, &count, &len, NULL, 0);\n        if (count < 1) { count = 1; }\n    }\n    return count;\n#elif defined(_SC_NPROCESSORS_ONLN)\n    return sysconf(_SC_NPROCESSORS_ONLN);\n#elif defined(_OS_WINDOWS_)\n    //Try to get WIN7 API method\n    GAPC gapc = (GAPC) jl_dlsym_e(\n        jl_kernel32_handle,\n        \"GetActiveProcessorCount\"\n    );\n\n    if (gapc) {\n        return gapc(ALL_PROCESSOR_GROUPS);\n    }\n    else { //fall back on GetSystemInfo\n        SYSTEM_INFO info;\n        GetSystemInfo(&info);\n        return info.dwNumberOfProcessors;\n    }\n#else\n    return 1;\n#endif\n}\n\n// -- high resolution timers --\n// Returns time in nanosec\nDLLEXPORT uint64_t jl_hrtime(void)\n{\n    return uv_hrtime();\n}\n\n// -- iterating the environment --\n\n#ifdef __APPLE__\n#include <crt_externs.h>\n#else\n#if !defined(_OS_WINDOWS_) || defined(_COMPILER_MINGW_)\nextern char **environ;\n#endif\n#endif\n\njl_value_t *jl_environ(int i)\n{\n#ifdef __APPLE__\n    char **environ = *_NSGetEnviron();\n#endif\n    char *env = environ[i];\n    return env ? jl_pchar_to_string(env, strlen(env)) : jl_nothing;\n}\n\n// -- child process status --\n\n#if defined _MSC_VER || defined _OS_WINDOWS_\n/* Native Woe32 API.  */\n#include <process.h>\n#define waitpid(pid,statusp,options) _cwait (statusp, pid, WAIT_CHILD)\n#define WAIT_T int\n#define WTERMSIG(x) ((x) & 0xff) /* or: SIGABRT ?? */\n#define WCOREDUMP(x) 0\n#define WEXITSTATUS(x) (((x) >> 8) & 0xff) /* or: (x) ?? */\n#define WIFSIGNALED(x) (WTERMSIG (x) != 0) /* or: ((x) == 3) ?? */\n#define WIFEXITED(x) (WTERMSIG (x) == 0) /* or: ((x) != 3) ?? */\n#define WIFSTOPPED(x) 0\n#define WSTOPSIG(x) 0 //Is this correct?\n#endif\n\nint jl_process_exited(int status)      { return WIFEXITED(status); }\nint jl_process_signaled(int status)    { return WIFSIGNALED(status); }\nint jl_process_stopped(int status)     { return WIFSTOPPED(status); }\n\nint jl_process_exit_status(int status) { return WEXITSTATUS(status); }\nint jl_process_term_signal(int status) { return WTERMSIG(status); }\nint jl_process_stop_signal(int status) { return WSTOPSIG(status); }\n\n// -- access to std filehandles --\n\nJL_STREAM *JL_STDIN  = (JL_STREAM*)STDIN_FILENO;\nJL_STREAM *JL_STDOUT = (JL_STREAM*)STDOUT_FILENO;\nJL_STREAM *JL_STDERR = (JL_STREAM*)STDERR_FILENO;\n\nJL_STREAM *jl_stdin_stream(void)  { return JL_STDIN; }\nJL_STREAM *jl_stdout_stream(void) { return JL_STDOUT; }\nJL_STREAM *jl_stderr_stream(void) { return JL_STDERR; }\n\n// CPUID\n\n#ifdef HAVE_CPUID\nDLLEXPORT void jl_cpuid(int32_t CPUInfo[4], int32_t InfoType)\n{\n#if defined _MSC_VER\n    __cpuid(CPUInfo, InfoType);\n#else\n    __asm__ __volatile__ (\n        #if defined(__i386__) && defined(__PIC__)\n        \"xchg %%ebx, %%esi;\"\n        \"cpuid;\"\n        \"xchg %%esi, %%ebx;\":\n        \"=S\" (CPUInfo[1]) ,\n        #else\n        \"cpuid\":\n        \"=b\" (CPUInfo[1]),\n        #endif\n        \"=a\" (CPUInfo[0]),\n        \"=c\" (CPUInfo[2]),\n        \"=d\" (CPUInfo[3]) :\n        \"a\" (InfoType)\n    );\n#endif\n}\n#endif\n\n// -- set/clear the FZ/DAZ flags on x86 & x86-64 --\n#ifdef __SSE__\n\n// Cache of information recovered from jl_cpuid.\n// In a multithreaded environment, there will be races on subnormal_flags,\n// but they are harmless idempotent races.  If we ever embrace C11, then\n// subnormal_flags should be declared atomic.\nstatic volatile int32_t subnormal_flags = 1;\n\nstatic int32_t get_subnormal_flags()\n{\n    uint32_t f = subnormal_flags;\n    if (f & 1) {\n        // CPU capabilities not yet inspected.\n        f = 0;\n        int32_t info[4];\n        jl_cpuid(info, 0);\n        if (info[0] >= 1) {\n            jl_cpuid(info, 0x00000001);\n            if (info[3] & (1 << 26)) {\n                // SSE2 supports both FZ and DAZ\n                f = 0x00008040;\n            }\n            else if (info[3] & (1 << 25)) {\n                // SSE supports only the FZ flag\n                f = 0x00008000;\n            }\n        }\n        subnormal_flags = f;\n    }\n    return f;\n}\n\n// Returns non-zero if subnormals go to 0; zero otherwise.\nDLLEXPORT int32_t jl_get_zero_subnormals(int8_t isZero)\n{\n    uint32_t flags = get_subnormal_flags();\n    return _mm_getcsr() & flags;\n}\n\n// Return zero on success, non-zero on failure.\nDLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)\n{\n    uint32_t flags = get_subnormal_flags();\n    if (flags) {\n        uint32_t state = _mm_getcsr();\n        if (isZero)\n            state |= flags;\n        else\n            state &= ~flags;\n        _mm_setcsr(state);\n        return 0;\n    }\n    else {\n        // Report a failure only if user is trying to enable FTZ/DAZ.\n        return isZero;\n    }\n}\n\n#else\n\nDLLEXPORT int32_t jl_get_zero_subnormals(int8_t isZero)\n{\n    return 0;\n}\n\nDLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)\n{\n    return isZero;\n}\n\n#endif\n\n// -- processor native alignment information --\n\nDLLEXPORT void jl_native_alignment(uint_t *int8align, uint_t *int16align, uint_t *int32align,\n                                   uint_t *int64align, uint_t *float32align, uint_t *float64align)\n{\n    LLVMTargetDataRef tgtdata = LLVMCreateTargetData(\"\");\n    *int8align = LLVMPreferredAlignmentOfType(tgtdata, LLVMInt8Type());\n    *int16align = LLVMPreferredAlignmentOfType(tgtdata, LLVMInt16Type());\n    *int32align = LLVMPreferredAlignmentOfType(tgtdata, LLVMInt32Type());\n    *int64align = LLVMPreferredAlignmentOfType(tgtdata, LLVMInt64Type());\n    *float32align = LLVMPreferredAlignmentOfType(tgtdata, LLVMFloatType());\n    *float64align = LLVMPreferredAlignmentOfType(tgtdata, LLVMDoubleType());\n    LLVMDisposeTargetData(tgtdata);\n}\n\nDLLEXPORT jl_value_t *jl_is_char_signed()\n{\n    return ((char)255) < 0 ? jl_true : jl_false;\n}\n\nDLLEXPORT void jl_field_offsets(jl_datatype_t *dt, ssize_t *offsets)\n{\n    size_t i;\n    for(i=0; i < jl_datatype_nfields(dt); i++) {\n        offsets[i] = jl_field_offset(dt, i);\n    }\n}\n\n// -- misc sysconf info --\n\n#ifdef _OS_WINDOWS_\nstatic long cachedPagesize = 0;\nlong jl_getpagesize(void)\n{\n    if (!cachedPagesize) {\n        SYSTEM_INFO systemInfo;\n        GetSystemInfo (&systemInfo);\n        cachedPagesize = systemInfo.dwPageSize;\n    }\n    return cachedPagesize;\n}\n#else\nlong jl_getpagesize(void)\n{\n    return sysconf(_SC_PAGESIZE);\n}\n#endif\n\n#ifdef _OS_WINDOWS_\nstatic long cachedAllocationGranularity = 0;\nlong jl_getallocationgranularity(void)\n{\n    if (!cachedAllocationGranularity) {\n        SYSTEM_INFO systemInfo;\n        GetSystemInfo (&systemInfo);\n        cachedAllocationGranularity = systemInfo.dwAllocationGranularity;\n    }\n    return cachedAllocationGranularity;\n}\n#else\nlong jl_getallocationgranularity(void)\n{\n    return jl_getpagesize();\n}\n#endif\n\nDLLEXPORT long jl_SC_CLK_TCK(void)\n{\n#ifndef _OS_WINDOWS_\n    return sysconf(_SC_CLK_TCK);\n#else\n    return 0;\n#endif\n}\n\nDLLEXPORT size_t jl_get_field_offset(jl_datatype_t *ty, int field)\n{\n    if (field > jl_datatype_nfields(ty))\n        jl_error(\"This type does not have that many fields\");\n    return jl_field_offset(ty, field);\n}\n\nDLLEXPORT size_t jl_get_alignment(jl_datatype_t *ty)\n{\n    return ty->alignment;\n}\n\n// Takes a handle (as returned from dlopen()) and returns the absolute path to the image loaded\nDLLEXPORT const char *jl_pathname_for_handle(uv_lib_t *uv_lib)\n{\n    if (!uv_lib)\n        return NULL;\n\n    void *handle = uv_lib->handle;\n#ifdef __APPLE__\n    // Iterate through all images currently in memory\n    for (int32_t i = _dyld_image_count(); i >= 0 ; i--) {\n        // dlopen() each image, check handle\n        const char *image_name = _dyld_get_image_name(i);\n        uv_lib_t *probe_lib = jl_load_dynamic_library(image_name, JL_RTLD_DEFAULT);\n        void *probe_handle = probe_lib->handle;\n        uv_dlclose(probe_lib);\n\n        // If the handle is the same as what was passed in (modulo mode bits), return this image name\n        if (((intptr_t)handle & (-4)) == ((intptr_t)probe_handle & (-4)))\n            return image_name;\n    }\n\n#elif defined(_OS_WINDOWS_)\n\n    wchar_t *pth16 = (wchar_t*)malloc(32768); // max long path length\n    DWORD n16 = GetModuleFileNameW((HMODULE)handle,pth16,32768);\n    if (n16 <= 0) {\n        free(pth16);\n        return NULL;\n    }\n    pth16[n16] = L'\\0';\n    DWORD n8 = WideCharToMultiByte(CP_UTF8, 0, pth16, -1, NULL, 0, NULL, NULL);\n    if (n8 == 0) {\n        free(pth16);\n        return NULL;\n    }\n    char *filepath = (char*)malloc(++n8);\n    if (!WideCharToMultiByte(CP_UTF8, 0, pth16, -1, filepath, n8, NULL, NULL)) {\n        free(pth16);\n        free(filepath);\n        return NULL;\n    }\n    free(pth16);\n    return filepath;\n\n#else // Linux, FreeBSD, ...\n\n    struct link_map *map;\n    dlinfo(handle, RTLD_DI_LINKMAP, &map);\n#ifdef __has_feature\n#if __has_feature(memory_sanitizer)\n    __msan_unpoison(&map,sizeof(struct link_map*));\n    if (map) {\n      __msan_unpoison(map, sizeof(struct link_map));\n      __msan_unpoison_string(map->l_name);\n    }\n#endif\n#endif\n    if (map)\n        return map->l_name;\n\n#endif\n    return NULL;\n}\n\n#ifdef _OS_WINDOWS_\n#include <dbghelp.h>\nstatic BOOL CALLBACK jl_EnumerateLoadedModulesProc64(\n  _In_      PCTSTR ModuleName,\n  _In_      DWORD64 ModuleBase,\n  _In_      ULONG ModuleSize,\n  _In_opt_  PVOID a\n)\n{\n    jl_array_grow_end((jl_array_t*)a, 1);\n    //XXX: change to jl_arrayset if array storage allocation for Array{ByteString,1} changes:\n    jl_value_t *v = jl_cstr_to_string(ModuleName);\n    jl_cellset(a, jl_array_dim0(a)-1, v);\n    return TRUE;\n}\n// Takes a handle (as returned from dlopen()) and returns the absolute path to the image loaded\nDLLEXPORT int jl_dllist(jl_array_t *list)\n{\n    return EnumerateLoadedModules64(GetCurrentProcess(), jl_EnumerateLoadedModulesProc64, list);\n}\n#endif\n\nDLLEXPORT void jl_raise_debugger(void)\n{\n#if defined(_OS_WINDOWS_)\n    if (IsDebuggerPresent() == 1)\n        DebugBreak();\n#else\n    raise(SIGINT);\n#endif // _OS_WINDOWS_\n}\n\nDLLEXPORT jl_sym_t* jl_get_OS_NAME()\n{\n#if defined(_OS_WINDOWS_)\n    return jl_symbol(\"Windows\");\n#elif defined(_OS_LINUX_)\n    return jl_symbol(\"Linux\");\n#elif defined(_OS_FREEBSD_)\n    return jl_symbol(\"FreeBSD\");\n#elif defined(_OS_DARWIN_)\n    return jl_symbol(\"Darwin\");\n#else\n#warning OS_NAME is Unknown\n    return jl_symbol(\"Unknown\");\n#endif\n}\n\nDLLEXPORT jl_sym_t* jl_get_ARCH()\n{\n    static jl_sym_t* ARCH = NULL;\n    if (!ARCH)\n        ARCH = (jl_sym_t*) jl_get_global(jl_base_module, jl_symbol(\"ARCH\"));\n    return ARCH;\n}\n\nDLLEXPORT size_t jl_maxrss()\n{\n#if defined(_OS_WINDOWS_)\n    PROCESS_MEMORY_COUNTERS counter;\n    GetProcessMemoryInfo( GetCurrentProcess( ), &counter, sizeof(counter) );\n    return (size_t)counter.PeakWorkingSetSize;\n\n#elif defined(_OS_LINUX_) || defined(_OS_DARWIN_) || defined (_OS_FREEBSD_)\n    struct rusage rusage;\n    getrusage( RUSAGE_SELF, &rusage );\n\n#if defined(_OS_LINUX_)\n    return (size_t)(rusage.ru_maxrss * 1024);\n#else\n    return (size_t)rusage.ru_maxrss;\n#endif\n\n#else\n    return (size_t)0;\n#endif\n}\n\n\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/src/signals-win.c": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n// Windows\n//\nDLLEXPORT void gdblookup(ptrint_t ip);\n#define WIN32_LEAN_AND_MEAN\n// Copied from MINGW_FLOAT_H which may not be found due to a collision with the builtin gcc float.h\n// eventually we can probably integrate this into OpenLibm.\n#if defined(_COMPILER_MINGW_)\nvoid __cdecl __MINGW_NOTHROW _fpreset (void);\nvoid __cdecl __MINGW_NOTHROW fpreset (void);\n#else\nvoid __cdecl _fpreset (void);\nvoid __cdecl fpreset (void);\n#endif\n#define _FPE_INVALID        0x81\n#define _FPE_DENORMAL       0x82\n#define _FPE_ZERODIVIDE     0x83\n#define _FPE_OVERFLOW       0x84\n#define _FPE_UNDERFLOW      0x85\n#define _FPE_INEXACT        0x86\n#define _FPE_UNEMULATED     0x87\n#define _FPE_SQRTNEG        0x88\n#define _FPE_STACKOVERFLOW  0x8a\n#define _FPE_STACKUNDERFLOW 0x8b\n#define _FPE_EXPLICITGEN    0x8c    /* raise( SIGFPE ); */\n\nstatic char *strsignal(int sig)\n{\n    switch (sig) {\n    case SIGINT:         return \"SIGINT\"; break;\n    case SIGILL:         return \"SIGILL\"; break;\n    case SIGABRT_COMPAT: return \"SIGABRT_COMPAT\"; break;\n    case SIGFPE:         return \"SIGFPE\"; break;\n    case SIGSEGV:        return \"SIGSEGV\"; break;\n    case SIGTERM:        return \"SIGTERM\"; break;\n    case SIGBREAK:       return \"SIGBREAK\"; break;\n    case SIGABRT:        return \"SIGABRT\"; break;\n    }\n    return \"?\";\n}\n\nvoid __cdecl crt_sig_handler(int sig, int num)\n{\n    switch (sig) {\n    case SIGFPE:\n        fpreset();\n        signal(SIGFPE, (void (__cdecl *)(int))crt_sig_handler);\n        switch(num) {\n        case _FPE_INVALID:\n        case _FPE_OVERFLOW:\n        case _FPE_UNDERFLOW:\n        default:\n            jl_errorf(\"Unexpected FPE Error 0x%X\", num);\n            break;\n        case _FPE_ZERODIVIDE:\n            jl_throw(jl_diverror_exception);\n            break;\n        }\n        break;\n    case SIGINT:\n        signal(SIGINT, (void (__cdecl *)(int))crt_sig_handler);\n        if (jl_defer_signal) {\n            jl_signal_pending = sig;\n        }\n        else {\n            jl_signal_pending = 0;\n            jl_sigint_action();\n        }\n        break;\n    default: // SIGSEGV, (SSIGTERM, IGILL)\n        ios_printf(ios_stderr,\"\\nsignal (%d): %s\\n\", sig, strsignal(sig));\n        bt_size = rec_backtrace(bt_data, MAX_BT_SIZE);\n        jlbacktrace();\n        gc_debug_print_status();\n        raise(sig);\n    }\n}\n\nBOOL (*pSetThreadStackGuarantee)(PULONG);\nvoid restore_signals(void)\n{\n    SetConsoleCtrlHandler(NULL, 0); //turn on ctrl-c handler\n}\n\nvoid jl_throw_in_ctx(jl_value_t *excpt, CONTEXT *ctxThread, int bt)\n{\n    assert(excpt != NULL);\n#if defined(_CPU_X86_64_)\n    DWORD64 Rsp = (ctxThread->Rsp&(DWORD64)-16) - 8;\n#elif defined(_CPU_X86_)\n    DWORD32 Esp = (ctxThread->Esp&(DWORD32)-16) - 4;\n#else\n#error WIN16 not supported :P\n#endif\n    bt_size = bt ? rec_backtrace_ctx(bt_data, MAX_BT_SIZE, ctxThread) : 0;\n    jl_exception_in_transit = excpt;\n#if defined(_CPU_X86_64_)\n    *(DWORD64*)Rsp = 0;\n    ctxThread->Rsp = Rsp;\n    ctxThread->Rip = (DWORD64)&jl_rethrow;\n#elif defined(_CPU_X86_)\n    *(DWORD32*)Esp = 0;\n    ctxThread->Esp = Esp;\n    ctxThread->Eip = (DWORD)&jl_rethrow;\n#endif\n}\n\nvolatile HANDLE hMainThread = NULL;\n\nstatic BOOL WINAPI sigint_handler(DWORD wsig) //This needs winapi types to guarantee __stdcall\n{\n    int sig;\n    //windows signals use different numbers from unix (raise)\n    switch(wsig) {\n        case CTRL_C_EVENT: sig = SIGINT; break;\n        //case CTRL_BREAK_EVENT: sig = SIGTERM; break;\n        // etc.\n        default: sig = SIGTERM; break;\n    }\n    if (jl_defer_signal) {\n        jl_signal_pending = sig;\n    }\n    else {\n        jl_signal_pending = 0;\n        if (exit_on_sigint) jl_exit(130);\n        if ((DWORD)-1 == SuspendThread(hMainThread)) {\n            //error\n            jl_safe_printf(\"error: SuspendThread failed\\n\");\n            return 0;\n        }\n        CONTEXT ctxThread;\n        memset(&ctxThread,0,sizeof(CONTEXT));\n        ctxThread.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;\n        if (!GetThreadContext(hMainThread, &ctxThread)) {\n            //error\n            jl_safe_printf(\"error: GetThreadContext failed\\n\");\n            return 0;\n        }\n        jl_throw_in_ctx(jl_interrupt_exception, &ctxThread, 1);\n        ctxThread.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;\n        if (!SetThreadContext(hMainThread,&ctxThread)) {\n            jl_safe_printf(\"error: SetThreadContext failed\\n\");\n            //error\n            return 0;\n        }\n        if ((DWORD)-1 == ResumeThread(hMainThread)) {\n            jl_safe_printf(\"error: ResumeThread failed\\n\");\n            //error\n            return 0;\n        }\n    }\n    return 1;\n}\n\nstatic LONG WINAPI _exception_handler(struct _EXCEPTION_POINTERS *ExceptionInfo, int in_ctx)\n{\n    if (ExceptionInfo->ExceptionRecord->ExceptionFlags == 0) {\n        switch (ExceptionInfo->ExceptionRecord->ExceptionCode) {\n            case EXCEPTION_INT_DIVIDE_BY_ZERO:\n                fpreset();\n                jl_throw_in_ctx(jl_diverror_exception, ExceptionInfo->ContextRecord,in_ctx);\n                return EXCEPTION_CONTINUE_EXECUTION;\n            case EXCEPTION_STACK_OVERFLOW:\n                jl_throw_in_ctx(jl_stackovf_exception, ExceptionInfo->ContextRecord,in_ctx&&pSetThreadStackGuarantee);\n                return EXCEPTION_CONTINUE_EXECUTION;\n            case EXCEPTION_ACCESS_VIOLATION:\n                if (ExceptionInfo->ExceptionRecord->ExceptionInformation[0] == 1) { // writing to read-only memory (e.g. mmap)\n                    jl_throw_in_ctx(jl_readonlymemory_exception, ExceptionInfo->ContextRecord,in_ctx);\n                    return EXCEPTION_CONTINUE_EXECUTION;\n                }\n        }\n        jl_safe_printf(\"\\nPlease submit a bug report with steps to reproduce this fault, and any error messages that follow (in their entirety). Thanks.\\nException: \");\n        switch (ExceptionInfo->ExceptionRecord->ExceptionCode) {\n            case EXCEPTION_ACCESS_VIOLATION:\n                jl_safe_printf(\"EXCEPTION_ACCESS_VIOLATION\"); break;\n            case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n                jl_safe_printf(\"EXCEPTION_ARRAY_BOUNDS_EXCEEDED\"); break;\n            case EXCEPTION_BREAKPOINT:\n                jl_safe_printf(\"EXCEPTION_BREAKPOINT\"); break;\n            case EXCEPTION_DATATYPE_MISALIGNMENT:\n                jl_safe_printf(\"EXCEPTION_DATATYPE_MISALIGNMENT\"); break;\n            case EXCEPTION_FLT_DENORMAL_OPERAND:\n                jl_safe_printf(\"EXCEPTION_FLT_DENORMAL_OPERAND\"); break;\n            case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n                jl_safe_printf(\"EXCEPTION_FLT_DIVIDE_BY_ZERO\"); break;\n            case EXCEPTION_FLT_INEXACT_RESULT:\n                jl_safe_printf(\"EXCEPTION_FLT_INEXACT_RESULT\"); break;\n            case EXCEPTION_FLT_INVALID_OPERATION:\n                jl_safe_printf(\"EXCEPTION_FLT_INVALID_OPERATION\"); break;\n            case EXCEPTION_FLT_OVERFLOW:\n                jl_safe_printf(\"EXCEPTION_FLT_OVERFLOW\"); break;\n            case EXCEPTION_FLT_STACK_CHECK:\n                jl_safe_printf(\"EXCEPTION_FLT_STACK_CHECK\"); break;\n            case EXCEPTION_FLT_UNDERFLOW:\n                jl_safe_printf(\"EXCEPTION_FLT_UNDERFLOW\"); break;\n            case EXCEPTION_ILLEGAL_INSTRUCTION:\n                jl_safe_printf(\"EXCEPTION_ILLEGAL_INSTRUCTION\"); break;\n            case EXCEPTION_IN_PAGE_ERROR:\n                jl_safe_printf(\"EXCEPTION_IN_PAGE_ERROR\"); break;\n            case EXCEPTION_INT_DIVIDE_BY_ZERO:\n                jl_safe_printf(\"EXCEPTION_INT_DIVIDE_BY_ZERO\"); break;\n            case EXCEPTION_INT_OVERFLOW:\n                jl_safe_printf(\"EXCEPTION_INT_OVERFLOW\"); break;\n            case EXCEPTION_INVALID_DISPOSITION:\n                jl_safe_printf(\"EXCEPTION_INVALID_DISPOSITION\"); break;\n            case EXCEPTION_NONCONTINUABLE_EXCEPTION:\n                jl_safe_printf(\"EXCEPTION_NONCONTINUABLE_EXCEPTION\"); break;\n            case EXCEPTION_PRIV_INSTRUCTION:\n                jl_safe_printf(\"EXCEPTION_PRIV_INSTRUCTION\"); break;\n            case EXCEPTION_SINGLE_STEP:\n                jl_safe_printf(\"EXCEPTION_SINGLE_STEP\"); break;\n            case EXCEPTION_STACK_OVERFLOW:\n                jl_safe_printf(\"EXCEPTION_STACK_OVERFLOW\"); break;\n            default:\n                jl_safe_printf(\"UNKNOWN\"); break;\n        }\n        jl_safe_printf(\" at 0x%Ix -- \", (size_t)ExceptionInfo->ExceptionRecord->ExceptionAddress);\n        gdblookup((ptrint_t)ExceptionInfo->ExceptionRecord->ExceptionAddress);\n        bt_size = rec_backtrace_ctx(bt_data, MAX_BT_SIZE, ExceptionInfo->ContextRecord);\n        jlbacktrace();\n        static int recursion = 0;\n        if (recursion++)\n            exit(1);\n        else\n            jl_exit(1);\n    }\n    return EXCEPTION_CONTINUE_SEARCH;\n}\n\nstatic LONG WINAPI exception_handler(struct _EXCEPTION_POINTERS *ExceptionInfo)\n{\n    return _exception_handler(ExceptionInfo,1);\n}\n\n#if defined(_CPU_X86_64_)\nEXCEPTION_DISPOSITION _seh_exception_handler(PEXCEPTION_RECORD ExceptionRecord, void *EstablisherFrame, PCONTEXT ContextRecord, void *DispatcherContext)\n{\n    EXCEPTION_POINTERS ExceptionInfo;\n    ExceptionInfo.ExceptionRecord = ExceptionRecord;\n    ExceptionInfo.ContextRecord = ContextRecord;\n\n    EXCEPTION_DISPOSITION rval;\n    switch (_exception_handler(&ExceptionInfo,1)) {\n        case EXCEPTION_CONTINUE_EXECUTION:\n            rval = ExceptionContinueExecution; break;\n        case EXCEPTION_CONTINUE_SEARCH:\n            rval = ExceptionContinueSearch; break;\n#ifndef _MSC_VER\n        case EXCEPTION_EXECUTE_HANDLER:\n            rval = ExceptionExecuteHandler; break;\n#endif\n    }\n\n    return rval;\n}\n#endif\n\nDLLEXPORT void jl_install_sigint_handler(void)\n{\n    SetConsoleCtrlHandler((PHANDLER_ROUTINE)sigint_handler,1);\n}\n\n\nvolatile HANDLE hBtThread = 0;\nstatic DWORD WINAPI profile_bt( LPVOID lparam )\n{\n    // Note: illegal to use jl_* functions from this thread\n\n    TIMECAPS tc;\n    if (MMSYSERR_NOERROR!=timeGetDevCaps(&tc, sizeof(tc))) {\n        fputs(\"failed to get timer resolution\",stderr);\n        hBtThread = 0;\n        return 0;\n    }\n    while (1) {\n        if (running && bt_size_cur < bt_size_max) {\n            DWORD timeout = nsecprof/GIGA;\n            timeout = min(max(timeout,tc.wPeriodMin*2),tc.wPeriodMax/2);\n            Sleep(timeout);\n            if ((DWORD)-1 == SuspendThread(hMainThread)) {\n                fputs(\"failed to suspend main thread. aborting profiling.\",stderr);\n                break;\n            }\n            CONTEXT ctxThread;\n            memset(&ctxThread,0,sizeof(CONTEXT));\n            ctxThread.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;\n            if (!GetThreadContext(hMainThread, &ctxThread)) {\n                fputs(\"failed to get context from main thread. aborting profiling.\",stderr);\n                break;\n            }\n            // Get backtrace data\n            bt_size_cur += rec_backtrace_ctx((ptrint_t*)bt_data_prof+bt_size_cur, bt_size_max-bt_size_cur-1, &ctxThread);\n            // Mark the end of this block with 0\n            bt_data_prof[bt_size_cur] = 0;\n            bt_size_cur++;\n            if ((DWORD)-1 == ResumeThread(hMainThread)) {\n                fputs(\"failed to resume main thread! aborting.\",stderr);\n                abort();\n            }\n        }\n        else {\n            SuspendThread(GetCurrentThread());\n        }\n    }\n    hBtThread = 0;\n    return 0;\n}\nDLLEXPORT int jl_profile_start_timer(void)\n{\n    running = 1;\n    if (hBtThread == 0) {\n        hBtThread = CreateThread(\n            NULL,                   // default security attributes\n            0,                      // use default stack size\n            profile_bt,            // thread function name\n            0,                      // argument to thread function\n            0,                      // use default creation flags\n            0);                     // returns the thread identifier\n        (void)SetThreadPriority(hBtThread,THREAD_PRIORITY_ABOVE_NORMAL);\n    }\n    else {\n        if ((DWORD)-1 == ResumeThread(hBtThread)) {\n            fputs(\"failed to resume profiling thread.\",stderr);\n            return -2;\n        }\n    }\n    return (hBtThread != NULL ? 0 : -1);\n}\nDLLEXPORT void jl_profile_stop_timer(void)\n{\n    running = 0;\n}\n\nvoid jl_install_default_signal_handlers(void)\n{\n    ULONG StackSizeInBytes = sig_stack_size;\n    if (uv_dlsym(jl_kernel32_handle, \"SetThreadStackGuarantee\", (void**)&pSetThreadStackGuarantee) || !pSetThreadStackGuarantee(&StackSizeInBytes))\n        pSetThreadStackGuarantee = NULL;\n    if (signal(SIGFPE, (void (__cdecl *)(int))crt_sig_handler) == SIG_ERR) {\n        jl_error(\"fatal error: Couldn't set SIGFPE\");\n    }\n    if (signal(SIGILL, (void (__cdecl *)(int))crt_sig_handler) == SIG_ERR) {\n        jl_error(\"fatal error: Couldn't set SIGILL\");\n    }\n    if (signal(SIGINT, (void (__cdecl *)(int))crt_sig_handler) == SIG_ERR) {\n        jl_error(\"fatal error: Couldn't set SIGINT\");\n    }\n    if (signal(SIGSEGV, (void (__cdecl *)(int))crt_sig_handler) == SIG_ERR) {\n        jl_error(\"fatal error: Couldn't set SIGSEGV\");\n    }\n    if (signal(SIGTERM, (void (__cdecl *)(int))crt_sig_handler) == SIG_ERR) {\n        jl_error(\"fatal error: Couldn't set SIGTERM\");\n    }\n    SetUnhandledExceptionFilter(exception_handler);\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/src/signals-apple.c": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n#include <mach/mach_traps.h>\n#include <mach/task.h>\n#include <mach/mig_errors.h>\n#include <AvailabilityMacros.h>\n\n#ifdef MAC_OS_X_VERSION_10_9\n#include <sys/_types/_ucontext64.h>\n#else\n#define __need_ucontext64_t\n#include <sys/_structs.h>\n#endif\n\nstatic mach_port_t segv_port = 0;\n\nextern boolean_t exc_server(mach_msg_header_t *, mach_msg_header_t *);\n\nvoid *mach_segv_listener(void *arg)\n{\n    (void)arg;\n    while (1) {\n        int ret = mach_msg_server(exc_server,2048,segv_port,MACH_MSG_TIMEOUT_NONE);\n        jl_safe_printf(\"mach_msg_server: %s\\n\", mach_error_string(ret));\n        jl_exit(128+SIGSEGV);\n    }\n}\n\n#ifdef SEGV_EXCEPTION\nvoid darwin_segv_handler(unw_context_t *uc)\n{\n    bt_size = rec_backtrace_ctx(bt_data, MAX_BT_SIZE, uc);\n    jl_exception_in_transit = jl_segv_exception;\n    jl_rethrow();\n}\n#endif\n\nvoid darwin_stack_overflow_handler(unw_context_t *uc)\n{\n    bt_size = rec_backtrace_ctx(bt_data, MAX_BT_SIZE, uc);\n    jl_exception_in_transit = jl_stackovf_exception;\n    jl_rethrow();\n}\n\nvoid darwin_accerr_handler(unw_context_t *uc)\n{\n    bt_size = rec_backtrace_ctx(bt_data, MAX_BT_SIZE, uc);\n    jl_exception_in_transit = jl_readonlymemory_exception;\n    jl_rethrow();\n}\n\n#define HANDLE_MACH_ERROR(msg, retval) \\\n    if (retval!=KERN_SUCCESS) { mach_error(msg \":\", (retval)); jl_exit(1); }\n\n#ifdef LIBOSXUNWIND\nvolatile mach_port_t mach_profiler_thread = 0;\nstatic kern_return_t profiler_segv_handler\n                (mach_port_t                          exception_port,\n                 mach_port_t                                  thread,\n                 mach_port_t                                    task,\n                 exception_type_t                          exception,\n                 exception_data_t                               code,\n                 mach_msg_type_number_t                   code_count);\n#endif\n\nenum x86_trap_flags {\n    USER_MODE = 0x4,\n    WRITE_FAULT = 0x2,\n    PAGE_PRESENT = 0x1\n};\n\n//exc_server uses dlsym to find symbol\nDLLEXPORT\nkern_return_t catch_exception_raise(mach_port_t            exception_port,\n                                    mach_port_t            thread,\n                                    mach_port_t            task,\n                                    exception_type_t       exception,\n                                    exception_data_t       code,\n                                    mach_msg_type_number_t code_count)\n{\n    unsigned int count = MACHINE_THREAD_STATE_COUNT;\n    unsigned int exc_count = X86_EXCEPTION_STATE64_COUNT;\n    x86_thread_state64_t state, old_state;\n    x86_exception_state64_t exc_state;\n    kern_return_t ret;\n    //memset(&state,0,sizeof(x86_thread_state64_t));\n    //memset(&exc_state,0,sizeof(x86_exception_state64_t));\n#ifdef LIBOSXUNWIND\n    if (thread == mach_profiler_thread) {\n        return profiler_segv_handler(exception_port,thread,task,exception,code,code_count);\n    }\n#endif\n    ret = thread_get_state(thread,x86_EXCEPTION_STATE64,(thread_state_t)&exc_state,&exc_count);\n    HANDLE_MACH_ERROR(\"thread_get_state(1)\",ret);\n    uint64_t fault_addr = exc_state.__faultvaddr;\n#ifdef SEGV_EXCEPTION\n    if (1) {\n#else\n    if (msync((void*)(fault_addr & ~(jl_page_size - 1)), 1, MS_ASYNC) == 0) { // check if this was a valid address\n#endif\n        ret = thread_get_state(thread,x86_THREAD_STATE64,(thread_state_t)&state,&count);\n        HANDLE_MACH_ERROR(\"thread_get_state(2)\",ret);\n        old_state = state;\n        // memset(&state,0,sizeof(x86_thread_state64_t));\n        // Setup libunwind information\n        state.__rsp = (uint64_t)signal_stack + sig_stack_size;\n        state.__rsp -= sizeof(unw_context_t);\n        state.__rsp &= -16;\n        unw_context_t *uc = (unw_context_t*)state.__rsp;\n        state.__rsp -= 512;\n        // This is for alignment. In particular note that the sizeof(void*) is necessary\n        // since it would usually specify the return address (i.e., we are aligning the call\n        // frame to a 16 byte boundary as required by the abi, but the stack pointer\n        // to point to the byte beyond that. Not doing this leads to funny behavior on\n        // the first access to an external function will fail due to stack misalignment\n        state.__rsp &= -16;\n        state.__rsp -= sizeof(void*);\n        memset(uc,0,sizeof(unw_context_t));\n        memcpy(uc,&old_state,sizeof(x86_thread_state64_t));\n        state.__rdi = (uint64_t)uc;\n        if (is_addr_on_stack((void*)fault_addr)) {\n            state.__rip = (uint64_t)darwin_stack_overflow_handler;\n        }\n#ifdef SEGV_EXCEPTION\n        else if (msync((void*)(fault_addr & ~(jl_page_size - 1)), 1, MS_ASYNC) != 0) {\n            // no page mapped at this address\n            state.__rip = (uint64_t)darwin_segv_handler;\n        }\n#endif\n        else {\n            if (!(exc_state.__err & WRITE_FAULT))\n                return KERN_INVALID_ARGUMENT; // rethrow the SEGV since it wasn't an error with writing to read-only memory\n            state.__rip = (uint64_t)darwin_accerr_handler;\n        }\n\n        state.__rbp = state.__rsp;\n        ret = thread_set_state(thread,x86_THREAD_STATE64,(thread_state_t)&state,count);\n        HANDLE_MACH_ERROR(\"thread_set_state\",ret);\n        return KERN_SUCCESS;\n    }\n    else {\n        ret = thread_get_state(thread,x86_THREAD_STATE64,(thread_state_t)&state,&count);\n        HANDLE_MACH_ERROR(\"thread_get_state(3)\",ret);\n        jl_safe_printf(\"\\nsignal (%d): %s\\n\", SIGSEGV, strsignal(SIGSEGV));\n        bt_size = rec_backtrace_ctx(bt_data, MAX_BT_SIZE, (unw_context_t*)&state);\n        jlbacktrace();\n        return KERN_INVALID_ARGUMENT;\n    }\n}\n\nvoid attach_exception_port()\n{\n    kern_return_t ret;\n    // http://www.opensource.apple.com/source/xnu/xnu-2782.1.97/osfmk/man/thread_set_exception_ports.html\n    ret = thread_set_exception_ports(mach_thread_self(),EXC_MASK_BAD_ACCESS,segv_port,EXCEPTION_DEFAULT,MACHINE_THREAD_STATE);\n    HANDLE_MACH_ERROR(\"thread_set_exception_ports\",ret);\n}\n\n#ifdef LIBOSXUNWIND\n//\n// OS X\n//\n#include <mach/mach_traps.h>\n#include <mach/task.h>\n#include <mach/mig_errors.h>\n#include <mach/clock.h>\n#include <mach/clock_types.h>\n#include <mach/clock_reply.h>\n#include <assert.h>\n\n#define HANDLE_MACH_ERROR(msg, retval) \\\n    if (retval!=KERN_SUCCESS) { mach_error(msg \":\", (retval)); jl_exit(1); }\n\nstatic pthread_t profiler_thread;\nstatic mach_port_t main_thread;\nclock_serv_t clk;\nstatic int profile_started = 0;\nstatic mach_port_t profile_port = 0;\nvolatile static int forceDwarf = -2;\nstatic unw_context_t profiler_uc;\nmach_timespec_t timerprof;\n\nstatic kern_return_t profiler_segv_handler\n                (mach_port_t                          exception_port,\n                 mach_port_t                                  thread,\n                 mach_port_t                                    task,\n                 exception_type_t                          exception,\n                 exception_data_t                               code,\n                 mach_msg_type_number_t                   code_count)\n{\n    assert(thread == mach_profiler_thread);\n    x86_thread_state64_t state;\n\n    // Not currently unwinding. Raise regular segfault\n    if (forceDwarf == -2)\n        return KERN_INVALID_ARGUMENT;\n\n    if (forceDwarf == 0)\n        forceDwarf = 1;\n    else\n        forceDwarf = -1;\n\n    unsigned int count = MACHINE_THREAD_STATE_COUNT;\n\n    thread_get_state(thread,x86_THREAD_STATE64,(thread_state_t)&state,&count);\n\n    // don't change cs fs gs rflags\n    uint64_t cs = state.__cs;\n    uint64_t fs = state.__fs;\n    uint64_t gs = state.__gs;\n    uint64_t rflags = state.__rflags;\n\n    memcpy(&state,&profiler_uc,sizeof(x86_thread_state64_t));\n\n    state.__cs = cs;\n    state.__fs = fs;\n    state.__gs = gs;\n    state.__rflags = rflags;\n\n    kern_return_t ret = thread_set_state(thread,x86_THREAD_STATE64,(thread_state_t)&state,count);\n    HANDLE_MACH_ERROR(\"thread_set_state\",ret);\n\n    return KERN_SUCCESS;\n}\n\nvoid *mach_profile_listener(void *arg)\n{\n    (void)arg;\n    int max_size = 512;\n    attach_exception_port();\n    mach_profiler_thread = mach_thread_self();\n    mig_reply_error_t *bufRequest = (mig_reply_error_t *) malloc(max_size);\n    while (1) {\n        kern_return_t ret = mach_msg(&bufRequest->Head, MACH_RCV_MSG,\n                                     0, max_size, profile_port,\n                                     MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);\n        HANDLE_MACH_ERROR(\"mach_msg\",ret);\n        if (bt_size_cur < bt_size_max) {\n            kern_return_t ret;\n            // Suspend the thread so we may safely sample it\n            ret = thread_suspend(main_thread);\n            HANDLE_MACH_ERROR(\"thread_suspend\",ret);\n\n            // Do the actual sampling\n            unsigned int count = MACHINE_THREAD_STATE_COUNT;\n            x86_thread_state64_t state;\n\n            // Get the state of the suspended thread\n            ret = thread_get_state(main_thread,x86_THREAD_STATE64,(thread_state_t)&state,&count);\n            HANDLE_MACH_ERROR(\"thread_get_state\",ret);\n\n            // Initialize the unwind context with the suspend thread's state\n            unw_context_t uc;\n            memset(&uc,0,sizeof(unw_context_t));\n            memcpy(&uc,&state,sizeof(x86_thread_state64_t));\n\n            /*\n             *  Unfortunately compact unwind info is incorrectly generated for quite a number of\n             *  libraries by quite a large number of compilers. We can fall back to DWARF unwind info\n             *  in some cases, but in quite a number of cases (especially libraries not compiled in debug\n             *  mode, only the compact unwind info may be available). Even more unfortunately, there is no\n             *  way to detect such bogus compact unwind info (other than noticing the resulting segfault).\n             *  What we do here is ugly, but necessary until the compact unwind info situation improves.\n             *  We try to use the compact unwind info and if that results in a segfault, we retry with DWARF info.\n             *  Note that in a small number of cases this may result in bogus stack traces, but at least the topmost\n             *  entry will always be correct, and the number of cases in which this is an issue is rather small.\n             *  Other than that, this implementation is not incorrect as the other thread is paused while we are profiling\n             *  and during stack unwinding we only ever read memory, but never write it.\n             */\n\n            forceDwarf = 0;\n            unw_getcontext(&profiler_uc);\n\n            if (forceDwarf == 0) {\n                // Save the backtrace\n                bt_size_cur += rec_backtrace_ctx((ptrint_t*)bt_data_prof+bt_size_cur, bt_size_max-bt_size_cur-1, &uc);\n            }\n            else if (forceDwarf == 1) {\n                bt_size_cur += rec_backtrace_ctx_dwarf((ptrint_t*)bt_data_prof+bt_size_cur, bt_size_max-bt_size_cur-1, &uc);\n            }\n            else if (forceDwarf == -1) {\n                jl_safe_printf(\"WARNING: profiler attempt to access an invalid memory location\\n\");\n            }\n\n            forceDwarf = -2;\n\n            // Mark the end of this block with 0\n            bt_data_prof[bt_size_cur] = 0;\n            bt_size_cur++;\n\n            // We're done! Resume the thread.\n            ret = thread_resume(main_thread);\n            HANDLE_MACH_ERROR(\"thread_resume\",ret)\n\n            if (running) {\n                // Reset the alarm\n                ret = clock_alarm(clk, TIME_RELATIVE, timerprof, profile_port);\n                HANDLE_MACH_ERROR(\"clock_alarm\",ret)\n            }\n        }\n    }\n}\n\nDLLEXPORT int jl_profile_start_timer(void)\n{\n    kern_return_t ret;\n    if (!profile_started) {\n        mach_port_t self = mach_task_self();\n        main_thread = mach_thread_self();\n\n        ret = host_get_clock_service(mach_host_self(), SYSTEM_CLOCK, (clock_serv_t *)&clk);\n        HANDLE_MACH_ERROR(\"host_get_clock_service\", ret);\n\n        ret = mach_port_allocate(self,MACH_PORT_RIGHT_RECEIVE,&profile_port);\n        HANDLE_MACH_ERROR(\"mach_port_allocate\",ret);\n\n        // Alright, create a thread to serve as the listener for exceptions\n        pthread_attr_t attr;\n        if (pthread_attr_init(&attr) != 0) {\n            jl_error(\"pthread_attr_init failed\");\n        }\n        pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_DETACHED);\n        if (pthread_create(&profiler_thread,&attr,mach_profile_listener,NULL) != 0) {\n            jl_error(\"pthread_create failed\");\n        }\n        pthread_attr_destroy(&attr);\n\n        profile_started = 1;\n    }\n\n    timerprof.tv_sec = nsecprof/GIGA;\n    timerprof.tv_nsec = nsecprof%GIGA;\n\n    running = 1;\n    ret = clock_alarm(clk, TIME_RELATIVE, timerprof, profile_port);\n    HANDLE_MACH_ERROR(\"clock_alarm\",ret);\n\n    return 0;\n}\n\nDLLEXPORT void jl_profile_stop_timer(void)\n{\n    running = 0;\n}\n#else\n#include \"signals-bsd.c\"\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/src/julia.h": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n#ifndef JULIA_H\n#define JULIA_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"options.h\"\n\n#include \"libsupport.h\"\n#include <stdint.h>\n#include <string.h>\n\n#include \"htable.h\"\n#include \"arraylist.h\"\n\n#include <setjmp.h>\n#ifndef _OS_WINDOWS_\n#  define jl_jmp_buf sigjmp_buf\n#  if defined(_CPU_ARM_)\n#    define MAX_ALIGN 8\n#  elif defined(_CPU_AARCH64_)\n// int128 is 16 bytes aligned on aarch64\n#    define MAX_ALIGN 16\n#  else\n#    define MAX_ALIGN sizeof(void*)\n#  endif\n#else\n#  define jl_jmp_buf jmp_buf\n#  include <malloc.h> //for _resetstkoflw\n#  define MAX_ALIGN 8\n#endif\n\n#ifdef _P64\n#define NWORDS(sz) (((sz)+7)>>3)\n#else\n#define NWORDS(sz) (((sz)+3)>>2)\n#endif\n\n#if __GNUC__\n#define NORETURN __attribute__ ((noreturn))\n#else\n#define NORETURN\n#endif\n\n#define container_of(ptr, type, member) \\\n    ((type *) ((char *)(ptr) - offsetof(type, member)))\n\n#ifdef _MSC_VER\n#if _WIN64\n#define JL_ATTRIBUTE_ALIGN_PTRSIZE(x) __declspec(align(8)) x\n#else\n#define JL_ATTRIBUTE_ALIGN_PTRSIZE(x) __declspec(align(4)) x\n#endif\n#elif __GNUC__\n#define JL_ATTRIBUTE_ALIGN_PTRSIZE(x) x __attribute__ ((aligned (sizeof(void*))))\n#else\n#define JL_ATTRIBUTE_ALIGN_PTRSIZE(x)\n#endif\n\n// threading ------------------------------------------------------------------\n\n// WARNING: Threading support is incomplete.  Changing the 1 to a 0 will break Julia.\n// Nonetheless, we define JL_THREAD and use it to give advanced notice to maintainers\n// of what eventual threading support will change.\n#if 1\n// Definition for compiling non-thread-safe Julia.\n#  define JL_THREAD\n#elif !defined(_OS_WINDOWS_)\n// Definition for compiling Julia on platforms with GCC __thread.\n#  define JL_THREAD __thread\n#else\n// Definition for compiling Julia on Windows\n#  define JL_THREAD __declspec(thread)\n#endif\n\n// core data types ------------------------------------------------------------\n\n#ifndef _COMPILER_MICROSOFT_\n#define JL_DATA_TYPE \\\n    struct _jl_value_t *fieldptr0[0];\n#else\n#define JL_DATA_TYPE\n#endif\n\ntypedef struct _jl_value_t {\n    JL_DATA_TYPE\n#if !defined(__GNUC__) || __GNUC__ < 6\n    // GCC 6 is not happy about flexible array member in otherwise empty struct.\n    // Only remove the definition on GCC >= 6 to avoid breaking existing setup.\n    struct _jl_value_t *fieldptr[];\n#endif\n} jl_value_t;\n\ntypedef struct {\n    union {\n        jl_value_t *type; // 16-bytes aligned\n        uintptr_t type_bits;\n        struct {\n            uintptr_t gc_bits:2;\n        };\n    };\n    jl_value_t value;\n} jl_taggedvalue_t;\n\n#define jl_astaggedvalue__MACRO(v) container_of((v),jl_taggedvalue_t,value)\n#define jl_typeof__MACRO(v) ((jl_value_t*)(jl_astaggedvalue__MACRO(v)->type_bits&~(uintptr_t)15))\n#define jl_astaggedvalue jl_astaggedvalue__MACRO\n#define jl_typeof jl_typeof__MACRO\nstatic inline void jl_set_typeof(void *v, void *t)\n{\n    jl_taggedvalue_t *tag = jl_astaggedvalue(v);\n    tag->type = (jl_value_t*)t;\n}\n#define jl_typeis(v,t) (jl_typeof(v)==(jl_value_t*)(t))\n\ntypedef struct _jl_sym_t {\n    JL_DATA_TYPE\n    struct _jl_sym_t *left;\n    struct _jl_sym_t *right;\n    uptrint_t hash;    // precomputed hash value\n    JL_ATTRIBUTE_ALIGN_PTRSIZE(char name[]);\n} jl_sym_t;\n\ntypedef struct _jl_gensym_t {\n    JL_DATA_TYPE\n    ssize_t id;\n} jl_gensym_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    size_t length;\n    jl_value_t *data[];\n} jl_svec_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    void *data;\n#ifdef STORE_ARRAY_LEN\n    size_t length;\n#endif\n    union {\n        struct {\n            /*\n              how - allocation style\n              0 = data is inlined, or a foreign pointer we don't manage\n              1 = julia-allocated buffer that needs to be marked\n              2 = malloc-allocated pointer this array object manages\n              3 = has a pointer to the Array that owns the data\n            */\n            unsigned short how:2;\n            unsigned short ndims:10;\n            unsigned short pooled:1;\n            unsigned short ptrarray:1;  // representation is pointer array\n            unsigned short isshared:1;  // data is shared by multiple Arrays\n            unsigned short isaligned:1; // data allocated with memalign\n        };\n        unsigned short flags;\n    };\n    uint16_t elsize;\n    uint32_t offset;  // for 1-d only. does not need to get big.\n    size_t nrows;\n    union {\n        // 1d\n        size_t maxsize;\n        // Nd\n        size_t ncols;\n    };\n    // other dim sizes go here for ndims > 2\n\n    // followed by alignment padding and inline data, or owner pointer\n} jl_array_t;\n// compute # of extra words needed to store dimensions\nSTATIC_INLINE int jl_array_ndimwords(uint32_t ndims)\n{\n    return (ndims < 3 ? 0 : ndims-2);\n}\n\ntypedef jl_value_t *(*jl_fptr_t)(jl_value_t*, jl_value_t**, uint32_t);\n\ntypedef struct _jl_datatype_t jl_tupletype_t;\n\ntypedef struct _jl_lambda_info_t {\n    JL_DATA_TYPE\n    // this holds the static data for a function:\n    // a syntax tree, static parameters, and (if it has been compiled)\n    // a function pointer.\n    // this is the stuff that's shared among different instantiations\n    // (different environments) of a closure.\n    jl_value_t *ast;\n    // sparams is a vector (symbol, value, symbol, value, ...)\n    jl_svec_t *sparams;\n    jl_value_t *tfunc;\n    jl_sym_t *name;  // for error reporting\n    jl_array_t *roots;  // pointers in generated code\n    jl_tupletype_t *specTypes;  // argument types this is specialized for\n    // a slower-but-works version of this function as a fallback\n    struct _jl_function_t *unspecialized;\n    // array of all lambda infos with code generated from this one\n    jl_array_t *specializations;\n    struct _jl_module_t *module;\n    struct _jl_lambda_info_t *def;  // original this is specialized from\n    jl_value_t *capt;  // captured var info\n    jl_sym_t *file;\n    int32_t line;\n    int8_t inferred;\n\n    // hidden fields:\n    // flag telling if inference is running on this function\n    // used to avoid infinite recursion\n    int8_t inInference : 1;\n    int8_t inCompile : 1;\n    jl_fptr_t fptr;             // jlcall entry point\n    void *functionObject;       // jlcall llvm Function\n    void *cFunctionList;        // c callable llvm Functions\n\n    // specialized llvm Function (common core for the other two)\n    void *specFunctionObject;\n    int32_t functionID; // index that this function will have in the codegen table\n    int32_t specFunctionID; // index that this specFunction will have in the codegen table\n} jl_lambda_info_t;\n\ntypedef struct _jl_function_t {\n    JL_DATA_TYPE\n    jl_fptr_t fptr;\n    jl_value_t *env;\n    jl_lambda_info_t *linfo;\n} jl_function_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_svec_t *parameters;\n    jl_value_t *body;\n} jl_typector_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    struct _jl_module_t *module;\n    jl_svec_t *names;  // field names\n    // if this is the name of a parametric type, this field points to the\n    // original type.\n    // a type alias, for example, might make a type constructor that is\n    // not the original.\n    jl_value_t *primary;\n    jl_svec_t *cache;        // sorted array\n    jl_svec_t *linearcache;  // unsorted array\n    ptrint_t uid;\n} jl_typename_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_svec_t *types;\n} jl_uniontype_t;\n\ntypedef struct {\n    uint8_t offset;   // offset relative to data start, excluding type tag\n    uint8_t size:7;\n    uint8_t isptr:1;\n} jl_fielddesc8_t;\n\ntypedef struct {\n    uint16_t offset;   // offset relative to data start, excluding type tag\n    uint16_t size:15;\n    uint16_t isptr:1;\n} jl_fielddesc16_t;\n\ntypedef struct {\n    uint32_t offset;   // offset relative to data start, excluding type tag\n    uint32_t size:31;\n    uint32_t isptr:1;\n} jl_fielddesc32_t;\n\ntypedef struct _jl_datatype_t {\n    JL_DATA_TYPE\n    jl_typename_t *name;\n    struct _jl_datatype_t *super;\n    jl_svec_t *parameters;\n    jl_svec_t *types;\n    jl_value_t *instance;  // for singletons\n    int32_t size;\n    uint8_t abstract;\n    uint8_t mutabl;\n    uint8_t pointerfree;\n    int32_t ninitialized;\n    // hidden fields:\n    uint32_t nfields;\n    uint32_t alignment : 29;  // strictest alignment over all fields\n    uint32_t haspadding : 1;  // has internal undefined bytes\n    uint32_t fielddesc_type : 2; // 0 -> 8, 1 -> 16, 2 -> 32\n    uint32_t uid;\n    void *struct_decl;  //llvm::Value*\n    void *ditype; // llvm::MDNode* to be used as llvm::DIType(ditype)\n    size_t fields[];\n} jl_datatype_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    jl_value_t *lb;   // lower bound\n    jl_value_t *ub;   // upper bound\n    uint8_t bound;    // part of a constraint environment\n} jl_tvar_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_value_t *value;\n} jl_weakref_t;\n\ntypedef struct {\n    // not first-class\n    jl_sym_t *name;\n    jl_value_t *value;\n    jl_value_t *globalref;  // cached GlobalRef for this binding\n    struct _jl_module_t *owner;  // for individual imported bindings\n    unsigned constp:1;\n    unsigned exportp:1;\n    unsigned imported:1;\n    unsigned deprecated:1;\n} jl_binding_t;\n\ntypedef struct _jl_module_t {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    struct _jl_module_t *parent;\n    htable_t bindings;\n    arraylist_t usings;  // modules with all bindings potentially imported\n    jl_array_t *constant_table;\n    jl_function_t *call_func;  // cached lookup of `call` within this module\n    uint8_t istopmod;\n    uint8_t std_imports;  // only for temporarily deprecating `importall Base.Operators`\n    uint64_t uuid;\n} jl_module_t;\n\ntypedef struct _jl_methlist_t {\n    JL_DATA_TYPE\n    jl_tupletype_t *sig;\n    int8_t va;\n    int8_t isstaged;\n    jl_svec_t *tvars;\n    jl_function_t *func;\n    // cache of specializations of this method for invoke(), i.e.\n    // cases where this method was called even though it was not necessarily\n    // the most specific for the argument types.\n    struct _jl_methtable_t *invokes;\n    // TODO: pointer from specialized to original method\n    //jl_function_t *orig_method;\n    struct _jl_methlist_t *next;\n} jl_methlist_t;\n\ntypedef struct _jl_methtable_t {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    jl_methlist_t *defs;\n    jl_methlist_t *cache;\n    jl_array_t *cache_arg1;\n    jl_array_t *cache_targ;\n    ptrint_t max_args;  // max # of non-vararg arguments in a signature\n    jl_function_t *kwsorter;  // keyword argument sorter function\n    jl_module_t *module; // used for incremental serialization to locate original binding\n#ifdef JL_GF_PROFILE\n    int ncalls;\n#endif\n} jl_methtable_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_sym_t *head;\n    jl_array_t *args;\n    jl_value_t *etype;\n} jl_expr_t;\n\n// constants and type objects -------------------------------------------------\n\nextern DLLEXPORT jl_datatype_t *jl_any_type;\nextern DLLEXPORT jl_datatype_t *jl_type_type;\nextern DLLEXPORT jl_tvar_t     *jl_typetype_tvar;\nextern DLLEXPORT jl_datatype_t *jl_typetype_type;\nextern DLLEXPORT jl_value_t    *jl_ANY_flag;\nextern DLLEXPORT jl_datatype_t *jl_typename_type;\nextern DLLEXPORT jl_datatype_t *jl_typector_type;\nextern DLLEXPORT jl_datatype_t *jl_sym_type;\nextern DLLEXPORT jl_datatype_t *jl_symbol_type;\nextern DLLEXPORT jl_datatype_t *jl_gensym_type;\nextern DLLEXPORT jl_datatype_t *jl_simplevector_type;\nextern DLLEXPORT jl_typename_t *jl_tuple_typename;\nextern DLLEXPORT jl_datatype_t *jl_anytuple_type;\n#define jl_tuple_type jl_anytuple_type\nextern DLLEXPORT jl_datatype_t *jl_ntuple_type;\nextern DLLEXPORT jl_typename_t *jl_ntuple_typename;\nextern DLLEXPORT jl_datatype_t *jl_vararg_type;\nextern DLLEXPORT jl_datatype_t *jl_tvar_type;\nextern DLLEXPORT jl_datatype_t *jl_task_type;\n\nextern DLLEXPORT jl_datatype_t *jl_uniontype_type;\nextern DLLEXPORT jl_datatype_t *jl_datatype_type;\n\nextern DLLEXPORT jl_value_t *jl_bottom_type;\nextern DLLEXPORT jl_datatype_t *jl_lambda_info_type;\nextern DLLEXPORT jl_datatype_t *jl_module_type;\nextern DLLEXPORT jl_datatype_t *jl_function_type;\nextern DLLEXPORT jl_datatype_t *jl_abstractarray_type;\nextern DLLEXPORT jl_datatype_t *jl_densearray_type;\nextern DLLEXPORT jl_datatype_t *jl_array_type;\nextern DLLEXPORT jl_typename_t *jl_array_typename;\nextern DLLEXPORT jl_datatype_t *jl_weakref_type;\nextern DLLEXPORT jl_datatype_t *jl_ascii_string_type;\nextern DLLEXPORT jl_datatype_t *jl_utf8_string_type;\nextern DLLEXPORT jl_datatype_t *jl_errorexception_type;\nextern DLLEXPORT jl_datatype_t *jl_argumenterror_type;\nextern DLLEXPORT jl_datatype_t *jl_loaderror_type;\nextern DLLEXPORT jl_datatype_t *jl_initerror_type;\nextern DLLEXPORT jl_datatype_t *jl_typeerror_type;\nextern DLLEXPORT jl_datatype_t *jl_methoderror_type;\nextern DLLEXPORT jl_datatype_t *jl_undefvarerror_type;\nextern DLLEXPORT jl_value_t *jl_stackovf_exception;\nextern DLLEXPORT jl_value_t *jl_memory_exception;\nextern DLLEXPORT jl_value_t *jl_readonlymemory_exception;\nextern DLLEXPORT jl_value_t *jl_diverror_exception;\nextern DLLEXPORT jl_value_t *jl_domain_exception;\nextern DLLEXPORT jl_value_t *jl_overflow_exception;\nextern DLLEXPORT jl_value_t *jl_inexact_exception;\nextern DLLEXPORT jl_value_t *jl_undefref_exception;\nextern DLLEXPORT jl_value_t *jl_interrupt_exception;\nextern DLLEXPORT jl_datatype_t *jl_boundserror_type;\nextern DLLEXPORT jl_value_t *jl_an_empty_cell;\n\nextern DLLEXPORT jl_datatype_t *jl_bool_type;\nextern DLLEXPORT jl_datatype_t *jl_char_type;\nextern DLLEXPORT jl_datatype_t *jl_int8_type;\nextern DLLEXPORT jl_datatype_t *jl_uint8_type;\nextern DLLEXPORT jl_datatype_t *jl_int16_type;\nextern DLLEXPORT jl_datatype_t *jl_uint16_type;\nextern DLLEXPORT jl_datatype_t *jl_int32_type;\nextern DLLEXPORT jl_datatype_t *jl_uint32_type;\nextern DLLEXPORT jl_datatype_t *jl_int64_type;\nextern DLLEXPORT jl_datatype_t *jl_uint64_type;\nextern DLLEXPORT jl_datatype_t *jl_float16_type;\nextern DLLEXPORT jl_datatype_t *jl_float32_type;\nextern DLLEXPORT jl_datatype_t *jl_float64_type;\nextern DLLEXPORT jl_datatype_t *jl_floatingpoint_type;\nextern DLLEXPORT jl_datatype_t *jl_number_type;\nextern DLLEXPORT jl_datatype_t *jl_void_type;\nextern DLLEXPORT jl_datatype_t *jl_complex_type;\nextern DLLEXPORT jl_datatype_t *jl_signed_type;\nextern DLLEXPORT jl_datatype_t *jl_voidpointer_type;\nextern DLLEXPORT jl_datatype_t *jl_pointer_type;\nextern DLLEXPORT jl_datatype_t *jl_ref_type;\n\nextern DLLEXPORT jl_value_t *jl_array_uint8_type;\nextern DLLEXPORT jl_value_t *jl_array_any_type;\nextern DLLEXPORT jl_value_t *jl_array_symbol_type;\nextern DLLEXPORT jl_datatype_t *jl_expr_type;\nextern DLLEXPORT jl_datatype_t *jl_symbolnode_type;\nextern DLLEXPORT jl_datatype_t *jl_globalref_type;\nextern DLLEXPORT jl_datatype_t *jl_linenumbernode_type;\nextern DLLEXPORT jl_datatype_t *jl_labelnode_type;\nextern DLLEXPORT jl_datatype_t *jl_gotonode_type;\nextern DLLEXPORT jl_datatype_t *jl_quotenode_type;\nextern DLLEXPORT jl_datatype_t *jl_newvarnode_type;\nextern DLLEXPORT jl_datatype_t *jl_topnode_type;\nextern DLLEXPORT jl_datatype_t *jl_intrinsic_type;\nextern DLLEXPORT jl_datatype_t *jl_methtable_type;\nextern DLLEXPORT jl_datatype_t *jl_method_type;\n\nextern DLLEXPORT jl_svec_t *jl_emptysvec;\nextern DLLEXPORT jl_value_t *jl_emptytuple;\nextern DLLEXPORT jl_value_t *jl_true;\nextern DLLEXPORT jl_value_t *jl_false;\nextern DLLEXPORT jl_value_t *jl_nothing;\n\n// some important symbols\nextern jl_sym_t *call_sym;\nextern jl_sym_t *dots_sym;    extern jl_sym_t *vararg_sym;\nextern jl_sym_t *quote_sym;   extern jl_sym_t *newvar_sym;\nextern jl_sym_t *top_sym;     extern jl_sym_t *dot_sym;\nextern jl_sym_t *line_sym;    extern jl_sym_t *toplevel_sym;\nextern DLLEXPORT jl_sym_t *jl_incomplete_sym;\nextern jl_sym_t *error_sym;   extern jl_sym_t *amp_sym;\nextern jl_sym_t *module_sym;  extern jl_sym_t *colons_sym;\nextern jl_sym_t *export_sym;  extern jl_sym_t *import_sym;\nextern jl_sym_t *importall_sym; extern jl_sym_t *using_sym;\nextern jl_sym_t *goto_sym;    extern jl_sym_t *goto_ifnot_sym;\nextern jl_sym_t *label_sym;   extern jl_sym_t *return_sym;\nextern jl_sym_t *lambda_sym;  extern jl_sym_t *assign_sym;\nextern jl_sym_t *null_sym;    extern jl_sym_t *body_sym;\nextern jl_sym_t *macro_sym;   extern jl_sym_t *method_sym;\nextern jl_sym_t *enter_sym;   extern jl_sym_t *leave_sym;\nextern jl_sym_t *exc_sym;     extern jl_sym_t *new_sym;\nextern jl_sym_t *static_typeof_sym; extern jl_sym_t *kw_sym;\nextern jl_sym_t *const_sym;   extern jl_sym_t *thunk_sym;\nextern jl_sym_t *anonymous_sym;  extern jl_sym_t *underscore_sym;\nextern jl_sym_t *abstracttype_sym; extern jl_sym_t *bitstype_sym;\nextern jl_sym_t *compositetype_sym; extern jl_sym_t *type_goto_sym;\nextern jl_sym_t *global_sym;  extern jl_sym_t *tuple_sym;\nextern jl_sym_t *boundscheck_sym; extern jl_sym_t *copyast_sym;\nextern jl_sym_t *fastmath_sym;\nextern jl_sym_t *simdloop_sym; extern jl_sym_t *meta_sym;\nextern jl_sym_t *arrow_sym; extern jl_sym_t *inert_sym;\n\n// gc -------------------------------------------------------------------------\n\ntypedef struct _jl_gcframe_t {\n    size_t nroots;\n    struct _jl_gcframe_t *prev;\n    // actual roots go here\n} jl_gcframe_t;\n\n// NOTE: it is the caller's responsibility to make sure arguments are\n// rooted. foo(f(), g()) will not work, and foo can't do anything about it,\n// so the caller must do\n// jl_value_t *x=NULL, *y=NULL; JL_GC_PUSH(&x, &y);\n// x = f(); y = g(); foo(x, y)\n\nextern DLLEXPORT JL_THREAD jl_gcframe_t *jl_pgcstack;\n\n#define JL_GC_PUSH(...)                                                   \\\n  void *__gc_stkf[] = {(void*)((VA_NARG(__VA_ARGS__)<<1)|1), jl_pgcstack, \\\n                       __VA_ARGS__};                                      \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH1(arg1)                                                 \\\n  void *__gc_stkf[] = {(void*)3, jl_pgcstack, arg1};                      \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH2(arg1, arg2)                                           \\\n  void *__gc_stkf[] = {(void*)5, jl_pgcstack, arg1, arg2};                \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH3(arg1, arg2, arg3)                                     \\\n  void *__gc_stkf[] = {(void*)7, jl_pgcstack, arg1, arg2, arg3};          \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH4(arg1, arg2, arg3, arg4)                               \\\n  void *__gc_stkf[] = {(void*)9, jl_pgcstack, arg1, arg2, arg3, arg4};    \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH5(arg1, arg2, arg3, arg4, arg5)                               \\\n  void *__gc_stkf[] = {(void*)11, jl_pgcstack, arg1, arg2, arg3, arg4, arg5};    \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSHARGS(rts_var,n)                               \\\n  rts_var = ((jl_value_t**)alloca(((n)+2)*sizeof(jl_value_t*)))+2;    \\\n  ((void**)rts_var)[-2] = (void*)(((size_t)n)<<1);              \\\n  ((void**)rts_var)[-1] = jl_pgcstack;                          \\\n  memset((void*)rts_var, 0, (n)*sizeof(jl_value_t*));           \\\n  jl_pgcstack = (jl_gcframe_t*)&(((void**)rts_var)[-2])\n\n#define JL_GC_POP() (jl_pgcstack = jl_pgcstack->prev)\n\nvoid jl_gc_init(void);\nvoid jl_gc_setmark(jl_value_t *v);\nDLLEXPORT int jl_gc_enable(int on);\nDLLEXPORT int jl_gc_is_enabled(void);\nDLLEXPORT int64_t jl_gc_total_bytes(void);\nDLLEXPORT uint64_t jl_gc_total_hrtime(void);\nDLLEXPORT int64_t jl_gc_diff_total_bytes(void);\nvoid jl_gc_sync_total_bytes(void);\n\nDLLEXPORT void jl_gc_collect(int);\nDLLEXPORT void jl_gc_preserve(jl_value_t *v);\nDLLEXPORT void jl_gc_unpreserve(void);\nDLLEXPORT int jl_gc_n_preserved_values(void);\n\nDLLEXPORT void jl_gc_add_finalizer(jl_value_t *v, jl_function_t *f);\nDLLEXPORT void jl_finalize(jl_value_t *o);\nDLLEXPORT jl_weakref_t *jl_gc_new_weakref(jl_value_t *value);\nvoid jl_gc_free_array(jl_array_t *a);\nvoid jl_gc_track_malloced_array(jl_array_t *a);\nvoid jl_gc_count_allocd(size_t sz);\nvoid jl_gc_run_all_finalizers(void);\nDLLEXPORT jl_value_t *jl_gc_alloc_0w(void);\nDLLEXPORT jl_value_t *jl_gc_alloc_1w(void);\nDLLEXPORT jl_value_t *jl_gc_alloc_2w(void);\nDLLEXPORT jl_value_t *jl_gc_alloc_3w(void);\nvoid *allocb(size_t sz);\nvoid *reallocb(void*, size_t);\nDLLEXPORT jl_value_t *jl_gc_allocobj(size_t sz);\n\nDLLEXPORT void jl_clear_malloc_data(void);\nDLLEXPORT int64_t jl_gc_num_pause(void);\nDLLEXPORT int64_t jl_gc_num_full_sweep(void);\n\n// GC write barriers\nDLLEXPORT void jl_gc_queue_root(jl_value_t *root); // root isa jl_value_t*\nvoid gc_queue_binding(jl_binding_t *bnd);\nvoid gc_setmark_buf(void *buf, int);\n\nstatic inline void jl_gc_wb_binding(jl_binding_t *bnd, void *val) // val isa jl_value_t*\n{\n    if (__unlikely((jl_astaggedvalue(bnd)->gc_bits & 1) == 1 &&\n                   (jl_astaggedvalue(val)->gc_bits & 1) == 0))\n        gc_queue_binding(bnd);\n}\n\nstatic inline void jl_gc_wb(void *parent, void *ptr) // parent and ptr isa jl_value_t*\n{\n    if (__unlikely((jl_astaggedvalue(parent)->gc_bits & 1) == 1 &&\n                   (jl_astaggedvalue(ptr)->gc_bits & 1) == 0))\n        jl_gc_queue_root((jl_value_t*)parent);\n}\n\nstatic inline void jl_gc_wb_buf(void *parent, void *bufptr) // parent isa jl_value_t*\n{\n    // if parent is marked and buf is not\n    if (__unlikely((jl_astaggedvalue(parent)->gc_bits & 1) == 1))\n        //            (jl_astaggedvalue(bufptr)->gc_bits) != 1))\n        gc_setmark_buf(bufptr, jl_astaggedvalue(parent)->gc_bits);\n}\n\nstatic inline void jl_gc_wb_back(void *ptr) // ptr isa jl_value_t*\n{\n    // if ptr is marked\n    if (__unlikely((jl_astaggedvalue(ptr)->gc_bits & 1) == 1)) {\n        jl_gc_queue_root((jl_value_t*)ptr);\n    }\n}\n\nDLLEXPORT void *jl_gc_managed_malloc(size_t sz);\nDLLEXPORT void *jl_gc_managed_realloc(void *d, size_t sz, size_t oldsz, int isaligned, jl_value_t* owner);\n\n// object accessors -----------------------------------------------------------\n\n#define jl_typeis(v,t) (jl_typeof(v)==(jl_value_t*)(t))\n\n#define jl_svec_len(t)              (((jl_svec_t*)(t))->length)\n#define jl_svec_set_len_unsafe(t,n) (((jl_svec_t*)(t))->length=(n))\n#define jl_svec_data(t)             (((jl_svec_t*)(t))->data)\n\nSTATIC_INLINE jl_value_t *jl_svecref(void *t, size_t i)\n{\n    assert(jl_typeis(t,jl_simplevector_type));\n    assert(i < jl_svec_len(t));\n    return jl_svec_data(t)[i];\n}\nSTATIC_INLINE jl_value_t *jl_svecset(void *t, size_t i, void *x)\n{\n    assert(jl_typeis(t,jl_simplevector_type));\n    assert(i < jl_svec_len(t));\n    jl_svec_data(t)[i] = (jl_value_t*)x;\n    if (x) jl_gc_wb(t, x);\n    return (jl_value_t*)x;\n}\n\n#ifdef STORE_ARRAY_LEN\n#define jl_array_len(a)   (((jl_array_t*)(a))->length)\n#else\nDLLEXPORT size_t jl_array_len_(jl_array_t *a);\n#define jl_array_len(a)   jl_array_len_((jl_array_t*)(a))\n#endif\n#define jl_array_data(a)  ((void*)((jl_array_t*)(a))->data)\n#define jl_array_dim(a,i) ((&((jl_array_t*)(a))->nrows)[i])\n#define jl_array_dim0(a)  (((jl_array_t*)(a))->nrows)\n#define jl_array_nrows(a) (((jl_array_t*)(a))->nrows)\n#define jl_array_ndims(a) ((int32_t)(((jl_array_t*)a)->ndims))\n#define jl_array_data_owner_offset(ndims) (offsetof(jl_array_t,ncols) + sizeof(size_t)*(1+jl_array_ndimwords(ndims))) // in bytes\n#define jl_array_data_owner(a) (*((jl_value_t**)((char*)a + jl_array_data_owner_offset(jl_array_ndims(a)))))\n\nSTATIC_INLINE jl_value_t *jl_cellref(void *a, size_t i)\n{\n    assert(i < jl_array_len(a));\n    return ((jl_value_t**)(jl_array_data(a)))[i];\n}\nSTATIC_INLINE jl_value_t *jl_cellset(void *a, size_t i, void *x)\n{\n    assert(i < jl_array_len(a));\n    ((jl_value_t**)(jl_array_data(a)))[i] = (jl_value_t*)x;\n    if (x) {\n        if (((jl_array_t*)a)->how == 3) {\n            a = jl_array_data_owner(a);\n        }\n        jl_gc_wb(a, x);\n    }\n    return (jl_value_t*)x;\n}\n\n#define jl_exprarg(e,n) (((jl_value_t**)jl_array_data(((jl_expr_t*)(e))->args))[n])\n#define jl_exprargset(e, n, v) jl_cellset(((jl_expr_t*)(e))->args, n, v)\n#define jl_expr_nargs(e) jl_array_len(((jl_expr_t*)(e))->args)\n\n#define jl_fieldref(s,i) jl_get_nth_field(((jl_value_t*)s),i)\n#define jl_nfields(v)    jl_datatype_nfields(jl_typeof(v))\n\n// Not using jl_fieldref to avoid allocations\n#define jl_symbolnode_sym(s) (*(jl_sym_t**)s)\n#define jl_symbolnode_type(s) (((jl_value_t**)s)[1])\n#define jl_linenode_file(x) (*(jl_sym_t**)x)\n#define jl_linenode_line(x) (((ptrint_t*)x)[1])\n#define jl_labelnode_label(x) (((ptrint_t*)x)[0])\n#define jl_gotonode_label(x) (((ptrint_t*)x)[0])\n#define jl_globalref_mod(s) (*(jl_module_t**)s)\n#define jl_globalref_name(s) (((jl_sym_t**)s)[1])\n\n#define jl_nparams(t)  jl_svec_len(((jl_datatype_t*)(t))->parameters)\n#define jl_tparam0(t)  jl_svecref(((jl_datatype_t*)(t))->parameters, 0)\n#define jl_tparam1(t)  jl_svecref(((jl_datatype_t*)(t))->parameters, 1)\n#define jl_tparam(t,i) jl_svecref(((jl_datatype_t*)(t))->parameters, i)\n\n// get a pointer to the data in a datatype\n#define jl_data_ptr(v)  ((jl_value_t**)v)\n\n#define jl_cell_data(a)   ((jl_value_t**)((jl_array_t*)a)->data)\n#define jl_string_data(s) ((char*)((jl_array_t*)jl_data_ptr(s)[0])->data)\n#define jl_string_len(s)  (jl_array_len(((jl_array_t*)jl_data_ptr(s)[0])))\n#define jl_iostr_data(s)  ((char*)((jl_array_t*)jl_data_ptr(s)[0])->data)\n\n#define jl_gf_mtable(f) ((jl_methtable_t*)((jl_function_t*)(f))->env)\n#define jl_gf_name(f)   (jl_gf_mtable(f)->name)\n\n// struct type info\n#define jl_field_name(st,i)    (jl_sym_t*)jl_svecref(((jl_datatype_t*)st)->name->names, (i))\n#define jl_field_type(st,i)    jl_svecref(((jl_datatype_t*)st)->types, (i))\n#define jl_datatype_size(t)    (((jl_datatype_t*)t)->size)\n#define jl_datatype_nfields(t) (((jl_datatype_t*)(t))->nfields)\n\n#define DEFINE_FIELD_ACCESSORS(f)                                       \\\n    static inline uint32_t jl_field_##f(jl_datatype_t *st, int i)       \\\n    {                                                                   \\\n        if (st->fielddesc_type == 0) {                                  \\\n            return ((jl_fielddesc8_t*)st->fields)[i].f;                 \\\n        }                                                               \\\n        else if (st->fielddesc_type == 1) {                             \\\n            return ((jl_fielddesc16_t*)st->fields)[i].f;                \\\n        }                                                               \\\n        else {                                                          \\\n            return ((jl_fielddesc32_t*)st->fields)[i].f;                \\\n        }                                                               \\\n    }                                                                   \\\n    static inline void jl_field_set##f(jl_datatype_t *st, int i,        \\\n                                       uint32_t val)                    \\\n    {                                                                   \\\n        if (st->fielddesc_type == 0) {                                  \\\n            ((jl_fielddesc8_t*)st->fields)[i].f = val;                  \\\n        }                                                               \\\n        else if (st->fielddesc_type == 1) {                             \\\n            ((jl_fielddesc16_t*)st->fields)[i].f = val;                 \\\n        }                                                               \\\n        else {                                                          \\\n            ((jl_fielddesc32_t*)st->fields)[i].f = val;                 \\\n        }                                                               \\\n    }\n\nDEFINE_FIELD_ACCESSORS(offset)\nDEFINE_FIELD_ACCESSORS(size)\nDEFINE_FIELD_ACCESSORS(isptr)\n\nstatic inline uint32_t jl_fielddesc_size(int8_t fielddesc_type)\n{\n    if (fielddesc_type == 0) {\n        return sizeof(jl_fielddesc8_t);\n    }\n    else if (fielddesc_type == 1) {\n        return sizeof(jl_fielddesc16_t);\n    }\n    else {\n        return sizeof(jl_fielddesc32_t);\n    }\n}\n\n#undef DEFINE_FIELD_ACCESSORS\n\n// basic predicates -----------------------------------------------------------\n#define jl_is_nothing(v)     (((jl_value_t*)(v)) == ((jl_value_t*)jl_nothing))\n#define jl_is_tuple(v)       (((jl_datatype_t*)jl_typeof(v))->name == jl_tuple_typename)\n#define jl_is_svec(v)        jl_typeis(v,jl_simplevector_type)\n#define jl_is_simplevector(v) jl_is_svec(v)\n#define jl_is_datatype(v)    jl_typeis(v,jl_datatype_type)\n#define jl_is_pointerfree(t) (((jl_datatype_t*)t)->pointerfree)\n#define jl_is_mutable(t)     (((jl_datatype_t*)t)->mutabl)\n#define jl_is_mutable_datatype(t) (jl_is_datatype(t) && (((jl_datatype_t*)t)->mutabl))\n#define jl_is_immutable(t)   (!((jl_datatype_t*)t)->mutabl)\n#define jl_is_immutable_datatype(t) (jl_is_datatype(t) && (!((jl_datatype_t*)t)->mutabl))\n#define jl_is_uniontype(v)   jl_typeis(v,jl_uniontype_type)\n#define jl_is_typevar(v)     jl_typeis(v,jl_tvar_type)\n#define jl_is_typector(v)    jl_typeis(v,jl_typector_type)\n#define jl_is_TypeConstructor(v)    jl_typeis(v,jl_typector_type)\n#define jl_is_typename(v)    jl_typeis(v,jl_typename_type)\n#define jl_is_int8(v)        jl_typeis(v,jl_int8_type)\n#define jl_is_int16(v)       jl_typeis(v,jl_int16_type)\n#define jl_is_int32(v)       jl_typeis(v,jl_int32_type)\n#define jl_is_int64(v)       jl_typeis(v,jl_int64_type)\n#define jl_is_uint8(v)       jl_typeis(v,jl_uint8_type)\n#define jl_is_uint16(v)      jl_typeis(v,jl_uint16_type)\n#define jl_is_uint32(v)      jl_typeis(v,jl_uint32_type)\n#define jl_is_uint64(v)      jl_typeis(v,jl_uint64_type)\n#define jl_is_float(v)       jl_subtype(v,(jl_value_t*)jl_floatingpoint_type,1)\n#define jl_is_floattype(v)   jl_subtype(v,(jl_value_t*)jl_floatingpoint_type,0)\n#define jl_is_float32(v)     jl_typeis(v,jl_float32_type)\n#define jl_is_float64(v)     jl_typeis(v,jl_float64_type)\n#define jl_is_bool(v)        jl_typeis(v,jl_bool_type)\n#define jl_is_symbol(v)      jl_typeis(v,jl_sym_type)\n#define jl_is_gensym(v)      jl_typeis(v,jl_gensym_type)\n#define jl_is_expr(v)        jl_typeis(v,jl_expr_type)\n#define jl_is_symbolnode(v)  jl_typeis(v,jl_symbolnode_type)\n#define jl_is_globalref(v)   jl_typeis(v,jl_globalref_type)\n#define jl_is_labelnode(v)   jl_typeis(v,jl_labelnode_type)\n#define jl_is_gotonode(v)    jl_typeis(v,jl_gotonode_type)\n#define jl_is_quotenode(v)   jl_typeis(v,jl_quotenode_type)\n#define jl_is_newvarnode(v)  jl_typeis(v,jl_newvarnode_type)\n#define jl_is_topnode(v)     jl_typeis(v,jl_topnode_type)\n#define jl_is_linenode(v)    jl_typeis(v,jl_linenumbernode_type)\n#define jl_is_lambda_info(v) jl_typeis(v,jl_lambda_info_type)\n#define jl_is_module(v)      jl_typeis(v,jl_module_type)\n#define jl_is_mtable(v)      jl_typeis(v,jl_methtable_type)\n#define jl_is_task(v)        jl_typeis(v,jl_task_type)\n#define jl_is_func(v)        jl_typeis(v,jl_function_type)\n#define jl_is_function(v)    jl_is_func(v)\n#define jl_is_ascii_string(v) jl_typeis(v,jl_ascii_string_type)\n#define jl_is_utf8_string(v) jl_typeis(v,jl_utf8_string_type)\n#define jl_is_byte_string(v) (jl_is_ascii_string(v) || jl_is_utf8_string(v))\n#define jl_is_cpointer(v)    jl_is_cpointer_type(jl_typeof(v))\n#define jl_is_pointer(v)     jl_is_cpointer_type(jl_typeof(v))\n#define jl_is_gf(f)          (((jl_function_t*)(f))->fptr==jl_apply_generic)\n\nSTATIC_INLINE int jl_is_bitstype(void *v)\n{\n    return (jl_is_datatype(v) && jl_is_immutable(v) &&\n            jl_datatype_nfields(v) == 0 &&\n            !((jl_datatype_t*)(v))->abstract &&\n            ((jl_datatype_t*)(v))->size > 0);\n}\n\nSTATIC_INLINE int jl_is_structtype(void *v)\n{\n    return (jl_is_datatype(v) &&\n            (jl_datatype_nfields(v) > 0 ||\n             ((jl_datatype_t*)(v))->size == 0) &&\n            !((jl_datatype_t*)(v))->abstract);\n}\n\nSTATIC_INLINE int jl_isbits(void *t)   // corresponding to isbits() in julia\n{\n    return (jl_is_datatype(t) && !((jl_datatype_t*)t)->mutabl &&\n            ((jl_datatype_t*)t)->pointerfree && !((jl_datatype_t*)t)->abstract);\n}\n\nSTATIC_INLINE int jl_is_datatype_singleton(jl_datatype_t *d)\n{\n    return (d->instance != NULL ||\n            (!d->abstract && d->size == 0 && d != jl_sym_type && d->name != jl_array_typename &&\n             (d->name->names == jl_emptysvec || !d->mutabl)));\n}\n\nSTATIC_INLINE int jl_is_abstracttype(void *v)\n{\n    return (jl_is_datatype(v) && ((jl_datatype_t*)(v))->abstract);\n}\n\nSTATIC_INLINE int jl_is_array_type(void *t)\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_array_typename);\n}\n\nSTATIC_INLINE int jl_is_array(void *v)\n{\n    jl_value_t *t = jl_typeof(v);\n    return jl_is_array_type(t);\n}\n\nSTATIC_INLINE int jl_is_cpointer_type(jl_value_t *t)\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_pointer_type->name);\n}\n\nSTATIC_INLINE int jl_is_abstract_ref_type(jl_value_t *t)\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_ref_type->name);\n}\n\nSTATIC_INLINE jl_value_t *jl_is_ref_type(jl_value_t *t)\n{\n    if (!jl_is_datatype(t)) return 0;\n    jl_datatype_t *dt = (jl_datatype_t*)t;\n    while (dt != jl_any_type && dt->name != dt->super->name) {\n        if (dt->name == jl_ref_type->name)\n            return (jl_value_t*)dt;\n        dt = dt->super;\n    }\n    return 0;\n}\n\nSTATIC_INLINE int jl_is_tuple_type(void *t)\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_tuple_typename);\n}\n\nSTATIC_INLINE int jl_is_vararg_type(jl_value_t *v)\n{\n    return (jl_is_datatype(v) &&\n            ((jl_datatype_t*)(v))->name == jl_vararg_type->name);\n}\n\nSTATIC_INLINE int jl_is_va_tuple(jl_datatype_t *t)\n{\n    size_t l = jl_svec_len(t->parameters);\n    return (l>0 && jl_is_vararg_type(jl_tparam(t,l-1)));\n}\n\nSTATIC_INLINE int jl_is_ntuple_type(jl_value_t *v)\n{\n    return (jl_is_datatype(v) &&\n            ((jl_datatype_t*)v)->name == jl_ntuple_typename);\n}\n\nSTATIC_INLINE int jl_is_type_type(jl_value_t *v)\n{\n    return (jl_is_datatype(v) &&\n            ((jl_datatype_t*)(v))->name == jl_type_type->name);\n}\n\n// object identity\nDLLEXPORT int jl_egal(jl_value_t *a, jl_value_t *b);\nDLLEXPORT uptrint_t jl_object_id(jl_value_t *v);\n\n// type predicates and basic operations\nint jl_is_type(jl_value_t *v);\nDLLEXPORT int jl_is_leaf_type(jl_value_t *v);\nDLLEXPORT int jl_has_typevars(jl_value_t *v);\nDLLEXPORT int jl_subtype(jl_value_t *a, jl_value_t *b, int ta);\nDLLEXPORT int jl_types_equal(jl_value_t *a, jl_value_t *b);\nDLLEXPORT jl_value_t *jl_type_union(jl_svec_t *types);\njl_value_t *jl_type_union_v(jl_value_t **ts, size_t n);\njl_value_t *jl_type_intersection_matching(jl_value_t *a, jl_value_t *b,\n                                          jl_svec_t **penv, jl_svec_t *tvars);\nDLLEXPORT jl_value_t *jl_type_intersection(jl_value_t *a, jl_value_t *b);\nDLLEXPORT int jl_args_morespecific(jl_value_t *a, jl_value_t *b);\nDLLEXPORT const char *jl_typename_str(jl_value_t *v);\nDLLEXPORT const char *jl_typeof_str(jl_value_t *v);\nDLLEXPORT int jl_type_morespecific(jl_value_t *a, jl_value_t *b);\n\n// type constructors\nDLLEXPORT jl_typename_t *jl_new_typename(jl_sym_t *name);\nDLLEXPORT jl_tvar_t *jl_new_typevar(jl_sym_t *name,jl_value_t *lb,jl_value_t *ub);\njl_typector_t *jl_new_type_ctor(jl_svec_t *params, jl_value_t *body);\nDLLEXPORT jl_value_t *jl_apply_type(jl_value_t *tc, jl_svec_t *params);\nDLLEXPORT jl_tupletype_t *jl_apply_tuple_type(jl_svec_t *params);\nDLLEXPORT jl_tupletype_t *jl_apply_tuple_type_v(jl_value_t **p, size_t np);\njl_value_t *jl_apply_type_(jl_value_t *tc, jl_value_t **params, size_t n);\njl_value_t *jl_instantiate_type_with(jl_value_t *t, jl_value_t **env, size_t n);\njl_datatype_t *jl_new_abstracttype(jl_value_t *name, jl_datatype_t *super,\n                                   jl_svec_t *parameters);\nDLLEXPORT jl_datatype_t *jl_new_uninitialized_datatype(size_t nfields,\n                                                       int8_t fielddesc_type);\nDLLEXPORT jl_datatype_t *jl_new_datatype(jl_sym_t *name, jl_datatype_t *super,\n                                         jl_svec_t *parameters,\n                                         jl_svec_t *fnames, jl_svec_t *ftypes,\n                                         int abstract, int mutabl, int ninitialized);\nDLLEXPORT jl_datatype_t *jl_new_bitstype(jl_value_t *name, jl_datatype_t *super,\n                                         jl_svec_t *parameters, size_t nbits);\njl_datatype_t *jl_wrap_Type(jl_value_t *t);  // x -> Type{x}\njl_datatype_t *jl_wrap_vararg(jl_value_t *t);\n\n// constructors\nDLLEXPORT jl_value_t *jl_new_bits(jl_value_t *bt, void *data);\nvoid jl_assign_bits(void *dest, jl_value_t *bits);\nDLLEXPORT jl_value_t *jl_new_struct(jl_datatype_t *type, ...);\nDLLEXPORT jl_value_t *jl_new_structv(jl_datatype_t *type, jl_value_t **args, uint32_t na);\nDLLEXPORT jl_value_t *jl_new_struct_uninit(jl_datatype_t *type);\nDLLEXPORT jl_function_t *jl_new_closure(jl_fptr_t proc, jl_value_t *env,\n                                        jl_lambda_info_t *li);\nDLLEXPORT jl_lambda_info_t *jl_new_lambda_info(jl_value_t *ast, jl_svec_t *sparams, jl_module_t *ctx);\nDLLEXPORT jl_svec_t *jl_svec(size_t n, ...);\nDLLEXPORT jl_svec_t *jl_svec1(void *a);\nDLLEXPORT jl_svec_t *jl_svec2(void *a, void *b);\nDLLEXPORT jl_svec_t *jl_alloc_svec(size_t n);\nDLLEXPORT jl_svec_t *jl_alloc_svec_uninit(size_t n);\nDLLEXPORT jl_svec_t *jl_svec_append(jl_svec_t *a, jl_svec_t *b);\njl_svec_t *jl_svec_copy(jl_svec_t *a);\nDLLEXPORT jl_svec_t *jl_svec_fill(size_t n, jl_value_t *x);\nDLLEXPORT jl_value_t *jl_tupletype_fill(size_t n, jl_value_t *v);\nDLLEXPORT jl_sym_t *jl_symbol(const char *str);\nDLLEXPORT jl_sym_t *jl_symbol_lookup(const char *str);\nDLLEXPORT jl_sym_t *jl_symbol_n(const char *str, int32_t len);\nDLLEXPORT jl_sym_t *jl_gensym(void);\nDLLEXPORT jl_sym_t *jl_tagged_gensym(const char *str, int32_t len);\nDLLEXPORT jl_sym_t *jl_get_root_symbol(void);\njl_expr_t *jl_exprn(jl_sym_t *head, size_t n);\njl_function_t *jl_new_generic_function(jl_sym_t *name, jl_module_t *module);\nvoid jl_add_method(jl_function_t *gf, jl_tupletype_t *types, jl_function_t *meth,\n                   jl_svec_t *tvars, int8_t isstaged);\nDLLEXPORT jl_value_t *jl_generic_function_def(jl_sym_t *name, jl_value_t **bp, jl_value_t *bp_owner,\n                                              jl_binding_t *bnd);\nDLLEXPORT jl_value_t *jl_method_def(jl_sym_t *name, jl_value_t **bp, jl_value_t *bp_owner, jl_binding_t *bnd,\n                                    jl_svec_t *argtypes, jl_function_t *f, jl_value_t *isstaged,\n                                    jl_value_t *call_func, int iskw);\nDLLEXPORT jl_value_t *jl_box_bool(int8_t x);\nDLLEXPORT jl_value_t *jl_box_int8(int8_t x);\nDLLEXPORT jl_value_t *jl_box_uint8(uint8_t x);\nDLLEXPORT jl_value_t *jl_box_int16(int16_t x);\nDLLEXPORT jl_value_t *jl_box_uint16(uint16_t x);\nDLLEXPORT jl_value_t *jl_box_int32(int32_t x);\nDLLEXPORT jl_value_t *jl_box_uint32(uint32_t x);\nDLLEXPORT jl_value_t *jl_box_char(uint32_t x);\nDLLEXPORT jl_value_t *jl_box_int64(int64_t x);\nDLLEXPORT jl_value_t *jl_box_uint64(uint64_t x);\nDLLEXPORT jl_value_t *jl_box_float32(float x);\nDLLEXPORT jl_value_t *jl_box_float64(double x);\nDLLEXPORT jl_value_t *jl_box_voidpointer(void *x);\nDLLEXPORT jl_value_t *jl_box_gensym(size_t x);\nDLLEXPORT jl_value_t *jl_box8 (jl_datatype_t *t, int8_t  x);\nDLLEXPORT jl_value_t *jl_box16(jl_datatype_t *t, int16_t x);\nDLLEXPORT jl_value_t *jl_box32(jl_datatype_t *t, int32_t x);\nDLLEXPORT jl_value_t *jl_box64(jl_datatype_t *t, int64_t x);\nDLLEXPORT int8_t jl_unbox_bool(jl_value_t *v);\nDLLEXPORT int8_t jl_unbox_int8(jl_value_t *v);\nDLLEXPORT uint8_t jl_unbox_uint8(jl_value_t *v);\nDLLEXPORT int16_t jl_unbox_int16(jl_value_t *v);\nDLLEXPORT uint16_t jl_unbox_uint16(jl_value_t *v);\nDLLEXPORT int32_t jl_unbox_int32(jl_value_t *v);\nDLLEXPORT uint32_t jl_unbox_uint32(jl_value_t *v);\nDLLEXPORT int64_t jl_unbox_int64(jl_value_t *v);\nDLLEXPORT uint64_t jl_unbox_uint64(jl_value_t *v);\nDLLEXPORT float jl_unbox_float32(jl_value_t *v);\nDLLEXPORT double jl_unbox_float64(jl_value_t *v);\nDLLEXPORT void *jl_unbox_voidpointer(jl_value_t *v);\nDLLEXPORT ssize_t jl_unbox_gensym(jl_value_t *v);\n\nDLLEXPORT int jl_get_size(jl_value_t *val, size_t *pnt);\n\n#ifdef _P64\n#define jl_box_long(x)   jl_box_int64(x)\n#define jl_box_ulong(x)  jl_box_uint64(x)\n#define jl_unbox_long(x) jl_unbox_int64(x)\n#define jl_is_long(x)    jl_is_int64(x)\n#define jl_long_type     jl_int64_type\n#else\n#define jl_box_long(x)   jl_box_int32(x)\n#define jl_box_ulong(x)  jl_box_uint32(x)\n#define jl_unbox_long(x) jl_unbox_int32(x)\n#define jl_is_long(x)    jl_is_int32(x)\n#define jl_long_type     jl_int32_type\n#endif\n\n// structs\nDLLEXPORT int         jl_field_index(jl_datatype_t *t, jl_sym_t *fld, int err);\nDLLEXPORT jl_value_t *jl_get_nth_field(jl_value_t *v, size_t i);\nDLLEXPORT jl_value_t *jl_get_nth_field_checked(jl_value_t *v, size_t i);\nDLLEXPORT void        jl_set_nth_field(jl_value_t *v, size_t i, jl_value_t *rhs);\nDLLEXPORT int         jl_field_isdefined(jl_value_t *v, size_t i);\nDLLEXPORT jl_value_t *jl_get_field(jl_value_t *o, const char *fld);\nDLLEXPORT jl_value_t *jl_value_ptr(jl_value_t *a);\n\n// arrays\n\nDLLEXPORT jl_array_t *jl_new_array(jl_value_t *atype, jl_value_t *dims);\nDLLEXPORT jl_array_t *jl_new_arrayv(jl_value_t *atype, ...);\nDLLEXPORT jl_array_t *jl_reshape_array(jl_value_t *atype, jl_array_t *data,\n                                       jl_value_t *dims);\nDLLEXPORT jl_array_t *jl_ptr_to_array_1d(jl_value_t *atype, void *data,\n                                         size_t nel, int own_buffer);\nDLLEXPORT jl_array_t *jl_ptr_to_array(jl_value_t *atype, void *data,\n                                      jl_value_t *dims, int own_buffer);\nint jl_array_store_unboxed(jl_value_t *el_type);\n\nDLLEXPORT jl_array_t *jl_alloc_array_1d(jl_value_t *atype, size_t nr);\nDLLEXPORT jl_array_t *jl_alloc_array_2d(jl_value_t *atype, size_t nr, size_t nc);\nDLLEXPORT jl_array_t *jl_alloc_array_3d(jl_value_t *atype, size_t nr, size_t nc,\n                                        size_t z);\nDLLEXPORT jl_array_t *jl_pchar_to_array(const char *str, size_t len);\nDLLEXPORT jl_value_t *jl_pchar_to_string(const char *str, size_t len);\nDLLEXPORT jl_value_t *jl_cstr_to_string(const char *str);\nDLLEXPORT jl_value_t *jl_array_to_string(jl_array_t *a);\nDLLEXPORT jl_array_t *jl_alloc_cell_1d(size_t n);\nDLLEXPORT jl_value_t *jl_arrayref(jl_array_t *a, size_t i);  // 0-indexed\nDLLEXPORT void jl_arrayset(jl_array_t *a, jl_value_t *v, size_t i);  // 0-indexed\nDLLEXPORT void jl_arrayunset(jl_array_t *a, size_t i);  // 0-indexed\nint jl_array_isdefined(jl_value_t **args, int nargs);\nDLLEXPORT void jl_array_grow_end(jl_array_t *a, size_t inc);\nDLLEXPORT void jl_array_del_end(jl_array_t *a, size_t dec);\nDLLEXPORT void jl_array_grow_beg(jl_array_t *a, size_t inc);\nDLLEXPORT void jl_array_del_beg(jl_array_t *a, size_t dec);\nDLLEXPORT void jl_array_sizehint(jl_array_t *a, size_t sz);\nDLLEXPORT void jl_cell_1d_push(jl_array_t *a, jl_value_t *item);\nDLLEXPORT jl_value_t *jl_apply_array_type(jl_datatype_t *type, size_t dim);\n// property access\nDLLEXPORT void *jl_array_ptr(jl_array_t *a);\nDLLEXPORT void *jl_array_eltype(jl_value_t *a);\nDLLEXPORT int jl_array_rank(jl_value_t *a);\nDLLEXPORT size_t jl_array_size(jl_value_t *a, int d);\n\n// strings\nDLLEXPORT const char *jl_bytestring_ptr(jl_value_t *s);\n\n// modules and global variables\nextern DLLEXPORT jl_module_t *jl_main_module;\nextern DLLEXPORT jl_module_t *jl_internal_main_module;\nextern DLLEXPORT jl_module_t *jl_core_module;\nextern DLLEXPORT jl_module_t *jl_base_module;\nextern DLLEXPORT jl_module_t *jl_top_module;\nextern DLLEXPORT jl_module_t *jl_current_module;\nDLLEXPORT jl_module_t *jl_new_module(jl_sym_t *name);\n// get binding for reading\nDLLEXPORT jl_binding_t *jl_get_binding(jl_module_t *m, jl_sym_t *var);\nDLLEXPORT jl_binding_t *jl_get_binding_or_error(jl_module_t *m, jl_sym_t *var);\nDLLEXPORT jl_value_t *jl_module_globalref(jl_module_t *m, jl_sym_t *var);\n// get binding for assignment\nDLLEXPORT jl_binding_t *jl_get_binding_wr(jl_module_t *m, jl_sym_t *var);\nDLLEXPORT jl_binding_t *jl_get_binding_for_method_def(jl_module_t *m, jl_sym_t *var);\nDLLEXPORT int jl_boundp(jl_module_t *m, jl_sym_t *var);\nDLLEXPORT int jl_defines_or_exports_p(jl_module_t *m, jl_sym_t *var);\nDLLEXPORT int jl_binding_resolved_p(jl_module_t *m, jl_sym_t *var);\nDLLEXPORT int jl_is_const(jl_module_t *m, jl_sym_t *var);\nDLLEXPORT jl_value_t *jl_get_global(jl_module_t *m, jl_sym_t *var);\nDLLEXPORT void jl_set_global(jl_module_t *m, jl_sym_t *var, jl_value_t *val);\nDLLEXPORT void jl_set_const(jl_module_t *m, jl_sym_t *var, jl_value_t *val);\nDLLEXPORT void jl_checked_assignment(jl_binding_t *b, jl_value_t *rhs);\nDLLEXPORT void jl_declare_constant(jl_binding_t *b);\nDLLEXPORT void jl_module_using(jl_module_t *to, jl_module_t *from);\nDLLEXPORT void jl_module_use(jl_module_t *to, jl_module_t *from, jl_sym_t *s);\nDLLEXPORT void jl_module_import(jl_module_t *to, jl_module_t *from, jl_sym_t *s);\nDLLEXPORT void jl_module_importall(jl_module_t *to, jl_module_t *from);\nDLLEXPORT void jl_module_export(jl_module_t *from, jl_sym_t *s);\nDLLEXPORT int jl_is_imported(jl_module_t *m, jl_sym_t *s);\nDLLEXPORT jl_module_t *jl_new_main_module(void);\nDLLEXPORT void jl_add_standard_imports(jl_module_t *m);\nSTATIC_INLINE jl_function_t *jl_get_function(jl_module_t *m, const char *name)\n{\n    return  (jl_function_t*) jl_get_global(m, jl_symbol(name));\n}\nDLLEXPORT void jl_module_run_initializer(jl_module_t *m);\njl_function_t *jl_module_call_func(jl_module_t *m);\nint jl_is_submodule(jl_module_t *child, jl_module_t *parent);\n\n// eq hash tables\nDLLEXPORT jl_array_t *jl_eqtable_put(jl_array_t *h, void *key, void *val);\nDLLEXPORT jl_value_t *jl_eqtable_get(jl_array_t *h, void *key, jl_value_t *deflt);\n\n// system information\nDLLEXPORT int jl_errno(void);\nDLLEXPORT void jl_set_errno(int e);\nDLLEXPORT int32_t jl_stat(const char *path, char *statbuf);\nDLLEXPORT int jl_cpu_cores(void);\nDLLEXPORT long jl_getpagesize(void);\nDLLEXPORT long jl_getallocationgranularity(void);\nDLLEXPORT int jl_is_debugbuild(void);\nDLLEXPORT jl_sym_t* jl_get_OS_NAME();\nDLLEXPORT jl_sym_t* jl_get_ARCH();\n\n// environment entries\nDLLEXPORT jl_value_t *jl_environ(int i);\n\n// throwing common exceptions\nDLLEXPORT void NORETURN jl_error(const char *str);\nDLLEXPORT void NORETURN jl_errorf(const char *fmt, ...);\nDLLEXPORT void NORETURN jl_exceptionf(jl_datatype_t *ty, const char *fmt, ...);\nDLLEXPORT void NORETURN jl_too_few_args(const char *fname, int min);\nDLLEXPORT void NORETURN jl_too_many_args(const char *fname, int max);\nDLLEXPORT void NORETURN jl_type_error(const char *fname, jl_value_t *expected, jl_value_t *got);\nDLLEXPORT void NORETURN jl_type_error_rt(const char *fname, const char *context,\n                                jl_value_t *ty, jl_value_t *got);\nDLLEXPORT void NORETURN jl_undefined_var_error(jl_sym_t *var);\nDLLEXPORT void NORETURN jl_bounds_error(jl_value_t *v, jl_value_t *t);\nDLLEXPORT void NORETURN jl_bounds_error_v(jl_value_t *v, jl_value_t **idxs, size_t nidxs);\nDLLEXPORT void NORETURN jl_bounds_error_int(jl_value_t *v, size_t i);\nDLLEXPORT void NORETURN jl_bounds_error_tuple_int(jl_value_t **v, size_t nv, size_t i);\nDLLEXPORT void NORETURN jl_bounds_error_unboxed_int(void *v, jl_value_t *vt, size_t i);\nDLLEXPORT void NORETURN jl_bounds_error_ints(jl_value_t *v, size_t *idxs, size_t nidxs);\nDLLEXPORT jl_value_t *jl_exception_occurred(void);\nDLLEXPORT void jl_exception_clear(void);\n\n#define JL_NARGS(fname, min, max)                               \\\n    if (nargs < min) jl_too_few_args(#fname, min);              \\\n    else if (nargs > max) jl_too_many_args(#fname, max);\n\n#define JL_NARGSV(fname, min)                           \\\n    if (nargs < min) jl_too_few_args(#fname, min);\n\n#define JL_TYPECHK(fname, type, v)                                      \\\n    if (!jl_is_##type(v)) {                                             \\\n        jl_type_error(#fname, (jl_value_t*)jl_##type##_type, (v));      \\\n    }\n#define JL_TYPECHKS(fname, type, v)                                     \\\n    if (!jl_is_##type(v)) {                                             \\\n        jl_type_error(fname, (jl_value_t*)jl_##type##_type, (v));       \\\n    }\n\n// initialization functions\ntypedef enum {\n    JL_IMAGE_CWD = 0,\n    JL_IMAGE_JULIA_HOME = 1,\n    //JL_IMAGE_LIBJULIA = 2,\n} JL_IMAGE_SEARCH;\nDLLEXPORT void julia_init(JL_IMAGE_SEARCH rel);\nDLLEXPORT void jl_init(const char *julia_home_dir);\nDLLEXPORT void jl_init_with_image(const char *julia_home_dir, const char *image_relative_path);\nDLLEXPORT int jl_is_initialized(void);\nDLLEXPORT int julia_trampoline(int argc, const char *argv[], int (*pmain)(int ac,char *av[]));\nDLLEXPORT void jl_atexit_hook(int status);\nDLLEXPORT void NORETURN jl_exit(int status);\n\nDLLEXPORT int jl_deserialize_verify_header(ios_t *s);\nDLLEXPORT void jl_preload_sysimg_so(const char *fname);\nDLLEXPORT ios_t *jl_create_system_image(void);\nDLLEXPORT void jl_save_system_image(const char *fname);\nDLLEXPORT void jl_restore_system_image(const char *fname);\nDLLEXPORT void jl_restore_system_image_data(const char *buf, size_t len);\nDLLEXPORT int jl_save_incremental(const char *fname, jl_array_t* worklist);\nDLLEXPORT jl_value_t *jl_restore_incremental(const char *fname);\nDLLEXPORT jl_value_t *jl_restore_incremental_from_buf(const char *buf, size_t sz);\nvoid jl_init_restored_modules(jl_array_t *init_order);\n\n// front end interface\nDLLEXPORT jl_value_t *jl_parse_input_line(const char *str, size_t len);\nDLLEXPORT jl_value_t *jl_parse_string(const char *str, size_t len,\n                                      int pos0, int greedy);\nDLLEXPORT int jl_parse_depwarn(int warn);\nint jl_start_parsing_file(const char *fname);\nvoid jl_stop_parsing(void);\njl_value_t *jl_parse_next(void);\nDLLEXPORT jl_value_t *jl_load_file_string(const char *text, size_t len,\n                                          char *filename, size_t namelen);\nDLLEXPORT jl_value_t *jl_expand(jl_value_t *expr);\nDLLEXPORT jl_value_t *jl_expand_in(jl_module_t *module, jl_value_t *expr);\njl_lambda_info_t *jl_wrap_expr(jl_value_t *expr);\nDLLEXPORT void *jl_eval_string(const char *str);\n\n// external libraries\nenum JL_RTLD_CONSTANT {\n     JL_RTLD_LOCAL=1U,\n     JL_RTLD_GLOBAL=2U,\n     JL_RTLD_LAZY=4U,\n     JL_RTLD_NOW=8U,\n     /* Linux/glibc and MacOS X: */\n     JL_RTLD_NODELETE=16U,\n     JL_RTLD_NOLOAD=32U,\n     /* Linux/glibc: */\n     JL_RTLD_DEEPBIND=64U,\n     /* MacOS X 10.5+: */\n     JL_RTLD_FIRST=128U\n};\n#define JL_RTLD_DEFAULT (JL_RTLD_LAZY | JL_RTLD_DEEPBIND)\n\ntypedef void *jl_uv_libhandle; // uv_lib_t* (avoid uv.h dependency)\nDLLEXPORT jl_uv_libhandle jl_load_dynamic_library(const char *fname, unsigned flags);\nDLLEXPORT jl_uv_libhandle jl_load_dynamic_library_e(const char *fname, unsigned flags);\nDLLEXPORT void *jl_dlsym_e(jl_uv_libhandle handle, const char *symbol);\nDLLEXPORT void *jl_dlsym(jl_uv_libhandle handle, const char *symbol);\nDLLEXPORT int jl_uv_dlopen(const char *filename, jl_uv_libhandle lib, unsigned flags);\nchar *jl_dlfind_win32(const char *name);\nDLLEXPORT int add_library_mapping(char *lib, void *hnd);\n\n#if defined(__linux__) || defined(__FreeBSD__)\nDLLEXPORT const char *jl_lookup_soname(const char *pfx, size_t n);\n#endif\n\n// compiler\nvoid jl_compile(jl_function_t *f);\nDLLEXPORT jl_value_t *jl_toplevel_eval(jl_value_t *v);\nDLLEXPORT jl_value_t *jl_toplevel_eval_in(jl_module_t *m, jl_value_t *ex, int delay_warn);\njl_value_t *jl_eval_global_var(jl_module_t *m, jl_sym_t *e);\nDLLEXPORT jl_value_t *jl_load(const char *fname, size_t len);\njl_value_t *jl_parse_eval_all(const char *fname, size_t len);\njl_value_t *jl_interpret_toplevel_thunk(jl_lambda_info_t *lam);\njl_value_t *jl_interpret_toplevel_thunk_with(jl_lambda_info_t *lam,\n                                             jl_value_t **loc, size_t nl);\njl_value_t *jl_interpret_toplevel_expr(jl_value_t *e);\nDLLEXPORT jl_value_t *jl_interpret_toplevel_expr_in(jl_module_t *m, jl_value_t *e,\n                                                    jl_value_t **locals, size_t nl);\njl_value_t *jl_static_eval(jl_value_t *ex, void *ctx_, jl_module_t *mod,\n                           jl_value_t *sp, jl_expr_t *ast, int sparams, int allow_alloc);\nint jl_is_toplevel_only_expr(jl_value_t *e);\nDLLEXPORT jl_module_t *jl_base_relative_to(jl_module_t *m);\nvoid jl_type_infer(jl_lambda_info_t *li, jl_tupletype_t *argtypes, jl_lambda_info_t *def);\n\njl_function_t *jl_method_lookup_by_type(jl_methtable_t *mt, jl_tupletype_t *types,\n                                        int cache, int inexact);\njl_function_t *jl_method_lookup(jl_methtable_t *mt, jl_value_t **args, size_t nargs, int cache);\njl_value_t *jl_gf_invoke(jl_function_t *gf, jl_tupletype_t *types,\n                         jl_value_t **args, size_t nargs);\n\n// AST access\njl_array_t *jl_lam_args(jl_expr_t *l);\njl_array_t *jl_lam_vinfo(jl_expr_t *l);\njl_array_t *jl_lam_capt(jl_expr_t *l);\njl_value_t *jl_lam_gensyms(jl_expr_t *l);\njl_array_t *jl_lam_staticparams(jl_expr_t *l);\njl_sym_t *jl_lam_argname(jl_lambda_info_t *li, int i);\nint jl_lam_vars_captured(jl_expr_t *ast);\njl_expr_t *jl_lam_body(jl_expr_t *l);\nint jl_in_vinfo_array(jl_array_t *a, jl_sym_t *v);\nint jl_local_in_ast(jl_expr_t *ast, jl_sym_t *sym);\nDLLEXPORT jl_value_t *jl_ast_rettype(jl_lambda_info_t *li, jl_value_t *ast);\njl_sym_t *jl_decl_var(jl_value_t *ex);\nDLLEXPORT int jl_is_rest_arg(jl_value_t *ex);\n\nDLLEXPORT jl_value_t *jl_prepare_ast(jl_lambda_info_t *li, jl_svec_t *sparams);\nDLLEXPORT jl_value_t *jl_copy_ast(jl_value_t *expr);\n\nDLLEXPORT jl_value_t *jl_compress_ast(jl_lambda_info_t *li, jl_value_t *ast);\nDLLEXPORT jl_value_t *jl_uncompress_ast(jl_lambda_info_t *li, jl_value_t *data);\n\nDLLEXPORT int jl_is_operator(char *sym);\nDLLEXPORT int jl_operator_precedence(char *sym);\n\nSTATIC_INLINE int jl_vinfo_capt(jl_array_t *vi)\n{\n    return (jl_unbox_long(jl_cellref(vi,2))&1)!=0;\n}\n\nSTATIC_INLINE int jl_vinfo_assigned(jl_array_t *vi)\n{\n    return (jl_unbox_long(jl_cellref(vi,2))&2)!=0;\n}\n\nSTATIC_INLINE int jl_vinfo_assigned_inner(jl_array_t *vi)\n{\n    return (jl_unbox_long(jl_cellref(vi,2))&4)!=0;\n}\n\nSTATIC_INLINE int jl_vinfo_sa(jl_array_t *vi)\n{\n    return (jl_unbox_long(jl_cellref(vi,2))&16)!=0;\n}\n\nSTATIC_INLINE int jl_vinfo_usedundef(jl_array_t *vi)\n{\n    return (jl_unbox_long(jl_cellref(vi,2))&32)!=0;\n}\n\n// calling into julia ---------------------------------------------------------\n\nSTATIC_INLINE\njl_value_t *jl_apply(jl_function_t *f, jl_value_t **args, uint32_t nargs)\n{\n    return f->fptr((jl_value_t*)f, args, nargs);\n}\n\nDLLEXPORT jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs);\nDLLEXPORT jl_value_t *jl_call0(jl_function_t *f);\nDLLEXPORT jl_value_t *jl_call1(jl_function_t *f, jl_value_t *a);\nDLLEXPORT jl_value_t *jl_call2(jl_function_t *f, jl_value_t *a, jl_value_t *b);\nDLLEXPORT jl_value_t *jl_call3(jl_function_t *f, jl_value_t *a, jl_value_t *b, jl_value_t *c);\n\n// interfacing with Task runtime\nDLLEXPORT void jl_yield(void);\n\n// async signal handling ------------------------------------------------------\n\n#include <signal.h>\n\nDLLEXPORT extern volatile sig_atomic_t jl_signal_pending;\nDLLEXPORT extern volatile sig_atomic_t jl_defer_signal;\n\n#define JL_SIGATOMIC_BEGIN() (jl_defer_signal++)\n#define JL_SIGATOMIC_END()                                      \\\n    do {                                                        \\\n        jl_defer_signal--;                                      \\\n        if (jl_defer_signal == 0 && jl_signal_pending != 0) {   \\\n            jl_signal_pending = 0;                              \\\n            jl_sigint_action();                                 \\\n        }                                                       \\\n    } while(0)\n\nDLLEXPORT void jl_sigint_action(void);\nDLLEXPORT void restore_signals(void);\nDLLEXPORT void jl_install_sigint_handler(void);\nDLLEXPORT void jl_sigatomic_begin(void);\nDLLEXPORT void jl_sigatomic_end(void);\n\n// tasks and exceptions -------------------------------------------------------\n\n// info describing an exception handler\ntypedef struct _jl_handler_t {\n    jl_jmp_buf eh_ctx;\n    jl_gcframe_t *gcstack;\n    struct _jl_handler_t *prev;\n} jl_handler_t;\n\ntypedef struct _jl_task_t {\n    JL_DATA_TYPE\n    struct _jl_task_t *parent;\n    struct _jl_task_t *last;\n    jl_value_t *tls;\n    jl_sym_t *state;\n    jl_value_t *consumers;\n    jl_value_t *donenotify;\n    jl_value_t *result;\n    jl_value_t *exception;\n    jl_value_t *backtrace;\n    jl_function_t *start;\n    jl_jmp_buf ctx;\n#ifndef COPY_STACKS\n    void *stack;\n#endif\n    size_t bufsz;\n    void *stkbuf;\n    size_t ssize;\n\n    // current exception handler\n    jl_handler_t *eh;\n    // saved gc stack top for context switches\n    jl_gcframe_t *gcstack;\n    // current module, or NULL if this task has not set one\n    jl_module_t *current_module;\n} jl_task_t;\n\nextern DLLEXPORT JL_THREAD jl_task_t * volatile jl_current_task;\nextern DLLEXPORT JL_THREAD jl_task_t *jl_root_task;\nextern DLLEXPORT JL_THREAD jl_value_t *jl_exception_in_transit;\n\nDLLEXPORT jl_task_t *jl_new_task(jl_function_t *start, size_t ssize);\nDLLEXPORT jl_value_t *jl_switchto(jl_task_t *t, jl_value_t *arg);\nDLLEXPORT void NORETURN jl_throw(jl_value_t *e);\nDLLEXPORT void NORETURN jl_rethrow(void);\nDLLEXPORT void NORETURN jl_rethrow_other(jl_value_t *e);\n\nSTATIC_INLINE void jl_eh_restore_state(jl_handler_t *eh)\n{\n    JL_SIGATOMIC_BEGIN();\n    jl_current_task->eh = eh->prev;\n    jl_pgcstack = eh->gcstack;\n    JL_SIGATOMIC_END();\n}\n\nDLLEXPORT void jl_enter_handler(jl_handler_t *eh);\nDLLEXPORT void jl_pop_handler(int n);\n\n#if defined(_OS_WINDOWS_)\n#if defined(_COMPILER_MINGW_)\nint __attribute__ ((__nothrow__,__returns_twice__)) jl_setjmp(jmp_buf _Buf);\n__declspec(noreturn) __attribute__ ((__nothrow__)) void jl_longjmp(jmp_buf _Buf,int _Value);\n#else\nint jl_setjmp(jmp_buf _Buf);\nvoid jl_longjmp(jmp_buf _Buf,int _Value);\n#endif\n#define jl_setjmp_f jl_setjmp\n#define jl_setjmp_name \"jl_setjmp\"\n#define jl_setjmp(a,b) jl_setjmp(a)\n#define jl_longjmp(a,b) jl_longjmp(a,b)\n#else\n// determine actual entry point name\n#if defined(sigsetjmp)\n#define jl_setjmp_f    __sigsetjmp\n#define jl_setjmp_name \"__sigsetjmp\"\n#else\n#define jl_setjmp_f    sigsetjmp\n#define jl_setjmp_name \"sigsetjmp\"\n#endif\n#define jl_setjmp(a,b) sigsetjmp(a,b)\n#define jl_longjmp(a,b) siglongjmp(a,b)\n#endif\n\n#define JL_TRY                                                    \\\n    int i__tr, i__ca; jl_handler_t __eh;                          \\\n    jl_enter_handler(&__eh);                                      \\\n    if (!jl_setjmp(__eh.eh_ctx,0))                                \\\n        for (i__tr=1; i__tr; i__tr=0, jl_eh_restore_state(&__eh))\n\n#define JL_EH_POP() jl_eh_restore_state(&__eh)\n\n#ifdef _OS_WINDOWS_\n#define JL_CATCH                                                \\\n    else                                                        \\\n        for (i__ca=1, jl_eh_restore_state(&__eh); i__ca; i__ca=0) \\\n            if (((jl_exception_in_transit==jl_stackovf_exception) && _resetstkoflw()) || 1)\n#else\n#define JL_CATCH                                                \\\n    else                                                        \\\n        for (i__ca=1, jl_eh_restore_state(&__eh); i__ca; i__ca=0)\n#endif\n\n// I/O system -----------------------------------------------------------------\n\n#define JL_STREAM uv_stream_t\n#define JL_STDOUT jl_uv_stdout\n#define JL_STDERR jl_uv_stderr\n#define JL_STDIN  jl_uv_stdin\n\nDLLEXPORT void jl_run_event_loop(uv_loop_t *loop);\nDLLEXPORT int jl_run_once(uv_loop_t *loop);\nDLLEXPORT int jl_process_events(uv_loop_t *loop);\n\nDLLEXPORT uv_loop_t *jl_global_event_loop(void);\n\nDLLEXPORT uv_pipe_t *jl_make_pipe(int writable, int julia_only, jl_value_t *julia_struct);\nDLLEXPORT void jl_close_uv(uv_handle_t *handle);\n\nDLLEXPORT int32_t jl_start_reading(uv_stream_t *handle);\n\nDLLEXPORT void jl_callback(void *callback);\n\nDLLEXPORT uv_async_t *jl_make_async(uv_loop_t *loop, jl_value_t *julia_struct);\nDLLEXPORT void jl_async_send(uv_async_t *handle);\nDLLEXPORT uv_idle_t * jl_make_idle(uv_loop_t *loop, jl_value_t *julia_struct);\nDLLEXPORT int jl_idle_start(uv_idle_t *idle);\nDLLEXPORT int jl_idle_stop(uv_idle_t *idle);\n\nDLLEXPORT uv_timer_t *jl_make_timer(uv_loop_t *loop, jl_value_t *julia_struct);\nDLLEXPORT int jl_timer_stop(uv_timer_t *timer);\n\nDLLEXPORT uv_tcp_t *jl_tcp_init(uv_loop_t *loop);\nDLLEXPORT int jl_tcp_bind(uv_tcp_t *handle, uint16_t port, uint32_t host, unsigned int flags);\n\nDLLEXPORT int jl_sizeof_ios_t(void);\n\n#ifdef _OS_WINDOWS_\nDLLEXPORT struct tm* localtime_r(const time_t *t, struct tm *tm);\n#endif\n\nDLLEXPORT jl_array_t *jl_takebuf_array(ios_t *s);\nDLLEXPORT jl_value_t *jl_takebuf_string(ios_t *s);\nDLLEXPORT void *jl_takebuf_raw(ios_t *s);\nDLLEXPORT jl_value_t *jl_readuntil(ios_t *s, uint8_t delim);\n\ntypedef struct {\n    void *data;\n    uv_loop_t *loop;\n    uv_handle_type type;\n    uv_file file;\n} jl_uv_file_t;\n\n#ifdef __GNUC__\n#define _JL_FORMAT_ATTR(type, str, arg) \\\n    __attribute__((format(type, str, arg)))\n#else\n#define _JL_FORMAT_ATTR(type, str, arg)\n#endif\n\nDLLEXPORT int jl_printf(uv_stream_t *s, const char *format, ...)\n    _JL_FORMAT_ATTR(printf, 2, 3);\nDLLEXPORT int jl_vprintf(uv_stream_t *s, const char *format, va_list args)\n    _JL_FORMAT_ATTR(printf, 2, 0);\nDLLEXPORT void jl_safe_printf(const char *str, ...)\n    _JL_FORMAT_ATTR(printf, 1, 2);\n\nextern DLLEXPORT JL_STREAM *JL_STDIN;\nextern DLLEXPORT JL_STREAM *JL_STDOUT;\nextern DLLEXPORT JL_STREAM *JL_STDERR;\n\nDLLEXPORT JL_STREAM *jl_stdout_stream(void);\nDLLEXPORT JL_STREAM *jl_stdin_stream(void);\nDLLEXPORT JL_STREAM *jl_stderr_stream(void);\n\n// showing and std streams\nDLLEXPORT void jl_show(jl_value_t *stream, jl_value_t *v);\nDLLEXPORT void jl_flush_cstdio(void);\nDLLEXPORT jl_value_t *jl_stdout_obj(void);\nDLLEXPORT jl_value_t *jl_stderr_obj(void);\nDLLEXPORT size_t jl_static_show(JL_STREAM *out, jl_value_t *v);\nDLLEXPORT size_t jl_static_show_func_sig(JL_STREAM *s, jl_value_t *type);\nDLLEXPORT void jlbacktrace(void);\n\n// debugging\nvoid show_execution_point(char *filename, int lno);\n\n// julia options -----------------------------------------------------------\n// NOTE: This struct needs to be kept in sync with JLOptions type in base/options.jl\ntypedef struct {\n    int8_t quiet;\n    const char *julia_home;\n    const char *julia_bin;\n    const char *eval;\n    const char *print;\n    const char *postboot;\n    const char *load;\n    const char *image_file;\n    const char *cpu_target;\n    int32_t nprocs;\n    const char *machinefile;\n    int8_t isinteractive;\n    int8_t color;\n    int8_t historyfile;\n    int8_t startupfile;\n    int8_t compile_enabled;\n    int8_t code_coverage;\n    int8_t malloc_log;\n    int8_t opt_level;\n    int8_t check_bounds;\n    int8_t depwarn;\n    int8_t can_inline;\n    int8_t fast_math;\n    int8_t worker;\n    int8_t handle_signals;\n    int8_t use_precompiled;\n    const char *bindto;\n    const char *outputbc;\n    const char *outputo;\n    const char *outputji;\n    int8_t incremental;\n} jl_options_t;\n\nextern DLLEXPORT jl_options_t jl_options;\n\nDLLEXPORT int jl_generating_output(void);\n\n// Settings for code_coverage and malloc_log\n// NOTE: if these numbers change, test/cmdlineargs.jl will have to be updated\n#define JL_LOG_NONE 0\n#define JL_LOG_USER 1\n#define JL_LOG_ALL  2\n\n#define JL_OPTIONS_CHECK_BOUNDS_DEFAULT 0\n#define JL_OPTIONS_CHECK_BOUNDS_ON 1\n#define JL_OPTIONS_CHECK_BOUNDS_OFF 2\n\n#define JL_OPTIONS_COMPILE_DEFAULT 1\n#define JL_OPTIONS_COMPILE_OFF 0\n#define JL_OPTIONS_COMPILE_ON  1\n#define JL_OPTIONS_COMPILE_ALL 2\n\n#define JL_OPTIONS_COLOR_ON 1\n#define JL_OPTIONS_COLOR_OFF 2\n\n#define JL_OPTIONS_HISTORYFILE_ON 1\n#define JL_OPTIONS_HISTORYFILE_OFF 0\n\n#define JL_OPTIONS_STARTUPFILE_ON 1\n#define JL_OPTIONS_STARTUPFILE_OFF 2\n\n#define JL_OPTIONS_DEPWARN_OFF 0\n#define JL_OPTIONS_DEPWARN_ON 1\n#define JL_OPTIONS_DEPWARN_ERROR 2\n\n#define JL_OPTIONS_FAST_MATH_ON 1\n#define JL_OPTIONS_FAST_MATH_OFF 2\n#define JL_OPTIONS_FAST_MATH_DEFAULT 0\n\n#define JL_OPTIONS_HANDLE_SIGNALS_ON 1\n#define JL_OPTIONS_HANDLE_SIGNALS_OFF 0\n\n#define JL_OPTIONS_USE_PRECOMPILED_YES 1\n#define JL_OPTIONS_USE_PRECOMPILED_NO 0\n\n// Version information\n#include \"julia_version.h\"\n\nDLLEXPORT extern int jl_ver_major(void);\nDLLEXPORT extern int jl_ver_minor(void);\nDLLEXPORT extern int jl_ver_patch(void);\nDLLEXPORT extern int jl_ver_is_release(void);\nDLLEXPORT extern const char* jl_ver_string(void);\nDLLEXPORT const char *jl_git_branch();\nDLLEXPORT const char *jl_git_commit();\n\n// nullable struct representations\ntypedef struct {\n    uint8_t isnull;\n    double value;\n} jl_nullable_float64_t;\n\ntypedef struct {\n    uint8_t isnull;\n    float value;\n} jl_nullable_float32_t;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/src/init.c": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n/*\n  init.c\n  system initialization and global state\n*/\n#include \"platform.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n#include <fcntl.h>\n\n#include <errno.h>\n\n#if !defined(_OS_WINDOWS_) || defined(_COMPILER_MINGW_)\n#include <getopt.h>\n#endif\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef _MSC_VER\nDLLEXPORT char * dirname(char *);\n#else\n#include <libgen.h>\n#endif\n\n#ifdef _OS_WINDOWS_\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n#include <dbghelp.h>\n#include <io.h>\nextern int needsSymRefreshModuleList;\nextern BOOL (WINAPI *hSymRefreshModuleList)(HANDLE);\n#else\n#include <sys/resource.h>\n#include <unistd.h>\n#endif\n\nstatic const char system_image_path[256] = \"\\0\" JL_SYSTEM_IMAGE_PATH;\n\njl_options_t jl_options = { 0,    // quiet\n                            NULL, // julia_home\n                            NULL, // julia_bin\n                            NULL, // eval\n                            NULL, // print\n                            NULL, // postboot\n                            NULL, // load\n                            &system_image_path[1], // image_file\n                            NULL, // cpu_taget (\"native\", \"core2\", etc...)\n                            0,    // nprocs\n                            NULL, // machinefile\n                            0,    // isinteractive\n                            0,    // color\n                            JL_OPTIONS_HISTORYFILE_ON, // historyfile\n                            0,    // startupfile\n                            JL_OPTIONS_COMPILE_DEFAULT, // compile_enabled\n                            0,    // code_coverage\n                            0,    // malloc_log\n                            0,    // opt_level\n                            JL_OPTIONS_CHECK_BOUNDS_DEFAULT, // check_bounds\n                            1,    // depwarn\n                            1,    // can_inline\n                            JL_OPTIONS_FAST_MATH_DEFAULT,\n                            0,    // worker\n                            JL_OPTIONS_HANDLE_SIGNALS_ON,\n#ifdef _OS_WINDOWS_\n// TODO remove this when using LLVM 3.5+\n                            JL_OPTIONS_USE_PRECOMPILED_NO,\n#else\n                            JL_OPTIONS_USE_PRECOMPILED_YES,\n#endif\n                            NULL, // bindto\n                            NULL, // outputbc\n                            NULL, // outputo\n                            NULL, // outputji\n                            0, // incremental\n};\n\nint jl_boot_file_loaded = 0;\nchar *jl_stack_lo;\nchar *jl_stack_hi;\nsize_t jl_page_size;\n\nstatic void jl_find_stack_bottom(void)\n{\n    size_t stack_size;\n#ifndef _OS_WINDOWS_\n    struct rlimit rl;\n\n    // When using memory sanitizer, increase stack size because msan bloats stack usage\n#if defined(__has_feature)\n#if __has_feature(memory_sanitizer)\n    const rlim_t kStackSize = 32 * 1024 * 1024;   // 32MB stack\n    int result;\n\n    result = getrlimit(RLIMIT_STACK, &rl);\n    if (result == 0) {\n        if (rl.rlim_cur < kStackSize) {\n            rl.rlim_cur = kStackSize;\n            result = setrlimit(RLIMIT_STACK, &rl);\n            if (result != 0) {\n                fprintf(stderr, \"setrlimit returned result = %d\\n\", result);\n            }\n        }\n    }\n#endif\n#endif\n\n    getrlimit(RLIMIT_STACK, &rl);\n    stack_size = rl.rlim_cur;\n#else\n    stack_size = 262144;  // guess\n#endif\n    jl_stack_hi = (char*)&stack_size;\n    jl_stack_lo = jl_stack_hi - stack_size;\n}\n\nstruct uv_shutdown_queue_item { uv_handle_t *h; struct uv_shutdown_queue_item *next; };\nstruct uv_shutdown_queue { struct uv_shutdown_queue_item *first; struct uv_shutdown_queue_item *last; };\n\nstatic void jl_uv_exitcleanup_add(uv_handle_t *handle, struct uv_shutdown_queue *queue)\n{\n    struct uv_shutdown_queue_item *item = (struct uv_shutdown_queue_item*)malloc(sizeof(struct uv_shutdown_queue_item));\n    item->h = handle;\n    item->next = NULL;\n    if (queue->last) queue->last->next = item;\n    if (!queue->first) queue->first = item;\n    queue->last = item;\n}\n\nstatic void jl_uv_exitcleanup_walk(uv_handle_t *handle, void *arg)\n{\n    if (handle != (uv_handle_t*)JL_STDOUT && handle != (uv_handle_t*)JL_STDERR)\n        jl_uv_exitcleanup_add(handle, (struct uv_shutdown_queue*)arg);\n}\n\nvoid jl_write_coverage_data(void);\nvoid jl_write_malloc_log(void);\nstatic void julia_save(void);\n\nstatic struct uv_shutdown_queue_item *next_shutdown_queue_item(struct uv_shutdown_queue_item *item)\n{\n    struct uv_shutdown_queue_item *rv = item->next;\n    free(item);\n    return rv;\n}\n\nDLLEXPORT void jl_atexit_hook(int exitcode)\n{\n    if (exitcode == 0) julia_save();\n    jl_print_gc_stats(JL_STDERR);\n    if (jl_options.code_coverage)\n        jl_write_coverage_data();\n    if (jl_options.malloc_log)\n        jl_write_malloc_log();\n    if (jl_base_module) {\n        jl_value_t *f = jl_get_global(jl_base_module, jl_symbol(\"_atexit\"));\n        if (f!=NULL && jl_is_function(f)) {\n            JL_TRY {\n                jl_apply((jl_function_t*)f, NULL, 0);\n            }\n            JL_CATCH {\n                jl_printf(JL_STDERR, \"\\natexit hook threw an error: \");\n                jl_static_show(JL_STDERR, jl_exception_in_transit);\n            }\n        }\n    }\n\n    jl_gc_run_all_finalizers();\n\n    uv_loop_t *loop = jl_global_event_loop();\n\n    if (loop == NULL) {\n        return;\n    }\n\n    struct uv_shutdown_queue queue = {NULL, NULL};\n    uv_walk(loop, jl_uv_exitcleanup_walk, &queue);\n    // close stdout and stderr last, since we like being\n    // able to show stuff (incl. printf's)\n    if (JL_STDOUT != (void*) STDOUT_FILENO &&\n        ((uv_handle_t*)JL_STDOUT)->type < UV_HANDLE_TYPE_MAX)\n        jl_uv_exitcleanup_add((uv_handle_t*)JL_STDOUT, &queue);\n    if (JL_STDERR != (void*) STDERR_FILENO &&\n        ((uv_handle_t*)JL_STDERR)->type < UV_HANDLE_TYPE_MAX)\n        jl_uv_exitcleanup_add((uv_handle_t*)JL_STDERR, &queue);\n    //uv_unref((uv_handle_t*)JL_STDOUT);\n    //uv_unref((uv_handle_t*)JL_STDERR);\n    struct uv_shutdown_queue_item *item = queue.first;\n    while (item) {\n        JL_TRY {\n            while (item) {\n                uv_handle_t *handle = item->h;\n                if (handle->type != UV_FILE && uv_is_closing(handle)) {\n                    item = next_shutdown_queue_item(item);\n                    continue;\n                }\n                switch(handle->type) {\n                case UV_TTY:\n                case UV_UDP:\n                case UV_TCP:\n                case UV_NAMED_PIPE:\n                case UV_POLL:\n                case UV_TIMER:\n                case UV_ASYNC:\n                case UV_FS_EVENT:\n                case UV_FS_POLL:\n                case UV_IDLE:\n                case UV_PREPARE:\n                case UV_CHECK:\n                case UV_SIGNAL:\n                case UV_PROCESS:\n                case UV_FILE:\n                    // These will be shutdown as appropriate by jl_close_uv\n                    jl_close_uv(handle);\n                    break;\n                case UV_HANDLE:\n                case UV_STREAM:\n                case UV_UNKNOWN_HANDLE:\n                case UV_HANDLE_TYPE_MAX:\n                case UV_RAW_FD:\n                case UV_RAW_HANDLE:\n                default:\n                    assert(0);\n                }\n                item = next_shutdown_queue_item(item);\n            }\n        }\n        JL_CATCH {\n            //error handling -- continue cleanup, as much as possible\n            uv_unref(item->h);\n            jl_printf(JL_STDERR, \"error during exit cleanup: close: \");\n            jl_static_show(JL_STDERR, jl_exception_in_transit);\n            item = next_shutdown_queue_item(item);\n        }\n    }\n    // force libuv to spin until everything has finished closing\n    loop->stop_flag = 0;\n    while (uv_run(loop,UV_RUN_DEFAULT)) {}\n}\n\nvoid jl_get_builtin_hooks(void);\n\nDLLEXPORT uv_lib_t *jl_dl_handle;\nuv_lib_t _jl_RTLD_DEFAULT_handle;\nuv_lib_t *jl_RTLD_DEFAULT_handle=&_jl_RTLD_DEFAULT_handle;\n#ifdef _OS_WINDOWS_\nuv_lib_t _jl_ntdll_handle;\nuv_lib_t _jl_exe_handle;\nuv_lib_t _jl_kernel32_handle;\nuv_lib_t _jl_crtdll_handle;\nuv_lib_t _jl_winsock_handle;\n\nDLLEXPORT uv_lib_t *jl_exe_handle=&_jl_exe_handle;\nuv_lib_t *jl_ntdll_handle=&_jl_ntdll_handle;\nuv_lib_t *jl_kernel32_handle=&_jl_kernel32_handle;\nuv_lib_t *jl_crtdll_handle=&_jl_crtdll_handle;\nuv_lib_t *jl_winsock_handle=&_jl_winsock_handle;\n#endif\n\nuv_loop_t *jl_io_loop;\n\nvoid *init_stdio_handle(uv_file fd,int readable)\n{\n    void *handle;\n    uv_handle_type type = uv_guess_handle(fd);\n    jl_uv_file_t *file;\n#ifndef _OS_WINDOWS_\n    // Duplicate the file descriptor so we can later dup it over if we want to redirect\n    // STDIO without having to worry about closing the associated libuv object.\n    // On windows however, libuv objects remember streams by their HANDLE, so this is\n    // unnecessary.\n    fd = dup(fd);\n#endif\n    //jl_printf(JL_STDOUT, \"%d: %d -- %d\\n\", fd, type, 0);\n    switch(type) {\n        case UV_TTY:\n            handle = malloc(sizeof(uv_tty_t));\n            if (uv_tty_init(jl_io_loop,(uv_tty_t*)handle,fd,readable)) {\n                jl_errorf(\"error initializing stdio in uv_tty_init (%d, %d)\", fd, type);\n            }\n            ((uv_tty_t*)handle)->data=0;\n            uv_tty_set_mode((uv_tty_t*)handle,0); //cooked stdio\n            break;\n        case UV_UNKNOWN_HANDLE:\n            // dup the descriptor with a new one pointing at the bit bucket ...\n#if defined(_OS_WINDOWS_)\n            _dup2(_open(\"NUL\", O_RDWR | O_BINARY, _S_IREAD | _S_IWRITE), fd);\n#else\n            dup2(open(\"/dev/null\", O_RDWR, S_IRUSR | S_IWUSR /* 0600 */ | S_IRGRP | S_IROTH /* 0644 */), fd);\n#endif\n            // ...and continue on as in the UV_FILE case\n        case UV_FILE:\n            file = (jl_uv_file_t*)malloc(sizeof(jl_uv_file_t));\n            file->loop = jl_io_loop;\n            file->type = UV_FILE;\n            file->file = fd;\n            file->data = 0;\n            handle = file;\n            break;\n        case UV_NAMED_PIPE:\n            handle = malloc(sizeof(uv_pipe_t));\n            if (uv_pipe_init(jl_io_loop, (uv_pipe_t*)handle, (readable?UV_PIPE_READABLE:UV_PIPE_WRITABLE))) {\n                jl_errorf(\"error initializing stdio in uv_pipe_init (%d, %d)\", fd, type);\n            }\n            if (uv_pipe_open((uv_pipe_t*)handle,fd)) {\n                jl_errorf(\"error initializing stdio in uv_pipe_open (%d, %d)\", fd, type);\n            }\n            ((uv_pipe_t*)handle)->data=0;\n            break;\n        case UV_TCP:\n            handle = malloc(sizeof(uv_tcp_t));\n            if (uv_tcp_init(jl_io_loop, (uv_tcp_t*)handle)) {\n                jl_errorf(\"error initializing stdio in uv_tcp_init (%d, %d)\", fd, type);\n            }\n            if (uv_tcp_open((uv_tcp_t*)handle,fd)) {\n                jl_errorf(\"error initializing stdio in uv_tcp_open (%d, %d)\", fd, type);\n            }\n            ((uv_tcp_t*)handle)->data=0;\n            break;\n        case UV_UDP:\n        default:\n            jl_errorf(\"this type of handle for stdio is not yet supported (%d, %d)\", fd, type);\n            break;\n    }\n    return handle;\n}\n\nvoid init_stdio()\n{   //order must be 2,1,0\n    JL_STDERR = (uv_stream_t*)init_stdio_handle(STDERR_FILENO,0);\n    JL_STDOUT = (uv_stream_t*)init_stdio_handle(STDOUT_FILENO,0);\n    JL_STDIN  = (uv_stream_t*)init_stdio_handle(STDIN_FILENO,1);\n\n    jl_flush_cstdio();\n}\n\n#ifdef JL_USE_INTEL_JITEVENTS\nchar jl_using_intel_jitevents; // Non-zero if running under Intel VTune Amplifier\n#endif\n\nint isabspath(const char *in)\n{\n#ifdef _OS_WINDOWS_\n    char c0 = in[0];\n    if (c0 == '/' || c0 == '\\\\') {\n        return 1; // absolute path relative to %CD% (current drive), or UNC\n    }\n    else {\n        int s = strlen(in);\n        if (s > 2) {\n            char c1 = in[1];\n            char c2 = in[2];\n            if (c1 == ':' && (c2 == '/' || c2 == '\\\\')) return 1; // absolute path\n        }\n    }\n#else\n    if (in[0] == '/') return 1; // absolute path\n#endif\n    return 0; // relative path\n}\n\nstatic char *abspath(const char *in)\n{ // compute an absolute path location, so that chdir doesn't change the file reference\n#ifndef _OS_WINDOWS_\n    char *out = realpath(in, NULL);\n    if (!out) {\n        if (in[0] == PATHSEPSTRING[0]) {\n            out = strdup(in);\n        }\n        else {\n            size_t path_size = PATH_MAX;\n            size_t len = strlen(in);\n            char *path = (char*)malloc(PATH_MAX);\n            if (uv_cwd(path, &path_size)) {\n                jl_error(\"fatal error: unexpected error while retrieving current working directory\");\n            }\n            if (path_size + len + 1 >= PATH_MAX) {\n                jl_error(\"fatal error: current working directory path too long\");\n            }\n            path[path_size-1] = PATHSEPSTRING[0];\n            memcpy(path+path_size, in, len+1);\n            out = strdup(path);\n            free(path);\n        }\n    }\n#else\n    DWORD n = GetFullPathName(in, 0, NULL, NULL);\n    if (n <= 0) {\n        jl_error(\"fatal error: jl_options.image_file path too long or GetFullPathName failed\");\n    }\n    char *out = (char*)malloc(n);\n    DWORD m = GetFullPathName(in, n, out, NULL);\n    if (n != m + 1) {\n        jl_error(\"fatal error: jl_options.image_file path too long or GetFullPathName failed\");\n    }\n#endif\n    return out;\n}\n\nstatic void jl_resolve_sysimg_location(JL_IMAGE_SEARCH rel)\n{ // this function resolves the paths in jl_options to absolute file locations as needed\n  // and it replaces the pointers to `julia_home`, `julia_bin`, `image_file`, and output file paths\n  // it may fail, print an error, and exit(1) if any of these paths are longer than PATH_MAX\n  //\n  // note: if you care about lost memory, you should call the appropriate `free()` function\n  // on the original pointer for each `char*` you've inserted into `jl_options`, after\n  // calling `julia_init()`\n    char *free_path = (char*)malloc(PATH_MAX);\n    size_t path_size = PATH_MAX;\n    if (uv_exepath(free_path, &path_size)) {\n        jl_error(\"fatal error: unexpected error while retrieving exepath\");\n    }\n    if (path_size >= PATH_MAX) {\n        jl_error(\"fatal error: jl_options.julia_bin path too long\");\n    }\n    jl_options.julia_bin = strdup(free_path);\n    if (!jl_options.julia_home) {\n        jl_options.julia_home = getenv(\"JULIA_HOME\");\n        if (!jl_options.julia_home) {\n            jl_options.julia_home = dirname(free_path);\n        }\n    }\n    if (jl_options.julia_home)\n        jl_options.julia_home = abspath(jl_options.julia_home);\n    free(free_path);\n    free_path = NULL;\n    if (jl_options.image_file) {\n        if (rel == JL_IMAGE_JULIA_HOME && !isabspath(jl_options.image_file)) {\n            // build time path, relative to JULIA_HOME\n            free_path = (char*)malloc(PATH_MAX);\n            int n = snprintf(free_path, PATH_MAX, \"%s\" PATHSEPSTRING \"%s\",\n                             jl_options.julia_home, jl_options.image_file);\n            if (n >= PATH_MAX || n < 0) {\n                jl_error(\"fatal error: jl_options.image_file path too long\");\n            }\n            jl_options.image_file = free_path;\n        }\n        if (jl_options.image_file)\n            jl_options.image_file = abspath(jl_options.image_file);\n        if (free_path) {\n            free(free_path);\n            free_path = NULL;\n        }\n    }\n    if (jl_options.outputo)\n        jl_options.outputo = abspath(jl_options.outputo);\n    if (jl_options.outputji)\n        jl_options.outputji = abspath(jl_options.outputji);\n    if (jl_options.outputbc)\n        jl_options.outputbc = abspath(jl_options.outputbc);\n    if (jl_options.machinefile)\n        jl_options.machinefile = abspath(jl_options.machinefile);\n    if (jl_options.load)\n        jl_options.load = abspath(jl_options.load);\n}\n\nvoid _julia_init(JL_IMAGE_SEARCH rel)\n{\n    libsupport_init();\n    jl_io_loop = uv_default_loop(); // this loop will internal events (spawning process etc.),\n                                    // best to call this first, since it also initializes libuv\n    restore_signals();\n    jl_resolve_sysimg_location(rel);\n    // loads sysimg if available, and conditionally sets jl_options.cpu_target\n    jl_preload_sysimg_so(jl_options.image_file);\n    if (jl_options.cpu_target == NULL)\n        jl_options.cpu_target = \"native\";\n\n    jl_page_size = jl_getpagesize();\n    uint64_t total_mem = uv_get_total_memory();\n    if (total_mem >= (size_t)-1) {\n        total_mem = (size_t)-1;\n    }\n    jl_arr_xtralloc_limit = total_mem / 100;  // Extra allocation limited to 1% of total RAM\n    jl_find_stack_bottom();\n    jl_dl_handle = (uv_lib_t *) jl_load_dynamic_library(NULL, JL_RTLD_DEFAULT);\n#ifdef RTLD_DEFAULT\n    jl_RTLD_DEFAULT_handle->handle = RTLD_DEFAULT;\n#else\n    jl_RTLD_DEFAULT_handle->handle = jl_dl_handle->handle;\n#endif\n#ifdef _OS_WINDOWS_\n    uv_dlopen(\"ntdll.dll\", jl_ntdll_handle); // bypass julia's pathchecking for system dlls\n    uv_dlopen(\"kernel32.dll\", jl_kernel32_handle);\n#if _MSC_VER == 1800\n    uv_dlopen(\"msvcr120.dll\", jl_crtdll_handle);\n#else\n    uv_dlopen(\"msvcrt.dll\", jl_crtdll_handle);\n#endif\n    uv_dlopen(\"ws2_32.dll\", jl_winsock_handle);\n    _jl_exe_handle.handle = GetModuleHandleA(NULL);\n    if (!DuplicateHandle(GetCurrentProcess(), GetCurrentThread(),\n                         GetCurrentProcess(), (PHANDLE)&hMainThread, 0,\n                         TRUE, DUPLICATE_SAME_ACCESS)) {\n        jl_printf(JL_STDERR, \"WARNING: failed to access handle to main thread\\n\");\n    }\n    SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_LINES);\n    if (!SymInitialize(GetCurrentProcess(), NULL, 1)) {\n        jl_printf(JL_STDERR, \"WARNING: failed to initialize stack walk info\\n\");\n    }\n    needsSymRefreshModuleList = 0;\n    uv_lib_t jl_dbghelp;\n    uv_dlopen(\"dbghelp.dll\",&jl_dbghelp);\n    if (uv_dlsym(&jl_dbghelp, \"SymRefreshModuleList\", (void**)&hSymRefreshModuleList))\n        hSymRefreshModuleList = 0;\n#endif\n\n#if defined(JL_USE_INTEL_JITEVENTS)\n    const char *jit_profiling = getenv(\"ENABLE_JITPROFILING\");\n    if (jit_profiling && atoi(jit_profiling)) {\n        jl_using_intel_jitevents = 1;\n    }\n#endif\n\n    jl_gc_init();\n    jl_gc_enable(0);\n    jl_init_frontend();\n    jl_init_types();\n    jl_init_tasks();\n    jl_init_root_task(jl_stack_lo, jl_stack_hi-jl_stack_lo);\n\n    init_stdio();\n    // libuv stdio cleanup depends on jl_init_tasks() because JL_TRY is used in jl_atexit_hook()\n\n    jl_init_codegen();\n    jl_an_empty_cell = (jl_value_t*)jl_alloc_cell_1d(0);\n    jl_init_serializer();\n\n    if (!jl_options.image_file) {\n        jl_core_module = jl_new_module(jl_symbol(\"Core\"));\n        jl_top_module = jl_core_module;\n        jl_init_intrinsic_functions();\n        jl_init_primitives();\n\n        jl_new_main_module();\n        jl_internal_main_module = jl_main_module;\n\n        jl_current_module = jl_core_module;\n        jl_root_task->current_module = jl_current_module;\n\n        jl_load(\"boot.jl\", sizeof(\"boot.jl\"));\n        jl_get_builtin_hooks();\n        jl_boot_file_loaded = 1;\n        jl_init_box_caches();\n    }\n\n    if (jl_options.image_file) {\n        JL_TRY {\n            jl_restore_system_image(jl_options.image_file);\n        }\n        JL_CATCH {\n            jl_printf(JL_STDERR, \"error during init:\\n\");\n            jl_static_show(JL_STDERR, jl_exception_in_transit);\n            jl_printf(JL_STDERR, \"\\n\");\n            jl_exit(1);\n        }\n    }\n\n    // set module field of primitive types\n    int i;\n    void **table = jl_core_module->bindings.table;\n    for(i=1; i < jl_core_module->bindings.size; i+=2) {\n        if (table[i] != HT_NOTFOUND) {\n            jl_binding_t *b = (jl_binding_t*)table[i];\n            if (b->value && jl_is_datatype(b->value)) {\n                jl_datatype_t *tt = (jl_datatype_t*)b->value;\n                tt->name->module = jl_core_module;\n            }\n        }\n    }\n\n    // the Main module is the one which is always open, and set as the\n    // current module for bare (non-module-wrapped) toplevel expressions.\n    // it does \"using Base\" if Base is available.\n    if (jl_base_module != NULL) {\n        jl_add_standard_imports(jl_main_module);\n    }\n    // eval() uses Main by default, so Main.eval === Core.eval\n    jl_module_import(jl_main_module, jl_core_module, jl_symbol(\"eval\"));\n    jl_current_module = jl_main_module;\n    jl_root_task->current_module = jl_current_module;\n\n    if (jl_options.handle_signals == JL_OPTIONS_HANDLE_SIGNALS_ON)\n        jl_install_default_signal_handlers();\n\n    jl_gc_enable(1);\n\n    if (jl_options.image_file) {\n        jl_array_t *temp = jl_module_init_order;\n        JL_GC_PUSH1(&temp);\n        jl_module_init_order = NULL;\n        jl_init_restored_modules(temp);\n        JL_GC_POP();\n    }\n\n    if (jl_options.handle_signals == JL_OPTIONS_HANDLE_SIGNALS_ON)\n        jl_install_sigint_handler();\n}\n\nextern int asprintf(char **str, const char *fmt, ...);\n\nDLLEXPORT int jl_generating_output()\n{\n    return jl_options.outputo || jl_options.outputbc || jl_options.outputji;\n}\n\nvoid jl_compile_all(void);\n\nstatic void julia_save()\n{\n    if (jl_options.compile_enabled == JL_OPTIONS_COMPILE_ALL)\n        jl_compile_all();\n\n    if (jl_options.incremental) {\n        jl_array_t *worklist = jl_module_init_order;\n        if (!worklist) {\n            jl_printf(JL_STDERR, \"WARNING: incremental output requested, but no modules defined during run\\n\");\n            return;\n        }\n        if (jl_options.outputji)\n            if (jl_save_incremental(jl_options.outputji, worklist))\n                jl_exit(1);\n        if (jl_options.outputbc)\n            jl_printf(JL_STDERR, \"WARNING: incremental output to a .bc file is not implemented\\n\");\n        if (jl_options.outputo)\n            jl_printf(JL_STDERR, \"WARNING: incremental output to a .o file is not implemented\\n\");\n    }\n    else {\n        ios_t *s = NULL;\n        if (jl_options.outputo || jl_options.outputbc)\n            s = jl_create_system_image();\n\n        if (jl_options.outputji) {\n            if (s == NULL) {\n                jl_save_system_image(jl_options.outputji);\n            }\n            else {\n                ios_t f;\n                if (ios_file(&f, jl_options.outputji, 1, 1, 1, 1) == NULL)\n                    jl_errorf(\"cannot open system image file \\\"%s\\\" for writing\", jl_options.outputji);\n                ios_write(&f, (const char*)s->buf, s->size);\n                ios_close(&f);\n            }\n        }\n\n        if (jl_options.outputbc)\n            jl_dump_bitcode((char*)jl_options.outputbc, (const char*)s->buf, s->size);\n\n        if (jl_options.outputo)\n            jl_dump_objfile((char*)jl_options.outputo, 0, (const char*)s->buf, s->size);\n    }\n}\n\njl_function_t *jl_typeinf_func=NULL;\n\nDLLEXPORT void jl_set_typeinf_func(jl_value_t* f)\n{\n    if (!jl_is_function(f))\n        jl_error(\"jl_set_typeinf_func must set a jl_function_t*\");\n    jl_typeinf_func = (jl_function_t*)f;\n}\n\nstatic jl_value_t *core(char *name)\n{\n    return jl_get_global(jl_core_module, jl_symbol(name));\n}\n\nstatic jl_value_t *basemod(char *name)\n{\n    return jl_get_global(jl_base_module, jl_symbol(name));\n}\n\n// fetch references to things defined in boot.jl\nvoid jl_get_builtin_hooks(void)\n{\n    jl_root_task->tls = jl_nothing;\n    jl_root_task->consumers = jl_nothing;\n    jl_root_task->donenotify = jl_nothing;\n    jl_root_task->exception = jl_nothing;\n    jl_root_task->result = jl_nothing;\n\n    jl_char_type    = (jl_datatype_t*)core(\"Char\");\n    jl_int8_type    = (jl_datatype_t*)core(\"Int8\");\n    jl_uint8_type   = (jl_datatype_t*)core(\"UInt8\");\n    jl_int16_type   = (jl_datatype_t*)core(\"Int16\");\n    jl_uint16_type  = (jl_datatype_t*)core(\"UInt16\");\n    jl_uint32_type  = (jl_datatype_t*)core(\"UInt32\");\n    jl_uint64_type  = (jl_datatype_t*)core(\"UInt64\");\n\n    jl_float16_type = (jl_datatype_t*)core(\"Float16\");\n    jl_float32_type = (jl_datatype_t*)core(\"Float32\");\n    jl_float64_type = (jl_datatype_t*)core(\"Float64\");\n    jl_floatingpoint_type = (jl_datatype_t*)core(\"AbstractFloat\");\n    jl_number_type = (jl_datatype_t*)core(\"Number\");\n    jl_signed_type = (jl_datatype_t*)core(\"Signed\");\n\n    jl_stackovf_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"StackOverflowError\"));\n    jl_diverror_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"DivideError\"));\n    jl_domain_exception    = jl_new_struct_uninit((jl_datatype_t*)core(\"DomainError\"));\n    jl_overflow_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"OverflowError\"));\n    jl_inexact_exception   = jl_new_struct_uninit((jl_datatype_t*)core(\"InexactError\"));\n    jl_undefref_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"UndefRefError\"));\n    jl_undefvarerror_type  = (jl_datatype_t*)core(\"UndefVarError\");\n    jl_interrupt_exception = jl_new_struct_uninit((jl_datatype_t*)core(\"InterruptException\"));\n    jl_boundserror_type    = (jl_datatype_t*)core(\"BoundsError\");\n    jl_memory_exception    = jl_new_struct_uninit((jl_datatype_t*)core(\"OutOfMemoryError\"));\n    jl_readonlymemory_exception = jl_new_struct_uninit((jl_datatype_t*)core(\"ReadOnlyMemoryError\"));\n    jl_typeerror_type = (jl_datatype_t*)core(\"TypeError\");\n\n#ifdef SEGV_EXCEPTION\n    jl_segv_exception      = jl_new_struct_uninit((jl_datatype_t*)core(\"SegmentationFault\"));\n#endif\n\n    jl_ascii_string_type = (jl_datatype_t*)core(\"ASCIIString\");\n    jl_utf8_string_type = (jl_datatype_t*)core(\"UTF8String\");\n    jl_symbolnode_type = (jl_datatype_t*)core(\"SymbolNode\");\n    jl_weakref_type = (jl_datatype_t*)core(\"WeakRef\");\n\n    jl_array_uint8_type = jl_apply_type((jl_value_t*)jl_array_type,\n                                        jl_svec2(jl_uint8_type, jl_box_long(1)));\n}\n\nDLLEXPORT void jl_get_system_hooks(void)\n{\n    if (jl_errorexception_type) return; // only do this once\n\n    jl_errorexception_type = (jl_datatype_t*)basemod(\"ErrorException\");\n    jl_argumenterror_type = (jl_datatype_t*)basemod(\"ArgumentError\");\n    jl_methoderror_type = (jl_datatype_t*)basemod(\"MethodError\");\n    jl_loaderror_type = (jl_datatype_t*)basemod(\"LoadError\");\n    jl_initerror_type = (jl_datatype_t*)basemod(\"InitError\");\n    jl_complex_type = (jl_datatype_t*)basemod(\"Complex\");\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/src/dump.c": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n/*\n  saving and restoring system images\n*/\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"builtin_proto.h\"\n\n#ifndef _OS_WINDOWS_\n#include <dlfcn.h>\n#endif\n\n#ifndef _COMPILER_MICROSOFT_\n#include \"valgrind.h\"\n#else\n#define RUNNING_ON_VALGRIND 0\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// TODO: put WeakRefs on the weak_refs list during deserialization\n// TODO: handle finalizers\n\n// hash of definitions for predefined tagged object\nstatic htable_t ser_tag;\n// array of definitions for the predefined tagged object types\n// (reverse of ser_tag)\nstatic jl_value_t *deser_tag[256];\n// hash of some common symbols, encoded as CommonSym_tag plus 1 byte\nstatic htable_t common_symbol_tag;\nstatic jl_value_t *deser_symbols[256];\n\n// table of all objects that have been deserialized, indexed by pos\n// (the order in the serializer stream) in MODE_MODULE, the low\n// bit is reserved for flagging certain entries and pos is\n// left shift by 1\nstatic htable_t backref_table;\nint backref_table_numel;\nstatic arraylist_t backref_list;\n\n// list of (jl_value_t **loc, size_t pos) entries\n// for anything that was flagged by the deserializer for later\n// type-rewriting of some sort\nstatic arraylist_t flagref_list;\n\n// list of (size_t pos, (void *f)(jl_value_t*)) entries\n// for the serializer to mark values in need of rework by function f\n// during deserialization later\nstatic arraylist_t reinit_list;\n\n// list of any methtable objects that were deserialized in MODE_MODULE\n// and need to be rehashed after assigning the uid fields to types\n// (only used in MODE_MODULE and MODE_MODULE_POSTWORK)\nstatic arraylist_t methtable_list;\n\n// list of stuff that is being serialized\n// (only used by the incremental serializer in MODE_MODULE)\nstatic jl_array_t *serializer_worklist;\n\n// hash of definitions for predefined function pointers\nstatic htable_t fptr_to_id;\n// array of definitions for the predefined function pointers\n// (reverse of fptr_to_id)\nstatic jl_fptr_t id_to_fptrs[] = {\n  NULL, NULL,\n  jl_f_throw, jl_f_is, jl_f_no_function, jl_f_typeof,\n  jl_f_subtype, jl_f_isa, jl_f_typeassert, jl_f_apply,\n  jl_f_top_eval, jl_f_isdefined, jl_f_tuple, jl_f_svec,\n  jl_f_get_field, jl_f_set_field, jl_f_field_type, jl_f_nfields,\n  jl_f_arraylen, jl_f_arrayref, jl_f_arrayset, jl_f_arraysize,\n  jl_f_instantiate_type, jl_f_kwcall, jl_trampoline,\n  jl_f_methodexists, jl_f_applicable, jl_f_invoke,\n  jl_apply_generic, jl_unprotect_stack, jl_f_sizeof, jl_f_new_expr,\n  NULL };\n\n// pointers to non-AST-ish objects in a compressed tree\nstatic jl_array_t *tree_literal_values=NULL;    // (only used in MODE_AST)\nstatic jl_module_t *tree_enclosing_module=NULL; // (only used in MODE_AST)\n\nstatic const ptrint_t LongSymbol_tag   = 23;\nstatic const ptrint_t LongSvec_tag     = 24;\nstatic const ptrint_t LongExpr_tag     = 25;\nstatic const ptrint_t LiteralVal_tag   = 26;\nstatic const ptrint_t SmallInt64_tag   = 27;\nstatic const ptrint_t SmallDataType_tag= 28;\nstatic const ptrint_t Int32_tag        = 29;\nstatic const ptrint_t Array1d_tag      = 30;\nstatic const ptrint_t Singleton_tag    = 31;\nstatic const ptrint_t CommonSym_tag    = 32;\nstatic const ptrint_t NearbyGlobal_tag = 33;  // a GlobalRef pointing to tree_enclosing_module\nstatic const ptrint_t Null_tag         = 253;\nstatic const ptrint_t ShortBackRef_tag = 254;\nstatic const ptrint_t BackRef_tag      = 255;\n\nstatic ptrint_t VALUE_TAGS;\n\ntypedef enum _DUMP_MODES {\n    // not in the serializer at all, or\n    // something is seriously wrong\n    MODE_INVALID = 0,\n\n    // jl_uncompress_ast\n    // compressing / decompressing an AST Expr in a LambdaStaticData\n    MODE_AST,\n\n    // jl_restore_system_image\n    // restoring an entire system image from disk\n    MODE_SYSTEM_IMAGE,\n\n    // jl_restore_new_module\n    // restoring a single module from disk for integration\n    // into the currently running system image / environment\n    MODE_MODULE, // first-stage (pre type-uid assignment)\n    MODE_MODULE_POSTWORK, // second-stage (post type-uid assignment)\n} DUMP_MODES;\nstatic DUMP_MODES mode = (DUMP_MODES) 0;\n\nstatic jl_value_t *jl_idtable_type=NULL;\n\n// queue of types to cache\nstatic jl_array_t *datatype_list=NULL; // (only used in MODE_SYSTEM_IMAGE)\n\n#define write_uint8(s, n) ios_putc((n), (s))\n#define read_uint8(s) ((uint8_t)ios_getc(s))\n#define write_int8(s, n) write_uint8(s, n)\n#define read_int8(s) read_uint8(s)\n\n/* read and write in network (bigendian) order: */\n\nstatic void write_int32(ios_t *s, int32_t i)\n{\n    write_uint8(s, (i>>24) & 0xff);\n    write_uint8(s, (i>>16) & 0xff);\n    write_uint8(s, (i>> 8) & 0xff);\n    write_uint8(s, i       & 0xff);\n}\n\nstatic int32_t read_int32(ios_t *s)\n{\n    int b3 = read_uint8(s);\n    int b2 = read_uint8(s);\n    int b1 = read_uint8(s);\n    int b0 = read_uint8(s);\n    return b0 | (b1<<8) | (b2<<16) | (b3<<24);\n}\n\nstatic void write_uint64(ios_t *s, uint64_t i)\n{\n    write_int32(s, (i>>32) & 0xffffffff);\n    write_int32(s, i       & 0xffffffff);\n}\n\nstatic uint64_t read_uint64(ios_t *s)\n{\n    uint64_t b1 = (uint32_t)read_int32(s);\n    uint64_t b0 = (uint32_t)read_int32(s);\n    return b0 | (b1<<32);\n}\n\nstatic void write_uint16(ios_t *s, uint16_t i)\n{\n    write_uint8(s, (i>> 8) & 0xff);\n    write_uint8(s, i       & 0xff);\n}\n\nstatic uint16_t read_uint16(ios_t *s)\n{\n    int b1 = read_uint8(s);\n    int b0 = read_uint8(s);\n    return b0 | (b1<<8);\n}\n\nstatic void writetag(ios_t *s, void *v)\n{\n    write_uint8(s, (uint8_t)(ptrint_t)ptrhash_get(&ser_tag, v));\n}\n\nstatic void write_as_tag(ios_t *s, uint8_t tag)\n{\n    if (tag < VALUE_TAGS) {\n        write_uint8(s, 0);\n    }\n    write_uint8(s, tag);\n}\n\nstatic void write_float64(ios_t *s, double x)\n{\n    write_uint64(s, *((uint64_t*)&x));\n}\n\n// --- Static Compile ---\n\n#define jl_serialize_value(s, v) jl_serialize_value_(s,(jl_value_t*)(v))\nstatic void jl_serialize_value_(ios_t *s, jl_value_t *v);\nstatic jl_value_t *jl_deserialize_value(ios_t *s, jl_value_t **loc);\njl_value_t ***sysimg_gvars = NULL;\n\n#ifdef HAVE_CPUID\nextern void jl_cpuid(int32_t CPUInfo[4], int32_t InfoType);\n#endif\n\nextern int globalUnique;\nuv_lib_t *jl_sysimg_handle = NULL;\nuint64_t jl_sysimage_base = 0;\n#ifdef _OS_WINDOWS_\n#include <dbghelp.h>\n#endif\n\nDLLEXPORT int jl_running_on_valgrind()\n{\n    return RUNNING_ON_VALGRIND;\n}\n\nstatic int jl_load_sysimg_so()\n{\n#ifndef _OS_WINDOWS_\n    Dl_info dlinfo;\n#endif\n    // attempt to load the pre-compiled sysimage from jl_sysimg_handle\n    if (jl_sysimg_handle == 0)\n        return -1;\n\n    int imaging_mode = jl_generating_output() && !jl_options.incremental;\n    // in --build mode only use sysimg data, not precompiled native code\n    if (!imaging_mode && jl_options.use_precompiled==JL_OPTIONS_USE_PRECOMPILED_YES) {\n        sysimg_gvars = (jl_value_t***)jl_dlsym(jl_sysimg_handle, \"jl_sysimg_gvars\");\n        globalUnique = *(size_t*)jl_dlsym(jl_sysimg_handle, \"jl_globalUnique\");\n        const char *cpu_target = (const char*)jl_dlsym(jl_sysimg_handle, \"jl_sysimg_cpu_target\");\n        if (strcmp(cpu_target,jl_options.cpu_target) != 0)\n            jl_error(\"Julia and the system image were compiled for different architectures.\\n\"\n                     \"Please delete or regenerate sys.{so,dll,dylib}.\");\n#ifdef HAVE_CPUID\n        uint32_t info[4];\n        jl_cpuid((int32_t*)info, 1);\n        if (strcmp(cpu_target, \"native\") == 0) {\n            if (!RUNNING_ON_VALGRIND) {\n                uint64_t saved_cpuid = *(uint64_t*)jl_dlsym(jl_sysimg_handle, \"jl_sysimg_cpu_cpuid\");\n                if (saved_cpuid != (((uint64_t)info[2])|(((uint64_t)info[3])<<32)))\n                    jl_error(\"Target architecture mismatch. Please delete or regenerate sys.{so,dll,dylib}.\");\n            }\n        }\n        else if (strcmp(cpu_target,\"core2\") == 0) {\n            int HasSSSE3 = (info[2] & 1<<9);\n            if (!HasSSSE3)\n                jl_error(\"The current host does not support SSSE3, but the system image was compiled for Core2.\\n\"\n                         \"Please delete or regenerate sys.{so,dll,dylib}.\");\n        }\n#endif\n\n#ifdef _OS_WINDOWS_\n        jl_sysimage_base = (intptr_t)jl_sysimg_handle->handle;\n#else\n        if (dladdr((void*)sysimg_gvars, &dlinfo) != 0) {\n            jl_sysimage_base = (intptr_t)dlinfo.dli_fbase;\n        }\n        else {\n            jl_sysimage_base = 0;\n        }\n#endif\n    }\n    const char *sysimg_data = (const char*)jl_dlsym_e(jl_sysimg_handle, \"jl_system_image_data\");\n    if (sysimg_data) {\n        size_t len = *(size_t*)jl_dlsym(jl_sysimg_handle, \"jl_system_image_size\");\n        jl_restore_system_image_data(sysimg_data, len);\n        return 0;\n    }\n    return -1;\n}\n\nstatic jl_value_t *jl_deserialize_gv(ios_t *s, jl_value_t *v)\n{\n    // Restore the GlobalVariable reference to this jl_value_t via the sysimg_gvars table\n    int32_t gvname_index = read_int32(s)-1;\n    if (sysimg_gvars != NULL && gvname_index >= 0 && mode == MODE_SYSTEM_IMAGE) {\n        *sysimg_gvars[gvname_index] = v;\n    }\n    return v;\n}\n\nstatic void jl_serialize_gv(ios_t *s, jl_value_t *v)\n{\n    // write the index of the literal_pointer_val into the system image\n    write_int32(s, jl_get_llvm_gv(v));\n}\n\nstatic void jl_serialize_globalvals(ios_t *s)\n{\n    size_t i, len = backref_table.size;\n    void **p = backref_table.table;\n    for(i=0; i < len; i+=2) {\n        char *offs = (char*)p[i+1];\n        if (offs != HT_NOTFOUND) {\n            uintptr_t pos = offs - (char*)HT_NOTFOUND - 1;\n            int32_t gv = jl_get_llvm_gv((jl_value_t*)p[i]);\n            if (gv != 0) {\n                write_int32(s, pos + 1);\n                write_int32(s, gv);\n            }\n        }\n    }\n    write_int32(s, 0);\n}\n\nstatic void jl_deserialize_globalvals(ios_t *s)\n{\n    while (1) {\n        intptr_t key = read_int32(s);\n        if (key == 0) break;\n        jl_deserialize_gv(s, (jl_value_t*)backref_list.items[key - 1]);\n    }\n}\n\nstatic void jl_serialize_gv_syms(ios_t *s, jl_sym_t *v)\n{\n    // since symbols are static, they might not have had a\n    // reference anywhere in the code image other than here\n    void *bp = ptrhash_get(&backref_table, v);\n    if (bp == HT_NOTFOUND) {\n        int32_t gv = jl_get_llvm_gv((jl_value_t*)v);\n        if (gv != 0) {\n            jl_serialize_value(s, v);\n            write_int32(s, gv);\n        }\n    }\n    if (v->left) jl_serialize_gv_syms(s, v->left);\n    if (v->right) jl_serialize_gv_syms(s, v->right);\n}\n\nstatic void jl_serialize_gv_others(ios_t *s)\n{\n    // ensures all objects referenced in the code have\n    // references in the system image to their global variable\n    // since codegen knows that some integer boxes are static,\n    // they might not have had a reference anywhere in the code\n    // image other than here\n    int32_t i;\n    for (i = -512; i < 512; i++) {\n        jl_value_t *v32 = jl_box_int32(i);\n        void *bp32 = ptrhash_get(&backref_table, v32);\n        if (bp32 == HT_NOTFOUND) {\n            int32_t gv32 = jl_get_llvm_gv(v32);\n            if (gv32 != 0) {\n                jl_serialize_value(s, v32);\n                write_int32(s, gv32);\n            }\n        }\n    }\n    for (i = -512; i < 512; i++) {\n        jl_value_t *v64 = jl_box_int64(i);\n        void *bp64 = ptrhash_get(&backref_table, v64);\n        if (bp64 == HT_NOTFOUND) {\n            int32_t gv64 = jl_get_llvm_gv(v64);\n            if (gv64 != 0) {\n                jl_serialize_value(s, v64);\n                write_int32(s, gv64);\n            }\n        }\n    }\n    jl_serialize_gv_syms(s, jl_get_root_symbol());\n    jl_serialize_value(s, NULL); // signal the end of this list\n}\n\nstatic void jl_deserialize_gv_others(ios_t *s)\n{\n    while (1) {\n        jl_value_t *v = jl_deserialize_value(s, NULL);\n        if (!v) break;\n        jl_deserialize_gv(s, v);\n    }\n}\n\nstruct delayed_fptrs_t {\n    jl_lambda_info_t *li;\n    int32_t func;\n    int32_t cfunc;\n} *delayed_fptrs = NULL;\nstatic size_t delayed_fptrs_n = 0;\nstatic size_t delayed_fptrs_max = 0;\n\nstatic void jl_delayed_fptrs(jl_lambda_info_t *li, int32_t func, int32_t cfunc)\n{\n    // can't restore the fptrs until after the system image is fully restored,\n    // since it will try to decompress the function AST to determine the argument types\n    if (cfunc || func) {\n        if (delayed_fptrs_max < delayed_fptrs_n + 1) {\n            if (delayed_fptrs_max == 0)\n                // current measurements put the number of functions at 1130\n                delayed_fptrs_max = 2048;\n            else\n                delayed_fptrs_max *= 2;\n            delayed_fptrs = (struct delayed_fptrs_t*)realloc(delayed_fptrs, delayed_fptrs_max*sizeof(delayed_fptrs[0])); //assumes sizeof==alignof\n        }\n        delayed_fptrs[delayed_fptrs_n].li = li;\n        delayed_fptrs[delayed_fptrs_n].func = func;\n        delayed_fptrs[delayed_fptrs_n].cfunc = cfunc;\n        delayed_fptrs_n++;\n    }\n}\n\nstatic void jl_update_all_fptrs()\n{\n    //jl_printf(JL_STDOUT, \"delayed_fptrs_n: %d\\n\", delayed_fptrs_n);\n    jl_value_t ***gvars = sysimg_gvars;\n    if (gvars == 0) return;\n    // jl_fptr_to_llvm needs to decompress some ASTs, therefore this needs to be NULL\n    // to skip trying to restore GlobalVariable pointers in jl_deserialize_gv\n    sysimg_gvars = NULL;\n    size_t i;\n    for (i = 0; i < delayed_fptrs_n; i++) {\n        jl_lambda_info_t *li = delayed_fptrs[i].li;\n        int32_t func = delayed_fptrs[i].func-1;\n        if (func >= 0) {\n            jl_fptr_to_llvm((void*)gvars[func], li, 0);\n        }\n        int32_t cfunc = delayed_fptrs[i].cfunc-1;\n        if (cfunc >= 0) {\n            jl_fptr_to_llvm((void*)gvars[cfunc], li, 1);\n        }\n    }\n    delayed_fptrs_n = 0;\n    delayed_fptrs_max = 0;\n    free(delayed_fptrs);\n    delayed_fptrs = NULL;\n}\n\n// --- serialize ---\n\nstatic void jl_serialize_fptr(ios_t *s, void *fptr)\n{\n    void **pbp = ptrhash_bp(&fptr_to_id, fptr);\n    if (*pbp == HT_NOTFOUND)\n        jl_error(\"unknown function pointer\");\n    write_uint16(s, *(ptrint_t*)pbp);\n}\n\nstatic int module_in_worklist(jl_module_t *mod) {\n    int i, l = jl_array_len(serializer_worklist);\n    for (i = 0; i < l; i++) {\n        jl_module_t *workmod = (jl_module_t*)jl_cellref(serializer_worklist, i);\n        if (jl_is_module(workmod) && jl_is_submodule(mod, workmod))\n            return 1;\n    }\n    return 0;\n}\n\nstatic void jl_serialize_datatype(ios_t *s, jl_datatype_t *dt)\n{\n    int tag = 0;\n    if (mode == MODE_MODULE_POSTWORK) {\n        if (dt->uid != 0) {\n            if (dt->name->primary == (jl_value_t*)dt)\n                tag = 6; // primary type\n            else\n                tag = 7; // must use apply_type\n        }\n    }\n    else if (mode == MODE_MODULE) {\n        int internal = module_in_worklist(dt->name->module);\n        int i, l = jl_array_len(serializer_worklist);\n        for (i = 0; i < l; i++) {\n            jl_module_t *mod = (jl_module_t*)jl_cellref(serializer_worklist, i);\n            if (jl_is_module(mod) && jl_is_submodule(dt->name->module, mod)) {\n                internal = 1;\n                break;\n            }\n        }\n        if (!internal && dt->name->primary == (jl_value_t*)dt) {\n            tag = 6; // external primary type\n        }\n        else if (dt->uid == 0) {\n            tag = 0; // normal struct\n        }\n        else if (!internal && jl_svec_len(dt->parameters) == 0) {\n            tag = 7; // external type that can be immediately recreated (with apply_type)\n        }\n        else {\n            tag = 5; // anything else (needs uid assigned later)\n            if (!internal) {\n                // also flag this in the backref table as special\n                uptrint_t *bp = (uptrint_t*)ptrhash_bp(&backref_table, dt);\n                assert(*bp != (uptrint_t)HT_NOTFOUND);\n                *bp |= 1; assert(((uptrint_t)HT_NOTFOUND)|1);\n            }\n        }\n    }\n    else if (dt == jl_int32_type)\n        tag = 2;\n    else if (dt == jl_bool_type)\n        tag = 3;\n    else if (dt == jl_int64_type)\n        tag = 4;\n    writetag(s, (jl_value_t*)SmallDataType_tag);\n    write_uint8(s, 0); // virtual size\n    jl_serialize_value(s, (jl_value_t*)jl_datatype_type);\n    write_uint8(s, tag);\n    if (tag == 6) {\n        jl_serialize_value(s, dt->name);\n        return;\n    }\n    if (tag == 7) {\n        jl_serialize_value(s, dt->name);\n        jl_serialize_value(s, dt->parameters);\n        return;\n    }\n    size_t nf = jl_datatype_nfields(dt);\n    write_uint16(s, nf);\n    write_int32(s, dt->size);\n    int has_instance = !!(dt->instance != NULL);\n    write_uint8(s, dt->abstract | (dt->mutabl<<1) | (dt->pointerfree<<2) | (has_instance<<3));\n    write_int8(s, dt->fielddesc_type);\n    if (!dt->abstract) {\n        write_uint16(s, dt->ninitialized);\n        if (mode != MODE_MODULE && mode != MODE_MODULE_POSTWORK) {\n            write_int32(s, dt->uid);\n        }\n    }\n    if (has_instance)\n        jl_serialize_value(s, dt->instance);\n    if (nf > 0) {\n        write_int32(s, dt->alignment);\n        write_int8(s, dt->haspadding);\n        size_t fieldsize = jl_fielddesc_size(dt->fielddesc_type);\n        ios_write(s, (char*)dt->fields, nf * fieldsize);\n        jl_serialize_value(s, dt->types);\n    }\n\n    jl_serialize_value(s, dt->parameters);\n    jl_serialize_value(s, dt->name);\n    jl_serialize_value(s, dt->super);\n}\n\nstatic void jl_serialize_module(ios_t *s, jl_module_t *m)\n{\n    writetag(s, jl_module_type);\n    jl_serialize_value(s, m->name);\n    int ref_only = 0;\n    if (mode == MODE_MODULE_POSTWORK) {\n        assert(!module_in_worklist(m));\n        ref_only = 1;\n    }\n    if (mode == MODE_MODULE) {\n        if (!module_in_worklist(m))\n            ref_only = 1;\n        write_int8(s, ref_only);\n    }\n    jl_serialize_value(s, m->parent);\n    if (ref_only) {\n        assert(m->parent != m);\n        return;\n    }\n    size_t i;\n    void **table = m->bindings.table;\n    for(i=1; i < m->bindings.size; i+=2) {\n        if (table[i] != HT_NOTFOUND) {\n            jl_binding_t *b = (jl_binding_t*)table[i];\n            if (b->owner == m || m != jl_main_module) {\n                jl_serialize_value(s, b->name);\n                jl_serialize_value(s, b->value);\n                jl_serialize_value(s, b->globalref);\n                jl_serialize_value(s, b->owner);\n                write_int8(s, (b->deprecated<<3) | (b->constp<<2) | (b->exportp<<1) | (b->imported));\n                jl_serialize_gv(s, (jl_value_t*)b);\n            }\n        }\n    }\n    jl_serialize_value(s, NULL);\n    if (m == jl_main_module) {\n        write_int32(s, 1);\n        jl_serialize_value(s, (jl_value_t*)jl_core_module);\n    }\n    else {\n        write_int32(s, m->usings.len);\n        for(i=0; i < m->usings.len; i++) {\n            jl_serialize_value(s, (jl_value_t*)m->usings.items[i]);\n        }\n    }\n    jl_serialize_value(s, m->constant_table);\n    write_uint8(s, m->istopmod);\n    write_uint8(s, m->std_imports);\n    write_uint64(s, m->uuid);\n}\n\nstatic int is_ast_node(jl_value_t *v)\n{\n    if (jl_is_lambda_info(v)) {\n        jl_lambda_info_t *li = (jl_lambda_info_t*)v;\n        if (jl_is_expr(li->ast)) {\n            li->ast = jl_compress_ast(li, li->ast);\n            jl_gc_wb(li, li->ast);\n        }\n        return 0;\n    }\n    return jl_is_symbol(v) || jl_is_symbolnode(v) || jl_is_gensym(v) ||\n        jl_is_expr(v) || jl_is_newvarnode(v) || jl_is_svec(v) ||\n        jl_typeis(v, jl_array_any_type) || jl_is_tuple(v) ||\n        jl_is_uniontype(v) || jl_is_int32(v) || jl_is_int64(v) ||\n        jl_is_bool(v) || jl_is_typevar(v) ||\n        jl_is_topnode(v) || jl_is_quotenode(v) || jl_is_gotonode(v) ||\n        jl_is_labelnode(v) || jl_is_linenode(v) || jl_is_globalref(v);\n}\n\nstatic int literal_val_id(jl_value_t *v)\n{\n    for(int i=0; i < jl_array_len(tree_literal_values); i++) {\n        if (jl_egal(jl_cellref(tree_literal_values,i), v))\n            return i;\n    }\n    jl_cell_1d_push(tree_literal_values, v);\n    return jl_array_len(tree_literal_values)-1;\n}\n\nstatic void jl_serialize_value_(ios_t *s, jl_value_t *v)\n{\n    if (v == NULL) {\n        write_uint8(s, Null_tag);\n        return;\n    }\n\n    void **bp = ptrhash_bp(&ser_tag, v);\n    if (*bp != HT_NOTFOUND) {\n        write_as_tag(s, (uint8_t)(ptrint_t)*bp);\n        return;\n    }\n    if (jl_is_symbol(v)) {\n        void *idx = ptrhash_get(&common_symbol_tag, v);\n        if (idx != HT_NOTFOUND) {\n            writetag(s, (jl_value_t*)CommonSym_tag);\n            write_uint8(s, (uint8_t)(size_t)idx);\n            return;\n        }\n    }\n\n    if (mode == MODE_AST) {\n        // compressing tree\n        if (!is_ast_node(v)) {\n            writetag(s, (jl_value_t*)LiteralVal_tag);\n            write_uint16(s, literal_val_id(v));\n            return;\n        }\n    }\n    else {\n        bp = ptrhash_bp(&backref_table, v);\n        if (*bp != HT_NOTFOUND) {\n            uintptr_t pos = (char*)*bp - (char*)HT_NOTFOUND - 1;\n            if (pos < 65536) {\n                write_uint8(s, ShortBackRef_tag);\n                write_uint16(s, pos);\n            }\n            else {\n                write_uint8(s, BackRef_tag);\n                write_int32(s, pos);\n            }\n            return;\n        }\n        ptrint_t pos = backref_table_numel++;\n        if (jl_typeof(v) == jl_idtable_type) {\n            // will need to rehash this, later (after types are fully constructed)\n            arraylist_push(&reinit_list, (void*)pos);\n            arraylist_push(&reinit_list, (void*)1);\n        }\n        if (mode == MODE_MODULE && jl_is_module(v)) {\n            jl_module_t *m = (jl_module_t*)v;\n            if (module_in_worklist(m) && !module_in_worklist(m->parent)) {\n                // will need to reinsert this into parent bindings, later (in case of any errors during reinsert)\n                arraylist_push(&reinit_list, (void*)pos);\n                arraylist_push(&reinit_list, (void*)2);\n            }\n        }\n        if (mode == MODE_MODULE || mode == MODE_MODULE_POSTWORK)\n            pos <<= 1;\n        ptrhash_put(&backref_table, v, (char*)HT_NOTFOUND + pos + 1);\n    }\n\n    size_t i;\n    if (jl_is_svec(v)) {\n        size_t l = jl_svec_len(v);\n        if (l <= 255) {\n            writetag(s, jl_simplevector_type);\n            write_uint8(s, (uint8_t)l);\n        }\n        else {\n            writetag(s, (jl_value_t*)LongSvec_tag);\n            write_int32(s, l);\n        }\n        for(i=0; i < l; i++) {\n            jl_serialize_value(s, jl_svecref(v, i));\n        }\n    }\n    else if (jl_is_symbol(v)) {\n        size_t l = strlen(((jl_sym_t*)v)->name);\n        if (l <= 255) {\n            writetag(s, jl_symbol_type);\n            write_uint8(s, (uint8_t)l);\n        }\n        else {\n            writetag(s, (jl_value_t*)LongSymbol_tag);\n            write_int32(s, l);\n        }\n        ios_write(s, ((jl_sym_t*)v)->name, l);\n    }\n    else if (jl_is_globalref(v)) {\n        if (mode == MODE_AST && jl_globalref_mod(v) == tree_enclosing_module) {\n            writetag(s, (jl_value_t*)NearbyGlobal_tag);\n            jl_serialize_value(s, jl_globalref_name(v));\n        }\n        else {\n            writetag(s, (jl_value_t*)jl_globalref_type);\n            jl_serialize_value(s, jl_globalref_mod(v));\n            jl_serialize_value(s, jl_globalref_name(v));\n        }\n    }\n    else if (jl_is_array(v)) {\n        jl_array_t *ar = (jl_array_t*)v;\n        if (ar->ndims == 1 && ar->elsize < 128) {\n            writetag(s, (jl_value_t*)Array1d_tag);\n            write_uint8(s, (ar->ptrarray<<7) | (ar->elsize & 0x7f));\n        }\n        else {\n            writetag(s, (jl_value_t*)jl_array_type);\n            write_uint16(s, ar->ndims);\n            write_uint16(s, (ar->ptrarray<<15) | (ar->elsize & 0x7fff));\n        }\n        for (i=0; i < ar->ndims; i++)\n            jl_serialize_value(s, jl_box_long(jl_array_dim(ar,i)));\n        jl_serialize_value(s, jl_typeof(ar));\n        if (!ar->ptrarray) {\n            size_t tot = jl_array_len(ar) * ar->elsize;\n            ios_write(s, (char*)jl_array_data(ar), tot);\n        }\n        else {\n            for(i=0; i < jl_array_len(ar); i++) {\n                jl_serialize_value(s, jl_cellref(v, i));\n            }\n        }\n    }\n    else if (jl_is_expr(v)) {\n        jl_expr_t *e = (jl_expr_t*)v;\n        size_t l = jl_array_len(e->args);\n        if (l <= 255) {\n            writetag(s, jl_expr_type);\n            write_uint8(s, (uint8_t)l);\n        }\n        else {\n            writetag(s, (jl_value_t*)LongExpr_tag);\n            write_int32(s, l);\n        }\n        jl_serialize_value(s, e->head);\n        jl_serialize_value(s, e->etype);\n        for(i=0; i < l; i++) {\n            jl_serialize_value(s, jl_exprarg(e, i));\n        }\n    }\n    else if (jl_is_datatype(v)) {\n        jl_serialize_datatype(s, (jl_datatype_t*)v);\n    }\n    else if (jl_is_typevar(v)) {\n        writetag(s, jl_tvar_type);\n        jl_serialize_value(s, ((jl_tvar_t*)v)->name);\n        jl_serialize_value(s, ((jl_tvar_t*)v)->lb);\n        jl_serialize_value(s, ((jl_tvar_t*)v)->ub);\n        write_int8(s, ((jl_tvar_t*)v)->bound);\n    }\n    else if (jl_is_function(v)) {\n        writetag(s, jl_function_type);\n        if (mode == MODE_MODULE || mode == MODE_MODULE_POSTWORK) {\n            if (jl_is_gf(v)) {\n                jl_methtable_t *mt = jl_gf_mtable(v);\n                if (mt->module && !module_in_worklist(mt->module)) {\n                    write_int8(s, 1);\n                    jl_serialize_value(s, (jl_value_t*)mt->module);\n                    jl_serialize_value(s, (jl_value_t*)mt->name);\n                    return;\n                }\n            }\n            write_int8(s, 0);\n        }\n        jl_function_t *f = (jl_function_t*)v;\n        jl_serialize_value(s, (jl_value_t*)f->linfo);\n        jl_serialize_value(s, f->env);\n        if (f->linfo && f->linfo->ast && f->fptr != &jl_trampoline) {\n            jl_serialize_fptr(s, (void*)&jl_trampoline);\n        }\n        else {\n            jl_serialize_fptr(s, (void*)f->fptr);\n        }\n    }\n    else if (jl_is_lambda_info(v)) {\n        writetag(s, jl_lambda_info_type);\n        jl_lambda_info_t *li = (jl_lambda_info_t*)v;\n        jl_serialize_value(s, li->ast);\n        jl_serialize_value(s, (jl_value_t*)li->sparams);\n        // don't save cached type info for code in the Core module, because\n        // it might reference types in the old Base module.\n        if (li->module == jl_core_module) {\n            jl_serialize_value(s, jl_nothing);\n        }\n        else {\n            jl_array_t *tf = (jl_array_t*)li->tfunc;\n            // go through the t-func cache, replacing ASTs with just return\n            // types for abstract argument types. these ASTs are generally\n            // not needed (e.g. they don't get inlined).\n            if (tf && jl_typeis(tf, jl_array_any_type)) {\n                size_t i, l = jl_array_len(tf);\n                for(i=0; i < l; i += 3) {\n                    if (!jl_is_leaf_type(jl_cellref(tf,i))) {\n                        jl_value_t *ast = jl_cellref(tf,i+1);\n                        if (ast && jl_is_array(ast) && jl_array_len(ast) > 500)\n                            jl_cellset(tf, i+1, jl_ast_rettype(li, (jl_value_t*)ast));\n                    }\n                }\n            }\n            jl_serialize_value(s, (jl_value_t*)li->tfunc);\n        }\n        jl_serialize_value(s, (jl_value_t*)li->name);\n        jl_serialize_value(s, (jl_value_t*)li->specTypes);\n        jl_serialize_value(s, (jl_value_t*)li->specializations);\n        write_int8(s, li->inferred);\n        jl_serialize_value(s, (jl_value_t*)li->file);\n        write_int32(s, li->line);\n        jl_serialize_value(s, (jl_value_t*)li->module);\n        jl_serialize_value(s, (jl_value_t*)li->roots);\n        jl_serialize_value(s, (jl_value_t*)li->def);\n        jl_serialize_value(s, (jl_value_t*)li->capt);\n        jl_serialize_value(s, (jl_value_t*)li->unspecialized);\n        // save functionObject pointers\n        write_int32(s, li->functionID);\n        write_int32(s, li->specFunctionID);\n    }\n    else if (jl_typeis(v, jl_module_type)) {\n        jl_serialize_module(s, (jl_module_t*)v);\n    }\n    else if (jl_typeis(v, jl_task_type)) {\n        jl_error(\"Task cannot be serialized\");\n    }\n    else {\n        jl_datatype_t *t = (jl_datatype_t*)jl_typeof(v);\n        void *data = jl_data_ptr(v);\n        if (t == jl_int64_type &&\n            *(int64_t*)data >= S32_MIN && *(int64_t*)data <= S32_MAX) {\n            writetag(s, (jl_value_t*)SmallInt64_tag);\n            write_int32(s, (int32_t)*(int64_t*)data);\n        }\n        else if (t == jl_int32_type) {\n            writetag(s, (jl_value_t*)Int32_tag);\n            write_int32(s, (int32_t)*(int32_t*)data);\n        }\n        else {\n            if (v == t->instance) {\n                if (mode == MODE_MODULE) {\n                    // also flag this in the backref table as special\n                    uptrint_t *bp = (uptrint_t*)ptrhash_bp(&backref_table, v);\n                    assert(*bp != (uptrint_t)HT_NOTFOUND);\n                    *bp |= 1; assert(((uptrint_t)HT_NOTFOUND)|1);\n                }\n                writetag(s, (jl_value_t*)Singleton_tag);\n                jl_serialize_value(s, t);\n                return;\n            }\n            if (t->size <= 255) {\n                writetag(s, (jl_value_t*)SmallDataType_tag);\n                write_uint8(s, t->size);\n            }\n            else {\n                writetag(s, (jl_value_t*)jl_datatype_type);\n                write_int32(s, t->size);\n            }\n            jl_serialize_value(s, t);\n            if ((mode == MODE_MODULE || mode == MODE_MODULE_POSTWORK) && t == jl_typename_type) {\n                if (module_in_worklist(((jl_typename_t*)v)->module)) {\n                    write_uint8(s, 0);\n                }\n                else {\n                    write_uint8(s, 1);\n                    jl_typename_t *tn = (jl_typename_t*)v;\n                    jl_serialize_value(s, tn->module);\n                    jl_serialize_value(s, tn->name);\n                    return;\n                }\n            }\n            size_t nf = jl_datatype_nfields(t);\n            if (nf == 0 && jl_datatype_size(t)>0) {\n                if (t->name == jl_pointer_type->name) {\n                    write_int32(s, 0);\n#ifdef _P64\n                    write_int32(s, 0);\n#endif\n                }\n                else {\n                    ios_write(s, (char*)data, jl_datatype_size(t));\n                }\n            }\n            else {\n                for(size_t i=0; i < nf; i++) {\n                    if (jl_field_size(t, i) > 0) {\n                        jl_serialize_value(s, jl_get_nth_field(v, i));\n                    }\n                }\n            }\n        }\n    }\n}\n\nstatic void jl_serialize_methtable_from_mod(ios_t *s, jl_methtable_t *mt, int8_t iskw)\n{\n    if (iskw) {\n        if (!mt->kwsorter)\n            return;\n        assert(jl_is_gf(mt->kwsorter));\n        assert(mt->module == jl_gf_mtable(mt->kwsorter)->module);\n        mt = jl_gf_mtable(mt->kwsorter);\n        assert(!mt->kwsorter);\n    }\n    assert(mt->module);\n    jl_methlist_t *ml = mt->defs;\n    while (ml != (void*)jl_nothing) {\n        if (module_in_worklist(ml->func->linfo->module)) {\n            jl_serialize_value(s, mt->module);\n            jl_serialize_value(s, mt->name);\n            write_int8(s, iskw);\n            jl_serialize_value(s, ml->sig);\n            jl_serialize_value(s, ml->func);\n            if (jl_is_svec(ml->tvars))\n                jl_serialize_value(s, ml->tvars);\n            else\n                jl_serialize_value(s, jl_svec1(ml->tvars));\n            write_int8(s, ml->isstaged);\n        }\n        ml = ml->next;\n    }\n}\n\nstatic void jl_serialize_lambdas_from_mod(ios_t *s, jl_module_t *m)\n{\n    if (module_in_worklist(m)) return;\n    size_t i;\n    void **table = m->bindings.table;\n    for(i=1; i < m->bindings.size; i+=2) {\n        if (table[i] != HT_NOTFOUND) {\n            jl_binding_t *b = (jl_binding_t*)table[i];\n            if (b->owner == m && b->value && b->constp) {\n                if (jl_is_function(b->value) && jl_is_gf(b->value)) {\n                    jl_function_t *gf = (jl_function_t*)b->value;\n                    jl_methtable_t *mt = jl_gf_mtable(gf);\n                    if (mt->name == b->name && mt->module == m) {\n                        jl_serialize_methtable_from_mod(s, mt, 0);\n                        jl_serialize_methtable_from_mod(s, mt, 1);\n                    }\n                }\n                else if (jl_is_module(b->value)) {\n                    jl_module_t *child = (jl_module_t*)b->value;\n                    if (child != m && child->parent == m && child->name == b->name) {\n                        // this is the original/primary binding for the submodule\n                        jl_serialize_lambdas_from_mod(s, (jl_module_t*)b->value);\n                    }\n                }\n            }\n        }\n    }\n}\n\n// serialize information about all of the modules accessible directly from Main\nvoid jl_serialize_mod_list(ios_t *s)\n{\n    jl_module_t *m = jl_main_module;\n    size_t i;\n    void **table = m->bindings.table;\n    for(i=1; i < m->bindings.size; i+=2) {\n        if (table[i] != HT_NOTFOUND) {\n            jl_binding_t *b = (jl_binding_t*)table[i];\n            if (b->owner == m &&\n                    b->value && b->constp &&\n                    jl_is_module(b->value) &&\n                    !module_in_worklist((jl_module_t*)b->value)) {\n                jl_module_t *child = (jl_module_t*)b->value;\n                if (child->name == b->name) {\n                    // this is the original/primary binding for the submodule\n                    size_t l = strlen(child->name->name);\n                    write_int32(s, l);\n                    ios_write(s, child->name->name, l);\n                    write_uint64(s, child->uuid);\n                }\n            }\n        }\n    }\n    write_int32(s, 0);\n}\n\n// \"magic\" string and version header of .ji file\nstatic const int JI_FORMAT_VERSION = 2;\nstatic const char JI_MAGIC[] = \"\\373jli\\r\\n\\032\\n\"; // based on PNG signature\nstatic const uint16_t BOM = 0xFEFF; // byte-order marker\nstatic void jl_serialize_header(ios_t *s)\n{\n    ios_write(s, JI_MAGIC, strlen(JI_MAGIC));\n    write_uint16(s, JI_FORMAT_VERSION);\n    ios_write(s, (char *) &BOM, 2);\n    write_uint8(s, sizeof(void*));\n    const char *OS_NAME = jl_get_OS_NAME()->name, *ARCH = jl_get_ARCH()->name;\n    ios_write(s, OS_NAME, strlen(OS_NAME)+1);\n    ios_write(s, ARCH, strlen(ARCH)+1);\n    ios_write(s, JULIA_VERSION_STRING, strlen(JULIA_VERSION_STRING)+1);\n    const char *branch = jl_git_branch(), *commit = jl_git_commit();\n    ios_write(s, branch, strlen(branch)+1);\n    ios_write(s, commit, strlen(commit)+1);\n}\n\n// serialize the global _require_dependencies array of pathnames that\n// are include depenencies\nvoid jl_serialize_dependency_list(ios_t *s)\n{\n    size_t total_size = 0;\n    static jl_array_t *deps = NULL;\n    if (!deps)\n        deps = (jl_array_t*)jl_get_global(jl_base_module, jl_symbol(\"_require_dependencies\"));\n\n    // unique(deps) to eliminate duplicates while preserving order:\n    // we preserve order so that the topmost included .jl file comes first\n    static jl_value_t *unique_func = NULL;\n    if (!unique_func)\n        unique_func = jl_get_global(jl_base_module, jl_symbol(\"unique\"));\n    jl_array_t *udeps = deps && unique_func ? (jl_array_t *) jl_apply((jl_function_t*)unique_func, (jl_value_t**)&deps, 1) : NULL;\n\n    JL_GC_PUSH1(&udeps);\n    if (udeps) {\n        size_t l = jl_array_len(udeps);\n        for (size_t i=0; i < l; i++) {\n            jl_value_t *dep = jl_fieldref(jl_cellref(udeps, i), 0);\n            size_t slen = jl_string_len(dep);\n            total_size += 4 + slen + 8;\n        }\n        total_size += 4;\n    }\n    // write the total size so that we can quickly seek past all of the\n    // dependencies if we don't need them\n    write_uint64(s, total_size);\n    if (udeps) {\n        size_t l = jl_array_len(udeps);\n        for (size_t i=0; i < l; i++) {\n            jl_value_t *deptuple = jl_cellref(udeps, i);\n            jl_value_t *dep = jl_fieldref(deptuple, 0);\n            size_t slen = jl_string_len(dep);\n            write_int32(s, slen);\n            ios_write(s, jl_string_data(dep), slen);\n            write_float64(s, jl_unbox_float64(jl_fieldref(deptuple, 1)));\n        }\n        write_int32(s, 0); // terminator, for ease of reading\n    }\n    JL_GC_POP();\n}\n\n// --- deserialize ---\n\nstatic jl_fptr_t jl_deserialize_fptr(ios_t *s)\n{\n    int fptr = read_uint16(s);\n    if (fptr < 2)\n        return NULL;\n\n    if (fptr >= sizeof(id_to_fptrs)/sizeof(*id_to_fptrs))\n        jl_error(\"unknown function pointer ID\");\n    return id_to_fptrs[fptr];\n}\n\nstatic jl_value_t *jl_deserialize_datatype(ios_t *s, int pos, jl_value_t **loc)\n{\n    int tag = read_uint8(s);\n    if (tag == 6 || tag == 7) {\n        jl_typename_t *name = (jl_typename_t*)jl_deserialize_value(s, NULL);\n        jl_value_t *dtv = name->primary;\n        if (tag == 7) {\n            jl_svec_t *parameters = (jl_svec_t*)jl_deserialize_value(s, NULL);\n            dtv = jl_apply_type(dtv, parameters);\n        }\n        backref_list.items[pos] = dtv;\n        return dtv;\n    }\n    uint16_t nf = read_uint16(s);\n    size_t size = read_int32(s);\n    uint8_t flags = read_uint8(s);\n    uint8_t fielddesc_type = read_int8(s);\n    jl_datatype_t *dt;\n    if (tag == 2)\n        dt = jl_int32_type;\n    else if (tag == 3)\n        dt = jl_bool_type;\n    else if (tag == 4)\n        dt = jl_int64_type;\n    else\n        dt = jl_new_uninitialized_datatype(nf, fielddesc_type);\n    assert(tree_literal_values==NULL && mode != MODE_AST);\n    backref_list.items[pos] = dt;\n    dt->size = size;\n    dt->struct_decl = NULL;\n    dt->instance = NULL;\n    dt->ditype = NULL;\n    dt->abstract = flags&1;\n    dt->mutabl = (flags>>1)&1;\n    dt->pointerfree = (flags>>2)&1;\n    if (!dt->abstract) {\n        dt->ninitialized = read_uint16(s);\n        dt->uid = mode != MODE_MODULE && mode != MODE_MODULE_POSTWORK ? read_int32(s) : 0;\n    }\n    else {\n        dt->ninitialized = 0;\n        dt->uid = 0;\n    }\n    int has_instance = (flags>>3)&1;\n    if (has_instance) {\n        assert(mode != MODE_MODULE_POSTWORK); // there shouldn't be an instance on a type with uid = 0\n        dt->instance = jl_deserialize_value(s, &dt->instance);\n        jl_gc_wb(dt, dt->instance);\n    }\n    if (tag == 5) {\n        assert(pos > 0);\n        assert(mode != MODE_MODULE_POSTWORK);\n        arraylist_push(&flagref_list, loc);\n        arraylist_push(&flagref_list, (void*)(uptrint_t)pos);\n        dt->uid = -1; // mark that this type needs a new uid\n    }\n\n    if (nf > 0) {\n        dt->alignment = read_int32(s);\n        dt->haspadding = read_int8(s);\n        size_t fieldsize = jl_fielddesc_size(fielddesc_type);\n        ios_read(s, (char*)dt->fields, nf * fieldsize);\n        dt->types = (jl_svec_t*)jl_deserialize_value(s, (jl_value_t**)&dt->types);\n        jl_gc_wb(dt, dt->types);\n    }\n    else {\n        dt->alignment = dt->size;\n        dt->haspadding = 0;\n        if (dt->alignment > MAX_ALIGN)\n            dt->alignment = MAX_ALIGN;\n        dt->types = jl_emptysvec;\n    }\n    dt->parameters = (jl_svec_t*)jl_deserialize_value(s, (jl_value_t**)&dt->parameters);\n    jl_gc_wb(dt, dt->parameters);\n    dt->name = (jl_typename_t*)jl_deserialize_value(s, (jl_value_t**)&dt->name);\n    jl_gc_wb(dt, dt->name);\n    dt->super = (jl_datatype_t*)jl_deserialize_value(s, (jl_value_t**)&dt->super);\n    jl_gc_wb(dt, dt->super);\n    if (datatype_list) {\n        if (dt->name == jl_array_type->name || dt->name == jl_ref_type->name ||\n            dt->name == jl_pointer_type->name || dt->name == jl_type_type->name ||\n            dt->name == jl_simplevector_type->name || dt->name == jl_abstractarray_type->name ||\n            dt->name == jl_densearray_type->name || dt->name == jl_tuple_typename ||\n            dt->name == jl_vararg_type->name) {\n            // builtin types are not serialized, so their caches aren't\n            // explicitly saved. so we reconstruct the caches of builtin\n            // parametric types here.\n            jl_cell_1d_push(datatype_list, (jl_value_t*)dt);\n        }\n    }\n    return (jl_value_t*)dt;\n}\n\njl_array_t *jl_eqtable_put(jl_array_t *h, void *key, void *val);\n\nstatic jl_value_t *jl_deserialize_value_(ios_t *s, jl_value_t *vtag, jl_value_t **loc);\nstatic jl_value_t *jl_deserialize_value(ios_t *s, jl_value_t **loc)\n{\n    assert(!ios_eof(s));\n    uint8_t tag = read_uint8(s);\n    if (tag == Null_tag)\n        return NULL;\n    if (tag == 0) {\n        tag = read_uint8(s);\n        jl_value_t *v = deser_tag[tag];\n        assert(v != NULL);\n        return v;\n    }\n    if (tag == BackRef_tag || tag == ShortBackRef_tag) {\n        assert(tree_literal_values == NULL && mode != MODE_AST);\n        uptrint_t offs = (tag == BackRef_tag) ? read_int32(s) : read_uint16(s);\n        int isdatatype = 0;\n        if (mode == MODE_MODULE) {\n            isdatatype = !!(offs & 1);\n            offs >>= 1;\n        }\n        else if (mode == MODE_MODULE_POSTWORK) {\n            offs >>= 1;\n        }\n        assert(offs >= 0 && offs < backref_list.len);\n        jl_value_t *bp = (jl_value_t*)backref_list.items[offs];\n        assert(bp);\n        if (isdatatype && loc != NULL) {\n            arraylist_push(&flagref_list, loc);\n            arraylist_push(&flagref_list, (void*)(uptrint_t)-1);\n        }\n        return (jl_value_t*)bp;\n    }\n\n    jl_value_t *vtag = deser_tag[tag];\n    if (tag >= VALUE_TAGS) {\n        return vtag;\n    }\n    else if (vtag == (jl_value_t*)LiteralVal_tag) {\n        return jl_cellref(tree_literal_values, read_uint16(s));\n    }\n    jl_value_t *v = jl_deserialize_value_(s, vtag, loc);\n    return v;\n}\n\nstatic jl_value_t *jl_deserialize_value_(ios_t *s, jl_value_t *vtag, jl_value_t **loc)\n{\n    int usetable = (mode != MODE_AST);\n\n    size_t i;\n    if (vtag == (jl_value_t*)jl_simplevector_type ||\n        vtag == (jl_value_t*)LongSvec_tag) {\n        size_t len;\n        if (vtag == (jl_value_t*)jl_simplevector_type)\n            len = read_uint8(s);\n        else\n            len = read_int32(s);\n        jl_svec_t *sv = jl_alloc_svec_uninit(len);\n        if (usetable)\n            arraylist_push(&backref_list, (jl_value_t*)sv);\n        jl_value_t **data = sv->data;\n        for(i=0; i < len; i++) {\n            data[i] = jl_deserialize_value(s, &data[i]);\n        }\n        return (jl_value_t*)sv;\n    }\n    else if (vtag == (jl_value_t*)CommonSym_tag) {\n        int tag = read_uint8(s);\n        return deser_symbols[tag];\n    }\n    else if (vtag == (jl_value_t*)jl_symbol_type ||\n             vtag == (jl_value_t*)LongSymbol_tag) {\n        size_t len;\n        if (vtag == (jl_value_t*)jl_symbol_type)\n            len = read_uint8(s);\n        else\n            len = read_int32(s);\n        char *name = (char*) (len >= 256 ? malloc(len+1) : alloca(len+1));\n        ios_read(s, name, len);\n        name[len] = '\\0';\n        jl_value_t *sym = (jl_value_t*)jl_symbol(name);\n        if (len >= 256) free(name);\n        if (usetable)\n            arraylist_push(&backref_list, sym);\n        return sym;\n    }\n    else if (vtag == (jl_value_t*)jl_array_type ||\n             vtag == (jl_value_t*)Array1d_tag) {\n        int16_t ndims;\n        int isunboxed, elsize;\n        if (vtag == (jl_value_t*)Array1d_tag) {\n            ndims = 1;\n            elsize = read_uint8(s);\n            isunboxed = !(elsize>>7);\n            elsize = elsize&0x7f;\n        }\n        else {\n            ndims = read_uint16(s);\n            elsize = read_uint16(s);\n            isunboxed = !(elsize>>15);\n            elsize = elsize&0x7fff;\n        }\n        int pos = backref_list.len;\n        if (usetable)\n            arraylist_push(&backref_list, NULL);\n        size_t *dims = (size_t*)alloca(ndims*sizeof(size_t));\n        for(i=0; i < ndims; i++)\n            dims[i] = jl_unbox_long(jl_deserialize_value(s, NULL));\n        jl_array_t *a = jl_new_array_for_deserialization((jl_value_t*)NULL, ndims, dims, isunboxed, elsize);\n        if (usetable)\n            backref_list.items[pos] = a;\n        jl_value_t *aty = jl_deserialize_value(s, &jl_astaggedvalue(a)->type);\n        jl_set_typeof(a, aty);\n        if (!a->ptrarray) {\n            size_t tot = jl_array_len(a) * a->elsize;\n            ios_read(s, (char*)jl_array_data(a), tot);\n        }\n        else {\n            jl_value_t** data = (jl_value_t**)jl_array_data(a);\n            for(i=0; i < jl_array_len(a); i++) {\n                data[i] = jl_deserialize_value(s, &data[i]);\n                if (data[i]) jl_gc_wb(a, data[i]);\n            }\n        }\n        return (jl_value_t*)a;\n    }\n    else if (vtag == (jl_value_t*)jl_expr_type ||\n             vtag == (jl_value_t*)LongExpr_tag) {\n        size_t len;\n        if (vtag == (jl_value_t*)jl_expr_type)\n            len = read_uint8(s);\n        else\n            len = read_int32(s);\n        int pos = backref_list.len;\n        if (usetable)\n            arraylist_push(&backref_list, NULL);\n        jl_expr_t *e = jl_exprn((jl_sym_t*)jl_deserialize_value(s, NULL), len);\n        if (usetable)\n            backref_list.items[pos] = e;\n        e->etype = jl_deserialize_value(s, &e->etype);\n        jl_gc_wb(e, e->etype);\n        jl_value_t **data = (jl_value_t**)(e->args->data);\n        for(i=0; i < len; i++) {\n            data[i] = jl_deserialize_value(s, &data[i]);\n        }\n        return (jl_value_t*)e;\n    }\n    else if (vtag == (jl_value_t*)jl_tvar_type) {\n        jl_tvar_t *tv = (jl_tvar_t*)newobj((jl_value_t*)jl_tvar_type, NWORDS(sizeof(jl_tvar_t)));\n        if (usetable)\n            arraylist_push(&backref_list, tv);\n        tv->name = (jl_sym_t*)jl_deserialize_value(s, NULL);\n        jl_gc_wb(tv, tv->name);\n        tv->lb = jl_deserialize_value(s, &tv->lb);\n        jl_gc_wb(tv, tv->lb);\n        tv->ub = jl_deserialize_value(s, &tv->ub);\n        jl_gc_wb(tv, tv->ub);\n        tv->bound = read_int8(s);\n        return (jl_value_t*)tv;\n    }\n    else if (vtag == (jl_value_t*)jl_function_type) {\n        if (mode == MODE_MODULE || mode == MODE_MODULE_POSTWORK) {\n            int ref_only = read_int8(s);\n            if (ref_only) {\n                int pos = backref_list.len;\n                arraylist_push(&backref_list, NULL);\n                jl_module_t *module = (jl_module_t*)jl_deserialize_value(s, NULL);\n                jl_sym_t *name = (jl_sym_t*)jl_deserialize_value(s, NULL);\n                jl_value_t *f = jl_get_global(module, name);\n                backref_list.items[pos] = f;\n                return f;\n            }\n        }\n        jl_function_t *f =\n            (jl_function_t*)newobj((jl_value_t*)jl_function_type, NWORDS(sizeof(jl_function_t)));\n        if (usetable)\n            arraylist_push(&backref_list, f);\n        f->linfo = (jl_lambda_info_t*)jl_deserialize_value(s, (jl_value_t**)&f->linfo);\n        if (f->linfo != NULL) jl_gc_wb(f, f->linfo);\n        f->env = jl_deserialize_value(s, &f->env);\n        jl_gc_wb(f, f->env);\n        f->fptr = jl_deserialize_fptr(s);\n        return (jl_value_t*)f;\n    }\n    else if (vtag == (jl_value_t*)jl_lambda_info_type) {\n        jl_lambda_info_t *li =\n            (jl_lambda_info_t*)newobj((jl_value_t*)jl_lambda_info_type,\n                                      NWORDS(sizeof(jl_lambda_info_t)));\n        if (usetable)\n            arraylist_push(&backref_list, li);\n        li->ast = jl_deserialize_value(s, &li->ast);\n        jl_gc_wb(li, li->ast);\n        li->sparams = (jl_svec_t*)jl_deserialize_value(s, (jl_value_t**)&li->sparams);\n        jl_gc_wb(li, li->sparams);\n        li->tfunc = jl_deserialize_value(s, (jl_value_t**)&li->tfunc);\n        jl_gc_wb(li, li->tfunc);\n        li->name = (jl_sym_t*)jl_deserialize_value(s, NULL);\n        jl_gc_wb(li, li->name);\n        li->specTypes = (jl_tupletype_t*)jl_deserialize_value(s, (jl_value_t**)&li->specTypes);\n        if (li->specTypes) jl_gc_wb(li, li->specTypes);\n        li->specializations = (jl_array_t*)jl_deserialize_value(s, (jl_value_t**)&li->specializations);\n        if (li->specializations) jl_gc_wb(li, li->specializations);\n        li->inferred = read_int8(s);\n        li->file = (jl_sym_t*)jl_deserialize_value(s, NULL);\n        jl_gc_wb(li, li->file);\n        li->line = read_int32(s);\n        li->module = (jl_module_t*)jl_deserialize_value(s, (jl_value_t**)&li->module);\n        jl_gc_wb(li, li->module);\n        li->roots = (jl_array_t*)jl_deserialize_value(s, (jl_value_t**)&li->roots);\n        if (li->roots) jl_gc_wb(li, li->roots);\n        li->def = (jl_lambda_info_t*)jl_deserialize_value(s, (jl_value_t**)&li->def);\n        jl_gc_wb(li, li->def);\n        li->capt = jl_deserialize_value(s, &li->capt);\n        if (li->capt) jl_gc_wb(li, li->capt);\n        li->fptr = &jl_trampoline;\n        li->functionObject = NULL;\n        li->cFunctionList = NULL;\n        li->specFunctionObject = NULL;\n        li->inInference = 0;\n        li->inCompile = 0;\n        li->unspecialized = (jl_function_t*)jl_deserialize_value(s, (jl_value_t**)&li->unspecialized);\n        if (li->unspecialized) jl_gc_wb(li, li->unspecialized);\n        li->functionID = 0;\n        li->specFunctionID = 0;\n        int32_t cfunc_llvm, func_llvm;\n        func_llvm = read_int32(s);\n        cfunc_llvm = read_int32(s);\n        jl_delayed_fptrs(li, func_llvm, cfunc_llvm);\n        return (jl_value_t*)li;\n    }\n    else if (vtag == (jl_value_t*)jl_module_type) {\n        int pos = backref_list.len;\n        if (usetable)\n            arraylist_push(&backref_list, NULL);\n        jl_sym_t *mname = (jl_sym_t*)jl_deserialize_value(s, NULL);\n        int ref_only = 0;\n        if (mode == MODE_MODULE_POSTWORK) {\n            ref_only = 1;\n        }\n        else if (mode == MODE_MODULE) {\n            ref_only = read_uint8(s);\n        }\n        if (ref_only) {\n            jl_value_t *m_ref = jl_get_global((jl_module_t*)jl_deserialize_value(s, NULL), mname);\n            if (usetable)\n                backref_list.items[pos] = m_ref;\n            return m_ref;\n        }\n        jl_module_t *m = jl_new_module(mname);\n        if (usetable)\n            backref_list.items[pos] = m;\n        m->parent = (jl_module_t*)jl_deserialize_value(s, (jl_value_t**)&m->parent);\n        jl_gc_wb(m, m->parent);\n\n        while (1) {\n            jl_sym_t *name = (jl_sym_t*)jl_deserialize_value(s, NULL);\n            if (name == NULL)\n                break;\n            jl_binding_t *b = jl_get_binding_wr(m, name);\n            b->value = jl_deserialize_value(s, &b->value);\n            jl_gc_wb_buf(m, b);\n            if (b->value != NULL) jl_gc_wb(m, b->value);\n            b->globalref = jl_deserialize_value(s, &b->globalref);\n            if (b->globalref != NULL) jl_gc_wb(m, b->globalref);\n            b->owner = (jl_module_t*)jl_deserialize_value(s, (jl_value_t**)&b->owner);\n            if (b->owner != NULL) jl_gc_wb(m, b->owner);\n            int8_t flags = read_int8(s);\n            b->deprecated = (flags>>3) & 1;\n            b->constp = (flags>>2) & 1;\n            b->exportp = (flags>>1) & 1;\n            b->imported = (flags) & 1;\n            jl_deserialize_gv(s, (jl_value_t*)b);\n        }\n        size_t i = m->usings.len;\n        size_t ni = read_int32(s);\n        arraylist_grow(&m->usings, ni);\n        ni += i;\n        while (i < ni) {\n            m->usings.items[i] = jl_deserialize_value(s, (jl_value_t**)&m->usings.items[i]);\n            i++;\n        }\n        m->constant_table = (jl_array_t*)jl_deserialize_value(s, (jl_value_t**)&m->constant_table);\n        if (m->constant_table != NULL) jl_gc_wb(m, m->constant_table);\n        m->istopmod = read_uint8(s);\n        m->std_imports = read_uint8(s);\n        m->uuid = read_uint64(s);\n        return (jl_value_t*)m;\n    }\n    else if (vtag == (jl_value_t*)SmallInt64_tag) {\n        jl_value_t *v = jl_box_int64(read_int32(s));\n        if (usetable)\n            arraylist_push(&backref_list, v);\n        return v;\n    }\n    else if (vtag == (jl_value_t*)Int32_tag) {\n        jl_value_t *v = jl_box_int32(read_int32(s));\n        if (usetable)\n            arraylist_push(&backref_list, v);\n        return v;\n    }\n    else if (vtag == (jl_value_t*)NearbyGlobal_tag) {\n        assert(tree_enclosing_module != NULL);\n        jl_value_t *sym = jl_deserialize_value(s, NULL);\n        return jl_module_globalref(tree_enclosing_module, (jl_sym_t*)sym);\n    }\n    else if (vtag == (jl_value_t*)jl_globalref_type) {\n        if (usetable) {\n            jl_value_t *v = jl_new_struct_uninit(jl_globalref_type);\n            arraylist_push(&backref_list, v);\n            jl_value_t* *data = jl_data_ptr(v);\n            data[0] = jl_deserialize_value(s, &data[0]);\n            data[1] = jl_deserialize_value(s, &data[1]);\n            return v;\n        }\n        else {\n            jl_value_t *mod = jl_deserialize_value(s, NULL);\n            jl_value_t *var = jl_deserialize_value(s, NULL);\n            return jl_module_globalref((jl_module_t*)mod, (jl_sym_t*)var);\n        }\n    }\n    else if (vtag == (jl_value_t*)jl_datatype_type || vtag == (jl_value_t*)SmallDataType_tag) {\n        int32_t sz = (vtag == (jl_value_t*)SmallDataType_tag ? read_uint8(s) : read_int32(s));\n        jl_value_t *v = jl_gc_allocobj(sz);\n        int pos = backref_list.len;\n        if (usetable)\n            arraylist_push(&backref_list, v);\n        jl_datatype_t *dt = (jl_datatype_t*)jl_deserialize_value(s, &jl_astaggedvalue(v)->type);\n        jl_set_typeof(v, dt);\n        if (dt == jl_datatype_type)\n            return jl_deserialize_datatype(s, pos, loc);\n        assert(mode==MODE_AST || sz!=0 || loc);\n        if ((mode == MODE_MODULE || mode == MODE_MODULE_POSTWORK) && dt == jl_typename_type) {\n            int ref_only = read_uint8(s);\n            if (ref_only) {\n                jl_module_t *m = (jl_module_t*)jl_deserialize_value(s, NULL);\n                jl_sym_t *sym = (jl_sym_t*)jl_deserialize_value(s, NULL);\n                jl_datatype_t *dt = (jl_datatype_t*)jl_get_global(m, sym);\n                assert(jl_is_datatype(dt));\n                jl_value_t *v = (jl_value_t*)dt->name;\n                if (usetable)\n                    backref_list.items[pos] = v;\n                return v;\n            }\n            assert(mode != MODE_MODULE_POSTWORK);\n        }\n        size_t nf = jl_datatype_nfields(dt);\n        if (nf == 0 && jl_datatype_size(dt)>0) {\n            int nby = jl_datatype_size(dt);\n            ios_read(s, (char*)jl_data_ptr(v), nby);\n        }\n        else {\n            char *data = (char*)jl_data_ptr(v);\n            for(i=0; i < nf; i++) {\n                if (jl_field_size(dt,i) > 0) {\n                    if (jl_field_isptr(dt,i)) {\n                        jl_value_t **fld = (jl_value_t**)(data+jl_field_offset(dt, i));\n                        *fld = jl_deserialize_value(s, fld);\n                    }\n                    else {\n                        jl_set_nth_field(v, i, jl_deserialize_value(s, NULL));\n                    }\n                }\n            }\n            if ((mode == MODE_MODULE || mode == MODE_MODULE_POSTWORK)) {\n                if (jl_is_mtable(v))\n                    arraylist_push(&methtable_list, v); // will resort this table, later\n                if (dt == jl_typename_type) {\n                    jl_typename_t* tn = (jl_typename_t*)v;\n                    tn->uid = jl_assign_type_uid(); // make sure this has a new uid\n                    tn->cache = jl_emptysvec; // the cache is refilled later (tag 5)\n                    tn->linearcache = jl_emptysvec; // the cache is refilled later (tag 5)\n                }\n            }\n        }\n        return v;\n    }\n    else if (vtag == (jl_value_t*)Singleton_tag) {\n        if (mode == MODE_MODULE_POSTWORK) {\n            uptrint_t pos = backref_list.len;\n            arraylist_push(&backref_list, NULL);\n            jl_datatype_t *dt = (jl_datatype_t*)jl_deserialize_value(s, NULL);\n            backref_list.items[pos] = dt->instance;\n            return dt->instance;\n        }\n        jl_value_t *v = (jl_value_t*)jl_gc_alloc_0w();\n        if (usetable) {\n            uptrint_t pos = backref_list.len;\n            arraylist_push(&backref_list, (void*)v);\n            if (mode == MODE_MODULE) {\n                // TODO: optimize the case where the value can easily be obtained\n                // from an external module (tag == 6) as dt->instance\n                assert(loc != NULL);\n                arraylist_push(&flagref_list, loc);\n                arraylist_push(&flagref_list, (void*)pos);\n            }\n        }\n        jl_datatype_t *dt = (jl_datatype_t*)jl_deserialize_value(s, NULL); // no loc, since if dt is replaced, then dt->instance would be also\n        jl_set_typeof(v, dt);\n        return v;\n    }\n    assert(0);\n    return NULL;\n}\n\nvoid jl_deserialize_lambdas_from_mod(ios_t *s)\n{\n    while (1) {\n        jl_module_t *mod = (jl_module_t*)jl_deserialize_value(s, NULL);\n        if (mod == NULL)\n            return;\n        jl_sym_t *name = (jl_sym_t*)jl_deserialize_value(s, NULL);\n        jl_function_t *gf = (jl_function_t*)jl_get_global(mod, name);\n        int8_t iskw = read_int8(s);\n        assert(jl_is_gf(gf));\n        if (iskw) {\n            jl_methtable_t* mt = jl_gf_mtable(gf);\n            if (!mt->kwsorter) {\n                mt->kwsorter = jl_new_generic_function(jl_gf_name(gf), mt->module);\n                jl_gc_wb(mt, mt->kwsorter);\n            }\n            gf = mt->kwsorter;\n            assert(jl_is_gf(gf));\n        }\n        jl_tupletype_t *types = (jl_tupletype_t*)jl_deserialize_value(s, NULL);\n        jl_function_t *meth = (jl_function_t*)jl_deserialize_value(s, NULL);\n        jl_svec_t *tvars = (jl_svec_t*)jl_deserialize_value(s, NULL);\n        int8_t isstaged = read_int8(s);\n        jl_add_method(gf, types, meth, tvars, isstaged);\n    }\n}\n\nint jl_deserialize_verify_mod_list(ios_t *s)\n{\n    if (!jl_main_module->uuid) {\n        jl_printf(JL_STDERR, \"ERROR: Main module uuid state is invalid for module deserialization.\\n\");\n        return 0;\n    }\n    while (1) {\n        size_t len = read_int32(s);\n        if (len == 0)\n            return 1;\n        char *name = (char*)alloca(len+1);\n        ios_read(s, name, len);\n        name[len] = '\\0';\n        uint64_t uuid = read_uint64(s);\n        jl_sym_t *sym = jl_symbol(name);\n        jl_module_t *m = (jl_module_t*)jl_get_global(jl_main_module, sym);\n        if (!m) {\n            static jl_value_t *require_func = NULL;\n            if (!require_func)\n                require_func = jl_get_global(jl_base_module, jl_symbol(\"require\"));\n            JL_TRY {\n                jl_apply((jl_function_t*)require_func, (jl_value_t**)&sym, 1);\n            }\n            JL_CATCH {\n                ios_close(s);\n                jl_rethrow();\n            }\n            m = (jl_module_t*)jl_get_global(jl_main_module, sym);\n        }\n        if (!m) {\n            jl_printf(JL_STDERR, \"ERROR: requiring \\\"%s\\\" did not define a corresponding module\\n\", name);\n            return 0;\n        }\n        if (!jl_is_module(m)) {\n            ios_close(s);\n            jl_errorf(\"invalid module path (%s does not name a module)\", name);\n        }\n        if (m->uuid != uuid) {\n            jl_printf(JL_STDERR,\n                      \"WARNING: Module %s uuid did not match cache file\\n\"\n                      \"  This is likely because module %s does not support\"\n                      \"  precompilation but is imported by a module that does.\\n\",\n                      name, name);\n            return 0;\n        }\n    }\n}\n\nstatic int readstr_verify(ios_t *s, const char *str)\n{\n    size_t len = strlen(str);\n    for (size_t i=0; i < len; ++i)\n        if ((char) read_uint8(s) != str[i])\n            return 0;\n    return 1;\n}\n\nDLLEXPORT int jl_deserialize_verify_header(ios_t *s)\n{\n    uint16_t bom;\n    return (readstr_verify(s, JI_MAGIC) &&\n            read_uint16(s) == JI_FORMAT_VERSION &&\n            ios_read(s, (char *) &bom, 2) == 2 && bom == BOM &&\n            read_uint8(s) == sizeof(void*) &&\n            readstr_verify(s, jl_get_OS_NAME()->name) && !read_uint8(s) &&\n            readstr_verify(s, jl_get_ARCH()->name) && !read_uint8(s) &&\n            readstr_verify(s, JULIA_VERSION_STRING) && !read_uint8(s) &&\n            readstr_verify(s, jl_git_branch()) && !read_uint8(s) &&\n            readstr_verify(s, jl_git_commit()) && !read_uint8(s));\n}\n\njl_array_t *jl_module_init_order;\n\nstatic void jl_finalize_serializer(ios_t *f) {\n    size_t i, l;\n    // save module initialization order\n    if (jl_module_init_order != NULL) {\n        l = jl_array_len(jl_module_init_order);\n        for(i=0; i < l; i++) {\n            // verify that all these modules were saved\n            assert(ptrhash_get(&backref_table, jl_cellref(jl_module_init_order, i)) != HT_NOTFOUND);\n        }\n    }\n    if (mode != MODE_MODULE)\n        jl_serialize_value(f, jl_module_init_order);\n\n    // record list of reinitialization functions\n    l = reinit_list.len;\n    for (i = 0; i < l; i += 2) {\n        write_int32(f, (int)((uintptr_t) reinit_list.items[i]));\n        write_int32(f, (int)((uintptr_t) reinit_list.items[i+1]));\n    }\n    write_int32(f, -1);\n}\n\nstatic void jl_reinit_item(ios_t *f, jl_value_t *v, int how) {\n    JL_TRY {\n        switch (how) {\n            case 1: { // rehash ObjectIdDict\n                jl_array_t **a = (jl_array_t**)jl_data_ptr(v);\n                // Assume *a don't need a write barrier\n                jl_idtable_rehash(a, jl_array_len(*a));\n                jl_gc_wb(v, *a);\n                break;\n            }\n            case 2: { // reinsert module v into parent (const)\n                jl_module_t *mod = (jl_module_t*)v;\n                jl_binding_t *b = jl_get_binding_wr(mod->parent, mod->name);\n                jl_declare_constant(b); // this can throw\n                if (b->value != NULL) {\n                    if (!jl_is_module(b->value)) {\n                        jl_errorf(\"invalid redefinition of constant %s\", mod->name->name); // this also throws\n                    }\n                    if (jl_generating_output() && jl_options.incremental) {\n                        jl_errorf(\"cannot replace module %s during incremental precompile\", mod->name->name);\n                    }\n                    jl_printf(JL_STDERR, \"WARNING: replacing module %s\\n\", mod->name->name);\n                }\n                b->value = v;\n                jl_gc_wb_binding(b, v);\n                break;\n            }\n            default:\n                assert(0);\n        }\n    }\n    JL_CATCH {\n        jl_printf(JL_STDERR, \"WARNING: error while reinitializing value \");\n        jl_static_show(JL_STDERR, v);\n        jl_printf(JL_STDERR, \":\\n\");\n        jl_static_show(JL_STDERR, jl_exception_in_transit);\n        jl_printf(JL_STDERR, \"\\n\");\n    }\n}\nstatic jl_array_t *jl_finalize_deserializer(ios_t *f) {\n    jl_array_t *init_order = NULL;\n    if (mode != MODE_MODULE)\n        init_order = (jl_array_t*)jl_deserialize_value(f, NULL);\n\n    // run reinitialization functions\n    int pos = read_int32(f);\n    while (pos != -1) {\n        jl_reinit_item(f, (jl_value_t*)backref_list.items[pos], read_int32(f));\n        pos = read_int32(f);\n    }\n    return init_order;\n}\n\nvoid jl_init_restored_modules(jl_array_t *init_order)\n{\n    if (!init_order)\n        return;\n    int i;\n    for(i=0; i < jl_array_len(init_order); i++) {\n        jl_value_t *mod = jl_cellref(init_order, i);\n        jl_module_run_initializer((jl_module_t*)mod);\n    }\n}\n\n\n// --- entry points ---\n\nvoid jl_save_system_image_to_stream(ios_t *f)\n{\n    jl_gc_collect(1); // full\n    jl_gc_collect(0); // incremental (sweep finalizers)\n    JL_SIGATOMIC_BEGIN();\n    int en = jl_gc_enable(0);\n    htable_reset(&backref_table, 250000);\n    arraylist_new(&reinit_list, 0);\n    backref_table_numel = 0;\n\n    // orphan old Base module if present\n    jl_base_module = (jl_module_t*)jl_get_global(jl_main_module, jl_symbol(\"Base\"));\n\n    jl_idtable_type = jl_base_module ? jl_get_global(jl_base_module, jl_symbol(\"ObjectIdDict\")) : NULL;\n\n    jl_serialize_value(f, jl_main_module);\n    jl_serialize_value(f, jl_top_module);\n    jl_serialize_value(f, jl_typeinf_func);\n\n    // ensure everything in deser_tag is reassociated with its GlobalValue\n    ptrint_t i=2;\n    for (i=2; i < 255; i++) {\n        jl_serialize_gv(f, deser_tag[i]);\n    }\n    jl_serialize_globalvals(f);\n    jl_serialize_gv_others(f); // serialize things that might not have visible gc roots roots with GlobalValue references\n\n    write_int32(f, jl_get_t_uid_ctr());\n    write_int32(f, jl_get_gs_ctr());\n    jl_finalize_serializer(f); // done with f\n\n    htable_reset(&backref_table, 0);\n    arraylist_free(&reinit_list);\n\n    jl_gc_enable(en);\n    JL_SIGATOMIC_END();\n}\n\nDLLEXPORT void jl_save_system_image(const char *fname)\n{\n    ios_t f;\n    if (ios_file(&f, fname, 1, 1, 1, 1) == NULL) {\n        jl_errorf(\"cannot open system image file \\\"%s\\\" for writing\", fname);\n    }\n    JL_SIGATOMIC_BEGIN();\n    jl_save_system_image_to_stream(&f);\n    ios_close(&f);\n    JL_SIGATOMIC_END();\n}\n\nDLLEXPORT ios_t *jl_create_system_image()\n{\n    ios_t *f; f = (ios_t*)malloc(sizeof(ios_t));\n    ios_mem(f, 1000000);\n    jl_save_system_image_to_stream(f);\n    return f;\n}\n\nextern jl_function_t *jl_typeinf_func;\nextern int jl_boot_file_loaded;\nextern void jl_get_builtin_hooks(void);\nextern void jl_get_system_hooks(void);\n\n// Takes in a path of the form \"usr/lib/julia/sys.{ji,so}\", as passed to jl_restore_system_image()\nDLLEXPORT void jl_preload_sysimg_so(const char *fname)\n{\n    // If passed NULL, don't even bother\n    if (!fname)\n        return;\n\n    // First, get \"sys\" from \"sys.ji\"\n    char *fname_shlib = (char*)alloca(strlen(fname)+1);\n    strcpy(fname_shlib, fname);\n    char *fname_shlib_dot = strrchr(fname_shlib, '.');\n    if (fname_shlib_dot != NULL) {\n        if (!strcmp(fname_shlib_dot, \".ji\"))\n            return;  // .ji extension => load .ji file only\n        *fname_shlib_dot = 0;\n    }\n\n    // Get handle to sys.so\n    jl_sysimg_handle = (uv_lib_t*)jl_load_dynamic_library_e(fname_shlib, JL_RTLD_DEFAULT | JL_RTLD_GLOBAL);\n\n    // set cpu target if unspecified by user and available from sysimg\n    // otherwise default to native.\n    if (jl_sysimg_handle && jl_options.cpu_target == NULL)\n        jl_options.cpu_target = (const char *)jl_dlsym(jl_sysimg_handle, \"jl_sysimg_cpu_target\");\n}\n\nvoid jl_restore_system_image_from_stream(ios_t *f)\n{\n    JL_SIGATOMIC_BEGIN();\n    int en = jl_gc_enable(0);\n    DUMP_MODES last_mode = mode;\n    mode = MODE_SYSTEM_IMAGE;\n    arraylist_new(&backref_list, 250000);\n\n    datatype_list = jl_alloc_cell_1d(0);\n\n    jl_main_module = (jl_module_t*)jl_deserialize_value(f, NULL);\n    jl_top_module = (jl_module_t*)jl_deserialize_value(f, NULL);\n    jl_internal_main_module = jl_main_module;\n    jl_typeinf_func = (jl_function_t*)jl_deserialize_value(f, NULL);\n    jl_core_module = (jl_module_t*)jl_get_global(jl_main_module,\n                                                 jl_symbol(\"Core\"));\n    jl_base_module = (jl_module_t*)jl_get_global(jl_main_module,\n                                                 jl_symbol(\"Base\"));\n    jl_current_module = jl_base_module; // run start_image in Base\n\n    // ensure everything in deser_tag is reassociated with its GlobalValue\n    ptrint_t i;\n    for (i=2; i < 255; i++) {\n        jl_deserialize_gv(f, deser_tag[i]);\n    }\n    jl_deserialize_globalvals(f);\n    jl_deserialize_gv_others(f);\n\n    int uid_ctr = read_int32(f);\n    int gs_ctr = read_int32(f);\n    jl_module_init_order = jl_finalize_deserializer(f); // done with f\n\n    // cache builtin parametric types\n    for(int i=0; i < jl_array_len(datatype_list); i++) {\n        jl_value_t *v = jl_cellref(datatype_list, i);\n        jl_cache_type_((jl_datatype_t*)v);\n    }\n    datatype_list = NULL;\n\n    jl_get_builtin_hooks();\n    if (jl_base_module) {\n        jl_get_system_hooks();\n    }\n    jl_boot_file_loaded = 1;\n    jl_init_box_caches();\n\n    jl_set_t_uid_ctr(uid_ctr);\n    jl_set_gs_ctr(gs_ctr);\n\n    //jl_printf(JL_STDERR, \"backref_list.len = %d\\n\", backref_list.len);\n    arraylist_free(&backref_list);\n\n    jl_gc_enable(en);\n    mode = last_mode;\n    jl_update_all_fptrs();\n    JL_SIGATOMIC_END();\n}\n\nDLLEXPORT void jl_restore_system_image(const char *fname)\n{\n    char *dot = (char*) strrchr(fname, '.');\n    int is_ji = (dot && !strcmp(dot, \".ji\"));\n\n    if (!is_ji) {\n        int err = jl_load_sysimg_so();\n        if (err != 0) {\n            if (jl_sysimg_handle == 0)\n                jl_errorf(\"system image file \\\"%s\\\" not found\", fname);\n            jl_errorf(\"library \\\"%s\\\" does not contain a valid system image\", fname);\n        }\n    }\n    else {\n        ios_t f;\n        if (ios_file(&f, fname, 1, 0, 0, 0) == NULL)\n            jl_errorf(\"system image file \\\"%s\\\" not found\", fname);\n        JL_SIGATOMIC_BEGIN();\n        jl_restore_system_image_from_stream(&f);\n        ios_close(&f);\n        JL_SIGATOMIC_END();\n    }\n}\n\nDLLEXPORT void jl_restore_system_image_data(const char *buf, size_t len)\n{\n    ios_t f;\n    JL_SIGATOMIC_BEGIN();\n    ios_static_buffer(&f, (char*)buf, len);\n    jl_restore_system_image_from_stream(&f);\n    ios_close(&f);\n    JL_SIGATOMIC_END();\n}\n\nDLLEXPORT jl_value_t *jl_ast_rettype(jl_lambda_info_t *li, jl_value_t *ast)\n{\n    if (jl_is_expr(ast))\n        return jl_lam_body((jl_expr_t*)ast)->etype;\n    JL_SIGATOMIC_BEGIN();\n    DUMP_MODES last_mode = mode;\n    mode = MODE_AST;\n    if (li->module->constant_table == NULL) {\n        li->module->constant_table = jl_alloc_cell_1d(0);\n        jl_gc_wb(li->module, li->module->constant_table);\n    }\n    tree_literal_values = li->module->constant_table;\n    ios_t src;\n    jl_array_t *bytes = (jl_array_t*)ast;\n    ios_mem(&src, 0);\n    ios_setbuf(&src, (char*)bytes->data, jl_array_len(bytes), 0);\n    src.size = jl_array_len(bytes);\n    int en = jl_gc_enable(0);\n    jl_value_t *rt = jl_deserialize_value(&src, NULL);\n    jl_gc_enable(en);\n    tree_literal_values = NULL;\n    mode = last_mode;\n    JL_SIGATOMIC_END();\n    return rt;\n}\n\nDLLEXPORT jl_value_t *jl_compress_ast(jl_lambda_info_t *li, jl_value_t *ast)\n{\n    JL_SIGATOMIC_BEGIN();\n    DUMP_MODES last_mode = mode;\n    mode = MODE_AST;\n    ios_t dest;\n    ios_mem(&dest, 0);\n    jl_array_t *last_tlv = tree_literal_values;\n    jl_module_t *last_tem = tree_enclosing_module;\n    int en = jl_gc_enable(0);\n\n    if (li->module->constant_table == NULL) {\n        li->module->constant_table = jl_alloc_cell_1d(0);\n        jl_gc_wb(li->module, li->module->constant_table);\n    }\n    tree_literal_values = li->module->constant_table;\n    tree_enclosing_module = li->module;\n    li->capt = (jl_value_t*)jl_lam_capt((jl_expr_t*)ast);\n    jl_gc_wb(li, li->capt);\n    if (jl_array_len(li->capt) == 0)\n        li->capt = NULL;\n    jl_serialize_value(&dest, jl_lam_body((jl_expr_t*)ast)->etype);\n    jl_serialize_value(&dest, ast);\n\n    //jl_printf(JL_STDERR, \"%d bytes, %d values\\n\", dest.size, vals->length);\n\n    jl_value_t *v = (jl_value_t*)jl_takebuf_array(&dest);\n    if (jl_array_len(tree_literal_values) == 0 && last_tlv == NULL) {\n        li->module->constant_table = NULL;\n    }\n    tree_literal_values = last_tlv;\n    tree_enclosing_module = last_tem;\n    jl_gc_enable(en);\n    mode = last_mode;\n    JL_SIGATOMIC_END();\n    return v;\n}\n\nDLLEXPORT jl_value_t *jl_uncompress_ast(jl_lambda_info_t *li, jl_value_t *data)\n{\n    JL_SIGATOMIC_BEGIN();\n    assert(jl_is_array(data));\n    DUMP_MODES last_mode = mode;\n    mode = MODE_AST;\n    jl_array_t *bytes = (jl_array_t*)data;\n    tree_literal_values = li->module->constant_table;\n    tree_enclosing_module = li->module;\n    ios_t src;\n    ios_mem(&src, 0);\n    ios_setbuf(&src, (char*)bytes->data, jl_array_len(bytes), 0);\n    src.size = jl_array_len(bytes);\n    int en = jl_gc_enable(0);\n    (void)jl_deserialize_value(&src, NULL); // skip ret type\n    jl_value_t *v = jl_deserialize_value(&src, NULL);\n    jl_gc_enable(en);\n    tree_literal_values = NULL;\n    tree_enclosing_module = NULL;\n    mode = last_mode;\n    JL_SIGATOMIC_END();\n    return v;\n}\n\nDLLEXPORT int jl_save_incremental(const char *fname, jl_array_t *worklist)\n{\n    char *tmpfname = strcat(strcpy((char *) alloca(strlen(fname)+8), fname), \".XXXXXX\");\n    ios_t f;\n    if (ios_mkstemp(&f, tmpfname) == NULL) {\n        jl_printf(JL_STDERR, \"Cannot open cache file \\\"%s\\\" for writing.\\n\", tmpfname);\n        return 1;\n    }\n    serializer_worklist = worklist;\n    jl_serialize_header(&f);\n    jl_serialize_mod_list(&f); // this can throw, keep it early (before any actual initialization)\n    jl_serialize_dependency_list(&f);\n\n    JL_SIGATOMIC_BEGIN();\n    arraylist_new(&reinit_list, 0);\n    htable_new(&backref_table, 5000);\n    ptrhash_put(&backref_table, jl_main_module, (char*)HT_NOTFOUND + 1);\n    backref_table_numel = 1;\n    jl_idtable_type = jl_base_module ? jl_get_global(jl_base_module, jl_symbol(\"ObjectIdDict\")) : NULL;\n\n    int en = jl_gc_enable(0);\n    DUMP_MODES last_mode = mode;\n    mode = MODE_MODULE;\n    jl_serialize_value(&f, worklist);\n    jl_finalize_serializer(&f); // done with MODE_MODULE\n    reinit_list.len = 0;\n\n    mode = MODE_MODULE_POSTWORK;\n    jl_serialize_lambdas_from_mod(&f, jl_main_module);\n    jl_serialize_value(&f, NULL); // signal end of lambdas\n    jl_finalize_serializer(&f); // done with f\n\n    mode = last_mode;\n    jl_gc_enable(en);\n\n    htable_reset(&backref_table, 0);\n    arraylist_free(&reinit_list);\n    ios_close(&f);\n    JL_SIGATOMIC_END();\n\n    if (jl_fs_rename(tmpfname, fname) < 0) {\n        jl_printf(JL_STDERR, \"Cannot write cache file \\\"%s\\\".\\n\", fname);\n        return 1;\n    }\n\n    return 0;\n}\n\njl_function_t *jl_method_cache_insert(jl_methtable_t *mt, jl_tupletype_t *type,\n                                      jl_function_t *method);\n\nstatic jl_datatype_t *jl_recache_type(jl_datatype_t *dt, size_t start, jl_value_t *v)\n{\n    if (v == NULL)\n        v = dt->instance; // the instance before unique'ing\n    jl_datatype_t *t; // the type after unique'ing\n    if (dt->uid == -1) {\n        jl_svec_t *tt = dt->parameters;\n        size_t l = jl_svec_len(tt);\n        if (l == 0) { // jl_cache_type doesn't work if length(parameters) == 0\n            dt->uid = jl_assign_type_uid();\n            t = dt;\n        }\n        else {\n            // recache all type parameters, then type type itself\n            size_t i;\n            for (i = 0; i < l; i++) {\n                jl_datatype_t *p = (jl_datatype_t*)jl_svecref(tt, i);\n                if (jl_is_datatype(p) && p->uid == -1) {\n                    jl_datatype_t *cachep = jl_recache_type(p, start, NULL);\n                    if (p != cachep)\n                        jl_svecset(tt, i, cachep);\n                }\n                jl_datatype_t *tp = (jl_datatype_t*)jl_typeof(p);\n                if (jl_is_datatype_singleton(tp)) {\n                    if (tp->uid == -1) {\n                        tp = jl_recache_type(tp, start, NULL);\n                    }\n                    if ((jl_value_t*)p != tp->instance)\n                        jl_svecset(tt, i, tp->instance);\n                }\n            }\n            dt->uid = 0;\n            t = (jl_datatype_t*)jl_cache_type_(dt);\n        }\n    }\n    else {\n        t = dt;\n    }\n    assert(t->uid != 0);\n    // delete / replace any other usages of this type in the backref list\n    // with the newly constructed object\n    size_t j = start;\n    while (j < flagref_list.len) {\n        jl_value_t **loc = (jl_value_t**)flagref_list.items[j];\n        int offs = (int)(intptr_t)flagref_list.items[j+1];\n        jl_value_t *o = loc ? *loc : (jl_value_t*)backref_list.items[offs];\n        if ((jl_value_t*)dt == o) {\n            if (t != dt) {\n                if (loc) *loc = (jl_value_t*)t;\n                if (offs > 0) backref_list.items[offs] = t;\n            }\n        }\n        else if (v == o) {\n            if (t->instance != v) {\n                *loc = t->instance;\n                if (offs > 0) backref_list.items[offs] = t->instance;\n            }\n        }\n        else {\n            j += 2;\n            continue;\n        }\n        // delete this item from the flagref list, so it won't be re-encountered later\n        flagref_list.len -= 2;\n        if (j >= flagref_list.len)\n            break;\n        flagref_list.items[j+0] = flagref_list.items[flagref_list.len+0];\n        flagref_list.items[j+1] = flagref_list.items[flagref_list.len+1];\n    }\n    return t;\n}\n\nstatic void jl_recache_types()\n{\n    size_t i = 0;\n    while (i < flagref_list.len) {\n        jl_value_t **loc = (jl_value_t**)flagref_list.items[i++];\n        int offs = (int)(intptr_t)flagref_list.items[i++];\n        jl_value_t *v, *o = loc ? *loc : (jl_value_t*)backref_list.items[offs];\n        jl_datatype_t *dt, *t;\n        if (jl_is_datatype(o)) {\n            dt = (jl_datatype_t*)o;\n            v = dt->instance;\n            assert(dt->uid == -1);\n            t = jl_recache_type(dt, i, NULL);\n        }\n        else {\n            dt = (jl_datatype_t*)jl_typeof(o);\n            v = o;\n            t = jl_recache_type(dt, i, v);\n        }\n        assert(dt);\n        if (t != dt) {\n            jl_set_typeof(dt, (jl_value_t*)(ptrint_t)0x10); // invalidate the old value to help catch errors\n            if ((jl_value_t*)dt == o) {\n                if (loc) *loc = (jl_value_t*)t;\n                if (offs > 0) backref_list.items[offs] = t;\n            }\n        }\n        if (t->instance != v) {\n            jl_set_typeof(v, (jl_value_t*)(ptrint_t)0x20); // invalidate the old value to help catch errors\n            if (v == o) {\n                *loc = t->instance;\n                if (offs > 0) backref_list.items[offs] = t->instance;\n            }\n        }\n    }\n}\n\nstatic jl_array_t *_jl_restore_incremental(ios_t *f)\n{\n    if (ios_eof(f)) {\n        ios_close(f);\n        return NULL;\n    }\n    if (!jl_deserialize_verify_header(f) ||\n        !jl_deserialize_verify_mod_list(f)) {\n        ios_close(f);\n        return NULL;\n    }\n    size_t deplen = read_uint64(f);\n    ios_skip(f, deplen); // skip past the dependency list\n    JL_SIGATOMIC_BEGIN();\n    arraylist_new(&backref_list, 4000);\n    arraylist_push(&backref_list, jl_main_module);\n    arraylist_new(&flagref_list, 0);\n    arraylist_new(&methtable_list, 0);\n\n    int en = jl_gc_enable(0);\n    DUMP_MODES last_mode = mode;\n    mode = MODE_MODULE;\n    jl_array_t *restored = NULL;\n    jl_array_t *init_order = NULL;\n    restored = (jl_array_t*)jl_deserialize_value(f, (jl_value_t**)&restored);\n\n    jl_recache_types();\n    jl_finalize_deserializer(f); // done with MODE_MODULE\n\n    // at this point, the AST is fully reconstructed, but still completely disconnected\n    // in postwork mode, all of the interconnects will be created\n    mode = MODE_MODULE_POSTWORK;\n    jl_deserialize_lambdas_from_mod(f); // hook up methods of external generic functions\n    init_order = jl_finalize_deserializer(f); // done with f\n\n    // Resort the internal method tables\n    size_t i;\n    for (i = 0; i < methtable_list.len; i++) {\n        jl_methtable_t *mt = (jl_methtable_t*)methtable_list.items[i];\n        jl_array_t *cache_targ = mt->cache_targ;\n        jl_array_t *cache_arg1 = mt->cache_arg1;\n        mt->cache_targ = (jl_array_t*)jl_nothing;\n        mt->cache_arg1 = (jl_array_t*)jl_nothing;\n        if (cache_targ != (void*)jl_nothing) {\n            size_t j, l = jl_array_len(cache_targ);\n            for (j = 0; j < l; j++) {\n                jl_methlist_t *ml = (jl_methlist_t*)jl_cellref(cache_targ, j);\n                while (ml != NULL && ml != (void*)jl_nothing) {\n                    assert(!ml->isstaged);\n                    jl_method_cache_insert(mt, ml->sig, ml->func);\n                    ml = ml->next;\n                }\n            }\n        }\n        if (cache_arg1 != (void*)jl_nothing) {\n            size_t j, l = jl_array_len(cache_arg1);\n            for (j = 0; j < l; j++) {\n                jl_methlist_t *ml = (jl_methlist_t*)jl_cellref(cache_arg1, j);\n                while (ml != NULL && ml != (void*)jl_nothing) {\n                    assert(!ml->isstaged);\n                    jl_method_cache_insert(mt, ml->sig, ml->func);\n                    ml = ml->next;\n                }\n            }\n        }\n    }\n\n    mode = last_mode;\n    jl_gc_enable(en);\n    arraylist_free(&flagref_list);\n    arraylist_free(&methtable_list);\n    arraylist_free(&backref_list);\n    ios_close(f);\n    JL_SIGATOMIC_END();\n\n    JL_GC_PUSH2(&init_order,&restored);\n    jl_init_restored_modules(init_order);\n    JL_GC_POP();\n\n    return restored;\n}\n\nDLLEXPORT jl_value_t *jl_restore_incremental_from_buf(const char *buf, size_t sz)\n{\n    ios_t f;\n    jl_array_t *modules;\n    ios_static_buffer(&f, (char*)buf, sz);\n    modules = _jl_restore_incremental(&f);\n    return modules ? (jl_value_t*) modules : jl_nothing;\n}\n\nDLLEXPORT jl_value_t *jl_restore_incremental(const char *fname)\n{\n    ios_t f;\n    jl_array_t *modules;\n    if (ios_file(&f, fname, 1, 0, 0, 0) == NULL) {\n        jl_printf(JL_STDERR, \"Cache file \\\"%s\\\" not found\\n\", fname);\n        return jl_nothing;\n    }\n    modules = _jl_restore_incremental(&f);\n    return modules ? (jl_value_t*) modules : jl_nothing;\n}\n\n// --- init ---\n\nvoid jl_init_serializer(void)\n{\n    htable_new(&ser_tag, 0);\n    htable_new(&common_symbol_tag, 0);\n    htable_new(&fptr_to_id, sizeof(id_to_fptrs)/sizeof(*id_to_fptrs));\n    htable_new(&backref_table, 0);\n\n    void *tags[] = { jl_symbol_type, jl_gensym_type, jl_datatype_type,\n                     jl_function_type, jl_simplevector_type, jl_array_type,\n                     jl_expr_type, (void*)LongSymbol_tag, (void*)LongSvec_tag,\n                     (void*)LongExpr_tag, (void*)LiteralVal_tag,\n                     (void*)SmallInt64_tag, (void*)SmallDataType_tag,\n                     (void*)Int32_tag, (void*)Array1d_tag, (void*)Singleton_tag,\n                     jl_module_type, jl_tvar_type, jl_lambda_info_type,\n                     (void*)CommonSym_tag, (void*)NearbyGlobal_tag, jl_globalref_type,\n                     // everything above here represents a class of object rather only than a literal\n\n                     jl_emptysvec, jl_emptytuple, jl_false, jl_true, jl_nothing, jl_any_type,\n                     call_sym, goto_ifnot_sym, return_sym, body_sym, line_sym,\n                     lambda_sym, tuple_sym, assign_sym,\n\n                     // empirical list of very common symbols\n                     #include \"common_symbols1.inc\"\n\n                     jl_box_int32(0), jl_box_int32(1), jl_box_int32(2),\n                     jl_box_int32(3), jl_box_int32(4), jl_box_int32(5),\n                     jl_box_int32(6), jl_box_int32(7), jl_box_int32(8),\n                     jl_box_int32(9), jl_box_int32(10), jl_box_int32(11),\n                     jl_box_int32(12), jl_box_int32(13), jl_box_int32(14),\n                     jl_box_int32(15), jl_box_int32(16), jl_box_int32(17),\n                     jl_box_int32(18), jl_box_int32(19), jl_box_int32(20),\n                     jl_box_int32(21), jl_box_int32(22), jl_box_int32(23),\n                     jl_box_int32(24), jl_box_int32(25), jl_box_int32(26),\n                     jl_box_int32(27), jl_box_int32(28), jl_box_int32(29),\n                     jl_box_int32(30), jl_box_int32(31), jl_box_int32(32),\n#ifndef _P64\n                     jl_box_int32(33), jl_box_int32(34), jl_box_int32(35),\n                     jl_box_int32(36), jl_box_int32(37), jl_box_int32(38),\n                     jl_box_int32(39), jl_box_int32(40), jl_box_int32(41),\n                     jl_box_int32(42), jl_box_int32(43), jl_box_int32(44),\n                     jl_box_int32(45), jl_box_int32(46), jl_box_int32(47),\n                     jl_box_int32(48), jl_box_int32(49), jl_box_int32(50),\n#endif\n                     jl_box_int64(0), jl_box_int64(1), jl_box_int64(2),\n                     jl_box_int64(3), jl_box_int64(4), jl_box_int64(5),\n                     jl_box_int64(6), jl_box_int64(7), jl_box_int64(8),\n                     jl_box_int64(9), jl_box_int64(10), jl_box_int64(11),\n                     jl_box_int64(12), jl_box_int64(13), jl_box_int64(14),\n                     jl_box_int64(15), jl_box_int64(16), jl_box_int64(17),\n                     jl_box_int64(18), jl_box_int64(19), jl_box_int64(20),\n                     jl_box_int64(21), jl_box_int64(22), jl_box_int64(23),\n                     jl_box_int64(24), jl_box_int64(25), jl_box_int64(26),\n                     jl_box_int64(27), jl_box_int64(28), jl_box_int64(29),\n                     jl_box_int64(30), jl_box_int64(31), jl_box_int64(32),\n#ifdef _P64\n                     jl_box_int64(33), jl_box_int64(34), jl_box_int64(35),\n                     jl_box_int64(36), jl_box_int64(37), jl_box_int64(38),\n                     jl_box_int64(39), jl_box_int64(40), jl_box_int64(41),\n                     jl_box_int64(42), jl_box_int64(43), jl_box_int64(44),\n                     jl_box_int64(45), jl_box_int64(46), jl_box_int64(47),\n                     jl_box_int64(48), jl_box_int64(49), jl_box_int64(50),\n#endif\n                     jl_labelnode_type, jl_linenumbernode_type,\n                     jl_gotonode_type, jl_quotenode_type, jl_topnode_type,\n                     jl_type_type, jl_bottom_type, jl_ref_type, jl_pointer_type,\n                     jl_vararg_type, jl_ntuple_type, jl_abstractarray_type,\n                     jl_densearray_type, jl_box_type, jl_void_type,\n                     jl_typector_type, jl_typename_type,\n                     jl_task_type, jl_uniontype_type, jl_typetype_type, jl_typetype_tvar,\n                     jl_ANY_flag, jl_array_any_type, jl_intrinsic_type, jl_method_type,\n                     jl_methtable_type, jl_voidpointer_type, jl_newvarnode_type,\n                     jl_array_symbol_type, jl_anytuple_type, jl_tparam0(jl_anytuple_type),\n                     jl_typeof(jl_emptytuple),\n                     jl_symbol_type->name, jl_gensym_type->name, jl_tuple_typename,\n                     jl_ref_type->name, jl_pointer_type->name, jl_simplevector_type->name,\n                     jl_datatype_type->name, jl_uniontype_type->name, jl_array_type->name,\n                     jl_expr_type->name, jl_typename_type->name, jl_type_type->name,\n                     jl_methtable_type->name, jl_method_type->name, jl_tvar_type->name,\n                     jl_ntuple_type->name, jl_abstractarray_type->name, jl_vararg_type->name,\n                     jl_densearray_type->name, jl_void_type->name, jl_lambda_info_type->name,\n                     jl_module_type->name, jl_box_type->name, jl_function_type->name,\n                     jl_typector_type->name, jl_intrinsic_type->name, jl_task_type->name,\n                     jl_labelnode_type->name, jl_linenumbernode_type->name,\n                     jl_gotonode_type->name, jl_quotenode_type->name, jl_topnode_type->name,\n                     jl_globalref_type->name,\n\n                     jl_root_task, jl_bottom_func,\n\n                     NULL };\n\n    // more common symbols, less common than those above. will get 2-byte encodings.\n    void *common_symbols[] = {\n        #include \"common_symbols2.inc\"\n        NULL\n    };\n\n    ptrint_t i=2;\n    while (tags[i-2] != NULL) {\n        ptrhash_put(&ser_tag, tags[i-2], (void*)i);\n        deser_tag[i] = (jl_value_t*)tags[i-2];\n        i += 1;\n    }\n    assert(i <= Null_tag);\n    VALUE_TAGS = (ptrint_t)ptrhash_get(&ser_tag, jl_emptysvec);\n\n    i=2;\n    while (id_to_fptrs[i] != NULL) {\n        ptrhash_put(&fptr_to_id, (void*)id_to_fptrs[i], (void*)i);\n        i += 1;\n    }\n\n    i=2;\n    while (common_symbols[i-2] != NULL) {\n        ptrhash_put(&common_symbol_tag, common_symbols[i-2], (void*)i);\n        deser_symbols[i] = (jl_value_t*)common_symbols[i-2];\n        i += 1;\n    }\n    assert(i <= 256);\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/src/dlload.c": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <sys/stat.h>\n\n#include \"platform.h\"\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#ifdef _OS_WINDOWS_\n#include <windows.h>\n#include <direct.h>\n#else\n#include <unistd.h>\n#include <dlfcn.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(__APPLE__)\nstatic char *extensions[] = { \"\", \".dylib\" };\n#define N_EXTENSIONS 2\n#elif defined(_OS_WINDOWS_)\nstatic char *extensions[] = { \"\", \".dll\" };\n#define N_EXTENSIONS 2\nextern int needsSymRefreshModuleList;\n#else\nstatic char *extensions[] = { \".so\", \"\" };\n#define N_EXTENSIONS 2\n#endif\n\n\n#define PATHBUF 512\n\nextern char *julia_home;\n\n#define JL_RTLD(flags, FLAG) (flags & JL_RTLD_ ## FLAG ? RTLD_ ## FLAG : 0)\n\nDLLEXPORT int jl_uv_dlopen(const char *filename, jl_uv_libhandle lib_, unsigned flags)\n{\n    uv_lib_t *lib = (uv_lib_t *) lib_;\n#if defined(_OS_WINDOWS_)\n    needsSymRefreshModuleList = 1;\n#endif\n#if defined(RTLD_GLOBAL) && defined(RTLD_LAZY) /* POSIX flags available */\n    dlerror(); /* Reset error status. */\n    lib->handle = dlopen(filename,\n                         (flags & JL_RTLD_NOW ? RTLD_NOW : RTLD_LAZY)\n                         | JL_RTLD(flags, LOCAL)\n                         | JL_RTLD(flags, GLOBAL)\n#ifdef RTLD_NODELETE\n                         | JL_RTLD(flags, NODELETE)\n#endif\n#ifdef RTLD_NOLOAD\n                         | JL_RTLD(flags, NOLOAD)\n#endif\n#ifdef RTLD_DEEPBIND\n                         | JL_RTLD(flags, DEEPBIND)\n#endif\n#ifdef RTLD_FIRST\n                         | JL_RTLD(flags, FIRST)\n#endif\n                         );\n    if (lib->handle) {\n        lib->errmsg = NULL;\n        return 0;\n    }\n    else {\n        lib->errmsg = strdup(dlerror());\n        return -1;\n    }\n#else\n    return uv_dlopen(filename, lib);\n#endif\n}\n\nstatic uv_lib_t *jl_load_dynamic_library_(const char *modname, unsigned flags, int throw_err)\n{\n    int error;\n    char *ext;\n    char path[PATHBUF];\n    int i;\n    uv_stat_t stbuf;\n    uv_lib_t *handle = (uv_lib_t*)malloc(sizeof(uv_lib_t));\n    handle->errmsg = NULL;\n\n/*\n    this branch returns handle of libjulia\n*/\n    if (modname == NULL) {\n#ifdef _OS_WINDOWS_\n        if (!GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n                                (LPCWSTR)(&jl_load_dynamic_library),\n                                &handle->handle)) {\n            free(handle);\n            jl_error(\"could not load base module\");\n        }\n#else\n        handle->handle = dlopen(NULL,RTLD_NOW);\n#endif\n        goto done;\n    }\n/*\n    this branch shortcuts absolute paths\n*/\n#ifdef _OS_WINDOWS_\n    else if (modname[1] == ':') {\n#else\n    else if (modname[0] == '/') {\n#endif\n        error = jl_uv_dlopen(modname,handle,flags);\n        if (!error)\n            goto done;\n        // bail out and show the error if file actually exists\n        if (jl_stat(modname, (char*)&stbuf) == 0)\n            goto notfound;\n        if (handle->errmsg)\n            uv_dlclose(handle);\n    }\n/*\n    this branch permutes all base paths in DL_LOAD_PATH with all extensions\n    note: skip when !jl_base_module to avoid UndefVarError(:DL_LOAD_PATH)\n*/\n    else if (jl_base_module != NULL) {\n        jl_array_t *DL_LOAD_PATH = (jl_array_t*)jl_get_global(jl_base_module, jl_symbol(\"DL_LOAD_PATH\"));\n        if (DL_LOAD_PATH != NULL) {\n            size_t j;\n            for (j = 0; j < jl_array_len(DL_LOAD_PATH); j++) {\n                char *dl_path = jl_string_data(jl_cell_data(DL_LOAD_PATH)[j]);\n                size_t len = strlen(dl_path);\n                if (len == 0)\n                    continue;\n                for(i=0; i < N_EXTENSIONS; i++) {\n                    ext = extensions[i];\n                    path[0] = '\\0';\n                    handle->handle = NULL;\n                    if (dl_path[len-1] == PATHSEPSTRING[0])\n                        snprintf(path, PATHBUF, \"%s%s%s\", dl_path, modname, ext);\n                    else\n                        snprintf(path, PATHBUF, \"%s\" PATHSEPSTRING \"%s%s\", dl_path, modname, ext);\n                    // free handle->errmsg, else it will leak on next uv_dlopen\n                    if (handle->errmsg)\n                        uv_dlclose(handle);\n                    error = jl_uv_dlopen(path, handle, flags);\n                    if (!error)\n                        goto done;\n                    // bail out and show the error if file actually exists\n                    if (jl_stat(path, (char*)&stbuf) == 0)\n                        goto notfound;\n                }\n            }\n        }\n    }\n\n    // now fall back and look in default library paths, for all extensions\n    for(i=0; i < N_EXTENSIONS; i++) {\n        ext = extensions[i];\n        path[0] = '\\0';\n        handle->handle = NULL;\n        snprintf(path, PATHBUF, \"%s%s\", modname, ext);\n        if (handle->errmsg)\n            uv_dlclose(handle);\n        error = jl_uv_dlopen(path, handle, flags);\n        if (!error)\n            goto done;\n    }\n\n#if defined(__linux__) || defined(__FreeBSD__)\n// check map of versioned libs from \"libX\" to full soname \"libX.so.ver\"\n    {\n        const char *soname = jl_lookup_soname(modname, strlen(modname));\n        error = (soname==NULL) || jl_uv_dlopen(soname, handle, flags);\n        if (!error)\n            goto done;\n    }\n#endif\n\nnotfound:\n    // copy the error message into the path buffer so we can free the lib handle\n    path[0] = '\\0';\n    snprintf(path, PATHBUF, \"%s\", uv_dlerror(handle));\n    uv_dlclose(handle);\n    free(handle);\n    if (throw_err)\n        jl_errorf(\"could not load library \\\"%s\\\"\\n%s\", modname, path);\n    return NULL;\n\ndone:\n    return handle;\n}\n\njl_uv_libhandle jl_load_dynamic_library_e(const char *modname, unsigned flags)\n{\n    return (jl_uv_libhandle) jl_load_dynamic_library_(modname, flags, 0);\n}\n\njl_uv_libhandle jl_load_dynamic_library(const char *modname, unsigned flags)\n{\n    return (jl_uv_libhandle) jl_load_dynamic_library_(modname, flags, 1);\n}\n\nvoid *jl_dlsym_e(jl_uv_libhandle handle, const char *symbol)\n{\n    void *ptr;\n    int error = uv_dlsym((uv_lib_t *) handle, symbol, &ptr);\n    if (error) ptr=NULL;\n    return ptr;\n}\n\nvoid *jl_dlsym(jl_uv_libhandle handle, const char *symbol)\n{\n    void *ptr;\n    int error = uv_dlsym((uv_lib_t *) handle, symbol, &ptr);\n    if (error) {\n        jl_errorf(\"could not load symbol \\\"%s\\\"\\n%s\", symbol, uv_dlerror((uv_lib_t *) handle));\n    }\n    return ptr;\n}\n\n#ifdef _OS_WINDOWS_\n//Look for symbols in win32 libraries\nchar *jl_dlfind_win32(const char *f_name)\n{\n    if (jl_dlsym_e(jl_exe_handle, f_name))\n        return (char*)1;\n    if (jl_dlsym_e(jl_dl_handle, f_name))\n        return (char*)2;\n    if (jl_dlsym_e(jl_kernel32_handle, f_name))\n        return \"kernel32\";\n    if (jl_dlsym_e(jl_ntdll_handle, f_name))\n        return \"ntdll\";\n    if (jl_dlsym_e(jl_crtdll_handle, f_name))\n#if _MSC_VER == 1800\n        return \"msvcr120\";\n#elif defined(_MSC_VER)\n#error This version of MSVC has not been tested.\n#else\n        return \"msvcrt\";\n#endif\n    if (jl_dlsym_e(jl_winsock_handle, f_name))\n        return \"ws2_32\";\n    // additional common libraries (libc?) could be added here, but in general,\n    // it is better to specify the library explicitly in the code. This exists\n    // mainly to ease compatibility with linux, and for libraries that don't\n    // have a name (julia.exe and libjulia.dll)\n    // We could also loop over all libraries that have been used so far, but, again,\n    // explicit is preferred over implicit\n    return NULL;\n    // oops, we didn't find it. NULL defaults to searching jl_RTLD_DEFAULT_handle,\n    // which defaults to jl_dl_handle, where we won't find it, and will throw the\n    // appropriate error.\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/src/debuginfo.cpp": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n#include \"platform.h\"\n\n#include \"llvm-version.h\"\n#include <llvm/ExecutionEngine/ExecutionEngine.h>\n#include <llvm/ExecutionEngine/JITEventListener.h>\n#include <llvm/DebugInfo/DIContext.h>\n#ifdef LLVM37\n#include \"llvm/DebugInfo/DWARF/DWARFContext.h\"\n#endif\n#include <llvm/Support/MemoryBuffer.h>\n#include <llvm/IR/Function.h>\n#include <llvm/ADT/StringRef.h>\n#ifdef LLVM35\n#include <llvm/IR/DebugInfo.h>\n#else\n#include <llvm/DebugInfo.h>\n#endif\n#ifdef USE_MCJIT\n#ifndef LLVM36\n#include <llvm/ExecutionEngine/ObjectImage.h>\n#endif\n#include <llvm/ExecutionEngine/RuntimeDyld.h>\n#else\n#include <llvm/ExecutionEngine/JITMemoryManager.h>\n#endif\n#ifdef _OS_DARWIN_\n#include <llvm/Object/MachO.h>\n#endif\n#ifdef _OS_WINDOWS_\n#include <llvm/Object/COFF.h>\n#   ifdef LLVM37\n#       include <llvm/Object/ELFObjectFile.h>\n#   endif\n#endif\n\n#if defined(USE_MCJIT) && !defined(LLVM36) && defined(_OS_DARWIN_)\n#include \"../deps/llvm-3.5.0/lib/ExecutionEngine/MCJIT/MCJIT.h\"\n#endif\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <map>\n#include <vector>\n#include <set>\n#include <cstdio>\n#include <cassert>\nusing namespace llvm;\n\nextern DLLEXPORT ExecutionEngine *jl_ExecutionEngine;\n\n#ifdef USE_MCJIT\ntypedef object::SymbolRef SymRef;\n#endif\n\n// --- storing and accessing source location metadata ---\n\n#ifndef USE_MCJIT\nstruct FuncInfo {\n    const Function* func;\n    size_t lengthAdr;\n    std::string name;\n    std::string filename;\n    std::vector<JITEvent_EmittedFunctionDetails::LineStart> lines;\n};\n#else\nstruct ObjectInfo {\n    const object::ObjectFile* object;\n    size_t SectionSize;\n#ifdef LLVM37\n    const llvm::LoadedObjectInfo *L;\n#elif defined(LLVM36)\n    size_t slide;\n#endif\n#ifdef _OS_DARWIN_\n    const char *name;\n#endif\n};\n#endif\n\n#if defined(_OS_WINDOWS_)\n#if defined(_CPU_X86_64_)\nextern \"C\" EXCEPTION_DISPOSITION _seh_exception_handler(PEXCEPTION_RECORD ExceptionRecord,void *EstablisherFrame, PCONTEXT ContextRecord, void *DispatcherContext);\n#endif\n#include <dbghelp.h>\nstatic void create_PRUNTIME_FUNCTION(uint8_t *Code, size_t Size, StringRef fnname,\n        uint8_t *Section, size_t Allocated, uint8_t *UnwindData)\n{\n    DWORD mod_size = 0;\n#if defined(_CPU_X86_64_)\n#if !defined(USE_MCJIT)\n    uint8_t *catchjmp = Section+Allocated;\n    UnwindData = (uint8_t*)(((uintptr_t)catchjmp+12+3)&~(uintptr_t)3);\n    if (!catchjmp[0]) {\n        catchjmp[0] = 0x48;\n        catchjmp[1] = 0xb8; // mov RAX, QWORD PTR [...]\n        *(uint64_t*)(&catchjmp[2]) = (uint64_t)&_seh_exception_handler;\n        catchjmp[10] = 0xff;\n        catchjmp[11] = 0xe0; // jmp RAX\n        UnwindData[0] = 0x09; // version info, UNW_FLAG_EHANDLER\n        UnwindData[1] = 4;    // size of prolog (bytes)\n        UnwindData[2] = 2;    // count of unwind codes (slots)\n        UnwindData[3] = 0x05; // frame register (rbp) = rsp\n        UnwindData[4] = 4;    // second instruction\n        UnwindData[5] = 0x03; // mov RBP, RSP\n        UnwindData[6] = 1;    // first instruction\n        UnwindData[7] = 0x50; // push RBP\n        *(DWORD*)&UnwindData[8] = (DWORD)(catchjmp - Section); // relative location of catchjmp\n        mod_size = (DWORD)Allocated+48;\n    }\n    PRUNTIME_FUNCTION tbl = (PRUNTIME_FUNCTION)(UnwindData+12);\n#else\n    PRUNTIME_FUNCTION tbl = (PRUNTIME_FUNCTION)malloc(sizeof(RUNTIME_FUNCTION));\n#endif\n    tbl->BeginAddress = (DWORD)(Code - Section);\n    tbl->EndAddress = (DWORD)(Code - Section + Size);\n    tbl->UnwindData = (DWORD)(UnwindData - Section);\n#else // defined(_CPU_X86_64_)\n    Section += (uintptr_t)Code;\n    mod_size = Size;\n#endif\n    if (0) {\n        assert(!jl_in_stackwalk);\n        jl_in_stackwalk = 1;\n        if (mod_size && !SymLoadModuleEx(GetCurrentProcess(), NULL, NULL, NULL, (DWORD64)Section, mod_size, NULL, SLMFLAG_VIRTUAL)) {\n#if defined(_CPU_X86_64_) && !defined(USE_MCJIT)\n            catchjmp[0] = 0;\n#endif\n            static int warned = 0;\n            if (!warned) {\n                jl_printf(JL_STDERR, \"WARNING: failed to insert module info for backtrace: %lu\\n\", GetLastError());\n                warned = 1;\n            }\n        }\n        else {\n            size_t len = fnname.size()+1;\n            if (len > MAX_SYM_NAME)\n                len = MAX_SYM_NAME;\n            char *name = (char*)alloca(len);\n            memcpy(name, fnname.data(), len-1);\n            name[len-1] = 0;\n            if (!SymAddSymbol(GetCurrentProcess(), (ULONG64)Section, name,\n                        (DWORD64)Code, (DWORD)Size, 0)) {\n                jl_printf(JL_STDERR, \"WARNING: failed to insert function name %s into debug info: %lu\\n\", name, GetLastError());\n            }\n        }\n        jl_in_stackwalk = 0;\n    }\n#if defined(_CPU_X86_64_)\n    if (!RtlAddFunctionTable(tbl, 1, (DWORD64)Section)) {\n        static int warned = 0;\n        if (!warned) {\n            jl_printf(JL_STDERR, \"WARNING: failed to insert function stack unwind info: %lu\\n\", GetLastError());\n            warned = 1;\n        }\n    }\n#endif\n}\n#endif\n\nstruct revcomp {\n    bool operator() (const size_t& lhs, const size_t& rhs) const\n    { return lhs>rhs; }\n};\n\nclass JuliaJITEventListener: public JITEventListener\n{\n#ifndef USE_MCJIT\n    std::map<size_t, FuncInfo, revcomp> info;\n#else\n    std::map<size_t, ObjectInfo, revcomp> objectmap;\n#endif\n\npublic:\n    JuliaJITEventListener(){}\n    virtual ~JuliaJITEventListener() {}\n\n#ifndef USE_MCJIT\n    virtual void NotifyFunctionEmitted(const Function &F, void *Code,\n                                       size_t Size, const EmittedFunctionDetails &Details)\n    {\n#if defined(_OS_WINDOWS_)\n        create_PRUNTIME_FUNCTION((uint8_t*)Code, Size, F.getName(), (uint8_t*)Code, Size, NULL);\n#endif\n        FuncInfo tmp = {&F, Size, F.getName().str(), std::string(), Details.LineStarts};\n        info[(size_t)(Code)] = tmp;\n    }\n\n    std::map<size_t, FuncInfo, revcomp>& getMap()\n    {\n        return info;\n    }\n#endif // ifndef USE_MCJIT\n\n#ifdef USE_MCJIT\n#ifdef LLVM36\n    virtual void NotifyObjectEmitted(const object::ObjectFile &obj,\n                                     const RuntimeDyld::LoadedObjectInfo &L)\n#else\n    virtual void NotifyObjectEmitted(const ObjectImage &obj)\n#endif\n    {\n        uint64_t Addr;\n        uint64_t Size;\n        object::SymbolRef::Type SymbolType;\n#ifdef LLVM36\n        object::section_iterator Section = obj.section_begin();\n        object::section_iterator EndSection = obj.section_end();\n        uint64_t SectionAddr = 0;\n        StringRef sName;\n#else\n        object::section_iterator Section = obj.begin_sections();\n        object::section_iterator EndSection = obj.end_sections();\n        bool isText;\n#ifndef _OS_LINUX_\n        StringRef sName;\n#endif\n#endif\n\n#ifndef LLVM36\n        uint64_t SectionAddr = 0;\n#endif\n        uint64_t SectionSize = 0;\n        uint64_t SectionAddrCheck = 0; // assert that all of the Sections are at the same location\n\n#if defined(_OS_WINDOWS_)\n#if defined(_CPU_X86_64_)\n        uint8_t *UnwindData = NULL;\n        uint8_t *catchjmp = NULL;\n        for (const object::SymbolRef &sym_iter : obj.symbols()) {\n#  ifdef LLVM37\n            sName = sym_iter.getName().get();\n#  else\n            sym_iter.getName(sName);\n#  endif\n            if (sName.equals(\"__UnwindData\")) {\n#  ifdef LLVM37\n                Addr = sym_iter.getAddress().get();\n#  else\n                sym_iter.getAddress(Addr);\n#  endif\n                sym_iter.getSection(Section);\n#  ifdef LLVM36\n                assert(Section->isText());\n#    ifdef LLVM38\n                SectionAddr = L.getSectionLoadAddress(*Section);\n#    else\n                Section->getName(sName);\n                SectionAddr = L.getSectionLoadAddress(sName);\n#    endif\n                Addr += SectionAddr;\n#  else\n                if (Section->isText(isText) || !isText) assert(0 && \"!isText\");\n                Section->getAddress(SectionAddr);\n#  endif\n                UnwindData = (uint8_t*)Addr;\n                if (SectionAddrCheck)\n                    assert(SectionAddrCheck == SectionAddr);\n                else\n                    SectionAddrCheck = SectionAddr;\n            }\n            if (sName.equals(\"__catchjmp\")) {\n#  ifdef LLVM37\n                Addr = sym_iter.getAddress().get();\n#  else\n                sym_iter.getAddress(Addr);\n#  endif\n                sym_iter.getSection(Section);\n#  ifdef LLVM36\n                assert(Section->isText());\n#    ifdef LLVM38\n                SectionAddr = L.getSectionLoadAddress(*Section);\n#    else\n                Section->getName(sName);\n                SectionAddr = L.getSectionLoadAddress(sName);\n#    endif\n                Addr += SectionAddr;\n#  else\n                if (Section->isText(isText) || !isText) assert(0 && \"!isText\");\n                Section->getAddress(SectionAddr);\n#  endif\n                catchjmp = (uint8_t*)Addr;\n                if (SectionAddrCheck)\n                    assert(SectionAddrCheck == SectionAddr);\n                else\n                    SectionAddrCheck = SectionAddr;\n            }\n        }\n        assert(catchjmp);\n        assert(UnwindData);\n        catchjmp[0] = 0x48;\n        catchjmp[1] = 0xb8; // mov RAX, QWORD PTR [&_seh_exception_handle]\n        *(uint64_t*)(&catchjmp[2]) = (uint64_t)&_seh_exception_handler;\n        catchjmp[10] = 0xff;\n        catchjmp[11] = 0xe0; // jmp RAX\n        UnwindData[0] = 0x09; // version info, UNW_FLAG_EHANDLER\n        UnwindData[1] = 4;    // size of prolog (bytes)\n        UnwindData[2] = 2;    // count of unwind codes (slots)\n        UnwindData[3] = 0x05; // frame register (rbp) = rsp\n        UnwindData[4] = 4;    // second instruction\n        UnwindData[5] = 0x03; // mov RBP, RSP\n        UnwindData[6] = 1;    // first instruction\n        UnwindData[7] = 0x50; // push RBP\n        *(DWORD*)&UnwindData[8] = (DWORD)(catchjmp - (uint8_t*)SectionAddr); // relative location of catchjmp\n#else // defined(_OS_X86_64_)\n        uint8_t *UnwindData = NULL;\n#endif // defined(_OS_X86_64_)\n#endif // defined(_OS_WINDOWS_)\n\n#ifdef LLVM35\n        for (const object::SymbolRef &sym_iter : obj.symbols()) {\n#           ifdef LLVM37\n                SymbolType = sym_iter.getType();\n#           else\n                sym_iter.getType(SymbolType);\n#           endif\n            if (SymbolType != object::SymbolRef::ST_Function) continue;\n#           ifdef LLVM37\n                Addr = sym_iter.getAddress().get();\n#           else\n                sym_iter.getAddress(Addr);\n#           endif\n#           ifdef LLVM38\n                Section = sym_iter.getSection().get();\n#           else\n                sym_iter.getSection(Section);\n#           endif\n            if (Section == EndSection) continue;\n#if defined(LLVM36)\n            if (!Section->isText()) continue;\n#    ifdef LLVM38\n            SectionAddr = L.getSectionLoadAddress(*Section);\n#    else\n            Section->getName(sName);\n            SectionAddr = L.getSectionLoadAddress(sName);\n#    endif\n            Addr += SectionAddr;\n#else\n            if (Section->isText(isText) || !isText) continue;\n#endif\n#if defined(LLVM36)\n            SectionSize = Section->getSize();\n#else\n            Section->getAddress(SectionAddr);\n            Section->getSize(SectionSize);\n#endif\n#ifdef _OS_DARWIN_\n#   if defined(LLVM37)\n            Size = Section->getSize();\n            sName = sym_iter.getName().get();\n#   else\n            sym_iter.getName(sName);\n#   endif\n#   if defined(LLVM36)\n            if (sName[0] == '_') {\n                sName = sName.substr(1);\n            }\n#   else\n            Addr = ((MCJIT*)jl_ExecutionEngine)->getSymbolAddress(sName, true);\n            if (!Addr && sName[0] == '_') {\n                sName = sName.substr(1);\n                Addr = ((MCJIT*)jl_ExecutionEngine)->getSymbolAddress(sName, true);\n            }\n            if (!Addr) continue;\n#   endif\n#elif defined(_OS_WINDOWS_)\n#   if defined(LLVM37)\n            assert(obj.isELF());\n            Size = ((llvm::object::ELFSymbolRef)sym_iter).getSize();\n            sName = sym_iter.getName().get();\n#   else\n            sym_iter.getSize(Size);\n            sym_iter.getName(sName);\n#   endif\n#   ifdef _CPU_X86_\n            if (sName[0] == '_') sName = sName.substr(1);\n#   endif\n            if (SectionAddrCheck)\n                assert(SectionAddrCheck == SectionAddr);\n            else\n                SectionAddrCheck = SectionAddr;\n            create_PRUNTIME_FUNCTION(\n                   (uint8_t*)(intptr_t)Addr, (size_t)Size, sName,\n                   (uint8_t*)(intptr_t)SectionAddr, (size_t)SectionSize, UnwindData);\n#endif\n            const object::ObjectFile *objfile =\n#ifdef LLVM36\n                &obj;\n#else\n                obj.getObjectFile();\n#endif\n            ObjectInfo tmp = {objfile, SectionSize\n#ifdef LLVM37\n                ,L.clone().release()\n#elif defined(LLVM36)\n                ,(size_t)SectionAddr\n#endif\n#ifdef _OS_DARWIN_\n                ,strndup(sName.data(), sName.size())\n#endif\n            };\n            objectmap[Addr] = tmp;\n        }\n#else //LLVM34\n        error_code itererr;\n        object::symbol_iterator sym_iter = obj.begin_symbols();\n        object::symbol_iterator sym_end = obj.end_symbols();\n        for (; sym_iter != sym_end; sym_iter.increment(itererr)) {\n            sym_iter->getType(SymbolType);\n            if (SymbolType != object::SymbolRef::ST_Function) continue;\n            sym_iter->getAddress(Addr);\n            sym_iter->getSize(Size);\n\n            ObjectInfo tmp = {obj.getObjectFile(), (size_t)Size};\n            objectmap[Addr] = tmp;\n        }\n#endif\n    }\n\n    // must implement if we ever start freeing code\n    // virtual void NotifyFreeingObject(const ObjectImage &obj) {}\n    // virtual void NotifyFreeingObject(const object::ObjectFile &Obj) {}\n\n    std::map<size_t, ObjectInfo, revcomp>& getObjectMap()\n    {\n        return objectmap;\n    }\n#endif // USE_MCJIT\n};\n\nextern \"C\"\nchar *jl_demangle(const char *name)\n{\n    const char *start = name + 6;\n    const char *end = name + strlen(name);\n    char *ret;\n    if (strncmp(name, \"julia_\", 6)) goto done;\n    if (*start == '\\0') goto done;\n    while (*(--end) != '_') {\n        char c = *end;\n        if (c < '0' || c > '9') goto done;\n    }\n    if (end <= start) goto done;\n    ret = (char*)malloc(end-start+1);\n    memcpy(ret,start,end-start);\n    ret[end-start] = '\\0';\n    return ret;\n done:\n    return strdup(name);\n}\n\nJuliaJITEventListener *jl_jit_events;\nvoid RegisterJuliaJITEventListener()\n{\n    jl_jit_events = new JuliaJITEventListener();\n    jl_ExecutionEngine->RegisterJITEventListener(jl_jit_events);\n}\n\n// *name and *filename are either NULL or malloc'd pointers\nvoid lookup_pointer(DIContext *context, char **name, size_t *line,\n                    char **filename, size_t *inlinedat_line,\n                    char **inlinedat_file, size_t pointer,\n                    int demangle, int *fromC)\n{\n    DILineInfo info, topinfo;\n    DIInliningInfo inlineinfo;\n    if (demangle && *name != NULL) {\n        char *oldname = *name;\n        *name = jl_demangle(*name);\n        free(oldname);\n    }\n#ifdef LLVM35\n    DILineInfoSpecifier infoSpec(DILineInfoSpecifier::FileLineInfoKind::AbsoluteFilePath,\n                                 DILineInfoSpecifier::FunctionNameKind::ShortName);\n    DILineInfoSpecifier inlineSpec(DILineInfoSpecifier::FileLineInfoKind::AbsoluteFilePath,\n                                 DILineInfoSpecifier::FunctionNameKind::ShortName);\n#else\n    int infoSpec = DILineInfoSpecifier::FileLineInfo |\n                   DILineInfoSpecifier::AbsoluteFilePath |\n                   DILineInfoSpecifier::FunctionName;\n    int inlineSpec = DILineInfoSpecifier::FileLineInfo |\n                   DILineInfoSpecifier::AbsoluteFilePath |\n                   DILineInfoSpecifier::FunctionName;\n#endif\n\n    if (context == NULL) goto done;\n    info = context->getLineInfoForAddress(pointer, infoSpec);\n    inlineinfo = context->getInliningInfoForAddress(pointer, inlineSpec);\n\n#ifndef LLVM35 // LLVM <= 3.4\n    if (strcmp(info.getFunctionName(), \"<invalid>\") == 0) goto done;\n    if (demangle) {\n        free(*name);\n        *name = jl_demangle(info.getFunctionName());\n    }\n    else {\n        jl_copy_str(name, info.getFunctionName());\n    }\n    *line = info.getLine();\n    jl_copy_str(filename, info.getFileName());\n\n    if (inlineinfo.getNumberOfFrames() > 1) {\n        topinfo = inlineinfo.getFrame(inlineinfo.getNumberOfFrames() - 1);\n        jl_copy_str(inlinedat_file, topinfo.getFileName());\n        *inlinedat_line = topinfo.getLine();\n    }\n#else\n    if (strcmp(info.FunctionName.c_str(), \"<invalid>\") == 0) goto done;\n    jl_copy_str(name, info.FunctionName.c_str());\n    *line = info.Line;\n    jl_copy_str(filename, info.FileName.c_str());\n\n    if (inlineinfo.getNumberOfFrames() > 1) {\n        topinfo = inlineinfo.getFrame(inlineinfo.getNumberOfFrames() - 1);\n        jl_copy_str(inlinedat_file, topinfo.FileName.c_str());\n        *inlinedat_line = topinfo.Line;\n    }\n#endif\n\ndone:\n    // If this is a jlcall wrapper, set fromC to match JIT behavior\n    if (*name == NULL || memcmp(*name, \"jlcall_\",7) == 0) {\n        *fromC = true;\n    }\n}\n\n#ifdef _OS_DARWIN_\n#include <mach-o/dyld.h>\n#endif\n#ifndef _OS_WINDOWS_\n#include <dlfcn.h>\n#endif\ntypedef struct {\n    llvm::object::ObjectFile *obj;\n    DIContext *ctx;\n    int64_t slide;\n} objfileentry_t;\ntypedef std::map<uint64_t, objfileentry_t> obfiletype;\nstatic obfiletype objfilemap;\n\n#ifdef _OS_DARWIN_\nbool getObjUUID(llvm::object::MachOObjectFile *obj, uint8_t uuid[16])\n{\n\n# ifdef LLVM37\n    for (auto Load : obj->load_commands ()) {\n# else\n#  ifdef LLVM35\n    uint32_t LoadCommandCount = obj->getHeader().ncmds;\n#  else\n    uint32_t LoadCommandCount = obj->getHeader().NumLoadCommands;\n#  endif\n    llvm::object::MachOObjectFile::LoadCommandInfo Load = obj->getFirstLoadCommandInfo();\n    for (unsigned I = 0; ; ++I) {\n# endif\n        if (\n# ifdef LLVM35\n            Load.C.cmd == LC_UUID\n# else\n            Load.C.Type == LC_UUID\n# endif\n            ) {\n            memcpy(uuid,((MachO::uuid_command*)Load.Ptr)->uuid,16);\n            return true;\n        }\n# ifndef LLVM37\n        else if (I == LoadCommandCount - 1) {\n            return false;\n        }\n        else {\n            Load = obj->getNextLoadCommandInfo(Load);\n        }\n# endif\n    }\n    return false;\n}\n#endif\n\nextern \"C\" uint64_t jl_sysimage_base;\n\n// *name and *filename should be either NULL or malloc'd pointer\nvoid jl_getDylibFunctionInfo(char **name, char **filename, size_t *line,\n                             char** inlinedat_file, size_t *inlinedat_line,\n                             size_t pointer, int *fromC, int skipC, int skipInline)\n{\n#ifdef _OS_WINDOWS_\n    IMAGEHLP_MODULE64 ModuleInfo;\n    BOOL isvalid;\n    if (jl_in_stackwalk) {\n        *fromC = 1;\n        return;\n    }\n    ModuleInfo.SizeOfStruct = sizeof(IMAGEHLP_MODULE64);\n    jl_in_stackwalk = 1;\n    isvalid = SymGetModuleInfo64(GetCurrentProcess(), (DWORD64)pointer, &ModuleInfo);\n    jl_in_stackwalk = 0;\n    if (isvalid) {\n        char *fname = ModuleInfo.LoadedImageName;\n        DWORD64 fbase = ModuleInfo.BaseOfImage;\n        *fromC = (fbase != jl_sysimage_base);\n        if (skipC && *fromC) {\n            return;\n        }\n        static char frame_info_func[\n            sizeof(SYMBOL_INFO) +\n            MAX_SYM_NAME * sizeof(TCHAR)];\n        static IMAGEHLP_LINE64 frame_info_line;\n        DWORD dwDisplacement = 0;\n        DWORD64 dwDisplacement64 = 0;\n        DWORD64 dwAddress = pointer;\n        PSYMBOL_INFO pSymbol = (PSYMBOL_INFO)frame_info_func;\n        pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);\n        pSymbol->MaxNameLen = MAX_SYM_NAME;\n        jl_in_stackwalk = 1;\n        if (SymFromAddr(GetCurrentProcess(), dwAddress, &dwDisplacement64,\n                        pSymbol)) {\n            // SymFromAddr returned success\n            jl_copy_str(name, pSymbol->Name);\n        }\n        else {\n            // SymFromAddr failed\n            //jl_printf(JL_STDERR,\"SymFromAddr returned error : %lu\\n\", GetLastError());\n        }\n\n        frame_info_line.SizeOfStruct = sizeof(IMAGEHLP_LINE64);\n        if (SymGetLineFromAddr64(GetCurrentProcess(), dwAddress, &dwDisplacement, &frame_info_line)) {\n            // SymGetLineFromAddr64 returned success\n            // record source file name and line number\n            if (frame_info_line.FileName)\n                jl_copy_str(filename, frame_info_line.FileName);\n            *line = frame_info_line.LineNumber;\n        }\n        else if (*fromC) {\n            // No debug info, use dll name instead\n            jl_copy_str(filename, fname);\n        }\n        jl_in_stackwalk = 0;\n#else // ifdef _OS_WINDOWS_\n    Dl_info dlinfo;\n    if ((dladdr((void*)pointer, &dlinfo) != 0) && dlinfo.dli_fname) {\n        const char *fname;\n        uint64_t fbase = (uint64_t)dlinfo.dli_fbase;\n#if defined(_OS_DARWIN_)\n        size_t msize = (size_t)(((uint64_t)-1)-fbase);\n#endif\n        *fromC = (fbase != jl_sysimage_base);\n        if (skipC && *fromC)\n            return;\n        // In case we fail with the debug info lookup, we at least still\n        // have the function name, even if we don't have line numbers\n        jl_copy_str(name, dlinfo.dli_sname);\n        jl_copy_str(filename, dlinfo.dli_fname);\n        fname = dlinfo.dli_fname;\n#endif // ifdef _OS_WINDOWS_\n        DIContext *context = NULL;\n        int64_t slide = 0;\n#if !defined(_OS_WINDOWS_) || defined(LLVM35)\n        obfiletype::iterator it = objfilemap.find(fbase);\n        llvm::object::ObjectFile *obj = NULL;\n        if (it == objfilemap.end()) {\n#if defined(_OS_DARWIN_)\n#ifdef LLVM36\n           std::unique_ptr<MemoryBuffer> membuf = MemoryBuffer::getMemBuffer(\n                    StringRef((const char *)fbase, msize), \"\", false);\n           auto origerrorobj = llvm::object::ObjectFile::createObjectFile(\n                membuf->getMemBufferRef(), sys::fs::file_magic::unknown);\n#elif defined(LLVM35)\n            MemoryBuffer *membuf = MemoryBuffer::getMemBuffer(\n                StringRef((const char *)fbase, msize), \"\", false);\n            std::unique_ptr<MemoryBuffer> buf(membuf);\n            auto origerrorobj = llvm::object::ObjectFile::createObjectFile(\n                buf, sys::fs::file_magic::unknown);\n#else\n            MemoryBuffer *membuf = MemoryBuffer::getMemBuffer(\n                StringRef((const char *)fbase, msize), \"\", false);\n            llvm::object::ObjectFile *origerrorobj = llvm::object::ObjectFile::createObjectFile(\n                membuf);\n#endif\n            if (!origerrorobj) {\n                objfileentry_t entry = {obj,context,slide};\n                objfilemap[fbase] = entry;\n                goto lookup;\n            }\n#ifdef LLVM36\n            llvm::object::MachOObjectFile *morigobj = (llvm::object::MachOObjectFile *)origerrorobj.get().release();\n#elif LLVM35\n            llvm::object::MachOObjectFile *morigobj = (llvm::object::MachOObjectFile *)origerrorobj.get();\n#else\n            llvm::object::MachOObjectFile *morigobj = (llvm::object::MachOObjectFile *)origerrorobj;\n#endif\n            // First find the uuid of the object file (we'll use this to make sure we find the\n            // correct debug symbol file).\n            uint8_t uuid[16], uuid2[16];\n            if (!getObjUUID(morigobj,uuid)) {\n                objfileentry_t entry = {obj,context,slide};\n                objfilemap[fbase] = entry;\n                goto lookup;\n            }\n\n            // On OS X debug symbols are not contained in the dynamic library and that's why\n            // we can't have nice things (easily). For now we only support .dSYM files in the same directory\n            // as the shared library. In the future we may use DBGCopyFullDSYMURLForUUID from CoreFoundation to make\n            // use of spotlight to find the .dSYM file.\n            char dsympath[PATH_MAX];\n            strlcpy(dsympath, fname, sizeof(dsympath));\n            strlcat(dsympath, \".dSYM/Contents/Resources/DWARF/\", sizeof(dsympath));\n            strlcat(dsympath, strrchr(fname,'/')+1, sizeof(dsympath));\n#ifdef LLVM35\n            auto errorobj = llvm::object::ObjectFile::createObjectFile(dsympath);\n#else\n            llvm::object::ObjectFile *errorobj = llvm::object::ObjectFile::createObjectFile(dsympath);\n#endif\n#else // ifdef _OS_DARWIN_\n            // On Linux systems we need to mmap another copy because of the permissions on the mmap'ed shared library.\n#ifdef LLVM35\n            auto errorobj = llvm::object::ObjectFile::createObjectFile(fname);\n#else\n            llvm::object::ObjectFile *errorobj = llvm::object::ObjectFile::createObjectFile(fname);\n#endif\n#endif // ifdef _OS_DARWIN_\n            if (errorobj) {\n#if LLVM36\n                auto binary = errorobj.get().takeBinary();\n                obj = binary.first.release();\n                binary.second.release();\n#elif LLVM35\n                obj = errorobj.get();\n#else\n                obj = errorobj;\n#endif\n#ifdef _OS_DARWIN_\n                if (getObjUUID(morigobj,uuid2) && memcmp(uuid,uuid2,sizeof(uuid)) == 0) {\n#endif\n#ifdef LLVM37\n                    context = new DWARFContextInMemory(*obj);\n#elif LLVM36\n                    context = DIContext::getDWARFContext(*obj);\n#else\n                    context = DIContext::getDWARFContext(obj);\n#endif\n                    slide = -(uint64_t)fbase;\n#ifdef _OS_DARWIN_\n                }\n#endif\n#ifdef _OS_WINDOWS_\n#ifdef LLVM35\n                assert(obj->isCOFF());\n                llvm::object::COFFObjectFile *coffobj = (llvm::object::COFFObjectFile *)obj;\n                const llvm::object::pe32plus_header *pe32plus;\n                coffobj->getPE32PlusHeader(pe32plus);\n                if (pe32plus != NULL) {\n                    slide = pe32plus->ImageBase - fbase;\n                }\n                else {\n                    const llvm::object::pe32_header *pe32;\n                    coffobj->getPE32Header(pe32);\n                    if (pe32 == NULL) {\n                        obj = NULL;\n                        context = NULL;\n                    }\n                    else {\n                        slide = pe32->ImageBase - fbase;\n                    }\n                }\n#endif\n#endif\n\n            }\n            objfileentry_t entry = {obj,context,slide};\n            objfilemap[fbase] = entry;\n        }\n        else {\n            obj = it->second.obj;\n            context = it->second.ctx;\n            slide = it->second.slide;\n        }\n#endif // ifdef _OS_WINDOWS && !LLVM35\n#ifdef _OS_DARWIN_\nlookup:\n#endif\n        lookup_pointer(context, name, line, filename, inlinedat_line, inlinedat_file, pointer+slide,\n                       fbase == jl_sysimage_base, fromC);\n    }\n    else {\n        *fromC = 1;\n    }\n}\n\n// Set *name and *filename to either NULL or malloc'd string\nvoid jl_getFunctionInfo(char **name, char **filename, size_t *line,\n                        char **inlinedat_file, size_t *inlinedat_line,\n                        size_t pointer, int *fromC, int skipC, int skipInline)\n{\n    *name = NULL;\n    *line = -1;\n    *filename = NULL;\n    *inlinedat_file = NULL;\n    *inlinedat_line = -1;\n    *fromC = 0;\n\n#ifdef USE_MCJIT\n    // With MCJIT we can get function information directly from the ObjectFile\n    std::map<size_t, ObjectInfo, revcomp> &objmap =\n        jl_jit_events->getObjectMap();\n    std::map<size_t, ObjectInfo, revcomp>::iterator it =\n        objmap.lower_bound(pointer);\n\n    if (it != objmap.end() &&\n        (intptr_t)(*it).first + (*it).second.SectionSize > pointer) {\n#if defined(_OS_DARWIN_) && !defined(LLVM37)\n        // *name should always be NULL here, free it anyway just to be more\n        // robust\n        free(*name);\n        *name = jl_demangle((*it).second.name);\n        DIContext *context = NULL; // versions of MCJIT < 3.7 can't handle MachO relocations\n#else\n#ifdef LLVM36\n#ifdef LLVM37\n        DIContext *context = new DWARFContextInMemory(*it->second.object, it->second.L);\n#else\n        DIContext *context = DIContext::getDWARFContext(*it->second.object);\n        pointer -= (*it).second.slide;\n#endif\n#else\n        DIContext *context = DIContext::getDWARFContext(const_cast<object::ObjectFile*>(it->second.object));\n#endif\n#endif\n        lookup_pointer(context, name, line, filename, inlinedat_line, inlinedat_file, pointer, 1, fromC);\n        delete context;\n        return;\n    }\n\n#else // !USE_MCJIT\n// Without MCJIT we use the FuncInfo structure containing address maps\n    std::map<size_t, FuncInfo, revcomp> &info = jl_jit_events->getMap();\n    std::map<size_t, FuncInfo, revcomp>::iterator it = info.lower_bound(pointer);\n    if (it != info.end() && (intptr_t)(*it).first + (*it).second.lengthAdr >= pointer) {\n        // We do this to hide the jlcall wrappers when getting julia backtraces,\n        // but it is still good to have them for regular lookup of C frames.\n        if (skipC && (*it).second.lines.empty()) {\n            // Technically not true, but we don't want them\n            // in julia backtraces, so close enough\n            *fromC = 1;\n            return;\n        }\n\n        jl_copy_str(name, (*it).second.name.c_str());\n        jl_copy_str(filename, (*it).second.filename.c_str());\n\n        if ((*it).second.lines.empty()) {\n            *fromC = 1;\n            return;\n        }\n\n        std::vector<JITEvent_EmittedFunctionDetails::LineStart>::iterator vit =\n            (*it).second.lines.begin();\n        JITEvent_EmittedFunctionDetails::LineStart prev = *vit;\n\n        if ((*it).second.func) {\n            DISubprogram debugscope =\n                DISubprogram(prev.Loc.getScope((*it).second.func->getContext()));\n            jl_copy_str(filename, debugscope.getFilename().str().c_str());\n            // the DISubprogram has the un-mangled name, so use that if\n            // available. However, if the scope need not be the current\n            // subprogram.\n            if (debugscope.getName().data() != NULL) {\n                jl_copy_str(name, debugscope.getName().str().c_str());\n            } else {\n                char *oldname = *name;\n                *name = jl_demangle(*name);\n                free(oldname);\n            }\n        }\n\n        vit++;\n\n        while (vit != (*it).second.lines.end()) {\n            if (pointer <= (*vit).Address) {\n                *line = prev.Loc.getLine();\n                break;\n            }\n            prev = *vit;\n            vit++;\n        }\n        if (*line == (size_t) -1) {\n            *line = prev.Loc.getLine();\n        }\n\n        DILexicalBlockFile locscope = DILexicalBlockFile(prev.Loc.getScope((*it).second.func->getContext()));\n        jl_copy_str(filename, locscope.getFilename().str().c_str());\n\n        MDNode *inlinedAt = skipInline ? NULL : prev.Loc.getInlinedAt((*it).second.func->getContext());\n        if ((!skipInline) && (inlinedAt != NULL)) {\n            DebugLoc inlineloc = DebugLoc::getFromDILocation(inlinedAt);\n            DILexicalBlockFile inlinescope = DILexicalBlockFile(inlineloc.getScope((*it).second.func->getContext()));\n            jl_copy_str(inlinedat_file, inlinescope.getFilename().str().c_str());\n            *inlinedat_line = inlineloc.getLine();\n        }\n\n        return;\n    }\n#endif // USE_MCJIT\n    jl_getDylibFunctionInfo(name, filename, line, inlinedat_file, inlinedat_line, pointer, fromC, skipC, skipInline);\n}\n\nint jl_get_llvmf_info(uint64_t fptr, uint64_t *symsize, uint64_t *slide,\n#ifdef USE_MCJIT\n    const object::ObjectFile **object\n#else\n    std::vector<JITEvent_EmittedFunctionDetails::LineStart> *lines\n#endif\n    )\n{\n#ifndef USE_MCJIT\n    std::map<size_t, FuncInfo, revcomp> &fmap = jl_jit_events->getMap();\n    std::map<size_t, FuncInfo, revcomp>::iterator fit = fmap.find(fptr);\n\n    if (fit != fmap.end()) {\n        *symsize = fit->second.lengthAdr;\n        *lines = fit->second.lines;\n        *slide = 0;\n        return 1;\n    }\n    return 0;\n#else // MCJIT version\n    std::map<size_t, ObjectInfo, revcomp> &objmap = jl_jit_events->getObjectMap();\n    std::map<size_t, ObjectInfo, revcomp>::iterator fit = objmap.find(fptr);\n\n    if (fit != objmap.end()) {\n        *symsize = fit->second.SectionSize;\n        *object = fit->second.object;\n#if defined(LLVM36) && !defined(LLVM37)\n        *slide = fit->second.slide;\n#else\n        *slide = 0;\n#endif\n        return 1;\n    }\n    return 0;\n#endif\n}\n\n\n#if defined(_OS_DARWIN_) && defined(LLVM37) && defined(LLVM_SHLIB)\n\n/*\n * We use a custom unwinder, so we need to make sure that when registering dynamic\n * frames, we do so with our unwinder rather than with the system one. If LLVM is\n * statically linked everything works out fine, but if it's dynamically linked\n * it would usually pick up the system one, so we need to do the registration\n * ourselves to ensure the right one gets picked.\n */\n\n#include \"llvm/ExecutionEngine/SectionMemoryManager.h\"\nclass RTDyldMemoryManagerOSX : public SectionMemoryManager\n{\n  RTDyldMemoryManagerOSX(const RTDyldMemoryManagerOSX&) = delete;\n  void operator=(const RTDyldMemoryManagerOSX&) = delete;\n\npublic:\n    RTDyldMemoryManagerOSX() {};\n    ~RTDyldMemoryManagerOSX() override {};\n    void registerEHFrames(uint8_t *Addr, uint64_t LoadAddr, size_t Size) override;\n    void deregisterEHFrames(uint8_t *Addr, uint64_t LoadAddr, size_t Size);\n};\n\nextern \"C\" void __register_frame(void*);\nextern \"C\" void __deregister_frame(void*);\n\nstatic void (*libc_register_frame)(void*)   = NULL;\nstatic void (*libc_deregister_frame)(void*) = NULL;\n\nstatic const char *processFDE(const char *Entry, bool isDeregister)\n{\n    const char *P = Entry;\n    uint32_t Length = *((const uint32_t *)P);\n    P += 4;\n    uint32_t Offset = *((const uint32_t *)P);\n    if (Offset != 0) {\n        if (isDeregister) {\n            if (!libc_deregister_frame) {\n                libc_deregister_frame = (void(*)(void*))dlsym(RTLD_NEXT,\"__deregister_frame\");\n            }\n            assert(libc_deregister_frame);\n            libc_deregister_frame(const_cast<char *>(Entry));\n            __deregister_frame(const_cast<char *>(Entry));\n        }\n        else {\n            if (!libc_register_frame) {\n                libc_register_frame = (void(*)(void*))dlsym(RTLD_NEXT,\"__register_frame\");\n            }\n            assert(libc_register_frame);\n            libc_register_frame(const_cast<char *>(Entry));\n            __register_frame(const_cast<char *>(Entry));\n        }\n    }\n    return P + Length;\n}\n\n// This implementation handles frame registration for local targets.\n// Memory managers for remote targets should re-implement this function\n// and use the LoadAddr parameter.\nvoid RTDyldMemoryManagerOSX::registerEHFrames(uint8_t *Addr, uint64_t LoadAddr, size_t Size)\n{\n    // On OS X OS X __register_frame takes a single FDE as an argument.\n    // See http://lists.cs.uiuc.edu/pipermail/llvmdev/2013-April/061768.html\n    const char *P = (const char *)Addr;\n    const char *End = P + Size;\n    do  {\n        P = processFDE(P, false);\n    } while(P != End);\n}\n\nvoid RTDyldMemoryManagerOSX::deregisterEHFrames(uint8_t *Addr, uint64_t LoadAddr, size_t Size)\n{\n    const char *P = (const char *)Addr;\n    const char *End = P + Size;\n    do  {\n        P = processFDE(P, true);\n    } while(P != End);\n}\n\nRTDyldMemoryManager* createRTDyldMemoryManagerOSX()\n{\n    return new RTDyldMemoryManagerOSX();\n}\n\n#endif\n\n#if defined(_OS_WINDOWS_)\n#ifdef USE_MCJIT\nextern \"C\"\nDWORD64 jl_getUnwindInfo(ULONG64 dwAddr)\n{\n    std::map<size_t, ObjectInfo, revcomp> &objmap = jl_jit_events->getObjectMap();\n    std::map<size_t, ObjectInfo, revcomp>::iterator it = objmap.lower_bound(dwAddr);\n    if (it != objmap.end() && (intptr_t)(*it).first + (*it).second.SectionSize > dwAddr) {\n        return (DWORD64)(intptr_t)(*it).first;\n    }\n    return 0;\n}\n\n#else //ifdef USE_MCJIT\n#if defined(_CPU_X86_64_)\n// Custom memory manager for exception handling on Windows\n// we overallocate 48 bytes at the end of each function\n// for unwind information (see NotifyFunctionEmitted)\nclass JITMemoryManagerWin : public JITMemoryManager {\nprivate:\n    JITMemoryManager *JMM;\npublic:\n    JITMemoryManagerWin() : JITMemoryManager()\n    {\n        JMM = JITMemoryManager::CreateDefaultMemManager();\n    }\n    virtual void setMemoryWritable() { return JMM->setMemoryWritable(); }\n    virtual void setMemoryExecutable() { return JMM->setMemoryExecutable(); }\n    virtual void setPoisonMemory(bool poison) { return JMM->setPoisonMemory(poison); }\n    virtual void AllocateGOT() { JMM->AllocateGOT(); HasGOT = true; }\n    virtual uint8_t *getGOTBase() const { return JMM->getGOTBase(); }\n    virtual uint8_t *startFunctionBody(const Function *F, uintptr_t &ActualSize)\n    {\n        if (ActualSize == 0)\n            ActualSize += 64;\n        ActualSize += 48;\n        uint8_t *mem = JMM->startFunctionBody(F,ActualSize);\n        ActualSize -= 48;\n        return mem;\n    }\n    virtual uint8_t *allocateStub(const GlobalValue* F, unsigned StubSize, unsigned Alignment)\n    {\n        return JMM->allocateStub(F,StubSize,Alignment);\n    }\n    virtual void endFunctionBody(const Function *F, uint8_t *FunctionStart, uint8_t *FunctionEnd)\n    {\n        FunctionEnd[0] = 0;\n        JMM->endFunctionBody(F,FunctionStart,FunctionEnd+48);\n    }\n    virtual uint8_t *allocateSpace(intptr_t Size, unsigned Alignment) { return JMM->allocateSpace(Size,Alignment); }\n    virtual uint8_t *allocateGlobal(uintptr_t Size, unsigned Alignment) { return JMM->allocateGlobal(Size,Alignment); }\n    virtual void deallocateFunctionBody(void *Body) { return JMM->deallocateFunctionBody(Body); }\n    virtual uint8_t *startExceptionTable(const Function* F,\n                                         uintptr_t &ActualSize) { return JMM->startExceptionTable(F,ActualSize); }\n    virtual void endExceptionTable(const Function *F, uint8_t *TableStart,\n                                   uint8_t *TableEnd, uint8_t *FrameRegister) { return JMM->endExceptionTable(F,TableStart,TableEnd,FrameRegister); }\n    virtual void deallocateExceptionTable(void *ET) { return JMM->deallocateExceptionTable(ET); }\n    virtual bool CheckInvariants(std::string &str) { return JMM->CheckInvariants(str); }\n    virtual size_t GetDefaultCodeSlabSize() { return JMM->GetDefaultCodeSlabSize(); }\n    virtual size_t GetDefaultDataSlabSize() { return JMM->GetDefaultDataSlabSize(); }\n    virtual size_t GetDefaultStubSlabSize() { return JMM->GetDefaultStubSlabSize(); }\n    virtual unsigned GetNumCodeSlabs() { return JMM->GetNumCodeSlabs(); }\n    virtual unsigned GetNumDataSlabs() { return JMM->GetNumDataSlabs(); }\n    virtual unsigned GetNumStubSlabs() { return JMM->GetNumStubSlabs(); }\n\n#ifdef LLVM35\n    virtual uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,\n                                         unsigned SectionID, llvm::StringRef SectionName)\n    {\n        uint8_t *mem = JMM->allocateCodeSection(Size+48, Alignment, SectionID, SectionName);\n        mem[Size] = 0;\n        return mem;\n    }\n    virtual uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n                                         unsigned SectionID, llvm::StringRef SectionName, bool IsReadOnly)\n    {\n        return JMM->allocateDataSection(Size,Alignment,SectionID,SectionName,IsReadOnly);\n    }\n#else\n    virtual uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment, unsigned SectionID)\n    {\n        uint8_t *mem = JMM->allocateCodeSection(Size+48, Alignment, SectionID);\n        mem[Size] = 0;\n        return mem;\n    }\n    virtual uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n                                         unsigned SectionID, bool IsReadOnly)\n    {\n        return JMM->allocateDataSection(Size,Alignment,SectionID,IsReadOnly);\n    }\n#endif\n    virtual void *getPointerToNamedFunction(const std::string &Name, bool AbortOnFailure = true)\n    {\n        return JMM->getPointerToNamedFunction(Name,AbortOnFailure);\n    }\n    virtual bool applyPermissions(std::string *ErrMsg = 0) { return JMM->applyPermissions(ErrMsg); }\n    virtual void registerEHFrames(StringRef SectionData) { return JMM->registerEHFrames(SectionData); }\n};\nJITMemoryManager* createJITMemoryManagerWin()\n{\n    return new JITMemoryManagerWin();\n}\n#else\nextern \"C\"\nDWORD64 jl_getUnwindInfo(ULONG64 dwAddr)\n{\n    std::map<size_t, FuncInfo, revcomp> &info = jl_jit_events->getMap();\n    std::map<size_t, FuncInfo, revcomp>::iterator it = info.lower_bound(dwAddr);\n    if (it != info.end() && (intptr_t)(*it).first + (*it).second.lengthAdr > dwAddr) {\n        return (DWORD64)(intptr_t)(*it).first;\n    }\n    return 0;\n}\n#endif\n#endif\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/src/codegen.cpp": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n#include \"llvm-version.h\"\n#include \"platform.h\"\n#include \"options.h\"\n#if defined(_OS_WINDOWS_)\n// trick pre-llvm36 into skipping the generation of _chkstk calls\n//   since it has some codegen issues associated with them:\n//   (a) assumed to be within 32-bit offset\n//   (b) bad asm is generated for certain code patterns:\n//       see https://github.com/JuliaLang/julia/pull/11644#issuecomment-112276813\n// also MCJIT debugging support on windows needs ELF (currently)\n#define FORCE_ELF\n#endif\n\n#ifndef __STDC_LIMIT_MACROS\n#define __STDC_LIMIT_MACROS\n#define __STDC_CONSTANT_MACROS\n#endif\n\n#include <llvm/ExecutionEngine/ExecutionEngine.h>\n#include <llvm/ExecutionEngine/JITEventListener.h>\n#include <llvm/IR/IntrinsicInst.h>\n#ifdef LLVM38\n#include <llvm/Analysis/BasicAliasAnalysis.h>\n#include <llvm/Analysis/TypeBasedAliasAnalysis.h>\n#endif\n#ifdef LLVM37\n#include \"llvm/IR/LegacyPassManager.h\"\n#else\n#include <llvm/PassManager.h>\n#endif\n#include <llvm/Target/TargetSubtargetInfo.h>\n#include <llvm/Support/TargetRegistry.h>\n#include <llvm/Analysis/Passes.h>\n#include <llvm/Bitcode/ReaderWriter.h>\n#ifdef LLVM37\n#include <llvm/Analysis/TargetLibraryInfo.h>\n#else\n#include <llvm/Target/TargetLibraryInfo.h>\n#endif\n#ifdef LLVM35\n#include <llvm/IR/Verifier.h>\n#include <llvm/Object/ObjectFile.h>\n#include <llvm/IR/DIBuilder.h>\n#include <llvm/Target/TargetMachine.h>\n#include <llvm/AsmParser/Parser.h>\n#else\n#include <llvm/Assembly/Parser.h>\n#include <llvm/Analysis/Verifier.h>\n#endif\n#include <llvm/DebugInfo/DIContext.h>\n#ifdef USE_MCJIT\n#include <llvm/ExecutionEngine/MCJIT.h>\n#include <llvm/ExecutionEngine/SectionMemoryManager.h>\n#include <llvm/ADT/DenseMapInfo.h>\n#include <llvm/Object/ObjectFile.h>\n#else\n#include <llvm/ExecutionEngine/JIT.h>\n#include <llvm/ExecutionEngine/JITMemoryManager.h>\n#include <llvm/ExecutionEngine/Interpreter.h>\n#endif\n#include <llvm/IR/DerivedTypes.h>\n#include <llvm/IR/LLVMContext.h>\n#include <llvm/IR/Module.h>\n#include <llvm/IR/Intrinsics.h>\n#include <llvm/IR/Attributes.h>\n#include <llvm/IR/IRBuilder.h>\n#include <llvm/IR/MDBuilder.h>\n#include <llvm/IR/Value.h>\n#ifndef LLVM35\n#include <llvm/DebugInfo.h>\n#include <llvm/DIBuilder.h>\n#endif\n#include <llvm/Target/TargetOptions.h>\n#include <llvm/Transforms/Scalar.h>\n#include <llvm/Transforms/Utils/BasicBlockUtils.h>\n#include <llvm/Transforms/Instrumentation.h>\n#include <llvm/Transforms/Vectorize.h>\n#include <llvm/Support/Host.h>\n#include <llvm/Support/TargetSelect.h>\n#include <llvm/Support/raw_ostream.h>\n#include <llvm/Support/FormattedStream.h>\n#include <llvm/Support/DynamicLibrary.h>\n#include <llvm/Support/PrettyStackTrace.h>\n#include <llvm/Support/SourceMgr.h>\n#include <llvm/Support/CommandLine.h>\n#include <llvm/Transforms/Utils/Cloning.h>\n\n#if defined(_OS_WINDOWS_) && !defined(NOMINMAX)\n#define NOMINMAX\n#endif\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n\n#include <setjmp.h>\n\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <map>\n#include <vector>\n#include <set>\n#include <cstdio>\n#include <cassert>\nusing namespace llvm;\n\n// LLVM version compatibility macros\n#if LLVM37\nusing namespace llvm::legacy;\n#define LLVM37_param(x) (x),\n#else\n#define LLVM37_param(x)\n#endif\n\nextern \"C\" {\n\n#include \"builtin_proto.h\"\n\n#ifdef HAVE_SSP\nextern uintptr_t __stack_chk_guard;\nextern void __stack_chk_fail();\n#else\nDLLEXPORT uintptr_t __stack_chk_guard = (uintptr_t)0xBAD57ACCBAD67ACC; // 0xBADSTACKBADSTACK\nDLLEXPORT void __stack_chk_fail()\n{\n    /* put your panic function or similar in here */\n    fprintf(stderr, \"fatal error: stack corruption detected\\n\");\n    abort(); // end with abort, since the compiler destroyed the stack upon entry to this function, there's no going back now\n}\n#endif\n\n#ifdef _OS_WINDOWS_\n#if defined(_CPU_X86_64_)\n#if defined(_COMPILER_MINGW_)\nextern void ___chkstk_ms(void);\n#else\nextern void __chkstk(void);\n#endif\n#else\n#if defined(_COMPILER_MINGW_)\n#undef _alloca\nextern void _alloca(void);\n#else\nextern void _chkstk(void);\n#endif\n#endif\n//void *force_chkstk(void) {\n//    return alloca(40960);\n//}\n#endif\n}\n\n#if defined(_COMPILER_MICROSOFT_) && !defined(__alignof__)\n#define __alignof__ __alignof\n#endif\n\n#define DISABLE_FLOAT16\n\n// llvm state\nDLLEXPORT LLVMContext &jl_LLVMContext = getGlobalContext();\nstatic IRBuilder<> builder(getGlobalContext());\nstatic bool nested_compile=false;\nDLLEXPORT ExecutionEngine *jl_ExecutionEngine;\nDLLEXPORT TargetMachine *jl_TargetMachine;\n#ifdef USE_MCJIT\nstatic Module *shadow_module;\nDLLEXPORT RTDyldMemoryManager *jl_mcjmm;\n#define jl_Module (builder.GetInsertBlock()->getParent()->getParent())\n#else\nstatic Module *jl_Module;\n#define shadow_module jl_Module\n#endif\nstatic MDBuilder *mbuilder;\nstatic std::map<int, std::string> argNumberStrings;\n#ifdef LLVM38\nstatic legacy::FunctionPassManager *FPM;\n#else\nstatic FunctionPassManager *FPM;\n#endif\n\n#ifdef LLVM37\n// No DataLayout pass needed anymore.\n#elif LLVM35\nstatic DataLayoutPass *jl_data_layout;\n#else\nstatic DataLayout *jl_data_layout;\n#endif\n\n// for image reloading\nstatic bool imaging_mode = false;\n\n// types\nstatic Type *jl_value_llvmt;\nstatic Type *jl_pvalue_llvmt;\nstatic Type *jl_ppvalue_llvmt;\nstatic Type* jl_parray_llvmt;\nstatic FunctionType *jl_func_sig;\nstatic Type *jl_pfptr_llvmt;\n\nstatic IntegerType *T_int1;\nstatic IntegerType *T_int8;\nstatic IntegerType *T_int16;\nstatic IntegerType *T_int32;\nstatic IntegerType *T_int64;\n\nstatic IntegerType *T_uint8;\nstatic IntegerType *T_uint16;\nstatic IntegerType *T_uint32;\nstatic IntegerType *T_uint64;\n\nstatic IntegerType *T_char;\nstatic IntegerType *T_size;\n\nstatic Type *T_float16;\nstatic Type *T_float32;\nstatic Type *T_float64;\nstatic Type *T_float128;\n\nstatic Type *T_pint8;\nstatic Type *T_pint16;\nstatic Type *T_pint32;\nstatic Type *T_pint64;\nstatic Type *T_psize;\nstatic Type *T_pfloat32;\nstatic Type *T_pfloat64;\n\nstatic Type *T_void;\n\n// type-based alias analysis nodes.  Indentation of comments indicates hierarchy.\nstatic MDNode* tbaa_user;           // User data that is mutable\nstatic MDNode* tbaa_immut;          // User data inside a heap-allocated immutable\nstatic MDNode* tbaa_value;          // Julia value\nstatic MDNode* tbaa_array;              // Julia array\nstatic MDNode* tbaa_arrayptr;               // The pointer inside a jl_array_t\nstatic MDNode* tbaa_arraysize;              // A size in a jl_array_t\nstatic MDNode* tbaa_arraylen;               // The len in a jl_array_t\nstatic MDNode* tbaa_sveclen;           // The len in a jl_svec_t\nstatic MDNode* tbaa_func;           // A jl_function_t\nstatic MDNode* tbaa_datatype;       // A jl_datatype_t\nstatic MDNode* tbaa_const;          // Memory that is immutable by the time LLVM can see it\n\nnamespace llvm {\n    extern Pass *createLowerSimdLoopPass();\n    extern bool annotateSimdLoop( BasicBlock* latch );\n}\n\n// Basic DITypes\n#ifdef LLVM37\nstatic DICompositeType *jl_value_dillvmt;\nstatic DIDerivedType *jl_pvalue_dillvmt;\nstatic DIDerivedType *jl_ppvalue_dillvmt;\nstatic DISubroutineType *jl_di_func_sig;\n#else\nstatic DICompositeType jl_value_dillvmt;\nstatic DIDerivedType jl_pvalue_dillvmt;\nstatic DIDerivedType jl_ppvalue_dillvmt;\n#ifdef LLVM36\nDISubroutineType jl_di_func_sig;\n#else\nDICompositeType jl_di_func_sig;\n#endif\n#endif\n\n// constants\nstatic Value *V_null;\n\n// global vars\nstatic GlobalVariable *jltrue_var;\nstatic GlobalVariable *jlfalse_var;\nstatic GlobalVariable *jlemptysvec_var;\nstatic GlobalVariable *jlemptytuple_var;\n#if defined(_CPU_X86_)\n#define JL_NEED_FLOATTEMP_VAR 1\n#endif\n#if JL_NEED_FLOATTEMP_VAR\nstatic GlobalVariable *jlfloattemp_var;\n#endif\nstatic GlobalVariable *jlpgcstack_var;\nstatic GlobalVariable *jlexc_var;\nstatic GlobalVariable *jldiverr_var;\nstatic GlobalVariable *jlundeferr_var;\nstatic GlobalVariable *jldomerr_var;\nstatic GlobalVariable *jlovferr_var;\nstatic GlobalVariable *jlinexacterr_var;\nstatic GlobalVariable *jlRTLD_DEFAULT_var;\n#ifdef _OS_WINDOWS_\nstatic GlobalVariable *jlexe_var;\nstatic GlobalVariable *jldll_var;\n#if defined(_CPU_X86_64_) && !defined(USE_MCJIT)\nextern JITMemoryManager* createJITMemoryManagerWin();\n#endif\n#endif //_OS_WINDOWS_\n#if defined(_OS_DARWIN_) && defined(LLVM37) && defined(LLVM_SHLIB)\n#define CUSTOM_MEMORY_MANAGER 1\nextern RTDyldMemoryManager* createRTDyldMemoryManagerOSX();\n#endif\n\n// important functions\nstatic Function *jlnew_func;\nstatic Function *jlthrow_func;\nstatic Function *jlerror_func;\nstatic Function *jltypeerror_func;\nstatic Function *jlundefvarerror_func;\nstatic Function *jlboundserror_func;\nstatic Function *jluboundserror_func;\nstatic Function *jlvboundserror_func;\nstatic Function *jlboundserrorv_func;\nstatic Function *jlcheckassign_func;\nstatic Function *jldeclareconst_func;\nstatic Function *jlgetbindingorerror_func;\nstatic Function *jltopeval_func;\nstatic Function *jlcopyast_func;\nstatic Function *jltuple_func;\nstatic Function *jlnsvec_func;\nstatic Function *jlapplygeneric_func;\nstatic Function *jlgetfield_func;\nstatic Function *jlbox_func;\nstatic Function *jlclosure_func;\nstatic Function *jlmethod_func;\nstatic Function *jlgenericfunction_func;\nstatic Function *jlenter_func;\nstatic Function *jlleave_func;\nstatic Function *jlegal_func;\nstatic Function *jlallocobj_func;\nstatic Function *jlalloc1w_func;\nstatic Function *jlalloc2w_func;\nstatic Function *jlalloc3w_func;\nstatic Function *jl_alloc_svec_func;\nstatic Function *jlsubtype_func;\nstatic Function *setjmp_func;\nstatic Function *memcmp_func;\nstatic Function *box_int8_func;\nstatic Function *box_uint8_func;\nstatic Function *box_int16_func;\nstatic Function *box_uint16_func;\nstatic Function *box_int32_func;\nstatic Function *box_char_func;\nstatic Function *box_uint32_func;\nstatic Function *box_int64_func;\nstatic Function *box_uint64_func;\nstatic Function *box_float32_func;\nstatic Function *box_float64_func;\nstatic Function *box_gensym_func;\nstatic Function *box8_func;\nstatic Function *box16_func;\nstatic Function *box32_func;\nstatic Function *box64_func;\nstatic Function *wbfunc;\nstatic Function *queuerootfun;\nstatic Function *expect_func;\nstatic Function *jldlsym_func;\nstatic Function *jlnewbits_func;\n//static Function *jlgetnthfield_func;\nstatic Function *jlgetnthfieldchecked_func;\n//static Function *jlsetnthfield_func;\n#ifdef _OS_WINDOWS_\nstatic Function *resetstkoflw_func;\n#endif\nstatic Function *diff_gc_total_bytes_func;\nstatic Function *jlarray_data_owner_func;\n\nstatic std::vector<Type *> two_pvalue_llvmt;\nstatic std::vector<Type *> three_pvalue_llvmt;\n\nstatic std::map<jl_fptr_t, Function*> builtin_func_map;\n\nextern \"C\" DLLEXPORT void jl_gc_wb_slow(jl_value_t* parent, jl_value_t* ptr)\n{\n    jl_gc_wb(parent, ptr);\n}\n\n// --- code generation ---\n\n// per-local-variable information\nstruct jl_varinfo_t {\n    Value *memvalue;  // an address, if the var is alloca'd\n    Value *SAvalue;   // register, if the var is SSA\n    Value *passedAs;  // if an argument, the original passed value\n#ifdef LLVM37\n    DILocalVariable *dinfo;\n#else\n    DIVariable dinfo;\n#endif\n    int closureidx;   // index in closure env, or -1\n    bool isAssigned;\n    bool isCaptured;\n    bool isSA;\n    bool isVolatile;\n    bool isArgument;\n    bool isGhost;     // Has size 0 and is thus never actually allocated\n    bool hasGCRoot;\n    bool escapes;\n    bool usedUndef;\n    bool used;\n    jl_value_t *declType;\n\n    jl_varinfo_t() : memvalue(NULL), SAvalue(NULL), passedAs(NULL),\n#ifdef LLVM37\n                     dinfo(NULL),\n#else\n                     dinfo(DIVariable()),\n#endif\n                     closureidx(-1), isAssigned(true), isCaptured(false), isSA(false),\n                     isVolatile(false), isArgument(false), isGhost(false), hasGCRoot(false),\n                     escapes(true), usedUndef(false), used(false),\n                     declType((jl_value_t*)jl_any_type)\n    {\n    }\n};\n\n// --- helpers for reloading IR image\nstatic void jl_dump_shadow(char *fname, int jit_model, const char *sysimg_data, size_t sysimg_len, bool dump_as_bc);\n\nextern \"C\"\nvoid jl_dump_bitcode(char *fname, const char *sysimg_data, size_t sysimg_len)\n{\n    jl_dump_shadow(fname, 0, sysimg_data, sysimg_len, true);\n}\n\nextern \"C\"\nvoid jl_dump_objfile(char *fname, int jit_model, const char *sysimg_data, size_t sysimg_len)\n{\n    jl_dump_shadow(fname, jit_model, sysimg_data, sysimg_len, false);\n}\n\n\n// aggregate of array metadata\ntypedef struct {\n    Value *dataptr;\n    Value *len;\n    std::vector<Value*> sizes;\n    jl_value_t *ty;\n} jl_arrayvar_t;\n\nstruct jl_gcinfo_t {\n    AllocaInst *gcframe;\n    Value *argSlot;\n    GetElementPtrInst *tempSlot;\n    int argDepth;\n    int maxDepth;\n    int argSpaceSize;\n    BasicBlock::iterator first_gcframe_inst;\n    BasicBlock::iterator last_gcframe_inst;\n};\n\n// information about the context of a piece of code: its enclosing\n// function and module, and visible local variables and labels.\ntypedef struct {\n    Function *f;\n    // local var info. globals are not in here.\n    // NOTE: you must be careful not to access vars[s] before you are sure \"s\" is\n    // a local, since otherwise this will add it to the map.\n    std::map<jl_sym_t*, jl_varinfo_t> vars;\n    std::vector<Value*> gensym_SAvalues;\n    std::vector<bool> gensym_assigned;\n    std::map<jl_sym_t*, jl_arrayvar_t> *arrayvars;\n    std::map<int, BasicBlock*> *labels;\n    std::map<int, Value*> *handlers;\n    jl_module_t *module;\n    jl_expr_t *ast;\n    jl_svec_t *sp;\n    jl_lambda_info_t *linfo;\n    Value *envArg;\n    Value *argArray;\n    Value *argCount;\n    std::string funcName;\n    jl_sym_t *vaName;  // name of vararg argument\n    bool vaStack;      // varargs stack-allocated\n    bool sret;\n    int nReqArgs;\n    std::vector<bool> boundsCheck;\n\n    jl_gcinfo_t gc;\n\n    llvm::DIBuilder *dbuilder;\n    bool debug_enabled;\n    std::vector<CallInst*> to_inline;\n} jl_codectx_t;\n\ntypedef struct {\n    size_t len;\n    struct {\n        int64_t isref;\n        Function *f;\n    } data[];\n} cFunctionList_t;\n\nstatic Value *emit_expr(jl_value_t *expr, jl_codectx_t *ctx, bool boxed=true, bool valuepos=true);\nstatic Value *emit_unboxed(jl_value_t *e, jl_codectx_t *ctx);\nstatic int is_global(jl_sym_t *s, jl_codectx_t *ctx);\n\nstatic Value *make_gcroot(Value *v, jl_codectx_t *ctx);\nstatic Value *emit_boxed_rooted(jl_value_t *e, jl_codectx_t *ctx);\nstatic Value *global_binding_pointer(jl_module_t *m, jl_sym_t *s,\n                                     jl_binding_t **pbnd, bool assign, jl_codectx_t *ctx);\nstatic Value *emit_checked_var(Value *bp, jl_sym_t *name, jl_codectx_t *ctx, bool isvol=false);\nstatic bool might_need_root(jl_value_t *ex);\nstatic Value *emit_condition(jl_value_t *cond, const std::string &msg, jl_codectx_t *ctx);\nstatic void allocate_gc_frame(size_t n_roots, BasicBlock *b0, jl_codectx_t *ctx);\nstatic void finalize_gc_frame(jl_codectx_t *ctx);\n\n// NoopType\nstatic Type *NoopType;\n\n// --- utilities ---\n\nextern \"C\" {\n    int globalUnique = 0;\n}\n\nextern \"C\" DLLEXPORT\njl_value_t *jl_get_cpu_name(void)\n{\n#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR < 5\n    std::string HostCPUName = llvm::sys::getHostCPUName();\n#else\n    StringRef HostCPUName = llvm::sys::getHostCPUName();\n#endif\n    return jl_pchar_to_string(HostCPUName.data(), HostCPUName.size());\n}\n\nstatic void emit_write_barrier(jl_codectx_t*,Value*,Value*);\n\n#include \"cgutils.cpp\"\n\nstatic void jl_rethrow_with_add(const char *fmt, ...)\n{\n    if (jl_typeis(jl_exception_in_transit, jl_errorexception_type)) {\n        char *str = jl_string_data(jl_fieldref(jl_exception_in_transit,0));\n        char buf[1024];\n        va_list args;\n        va_start(args, fmt);\n        int nc = vsnprintf(buf, sizeof(buf), fmt, args);\n        va_end(args);\n        nc += snprintf(buf+nc, sizeof(buf)-nc, \": %s\", str);\n        jl_value_t *msg = jl_pchar_to_string(buf, nc);\n        JL_GC_PUSH1(&msg);\n        jl_throw(jl_new_struct(jl_errorexception_type, msg));\n    }\n    jl_rethrow();\n}\n\n// --- allocating local variables ---\n\nstatic bool isbits_spec(jl_value_t *jt, bool allow_unsized = true)\n{\n    return jl_isbits(jt) && jl_is_leaf_type(jt) && (allow_unsized ||\n        ((jl_is_bitstype(jt) && jl_datatype_size(jt) > 0) ||\n         (jl_is_datatype(jt) && jl_datatype_nfields(jt)>0)));\n}\n\nstatic bool store_unboxed_p(jl_value_t *jt)\n{\n    return (isbits_spec(jt,false) &&\n        // don't unbox intrinsics, since inference depends on their having\n        // stable addresses for table lookup.\n        jt != (jl_value_t*)jl_intrinsic_type);\n}\n\nstatic bool store_unboxed_p(jl_sym_t *s, jl_codectx_t *ctx)\n{\n    jl_varinfo_t &vi = ctx->vars[s];\n    // only store a variable unboxed if type inference has run, which\n    // checks that the variable is not referenced undefined.\n    return (ctx->linfo->inferred && !vi.isCaptured && !vi.usedUndef &&\n            // don't unbox vararg tuples\n            s != ctx->vaName && store_unboxed_p(vi.declType));\n}\n\nstatic Value *alloc_local(jl_sym_t *s, jl_codectx_t *ctx)\n{\n    jl_varinfo_t &vi = ctx->vars[s];\n    jl_value_t *jt = vi.declType;\n    Value *lv = NULL;\n    assert(store_unboxed_p(s,ctx));\n    Type *vtype = julia_struct_to_llvm(jt);\n    assert(vtype != jl_pvalue_llvmt);\n    if (!type_is_ghost(vtype)) {\n        // CreateAlloca is OK here because alloc_local is only called during prologue setup\n        lv = builder.CreateAlloca(vtype, 0, s->name);\n        if (vtype != jl_pvalue_llvmt)\n            lv = mark_julia_type(lv, jt);\n        vi.isGhost = false;\n        assert(lv != NULL);\n    }\n    else {\n        vi.isGhost = true;\n    }\n    vi.memvalue = lv;\n#ifdef LLVM36\n    if (!vi.isGhost && ctx->debug_enabled) {\n#ifdef LLVM37\n        ctx->dbuilder->insertDeclare(lv,vi.dinfo,ctx->dbuilder->createExpression(),\n            builder.getCurrentDebugLocation().get(),builder.GetInsertBlock());\n#else\n        ctx->dbuilder->insertDeclare(lv,vi.dinfo,ctx->dbuilder->createExpression(),builder.GetInsertBlock());\n#endif\n    }\n#endif\n    return lv;\n}\n\nstatic void maybe_alloc_arrayvar(jl_sym_t *s, jl_codectx_t *ctx)\n{\n    jl_value_t *jt = ctx->vars[s].declType;\n    if (jl_is_array_type(jt) && jl_is_leaf_type(jt) && jl_is_long(jl_tparam1(jt)) &&\n        jl_unbox_long(jl_tparam1(jt)) != 1) {\n        // TODO: this optimization does not yet work with 1-d arrays, since the\n        // length and data pointer can change at any time via push!\n        // we could make it work by reloading the metadata when the array is\n        // passed to an external function (ideally only impure functions)\n        jl_arrayvar_t av;\n        int ndims = jl_unbox_long(jl_tparam1(jt));\n        Type *elt = julia_type_to_llvm(jl_tparam0(jt));\n        if (elt == T_void)\n            return;\n        // CreateAlloca is OK here because maybe_alloc_arrayvar is only called in the prologue setup\n        av.dataptr = builder.CreateAlloca(PointerType::get(elt,0));\n        av.len = builder.CreateAlloca(T_size);\n        for(int i=0; i < ndims-1; i++)\n            av.sizes.push_back(builder.CreateAlloca(T_size));\n        av.ty = jt;\n        (*ctx->arrayvars)[s] = av;\n    }\n}\n\n// --- entry point ---\n//static int n_emit=0;\nstatic Function *emit_function(jl_lambda_info_t *lam);\n//static int n_compile=0;\nstatic Function *to_function(jl_lambda_info_t *li)\n{\n    JL_SIGATOMIC_BEGIN();\n    assert(!li->inInference);\n    BasicBlock *old = nested_compile ? builder.GetInsertBlock() : NULL;\n    DebugLoc olddl = builder.getCurrentDebugLocation();\n    bool last_n_c = nested_compile;\n    nested_compile = true;\n    jl_gc_inhibit_finalizers(nested_compile);\n    Function *f = NULL;\n    JL_TRY {\n        f = emit_function(li);\n        //n_emit++;\n    }\n    JL_CATCH {\n        li->functionObject = NULL;\n        li->specFunctionObject = NULL;\n        li->cFunctionList = NULL;\n        nested_compile = last_n_c;\n        if (old != NULL) {\n            builder.SetInsertPoint(old);\n            builder.SetCurrentDebugLocation(olddl);\n        }\n        JL_SIGATOMIC_END();\n        jl_rethrow_with_add(\"error compiling %s\", li->name->name);\n    }\n    assert(f != NULL);\n#ifdef JL_DEBUG_BUILD\n#ifdef LLVM35\n    llvm::raw_fd_ostream out(1,false);\n#endif\n    if (\n#ifdef LLVM35\n        verifyFunction(*f,&out)\n#else\n        verifyFunction(*f,PrintMessageAction)\n#endif\n        ) {\n        f->dump();\n        abort();\n    }\n#endif\n    FPM->run(*f);\n    //n_compile++;\n    // print out the function's LLVM code\n    //jl_static_show(JL_STDERR, (jl_value_t*)li);\n    //jl_printf(JL_STDERR, \"%s:%d\\n\",\n    //           ((jl_sym_t*)li->file)->name, li->line);\n    //f->dump();\n    //if (verifyFunction(*f,PrintMessageAction)) {\n    //    f->dump();\n    //    abort();\n    //}\n    if (old != NULL) {\n        builder.SetInsertPoint(old);\n        builder.SetCurrentDebugLocation(olddl);\n    }\n    nested_compile = last_n_c;\n    jl_gc_inhibit_finalizers(nested_compile);\n    JL_SIGATOMIC_END();\n    return f;\n}\n\nstatic void jl_setup_module(Module *m, bool add)\n{\n    m->addModuleFlag(llvm::Module::Warning, \"Dwarf Version\",2);\n#ifdef LLVM34\n    m->addModuleFlag(llvm::Module::Error, \"Debug Info Version\",\n        llvm::DEBUG_METADATA_VERSION);\n#endif\n#ifdef LLVM37\n    if (jl_ExecutionEngine) {\n#ifdef LLVM38\n        m->setDataLayout(jl_ExecutionEngine->getDataLayout().getStringRepresentation());\n#else\n        m->setDataLayout(jl_ExecutionEngine->getDataLayout()->getStringRepresentation());\n#endif\n        m->setTargetTriple(jl_TargetMachine->getTargetTriple().str());\n    }\n#elif LLVM36\n    if (jl_ExecutionEngine)\n        m->setDataLayout(jl_ExecutionEngine->getDataLayout());\n#endif\n    if (add) {\n        assert(jl_ExecutionEngine);\n#ifdef LLVM36\n        jl_ExecutionEngine->addModule(std::unique_ptr<Module>(m));\n#else\n        jl_ExecutionEngine->addModule(m);\n#endif\n#if defined(_CPU_X86_64_) && defined(_OS_WINDOWS_) && defined(USE_MCJIT)\n        ArrayType *atype = ArrayType::get(T_uint32,3); // want 4-byte alignment of 12-bytes of data\n        (new GlobalVariable(*m, atype,\n            false, GlobalVariable::InternalLinkage,\n            ConstantAggregateZero::get(atype), \"__UnwindData\"))->setSection(\".text\");\n        (new GlobalVariable(*m, atype,\n            false, GlobalVariable::InternalLinkage,\n            ConstantAggregateZero::get(atype), \"__catchjmp\"))->setSection(\".text\");\n#endif\n    }\n}\n\nextern \"C\" void jl_generate_fptr(jl_function_t *f)\n{\n    // objective: assign li->fptr\n    jl_lambda_info_t *li = f->linfo;\n    assert(li->functionObject);\n    if (li->fptr == &jl_trampoline) {\n        JL_SIGATOMIC_BEGIN();\n        #ifdef USE_MCJIT\n        if (imaging_mode) {\n            // Copy the function out of the shadow module\n            Module *m = new Module(\"julia\", jl_LLVMContext);\n            jl_setup_module(m, true);\n            FunctionMover mover(m, shadow_module);\n            li->functionObject = mover.CloneFunction((Function*)li->functionObject);\n            if (li->specFunctionObject != NULL)\n                li->specFunctionObject = mover.CloneFunction((Function*)li->specFunctionObject);\n            if (li->cFunctionList != NULL) {\n                size_t i;\n                cFunctionList_t *list = (cFunctionList_t*)li->cFunctionList;\n                for (i = 0; i < list->len; i++) {\n                    list->data[i].f = mover.CloneFunction(list->data[i].f);\n                }\n            }\n        }\n        #endif\n\n        Function *llvmf = (Function*)li->functionObject;\n#ifdef USE_MCJIT\n        li->fptr = (jl_fptr_t)(intptr_t)jl_ExecutionEngine->getFunctionAddress(llvmf->getName());\n#else\n        li->fptr = (jl_fptr_t)jl_ExecutionEngine->getPointerToFunction(llvmf);\n#endif\n        assert(li->fptr != NULL);\n#ifndef KEEP_BODIES\n        if (!imaging_mode)\n            llvmf->deleteBody();\n#endif\n\n        if (li->cFunctionList != NULL) {\n            size_t i;\n            cFunctionList_t *list = (cFunctionList_t*)li->cFunctionList;\n            for (i = 0; i < list->len; i++) {\n#ifdef USE_MCJIT\n                (void)jl_ExecutionEngine->getFunctionAddress(list->data[i].f->getName());\n#else\n                (void)jl_ExecutionEngine->getPointerToFunction(list->data[i].f);\n#endif\n#ifndef KEEP_BODIES\n                if (!imaging_mode) {\n                    list->data[i].f->deleteBody();\n                }\n#endif\n            }\n        }\n\n        if (li->specFunctionObject != NULL) {\n#ifdef USE_MCJIT\n            (void)jl_ExecutionEngine->getFunctionAddress(((Function*)li->specFunctionObject)->getName());\n#else\n            (void)jl_ExecutionEngine->getPointerToFunction((Function*)li->specFunctionObject);\n#endif\n#ifndef KEEP_BODIES\n            if (!imaging_mode)\n                ((Function*)li->specFunctionObject)->deleteBody();\n#endif\n        }\n        JL_SIGATOMIC_END();\n    }\n    f->fptr = li->fptr;\n}\n\nextern \"C\" void jl_compile(jl_function_t *f)\n{\n    jl_lambda_info_t *li = f->linfo;\n    if (li->functionObject == NULL) {\n        // objective: assign li->functionObject\n        li->inCompile = 1;\n        (void)to_function(li);\n        li->inCompile = 0;\n    }\n}\n\n// Get the LLVM Function* for the C-callable entry point for a certain function\n// and argument types. If rt is NULL then whatever return type is present is\n// accepted.\nstatic Function *gen_cfun_wrapper(jl_function_t *ff, jl_value_t *jlrettype, jl_tupletype_t *argt, int64_t isref);\nstatic Function *jl_cfunction_object(jl_function_t *f, jl_value_t *rt, jl_tupletype_t *argt)\n{\n    if (rt) {\n        JL_TYPECHK(cfunction, type, rt);\n    }\n    JL_TYPECHK(cfunction, type, (jl_value_t*)argt);\n    JL_TYPECHK(cfunction, function, (jl_value_t*)f);\n    if (!jl_is_gf(f))\n        jl_error(\"only generic functions are currently c-callable\");\n\n    size_t i, nargs = jl_nparams(argt);\n    if (nargs >= 64)\n        jl_error(\"only functions with less than 64 arguments are c-callable\");\n\n    uint64_t isref = 0; // bit vector of which argument types are a subtype of Type{Ref{T}}\n    jl_value_t *sigt = NULL; // type signature with Ref{} annotations removed\n    JL_GC_PUSH1(&sigt);\n    sigt = (jl_value_t*)jl_alloc_svec(nargs);\n    for (i = 0; i < nargs; i++) {\n        jl_value_t *ati = jl_tparam(argt, i);\n        if (jl_is_abstract_ref_type(ati)) {\n            ati = jl_tparam0(ati);\n            if (jl_is_typevar(ati))\n                jl_error(\"cfunction: argument type Ref should have an element type, not Ref{T}\");\n            isref |= (2<<i);\n        }\n        else if (ati != (jl_value_t*)jl_any_type && !jl_is_leaf_type(ati)) {\n            jl_error(\"cfunction: type signature must only contain leaf types\");\n        }\n        jl_svecset(sigt, i, ati);\n    }\n    sigt = (jl_value_t*)jl_apply_tuple_type((jl_svec_t*)sigt);\n\n    if (rt != NULL) {\n        if (jl_is_abstract_ref_type(rt)) {\n            rt = jl_tparam0(rt);\n            if (jl_is_typevar(rt))\n                jl_error(\"cfunction: return type Ref should have an element type, not Ref{T}\");\n            if (rt == (jl_value_t*)jl_any_type)\n                jl_error(\"cfunction: return type Ref{Any} is invalid. Use Any or Ptr{Any} instead.\");\n            isref |= 1;\n        }\n        else if (!jl_is_leaf_type(rt)) {\n            isref |= 1;\n        }\n    }\n\n    jl_function_t *ff = jl_get_specialization(f, (jl_tupletype_t*)sigt);\n    if (ff != NULL && ff->env==(jl_value_t*)jl_emptysvec && ff->linfo != NULL) {\n        jl_lambda_info_t *li = ff->linfo;\n        if (!jl_types_equal((jl_value_t*)li->specTypes, sigt)) {\n            jl_errorf(\"cfunction: type signature of %s does not match specification\",\n                      li->name->name);\n        }\n        jl_value_t *astrt = jl_ast_rettype(li, li->ast);\n        if (rt != NULL) {\n            if (astrt == (jl_value_t*)jl_bottom_type) {\n                if (rt != (jl_value_t*)jl_void_type) {\n                    // a function that doesn't return can be passed to C as void\n                    jl_errorf(\"cfunction: %s does not return\", li->name->name);\n                }\n            }\n            else if (!jl_subtype(astrt, rt, 0)) {\n                jl_errorf(\"cfunction: return type of %s does not match\",\n                          li->name->name);\n            }\n        }\n        JL_GC_POP(); // kill list: sigt\n        return gen_cfun_wrapper(ff, astrt, argt, isref);\n    }\n    jl_error(\"cfunction: no method exactly matched the required type signature (function not yet c-callable)\");\n}\n\n// get the address of a C-callable entry point for a function\nextern \"C\" DLLEXPORT\nvoid *jl_function_ptr(jl_function_t *f, jl_value_t *rt, jl_value_t *argt)\n{\n    JL_GC_PUSH1(&argt);\n    if (jl_is_tuple(argt)) {\n        // TODO: maybe deprecation warning, better checking\n        argt = (jl_value_t*)jl_apply_tuple_type_v((jl_value_t**)jl_data_ptr(argt), jl_nfields(argt));\n    }\n    assert(jl_is_tuple_type(argt));\n    Function *llvmf = jl_cfunction_object(f, rt, (jl_tupletype_t*)argt);\n    assert(llvmf);\n    JL_GC_POP();\n#ifdef USE_MCJIT\n    return (void*)(intptr_t)jl_ExecutionEngine->getFunctionAddress(llvmf->getName());\n#else\n    return jl_ExecutionEngine->getPointerToFunction(llvmf);\n#endif\n}\n\n\nextern \"C\" DLLEXPORT\nvoid *jl_function_ptr_by_llvm_name(char* name) {\n#ifdef __has_feature\n#if __has_feature(memory_sanitizer)\n    __msan_unpoison_string(name);\n#endif\n#endif\n    return (void*)(intptr_t)jl_ExecutionEngine->FindFunctionNamed(name);\n}\n\n// export a C-callable entry point for a function, with a given name\nextern \"C\" DLLEXPORT\nvoid jl_extern_c(jl_function_t *f, jl_value_t *rt, jl_value_t *argt, char *name)\n{\n    assert(jl_is_tuple_type(argt));\n    Function *llvmf = jl_cfunction_object(f, rt, (jl_tupletype_t*)argt);\n    if (llvmf) {\n        #ifndef LLVM35\n        new GlobalAlias(llvmf->getType(), GlobalValue::ExternalLinkage, name, llvmf, llvmf->getParent());\n        #elif defined(LLVM37) && !defined(LLVM38)\n        GlobalAlias::create(cast<PointerType>(llvmf->getType()),\n                            GlobalValue::ExternalLinkage, name, llvmf, llvmf->getParent());\n        #else\n        GlobalAlias::create(llvmf->getType()->getElementType(), llvmf->getType()->getAddressSpace(),\n                            GlobalValue::ExternalLinkage, name, llvmf, llvmf->getParent());\n        #endif\n    }\n}\n\n// --- native code info, and dump function to IR and ASM ---\nextern void RegisterJuliaJITEventListener();\n\nextern int jl_get_llvmf_info(uint64_t fptr, uint64_t *symsize, uint64_t *slide,\n#ifdef USE_MCJIT\n    const object::ObjectFile **object\n#else\n    std::vector<JITEvent_EmittedFunctionDetails::LineStart> *lines\n#endif\n    );\n\n\n// Get pointer to llvm::Function instance, compiling if necessary\nextern \"C\" DLLEXPORT\nvoid *jl_get_llvmf(jl_function_t *f, jl_tupletype_t *tt, bool getwrapper)\n{\n    jl_function_t *sf = f;\n    if (tt != NULL) {\n        if (!jl_is_function(f) || !jl_is_gf(f)) {\n            return NULL;\n        }\n        sf = jl_get_specialization(f, tt);\n    }\n    if (sf == NULL || sf->linfo == NULL) {\n        sf = jl_method_lookup_by_type(jl_gf_mtable(f), tt, 0, 0);\n        if (sf == jl_bottom_func) {\n            return NULL;\n        }\n        jl_printf(JL_STDERR,\n                  \"WARNING: Returned code may not match what actually runs.\\n\");\n    }\n    if (sf->linfo->specFunctionObject != NULL) {\n        // found in the system image: force a recompile\n        Function *llvmf = (Function*)sf->linfo->specFunctionObject;\n        if (llvmf->isDeclaration()) {\n            sf->linfo->specFunctionObject = NULL;\n            sf->linfo->functionObject = NULL;\n        }\n    }\n    if (sf->linfo->functionObject != NULL) {\n        // found in the system image: force a recompile\n        Function *llvmf = (Function*)sf->linfo->functionObject;\n        if (llvmf->isDeclaration()) {\n            sf->linfo->specFunctionObject = NULL;\n            sf->linfo->functionObject = NULL;\n        }\n    }\n    if (sf->linfo->functionObject == NULL && sf->linfo->specFunctionObject == NULL) {\n        jl_compile(sf);\n    }\n    if (!getwrapper && sf->linfo->specFunctionObject != NULL)\n        return (Function*)sf->linfo->specFunctionObject;\n    else\n        return (Function*)sf->linfo->functionObject;\n}\n\nFunction* CloneFunctionToModule(Function *F, Module *destModule)\n{\n    ValueToValueMapTy VMap;\n    Function *NewF = Function::Create(F->getFunctionType(),\n                                      Function::ExternalLinkage,\n                                      F->getName(),\n                                      destModule);\n    VMap[F] = NewF;\n\n    Function::arg_iterator DestI = NewF->arg_begin();\n    for (Function::const_arg_iterator I = F->arg_begin(), E = F->arg_end(); I != E; ++I) {\n        DestI->setName(I->getName());    // Copy the name over...\n        VMap[&*I] = &*DestI++;        // Add mapping to VMap\n    }\n\n    SmallVector<ReturnInst*, 8> Returns;\n    llvm::CloneFunctionInto(NewF, F, VMap, true, Returns, \"\", NULL, NULL);\n    return NewF;\n}\n\nextern \"C\" DLLEXPORT\nconst jl_value_t *jl_dump_function_ir(void *f, bool strip_ir_metadata, bool dump_module)\n{\n    std::string code;\n    llvm::raw_string_ostream stream(code);\n\n    Function *llvmf = dyn_cast<Function>((Function*)f);\n    if (!llvmf)\n        jl_error(\"jl_dump_function_ir: Expected Function*\");\n\n    if (llvmf->isDeclaration()) {\n        // print the function declaration plain\n        llvmf->print(stream);\n    }\n    else {\n        // make a copy of the function with all module metadata\n        Module *m = new Module(llvmf->getName(), jl_LLVMContext);\n        jl_setup_module(m, false);\n        Function *f2 = CloneFunctionToModule(llvmf, m);\n        if (strip_ir_metadata) {\n            // strip metadata from the copy\n            Function::BasicBlockListType::iterator f2_bb = f2->getBasicBlockList().begin();\n            // iterate over all basic blocks in the function\n            for (; f2_bb != f2->getBasicBlockList().end(); ++f2_bb) {\n                BasicBlock::InstListType::iterator f2_il = (*f2_bb).getInstList().begin();\n                // iterate over instructions in basic block\n                for (; f2_il != (*f2_bb).getInstList().end(); ) {\n                    Instruction *inst = &*f2_il++;\n                    // remove dbg.declare and dbg.value calls\n                    if (isa<DbgDeclareInst>(inst) || isa<DbgValueInst>(inst)) {\n                        inst->eraseFromParent();\n                        continue;\n                    }\n\n                    SmallVector<std::pair<unsigned, MDNode*>, 4> MDForInst;\n                    inst->getAllMetadata(MDForInst);\n                    SmallVector<std::pair<unsigned, MDNode*>, 4>::iterator md_iter = MDForInst.begin();\n\n                    // iterate over all metadata kinds and set to NULL to remove\n                    for (; md_iter != MDForInst.end(); ++md_iter) {\n                        inst->setMetadata((*md_iter).first, NULL);\n                    }\n                }\n            }\n        }\n        if (dump_module)\n            m->print(stream, NULL);\n        else\n            f2->print(stream);\n        f2->eraseFromParent();\n        delete m;\n    }\n\n    return jl_cstr_to_string(const_cast<char*>(stream.str().c_str()));\n}\n\n// Pre-declaration. Definition in disasm.cpp\nextern \"C\"\nvoid jl_dump_asm_internal(uintptr_t Fptr, size_t Fsize, size_t slide,\n#ifdef USE_MCJIT\n                          const object::ObjectFile *objectfile,\n#else\n                          std::vector<JITEvent_EmittedFunctionDetails::LineStart> lineinfo,\n#endif\n                          formatted_raw_ostream &stream);\n\nextern \"C\" DLLEXPORT\nconst jl_value_t *jl_dump_function_asm(void *f)\n{\n    std::string code;\n    llvm::raw_string_ostream stream(code);\n    llvm::formatted_raw_ostream fstream(stream);\n\n    Function *llvmf = dyn_cast<Function>((Function*)f);\n    if (!llvmf)\n        jl_error(\"jl_dump_function_asm: Expected Function*\");\n\n    // Dump assembly code\n    uint64_t symsize, slide;\n#ifdef USE_MCJIT\n    uint64_t fptr = jl_ExecutionEngine->getFunctionAddress(llvmf->getName());\n    const object::ObjectFile *object;\n#else\n    uint64_t fptr = (uintptr_t)jl_ExecutionEngine->getPointerToFunction(llvmf);\n    std::vector<JITEvent_EmittedFunctionDetails::LineStart> object;\n#endif\n    assert(fptr != 0);\n    if (jl_get_llvmf_info(fptr, &symsize, &slide, &object)) {\n        jl_dump_asm_internal(fptr, symsize, slide, object, fstream);\n    }\n    else {\n        jl_printf(JL_STDERR, \"WARNING: Unable to find function pointer\\n\");\n    }\n    fstream.flush();\n\n    return jl_cstr_to_string(const_cast<char*>(stream.str().c_str()));\n}\n\n// Code coverage\n\ntypedef std::map<std::string,std::vector<GlobalVariable*> > logdata_t;\nstatic logdata_t coverageData;\n\nstatic void coverageVisitLine(std::string filename, int line)\n{\n    if (filename == \"\" || filename == \"none\" || filename == \"no file\")\n        return;\n    logdata_t::iterator it = coverageData.find(filename);\n    if (it == coverageData.end()) {\n        coverageData[filename] = std::vector<GlobalVariable*>(0);\n    }\n    std::vector<GlobalVariable*> &vec = coverageData[filename];\n    if (vec.size() <= (size_t)line)\n        vec.resize(line+1, NULL);\n    if (vec[line] == NULL) {\n        vec[line] = addComdat(new GlobalVariable(*jl_Module, T_int64, false,\n                                                 GlobalVariable::InternalLinkage,\n                                                 ConstantInt::get(T_int64,0), \"lcnt\"));\n    }\n    GlobalVariable *v = prepare_global(vec[line]);\n    builder.CreateStore(builder.CreateAdd(builder.CreateLoad(v),\n                                          ConstantInt::get(T_int64,1)),\n                        v);\n}\n\nextern \"C\" int isabspath(const char *in);\n\nvoid write_log_data(logdata_t logData, const char *extension)\n{\n    std::string base = std::string(jl_options.julia_home);\n    base = base + \"/../share/julia/base/\";\n    logdata_t::iterator it = logData.begin();\n    for (; it != logData.end(); it++) {\n        std::string filename = (*it).first;\n        std::vector<GlobalVariable*> &values = (*it).second;\n        if (values.size() > 1) {\n            if (!isabspath(filename.c_str()))\n                filename = base + filename;\n            std::ifstream inf(filename.c_str());\n            if (inf.is_open()) {\n                std::string outfile = filename + extension;\n                std::ofstream outf(outfile.c_str(), std::ofstream::trunc | std::ofstream::out);\n                char line[1024];\n                int l = 1;\n                while (!inf.eof()) {\n                    inf.getline(line, sizeof(line));\n                    if (inf.fail() && !inf.bad()) {\n                        // Read through lines longer than sizeof(line)\n                        inf.clear();\n                        inf.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n                    }\n                    int value = -1;\n                    if ((size_t)l < values.size()) {\n                        GlobalVariable *gv = values[l];\n                        if (gv) {\n#ifdef USE_MCJIT\n                            int *p = (int*)(intptr_t)jl_ExecutionEngine->getGlobalValueAddress(gv->getName());\n#else\n                            int *p = (int*)jl_ExecutionEngine->getPointerToGlobal(gv);\n#endif\n                            value = *p;\n                        }\n                    }\n                    outf.width(9);\n                    if (value == -1)\n                        outf<<'-';\n                    else\n                        outf<<value;\n                    outf.width(0);\n                    outf<<\" \"<<line<<std::endl;\n                    l++;\n                }\n                outf.close();\n                inf.close();\n            }\n        }\n    }\n}\n\nextern \"C\" int jl_getpid();\nextern \"C\" void jl_write_coverage_data(void)\n{\n    std::ostringstream stm;\n    stm << jl_getpid();\n    std::string outf = \".\" + stm.str() + \".cov\";\n    write_log_data(coverageData, outf.c_str());\n}\n\n// Memory allocation log (malloc_log)\n\nstatic logdata_t mallocData;\n\nstatic void mallocVisitLine(std::string filename, int line)\n{\n    if (filename == \"\" || filename == \"none\" || filename == \"no file\") {\n        jl_gc_sync_total_bytes();\n        return;\n    }\n    logdata_t::iterator it = mallocData.find(filename);\n    if (it == mallocData.end()) {\n        mallocData[filename] = std::vector<GlobalVariable*>(0);\n    }\n    std::vector<GlobalVariable*> &vec = mallocData[filename];\n    if (vec.size() <= (size_t)line)\n        vec.resize(line+1, NULL);\n    if (vec[line] == NULL) {\n        vec[line] = addComdat(new GlobalVariable(*jl_Module, T_int64, false,\n                                                 GlobalVariable::InternalLinkage,\n                                                 ConstantInt::get(T_int64,0), \"bytecnt\"));\n    }\n    GlobalVariable *v = prepare_global(vec[line]);\n    builder.CreateStore(builder.CreateAdd(builder.CreateLoad(v, true),\n                                          builder.CreateCall(prepare_call(diff_gc_total_bytes_func)\n#ifdef LLVM37\n                                            , {}\n#endif\n                                            )),\n                        v, true);\n}\n\n// Resets the malloc counts. Needed to avoid including memory usage\n// from JITting.\nextern \"C\" DLLEXPORT void jl_clear_malloc_data(void)\n{\n    logdata_t::iterator it = mallocData.begin();\n    for (; it != mallocData.end(); it++) {\n        std::vector<GlobalVariable*> &bytes = (*it).second;\n        std::vector<GlobalVariable*>::iterator itb;\n        for (itb = bytes.begin(); itb != bytes.end(); itb++) {\n            if (*itb) {\n#ifdef USE_MCJIT\n                int *p = (int*)(intptr_t)jl_ExecutionEngine->getGlobalValueAddress((*itb)->getName());\n#else\n                int *p = (int*)jl_ExecutionEngine->getPointerToGlobal(*itb);\n#endif\n                *p = 0;\n            }\n        }\n    }\n    jl_gc_sync_total_bytes();\n}\n\nextern \"C\" void jl_write_malloc_log(void)\n{\n    write_log_data(mallocData, \".mem\");\n}\n\n// --- code gen for intrinsic functions ---\n\n#include \"intrinsics.cpp\"\n\n// --- constant determination ---\n\nstatic void show_source_loc(JL_STREAM *out, jl_codectx_t *ctx)\n{\n    if (ctx == NULL) return;\n    jl_printf(out, \"in %s at %s\", ctx->linfo->name->name, ctx->linfo->file->name);\n}\n\nextern \"C\" void jl_binding_deprecation_warning(jl_binding_t *b);\n\nstatic void cg_bdw(jl_binding_t *b, jl_codectx_t *ctx)\n{\n    jl_binding_deprecation_warning(b);\n    if (jl_options.depwarn) {\n        show_source_loc(JL_STDERR, ctx);\n        jl_printf(JL_STDERR, \"\\n\");\n    }\n}\n\n// try to statically evaluate, NULL if not possible\nextern \"C\"\njl_value_t *jl_static_eval(jl_value_t *ex, void *ctx_, jl_module_t *mod,\n                           jl_value_t *sp, jl_expr_t *ast, int sparams, int allow_alloc)\n{\n    jl_codectx_t *ctx = (jl_codectx_t*)ctx_;\n    if (jl_is_symbolnode(ex))\n        ex = (jl_value_t*)jl_symbolnode_sym(ex);\n    if (jl_is_symbol(ex)) {\n        jl_sym_t *sym = (jl_sym_t*)ex;\n        bool isglob = true;\n        if (ctx) {\n            isglob = is_global(sym, ctx);\n        }\n        else if (ast) {\n            isglob = !jl_local_in_ast(ast, sym);\n        }\n        if (isglob) {\n            size_t i;\n            if (sparams) {\n                for(i=0; i < jl_svec_len(sp); i+=2) {\n                    if (sym == (jl_sym_t*)jl_svecref(sp, i)) {\n                        // static parameter\n                        return jl_svecref(sp, i+1);\n                    }\n                }\n            }\n            if (jl_is_const(mod, sym))\n                return jl_get_global(mod, sym);\n        }\n        return NULL;\n    }\n    if (jl_is_gensym(ex))\n        return NULL;\n    if (jl_is_topnode(ex)) {\n        jl_binding_t *b = jl_get_binding(jl_base_relative_to(mod),\n                                         (jl_sym_t*)jl_fieldref(ex,0));\n        if (b == NULL) return NULL;\n        if (b->constp)\n            return b->value;\n        return NULL;\n    }\n    if (jl_is_quotenode(ex))\n        return jl_fieldref(ex,0);\n    if (jl_is_lambda_info(ex))\n        return NULL;\n    jl_module_t *m = NULL;\n    jl_sym_t *s = NULL;\n    if (jl_is_globalref(ex)) {\n        s = (jl_sym_t*)jl_globalref_name(ex);\n        if (s && jl_is_symbol(s)) {\n            jl_binding_t *b = jl_get_binding(jl_globalref_mod(ex), s);\n            if (b && b->constp) {\n                if (b->deprecated) cg_bdw(b, ctx);\n                return b->value;\n            }\n        }\n        return NULL;\n    }\n    if (jl_is_expr(ex)) {\n        jl_expr_t *e = (jl_expr_t*)ex;\n        if (e->head == call_sym) {\n            jl_value_t *f = jl_static_eval(jl_exprarg(e,0),ctx,mod,sp,ast,sparams,allow_alloc);\n            if (f && jl_is_function(f)) {\n                jl_fptr_t fptr = ((jl_function_t*)f)->fptr;\n                if (jl_array_dim0(e->args) == 3 && fptr == &jl_f_get_field) {\n                    m = (jl_module_t*)jl_static_eval(jl_exprarg(e,1),ctx,mod,sp,ast,sparams,allow_alloc);\n                    s = (jl_sym_t*)jl_static_eval(jl_exprarg(e,2),ctx,mod,sp,ast,sparams,allow_alloc);\n                    if (m && jl_is_module(m) && s && jl_is_symbol(s)) {\n                        jl_binding_t *b = jl_get_binding(m, s);\n                        if (b && b->constp) {\n                            if (b->deprecated) cg_bdw(b, ctx);\n                            return b->value;\n                        }\n                    }\n                }\n                else if (fptr == &jl_f_tuple || fptr == &jl_f_instantiate_type) {\n                    size_t i;\n                    size_t n = jl_array_dim0(e->args)-1;\n                    if (n==0 && fptr == &jl_f_tuple) return (jl_value_t*)jl_emptytuple;\n                    if (!allow_alloc)\n                        return NULL;\n                    jl_value_t **v;\n                    JL_GC_PUSHARGS(v, n);\n                    for (i = 0; i < n; i++) {\n                        v[i] = jl_static_eval(jl_exprarg(e,i+1),ctx,mod,sp,ast,sparams,allow_alloc);\n                        if (v[i] == NULL) {\n                            JL_GC_POP();\n                            return NULL;\n                        }\n                    }\n                    jl_value_t *result;\n                    JL_TRY {\n                        result = fptr(f, v, n);\n                    }\n                    JL_CATCH {\n                        result = NULL;\n                    }\n                    JL_GC_POP();\n                    return result;\n                }\n            }\n        // The next part is probably valid, but it is untested\n        //} else if (e->head == tuple_sym) {\n        //  size_t i;\n        //  for (i = 0; i < jl_array_dim0(e->args); i++)\n        //        if (jl_static_eval(jl_exprarg(e,i),ctx,mod,sp,ast,sparams,allow_alloc) == NULL)\n        //          return NULL;\n        //  return ex;\n        }\n        return NULL;\n    }\n    return ex;\n}\n\nstatic jl_value_t *static_eval(jl_value_t *ex, jl_codectx_t *ctx, bool sparams,\n                               bool allow_alloc)\n{\n    return jl_static_eval(ex, ctx, ctx->module, (jl_value_t*)ctx->sp, ctx->ast,\n                          sparams, allow_alloc);\n}\n\nstatic bool is_constant(jl_value_t *ex, jl_codectx_t *ctx, bool sparams=true)\n{\n    return static_eval(ex,ctx,sparams) != NULL;\n}\n\nstatic bool symbol_eq(jl_value_t *e, jl_sym_t *sym)\n{\n    return ((jl_is_symbol(e) && ((jl_sym_t*)e)==sym) ||\n            (jl_is_symbolnode(e) && jl_symbolnode_sym(e)==sym));\n}\n\n// --- find volatile variables ---\n\n// assigned in a try block and used outside that try block\n\nstatic bool local_var_occurs(jl_value_t *e, jl_sym_t *s)\n{\n    if (jl_is_symbol(e) || jl_is_symbolnode(e)) {\n        if (symbol_eq(e, s))\n            return true;\n    }\n    else if (jl_is_expr(e)) {\n        jl_expr_t *ex = (jl_expr_t*)e;\n        size_t alength = jl_array_dim0(ex->args);\n        for(int i=0; i < (int)alength; i++) {\n            if (local_var_occurs(jl_exprarg(ex,i),s))\n                return true;\n        }\n    }\n    return false;\n}\n\nstatic std::set<jl_sym_t*> assigned_in_try(jl_array_t *stmts, int s, long l, int *pend)\n{\n    std::set<jl_sym_t*> av;\n    size_t slength = jl_array_dim0(stmts);\n    for(int i=s; i < (int)slength; i++) {\n        jl_value_t *st = jl_cellref(stmts,i);\n        if (jl_is_expr(st)) {\n            if (((jl_expr_t*)st)->head == assign_sym) {\n                jl_value_t *ar = jl_exprarg(st, 0);\n                if (jl_is_symbolnode(ar)) {\n                    ar = (jl_value_t*)jl_symbolnode_sym(ar);\n                }\n                if (jl_is_symbol(ar)) {\n                    av.insert((jl_sym_t*)ar);\n                }\n            }\n        }\n        if (jl_is_labelnode(st)) {\n            if (jl_labelnode_label(st) == l) {\n                *pend = i;\n                break;\n            }\n        }\n    }\n    return av;\n}\n\nstatic void mark_volatile_vars(jl_array_t *stmts, std::map<jl_sym_t*,jl_varinfo_t> &vars)\n{\n    size_t slength = jl_array_dim0(stmts);\n    for(int i=0; i < (int)slength; i++) {\n        jl_value_t *st = jl_cellref(stmts,i);\n        if (jl_is_expr(st)) {\n            if (((jl_expr_t*)st)->head == enter_sym) {\n                int last = (int)slength-1;\n                std::set<jl_sym_t*> as =\n                    assigned_in_try(stmts, i+1,\n                                    jl_unbox_long(jl_exprarg(st,0)), &last);\n                for(int j=0; j < (int)slength; j++) {\n                    if (j < i || j > last) {\n                        std::set<jl_sym_t*>::iterator it = as.begin();\n                        for(; it != as.end(); it++) {\n                            if (vars.find(*it) != vars.end() &&\n                                local_var_occurs(jl_cellref(stmts,j), *it)) {\n                                vars[*it].isVolatile = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n// --- escape analysis ---\n\nstatic bool expr_is_symbol(jl_value_t *e)\n{\n    return (jl_is_symbol(e) || jl_is_symbolnode(e) || jl_is_topnode(e) || jl_is_globalref(e));\n}\n\n// a very simple, conservative escape analysis that is sufficient for\n// eliding allocation of varargs tuples.\n// \"esc\" means \"in escaping context\"\nstatic void simple_escape_analysis(jl_value_t *expr, bool esc, jl_codectx_t *ctx)\n{\n    if (jl_is_expr(expr)) {\n        esc = true;\n        jl_expr_t *e = (jl_expr_t*)expr;\n        size_t i;\n        if (e->head == call_sym || e->head == new_sym) {\n            int alen = jl_array_dim0(e->args);\n            jl_value_t *f = jl_exprarg(e,0);\n            simple_escape_analysis(f, esc, ctx);\n            if (expr_is_symbol(f)) {\n                if (is_constant(f, ctx, false)) {\n                    jl_value_t *fv =\n                        jl_interpret_toplevel_expr_in(ctx->module, f, NULL, 0);\n                    if (jl_typeis(fv, jl_intrinsic_type)) {\n                        esc = false;\n                        JL_I::intrinsic fi = (JL_I::intrinsic)jl_unbox_int32(fv);\n                        if (fi == JL_I::ccall) {\n                            esc = true;\n                            simple_escape_analysis(jl_exprarg(e,1), esc, ctx);\n                            // 2nd and 3d arguments are static\n                            for(i=4; i < (size_t)alen; i+=2) {\n                                simple_escape_analysis(jl_exprarg(e,i), esc, ctx);\n                            }\n                            return;\n                        }\n                    }\n                    else if (jl_is_function(fv)) {\n                        jl_function_t *ff = (jl_function_t*)fv;\n                        if ((ff->fptr == jl_f_get_field && alen==3 &&\n                             expr_type(jl_exprarg(e,2),ctx) == (jl_value_t*)jl_long_type) ||\n                            ff->fptr == jl_f_nfields ||\n                            (ff->fptr == jl_f_apply && alen==4 &&\n                             expr_type(jl_exprarg(e,2),ctx) == (jl_value_t*)jl_function_type)) {\n                            esc = false;\n                        }\n                    }\n                }\n            }\n\n            for(i=1; i < (size_t)alen; i++) {\n                simple_escape_analysis(jl_exprarg(e,i), esc, ctx);\n            }\n        }\n        else if (e->head == method_sym) {\n            simple_escape_analysis(jl_exprarg(e,0), esc, ctx);\n            if (jl_expr_nargs(e) > 1) {\n                simple_escape_analysis(jl_exprarg(e,1), esc, ctx);\n                simple_escape_analysis(jl_exprarg(e,2), esc, ctx);\n            }\n        }\n        else if (e->head == assign_sym) {\n            // don't consider assignment LHS as a variable \"use\"\n            simple_escape_analysis(jl_exprarg(e,1), esc, ctx);\n        }\n        else if (e->head != line_sym) {\n            size_t elen = jl_array_dim0(e->args);\n            for(i=0; i < elen; i++) {\n                simple_escape_analysis(jl_exprarg(e,i), esc, ctx);\n            }\n        }\n        return;\n    }\n    if (jl_is_symbolnode(expr)) {\n        expr = (jl_value_t*)jl_symbolnode_sym(expr);\n    }\n    if (jl_is_symbol(expr)) {\n        jl_sym_t *vname = ((jl_sym_t*)expr);\n        if (ctx->vars.find(vname) != ctx->vars.end()) {\n            jl_varinfo_t &vi = ctx->vars[vname];\n            vi.escapes |= esc;\n            vi.used = true;\n        }\n    }\n}\n\n// --- gc root utils ---\n\n// ---- Get Element Pointer (GEP) instructions within the GC frame ----\n\n// Emit GEP for the @slot-th slot in the GC frame\nstatic Value*\nemit_local_slot(int slot, jl_codectx_t *ctx)\n{\n    Value *idx = ConstantInt::get(T_int32, slot);\n    return builder.CreateGEP(ctx->gc.argSlot, idx);\n}\n\n// Emit GEP for the @slot-th temporary variable in the GC frame.\n// The temporary variables are after all local variables in the GC frame.\nstatic Value*\nemit_temp_slot(int slot, jl_codectx_t *ctx)\n{\n    Value *idx = ConstantInt::get(T_int32, slot);\n    return builder.CreateGEP(ctx->gc.tempSlot, idx);\n}\n\nstatic Value *make_gcroot(Value *v, jl_codectx_t *ctx)\n{\n    Value *froot = emit_temp_slot(ctx->gc.argDepth, ctx);\n    builder.CreateStore(v, froot);\n    ctx->gc.argDepth++;\n    if (ctx->gc.argDepth > ctx->gc.maxDepth)\n        ctx->gc.maxDepth = ctx->gc.argDepth;\n    return froot;\n}\n\n// test whether getting a field from the given type using the given\n// field expression would not allocate memory\nstatic bool is_getfield_nonallocating(jl_datatype_t *ty, jl_value_t *fld)\n{\n    if (!jl_is_leaf_type((jl_value_t*)ty))\n        return false;\n    jl_sym_t *name = NULL;\n    if (jl_is_quotenode(fld) && jl_is_symbol(jl_fieldref(fld,0)))\n        name = (jl_sym_t*)jl_fieldref(fld,0);\n    int idx = -1;\n    if (name)\n        idx = jl_field_index(ty, name, 0);\n    else if (jl_is_long(fld))\n        idx = jl_unbox_long(fld)-1;\n    else if (jl_is_quotenode(fld) && jl_is_long(jl_fieldref(fld,0)))\n        idx = jl_unbox_long(jl_fieldref(fld,0))-1;\n    for(size_t i=0; i < jl_svec_len(ty->types); i++) {\n        if (!(jl_field_isptr(ty,i) || (idx >= 0 && (size_t)idx != i)))\n            return false;\n    }\n    return true;\n}\n\n// does \"ex\" compute something that doesn't need a root over the whole function?\nstatic bool is_stable_expr(jl_value_t *ex, jl_codectx_t *ctx)\n{\n    if (jl_is_symbolnode(ex))\n        ex = (jl_value_t*)jl_symbolnode_sym(ex);\n    if (jl_is_symbol(ex)) {\n        if (ctx->vars.find((jl_sym_t*)ex) != ctx->vars.end()) {\n            // arguments and SSA vars are stable\n            jl_varinfo_t &rhs = ctx->vars[(jl_sym_t*)ex];\n            if ((rhs.isArgument && !rhs.isAssigned) || rhs.isSA)\n                return true;\n        }\n    }\n    if (jl_is_gensym(ex))\n        return true;\n    if (static_eval(ex, ctx, true, false) != NULL)\n        return true;\n    if (jl_is_expr(ex)) {\n        jl_expr_t *e = (jl_expr_t*)ex;\n        if (e->head == call_sym) {\n            jl_value_t *f = static_eval(jl_exprarg(e,0),ctx,true,false);\n            if (f && jl_is_function(f)) {\n                jl_fptr_t fptr = ((jl_function_t*)f)->fptr;\n                // something reached via getfield from a stable value is also stable.\n                if (jl_array_dim0(e->args) == 3) {\n                    jl_value_t *ty = expr_type(jl_exprarg(e,1), ctx);\n                    if ((fptr == &jl_f_get_field && jl_is_immutable_datatype(ty) &&\n                         is_getfield_nonallocating((jl_datatype_t*)ty, jl_exprarg(e,2)))) {\n                        if (is_stable_expr(jl_exprarg(e,1), ctx))\n                            return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n\n// classify exprs that might need temporary rooting.\nstatic bool might_need_root(jl_value_t *ex)\n{\n    return (!jl_is_symbol(ex) && !jl_is_symbolnode(ex) && !jl_is_gensym(ex) &&\n            !jl_is_bool(ex) && !jl_is_quotenode(ex) && !jl_is_byte_string(ex) &&\n            !jl_is_globalref(ex));\n}\n\nstatic Value *emit_boxed_rooted(jl_value_t *e, jl_codectx_t *ctx)\n{\n    Value *v = emit_expr(e, ctx);\n    if (v->getType() != jl_pvalue_llvmt) {\n        v = boxed(v, ctx);\n        make_gcroot(v, ctx);\n    }\n    else if (might_need_root(e)) {\n        make_gcroot(v, ctx);\n    }\n    return v;\n}\n\n// --- lambda ---\n\nstatic void jl_add_linfo_root(jl_lambda_info_t *li, jl_value_t *val)\n{\n    JL_GC_PUSH1(&val);\n    li = li->def;\n    if (li->roots == NULL) {\n        li->roots = jl_alloc_cell_1d(1);\n        jl_gc_wb(li, li->roots);\n        jl_cellset(li->roots, 0, val);\n    }\n    else {\n        size_t rlen = jl_array_dim0(li->roots);\n        for(size_t i=0; i < rlen; i++) {\n            if (jl_cellref(li->roots,i) == val) {\n                JL_GC_POP();\n                return;\n            }\n        }\n        jl_cell_1d_push(li->roots, val);\n    }\n    JL_GC_POP();\n}\n\nstatic Value *emit_lambda_closure(jl_value_t *expr, jl_codectx_t *ctx)\n{\n    assert(jl_is_lambda_info(expr));\n    size_t i;\n    jl_value_t *ast = ((jl_lambda_info_t*)expr)->ast;\n    jl_array_t *capt;\n    if (jl_is_expr(ast))\n        capt = jl_lam_capt((jl_expr_t*)ast);\n    else\n        capt = (jl_array_t*)((jl_lambda_info_t*)expr)->capt;\n    if (capt == NULL || jl_array_dim0(capt) == 0) {\n        // no captured vars; lift\n        jl_value_t *fun =\n            (jl_value_t*)jl_new_closure(NULL, (jl_value_t*)jl_emptysvec,\n                                        (jl_lambda_info_t*)expr);\n        jl_add_linfo_root(ctx->linfo, fun);\n        return literal_pointer_val(fun);\n    }\n\n    int argStart = ctx->gc.argDepth;\n    size_t clen = jl_array_dim0(capt);\n    Value **captured = (Value**) alloca((1+clen)*sizeof(Value*));\n    captured[0] = ConstantInt::get(T_size, clen);\n    for(i=0; i < clen; i++) {\n        Value *val;\n        jl_array_t *vi = (jl_array_t*)jl_cellref(capt, i);\n        assert(jl_is_array(vi));\n        jl_sym_t *s = (jl_sym_t*)jl_cellref(vi,0);\n        assert(jl_is_symbol(s));\n        jl_varinfo_t &vari = ctx->vars[s];\n        if (vari.closureidx != -1) {\n            int idx = vari.closureidx;\n            val = emit_nthptr((Value*)ctx->envArg, idx+1, tbaa_sveclen);\n        }\n        else {\n            Value *l = vari.memvalue;\n            if (l == NULL) {\n                val = vari.passedAs;\n                if (val == NULL && vari.declType != (jl_value_t*)jl_any_type) {\n                    val = boxed(NULL, ctx, vari.declType);\n                }\n                assert(val != NULL);\n                if (val->getType() != jl_pvalue_llvmt) {\n                    assert(vari.declType != (jl_value_t*)jl_any_type);\n                    val = boxed(val,ctx,vari.declType);\n                    make_gcroot(val, ctx);\n                }\n            }\n            else {\n                val = builder.CreateLoad(l);\n            }\n        }\n        captured[i+1] = val;\n    }\n    Value *env_tuple;\n    env_tuple = builder.CreateCall(prepare_call(jlnsvec_func),\n                                   ArrayRef<Value*>(&captured[0], 1+clen));\n    ctx->gc.argDepth = argStart;\n    make_gcroot(env_tuple, ctx);\n#ifdef LLVM37\n    Value *result = builder.CreateCall(prepare_call(jlclosure_func),\n                                        {Constant::getNullValue(T_pint8),\n                                        env_tuple, literal_pointer_val(expr)});\n#else\n    Value *result = builder.CreateCall3(prepare_call(jlclosure_func),\n                                        Constant::getNullValue(T_pint8),\n                                        env_tuple, literal_pointer_val(expr));\n#endif\n    ctx->gc.argDepth--;\n    return result;\n}\n\n// --- generating function calls ---\n\nstatic jl_svec_t *call_arg_types(jl_value_t **args, size_t n, jl_codectx_t *ctx)\n{\n    jl_svec_t *t = jl_alloc_svec(n);\n    JL_GC_PUSH1(&t);\n    size_t i;\n    for(i=0; i < n; i++) {\n        jl_value_t *ty = expr_type(args[i], ctx);\n        if (!jl_is_leaf_type(ty)) {\n            t = NULL;\n            break;\n        }\n        jl_svecset(t, i, ty);\n    }\n    JL_GC_POP();\n    return t;\n}\n\nstatic Value *emit_getfield(jl_value_t *expr, jl_sym_t *name, jl_codectx_t *ctx)\n{\n    if (jl_is_quotenode(expr) && jl_is_module(jl_fieldref(expr,0)))\n        expr = jl_fieldref(expr,0);\n\n    jl_value_t *static_val = static_eval(expr, ctx, true, false);\n    if (static_val != NULL && jl_is_module(static_val))\n        expr = static_val;\n\n    if (jl_is_module(expr)) {\n        jl_binding_t *bnd = NULL;\n        Value *bp = global_binding_pointer((jl_module_t*)expr, name, &bnd, false, ctx);\n        // TODO: refactor. this partially duplicates code in emit_var\n        if (bnd && bnd->value != NULL) {\n            if (bnd->constp && jl_isbits(jl_typeof(bnd->value)))\n                return emit_unboxed(bnd->value, ctx);\n            return tpropagate(bp, builder.CreateLoad(bp));\n        }\n        // todo: use type info to avoid undef check\n        return emit_checked_var(bp, name, ctx);\n    }\n\n    jl_datatype_t *sty = (jl_datatype_t*)expr_type(expr, ctx);\n    JL_GC_PUSH1(&sty);\n    if (jl_is_type_type((jl_value_t*)sty) && jl_is_leaf_type(jl_tparam0(sty)))\n        sty = (jl_datatype_t*)jl_typeof(jl_tparam0(sty));\n    if (jl_is_structtype(sty) && sty != jl_module_type && sty->uid != 0 &&\n        jl_is_leaf_type((jl_value_t*)sty)) {\n        unsigned idx = jl_field_index(sty, name, 0);\n        if (idx != (unsigned)-1) {\n            Value *strct = emit_expr(expr, ctx, false);\n            Value *fld = emit_getfield_knownidx(strct, idx, sty, ctx);\n            JL_GC_POP();\n            return fld;\n        }\n    }\n    // TODO: attempt better codegen for approximate types, if the types\n    // and offsets of some fields are independent of parameters.\n    JL_GC_POP();\n\n    int argStart = ctx->gc.argDepth;\n    Value *arg1 = boxed(emit_expr(expr,ctx), ctx, expr_type(expr,ctx));\n    // TODO: generic getfield func with more efficient calling convention\n    make_gcroot(arg1, ctx);\n    Value *arg2 = literal_pointer_val((jl_value_t*)name);\n    make_gcroot(arg2, ctx);\n    Value *myargs = emit_temp_slot(argStart, ctx);\n#ifdef LLVM37\n    Value *result = builder.CreateCall(prepare_call(jlgetfield_func), {V_null, myargs,\n                                        ConstantInt::get(T_int32,2)});\n#else\n    Value *result = builder.CreateCall3(prepare_call(jlgetfield_func), V_null, myargs,\n                                        ConstantInt::get(T_int32,2));\n#endif\n    ctx->gc.argDepth = argStart;\n    return result;\n}\n\n// emit code for is (===). rt1 and rt2 are the julia types of the arguments,\n// arg1 and arg2 are expressions for the arguments if we have them, or NULL,\n// and varg1 and varg2 are LLVM values for the arguments if we have them.\nstatic Value *emit_f_is(jl_value_t *rt1, jl_value_t *rt2,\n                        jl_value_t *arg1, jl_value_t *arg2,\n                        Value *varg1, Value *varg2, jl_codectx_t *ctx)\n{\n    if (jl_is_type_type(rt1) && jl_is_type_type(rt2) &&\n        !jl_is_typevar(jl_tparam0(rt1)) && !jl_is_typevar(jl_tparam0(rt2)) &&\n        (!arg1 || jl_is_symbol(arg1) || jl_is_symbolnode(arg1) || jl_is_gensym(arg1) || is_constant(arg1, ctx)) &&\n        (!arg2 || jl_is_symbol(arg2) || jl_is_symbolnode(arg2) || jl_is_gensym(arg2) || is_constant(arg2, ctx))) {\n        if (jl_tparam0(rt1) == jl_tparam0(rt2))\n            return ConstantInt::get(T_int1, 1);\n        return ConstantInt::get(T_int1, 0);\n    }\n    int ptr_comparable = 0;\n    if (rt1==(jl_value_t*)jl_sym_type || rt2==(jl_value_t*)jl_sym_type ||\n        jl_is_mutable_datatype(rt1) || jl_is_mutable_datatype(rt2))\n        ptr_comparable = 1;\n    if (jl_subtype(rt1, (jl_value_t*)jl_type_type, 0) ||\n        jl_subtype(rt2, (jl_value_t*)jl_type_type, 0))\n        ptr_comparable = 0;\n    if ((jl_is_type_type(rt1) && jl_is_leaf_type(jl_tparam0(rt1))) ||\n        (jl_is_type_type(rt2) && jl_is_leaf_type(jl_tparam0(rt2))))\n        ptr_comparable = 1;\n    int last_depth = ctx->gc.argDepth;\n    bool isleaf = jl_is_leaf_type(rt1) && jl_is_leaf_type(rt2);\n    bool isteq = jl_types_equal(rt1, rt2);\n    bool isbits = isleaf && isteq && jl_is_bitstype(rt1);\n    bool issingleton = isteq && isleaf && jl_is_datatype_singleton((jl_datatype_t*)rt1);\n    if (arg1 && !varg1) {\n        varg1 = isbits ? auto_unbox(arg1, ctx) : emit_expr(arg1, ctx);\n        if (!issingleton && arg2 && !varg2 && !isbits && varg1->getType() == jl_pvalue_llvmt &&\n            rt1 != (jl_value_t*)jl_sym_type && might_need_root(arg1)) {\n            make_gcroot(varg1, ctx);\n        }\n    }\n    if (arg2 && !varg2)\n        varg2 = isbits ? auto_unbox(arg2, ctx) : emit_expr(arg2, ctx);\n    if (issingleton)\n        return ConstantInt::get(T_int1, 1);\n    if (isleaf && !isteq && !jl_is_type_type(rt1) && !jl_is_type_type(rt2)) {\n        ctx->gc.argDepth = last_depth;\n        return ConstantInt::get(T_int1, 0);\n    }\n    Value *answer;\n    Type *at1 = varg1->getType();\n    Type *at2 = varg2->getType();\n    if (at1 != jl_pvalue_llvmt && at2 != jl_pvalue_llvmt) {\n        assert(at1 == at2);\n        assert(!at1->isAggregateType());\n        assert(!ptr_comparable);\n        if (at1->isPointerTy()) {\n            Type *elty = julia_type_to_llvm(rt1);\n            if (elty->isAggregateType()) {\n                assert(jl_is_datatype(rt1));\n                size_t sz = jl_datatype_size(rt1);\n                if (sz > 512 && !((jl_datatype_t*)rt1)->haspadding) {\n#ifdef LLVM37\n                    answer = builder.CreateCall(prepare_call(memcmp_func),\n                                    {\n                                    builder.CreatePointerCast(varg1, T_pint8),\n                                    builder.CreatePointerCast(varg2, T_pint8),\n                                    ConstantInt::get(T_size, sz)\n                                    });\n#else\n                    answer = builder.CreateCall3(prepare_call(memcmp_func),\n                            builder.CreatePointerCast(varg1, T_pint8),\n                            builder.CreatePointerCast(varg2, T_pint8),\n                            ConstantInt::get(T_size, sz));\n#endif\n                    answer = builder.CreateICmpEQ(answer, ConstantInt::get(T_int32, 0));\n                }\n                else {\n                    varg1 = builder.CreatePointerCast(varg1, elty->getPointerTo());\n                    varg2 = builder.CreatePointerCast(varg2, elty->getPointerTo());\n                    jl_svec_t *types = ((jl_datatype_t*)rt1)->types;\n                    answer = ConstantInt::get(T_int1, 1);\n                    size_t l = jl_svec_len(types);\n                    for(unsigned i=0; i < l; i++) {\n                        jl_value_t *fldty = jl_svecref(types, i);\n                        Value *subAns;\n#ifdef LLVM37\n                        Value *fld1 = builder.CreateConstGEP2_32(elty, varg1, 0, i);\n                        Value *fld2 = builder.CreateConstGEP2_32(elty, varg2, 0, i);\n#else\n                        Value *fld1 = builder.CreateConstGEP2_32(varg1, 0, i);\n                        Value *fld2 = builder.CreateConstGEP2_32(varg2, 0, i);\n#endif\n                        if (type_is_ghost(fld1->getType()))\n                            continue;\n                        if (!fld1->getType()->getContainedType(0)->isAggregateType()) {\n                            fld1 = builder.CreateLoad(fld1);\n                            fld2 = builder.CreateLoad(fld2);\n                        }\n                        subAns = emit_f_is(fldty, fldty, NULL, NULL, fld1, fld2, ctx);\n                        answer = builder.CreateAnd(answer, subAns);\n                    }\n                }\n                goto done;\n            }\n        }\n        if (at1->isIntegerTy() || at1->isPointerTy() ||\n            at1->isFloatingPointTy()) {\n            answer = builder.CreateICmpEQ(JL_INT(varg1),JL_INT(varg2));\n            goto done;\n        }\n        if (at1->isVectorTy()) {\n            assert(jl_is_datatype(rt1));\n            jl_svec_t *types = ((jl_datatype_t*)rt1)->types;\n            answer = ConstantInt::get(T_int1, 1);\n            size_t l = jl_svec_len(types);\n            for(unsigned i=0; i < l; i++) {\n                jl_value_t *fldty = jl_svecref(types,i);\n                Value *subAns;\n                subAns = emit_f_is(fldty, fldty, NULL, NULL,\n                        builder.CreateExtractElement(varg1, ConstantInt::get(T_int32,i)),\n                        builder.CreateExtractElement(varg2, ConstantInt::get(T_int32,i)),\n                        ctx);\n                answer = builder.CreateAnd(answer, subAns);\n            }\n            goto done;\n        }\n    }\n    assert(at1 == jl_pvalue_llvmt || at2 == jl_pvalue_llvmt);\n    varg1 = boxed(varg1,ctx); varg2 = boxed(varg2,ctx);\n    if (ptr_comparable)\n        answer = builder.CreateICmpEQ(varg1, varg2);\n    else {\n#ifdef LLVM37\n        answer = builder.CreateTrunc(builder.CreateCall(prepare_call(jlegal_func), {varg1, varg2}), T_int1);\n#else\n        answer = builder.CreateTrunc(builder.CreateCall2(prepare_call(jlegal_func), varg1, varg2), T_int1);\n#endif\n    }\n done:\n    ctx->gc.argDepth = last_depth;\n    return answer;\n}\n\nstatic Value *emit_known_call(jl_value_t *ff, jl_value_t **args, size_t nargs,\n                              jl_codectx_t *ctx,\n                              Value **theFptr, jl_function_t **theF,\n                              jl_value_t *expr)\n{\n    if (jl_typeis(ff, jl_intrinsic_type)) {\n        return emit_intrinsic((intrinsic)*(uint32_t*)jl_data_ptr(ff),\n                              args, nargs, ctx);\n    }\n    if (!jl_is_func(ff)) {\n        return NULL;\n    }\n    jl_value_t *rt1=NULL, *rt2=NULL, *rt3=NULL;\n    JL_GC_PUSH3(&rt1, &rt2, &rt3);\n    jl_function_t *f = (jl_function_t*)ff;\n    if (f->fptr == &jl_apply_generic) {\n        *theFptr = jlapplygeneric_func;\n        *theF = f;\n        if (ctx->linfo->inferred) {\n            jl_svec_t *aty = call_arg_types(&args[1], nargs, ctx);\n            rt1 = (jl_value_t*)aty;\n            // attempt compile-time specialization for inferred types\n            if (aty != NULL) {\n                rt1 = (jl_value_t*)jl_apply_tuple_type(aty);\n                /*\n                  if (trace) {\n                      jl_printf(JL_STDOUT, \"call %s%s\\n\",\n                      jl_sprint(args[0]),\n                      jl_sprint((jl_value_t*)aty));\n                  }\n                */\n                f = jl_get_specialization(f, (jl_tupletype_t*)rt1);\n                if (f != NULL) {\n                    assert(f->linfo->functionObject != NULL);\n                    *theFptr = (Value*)f->linfo->functionObject;\n                    *theF = f;\n                }\n            }\n        }\n    }\n    else if (f->fptr == &jl_f_is && nargs==2) {\n        rt1 = expr_type(args[1], ctx);\n        rt2 = expr_type(args[2], ctx);\n        Value *ans = emit_f_is(rt1,rt2, args[1],args[2], NULL,NULL, ctx);\n        JL_GC_POP();\n        return ans;\n    }\n    else if (f->fptr == &jl_f_typeof && nargs==1) {\n        jl_value_t *aty = expr_type(args[1], ctx); rt1 = aty;\n        Value *arg1 = emit_expr(args[1], ctx), *ret;\n        if (jl_is_leaf_type(aty)) {\n            if (jl_is_type_type(aty))\n                aty = (jl_value_t*)jl_typeof(jl_tparam0(aty));\n            ret = literal_pointer_val(aty);\n        }\n        else {\n            arg1 = boxed(arg1,ctx);\n            ret = emit_typeof(arg1);\n        }\n        JL_GC_POP();\n        return ret;\n    }\n    else if (f->fptr == &jl_f_typeassert && nargs==2) {\n        jl_value_t *arg = expr_type(args[1], ctx); rt1 = arg;\n        jl_value_t *ty  = expr_type(args[2], ctx); rt2 = ty;\n        if (jl_is_type_type(ty) && !jl_is_typevar(jl_tparam0(ty))) {\n            jl_value_t *tp0 = jl_tparam0(ty);\n            if (jl_subtype(arg, tp0, 0)) {\n                JL_GC_POP();\n                Value *v = emit_expr(args[1], ctx);\n                if (tp0 == jl_bottom_type) {\n                    v = builder.CreateUnreachable();\n                    BasicBlock *cont = BasicBlock::Create(getGlobalContext(),\"after_assert\",ctx->f);\n                    builder.SetInsertPoint(cont);\n                }\n                return v;\n            }\n            if (tp0 == jl_bottom_type) {\n                emit_expr(args[1], ctx);\n                emit_error(\"reached code declared unreachable\", ctx);\n                JL_GC_POP();\n                return NULL;\n            }\n            if (!jl_is_tuple_type(tp0) && jl_is_leaf_type(tp0)) {\n                Value *arg1 = emit_expr(args[1], ctx);\n                emit_typecheck(arg1, tp0, \"typeassert\", ctx);\n                JL_GC_POP();\n                return arg1;\n            }\n        }\n        if (jl_subtype(ty, (jl_value_t*)jl_type_type, 0)) {\n            FunctionType *ft = FunctionType::get(T_void, two_pvalue_llvmt, false);\n            Value *typeassert = jl_Module->getOrInsertFunction(\"jl_typeassert\", ft);\n            int ldepth = ctx->gc.argDepth;\n            Value *arg1 = emit_boxed_rooted(args[1], ctx);\n#ifdef LLVM37\n            builder.CreateCall(prepare_call(typeassert), {arg1, boxed(emit_expr(args[2], ctx),ctx)});\n#else\n            builder.CreateCall2(prepare_call(typeassert), arg1, boxed(emit_expr(args[2], ctx),ctx));\n#endif\n            ctx->gc.argDepth = ldepth;\n            JL_GC_POP();\n            return arg1;\n        }\n    }\n    else if (f->fptr == &jl_f_isa && nargs==2) {\n        jl_value_t *arg = expr_type(args[1], ctx); rt1 = arg;\n        jl_value_t *ty  = expr_type(args[2], ctx); rt2 = ty;\n        if (arg == jl_bottom_type) {\n            JL_GC_POP();\n            emit_expr(args[1], ctx);\n            return UndefValue::get(T_int1);\n        }\n        if (jl_is_type_type(ty) && !jl_has_typevars(jl_tparam0(ty))) {\n            jl_value_t *tp0 = jl_tparam0(ty);\n            if (jl_subtype(arg, tp0, 0)) {\n                emit_expr(args[1], ctx);  // TODO remove if no side effects\n                JL_GC_POP();\n                return ConstantInt::get(T_int1,1);\n            }\n            if (!jl_subtype(tp0, (jl_value_t*)jl_type_type, 0)) {\n                if (jl_is_leaf_type(arg)) {\n                    emit_expr(args[1], ctx);  // TODO remove if no side effects\n                    JL_GC_POP();\n                    return ConstantInt::get(T_int1,0);\n                }\n                if (jl_is_leaf_type(tp0)) {\n                    Value *arg1 = emit_expr(args[1], ctx);\n                    JL_GC_POP();\n                    return builder.CreateICmpEQ(emit_typeof(arg1),\n                                                literal_pointer_val(tp0));\n                }\n            }\n        }\n    }\n    else if (f->fptr == &jl_f_subtype && nargs == 2) {\n        rt1 = expr_type(args[1], ctx);\n        rt2 = expr_type(args[2], ctx);\n        if (jl_is_type_type(rt1) && !jl_is_typevar(jl_tparam0(rt1)) &&\n            jl_is_type_type(rt2) && !jl_is_typevar(jl_tparam0(rt2))) {\n            int issub = jl_subtype(jl_tparam0(rt1), jl_tparam0(rt2), 0);\n            JL_GC_POP();\n            return ConstantInt::get(T_int1, issub);\n        }\n    }\n    else if (f->fptr == &jl_f_apply && nargs==3 && ctx->vaStack &&\n             symbol_eq(args[3], ctx->vaName) && expr_type(args[2],ctx) == (jl_value_t*)jl_function_type) {\n        Value *theF = emit_expr(args[2],ctx);\n        Value *theFptr = emit_nthptr_recast(\n                theF,\n                (ssize_t)(offsetof(jl_function_t,fptr)/sizeof(void*)),\n                tbaa_func,\n                jl_pfptr_llvmt);\n        Value *nva = emit_n_varargs(ctx);\n#ifdef _P64\n        nva = builder.CreateTrunc(nva, T_int32);\n#endif\n        Value *r =\n#ifdef LLVM37\n            builder.CreateCall(prepare_call(theFptr), {theF,\n                                builder.CreateGEP(ctx->argArray,\n                                                  ConstantInt::get(T_size, ctx->nReqArgs)),\n                                nva});\n#else\n            builder.CreateCall3(prepare_call(theFptr), theF,\n                                builder.CreateGEP(ctx->argArray,\n                                                  ConstantInt::get(T_size, ctx->nReqArgs)),\n                                nva);\n#endif\n        JL_GC_POP();\n        return r;\n    }\n    else if (f->fptr == &jl_f_tuple) {\n        if (nargs == 0) {\n            JL_GC_POP();\n            return tbaa_decorate(tbaa_const, builder.CreateLoad(prepare_global(jlemptytuple_var)));\n        }\n        if (ctx->linfo->inferred) {\n            rt1 = expr_type(expr, ctx);\n            if (jl_is_tuple_type(rt1) && jl_is_leaf_type(rt1) && nargs == jl_datatype_nfields(rt1)) {\n                Value *tpl = emit_new_struct(rt1, nargs+1, args, ctx);\n                JL_GC_POP();\n                return tpl;\n            }\n        }\n    }\n    else if (f->fptr == &jl_f_throw && nargs==1) {\n        Value *arg1 = boxed(emit_expr(args[1], ctx), ctx);\n        JL_GC_POP();\n        raise_exception_unless(ConstantInt::get(T_int1,0), arg1, ctx);\n        return V_null;\n    }\n    else if (f->fptr == &jl_f_arraylen && nargs==1) {\n        jl_value_t *aty = expr_type(args[1], ctx); rt1 = aty;\n        if (jl_is_array_type(aty)) {\n            // todo: also allow e.g. Union of several array types\n            Value *arg1 = emit_expr(args[1], ctx);\n            JL_GC_POP();\n            return emit_arraylen(arg1, args[1], ctx);\n        }\n    }\n    else if (f->fptr == &jl_f_arraysize && nargs==2) {\n        jl_value_t *aty = expr_type(args[1], ctx); rt1 = aty;\n        jl_value_t *ity = expr_type(args[2], ctx); rt2 = ity;\n        if (jl_is_array_type(aty) && ity == (jl_value_t*)jl_long_type) {\n            jl_value_t *ndp = jl_tparam1(aty);\n            if (jl_is_long(ndp)) {\n                Value *ary = emit_expr(args[1], ctx);\n                size_t ndims = jl_unbox_long(ndp);\n                if (jl_is_long(args[2])) {\n                    uint32_t idx = (uint32_t)jl_unbox_long(args[2]);\n                    if (idx > 0 && idx <= ndims) {\n                        JL_GC_POP();\n                        return emit_arraysize(ary, args[1], idx, ctx);\n                    }\n                    else if (idx > ndims) {\n                        JL_GC_POP();\n                        return ConstantInt::get(T_size, 1);\n                    }\n                }\n                else {\n                    Value *idx = emit_unbox(T_size,\n                                            emit_unboxed(args[2], ctx), ity);\n                    error_unless(builder.CreateICmpSGT(idx,\n                                                      ConstantInt::get(T_size,0)),\n                                 \"arraysize: dimension out of range\", ctx);\n                    BasicBlock *outBB = BasicBlock::Create(getGlobalContext(),\"outofrange\",ctx->f);\n                    BasicBlock *inBB = BasicBlock::Create(getGlobalContext(),\"inrange\");\n                    BasicBlock *ansBB = BasicBlock::Create(getGlobalContext(),\"arraysize\");\n                    builder.CreateCondBr(builder.CreateICmpSLE(idx,\n                                                              ConstantInt::get(T_size, ndims)),\n                                         inBB, outBB);\n                    builder.SetInsertPoint(outBB);\n                    Value *v_one = ConstantInt::get(T_size, 1);\n                    builder.CreateBr(ansBB);\n                    ctx->f->getBasicBlockList().push_back(inBB);\n                    builder.SetInsertPoint(inBB);\n                    Value *v_sz = emit_arraysize(ary, idx);\n                    builder.CreateBr(ansBB);\n                    ctx->f->getBasicBlockList().push_back(ansBB);\n                    builder.SetInsertPoint(ansBB);\n                    PHINode *result = builder.CreatePHI(T_size, 2);\n                    result->addIncoming(v_one, outBB);\n                    result->addIncoming(v_sz, inBB);\n                    JL_GC_POP();\n                    return result;\n                }\n            }\n        }\n    }\n    else if (f->fptr == &jl_f_arrayref && nargs>=2) {\n        jl_value_t *aty = expr_type(args[1], ctx); rt1 = aty;\n        bool indexes_ok = true;\n        for (size_t i=2; i <= nargs; i++) {\n            if (expr_type(args[i], ctx) != (jl_value_t*)jl_long_type) {\n                indexes_ok = false; break;\n            }\n        }\n        if (jl_is_array_type(aty) && indexes_ok) {\n            jl_value_t *ety = jl_tparam0(aty);\n            if (!jl_is_typevar(ety)) {\n                if (!jl_array_store_unboxed(ety))\n                    ety = (jl_value_t*)jl_any_type;\n                jl_value_t *ndp = jl_tparam1(aty);\n                if (jl_is_long(ndp) || nargs==2) {\n                    Value *ary = emit_expr(args[1], ctx);\n                    size_t nd = jl_is_long(ndp) ? jl_unbox_long(ndp) : 1;\n                    Value *idx = emit_array_nd_index(ary, args[1], nd, &args[2], nargs-1, ctx);\n                    JL_GC_POP();\n                    if (jl_array_store_unboxed(ety) &&\n                        ((jl_datatype_t*)ety)->size == 0) {\n                        assert(jl_is_datatype(ety));\n                        assert(((jl_datatype_t*)ety)->instance != NULL);\n                        return literal_pointer_val(((jl_datatype_t*)ety)->instance);\n                    }\n                    return typed_load(emit_arrayptr(ary, args[1], ctx), idx, ety, ctx, tbaa_user);\n                }\n            }\n        }\n    }\n    else if (f->fptr == &jl_f_arrayset && nargs>=3) {\n        jl_value_t *aty = expr_type(args[1], ctx); rt1 = aty;\n        jl_value_t *vty = expr_type(args[2], ctx); rt2 = vty;\n        bool indexes_ok = true;\n        for (size_t i=3; i <= nargs; i++) {\n            if (expr_type(args[i], ctx) != (jl_value_t*)jl_long_type) {\n                indexes_ok = false; break;\n            }\n        }\n        if (jl_is_array_type(aty) && indexes_ok) {\n            jl_value_t *ety = jl_tparam0(aty);\n            if (!jl_is_typevar(ety) && jl_subtype(vty, ety, 0)) {\n                if (!jl_array_store_unboxed(ety))\n                    ety = (jl_value_t*)jl_any_type;\n                jl_value_t *ndp = jl_tparam1(aty);\n                if (jl_is_long(ndp) || nargs==3) {\n                    Value *ary = emit_expr(args[1], ctx);\n                    size_t nd = jl_is_long(ndp) ? jl_unbox_long(ndp) : 1;\n                    Value *idx = emit_array_nd_index(ary, args[1], nd, &args[3], nargs-2, ctx);\n                    bool isboxed = !jl_array_store_unboxed(ety);\n                    if (!isboxed && ((jl_datatype_t*)ety)->size == 0) {\n                        // no-op, but emit expr for possible effects\n                        assert(jl_is_datatype(ety));\n                        emit_expr(args[2],ctx,false);\n                    }\n                    else {\n                        Value* v = ety==(jl_value_t*)jl_any_type ? emit_expr(args[2],ctx) : emit_unboxed(args[2],ctx);\n                        PHINode* data_owner = NULL; // owner object against which the write barrier must check\n                        if (isboxed) { // if not boxed we don't need a write barrier\n                            Value *flags = emit_arrayflags(ary,ctx);\n                            // the owner of the data is ary itself except if ary->how == 3\n                            flags = builder.CreateAnd(flags, 3);\n                            Value *is_owned = builder.CreateICmpEQ(flags, ConstantInt::get(T_int16, 3));\n                            BasicBlock *curBB = builder.GetInsertBlock();\n                            BasicBlock *ownedBB = BasicBlock::Create(getGlobalContext(), \"array_owned\", ctx->f);\n                            BasicBlock *mergeBB = BasicBlock::Create(getGlobalContext(), \"merge_own\", ctx->f);\n                            builder.CreateCondBr(is_owned, ownedBB, mergeBB);\n                            builder.SetInsertPoint(ownedBB);\n                            // load owner pointer\n                            Value *own_ptr;\n                            if (jl_is_long(ndp)) {\n                                own_ptr = builder.CreateLoad(\n                                    builder.CreateBitCast(\n                                        builder.CreateConstGEP1_32(\n                                            builder.CreateBitCast(ary,T_pint8),\n                                            jl_array_data_owner_offset(nd)),\n                                        jl_ppvalue_llvmt));\n                            }\n                            else {\n#ifdef LLVM37\n                                own_ptr = builder.CreateCall(\n                                    prepare_call(jlarray_data_owner_func),\n                                    {ary});\n#else\n                                own_ptr = builder.CreateCall(\n                                    prepare_call(jlarray_data_owner_func),\n                                    ary);\n#endif\n                            }\n                            builder.CreateBr(mergeBB);\n                            builder.SetInsertPoint(mergeBB);\n                            data_owner = builder.CreatePHI(jl_pvalue_llvmt, 2);\n                            data_owner->addIncoming(ary, curBB);\n                            data_owner->addIncoming(own_ptr, ownedBB);\n                        }\n                        typed_store(emit_arrayptr(ary,args[1],ctx), idx, v,\n                                    ety, ctx, tbaa_user, data_owner);\n                    }\n                    JL_GC_POP();\n                    return ary;\n                }\n            }\n        }\n    }\n    else if (f->fptr == &jl_f_get_field && nargs==2) {\n        if (jl_is_quotenode(args[2]) && jl_is_symbol(jl_fieldref(args[2],0))) {\n            Value *fld = emit_getfield(args[1],\n                                       (jl_sym_t*)jl_fieldref(args[2],0), ctx);\n            JL_GC_POP();\n            return fld;\n        }\n        jl_datatype_t *stt = (jl_datatype_t*)expr_type(args[1], ctx);\n        jl_value_t *fldt   = expr_type(args[2], ctx);\n\n        // VA tuple\n        if (ctx->vaStack && symbol_eq(args[1], ctx->vaName)) {\n            Value *valen = emit_n_varargs(ctx);\n            Value *idx = emit_unbox(T_size,\n                                    emit_unboxed(args[2], ctx),fldt);\n            idx = emit_bounds_check(builder.CreateGEP(ctx->argArray, ConstantInt::get(T_size, ctx->nReqArgs)),\n                                    (jl_value_t*)jl_any_type, idx, valen, ctx);\n            idx = builder.CreateAdd(idx, ConstantInt::get(T_size, ctx->nReqArgs));\n            JL_GC_POP();\n            return tbaa_decorate(tbaa_user, builder.\n                                 CreateLoad(builder.CreateGEP(ctx->argArray,idx)));\n        }\n\n        if (fldt == (jl_value_t*)jl_long_type && jl_is_leaf_type((jl_value_t*)stt)) {\n            if ((jl_is_structtype(stt) || jl_is_tuple_type(stt)) && !jl_subtype((jl_value_t*)jl_module_type, (jl_value_t*)stt, 0)) {\n                size_t nfields = jl_datatype_nfields(stt);\n                Value *strct = emit_expr(args[1], ctx);\n                // integer index\n                Value *fld;\n                size_t idx;\n                if (jl_is_long(args[2]) && (idx=jl_unbox_long(args[2])-1) < nfields) {\n                    // known index\n                    fld = emit_getfield_knownidx(strct, idx, stt, ctx);\n                }\n                else {\n                    // unknown index\n                    Value *vidx = emit_unbox(T_size, emit_unboxed(args[2], ctx), (jl_value_t*)jl_long_type);\n                    fld = emit_getfield_unknownidx(strct, vidx, stt, ctx);\n                }\n                if (fld != NULL) {\n                    JL_GC_POP();\n                    return fld;\n                }\n            }\n        }\n    }\n    else if (f->fptr == &jl_f_set_field && nargs==3) {\n        jl_datatype_t *sty = (jl_datatype_t*)expr_type(args[1], ctx);\n        rt1 = (jl_value_t*)sty;\n        if (jl_is_structtype(sty) && sty != jl_module_type &&\n            jl_is_quotenode(args[2]) && jl_is_symbol(jl_fieldref(args[2],0))) {\n            size_t idx = jl_field_index(sty,\n                                        (jl_sym_t*)jl_fieldref(args[2],0), 0);\n            if (idx != (size_t)-1) {\n                jl_value_t *ft = jl_svecref(sty->types, idx);\n                jl_value_t *rhst = expr_type(args[3], ctx);\n                rt2 = rhst;\n                if (jl_is_leaf_type((jl_value_t*)sty) && jl_subtype(rhst, ft, 0)) {\n                    // TODO: attempt better codegen for approximate types\n                    Value *strct = emit_expr(args[1], ctx);\n                    Value *rhs;\n                    if (jl_field_isptr(sty, idx))\n                        rhs = emit_expr(args[3], ctx);\n                    else\n                        rhs = emit_unboxed(args[3], ctx);\n                    emit_setfield(sty, strct, idx, rhs, ctx, true, true);\n                    JL_GC_POP();\n                    return rhs;\n                }\n            }\n        }\n        // TODO: faster code for integer index\n    }\n    else if (f->fptr == &jl_f_nfields && nargs==1) {\n        if (ctx->vaStack && symbol_eq(args[1], ctx->vaName) && !ctx->vars[ctx->vaName].isAssigned) {\n            JL_GC_POP();\n            return emit_n_varargs(ctx);\n        }\n        jl_value_t *aty = expr_type(args[1], ctx); rt1 = aty;\n        if (jl_is_type_type(aty)) {\n            jl_value_t *tp0 = jl_tparam0(aty);\n            if (jl_is_leaf_type(tp0)) {\n                emit_expr(args[1], ctx);\n                JL_GC_POP();\n                assert(jl_is_datatype(tp0));\n                return ConstantInt::get(T_size, jl_datatype_nfields(tp0));\n            }\n        }\n        else if (jl_is_leaf_type(aty)) {\n            Value *arg1 = emit_expr(args[1], ctx);\n            JL_GC_POP();\n            if (aty == (jl_value_t*)jl_datatype_type)\n                return emit_datatype_nfields(arg1);\n            return ConstantInt::get(T_size, jl_datatype_nfields(aty));\n        }\n    }\n    else if (f->fptr == &jl_f_field_type && nargs==2) {\n        jl_datatype_t *sty = (jl_datatype_t*)expr_type(args[1], ctx);\n        rt1 = (jl_value_t*)sty;\n        if (jl_is_type_type((jl_value_t*)sty) || sty == jl_datatype_type) {\n            rt2 = expr_type(args[2], ctx); // index argument type\n            if (rt2 == (jl_value_t*)jl_long_type) {\n                Value *ty = emit_expr(args[1], ctx);\n                Value *types_svec = emit_datatype_types(ty);\n                Value *types_len = emit_datatype_nfields(ty);\n                Value *idx = emit_unboxed(args[2], ctx);\n                emit_bounds_check(ty, NULL, idx, types_len, ctx);\n                Value *fieldtyp = builder.CreateLoad(builder.CreateGEP(builder.CreateBitCast(types_svec, jl_ppvalue_llvmt), idx));\n                JL_GC_POP();\n                return fieldtyp;\n            }\n        }\n    }\n    else if (f->fptr == &jl_f_sizeof && nargs == 1) {\n        jl_datatype_t *sty = (jl_datatype_t*)expr_type(args[1], ctx);\n        rt1 = (jl_value_t*)sty;\n        if (jl_is_type_type((jl_value_t*)sty) && !jl_is_typevar(jl_tparam0(sty))) {\n            sty = (jl_datatype_t*)jl_tparam0(sty);\n        }\n        if (jl_is_datatype(sty) && sty != jl_symbol_type && sty->name != jl_array_typename &&\n            sty != jl_simplevector_type &&\n            // exclude DataType, since each DataType has its own size, not sizeof(DataType).\n            // this is issue #8798\n            sty != jl_datatype_type) {\n            if (jl_is_leaf_type((jl_value_t*)sty) ||\n                (sty->name->names == jl_emptysvec && sty->size > 0)) {\n                JL_GC_POP();\n                return ConstantInt::get(T_size, sty->size);\n            }\n        }\n    }\n    else if (f->fptr == &jl_f_instantiate_type && nargs > 0) {\n        size_t i;\n        for(i=1; i <= nargs; i++) {\n            if (!is_constant(args[i], ctx))\n                break;\n        }\n        if (i > nargs) {\n            jl_value_t *ty = static_eval(expr, ctx, true, true);\n            if (ty!=NULL && jl_is_leaf_type(ty)) {\n                if (jl_has_typevars(ty)) {\n                    // add root for types not cached. issue #7065\n                    jl_add_linfo_root(ctx->linfo, ty);\n                }\n                JL_GC_POP();\n                return literal_pointer_val(ty);\n            }\n        }\n    }\n    // TODO: other known builtins\n    JL_GC_POP();\n    return NULL;\n}\n\nstatic Value *emit_jlcall(Value *theFptr, Value *theF, int argStart,\n                          size_t nargs, jl_codectx_t *ctx)\n{\n    // call\n    Value *myargs;\n    if (nargs > 0)\n        myargs = emit_temp_slot(argStart, ctx);\n    else\n        myargs = Constant::getNullValue(jl_ppvalue_llvmt);\n#ifdef LLVM37\n    Value *result = builder.CreateCall(prepare_call(theFptr), {theF, myargs,\n                                        ConstantInt::get(T_int32,nargs)});\n#else\n    Value *result = builder.CreateCall3(prepare_call(theFptr), theF, myargs,\n                                        ConstantInt::get(T_int32,nargs));\n#endif\n    ctx->gc.argDepth = argStart; // clear the args from the gcstack\n    return result;\n}\n\nstatic Value *emit_jlcall(Value *theFptr, Value *theF, jl_value_t **args,\n                          size_t nargs, jl_codectx_t *ctx)\n{\n    // emit arguments\n    int argStart = ctx->gc.argDepth;\n    for(size_t i=0; i < nargs; i++) {\n        Value *anArg = emit_expr(args[i], ctx, true, true);\n        // put into argument space\n        make_gcroot(boxed(anArg, ctx, expr_type(args[i],ctx)), ctx);\n    }\n    return emit_jlcall(theFptr, theF, argStart, nargs, ctx);\n}\n\nstatic Value *emit_call_function_object(jl_function_t *f, Value *theF, Value *theFptr,\n                                        bool specialized,\n                                        jl_value_t **args, size_t nargs,\n                                        jl_codectx_t *ctx)\n{\n    if (f!=NULL && specialized && f->linfo!=NULL && f->linfo->specFunctionObject!=NULL) {\n        // emit specialized call site\n        Function *cf = (Function*)f->linfo->specFunctionObject;\n        FunctionType *cft = cf->getFunctionType();\n        size_t nfargs = cft->getNumParams();\n        Value **argvals = (Value**) alloca(nfargs*sizeof(Value*));\n        bool sret = cf->hasStructRetAttr();\n        unsigned idx = 0;\n        Value *result;\n        if (sret) {\n            result = emit_static_alloca(cft->getParamType(0)->getContainedType(0), ctx);\n            argvals[idx] = result;\n            idx++;\n        }\n        for(size_t i=0; i < nargs; i++) {\n            Type *at = cft->getParamType(idx);\n            jl_value_t *jt = jl_nth_slot_type(f->linfo->specTypes,i);\n            Type *et = julia_type_to_llvm(jt);\n            if (et == T_void || et->isEmptyTy()) {\n                // Still emit the expression in case it has side effects\n                emit_expr(args[i+1], ctx);\n                continue;\n            }\n            if (at == jl_pvalue_llvmt) {\n                Value *origval = emit_expr(args[i+1], ctx);\n                argvals[idx] = boxed(origval,ctx,expr_type(args[i+1],ctx));\n                assert(dyn_cast<UndefValue>(argvals[idx]) == 0);\n                // TODO: there should be a function emit_rooted that handles this, leaving\n                // the value rooted if it was already, to avoid redundant stores.\n                if (origval->getType() != jl_pvalue_llvmt ||\n                    (might_need_root(args[i+1]) && !is_stable_expr(args[i+1], ctx))) {\n                    make_gcroot(argvals[idx], ctx);\n                }\n            }\n            else if (et->isAggregateType()) {\n                assert(at == PointerType::get(et, 0));\n                Value *arg = emit_unboxed(args[i+1], ctx);\n                if (arg->getType() == at && jl_is_immutable_datatype(jt)) // can lazy load on demand, no copy needed\n                    argvals[idx] = arg;\n                else\n                    argvals[idx] = emit_reg2mem(emit_unbox(et, arg, jt), ctx);\n            }\n            else {\n                assert(at == et);\n                argvals[idx] = emit_unbox(et, emit_unboxed(args[i+1], ctx), jt);\n                assert(dyn_cast<UndefValue>(argvals[idx]) == 0);\n            }\n            idx++;\n        }\n        assert(idx == nfargs);\n        CallInst *call = builder.CreateCall(prepare_call(cf), ArrayRef<Value*>(&argvals[0], nfargs));\n        call->setAttributes(cf->getAttributes());\n        if (sret)\n            result = builder.CreateLoad(result);\n        else\n            result = call;\n        return mark_julia_type(emit_reg2mem(result, ctx), jl_ast_rettype(f->linfo, f->linfo->ast));\n    }\n    return emit_jlcall(theFptr, theF, &args[1], nargs, ctx);\n}\n\nstatic Value *emit_is_function(Value *x, jl_codectx_t *ctx)\n{\n    Value *xty = emit_typeof(x);\n    Value *isfunc =\n        builder.CreateICmpEQ(xty, literal_pointer_val((jl_value_t*)jl_function_type));\n    return isfunc;\n}\n\nstatic Value *emit_call(jl_value_t **args, size_t arglen, jl_codectx_t *ctx, jl_value_t *expr)\n{\n    size_t nargs = arglen-1;\n    Value *theFptr=NULL, *theF=NULL;\n    jl_value_t *a0 = args[0];\n    jl_value_t *hdtype;\n    bool headIsGlobal = false;\n    bool definitely_function = false;\n    bool definitely_not_function = false;\n\n    jl_function_t *f = (jl_function_t*)static_eval(a0, ctx, true);\n    JL_GC_PUSH1(&f);\n    if (f != NULL) {\n        // function is a compile-time constant\n        Value *result;\n        headIsGlobal = true;\n        definitely_function = jl_is_func(f);\n        definitely_not_function = !definitely_function;\n        if (jl_typeis(f, jl_intrinsic_type) || jl_is_func(f)) {\n            result = emit_known_call((jl_value_t*)f, args, nargs, ctx, &theFptr, &f, expr);\n            assert(!jl_typeis(f,jl_intrinsic_type) || result!=NULL);\n        }\n        else {\n            result = emit_known_call((jl_value_t*)jl_module_call_func(ctx->module),\n                                     args-1, nargs+1, ctx, &theFptr, &f, expr);\n        }\n        if (result != NULL) {\n            JL_GC_POP();\n            return result;\n        }\n    }\n\n    hdtype = expr_type(a0, ctx);\n    definitely_function |= (hdtype == (jl_value_t*)jl_function_type);\n    definitely_not_function |= (jl_is_leaf_type(hdtype) && !definitely_function);\n\n    assert(!(definitely_function && definitely_not_function));\n\n    int last_depth = ctx->gc.argDepth;\n    Value *result;\n\n    if (definitely_not_function) {\n        f = jl_module_call_func(ctx->module);\n        Value *r = emit_known_call((jl_value_t*)f, args-1, nargs+1, ctx, &theFptr, &f, expr);\n        assert(r == NULL); (void) r;\n        if (theFptr == NULL) {\n            just_emit_error(\"\\\"call\\\" is not a generic function\", ctx);\n            result = UndefValue::get(jl_pvalue_llvmt);\n        }\n        else {\n            theF = literal_pointer_val((jl_value_t*)f);\n            result = emit_call_function_object(f, theF, theFptr, true, args-1, nargs+1, ctx);\n        }\n    }\n    else if (definitely_function) {\n        bool specialized = true;\n        if (theFptr == NULL) {\n            specialized = false;\n            if (f != NULL) {\n                // builtin functions don't need the function object passed and are constant\n                std::map<jl_fptr_t,Function*>::iterator it = builtin_func_map.find(f->fptr);\n                if (it != builtin_func_map.end()) {\n                    theFptr = (*it).second;\n                    theF = V_null;\n                }\n            }\n            if (theFptr == NULL) {\n                Value *theFunc = emit_expr(args[0], ctx);\n                if (!headIsGlobal && (jl_is_expr(a0) || jl_is_lambda_info(a0)))\n                    make_gcroot(boxed(theFunc,ctx), ctx);\n                // extract pieces of the function object\n                // TODO: try extractvalue instead\n                theFptr = emit_nthptr_recast(theFunc, (ssize_t)(offsetof(jl_function_t,fptr)/sizeof(void*)), tbaa_func, jl_pfptr_llvmt);\n                theF = theFunc;\n            }\n        }\n        else {\n            theF = literal_pointer_val((jl_value_t*)f);\n        }\n        result = emit_call_function_object(f, theF, theFptr, specialized, args, nargs, ctx);\n    }\n    else {\n        // either direct function, or use call(), based on run-time branch\n\n        // emit \"function\" and arguments\n        int argStart = ctx->gc.argDepth;\n        Value *theFunc = boxed(emit_expr(args[0], ctx), ctx);\n        make_gcroot(theFunc, ctx);\n        for(size_t i=0; i < nargs; i++) {\n            Value *anArg = emit_expr(args[i+1], ctx);\n            // put into argument space\n            make_gcroot(boxed(anArg, ctx, expr_type(args[i+1],ctx)), ctx);\n        }\n\n        Value *isfunc = emit_is_function(theFunc, ctx);\n        BasicBlock *funcBB1 = BasicBlock::Create(getGlobalContext(),\"isf\", ctx->f);\n        BasicBlock *elseBB1 = BasicBlock::Create(getGlobalContext(),\"notf\");\n        BasicBlock *mergeBB1 = BasicBlock::Create(getGlobalContext(),\"mergef\");\n        builder.CreateCondBr(isfunc, funcBB1, elseBB1);\n\n        builder.SetInsertPoint(funcBB1);\n        // is function\n        Value *myargs;\n        if (nargs > 0)\n            myargs = emit_temp_slot(argStart + 1, ctx); // argStart holds theFunc, argStart + 1 holds the start of the argument list\n        else\n            myargs = Constant::getNullValue(jl_ppvalue_llvmt); // no arguments\n        theFptr = emit_nthptr_recast(theFunc, (ssize_t)(offsetof(jl_function_t,fptr)/sizeof(void*)), tbaa_func, jl_pfptr_llvmt);\n#ifdef LLVM37\n        Value *r1 = builder.CreateCall(prepare_call(theFptr), {theFunc, myargs,\n                                        ConstantInt::get(T_int32,nargs)});\n#else\n        Value *r1 = builder.CreateCall3(prepare_call(theFptr), theFunc, myargs,\n                                        ConstantInt::get(T_int32,nargs));\n#endif\n        builder.CreateBr(mergeBB1);\n        ctx->f->getBasicBlockList().push_back(elseBB1);\n        builder.SetInsertPoint(elseBB1);\n        // not function\n        myargs = emit_temp_slot(argStart, ctx);\n        jl_value_t *call_func = (jl_value_t*)jl_module_call_func(ctx->module);\n        Value *r2;\n        if (!jl_is_gf(call_func)) {\n            just_emit_error(\"\\\"call\\\" is not a generic function\", ctx);\n            r2 = UndefValue::get(jl_pvalue_llvmt);\n        }\n        else {\n#ifdef LLVM37\n            r2 = builder.CreateCall(prepare_call(jlapplygeneric_func),\n                                    {literal_pointer_val(call_func),\n                                     myargs,\n                                     ConstantInt::get(T_int32, nargs + 1)});\n#else\n            r2 = builder.CreateCall3(prepare_call(jlapplygeneric_func),\n                                     literal_pointer_val(call_func),\n                                     myargs,\n                                     ConstantInt::get(T_int32, nargs + 1));\n#endif\n        }\n        builder.CreateBr(mergeBB1);\n        ctx->f->getBasicBlockList().push_back(mergeBB1);\n        builder.SetInsertPoint(mergeBB1);\n        PHINode *ph = builder.CreatePHI(jl_pvalue_llvmt, 2);\n        ph->addIncoming(r1, funcBB1);\n        ph->addIncoming(r2, elseBB1);\n        result = ph;\n    }\n\n    ctx->gc.argDepth = last_depth; // remove the arguments from the gc stack\n    JL_GC_POP();\n    return result;\n}\n\n// --- accessing and assigning variables ---\n\nstatic bool isBoxed(jl_sym_t *varname, jl_codectx_t *ctx)\n{\n    std::map<jl_sym_t*,jl_varinfo_t>::iterator it = ctx->vars.find(varname);\n    if (it == ctx->vars.end())\n        return false;\n    jl_varinfo_t &vi = (*it).second;\n    return vi.isAssigned && vi.isCaptured;\n}\n\nstatic int is_var_closed(jl_sym_t *s, jl_codectx_t *ctx)\n{\n    std::map<jl_sym_t*,jl_varinfo_t>::iterator it = ctx->vars.find(s);\n    if (it == ctx->vars.end())\n        return false;\n    jl_varinfo_t &vi = (*it).second;\n    return (vi.closureidx != -1);\n}\n\nstatic int is_global(jl_sym_t *s, jl_codectx_t *ctx)\n{\n    std::map<jl_sym_t*,jl_varinfo_t>::iterator it = ctx->vars.find(s);\n    return (it == ctx->vars.end());\n}\n\nstatic void undef_var_error_if_null(Value *v, jl_sym_t *name, jl_codectx_t *ctx)\n{\n    Value *ok = builder.CreateICmpNE(v, V_null);\n    BasicBlock *err = BasicBlock::Create(getGlobalContext(), \"err\", ctx->f);\n    BasicBlock *ifok = BasicBlock::Create(getGlobalContext(), \"ok\");\n    builder.CreateCondBr(ok, ifok, err);\n    builder.SetInsertPoint(err);\n    builder.CreateCall(prepare_call(jlundefvarerror_func), literal_pointer_val((jl_value_t*)name));\n    builder.CreateUnreachable();\n    ctx->f->getBasicBlockList().push_back(ifok);\n    builder.SetInsertPoint(ifok);\n}\n\nstatic Value *global_binding_pointer(jl_module_t *m, jl_sym_t *s,\n                                     jl_binding_t **pbnd, bool assign, jl_codectx_t *ctx)\n{\n    jl_binding_t *b=NULL;\n    if (assign) {\n        b = jl_get_binding_wr(m, s);\n        assert(b != NULL);\n    }\n    else {\n        b = jl_get_binding(m, s);\n        if (b == NULL) {\n            // var not found. switch to delayed lookup.\n            Constant *initnul = ConstantPointerNull::get((PointerType*)jl_pvalue_llvmt);\n            GlobalVariable *bindinggv =\n                new GlobalVariable(*jl_Module, jl_pvalue_llvmt,\n                                   false, GlobalVariable::PrivateLinkage,\n                                   initnul, \"delayedvar\");\n            Value *cachedval = builder.CreateLoad(bindinggv);\n            BasicBlock *have_val = BasicBlock::Create(jl_LLVMContext, \"found\"),\n                *not_found = BasicBlock::Create(jl_LLVMContext, \"notfound\");\n            BasicBlock *currentbb = builder.GetInsertBlock();\n            builder.CreateCondBr(builder.CreateICmpNE(cachedval, initnul), have_val, not_found);\n            ctx->f->getBasicBlockList().push_back(not_found);\n            builder.SetInsertPoint(not_found);\n#ifdef LLVM37\n            Value *bval = builder.CreateCall(prepare_call(jlgetbindingorerror_func),\n                                              {literal_pointer_val((jl_value_t*)m),\n                                              literal_pointer_val((jl_value_t*)s)});\n#else\n            Value *bval = builder.CreateCall2(prepare_call(jlgetbindingorerror_func),\n                                              literal_pointer_val((jl_value_t*)m),\n                                              literal_pointer_val((jl_value_t*)s));\n#endif\n            builder.CreateStore(bval, bindinggv);\n            builder.CreateBr(have_val);\n            ctx->f->getBasicBlockList().push_back(have_val);\n            builder.SetInsertPoint(have_val);\n            PHINode *p = builder.CreatePHI(jl_pvalue_llvmt, 2);\n            p->addIncoming(cachedval, currentbb);\n            p->addIncoming(bval, not_found);\n            return julia_binding_gv(builder.CreateBitCast(p,jl_ppvalue_llvmt));\n        }\n        if (b->deprecated) cg_bdw(b, ctx);\n    }\n    if (pbnd) *pbnd = b;\n    return julia_binding_gv(b);\n}\n\nstatic bool is_stack(Value *v)\n{\n    if (isa<AllocaInst>(v)) return true;\n    GetElementPtrInst *i = dyn_cast<GetElementPtrInst>(v);\n    if (i && is_stack(i->getOperand(0))) return true;\n    return false;\n}\n\n// yields a jl_value_t** giving the binding location of a variable\nstatic Value *var_binding_pointer(jl_sym_t *s, jl_binding_t **pbnd,\n                                  bool assign, jl_codectx_t *ctx)\n{\n    if (jl_is_symbolnode(s))\n        s = jl_symbolnode_sym(s);\n    assert(jl_is_symbol(s));\n    if (is_global(s, ctx)) {\n        return global_binding_pointer(ctx->module, s, pbnd, assign, ctx);\n    }\n    jl_varinfo_t &vi = ctx->vars[s];\n    if (vi.closureidx != -1) {\n        int idx = vi.closureidx;\n        assert(((Value*)ctx->envArg)->getType() == jl_pvalue_llvmt);\n        if (isBoxed(s, ctx)) {\n            return builder.CreatePointerCast(emit_nthptr((Value*)ctx->envArg, idx+1, tbaa_sveclen), jl_ppvalue_llvmt);\n        }\n        return emit_nthptr_addr((Value*)ctx->envArg, idx+1);\n    }\n    Value *l = vi.memvalue;\n    if (l == NULL) return NULL;\n    if (isBoxed(s, ctx)) {\n        return builder.CreatePointerCast(builder.CreateLoad(l), jl_ppvalue_llvmt);\n    }\n    return l;\n}\n\nstatic Value *emit_checked_var(Value *bp, jl_sym_t *name, jl_codectx_t *ctx, bool isvol)\n{\n    Value *v = tpropagate(bp, builder.CreateLoad(bp, isvol));\n    // in unreachable code, there might be a poorly-typed instance of a variable\n    // that has a concrete type everywhere it's actually used. tolerate this\n    // situation by just skipping the NULL check if it wouldn't be valid. (issue #7836)\n    if (v->getType() == jl_pvalue_llvmt)\n        undef_var_error_if_null(v, name, ctx);\n    return v;\n}\n\nstatic Value *ghostValue(jl_value_t *ty)\n{\n    assert(ty == (jl_value_t*)jl_bottom_type || jl_is_datatype(ty));\n    return mark_julia_type(UndefValue::get(NoopType),ty);\n}\n\nstatic Value *emit_var(jl_sym_t *sym, jl_value_t *ty, jl_codectx_t *ctx, bool isboxed)\n{\n    bool isglobal = is_global(sym, ctx);\n    if (isglobal) {\n        // look for static parameter\n        for(size_t i=0; i < jl_svec_len(ctx->sp); i+=2) {\n            assert(jl_is_symbol(jl_svecref(ctx->sp, i)));\n            if (sym == (jl_sym_t*)jl_svecref(ctx->sp, i)) {\n                return literal_pointer_val(jl_svecref(ctx->sp, i+1));\n            }\n        }\n        jl_binding_t *jbp=NULL;\n        Value *bp = var_binding_pointer(sym, &jbp, false, ctx);\n        if (bp == NULL)\n            return NULL;\n        if (jbp && jbp->value != NULL) {\n            if (jbp->constp) {\n                if (!isboxed && jl_isbits(jl_typeof(jbp->value)))\n                    return emit_unboxed(jbp->value, ctx);\n            }\n            // double-check that a global variable is actually defined. this\n            // can be a problem in parallel when a definition is missing on\n            // one machine.\n            return tpropagate(bp, builder.CreateLoad(bp));\n        }\n        return emit_checked_var(bp, sym, ctx);\n    }\n\n    jl_varinfo_t &vi = ctx->vars[sym];\n\n    Value *arg = vi.passedAs;\n    if (arg!=NULL && arg!=V_null && !vi.isAssigned &&\n        (isboxed || vi.memvalue == NULL)) {\n        // if we need a boxed version of an argument that's not assigned,\n        // use the original value.\n        return arg;\n    }\n    if (vi.SAvalue != NULL)\n        return vi.SAvalue;\n\n    jl_binding_t *jbp=NULL;\n    Value *bp = var_binding_pointer(sym, &jbp, false, ctx);\n    if (bp == NULL) {\n        assert(vi.isGhost);\n        return ghostValue(ty);\n    }\n    assert(jbp == NULL);\n    if (arg != NULL ||    // arguments are always defined\n        ((!is_var_closed(sym, ctx) || !vi.isAssigned) && !vi.usedUndef)) {\n        if (bp->getType()->getContainedType(0)->isAggregateType())\n            return bp;\n        Value *theLoad = builder.CreateLoad(bp, vi.isVolatile);\n        if (vi.closureidx > -1 && !(vi.isAssigned && vi.isCaptured))\n            theLoad = tbaa_decorate(tbaa_const, (Instruction*)theLoad);\n        return tpropagate(bp, theLoad);\n    }\n    return emit_checked_var(bp, sym, ctx, vi.isVolatile);\n}\n\nstatic Value *emit_assignment(Value *bp, jl_value_t *r, jl_value_t *declType, bool isVolatile, bool used, jl_codectx_t *ctx)\n{\n    Value *rval;\n    jl_value_t *rt = expr_type(r,ctx);\n    if (bp != NULL) {\n        if ((jl_is_symbol(r) || jl_is_symbolnode(r) || jl_is_gensym(r)) && rt == jl_bottom_type) {\n            // sometimes x = y::Union{} occurs\n            if (!jl_is_gensym(r)) {\n                jl_sym_t *s;\n                if (jl_is_symbolnode(r))\n                    s = jl_symbolnode_sym(r);\n                else\n                    s = (jl_sym_t*)r;\n                jl_varinfo_t &vi = ctx->vars[s];\n                if (vi.usedUndef)\n                    builder.CreateCall(prepare_call(jlundefvarerror_func), literal_pointer_val((jl_value_t*)s));\n            }\n            return UndefValue::get(bp->getType()->getContainedType(0));\n        }\n        Type *vt = bp->getType();\n        if (vt != jl_ppvalue_llvmt) { // unboxed store (in an alloca)\n            // `rt` is technically correct here, but sometimes we're not propagating type information\n            // properly, so `rt` is a union type, while LLVM know that it's not. However, in order for this to\n            // happen, we need to already be sure somewhere that we have the right type, so vi.declType is fine\n            // even if not technically correct.\n            rval = mark_julia_type(emit_unbox(vt->getContainedType(0), emit_unboxed(r, ctx), declType), declType);\n        }\n        else {\n            rval = boxed(emit_expr(r, ctx, true),ctx,rt);\n            if (!is_stack(bp)) { // bp is a jl_box_t*\n                emit_write_barrier(ctx, bp, rval);\n            }\n        }\n        if (builder.GetInsertBlock()->getTerminator() == NULL) {\n            builder.CreateStore(rval, bp, isVolatile);\n        }\n    }\n    else {\n        rval = emit_expr(r, ctx, true);\n\n        // don't need to store this if it isn't used\n        // and sometimes we can get x::Union{} = Expr(:tuple)::() in dead code\n        if (!used || declType == jl_bottom_type)\n            return UndefValue::get(rval->getType());\n\n        // Make sure this is already boxed. If not, there was\n        // something wrong in the earlier analysis as this should\n        // have been alloca'd\n        assert(rval->getType() == jl_pvalue_llvmt || rval->getType() == NoopType);\n    }\n    assert(rval);\n    return rval;\n}\n\nstatic void emit_assignment(jl_value_t *l, jl_value_t *r, jl_codectx_t *ctx)\n{\n    if (jl_is_gensym(l)) {\n        ssize_t idx = ((jl_gensym_t*)l)->id;\n        assert(idx >= 0);\n        assert(!ctx->gensym_assigned.at(idx));\n        jl_value_t *gensym_types = jl_lam_gensyms(ctx->ast);\n        jl_value_t *declType = (jl_is_array(gensym_types) ? jl_cellref(gensym_types, idx) : (jl_value_t*)jl_any_type);\n        Value *bp = NULL;\n        if (store_unboxed_p(declType)) {\n            Type *vtype = julia_struct_to_llvm(declType);\n            assert(vtype != jl_pvalue_llvmt);\n            if (!type_is_ghost(vtype)) {\n                // add a stack slot for this (non-ghost) GenSym node\n                bp = mark_julia_type(emit_static_alloca(vtype, ctx), declType);\n            }\n        }\n        else if (!is_stable_expr(r, ctx)) {\n            // add a gc root for this GenSym node\n            bp = emit_local_slot(ctx->gc.argSpaceSize++, ctx);\n        }\n        Value *rval = emit_assignment(bp, r, declType, false, true, ctx);\n        if (!julia_type_to_llvm(declType)->isAggregateType())\n            ctx->gensym_SAvalues.at(idx) = rval; // now gensym_SAvalues[idx] contains the SAvalue\n        else\n            ctx->gensym_SAvalues.at(idx) = bp;\n        assert(ctx->gensym_assigned.at(idx) = true);\n        return;\n    }\n    jl_sym_t *s = NULL;\n    jl_binding_t *bnd=NULL;\n    Value *bp=NULL;\n    if (jl_is_symbol(l))\n        s = (jl_sym_t*)l;\n    else if (jl_is_symbolnode(l))\n        s = jl_symbolnode_sym(l);\n    else if (jl_is_globalref(l))\n        bp = global_binding_pointer(jl_globalref_mod(l), jl_globalref_name(l), &bnd, true, ctx);\n    else\n        assert(false);\n    if (bp == NULL)\n        bp = var_binding_pointer(s, &bnd, true, ctx);\n    if (bnd) {\n        Value *rval = boxed(emit_expr(r, ctx, true),ctx);\n#ifdef LLVM37\n        builder.CreateCall(prepare_call(jlcheckassign_func),\n                           {literal_pointer_val(bnd),\n                            rval});\n#else\n        builder.CreateCall2(prepare_call(jlcheckassign_func),\n                           literal_pointer_val(bnd),\n                            rval);\n#endif\n        // Global variable. Does not need debug info because the debugger knows about\n        // its memory location.\n    }\n    else {\n        jl_varinfo_t &vi = ctx->vars[s];\n\n        if (!bp && !vi.hasGCRoot && vi.used && !vi.isArgument &&\n                !is_stable_expr(r, ctx)) {\n            Instruction *newroot = cast<Instruction>(emit_local_slot(ctx->gc.argSpaceSize++, ctx));\n            newroot->removeFromParent(); // move it to the gc frame basic block so it can be reused as needed\n            newroot->insertAfter(&*ctx->gc.last_gcframe_inst);\n            vi.memvalue = bp = newroot;\n            vi.hasGCRoot = true; // this has been discovered to need a gc root, add it now\n            //TODO: move this logic after the emit_expr\n        }\n        Value *rval = emit_assignment(bp, r, vi.declType, vi.isVolatile, vi.used, ctx);\n\n        if (vi.isSA &&\n            ((bp == NULL) ||\n             (!vi.isCaptured && !vi.isArgument &&\n              !vi.usedUndef && !vi.isVolatile))) {\n            // use SSA value instead of GC frame load for var access\n            if (bp && bp->getType()->getContainedType(0)->isAggregateType())\n                vi.SAvalue = bp;\n            else\n                vi.SAvalue = rval;\n        }\n\n        if (!isa<UndefValue>(rval) && builder.GetInsertBlock()->getTerminator() == NULL) {\n            jl_arrayvar_t *av = arrayvar_for(l, ctx);\n            if (av != NULL) {\n                assign_arrayvar(*av, rval);\n            }\n        }\n    }\n}\n\n// --- convert expression to code ---\n\nstatic Value *emit_condition(jl_value_t *cond, const std::string &msg, jl_codectx_t *ctx)\n{\n    Value *condV = emit_unboxed(cond, ctx);\n    if (expr_type(cond, ctx) != (jl_value_t*)jl_bool_type &&\n        condV->getType() != T_int1) {\n        emit_typecheck(condV, (jl_value_t*)jl_bool_type, msg, ctx);\n    }\n    if (condV->getType() == T_int1) {\n        return builder.CreateXor(condV, ConstantInt::get(T_int1,1));\n    }\n    else if (condV->getType() == jl_pvalue_llvmt) {\n        return builder.CreateICmpEQ(condV, tbaa_decorate(tbaa_const, builder.CreateLoad(prepare_global(jlfalse_var))));\n    }\n    // not a boolean\n    return ConstantInt::get(T_int1,0);\n}\n\nstatic Value *emit_expr(jl_value_t *expr, jl_codectx_t *ctx, bool isboxed, bool valuepos)\n{\n    if (jl_is_symbol(expr)) {\n        if (!valuepos) return NULL;\n        jl_sym_t *sym = (jl_sym_t*)expr;\n        return emit_var(sym, (jl_value_t*)jl_any_type, ctx, isboxed);\n    }\n    if (jl_is_symbolnode(expr)) {\n        if (!valuepos) return NULL;\n        jl_sym_t *sym = jl_symbolnode_sym(expr);\n        return emit_var(sym, jl_symbolnode_type(expr), ctx, isboxed);\n    }\n    if (jl_is_gensym(expr)) {\n        if (!valuepos) return NULL;\n        ssize_t idx = ((jl_gensym_t*)expr)->id;\n        assert(idx >= 0);\n        assert(ctx->gensym_assigned.at(idx));\n        Value *bp = ctx->gensym_SAvalues.at(idx); // at this point, gensym_SAvalues[idx] actually contains the SAvalue\n        if (bp == NULL || type_is_ghost(bp->getType())) {\n            // assert(vi.isGhost);\n            jl_value_t *gensym_types = jl_lam_gensyms(ctx->ast);\n            jl_value_t *declType = (jl_is_array(gensym_types) ? jl_cellref(gensym_types, idx) : (jl_value_t*)jl_any_type);\n            return ghostValue(declType);\n        }\n        return bp;\n    }\n    if (jl_is_labelnode(expr)) {\n        int labelname = jl_labelnode_label(expr);\n        BasicBlock *bb = (*ctx->labels)[labelname];\n        assert(bb);\n        if (builder.GetInsertBlock()->getTerminator() == NULL) {\n            builder.CreateBr(bb); // all BasicBlocks must exit explicitly\n        }\n        ctx->f->getBasicBlockList().push_back(bb);\n        builder.SetInsertPoint(bb);\n        return NULL;\n    }\n    if (jl_is_linenode(expr)) {\n        if (valuepos)\n            jl_error(\"Linenode in value position\");\n        return NULL;\n    }\n    if (jl_is_gotonode(expr)) {\n        if (builder.GetInsertBlock()->getTerminator() == NULL) {\n            int labelname = jl_gotonode_label(expr);\n            BasicBlock *bb = (*ctx->labels)[labelname];\n            assert(bb);\n            builder.CreateBr(bb);\n            BasicBlock *after = BasicBlock::Create(getGlobalContext(),\n                                                   \"br\", ctx->f);\n            builder.SetInsertPoint(after);\n        }\n        return NULL;\n    }\n    if (jl_is_globalref(expr)) {\n        return emit_getfield((jl_value_t*)jl_globalref_mod(expr), jl_globalref_name(expr), ctx);\n    }\n    if (jl_is_topnode(expr)) {\n        jl_sym_t *var = (jl_sym_t*)jl_fieldref(expr,0);\n        jl_module_t *mod = topmod(ctx);\n        jl_binding_t *b = jl_get_binding(mod, var);\n        if (b == NULL)\n            b = jl_get_binding_wr(mod, var);\n        Value *bp = julia_binding_gv(b);\n        if (b->constp && b->value!=NULL) {\n            return builder.CreateLoad(bp, false);\n        }\n        return emit_checked_var(bp, var, ctx);\n    }\n    if (jl_is_newvarnode(expr)) {\n        assert(!valuepos);\n        jl_sym_t *var = (jl_sym_t*)jl_fieldref(expr,0);\n        assert(!jl_is_gensym(var));\n        assert(jl_is_symbol(var));\n        jl_varinfo_t &vi = ctx->vars[var];\n        Value *lv = vi.memvalue;\n        if (lv != NULL) {\n            // create a new uninitialized variable\n            if (isBoxed(var, ctx)) {\n                builder.CreateStore(builder.CreateCall(prepare_call(jlbox_func), V_null), lv);\n            }\n            else if (lv->getType() == jl_ppvalue_llvmt && vi.usedUndef) {\n                builder.CreateStore(V_null, lv);\n            }\n        }\n        return NULL;\n    }\n    if (jl_is_lambda_info(expr)) {\n        return emit_lambda_closure(expr, ctx);\n    }\n    if (!jl_is_expr(expr)) {\n        int needroot = true;\n        if (jl_is_quotenode(expr)) {\n            expr = jl_fieldref(expr,0);\n            if (jl_is_symbol(expr)) {\n                needroot = false;\n            }\n        }\n        // numeric literals\n        if (jl_is_int32(expr)) {\n            int32_t val = jl_unbox_int32(expr);\n            if ((uint32_t)(val+512) < 1024) {\n                // this can be gotten from the box cache\n                needroot = false;\n                expr = jl_box_int32(val);\n            }\n        }\n        else if (jl_is_int64(expr)) {\n            uint64_t val = jl_unbox_uint64(expr);\n            if ((uint64_t)(val+512) < 1024) {\n                // this can be gotten from the box cache\n                needroot = false;\n                expr = jl_box_int64(val);\n            }\n        }\n        if (needroot) {\n            jl_add_linfo_root(ctx->linfo, expr);\n        }\n        return literal_pointer_val(expr);\n    }\n    jl_expr_t *ex = (jl_expr_t*)expr;\n    jl_value_t **args = (jl_value_t**)jl_array_data(ex->args);\n    jl_sym_t *head = ex->head;\n    // this is object-disoriented.\n    // however, this is a good way to do it because it should *not* be easy\n    // to add new node types.\n    if (head == goto_ifnot_sym) {\n        jl_value_t *cond = args[0];\n        int labelname = jl_unbox_long(args[1]);\n        BasicBlock *ifso = BasicBlock::Create(getGlobalContext(), \"if\", ctx->f);\n        BasicBlock *ifnot = (*ctx->labels)[labelname];\n        assert(ifnot);\n        // NOTE: if type inference sees a constant condition it behaves as if\n        // the branch weren't there. But LLVM will not see constant conditions\n        // this way until a later optimization pass, so it might see one of our\n        // SSA vars as not dominating all uses. see issue #6068\n        // Work around this by generating unconditional branches.\n        if (cond == jl_true) {\n            builder.CreateBr(ifso);\n        }\n        else if (cond == jl_false) {\n            builder.CreateBr(ifnot);\n        }\n        else {\n            Value *isfalse = emit_condition(cond, \"if\", ctx);\n            builder.CreateCondBr(isfalse, ifnot, ifso);\n        }\n        builder.SetInsertPoint(ifso);\n    }\n    else if (head == call_sym) {\n        return emit_call(args, jl_array_dim0(ex->args), ctx, (jl_value_t*)ex);\n    }\n    else if (head == assign_sym) {\n        emit_assignment(args[0], args[1], ctx);\n        if (valuepos) {\n            return literal_pointer_val((jl_value_t*)jl_nothing);\n        }\n    }\n    else if (head == method_sym) {\n        jl_value_t *mn = args[0];\n        bool iskw = false;\n        Value *theF = NULL;\n        if (jl_is_expr(mn) || jl_is_globalref(mn)) {\n            if (jl_is_expr(mn) && ((jl_expr_t*)mn)->head == kw_sym) {\n                iskw = true;\n                mn = jl_exprarg(mn,0);\n            }\n            theF = emit_expr(mn, ctx);\n            if (jl_is_expr(mn)) {\n                mn = jl_fieldref(jl_exprarg(mn, 2), 0);\n            }\n        }\n        if (jl_is_symbolnode(mn)) {\n            mn = (jl_value_t*)jl_symbolnode_sym(mn);\n        }\n        assert(jl_is_symbol(mn));\n        int last_depth = ctx->gc.argDepth;\n        Value *name = literal_pointer_val(mn);\n        jl_binding_t *bnd = NULL;\n        Value *bp, *bp_owner = V_null;\n        if (theF != NULL) {\n            bp = make_gcroot(theF, ctx);\n        }\n        else {\n            if (is_global((jl_sym_t*)mn, ctx)) {\n                bnd = jl_get_binding_for_method_def(ctx->module, (jl_sym_t*)mn);\n                bp = julia_binding_gv(bnd);\n                bp_owner = literal_pointer_val((jl_value_t*)ctx->module);\n            }\n            else {\n                bp = var_binding_pointer((jl_sym_t*)mn, &bnd, false, ctx);\n                if (isBoxed((jl_sym_t*)mn, ctx)) { // bp is a jl_box_t*\n                    bp_owner = builder.CreateBitCast(bp, jl_pvalue_llvmt);\n                }\n            }\n        }\n        if (jl_expr_nargs(ex) == 1) {\n            Value *mdargs[4] = { name, bp, bp_owner, literal_pointer_val(bnd) };\n            return builder.CreateCall(prepare_call(jlgenericfunction_func), ArrayRef<Value*>(&mdargs[0], 4));\n        }\n        else {\n            Value *a1 = boxed(emit_expr(args[1], ctx),ctx);\n            make_gcroot(a1, ctx);\n            Value *a2 = boxed(emit_expr(args[2], ctx),ctx);\n            make_gcroot(a2, ctx);\n            Value *mdargs[9] =\n                { name, bp, bp_owner, literal_pointer_val(bnd), a1, a2, literal_pointer_val(args[3]),\n                  literal_pointer_val((jl_value_t*)jl_module_call_func(ctx->module)),\n                  ConstantInt::get(T_int32, (int)iskw) };\n            ctx->gc.argDepth = last_depth;\n            return builder.CreateCall(prepare_call(jlmethod_func), ArrayRef<Value*>(&mdargs[0], 9));\n        }\n    }\n    else if (head == const_sym) {\n        jl_sym_t *sym = (jl_sym_t*)args[0];\n        assert(jl_is_symbol(sym));\n        jl_binding_t *bnd = NULL;\n        (void)var_binding_pointer(sym, &bnd, true, ctx);\n        if (bnd) {\n            builder.CreateCall(prepare_call(jldeclareconst_func),\n                               literal_pointer_val(bnd));\n        }\n    }\n\n    else if (head == null_sym) {\n        return literal_pointer_val((jl_value_t*)jl_nothing);\n    }\n    else if (head == static_typeof_sym) {\n        jl_value_t *extype = expr_type((jl_value_t*)ex, ctx);\n        if (jl_is_type_type(extype)) {\n            extype = jl_tparam0(extype);\n            if (jl_is_typevar(extype))\n                extype = ((jl_tvar_t*)extype)->ub;\n        }\n        else {\n            extype = (jl_value_t*)jl_any_type;\n        }\n        if (jl_is_tuple_type(extype))\n            jl_add_linfo_root(ctx->linfo, extype);\n        return literal_pointer_val(extype);\n    }\n    else if (head == new_sym) {\n        jl_value_t *ty = expr_type(args[0], ctx);\n        size_t nargs = jl_array_len(ex->args);\n        if (jl_is_type_type(ty) &&\n            jl_is_datatype(jl_tparam0(ty)) &&\n            jl_is_leaf_type(jl_tparam0(ty))) {\n            return emit_new_struct(jl_tparam0(ty),nargs,args,ctx);\n        }\n        Value *typ = emit_expr(args[0], ctx);\n        return emit_jlcall(jlnew_func, typ, &args[1], nargs-1, ctx);\n    }\n    else if (head == exc_sym) {\n        return builder.CreateLoad(prepare_global(jlexc_var), true);\n    }\n    else if (head == leave_sym) {\n        assert(jl_is_long(args[0]));\n        builder.CreateCall(prepare_call(jlleave_func),\n                           ConstantInt::get(T_int32, jl_unbox_long(args[0])));\n    }\n    else if (head == enter_sym) {\n        assert(jl_is_long(args[0]));\n        int labl = jl_unbox_long(args[0]);\n        Value *jbuf = builder.CreateGEP((*ctx->handlers)[labl],\n                                        ConstantInt::get(T_size,0));\n        builder.CreateCall(prepare_call(jlenter_func), jbuf);\n#ifndef _OS_WINDOWS_\n#ifdef LLVM37\n        CallInst *sj = builder.CreateCall(prepare_call(setjmp_func), { jbuf, ConstantInt::get(T_int32,0) });\n#else\n        CallInst *sj = builder.CreateCall2(prepare_call(setjmp_func), jbuf, ConstantInt::get(T_int32,0));\n#endif\n#else\n        CallInst *sj = builder.CreateCall(prepare_call(setjmp_func), jbuf);\n#endif\n        // We need to mark this on the call site as well. See issue #6757\n        sj->setCanReturnTwice();\n        Value *isz = builder.CreateICmpEQ(sj, ConstantInt::get(T_int32,0));\n        BasicBlock *tryblk = BasicBlock::Create(getGlobalContext(), \"try\",\n                                                ctx->f);\n        BasicBlock *handlr = (*ctx->labels)[labl];\n        assert(handlr);\n#ifdef _OS_WINDOWS_\n        BasicBlock *cond_resetstkoflw_blk = BasicBlock::Create(getGlobalContext(), \"cond_resetstkoflw\", ctx->f);\n        BasicBlock *resetstkoflw_blk = BasicBlock::Create(getGlobalContext(), \"resetstkoflw\", ctx->f);\n        builder.CreateCondBr(isz, tryblk, cond_resetstkoflw_blk);\n        builder.SetInsertPoint(cond_resetstkoflw_blk);\n        builder.CreateCondBr(builder.CreateICmpEQ(\n                    literal_pointer_val(jl_stackovf_exception),\n                    builder.CreateLoad(prepare_global(jlexc_var), true)),\n                resetstkoflw_blk, handlr);\n        builder.SetInsertPoint(resetstkoflw_blk);\n        builder.CreateCall(prepare_call(resetstkoflw_func)\n#                          ifdef LLVM37\n                           , {}\n#                          endif\n                           );\n        builder.CreateBr(handlr);\n#else\n        builder.CreateCondBr(isz, tryblk, handlr);\n#endif\n        builder.SetInsertPoint(tryblk);\n    }\n    else if (head == boundscheck_sym) {\n        if (jl_array_len(ex->args) > 0 &&\n            jl_options.check_bounds == JL_OPTIONS_CHECK_BOUNDS_DEFAULT) {\n            jl_value_t *arg = args[0];\n            if (arg == jl_true) {\n                ctx->boundsCheck.push_back(true);\n            }\n            else if (arg == jl_false) {\n                ctx->boundsCheck.push_back(false);\n            }\n            else {\n                if (!ctx->boundsCheck.empty())\n                    ctx->boundsCheck.pop_back();\n            }\n        }\n        if (valuepos)\n            return literal_pointer_val((jl_value_t*)jl_nothing);\n    }\n    else if (head == copyast_sym) {\n        jl_value_t *arg = args[0];\n        if (jl_is_quotenode(arg)) {\n            jl_value_t *arg1 = jl_fieldref(arg,0);\n            if (!((jl_is_expr(arg1) && ((jl_expr_t*)arg1)->head!=null_sym) ||\n                  jl_typeis(arg1,jl_array_any_type) || jl_is_quotenode(arg1))) {\n                // elide call to jl_copy_ast when possible\n                return emit_expr(arg, ctx);\n            }\n        }\n        return builder.CreateCall(prepare_call(jlcopyast_func), emit_expr(arg, ctx));\n    }\n    else if (head == simdloop_sym) {\n        if (!llvm::annotateSimdLoop(builder.GetInsertBlock()))\n            jl_printf(JL_STDERR, \"WARNING: could not attach metadata for @simd loop.\\n\");\n        return NULL;\n    }\n    else if (head == meta_sym) {\n        return literal_pointer_val((jl_value_t*)jl_nothing);  // will change as new metadata gets added\n    }\n    else {\n        if (!strcmp(head->name, \"$\"))\n            jl_error(\"syntax: prefix \\\"$\\\" in non-quoted expression\");\n        if (jl_is_toplevel_only_expr(expr) &&\n            ctx->linfo->name == anonymous_sym && ctx->vars.empty() &&\n            ctx->linfo->module == jl_current_module) {\n            // call interpreter to run a toplevel expr from inside a\n            // compiled toplevel thunk.\n            builder.CreateCall(prepare_call(jltopeval_func), literal_pointer_val(expr));\n            jl_add_linfo_root(ctx->linfo, expr);\n            return valuepos ? literal_pointer_val(jl_nothing) : NULL;\n        }\n        // some expression types are metadata and can be ignored\n        if (valuepos || !(head == line_sym || head == type_goto_sym)) {\n            if (head == abstracttype_sym || head == compositetype_sym ||\n                head == bitstype_sym) {\n                jl_errorf(\"type definition not allowed inside a local scope\");\n            }\n            else if (head == macro_sym) {\n                jl_errorf(\"macro definition not allowed inside a local scope\");\n            }\n            else {\n                jl_errorf(\"unsupported or misplaced expression \\\"%s\\\" in function %s\",\n                          head->name, ctx->linfo->name->name);\n            }\n        }\n    }\n    return NULL;\n}\n\n// --- generate function bodies ---\n\nextern \"C\" jl_svec_t *jl_svec_tvars_to_symbols(jl_svec_t *t);\n\n// gc frame emission\nstatic void allocate_gc_frame(size_t n_roots, BasicBlock *b0, jl_codectx_t *ctx)\n{\n    // allocate a placeholder gc frame\n    jl_gcinfo_t *gc = &ctx->gc;\n    gc->argSpaceSize = n_roots;\n    gc->argDepth = 0;\n    gc->maxDepth = 0;\n\n    gc->gcframe = builder.CreateAlloca(jl_pvalue_llvmt, ConstantInt::get(T_int32, 0));\n    gc->first_gcframe_inst = BasicBlock::iterator(gc->gcframe);\n    gc->argSlot = builder.CreateConstGEP1_32(gc->gcframe, 2);\n    gc->tempSlot = (GetElementPtrInst*)builder.CreateConstGEP1_32(gc->gcframe, 2);\n    gc->last_gcframe_inst = BasicBlock::iterator((Instruction*)gc->tempSlot);\n}\n\nstatic void clear_gc_frame(jl_gcinfo_t *gc)\n{\n    // replace instruction uses with Undef first to avoid LLVM assertion failures\n    BasicBlock::iterator bbi = gc->first_gcframe_inst;\n    while (1) {\n        Instruction &iii = *bbi;\n        Type *ty = iii.getType();\n        if (ty != T_void)\n            iii.replaceAllUsesWith(UndefValue::get(ty));\n        if (bbi == gc->last_gcframe_inst) break;\n        bbi++;\n    }\n    // Remove GC frame creation\n    // (instructions from gc->gcframe to gc->last_gcframe_inst)\n    BasicBlock::InstListType &il = gc->gcframe->getParent()->getInstList();\n    il.erase(gc->first_gcframe_inst, gc->last_gcframe_inst);\n    // erase() erases up *to* the end point; erase last inst too\n    il.erase(gc->last_gcframe_inst);\n}\n\nstatic void\nemit_gcpops(jl_codectx_t *ctx)\n{\n    Function *F = ctx->f;\n    for(Function::iterator I = F->begin(), E = F->end(); I != E; ++I) {\n        if (isa<ReturnInst>(I->getTerminator())) {\n            builder.SetInsertPoint(I->getTerminator()); // set insert *before* Ret\n            Instruction *gcpop =\n                (Instruction*)builder.CreateConstGEP1_32(ctx->gc.gcframe, 1);\n            builder.CreateStore(builder.CreatePointerCast(builder.CreateLoad(gcpop, false),\n                                                      jl_ppvalue_llvmt),\n                                prepare_global(jlpgcstack_var));\n        }\n    }\n}\n\nstatic void finalize_gc_frame(jl_codectx_t *ctx)\n{\n    jl_gcinfo_t *gc = &ctx->gc;\n    if (gc->argSpaceSize + gc->maxDepth == 0) {\n        // 0 roots; remove gc frame entirely\n        clear_gc_frame(gc);\n        return;\n    }\n    BasicBlock::iterator bbi(gc->gcframe);\n    AllocaInst *newgcframe = gc->gcframe;\n    builder.SetInsertPoint(&*++gc->last_gcframe_inst); // set insert *before* point, e.g. after the gcframe\n    // Allocate the real GC frame\n    // n_frames++;\n    newgcframe->setOperand(0, ConstantInt::get(T_int32, 2 + gc->argSpaceSize + gc->maxDepth)); // fix up the size of the gc frame\n    gc->tempSlot->setOperand(1, ConstantInt::get(T_int32, 2 + gc->argSpaceSize)); // fix up the offset to the temp slot space\n    builder.CreateStore(ConstantInt::get(T_size, (gc->argSpaceSize + gc->maxDepth) << 1),\n                        builder.CreateBitCast(builder.CreateConstGEP1_32(newgcframe, 0), T_psize));\n    builder.CreateStore(builder.CreateLoad(prepare_global(jlpgcstack_var)),\n                        builder.CreatePointerCast(builder.CreateConstGEP1_32(newgcframe, 1), PointerType::get(jl_ppvalue_llvmt,0)));\n    builder.CreateStore(newgcframe, prepare_global(jlpgcstack_var));\n    // Initialize the slots for temporary variables to NULL\n    for (int i = 0; i < gc->argSpaceSize; i++) {\n        Value *argTempi = emit_local_slot(i, ctx);\n        builder.CreateStore(V_null, argTempi);\n    }\n    for (int i = 0; i < gc->maxDepth; i++) {\n        Value *argTempi = emit_temp_slot(i, ctx);\n        builder.CreateStore(V_null, argTempi);\n    }\n    emit_gcpops(ctx);\n}\n\nstatic Function *gen_cfun_wrapper(jl_function_t *ff, jl_value_t *jlrettype, jl_tupletype_t *argt, int64_t isref)\n{\n    jl_lambda_info_t *lam = ff->linfo;\n    cFunctionList_t *list = (cFunctionList_t*)lam->cFunctionList;\n    if (list != NULL) {\n        size_t i;\n        for (i = 0; i < list->len; i++) {\n            if (list->data[i].isref == isref) {\n                return list->data[i].f;\n            }\n        }\n    }\n    // Generate a c-callable wrapper\n    Type *crt = ((isref&1) ? jl_pvalue_llvmt : julia_struct_to_llvm(jlrettype));\n    if (crt == NULL)\n        jl_error(\"cfunction: return type doesn't correspond to a C type\");\n    size_t i;\n    size_t nargs = jl_nparams(argt);\n    for(i=0; i < nargs; i++) {\n        jl_value_t *tti = jl_nth_slot_type(lam->specTypes,i);\n        if (tti == (jl_value_t*)jl_pointer_type) {\n            jl_error(\"cfunction: argument type Ptr should have an element type, Ptr{T}\");\n        }\n    }\n\n    std::vector<Type*> fargt(0);\n    std::vector<Type*> fargt_sig(0);\n    Type* fargt_vasig;\n    std::vector<bool> inRegList(0);\n    std::vector<bool> byRefList(0);\n    attr_type attrs;\n    Type *prt = NULL;\n    int sret = 0;\n    std::string err_msg = generate_func_sig(&crt, &prt, sret, fargt, fargt_sig, fargt_vasig, inRegList, byRefList, attrs,\n                                            ((isref&1) ? (jl_value_t*)jl_any_type : jlrettype), argt->parameters);\n    if (!err_msg.empty())\n        jl_error(err_msg.c_str());\n    if (fargt.size() != fargt_sig.size())\n        jl_error(\"va_arg syntax not allowed for cfunction argument list\");\n\n    jl_compile(ff);\n    if (!lam->functionObject) {\n        jl_errorf(\"error compiling %s while creating cfunction\", lam->name->name);\n    }\n\n    std::stringstream funcName;\n    funcName << \"jlcapi_\" << lam->name->name << \"_\" << globalUnique++;\n\n    // Backup the info for the nested compile\n    JL_SIGATOMIC_BEGIN(); // no errors expected beyond this point\n    BasicBlock *old = nested_compile ? builder.GetInsertBlock() : NULL;\n    DebugLoc olddl = builder.getCurrentDebugLocation();\n    bool last_n_c = nested_compile;\n    nested_compile = true;\n    jl_gc_inhibit_finalizers(nested_compile); // no allocations expected between the top of this function (when last scanned lam->cFunctionList) and here, which might have triggered running julia code\n\n    // Create the Function stub\n    Module *m;\n#ifdef USE_MCJIT\n    if (!imaging_mode) {\n        m = new Module(funcName.str(), jl_LLVMContext);\n        jl_setup_module(m,true);\n    }\n    else {\n        m = shadow_module;\n    }\n#else\n    m = jl_Module;\n#endif\n\n    Function *cw = Function::Create(FunctionType::get(sret ? T_void : prt, fargt_sig, false),\n            imaging_mode ? GlobalVariable::InternalLinkage : GlobalVariable::ExternalLinkage,\n            funcName.str(), m);\n    cw->setAttributes(attrs);\n    BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", cw);\n    builder.SetInsertPoint(b0);\n    DebugLoc noDbg;\n    builder.SetCurrentDebugLocation(noDbg);\n\n    jl_codectx_t ctx;\n    ctx.f = cw;\n    ctx.linfo = lam;\n    ctx.sret = false;\n    allocate_gc_frame(0, b0, &ctx);\n\n    // Save the Function object reference\n    int len = (list ? list->len : 0) + 1;\n    cFunctionList_t *list2 = (cFunctionList_t*)realloc(list, sizeof(*list)+sizeof(list->data[0])*len);\n    if (!list2)\n        jl_throw(jl_memory_exception);\n    list2->len = len;\n    list2->data[len-1].isref = isref;\n    list2->data[len-1].f = cw;\n    lam->cFunctionList = list2;\n\n    // See whether this function is specsig or jlcall\n    bool specsig, jlfunc_sret;\n    Function *theFptr;\n    if (lam->specFunctionObject != NULL) {\n        theFptr = (Function*)lam->specFunctionObject;\n        specsig = true;\n        jlfunc_sret = theFptr->hasStructRetAttr();\n    }\n    else {\n        theFptr = (Function*)lam->functionObject;\n        specsig = false;\n        jlfunc_sret = false;\n    }\n    assert(theFptr);\n\n    // Alright, let's do this!\n    // let's first emit the arguments\n    std::vector<Value*> args;\n    Function::arg_iterator AI = cw->arg_begin();\n    Value *sretPtr = NULL;\n    if (sret)\n        sretPtr = &*AI++;\n\n    Value *result;\n    size_t FParamIndex = 0;\n    if (jlfunc_sret) {\n        if (sret)\n            result = sretPtr;\n        else\n            result = builder.CreateAlloca(theFptr->getFunctionType()->getParamType(0)->getContainedType(0));\n        args.push_back(result);\n        FParamIndex++;\n    }\n\n    for (size_t i = 0; i < nargs; i++) {\n        Value *val = &*AI++;\n        jl_value_t *jargty = jl_nth_slot_type(lam->specTypes, i);\n\n        // figure out how to unpack this type\n        if (isref & (2<<i)) {\n            if (!jl_isbits(jargty)) {\n                val = builder.CreatePointerCast(val, jl_pvalue_llvmt);\n            }\n            else {\n                Type *t = julia_type_to_llvm(jargty);\n                if (type_is_ghost(t)) {\n                    if (specsig) {\n                        continue; // ghost types are skipped by the specsig method signature\n                    }\n                    else {\n                        val = boxed(ghostValue(jargty), &ctx, jargty);\n                    }\n                }\n                else {\n                    val = builder.CreatePointerCast(val, t->getPointerTo());\n                    val = builder.CreateAlignedLoad(val, 1); // make no alignment assumption about pointer from C\n                }\n            }\n        }\n        else {\n            // undo whatever we might have done to this poor argument\n            bool issigned = jl_signed_type && jl_subtype(jargty, (jl_value_t*)jl_signed_type, 0);\n            val = llvm_type_rewrite(val, val->getType(), fargt[i+sret], true, byRefList[i], issigned, &ctx);\n        }\n\n        // figure out how to repack this type\n        Type *at = specsig ? theFptr->getFunctionType()->getParamType(FParamIndex++) : jl_pvalue_llvmt;\n        if (val->getType() != at) {\n            if (at == jl_pvalue_llvmt) {\n                assert(jl_is_leaf_type(jargty));\n                if (jl_datatype_nfields(jargty) == 0) {\n                    val = literal_pointer_val(jl_new_struct_uninit((jl_datatype_t*)jargty));\n                }\n                else if (jl_isbits(jargty)) {\n                    val = boxed(val, &ctx, jargty);\n                }\n                else {\n                    Value *mem = emit_allocobj(jl_datatype_size(jargty));\n                    builder.CreateStore(literal_pointer_val((jl_value_t*)jargty),\n                                        emit_typeptr_addr(mem));\n                    builder.CreateAlignedStore(val, builder.CreateBitCast(mem, val->getType()->getPointerTo()), 16); // julia's gc gives 16-byte aligned addresses\n                    val = mem;\n                }\n                if (specsig)\n                    make_gcroot(val, &ctx);\n            }\n            else if (val->getType()->isAggregateType()) {\n                val = emit_reg2mem(val, &ctx);\n                assert(val->getType() == at);\n            }\n            else {\n                val = emit_unbox(at, val, jargty);\n                assert(dyn_cast<UndefValue>(val) == 0);\n            }\n        }\n\n        // add to argument list\n        if (specsig)\n            args.push_back(val);\n        else\n            make_gcroot(val, &ctx);\n    }\n\n    // Create the call\n    Value *r;\n    if (specsig) {\n        CallInst *call = builder.CreateCall(prepare_call(theFptr), ArrayRef<Value*>(args));\n        call->setAttributes(theFptr->getAttributes());\n        if (jlfunc_sret)\n            r = builder.CreateLoad(result);\n        else\n            r = call;\n        r = emit_reg2mem(r, &ctx);\n    }\n    else {\n        r = emit_jlcall(theFptr, literal_pointer_val((jl_value_t*)ff), 0, nargs, &ctx);\n    }\n\n    // Prepare the return value\n    if (isref&1) {\n        assert(!sret);\n        // return a jl_value_t*\n        if (r->getType() != jl_pvalue_llvmt) {\n            r = boxed(r, &ctx, jlrettype);\n        }\n    }\n    else if (sret && jlfunc_sret) {\n        // nothing to do\n    }\n    else if (!type_is_ghost(crt)) {\n        if (sret)\n            prt = fargt_sig[0]->getContainedType(0); // sret is a PointerType\n        Value *v = julia_to_native(crt, jlrettype, r, jlrettype, false, false, false, false, false, 0, &ctx, NULL);\n        bool issigned = jl_signed_type && jl_subtype(jlrettype, (jl_value_t*)jl_signed_type, 0);\n        r = llvm_type_rewrite(v, crt, prt, false, false, issigned, &ctx);\n        if (sret)\n            builder.CreateStore(r, sretPtr);\n    }\n    else {\n        assert(type_is_ghost(prt));\n        sret = true;\n    }\n\n    if (sret)\n        builder.CreateRetVoid();\n    else\n        builder.CreateRet(r);\n    finalize_gc_frame(&ctx);\n\n#ifdef JL_DEBUG_BUILD\n#ifdef LLVM35\n    llvm::raw_fd_ostream out(1,false);\n#endif\n    if (\n#ifdef LLVM35\n        verifyFunction(*cw,&out)\n#else\n        verifyFunction(*cw,PrintMessageAction)\n#endif\n    ) {\n        cw->dump();\n        abort();\n    }\n#endif\n\n#ifdef USE_MCJIT\n    if (imaging_mode) {\n        // Copy the function out of the shadow module\n        Module *m = new Module(\"julia\", jl_LLVMContext);\n        jl_setup_module(m, true);\n        FunctionMover mover(m, shadow_module);\n        Function *clone = mover.CloneFunction(cw);\n        FPM->run(*clone);\n    }\n    else {\n        FPM->run(*cw);\n    }\n#endif\n\n    // Restore the previous compile context\n    if (old != NULL) {\n        builder.SetInsertPoint(old);\n        builder.SetCurrentDebugLocation(olddl);\n    }\n    nested_compile = last_n_c;\n    jl_gc_inhibit_finalizers(nested_compile);\n    JL_SIGATOMIC_END();\n\n    return cw;\n}\n\n// generate a julia-callable function that calls f (AKA lam)\nstatic Function *gen_jlcall_wrapper(jl_lambda_info_t *lam, jl_expr_t *ast, Function *f, bool sret)\n{\n    std::stringstream funcName;\n    const std::string &fname = f->getName().str();\n    funcName << \"jlcall_\";\n    if (fname.compare(0, 6, \"julia_\") == 0)\n        funcName << fname.substr(6);\n    else\n        funcName << fname;\n\n    Function *w = Function::Create(jl_func_sig, imaging_mode ? GlobalVariable::InternalLinkage : GlobalVariable::ExternalLinkage,\n                                   funcName.str(), f->getParent());\n    addComdat(w);\n    Function::arg_iterator AI = w->arg_begin();\n    /* const Argument &fArg = */ *AI++;\n    Value *argArray = &*AI++;\n    /* const Argument &argCount = *AI++; */\n    BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", w);\n\n    builder.SetInsertPoint(b0);\n    DebugLoc noDbg;\n    builder.SetCurrentDebugLocation(noDbg);\n\n    jl_codectx_t ctx;\n    ctx.f = w;\n    ctx.linfo = lam;\n    ctx.sret = false;\n    allocate_gc_frame(0, b0, &ctx);\n\n    size_t nargs = jl_array_dim0(jl_lam_args(ast));\n    size_t nfargs = f->getFunctionType()->getNumParams();\n    Value **args = (Value**) alloca(nfargs*sizeof(Value*));\n    unsigned idx = 0;\n    Value *result;\n    if (sret) {\n        result = builder.CreateAlloca(f->getFunctionType()->getParamType(0)->getContainedType(0));\n        args[idx] = result;\n        idx++;\n    }\n    for(size_t i=0; i < nargs; i++) {\n        jl_value_t *ty = jl_nth_slot_type(lam->specTypes, i);\n        Type *lty = julia_type_to_llvm(ty);\n        if (lty != NULL && type_is_ghost(lty))\n            continue;\n        Value *argPtr = builder.CreateGEP(argArray,\n                                          ConstantInt::get(T_size, i));\n        Value *theArg = builder.CreateLoad(argPtr);\n        Value *theNewArg = theArg;\n        if (lty != NULL && lty != jl_pvalue_llvmt) {\n            if (lty->isAggregateType())\n                theNewArg = builder.CreatePointerCast(theArg, PointerType::get(lty,0));\n            else\n                theNewArg = emit_unbox(lty, theArg, ty);\n        }\n        assert(dyn_cast<UndefValue>(theNewArg) == NULL);\n        args[idx] = theNewArg;\n        idx++;\n    }\n    // TODO: consider pulling the function pointer out of fArg so these\n    // wrappers can be reused for different functions of the same type.\n    CallInst *call = builder.CreateCall(prepare_call(f), ArrayRef<Value*>(&args[0], nfargs));\n    call->setAttributes(f->getAttributes());\n    Value *r;\n    if (sret || call->getType() != jl_pvalue_llvmt) {\n        jl_value_t *ty = jl_ast_rettype(lam, (jl_value_t*)ast);\n        if (sret)\n            r = builder.CreateLoad(result);\n        else\n            r = call;\n        r = boxed(r, &ctx, ty);\n    }\n    else {\n        r = call;\n    }\n\n    builder.CreateRet(r);\n    finalize_gc_frame(&ctx);\n\n    FPM->run(*w);\n\n    return w;\n}\n\n// Compile to LLVM IR, using a specialized signature if applicable.\nstatic Function *emit_function(jl_lambda_info_t *lam)\n{\n    // step 1. unpack AST and allocate codegen context for this function\n    jl_expr_t *ast = (jl_expr_t*)lam->ast;\n    jl_svec_t *sparams = NULL;\n    JL_GC_PUSH2(&ast, &sparams);\n    if (!jl_is_expr(ast)) {\n        ast = (jl_expr_t*)jl_uncompress_ast(lam, (jl_value_t*)ast);\n    }\n    assert(jl_is_expr(ast));\n    sparams = jl_svec_tvars_to_symbols(lam->sparams);\n    //jl_printf((jl_value_t*)ast);\n    //jl_printf(JL_STDOUT, \"\\n\");\n    std::map<jl_sym_t*, jl_arrayvar_t> arrayvars;\n    std::map<int, BasicBlock*> labels;\n    std::map<int, Value*> handlers;\n    jl_codectx_t ctx;\n    ctx.arrayvars = &arrayvars;\n    ctx.labels = &labels;\n    ctx.handlers = &handlers;\n    ctx.module = lam->module;\n    ctx.ast = ast;\n    ctx.sp = sparams;\n    ctx.linfo = lam;\n    ctx.funcName = lam->name->name;\n    ctx.vaName = NULL;\n    ctx.vaStack = false;\n    ctx.boundsCheck.push_back(true);\n\n    // step 2. process var-info lists to see what vars are captured, need boxing\n    jl_value_t *gensym_types = jl_lam_gensyms(ast);\n    int n_gensyms = (jl_is_array(gensym_types) ? jl_array_len(gensym_types) : jl_unbox_gensym(gensym_types));\n    jl_array_t *largs = jl_lam_args(ast);\n    size_t largslen = jl_array_dim0(largs);\n    jl_array_t *vinfos = jl_lam_vinfo(ast);\n    size_t vinfoslen = jl_array_dim0(vinfos);\n    jl_array_t *captvinfos = jl_lam_capt(ast);\n    size_t captvinfoslen = jl_array_dim0(captvinfos);\n    size_t nreq = largslen;\n    int va = 0;\n    if (!lam->specTypes)\n        lam->specTypes = jl_anytuple_type;\n    if (nreq > 0 && jl_is_rest_arg(jl_cellref(largs,nreq-1))) {\n        nreq--;\n        va = 1;\n        ctx.vaName = jl_decl_var(jl_cellref(largs,nreq));\n    }\n    ctx.nReqArgs = nreq;\n\n    size_t i;\n    for(i=0; i < nreq; i++) {\n        jl_sym_t *argname = jl_decl_var(jl_cellref(largs,i));\n        jl_varinfo_t &varinfo = ctx.vars[argname];\n        varinfo.isArgument = true;\n    }\n    if (va) {\n        ctx.vars[ctx.vaName].isArgument = true;\n    }\n\n    for(i=0; i < vinfoslen; i++) {\n        jl_array_t *vi = (jl_array_t*)jl_cellref(vinfos, i);\n        assert(jl_is_array(vi));\n        jl_sym_t *vname = ((jl_sym_t*)jl_cellref(vi,0));\n        assert(jl_is_symbol(vname));\n        jl_varinfo_t &varinfo = ctx.vars[vname];\n        varinfo.isAssigned = (jl_vinfo_assigned(vi)!=0);\n        varinfo.isCaptured = (jl_vinfo_capt(vi)!=0);\n        varinfo.escapes = varinfo.isCaptured;\n        if (varinfo.isCaptured)\n            varinfo.used = true;\n        varinfo.isSA = (jl_vinfo_sa(vi)!=0);\n        varinfo.usedUndef = (jl_vinfo_usedundef(vi)!=0) || (!varinfo.isArgument && !lam->inferred);\n        varinfo.declType = jl_cellref(vi,1);\n        if (!jl_is_type(varinfo.declType))\n            varinfo.declType = (jl_value_t*)jl_any_type;\n    }\n    bool hasCapt = (captvinfoslen > 0);\n    for(i=0; i < captvinfoslen; i++) {\n        jl_array_t *vi = (jl_array_t*)jl_cellref(captvinfos, i);\n        assert(jl_is_array(vi));\n        jl_sym_t *vname = ((jl_sym_t*)jl_cellref(vi,0));\n        assert(jl_is_symbol(vname));\n        jl_varinfo_t &varinfo = ctx.vars[vname];\n        varinfo.closureidx = i;\n        varinfo.isAssigned = (jl_vinfo_assigned(vi)!=0);\n        varinfo.isCaptured = true;\n        varinfo.escapes = true;\n        varinfo.used = true;\n        varinfo.usedUndef = (jl_vinfo_usedundef(vi)!=0) || !lam->inferred;\n        varinfo.declType = jl_cellref(vi,1);\n        if (!jl_is_type(varinfo.declType))\n            varinfo.declType = (jl_value_t*)jl_any_type;\n    }\n\n    // step 3. some variable analysis\n\n    // finish recording escape info\n    simple_escape_analysis((jl_value_t*)ast, true, &ctx);\n\n    // determine which vars need to be volatile\n    jl_array_t *stmts = jl_lam_body(ast)->args;\n    mark_volatile_vars(stmts, ctx.vars);\n\n    // step 4. determine function signature\n    jl_value_t *jlrettype = jl_ast_rettype(lam, (jl_value_t*)ast);\n    Function *f = NULL;\n\n    bool specsig = false;\n    if (!va && !hasCapt && lam->specTypes != jl_anytuple_type && lam->inferred) {\n        // no captured vars and not vararg\n        // consider specialized signature\n        for(size_t i=0; i < jl_nparams(lam->specTypes); i++) {\n            if (isbits_spec(jl_tparam(lam->specTypes, i))) { // assumes !va\n                specsig = true;\n                break;\n            }\n        }\n        if (jl_nparams(lam->specTypes) == 0)\n            specsig = true;\n        if (isbits_spec(jlrettype))\n            specsig = true;\n    }\n\n    std::stringstream funcName;\n    // try to avoid conflicts in the global symbol table\n    funcName << \"julia_\" << lam->name->name;\n\n    Module *m;\n#ifdef USE_MCJIT\n    if (!imaging_mode) {\n        m = new Module(funcName.str(), jl_LLVMContext);\n        jl_setup_module(m,true);\n    }\n    else {\n        m = shadow_module;\n    }\n#else\n    m = jl_Module;\n#endif\n    funcName << \"_\" << globalUnique++;\n\n    ctx.sret = false;\n    if (specsig) { // assumes !va\n        std::vector<Type*> fsig(0);\n        Type *rt = (jlrettype == (jl_value_t*)jl_void_type ? T_void : julia_type_to_llvm(jlrettype));\n        if (rt != jl_pvalue_llvmt && rt != T_void && deserves_sret(jlrettype, rt)) {\n            ctx.sret = true;\n            fsig.push_back(rt->getPointerTo());\n            rt = T_void;\n        }\n        for(size_t i=0; i < jl_nparams(lam->specTypes); i++) {\n            Type *ty = julia_type_to_llvm(jl_tparam(lam->specTypes,i));\n            if (type_is_ghost(ty)) {\n                // mark as a ghost for now, we'll revise this later if needed as a local\n                ctx.vars[jl_decl_var(jl_cellref(largs,i))].isGhost = true;\n                continue;\n            }\n            if (ty->isAggregateType())\n                ty = PointerType::get(ty,0);\n            fsig.push_back(ty);\n        }\n        f = Function::Create(FunctionType::get(rt, fsig, false),\n                             imaging_mode ? GlobalVariable::InternalLinkage : GlobalVariable::ExternalLinkage,\n                             funcName.str(), m);\n        if (ctx.sret)\n            f->addAttribute(1, Attribute::StructRet);\n        addComdat(f);\n        if (lam->specFunctionObject == NULL) {\n            lam->specFunctionObject = (void*)f;\n            lam->specFunctionID = jl_assign_functionID(f);\n        }\n        if (lam->functionObject == NULL) {\n            Function *fwrap = gen_jlcall_wrapper(lam, ast, f, ctx.sret);\n            lam->functionObject = (void*)fwrap;\n            lam->functionID = jl_assign_functionID(fwrap);\n        }\n    }\n    else {\n        f = Function::Create(jl_func_sig, imaging_mode ? GlobalVariable::InternalLinkage : GlobalVariable::ExternalLinkage,\n                             funcName.str(), m);\n        addComdat(f);\n        if (lam->functionObject == NULL) {\n            lam->functionObject = (void*)f;\n            lam->functionID = jl_assign_functionID(f);\n        }\n    }\n    if (jlrettype == (jl_value_t*)jl_bottom_type)\n        f->setDoesNotReturn();\n#if defined(_OS_WINDOWS_) && !defined(_CPU_X86_64_)\n    // tell Win32 to realign the stack to the next 16-byte boundary\n    // upon entry to any function. This achieves compatibility\n    // with both MinGW-GCC (which assumes an 16-byte-aligned stack) and\n    // i686 Windows (which uses a 4-byte-aligned stack)\n    AttrBuilder *attr = new AttrBuilder();\n    attr->addStackAlignmentAttr(16);\n    f->addAttributes(AttributeSet::FunctionIndex,\n        AttributeSet::get(f->getContext(),\n            AttributeSet::FunctionIndex,*attr));\n#endif\n\n#if defined(_OS_WINDOWS_) && defined(_CPU_X86_64_) && LLVM35\n    f->setHasUWTable(); // force NeedsWinEH\n#endif\n\n#ifdef JL_DEBUG_BUILD\n    f->addFnAttr(Attribute::StackProtectReq);\n#endif\n    ctx.f = f;\n\n    // step 5. set up debug info context and create first basic block\n    bool in_user_code = !jl_is_submodule(lam->module, jl_base_module) && !jl_is_submodule(lam->module, jl_core_module);\n    bool do_coverage = jl_options.code_coverage == JL_LOG_ALL || (jl_options.code_coverage == JL_LOG_USER && in_user_code);\n    bool do_malloc_log = jl_options.malloc_log  == JL_LOG_ALL || (jl_options.malloc_log    == JL_LOG_USER && in_user_code);\n    jl_value_t *stmt = skip_meta(stmts);\n    std::string filename = \"no file\";\n    char *dbgFuncName = lam->name->name;\n    int lno = -1;\n    // look for initial (line num filename [funcname]) node, [funcname] for kwarg methods.\n    if (jl_is_linenode(stmt)) {\n        lno = jl_linenode_line(stmt);\n        filename = jl_linenode_file(stmt)->name;\n    }\n    else if (jl_is_expr(stmt) && ((jl_expr_t*)stmt)->head == line_sym &&\n             jl_array_dim0(((jl_expr_t*)stmt)->args) > 0) {\n        jl_value_t *a1 = jl_exprarg(stmt,0);\n        if (jl_is_long(a1))\n            lno = jl_unbox_long(a1);\n        if (jl_array_dim0(((jl_expr_t*)stmt)->args) > 1) {\n            a1 = jl_exprarg(stmt,1);\n            if (jl_is_symbol(a1))\n                filename = ((jl_sym_t*)a1)->name;\n            if (jl_array_dim0(((jl_expr_t*)stmt)->args) > 2) {\n                a1 = jl_exprarg(stmt,2);\n                if (jl_is_symbol(a1))\n                    dbgFuncName = ((jl_sym_t*)a1)->name;\n            }\n        }\n    }\n    int toplineno = lno;\n\n    DIBuilder dbuilder(*m);\n    ctx.dbuilder = &dbuilder;\n#ifdef LLVM37\n    DIFile *topfile = NULL;\n    DISubprogram *SP;\n#else\n    DIFile topfile;\n    DISubprogram SP;\n#endif\n    DebugLoc inlineLoc;\n\n    BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", f);\n    builder.SetInsertPoint(b0);\n\n    //jl_printf(JL_STDERR, \"\\n*** compiling %s at %s:%d\\n\\n\",\n    //           lam->name->name, filename.c_str(), lno);\n\n    DebugLoc noDbg;\n    ctx.debug_enabled = true;\n    if (dbgFuncName[0] == 0) {\n        // special value: if function name is empty, disable debug info\n        builder.SetCurrentDebugLocation(noDbg);\n        ctx.debug_enabled = false;\n        do_coverage = false;\n        do_malloc_log = false;\n    }\n    else {\n        // TODO: Fix when moving to new LLVM version\n        #ifndef LLVM34\n        dbuilder.createCompileUnit(0x01, filename, \".\", \"julia\", true, \"\", 0);\n        #elif LLVM37\n        DICompileUnit *CU = dbuilder.createCompileUnit(0x01, filename, \".\", \"julia\", true, \"\", 0);\n        #else\n        DICompileUnit CU = dbuilder.createCompileUnit(0x01, filename, \".\", \"julia\", true, \"\", 0);\n        assert(CU.Verify());\n        #endif\n\n#ifdef LLVM37\n        DISubroutineType *subrty;\n#elif LLVM36\n        DISubroutineType subrty;\n#else\n        DICompositeType subrty;\n#endif\n\n        if (!specsig) {\n            subrty = jl_di_func_sig;\n        }\n        else {\n#ifdef LLVM36\n            std::vector<Metadata*> ditypes(0);\n#else\n            std::vector<Value*> ditypes(0);\n#endif\n            for(size_t i=0; i < jl_nparams(lam->specTypes); i++) { // assumes !va\n                if (ctx.vars[jl_decl_var(jl_cellref(largs,i))].isGhost)\n                    continue;\n                ditypes.push_back(julia_type_to_di(jl_tparam(lam->specTypes,i),ctx.dbuilder,false));\n            }\n#ifdef LLVM38\n            subrty = ctx.dbuilder->createSubroutineType(ctx.dbuilder->getOrCreateTypeArray(ditypes));\n#elif defined(LLVM36)\n            subrty = ctx.dbuilder->createSubroutineType(topfile,ctx.dbuilder->getOrCreateTypeArray(ditypes));\n#else\n            subrty = ctx.dbuilder->createSubroutineType(topfile,ctx.dbuilder->getOrCreateArray(ditypes));\n#endif\n        }\n\n        topfile = dbuilder.createFile(filename, \".\");\n        #ifndef LLVM34\n        SP = dbuilder.createFunction((DIDescriptor)dbuilder.getCU(),\n        #else\n        SP = dbuilder.createFunction(CU,\n        #endif\n                                    dbgFuncName,  // Name\n                                    f->getName(), // LinkageName\n                                    topfile,       // File\n                                    0,            // LineNo\n                                    subrty,       // Ty\n                                    false,        // isLocalToUnit\n                                    true,         // isDefinition\n                                    0,            // ScopeLine\n                                    0,            // Flags\n                                    true,         // isOptimized\n        #ifdef LLVM38\n                                    nullptr);       // Template Parameters\n        #else\n                                    f);             // Function\n        #endif\n        // set initial line number\n        inlineLoc = DebugLoc::get(lno, 0, (MDNode*)SP, NULL);\n        builder.SetCurrentDebugLocation(inlineLoc);\n        #ifdef LLVM38\n        f->setSubprogram(SP);\n        #endif\n        #ifndef LLVM37\n        assert(SP.Verify() && SP.describes(f) && SP.getFunction() == f);\n        #endif\n    }\n\n    if (ctx.debug_enabled) {\n        // Go over all arguments and local variables and initialize their debug information\n        for(i=0; i < nreq; i++) {\n            jl_sym_t *argname = jl_decl_var(jl_cellref(largs,i));\n            jl_varinfo_t &varinfo = ctx.vars[argname];\n#ifdef LLVM38\n            varinfo.dinfo = ctx.dbuilder->createParameterVariable(\n                SP,                                 // Scope (current function will be fill in later)\n                argname->name,                      // Variable name\n                ctx.sret + i + 1,                                // Argument number (1-based)\n                topfile,                            // File\n                toplineno == -1 ? 0 : toplineno,  // Line\n                // Variable type\n                julia_type_to_di(varinfo.declType,ctx.dbuilder,specsig));\n#else\n            varinfo.dinfo = ctx.dbuilder->createLocalVariable(\n                llvm::dwarf::DW_TAG_arg_variable,    // Tag\n                SP,         // Scope (current function will be fill in later)\n                argname->name,    // Variable name\n                topfile,                    // File\n                toplineno == -1 ? 0 : toplineno,             // Line (for now, use lineno of the function)\n                julia_type_to_di(varinfo.declType,ctx.dbuilder,specsig), // Variable type\n                false,                  // May be optimized out\n                0,                      // Flags (TODO: Do we need any)\n                ctx.sret + i + 1);                   // Argument number (1-based)\n#endif\n        }\n        if (va) {\n#ifdef LLVM38\n            ctx.vars[ctx.vaName].dinfo = ctx.dbuilder->createParameterVariable(\n                SP,                     // Scope (current function will be fill in later)\n                ctx.vaName->name,       // Variable name\n                ctx.sret + nreq + 1,               // Argument number (1-based)\n                topfile,                    // File\n                toplineno == -1 ? 0 : toplineno,             // Line (for now, use lineno of the function)\n                julia_type_to_di(ctx.vars[ctx.vaName].declType,ctx.dbuilder,false));\n#else\n            ctx.vars[ctx.vaName].dinfo = ctx.dbuilder->createLocalVariable(\n                llvm::dwarf::DW_TAG_arg_variable,   // Tag\n                SP,                                 // Scope (current function will be fill in later)\n                ctx.vaName->name,                   // Variable name\n                topfile,                             // File\n                toplineno == -1 ? 0 : toplineno,  // Line (for now, use lineno of the function)\n                julia_type_to_di(ctx.vars[ctx.vaName].declType,ctx.dbuilder,false),      // Variable type\n                false,                  // May be optimized out\n                0,                      // Flags (TODO: Do we need any)\n                ctx.sret + nreq + 1);              // Argument number (1-based)\n#endif\n        }\n        for(i=0; i < vinfoslen; i++) {\n            jl_sym_t *s = (jl_sym_t*)jl_cellref(jl_cellref(vinfos,i),0);\n            jl_varinfo_t &varinfo = ctx.vars[s];\n            if (varinfo.isArgument)\n                continue;\n#ifdef LLVM38\n            varinfo.dinfo = ctx.dbuilder->createAutoVariable(\n#else\n            varinfo.dinfo = ctx.dbuilder->createLocalVariable(\n                llvm::dwarf::DW_TAG_auto_variable,    // Tag\n#endif\n                SP,                     // Scope (current function will be fill in later)\n                s->name,                // Variable name\n                topfile,                 // File\n                toplineno == -1 ? 0 : toplineno, // Line (for now, use lineno of the function)\n                julia_type_to_di(varinfo.declType,ctx.dbuilder,specsig), // Variable type\n                false,                  // May be optimized out\n                0                       // Flags (TODO: Do we need any)\n#ifndef LLVM38\n                ,0                      // Argument number (1-based)\n#endif\n                );\n        }\n        for(i=0; i < captvinfoslen; i++) {\n            jl_array_t *vi = (jl_array_t*)jl_cellref(captvinfos, i);\n            assert(jl_is_array(vi));\n            jl_sym_t *vname = ((jl_sym_t*)jl_cellref(vi,0));\n            assert(jl_is_symbol(vname));\n            jl_varinfo_t &varinfo = ctx.vars[vname];\n#ifdef LLVM38\n            varinfo.dinfo = ctx.dbuilder->createAutoVariable(\n#else\n            varinfo.dinfo = ctx.dbuilder->createLocalVariable(\n                llvm::dwarf::DW_TAG_auto_variable,    // Tag\n#endif\n                SP,                     // Scope (current function will be filled in later)\n                vname->name,            // Variable name\n                topfile,                 // File\n                toplineno == -1 ? 0 : toplineno, // Line (for now, use lineno of the function)\n                julia_type_to_di(varinfo.declType,ctx.dbuilder,specsig), // Variable type\n                false,                  // May be optimized out\n                0                       // Flags (TODO: Do we need any)\n#ifndef LLVM38\n                ,0                      // Argument number (1-based)\n#endif\n                );\n        }\n    }\n\n#ifdef LLVM37\n    std::map<jl_sym_t *, DIFile *> filescopes;\n#else\n    std::map<jl_sym_t *, MDNode *> filescopes;\n#endif\n\n    Value *fArg=NULL, *argArray=NULL, *argCount=NULL;\n    unsigned argIdx = 0;\n    if (!specsig) {\n        Function::arg_iterator AI = f->arg_begin();\n        fArg = &*AI++;\n        argArray = &*AI++;\n        argCount = &*AI++;\n        ctx.argArray = argArray;\n        ctx.argCount = argCount;\n\n#ifdef LLVM36\n        // Declare arguments early so llvm in case any of the below emits basic blocks\n        // before we get to loading local variables\n        for(i=0; i < nreq; i++) {\n            jl_sym_t *s = jl_decl_var(jl_cellref(largs,i));\n            if (ctx.vars[s].dinfo != (MDNode*)NULL) {\n                SmallVector<int64_t, 9> addr;\n                addr.push_back(llvm::dwarf::DW_OP_plus);\n                addr.push_back(argIdx * sizeof(void*));\n                //addr.push_back(llvm::dwarf::DW_OP_deref);\n#ifdef LLVM37\n                ctx.dbuilder->insertDbgValueIntrinsic(argArray, 0, ctx.vars[s].dinfo,\n                ctx.dbuilder->createExpression(addr),\n                builder.getCurrentDebugLocation().get(), builder.GetInsertBlock());\n#else\n                ctx.dbuilder->insertDbgValueIntrinsic(argArray, 0, ctx.vars[s].dinfo,\n                ctx.dbuilder->createExpression(addr), builder.GetInsertBlock());\n#endif\n            }\n            argIdx++;\n        }\n#endif\n    }\n\n    /*\n    // step 6. (optional) check for stack overflow (the slower way)\n    Value *cur_sp =\n        builder.CreateCall(Intrinsic::getDeclaration(jl_Module,\n                                                     Intrinsic::frameaddress),\n                           ConstantInt::get(T_int32, 0));\n    Value *sp_ok =\n        builder.CreateICmpUGT(cur_sp,\n                              ConstantInt::get(T_size,\n                                               (uptrint_t)jl_stack_lo));\n    error_unless(sp_ok, \"stack overflow\", &ctx);\n    */\n\n    // step 7. allocate local variables\n    // must be first for the mem2reg pass to work\n    int n_roots = 0;\n    for(i=0; i < largslen; i++) {\n        jl_sym_t *s = jl_decl_var(jl_cellref(largs,i));\n        if (store_unboxed_p(s, &ctx)) {\n            alloc_local(s, &ctx);\n        }\n        else if (ctx.vars[s].isAssigned || (va && i==largslen-1)) {\n            n_roots++;\n        }\n        maybe_alloc_arrayvar(s, &ctx);\n    }\n    for(i=0; i < vinfoslen; i++) {\n        jl_sym_t *s = (jl_sym_t*)jl_cellref(jl_cellref(vinfos,i),0);\n        assert(jl_is_symbol(s));\n        jl_varinfo_t &vi = ctx.vars[s];\n        if (vi.isArgument)\n            continue;\n        if (store_unboxed_p(s, &ctx)) {\n            alloc_local(s, &ctx);\n        }\n        else {\n            if (!vi.used) {\n                vi.hasGCRoot = false;\n                continue;\n            }\n            if (vi.isSA && !vi.isVolatile && !vi.isCaptured && !vi.usedUndef) {\n                vi.hasGCRoot = false; // so far...\n            }\n            else {\n                vi.hasGCRoot = true;\n                n_roots++;\n            }\n        }\n        maybe_alloc_arrayvar(s, &ctx);\n    }\n\n    // create SAvalue locations for GenSym objects\n    ctx.gensym_assigned.assign(n_gensyms, false);\n    ctx.gensym_SAvalues.assign(n_gensyms, (Value*)NULL);\n\n    // fetch env out of function object if we need it\n    if (hasCapt) {\n        ctx.envArg = emit_nthptr(fArg, offsetof(jl_function_t,env)/sizeof(jl_value_t*), tbaa_func);\n    }\n\n    // step 8. set up GC frame\n    allocate_gc_frame(n_roots, b0, &ctx);\n\n    // get pointers for locals stored in the gc frame array (argTemp)\n    int varnum = 0;\n    for(i=0; i < largslen; i++) {\n        jl_sym_t *s = jl_decl_var(jl_cellref(largs,i));\n        if (store_unboxed_p(s, &ctx)) {\n            // nothing\n        }\n        else if (ctx.vars[s].isAssigned || (va && i==largslen-1)) {\n            Value *av = emit_local_slot(varnum, &ctx);\n            varnum++;\n            ctx.vars[s].memvalue = av;\n        }\n    }\n    for(i=0; i < vinfoslen; i++) {\n        jl_sym_t *s = (jl_sym_t*)jl_cellref(jl_cellref(vinfos,i),0);\n        if (ctx.vars[s].isArgument)\n            continue;\n        if (store_unboxed_p(s, &ctx)) {\n            // nothing\n        }\n        else if (ctx.vars[s].hasGCRoot) {\n            Value *lv = emit_local_slot(varnum, &ctx);\n            varnum++;\n            ctx.vars[s].memvalue = lv;\n        }\n    }\n    assert(varnum == ctx.gc.argSpaceSize);\n\n    // step 9. create boxes for boxed locals\n    // now handled by explicit :newvar nodes\n\n    // step 10. allocate space for exception handler contexts\n    size_t stmtslen = jl_array_dim0(stmts);\n    for(i=0; i < stmtslen; i++) {\n        jl_value_t *stmt = jl_cellref(stmts,i);\n        if (jl_is_expr(stmt) && ((jl_expr_t*)stmt)->head == enter_sym) {\n            int labl = jl_unbox_long(jl_exprarg(stmt,0));\n            AllocaInst *handlr =\n                builder.CreateAlloca(T_int8,\n                                     ConstantInt::get(T_int32,\n                                                      sizeof(jl_handler_t)));\n            handlr->setAlignment(16);\n            handlers[labl] = handlr;\n        }\n    }\n\n    // step 11. check arg count\n    if (jl_is_va_tuple(ctx.linfo->specTypes)) {\n        std::string msg;\n        Value *enough;\n        if (va) {\n            msg = \"too few arguments\";\n            enough = builder.CreateICmpUGE(argCount,\n                                      ConstantInt::get(T_int32, nreq));\n        }\n        else {\n            msg = \"wrong number of arguments\";\n            enough =\n                builder.CreateICmpEQ(argCount,\n                                     ConstantInt::get(T_int32, nreq));\n        }\n        BasicBlock *elseBB =\n            BasicBlock::Create(getGlobalContext(), \"else\", f);\n        BasicBlock *mergeBB =\n            BasicBlock::Create(getGlobalContext(), \"ifcont\");\n        builder.CreateCondBr(enough, mergeBB, elseBB);\n        builder.SetInsertPoint(elseBB);\n        just_emit_error(msg, &ctx);\n        builder.CreateUnreachable();\n        f->getBasicBlockList().push_back(mergeBB);\n        builder.SetInsertPoint(mergeBB);\n    }\n\n    // step 12. move args into local variables\n    Function::arg_iterator AI = f->arg_begin();\n    argIdx = 0;\n    if (ctx.sret)\n        AI++; // skip sret slot\n    for(i=0; i < nreq; i++) {\n        jl_sym_t *s = jl_decl_var(jl_cellref(largs,i));\n        jl_varinfo_t &vi = ctx.vars[s];\n        Value *argPtr = NULL;\n        jl_value_t *argType = NULL;\n        if (specsig) {\n            argType = jl_nth_slot_type(lam->specTypes,i);\n            if (!vi.isGhost) {\n                argPtr = &*AI++;\n                argPtr = mark_julia_type(argPtr, argType);\n            }\n        }\n        else {\n            argPtr = builder.CreateGEP(argArray, ConstantInt::get(T_size, argIdx));\n            argIdx++;\n        }\n\n        Value *theArg = NULL;\n        if (specsig) {\n            theArg = argPtr;\n        }\n        else {\n            assert(argPtr != NULL);\n            theArg = builder.CreateLoad(argPtr);\n        }\n\n        Value *lv = vi.memvalue;\n        if (lv == NULL) {\n            // if this argument hasn't been given space yet, we've decided\n            // to leave it in the input argument array.\n            vi.passedAs = theArg;\n        }\n        else {\n            // keep track of original (boxed) value to avoid re-boxing\n            vi.passedAs = theArg;\n            if (isBoxed(s, &ctx)) {\n                if (specsig) {\n                    theArg = boxed(theArg,&ctx,argType);\n                    builder.CreateStore(theArg, lv); // temporarily root\n                }\n                builder.CreateStore(builder.CreateCall(prepare_call(jlbox_func), theArg), lv);\n            }\n            else if (dyn_cast<GetElementPtrInst>(lv) != NULL) {\n                builder.CreateStore(boxed(theArg,&ctx,argType), lv);\n            }\n            else if (dyn_cast<AllocaInst>(lv)->getAllocatedType() == jl_pvalue_llvmt) {\n                builder.CreateStore(theArg,lv);\n            }\n            else {\n                builder.CreateStore(emit_unbox(dyn_cast<AllocaInst>(lv)->getAllocatedType(),\n                                               theArg,\n                                               lam->specTypes == NULL ? NULL :\n                                               jl_nth_slot_type(lam->specTypes,i)),\n                                    lv);\n            }\n        }\n        // get arrayvar data if applicable\n        if (arrayvars.find(s) != arrayvars.end()) {\n            jl_arrayvar_t av = arrayvars[s];\n            assign_arrayvar(av, theArg);\n        }\n    }\n\n    // step 13. allocate rest argument if necessary\n    if (va) {\n        jl_sym_t *argname = ctx.vaName;\n        jl_varinfo_t &vi = ctx.vars[argname];\n        if (!vi.escapes && !vi.isAssigned) {\n            ctx.vaStack = true;\n        }\n        else if (!vi.isGhost) {\n            // restarg = jl_f_tuple(NULL, &args[nreq], nargs-nreq)\n            Value *lv = vi.memvalue;\n            if (dyn_cast<GetElementPtrInst>(lv) != NULL || dyn_cast<AllocaInst>(lv)->getAllocatedType() == jl_pvalue_llvmt) {\n#ifdef LLVM37\n                Value *restTuple =\n                    builder.CreateCall(prepare_call(jltuple_func), {V_null,\n                                        builder.CreateGEP(argArray,\n                                                          ConstantInt::get(T_size,nreq)),\n                                        builder.CreateSub(argCount,\n                                                          ConstantInt::get(T_int32,nreq))});\n#else\n                Value *restTuple =\n                    builder.CreateCall3(prepare_call(jltuple_func), V_null,\n                                        builder.CreateGEP(argArray,\n                                                          ConstantInt::get(T_size,nreq)),\n                                        builder.CreateSub(argCount,\n                                                          ConstantInt::get(T_int32,nreq)));\n#endif\n                if (isBoxed(argname, &ctx))\n                    builder.CreateStore(builder.CreateCall(prepare_call(jlbox_func), restTuple), lv);\n                else\n                    builder.CreateStore(restTuple, lv);\n            }\n            else {\n                // TODO: Perhaps allow this in the future, but for now since varargs\n                // are always unspecialized we don't\n                assert(false);\n            }\n        }\n        else {\n            assert(vi.memvalue == NULL);\n        }\n    }\n\n    // step 14. associate labels with basic blocks to resolve forward jumps\n    BasicBlock *prev=NULL;\n    for(i=0; i < stmtslen; i++) {\n        jl_value_t *ex = jl_cellref(stmts,i);\n        if (jl_is_labelnode(ex)) {\n            int lname = jl_labelnode_label(ex);\n            if (prev != NULL) {\n                // fuse consecutive labels\n                labels[lname] = prev;\n            }\n            else {\n                prev = BasicBlock::Create(getGlobalContext(), \"L\");\n                labels[lname] = prev;\n            }\n        }\n        else {\n            prev = NULL;\n        }\n    }\n\n    // step 15. compile body statements\n    bool prevlabel = false;\n    lno = -1;\n    int prevlno = -1;\n    for(i=0; i < stmtslen; i++) {\n        jl_value_t *stmt = jl_cellref(stmts,i);\n        if (jl_is_linenode(stmt) ||\n            (jl_is_expr(stmt) && ((jl_expr_t*)stmt)->head == line_sym)) {\n\n            jl_sym_t *file = NULL;\n            if (jl_is_linenode(stmt)) {\n                lno = jl_linenode_line(stmt);\n                file = jl_linenode_file(stmt);\n            } else if (jl_is_expr(stmt)) {\n                lno = jl_unbox_long(jl_exprarg(stmt,0));\n                if (jl_array_dim0(((jl_expr_t*)stmt)->args) > 1) {\n                    jl_value_t *a1 = jl_exprarg(stmt,1);\n                    if (jl_is_symbol(a1)) {\n                        file = (jl_sym_t*)a1;\n                    }\n                }\n            }\n            assert(file->name);\n\n#           ifdef LLVM37\n            DIFile *dfil = NULL;\n#           else\n            MDNode *dfil = NULL;\n#           endif\n\n            // If the string is not empty\n            if (*file->name != '\\0') {\n#               ifdef LLVM37\n                std::map<jl_sym_t *, DIFile *>::iterator it = filescopes.find(file);\n#               else\n                std::map<jl_sym_t *, MDNode *>::iterator it = filescopes.find(file);\n#               endif\n                if (it != filescopes.end()) {\n                    dfil = it->second;\n                } else {\n#                   ifdef LLVM37\n                    dfil = (DIFile*)dbuilder.createFile(file->name, \".\");\n#                   else\n                    dfil = (MDNode*)dbuilder.createFile(file->name, \".\");\n#                   endif\n                }\n            }\n            DebugLoc loc;\n            if (ctx.debug_enabled) {\n                MDNode *scope;\n                if ((dfil == topfile || dfil == NULL) &&\n                    lno >= toplineno)\n                    {\n                    // for sequentially-defined code,\n                    // set location to line in top file.\n                    // TODO: improve handling of nested inlines\n                    loc = inlineLoc = DebugLoc::get(lno, 1, SP, NULL);\n                } else {\n                    // otherwise, we are compiling inlined code,\n                    // so set the DebugLoc \"inlinedAt\" parameter\n                    // to the current line, then use source loc.\n#ifdef LLVM37\n                    scope = (MDNode*)dbuilder.createLexicalBlockFile(SP,dfil);\n                    MDNode *inlineLocMd = inlineLoc.getAsMDNode();\n#else\n                    scope = (MDNode*)dbuilder.createLexicalBlockFile(SP,DIFile(dfil));\n                    MDNode *inlineLocMd = inlineLoc.getAsMDNode(jl_LLVMContext);\n#endif\n                    loc = DebugLoc::get(lno, 1, scope, inlineLocMd);\n                }\n                builder.SetCurrentDebugLocation(loc);\n            }\n            if (do_coverage)\n                coverageVisitLine(filename, lno);\n        }\n        if (jl_is_labelnode(stmt)) {\n            if (prevlabel) continue;\n            prevlabel = true;\n        }\n        else {\n            prevlabel = false;\n        }\n        if (do_malloc_log) {\n            // Check memory allocation after finishing a line or hitting the next branch\n            if (lno != prevlno ||\n                (jl_is_expr(stmt) && ((jl_expr_t*)stmt)->head == goto_ifnot_sym) ||\n                jl_is_gotonode(stmt)) {\n                if (prevlno != -1)\n                    mallocVisitLine(filename, prevlno);\n                prevlno = lno;\n            }\n        }\n        if (jl_is_expr(stmt) && ((jl_expr_t*)stmt)->head == return_sym) {\n            jl_expr_t *ex = (jl_expr_t*)stmt;\n            Value *retval;\n            Type *retty = ctx.sret ? f->getFunctionType()->getParamType(0)->getContainedType(0) : f->getReturnType();\n            if (retty == jl_pvalue_llvmt) {\n                retval = boxed(emit_expr(jl_exprarg(ex,0), &ctx, true),&ctx,expr_type(stmt,&ctx));\n            }\n            else if (retty != T_void) {\n                retval = emit_unbox(retty,\n                                    emit_unboxed(jl_exprarg(ex,0), &ctx), jlrettype);\n            }\n            else {\n                retval = emit_expr(jl_exprarg(ex,0), &ctx, false);\n            }\n            if (do_malloc_log && lno != -1)\n                mallocVisitLine(filename, lno);\n\n            if (ctx.sret)\n                builder.CreateStore(retval, &*ctx.f->arg_begin());\n            if (type_is_ghost(retty) || ctx.sret)\n                builder.CreateRetVoid();\n            else\n                builder.CreateRet(retval);\n            if (i != stmtslen-1) {\n                BasicBlock *bb =\n                    BasicBlock::Create(getGlobalContext(), \"ret\", ctx.f);\n                builder.SetInsertPoint(bb);\n            }\n        }\n        else {\n            (void)emit_expr(stmt, &ctx, false, false);\n        }\n    }\n\n    builder.SetCurrentDebugLocation(noDbg);\n\n    // sometimes we have dangling labels after the end\n    if (builder.GetInsertBlock()->getTerminator() == NULL) {\n        builder.CreateUnreachable();\n    }\n\n    // step 16. fix up size of stack root list\n    finalize_gc_frame(&ctx);\n\n    // step 17, Apply LLVM level inlining\n    for(std::vector<CallInst*>::iterator it = ctx.to_inline.begin(); it != ctx.to_inline.end(); ++it) {\n        Function *inlinef = (*it)->getCalledFunction();\n        InlineFunctionInfo info;\n        if (!InlineFunction(*it,info))\n            jl_error(\"Inlining Pass failed\");\n        inlinef->eraseFromParent();\n    }\n\n    // step 18. Perform any delayed instantiations\n    if (ctx.debug_enabled)\n        ctx.dbuilder->finalize();\n\n    JL_GC_POP();\n\n    return f;\n}\n\n// --- initialization ---\n\nstatic MDNode *tbaa_make_child( const char *name, MDNode *parent, bool isConstant=false )\n{\n    MDNode *n = mbuilder->createTBAANode(name,parent,isConstant);\n#ifndef LLVM36\n#ifdef LLVM35\n    n->setValueName( ValueName::Create(name));\n#else\n    n->setValueName( ValueName::Create(name, name+strlen(name)));\n#endif\n#endif\n    return n;\n}\n\nstatic GlobalVariable *global_to_llvm(const std::string &cname, void *addr, Module *m)\n{\n    GlobalVariable *gv =\n        new GlobalVariable(*m, jl_pvalue_llvmt, true,\n                           GlobalVariable::ExternalLinkage, NULL, cname);\n    add_named_global(gv, addr);\n    return gv;\n}\n\nstatic Function *jlcall_func_to_llvm(const std::string &cname, void *addr, Module *m)\n{\n    Function *f = Function::Create(jl_func_sig, Function::ExternalLinkage, cname, m);\n    add_named_global(f, addr);\n    return f;\n}\n\nextern \"C\" void jl_fptr_to_llvm(void *fptr, jl_lambda_info_t *lam, int specsig)\n{\n    if (imaging_mode) {\n        if (!specsig) {\n            lam->fptr = (jl_fptr_t)fptr; // in imaging mode, it's fine to use the fptr, but we don't want it in the shadow_module\n        }\n    }\n    else {\n        // this assigns a function pointer (from loading the system image), to the function object\n        std::string funcName = lam->name->name;\n        funcName = \"julia_\" + funcName;\n        if (specsig) { // assumes !va\n            std::vector<Type*> fsig(0);\n            jl_value_t *jlrettype = jl_ast_rettype(lam, (jl_value_t*)lam->ast);\n            Type *rt = (jlrettype == (jl_value_t*)jl_void_type ? T_void : julia_type_to_llvm(jlrettype));\n            bool sret = false;\n            if (rt != jl_pvalue_llvmt && rt != T_void && deserves_sret(jlrettype, rt)) {\n                sret = true;\n                fsig.push_back(rt->getPointerTo());\n                rt = T_void;\n            }\n            for (size_t i=0; i < jl_nparams(lam->specTypes); i++) {\n                Type *ty = julia_type_to_llvm(jl_tparam(lam->specTypes,i));\n                if (type_is_ghost(ty))\n                    continue;\n                if (ty->isAggregateType())\n                    ty = PointerType::get(ty,0);\n                fsig.push_back(ty);\n            }\n            Function *f = Function::Create(FunctionType::get(rt, fsig, false), Function::ExternalLinkage, funcName,\n                                           shadow_module);\n            if (sret)\n                f->addAttribute(1, Attribute::StructRet);\n\n        if (lam->specFunctionObject == NULL) {\n            lam->specFunctionObject = (void*)f;\n            lam->specFunctionID = jl_assign_functionID(f);\n            }\n            add_named_global(f, (void*)fptr);\n        }\n        else {\n            Function *f = jlcall_func_to_llvm(funcName, fptr, shadow_module);\n            if (lam->functionObject == NULL) {\n                lam->functionObject = (void*)f;\n                lam->functionID = jl_assign_functionID(f);\n                assert(lam->fptr == &jl_trampoline);\n                lam->fptr = (jl_fptr_t)fptr;\n            }\n        }\n    }\n}\n\nextern \"C\" DLLEXPORT jl_value_t *jl_new_box(jl_value_t *v)\n{\n    jl_value_t *box = (jl_value_t*)jl_gc_alloc_1w();\n    jl_set_typeof(box, jl_box_any_type);\n    // if (v) jl_gc_wb(box, v); // write block not needed: box was just allocated\n    jl_data_ptr(box)[0] = v;\n    return box;\n}\n\n#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR == 3 && SYSTEM_LLVM\n#define INSTCOMBINE_BUG\n#define V128_BUG\n#endif\n\nstatic void init_julia_llvm_env(Module *m)\n{\n    MDNode* tbaa_root = mbuilder->createTBAARoot(\"jtbaa\");\n    tbaa_user = tbaa_make_child(\"jtbaa_user\",tbaa_root);\n    tbaa_value = tbaa_make_child(\"jtbaa_value\",tbaa_root);\n    tbaa_immut = tbaa_make_child(\"jtbaa_immut\",tbaa_root);\n    tbaa_array = tbaa_make_child(\"jtbaa_array\",tbaa_value);\n    tbaa_arrayptr = tbaa_make_child(\"jtbaa_arrayptr\",tbaa_array);\n    tbaa_arraysize = tbaa_make_child(\"jtbaa_arraysize\",tbaa_array);\n    tbaa_arraylen = tbaa_make_child(\"jtbaa_arraylen\",tbaa_array);\n    tbaa_sveclen = tbaa_make_child(\"jtbaa_sveclen\",tbaa_value);\n    tbaa_func = tbaa_make_child(\"jtbaa_func\",tbaa_value);\n    tbaa_datatype = tbaa_make_child(\"jtbaa_datatype\",tbaa_value);\n    tbaa_const = tbaa_make_child(\"jtbaa_const\",tbaa_root,true);\n\n    // every variable or function mapped in this function must be\n    // exported from libjulia, to support static compilation\n    T_int1  = Type::getInt1Ty(getGlobalContext());\n    T_int8  = Type::getInt8Ty(getGlobalContext());\n    T_pint8 = PointerType::get(T_int8, 0);\n    T_int16 = Type::getInt16Ty(getGlobalContext());\n    T_pint16 = PointerType::get(T_int16, 0);\n    T_int32 = Type::getInt32Ty(getGlobalContext());\n    T_char = Type::getInt32Ty(getGlobalContext());\n    T_pint32 = PointerType::get(T_int32, 0);\n    T_int64 = Type::getInt64Ty(getGlobalContext());\n    T_pint64 = PointerType::get(T_int64, 0);\n    T_uint8 = T_int8;   T_uint16 = T_int16;\n    T_uint32 = T_int32; T_uint64 = T_int64;\n    if (sizeof(size_t) == 8)\n        T_size = T_uint64;\n    else\n        T_size = T_uint32;\n    T_psize = PointerType::get(T_size, 0);\n    T_float16 = Type::getHalfTy(getGlobalContext());\n    T_float32 = Type::getFloatTy(getGlobalContext());\n    T_pfloat32 = PointerType::get(T_float32, 0);\n    T_float64 = Type::getDoubleTy(getGlobalContext());\n    T_pfloat64 = PointerType::get(T_float64, 0);\n    T_float128 = Type::getFP128Ty(getGlobalContext());\n    T_void = Type::getVoidTy(jl_LLVMContext);\n\n    // This type is used to create undef Values which carry metadata.\n    NoopType = ArrayType::get(T_int1,0);\n\n    // add needed base definitions to our LLVM environment\n    StructType *valueSt = StructType::create(getGlobalContext(), \"jl_value_t\");\n    Type *valueStructElts[1] = { PointerType::getUnqual(valueSt) };\n    ArrayRef<Type*> vselts(valueStructElts);\n    valueSt->setBody(vselts);\n    jl_value_llvmt = valueSt;\n\n    DIBuilder dbuilder(*m);\n#ifdef LLVM37\n    DIFile *julia_h = dbuilder.createFile(\"julia.h\",\"\");\n    jl_value_dillvmt = dbuilder.createStructType(nullptr,\n#else\n    DIFile julia_h = dbuilder.createFile(\"julia.h\",\"\");\n    jl_value_dillvmt = dbuilder.createStructType(DIDescriptor(),\n#endif\n        \"jl_value_t\",\n        julia_h,\n        71, // At the time of this writing. Not sure if it's worth it to keep this in sync\n        sizeof(jl_value_t)*8,\n        __alignof__(jl_value_t)*8,\n        0, // Flags\n#ifdef LLVM37\n        nullptr,    // Derived from\n        nullptr);  // Elements - will be corrected later\n#else\n        DIType(), // Derived from\n        DIArray()); // Elements - will be corrected later\n#endif\n\n    jl_pvalue_dillvmt = dbuilder.createPointerType(jl_value_dillvmt,sizeof(jl_value_t*)*8,\n                                                   __alignof__(jl_value_t*)*8);\n\n#ifdef LLVM36\n    SmallVector<llvm::Metadata *, 1> Elts;\n    std::vector<Metadata*> diargs(0);\n    Elts.push_back(jl_pvalue_dillvmt);\n    dbuilder.replaceArrays(jl_value_dillvmt,\n       dbuilder.getOrCreateArray(Elts));\n#else\n    SmallVector<llvm::Value *, 1> Elts;\n    std::vector<Value*> diargs(0);\n    Elts.push_back(jl_pvalue_dillvmt);\n    jl_value_dillvmt.setTypeArray(dbuilder.getOrCreateArray(Elts));\n#endif\n\n    jl_ppvalue_dillvmt = dbuilder.createPointerType(jl_pvalue_dillvmt,sizeof(jl_value_t**)*8,\n                                                    __alignof__(jl_value_t**)*8);\n\n    diargs.push_back(jl_pvalue_dillvmt);    // Return Type (ret value)\n    diargs.push_back(jl_pvalue_dillvmt);    // First Argument (function)\n    diargs.push_back(jl_ppvalue_dillvmt);   // Second Argument (argv)\n    // Third argument (length(argv))\n    diargs.push_back(julia_type_to_di((jl_value_t*)jl_int32_type,&dbuilder,false));\n\n#ifdef LLVM38\n    jl_di_func_sig = dbuilder.createSubroutineType(\n        dbuilder.getOrCreateTypeArray(diargs));\n#elif defined(LLVM36)\n    jl_di_func_sig = dbuilder.createSubroutineType(julia_h,\n        dbuilder.getOrCreateTypeArray(diargs));\n#else\n    jl_di_func_sig = dbuilder.createSubroutineType(julia_h,\n        dbuilder.getOrCreateArray(diargs));\n#endif\n\n    jl_pvalue_llvmt = PointerType::get(jl_value_llvmt, 0);\n    jl_ppvalue_llvmt = PointerType::get(jl_pvalue_llvmt, 0);\n    two_pvalue_llvmt.push_back(jl_pvalue_llvmt);\n    two_pvalue_llvmt.push_back(jl_pvalue_llvmt);\n    three_pvalue_llvmt.push_back(jl_pvalue_llvmt);\n    three_pvalue_llvmt.push_back(jl_pvalue_llvmt);\n    three_pvalue_llvmt.push_back(jl_pvalue_llvmt);\n    V_null = Constant::getNullValue(jl_pvalue_llvmt);\n    std::vector<Type*> ftargs(0);\n    ftargs.push_back(jl_pvalue_llvmt);\n    ftargs.push_back(jl_ppvalue_llvmt);\n    ftargs.push_back(T_int32);\n    jl_func_sig = FunctionType::get(jl_pvalue_llvmt, ftargs, false);\n    assert(jl_func_sig != NULL);\n    jl_pfptr_llvmt = PointerType::get(PointerType::get(jl_func_sig, 0), 0);\n\n    Type* vaelts[] = {T_pint8\n#ifdef STORE_ARRAY_LEN\n                      , T_size\n#endif\n                      , T_int16\n    };\n    Type* jl_array_llvmt =\n        StructType::create(jl_LLVMContext,\n                           ArrayRef<Type*>(vaelts,sizeof(vaelts)/sizeof(vaelts[0])),\n                           \"jl_array_t\");\n    jl_parray_llvmt = PointerType::get(jl_array_llvmt,0);\n\n    jlpgcstack_var =\n        new GlobalVariable(*m, jl_ppvalue_llvmt,\n                           false, GlobalVariable::ExternalLinkage,\n                           NULL, \"jl_pgcstack\");\n    add_named_global(jlpgcstack_var, (void*)&jl_pgcstack);\n\n    global_to_llvm(\"__stack_chk_guard\", (void*)&__stack_chk_guard, m);\n    Function *jl__stack_chk_fail =\n        Function::Create(FunctionType::get(T_void, false),\n                         Function::ExternalLinkage,\n                         \"__stack_chk_fail\", m);\n    jl__stack_chk_fail->setDoesNotReturn();\n    add_named_global(jl__stack_chk_fail, (void*)&__stack_chk_fail);\n\n    jltrue_var = global_to_llvm(\"jl_true\", (void*)&jl_true, m);\n    jlfalse_var = global_to_llvm(\"jl_false\", (void*)&jl_false, m);\n    jlemptysvec_var = global_to_llvm(\"jl_emptysvec\", (void*)&jl_emptysvec, m);\n    jlemptytuple_var = global_to_llvm(\"jl_emptytuple\", (void*)&jl_emptytuple, m);\n    jlexc_var = global_to_llvm(\"jl_exception_in_transit\",\n                               (void*)&jl_exception_in_transit, m);\n    jldiverr_var = global_to_llvm(\"jl_diverror_exception\",\n                                  (void*)&jl_diverror_exception, m);\n    jlundeferr_var = global_to_llvm(\"jl_undefref_exception\",\n                                    (void*)&jl_undefref_exception, m);\n    jldomerr_var = global_to_llvm(\"jl_domain_exception\",\n                                  (void*)&jl_domain_exception, m);\n    jlovferr_var = global_to_llvm(\"jl_overflow_exception\",\n                                  (void*)&jl_overflow_exception, m);\n    jlinexacterr_var = global_to_llvm(\"jl_inexact_exception\",\n                                      (void*)&jl_inexact_exception, m);\n\n    jlRTLD_DEFAULT_var =\n        new GlobalVariable(*m, T_pint8,\n                           true, GlobalVariable::ExternalLinkage,\n                           NULL, \"jl_RTLD_DEFAULT_handle\");\n    add_named_global(jlRTLD_DEFAULT_var, (void*)&jl_RTLD_DEFAULT_handle);\n#ifdef _OS_WINDOWS_\n    jlexe_var =\n        new GlobalVariable(*m, T_pint8,\n                           true, GlobalVariable::ExternalLinkage,\n                           NULL, \"jl_exe_handle\");\n    add_named_global(jlexe_var, (void*)&jl_exe_handle);\n    jldll_var =\n        new GlobalVariable(*m, T_pint8,\n                           true, GlobalVariable::ExternalLinkage,\n                           NULL, \"jl_dl_handle\");\n    add_named_global(jldll_var, (void*)&jl_dl_handle);\n#endif\n#if JL_NEED_FLOATTEMP_VAR\n    // Has to be big enough for the biggest LLVM-supported float type\n    jlfloattemp_var =\n        addComdat(new GlobalVariable(*m, IntegerType::get(jl_LLVMContext,128),\n                                     false, GlobalVariable::ExternalLinkage,\n                                     ConstantInt::get(IntegerType::get(jl_LLVMContext,128),0),\n                                     \"jl_float_temp\"));\n#endif\n\n    std::vector<Type*> args1(0);\n    args1.push_back(T_pint8);\n    jlerror_func =\n        Function::Create(FunctionType::get(T_void, args1, false),\n                         Function::ExternalLinkage,\n                         \"jl_error\", m);\n    jlerror_func->setDoesNotReturn();\n    add_named_global(jlerror_func, (void*)&jl_error);\n\n    std::vector<Type*> args1_(0);\n    args1_.push_back(jl_pvalue_llvmt);\n    jlthrow_func =\n        Function::Create(FunctionType::get(T_void, args1_, false),\n                         Function::ExternalLinkage,\n                         \"jl_throw\", m);\n    jlthrow_func->setDoesNotReturn();\n    add_named_global(jlthrow_func, (void*)&jl_throw);\n\n    jlundefvarerror_func =\n        Function::Create(FunctionType::get(T_void, args1_, false),\n                         Function::ExternalLinkage,\n                         \"jl_undefined_var_error\", m);\n    jlundefvarerror_func->setDoesNotReturn();\n    add_named_global(jlundefvarerror_func, (void*)&jl_undefined_var_error);\n\n    std::vector<Type*> args2_boundserrorv(0);\n    args2_boundserrorv.push_back(jl_pvalue_llvmt);\n    args2_boundserrorv.push_back(T_psize);\n    args2_boundserrorv.push_back(T_size);\n    jlboundserrorv_func =\n        Function::Create(FunctionType::get(T_void, args2_boundserrorv, false),\n                         Function::ExternalLinkage,\n                         \"jl_bounds_error_ints\", m);\n    jlboundserrorv_func->setDoesNotReturn();\n    add_named_global(jlboundserrorv_func, (void*)&jl_bounds_error_ints);\n\n    std::vector<Type*> args2_boundserror(0);\n    args2_boundserror.push_back(jl_pvalue_llvmt);\n    args2_boundserror.push_back(T_size);\n    jlboundserror_func =\n        Function::Create(FunctionType::get(T_void, args2_boundserror, false),\n                         Function::ExternalLinkage,\n                         \"jl_bounds_error_int\", m);\n    jlboundserror_func->setDoesNotReturn();\n    add_named_global(jlboundserror_func, (void*)&jl_bounds_error_int);\n\n    std::vector<Type*> args3_vboundserror(0);\n    args3_vboundserror.push_back(jl_ppvalue_llvmt);\n    args3_vboundserror.push_back(T_size);\n    args3_vboundserror.push_back(T_size);\n    jlvboundserror_func =\n        Function::Create(FunctionType::get(T_void, args3_vboundserror, false),\n                         Function::ExternalLinkage,\n                         \"jl_bounds_error_tuple_int\", m);\n    jlvboundserror_func->setDoesNotReturn();\n    add_named_global(jlvboundserror_func, (void*)&jl_bounds_error_tuple_int);\n\n    std::vector<Type*> args3_uboundserror(0);\n    args3_uboundserror.push_back(T_pint8);\n    args3_uboundserror.push_back(jl_pvalue_llvmt);\n    args3_uboundserror.push_back(T_size);\n    jluboundserror_func =\n        Function::Create(FunctionType::get(T_void, args3_uboundserror, false),\n                         Function::ExternalLinkage,\n                         \"jl_bounds_error_unboxed_int\", m);\n    jluboundserror_func->setDoesNotReturn();\n    add_named_global(jluboundserror_func, (void*)&jl_bounds_error_unboxed_int);\n\n    jlnew_func =\n        Function::Create(jl_func_sig, Function::ExternalLinkage,\n                         \"jl_new_structv\", m);\n    add_named_global(jlnew_func, (void*)&jl_new_structv);\n\n    std::vector<Type*> args2(0);\n    args2.push_back(T_pint8);\n#ifndef _OS_WINDOWS_\n    args2.push_back(T_int32);\n#endif\n    setjmp_func =\n        Function::Create(FunctionType::get(T_int32, args2, false),\n                         Function::ExternalLinkage, jl_setjmp_name, m);\n    setjmp_func->addFnAttr(Attribute::ReturnsTwice);\n    add_named_global(setjmp_func, (void*)&jl_setjmp_f);\n\n    std::vector<Type*> args_memcmp(0);\n    args_memcmp.push_back(T_pint8);\n    args_memcmp.push_back(T_pint8);\n    args_memcmp.push_back(T_size);\n    memcmp_func =\n        Function::Create(FunctionType::get(T_int32, args_memcmp, false),\n                         Function::ExternalLinkage, \"memcmp\", m);\n    add_named_global(memcmp_func, (void*)&memcmp);\n\n    std::vector<Type*> te_args(0);\n    te_args.push_back(T_pint8);\n    te_args.push_back(T_pint8);\n    te_args.push_back(jl_pvalue_llvmt);\n    te_args.push_back(jl_pvalue_llvmt);\n    jltypeerror_func =\n        Function::Create(FunctionType::get(T_void, te_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_type_error_rt\", m);\n    jltypeerror_func->setDoesNotReturn();\n    add_named_global(jltypeerror_func, (void*)&jl_type_error_rt);\n\n    std::vector<Type *> args_2ptrs(0);\n    args_2ptrs.push_back(jl_pvalue_llvmt);\n    args_2ptrs.push_back(jl_pvalue_llvmt);\n    jlcheckassign_func =\n        Function::Create(FunctionType::get(T_void, args_2ptrs, false),\n                         Function::ExternalLinkage,\n                         \"jl_checked_assignment\", m);\n    add_named_global(jlcheckassign_func, (void*)&jl_checked_assignment);\n\n    std::vector<Type *> args_1ptr(0);\n    args_1ptr.push_back(jl_pvalue_llvmt);\n    jldeclareconst_func =\n        Function::Create(FunctionType::get(T_void, args_1ptr, false),\n                         Function::ExternalLinkage,\n                         \"jl_declare_constant\", m);\n    add_named_global(jldeclareconst_func, (void*)&jl_declare_constant);\n\n    jlgetbindingorerror_func =\n        Function::Create(FunctionType::get(jl_pvalue_llvmt, args_2ptrs, false),\n                         Function::ExternalLinkage,\n                         \"jl_get_binding_or_error\", m);\n    add_named_global(jlgetbindingorerror_func, (void*)&jl_get_binding_or_error);\n\n    builtin_func_map[jl_f_is] = jlcall_func_to_llvm(\"jl_f_is\", (void*)&jl_f_is, m);\n    builtin_func_map[jl_f_typeof] = jlcall_func_to_llvm(\"jl_f_typeof\", (void*)&jl_f_typeof, m);\n    builtin_func_map[jl_f_sizeof] = jlcall_func_to_llvm(\"jl_f_sizeof\", (void*)&jl_f_sizeof, m);\n    builtin_func_map[jl_f_subtype] = jlcall_func_to_llvm(\"jl_f_subtype\", (void*)&jl_f_subtype, m);\n    builtin_func_map[jl_f_isa] = jlcall_func_to_llvm(\"jl_f_isa\", (void*)&jl_f_isa, m);\n    builtin_func_map[jl_f_typeassert] = jlcall_func_to_llvm(\"jl_f_typeassert\", (void*)&jl_f_typeassert, m);\n    builtin_func_map[jl_f_apply] = jlcall_func_to_llvm(\"jl_f_apply\", (void*)&jl_f_apply, m);\n    builtin_func_map[jl_f_kwcall] = jlcall_func_to_llvm(\"jl_f_kwcall\", (void*)&jl_f_kwcall, m);\n    builtin_func_map[jl_f_throw] = jlcall_func_to_llvm(\"jl_f_throw\", (void*)&jl_f_throw, m);\n    builtin_func_map[jl_f_tuple] = jlcall_func_to_llvm(\"jl_f_tuple\", (void*)&jl_f_tuple, m);\n    builtin_func_map[jl_f_svec] = jlcall_func_to_llvm(\"jl_f_svec\", (void*)&jl_f_svec, m);\n    builtin_func_map[jl_f_methodexists] = jlcall_func_to_llvm(\"jl_f_methodexists\", (void*)&jl_f_methodexists, m);\n    builtin_func_map[jl_f_applicable] = jlcall_func_to_llvm(\"jl_f_applicable\", (void*)&jl_f_applicable, m);\n    builtin_func_map[jl_f_invoke] = jlcall_func_to_llvm(\"jl_f_invoke\", (void*)&jl_f_invoke, m);\n    builtin_func_map[jl_f_top_eval] = jlcall_func_to_llvm(\"jl_f_top_eval\", (void*)&jl_f_top_eval, m);\n    builtin_func_map[jl_f_isdefined] = jlcall_func_to_llvm(\"jl_f_isdefined\", (void*)&jl_f_isdefined, m);\n    builtin_func_map[jl_f_get_field] = jlcall_func_to_llvm(\"jl_f_get_field\", (void*)&jl_f_get_field, m);\n    builtin_func_map[jl_f_set_field] = jlcall_func_to_llvm(\"jl_f_set_field\", (void*)&jl_f_set_field, m);\n    builtin_func_map[jl_f_field_type] = jlcall_func_to_llvm(\"jl_f_field_type\", (void*)&jl_f_field_type, m);\n    builtin_func_map[jl_f_nfields] = jlcall_func_to_llvm(\"jl_f_nfields\", (void*)&jl_f_nfields, m);\n    builtin_func_map[jl_f_new_expr] = jlcall_func_to_llvm(\"jl_f_new_expr\", (void*)&jl_f_new_expr, m);\n    builtin_func_map[jl_f_arraylen] = jlcall_func_to_llvm(\"jl_f_arraylen\", (void*)&jl_f_arraylen, m);\n    builtin_func_map[jl_f_arrayref] = jlcall_func_to_llvm(\"jl_f_arrayref\", (void*)&jl_f_arrayref, m);\n    builtin_func_map[jl_f_arrayset] = jlcall_func_to_llvm(\"jl_f_arrayset\", (void*)&jl_f_arrayset, m);\n    builtin_func_map[jl_f_arraysize] = jlcall_func_to_llvm(\"jl_f_arraysize\", (void*)&jl_f_arraysize, m);\n    builtin_func_map[jl_f_instantiate_type] = jlcall_func_to_llvm(\"jl_f_instantiate_type\", (void*)&jl_f_instantiate_type, m);\n    jltuple_func = builtin_func_map[jl_f_tuple];\n    jlgetfield_func = builtin_func_map[jl_f_get_field];\n    jlapplygeneric_func = jlcall_func_to_llvm(\"jl_apply_generic\", (void*)&jl_apply_generic, m);\n\n    queuerootfun = Function::Create(FunctionType::get(T_void, args_1ptr, false),\n                                    Function::ExternalLinkage,\n                                    \"jl_gc_queue_root\", m);\n    add_named_global(queuerootfun, (void*)&jl_gc_queue_root);\n\n    std::vector<Type *> wbargs(0);\n    wbargs.push_back(jl_pvalue_llvmt);\n    wbargs.push_back(jl_pvalue_llvmt);\n    wbfunc = Function::Create(FunctionType::get(T_void, wbargs, false),\n                              Function::ExternalLinkage,\n                              \"jl_gc_wb_slow\", m);\n    add_named_global(wbfunc, (void*)&jl_gc_wb_slow);\n\n    std::vector<Type *> exp_args(0);\n    exp_args.push_back(T_int1);\n    expect_func = Intrinsic::getDeclaration(m, Intrinsic::expect, exp_args);\n\n    std::vector<Type*> args3(0);\n    args3.push_back(jl_pvalue_llvmt);\n    jlbox_func =\n        Function::Create(FunctionType::get(jl_pvalue_llvmt, args3, false),\n                         Function::ExternalLinkage,\n                         \"jl_new_box\", m);\n    add_named_global(jlbox_func, (void*)&jl_new_box);\n\n    jltopeval_func =\n        Function::Create(FunctionType::get(jl_pvalue_llvmt, args3, false),\n                         Function::ExternalLinkage,\n                         \"jl_toplevel_eval\", m);\n    add_named_global(jltopeval_func, (void*)&jl_toplevel_eval);\n\n    jlcopyast_func =\n        Function::Create(FunctionType::get(jl_pvalue_llvmt, args3, false),\n                         Function::ExternalLinkage,\n                         \"jl_copy_ast\", m);\n    add_named_global(jlcopyast_func, (void*)&jl_copy_ast);\n\n    std::vector<Type*> args4(0);\n    args4.push_back(T_pint8);\n    args4.push_back(jl_pvalue_llvmt);\n    args4.push_back(jl_pvalue_llvmt);\n    jlclosure_func =\n        Function::Create(FunctionType::get(jl_pvalue_llvmt, args4, false),\n                         Function::ExternalLinkage,\n                         \"jl_new_closure\", m);\n    add_named_global(jlclosure_func, (void*)&jl_new_closure);\n\n    std::vector<Type*> args5(0);\n    args5.push_back(T_size);\n    jlnsvec_func =\n        Function::Create(FunctionType::get(jl_pvalue_llvmt, args5, true),\n                         Function::ExternalLinkage,\n                         \"jl_svec\", m);\n    add_named_global(jlnsvec_func, (void*)&jl_svec);\n\n    std::vector<Type*> mdargs(0);\n    mdargs.push_back(jl_pvalue_llvmt);\n    mdargs.push_back(jl_ppvalue_llvmt);\n    mdargs.push_back(jl_pvalue_llvmt);\n    mdargs.push_back(jl_pvalue_llvmt);\n    mdargs.push_back(jl_pvalue_llvmt);\n    mdargs.push_back(jl_pvalue_llvmt);\n    mdargs.push_back(jl_pvalue_llvmt);\n    mdargs.push_back(jl_pvalue_llvmt);\n    mdargs.push_back(T_int32);\n    jlmethod_func =\n        Function::Create(FunctionType::get(jl_pvalue_llvmt, mdargs, false),\n                         Function::ExternalLinkage,\n                         \"jl_method_def\", m);\n    add_named_global(jlmethod_func, (void*)&jl_method_def);\n\n    std::vector<Type*> funcdefargs(0);\n    funcdefargs.push_back(jl_pvalue_llvmt);\n    funcdefargs.push_back(jl_ppvalue_llvmt);\n    funcdefargs.push_back(jl_pvalue_llvmt);\n    funcdefargs.push_back(jl_pvalue_llvmt);\n    jlgenericfunction_func =\n        Function::Create(FunctionType::get(jl_pvalue_llvmt, funcdefargs, false),\n                         Function::ExternalLinkage,\n                         \"jl_generic_function_def\", m);\n    add_named_global(jlgenericfunction_func, (void*)&jl_generic_function_def);\n\n    std::vector<Type*> ehargs(0);\n    ehargs.push_back(T_pint8);\n    jlenter_func =\n        Function::Create(FunctionType::get(T_void, ehargs, false),\n                         Function::ExternalLinkage,\n                         \"jl_enter_handler\", m);\n    add_named_global(jlenter_func, (void*)&jl_enter_handler);\n\n#ifdef _OS_WINDOWS_\n    resetstkoflw_func = Function::Create(FunctionType::get(T_void, false),\n            Function::ExternalLinkage, \"_resetstkoflw\", m);\n    add_named_global(resetstkoflw_func, (void*)&_resetstkoflw);\n#if defined(_CPU_X86_64_)\n#if defined(_COMPILER_MINGW_)\n    Function *chkstk_func = Function::Create(FunctionType::get(T_void, false),\n            Function::ExternalLinkage, \"___chkstk_ms\", m);\n    add_named_global(chkstk_func, (void*)&___chkstk_ms);\n#else\n    Function *chkstk_func = Function::Create(FunctionType::get(T_void, false),\n            Function::ExternalLinkage, \"__chkstk\", m);\n    add_named_global(chkstk_func, (void*)&__chkstk);\n#endif\n#else\n#if defined(_COMPILER_MINGW_)\n    Function *chkstk_func = Function::Create(FunctionType::get(T_void, false),\n            Function::ExternalLinkage, \"_alloca\", m);\n    add_named_global(chkstk_func, (void*)&_alloca);\n#else\n    Function *chkstk_func = Function::Create(FunctionType::get(T_void, false),\n            Function::ExternalLinkage, \"_chkstk\", m);\n    add_named_global(chkstk_func, (void*)&_chkstk);\n#endif\n#endif\n#endif\n\n    std::vector<Type*> lhargs(0);\n    lhargs.push_back(T_int32);\n    jlleave_func =\n        Function::Create(FunctionType::get(T_void, lhargs, false),\n                         Function::ExternalLinkage,\n                         \"jl_pop_handler\", m);\n    add_named_global(jlleave_func, (void*)&jl_pop_handler);\n\n    std::vector<Type *> args_2vals(0);\n    args_2vals.push_back(jl_pvalue_llvmt);\n    args_2vals.push_back(jl_pvalue_llvmt);\n    jlegal_func =\n        Function::Create(FunctionType::get(T_int32, args_2vals, false),\n                         Function::ExternalLinkage,\n                         \"jl_egal\", m);\n    add_named_global(jlegal_func, (void*)&jl_egal);\n\n    std::vector<Type *> subt_args(0);\n    subt_args.push_back(jl_pvalue_llvmt);\n    subt_args.push_back(jl_pvalue_llvmt);\n    subt_args.push_back(T_int32);\n    jlsubtype_func =\n        Function::Create(FunctionType::get(T_int32, subt_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_subtype\", m);\n    add_named_global(jlsubtype_func, (void*)&jl_subtype);\n\n    std::vector<Type*> aoargs(0);\n    aoargs.push_back(T_size);\n    jlallocobj_func =\n        Function::Create(FunctionType::get(jl_pvalue_llvmt, aoargs, false),\n                         Function::ExternalLinkage,\n                         \"jl_gc_allocobj\", m);\n    add_named_global(jlallocobj_func, (void*)&jl_gc_allocobj);\n\n    std::vector<Type*> empty_args(0);\n    jlalloc1w_func =\n        Function::Create(FunctionType::get(jl_pvalue_llvmt, empty_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_gc_alloc_1w\", m);\n    add_named_global(jlalloc1w_func, (void*)&jl_gc_alloc_1w);\n\n    jlalloc2w_func =\n        Function::Create(FunctionType::get(jl_pvalue_llvmt, empty_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_gc_alloc_2w\", m);\n    add_named_global(jlalloc2w_func, (void*)&jl_gc_alloc_2w);\n\n    jlalloc3w_func =\n        Function::Create(FunctionType::get(jl_pvalue_llvmt, empty_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_gc_alloc_3w\", m);\n    add_named_global(jlalloc3w_func, (void*)&jl_gc_alloc_3w);\n\n    std::vector<Type*> atargs(0);\n    atargs.push_back(T_size);\n    jl_alloc_svec_func =\n        Function::Create(FunctionType::get(jl_pvalue_llvmt, atargs, false),\n                         Function::ExternalLinkage,\n                         \"jl_alloc_svec\", m);\n    add_named_global(jl_alloc_svec_func, (void*)&jl_alloc_svec);\n\n    std::vector<Type *> dlsym_args(0);\n    dlsym_args.push_back(T_pint8);\n    dlsym_args.push_back(T_pint8);\n    dlsym_args.push_back(PointerType::get(T_pint8,0));\n    jldlsym_func =\n        Function::Create(FunctionType::get(T_pint8, dlsym_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_load_and_lookup\", m);\n    add_named_global(jldlsym_func, (void*)&jl_load_and_lookup);\n\n    std::vector<Type *> newbits_args(0);\n    newbits_args.push_back(jl_pvalue_llvmt);\n    newbits_args.push_back(T_pint8);\n    jlnewbits_func =\n        Function::Create(FunctionType::get(jl_pvalue_llvmt, newbits_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_new_bits\", m);\n    add_named_global(jlnewbits_func, (void*)&jl_new_bits);\n\n    std::vector<Type *> getnthfld_args(0);\n    getnthfld_args.push_back(jl_pvalue_llvmt);\n    getnthfld_args.push_back(T_size);\n    jlgetnthfieldchecked_func =\n        Function::Create(FunctionType::get(jl_pvalue_llvmt, getnthfld_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_get_nth_field_checked\", m);\n    add_named_global(jlgetnthfieldchecked_func, (void*)*jl_get_nth_field_checked);\n\n    diff_gc_total_bytes_func =\n        Function::Create(FunctionType::get(T_int64, false),\n                         Function::ExternalLinkage,\n                         \"jl_gc_diff_total_bytes\", m);\n    add_named_global(diff_gc_total_bytes_func, (void*)*jl_gc_diff_total_bytes);\n    std::vector<Type*> array_owner_args(0);\n    array_owner_args.push_back(jl_pvalue_llvmt);\n    jlarray_data_owner_func =\n        Function::Create(FunctionType::get(jl_pvalue_llvmt, array_owner_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_array_data_owner\", m);\n    jlarray_data_owner_func->setAttributes(\n        jlarray_data_owner_func->getAttributes()\n        .addAttribute(jlarray_data_owner_func->getContext(),\n                      AttributeSet::FunctionIndex, Attribute::ReadOnly)\n        .addAttribute(jlarray_data_owner_func->getContext(),\n                      AttributeSet::FunctionIndex, Attribute::NoUnwind));\n    add_named_global(jlarray_data_owner_func, (void*)*jl_array_data_owner);\n\n    // set up optimization passes\n#ifdef LLVM38\n    FPM = new legacy::FunctionPassManager(m);\n#else\n    FPM = new FunctionPassManager(m);\n#endif\n\n#ifdef LLVM37\n// No DataLayout pass needed anymore.\n#elif LLVM36\n    jl_data_layout = new llvm::DataLayoutPass();\n#elif LLVM35\n    jl_data_layout = new llvm::DataLayoutPass(*jl_ExecutionEngine->getDataLayout());\n#else\n    jl_data_layout = new DataLayout(*jl_ExecutionEngine->getDataLayout());\n#endif\n\n#ifndef LLVM37\n    FPM->add(jl_data_layout);\n#endif\n\n#ifdef __has_feature\n#   if __has_feature(address_sanitizer)\n    FPM->add(createAddressSanitizerFunctionPass());\n#   endif\n#   if __has_feature(memory_sanitizer)\n    FPM->add(llvm::createMemorySanitizerPass(true));\n#   endif\n#endif\n#ifndef LLVM37\n    jl_TargetMachine->addAnalysisPasses(*FPM);\n#endif\n#ifdef LLVM38\n    FPM->add(createTypeBasedAAWrapperPass());\n#else\n    FPM->add(createTypeBasedAliasAnalysisPass());\n#endif\n    if (jl_options.opt_level>=1) {\n#ifdef LLVM38\n        FPM->add(createBasicAAWrapperPass());\n#else\n        FPM->add(createBasicAliasAnalysisPass());\n#endif\n    }\n    // list of passes from vmkit\n    FPM->add(createCFGSimplificationPass()); // Clean up disgusting code\n    FPM->add(createPromoteMemoryToRegisterPass());// Kill useless allocas\n\n#ifndef INSTCOMBINE_BUG\n    FPM->add(createInstructionCombiningPass()); // Cleanup for scalarrepl.\n#endif\n    FPM->add(createScalarReplAggregatesPass()); // Break up aggregate allocas\n#ifndef INSTCOMBINE_BUG\n    FPM->add(createInstructionCombiningPass()); // Cleanup for scalarrepl.\n#endif\n    FPM->add(createJumpThreadingPass());        // Thread jumps.\n    // NOTE: CFG simp passes after this point seem to hurt native codegen.\n    // See issue #6112. Should be re-evaluated when we switch to MCJIT.\n    //FPM->add(createCFGSimplificationPass());    // Merge & remove BBs\n#ifndef INSTCOMBINE_BUG\n    FPM->add(createInstructionCombiningPass()); // Combine silly seq's\n#endif\n\n    //FPM->add(createCFGSimplificationPass());    // Merge & remove BBs\n    FPM->add(createReassociatePass());          // Reassociate expressions\n\n    // this has the potential to make some things a bit slower\n    //FPM->add(createBBVectorizePass());\n\n    FPM->add(createEarlyCSEPass()); //// ****\n\n    FPM->add(createLoopIdiomPass()); //// ****\n    FPM->add(createLoopRotatePass());           // Rotate loops.\n    // LoopRotate strips metadata from terminator, so run LowerSIMD afterwards\n    FPM->add(createLowerSimdLoopPass());        // Annotate loop marked with \"simdloop\" as LLVM parallel loop\n    FPM->add(createLICMPass());                 // Hoist loop invariants\n    FPM->add(createLoopUnswitchPass());         // Unswitch loops.\n    // Subsequent passes not stripping metadata from terminator\n#ifndef INSTCOMBINE_BUG\n    FPM->add(createInstructionCombiningPass());\n#endif\n    FPM->add(createIndVarSimplifyPass());       // Canonicalize indvars\n    FPM->add(createLoopDeletionPass());         // Delete dead loops\n#if LLVM35\n    FPM->add(createSimpleLoopUnrollPass());     // Unroll small loops\n#else\n    FPM->add(createLoopUnrollPass());           // Unroll small loops\n#endif\n#if !LLVM35 && !defined(INSTCOMBINE_BUG)\n    FPM->add(createLoopVectorizePass());        // Vectorize loops\n#endif\n    //FPM->add(createLoopStrengthReducePass());   // (jwb added)\n\n#ifndef INSTCOMBINE_BUG\n    FPM->add(createInstructionCombiningPass()); // Clean up after the unroller\n#endif\n    FPM->add(createGVNPass());                  // Remove redundancies\n    //FPM->add(createMemCpyOptPass());            // Remove memcpy / form memset\n    FPM->add(createSCCPPass());                 // Constant prop with SCCP\n\n    // Run instcombine after redundancy elimination to exploit opportunities\n    // opened up by them.\n    FPM->add(createSinkingPass()); ////////////// ****\n    FPM->add(createInstructionSimplifierPass());///////// ****\n#ifndef INSTCOMBINE_BUG\n    FPM->add(createInstructionCombiningPass());\n#endif\n    FPM->add(createJumpThreadingPass());         // Thread jumps\n    FPM->add(createDeadStoreEliminationPass());  // Delete dead stores\n#if !defined(INSTCOMBINE_BUG)\n    if (jl_options.opt_level>=1)\n        FPM->add(createSLPVectorizerPass());     // Vectorize straight-line code\n#endif\n\n    FPM->add(createAggressiveDCEPass());         // Delete dead instructions\n#if !defined(INSTCOMBINE_BUG)\n    if (jl_options.opt_level>=1)\n        FPM->add(createInstructionCombiningPass());   // Clean up after SLP loop vectorizer\n#endif\n#if LLVM35\n    FPM->add(createLoopVectorizePass());         // Vectorize loops\n    FPM->add(createInstructionCombiningPass());  // Clean up after loop vectorizer\n#endif\n    //FPM->add(createCFGSimplificationPass());     // Merge & remove BBs\n\n    FPM->doInitialization();\n}\n\n// Helper to figure out what features to set for the LLVM target\n// If the user specifies native ( or does not specify ) we default\n// using the API provided by LLVM\nstatic inline SmallVector<std::string,10> getTargetFeatures() {\n  StringMap<bool> HostFeatures;\n  if( !strcmp(jl_options.cpu_target,\"native\") )\n  {\n    // On earlier versions of LLVM this is empty\n    llvm::sys::getHostCPUFeatures(HostFeatures);\n  }\n\n  // Platform specific overides follow\n#if defined(_CPU_X86_64_) || defined(_CPU_X86_)\n#ifndef USE_MCJIT\n    // Temporarily disable Haswell BMI2 features due to LLVM bug.\n  HostFeatures[\"bmi2\"] = false;\n  HostFeatures[\"avx2\"] = false;\n#endif\n#ifdef V128_BUG\n  HostFeatures[\"avx\"] = false;\n#endif\n#endif\n\n  // Figure out if we know the cpu_target\n  std::string cpu = strcmp(jl_options.cpu_target,\"native\") ? jl_options.cpu_target : sys::getHostCPUName();\n  if (cpu.empty() || cpu == \"generic\") {\n    jl_printf(JL_STDERR, \"WARNING: unable to determine host cpu name.\\n\");\n#ifdef _CPU_ARM_\n    // Check if this is required when you have read the features directly from the processor\n    // the processors that don't have VFP are old and (hopefully) rare. this affects the platform calling convention.\n    HostFeatures[\"vfp2\"] = true;\n#endif\n  }\n\n  SmallVector<std::string,10> attr;\n  for( StringMap<bool>::const_iterator it = HostFeatures.begin(); it != HostFeatures.end(); it++  )\n  {\n    std::string att = it->getValue() ? it->getKey().str() :\n                      std::string(\"-\") + it->getKey().str();\n    attr.append( 1, att );\n  }\n  return attr;\n}\n\nextern \"C\" void jl_init_codegen(void)\n{\n    const char *const argv_tailmerge[] = {\"\", \"-enable-tail-merge=0\"}; // NOO TOUCHIE; NO TOUCH! See #922\n    cl::ParseCommandLineOptions(sizeof(argv_tailmerge)/sizeof(argv_tailmerge[0]), argv_tailmerge, \"disable-tail-merge\\n\");\n#if defined(_OS_WINDOWS_) && defined(_CPU_X86_64_)\n    const char *const argv_copyprop[] = {\"\", \"-disable-copyprop\"}; // llvm bug 21743\n    cl::ParseCommandLineOptions(sizeof(argv_copyprop)/sizeof(argv_copyprop[0]), argv_copyprop, \"disable-copyprop\\n\");\n#endif\n#ifdef JL_DEBUG_BUILD\n    cl::ParseEnvironmentOptions(\"Julia\", \"JULIA_LLVM_ARGS\");\n#endif\n\n#if defined(_CPU_PPC_) || defined(_CPU_PPC64_)\n    imaging_mode = true; // LLVM seems to JIT bad TOC tables for the optimizations we attempt in non-imaging_mode\n#else\n    imaging_mode = jl_generating_output();\n#endif\n\n#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR <= 3\n    // this option disables LLVM's signal handlers\n    llvm::DisablePrettyStackTrace = true;\n#endif\n\n    InitializeNativeTarget();\n    InitializeNativeTargetAsmPrinter();\n    InitializeNativeTargetAsmParser();\n\n    Module *m, *engine_module;\n\n#ifdef USE_MCJIT\n    m = shadow_module = new Module(\"shadow\", jl_LLVMContext);\n    jl_setup_module(shadow_module,false);\n    if (imaging_mode) {\n        engine_module = new Module(\"engine_module\", jl_LLVMContext);\n        jl_setup_module(engine_module,false);\n    }\n    else {\n        engine_module = m;\n    }\n#else\n    engine_module = m = jl_Module = new Module(\"julia\", jl_LLVMContext);\n    jl_setup_module(engine_module,false);\n#endif\n\n    TargetOptions options = TargetOptions();\n    //options.PrintMachineCode = true; //Print machine code produced during JIT compiling\n#if defined(JL_DEBUG_BUILD) && !defined(LLVM37)\n    options.JITEmitDebugInfo = true;\n#endif\n#ifndef LLVM37\n    options.NoFramePointerElim = true;\n#endif\n#ifndef LLVM34\n    options.NoFramePointerElimNonLeaf = true;\n#endif\n#if defined(_OS_WINDOWS_) && !defined(_CPU_X86_64_)\n    // tell Win32 to assume the stack is always 16-byte aligned,\n    // and to ensure that it is 16-byte aligned for out-going calls,\n    // to ensure compatibility with GCC codes\n    options.StackAlignmentOverride = 16;\n#endif\n#if defined(__APPLE__) && !defined(LLVM34)\n    // turn on JIT support for libunwind to walk the stack\n    options.JITExceptionHandling = 1;\n#endif\n#ifdef USE_MCJIT\n    jl_mcjmm = new SectionMemoryManager();\n#endif\n\n#ifdef LLVM36\n    EngineBuilder eb(std::move(std::unique_ptr<Module>(engine_module)));\n#else\n    EngineBuilder eb(engine_module);\n#endif\n    std::string ErrorStr;\n    eb  .setEngineKind(EngineKind::JIT)\n#if defined(_OS_WINDOWS_) && defined(_CPU_X86_64_) && !defined(USE_MCJIT)\n        .setJITMemoryManager(createJITMemoryManagerWin())\n#elif defined(CUSTOM_MEMORY_MANAGER)\n        .setMCJITMemoryManager(std::move(std::unique_ptr<RTDyldMemoryManager>{createRTDyldMemoryManagerOSX()}))\n#elif defined(USE_ORCJIT) // ORCJIT forgets to create one if one isn't created for it\n        .setMCJITMemoryManager(std::move(std::unique_ptr<RTDyldMemoryManager>{new SectionMemoryManager()}))\n#endif\n        .setTargetOptions(options)\n        .setRelocationModel(Reloc::PIC_)\n        .setCodeModel(CodeModel::Small)\n#if defined(USE_MCJIT) && !defined(LLVM36)\n        .setUseMCJIT(true)\n#endif\n#ifdef USE_ORCJIT\n        .setUseOrcMCJITReplacement(true)\n#endif\n    ;\n    Triple TheTriple(sys::getProcessTriple());\n#if defined(FORCE_ELF)\n#ifdef LLVM35\n    TheTriple.setObjectFormat(Triple::ELF);\n#else\n    TheTriple.setEnvironment(Triple::ELF);\n#endif\n#endif\n    std::string TheCPU = strcmp(jl_options.cpu_target,\"native\") ? jl_options.cpu_target : sys::getHostCPUName();\n    SmallVector<std::string, 10>  targetFeatures = getTargetFeatures( );\n    TargetMachine *targetMachine = eb.selectTarget(\n            TheTriple,\n            \"\",\n            TheCPU,\n            targetFeatures);\n    assert(targetMachine && \"Failed to select target machine -\"\n                            \" Is the LLVM backend for this CPU enabled?\");\n    jl_TargetMachine = targetMachine->getTarget().createTargetMachine(\n            TheTriple.getTriple(),\n            targetMachine->getTargetCPU(),\n            targetMachine->getTargetFeatureString(),\n            targetMachine->Options,\n#ifdef CODEGEN_TLS\n            Reloc::PIC_,\n            CodeModel::Small,\n#else\n            Reloc::Default,\n            CodeModel::JITDefault,\n#endif\n#ifdef DISABLE_OPT\n            CodeGenOpt::None\n#else\n            CodeGenOpt::Aggressive // -O3\n#endif\n            );\n    delete targetMachine;\n    assert(jl_TargetMachine);\n#if defined(USE_MCJIT) && !defined(_CPU_ARM_)\n    // FastISel seems to be buggy for ARM. Ref #13321\n    jl_TargetMachine->setFastISel(true);\n#endif\n#if defined(LLVM38)\n    engine_module->setDataLayout(jl_TargetMachine->createDataLayout());\n#elif defined(LLVM36) && !defined(LLVM37)\n    engine_module->setDataLayout(jl_TargetMachine->getSubtargetImpl()->getDataLayout());\n#elif defined(LLVM35) && !defined(LLVM37)\n    engine_module->setDataLayout(jl_TargetMachine->getDataLayout());\n#else\n    engine_module->setDataLayout(jl_TargetMachine->getDataLayout()->getStringRepresentation());\n#endif\n    jl_ExecutionEngine = eb.create(jl_TargetMachine);\n    //jl_printf(JL_STDERR,\"%s\\n\",jl_ExecutionEngine->getDataLayout()->getStringRepresentation().c_str());\n    if (!jl_ExecutionEngine) {\n        jl_printf(JL_STDERR, \"Critical error initializing llvm: %s\\n\",\n                  ErrorStr.c_str());\n        exit(1);\n    }\n#if defined(LLVM35) && !defined(USE_ORCJIT)\n    jl_ExecutionEngine->setProcessAllSections(true);\n#endif\n    jl_ExecutionEngine->DisableLazyCompilation();\n    mbuilder = new MDBuilder(getGlobalContext());\n\n#ifdef LLVM37\n#ifdef LLVM38\n    m->setDataLayout(jl_ExecutionEngine->getDataLayout().getStringRepresentation());\n    engine_module->setDataLayout(jl_ExecutionEngine->getDataLayout().getStringRepresentation());\n#else\n    m->setDataLayout(jl_ExecutionEngine->getDataLayout()->getStringRepresentation());\n    engine_module->setDataLayout(jl_ExecutionEngine->getDataLayout()->getStringRepresentation());\n#endif\n    m->setTargetTriple(jl_TargetMachine->getTargetTriple().str());\n    engine_module->setTargetTriple(jl_TargetMachine->getTargetTriple().str());\n#elif LLVM36\n    m->setDataLayout(jl_ExecutionEngine->getDataLayout());\n    engine_module->setDataLayout(jl_ExecutionEngine->getDataLayout());\n#endif\n    init_julia_llvm_env(m);\n\n    RegisterJuliaJITEventListener();\n#ifdef JL_USE_INTEL_JITEVENTS\n    if (jl_using_intel_jitevents)\n        jl_ExecutionEngine->RegisterJITEventListener(\n            JITEventListener::createIntelJITEventListener());\n#endif // JL_USE_INTEL_JITEVENTS\n\n    BOX_F(int8,int8);  UBOX_F(uint8,uint8);\n    BOX_F(int16,int16); UBOX_F(uint16,uint16);\n    BOX_F(int32,int32); UBOX_F(uint32,uint32);\n    BOX_F(int64,int64); UBOX_F(uint64,uint64);\n    BOX_F(float32,float32); BOX_F(float64,float64);\n    BOX_F(char,char);\n    UBOX_F(gensym,size);\n\n    box8_func  = boxfunc_llvm(ft2arg(jl_pvalue_llvmt, jl_pvalue_llvmt, T_int8),\n                              \"jl_box8\", (void*)&jl_box8, m);\n    box16_func = boxfunc_llvm(ft2arg(jl_pvalue_llvmt, jl_pvalue_llvmt, T_int16),\n                              \"jl_box16\", (void*)&jl_box16, m);\n    box32_func = boxfunc_llvm(ft2arg(jl_pvalue_llvmt, jl_pvalue_llvmt, T_int32),\n                              \"jl_box32\", (void*)&jl_box32, m);\n    box64_func = boxfunc_llvm(ft2arg(jl_pvalue_llvmt, jl_pvalue_llvmt, T_int64),\n                              \"jl_box64\", (void*)&jl_box64, m);\n\n    typeToTypeId = jl_alloc_cell_1d(16);\n}\n\n// for debugging from gdb\nextern \"C\" void jl_dump_llvm_value(void *v)\n{\n    ((Value*)v)->dump();\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/src/ccall.cpp": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n// --- the ccall intrinsic ---\n\n// --- library symbol lookup ---\n\n// map from \"libX\" to full soname \"libX.so.ver\"\n#if defined(__linux__) || defined(__FreeBSD__)\nstatic std::map<std::string, std::string> sonameMap;\nstatic bool got_sonames = false;\n\nextern \"C\" DLLEXPORT void jl_read_sonames(void)\n{\n    char *line=NULL;\n    size_t sz=0;\n#if defined(__linux__)\n    FILE *ldc = popen(\"/sbin/ldconfig -p\", \"r\");\n#else\n    FILE *ldc = popen(\"/sbin/ldconfig -r\", \"r\");\n#endif\n    if (ldc == NULL) return; // ignore errors in running ldconfig (other than whatever might have been printed to stderr)\n\n    while (!feof(ldc)) {\n        ssize_t n = getline(&line, &sz, ldc);\n        if (n == -1)\n            break;\n        if (n > 2 && isspace((unsigned char)line[0])) {\n#ifdef __linux__\n            int i = 0;\n            while (isspace((unsigned char)line[++i])) ;\n            char *name = &line[i];\n            char *dot = strstr(name, \".so\");\n            i = 0;\n#else\n            char *name = strstr(line, \":-l\");\n            if (name == NULL) continue;\n            strncpy(name, \"lib\", 3);\n            char *dot = strchr(name, '.');\n#endif\n\n            if (NULL == dot)\n                continue;\n\n#ifdef __linux__\n            // Detect if this entry is for the current architecture\n            while (!isspace((unsigned char)dot[++i])) ;\n            while (isspace((unsigned char)dot[++i])) ;\n            int j = i;\n            while (!isspace((unsigned char)dot[++j])) ;\n            char *arch = strstr(dot+i,\"x86-64\");\n            if (arch != NULL && arch < dot + j) {\n#ifdef _P32\n                continue;\n#endif\n            }\n            else {\n#ifdef _P64\n                continue;\n#endif\n            }\n#endif // __linux__\n\n            char *abslibpath = strrchr(line, ' ');\n            if (dot != NULL && abslibpath != NULL) {\n                std::string pfx(name, dot - name);\n                // Do not include ' ' in front and '\\n' at the end\n                std::string soname(abslibpath+1, line+n-(abslibpath+1)-1);\n                sonameMap[pfx] = soname;\n            }\n        }\n    }\n\n    free(line);\n    pclose(ldc);\n}\n\nextern \"C\" DLLEXPORT const char *jl_lookup_soname(const char *pfx, size_t n)\n{\n    if (!got_sonames) {\n        jl_read_sonames();\n        got_sonames = true;\n    }\n    std::string str(pfx, n);\n    if (sonameMap.find(str) != sonameMap.end()) {\n        return sonameMap[str].c_str();\n    }\n    return NULL;\n}\n#endif\n\n// map from user-specified lib names to handles\nstatic std::map<std::string, uv_lib_t*> libMap;\n\nstatic uv_lib_t *get_library(char *lib)\n{\n    uv_lib_t *hnd;\n#ifdef _OS_WINDOWS_\n    if ((intptr_t)lib == 1)\n        return jl_exe_handle;\n    if ((intptr_t)lib == 2)\n        return jl_dl_handle;\n#endif\n    if (lib == NULL)\n        return jl_RTLD_DEFAULT_handle;\n    hnd = libMap[lib];\n    if (hnd != NULL)\n        return hnd;\n    hnd = (uv_lib_t *) jl_load_dynamic_library(lib, JL_RTLD_DEFAULT);\n    if (hnd != NULL)\n        libMap[lib] = hnd;\n    return hnd;\n}\n\nextern \"C\" DLLEXPORT\nvoid *jl_load_and_lookup(char *f_lib, char *f_name, uv_lib_t **hnd)\n{\n    uv_lib_t *handle = *hnd;\n    if (!handle)\n        *hnd = handle = get_library(f_lib);\n    void *ptr = jl_dlsym_e(handle, f_name);\n    if (!ptr)\n        jl_errorf(\"symbol \\\"%s\\\" could not be found: %s\", f_name, uv_dlerror(handle));\n    return ptr;\n}\n\nstatic std::map<std::string, GlobalVariable*> libMapGV;\nstatic std::map<std::string, GlobalVariable*> symMapGV;\nstatic Value *runtime_sym_lookup(PointerType *funcptype, char *f_lib, char *f_name, jl_codectx_t *ctx)\n{\n    // in pseudo-code, this function emits the following:\n    //   global uv_lib_t **libptrgv\n    //   global void **llvmgv\n    //   if (*llvmgv == NULL) {\n    //       *llvmgv = jl_load_and_lookup(f_lib, f_name, libptrgv);\n    //   }\n    //   return (*llvmgv)\n    Constant *initnul = ConstantPointerNull::get((PointerType*)T_pint8);\n\n    uv_lib_t *libsym = NULL;\n    bool runtime_lib = false;\n    GlobalVariable *libptrgv;\n#ifdef _OS_WINDOWS_\n    if ((intptr_t)f_lib == 1) {\n        libptrgv = prepare_global(jlexe_var);\n        libsym = jl_exe_handle;\n    }\n    else if ((intptr_t)f_lib == 2) {\n        libptrgv = prepare_global(jldll_var);\n        libsym = jl_dl_handle;\n    }\n    else\n#endif\n    if (f_lib == NULL) {\n        libptrgv = prepare_global(jlRTLD_DEFAULT_var);\n        libsym = jl_RTLD_DEFAULT_handle;\n    }\n    else {\n        runtime_lib = true;\n        libptrgv = libMapGV[f_lib];\n        if (libptrgv == NULL) {\n            libptrgv = new GlobalVariable(*jl_Module, T_pint8,\n               false, GlobalVariable::PrivateLinkage,\n               initnul, f_lib);\n            libMapGV[f_lib] = libptrgv;\n            libsym = get_library(f_lib);\n            assert(libsym != NULL);\n#ifdef USE_MCJIT\n            jl_llvm_to_jl_value[libptrgv] = libsym;\n#else\n            *((uv_lib_t**)jl_ExecutionEngine->getPointerToGlobal(libptrgv)) = libsym;\n#endif\n        }\n    }\n    if (libsym == NULL) {\n#ifdef USE_MCJIT\n        libsym = (uv_lib_t*)jl_llvm_to_jl_value[libptrgv];\n#else\n        libsym = *((uv_lib_t**)jl_ExecutionEngine->getPointerToGlobal(libptrgv));\n#endif\n    }\n\n    assert(libsym != NULL);\n\n    GlobalVariable *llvmgv = symMapGV[f_name];\n    if (llvmgv == NULL) {\n        // MCJIT forces this to have external linkage eventually, so we would clobber\n        // the symbol of the actual function.\n        std::string name = f_name;\n        name = \"ccall_\" + name;\n        llvmgv = new GlobalVariable(*jl_Module, T_pint8,\n           false, GlobalVariable::PrivateLinkage,\n           initnul, name);\n        symMapGV[f_name] = llvmgv;\n#ifdef USE_MCJIT\n        jl_llvm_to_jl_value[llvmgv] = jl_dlsym_e(libsym, f_name);\n#else\n        *((void**)jl_ExecutionEngine->getPointerToGlobal(llvmgv)) = jl_dlsym_e(libsym, f_name);\n#endif\n    }\n\n    BasicBlock *dlsym_lookup = BasicBlock::Create(jl_LLVMContext, \"dlsym\"),\n               *ccall_bb = BasicBlock::Create(jl_LLVMContext, \"ccall\");\n    builder.CreateCondBr(builder.CreateICmpNE(builder.CreateLoad(llvmgv), initnul), ccall_bb, dlsym_lookup);\n\n    ctx->f->getBasicBlockList().push_back(dlsym_lookup);\n    builder.SetInsertPoint(dlsym_lookup);\n    Value *libname;\n    if (runtime_lib) {\n        libname = builder.CreateGlobalStringPtr(f_lib);\n    }\n    else {\n        libname = literal_static_pointer_val(f_lib, T_pint8);\n    }\n#ifdef LLVM37\n    Value *llvmf = builder.CreateCall(prepare_call(jldlsym_func), { libname, builder.CreateGlobalStringPtr(f_name), libptrgv });\n#else\n    Value *llvmf = builder.CreateCall3(prepare_call(jldlsym_func), libname, builder.CreateGlobalStringPtr(f_name), libptrgv);\n#endif\n    builder.CreateStore(llvmf, llvmgv);\n    builder.CreateBr(ccall_bb);\n\n    ctx->f->getBasicBlockList().push_back(ccall_bb);\n    builder.SetInsertPoint(ccall_bb);\n    llvmf = builder.CreateLoad(llvmgv);\n    return builder.CreatePointerCast(llvmf,funcptype);\n}\n\n// --- ABI Implementations ---\n// Partially based on the LDC ABI implementations licensed under the BSD 3-clause license\n\n#if defined ABI_LLVM\n#  include \"abi_llvm.cpp\"\n#elif defined _CPU_X86_64_\n#  if defined _OS_WINDOWS_\n#    include \"abi_win64.cpp\"\n#  else\n#    include \"abi_x86_64.cpp\"\n#  endif\n#elif defined _CPU_X86_\n#  if defined _OS_WINDOWS_\n#    include \"abi_win32.cpp\"\n#  else\n#    include \"abi_x86.cpp\"\n#  endif\n#elif defined _CPU_AARCH64_\n#    include \"abi_aarch64.cpp\"\n#else\n#  warning \"ccall is defaulting to llvm ABI, since no platform ABI has been defined for this CPU/OS combination\"\n#  include \"abi_llvm.cpp\"\n#endif\n\nValue *llvm_type_rewrite(Value *v, Type *from_type, Type *target_type, bool tojulia, bool byref, bool issigned, jl_codectx_t *ctx)\n{\n    Type *ptarget_type = PointerType::get(target_type, 0);\n\n    if (tojulia) {\n        if (byref) {\n            if (v->getType() != ptarget_type) {\n                v = builder.CreatePointerCast(v, ptarget_type);\n            }\n            return builder.CreateAlignedLoad(v, 1); // unknown alignment from C\n        }\n    }\n    else {\n        if (byref) { // client is supposed to have already done the alloca and store\n            if (v->getType() != target_type) {\n                v = builder.CreatePointerCast(v, target_type);\n            }\n            return v;\n        }\n\n        if (v->getType() != from_type) { // this is already be a pointer in the codegen\n            unsigned align = v->getType() == jl_pvalue_llvmt ? 16 : 0;\n            if (v->getType() != ptarget_type) {\n                v = builder.CreatePointerCast(v, ptarget_type);\n            }\n            return builder.CreateAlignedLoad(v, align);\n        }\n    }\n    assert(v->getType() == from_type);\n\n    if (target_type == from_type) {\n        return v;\n    }\n\n    if ((target_type->isIntegerTy() && from_type->isIntegerTy()) ||\n        (target_type->isFloatingPointTy() && from_type->isFloatingPointTy()) ||\n        (target_type->isPointerTy() && from_type->isPointerTy())) {\n        if (target_type->isPointerTy()) {\n            return builder.CreatePointerCast(v, target_type);\n        }\n        if (target_type->isFloatingPointTy()) {\n            if (target_type->getPrimitiveSizeInBits() > from_type->getPrimitiveSizeInBits()) {\n                return builder.CreateFPExt(v, target_type);\n            }\n            else if (target_type->getPrimitiveSizeInBits() < from_type->getPrimitiveSizeInBits()) {\n                return builder.CreateFPTrunc(v, target_type);\n            }\n            else {\n                return v;\n            }\n        }\n        assert(target_type->isIntegerTy());\n        if (issigned)\n            return builder.CreateSExtOrTrunc(v, target_type);\n        else\n            return builder.CreateZExtOrTrunc(v, target_type);\n    }\n\n    // Vector or non-Aggregate types\n    // LLVM doesn't allow us to cast values directly, so\n    // we need to use this alloca trick\n    Value *mem = emit_static_alloca(target_type, ctx);\n    builder.CreateStore(v, builder.CreatePointerCast(mem, from_type->getPointerTo()));\n    return builder.CreateLoad(mem);\n}\n\n// --- argument passing and scratch space utilities ---\n\n// Emit code to convert argument to form expected by C ABI\n// ty = desired LLVM type\n// jt = Julia type of formal argument\n// jv = value of actual argument\n// aty = Julia inferred type of actual argument\nstatic Value *julia_to_native(Type *ty, jl_value_t *jt, Value *jv,\n                              jl_value_t *aty, bool addressOf,\n                              bool byRef, bool inReg,\n                              bool needCopy, bool tojulia,\n                              int argn, jl_codectx_t *ctx,\n                              bool *needStackRestore)\n{\n    Type *vt = jv->getType();\n\n    // We're passing Any\n    if (ty == jl_pvalue_llvmt) {\n        return boxed(jv,ctx);\n    }\n\n    if (!tojulia && vt != jl_pvalue_llvmt && julia_type_to_llvm(aty)->isAggregateType()) {\n        // this value is expected to be a pointer in the julia codegen,\n        // so it needs to be extracted first if not tojulia\n        vt = vt->getContainedType(0);\n    }\n\n    if (ty == vt && !addressOf && !byRef) {\n        return jv;\n    }\n\n    if (vt != jl_pvalue_llvmt) {\n        // argument value is unboxed\n        if (vt != jv->getType())\n            jv = builder.CreateLoad(jv); // something stack allocated\n        if (addressOf || (byRef && inReg)) {\n            if (ty->isPointerTy() && ty->getContainedType(0) == vt) {\n                // pass the address of an alloca'd thing, not a box\n                // since those are immutable.\n                Value *slot = emit_static_alloca(vt, ctx);\n                builder.CreateStore(jv, slot);\n                return builder.CreateBitCast(slot, ty);\n            }\n        }\n        else if ((vt->isIntegerTy() && ty->isIntegerTy()) ||\n                 (vt->isFloatingPointTy() && ty->isFloatingPointTy()) ||\n                 (vt->isPointerTy() && ty->isPointerTy())) {\n            if (vt->getPrimitiveSizeInBits() ==\n                ty->getPrimitiveSizeInBits()) {\n                if (!byRef) {\n                    return builder.CreateBitCast(jv, ty);\n                }\n                else {\n                    Value *mem = emit_static_alloca(ty, ctx);\n                    builder.CreateStore(jv,builder.CreateBitCast(mem,vt->getPointerTo()));\n                    return mem;\n                }\n            }\n        }\n        else if (vt->isStructTy()) {\n            if (byRef) {\n                Value *mem = emit_static_alloca(vt, ctx);\n                builder.CreateStore(jv, mem);\n                return mem;\n            }\n            else {\n                return jv;\n            }\n        }\n\n        emit_error(\"ccall: argument type did not match declaration\", ctx);\n    }\n\n    // argument value is boxed (jl_value_t*)\n    if (jl_is_tuple(jt)) {\n        emit_error(\"ccall: unimplemented: boxed tuple argument type\", ctx);\n        return jv; // TODO: this is wrong\n    }\n    if (jl_is_cpointer_type(jt) && addressOf) {\n        assert(ty->isPointerTy());\n        jl_value_t *ety = jl_tparam0(jt);\n        if (aty != ety && ety != (jl_value_t*)jl_any_type && jt != (jl_value_t*)jl_voidpointer_type) {\n            std::stringstream msg;\n            msg << \"ccall argument \";\n            msg << argn;\n            emit_typecheck(jv, ety, msg.str(), ctx);\n        }\n        if (jl_is_mutable_datatype(ety)) {\n            // no copy, just reference the data field\n            return builder.CreateBitCast(jv, ty);\n        }\n        else if (jl_is_immutable_datatype(ety) && jt != (jl_value_t*)jl_voidpointer_type) {\n            // yes copy\n            Value *nbytes;\n            if (jl_is_leaf_type(ety))\n                nbytes = ConstantInt::get(T_int32, jl_datatype_size(ety));\n            else\n                nbytes = tbaa_decorate(tbaa_datatype, builder.CreateLoad(\n                                builder.CreateGEP(builder.CreatePointerCast(emit_typeof(jv), T_pint32),\n                                    ConstantInt::get(T_size, offsetof(jl_datatype_t,size)/sizeof(int32_t))),\n                                false));\n            *needStackRestore = true;\n            AllocaInst *ai = builder.CreateAlloca(T_int8, nbytes);\n            ai->setAlignment(16);\n            builder.CreateMemCpy(ai, builder.CreateBitCast(jv, T_pint8), nbytes, sizeof(void*)); // minimum gc-alignment in julia is pointer size\n            return builder.CreateBitCast(ai, ty);\n        }\n        // emit maybe copy\n        *needStackRestore = true;\n        Value *jvt = emit_typeof(jv);\n        BasicBlock *mutableBB = BasicBlock::Create(getGlobalContext(),\"is-mutable\",ctx->f);\n        BasicBlock *immutableBB = BasicBlock::Create(getGlobalContext(),\"is-immutable\",ctx->f);\n        BasicBlock *afterBB = BasicBlock::Create(getGlobalContext(),\"after\",ctx->f);\n        Value *ismutable = builder.CreateTrunc(\n                tbaa_decorate(tbaa_datatype, builder.CreateLoad(\n                        builder.CreateGEP(builder.CreatePointerCast(jvt, T_pint8),\n                            ConstantInt::get(T_size, offsetof(jl_datatype_t,mutabl))),\n                        false)),\n                T_int1);\n        builder.CreateCondBr(ismutable, mutableBB, immutableBB);\n        builder.SetInsertPoint(mutableBB);\n        Value *p1 = builder.CreatePointerCast(jv, ty);\n        builder.CreateBr(afterBB);\n        builder.SetInsertPoint(immutableBB);\n        Value *nbytes = tbaa_decorate(tbaa_datatype, builder.CreateLoad(\n                    builder.CreateGEP(builder.CreatePointerCast(jvt, T_pint32),\n                        ConstantInt::get(T_size, offsetof(jl_datatype_t,size)/sizeof(int32_t))),\n                    false));\n        AllocaInst *ai = builder.CreateAlloca(T_int8, nbytes);\n        ai->setAlignment(16);\n        builder.CreateMemCpy(ai, builder.CreatePointerCast(jv, T_pint8), nbytes, sizeof(void*)); // minimum gc-alignment in julia is pointer size\n        Value *p2 = builder.CreatePointerCast(ai, ty);\n        builder.CreateBr(afterBB);\n        builder.SetInsertPoint(afterBB);\n        PHINode *p = builder.CreatePHI(ty, 2);\n        p->addIncoming(p1, mutableBB);\n        p->addIncoming(p2, immutableBB);\n        return p;\n    }\n    if (addressOf)\n        jl_error(\"ccall: unexpected & on argument\"); // the only \"safe\" thing to emit here is the expected struct\n    assert(jl_is_datatype(jt));\n    if (aty != jt) {\n        std::stringstream msg;\n        msg << \"ccall argument \";\n        msg << argn;\n        emit_typecheck(jv, jt, msg.str(), ctx);\n    }\n    Value *pjv = builder.CreatePointerCast(jv, PointerType::get(ty,0));\n    if (byRef) {\n        if (!needCopy) {\n            return pjv;\n        }\n        else {\n            Value *mem = emit_static_alloca(ty, ctx);\n            builder.CreateMemCpy(mem, pjv, (uint64_t)jl_datatype_size(jt), (uint64_t)((jl_datatype_t*)jt)->alignment);\n            return mem;\n        }\n    }\n    else {\n        return pjv; // lazy load by llvm_type_rewrite\n    }\n}\n\ntypedef struct {\n    Value *jl_ptr;  // if the argument is a run-time computed pointer\n    void *fptr;     // if the argument is a constant pointer\n    char *f_name;   // if the symbol name is known\n    char *f_lib;    // if a library name is specified\n} native_sym_arg_t;\n\n// --- parse :sym or (:sym, :lib) argument into address info ---\nstatic native_sym_arg_t interpret_symbol_arg(jl_value_t *arg, jl_codectx_t *ctx, const char *fname)\n{\n    jl_value_t *ptr = NULL;\n    Value *jl_ptr=NULL;\n\n    ptr = static_eval(arg, ctx, true);\n    if (ptr == NULL) {\n        jl_value_t *ptr_ty = expr_type(arg, ctx);\n        Value *arg1 = emit_unboxed(arg, ctx);\n        if (!jl_is_cpointer_type(ptr_ty)) {\n            emit_cpointercheck(arg1,\n                               !strcmp(fname,\"ccall\") ?\n                               \"ccall: first argument not a pointer or valid constant expression\" :\n                               \"cglobal: first argument not a pointer or valid constant expression\",\n                               ctx);\n        }\n        jl_ptr = emit_unbox(T_size, arg1, (jl_value_t*)jl_voidpointer_type);\n    }\n\n    void *fptr=NULL;\n    char *f_name=NULL, *f_lib=NULL;\n    jl_value_t *t0 = NULL, *t1 = NULL;\n    JL_GC_PUSH3(&ptr, &t0, &t1);\n    if (ptr != NULL) {\n        if (jl_is_tuple(ptr) && jl_nfields(ptr)==1) {\n            ptr = jl_fieldref(ptr,0);\n        }\n        if (jl_is_symbol(ptr))\n            f_name = ((jl_sym_t*)ptr)->name;\n        else if (jl_is_byte_string(ptr))\n            f_name = jl_string_data(ptr);\n        if (f_name != NULL) {\n            // just symbol, default to JuliaDLHandle\n            // will look in process symbol table\n#ifdef _OS_WINDOWS_\n            f_lib = jl_dlfind_win32(f_name);\n#endif\n        }\n        else if (jl_is_cpointer_type(jl_typeof(ptr))) {\n            fptr = *(void**)jl_data_ptr(ptr);\n        }\n        else if (jl_is_tuple(ptr) && jl_nfields(ptr)>1) {\n            jl_value_t *t0 = jl_fieldref(ptr,0);\n            jl_value_t *t1 = jl_fieldref(ptr,1);\n            if (jl_is_symbol(t0))\n                f_name = ((jl_sym_t*)t0)->name;\n            else if (jl_is_byte_string(t0))\n                f_name = jl_string_data(t0);\n            else\n                JL_TYPECHKS(fname, symbol, t0);\n            if (jl_is_symbol(t1))\n                f_lib = ((jl_sym_t*)t1)->name;\n            else if (jl_is_byte_string(t1))\n                f_lib = jl_string_data(t1);\n            else\n                JL_TYPECHKS(fname, symbol, t1);\n        }\n        else {\n            JL_TYPECHKS(fname, pointer, ptr);\n        }\n    }\n    JL_GC_POP();\n    native_sym_arg_t r;\n    r.jl_ptr = jl_ptr;\n    r.fptr = fptr;\n    r.f_name = f_name;\n    r.f_lib = f_lib;\n    return r;\n}\n\n\ntypedef AttributeSet attr_type;\n\n// --- code generator for cglobal ---\n\nstatic Value *emit_cglobal(jl_value_t **args, size_t nargs, jl_codectx_t *ctx)\n{\n    JL_NARGS(cglobal, 1, 2);\n    jl_value_t *rt=NULL;\n    Value *res;\n    JL_GC_PUSH1(&rt);\n\n    if (nargs == 2) {\n        JL_TRY {\n            rt = jl_interpret_toplevel_expr_in(ctx->module, args[2],\n                                               jl_svec_data(ctx->sp),\n                                               jl_svec_len(ctx->sp)/2);\n        }\n        JL_CATCH {\n            jl_rethrow_with_add(\"error interpreting cglobal type\");\n        }\n\n        JL_TYPECHK(cglobal, type, rt);\n        rt = (jl_value_t*)jl_apply_type((jl_value_t*)jl_pointer_type, jl_svec1(rt));\n    }\n    else {\n        rt = (jl_value_t*)jl_voidpointer_type;\n    }\n    Type *lrt = julia_type_to_llvm(rt);\n    if (lrt == NULL) lrt = T_pint8;\n\n    native_sym_arg_t sym = interpret_symbol_arg(args[1], ctx, \"cglobal\");\n\n    if (sym.jl_ptr != NULL) {\n        res = builder.CreateIntToPtr(sym.jl_ptr, lrt);\n    }\n    else if (sym.fptr != NULL) {\n        res = literal_static_pointer_val(sym.fptr, lrt);\n        if (imaging_mode)\n            jl_printf(JL_STDERR,\"WARNING: literal address used in cglobal for %s; code cannot be statically compiled\\n\", sym.f_name);\n    }\n    else {\n        if (imaging_mode) {\n            res = runtime_sym_lookup((PointerType*)lrt, sym.f_lib, sym.f_name, ctx);\n        }\n        else {\n            void *symaddr = jl_dlsym_e(get_library(sym.f_lib), sym.f_name);\n            if (symaddr == NULL) {\n                std::stringstream msg;\n                msg << \"cglobal: could not find symbol \";\n                msg << sym.f_name;\n                if (sym.f_lib != NULL) {\n#ifdef _OS_WINDOWS_\n                    assert((intptr_t)sym.f_lib != 1 && (intptr_t)sym.f_lib != 2);\n#endif\n                    msg << \" in library \";\n                    msg << sym.f_lib;\n                }\n                emit_error(msg.str(), ctx);\n            }\n            // since we aren't saving this code, there's no sense in\n            // putting anything complicated here: just JIT the address of the cglobal\n            res = literal_static_pointer_val(symaddr, lrt);\n        }\n    }\n\n    JL_GC_POP();\n    return mark_julia_type(res, rt);\n}\n\n// llvmcall(ir, (rettypes...), (argtypes...), args...)\nstatic Value *emit_llvmcall(jl_value_t **args, size_t nargs, jl_codectx_t *ctx)\n{\n    JL_NARGSV(llvmcall, 3)\n    jl_value_t *rt = NULL, *at = NULL, *ir = NULL;\n    jl_svec_t *stt = NULL;\n    JL_GC_PUSH4(&ir, &rt, &at, &stt);\n    {\n    JL_TRY {\n        at  = jl_interpret_toplevel_expr_in(ctx->module, args[3],\n                                            jl_svec_data(ctx->sp),\n                                            jl_svec_len(ctx->sp)/2);\n    }\n    JL_CATCH {\n        jl_rethrow_with_add(\"error interpreting llvmcall argument tuple\");\n    }\n    }\n    {\n    JL_TRY {\n        rt  = jl_interpret_toplevel_expr_in(ctx->module, args[2],\n                                            jl_svec_data(ctx->sp),\n                                            jl_svec_len(ctx->sp)/2);\n    }\n    JL_CATCH {\n        jl_rethrow_with_add(\"error interpreting llvmcall return type\");\n    }\n    }\n    {\n    JL_TRY {\n        ir  = jl_interpret_toplevel_expr_in(ctx->module, args[1],\n                                            jl_svec_data(ctx->sp),\n                                            jl_svec_len(ctx->sp)/2);\n    }\n    JL_CATCH {\n        jl_rethrow_with_add(\"error interpreting IR argument\");\n    }\n    }\n    int i = 1;\n    if (ir == NULL) {\n        jl_error(\"Cannot statically evaluate first argument to llvmcall\");\n    }\n    bool isString = jl_is_byte_string(ir);\n    bool isPtr = jl_is_cpointer(ir);\n    if (!isString && !isPtr) {\n        jl_error(\"First argument to llvmcall must be a string or pointer to an LLVM Function\");\n    }\n\n    JL_TYPECHK(llvmcall, type, rt);\n    JL_TYPECHK(llvmcall, type, at);\n\n    std::stringstream ir_stream;\n\n    stt = jl_alloc_svec(nargs - 3);\n\n    for (size_t i = 0; i < nargs-3; ++i) {\n        jl_svecset(stt,i,expr_type(args[4+i],ctx));\n    }\n\n    // Generate arguments\n    std::string arguments;\n    llvm::raw_string_ostream argstream(arguments);\n    jl_svec_t *tt = ((jl_datatype_t*)at)->parameters;\n    jl_value_t *rtt = rt;\n\n    size_t nargt = jl_svec_len(tt);\n    Value **argvals = (Value**) alloca(nargt*sizeof(Value*));\n    std::vector<llvm::Type*> argtypes;\n    /*\n     * Semantics for arguments are as follows:\n     * If the argument type is immutable (including bitstype), we pass the loaded llvm value\n     * type. Otherwise we pass a pointer to a jl_value_t.\n     */\n    for (size_t i = 0; i < nargt; ++i) {\n        jl_value_t *tti = jl_svecref(tt,i);\n        Type *t = julia_type_to_llvm(tti);\n        argtypes.push_back(t);\n        if (4+i > nargs) {\n            jl_error(\"Missing arguments to llvmcall!\");\n        }\n        jl_value_t *argi = args[4+i];\n        Value *arg;\n        bool needroot = false;\n        if (t == jl_pvalue_llvmt || !jl_isbits(tti)) {\n            arg = emit_expr(argi, ctx, true);\n            if (t == jl_pvalue_llvmt && arg->getType() != jl_pvalue_llvmt) {\n                arg = boxed(arg, ctx);\n                needroot = true;\n            }\n        }\n        else {\n            arg = emit_unboxed(argi, ctx);\n            if (jl_is_bitstype(expr_type(argi, ctx))) {\n                arg = emit_unbox(t, arg, tti);\n            }\n        }\n\n        // make sure args are rooted\n        if (t == jl_pvalue_llvmt && (needroot || might_need_root(argi))) {\n            make_gcroot(arg, ctx);\n        }\n        Value *v = julia_to_native(t, tti, arg, expr_type(argi, ctx), false, false, false, false, false, i, ctx, NULL);\n        bool issigned = jl_signed_type && jl_subtype(tti, (jl_value_t*)jl_signed_type, 0);\n        argvals[i] = llvm_type_rewrite(v, t, t, false, false, issigned, ctx);\n    }\n\n    Function *f;\n    Type *rettype = julia_type_to_llvm(rtt);\n    if (isString) {\n        // Make sure to find a unique name\n        std::string ir_name;\n        while(true) {\n            std::stringstream name;\n            name << (ctx->f->getName().str()) << \"u\" << i++;\n            ir_name = name.str();\n            if (jl_Module->getFunction(ir_name) == NULL)\n                break;\n        }\n\n        bool first = true;\n        for (std::vector<Type *>::iterator it = argtypes.begin(); it != argtypes.end(); ++it) {\n            if (!first)\n                argstream << \",\";\n            else\n                first = false;\n            (*it)->print(argstream);\n            argstream << \" \";\n        }\n\n        std::string rstring;\n        llvm::raw_string_ostream rtypename(rstring);\n        rettype->print(rtypename);\n\n        ir_stream << \"; Number of arguments: \" << nargt << \"\\n\"\n        << \"define \"<<rtypename.str()<<\" @\\\"\" << ir_name << \"\\\"(\"<<argstream.str()<<\") {\\n\"\n        << jl_string_data(ir) << \"\\n}\";\n        SMDiagnostic Err = SMDiagnostic();\n        std::string ir_string = ir_stream.str();\n#ifdef LLVM36\n        Module *m = NULL;\n        bool failed = parseAssemblyInto(llvm::MemoryBufferRef(ir_string,\"llvmcall\"),*jl_Module,Err);\n        if (!failed)\n            m = jl_Module;\n#else\n        Module *m = ParseAssemblyString(ir_string.c_str(),jl_Module,Err,jl_LLVMContext);\n#endif\n        if (m == NULL) {\n            std::string message = \"Failed to parse LLVM Assembly: \\n\";\n            llvm::raw_string_ostream stream(message);\n            Err.print(\"julia\",stream,true);\n            jl_error(stream.str().c_str());\n        }\n        f = m->getFunction(ir_name);\n    }\n    else {\n        assert(isPtr);\n        // Create Function skeleton\n        f = (llvm::Function*)jl_unbox_voidpointer(ir);\n        assert(f->getReturnType() == rettype);\n        int i = 0;\n        for (std::vector<Type *>::iterator it = argtypes.begin();\n            it != argtypes.end(); ++it, ++i)\n            assert(*it == f->getFunctionType()->getParamType(i));\n\n#ifdef USE_MCJIT\n        if (f->getParent() != jl_Module) {\n            FunctionMover mover(jl_Module,f->getParent());\n            f = mover.CloneFunction(f);\n        }\n#endif\n\n        //f->dump();\n        #ifndef LLVM35\n        if (verifyFunction(*f,PrintMessageAction)) {\n        #else\n        llvm::raw_fd_ostream out(1,false);\n        if (verifyFunction(*f,&out)) {\n        #endif\n            f->dump();\n            jl_error(\"Malformed LLVM Function\");\n        }\n    }\n\n    /*\n     * It might be tempting to just try to set the Always inline attribute on the function\n     * and hope for the best. However, this doesn't work since that would require an inlining\n     * pass (which is a Call Graph pass and cannot be managed by a FunctionPassManager). Instead\n     * We are sneaky and call the inliner directly. This however doesn't work until we've actually\n     * generated the entire function, so we need to store it in the context until the end of the\n     * function. This also has the benefit of looking exactly like we cut/pasted it in in `code_llvm`.\n     */\n    f->setLinkage(GlobalValue::LinkOnceODRLinkage);\n\n    // the actual call\n    assert(f->getParent() == jl_Module); // no prepare_call(f) is needed below, since this was just emitted into the same module\n    CallInst *inst = builder.CreateCall(f,ArrayRef<Value*>(&argvals[0],nargt));\n    ctx->to_inline.push_back(inst);\n\n    JL_GC_POP();\n\n    if (inst->getType() != rettype) {\n        jl_error(\"Return type of llvmcall'ed function does not match declared return type\");\n    }\n\n    return mark_julia_type(emit_reg2mem(inst, ctx), rtt);\n}\n\n// --- code generator for ccall itself ---\n\nint try_to_determine_bitstype_nbits(jl_value_t *targ, jl_codectx_t *ctx);\n\nstatic Value *mark_or_box_ccall_result(Value *result, jl_value_t *rt_expr, jl_value_t *rt, bool static_rt, jl_codectx_t *ctx)\n{\n    if (!static_rt && rt != (jl_value_t*)jl_any_type) {\n        // box if type was not statically known\n        int nbits = try_to_determine_bitstype_nbits(rt_expr, ctx);\n        return allocate_box_dynamic(emit_expr(rt_expr, ctx),\n                                    ConstantInt::get(T_size, nbits/8),\n                                    result);\n    }\n\n    return mark_julia_type(result, rt);\n}\n\ntypedef AttributeSet attr_type;\n\nstatic std::string generate_func_sig(Type **lrt, Type **prt, int &sret,\n        std::vector<Type *> &fargt, std::vector<Type *> &fargt_sig,\n        Type *&fargt_vasig,\n        std::vector<bool> &inRegList,\n        std::vector<bool> &byRefList, attr_type &attributes,\n        jl_value_t *rt, jl_svec_t *tt)\n{\n    size_t nargt = jl_svec_len(tt);\n    if (nargt > 0 && jl_svecref(tt,nargt-1) == (jl_value_t*)dots_sym) {\n        nargt--;\n    }\n    assert(rt && !jl_is_abstract_ref_type(rt));\n\n    AttrBuilder retattrs;\n    std::vector<AttrBuilder> paramattrs;\n    AbiState abi = default_abi_state;\n    sret = 0;\n\n    if (type_is_ghost(*lrt)) {\n        *prt = *lrt = T_void;\n    }\n    else {\n        *prt = preferred_llvm_type(rt, true);\n        if (*prt == NULL)\n            *prt = *lrt;\n\n        if (jl_is_datatype(rt) && !jl_is_abstracttype(rt) && use_sret(&abi, rt)) {\n            paramattrs.push_back(AttrBuilder());\n            paramattrs[0].clear();\n#if !defined(_OS_WINDOWS_) || defined(LLVM35)\n            paramattrs[0].addAttribute(Attribute::StructRet);\n#endif\n            fargt.push_back(PointerType::get(*prt, 0));\n            fargt_sig.push_back(PointerType::get(*prt, 0));\n            sret = 1;\n        }\n    }\n\n    size_t i;\n    bool current_isVa = false;\n    for(i = 0; i < nargt; i++) {\n        paramattrs.push_back(AttrBuilder());\n        jl_value_t *tti = jl_svecref(tt,i);\n        if (jl_is_vararg_type(tti)) {\n            current_isVa = true;\n            tti = jl_tparam0(tti);\n        }\n        Type *t = NULL;\n        if (jl_is_abstract_ref_type(tti)) {\n            if (jl_is_typevar(jl_tparam0(tti)))\n                jl_error(\"ccall: argument type Ref should have an element type, not Ref{T}\");\n            tti = (jl_value_t*)jl_voidpointer_type;\n            t = T_pint8;\n        }\n        else {\n            if (jl_is_cpointer_type(tti) && jl_is_typevar(jl_tparam0(tti)))\n                jl_error(\"ccall: argument type Ptr should have an element type, not Ptr{T}\");\n            if (jl_is_bitstype(tti)) {\n                // see pull req #978. need to annotate signext/zeroext for\n                // small integer arguments.\n                jl_datatype_t *bt = (jl_datatype_t*)tti;\n                if (bt->size < 4) {\n                    Attribute::AttrKind av;\n                    if (jl_signed_type && jl_subtype(tti, (jl_value_t*)jl_signed_type, 0))\n                        av = Attribute::SExt;\n                    else\n                        av = Attribute::ZExt;\n                    paramattrs[i+sret].addAttribute(av);\n                }\n            }\n\n            t = julia_struct_to_llvm(tti);\n            if (t == NULL || t == T_void) {\n                std::stringstream msg;\n                msg << \"ccall: the type of argument \";\n                msg << i+1;\n                msg << \" doesn't correspond to a C type\";\n                return msg.str();\n            }\n        }\n\n        // Whether the ABI needs us to pass this by ref and/or in registers\n        // Valid combinations are:\n        bool byRefAttr = false;\n\n        // Whether or not LLVM wants us to emit a pointer to the data\n        bool byRef = false;\n\n        // Whether or not to pass this in registers\n        bool inReg = false;\n\n        if (jl_is_datatype(tti) && !jl_is_abstracttype(tti))\n            needPassByRef(&abi, tti, &byRef, &inReg, &byRefAttr);\n\n        // Add the appropriate LLVM parameter attributes\n        // Note that even though the LLVM argument is called ByVal\n        // this really means that the thing we're passing is pointing to\n        // the thing we want to pass by value\n        if (byRefAttr)\n            paramattrs[i+sret].addAttribute(Attribute::ByVal);\n        if (inReg)\n            paramattrs[i+sret].addAttribute(Attribute::InReg);\n\n        byRefList.push_back(byRef);\n        inRegList.push_back(inReg);\n\n        fargt.push_back(t);\n\n        Type *pat = preferred_llvm_type(tti, false);\n        if (pat != NULL)\n            t = pat;\n        else if (byRef)\n            t = PointerType::get(t,0);\n\n        if (!current_isVa) {\n            fargt_sig.push_back(t);\n        }\n        else {\n            fargt_vasig = t;\n        }\n    }\n\n    if (retattrs.hasAttributes())\n        attributes = AttributeSet::get(jl_LLVMContext, AttributeSet::ReturnIndex, retattrs);\n    for (i = 0; i < nargt+sret; ++i)\n        if (paramattrs[i].hasAttributes())\n            attributes = attributes.addAttributes(jl_LLVMContext, i+1,\n                                                  AttributeSet::get(jl_LLVMContext, i+1, paramattrs[i]));\n    return \"\";\n}\n\n\n// ccall(pointer, rettype, (argtypes...), args...)\nstatic Value *emit_ccall(jl_value_t **args, size_t nargs, jl_codectx_t *ctx)\n{\n    JL_NARGSV(ccall, 3);\n    jl_value_t *rt=NULL, *at=NULL;\n    JL_GC_PUSH2(&rt, &at);\n\n    native_sym_arg_t symarg = interpret_symbol_arg(args[1], ctx, \"ccall\");\n    Value *jl_ptr=NULL;\n    void *fptr = NULL;\n    char *f_name = NULL, *f_lib = NULL;\n    jl_ptr = symarg.jl_ptr;\n    fptr = symarg.fptr;\n    f_name = symarg.f_name;\n    f_lib = symarg.f_lib;\n    bool isVa = false;\n\n    if (f_name == NULL && fptr == NULL && jl_ptr == NULL) {\n        JL_GC_POP();\n        emit_error(\"ccall: null function pointer\", ctx);\n        return literal_pointer_val(jl_nothing);\n    }\n\n    jl_value_t *rtt_ = expr_type(args[2], ctx);\n    bool static_rt = true;  // is return type fully statically known?\n    if (jl_is_type_type(rtt_) && jl_is_leaf_type(jl_tparam0(rtt_))) {\n        rt = jl_tparam0(rtt_);\n    }\n    else {\n        JL_TRY {\n            rt  = jl_interpret_toplevel_expr_in(ctx->module, args[2],\n                                                jl_svec_data(ctx->sp),\n                                                jl_svec_len(ctx->sp)/2);\n        }\n        JL_CATCH {\n            static_rt = false;\n            if (jl_is_type_type(rtt_)) {\n                if (jl_subtype(jl_tparam0(rtt_), (jl_value_t*)jl_pointer_type, 0)) {\n                    // substitute Ptr{Void} for statically-unknown pointer type\n                    rt = (jl_value_t*)jl_voidpointer_type;\n                }\n                else if (jl_subtype(jl_tparam0(rtt_), (jl_value_t*)jl_array_type, 0)) {\n                    // `Array` used as return type just returns a julia object reference\n                    rt = (jl_value_t*)jl_any_type;\n                }\n            }\n            if (rt == NULL) {\n                emit_error(\"error interpreting ccall return type\", ctx);\n                JL_GC_POP();\n                return UndefValue::get(T_void);\n            }\n        }\n    }\n\n    if (jl_is_svec(rt)) {\n        std::string msg = \"in \" + ctx->funcName +\n            \": ccall: missing return type\";\n        jl_error(msg.c_str());\n    }\n    if (jl_is_cpointer_type(rt) && jl_is_typevar(jl_tparam0(rt)))\n        jl_error(\"ccall: return type Ptr should have an element type, not Ptr{_<:T}\");\n\n    if (jl_is_abstract_ref_type(rt)) {\n        if (jl_tparam0(rt) == (jl_value_t*)jl_any_type)\n            jl_error(\"ccall: return type Ref{Any} is invalid. use Ptr{Any} instead.\");\n        rt = (jl_value_t*)jl_any_type; // convert return type to jl_value_t*\n    }\n\n    if (jl_is_array_type(rt)) {\n        // `Array` used as return type just returns a julia object reference\n        rt = (jl_value_t*)jl_any_type;\n    }\n\n    JL_TYPECHK(ccall, type, rt);\n    Type *lrt = julia_struct_to_llvm(rt);\n    if (lrt == NULL) {\n        JL_GC_POP();\n        emit_error(\"ccall: return type doesn't correspond to a C type\", ctx);\n        return literal_pointer_val(jl_nothing);\n    }\n\n    {\n        JL_TRY {\n            at  = jl_interpret_toplevel_expr_in(ctx->module, args[3],\n                                                jl_svec_data(ctx->sp),\n                                                jl_svec_len(ctx->sp)/2);\n        }\n        JL_CATCH {\n            //jl_rethrow_with_add(\"error interpreting ccall argument tuple\");\n            emit_error(\"error interpreting ccall argument tuple\", ctx);\n            JL_GC_POP();\n            return UndefValue::get(lrt);\n        }\n    }\n\n    JL_TYPECHK(ccall, simplevector, at);\n    //JL_TYPECHK(ccall, type, at);\n    jl_svec_t *tt = (jl_svec_t*)at;\n\n    // check for calling convention specifier\n    CallingConv::ID cc = CallingConv::C;\n    jl_value_t *last = args[nargs];\n    if (jl_is_expr(last)) {\n        jl_sym_t *lhd = ((jl_expr_t*)last)->head;\n        if (lhd == jl_symbol(\"stdcall\")) {\n            cc = CallingConv::X86_StdCall;\n            nargs--;\n        }\n        else if (lhd == jl_symbol(\"cdecl\")) {\n            cc = CallingConv::C;\n            nargs--;\n        }\n        else if (lhd == jl_symbol(\"fastcall\")) {\n            cc = CallingConv::X86_FastCall;\n            nargs--;\n        }\n        else if (lhd == jl_symbol(\"thiscall\")) {\n            cc = CallingConv::X86_ThisCall;\n            nargs--;\n        }\n    }\n\n    // some sanity checking and check whether there's a vararg\n    size_t i;\n    size_t nargt = jl_svec_len(tt);\n    for(i=0; i < nargt; i++) {\n        jl_value_t *tti = jl_svecref(tt,i);\n        if (jl_is_cpointer_type(tti) && jl_is_typevar(jl_tparam0(tti))) {\n            JL_GC_POP();\n            emit_error(\"ccall: argument type Ptr should have an element type, Ptr{T}\",ctx);\n            return literal_pointer_val(jl_nothing);\n        }\n        if (jl_is_vararg_type(tti))\n            isVa = true;\n    }\n\n    if ((!isVa && nargt  != (nargs-2)/2) ||\n        ( isVa && nargt-1 > (nargs-2)/2))\n        jl_error(\"ccall: wrong number of arguments to C function\");\n\n    // some special functions\n    if (fptr == (void *) &jl_array_ptr ||\n        ((f_lib==NULL || (intptr_t)f_lib==2)\n         && f_name && !strcmp(f_name,\"jl_array_ptr\"))) {\n        assert(lrt->isPointerTy());\n        assert(!isVa);\n        assert(nargt==1);\n        jl_value_t *argi = args[4];\n        assert(!(jl_is_expr(argi) && ((jl_expr_t*)argi)->head == amp_sym));\n        Value *ary = emit_expr(argi, ctx);\n        JL_GC_POP();\n        return mark_or_box_ccall_result(builder.CreateBitCast(emit_arrayptr(ary),lrt),\n                                        args[2], rt, static_rt, ctx);\n    }\n    if (fptr == (void *) &jl_value_ptr ||\n        ((f_lib==NULL || (intptr_t)f_lib==2)\n         && f_name && !strcmp(f_name,\"jl_value_ptr\"))) {\n        assert(lrt->isPointerTy());\n        assert(!isVa);\n        assert(nargt==1);\n        jl_value_t *argi = args[4];\n        bool addressOf = false;\n        jl_value_t *tti = jl_svecref(tt,0);\n        if (jl_is_expr(argi) && ((jl_expr_t*)argi)->head == amp_sym) {\n            addressOf = true;\n            argi = jl_exprarg(argi,0);\n        }\n        else if (jl_is_abstract_ref_type(tti)) {\n            tti = (jl_value_t*)jl_voidpointer_type;\n        }\n        Value *ary;\n        Type *largty;\n        if (addressOf)\n            largty = jl_pvalue_llvmt;\n        else\n            largty = julia_struct_to_llvm(jl_svecref(tt, 0));\n        if (largty == jl_pvalue_llvmt) {\n            ary = boxed(emit_expr(argi, ctx),ctx);\n        }\n        else {\n            assert(!addressOf);\n            ary = emit_unbox(largty, emit_unboxed(argi, ctx), jl_svecref(tt, 0));\n        }\n        JL_GC_POP();\n        return mark_or_box_ccall_result(builder.CreateBitCast(ary, lrt),\n                                        args[2], rt, static_rt, ctx);\n    }\n    if (fptr == (void *) &jl_is_leaf_type ||\n        ((f_lib==NULL || (intptr_t)f_lib==2)\n         && f_name && !strcmp(f_name, \"jl_is_leaf_type\"))) {\n        assert(nargt == 1);\n        jl_value_t *arg = args[4];\n        jl_value_t *ty = expr_type(arg, ctx);\n        if (jl_is_type_type(ty) && !jl_is_typevar(jl_tparam0(ty))) {\n            int isleaf = jl_is_leaf_type(jl_tparam0(ty));\n            JL_GC_POP();\n            return ConstantInt::get(T_int32, isleaf);\n        }\n    }\n    if (fptr == (void*)&jl_function_ptr ||\n        ((f_lib==NULL || (intptr_t)f_lib==2)\n         && f_name && !strcmp(f_name, \"jl_function_ptr\"))) {\n        assert(nargt == 3);\n        jl_value_t *f = static_eval(args[4], ctx, false, false);\n        jl_value_t *frt = expr_type(args[6], ctx);\n        if (f && jl_is_function(f) &&\n                (jl_is_type_type((jl_value_t*)frt) && !jl_has_typevars(jl_tparam0(frt)))) {\n            jl_value_t *fargt = static_eval(args[8], ctx, true, true);\n            if (fargt) {\n                if (jl_is_tuple(fargt)) {\n                    // TODO: maybe deprecation warning, better checking\n                    fargt = (jl_value_t*)jl_apply_tuple_type_v((jl_value_t**)jl_data_ptr(fargt), jl_nfields(fargt));\n                }\n            }\n            else {\n                fargt = expr_type(args[8], ctx);\n                if (jl_is_type_type((jl_value_t*)fargt))\n                    fargt = jl_tparam0(fargt);\n            }\n            if (jl_is_tuple_type(fargt) && jl_is_leaf_type(fargt)) {\n                frt = jl_tparam0(frt);\n                JL_TRY {\n                    Value *llvmf = prepare_call(\n                            jl_cfunction_object((jl_function_t*)f, frt, (jl_tupletype_t*)fargt));\n                    // make sure to emit any side-effects that may have been part of the original expression\n                    emit_expr(args[4], ctx);\n                    emit_expr(args[6], ctx);\n                    emit_expr(args[8], ctx);\n                    JL_GC_POP();\n                    return mark_or_box_ccall_result(builder.CreateBitCast(llvmf, lrt),\n                                                    args[2], rt, static_rt, ctx);\n                }\n                JL_CATCH {\n                }\n            }\n        }\n    }\n\n    // save place before arguments, for possible insertion of temp arg\n    // area saving code.\n    Value *stacksave=NULL;\n    BasicBlock::InstListType &instList = builder.GetInsertBlock()->getInstList();\n    Instruction *savespot;\n    if (instList.empty()) {\n        savespot = NULL;\n    }\n    else {\n        // hey C++, there's this thing called pointers...\n        Instruction &_savespot = builder.GetInsertBlock()->back();\n        savespot = &_savespot;\n    }\n\n    std::vector<Type*> fargt(0);\n    std::vector<Type*> fargt_sig(0);\n    Type *fargt_vasig = NULL;\n    std::vector<bool> inRegList(0);\n    std::vector<bool> byRefList(0);\n    attr_type attrs;\n    Type *prt = NULL;\n    int sret = 0;\n    std::string err_msg = generate_func_sig(&lrt, &prt, sret, fargt, fargt_sig, fargt_vasig, inRegList, byRefList, attrs, rt, tt);\n    if (!err_msg.empty()) {\n        JL_GC_POP();\n        emit_error(err_msg,ctx);\n        return literal_pointer_val(jl_nothing);\n    }\n\n    // emit arguments\n    Value **argvals = (Value**) alloca(((nargs-3)/2 + sret)*sizeof(Value*));\n    Value *result = NULL;\n    bool needStackRestore = false;\n\n    // First, if the ABI requires us to provide the space for the return\n    // argument, allocate the box and store that as the first argument type\n    if (sret) {\n        result = emit_new_struct(rt,1,NULL,ctx); // TODO: is it valid to be creating an incomplete type this way?\n        assert(result != NULL && \"Type was not concrete\");\n        if (!result->getType()->isPointerTy()) {\n            Value *mem = emit_static_alloca(lrt, ctx);\n            builder.CreateStore(result, mem);\n            result = mem;\n            argvals[0] = result;\n        }\n        else {\n            // XXX: result needs a GC root here if result->getType() == jl_pvalue_llvmt\n            argvals[0] = builder.CreateBitCast(result, fargt_sig[0]);\n        }\n    }\n\n    // save argument depth until after we're done emitting arguments\n    int last_depth = ctx->gc.argDepth;\n\n    // number of parameters to the c function\n    for(i=4; i < nargs+1; i+=2) {\n        // Current C function parameter\n        size_t ai = (i-4)/2;\n\n        // Julia (expression) value of current parameter\n        jl_value_t *argi = args[i];\n\n        // pass the address of the argument rather than the argument itself\n        bool addressOf = false;\n        if (jl_is_expr(argi) && ((jl_expr_t*)argi)->head == amp_sym) {\n            addressOf = true;\n            argi = jl_exprarg(argi,0);\n        }\n\n        // LLVM type of the current parameter\n        Type *largty;\n\n        // Julia type of the current parameter\n        jl_value_t *jargty;\n\n        // Index into the byRefList for the current argument\n        size_t byRefIndex;\n\n        if (isVa && ai >= nargt-1) {\n            largty = fargt[nargt-1];\n            byRefIndex = nargt-1;\n            jargty = jl_tparam0(jl_svecref(tt,nargt-1));\n        }\n        else {\n            largty = fargt[sret+ai];\n            byRefIndex = ai;\n            jargty = jl_svecref(tt,ai);\n        }\n\n        Value *arg;\n        bool needroot = false;\n        if (jl_is_abstract_ref_type(jargty)) {\n            if (addressOf)\n                emit_error(\"ccall: & on a Ref{T} argument is invalid\", ctx);\n            arg = emit_unboxed((jl_value_t*)argi, ctx);\n            if (arg->getType() == jl_pvalue_llvmt) {\n                emit_cpointercheck(arg, \"ccall: argument to Ref{T} is not a pointer\", ctx);\n                arg = emit_unbox(largty, arg, (jl_value_t*)jl_voidpointer_type);\n            }\n            if (arg->getType() != T_pint8)\n                arg = builder.CreatePointerCast(arg, T_pint8);\n            jargty = (jl_value_t*)jl_voidpointer_type;\n        }\n        else if (largty == jl_pvalue_llvmt || largty->isStructTy()) {\n            arg = emit_expr(argi, ctx, true);\n            if (largty == jl_pvalue_llvmt && arg->getType() != jl_pvalue_llvmt) {\n                arg = boxed(arg,ctx);\n                needroot = true;\n            }\n        }\n        else {\n            arg = emit_unboxed(argi, ctx);\n            if (jl_is_bitstype(expr_type(argi, ctx))) {\n                Type *at = arg->getType();\n                Type *totype = addressOf ? largty->getContainedType(0) : largty;\n                if (at != jl_pvalue_llvmt && at != totype &&\n                    !(at->isPointerTy() && jargty==(jl_value_t*)jl_voidpointer_type)) {\n                    emit_type_error(arg, jargty, \"ccall\", ctx);\n                    arg = UndefValue::get(totype);\n                }\n                else {\n                    arg = emit_unbox(totype, arg, jargty);\n                }\n            }\n        }\n\n        // make sure args are rooted\n        if (largty == jl_pvalue_llvmt && (needroot || might_need_root(argi))) {\n            make_gcroot(arg, ctx);\n        }\n\n        bool nSR=false;\n        bool issigned = jl_signed_type && jl_subtype(jargty, (jl_value_t*)jl_signed_type, 0);\n        assert(byRefList.size() == inRegList.size() && byRefIndex < byRefList.size());\n        bool byRef = byRefList[byRefIndex];\n        bool inReg = inRegList[byRefIndex];\n        argvals[ai + sret] = llvm_type_rewrite(\n                julia_to_native(largty, jargty, arg, expr_type(argi, ctx), addressOf, byRef, inReg,\n                    need_private_copy(jargty, byRef), false, ai + 1, ctx, &nSR),\n                largty, ai + sret < fargt_sig.size() ? fargt_sig[ai + sret] : fargt_vasig,\n                false, byRef, issigned, ctx);\n        needStackRestore |= nSR;\n    }\n\n\n    // make LLVM function object for the target\n    // keep this close to the function call, so that the compiler can\n    // optimize the global pointer load in the common case\n    Value *llvmf;\n    FunctionType *functype = FunctionType::get(sret?T_void:prt, fargt_sig, isVa);\n\n    if (jl_ptr != NULL) {\n        null_pointer_check(jl_ptr,ctx);\n        Type *funcptype = PointerType::get(functype,0);\n        llvmf = builder.CreateIntToPtr(jl_ptr, funcptype);\n    }\n    else if (fptr != NULL) {\n        Type *funcptype = PointerType::get(functype,0);\n        llvmf = literal_static_pointer_val(fptr, funcptype);\n        if (imaging_mode)\n            jl_printf(JL_STDERR,\"WARNING: literal address used in ccall for %s; code cannot be statically compiled\\n\", f_name);\n    }\n    else {\n        assert(f_name != NULL);\n\n        PointerType *funcptype = PointerType::get(functype,0);\n        if (imaging_mode) {\n            llvmf = runtime_sym_lookup(funcptype, f_lib, f_name, ctx);\n        }\n        else {\n            void *symaddr = jl_dlsym_e(get_library(f_lib), f_name);\n            if (symaddr == NULL) {\n                JL_GC_POP();\n                std::stringstream msg;\n                msg << \"ccall: could not find function \";\n                msg << f_name;\n                if (f_lib != NULL) {\n#ifdef _OS_WINDOWS_\n                    assert((intptr_t)f_lib != 1 && (intptr_t)f_lib != 2);\n#endif\n                    msg << \" in library \";\n                    msg << f_lib;\n                }\n                emit_error(msg.str(), ctx);\n                return literal_pointer_val(jl_nothing);\n            }\n            // since we aren't saving this code, there's no sense in\n            // putting anything complicated here: just JIT the function address\n            llvmf = literal_static_pointer_val(symaddr, funcptype);\n        }\n    }\n\n    if (needStackRestore) {\n        stacksave = CallInst::Create(Intrinsic::getDeclaration(jl_Module,\n                                                               Intrinsic::stacksave));\n        if (savespot) {\n#ifdef LLVM38\n                instList.insertAfter(savespot->getIterator(), (Instruction*)stacksave);\n#else\n                instList.insertAfter((Instruction*)savespot, (Instruction*)stacksave);\n#endif\n        }\n        else\n            instList.push_front((Instruction*)stacksave);\n    }\n\n    //llvmf->dump();\n    //for (std::vector<Value *>::iterator it = argvals.begin() ; it != argvals.end(); ++it)\n    //    (*it)->dump();\n\n    // the actual call\n    Value *ret = builder.CreateCall(prepare_call(llvmf),\n                                    ArrayRef<Value*>(&argvals[0],(nargs-3)/2+sret));\n    ((CallInst*)ret)->setAttributes(attrs);\n\n    if (cc != CallingConv::C)\n        ((CallInst*)ret)->setCallingConv(cc);\n    if (!sret)\n        result = ret;\n    if (needStackRestore) {\n        assert(stacksave != NULL);\n        builder.CreateCall(Intrinsic::getDeclaration(jl_Module,\n                                                     Intrinsic::stackrestore),\n                           stacksave);\n    }\n    ctx->gc.argDepth = last_depth;\n    if (0) { // Enable this to turn on SSPREQ (-fstack-protector) on the function containing this ccall\n        ctx->f->addFnAttr(Attribute::StackProtectReq);\n    }\n\n    JL_GC_POP();\n    // Finally we need to box the result into julia type\n    // However, if we have already created a box for the return\n    // type because the ABI required us to pass a pointer (sret),\n    // then we do not need to do this.\n    if (!sret) {\n        if (lrt == T_void)\n            result = literal_pointer_val((jl_value_t*)jl_nothing);\n        else if (lrt->isStructTy()) {\n            //fprintf(stderr, \"ccall rt: %s -> %s\\n\", f_name, ((jl_tag_type_t*)rt)->name->name->name);\n            assert(jl_is_structtype(rt));\n            Value *newst = emit_new_struct(rt,1,NULL,ctx);\n            assert(newst != NULL && \"Type was not concrete\");\n            assert(newst->getType()->isPointerTy());\n            // julia gc is aligned 16, otherwise use default alignment for alloca pointers\n            builder.CreateAlignedStore(result, builder.CreateBitCast(newst, prt->getPointerTo()), newst->getType()==jl_pvalue_llvmt ? 16 : 0);\n            result = newst;\n        }\n        else {\n            if (prt->getPrimitiveSizeInBits() == lrt->getPrimitiveSizeInBits()) {\n                result = builder.CreateBitCast(result,lrt);\n            }\n            else {\n                Value *rloc = emit_static_alloca(lrt, ctx);\n                builder.CreateStore(result, builder.CreatePointerCast(rloc, PointerType::get(prt,0)));\n                if (lrt->isAggregateType()) {\n                    result = rloc;\n                }\n                else {\n                    result = builder.CreateLoad(rloc);\n                }\n            }\n        }\n    }\n    else {\n        if (result->getType() != jl_pvalue_llvmt && !lrt->isAggregateType())\n            result = builder.CreateLoad(result); // something alloca'd above\n    }\n\n    return mark_or_box_ccall_result(result, args[2], rt, static_rt, ctx);\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/src/flisp/print.c": "extern void *memrchr(const void *s, int c, size_t n);\n\nstatic htable_t printconses;\nstatic u_int32_t printlabel;\nstatic int print_pretty;\nstatic int print_princ;\nstatic fixnum_t print_length;\nstatic fixnum_t print_level;\nstatic fixnum_t P_LEVEL;\nstatic int SCR_WIDTH = 80;\n\nstatic int HPOS=0, VPOS;\nstatic void outc(char c, ios_t *f)\n{\n    ios_putc(c, f);\n    if (c == '\\n')\n        HPOS = 0;\n    else\n        HPOS++;\n}\nstatic void outs(char *s, ios_t *f)\n{\n    ios_puts(s, f);\n    HPOS += u8_strwidth(s);\n}\nstatic void outsn(char *s, ios_t *f, size_t n)\n{\n    ios_write(f, s, n);\n    HPOS += u8_strwidth(s);\n}\nstatic int outindent(int n, ios_t *f)\n{\n    // move back to left margin if we get too indented\n    if (n > SCR_WIDTH-12)\n        n = 2;\n    int n0 = n;\n    ios_putc('\\n', f);\n    VPOS++;\n    HPOS = n;\n    while (n >= 8) {\n        ios_putc('\\t', f);\n        n -= 8;\n    }\n    while (n) {\n        ios_putc(' ', f);\n        n--;\n    }\n    return n0;\n}\n\nvoid fl_print_chr(char c, ios_t *f)\n{\n    outc(c, f);\n}\n\nvoid fl_print_str(char *s, ios_t *f)\n{\n    outs(s, f);\n}\n\nvoid print_traverse(value_t v)\n{\n    value_t *bp;\n    while (iscons(v)) {\n        if (ismarked(v)) {\n            bp = (value_t*)ptrhash_bp(&printconses, (void*)v);\n            if (*bp == (value_t)HT_NOTFOUND)\n                *bp = fixnum(printlabel++);\n            return;\n        }\n        mark_cons(v);\n        print_traverse(car_(v));\n        v = cdr_(v);\n    }\n    if (!ismanaged(v) || issymbol(v))\n        return;\n    if (ismarked(v)) {\n        bp = (value_t*)ptrhash_bp(&printconses, (void*)v);\n        if (*bp == (value_t)HT_NOTFOUND)\n            *bp = fixnum(printlabel++);\n        return;\n    }\n    if (isvector(v)) {\n        if (vector_size(v) > 0)\n            mark_cons(v);\n        unsigned int i;\n        for(i=0; i < vector_size(v); i++)\n            print_traverse(vector_elt(v,i));\n    }\n    else if (iscprim(v)) {\n        mark_cons(v);\n    }\n    else if (isclosure(v)) {\n        mark_cons(v);\n        function_t *f = (function_t*)ptr(v);\n        print_traverse(f->bcode);\n        print_traverse(f->vals);\n        print_traverse(f->env);\n    }\n    else {\n        assert(iscvalue(v));\n        cvalue_t *cv = (cvalue_t*)ptr(v);\n        // don't consider shared references to \"\"\n        if (!cv_isstr(cv) || cv_len(cv)!=0)\n            mark_cons(v);\n        fltype_t *t = cv_class(cv);\n        if (t->vtable != NULL && t->vtable->print_traverse != NULL)\n            t->vtable->print_traverse(v);\n    }\n}\n\nstatic void print_symbol_name(ios_t *f, char *name)\n{\n    int i, escape=0, charescape=0;\n\n    if ((name[0] == '\\0') ||\n        (name[0] == '.' && name[1] == '\\0') ||\n        (name[0] == '#') ||\n        isnumtok(name, NULL))\n        escape = 1;\n    i=0;\n    while (name[i]) {\n        if (!symchar(name[i])) {\n            escape = 1;\n            if (name[i]=='|' || name[i]=='\\\\') {\n                charescape = 1;\n                break;\n            }\n        }\n        i++;\n    }\n    if (escape) {\n        if (charescape) {\n            outc('|', f);\n            i=0;\n            while (name[i]) {\n                if (name[i]=='|' || name[i]=='\\\\')\n                    outc('\\\\', f);\n                outc(name[i], f);\n                i++;\n            }\n            outc('|', f);\n        }\n        else {\n            outc('|', f);\n            outs(name, f);\n            outc('|', f);\n        }\n    }\n    else {\n        outs(name, f);\n    }\n}\n\n/*\n  The following implements a simple pretty-printing algorithm. This is\n  an unlimited-width approach that doesn't require an extra pass.\n  It uses some heuristics to guess whether an expression is \"small\",\n  and avoids wrapping symbols across lines. The result is high\n  performance and nice output for typical code. Quality is poor for\n  pathological or deeply-nested expressions, but those are difficult\n  to print anyway.\n*/\n#define SMALL_STR_LEN 20\nstatic inline int tinyp(value_t v)\n{\n    if (issymbol(v))\n        return (u8_strwidth(symbol_name(v)) < SMALL_STR_LEN);\n    if (fl_isstring(v))\n        return (cv_len((cvalue_t*)ptr(v)) < SMALL_STR_LEN);\n    return (isfixnum(v) || isbuiltin(v) || v==FL_F || v==FL_T || v==FL_NIL ||\n            v == FL_EOF);\n}\n\nstatic int smallp(value_t v)\n{\n    if (tinyp(v)) return 1;\n    if (fl_isnumber(v)) return 1;\n    if (iscons(v)) {\n        if (tinyp(car_(v)) && (tinyp(cdr_(v)) ||\n                               (iscons(cdr_(v)) && tinyp(car_(cdr_(v))) &&\n                                cdr_(cdr_(v))==NIL)))\n            return 1;\n        return 0;\n    }\n    if (isvector(v)) {\n        size_t s = vector_size(v);\n        return (s == 0 || (tinyp(vector_elt(v,0)) &&\n                           (s == 1 || (s == 2 &&\n                                       tinyp(vector_elt(v,1))))));\n    }\n    return 0;\n}\n\nstatic int specialindent(value_t head)\n{\n    // indent these forms 2 spaces, not lined up with the first argument\n    if (head == LAMBDA || head == TRYCATCH || head == definesym ||\n        head == defmacrosym || head == forsym)\n        return 2;\n    return -1;\n}\n\nstatic int lengthestimate(value_t v)\n{\n    // get the width of an expression if we can do so cheaply\n    if (issymbol(v))\n        return u8_strwidth(symbol_name(v));\n    return -1;\n}\n\nstatic int allsmallp(value_t v)\n{\n    int n = 1;\n    while (iscons(v)) {\n        if (!smallp(car_(v)))\n            return 0;\n        v = cdr_(v);\n        n++;\n        if (n > 25)\n            return n;\n    }\n    return n;\n}\n\nstatic int indentafter3(value_t head, value_t v)\n{\n    // for certain X always indent (X a b c) after b\n    return ((head == forsym) && !allsmallp(cdr_(v)));\n}\n\nstatic int indentafter2(value_t head, value_t v)\n{\n    // for certain X always indent (X a b) after a\n    return ((head == definesym || head == defmacrosym) &&\n            !allsmallp(cdr_(v)));\n}\n\nstatic int indentevery(value_t v)\n{\n    // indent before every subform of a special form, unless every\n    // subform is \"small\"\n    value_t c = car_(v);\n    if (c == LAMBDA || c == setqsym)\n        return 0;\n    if (c == IF) // TODO: others\n        return !allsmallp(cdr_(v));\n    return 0;\n}\n\nstatic int blockindent(value_t v)\n{\n    // in this case we switch to block indent mode, where the head\n    // is no longer considered special:\n    // (a b c d e\n    //  f g h i j)\n    return (allsmallp(v) > 9);\n}\n\nstatic void print_pair(ios_t *f, value_t v)\n{\n    value_t cd;\n    char *op = NULL;\n    if (iscons(cdr_(v)) && cdr_(cdr_(v)) == NIL &&\n        !ptrhash_has(&printconses, (void*)cdr_(v)) &&\n        (((car_(v) == QUOTE)     && (op = \"'\"))  ||\n         ((car_(v) == BACKQUOTE) && (op = \"`\"))  ||\n         ((car_(v) == COMMA)     && (op = \",\"))  ||\n         ((car_(v) == COMMAAT)   && (op = \",@\")) ||\n         ((car_(v) == COMMADOT)  && (op = \",.\")))) {\n        // special prefix syntax\n        unmark_cons(v);\n        unmark_cons(cdr_(v));\n        outs(op, f);\n        fl_print_child(f, car_(cdr_(v)));\n        return;\n    }\n    int startpos = HPOS;\n    outc('(', f);\n    int newindent=HPOS, blk=blockindent(v);\n    int lastv, n=0, si, ind=0, est, always=0, nextsmall, thistiny;\n    if (!blk) always = indentevery(v);\n    value_t head = car_(v);\n    int after3 = indentafter3(head, v);\n    int after2 = indentafter2(head, v);\n    int n_unindented = 1;\n    while (1) {\n        cd = cdr_(v);\n        if (print_length >= 0 && n >= print_length && cd!=NIL) {\n            outsn(\"...)\", f, 4);\n            break;\n        }\n        lastv = VPOS;\n        unmark_cons(v);\n        fl_print_child(f, car_(v));\n        if (!iscons(cd) || ptrhash_has(&printconses, (void*)cd)) {\n            if (cd != NIL) {\n                outsn(\" . \", f, 3);\n                fl_print_child(f, cd);\n            }\n            outc(')', f);\n            break;\n        }\n\n        if (!print_pretty ||\n            ((head == LAMBDA) && n == 0)) {\n            // never break line before lambda-list\n            ind = 0;\n        }\n        else {\n            est = lengthestimate(car_(cd));\n            nextsmall = smallp(car_(cd));\n            thistiny = tinyp(car_(v));\n            ind = (((VPOS > lastv) ||\n                    (HPOS>SCR_WIDTH/2 && !nextsmall && !thistiny && n>0)) ||\n\n                   (HPOS > SCR_WIDTH-4) ||\n\n                   (est!=-1 && (HPOS+est > SCR_WIDTH-2)) ||\n\n                   ((head == LAMBDA) && !nextsmall) ||\n\n                   (n > 0 && always) ||\n\n                   (n == 2 && after3) ||\n                   (n == 1 && after2) ||\n\n                   (n_unindented >= 3 && !nextsmall) ||\n\n                   (n == 0 && !smallp(head)));\n        }\n\n        if (ind) {\n            newindent = outindent(newindent, f);\n            n_unindented = 1;\n        }\n        else {\n            n_unindented++;\n            outc(' ', f);\n            if (n==0) {\n                // set indent level after printing head\n                si = specialindent(head);\n                if (si != -1)\n                    newindent = startpos + si;\n                else if (!blk)\n                    newindent = HPOS;\n            }\n        }\n        n++;\n        v = cd;\n    }\n}\n\nstatic void cvalue_print(ios_t *f, value_t v);\n\nstatic int print_circle_prefix(ios_t *f, value_t v)\n{\n    value_t label;\n    char buf[64];\n    char *str;\n    if ((label=(value_t)ptrhash_get(&printconses, (void*)v)) !=\n        (value_t)HT_NOTFOUND) {\n        if (!ismarked(v)) {\n            //HPOS+=ios_printf(f, \"#%ld#\", numval(label));\n            outc('#', f);\n            str = uint2str(buf, sizeof(buf)-1, numval(label), 10);\n            outs(str, f);\n            outc('#', f);\n            return 1;\n        }\n        //HPOS+=ios_printf(f, \"#%ld=\", numval(label));\n        outc('#', f);\n        str = uint2str(buf, sizeof(buf)-1, numval(label), 10);\n        outs(str, f);\n        outc('=', f);\n    }\n    if (ismanaged(v))\n        unmark_cons(v);\n    return 0;\n}\n\nvoid fl_print_child(ios_t *f, value_t v)\n{\n    char *name, *str;\n    char buf[64];\n    if (print_level >= 0 && P_LEVEL >= print_level &&\n        (iscons(v) || isvector(v) || isclosure(v))) {\n        outc('#', f);\n        return;\n    }\n    P_LEVEL++;\n\n    switch (tag(v)) {\n    case TAG_NUM :\n    case TAG_NUM1: //HPOS+=ios_printf(f, \"%ld\", numval(v)); break;\n        str = uint2str(&buf[1], sizeof(buf)-1, labs(numval(v)), 10);\n        if (numval(v)<0)\n            *(--str) = '-';\n        outs(str, f);\n        break;\n    case TAG_SYM:\n        name = symbol_name(v);\n        if (print_princ)\n            outs(name, f);\n        else if (ismanaged(v)) {\n            outsn(\"#:\", f, 2);\n            outs(name, f);\n        }\n        else\n            print_symbol_name(f, name);\n        break;\n    case TAG_FUNCTION:\n        if (v == FL_T) {\n            outsn(\"#t\", f, 2);\n        }\n        else if (v == FL_F) {\n            outsn(\"#f\", f, 2);\n        }\n        else if (v == FL_NIL) {\n            outsn(\"()\", f, 2);\n        }\n        else if (v == FL_EOF) {\n            outsn(\"#<eof>\", f, 6);\n        }\n        else if (isbuiltin(v)) {\n            if (!print_princ)\n                outsn(\"#.\", f, 2);\n            outs(builtin_names[uintval(v)], f);\n        }\n        else {\n            assert(isclosure(v));\n            if (!print_princ) {\n                if (print_circle_prefix(f, v)) break;\n                function_t *fn = (function_t*)ptr(v);\n                outs(\"#fn(\", f);\n                char *data = (char*)cvalue_data(fn->bcode);\n                size_t i, sz = cvalue_len(fn->bcode);\n                for(i=0; i < sz; i++) data[i] += 48;\n                fl_print_child(f, fn->bcode);\n                for(i=0; i < sz; i++) data[i] -= 48;\n                outc(' ', f);\n                fl_print_child(f, fn->vals);\n                if (fn->env != NIL) {\n                    outc(' ', f);\n                    fl_print_child(f, fn->env);\n                }\n                if (fn->name != LAMBDA) {\n                    outc(' ', f);\n                    fl_print_child(f, fn->name);\n                }\n                outc(')', f);\n            }\n            else {\n                outs(\"#<function>\", f);\n            }\n        }\n        break;\n    case TAG_CVALUE:\n    case TAG_CPRIM:\n        if (v == UNBOUND) { outs(\"#<undefined>\", f); break; }\n    case TAG_VECTOR:\n    case TAG_CONS:\n        if (print_circle_prefix(f, v)) break;\n        if (isvector(v)) {\n            outc('[', f);\n            int newindent = HPOS, est;\n            int i, sz = vector_size(v);\n            for(i=0; i < sz; i++) {\n                if (print_length >= 0 && i >= print_length && i < sz-1) {\n                    outsn(\"...\", f, 3);\n                    break;\n                }\n                fl_print_child(f, vector_elt(v,i));\n                if (i < sz-1) {\n                    if (!print_pretty) {\n                        outc(' ', f);\n                    }\n                    else {\n                        est = lengthestimate(vector_elt(v,i+1));\n                        if (HPOS > SCR_WIDTH-4 ||\n                            (est!=-1 && (HPOS+est > SCR_WIDTH-2)) ||\n                            (HPOS > SCR_WIDTH/2 &&\n                             !smallp(vector_elt(v,i+1)) &&\n                             !tinyp(vector_elt(v,i))))\n                            newindent = outindent(newindent, f);\n                        else\n                            outc(' ', f);\n                    }\n                }\n            }\n            outc(']', f);\n            break;\n        }\n        if (iscvalue(v) || iscprim(v))\n            cvalue_print(f, v);\n        else\n            print_pair(f, v);\n        break;\n    }\n    P_LEVEL--;\n}\n\nstatic void print_string(ios_t *f, char *str, size_t sz)\n{\n    char buf[512];\n    size_t i = 0;\n    uint8_t c;\n    static char hexdig[] = \"0123456789abcdef\";\n\n    outc('\"', f);\n    if (!u8_isvalid(str, sz)) {\n        // alternate print algorithm that preserves data if it's not UTF-8\n        for(i=0; i < sz; i++) {\n            c = str[i];\n            if (c == '\\\\')\n                outsn(\"\\\\\\\\\", f, 2);\n            else if (c == '\"')\n                outsn(\"\\\\\\\"\", f, 2);\n            else if (c >= 32 && c < 0x7f)\n                outc(c, f);\n            else {\n                outsn(\"\\\\x\", f, 2);\n                outc(hexdig[c>>4], f);\n                outc(hexdig[c&0xf], f);\n            }\n        }\n    }\n    else {\n        while (i < sz) {\n            size_t n = u8_escape(buf, sizeof(buf), str, &i, sz, 1, 0);\n            outsn(buf, f, n-1);\n        }\n    }\n    outc('\"', f);\n}\n\nstatic numerictype_t sym_to_numtype(value_t type);\n#ifndef _OS_WINDOWS_\n#define __USE_GNU\n#include <dlfcn.h>\n#undef __USE_GNU\n#endif\n\n#define sign_bit(r) ((*(int64_t*)&(r)) & BIT63)\n#define DFINITE(d) (((*(int64_t*)&(d))&0x7ff0000000000000LL)!=0x7ff0000000000000LL)\n\n// 'weak' means we don't need to accurately reproduce the type, so\n// for example #int32(0) can be printed as just 0. this is used\n// printing in a context where a type is already implied, e.g. inside\n// an array.\nstatic void cvalue_printdata(ios_t *f, void *data, size_t len, value_t type,\n                             int weak)\n{\n    if (type == bytesym) {\n        unsigned char ch = *(unsigned char*)data;\n        if (print_princ)\n            outc(ch, f);\n        else if (weak)\n            HPOS+=ios_printf(f, \"0x%hhx\", ch);\n        else\n            HPOS+=ios_printf(f, \"#byte(0x%hhx)\", ch);\n    }\n    else if (type == wcharsym) {\n        uint32_t wc = *(uint32_t*)data;\n        char seq[8];\n        size_t nb = u8_toutf8(seq, sizeof(seq), &wc, 1);\n        seq[nb] = '\\0';\n        if (print_princ) {\n            // TODO: better multibyte handling\n            outs(seq, f);\n        }\n        else {\n            outsn(\"#\\\\\", f, 2);\n            if      (wc == 0x00) outsn(\"nul\", f, 3);\n            else if (wc == 0x07) outsn(\"alarm\", f, 5);\n            else if (wc == 0x08) outsn(\"backspace\", f, 9);\n            else if (wc == 0x09) outsn(\"tab\", f, 3);\n            else if (wc == 0x0A) outsn(\"linefeed\", f, 8);\n            //else if (wc == 0x0A) outsn(\"newline\", f, 7);\n            else if (wc == 0x0B) outsn(\"vtab\", f, 4);\n            else if (wc == 0x0C) outsn(\"page\", f, 4);\n            else if (wc == 0x0D) outsn(\"return\", f, 6);\n            else if (wc == 0x1B) outsn(\"esc\", f, 3);\n            else if (wc == 0x20) outsn(\"space\", f, 5);\n            else if (wc == 0x7F) outsn(\"delete\", f, 6);\n            else if (iswprint(wc)) outs(seq, f);\n            else HPOS+=ios_printf(f, \"x%04x\", (int)wc);\n        }\n    }\n    else if (type == floatsym || type == doublesym) {\n        char buf[64];\n        double d;\n        if (type == floatsym) { d = (double)*(float*)data; }\n        else { d = *(double*)data; }\n        if (!DFINITE(d)) {\n            char *rep;\n            if (d != d)\n                rep = (char*)(sign_bit(d) ? \"-nan.0\" : \"+nan.0\");\n            else\n                rep = (char*)(sign_bit(d) ? \"-inf.0\" : \"+inf.0\");\n            if (type == floatsym && !print_princ && !weak)\n                HPOS+=ios_printf(f, \"#%s(%s)\", symbol_name(type), rep);\n            else\n                outs(rep, f);\n        }\n        else if (d == 0) {\n            if (sign_bit(d))\n                outsn(\"-0.0\", f, 4);\n            else\n                outsn(\"0.0\", f, 3);\n            if (type == floatsym && !print_princ && !weak)\n                outc('f', f);\n        }\n        else {\n            double ad = d < 0 ? -d : d;\n            if ((long)d == d && ad < 1e6 && ad >= 1e-4) {\n                snprintf(buf, sizeof(buf), \"%g\", d);\n            }\n            else {\n                if (type == floatsym)\n                    snprintf(buf, sizeof(buf), \"%.8g\", d);\n                else\n                    snprintf(buf, sizeof(buf), \"%.16g\", d);\n            }\n            int hasdec = (strpbrk(buf, \".eE\") != NULL);\n            outs(buf, f);\n            if (!hasdec) outsn(\".0\", f, 2);\n            if (type == floatsym && !print_princ && !weak)\n                outc('f', f);\n        }\n    }\n    else if (type == uint64sym\n#ifdef _P64\n             || type == sizesym\n#endif\n             ) {\n        uint64_t ui64 = *(uint64_t*)data;\n        if (weak || print_princ)\n            HPOS += ios_printf(f, \"%llu\", ui64);\n        else\n            HPOS += ios_printf(f, \"#%s(%llu)\", symbol_name(type), ui64);\n    }\n    else if (issymbol(type)) {\n        // handle other integer prims. we know it's smaller than uint64\n        // at this point, so int64 is big enough to capture everything.\n        numerictype_t nt = sym_to_numtype(type);\n        if (nt == N_NUMTYPES) {\n            static size_t (*jl_static_print)(ios_t*, void*) = 0;\n            static int init = 0;\n            static value_t jl_sym = 0;\n            if (init == 0) {\n                init = 1;\n#if defined(RTLD_SELF)\n                jl_static_print = (size_t (*)(ios_t *, void *)) dlsym(RTLD_SELF, \"jl_static_show\");\n#elif defined(RTLD_DEFAULT)\n                jl_static_print = (size_t (*)(ios_t *, void *)) dlsym(RTLD_DEFAULT, \"jl_static_show\");\n#endif\n                jl_sym = symbol(\"julia_value\");\n            }\n            if (jl_static_print != 0 && jl_sym == type) {\n                HPOS += ios_printf(f, \"#<julia: \");\n                HPOS += jl_static_print(f, *(void**)data);\n                HPOS += ios_printf(f, \">\");\n            }\n            else\n                HPOS += ios_printf(f, \"#<%s>\", symbol_name(type));\n        }\n        else {\n            int64_t i64 = conv_to_int64(data, nt);\n            if (weak || print_princ)\n                HPOS += ios_printf(f, \"%lld\", i64);\n            else\n                HPOS += ios_printf(f, \"#%s(%lld)\", symbol_name(type), i64);\n        }\n    }\n    else if (iscons(type)) {\n        if (car_(type) == arraysym) {\n            value_t eltype = car(cdr_(type));\n            size_t cnt, elsize;\n            if (iscons(cdr_(cdr_(type)))) {\n                cnt = tosize(car_(cdr_(cdr_(type))), \"length\");\n                elsize = cnt ? len/cnt : 0;\n            }\n            else {\n                // incomplete array type\n                int junk;\n                elsize = ctype_sizeof(eltype, &junk);\n                cnt = elsize ? len/elsize : 0;\n            }\n            if (eltype == bytesym) {\n                if (print_princ) {\n                    ios_write(f, (char*)data, len);\n                    /*\n                    char *nl = memrchr(data, '\\n', len);\n                    if (nl)\n                        HPOS = u8_strwidth(nl+1);\n                    else\n                        HPOS += u8_strwidth(data);\n                    */\n                }\n                else {\n                    print_string(f, (char*)data, len);\n                }\n                return;\n            }\n            else if (eltype == wcharsym) {\n                // TODO wchar\n            }\n            else {\n            }\n            size_t i;\n            if (!weak) {\n                if (eltype == uint8sym) {\n                    outsn(\"#vu8(\", f, 5);\n                }\n                else {\n                    outsn(\"#array(\", f, 7);\n                    fl_print_child(f, eltype);\n                    if (cnt > 0)\n                        outc(' ', f);\n                }\n            }\n            else {\n                outc('[', f);\n            }\n            for(i=0; i < cnt; i++) {\n                if (i > 0)\n                    outc(' ', f);\n                cvalue_printdata(f, data, elsize, eltype, 1);\n                data = (char *)data + elsize;\n            }\n            if (!weak)\n                outc(')', f);\n            else\n                outc(']', f);\n        }\n    }\n}\n\nstatic void cvalue_print(ios_t *f, value_t v)\n{\n    cvalue_t *cv = (cvalue_t*)ptr(v);\n    void *data = cptr(v);\n    value_t label;\n\n    if (cv_class(cv) == builtintype) {\n        void *fptr = *(void**)data;\n        label = (value_t)ptrhash_get(&reverse_dlsym_lookup_table, cv);\n        if (label == (value_t)HT_NOTFOUND) {\n            HPOS += ios_printf(f, \"#<builtin @0x%08zx>\",\n                               (size_t)(builtin_t)fptr);\n        }\n        else {\n            if (print_princ) {\n                outs(symbol_name(label), f);\n            }\n            else {\n                outsn(\"#fn(\", f, 4);\n                outs(symbol_name(label), f);\n                outc(')', f);\n            }\n        }\n    }\n    else if (cv_class(cv)->vtable != NULL &&\n             cv_class(cv)->vtable->print != NULL) {\n        cv_class(cv)->vtable->print(v, f);\n    }\n    else {\n        value_t type = cv_type(cv);\n        size_t len = iscprim(v) ? cv_class(cv)->size : cv_len(cv);\n        cvalue_printdata(f, data, len, type, 0);\n    }\n}\n\nstatic void set_print_width(void)\n{\n    value_t pw = symbol_value(printwidthsym);\n    if (!isfixnum(pw)) return;\n    SCR_WIDTH = numval(pw);\n}\n\nvoid fl_print(ios_t *f, value_t v)\n{\n    print_pretty = (symbol_value(printprettysym) != FL_F);\n    if (print_pretty)\n        set_print_width();\n    print_princ = (symbol_value(printreadablysym) == FL_F);\n\n    value_t pl = symbol_value(printlengthsym);\n    if (isfixnum(pl)) print_length = numval(pl);\n    else print_length = -1;\n    pl = symbol_value(printlevelsym);\n    if (isfixnum(pl)) print_level = numval(pl);\n    else print_level = -1;\n    P_LEVEL = 0;\n\n    printlabel = 0;\n    print_traverse(v);\n    HPOS = VPOS = 0;\n\n    fl_print_child(f, v);\n\n    if (print_level >= 0 || print_length >= 0) {\n        memset(consflags, 0, 4*bitvector_nwords(heapsize/sizeof(cons_t)));\n    }\n\n    if ((iscons(v) || isvector(v) || isfunction(v) || iscvalue(v)) &&\n        !fl_isstring(v) && v!=FL_T && v!=FL_F && v!=FL_NIL) {\n        htable_reset(&printconses, 32);\n    }\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/src/flisp/flisp.h": "#ifndef FLISP_H\n#define FLISP_H\n\n#include <setjmp.h>\n#include <stdint.h>\n\n#include \"platform.h\"\n#include \"libsupport.h\"\n#include \"uv.h\"\n\n//#define MEMDEBUG\n//#define MEMDEBUG2\n\ntypedef uptrint_t value_t;\ntypedef int_t fixnum_t;\n#if NBITS==64\n#define T_FIXNUM T_INT64\n#define labs llabs\n#else\n#define T_FIXNUM T_INT32\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    value_t car;\n    value_t cdr;\n} cons_t;\n\ntypedef struct _symbol_t {\n    uptrint_t flags;\n    value_t binding;   // global value binding\n    struct _fltype_t *type;\n    uint32_t hash;\n    void *dlcache;     // dlsym address\n    // below fields are private\n    struct _symbol_t *left;\n    struct _symbol_t *right;\n    union {\n        char name[1];\n        void *_pad;    // ensure field aligned to pointer size\n    };\n} symbol_t;\n\ntypedef struct {\n    value_t isconst;\n    value_t binding;   // global value binding\n    struct _fltype_t *type;\n    uint32_t id;\n} gensym_t;\n\n#define TAG_NUM      0x0\n#define TAG_CPRIM    0x1\n#define TAG_FUNCTION 0x2\n#define TAG_VECTOR   0x3\n#define TAG_NUM1     0x4\n#define TAG_CVALUE   0x5\n#define TAG_SYM      0x6\n#define TAG_CONS     0x7\n#define UNBOUND      ((value_t)0x1) // an invalid value\n#define TAG_FWD      UNBOUND\n#define tag(x) ((x)&0x7)\n#define ptr(x) ((void*)((x)&(~(value_t)0x7)))\n#define tagptr(p,t) (((value_t)(p)) | (t))\n#define fixnum(x) ((value_t)(((uptrint_t)(x))<<2))\n#define numval(x)  (((fixnum_t)(x))>>2)\n#if NBITS==64\n#define fits_fixnum(x) (((x)>>61) == 0 || (~((x)>>61)) == 0)\n#else\n#define fits_fixnum(x) (((x)>>29) == 0 || (~((x)>>29)) == 0)\n#endif\n#define fits_bits(x,b) (((x)>>(b-1)) == 0 || (~((x)>>(b-1))) == 0)\n#define uintval(x)  (((unsigned int)(x))>>3)\n#define builtin(n) tagptr((((int)n)<<3), TAG_FUNCTION)\n#define iscons(x)    (tag(x) == TAG_CONS)\n#define issymbol(x)  (tag(x) == TAG_SYM)\n#define isfixnum(x)  (((x)&3) == TAG_NUM)\n#define bothfixnums(x,y) ((((x)|(y))&3) == TAG_NUM)\n#define isbuiltin(x) ((tag(x) == TAG_FUNCTION) && uintval(x) <= OP_ASET)\n#define isvector(x) (tag(x) == TAG_VECTOR)\n#define iscvalue(x) (tag(x) == TAG_CVALUE)\n#define iscprim(x)  (tag(x) == TAG_CPRIM)\n#define selfevaluating(x) (tag(x)<6)\n// comparable with ==\n#define eq_comparable(a,b) (!(((a)|(b))&1))\n#define eq_comparablep(a) (!((a)&1))\n// doesn't lead to other values\n#define leafp(a) (((a)&3) != 3)\n\n#define isforwarded(v) (((value_t*)ptr(v))[0] == TAG_FWD)\n#define forwardloc(v)  (((value_t*)ptr(v))[1])\n#define forward(v,to) do { (((value_t*)ptr(v))[0] = TAG_FWD); \\\n                           (((value_t*)ptr(v))[1] = to); } while (0)\n\n#define vector_size(v) (((size_t*)ptr(v))[0]>>2)\n#define vector_setsize(v,n) (((size_t*)ptr(v))[0] = ((n)<<2))\n#define vector_elt(v,i) (((value_t*)ptr(v))[1+(i)])\n#define vector_grow_amt(x) ((x)<8 ? 5 : 6*((x)>>3))\n// functions ending in _ are unsafe, faster versions\n#define car_(v) (((cons_t*)ptr(v))->car)\n#define cdr_(v) (((cons_t*)ptr(v))->cdr)\n#define car(v)  (tocons((v),\"car\")->car)\n#define cdr(v)  (tocons((v),\"cdr\")->cdr)\n#define fn_bcode(f) (((value_t*)ptr(f))[0])\n#define fn_vals(f) (((value_t*)ptr(f))[1])\n#define fn_env(f) (((value_t*)ptr(f))[2])\n#define fn_name(f) (((value_t*)ptr(f))[3])\n\n#define set(s, v)  (((symbol_t*)ptr(s))->binding = (v))\n#define setc(s, v) do { ((symbol_t*)ptr(s))->flags |= 1; \\\n                        ((symbol_t*)ptr(s))->binding = (v); } while (0)\n#define isconstant(s) ((s)->flags&0x1)\n#define iskeyword(s) ((s)->flags&0x2)\n#define symbol_value(s) (((symbol_t*)ptr(s))->binding)\n#ifdef MEMDEBUG2\n#define ismanaged(v) (!issymbol(v) && !isfixnum(v) && ((v)>(N_OPCODES<<3)) && !iscbuiltin(v))\n#else\n#define ismanaged(v) ((((unsigned char*)ptr(v)) >= fromspace) && \\\n                      (((unsigned char*)ptr(v)) < fromspace+heapsize))\n#endif\n#define isgensym(x)  (issymbol(x) && ismanaged(x))\n\n#define isfunction(x) (tag(x) == TAG_FUNCTION && (x) > (N_BUILTINS<<3))\n#define isclosure(x) isfunction(x)\n#define iscbuiltin(x) (iscvalue(x) && (cv_class((cvalue_t*)ptr(x))==builtintype))\n\nvoid fl_gc_handle(value_t *pv);\nvoid fl_free_gc_handles(uint32_t n);\n\n#include \"opcodes.h\"\n\n// utility for iterating over all arguments in a builtin\n// i=index, i0=start index, arg = var for each arg, args = arg array\n// assumes \"nargs\" is the argument count\n#define FOR_ARGS(i, i0, arg, args)     \\\n    for(i=i0; ((size_t)i)<nargs && ((arg=args[i]) || 1); i++)\n\n#define N_BUILTINS ((int)N_OPCODES)\n\nextern value_t FL_NIL, FL_T, FL_F, FL_EOF;\n\n#define FL_UNSPECIFIED FL_T\n\n/* read, eval, print main entry points */\nvalue_t fl_read_sexpr(value_t f);\nvoid fl_print(ios_t *f, value_t v);\nvalue_t fl_toplevel_eval(value_t expr);\nvalue_t fl_apply(value_t f, value_t l);\nvalue_t fl_applyn(uint32_t n, value_t f, ...);\n\nextern value_t printprettysym, printreadablysym, printwidthsym;\n\n/* object model manipulation */\nvalue_t fl_cons(value_t a, value_t b);\nvalue_t fl_list2(value_t a, value_t b);\nvalue_t fl_listn(size_t n, ...);\nvalue_t symbol(char *str);\nchar *symbol_name(value_t v);\nint fl_is_keyword_name(const char *str, size_t len);\nvalue_t alloc_vector(size_t n, int init);\nsize_t llength(value_t v);\nvalue_t fl_compare(value_t a, value_t b);  // -1, 0, or 1\nvalue_t fl_equal(value_t a, value_t b);    // T or nil\nint equal_lispvalue(value_t a, value_t b);\nuptrint_t hash_lispvalue(value_t a);\nint isnumtok_base(char *tok, value_t *pval, int base);\n\n/* safe casts */\ncons_t *tocons(value_t v, char *fname);\nsymbol_t *tosymbol(value_t v, char *fname);\nfixnum_t tofixnum(value_t v, char *fname);\nchar *tostring(value_t v, char *fname);\n\n/* error handling */\ntypedef struct _ectx_t {\n    jmp_buf buf;\n    uint32_t sp;\n    uint32_t frame;\n    uint32_t ngchnd;\n    void *rdst;\n    struct _ectx_t *prev;\n} fl_exception_context_t;\n\nextern fl_exception_context_t *fl_ctx;\nextern uint32_t fl_throwing_frame;\nextern value_t fl_lasterror;\n\n#define FL_TRY_EXTERN                                                   \\\n  fl_exception_context_t _ctx; int l__tr, l__ca;                        \\\n  fl_savestate(&_ctx); fl_ctx = &_ctx;                                  \\\n  if (!setjmp(_ctx.buf))                                                \\\n    for (l__tr=1; l__tr; l__tr=0, (void)(fl_ctx=fl_ctx->prev))\n\n#define FL_CATCH_EXTERN \\\n  else \\\n    for(l__ca=1; l__ca; l__ca=0, fl_restorestate(&_ctx))\n\n#if defined(_OS_WINDOWS_)\n__declspec(noreturn) void lerrorf(value_t e, char *format, ...);\n__declspec(noreturn) void lerror(value_t e, const char *msg);\n__declspec(noreturn) void fl_raise(value_t e);\n__declspec(noreturn) void type_error(char *fname, char *expected, value_t got);\n__declspec(noreturn) void bounds_error(char *fname, value_t arr, value_t ind);\n#else\nvoid lerrorf(value_t e, char *format, ...) __attribute__ ((__noreturn__));\nvoid lerror(value_t e, const char *msg) __attribute__ ((__noreturn__));\nvoid fl_raise(value_t e) __attribute__ ((__noreturn__));\nvoid type_error(char *fname, char *expected, value_t got) __attribute__ ((__noreturn__));\nvoid bounds_error(char *fname, value_t arr, value_t ind) __attribute__ ((__noreturn__));\n#endif\n\nvoid fl_savestate(fl_exception_context_t *_ctx);\nvoid fl_restorestate(fl_exception_context_t *_ctx);\n\nextern value_t ArgError, IOError, KeyError, OutOfMemoryError, EnumerationError;\nextern value_t UnboundError;\n\nstatic inline void argcount(char *fname, uint32_t nargs, uint32_t c)\n{\n    if (__unlikely(nargs != c))\n        lerrorf(ArgError,\"%s: too %s arguments\", fname, nargs<c ? \"few\":\"many\");\n}\n\ntypedef struct {\n    void (*print)(value_t self, ios_t *f);\n    void (*relocate)(value_t oldv, value_t newv);\n    void (*finalize)(value_t self);\n    void (*print_traverse)(value_t self);\n} cvtable_t;\n\n/* functions needed to implement the value interface (cvtable_t) */\nvalue_t relocate_lispvalue(value_t v);\nvoid print_traverse(value_t v);\nvoid fl_print_chr(char c, ios_t *f);\nvoid fl_print_str(char *s, ios_t *f);\nvoid fl_print_child(ios_t *f, value_t v);\n\ntypedef int (*cvinitfunc_t)(struct _fltype_t*, value_t, void*);\n\ntypedef struct _fltype_t {\n    value_t type;\n    numerictype_t numtype;\n    size_t size;\n    size_t elsz;\n    cvtable_t *vtable;\n    struct _fltype_t *eltype;  // for arrays\n    struct _fltype_t *artype;  // (array this)\n    int marked;\n    cvinitfunc_t init;\n} fltype_t;\n\ntypedef struct {\n    fltype_t *type;\n    void *data;\n    size_t len;            // length of *data in bytes\n    union {\n        value_t parent;    // optional\n        char _space[1];    // variable size\n    };\n} cvalue_t;\n\n#define CVALUE_NWORDS 4\n\ntypedef struct {\n    fltype_t *type;\n    char _space[1];\n} cprim_t;\n\ntypedef struct {\n    value_t bcode;\n    value_t vals;\n    value_t env;\n    value_t name;\n} function_t;\n\n#define CPRIM_NWORDS 2\n#define MAX_INL_SIZE 384\n\n#define CV_OWNED_BIT  0x1\n#define CV_PARENT_BIT 0x2\n#define owned(cv)      ((uptrint_t)(cv)->type & CV_OWNED_BIT)\n#define hasparent(cv)  ((uptrint_t)(cv)->type & CV_PARENT_BIT)\n#define isinlined(cv)  ((cv)->data == &(cv)->_space[0])\n#define cv_class(cv)   ((fltype_t*)(((uptrint_t)(cv)->type)&~3))\n#define cv_len(cv)     ((cv)->len)\n#define cv_type(cv)    (cv_class(cv)->type)\n#define cv_data(cv)    ((cv)->data)\n#define cv_isstr(cv)   (cv_class(cv)->eltype == bytetype)\n#define cv_isPOD(cv)   (cv_class(cv)->init != NULL)\n\n#define cvalue_data(v) cv_data((cvalue_t*)ptr(v))\n#define cvalue_len(v) cv_len((cvalue_t*)ptr(v))\n#define value2c(type, v) ((type)cv_data((cvalue_t*)ptr(v)))\n\n#define valid_numtype(v) ((v) < N_NUMTYPES)\n#define cp_class(cp)   ((cp)->type)\n#define cp_type(cp)    (cp_class(cp)->type)\n#define cp_numtype(cp) (cp_class(cp)->numtype)\n#define cp_data(cp)    (&(cp)->_space[0])\n\n// WARNING: multiple evaluation!\n#define cptr(v) \\\n    (iscprim(v) ? cp_data((cprim_t*)ptr(v)) : cv_data((cvalue_t*)ptr(v)))\n\n/* C type names corresponding to cvalues type names */\ntypedef int8_t   fl_int8_t;\ntypedef uint8_t  fl_uint8_t;\ntypedef int16_t  fl_int16_t;\ntypedef uint16_t fl_uint16_t;\ntypedef int32_t  fl_int32_t;\ntypedef uint32_t fl_uint32_t;\ntypedef int64_t  fl_int64_t;\ntypedef uint64_t fl_uint64_t;\ntypedef char     fl_char_t;\ntypedef char     char_t;\ntypedef ptrdiff_t fl_ptrdiff_t;\ntypedef size_t   fl_size_t;\ntypedef double   fl_double_t;\ntypedef float    fl_float_t;\n\ntypedef value_t (*builtin_t)(value_t*, uint32_t);\n\nextern value_t QUOTE;\nextern value_t int8sym, uint8sym, int16sym, uint16sym, int32sym, uint32sym;\nextern value_t int64sym, uint64sym;\nextern value_t ptrdiffsym, sizesym, bytesym, wcharsym;\nextern value_t arraysym, cfunctionsym, voidsym, pointersym;\nextern value_t stringtypesym, wcstringtypesym, emptystringsym;\nextern value_t floatsym, doublesym;\nextern fltype_t *bytetype, *wchartype;\nextern fltype_t *stringtype, *wcstringtype;\nextern fltype_t *builtintype;\n\nvalue_t cvalue(fltype_t *type, size_t sz);\nvoid add_finalizer(cvalue_t *cv);\nvoid cv_autorelease(cvalue_t *cv);\nvoid cv_pin(cvalue_t *cv);\nsize_t ctype_sizeof(value_t type, int *palign);\nvalue_t cvalue_copy(value_t v);\nvalue_t cvalue_from_data(fltype_t *type, void *data, size_t sz);\nvalue_t cvalue_from_ref(fltype_t *type, void *ptr, size_t sz, value_t parent);\nvalue_t cbuiltin(char *name, builtin_t f);\nsize_t cvalue_arraylen(value_t v);\nvalue_t size_wrap(size_t sz);\nsize_t tosize(value_t n, char *fname);\nvalue_t cvalue_string(size_t sz);\nvalue_t cvalue_static_cstrn(const char *str, size_t n);\nvalue_t cvalue_static_cstring(const char *str);\nvalue_t string_from_cstr(char *str);\nvalue_t string_from_cstrn(char *str, size_t n);\nint fl_isstring(value_t v);\nint fl_isnumber(value_t v);\nint fl_isgensym(value_t v);\nint fl_isiostream(value_t v);\nios_t *fl_toiostream(value_t v, char *fname);\nvalue_t cvalue_compare(value_t a, value_t b);\nint numeric_compare(value_t a, value_t b, int eq, int eqnans, char *fname);\n\nvoid to_sized_ptr(value_t v, char *fname, char **pdata, size_t *psz);\n\nfltype_t *get_type(value_t t);\nfltype_t *get_array_type(value_t eltype);\nfltype_t *define_opaque_type(value_t sym, size_t sz, cvtable_t *vtab,\n                             cvinitfunc_t init);\n\nvalue_t mk_double(fl_double_t n);\nvalue_t mk_float(fl_float_t n);\nvalue_t mk_uint32(uint32_t n);\nvalue_t mk_uint64(uint64_t n);\nvalue_t mk_wchar(int32_t n);\nvalue_t return_from_uint64(uint64_t Uaccum);\nvalue_t return_from_int64(int64_t Saccum);\n\ntypedef struct {\n    char *name;\n    builtin_t fptr;\n} builtinspec_t;\n\nvoid assign_global_builtins(builtinspec_t *b);\n\n/* builtins */\nvalue_t fl_hash(value_t *args, u_int32_t nargs);\nvalue_t cvalue_byte(value_t *args, uint32_t nargs);\nvalue_t cvalue_wchar(value_t *args, uint32_t nargs);\n\nvoid fl_init(size_t initial_heapsize);\nint fl_load_system_image(value_t ios);\nint fl_load_system_image_str(char* str, size_t len);\n\n/* julia extensions */\nDLLEXPORT int jl_id_char(uint32_t wc);\nDLLEXPORT int jl_id_start_char(uint32_t wc);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/src/flisp/cvalues.c": "#ifdef _P64\n#define NWORDS(sz) (((sz)+7)>>3)\n#else\n#define NWORDS(sz) (((sz)+3)>>2)\n#endif\n\nstatic int ALIGN2, ALIGN4, ALIGN8, ALIGNPTR;\n\nvalue_t int8sym, uint8sym, int16sym, uint16sym, int32sym, uint32sym;\nvalue_t int64sym, uint64sym;\nvalue_t ptrdiffsym, sizesym, bytesym, wcharsym;\nvalue_t floatsym, doublesym;\nvalue_t gftypesym, stringtypesym, wcstringtypesym;\nvalue_t emptystringsym;\n\nvalue_t arraysym, cfunctionsym, voidsym, pointersym;\n\nstatic htable_t TypeTable;\nstatic htable_t reverse_dlsym_lookup_table;\nstatic fltype_t *int8type, *uint8type;\nstatic fltype_t *int16type, *uint16type;\nstatic fltype_t *int32type, *uint32type;\nstatic fltype_t *int64type, *uint64type;\nstatic fltype_t *ptrdifftype, *sizetype;\nstatic fltype_t *floattype, *doubletype;\n       fltype_t *bytetype, *wchartype;\n       fltype_t *stringtype, *wcstringtype;\n       fltype_t *builtintype;\n\nstatic void cvalue_init(fltype_t *type, value_t v, void *dest);\n\n// cvalues-specific builtins\nvalue_t cvalue_new(value_t *args, u_int32_t nargs);\nvalue_t cvalue_sizeof(value_t *args, u_int32_t nargs);\nvalue_t cvalue_typeof(value_t *args, u_int32_t nargs);\n\n// trigger unconditional GC after this many bytes are allocated\n#define ALLOC_LIMIT_TRIGGER 67108864\n\nstatic size_t malloc_pressure = 0;\n\nstatic cvalue_t **Finalizers = NULL;\nstatic size_t nfinalizers=0;\nstatic size_t maxfinalizers=0;\n\nvoid add_finalizer(cvalue_t *cv)\n{\n    if (nfinalizers == maxfinalizers) {\n        size_t nn = (maxfinalizers==0 ? 256 : maxfinalizers*2);\n        cvalue_t **temp = (cvalue_t**)realloc(Finalizers, nn*sizeof(value_t));\n        if (temp == NULL)\n            lerror(OutOfMemoryError, \"out of memory\");\n        Finalizers = temp;\n        maxfinalizers = nn;\n    }\n    Finalizers[nfinalizers++] = cv;\n}\n\n// remove dead objects from finalization list in-place\nstatic void sweep_finalizers(void)\n{\n    cvalue_t **lst = Finalizers;\n    size_t n=0, ndel=0, l=nfinalizers;\n    cvalue_t *tmp;\n#define SWAP_sf(a,b) (tmp=a,a=b,b=tmp,1)\n    if (l == 0)\n        return;\n    do {\n        tmp = lst[n];\n        if (isforwarded((value_t)tmp)) {\n            // object is alive\n            lst[n] = (cvalue_t*)ptr(forwardloc((value_t)tmp));\n            n++;\n        }\n        else {\n            fltype_t *t = cv_class(tmp);\n            if (t->vtable != NULL && t->vtable->finalize != NULL) {\n                t->vtable->finalize(tagptr(tmp, TAG_CVALUE));\n            }\n            if (!isinlined(tmp) && owned(tmp)) {\n#ifdef DEBUG\n                memset(cv_data(tmp), 0xbb, cv_len(tmp));\n#endif\n                free(cv_data(tmp));\n            }\n            ndel++;\n        }\n    } while ((n < l-ndel) && SWAP_sf(lst[n],lst[n+ndel]));\n\n    nfinalizers -= ndel;\n#ifdef VERBOSEGC\n    if (ndel > 0)\n        printf(\"GC: finalized %d objects\\n\", ndel);\n#endif\n\n    malloc_pressure = 0;\n}\n\n// compute the size of the metadata object for a cvalue\nstatic size_t cv_nwords(cvalue_t *cv)\n{\n    if (isinlined(cv)) {\n        size_t n = cv_len(cv);\n        if (n==0 || cv_isstr(cv))\n            n++;\n        return CVALUE_NWORDS - 1 + NWORDS(n);\n    }\n    return CVALUE_NWORDS;\n}\n\nstatic void autorelease(cvalue_t *cv)\n{\n    cv->type = (fltype_t*)(((uptrint_t)cv->type) | CV_OWNED_BIT);\n    add_finalizer(cv);\n}\n\nvoid cv_autorelease(cvalue_t *cv)\n{\n    autorelease(cv);\n}\n\nstatic value_t cprim(fltype_t *type, size_t sz)\n{\n    cprim_t *pcp = (cprim_t*)alloc_words(CPRIM_NWORDS-1+NWORDS(sz));\n    pcp->type = type;\n    return tagptr(pcp, TAG_CPRIM);\n}\n\nvalue_t cvalue(fltype_t *type, size_t sz)\n{\n    cvalue_t *pcv;\n    int str=0;\n\n    if (valid_numtype(type->numtype)) {\n        return cprim(type, sz);\n    }\n    if (type->eltype == bytetype) {\n        if (sz == 0)\n            return symbol_value(emptystringsym);\n        sz++;\n        str=1;\n    }\n    if (sz <= MAX_INL_SIZE) {\n        size_t nw = CVALUE_NWORDS - 1 + NWORDS(sz) + (sz==0 ? 1 : 0);\n        pcv = (cvalue_t*)alloc_words(nw);\n        pcv->type = type;\n        pcv->data = &pcv->_space[0];\n        if (type->vtable != NULL && type->vtable->finalize != NULL)\n            add_finalizer(pcv);\n    }\n    else {\n        if (malloc_pressure > ALLOC_LIMIT_TRIGGER)\n            gc(0);\n        pcv = (cvalue_t*)alloc_words(CVALUE_NWORDS);\n        pcv->type = type;\n        pcv->data = malloc(sz);\n        autorelease(pcv);\n        malloc_pressure += sz;\n    }\n    if (str) {\n        sz--;\n        ((char*)pcv->data)[sz] = '\\0';\n    }\n    pcv->len = sz;\n    return tagptr(pcv, TAG_CVALUE);\n}\n\nvalue_t cvalue_from_data(fltype_t *type, void *data, size_t sz)\n{\n    value_t cv;\n    cv = cvalue(type, sz);\n    memcpy(cptr(cv), data, sz);\n    return cv;\n}\n\n// this effectively dereferences a pointer\n// just like *p in C, it only removes a level of indirection from the type,\n// it doesn't copy any data.\n// this method of creating a cvalue only allocates metadata.\n// ptr is user-managed; we don't autorelease it unless the\n// user explicitly calls (autorelease ) on the result of this function.\n// 'parent' is an optional cvalue that this pointer is known to point\n// into; NIL if none.\nvalue_t cvalue_from_ref(fltype_t *type, void *ptr, size_t sz, value_t parent)\n{\n    cvalue_t *pcv;\n    value_t cv;\n\n    pcv = (cvalue_t*)alloc_words(CVALUE_NWORDS);\n    pcv->data = ptr;\n    pcv->len = sz;\n    pcv->type = type;\n    if (parent != NIL) {\n        pcv->type = (fltype_t*)(((uptrint_t)pcv->type) | CV_PARENT_BIT);\n        pcv->parent = parent;\n    }\n    cv = tagptr(pcv, TAG_CVALUE);\n    return cv;\n}\n\nvalue_t cvalue_string(size_t sz)\n{\n    return cvalue(stringtype, sz);\n}\n\nvalue_t cvalue_static_cstrn(const char *str, size_t n)\n{\n    return cvalue_from_ref(stringtype, (char*)str, n, NIL);\n}\n\nvalue_t cvalue_static_cstring(const char *str)\n{\n    return cvalue_static_cstrn(str, strlen(str));\n}\n\nvalue_t string_from_cstrn(char *str, size_t n)\n{\n    value_t v = cvalue_string(n);\n    memcpy(cvalue_data(v), str, n);\n    return v;\n}\n\nvalue_t string_from_cstr(char *str)\n{\n    return string_from_cstrn(str, strlen(str));\n}\n\nint fl_isstring(value_t v)\n{\n    return (iscvalue(v) && cv_isstr((cvalue_t*)ptr(v)));\n}\n\n// convert to malloc representation (fixed address)\nvoid cv_pin(cvalue_t *cv)\n{\n    if (!isinlined(cv))\n        return;\n    size_t sz = cv_len(cv);\n    if (cv_isstr(cv)) sz++;\n    void *data = malloc(sz);\n    memcpy(data, cv_data(cv), sz);\n    cv->data = data;\n    autorelease(cv);\n}\n\n#define num_init(ctype, cnvt, tag)                              \\\nstatic int cvalue_##ctype##_init(fltype_t *type, value_t arg,   \\\n                                 void *dest)                    \\\n{                                                               \\\n    fl_##ctype##_t n=0;                                         \\\n    (void)type;                                                 \\\n    if (isfixnum(arg)) {                                        \\\n        n = numval(arg);                                        \\\n    }                                                           \\\n    else if (iscprim(arg)) {                                    \\\n        cprim_t *cp = (cprim_t*)ptr(arg);                       \\\n        void *p = cp_data(cp);                                  \\\n        n = (fl_##ctype##_t)conv_to_##cnvt(p, cp_numtype(cp));  \\\n    }                                                           \\\n    else {                                                      \\\n        return 1;                                               \\\n    }                                                           \\\n    *((fl_##ctype##_t*)dest) = n;                               \\\n    return 0;                                                   \\\n}\nnum_init(int8, int32, T_INT8)\nnum_init(uint8, uint32, T_UINT8)\nnum_init(int16, int32, T_INT16)\nnum_init(uint16, uint32, T_UINT16)\nnum_init(int32, int32, T_INT32)\nnum_init(uint32, uint32, T_UINT32)\nnum_init(int64, int64, T_INT64)\nnum_init(uint64, uint64, T_UINT64)\nnum_init(float, double, T_FLOAT)\nnum_init(double, double, T_DOUBLE)\n\n#define num_ctor_init(typenam, ctype, tag)                              \\\nvalue_t cvalue_##typenam(value_t *args, u_int32_t nargs)                \\\n{                                                                       \\\n    if (nargs==0) { PUSH(fixnum(0)); args = &Stack[SP-1]; }             \\\n    value_t cp = cprim(typenam##type, sizeof(fl_##ctype##_t));          \\\n    if (cvalue_##ctype##_init(typenam##type,                            \\\n                              args[0], cp_data((cprim_t*)ptr(cp))))     \\\n        type_error(#typenam, \"number\", args[0]);                        \\\n    return cp;                                                          \\\n}\n\n#define num_ctor_ctor(typenam, ctype, tag)                              \\\nvalue_t mk_##typenam(fl_##ctype##_t n)                                  \\\n{                                                                       \\\n    value_t cp = cprim(typenam##type, sizeof(fl_##ctype##_t));          \\\n    *(fl_##ctype##_t*)cp_data((cprim_t*)ptr(cp)) = n;                   \\\n    return cp;                                                          \\\n}\n\n#define num_ctor(typenam, ctype, tag) \\\n    num_ctor_init(typenam, ctype, tag) \\\n    num_ctor_ctor(typenam, ctype, tag)\n\nnum_ctor(int8, int8, T_INT8)\nnum_ctor(uint8, uint8, T_UINT8)\nnum_ctor(int16, int16, T_INT16)\nnum_ctor(uint16, uint16, T_UINT16)\nnum_ctor(int32, int32, T_INT32)\nnum_ctor(uint32, uint32, T_UINT32)\nnum_ctor(int64, int64, T_INT64)\nnum_ctor(uint64, uint64, T_UINT64)\nnum_ctor(byte,  uint8, T_UINT8)\nnum_ctor(wchar, int32, T_INT32)\n#ifdef _P64\nnum_ctor(ptrdiff, int64, T_INT64)\nnum_ctor(size, uint64, T_UINT64)\n#else\nnum_ctor(ptrdiff, int32, T_INT32)\nnum_ctor(size, uint32, T_UINT32)\n#endif\nnum_ctor(float, float, T_FLOAT)\nnum_ctor(double, double, T_DOUBLE)\n\nvalue_t size_wrap(size_t sz)\n{\n    if (fits_fixnum(sz))\n        return fixnum(sz);\n    assert(sizeof(void*) == sizeof(size_t));\n    return mk_size(sz);\n}\n\nsize_t tosize(value_t n, char *fname)\n{\n    if (isfixnum(n))\n        return numval(n);\n    if (iscprim(n)) {\n        cprim_t *cp = (cprim_t*)ptr(n);\n        return conv_to_size(cp_data(cp), cp_numtype(cp));\n    }\n    type_error(fname, \"number\", n);\n    return 0;\n}\n\nstatic int isarray(value_t v)\n{\n    return iscvalue(v) && cv_class((cvalue_t*)ptr(v))->eltype != NULL;\n}\n\nstatic size_t predict_arraylen(value_t arg)\n{\n    if (isvector(arg))\n        return vector_size(arg);\n    else if (iscons(arg))\n        return llength(arg);\n    else if (arg == NIL)\n        return 0;\n    if (isarray(arg))\n        return cvalue_arraylen(arg);\n    return 1;\n}\n\nstatic int cvalue_array_init(fltype_t *ft, value_t arg, void *dest)\n{\n    value_t type = ft->type;\n    size_t elsize, i, cnt, sz;\n    fltype_t *eltype = ft->eltype;\n\n    elsize = ft->elsz;\n    cnt = predict_arraylen(arg);\n\n    if (iscons(cdr_(cdr_(type)))) {\n        size_t tc = tosize(car_(cdr_(cdr_(type))), \"array\");\n        if (tc != cnt)\n            lerror(ArgError, \"array: size mismatch\");\n    }\n\n    sz = elsize * cnt;\n\n    if (isvector(arg)) {\n        for(i=0; i < cnt; i++) {\n            cvalue_init(eltype, vector_elt(arg,i), dest);\n            dest = (char *)dest + elsize;\n        }\n        return 0;\n    }\n    else if (iscons(arg) || arg==NIL) {\n        i = 0;\n        while (iscons(arg)) {\n            if (i == cnt) { i++; break; } // trigger error\n            cvalue_init(eltype, car_(arg), dest);\n            i++;\n            dest = (char *)dest + elsize;\n            arg = cdr_(arg);\n        }\n        if (i != cnt)\n            lerror(ArgError, \"array: size mismatch\");\n        return 0;\n    }\n    else if (iscvalue(arg)) {\n        cvalue_t *cv = (cvalue_t*)ptr(arg);\n        if (isarray(arg)) {\n            fltype_t *aet = cv_class(cv)->eltype;\n            if (aet == eltype) {\n                if (cv_len(cv) == sz)\n                    memcpy(dest, cv_data(cv), sz);\n                else\n                    lerror(ArgError, \"array: size mismatch\");\n                return 0;\n            }\n            else {\n                // TODO: initialize array from different type elements\n                lerror(ArgError, \"array: element type mismatch\");\n            }\n        }\n    }\n    if (cnt == 1)\n        cvalue_init(eltype, arg, dest);\n    else\n        type_error(\"array\", \"sequence\", arg);\n    return 0;\n}\n\nvalue_t cvalue_array(value_t *args, u_int32_t nargs)\n{\n    size_t elsize, cnt, sz, i;\n    value_t arg;\n\n    if (nargs < 1)\n        argcount(\"array\", nargs, 1);\n\n    cnt = nargs - 1;\n    fltype_t *type = get_array_type(args[0]);\n    elsize = type->elsz;\n    sz = elsize * cnt;\n\n    value_t cv = cvalue(type, sz);\n    char *dest = (char*)cv_data((cvalue_t*)ptr(cv));\n    FOR_ARGS(i,1,arg,args) {\n        cvalue_init(type->eltype, arg, dest);\n        dest += elsize;\n    }\n    return cv;\n}\n\n// NOTE: v must be an array\nsize_t cvalue_arraylen(value_t v)\n{\n    cvalue_t *cv = (cvalue_t*)ptr(v);\n    return cv_len(cv)/(cv_class(cv)->elsz);\n}\n\n// *palign is an output argument giving the alignment required by type\nsize_t ctype_sizeof(value_t type, int *palign)\n{\n    if (type == int8sym || type == uint8sym || type == bytesym) {\n        *palign = 1;\n        return 1;\n    }\n    if (type == int16sym || type == uint16sym) {\n        *palign = ALIGN2;\n        return 2;\n    }\n    if (type == int32sym || type == uint32sym || type == wcharsym ||\n        type == floatsym) {\n        *palign = ALIGN4;\n        return 4;\n    }\n    if (type == int64sym || type == uint64sym || type == doublesym) {\n        *palign = ALIGN8;\n        return 8;\n    }\n    if (type == ptrdiffsym || type == sizesym) {\n#ifdef _P64\n        *palign = ALIGN8;\n        return 8;\n#else\n        *palign = ALIGN4;\n        return 4;\n#endif\n    }\n    if (iscons(type)) {\n        value_t hed = car_(type);\n        if (hed == pointersym || hed == cfunctionsym) {\n            *palign = ALIGNPTR;\n            return sizeof(void*);\n        }\n        if (hed == arraysym) {\n            value_t t = car(cdr_(type));\n            if (!iscons(cdr_(cdr_(type))))\n                lerror(ArgError, \"sizeof: incomplete type\");\n            value_t n = car_(cdr_(cdr_(type)));\n            size_t sz = tosize(n, \"sizeof\");\n            return sz * ctype_sizeof(t, palign);\n        }\n    }\n    lerror(ArgError, \"sizeof: invalid c type\");\n    return 0;\n}\n\nextern fltype_t *iostreamtype;\n\n// get pointer and size for any plain-old-data value\nvoid to_sized_ptr(value_t v, char *fname, char **pdata, size_t *psz)\n{\n    if (iscvalue(v)) {\n        cvalue_t *pcv = (cvalue_t*)ptr(v);\n        ios_t *x = value2c(ios_t*,v);\n        if (cv_class(pcv) == iostreamtype && (x->bm == bm_mem)) {\n            *pdata = x->buf;\n            *psz = x->size;\n            return;\n        }\n        else if (cv_isPOD(pcv)) {\n            *pdata = (char*)cv_data(pcv);\n            *psz = cv_len(pcv);\n            return;\n        }\n    }\n    else if (iscprim(v)) {\n        cprim_t *pcp = (cprim_t*)ptr(v);\n        *pdata = cp_data(pcp);\n        *psz = cp_class(pcp)->size;\n        return;\n    }\n    type_error(fname, \"plain-old-data\", v);\n}\n\nvalue_t cvalue_sizeof(value_t *args, u_int32_t nargs)\n{\n    argcount(\"sizeof\", nargs, 1);\n    if (issymbol(args[0]) || iscons(args[0])) {\n        int a;\n        return size_wrap(ctype_sizeof(args[0], &a));\n    }\n    size_t n; char *data;\n    to_sized_ptr(args[0], \"sizeof\", &data, &n);\n    return size_wrap(n);\n}\n\nvalue_t cvalue_typeof(value_t *args, u_int32_t nargs)\n{\n    argcount(\"typeof\", nargs, 1);\n    switch(tag(args[0])) {\n    case TAG_CONS: return pairsym;\n    case TAG_NUM1:\n    case TAG_NUM:  return fixnumsym;\n    case TAG_SYM:  return symbolsym;\n    case TAG_VECTOR: return vectorsym;\n    case TAG_FUNCTION:\n        if (args[0] == FL_T || args[0] == FL_F)\n            return booleansym;\n        if (args[0] == NIL)\n            return nullsym;\n        if (args[0] == FL_EOF)\n            return symbol(\"eof-object\");\n        if (isbuiltin(args[0]))\n            return builtinsym;\n        return FUNCTION;\n    }\n    return cv_type((cvalue_t*)ptr(args[0]));\n}\n\nstatic value_t cvalue_relocate(value_t v)\n{\n    size_t nw;\n    cvalue_t *cv = (cvalue_t*)ptr(v);\n    cvalue_t *nv;\n    value_t ncv;\n\n    nw = cv_nwords(cv);\n    nv = (cvalue_t*)alloc_words(nw);\n    memcpy(nv, cv, nw*sizeof(value_t));\n    if (isinlined(cv))\n        nv->data = &nv->_space[0];\n    ncv = tagptr(nv, TAG_CVALUE);\n    fltype_t *t = cv_class(cv);\n    if (t->vtable != NULL && t->vtable->relocate != NULL)\n        t->vtable->relocate(v, ncv);\n    forward(v, ncv);\n    return ncv;\n}\n\nvalue_t cvalue_copy(value_t v)\n{\n    assert(iscvalue(v));\n    PUSH(v);\n    cvalue_t *cv = (cvalue_t*)ptr(v);\n    size_t nw = cv_nwords(cv);\n    cvalue_t *ncv = (cvalue_t*)alloc_words(nw);\n    v = POP(); cv = (cvalue_t*)ptr(v);\n    memcpy(ncv, cv, nw * sizeof(value_t));\n    if (!isinlined(cv)) {\n        size_t len = cv_len(cv);\n        if (cv_isstr(cv)) len++;\n        ncv->data = malloc(len);\n        memcpy(ncv->data, cv_data(cv), len);\n        autorelease(ncv);\n        if (hasparent(cv)) {\n            ncv->type = (fltype_t*)(((uptrint_t)ncv->type) & ~CV_PARENT_BIT);\n            ncv->parent = NIL;\n        }\n    }\n    else {\n        ncv->data = &ncv->_space[0];\n    }\n\n    return tagptr(ncv, TAG_CVALUE);\n}\n\nvalue_t fl_copy(value_t *args, u_int32_t nargs)\n{\n    argcount(\"copy\", nargs, 1);\n    if (iscons(args[0]) || isvector(args[0]))\n        lerror(ArgError, \"copy: argument must be a leaf atom\");\n    if (!iscvalue(args[0]))\n        return args[0];\n    if (!cv_isPOD((cvalue_t*)ptr(args[0])))\n        lerror(ArgError, \"copy: argument must be a plain-old-data type\");\n    return cvalue_copy(args[0]);\n}\n\nvalue_t fl_podp(value_t *args, u_int32_t nargs)\n{\n    argcount(\"plain-old-data?\", nargs, 1);\n    return (iscprim(args[0]) ||\n            (iscvalue(args[0]) && cv_isPOD((cvalue_t*)ptr(args[0])))) ?\n        FL_T : FL_F;\n}\n\nstatic void cvalue_init(fltype_t *type, value_t v, void *dest)\n{\n    cvinitfunc_t f=type->init;\n\n    if (f == NULL)\n        lerror(ArgError, \"c-value: invalid c type\");\n\n    f(type, v, dest);\n}\n\nstatic numerictype_t sym_to_numtype(value_t type)\n{\n    if (type == int8sym)\n        return T_INT8;\n    else if (type == uint8sym || type == bytesym)\n        return T_UINT8;\n    else if (type == int16sym)\n        return T_INT16;\n    else if (type == uint16sym)\n        return T_UINT16;\n#ifdef _P64\n    else if (type == int32sym || type == wcharsym)\n#else\n    else if (type == int32sym || type == wcharsym || type == ptrdiffsym)\n#endif\n        return T_INT32;\n#ifdef _P64\n    else if (type == uint32sym)\n#else\n    else if (type == uint32sym || type == sizesym)\n#endif\n        return T_UINT32;\n#ifdef _P64\n    else if (type == int64sym || type == ptrdiffsym)\n#else\n    else if (type == int64sym)\n#endif\n        return T_INT64;\n#ifdef _P64\n    else if (type == uint64sym || type == sizesym)\n#else\n    else if (type == uint64sym)\n#endif\n        return T_UINT64;\n    else if (type == floatsym)\n        return T_FLOAT;\n    else if (type == doublesym)\n        return T_DOUBLE;\n    return (numerictype_t)N_NUMTYPES;\n}\n\n// (new type . args)\n// this provides (1) a way to allocate values with a shared type for\n// efficiency, (2) a uniform interface for allocating cvalues of any\n// type, including user-defined.\nvalue_t cvalue_new(value_t *args, u_int32_t nargs)\n{\n    if (nargs < 1 || nargs > 2)\n        argcount(\"c-value\", nargs, 2);\n    value_t type = args[0];\n    fltype_t *ft = get_type(type);\n    value_t cv;\n    if (ft->eltype != NULL) {\n        // special case to handle incomplete array types bla[]\n        size_t elsz = ft->elsz;\n        size_t cnt;\n\n        if (iscons(cdr_(cdr_(type))))\n            cnt = tosize(car_(cdr_(cdr_(type))), \"array\");\n        else if (nargs == 2)\n            cnt = predict_arraylen(args[1]);\n        else\n            cnt = 0;\n        cv = cvalue(ft, elsz * cnt);\n        if (nargs == 2)\n            cvalue_array_init(ft, args[1], cv_data((cvalue_t*)ptr(cv)));\n    }\n    else {\n        cv = cvalue(ft, ft->size);\n        if (nargs == 2)\n            cvalue_init(ft, args[1], cptr(cv));\n    }\n    return cv;\n}\n\n// NOTE: this only compares lexicographically; it ignores numeric formats\nvalue_t cvalue_compare(value_t a, value_t b)\n{\n    cvalue_t *ca = (cvalue_t*)ptr(a);\n    cvalue_t *cb = (cvalue_t*)ptr(b);\n    char *adata = (char*)cv_data(ca);\n    char *bdata = (char*)cv_data(cb);\n    size_t asz = cv_len(ca);\n    size_t bsz = cv_len(cb);\n    size_t minsz = asz < bsz ? asz : bsz;\n    int diff = memcmp(adata, bdata, minsz);\n    if (diff == 0) {\n        if (asz > bsz)\n            return fixnum(1);\n        else if (asz < bsz)\n            return fixnum(-1);\n    }\n    return fixnum(diff);\n}\n\nstatic void check_addr_args(char *fname, value_t arr, value_t ind,\n                            char **data, size_t *index)\n{\n    size_t numel;\n    cvalue_t *cv = (cvalue_t*)ptr(arr);\n    *data = (char*)cv_data(cv);\n    numel = cv_len(cv)/(cv_class(cv)->elsz);\n    *index = tosize(ind, fname);\n    if (*index >= numel)\n        bounds_error(fname, arr, ind);\n}\n\nstatic value_t cvalue_array_aref(value_t *args)\n{\n    char *data; size_t index;\n    fltype_t *eltype = cv_class((cvalue_t*)ptr(args[0]))->eltype;\n    value_t el = 0;\n    numerictype_t nt = eltype->numtype;\n    if (nt >= T_INT32)\n        el = cvalue(eltype, eltype->size);\n    check_addr_args(\"aref\", args[0], args[1], &data, &index);\n    if (nt < T_INT32) {\n        if (nt == T_INT8)\n            return fixnum((int8_t)data[index]);\n        else if (nt == T_UINT8)\n            return fixnum((uint8_t)data[index]);\n        else if (nt == T_INT16)\n            return fixnum(((int16_t*)data)[index]);\n        return fixnum(((uint16_t*)data)[index]);\n    }\n    char *dest = (char*)cptr(el);\n    size_t sz = eltype->size;\n    if (sz == 1)\n        *dest = data[index];\n    else if (sz == 2)\n        *(int16_t*)dest = ((int16_t*)data)[index];\n    else if (sz == 4)\n        *(int32_t*)dest = ((int32_t*)data)[index];\n    else if (sz == 8)\n        *(int64_t*)dest = ((int64_t*)data)[index];\n    else\n        memcpy(dest, data + index*sz, sz);\n    return el;\n}\n\nstatic value_t cvalue_array_aset(value_t *args)\n{\n    char *data; size_t index;\n    fltype_t *eltype = cv_class((cvalue_t*)ptr(args[0]))->eltype;\n    check_addr_args(\"aset!\", args[0], args[1], &data, &index);\n    char *dest = data + index*eltype->size;\n    cvalue_init(eltype, args[2], dest);\n    return args[2];\n}\n\nvalue_t fl_builtin(value_t *args, u_int32_t nargs)\n{\n    argcount(\"builtin\", nargs, 1);\n    symbol_t *name = tosymbol(args[0], \"builtin\");\n    cvalue_t *cv;\n    if (ismanaged(args[0]) || (cv=(cvalue_t*)name->dlcache) == NULL) {\n        lerrorf(ArgError, \"builtin: function %s not found\", name->name);\n    }\n    return tagptr(cv, TAG_CVALUE);\n}\n\nvalue_t cbuiltin(char *name, builtin_t f)\n{\n    cvalue_t *cv = (cvalue_t*)malloc(CVALUE_NWORDS * sizeof(value_t));\n    cv->type = builtintype;\n    cv->data = &cv->_space[0];\n    cv->len = sizeof(value_t);\n    *(void**)cv->data = (void*)f;\n\n    value_t sym = symbol(name);\n    ((symbol_t*)ptr(sym))->dlcache = cv;\n    ptrhash_put(&reverse_dlsym_lookup_table, cv, (void*)sym);\n\n    return tagptr(cv, TAG_CVALUE);\n}\n\nstatic value_t fl_logand(value_t *args, u_int32_t nargs);\nstatic value_t fl_logior(value_t *args, u_int32_t nargs);\nstatic value_t fl_logxor(value_t *args, u_int32_t nargs);\nstatic value_t fl_lognot(value_t *args, u_int32_t nargs);\nstatic value_t fl_ash(value_t *args, u_int32_t nargs);\n\nstatic builtinspec_t cvalues_builtin_info[] = {\n    { \"c-value\", cvalue_new },\n    { \"typeof\", cvalue_typeof },\n    { \"sizeof\", cvalue_sizeof },\n    { \"builtin\", fl_builtin },\n    { \"copy\", fl_copy },\n    { \"plain-old-data?\", fl_podp },\n\n    { \"logand\", fl_logand },\n    { \"logior\", fl_logior },\n    { \"logxor\", fl_logxor },\n    { \"lognot\", fl_lognot },\n    { \"ash\", fl_ash },\n    // todo: autorelease\n    { NULL, NULL }\n};\n\n#define cv_intern(tok) tok##sym = symbol(#tok)\n#define ctor_cv_intern(tok) \\\n    cv_intern(tok);set(tok##sym, cbuiltin(#tok, cvalue_##tok))\n\n#define mk_primtype(name) \\\n  name##type=get_type(name##sym);name##type->init = &cvalue_##name##_init\n\n#define mk_primtype_(name,ctype) \\\n  name##type=get_type(name##sym);name##type->init = &cvalue_##ctype##_init\n\nstruct prim_int16{ char a; int16_t i; };\nstruct prim_int32{ char a; int32_t i; };\nstruct prim_int64{ char a; int64_t i; };\nstruct prim_ptr{ char a;  void   *i; };\n\nstatic void cvalues_init(void)\n{\n    htable_new(&TypeTable, 256);\n    htable_new(&reverse_dlsym_lookup_table, 256);\n\n    // compute struct field alignment required for primitives\n    ALIGN2   = sizeof(struct prim_int16) - 2;\n    ALIGN4   = sizeof(struct prim_int32) - 4;\n    ALIGN8   = sizeof(struct prim_int64) - 8;\n    ALIGNPTR = sizeof(struct prim_ptr) - sizeof(void*);\n\n    builtintype = define_opaque_type(builtinsym, sizeof(builtin_t), NULL, NULL);\n\n    ctor_cv_intern(int8);\n    ctor_cv_intern(uint8);\n    ctor_cv_intern(int16);\n    ctor_cv_intern(uint16);\n    ctor_cv_intern(int32);\n    ctor_cv_intern(uint32);\n    ctor_cv_intern(int64);\n    ctor_cv_intern(uint64);\n    ctor_cv_intern(byte);\n    ctor_cv_intern(wchar);\n    ctor_cv_intern(ptrdiff);\n    ctor_cv_intern(size);\n    ctor_cv_intern(float);\n    ctor_cv_intern(double);\n\n    ctor_cv_intern(array);\n    cv_intern(pointer);\n    cv_intern(void);\n    cfunctionsym = symbol(\"c-function\");\n\n    assign_global_builtins(cvalues_builtin_info);\n\n    stringtypesym = symbol(\"*string-type*\");\n    setc(stringtypesym, fl_list2(arraysym, bytesym));\n\n    wcstringtypesym = symbol(\"*wcstring-type*\");\n    setc(wcstringtypesym, fl_list2(arraysym, wcharsym));\n\n    mk_primtype(int8);\n    mk_primtype(uint8);\n    mk_primtype(int16);\n    mk_primtype(uint16);\n    mk_primtype(int32);\n    mk_primtype(uint32);\n    mk_primtype(int64);\n    mk_primtype(uint64);\n#ifdef _P64\n    mk_primtype_(ptrdiff,int64);\n    mk_primtype_(size,uint64);\n#else\n    mk_primtype_(ptrdiff,int32);\n    mk_primtype_(size,uint32);\n#endif\n    mk_primtype_(byte,uint8);\n    mk_primtype_(wchar,int32);\n    mk_primtype(float);\n    mk_primtype(double);\n\n    stringtype = get_type(symbol_value(stringtypesym));\n    wcstringtype = get_type(symbol_value(wcstringtypesym));\n\n    emptystringsym = symbol(\"*empty-string*\");\n    setc(emptystringsym, cvalue_static_cstring(\"\"));\n}\n\n#define RETURN_NUM_AS(var, type) return(mk_##type((fl_##type##_t)var))\n\nvalue_t return_from_uint64(uint64_t Uaccum)\n{\n    if (fits_fixnum(Uaccum)) {\n        return fixnum((fixnum_t)Uaccum);\n    }\n    if (Uaccum > (uint64_t)S64_MAX) {\n        RETURN_NUM_AS(Uaccum, uint64);\n    }\n    else if (Uaccum > (uint64_t)INT_MAX) {\n        RETURN_NUM_AS(Uaccum, int64);\n    }\n    RETURN_NUM_AS(Uaccum, int32);\n}\n\nvalue_t return_from_int64(int64_t Saccum)\n{\n    if (fits_fixnum(Saccum)) {\n        return fixnum((fixnum_t)Saccum);\n    }\n    if (Saccum > (int64_t)INT_MAX || Saccum < (int64_t)INT_MIN) {\n        RETURN_NUM_AS(Saccum, int64);\n    }\n    RETURN_NUM_AS(Saccum, int32);\n}\n\nstatic value_t fl_add_any(value_t *args, u_int32_t nargs, fixnum_t carryIn)\n{\n    uint64_t Uaccum=0;\n    int64_t Saccum = carryIn;\n    double Faccum=0;\n    uint32_t i;\n    value_t arg=NIL;\n\n    FOR_ARGS(i,0,arg,args) {\n        if (isfixnum(arg)) {\n            Saccum += numval(arg);\n            continue;\n        }\n        else if (iscprim(arg)) {\n            cprim_t *cp = (cprim_t*)ptr(arg);\n            void *a = cp_data(cp);\n            int64_t i64;\n            switch(cp_numtype(cp)) {\n            case T_INT8:   Saccum += *(int8_t*)a; break;\n            case T_UINT8:  Saccum += *(uint8_t*)a; break;\n            case T_INT16:  Saccum += *(int16_t*)a; break;\n            case T_UINT16: Saccum += *(uint16_t*)a; break;\n            case T_INT32:  Saccum += *(int32_t*)a; break;\n            case T_UINT32: Saccum += *(uint32_t*)a; break;\n            case T_INT64:\n                i64 = *(int64_t*)a;\n                if (i64 > 0)\n                    Uaccum += (uint64_t)i64;\n                else\n                    Saccum += i64;\n                break;\n            case T_UINT64: Uaccum += *(uint64_t*)a; break;\n            case T_FLOAT:  Faccum += *(float*)a; break;\n            case T_DOUBLE: Faccum += *(double*)a; break;\n            default:\n                goto add_type_error;\n            }\n            continue;\n        }\n    add_type_error:\n        type_error(\"+\", \"number\", arg);\n    }\n    if (Faccum != 0) {\n        Faccum += Uaccum;\n        Faccum += Saccum;\n        return mk_double(Faccum);\n    }\n    else if (Saccum < 0) {\n        uint64_t negpart = (uint64_t)(-Saccum);\n        if (negpart > Uaccum) {\n            Saccum += (int64_t)Uaccum;\n            // return value in Saccum\n            if (Saccum >= INT_MIN) {\n                if (fits_fixnum(Saccum)) {\n                    return fixnum((fixnum_t)Saccum);\n                }\n                RETURN_NUM_AS(Saccum, int32);\n            }\n            RETURN_NUM_AS(Saccum, int64);\n        }\n        Uaccum -= negpart;\n    }\n    else {\n        Uaccum += (uint64_t)Saccum;\n    }\n    // return value in Uaccum\n    return return_from_uint64(Uaccum);\n}\n\nstatic value_t fl_neg(value_t n)\n{\n    if (isfixnum(n)) {\n        return fixnum(-numval(n));\n    }\n    else if (iscprim(n)) {\n        cprim_t *cp = (cprim_t*)ptr(n);\n        void *a = cp_data(cp);\n        uint32_t ui32;\n        int32_t i32;\n        int64_t i64;\n        switch(cp_numtype(cp)) {\n        case T_INT8:   return fixnum(-(int32_t)*(int8_t*)a);\n        case T_UINT8:  return fixnum(-(int32_t)*(uint8_t*)a);\n        case T_INT16:  return fixnum(-(int32_t)*(int16_t*)a);\n        case T_UINT16: return fixnum(-(int32_t)*(uint16_t*)a);\n        case T_INT32:\n            i32 = *(int32_t*)a;\n            if (i32 == (int32_t)BIT31)\n                return mk_uint32((uint32_t)BIT31);\n            return mk_int32(-i32);\n        case T_UINT32:\n            ui32 = *(uint32_t*)a;\n            if (ui32 <= ((uint32_t)INT_MAX)+1) return mk_int32(-(int32_t)ui32);\n            return mk_int64(-(int64_t)ui32);\n        case T_INT64:\n            i64 = *(int64_t*)a;\n            if (i64 == (int64_t)BIT63)\n                return mk_uint64((uint64_t)BIT63);\n            return mk_int64(-i64);\n        case T_UINT64: return mk_int64(-(int64_t)*(uint64_t*)a);\n        case T_FLOAT:  return mk_float(-*(float*)a);\n        case T_DOUBLE: return mk_double(-*(double*)a);\n            break;\n        }\n    }\n    type_error(\"-\", \"number\", n);\n}\n\nstatic value_t fl_mul_any(value_t *args, u_int32_t nargs, int64_t Saccum)\n{\n    uint64_t Uaccum=1;\n    double Faccum=1;\n    uint32_t i;\n    value_t arg=NIL;\n\n    FOR_ARGS(i,0,arg,args) {\n        if (isfixnum(arg)) {\n            Saccum *= numval(arg);\n            continue;\n        }\n        else if (iscprim(arg)) {\n            cprim_t *cp = (cprim_t*)ptr(arg);\n            void *a = cp_data(cp);\n            int64_t i64;\n            switch(cp_numtype(cp)) {\n            case T_INT8:   Saccum *= *(int8_t*)a; break;\n            case T_UINT8:  Saccum *= *(uint8_t*)a; break;\n            case T_INT16:  Saccum *= *(int16_t*)a; break;\n            case T_UINT16: Saccum *= *(uint16_t*)a; break;\n            case T_INT32:  Saccum *= *(int32_t*)a; break;\n            case T_UINT32: Saccum *= *(uint32_t*)a; break;\n            case T_INT64:\n                i64 = *(int64_t*)a;\n                if (i64 > 0)\n                    Uaccum *= (uint64_t)i64;\n                else\n                    Saccum *= i64;\n                break;\n            case T_UINT64: Uaccum *= *(uint64_t*)a; break;\n            case T_FLOAT:  Faccum *= *(float*)a; break;\n            case T_DOUBLE: Faccum *= *(double*)a; break;\n            default:\n                goto mul_type_error;\n            }\n            continue;\n        }\n    mul_type_error:\n        type_error(\"*\", \"number\", arg);\n    }\n    if (Faccum != 1) {\n        Faccum *= Uaccum;\n        Faccum *= Saccum;\n        return mk_double(Faccum);\n    }\n    else if (Saccum < 0) {\n        Saccum *= (int64_t)Uaccum;\n        if (Saccum >= INT_MIN) {\n            if (fits_fixnum(Saccum)) {\n                return fixnum((fixnum_t)Saccum);\n            }\n            RETURN_NUM_AS(Saccum, int32);\n        }\n        RETURN_NUM_AS(Saccum, int64);\n    }\n    else {\n        Uaccum *= (uint64_t)Saccum;\n    }\n    return return_from_uint64(Uaccum);\n}\n\nstatic int num_to_ptr(value_t a, fixnum_t *pi, numerictype_t *pt, void **pp)\n{\n    cprim_t *cp;\n    if (isfixnum(a)) {\n        *pi = numval(a);\n        *pp = pi;\n        *pt = T_FIXNUM;\n    }\n    else if (iscprim(a)) {\n        cp = (cprim_t*)ptr(a);\n        *pp = cp_data(cp);\n        *pt = cp_numtype(cp);\n    }\n    else {\n        return 0;\n    }\n    return 1;\n}\n\n/*\n  returns -1, 0, or 1 based on ordering of a and b\n  eq: consider equality only, returning 0 or nonzero\n  eqnans: NaNs considered equal to each other\n          -0.0 not considered equal to 0.0\n          inexact not considered equal to exact\n  fname: if not NULL, throws type errors, else returns 2 for type errors\n*/\nint numeric_compare(value_t a, value_t b, int eq, int eqnans, char *fname)\n{\n    int_t ai, bi;\n    numerictype_t ta, tb;\n    void *aptr, *bptr;\n\n    if (bothfixnums(a,b)) {\n        if (a==b) return 0;\n        if (numval(a) < numval(b)) return -1;\n        return 1;\n    }\n    if (!num_to_ptr(a, &ai, &ta, &aptr)) {\n        if (fname) type_error(fname, \"number\", a); else return 2;\n    }\n    if (!num_to_ptr(b, &bi, &tb, &bptr)) {\n        if (fname) type_error(fname, \"number\", b); else return 2;\n    }\n    if (eq && eqnans && ((ta >= T_FLOAT) != (tb >= T_FLOAT)))\n        return 1;\n    if (cmp_eq(aptr, ta, bptr, tb, eqnans))\n        return 0;\n    if (eq) return 1;\n    if (cmp_lt(aptr, ta, bptr, tb))\n        return -1;\n    return 1;\n}\n\n#if defined(_OS_WINDOWS_)\n__declspec(noreturn) static void DivideByZeroError();\n#else\nstatic void DivideByZeroError() __attribute__ ((__noreturn__));\n#endif\n\nstatic void DivideByZeroError(void)\n{\n    lerror(DivideError, \"/: division by zero\");\n}\n\nstatic value_t fl_div2(value_t a, value_t b)\n{\n    double da, db;\n    int_t ai, bi;\n    numerictype_t ta, tb;\n    void *aptr, *bptr;\n\n    if (!num_to_ptr(a, &ai, &ta, &aptr))\n        type_error(\"/\", \"number\", a);\n    if (!num_to_ptr(b, &bi, &tb, &bptr))\n        type_error(\"/\", \"number\", b);\n\n    da = conv_to_double(aptr, ta);\n    db = conv_to_double(bptr, tb);\n\n    if (db == 0 && tb < T_FLOAT)  // exact 0\n        DivideByZeroError();\n\n    da = da/db;\n\n    if (ta < T_FLOAT && tb < T_FLOAT && (double)(int64_t)da == da)\n        return return_from_int64((int64_t)da);\n    return mk_double(da);\n}\n\nstatic value_t fl_idiv2(value_t a, value_t b)\n{\n    int_t ai, bi;\n    numerictype_t ta, tb;\n    void *aptr, *bptr;\n    int64_t a64, b64;\n\n    if (!num_to_ptr(a, &ai, &ta, &aptr))\n        type_error(\"div0\", \"number\", a);\n    if (!num_to_ptr(b, &bi, &tb, &bptr))\n        type_error(\"div0\", \"number\", b);\n\n    if (ta == T_UINT64) {\n        if (tb == T_UINT64) {\n            if (*(uint64_t*)bptr == 0) goto div_error;\n            return return_from_uint64(*(uint64_t*)aptr / *(uint64_t*)bptr);\n        }\n        b64 = conv_to_int64(bptr, tb);\n        if (b64 < 0) {\n            return return_from_int64(-(int64_t)(*(uint64_t*)aptr /\n                                                (uint64_t)(-b64)));\n        }\n        if (b64 == 0)\n            goto div_error;\n        return return_from_uint64(*(uint64_t*)aptr / (uint64_t)b64);\n    }\n    if (tb == T_UINT64) {\n        if (*(uint64_t*)bptr == 0) goto div_error;\n        a64 = conv_to_int64(aptr, ta);\n        if (a64 < 0) {\n            return return_from_int64(-((int64_t)((uint64_t)(-a64) /\n                                                 *(uint64_t*)bptr)));\n        }\n        return return_from_uint64((uint64_t)a64 / *(uint64_t*)bptr);\n    }\n\n    b64 = conv_to_int64(bptr, tb);\n    if (b64 == 0) goto div_error;\n\n    return return_from_int64(conv_to_int64(aptr, ta) / b64);\n div_error:\n    DivideByZeroError();\n}\n\nstatic value_t fl_bitwise_op(value_t a, value_t b, int opcode, char *fname)\n{\n    int_t ai, bi;\n    numerictype_t ta, tb, itmp;\n    void *aptr=NULL, *bptr=NULL, *ptmp;\n    int64_t b64;\n\n    if (!num_to_ptr(a, &ai, &ta, &aptr) || ta >= T_FLOAT)\n        type_error(fname, \"integer\", a);\n    if (!num_to_ptr(b, &bi, &tb, &bptr) || tb >= T_FLOAT)\n        type_error(fname, \"integer\", b);\n\n    if (ta < tb) {\n        itmp = ta; ta = tb; tb = itmp;\n        ptmp = aptr; aptr = bptr; bptr = ptmp;\n    }\n    // now a's type is larger than or same as b's\n    b64 = conv_to_int64(bptr, tb);\n    switch (opcode) {\n    case 0:\n    switch (ta) {\n    case T_INT8:   return fixnum(   *(int8_t *)aptr  & (int8_t  )b64);\n    case T_UINT8:  return fixnum(   *(uint8_t *)aptr & (uint8_t )b64);\n    case T_INT16:  return fixnum(   *(int16_t*)aptr  & (int16_t )b64);\n    case T_UINT16: return fixnum(   *(uint16_t*)aptr & (uint16_t)b64);\n    case T_INT32:  return mk_int32( *(int32_t*)aptr  & (int32_t )b64);\n    case T_UINT32: return mk_uint32(*(uint32_t*)aptr & (uint32_t)b64);\n    case T_INT64:  return mk_int64( *(int64_t*)aptr  & (int64_t )b64);\n    case T_UINT64: return mk_uint64(*(uint64_t*)aptr & (uint64_t)b64);\n    case T_FLOAT:\n    case T_DOUBLE: assert(0);\n    }\n    break;\n    case 1:\n    switch (ta) {\n    case T_INT8:   return fixnum(   *(int8_t *)aptr  | (int8_t  )b64);\n    case T_UINT8:  return fixnum(   *(uint8_t *)aptr | (uint8_t )b64);\n    case T_INT16:  return fixnum(   *(int16_t*)aptr  | (int16_t )b64);\n    case T_UINT16: return fixnum(   *(uint16_t*)aptr | (uint16_t)b64);\n    case T_INT32:  return mk_int32( *(int32_t*)aptr  | (int32_t )b64);\n    case T_UINT32: return mk_uint32(*(uint32_t*)aptr | (uint32_t)b64);\n    case T_INT64:  return mk_int64( *(int64_t*)aptr  | (int64_t )b64);\n    case T_UINT64: return mk_uint64(*(uint64_t*)aptr | (uint64_t)b64);\n    case T_FLOAT:\n    case T_DOUBLE: assert(0);\n    }\n    break;\n    case 2:\n    switch (ta) {\n    case T_INT8:   return fixnum(   *(int8_t *)aptr  ^ (int8_t  )b64);\n    case T_UINT8:  return fixnum(   *(uint8_t *)aptr ^ (uint8_t )b64);\n    case T_INT16:  return fixnum(   *(int16_t*)aptr  ^ (int16_t )b64);\n    case T_UINT16: return fixnum(   *(uint16_t*)aptr ^ (uint16_t)b64);\n    case T_INT32:  return mk_int32( *(int32_t*)aptr  ^ (int32_t )b64);\n    case T_UINT32: return mk_uint32(*(uint32_t*)aptr ^ (uint32_t)b64);\n    case T_INT64:  return mk_int64( *(int64_t*)aptr  ^ (int64_t )b64);\n    case T_UINT64: return mk_uint64(*(uint64_t*)aptr ^ (uint64_t)b64);\n    case T_FLOAT:\n    case T_DOUBLE: assert(0);\n    }\n    }\n    assert(0);\n    return NIL;\n}\n\nstatic value_t fl_logand(value_t *args, u_int32_t nargs)\n{\n    value_t v, e;\n    int i;\n    if (nargs == 0)\n        return fixnum(-1);\n    v = args[0];\n    FOR_ARGS(i,1,e,args) {\n        if (bothfixnums(v, e))\n            v = v & e;\n        else\n            v = fl_bitwise_op(v, e, 0, \"logand\");\n    }\n    return v;\n}\n\nstatic value_t fl_logior(value_t *args, u_int32_t nargs)\n{\n    value_t v, e;\n    int i;\n    if (nargs == 0)\n        return fixnum(0);\n    v = args[0];\n    FOR_ARGS(i,1,e,args) {\n        if (bothfixnums(v, e))\n            v = v | e;\n        else\n            v = fl_bitwise_op(v, e, 1, \"logior\");\n    }\n    return v;\n}\n\nstatic value_t fl_logxor(value_t *args, u_int32_t nargs)\n{\n    value_t v, e;\n    int i;\n    if (nargs == 0)\n        return fixnum(0);\n    v = args[0];\n    FOR_ARGS(i,1,e,args) {\n        if (bothfixnums(v, e))\n            v = fixnum(numval(v) ^ numval(e));\n        else\n            v = fl_bitwise_op(v, e, 2, \"logxor\");\n    }\n    return v;\n}\n\nstatic value_t fl_lognot(value_t *args, u_int32_t nargs)\n{\n    argcount(\"lognot\", nargs, 1);\n    value_t a = args[0];\n    if (isfixnum(a))\n        return fixnum(~numval(a));\n    cprim_t *cp;\n    int ta;\n    void *aptr;\n\n    if (iscprim(a)) {\n        cp = (cprim_t*)ptr(a);\n        ta = cp_numtype(cp);\n        aptr = cp_data(cp);\n        switch (ta) {\n        case T_INT8:   return fixnum(~*(int8_t *)aptr);\n        case T_UINT8:  return fixnum(~*(uint8_t *)aptr);\n        case T_INT16:  return fixnum(~*(int16_t *)aptr);\n        case T_UINT16: return fixnum(~*(uint16_t*)aptr);\n        case T_INT32:  return mk_int32(~*(int32_t *)aptr);\n        case T_UINT32: return mk_uint32(~*(uint32_t*)aptr);\n        case T_INT64:  return mk_int64(~*(int64_t *)aptr);\n        case T_UINT64: return mk_uint64(~*(uint64_t*)aptr);\n        }\n    }\n    type_error(\"lognot\", \"integer\", a);\n}\n\nstatic value_t fl_ash(value_t *args, u_int32_t nargs)\n{\n    fixnum_t n;\n    int64_t accum;\n    argcount(\"ash\", nargs, 2);\n    value_t a = args[0];\n    n = tofixnum(args[1], \"ash\");\n    if (isfixnum(a)) {\n        if (n <= 0)\n            return fixnum(numval(a)>>(-n));\n        accum = ((int64_t)numval(a))<<n;\n        if (fits_fixnum(accum))\n            return fixnum(accum);\n        else\n            return return_from_int64(accum);\n    }\n    cprim_t *cp;\n    int ta;\n    void *aptr;\n    if (iscprim(a)) {\n        if (n == 0) return a;\n        cp = (cprim_t*)ptr(a);\n        ta = cp_numtype(cp);\n        aptr = cp_data(cp);\n        if (n < 0) {\n            n = -n;\n            switch (ta) {\n            case T_INT8:   return fixnum((*(int8_t *)aptr) >> n);\n            case T_UINT8:  return fixnum((*(uint8_t *)aptr) >> n);\n            case T_INT16:  return fixnum((*(int16_t *)aptr) >> n);\n            case T_UINT16: return fixnum((*(uint16_t*)aptr) >> n);\n            case T_INT32:  return mk_int32((*(int32_t *)aptr) >> n);\n            case T_UINT32: return mk_uint32((*(uint32_t*)aptr) >> n);\n            case T_INT64:  return mk_int64((*(int64_t *)aptr) >> n);\n            case T_UINT64: return mk_uint64((*(uint64_t*)aptr) >> n);\n            }\n        }\n        else {\n            if (ta == T_UINT64)\n                return return_from_uint64((*(uint64_t*)aptr)<<n);\n            else if (ta < T_FLOAT) {\n                int64_t i64 = conv_to_int64(aptr, (numerictype_t)ta);\n                return return_from_int64(i64<<n);\n            }\n        }\n    }\n    type_error(\"ash\", \"integer\", a);\n    return NIL;\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/searchindex.js": "Search.setIndex({envversion:46,filenames:[\"devdocs/C\",\"devdocs/ast\",\"devdocs/backtraces\",\"devdocs/cartesian\",\"devdocs/debuggingtips\",\"devdocs/eval\",\"devdocs/init\",\"devdocs/julia\",\"devdocs/llvm\",\"devdocs/meta\",\"devdocs/object\",\"devdocs/promote-op\",\"devdocs/reflection\",\"devdocs/stdio\",\"devdocs/subarrays\",\"devdocs/sysimg\",\"devdocs/types\",\"devdocs/valgrind\",\"index\",\"latex\",\"manual/arrays\",\"manual/calling-c-and-fortran-code\",\"manual/complex-and-rational-numbers\",\"manual/constructors\",\"manual/control-flow\",\"manual/conversion-and-promotion\",\"manual/dates\",\"manual/documentation\",\"manual/embedding\",\"manual/faq\",\"manual/functions\",\"manual/getting-started\",\"manual/index\",\"manual/integers-and-floating-point-numbers\",\"manual/interacting-with-julia\",\"manual/interfaces\",\"manual/introduction\",\"manual/linear-algebra\",\"manual/mathematical-operations\",\"manual/metaprogramming\",\"manual/methods\",\"manual/modules\",\"manual/networking-and-streams\",\"manual/noteworthy-differences\",\"manual/packages\",\"manual/parallel-computing\",\"manual/performance-tips\",\"manual/profile\",\"manual/running-external-programs\",\"manual/strings\",\"manual/style-guide\",\"manual/types\",\"manual/unicode-input\",\"manual/variables\",\"manual/variables-and-scoping\",\"manual/workflow-tips\",\"stdlib/arrays\",\"stdlib/base\",\"stdlib/c\",\"stdlib/collections\",\"stdlib/constants\",\"stdlib/dates\",\"stdlib/file\",\"stdlib/index\",\"stdlib/io-network\",\"stdlib/libc\",\"stdlib/libdl\",\"stdlib/linalg\",\"stdlib/math\",\"stdlib/numbers\",\"stdlib/parallel\",\"stdlib/pkg\",\"stdlib/profile\",\"stdlib/punctuation\",\"stdlib/sort\",\"stdlib/strings\",\"stdlib/test\"],objects:{\"\":{\"@__doc__\":[27,4,1,\"\"],Dates:[61,3,0,\"-\"],Libc:[65,3,0,\"-\"],Libdl:[66,3,0,\"-\"],Profile:[72,3,0,\"-\"],build_sysimg:[15,4,1,\"\"]},\"Base.\":{\"!=\":[68,4,1,\"\"],\"*\":[68,4,1,\"\"],\"+\":[68,4,1,\"\"],\"-\":[68,4,1,\"\"],\"/\":[68,4,1,\"\"],\"<\":[68,4,1,\"\"],\"<=\":[68,4,1,\"\"],\"==\":[68,4,1,\"\"],\">\":[68,4,1,\"\"],\">=\":[68,4,1,\"\"],\"\\\\\":[68,4,1,\"\"],\"\\u2260\":[68,4,1,\"\"],\"\\u2264\":[68,4,1,\"\"],\"\\u2265\":[68,4,1,\"\"],\"^\":[68,4,1,\"\"]},\"Base.Base\":{compilecache:[57,4,1,\"\"],linearindexing:[56,4,1,\"\"],process_messages:[70,4,1,\"\"],summarysize:[57,4,1,\"\"]},\"Base.Collections\":{\"dequeue!\":[59,4,1,\"\"],\"enqueue!\":[59,4,1,\"\"],\"heapify!\":[59,4,1,\"\"],\"heappop!\":[59,4,1,\"\"],\"heappush!\":[59,4,1,\"\"],PriorityQueue:[59,4,1,\"\"],heapify:[59,4,1,\"\"],isheap:[59,4,1,\"\"],peek:[59,4,1,\"\"]},\"Base.FFTW\":{\"plan_r2r!\":[68,4,1,\"\"],\"r2r!\":[68,4,1,\"\"],plan_r2r:[68,4,1,\"\"],r2r:[68,4,1,\"\"]},\"Base.LinAlg\":{BLAS:[67,3,0,\"-\"],LAPACK:[67,3,0,\"-\"]},\"Base.LinAlg.BLAS\":{\"axpy!\":[67,4,1,\"\"],\"blascopy!\":[67,4,1,\"\"],\"gbmv!\":[67,4,1,\"\"],\"gemm!\":[67,4,1,\"\"],\"gemv!\":[67,4,1,\"\"],\"ger!\":[67,4,1,\"\"],\"her!\":[67,4,1,\"\"],\"herk!\":[67,4,1,\"\"],\"sbmv!\":[67,4,1,\"\"],\"scal!\":[67,4,1,\"\"],\"symm!\":[67,4,1,\"\"],\"symv!\":[67,4,1,\"\"],\"syr!\":[67,4,1,\"\"],\"syrk!\":[67,4,1,\"\"],\"trmm!\":[67,4,1,\"\"],\"trmv!\":[67,4,1,\"\"],\"trsm!\":[67,4,1,\"\"],\"trsv!\":[67,4,1,\"\"],I:[67,5,1,\"\"],asum:[67,4,1,\"\"],blas_set_num_threads:[67,4,1,\"\"],dot:[67,4,1,\"\"],dotc:[67,4,1,\"\"],dotu:[67,4,1,\"\"],gbmv:[67,4,1,\"\"],gemm:[67,4,1,\"\"],gemv:[67,4,1,\"\"],herk:[67,4,1,\"\"],nrm2:[67,4,1,\"\"],sbmv:[67,4,1,\"\"],scal:[67,4,1,\"\"],symm:[67,4,1,\"\"],symv:[67,4,1,\"\"],syrk:[67,4,1,\"\"],trmm:[67,4,1,\"\"],trmv:[67,4,1,\"\"],trsm:[67,4,1,\"\"],trsv:[67,4,1,\"\"]},\"Base.LinAlg.LAPACK\":{\"bdsdc!\":[67,4,1,\"\"],\"bdsqr!\":[67,4,1,\"\"],\"gbtrf!\":[67,4,1,\"\"],\"gbtrs!\":[67,4,1,\"\"],\"gebak!\":[67,4,1,\"\"],\"gebal!\":[67,4,1,\"\"],\"gebrd!\":[67,4,1,\"\"],\"gecon!\":[67,4,1,\"\"],\"gees!\":[67,4,1,\"\"],\"geev!\":[67,4,1,\"\"],\"geevx!\":[67,4,1,\"\"],\"gehrd!\":[67,4,1,\"\"],\"gelqf!\":[67,4,1,\"\"],\"gels!\":[67,4,1,\"\"],\"gelsd!\":[67,4,1,\"\"],\"gelsy!\":[67,4,1,\"\"],\"gemqrt!\":[67,4,1,\"\"],\"geqlf!\":[67,4,1,\"\"],\"geqp3!\":[67,4,1,\"\"],\"geqrf!\":[67,4,1,\"\"],\"geqrt!\":[67,4,1,\"\"],\"geqrt3!\":[67,4,1,\"\"],\"gerqf!\":[67,4,1,\"\"],\"gesdd!\":[67,4,1,\"\"],\"gesv!\":[67,4,1,\"\"],\"gesvd!\":[67,4,1,\"\"],\"gesvx!\":[67,4,1,\"\"],\"getrf!\":[67,4,1,\"\"],\"getri!\":[67,4,1,\"\"],\"getrs!\":[67,4,1,\"\"],\"gges!\":[67,4,1,\"\"],\"ggev!\":[67,4,1,\"\"],\"gglse!\":[67,4,1,\"\"],\"ggsvd!\":[67,4,1,\"\"],\"gtsv!\":[67,4,1,\"\"],\"gttrf!\":[67,4,1,\"\"],\"gttrs!\":[67,4,1,\"\"],\"hesv!\":[67,4,1,\"\"],\"hetrf!\":[67,4,1,\"\"],\"hetri!\":[67,4,1,\"\"],\"hetrs!\":[67,4,1,\"\"],\"orghr!\":[67,4,1,\"\"],\"orglq!\":[67,4,1,\"\"],\"orgqr!\":[67,4,1,\"\"],\"ormlq!\":[67,4,1,\"\"],\"ormqr!\":[67,4,1,\"\"],\"ormrz!\":[67,4,1,\"\"],\"posv!\":[67,4,1,\"\"],\"potrf!\":[67,4,1,\"\"],\"potri!\":[67,4,1,\"\"],\"potrs!\":[67,4,1,\"\"],\"pstrf!\":[67,4,1,\"\"],\"ptsv!\":[67,4,1,\"\"],\"pttrf!\":[67,4,1,\"\"],\"pttrs!\":[67,4,1,\"\"],\"stebz!\":[67,4,1,\"\"],\"stegr!\":[67,4,1,\"\"],\"stein!\":[67,4,1,\"\"],\"stev!\":[67,4,1,\"\"],\"syconv!\":[67,4,1,\"\"],\"syev!\":[67,4,1,\"\"],\"syevr!\":[67,4,1,\"\"],\"sygvd!\":[67,4,1,\"\"],\"sysv!\":[67,4,1,\"\"],\"sytrf!\":[67,4,1,\"\"],\"sytri!\":[67,4,1,\"\"],\"sytrs!\":[67,4,1,\"\"],\"tgsen!\":[67,4,1,\"\"],\"trcon!\":[67,4,1,\"\"],\"trevc!\":[67,4,1,\"\"],\"trrfs!\":[67,4,1,\"\"],\"trsen!\":[67,4,1,\"\"],\"trsyl!\":[67,4,1,\"\"],\"trtri!\":[67,4,1,\"\"],\"trtrs!\":[67,4,1,\"\"],\"tzrzf!\":[67,4,1,\"\"]},\"Base.Mmap\":{\"sync!\":[64,4,1,\"\"],Anonymous:[64,4,1,\"\"],mmap:[64,4,1,\"\"]},\"Base.Pkg\":{add:[71,4,1,\"\"],available:[71,4,1,\"\"],build:[71,4,1,\"\"],checkout:[71,4,1,\"\"],clone:[71,4,1,\"\"],dir:[71,4,1,\"\"],edit:[71,4,1,\"\"],free:[71,4,1,\"\"],generate:[71,4,1,\"\"],init:[71,4,1,\"\"],installed:[71,4,1,\"\"],pin:[71,4,1,\"\"],publish:[71,4,1,\"\"],register:[71,4,1,\"\"],resolve:[71,4,1,\"\"],rm:[71,4,1,\"\"],status:[71,4,1,\"\"],tag:[71,4,1,\"\"],test:[71,4,1,\"\"],update:[71,4,1,\"\"]},\"Base.Profile\":{callers:[72,4,1,\"\"],clear:[72,4,1,\"\"],clear_malloc_data:[72,4,1,\"\"],fetch:[72,4,1,\"\"],init:[72,4,1,\"\"],print:[72,4,1,\"\"],retrieve:[72,4,1,\"\"]},\"Base.Sys\":{get_process_title:[57,4,1,\"\"],set_process_title:[57,4,1,\"\"]},\"Base.Test\":{\"@test\":[76,4,1,\"\"],\"@test_approx_eq\":[76,4,1,\"\"],\"@test_approx_eq_eps\":[76,4,1,\"\"],\"@test_throws\":[76,4,1,\"\"],with_handler:[76,4,1,\"\"]},\"Dates.Dates\":{DateFormat:[61,4,1,\"\"]},Base:{\"!\":[68,4,1,\"\"],\"!=\":[68,4,1,\"\"],\"!==\":[68,4,1,\"\"],\"$\":[68,4,1,\"\"],\"%\":[68,4,1,\"\"],\"&\":[68,4,1,\"\"],\"*\":[75,4,1,\"\"],\"+\":[68,4,1,\"\"],\"-\":[68,4,1,\"\"],\"/\":[68,4,1,\"\"],\"//\":[68,4,1,\"\"],\":\":[68,4,1,\"\"],\"<\":[68,4,1,\"\"],\"<:\":[57,4,1,\"\"],\"<<\":[68,4,1,\"\"],\"<=\":[68,4,1,\"\"],\"==\":[68,4,1,\"\"],\"===\":[68,4,1,\"\"],\">\":[68,4,1,\"\"],\">=\":[68,4,1,\"\"],\">>\":[68,4,1,\"\"],\">>>\":[68,4,1,\"\"],\"@allocated\":[57,4,1,\"\"],\"@async\":[70,4,1,\"\"],\"@code_llvm\":[57,4,1,\"\"],\"@code_lowered\":[57,4,1,\"\"],\"@code_native\":[57,4,1,\"\"],\"@code_typed\":[57,4,1,\"\"],\"@code_warntype\":[57,4,1,\"\"],\"@edit\":[57,4,1,\"\"],\"@elapsed\":[57,4,1,\"\"],\"@eval\":[57,4,1,\"\"],\"@evalpoly\":[68,4,1,\"\"],\"@everywhere\":[70,4,1,\"\"],\"@fetch\":[70,4,1,\"\"],\"@fetchfrom\":[70,4,1,\"\"],\"@gensym\":[57,4,1,\"\"],\"@less\":[57,4,1,\"\"],\"@linux\":[57,4,1,\"\"],\"@osx\":[57,4,1,\"\"],\"@parallel\":[70,4,1,\"\"],\"@printf\":[64,4,1,\"\"],\"@profile\":[72,4,1,\"\"],\"@schedule\":[70,4,1,\"\"],\"@show\":[57,4,1,\"\"],\"@spawn\":[70,4,1,\"\"],\"@spawnat\":[70,4,1,\"\"],\"@sprintf\":[64,4,1,\"\"],\"@sync\":[70,4,1,\"\"],\"@task\":[70,4,1,\"\"],\"@time\":[57,4,1,\"\"],\"@timed\":[57,4,1,\"\"],\"@timev\":[57,4,1,\"\"],\"@unix\":[57,4,1,\"\"],\"@which\":[57,4,1,\"\"],\"@windows\":[57,4,1,\"\"],\"A_mul_B!\":[68,4,1,\"\"],\"Channel{T}\":[70,4,1,\"\"],\"Ptr{T}\":[58,5,1,\"\"],\"Ref{T}\":[58,5,1,\"\"],\"Val{c}\":[57,4,1,\"\"],\"\\\\\":[68,4,1,\"\"],\"\\u00d7\":[67,4,1,\"\"],\"\\u00f7\":[68,4,1,\"\"],\"\\u03b3\":[69,5,1,\"\"],\"\\u03c0\":[69,5,1,\"\"],\"\\u03c6\":[69,5,1,\"\"],\"\\u2208\":[59,4,1,\"\"],\"\\u2209\":[59,4,1,\"\"],\"\\u220b\":[59,4,1,\"\"],\"\\u220c\":[59,4,1,\"\"],\"\\u2229\":[59,4,1,\"\"],\"\\u222a\":[59,4,1,\"\"],\"\\u2260\":[68,4,1,\"\"],\"\\u2261\":[68,4,1,\"\"],\"\\u2262\":[68,4,1,\"\"],\"\\u2264\":[68,4,1,\"\"],\"\\u2265\":[68,4,1,\"\"],\"\\u2286\":[59,4,1,\"\"],\"\\u2288\":[59,4,1,\"\"],\"\\u228a\":[59,4,1,\"\"],\"\\u22c5\":[67,4,1,\"\"],\"^\":[75,4,1,\"\"],\"__precompile__\":[57,4,1,\"\"],\"all!\":[59,4,1,\"\"],\"any!\":[59,4,1,\"\"],\"append!\":[59,4,1,\"\"],\"bfft!\":[68,4,1,\"\"],\"bkfact!\":[67,4,1,\"\"],\"broadcast!\":[56,4,1,\"\"],\"broadcast!_function\":[56,4,1,\"\"],\"broadcast_setindex!\":[56,4,1,\"\"],\"cholfact!\":[67,4,1,\"\"],\"complement!\":[59,4,1,\"\"],\"conj!\":[56,4,1,\"\"],\"copy!\":[58,4,1,\"\"],\"ctranspose!\":[67,4,1,\"\"],\"cumprod!\":[56,4,1,\"\"],\"cumsum!\":[56,4,1,\"\"],\"dct!\":[68,4,1,\"\"],\"delete!\":[59,4,1,\"\"],\"deleteat!\":[59,4,1,\"\"],\"digits!\":[69,4,1,\"\"],\"eigfact!\":[67,4,1,\"\"],\"eigvals!\":[67,4,1,\"\"],\"empty!\":[59,4,1,\"\"],\"fft!\":[68,4,1,\"\"],\"fill!\":[56,4,1,\"\"],\"filt!\":[68,4,1,\"\"],\"filter!\":[59,4,1,\"\"],\"findmax!\":[59,4,1,\"\"],\"findmin!\":[59,4,1,\"\"],\"flipbits!\":[56,4,1,\"\"],\"float\":[69,4,1,\"\"],\"get!\":[59,4,1,\"\"],\"givens{T}\":[67,4,1,\"\"],\"hessfact!\":[67,4,1,\"\"],\"hist!\":[68,4,1,\"\"],\"hist2d!\":[68,4,1,\"\"],\"idct!\":[68,4,1,\"\"],\"ifft!\":[68,4,1,\"\"],\"in\":[59,4,1,\"\"],\"insert!\":[59,4,1,\"\"],\"intersect!\":[59,4,1,\"\"],\"ipermute!\":[56,4,1,\"\"],\"isposdef!\":[67,4,1,\"\"],\"ldltfact!\":[67,4,1,\"\"],\"lufact!\":[67,4,1,\"\"],\"map!\":[59,4,1,\"\"],\"maxabs!\":[59,4,1,\"\"],\"maximum!\":[59,4,1,\"\"],\"mean!\":[68,4,1,\"\"],\"median!\":[68,4,1,\"\"],\"merge!\":[59,4,1,\"\"],\"minabs!\":[59,4,1,\"\"],\"minimum!\":[59,4,1,\"\"],\"nthperm!\":[56,4,1,\"\"],\"ordschur!\":[67,4,1,\"\"],\"permute!\":[56,4,1,\"\"],\"permutedims!\":[56,4,1,\"\"],\"plan_bfft!\":[68,4,1,\"\"],\"plan_dct!\":[68,4,1,\"\"],\"plan_fft!\":[68,4,1,\"\"],\"plan_idct!\":[68,4,1,\"\"],\"plan_ifft!\":[68,4,1,\"\"],\"pop!\":[59,4,1,\"\"],\"prepend!\":[59,4,1,\"\"],\"prod!\":[59,4,1,\"\"],\"push!\":[59,4,1,\"\"],\"put!\":[70,4,1,\"\"],\"qrfact!\":[67,4,1,\"\"],\"quantile!\":[68,4,1,\"\"],\"rand!\":[69,4,1,\"\"],\"randexp!\":[69,4,1,\"\"],\"randn!\":[69,4,1,\"\"],\"randsubseq!\":[56,4,1,\"\"],\"read!\":[64,4,1,\"\"],\"readbytes!\":[64,4,1,\"\"],\"resize!\":[59,4,1,\"\"],\"reverse!\":[56,4,1,\"\"],\"rol!\":[56,4,1,\"\"],\"ror!\":[56,4,1,\"\"],\"scale!\":[67,4,1,\"\"],\"schurfact!\":[67,4,1,\"\"],\"select!\":[74,4,1,\"\"],\"selectperm!\":[74,4,1,\"\"],\"setdiff!\":[59,4,1,\"\"],\"setfield!\":[57,4,1,\"\"],\"setindex!\":[59,4,1,\"\"],\"shift!\":[59,4,1,\"\"],\"shuffle!\":[56,4,1,\"\"],\"sizehint!\":[59,4,1,\"\"],\"sort!\":[74,4,1,\"\"],\"sortperm!\":[74,4,1,\"\"],\"splice!\":[59,4,1,\"\"],\"sum!\":[59,4,1,\"\"],\"sumabs!\":[59,4,1,\"\"],\"sumabs2!\":[59,4,1,\"\"],\"super\":[57,4,1,\"\"],\"svdfact!\":[67,4,1,\"\"],\"svdvals!\":[67,4,1,\"\"],\"symdiff!\":[59,4,1,\"\"],\"take!\":[70,4,1,\"\"],\"throw\":[57,4,1,\"\"],\"transpose!\":[67,4,1,\"\"],\"tril!\":[67,4,1,\"\"],\"triu!\":[67,4,1,\"\"],\"typeof\":[57,4,1,\"\"],\"union!\":[59,4,1,\"\"],\"unsafe_copy!\":[58,4,1,\"\"],\"unsafe_store!\":[58,4,1,\"\"],\"unshift!\":[59,4,1,\"\"],\"var\":[68,4,1,\"\"],\"|\":[68,4,1,\"\"],\"|>\":[57,4,1,\"\"],\"~\":[68,4,1,\"\"],ANY:[60,5,1,\"\"],ARGS:[60,5,1,\"\"],A_ldiv_Bc:[68,4,1,\"\"],A_ldiv_Bt:[68,4,1,\"\"],A_mul_Bc:[68,4,1,\"\"],A_mul_Bt:[68,4,1,\"\"],A_rdiv_Bc:[68,4,1,\"\"],A_rdiv_Bt:[68,4,1,\"\"],Ac_ldiv_B:[68,4,1,\"\"],Ac_ldiv_Bc:[68,4,1,\"\"],Ac_mul_B:[68,4,1,\"\"],Ac_mul_Bc:[68,4,1,\"\"],Ac_rdiv_B:[68,4,1,\"\"],Ac_rdiv_Bc:[68,4,1,\"\"],ArgumentError:[57,4,1,\"\"],Array:[56,4,1,\"\"],AssertionError:[57,4,1,\"\"],At_ldiv_B:[68,4,1,\"\"],At_ldiv_Bt:[68,4,1,\"\"],At_mul_B:[68,4,1,\"\"],At_mul_Bt:[68,4,1,\"\"],At_rdiv_B:[68,4,1,\"\"],At_rdiv_Bt:[68,4,1,\"\"],Base64DecodePipe:[64,4,1,\"\"],Base64EncodePipe:[64,4,1,\"\"],Bidiagonal:[67,4,1,\"\"],BigFloat:[69,4,1,\"\"],BigInt:[69,4,1,\"\"],BoundsError:[57,4,1,\"\"],CPU_CORES:[60,5,1,\"\"],C_NULL:[60,5,1,\"\"],Cartesian:[3,3,0,\"-\"],Cchar:[58,5,1,\"\"],Cdouble:[58,5,1,\"\"],Cfloat:[58,5,1,\"\"],Cint:[58,5,1,\"\"],Cintmax_t:[58,5,1,\"\"],Clong:[58,5,1,\"\"],Clonglong:[58,5,1,\"\"],Coff_t:[58,5,1,\"\"],Collections:[59,3,0,\"-\"],Condition:[70,4,1,\"\"],Cptrdiff_t:[58,5,1,\"\"],Cshort:[58,5,1,\"\"],Csize_t:[58,5,1,\"\"],Cssize_t:[58,5,1,\"\"],Cuchar:[58,5,1,\"\"],Cuint:[58,5,1,\"\"],Cuintmax_t:[58,5,1,\"\"],Culong:[58,5,1,\"\"],Culonglong:[58,5,1,\"\"],Cushort:[58,5,1,\"\"],Cwchar_t:[58,5,1,\"\"],DevNull:[57,5,1,\"\"],Dict:[59,4,1,\"\"],DimensionMismatch:[57,4,1,\"\"],DivideError:[57,4,1,\"\"],DomainError:[57,4,1,\"\"],ENDIAN_BOM:[64,5,1,\"\"],ENV:[57,5,1,\"\"],EOFError:[57,4,1,\"\"],EnvHash:[57,4,1,\"\"],ErrorException:[57,4,1,\"\"],Float32:[69,4,1,\"\"],Float64:[69,4,1,\"\"],IOBuffer:[64,4,1,\"\"],IPv4:[64,4,1,\"\"],IPv6:[64,4,1,\"\"],InexactError:[57,4,1,\"\"],Inf16:[69,5,1,\"\"],Inf32:[69,5,1,\"\"],Inf:[69,5,1,\"\"],InitError:[57,4,1,\"\"],IntSet:[59,4,1,\"\"],InterruptException:[57,4,1,\"\"],JULIA_HOME:[60,5,1,\"\"],KeyError:[57,4,1,\"\"],LOAD_PATH:[60,5,1,\"\"],LinAlg:[67,3,0,\"-\"],LoadError:[57,4,1,\"\"],MersenneTwister:[69,4,1,\"\"],MethodError:[57,4,1,\"\"],NaN16:[69,5,1,\"\"],NaN32:[69,5,1,\"\"],NaN:[69,5,1,\"\"],NullException:[57,4,1,\"\"],Nullable:[57,4,1,\"\"],OS_NAME:[60,5,1,\"\"],OutOfMemoryError:[57,4,1,\"\"],OverflowError:[57,4,1,\"\"],ParseError:[57,4,1,\"\"],PipeBuffer:[64,4,1,\"\"],Pkg:[71,3,0,\"-\"],ProcessExitedException:[57,4,1,\"\"],RandomDevice:[69,4,1,\"\"],ReadOnlyMemoryError:[57,4,1,\"\"],ReentrantLock:[70,4,1,\"\"],RemoteRef:[70,4,1,\"\"],RoundDown:[68,5,1,\"\"],RoundNearest:[68,5,1,\"\"],RoundNearestTiesAway:[68,5,1,\"\"],RoundNearestTiesUp:[68,5,1,\"\"],RoundToZero:[68,5,1,\"\"],RoundUp:[68,5,1,\"\"],RoundingMode:[68,5,1,\"\"],STDERR:[64,5,1,\"\"],STDIN:[64,5,1,\"\"],STDOUT:[64,5,1,\"\"],Set:[59,4,1,\"\"],SharedArray:[70,4,1,\"\"],StackOverflowError:[57,4,1,\"\"],SymTridiagonal:[67,4,1,\"\"],SystemError:[57,4,1,\"\"],Task:[70,4,1,\"\"],Test:[76,3,0,\"-\"],TextDisplay:[64,4,1,\"\"],Timer:[57,4,1,\"\"],Tridiagonal:[67,4,1,\"\"],TypeError:[57,4,1,\"\"],UndefRefError:[57,4,1,\"\"],UndefVarError:[57,4,1,\"\"],VERSION:[60,5,1,\"\"],WORD_SIZE:[60,5,1,\"\"],abs2:[68,4,1,\"\"],abs:[68,4,1,\"\"],abspath:[62,4,1,\"\"],accept:[64,4,1,\"\"],acos:[68,4,1,\"\"],acosd:[68,4,1,\"\"],acosh:[68,4,1,\"\"],acot:[68,4,1,\"\"],acotd:[68,4,1,\"\"],acoth:[68,4,1,\"\"],acsc:[68,4,1,\"\"],acscd:[68,4,1,\"\"],acsch:[68,4,1,\"\"],addprocs:[70,4,1,\"\"],airy:[68,4,1,\"\"],airyai:[68,4,1,\"\"],airyaiprime:[68,4,1,\"\"],airybi:[68,4,1,\"\"],airybiprime:[68,4,1,\"\"],airyprime:[68,4,1,\"\"],airyx:[68,4,1,\"\"],all:[59,4,1,\"\"],angle:[68,4,1,\"\"],ans:[57,5,1,\"\"],any:[59,4,1,\"\"],applicable:[57,4,1,\"\"],apropos:[57,4,1,\"\"],ascii:[75,4,1,\"\"],asec:[68,4,1,\"\"],asecd:[68,4,1,\"\"],asech:[68,4,1,\"\"],asin:[68,4,1,\"\"],asind:[68,4,1,\"\"],asinh:[68,4,1,\"\"],assert:[57,4,1,\"\"],atan2:[68,4,1,\"\"],atan:[68,4,1,\"\"],atand:[68,4,1,\"\"],atanh:[68,4,1,\"\"],atexit:[57,4,1,\"\"],atreplinit:[57,4,1,\"\"],backtrace:[57,4,1,\"\"],base64decode:[64,4,1,\"\"],base64encode:[64,4,1,\"\"],base:[69,4,1,\"\"],basename:[62,4,1,\"\"],besselh:[68,4,1,\"\"],besseli:[68,4,1,\"\"],besselix:[68,4,1,\"\"],besselj0:[68,4,1,\"\"],besselj1:[68,4,1,\"\"],besselj:[68,4,1,\"\"],besseljx:[68,4,1,\"\"],besselk:[68,4,1,\"\"],besselkx:[68,4,1,\"\"],bessely0:[68,4,1,\"\"],bessely1:[68,4,1,\"\"],bessely:[68,4,1,\"\"],besselyx:[68,4,1,\"\"],beta:[68,4,1,\"\"],bfft:[68,4,1,\"\"],big:[69,4,1,\"\"],bin:[69,4,1,\"\"],bind:[64,4,1,\"\"],binomial:[68,4,1,\"\"],bitbroadcast:[56,4,1,\"\"],bitpack:[56,4,1,\"\"],bitrand:[69,4,1,\"\"],bits:[69,4,1,\"\"],bitunpack:[56,4,1,\"\"],bkfact:[67,4,1,\"\"],blkdiag:[67,4,1,\"\"],brfft:[68,4,1,\"\"],broadcast:[56,4,1,\"\"],broadcast_function:[56,4,1,\"\"],broadcast_getindex:[56,4,1,\"\"],bswap:[69,4,1,\"\"],bytes2hex:[69,4,1,\"\"],bytestring:[75,4,1,\"\"],call:[57,4,1,\"\"],cat:[56,4,1,\"\"],catalan:[69,5,1,\"\"],catch_backtrace:[57,4,1,\"\"],cbrt:[68,4,1,\"\"],ccall:[58,4,1,\"\"],cconvert:[58,4,1,\"\"],cd:[62,4,1,\"\"],ceil:[68,4,1,\"\"],cell:[56,4,1,\"\"],cfunction:[58,4,1,\"\"],cglobal:[58,4,1,\"\"],charwidth:[75,4,1,\"\"],checkbounds:[56,4,1,\"\"],chmod:[62,4,1,\"\"],chol:[67,4,1,\"\"],cholfact:[67,4,1,\"\"],chomp:[75,4,1,\"\"],chop:[75,4,1,\"\"],chr2ind:[75,4,1,\"\"],circshift:[56,4,1,\"\"],cis:[68,4,1,\"\"],clamp:[68,4,1,\"\"],cld:[68,4,1,\"\"],clipboard:[57,4,1,\"\"],close:[70,4,1,\"\"],cmp:[68,4,1,\"\"],code_llvm:[57,4,1,\"\"],code_lowered:[57,4,1,\"\"],code_native:[57,4,1,\"\"],code_typed:[57,4,1,\"\"],code_warntype:[57,4,1,\"\"],collect:[59,4,1,\"\"],colon:[68,4,1,\"\"],combinations:[56,4,1,\"\"],complement:[59,4,1,\"\"],complex:[69,4,1,\"\"],cond:[67,4,1,\"\"],condskeel:[67,4,1,\"\"],conj:[68,4,1,\"\"],connect:[70,4,1,\"\"],consume:[70,4,1,\"\"],contains:[75,4,1,\"\"],conv2:[68,4,1,\"\"],conv:[68,4,1,\"\"],convert:[57,4,1,\"\"],copy:[57,4,1,\"\"],copysign:[68,4,1,\"\"],cor:[68,4,1,\"\"],cos:[68,4,1,\"\"],cosc:[68,4,1,\"\"],cosd:[68,4,1,\"\"],cosh:[68,4,1,\"\"],cospi:[68,4,1,\"\"],cot:[68,4,1,\"\"],cotd:[68,4,1,\"\"],coth:[68,4,1,\"\"],count:[59,4,1,\"\"],count_ones:[69,4,1,\"\"],count_zeros:[69,4,1,\"\"],countfrom:[59,4,1,\"\"],countlines:[64,4,1,\"\"],countnz:[56,4,1,\"\"],cov:[68,4,1,\"\"],cp:[62,4,1,\"\"],cross:[67,4,1,\"\"],csc:[68,4,1,\"\"],cscd:[68,4,1,\"\"],csch:[68,4,1,\"\"],ctime:[62,4,1,\"\"],ctranspose:[67,4,1,\"\"],cummax:[56,4,1,\"\"],cummin:[56,4,1,\"\"],cumprod:[56,4,1,\"\"],cumsum:[56,4,1,\"\"],cumsum_kbn:[56,4,1,\"\"],current_module:[57,4,1,\"\"],current_task:[70,4,1,\"\"],cycle:[59,4,1,\"\"],dawson:[68,4,1,\"\"],dct:[68,4,1,\"\"],dec:[69,4,1,\"\"],deconv:[68,4,1,\"\"],deepcopy:[57,4,1,\"\"],deg2rad:[68,4,1,\"\"],den:[68,4,1,\"\"],deserialize:[64,4,1,\"\"],det:[67,4,1,\"\"],detach:[57,4,1,\"\"],diag:[67,4,1,\"\"],diagind:[67,4,1,\"\"],diagm:[67,4,1,\"\"],diff:[56,4,1,\"\"],digamma:[68,4,1,\"\"],digits:[69,4,1,\"\"],dirname:[62,4,1,\"\"],disable_sigint:[58,4,1,\"\"],display:[64,4,1,\"\"],displayable:[64,4,1,\"\"],div:[68,4,1,\"\"],divrem:[68,4,1,\"\"],done:[59,4,1,\"\"],dot:[67,4,1,\"\"],download:[62,4,1,\"\"],drop:[59,4,1,\"\"],dump:[64,4,1,\"\"],e:[69,5,1,\"\"],eachindex:[56,4,1,\"\"],eachline:[64,4,1,\"\"],eachmatch:[75,4,1,\"\"],edit:[57,4,1,\"\"],eig:[67,4,1,\"\"],eigfact:[67,4,1,\"\"],eigmax:[67,4,1,\"\"],eigmin:[67,4,1,\"\"],eigs:[67,4,1,\"\"],eigvals:[67,4,1,\"\"],eigvecs:[67,4,1,\"\"],eltype:[59,4,1,\"\"],endof:[59,4,1,\"\"],endswith:[75,4,1,\"\"],enumerate:[59,4,1,\"\"],eof:[64,4,1,\"\"],eps:[57,4,1,\"\"],erf:[68,4,1,\"\"],erfc:[68,4,1,\"\"],erfcinv:[68,4,1,\"\"],erfcx:[68,4,1,\"\"],erfi:[68,4,1,\"\"],erfinv:[68,4,1,\"\"],error:[57,4,1,\"\"],esc:[57,4,1,\"\"],escape_string:[75,4,1,\"\"],eta:[68,4,1,\"\"],etree:[56,4,1,\"\"],eu:[69,5,1,\"\"],eulergamma:[69,5,1,\"\"],eval:[57,4,1,\"\"],evalfile:[57,4,1,\"\"],exit:[57,4,1,\"\"],exp10:[68,4,1,\"\"],exp2:[68,4,1,\"\"],exp:[68,4,1,\"\"],expand:[57,4,1,\"\"],expanduser:[62,4,1,\"\"],expm1:[68,4,1,\"\"],expm:[67,4,1,\"\"],exponent:[69,4,1,\"\"],extrema:[59,4,1,\"\"],eye:[56,4,1,\"\"],factor:[68,4,1,\"\"],factorial:[68,4,1,\"\"],factorize:[67,4,1,\"\"],falses:[56,4,1,\"\"],fd:[64,4,1,\"\"],fdio:[64,4,1,\"\"],fetch:[70,4,1,\"\"],fft:[68,4,1,\"\"],fftshift:[68,4,1,\"\"],fieldnames:[57,4,1,\"\"],fieldoffsets:[57,4,1,\"\"],fieldtype:[57,4,1,\"\"],filemode:[62,4,1,\"\"],filesize:[62,4,1,\"\"],fill:[56,4,1,\"\"],filt:[68,4,1,\"\"],filter:[59,4,1,\"\"],finalize:[57,4,1,\"\"],finalizer:[57,4,1,\"\"],find:[56,4,1,\"\"],findfirst:[56,4,1,\"\"],findin:[59,4,1,\"\"],findlast:[56,4,1,\"\"],findmax:[59,4,1,\"\"],findmin:[59,4,1,\"\"],findn:[56,4,1,\"\"],findnext:[56,4,1,\"\"],findnz:[56,4,1,\"\"],findprev:[56,4,1,\"\"],first:[59,4,1,\"\"],fld:[68,4,1,\"\"],fldmod:[68,4,1,\"\"],flipdim:[56,4,1,\"\"],flipsign:[68,4,1,\"\"],floor:[68,4,1,\"\"],flush:[64,4,1,\"\"],fma:[68,4,1,\"\"],foldl:[59,4,1,\"\"],foldr:[59,4,1,\"\"],frexp:[68,4,1,\"\"],full:[67,4,1,\"\"],fullname:[57,4,1,\"\"],function_module:[57,4,1,\"\"],function_name:[57,4,1,\"\"],functionloc:[57,4,1,\"\"],gamma:[68,4,1,\"\"],gc:[57,4,1,\"\"],gc_enable:[57,4,1,\"\"],gcd:[68,4,1,\"\"],gcdx:[68,4,1,\"\"],gensym:[57,4,1,\"\"],get:[59,4,1,\"\"],get_bigfloat_precision:[69,4,1,\"\"],get_rounding:[69,4,1,\"\"],get_zero_subnormals:[69,4,1,\"\"],getaddrinfo:[64,4,1,\"\"],getfield:[57,4,1,\"\"],gethostname:[57,4,1,\"\"],getindex:[59,4,1,\"\"],getipaddr:[57,4,1,\"\"],getkey:[59,4,1,\"\"],getpid:[57,4,1,\"\"],golden:[69,5,1,\"\"],gperm:[62,4,1,\"\"],gradient:[56,4,1,\"\"],graphemes:[75,4,1,\"\"],hankelh1:[68,4,1,\"\"],hankelh1x:[68,4,1,\"\"],hankelh2:[68,4,1,\"\"],hankelh2x:[68,4,1,\"\"],hash:[57,4,1,\"\"],haskey:[59,4,1,\"\"],hcat:[56,4,1,\"\"],hessfact:[67,4,1,\"\"],hex2bytes:[69,4,1,\"\"],hex2num:[69,4,1,\"\"],hex:[69,4,1,\"\"],hist2d:[68,4,1,\"\"],hist:[68,4,1,\"\"],histrange:[68,4,1,\"\"],homedir:[62,4,1,\"\"],htol:[64,4,1,\"\"],hton:[64,4,1,\"\"],hvcat:[56,4,1,\"\"],hypot:[68,4,1,\"\"],idct:[68,4,1,\"\"],identity:[57,4,1,\"\"],ifelse:[57,4,1,\"\"],ifft:[68,4,1,\"\"],ifftshift:[68,4,1,\"\"],ignorestatus:[57,4,1,\"\"],im:[69,5,1,\"\"],imag:[68,4,1,\"\"],include:[57,4,1,\"\"],include_dependency:[57,4,1,\"\"],include_string:[57,4,1,\"\"],ind2chr:[75,4,1,\"\"],ind2sub:[56,4,1,\"\"],indexin:[59,4,1,\"\"],indexpids:[70,4,1,\"\"],indmax:[59,4,1,\"\"],indmin:[59,4,1,\"\"],inf:[69,4,1,\"\"],info:[64,4,1,\"\"],init_worker:[70,4,1,\"\"],instances:[57,4,1,\"\"],interrupt:[70,4,1,\"\"],intersect:[59,4,1,\"\"],inv:[67,4,1,\"\"],invdigamma:[68,4,1,\"\"],invmod:[68,4,1,\"\"],invoke:[57,4,1,\"\"],invperm:[56,4,1,\"\"],ipermutedims:[56,4,1,\"\"],irfft:[68,4,1,\"\"],is:[57,4,1,\"\"],is_assigned_char:[75,4,1,\"\"],isa:[57,4,1,\"\"],isabspath:[62,4,1,\"\"],isalnum:[75,4,1,\"\"],isalpha:[75,4,1,\"\"],isapprox:[68,4,1,\"\"],isascii:[75,4,1,\"\"],isbits:[57,4,1,\"\"],isblockdev:[62,4,1,\"\"],ischardev:[62,4,1,\"\"],iscntrl:[75,4,1,\"\"],isconst:[57,4,1,\"\"],isdefined:[57,4,1,\"\"],isdiag:[67,4,1,\"\"],isdigit:[75,4,1,\"\"],isdir:[62,4,1,\"\"],isdirpath:[62,4,1,\"\"],iseltype:[56,4,1,\"\"],isempty:[59,4,1,\"\"],isequal:[57,4,1,\"\"],iseven:[69,4,1,\"\"],isexecutable:[62,4,1,\"\"],isfifo:[62,4,1,\"\"],isfile:[62,4,1,\"\"],isfinite:[69,4,1,\"\"],isgeneric:[57,4,1,\"\"],isgraph:[75,4,1,\"\"],ishermitian:[67,4,1,\"\"],isimmutable:[57,4,1,\"\"],isinf:[69,4,1,\"\"],isinteger:[69,4,1,\"\"],isinteractive:[57,4,1,\"\"],isleaftype:[57,4,1,\"\"],isless:[57,4,1,\"\"],islink:[62,4,1,\"\"],islower:[75,4,1,\"\"],ismarked:[64,4,1,\"\"],ismatch:[75,4,1,\"\"],ismount:[62,4,1,\"\"],isnan:[69,4,1,\"\"],isnull:[57,4,1,\"\"],isnumber:[75,4,1,\"\"],isodd:[69,4,1,\"\"],isopen:[64,4,1,\"\"],ispath:[62,4,1,\"\"],isperm:[56,4,1,\"\"],isposdef:[67,4,1,\"\"],ispow2:[68,4,1,\"\"],isprime:[69,4,1,\"\"],isprint:[75,4,1,\"\"],ispunct:[75,4,1,\"\"],isqrt:[68,4,1,\"\"],isreadable:[62,4,1,\"\"],isreadonly:[64,4,1,\"\"],isready:[70,4,1,\"\"],isreal:[69,4,1,\"\"],issetgid:[62,4,1,\"\"],issetuid:[62,4,1,\"\"],issocket:[62,4,1,\"\"],issorted:[74,4,1,\"\"],isspace:[75,4,1,\"\"],issparse:[56,4,1,\"\"],issticky:[62,4,1,\"\"],issubnormal:[69,4,1,\"\"],issubset:[59,4,1,\"\"],issubtype:[57,4,1,\"\"],issym:[67,4,1,\"\"],istaskdone:[70,4,1,\"\"],istaskstarted:[70,4,1,\"\"],istext:[64,4,1,\"\"],istril:[67,4,1,\"\"],istriu:[67,4,1,\"\"],isupper:[75,4,1,\"\"],isvalid:[75,4,1,\"\"],iswritable:[62,4,1,\"\"],isxdigit:[75,4,1,\"\"],join:[75,4,1,\"\"],joinpath:[62,4,1,\"\"],keys:[59,4,1,\"\"],keytype:[59,4,1,\"\"],kill:[70,4,1,\"\"],kron:[67,4,1,\"\"],last:[59,4,1,\"\"],launch:[70,4,1,\"\"],lbeta:[68,4,1,\"\"],lcfirst:[75,4,1,\"\"],lcm:[68,4,1,\"\"],ldexp:[68,4,1,\"\"],ldltfact:[67,4,1,\"\"],leading_ones:[69,4,1,\"\"],leading_zeros:[69,4,1,\"\"],length:[75,4,1,\"\"],less:[57,4,1,\"\"],lexcmp:[57,4,1,\"\"],lexless:[57,4,1,\"\"],lfact:[68,4,1,\"\"],lgamma:[68,4,1,\"\"],linreg:[67,4,1,\"\"],linspace:[56,4,1,\"\"],listen:[64,4,1,\"\"],listenany:[64,4,1,\"\"],llvmcall:[58,4,1,\"\"],localindexes:[70,4,1,\"\"],lock:[70,4,1,\"\"],log10:[68,4,1,\"\"],log1p:[68,4,1,\"\"],log2:[68,4,1,\"\"],log:[68,4,1,\"\"],logabsdet:[67,4,1,\"\"],logdet:[67,4,1,\"\"],logm:[67,4,1,\"\"],logspace:[56,4,1,\"\"],lowercase:[75,4,1,\"\"],lpad:[75,4,1,\"\"],lstat:[62,4,1,\"\"],lstrip:[75,4,1,\"\"],ltoh:[64,4,1,\"\"],lu:[67,4,1,\"\"],lufact:[67,4,1,\"\"],lyap:[67,4,1,\"\"],macroexpand:[57,4,1,\"\"],manage:[70,4,1,\"\"],map:[59,4,1,\"\"],mapfoldl:[59,4,1,\"\"],mapfoldr:[59,4,1,\"\"],mapreduce:[59,4,1,\"\"],mapreducedim:[56,4,1,\"\"],mapslices:[56,4,1,\"\"],mark:[64,4,1,\"\"],match:[75,4,1,\"\"],matchall:[75,4,1,\"\"],max:[68,4,1,\"\"],maxabs:[59,4,1,\"\"],maximum:[59,4,1,\"\"],maxintfloat:[57,4,1,\"\"],mean:[68,4,1,\"\"],median:[68,4,1,\"\"],merge:[59,4,1,\"\"],method_exists:[57,4,1,\"\"],methods:[57,4,1,\"\"],methodswith:[57,4,1,\"\"],middle:[68,4,1,\"\"],midpoints:[68,4,1,\"\"],mimewritable:[64,4,1,\"\"],min:[68,4,1,\"\"],minabs:[59,4,1,\"\"],minimum:[59,4,1,\"\"],minmax:[68,4,1,\"\"],mkdir:[62,4,1,\"\"],mkpath:[62,4,1,\"\"],mktemp:[62,4,1,\"\"],mktempdir:[62,4,1,\"\"],mod1:[68,4,1,\"\"],mod2pi:[68,4,1,\"\"],mod:[68,4,1,\"\"],modf:[68,4,1,\"\"],module_name:[57,4,1,\"\"],module_parent:[57,4,1,\"\"],mtime:[62,4,1,\"\"],muladd:[68,4,1,\"\"],mv:[62,4,1,\"\"],myid:[70,4,1,\"\"],names:[57,4,1,\"\"],nan:[69,4,1,\"\"],nb_available:[64,4,1,\"\"],ndigits:[68,4,1,\"\"],ndims:[56,4,1,\"\"],next:[59,4,1,\"\"],nextfloat:[69,4,1,\"\"],nextind:[75,4,1,\"\"],nextpow2:[68,4,1,\"\"],nextpow:[68,4,1,\"\"],nextprod:[68,4,1,\"\"],nfields:[57,4,1,\"\"],nnz:[56,4,1,\"\"],nonzeros:[56,4,1,\"\"],norm:[67,4,1,\"\"],normalize_string:[75,4,1,\"\"],normpath:[62,4,1,\"\"],nothing:[60,5,1,\"\"],notify:[70,4,1,\"\"],nprocs:[70,4,1,\"\"],nthperm:[56,4,1,\"\"],ntoh:[64,4,1,\"\"],ntuple:[57,4,1,\"\"],nullspace:[67,4,1,\"\"],num2hex:[69,4,1,\"\"],num:[68,4,1,\"\"],nworkers:[70,4,1,\"\"],nzrange:[56,4,1,\"\"],object_id:[57,4,1,\"\"],oct:[69,4,1,\"\"],oftype:[57,4,1,\"\"],one:[69,4,1,\"\"],ones:[56,4,1,\"\"],open:[64,4,1,\"\"],operm:[62,4,1,\"\"],ordschur:[67,4,1,\"\"],parent:[56,4,1,\"\"],parentindexes:[56,4,1,\"\"],parse:[69,4,1,\"\"],parseip:[64,4,1,\"\"],partitions:[56,4,1,\"\"],peakflops:[67,4,1,\"\"],permutations:[56,4,1,\"\"],permutedims:[56,4,1,\"\"],pi:[69,5,1,\"\"],pinv:[67,4,1,\"\"],pipeline:[57,4,1,\"\"],plan_bfft:[68,4,1,\"\"],plan_brfft:[68,4,1,\"\"],plan_dct:[68,4,1,\"\"],plan_fft:[68,4,1,\"\"],plan_idct:[68,4,1,\"\"],plan_ifft:[68,4,1,\"\"],plan_irfft:[68,4,1,\"\"],plan_rfft:[68,4,1,\"\"],pmap:[70,4,1,\"\"],pointer:[58,4,1,\"\"],pointer_from_objref:[58,4,1,\"\"],pointer_to_array:[58,4,1,\"\"],poll_fd:[64,4,1,\"\"],poll_file:[64,4,1,\"\"],polygamma:[68,4,1,\"\"],popdisplay:[64,4,1,\"\"],position:[64,4,1,\"\"],powermod:[68,4,1,\"\"],precision:[69,4,1,\"\"],precompile:[57,4,1,\"\"],prevfloat:[69,4,1,\"\"],prevind:[75,4,1,\"\"],prevpow2:[68,4,1,\"\"],prevpow:[68,4,1,\"\"],prevprod:[68,4,1,\"\"],primes:[69,4,1,\"\"],primesmask:[69,4,1,\"\"],print:[64,4,1,\"\"],print_escaped:[64,4,1,\"\"],print_joined:[64,4,1,\"\"],print_shortest:[64,4,1,\"\"],print_unescaped:[64,4,1,\"\"],print_with_color:[64,4,1,\"\"],println:[64,4,1,\"\"],process_exited:[57,4,1,\"\"],process_running:[57,4,1,\"\"],procs:[70,4,1,\"\"],prod:[59,4,1,\"\"],produce:[70,4,1,\"\"],promote:[57,4,1,\"\"],promote_rule:[57,4,1,\"\"],promote_shape:[56,4,1,\"\"],promote_type:[57,4,1,\"\"],pushdisplay:[64,4,1,\"\"],pwd:[62,4,1,\"\"],qr:[67,4,1,\"\"],qrfact:[67,4,1,\"\"],quadgk:[68,4,1,\"\"],quantile:[68,4,1,\"\"],quit:[57,4,1,\"\"],rad2deg:[68,4,1,\"\"],rand:[69,4,1,\"\"],randcycle:[56,4,1,\"\"],randexp:[69,4,1,\"\"],randjump:[69,4,1,\"\"],randn:[69,4,1,\"\"],randperm:[56,4,1,\"\"],randstring:[75,4,1,\"\"],randsubseq:[56,4,1,\"\"],range:[68,4,1,\"\"],rank:[67,4,1,\"\"],rationalize:[68,4,1,\"\"],read:[64,4,1,\"\"],readall:[64,4,1,\"\"],readandwrite:[57,4,1,\"\"],readavailable:[64,4,1,\"\"],readbytes:[64,4,1,\"\"],readchomp:[64,4,1,\"\"],readcsv:[64,4,1,\"\"],readdir:[62,4,1,\"\"],readdlm:[64,4,1,\"\"],readline:[64,4,1,\"\"],readlines:[64,4,1,\"\"],readlink:[62,4,1,\"\"],readuntil:[64,4,1,\"\"],real:[68,4,1,\"\"],realmax:[57,4,1,\"\"],realmin:[57,4,1,\"\"],realpath:[62,4,1,\"\"],recv:[64,4,1,\"\"],recvfrom:[64,4,1,\"\"],redirect_stderr:[64,4,1,\"\"],redirect_stdin:[64,4,1,\"\"],redirect_stdout:[64,4,1,\"\"],redisplay:[64,4,1,\"\"],reduce:[59,4,1,\"\"],reducedim:[56,4,1,\"\"],reenable_sigint:[58,4,1,\"\"],reim:[68,4,1,\"\"],reinterpret:[56,4,1,\"\"],reload:[57,4,1,\"\"],relpath:[62,4,1,\"\"],rem1:[68,4,1,\"\"],rem:[68,4,1,\"\"],remotecall:[70,4,1,\"\"],remotecall_fetch:[70,4,1,\"\"],remotecall_wait:[70,4,1,\"\"],repeat:[67,4,1,\"\"],repeated:[59,4,1,\"\"],replace:[75,4,1,\"\"],repmat:[67,4,1,\"\"],repr:[75,4,1,\"\"],reprmime:[64,4,1,\"\"],require:[57,4,1,\"\"],reset:[64,4,1,\"\"],reshape:[56,4,1,\"\"],rest:[59,4,1,\"\"],rethrow:[57,4,1,\"\"],reverse:[75,4,1,\"\"],reverseind:[56,4,1,\"\"],rfft:[68,4,1,\"\"],rm:[62,4,1,\"\"],rmprocs:[70,4,1,\"\"],rol:[56,4,1,\"\"],ror:[56,4,1,\"\"],rot180:[56,4,1,\"\"],rotl90:[56,4,1,\"\"],rotr90:[56,4,1,\"\"],round:[68,4,1,\"\"],rowvals:[56,4,1,\"\"],rpad:[75,4,1,\"\"],rsearch:[75,4,1,\"\"],rsearchindex:[75,4,1,\"\"],rsplit:[75,4,1,\"\"],rstrip:[75,4,1,\"\"],run:[57,4,1,\"\"],runtests:[76,4,1,\"\"],scale:[67,4,1,\"\"],schedule:[70,4,1,\"\"],schur:[67,4,1,\"\"],schurfact:[67,4,1,\"\"],sdata:[70,4,1,\"\"],search:[75,4,1,\"\"],searchindex:[75,4,1,\"\"],searchsorted:[74,4,1,\"\"],searchsortedfirst:[74,4,1,\"\"],searchsortedlast:[74,4,1,\"\"],sec:[68,4,1,\"\"],secd:[68,4,1,\"\"],sech:[68,4,1,\"\"],seek:[64,4,1,\"\"],seekend:[64,4,1,\"\"],seekstart:[64,4,1,\"\"],select:[74,4,1,\"\"],selectperm:[74,4,1,\"\"],send:[64,4,1,\"\"],serialize:[64,4,1,\"\"],set_bigfloat_precision:[69,4,1,\"\"],set_rounding:[69,4,1,\"\"],set_zero_subnormals:[69,4,1,\"\"],setdiff:[59,4,1,\"\"],setenv:[57,4,1,\"\"],setopt:[64,4,1,\"\"],show:[64,4,1,\"\"],showall:[64,4,1,\"\"],showcompact:[64,4,1,\"\"],showerror:[64,4,1,\"\"],shuffle:[56,4,1,\"\"],sign:[68,4,1,\"\"],signbit:[68,4,1,\"\"],signed:[69,4,1,\"\"],signif:[68,4,1,\"\"],significand:[69,4,1,\"\"],similar:[56,4,1,\"\"],sin:[68,4,1,\"\"],sinc:[68,4,1,\"\"],sind:[68,4,1,\"\"],sinh:[68,4,1,\"\"],sinpi:[68,4,1,\"\"],size:[56,4,1,\"\"],sizeof:[75,4,1,\"\"],skip:[64,4,1,\"\"],skipchars:[64,4,1,\"\"],sleep:[70,4,1,\"\"],slice:[56,4,1,\"\"],slicedim:[56,4,1,\"\"],sort:[74,4,1,\"\"],sortcols:[74,4,1,\"\"],sortperm:[74,4,1,\"\"],sortrows:[74,4,1,\"\"],sparse:[56,4,1,\"\"],sparsevec:[56,4,1,\"\"],spawn:[57,4,1,\"\"],spdiagm:[56,4,1,\"\"],speye:[56,4,1,\"\"],split:[75,4,1,\"\"],splitdir:[62,4,1,\"\"],splitdrive:[62,4,1,\"\"],splitext:[62,4,1,\"\"],spones:[56,4,1,\"\"],sprand:[56,4,1,\"\"],sprandbool:[56,4,1,\"\"],sprandn:[56,4,1,\"\"],sprint:[64,4,1,\"\"],spzeros:[56,4,1,\"\"],sqrt:[68,4,1,\"\"],sqrtm:[67,4,1,\"\"],squeeze:[56,4,1,\"\"],srand:[69,4,1,\"\"],start:[59,4,1,\"\"],startswith:[75,4,1,\"\"],stat:[62,4,1,\"\"],std:[68,4,1,\"\"],stdm:[68,4,1,\"\"],step:[59,4,1,\"\"],stride:[56,4,1,\"\"],strides:[56,4,1,\"\"],string:[75,4,1,\"\"],stringmime:[64,4,1,\"\"],strip:[75,4,1,\"\"],strwidth:[75,4,1,\"\"],sub2ind:[56,4,1,\"\"],sub:[56,4,1,\"\"],subtypes:[57,4,1,\"\"],success:[57,4,1,\"\"],sum:[59,4,1,\"\"],sum_kbn:[56,4,1,\"\"],sumabs2:[59,4,1,\"\"],sumabs:[59,4,1,\"\"],summary:[64,4,1,\"\"],svd:[67,4,1,\"\"],svdfact:[67,4,1,\"\"],svds:[67,4,1,\"\"],svdvals:[67,4,1,\"\"],sylvester:[67,4,1,\"\"],symbol:[75,4,1,\"\"],symdiff:[59,4,1,\"\"],symlink:[62,4,1,\"\"],symperm:[56,4,1,\"\"],systemerror:[58,4,1,\"\"],take:[59,4,1,\"\"],takebuf_array:[64,4,1,\"\"],takebuf_string:[64,4,1,\"\"],tan:[68,4,1,\"\"],tand:[68,4,1,\"\"],tanh:[68,4,1,\"\"],task_local_storage:[70,4,1,\"\"],tempdir:[62,4,1,\"\"],tempname:[62,4,1,\"\"],tic:[57,4,1,\"\"],time:[57,4,1,\"\"],time_ns:[57,4,1,\"\"],timedwait:[70,4,1,\"\"],toc:[57,4,1,\"\"],toq:[57,4,1,\"\"],touch:[62,4,1,\"\"],trace:[67,4,1,\"\"],trailing_ones:[69,4,1,\"\"],trailing_zeros:[69,4,1,\"\"],transpose:[67,4,1,\"\"],trigamma:[68,4,1,\"\"],tril:[67,4,1,\"\"],triu:[67,4,1,\"\"],trues:[56,4,1,\"\"],trunc:[68,4,1,\"\"],truncate:[64,4,1,\"\"],tryparse:[69,4,1,\"\"],tuple:[57,4,1,\"\"],typeintersect:[57,4,1,\"\"],typejoin:[57,4,1,\"\"],typemax:[57,4,1,\"\"],typemin:[57,4,1,\"\"],ucfirst:[75,4,1,\"\"],unescape_string:[75,4,1,\"\"],union:[59,4,1,\"\"],unique:[59,4,1,\"\"],unlock:[70,4,1,\"\"],unmark:[64,4,1,\"\"],unsafe_convert:[58,4,1,\"\"],unsafe_load:[58,4,1,\"\"],unsafe_pointer_to_objref:[58,4,1,\"\"],unsafe_trunc:[68,4,1,\"\"],unsigned:[69,4,1,\"\"],uperm:[62,4,1,\"\"],uppercase:[75,4,1,\"\"],utf16:[75,4,1,\"\"],utf32:[75,4,1,\"\"],utf8:[75,4,1,\"\"],valtype:[59,4,1,\"\"],values:[59,4,1,\"\"],varm:[68,4,1,\"\"],vcat:[56,4,1,\"\"],vec:[56,4,1,\"\"],vecdot:[67,4,1,\"\"],vecnorm:[67,4,1,\"\"],versioninfo:[57,4,1,\"\"],wait:[70,4,1,\"\"],warn:[64,4,1,\"\"],watch_file:[64,4,1,\"\"],which:[57,4,1,\"\"],whos:[57,4,1,\"\"],widemul:[68,4,1,\"\"],widen:[57,4,1,\"\"],with_bigfloat_precision:[69,4,1,\"\"],with_rounding:[69,4,1,\"\"],withenv:[57,4,1,\"\"],workers:[70,4,1,\"\"],workspace:[57,4,1,\"\"],write:[64,4,1,\"\"],writecsv:[64,4,1,\"\"],writedlm:[64,4,1,\"\"],writemime:[64,4,1,\"\"],wstring:[75,4,1,\"\"],xcorr:[68,4,1,\"\"],xdump:[64,4,1,\"\"],yield:[70,4,1,\"\"],yieldto:[70,4,1,\"\"],zero:[69,4,1,\"\"],zeros:[56,4,1,\"\"],zeta:[68,4,1,\"\"],zip:[59,4,1,\"\"]},Dates:{\"UTInstant{T}\":[61,5,1,\"\"],\"default\":[61,4,1,\"\"],\"recur{T<:TimeType}\":[61,4,1,\"\"],Date:[61,5,1,\"\"],DateTime:[61,5,1,\"\"],Day:[61,5,1,\"\"],Hour:[61,5,1,\"\"],Instant:[61,5,1,\"\"],Millisecond:[61,5,1,\"\"],Minute:[61,5,1,\"\"],Month:[61,5,1,\"\"],Period:[61,5,1,\"\"],Second:[61,5,1,\"\"],TimeType:[61,5,1,\"\"],Week:[61,5,1,\"\"],Year:[61,5,1,\"\"],datetime2julian:[61,4,1,\"\"],datetime2rata:[61,4,1,\"\"],datetime2unix:[61,4,1,\"\"],day:[61,4,1,\"\"],dayabbr:[61,4,1,\"\"],dayname:[61,4,1,\"\"],dayofquarter:[61,4,1,\"\"],dayofweek:[61,4,1,\"\"],dayofweekofmonth:[61,4,1,\"\"],dayofyear:[61,4,1,\"\"],daysinmonth:[61,4,1,\"\"],daysinyear:[61,4,1,\"\"],daysofweekinmonth:[61,4,1,\"\"],eps:[61,4,1,\"\"],firstdayofmonth:[61,4,1,\"\"],firstdayofquarter:[61,4,1,\"\"],firstdayofweek:[61,4,1,\"\"],firstdayofyear:[61,4,1,\"\"],hour:[61,4,1,\"\"],isleapyear:[61,4,1,\"\"],julian2datetime:[61,4,1,\"\"],lastdayofmonth:[61,4,1,\"\"],lastdayofquarter:[61,4,1,\"\"],lastdayofweek:[61,4,1,\"\"],lastdayofyear:[61,4,1,\"\"],millisecond:[61,4,1,\"\"],minute:[61,4,1,\"\"],month:[61,4,1,\"\"],monthabbr:[61,4,1,\"\"],monthday:[61,4,1,\"\"],monthname:[61,4,1,\"\"],now:[61,4,1,\"\"],quarterofyear:[61,4,1,\"\"],rata2datetime:[61,4,1,\"\"],second:[61,4,1,\"\"],today:[61,4,1,\"\"],tofirst:[61,4,1,\"\"],tolast:[61,4,1,\"\"],tonext:[61,4,1,\"\"],toprev:[61,4,1,\"\"],trunc:[61,4,1,\"\"],unix2datetime:[61,4,1,\"\"],week:[61,4,1,\"\"],year:[61,4,1,\"\"],yearmonth:[61,4,1,\"\"],yearmonthday:[61,4,1,\"\"]},Libc:{FormatMessage:[65,4,1,\"\"],GetLastError:[65,4,1,\"\"],MS_ASYNC:[65,5,1,\"\"],MS_INVALIDATE:[65,5,1,\"\"],MS_SYNC:[65,5,1,\"\"],TmStruct:[65,4,1,\"\"],calloc:[65,4,1,\"\"],errno:[65,4,1,\"\"],flush_cstdio:[65,4,1,\"\"],free:[65,4,1,\"\"],malloc:[65,4,1,\"\"],msync:[65,4,1,\"\"],realloc:[65,4,1,\"\"],strerror:[65,4,1,\"\"],strftime:[65,4,1,\"\"],strptime:[65,4,1,\"\"],time:[65,4,1,\"\"]},Libdl:{DL_LOAD_PATH:[66,5,1,\"\"],RTLD_DEEPBIND:[66,5,1,\"\"],RTLD_FIRST:[66,5,1,\"\"],RTLD_GLOBAL:[66,5,1,\"\"],RTLD_LAZY:[66,5,1,\"\"],RTLD_LOCAL:[66,5,1,\"\"],RTLD_NODELETE:[66,5,1,\"\"],RTLD_NOLOAD:[66,5,1,\"\"],RTLD_NOW:[66,5,1,\"\"],dlclose:[66,4,1,\"\"],dlext:[66,5,1,\"\"],dlopen:[66,4,1,\"\"],dlopen_e:[66,4,1,\"\"],dlsym:[66,4,1,\"\"],dlsym_e:[66,4,1,\"\"],find_library:[66,4,1,\"\"]}},objnames:{\"0\":[\"py\",\"module\",\"Python module\"],\"1\":[\"py\",\"function\",\"Python function\"],\"2\":[\"py\",\"data\",\"Python data\"],\"3\":[\"jl\",\"module\",\"Julia module\"],\"4\":[\"jl\",\"function\",\"Julia function\"],\"5\":[\"jl\",\"data\",\"Julia data\"]},objtypes:{\"0\":\"py:module\",\"1\":\"py:function\",\"2\":\"py:data\",\"3\":\"jl:module\",\"4\":\"jl:function\",\"5\":\"jl:data\"},terms:{\"0000001f\":46,\"00025f0\":33,\"000_000_005\":33,\"000a1\":52,\"000a3\":52,\"000a5\":52,\"000a6\":52,\"000a7\":52,\"000a8\":52,\"000a9\":52,\"000aa\":52,\"000ac\":52,\"000ae\":52,\"000af\":52,\"000b0\":52,\"000b1\":52,\"000b2\":52,\"000b3\":52,\"000b4\":52,\"000b6\":52,\"000b7\":52,\"000b9\":52,\"000ba\":52,\"000bc\":52,\"000bd\":52,\"000be\":52,\"000bf\":52,\"000c5\":52,\"000c6\":52,\"000d0\":52,\"000d7\":52,\"000d8\":52,\"000de\":52,\"000df\":52,\"000e5\":52,\"000e6\":52,\"000f0\":52,\"000f7\":52,\"000f8\":52,\"000fe\":52,\"0014a\":52,\"0014b\":52,\"0019e\":52,\"001b5\":52,\"001c2\":52,\"0025b\":52,\"0026c\":52,\"0026d\":52,\"0026f\":52,\"0027a\":52,\"0027b\":52,\"0027c\":52,\"0027d\":52,\"0027e\":52,\"0028a\":52,\"0028b\":52,\"0028c\":52,\"0028d\":52,\"0028e\":52,\"0029e\":52,\"002a4\":52,\"002a7\":52,\"002b0\":52,\"002b2\":52,\"002b3\":52,\"002b7\":52,\"002b8\":52,\"002bc\":52,\"002c7\":52,\"002c8\":52,\"002cc\":52,\"002d0\":52,\"002d1\":52,\"002d2\":52,\"002d3\":52,\"002d4\":52,\"002d5\":52,\"002d8\":52,\"002dc\":52,\"002e1\":52,\"002e2\":52,\"002e3\":52,\"0030a\":52,\"0030b\":52,\"0030c\":52,\"0031a\":52,\"0032a\":52,\"0039a\":52,\"0039b\":52,\"0039c\":52,\"0039d\":52,\"0039e\":52,\"0039f\":52,\"003a0\":52,\"003a1\":52,\"003a3\":52,\"003a4\":52,\"003a5\":52,\"003a6\":52,\"003a7\":52,\"003a8\":52,\"003a9\":52,\"003b1\":52,\"003b2\":52,\"003b3\":52,\"003b4\":52,\"003b5\":52,\"003b6\":52,\"003b7\":52,\"003b8\":52,\"003b9\":52,\"003ba\":52,\"003bb\":52,\"003bc\":52,\"003bd\":52,\"003be\":52,\"003bf\":52,\"003c0\":52,\"003c1\":52,\"003c2\":52,\"003c3\":52,\"003c4\":52,\"003c5\":52,\"003c6\":52,\"003c7\":52,\"003c8\":52,\"003c9\":52,\"003d0\":52,\"003d1\":52,\"003d5\":52,\"003d6\":52,\"003d8\":52,\"003d9\":52,\"003da\":52,\"003db\":52,\"003dc\":52,\"003dd\":52,\"003de\":52,\"003df\":52,\"003e0\":52,\"003e1\":52,\"003f0\":52,\"003f1\":52,\"003f4\":52,\"003f5\":52,\"003f6\":52,\"00a0\":53,\"01d2c\":52,\"01d2e\":52,\"01d30\":52,\"01d31\":52,\"01d33\":52,\"01d34\":52,\"01d35\":52,\"01d36\":52,\"01d37\":52,\"01d38\":52,\"01d39\":52,\"01d3a\":52,\"01d3c\":52,\"01d3e\":52,\"01d3f\":52,\"01d40\":52,\"01d41\":52,\"01d42\":52,\"01d43\":52,\"01d45\":52,\"01d47\":52,\"01d48\":52,\"01d49\":52,\"01d4b\":52,\"01d4d\":52,\"01d4f\":52,\"01d50\":52,\"01d52\":52,\"01d56\":52,\"01d57\":52,\"01d58\":52,\"01d5b\":52,\"01d5d\":52,\"01d5e\":52,\"01d5f\":52,\"01d60\":52,\"01d61\":52,\"01d62\":52,\"01d63\":52,\"01d64\":52,\"01d65\":52,\"01d66\":52,\"01d67\":52,\"01d68\":52,\"01d69\":52,\"01d6a\":52,\"01d9c\":52,\"01da0\":52,\"01da5\":52,\"01db2\":52,\"01dbb\":52,\"01dbf\":52,\"01t00\":[26,61],\"01t12\":[26,61],\"0200a\":52,\"0201b\":52,\"0201c\":52,\"0201d\":52,\"0203a\":52,\"0203c\":52,\"0207a\":52,\"0207b\":52,\"0207c\":52,\"0207d\":52,\"0207e\":52,\"0207f\":52,\"0208a\":52,\"0208b\":52,\"0208c\":52,\"0208d\":52,\"0208e\":52,\"0209a\":52,\"0209b\":52,\"0209c\":52,\"020a7\":52,\"020ac\":52,\"020d0\":52,\"020d1\":52,\"020d2\":52,\"020d6\":52,\"020d7\":52,\"020db\":52,\"020dc\":52,\"020dd\":52,\"020de\":52,\"020df\":52,\"020e1\":52,\"020e4\":52,\"020e7\":52,\"020e8\":52,\"020e9\":52,\"020ec\":52,\"020ed\":52,\"020ee\":52,\"020ef\":52,\"020f0\":52,\"0210a\":52,\"0210b\":52,\"0210c\":52,\"0210d\":52,\"0210e\":52,\"0210f\":52,\"0211a\":52,\"0211b\":52,\"0211c\":52,\"0211d\":52,\"0211e\":52,\"0212b\":52,\"0212c\":52,\"0212d\":52,\"0212f\":52,\"0213c\":52,\"0213d\":52,\"0213e\":52,\"0213f\":52,\"0214a\":52,\"0214b\":52,\"0219a\":52,\"0219b\":52,\"0219e\":52,\"0219f\":52,\"021a0\":52,\"021a1\":52,\"021a2\":52,\"021a3\":52,\"021a4\":52,\"021a5\":52,\"021a6\":52,\"021a7\":52,\"021a8\":52,\"021a9\":52,\"021aa\":52,\"021ab\":52,\"021ac\":52,\"021ad\":52,\"021ae\":52,\"021af\":52,\"021b0\":52,\"021b1\":52,\"021b2\":52,\"021b3\":52,\"021b4\":52,\"021b5\":52,\"021b6\":52,\"021b7\":52,\"021b8\":52,\"021b9\":52,\"021ba\":52,\"021bb\":52,\"021bc\":52,\"021bd\":52,\"021be\":52,\"021bf\":52,\"021c0\":52,\"021c1\":52,\"021c2\":52,\"021c3\":52,\"021c4\":52,\"021c5\":52,\"021c6\":52,\"021c7\":52,\"021c8\":52,\"021c9\":52,\"021ca\":52,\"021cb\":52,\"021cc\":52,\"021cd\":52,\"021ce\":52,\"021cf\":52,\"021d0\":52,\"021d1\":52,\"021d2\":52,\"021d3\":52,\"021d4\":52,\"021d5\":52,\"021d6\":52,\"021d7\":52,\"021d8\":52,\"021d9\":52,\"021da\":52,\"021db\":52,\"021dc\":52,\"021dd\":52,\"021de\":52,\"021df\":52,\"021e0\":52,\"021e1\":52,\"021e2\":52,\"021e3\":52,\"021e4\":52,\"021e5\":52,\"021e6\":52,\"021e7\":52,\"021e8\":52,\"021e9\":52,\"021ea\":52,\"021f4\":52,\"021f5\":52,\"021f6\":52,\"021f7\":52,\"021f8\":52,\"021f9\":52,\"021fa\":52,\"021fb\":52,\"021fc\":52,\"021fd\":52,\"021fe\":52,\"021ff\":52,\"0220a\":52,\"0220b\":52,\"0220c\":52,\"0220d\":52,\"0220e\":52,\"0220f\":52,\"0221a\":52,\"0221b\":52,\"0221c\":52,\"0221d\":52,\"0221e\":52,\"0221f\":52,\"0222a\":52,\"0222b\":52,\"0222c\":52,\"0222d\":52,\"0222e\":52,\"0222f\":52,\"0223a\":52,\"0223b\":52,\"0223c\":52,\"0223d\":52,\"0223e\":52,\"0223f\":52,\"0224a\":52,\"0224b\":52,\"0224c\":52,\"0224d\":52,\"0224e\":52,\"0224f\":52,\"0225a\":52,\"0225b\":52,\"0225c\":52,\"0225d\":52,\"0225e\":52,\"0225f\":52,\"0226a\":52,\"0226b\":52,\"0226c\":52,\"0226d\":52,\"0226e\":52,\"0226f\":52,\"0227a\":52,\"0227b\":52,\"0227c\":52,\"0227d\":52,\"0227e\":52,\"0227f\":52,\"0228a\":52,\"0228b\":52,\"0228d\":52,\"0228e\":52,\"0228f\":52,\"0229a\":52,\"0229b\":52,\"0229c\":52,\"0229d\":52,\"0229e\":52,\"0229f\":52,\"022a0\":52,\"022a1\":52,\"022a2\":52,\"022a3\":52,\"022a4\":52,\"022a5\":52,\"022a7\":52,\"022a8\":52,\"022a9\":52,\"022aa\":52,\"022ab\":52,\"022ac\":52,\"022ad\":52,\"022ae\":52,\"022af\":52,\"022b0\":52,\"022b1\":52,\"022b2\":52,\"022b3\":52,\"022b4\":52,\"022b5\":52,\"022b6\":52,\"022b7\":52,\"022b8\":52,\"022b9\":52,\"022ba\":52,\"022bb\":52,\"022bc\":52,\"022bd\":52,\"022be\":52,\"022bf\":52,\"022c0\":52,\"022c1\":52,\"022c2\":52,\"022c3\":52,\"022c4\":52,\"022c5\":52,\"022c6\":52,\"022c7\":52,\"022c8\":52,\"022c9\":52,\"022ca\":52,\"022cb\":52,\"022cc\":52,\"022cd\":52,\"022ce\":52,\"022cf\":52,\"022d0\":52,\"022d1\":52,\"022d2\":52,\"022d3\":52,\"022d4\":52,\"022d5\":52,\"022d6\":52,\"022d7\":52,\"022d8\":52,\"022d9\":52,\"022da\":52,\"022db\":52,\"022dc\":52,\"022dd\":52,\"022de\":52,\"022df\":52,\"022e0\":52,\"022e1\":52,\"022e2\":52,\"022e3\":52,\"022e4\":52,\"022e5\":52,\"022e6\":52,\"022e7\":52,\"022e8\":52,\"022e9\":52,\"022ea\":52,\"022eb\":52,\"022ec\":52,\"022ed\":52,\"022ee\":52,\"022ef\":52,\"022f0\":52,\"022f1\":52,\"022f2\":52,\"022f3\":52,\"022f4\":52,\"022f5\":52,\"022f6\":52,\"022f7\":52,\"022f8\":52,\"022f9\":52,\"022fa\":52,\"022fb\":52,\"022fc\":52,\"022fd\":52,\"022fe\":52,\"022ff\":52,\"0230a\":52,\"0230b\":52,\"0231a\":52,\"0231b\":52,\"0231c\":52,\"0231d\":52,\"0231e\":52,\"0231f\":52,\"0232c\":52,\"0233d\":52,\"0233f\":52,\"023a3\":52,\"023b0\":52,\"023b1\":52,\"023b4\":52,\"023b5\":52,\"023b6\":52,\"023b7\":52,\"023b8\":52,\"023b9\":52,\"023ce\":52,\"023de\":52,\"023df\":52,\"023e2\":52,\"023e3\":52,\"023e4\":52,\"023e5\":52,\"023e6\":52,\"023e7\":52,\"023e9\":52,\"023ea\":52,\"023eb\":52,\"023ec\":52,\"023f0\":52,\"023f3\":52,\"024c2\":52,\"024c8\":52,\"0258c\":52,\"025a0\":52,\"025a1\":52,\"025a2\":52,\"025a3\":52,\"025a4\":52,\"025a5\":52,\"025a6\":52,\"025a7\":52,\"025a8\":52,\"025a9\":52,\"025aa\":52,\"025ab\":52,\"025ac\":52,\"025ad\":52,\"025ae\":52,\"025af\":52,\"025b0\":52,\"025b1\":52,\"025b2\":52,\"025b3\":52,\"025b4\":52,\"025b5\":52,\"025b6\":52,\"025b9\":52,\"025ba\":52,\"025bb\":52,\"025bc\":52,\"025bd\":52,\"025be\":52,\"025bf\":52,\"025c0\":52,\"025c3\":52,\"025c4\":52,\"025c5\":52,\"025c6\":52,\"025c7\":52,\"025c8\":52,\"025c9\":52,\"025ca\":52,\"025cb\":52,\"025cc\":52,\"025cd\":52,\"025ce\":52,\"025cf\":52,\"025d0\":52,\"025d1\":52,\"025d2\":52,\"025d3\":52,\"025d4\":52,\"025d5\":52,\"025d6\":52,\"025d7\":52,\"025d8\":52,\"025d9\":52,\"025da\":52,\"025db\":52,\"025dc\":52,\"025dd\":52,\"025de\":52,\"025df\":52,\"025e0\":52,\"025e1\":52,\"025e2\":52,\"025e3\":52,\"025e4\":52,\"025e5\":52,\"025e6\":52,\"025e7\":52,\"025e8\":52,\"025e9\":52,\"025ea\":52,\"025eb\":52,\"025ec\":52,\"025ed\":52,\"025ee\":52,\"025ef\":52,\"025f0\":52,\"025f1\":52,\"025f2\":52,\"025f3\":52,\"025f4\":52,\"025f5\":52,\"025f6\":52,\"025f7\":52,\"025f8\":52,\"025f9\":52,\"025fa\":52,\"025fb\":52,\"025fc\":52,\"025fd\":52,\"025fe\":52,\"025ff\":52,\"0260e\":52,\"0261d\":52,\"0263a\":52,\"0263b\":52,\"0263c\":52,\"0263d\":52,\"0263f\":52,\"0264a\":52,\"0264b\":52,\"0264c\":52,\"0264d\":52,\"0264e\":52,\"0264f\":52,\"0266a\":52,\"0266b\":52,\"0266d\":52,\"0266e\":52,\"0266f\":52,\"0267b\":52,\"0267e\":52,\"0267f\":52,\"026a0\":52,\"026a1\":52,\"026a5\":52,\"026aa\":52,\"026ab\":52,\"026ac\":52,\"026b2\":52,\"026bd\":52,\"026be\":52,\"026c4\":52,\"026c5\":52,\"026ce\":52,\"026d4\":52,\"026ea\":52,\"026f2\":52,\"026f3\":52,\"026f5\":52,\"026fa\":52,\"026fd\":52,\"0270a\":52,\"0270b\":52,\"0270c\":52,\"0270f\":52,\"0272a\":52,\"0273d\":52,\"0274c\":52,\"0274e\":52,\"0279b\":52,\"027a1\":52,\"027b0\":52,\"027bf\":52,\"027c0\":52,\"027c1\":52,\"027c2\":52,\"027c8\":52,\"027c9\":52,\"027d1\":52,\"027d2\":52,\"027d8\":52,\"027d9\":52,\"027e6\":52,\"027e7\":52,\"027e8\":52,\"027e9\":52,\"027f0\":52,\"027f1\":52,\"027f5\":52,\"027f6\":52,\"027f7\":52,\"027f8\":52,\"027f9\":52,\"027fa\":52,\"027fb\":52,\"027fc\":52,\"027fd\":52,\"027fe\":52,\"027ff\":52,\"0290a\":52,\"0290b\":52,\"0290c\":52,\"0290d\":52,\"0290e\":52,\"0290f\":52,\"0291d\":52,\"0291e\":52,\"0291f\":52,\"0292a\":52,\"0292b\":52,\"0292c\":52,\"0292d\":52,\"0292e\":52,\"0292f\":52,\"0294a\":52,\"0294b\":52,\"0294c\":52,\"0294d\":52,\"0294e\":52,\"0294f\":52,\"0295a\":52,\"0295b\":52,\"0295c\":52,\"0295d\":52,\"0295e\":52,\"0295f\":52,\"0296a\":52,\"0296b\":52,\"0296c\":52,\"0296d\":52,\"0296e\":52,\"0296f\":52,\"0299b\":52,\"0299c\":52,\"0299d\":52,\"0299e\":52,\"0299f\":52,\"029a0\":52,\"029a1\":52,\"029a2\":52,\"029a3\":52,\"029a4\":52,\"029a5\":52,\"029a6\":52,\"029a7\":52,\"029a8\":52,\"029a9\":52,\"029aa\":52,\"029ab\":52,\"029ac\":52,\"029ad\":52,\"029ae\":52,\"029af\":52,\"029b0\":52,\"029b1\":52,\"029b2\":52,\"029b3\":52,\"029b4\":52,\"029b7\":52,\"029b8\":52,\"029bc\":52,\"029be\":52,\"029bf\":52,\"029c0\":52,\"029c1\":52,\"029c4\":52,\"029c5\":52,\"029c6\":52,\"029c7\":52,\"029ca\":52,\"029cb\":52,\"029cf\":52,\"029d0\":52,\"029df\":52,\"029e1\":52,\"029e2\":52,\"029e3\":52,\"029e4\":52,\"029e5\":52,\"029eb\":52,\"029f4\":52,\"029f6\":52,\"029f7\":52,\"029fa\":52,\"029fb\":52,\"02a00\":52,\"02a01\":52,\"02a02\":52,\"02a03\":52,\"02a04\":52,\"02a05\":52,\"02a06\":52,\"02a07\":52,\"02a08\":52,\"02a09\":52,\"02a0a\":52,\"02a0b\":52,\"02a0c\":52,\"02a0d\":52,\"02a0e\":52,\"02a0f\":52,\"02a10\":52,\"02a11\":52,\"02a12\":52,\"02a13\":52,\"02a14\":52,\"02a15\":52,\"02a16\":52,\"02a18\":52,\"02a19\":52,\"02a1a\":52,\"02a1b\":52,\"02a1c\":52,\"02a22\":52,\"02a23\":52,\"02a24\":52,\"02a25\":52,\"02a26\":52,\"02a27\":52,\"02a28\":52,\"02a29\":52,\"02a2a\":52,\"02a2b\":52,\"02a2c\":52,\"02a2d\":52,\"02a2e\":52,\"02a2f\":52,\"02a30\":52,\"02a31\":52,\"02a32\":52,\"02a33\":52,\"02a34\":52,\"02a35\":52,\"02a36\":52,\"02a37\":52,\"02a38\":52,\"02a39\":52,\"02a3a\":52,\"02a3b\":52,\"02a3c\":52,\"02a3d\":52,\"02a3f\":52,\"02a40\":52,\"02a41\":52,\"02a42\":52,\"02a43\":52,\"02a44\":52,\"02a45\":52,\"02a4a\":52,\"02a4b\":52,\"02a4c\":52,\"02a4d\":52,\"02a4e\":52,\"02a4f\":52,\"02a50\":52,\"02a51\":52,\"02a52\":52,\"02a53\":52,\"02a54\":52,\"02a55\":52,\"02a56\":52,\"02a57\":52,\"02a58\":52,\"02a5a\":52,\"02a5b\":52,\"02a5c\":52,\"02a5d\":52,\"02a5e\":52,\"02a5f\":52,\"02a60\":52,\"02a61\":52,\"02a62\":52,\"02a63\":52,\"02a66\":52,\"02a67\":52,\"02a6a\":52,\"02a6b\":52,\"02a6c\":52,\"02a6d\":52,\"02a6e\":52,\"02a6f\":52,\"02a70\":52,\"02a71\":52,\"02a72\":52,\"02a73\":52,\"02a74\":52,\"02a75\":52,\"02a76\":52,\"02a77\":52,\"02a78\":52,\"02a79\":52,\"02a7a\":52,\"02a7b\":52,\"02a7c\":52,\"02a7d\":52,\"02a7e\":52,\"02a7f\":52,\"02a80\":52,\"02a81\":52,\"02a82\":52,\"02a83\":52,\"02a84\":52,\"02a85\":52,\"02a86\":52,\"02a87\":52,\"02a88\":52,\"02a89\":52,\"02a8a\":52,\"02a8b\":52,\"02a8c\":52,\"02a8d\":52,\"02a8e\":52,\"02a8f\":52,\"02a90\":52,\"02a91\":52,\"02a92\":52,\"02a93\":52,\"02a94\":52,\"02a95\":52,\"02a96\":52,\"02a97\":52,\"02a98\":52,\"02a99\":52,\"02a9a\":52,\"02a9b\":52,\"02a9c\":52,\"02a9d\":52,\"02a9e\":52,\"02a9f\":52,\"02aa0\":52,\"02aa1\":52,\"02aa2\":52,\"02aa3\":52,\"02aa4\":52,\"02aa5\":52,\"02aa6\":52,\"02aa7\":52,\"02aa8\":52,\"02aa9\":52,\"02aaa\":52,\"02aab\":52,\"02aac\":52,\"02aad\":52,\"02aae\":52,\"02aaf\":52,\"02ab0\":52,\"02ab1\":52,\"02ab2\":52,\"02ab3\":52,\"02ab4\":52,\"02ab5\":52,\"02ab6\":52,\"02ab7\":52,\"02ab8\":52,\"02ab9\":52,\"02aba\":52,\"02abb\":52,\"02abc\":52,\"02abd\":52,\"02abe\":52,\"02abf\":52,\"02ac0\":52,\"02ac1\":52,\"02ac2\":52,\"02ac3\":52,\"02ac4\":52,\"02ac5\":52,\"02ac6\":52,\"02ac7\":52,\"02ac8\":52,\"02ac9\":52,\"02aca\":52,\"02acb\":52,\"02acc\":52,\"02acd\":52,\"02ace\":52,\"02acf\":52,\"02ad0\":52,\"02ad1\":52,\"02ad2\":52,\"02ad3\":52,\"02ad4\":52,\"02ad5\":52,\"02ad6\":52,\"02ad7\":52,\"02ad8\":52,\"02ad9\":52,\"02adb\":52,\"02adc\":52,\"02add\":52,\"02ae3\":52,\"02ae4\":52,\"02af4\":52,\"02af6\":52,\"02af7\":52,\"02af8\":52,\"02af9\":52,\"02afa\":52,\"02b05\":52,\"02b06\":52,\"02b07\":52,\"02b12\":52,\"02b13\":52,\"02b14\":52,\"02b15\":52,\"02b16\":52,\"02b17\":52,\"02b18\":52,\"02b19\":52,\"02b1a\":52,\"02b1b\":52,\"02b1c\":52,\"02b1d\":52,\"02b1e\":52,\"02b1f\":52,\"02b20\":52,\"02b21\":52,\"02b22\":52,\"02b23\":52,\"02b24\":52,\"02b25\":52,\"02b26\":52,\"02b27\":52,\"02b28\":52,\"02b29\":52,\"02b2a\":52,\"02b2b\":52,\"02b2c\":52,\"02b2d\":52,\"02b2e\":52,\"02b2f\":52,\"02b30\":52,\"02b31\":52,\"02b32\":52,\"02b33\":52,\"02b34\":52,\"02b35\":52,\"02b36\":52,\"02b37\":52,\"02b38\":52,\"02b39\":52,\"02b3a\":52,\"02b3b\":52,\"02b3c\":52,\"02b3d\":52,\"02b3e\":52,\"02b3f\":52,\"02b40\":52,\"02b41\":52,\"02b42\":52,\"02b43\":52,\"02b44\":52,\"02b45\":52,\"02b46\":52,\"02b47\":52,\"02b48\":52,\"02b49\":52,\"02b4a\":52,\"02b4b\":52,\"02b4c\":52,\"02b50\":52,\"02b51\":52,\"02b52\":52,\"02b53\":52,\"02b54\":52,\"02b55\":52,\"02c7c\":52,\"02c7d\":52,\"0303d\":52,\"0518977991518im\":22,\"08708053414102428im\":22,\"0b10\":33,\"0b1011_0010\":33,\"0e10\":33,\"0f0\":[33,43,46],\"0fe00\":52,\"0im\":[22,24,25,29],\"0mq\":45,\"0o10\":33,\"0o777\":62,\"0x0\":43,\"0x00\":[42,43],\"0x000\":43,\"0x0000\":43,\"0x00007f418d0816b8\":21,\"0x00007f5998a04370\":16,\"0x00007f5998a570d0\":16,\"0x00007fcc7de64850\":16,\"0x00007fcc80c4d930\":16,\"0x00007ffde56bd01a\":4,\"0x00007fff5fbffc45\":21,\"0x00007ffff6541154\":4,\"0x00007ffff65412fe\":4,\"0x00007ffff7928bf7\":4,\"0x000f\":43,\"0x01\":[33,38],\"0x01020304\":64,\"0x0123\":33,\"0x01234567\":33,\"0x0123456789abcdef\":33,\"0x02\":33,\"0x04030201\":64,\"0x08\":33,\"0x0c\":25,\"0x1\":33,\"0x110000\":49,\"0x123\":33,\"0x1234567\":33,\"0x123456789abcdef\":33,\"0x1289d070\":4,\"0x1p0\":33,\"0x2812060\":4,\"0x41\":49,\"0x44\":49,\"0x54\":49,\"0x61\":42,\"0x62\":42,\"0x63\":42,\"0x64\":42,\"0x7ffde56be000\":4,\"0x7ffdf35e8010\":16,\"0x7ffdf367f630\":4,\"0x7ffdf39b1030\":4,\"0x7ffdf42de400\":4,\"0x7ffdf7409150\":16,\"0x7ffdf74091b0\":16,\"0x7ffdf74d7a90\":16,\"0x7ffdf74d7af0\":16,\"0x7ffff6dcb07d\":16,\"0x7fffffffc2b0\":4,\"0x7fffffffcc70\":16,\"0x7fffffffcc90\":16,\"0x80\":49,\"0x84\":38,\"0x88\":49,\"0xb2\":33,\"0xbf\":49,\"0xc3\":49,\"0xdead_beef\":33,\"0xdeadbeef\":33,\"0xe2\":49,\"0xf\":43,\"0xf0\":43,\"0xff\":[33,49],\"0xfff0\":43,\"0xffffff84\":38,\"0xfffffffffffffffff\":1,\"1000x\":4,\"10_000\":33,\"10ffff\":49,\"10x10\":[20,56],\"1368683772161603e\":33,\"13ghz\":2,\"15im\":22,\"15t00\":61,\"18425e\":56,\"1920929f\":33,\"1d400\":52,\"1d401\":52,\"1d402\":52,\"1d403\":52,\"1d404\":52,\"1d405\":52,\"1d406\":52,\"1d407\":52,\"1d408\":52,\"1d409\":52,\"1d40a\":52,\"1d40b\":52,\"1d40c\":52,\"1d40d\":52,\"1d40e\":52,\"1d40f\":52,\"1d410\":52,\"1d411\":52,\"1d412\":52,\"1d413\":52,\"1d414\":52,\"1d415\":52,\"1d416\":52,\"1d417\":52,\"1d418\":52,\"1d419\":52,\"1d41a\":52,\"1d41b\":52,\"1d41c\":52,\"1d41d\":52,\"1d41e\":52,\"1d41f\":52,\"1d420\":52,\"1d421\":52,\"1d422\":52,\"1d423\":52,\"1d424\":52,\"1d425\":52,\"1d426\":52,\"1d427\":52,\"1d428\":52,\"1d429\":52,\"1d42a\":52,\"1d42b\":52,\"1d42c\":52,\"1d42d\":52,\"1d42e\":52,\"1d42f\":52,\"1d430\":52,\"1d431\":52,\"1d432\":52,\"1d433\":52,\"1d434\":52,\"1d435\":52,\"1d436\":52,\"1d437\":52,\"1d438\":52,\"1d439\":52,\"1d43a\":52,\"1d43b\":52,\"1d43c\":52,\"1d43d\":52,\"1d43e\":52,\"1d43f\":52,\"1d440\":52,\"1d441\":52,\"1d442\":52,\"1d443\":52,\"1d444\":52,\"1d445\":52,\"1d446\":52,\"1d447\":52,\"1d448\":52,\"1d449\":52,\"1d44a\":52,\"1d44b\":52,\"1d44c\":52,\"1d44d\":52,\"1d44e\":52,\"1d44f\":52,\"1d450\":52,\"1d451\":52,\"1d452\":52,\"1d453\":52,\"1d454\":52,\"1d456\":52,\"1d457\":52,\"1d458\":52,\"1d459\":52,\"1d45a\":52,\"1d45b\":52,\"1d45c\":52,\"1d45d\":52,\"1d45e\":52,\"1d45f\":52,\"1d460\":52,\"1d461\":52,\"1d462\":52,\"1d463\":52,\"1d464\":52,\"1d465\":52,\"1d466\":52,\"1d467\":52,\"1d468\":52,\"1d469\":52,\"1d46a\":52,\"1d46b\":52,\"1d46c\":52,\"1d46d\":52,\"1d46e\":52,\"1d46f\":52,\"1d470\":52,\"1d471\":52,\"1d472\":52,\"1d473\":52,\"1d474\":52,\"1d475\":52,\"1d476\":52,\"1d477\":52,\"1d478\":52,\"1d479\":52,\"1d47a\":52,\"1d47b\":52,\"1d47c\":52,\"1d47d\":52,\"1d47e\":52,\"1d47f\":52,\"1d480\":52,\"1d481\":52,\"1d482\":52,\"1d483\":52,\"1d484\":52,\"1d485\":52,\"1d486\":52,\"1d487\":52,\"1d488\":52,\"1d489\":52,\"1d48a\":52,\"1d48b\":52,\"1d48c\":52,\"1d48d\":52,\"1d48e\":52,\"1d48f\":52,\"1d490\":52,\"1d491\":52,\"1d492\":52,\"1d493\":52,\"1d494\":52,\"1d495\":52,\"1d496\":52,\"1d497\":52,\"1d498\":52,\"1d499\":52,\"1d49a\":52,\"1d49b\":52,\"1d49c\":52,\"1d49e\":52,\"1d49f\":52,\"1d4a2\":52,\"1d4a5\":52,\"1d4a6\":52,\"1d4a9\":52,\"1d4aa\":52,\"1d4ab\":52,\"1d4ac\":52,\"1d4ae\":52,\"1d4af\":52,\"1d4b0\":52,\"1d4b1\":52,\"1d4b2\":52,\"1d4b3\":52,\"1d4b4\":52,\"1d4b5\":52,\"1d4b6\":52,\"1d4b7\":52,\"1d4b8\":52,\"1d4b9\":52,\"1d4bb\":52,\"1d4bd\":52,\"1d4be\":52,\"1d4bf\":52,\"1d4c0\":52,\"1d4c1\":52,\"1d4c2\":52,\"1d4c3\":52,\"1d4c5\":52,\"1d4c6\":52,\"1d4c7\":52,\"1d4c8\":52,\"1d4c9\":52,\"1d4ca\":52,\"1d4cb\":52,\"1d4cc\":52,\"1d4cd\":52,\"1d4ce\":52,\"1d4cf\":52,\"1d4d0\":52,\"1d4d1\":52,\"1d4d2\":52,\"1d4d3\":52,\"1d4d4\":52,\"1d4d5\":52,\"1d4d6\":52,\"1d4d7\":52,\"1d4d8\":52,\"1d4d9\":52,\"1d4da\":52,\"1d4db\":52,\"1d4dc\":52,\"1d4dd\":52,\"1d4de\":52,\"1d4df\":52,\"1d4e0\":52,\"1d4e1\":52,\"1d4e2\":52,\"1d4e3\":52,\"1d4e4\":52,\"1d4e5\":52,\"1d4e6\":52,\"1d4e7\":52,\"1d4e8\":52,\"1d4e9\":52,\"1d4ea\":52,\"1d4eb\":52,\"1d4ec\":52,\"1d4ed\":52,\"1d4ee\":52,\"1d4ef\":52,\"1d4f0\":52,\"1d4f1\":52,\"1d4f2\":52,\"1d4f3\":52,\"1d4f4\":52,\"1d4f5\":52,\"1d4f6\":52,\"1d4f7\":52,\"1d4f8\":52,\"1d4f9\":52,\"1d4fa\":52,\"1d4fb\":52,\"1d4fc\":52,\"1d4fd\":52,\"1d4fe\":52,\"1d4ff\":52,\"1d500\":52,\"1d501\":52,\"1d502\":52,\"1d503\":52,\"1d504\":52,\"1d505\":52,\"1d507\":52,\"1d508\":52,\"1d509\":52,\"1d50a\":52,\"1d50d\":52,\"1d50e\":52,\"1d50f\":52,\"1d510\":52,\"1d511\":52,\"1d512\":52,\"1d513\":52,\"1d514\":52,\"1d516\":52,\"1d517\":52,\"1d518\":52,\"1d519\":52,\"1d51a\":52,\"1d51b\":52,\"1d51c\":52,\"1d51e\":52,\"1d51f\":52,\"1d520\":52,\"1d521\":52,\"1d522\":52,\"1d523\":52,\"1d524\":52,\"1d525\":52,\"1d526\":52,\"1d527\":52,\"1d528\":52,\"1d529\":52,\"1d52a\":52,\"1d52b\":52,\"1d52c\":52,\"1d52d\":52,\"1d52e\":52,\"1d52f\":52,\"1d530\":52,\"1d531\":52,\"1d532\":52,\"1d533\":52,\"1d534\":52,\"1d535\":52,\"1d536\":52,\"1d537\":52,\"1d538\":52,\"1d539\":52,\"1d53b\":52,\"1d53c\":52,\"1d53d\":52,\"1d53e\":52,\"1d540\":52,\"1d541\":52,\"1d542\":52,\"1d543\":52,\"1d544\":52,\"1d546\":52,\"1d54a\":52,\"1d54b\":52,\"1d54c\":52,\"1d54d\":52,\"1d54e\":52,\"1d54f\":52,\"1d550\":52,\"1d552\":52,\"1d553\":52,\"1d554\":52,\"1d555\":52,\"1d556\":52,\"1d557\":52,\"1d558\":52,\"1d559\":52,\"1d55a\":52,\"1d55b\":52,\"1d55c\":52,\"1d55d\":52,\"1d55e\":52,\"1d55f\":52,\"1d560\":52,\"1d561\":52,\"1d562\":52,\"1d563\":52,\"1d564\":52,\"1d565\":52,\"1d566\":52,\"1d567\":52,\"1d568\":52,\"1d569\":52,\"1d56a\":52,\"1d56b\":52,\"1d56c\":52,\"1d56d\":52,\"1d56e\":52,\"1d56f\":52,\"1d570\":52,\"1d571\":52,\"1d572\":52,\"1d573\":52,\"1d574\":52,\"1d575\":52,\"1d576\":52,\"1d577\":52,\"1d578\":52,\"1d579\":52,\"1d57a\":52,\"1d57b\":52,\"1d57c\":52,\"1d57d\":52,\"1d57e\":52,\"1d57f\":52,\"1d580\":52,\"1d581\":52,\"1d582\":52,\"1d583\":52,\"1d584\":52,\"1d585\":52,\"1d586\":52,\"1d587\":52,\"1d588\":52,\"1d589\":52,\"1d58a\":52,\"1d58b\":52,\"1d58c\":52,\"1d58d\":52,\"1d58e\":52,\"1d58f\":52,\"1d590\":52,\"1d591\":52,\"1d592\":52,\"1d593\":52,\"1d594\":52,\"1d595\":52,\"1d596\":52,\"1d597\":52,\"1d598\":52,\"1d599\":52,\"1d59a\":52,\"1d59b\":52,\"1d59c\":52,\"1d59d\":52,\"1d59e\":52,\"1d59f\":52,\"1d5a0\":52,\"1d5a1\":52,\"1d5a2\":52,\"1d5a3\":52,\"1d5a4\":52,\"1d5a5\":52,\"1d5a6\":52,\"1d5a7\":52,\"1d5a8\":52,\"1d5a9\":52,\"1d5aa\":52,\"1d5ab\":52,\"1d5ac\":52,\"1d5ad\":52,\"1d5ae\":52,\"1d5af\":52,\"1d5b0\":52,\"1d5b1\":52,\"1d5b2\":52,\"1d5b3\":52,\"1d5b4\":52,\"1d5b5\":52,\"1d5b6\":52,\"1d5b7\":52,\"1d5b8\":52,\"1d5b9\":52,\"1d5ba\":52,\"1d5bb\":52,\"1d5bc\":52,\"1d5bd\":52,\"1d5be\":52,\"1d5bf\":52,\"1d5c0\":52,\"1d5c1\":52,\"1d5c2\":52,\"1d5c3\":52,\"1d5c4\":52,\"1d5c5\":52,\"1d5c6\":52,\"1d5c7\":52,\"1d5c8\":52,\"1d5c9\":52,\"1d5ca\":52,\"1d5cb\":52,\"1d5cc\":52,\"1d5cd\":52,\"1d5ce\":52,\"1d5cf\":52,\"1d5d0\":52,\"1d5d1\":52,\"1d5d2\":52,\"1d5d3\":52,\"1d5d4\":52,\"1d5d5\":52,\"1d5d6\":52,\"1d5d7\":52,\"1d5d8\":52,\"1d5d9\":52,\"1d5da\":52,\"1d5db\":52,\"1d5dc\":52,\"1d5dd\":52,\"1d5de\":52,\"1d5df\":52,\"1d5e0\":52,\"1d5e1\":52,\"1d5e2\":52,\"1d5e3\":52,\"1d5e4\":52,\"1d5e5\":52,\"1d5e6\":52,\"1d5e7\":52,\"1d5e8\":52,\"1d5e9\":52,\"1d5ea\":52,\"1d5eb\":52,\"1d5ec\":52,\"1d5ed\":52,\"1d5ee\":52,\"1d5ef\":52,\"1d5f0\":52,\"1d5f1\":52,\"1d5f2\":52,\"1d5f3\":52,\"1d5f4\":52,\"1d5f5\":52,\"1d5f6\":52,\"1d5f7\":52,\"1d5f8\":52,\"1d5f9\":52,\"1d5fa\":52,\"1d5fb\":52,\"1d5fc\":52,\"1d5fd\":52,\"1d5fe\":52,\"1d5ff\":52,\"1d600\":52,\"1d601\":52,\"1d602\":52,\"1d603\":52,\"1d604\":52,\"1d605\":52,\"1d606\":52,\"1d607\":52,\"1d608\":52,\"1d609\":52,\"1d60a\":52,\"1d60b\":52,\"1d60c\":52,\"1d60d\":52,\"1d60e\":52,\"1d60f\":52,\"1d610\":52,\"1d611\":52,\"1d612\":52,\"1d613\":52,\"1d614\":52,\"1d615\":52,\"1d616\":52,\"1d617\":52,\"1d618\":52,\"1d619\":52,\"1d61a\":52,\"1d61b\":52,\"1d61c\":52,\"1d61d\":52,\"1d61e\":52,\"1d61f\":52,\"1d620\":52,\"1d621\":52,\"1d622\":52,\"1d623\":52,\"1d624\":52,\"1d625\":52,\"1d626\":52,\"1d627\":52,\"1d628\":52,\"1d629\":52,\"1d62a\":52,\"1d62b\":52,\"1d62c\":52,\"1d62d\":52,\"1d62e\":52,\"1d62f\":52,\"1d630\":52,\"1d631\":52,\"1d632\":52,\"1d633\":52,\"1d634\":52,\"1d635\":52,\"1d636\":52,\"1d637\":52,\"1d638\":52,\"1d639\":52,\"1d63a\":52,\"1d63b\":52,\"1d63c\":52,\"1d63d\":52,\"1d63e\":52,\"1d63f\":52,\"1d640\":52,\"1d641\":52,\"1d642\":52,\"1d643\":52,\"1d644\":52,\"1d645\":52,\"1d646\":52,\"1d647\":52,\"1d648\":52,\"1d649\":52,\"1d64a\":52,\"1d64b\":52,\"1d64c\":52,\"1d64d\":52,\"1d64e\":52,\"1d64f\":52,\"1d650\":52,\"1d651\":52,\"1d652\":52,\"1d653\":52,\"1d654\":52,\"1d655\":52,\"1d656\":52,\"1d657\":52,\"1d658\":52,\"1d659\":52,\"1d65a\":52,\"1d65b\":52,\"1d65c\":52,\"1d65d\":52,\"1d65e\":52,\"1d65f\":52,\"1d660\":52,\"1d661\":52,\"1d662\":52,\"1d663\":52,\"1d664\":52,\"1d665\":52,\"1d666\":52,\"1d667\":52,\"1d668\":52,\"1d669\":52,\"1d66a\":52,\"1d66b\":52,\"1d66c\":52,\"1d66d\":52,\"1d66e\":52,\"1d66f\":52,\"1d670\":52,\"1d671\":52,\"1d672\":52,\"1d673\":52,\"1d674\":52,\"1d675\":52,\"1d676\":52,\"1d677\":52,\"1d678\":52,\"1d679\":52,\"1d67a\":52,\"1d67b\":52,\"1d67c\":52,\"1d67d\":52,\"1d67e\":52,\"1d67f\":52,\"1d680\":52,\"1d681\":52,\"1d682\":52,\"1d683\":52,\"1d684\":52,\"1d685\":52,\"1d686\":52,\"1d687\":52,\"1d688\":52,\"1d689\":52,\"1d68a\":52,\"1d68b\":52,\"1d68c\":52,\"1d68d\":52,\"1d68e\":52,\"1d68f\":52,\"1d690\":52,\"1d691\":52,\"1d692\":52,\"1d693\":52,\"1d694\":52,\"1d695\":52,\"1d696\":52,\"1d697\":52,\"1d698\":52,\"1d699\":52,\"1d69a\":52,\"1d69b\":52,\"1d69c\":52,\"1d69d\":52,\"1d69e\":52,\"1d69f\":52,\"1d6a0\":52,\"1d6a1\":52,\"1d6a2\":52,\"1d6a3\":52,\"1d6a4\":52,\"1d6a5\":52,\"1d6a8\":52,\"1d6a9\":52,\"1d6aa\":52,\"1d6ab\":52,\"1d6ac\":52,\"1d6ad\":52,\"1d6ae\":52,\"1d6af\":52,\"1d6b0\":52,\"1d6b1\":52,\"1d6b2\":52,\"1d6b3\":52,\"1d6b4\":52,\"1d6b5\":52,\"1d6b6\":52,\"1d6b7\":52,\"1d6b8\":52,\"1d6b9\":52,\"1d6ba\":52,\"1d6bb\":52,\"1d6bc\":52,\"1d6bd\":52,\"1d6be\":52,\"1d6bf\":52,\"1d6c0\":52,\"1d6c1\":52,\"1d6c2\":52,\"1d6c3\":52,\"1d6c4\":52,\"1d6c5\":52,\"1d6c6\":52,\"1d6c7\":52,\"1d6c8\":52,\"1d6c9\":52,\"1d6ca\":52,\"1d6cb\":52,\"1d6cc\":52,\"1d6cd\":52,\"1d6ce\":52,\"1d6cf\":52,\"1d6d0\":52,\"1d6d1\":52,\"1d6d2\":52,\"1d6d3\":52,\"1d6d4\":52,\"1d6d5\":52,\"1d6d6\":52,\"1d6d7\":52,\"1d6d8\":52,\"1d6d9\":52,\"1d6da\":52,\"1d6db\":52,\"1d6dc\":52,\"1d6dd\":52,\"1d6de\":52,\"1d6df\":52,\"1d6e0\":52,\"1d6e1\":52,\"1d6e2\":52,\"1d6e3\":52,\"1d6e4\":52,\"1d6e5\":52,\"1d6e6\":52,\"1d6e7\":52,\"1d6e8\":52,\"1d6e9\":52,\"1d6ea\":52,\"1d6eb\":52,\"1d6ec\":52,\"1d6ed\":52,\"1d6ee\":52,\"1d6ef\":52,\"1d6f0\":52,\"1d6f1\":52,\"1d6f2\":52,\"1d6f3\":52,\"1d6f4\":52,\"1d6f5\":52,\"1d6f6\":52,\"1d6f7\":52,\"1d6f8\":52,\"1d6f9\":52,\"1d6fa\":52,\"1d6fb\":52,\"1d6fc\":52,\"1d6fd\":52,\"1d6fe\":52,\"1d6ff\":52,\"1d700\":52,\"1d701\":52,\"1d702\":52,\"1d703\":52,\"1d704\":52,\"1d705\":52,\"1d706\":52,\"1d707\":52,\"1d708\":52,\"1d709\":52,\"1d70a\":52,\"1d70b\":52,\"1d70c\":52,\"1d70d\":52,\"1d70e\":52,\"1d70f\":52,\"1d710\":52,\"1d711\":52,\"1d712\":52,\"1d713\":52,\"1d714\":52,\"1d715\":52,\"1d716\":52,\"1d717\":52,\"1d718\":52,\"1d719\":52,\"1d71a\":52,\"1d71b\":52,\"1d71c\":52,\"1d71d\":52,\"1d71e\":52,\"1d71f\":52,\"1d720\":52,\"1d721\":52,\"1d722\":52,\"1d723\":52,\"1d724\":52,\"1d725\":52,\"1d726\":52,\"1d727\":52,\"1d728\":52,\"1d729\":52,\"1d72a\":52,\"1d72b\":52,\"1d72c\":52,\"1d72d\":52,\"1d72e\":52,\"1d72f\":52,\"1d730\":52,\"1d731\":52,\"1d732\":52,\"1d733\":52,\"1d734\":52,\"1d735\":52,\"1d736\":52,\"1d737\":52,\"1d738\":52,\"1d739\":52,\"1d73a\":52,\"1d73b\":52,\"1d73c\":52,\"1d73d\":52,\"1d73e\":52,\"1d73f\":52,\"1d740\":52,\"1d741\":52,\"1d742\":52,\"1d743\":52,\"1d744\":52,\"1d745\":52,\"1d746\":52,\"1d747\":52,\"1d748\":52,\"1d749\":52,\"1d74a\":52,\"1d74b\":52,\"1d74c\":52,\"1d74d\":52,\"1d74e\":52,\"1d74f\":52,\"1d750\":52,\"1d751\":52,\"1d752\":52,\"1d753\":52,\"1d754\":52,\"1d755\":52,\"1d756\":52,\"1d757\":52,\"1d758\":52,\"1d759\":52,\"1d75a\":52,\"1d75b\":52,\"1d75c\":52,\"1d75d\":52,\"1d75e\":52,\"1d75f\":52,\"1d760\":52,\"1d761\":52,\"1d762\":52,\"1d763\":52,\"1d764\":52,\"1d765\":52,\"1d766\":52,\"1d767\":52,\"1d768\":52,\"1d769\":52,\"1d76a\":52,\"1d76b\":52,\"1d76c\":52,\"1d76d\":52,\"1d76e\":52,\"1d76f\":52,\"1d770\":52,\"1d771\":52,\"1d772\":52,\"1d773\":52,\"1d774\":52,\"1d775\":52,\"1d776\":52,\"1d777\":52,\"1d778\":52,\"1d779\":52,\"1d77a\":52,\"1d77b\":52,\"1d77c\":52,\"1d77d\":52,\"1d77e\":52,\"1d77f\":52,\"1d780\":52,\"1d781\":52,\"1d782\":52,\"1d783\":52,\"1d784\":52,\"1d785\":52,\"1d786\":52,\"1d787\":52,\"1d788\":52,\"1d789\":52,\"1d78a\":52,\"1d78b\":52,\"1d78c\":52,\"1d78d\":52,\"1d78e\":52,\"1d78f\":52,\"1d790\":52,\"1d791\":52,\"1d792\":52,\"1d793\":52,\"1d794\":52,\"1d795\":52,\"1d796\":52,\"1d797\":52,\"1d798\":52,\"1d799\":52,\"1d79a\":52,\"1d79b\":52,\"1d79c\":52,\"1d79d\":52,\"1d79e\":52,\"1d79f\":52,\"1d7a0\":52,\"1d7a1\":52,\"1d7a2\":52,\"1d7a3\":52,\"1d7a4\":52,\"1d7a5\":52,\"1d7a6\":52,\"1d7a7\":52,\"1d7a8\":52,\"1d7a9\":52,\"1d7aa\":52,\"1d7ab\":52,\"1d7ac\":52,\"1d7ad\":52,\"1d7ae\":52,\"1d7af\":52,\"1d7b0\":52,\"1d7b1\":52,\"1d7b2\":52,\"1d7b3\":52,\"1d7b4\":52,\"1d7b5\":52,\"1d7b6\":52,\"1d7b7\":52,\"1d7b8\":52,\"1d7b9\":52,\"1d7ba\":52,\"1d7bb\":52,\"1d7bc\":52,\"1d7bd\":52,\"1d7be\":52,\"1d7bf\":52,\"1d7c0\":52,\"1d7c1\":52,\"1d7c2\":52,\"1d7c3\":52,\"1d7c4\":52,\"1d7c5\":52,\"1d7c6\":52,\"1d7c7\":52,\"1d7c8\":52,\"1d7c9\":52,\"1d7ca\":52,\"1d7cb\":52,\"1d7ce\":52,\"1d7cf\":52,\"1d7d0\":52,\"1d7d1\":52,\"1d7d2\":52,\"1d7d3\":52,\"1d7d4\":52,\"1d7d5\":52,\"1d7d6\":52,\"1d7d7\":52,\"1d7d8\":52,\"1d7d9\":52,\"1d7da\":52,\"1d7db\":52,\"1d7dc\":52,\"1d7dd\":52,\"1d7de\":52,\"1d7df\":52,\"1d7e0\":52,\"1d7e1\":52,\"1d7e2\":52,\"1d7e3\":52,\"1d7e4\":52,\"1d7e5\":52,\"1d7e6\":52,\"1d7e7\":52,\"1d7e8\":52,\"1d7e9\":52,\"1d7ea\":52,\"1d7eb\":52,\"1d7ec\":52,\"1d7ed\":52,\"1d7ee\":52,\"1d7ef\":52,\"1d7f0\":52,\"1d7f1\":52,\"1d7f2\":52,\"1d7f3\":52,\"1d7f4\":52,\"1d7f5\":52,\"1d7f6\":52,\"1d7f7\":52,\"1d7f8\":52,\"1d7f9\":52,\"1d7fa\":52,\"1d7fb\":52,\"1d7fc\":52,\"1d7fd\":52,\"1d7fe\":52,\"1d7ff\":52,\"1e10\":33,\"1f004\":52,\"1f0cf\":52,\"1f170\":52,\"1f171\":52,\"1f17e\":52,\"1f17f\":52,\"1f18e\":52,\"1f191\":52,\"1f192\":52,\"1f193\":52,\"1f194\":52,\"1f195\":52,\"1f196\":52,\"1f197\":52,\"1f198\":52,\"1f199\":52,\"1f19a\":52,\"1f201\":52,\"1f202\":52,\"1f21a\":52,\"1f22f\":52,\"1f232\":52,\"1f233\":52,\"1f234\":52,\"1f235\":52,\"1f236\":52,\"1f237\":52,\"1f238\":52,\"1f239\":52,\"1f23a\":52,\"1f250\":52,\"1f251\":52,\"1f300\":52,\"1f301\":52,\"1f302\":52,\"1f303\":52,\"1f304\":52,\"1f305\":52,\"1f306\":52,\"1f307\":52,\"1f308\":52,\"1f309\":52,\"1f30a\":52,\"1f30b\":52,\"1f30c\":52,\"1f30d\":52,\"1f30e\":52,\"1f30f\":52,\"1f310\":52,\"1f311\":52,\"1f312\":52,\"1f313\":52,\"1f314\":52,\"1f315\":52,\"1f316\":52,\"1f317\":52,\"1f318\":52,\"1f319\":52,\"1f31a\":52,\"1f31b\":52,\"1f31c\":52,\"1f31d\":52,\"1f31e\":52,\"1f31f\":52,\"1f320\":52,\"1f330\":52,\"1f331\":52,\"1f332\":52,\"1f333\":52,\"1f334\":52,\"1f335\":52,\"1f337\":52,\"1f338\":52,\"1f339\":52,\"1f33a\":52,\"1f33b\":52,\"1f33c\":52,\"1f33d\":52,\"1f33e\":52,\"1f33f\":52,\"1f340\":52,\"1f341\":52,\"1f342\":52,\"1f343\":52,\"1f344\":52,\"1f345\":52,\"1f346\":52,\"1f347\":52,\"1f348\":52,\"1f349\":52,\"1f34a\":52,\"1f34b\":52,\"1f34c\":52,\"1f34d\":52,\"1f34e\":52,\"1f34f\":52,\"1f350\":52,\"1f351\":52,\"1f352\":52,\"1f353\":52,\"1f354\":52,\"1f355\":52,\"1f356\":52,\"1f357\":52,\"1f358\":52,\"1f359\":52,\"1f35a\":52,\"1f35b\":52,\"1f35c\":52,\"1f35d\":52,\"1f35e\":52,\"1f35f\":52,\"1f360\":52,\"1f361\":52,\"1f362\":52,\"1f363\":52,\"1f364\":52,\"1f365\":52,\"1f366\":52,\"1f367\":52,\"1f368\":52,\"1f369\":52,\"1f36a\":52,\"1f36b\":52,\"1f36c\":52,\"1f36d\":52,\"1f36e\":52,\"1f36f\":52,\"1f370\":52,\"1f371\":52,\"1f372\":52,\"1f373\":52,\"1f374\":52,\"1f375\":52,\"1f376\":52,\"1f377\":52,\"1f378\":52,\"1f379\":52,\"1f37a\":52,\"1f37b\":52,\"1f37c\":52,\"1f380\":52,\"1f381\":52,\"1f382\":52,\"1f383\":52,\"1f384\":52,\"1f385\":52,\"1f386\":52,\"1f387\":52,\"1f388\":52,\"1f389\":52,\"1f38a\":52,\"1f38b\":52,\"1f38c\":52,\"1f38d\":52,\"1f38e\":52,\"1f38f\":52,\"1f390\":52,\"1f391\":52,\"1f392\":52,\"1f393\":52,\"1f3a0\":52,\"1f3a1\":52,\"1f3a2\":52,\"1f3a3\":52,\"1f3a4\":52,\"1f3a5\":52,\"1f3a6\":52,\"1f3a7\":52,\"1f3a8\":52,\"1f3a9\":52,\"1f3aa\":52,\"1f3ab\":52,\"1f3ac\":52,\"1f3ad\":52,\"1f3ae\":52,\"1f3af\":52,\"1f3b0\":52,\"1f3b1\":52,\"1f3b2\":52,\"1f3b3\":52,\"1f3b4\":52,\"1f3b5\":52,\"1f3b6\":52,\"1f3b7\":52,\"1f3b8\":52,\"1f3b9\":52,\"1f3ba\":52,\"1f3bb\":52,\"1f3bc\":52,\"1f3bd\":52,\"1f3be\":52,\"1f3bf\":52,\"1f3c0\":52,\"1f3c1\":52,\"1f3c2\":52,\"1f3c3\":52,\"1f3c4\":52,\"1f3c6\":52,\"1f3c7\":52,\"1f3c8\":52,\"1f3c9\":52,\"1f3ca\":52,\"1f3e0\":52,\"1f3e1\":52,\"1f3e2\":52,\"1f3e3\":52,\"1f3e4\":52,\"1f3e5\":52,\"1f3e6\":52,\"1f3e7\":52,\"1f3e8\":52,\"1f3e9\":52,\"1f3ea\":52,\"1f3eb\":52,\"1f3ec\":52,\"1f3ed\":52,\"1f3ee\":52,\"1f3ef\":52,\"1f3f0\":52,\"1f3fb\":52,\"1f3fc\":52,\"1f3fd\":52,\"1f3fe\":52,\"1f3ff\":52,\"1f400\":52,\"1f401\":52,\"1f402\":52,\"1f403\":52,\"1f404\":52,\"1f405\":52,\"1f406\":52,\"1f407\":52,\"1f408\":52,\"1f409\":52,\"1f40a\":52,\"1f40b\":52,\"1f40c\":52,\"1f40d\":52,\"1f40e\":52,\"1f40f\":52,\"1f410\":52,\"1f411\":52,\"1f412\":52,\"1f413\":52,\"1f414\":52,\"1f415\":52,\"1f416\":52,\"1f417\":52,\"1f418\":52,\"1f419\":52,\"1f41a\":52,\"1f41b\":52,\"1f41c\":52,\"1f41d\":52,\"1f41e\":52,\"1f41f\":52,\"1f420\":52,\"1f421\":52,\"1f422\":52,\"1f423\":52,\"1f424\":52,\"1f425\":52,\"1f426\":52,\"1f427\":52,\"1f428\":52,\"1f429\":52,\"1f42a\":52,\"1f42b\":52,\"1f42c\":52,\"1f42d\":52,\"1f42e\":52,\"1f42f\":52,\"1f430\":52,\"1f431\":52,\"1f432\":52,\"1f433\":52,\"1f434\":52,\"1f435\":52,\"1f436\":52,\"1f437\":52,\"1f438\":52,\"1f439\":52,\"1f43a\":52,\"1f43b\":52,\"1f43c\":52,\"1f43d\":52,\"1f43e\":52,\"1f440\":52,\"1f442\":52,\"1f443\":52,\"1f444\":52,\"1f445\":52,\"1f446\":52,\"1f447\":52,\"1f448\":52,\"1f449\":52,\"1f44a\":52,\"1f44b\":52,\"1f44c\":52,\"1f44d\":52,\"1f44e\":52,\"1f44f\":52,\"1f450\":52,\"1f451\":52,\"1f452\":52,\"1f453\":52,\"1f454\":52,\"1f455\":52,\"1f456\":52,\"1f457\":52,\"1f458\":52,\"1f459\":52,\"1f45a\":52,\"1f45b\":52,\"1f45c\":52,\"1f45d\":52,\"1f45e\":52,\"1f45f\":52,\"1f460\":52,\"1f461\":52,\"1f462\":52,\"1f463\":52,\"1f464\":52,\"1f465\":52,\"1f466\":52,\"1f467\":52,\"1f468\":52,\"1f469\":52,\"1f46a\":52,\"1f46b\":52,\"1f46c\":52,\"1f46d\":52,\"1f46e\":52,\"1f46f\":52,\"1f470\":52,\"1f471\":52,\"1f472\":52,\"1f473\":52,\"1f474\":52,\"1f475\":52,\"1f476\":52,\"1f477\":52,\"1f478\":52,\"1f479\":52,\"1f47a\":52,\"1f47b\":52,\"1f47c\":52,\"1f47d\":52,\"1f47e\":52,\"1f47f\":52,\"1f480\":52,\"1f481\":52,\"1f482\":52,\"1f483\":52,\"1f484\":52,\"1f485\":52,\"1f486\":52,\"1f487\":52,\"1f488\":52,\"1f489\":52,\"1f48a\":52,\"1f48b\":52,\"1f48c\":52,\"1f48d\":52,\"1f48e\":52,\"1f48f\":52,\"1f490\":52,\"1f491\":52,\"1f492\":52,\"1f493\":52,\"1f494\":52,\"1f495\":52,\"1f496\":52,\"1f497\":52,\"1f498\":52,\"1f499\":52,\"1f49a\":52,\"1f49b\":52,\"1f49c\":52,\"1f49d\":52,\"1f49e\":52,\"1f49f\":52,\"1f4a0\":52,\"1f4a1\":52,\"1f4a2\":52,\"1f4a3\":52,\"1f4a4\":52,\"1f4a5\":52,\"1f4a6\":52,\"1f4a7\":52,\"1f4a8\":52,\"1f4a9\":52,\"1f4aa\":52,\"1f4ab\":52,\"1f4ac\":52,\"1f4ad\":52,\"1f4ae\":52,\"1f4af\":52,\"1f4b0\":52,\"1f4b1\":52,\"1f4b2\":52,\"1f4b3\":52,\"1f4b4\":52,\"1f4b5\":52,\"1f4b6\":52,\"1f4b7\":52,\"1f4b8\":52,\"1f4b9\":52,\"1f4ba\":52,\"1f4bb\":52,\"1f4bc\":52,\"1f4bd\":52,\"1f4be\":52,\"1f4bf\":52,\"1f4c0\":52,\"1f4c1\":52,\"1f4c2\":52,\"1f4c3\":52,\"1f4c4\":52,\"1f4c5\":52,\"1f4c6\":52,\"1f4c7\":52,\"1f4c8\":52,\"1f4c9\":52,\"1f4ca\":52,\"1f4cb\":52,\"1f4cc\":52,\"1f4cd\":52,\"1f4ce\":52,\"1f4cf\":52,\"1f4d0\":52,\"1f4d1\":52,\"1f4d2\":52,\"1f4d3\":52,\"1f4d4\":52,\"1f4d5\":52,\"1f4d6\":52,\"1f4d7\":52,\"1f4d8\":52,\"1f4d9\":52,\"1f4da\":52,\"1f4db\":52,\"1f4dc\":52,\"1f4dd\":52,\"1f4de\":52,\"1f4df\":52,\"1f4e0\":52,\"1f4e1\":52,\"1f4e2\":52,\"1f4e3\":52,\"1f4e4\":52,\"1f4e5\":52,\"1f4e6\":52,\"1f4e7\":52,\"1f4e8\":52,\"1f4e9\":52,\"1f4ea\":52,\"1f4eb\":52,\"1f4ec\":52,\"1f4ed\":52,\"1f4ee\":52,\"1f4ef\":52,\"1f4f0\":52,\"1f4f1\":52,\"1f4f2\":52,\"1f4f3\":52,\"1f4f4\":52,\"1f4f5\":52,\"1f4f6\":52,\"1f4f7\":52,\"1f4f9\":52,\"1f4fa\":52,\"1f4fb\":52,\"1f4fc\":52,\"1f500\":52,\"1f501\":52,\"1f502\":52,\"1f503\":52,\"1f504\":52,\"1f505\":52,\"1f506\":52,\"1f507\":52,\"1f508\":52,\"1f509\":52,\"1f50a\":52,\"1f50b\":52,\"1f50c\":52,\"1f50d\":52,\"1f50e\":52,\"1f50f\":52,\"1f510\":52,\"1f511\":52,\"1f512\":52,\"1f513\":52,\"1f514\":52,\"1f515\":52,\"1f516\":52,\"1f517\":52,\"1f518\":52,\"1f519\":52,\"1f51a\":52,\"1f51b\":52,\"1f51c\":52,\"1f51d\":52,\"1f51e\":52,\"1f51f\":52,\"1f520\":52,\"1f521\":52,\"1f522\":52,\"1f523\":52,\"1f524\":52,\"1f525\":52,\"1f526\":52,\"1f527\":52,\"1f528\":52,\"1f529\":52,\"1f52a\":52,\"1f52b\":52,\"1f52c\":52,\"1f52d\":52,\"1f52e\":52,\"1f52f\":52,\"1f530\":52,\"1f531\":52,\"1f532\":52,\"1f533\":52,\"1f534\":52,\"1f535\":52,\"1f536\":52,\"1f537\":52,\"1f538\":52,\"1f539\":52,\"1f53a\":52,\"1f53b\":52,\"1f53c\":52,\"1f53d\":52,\"1f550\":52,\"1f551\":52,\"1f552\":52,\"1f553\":52,\"1f554\":52,\"1f555\":52,\"1f556\":52,\"1f557\":52,\"1f558\":52,\"1f559\":52,\"1f55a\":52,\"1f55b\":52,\"1f55c\":52,\"1f55d\":52,\"1f55e\":52,\"1f55f\":52,\"1f560\":52,\"1f561\":52,\"1f562\":52,\"1f563\":52,\"1f564\":52,\"1f565\":52,\"1f566\":52,\"1f567\":52,\"1f5fb\":52,\"1f5fc\":52,\"1f5fd\":52,\"1f5fe\":52,\"1f5ff\":52,\"1f600\":52,\"1f601\":52,\"1f602\":52,\"1f603\":52,\"1f604\":52,\"1f605\":52,\"1f606\":52,\"1f607\":52,\"1f608\":52,\"1f609\":52,\"1f60a\":52,\"1f60b\":52,\"1f60c\":52,\"1f60d\":52,\"1f60e\":52,\"1f60f\":52,\"1f610\":52,\"1f611\":52,\"1f612\":52,\"1f613\":52,\"1f614\":52,\"1f615\":52,\"1f616\":52,\"1f617\":52,\"1f618\":52,\"1f619\":52,\"1f61a\":52,\"1f61b\":52,\"1f61c\":52,\"1f61d\":52,\"1f61e\":52,\"1f61f\":52,\"1f620\":52,\"1f621\":52,\"1f622\":52,\"1f623\":52,\"1f624\":52,\"1f625\":52,\"1f626\":52,\"1f627\":52,\"1f628\":52,\"1f629\":52,\"1f62a\":52,\"1f62b\":52,\"1f62c\":52,\"1f62d\":52,\"1f62e\":52,\"1f62f\":52,\"1f630\":52,\"1f631\":52,\"1f632\":52,\"1f633\":52,\"1f634\":52,\"1f635\":52,\"1f636\":52,\"1f637\":52,\"1f638\":52,\"1f639\":52,\"1f63a\":52,\"1f63b\":52,\"1f63c\":52,\"1f63d\":52,\"1f63e\":52,\"1f63f\":52,\"1f640\":52,\"1f645\":52,\"1f646\":52,\"1f647\":52,\"1f648\":52,\"1f649\":52,\"1f64a\":52,\"1f64b\":52,\"1f64c\":52,\"1f64d\":52,\"1f64e\":52,\"1f64f\":52,\"1f680\":52,\"1f681\":52,\"1f682\":52,\"1f683\":52,\"1f684\":52,\"1f685\":52,\"1f686\":52,\"1f687\":52,\"1f688\":52,\"1f689\":52,\"1f68a\":52,\"1f68b\":52,\"1f68c\":52,\"1f68d\":52,\"1f68e\":52,\"1f68f\":52,\"1f690\":52,\"1f691\":52,\"1f692\":52,\"1f693\":52,\"1f694\":52,\"1f695\":52,\"1f696\":52,\"1f697\":52,\"1f698\":52,\"1f699\":52,\"1f69a\":52,\"1f69b\":52,\"1f69c\":52,\"1f69d\":52,\"1f69e\":52,\"1f69f\":52,\"1f6a0\":52,\"1f6a1\":52,\"1f6a2\":52,\"1f6a3\":52,\"1f6a4\":52,\"1f6a5\":52,\"1f6a6\":52,\"1f6a7\":52,\"1f6a8\":52,\"1f6a9\":52,\"1f6aa\":52,\"1f6ab\":52,\"1f6ac\":52,\"1f6ad\":52,\"1f6ae\":52,\"1f6af\":52,\"1f6b0\":52,\"1f6b1\":52,\"1f6b2\":52,\"1f6b3\":52,\"1f6b4\":52,\"1f6b5\":52,\"1f6b6\":52,\"1f6b7\":52,\"1f6b8\":52,\"1f6b9\":52,\"1f6ba\":52,\"1f6bb\":52,\"1f6bc\":52,\"1f6bd\":52,\"1f6be\":52,\"1f6bf\":52,\"1f6c0\":52,\"1f6c1\":52,\"1f6c2\":52,\"1f6c3\":52,\"1f6c4\":52,\"1f6c5\":52,\"1fd0983b\":44,\"1im\":[22,25],\"1st\":[26,61],\"1x100\":35,\"1x2\":[20,34,35],\"1x4\":[20,56],\"1xn\":43,\"20f\":68,\"220446049250313e\":[33,76],\"223372036854776e18\":46,\"2499999f0\":33,\"24t12\":61,\"2500001f0\":33,\"25f0\":33,\"28th\":26,\"29t00\":26,\"29th\":26,\"2im\":[22,23,25],\"2nd\":26,\"2pi\":[38,46,68],\"2x2\":[20,24,45,46,64,68],\"2x3\":[20,35,56],\"2x4\":56,\"30e525\":44,\"31st\":26,\"31t00\":61,\"33333334f0\":[57,69],\"3333333f0\":69,\"3ef4f5c4\":44,\"3im\":22,\"3x2\":56,\"3x3\":[20,35,67],\"3x4\":45,\"3x5\":20,\"4031192506220405im\":22,\"4142135623730951im\":29,\"417b50a\":2,\"459565876494606882133333333333333333333333333333333333333333333333333333333344e\":33,\"4717266720048188im\":22,\"47c198b1\":44,\"4ghz\":46,\"4im\":22,\"4th\":26,\"4x2\":[14,20],\"4x4\":20,\"5000025e11\":46,\"5172413793103449im\":22,\"55b6\":52,\"5714285714285714im\":22,\"5f0\":[33,46,57],\"5fcfb13\":44,\"5im\":22,\"5th\":26,\"5x18\":20,\"5x2\":14,\"5x5\":20,\"600x600\":45,\"60im\":22,\"64f437b\":34,\"6e80\":52,\"7071067811865475im\":22,\"75im\":22,\"7861513777574233im\":22,\"793662034335766e\":33,\"7a7a\":52,\"800x800\":45,\"84b8e266dae6de30ab9703150b3bf771ec7b6285\":44,\"8ball\":52,\"8im\":22,\"8p3\":33,\"960664459571898im\":22,\"9f71f4becb05cadacb983c54a72eed744e5c019d\":44,\"\\u00e5ke\":67,\"\\u00ectr\":59,\"\\u0111\":52,\"\\u0127\":[34,52],\"\\u0142\":52,\"\\u014b\":52,\"\\u0153\":52,\"\\u0195\":52,\"\\u019e\":52,\"\\u01b6\":52,\"\\u01c2\":52,\"\\u0250\":52,\"\\u0252\":52,\"\\u0254\":52,\"\\u0256\":52,\"\\u0259\":52,\"\\u025b\":52,\"\\u0263\":52,\"\\u0264\":52,\"\\u0265\":52,\"\\u026c\":52,\"\\u026d\":52,\"\\u026f\":52,\"\\u0270\":52,\"\\u0271\":52,\"\\u0272\":52,\"\\u0273\":52,\"\\u0277\":52,\"\\u0278\":52,\"\\u0279\":52,\"\\u027a\":52,\"\\u027b\":52,\"\\u027c\":52,\"\\u027d\":52,\"\\u027e\":52,\"\\u0282\":52,\"\\u0283\":52,\"\\u0287\":52,\"\\u0288\":52,\"\\u028a\":52,\"\\u028b\":52,\"\\u028c\":52,\"\\u028d\":52,\"\\u028e\":52,\"\\u0290\":52,\"\\u0292\":52,\"\\u0294\":52,\"\\u0295\":52,\"\\u0296\":52,\"\\u029e\":52,\"\\u02a4\":52,\"\\u02a7\":52,\"\\u02b0\":52,\"\\u02b2\":52,\"\\u02b3\":52,\"\\u02b7\":52,\"\\u02b8\":52,\"\\u02bc\":52,\"\\u02c7\":52,\"\\u02c8\":52,\"\\u02cc\":52,\"\\u02d0\":52,\"\\u02d1\":52,\"\\u02e1\":52,\"\\u02e2\":52,\"\\u02e3\":52,\"\\u03b1\":[52,53],\"\\u03b2\":52,\"\\u03b3\":[52,69],\"\\u03b4\":[52,53],\"\\u03b4t\":46,\"\\u03b5\":52,\"\\u03b6\":52,\"\\u03b7\":52,\"\\u03b8\":52,\"\\u03b9\":52,\"\\u03ba\":52,\"\\u03bb\":[37,52],\"\\u03bc\":52,\"\\u03bd\":52,\"\\u03be\":52,\"\\u03bf\":52,\"\\u03c0\":[34,52,53,69],\"\\u03c1\":52,\"\\u03c2\":52,\"\\u03c3\":52,\"\\u03c4\":52,\"\\u03c5\":52,\"\\u03c6\":[52,69],\"\\u03c7\":52,\"\\u03c8\":52,\"\\u03c9\":52,\"\\u03d0\":52,\"\\u03d1\":52,\"\\u03d5\":52,\"\\u03d6\":52,\"\\u03d9\":52,\"\\u03db\":52,\"\\u03dd\":52,\"\\u03df\":52,\"\\u03e1\":52,\"\\u03f0\":52,\"\\u03f1\":52,\"\\u03f5\":52,\"\\u1d2c\":52,\"\\u1d2e\":52,\"\\u1d30\":52,\"\\u1d31\":52,\"\\u1d33\":52,\"\\u1d34\":52,\"\\u1d35\":52,\"\\u1d36\":52,\"\\u1d37\":52,\"\\u1d38\":52,\"\\u1d39\":52,\"\\u1d3a\":52,\"\\u1d3c\":52,\"\\u1d3e\":52,\"\\u1d3f\":52,\"\\u1d40\":52,\"\\u1d41\":52,\"\\u1d42\":52,\"\\u1d43\":52,\"\\u1d45\":52,\"\\u1d47\":52,\"\\u1d48\":52,\"\\u1d49\":52,\"\\u1d4b\":52,\"\\u1d4d\":52,\"\\u1d4f\":52,\"\\u1d50\":52,\"\\u1d52\":52,\"\\u1d56\":52,\"\\u1d57\":52,\"\\u1d58\":52,\"\\u1d5b\":52,\"\\u1d5d\":52,\"\\u1d5e\":52,\"\\u1d5f\":52,\"\\u1d60\":52,\"\\u1d61\":52,\"\\u1d62\":52,\"\\u1d63\":52,\"\\u1d64\":52,\"\\u1d65\":52,\"\\u1d66\":52,\"\\u1d67\":52,\"\\u1d68\":52,\"\\u1d69\":52,\"\\u1d6a\":52,\"\\u1d9c\":52,\"\\u1da0\":52,\"\\u1da5\":52,\"\\u1db2\":52,\"\\u1dbb\":52,\"\\u1dbf\":52,\"\\u2070\":52,\"\\u2071\":52,\"\\u2074\":52,\"\\u2075\":52,\"\\u2076\":52,\"\\u2077\":52,\"\\u2078\":52,\"\\u2079\":52,\"\\u207f\":52,\"\\u2080\":52,\"\\u2081\":52,\"\\u2082\":[52,53],\"\\u2083\":52,\"\\u2084\":52,\"\\u2085\":52,\"\\u2086\":52,\"\\u2087\":52,\"\\u2088\":52,\"\\u2089\":52,\"\\u2090\":52,\"\\u2091\":52,\"\\u2092\":52,\"\\u2093\":52,\"\\u2094\":52,\"\\u2102\":52,\"\\u2107\":52,\"\\u210a\":52,\"\\u210b\":52,\"\\u210c\":52,\"\\u210d\":52,\"\\u210e\":52,\"\\u210f\":52,\"\\u2110\":52,\"\\u2111\":52,\"\\u2112\":52,\"\\u2113\":52,\"\\u2115\":52,\"\\u2119\":52,\"\\u211a\":52,\"\\u211b\":52,\"\\u211c\":52,\"\\u211d\":52,\"\\u2124\":52,\"\\u2128\":52,\"\\u212c\":52,\"\\u212d\":52,\"\\u212f\":52,\"\\u2130\":52,\"\\u2131\":52,\"\\u2133\":52,\"\\u2134\":52,\"\\u2135\":52,\"\\u2136\":52,\"\\u2137\":52,\"\\u2138\":52,\"\\u2139\":52,\"\\u213c\":52,\"\\u213d\":52,\"\\u213e\":52,\"\\u213f\":52,\"\\u2145\":52,\"\\u2146\":52,\"\\u2147\":52,\"\\u2148\":52,\"\\u2149\":52,\"\\u214e\":52,\"\\u2c7c\":52,\"\\u2c7d\":52,\"\\u4eba\\u4eba\\u751f\\u800c\\u81ea\\u7531\":53,\"\\u4f60\\u597d\":31,\"\\u5728\\u5c0a\\u4e25\\u548c\\u6743\\u529b\\u4e0a\\u4e00\\u5f8b\\u5e73\\u7b49\":53,\"\\uc548\\ub155\\ud558\\uc138\\uc694\":[31,53],\"\\ud835\\udc00\":52,\"\\ud835\\udc01\":52,\"\\ud835\\udc02\":52,\"\\ud835\\udc03\":52,\"\\ud835\\udc04\":52,\"\\ud835\\udc05\":52,\"\\ud835\\udc06\":52,\"\\ud835\\udc07\":52,\"\\ud835\\udc08\":52,\"\\ud835\\udc09\":52,\"\\ud835\\udc0a\":52,\"\\ud835\\udc0b\":52,\"\\ud835\\udc0c\":52,\"\\ud835\\udc0d\":52,\"\\ud835\\udc0e\":52,\"\\ud835\\udc0f\":52,\"\\ud835\\udc10\":52,\"\\ud835\\udc11\":52,\"\\ud835\\udc12\":52,\"\\ud835\\udc13\":52,\"\\ud835\\udc14\":52,\"\\ud835\\udc15\":52,\"\\ud835\\udc16\":52,\"\\ud835\\udc17\":52,\"\\ud835\\udc18\":52,\"\\ud835\\udc19\":52,\"\\ud835\\udc1a\":52,\"\\ud835\\udc1b\":52,\"\\ud835\\udc1c\":52,\"\\ud835\\udc1d\":52,\"\\ud835\\udc1e\":52,\"\\ud835\\udc1f\":52,\"\\ud835\\udc20\":52,\"\\ud835\\udc21\":52,\"\\ud835\\udc22\":52,\"\\ud835\\udc23\":52,\"\\ud835\\udc24\":52,\"\\ud835\\udc25\":52,\"\\ud835\\udc26\":52,\"\\ud835\\udc27\":52,\"\\ud835\\udc28\":52,\"\\ud835\\udc29\":52,\"\\ud835\\udc2a\":52,\"\\ud835\\udc2b\":52,\"\\ud835\\udc2c\":52,\"\\ud835\\udc2d\":52,\"\\ud835\\udc2e\":52,\"\\ud835\\udc2f\":52,\"\\ud835\\udc30\":52,\"\\ud835\\udc31\":52,\"\\ud835\\udc32\":52,\"\\ud835\\udc33\":52,\"\\ud835\\udc34\":52,\"\\ud835\\udc35\":52,\"\\ud835\\udc36\":52,\"\\ud835\\udc37\":52,\"\\ud835\\udc38\":52,\"\\ud835\\udc39\":52,\"\\ud835\\udc3a\":52,\"\\ud835\\udc3b\":52,\"\\ud835\\udc3c\":52,\"\\ud835\\udc3d\":52,\"\\ud835\\udc3e\":52,\"\\ud835\\udc3f\":52,\"\\ud835\\udc40\":52,\"\\ud835\\udc41\":52,\"\\ud835\\udc42\":52,\"\\ud835\\udc43\":52,\"\\ud835\\udc44\":52,\"\\ud835\\udc45\":52,\"\\ud835\\udc46\":52,\"\\ud835\\udc47\":52,\"\\ud835\\udc48\":52,\"\\ud835\\udc49\":52,\"\\ud835\\udc4a\":52,\"\\ud835\\udc4b\":52,\"\\ud835\\udc4c\":52,\"\\ud835\\udc4d\":52,\"\\ud835\\udc4e\":52,\"\\ud835\\udc4f\":52,\"\\ud835\\udc50\":52,\"\\ud835\\udc51\":52,\"\\ud835\\udc52\":52,\"\\ud835\\udc53\":52,\"\\ud835\\udc54\":52,\"\\ud835\\udc56\":52,\"\\ud835\\udc57\":52,\"\\ud835\\udc58\":52,\"\\ud835\\udc59\":52,\"\\ud835\\udc5a\":52,\"\\ud835\\udc5b\":52,\"\\ud835\\udc5c\":52,\"\\ud835\\udc5d\":52,\"\\ud835\\udc5e\":52,\"\\ud835\\udc5f\":52,\"\\ud835\\udc60\":52,\"\\ud835\\udc61\":52,\"\\ud835\\udc62\":52,\"\\ud835\\udc63\":52,\"\\ud835\\udc64\":52,\"\\ud835\\udc65\":52,\"\\ud835\\udc66\":52,\"\\ud835\\udc67\":52,\"\\ud835\\udc68\":52,\"\\ud835\\udc69\":52,\"\\ud835\\udc6a\":52,\"\\ud835\\udc6b\":52,\"\\ud835\\udc6c\":52,\"\\ud835\\udc6d\":52,\"\\ud835\\udc6e\":52,\"\\ud835\\udc6f\":52,\"\\ud835\\udc70\":52,\"\\ud835\\udc71\":52,\"\\ud835\\udc72\":52,\"\\ud835\\udc73\":52,\"\\ud835\\udc74\":52,\"\\ud835\\udc75\":52,\"\\ud835\\udc76\":52,\"\\ud835\\udc77\":52,\"\\ud835\\udc78\":52,\"\\ud835\\udc79\":52,\"\\ud835\\udc7a\":52,\"\\ud835\\udc7b\":52,\"\\ud835\\udc7c\":52,\"\\ud835\\udc7d\":52,\"\\ud835\\udc7e\":52,\"\\ud835\\udc7f\":52,\"\\ud835\\udc80\":52,\"\\ud835\\udc81\":52,\"\\ud835\\udc82\":52,\"\\ud835\\udc83\":52,\"\\ud835\\udc84\":52,\"\\ud835\\udc85\":52,\"\\ud835\\udc86\":52,\"\\ud835\\udc87\":52,\"\\ud835\\udc88\":52,\"\\ud835\\udc89\":52,\"\\ud835\\udc8a\":52,\"\\ud835\\udc8b\":52,\"\\ud835\\udc8c\":52,\"\\ud835\\udc8d\":52,\"\\ud835\\udc8e\":52,\"\\ud835\\udc8f\":52,\"\\ud835\\udc90\":52,\"\\ud835\\udc91\":52,\"\\ud835\\udc92\":52,\"\\ud835\\udc93\":52,\"\\ud835\\udc94\":52,\"\\ud835\\udc95\":52,\"\\ud835\\udc96\":52,\"\\ud835\\udc97\":52,\"\\ud835\\udc98\":52,\"\\ud835\\udc99\":52,\"\\ud835\\udc9a\":52,\"\\ud835\\udc9b\":52,\"\\ud835\\udc9c\":52,\"\\ud835\\udc9e\":52,\"\\ud835\\udc9f\":52,\"\\ud835\\udca2\":52,\"\\ud835\\udca5\":52,\"\\ud835\\udca6\":52,\"\\ud835\\udca9\":52,\"\\ud835\\udcaa\":52,\"\\ud835\\udcab\":52,\"\\ud835\\udcac\":52,\"\\ud835\\udcae\":52,\"\\ud835\\udcaf\":52,\"\\ud835\\udcb0\":52,\"\\ud835\\udcb1\":52,\"\\ud835\\udcb2\":52,\"\\ud835\\udcb3\":52,\"\\ud835\\udcb4\":52,\"\\ud835\\udcb5\":52,\"\\ud835\\udcb6\":52,\"\\ud835\\udcb7\":52,\"\\ud835\\udcb8\":52,\"\\ud835\\udcb9\":52,\"\\ud835\\udcbb\":52,\"\\ud835\\udcbd\":52,\"\\ud835\\udcbe\":52,\"\\ud835\\udcbf\":52,\"\\ud835\\udcc0\":52,\"\\ud835\\udcc1\":52,\"\\ud835\\udcc2\":52,\"\\ud835\\udcc3\":52,\"\\ud835\\udcc5\":52,\"\\ud835\\udcc6\":52,\"\\ud835\\udcc7\":52,\"\\ud835\\udcc8\":52,\"\\ud835\\udcc9\":52,\"\\ud835\\udcca\":52,\"\\ud835\\udccb\":52,\"\\ud835\\udccc\":52,\"\\ud835\\udccd\":52,\"\\ud835\\udcce\":52,\"\\ud835\\udccf\":52,\"\\ud835\\udcd0\":52,\"\\ud835\\udcd1\":52,\"\\ud835\\udcd2\":52,\"\\ud835\\udcd3\":52,\"\\ud835\\udcd4\":52,\"\\ud835\\udcd5\":52,\"\\ud835\\udcd6\":52,\"\\ud835\\udcd7\":52,\"\\ud835\\udcd8\":52,\"\\ud835\\udcd9\":52,\"\\ud835\\udcda\":52,\"\\ud835\\udcdb\":52,\"\\ud835\\udcdc\":52,\"\\ud835\\udcdd\":52,\"\\ud835\\udcde\":52,\"\\ud835\\udcdf\":52,\"\\ud835\\udce0\":52,\"\\ud835\\udce1\":52,\"\\ud835\\udce2\":52,\"\\ud835\\udce3\":52,\"\\ud835\\udce4\":52,\"\\ud835\\udce5\":52,\"\\ud835\\udce6\":52,\"\\ud835\\udce7\":52,\"\\ud835\\udce8\":52,\"\\ud835\\udce9\":52,\"\\ud835\\udcea\":52,\"\\ud835\\udceb\":52,\"\\ud835\\udcec\":52,\"\\ud835\\udced\":52,\"\\ud835\\udcee\":52,\"\\ud835\\udcef\":52,\"\\ud835\\udcf0\":52,\"\\ud835\\udcf1\":52,\"\\ud835\\udcf2\":52,\"\\ud835\\udcf3\":52,\"\\ud835\\udcf4\":52,\"\\ud835\\udcf5\":52,\"\\ud835\\udcf6\":52,\"\\ud835\\udcf7\":52,\"\\ud835\\udcf8\":52,\"\\ud835\\udcf9\":52,\"\\ud835\\udcfa\":52,\"\\ud835\\udcfb\":52,\"\\ud835\\udcfc\":52,\"\\ud835\\udcfd\":52,\"\\ud835\\udcfe\":52,\"\\ud835\\udcff\":52,\"\\ud835\\udd00\":52,\"\\ud835\\udd01\":52,\"\\ud835\\udd02\":52,\"\\ud835\\udd03\":52,\"\\ud835\\udd04\":52,\"\\ud835\\udd05\":52,\"\\ud835\\udd07\":52,\"\\ud835\\udd08\":52,\"\\ud835\\udd09\":52,\"\\ud835\\udd0a\":52,\"\\ud835\\udd0d\":52,\"\\ud835\\udd0e\":52,\"\\ud835\\udd0f\":52,\"\\ud835\\udd10\":52,\"\\ud835\\udd11\":52,\"\\ud835\\udd12\":52,\"\\ud835\\udd13\":52,\"\\ud835\\udd14\":52,\"\\ud835\\udd16\":52,\"\\ud835\\udd17\":52,\"\\ud835\\udd18\":52,\"\\ud835\\udd19\":52,\"\\ud835\\udd1a\":52,\"\\ud835\\udd1b\":52,\"\\ud835\\udd1c\":52,\"\\ud835\\udd1e\":52,\"\\ud835\\udd1f\":52,\"\\ud835\\udd20\":52,\"\\ud835\\udd21\":52,\"\\ud835\\udd22\":52,\"\\ud835\\udd23\":52,\"\\ud835\\udd24\":52,\"\\ud835\\udd25\":52,\"\\ud835\\udd26\":52,\"\\ud835\\udd27\":52,\"\\ud835\\udd28\":52,\"\\ud835\\udd29\":52,\"\\ud835\\udd2a\":52,\"\\ud835\\udd2b\":52,\"\\ud835\\udd2c\":52,\"\\ud835\\udd2d\":52,\"\\ud835\\udd2e\":52,\"\\ud835\\udd2f\":52,\"\\ud835\\udd30\":52,\"\\ud835\\udd31\":52,\"\\ud835\\udd32\":52,\"\\ud835\\udd33\":52,\"\\ud835\\udd34\":52,\"\\ud835\\udd35\":52,\"\\ud835\\udd36\":52,\"\\ud835\\udd37\":52,\"\\ud835\\udd38\":52,\"\\ud835\\udd39\":52,\"\\ud835\\udd3b\":52,\"\\ud835\\udd3c\":52,\"\\ud835\\udd3d\":52,\"\\ud835\\udd3e\":52,\"\\ud835\\udd40\":52,\"\\ud835\\udd41\":52,\"\\ud835\\udd42\":52,\"\\ud835\\udd43\":52,\"\\ud835\\udd44\":52,\"\\ud835\\udd46\":52,\"\\ud835\\udd4a\":52,\"\\ud835\\udd4b\":52,\"\\ud835\\udd4c\":52,\"\\ud835\\udd4d\":52,\"\\ud835\\udd4e\":52,\"\\ud835\\udd4f\":52,\"\\ud835\\udd50\":52,\"\\ud835\\udd52\":52,\"\\ud835\\udd53\":52,\"\\ud835\\udd54\":52,\"\\ud835\\udd55\":52,\"\\ud835\\udd56\":52,\"\\ud835\\udd57\":52,\"\\ud835\\udd58\":52,\"\\ud835\\udd59\":52,\"\\ud835\\udd5a\":52,\"\\ud835\\udd5b\":52,\"\\ud835\\udd5c\":52,\"\\ud835\\udd5d\":52,\"\\ud835\\udd5e\":52,\"\\ud835\\udd5f\":52,\"\\ud835\\udd60\":52,\"\\ud835\\udd61\":52,\"\\ud835\\udd62\":52,\"\\ud835\\udd63\":52,\"\\ud835\\udd64\":52,\"\\ud835\\udd65\":52,\"\\ud835\\udd66\":52,\"\\ud835\\udd67\":52,\"\\ud835\\udd68\":52,\"\\ud835\\udd69\":52,\"\\ud835\\udd6a\":52,\"\\ud835\\udd6b\":52,\"\\ud835\\udd6c\":52,\"\\ud835\\udd6d\":52,\"\\ud835\\udd6e\":52,\"\\ud835\\udd6f\":52,\"\\ud835\\udd70\":52,\"\\ud835\\udd71\":52,\"\\ud835\\udd72\":52,\"\\ud835\\udd73\":52,\"\\ud835\\udd74\":52,\"\\ud835\\udd75\":52,\"\\ud835\\udd76\":52,\"\\ud835\\udd77\":52,\"\\ud835\\udd78\":52,\"\\ud835\\udd79\":52,\"\\ud835\\udd7a\":52,\"\\ud835\\udd7b\":52,\"\\ud835\\udd7c\":52,\"\\ud835\\udd7d\":52,\"\\ud835\\udd7e\":52,\"\\ud835\\udd7f\":52,\"\\ud835\\udd80\":52,\"\\ud835\\udd81\":52,\"\\ud835\\udd82\":52,\"\\ud835\\udd83\":52,\"\\ud835\\udd84\":52,\"\\ud835\\udd85\":52,\"\\ud835\\udd86\":52,\"\\ud835\\udd87\":52,\"\\ud835\\udd88\":52,\"\\ud835\\udd89\":52,\"\\ud835\\udd8a\":52,\"\\ud835\\udd8b\":52,\"\\ud835\\udd8c\":52,\"\\ud835\\udd8d\":52,\"\\ud835\\udd8e\":52,\"\\ud835\\udd8f\":52,\"\\ud835\\udd90\":52,\"\\ud835\\udd91\":52,\"\\ud835\\udd92\":52,\"\\ud835\\udd93\":52,\"\\ud835\\udd94\":52,\"\\ud835\\udd95\":52,\"\\ud835\\udd96\":52,\"\\ud835\\udd97\":52,\"\\ud835\\udd98\":52,\"\\ud835\\udd99\":52,\"\\ud835\\udd9a\":52,\"\\ud835\\udd9b\":52,\"\\ud835\\udd9c\":52,\"\\ud835\\udd9d\":52,\"\\ud835\\udd9e\":52,\"\\ud835\\udd9f\":52,\"\\ud835\\udda0\":52,\"\\ud835\\udda1\":52,\"\\ud835\\udda2\":52,\"\\ud835\\udda3\":52,\"\\ud835\\udda4\":52,\"\\ud835\\udda5\":52,\"\\ud835\\udda6\":52,\"\\ud835\\udda7\":52,\"\\ud835\\udda8\":52,\"\\ud835\\udda9\":52,\"\\ud835\\uddaa\":52,\"\\ud835\\uddab\":52,\"\\ud835\\uddac\":52,\"\\ud835\\uddad\":52,\"\\ud835\\uddae\":52,\"\\ud835\\uddaf\":52,\"\\ud835\\uddb0\":52,\"\\ud835\\uddb1\":52,\"\\ud835\\uddb2\":52,\"\\ud835\\uddb3\":52,\"\\ud835\\uddb4\":52,\"\\ud835\\uddb5\":52,\"\\ud835\\uddb6\":52,\"\\ud835\\uddb7\":52,\"\\ud835\\uddb8\":52,\"\\ud835\\uddb9\":52,\"\\ud835\\uddba\":52,\"\\ud835\\uddbb\":52,\"\\ud835\\uddbc\":52,\"\\ud835\\uddbd\":52,\"\\ud835\\uddbe\":52,\"\\ud835\\uddbf\":52,\"\\ud835\\uddc0\":52,\"\\ud835\\uddc1\":52,\"\\ud835\\uddc2\":52,\"\\ud835\\uddc3\":52,\"\\ud835\\uddc4\":52,\"\\ud835\\uddc5\":52,\"\\ud835\\uddc6\":52,\"\\ud835\\uddc7\":52,\"\\ud835\\uddc8\":52,\"\\ud835\\uddc9\":52,\"\\ud835\\uddca\":52,\"\\ud835\\uddcb\":52,\"\\ud835\\uddcc\":52,\"\\ud835\\uddcd\":52,\"\\ud835\\uddce\":52,\"\\ud835\\uddcf\":52,\"\\ud835\\uddd0\":52,\"\\ud835\\uddd1\":52,\"\\ud835\\uddd2\":52,\"\\ud835\\uddd3\":52,\"\\ud835\\uddd4\":52,\"\\ud835\\uddd5\":52,\"\\ud835\\uddd6\":52,\"\\ud835\\uddd7\":52,\"\\ud835\\uddd8\":52,\"\\ud835\\uddd9\":52,\"\\ud835\\uddda\":52,\"\\ud835\\udddb\":52,\"\\ud835\\udddc\":52,\"\\ud835\\udddd\":52,\"\\ud835\\uddde\":52,\"\\ud835\\udddf\":52,\"\\ud835\\udde0\":52,\"\\ud835\\udde1\":52,\"\\ud835\\udde2\":52,\"\\ud835\\udde3\":52,\"\\ud835\\udde4\":52,\"\\ud835\\udde5\":52,\"\\ud835\\udde6\":52,\"\\ud835\\udde7\":52,\"\\ud835\\udde8\":52,\"\\ud835\\udde9\":52,\"\\ud835\\uddea\":52,\"\\ud835\\uddeb\":52,\"\\ud835\\uddec\":52,\"\\ud835\\udded\":52,\"\\ud835\\uddee\":52,\"\\ud835\\uddef\":52,\"\\ud835\\uddf0\":52,\"\\ud835\\uddf1\":52,\"\\ud835\\uddf2\":52,\"\\ud835\\uddf3\":52,\"\\ud835\\uddf4\":52,\"\\ud835\\uddf5\":52,\"\\ud835\\uddf6\":52,\"\\ud835\\uddf7\":52,\"\\ud835\\uddf8\":52,\"\\ud835\\uddf9\":52,\"\\ud835\\uddfa\":52,\"\\ud835\\uddfb\":52,\"\\ud835\\uddfc\":52,\"\\ud835\\uddfd\":52,\"\\ud835\\uddfe\":52,\"\\ud835\\uddff\":52,\"\\ud835\\ude00\":52,\"\\ud835\\ude01\":52,\"\\ud835\\ude02\":52,\"\\ud835\\ude03\":52,\"\\ud835\\ude04\":52,\"\\ud835\\ude05\":52,\"\\ud835\\ude06\":52,\"\\ud835\\ude07\":52,\"\\ud835\\ude08\":52,\"\\ud835\\ude09\":52,\"\\ud835\\ude0a\":52,\"\\ud835\\ude0b\":52,\"\\ud835\\ude0c\":52,\"\\ud835\\ude0d\":52,\"\\ud835\\ude0e\":52,\"\\ud835\\ude0f\":52,\"\\ud835\\ude10\":52,\"\\ud835\\ude11\":52,\"\\ud835\\ude12\":52,\"\\ud835\\ude13\":52,\"\\ud835\\ude14\":52,\"\\ud835\\ude15\":52,\"\\ud835\\ude16\":52,\"\\ud835\\ude17\":52,\"\\ud835\\ude18\":52,\"\\ud835\\ude19\":52,\"\\ud835\\ude1a\":52,\"\\ud835\\ude1b\":52,\"\\ud835\\ude1c\":52,\"\\ud835\\ude1d\":52,\"\\ud835\\ude1e\":52,\"\\ud835\\ude1f\":52,\"\\ud835\\ude20\":52,\"\\ud835\\ude21\":52,\"\\ud835\\ude22\":52,\"\\ud835\\ude23\":52,\"\\ud835\\ude24\":52,\"\\ud835\\ude25\":52,\"\\ud835\\ude26\":52,\"\\ud835\\ude27\":52,\"\\ud835\\ude28\":52,\"\\ud835\\ude29\":52,\"\\ud835\\ude2a\":52,\"\\ud835\\ude2b\":52,\"\\ud835\\ude2c\":52,\"\\ud835\\ude2d\":52,\"\\ud835\\ude2e\":52,\"\\ud835\\ude2f\":52,\"\\ud835\\ude30\":52,\"\\ud835\\ude31\":52,\"\\ud835\\ude32\":52,\"\\ud835\\ude33\":52,\"\\ud835\\ude34\":52,\"\\ud835\\ude35\":52,\"\\ud835\\ude36\":52,\"\\ud835\\ude37\":52,\"\\ud835\\ude38\":52,\"\\ud835\\ude39\":52,\"\\ud835\\ude3a\":52,\"\\ud835\\ude3b\":52,\"\\ud835\\ude3c\":52,\"\\ud835\\ude3d\":52,\"\\ud835\\ude3e\":52,\"\\ud835\\ude3f\":52,\"\\ud835\\ude40\":52,\"\\ud835\\ude41\":52,\"\\ud835\\ude42\":52,\"\\ud835\\ude43\":52,\"\\ud835\\ude44\":52,\"\\ud835\\ude45\":52,\"\\ud835\\ude46\":52,\"\\ud835\\ude47\":52,\"\\ud835\\ude48\":52,\"\\ud835\\ude49\":52,\"\\ud835\\ude4a\":52,\"\\ud835\\ude4b\":52,\"\\ud835\\ude4c\":52,\"\\ud835\\ude4d\":52,\"\\ud835\\ude4e\":52,\"\\ud835\\ude4f\":52,\"\\ud835\\ude50\":52,\"\\ud835\\ude51\":52,\"\\ud835\\ude52\":52,\"\\ud835\\ude53\":52,\"\\ud835\\ude54\":52,\"\\ud835\\ude55\":52,\"\\ud835\\ude56\":52,\"\\ud835\\ude57\":52,\"\\ud835\\ude58\":52,\"\\ud835\\ude59\":52,\"\\ud835\\ude5a\":52,\"\\ud835\\ude5b\":52,\"\\ud835\\ude5c\":52,\"\\ud835\\ude5d\":52,\"\\ud835\\ude5e\":52,\"\\ud835\\ude5f\":52,\"\\ud835\\ude60\":52,\"\\ud835\\ude61\":52,\"\\ud835\\ude62\":52,\"\\ud835\\ude63\":52,\"\\ud835\\ude64\":52,\"\\ud835\\ude65\":52,\"\\ud835\\ude66\":52,\"\\ud835\\ude67\":52,\"\\ud835\\ude68\":52,\"\\ud835\\ude69\":52,\"\\ud835\\ude6a\":52,\"\\ud835\\ude6b\":52,\"\\ud835\\ude6c\":52,\"\\ud835\\ude6d\":52,\"\\ud835\\ude6e\":52,\"\\ud835\\ude6f\":52,\"\\ud835\\ude70\":52,\"\\ud835\\ude71\":52,\"\\ud835\\ude72\":52,\"\\ud835\\ude73\":52,\"\\ud835\\ude74\":52,\"\\ud835\\ude75\":52,\"\\ud835\\ude76\":52,\"\\ud835\\ude77\":52,\"\\ud835\\ude78\":52,\"\\ud835\\ude79\":52,\"\\ud835\\ude7a\":52,\"\\ud835\\ude7b\":52,\"\\ud835\\ude7c\":52,\"\\ud835\\ude7d\":52,\"\\ud835\\ude7e\":52,\"\\ud835\\ude7f\":52,\"\\ud835\\ude80\":52,\"\\ud835\\ude81\":52,\"\\ud835\\ude82\":52,\"\\ud835\\ude83\":52,\"\\ud835\\ude84\":52,\"\\ud835\\ude85\":52,\"\\ud835\\ude86\":52,\"\\ud835\\ude87\":52,\"\\ud835\\ude88\":52,\"\\ud835\\ude89\":52,\"\\ud835\\ude8a\":52,\"\\ud835\\ude8b\":52,\"\\ud835\\ude8c\":52,\"\\ud835\\ude8d\":52,\"\\ud835\\ude8e\":52,\"\\ud835\\ude8f\":52,\"\\ud835\\ude90\":52,\"\\ud835\\ude91\":52,\"\\ud835\\ude92\":52,\"\\ud835\\ude93\":52,\"\\ud835\\ude94\":52,\"\\ud835\\ude95\":52,\"\\ud835\\ude96\":52,\"\\ud835\\ude97\":52,\"\\ud835\\ude98\":52,\"\\ud835\\ude99\":52,\"\\ud835\\ude9a\":52,\"\\ud835\\ude9b\":52,\"\\ud835\\ude9c\":52,\"\\ud835\\ude9d\":52,\"\\ud835\\ude9e\":52,\"\\ud835\\ude9f\":52,\"\\ud835\\udea0\":52,\"\\ud835\\udea1\":52,\"\\ud835\\udea2\":52,\"\\ud835\\udea3\":52,\"\\ud835\\udea4\":52,\"\\ud835\\udea5\":52,\"\\ud835\\udea8\":52,\"\\ud835\\udea9\":52,\"\\ud835\\udeaa\":52,\"\\ud835\\udeab\":52,\"\\ud835\\udeac\":52,\"\\ud835\\udead\":52,\"\\ud835\\udeae\":52,\"\\ud835\\udeaf\":52,\"\\ud835\\udeb0\":52,\"\\ud835\\udeb1\":52,\"\\ud835\\udeb2\":52,\"\\ud835\\udeb3\":52,\"\\ud835\\udeb4\":52,\"\\ud835\\udeb5\":52,\"\\ud835\\udeb6\":52,\"\\ud835\\udeb7\":52,\"\\ud835\\udeb8\":52,\"\\ud835\\udeb9\":52,\"\\ud835\\udeba\":52,\"\\ud835\\udebb\":52,\"\\ud835\\udebc\":52,\"\\ud835\\udebd\":52,\"\\ud835\\udebe\":52,\"\\ud835\\udebf\":52,\"\\ud835\\udec0\":52,\"\\ud835\\udec2\":52,\"\\ud835\\udec3\":52,\"\\ud835\\udec4\":52,\"\\ud835\\udec5\":52,\"\\ud835\\udec6\":52,\"\\ud835\\udec7\":52,\"\\ud835\\udec8\":52,\"\\ud835\\udec9\":52,\"\\ud835\\udeca\":52,\"\\ud835\\udecb\":52,\"\\ud835\\udecc\":52,\"\\ud835\\udecd\":52,\"\\ud835\\udece\":52,\"\\ud835\\udecf\":52,\"\\ud835\\uded0\":52,\"\\ud835\\uded1\":52,\"\\ud835\\uded2\":52,\"\\ud835\\uded3\":52,\"\\ud835\\uded4\":52,\"\\ud835\\uded5\":52,\"\\ud835\\uded6\":52,\"\\ud835\\uded7\":52,\"\\ud835\\uded8\":52,\"\\ud835\\uded9\":52,\"\\ud835\\udeda\":52,\"\\ud835\\udedc\":52,\"\\ud835\\udedd\":52,\"\\ud835\\udede\":52,\"\\ud835\\udedf\":52,\"\\ud835\\udee0\":52,\"\\ud835\\udee1\":52,\"\\ud835\\udee2\":52,\"\\ud835\\udee3\":52,\"\\ud835\\udee4\":52,\"\\ud835\\udee5\":52,\"\\ud835\\udee6\":52,\"\\ud835\\udee7\":52,\"\\ud835\\udee8\":52,\"\\ud835\\udee9\":52,\"\\ud835\\udeea\":52,\"\\ud835\\udeeb\":52,\"\\ud835\\udeec\":52,\"\\ud835\\udeed\":52,\"\\ud835\\udeee\":52,\"\\ud835\\udeef\":52,\"\\ud835\\udef0\":52,\"\\ud835\\udef1\":52,\"\\ud835\\udef2\":52,\"\\ud835\\udef3\":52,\"\\ud835\\udef4\":52,\"\\ud835\\udef5\":52,\"\\ud835\\udef6\":52,\"\\ud835\\udef7\":52,\"\\ud835\\udef8\":52,\"\\ud835\\udef9\":52,\"\\ud835\\udefa\":52,\"\\ud835\\udefc\":52,\"\\ud835\\udefd\":52,\"\\ud835\\udefe\":52,\"\\ud835\\udeff\":52,\"\\ud835\\udf00\":52,\"\\ud835\\udf01\":52,\"\\ud835\\udf02\":52,\"\\ud835\\udf03\":52,\"\\ud835\\udf04\":52,\"\\ud835\\udf05\":52,\"\\ud835\\udf06\":52,\"\\ud835\\udf07\":52,\"\\ud835\\udf08\":52,\"\\ud835\\udf09\":52,\"\\ud835\\udf0a\":52,\"\\ud835\\udf0b\":52,\"\\ud835\\udf0c\":52,\"\\ud835\\udf0d\":52,\"\\ud835\\udf0e\":52,\"\\ud835\\udf0f\":52,\"\\ud835\\udf10\":52,\"\\ud835\\udf11\":52,\"\\ud835\\udf12\":52,\"\\ud835\\udf13\":52,\"\\ud835\\udf14\":52,\"\\ud835\\udf16\":52,\"\\ud835\\udf17\":52,\"\\ud835\\udf18\":52,\"\\ud835\\udf19\":52,\"\\ud835\\udf1a\":52,\"\\ud835\\udf1b\":52,\"\\ud835\\udf1c\":52,\"\\ud835\\udf1d\":52,\"\\ud835\\udf1e\":52,\"\\ud835\\udf1f\":52,\"\\ud835\\udf20\":52,\"\\ud835\\udf21\":52,\"\\ud835\\udf22\":52,\"\\ud835\\udf23\":52,\"\\ud835\\udf24\":52,\"\\ud835\\udf25\":52,\"\\ud835\\udf26\":52,\"\\ud835\\udf27\":52,\"\\ud835\\udf28\":52,\"\\ud835\\udf29\":52,\"\\ud835\\udf2a\":52,\"\\ud835\\udf2b\":52,\"\\ud835\\udf2c\":52,\"\\ud835\\udf2d\":52,\"\\ud835\\udf2e\":52,\"\\ud835\\udf2f\":52,\"\\ud835\\udf30\":52,\"\\ud835\\udf31\":52,\"\\ud835\\udf32\":52,\"\\ud835\\udf33\":52,\"\\ud835\\udf34\":52,\"\\ud835\\udf36\":52,\"\\ud835\\udf37\":52,\"\\ud835\\udf38\":52,\"\\ud835\\udf39\":52,\"\\ud835\\udf3a\":52,\"\\ud835\\udf3b\":52,\"\\ud835\\udf3c\":52,\"\\ud835\\udf3d\":52,\"\\ud835\\udf3e\":52,\"\\ud835\\udf3f\":52,\"\\ud835\\udf40\":52,\"\\ud835\\udf41\":52,\"\\ud835\\udf42\":52,\"\\ud835\\udf43\":52,\"\\ud835\\udf44\":52,\"\\ud835\\udf45\":52,\"\\ud835\\udf46\":52,\"\\ud835\\udf47\":52,\"\\ud835\\udf48\":52,\"\\ud835\\udf49\":52,\"\\ud835\\udf4a\":52,\"\\ud835\\udf4b\":52,\"\\ud835\\udf4c\":52,\"\\ud835\\udf4d\":52,\"\\ud835\\udf4e\":52,\"\\ud835\\udf50\":52,\"\\ud835\\udf51\":52,\"\\ud835\\udf52\":52,\"\\ud835\\udf53\":52,\"\\ud835\\udf54\":52,\"\\ud835\\udf55\":52,\"\\ud835\\udf56\":52,\"\\ud835\\udf57\":52,\"\\ud835\\udf58\":52,\"\\ud835\\udf59\":52,\"\\ud835\\udf5a\":52,\"\\ud835\\udf5b\":52,\"\\ud835\\udf5c\":52,\"\\ud835\\udf5d\":52,\"\\ud835\\udf5e\":52,\"\\ud835\\udf5f\":52,\"\\ud835\\udf60\":52,\"\\ud835\\udf61\":52,\"\\ud835\\udf62\":52,\"\\ud835\\udf63\":52,\"\\ud835\\udf64\":52,\"\\ud835\\udf65\":52,\"\\ud835\\udf66\":52,\"\\ud835\\udf67\":52,\"\\ud835\\udf68\":52,\"\\ud835\\udf69\":52,\"\\ud835\\udf6a\":52,\"\\ud835\\udf6b\":52,\"\\ud835\\udf6c\":52,\"\\ud835\\udf6d\":52,\"\\ud835\\udf6e\":52,\"\\ud835\\udf70\":52,\"\\ud835\\udf71\":52,\"\\ud835\\udf72\":52,\"\\ud835\\udf73\":52,\"\\ud835\\udf74\":52,\"\\ud835\\udf75\":52,\"\\ud835\\udf76\":52,\"\\ud835\\udf77\":52,\"\\ud835\\udf78\":52,\"\\ud835\\udf79\":52,\"\\ud835\\udf7a\":52,\"\\ud835\\udf7b\":52,\"\\ud835\\udf7c\":52,\"\\ud835\\udf7d\":52,\"\\ud835\\udf7e\":52,\"\\ud835\\udf7f\":52,\"\\ud835\\udf80\":52,\"\\ud835\\udf81\":52,\"\\ud835\\udf82\":52,\"\\ud835\\udf83\":52,\"\\ud835\\udf84\":52,\"\\ud835\\udf85\":52,\"\\ud835\\udf86\":52,\"\\ud835\\udf87\":52,\"\\ud835\\udf88\":52,\"\\ud835\\udf8a\":52,\"\\ud835\\udf8b\":52,\"\\ud835\\udf8c\":52,\"\\ud835\\udf8d\":52,\"\\ud835\\udf8e\":52,\"\\ud835\\udf8f\":52,\"\\ud835\\udf90\":52,\"\\ud835\\udf91\":52,\"\\ud835\\udf92\":52,\"\\ud835\\udf93\":52,\"\\ud835\\udf94\":52,\"\\ud835\\udf95\":52,\"\\ud835\\udf96\":52,\"\\ud835\\udf97\":52,\"\\ud835\\udf98\":52,\"\\ud835\\udf99\":52,\"\\ud835\\udf9a\":52,\"\\ud835\\udf9b\":52,\"\\ud835\\udf9c\":52,\"\\ud835\\udf9d\":52,\"\\ud835\\udf9e\":52,\"\\ud835\\udf9f\":52,\"\\ud835\\udfa0\":52,\"\\ud835\\udfa1\":52,\"\\ud835\\udfa2\":52,\"\\ud835\\udfa3\":52,\"\\ud835\\udfa4\":52,\"\\ud835\\udfa5\":52,\"\\ud835\\udfa6\":52,\"\\ud835\\udfa7\":52,\"\\ud835\\udfa8\":52,\"\\ud835\\udfaa\":52,\"\\ud835\\udfab\":52,\"\\ud835\\udfac\":52,\"\\ud835\\udfad\":52,\"\\ud835\\udfae\":52,\"\\ud835\\udfaf\":52,\"\\ud835\\udfb0\":52,\"\\ud835\\udfb1\":52,\"\\ud835\\udfb2\":52,\"\\ud835\\udfb3\":52,\"\\ud835\\udfb4\":52,\"\\ud835\\udfb5\":52,\"\\ud835\\udfb6\":52,\"\\ud835\\udfb7\":52,\"\\ud835\\udfb8\":52,\"\\ud835\\udfb9\":52,\"\\ud835\\udfba\":52,\"\\ud835\\udfbb\":52,\"\\ud835\\udfbc\":52,\"\\ud835\\udfbd\":52,\"\\ud835\\udfbe\":52,\"\\ud835\\udfbf\":52,\"\\ud835\\udfc0\":52,\"\\ud835\\udfc1\":52,\"\\ud835\\udfc2\":52,\"\\ud835\\udfc4\":52,\"\\ud835\\udfc5\":52,\"\\ud835\\udfc6\":52,\"\\ud835\\udfc7\":52,\"\\ud835\\udfc8\":52,\"\\ud835\\udfc9\":52,\"\\ud835\\udfca\":52,\"\\ud835\\udfcb\":52,\"\\ud835\\udfce\":52,\"\\ud835\\udfcf\":52,\"\\ud835\\udfd0\":52,\"\\ud835\\udfd1\":52,\"\\ud835\\udfd2\":52,\"\\ud835\\udfd3\":52,\"\\ud835\\udfd4\":52,\"\\ud835\\udfd5\":52,\"\\ud835\\udfd6\":52,\"\\ud835\\udfd7\":52,\"\\ud835\\udfd8\":52,\"\\ud835\\udfd9\":52,\"\\ud835\\udfda\":52,\"\\ud835\\udfdb\":52,\"\\ud835\\udfdc\":52,\"\\ud835\\udfdd\":52,\"\\ud835\\udfde\":52,\"\\ud835\\udfdf\":52,\"\\ud835\\udfe0\":52,\"\\ud835\\udfe1\":52,\"\\ud835\\udfe2\":52,\"\\ud835\\udfe3\":52,\"\\ud835\\udfe4\":52,\"\\ud835\\udfe5\":52,\"\\ud835\\udfe6\":52,\"\\ud835\\udfe7\":52,\"\\ud835\\udfe8\":52,\"\\ud835\\udfe9\":52,\"\\ud835\\udfea\":52,\"\\ud835\\udfeb\":52,\"\\ud835\\udfec\":52,\"\\ud835\\udfed\":52,\"\\ud835\\udfee\":52,\"\\ud835\\udfef\":52,\"\\ud835\\udff0\":52,\"\\ud835\\udff1\":52,\"\\ud835\\udff2\":52,\"\\ud835\\udff3\":52,\"\\ud835\\udff4\":52,\"\\ud835\\udff5\":52,\"\\ud835\\udff6\":52,\"\\ud835\\udff7\":52,\"\\ud835\\udff8\":52,\"\\ud835\\udff9\":52,\"\\ud835\\udffa\":52,\"\\ud835\\udffb\":52,\"\\ud835\\udffc\":52,\"\\ud835\\udffd\":52,\"\\ud835\\udffe\":52,\"\\ud835\\udfff\":52,\"_130862\":12,\"__doc__\":27,\"__file__\":[41,62],\"__init__\":[6,13,41,57],\"__line__\":62,\"__precompile__\":[41,57],\"__text\":29,\"_atexit\":[5,6],\"_beta\":52,\"_chi\":52,\"_fileno\":13,\"_fopen\":21,\"_function\":56,\"_gamma\":52,\"_init\":55,\"_inlin\":9,\"_j_str267\":4,\"_julia_init\":6,\"_not_\":67,\"_phi\":52,\"_rho\":52,\"_schwa\":52,\"_start\":5,\"_var0\":46,\"_var1\":46,\"_var2\":46,\"_var3\":46,\"_var4\":46,\"abstract\":[5,12,16,20,21,23,25,26,27,33],\"b\\u00e9zout\":68,\"bj\\u00f6rck\":67,\"boolean\":[1,14,16,20,24,25,28,38,40,43,51,56,57,59,64,67,68,69,73,75],\"break\":[1,2,4,14,24,28,29,43,44,45],\"byte\":[10,12,21,31,33,39,42,45,46,47],\"case\":[1,3,10,11,13,14,16,17,20,21,22],\"catch\":[1,4],\"char\":[5,6,10,13,21,28,34,40,42,49,51,58,64,75],\"class\":[8,20,30,31,38,43,48,49,51,64],\"const\":[1,10,13,20,21,26,27,28,34,41,46,53,54,56,57,66],\"default\":[4,8,12,15,16,17,20,21,23,24,26,27,29],\"enum\":[21,27,43,57,65,66],\"export\":[1,3,8,12,21,26,28,29,41,44,45,57,58,61,66,67,71,72,76],\"final\":[1,4,5,6,12,14,16,21,23],\"float\":[4,18,21,22,23,25,31,32],\"fr\\u00e9chet\":67,\"function\":1,\"goto\":46,\"int\":[6,10,11,12,13,14,16,20,21,23,24,25,26,28,29,30,33,35,38,39,40,41,43,45,46,47,49,50,51,52,56,57,58,59,61,62,64,67,68,69,70,72],\"long\":[3,21,24,40,44,45,47,52,54,58,64,65,67,68,69,72],\"new\":[1,2,5,6,9,10,15,21,23,24],\"null\":[1,4,5,6,13,21,23,28],\"public\":[41,44,52],\"return\":[1,4,5,6,9,12,13,14,16,20],\"short\":[4,5,21,23],\"static\":[1,8,13,25,36,43],\"super\":[6,21,25,51,57,67],\"switch\":[24,29,31,44,45,70],\"throw\":[21,23],\"transient\":40,\"true\":[1,12,14,15,16,20,21,22,23,24,25,26,27,29,31,33,35,38,39,40,42,43,45,46,47,48,49,51,52,54,56,57,58,59,61,62,64,67,68,69,70,72,74,75],\"try\":[1,2,16,21,22,23],\"typeof\":[12,13,21,22,23,24,25,28,29,33,38,39,46,49,50,51,57,59,64,68],\"var\":[1,3,16,21,24,39,57,68,70],\"void\":[4,10,13,16,21,28,29,41,49,50,58,60,65,71],\"while\":[1,2,4,10,12,14,16,23,24,25,26,27,28,29,31,33,35,36,39,40,41,42,43,44,45,46,47,48,49,50,51,53,54,57,59,66,67,68,70,72,74],a_1:[21,40],a_2:[21,40],a_3:21,a_ldiv_b:68,a_ldiv_bc:68,a_ldiv_bt:68,a_mul_b:68,a_mul_bc:68,a_mul_bt:68,a_rdiv_bc:68,a_rdiv_bt:68,aaaa1aaaa2aaaa3:49,abbr:61,abbrevi:[26,39,50,61],abc:52,abcd:[42,52],abi_:5,abil:[3,14,24,36,39,40,41,51,64],abl:[4,16,23,24,29,30,35,42,44,45,46,51,54,57],abnrm:67,abort:4,about:[4,5,7,8,10,14],abov:[6,10,12,14,16,20,21,24,25,26,27,28,29,30,33,34,35,36,39,40,41,42,44,45,46,47,48,49,50,51,52,54,57,61,64,67,76],abracadabra:49,abruptli:21,abs2:[20,22,38,46,59,68],absenc:[25,26,40,51],absent:10,absolut:[22,26,33],abspath:62,abstol:[67,68],abstract_cal:47,abstract_call_gf:47,abstract_ev:47,abstractarrai:[14,20,21,35,40,45,46,50,56,59,67,74],abstractfloat:[12,16,25,40,46,51,57,69],abstractli:[40,75],abstractmatrix:[20,56,67],abstractrepl:34,abstractrng:69,abstractsparsematrix:20,abstractstr:[21,27,29,33,34,45,49,50,51,57,59,61,62,64,66,70,71,75],abstracttriangular:40,abstractvector:[20,46],abus:[23,39],ac_ldiv_b:68,ac_ldiv_bc:68,ac_mul_b:68,ac_mul_bc:68,ac_rdiv_b:68,ac_rdiv_bc:68,accent:[49,52,75],accept:[12,16,20,21,22,26,29,30,34,42,43,44,46,49,50,51,52,54,58,59,64,68,69,70,71,74,75],access:[4,8,10,14,16,20],accident:[29,39,41,44],accommod:[16,59,64],accomplish:[21,23,24,26,30,35,39,41,44,48,51,59],accord:[20,33,38,56,57,59,61,67,68,69,74,75],accordingli:[23,30,40,44,46,51,58],account:[33,43,44,49,67,76],accumul:[45,46],accur:[2,21,23,38,44,48,68],accuraci:[33,56,67,68],accurr:52,accustom:43,acd:49,achiev:[16,23,29,36,39,41,42,43,44,45,46,68],acidfre:52,aco:[20,38,68],acosd:[20,38,68],acosh:[20,38,68],acot:[20,38,68],acotd:[20,38,68],acoth:[20,38,68],acoust:67,acquir:70,acronym:[5,44],across:[21,36,38,43,45,51,64,67,70,76],acsc:[20,38,68],acscd:[20,38,68],acsch:[20,38,68],act:[4,20,21,30,39,40,43,51,70],action:[5,16,24,25,34,39,47],activ:[2,42,48,57],actual:[1,20,21,23,24,25,26,29,30,33,39,42,44,46,47,48,49,51,52,54,57,58,64,68,70],acut:52,ada:[25,51],adapt:[46,68],add:[1,4,5,12,17,23,26,27,29,38,39,40,41,44,45,46,47,50,51,55,59,64,68,70,71],add_builtin_func:6,add_float:46,addfun:11,addict:50,addit:[3,4,9,14,17,20,21,22,23,24,25,26,29,31,34,35,36,38,39,40,41,42,44,45,46,49,51,53,55,56,57,67,68,69,70,75],addition:[14,16,21,24,28,29,33,35,38,46,59,70,75],additon:76,addon:50,addopt:75,addproc:[45,70],addr:[64,65],address:[4,10,21,23,31,41],adjac:[20,33,56,74,75],adjust:17,adopt:[14,46,53],adot:52,advanc:24,advantag:[28,29,33,36,39,41,45,46,51,52,55,70],advection_chunk:45,advection_parallel:45,advection_seri:45,advection_shar:45,advection_shared_chunk:45,advic:46,advis:[52,68],aerial:52,aerial_tramwai:52,affect:[6,21,30,41,46,50,54,69,72],aforement:40,africa:52,after:[1,4,6,8,17,21,23,24,25,28,29,30,34,38,39,40,41,42,43,44,46,47,49,51,53,57,58,62,64,65,67,68,71,75],afterward:[23,24,44,64,70,71],again:[6,21,24,25,34,39,42,44,45,46,64,67,70,71,72],against:[8,16,28,29,44,50],agent:44,aggress:29,agre:[23,49],agroup:49,ah12:67,ahead:[26,45],ahr13:67,aid:[26,28,43],aim:36,airi:[20,38,68],airplan:52,airyai:[20,38,68],airyaiprim:[20,38,68],airybi:[20,38,68],airybiprim:[20,38,68],airyprim:[20,38,68],airyx:[38,68],aka:[16,21],alarm:52,alarm_clock:52,albeit:[5,45],alef:52,aleph:52,alert:50,alg:74,algebra:[18,29,32],algorithm:[3,10,14,16,25,29,35,40,44,45,46,51,56,59,67,68,69],alia:6,alias:[20,21,33,49],alien:52,align:[10,12,21],alik:21,all:[1,3,4,5,8,10,12,14,15,16,17,20,21,22,23,24,25,26,27,28,29,30,31,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,54,56],all_to_al:[45,70],allequ:52,allevi:49,alloc:[1,5,6],allow:[3,4,13,14,16,20,21,22,23,24,25,27,28,29,30,33,34,37,38,39,40,41,42,43,44,45,46,47,49,51],almost:[20,28,29,37,39,40,43,46,52,54],alon:[21,29,39,50,51,54],along:[5,14,20,23,26,35,44,45],alpha:[49,52,53,67],alphabet:75,alphanumer:75,alreadi:[21,23,28,29,30,34,35,39,44,50,51,55,57,59,64,70,71,74,75],also:[1,3,5,8,10,12,14,15,16,17,20,21,22,23,24,25,26,27,28,29,30,31,33,34,35,36,38,39,40,41,42,43,44,45,46,47,49,50,51,53,54,55,56,57,58,59,60,64,67,68,69,70,71,73,74,75],alt:34,alter:[21,23,30,39,51],altern:[10,20,24,25,28,29,33,39,41,46,47,48,50,52,55,57,58,59,61,64,68,75],although:[5,10,16,21,23,24,25,30,36,39,40,43,44,45,46,47,51,54,64,68],altogeth:[40,45,50],alveolar:52,alwai:[1,2,9,14,21,23,24,25,26,28,29,30,31,33,35,36,40,41,43,45,46,48,49,50,51,54,57,59,62,64,68,69],amalg:52,amalgam:52,ambigu:[33,39],ambul:52,amd:67,amen:[46,57],america:52,american:[52,68],among:[16,24,30,41,44,45,46,47,50,70],amount:[36,39,41,45,46,47,49,56,57,64],ampersand:52,amplifi:29,analog:[26,29,46],analogu:56,analysi:5,analyz:0,anatomi:24,anchor:52,and_int:46,angdnr:52,angel:52,anger:52,angl:[20,22,38,52,67,68],angleubar:52,angri:[49,52,75],angstrom:52,anguish:52,ani:[1,2,4,5,6,8,9,10,12,13,14],annot:[1,12,21,30,36,39,40,43,44],annuiti:52,anonymousmmap:64,anorm:67,anoth:[4,16,17,20,21,23,24,25,26,28,29,34,39,41,42,43,44,45,46,48,49,50,51,55,57,59,64,70,76],answer:[20,26,45,58,67,68,70],ant:52,antenna:52,anticlockwis:52,anymor:[44,54],anyon:[25,39,44],anyth:[20,24,29,34,35,36,38,39,41,44,49,57,59,69],anywai:[20,26,29,50],anywher:[21,24,30,40,49,51],apach:44,apart:29,apex:51,api:[10,21,26,28,29,36,42,44,61,64,67,74],apl:52,aplboxquest:52,aplboxupcaret:52,aplnotbackslash:52,aplnotslash:52,apolog:48,apostroph:52,appar:[40,41,49],appeal:[14,29],appear:[1,3,14,21,23,28,29,34,40,43,44,46,47,52,54,59,67,68,74],append:[9,14,21,40,43,45,47],appl:[31,34,43,49,52,57,75],appli:[14,20,22,23,24,25,27,30,33,36,38,39,40,43,44,45,46,51,56,57,59,61,62,64,67,68,70,74],applic:[3,12,14,20,21,24,25,27,28,30,33,36,40,46,47,49,51,57,64,66,67,68,69,70],apply_typ:12,appreci:8,approach:[3,14,26,27,29,31,34,36,39,44,45,46,52,67],appropri:[20,21,24,25,29,33,35,36,39,40,42,44,45,48,49,50,51,57,59,64,69,70,75],approv:44,approx:[52,76],approxeq:52,approxeqq:52,approxim:[21,25,47,52,57,68,76],approxnotequ:52,appveyor:[44,71],apr:61,april:[26,61],apropo:57,aptli:39,aquariu:52,arab:49,arbitrari:[1,20,21,25,27,30],arbitrarili:[27,38,40,43,44,51,69],arc:52,arceq:52,archaic:52,architectur:[33,49],archiv:5,area:11,aren:[23,41,44,48,49,67],arg1:[21,31,40,43],arg2:[21,31,40,43],arg3:43,arg:[1,2,4,5,6,9,10,13,16,21,22,23,28,29,30,31,34,39,40,46,57,60,64,70],argc:[6,21,28],args_morespecif:16,argtyp:[12,28],argument:1,argumenterror:[22,24,57,59],argumenttyp:[21,58],argumenttype1:58,argumentvalu:58,argumentvalue1:58,argv:[6,21,28,48],ari:[1,37,52],aris:[4,33,37,39],arisen:[23,25,51],arithmet:[20,21,22,25],arm:[16,21,52],arnoldi:67,around:[5,21,23,28,29,30,39,44,45,50,51,52],arrai:[1,3,4,6,8,9,10,12,14,16,18],arrang:[21,39,45,46,48],array_typ:28,arraycontain:46,arrayref:46,arraytyp:35,arriv:[6,24],arrow:[34,52],arrow_backward:52,arrow_double_down:52,arrow_double_up:52,arrow_down:52,arrow_down_smal:52,arrow_forward:52,arrow_heading_down:52,arrow_heading_up:52,arrow_left:52,arrow_lower_left:52,arrow_lower_right:52,arrow_right:52,arrow_right_hook:52,arrow_up:52,arrow_up_down:52,arrow_up_smal:52,arrow_upper_left:52,arrow_upper_right:52,arrows_clockwis:52,arrows_counterclockwis:52,art:52,arthur:40,articl:33,articul:52,articulated_lorri:52,artifici:40,artist:52,ascend:[44,59,68,74],ascii:[6,21,29,49,64,70,75],asciistr:[6,21,25,29,39,40,42,44,48,49,51,59,64,69,71,75],asec:[20,38,68],asecd:[20,38,68],asech:[20,38,68],asia:52,asid:50,asin:[20,38,68],asind:[20,38,68],asinh:[20,38,68],ask:[16,18,26],asl:[44,71],aspect:[46,48,50,51],assembl:[5,57],assert:[21,25,39,40,46,51,57,65,76],assertionerror:[39,57],assign:[1,12,16],assist:51,associ:[10,24,26,27,29,37,41,44,45,51,53,56,57],assum:[10,17,21,24,26,28,33,42,44,46,51,54,56,58,61,64,67,68,74],assumpt:[17,26,28,68],asteq:52,asteracc:52,asterisk:52,astonish:52,astrosun:52,asum:67,asymp:52,asymptot:52,async:[24,29,42,45,46,48,70],asyncstream:[6,13,45,70],asyncwork:21,at_ldiv_b:68,at_ldiv_bt:68,at_mul_b:68,at_mul_bt:68,at_rdiv_b:68,at_rdiv_bt:68,atan2:[20,38,68],atan:[20,38,68],atand:[20,38,68],atanh:[20,38,68],atexit:[5,57],athlet:52,athletic_sho:52,atm:52,atol:68,atom:1,atreplinit:[34,57],attach:51,attempt:[2,5,21,34,41,42,44,48,51,57,59,64],attent:[20,29],attitud:44,attr:12,atyp:10,aubergin:52,audio:64,audit:[2,44],aug:61,augment:36,august:61,australia:52,author:[27,44,47],auto_unbox:4,autom:[15,44,52],automat:[12,20,21,23,24,25,27],automobil:52,aux:48,auxiliari:[23,25],avail:[5,12,13,14,15,21,24,26,29,31,33,34,37,39,41,42],averag:[20,52],avoid:[20,21,22,23,26,29,30,33,39,40,41,42,43,44,45],awad:67,awai:[24,33,44,46,56,68],awar:[21,26,28,40,41,45,48,50],awint:52,awkward:[30,49],awri:2,axi:38,axpi:67,b96:67,b_a:21,b_a_2:21,babi:52,babuska:56,baby_bottl:52,baby_chick:52,baby_symbol:52,back:[4,5,6,16,21,23,24,25,28,38,44,45,46,49,51,52,54,64,68,70,71],backbon:51,backend:64,backepsilon:52,backhand:52,backppprim:52,backpprim:52,backprim:52,backsim:52,backsimeq:52,backslash:[49,52,53,64,73],backspac:34,backtick:[48,57],backtrac:[2,4,5,6,24,47,57,70,72],backtransform:67,backward:[57,67,68],bactrian:52,bad:[21,24],badg:52,badli:44,bag:[51,52],baggag:52,baggage_claim:52,bagmemb:52,bail:44,balanc:67,ball:52,balloon:52,ballot:52,ballot_box_with_check:52,bamboo:52,banana:[43,49,52,75],band:67,bang:74,bangbang:52,bank:52,banknot:52,banner:[31,34],bar:[23,24,27,29,30,31,39,40,41,44,46,47,48,51,52,54,58,59,70],bar_chart:52,barb:52,barbar:39,barber:52,barcap:52,barcup:52,baremodul:[27,41,54,57],barleftarrow:52,barleftarrowrightarrowbar:52,barovernorthwestarrow:52,barrier:28,barrightarrowdiamond:52,barve:52,barwedg:52,base64:64,base64decod:64,base64decodepip:64,base64encod:64,base64encodepip:64,base64pip:64,base:[1,2],basebal:52,basenam:62,bash:[8,21],basi:[26,67,74],basic:1,basketbal:52,bath:52,bathtub:52,batteri:52,bauer:67,baz:[23,24,29,30,39,48,51,59],bbb:52,bbba:52,bbbb:52,bbbc:52,bbbd:52,bbbe:52,bbbeight:52,bbbf:52,bbbfive:52,bbbfour:52,bbbg:52,bbbgamma:52,bbbh:52,bbbi:52,bbbj:52,bbbk:52,bbbl:52,bbbm:52,bbbn:52,bbbnine:52,bbbo:52,bbbone:52,bbbp:52,bbbpi:52,bbbq:52,bbbr:52,bbbseven:52,bbbsix:52,bbbt:52,bbbthree:52,bbbtwo:52,bbbu:52,bbbv:52,bbbw:52,bbbx:52,bbby:52,bbbz:52,bbbzero:52,bbrktbrk:52,bbsum:52,bce:26,bdsdc:67,bdsqr:67,beam:52,bear:52,beat:52,becaus:[4,5,12,13,14,16,20,21,23,24,26,28,29,36,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,56,59,65,67,68,69,72],becom:[14,23,24,29,30,39,45,46,47,48,49,50,51,53,67,70],bee:52,been:[2,4,5,12,14,23,24,25,29,30,34,36,37,38,41,42,44,45,46,47,48,49,51,54,57,65,67,70,71],beer:52,beetl:52,befor:[1,3,5,6,8,13,17,20,21,23,24,25,26,28,29,30,33,34,36,39,40,41,42,43,44,45,46,47,48,49,51,54,57,59,61,62,64,66,67,68,70,74,75],beforehand:21,begin:[3,6,12,14,16,21,23,24,27,29,30,31,34,39,42,44,45,46,47,49,51,53,54,55,59,62,64,70,73,75],beginn:52,behav:[17,20,21,22,23,26,29,39,40,45,46,49,50,51,54,56,59],behavior:[16,20,21,23,24,25,29],behaviour:[25,45,68,75],behind:[29,42,44,52],believ:36,bell:52,belong:[40,44,51,75],below:[3,6,16,20,21,24,28,30,31,35,39,41,44,45,46,47,49,51,52,54,57,67],belt:52,benchmark:[46,68],beneath:44,benefici:[29,51],benefit:[45,46],bento:52,benzen:52,benzenr:52,beowulf:70,bernoulli:56,berr:67,besid:[8,25,44,49,52,69],bess:[20,38,68],bessel:[38,68],besselh:[20,38,68],besselix:[38,68],besselj0:[20,38,68],besselj1:[20,38,68],besselj:[20,38,68],besseljx:[38,68],besselk:[20,38,68],besselkx:[38,68],bessely0:[20,38,68],bessely1:[20,38,68],besselyx:[38,68],best:[2,8,14,21,23,24,27,29,41,43,44,46,47,56,64,68],bet:[2,52],beta:20,beth:52,better:[8,14,17,20,23,25,39,41,44,45,46,48,50,57,68,72],between:[3,8],beverag:52,beyond:[20,25,40,49,57,64],bfft:68,bh83:67,bias:67,bicep:52,bicycl:52,bicyclist:52,bidiag:40,bidiagon:[37,40,67],big:[3,25,57,64,68,69],big_str:1,bigblacktriangledown:52,bigblacktriangleup:52,bigbot:52,bigcap:52,bigcirc:52,bigcup:52,bigcupdot:52,bigfloat:[12,33,40,43,68],bigger:29,biggest:[45,46],bigint:[25,29,33,40,43,69],biglib:41,bigodot:52,bigoplu:52,bigotim:52,bigslopedve:52,bigslopedwedg:52,bigsqcap:52,bigsqcup:52,bigstar:52,bigtim:52,bigtop:52,bigtriangledown:52,bigtriangleup:52,biguplu:52,bigve:52,bigwedg:52,bigwhitestar:52,bike:[44,52],bikini:52,billiard:52,bin:[2,4,8,21,28,64,68,69],bin_arr:69,binari:[2,20,29,31,33,37,38,42,43,44,52,56,57,59,64,68,69,70,76],bind:[6,12,22,23,27,29,30,31],bind_addr:[31,45,70],bindep:41,binomi:68,bird:52,birthdai:52,bischof1987:67,bischof:67,bisect:52,bit:[1,4,5,6],bitarrai:40,bitbroadcast:56,bitbucket:44,bitcod:[31,57],bitfield:62,bitpack:56,bitrand:69,bitshift:38,bitstyp:[21,45,49,51,70],bitunpack:56,bitvector:[56,59],bitwis:[20,24,33],bkarow:52,bkfact:67,bla:[2,20,21],black:[30,52],black_circl:52,black_jok:52,black_large_squar:52,black_medium_small_squar:52,black_medium_squar:52,black_nib:52,black_small_squar:52,black_square_button:52,blackcircledrightdot:52,blackcircledtwodot:52,blackcircleulquadwhit:52,blackinwhitediamond:52,blackinwhitesquar:52,blacklefthalfcircl:52,blacklozeng:52,blackpointerleft:52,blackpointerright:52,blackrighthalfcircl:52,blacksmilei:52,blacksquar:52,blacktriangl:52,blacktriangledown:52,blacktriangleleft:52,blacktriangleright:52,blank:[34,49,52,64],blanksymbol:52,blas_set_num_thread:67,blascopi:67,blasfloat:67,blindli:35,blkdiag:67,blkhorzov:52,blksize:[57,62],blkvertov:52,blockful:52,blockhalfshad:52,blocklefthalf:52,blocklowhalf:52,blockqtrshad:52,blockrighthalf:52,blockthreeqtrshad:52,blockuphalf:52,blog:[21,29,33,38,44],blond:52,bloomfilt:44,blossom:52,blowfish:52,blue:[52,64],blue_book:52,blue_car:52,blue_heart:52,blush:[29,52],boar:52,board:52,boat:52,bodi:[1,3,4,9,24,25,29,30,35,39,40,41,43,46,50,54,58,59,64,70],bodyexpr:3,boi:52,boilerpl:[21,39],bold:52,bolt:52,bomb:52,bone:52,bonu:16,boo:39,book:[33,44,52],bookmark:52,bookmark_tab:52,bool:[4,9,16,20,21,24,25,26,29,33,38,40,43,45,46,51,56,57,58,59,61,62,64,67,68,69,70,75],boom:[26,52],boot:[5,6,16,31,51,52],bootup:2,borrow:[36,48],bot:52,both:[3,5,12,14,16,17,20,21,22,23,24,25,26,27,29,30,33,34,35,39,40,41,43,44,45,46,47,48,49,50,51,52,54,56,57,59,67,68,71,74],botsemicircl:52,bottl:52,bottleneck:[46,47],bound:[1,3,5,6,13,14,16,22,29,30,31,39,44,46,49,51,53,54,56,57,66,67,68],boundari:[21,46,49,67],boundscheck:1,boundserror:[24,33,35,39,43,49,57,76],bouquet:52,bow:52,bowl:52,bowti:52,box:[1,4,5,6,10,28,46,51,52],boxast:52,boxbar:52,boxbslash:52,boxcircl:52,boxdiag:52,boxdot:52,boxed_uint8_cach:6,boxminu:52,boxplu:52,boxtim:52,brace:51,branch:[1,24,29],bread:52,breakag:44,bref:45,breve:52,brfft:68,bride:52,bride_with_veil:52,bridg:[28,52],bridge_at_night:52,brief:[33,35,44,45,64],briefcas:52,briefli:[23,40,46],bright:52,bring:[27,61],brittl:44,broad:[33,38,57],broadcast_f:56,broadcast_funct:56,broadcast_getindex:[20,56],broadcast_setindex:[20,56],broadli:14,broke:44,broken:[49,52,57,65],broken_heart:52,broker:45,brought:[41,45],browser:[47,52],bruce:33,bsd:[44,71],bsimilarleftarrow:52,bsimilarrightarrow:52,bsolhsub:52,bswap:69,btime:52,buf:13,buffalo:52,buffer:[13,21,34,42,47,48,64,72],bufferstream:45,bug:[17,21,29,44,46,50,52],bugfix:29,build:2,build_sysimg:15,built:[4,6,8,10,16,20,21],builtin:[4,5,6,8,16,35],bulb:52,bulid:8,bulk:[5,44],bullet:[27,52],bullettrain_front:52,bullettrain_sid:52,bullsey:52,bumpeq:52,bumpeqq:52,bumpi:52,bunch1977:67,bunch:[44,67],bunchkaufman:67,bundl:51,bunni:52,busi:47,busstop:52,bust:52,bust_in_silhouett:52,busts_in_silhouett:52,button:52,buy_drink_for:27,bytes2hex:69,bytestr:[21,57,62,75],c153:67,c169:67,c1cb1c1:44,c394:67,c410:67,c_char_p:28,c_null:[21,60],cablewai:52,cach:[4,16,21,39,41,44,45,46,57,64,68],cactu:52,cake:52,calcul:[3,24,26,28,33,39,45,46,59,65,67,68],calendar:[26,52,61],calendr:26,call1:46,callabl:[28,40,58,66,70],calle:[21,23,24],caller:[13,21,24,30,39,43,45,46],calloc:65,camel:[50,52,53],camera:52,camp:[25,51],can:[1,2,3,4,5,8,9,10,11,13,14,15,16,17,20,21,22,23,24,25,26,27,28],cancel:[34,52],cancer:52,candi:52,candid:[16,23,25,33,40,49,51],candra:52,candrabindu:52,cannot:[5,14,21,23,24,25,27,29,30,33,36,39,40,41,43,44,45,46,48,49,51,54,57,58,59,64,65,68,70],canon:[42,57,64,68,75],canonic:[62,75],cap:[46,52],capabl:[5,12,36,39,43,45,64],capac:59,capdot:52,capit:[33,42,50,52,53],capital_abcd:52,capricorn:52,capricornu:52,captur:[1,39,45,47,48,49,70,75],capwedg:52,car:52,card:52,card_index:52,cardin:52,care:[14,20,21,24,38,43,44,45,46],carefulli:[20,25,48],caret:52,carlo:45,caron:52,carousel:52,carousel_hors:52,carp:52,carri:[20,43,45,47],carriag:49,carriagereturn:52,cartesianindex:[20,40],cartesianindex_2:20,cartesianrang:56,casefold:75,casino:26,cast:[21,28,33,40],castl:52,casual:36,cat2:52,cat:[13,20,44,52,56,57],catalan:69,catch_backtrac:[24,57],catch_block:1,catdoc:27,categori:[25,38,53,75],caught:[1,4],caus:[4,20,21,24,29,30,38,39,41,45,46,47,48,51,57,58,68,70,75],caution:[46,50,52,57],cbind:43,cbrt:[20,38,52,68],ccall:[4,5,6,8,13,16],cchar:[21,58],cconvert:[21,58],cdecl:21,cdll:28,cdot:52,cdotp:52,cdoubl:[21,58],cedilla:52,ceil:[20,38,44,46,50,52,68],celebr:52,cell:[20,45,46,50,56,64,73],center:[52,68],centr:52,central:[37,40],cenv_t:16,ceremoni:52,certainli:48,cflag:[17,28],cfloat:[21,58],cglobal:[21,58],cgutil:8,chain:[1,21,24],chang:[8,11,21,23,24,26,28,29,33,34,38,39,40,41,42,43],change_arrai:29,change_valu:29,changedfil:44,chapter:[23,39,57],charact:[1,21,26,27,29,34,39,42,43,44,48],characterist:[29,33,37,45,46],charg:24,chart:52,chart_with_downwards_trend:52,chart_with_upwards_trend:52,charwidth:75,cheatsheet:31,check:[1,3,13,14,16,17,21,22,23,26,28,29,30,31,33,37,40,43,44,46,49,50],checkbound:56,checked_lib:41,checker:17,checkered_flag:52,checkmark:52,cheer:52,chequer:52,cherri:52,cherry_blossom:52,chestnut:52,chi:52,chick:52,chicken:52,child:[28,47,48,51,57],children:[17,48,51,52],children_cross:52,chime:52,chines:49,chmod:62,chocol:52,chocolate_bar:52,choic:[14,21,24,29,40,45,46,47,51,52,67,68,72,75],chol:67,choleski:[37,67],choleskypivot:[37,67],cholfact:67,cholmod:67,cholmodfactor:67,chomp:[48,64,75],choos:[29,40,44,45,47,50,51,56,64,68,74],chop:75,chosen:[20,24,30,45,46,59,67,68,70,74],chr2ind:[49,75],christma:52,christmas_tre:52,chunk:[5,45,51],church:52,cinema:52,cint:[16,21,58],cintmax_t:[21,58],circ:52,circeq:52,circl:52,circlearrowleft:52,circlearrowright:52,circledast:52,circledbullet:52,circledcirc:52,circleddash:52,circledequ:52,circledparallel:52,circledr:52,circledrightdot:52,circledstar:52,circledtwodot:52,circledwhitebullet:52,circlellquad:52,circlelrquad:52,circleonleftarrow:52,circleonrightarrow:52,circletophalfblack:52,circleulquad:52,circleurquad:52,circleurquadblack:52,circlevertfil:52,circshift:56,circu:52,circul:52,circular:52,circularli:56,circumflex:52,circumst:[9,10,14,24,46],circumv:[4,44,46],circus_t:52,cirfnint:52,city_sunris:52,city_sunset:52,cityscap:52,cjk:[31,52,53],claim:52,clamp:68,clang:[21,28,46],clap:52,clapper:52,clarifi:[14,46,50],clariti:[24,44],clark:40,clarke61:40,clash:39,classic:[21,26,30,48,51],classifi:[39,75],claus:1,cld:[38,46,68],clean:[5,6,24,26,44,54,57],cleaner:[33,50],cleanli:23,cleanup:[21,28,41,45,70],clear:[4,14,23,29,34,41,44],clear_malloc_data:[47,72],clearer:[33,47,51],clearest:43,clearli:[21,24,29,30,39,41,51],clever:[25,29,40],cleverest:29,click:[31,34,44,52],client:[6,42,47,57,64],clientsid:42,clink:52,clipboard:[52,57],clock1030:52,clock10:52,clock1130:52,clock11:52,clock1230:52,clock12:52,clock130:52,clock1:52,clock230:52,clock2:52,clock330:52,clock3:52,clock430:52,clock4:52,clock530:52,clock5:52,clock630:52,clock6:52,clock730:52,clock7:52,clock830:52,clock8:52,clock930:52,clock9:52,clock:[21,52],clockoint:52,clockwis:52,clonabl:44,clone:[43,44,71],clong:[21,58],clonglong:[21,58],close:[1,5,16,24,30,42,44,45,47,49,51,52,57,64,66,67,70],closed_book:52,closed_lock_with_kei:52,closed_umbrella:52,closedvarcap:52,closedvarcup:52,closedvarcupsmashprod:52,closer:[12,29,43,67],closest:[16,23,25,33,40,49,51,57,67],closet:52,closur:[54,57,70],cloth:52,cloud:52,clover:52,club:52,clubsuit:52,clutter:27,clwintegr:52,cmd:[1,39,45,48],cmd_gen:39,cmp:[29,68],coaster:52,cocktail:52,code_llvm:[12,46,57],code_llvm_raw:57,code_low:[12,46,57],code_n:[12,29,46,57],code_typ:[12,46,57],code_warntyp:12,codegen:[4,5,8],codepoint:75,coeffici:22,coff_t:58,coffe:52,coin:45,col:[46,47,56,67,72],cold:52,cold_sweat:52,coll:[59,69],collabor:44,collect:[2,8,16,18,20],collection2:59,collector:5,collid:44,collis:52,colon:[14,20,30,34,40,46,52,56,68],coloneq:52,color:[30,31,57,64],colptr:[20,67],com:[42,44,67],combin:[5,14,22,23,24,25,28],come:[3,5,23,24,25,33,34,35,39,43,44,46,47,49,54,74],comfort:29,comma:[21,39,51,52,54,64],commaminu:52,command:[4,5,6,8,14,15,17],comment:[8,10,16,23,39,43,44,49,61,64,73,75],comment_char:64,commit:[2,34,44,64,67,71],committe:45,common:[2,10,21,22,23,24,25,29,30,33,34,35,38,39,40,41,42,43,44,45,46,47,48],commonli:[10,20,33,45,49,51,59],commun:[44,45],compact:[3,30,36,37,64,67,75],compactli:[51,67],compar:[10,16,20,21,24,25,26,30,36,38,39,44,45,46,49,50,51,57,59,64,68,74],comparison:[1,20,21,22,24],compat:12,compens:56,compil:[1,2,4,5,6,7,8],compilecach:[41,57],complain:44,complement:[33,52,59],complementari:[38,68],complet:[4,10,13,20,21,23,25,29,30,31],complete_m:23,complex128:[21,67,69],complex64:[21,67,69],complex:[1,5,16,18,20,21],complic:[24,28,35,39,41,44,46,48],compon:[58,59,62,67,68,71,73],componentwis:67,compos:[5,49,75],composit:[21,22,23,40,41],compositeexcept:[24,70],compoundperiod:40,compq:67,comprehens:1,compress:4,compris:[1,49],comput:[3,5,14,16,18,20,21,23,24,25,28,29,30,31,32,33,34,35,36,37,38,39,43,44],compute_dot:21,conceiv:[16,46],concept:[37,40,50,51,54],conceptu:[40,49,51],concern:[29,39,54,65],concis:[24,30,46,50,57],conclud:[47,50],conclus:44,concret:[12,14,16,20,23,40,45,46,49,50,51,57],cond:[24,43,57,67],condit:1,conditionexpr:3,condskeel:67,confetti:52,confetti_bal:52,confid:47,configur:[6,28,34,44,45],confirm:[51,62],conflict:16,confound:52,confus:[25,29,43,44,47,49],cong:52,congdot:52,congratul:[2,52],congruent:[38,52],conic:52,conictap:52,conj:[22,56,68],conjquant:52,conjug:[43,52,56,67,68],conjunct:[30,34,55,56],connect:[24,31,42,44,45,48,49,51,64,70],connect_at:45,connect_id:[45,70],connector:53,conqueq:67,conquer:67,conscious:25,consecut:[1,52,58,64],consequ:[14,16,29,39,44,45,46,47,51,70],conserv:44,consid:[3,9,11,14,16,17,21,23,24,25,26,28,29,30,35,38,39,41,42,43,44,45,46,47,49,50,51,54,57,58,61,64,68,69,70,74],consist:[1,10,23,40,44],consol:[34,47],constant:[1,5,6,13,18,20],constantli:70,constitut:[16,45],constrain:[16,23,40,51],constraint:[16,23,38,40,67],construct:[1,3,4,10,14,16],construction_work:52,constructor:[10,18],constuct:61,consult:44,consum:[14,24,29,47,48,57,70],consumpt:57,contain:[1,2,3,5,6,9,10,13,14,15,16,20,21,23,24,26,27,28,30,35,39,41,43,44,45],content:[4,6,15,21,23,27,28,29,39,41,42,44,48,55,57,62,64,68,71],context:[10,23,24,26,28,29,39,41,43,44,45,46,51,53,57,70,73],contigu:[14,46,51,75],continu:[1,6,16,23,24,25,26,36,40,42,43,46,47,49,61,67],contour:52,contrast:[16,20,29,30,39,43,44,45,46,47,51,54],contravari:51,contrib:[2,17],contribut:[2,17,29,44],contributor:44,contriv:[24,39,46,49],control:[1,5,18,20],conv2:68,conv:68,convei:[1,29,36,54],conveni:[3,9,12,16,20,22,23,24,25,26,28,30,38,39,40,42,43,44,45,46,49,50,51,52,54,56,59,62,64,67,70],convenience_stor:52,convent:[9,20],converg:67,convers:[14,18,20],convert:[1,4,5,10,14,20,21,22,23,25,26,27],convolut:68,cook:[6,33,38,52],cooki:52,cool:52,cooper:[24,42,45],coordin:[24,38,51,68],cop:52,copi:[1,20,21,28,30,39,41,44,45,46,47,50,51,55,56,57,58,59,62,64,67,69,70,72,74,75],coprod:52,coproduct:52,copy_col:46,copy_col_row:46,copy_row:46,copy_row_col:46,copyast:[1,39],copyright:52,copysign:[20,38,68],cor:68,core2:15,core:[2,5,6,16,23],corn:52,corner:[44,52],corpu:2,correct:[21,23,29,33,39,46,51,58,68],correctli:[20,21,25,27,38,41,44,49,65],correl:68,correspond:[1,10,13,14,16],corrupt:[10,46,49,58],cosc:[20,38,68],cosd:[20,38,68],cosec:68,cosh:[20,38,68],cosin:[67,68],cospi:[20,38,68],cost:[29,33,39,47,55,68,74],cot:[20,38,68],cotang:68,cotd:[20,38,68],coth:[20,38,68],could:[14,20,23,24,25,26,29,30,31,33,34,35,38,39,40,41,42,45,46,47,49,50,51,57,64],count:[20,21,24,29,31,35,40,44,45,47,56,59,64,68,70,72],count_head:45,count_on:69,count_zero:69,counter:[8,29,41,47,54,57,70],counterintuit:51,counterpart:[20,43],countfrom:59,countlin:64,countnz:[20,56],coupl:[46,52],couple_with_heart:52,couplekiss:52,cours:[23,27,29,30,39,44,45,46,47,48,49,51,55],cousin:46,cov:68,covari:[16,51,68],cover:[10,39,40,49,52,67],coverag:[31,47],cow2:52,cow:52,cplex:44,cpp:[4,5,8,21],cptrdiff_t:[21,58],cpu:[2,14,15,24,31,45,46,60],cpu_cor:[60,70,76],cpu_target:15,crack:23,cracker:52,crash:0,cream:52,creat:[1,2,3,5,6,8,9,10,13,14,15,16,20],creation:[5,10,23,30,62,68],credit:52,credit_card:52,crescent:52,crescent_moon:52,criterion:26,critic:[12,21,45,46],crlf:[49,75],crocodil:52,cross:[5,13,49,52,67,68],crossed_flag:52,crosshatch:52,crown:52,crucial:[17,29,36],cruft:44,cry:52,crying_cat_fac:52,cryptograph:69,crystal:52,crystal_bal:52,cscd:[20,38,68],csch:[20,38,68],cshort:[21,58],csize_t:[21,58],cssize_t:[21,58],cstring:21,cstyle:4,csub:52,csube:52,csup:52,csupe:52,csv:[48,70],ct_eval_cal:47,ctime:[57,62],ctranspos:[30,67],ctrl:[27,57,58,70],cubatur:68,cube:[38,52],cuchar:[21,58],cuint:[21,58],cuintmax_t:[21,58],culong:[21,58],culonglong:[21,58],cumbersom:[42,49],cummax:56,cummin:56,cumprod:56,cumsum:56,cumsum_kbn:56,cumul:[47,56],cup:52,cupdot:52,cupid:52,cupve:52,curat:44,curiou:25,curl:[52,62],curli:[1,51,52],curly_loop:52,curlyeqprec:52,curlyeqsucc:52,curlyve:52,curlywedg:52,currenc:[52,53],currency_exchang:52,current:[1,3,4,5,6,8,14,15,16,17,20,21,24,28,29,31,35,40,41,42,43,44,45,46,47,48,49,51,52,54,57,59,60,61,62,64,65,66,67,68,69,70,71,72,74,75,76],current_modul:[6,21,41,57],current_task:[24,70],curri:52,cursor:[27,34],curv:[46,52],curvearrowleft:52,curvearrowright:52,cushort:[21,58],custard:52,custom:[8,20,24,26,27],custom_handl:76,customary_phras:53,customize_kei:34,cut:48,cwchar_t:[21,49,58,75],cwd:42,cwstring:21,cxx:21,cxxflag:28,cycl:59,cyclic:56,cyclon:52,cyril:49,d7ff:49,dagger:52,dai:[26,34,40,61],daili:36,dalet:52,daleth:52,damag:[46,48],dan:29,dancer:52,danger:[50,52],dango:52,dark:52,darrai:45,dart:52,darwin13:[31,34],darwin:60,dash:[44,52],dashleftharpoondown:52,dashrightharpoondown:52,dashv:52,data:[1,4,5,8,10,14,16,18,20],data_cel:64,dataarrai:68,databas:26,datafram:[43,44],datarootdir:[15,28],datatyp:[12,16,28,34,41,51,57],date:[2,18],date_str:26,dateformat:[26,61],datefunct:26,datetim:18,datetime2julian:61,datetime2rata:61,datetime2unix:61,david:33,dawson:[20,33,38,68],dayabbr:61,daylight:26,daynam:[26,61],dayofquart:[26,61],dayofweek:[26,61],dayofweekofmonth:[26,61],dayofyear:[26,61],daysinmonth:[26,61],daysinyear:61,daysofweekinmonth:61,dbg:[12,57],dbkarow:52,dblarrowupdown:52,dct:68,ddagger:52,ddddot:52,dddot:52,ddot:52,ddot_:21,ddotseq:52,ddownarrow:52,de77ee4dc0689b12c5e8b574aef7f70e8b311b0:44,dead:57,deal:[6,14,16,21,26,38,42,46,49],dealloc:21,dealt:26,debug_bootstrap:2,debugg:16,debuginfo:[5,8],dec:[61,69],decad:36,decemb:61,decid:[5,23,44,45,47,50,51],decidu:52,deciduous_tre:52,decim:[43,68,69],decis:[14,46,51],declar:[1,10,12,16,20,21,23,24,25],decod:64,decompos:75,decomposit:[20,37,67,75],deconv:68,decor:[27,52,64],decoupl:40,decreas:[46,47],decrement:[67,70],dedent:49,dedic:[25,34,39,70],deem:[22,29,40],deep:57,deepcopi:[20,57],deepcopy_intern:57,deeper:47,deepli:[24,29,39,47,51,52],defalg:74,default_handl:76,default_meta:71,default_sysimg_path:15,default_v:46,defeat:29,defer:64,defici:67,defin:[4,5,6,9,10,11,12,13,16,20,21,22,23,24],definit:1,deg2rad:68,degeneraci:67,degrad:29,degre:[23,25,38,52,56,68],del:52,delai:[30,47,52,57,72],deleg:[23,25,40,45],delet:4,deleteat:59,deliber:29,delici:52,delim:[64,75],delimet:64,delimit:[26,27,31,41,43,49,52,61,64,68,73,75],deliv:70,deliveri:52,delta:[44,52,53],demand:[5,10,24,51],demonstr:[21,30,39,41,44,45,51],den:[22,23,25,51,68],denomin:[20,22,23,25,51,57,68],denorm:[46,69],denot:[29,43,51],densearrai:[16,20,40],densest:33,densiti:[20,56],dep:[2,8,71],depart:52,department_stor:52,departur:36,depend:[5,10,11,14,16,21,24,25,26,29,30,33,39,40,41,42,43,44,45,46,49,51,56,57,59,64,66,67,68,70,71,72,73,75],deploi:36,depth:[12,33,71,72],depwarn:31,deregist:[45,70],deriv:[20,38,46,67,68],descend:51,describ:[1,3,5,14,16,17,21,22,23,24,25,29,30,33,34,35,36,41,44,45,47,49,51,54,56,60,61,64,67,68,70],descript:[6,20,21,33,35,38],descriptor:[48,62,64,70],deseri:[5,57,64],deserialis:6,deserv:23,desir:[5,24,26,41,45,46,47,50,57,62,68],desk:52,despit:[16,29,40,47,51],dest:[56,58,62,67],destin:[20,57,58,59],destroi:[28,29],destruct:59,destructur:[30,49],det:[37,67],detach:57,detail:[5,10,12],detect:[16,17,29,47,54,64],determin:[1,2,4,5,20,21,23,24,25],determinist:[4,39,48],dev:[13,44,57],devector:[36,43],deviat:[68,69],devic:[41,46,57,62,64],devnul:[57,64],devot:5,dezh:52,dft:68,dht:68,diacrit:[53,75],diaeresi:52,diag:[43,67],diagdown:52,diagind:67,diagm:[43,67],diagnos:46,diagnost:[8,24],diagon:[37,40,43,51,52,56,67],diagpoint:51,diagup:52,diamet:52,diamond:52,diamond_shape_with_a_dot_insid:52,diamondbotblack:52,diamondleftarrow:52,diamondleftarrowbar:52,diamondleftblack:52,diamondrightblack:52,diamondsuit:52,diamondtopblack:52,diassembl:8,dicei:52,diceii:52,diceiii:52,diceiv:52,dicev:52,dicevi:52,dict:[26,29,34,35,41,43,44,45,56,57,59,68,70,71,72],dict_comprehens:1,dictat:[25,51],dictchannel:45,dictionari:[27,30,34,41,44,45,50,56,57,59,68,70,71,72],did:[9,15,39,42,45,46,48,57],didn:[29,42,50],die:[52,61],diff:[14,44,56],differ:1,differenti:[51,52,68],difficult:[29,30,46,50,51,54],difficulti:[23,29,51],dig:16,digamma:[20,38,52,68],digest:46,digit:[1,5,33,43,49,52,53,61,64,68,69,75],digraph:52,dim:[3,10,14,20,21,28,35,39,45,56,58,59,64,68,69,70,74],dimanch:26,dimens:[3,14,20,28,35,38,39,43,45,46,51,56,59,64,67,68,69,73,74],dimension:[14,18],dimensionmismatch:57,diminish:36,dimlength:56,dingasterisk:52,dir:[31,44,57,62,70,71],direct:[2,12,15,20,21,22,24,39,44,51,52,67],directindexstr:34,directli:[1,5,8,10,13,21,22,23,24,25,28,33,35,36,39,41,44,45,46,47,48,50,52,56,57,64,65,71,74,75,76],directori:[2,4,5,8,17,28,41,43,44,47,55,57,60,62,64,70,71],dirichlet:[38,68],dirnam:62,disabl:[17,28,31,46,57,58],disable_sigint:58,disadvantag:55,disallow:[31,53],disambigu:[40,49,50,72],disappear:46,disappoint:52,disappointed_reliev:52,disasm:8,disastr:14,disc:52,discard:[44,57],disclaim:39,disconnect:42,discontinu:68,discourag:[43,53,70],discov:[4,21,34],discret:[26,61,68],discuss:[12,14,16,24,25,33,39,40,42,44,46,47,49,51,57],disin:52,disjoint:45,disjquant:52,disk:[2,42,52,64,70],dispar:40,dispatch:[5,12,14,16,21,23,25,30,36,39,40,43,51,57,60,64],displac:14,display:64,disregard:41,disrupt:50,distanc:[20,22,33,56,57],distinct:[1,14,16,23,24,26,35,39,40,41,45,49,51,54,75],distinguish:[16,26,38,39,43,45,57,74],distr:1,distribut:[2,5,17,20,28,29,36,43,44],distributedarrai:45,div:[14,20,23,25,26,33,38,46,52,68],diverg:[44,68],divid:[23,25,27,33,38,45,50,52,67,68],divideerror:[24,33,57],divideontim:52,divis:[22,23,25,26],divisor:[23,38,68],divrem:[38,68],dizzi:52,dizzy_fac:52,dl_load_path:[60,66],dlamch:67,dlclose:66,dlext:66,dll:[15,66],dlopen:[21,66],dlopen_:66,dlsym:[21,58,66],dlsym_:66,dmemdebug2:17,dmemdebug:17,do_cal:6,do_comput:48,do_not_litt:52,do_test:76,do_test_throw:76,do_work:48,doc:[1,27,31,34,45,68,75],doc_str:27,docil:27,docstr:27,document:3,doe:[1,6,14,16,17,20,21,22,23,24,25,26,28],doesn:[4,21,23,25,29,33,39,43,44,46,47,49,50,51,54,57,67],dog2:52,dog:52,doi:67,doll:52,dollar:52,dolphin:52,domain:[36,42,43,44,45,56,57,64],domainerror:[22,24],domin:46,don:[14,20,23,26,29,31,39,44,46,48],done:[6,21,23,24,26,27,28,29,33,35,39,40,41,42,43,44,45,46,48,50,54,56,57,59,64,71],door:52,dot:[20,21,35,43,46,52,54,62,67],dotc:67,doteq:52,dotequiv:52,doth:57,dotless:52,dotminu:52,dotmulfun:11,dotplu:52,dotsim:52,dotsminusdot:52,dottedcircl:52,dottedsquar:52,dottim:52,dotu:67,doubl:[20,21,28,31,33,34,39,44,48,49,50,52,58,64,67],doublebarve:52,doubleplu:52,doughnut:52,dow:61,down:[2,6,24,26,29,34,47,52,59,65],downarrow:52,downarrowbar:52,downarrowuparrow:52,downdasharrow:52,downdownarrow:52,downharpoonleft:52,downharpoonright:52,downharpoonsleftright:52,downleftrightvector:52,downleftteevector:52,downleftvectorbar:52,download:[29,31,44,62],downrightteevector:52,downrightvectorbar:52,downsid:46,downward:52,downwhitearrow:52,downzigzagarrow:52,dozen:[29,40],draft:52,draftingarrow:52,dragon:52,dragon_fac:52,dramat:45,draw:52,drawback:[29,51],drawn:68,drbkarrow:52,dress:52,drill:6,drink:52,drive:[45,62],driver:[45,70],droang:52,dromedari:52,dromedary_camel:52,drop:[14,20,52,56,59,62],droplet:52,dsfmt:47,dsfmt_gv_fill_array_close_open:47,dsol:52,dst:62,dt2:26,dth:61,dtruss:2,du2:67,dualmap:52,duck:[50,67],due:[2,21,24,29,44,45,46,47,48,50,57,67],dumbsum3:47,dumbsum:47,dummi:51,dummymodul:45,dump:[4,5,6,8,12,13,26,39,47,64],dup:67,duplic:56,dusk:52,dvd:52,dylib:[15,28,49,66],dynam:[5,8,21,25,28,30,34,36,39,40,41,43,45,46,49,51,57,63,64],dynamic_arch:2,e000:49,e10:33,each:[1,3,5,6,8,10,12,13,14,16,20,21,23,24,26,27,28,29,30,31,33,34,35,38,39,40,41,43,44,45,46,47,48,49,51,54,56,57,58,59,61,64,67,68,70,71,72,74,75],eachindex:[20,56],eachlin:[42,59,64],eachmatch:75,eagerli:43,ear:52,ear_of_ric:52,earli:[2,5,6,24],earlier:[23,44,46,70],earth:[26,52,61],earth_africa:52,earth_america:52,earth_asia:52,eas:36,easi:[16,20,21,24,27,30,33,34,36,39,44,45,49,50,51,57],easier:[3,21,24,30,41,42,43,44,45,50,51,59],easiest:[16,24,31,39,44],easili:[1,22,23,24,25,27,29,33,35,36,39,40,44,46,48,49,51,74],east:52,eax:29,echo:[13,31,34,39,42,44,48],economi:67,ecosystem:[10,46],edg:[1,39,68,70],edge1:68,edge2:68,edit:[12,34,44,53,57,71],edit_move_up:34,editor:[44,49],ef45f54b:44,effect:[4,20,21,23,24,27,29,30,33,38],effici:[5,14,20,21,26,28,29,35,36,38,39,40,43,45,46,47,49,50,51,54,55,56,57,59,61,64,67,68,74],effortless:22,egal:[10,57],egg:52,eggplant:52,egsdot:52,eiffel:51,eig:[37,67],eigen:[37,67],eigendecomposit:67,eigensolv:67,eigensystem:67,eigenvalu:67,eigenvector:67,eigfact:67,eight:[49,51,52],eight_pointed_black_star:52,eight_spoked_asterisk:52,eighteen:52,eighth:52,eighthnot:52,eigmax:[37,67],eigmin:[37,67],eigval:[37,67],eigvalu:67,eigvec:[37,67],eip:4,either:[3,8,16,17,20,21,23,24,25,26,27,29,30,31,35,38,39,40,43,44,46,49,50,51,54,56,57,58,62,64,67,68,69,70,75,76],elaps:[39,46,57,64],electr:52,electric_plug:52,eleg:[33,36],element:[1,3,12,14,16,20,21,23,24,26,27,28,29,30,34,35,38,39,40,42,43,45,46,47,48,49,50,51,52,55,56,57,58,59,61,64,67,68,69,70,74,75],element_typ:[20,56,59],elementari:[18,22,24,25,32],elementwis:[20,38,59,68,73],eleph:52,eleven:52,elig:54,elimin:[5,21,29,36,45,46,56,57],elint:52,ell:52,ellips:[39,52],ellipsi:[30,52],elor:52,elroang:52,els:[1,3,5,6,14,17,23,24,25,29,30,36,38,39,40,41,44,45,46,49,51,53,64],elsdot:52,elseexpr:3,elseif:[1,3,24,30,46],elsewher:[25,56,57,64,68],eltyp:[20,21,35,46,56,59,67,69],elzand:52,elzbar:52,elzbtdl:52,elzcirfb:52,elzcirfl:52,elzcirfr:52,elzclomeg:52,elzddfnc:52,elzdefa:52,elzdlcorn:52,elzdshfnc:52,elzdyogh:52,elzesh:52,elzfhr:52,elzglst:52,elzhlmrk:52,elzinglst:52,elzinvv:52,elzinvw:52,elzlap:52,elzlmrk:52,elzlow:52,elzlpargt:52,elzltlmr:52,elzltln:52,elzminhat:52,elzopeno:52,elzor:52,elzp:52,elzpalh:52,elzpbgam:52,elzpgamma:52,elzpscrv:52,elzpupsil:52,elzrai:52,elzrarrx:52,elzreapo:52,elzreglst:52,elzrh:52,elzrl:52,elzrlarr:52,elzrtl:52,elzrtld:52,elzrtll:52,elzrtln:52,elzrtlr:52,elzrtlt:52,elzrtlz:52,elzrttrnr:52,elzrvbul:52,elzsbbrg:52,elzsblhr:52,elzsbrhr:52,elzschwa:52,elzsqfl:52,elzsqfnw:52,elzsqfr:52,elzsqfs:52,elzsqspn:52,elztdcol:52,elztesh:52,elztim:52,elztrna:52,elztrnh:52,elztrni:52,elztrnm:52,elztrnmlr:52,elztrnr:52,elztrnrl:52,elztrnsa:52,elztrnt:52,elzvert:52,elzverti:52,elzvrecto:52,elzxh:52,elzxl:52,elzxrat:52,elzyogh:52,email:[44,52],embed:[10,15,18,21],embed_exampl:28,emblem:52,emdash:52,emerg:[25,27],emiss:5,emit:[5,29,31,41],emit_cal:4,emit_expr:[4,5],emit_funct:[4,5],emit_intrins:6,emit_known_cal:5,emoji:52,emphas:[39,50,57,70],emploi:[3,16,67],empti:[9,16,20,27,29,34,39],emptyfunc:40,emptyset:52,emptysetoarr:52,emptysetoarrl:52,emptysetobar:52,emptysetocirc:52,emul:[48,70],enabl:[1,5,8,17,27,28,31,35,44,45,46,56,57,58,64,75],enable_broadcast:64,enc:47,encapsul:21,enclos:[1,39,41,43,52,54,57,64,70],enclosecircl:52,enclosediamond:52,enclosesquar:52,enclosetriangl:52,encod:[14,49,53,64,68,69,75],encompass:54,encount:[2,5,33,39,41,44,49,51],encourag:[43,44,48],end:[1,2,3,5,9,11,12,14,16,20,21,23,24,25,26,27,29,30,31,33,34,35,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,62,64,67,68,70,73,75,76],endash:52,endian:64,endian_bom:[60,64],endof:[35,49,50,59,75],endors:44,endpoint:68,endswith:75,enforc:[23,46,75],eng:52,engin:[33,44,52],english:[26,49,61],enhanc:[33,44,55],enorm:51,enough:[8,20,23,25,29,33,36,39,45,46,47,57],enqueu:59,enspac:52,ensur:[13,20,21,22,23,29,30,38,39,44,45,46,50,51,58,64,70,71],entail:33,enter:[1,2,16,27,30,31,33,34,40,42,47,49,53],entir:[1,5,14,16,17,20,23,24,27,29,39,42,44,45,47,49,51,64,67,73],entireti:64,entiti:16,entri:[14,16,20,24,34,38,43,44,51,52,56,59,62,67,68,70,71],entropi:69,entrypoint:71,enumer:[29,43,46,50,57,59],enumnam:57,enumvalue1:57,enumvalue2:57,env:[1,10,16,21,57,60,71],envelop:52,envelope_with_arrow:52,envhash:[57,59],eof:[42,64],eoferror:[24,57,76],eol:64,eparsl:52,ephemer:46,epoch:[57,61,65],epsilon:25,eq_float:46,eqc:16,eqcirc:52,eqcolon:52,eqdef:52,eqdot:52,eqeqeq:52,eqgtr:52,eqless:52,eqqgtr:52,eqqless:52,eqqplu:52,eqqsim:52,eqqslantgtr:52,eqqslantless:52,eqsim:52,eqslantgtr:52,eqslantless:52,equ:67,equal:[14,16,21,22,24,27,33,38,39,43,44,45],equalleftarrow:52,equalparallel:52,equat:[67,68],equiangular:52,equilbr:67,equilibr:67,equiv:52,equival:[10,13,16,20,21,23,24,27,29,30,31,33,34,38,39,40,42,43,44,45,46,49,51,52,54,56,57,58,59,60,62,64,67,68,69,70,71,74,75],equivdd:52,eqvparsl:52,era:26,erf:[20,38,68],erfc:[20,38,68],erfcinv:[20,38,68],erfcx:[20,38,68],erfi:[20,38,68],erfinv:[20,38,68],err:[21,44,48,57],err_retri:70,err_stop:70,errno:[21,57,58,65],erron:33,error:1,errorexcept:[4,24,48,57,76],esc:[9,21,27,39,57,64],escap:[39,48,49,64,75],escape_str:75,esh:52,esoter:5,especi:[2,20,21,23,25,30,38,44,45,46,50,51,54,68],essenti:[16,18,21,23,24,28,33,38,39,46,51],ession:39,establish:[28,42,44,45,70],estim:[52,57,67,68],eta:[20,38,52,68],etc:[2,4,13,20,26,29,38,41,42,43,45,48,49,51,58,61,65,68],etcetera:[23,68],eth:52,etre:56,etymolog:5,euclid:68,euclidean:[67,68],euler:[52,68,69],eulerconst:52,eulergamma:69,euro:52,europ:52,european:52,european_castl:52,european_post_offic:52,ev_in:67,eval_user_input:47,evalfil:57,evalpoli:68,evalu:[1,3,5,6,12,16,20,21],even:[4,10,14,16,21,22,23,24,25,27,29,30,33,36,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,56,57,59,64,67,68,69,75],event:21,eventu:[5,16,24,30],ever:[23,25,40,46,51],evergreen:52,evergreen_tre:52,everi:[4,20,21,23,25,26,28,29,30,33,35,36,38,39,41,42,43,45,46,49,51,56,57,59,64,70],everydai:24,everyth:[4,25,26,28,38,44,46,49,51,57,62,64],everywher:[25,29,45,47,55,70],evil:52,evolv:11,ex1:39,ex2:39,ex3:39,exact:[20,22,30,33,50,51,64,68,72],exactli:[4,16,21,28,30,33,39,40,43,49,51,56,57,58,59,64,68,69],examin:[3,4,5,16,27,39,42,46,47,48,72],exampl:[1,3,4,5,6,8,9,10,11,12,14,15,16,20,21,22,23,24,25,26,27],exce:36,exceed:[33,68],excel:[29,33,38,49],except:[1,15,16,20,21,22],excerpt:49,excess:48,exchang:52,exclam:[52,57],exclud:[44,49,57,67],exclus:[21,38,68],exec:[2,48],exec_program:6,execut:[2,3,4],exeflag:[45,70],exenam:[45,70],exhaust:[31,64],exhibit:[20,23,47],exist:[1,21,23,25,26,28,29,30,33,36,39,40,41,42,43],existingarrai:28,exit:[4,5,24,30,31,34,45,57,70],exit_cod:5,exitcod:70,exp10:68,exp2:[20,68],exp:[20,22,24,38,68],expand:[1,5,12,20,21,27,29,39,56,57,59,62,68,75],expandus:62,expat:44,expect:[2,9,20,21,22,23,24,25,26,27,29,36,39,41,42,44,46,47,49,50,51,57,64,69],expedit:44,expens:[20,35,45,47,56,68],experi:[24,31,33,55,68],experienc:2,expert:[36,44],explain:[23,25,44,49,50,51,54],explan:[24,72],explicit:[1,20,21,23,25,28,29,30,33,39,40,41,43,44,45,46,49,51,54,61,70,71],explicitli:[2,20,21,22,23,24,25,26,30,33,36,38,40,41,43,45,46,47,51,53,56,57,59,67,74],exploit:[20,64,68],explor:[39,51,55,67],expm1:[20,38,68],expm:[37,67],expon:[20,38,69,73],exponenti:[14,33,38,43,46,67,68,69],expos:[5,29,35,42],expr1:39,expr2:39,express:1,expressionless:52,ext:48,extact:67,extend:[5,25,27,28,29,30,35,36,41,45,56,67,68,73,75],extens:[23,33,35,36,40,41,44,49,66,74,76],extent:26,extern:[2,18,20,21,24,32,35,41,43,44,45],extra:[14,20,21,30,35,39,44,46,47,51,54,64,70,76],extra_repl_keymap:34,extract:[4,9,10,14,16,22,28,30,39,49,57,67,69],extraordinarili:39,extraterrestri:52,extrem:[25,39,44,46,47,49,53,57],extrema:[59,68],extyp:76,eyeglass:52,ezh:52,f77:21,f_improv:46,face:[52,67],facepunch:52,facil:36,facilit:[3,24,30,40,41,45,55,70],fact:[14,23,26,29,30,39,45,46,47,48,50,51,67,68],factor:[2,22],factori:[24,33,38,52,56,68],faddeeva:68,fail:[2,17,21,23,24,29,30,39,44,45,48,49,51,57,67,70,75,76],failur:[4,29,41,44,57,65,66,70,76],fairli:[14,23,24,27,45,57],faithfulli:25,fall:[23,25,40,51,52,68],fallback:[20,35,41,57,64,68],fallen:[51,52],fallen_leaf:52,fallingdotseq:52,fals:[1,4,12,15,16,20,21,22,23,24,25,26,29,33,38,39,40,41,43,45,46,47,49,51,53,54,56,57,59,61,62,64,67,68,69,70,72,74,75],falsifi:24,famili:[44,51,52],familiar:[26,39,42,43,44,49,50],fan:68,fancier:35,faq:[43,50],far:[4,29,30,39,40,43,46,47,51,57],farther:33,fashion:57,fast:[14,20,29,31,36,37,44,45,46,56,68,70,74],fast_forward:52,fastcal:21,faster:[5,17,27,29,39,44,46,50,51,56,59,67,68,74],fastest:[45,68],fastmath:[31,46],fatal:70,father:[33,52],favor:[33,43,67,73],favorit:44,fax:52,fdiagovnearrow:52,fdiagovrdiag:52,fdio:64,fear:52,featur:[1,3,5,14,23,24,27,31,33,34,36,37,39,40,41,46,49,51,54],feb:[26,61],februari:[26,61],feed:[45,48,75],feedback:44,feeder:45,feel:[42,44,51],feet:52,femal:52,feminin:52,femtolisp:[5,6,13,17],fenc:[27,52],ferr:67,ferri:52,ferris_wheel:52,fetch:[39,45,46,47,48,50,57,62,70,72],fetchfrom:70,few:[2,3],fewer:[1,23,29,40],ffast:46,ffi:5,fft:[27,43,68],fftshift:68,fftw:68,field:[1,4,5,10,12,13],fieldnam:[12,51,57],fieldoffset:[12,57],fieldptr:10,fieldtyp:57,fieldvalu:40,fifo:62,figur:[2,4,26,44],file1:[41,45],file2:[41,45],file:1,file_fold:52,file_nam:64,filefunclin:[47,72],filemod:62,filenam:[5,29,42,57,64,69,70,72],filepath:62,files:62,filesystem:[18,41],fill:[5,20,21,28,35,36,45,46,47,52,56,59,64,65,67,69],fill_two:46,filt:68,filter:[59,68],finally_block:1,find:[2,3,8,10,16,17,20,26,29,34,36,37,39,40,41,43,44,46,47,49,50,51,56,59,67,68],find_librari:66,findfirst:56,findin:59,findlast:56,findmax:59,findmin:59,findn:[20,56],findnext:56,findnz:[20,56],findprev:56,fine:[17,26,30,46],finer:[45,75],finish:[16,21,23,24,25,44,45,70],finit:[33,38,46,49,52,56,57,68,69],finv:52,fire:[16,52],fire_engin:52,firewal:44,firework:52,first:[1,2,3,4,5,8,9,11,14,16,20,21,23,24,25,26,27,28,29,30,31,34,35,36,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,56,57,58,59,61,62,64,66,67,68,69,70,71,72,74,75],first_index:14,first_quarter_moon:52,first_quarter_moon_with_fac:52,firstdayofmonth:61,firstdayofquart:61,firstdayofweek:[26,61],firstdayofyear:61,firstlast:51,fish:52,fish_cak:52,fishey:52,fishhook:52,fishing_pole_and_fish:52,fist:52,fit:[29,36,38,43,46,51,64],fitzpatrick:52,five:[24,48,52,64],fix:[8,26,29,33,40,41],fixbar:44,fixbar_backup:44,fl_invoke_julia_macro:5,fl_print:[4,13],flag:[1,14,17,28,29,34,41,42,49,52,62,64,65,66,68,70,75],flaot64:67,flashlight:52,flat:[47,52,72],flatten:46,flavour:27,fld:[10,38,46,68],fldmod:[38,68],flex:52,flexibl:[3,23,24,33,36,39,40,45,51,53,64,74],flip:[30,45,68],flipbit:56,flipdim:56,flipsign:[38,68],flisp:[4,5,13],float16:[12,33,40,51,69],float32:[4,12,16,21,25,33,40,43,46,51,56,57,58,67,69],float64:[4,12,14,16,20,21,23,24,25,28,29,30,33,35,40,43,45,46,50,51,56,57,58,59,61,64,67,68,69,70,72,74],floatrang:40,floor:[20,38,44,46,50,52,68],flop:67,floppi:52,floppy_disk:52,flow:[1,18],flower:52,flower_playing_card:52,fltn:52,flush:[5,42,48,52,64,65],flush_cstdio:65,flutter:52,fly:[42,56],fma:68,fmt:[28,34,46,64],fname:4,focu:[1,36,51],focus:[16,46],foggi:52,foist:29,fold:[52,75],folder:[2,15,28,44,45,52],foldl:59,foldr:59,follow:[1,2,3,5,10,12,13,16,17,20,21,22,23,24,25,26,27,28,29,30,31,33,34,37,38,39,40,41,42,43,44,45,46,47,49,50,51,53,54,55,56,57,58,61,64,67,68,69,70,73,75],follow_symlink:62,font:52,foo:[1,16,21,23,24,25,27,29,30,31,39,40,41,44,46,48,50,51,54,56,58,59,70],foo_data:41,foo_data_ptr:41,foo_init:41,foobar:[21,44],food:52,foomanag:[45,70],foot:5,footbal:52,footnot:45,footprint:52,fopen:[21,64],foral:52,forbid:51,forc:[1,4,15,26,28,29,43,44,45,46,47,48,50,52,54,57,64,65,72],foremost:14,forev:59,forget:44,forgot:44,forio:31,fork:[44,48,52],fork_and_knif:52,forksnot:52,forkv:52,formal:26,format:[13,14,20,21,25,26,27,33,34,44,47,56,61,64,65,67,68],format_str:26,formatmessag:65,former:[30,46,48,49],formerli:46,formula:[33,35,67],forth:[24,44],fortran90:21,fortran:[18,20],fortun:[11,14,36,45,49],forum:45,forward:[34,44,46,54,67,69],forwardord:59,found:[9,10,16,20,24,28,29,30,34,37,41,42,43,44,49,51,56,64,67,70,75],fountain:52,four:[12,25,27,34,46,49,51,52,56,74,75],four_leaf_clov:52,fourier:68,fourth:[14,25,40,47,52],fourthroot:52,fpart:68,fpic:[21,28],fptosi:46,fptr:4,fptrunc:4,fraction:[38,52,68],fragment:[5,39],fraktur:52,frame:[4,6,28,43],free:[21,27,28,29,33,36],freebsd:44,freed:[21,28,45,57,65,75],freeli:[44,51],french:[26,52],french_daysofweek:26,frequent:[6,18,24],fresh:[31,34,44,47],freshli:54,frexp:68,fri:[52,61],fric:52,fridai:[26,61],fried_shrimp:52,friendli:8,frobeniu:67,frog:52,from:[1,2,3],front:[1,46,51,52],frown:52,frozen:5,fruit:[43,57],fs_caveat:64,fuel:52,fuelpump:52,fuji:52,full:[2,5,12,13,17,20,22,26,33,34,39,43,44,45,47,49,51,52,56,57,60,61,62,67,70],full_moon:52,full_moon_with_fac:52,fulli:[5,21,23,24,29,34,41,46,49,51,54,57,59,74],fullnam:57,fun:21,func10:39,func:[16,21,28,30,39,46,57,61,64,70],funcnam:72,function_modul:57,function_nam:[28,57],function_point:58,functionloc:57,functionobject:4,functiontyp:21,functor:[11,23,40],fundament:[16,23,26,51],further:[10,12,17,24,28,29],furthermor:[30,43,45,50,68],fuss:26,fussi:24,fussy_sqrt:24,futur:[5,11,21,27,29,40,41,44,45,46,50,59,66,67,72],fwrite:13,gadfli:44,gain:[20,21,51],gambl:26,game:[26,52],game_di:52,gamma:[20,38,52,68],gamut:22,gap:[14,59],garbag:5,garden:52,gather:46,gauss:68,gaussian:20,gbmv:67,gbsn:53,gbtr:67,gbtrf:67,gc_enabl:57,gcc:[15,21,28,29],gcd:[23,38,68],gcdx:68,gdb:[0,2],gdblookup:4,gebak:67,gebal:67,gebrd:67,gecon:67,gee:67,geev:67,geevx:67,gehrd:67,gel:67,gelqf:67,gelsd:67,gelsi:67,gem:52,gemini:52,gemm:67,gemqrt:67,gemv:67,gener:[1,2,3],generalizedeigen:67,generalizedschur:67,generalizedsvd:[37,67],generic_funct:1,gensym:[1,21,39,57],geometr:52,geqlf:67,geqp3:67,geqq:52,geqqslant:52,geqrf:67,geqrt3:67,geqrt:67,geqslant:52,ger:67,gerqf:67,gescc:52,gesdd:67,gesdot:52,gesdoto:52,gesdotol:52,gesl:52,gestur:52,gesv:67,gesvd:67,gesvx:67,get:[2,3,4,5,8,9,10,16,18,20,21,23,24,26,28,29],get_bigfloat_precis:69,get_process_titl:57,get_round:[68,69],get_zero_subnorm:69,getaddrinfo:[42,64],getenv:21,getfield:[46,57],gethostnam:[21,57],getipaddr:57,getkei:59,getlasterror:65,getpid:57,getr:67,getrf:67,getri:67,getstdout:41,gflop:46,gge:67,ggev:67,ggg:52,gggnest:52,gglse:67,ggsvd:67,ghost:52,ghz:46,gibbou:52,gid:[57,62],gift:52,gift_heart:52,gigabyt:29,gimel:52,girl:52,gist:2,git:[44,71],github:[2,44,67],gitignor:44,give:[12,15,20,21,22,23,26],given:[1,5,9,12,14,15,20,21,23,24,25,26,27,29,30,31,33,34,39,40,41,42,44,45,47,49,51,56,57,59,61,62,64,65,67,68,69,70,71,72,74,75,76],gla:52,glass:52,gle:52,glj:52,glm:43,global:[1,6,10,20],globalref:[1,46],globe:52,globe_with_meridian:52,gloss:49,glottal:52,glow:52,glue:21,glyph:52,gmp:[33,40],gmt:61,gnapprox:52,gneq:52,gneqq:52,gnsim:52,gnu:[2,28,33,66,69],goal:43,goat:52,goblin:52,goe:[1,2,24,44,48,49,56,57],goertzel:68,goldberg:33,golden:69,golf:52,good:[4,16,23,26,27,36,41,44,45,46,47,49,52,55],goodby:[49,75],googl:42,got:[29,51,57],gotcha:[21,51],gotoifnot:1,gotonod:1,gperm:62,gracefulli:[5,29,49],gradient:56,gradual:51,graduat:52,grant:46,grape:52,graph:51,graphem:75,graphic:[47,64],grave:52,great:[34,38,39,42,51],greater:[21,23,24,25,26,33,38,44,49,52,53,57,59,67,68,74,75],greatest:[21,23,38,44,51,68],greatli:[2,46],greedi:57,greedili:57,greek:[49,52],green:[36,52],green_appl:52,green_book:52,green_heart:52,greet:[31,34,49],gregorian:[26,61],grep:[48,57],grew:57,grey_exclam:52,grey_quest:52,grid:20,grimac:52,grin:52,group:[8,21,26,49,57,59,62,64,75],groupnam:49,grow:[14,33,43,47,52,57,64],grown:64,growth:67,gsime:52,gsiml:52,gtcc:52,gtcir:52,gtquest:52,gtrapprox:52,gtrdot:52,gtreqless:52,gtreqqless:52,gtrless:52,gtrsim:52,gtsv:67,gttr:67,gttrf:67,gua:52,guarante:[14,20,21,23,24,50,51,57,58,59],guard:29,guardsman:52,guess:26,guid:[2,18],guidanc:44,guidelin:29,guillemet:52,guilsinglleft:52,guilsinglright:52,guitar:52,gun:52,gvertneqq:52,h05:67,habit:44,hacek:52,hack:13,had:[41,42,44,46,47,70],hadamard:43,hair:52,haircut:52,half:[20,29,33,52,67,68,74],halfcomplex:68,halo:52,halv:68,hamburg:52,hammarl:67,hammer:52,hamster:52,hand:[5,8,23,24,25,26,29,33,35,36,38,39,43,44,51,52,54,67],handbag:52,handi:[9,20,24,30,39,49],handl:[4,5,6,8,13,14,16],handler:[1,6,13,24,31,58],handoff:5,hankei:52,hankel:[38,68],hankelh1:[20,38,68],hankelh1x:[38,68],hankelh2:[20,38,68],hankelh2x:[38,68],happen:[14,16,24,25,27,28,29,30,39,42,45,46,47,48,49,50,51,56,57,67,70,76],happi:[44,52],har:45,hard:[3,29,39,44,53],harder:[46,50],hardest:5,hardli:25,hardwar:[33,45,46,69],harm:[21,22],harpoon:52,hartlei:68,hash:[16,38,41,43,44,57,59],haskei:[50,59],haskel:51,hasn:44,hasplain:23,hassl:44,hat:[34,52,53],hatapprox:52,hatch:52,hatched_chick:52,hatching_chick:52,have:[1,2,3,9,10,11,12,14,16,20,21,22,23,24,25,26,27,28,29,30,31,33,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,54,55,56,57,59,61,64,65,67,68,69,70,71,72,75],haven:[41,44,46],haystack:75,hbar:[34,52],hc2r:68,hcat:[1,20,30,43,56],hdf5:64,head:[1,39,52],headach:38,header:[2,10,21,28,64],header_cel:64,headphon:52,heap:[28,29,41,58],heapifi:59,heappop:59,heappush:59,hear:52,hear_no_evil:52,heart:[16,52],heart_decor:52,heart_ey:52,heart_eyes_cat:52,heartbeat:52,heartpuls:52,heartsuit:[34,52],heatflow:46,heavi:[13,16,23,42,52],heavili:[14,16],heavy_check_mark:52,heavy_division_sign:52,heavy_dollar_sign:52,heavy_minus_sign:52,heavy_multiplication_x:52,heavy_plus_sign:52,hebrew:49,heel:52,held:[23,34,45],helicopt:52,hello:[6,13,34,39,42,46,48,49,51,53,75],help:[2,4,14,16,17,21,26,27,29,30,31],helper:[5,21],henc:[14,16,24,26,41,45,47,51,56,57,58,67,68],her:67,herb:52,here:[2,3,4,8,9,10,11,14,16,20,21,23,24,25,27,28,29,30,33,34,38,39,40,41,42,44,45,46,47,48,49,50,51,54,55,57,59,68,73,74],herk:67,hermaphrodit:52,hermitconjmatrix:[34,52],hermitian:[37,52,67],hessenberg:[37,67],hessenbergq:67,hessfact:67,hesv:67,heterogen:[20,56],hetr:67,hetrf:67,hetri:67,heurist:5,hex2byt:69,hex2num:69,hex:[33,43,69],hexadecim:[33,43,49,69,75],hexagon:52,hexagonblack:52,hibiscu:52,hidden:[39,41,57],hide:21,hierarch:51,hierarchi:[25,41,51],hierarchicalvalu:40,high:[21,24],high_bright:52,high_heel:52,higham:67,higher:[2,4,14,20,24,26,39,45,50,56,57,67,68,69],highest:[14,36,38,48,57,59],highli:[10,36,44,46,51,68],highlight:[12,33],hindi:49,hint:[1,9,39,46,64],hist2d:68,hist:[34,68],histogram:68,histori:[31,33,34,44],history_next:34,history_prev:34,histrang:68,hit:[2,31,34,44,52],hksearow:[34,52],hkswarow:[34,52],hocho:52,hoist:[5,46],hold:[16,21,23,25,28,35],hole:[46,52],holidai:26,home:[2,31,34,44,45,55,62,70],homebrew:44,homedir:[62,71],homer:31,homothet:52,honei:52,honest:26,honey_pot:52,honeybe:52,hood:16,hook:[6,37,52,57],hookleftarrow:[34,52],hookrightarrow:[34,52],hoop:52,hope:[3,27],hopefulli:[5,14,39],horizont:[43,52,56,73,75],horn:52,horner:68,horribl:1,hors:52,horse_rac:52,hospit:52,host:[28,31,42,44,45,57,64,70],hostnam:[21,45],hot:[35,52],hotel:52,hotspr:52,hour:[17,26,49,61,65],hourglass:52,hourglass_flowing_sand:52,hous:52,house_with_garden:52,household:67,how:[4,5,6,16,20,21,23,24,25,26,27,28],howev:[1,2,3,4,6,10,13,14,16,20,21,22,23,24,25,26,27,28,29,30,33,35,36,38,39,40,41,42,44,45,46,47,48,49,51,53,54,56,57,58,59,64,65,67,69],howmni:67,hrectangl:52,hrectangleblack:52,hslash:[34,52],hspace:[34,52],html:[44,64,67,75],html_str:75,htol:64,hton:64,http:[29,31,34,44,45,64,67,68],hub:44,human:[1,26,39,61],hundr:52,hurwitz:68,hush:52,hvcat:[20,30,43,56],hvcat_fil:46,hybrid:29,hyndman:68,hyperlink:44,hyphen:[52,75],hypot:[20,30,38,68],hypotenus:[30,38],i64:12,i686:4,i_1:[3,20],i_2:[3,20],i_3:3,i_d:3,i_j:3,i_k:20,i_n:20,iblock:67,iblock_in:67,ice_cream:52,icecream:52,iceil:76,icon:44,idct:68,idea:[5,23,30,44,46,47,51,55],ideal:[29,33,50],ident:[16,20,21,22,23,30,37,38,39,45,46,48,49,51,52,54,56,57,59,64,67,69,70,75],identifi:[1,10,21,22,30,33,35,39,40,41,43,44,45,46,47,49,51,53,70],ideograph:52,ideograph_advantag:52,idiom:[24,49],idiomat:[28,30,40,50],idl:70,idx:[45,46,75],ieee:[31,33,38,46,67,68,69],if_fals:73,if_tru:73,ifels:[46,57],iff:[57,59],ifft:68,ifftshift:68,iftru:58,ignor:[21,31,34,39,44,49,56,57,64,66,68,75],ignore_invalid_char:64,ignorestatu:57,ihi:67,iid:[20,68],iii:68,iiiint:52,iiint:52,iint:52,ijulia:[27,31,55,64],ill:67,illus:30,illustr:[24,27,39,41,46,47],ilo:67,image_fil:[5,6],imagin:[26,39,44,45,46],imaginari:[22,23,38,43,67,68,69],imath:52,immedi:[21,23,24,29,30,31,33,38,39,40,41,44,45,48,49,51,57,65,70],immut:[5,11,21,23,26,27],imp:52,impact:46,imper:[21,24,30,36,44],implement:[1,5,9,10,14,16],impli:[5,16,23,25,31,33,38,40,44,46,51,57,67],implic:51,implicit:[23,24,45],implicitli:[40,41,51,57],impos:[16,36,51,53],imposs:[28,29,39,46,51],imprecis:76,imul:29,inabl:29,inadequ:11,inadvert:51,inappropri:51,inbound:[46,58],inbox:52,inbox_trai:52,inbuilt:45,inc:29,incant:2,incept:36,inci:[21,67],includ:[1,2,3,4,5,12,14,15,16,17,20,21,24,25,26,27,28,29,30,31,33,35,36,38,39,41,43,44,45,46,47,49,51,52,53,55,56,57,58,61,62,64,67,68,70,74,75,76],include_depend:[41,57],include_str:57,inclus:[8,26,59],incom:[42,45,52,70],incoming_envelop:52,inconsist:[21,52,57],inconveni:[25,29],incorpor:44,incorrect:[39,44,57,58,67],increas:[20,26,47,51,52,56,64,67,68],increment:[26,29,31,34,41,44,52,59,61],incur:[33,39,46,47],incx:[21,67],ind2chr:[49,75],ind2sub:[14,56],ind:[39,56],inde:[14,16,29,46,59,74],indefinit:67,indent:[27,39,41,43,47,49],independ:[20,21,39,45,47,51,56,57,70,72,74],indetermin:21,index1:40,index2:40,index:3,indexexpr:3,indexin:[50,59],indexpid:[45,70],indic:[1,2,14,16,20,21,23,24,25,26,28,33,34,35,38,39,40,42,43,44,46,47,49,50,51,52,53,56,57,58,59,61,64,67,68,73,74,75,76],indirectli:20,indistinguish:[40,74],individu:[27,29,30,41,44,46,47,51,59,67,75],indmax:[56,59],indmin:59,induc:67,indxin:50,ineffici:[20,49,54],inequ:38,inertia:67,inevit:[25,48],inexact:[38,68],inexacterror:[23,24,25,38,51,57,68],inf16:[33,69],inf32:[33,69],inf:[22,33,38,46,67,68,69],infer:[1,4],infin:[33,38,52,67,68,69],infinit:[14,22,38,57,68,69],infix:[24,25,30,53,57],influenc:45,inform:[1,2,5,8,9,10,14,16,21,23],information_desk_person:52,information_sourc:52,infrastructur:[9,13,44,45],infrequ:47,infti:52,ing:[35,57],inher:50,inherit:[13,20,35,51,54,69],init:[6,13,44,45,46,47,59,70,71,72],init_stdio:13,init_work:[45,70],initerror:[24,57],initfn:[45,70],initi:[4,5],initialis:6,initializaton:45,inject:46,ink:[52,75],inlin:[1,5,9,16,21,27,29,31,46,47,50,57,68],inner:1,innermost:[20,46],innersimd:46,innoc:[26,46,52],innocu:[23,39],inod:[57,62],inplaceop:43,input:[1,11,14,16,18,20],inputindex:14,insan:39,insensit:[49,75],insert:1,insertionsort:74,insid:[1,2,5,9,16,21,23,24,25],insist:45,instabl:[29,46,57],instal:[28,31,41],instanc:[10,16,17,20,21,23,24,25,28,35,37,39,40,41,43,45,46,48],instant:[26,40,61],instanti:[14,16,21,51,73],instead:[1,5,9,10,12,14,16,20,21,22,23,24,25,26,27,29,30,31,33,35,38,39,41,42,43,44,45,46,48,49,50,51,53,54,55,56,57,59,61,62,64,66,67,68,69,70,74,75],insteadof:44,instrm:70,instruct:[2,5,6,9,15,21,29,31,36,44,46,47,51,57,72],instrument:47,insuffici:[17,69],int128:[29,33,34,40,43,51,69],int128_str:1,int16:[21,33,34,40,51,58,69,75],int32:[6,20,21,23,25,33,34,40,43,46,49,50,51,57,58,59,69,75],int32_t:28,int64:[12,14,16,20,21,22,23,24,25,26,29,30,33,34,35,39,40,43,45,46,49,51,56,57,58,59,61,68,69,74],int8:[16,20,21,25,33,34,38,40,51,69],intbar:52,intcap:52,intcup:52,integ:[1,3,6,13,14,16,18,20,21,22,23,25,26,28],integr:[22,23,28,48,51,52],integrand:68,intel:[2,46],intellig:[27,44,49],intend:[3,20,21,38,41,44,45,47,53,57,58,59,67],intens:[8,31,36],intent:[41,44,54,57],intention:[21,39],inter:20,interact:[4,5,10,16,18,21,22,24,28,30,31,32,33],interc:52,intercal:52,interchang:[43,51],interconvert:20,interest:[8,12,16,21,23,29,33,39,44,48],interfac:5,interior:[14,52],interleav:52,intermedi:[12,46,56,59,68],intern:[1,4],internet:44,interoper:[25,29,33],interpol:[12,14,27,33],interpret:[4,5,6,8,14,24,25,27,30,33,36,38,39,41,44,46,47,48,49,56,57,61,64,70,71],interrobang:52,interrog:12,interrupt:[24,34,45,57,58,70],interruptexcept:[24,57],intersect:[16,40,52,57,59],intersect_tupl:16,interv:[20,37,44,47,57,65,67,68,69,71],interval_:64,interven:48,interview:33,intfunc:29,intmax_t:[21,58],intorstr:51,intprod:52,intprodr:52,intrins:[5,6,8,35,56,57],introduc:[23,24,29,33,34,39,40,41,45,47,48,49,50,51,54],introductori:[31,47],intset:59,intuit:[8,51,54],intx:52,inv:[37,57,67,68],invalid:[5,21,22,23,28,29,41,45,46,49,58,64],invalidstateexcept:24,invalu:39,invari:[16,23,51,67],invdigamma:68,invers:[20,38,52,56,59,67,68,71],inversewhitecircl:52,invert:[52,67],investig:17,invis:[25,75],invmod:68,invnot:52,invok:[4,5,16,23,24,25,28,30,39,40,41,43,47,48,51,57,64,73,74],involv:[5,8,14,25,29,41,42,45,50,51,54,55,57],invperm:56,invwhitelowerhalfcircl:52,invwhiteupperhalfcircl:52,iobuff:[45,64,75],ios_init_stdstream:6,ios_stdout:4,ios_t:13,ios_writ:13,iostream:[13,34,42,64],iota:52,ipart:68,ipermut:56,ipermutedim:56,iphon:52,ipiv:67,ipv4:[42,64],ipv6:[42,64],ipython:64,irang:[45,67],irfft:68,irrat:40,irregular:26,irrelev:[39,54],is_assigned_char:75,isa:[14,24,38,39,46,50,51,57],isabspath:62,isalnum:75,isalpha:75,isapprox:[68,76],isascii:75,isbit:[10,12,21,41,51,57],isblockdev:62,ischardev:62,iscntrl:75,isconst:57,isdefin:[29,57],isdiag:67,isdigit:75,isdir:62,isdirpath:62,isdst:65,iseltyp:56,isempti:[39,59],isequ:[22,38,50,57,59],iseven:[30,46,54,69],isexecut:62,isfifo:62,isfil:[55,62],isfinit:[20,38,69],isgener:57,isgn:67,isgraph:75,isheap:59,ishermitian:67,isimmut:57,isin:52,isindot:52,isinf:[20,25,38,69],isinobar:52,isinteg:69,isinteract:[31,55,57],isinvb:52,isleaftyp:57,isleapyear:[26,61],isless:[57,68,74],islink:62,islow:75,ism:[49,75],ismark:64,ismatch:[49,75],ismount:62,isn:[14,16,21,25,29,44,48,51,57],isnan:[20,25,38,57,69],isnul:[51,57],isnumb:75,iso:26,isodd:[54,69],isol:[3,8,43,46],isopen:[42,57,64],ispath:62,isperm:56,isplit:67,isplit_in:67,isposdef:67,ispow2:[29,68],isprecompil:57,isprim:69,isprint:75,isprocess:51,ispunct:75,isqrt:68,isread:62,isreadi:[45,70],isreadonli:64,isreal:69,issetgid:62,issetuid:62,issocket:62,issort:74,isspac:[64,75],isspars:[20,56],isstag:16,issticki:62,issu:[2,14,17,21,26,29,33,39,41,43,44,45,46,49,50,51,52,55,67],issubnorm:69,issubset:59,issubtyp:[50,57],issue8859:67,issym:67,istaskdon:[24,70],istaskstart:[24,70],istext:64,istream:64,istril:67,istriu:67,istuesdai:26,isupp:[67,75],isvalid:[49,75],iswrit:62,isxdigit:75,ital:52,item:[16,27,35,43,45,57,59,64,68,70],iter1:1,iter2:1,iter:[1,3,6],iteratorsmd:[20,40],itersym:3,itertyp:35,ith:58,itr:59,itself:[1,5,12,14,15,16,20,21,23,25,27,29,33,35,36,38,39,40,41],ityp:67,izakaya:52,izakaya_lantern:52,j_1:3,j_2:3,j_d:3,jack:52,jack_o_lantern:52,jan:[26,61],januari:[26,61],japan:52,japanes:[49,52],japanese_castl:52,japanese_goblin:52,japanese_ogr:52,jargon:44,java:[24,25,26,29,40,43,49,51,68],javascript:[26,68],jean:52,jeudi:26,jiahao:27,jl_:[4,16,28],jl_add_standard_import:6,jl_alloc_array_1d:[10,28],jl_alloc_array_2d:[10,28],jl_alloc_array_3d:10,jl_alloc_cell_1d:10,jl_alloc_tupl:10,jl_any_typ:6,jl_appli:[4,6],jl_apply_array_typ:[10,28],jl_apply_gener:[4,6],jl_apply_typ:10,jl_args_morespecif:16,jl_array_data:28,jl_array_dim:28,jl_array_len:28,jl_array_ndim:28,jl_array_t:[10,28],jl_atexit_hook:5,jl_base_modul:[6,28],jl_bottom_typ:16,jl_box_:28,jl_box_float32:28,jl_box_float64:28,jl_box_int32:28,jl_box_uint16:10,jl_box_uint8:6,jl_breakpoint:[4,16],jl_call0:28,jl_call1:28,jl_call2:28,jl_call3:28,jl_call:28,jl_compil:4,jl_compile_al:6,jl_core_modul:6,jl_current_task:6,jl_datatype_t:[6,10],jl_dump_llvm_valu:4,jl_egal:10,jl_error:[4,28],jl_errorf:28,jl_eval_str:[4,28],jl_exception_in_transit:1,jl_exception_occur:28,jl_expand:5,jl_f_appli:6,jl_f_i:6,jl_f_top_ev:6,jl_filenam:4,jl_float64_typ:28,jl_fptr_t:10,jl_function_t:[4,10,28],jl_gc_allocobj:10,jl_gc_collect:28,jl_gc_enabl:28,jl_gc_init:6,jl_gc_is_en:28,jl_gc_pop:28,jl_gc_push1:28,jl_gc_push2:28,jl_gc_push3:28,jl_gc_push4:28,jl_gc_push:28,jl_gc_pusharg:28,jl_gc_run_all_fin:[5,6],jl_gc_wb:[10,28],jl_get_builtin_hook:6,jl_get_field:10,jl_get_funct:28,jl_get_glob:6,jl_get_nth_field_check:10,jl_init:28,jl_init_box_cach:6,jl_init_codegen:[5,6],jl_init_frontend:6,jl_init_intrinsic_funct:6,jl_init_primit:6,jl_init_restored_modul:6,jl_init_seri:6,jl_init_task:6,jl_init_typ:[6,10],jl_int32_typ:6,jl_interpret_toplevel_expr:6,jl_interrupt_except:6,jl_intrinsic_typ:6,jl_is_:28,jl_is_float64:28,jl_is_mut:10,jl_lambda_info_t:[4,5,10],jl_lamdbda_info_t:4,jl_lineno:4,jl_load:[4,5,6],jl_macroexpand:5,jl_main_modul:6,jl_module_run_initi:6,jl_new_abstracttyp:6,jl_new_arrai:10,jl_new_arrayv:10,jl_new_bit:10,jl_new_bitstyp:6,jl_new_closur:[6,10],jl_new_generic_funct:10,jl_new_lambda_info:10,jl_new_main_modul:6,jl_new_modul:6,jl_new_struct:10,jl_new_structv:10,jl_new_uniontyp:10,jl_null:6,jl_option:[4,5,6,28],jl_parse_eval_al:6,jl_parse_input_lin:6,jl_parse_next:6,jl_printf:13,jl_ptr_to_array_1d:28,jl_pvalue_t:10,jl_resolve_sysimg_loc:6,jl_restore_system_imag:[5,6],jl_root_task:6,jl_safe_printf:13,jl_save_system_imag:[5,6],jl_set_const:6,jl_set_typeof:10,jl_share:28,jl_static_show:13,jl_stderr:13,jl_stdin:13,jl_stdout:[6,13],jl_subtype_l:16,jl_svec_t:16,jl_sym_t:10,jl_symbol:[6,10],jl_task_typ:6,jl_throw:[4,6],jl_too_few_arg:4,jl_too_many_arg:4,jl_toplevel_ev:6,jl_toplevel_eval_flex:[5,6],jl_toplevel_eval_in:6,jl_trampolin:6,jl_tupl:10,jl_tuple_t:10,jl_tupletype_t:4,jl_tuplev:10,jl_type_error:28,jl_type_intersect:16,jl_type_morespecif:16,jl_type_typ:6,jl_typeof:[4,10],jl_typeof_str:28,jl_typetag_t:10,jl_unbox_float64:28,jl_uncompress_ast:4,jl_uniontype_t:10,jl_uv:[6,13],jl_uv_handle_typ:13,jl_uv_stderr:4,jl_uv_writ:[6,13],jl_value_t:[4,6],jl_vprintf:13,jl_write:13,jlbacktrac:4,jlcall_print_284639:6,jle:29,jlfrontend:5,jltype:10,jmath:52,job:[6,24,45,46,47,67],jobq:67,jobsvl:67,jobu:67,jobv:67,jobvl:67,jobvr:67,jobvsl:67,jobvsr:67,jobvt:67,jobz:67,john:[33,38],joi:[26,52],join:[49,52,62,75],joiner:52,joinpath:[15,28,62,71],jointli:45,joker:52,journal:67,joy_cat:52,jpvt:67,jrang:45,judgment:46,judici:[39,57],jul:61,juli:61,julia_:12,julia_convert_16886:4,julia_dir:28,julia_hom:[15,28,60,70],julia_init:5,julia_init_dir:28,julia_llvm_arg:8,julia_load_path:41,julia_pkgdir:71,julia_print_284639:6,julia_root:2,julia_worker_timeout:70,julia_write_282942:6,julialang:[29,31,34,44,67],julialibm:68,julian2datetim:61,julian_dai:61,juliapars:44,juliarc:[31,34,41,45,55,57,70],juliastat:[43,44],jump:[1,42,46,69],jumppoli:69,jun:61,june:61,juno:27,jupit:52,just:[1,3,5,6,8,10,11,14,16,17,20,21,22,23,24,25,26,27,28,29,30,31,33,34,35,36,38,39,40,42,43,44,45,46,47,48,49],juxtapos:[22,33],juxtaposit:33,k_1:68,k_2:68,kahan:[33,56],kappa:52,karpinski:44,katakana:52,kaufman:67,keep:[16,17,21,24,28,35,41,44,45,46,55,57,70,75],kei:[14,16,24,30,31],kept:[10,36,71,75],kernel:[24,45],kernelcontract:52,keyboard:52,keycap:52,keycap_ten:52,keyerror:[24,57],keymap:34,keytyp:59,keyword:[1,20,21,24,26],keyword_arg:70,kib:44,kick:46,kill:[34,45,57,70],kimono:52,kind:[4,14,17,23,24,25,26,29,38,39,40,42,46,49,51,54,56,57,68,76],kindli:44,kiss:52,kissing_cat:52,kissing_closed_ey:52,kissing_heart:52,kissing_smiling_ey:52,kiwi:57,knew:45,knife:52,know:[2,5,21,24,25,26,28,29,30,33,35,39,41,44,45,46,48,49,50,64],knowledg:[16,46],known:[5,10,16,21,22,23,24,26,27,30,31,33,35,39,40,41,44,46,47,50,51,52,56,67,68],knuth:[68,69],koala:52,koko:52,konstantinid:67,konstantino:67,koppa:52,korean:49,kron:[53,67],kroneck:[53,67],kronrod:68,krylov:67,kth:56,kung:67,kwarg:[30,70,72],kwsorter:1,ky88:67,label:[1,30,46],labelnod:1,labor:8,lack:[29,36,39,43,50,70],ladi:52,laid:[14,20],lambda:[1,4,12,52,67],lamda:52,lanczo:67,land:44,langl:52,languag:[5,18,20,21,24,25,26,28,29,30,32,36,38,39,40,41],lantern:52,lapack:[2,20,37],lappli:43,laptop:[45,47],larg:[10,20,25,28,29,30,35,36,38,39,41,43,44,45,46,51,52,56,57,59,64,67,68],large_blue_circl:52,large_blue_diamond:52,large_orange_diamond:52,larger:[20,23,25,28,33,43,44,49,52,57,59,67,68],largest:[20,25,29,33,56,57,59,67,68],last:[1,3,4,8,14,16,20,24,25,26,28,30,31,33,34,35,38,39,42,43,44,45,49,50,51,52,54,56,57,59,61,62,64,67,68,70,74,75],last_quarter_moon:52,last_quarter_moon_with_fac:52,lastdayofmonth:[26,61],lastdayofquart:[26,61],lastdayofweek:61,lastdayofyear:61,lastmain:57,lat:52,late:52,latenc:[46,48],later:[6,14,20,23,24,26,30,40,44,45,46,50,51,53,57,58,70],latest:[8,29,44,45],latex:[3,27,34,53],lather:55,latin:[52,75],latter:[16,25,43,44,46,48,49,54],laugh:52,launch:[24,31,45,47,70],launch_ntfi:70,law:[36,40],layer:[5,21,45],layout:[1,7],lazi:[23,43,52],lazili:43,lazysinv:52,lbeta:[20,38,68],lceil:52,lcfirst:75,lcm:[38,68],ldexp:[38,68],ldflag:28,ldlib:28,ldlt:67,ldltfact:67,ldsh:52,lea:29,lead:[20,26,29,41,43,44,46,54,67,69,75],leading_on:69,leading_zero:69,leaf:[10,21,46,52,57],leak:17,leaki:24,leap:[26,61],learn:[5,16,27,29,31,46],least:[14,16,20,33,38,42,44,46,47,49,57,59,64,67,68,69,75],leav:[1,23,24,29,39,44,50,52,74],led:47,ledger:52,left:[1,3,20,24,29,30,33,34,38,39,43,44,49,51,52,54,56,57,59,67,68,70,75,76],left_luggag:52,left_right_arrow:52,left_sv:67,leftarrow:52,leftarrowapprox:52,leftarrowbackapprox:52,leftarrowbsimilar:52,leftarrowonoplu:52,leftarrowplu:52,leftarrowtail:52,leftarrowtriangl:52,leftarrowx:52,leftbkarrow:52,leftcurvedarrow:52,leftdasharrow:52,leftdbkarrow:52,leftdotarrow:52,leftdownteevector:52,leftdownvectorbar:52,leftharpoonacc:52,leftharpoondown:52,leftharpoonsupdown:52,leftharpoonup:52,leftharpoonupdash:52,leftleftarrow:52,leftrightarrow:52,leftrightarrowcircl:52,leftrightarrowtriangl:52,leftrightharpoon:52,leftrightharpoondownup:52,leftrightharpoonsdown:52,leftrightharpoonsup:52,leftrightharpoonupdown:52,leftrightsquigarrow:52,leftrightvector:52,leftsquigarrow:52,leftteevector:52,leftthreearrow:52,leftthreetim:52,lefttrianglebar:52,leftupdownvector:52,leftupteevector:52,leftupvectorbar:52,leftvectorbar:52,leftward:52,leftwards_arrow_with_hook:52,leftwhitearrow:52,leg:52,legaci:6,legal:51,legend:37,lemon:52,len:[6,65,75],length:[10,11,14,16,20,21,26,28,30,35,38,39,43,45,46,49,56,57,59,64,67,68,69,70,74,75],leo:52,leopard:52,leqq:52,leqqslant:52,leqslant:52,lescc:52,lesdot:52,lesdoto:52,lesdotor:52,lesg:52,less:[1,14,16,20,21,23,24,26,29,33,38,39,40,43,44,45,47,48,49,50,51,52,57,68,70,74,75],lessapprox:52,lessdot:52,lesseqgtr:52,lesseqqgtr:52,lessgtr:52,lesssim:52,let:[1,3,4,5,11,16,21,23,24,26,27,28,35,39,41,42,43,44,45,47,48,49,51,53],letter:[48,49,52,53,62,75],level:[5,8,10,12,14,20,21,24,27],leverag:[23,45],lexcmp:57,lexic:54,lexicograph:[49,56,57,69,74],lexless:57,lfact:[20,38,68],lfloor:52,lgamma:[20,38,68],lgblkcircl:52,lgblksquar:52,lge:52,lgwhtcircl:52,lgwhtsquar:52,lib:[4,15,21,28,41,49,57],libc:[21,48,65,66],liber:29,liberti:52,libfil:66,libfoo:[21,41],libjulia:[15,28],liblapack:21,libllvm:[2,5],libm:[2,46],libopenbla:2,libopenlibm:2,libra:52,librari:[5,6],libstdc:28,libsupport_init:6,libuv:[5,6],licens:[36,44,46,71],lidict:72,lie:16,lieu:[6,43,67],life:39,lifetim:[45,70],lifo:57,lift:23,ligatur:[52,75],light:52,light_rail:52,lightweight:[4,24,36,44],like:[1,2,3,4,8,9,11,13,14,16,17,20,21,23,24,25,26,27,28,29,30,35,36,38,39],likewis:[12,14,16,24,29,49,51],limit:[5,21,25,26,31,36,39,44,45,47,49,52,61,64,67,72,75],linalg:[40,67],lindahua:44,line:[1,4,5,6,8,12,13,14,15,16,17,21,23,24,25,26],lineag:36,linearcach:16,linearfast:[20,35,56],linearindex:[20,35,56],linearli:[20,56],linearslow:[20,35,56],linecom:64,lineedit:34,linefe:[52,75],lineinfo:72,linenumbernod:1,liner:[24,48],linerang:72,linfo:[4,72],lingo:51,link:[2,8,21,27,28,29,44,52,62,64],linker:63,linreg:67,linspac:[20,43,45,56],lint:46,linux:[2,6,21,28,44,57,60],lip:52,lipstick:52,lisp:[5,30,36,39],list:[1,4,6,8,10,12,16,20,21,24,27,30,31,34,38,41,43,44,45,46,47,51,54,56,57,59,61,66,67,68,70,72,75,76],listen:[42,45,64],listenani:64,liter:[14,21,22,24,25,27],literatur:67,litter:52,littl:[16,26,29,36,40,44,45,46,47,50,51,64],live:[15,29,45,64],ljulia:28,llarc:52,llblacktriangl:52,llbracket:52,llcorner:52,lldb:4,lleftarrow:52,lllnest:52,lltriangl:52,llvm:[2,5,6,7],llvm_assert:8,llvm_debug:8,llvm_ver:8,llvmcall:[5,58],lmoustach:52,lnapprox:52,lneq:52,lneqq:52,lnsim:52,load:2,load_cache_path:[41,57],load_path:[41,57,60],loader:66,loaderror:[24,57],loan:67,local:[1,6,21,23,24,26,28,29,31,39,41,44,45,46,49,51],localdatetim:26,localfil:62,localhost:[42,64],localindex:[45,70],localmanag:[45,70],locat:[20,28,29,30,31,44],lock:[29,45,52,70],lock_with_ink_pen:52,locomot:52,log10:[20,38,68],log1p:[20,38,68],log2:[20,38,68],log:20,logabsdet:67,logarithm:[38,56,67,68],logdet:[37,67],logic:[21,25,38,43,44,45,52,67,69,70],login:[31,45],logm:67,logspac:56,lollipop:52,long_comput:70,longer:[24,28,29,39,44,47,49,55,58,70,71],longest:49,longleftarrow:52,longleftrightarrow:52,longleftsquigarrow:52,longmapsfrom:52,longmapsto:52,longrightarrow:52,longrightsquigarrow:52,look:[4,6,8,14,16,20,21,28,29,30,35,39,41,44,45,46,47,49,51,52,57,59,60,66,70],lookup:[4,21,41,46,64,66],loop:[1,3,5,8,16,21],looparrowleft:52,looparrowright:52,loopback:64,loopinc:46,loopinc_prealloc:46,lorri:52,lose:[44,65],loss:[23,26,51,57],lossless:23,losslessli:[57,61],lot:[14,16,20,29,35,65],loud_sound:52,loudli:52,loudspeak:52,love:52,love_hotel:52,love_lett:52,low:[5,10,14,27,33,45,52,70],low_bright:52,lowercas:[21,26,49,50,75],lowertriangular:[37,40,67],lowest:[10,22,23,33,38,57,59],lowint:52,lozeng:52,lpad:[33,75],lrarc:52,lrblacktriangl:52,lrcorner:52,lrtriangl:52,lrtriangleeq:52,lsh:52,lsime:52,lsimg:52,lsqhook:52,lst:[45,70],lstat:62,lstrip:75,lt_float:46,ltcc:52,ltcir:52,ltime:52,ltoh:64,ltp:67,ltquest:52,lua:36,lucid:33,lufact:67,luggag:52,lump:47,lunat:52,lundi:26,lutridiagon:37,luu:29,lvboxlin:52,lvertneqq:52,lyap:67,lyapunov:67,mac:41,machin:[5,12,21,25,26],machine_spec:70,machinefil:[31,45],maco:66,macrocal:1,macroexpand:[3,5,12,39,57],macron:52,mad:44,made:[20,23,29,30,41,44,45,46,57,64,70,75],mag:52,mag_right:52,magic:40,magnifi:[51,52],magnitud:[38,46,67,68],mahjong:52,mai:[2,3,5,10,11,12,14,15,16,17,20,21,23,24,25,26,27,28,29,30,31,33,34,36,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,56,57,58,59,61,64,65,67,68,69,70,72,74,75],mail:52,mailbox:52,mailbox_clos:52,mailbox_with_mail:52,mailbox_with_no_mail:52,main:5,mainli:29,mainstream:51,maintain:[1,2,24,41,48,59],maiz:52,major:[20,28,29,39,41,43,44,45,46,47,49,56,71],make:[2,4,5,8,13,14,16,17,20,21,22,23,24,25,27,28,29,30,33,34,35,36,38,39,40,41,42,43],make_expr2:39,male:52,malloc:[10,21,28,65],maltes:52,man:[33,52,65,66],man_with_gua_pi_mao:52,man_with_turban:52,manag:[2,18,21,24],mangl:21,mani:[1,2,3,4,5,10,12,14,15,16,20,21,23,24,25,26,27,28],manipul:[1,4,5,20,21,22,24],manner:[20,21,23,24,25,33,38,39,42,45,51,56,57,58,64,68],manpag:49,mans_sho:52,mantissa:[38,69],manual:[2,5,10,14,16],mao:52,map:6,mapfoldl:59,mapfoldr:59,mapl:52,maple_leaf:52,mapreduc:59,mapreducedim:56,mapsdown:52,mapsfrom:52,mapslic:56,mapsto:52,mapsup:52,mar:[26,52,61],march:[15,26,61],mardi:26,margin:76,mark:1,marker:[64,75],markup:46,masculin:52,mask:[6,43,52,62],massag:52,master:[34,44,45,70,71],master_slav:[45,70],match:[2,16,20,21,23,25,29,33,34,35,36,37,38,39,40,44,49,51,56,57,59,61,68,70,75],matchal:75,math:[3,22,24,29,31,34,46,53,68],math_expr:39,mathemat:[18,20,22,24,25,29,30,32,33,36],matlab:[24,29,36],matrix:14,matter:[2,16,20,25,26,29,39,44,45,46,49,51],matur:[21,44],max:[20,43,46,47,56,59,61,67,68],max_parallel:[45,70],maxab:59,maxdepth:[47,72],maxev:68,maxim:49,maximum:[20,33,43,45,47,50,56,59,67,68,69,70,75],maxintfloat:57,maxit:67,maxsiz:64,maxsum:40,maxval:59,mbf:52,mbfa:52,mbfalpha:52,mbfb:52,mbfbeta:52,mbfc:52,mbfchi:52,mbfd:52,mbfdelta:52,mbfdigamma:52,mbfe:52,mbfeight:52,mbfepsilon:52,mbfeta:52,mbff:52,mbffive:52,mbffour:52,mbffrak:52,mbffraka:52,mbffrakb:52,mbffrakc:52,mbffrakd:52,mbffrake:52,mbffrakf:52,mbffrakg:52,mbffrakh:52,mbffraki:52,mbffrakj:52,mbffrakk:52,mbffrakl:52,mbffrakm:52,mbffrakn:52,mbffrako:52,mbffrakp:52,mbffrakq:52,mbffrakr:52,mbffrakt:52,mbffraku:52,mbffrakv:52,mbffrakw:52,mbffrakx:52,mbffrakz:52,mbfg:52,mbfgamma:52,mbfh:52,mbfi:52,mbfiota:52,mbfit:52,mbfita:52,mbfitalpha:52,mbfitb:52,mbfitbeta:52,mbfitc:52,mbfitchi:52,mbfitd:52,mbfitdelta:52,mbfite:52,mbfitepsilon:52,mbfiteta:52,mbfitf:52,mbfitg:52,mbfitgamma:52,mbfith:52,mbfiti:52,mbfitiota:52,mbfitj:52,mbfitk:52,mbfitkappa:52,mbfitl:52,mbfitlambda:52,mbfitm:52,mbfitmu:52,mbfitn:52,mbfitnabla:52,mbfitnu:52,mbfito:52,mbfitomega:52,mbfitomicron:52,mbfitp:52,mbfitparti:52,mbfitphi:52,mbfitpi:52,mbfitpsi:52,mbfitq:52,mbfitr:52,mbfitrho:52,mbfitsans:52,mbfitsansa:52,mbfitsansalpha:52,mbfitsansb:52,mbfitsansbeta:52,mbfitsansc:52,mbfitsanschi:52,mbfitsansd:52,mbfitsansdelta:52,mbfitsansepsilon:52,mbfitsanseta:52,mbfitsansf:52,mbfitsansg:52,mbfitsansgamma:52,mbfitsansh:52,mbfitsansi:52,mbfitsansiota:52,mbfitsansj:52,mbfitsansk:52,mbfitsanskappa:52,mbfitsansl:52,mbfitsanslambda:52,mbfitsansm:52,mbfitsansmu:52,mbfitsansn:52,mbfitsansnabla:52,mbfitsansnu:52,mbfitsanso:52,mbfitsansomega:52,mbfitsansomicron:52,mbfitsansp:52,mbfitsansparti:52,mbfitsansphi:52,mbfitsanspi:52,mbfitsanspsi:52,mbfitsansq:52,mbfitsansr:52,mbfitsansrho:52,mbfitsanss:52,mbfitsanssigma:52,mbfitsanst:52,mbfitsanstau:52,mbfitsanstheta:52,mbfitsansu:52,mbfitsansupsilon:52,mbfitsansv:52,mbfitsansvarepsilon:52,mbfitsansvarkappa:52,mbfitsansvarphi:52,mbfitsansvarpi:52,mbfitsansvarrho:52,mbfitsansvarsigma:52,mbfitsansvartheta:52,mbfitsansw:52,mbfitsansx:52,mbfitsansxi:52,mbfitsansz:52,mbfitsanszeta:52,mbfitsigma:52,mbfitt:52,mbfittau:52,mbfittheta:52,mbfitu:52,mbfitupsilon:52,mbfitv:52,mbfitvarepsilon:52,mbfitvarkappa:52,mbfitvarphi:52,mbfitvarpi:52,mbfitvarrho:52,mbfitvarsigma:52,mbfitvartheta:52,mbfitw:52,mbfitx:52,mbfitxi:52,mbfitz:52,mbfitzeta:52,mbfj:52,mbfk:52,mbfkappa:52,mbfl:52,mbflambda:52,mbfm:52,mbfmu:52,mbfn:52,mbfnabla:52,mbfnine:52,mbfnu:52,mbfo:52,mbfomega:52,mbfomicron:52,mbfone:52,mbfp:52,mbfpartial:52,mbfphi:52,mbfpi:52,mbfpsi:52,mbfq:52,mbfr:52,mbfrho:52,mbfsans:52,mbfsansa:52,mbfsansalpha:52,mbfsansb:52,mbfsansbeta:52,mbfsansc:52,mbfsanschi:52,mbfsansd:52,mbfsansdelta:52,mbfsanseight:52,mbfsansepsilon:52,mbfsanseta:52,mbfsansf:52,mbfsansfiv:52,mbfsansfour:52,mbfsansg:52,mbfsansgamma:52,mbfsansh:52,mbfsansi:52,mbfsansiota:52,mbfsansj:52,mbfsansk:52,mbfsanskappa:52,mbfsansl:52,mbfsanslambda:52,mbfsansm:52,mbfsansmu:52,mbfsansn:52,mbfsansnabla:52,mbfsansnin:52,mbfsansnu:52,mbfsanso:52,mbfsansomega:52,mbfsansomicron:52,mbfsanson:52,mbfsansp:52,mbfsansparti:52,mbfsansphi:52,mbfsanspi:52,mbfsanspsi:52,mbfsansq:52,mbfsansr:52,mbfsansrho:52,mbfsanss:52,mbfsansseven:52,mbfsanssigma:52,mbfsanssix:52,mbfsanst:52,mbfsanstau:52,mbfsanstheta:52,mbfsansthre:52,mbfsanstwo:52,mbfsansu:52,mbfsansupsilon:52,mbfsansv:52,mbfsansvarepsilon:52,mbfsansvarkappa:52,mbfsansvarphi:52,mbfsansvarpi:52,mbfsansvarrho:52,mbfsansvarsigma:52,mbfsansvartheta:52,mbfsansw:52,mbfsansx:52,mbfsansxi:52,mbfsansz:52,mbfsanszero:52,mbfsanszeta:52,mbfscr:52,mbfscra:52,mbfscrb:52,mbfscrc:52,mbfscrd:52,mbfscre:52,mbfscrf:52,mbfscrg:52,mbfscrh:52,mbfscri:52,mbfscrj:52,mbfscrk:52,mbfscrl:52,mbfscrm:52,mbfscrn:52,mbfscro:52,mbfscrp:52,mbfscrq:52,mbfscrr:52,mbfscrt:52,mbfscru:52,mbfscrv:52,mbfscrw:52,mbfscrx:52,mbfscry:52,mbfscrz:52,mbfseven:52,mbfsigma:52,mbfsix:52,mbft:52,mbftau:52,mbftheta:52,mbfthree:52,mbftwo:52,mbfu:52,mbfupsilon:52,mbfv:52,mbfvarepsilon:52,mbfvarkappa:52,mbfvarphi:52,mbfvarpi:52,mbfvarrho:52,mbfvarsigma:52,mbfvartheta:52,mbfw:52,mbfx:52,mbfxi:52,mbfy:52,mbfz:52,mbfzero:52,mbfzeta:52,mcjit:5,mdai:65,mdblkcircl:52,mdblkdiamond:52,mdblklozeng:52,mdblksquar:52,mdlgblkcircl:52,mdlgblkdiamond:52,mdlgwhtdiamond:52,mdnode:8,mdsmblksquar:52,mdsmwhtcircl:52,mdsmwhtsquar:52,mdwhtcircl:52,mdwhtdiamond:52,mdwhtlozeng:52,mdwhtsquar:52,mean:[1,5,14,15,16,20,21,23,24,26,28],meaning:51,meaningless:74,meant:[25,41,44,48],meantim:44,meanwhil:42,measangledltosw:52,measangledrtos:52,measangleldtosw:52,measanglelutonw:52,measanglerdtos:52,measangleruton:52,measangleultonw:52,measangleurton:52,measeq:52,measur:[26,45],measuredangl:52,measuredangleleft:52,meat:52,meat_on_bon:52,mechan:[6,7],medblackstar:52,median:68,medic:52,medium:52,medwhitestar:52,mega:52,megaphon:52,melon:52,mem:[46,47,72],member:[43,52,57,59,62],membership:52,memdebug2:17,memdebug:17,memo:52,memori:[5,7],men:52,mental:[26,44],mention:[23,25,29,30,40,42,47,51,57,64],mercredi:26,mercuri:52,mere:[45,46],merg:[29,44,59,72],mergesort:74,meridian:52,mersenn:69,mersennetwist:69,mesh:45,mess:23,messag:13,met:70,meta:[1,7],meta_branch:[44,71],metacharact:[48,49],metadata:[1,8,9,10,27],metaprogram:[12,18,27,32,36],meter:11,meterunit:11,meth:40,method:1,method_exist:57,method_to_break:4,methoderror:[16,23,24,25,33,35,40,49,50,51,57,64],methodswith:[12,57],metro:52,mfrak:52,mfraka:52,mfrakb:52,mfrakc:52,mfrakd:52,mfrake:52,mfrakf:52,mfrakg:52,mfrakh:52,mfraki:52,mfrakj:52,mfrakk:52,mfrakl:52,mfrakm:52,mfrakn:52,mfrako:52,mfrakp:52,mfrakq:52,mfrakr:52,mfrakt:52,mfraku:52,mfrakv:52,mfrakw:52,mfrakx:52,mfrakz:52,mho:52,microphon:52,microscop:52,microsecond:[47,57],mid:[46,52],midbarve:52,midbarwedg:52,middl:[38,45,52,68],midlin:52,midpoint:[29,68],midwai:13,might:[1,4,9,14,20,21,24,28,29,30,39,40,42,44,45,46,47,50,51,54,55,57,59,64,69,70],milki:52,milky_wai:52,mill:52,millisecond:[26,45,61,70],mime:64,mimewrit:64,mimic:48,min:[3,20,43,56,59,65,68],minab:59,mind:[17,21,29,46],minibu:52,minidisc:52,minim:[5,17,44,45,51,64,67,68],minimum:[20,24,33,43,44,49,56,59,64,67,68,70],minmax:68,minor:[29,44,46,49,71],minu:[38,52,68],minusdot:52,minusfdot:52,minusrdot:52,minut:[26,31,49,61,65],minval:59,mirror:[10,21,26],miser:17,misfeatur:1,misplac:39,miss:[10,14],mit:[31,36,44,52,71],mita:52,mitalpha:52,mitb:52,mitbbb:52,mitbbbd:52,mitbbbi:52,mitbbbj:52,mitbeta:52,mitc:52,mitchi:52,mitd:52,mitdelta:52,mite:52,mitepsilon:52,miteta:52,mitf:52,mitg:52,mitgamma:52,mith:52,miti:52,mitiota:52,mitj:52,mitk:52,mitkappa:52,mitl:52,mitlambda:52,mitm:52,mitmu:52,mitn:52,mitnabla:52,mitnu:52,mito:52,mitomega:52,mitomicron:52,mitp:52,mitparti:52,mitphi:52,mitpi:52,mitpsi:52,mitq:52,mitr:52,mitrho:52,mitsans:52,mitsansa:52,mitsansb:52,mitsansc:52,mitsansd:52,mitsansf:52,mitsansg:52,mitsansh:52,mitsansi:52,mitsansj:52,mitsansk:52,mitsansl:52,mitsansm:52,mitsansn:52,mitsanso:52,mitsansp:52,mitsansq:52,mitsansr:52,mitsanss:52,mitsanst:52,mitsansu:52,mitsansv:52,mitsansw:52,mitsansx:52,mitsansz:52,mitsigma:52,mitt:52,mittau:52,mittheta:52,mitu:52,mitupsilon:52,mitv:52,mitvarepsilon:52,mitvarkappa:52,mitvarphi:52,mitvarpi:52,mitvarrho:52,mitvarsigma:52,mitvartheta:52,mitw:52,mitx:52,mitxi:52,mitz:52,mitzeta:52,mix:25,mixin:41,mixtur:[25,38],mkdir:62,mkpath:62,mktemp:62,mktempdir:62,mlcp:52,mmap:[64,65,70],mobil:52,mobile_phone_off:52,mod1:68,mod2pi:[38,68],mod:[1,20,33,38,41,57,68],modal:35,mode:[17,31],model:[36,43,52],modern:[33,36,45],modf:68,modif:[10,20,21,30,47,49,51,54,56,67],modifi:[4,15,17,20],modtwosum:52,modul:[1,3,5,6,12,13,15,16,18,26],modular:33,module_nam:57,module_par:57,modulenam:41,modulo:[38,52,68],modulu:[33,38,43,68],mohi:67,moment:[16,26,44,46],mon:61,mondai:[26,61],monei:52,money_with_w:52,moneybag:52,monitor:64,monkei:52,monkey_fac:52,monorail:52,monospac:52,monster:52,mont:45,month:[26,29,40,61,65],monthabbr:61,monthdai:[26,61],monthnam:[26,61],monthtovalu:26,monthtovalueabbr:26,moon:52,moor:[36,67],more:[1,3,4],moreequ:67,moreov:[21,23,39,47,48],morespecif:16,morev:69,mortar_board:52,most:[1,3,4,10,14,16,17,20,21,23,24,25,26,27,28,29,30,33,34,35,36,38,39,40,41,43,44,45,46,47,48,49,51,53,54,55,56,57,58,59,61,64,67,68,69,72,75],mostli:[1,13,36,41,43,49,57,75],motiv:[14,26,39,45],mount:[52,62],mount_fuji:52,mountain:52,mountain_bicyclist:52,mountain_cablewai:52,mountain_railwai:52,mous:52,mouse2:52,mouth:52,mov:29,move:[20,21,24,33,34,36,39,41,44,45,54,62,69,71],movement:34,movi:52,movie_camera:52,moyai:52,mpfr:[33,40,69],mpi:45,ms_async:[60,65],ms_invalid:[60,65],ms_sync:[60,65],msans:52,msansa:52,msansb:52,msansc:52,msansd:52,msanseight:52,msansf:52,msansfiv:52,msansfour:52,msansg:52,msansh:52,msansi:52,msansj:52,msansk:52,msansl:52,msansm:52,msansn:52,msansnin:52,msanso:52,msanson:52,msansp:52,msansq:52,msansr:52,msanss:52,msansseven:52,msanssix:52,msanst:52,msansthre:52,msanstwo:52,msansu:52,msansv:52,msansw:52,msansx:52,msansz:52,msanszero:52,mscr:52,mscra:52,mscrb:52,mscrc:52,mscrd:52,mscre:52,mscrf:52,mscrg:52,mscrh:52,mscri:52,mscrj:52,mscrk:52,mscrl:52,mscrm:52,mscrn:52,mscro:52,mscrp:52,mscrq:52,mscrr:52,mscrt:52,mscru:52,mscrv:52,mscrw:52,mscrx:52,mscry:52,mscrz:52,msg:[39,57,64],msg_bodi:39,msync:65,msys2:28,mtime:[57,62,64],mtt:52,mtta:52,mttb:52,mttc:52,mttd:52,mtte:52,mtteight:52,mttf:52,mttfive:52,mttfour:52,mttg:52,mtth:52,mtti:52,mttj:52,mttk:52,mttl:52,mttm:52,mttn:52,mttnine:52,mtto:52,mttone:52,mttp:52,mttq:52,mttr:52,mttseven:52,mttsix:52,mttt:52,mttthree:52,mtttwo:52,mttu:52,mttv:52,mttw:52,mttx:52,mtty:52,mttz:52,mttzero:52,much:[1,5,17,21,23,24,26,29,33,36,40,41,43,44,45,46,47,48,50,51,52,56,57,67,68],mug:52,muladd:68,mulfun:11,multi:[3,18],multicast:64,multicast_loop:64,multicast_ttl:64,multicor:45,multidimension:[3,20],multilin:[24,43],multilinear:39,multimap:52,multimedia:16,multipl:[3,5,10,14,15,17,20,21,22,23,24,25,26],multipli:[25,27,29,33,59,67,68,73],multiprocess:45,multiset:52,multitask:24,muscl:52,mushroom:52,music:52,musical_keyboard:52,musical_not:52,musical_scor:52,must:[2,3,5,8,10,20,21,22,23,24,25,27,28,29,30,31,33,34,35,36,37,38,39,40,41,42,43,44,45,46,49,51,53,56,57,58,59,61,62,64,67,68,69,70,71,75],mutabl:[1,10,20,21,29,30,35,51,54,56,57],mutat:[20,27,29,35,43,53,56,59,74],mute:52,mutual:[21,54],my_real_callback:21,myaccount:44,myambiguouscontain:46,myambiguoustyp:46,myappend:40,myarg:24,myarrai:[20,56],mybettercontain:46,mycod:41,mycompar:21,mycompare_c:21,mycontain:46,mycustomexcept:24,myfix:44,myfork:44,myfun:46,myfunc:[21,46,47],myfunct:[9,43],myid:[41,45,70],myimag:64,myintersect:16,mykei:34,mylib:21,mylibvar:21,mymacro:43,mymodul:[29,39,41],mynewcod:29,mypackag:15,myplu:51,myrang:45,mysimplecontain:46,mystdout:41,mysteri:[16,39],mystillambiguoustyp:46,mysum:3,mytask:24,mytyp:[16,29,41,45,46,50],mytypeof:40,myundefvarerror:24,n_1:68,n_d:68,nabla:52,nadir:51,nail:52,nail_car:52,naiv:39,nall:3,name:[1,4,5,6,10,12,15,16,20,21,22,24,25,26,27,29],name_badg:52,namespac:29,nan16:[33,69],nan32:[33,38,69],nan:[22,33,38,46,57,64,68,69,76],nan_dom_err:46,nand:52,nanosecond:57,napprox:52,narg:[4,28],nargout:43,nasymp:52,nativ:[4,5,8,15,21,25],nativetyp:50,natur:[3,14,23,24,25,26,27,29,33,38,44,45,46,50,51,52,62,68],navig:44,nb_avail:64,nbad:[49,75],nbumpeq:52,nbyte:10,nce:47,nchunk:45,ncol:43,ncong:52,nconv:67,ncv:67,ndigit:68,ndim:[14,20,28,35,56,68],ndrang:59,nearest:[33,34,38,68,70],nearli:[20,36,47,48],nearrow:52,necessari:[1,3,9,14,20,21,22,24,25,27,28,29,30,38,39,43,44,45,46,48,50,51,54,57,59,62,64],necessarili:[1,9,14,24,28,49,67],neckti:52,need:[1,2,3,4,5,10,13,14,16,20,21,23,24,25,26,28,29,30,35,36,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,54,55,56,57,58,59,61,62,64,65,68,71,72,74,75],needl:75,neg:[22,23,24,26,29,33,38,43,52,67,68,69],negat:[24,33,38,44,52,61],negative_squared_cross_mark:52,neglig:74,nehalem:2,neighbor:20,neither:[14,16,24,29,33,40,49,52,56,58,62],nel:75,nelli:40,neovnwarrow:52,neovsearrow:52,neptun:52,neqsim:52,nequiv:52,nest:[3,9,12,24,39,47,52,54,57,68],nestabl:73,nestedgreatergreat:52,nestedlessless:52,net:46,netlib:67,network:[18,32],neumaier:56,neuter:52,neutral:[52,59],neutral_fac:52,nev:67,never:[21,24,25,30,31,39,46,48,51,54,58,61,64,68],nevertheless:40,new_moon:52,new_moon_with_fac:52,newbranch:44,newcom:[29,44],newer:44,newest:71,newli:[42,44,45,51,54,70],newlin:[42,49,64,75],newline2l:75,newline2lf:75,newline2p:75,newobj:10,newspap:52,newstruct:10,newvarnod:1,nexist:52,nexpr:3,next:[1,2,6,14,15,16,21,24,26,28,29,33,34,35,39,42,43,44,45,46,47,49,51,54,56,57,59,61,64,65,68,69,70,71,75],nextfloat:[33,69],nextidx:45,nextind:[49,75],nextpow2:68,nextpow:68,nextprod:68,nfc:75,nfd:75,nfield:[10,57],nfkc:75,nfkd:75,ngener:3,ngeq:52,ngeqslant:52,ngtr:52,ngtrsim:52,nhdownarrow:52,nhead:45,nhuparrow:52,nib:52,nice:68,nichola:67,nif:3,night:52,night_with_star:52,nine:52,niobar:52,nisd:52,niter:67,nle:48,nleftarrow:52,nleftrightarrow:52,nleq:52,nleqslant:52,nless:52,nlesssim:52,nlink:[57,62],nloop:3,nmemb:21,nmid:52,nmult:67,nni:52,nnz:[20,56],no_affin:2,no_bel:52,no_bicycl:52,no_entri:52,no_entry_sign:52,no_good:52,no_mobile_phon:52,no_mouth:52,no_pedestrian:52,no_smok:52,node:[1,5,31,45,51,57,70],nodej:64,nofield:51,noh:[49,75],noinlin:[1,27],nois:[30,33,46,47],nolinebreak:52,nolta:44,nomenclatur:23,nomin:51,non:[3,17,20],none:[1,12,16,17,20,23,24,29,30,31,39,40,46,47,50,51,54,57,71,76],nonempti:67,nonfork:52,nonneg:24,nonposit:67,nonprincip:67,nonscalar:35,nonsymmetr:67,nontrivi:56,nonzero:[20,51,56,67],noop:37,nope:26,nor:[33,40,45,49,52,56,58,62,70],norm:[46,51,67,68],normal:[2,20,21,22,23,24,26,28,29,30,39,41,43,44,48,49,52,54,56,57,62,68,69,71,75],normalform:75,normalize_str:75,normpath:[62,71],normtyp:67,north:52,nose:52,notabl:[8,21,28,38,54],notat:[20,22,30,33,36,38,39,43,48,49,51,52,54,59,64],note:[2,4,5,6,10,11,12,14,15,16,17,20,21,22,24,25,26],notebook:[52,64],notebook_with_decorative_cov:52,noteworthi:[18,32],notgreatergreat:52,notgreaterless:52,noth:[1,3,6,10,15,16,21,24,25,28,29,34,39,42,44,46,48,49,50,51,57,60,62,64,67,68,70,71,75,76],nothing:10,notic:[21,24,25,28,29,30,35,39,41,42,45,46,49,51],notif:[45,64,70],notifi:[10,21,24,28,44,45,64,70],notin:52,notion:[14,25,26,48,68,74],notlefttrianglebar:52,notlessgreat:52,notlessless:52,notnestedgreatergreat:52,notnestedlessless:52,notori:21,notrighttrianglebar:52,notsquaresubset:52,notsquaresuperset:52,nov:[26,61],novemb:[26,61],now:[1,4,6,11,14,15,16,21,23,25,26,28,29,35,39,40,42,43,44,45,46,47,51,55,61,64],nowher:25,nparallel:52,npolint:52,nprec:52,npreccurlyeq:52,npreceq:52,nprecsim:52,nproc:[45,70],nref:3,nrightarrow:52,nrm2:67,nrow:43,nsim:52,nsime:52,nsqsubseteq:52,nsqsupseteq:52,nstep:46,nsubset:52,nsubseteq:52,nsubseteqq:52,nsucc:52,nsucccurlyeq:52,nsucceq:52,nsuccsim:52,nsupset:52,nsupseteq:52,nsupseteqq:52,nsv:67,nth:49,nthperm:56,ntoh:64,ntriangleleft:52,ntrianglelefteq:52,ntriangleright:52,ntrianglerighteq:52,ntupl:[3,14,35,39,45,57,70],nul:[21,57,75],nullabl:[29,45,50],nullexcept:[51,57],nullspac:67,num2hex:69,num:[22,23,25,30,51,65,68,69],numcor:76,numer:[8,21,22,23,25,29,31],numericextens:44,numero:52,numpi:[43,46],nut:52,nut_and_bolt:52,nutshel:44,nvdash:52,nvleftarrow:52,nvleftarrowtail:52,nvleftrightarrow:52,nvrightarrow:52,nvrightarrowtail:52,nvtwoheadleftarrow:52,nvtwoheadleftarrowtail:52,nvtwoheadrightarrow:52,nvtwoheadrightarrowtail:52,nwarrow:52,nworker:[46,70],nwovnearrow:52,nx1:43,nzrang:56,nzval:[20,67],obar:52,obei:69,obj1:29,obj2:29,obj3:29,obj:[4,23,40,57],objconstructor:29,object:[1,4,5,6,7,8],object_id:[41,57],object_inst:58,objectiddict:[41,57,59],obliqu:52,observ:[12,25,33,49,68],obslash:52,obtain:[21,24,28,45,47,53,58,62,64,65,67,68,72,75],obviou:[1,14,23,24,29,30,45,49],obvious:[41,46,53],occas:51,occasion:[2,29,39,40,44,45,55],occur:[2,4,16,21,24,25,29,33,35,39,40,41,43,45,46,47,48,49,51,57,61,64,70,74],occurr:75,ocean:52,ocirc:52,oclock:52,ocommatopright:52,oct:[44,61,69],octal:[33,43,49,69],octob:61,octopu:52,odd:[14,26,44,46,51,54,69],oden:52,odiv:52,odot:52,odotslashdot:52,off:[1,5,24,25,36,38,44,45,52,64,67,70],off_t:58,offend:64,offer:[2,20,38],offic:52,offici:[35,44],offset:[5,12,14,20,39,49,57,58,64,70],often:[2,14,16,17,20,21,23,24,25,26,30,33,35,36,37,38,39,40,41,43,44,45,46,47,50,51,57,68,70],oftentim:46,oftyp:[46,57],ogonek:52,ogr:52,ogreaterthan:52,ohm:52,oiiint:52,oiint:52,oint:52,ointctrclockwis:52,ok_hand:52,ok_woman:52,old:[28,29,33,34,51,64,69],older:[3,15,34,52,67],older_man:52,older_woman:52,olessthan:52,olsen:26,omega:52,omicron:52,ominu:52,omit:[16,20,21,24,25,30,31,40,45,50,51,67,68,75],onc:[1,2,4,16,23,28,29,31,33,36,38,39,40,41,43,44,45,46,47,48,54,56,57,59,64,70,71],oncom:52,oncoming_automobil:52,oncoming_bu:52,oncoming_police_car:52,oncoming_taxi:52,ongo:25,onli:[1,4,6,8,10,14,16,21,22],onlin:[33,44],onto:[1,24,29,33,43,45,64],oop:[29,44],op1:39,op2:39,opaqu:[10,64,66],open:[2,20,24,30,36,41,42,44,45,47,48,49,52,62,64,67,71],open_file_fold:52,open_hand:52,open_mouth:52,openbracketleft:52,openbracketright:52,operand:[22,23,24,25,30,38,46,51],operm:62,ophiuchu:52,oplu:52,opluslhrim:52,oplusrhrim:52,oppos:[2,24,27,75],opposit:[28,43,51,68],opr1:39,opr1f:39,opr2:39,opr2f:39,opt:[8,22,35,54,56],optic:52,optim:5,option:[3,4,6],oqaqu:10,or_int:46,orang:[52,57],orange_book:52,ord:[49,59],order:[1,4,5,16,20,21,23,24,26,28,30,33,35,38,39,41,43,44,45],orderedpair:23,ordin:52,ordinalrang:[40,74],ordinari:[21,29,39,40,49,51,57,67,68],ordschur:67,org:[29,31,34,44,45,64,67,68],organ:[40,43,44,51],orghr:67,orglq:67,orgqr:67,orient:[25,36,40,51,67],origin:[20,21,24,25,26,44,46,51,52,57,59,64,65,67,71,74,75],ormlq:67,ormqr:67,ormrz:67,ornament:52,orthogon:[52,67],orthonorm:67,os_nam:[21,60],oscillatori:68,oslash:52,ostream:64,osx:[2,6,21,44,57],other:[2,3,4,5,6,8,10,14,16,18,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42],otherlib:41,otherwis:[5,8,10,12,16,20,21,23,24,26,29,33,38,39,40,43,44,45,48,51,53,56,57,59,61,62,64,67,68,69,70,71,72,75],otim:52,otimeshat:52,otimeslhrim:52,otimesrhrim:52,oturnedcomma:52,ouch:29,ouput:2,our:[2,6,14,16,25,26,28,29,35,40,45,46,47],ourselv:35,out:[2,4,8,14,16,20,21,22,23,26,28,39,40,42,43,44,45,46,47,48,51,52,54,57,64,68,71],outbox:52,outbox_trai:52,outcom:[26,29],outer:1,outfil:30,outlin:24,outliv:[54,57],outofmemoryerror:[24,57],output:[2,4,12,13,28],outset:44,outsid:[23,24],outstand:14,outstrm:70,outward:40,over:[1,4,5,6,14,16,20,21,24,29,33,35,36,38,39,40,43,44,45,46,49,50,51,52,56,59,61,64,67,68,69,70,72,75],overal:[23,40,46,47],overbar:52,overbrac:52,overbracket:52,overflow:[29,30],overflowerror:[24,57],overhead:[14,21,29,33,37,43,45,46,47],overlai:52,overlap:[13,46,49,52,56,67,75],overleftarrow:52,overleftrightarrow:52,overlin:52,overload:23,overrid:[8,31,35,51,57,59,64],overridden:27,overscor:52,overwrit:[59,67,68],overwritten:[6,20,53,56,67,68],ovhook:52,own:[1,10,16,21,23,24,25,35,36,38,39,41,43,44,45,46,47,49,51,56,57,58,59,62,64,69,70],owner:[44,62],pace:36,pack:[21,50,51,56],packag:[15,18,20,21,26,27],packet:64,pad:[21,69,75],page:[2,14,29,34,35,44,52,65,66],page_facing_up:52,page_with_curl:52,pager:[52,57],pai:[20,29],pair:[16,21,23,25,28,30,38,39,40,41,45,49,51,52,54,57,59,64,67,68,70],palat:52,palett:52,palm:52,palm_tre:52,panda:52,panda_fac:52,paper:[33,52],paperclip:52,paradigm:[36,40],paragraph:[27,38,52,75],parallel:[18,24,31,32,36,43],parallelogram:52,parallelogramblack:52,param:[10,45,70],paramet:1,parameter:[24,46,51,67],parametr:[16,20],paren:50,parent:[10,14,17,20,28,41,47,48,51,54,56,57,62,70],parenthes:[1,21,24,30,33,39,43,49],parenthesi:[3,30,43,52],parenthet:33,parentindex:[14,56],park:52,parlanc:[26,39,51],pars:[1,3,4],parse_opt:6,parseerror:[24,57],parseip:64,parser:[1,5,6,26,27,39,49],part:[1,5,20,22,23,25,26,29,35,39,41,45,46,48,49,52,56,57,61,62,64,67,68,71,75],part_alternation_mark:52,parti:52,partial:[16,21,24,39,46,49,52,59,68,74,76],partialmeetcontract:52,partialquicksort:74,particip:[25,33,40,44,45,70],particularli:[4,16,24,25,40,43,46,49,50,51,57],partit:[56,70],partli:[36,44],partly_sunni:52,pass:[4,5],passport:52,passport_control:52,passwd:48,passwordless:[31,45],past:[36,39,48,57],pat:75,patch:[44,49,71],patchwork:40,path:[6,21,24,27,28],path_to_your_script:2,patholog:39,patient:68,pattern:[3,5,20,21,24,35,39,42,43,45,46,49,55,57,61,64,75],paus:42,paw:52,pcre:49,pdf:48,peach:52,peak:67,peakflop:67,pear:[43,52],pearson:68,ped:65,pedagog:25,pedestrian:52,peek:59,pem:70,pen:52,penalti:[46,50],pencil2:52,pencil:[44,52],pend:28,penguin:52,penros:67,pensiv:52,pentagon:52,pentagonblack:52,penv:16,peopl:[44,62],per:[21,27,39,41,45,49,52],perceiv:75,perfect:26,perfectli:[41,45,46],perform:[3,9,14,16,18,20,21,22,24,25,26,28,29,30,32,33,35,36,38,39,40,41,43,44,45],performing_art:52,perhap:[3,4,16,23,26,29,39,40,45,46,49,51],perl:[24,25,30,31,36,48,49,64],perlr:49,perm:[56,67],perman:[44,52],permiss:[46,62],permit:[10,16,21,31,38,51,59,69],permut:[25,56,67,74],permutedim:56,perp:52,perpendicular:52,persev:52,persever:52,persist:41,person:[39,44,52],person_frown:52,person_with_blond_hair:52,person_with_pouting_fac:52,perspcorrespond:52,perspect:[39,52],pertain:[43,54],pertin:2,perus:23,peseta:52,pharyng:52,phase:[2,4,22,41,68],phi:52,philadelphia:67,philosophi:[21,44],phone:52,php:26,phrase:5,physic:[11,26],pick:[4,8,16,24,40,44,45,68,69,74],pictur:[30,46],pid:[45,46,70],piec:[5,13,23,24,45,47,50,51],piecewis:40,pig2:52,pig:52,pig_nos:52,pilcrow:52,pile:52,pill:52,pine:52,pineappl:[49,52,75],pinv:67,pipe:[13,42,48,52,57,64],pipebuff:64,pipeendpoint:64,pipeserv:[42,64],pisc:52,pistol:52,pitchfork:52,pitfal:[48,69],pittsburgh:26,piv:67,pivot:[37,67],pizza:52,pkg1:71,pkg2:71,pkg:[40,41,44,49,57,71],place:[9,13,15,16,20,21,24,25,27,28,29,33,34,38,39,41,43,46,47,51,52,53,54,56,57,59,67,68,74],plai:[16,46,52],plain:[21,23,30,39,45,49,51,57,64],plan:[1,8,41,44,68],plan_bfft:68,plan_brfft:68,plan_dct:68,plan_fft:68,plan_idct:68,plan_ifft:68,plan_irfft:68,plan_r2r:68,plan_rfft:68,planck:52,planckconst:52,plane:68,planner:68,platform:[2,4,6,10,13,15,21,29,34,45,57,64,65,66,71,76],pleas:[2,21,62],plot:[30,44,67],plu:[34,38,47,50,52,64],plug:[52,69],plumb:[45,48],plural:44,plusdot:52,pluseqq:52,plushat:52,plussim:52,plussubtwo:52,plustrif:52,pluto:52,pma:44,pmap:[45,70],pmax:43,pmin:43,png:64,point:[1,4,5,6,8,10,12,13,16,18,20,22,23,24,25,28,29,30,31,32],point_down:52,point_left:52,point_right:52,point_up:52,point_up_2:52,pointer:[5,6,10,13,14,20],pointer_from_objref:[16,21,58],pointer_to_arrai:[21,58],pointi:51,pointint:52,pointless:30,pole:52,polic:52,police_car:52,polici:8,polish:52,poll:[64,70],poll_fd:[64,70],poll_fil:64,pollint:70,polyalgorithm:67,polygamma:68,polymorph:[25,51],polynomi:[30,33,68,69],poo:52,poodl:52,pool:[6,10,17,45,70],poor:[23,29],poorer:46,poorli:[14,46],pop:[1,29,50,59,64],popdisplai:64,popmeta:9,popper:52,popul:[16,21,43,44,69],popular:[22,36,51],port:[31,42,45,48,64,70],port_hint:64,portabl:[21,38,64,72],portion:[2,10,24,45,49,61,69],posdefexcept:67,posit:[20,24,26,30,33,38,40,44,46,49,54,56,59,64,67,68,69,74],posix:66,possess:45,possibl:[10,11,14,15,16,17,20,21,23,24,25,26,28,29,30,33,35,36,39,40,41,44,45,46,47,49],post:[3,21,29,31,33,38],post_offic:52,postal:52,postal_horn:52,postalmark:52,postbox:52,postexpr:3,postscript:64,posv:67,pot:52,potabl:52,potable_wat:52,potato:52,potenti:[21,24,29,38,39,41,43,44,46,47,51,53,57,59,64,66],potr:67,potrf:67,potri:67,pouch:52,poultri:52,poultry_leg:52,pound:52,pout:52,pouting_cat:52,pow:[11,43],power:[3,20,23,24,29,30,35,36],power_by_squar:29,powermod:68,powerpc:21,pppprime:52,ppprime:52,pprime:52,practic:[3,21,24,25,26,27,41,45,46,49,51,64],prai:52,pre:[2,3,6,16,25,44],prealloc:[35,46,56,67,68,74],prec:52,precapprox:52,precaut:21,preccurlyeq:52,preced:[14,21,24,33],preceq:52,preceqq:52,precis:[25,26,29,30],precnapprox:52,precneq:52,precneqq:52,precnsim:52,precompil:[5,15,31],precsim:52,predefin:[22,25,51],predic:[56,59,64],predict:[28,29],preemptiv:45,preexpr:3,prefer:[27,29,34,36,50,57,58,62,64,67,69,74],prefix:[3,6,20,21,33,34,39,43,45,48,49,57,58,61,66,68,70,71,73,75],preload:45,prematur:21,premium:29,prepar:3,prepars:[2,15],prepend:[20,55,59],preprocessor:39,prereleas:[34,44],prescript:52,presenc:[26,29,45,51,59],present:[1,3,23,29,31,33,40,42,44,46,48,51,52,57,59,70,75],preserv:[6,20,21,50,59,68],press:[27,34,42,67,70],pressur:45,presum:23,pretend:49,pretti:[26,35],prev:64,prevent:[4,41,46,57],prevfloat:[33,69],prevind:75,previou:[14,24,28,30,34,39,44,46,47,48,51,56,57,61,64,67,68,69,70,72,75],previous:[5,12,23,29,46,51,57,64],prevpow2:68,prevpow:68,prevprod:68,primal:69,primari:[16,30,51],primarili:[5,72],prime:[52,53,68,69],primesmask:69,primit:[5,21,22,24,28,33,36,38,45],princess:52,princip:[22,46,67],print:[2,4,5,6,8,12,13,16,24,28,29,31,34,38,39,41,42,43,44,45,46,47,48,49,52,57,64,67,71,72,75,76],print_escap:[64,75],print_join:64,print_shortest:64,print_unescap:[64,75],print_with_color:64,printabl:[64,75],printarg:29,printer:75,printf:7,println:[3,6,12,13,21,24,28,29,31,33,35,38,39,40,42,43,45,46,48,49,51,59,64,76],printout:39,prior:[14,25,29,30,62],priori:[10,21],priorit:59,prioriti:59,privat:[35,39,41,44,54],privileg:64,probabilist:69,probabl:[20,21,23,24,26,27,29,36,38,43,46,47,51,56,57,68,69],problem:[4,21,23,24,25,29,36,39,40,44,45,46,49,50,54,67,68],problemat:[29,57],proc:[10,31,45,70],proce:[5,40,44,45],procedur:[2,24,44,47,67],proceed:70,process:2,process_exit:57,process_messag:[45,70],process_opt:6,process_run:57,processexitedexcept:57,processor:[15,31,45,46,67,68,76],prod:[35,43,52,59],produc:[20,21,23,24,25,29,30,33,39,41,43,45,46,47,48,49,53,57,64,67,68,70],product:[21,24,36,37,43,48,52,53,56,59,62,67,68],prof:47,profil:[17,18,32,40,46],profileview:[46,47],proflin:52,profoundli:39,profsurf:52,prog:39,prognam:17,program:[2,5,6,10,17,18,20,21,24,25,28,29,30,31,32,33,34,36],programfil:31,programm:[24,25,29,36,39,42,45,51],programmat:[23,27,39,44,45,49],progress:[16,27,46],project:[28,36,44,46,55,67],prolept:[26,61],promis:46,promot:7,promote_op:11,promote_rul:[11,25,57],promote_shap:56,promote_typ:[11,25,50,57],prompt:[4,16,21,31],promptstat:34,proof:52,propag:[5,21,22,24,46,54,70],proper:[21,45,51],propercas:26,properli:[2,41,57],properti:[1,9,10,28,46,51,52,57,59,74],propertylin:52,proport:[47,52,68],propos:44,propto:52,protect:[44,58,62],protocol:44,prototyp:[21,36],prove:52,provid:[3,9,11,12,13,17,20,21,22,23,24,25,26,30,31,33,35,36,38,39,40,41,42,43,44,45,47,49,50,51,53,54,55,56,57,59,61,62,64,67,68,69,70,71,74,75,76],provis:23,proxi:[45,70],prurel:52,pseudo:[1,5,44],pseudoinvers:67,psi:52,pstrf:67,ptl:67,ptld:67,ptr:[10,13,16,20,21,29,40,41,50,51,58,64,65,75],ptrdiff_t:[21,58],ptsv:67,pttr:67,pttrf:67,publicli:44,publish:29,pull:[5,44,47,67,71],pump:52,punctuat:[18,49,53,63],pure:[14,30,51,70],pure_instruct:29,purer:51,purpl:52,purple_heart:52,purpos:[10,12,20,27,30,33,39,40,41,45,46,51,54,57,60,64,70],purs:52,pursu:61,push:[1,14,28,29,35,41,43,44,46,50,59,64,71],pushdisplai:64,pushmeta:9,pushpin:52,put:[28,31,34,40,41,44,45,46,47,52,55,56,66,68,70,74],put_litter_in_its_plac:52,pwd:[17,62,70],pyplot:[44,67],python:[24,25,26,28,30,36,38],qbp:67,qed:52,qrcompactwi:[37,67],qrcompactwyq:67,qrfact:67,qrpackedq:67,qrpivot:[37,67],qsort:21,quad:52,quadgk:68,quadrant:[52,68],quadratur:68,quadrupl:52,qualifi:[29,41,54,57],qualiti:21,quantil:68,quantiti:67,quarter:[26,52,61],quarternot:52,quarterofyear:[26,61],quasi:[1,67],quaternion:52,queri:[10,20,24],questeq:52,question:[18,25,28],queu:[24,70],queue:[24,45,59,70],quick:[20,34,50],quickli:[45,68],quicksort:74,quiet:31,quit:[5,14,17,20,21,23,24,25,26,29,30,31,34,35,38,39,40,44,45,46,47,48,49,51,54,57,72,74],quot:[1,3,9,12,21,27,34],quotat:[49,52],quotenod:[1,39],quotient:[38,68],qux:[48,51],qword:29,r2hc:68,r2r:68,r_str:[39,75],rabbit2:52,rabbit:52,race:[48,52,70],racehors:52,racquet:52,rad2deg:68,radian:[22,38,68],radic:[26,52],radio:52,radio_button:52,rage:52,rai:52,rail:52,railwai:52,railway_car:52,rain:52,rainbow:52,rais:[23,24,28,29,38,39,40,41,46,49,51,52,57,58,62,66,69,70],raised_hand:52,raising_hand:52,ram:[45,52],ramen:52,ramif:26,rand2:45,rand:[20,24,35,39,43,45,46,47,56,64,69,74],randcycl:56,randexp:69,randjump:69,randn:[20,45,46,69,74],random:[20,43,45,46,47,56],randomdevic:69,randomli:[45,46,56,69],randommatric:44,randperm:56,randstr:75,randsubseq:56,rang:[3,14,20,21,24,26,29,33,35,37,40,41,43,44,45,46,49,51,56,57,59,61,67,68,70,72,73,74,75],rangeexpr:3,rangl:52,rank:[45,67],rapid:76,rapidli:[6,46],rasp:52,rat:[44,52],rata2datetim:61,rata:61,rate:[29,67,69],rather:[14,16,20,21,23,24,26,29,30,31,33,38,39,40,41,42,43,44,45,46,47,48,49,50,51,54,56,57,59,62,67,75],ratio:[22,23,25,51,69],ration:18,rational:33,raw:[5,26,41,42,61,64],rawfd:70,rax:29,rbind:43,rbp:29,rc1:[44,49],rc2:49,rceil:52,rcond:67,rcondv:67,rdev:[57,62],rdi:29,rdiagovfdiag:52,rdiagovsearrow:52,rdsh:52,reach:[5,16,23,24,45,64],reachabl:[10,13,57],read:[3,5,8,10,13,24,25,28,29],read_and_capit:42,readabl:[20,21,39,40,43,49,50,64],readal:[42,48,64],readandwrit:57,readavail:64,readbyt:[42,64],readchomp:64,readcsv:64,readdir:62,readdlm:64,reader:[23,25,45,48,51],readi:[24,30,44,45,47],readili:[14,46],readlin:[42,64],readlink:62,readm:[44,71],readonli:64,readonlymemoryerror:[24,57],readuntil:64,real:[4,16,21,22,23,24,25,26,28,29,30,33,40,43,45,46,49,50,51,57,64,67,68,69],realist:24,realiz:[29,50,67],realli:[4,16,21,23,25,29,39,44,46,47,50,51,56],realloc:65,realmax:57,realmin:57,realpath:62,reappear:44,rearrang:1,reason:[14,15,16,17,21,23,24,25,26,29,36,39,41,45,46,47,48,49,51,54,74],reassign:[5,29,53],rebind:[29,38,43],rebuild:15,recal:[23,25,33,39,40,49,51],recap:51,receiv:[21,35,39,40,44,45,52,64,70],recent:[4,34,44],reciproc:67,recommend:[3,20,21,22,28,33,36,38,44,46,47,53,67,68,70],recompil:[4,41,46,51,57],recomput:44,reconstruct:[20,29,67],record_backtrac:4,recreat:52,rectangl:52,rectangular:[52,67],recur:[26,61],recurs:[1,5,12,20,21,23,24,39,41,44,47,54,57,62,67,68,71],recv:64,recvfrom:64,recycl:52,red:[46,52,57,64],red_circl:52,redefin:[29,53],redefinit:29,redesign:41,redft00:68,redft01:68,redft10:68,redft11:68,redirect:[34,48,57,64],redirect_stderr:64,redirect_stdin:64,redirect_stdout:64,redisplai:64,reduc:[17,21,22,29,30,33,41,45,46,47,49,56,57,59,67,70],reducedim:56,reduct:[43,45,46,56,59,70],redund:[1,25,39,44,50,51],reenable_sigint:58,reentrant:70,reentrantlock:[29,70],ref:[1,6,21,46,58,68],refer:[1,2],referenc:[20,21,27,28,41,49,51,57,58,59,66,70],referenti:23,reflect:10,reflector:67,regard:[43,49,65],regardless:[12,13,24,33,40,44,51,57],regex:[39,49,57,75],regexmatch:[49,75],region:[54,56,59,65,67,68],regist:[4,5,10,34,41,44,45,52,57,64,70,71,74],registerhandl:76,registr:44,regress:67,regular:[20,29,39,45],reid:31,reim:68,reinit_stdio:13,reinstal:44,reinterpret:[20,21,56,69],rejectna:75,rel:[10,12,14,25,26,27,33],relat:[4,16,18,21,24,27,45,46,49,51,52,63,69],relationship:[8,51,67],relax:[23,52],releas:[8,21,28],relev:[5,14,16,21,27,43,45,46,47,50,57,67,70],reli:[13,14,29,35,50,51,62,68,74],reliabl:64,reliev:52,reload:[29,41,44,55,57],relpath:62,reltol:68,relton:67,rem1:68,rem:[33,38,68],remain:[5,14,21,24,35,39,40,44,45,46,51,56,58,74],remaind:[33,38,39,68,73],rememb:[21,24,26,28,30,44,45,46,50],reminisc:39,remot:44,remotecal:[45,50,70],remotecall_fetch:[45,46,50,70],remotecall_wait:[45,70],remoteexcept:[24,70],remov:1,remove_destin:62,renam:[39,62,64],renc:47,render:[27,28,52],reorder:[46,59,67],rep:[46,69],repeat:3,repeat_on:52,repeatedli:[6,24,44,46,61,64],repetit:[3,24,39],repl:[5,6,16,27,28],replac:[3,8],replic:[20,38],repmat:[20,46,67],repo:[44,71],report:0,repr:75,repres:[1,10,11,12,13,14,16,20,21,22,23,24,25,26,27,28,29,33,37,39,43,45,46,47,48,49,50],represent:[1,5,10,11,12,20,23,25,26,29,33,38],reprmim:64,reproduc:69,repstr:34,request:[2,6,20,23,24,25,28,31,42,44,45,47,56,64,67,69,70,71],requir:[4,10,12,14,20,21,23,24,25,28,29,30,35,36,38,39,41,42,43],requisit:50,rese:69,resembl:[45,51],reserv:[30,41,59],reset:[44,47,64],reshap:[14,20,41,56],resid:[47,61,67],residu:67,resiz:[56,59,64],resolut:[42,44,57,61],resolv:[1,21,26,29,33,39,40,41],resort:44,resourc:24,respect:[3,16,20,22,24,25,26,27,33,34,38,43,46,48,49,51,56,57,58,64,67,68,75],respond:44,respons:[21,24,28,44,45,46],rest:[5,20,23,25,44,46,59],restart:[24,45,55,70],restor:[57,70],restore_sign:6,restrict:[11,21,23,27,40,41,51,53,57,64,67],restroom:52,result:[1,4,5,8,10,11,12,14,16,20,21,22,23,24,25,26,28],resultexpr:76,resum:[24,42],ret:[12,28,29,46],ret_unbox:28,retain:[45,48,59],retexpr:39,rethrow:[24,28,57,76],retri:70,retriev:[13,20,21,26,27,28,42,45,54,59,65,72,75],retroflex:52,retun:45,returntyp:[21,58],retval:58,reus:[44,46,54,59,67,68],reusabl:[21,46,50],rev:74,revangl:52,revangleubar:52,reveal:[16,23,47,51],revemptyset:52,revers:[5,21,23,28,34,43,52,56,58,64,74,75],reverseind:56,reverseupequilibrium:52,revert:6,review:21,revisit:67,revolut:61,revolv:52,revolving_heart:52,revstr:34,rewind:52,rewrit:[28,30,39,46,49],rewritten:39,rfft:68,rfloor:52,rfn:56,rho:52,ribbon:52,rice:52,rice_bal:52,rice_crack:52,rice_scen:52,rich:[35,36,37,42,55,64],richer:64,richest:64,riemann:[38,68],right:[3,5,20,24,25,26,29,30,34,35,38,42,43,44,51,52,54,56,57,59,67,68,75,76],right_sv:67,rightangl:52,rightanglearc:52,rightanglemdot:52,rightarrow:52,rightarrowbackapprox:52,rightarrowbar:52,rightarrowbsimilar:52,rightarrowdiamond:52,rightarrowgtr:52,rightarrowplu:52,rightarrowsupset:52,rightarrowtail:52,rightarrowtriangl:52,rightdasharrow:52,rightdotarrow:52,rightdownteevector:52,rightdownvectorbar:52,righthand:52,rightharpoonacc:52,rightharpoondown:52,rightharpoonsupdown:52,rightharpoonup:52,rightharpoonupdash:52,rightleftarrow:52,rightleftharpoon:52,rightleftharpoonsdown:52,rightleftharpoonsup:52,rightmoon:52,rightpentagon:52,rightpentagonblack:52,rightrightarrow:52,rightsquigarrow:52,rightteevector:52,rightthreearrow:52,rightthreetim:52,righttrianglebar:52,rightupdownvector:52,rightupteevector:52,rightupvectorbar:52,rightvectorbar:52,rightward:52,rightwhitearrow:52,rind:59,ring:52,ringplu:52,rins:55,rip:4,rise:52,risingdotseq:52,risk:23,ritz:67,ritzvec:67,rival:36,rma:45,rmoustach:52,rmproc:[45,70],rmt:44,rndmat:44,rng:[56,69,75],rnk:67,roast:52,robust:51,rocket:52,rodft00:68,rodft01:68,rodft10:68,rodft11:68,rol:56,role:[16,36,46],roll:44,roller:52,roller_coast:52,room:47,rooster:52,root:[2,6,22,24,28],ropestr:34,ror:56,rose:52,rot180:56,rotat:[26,52,56,67],rotating_light:52,rotl90:56,rotr90:56,rough:68,roughli:[16,68,75],round:[17,20,25,30],round_pushpin:52,rounddown:[33,68,69],roundfromzero:69,roundimpli:52,roundingmod:[68,69],roundingmodeimaginari:68,roundingmoder:68,roundnearest:[33,68,69],roundnearesttiesawai:68,roundnearesttiesup:68,roundtozero:[68,69],roundup:[33,68,69],rout:13,routin:[20,21,24,37,41,46,51,65],row:[1,20,43,45,46,56,64,67,68,74],rowboat:52,rowval:[20,56,67],rpad:[46,75],rppolint:52,rrbracket:52,rrightarrow:52,rsearch:75,rsearchindex:75,rsh:52,rsi:29,rsolbar:52,rsp:29,rsplit:75,rsqhook:52,rstrip:75,rtime:52,rtld_deepbind:[60,66],rtld_first:[60,66],rtld_global:[28,60,66],rtld_lazi:[60,66],rtld_local:[60,66],rtld_nodelet:[60,66],rtld_noload:[60,66],rtld_now:[60,66],rtol:68,rubi:[24,30,31,36,48,51],rug:29,rugbi:52,rugby_footbal:52,rule:[11,16,21],ruledelai:52,ruler:52,run:1,run_repl:47,runnabl:[24,70],runner:52,running_shirt_with_sash:52,runtest:[17,44,71,76],rval:59,rvboxlin:52,s13:67,s1a:14,s29:4,s84:67,s_1:3,s_2:3,s_3:3,s_4:3,s_j:3,saba:[2,49],sacrif:20,safe:[14,21,28,41,45,46,48,49,50],safe_oper:41,sagittariu:52,sai:[4,5,14,23,25,26,29,35,39,44,47,51,55],sailboat:52,sake:[24,52],salient:51,same:[2,4,15,16,20,21,23,24,25,26,27,28],same_typ:40,same_type_numer:40,samedi:26,sampi:52,sampl:[17,28,45,47,56,68,72],samuel:67,san:52,sand:52,sandal:52,sanslmirror:52,sanslturn:52,santa:52,sash:52,sat:61,satchel:52,satellit:52,satisfi:[26,38,44,56,61,67,68],satur:[29,48],saturdai:61,saturn:52,sauc:27,save:[5,6,16,20,24,26,28,31,34,35,44,47,55,67,68,72],savour:52,saw:[16,42],saxophon:52,sayhello:39,sbmv:67,scal:67,scala:51,scalabl:45,scalar:[20,21,35,37,38,43,56,57,67,68],scale:36,scan:9,scanner:6,scatter:46,scenario:[25,41,44,51],scene:42,schedul:[21,24],scheme:[1,30,49],school:52,school_satchel:52,schreiber1989:67,schreiber:67,schur:67,schurfact:67,schwa:52,sci:67,scientif:[33,36,57,67],scientist:33,scissor:52,scm:[1,5,44],scope:[18,24,29],score:52,scorpio:52,scorpiu:52,scpolint:52,scratch:55,scream:52,scream_cat:52,screen:34,scriptfil:31,scroll:52,scurel:52,sdata:[45,70],seamless:40,seamlessli:36,search:[6,12,16,27],searchabl:34,searchindex:75,searchsort:[20,74],searchsortedfirst:74,searchsortedlast:74,searrow:52,seat:52,sec:[20,38,65,68,70],secant:68,secd:[20,38,68],sech:[20,38,68],second:[1,3,6,11,14,16,20,21,23,24,25,26,27,28,30,33,35,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,56,57,61,64,65,67,68,70,72,75],secret:[27,52],section:[3,10,12,17,20,21,22,24,25,29,30,34,35,36,37,39,40,43,44,45,46,49,50,51,52,54,56,57,59],see:[4,6,10,12,13,16,17,20,21,23,24,25,26,28,29,30,31,33,34,35,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,54,55,56,57,58,59,60,62,64,65,66,67,68,69,70,72,74,75],see_no_evil:52,seed:69,seedl:52,seek:64,seekend:64,seekstart:64,seem:[16,24,29,30,40,44,45,46,51,54],seen:[23,28,33,39,43,45,76],segfault:[0,1],segment:[45,52,64,68],select:[5,12,20,43,51,55,67,68,74],selector:52,selectperm:74,self:[5,13,17,23],selfreferenti:23,semant:[30,39,49,53,54,68,70],semi:67,semicircl:52,semicircular:52,semicolon:[3,20,24,30,31,34,43,47],semidirect:52,seminumer:69,send:[34,44,45,57,64,70],sens:[23,25,28,29,30,38,40,41,45,48,50,51,54,57,59,67,68,70,74],sensibl:23,sensit:7,sent:[4,42,45,48,64,70],seovnearrow:52,sep:61,separ:[13,14,23,24,27,29,31,33,35,39,40,41,43,44,45],septemb:61,sequenc:[1,3,5,24,33,35,47,49,52,59,64,68,69,75],sequenti:[30,35,59],seri:[20,24,33,39,49,50,54,56,64],serial:[5,41,45,46,57,64],serialis:[6,13],serif:52,serious:46,serv:[16,23,27,30,46,51,57],server:[42,64],servic:44,session:[4,15,21,24],set:[4,5,6,8,13,15],set_bigfloat_precis:[33,69],set_num_thread:68,set_process_titl:57,set_round:[33,69],set_zero_subnorm:[46,69],setdiff:59,setenv:57,setfield:57,setgid:62,setjmp:1,setminu:52,setopt:64,setuid:62,setup:28,setup_interfac:34,seven:52,sever:[4,10,12,17,21,23,24,26,28,29,30,33,34,41,42,43,44,45,46,48,51,53,56,64,67,68],sha1:44,shade:52,shadow:30,shallow:57,shape:[20,35,52,56,68],share:[15,21,24,28,30,41,43],sharedarrai:[45,64,70],sharp:52,shave:52,shaved_ic:52,shed:44,sheep:52,sheer:46,shell:[21,28],shell_pars:39,shield:46,shift:[38,43,56,59,67,68],shini:44,ship:[15,17,21,22,52],shirt:52,shoe:52,shoot:52,shortcak:52,shortcut:41,shorter:[39,44,46],shortest:[49,64],shorthand:[2,4,6,16,20,38,43,49],shortli:23,shot:24,should:[2,3,5,10,11,14,15,16,17,20,21,23,25,26,27,28,29,30,31,33,34,38,39,40,41,42,43,44,45,46,49,50,51,54,56,57,58,59,61,64,65,67,68,70,75],shouldn:57,show:[6,16,17,20,28,31,34,38,39,40,41,42,44,45,47,48,50,52,56,57,64],show_delim_arrai:16,show_sexpr:[12,39],showal:[64,75],showarg:39,showcompact:64,shower:52,showerror:[24,64],showlimit:16,shown:[31,41,45,46,49,51,53,57,67,72],showpar:57,shrimp:52,shuffl:[52,56],siam:67,side:[4,5,29,30,38,39,41,42,43,44,45,51,54,67,76],sidestep:51,siev:69,sig:16,sigabrt:6,sigbu:6,sigdie_handl:6,sigfp:6,sigil:6,siginfo:6,sigint:6,sigint_handl:6,sigma:[52,67],sign:[5,16,21,23,25,33],signal:[6,13,28,31,45,57,60,67],signal_strength:52,signatur:[4,5,9,12,16,21,25,30,34,40,45,50,51,57],signbit:[38,57,68],signif:68,signific:[1,24,33,36,39,43,45,46,49,51,68,69],significand:[20,33,38,68,69],significantli:[33,47,51,68],signum:57,sigpip:6,sigquit:6,sigsegv:6,sigsi:6,sigterm:[6,57],silent:[21,29,46,49,66],silhouett:52,sim:52,simd:[8,46],simdloop:8,simeq:52,simg:52,simgtr:52,similar:[2,3,5,14,16,20,21,22,23,24,26,27,31,35,39,41,43,45,46,47,48,51,52,54,56,57,58,61,64,66,67,68,74,75],similarleftarrow:52,similarli:[4,20,21,24,25,26,30,33,43,44,50,51,54,59,61,64,67],siml:52,simless:52,simminussim:52,simpl:[3,5,11,20,21,23,24,26,28,29,30,35,38,39,40],simpler:[5,26,35,39,42,51],simplest:[14,20,23,25,44],simplevector:[1,16],simpli:[1,10,16,23,24,25,26,27,28,29,30,34,35,39,40,44,45,49,50,51,56,58,64,68],simplic:51,simplif:67,simplifi:[21,26,39,44,51],simplu:52,simrdot:52,simul:[30,45],simultan:[45,48,56,61],sin:[20,38,41,46,68],sinc:[1,4,5,6,10,14,20,21,22,23,24,25,26,28,29,30,33,35,38,39,40,41,42,43,44,45,46,47,48,49,50,51,54,56,57,59,61,64,65,67,68,70,74],sind:[20,38,68],sine:[38,52,67,68],sinewav:52,singl:[1,3,8,11,14,16,20,23,24,25,26,27,29,30,33,35,36,38,39,40,41,43,44,45,46,48,49,50,51,52,56,57,59,61,64,68,72,73,74,75],singleasyncwork:21,singleton:4,singular:[37,43,45,67,68],sinh:[20,22,38,68],sinpi:[20,38,68],sit:[2,15],site:[39,46,51,62,71],sitofp:46,situat:[23,24,28,29,30,33,38,39,41,45,46,49,51,58,62,64,66,70],six:[49,52],six_pointed_star:52,size0:28,size1:28,size:[3,10,14,20,21,25,28,29,33,35,37,43,45,46,47,49,51,56,57,58,59,60,61,62,64,65,67,68,69,70,74,75],size_t:[10,16,21,28,58],sizehint:59,sizeof:[6,21,28,33,57,75],skeel:67,ski:52,skin:52,skip:[5,21,60,64,70],skipblank:64,skipchar:64,skipstart:64,skull:52,slant:52,slash:52,sleep:[48,52,70],sleepi:52,slice:[14,43,46,52,56,67,68],slicedim:56,slight:54,slightli:[21,23,29,30,39,42,46,49,51,54,59,64,68],slope:52,slot:[26,29,39,52,61],slot_machin:52,slow:[14,20,36,46],slowdown:46,slower:[2,4,20,24,33,36],slowest:14,slowli:46,slt_int:46,small:[5,20,24,25,28,35,44,45,46,52,56,68,74,76],small_blue_diamond:52,small_orange_diamond:52,small_red_triangl:52,small_red_triangle_down:52,smaller:[5,10,33,46,51,52,59,68,76],smallest:[20,29,33,57,59,67,68,69],smallin:52,smallni:52,smart:45,smash:52,smashtim:52,smblkdiamond:52,smblklozeng:52,smblksquar:52,smc:17,smeparsl:52,smile:52,smile_cat:52,smilei:52,smiley_cat:52,smiling_imp:52,smirk:52,smirk_cat:52,smoke:52,smooth:68,smoothli:[40,44],smt:52,smte:52,smwhitestar:52,smwhtcircl:52,smwhtlozeng:52,smwhtsquar:52,snail:52,snake:52,snapshot:47,sneaki:16,snippet:[28,41],snow:52,snowboard:52,snowflak:52,snowman:52,sob:52,soccer:52,sock:[42,64],socket:[42,45,62,64,70],soft:52,softwar:[33,44,49,52],sold:27,solid:30,solidu:52,solut:[23,35,44,45,46,48,67,68],solv:[24,39,50,54,67],solve_tvar_constraint:16,solver:67,some:[1,2,3,4,5,8,9,10,14,16,17,20,21,23,24,25,26,27,28,29,30,33,35,36,38,39,40,41,43,44,45,46,47,48,49,50,51,53,54,55,56,57,59,62,64,65,67,68,69,70,74],some_arrai:28,some_complicated_th:21,some_different_th:21,some_old_valu:28,some_other_valu:28,some_specific_typ:28,some_valu:28,some_young_valu:28,somebodi:41,somefunct:29,someon:[23,26,44],someotherfunct:29,someth:[2,3,4,16,20,25,27,28,29,36,39,42,43,44,46,48,49],sometim:[4,20,23,24,25,26,28,29,30,36,39,40,41,45,46,47,51,53,57,60,67],somewhat:[16,24,42,46,49,51,54],somewher:[4,45,50],soon:[45,50,52,57],sooner:45,sophist:[23,25,30,39,43,48],sorri:26,sort:1,sortcol:74,sortedbi:[47,72],sortingalgorithm:44,sortperm:74,sortrow:74,sound:52,sourc:[2,5,6,15,17,27,28,29,31,36,39,41,44,46,47,49,51,52,54,56,57,58,64,70,72,76],source_path:41,sout:52,south:52,space:[4,6,14,16,20,24,35,38,43,44,47,48,49,50,52,56,64,67,68,73,75],space_invad:52,spade:52,spadesuit:52,spaghetti:52,span:[45,56,67],sparam:10,sparkl:52,sparkler:52,sparkling_heart:52,sparsearrai:35,sparsematrix:[35,40,50],sparsematrixcsc:[14,20,40,67],sparser:33,sparsevec:56,sparsiti:20,spawn:[31,45,48,57,70],spawnat:[45,46,70],spdiagm:56,speak:[3,14,16,36],speak_no_evil:52,speaker:[49,52],specfunctionobject:4,special:[1,4,9,10,13,14,16,20],specif:[1,4,5,6,12,14,16,20],specifi:[3,8,9,14,16,20,21,23,24,25,26,29,30,31,33,35,38,39,40,41,42,43,44],specific:67,spectral:37,spectrum:67,spectyp:4,speech:[52,67],speech_balloon:52,speed:[6,36,45,47,52,64,67,69],speedboat:52,speedup:[46,64],spell:54,spend:68,spent:47,spey:[20,56],spheric:52,sphericalangl:52,sphericalangleup:52,spiral:52,splash:52,splat:3,splice:[30,39,50,59,73],split:14,splitdir:62,splitdriv:62,splitext:62,spoil:23,spoke:52,spone:[20,56],spot:[4,46,47],spout:52,spqr:67,sprand:[20,56,67],sprandbool:[20,56],sprandn:[20,56],spring:52,sprint:64,sprintf:[64,68],spuriou:17,spzero:[20,56],sqcap:52,sqcup:52,sqlozeng:52,sqrint:52,sqrt:[20,22,24,28,29,30,33,34,38,43,46,47,51,52,53,67,68,69],sqrt_second:24,sqrtbottom:52,sqrtm:[37,67],sqsubset:52,sqsubseteq:52,sqsubsetneq:52,sqsupset:52,sqsupseteq:52,squar:[20,22,24,28,29,35,37,38,43,45,46,52,59,67,68],squarebotblack:52,squarecrossfil:52,squarehfil:52,squarehvfil:52,squarellblack:52,squarellquad:52,squarelrquad:52,squareneswfil:52,squarenwsefil:52,squaresvector:35,squaretopblack:52,squareulblack:52,squareulquad:52,squareurblack:52,squareurquad:52,squarevfil:52,squeez:56,squiggl:52,squoval:52,srand:69,src:[2,5,8,13,44,49,56,58,62,67,71],ssa:[1,58],ssh:[31,44,45,70],sshflag:[45,70],sshmanag:[45,70],ssize_t:[21,58],sspreq:12,ssr:67,stabil:[29,46,50,74,75],stack:[1,4,6,24,28,46,56,57,64],stackoverflowerror:57,stage:[1,4,5,21,44,48,57],stai:44,stand:[5,16],standalon:41,standard:[12,13,14,16],star2:52,star:[45,52],starequ:52,start:[1,2,3,4,5,6,9,12,14,15,16,18,20,24,26,28,29],startpath:62,startswith:75,stat:[44,62,67],state:[4,6,16,23],statement:[1,3,9,12],static_typeof:1,station:52,statist:[29,43,47,67],statistician:68,statstruct:[57,64],statu:[12,24],statue_of_liberti:52,std:[13,35,68],stdcall:21,stderr:[4,13,48,57,60,64,65],stderr_fileno:13,stdin:[13,42,48,57,60,64],stdio:[4,6,7],stdm:68,stdout:[13,29,41,42,45,47,48,57,60,64,65,72],stdout_fileno:13,steam:52,steam_locomot:52,stebz:67,stefan:44,stefankarpinski:44,stegr:67,stein:67,stem:52,step:[2,4,5,8,16,23,28,39,41,44,45,46,50,59,61,64,68,69],steprang:[20,26,61],sterl:52,stev:67,stew:52,stewart:67,stick:50,sticki:62,stigma:52,stile:52,still:[4,13,23,24],stirl:56,stmt1:1,stmt2:1,stone:52,stop:[20,24,26,47,52,56,57,61,68,70,72],storag:[6,10,14],store:[1,6,10,12,14,15,20,21,23,24,26,27,28,29,41,45,46,47,48,50,51,52,53,54,56,57,58,59,64,67,68,70,72],stori:23,str:[4,10,13,28,39,49,57,64,69,75],strace:2,straight:[46,52,67,68],straight_rul:52,straightforward:[16,26,31,49],straightforwardli:14,strang:30,strange_two:46,strategi:[8,14,44],strawberri:52,strcmp:4,stream:[1,4,6,13,18],streamer:52,street:26,strength:[42,47],strerror:65,strftime:65,stri:34,strict:[23,25,27,46],stricter:24,strictli:[16,24,25,43,52,57],stride1:14,stride:[3,14,20,34,46,56,67],stridedarrai:34,stridedmatrix:[20,34,67],stridedvecormat:34,stridedvector:[20,34],stringmim:[34,64],strip:[8,34,44,49,75],stripcc:75,stripignor:75,stripmark:75,strn:52,stroke:52,strong:36,strongest:39,strongli:[21,28,38,44,48,52],strptime:65,struck:52,struct:[1,4,5,6,10,16],structinfo:57,structur:[1,5,12,18,20,21,23,25,35,37,39,40,43,44,46,51,56,57],strwidth:75,stuck:52,stuck_out_tongu:52,stuck_out_tongue_closed_ey:52,stuck_out_tongue_winking_ey:52,studi:8,style:[12,14,18,20,21,24,30,32,34,39,41,43,46,49],sub2ind:[14,39,56],sub2ind_gen:39,sub2ind_gen_impl:39,sub2ind_loop:39,sub2ind_rec:39,sub:[14,20,56,67,70],subarrai:7,subarray2:14,subclass:[40,64],subdiagon:67,subdivid:[51,68],subedot:52,subexpress:[1,24,27,39],subgroup:52,subject:[23,33,38,47,67],submatric:67,submatrix:67,submit:[17,44],submodul:41,submult:52,subscript:[35,46,52,56],subsequ:[5,26,29,30,35,39,40,41,49,53,56,59,68,69,70,72],subset:[16,21,25,30,47,52,53,56,59,67,68,75],subsetapprox:52,subsetdot:52,subseteq:52,subseteqq:52,subsetneq:52,subsetneqq:52,subsetplu:52,subsim:52,subsitut:49,subspac:67,substanti:[29,46,47],substitut:[21,28,34,39,49],substitutionstr:75,substr:[34,43,49,75],subsub:52,subsup:52,subtl:[17,42],subtleti:[33,54,57],subtract:[25,27,29,38,39,68],subtyp:12,succ:52,succapprox:52,succcurlyeq:52,succe:[23,49,52],succeed:[16,67],succeq:52,succeqq:52,success:[14,23,42,57,66,67,70,76],successfulli:[4,23,24,44,45,48,57,66],succinctli:[26,46],succnapprox:52,succneq:52,succneqq:52,succnsim:52,succsim:52,suffer:46,suffic:[22,46,51],suffici:[11,25,40,51],suffix:[38,43,44,75],sugar:43,suggest:[8,21,44,46,47,50,59],suitabl:[5,58,69],suitespars:67,suitesparse_long:67,sum:[23,25,35,43,45,46,47,52,56,57,59,67,68,69],sum_kbn:[50,56],sumab:59,sumabs2:[59,68],sumfoo:46,sumint:52,summar:[37,46,57],summarys:57,summat:[52,56],summedarrai:23,summer:26,sun:[52,61],sun_with_fac:52,sundai:[26,61],sunflow:52,sunglass:52,sunni:52,sunris:52,sunrise_over_mountain:52,sunset:52,supdsub:52,supedot:52,superdiagon:67,superfici:29,superscript:52,superset:52,supertyp:[34,35,51,57],suphsol:52,suphsub:52,supmult:52,supp:17,support:[1,13,14,16,17,20,21,22,24,26,27,28,29,30,33,35,36,38,39,41,43,44,45,48,49,50,51,56,57,62,64,65,67,68,69],suppos:[21,23,24,29,41,44,48,51],supset:52,supsetapprox:52,supsetdot:52,supseteq:52,supseteqq:52,supsetneq:52,supsetneqq:52,supsetplu:52,supsim:52,supsub:52,supsup:52,surd:52,sure:[8,14,20,21,24,28,41,42,44,64,71],surfer:52,surpris:[16,29,33,38,46,47],surprisingli:[39,45,51],surrend:45,surround:[5,21,39,51],surviv:28,suscept:50,sushi:52,suspect:46,suspend:[24,45,70],suspens:[23,52],suspension_railwai:52,svd:[37,43,45,46,67],svdfact:67,svdval:[37,67],svec:[12,16],sven:67,svn:8,swap:[68,69],swarrow:52,sweat:52,sweat_drop:52,sweat_smil:52,sweep:29,sweet:52,sweet_potato:52,swimmer:52,swirl:52,syconv:67,syev:67,syevr:67,sygvd:67,sylvest:67,sym:[27,39,40,66],symbol:[1,2,3,4,6,9,10,12,16,21,24,25,27,29,30,34],symbolnod:1,symdiff:59,symlink:62,symm:67,symmetr:[24,37,56,59,67],symmetri:[25,37,68],symperm:56,symptom:2,symtridiagon:[37,40,67],symv:67,sync:[29,45,46,64,70],synonym:[21,75],syntact:[1,33,38,39,41,43,57],syr:67,syring:52,syrk:67,sys0:4,syscal:4,sysfunc:58,sysimag:31,sysimg_path:15,system:[1,2],systemat:44,systemerror:[24,57,58],sysv:67,sytr:67,sytrf:67,sytri:67,t_interpret:47,tabl:[2,6,12,16,20,21,27,37,43,52,54,57,59,67],tack:52,tackl:[14,49],tada:52,tag:[4,5,6,10,21],tail:[39,48,52],take:[4,5,12,15,16,17,20,21,22,23,24,25,26,27,28,29,30,31,33,35,38,39,40,41,42,43,44,45,46,47,50,51,52,57,58,59,61,64,67,68,70,72,76],take_ownership:58,takebuf_arrai:64,takebuf_str:64,taken:[3,24,31,38,40,43,45],talk:7,tan:[20,38,68],tanabata:52,tanabata_tre:52,tand:[20,38,68],tangent:68,tangerin:52,tanh:[20,38,68],taocp:68,taper:52,target:[1,15,31,33,46,47,62],task:[4,5,6,15,18],task_local_storag:[24,70,76],taskhdl:24,tast:44,tau:[52,67],taup:67,tauq:67,tauru:52,taxi:52,tbaa:8,tcpserver:[42,64],tcpsocket:[42,64],tea:52,teacup:52,tear:52,teardrop:52,teaser:46,technic:[20,23,27,29,31,34,56,64,68],techniqu:[4,29,30,36,46,47,68],technolog:40,tediou:39,tedium:46,telephon:52,telephone_receiv:52,telescop:52,televis:52,tell:[1,27,28,40,44,49,51,57,65,70,75],teller:52,tempdir:62,templat:51,tempnam:62,tempor:[26,61],temporari:[13,20,29,39,46,48,55,62,74],temporarili:[24,57,58,62],tempt:50,ten:[39,52],tend:[20,38,47,50,68],tenni:52,tensor:[45,67],tent:[47,52],term:[2,3,5,14,16,22,23,25,26,30,35,39,40,41,48,49,51],termin:[21,24,28,34,42,43,44,45,49,57,61,70,75],terminolog:[21,23],ternari:[21,24],terribl:48,territori:44,ters:[24,30,39],tesh:52,test:[2,4,10,16],test_approx_eq:76,test_approx_eq_ep:76,test_handl:76,test_throw:76,testabl:50,testcb:70,testsocket:42,text:[26,27,31,34],text_str:75,textasciiacut:52,textasciicaron:52,textasciidieresi:52,textasciimacron:52,textbrokenbar:52,textdisplai:64,textdoublepip:52,textexclamdown:52,texthvlig:52,textnrleg:52,textnumero:52,textonehalf:52,textonequart:52,textordfeminin:52,textordmasculin:52,textpertenthousand:52,textperthousand:52,textphi:52,textquestiondown:52,textquotedblleft:52,textquotedblright:52,texttheta:52,textthreequart:52,texttildelow:52,texttrademark:52,textturnk:52,textual:[39,64],textvisiblespac:52,tgsen:67,than:[1,2,14,16,17,20,21,22,23,24,25,26,27,28,29,30,31,33,35,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,56,57,59,62,64,67,68,69,70,74,75],thank:[33,51],thankfulli:26,thanksgiv:26,the_except:1,thei:[1,5,16,20,21,22,23,24,25,26,29,30,33,35,36,39,40,41,43,44,45,46,48,49,50,51,52,53,54,56,57,58,59,64,67,69,70,71,74,75],them:[5,14,16,20,21,22,23,24,25,27,29,30,33,37,38,39,41,43,44,45,46,47,48,49,50,51,54,57,59,64,67,68,69,70,71],themselv:[12,23,30,36,41,45,49,51,59],theori:[16,29,51],therebi:[15,23,30,41,45,51,74],therefor:[5,8,12,14,16,20,21,23,25,30,37,39,43,45,46,49,50,51,52,54,55,59,64,67,68],therein:41,thereof:[12,51,70],theta:52,thi:[1,2,3,4,5,6,8,9,10,11,12,13,14,15,16,17,20,21,22,23,24,25,26,27,28,29,30,31,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,56,57,58,59,61,62,64,65,66,67,68,69,70,71,72,74,75,76],thickspac:52,thin:[28,52,67],thing1:41,thing2:41,thing:[14,16,17,23,26,27,28,29,39,42,44,45,46,48,49,50,51,54,68,74],think:[2,24,25,26,29,42,45,51],thinspac:52,third:[3,14,20,23,25,26,30,38,40,47,49,52,56,68,75],thirti:52,this_function_does_not_exist:28,thiscal:21,thisindex:14,thorn:52,those:1,though:[6,14,16,21,22,25,26,28,30,35,40,42,43,44,47,51,57,67,75],thought:[29,45,51,52],thought_balloon:52,thousand:52,three:[14,16,21,24,30,33,35,38,39,40,41,44,45,46,48,49,50,51,52,54,64,67,68,75,76],threearg:29,threedangl:52,threeunderdot:52,threshold:[25,67],through:[4,5,6,13,16],throughout:[13,23,35,50,51],throughput:48,thrown:[21,23,24,25,28,49,50,51,57,64,67,70],thu:[20,21,23,25,26,29,33,38,39,40,42,45,46,49,50,51,54,59,61],thumb:[46,52],thursdai:[26,61],ti1:40,ti2:40,tic:[43,46,57],ticket:52,tidi:44,tie:[23,52],tieconcat:52,tiger2:52,tiger:52,tight:[46,57],tightli:[22,38,52,56],tild:[52,62],tildetrpl:52,tile:52,till:[45,70],time:[1,2,3,4,5,6,14,15,17,18,20,21,24,26,27,28,29,30,31,36,37,38,39,40,41,43,44,45],time_n:57,timedout:64,timedwait:70,timeit:46,timelimit:68,timelin:[26,61],timeout:[64,70],timeout_:64,timer:[57,64],timesbar:52,timestamp:62,timestep:46,timestr:65,timev:57,timezon:[26,61,65],tini:[45,46],tip:0,tire:52,tired_fac:52,titl:[57,67],titlecas:75,tmp:[15,44,47,55,64],tmstruct:65,to_funct:4,toc:[43,46,57],todai:[29,61],todo:6,toea:52,tofirst:61,togeth:[5,23,24,25,27,31,34,39,40,41,45,47,49,50,57,74,75],toggl:59,toi:[35,45],toilet:52,token:[5,44,75],tokyo:52,tokyo_tow:52,tol:[25,67,68,76],tolast:61,told:21,toler:[25,57,67,68,76],tomato:52,tona:52,tone:52,tonext:[26,61],tongu:52,too:[3,10,13,27,28,30,35,39,43,44,45,46,57,64],took:[29,57],tool:[2,8,17,39,44],top:[8,10,12,21,33,35],topbot:52,tophat:52,topic:[24,33,34,57],toplevel:[1,5,6,27,46],topmost:64,topnod:1,toprev:[26,61],topsemicircl:52,toq:57,torch:52,tosa:52,total:[44,45,47,57,61,64,68,74],touch:62,towa:52,toward:[2,25,33,38,68],tower:52,trace:[4,17,67],track:[2,5,8,10,24,31,35,44,45,46,47,57,70,72],tractor:52,trade:[36,52],trademark:52,tradit:[22,30,36,40,49,51,64,75],tradition:[25,30,36,51],traffic:[45,52],traffic_light:52,trai:52,trail:[20,21,30,31,34,49,51,56,64,69,75],trailing_on:69,trailing_zero:69,train2:52,train:52,tram:52,tramwai:52,tran:67,trang:45,transa:67,transact:67,transb:67,transfinit:52,transform:[5,20,23,30,39,43,56,57,59,67,68,70,74,75],transit:26,translat:6,transpar:[10,29,49],transpos:[20,30,34,35,56,67,73],transposit:[43,67],transvers:52,trap:29,trapezium:52,trapezoid:67,trash:71,travers:57,travi:[44,71],trcon:67,treat:[20,21,39,43],tree:[2,5,12,27,28,39,44,47,52,56,72,76],trend:52,trevc:67,tri:[5,21,26,28,57,64],trial:[45,46],triangl:[30,38,52,67],trianglecdot:52,triangledown:52,triangleleft:52,triangleleftblack:52,trianglelefteq:52,triangleminu:52,triangleplu:52,triangleq:52,triangleright:52,trianglerightblack:52,trianglerighteq:52,triangletim:52,triangular:[37,40,52,56,67],triangular_flag_on_post:52,triangular_rul:52,trick:51,tricki:[26,38],trickier:41,trident:52,tridiag:40,tridiagon:[37,40,67],trigamma:68,trigger:[12,16,21,47,57,70],tril:67,trip:[5,43,46],tripl:[1,43],tripleplu:52,triu:[56,67],triumph:52,trivial:[29,44,45,46],trmm:67,trmv:67,trolleybu:52,trophi:52,tropic:52,tropical_drink:52,tropical_fish:52,troubl:[45,49,50],trrf:67,trsen:67,trsm:67,trsv:67,trsyl:67,trtr:67,trtri:67,truck:52,trumpet:52,trunc:[20,21,38,46,61,68],truncat:[14,21,25,38,46,47,61,64,68],try_block:1,trypars:69,tst:55,ttl:64,tty:[6,13,42,64],tty_col:[47,72],tue:[26,61],tuesdai:[26,61],tulip:52,tunnel:[45,70],tupl:[1,3,4,8,9,10,12,14],tuple2:51,turban:52,turn:[1,5,9,21,23,24,26,31,41,46,47,49,51,52,57,58,67],turnangl:52,turnediota:52,turnednot:52,turnstil:52,turtl:52,tutori:31,tv1:40,tv2:40,tvar:16,twelv:52,twice:[38,47],twist:52,twisted_rightwards_arrow:52,twister:69,two:[1,4,10,14,16,20,21,23,24,25,26,27],two_heart:52,two_men_holding_hand:52,two_women_holding_hand:52,twocap:52,twocup:52,twoheaddownarrow:52,twoheadleftarrow:52,twoheadleftarrowtail:52,twoheadleftdbkarrow:52,twoheadmapsfrom:52,twoheadmapsto:52,twoheadrightarrow:52,twoheadrightarrowtail:52,twoheaduparrow:52,twoheaduparrowcircl:52,twonot:52,twostep:39,txt:[42,47,48,57,64],typ:[39,57],type1:57,type2:57,type_goto:1,type_intersection_match:16,type_match:16,type_match_morespecif:16,type_morespecif:16,typea:43,typealia:[21,27,51],typeassert:[21,51],typeb:43,typecheck:46,typed_comprehens:1,typed_dict_comprehens:1,typed_hcat:1,typed_vcat:1,typedef:[10,16,21],typeerror:[24,51,57],typeinf:[5,47],typeintersect:[16,57],typejoin:[16,57],typeless:36,typemax:[29,33,47,57,64,69,72],typemin:[29,33,57,69],typesof:12,typic:[2,5,9,10,17,20,21,22,23,24,25,28,30,33,35,36,40,41,43,45,47,49,50,51,56,57,58,64,67,68,69,71,74],typo:44,tzrzf:67,u10ffff:49,u110000:49,u2200:[39,49],u2203:49,u5272:52,u5408:52,u55b6:52,u6307:52,u6708:52,u6709:52,u6e80:52,u7121:52,u7533:52,u78:49,u7981:52,u7a7a:52,u80:49,uax:75,ucfirst:75,udp:64,udpsocket:64,uff:49,uglier:46,uid:[16,57,62],uint128:[33,40,43,51,69],uint128_str:1,uint16:[21,25,33,40,43,51,58,64,69,75],uint16_t:10,uint32:[21,33,38,40,43,51,56,58,69,75],uint32_t:[6,10],uint64:[21,33,40,43,51,57,58,69],uint8:[16,21,25,33,38,40,42,43,46,49,50,51,57,58,64,69,75],uint8_t:6,uint:[21,33,51,57,58],uintmax_t:[21,58],ularc:52,ulblacktriangl:52,ulcorn:52,ull:43,ultim:[23,24,29,64],ultriangl:52,umbrella:[51,52],umfpack:37,umfpacklu:[37,67],uminu:52,unabl:[4,24],unalloc:64,unalt:49,unambigu:51,unamus:52,unannot:12,unari:[20,33,38,68],unassign:[23,75],unavoid:[41,44,45],unawar:26,unbalanc:45,unbind:29,unbound:[16,29,69],unbox:[5,8,10,28],uncaught:24,uncertain:46,uncertainti:[46,47],unclear:43,uncommon:44,uncondit:1,uncondition:46,unconnect:[45,70],unconstrain:[40,51],undecor:27,undefin:[10,16,21,23,30,35,38,39,40,45,50,57,58,59,70],undefreferror:[16,23,24,57],undefvarerror:[24,39,54,57],under:[4,14,16],underag:52,underbar:52,underbrac:52,underbracket:52,underdot:52,underflow:[29,68],undergo:2,underleftarrow:52,underleftharpoondown:52,underli:[14,16,20,21,26,29,33,42,45,46,58,64,67],underneath:67,underrightarrow:52,underrightharpoondown:52,underscor:[21,33,50,53],understand:[10,12,16,24,25,33,36,39,41,45,47],undesir:48,undo:68,unduli:51,unequ:57,unescap:[49,64,75],unescape_str:75,unevenli:56,unexpect:[24,26,46,53,56,67],unexpectedli:[2,17,20,29,46,51],unfamiliar:33,unfortun:[14,29,46],unhappi:29,unicod:[18,30,32,34,36],unicodeerror:[24,49],unifi:[13,36,52],uniform:[13,14],uniformli:[14,20,69],uniformsc:[37,40,67],unimpl:21,uniniti:[20,21,23,29,56,64,70],uninterpret:21,unintuit:[24,36],uninvit:23,uniqu:[4,10,16,22,34,39,40,41,44,47,56,57,59,62,67,68],uniquedbyid:41,unit:[11,18,38,43,46,52,63,67,69],unitari:[67,68],unitlowertriangular:40,unitrang:[14,46,50,56,59,67],unituppertriangular:40,univers:[16,52],universaldeclarationofhumanrightsstart:53,unix2datetim:61,unix:[21,42,44,45,47,48,57,61,62,71],unknown:[8,10,21,51,68],unless:[15,21,41,44,46,47,48,49,50,53,54,56,57,61,69,70,72,74,75],unlik:[1,16,20,24,29,35,38,43,45,48,49,51,54,58],unlimit:51,unlock:[29,52,70],unmark:64,unmatch:75,unmodifi:[43,62,67,74],unnam:[21,30,58],unnatur:36,unnecessari:[26,27,33,42,46,49],unnorm:68,unobtrus:[36,51],unord:[57,59,68],unpermut:67,unpin:44,unpreced:36,unpredict:[29,45,57,70],unquot:[12,39,43,49],unrel:[41,49],unrol:[29,39],unsaf:[10,21,31],unsafe_convert:[20,21,58],unsafe_copi:58,unsafe_load:[21,50,58],unsafe_pointer_to_objref:[21,58],unsafe_stor:[21,58],unsafe_trunc:68,unscal:67,unset:57,unsettl:29,unshift:59,unsign:[21,33,38,43,51,58,68,69],unsort:20,unspecifi:[23,46,59,68,70],unstabl:[29,46,49],unsupport:[21,39],until:[5,13,16,21,23,24,40,44,45,51,61,64,68,70],unus:1,unusu:[44,46],unwant:50,unwind:[3,6,24],upand:52,uparrow:52,uparrowbar:52,upcom:41,updasharrow:52,updat:[28,29,34,35],updownarrow:52,updownarrowbar:52,updownharpoonleftright:52,updownharpoonrightleft:52,upepsilon:52,upequilibrium:52,uperm:62,upgrad:[44,71],upharpoonleft:52,upharpoonright:52,upharpoonsleftright:52,upin:52,upint:52,upkoppa:52,uplo:67,upload:44,uplu:52,upmu:52,upnu:52,upoldkoppa:52,upomicron:52,upper:[16,37,44,49,52,53,56,67,68,75],uppercas:[21,42,49,75],uppertriangular:[37,40,67],upsampi:52,upsilon:52,upstigma:52,upstream:44,upuparrow:52,upvarbeta:52,upward:52,upwhitearrow:52,uranu:52,urarc:52,urblacktriangl:52,urcorn:52,url:[44,62,67,71],urtriangl:52,usa:44,usabl:[4,5,51],use64bitint:2,use_llvm_shlib:8,use_mmap:64,usefulli:4,user:[5,8,14,15,17,20,23,24,25,26,27,29,30,31,33,34,36,39,41,43,44,45,46,47,48,49,50,51,52,53,57,61,62,64,67,68,70,72,75,76],userdata:45,userimg:[15,41],userimg_path:15,usernam:44,usr:[2,4,8,28,49],usual:[4,8,20,22,23,26,27,30,36,38,42,44,46,47,50,54,56,57,64,67,68,69],ut1:26,utc:[2,31,34,61],utf16:[21,44,49,75],utf16str:[34,49,75],utf32:[21,49,75],utf32str:[49,75],utf8:[31,49,53,59,75],utf8str:[26,34,42,49,59,75],utf:[21,36],util:[8,39,41,51],utinst:[26,61],uuparrow:52,uv_async_send:21,uv_handle_typ:13,uv_handle_type_max:13,uv_stream_t:13,uv_writ:[6,13],uvw:13,va_arg:21,va_list:13,vagu:20,val1:1,val2:1,val:[11,21,28,39,43,51,56,57,67,68,70],valgrind:0,valid:[1,13,15,21,23,25,26,28,29,33,35,38,41,43,44,49,50,51,53,56,57,58,59,62,65,66,67,68,69,72,75],valtyp:59,valu:[1,3,4,5,6,10,13,14,16,20,21,22,23,24,25,26,27,28],value1:[43,54],value2:43,value3:54,value_t:4,valuetodayofweek:26,valuetomonth:26,valuetyp:59,van:67,var1:[1,54],var2:[1,54],var3:54,var_sym:39,vararg:[1,16,21],varcarriagereturn:52,varclubsuit:52,vardiamondsuit:52,vardim:68,vardoublebarwedg:52,varepsilon:52,varheartsuit:52,varhexagon:52,varhexagonblack:52,varhexagonlrbond:52,vari:[29,34,64,67],variabl:[1,3],variablenam:43,variad:21,varianc:68,variant:[21,27,38,46,49,52,64,67,68,72,74],varieti:[12,24,25,51],varinfo:1,variou:[5,6,10,21,24,25,31,37,40,42,44,45,48,49,51,57,68,75],varisin:52,varisinobar:52,varkappa:52,varlrtriangl:52,varm:68,varni:52,varniobar:52,varnoth:52,varointclockwis:52,varphi:52,varpi:52,varrho:52,varsigma:52,varspadesuit:52,varstar:52,varsubsetneqq:52,varsupsetneq:52,vartheta:52,vartriangl:52,vartriangleleft:52,vartriangleright:52,varveebar:52,vast:[39,41],vastli:15,vcat:[1,20,30,43,56],vdash:52,vdot:52,vec:[29,46,52,56],vecdot:67,vecnorm:[67,68],vect:1,vector:[1,8],vectorize_1arg:20,vectorize_2arg:20,vee:52,veebar:52,veedoublebar:52,veeeq:52,veemidvert:52,veeodot:52,vehicl:52,veil:52,vendredi:26,venu:52,ver:71,verbatim:39,verbos:[4,39,49,57],verbose_fussy_sqrt:24,veri:[1,2,5,9,14,16,23,24,25,27,29,35,36,39,40,42,43,44,45,46,47,49,51,52,56,59,68,74],verifi:[21,23,28,44,45,46,56,76],versa:[14,38,57],versioninfo:[2,57],versionnumb:[44,49,71],versionweight:40,versu:[22,46,55],vert:52,vertic:[43,52,56,73],vertical_traffic_light:52,vertoverlai:52,verymuchless:52,via:[5,8,11,16,21,23,27,29,30,31,36,40,41,43,44,45,46,47,48,51,54,55,57,64,67,68,69,70,74,75,76],vibrat:52,vibration_mod:52,vice:[14,38,57],victori:52,video:[31,52,64],video_camera:52,video_gam:52,videocassett:52,view:[4,5,12,14,26,39,41,47,52,56],viewdata:52,viewindex:14,violat:[23,39,51],violin:52,virgo:52,virtual:[1,5,43],visibl:[20,21,24,30,41,43,44,45,54,57,64],visit:[20,56],visual:[1,30,33,44,46,71,75],voic:52,vol:[67,68],volcano:52,voltag:52,volum:[48,52],vrectangleblack:52,vsl:67,vsr:67,vulgar:52,vvdash:52,vvert:52,vwprebuild:40,vwprebuilditem:40,vysmblkcircl:52,vysmblksquar:52,vysmwhtsquar:52,w_in:67,wai:[3,4,5,6,8,13,14,16,17,20,21,23,24,25,27,28,29,31,33,35,36,39,41,42,43,44,45,46,47,49,50,51,52,54,57,64,68,70,74],wait:[2,5,24,29,42,45,46,48,57,64,70],wake:[57,70],walk:[4,52],wane:52,waning_crescent_moon:52,waning_gibbous_moon:52,want:[3,4,5,9,17,21,23,24,25],warm:16,warn:[8,13,17],wast:20,watch:[16,43,52,64],watch_fil:64,water:52,water_buffalo:52,watermelon:52,wave:[46,52],wavi:52,wavy_dash:52,wax:52,waxing_crescent_moon:52,wchar_t:[21,58],wdai:65,weak:[6,59],weakkeydict:59,weakref:41,weari:52,web:44,websit:44,wed:[44,52,61],wedg:52,wedgedot:52,wedgedoublebar:52,wedgemidvert:52,wedgeodot:52,wedgeonwedg:52,wedgeq:52,wednesdai:[26,61],week:[26,40,61],weight:[20,67],well:[5,17,20,24,25,26,27,28,33,34,35,37,38,40,43,44,45,46,47,49,50,51,53,54,56,57,67,68,74],were:[3,4,14,21,23,26,29,30,34,38,40,41,43,47,51,67,74],weren:24,west:52,wget:62,whale2:52,whale:52,what:[2,3,4,5,14,16,23,24,25,26,28],whatev:[5,6,21,39,44,54,71,74],whatsoev:49,wheel:52,wheelchair:52,whenev:[5,10,21,23,24,31,40,41,45,46,57,67],where:[1,3,4,6,8,13,15,16,20,21,22,23,24,26,28,29,30,33,35,36,38,39,40,41,43,44,45,46,47,50,51,54,56,57,58,59,60,61,62,64,66,67,68,69,74,75,76],wherea:[3,14,16,20,39,43,48,49,51,56,64,67,72],wherebi:20,wherein:[45,51],wherev:[13,38,59],whether:[1,5,13,16,22,23,24,25,28,31,33,36,37,38,40,44,46,47,49],which:[1,3,4,5,6,9,10,12,14,15,16,20,21,23,24,25,26,27,28,29,30,33,34,35,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,54,55,56,57,58,59,60,61,62,64,65,66,67,68,69,70,71,72,74,75,76],whichev:[45,56,70],white:52,white_check_mark:52,white_circl:52,white_flow:52,white_large_squar:52,white_medium_small_squar:52,white_medium_squar:52,white_small_squar:52,white_square_button:52,whitearrowupfrombar:52,whiteinwhitetriangl:52,whitepointerleft:52,whitepointerright:52,whitespac:[33,34,39,43,44,49,64,75],whizbang:44,who:[4,21,24,28,29,33,41,44,57,62,72],whoa:40,whole:[5,6,14,20,21,23,41,45,46,49,51,58,68,75],whom:49,whose:[1,23,25,30,38,41,42,45,49,51,57,59,62,64,67,68,75],whthorzov:52,whtvertov:52,why:[2,3,16,24,26],wide:[21,25,44,47,49,52,75],wideangledown:52,wideangleup:52,widebridgeabov:52,widemul:68,widen:[23,57],wider:[20,47],wideutild:52,width:[21,26,30,49,61,72],william:33,willing:29,win32:65,win64:49,wind:[44,52],wind_chim:52,window:[6,15,21,28,42,44,47,57,60,62,64,65],wine:52,wine_glass:52,wing:52,wink:52,winston:44,wint_t:21,wip:44,wise:[29,43,67,68],wish:[9,20,24,44,45,46,56,64,70],with_bigfloat_precis:[33,69],with_handl:76,with_keyword:46,with_output_limit:16,with_round:[33,69],withenv:57,within:[1,4,9,16,20,21,25,29,30,33,39,41,43,44,45,46,49,54,55,56,57,59,64,67,68,70,75],without:[1,3,5,9,10,14,20,21,23,24,27,28,29,30,33,34,37,39,40,41,43,44,45,46,48,49,50,51,52,53,54,55,56,57,59,61,64,67,68,69,70,75],wittingli:15,wizardri:56,woken:[57,70],wolf:52,woman:52,womans_cloth:52,womans_hat:52,women:52,won:[39,41,44,48,51],word:[5,16,25,29,30,33,34,38,39,40,43,44,47,48,50,51,52,53,60,64],word_siz:[2,33,60],work:[3,4,5,6,7],workaround:29,worker:[17,31,45,46,48,52,67,70],workerconfig:[45,70],workflow:[18,29],working_dir:57,workload:45,workspac:[41,54,57],world:[4,6,23,39,42,46,48,49,51,53,75],worri:[21,25,41,42,44,52],wors:[29,54],worth:[11,16,38,45,50,70],would:[3,5,8,14,15,16,17,20,21,23,24,25,26,29,30,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,54,56,57,58,61,64,68,69,74,75],wouldn:29,wrap:[1,21,24,26,28,29,30,33,35,39,43,44,46,50,52,55,57,58,61,67,70],wraparound:[33,57],wrapper:[5,6],wreath:52,wrench:52,wrinkl:23,writabl:[64,70],write:[3,4,6,13,20,21,23,24,25,28],writeal:48,writecsv:64,writedlm:64,writefunc:64,writemim:[27,64],writer:[45,48],written:[1,5,16,20,21,22,24,27,28,29,30,31,34,35,36,38,39,40,41,42,44,45,46,47,48,50,51,57,58,64,65,68,70],wrong:[2,21,24,30,39,41,57],wry:52,wstring:[21,49,75],www:[45,67,68],x7f:49,x80:49,x86:21,x86_64:[2,21,31,34],x_str:1,xarg:28,xcorr:68,xdata:28,xdump:[16,64],xff:[33,39,49],xinc:46,xor:[38,43,52,73],xylophon:[48,49],xyz:57,yank:34,yao:67,ydai:65,year:[26,40,44,57,61,65],yearmonth:[26,61],yearmonthdai:[26,61],yellow:52,yellow_heart:52,yen:52,yet:[9,16,21,24,26,30,33,36,39,40,42,44,46,49,51,57,64,68],yield:[1,21,29,33,46,57,59,64,68,69,70],yieldto:[24,70],yml:[44,71],yogh:52,you:[2,3,4,8,9,10,14,16,17,20,21,22,23,24,25,26,27,28,29,30,31,34,35,36,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,55,56,57,58,59,61,64,65,67,68,69,70,71,72,74,75,76],young:28,your:[2,4,9,17,20,21,23,24,27,29,30,38,39,41,42],yourself:[16,21,23,29,44,46,47],yum:52,yup:52,yyyi:61,yyyymm:26,yyyymmdd:[26,61],zap:52,zbar:52,zero:[3,6,20,21,22,23,24,25,26,28,29,30],zeromq:45,zerox:39,zeta:[20,38,52,68],zigzag:52,zip:[43,57,59,64],zlocal:21,zmat:67,zone:26,zzz:52},titles:[\"Developing/debugging Julia&#8217;s C code\",\"Julia ASTs\",\"Reporting and analyzing crashes (segfaults)\",\"Base.Cartesian\",\"gdb debugging tips\",\"Eval of Julia code\",\"Initialization of the Julia runtime\",\"Documentation of Julia&#8217;s Internals\",\"Working with LLVM\",\"Talking to the compiler (the <code class=\\\"docutils literal\\\"><span class=\\\"pre\\\">:meta</span></code> mechanism)\",\"Memory layout of Julia Objects\",\"Operator-sensitive promotion\",\"Reflection and introspection\",\"printf() and stdio in the Julia runtime\",\"SubArrays\",\"System Image Building\",\"More about types\",\"Using Valgrind with Julia\",\"Julia Documentation\",\"Julia Documentation\",\"Multi-dimensional Arrays\",\"Calling C and Fortran Code\",\"Complex and Rational Numbers\",\"Constructors\",\"Control Flow\",\"Conversion and Promotion\",\"Date and DateTime\",\"Documentation\",\"Embedding Julia\",\"Frequently Asked Questions\",\"Functions\",\"Getting Started\",\"The Julia Manual\",\"Integers and Floating-Point Numbers\",\"Interacting With Julia\",\"Interfaces\",\"Introduction\",\"Linear algebra\",\"Mathematical Operations and Elementary Functions\",\"Metaprogramming\",\"Methods\",\"Modules\",\"Networking and Streams\",\"Noteworthy Differences from other Languages\",\"Packages\",\"Parallel Computing\",\"Performance Tips\",\"Profiling\",\"Running External Programs\",\"Strings\",\"Style Guide\",\"Types\",\"Unicode Input\",\"Variables\",\"Scope of Variables\",\"Workflow Tips\",\"Arrays\",\"Essentials\",\"C Interface\",\"Collections and Data Structures\",\"Constants\",\"Dates and Time\",\"Filesystem\",\"The Julia Standard Library\",\"I/O and Network\",\"C Standard Library\",\"Dynamic Linker\",\"Linear Algebra\",\"Mathematics\",\"Numbers\",\"Tasks and Parallel Computing\",\"Package Manager Functions\",\"Profiling\",\"Punctuation\",\"Sorting and Related Functions\",\"Strings\",\"Unit and Functional Testing\"],titleterms:{\"_start\":6,\"abstract\":[35,46,51],\"break\":46,\"byte\":49,\"case\":[23,25],\"catch\":[24,50],\"default\":[30,41],\"final\":24,\"float\":[33,50],\"function\":[3,4,20,21,24,26,27,28,29,30,38,39,40,46,50,56,57,59,61,67,68,69,71,74,76],\"import\":[1,29],\"new\":[25,44],\"null\":29,\"return\":[21,28,30],\"short\":24,\"static\":50,\"throw\":[24,28],\"try\":[24,50],about:[16,21,50],absolut:[38,41],abstractchannel:45,access:[21,27,28,46,51],accessor:[26,61],accumul:47,address:42,adjust:[26,61],advanc:[27,39],aka:24,algebra:[37,67],algorithm:74,alia:8,alias:51,all:57,alloc:[10,29,46,47],allow:53,along:46,ambigu:40,analysi:[8,47],analyz:2,ani:16,annot:46,anonym:[3,30],append:50,arbitrari:33,argument:[3,21,29,30,40,46,50],arithmet:[26,29,33,38],around:57,arrai:[20,28,29,35,45,46,49,56,70],ask:29,assign:[20,56],associ:59,ast:1,asynchron:29,attent:46,auto:21,automat:28,avail:[44,45],avoid:[46,48,50],background:33,bare:41,base:[3,6,50,55,76],basic:[3,20,39,42,47,49,55,56],behavior:[30,33],beta:29,between:[13,29],bigfloat:69,bind:34,bit:[10,21,51],bitarrai:56,bitwis:38,bla:67,block:[1,30,54],bootstrap:[2,4,5],bottom:16,bracket:1,branch:44,breakpoint:4,broadcast:20,browser:55,build:[4,8,15,28,39],built:24,call:[1,4,21,23,28,29,40],callback:21,caller:50,can:29,care:50,cartesian:[3,14],caveat:17,ccall:21,certain:[4,29],cfunction:21,chain:38,chang:[44,46],channel:45,charact:49,check:51,checkout:44,circuit:24,claus:24,clear:47,cluster:[45,70],clustermanag:45,code:[0,5,13,21,27,39,44,45,50],code_warntyp:46,coeffici:33,collect:[21,45,59],collector:[10,28],column:[20,46],combin:29,combinator:56,command:28,common:49,comparison:[26,38],compat:21,compil:9,complet:34,complex:[22,48],composit:51,compound:24,comprehens:[20,54],compress:20,comput:[45,70],concaten:[20,56],concurr:29,condit:[4,24,50],config:28,configur:47,conflict:33,confus:50,consider:17,consist:50,constant:[21,54,60,61,69],construct:[20,51],constructor:[20,23,26,29,56],contain:[46,50],control:[24,47],convent:[21,50,53],convers:[21,23,25,38,61],convert:28,core:24,coroutin:24,correspond:[20,21],crash:2,creat:[21,44],csc:20,custom:[34,44,45],data:[21,45,59,69],date:[26,61],datetim:26,deadlock:48,debug:[0,4],declar:[29,46,51],defin:[25,40],definit:[5,29,41,46],delet:29,dens:20,deprec:[21,29,46],dequeu:59,descript:44,design:14,detail:[14,44],determin:28,develop:[0,18,44],differ:[8,29,34,43],dimension:20,dirti:44,displai:[4,47],distribut:45,divers:50,divis:[33,38],document:[7,18,19,27,44],doe:29,domainerror:29,don:50,durat:26,dure:[2,4,13,46],dynam:66,editor:55,effect:39,elabor:50,elementari:[37,38],embed:28,empti:40,environ:2,epsilon:33,equal:50,error:[2,24,33,57],essenti:57,eval:[5,6,39],evalu:[24,30,39],event:[24,57],exampl:[28,39,42,48],except:[24,28],excess:50,execut:[5,44,46],exist:44,expans:5,experiment:45,expos:50,expr:1,express:[3,24,39,49],extern:48,factor:37,few:14,field:[14,46,50],file:[4,41,42],filesystem:62,fix:[44,46],flow:24,form:1,format:69,fortran:21,framework:[4,76],free:44,frequent:29,from:[4,43,46],further:30,garbag:[10,21,28,45],gdb:4,gener:[5,17,27,39,40,44,50,57,59,64,69,70],get:[31,57],getindex:14,give:29,global:[21,27,46,54],glossari:2,guid:[21,27,50],guidelin:44,handl:[21,24,50],handler:76,hard:54,heap:59,help:34,high:28,hoc:44,hold:39,how:29,hygien:39,hyperbol:38,imag:[5,15],immut:[29,51],implement:20,importal:29,improv:8,incomplet:23,index:[14,20,35,56,59],indirect:21,infer:5,info:2,inform:24,initi:[6,20,23,41,44,55],initialis:13,inner:23,input:[21,52],insert:4,insid:29,inspect:4,instal:44,instanc:50,integ:[29,33,69],integr:68,inter:29,interact:34,interfac:[8,13,35,50,58,70],intern:[7,16,57],interpol:[39,46,48,49],introduct:[16,36,57],introspect:12,invoc:39,iter:[20,35,59],itself:44,jit:5,jl_atexit_hook:6,jl_std:13,jl_value_t:10,jltype:16,julia:[0,1,2,4,5,6,7,8,10,13,15,17,18,19,21,28,29,32,34,50,63,76],julia_init:6,julia_sav:6,julian:34,just:50,kei:34,kernel:46,keybind:34,keyword:[30,40,46],lambdastaticdata:1,languag:43,lapack:67,layout:10,legaci:13,let:54,level:[28,41,50],librari:[13,18,63,65],libuv:13,like:[40,59],line:28,linear:[14,37,67],linker:66,liter:[33,39,49,50],llvm:[8,58],load:[4,45],local:54,locat:46,log:38,loop:[24,45,54],lower:1,machin:[29,33],machineri:16,macro:[1,3,5,27,39,50,76],main:6,make:44,makefil:28,manag:[28,45,70,71],mani:29,manipul:28,manual:[18,32,44],map:[21,45,64],mark:10,markdown:27,mathemat:[38,56,68],matlab:43,matric:[20,37,56],matrix:[20,37],mean:29,measur:46,mechan:9,memori:[10,21,28,29,46,47,64],messag:24,meta:9,metadata:44,metaprogram:39,method:[4,16,20,23,27,40,50],miscellanea:41,miss:[29,51],mix:29,mode:[33,34],modifi:[21,29,50],modul:[27,29,41],more:[5,16,21],movement:45,mozilla:4,multi:20,multidimension:28,multimedia:64,multipl:[27,30,46],name:[30,44,50,53],namespac:41,nativ:29,network:[42,45,46,64],nightli:29,non:[21,39,49],note:[27,40],noteworthi:43,nothing:29,nullabl:[51,57],number:[1,3,22,33,46,49,69],numer:[33,38,50,68,69],object:[10,27,29,40,51,57],offlin:44,onli:23,oper:[1,11,20,21,24,29,30,37,38,49,50,51,56,68],optim:[8,46],option:[8,30,40,47],order:[46,74],other:43,outer:23,output:[29,46],outsid:29,overflow:33,overli:50,overload:[40,50],overus:50,overview:8,ownership:21,packag:[29,44,45,71],pai:46,parallel:[45,46,70],paramet:[14,28,46,50],parametr:[23,40,51],parenthes:50,pars:5,particular:4,pass:[8,21,29,30],path:41,perform:46,period:[26,61],pin:44,pipelin:48,point:33,pointer:21,possibl:50,post:44,power:38,pre:46,preced:38,precis:33,precompil:41,principl:3,printf:13,priorityqueu:59,process:[4,68],profil:[47,72],program:[39,48],promot:[11,25],prompt:34,publish:44,punctuat:73,python:43,queri:[26,61],question:29,quot:[39,48,49],random:69,ration:[22,23,25],read:30,rebas:44,record:4,refer:[3,21,33,45],reflect:[12,57],regular:49,rel:41,relat:74,releas:29,remot:45,remoteref:45,remov:[29,44],repeat:24,repl:[29,55],replac:14,replai:4,report:2,repositori:44,repres:51,represent:39,requir:44,resolv:42,resourc:31,result:[29,47],root:38,round:[33,38],rule:25,run:[2,17,48],runtim:[6,13],safe:51,safeti:21,same:29,scale:37,schedul:45,scope:[30,54],script:[2,50],search:34,seemingli:29,segfault:2,sensibl:29,sensit:11,separ:46,session:29,set:[16,59],setindex:14,setup:44,share:[45,70],shell:34,sign:38,signal:68,simpl:42,simplifi:55,singleton:[10,51],slurp:29,soft:54,someth:50,sort:[16,74],spars:[20,56],speak:44,special:[21,30,33,37,38],specif:[21,44,50],specifi:45,splat:29,split:29,squash:44,stabl:[29,46],standard:[18,39,41,49,63,65,67,69],start:31,startup:2,state:24,statement:24,statist:68,statu:44,stdio:13,still:29,storag:20,strang:50,stream:[29,42],string:[1,39,46,49,75],struct:21,structur:59,studi:[23,25],style:50,stylist:53,subarrai:14,subnorm:46,subtyp:16,suit:17,summari:[41,44],suppli:3,support:70,suppress:17,surfac:1,symbol:39,synchron:[29,45],syntax:[1,3,21,27,30,33,57],sysimg:[2,6],system:[5,15,21,57],tab:34,tag:44,taken:46,talk:9,task:[24,70],tcp:42,test:[17,76],text:[42,64],those:4,thread:21,through:21,time:[46,61],timetyp:26,tip:[4,46,55],tool:46,top:41,topolog:45,trait:20,translat:[14,21],transport:45,treat:46,trigonometr:38,tripl:49,true_main:6,tupl:[16,51],tweak:46,two:29,type:[1,5,10,14,16,20,21,26,27,28,29,46,50,51,57,61,69],typenam:16,typevar:16,unchang:29,under:17,unicod:[49,52],uniform:37,union:[16,50,51],unit:76,unnecessari:50,unregist:44,unsaf:50,untyp:46,updat:[38,44],upon:4,usag:[3,27,41,47],utf:49,valgrind:17,valu:[29,30,33,38,46,51],vararg:[30,51],variabl:[4,21,27,29,46,53,54],variat:21,vector:20,version:[2,8,29,49],want:29,warn:[24,46],what:29,when:[2,29,50],whether:50,why:[29,39],work:[8,28,29,42],workflow:55,wrapper:13,write:[29,46,50],your:44,zero:[33,46]}})",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/genindex.html": "\n\n\n<!DOCTYPE html>\n<!--[if IE 8]><html class=\"no-js lt-ie9\" lang=\"en\" > <![endif]-->\n<!--[if gt IE 8]><!--> <html class=\"no-js\" lang=\"en\" > <!--<![endif]-->\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  \n  <title>Index &mdash; Julia Language 0.4.5 documentation</title>\n  \n\n  \n  \n\n  \n  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>\n\n  \n  \n    \n\n  \n\n  \n  \n    <link rel=\"stylesheet\" href=\"_static/julia.css\" type=\"text/css\" />\n  \n\n  \n    <link rel=\"stylesheet\" href=\"_static/julia.css\" type=\"text/css\" />\n  \n    <link rel=\"top\" title=\"Julia Language 0.4.5 documentation\" href=\"index.html\"/> \n\n  \n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js\"></script>\n\n</head>\n\n<body class=\"wy-body-for-nav\" role=\"document\">\n\n  <div class=\"wy-grid-for-nav\">\n\n    \n    <nav data-toggle=\"wy-nav-shift\" class=\"wy-nav-side\">\n      <div class=\"wy-side-nav-search\">\n        <a href=\"http://julialang.org/\"><img src=\"_static/julia-logo.svg\" class=\"logo\"></a>\n        <!--\n        <a href=\"index.html\" class=\"fa fa-home\"> Julia Language</a>\n        -->\n        <div role=\"search\">\n  <form id =\"rtd-search-form\" class=\"wy-form\" action=\"search.html\" method=\"get\">\n    <input type=\"text\" name=\"q\" placeholder=\"Search docs\" />\n    <input type=\"hidden\" name=\"check_keywords\" value=\"yes\" />\n    <input type=\"hidden\" name=\"area\" value=\"default\" />\n  </form>\n</div>\n      </div>\n\n      <div class=\"wy-menu wy-menu-vertical\" data-spy=\"affix\" role=\"navigation\" aria-label=\"main navigation\">\n        \n        \n            <ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/introduction.html\">Introduction</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/getting-started.html\">Getting Started</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/getting-started.html#resources\">Resources</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/variables.html\">Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/variables.html#allowed-variable-names\">Allowed Variable Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/variables.html#stylistic-conventions\">Stylistic Conventions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/integers-and-floating-point-numbers.html\">Integers and Floating-Point Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/integers-and-floating-point-numbers.html#integers\">Integers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/integers-and-floating-point-numbers.html#floating-point-numbers\">Floating-Point Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/integers-and-floating-point-numbers.html#arbitrary-precision-arithmetic\">Arbitrary Precision Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/integers-and-floating-point-numbers.html#numeric-literal-coefficients\">Numeric Literal Coefficients</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/integers-and-floating-point-numbers.html#literal-zero-and-one\">Literal zero and one</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/mathematical-operations.html\">Mathematical Operations and Elementary Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/mathematical-operations.html#arithmetic-operators\">Arithmetic Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/mathematical-operations.html#bitwise-operators\">Bitwise Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/mathematical-operations.html#updating-operators\">Updating operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/mathematical-operations.html#numeric-comparisons\">Numeric Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/mathematical-operations.html#numerical-conversions\">Numerical Conversions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/mathematical-operations.html#elementary-functions\">Elementary Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/complex-and-rational-numbers.html\">Complex and Rational Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/complex-and-rational-numbers.html#complex-numbers\">Complex Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/complex-and-rational-numbers.html#rational-numbers\">Rational Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/strings.html\">Strings</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#characters\">Characters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#string-basics\">String Basics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#unicode-and-utf-8\">Unicode and UTF-8</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#triple-quoted-string-literals\">Triple-Quoted String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#common-operations\">Common Operations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#regular-expressions\">Regular Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#id3\">Byte Array Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#version-number-literals\">Version Number Literals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/functions.html\">Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#argument-passing-behavior\">Argument Passing Behavior</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#the-return-keyword\">The <code class=\"docutils literal\"><span class=\"pre\">return</span></code> Keyword</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#operators-are-functions\">Operators Are Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#operators-with-special-names\">Operators With Special Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#anonymous-functions\">Anonymous Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#multiple-return-values\">Multiple Return Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#varargs-functions\">Varargs Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#optional-arguments\">Optional Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#keyword-arguments\">Keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#evaluation-scope-of-default-values\">Evaluation Scope of Default Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#do-block-syntax-for-function-arguments\">Do-Block Syntax for Function Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#further-reading\">Further Reading</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/control-flow.html\">Control Flow</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/control-flow.html#compound-expressions\">Compound Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/control-flow.html#conditional-evaluation\">Conditional Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/control-flow.html#short-circuit-evaluation\">Short-Circuit Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/control-flow.html#repeated-evaluation-loops\">Repeated Evaluation: Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/control-flow.html#exception-handling\">Exception Handling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/control-flow.html#tasks-aka-coroutines\">Tasks (aka Coroutines)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/variables-and-scoping.html\">Scope of Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/variables-and-scoping.html#global-scope\">Global Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/variables-and-scoping.html#local-scope\">Local Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/variables-and-scoping.html#constants\">Constants</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/types.html\">Types</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#type-declarations\">Type Declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#abstract-types\">Abstract Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#bits-types\">Bits Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#composite-types\">Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#immutable-composite-types\">Immutable Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#declared-types\">Declared Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#type-unions\">Type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#man-parametric-types\">Parametric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#type-aliases\">Type Aliases</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#operations-on-types\">Operations on Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#value-types\">&#8220;Value types&#8221;</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#nullable-types-representing-missing-values\">Nullable Types: Representing Missing Values</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/methods.html\">Methods</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#defining-methods\">Defining Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#method-ambiguities\">Method Ambiguities</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#parametric-methods\">Parametric Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#note-on-optional-and-keyword-arguments\">Note on Optional and keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#call-overloading-and-function-like-objects\">Call overloading and function-like objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#empty-generic-functions\">Empty generic functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/constructors.html\">Constructors</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#outer-constructor-methods\">Outer Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#inner-constructor-methods\">Inner Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#incomplete-initialization\">Incomplete Initialization</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#parametric-constructors\">Parametric Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#case-study-rational\">Case Study: Rational</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#constructors-call-and-conversion\">Constructors, Call, and Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#outer-only-constructors\">Outer-only constructors</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/conversion-and-promotion.html\">Conversion and Promotion</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/conversion-and-promotion.html#conversion\">Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/conversion-and-promotion.html#promotion\">Promotion</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/interfaces.html\">Interfaces</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interfaces.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interfaces.html#indexing\">Indexing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interfaces.html#abstract-arrays\">Abstract Arrays</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/modules.html\">Modules</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/modules.html#summary-of-module-usage\">Summary of module usage</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/documentation.html\">Documentation</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/documentation.html#accessing-documentation\">Accessing Documentation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/documentation.html#functions-methods\">Functions &amp; Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/documentation.html#advanced-usage\">Advanced Usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/documentation.html#syntax-guide\">Syntax Guide</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/documentation.html#markdown-syntax-notes\">Markdown Syntax Notes</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/metaprogramming.html\">Metaprogramming</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/metaprogramming.html#program-representation\">Program representation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/metaprogramming.html#expressions-and-evaluation\">Expressions and evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/metaprogramming.html#macros\">Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/metaprogramming.html#code-generation\">Code Generation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/metaprogramming.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/metaprogramming.html#generated-functions\">Generated functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/arrays.html\">Multi-dimensional Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/arrays.html#arrays\">Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/arrays.html#sparse-matrices\">Sparse Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/linear-algebra.html\">Linear algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/linear-algebra.html#matrix-factorizations\">Matrix factorizations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/linear-algebra.html#special-matrices\">Special matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html\">Networking and Streams</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html#basic-stream-i-o\">Basic Stream I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html#working-with-files\">Working with Files</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html#a-simple-tcp-example\">A simple TCP example</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html#resolving-ip-addresses\">Resolving IP Addresses</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/parallel-computing.html\">Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#code-availability-and-loading-packages\">Code Availability and Loading Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#data-movement\">Data Movement</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#parallel-map-and-loops\">Parallel Map and Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#synchronization-with-remote-references\">Synchronization With Remote References</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#scheduling\">Scheduling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#channels\">Channels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#remoterefs-and-abstractchannels\">RemoteRefs and AbstractChannels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#shared-arrays\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#distributed-garbage-collection\">Distributed Garbage Collection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#clustermanagers\">ClusterManagers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#cluster-managers-with-custom-transports\">Cluster Managers with custom transports</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#specifying-network-topology-experimental\">Specifying network topology (Experimental)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/dates.html\">Date and DateTime</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#durations-comparisons\">Durations/Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#accessor-functions\">Accessor Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#query-functions\">Query Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#timetype-period-arithmetic\">TimeType-Period Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#adjuster-functions\">Adjuster Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#period-types\">Period Types</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/running-external-programs.html\">Running External Programs</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/running-external-programs.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/running-external-programs.html#quoting\">Quoting</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/running-external-programs.html#pipelines\">Pipelines</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html\">Calling C and Fortran Code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#creating-c-compatible-julia-function-pointers\">Creating C-Compatible Julia Function Pointers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#mapping-c-types-to-julia\">Mapping C Types to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#mapping-c-functions-to-julia\">Mapping C Functions to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#garbage-collection-safety\">Garbage Collection Safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#non-constant-function-specifications\">Non-constant Function Specifications</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#indirect-calls\">Indirect Calls</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#calling-convention\">Calling Convention</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#accessing-global-variables\">Accessing Global Variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#accessing-data-through-a-pointer\">Accessing Data through a Pointer</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#thread-safety\">Thread-safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#more-about-callbacks\">More About Callbacks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#c\">C++</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#handling-operating-system-variation\">Handling Operating System Variation</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/interacting-with-julia.html\">Interacting With Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interacting-with-julia.html#the-different-prompt-modes\">The different prompt modes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interacting-with-julia.html#key-bindings\">Key bindings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interacting-with-julia.html#tab-completion\">Tab completion</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/embedding.html\">Embedding Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/embedding.html#high-level-embedding\">High-Level Embedding</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/embedding.html#converting-types\">Converting Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/embedding.html#calling-julia-functions\">Calling Julia Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/embedding.html#memory-management\">Memory Management</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/embedding.html#working-with-arrays\">Working with Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/embedding.html#exceptions\">Exceptions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/packages.html\">Packages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#package-status\">Package Status</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#adding-and-removing-packages\">Adding and Removing Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#offline-installation-of-packages\">Offline Installation of Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#installing-unregistered-packages\">Installing Unregistered Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#updating-packages\">Updating Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#checkout-pin-and-free\">Checkout, Pin and Free</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#custom-metadata-repository\">Custom METADATA Repository</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/packages.html#package-development\">Package Development</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#initial-setup\">Initial Setup</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#making-changes-to-an-existing-package\">Making changes to an existing package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#creating-a-new-package\">Creating a new Package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#fixing-package-requirements\">Fixing Package Requirements</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#man-package-requirements\">Requirements Specification</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/profile.html\">Profiling</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/profile.html#basic-usage\">Basic usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/profile.html#accumulation-and-clearing\">Accumulation and clearing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/profile.html#options-for-controlling-the-display-of-profile-results\">Options for controlling the display of profile results</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/profile.html#configuration\">Configuration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/profile.html#memory-allocation-analysis\">Memory allocation analysis</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/performance-tips.html\">Performance Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#avoid-global-variables\">Avoid global variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#measure-performance-with-time-and-pay-attention-to-memory-allocation\">Measure performance with <code class=\"docutils literal\"><span class=\"pre\">&#64;time</span></code> and pay attention to memory allocation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#tools\">Tools</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#avoid-containers-with-abstract-type-parameters\">Avoid containers with abstract type parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#type-declarations\">Type declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#break-functions-into-multiple-definitions\">Break functions into multiple definitions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#write-type-stable-functions\">Write &#8220;type-stable&#8221; functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#avoid-changing-the-type-of-a-variable\">Avoid changing the type of a variable</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#separate-kernel-functions\">Separate kernel functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#access-arrays-in-memory-order-along-columns\">Access arrays in memory order, along columns</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#pre-allocating-outputs\">Pre-allocating outputs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#avoid-string-interpolation-for-i-o\">Avoid string interpolation for I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#optimize-network-i-o-during-parallel-execution\">Optimize network I/O during parallel execution</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#fix-deprecation-warnings\">Fix deprecation warnings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#tweaks\">Tweaks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#performance-annotations\">Performance Annotations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#treat-subnormal-numbers-as-zeros\">Treat Subnormal Numbers as Zeros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#code-warntype\"><code class=\"docutils literal\"><span class=\"pre\">&#64;code_warntype</span></code></a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/workflow-tips.html\">Workflow Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/workflow-tips.html#repl-based-workflow\">REPL-based workflow</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/workflow-tips.html#browser-based-workflow\">Browser-based workflow</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/style-guide.html\">Style Guide</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#write-functions-not-just-scripts\">Write functions, not just scripts</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#avoid-writing-overly-specific-types\">Avoid writing overly-specific types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#handle-excess-argument-diversity-in-the-caller\">Handle excess argument diversity in the caller</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#append-to-names-of-functions-that-modify-their-arguments\">Append <code class=\"docutils literal\"><span class=\"pre\">!</span></code> to names of functions that modify their arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#avoid-strange-type-unions\">Avoid strange type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#avoid-type-unions-in-fields\">Avoid type Unions in fields</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#avoid-elaborate-container-types\">Avoid elaborate container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#use-naming-conventions-consistent-with-julia-s-base\">Use naming conventions consistent with Julia&#8217;s <code class=\"docutils literal\"><span class=\"pre\">base/</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-overuse-try-catch\">Don&#8217;t overuse try-catch</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-parenthesize-conditions\">Don&#8217;t parenthesize conditions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-overuse\">Don&#8217;t overuse ...</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-use-unnecessary-static-parameters\">Don&#8217;t use unnecessary static parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#avoid-confusion-about-whether-something-is-an-instance-or-a-type\">Avoid confusion about whether something is an instance or a type</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-overuse-macros\">Don&#8217;t overuse macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-expose-unsafe-operations-at-the-interface-level\">Don&#8217;t expose unsafe operations at the interface level</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-overload-methods-of-base-container-types\">Don&#8217;t overload methods of base container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#be-careful-with-type-equality\">Be careful with type equality</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#do-not-write-x-f-x\">Do not write <code class=\"docutils literal\"><span class=\"pre\">x-&gt;f(x)</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible\">Avoid using floats for numeric literals in generic code when possible</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/faq.html\">Frequently Asked Questions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#sessions-and-the-repl\">Sessions and the REPL</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#functions\">Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#types-type-declarations-and-constructors\">Types, type declarations, and constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#packages-and-modules\">Packages and Modules</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#nothingness-and-missing-values\">Nothingness and missing values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#memory\">Memory</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#asynchronous-io-and-concurrent-synchronous-writes\">Asynchronous IO and concurrent synchronous writes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#julia-releases\">Julia Releases</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/noteworthy-differences.html\">Noteworthy Differences from other Languages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/noteworthy-differences.html#noteworthy-differences-from-matlab\">Noteworthy differences from MATLAB</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/noteworthy-differences.html#noteworthy-differences-from-r\">Noteworthy differences from R</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/noteworthy-differences.html#noteworthy-differences-from-python\">Noteworthy differences from Python</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/noteworthy-differences.html#noteworthy-differences-from-c-c\">Noteworthy differences from C/C++</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/unicode-input.html\">Unicode Input</a></li>\n</ul>\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/base.html\">Essentials</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#introduction\">Introduction</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#getting-around\">Getting Around</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#all-objects\">All Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#types\">Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#generic-functions\">Generic Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#syntax\">Syntax</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#nullables\">Nullables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#system\">System</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#errors\">Errors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#events\">Events</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#reflection\">Reflection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#internals\">Internals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/collections.html\">Collections and Data Structures</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#general-collections\">General Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#iterable-collections\">Iterable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#indexable-collections\">Indexable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#associative-collections\">Associative Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#set-like-collections\">Set-Like Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#dequeues\">Dequeues</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#priorityqueue\">PriorityQueue</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#heap-functions\">Heap Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/math.html\">Mathematics</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/math.html#mathematical-operators\">Mathematical Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/math.html#mathematical-functions\">Mathematical Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/math.html#statistics\">Statistics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/math.html#signal-processing\">Signal Processing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/math.html#numerical-integration\">Numerical Integration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/numbers.html\">Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/numbers.html#standard-numeric-types\">Standard Numeric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/numbers.html#data-formats\">Data Formats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/numbers.html#general-number-functions-and-constants\">General Number Functions and Constants</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/numbers.html#bigfloats\">BigFloats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/numbers.html#random-numbers\">Random Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/strings.html\">Strings</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/arrays.html\">Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#basic-functions\">Basic functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#mathematical-operators-and-functions\">Mathematical operators and functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#indexing-assignment-and-concatenation\">Indexing, Assignment, and Concatenation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#array-functions\">Array functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#combinatorics\">Combinatorics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#bitarrays\">BitArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#sparse-matrices\">Sparse Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/parallel.html\">Tasks and Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/parallel.html#tasks\">Tasks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/parallel.html#general-parallel-computing-support\">General Parallel Computing Support</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/parallel.html#shared-arrays\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/parallel.html#cluster-manager-interface\">Cluster Manager Interface</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/linalg.html\">Linear Algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/linalg.html#module-Base.LinAlg\">Standard Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/linalg.html#module-Base.LinAlg.BLAS\">BLAS Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/linalg.html#module-Base.LinAlg.LAPACK\">LAPACK Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/constants.html\">Constants</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/file.html\">Filesystem</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/io-network.html\">I/O and Network</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/io-network.html#general-i-o\">General I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/io-network.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/io-network.html#multimedia-i-o\">Multimedia I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/io-network.html#memory-mapped-i-o\">Memory-mapped I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/io-network.html#network-i-o\">Network I/O</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/punctuation.html\">Punctuation</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/sort.html\">Sorting and Related Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/sort.html#sorting-functions\">Sorting Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/sort.html#order-related-functions\">Order-Related Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/sort.html#sorting-algorithms\">Sorting Algorithms</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/pkg.html\">Package Manager Functions</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/dates.html\">Dates and Time</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/dates.html#dates-and-time-types\">Dates and Time Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/dates.html#dates-functions\">Dates Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/test.html\">Unit and Functional Testing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/test.html#testing-base-julia\">Testing Base Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/test.html#test-framework\">Test Framework</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/test.html#handlers\">Handlers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/test.html#macros\">Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/test.html#functions\">Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/c.html\">C Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/c.html#llvm-interface\">LLVM Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/profile.html\">Profiling</a></li>\n</ul>\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"devdocs/reflection.html\">Reflection and introspection</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"devdocs/julia.html\">Documentation of Julia&#8217;s Internals</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/init.html\">Initialization of the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/eval.html\">Eval of Julia code</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/ast.html\">Julia ASTs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/types.html\">More about types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/object.html\">Memory layout of Julia Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/cartesian.html\">Base.Cartesian</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/meta.html\">Talking to the compiler (the <code class=\"docutils literal\"><span class=\"pre\">:meta</span></code> mechanism)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/subarrays.html\">SubArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/sysimg.html\">System Image Building</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/llvm.html\">Working with LLVM</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/stdio.html\">printf() and stdio in the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/promote-op.html\">Operator-sensitive promotion</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"devdocs/C.html\">Developing/debugging Julia&#8217;s C code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/backtraces.html\">Reporting and analyzing crashes (segfaults)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/debuggingtips.html\">gdb debugging tips</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/valgrind.html\">Using Valgrind with Julia</a></li>\n</ul>\n</li>\n</ul>\n\n        \n      </div>\n      &nbsp;\n    </nav>\n\n    <section data-toggle=\"wy-nav-shift\" class=\"wy-nav-content-wrap\">\n\n      \n      <nav class=\"wy-nav-top\" role=\"navigation\" aria-label=\"top navigation\">\n        <i data-toggle=\"wy-nav-top\" class=\"fa fa-bars\"></i>\n        <a href=\"index.html\">Julia Language</a>\n      </nav>\n\n\n      \n      <div class=\"wy-nav-content\">\n        <div class=\"rst-content\">\n          <div role=\"navigation\" aria-label=\"breadcrumbs navigation\">\n  <ul class=\"wy-breadcrumbs\">\n    <li><a href=\"index.html\">Docs</a> &raquo;</li>\n      \n    <li></li>\n      <li class=\"wy-breadcrumbs-aside\">\n        \n      </li>\n  </ul>\n  <hr/>\n</div>\n          <div role=\"main\" class=\"document\">\n            \n\n<h1 id=\"index\">Index</h1>\n\n<div class=\"genindex-jumpbox\">\n <a href=\"#Symbols\"><strong>Symbols</strong></a>\n | <a href=\"#_\"><strong>_</strong></a>\n | <a href=\"#A\"><strong>A</strong></a>\n | <a href=\"#B\"><strong>B</strong></a>\n | <a href=\"#C\"><strong>C</strong></a>\n | <a href=\"#D\"><strong>D</strong></a>\n | <a href=\"#E\"><strong>E</strong></a>\n | <a href=\"#F\"><strong>F</strong></a>\n | <a href=\"#G\"><strong>G</strong></a>\n | <a href=\"#H\"><strong>H</strong></a>\n | <a href=\"#I\"><strong>I</strong></a>\n | <a href=\"#J\"><strong>J</strong></a>\n | <a href=\"#K\"><strong>K</strong></a>\n | <a href=\"#L\"><strong>L</strong></a>\n | <a href=\"#M\"><strong>M</strong></a>\n | <a href=\"#N\"><strong>N</strong></a>\n | <a href=\"#O\"><strong>O</strong></a>\n | <a href=\"#P\"><strong>P</strong></a>\n | <a href=\"#Q\"><strong>Q</strong></a>\n | <a href=\"#R\"><strong>R</strong></a>\n | <a href=\"#S\"><strong>S</strong></a>\n | <a href=\"#T\"><strong>T</strong></a>\n | <a href=\"#U\"><strong>U</strong></a>\n | <a href=\"#V\"><strong>V</strong></a>\n | <a href=\"#W\"><strong>W</strong></a>\n | <a href=\"#X\"><strong>X</strong></a>\n | <a href=\"#Y\"><strong>Y</strong></a>\n | <a href=\"#Z\"><strong>Z</strong></a>\n | <a href=\"#Symbols\"><strong>Symbols</strong></a>\n \n</div>\n<h2 id=\"Symbols\">Symbols</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.!\">!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.!=\">!=() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.!==\">!==() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.$\">$() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.%\">%() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.&\">&amp;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.*\">*() (in module Base)</a>, <a href=\"stdlib/math.html#Base.*\">[1]</a>, <a href=\"stdlib/strings.html#Base.*\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.+\">+() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.-\">-() (in module Base)</a>, <a href=\"stdlib/math.html#Base.-\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..!=\">.!=() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..*\">.*() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..+\">.+() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..-\">.-() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base../\">./() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..<\">.&lt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..<=\">.&lt;=() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..==\">.==() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..\u2260\">.\u2260() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..>\">.&gt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..>=\">.&gt;=() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..\\\">.\\() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..^\">.^() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..\u2264\">.\u2264() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..\u2265\">.\u2265() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base./\">/() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.//\">//() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.:\">:() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.<\">&lt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.<:\">&lt;:() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.<<\">&lt;&lt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.<=\">&lt;=() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.==\">==() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.===\">===() (in module Base)</a>, <a href=\"stdlib/math.html#Base.===\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.\u2260\">\u2260() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.>\">&gt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.>=\">&gt;=() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.>>\">&gt;&gt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.>>>\">&gt;&gt;&gt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/documentation.html#@__doc__\">@__doc__() (built-in function)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@allocated\">@allocated() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@async\">@async() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.@code_llvm\">@code_llvm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@code_lowered\">@code_lowered() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@code_native\">@code_native() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@code_typed\">@code_typed() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@code_warntype\">@code_warntype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@edit\">@edit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@elapsed\">@elapsed() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@eval\">@eval() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.@evalpoly\">@evalpoly() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@everywhere\">@everywhere() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@fetch\">@fetch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@fetchfrom\">@fetchfrom() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@gensym\">@gensym() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@less\">@less() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@linux\">@linux() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@osx\">@osx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@parallel\">@parallel() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.@printf\">@printf() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/profile.html#Base.@profile\">@profile() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@schedule\">@schedule() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@show\">@show() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@spawn\">@spawn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@spawnat\">@spawnat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.@sprintf\">@sprintf() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@sync\">@sync() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@task\">@task() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#Base.Test.@test\">@test() (in module Base.Test)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#Base.Test.@test_approx_eq\">@test_approx_eq() (in module Base.Test)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#Base.Test.@test_approx_eq_eps\">@test_approx_eq_eps() (in module Base.Test)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#Base.Test.@test_throws\">@test_throws() (in module Base.Test)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@time\">@time() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@timed\">@timed() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@timev\">@timev() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@unix\">@unix() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@which\">@which() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@windows\">@windows() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.\\\">\\() (in module Base)</a>, <a href=\"stdlib/math.html#Base.\\\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.^\">^() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.^\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.|\">|() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.|>\">|&gt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.~\">~() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"_\">_</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.__precompile__\">__precompile__() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"A\">A</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.A_ldiv_Bc\">A_ldiv_Bc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.A_ldiv_Bt\">A_ldiv_Bt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.A_mul_B!\">A_mul_B!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.A_mul_Bc\">A_mul_Bc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.A_mul_Bt\">A_mul_Bt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.A_rdiv_Bc\">A_rdiv_Bc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.A_rdiv_Bt\">A_rdiv_Bt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.abs\">abs() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.abs2\">abs2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.abspath\">abspath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Ac_ldiv_B\">Ac_ldiv_B() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Ac_ldiv_Bc\">Ac_ldiv_Bc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Ac_mul_B\">Ac_mul_B() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Ac_mul_Bc\">Ac_mul_Bc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Ac_rdiv_B\">Ac_rdiv_B() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Ac_rdiv_Bc\">Ac_rdiv_Bc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.accept\">accept() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acos\">acos() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acosd\">acosd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acosh\">acosh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acot\">acot() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acotd\">acotd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acoth\">acoth() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acsc\">acsc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acscd\">acscd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acsch\">acsch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.add\">add() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.addprocs\">addprocs() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.addprocs\">[1]</a>, <a href=\"stdlib/parallel.html#Base.addprocs\">[2]</a>, <a href=\"stdlib/parallel.html#Base.addprocs\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airy\">airy() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airyai\">airyai() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airyaiprime\">airyaiprime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airybi\">airybi() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airybiprime\">airybiprime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airyprime\">airyprime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airyx\">airyx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.all!\">all!() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/collections.html#Base.all\">all() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.all\">[1]</a>, <a href=\"stdlib/collections.html#Base.all\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.angle\">angle() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ans\">ans (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.ANY\">ANY (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.any!\">any!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.any\">any() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.any\">[1]</a>, <a href=\"stdlib/collections.html#Base.any\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.append!\">append!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.applicable\">applicable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.apropos\">apropos() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.ARGS\">ARGS (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ArgumentError\">ArgumentError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.Array\">Array() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.ascii\">ascii() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.ascii\">[1]</a>, <a href=\"stdlib/strings.html#Base.ascii\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.asec\">asec() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.asecd\">asecd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.asech\">asech() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.asin\">asin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.asind\">asind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.asinh\">asinh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.assert\">assert() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.AssertionError\">AssertionError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.asum\">asum() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.At_ldiv_B\">At_ldiv_B() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.At_ldiv_Bt\">At_ldiv_Bt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.At_mul_B\">At_mul_B() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.At_mul_Bt\">At_mul_Bt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.At_rdiv_B\">At_rdiv_B() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.At_rdiv_Bt\">At_rdiv_Bt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.atan\">atan() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.atan2\">atan2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.atand\">atand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.atanh\">atanh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.atexit\">atexit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.atreplinit\">atreplinit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.available\">available() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.available\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.axpy!\">axpy!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"B\">B</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.backtrace\">backtrace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/modules.html#index-0\">baremodule</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.base\">base() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"devdocs/cartesian.html#module-Base.Cartesian\">Base.Cartesian (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#module-Base.Collections\">Base.Collections (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Base.compilecache\">Base.compilecache() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#module-Base.LinAlg\">Base.LinAlg (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#module-Base.LinAlg.BLAS\">Base.LinAlg.BLAS (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#module-Base.LinAlg.LAPACK\">Base.LinAlg.LAPACK (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.Base.linearindexing\">Base.linearindexing() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#module-Base.Pkg\">Base.Pkg (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Base.process_messages\">Base.process_messages() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Base.summarysize\">Base.summarysize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#module-Base.Test\">Base.Test (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.base64decode\">base64decode() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.Base64DecodePipe\">Base64DecodePipe() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.base64encode\">base64encode() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.Base64EncodePipe\">Base64EncodePipe() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.basename\">basename() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.bdsdc!\">bdsdc!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.bdsqr!\">bdsqr!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselh\">besselh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besseli\">besseli() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselix\">besselix() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselj\">besselj() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselj0\">besselj0() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselj1\">besselj1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besseljx\">besseljx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselk\">besselk() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselkx\">besselkx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.bessely\">bessely() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.bessely0\">bessely0() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.bessely1\">bessely1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselyx\">besselyx() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.beta\">beta() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.bfft!\">bfft!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.bfft\">bfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Bidiagonal\">Bidiagonal() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.big\">big() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.BigFloat\">BigFloat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.BigInt\">BigInt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.bin\">bin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.bind\">bind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.binomial\">binomial() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.bitbroadcast\">bitbroadcast() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.bitpack\">bitpack() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.bitrand\">bitrand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.bits\">bits() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.bitunpack\">bitunpack() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.bkfact!\">bkfact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.bkfact\">bkfact() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.blas_set_num_threads\">blas_set_num_threads() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.blascopy!\">blascopy!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.blkdiag\">blkdiag() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.BoundsError\">BoundsError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.brfft\">brfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.broadcast!\">broadcast!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.broadcast!_function\">broadcast!_function() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.broadcast\">broadcast() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.broadcast_function\">broadcast_function() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.broadcast_getindex\">broadcast_getindex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.broadcast_setindex!\">broadcast_setindex!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.bswap\">bswap() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.build\">build() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.build\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"devdocs/sysimg.html#build_sysimg\">build_sysimg() (built-in function)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.bytes2hex\">bytes2hex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.bytestring\">bytestring() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.bytestring\">[1]</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"C\">C</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/constants.html#Base.C_NULL\">C_NULL (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.call\">call() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/profile.html#Base.Profile.callers\">callers() (in module Base.Profile)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Libc.calloc\">calloc() (in module Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cat\">cat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.catalan\">catalan (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.catch_backtrace\">catch_backtrace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cbrt\">cbrt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.ccall\">ccall() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cchar\">Cchar (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.cconvert\">cconvert() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.cd\">cd() (in module Base)</a>, <a href=\"stdlib/file.html#Base.cd\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cdouble\">Cdouble (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ceil\">ceil() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cell\">cell() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cfloat\">Cfloat (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.cfunction\">cfunction() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.cglobal\">cglobal() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Channel{T}\">Channel{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.charwidth\">charwidth() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.checkbounds\">checkbounds() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.checkbounds\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.checkout\">checkout() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.chmod\">chmod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.chol\">chol() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.cholfact!\">cholfact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.cholfact\">cholfact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.cholfact\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.chomp\">chomp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.chop\">chop() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.chr2ind\">chr2ind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cint\">Cint (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cintmax_t\">Cintmax_t (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.circshift\">circshift() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cis\">cis() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.clamp\">clamp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cld\">cld() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/profile.html#Base.Profile.clear\">clear() (in module Base.Profile)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/profile.html#Base.Profile.clear_malloc_data\">clear_malloc_data() (in module Base.Profile)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.clipboard\">clipboard() (in module Base)</a>, <a href=\"stdlib/base.html#Base.clipboard\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.clone\">clone() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.clone\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Clong\">Clong (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Clonglong\">Clonglong (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.close\">close() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.close\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cmp\">cmp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.code_llvm\">code_llvm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.code_lowered\">code_lowered() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.code_native\">code_native() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.code_typed\">code_typed() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.code_warntype\">code_warntype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Coff_t\">Coff_t (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.collect\">collect() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.collect\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.colon\">colon() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.combinations\">combinations() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.complement!\">complement!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.complement\">complement() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.complex\">complex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.cond\">cond() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Condition\">Condition() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.condskeel\">condskeel() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/arrays.html#Base.conj!\">conj!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.conj\">conj() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.connect\">connect() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.connect\">[1]</a>, <a href=\"stdlib/parallel.html#Base.connect\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.consume\">consume() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.contains\">contains() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.conv\">conv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.conv2\">conv2() (in module Base)</a>, <a href=\"stdlib/math.html#Base.conv2\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.convert\">convert() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.copy!\">copy!() (in module Base)</a>, <a href=\"stdlib/c.html#Base.copy!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.copy\">copy() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.copysign\">copysign() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cor\">cor() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cos\">cos() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cosc\">cosc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cosd\">cosd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cosh\">cosh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cospi\">cospi() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cot\">cot() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cotd\">cotd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.coth\">coth() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.count\">count() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.count_ones\">count_ones() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.count_zeros\">count_zeros() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.countfrom\">countfrom() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.countlines\">countlines() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.countnz\">countnz() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cov\">cov() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.cp\">cp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cptrdiff_t\">Cptrdiff_t (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.CPU_CORES\">CPU_CORES (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.cross\">cross() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.csc\">csc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cscd\">cscd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.csch\">csch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cshort\">Cshort (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Csize_t\">Csize_t (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cssize_t\">Cssize_t (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.ctime\">ctime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ctranspose!\">ctranspose!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ctranspose\">ctranspose() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cuchar\">Cuchar (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cuint\">Cuint (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cuintmax_t\">Cuintmax_t (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Culong\">Culong (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Culonglong\">Culonglong (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cummax\">cummax() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cummin\">cummin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cumprod!\">cumprod!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cumprod\">cumprod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cumsum!\">cumsum!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cumsum\">cumsum() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cumsum_kbn\">cumsum_kbn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.current_module\">current_module() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.current_task\">current_task() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cushort\">Cushort (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cwchar_t\">Cwchar_t (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.cycle\">cycle() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"D\">D</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Date\">Date (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Date\">Date() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Date\">[1]</a>, <a href=\"stdlib/dates.html#Dates.Date\">[2]</a>, <a href=\"stdlib/dates.html#Dates.Date\">[3]</a>, <a href=\"stdlib/dates.html#Dates.Date\">[4]</a>, <a href=\"stdlib/dates.html#Dates.Date\">[5]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#module-Dates\">Dates (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Dates.DateFormat\">Dates.DateFormat() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.DateTime\">DateTime (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.DateTime\">DateTime() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.DateTime\">[1]</a>, <a href=\"stdlib/dates.html#Dates.DateTime\">[2]</a>, <a href=\"stdlib/dates.html#Dates.DateTime\">[3]</a>, <a href=\"stdlib/dates.html#Dates.DateTime\">[4]</a>, <a href=\"stdlib/dates.html#Dates.DateTime\">[5]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.datetime2julian\">datetime2julian() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.datetime2rata\">datetime2rata() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.datetime2unix\">datetime2unix() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.dawson\">dawson() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Day\">Day (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Day\">Day() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Day\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.day\">day() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayabbr\">dayabbr() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayname\">dayname() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayofquarter\">dayofquarter() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayofweek\">dayofweek() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayofweekofmonth\">dayofweekofmonth() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayofyear\">dayofyear() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.daysinmonth\">daysinmonth() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.daysinyear\">daysinyear() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.daysofweekinmonth\">daysofweekinmonth() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.dct!\">dct!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.dct\">dct() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.dec\">dec() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.deconv\">deconv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.deepcopy\">deepcopy() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.default\">default() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.deg2rad\">deg2rad() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.delete!\">delete!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.deleteat!\">deleteat!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.deleteat!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.den\">den() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.dequeue!\">dequeue!() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.deserialize\">deserialize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.det\">det() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.detach\">detach() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.DevNull\">DevNull (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.diag\">diag() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.diagind\">diagind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.diagm\">diagm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Dict\">Dict() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.diff\">diff() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.digamma\">digamma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.digits!\">digits!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.digits\">digits() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.DimensionMismatch\">DimensionMismatch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.dir\">dir() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.dir\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.dirname\">dirname() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.disable_sigint\">disable_sigint() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.display\">display() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.displayable\">displayable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.div\">div() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.DivideError\">DivideError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.divrem\">divrem() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Libdl.DL_LOAD_PATH\">DL_LOAD_PATH (in module Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Libdl.dlclose\">dlclose() (in module Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Libdl.dlext\">dlext (in module Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Libdl.dlopen\">dlopen() (in module Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Libdl.dlopen_e\">dlopen_e() (in module Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Libdl.dlsym\">dlsym() (in module Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Libdl.dlsym_e\">dlsym_e() (in module Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.DomainError\">DomainError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.done\">done() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.dot\">dot() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.dot\">(in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.dotc\">dotc() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.dotu\">dotu() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.download\">download() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.drop\">drop() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.dump\">dump() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"E\">E</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/numbers.html#Base.e\">e (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.eachindex\">eachindex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.eachline\">eachline() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.eachmatch\">eachmatch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.edit\">edit() (in module Base)</a>, <a href=\"stdlib/base.html#Base.edit\">[1]</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.edit\">(in module Base.Pkg)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eig\">eig() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.eig\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigfact!\">eigfact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigfact\">eigfact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.eigfact\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigmax\">eigmax() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigmin\">eigmin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigs\">eigs() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.eigs\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigvals!\">eigvals!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigvals\">eigvals() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigvecs\">eigvecs() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.eltype\">eltype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.empty!\">empty!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.ENDIAN_BOM\">ENDIAN_BOM (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.endof\">endof() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.endswith\">endswith() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.enqueue!\">enqueue!() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.enumerate\">enumerate() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ENV\">ENV (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.EnvHash\">EnvHash() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.eof\">eof() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.EOFError\">EOFError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.eps\">eps() (in module Base)</a>, <a href=\"stdlib/base.html#Base.eps\">[1]</a>, <a href=\"stdlib/base.html#Base.eps\">[2]</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/dates.html#Dates.eps\">(in module Dates)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/math.html#Base.erf\">erf() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.erfc\">erfc() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.erfcinv\">erfcinv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.erfcx\">erfcx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.erfi\">erfi() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.erfinv\">erfinv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Libc.errno\">errno() (in module Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.error\">error() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ErrorException\">ErrorException() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.esc\">esc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.escape_string\">escape_string() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.eta\">eta() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.etree\">etree() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.eu\">eu (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.eulergamma\">eulergamma (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.eval\">eval() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.evalfile\">evalfile() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.exit\">exit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.exp\">exp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.exp10\">exp10() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.exp2\">exp2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.expand\">expand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.expanduser\">expanduser() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.expm\">expm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.expm1\">expm1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.exponent\">exponent() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/modules.html#index-0\">export</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.extrema\">extrema() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.eye\">eye() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.eye\">[1]</a>, <a href=\"stdlib/arrays.html#Base.eye\">[2]</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"F\">F</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.factor\">factor() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.factorial\">factorial() (in module Base)</a>, <a href=\"stdlib/math.html#Base.factorial\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.factorize\">factorize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.falses\">falses() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.fd\">fd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.fdio\">fdio() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.fetch\">fetch() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/profile.html#Base.Profile.fetch\">(in module Base.Profile)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/math.html#Base.fft!\">fft!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.fft\">fft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.fftshift\">fftshift() (in module Base)</a>, <a href=\"stdlib/math.html#Base.fftshift\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.fieldnames\">fieldnames() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.fieldoffsets\">fieldoffsets() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.fieldtype\">fieldtype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.filemode\">filemode() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.filesize\">filesize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.fill!\">fill!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.fill\">fill() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.filt!\">filt!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.filt\">filt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.filter!\">filter!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.filter\">filter() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.finalize\">finalize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.finalizer\">finalizer() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.find\">find() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.find\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Libdl.find_library\">find_library() (in module Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.findfirst\">findfirst() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.findfirst\">[1]</a>, <a href=\"stdlib/arrays.html#Base.findfirst\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.findin\">findin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.findlast\">findlast() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.findlast\">[1]</a>, <a href=\"stdlib/arrays.html#Base.findlast\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.findmax!\">findmax!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.findmax\">findmax() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.findmax\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.findmin!\">findmin!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.findmin\">findmin() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.findmin\">[1]</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/arrays.html#Base.findn\">findn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.findnext\">findnext() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.findnext\">[1]</a>, <a href=\"stdlib/arrays.html#Base.findnext\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.findnz\">findnz() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.findprev\">findprev() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.findprev\">[1]</a>, <a href=\"stdlib/arrays.html#Base.findprev\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.first\">first() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.firstdayofmonth\">firstdayofmonth() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.firstdayofquarter\">firstdayofquarter() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.firstdayofweek\">firstdayofweek() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.firstdayofyear\">firstdayofyear() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.fld\">fld() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.fldmod\">fldmod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.flipbits!\">flipbits!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.flipdim\">flipdim() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.flipsign\">flipsign() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.float\">float() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.Float32\">Float32() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.Float64\">Float64() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.floor\">floor() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.flush\">flush() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Libc.flush_cstdio\">flush_cstdio() (in module Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.fma\">fma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.foldl\">foldl() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.foldl\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.foldr\">foldr() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.foldr\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Libc.FormatMessage\">FormatMessage() (in module Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.free\">free() (in module Base.Pkg)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/libc.html#Libc.free\">(in module Libc)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/math.html#Base.frexp\">frexp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.full\">full() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.full\">[1]</a>, <a href=\"stdlib/linalg.html#Base.full\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.fullname\">fullname() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.function_module\">function_module() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.function_name\">function_name() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.functionloc\">functionloc() (in module Base)</a>, <a href=\"stdlib/base.html#Base.functionloc\">[1]</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"G\">G</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.gamma\">gamma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gbmv!\">gbmv!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gbmv\">gbmv() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gbtrf!\">gbtrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gbtrs!\">gbtrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.gc\">gc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.gc_enable\">gc_enable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.gcd\">gcd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.gcdx\">gcdx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gebak!\">gebak!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gebal!\">gebal!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gebrd!\">gebrd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gecon!\">gecon!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gees!\">gees!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geev!\">geev!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geevx!\">geevx!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gehrd!\">gehrd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gelqf!\">gelqf!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gelqf!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gels!\">gels!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gelsd!\">gelsd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gelsy!\">gelsy!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gemm!\">gemm!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gemm\">gemm() (in module Base.LinAlg.BLAS)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gemm\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gemqrt!\">gemqrt!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gemv!\">gemv!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gemv\">gemv() (in module Base.LinAlg.BLAS)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gemv\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.generate\">generate() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.gensym\">gensym() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqlf!\">geqlf!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqlf!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqp3!\">geqp3!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqp3!\">[1]</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqp3!\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqrf!\">geqrf!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqrf!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqrt!\">geqrt!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqrt!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqrt3!\">geqrt3!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqrt3!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.ger!\">ger!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gerqf!\">gerqf!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gerqf!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gesdd!\">gesdd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gesv!\">gesv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gesvd!\">gesvd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gesvx!\">gesvx!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gesvx!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.get!\">get!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.get!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.get\">get() (in module Base)</a>, <a href=\"stdlib/base.html#Base.get\">[1]</a>, <a href=\"stdlib/collections.html#Base.get\">[2]</a>, <a href=\"stdlib/collections.html#Base.get\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.get_bigfloat_precision\">get_bigfloat_precision() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.get_rounding\">get_rounding() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.get_zero_subnormals\">get_zero_subnormals() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.getaddrinfo\">getaddrinfo() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.getfield\">getfield() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.gethostname\">gethostname() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.getindex\">getindex() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.getindex\">[1]</a>, <a href=\"stdlib/collections.html#Base.getindex\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.getipaddr\">getipaddr() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.getkey\">getkey() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Libc.GetLastError\">GetLastError() (in module Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.getpid\">getpid() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.getrf!\">getrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.getri!\">getri!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.getrs!\">getrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gges!\">gges!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ggev!\">ggev!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gglse!\">gglse!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ggsvd!\">ggsvd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.givens{T}\">givens{T}() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.givens{T}\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.golden\">golden (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.gperm\">gperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.gradient\">gradient() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.graphemes\">graphemes() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gtsv!\">gtsv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gttrf!\">gttrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gttrs!\">gttrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"H\">H</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.hankelh1\">hankelh1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.hankelh1x\">hankelh1x() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.hankelh2\">hankelh2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.hankelh2x\">hankelh2x() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.hash\">hash() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.haskey\">haskey() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.hcat\">hcat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.heapify!\">heapify!() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.heapify\">heapify() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.heappop!\">heappop!() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.heappush!\">heappush!() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.her!\">her!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.herk!\">herk!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.herk\">herk() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.hessfact!\">hessfact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.hessfact\">hessfact() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.hesv!\">hesv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.hetrf!\">hetrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.hetri!\">hetri!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.hetrs!\">hetrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.hex\">hex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.hex2bytes\">hex2bytes() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.hex2num\">hex2num() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.hist!\">hist!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.hist\">hist() (in module Base)</a>, <a href=\"stdlib/math.html#Base.hist\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.hist2d!\">hist2d!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.hist2d\">hist2d() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.histrange\">histrange() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.homedir\">homedir() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Hour\">Hour (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Hour\">Hour() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Hour\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.hour\">hour() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.htol\">htol() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.hton\">hton() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.hvcat\">hvcat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.hypot\">hypot() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"I\">I</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.I\">I (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.idct!\">idct!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.idct\">idct() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.identity\">identity() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ifelse\">ifelse() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ifft!\">ifft!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ifft\">ifft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ifftshift\">ifftshift() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ignorestatus\">ignorestatus() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.im\">im (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.imag\">imag() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/modules.html#index-0\">import</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/modules.html#index-0\">importall</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.in\">in() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.include\">include() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.include_dependency\">include_dependency() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.include_string\">include_string() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.ind2chr\">ind2chr() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ind2sub\">ind2sub() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.ind2sub\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.indexin\">indexin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.indexpids\">indexpids() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.indmax\">indmax() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.indmin\">indmin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.InexactError\">InexactError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.Inf\">Inf (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.inf\">inf() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.Inf16\">Inf16 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.Inf32\">Inf32 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.info\">info() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.init\">init() (in module Base.Pkg)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/profile.html#Base.Profile.init\">(in module Base.Profile)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/parallel.html#Base.init_worker\">init_worker() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.InitError\">InitError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.insert!\">insert!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.installed\">installed() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.installed\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.instances\">instances() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Instant\">Instant (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.interrupt\">interrupt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.InterruptException\">InterruptException() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.intersect!\">intersect!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.intersect\">intersect() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.IntSet\">IntSet() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.inv\">inv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.invdigamma\">invdigamma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.invmod\">invmod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.invoke\">invoke() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.invperm\">invperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.IOBuffer\">IOBuffer() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.IOBuffer\">[1]</a>, <a href=\"stdlib/io-network.html#Base.IOBuffer\">[2]</a>, <a href=\"stdlib/io-network.html#Base.IOBuffer\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ipermute!\">ipermute!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ipermutedims\">ipermutedims() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.IPv4\">IPv4() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.IPv6\">IPv6() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.irfft\">irfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.is\">is() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.is_assigned_char\">is_assigned_char() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isa\">isa() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isabspath\">isabspath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isalnum\">isalnum() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isalpha\">isalpha() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.isapprox\">isapprox() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isascii\">isascii() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isbits\">isbits() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isblockdev\">isblockdev() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.ischardev\">ischardev() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.iscntrl\">iscntrl() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isconst\">isconst() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isdefined\">isdefined() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.isdiag\">isdiag() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isdigit\">isdigit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isdir\">isdir() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isdirpath\">isdirpath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.iseltype\">iseltype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.isempty\">isempty() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isequal\">isequal() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.iseven\">iseven() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isexecutable\">isexecutable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isfifo\">isfifo() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isfile\">isfile() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isfinite\">isfinite() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isgeneric\">isgeneric() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isgraph\">isgraph() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.isheap\">isheap() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ishermitian\">ishermitian() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isimmutable\">isimmutable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isinf\">isinf() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isinteger\">isinteger() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isinteractive\">isinteractive() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isleaftype\">isleaftype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.isleapyear\">isleapyear() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isless\">isless() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.islink\">islink() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.islower\">islower() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.ismarked\">ismarked() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.ismatch\">ismatch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.ismount\">ismount() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isnan\">isnan() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isnull\">isnull() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isnumber\">isnumber() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isodd\">isodd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.isopen\">isopen() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.ispath\">ispath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.isperm\">isperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.isposdef!\">isposdef!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.isposdef\">isposdef() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ispow2\">ispow2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isprime\">isprime() (in module Base)</a>, <a href=\"stdlib/numbers.html#Base.isprime\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isprint\">isprint() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.ispunct\">ispunct() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.isqrt\">isqrt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isreadable\">isreadable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.isreadonly\">isreadonly() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.isready\">isready() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isreal\">isreal() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.issetgid\">issetgid() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.issetuid\">issetuid() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.issocket\">issocket() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.issorted\">issorted() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isspace\">isspace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.issparse\">issparse() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.issticky\">issticky() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.issubnormal\">issubnormal() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.issubset\">issubset() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.issubset\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.issubtype\">issubtype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.issym\">issym() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.istaskdone\">istaskdone() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.istaskstarted\">istaskstarted() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.istext\">istext() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.istril\">istril() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.istriu\">istriu() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isupper\">isupper() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isvalid\">isvalid() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.isvalid\">[1]</a>, <a href=\"stdlib/strings.html#Base.isvalid\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.iswritable\">iswritable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isxdigit\">isxdigit() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"J\">J</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/strings.html#Base.join\">join() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.joinpath\">joinpath() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/constants.html#Base.JULIA_HOME\">JULIA_HOME (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.julian2datetime\">julian2datetime() (in module Dates)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"K\">K</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.KeyError\">KeyError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.keys\">keys() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.keytype\">keytype() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.kill\">kill() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.kill\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.kron\">kron() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"L\">L</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/collections.html#Base.last\">last() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.lastdayofmonth\">lastdayofmonth() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.lastdayofquarter\">lastdayofquarter() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.lastdayofweek\">lastdayofweek() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.lastdayofyear\">lastdayofyear() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.launch\">launch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.lbeta\">lbeta() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.lcfirst\">lcfirst() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.lcm\">lcm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ldexp\">ldexp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ldltfact!\">ldltfact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ldltfact\">ldltfact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.ldltfact\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.leading_ones\">leading_ones() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.leading_zeros\">leading_zeros() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.length\">length() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.length\">[1]</a>, <a href=\"stdlib/strings.html#Base.length\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.less\">less() (in module Base)</a>, <a href=\"stdlib/base.html#Base.less\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.lexcmp\">lexcmp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.lexless\">lexless() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.lfact\">lfact() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.lgamma\">lgamma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#module-Libc\">Libc (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#module-Libdl\">Libdl (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.linreg\">linreg() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.linreg\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.linspace\">linspace() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/io-network.html#Base.listen\">listen() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.listen\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.listenany\">listenany() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.llvmcall\">llvmcall() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.LOAD_PATH\">LOAD_PATH (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.LoadError\">LoadError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.localindexes\">localindexes() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.lock\">lock() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.log\">log() (in module Base)</a>, <a href=\"stdlib/math.html#Base.log\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.log10\">log10() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.log1p\">log1p() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.log2\">log2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.logabsdet\">logabsdet() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.logdet\">logdet() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.logm\">logm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.logspace\">logspace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.lowercase\">lowercase() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.lpad\">lpad() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.lstat\">lstat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.lstrip\">lstrip() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.ltoh\">ltoh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.lu\">lu() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.lufact!\">lufact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.lufact\">lufact() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.lyap\">lyap() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"M\">M</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.macroexpand\">macroexpand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Libc.malloc\">malloc() (in module Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.manage\">manage() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.map!\">map!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.map!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.map\">map() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.mapfoldl\">mapfoldl() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.mapfoldl\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.mapfoldr\">mapfoldr() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.mapfoldr\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.mapreduce\">mapreduce() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.mapreduce\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.mapreducedim\">mapreducedim() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.mapslices\">mapslices() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.mark\">mark() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.match\">match() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.matchall\">matchall() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.max\">max() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.maxabs!\">maxabs!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.maxabs\">maxabs() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.maxabs\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.maximum!\">maximum!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.maximum\">maximum() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.maximum\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.maxintfloat\">maxintfloat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.mean!\">mean!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.mean\">mean() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.median!\">median!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.median\">median() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.merge!\">merge!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.merge\">merge() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.MersenneTwister\">MersenneTwister() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.method_exists\">method_exists() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.MethodError\">MethodError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.methods\">methods() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.methodswith\">methodswith() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.middle\">middle() (in module Base)</a>, <a href=\"stdlib/math.html#Base.middle\">[1]</a>, <a href=\"stdlib/math.html#Base.middle\">[2]</a>, <a href=\"stdlib/math.html#Base.middle\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.midpoints\">midpoints() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Millisecond\">Millisecond (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Millisecond\">Millisecond() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Millisecond\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.millisecond\">millisecond() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.mimewritable\">mimewritable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.min\">min() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/collections.html#Base.minabs!\">minabs!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.minabs\">minabs() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.minabs\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.minimum!\">minimum!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.minimum\">minimum() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.minimum\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.minmax\">minmax() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Minute\">Minute (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Minute\">Minute() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Minute\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.minute\">minute() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.mkdir\">mkdir() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.mkpath\">mkpath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.mktemp\">mktemp() (in module Base)</a>, <a href=\"stdlib/file.html#Base.mktemp\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.mktempdir\">mktempdir() (in module Base)</a>, <a href=\"stdlib/file.html#Base.mktempdir\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.Mmap.Anonymous\">Mmap.Anonymous() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.Mmap.mmap\">Mmap.mmap() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.Mmap.mmap\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.Mmap.sync!\">Mmap.sync!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.mod\">mod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.mod1\">mod1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.mod2pi\">mod2pi() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.modf\">modf() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/modules.html#index-0\">module</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.module_name\">module_name() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.module_parent\">module_parent() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Month\">Month (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Month\">Month() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Month\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.month\">month() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.monthabbr\">monthabbr() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.monthday\">monthday() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.monthname\">monthname() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Libc.MS_ASYNC\">MS_ASYNC (in module Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Libc.MS_INVALIDATE\">MS_INVALIDATE (in module Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Libc.MS_SYNC\">MS_SYNC (in module Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Libc.msync\">msync() (in module Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.mtime\">mtime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.muladd\">muladd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.mv\">mv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.myid\">myid() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"N\">N</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.names\">names() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.NaN\">NaN (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.nan\">nan() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.NaN16\">NaN16 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.NaN32\">NaN32 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.nb_available\">nb_available() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ndigits\">ndigits() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ndims\">ndims() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.next\">next() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.nextfloat\">nextfloat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.nextind\">nextind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.nextpow\">nextpow() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.nextpow2\">nextpow2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.nextprod\">nextprod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.nfields\">nfields() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.nnz\">nnz() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.nonzeros\">nonzeros() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.norm\">norm() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/strings.html#Base.normalize_string\">normalize_string() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.normpath\">normpath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.nothing\">nothing (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.notify\">notify() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.now\">now() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.now\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.nprocs\">nprocs() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.nrm2\">nrm2() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.nthperm!\">nthperm!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.nthperm\">nthperm() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.nthperm\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.ntoh\">ntoh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ntuple\">ntuple() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Nullable\">Nullable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.NullException\">NullException() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.nullspace\">nullspace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.num\">num() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.num2hex\">num2hex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.nworkers\">nworkers() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.nzrange\">nzrange() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"O\">O</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.object_id\">object_id() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.oct\">oct() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.oftype\">oftype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.one\">one() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ones\">ones() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.ones\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.open\">open() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.open\">[1]</a>, <a href=\"stdlib/io-network.html#Base.open\">[2]</a>, <a href=\"stdlib/io-network.html#Base.open\">[3]</a>, <a href=\"stdlib/io-network.html#Base.open\">[4]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.operm\">operm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ordschur!\">ordschur!() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.ordschur!\">[1]</a>, <a href=\"stdlib/linalg.html#Base.ordschur!\">[2]</a>, <a href=\"stdlib/linalg.html#Base.ordschur!\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ordschur\">ordschur() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.ordschur\">[1]</a>, <a href=\"stdlib/linalg.html#Base.ordschur\">[2]</a>, <a href=\"stdlib/linalg.html#Base.ordschur\">[3]</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.orghr!\">orghr!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.orglq!\">orglq!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.orgqr!\">orgqr!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ormlq!\">ormlq!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ormqr!\">ormqr!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ormrz!\">ormrz!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.OS_NAME\">OS_NAME (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.OutOfMemoryError\">OutOfMemoryError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.OverflowError\">OverflowError() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"P\">P</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/arrays.html#Base.parent\">parent() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.parentindexes\">parentindexes() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.parse\">parse() (in module Base)</a>, <a href=\"stdlib/base.html#Base.parse\">[1]</a>, <a href=\"stdlib/numbers.html#Base.parse\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ParseError\">ParseError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.parseip\">parseip() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.partitions\">partitions() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.partitions\">[1]</a>, <a href=\"stdlib/arrays.html#Base.partitions\">[2]</a>, <a href=\"stdlib/arrays.html#Base.partitions\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.peakflops\">peakflops() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.peek\">peek() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Period\">Period (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.permutations\">permutations() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.permute!\">permute!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.permutedims!\">permutedims!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.permutedims\">permutedims() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.pi\">pi (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.pin\">pin() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.pin\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.pinv\">pinv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.PipeBuffer\">PipeBuffer() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.PipeBuffer\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.pipeline\">pipeline() (in module Base)</a>, <a href=\"stdlib/base.html#Base.pipeline\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_bfft!\">plan_bfft!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_bfft\">plan_bfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_brfft\">plan_brfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_dct!\">plan_dct!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_dct\">plan_dct() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_fft!\">plan_fft!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_fft\">plan_fft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_idct!\">plan_idct!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_idct\">plan_idct() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_ifft!\">plan_ifft!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_ifft\">plan_ifft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_irfft\">plan_irfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.FFTW.plan_r2r!\">plan_r2r!() (in module Base.FFTW)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.FFTW.plan_r2r\">plan_r2r() (in module Base.FFTW)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_rfft\">plan_rfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.pmap\">pmap() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.pointer\">pointer() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.pointer_from_objref\">pointer_from_objref() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.pointer_to_array\">pointer_to_array() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.poll_fd\">poll_fd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.poll_file\">poll_file() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.polygamma\">polygamma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.pop!\">pop!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.pop!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.popdisplay\">popdisplay() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.position\">position() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.posv!\">posv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.potrf!\">potrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.potri!\">potri!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.potrs!\">potrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.powermod\">powermod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.precision\">precision() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.precompile\">precompile() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.prepend!\">prepend!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.prevfloat\">prevfloat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.prevind\">prevind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.prevpow\">prevpow() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.prevpow2\">prevpow2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.prevprod\">prevprod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.primes\">primes() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.primesmask\">primesmask() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.print\">print() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/profile.html#Base.Profile.print\">(in module Base.Profile)</a>, <a href=\"stdlib/profile.html#Base.Profile.print\">[1]</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/io-network.html#Base.print_escaped\">print_escaped() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.print_joined\">print_joined() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.print_shortest\">print_shortest() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.print_unescaped\">print_unescaped() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.print_with_color\">print_with_color() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.println\">println() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.PriorityQueue\">PriorityQueue() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.process_exited\">process_exited() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.process_running\">process_running() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ProcessExitedException\">ProcessExitedException() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.procs\">procs() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.procs\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.prod!\">prod!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.prod\">prod() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.prod\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.produce\">produce() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/profile.html#module-Profile\">Profile (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.promote\">promote() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.promote_rule\">promote_rule() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.promote_shape\">promote_shape() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.promote_type\">promote_type() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.pstrf!\">pstrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Ptr{T}\">Ptr{T} (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ptsv!\">ptsv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.pttrf!\">pttrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.pttrs!\">pttrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.publish\">publish() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.push!\">push!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.pushdisplay\">pushdisplay() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.put!\">put!() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.put!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.pwd\">pwd() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"Q\">Q</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.qr\">qr() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.qrfact!\">qrfact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.qrfact\">qrfact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.qrfact\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.quadgk\">quadgk() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.quantile!\">quantile!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.quantile\">quantile() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.quarterofyear\">quarterofyear() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.quit\">quit() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"R\">R</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.FFTW.r2r!\">r2r!() (in module Base.FFTW)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.FFTW.r2r\">r2r() (in module Base.FFTW)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.rad2deg\">rad2deg() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.rand!\">rand!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.rand\">rand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.randcycle\">randcycle() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.randexp!\">randexp!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.randexp\">randexp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.randjump\">randjump() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.randn!\">randn!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.randn\">randn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.RandomDevice\">RandomDevice() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.randperm\">randperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.randstring\">randstring() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.randsubseq!\">randsubseq!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.randsubseq\">randsubseq() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.range\">range() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.rank\">rank() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.rata2datetime\">rata2datetime() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.rationalize\">rationalize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.read!\">read!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.read\">read() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.read\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readall\">readall() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.readall\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.readandwrite\">readandwrite() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readavailable\">readavailable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readbytes!\">readbytes!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readbytes\">readbytes() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readchomp\">readchomp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readcsv\">readcsv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.readdir\">readdir() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readdlm\">readdlm() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.readdlm\">[1]</a>, <a href=\"stdlib/io-network.html#Base.readdlm\">[2]</a>, <a href=\"stdlib/io-network.html#Base.readdlm\">[3]</a>, <a href=\"stdlib/io-network.html#Base.readdlm\">[4]</a>, <a href=\"stdlib/io-network.html#Base.readdlm\">[5]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readline\">readline() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readlines\">readlines() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.readlink\">readlink() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ReadOnlyMemoryError\">ReadOnlyMemoryError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readuntil\">readuntil() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.real\">real() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Libc.realloc\">realloc() (in module Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.realmax\">realmax() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.realmin\">realmin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.realpath\">realpath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.recur{T<:TimeType}\">recur{T&lt;:TimeType}() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.recv\">recv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.recvfrom\">recvfrom() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.redirect_stderr\">redirect_stderr() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.redirect_stdin\">redirect_stdin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.redirect_stdout\">redirect_stdout() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.redirect_stdout\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.redisplay\">redisplay() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.reduce\">reduce() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.reduce\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.reducedim\">reducedim() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.reenable_sigint\">reenable_sigint() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.ReentrantLock\">ReentrantLock() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Ref{T}\">Ref{T} (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.register\">register() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.reim\">reim() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.reinterpret\">reinterpret() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.reload\">reload() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.relpath\">relpath() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.rem\">rem() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.rem1\">rem1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.remotecall\">remotecall() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.remotecall_fetch\">remotecall_fetch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.remotecall_wait\">remotecall_wait() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.RemoteRef\">RemoteRef() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.RemoteRef\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.repeat\">repeat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.repeated\">repeated() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.replace\">replace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.repmat\">repmat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.repr\">repr() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.reprmime\">reprmime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.require\">require() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.reset\">reset() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.reshape\">reshape() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.resize!\">resize!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.resolve\">resolve() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.rest\">rest() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.rethrow\">rethrow() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/profile.html#Base.Profile.retrieve\">retrieve() (in module Base.Profile)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.reverse!\">reverse!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.reverse\">reverse() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.reverse\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.reverseind\">reverseind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.rfft\">rfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.rm\">rm() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.rm\">(in module Base.Pkg)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/parallel.html#Base.rmprocs\">rmprocs() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.rol!\">rol!() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.rol!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.rol\">rol() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ror!\">ror!() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.ror!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ror\">ror() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.rot180\">rot180() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.rot180\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.rotl90\">rotl90() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.rotl90\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.rotr90\">rotr90() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.rotr90\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.round\">round() (in module Base)</a>, <a href=\"stdlib/math.html#Base.round\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.RoundDown\">RoundDown (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.RoundingMode\">RoundingMode (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.RoundNearest\">RoundNearest (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.RoundNearestTiesAway\">RoundNearestTiesAway (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.RoundNearestTiesUp\">RoundNearestTiesUp (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.RoundToZero\">RoundToZero (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.RoundUp\">RoundUp (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.rowvals\">rowvals() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.rpad\">rpad() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.rsearch\">rsearch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.rsearchindex\">rsearchindex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.rsplit\">rsplit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.rstrip\">rstrip() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Libdl.RTLD_DEEPBIND\">RTLD_DEEPBIND (in module Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Libdl.RTLD_FIRST\">RTLD_FIRST (in module Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Libdl.RTLD_GLOBAL\">RTLD_GLOBAL (in module Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Libdl.RTLD_LAZY\">RTLD_LAZY (in module Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Libdl.RTLD_LOCAL\">RTLD_LOCAL (in module Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Libdl.RTLD_NODELETE\">RTLD_NODELETE (in module Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Libdl.RTLD_NOLOAD\">RTLD_NOLOAD (in module Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Libdl.RTLD_NOW\">RTLD_NOW (in module Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.run\">run() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#Base.runtests\">runtests() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"S\">S</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.sbmv!\">sbmv!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.sbmv\">sbmv() (in module Base.LinAlg.BLAS)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.sbmv\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.scal!\">scal!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.scal\">scal() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.scale!\">scale!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.scale\">scale() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.schedule\">schedule() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.schur\">schur() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.schur\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.schurfact!\">schurfact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.schurfact\">schurfact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.schurfact\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.sdata\">sdata() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.search\">search() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.searchindex\">searchindex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.searchsorted\">searchsorted() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.searchsortedfirst\">searchsortedfirst() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.searchsortedlast\">searchsortedlast() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sec\">sec() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.secd\">secd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sech\">sech() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Second\">Second (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Second\">Second() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Second\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.second\">second() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.seek\">seek() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.seekend\">seekend() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.seekstart\">seekstart() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.select!\">select!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.select\">select() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.selectperm!\">selectperm!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.selectperm\">selectperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.send\">send() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.serialize\">serialize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Set\">Set() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.set_bigfloat_precision\">set_bigfloat_precision() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.set_rounding\">set_rounding() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.set_zero_subnormals\">set_zero_subnormals() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.setdiff!\">setdiff!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.setdiff\">setdiff() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.setenv\">setenv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.setfield!\">setfield!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.setindex!\">setindex!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.setindex!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.setopt\">setopt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.SharedArray\">SharedArray() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.SharedArray\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.shift!\">shift!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.show\">show() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.showall\">showall() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.showcompact\">showcompact() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.showerror\">showerror() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.shuffle!\">shuffle!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.shuffle\">shuffle() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sign\">sign() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.signbit\">signbit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.signed\">signed() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.signif\">signif() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.significand\">significand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.similar\">similar() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sin\">sin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sinc\">sinc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sind\">sind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sinh\">sinh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sinpi\">sinpi() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.size\">size() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sizehint!\">sizehint!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.sizeof\">sizeof() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.sizeof\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.skip\">skip() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.skipchars\">skipchars() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.sleep\">sleep() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.slice\">slice() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.slicedim\">slicedim() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.sort!\">sort!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.sort\">sort() (in module Base)</a>, <a href=\"stdlib/sort.html#Base.sort\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.sortcols\">sortcols() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.sortperm!\">sortperm!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.sortperm\">sortperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.sortrows\">sortrows() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sparse\">sparse() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.sparse\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sparsevec\">sparsevec() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.sparsevec\">[1]</a>, <a href=\"stdlib/arrays.html#Base.sparsevec\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.spawn\">spawn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.spdiagm\">spdiagm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.speye\">speye() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.splice!\">splice!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.splice!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.split\">split() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.splitdir\">splitdir() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/file.html#Base.splitdrive\">splitdrive() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.splitext\">splitext() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.spones\">spones() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sprand\">sprand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sprandbool\">sprandbool() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sprandn\">sprandn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.sprint\">sprint() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.spzeros\">spzeros() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sqrt\">sqrt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.sqrtm\">sqrtm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.squeeze\">squeeze() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.srand\">srand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.StackOverflowError\">StackOverflowError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.start\">start() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.startswith\">startswith() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.stat\">stat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.status\">status() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.std\">std() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.STDERR\">STDERR (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.STDIN\">STDIN (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.stdm\">stdm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.STDOUT\">STDOUT (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.stebz!\">stebz!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.stegr!\">stegr!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.stein!\">stein!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.step\">step() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.stev!\">stev!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Libc.strerror\">strerror() (in module Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Libc.strftime\">strftime() (in module Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.stride\">stride() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.strides\">strides() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.string\">string() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.stringmime\">stringmime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.strip\">strip() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Libc.strptime\">strptime() (in module Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.strwidth\">strwidth() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sub\">sub() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sub2ind\">sub2ind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.subtypes\">subtypes() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.success\">success() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sum!\">sum!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sum\">sum() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.sum\">[1]</a>, <a href=\"stdlib/collections.html#Base.sum\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sum_kbn\">sum_kbn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sumabs!\">sumabs!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sumabs\">sumabs() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.sumabs\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sumabs2!\">sumabs2!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sumabs2\">sumabs2() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.sumabs2\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.summary\">summary() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.super\">super() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.svd\">svd() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.svd\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.svdfact!\">svdfact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.svdfact\">svdfact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.svdfact\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.svds\">svds() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.svdvals!\">svdvals!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.svdvals\">svdvals() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.svdvals\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.syconv!\">syconv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.syev!\">syev!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.syevr!\">syevr!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.sygvd!\">sygvd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.sylvester\">sylvester() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.symbol\">symbol() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.symdiff!\">symdiff!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.symdiff!\">[1]</a>, <a href=\"stdlib/collections.html#Base.symdiff!\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.symdiff\">symdiff() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.symlink\">symlink() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symm!\">symm!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symm\">symm() (in module Base.LinAlg.BLAS)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symm\">[1]</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symm\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.symperm\">symperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.SymTridiagonal\">SymTridiagonal() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symv!\">symv!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symv\">symv() (in module Base.LinAlg.BLAS)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symv\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.syr!\">syr!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.syrk!\">syrk!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.syrk\">syrk() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Sys.get_process_title\">Sys.get_process_title() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Sys.set_process_title\">Sys.set_process_title() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.SystemError\">SystemError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.systemerror\">systemerror() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.sysv!\">sysv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.sytrf!\">sytrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.sytri!\">sytri!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.sytrs!\">sytrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"T\">T</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.tag\">tag() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.take!\">take!() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.take!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.take\">take() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.takebuf_array\">takebuf_array() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.takebuf_string\">takebuf_string() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.tan\">tan() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.tand\">tand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.tanh\">tanh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Task\">Task() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.task_local_storage\">task_local_storage() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.task_local_storage\">[1]</a>, <a href=\"stdlib/parallel.html#Base.task_local_storage\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.tempdir\">tempdir() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.tempname\">tempname() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.test\">test() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.test\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.TextDisplay\">TextDisplay() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.tgsen!\">tgsen!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.throw\">throw() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.tic\">tic() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.time\">time() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/libc.html#Libc.time\">(in module Libc)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/base.html#Base.time_ns\">time_ns() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.timedwait\">timedwait() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Timer\">Timer() (in module Base)</a>, <a href=\"stdlib/base.html#Base.Timer\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.TimeType\">TimeType (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Libc.TmStruct\">TmStruct() (in module Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.toc\">toc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.today\">today() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.tofirst\">tofirst() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.tolast\">tolast() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.tonext\">tonext() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.tonext\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.toprev\">toprev() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.toprev\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.toq\">toq() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.touch\">touch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.trace\">trace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.trailing_ones\">trailing_ones() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.trailing_zeros\">trailing_zeros() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.transpose!\">transpose!() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.transpose\">transpose() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trcon!\">trcon!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trevc!\">trevc!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Tridiagonal\">Tridiagonal() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.trigamma\">trigamma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.tril!\">tril!() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.tril!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.tril\">tril() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.tril\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.triu!\">triu!() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.triu!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.triu\">triu() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.triu\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trmm!\">trmm!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trmm\">trmm() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trmv!\">trmv!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trmv\">trmv() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trrfs!\">trrfs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trsen!\">trsen!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trsm!\">trsm!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trsm\">trsm() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trsv!\">trsv!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trsv\">trsv() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trsyl!\">trsyl!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trtri!\">trtri!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trtrs!\">trtrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.trues\">trues() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.trunc\">trunc() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/dates.html#Dates.trunc\">(in module Dates)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/io-network.html#Base.truncate\">truncate() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.tryparse\">tryparse() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.tuple\">tuple() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.TypeError\">TypeError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.typeintersect\">typeintersect() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.typejoin\">typejoin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.typemax\">typemax() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.typemin\">typemin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.typeof\">typeof() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.tzrzf!\">tzrzf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"U\">U</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/strings.html#Base.ucfirst\">ucfirst() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.UndefRefError\">UndefRefError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.UndefVarError\">UndefVarError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.unescape_string\">unescape_string() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.union!\">union!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.union\">union() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.unique\">unique() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.unix2datetime\">unix2datetime() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.unlock\">unlock() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.unmark\">unmark() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.unsafe_convert\">unsafe_convert() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.unsafe_copy!\">unsafe_copy!() (in module Base)</a>, <a href=\"stdlib/c.html#Base.unsafe_copy!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.unsafe_load\">unsafe_load() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/c.html#Base.unsafe_pointer_to_objref\">unsafe_pointer_to_objref() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.unsafe_store!\">unsafe_store!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.unsafe_trunc\">unsafe_trunc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.unshift!\">unshift!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.unsigned\">unsigned() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.update\">update() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.uperm\">uperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.uppercase\">uppercase() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/modules.html#index-0\">using</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.utf16\">utf16() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.utf16\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.utf32\">utf32() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.utf32\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.utf8\">utf8() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.utf8\">[1]</a>, <a href=\"stdlib/strings.html#Base.utf8\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.UTInstant{T}\">UTInstant{T} (in module Dates)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"V\">V</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/collections.html#Base.valtype\">valtype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.values\">values() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Val{c}\">Val{c}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.var\">var() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.varm\">varm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.vcat\">vcat() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/arrays.html#Base.vec\">vec() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.vecdot\">vecdot() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.vecnorm\">vecnorm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.VERSION\">VERSION (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.versioninfo\">versioninfo() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"W\">W</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/parallel.html#Base.wait\">wait() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.warn\">warn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.watch_file\">watch_file() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Week\">Week (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Week\">Week() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Week\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.week\">week() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.which\">which() (in module Base)</a>, <a href=\"stdlib/base.html#Base.which\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.whos\">whos() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.widemul\">widemul() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.widen\">widen() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.with_bigfloat_precision\">with_bigfloat_precision() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/test.html#Base.Test.with_handler\">with_handler() (in module Base.Test)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.with_rounding\">with_rounding() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.withenv\">withenv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.WORD_SIZE\">WORD_SIZE (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.workers\">workers() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.workspace\">workspace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.write\">write() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.writecsv\">writecsv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.writedlm\">writedlm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.writemime\">writemime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.wstring\">wstring() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"X\">X</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.xcorr\">xcorr() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/io-network.html#Base.xdump\">xdump() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"Y\">Y</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Year\">Year (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Year\">Year() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Year\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.year\">year() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.yearmonth\">yearmonth() (in module Dates)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/dates.html#Dates.yearmonthday\">yearmonthday() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.yield\">yield() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.yieldto\">yieldto() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"Z\">Z</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/numbers.html#Base.zero\">zero() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.zeros\">zeros() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.zeros\">[1]</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.zeta\">zeta() (in module Base)</a>, <a href=\"stdlib/math.html#Base.zeta\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.zip\">zip() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"Symbols\">Symbols</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.\u00d7\">\u00d7() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.\u00f7\">\u00f7() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.\u03b3\">\u03b3 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.\u03c0\">\u03c0 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.\u03c6\">\u03c6 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u2208\">\u2208() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u2209\">\u2209() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u220b\">\u220b() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u220c\">\u220c() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u2229\">\u2229() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u222a\">\u222a() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.\u2261\">\u2261() (in module Base)</a>, <a href=\"stdlib/math.html#Base.\u2261\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.\u2262\">\u2262() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.\u2264\">\u2264() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.\u2265\">\u2265() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u2286\">\u2286() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.\u2286\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u2288\">\u2288() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u228a\">\u228a() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.\u22c5\">\u22c5() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n\n\n          </div>\n          <footer>\n  \n\n  <hr/>\n\n  <div role=\"contentinfo\">\n    <p>\n    </p>\n  </div>\n\n  <a href=\"https://github.com/snide/sphinx_rtd_theme\">Sphinx theme</a> provided by <a href=\"https://readthedocs.org\">Read the Docs</a>\n</footer>\n        </div>\n      </div>\n\n    </section>\n\n  </div>\n  \n\n  \n\n    <script type=\"text/javascript\">\n        var DOCUMENTATION_OPTIONS = {\n            URL_ROOT:'./',\n            VERSION:'0.4.5',\n            COLLAPSE_INDEX:false,\n            FILE_SUFFIX:'.html',\n            HAS_SOURCE:  true\n        };\n    </script>\n      <script type=\"text/javascript\" src=\"_static/jquery.js\"></script>\n      <script type=\"text/javascript\" src=\"_static/underscore.js\"></script>\n      <script type=\"text/javascript\" src=\"_static/doctools.js\"></script>\n      <script type=\"text/javascript\" src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>\n\n  \n\n  \n  \n    <script type=\"text/javascript\" src=\"_static/js/theme.js\"></script>\n  \n\n  \n  \n  <script type=\"text/javascript\">\n      jQuery(function () {\n          SphinxRtdTheme.StickyNav.enable();\n      });\n  </script>\n   \n\n</body>\n</html>",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/stdlib/libdl.html": "\n\n<!DOCTYPE html>\n<!--[if IE 8]><html class=\"no-js lt-ie9\" lang=\"en\" > <![endif]-->\n<!--[if gt IE 8]><!--> <html class=\"no-js\" lang=\"en\" > <!--<![endif]-->\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  \n  <title>Dynamic Linker &mdash; Julia Language 0.4.5 documentation</title>\n  \n\n  \n  \n\n  \n  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>\n\n  \n  \n    \n\n  \n\n  \n  \n    <link rel=\"stylesheet\" href=\"../_static/julia.css\" type=\"text/css\" />\n  \n\n  \n    <link rel=\"stylesheet\" href=\"../_static/julia.css\" type=\"text/css\" />\n  \n    <link rel=\"top\" title=\"Julia Language 0.4.5 documentation\" href=\"../index.html\"/> \n\n  \n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js\"></script>\n\n</head>\n\n<body class=\"wy-body-for-nav\" role=\"document\">\n\n  <div class=\"wy-grid-for-nav\">\n\n    \n    <nav data-toggle=\"wy-nav-shift\" class=\"wy-nav-side\">\n      <div class=\"wy-side-nav-search\">\n        <a href=\"http://julialang.org/\"><img src=\"../_static/julia-logo.svg\" class=\"logo\"></a>\n        <!--\n        <a href=\"../index.html\" class=\"fa fa-home\"> Julia Language</a>\n        -->\n        <div role=\"search\">\n  <form id =\"rtd-search-form\" class=\"wy-form\" action=\"../search.html\" method=\"get\">\n    <input type=\"text\" name=\"q\" placeholder=\"Search docs\" />\n    <input type=\"hidden\" name=\"check_keywords\" value=\"yes\" />\n    <input type=\"hidden\" name=\"area\" value=\"default\" />\n  </form>\n</div>\n      </div>\n\n      <div class=\"wy-menu wy-menu-vertical\" data-spy=\"affix\" role=\"navigation\" aria-label=\"main navigation\">\n        \n        \n            <ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/introduction.html\">Introduction</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/getting-started.html\">Getting Started</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/getting-started.html#resources\">Resources</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/variables.html\">Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables.html#allowed-variable-names\">Allowed Variable Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables.html#stylistic-conventions\">Stylistic Conventions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html\">Integers and Floating-Point Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#integers\">Integers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#floating-point-numbers\">Floating-Point Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#arbitrary-precision-arithmetic\">Arbitrary Precision Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#numeric-literal-coefficients\">Numeric Literal Coefficients</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#literal-zero-and-one\">Literal zero and one</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html\">Mathematical Operations and Elementary Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#arithmetic-operators\">Arithmetic Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#bitwise-operators\">Bitwise Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#updating-operators\">Updating operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#numeric-comparisons\">Numeric Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#numerical-conversions\">Numerical Conversions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#elementary-functions\">Elementary Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/complex-and-rational-numbers.html\">Complex and Rational Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/complex-and-rational-numbers.html#complex-numbers\">Complex Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/complex-and-rational-numbers.html#rational-numbers\">Rational Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/strings.html\">Strings</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#characters\">Characters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#string-basics\">String Basics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#unicode-and-utf-8\">Unicode and UTF-8</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#triple-quoted-string-literals\">Triple-Quoted String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#common-operations\">Common Operations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#regular-expressions\">Regular Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#id3\">Byte Array Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#version-number-literals\">Version Number Literals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/functions.html\">Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#argument-passing-behavior\">Argument Passing Behavior</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#the-return-keyword\">The <code class=\"docutils literal\"><span class=\"pre\">return</span></code> Keyword</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#operators-are-functions\">Operators Are Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#operators-with-special-names\">Operators With Special Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#anonymous-functions\">Anonymous Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#multiple-return-values\">Multiple Return Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#varargs-functions\">Varargs Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#optional-arguments\">Optional Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#keyword-arguments\">Keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#evaluation-scope-of-default-values\">Evaluation Scope of Default Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#do-block-syntax-for-function-arguments\">Do-Block Syntax for Function Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#further-reading\">Further Reading</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/control-flow.html\">Control Flow</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#compound-expressions\">Compound Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#conditional-evaluation\">Conditional Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#short-circuit-evaluation\">Short-Circuit Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#repeated-evaluation-loops\">Repeated Evaluation: Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#exception-handling\">Exception Handling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#tasks-aka-coroutines\">Tasks (aka Coroutines)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html\">Scope of Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html#global-scope\">Global Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html#local-scope\">Local Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html#constants\">Constants</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/types.html\">Types</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#type-declarations\">Type Declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#abstract-types\">Abstract Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#bits-types\">Bits Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#composite-types\">Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#immutable-composite-types\">Immutable Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#declared-types\">Declared Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#type-unions\">Type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#man-parametric-types\">Parametric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#type-aliases\">Type Aliases</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#operations-on-types\">Operations on Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#value-types\">&#8220;Value types&#8221;</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#nullable-types-representing-missing-values\">Nullable Types: Representing Missing Values</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/methods.html\">Methods</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#defining-methods\">Defining Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#method-ambiguities\">Method Ambiguities</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#parametric-methods\">Parametric Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#note-on-optional-and-keyword-arguments\">Note on Optional and keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#call-overloading-and-function-like-objects\">Call overloading and function-like objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#empty-generic-functions\">Empty generic functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/constructors.html\">Constructors</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#outer-constructor-methods\">Outer Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#inner-constructor-methods\">Inner Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#incomplete-initialization\">Incomplete Initialization</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#parametric-constructors\">Parametric Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#case-study-rational\">Case Study: Rational</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#constructors-call-and-conversion\">Constructors, Call, and Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#outer-only-constructors\">Outer-only constructors</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/conversion-and-promotion.html\">Conversion and Promotion</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/conversion-and-promotion.html#conversion\">Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/conversion-and-promotion.html#promotion\">Promotion</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/interfaces.html\">Interfaces</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interfaces.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interfaces.html#indexing\">Indexing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interfaces.html#abstract-arrays\">Abstract Arrays</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/modules.html\">Modules</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/modules.html#summary-of-module-usage\">Summary of module usage</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/documentation.html\">Documentation</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#accessing-documentation\">Accessing Documentation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#functions-methods\">Functions &amp; Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#advanced-usage\">Advanced Usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#syntax-guide\">Syntax Guide</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#markdown-syntax-notes\">Markdown Syntax Notes</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html\">Metaprogramming</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#program-representation\">Program representation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#expressions-and-evaluation\">Expressions and evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#macros\">Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#code-generation\">Code Generation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#generated-functions\">Generated functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/arrays.html\">Multi-dimensional Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/arrays.html#arrays\">Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/arrays.html#sparse-matrices\">Sparse Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/linear-algebra.html\">Linear algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/linear-algebra.html#matrix-factorizations\">Matrix factorizations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/linear-algebra.html#special-matrices\">Special matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html\">Networking and Streams</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#basic-stream-i-o\">Basic Stream I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#working-with-files\">Working with Files</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#a-simple-tcp-example\">A simple TCP example</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#resolving-ip-addresses\">Resolving IP Addresses</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html\">Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#code-availability-and-loading-packages\">Code Availability and Loading Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#data-movement\">Data Movement</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#parallel-map-and-loops\">Parallel Map and Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#synchronization-with-remote-references\">Synchronization With Remote References</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#scheduling\">Scheduling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#channels\">Channels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#remoterefs-and-abstractchannels\">RemoteRefs and AbstractChannels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#shared-arrays\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#distributed-garbage-collection\">Distributed Garbage Collection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#clustermanagers\">ClusterManagers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#cluster-managers-with-custom-transports\">Cluster Managers with custom transports</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#specifying-network-topology-experimental\">Specifying network topology (Experimental)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/dates.html\">Date and DateTime</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#durations-comparisons\">Durations/Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#accessor-functions\">Accessor Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#query-functions\">Query Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#timetype-period-arithmetic\">TimeType-Period Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#adjuster-functions\">Adjuster Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#period-types\">Period Types</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html\">Running External Programs</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html#quoting\">Quoting</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html#pipelines\">Pipelines</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html\">Calling C and Fortran Code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#creating-c-compatible-julia-function-pointers\">Creating C-Compatible Julia Function Pointers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#mapping-c-types-to-julia\">Mapping C Types to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#mapping-c-functions-to-julia\">Mapping C Functions to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#garbage-collection-safety\">Garbage Collection Safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#non-constant-function-specifications\">Non-constant Function Specifications</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#indirect-calls\">Indirect Calls</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#calling-convention\">Calling Convention</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#accessing-global-variables\">Accessing Global Variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#accessing-data-through-a-pointer\">Accessing Data through a Pointer</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#thread-safety\">Thread-safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#more-about-callbacks\">More About Callbacks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#c\">C++</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#handling-operating-system-variation\">Handling Operating System Variation</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html\">Interacting With Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html#the-different-prompt-modes\">The different prompt modes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html#key-bindings\">Key bindings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html#tab-completion\">Tab completion</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/embedding.html\">Embedding Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#high-level-embedding\">High-Level Embedding</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#converting-types\">Converting Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#calling-julia-functions\">Calling Julia Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#memory-management\">Memory Management</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#working-with-arrays\">Working with Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#exceptions\">Exceptions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/packages.html\">Packages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#package-status\">Package Status</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#adding-and-removing-packages\">Adding and Removing Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#offline-installation-of-packages\">Offline Installation of Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#installing-unregistered-packages\">Installing Unregistered Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#updating-packages\">Updating Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#checkout-pin-and-free\">Checkout, Pin and Free</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#custom-metadata-repository\">Custom METADATA Repository</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/packages.html#package-development\">Package Development</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#initial-setup\">Initial Setup</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#making-changes-to-an-existing-package\">Making changes to an existing package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#creating-a-new-package\">Creating a new Package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#fixing-package-requirements\">Fixing Package Requirements</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#man-package-requirements\">Requirements Specification</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/profile.html\">Profiling</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#basic-usage\">Basic usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#accumulation-and-clearing\">Accumulation and clearing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#options-for-controlling-the-display-of-profile-results\">Options for controlling the display of profile results</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#configuration\">Configuration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/profile.html#memory-allocation-analysis\">Memory allocation analysis</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/performance-tips.html\">Performance Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-global-variables\">Avoid global variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#measure-performance-with-time-and-pay-attention-to-memory-allocation\">Measure performance with <code class=\"docutils literal\"><span class=\"pre\">&#64;time</span></code> and pay attention to memory allocation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#tools\">Tools</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-containers-with-abstract-type-parameters\">Avoid containers with abstract type parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#type-declarations\">Type declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#break-functions-into-multiple-definitions\">Break functions into multiple definitions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#write-type-stable-functions\">Write &#8220;type-stable&#8221; functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-changing-the-type-of-a-variable\">Avoid changing the type of a variable</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#separate-kernel-functions\">Separate kernel functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#access-arrays-in-memory-order-along-columns\">Access arrays in memory order, along columns</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#pre-allocating-outputs\">Pre-allocating outputs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-string-interpolation-for-i-o\">Avoid string interpolation for I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#optimize-network-i-o-during-parallel-execution\">Optimize network I/O during parallel execution</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#fix-deprecation-warnings\">Fix deprecation warnings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#tweaks\">Tweaks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#performance-annotations\">Performance Annotations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#treat-subnormal-numbers-as-zeros\">Treat Subnormal Numbers as Zeros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#code-warntype\"><code class=\"docutils literal\"><span class=\"pre\">&#64;code_warntype</span></code></a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/workflow-tips.html\">Workflow Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/workflow-tips.html#repl-based-workflow\">REPL-based workflow</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/workflow-tips.html#browser-based-workflow\">Browser-based workflow</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/style-guide.html\">Style Guide</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#write-functions-not-just-scripts\">Write functions, not just scripts</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-writing-overly-specific-types\">Avoid writing overly-specific types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#handle-excess-argument-diversity-in-the-caller\">Handle excess argument diversity in the caller</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#append-to-names-of-functions-that-modify-their-arguments\">Append <code class=\"docutils literal\"><span class=\"pre\">!</span></code> to names of functions that modify their arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-strange-type-unions\">Avoid strange type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-type-unions-in-fields\">Avoid type Unions in fields</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-elaborate-container-types\">Avoid elaborate container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#use-naming-conventions-consistent-with-julia-s-base\">Use naming conventions consistent with Julia&#8217;s <code class=\"docutils literal\"><span class=\"pre\">base/</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overuse-try-catch\">Don&#8217;t overuse try-catch</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-parenthesize-conditions\">Don&#8217;t parenthesize conditions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overuse\">Don&#8217;t overuse ...</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-use-unnecessary-static-parameters\">Don&#8217;t use unnecessary static parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-confusion-about-whether-something-is-an-instance-or-a-type\">Avoid confusion about whether something is an instance or a type</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overuse-macros\">Don&#8217;t overuse macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-expose-unsafe-operations-at-the-interface-level\">Don&#8217;t expose unsafe operations at the interface level</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overload-methods-of-base-container-types\">Don&#8217;t overload methods of base container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#be-careful-with-type-equality\">Be careful with type equality</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#do-not-write-x-f-x\">Do not write <code class=\"docutils literal\"><span class=\"pre\">x-&gt;f(x)</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible\">Avoid using floats for numeric literals in generic code when possible</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/faq.html\">Frequently Asked Questions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#sessions-and-the-repl\">Sessions and the REPL</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#functions\">Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#types-type-declarations-and-constructors\">Types, type declarations, and constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#packages-and-modules\">Packages and Modules</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#nothingness-and-missing-values\">Nothingness and missing values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#memory\">Memory</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#asynchronous-io-and-concurrent-synchronous-writes\">Asynchronous IO and concurrent synchronous writes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#julia-releases\">Julia Releases</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html\">Noteworthy Differences from other Languages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-matlab\">Noteworthy differences from MATLAB</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-r\">Noteworthy differences from R</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-python\">Noteworthy differences from Python</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-c-c\">Noteworthy differences from C/C++</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/unicode-input.html\">Unicode Input</a></li>\n</ul>\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"base.html\">Essentials</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#introduction\">Introduction</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#getting-around\">Getting Around</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#all-objects\">All Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#types\">Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#generic-functions\">Generic Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#syntax\">Syntax</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#nullables\">Nullables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#system\">System</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#errors\">Errors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#events\">Events</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#reflection\">Reflection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#internals\">Internals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"collections.html\">Collections and Data Structures</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#general-collections\">General Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#iterable-collections\">Iterable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#indexable-collections\">Indexable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#associative-collections\">Associative Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#set-like-collections\">Set-Like Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#dequeues\">Dequeues</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#priorityqueue\">PriorityQueue</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#heap-functions\">Heap Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"math.html\">Mathematics</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#mathematical-operators\">Mathematical Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#mathematical-functions\">Mathematical Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#statistics\">Statistics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#signal-processing\">Signal Processing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#numerical-integration\">Numerical Integration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"numbers.html\">Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#standard-numeric-types\">Standard Numeric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#data-formats\">Data Formats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#general-number-functions-and-constants\">General Number Functions and Constants</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#bigfloats\">BigFloats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#random-numbers\">Random Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"strings.html\">Strings</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"arrays.html\">Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#basic-functions\">Basic functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#mathematical-operators-and-functions\">Mathematical operators and functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#indexing-assignment-and-concatenation\">Indexing, Assignment, and Concatenation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#array-functions\">Array functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#combinatorics\">Combinatorics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#bitarrays\">BitArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#sparse-matrices\">Sparse Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"parallel.html\">Tasks and Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#tasks\">Tasks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#general-parallel-computing-support\">General Parallel Computing Support</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#shared-arrays\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#cluster-manager-interface\">Cluster Manager Interface</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"linalg.html\">Linear Algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linalg.html#module-Base.LinAlg\">Standard Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linalg.html#module-Base.LinAlg.BLAS\">BLAS Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linalg.html#module-Base.LinAlg.LAPACK\">LAPACK Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"constants.html\">Constants</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"file.html\">Filesystem</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"io-network.html\">I/O and Network</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#general-i-o\">General I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#multimedia-i-o\">Multimedia I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#memory-mapped-i-o\">Memory-mapped I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#network-i-o\">Network I/O</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"punctuation.html\">Punctuation</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"sort.html\">Sorting and Related Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sort.html#sorting-functions\">Sorting Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sort.html#order-related-functions\">Order-Related Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sort.html#sorting-algorithms\">Sorting Algorithms</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"pkg.html\">Package Manager Functions</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"dates.html\">Dates and Time</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#dates-and-time-types\">Dates and Time Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#dates-functions\">Dates Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"test.html\">Unit and Functional Testing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#testing-base-julia\">Testing Base Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#test-framework\">Test Framework</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#handlers\">Handlers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#macros\">Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#functions\">Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"c.html\">C Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"c.html#llvm-interface\">LLVM Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"profile.html\">Profiling</a></li>\n</ul>\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/reflection.html\">Reflection and introspection</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/julia.html\">Documentation of Julia&#8217;s Internals</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/init.html\">Initialization of the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/eval.html\">Eval of Julia code</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/ast.html\">Julia ASTs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/types.html\">More about types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/object.html\">Memory layout of Julia Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/cartesian.html\">Base.Cartesian</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/meta.html\">Talking to the compiler (the <code class=\"docutils literal\"><span class=\"pre\">:meta</span></code> mechanism)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/subarrays.html\">SubArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/sysimg.html\">System Image Building</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/llvm.html\">Working with LLVM</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/stdio.html\">printf() and stdio in the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/promote-op.html\">Operator-sensitive promotion</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/C.html\">Developing/debugging Julia&#8217;s C code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/backtraces.html\">Reporting and analyzing crashes (segfaults)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/debuggingtips.html\">gdb debugging tips</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/valgrind.html\">Using Valgrind with Julia</a></li>\n</ul>\n</li>\n</ul>\n\n        \n      </div>\n      &nbsp;\n    </nav>\n\n    <section data-toggle=\"wy-nav-shift\" class=\"wy-nav-content-wrap\">\n\n      \n      <nav class=\"wy-nav-top\" role=\"navigation\" aria-label=\"top navigation\">\n        <i data-toggle=\"wy-nav-top\" class=\"fa fa-bars\"></i>\n        <a href=\"../index.html\">Julia Language</a>\n      </nav>\n\n\n      \n      <div class=\"wy-nav-content\">\n        <div class=\"rst-content\">\n          <div role=\"navigation\" aria-label=\"breadcrumbs navigation\">\n  <ul class=\"wy-breadcrumbs\">\n    <li><a href=\"../index.html\">Docs</a> &raquo;</li>\n      \n    <li>Dynamic Linker</li>\n      <li class=\"wy-breadcrumbs-aside\">\n        \n          <a href=\"../_sources/stdlib/libdl.txt\" rel=\"nofollow\"> View page source</a>\n        \n      </li>\n  </ul>\n  <hr/>\n</div>\n          <div role=\"main\" class=\"document\">\n            \n  <span class=\"target\" id=\"module-Libdl\"></span><div class=\"section\" id=\"dynamic-linker\">\n<h1>Dynamic Linker<a class=\"headerlink\" href=\"#dynamic-linker\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<dl class=\"function\">\n<dt id=\"Libdl.dlopen\">\n<code class=\"descname\">dlopen</code><span class=\"sig-paren\">(</span><em>libfile::AbstractString</em><span class=\"optional\">[</span>, <em>flags::Integer</em><span class=\"optional\">]</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Libdl.dlopen\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Load a shared library, returning an opaque handle.</p>\n<p>The optional flags argument is a bitwise-or of zero or more of <code class=\"docutils literal\"><span class=\"pre\">RTLD_LOCAL</span></code>, <code class=\"docutils literal\"><span class=\"pre\">RTLD_GLOBAL</span></code>, <code class=\"docutils literal\"><span class=\"pre\">RTLD_LAZY</span></code>, <code class=\"docutils literal\"><span class=\"pre\">RTLD_NOW</span></code>, <code class=\"docutils literal\"><span class=\"pre\">RTLD_NODELETE</span></code>, <code class=\"docutils literal\"><span class=\"pre\">RTLD_NOLOAD</span></code>, <code class=\"docutils literal\"><span class=\"pre\">RTLD_DEEPBIND</span></code>, and <code class=\"docutils literal\"><span class=\"pre\">RTLD_FIRST</span></code>. These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default <code class=\"docutils literal\"><span class=\"pre\">dlopen</span></code> flags are <code class=\"docutils literal\"><span class=\"pre\">RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL</span></code> while on other platforms the defaults are <code class=\"docutils literal\"><span class=\"pre\">RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL</span></code>. An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance <code class=\"docutils literal\"><span class=\"pre\">RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL</span></code> allows the library&#8217;s symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Libdl.dlopen_e\">\n<code class=\"descname\">dlopen_e</code><span class=\"sig-paren\">(</span><em>libfile::AbstractString</em><span class=\"optional\">[</span>, <em>flags::Integer</em><span class=\"optional\">]</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Libdl.dlopen_e\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Similar to <a class=\"reference internal\" href=\"#Libdl.dlopen\" title=\"Libdl.dlopen\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">dlopen()</span></code></a>, except returns a <code class=\"docutils literal\"><span class=\"pre\">NULL</span></code> pointer instead of raising errors.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Libdl.RTLD_DEEPBIND\">\n<code class=\"descname\">RTLD_DEEPBIND</code><a class=\"headerlink\" href=\"#Libdl.RTLD_DEEPBIND\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Enum constant for <a class=\"reference internal\" href=\"#Libdl.dlopen\" title=\"Libdl.dlopen\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">dlopen()</span></code></a>. See your platform man page for details, if applicable.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Libdl.RTLD_FIRST\">\n<code class=\"descname\">RTLD_FIRST</code><a class=\"headerlink\" href=\"#Libdl.RTLD_FIRST\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Enum constant for <a class=\"reference internal\" href=\"#Libdl.dlopen\" title=\"Libdl.dlopen\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">dlopen()</span></code></a>. See your platform man page for details, if applicable.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Libdl.RTLD_GLOBAL\">\n<code class=\"descname\">RTLD_GLOBAL</code><a class=\"headerlink\" href=\"#Libdl.RTLD_GLOBAL\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Enum constant for <a class=\"reference internal\" href=\"#Libdl.dlopen\" title=\"Libdl.dlopen\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">dlopen()</span></code></a>. See your platform man page for details, if applicable.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Libdl.RTLD_LAZY\">\n<code class=\"descname\">RTLD_LAZY</code><a class=\"headerlink\" href=\"#Libdl.RTLD_LAZY\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Enum constant for <a class=\"reference internal\" href=\"#Libdl.dlopen\" title=\"Libdl.dlopen\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">dlopen()</span></code></a>. See your platform man page for details, if applicable.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Libdl.RTLD_LOCAL\">\n<code class=\"descname\">RTLD_LOCAL</code><a class=\"headerlink\" href=\"#Libdl.RTLD_LOCAL\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Enum constant for <a class=\"reference internal\" href=\"#Libdl.dlopen\" title=\"Libdl.dlopen\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">dlopen()</span></code></a>. See your platform man page for details, if applicable.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Libdl.RTLD_NODELETE\">\n<code class=\"descname\">RTLD_NODELETE</code><a class=\"headerlink\" href=\"#Libdl.RTLD_NODELETE\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Enum constant for <a class=\"reference internal\" href=\"#Libdl.dlopen\" title=\"Libdl.dlopen\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">dlopen()</span></code></a>. See your platform man page for details, if applicable.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Libdl.RTLD_NOLOAD\">\n<code class=\"descname\">RTLD_NOLOAD</code><a class=\"headerlink\" href=\"#Libdl.RTLD_NOLOAD\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Enum constant for <a class=\"reference internal\" href=\"#Libdl.dlopen\" title=\"Libdl.dlopen\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">dlopen()</span></code></a>. See your platform man page for details, if applicable.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Libdl.RTLD_NOW\">\n<code class=\"descname\">RTLD_NOW</code><a class=\"headerlink\" href=\"#Libdl.RTLD_NOW\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Enum constant for <a class=\"reference internal\" href=\"#Libdl.dlopen\" title=\"Libdl.dlopen\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">dlopen()</span></code></a>. See your platform man page for details, if applicable.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Libdl.dlsym\">\n<code class=\"descname\">dlsym</code><span class=\"sig-paren\">(</span><em>handle</em>, <em>sym</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Libdl.dlsym\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Look up a symbol from a shared library handle, return callable function pointer on success.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Libdl.dlsym_e\">\n<code class=\"descname\">dlsym_e</code><span class=\"sig-paren\">(</span><em>handle</em>, <em>sym</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Libdl.dlsym_e\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Look up a symbol from a shared library handle, silently return <code class=\"docutils literal\"><span class=\"pre\">NULL</span></code> pointer on lookup failure.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Libdl.dlclose\">\n<code class=\"descname\">dlclose</code><span class=\"sig-paren\">(</span><em>handle</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Libdl.dlclose\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Close shared library referenced by handle.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Libdl.dlext\">\n<code class=\"descname\">dlext</code><a class=\"headerlink\" href=\"#Libdl.dlext\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>File extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Libdl.find_library\">\n<code class=\"descname\">find_library</code><span class=\"sig-paren\">(</span><em>names</em>, <em>locations</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Libdl.find_library\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Searches for the first library in <code class=\"docutils literal\"><span class=\"pre\">names</span></code> in the paths in the <code class=\"docutils literal\"><span class=\"pre\">locations</span></code> list, <code class=\"docutils literal\"><span class=\"pre\">DL_LOAD_PATH</span></code>, or system library paths (in that order) which can successfully be dlopen&#8217;d. On success, the return value will be one of the names (potentially prefixed by one of the paths in locations). This string can be assigned to a <code class=\"docutils literal\"><span class=\"pre\">global</span> <span class=\"pre\">const</span></code> and used as the library name in future <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code>&#8216;s. On failure, it returns the empty string.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Libdl.DL_LOAD_PATH\">\n<code class=\"descname\">DL_LOAD_PATH</code><a class=\"headerlink\" href=\"#Libdl.DL_LOAD_PATH\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>When calling <code class=\"docutils literal\"><span class=\"pre\">dlopen</span></code>, the paths in this list will be searched first, in order, before searching the\nsystem locations for a valid library handle.</p>\n</dd></dl>\n\n</div>\n\n\n          </div>\n          <footer>\n  \n\n  <hr/>\n\n  <div role=\"contentinfo\">\n    <p>\n    </p>\n  </div>\n\n  <a href=\"https://github.com/snide/sphinx_rtd_theme\">Sphinx theme</a> provided by <a href=\"https://readthedocs.org\">Read the Docs</a>\n</footer>\n        </div>\n      </div>\n\n    </section>\n\n  </div>\n  \n\n  \n\n    <script type=\"text/javascript\">\n        var DOCUMENTATION_OPTIONS = {\n            URL_ROOT:'../',\n            VERSION:'0.4.5',\n            COLLAPSE_INDEX:false,\n            FILE_SUFFIX:'.html',\n            HAS_SOURCE:  true\n        };\n    </script>\n      <script type=\"text/javascript\" src=\"../_static/jquery.js\"></script>\n      <script type=\"text/javascript\" src=\"../_static/underscore.js\"></script>\n      <script type=\"text/javascript\" src=\"../_static/doctools.js\"></script>\n      <script type=\"text/javascript\" src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>\n\n  \n\n  \n  \n    <script type=\"text/javascript\" src=\"../_static/js/theme.js\"></script>\n  \n\n  \n  \n  <script type=\"text/javascript\">\n      jQuery(function () {\n          SphinxRtdTheme.StickyNav.enable();\n      });\n  </script>\n   \n\n</body>\n</html>",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/stdlib/c.html": "\n\n<!DOCTYPE html>\n<!--[if IE 8]><html class=\"no-js lt-ie9\" lang=\"en\" > <![endif]-->\n<!--[if gt IE 8]><!--> <html class=\"no-js\" lang=\"en\" > <!--<![endif]-->\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  \n  <title>C Interface &mdash; Julia Language 0.4.5 documentation</title>\n  \n\n  \n  \n\n  \n  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>\n\n  \n  \n    \n\n  \n\n  \n  \n    <link rel=\"stylesheet\" href=\"../_static/julia.css\" type=\"text/css\" />\n  \n\n  \n    <link rel=\"stylesheet\" href=\"../_static/julia.css\" type=\"text/css\" />\n  \n    <link rel=\"top\" title=\"Julia Language 0.4.5 documentation\" href=\"../index.html\"/>\n        <link rel=\"next\" title=\"Profiling\" href=\"profile.html\"/>\n        <link rel=\"prev\" title=\"Unit and Functional Testing\" href=\"test.html\"/> \n\n  \n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js\"></script>\n\n</head>\n\n<body class=\"wy-body-for-nav\" role=\"document\">\n\n  <div class=\"wy-grid-for-nav\">\n\n    \n    <nav data-toggle=\"wy-nav-shift\" class=\"wy-nav-side\">\n      <div class=\"wy-side-nav-search\">\n        <a href=\"http://julialang.org/\"><img src=\"../_static/julia-logo.svg\" class=\"logo\"></a>\n        <!--\n        <a href=\"../index.html\" class=\"fa fa-home\"> Julia Language</a>\n        -->\n        <div role=\"search\">\n  <form id =\"rtd-search-form\" class=\"wy-form\" action=\"../search.html\" method=\"get\">\n    <input type=\"text\" name=\"q\" placeholder=\"Search docs\" />\n    <input type=\"hidden\" name=\"check_keywords\" value=\"yes\" />\n    <input type=\"hidden\" name=\"area\" value=\"default\" />\n  </form>\n</div>\n      </div>\n\n      <div class=\"wy-menu wy-menu-vertical\" data-spy=\"affix\" role=\"navigation\" aria-label=\"main navigation\">\n        \n        \n            <ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/introduction.html\">Introduction</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/getting-started.html\">Getting Started</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/getting-started.html#resources\">Resources</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/variables.html\">Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables.html#allowed-variable-names\">Allowed Variable Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables.html#stylistic-conventions\">Stylistic Conventions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html\">Integers and Floating-Point Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#integers\">Integers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#floating-point-numbers\">Floating-Point Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#arbitrary-precision-arithmetic\">Arbitrary Precision Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#numeric-literal-coefficients\">Numeric Literal Coefficients</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#literal-zero-and-one\">Literal zero and one</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html\">Mathematical Operations and Elementary Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#arithmetic-operators\">Arithmetic Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#bitwise-operators\">Bitwise Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#updating-operators\">Updating operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#numeric-comparisons\">Numeric Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#numerical-conversions\">Numerical Conversions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#elementary-functions\">Elementary Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/complex-and-rational-numbers.html\">Complex and Rational Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/complex-and-rational-numbers.html#complex-numbers\">Complex Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/complex-and-rational-numbers.html#rational-numbers\">Rational Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/strings.html\">Strings</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#characters\">Characters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#string-basics\">String Basics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#unicode-and-utf-8\">Unicode and UTF-8</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#triple-quoted-string-literals\">Triple-Quoted String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#common-operations\">Common Operations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#regular-expressions\">Regular Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#id3\">Byte Array Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#version-number-literals\">Version Number Literals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/functions.html\">Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#argument-passing-behavior\">Argument Passing Behavior</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#the-return-keyword\">The <code class=\"docutils literal\"><span class=\"pre\">return</span></code> Keyword</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#operators-are-functions\">Operators Are Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#operators-with-special-names\">Operators With Special Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#anonymous-functions\">Anonymous Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#multiple-return-values\">Multiple Return Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#varargs-functions\">Varargs Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#optional-arguments\">Optional Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#keyword-arguments\">Keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#evaluation-scope-of-default-values\">Evaluation Scope of Default Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#do-block-syntax-for-function-arguments\">Do-Block Syntax for Function Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#further-reading\">Further Reading</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/control-flow.html\">Control Flow</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#compound-expressions\">Compound Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#conditional-evaluation\">Conditional Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#short-circuit-evaluation\">Short-Circuit Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#repeated-evaluation-loops\">Repeated Evaluation: Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#exception-handling\">Exception Handling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#tasks-aka-coroutines\">Tasks (aka Coroutines)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html\">Scope of Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html#global-scope\">Global Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html#local-scope\">Local Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html#constants\">Constants</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/types.html\">Types</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#type-declarations\">Type Declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#abstract-types\">Abstract Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#bits-types\">Bits Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#composite-types\">Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#immutable-composite-types\">Immutable Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#declared-types\">Declared Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#type-unions\">Type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#man-parametric-types\">Parametric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#type-aliases\">Type Aliases</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#operations-on-types\">Operations on Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#value-types\">&#8220;Value types&#8221;</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#nullable-types-representing-missing-values\">Nullable Types: Representing Missing Values</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/methods.html\">Methods</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#defining-methods\">Defining Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#method-ambiguities\">Method Ambiguities</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#parametric-methods\">Parametric Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#note-on-optional-and-keyword-arguments\">Note on Optional and keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#call-overloading-and-function-like-objects\">Call overloading and function-like objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#empty-generic-functions\">Empty generic functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/constructors.html\">Constructors</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#outer-constructor-methods\">Outer Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#inner-constructor-methods\">Inner Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#incomplete-initialization\">Incomplete Initialization</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#parametric-constructors\">Parametric Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#case-study-rational\">Case Study: Rational</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#constructors-call-and-conversion\">Constructors, Call, and Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#outer-only-constructors\">Outer-only constructors</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/conversion-and-promotion.html\">Conversion and Promotion</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/conversion-and-promotion.html#conversion\">Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/conversion-and-promotion.html#promotion\">Promotion</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/interfaces.html\">Interfaces</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interfaces.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interfaces.html#indexing\">Indexing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interfaces.html#abstract-arrays\">Abstract Arrays</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/modules.html\">Modules</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/modules.html#summary-of-module-usage\">Summary of module usage</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/documentation.html\">Documentation</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#accessing-documentation\">Accessing Documentation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#functions-methods\">Functions &amp; Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#advanced-usage\">Advanced Usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#syntax-guide\">Syntax Guide</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#markdown-syntax-notes\">Markdown Syntax Notes</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html\">Metaprogramming</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#program-representation\">Program representation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#expressions-and-evaluation\">Expressions and evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#macros\">Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#code-generation\">Code Generation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#generated-functions\">Generated functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/arrays.html\">Multi-dimensional Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/arrays.html#arrays\">Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/arrays.html#sparse-matrices\">Sparse Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/linear-algebra.html\">Linear algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/linear-algebra.html#matrix-factorizations\">Matrix factorizations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/linear-algebra.html#special-matrices\">Special matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html\">Networking and Streams</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#basic-stream-i-o\">Basic Stream I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#working-with-files\">Working with Files</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#a-simple-tcp-example\">A simple TCP example</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#resolving-ip-addresses\">Resolving IP Addresses</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html\">Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#code-availability-and-loading-packages\">Code Availability and Loading Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#data-movement\">Data Movement</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#parallel-map-and-loops\">Parallel Map and Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#synchronization-with-remote-references\">Synchronization With Remote References</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#scheduling\">Scheduling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#channels\">Channels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#remoterefs-and-abstractchannels\">RemoteRefs and AbstractChannels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#shared-arrays\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#distributed-garbage-collection\">Distributed Garbage Collection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#clustermanagers\">ClusterManagers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#cluster-managers-with-custom-transports\">Cluster Managers with custom transports</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#specifying-network-topology-experimental\">Specifying network topology (Experimental)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/dates.html\">Date and DateTime</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#durations-comparisons\">Durations/Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#accessor-functions\">Accessor Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#query-functions\">Query Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#timetype-period-arithmetic\">TimeType-Period Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#adjuster-functions\">Adjuster Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#period-types\">Period Types</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html\">Running External Programs</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html#quoting\">Quoting</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html#pipelines\">Pipelines</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html\">Calling C and Fortran Code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#creating-c-compatible-julia-function-pointers\">Creating C-Compatible Julia Function Pointers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#mapping-c-types-to-julia\">Mapping C Types to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#mapping-c-functions-to-julia\">Mapping C Functions to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#garbage-collection-safety\">Garbage Collection Safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#non-constant-function-specifications\">Non-constant Function Specifications</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#indirect-calls\">Indirect Calls</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#calling-convention\">Calling Convention</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#accessing-global-variables\">Accessing Global Variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#accessing-data-through-a-pointer\">Accessing Data through a Pointer</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#thread-safety\">Thread-safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#more-about-callbacks\">More About Callbacks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#c\">C++</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#handling-operating-system-variation\">Handling Operating System Variation</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html\">Interacting With Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html#the-different-prompt-modes\">The different prompt modes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html#key-bindings\">Key bindings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html#tab-completion\">Tab completion</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/embedding.html\">Embedding Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#high-level-embedding\">High-Level Embedding</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#converting-types\">Converting Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#calling-julia-functions\">Calling Julia Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#memory-management\">Memory Management</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#working-with-arrays\">Working with Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#exceptions\">Exceptions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/packages.html\">Packages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#package-status\">Package Status</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#adding-and-removing-packages\">Adding and Removing Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#offline-installation-of-packages\">Offline Installation of Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#installing-unregistered-packages\">Installing Unregistered Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#updating-packages\">Updating Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#checkout-pin-and-free\">Checkout, Pin and Free</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#custom-metadata-repository\">Custom METADATA Repository</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/packages.html#package-development\">Package Development</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#initial-setup\">Initial Setup</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#making-changes-to-an-existing-package\">Making changes to an existing package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#creating-a-new-package\">Creating a new Package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#fixing-package-requirements\">Fixing Package Requirements</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#man-package-requirements\">Requirements Specification</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/profile.html\">Profiling</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#basic-usage\">Basic usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#accumulation-and-clearing\">Accumulation and clearing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#options-for-controlling-the-display-of-profile-results\">Options for controlling the display of profile results</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#configuration\">Configuration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/profile.html#memory-allocation-analysis\">Memory allocation analysis</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/performance-tips.html\">Performance Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-global-variables\">Avoid global variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#measure-performance-with-time-and-pay-attention-to-memory-allocation\">Measure performance with <code class=\"docutils literal\"><span class=\"pre\">&#64;time</span></code> and pay attention to memory allocation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#tools\">Tools</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-containers-with-abstract-type-parameters\">Avoid containers with abstract type parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#type-declarations\">Type declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#break-functions-into-multiple-definitions\">Break functions into multiple definitions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#write-type-stable-functions\">Write &#8220;type-stable&#8221; functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-changing-the-type-of-a-variable\">Avoid changing the type of a variable</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#separate-kernel-functions\">Separate kernel functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#access-arrays-in-memory-order-along-columns\">Access arrays in memory order, along columns</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#pre-allocating-outputs\">Pre-allocating outputs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-string-interpolation-for-i-o\">Avoid string interpolation for I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#optimize-network-i-o-during-parallel-execution\">Optimize network I/O during parallel execution</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#fix-deprecation-warnings\">Fix deprecation warnings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#tweaks\">Tweaks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#performance-annotations\">Performance Annotations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#treat-subnormal-numbers-as-zeros\">Treat Subnormal Numbers as Zeros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#code-warntype\"><code class=\"docutils literal\"><span class=\"pre\">&#64;code_warntype</span></code></a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/workflow-tips.html\">Workflow Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/workflow-tips.html#repl-based-workflow\">REPL-based workflow</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/workflow-tips.html#browser-based-workflow\">Browser-based workflow</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/style-guide.html\">Style Guide</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#write-functions-not-just-scripts\">Write functions, not just scripts</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-writing-overly-specific-types\">Avoid writing overly-specific types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#handle-excess-argument-diversity-in-the-caller\">Handle excess argument diversity in the caller</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#append-to-names-of-functions-that-modify-their-arguments\">Append <code class=\"docutils literal\"><span class=\"pre\">!</span></code> to names of functions that modify their arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-strange-type-unions\">Avoid strange type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-type-unions-in-fields\">Avoid type Unions in fields</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-elaborate-container-types\">Avoid elaborate container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#use-naming-conventions-consistent-with-julia-s-base\">Use naming conventions consistent with Julia&#8217;s <code class=\"docutils literal\"><span class=\"pre\">base/</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overuse-try-catch\">Don&#8217;t overuse try-catch</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-parenthesize-conditions\">Don&#8217;t parenthesize conditions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overuse\">Don&#8217;t overuse ...</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-use-unnecessary-static-parameters\">Don&#8217;t use unnecessary static parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-confusion-about-whether-something-is-an-instance-or-a-type\">Avoid confusion about whether something is an instance or a type</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overuse-macros\">Don&#8217;t overuse macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-expose-unsafe-operations-at-the-interface-level\">Don&#8217;t expose unsafe operations at the interface level</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overload-methods-of-base-container-types\">Don&#8217;t overload methods of base container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#be-careful-with-type-equality\">Be careful with type equality</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#do-not-write-x-f-x\">Do not write <code class=\"docutils literal\"><span class=\"pre\">x-&gt;f(x)</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible\">Avoid using floats for numeric literals in generic code when possible</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/faq.html\">Frequently Asked Questions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#sessions-and-the-repl\">Sessions and the REPL</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#functions\">Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#types-type-declarations-and-constructors\">Types, type declarations, and constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#packages-and-modules\">Packages and Modules</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#nothingness-and-missing-values\">Nothingness and missing values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#memory\">Memory</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#asynchronous-io-and-concurrent-synchronous-writes\">Asynchronous IO and concurrent synchronous writes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#julia-releases\">Julia Releases</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html\">Noteworthy Differences from other Languages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-matlab\">Noteworthy differences from MATLAB</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-r\">Noteworthy differences from R</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-python\">Noteworthy differences from Python</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-c-c\">Noteworthy differences from C/C++</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/unicode-input.html\">Unicode Input</a></li>\n</ul>\n<ul class=\"current\">\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"base.html\">Essentials</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#introduction\">Introduction</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#getting-around\">Getting Around</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#all-objects\">All Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#types\">Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#generic-functions\">Generic Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#syntax\">Syntax</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#nullables\">Nullables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#system\">System</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#errors\">Errors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#events\">Events</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#reflection\">Reflection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#internals\">Internals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"collections.html\">Collections and Data Structures</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#general-collections\">General Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#iterable-collections\">Iterable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#indexable-collections\">Indexable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#associative-collections\">Associative Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#set-like-collections\">Set-Like Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#dequeues\">Dequeues</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#priorityqueue\">PriorityQueue</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#heap-functions\">Heap Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"math.html\">Mathematics</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#mathematical-operators\">Mathematical Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#mathematical-functions\">Mathematical Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#statistics\">Statistics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#signal-processing\">Signal Processing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#numerical-integration\">Numerical Integration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"numbers.html\">Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#standard-numeric-types\">Standard Numeric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#data-formats\">Data Formats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#general-number-functions-and-constants\">General Number Functions and Constants</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#bigfloats\">BigFloats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#random-numbers\">Random Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"strings.html\">Strings</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"arrays.html\">Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#basic-functions\">Basic functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#mathematical-operators-and-functions\">Mathematical operators and functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#indexing-assignment-and-concatenation\">Indexing, Assignment, and Concatenation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#array-functions\">Array functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#combinatorics\">Combinatorics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#bitarrays\">BitArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#sparse-matrices\">Sparse Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"parallel.html\">Tasks and Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#tasks\">Tasks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#general-parallel-computing-support\">General Parallel Computing Support</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#shared-arrays\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#cluster-manager-interface\">Cluster Manager Interface</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"linalg.html\">Linear Algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linalg.html#module-Base.LinAlg\">Standard Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linalg.html#module-Base.LinAlg.BLAS\">BLAS Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linalg.html#module-Base.LinAlg.LAPACK\">LAPACK Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"constants.html\">Constants</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"file.html\">Filesystem</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"io-network.html\">I/O and Network</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#general-i-o\">General I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#multimedia-i-o\">Multimedia I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#memory-mapped-i-o\">Memory-mapped I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#network-i-o\">Network I/O</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"punctuation.html\">Punctuation</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"sort.html\">Sorting and Related Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sort.html#sorting-functions\">Sorting Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sort.html#order-related-functions\">Order-Related Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sort.html#sorting-algorithms\">Sorting Algorithms</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"pkg.html\">Package Manager Functions</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"dates.html\">Dates and Time</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#dates-and-time-types\">Dates and Time Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#dates-functions\">Dates Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"test.html\">Unit and Functional Testing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#testing-base-julia\">Testing Base Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#test-framework\">Test Framework</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#handlers\">Handlers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#macros\">Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#functions\">Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1 current\"><a class=\"current reference internal\" href=\"\">C Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"#llvm-interface\">LLVM Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"profile.html\">Profiling</a></li>\n</ul>\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/reflection.html\">Reflection and introspection</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/julia.html\">Documentation of Julia&#8217;s Internals</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/init.html\">Initialization of the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/eval.html\">Eval of Julia code</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/ast.html\">Julia ASTs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/types.html\">More about types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/object.html\">Memory layout of Julia Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/cartesian.html\">Base.Cartesian</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/meta.html\">Talking to the compiler (the <code class=\"docutils literal\"><span class=\"pre\">:meta</span></code> mechanism)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/subarrays.html\">SubArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/sysimg.html\">System Image Building</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/llvm.html\">Working with LLVM</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/stdio.html\">printf() and stdio in the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/promote-op.html\">Operator-sensitive promotion</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/C.html\">Developing/debugging Julia&#8217;s C code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/backtraces.html\">Reporting and analyzing crashes (segfaults)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/debuggingtips.html\">gdb debugging tips</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/valgrind.html\">Using Valgrind with Julia</a></li>\n</ul>\n</li>\n</ul>\n\n        \n      </div>\n      &nbsp;\n    </nav>\n\n    <section data-toggle=\"wy-nav-shift\" class=\"wy-nav-content-wrap\">\n\n      \n      <nav class=\"wy-nav-top\" role=\"navigation\" aria-label=\"top navigation\">\n        <i data-toggle=\"wy-nav-top\" class=\"fa fa-bars\"></i>\n        <a href=\"../index.html\">Julia Language</a>\n      </nav>\n\n\n      \n      <div class=\"wy-nav-content\">\n        <div class=\"rst-content\">\n          <div role=\"navigation\" aria-label=\"breadcrumbs navigation\">\n  <ul class=\"wy-breadcrumbs\">\n    <li><a href=\"../index.html\">Docs</a> &raquo;</li>\n      \n    <li>C Interface</li>\n      <li class=\"wy-breadcrumbs-aside\">\n        \n          <a href=\"../_sources/stdlib/c.txt\" rel=\"nofollow\"> View page source</a>\n        \n      </li>\n  </ul>\n  <hr/>\n</div>\n          <div role=\"main\" class=\"document\">\n            \n  <div class=\"section\" id=\"c-interface\">\n<h1>C Interface<a class=\"headerlink\" href=\"#c-interface\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<dl class=\"function\">\n<dt id=\"Base.ccall\">\n<code class=\"descname\">ccall</code><span class=\"sig-paren\">(</span><em>(symbol</em>, <em>library) or function_pointer</em>, <em>ReturnType</em>, <em>(ArgumentType1</em>, <em>...)</em>, <em>ArgumentValue1</em>, <em>...</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.ccall\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Call function in C-exported shared library, specified by <code class=\"docutils literal\"><span class=\"pre\">(function</span> <span class=\"pre\">name,</span> <span class=\"pre\">library)</span></code> tuple, where each component is a string or symbol.</p>\n<p>Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression. Alternatively, <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code> may also be used to call a function pointer, such as one returned by <code class=\"docutils literal\"><span class=\"pre\">dlsym</span></code>.</p>\n<p>Each <code class=\"docutils literal\"><span class=\"pre\">ArgumentValue</span></code> to the <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code> will be converted to the corresponding <code class=\"docutils literal\"><span class=\"pre\">ArgumentType</span></code>, by automatic insertion of calls to <code class=\"docutils literal\"><span class=\"pre\">unsafe_convert(ArgumentType,</span> <span class=\"pre\">cconvert(ArgumentType,</span> <span class=\"pre\">ArgumentValue))</span></code>. (See also the documentation for each of these functions for further details.) In most cases, this simply results in a call to <code class=\"docutils literal\"><span class=\"pre\">convert(ArgumentType,</span> <span class=\"pre\">ArgumentValue)</span></code>.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.cglobal\">\n<code class=\"descname\">cglobal</code><span class=\"sig-paren\">(</span><em>(symbol</em>, <em>library)</em><span class=\"optional\">[</span>, <em>type=Void</em><span class=\"optional\">]</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.cglobal\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Obtain a pointer to a global variable in a C-exported shared library, specified exactly as in <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code>. Returns a <code class=\"docutils literal\"><span class=\"pre\">Ptr{Type}</span></code>, defaulting to <code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code> if no Type argument is supplied. The values can be read or written by <code class=\"docutils literal\"><span class=\"pre\">unsafe_load</span></code> or <code class=\"docutils literal\"><span class=\"pre\">unsafe_store!</span></code>, respectively.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.cfunction\">\n<code class=\"descname\">cfunction</code><span class=\"sig-paren\">(</span><em>function::Function</em>, <em>ReturnType::Type</em>, <em>(ArgumentTypes...)</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.cfunction\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Generate C-callable function pointer from Julia function. Type annotation of the return value in the callback function is a must for situations where Julia cannot infer the return type automatically.</p>\n<p>For example:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">function</span><span class=\"nf\"> foo</span><span class=\"p\">()</span>\n    <span class=\"c\"># body</span>\n\n    <span class=\"n\">retval</span><span class=\"p\">::</span><span class=\"kt\">Float64</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">bar</span> <span class=\"o\">=</span> <span class=\"n\">cfunction</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"kt\">Float64</span><span class=\"p\">,</span> <span class=\"p\">())</span>\n</pre></div>\n</div>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.unsafe_convert\">\n<code class=\"descname\">unsafe_convert</code><span class=\"sig-paren\">(</span><em>T</em>, <em>x</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.unsafe_convert\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Convert <code class=\"docutils literal\"><span class=\"pre\">x</span></code> to a value of type <code class=\"docutils literal\"><span class=\"pre\">T</span></code></p>\n<p>In cases where <code class=\"docutils literal\"><span class=\"pre\">convert</span></code> would need to take a Julia object and turn it into a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code>, this function should be used to define and perform that conversion.</p>\n<p>Be careful to ensure that a julia reference to <code class=\"docutils literal\"><span class=\"pre\">x</span></code> exists as long as the result of this function will be used. Accordingly, the argument <code class=\"docutils literal\"><span class=\"pre\">x</span></code> to this function should never be an expression, only a variable name or field reference. For example, <code class=\"docutils literal\"><span class=\"pre\">x=a.b.c</span></code> is acceptable, but <code class=\"docutils literal\"><span class=\"pre\">x=[a,b,c]</span></code> is not.</p>\n<p>The <code class=\"docutils literal\"><span class=\"pre\">unsafe</span></code> prefix on this function indicates that using the result of this function after the <code class=\"docutils literal\"><span class=\"pre\">x</span></code> argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.cconvert\">\n<code class=\"descname\">cconvert</code><span class=\"sig-paren\">(</span><em>T</em>, <em>x</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.cconvert\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Convert <code class=\"docutils literal\"><span class=\"pre\">x</span></code> to a value of type <code class=\"docutils literal\"><span class=\"pre\">T</span></code>, typically by calling <code class=\"docutils literal\"><span class=\"pre\">convert(T,x)</span></code></p>\n<p>In cases where <code class=\"docutils literal\"><span class=\"pre\">x</span></code> cannot be safely converted to <code class=\"docutils literal\"><span class=\"pre\">T</span></code>, unlike <code class=\"docutils literal\"><span class=\"pre\">convert</span></code>, <code class=\"docutils literal\"><span class=\"pre\">cconvert</span></code> may return an object of a type different from <code class=\"docutils literal\"><span class=\"pre\">T</span></code>, which however is suitable for <code class=\"docutils literal\"><span class=\"pre\">unsafe_convert</span></code> to handle.</p>\n<p>Neither <code class=\"docutils literal\"><span class=\"pre\">convert</span></code> nor <code class=\"docutils literal\"><span class=\"pre\">cconvert</span></code> should take a Julia object and turn it into a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code>.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.unsafe_load\">\n<code class=\"descname\">unsafe_load</code><span class=\"sig-paren\">(</span><em>p::Ptr{T}</em>, <em>i::Integer</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.unsafe_load\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Load a value of type <code class=\"docutils literal\"><span class=\"pre\">T</span></code> from the address of the ith element (1-indexed) starting at <code class=\"docutils literal\"><span class=\"pre\">p</span></code>. This is equivalent to the C expression <code class=\"docutils literal\"><span class=\"pre\">p[i-1]</span></code>.</p>\n<p>The <code class=\"docutils literal\"><span class=\"pre\">unsafe</span></code> prefix on this function indicates that no validation is performed on the pointer <code class=\"docutils literal\"><span class=\"pre\">p</span></code> to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.unsafe_store!\">\n<code class=\"descname\">unsafe_store!</code><span class=\"sig-paren\">(</span><em>p::Ptr{T}</em>, <em>x</em>, <em>i::Integer</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.unsafe_store!\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Store a value of type <code class=\"docutils literal\"><span class=\"pre\">T</span></code> to the address of the ith element (1-indexed) starting at <code class=\"docutils literal\"><span class=\"pre\">p</span></code>. This is equivalent to the C expression <code class=\"docutils literal\"><span class=\"pre\">p[i-1]</span> <span class=\"pre\">=</span> <span class=\"pre\">x</span></code>.</p>\n<p>The <code class=\"docutils literal\"><span class=\"pre\">unsafe</span></code> prefix on this function indicates that no validation is performed on the pointer <code class=\"docutils literal\"><span class=\"pre\">p</span></code> to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.unsafe_copy!\">\n<code class=\"descname\">unsafe_copy!</code><span class=\"sig-paren\">(</span><em>dest::Ptr{T}</em>, <em>src::Ptr{T}</em>, <em>N</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.unsafe_copy!\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Copy <code class=\"docutils literal\"><span class=\"pre\">N</span></code> elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.</p>\n<p>The <code class=\"docutils literal\"><span class=\"pre\">unsafe</span></code> prefix on this function indicates that no validation is performed on the pointers <code class=\"docutils literal\"><span class=\"pre\">dest</span></code> and <code class=\"docutils literal\"><span class=\"pre\">src</span></code> to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt>\n<code class=\"descname\">unsafe_copy!</code><span class=\"sig-paren\">(</span><em>dest::Array</em>, <em>do</em>, <em>src::Array</em>, <em>so</em>, <em>N</em><span class=\"sig-paren\">)</span></dt>\n<dd><p>Copy <code class=\"docutils literal\"><span class=\"pre\">N</span></code> elements from a source array to a destination, starting at offset <code class=\"docutils literal\"><span class=\"pre\">so</span></code> in the source and <code class=\"docutils literal\"><span class=\"pre\">do</span></code> in the destination (1-indexed).</p>\n<p>The <code class=\"docutils literal\"><span class=\"pre\">unsafe</span></code> prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.copy!\">\n<code class=\"descname\">copy!</code><span class=\"sig-paren\">(</span><em>dest</em>, <em>src</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.copy!\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Copy all elements from collection <code class=\"docutils literal\"><span class=\"pre\">src</span></code> to array <code class=\"docutils literal\"><span class=\"pre\">dest</span></code>. Returns <code class=\"docutils literal\"><span class=\"pre\">dest</span></code>.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt>\n<code class=\"descname\">copy!</code><span class=\"sig-paren\">(</span><em>dest</em>, <em>do</em>, <em>src</em>, <em>so</em>, <em>N</em><span class=\"sig-paren\">)</span></dt>\n<dd><p>Copy <code class=\"docutils literal\"><span class=\"pre\">N</span></code> elements from collection <code class=\"docutils literal\"><span class=\"pre\">src</span></code> starting at offset <code class=\"docutils literal\"><span class=\"pre\">so</span></code>, to array <code class=\"docutils literal\"><span class=\"pre\">dest</span></code> starting at offset <code class=\"docutils literal\"><span class=\"pre\">do</span></code>. Returns <code class=\"docutils literal\"><span class=\"pre\">dest</span></code>.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.pointer\">\n<code class=\"descname\">pointer</code><span class=\"sig-paren\">(</span><em>array</em><span class=\"optional\">[</span>, <em>index</em><span class=\"optional\">]</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.pointer\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Get the native address of an array or string element. Be careful to ensure that a julia reference to <code class=\"docutils literal\"><span class=\"pre\">a</span></code> exists as long as this pointer will be used. This function is &#8220;unsafe&#8221; like <code class=\"docutils literal\"><span class=\"pre\">unsafe_convert</span></code>.</p>\n<p>Calling <code class=\"docutils literal\"><span class=\"pre\">Ref(array[,</span> <span class=\"pre\">index])</span></code> is generally preferable to this function.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.pointer_to_array\">\n<code class=\"descname\">pointer_to_array</code><span class=\"sig-paren\">(</span><em>pointer</em>, <em>dims</em><span class=\"optional\">[</span>, <em>take_ownership::Bool</em><span class=\"optional\">]</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.pointer_to_array\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Wrap a native pointer as a Julia Array object. The pointer element type determines the array element type. <code class=\"docutils literal\"><span class=\"pre\">own</span></code> optionally specifies whether Julia should take ownership of the memory, calling <code class=\"docutils literal\"><span class=\"pre\">free</span></code> on the pointer when the array is no longer referenced.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.pointer_from_objref\">\n<code class=\"descname\">pointer_from_objref</code><span class=\"sig-paren\">(</span><em>object_instance</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.pointer_from_objref\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Get the memory address of a Julia object as a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code>. The existence of the resulting <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> will be used.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.unsafe_pointer_to_objref\">\n<code class=\"descname\">unsafe_pointer_to_objref</code><span class=\"sig-paren\">(</span><em>p::Ptr</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.unsafe_pointer_to_objref\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Convert a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered &#8220;unsafe&#8221; and should be used with care.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.disable_sigint\">\n<code class=\"descname\">disable_sigint</code><span class=\"sig-paren\">(</span><em>f::Function</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.disable_sigint\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Disable Ctrl-C handler during execution of a function, for calling external code that is not interrupt safe. Intended to be called using <code class=\"docutils literal\"><span class=\"pre\">do</span></code> block syntax as follows:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">disable_sigint</span><span class=\"p\">()</span> <span class=\"k\">do</span>\n    <span class=\"c\"># interrupt-unsafe code</span>\n    <span class=\"o\">...</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.reenable_sigint\">\n<code class=\"descname\">reenable_sigint</code><span class=\"sig-paren\">(</span><em>f::Function</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.reenable_sigint\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Re-enable Ctrl-C handler during execution of a function. Temporarily reverses the effect of <code class=\"docutils literal\"><span class=\"pre\">disable_sigint</span></code>.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.systemerror\">\n<code class=\"descname\">systemerror</code><span class=\"sig-paren\">(</span><em>sysfunc</em>, <em>iftrue</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.systemerror\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Raises a <code class=\"docutils literal\"><span class=\"pre\">SystemError</span></code> for <code class=\"docutils literal\"><span class=\"pre\">errno</span></code> with the descriptive string <code class=\"docutils literal\"><span class=\"pre\">sysfunc</span></code> if <code class=\"docutils literal\"><span class=\"pre\">iftrue</span></code> is <code class=\"docutils literal\"><span class=\"pre\">true</span></code></p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Ptr{T}\">\n<code class=\"descname\">Ptr{T}</code><a class=\"headerlink\" href=\"#Base.Ptr{T}\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>A memory address referring to data of type <code class=\"docutils literal\"><span class=\"pre\">T</span></code>.\nHowever, there is no guarantee that the memory is actually valid,\nor that it actually represents data of the specified type.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Ref{T}\">\n<code class=\"descname\">Ref{T}</code><a class=\"headerlink\" href=\"#Base.Ref{T}\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>An object that safely references data of type <code class=\"docutils literal\"><span class=\"pre\">T</span></code>.\nThis type is guaranteed to point to valid, Julia-allocated memory\nof the correct type. The underlying data is protected from freeing by\nthe garbage collector as long as the <code class=\"docutils literal\"><span class=\"pre\">Ref</span></code> itself is referenced.</p>\n<p>When passed as a <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code> argument (either as a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> or <code class=\"docutils literal\"><span class=\"pre\">Ref</span></code> type),\na <code class=\"docutils literal\"><span class=\"pre\">Ref</span></code> object will be converted to a native pointer to the data it references.</p>\n<p>There is no invalid (NULL) <code class=\"docutils literal\"><span class=\"pre\">Ref</span></code>.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cchar\">\n<code class=\"descname\">Cchar</code><a class=\"headerlink\" href=\"#Base.Cchar\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">char</span></code> c-type</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cuchar\">\n<code class=\"descname\">Cuchar</code><a class=\"headerlink\" href=\"#Base.Cuchar\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">char</span></code> c-type (UInt8)</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cshort\">\n<code class=\"descname\">Cshort</code><a class=\"headerlink\" href=\"#Base.Cshort\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">signed</span> <span class=\"pre\">short</span></code> c-type (Int16)</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cushort\">\n<code class=\"descname\">Cushort</code><a class=\"headerlink\" href=\"#Base.Cushort\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">short</span></code> c-type (UInt16)</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cint\">\n<code class=\"descname\">Cint</code><a class=\"headerlink\" href=\"#Base.Cint\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">signed</span> <span class=\"pre\">int</span></code> c-type (Int32)</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cuint\">\n<code class=\"descname\">Cuint</code><a class=\"headerlink\" href=\"#Base.Cuint\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">int</span></code> c-type (UInt32)</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Clong\">\n<code class=\"descname\">Clong</code><a class=\"headerlink\" href=\"#Base.Clong\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">signed</span> <span class=\"pre\">long</span></code> c-type</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Culong\">\n<code class=\"descname\">Culong</code><a class=\"headerlink\" href=\"#Base.Culong\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">long</span></code> c-type</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Clonglong\">\n<code class=\"descname\">Clonglong</code><a class=\"headerlink\" href=\"#Base.Clonglong\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">signed</span> <span class=\"pre\">long</span> <span class=\"pre\">long</span></code> c-type (Int64)</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Culonglong\">\n<code class=\"descname\">Culonglong</code><a class=\"headerlink\" href=\"#Base.Culonglong\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">long</span> <span class=\"pre\">long</span></code> c-type (UInt64)</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cintmax_t\">\n<code class=\"descname\">Cintmax_t</code><a class=\"headerlink\" href=\"#Base.Cintmax_t\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">intmax_t</span></code> c-type (Int64)</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cuintmax_t\">\n<code class=\"descname\">Cuintmax_t</code><a class=\"headerlink\" href=\"#Base.Cuintmax_t\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">uintmax_t</span></code> c-type (UInt64)</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Csize_t\">\n<code class=\"descname\">Csize_t</code><a class=\"headerlink\" href=\"#Base.Csize_t\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">size_t</span></code> c-type (UInt)</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cssize_t\">\n<code class=\"descname\">Cssize_t</code><a class=\"headerlink\" href=\"#Base.Cssize_t\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">ssize_t</span></code> c-type</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cptrdiff_t\">\n<code class=\"descname\">Cptrdiff_t</code><a class=\"headerlink\" href=\"#Base.Cptrdiff_t\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">ptrdiff_t</span></code> c-type (Int)</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Coff_t\">\n<code class=\"descname\">Coff_t</code><a class=\"headerlink\" href=\"#Base.Coff_t\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">off_t</span></code> c-type</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cwchar_t\">\n<code class=\"descname\">Cwchar_t</code><a class=\"headerlink\" href=\"#Base.Cwchar_t\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">wchar_t</span></code> c-type (Int32)</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cfloat\">\n<code class=\"descname\">Cfloat</code><a class=\"headerlink\" href=\"#Base.Cfloat\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">float</span></code> c-type (Float32)</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cdouble\">\n<code class=\"descname\">Cdouble</code><a class=\"headerlink\" href=\"#Base.Cdouble\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">double</span></code> c-type (Float64)</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"llvm-interface\">\n<h1>LLVM Interface<a class=\"headerlink\" href=\"#llvm-interface\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<dl class=\"function\">\n<dt id=\"Base.llvmcall\">\n<code class=\"descname\">llvmcall</code><span class=\"sig-paren\">(</span><em>IR::String</em>, <em>ReturnType</em>, <em>(ArgumentType1</em>, <em>...)</em>, <em>ArgumentValue1</em>, <em>...</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.llvmcall\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Call LLVM IR string in the first argument. Similar to an LLVM function <code class=\"docutils literal\"><span class=\"pre\">define</span></code> block, arguments are available as consecutive unnamed SSA variables (%0, %1, etc.).</p>\n<p>Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.</p>\n<p>Each <code class=\"docutils literal\"><span class=\"pre\">ArgumentValue</span></code> to <code class=\"docutils literal\"><span class=\"pre\">llvmcall</span></code> will be converted to the corresponding <code class=\"docutils literal\"><span class=\"pre\">ArgumentType</span></code>, by automatic insertion of calls to <code class=\"docutils literal\"><span class=\"pre\">unsafe_convert(ArgumentType,</span> <span class=\"pre\">cconvert(ArgumentType,</span> <span class=\"pre\">ArgumentValue))</span></code>. (see also the documentation for each of these functions for further details). In most cases, this simply results in a call to <code class=\"docutils literal\"><span class=\"pre\">convert(ArgumentType,</span> <span class=\"pre\">ArgumentValue)</span></code>.</p>\n<p>See <code class=\"docutils literal\"><span class=\"pre\">test/llvmcall.jl</span></code> for usage examples.</p>\n</dd></dl>\n\n</div>\n\n\n          </div>\n          <footer>\n  \n    <div class=\"rst-footer-buttons\" role=\"navigation\" aria-label=\"footer navigation\">\n      \n        <a href=\"profile.html\" class=\"btn btn-neutral float-right\" title=\"Profiling\">Next <span class=\"fa fa-arrow-circle-right\"></span></a>\n      \n      \n        <a href=\"test.html\" class=\"btn btn-neutral\" title=\"Unit and Functional Testing\"><span class=\"fa fa-arrow-circle-left\"></span> Previous</a>\n      \n    </div>\n  \n\n  <hr/>\n\n  <div role=\"contentinfo\">\n    <p>\n    </p>\n  </div>\n\n  <a href=\"https://github.com/snide/sphinx_rtd_theme\">Sphinx theme</a> provided by <a href=\"https://readthedocs.org\">Read the Docs</a>\n</footer>\n        </div>\n      </div>\n\n    </section>\n\n  </div>\n  \n\n  \n\n    <script type=\"text/javascript\">\n        var DOCUMENTATION_OPTIONS = {\n            URL_ROOT:'../',\n            VERSION:'0.4.5',\n            COLLAPSE_INDEX:false,\n            FILE_SUFFIX:'.html',\n            HAS_SOURCE:  true\n        };\n    </script>\n      <script type=\"text/javascript\" src=\"../_static/jquery.js\"></script>\n      <script type=\"text/javascript\" src=\"../_static/underscore.js\"></script>\n      <script type=\"text/javascript\" src=\"../_static/doctools.js\"></script>\n      <script type=\"text/javascript\" src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>\n\n  \n\n  \n  \n    <script type=\"text/javascript\" src=\"../_static/js/theme.js\"></script>\n  \n\n  \n  \n  <script type=\"text/javascript\">\n      jQuery(function () {\n          SphinxRtdTheme.StickyNav.enable();\n      });\n  </script>\n   \n\n</body>\n</html>",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/manual/calling-c-and-fortran-code.html": "\n\n<!DOCTYPE html>\n<!--[if IE 8]><html class=\"no-js lt-ie9\" lang=\"en\" > <![endif]-->\n<!--[if gt IE 8]><!--> <html class=\"no-js\" lang=\"en\" > <!--<![endif]-->\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  \n  <title>Calling C and Fortran Code &mdash; Julia Language 0.4.5 documentation</title>\n  \n\n  \n  \n\n  \n  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>\n\n  \n  \n    \n\n  \n\n  \n  \n    <link rel=\"stylesheet\" href=\"../_static/julia.css\" type=\"text/css\" />\n  \n\n  \n    <link rel=\"stylesheet\" href=\"../_static/julia.css\" type=\"text/css\" />\n  \n    <link rel=\"top\" title=\"Julia Language 0.4.5 documentation\" href=\"../index.html\"/>\n        <link rel=\"next\" title=\"Interacting With Julia\" href=\"interacting-with-julia.html\"/>\n        <link rel=\"prev\" title=\"Running External Programs\" href=\"running-external-programs.html\"/> \n\n  \n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js\"></script>\n\n</head>\n\n<body class=\"wy-body-for-nav\" role=\"document\">\n\n  <div class=\"wy-grid-for-nav\">\n\n    \n    <nav data-toggle=\"wy-nav-shift\" class=\"wy-nav-side\">\n      <div class=\"wy-side-nav-search\">\n        <a href=\"http://julialang.org/\"><img src=\"../_static/julia-logo.svg\" class=\"logo\"></a>\n        <!--\n        <a href=\"../index.html\" class=\"fa fa-home\"> Julia Language</a>\n        -->\n        <div role=\"search\">\n  <form id =\"rtd-search-form\" class=\"wy-form\" action=\"../search.html\" method=\"get\">\n    <input type=\"text\" name=\"q\" placeholder=\"Search docs\" />\n    <input type=\"hidden\" name=\"check_keywords\" value=\"yes\" />\n    <input type=\"hidden\" name=\"area\" value=\"default\" />\n  </form>\n</div>\n      </div>\n\n      <div class=\"wy-menu wy-menu-vertical\" data-spy=\"affix\" role=\"navigation\" aria-label=\"main navigation\">\n        \n        \n            <ul class=\"current\">\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"introduction.html\">Introduction</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"getting-started.html\">Getting Started</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"getting-started.html#resources\">Resources</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"variables.html\">Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"variables.html#allowed-variable-names\">Allowed Variable Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"variables.html#stylistic-conventions\">Stylistic Conventions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"integers-and-floating-point-numbers.html\">Integers and Floating-Point Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"integers-and-floating-point-numbers.html#integers\">Integers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"integers-and-floating-point-numbers.html#floating-point-numbers\">Floating-Point Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"integers-and-floating-point-numbers.html#arbitrary-precision-arithmetic\">Arbitrary Precision Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"integers-and-floating-point-numbers.html#numeric-literal-coefficients\">Numeric Literal Coefficients</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"integers-and-floating-point-numbers.html#literal-zero-and-one\">Literal zero and one</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"mathematical-operations.html\">Mathematical Operations and Elementary Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"mathematical-operations.html#arithmetic-operators\">Arithmetic Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"mathematical-operations.html#bitwise-operators\">Bitwise Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"mathematical-operations.html#updating-operators\">Updating operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"mathematical-operations.html#numeric-comparisons\">Numeric Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"mathematical-operations.html#numerical-conversions\">Numerical Conversions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"mathematical-operations.html#elementary-functions\">Elementary Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"complex-and-rational-numbers.html\">Complex and Rational Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"complex-and-rational-numbers.html#complex-numbers\">Complex Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"complex-and-rational-numbers.html#rational-numbers\">Rational Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"strings.html\">Strings</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#characters\">Characters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#string-basics\">String Basics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#unicode-and-utf-8\">Unicode and UTF-8</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#triple-quoted-string-literals\">Triple-Quoted String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#common-operations\">Common Operations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#regular-expressions\">Regular Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#id3\">Byte Array Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#version-number-literals\">Version Number Literals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"functions.html\">Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#argument-passing-behavior\">Argument Passing Behavior</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#the-return-keyword\">The <code class=\"docutils literal\"><span class=\"pre\">return</span></code> Keyword</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#operators-are-functions\">Operators Are Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#operators-with-special-names\">Operators With Special Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#anonymous-functions\">Anonymous Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#multiple-return-values\">Multiple Return Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#varargs-functions\">Varargs Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#optional-arguments\">Optional Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#keyword-arguments\">Keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#evaluation-scope-of-default-values\">Evaluation Scope of Default Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#do-block-syntax-for-function-arguments\">Do-Block Syntax for Function Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#further-reading\">Further Reading</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"control-flow.html\">Control Flow</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"control-flow.html#compound-expressions\">Compound Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"control-flow.html#conditional-evaluation\">Conditional Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"control-flow.html#short-circuit-evaluation\">Short-Circuit Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"control-flow.html#repeated-evaluation-loops\">Repeated Evaluation: Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"control-flow.html#exception-handling\">Exception Handling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"control-flow.html#tasks-aka-coroutines\">Tasks (aka Coroutines)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"variables-and-scoping.html\">Scope of Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"variables-and-scoping.html#global-scope\">Global Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"variables-and-scoping.html#local-scope\">Local Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"variables-and-scoping.html#constants\">Constants</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"types.html\">Types</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#type-declarations\">Type Declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#abstract-types\">Abstract Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#bits-types\">Bits Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#composite-types\">Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#immutable-composite-types\">Immutable Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#declared-types\">Declared Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#type-unions\">Type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#man-parametric-types\">Parametric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#type-aliases\">Type Aliases</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#operations-on-types\">Operations on Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#value-types\">&#8220;Value types&#8221;</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#nullable-types-representing-missing-values\">Nullable Types: Representing Missing Values</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"methods.html\">Methods</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#defining-methods\">Defining Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#method-ambiguities\">Method Ambiguities</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#parametric-methods\">Parametric Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#note-on-optional-and-keyword-arguments\">Note on Optional and keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#call-overloading-and-function-like-objects\">Call overloading and function-like objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#empty-generic-functions\">Empty generic functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"constructors.html\">Constructors</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#outer-constructor-methods\">Outer Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#inner-constructor-methods\">Inner Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#incomplete-initialization\">Incomplete Initialization</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#parametric-constructors\">Parametric Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#case-study-rational\">Case Study: Rational</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#constructors-call-and-conversion\">Constructors, Call, and Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#outer-only-constructors\">Outer-only constructors</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"conversion-and-promotion.html\">Conversion and Promotion</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"conversion-and-promotion.html#conversion\">Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"conversion-and-promotion.html#promotion\">Promotion</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"interfaces.html\">Interfaces</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interfaces.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interfaces.html#indexing\">Indexing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interfaces.html#abstract-arrays\">Abstract Arrays</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"modules.html\">Modules</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"modules.html#summary-of-module-usage\">Summary of module usage</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"documentation.html\">Documentation</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"documentation.html#accessing-documentation\">Accessing Documentation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"documentation.html#functions-methods\">Functions &amp; Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"documentation.html#advanced-usage\">Advanced Usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"documentation.html#syntax-guide\">Syntax Guide</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"documentation.html#markdown-syntax-notes\">Markdown Syntax Notes</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"metaprogramming.html\">Metaprogramming</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"metaprogramming.html#program-representation\">Program representation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"metaprogramming.html#expressions-and-evaluation\">Expressions and evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"metaprogramming.html#macros\">Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"metaprogramming.html#code-generation\">Code Generation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"metaprogramming.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"metaprogramming.html#generated-functions\">Generated functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"arrays.html\">Multi-dimensional Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#arrays\">Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#sparse-matrices\">Sparse Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"linear-algebra.html\">Linear algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linear-algebra.html#matrix-factorizations\">Matrix factorizations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linear-algebra.html#special-matrices\">Special matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"networking-and-streams.html\">Networking and Streams</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"networking-and-streams.html#basic-stream-i-o\">Basic Stream I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"networking-and-streams.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"networking-and-streams.html#working-with-files\">Working with Files</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"networking-and-streams.html#a-simple-tcp-example\">A simple TCP example</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"networking-and-streams.html#resolving-ip-addresses\">Resolving IP Addresses</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"parallel-computing.html\">Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#code-availability-and-loading-packages\">Code Availability and Loading Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#data-movement\">Data Movement</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#parallel-map-and-loops\">Parallel Map and Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#synchronization-with-remote-references\">Synchronization With Remote References</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#scheduling\">Scheduling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#channels\">Channels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#remoterefs-and-abstractchannels\">RemoteRefs and AbstractChannels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#shared-arrays\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#distributed-garbage-collection\">Distributed Garbage Collection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#clustermanagers\">ClusterManagers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#cluster-managers-with-custom-transports\">Cluster Managers with custom transports</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#specifying-network-topology-experimental\">Specifying network topology (Experimental)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"dates.html\">Date and DateTime</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#durations-comparisons\">Durations/Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#accessor-functions\">Accessor Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#query-functions\">Query Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#timetype-period-arithmetic\">TimeType-Period Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#adjuster-functions\">Adjuster Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#period-types\">Period Types</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"running-external-programs.html\">Running External Programs</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"running-external-programs.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"running-external-programs.html#quoting\">Quoting</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"running-external-programs.html#pipelines\">Pipelines</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1 current\"><a class=\"current reference internal\" href=\"\">Calling C and Fortran Code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#creating-c-compatible-julia-function-pointers\">Creating C-Compatible Julia Function Pointers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#mapping-c-types-to-julia\">Mapping C Types to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#mapping-c-functions-to-julia\">Mapping C Functions to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#garbage-collection-safety\">Garbage Collection Safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#non-constant-function-specifications\">Non-constant Function Specifications</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#indirect-calls\">Indirect Calls</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#calling-convention\">Calling Convention</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#accessing-global-variables\">Accessing Global Variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#accessing-data-through-a-pointer\">Accessing Data through a Pointer</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#thread-safety\">Thread-safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#more-about-callbacks\">More About Callbacks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#c\">C++</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#handling-operating-system-variation\">Handling Operating System Variation</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"interacting-with-julia.html\">Interacting With Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interacting-with-julia.html#the-different-prompt-modes\">The different prompt modes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interacting-with-julia.html#key-bindings\">Key bindings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interacting-with-julia.html#tab-completion\">Tab completion</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"embedding.html\">Embedding Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"embedding.html#high-level-embedding\">High-Level Embedding</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"embedding.html#converting-types\">Converting Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"embedding.html#calling-julia-functions\">Calling Julia Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"embedding.html#memory-management\">Memory Management</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"embedding.html#working-with-arrays\">Working with Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"embedding.html#exceptions\">Exceptions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"packages.html\">Packages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#package-status\">Package Status</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#adding-and-removing-packages\">Adding and Removing Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#offline-installation-of-packages\">Offline Installation of Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#installing-unregistered-packages\">Installing Unregistered Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#updating-packages\">Updating Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#checkout-pin-and-free\">Checkout, Pin and Free</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#custom-metadata-repository\">Custom METADATA Repository</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"packages.html#package-development\">Package Development</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#initial-setup\">Initial Setup</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#making-changes-to-an-existing-package\">Making changes to an existing package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#creating-a-new-package\">Creating a new Package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#fixing-package-requirements\">Fixing Package Requirements</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#man-package-requirements\">Requirements Specification</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"profile.html\">Profiling</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"profile.html#basic-usage\">Basic usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"profile.html#accumulation-and-clearing\">Accumulation and clearing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"profile.html#options-for-controlling-the-display-of-profile-results\">Options for controlling the display of profile results</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"profile.html#configuration\">Configuration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"profile.html#memory-allocation-analysis\">Memory allocation analysis</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"performance-tips.html\">Performance Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#avoid-global-variables\">Avoid global variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#measure-performance-with-time-and-pay-attention-to-memory-allocation\">Measure performance with <code class=\"docutils literal\"><span class=\"pre\">&#64;time</span></code> and pay attention to memory allocation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#tools\">Tools</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#avoid-containers-with-abstract-type-parameters\">Avoid containers with abstract type parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#type-declarations\">Type declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#break-functions-into-multiple-definitions\">Break functions into multiple definitions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#write-type-stable-functions\">Write &#8220;type-stable&#8221; functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#avoid-changing-the-type-of-a-variable\">Avoid changing the type of a variable</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#separate-kernel-functions\">Separate kernel functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#access-arrays-in-memory-order-along-columns\">Access arrays in memory order, along columns</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#pre-allocating-outputs\">Pre-allocating outputs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#avoid-string-interpolation-for-i-o\">Avoid string interpolation for I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#optimize-network-i-o-during-parallel-execution\">Optimize network I/O during parallel execution</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#fix-deprecation-warnings\">Fix deprecation warnings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#tweaks\">Tweaks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#performance-annotations\">Performance Annotations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#treat-subnormal-numbers-as-zeros\">Treat Subnormal Numbers as Zeros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#code-warntype\"><code class=\"docutils literal\"><span class=\"pre\">&#64;code_warntype</span></code></a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"workflow-tips.html\">Workflow Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"workflow-tips.html#repl-based-workflow\">REPL-based workflow</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"workflow-tips.html#browser-based-workflow\">Browser-based workflow</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"style-guide.html\">Style Guide</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#write-functions-not-just-scripts\">Write functions, not just scripts</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#avoid-writing-overly-specific-types\">Avoid writing overly-specific types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#handle-excess-argument-diversity-in-the-caller\">Handle excess argument diversity in the caller</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#append-to-names-of-functions-that-modify-their-arguments\">Append <code class=\"docutils literal\"><span class=\"pre\">!</span></code> to names of functions that modify their arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#avoid-strange-type-unions\">Avoid strange type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#avoid-type-unions-in-fields\">Avoid type Unions in fields</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#avoid-elaborate-container-types\">Avoid elaborate container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#use-naming-conventions-consistent-with-julia-s-base\">Use naming conventions consistent with Julia&#8217;s <code class=\"docutils literal\"><span class=\"pre\">base/</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-overuse-try-catch\">Don&#8217;t overuse try-catch</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-parenthesize-conditions\">Don&#8217;t parenthesize conditions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-overuse\">Don&#8217;t overuse ...</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-use-unnecessary-static-parameters\">Don&#8217;t use unnecessary static parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#avoid-confusion-about-whether-something-is-an-instance-or-a-type\">Avoid confusion about whether something is an instance or a type</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-overuse-macros\">Don&#8217;t overuse macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-expose-unsafe-operations-at-the-interface-level\">Don&#8217;t expose unsafe operations at the interface level</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-overload-methods-of-base-container-types\">Don&#8217;t overload methods of base container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#be-careful-with-type-equality\">Be careful with type equality</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#do-not-write-x-f-x\">Do not write <code class=\"docutils literal\"><span class=\"pre\">x-&gt;f(x)</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible\">Avoid using floats for numeric literals in generic code when possible</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"faq.html\">Frequently Asked Questions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#sessions-and-the-repl\">Sessions and the REPL</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#functions\">Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#types-type-declarations-and-constructors\">Types, type declarations, and constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#packages-and-modules\">Packages and Modules</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#nothingness-and-missing-values\">Nothingness and missing values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#memory\">Memory</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#asynchronous-io-and-concurrent-synchronous-writes\">Asynchronous IO and concurrent synchronous writes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#julia-releases\">Julia Releases</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"noteworthy-differences.html\">Noteworthy Differences from other Languages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"noteworthy-differences.html#noteworthy-differences-from-matlab\">Noteworthy differences from MATLAB</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"noteworthy-differences.html#noteworthy-differences-from-r\">Noteworthy differences from R</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"noteworthy-differences.html#noteworthy-differences-from-python\">Noteworthy differences from Python</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"noteworthy-differences.html#noteworthy-differences-from-c-c\">Noteworthy differences from C/C++</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"unicode-input.html\">Unicode Input</a></li>\n</ul>\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/base.html\">Essentials</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#introduction\">Introduction</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#getting-around\">Getting Around</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#all-objects\">All Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#types\">Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#generic-functions\">Generic Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#syntax\">Syntax</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#nullables\">Nullables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#system\">System</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#errors\">Errors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#events\">Events</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#reflection\">Reflection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#internals\">Internals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/collections.html\">Collections and Data Structures</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#general-collections\">General Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#iterable-collections\">Iterable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#indexable-collections\">Indexable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#associative-collections\">Associative Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#set-like-collections\">Set-Like Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#dequeues\">Dequeues</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#priorityqueue\">PriorityQueue</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#heap-functions\">Heap Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/math.html\">Mathematics</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/math.html#mathematical-operators\">Mathematical Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/math.html#mathematical-functions\">Mathematical Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/math.html#statistics\">Statistics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/math.html#signal-processing\">Signal Processing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/math.html#numerical-integration\">Numerical Integration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/numbers.html\">Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/numbers.html#standard-numeric-types\">Standard Numeric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/numbers.html#data-formats\">Data Formats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/numbers.html#general-number-functions-and-constants\">General Number Functions and Constants</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/numbers.html#bigfloats\">BigFloats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/numbers.html#random-numbers\">Random Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/strings.html\">Strings</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/arrays.html\">Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#basic-functions\">Basic functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#mathematical-operators-and-functions\">Mathematical operators and functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#indexing-assignment-and-concatenation\">Indexing, Assignment, and Concatenation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#array-functions\">Array functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#combinatorics\">Combinatorics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#bitarrays\">BitArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#sparse-matrices\">Sparse Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/parallel.html\">Tasks and Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/parallel.html#tasks\">Tasks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/parallel.html#general-parallel-computing-support\">General Parallel Computing Support</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/parallel.html#shared-arrays\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/parallel.html#cluster-manager-interface\">Cluster Manager Interface</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/linalg.html\">Linear Algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/linalg.html#module-Base.LinAlg\">Standard Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/linalg.html#module-Base.LinAlg.BLAS\">BLAS Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/linalg.html#module-Base.LinAlg.LAPACK\">LAPACK Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/constants.html\">Constants</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/file.html\">Filesystem</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/io-network.html\">I/O and Network</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/io-network.html#general-i-o\">General I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/io-network.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/io-network.html#multimedia-i-o\">Multimedia I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/io-network.html#memory-mapped-i-o\">Memory-mapped I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/io-network.html#network-i-o\">Network I/O</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/punctuation.html\">Punctuation</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/sort.html\">Sorting and Related Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/sort.html#sorting-functions\">Sorting Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/sort.html#order-related-functions\">Order-Related Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/sort.html#sorting-algorithms\">Sorting Algorithms</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/pkg.html\">Package Manager Functions</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/dates.html\">Dates and Time</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/dates.html#dates-and-time-types\">Dates and Time Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/dates.html#dates-functions\">Dates Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/test.html\">Unit and Functional Testing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/test.html#testing-base-julia\">Testing Base Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/test.html#test-framework\">Test Framework</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/test.html#handlers\">Handlers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/test.html#macros\">Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/test.html#functions\">Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/c.html\">C Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/c.html#llvm-interface\">LLVM Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/profile.html\">Profiling</a></li>\n</ul>\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/reflection.html\">Reflection and introspection</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/julia.html\">Documentation of Julia&#8217;s Internals</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/init.html\">Initialization of the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/eval.html\">Eval of Julia code</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/ast.html\">Julia ASTs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/types.html\">More about types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/object.html\">Memory layout of Julia Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/cartesian.html\">Base.Cartesian</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/meta.html\">Talking to the compiler (the <code class=\"docutils literal\"><span class=\"pre\">:meta</span></code> mechanism)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/subarrays.html\">SubArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/sysimg.html\">System Image Building</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/llvm.html\">Working with LLVM</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/stdio.html\">printf() and stdio in the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/promote-op.html\">Operator-sensitive promotion</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/C.html\">Developing/debugging Julia&#8217;s C code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/backtraces.html\">Reporting and analyzing crashes (segfaults)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/debuggingtips.html\">gdb debugging tips</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/valgrind.html\">Using Valgrind with Julia</a></li>\n</ul>\n</li>\n</ul>\n\n        \n      </div>\n      &nbsp;\n    </nav>\n\n    <section data-toggle=\"wy-nav-shift\" class=\"wy-nav-content-wrap\">\n\n      \n      <nav class=\"wy-nav-top\" role=\"navigation\" aria-label=\"top navigation\">\n        <i data-toggle=\"wy-nav-top\" class=\"fa fa-bars\"></i>\n        <a href=\"../index.html\">Julia Language</a>\n      </nav>\n\n\n      \n      <div class=\"wy-nav-content\">\n        <div class=\"rst-content\">\n          <div role=\"navigation\" aria-label=\"breadcrumbs navigation\">\n  <ul class=\"wy-breadcrumbs\">\n    <li><a href=\"../index.html\">Docs</a> &raquo;</li>\n      \n    <li>Calling C and Fortran Code</li>\n      <li class=\"wy-breadcrumbs-aside\">\n        \n          <a href=\"../_sources/manual/calling-c-and-fortran-code.txt\" rel=\"nofollow\"> View page source</a>\n        \n      </li>\n  </ul>\n  <hr/>\n</div>\n          <div role=\"main\" class=\"document\">\n            \n  <div class=\"section\" id=\"calling-c-and-fortran-code\">\n<span id=\"man-calling-c-and-fortran-code\"></span><h1>Calling C and Fortran Code<a class=\"headerlink\" href=\"#calling-c-and-fortran-code\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<p>Though most code can be written in Julia, there are many high-quality,\nmature libraries for numerical computing already written in C and\nFortran. To allow easy use of this existing code, Julia makes it simple\nand efficient to call C and Fortran functions. Julia has a &#8220;no\nboilerplate&#8221; philosophy: functions can be called directly from Julia\nwithout any &#8220;glue&#8221; code, code generation, or compilation \u2014 even from the\ninteractive prompt. This is accomplished just by making an appropriate call\nwith <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code> syntax, which looks like an ordinary function call.</p>\n<p>The code to be called must be available as a shared library. Most C and\nFortran libraries ship compiled as shared libraries already, but if you\nare compiling the code yourself using GCC (or Clang), you will need to\nuse the <code class=\"docutils literal\"><span class=\"pre\">-shared</span></code> and <code class=\"docutils literal\"><span class=\"pre\">-fPIC</span></code> options. The machine instructions\ngenerated by Julia&#8217;s JIT are the same as a native C call would be, so\nthe resulting overhead is the same as calling a library function from C\ncode. (Non-library function calls in both C and Julia can be inlined and\nthus may have even less overhead than calls to shared library functions.\nWhen both libraries and executables are generated by LLVM, it is\npossible to perform whole-program optimizations that can even optimize\nacross this boundary, but Julia does not yet support that. In the\nfuture, however, it may do so, yielding even greater performance gains.)</p>\n<p>Shared libraries and functions are referenced by a tuple of the\nform <code class=\"docutils literal\"><span class=\"pre\">(:function,</span> <span class=\"pre\">&quot;library&quot;)</span></code> or <code class=\"docutils literal\"><span class=\"pre\">(&quot;function&quot;,</span> <span class=\"pre\">&quot;library&quot;)</span></code> where <code class=\"docutils literal\"><span class=\"pre\">function</span></code>\nis the C-exported function name. <code class=\"docutils literal\"><span class=\"pre\">library</span></code> refers to the shared library\nname: shared libraries available in the (platform-specific) load path\nwill be resolved by name, and if necessary a direct path may be specified.</p>\n<p>A function name may be used alone in place of the tuple (just\n<code class=\"docutils literal\"><span class=\"pre\">:function</span></code> or <code class=\"docutils literal\"><span class=\"pre\">&quot;function&quot;</span></code>). In this case the name is resolved within\nthe current process. This form can be used to call C library functions,\nfunctions in the Julia runtime, or functions in an application linked to\nJulia.</p>\n<p>By default, Fortran compilers <a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Name_mangling#Fortran\">generate mangled names</a>\n(for example, converting function names to lowercase or uppercase,\noften appending an underscore), and so to call a Fortran function via\n<code class=\"docutils literal\"><span class=\"pre\">ccall</span></code> you must pass the mangled identifier corresponding to the rule\nfollowed by your Fortran compiler.  Also, when calling a Fortran\nfunction, all inputs must be passed by reference.</p>\n<p>Finally, you can use <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code> to actually generate a call to the\nlibrary function. Arguments to <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code> are as follows:</p>\n<ol class=\"arabic simple\">\n<li>(:function, &#8220;library&#8221;) pair (must be a constant, but see below).</li>\n<li>Return type (see below for mapping the declared C type to Julia)<ul>\n<li>This argument will be evaluated at compile-time.</li>\n</ul>\n</li>\n<li>A tuple of input types. The input types must be written as a literal tuple,\nnot a tuple-valued variable or expression.<ul>\n<li>This argument will be evaluated at compile-time.</li>\n</ul>\n</li>\n<li>The following arguments, if any, are the actual argument values\npassed to the function.</li>\n</ol>\n<p>As a complete but simple example, the following calls the <code class=\"docutils literal\"><span class=\"pre\">clock</span></code>\nfunction from the standard C library:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"k\">ccall</span><span class=\"p\">(</span> <span class=\"p\">(:</span><span class=\"n\">clock</span><span class=\"p\">,</span> <span class=\"s\">&quot;libc&quot;</span><span class=\"p\">),</span> <span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"p\">())</span>\n<span class=\"mi\">2292761</span>\n\n<span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">t</span>\n<span class=\"mi\">2292761</span>\n\n<span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"nb\">typeof</span><span class=\"p\">(</span><span class=\"n\">ans</span><span class=\"p\">)</span>\n<span class=\"kt\">Int32</span>\n</pre></div>\n</div>\n<p><code class=\"docutils literal\"><span class=\"pre\">clock</span></code> takes no arguments and returns an <code class=\"docutils literal\"><span class=\"pre\">Int32</span></code>. One common gotcha\nis that a 1-tuple must be written with a trailing comma. For\nexample, to call the <code class=\"docutils literal\"><span class=\"pre\">getenv</span></code> function to get a pointer to the value\nof an environment variable, one makes a call like this:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">path</span> <span class=\"o\">=</span> <span class=\"k\">ccall</span><span class=\"p\">((:</span><span class=\"n\">getenv</span><span class=\"p\">,</span> <span class=\"s\">&quot;libc&quot;</span><span class=\"p\">),</span> <span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"n\">UInt8</span><span class=\"p\">},</span> <span class=\"p\">(</span><span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"n\">UInt8</span><span class=\"p\">},),</span> <span class=\"s\">&quot;SHELL&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"n\">UInt8</span><span class=\"p\">}</span> <span class=\"p\">@</span><span class=\"mh\">0x00007fff5fbffc45</span>\n\n<span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">bytestring</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">)</span>\n<span class=\"s\">&quot;/bin/bash&quot;</span>\n</pre></div>\n</div>\n<p>Note that the argument type tuple must be written as <code class=\"docutils literal\"><span class=\"pre\">(Ptr{UInt8},)</span></code>,\nrather than <code class=\"docutils literal\"><span class=\"pre\">(Ptr{UInt8})</span></code>. This is because <code class=\"docutils literal\"><span class=\"pre\">(Ptr{UInt8})</span></code> is just\nthe expression <code class=\"docutils literal\"><span class=\"pre\">Ptr{UInt8}</span></code> surrounded by parentheses, rather than\na 1-tuple containing <code class=\"docutils literal\"><span class=\"pre\">Ptr{UInt8}</span></code>:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"p\">(</span><span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"n\">UInt8</span><span class=\"p\">})</span>\n<span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"n\">UInt8</span><span class=\"p\">}</span>\n\n<span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"p\">(</span><span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"n\">UInt8</span><span class=\"p\">},)</span>\n<span class=\"p\">(</span><span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"n\">UInt8</span><span class=\"p\">},)</span>\n</pre></div>\n</div>\n<p>In practice, especially when providing reusable functionality, one\ngenerally wraps <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code> uses in Julia functions that set up arguments\nand then check for errors in whatever manner the C or Fortran function\nindicates them, propagating to the Julia caller as exceptions. This is\nespecially important since C and Fortran APIs are notoriously\ninconsistent about how they indicate error conditions. For example, the\n<code class=\"docutils literal\"><span class=\"pre\">getenv</span></code> C library function is wrapped in the following Julia function\nin\n<a class=\"reference external\" href=\"https://github.com/JuliaLang/julia/blob/master/base/env.jl\">env.jl</a>:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">function</span><span class=\"nf\"> getenv</span><span class=\"p\">(</span><span class=\"n\">var</span><span class=\"p\">::</span><span class=\"n\">AbstractString</span><span class=\"p\">)</span>\n  <span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"k\">ccall</span><span class=\"p\">((:</span><span class=\"n\">getenv</span><span class=\"p\">,</span> <span class=\"s\">&quot;libc&quot;</span><span class=\"p\">),</span>\n              <span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"n\">UInt8</span><span class=\"p\">},</span> <span class=\"p\">(</span><span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"n\">UInt8</span><span class=\"p\">},),</span> <span class=\"n\">var</span><span class=\"p\">)</span>\n  <span class=\"k\">if</span> <span class=\"n\">val</span> <span class=\"o\">==</span> <span class=\"n\">C_NULL</span>\n    <span class=\"nb\">error</span><span class=\"p\">(</span><span class=\"s\">&quot;getenv: undefined variable: &quot;</span><span class=\"p\">,</span> <span class=\"n\">var</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n  <span class=\"n\">bytestring</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n<p>The C <code class=\"docutils literal\"><span class=\"pre\">getenv</span></code> function indicates an error by returning <code class=\"docutils literal\"><span class=\"pre\">NULL</span></code>, but\nother standard C functions indicate errors in various different ways,\nincluding by returning -1, 0, 1 and other special values. This wrapper\nthrows an exception clearly indicating the problem if the caller tries\nto get a non-existent environment variable:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">getenv</span><span class=\"p\">(</span><span class=\"s\">&quot;SHELL&quot;</span><span class=\"p\">)</span>\n<span class=\"s\">&quot;/bin/bash&quot;</span>\n\n<span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">getenv</span><span class=\"p\">(</span><span class=\"s\">&quot;FOOBAR&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">getenv</span><span class=\"p\">:</span> <span class=\"n\">undefined</span> <span class=\"n\">variable</span><span class=\"p\">:</span> <span class=\"n\">FOOBAR</span>\n</pre></div>\n</div>\n<p>Here is a slightly more complex example that discovers the local\nmachine&#8217;s hostname:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">function</span><span class=\"nf\"> gethostname</span><span class=\"p\">()</span>\n  <span class=\"n\">hostname</span> <span class=\"o\">=</span> <span class=\"n\">Array</span><span class=\"p\">(</span><span class=\"n\">UInt8</span><span class=\"p\">,</span> <span class=\"mi\">128</span><span class=\"p\">)</span>\n  <span class=\"k\">ccall</span><span class=\"p\">((:</span><span class=\"n\">gethostname</span><span class=\"p\">,</span> <span class=\"s\">&quot;libc&quot;</span><span class=\"p\">),</span> <span class=\"kt\">Int32</span><span class=\"p\">,</span>\n        <span class=\"p\">(</span><span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"n\">UInt8</span><span class=\"p\">},</span> <span class=\"n\">Csize_t</span><span class=\"p\">),</span>\n        <span class=\"n\">hostname</span><span class=\"p\">,</span> <span class=\"nb\">sizeof</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"p\">))</span>\n  <span class=\"n\">hostname</span><span class=\"p\">[</span><span class=\"k\">end</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"c\"># ensure null-termination</span>\n  <span class=\"k\">return</span> <span class=\"n\">bytestring</span><span class=\"p\">(</span><span class=\"n\">pointer</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"p\">))</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n<p>This example first allocates an array of bytes, then calls the C library\nfunction <code class=\"docutils literal\"><span class=\"pre\">gethostname</span></code> to fill the array in with the hostname, takes a\npointer to the hostname buffer, and converts the pointer to a Julia\nstring, assuming that it is a NUL-terminated C string. It is common for\nC libraries to use this pattern of requiring the caller to allocate\nmemory to be passed to the callee and filled in. Allocation of memory\nfrom Julia like this is generally accomplished by creating an\nuninitialized array and passing a pointer to its data to the C function.</p>\n<div class=\"section\" id=\"creating-c-compatible-julia-function-pointers\">\n<h2>Creating C-Compatible Julia Function Pointers<a class=\"headerlink\" href=\"#creating-c-compatible-julia-function-pointers\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>It is possible to pass Julia functions to native c-functions that accept\nfunction pointer arguments. For example, to match c-prototypes of the form:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">typedef</span> <span class=\"n\">returntype</span> <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">functiontype</span><span class=\"p\">)(</span><span class=\"n\">argumenttype</span><span class=\"p\">,</span><span class=\"o\">...</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>The function <code class=\"docutils literal\"><span class=\"pre\">cfunction</span></code> generates the c-compatible function pointer for\na call to a Julia library function.\nArguments to <code class=\"docutils literal\"><span class=\"pre\">cfunction</span></code> are as follows:</p>\n<ol class=\"arabic simple\">\n<li>A Julia Function</li>\n<li>Return type</li>\n<li>A tuple of input types</li>\n</ol>\n<p>A classic example is the standard C library <code class=\"docutils literal\"><span class=\"pre\">qsort</span></code> function,\ndeclared as:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">void</span> <span class=\"n\">qsort</span><span class=\"p\">(</span><span class=\"n\">void</span> <span class=\"o\">*</span><span class=\"n\">base</span><span class=\"p\">,</span> <span class=\"n\">size_t</span> <span class=\"n\">nmemb</span><span class=\"p\">,</span> <span class=\"n\">size_t</span> <span class=\"n\">size</span><span class=\"p\">,</span>\n           <span class=\"n\">int</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">compare</span><span class=\"p\">)(</span><span class=\"kd\">const</span> <span class=\"n\">void</span> <span class=\"o\">*</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"kd\">const</span> <span class=\"n\">void</span> <span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">));</span>\n</pre></div>\n</div>\n<p>The <code class=\"docutils literal\"><span class=\"pre\">base</span></code> argument is a pointer to an array of length <code class=\"docutils literal\"><span class=\"pre\">nmemb</span></code>, with elements of\n<code class=\"docutils literal\"><span class=\"pre\">size</span></code> bytes each. <code class=\"docutils literal\"><span class=\"pre\">compare</span></code> is a callback function which takes pointers to two\nelements <code class=\"docutils literal\"><span class=\"pre\">a</span></code> and <code class=\"docutils literal\"><span class=\"pre\">b</span></code> and returns an integer less/greater than zero if <code class=\"docutils literal\"><span class=\"pre\">a</span></code> should\nappear before/after <code class=\"docutils literal\"><span class=\"pre\">b</span></code> (or zero if any order is permitted). Now, suppose that we\nhave a 1d array <code class=\"docutils literal\"><span class=\"pre\">A</span></code> of values in Julia that we want to sort using the <code class=\"docutils literal\"><span class=\"pre\">qsort</span></code>\nfunction (rather than Julia&#8217;s built-in <code class=\"docutils literal\"><span class=\"pre\">sort</span></code> function). Before we worry about calling\n<code class=\"docutils literal\"><span class=\"pre\">qsort</span></code> and passing arguments, we need to write a comparison function that works for\nsome arbitrary type T:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">function</span><span class=\"nf\"> mycompare</span><span class=\"p\">{</span><span class=\"n\">T</span><span class=\"p\">}(</span><span class=\"n\">a</span><span class=\"p\">::</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">::</span><span class=\"n\">T</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"nb\">convert</span><span class=\"p\">(</span><span class=\"n\">Cint</span><span class=\"p\">,</span> <span class=\"n\">a</span> <span class=\"o\">&lt;</span> <span class=\"n\">b</span> <span class=\"o\">?</span> <span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"p\">:</span> <span class=\"n\">a</span> <span class=\"o\">&gt;</span> <span class=\"n\">b</span> <span class=\"o\">?</span> <span class=\"o\">+</span><span class=\"mi\">1</span> <span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">)::</span><span class=\"n\">Cint</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n<p>Notice that we have to be careful about the return type: <code class=\"docutils literal\"><span class=\"pre\">qsort</span></code> expects a function\nreturning a C <code class=\"docutils literal\"><span class=\"pre\">int</span></code>, so we must be sure to return <code class=\"docutils literal\"><span class=\"pre\">Cint</span></code> via a call to <code class=\"docutils literal\"><span class=\"pre\">convert</span></code>\nand a <code class=\"docutils literal\"><span class=\"pre\">typeassert</span></code>.</p>\n<p>In order to pass this function to C, we obtain its address using the function <code class=\"docutils literal\"><span class=\"pre\">cfunction</span></code>:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"kd\">const</span> <span class=\"n\">mycompare_c</span> <span class=\"o\">=</span> <span class=\"n\">cfunction</span><span class=\"p\">(</span><span class=\"n\">mycompare</span><span class=\"p\">,</span> <span class=\"n\">Cint</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">Ref</span><span class=\"p\">{</span><span class=\"n\">Cdouble</span><span class=\"p\">},</span> <span class=\"n\">Ref</span><span class=\"p\">{</span><span class=\"n\">Cdouble</span><span class=\"p\">}))</span>\n</pre></div>\n</div>\n<p><code class=\"docutils literal\"><span class=\"pre\">cfunction</span></code> accepts three arguments: the Julia function (<code class=\"docutils literal\"><span class=\"pre\">mycompare</span></code>), the return\ntype (<code class=\"docutils literal\"><span class=\"pre\">Cint</span></code>), and a tuple of the argument types, in this case to sort an array of\n<code class=\"docutils literal\"><span class=\"pre\">Cdouble</span></code> (Float64) elements.</p>\n<p>The final call to <code class=\"docutils literal\"><span class=\"pre\">qsort</span></code> looks like this:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">1.3</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">2.7</span><span class=\"p\">,</span> <span class=\"mf\">4.4</span><span class=\"p\">,</span> <span class=\"mf\">3.1</span><span class=\"p\">]</span>\n<span class=\"k\">ccall</span><span class=\"p\">(:</span><span class=\"n\">qsort</span><span class=\"p\">,</span> <span class=\"n\">Void</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"n\">Cdouble</span><span class=\"p\">},</span> <span class=\"n\">Csize_t</span><span class=\"p\">,</span> <span class=\"n\">Csize_t</span><span class=\"p\">,</span> <span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"n\">Void</span><span class=\"p\">}),</span>\n      <span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">),</span> <span class=\"nb\">sizeof</span><span class=\"p\">(</span><span class=\"n\">eltype</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)),</span> <span class=\"n\">mycompare_c</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>After this executes, <code class=\"docutils literal\"><span class=\"pre\">A</span></code> is changed to the sorted array <code class=\"docutils literal\"><span class=\"pre\">[-2.7,</span> <span class=\"pre\">1.3,</span> <span class=\"pre\">3.1,</span> <span class=\"pre\">4.4]</span></code>.\nNote that Julia knows how to convert an array into a <code class=\"docutils literal\"><span class=\"pre\">Ptr{Cdouble}</span></code>, how to compute\nthe size of a type in bytes (identical to C&#8217;s <code class=\"docutils literal\"><span class=\"pre\">sizeof</span></code> operator), and so on.\nFor fun, try inserting a <code class=\"docutils literal\"><span class=\"pre\">println(&quot;mycompare($a,$b)&quot;)</span></code> line into <code class=\"docutils literal\"><span class=\"pre\">mycompare</span></code>, which\nwill allow you to see the comparisons that <code class=\"docutils literal\"><span class=\"pre\">qsort</span></code> is performing (and to verify that\nit is really calling the Julia function that you passed to it).</p>\n</div>\n<div class=\"section\" id=\"mapping-c-types-to-julia\">\n<h2>Mapping C Types to Julia<a class=\"headerlink\" href=\"#mapping-c-types-to-julia\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>It is critical to exactly match the declared C type with its declaration\nin Julia. Inconsistencies can cause code that works correctly on one system\nto fail or produce indeterminate results on a different system.</p>\n<p>Note that no C header files are used anywhere in the process of calling C\nfunctions: you are responsible for making sure that your Julia types and\ncall signatures accurately reflect those in the C header file. (The <a class=\"reference external\" href=\"https://github.com/ihnorton/Clang.jl\">Clang\npackage</a> can be used to auto-generate\nJulia code from a C header file.)</p>\n<div class=\"section\" id=\"auto-conversion\">\n<h3>Auto-conversion:<a class=\"headerlink\" href=\"#auto-conversion\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>Julia automatically inserts calls to the <code class=\"docutils literal\"><span class=\"pre\">convert</span></code> function to convert\neach argument to the specified type. For example, the following call:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">ccall</span><span class=\"p\">((:</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"s\">&quot;libfoo&quot;</span><span class=\"p\">),</span> <span class=\"n\">Void</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"kt\">Float64</span><span class=\"p\">),</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>will behave as if the following were written:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">ccall</span><span class=\"p\">((:</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"s\">&quot;libfoo&quot;</span><span class=\"p\">),</span> <span class=\"n\">Void</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"kt\">Float64</span><span class=\"p\">),</span>\n      <span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">unsafe_convert</span><span class=\"p\">(</span><span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">cconvert</span><span class=\"p\">(</span><span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">)),</span>\n      <span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">unsafe_convert</span><span class=\"p\">(</span><span class=\"kt\">Float64</span><span class=\"p\">,</span> <span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">cconvert</span><span class=\"p\">(</span><span class=\"kt\">Float64</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)))</span>\n</pre></div>\n</div>\n<p><code class=\"docutils literal\"><span class=\"pre\">cconvert</span></code> normally just calls <code class=\"docutils literal\"><span class=\"pre\">convert</span></code>, but can be defined to return\nan arbitrary new object more appropriate for passing to C. For example,\nthis is used to convert an <code class=\"docutils literal\"><span class=\"pre\">Array</span></code> of objects (e.g. strings) to an\narray of pointers.</p>\n<p><code class=\"docutils literal\"><span class=\"pre\">unsafe_convert</span></code> handles conversion to <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> types. It is considered\nunsafe because converting an object to a native pointer can hide the object\nfrom the garbage collector, causing it to be freed prematurely.</p>\n</div>\n<div class=\"section\" id=\"type-correspondences\">\n<h3>Type Correspondences:<a class=\"headerlink\" href=\"#type-correspondences\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>First, a review of some relevant Julia type terminology:</p>\n<table border=\"1\" class=\"text-wrap docutils\">\n<colgroup>\n<col width=\"26%\" />\n<col width=\"26%\" />\n<col width=\"48%\" />\n</colgroup>\n<thead valign=\"bottom\">\n<tr class=\"row-odd\"><th class=\"head\">Syntax / Keyword</th>\n<th class=\"head\">Example</th>\n<th class=\"head\">Description</th>\n</tr>\n</thead>\n<tbody valign=\"top\">\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">type</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">ASCIIString</span></code></td>\n<td>&#8220;Leaf Type&#8221; :: A group of related data that includes\na type-tag, is managed by the Julia GC, and\nis defined by object-identity.\nThe type parameters of a leaf type must be fully defined\n(no <code class=\"docutils literal\"><span class=\"pre\">TypeVars</span></code> are allowed)\nin order for the instance to be constructed.</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">abstract</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Any</span></code>,\n<code class=\"docutils literal\"><span class=\"pre\">AbstractArray{T,N}</span></code>,\n<code class=\"docutils literal\"><span class=\"pre\">Complex{T}</span></code></td>\n<td>&#8220;Super Type&#8221; :: A super-type (not a leaf-type)\nthat cannot be instantiated, but can be used to\ndescribe a group of types.</td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">{T}</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Vector{Int}</span></code></td>\n<td><p class=\"first\">&#8220;Type Parameter&#8221; :: A specialization of a type\n(typically used for dispatch or storage optimization).</p>\n<p class=\"last\">&#8220;TypeVar&#8221; :: The <code class=\"docutils literal\"><span class=\"pre\">T</span></code> in the type parameter declaration\nis referred to as a TypeVar (short for type variable).</p>\n</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">bitstype</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int</span></code>,\n<code class=\"docutils literal\"><span class=\"pre\">Float64</span></code></td>\n<td>&#8220;Bits Type&#8221; :: A type with no fields, but a size. It\nis stored and defined by-value.</td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">immutable</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">Pair{Int,Int}</span></code></p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">Complex128</span></code> (<code class=\"docutils literal\"><span class=\"pre\">isbits</span></code>)</p>\n</td>\n<td><p class=\"first\">&#8220;Immutable&#8221; :: A type with all fields defined to be\nconstant. It is defined by-value. And may be stored\nwith a type-tag.</p>\n<p class=\"last\">&#8220;Is-Bits&#8221; :: A <code class=\"docutils literal\"><span class=\"pre\">bitstype</span></code>, or an <code class=\"docutils literal\"><span class=\"pre\">immutable</span></code> type\nwhere all fields are other <code class=\"docutils literal\"><span class=\"pre\">isbits</span></code> types. It is\ndefined by-value, and is stored without a type-tag.</p>\n</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">type</span> <span class=\"pre\">...;</span> <span class=\"pre\">end</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">nothing</span></code></td>\n<td>&#8220;Singleton&#8221; :: a Leaf Type or Immutable with no fields.</td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">(...)</span></code> or <code class=\"docutils literal\"><span class=\"pre\">tuple(...)`</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">(1,2,3)</span></code></td>\n<td>&#8220;Tuple&#8221; :: an immutable data-structure similar to an\nanonymous immutable type, or a constant array.\nRepresented as either an array or a struct.</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">typealias</span></code></td>\n<td>Not applicable here</td>\n<td>Type aliases, and other similar mechanisms of\ndoing type indirection, are resolved to their base\ntype (this includes assigning a type to another name,\nor getting the type out of a function call).</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"bits-types\">\n<h3>Bits Types:<a class=\"headerlink\" href=\"#bits-types\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>There are several special types to be aware of, as no other type can be defined to behave the same:</p>\n<dl class=\"docutils\">\n<dt><code class=\"docutils literal\"><span class=\"pre\">Float32</span></code></dt>\n<dd>Exactly corresponds to the <code class=\"docutils literal\"><span class=\"pre\">float</span></code> type in C (or <code class=\"docutils literal\"><span class=\"pre\">REAL*4</span></code> in Fortran).</dd>\n<dt><code class=\"docutils literal\"><span class=\"pre\">Float64</span></code></dt>\n<dd>Exactly corresponds to the <code class=\"docutils literal\"><span class=\"pre\">double</span></code> type in C (or <code class=\"docutils literal\"><span class=\"pre\">REAL*8</span></code> in Fortran).</dd>\n<dt><code class=\"docutils literal\"><span class=\"pre\">Complex64</span></code></dt>\n<dd>Exactly corresponds to the <code class=\"docutils literal\"><span class=\"pre\">complex</span> <span class=\"pre\">float</span></code> type in C (or <code class=\"docutils literal\"><span class=\"pre\">COMPLEX*8</span></code> in Fortran).</dd>\n<dt><code class=\"docutils literal\"><span class=\"pre\">Complex128</span></code></dt>\n<dd>Exactly corresponds to the <code class=\"docutils literal\"><span class=\"pre\">complex</span> <span class=\"pre\">double</span></code> type in C (or <code class=\"docutils literal\"><span class=\"pre\">COMPLEX*16</span></code> in Fortran).</dd>\n<dt><code class=\"docutils literal\"><span class=\"pre\">Signed</span></code></dt>\n<dd>Exactly corresponds to the <code class=\"docutils literal\"><span class=\"pre\">signed</span></code> type annotation in C (or any <code class=\"docutils literal\"><span class=\"pre\">INTEGER</span></code> type in Fortran). Any Julia type that is not a subtype of <code class=\"docutils literal\"><span class=\"pre\">Signed</span></code> is assumed to be unsigned.</dd>\n<dt><code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code></dt>\n<dd>Behaves like a <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code> that owns its memory.</dd>\n<dt><code class=\"docutils literal\"><span class=\"pre\">Array{T,N}</span></code></dt>\n<dd><p class=\"first\">When an array is passed to C as a <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code> argument, it is\nnot reinterpret-cast: Julia requires that the element type of the\narray matches <code class=\"docutils literal\"><span class=\"pre\">T</span></code>, and the address of the first element is passed.</p>\n<p>Therefore, if an <code class=\"docutils literal\"><span class=\"pre\">Array</span></code> contains data in the wrong format, it will\nhave to be explicitly converted using a call such as <code class=\"docutils literal\"><span class=\"pre\">trunc(Int32,a)</span></code>.</p>\n<p>To pass an array <code class=\"docutils literal\"><span class=\"pre\">A</span></code> as a pointer of a different type <em>without</em>\nconverting the data beforehand (for example, to pass a <code class=\"docutils literal\"><span class=\"pre\">Float64</span></code> array\nto a function that operates on uninterpreted bytes), you can\ndeclare the argument as <code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code>.</p>\n<p class=\"last\">If an array of eltype <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code> is passed as a <code class=\"docutils literal\"><span class=\"pre\">Ptr{Ptr{T}}</span></code> argument, the Julia base library\n<code class=\"docutils literal\"><span class=\"pre\">cconvert</span></code> function will attempt to first make a null-terminated copy of the array with\neach element replaced by its <code class=\"docutils literal\"><span class=\"pre\">cconvert</span></code> version. This allows, for example, passing an <code class=\"docutils literal\"><span class=\"pre\">argv</span></code>\npointer array of type <code class=\"docutils literal\"><span class=\"pre\">Vector{ByteString}</span></code> to an argument of type <code class=\"docutils literal\"><span class=\"pre\">Ptr{Ptr{Cchar}}</span></code>.</p>\n</dd>\n</dl>\n<p>On all systems we currently support, basic C/C++ value types may be\ntranslated to Julia types as follows. Every C type also has a corresponding\nJulia type with the same name, prefixed by C. This can help for writing portable code (and remembering that an <code class=\"docutils literal\"><span class=\"pre\">int</span></code> in C is not the same as an <code class=\"docutils literal\"><span class=\"pre\">Int</span></code> in Julia).</p>\n<p><strong>System Independent:</strong></p>\n<table border=\"1\" class=\"text-wrap docutils\">\n<colgroup>\n<col width=\"32%\" />\n<col width=\"16%\" />\n<col width=\"20%\" />\n<col width=\"32%\" />\n</colgroup>\n<thead valign=\"bottom\">\n<tr class=\"row-odd\"><th class=\"head\">C name</th>\n<th class=\"head\">Fortran name</th>\n<th class=\"head\">Standard Julia Alias</th>\n<th class=\"head\">Julia Base Type</th>\n</tr>\n</thead>\n<tbody valign=\"top\">\n<tr class=\"row-even\"><td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">char</span></code></p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">bool</span></code> (C++)</p>\n</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">CHARACTER</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cuchar</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">UInt8</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">short</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">INTEGER*2</span></code></p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">LOGICAL*2</span></code></p>\n</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cshort</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int16</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">short</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cushort</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">UInt16</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">int</span></code></p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">BOOL</span></code> (C, typical)</p>\n</td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">INTEGER*4</span></code></p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">LOGICAL*4</span></code></p>\n</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cint</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int32</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">int</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cuint</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">UInt32</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">long</span> <span class=\"pre\">long</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">INTEGER*8</span></code></p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">LOGICAL*8</span></code></p>\n</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Clonglong</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int64</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">long</span> <span class=\"pre\">long</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Culonglong</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">UInt64</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">intmax_t</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cintmax_t</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int64</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">uintmax_t</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cuintmax_t</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">UInt64</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">float</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">REAL*4i</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cfloat</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Float32</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">double</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">REAL*8</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cdouble</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Float64</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">complex</span> <span class=\"pre\">float</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">COMPLEX*8</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Complex64</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Complex{Float32}</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">complex</span> <span class=\"pre\">double</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">COMPLEX*16</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Complex128</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Complex{Float64}</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">ptrdiff_t</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cptrdiff_t</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">ssize_t</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cssize_t</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">size_t</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Csize_t</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">UInt</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">void</span></code></td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Void</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">void*</span></code></td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">T*</span></code> (where T represents an\nappropriately defined type)</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">char*</span></code>\n(or <code class=\"docutils literal\"><span class=\"pre\">char[]</span></code>, e.g. a string)</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">CHARACTER*N</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> if NUL-terminated, or\n<code class=\"docutils literal\"><span class=\"pre\">Ptr{UInt8}</span></code> if not</td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">char**</span></code> (or <code class=\"docutils literal\"><span class=\"pre\">*char[]</span></code>)</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Ptr{Ptr{UInt8}}</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code>\n(any Julia Type)</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Any</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">jl_value_t**</span></code>\n(a reference to a Julia Type)</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Ref{Any}</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">va_arg</span></code></td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>Not supported</td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">...</span></code>\n(variadic function specification)</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">T...</span></code> (where <code class=\"docutils literal\"><span class=\"pre\">T</span></code>\nis one of the above types,\nvariadic functions of different\nargument types are not supported)</td>\n</tr>\n</tbody>\n</table>\n<p>The <code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> type is essentially a synonym for <code class=\"docutils literal\"><span class=\"pre\">Ptr{UInt8}</span></code>, except the conversion to <code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> throws an\nerror if the Julia string contains any embedded NUL characters (which would cause the string to be silently\ntruncated if the C routine treats NUL as the terminator).  If you are passing a <code class=\"docutils literal\"><span class=\"pre\">char*</span></code> to a C routine that\ndoes not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that\nyour Julia string does not contain NUL and want to skip the check, you can use <code class=\"docutils literal\"><span class=\"pre\">Ptr{UInt8}</span></code> as the argument type.</p>\n<p><strong>System-dependent:</strong></p>\n<table border=\"1\" class=\"docutils\">\n<colgroup>\n<col width=\"32%\" />\n<col width=\"32%\" />\n<col width=\"35%\" />\n</colgroup>\n<thead valign=\"bottom\">\n<tr class=\"row-odd\"><th class=\"head\">C name</th>\n<th class=\"head\">Standard Julia Alias</th>\n<th class=\"head\">Julia Base Type</th>\n</tr>\n</thead>\n<tbody valign=\"top\">\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">char</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cchar</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">Int8</span></code> (x86, x86_64)</p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">UInt8</span></code> (powerpc, arm)</p>\n</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">long</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Clong</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">Int</span></code> (UNIX)</p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">Int32</span></code> (Windows)</p>\n</td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">long</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Culong</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">UInt</span></code> (UNIX)</p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">UInt32</span></code> (Windows)</p>\n</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">wchar_t</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cwchar_t</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">Int32</span></code> (UNIX)</p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">UInt16</span></code> (Windows)</p>\n</td>\n</tr>\n</tbody>\n</table>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">When calling a Fortran function, all inputs must be passed by reference, so\nall type correspondences above should contain an additional <code class=\"docutils literal\"><span class=\"pre\">Ptr{..}</span></code> or\n<code class=\"docutils literal\"><span class=\"pre\">Ref{..}</span></code> wrapper around their type specification.</p>\n</div>\n<div class=\"admonition warning\">\n<p class=\"first admonition-title\">Warning</p>\n<p class=\"last\">For string arguments (<code class=\"docutils literal\"><span class=\"pre\">char*</span></code>) the Julia type should be <code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> (if NUL-\nterminated data is expected) or either <code class=\"docutils literal\"><span class=\"pre\">Ptr{Cchar}</span></code> or <code class=\"docutils literal\"><span class=\"pre\">Ptr{UInt8}</span></code>\notherwise (these two pointer types have the same effect), as described above,\nnot <code class=\"docutils literal\"><span class=\"pre\">ASCIIString</span></code>. Similarly, for array arguments (<code class=\"docutils literal\"><span class=\"pre\">T[]</span></code> or <code class=\"docutils literal\"><span class=\"pre\">T*</span></code>), the\nJulia type should again be <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code>, not <code class=\"docutils literal\"><span class=\"pre\">Vector{T}</span></code>.</p>\n</div>\n<div class=\"admonition warning\">\n<p class=\"first admonition-title\">Warning</p>\n<p class=\"last\">Julia&#8217;s <code class=\"docutils literal\"><span class=\"pre\">Char</span></code> type is 32 bits, which is not the same as the wide character\ntype (<code class=\"docutils literal\"><span class=\"pre\">wchar_t</span></code> or <code class=\"docutils literal\"><span class=\"pre\">wint_t</span></code>) on all platforms.</p>\n</div>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">For <code class=\"docutils literal\"><span class=\"pre\">wchar_t*</span></code> arguments, the Julia type should be <code class=\"docutils literal\"><span class=\"pre\">Cwstring</span></code> (if the C\nroutine expects a NUL-terminated string) or <code class=\"docutils literal\"><span class=\"pre\">Ptr{Cwchar_t}</span></code> otherwise, and\ndata can be converted to/from ordinary Julia strings by the <code class=\"docutils literal\"><span class=\"pre\">wstring(s)</span></code>\nfunction (equivalent to either <code class=\"docutils literal\"><span class=\"pre\">utf16(s)</span></code> or <code class=\"docutils literal\"><span class=\"pre\">utf32(s)</span></code> depending upon the\nwidth of <code class=\"docutils literal\"><span class=\"pre\">Cwchar_t</span></code>); this conversion will be called automatically for\n<code class=\"docutils literal\"><span class=\"pre\">Cwstring</span></code> arguments.    Note also that ASCII, UTF-8, UTF-16, and UTF-32\nstring data in Julia is internally NUL-terminated, so it can be passed to C\nfunctions expecting NUL-terminated data without making a copy (but using the\n<code class=\"docutils literal\"><span class=\"pre\">Cwstring</span></code> type will cause an error to be thrown if the string itself\ncontains NUL characters).</p>\n</div>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p>C functions that take an argument of the type <code class=\"docutils literal\"><span class=\"pre\">char**</span></code> can be called by\nusing a <code class=\"docutils literal\"><span class=\"pre\">Ptr{Ptr{UInt8}}</span></code> type within Julia. For example, C functions of the\nform:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">int</span> <span class=\"n\">main</span><span class=\"p\">(</span><span class=\"n\">int</span> <span class=\"n\">argc</span><span class=\"p\">,</span> <span class=\"n\">char</span> <span class=\"o\">**</span><span class=\"n\">argv</span><span class=\"p\">);</span>\n</pre></div>\n</div>\n<p>can be called via the following Julia code:</p>\n<div class=\"last highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">argv</span> <span class=\"o\">=</span> <span class=\"p\">[</span> <span class=\"s\">&quot;a.out&quot;</span><span class=\"p\">,</span> <span class=\"s\">&quot;arg1&quot;</span><span class=\"p\">,</span> <span class=\"s\">&quot;arg2&quot;</span> <span class=\"p\">]</span>\n<span class=\"k\">ccall</span><span class=\"p\">(:</span><span class=\"n\">main</span><span class=\"p\">,</span> <span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"n\">UInt8</span><span class=\"p\">}}),</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">argv</span><span class=\"p\">),</span> <span class=\"n\">argv</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</div>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">A C function declared to return <code class=\"docutils literal\"><span class=\"pre\">Void</span></code> will return the value <code class=\"docutils literal\"><span class=\"pre\">nothing</span></code> in\nJulia.</p>\n</div>\n</div>\n<div class=\"section\" id=\"struct-type-correspondences\">\n<h3>Struct Type correspondences<a class=\"headerlink\" href=\"#struct-type-correspondences\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>Composite types, aka <code class=\"docutils literal\"><span class=\"pre\">struct</span></code> in C or <code class=\"docutils literal\"><span class=\"pre\">TYPE</span></code> in Fortran90\n(or <code class=\"docutils literal\"><span class=\"pre\">STRUCTURE</span></code> / <code class=\"docutils literal\"><span class=\"pre\">RECORD</span></code> in some variants of F77),\ncan be mirrored in Julia by creating a <code class=\"docutils literal\"><span class=\"pre\">type</span></code> or <code class=\"docutils literal\"><span class=\"pre\">immutable</span></code>\ndefinition with the same field layout.</p>\n<p>When used recursively, <code class=\"docutils literal\"><span class=\"pre\">isbits</span></code> types are stored inline.\nAll other types are stored as a pointer to the data.\nWhen mirroring a struct used by-value inside another struct in C,\nit is imperative that you do not attempt to manually copy the fields over,\nas this will not preserve the correct field alignment.\nInstead, declare an immutable isbits type and use that instead.\nUnnamed structs are not possible in the translation to Julia.</p>\n<p>Packed structs and union declarations are not supported by Julia.</p>\n<p>You can get a near approximation of a <code class=\"docutils literal\"><span class=\"pre\">union</span></code> if you know, a priori,\nthe field that will have the greatest size (potentially including padding).\nWhen translating your fields to Julia, declare the Julia field to be only\nof that type.</p>\n<p>Arrays of parameters must be expanded manually, currently\n(either inline, or in an immutable helper-type). For example:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">in</span> <span class=\"n\">C</span><span class=\"p\">:</span>\n<span class=\"n\">struct</span> <span class=\"n\">B</span> <span class=\"p\">{</span>\n    <span class=\"n\">int</span> <span class=\"n\">A</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">];</span>\n<span class=\"p\">};</span>\n<span class=\"n\">b_a_2</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"o\">.</span><span class=\"n\">A</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">];</span>\n\n<span class=\"k\">in</span> <span class=\"n\">Julia</span><span class=\"p\">:</span>\n<span class=\"k\">immutable</span> <span class=\"n\">B_A</span>\n    <span class=\"n\">A_1</span><span class=\"p\">::</span><span class=\"n\">Cint</span>\n    <span class=\"n\">A_2</span><span class=\"p\">::</span><span class=\"n\">Cint</span>\n    <span class=\"n\">A_3</span><span class=\"p\">::</span><span class=\"n\">Cint</span>\n<span class=\"k\">end</span>\n<span class=\"k\">type</span><span class=\"nc\"> B</span>\n    <span class=\"n\">A</span><span class=\"p\">::</span><span class=\"n\">B_A</span>\n<span class=\"k\">end</span>\n<span class=\"n\">b_a_2</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"o\">.</span><span class=\"n\">A</span><span class=\"o\">.</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Arrays of unknown size are not supported.</p>\n<p>In the future, some of these restrictions may be reduced or eliminated.</p>\n</div>\n<div class=\"section\" id=\"memory-ownership\">\n<h3>Memory Ownership:<a class=\"headerlink\" href=\"#memory-ownership\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p><strong>malloc/free</strong></p>\n<p>Memory allocation and deallocation of such objects must be\nhandled by calls to the appropriate cleanup routines in the libraries\nbeing used, just like in any C program. Do not try to free an object\nreceived from a C library with <code class=\"docutils literal\"><span class=\"pre\">Libc.free</span></code> in Julia, as this may result\nin the <code class=\"docutils literal\"><span class=\"pre\">free</span></code> function being called via the wrong <code class=\"docutils literal\"><span class=\"pre\">libc</span></code> library and\ncause Julia to crash. The reverse (passing an object allocated in Julia\nto be freed by an external library) is equally invalid.</p>\n<p><strong>Ptr{T} vs. Array{T} vs. Ref{T} vs. T</strong></p>\n<p>The choice of type-wrapper declaration strongly depends on who allocated the memory,\nand the declared type.\nIn general, use <code class=\"docutils literal\"><span class=\"pre\">T</span></code> if the memory is intended to be allocated in\n(and managed by) Julia (with type-tag).\nUse <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code> if the memory is expected to be populated by <code class=\"docutils literal\"><span class=\"pre\">C</span></code> (without type-tag).\nUse <code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code> if you have an <code class=\"docutils literal\"><span class=\"pre\">isbits</span></code> type,\nbut you want to turn it into a pointer to a struct in another struct definition.</p>\n<p>See issue #2818 for some work that needs to be done to simplify this so that Julia\ntypes can be used to recursively mirror c-style structs,\nwithout requiring as much manual management of the <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> conversions.\nAfter #2818 is implemented, it will be true that an <code class=\"docutils literal\"><span class=\"pre\">Vector{T}</span></code> will be equivalent to\nan <code class=\"docutils literal\"><span class=\"pre\">Ptr{Ptr{T}}</span></code>. That is currently not true, and the conversion must be explicitly.</p>\n</div>\n</div>\n<div class=\"section\" id=\"mapping-c-functions-to-julia\">\n<h2>Mapping C Functions to Julia<a class=\"headerlink\" href=\"#mapping-c-functions-to-julia\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<div class=\"section\" id=\"ccall-cfunction-argument-translation-guide\">\n<h3>ccall/cfunction argument translation guide<a class=\"headerlink\" href=\"#ccall-cfunction-argument-translation-guide\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>For translating a <code class=\"docutils literal\"><span class=\"pre\">c</span></code> argument list to <code class=\"docutils literal\"><span class=\"pre\">Julia</span></code>:</p>\n<ul class=\"simple\">\n<li><code class=\"docutils literal\"><span class=\"pre\">T</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is one of the primitive types:\n<code class=\"docutils literal\"><span class=\"pre\">char</span></code>, <code class=\"docutils literal\"><span class=\"pre\">int</span></code>, <code class=\"docutils literal\"><span class=\"pre\">long</span></code>, <code class=\"docutils literal\"><span class=\"pre\">short</span></code>, <code class=\"docutils literal\"><span class=\"pre\">float</span></code>, <code class=\"docutils literal\"><span class=\"pre\">double</span></code>, <code class=\"docutils literal\"><span class=\"pre\">complex</span></code>, <code class=\"docutils literal\"><span class=\"pre\">enum</span></code>\nor any of their <code class=\"docutils literal\"><span class=\"pre\">typedef</span></code> equivalents<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">T</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is an equivalent Julia Bits Type (per the table above)</li>\n<li>if <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is an <code class=\"docutils literal\"><span class=\"pre\">enum</span></code>, the argument type should be equivalent to <code class=\"docutils literal\"><span class=\"pre\">Cint</span></code> or <code class=\"docutils literal\"><span class=\"pre\">Cuint</span></code></li>\n<li>argument value will be copied (passed by-value)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">struct</span> <span class=\"pre\">T</span></code> (including typedef to a struct)<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">T</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is a Julia Leaf Type</li>\n<li>argument value will be copied (passed by-value)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">void*</span></code><ul>\n<li>depends on how this parameter is used, first translate this to the intended pointer type,\nthen determine the Julia equivalent using the remaining rules in this list</li>\n<li>this argument may be declared as <code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code>, if it really is just an unknown pointer</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code><ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Any</span></code></li>\n<li>argument value must be a valid Julia object</li>\n<li>currently unsupported by cfunction</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">jl_value_t**</span></code><ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ref{Any}</span></code></li>\n<li>argument value must be a valid Julia object (or <code class=\"docutils literal\"><span class=\"pre\">C_NULL</span></code>)</li>\n<li>currently unsupported by cfunction</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">T*</span></code><ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is the Julia type corresponding to <code class=\"docutils literal\"><span class=\"pre\">T</span></code></li>\n<li>argument value will be copied if it is an <code class=\"docutils literal\"><span class=\"pre\">isbits</span></code> type\notherwise, the value must be a valid Julia object</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">(T*)(...)</span></code> (e.g. a pointer to a function)<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code> (you may need to use <code class=\"docutils literal\"><span class=\"pre\">cfunction</span></code> explicitly to create this pointer)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">...</span></code> (e.g. a vararg)<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">T...</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is the Julia type</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">va_arg</span></code><ul>\n<li>not supported</li>\n</ul>\n</li>\n</ul>\n</div>\n<div class=\"section\" id=\"ccall-cfunction-return-type-translation-guide\">\n<h3>ccall/cfunction return type translation guide<a class=\"headerlink\" href=\"#ccall-cfunction-return-type-translation-guide\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>For translating a <code class=\"docutils literal\"><span class=\"pre\">c</span></code> return type to <code class=\"docutils literal\"><span class=\"pre\">Julia</span></code>:</p>\n<ul class=\"simple\">\n<li><code class=\"docutils literal\"><span class=\"pre\">void</span></code><ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Void</span></code> (this will return the singleton instance <code class=\"docutils literal\"><span class=\"pre\">nothing::Void</span></code>)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">T</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is one of the primitive types:\n<code class=\"docutils literal\"><span class=\"pre\">char</span></code>, <code class=\"docutils literal\"><span class=\"pre\">int</span></code>, <code class=\"docutils literal\"><span class=\"pre\">long</span></code>, <code class=\"docutils literal\"><span class=\"pre\">short</span></code>, <code class=\"docutils literal\"><span class=\"pre\">float</span></code>, <code class=\"docutils literal\"><span class=\"pre\">double</span></code>, <code class=\"docutils literal\"><span class=\"pre\">complex</span></code>, <code class=\"docutils literal\"><span class=\"pre\">enum</span></code>\nor any of their <code class=\"docutils literal\"><span class=\"pre\">typedef</span></code> equivalents<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">T</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is an equivalent Julia Bits Type (per the table above)</li>\n<li>if <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is an <code class=\"docutils literal\"><span class=\"pre\">enum</span></code>, the argument type should be equivalent to <code class=\"docutils literal\"><span class=\"pre\">Cint</span></code> or <code class=\"docutils literal\"><span class=\"pre\">Cuint</span></code></li>\n<li>argument value will be copied (returned by-value)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">struct</span> <span class=\"pre\">T</span></code> (including typedef to a struct)<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">T</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is a Julia Leaf Type</li>\n<li>argument value will be copied (returned by-value)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">void*</span></code><ul>\n<li>depends on how this parameter is used, first translate this to the intended pointer type,\nthen determine the Julia equivalent using the remaining rules in this list</li>\n<li>this argument may be declared as <code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code>, if it really is just an unknown pointer</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code><ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Any</span></code></li>\n<li>argument value must be a valid Julia object</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">jl_value_t**</span></code><ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ref{Any}</span></code></li>\n<li>argument value must be a valid Julia object (or <code class=\"docutils literal\"><span class=\"pre\">C_NULL</span></code>)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">T*</span></code><ul>\n<li>If the memory is already owned by Julia, or is an <code class=\"docutils literal\"><span class=\"pre\">isbits</span></code> type, and is known to be non-null:<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is the Julia type corresponding to <code class=\"docutils literal\"><span class=\"pre\">T</span></code></li>\n<li>a return type of <code class=\"docutils literal\"><span class=\"pre\">Ref{Any}</span></code> is invalid, it should either be <code class=\"docutils literal\"><span class=\"pre\">Any</span></code>\n(corresponding to <code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code>) or <code class=\"docutils literal\"><span class=\"pre\">Ptr{Any}</span></code> (corresponding to <code class=\"docutils literal\"><span class=\"pre\">Ptr{Any}</span></code>)</li>\n<li>currently partially unsupported by cfunction due to #2818</li>\n<li>C <strong>MUST NOT</strong> modify the memory returned via <code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code> if <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is an <code class=\"docutils literal\"><span class=\"pre\">isbits</span></code> type</li>\n</ul>\n</li>\n<li>If the memory is owned by C:<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is the Julia type corresponding to <code class=\"docutils literal\"><span class=\"pre\">T</span></code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">(T*)(...)</span></code> (e.g. a pointer to a function)<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code> (you may need to use <code class=\"docutils literal\"><span class=\"pre\">cfunction</span></code> explicitly to create this pointer)</li>\n</ul>\n</li>\n</ul>\n</div>\n<div class=\"section\" id=\"passing-pointers-for-modifying-inputs\">\n<h3>Passing Pointers for Modifying Inputs<a class=\"headerlink\" href=\"#passing-pointers-for-modifying-inputs\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>Because C doesn&#8217;t support multiple return values,\noften C functions will take pointers to data that the function will modify.\nTo accomplish this within a <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code>,\nyou need to first encapsulate the value inside an <code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code> of the appropriate type.\nWhen you pass this <code class=\"docutils literal\"><span class=\"pre\">Ref</span></code> object as an argument,\njulia will automatically pass a C pointer to the encapsulated data:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">width</span> <span class=\"o\">=</span> <span class=\"n\">Ref</span><span class=\"p\">{</span><span class=\"n\">Cint</span><span class=\"p\">}(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">range</span> <span class=\"o\">=</span> <span class=\"n\">Ref</span><span class=\"p\">{</span><span class=\"n\">Cfloat</span><span class=\"p\">}(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"k\">ccall</span><span class=\"p\">(:</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"n\">Void</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">Ref</span><span class=\"p\">{</span><span class=\"n\">Cint</span><span class=\"p\">},</span> <span class=\"n\">Ref</span><span class=\"p\">{</span><span class=\"n\">Cfloat</span><span class=\"p\">}),</span> <span class=\"n\">width</span><span class=\"p\">,</span> <span class=\"n\">range</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Upon return, the contents of <code class=\"docutils literal\"><span class=\"pre\">width</span></code> and <code class=\"docutils literal\"><span class=\"pre\">range</span></code> can be retrieved\n(if they were changed by <code class=\"docutils literal\"><span class=\"pre\">foo</span></code>) by <code class=\"docutils literal\"><span class=\"pre\">width[]</span></code> and <code class=\"docutils literal\"><span class=\"pre\">range[]</span></code>; that is,\nthey act like zero-dimensional arrays.</p>\n</div>\n<div class=\"section\" id=\"special-reference-syntax-for-ccall-deprecated\">\n<h3>Special Reference Syntax for ccall (deprecated):<a class=\"headerlink\" href=\"#special-reference-syntax-for-ccall-deprecated\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>The <code class=\"docutils literal\"><span class=\"pre\">&amp;</span></code> syntax is deprecated, use the <code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code> argument type instead.</p>\n<p>A prefix <code class=\"docutils literal\"><span class=\"pre\">&amp;</span></code> is used on an argument to ccall to indicate that a pointer\nto a scalar argument should be passed instead of the scalar value itself\n(required for all Fortran function arguments, as noted above). The following\nexample computes a dot product using a BLAS function.</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">function</span><span class=\"nf\"> compute_dot</span><span class=\"p\">(</span><span class=\"n\">DX</span><span class=\"p\">::</span><span class=\"n\">Vector</span><span class=\"p\">{</span><span class=\"kt\">Float64</span><span class=\"p\">},</span> <span class=\"n\">DY</span><span class=\"p\">::</span><span class=\"n\">Vector</span><span class=\"p\">{</span><span class=\"kt\">Float64</span><span class=\"p\">})</span>\n  <span class=\"nb\">assert</span><span class=\"p\">(</span><span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">DX</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">DY</span><span class=\"p\">))</span>\n  <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">DX</span><span class=\"p\">)</span>\n  <span class=\"n\">incx</span> <span class=\"o\">=</span> <span class=\"n\">incy</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n  <span class=\"n\">product</span> <span class=\"o\">=</span> <span class=\"k\">ccall</span><span class=\"p\">((:</span><span class=\"n\">ddot_</span><span class=\"p\">,</span> <span class=\"s\">&quot;libLAPACK&quot;</span><span class=\"p\">),</span>\n                  <span class=\"kt\">Float64</span><span class=\"p\">,</span>\n                  <span class=\"p\">(</span><span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Int32</span><span class=\"p\">},</span> <span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Float64</span><span class=\"p\">},</span> <span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Int32</span><span class=\"p\">},</span> <span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Float64</span><span class=\"p\">},</span> <span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Int32</span><span class=\"p\">}),</span>\n                  <span class=\"o\">&amp;</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">DX</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">incx</span><span class=\"p\">,</span> <span class=\"n\">DY</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">incy</span><span class=\"p\">)</span>\n  <span class=\"k\">return</span> <span class=\"n\">product</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n<p>The meaning of prefix <code class=\"docutils literal\"><span class=\"pre\">&amp;</span></code> is not quite the same as in C. In\nparticular, any changes to the referenced variables will not be\nvisible in Julia unless the type is mutable (declared via\n<code class=\"docutils literal\"><span class=\"pre\">type</span></code>). However, even for immutable types it will not cause any\nharm for called functions to attempt such modifications (that is,\nwriting through the passed pointers). Moreover, <code class=\"docutils literal\"><span class=\"pre\">&amp;</span></code> may be used with\nany expression, such as <code class=\"docutils literal\"><span class=\"pre\">&amp;0</span></code> or <code class=\"docutils literal\"><span class=\"pre\">&amp;f(x)</span></code>.</p>\n<p>When a scalar value is passed with <code class=\"docutils literal\"><span class=\"pre\">&amp;</span></code> as an argument of type\n<code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code>, the value will first be converted to type <code class=\"docutils literal\"><span class=\"pre\">T</span></code>.</p>\n</div>\n</div>\n<div class=\"section\" id=\"garbage-collection-safety\">\n<h2>Garbage Collection Safety<a class=\"headerlink\" href=\"#garbage-collection-safety\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>When passing data to a ccall, it is best to avoid using the <code class=\"docutils literal\"><span class=\"pre\">pointer()</span></code>\nfunction. Instead define a convert method and pass the variables directly to\nthe ccall. ccall automatically arranges that all of its arguments will be\npreserved from garbage collection until the call returns. If a C API will\nstore a reference to memory allocated by Julia, after the ccall returns, you\nmust arrange that the object remains visible to the garbage collector. The\nsuggested way to handle this is to make a global variable of type\n<code class=\"docutils literal\"><span class=\"pre\">Array{Ref,1}</span></code> to hold these values, until the C library notifies you that\nit is finished with them.</p>\n<p>Whenever you have created a pointer to Julia data, you must ensure the original data\nexists until you are done with using the pointer. Many methods in Julia such as\n<code class=\"docutils literal\"><span class=\"pre\">unsafe_load()</span></code> and <code class=\"docutils literal\"><span class=\"pre\">bytestring()</span></code> make copies of data instead of taking ownership\nof the buffer, so that it is safe to free (or alter) the original data without\naffecting Julia. A notable exception is <code class=\"docutils literal\"><span class=\"pre\">pointer_to_array()</span></code> which, for performance\nreasons, shares (or can be told to take ownership of) the underlying buffer.</p>\n<p>The garbage collector does not guarantee any order of finalization. That is, if <code class=\"docutils literal\"><span class=\"pre\">a</span></code>\ncontained a reference to <code class=\"docutils literal\"><span class=\"pre\">b</span></code> and both <code class=\"docutils literal\"><span class=\"pre\">a</span></code> and <code class=\"docutils literal\"><span class=\"pre\">b</span></code> are due for garbage\ncollection, there is no guarantee that <code class=\"docutils literal\"><span class=\"pre\">b</span></code> would be finalized after <code class=\"docutils literal\"><span class=\"pre\">a</span></code>. If\nproper finalization of <code class=\"docutils literal\"><span class=\"pre\">a</span></code> depends on <code class=\"docutils literal\"><span class=\"pre\">b</span></code> being valid, it must be handled in\nother ways.</p>\n</div>\n<div class=\"section\" id=\"non-constant-function-specifications\">\n<h2>Non-constant Function Specifications<a class=\"headerlink\" href=\"#non-constant-function-specifications\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>A <code class=\"docutils literal\"><span class=\"pre\">(name,</span> <span class=\"pre\">library)</span></code> function specification must be a constant expression.\nHowever, it is possible to use computed values as function names by staging\nthrough <code class=\"docutils literal\"><span class=\"pre\">eval</span></code> as follows:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"p\">@</span><span class=\"n\">eval</span> <span class=\"k\">ccall</span><span class=\"p\">((</span><span class=\"o\">$</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">(</span><span class=\"s\">&quot;a&quot;</span><span class=\"p\">,</span><span class=\"s\">&quot;b&quot;</span><span class=\"p\">)),</span><span class=\"s\">&quot;lib&quot;</span><span class=\"p\">),</span> <span class=\"o\">...</span>\n</pre></div>\n</div>\n<p>This expression constructs a name using <code class=\"docutils literal\"><span class=\"pre\">string</span></code>, then substitutes this\nname into a new <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code> expression, which is then evaluated. Keep in mind that\n<code class=\"docutils literal\"><span class=\"pre\">eval</span></code> only operates at the top level, so within this expression local\nvariables will not be available (unless their values are substituted with\n<code class=\"docutils literal\"><span class=\"pre\">$</span></code>). For this reason, <code class=\"docutils literal\"><span class=\"pre\">eval</span></code> is typically only used to form top-level\ndefinitions, for example when wrapping libraries that contain many\nsimilar functions.</p>\n<p>If your usage is more dynamic, use indirect calls as described in the next section.</p>\n</div>\n<div class=\"section\" id=\"indirect-calls\">\n<h2>Indirect Calls<a class=\"headerlink\" href=\"#indirect-calls\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>The first argument to <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code> can also be an expression evaluated at run time.\nIn this case, the expression must evaluate to a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code>,\nwhich will be used as the address of the native function to call.\nThis behavior occurs when the first <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code> argument contains references to non-constants,\nsuch as local variables, function arguments, or non-constant globals.</p>\n<p>For example, you might lookup the function via <code class=\"docutils literal\"><span class=\"pre\">dlsym</span></code>,\nthen cache it in a global variable for that session. For example:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">macro</span> <span class=\"nb\">dlsym</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"n\">lib</span><span class=\"p\">)</span>\n    <span class=\"n\">z</span><span class=\"p\">,</span> <span class=\"n\">zlocal</span> <span class=\"o\">=</span> <span class=\"n\">gensym</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">)),</span> <span class=\"n\">gensym</span><span class=\"p\">()</span>\n    <span class=\"n\">eval</span><span class=\"p\">(</span><span class=\"n\">current_module</span><span class=\"p\">(),:(</span><span class=\"kd\">global</span> <span class=\"o\">$</span><span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"n\">C_NULL</span><span class=\"p\">))</span>\n    <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"n\">esc</span><span class=\"p\">(</span><span class=\"n\">z</span><span class=\"p\">)</span>\n    <span class=\"k\">quote</span>\n        <span class=\"k\">let</span> <span class=\"o\">$</span><span class=\"n\">zlocal</span><span class=\"p\">::</span><span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"n\">Void</span><span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"o\">$</span><span class=\"n\">z</span><span class=\"p\">::</span><span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"n\">Void</span><span class=\"p\">}</span>\n            <span class=\"k\">if</span> <span class=\"o\">$</span><span class=\"n\">zlocal</span> <span class=\"o\">==</span> <span class=\"n\">C_NULL</span>\n               <span class=\"o\">$</span><span class=\"n\">zlocal</span> <span class=\"o\">=</span> <span class=\"nb\">dlsym</span><span class=\"p\">(</span><span class=\"o\">$</span><span class=\"p\">(</span><span class=\"n\">esc</span><span class=\"p\">(</span><span class=\"n\">lib</span><span class=\"p\">))::</span><span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"n\">Void</span><span class=\"p\">},</span> <span class=\"o\">$</span><span class=\"p\">(</span><span class=\"n\">esc</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">)))</span>\n               <span class=\"kd\">global</span> <span class=\"o\">$</span><span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"o\">$</span><span class=\"n\">zlocal</span>\n            <span class=\"k\">end</span>\n            <span class=\"o\">$</span><span class=\"n\">zlocal</span>\n        <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">mylibvar</span> <span class=\"o\">=</span> <span class=\"nb\">dlopen</span><span class=\"p\">(</span><span class=\"s\">&quot;mylib&quot;</span><span class=\"p\">)</span>\n<span class=\"k\">ccall</span><span class=\"p\">(@</span><span class=\"nb\">dlsym</span><span class=\"p\">(</span><span class=\"s\">&quot;myfunc&quot;</span><span class=\"p\">,</span> <span class=\"n\">mylibvar</span><span class=\"p\">),</span> <span class=\"n\">Void</span><span class=\"p\">,</span> <span class=\"p\">())</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"calling-convention\">\n<h2>Calling Convention<a class=\"headerlink\" href=\"#calling-convention\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>The second argument to <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code> can optionally be a calling convention\nspecifier (immediately preceding return type). Without any specifier,\nthe platform-default C calling convention is used. Other supported\nconventions are: <code class=\"docutils literal\"><span class=\"pre\">stdcall</span></code>, <code class=\"docutils literal\"><span class=\"pre\">cdecl</span></code>, <code class=\"docutils literal\"><span class=\"pre\">fastcall</span></code>, and <code class=\"docutils literal\"><span class=\"pre\">thiscall</span></code>.\nFor example (from base/libc.jl) we see the same <code class=\"docutils literal\"><span class=\"pre\">gethostname</span></code> ccall as above,\nbut with the correct signature for Windows:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">hn</span> <span class=\"o\">=</span> <span class=\"n\">Array</span><span class=\"p\">(</span><span class=\"n\">UInt8</span><span class=\"p\">,</span> <span class=\"mi\">256</span><span class=\"p\">)</span>\n<span class=\"n\">err</span> <span class=\"o\">=</span> <span class=\"k\">ccall</span><span class=\"p\">(:</span><span class=\"n\">gethostname</span><span class=\"p\">,</span> <span class=\"n\">stdcall</span><span class=\"p\">,</span> <span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"n\">UInt8</span><span class=\"p\">},</span> <span class=\"n\">UInt32</span><span class=\"p\">),</span> <span class=\"n\">hn</span><span class=\"p\">,</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">hn</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p>For more information, please see the <a class=\"reference external\" href=\"http://llvm.org/docs/LangRef.html#calling-conventions\">LLVM Language Reference</a>.</p>\n</div>\n<div class=\"section\" id=\"accessing-global-variables\">\n<h2>Accessing Global Variables<a class=\"headerlink\" href=\"#accessing-global-variables\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Global variables exported by native libraries can be accessed by name using the\n<code class=\"docutils literal\"><span class=\"pre\">cglobal</span></code> function. The arguments to <code class=\"docutils literal\"><span class=\"pre\">cglobal</span></code> are a symbol specification\nidentical to that used by <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code>, and a type describing the value stored in\nthe variable:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">cglobal</span><span class=\"p\">((:</span><span class=\"n\">errno</span><span class=\"p\">,:</span><span class=\"n\">libc</span><span class=\"p\">),</span> <span class=\"kt\">Int32</span><span class=\"p\">)</span>\n<span class=\"n\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Int32</span><span class=\"p\">}</span> <span class=\"p\">@</span><span class=\"mh\">0x00007f418d0816b8</span>\n</pre></div>\n</div>\n<p>The result is a pointer giving the address of the value. The value can be\nmanipulated through this pointer using <code class=\"docutils literal\"><span class=\"pre\">unsafe_load</span></code> and <code class=\"docutils literal\"><span class=\"pre\">unsafe_store</span></code>.</p>\n</div>\n<div class=\"section\" id=\"accessing-data-through-a-pointer\">\n<h2>Accessing Data through a Pointer<a class=\"headerlink\" href=\"#accessing-data-through-a-pointer\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>The following methods are described as &#8220;unsafe&#8221; because a bad pointer\nor type declaration can cause Julia to terminate abruptly\n(although, that&#8217;s quite alike with ccall).</p>\n<p>Given a <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code>, the contents of type <code class=\"docutils literal\"><span class=\"pre\">T</span></code> can generally be copied from\nthe referenced memory into a Julia object using <code class=\"docutils literal\"><span class=\"pre\">unsafe_load(ptr,</span> <span class=\"pre\">[index])</span></code>.\nThe index argument is optional (default is 1),\nand follows the Julia-convention of 1-based indexing.\nThis function is intentionally similar to the behavior of <code class=\"docutils literal\"><span class=\"pre\">getindex()</span></code> and <code class=\"docutils literal\"><span class=\"pre\">setindex!()</span></code>\n(e.g. <code class=\"docutils literal\"><span class=\"pre\">[]</span></code> access syntax).</p>\n<p>The return value will be a new object initialized\nto contain a copy of the contents of the referenced memory.\nThe referenced memory can safely be freed or released.</p>\n<p>If <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is <code class=\"docutils literal\"><span class=\"pre\">Any</span></code>, then the memory is assumed to contain a reference to\na Julia object (a <code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code>), the result will be a reference to this object,\nand the object will not be copied. You must be careful in this case to ensure\nthat the object was always visible to the garbage collector (pointers do not\ncount, but the new reference does) to ensure the memory is not prematurely freed.\nNote that if the object was not originally allocated by Julia, the new object\nwill never be finalized by Julia&#8217;s garbage collector.  If the <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> itself\nis actually a <code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code>, it can be converted back to a Julia object\nreference by <code class=\"docutils literal\"><span class=\"pre\">unsafe_pointer_to_objref(ptr)</span></code>.  (Julia values <code class=\"docutils literal\"><span class=\"pre\">v</span></code>\ncan be converted to <code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code> pointers, as <code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code>, by calling\n<code class=\"docutils literal\"><span class=\"pre\">pointer_from_objref(v)</span></code>.)</p>\n<p>The reverse operation (writing data to a Ptr{T}), can be performed using\n<code class=\"docutils literal\"><span class=\"pre\">unsafe_store!(ptr,</span> <span class=\"pre\">value,</span> <span class=\"pre\">[index])</span></code>.  Currently, this is only supported\nfor bitstypes or other pointer-free (<code class=\"docutils literal\"><span class=\"pre\">isbits</span></code>) immutable types.</p>\n<p>Any operation that throws an error is probably currently unimplemented\nand should be posted as a bug so that it can be resolved.</p>\n<p>If the pointer of interest is a plain-data array (bitstype or immutable), the\nfunction <code class=\"docutils literal\"><span class=\"pre\">pointer_to_array(ptr,dims,[own])</span></code> may be more useful. The final\nparameter should be true if Julia should &#8220;take ownership&#8221; of the underlying\nbuffer and call <code class=\"docutils literal\"><span class=\"pre\">free(ptr)</span></code> when the returned <code class=\"docutils literal\"><span class=\"pre\">Array</span></code> object is finalized.\nIf the <code class=\"docutils literal\"><span class=\"pre\">own</span></code> parameter is omitted or false, the caller must ensure the\nbuffer remains in existence until all access is complete.</p>\n<p>Arithmetic on the <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> type in Julia (e.g. using <code class=\"docutils literal\"><span class=\"pre\">+</span></code>) does not behave the\nsame as C&#8217;s pointer arithmetic. Adding an integer to a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> in Julia always\nmoves the pointer by some number of <em>bytes</em>, not elements. This way, the\naddress values obtained from pointer arithmetic do not depend on the\nelement types of pointers.</p>\n</div>\n<div class=\"section\" id=\"thread-safety\">\n<h2>Thread-safety<a class=\"headerlink\" href=\"#thread-safety\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Some C libraries execute their callbacks from a different thread, and\nsince Julia isn&#8217;t thread-safe you&#8217;ll need to take some extra\nprecautions. In particular, you&#8217;ll need to set up a two-layered\nsystem: the C callback should only <em>schedule</em> (via Julia&#8217;s event loop)\nthe execution of your &#8220;real&#8221; callback. To do this, you pass a function\nof one argument (the <code class=\"docutils literal\"><span class=\"pre\">AsyncWork</span></code> object for which the event was\ntriggered, which you&#8217;ll probably just ignore) to <code class=\"docutils literal\"><span class=\"pre\">SingleAsyncWork</span></code>:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">cb</span> <span class=\"o\">=</span> <span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">SingleAsyncWork</span><span class=\"p\">(</span><span class=\"n\">data</span> <span class=\"o\">-&gt;</span> <span class=\"n\">my_real_callback</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p>The callback you pass to C should only execute a <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code> to\n<code class=\"docutils literal\"><span class=\"pre\">:uv_async_send</span></code>, passing <code class=\"docutils literal\"><span class=\"pre\">cb.handle</span></code> as the argument.</p>\n</div>\n<div class=\"section\" id=\"more-about-callbacks\">\n<h2>More About Callbacks<a class=\"headerlink\" href=\"#more-about-callbacks\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>For more details on how to pass callbacks to C libraries, see this\n<a class=\"reference external\" href=\"http://julialang.org/blog/2013/05/callback\">blog post</a>.</p>\n</div>\n<div class=\"section\" id=\"c\">\n<h2>C++<a class=\"headerlink\" href=\"#c\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Limited support for C++ is provided by the <a class=\"reference external\" href=\"https://github.com/timholy/Cpp.jl\">Cpp</a>,\n<a class=\"reference external\" href=\"https://github.com/ihnorton/Clang.jl\">Clang</a>, and <a class=\"reference external\" href=\"https://github.com/Keno/Cxx.jl\">Cxx</a> packages.</p>\n</div>\n<div class=\"section\" id=\"handling-operating-system-variation\">\n<h2>Handling Operating System Variation<a class=\"headerlink\" href=\"#handling-operating-system-variation\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>When dealing with platform libraries, it is often necessary to provide special cases\nfor various platforms. The variable <code class=\"docutils literal\"><span class=\"pre\">OS_NAME</span></code> can be used to write these special\ncases. Additionally, there are several macros intended to make this easier:\n<code class=\"docutils literal\"><span class=\"pre\">&#64;windows</span></code>, <code class=\"docutils literal\"><span class=\"pre\">&#64;unix</span></code>, <code class=\"docutils literal\"><span class=\"pre\">&#64;linux</span></code>, and <code class=\"docutils literal\"><span class=\"pre\">&#64;osx</span></code>. Note that linux and osx are mutually\nexclusive subsets of unix. Their usage takes the form of a ternary conditional\noperator, as demonstrated in the following examples.</p>\n<p>Simple blocks:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">ccall</span><span class=\"p\">(</span> <span class=\"p\">(@</span><span class=\"n\">windows</span><span class=\"o\">?</span> <span class=\"p\">:</span><span class=\"n\">_fopen</span> <span class=\"p\">:</span> <span class=\"p\">:</span><span class=\"n\">fopen</span><span class=\"p\">),</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Complex blocks:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"p\">@</span><span class=\"n\">linux</span><span class=\"o\">?</span> <span class=\"p\">(</span>\n         <span class=\"k\">begin</span>\n             <span class=\"n\">some_complicated_thing</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n         <span class=\"k\">end</span>\n       <span class=\"p\">:</span> <span class=\"k\">begin</span>\n             <span class=\"n\">some_different_thing</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n         <span class=\"k\">end</span>\n       <span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Chaining (parentheses optional, but recommended for readability):</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"p\">@</span><span class=\"n\">windows</span><span class=\"o\">?</span> <span class=\"p\">:</span><span class=\"n\">a</span> <span class=\"p\">:</span> <span class=\"p\">(@</span><span class=\"n\">osx</span><span class=\"o\">?</span> <span class=\"p\">:</span><span class=\"n\">b</span> <span class=\"p\">:</span> <span class=\"p\">:</span><span class=\"n\">c</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</div>\n</div>\n\n\n          </div>\n          <footer>\n  \n    <div class=\"rst-footer-buttons\" role=\"navigation\" aria-label=\"footer navigation\">\n      \n        <a href=\"interacting-with-julia.html\" class=\"btn btn-neutral float-right\" title=\"Interacting With Julia\">Next <span class=\"fa fa-arrow-circle-right\"></span></a>\n      \n      \n        <a href=\"running-external-programs.html\" class=\"btn btn-neutral\" title=\"Running External Programs\"><span class=\"fa fa-arrow-circle-left\"></span> Previous</a>\n      \n    </div>\n  \n\n  <hr/>\n\n  <div role=\"contentinfo\">\n    <p>\n    </p>\n  </div>\n\n  <a href=\"https://github.com/snide/sphinx_rtd_theme\">Sphinx theme</a> provided by <a href=\"https://readthedocs.org\">Read the Docs</a>\n</footer>\n        </div>\n      </div>\n\n    </section>\n\n  </div>\n  \n\n  \n\n    <script type=\"text/javascript\">\n        var DOCUMENTATION_OPTIONS = {\n            URL_ROOT:'../',\n            VERSION:'0.4.5',\n            COLLAPSE_INDEX:false,\n            FILE_SUFFIX:'.html',\n            HAS_SOURCE:  true\n        };\n    </script>\n      <script type=\"text/javascript\" src=\"../_static/jquery.js\"></script>\n      <script type=\"text/javascript\" src=\"../_static/underscore.js\"></script>\n      <script type=\"text/javascript\" src=\"../_static/doctools.js\"></script>\n      <script type=\"text/javascript\" src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>\n\n  \n\n  \n  \n    <script type=\"text/javascript\" src=\"../_static/js/theme.js\"></script>\n  \n\n  \n  \n  <script type=\"text/javascript\">\n      jQuery(function () {\n          SphinxRtdTheme.StickyNav.enable();\n      });\n  </script>\n   \n\n</body>\n</html>",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/_sources/stdlib/libdl.txt": ".. module:: Libdl\n\n****************\n Dynamic Linker\n****************\n\n.. function:: dlopen(libfile::AbstractString [, flags::Integer])\n\n   .. Docstring generated from Julia source\n\n   Load a shared library, returning an opaque handle.\n\n   The optional flags argument is a bitwise-or of zero or more of ``RTLD_LOCAL``\\ , ``RTLD_GLOBAL``\\ , ``RTLD_LAZY``\\ , ``RTLD_NOW``\\ , ``RTLD_NODELETE``\\ , ``RTLD_NOLOAD``\\ , ``RTLD_DEEPBIND``\\ , and ``RTLD_FIRST``\\ . These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default ``dlopen`` flags are ``RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL`` while on other platforms the defaults are ``RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL``\\ . An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance ``RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL`` allows the library's symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.\n\n.. function:: dlopen_e(libfile::AbstractString [, flags::Integer])\n\n   .. Docstring generated from Julia source\n\n   Similar to :func:`dlopen`, except returns a ``NULL`` pointer instead of raising errors.\n\n.. data:: RTLD_DEEPBIND\n\n   Enum constant for :func:`dlopen`. See your platform man page for details, if applicable.\n\n.. data:: RTLD_FIRST\n\n   Enum constant for :func:`dlopen`. See your platform man page for details, if applicable.\n\n.. data:: RTLD_GLOBAL\n\n   Enum constant for :func:`dlopen`. See your platform man page for details, if applicable.\n\n.. data:: RTLD_LAZY\n\n   Enum constant for :func:`dlopen`. See your platform man page for details, if applicable.\n\n.. data:: RTLD_LOCAL\n\n   Enum constant for :func:`dlopen`. See your platform man page for details, if applicable.\n\n.. data:: RTLD_NODELETE\n\n   Enum constant for :func:`dlopen`. See your platform man page for details, if applicable.\n\n.. data:: RTLD_NOLOAD\n\n   Enum constant for :func:`dlopen`. See your platform man page for details, if applicable.\n\n.. data:: RTLD_NOW\n\n   Enum constant for :func:`dlopen`. See your platform man page for details, if applicable.\n\n.. function:: dlsym(handle, sym)\n\n   .. Docstring generated from Julia source\n\n   Look up a symbol from a shared library handle, return callable function pointer on success.\n\n.. function:: dlsym_e(handle, sym)\n\n   .. Docstring generated from Julia source\n\n   Look up a symbol from a shared library handle, silently return ``NULL`` pointer on lookup failure.\n\n.. function:: dlclose(handle)\n\n   .. Docstring generated from Julia source\n\n   Close shared library referenced by handle.\n\n.. data:: dlext\n\n   File extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.\n\n.. function:: find_library(names, locations)\n\n   .. Docstring generated from Julia source\n\n   Searches for the first library in ``names`` in the paths in the ``locations`` list, ``DL_LOAD_PATH``\\ , or system library paths (in that order) which can successfully be dlopen'd. On success, the return value will be one of the names (potentially prefixed by one of the paths in locations). This string can be assigned to a ``global const`` and used as the library name in future ``ccall``\\ 's. On failure, it returns the empty string.\n\n.. data:: DL_LOAD_PATH\n\n   When calling ``dlopen``, the paths in this list will be searched first, in order, before searching the\n   system locations for a valid library handle.\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/_sources/stdlib/c.txt": ".. currentmodule:: Base\n\n*************\n C Interface\n*************\n\n.. function:: ccall((symbol, library) or function_pointer, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n\n   .. Docstring generated from Julia source\n\n   Call function in C-exported shared library, specified by ``(function name, library)`` tuple, where each component is a string or symbol.\n\n   Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression. Alternatively, ``ccall`` may also be used to call a function pointer, such as one returned by ``dlsym``\\ .\n\n   Each ``ArgumentValue`` to the ``ccall`` will be converted to the corresponding ``ArgumentType``\\ , by automatic insertion of calls to ``unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))``\\ . (See also the documentation for each of these functions for further details.) In most cases, this simply results in a call to ``convert(ArgumentType, ArgumentValue)``\\ .\n\n.. function:: cglobal((symbol, library) [, type=Void])\n\n   .. Docstring generated from Julia source\n\n   Obtain a pointer to a global variable in a C-exported shared library, specified exactly as in ``ccall``\\ . Returns a ``Ptr{Type}``\\ , defaulting to ``Ptr{Void}`` if no Type argument is supplied. The values can be read or written by ``unsafe_load`` or ``unsafe_store!``\\ , respectively.\n\n.. function:: cfunction(function::Function, ReturnType::Type, (ArgumentTypes...))\n\n   .. Docstring generated from Julia source\n\n   Generate C-callable function pointer from Julia function. Type annotation of the return value in the callback function is a must for situations where Julia cannot infer the return type automatically.\n\n   For example:\n\n   .. code-block:: julia\n\n       function foo()\n           # body\n\n           retval::Float64\n       end\n\n       bar = cfunction(foo, Float64, ())\n\n.. function:: unsafe_convert(T,x)\n\n   .. Docstring generated from Julia source\n\n   Convert ``x`` to a value of type ``T``\n\n   In cases where ``convert`` would need to take a Julia object and turn it into a ``Ptr``\\ , this function should be used to define and perform that conversion.\n\n   Be careful to ensure that a julia reference to ``x`` exists as long as the result of this function will be used. Accordingly, the argument ``x`` to this function should never be an expression, only a variable name or field reference. For example, ``x=a.b.c`` is acceptable, but ``x=[a,b,c]`` is not.\n\n   The ``unsafe`` prefix on this function indicates that using the result of this function after the ``x`` argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.\n\n.. function:: cconvert(T,x)\n\n   .. Docstring generated from Julia source\n\n   Convert ``x`` to a value of type ``T``\\ , typically by calling ``convert(T,x)``\n\n   In cases where ``x`` cannot be safely converted to ``T``\\ , unlike ``convert``\\ , ``cconvert`` may return an object of a type different from ``T``\\ , which however is suitable for ``unsafe_convert`` to handle.\n\n   Neither ``convert`` nor ``cconvert`` should take a Julia object and turn it into a ``Ptr``\\ .\n\n.. function:: unsafe_load(p::Ptr{T},i::Integer)\n\n   .. Docstring generated from Julia source\n\n   Load a value of type ``T`` from the address of the ith element (1-indexed) starting at ``p``\\ . This is equivalent to the C expression ``p[i-1]``\\ .\n\n   The ``unsafe`` prefix on this function indicates that no validation is performed on the pointer ``p`` to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.\n\n.. function:: unsafe_store!(p::Ptr{T},x,i::Integer)\n\n   .. Docstring generated from Julia source\n\n   Store a value of type ``T`` to the address of the ith element (1-indexed) starting at ``p``\\ . This is equivalent to the C expression ``p[i-1] = x``\\ .\n\n   The ``unsafe`` prefix on this function indicates that no validation is performed on the pointer ``p`` to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n.. function:: unsafe_copy!(dest::Ptr{T}, src::Ptr{T}, N)\n\n   .. Docstring generated from Julia source\n\n   Copy ``N`` elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.\n\n   The ``unsafe`` prefix on this function indicates that no validation is performed on the pointers ``dest`` and ``src`` to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n.. function:: unsafe_copy!(dest::Array, do, src::Array, so, N)\n\n   .. Docstring generated from Julia source\n\n   Copy ``N`` elements from a source array to a destination, starting at offset ``so`` in the source and ``do`` in the destination (1-indexed).\n\n   The ``unsafe`` prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n.. function:: copy!(dest, src)\n\n   .. Docstring generated from Julia source\n\n   Copy all elements from collection ``src`` to array ``dest``\\ . Returns ``dest``\\ .\n\n.. function:: copy!(dest, do, src, so, N)\n\n   .. Docstring generated from Julia source\n\n   Copy ``N`` elements from collection ``src`` starting at offset ``so``\\ , to array ``dest`` starting at offset ``do``\\ . Returns ``dest``\\ .\n\n.. function:: pointer(array [, index])\n\n   .. Docstring generated from Julia source\n\n   Get the native address of an array or string element. Be careful to ensure that a julia reference to ``a`` exists as long as this pointer will be used. This function is \"unsafe\" like ``unsafe_convert``\\ .\n\n   Calling ``Ref(array[, index])`` is generally preferable to this function.\n\n.. function:: pointer_to_array(pointer, dims[, take_ownership::Bool])\n\n   .. Docstring generated from Julia source\n\n   Wrap a native pointer as a Julia Array object. The pointer element type determines the array element type. ``own`` optionally specifies whether Julia should take ownership of the memory, calling ``free`` on the pointer when the array is no longer referenced.\n\n.. function:: pointer_from_objref(object_instance)\n\n   .. Docstring generated from Julia source\n\n   Get the memory address of a Julia object as a ``Ptr``\\ . The existence of the resulting ``Ptr`` will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the ``Ptr`` will be used.\n\n.. function:: unsafe_pointer_to_objref(p::Ptr)\n\n   .. Docstring generated from Julia source\n\n   Convert a ``Ptr`` to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered \"unsafe\" and should be used with care.\n\n.. function:: disable_sigint(f::Function)\n\n   .. Docstring generated from Julia source\n\n   Disable Ctrl-C handler during execution of a function, for calling external code that is not interrupt safe. Intended to be called using ``do`` block syntax as follows:\n\n   .. code-block:: julia\n\n       disable_sigint() do\n           # interrupt-unsafe code\n           ...\n       end\n\n.. function:: reenable_sigint(f::Function)\n\n   .. Docstring generated from Julia source\n\n   Re-enable Ctrl-C handler during execution of a function. Temporarily reverses the effect of ``disable_sigint``\\ .\n\n.. function:: systemerror(sysfunc, iftrue)\n\n   .. Docstring generated from Julia source\n\n   Raises a ``SystemError`` for ``errno`` with the descriptive string ``sysfunc`` if ``iftrue`` is ``true``\n\n.. data:: Ptr{T}\n\n   A memory address referring to data of type ``T``.\n   However, there is no guarantee that the memory is actually valid,\n   or that it actually represents data of the specified type.\n\n.. data:: Ref{T}\n\n   An object that safely references data of type ``T``.\n   This type is guaranteed to point to valid, Julia-allocated memory\n   of the correct type. The underlying data is protected from freeing by\n   the garbage collector as long as the ``Ref`` itself is referenced.\n\n   When passed as a ``ccall`` argument (either as a ``Ptr`` or ``Ref`` type),\n   a ``Ref`` object will be converted to a native pointer to the data it references.\n\n   There is no invalid (NULL) ``Ref``.\n\n.. data:: Cchar\n\n   Equivalent to the native ``char`` c-type\n\n.. data:: Cuchar\n\n   Equivalent to the native ``unsigned char`` c-type (UInt8)\n\n.. data:: Cshort\n\n   Equivalent to the native ``signed short`` c-type (Int16)\n\n.. data:: Cushort\n\n   Equivalent to the native ``unsigned short`` c-type (UInt16)\n\n.. data:: Cint\n\n   Equivalent to the native ``signed int`` c-type (Int32)\n\n.. data:: Cuint\n\n   Equivalent to the native ``unsigned int`` c-type (UInt32)\n\n.. data:: Clong\n\n   Equivalent to the native ``signed long`` c-type\n\n.. data:: Culong\n\n   Equivalent to the native ``unsigned long`` c-type\n\n.. data:: Clonglong\n\n   Equivalent to the native ``signed long long`` c-type (Int64)\n\n.. data:: Culonglong\n\n   Equivalent to the native ``unsigned long long`` c-type (UInt64)\n\n.. data:: Cintmax_t\n\n   Equivalent to the native ``intmax_t`` c-type (Int64)\n\n.. data:: Cuintmax_t\n\n   Equivalent to the native ``uintmax_t`` c-type (UInt64)\n\n.. data:: Csize_t\n\n   Equivalent to the native ``size_t`` c-type (UInt)\n\n.. data:: Cssize_t\n\n   Equivalent to the native ``ssize_t`` c-type\n\n.. data:: Cptrdiff_t\n\n   Equivalent to the native ``ptrdiff_t`` c-type (Int)\n\n.. data:: Coff_t\n\n   Equivalent to the native ``off_t`` c-type\n\n.. data:: Cwchar_t\n\n   Equivalent to the native ``wchar_t`` c-type (Int32)\n\n.. data:: Cfloat\n\n   Equivalent to the native ``float`` c-type (Float32)\n\n.. data:: Cdouble\n\n   Equivalent to the native ``double`` c-type (Float64)\n\n****************\n LLVM Interface\n****************\n\n.. function:: llvmcall(IR::String, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n\n   .. Docstring generated from Julia source\n\n   Call LLVM IR string in the first argument. Similar to an LLVM function ``define`` block, arguments are available as consecutive unnamed SSA variables (%0, %1, etc.).\n\n   Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.\n\n   Each ``ArgumentValue`` to ``llvmcall`` will be converted to the corresponding ``ArgumentType``\\ , by automatic insertion of calls to ``unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))``\\ . (see also the documentation for each of these functions for further details). In most cases, this simply results in a call to ``convert(ArgumentType, ArgumentValue)``\\ .\n\n   See ``test/llvmcall.jl`` for usage examples.\n\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/_sources/manual/calling-c-and-fortran-code.txt": ".. _man-calling-c-and-fortran-code:\n\n****************************\n Calling C and Fortran Code\n****************************\n\nThough most code can be written in Julia, there are many high-quality,\nmature libraries for numerical computing already written in C and\nFortran. To allow easy use of this existing code, Julia makes it simple\nand efficient to call C and Fortran functions. Julia has a \"no\nboilerplate\" philosophy: functions can be called directly from Julia\nwithout any \"glue\" code, code generation, or compilation \u2014 even from the\ninteractive prompt. This is accomplished just by making an appropriate call\nwith ``ccall`` syntax, which looks like an ordinary function call.\n\nThe code to be called must be available as a shared library. Most C and\nFortran libraries ship compiled as shared libraries already, but if you\nare compiling the code yourself using GCC (or Clang), you will need to\nuse the ``-shared`` and ``-fPIC`` options. The machine instructions\ngenerated by Julia's JIT are the same as a native C call would be, so\nthe resulting overhead is the same as calling a library function from C\ncode. (Non-library function calls in both C and Julia can be inlined and\nthus may have even less overhead than calls to shared library functions.\nWhen both libraries and executables are generated by LLVM, it is\npossible to perform whole-program optimizations that can even optimize\nacross this boundary, but Julia does not yet support that. In the\nfuture, however, it may do so, yielding even greater performance gains.)\n\nShared libraries and functions are referenced by a tuple of the\nform ``(:function, \"library\")`` or ``(\"function\", \"library\")`` where ``function``\nis the C-exported function name. ``library`` refers to the shared library\nname: shared libraries available in the (platform-specific) load path\nwill be resolved by name, and if necessary a direct path may be specified.\n\nA function name may be used alone in place of the tuple (just\n``:function`` or ``\"function\"``). In this case the name is resolved within\nthe current process. This form can be used to call C library functions,\nfunctions in the Julia runtime, or functions in an application linked to\nJulia.\n\nBy default, Fortran compilers `generate mangled names\n<https://en.wikipedia.org/wiki/Name_mangling#Fortran>`_\n(for example, converting function names to lowercase or uppercase,\noften appending an underscore), and so to call a Fortran function via\n``ccall`` you must pass the mangled identifier corresponding to the rule\nfollowed by your Fortran compiler.  Also, when calling a Fortran\nfunction, all inputs must be passed by reference.\n\nFinally, you can use ``ccall`` to actually generate a call to the\nlibrary function. Arguments to ``ccall`` are as follows:\n\n1. (:function, \"library\") pair (must be a constant, but see below).\n\n2. Return type (see below for mapping the declared C type to Julia)\n\n   - This argument will be evaluated at compile-time.\n\n3. A tuple of input types. The input types must be written as a literal tuple,\n   not a tuple-valued variable or expression.\n\n   - This argument will be evaluated at compile-time.\n\n4. The following arguments, if any, are the actual argument values\n   passed to the function.\n\nAs a complete but simple example, the following calls the ``clock``\nfunction from the standard C library::\n\n    julia> t = ccall( (:clock, \"libc\"), Int32, ())\n    2292761\n\n    julia> t\n    2292761\n\n    julia> typeof(ans)\n    Int32\n\n``clock`` takes no arguments and returns an ``Int32``. One common gotcha\nis that a 1-tuple must be written with a trailing comma. For\nexample, to call the ``getenv`` function to get a pointer to the value\nof an environment variable, one makes a call like this::\n\n    julia> path = ccall((:getenv, \"libc\"), Ptr{UInt8}, (Ptr{UInt8},), \"SHELL\")\n    Ptr{UInt8} @0x00007fff5fbffc45\n\n    julia> bytestring(path)\n    \"/bin/bash\"\n\nNote that the argument type tuple must be written as ``(Ptr{UInt8},)``,\nrather than ``(Ptr{UInt8})``. This is because ``(Ptr{UInt8})`` is just\nthe expression ``Ptr{UInt8}`` surrounded by parentheses, rather than\na 1-tuple containing ``Ptr{UInt8}``::\n\n    julia> (Ptr{UInt8})\n    Ptr{UInt8}\n\n    julia> (Ptr{UInt8},)\n    (Ptr{UInt8},)\n\nIn practice, especially when providing reusable functionality, one\ngenerally wraps ``ccall`` uses in Julia functions that set up arguments\nand then check for errors in whatever manner the C or Fortran function\nindicates them, propagating to the Julia caller as exceptions. This is\nespecially important since C and Fortran APIs are notoriously\ninconsistent about how they indicate error conditions. For example, the\n``getenv`` C library function is wrapped in the following Julia function\nin\n`env.jl <https://github.com/JuliaLang/julia/blob/master/base/env.jl>`_::\n\n    function getenv(var::AbstractString)\n      val = ccall((:getenv, \"libc\"),\n                  Ptr{UInt8}, (Ptr{UInt8},), var)\n      if val == C_NULL\n        error(\"getenv: undefined variable: \", var)\n      end\n      bytestring(val)\n    end\n\nThe C ``getenv`` function indicates an error by returning ``NULL``, but\nother standard C functions indicate errors in various different ways,\nincluding by returning -1, 0, 1 and other special values. This wrapper\nthrows an exception clearly indicating the problem if the caller tries\nto get a non-existent environment variable::\n\n    julia> getenv(\"SHELL\")\n    \"/bin/bash\"\n\n    julia> getenv(\"FOOBAR\")\n    getenv: undefined variable: FOOBAR\n\nHere is a slightly more complex example that discovers the local\nmachine's hostname::\n\n    function gethostname()\n      hostname = Array(UInt8, 128)\n      ccall((:gethostname, \"libc\"), Int32,\n            (Ptr{UInt8}, Csize_t),\n            hostname, sizeof(hostname))\n      hostname[end] = 0; # ensure null-termination\n      return bytestring(pointer(hostname))\n    end\n\nThis example first allocates an array of bytes, then calls the C library\nfunction ``gethostname`` to fill the array in with the hostname, takes a\npointer to the hostname buffer, and converts the pointer to a Julia\nstring, assuming that it is a NUL-terminated C string. It is common for\nC libraries to use this pattern of requiring the caller to allocate\nmemory to be passed to the callee and filled in. Allocation of memory\nfrom Julia like this is generally accomplished by creating an\nuninitialized array and passing a pointer to its data to the C function.\n\nCreating C-Compatible Julia Function Pointers\n---------------------------------------------\n\nIt is possible to pass Julia functions to native c-functions that accept\nfunction pointer arguments. For example, to match c-prototypes of the form::\n\n    typedef returntype (*functiontype)(argumenttype,...)\n\nThe function ``cfunction`` generates the c-compatible function pointer for\na call to a Julia library function.\nArguments to ``cfunction`` are as follows:\n\n1. A Julia Function\n\n2. Return type\n\n3. A tuple of input types\n\nA classic example is the standard C library ``qsort`` function,\ndeclared as::\n\n    void qsort(void *base, size_t nmemb, size_t size,\n               int(*compare)(const void *a, const void *b));\n\nThe ``base`` argument is a pointer to an array of length ``nmemb``, with elements of\n``size`` bytes each. ``compare`` is a callback function which takes pointers to two\nelements ``a`` and ``b`` and returns an integer less/greater than zero if ``a`` should\nappear before/after ``b`` (or zero if any order is permitted). Now, suppose that we\nhave a 1d array ``A`` of values in Julia that we want to sort using the ``qsort``\nfunction (rather than Julia's built-in ``sort`` function). Before we worry about calling\n``qsort`` and passing arguments, we need to write a comparison function that works for\nsome arbitrary type T::\n\n    function mycompare{T}(a::T, b::T)\n        return convert(Cint, a < b ? -1 : a > b ? +1 : 0)::Cint\n    end\n\nNotice that we have to be careful about the return type: ``qsort`` expects a function\nreturning a C ``int``, so we must be sure to return ``Cint`` via a call to ``convert``\nand a ``typeassert``.\n\nIn order to pass this function to C, we obtain its address using the function ``cfunction``::\n\n    const mycompare_c = cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}))\n\n``cfunction`` accepts three arguments: the Julia function (``mycompare``), the return\ntype (``Cint``), and a tuple of the argument types, in this case to sort an array of\n``Cdouble`` (Float64) elements.\n\nThe final call to ``qsort`` looks like this::\n\n    A = [1.3, -2.7, 4.4, 3.1]\n    ccall(:qsort, Void, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Void}),\n          A, length(A), sizeof(eltype(A)), mycompare_c)\n\nAfter this executes, ``A`` is changed to the sorted array ``[-2.7, 1.3, 3.1, 4.4]``.\nNote that Julia knows how to convert an array into a ``Ptr{Cdouble}``, how to compute\nthe size of a type in bytes (identical to C's ``sizeof`` operator), and so on.\nFor fun, try inserting a ``println(\"mycompare($a,$b)\")`` line into ``mycompare``, which\nwill allow you to see the comparisons that ``qsort`` is performing (and to verify that\nit is really calling the Julia function that you passed to it).\n\n\nMapping C Types to Julia\n------------------------\n\nIt is critical to exactly match the declared C type with its declaration\nin Julia. Inconsistencies can cause code that works correctly on one system\nto fail or produce indeterminate results on a different system.\n\nNote that no C header files are used anywhere in the process of calling C\nfunctions: you are responsible for making sure that your Julia types and\ncall signatures accurately reflect those in the C header file. (The `Clang\npackage <https://github.com/ihnorton/Clang.jl>`_ can be used to auto-generate\nJulia code from a C header file.)\n\nAuto-conversion:\n~~~~~~~~~~~~~~~~\n\nJulia automatically inserts calls to the ``convert`` function to convert\neach argument to the specified type. For example, the following call::\n\n    ccall((:foo, \"libfoo\"), Void, (Int32, Float64), x, y)\n\nwill behave as if the following were written::\n\n    ccall((:foo, \"libfoo\"), Void, (Int32, Float64),\n          Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),\n          Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))\n\n``cconvert`` normally just calls ``convert``, but can be defined to return\nan arbitrary new object more appropriate for passing to C. For example,\nthis is used to convert an ``Array`` of objects (e.g. strings) to an\narray of pointers.\n\n``unsafe_convert`` handles conversion to ``Ptr`` types. It is considered\nunsafe because converting an object to a native pointer can hide the object\nfrom the garbage collector, causing it to be freed prematurely.\n\nType Correspondences:\n~~~~~~~~~~~~~~~~~~~~~\n\nFirst, a review of some relevant Julia type terminology:\n\n.. rst-class:: text-wrap\n\n==============================  ==============================  ======================================================\nSyntax / Keyword                Example                         Description\n==============================  ==============================  ======================================================\n``type``                        ``ASCIIString``                 \"Leaf Type\" :: A group of related data that includes\n                                                                a type-tag, is managed by the Julia GC, and\n                                                                is defined by object-identity.\n                                                                The type parameters of a leaf type must be fully defined\n                                                                (no ``TypeVars`` are allowed)\n                                                                in order for the instance to be constructed.\n\n``abstract``                    ``Any``,                        \"Super Type\" :: A super-type (not a leaf-type)\n                                ``AbstractArray{T,N}``,         that cannot be instantiated, but can be used to\n                                ``Complex{T}``                  describe a group of types.\n\n``{T}``                         ``Vector{Int}``                 \"Type Parameter\" :: A specialization of a type\n                                                                (typically used for dispatch or storage optimization).\n\n                                                                \"TypeVar\" :: The ``T`` in the type parameter declaration\n                                                                is referred to as a TypeVar (short for type variable).\n\n``bitstype``                    ``Int``,                        \"Bits Type\" :: A type with no fields, but a size. It\n                                ``Float64``                     is stored and defined by-value.\n\n``immutable``                   ``Pair{Int,Int}``               \"Immutable\" :: A type with all fields defined to be\n                                                                constant. It is defined by-value. And may be stored\n                                                                with a type-tag.\n\n                                ``Complex128`` (``isbits``)     \"Is-Bits\" :: A ``bitstype``, or an ``immutable`` type\n                                                                where all fields are other ``isbits`` types. It is\n                                                                defined by-value, and is stored without a type-tag.\n\n``type ...; end``               ``nothing``                     \"Singleton\" :: a Leaf Type or Immutable with no fields.\n\n``(...)`` or ``tuple(...)```    ``(1,2,3)``                     \"Tuple\" :: an immutable data-structure similar to an\n                                                                anonymous immutable type, or a constant array.\n                                                                Represented as either an array or a struct.\n\n``typealias``                   Not applicable here             Type aliases, and other similar mechanisms of\n                                                                doing type indirection, are resolved to their base\n                                                                type (this includes assigning a type to another name,\n                                                                or getting the type out of a function call).\n==============================  ==============================  ======================================================\n\nBits Types:\n~~~~~~~~~~~\n\nThere are several special types to be aware of, as no other type can be defined to behave the same:\n\n``Float32``\n    Exactly corresponds to the ``float`` type in C (or ``REAL*4`` in Fortran).\n\n``Float64``\n    Exactly corresponds to the ``double`` type in C (or ``REAL*8`` in Fortran).\n\n``Complex64``\n    Exactly corresponds to the ``complex float`` type in C (or ``COMPLEX*8`` in Fortran).\n\n``Complex128``\n    Exactly corresponds to the ``complex double`` type in C (or ``COMPLEX*16`` in Fortran).\n\n``Signed``\n    Exactly corresponds to the ``signed`` type annotation in C (or any ``INTEGER`` type in Fortran). Any Julia type that is not a subtype of ``Signed`` is assumed to be unsigned.\n\n``Ref{T}``\n    Behaves like a ``Ptr{T}`` that owns its memory.\n\n``Array{T,N}``\n    When an array is passed to C as a ``Ptr{T}`` argument, it is\n    not reinterpret-cast: Julia requires that the element type of the\n    array matches ``T``, and the address of the first element is passed.\n\n    Therefore, if an ``Array`` contains data in the wrong format, it will\n    have to be explicitly converted using a call such as ``trunc(Int32,a)``.\n\n    To pass an array ``A`` as a pointer of a different type *without*\n    converting the data beforehand (for example, to pass a ``Float64`` array\n    to a function that operates on uninterpreted bytes), you can\n    declare the argument as ``Ptr{Void}``.\n\n    If an array of eltype ``Ptr{T}`` is passed as a ``Ptr{Ptr{T}}`` argument, the Julia base library\n    ``cconvert`` function will attempt to first make a null-terminated copy of the array with\n    each element replaced by its ``cconvert`` version. This allows, for example, passing an ``argv``\n    pointer array of type ``Vector{ByteString}`` to an argument of type ``Ptr{Ptr{Cchar}}``.\n\nOn all systems we currently support, basic C/C++ value types may be\ntranslated to Julia types as follows. Every C type also has a corresponding\nJulia type with the same name, prefixed by C. This can help for writing portable code (and remembering that an ``int`` in C is not the same as an ``Int`` in Julia).\n\n**System Independent:**\n\n.. rst-class:: text-wrap\n\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| C name                            | Fortran name    | Standard Julia Alias | Julia Base Type                   |\n+===================================+=================+======================+===================================+\n| ``unsigned char``                 | ``CHARACTER``   | ``Cuchar``           | ``UInt8``                         |\n|                                   |                 |                      |                                   |\n| ``bool`` (C++)                    |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``short``                         | ``INTEGER*2``   | ``Cshort``           | ``Int16``                         |\n|                                   |                 |                      |                                   |\n|                                   | ``LOGICAL*2``   |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``unsigned short``                |                 | ``Cushort``          | ``UInt16``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``int``                           | ``INTEGER*4``   | ``Cint``             | ``Int32``                         |\n|                                   |                 |                      |                                   |\n| ``BOOL`` (C, typical)             | ``LOGICAL*4``   |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``unsigned int``                  |                 | ``Cuint``            | ``UInt32``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``long long``                     | ``INTEGER*8``   | ``Clonglong``        | ``Int64``                         |\n|                                   |                 |                      |                                   |\n|                                   | ``LOGICAL*8``   |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``unsigned long long``            |                 | ``Culonglong``       | ``UInt64``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``intmax_t``                      |                 | ``Cintmax_t``        | ``Int64``                         |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``uintmax_t``                     |                 | ``Cuintmax_t``       | ``UInt64``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``float``                         | ``REAL*4i``     | ``Cfloat``           | ``Float32``                       |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``double``                        | ``REAL*8``      | ``Cdouble``          | ``Float64``                       |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``complex float``                 | ``COMPLEX*8``   | ``Complex64``        | ``Complex{Float32}``              |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``complex double``                | ``COMPLEX*16``  | ``Complex128``       | ``Complex{Float64}``              |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``ptrdiff_t``                     |                 | ``Cptrdiff_t``       | ``Int``                           |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``ssize_t``                       |                 | ``Cssize_t``         | ``Int``                           |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``size_t``                        |                 | ``Csize_t``          | ``UInt``                          |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``void``                          |                 |                      | ``Void``                          |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``void*``                         |                 |                      | ``Ptr{Void}``                     |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``T*`` (where T represents an     |                 |                      | ``Ref{T}``                        |\n| appropriately defined type)       |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``char*``                         | ``CHARACTER*N`` |                      | ``Cstring`` if NUL-terminated, or |\n| (or ``char[]``, e.g. a string)    |                 |                      | ``Ptr{UInt8}`` if not             |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``char**`` (or ``*char[]``)       |                 |                      | ``Ptr{Ptr{UInt8}}``               |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``jl_value_t*``                   |                 |                      | ``Any``                           |\n| (any Julia Type)                  |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``jl_value_t**``                  |                 |                      | ``Ref{Any}``                      |\n| (a reference to a Julia Type)     |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``va_arg``                        |                 |                      | Not supported                     |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``...``                           |                 |                      | ``T...`` (where ``T``             |\n| (variadic function specification) |                 |                      | is one of the above types,        |\n|                                   |                 |                      | variadic functions of different   |\n|                                   |                 |                      | argument types are not supported) |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n\nThe ``Cstring`` type is essentially a synonym for ``Ptr{UInt8}``, except the conversion to ``Cstring`` throws an\nerror if the Julia string contains any embedded NUL characters (which would cause the string to be silently\ntruncated if the C routine treats NUL as the terminator).  If you are passing a ``char*`` to a C routine that\ndoes not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that\nyour Julia string does not contain NUL and want to skip the check, you can use ``Ptr{UInt8}`` as the argument type.\n\n**System-dependent:**\n\n======================  ======================  =======\nC name                  Standard Julia Alias    Julia Base Type\n======================  ======================  =======\n``char``                ``Cchar``               ``Int8`` (x86, x86_64)\n\n                                                ``UInt8`` (powerpc, arm)\n\n``long``                ``Clong``               ``Int`` (UNIX)\n\n                                                ``Int32`` (Windows)\n\n``unsigned long``       ``Culong``              ``UInt`` (UNIX)\n\n                                                ``UInt32`` (Windows)\n\n``wchar_t``             ``Cwchar_t``            ``Int32`` (UNIX)\n\n                                                ``UInt16`` (Windows)\n======================  ======================  =======\n\n.. note::\n\n    When calling a Fortran function, all inputs must be passed by reference, so\n    all type correspondences above should contain an additional ``Ptr{..}`` or\n    ``Ref{..}`` wrapper around their type specification.\n\n.. warning::\n\n    For string arguments (``char*``) the Julia type should be ``Cstring`` (if NUL-\n    terminated data is expected) or either ``Ptr{Cchar}`` or ``Ptr{UInt8}``\n    otherwise (these two pointer types have the same effect), as described above,\n    not ``ASCIIString``. Similarly, for array arguments (``T[]`` or ``T*``), the\n    Julia type should again be ``Ptr{T}``, not ``Vector{T}``.\n\n.. warning::\n\n    Julia's ``Char`` type is 32 bits, which is not the same as the wide character\n    type (``wchar_t`` or ``wint_t``) on all platforms.\n\n.. note::\n\n    For ``wchar_t*`` arguments, the Julia type should be ``Cwstring`` (if the C\n    routine expects a NUL-terminated string) or ``Ptr{Cwchar_t}`` otherwise, and\n    data can be converted to/from ordinary Julia strings by the ``wstring(s)``\n    function (equivalent to either ``utf16(s)`` or ``utf32(s)`` depending upon the\n    width of ``Cwchar_t``); this conversion will be called automatically for\n    ``Cwstring`` arguments.    Note also that ASCII, UTF-8, UTF-16, and UTF-32\n    string data in Julia is internally NUL-terminated, so it can be passed to C\n    functions expecting NUL-terminated data without making a copy (but using the\n    ``Cwstring`` type will cause an error to be thrown if the string itself\n    contains NUL characters).\n\n.. note::\n\n    C functions that take an argument of the type ``char**`` can be called by\n    using a ``Ptr{Ptr{UInt8}}`` type within Julia. For example, C functions of the\n    form::\n\n        int main(int argc, char **argv);\n\n    can be called via the following Julia code::\n\n        argv = [ \"a.out\", \"arg1\", \"arg2\" ]\n        ccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)\n\n.. note::\n\n    A C function declared to return ``Void`` will return the value ``nothing`` in\n    Julia.\n\nStruct Type correspondences\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nComposite types, aka ``struct`` in C or ``TYPE`` in Fortran90\n(or ``STRUCTURE`` / ``RECORD`` in some variants of F77),\ncan be mirrored in Julia by creating a ``type`` or ``immutable``\ndefinition with the same field layout.\n\nWhen used recursively, ``isbits`` types are stored inline.\nAll other types are stored as a pointer to the data.\nWhen mirroring a struct used by-value inside another struct in C,\nit is imperative that you do not attempt to manually copy the fields over,\nas this will not preserve the correct field alignment.\nInstead, declare an immutable isbits type and use that instead.\nUnnamed structs are not possible in the translation to Julia.\n\nPacked structs and union declarations are not supported by Julia.\n\nYou can get a near approximation of a ``union`` if you know, a priori,\nthe field that will have the greatest size (potentially including padding).\nWhen translating your fields to Julia, declare the Julia field to be only\nof that type.\n\nArrays of parameters must be expanded manually, currently\n(either inline, or in an immutable helper-type). For example::\n\n    in C:\n    struct B {\n        int A[3];\n    };\n    b_a_2 = B.A[2];\n\n    in Julia:\n    immutable B_A\n        A_1::Cint\n        A_2::Cint\n        A_3::Cint\n    end\n    type B\n        A::B_A\n    end\n    b_a_2 = B.A.(2)\n\nArrays of unknown size are not supported.\n\nIn the future, some of these restrictions may be reduced or eliminated.\n\nMemory Ownership:\n~~~~~~~~~~~~~~~~~\n\n**malloc/free**\n\nMemory allocation and deallocation of such objects must be\nhandled by calls to the appropriate cleanup routines in the libraries\nbeing used, just like in any C program. Do not try to free an object\nreceived from a C library with ``Libc.free`` in Julia, as this may result\nin the ``free`` function being called via the wrong ``libc`` library and\ncause Julia to crash. The reverse (passing an object allocated in Julia\nto be freed by an external library) is equally invalid.\n\n**Ptr{T} vs. Array{T} vs. Ref{T} vs. T**\n\nThe choice of type-wrapper declaration strongly depends on who allocated the memory,\nand the declared type.\nIn general, use ``T`` if the memory is intended to be allocated in\n(and managed by) Julia (with type-tag).\nUse ``Ptr{T}`` if the memory is expected to be populated by ``C`` (without type-tag).\nUse ``Ref{T}`` if you have an ``isbits`` type,\nbut you want to turn it into a pointer to a struct in another struct definition.\n\nSee issue #2818 for some work that needs to be done to simplify this so that Julia\ntypes can be used to recursively mirror c-style structs,\nwithout requiring as much manual management of the ``Ptr`` conversions.\nAfter #2818 is implemented, it will be true that an ``Vector{T}`` will be equivalent to\nan ``Ptr{Ptr{T}}``. That is currently not true, and the conversion must be explicitly.\n\nMapping C Functions to Julia\n----------------------------\n\nccall/cfunction argument translation guide\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor translating a ``c`` argument list to ``Julia``:\n\n* ``T``, where ``T`` is one of the primitive types:\n  ``char``, ``int``, ``long``, ``short``, ``float``, ``double``, ``complex``, ``enum``\n  or any of their ``typedef`` equivalents\n\n  + ``T``, where ``T`` is an equivalent Julia Bits Type (per the table above)\n  + if ``T`` is an ``enum``, the argument type should be equivalent to ``Cint`` or ``Cuint``\n  + argument value will be copied (passed by-value)\n\n* ``struct T`` (including typedef to a struct)\n\n  + ``T``, where ``T`` is a Julia Leaf Type\n  + argument value will be copied (passed by-value)\n\n* ``void*``\n\n  + depends on how this parameter is used, first translate this to the intended pointer type,\n    then determine the Julia equivalent using the remaining rules in this list\n  + this argument may be declared as ``Ptr{Void}``, if it really is just an unknown pointer\n\n* ``jl_value_t*``\n\n  + ``Any``\n  + argument value must be a valid Julia object\n  + currently unsupported by cfunction\n\n* ``jl_value_t**``\n\n  + ``Ref{Any}``\n  + argument value must be a valid Julia object (or ``C_NULL``)\n  + currently unsupported by cfunction\n\n* ``T*``\n\n  + ``Ref{T}``, where ``T`` is the Julia type corresponding to ``T``\n  + argument value will be copied if it is an ``isbits`` type\n    otherwise, the value must be a valid Julia object\n\n* ``(T*)(...)`` (e.g. a pointer to a function)\n\n  + ``Ptr{Void}`` (you may need to use ``cfunction`` explicitly to create this pointer)\n\n* ``...`` (e.g. a vararg)\n\n  + ``T...``, where ``T`` is the Julia type\n\n* ``va_arg``\n\n  + not supported\n\nccall/cfunction return type translation guide\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor translating a ``c`` return type to ``Julia``:\n\n* ``void``\n\n  + ``Void`` (this will return the singleton instance ``nothing::Void``)\n\n* ``T``, where ``T`` is one of the primitive types:\n  ``char``, ``int``, ``long``, ``short``, ``float``, ``double``, ``complex``, ``enum``\n  or any of their ``typedef`` equivalents\n\n  + ``T``, where ``T`` is an equivalent Julia Bits Type (per the table above)\n  + if ``T`` is an ``enum``, the argument type should be equivalent to ``Cint`` or ``Cuint``\n  + argument value will be copied (returned by-value)\n\n* ``struct T`` (including typedef to a struct)\n\n  + ``T``, where ``T`` is a Julia Leaf Type\n  + argument value will be copied (returned by-value)\n\n* ``void*``\n\n  + depends on how this parameter is used, first translate this to the intended pointer type,\n    then determine the Julia equivalent using the remaining rules in this list\n  + this argument may be declared as ``Ptr{Void}``, if it really is just an unknown pointer\n\n* ``jl_value_t*``\n\n  + ``Any``\n  + argument value must be a valid Julia object\n\n* ``jl_value_t**``\n\n  + ``Ref{Any}``\n  + argument value must be a valid Julia object (or ``C_NULL``)\n\n* ``T*``\n\n  + If the memory is already owned by Julia, or is an ``isbits`` type, and is known to be non-null:\n\n    + ``Ref{T}``, where ``T`` is the Julia type corresponding to ``T``\n    + a return type of ``Ref{Any}`` is invalid, it should either be ``Any``\n      (corresponding to ``jl_value_t*``) or ``Ptr{Any}`` (corresponding to ``Ptr{Any}``)\n    + currently partially unsupported by cfunction due to #2818\n    + C **MUST NOT** modify the memory returned via ``Ref{T}`` if ``T`` is an ``isbits`` type\n\n  + If the memory is owned by C:\n\n    + ``Ptr{T}``, where ``T`` is the Julia type corresponding to ``T``\n\n* ``(T*)(...)`` (e.g. a pointer to a function)\n\n  + ``Ptr{Void}`` (you may need to use ``cfunction`` explicitly to create this pointer)\n\nPassing Pointers for Modifying Inputs\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBecause C doesn't support multiple return values,\noften C functions will take pointers to data that the function will modify.\nTo accomplish this within a ``ccall``,\nyou need to first encapsulate the value inside an ``Ref{T}`` of the appropriate type.\nWhen you pass this ``Ref`` object as an argument,\njulia will automatically pass a C pointer to the encapsulated data::\n\n    width = Ref{Cint}(0)\n    range = Ref{Cfloat}(0)\n    ccall(:foo, Void, (Ref{Cint}, Ref{Cfloat}), width, range)\n\nUpon return, the contents of ``width`` and ``range`` can be retrieved\n(if they were changed by ``foo``) by ``width[]`` and ``range[]``; that is,\nthey act like zero-dimensional arrays.\n\nSpecial Reference Syntax for ccall (deprecated):\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``&`` syntax is deprecated, use the ``Ref{T}`` argument type instead.\n\nA prefix ``&`` is used on an argument to ccall to indicate that a pointer\nto a scalar argument should be passed instead of the scalar value itself\n(required for all Fortran function arguments, as noted above). The following\nexample computes a dot product using a BLAS function.\n\n::\n\n    function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})\n      assert(length(DX) == length(DY))\n      n = length(DX)\n      incx = incy = 1\n      product = ccall((:ddot_, \"libLAPACK\"),\n                      Float64,\n                      (Ptr{Int32}, Ptr{Float64}, Ptr{Int32}, Ptr{Float64}, Ptr{Int32}),\n                      &n, DX, &incx, DY, &incy)\n      return product\n    end\n\nThe meaning of prefix ``&`` is not quite the same as in C. In\nparticular, any changes to the referenced variables will not be\nvisible in Julia unless the type is mutable (declared via\n``type``). However, even for immutable types it will not cause any\nharm for called functions to attempt such modifications (that is,\nwriting through the passed pointers). Moreover, ``&`` may be used with\nany expression, such as ``&0`` or ``&f(x)``.\n\nWhen a scalar value is passed with ``&`` as an argument of type\n``Ptr{T}``, the value will first be converted to type ``T``.\n\n\nGarbage Collection Safety\n-------------------------\nWhen passing data to a ccall, it is best to avoid using the ``pointer()``\nfunction. Instead define a convert method and pass the variables directly to\nthe ccall. ccall automatically arranges that all of its arguments will be\npreserved from garbage collection until the call returns. If a C API will\nstore a reference to memory allocated by Julia, after the ccall returns, you\nmust arrange that the object remains visible to the garbage collector. The\nsuggested way to handle this is to make a global variable of type\n``Array{Ref,1}`` to hold these values, until the C library notifies you that\nit is finished with them.\n\nWhenever you have created a pointer to Julia data, you must ensure the original data\nexists until you are done with using the pointer. Many methods in Julia such as\n``unsafe_load()`` and ``bytestring()`` make copies of data instead of taking ownership\nof the buffer, so that it is safe to free (or alter) the original data without\naffecting Julia. A notable exception is ``pointer_to_array()`` which, for performance\nreasons, shares (or can be told to take ownership of) the underlying buffer.\n\nThe garbage collector does not guarantee any order of finalization. That is, if ``a``\ncontained a reference to ``b`` and both ``a`` and ``b`` are due for garbage\ncollection, there is no guarantee that ``b`` would be finalized after ``a``. If\nproper finalization of ``a`` depends on ``b`` being valid, it must be handled in\nother ways.\n\n\nNon-constant Function Specifications\n------------------------------------\n\nA ``(name, library)`` function specification must be a constant expression.\nHowever, it is possible to use computed values as function names by staging\nthrough ``eval`` as follows::\n\n    @eval ccall(($(string(\"a\",\"b\")),\"lib\"), ...\n\nThis expression constructs a name using ``string``, then substitutes this\nname into a new ``ccall`` expression, which is then evaluated. Keep in mind that\n``eval`` only operates at the top level, so within this expression local\nvariables will not be available (unless their values are substituted with\n``$``). For this reason, ``eval`` is typically only used to form top-level\ndefinitions, for example when wrapping libraries that contain many\nsimilar functions.\n\nIf your usage is more dynamic, use indirect calls as described in the next section.\n\n\nIndirect Calls\n--------------\n\nThe first argument to ``ccall`` can also be an expression evaluated at run time.\nIn this case, the expression must evaluate to a ``Ptr``,\nwhich will be used as the address of the native function to call.\nThis behavior occurs when the first ``ccall`` argument contains references to non-constants,\nsuch as local variables, function arguments, or non-constant globals.\n\nFor example, you might lookup the function via ``dlsym``,\nthen cache it in a global variable for that session. For example::\n\n    macro dlsym(func, lib)\n        z, zlocal = gensym(string(func)), gensym()\n        eval(current_module(),:(global $z = C_NULL))\n        z = esc(z)\n        quote\n            let $zlocal::Ptr{Void} = $z::Ptr{Void}\n                if $zlocal == C_NULL\n                   $zlocal = dlsym($(esc(lib))::Ptr{Void}, $(esc(func)))\n                   global $z = $zlocal\n                end\n                $zlocal\n            end\n        end\n    end\n\n    mylibvar = dlopen(\"mylib\")\n    ccall(@dlsym(\"myfunc\", mylibvar), Void, ())\n\n\nCalling Convention\n------------------\n\nThe second argument to ``ccall`` can optionally be a calling convention\nspecifier (immediately preceding return type). Without any specifier,\nthe platform-default C calling convention is used. Other supported\nconventions are: ``stdcall``, ``cdecl``, ``fastcall``, and ``thiscall``.\nFor example (from base/libc.jl) we see the same ``gethostname`` ccall as above,\nbut with the correct signature for Windows::\n\n    hn = Array(UInt8, 256)\n    err = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))\n\nFor more information, please see the `LLVM Language Reference`_.\n\n.. _LLVM Language Reference: http://llvm.org/docs/LangRef.html#calling-conventions\n\n\nAccessing Global Variables\n--------------------------\n\nGlobal variables exported by native libraries can be accessed by name using the\n``cglobal`` function. The arguments to ``cglobal`` are a symbol specification\nidentical to that used by ``ccall``, and a type describing the value stored in\nthe variable::\n\n    julia> cglobal((:errno,:libc), Int32)\n    Ptr{Int32} @0x00007f418d0816b8\n\nThe result is a pointer giving the address of the value. The value can be\nmanipulated through this pointer using ``unsafe_load`` and ``unsafe_store``.\n\n\nAccessing Data through a Pointer\n--------------------------------\nThe following methods are described as \"unsafe\" because a bad pointer\nor type declaration can cause Julia to terminate abruptly\n(although, that's quite alike with ccall).\n\nGiven a ``Ptr{T}``, the contents of type ``T`` can generally be copied from\nthe referenced memory into a Julia object using ``unsafe_load(ptr, [index])``.\nThe index argument is optional (default is 1),\nand follows the Julia-convention of 1-based indexing.\nThis function is intentionally similar to the behavior of ``getindex()`` and ``setindex!()``\n(e.g. ``[]`` access syntax).\n\nThe return value will be a new object initialized\nto contain a copy of the contents of the referenced memory.\nThe referenced memory can safely be freed or released.\n\nIf ``T`` is ``Any``, then the memory is assumed to contain a reference to\na Julia object (a ``jl_value_t*``), the result will be a reference to this object,\nand the object will not be copied. You must be careful in this case to ensure\nthat the object was always visible to the garbage collector (pointers do not\ncount, but the new reference does) to ensure the memory is not prematurely freed.\nNote that if the object was not originally allocated by Julia, the new object\nwill never be finalized by Julia's garbage collector.  If the ``Ptr`` itself\nis actually a ``jl_value_t*``, it can be converted back to a Julia object\nreference by ``unsafe_pointer_to_objref(ptr)``.  (Julia values ``v``\ncan be converted to ``jl_value_t*`` pointers, as ``Ptr{Void}``, by calling\n``pointer_from_objref(v)``.)\n\nThe reverse operation (writing data to a Ptr{T}), can be performed using\n``unsafe_store!(ptr, value, [index])``.  Currently, this is only supported\nfor bitstypes or other pointer-free (``isbits``) immutable types.\n\nAny operation that throws an error is probably currently unimplemented\nand should be posted as a bug so that it can be resolved.\n\nIf the pointer of interest is a plain-data array (bitstype or immutable), the\nfunction ``pointer_to_array(ptr,dims,[own])`` may be more useful. The final\nparameter should be true if Julia should \"take ownership\" of the underlying\nbuffer and call ``free(ptr)`` when the returned ``Array`` object is finalized.\nIf the ``own`` parameter is omitted or false, the caller must ensure the\nbuffer remains in existence until all access is complete.\n\nArithmetic on the ``Ptr`` type in Julia (e.g. using ``+``) does not behave the\nsame as C's pointer arithmetic. Adding an integer to a ``Ptr`` in Julia always\nmoves the pointer by some number of *bytes*, not elements. This way, the\naddress values obtained from pointer arithmetic do not depend on the\nelement types of pointers.\n\n\nThread-safety\n-------------\n\nSome C libraries execute their callbacks from a different thread, and\nsince Julia isn't thread-safe you'll need to take some extra\nprecautions. In particular, you'll need to set up a two-layered\nsystem: the C callback should only *schedule* (via Julia's event loop)\nthe execution of your \"real\" callback. To do this, you pass a function\nof one argument (the ``AsyncWork`` object for which the event was\ntriggered, which you'll probably just ignore) to ``SingleAsyncWork``::\n\n  cb = Base.SingleAsyncWork(data -> my_real_callback(args))\n\nThe callback you pass to C should only execute a ``ccall`` to\n``:uv_async_send``, passing ``cb.handle`` as the argument.\n\nMore About Callbacks\n--------------------\n\nFor more details on how to pass callbacks to C libraries, see this\n`blog post <http://julialang.org/blog/2013/05/callback>`_.\n\nC++\n---\n\nLimited support for C++ is provided by the `Cpp <https://github.com/timholy/Cpp.jl>`_,\n`Clang <https://github.com/ihnorton/Clang.jl>`_, and `Cxx <https://github.com/Keno/Cxx.jl>`_ packages.\n\nHandling Operating System Variation\n-----------------------------------\n\nWhen dealing with platform libraries, it is often necessary to provide special cases\nfor various platforms. The variable ``OS_NAME`` can be used to write these special\ncases. Additionally, there are several macros intended to make this easier:\n``@windows``, ``@unix``, ``@linux``, and ``@osx``. Note that linux and osx are mutually\nexclusive subsets of unix. Their usage takes the form of a ternary conditional\noperator, as demonstrated in the following examples.\n\nSimple blocks::\n\n    ccall( (@windows? :_fopen : :fopen), ...)\n\nComplex blocks::\n\n    @linux? (\n             begin\n                 some_complicated_thing(a)\n             end\n           : begin\n                 some_different_thing(a)\n             end\n           )\n\nChaining (parentheses optional, but recommended for readability)::\n\n    @windows? :a : (@osx? :b : :c)\n\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/stdlib/libdl.rst": ".. module:: Libdl\n\n****************\n Dynamic Linker\n****************\n\n.. function:: dlopen(libfile::AbstractString [, flags::Integer])\n\n   .. Docstring generated from Julia source\n\n   Load a shared library, returning an opaque handle.\n\n   The optional flags argument is a bitwise-or of zero or more of ``RTLD_LOCAL``\\ , ``RTLD_GLOBAL``\\ , ``RTLD_LAZY``\\ , ``RTLD_NOW``\\ , ``RTLD_NODELETE``\\ , ``RTLD_NOLOAD``\\ , ``RTLD_DEEPBIND``\\ , and ``RTLD_FIRST``\\ . These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default ``dlopen`` flags are ``RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL`` while on other platforms the defaults are ``RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL``\\ . An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance ``RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL`` allows the library's symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.\n\n.. function:: dlopen_e(libfile::AbstractString [, flags::Integer])\n\n   .. Docstring generated from Julia source\n\n   Similar to :func:`dlopen`, except returns a ``NULL`` pointer instead of raising errors.\n\n.. data:: RTLD_DEEPBIND\n\n   Enum constant for :func:`dlopen`. See your platform man page for details, if applicable.\n\n.. data:: RTLD_FIRST\n\n   Enum constant for :func:`dlopen`. See your platform man page for details, if applicable.\n\n.. data:: RTLD_GLOBAL\n\n   Enum constant for :func:`dlopen`. See your platform man page for details, if applicable.\n\n.. data:: RTLD_LAZY\n\n   Enum constant for :func:`dlopen`. See your platform man page for details, if applicable.\n\n.. data:: RTLD_LOCAL\n\n   Enum constant for :func:`dlopen`. See your platform man page for details, if applicable.\n\n.. data:: RTLD_NODELETE\n\n   Enum constant for :func:`dlopen`. See your platform man page for details, if applicable.\n\n.. data:: RTLD_NOLOAD\n\n   Enum constant for :func:`dlopen`. See your platform man page for details, if applicable.\n\n.. data:: RTLD_NOW\n\n   Enum constant for :func:`dlopen`. See your platform man page for details, if applicable.\n\n.. function:: dlsym(handle, sym)\n\n   .. Docstring generated from Julia source\n\n   Look up a symbol from a shared library handle, return callable function pointer on success.\n\n.. function:: dlsym_e(handle, sym)\n\n   .. Docstring generated from Julia source\n\n   Look up a symbol from a shared library handle, silently return ``NULL`` pointer on lookup failure.\n\n.. function:: dlclose(handle)\n\n   .. Docstring generated from Julia source\n\n   Close shared library referenced by handle.\n\n.. data:: dlext\n\n   File extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.\n\n.. function:: find_library(names, locations)\n\n   .. Docstring generated from Julia source\n\n   Searches for the first library in ``names`` in the paths in the ``locations`` list, ``DL_LOAD_PATH``\\ , or system library paths (in that order) which can successfully be dlopen'd. On success, the return value will be one of the names (potentially prefixed by one of the paths in locations). This string can be assigned to a ``global const`` and used as the library name in future ``ccall``\\ 's. On failure, it returns the empty string.\n\n.. data:: DL_LOAD_PATH\n\n   When calling ``dlopen``, the paths in this list will be searched first, in order, before searching the\n   system locations for a valid library handle.\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/stdlib/c.rst": ".. currentmodule:: Base\n\n*************\n C Interface\n*************\n\n.. function:: ccall((symbol, library) or function_pointer, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n\n   .. Docstring generated from Julia source\n\n   Call function in C-exported shared library, specified by ``(function name, library)`` tuple, where each component is a string or symbol.\n\n   Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression. Alternatively, ``ccall`` may also be used to call a function pointer, such as one returned by ``dlsym``\\ .\n\n   Each ``ArgumentValue`` to the ``ccall`` will be converted to the corresponding ``ArgumentType``\\ , by automatic insertion of calls to ``unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))``\\ . (See also the documentation for each of these functions for further details.) In most cases, this simply results in a call to ``convert(ArgumentType, ArgumentValue)``\\ .\n\n.. function:: cglobal((symbol, library) [, type=Void])\n\n   .. Docstring generated from Julia source\n\n   Obtain a pointer to a global variable in a C-exported shared library, specified exactly as in ``ccall``\\ . Returns a ``Ptr{Type}``\\ , defaulting to ``Ptr{Void}`` if no Type argument is supplied. The values can be read or written by ``unsafe_load`` or ``unsafe_store!``\\ , respectively.\n\n.. function:: cfunction(function::Function, ReturnType::Type, (ArgumentTypes...))\n\n   .. Docstring generated from Julia source\n\n   Generate C-callable function pointer from Julia function. Type annotation of the return value in the callback function is a must for situations where Julia cannot infer the return type automatically.\n\n   For example:\n\n   .. code-block:: julia\n\n       function foo()\n           # body\n\n           retval::Float64\n       end\n\n       bar = cfunction(foo, Float64, ())\n\n.. function:: unsafe_convert(T,x)\n\n   .. Docstring generated from Julia source\n\n   Convert ``x`` to a value of type ``T``\n\n   In cases where ``convert`` would need to take a Julia object and turn it into a ``Ptr``\\ , this function should be used to define and perform that conversion.\n\n   Be careful to ensure that a julia reference to ``x`` exists as long as the result of this function will be used. Accordingly, the argument ``x`` to this function should never be an expression, only a variable name or field reference. For example, ``x=a.b.c`` is acceptable, but ``x=[a,b,c]`` is not.\n\n   The ``unsafe`` prefix on this function indicates that using the result of this function after the ``x`` argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.\n\n.. function:: cconvert(T,x)\n\n   .. Docstring generated from Julia source\n\n   Convert ``x`` to a value of type ``T``\\ , typically by calling ``convert(T,x)``\n\n   In cases where ``x`` cannot be safely converted to ``T``\\ , unlike ``convert``\\ , ``cconvert`` may return an object of a type different from ``T``\\ , which however is suitable for ``unsafe_convert`` to handle.\n\n   Neither ``convert`` nor ``cconvert`` should take a Julia object and turn it into a ``Ptr``\\ .\n\n.. function:: unsafe_load(p::Ptr{T},i::Integer)\n\n   .. Docstring generated from Julia source\n\n   Load a value of type ``T`` from the address of the ith element (1-indexed) starting at ``p``\\ . This is equivalent to the C expression ``p[i-1]``\\ .\n\n   The ``unsafe`` prefix on this function indicates that no validation is performed on the pointer ``p`` to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.\n\n.. function:: unsafe_store!(p::Ptr{T},x,i::Integer)\n\n   .. Docstring generated from Julia source\n\n   Store a value of type ``T`` to the address of the ith element (1-indexed) starting at ``p``\\ . This is equivalent to the C expression ``p[i-1] = x``\\ .\n\n   The ``unsafe`` prefix on this function indicates that no validation is performed on the pointer ``p`` to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n.. function:: unsafe_copy!(dest::Ptr{T}, src::Ptr{T}, N)\n\n   .. Docstring generated from Julia source\n\n   Copy ``N`` elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.\n\n   The ``unsafe`` prefix on this function indicates that no validation is performed on the pointers ``dest`` and ``src`` to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n.. function:: unsafe_copy!(dest::Array, do, src::Array, so, N)\n\n   .. Docstring generated from Julia source\n\n   Copy ``N`` elements from a source array to a destination, starting at offset ``so`` in the source and ``do`` in the destination (1-indexed).\n\n   The ``unsafe`` prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n.. function:: copy!(dest, src)\n\n   .. Docstring generated from Julia source\n\n   Copy all elements from collection ``src`` to array ``dest``\\ . Returns ``dest``\\ .\n\n.. function:: copy!(dest, do, src, so, N)\n\n   .. Docstring generated from Julia source\n\n   Copy ``N`` elements from collection ``src`` starting at offset ``so``\\ , to array ``dest`` starting at offset ``do``\\ . Returns ``dest``\\ .\n\n.. function:: pointer(array [, index])\n\n   .. Docstring generated from Julia source\n\n   Get the native address of an array or string element. Be careful to ensure that a julia reference to ``a`` exists as long as this pointer will be used. This function is \"unsafe\" like ``unsafe_convert``\\ .\n\n   Calling ``Ref(array[, index])`` is generally preferable to this function.\n\n.. function:: pointer_to_array(pointer, dims[, take_ownership::Bool])\n\n   .. Docstring generated from Julia source\n\n   Wrap a native pointer as a Julia Array object. The pointer element type determines the array element type. ``own`` optionally specifies whether Julia should take ownership of the memory, calling ``free`` on the pointer when the array is no longer referenced.\n\n.. function:: pointer_from_objref(object_instance)\n\n   .. Docstring generated from Julia source\n\n   Get the memory address of a Julia object as a ``Ptr``\\ . The existence of the resulting ``Ptr`` will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the ``Ptr`` will be used.\n\n.. function:: unsafe_pointer_to_objref(p::Ptr)\n\n   .. Docstring generated from Julia source\n\n   Convert a ``Ptr`` to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered \"unsafe\" and should be used with care.\n\n.. function:: disable_sigint(f::Function)\n\n   .. Docstring generated from Julia source\n\n   Disable Ctrl-C handler during execution of a function, for calling external code that is not interrupt safe. Intended to be called using ``do`` block syntax as follows:\n\n   .. code-block:: julia\n\n       disable_sigint() do\n           # interrupt-unsafe code\n           ...\n       end\n\n.. function:: reenable_sigint(f::Function)\n\n   .. Docstring generated from Julia source\n\n   Re-enable Ctrl-C handler during execution of a function. Temporarily reverses the effect of ``disable_sigint``\\ .\n\n.. function:: systemerror(sysfunc, iftrue)\n\n   .. Docstring generated from Julia source\n\n   Raises a ``SystemError`` for ``errno`` with the descriptive string ``sysfunc`` if ``iftrue`` is ``true``\n\n.. data:: Ptr{T}\n\n   A memory address referring to data of type ``T``.\n   However, there is no guarantee that the memory is actually valid,\n   or that it actually represents data of the specified type.\n\n.. data:: Ref{T}\n\n   An object that safely references data of type ``T``.\n   This type is guaranteed to point to valid, Julia-allocated memory\n   of the correct type. The underlying data is protected from freeing by\n   the garbage collector as long as the ``Ref`` itself is referenced.\n\n   When passed as a ``ccall`` argument (either as a ``Ptr`` or ``Ref`` type),\n   a ``Ref`` object will be converted to a native pointer to the data it references.\n\n   There is no invalid (NULL) ``Ref``.\n\n.. data:: Cchar\n\n   Equivalent to the native ``char`` c-type\n\n.. data:: Cuchar\n\n   Equivalent to the native ``unsigned char`` c-type (UInt8)\n\n.. data:: Cshort\n\n   Equivalent to the native ``signed short`` c-type (Int16)\n\n.. data:: Cushort\n\n   Equivalent to the native ``unsigned short`` c-type (UInt16)\n\n.. data:: Cint\n\n   Equivalent to the native ``signed int`` c-type (Int32)\n\n.. data:: Cuint\n\n   Equivalent to the native ``unsigned int`` c-type (UInt32)\n\n.. data:: Clong\n\n   Equivalent to the native ``signed long`` c-type\n\n.. data:: Culong\n\n   Equivalent to the native ``unsigned long`` c-type\n\n.. data:: Clonglong\n\n   Equivalent to the native ``signed long long`` c-type (Int64)\n\n.. data:: Culonglong\n\n   Equivalent to the native ``unsigned long long`` c-type (UInt64)\n\n.. data:: Cintmax_t\n\n   Equivalent to the native ``intmax_t`` c-type (Int64)\n\n.. data:: Cuintmax_t\n\n   Equivalent to the native ``uintmax_t`` c-type (UInt64)\n\n.. data:: Csize_t\n\n   Equivalent to the native ``size_t`` c-type (UInt)\n\n.. data:: Cssize_t\n\n   Equivalent to the native ``ssize_t`` c-type\n\n.. data:: Cptrdiff_t\n\n   Equivalent to the native ``ptrdiff_t`` c-type (Int)\n\n.. data:: Coff_t\n\n   Equivalent to the native ``off_t`` c-type\n\n.. data:: Cwchar_t\n\n   Equivalent to the native ``wchar_t`` c-type (Int32)\n\n.. data:: Cfloat\n\n   Equivalent to the native ``float`` c-type (Float32)\n\n.. data:: Cdouble\n\n   Equivalent to the native ``double`` c-type (Float64)\n\n****************\n LLVM Interface\n****************\n\n.. function:: llvmcall(IR::String, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n\n   .. Docstring generated from Julia source\n\n   Call LLVM IR string in the first argument. Similar to an LLVM function ``define`` block, arguments are available as consecutive unnamed SSA variables (%0, %1, etc.).\n\n   Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.\n\n   Each ``ArgumentValue`` to ``llvmcall`` will be converted to the corresponding ``ArgumentType``\\ , by automatic insertion of calls to ``unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))``\\ . (see also the documentation for each of these functions for further details). In most cases, this simply results in a call to ``convert(ArgumentType, ArgumentValue)``\\ .\n\n   See ``test/llvmcall.jl`` for usage examples.\n\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/manual/calling-c-and-fortran-code.rst": ".. _man-calling-c-and-fortran-code:\n\n****************************\n Calling C and Fortran Code\n****************************\n\nThough most code can be written in Julia, there are many high-quality,\nmature libraries for numerical computing already written in C and\nFortran. To allow easy use of this existing code, Julia makes it simple\nand efficient to call C and Fortran functions. Julia has a \"no\nboilerplate\" philosophy: functions can be called directly from Julia\nwithout any \"glue\" code, code generation, or compilation \u2014 even from the\ninteractive prompt. This is accomplished just by making an appropriate call\nwith ``ccall`` syntax, which looks like an ordinary function call.\n\nThe code to be called must be available as a shared library. Most C and\nFortran libraries ship compiled as shared libraries already, but if you\nare compiling the code yourself using GCC (or Clang), you will need to\nuse the ``-shared`` and ``-fPIC`` options. The machine instructions\ngenerated by Julia's JIT are the same as a native C call would be, so\nthe resulting overhead is the same as calling a library function from C\ncode. (Non-library function calls in both C and Julia can be inlined and\nthus may have even less overhead than calls to shared library functions.\nWhen both libraries and executables are generated by LLVM, it is\npossible to perform whole-program optimizations that can even optimize\nacross this boundary, but Julia does not yet support that. In the\nfuture, however, it may do so, yielding even greater performance gains.)\n\nShared libraries and functions are referenced by a tuple of the\nform ``(:function, \"library\")`` or ``(\"function\", \"library\")`` where ``function``\nis the C-exported function name. ``library`` refers to the shared library\nname: shared libraries available in the (platform-specific) load path\nwill be resolved by name, and if necessary a direct path may be specified.\n\nA function name may be used alone in place of the tuple (just\n``:function`` or ``\"function\"``). In this case the name is resolved within\nthe current process. This form can be used to call C library functions,\nfunctions in the Julia runtime, or functions in an application linked to\nJulia.\n\nBy default, Fortran compilers `generate mangled names\n<https://en.wikipedia.org/wiki/Name_mangling#Fortran>`_\n(for example, converting function names to lowercase or uppercase,\noften appending an underscore), and so to call a Fortran function via\n``ccall`` you must pass the mangled identifier corresponding to the rule\nfollowed by your Fortran compiler.  Also, when calling a Fortran\nfunction, all inputs must be passed by reference.\n\nFinally, you can use ``ccall`` to actually generate a call to the\nlibrary function. Arguments to ``ccall`` are as follows:\n\n1. (:function, \"library\") pair (must be a constant, but see below).\n\n2. Return type (see below for mapping the declared C type to Julia)\n\n   - This argument will be evaluated at compile-time.\n\n3. A tuple of input types. The input types must be written as a literal tuple,\n   not a tuple-valued variable or expression.\n\n   - This argument will be evaluated at compile-time.\n\n4. The following arguments, if any, are the actual argument values\n   passed to the function.\n\nAs a complete but simple example, the following calls the ``clock``\nfunction from the standard C library::\n\n    julia> t = ccall( (:clock, \"libc\"), Int32, ())\n    2292761\n\n    julia> t\n    2292761\n\n    julia> typeof(ans)\n    Int32\n\n``clock`` takes no arguments and returns an ``Int32``. One common gotcha\nis that a 1-tuple must be written with a trailing comma. For\nexample, to call the ``getenv`` function to get a pointer to the value\nof an environment variable, one makes a call like this::\n\n    julia> path = ccall((:getenv, \"libc\"), Ptr{UInt8}, (Ptr{UInt8},), \"SHELL\")\n    Ptr{UInt8} @0x00007fff5fbffc45\n\n    julia> bytestring(path)\n    \"/bin/bash\"\n\nNote that the argument type tuple must be written as ``(Ptr{UInt8},)``,\nrather than ``(Ptr{UInt8})``. This is because ``(Ptr{UInt8})`` is just\nthe expression ``Ptr{UInt8}`` surrounded by parentheses, rather than\na 1-tuple containing ``Ptr{UInt8}``::\n\n    julia> (Ptr{UInt8})\n    Ptr{UInt8}\n\n    julia> (Ptr{UInt8},)\n    (Ptr{UInt8},)\n\nIn practice, especially when providing reusable functionality, one\ngenerally wraps ``ccall`` uses in Julia functions that set up arguments\nand then check for errors in whatever manner the C or Fortran function\nindicates them, propagating to the Julia caller as exceptions. This is\nespecially important since C and Fortran APIs are notoriously\ninconsistent about how they indicate error conditions. For example, the\n``getenv`` C library function is wrapped in the following Julia function\nin\n`env.jl <https://github.com/JuliaLang/julia/blob/master/base/env.jl>`_::\n\n    function getenv(var::AbstractString)\n      val = ccall((:getenv, \"libc\"),\n                  Ptr{UInt8}, (Ptr{UInt8},), var)\n      if val == C_NULL\n        error(\"getenv: undefined variable: \", var)\n      end\n      bytestring(val)\n    end\n\nThe C ``getenv`` function indicates an error by returning ``NULL``, but\nother standard C functions indicate errors in various different ways,\nincluding by returning -1, 0, 1 and other special values. This wrapper\nthrows an exception clearly indicating the problem if the caller tries\nto get a non-existent environment variable::\n\n    julia> getenv(\"SHELL\")\n    \"/bin/bash\"\n\n    julia> getenv(\"FOOBAR\")\n    getenv: undefined variable: FOOBAR\n\nHere is a slightly more complex example that discovers the local\nmachine's hostname::\n\n    function gethostname()\n      hostname = Array(UInt8, 128)\n      ccall((:gethostname, \"libc\"), Int32,\n            (Ptr{UInt8}, Csize_t),\n            hostname, sizeof(hostname))\n      hostname[end] = 0; # ensure null-termination\n      return bytestring(pointer(hostname))\n    end\n\nThis example first allocates an array of bytes, then calls the C library\nfunction ``gethostname`` to fill the array in with the hostname, takes a\npointer to the hostname buffer, and converts the pointer to a Julia\nstring, assuming that it is a NUL-terminated C string. It is common for\nC libraries to use this pattern of requiring the caller to allocate\nmemory to be passed to the callee and filled in. Allocation of memory\nfrom Julia like this is generally accomplished by creating an\nuninitialized array and passing a pointer to its data to the C function.\n\nCreating C-Compatible Julia Function Pointers\n---------------------------------------------\n\nIt is possible to pass Julia functions to native c-functions that accept\nfunction pointer arguments. For example, to match c-prototypes of the form::\n\n    typedef returntype (*functiontype)(argumenttype,...)\n\nThe function ``cfunction`` generates the c-compatible function pointer for\na call to a Julia library function.\nArguments to ``cfunction`` are as follows:\n\n1. A Julia Function\n\n2. Return type\n\n3. A tuple of input types\n\nA classic example is the standard C library ``qsort`` function,\ndeclared as::\n\n    void qsort(void *base, size_t nmemb, size_t size,\n               int(*compare)(const void *a, const void *b));\n\nThe ``base`` argument is a pointer to an array of length ``nmemb``, with elements of\n``size`` bytes each. ``compare`` is a callback function which takes pointers to two\nelements ``a`` and ``b`` and returns an integer less/greater than zero if ``a`` should\nappear before/after ``b`` (or zero if any order is permitted). Now, suppose that we\nhave a 1d array ``A`` of values in Julia that we want to sort using the ``qsort``\nfunction (rather than Julia's built-in ``sort`` function). Before we worry about calling\n``qsort`` and passing arguments, we need to write a comparison function that works for\nsome arbitrary type T::\n\n    function mycompare{T}(a::T, b::T)\n        return convert(Cint, a < b ? -1 : a > b ? +1 : 0)::Cint\n    end\n\nNotice that we have to be careful about the return type: ``qsort`` expects a function\nreturning a C ``int``, so we must be sure to return ``Cint`` via a call to ``convert``\nand a ``typeassert``.\n\nIn order to pass this function to C, we obtain its address using the function ``cfunction``::\n\n    const mycompare_c = cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}))\n\n``cfunction`` accepts three arguments: the Julia function (``mycompare``), the return\ntype (``Cint``), and a tuple of the argument types, in this case to sort an array of\n``Cdouble`` (Float64) elements.\n\nThe final call to ``qsort`` looks like this::\n\n    A = [1.3, -2.7, 4.4, 3.1]\n    ccall(:qsort, Void, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Void}),\n          A, length(A), sizeof(eltype(A)), mycompare_c)\n\nAfter this executes, ``A`` is changed to the sorted array ``[-2.7, 1.3, 3.1, 4.4]``.\nNote that Julia knows how to convert an array into a ``Ptr{Cdouble}``, how to compute\nthe size of a type in bytes (identical to C's ``sizeof`` operator), and so on.\nFor fun, try inserting a ``println(\"mycompare($a,$b)\")`` line into ``mycompare``, which\nwill allow you to see the comparisons that ``qsort`` is performing (and to verify that\nit is really calling the Julia function that you passed to it).\n\n\nMapping C Types to Julia\n------------------------\n\nIt is critical to exactly match the declared C type with its declaration\nin Julia. Inconsistencies can cause code that works correctly on one system\nto fail or produce indeterminate results on a different system.\n\nNote that no C header files are used anywhere in the process of calling C\nfunctions: you are responsible for making sure that your Julia types and\ncall signatures accurately reflect those in the C header file. (The `Clang\npackage <https://github.com/ihnorton/Clang.jl>`_ can be used to auto-generate\nJulia code from a C header file.)\n\nAuto-conversion:\n~~~~~~~~~~~~~~~~\n\nJulia automatically inserts calls to the ``convert`` function to convert\neach argument to the specified type. For example, the following call::\n\n    ccall((:foo, \"libfoo\"), Void, (Int32, Float64), x, y)\n\nwill behave as if the following were written::\n\n    ccall((:foo, \"libfoo\"), Void, (Int32, Float64),\n          Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),\n          Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))\n\n``cconvert`` normally just calls ``convert``, but can be defined to return\nan arbitrary new object more appropriate for passing to C. For example,\nthis is used to convert an ``Array`` of objects (e.g. strings) to an\narray of pointers.\n\n``unsafe_convert`` handles conversion to ``Ptr`` types. It is considered\nunsafe because converting an object to a native pointer can hide the object\nfrom the garbage collector, causing it to be freed prematurely.\n\nType Correspondences:\n~~~~~~~~~~~~~~~~~~~~~\n\nFirst, a review of some relevant Julia type terminology:\n\n.. rst-class:: text-wrap\n\n==============================  ==============================  ======================================================\nSyntax / Keyword                Example                         Description\n==============================  ==============================  ======================================================\n``type``                        ``ASCIIString``                 \"Leaf Type\" :: A group of related data that includes\n                                                                a type-tag, is managed by the Julia GC, and\n                                                                is defined by object-identity.\n                                                                The type parameters of a leaf type must be fully defined\n                                                                (no ``TypeVars`` are allowed)\n                                                                in order for the instance to be constructed.\n\n``abstract``                    ``Any``,                        \"Super Type\" :: A super-type (not a leaf-type)\n                                ``AbstractArray{T,N}``,         that cannot be instantiated, but can be used to\n                                ``Complex{T}``                  describe a group of types.\n\n``{T}``                         ``Vector{Int}``                 \"Type Parameter\" :: A specialization of a type\n                                                                (typically used for dispatch or storage optimization).\n\n                                                                \"TypeVar\" :: The ``T`` in the type parameter declaration\n                                                                is referred to as a TypeVar (short for type variable).\n\n``bitstype``                    ``Int``,                        \"Bits Type\" :: A type with no fields, but a size. It\n                                ``Float64``                     is stored and defined by-value.\n\n``immutable``                   ``Pair{Int,Int}``               \"Immutable\" :: A type with all fields defined to be\n                                                                constant. It is defined by-value. And may be stored\n                                                                with a type-tag.\n\n                                ``Complex128`` (``isbits``)     \"Is-Bits\" :: A ``bitstype``, or an ``immutable`` type\n                                                                where all fields are other ``isbits`` types. It is\n                                                                defined by-value, and is stored without a type-tag.\n\n``type ...; end``               ``nothing``                     \"Singleton\" :: a Leaf Type or Immutable with no fields.\n\n``(...)`` or ``tuple(...)```    ``(1,2,3)``                     \"Tuple\" :: an immutable data-structure similar to an\n                                                                anonymous immutable type, or a constant array.\n                                                                Represented as either an array or a struct.\n\n``typealias``                   Not applicable here             Type aliases, and other similar mechanisms of\n                                                                doing type indirection, are resolved to their base\n                                                                type (this includes assigning a type to another name,\n                                                                or getting the type out of a function call).\n==============================  ==============================  ======================================================\n\nBits Types:\n~~~~~~~~~~~\n\nThere are several special types to be aware of, as no other type can be defined to behave the same:\n\n``Float32``\n    Exactly corresponds to the ``float`` type in C (or ``REAL*4`` in Fortran).\n\n``Float64``\n    Exactly corresponds to the ``double`` type in C (or ``REAL*8`` in Fortran).\n\n``Complex64``\n    Exactly corresponds to the ``complex float`` type in C (or ``COMPLEX*8`` in Fortran).\n\n``Complex128``\n    Exactly corresponds to the ``complex double`` type in C (or ``COMPLEX*16`` in Fortran).\n\n``Signed``\n    Exactly corresponds to the ``signed`` type annotation in C (or any ``INTEGER`` type in Fortran). Any Julia type that is not a subtype of ``Signed`` is assumed to be unsigned.\n\n``Ref{T}``\n    Behaves like a ``Ptr{T}`` that owns its memory.\n\n``Array{T,N}``\n    When an array is passed to C as a ``Ptr{T}`` argument, it is\n    not reinterpret-cast: Julia requires that the element type of the\n    array matches ``T``, and the address of the first element is passed.\n\n    Therefore, if an ``Array`` contains data in the wrong format, it will\n    have to be explicitly converted using a call such as ``trunc(Int32,a)``.\n\n    To pass an array ``A`` as a pointer of a different type *without*\n    converting the data beforehand (for example, to pass a ``Float64`` array\n    to a function that operates on uninterpreted bytes), you can\n    declare the argument as ``Ptr{Void}``.\n\n    If an array of eltype ``Ptr{T}`` is passed as a ``Ptr{Ptr{T}}`` argument, the Julia base library\n    ``cconvert`` function will attempt to first make a null-terminated copy of the array with\n    each element replaced by its ``cconvert`` version. This allows, for example, passing an ``argv``\n    pointer array of type ``Vector{ByteString}`` to an argument of type ``Ptr{Ptr{Cchar}}``.\n\nOn all systems we currently support, basic C/C++ value types may be\ntranslated to Julia types as follows. Every C type also has a corresponding\nJulia type with the same name, prefixed by C. This can help for writing portable code (and remembering that an ``int`` in C is not the same as an ``Int`` in Julia).\n\n**System Independent:**\n\n.. rst-class:: text-wrap\n\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| C name                            | Fortran name    | Standard Julia Alias | Julia Base Type                   |\n+===================================+=================+======================+===================================+\n| ``unsigned char``                 | ``CHARACTER``   | ``Cuchar``           | ``UInt8``                         |\n|                                   |                 |                      |                                   |\n| ``bool`` (C++)                    |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``short``                         | ``INTEGER*2``   | ``Cshort``           | ``Int16``                         |\n|                                   |                 |                      |                                   |\n|                                   | ``LOGICAL*2``   |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``unsigned short``                |                 | ``Cushort``          | ``UInt16``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``int``                           | ``INTEGER*4``   | ``Cint``             | ``Int32``                         |\n|                                   |                 |                      |                                   |\n| ``BOOL`` (C, typical)             | ``LOGICAL*4``   |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``unsigned int``                  |                 | ``Cuint``            | ``UInt32``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``long long``                     | ``INTEGER*8``   | ``Clonglong``        | ``Int64``                         |\n|                                   |                 |                      |                                   |\n|                                   | ``LOGICAL*8``   |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``unsigned long long``            |                 | ``Culonglong``       | ``UInt64``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``intmax_t``                      |                 | ``Cintmax_t``        | ``Int64``                         |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``uintmax_t``                     |                 | ``Cuintmax_t``       | ``UInt64``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``float``                         | ``REAL*4i``     | ``Cfloat``           | ``Float32``                       |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``double``                        | ``REAL*8``      | ``Cdouble``          | ``Float64``                       |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``complex float``                 | ``COMPLEX*8``   | ``Complex64``        | ``Complex{Float32}``              |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``complex double``                | ``COMPLEX*16``  | ``Complex128``       | ``Complex{Float64}``              |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``ptrdiff_t``                     |                 | ``Cptrdiff_t``       | ``Int``                           |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``ssize_t``                       |                 | ``Cssize_t``         | ``Int``                           |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``size_t``                        |                 | ``Csize_t``          | ``UInt``                          |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``void``                          |                 |                      | ``Void``                          |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``void*``                         |                 |                      | ``Ptr{Void}``                     |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``T*`` (where T represents an     |                 |                      | ``Ref{T}``                        |\n| appropriately defined type)       |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``char*``                         | ``CHARACTER*N`` |                      | ``Cstring`` if NUL-terminated, or |\n| (or ``char[]``, e.g. a string)    |                 |                      | ``Ptr{UInt8}`` if not             |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``char**`` (or ``*char[]``)       |                 |                      | ``Ptr{Ptr{UInt8}}``               |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``jl_value_t*``                   |                 |                      | ``Any``                           |\n| (any Julia Type)                  |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``jl_value_t**``                  |                 |                      | ``Ref{Any}``                      |\n| (a reference to a Julia Type)     |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``va_arg``                        |                 |                      | Not supported                     |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``...``                           |                 |                      | ``T...`` (where ``T``             |\n| (variadic function specification) |                 |                      | is one of the above types,        |\n|                                   |                 |                      | variadic functions of different   |\n|                                   |                 |                      | argument types are not supported) |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n\nThe ``Cstring`` type is essentially a synonym for ``Ptr{UInt8}``, except the conversion to ``Cstring`` throws an\nerror if the Julia string contains any embedded NUL characters (which would cause the string to be silently\ntruncated if the C routine treats NUL as the terminator).  If you are passing a ``char*`` to a C routine that\ndoes not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that\nyour Julia string does not contain NUL and want to skip the check, you can use ``Ptr{UInt8}`` as the argument type.\n\n**System-dependent:**\n\n======================  ======================  =======\nC name                  Standard Julia Alias    Julia Base Type\n======================  ======================  =======\n``char``                ``Cchar``               ``Int8`` (x86, x86_64)\n\n                                                ``UInt8`` (powerpc, arm)\n\n``long``                ``Clong``               ``Int`` (UNIX)\n\n                                                ``Int32`` (Windows)\n\n``unsigned long``       ``Culong``              ``UInt`` (UNIX)\n\n                                                ``UInt32`` (Windows)\n\n``wchar_t``             ``Cwchar_t``            ``Int32`` (UNIX)\n\n                                                ``UInt16`` (Windows)\n======================  ======================  =======\n\n.. note::\n\n    When calling a Fortran function, all inputs must be passed by reference, so\n    all type correspondences above should contain an additional ``Ptr{..}`` or\n    ``Ref{..}`` wrapper around their type specification.\n\n.. warning::\n\n    For string arguments (``char*``) the Julia type should be ``Cstring`` (if NUL-\n    terminated data is expected) or either ``Ptr{Cchar}`` or ``Ptr{UInt8}``\n    otherwise (these two pointer types have the same effect), as described above,\n    not ``ASCIIString``. Similarly, for array arguments (``T[]`` or ``T*``), the\n    Julia type should again be ``Ptr{T}``, not ``Vector{T}``.\n\n.. warning::\n\n    Julia's ``Char`` type is 32 bits, which is not the same as the wide character\n    type (``wchar_t`` or ``wint_t``) on all platforms.\n\n.. note::\n\n    For ``wchar_t*`` arguments, the Julia type should be ``Cwstring`` (if the C\n    routine expects a NUL-terminated string) or ``Ptr{Cwchar_t}`` otherwise, and\n    data can be converted to/from ordinary Julia strings by the ``wstring(s)``\n    function (equivalent to either ``utf16(s)`` or ``utf32(s)`` depending upon the\n    width of ``Cwchar_t``); this conversion will be called automatically for\n    ``Cwstring`` arguments.    Note also that ASCII, UTF-8, UTF-16, and UTF-32\n    string data in Julia is internally NUL-terminated, so it can be passed to C\n    functions expecting NUL-terminated data without making a copy (but using the\n    ``Cwstring`` type will cause an error to be thrown if the string itself\n    contains NUL characters).\n\n.. note::\n\n    C functions that take an argument of the type ``char**`` can be called by\n    using a ``Ptr{Ptr{UInt8}}`` type within Julia. For example, C functions of the\n    form::\n\n        int main(int argc, char **argv);\n\n    can be called via the following Julia code::\n\n        argv = [ \"a.out\", \"arg1\", \"arg2\" ]\n        ccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)\n\n.. note::\n\n    A C function declared to return ``Void`` will return the value ``nothing`` in\n    Julia.\n\nStruct Type correspondences\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nComposite types, aka ``struct`` in C or ``TYPE`` in Fortran90\n(or ``STRUCTURE`` / ``RECORD`` in some variants of F77),\ncan be mirrored in Julia by creating a ``type`` or ``immutable``\ndefinition with the same field layout.\n\nWhen used recursively, ``isbits`` types are stored inline.\nAll other types are stored as a pointer to the data.\nWhen mirroring a struct used by-value inside another struct in C,\nit is imperative that you do not attempt to manually copy the fields over,\nas this will not preserve the correct field alignment.\nInstead, declare an immutable isbits type and use that instead.\nUnnamed structs are not possible in the translation to Julia.\n\nPacked structs and union declarations are not supported by Julia.\n\nYou can get a near approximation of a ``union`` if you know, a priori,\nthe field that will have the greatest size (potentially including padding).\nWhen translating your fields to Julia, declare the Julia field to be only\nof that type.\n\nArrays of parameters must be expanded manually, currently\n(either inline, or in an immutable helper-type). For example::\n\n    in C:\n    struct B {\n        int A[3];\n    };\n    b_a_2 = B.A[2];\n\n    in Julia:\n    immutable B_A\n        A_1::Cint\n        A_2::Cint\n        A_3::Cint\n    end\n    type B\n        A::B_A\n    end\n    b_a_2 = B.A.(2)\n\nArrays of unknown size are not supported.\n\nIn the future, some of these restrictions may be reduced or eliminated.\n\nMemory Ownership:\n~~~~~~~~~~~~~~~~~\n\n**malloc/free**\n\nMemory allocation and deallocation of such objects must be\nhandled by calls to the appropriate cleanup routines in the libraries\nbeing used, just like in any C program. Do not try to free an object\nreceived from a C library with ``Libc.free`` in Julia, as this may result\nin the ``free`` function being called via the wrong ``libc`` library and\ncause Julia to crash. The reverse (passing an object allocated in Julia\nto be freed by an external library) is equally invalid.\n\n**Ptr{T} vs. Array{T} vs. Ref{T} vs. T**\n\nThe choice of type-wrapper declaration strongly depends on who allocated the memory,\nand the declared type.\nIn general, use ``T`` if the memory is intended to be allocated in\n(and managed by) Julia (with type-tag).\nUse ``Ptr{T}`` if the memory is expected to be populated by ``C`` (without type-tag).\nUse ``Ref{T}`` if you have an ``isbits`` type,\nbut you want to turn it into a pointer to a struct in another struct definition.\n\nSee issue #2818 for some work that needs to be done to simplify this so that Julia\ntypes can be used to recursively mirror c-style structs,\nwithout requiring as much manual management of the ``Ptr`` conversions.\nAfter #2818 is implemented, it will be true that an ``Vector{T}`` will be equivalent to\nan ``Ptr{Ptr{T}}``. That is currently not true, and the conversion must be explicitly.\n\nMapping C Functions to Julia\n----------------------------\n\nccall/cfunction argument translation guide\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor translating a ``c`` argument list to ``Julia``:\n\n* ``T``, where ``T`` is one of the primitive types:\n  ``char``, ``int``, ``long``, ``short``, ``float``, ``double``, ``complex``, ``enum``\n  or any of their ``typedef`` equivalents\n\n  + ``T``, where ``T`` is an equivalent Julia Bits Type (per the table above)\n  + if ``T`` is an ``enum``, the argument type should be equivalent to ``Cint`` or ``Cuint``\n  + argument value will be copied (passed by-value)\n\n* ``struct T`` (including typedef to a struct)\n\n  + ``T``, where ``T`` is a Julia Leaf Type\n  + argument value will be copied (passed by-value)\n\n* ``void*``\n\n  + depends on how this parameter is used, first translate this to the intended pointer type,\n    then determine the Julia equivalent using the remaining rules in this list\n  + this argument may be declared as ``Ptr{Void}``, if it really is just an unknown pointer\n\n* ``jl_value_t*``\n\n  + ``Any``\n  + argument value must be a valid Julia object\n  + currently unsupported by cfunction\n\n* ``jl_value_t**``\n\n  + ``Ref{Any}``\n  + argument value must be a valid Julia object (or ``C_NULL``)\n  + currently unsupported by cfunction\n\n* ``T*``\n\n  + ``Ref{T}``, where ``T`` is the Julia type corresponding to ``T``\n  + argument value will be copied if it is an ``isbits`` type\n    otherwise, the value must be a valid Julia object\n\n* ``(T*)(...)`` (e.g. a pointer to a function)\n\n  + ``Ptr{Void}`` (you may need to use ``cfunction`` explicitly to create this pointer)\n\n* ``...`` (e.g. a vararg)\n\n  + ``T...``, where ``T`` is the Julia type\n\n* ``va_arg``\n\n  + not supported\n\nccall/cfunction return type translation guide\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor translating a ``c`` return type to ``Julia``:\n\n* ``void``\n\n  + ``Void`` (this will return the singleton instance ``nothing::Void``)\n\n* ``T``, where ``T`` is one of the primitive types:\n  ``char``, ``int``, ``long``, ``short``, ``float``, ``double``, ``complex``, ``enum``\n  or any of their ``typedef`` equivalents\n\n  + ``T``, where ``T`` is an equivalent Julia Bits Type (per the table above)\n  + if ``T`` is an ``enum``, the argument type should be equivalent to ``Cint`` or ``Cuint``\n  + argument value will be copied (returned by-value)\n\n* ``struct T`` (including typedef to a struct)\n\n  + ``T``, where ``T`` is a Julia Leaf Type\n  + argument value will be copied (returned by-value)\n\n* ``void*``\n\n  + depends on how this parameter is used, first translate this to the intended pointer type,\n    then determine the Julia equivalent using the remaining rules in this list\n  + this argument may be declared as ``Ptr{Void}``, if it really is just an unknown pointer\n\n* ``jl_value_t*``\n\n  + ``Any``\n  + argument value must be a valid Julia object\n\n* ``jl_value_t**``\n\n  + ``Ref{Any}``\n  + argument value must be a valid Julia object (or ``C_NULL``)\n\n* ``T*``\n\n  + If the memory is already owned by Julia, or is an ``isbits`` type, and is known to be non-null:\n\n    + ``Ref{T}``, where ``T`` is the Julia type corresponding to ``T``\n    + a return type of ``Ref{Any}`` is invalid, it should either be ``Any``\n      (corresponding to ``jl_value_t*``) or ``Ptr{Any}`` (corresponding to ``Ptr{Any}``)\n    + currently partially unsupported by cfunction due to #2818\n    + C **MUST NOT** modify the memory returned via ``Ref{T}`` if ``T`` is an ``isbits`` type\n\n  + If the memory is owned by C:\n\n    + ``Ptr{T}``, where ``T`` is the Julia type corresponding to ``T``\n\n* ``(T*)(...)`` (e.g. a pointer to a function)\n\n  + ``Ptr{Void}`` (you may need to use ``cfunction`` explicitly to create this pointer)\n\nPassing Pointers for Modifying Inputs\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBecause C doesn't support multiple return values,\noften C functions will take pointers to data that the function will modify.\nTo accomplish this within a ``ccall``,\nyou need to first encapsulate the value inside an ``Ref{T}`` of the appropriate type.\nWhen you pass this ``Ref`` object as an argument,\njulia will automatically pass a C pointer to the encapsulated data::\n\n    width = Ref{Cint}(0)\n    range = Ref{Cfloat}(0)\n    ccall(:foo, Void, (Ref{Cint}, Ref{Cfloat}), width, range)\n\nUpon return, the contents of ``width`` and ``range`` can be retrieved\n(if they were changed by ``foo``) by ``width[]`` and ``range[]``; that is,\nthey act like zero-dimensional arrays.\n\nSpecial Reference Syntax for ccall (deprecated):\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``&`` syntax is deprecated, use the ``Ref{T}`` argument type instead.\n\nA prefix ``&`` is used on an argument to ccall to indicate that a pointer\nto a scalar argument should be passed instead of the scalar value itself\n(required for all Fortran function arguments, as noted above). The following\nexample computes a dot product using a BLAS function.\n\n::\n\n    function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})\n      assert(length(DX) == length(DY))\n      n = length(DX)\n      incx = incy = 1\n      product = ccall((:ddot_, \"libLAPACK\"),\n                      Float64,\n                      (Ptr{Int32}, Ptr{Float64}, Ptr{Int32}, Ptr{Float64}, Ptr{Int32}),\n                      &n, DX, &incx, DY, &incy)\n      return product\n    end\n\nThe meaning of prefix ``&`` is not quite the same as in C. In\nparticular, any changes to the referenced variables will not be\nvisible in Julia unless the type is mutable (declared via\n``type``). However, even for immutable types it will not cause any\nharm for called functions to attempt such modifications (that is,\nwriting through the passed pointers). Moreover, ``&`` may be used with\nany expression, such as ``&0`` or ``&f(x)``.\n\nWhen a scalar value is passed with ``&`` as an argument of type\n``Ptr{T}``, the value will first be converted to type ``T``.\n\n\nGarbage Collection Safety\n-------------------------\nWhen passing data to a ccall, it is best to avoid using the ``pointer()``\nfunction. Instead define a convert method and pass the variables directly to\nthe ccall. ccall automatically arranges that all of its arguments will be\npreserved from garbage collection until the call returns. If a C API will\nstore a reference to memory allocated by Julia, after the ccall returns, you\nmust arrange that the object remains visible to the garbage collector. The\nsuggested way to handle this is to make a global variable of type\n``Array{Ref,1}`` to hold these values, until the C library notifies you that\nit is finished with them.\n\nWhenever you have created a pointer to Julia data, you must ensure the original data\nexists until you are done with using the pointer. Many methods in Julia such as\n``unsafe_load()`` and ``bytestring()`` make copies of data instead of taking ownership\nof the buffer, so that it is safe to free (or alter) the original data without\naffecting Julia. A notable exception is ``pointer_to_array()`` which, for performance\nreasons, shares (or can be told to take ownership of) the underlying buffer.\n\nThe garbage collector does not guarantee any order of finalization. That is, if ``a``\ncontained a reference to ``b`` and both ``a`` and ``b`` are due for garbage\ncollection, there is no guarantee that ``b`` would be finalized after ``a``. If\nproper finalization of ``a`` depends on ``b`` being valid, it must be handled in\nother ways.\n\n\nNon-constant Function Specifications\n------------------------------------\n\nA ``(name, library)`` function specification must be a constant expression.\nHowever, it is possible to use computed values as function names by staging\nthrough ``eval`` as follows::\n\n    @eval ccall(($(string(\"a\",\"b\")),\"lib\"), ...\n\nThis expression constructs a name using ``string``, then substitutes this\nname into a new ``ccall`` expression, which is then evaluated. Keep in mind that\n``eval`` only operates at the top level, so within this expression local\nvariables will not be available (unless their values are substituted with\n``$``). For this reason, ``eval`` is typically only used to form top-level\ndefinitions, for example when wrapping libraries that contain many\nsimilar functions.\n\nIf your usage is more dynamic, use indirect calls as described in the next section.\n\n\nIndirect Calls\n--------------\n\nThe first argument to ``ccall`` can also be an expression evaluated at run time.\nIn this case, the expression must evaluate to a ``Ptr``,\nwhich will be used as the address of the native function to call.\nThis behavior occurs when the first ``ccall`` argument contains references to non-constants,\nsuch as local variables, function arguments, or non-constant globals.\n\nFor example, you might lookup the function via ``dlsym``,\nthen cache it in a global variable for that session. For example::\n\n    macro dlsym(func, lib)\n        z, zlocal = gensym(string(func)), gensym()\n        eval(current_module(),:(global $z = C_NULL))\n        z = esc(z)\n        quote\n            let $zlocal::Ptr{Void} = $z::Ptr{Void}\n                if $zlocal == C_NULL\n                   $zlocal = dlsym($(esc(lib))::Ptr{Void}, $(esc(func)))\n                   global $z = $zlocal\n                end\n                $zlocal\n            end\n        end\n    end\n\n    mylibvar = dlopen(\"mylib\")\n    ccall(@dlsym(\"myfunc\", mylibvar), Void, ())\n\n\nCalling Convention\n------------------\n\nThe second argument to ``ccall`` can optionally be a calling convention\nspecifier (immediately preceding return type). Without any specifier,\nthe platform-default C calling convention is used. Other supported\nconventions are: ``stdcall``, ``cdecl``, ``fastcall``, and ``thiscall``.\nFor example (from base/libc.jl) we see the same ``gethostname`` ccall as above,\nbut with the correct signature for Windows::\n\n    hn = Array(UInt8, 256)\n    err = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))\n\nFor more information, please see the `LLVM Language Reference`_.\n\n.. _LLVM Language Reference: http://llvm.org/docs/LangRef.html#calling-conventions\n\n\nAccessing Global Variables\n--------------------------\n\nGlobal variables exported by native libraries can be accessed by name using the\n``cglobal`` function. The arguments to ``cglobal`` are a symbol specification\nidentical to that used by ``ccall``, and a type describing the value stored in\nthe variable::\n\n    julia> cglobal((:errno,:libc), Int32)\n    Ptr{Int32} @0x00007f418d0816b8\n\nThe result is a pointer giving the address of the value. The value can be\nmanipulated through this pointer using ``unsafe_load`` and ``unsafe_store``.\n\n\nAccessing Data through a Pointer\n--------------------------------\nThe following methods are described as \"unsafe\" because a bad pointer\nor type declaration can cause Julia to terminate abruptly\n(although, that's quite alike with ccall).\n\nGiven a ``Ptr{T}``, the contents of type ``T`` can generally be copied from\nthe referenced memory into a Julia object using ``unsafe_load(ptr, [index])``.\nThe index argument is optional (default is 1),\nand follows the Julia-convention of 1-based indexing.\nThis function is intentionally similar to the behavior of ``getindex()`` and ``setindex!()``\n(e.g. ``[]`` access syntax).\n\nThe return value will be a new object initialized\nto contain a copy of the contents of the referenced memory.\nThe referenced memory can safely be freed or released.\n\nIf ``T`` is ``Any``, then the memory is assumed to contain a reference to\na Julia object (a ``jl_value_t*``), the result will be a reference to this object,\nand the object will not be copied. You must be careful in this case to ensure\nthat the object was always visible to the garbage collector (pointers do not\ncount, but the new reference does) to ensure the memory is not prematurely freed.\nNote that if the object was not originally allocated by Julia, the new object\nwill never be finalized by Julia's garbage collector.  If the ``Ptr`` itself\nis actually a ``jl_value_t*``, it can be converted back to a Julia object\nreference by ``unsafe_pointer_to_objref(ptr)``.  (Julia values ``v``\ncan be converted to ``jl_value_t*`` pointers, as ``Ptr{Void}``, by calling\n``pointer_from_objref(v)``.)\n\nThe reverse operation (writing data to a Ptr{T}), can be performed using\n``unsafe_store!(ptr, value, [index])``.  Currently, this is only supported\nfor bitstypes or other pointer-free (``isbits``) immutable types.\n\nAny operation that throws an error is probably currently unimplemented\nand should be posted as a bug so that it can be resolved.\n\nIf the pointer of interest is a plain-data array (bitstype or immutable), the\nfunction ``pointer_to_array(ptr,dims,[own])`` may be more useful. The final\nparameter should be true if Julia should \"take ownership\" of the underlying\nbuffer and call ``free(ptr)`` when the returned ``Array`` object is finalized.\nIf the ``own`` parameter is omitted or false, the caller must ensure the\nbuffer remains in existence until all access is complete.\n\nArithmetic on the ``Ptr`` type in Julia (e.g. using ``+``) does not behave the\nsame as C's pointer arithmetic. Adding an integer to a ``Ptr`` in Julia always\nmoves the pointer by some number of *bytes*, not elements. This way, the\naddress values obtained from pointer arithmetic do not depend on the\nelement types of pointers.\n\n\nThread-safety\n-------------\n\nSome C libraries execute their callbacks from a different thread, and\nsince Julia isn't thread-safe you'll need to take some extra\nprecautions. In particular, you'll need to set up a two-layered\nsystem: the C callback should only *schedule* (via Julia's event loop)\nthe execution of your \"real\" callback. To do this, you pass a function\nof one argument (the ``AsyncWork`` object for which the event was\ntriggered, which you'll probably just ignore) to ``SingleAsyncWork``::\n\n  cb = Base.SingleAsyncWork(data -> my_real_callback(args))\n\nThe callback you pass to C should only execute a ``ccall`` to\n``:uv_async_send``, passing ``cb.handle`` as the argument.\n\nMore About Callbacks\n--------------------\n\nFor more details on how to pass callbacks to C libraries, see this\n`blog post <http://julialang.org/blog/2013/05/callback>`_.\n\nC++\n---\n\nLimited support for C++ is provided by the `Cpp <https://github.com/timholy/Cpp.jl>`_,\n`Clang <https://github.com/ihnorton/Clang.jl>`_, and `Cxx <https://github.com/Keno/Cxx.jl>`_ packages.\n\nHandling Operating System Variation\n-----------------------------------\n\nWhen dealing with platform libraries, it is often necessary to provide special cases\nfor various platforms. The variable ``OS_NAME`` can be used to write these special\ncases. Additionally, there are several macros intended to make this easier:\n``@windows``, ``@unix``, ``@linux``, and ``@osx``. Note that linux and osx are mutually\nexclusive subsets of unix. Their usage takes the form of a ternary conditional\noperator, as demonstrated in the following examples.\n\nSimple blocks::\n\n    ccall( (@windows? :_fopen : :fopen), ...)\n\nComplex blocks::\n\n    @linux? (\n             begin\n                 some_complicated_thing(a)\n             end\n           : begin\n                 some_different_thing(a)\n             end\n           )\n\nChaining (parentheses optional, but recommended for readability)::\n\n    @windows? :a : (@osx? :b : :c)\n\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/contrib/BBEditTextWrangler-julia.plist": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\"\n\t\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n\n<plist version=\"1.0\">\n\n<!--\n      Julia codeless language module for BBEdit and TextWrangler text editors\n\n      version of 2014-09-10 20:17:45\n\n-->\n\n<dict>\n\t<key>BBEditDocumentType</key>\n\t<string>CodelessLanguageModule</string>\n\n\t<key>BBLMLanguageDisplayName</key>\n\t<string>Julia</string>\n\n\t<key>BBLMLanguageCode</key>\n\t<string>Jul!</string>\n\n\t<key>BBLMSuffixMap</key>\n\t<array>\n\t\t<dict>\n    \t\t<key>BBLMLanguageSuffix</key>\n    \t\t<string>.jl</string>\n\t\t</dict>\n\t</array>\n\n\t<key>BBLMColorsSyntax</key>\n\t<true/>\n\n\t<key>BBLMScansFunctions</key>\n    <true/>\n\n    <key>BBLMKeywordList</key>\n      <array>\n      <!-- these reserved words from julia-parser.scm added by hand -->\n            <string>abstract</string>\n            <string>baremodule</string>\n            <string>begin</string>\n            <string>bitstype</string>\n            <string>break</string>\n            <string>ccall</string>\n            <string>const</string>\n            <string>continue</string>\n            <string>do</string>\n            <string>else</string>\n            <string>elseif</string>\n            <string>end</string>\n            <string>export</string>\n            <string>for</string>\n            <string>function</string>\n            <string>global</string>\n            <string>if</string>\n            <string>immutable</string>\n            <string>import</string>\n            <string>importall</string>\n            <string>let</string>\n            <string>local</string>\n            <string>macro</string>\n            <string>module</string>\n            <string>quote</string>\n            <string>return</string>\n            <string>try</string>\n            <string>type</string>\n            <string>typealias</string>\n            <string>using</string>\n            <string>while</string>\n\n      <!-- dunno where this one is defined, added by hand -->\n\n            <string>typeof</string>\n\n      <!-- these generated from names(Base) -->\n              <string>@MIME</string>\n              <string>@MIME_str</string>\n              <string>@__FILE__</string>\n              <string>@allocated</string>\n              <string>@assert</string>\n              <string>@async</string>\n              <string>@b_str</string>\n              <string>@bigint_str</string>\n              <string>@boundscheck</string>\n              <string>@cmd</string>\n              <string>@code_llvm</string>\n              <string>@code_lowered</string>\n              <string>@code_native</string>\n              <string>@code_typed</string>\n              <string>@deprecate</string>\n              <string>@edit</string>\n              <string>@elapsed</string>\n              <string>@eval</string>\n              <string>@evalpoly</string>\n              <string>@everywhere</string>\n              <string>@fetch</string>\n              <string>@fetchfrom</string>\n              <string>@gensym</string>\n              <string>@goto</string>\n              <string>@inbounds</string>\n              <string>@int128_str</string>\n              <string>@ip_str</string>\n              <string>@label</string>\n              <string>@less</string>\n              <string>@linux</string>\n              <string>@linux_only</string>\n              <string>@non_windowsxp_only</string>\n              <string>@osx</string>\n              <string>@osx_only</string>\n              <string>@parallel</string>\n              <string>@printf</string>\n              <string>@profile</string>\n              <string>@r_str</string>\n              <string>@schedule</string>\n              <string>@show</string>\n              <string>@simd</string>\n              <string>@spawn</string>\n              <string>@spawnat</string>\n              <string>@sprintf</string>\n              <string>@sync</string>\n              <string>@task</string>\n              <string>@thunk</string>\n              <string>@time</string>\n              <string>@timed</string>\n              <string>@uint128_str</string>\n              <string>@unexpected</string>\n              <string>@unix</string>\n              <string>@unix_only</string>\n              <string>@v_str</string>\n              <string>@vectorize_1arg</string>\n              <string>@vectorize_2arg</string>\n              <string>@which</string>\n              <string>@windows</string>\n              <string>@windows_only</string>\n              <string>@windowsxp_only</string>\n              <string>A_ldiv_B!</string>\n              <string>A_ldiv_Bc</string>\n              <string>A_ldiv_Bt</string>\n              <string>A_mul_B!</string>\n              <string>A_mul_Bc</string>\n              <string>A_mul_Bc!</string>\n              <string>A_mul_Bt</string>\n              <string>A_mul_Bt!</string>\n              <string>A_rdiv_Bc</string>\n              <string>A_rdiv_Bt</string>\n              <string>Ac_ldiv_B</string>\n              <string>Ac_ldiv_Bc</string>\n              <string>Ac_mul_B</string>\n              <string>Ac_mul_B!</string>\n              <string>Ac_mul_Bc</string>\n              <string>Ac_mul_Bc!</string>\n              <string>Ac_rdiv_B</string>\n              <string>Ac_rdiv_Bc</string>\n              <string>At_ldiv_B</string>\n              <string>At_ldiv_Bt</string>\n              <string>At_mul_B</string>\n              <string>At_mul_B!</string>\n              <string>At_mul_Bt</string>\n              <string>At_mul_Bt!</string>\n              <string>At_rdiv_B</string>\n              <string>At_rdiv_Bt</string>\n              <string>PipeBuffer</string>\n              <string>abs</string>\n              <string>abs2</string>\n              <string>abspath</string>\n              <string>accept</string>\n              <string>acos</string>\n              <string>acosd</string>\n              <string>acosh</string>\n              <string>acot</string>\n              <string>acotd</string>\n              <string>acoth</string>\n              <string>acsc</string>\n              <string>acscd</string>\n              <string>acsch</string>\n              <string>addprocs</string>\n              <string>airy</string>\n              <string>airyai</string>\n              <string>airyaiprime</string>\n              <string>airybi</string>\n              <string>airybiprime</string>\n              <string>airyprime</string>\n              <string>airyx</string>\n              <string>all</string>\n              <string>all!</string>\n              <string>angle</string>\n              <string>any</string>\n              <string>any!</string>\n              <string>append!</string>\n              <string>ascii</string>\n              <string>asec</string>\n              <string>asecd</string>\n              <string>asech</string>\n              <string>asin</string>\n              <string>asind</string>\n              <string>asinh</string>\n              <string>assert</string>\n              <string>atan</string>\n              <string>atan2</string>\n              <string>atand</string>\n              <string>atanh</string>\n              <string>atexit</string>\n              <string>backtrace</string>\n              <string>base</string>\n              <string>base64</string>\n              <string>basename</string>\n              <string>beginswith</string>\n              <string>besselh</string>\n              <string>besseli</string>\n              <string>besselix</string>\n              <string>besselj</string>\n              <string>besselj0</string>\n              <string>besselj1</string>\n              <string>besseljx</string>\n              <string>besselk</string>\n              <string>besselkx</string>\n              <string>bessely</string>\n              <string>bessely0</string>\n              <string>bessely1</string>\n              <string>besselyx</string>\n              <string>beta</string>\n              <string>bfft</string>\n              <string>bfft!</string>\n              <string>big</string>\n              <string>bin</string>\n              <string>bind</string>\n              <string>binomial</string>\n              <string>bitbroadcast</string>\n              <string>bitmix</string>\n              <string>bitpack</string>\n              <string>bits</string>\n              <string>bitunpack</string>\n              <string>bkfact</string>\n              <string>bkfact!</string>\n              <string>blas_set_num_threads</string>\n              <string>blkdiag</string>\n              <string>bool</string>\n              <string>brfft</string>\n              <string>broadcast</string>\n              <string>broadcast!</string>\n              <string>broadcast!_function</string>\n              <string>broadcast_function</string>\n              <string>broadcast_getindex</string>\n              <string>broadcast_setindex!</string>\n              <string>bswap</string>\n              <string>bytes2hex</string>\n              <string>bytestring</string>\n              <string>c_calloc</string>\n              <string>c_free</string>\n              <string>c_malloc</string>\n              <string>c_realloc</string>\n              <string>cartesianmap</string>\n              <string>cat</string>\n              <string>catch_backtrace</string>\n              <string>cbrt</string>\n              <string>cd</string>\n              <string>ceil</string>\n              <string>cell</string>\n              <string>cfunction</string>\n              <string>char</string>\n              <string>charwidth</string>\n              <string>checkbounds</string>\n              <string>chol</string>\n              <string>cholfact</string>\n              <string>cholfact!</string>\n              <string>chomp</string>\n              <string>chop</string>\n              <string>chr2ind</string>\n              <string>circshift</string>\n              <string>cis</string>\n              <string>clamp</string>\n              <string>clear_malloc_data</string>\n              <string>clipboard</string>\n              <string>close</string>\n              <string>cmp</string>\n              <string>code_llvm</string>\n              <string>code_lowered</string>\n              <string>code_native</string>\n              <string>code_typed</string>\n              <string>collect</string>\n              <string>colon</string>\n              <string>combinations</string>\n              <string>complement</string>\n              <string>complement!</string>\n              <string>complex</string>\n              <string>complex128</string>\n              <string>complex32</string>\n              <string>complex64</string>\n              <string>cond</string>\n              <string>condskeel</string>\n              <string>conj</string>\n              <string>conj!</string>\n              <string>connect</string>\n              <string>consume</string>\n              <string>contains</string>\n              <string>conv</string>\n              <string>conv2</string>\n              <string>convert</string>\n              <string>copy</string>\n              <string>copy!</string>\n              <string>copysign</string>\n              <string>cor</string>\n              <string>cos</string>\n              <string>cosc</string>\n              <string>cosd</string>\n              <string>cosh</string>\n              <string>cospi</string>\n              <string>cot</string>\n              <string>cotd</string>\n              <string>coth</string>\n              <string>count</string>\n              <string>count_ones</string>\n              <string>count_zeros</string>\n              <string>countlines</string>\n              <string>countnz</string>\n              <string>cov</string>\n              <string>cp</string>\n              <string>cross</string>\n              <string>csc</string>\n              <string>cscd</string>\n              <string>csch</string>\n              <string>ctime</string>\n              <string>ctranspose</string>\n              <string>cummax</string>\n              <string>cummin</string>\n              <string>cumprod</string>\n              <string>cumprod!</string>\n              <string>cumsum</string>\n              <string>cumsum!</string>\n              <string>cumsum_kbn</string>\n              <string>current_module</string>\n              <string>current_task</string>\n              <string>dawson</string>\n              <string>dct</string>\n              <string>dct!</string>\n              <string>dec</string>\n              <string>deconv</string>\n              <string>deepcopy</string>\n              <string>deg2rad</string>\n              <string>degrees2radians</string>\n              <string>delete!</string>\n              <string>deleteat!</string>\n              <string>den</string>\n              <string>dense</string>\n              <string>deserialize</string>\n              <string>det</string>\n              <string>detach</string>\n              <string>dfill</string>\n              <string>diag</string>\n              <string>diagind</string>\n              <string>diagm</string>\n              <string>diff</string>\n              <string>digamma</string>\n              <string>digits</string>\n              <string>dirname</string>\n              <string>disable_sigint</string>\n              <string>display</string>\n              <string>displayable</string>\n              <string>distribute</string>\n              <string>div</string>\n              <string>divrem</string>\n              <string>dlclose</string>\n              <string>dlopen</string>\n              <string>dlopen_e</string>\n              <string>dlsym</string>\n              <string>dlsym_e</string>\n              <string>done</string>\n              <string>dones</string>\n              <string>dot</string>\n              <string>download</string>\n              <string>drand</string>\n              <string>drandn</string>\n              <string>dump</string>\n              <string>dzeros</string>\n              <string>eachline</string>\n              <string>eachmatch</string>\n              <string>edit</string>\n              <string>eig</string>\n              <string>eigfact</string>\n              <string>eigfact!</string>\n              <string>eigmax</string>\n              <string>eigmin</string>\n              <string>eigs</string>\n              <string>eigvals</string>\n              <string>eigvecs</string>\n              <string>eltype</string>\n              <string>empty!</string>\n              <string>endof</string>\n              <string>endswith</string>\n              <string>enumerate</string>\n              <string>eof</string>\n              <string>eps</string>\n              <string>erf</string>\n              <string>erfc</string>\n              <string>erfcinv</string>\n              <string>erfcx</string>\n              <string>erfi</string>\n              <string>erfinv</string>\n              <string>errno</string>\n              <string>error</string>\n              <string>esc</string>\n              <string>escape_string</string>\n              <string>eta</string>\n              <string>etree</string>\n              <string>evalfile</string>\n              <string>exit</string>\n              <string>exp</string>\n              <string>exp10</string>\n              <string>exp2</string>\n              <string>expand</string>\n              <string>expanduser</string>\n              <string>expm</string>\n              <string>expm1</string>\n              <string>exponent</string>\n              <string>extrema</string>\n              <string>eye</string>\n              <string>factor</string>\n              <string>factorial</string>\n              <string>factorize</string>\n              <string>falses</string>\n              <string>fd</string>\n              <string>fdio</string>\n              <string>fetch</string>\n              <string>fft</string>\n              <string>fft!</string>\n              <string>fftshift</string>\n              <string>fieldoffsets</string>\n              <string>filemode</string>\n              <string>filesize</string>\n              <string>fill</string>\n              <string>fill!</string>\n              <string>filt</string>\n              <string>filt!</string>\n              <string>filter</string>\n              <string>filter!</string>\n              <string>finalizer</string>\n              <string>find</string>\n              <string>find_library</string>\n              <string>findfirst</string>\n              <string>findin</string>\n              <string>findmax</string>\n              <string>findmin</string>\n              <string>findn</string>\n              <string>findnext</string>\n              <string>findnz</string>\n              <string>first</string>\n              <string>fld</string>\n              <string>flipbits!</string>\n              <string>flipdim</string>\n              <string>fliplr</string>\n              <string>flipsign</string>\n              <string>flipud</string>\n              <string>float</string>\n              <string>float16</string>\n              <string>float32</string>\n              <string>float32_isvalid</string>\n              <string>float64</string>\n              <string>float64_isvalid</string>\n              <string>floor</string>\n              <string>flush</string>\n              <string>flush_cstdio</string>\n              <string>foldl</string>\n              <string>foldr</string>\n              <string>frexp</string>\n              <string>full</string>\n              <string>fullname</string>\n              <string>functionloc</string>\n              <string>functionlocs</string>\n              <string>gamma</string>\n              <string>gc</string>\n              <string>gc_disable</string>\n              <string>gc_enable</string>\n              <string>gcd</string>\n              <string>gcdx</string>\n              <string>gensym</string>\n              <string>get</string>\n              <string>get!</string>\n              <string>get_bigfloat_precision</string>\n              <string>get_bigfloat_rounding</string>\n              <string>get_rounding</string>\n              <string>getaddrinfo</string>\n              <string>gethostname</string>\n              <string>getindex</string>\n              <string>getipaddr</string>\n              <string>getkey</string>\n              <string>getpid</string>\n              <string>givens</string>\n              <string>gperm</string>\n              <string>gradient</string>\n              <string>hankelh1</string>\n              <string>hankelh1x</string>\n              <string>hankelh2</string>\n              <string>hankelh2x</string>\n              <string>hash</string>\n              <string>haskey</string>\n              <string>hcat</string>\n              <string>hessfact</string>\n              <string>hessfact!</string>\n              <string>hex</string>\n              <string>hex2bytes</string>\n              <string>hex2num</string>\n              <string>hist</string>\n              <string>hist2d</string>\n              <string>histrange</string>\n              <string>homedir</string>\n              <string>htol</string>\n              <string>hton</string>\n              <string>hvcat</string>\n              <string>hypot</string>\n              <string>iceil</string>\n              <string>idct</string>\n              <string>idct!</string>\n              <string>identity</string>\n              <string>ifelse</string>\n              <string>ifft</string>\n              <string>ifft!</string>\n              <string>ifftshift</string>\n              <string>ifloor</string>\n              <string>ignorestatus</string>\n              <string>imag</string>\n              <string>in</string>\n              <string>include</string>\n              <string>include_string</string>\n              <string>ind2chr</string>\n              <string>ind2sub</string>\n              <string>indexin</string>\n              <string>indexpids</string>\n              <string>indmax</string>\n              <string>indmin</string>\n              <string>inf</string>\n              <string>info</string>\n              <string>infs</string>\n              <string>insert!</string>\n              <string>int</string>\n              <string>int128</string>\n              <string>int16</string>\n              <string>int32</string>\n              <string>int64</string>\n              <string>int8</string>\n              <string>integer</string>\n              <string>interrupt</string>\n              <string>intersect</string>\n              <string>intersect!</string>\n              <string>inv</string>\n              <string>invdigamma</string>\n              <string>invmod</string>\n              <string>invperm</string>\n              <string>ipermute!</string>\n              <string>ipermutedims</string>\n              <string>irfft</string>\n              <string>iround</string>\n              <string>is_assigned_char</string>\n              <string>is_valid_ascii</string>\n              <string>is_valid_char</string>\n              <string>is_valid_utf16</string>\n              <string>is_valid_utf8</string>\n              <string>isabspath</string>\n              <string>isalnum</string>\n              <string>isalpha</string>\n              <string>isapprox</string>\n              <string>isascii</string>\n              <string>isbits</string>\n              <string>isblank</string>\n              <string>isblockdev</string>\n              <string>ischardev</string>\n              <string>iscntrl</string>\n              <string>isconst</string>\n              <string>isdigit</string>\n              <string>isdir</string>\n              <string>isdirpath</string>\n              <string>iseltype</string>\n              <string>isempty</string>\n              <string>isequal</string>\n              <string>iseven</string>\n              <string>isexecutable</string>\n              <string>isfifo</string>\n              <string>isfile</string>\n              <string>isfinite</string>\n              <string>isgeneric</string>\n              <string>isgraph</string>\n              <string>ishermitian</string>\n              <string>isimmutable</string>\n              <string>isinf</string>\n              <string>isinteger</string>\n              <string>isinteractive</string>\n              <string>isleaftype</string>\n              <string>isless</string>\n              <string>islink</string>\n              <string>islower</string>\n              <string>ismarked</string>\n              <string>ismatch</string>\n              <string>isnan</string>\n              <string>isodd</string>\n              <string>isopen</string>\n              <string>ispath</string>\n              <string>isperm</string>\n              <string>isposdef</string>\n              <string>isposdef!</string>\n              <string>ispow2</string>\n              <string>isprime</string>\n              <string>isprint</string>\n              <string>ispunct</string>\n              <string>isqrt</string>\n              <string>isreadable</string>\n              <string>isreadonly</string>\n              <string>isready</string>\n              <string>isreal</string>\n              <string>issetgid</string>\n              <string>issetuid</string>\n              <string>issocket</string>\n              <string>issorted</string>\n              <string>isspace</string>\n              <string>issparse</string>\n              <string>issticky</string>\n              <string>issubnormal</string>\n              <string>issubset</string>\n              <string>issym</string>\n              <string>istaskdone</string>\n              <string>istext</string>\n              <string>istril</string>\n              <string>istriu</string>\n              <string>isupper</string>\n              <string>isvalid</string>\n              <string>iswritable</string>\n              <string>isxdigit</string>\n              <string>itrunc</string>\n              <string>join</string>\n              <string>joinpath</string>\n              <string>keys</string>\n              <string>kill</string>\n              <string>kron</string>\n              <string>last</string>\n              <string>lbeta</string>\n              <string>lcfirst</string>\n              <string>lcm</string>\n              <string>ldexp</string>\n              <string>ldltfact</string>\n              <string>ldltfact!</string>\n              <string>leading_ones</string>\n              <string>leading_zeros</string>\n              <string>length</string>\n              <string>less</string>\n              <string>lexcmp</string>\n              <string>lexless</string>\n              <string>lfact</string>\n              <string>lgamma</string>\n              <string>linrange</string>\n              <string>linreg</string>\n              <string>linspace</string>\n              <string>listen</string>\n              <string>listenany</string>\n              <string>localindexes</string>\n              <string>localpart</string>\n              <string>log</string>\n              <string>log10</string>\n              <string>log1p</string>\n              <string>log2</string>\n              <string>logdet</string>\n              <string>logspace</string>\n              <string>lowercase</string>\n              <string>lpad</string>\n              <string>lstat</string>\n              <string>lstrip</string>\n              <string>ltoh</string>\n              <string>lu</string>\n              <string>lufact</string>\n              <string>lufact!</string>\n              <string>lyap</string>\n              <string>macroexpand</string>\n              <string>map</string>\n              <string>map!</string>\n              <string>mapreduce</string>\n              <string>mapslices</string>\n              <string>mark</string>\n              <string>match</string>\n              <string>matchall</string>\n              <string>max</string>\n              <string>maxabs</string>\n              <string>maxabs!</string>\n              <string>maximum</string>\n              <string>maximum!</string>\n              <string>maxintfloat</string>\n              <string>mean</string>\n              <string>mean!</string>\n              <string>median</string>\n              <string>median!</string>\n              <string>merge</string>\n              <string>merge!</string>\n              <string>methods</string>\n              <string>methodswith</string>\n              <string>middle</string>\n              <string>midpoints</string>\n              <string>mimewritable</string>\n              <string>min</string>\n              <string>minabs</string>\n              <string>minabs!</string>\n              <string>minimum</string>\n              <string>minimum!</string>\n              <string>minmax</string>\n              <string>mkdir</string>\n              <string>mkpath</string>\n              <string>mktemp</string>\n              <string>mktempdir</string>\n              <string>mmap</string>\n              <string>mmap_array</string>\n              <string>mmap_bitarray</string>\n              <string>mod</string>\n              <string>mod1</string>\n              <string>mod2pi</string>\n              <string>modf</string>\n              <string>module_name</string>\n              <string>module_parent</string>\n              <string>msync</string>\n              <string>mtime</string>\n              <string>mv</string>\n              <string>myid</string>\n              <string>myindexes</string>\n              <string>names</string>\n              <string>nan</string>\n              <string>nans</string>\n              <string>nb_available</string>\n              <string>ndigits</string>\n              <string>ndims</string>\n              <string>next</string>\n              <string>nextfloat</string>\n              <string>nextind</string>\n              <string>nextpow</string>\n              <string>nextpow2</string>\n              <string>nextprod</string>\n              <string>nfilled</string>\n              <string>nnz</string>\n              <string>nonzeros</string>\n              <string>norm</string>\n              <string>normalize_string</string>\n              <string>normfro</string>\n              <string>normpath</string>\n              <string>notify</string>\n              <string>nprocs</string>\n              <string>nthperm</string>\n              <string>nthperm!</string>\n              <string>ntoh</string>\n              <string>ntuple</string>\n              <string>null</string>\n              <string>num</string>\n              <string>num2hex</string>\n              <string>nworkers</string>\n              <string>object_id</string>\n              <string>oct</string>\n              <string>oftype</string>\n              <string>one</string>\n              <string>ones</string>\n              <string>open</string>\n              <string>operm</string>\n              <string>parent</string>\n              <string>parentindexes</string>\n              <string>parse</string>\n              <string>parsefloat</string>\n              <string>parseint</string>\n              <string>parseip</string>\n              <string>partitions</string>\n              <string>peakflops</string>\n              <string>permutations</string>\n              <string>permute!</string>\n              <string>permutedims</string>\n              <string>permutedims!</string>\n              <string>pinv</string>\n              <string>plan_bfft</string>\n              <string>plan_bfft!</string>\n              <string>plan_brfft</string>\n              <string>plan_dct</string>\n              <string>plan_dct!</string>\n              <string>plan_fft</string>\n              <string>plan_fft!</string>\n              <string>plan_idct</string>\n              <string>plan_idct!</string>\n              <string>plan_ifft</string>\n              <string>plan_ifft!</string>\n              <string>plan_irfft</string>\n              <string>plan_rfft</string>\n              <string>pmap</string>\n              <string>pointer</string>\n              <string>pointer_from_objref</string>\n              <string>pointer_to_array</string>\n              <string>poll_fd</string>\n              <string>poll_file</string>\n              <string>polygamma</string>\n              <string>pop!</string>\n              <string>popdisplay</string>\n              <string>position</string>\n              <string>powermod</string>\n              <string>precision</string>\n              <string>precompile</string>\n              <string>prepend!</string>\n              <string>prevfloat</string>\n              <string>prevind</string>\n              <string>prevpow</string>\n              <string>prevpow2</string>\n              <string>prevprod</string>\n              <string>primes</string>\n              <string>print</string>\n              <string>print_escaped</string>\n              <string>print_joined</string>\n              <string>print_shortest</string>\n              <string>print_unescaped</string>\n              <string>print_with_color</string>\n              <string>println</string>\n              <string>process_exited</string>\n              <string>process_running</string>\n              <string>procs</string>\n              <string>prod</string>\n              <string>prod!</string>\n              <string>produce</string>\n              <string>promote</string>\n              <string>promote_rule</string>\n              <string>promote_shape</string>\n              <string>promote_type</string>\n              <string>push!</string>\n              <string>pushdisplay</string>\n              <string>put</string>\n              <string>put!</string>\n              <string>pwd</string>\n              <string>qr</string>\n              <string>qrfact</string>\n              <string>qrfact!</string>\n              <string>quadgk</string>\n              <string>quantile</string>\n              <string>quantile!</string>\n              <string>quit</string>\n              <string>rad2deg</string>\n              <string>radians2degrees</string>\n              <string>rand</string>\n              <string>rand!</string>\n              <string>randbool</string>\n              <string>randbool!</string>\n              <string>randcycle</string>\n              <string>randn</string>\n              <string>randn!</string>\n              <string>randperm</string>\n              <string>randstring</string>\n              <string>randsubseq</string>\n              <string>randsubseq!</string>\n              <string>range</string>\n              <string>rank</string>\n              <string>rationalize</string>\n              <string>read</string>\n              <string>read!</string>\n              <string>readall</string>\n              <string>readandwrite</string>\n              <string>readavailable</string>\n              <string>readbytes</string>\n              <string>readbytes!</string>\n              <string>readchomp</string>\n              <string>readcsv</string>\n              <string>readdir</string>\n              <string>readdlm</string>\n              <string>readline</string>\n              <string>readlines</string>\n              <string>readsfrom</string>\n              <string>readuntil</string>\n              <string>real</string>\n              <string>realmax</string>\n              <string>realmin</string>\n              <string>realpath</string>\n              <string>recv</string>\n              <string>redirect_stderr</string>\n              <string>redirect_stdin</string>\n              <string>redirect_stdout</string>\n              <string>redisplay</string>\n              <string>reduce</string>\n              <string>reducedim</string>\n              <string>reenable_sigint</string>\n              <string>reim</string>\n              <string>reinterpret</string>\n              <string>reload</string>\n              <string>rem</string>\n              <string>rem1</string>\n              <string>remotecall</string>\n              <string>remotecall_fetch</string>\n              <string>remotecall_wait</string>\n              <string>repeat</string>\n              <string>replace</string>\n              <string>repmat</string>\n              <string>repr</string>\n              <string>reprmime</string>\n              <string>require</string>\n              <string>reset</string>\n              <string>reshape</string>\n              <string>resize!</string>\n              <string>rethrow</string>\n              <string>reverse</string>\n              <string>reverse!</string>\n              <string>rfft</string>\n              <string>rm</string>\n              <string>rmdir</string>\n              <string>rmprocs</string>\n              <string>rol</string>\n              <string>ror</string>\n              <string>rot180</string>\n              <string>rotl90</string>\n              <string>rotr90</string>\n              <string>round</string>\n              <string>rpad</string>\n              <string>rref</string>\n              <string>rsearch</string>\n              <string>rsearchindex</string>\n              <string>rsplit</string>\n              <string>rstrip</string>\n              <string>run</string>\n              <string>scale</string>\n              <string>scale!</string>\n              <string>schedule</string>\n              <string>schur</string>\n              <string>schurfact</string>\n              <string>schurfact!</string>\n              <string>sdata</string>\n              <string>search</string>\n              <string>searchindex</string>\n              <string>searchsorted</string>\n              <string>searchsortedfirst</string>\n              <string>searchsortedlast</string>\n              <string>sec</string>\n              <string>secd</string>\n              <string>sech</string>\n              <string>seek</string>\n              <string>seekend</string>\n              <string>seekstart</string>\n              <string>select</string>\n              <string>select!</string>\n              <string>send</string>\n              <string>serialize</string>\n              <string>set_bigfloat_precision</string>\n              <string>set_bigfloat_rounding</string>\n              <string>set_rounding</string>\n              <string>setdiff</string>\n              <string>setdiff!</string>\n              <string>setenv</string>\n              <string>setfield</string>\n              <string>setindex!</string>\n              <string>shift!</string>\n              <string>show</string>\n              <string>showall</string>\n              <string>showcompact</string>\n              <string>showerror</string>\n              <string>shuffle</string>\n              <string>shuffle!</string>\n              <string>sign</string>\n              <string>signbit</string>\n              <string>signed</string>\n              <string>signif</string>\n              <string>significand</string>\n              <string>similar</string>\n              <string>sin</string>\n              <string>sinc</string>\n              <string>sind</string>\n              <string>sinh</string>\n              <string>sinpi</string>\n              <string>size</string>\n              <string>sizehint</string>\n              <string>sizeof</string>\n              <string>skip</string>\n              <string>skipchars</string>\n              <string>sleep</string>\n              <string>slice</string>\n              <string>slicedim</string>\n              <string>sort</string>\n              <string>sort!</string>\n              <string>sortcols</string>\n              <string>sortperm</string>\n              <string>sortrows</string>\n              <string>sparse</string>\n              <string>sparsevec</string>\n              <string>spawn</string>\n              <string>spdiagm</string>\n              <string>speye</string>\n              <string>splice!</string>\n              <string>split</string>\n              <string>splitdir</string>\n              <string>splitdrive</string>\n              <string>splitext</string>\n              <string>spones</string>\n              <string>sprand</string>\n              <string>sprandbool</string>\n              <string>sprandn</string>\n              <string>sprint</string>\n              <string>spzeros</string>\n              <string>sqrt</string>\n              <string>sqrtm</string>\n              <string>squeeze</string>\n              <string>srand</string>\n              <string>start</string>\n              <string>start_reading</string>\n              <string>start_timer</string>\n              <string>start_watching</string>\n              <string>stat</string>\n              <string>std</string>\n              <string>stdm</string>\n              <string>step</string>\n              <string>stop_reading</string>\n              <string>stop_timer</string>\n              <string>strerror</string>\n              <string>strftime</string>\n              <string>stride</string>\n              <string>strides</string>\n              <string>string</string>\n              <string>stringmime</string>\n              <string>strip</string>\n              <string>strptime</string>\n              <string>strwidth</string>\n              <string>sub</string>\n              <string>sub2ind</string>\n              <string>subtypes</string>\n              <string>success</string>\n              <string>sum</string>\n              <string>sum!</string>\n              <string>sum_kbn</string>\n              <string>sumabs</string>\n              <string>sumabs!</string>\n              <string>sumabs2</string>\n              <string>sumabs2!</string>\n              <string>summary</string>\n              <string>super</string>\n              <string>svd</string>\n              <string>svdfact</string>\n              <string>svdfact!</string>\n              <string>svdvals</string>\n              <string>svdvals!</string>\n              <string>sylvester</string>\n              <string>symbol</string>\n              <string>symdiff</string>\n              <string>symdiff!</string>\n              <string>symlink</string>\n              <string>symperm</string>\n              <string>systemerror</string>\n              <string>take</string>\n              <string>take!</string>\n              <string>takebuf_array</string>\n              <string>takebuf_string</string>\n              <string>tan</string>\n              <string>tand</string>\n              <string>tanh</string>\n              <string>task_local_storage</string>\n              <string>tempdir</string>\n              <string>tempname</string>\n              <string>tic</string>\n              <string>time</string>\n              <string>time_ns</string>\n              <string>timedwait</string>\n              <string>toc</string>\n              <string>toq</string>\n              <string>touch</string>\n              <string>trace</string>\n              <string>trailing_ones</string>\n              <string>trailing_zeros</string>\n              <string>transpose</string>\n              <string>trigamma</string>\n              <string>tril</string>\n              <string>tril!</string>\n              <string>triu</string>\n              <string>triu!</string>\n              <string>trues</string>\n              <string>trunc</string>\n              <string>truncate</string>\n              <string>typeintersect</string>\n              <string>typejoin</string>\n              <string>typemax</string>\n              <string>typemin</string>\n              <string>ucfirst</string>\n              <string>uint</string>\n              <string>uint128</string>\n              <string>uint16</string>\n              <string>uint32</string>\n              <string>uint64</string>\n              <string>uint8</string>\n              <string>unescape_string</string>\n              <string>union</string>\n              <string>union!</string>\n              <string>unique</string>\n              <string>unmark</string>\n              <string>unsafe_copy!</string>\n              <string>unsafe_load</string>\n              <string>unsafe_pointer_to_objref</string>\n              <string>unsafe_store!</string>\n              <string>unshift!</string>\n              <string>unsigned</string>\n              <string>uperm</string>\n              <string>uppercase</string>\n              <string>utf16</string>\n              <string>utf32</string>\n              <string>utf8</string>\n              <string>values</string>\n              <string>var</string>\n              <string>varm</string>\n              <string>vcat</string>\n              <string>vec</string>\n              <string>vecnorm</string>\n              <string>versioninfo</string>\n              <string>wait</string>\n              <string>warn</string>\n              <string>watch_file</string>\n              <string>which</string>\n              <string>whos</string>\n              <string>widemul</string>\n              <string>widen</string>\n              <string>with_bigfloat_precision</string>\n              <string>with_bigfloat_rounding</string>\n              <string>with_rounding</string>\n              <string>workers</string>\n              <string>workspace</string>\n              <string>write</string>\n              <string>writecsv</string>\n              <string>writedlm</string>\n              <string>writemime</string>\n              <string>writesto</string>\n              <string>wstring</string>\n              <string>xcorr</string>\n              <string>xdump</string>\n              <string>yield</string>\n              <string>zero</string>\n              <string>zeros</string>\n              <string>zeta</string>\n              <string>zip</string>\n    </array>\n\n    <!-- these are the names(Base) ... strings that start with capital letter and are not functions. -->\n\n    <key>BBLMPredefinedNameList</key>\n      <array>\n              <string>AbstractMatrix</string>\n              <string>AbstractRNG</string>\n              <string>AbstractSparseArray</string>\n              <string>AbstractSparseMatrix</string>\n              <string>AbstractSparseVector</string>\n              <string>AbstractVecOrMat</string>\n              <string>AbstractVector</string>\n              <string>ArgumentError</string>\n              <string>Array</string>\n              <string>Associative</string>\n              <string>BLAS</string>\n              <string>Base</string>\n              <string>Base64Pipe</string>\n              <string>Bidiagonal</string>\n              <string>BigFloat</string>\n              <string>BigInt</string>\n              <string>BitArray</string>\n              <string>BitMatrix</string>\n              <string>BitVector</string>\n              <string>CFILE</string>\n              <string>Cchar</string>\n              <string>Cdouble</string>\n              <string>Cfloat</string>\n              <string>CharString</string>\n              <string>Cint</string>\n              <string>Clong</string>\n              <string>Clonglong</string>\n              <string>ClusterManager</string>\n              <string>Cmd</string>\n              <string>Coff_t</string>\n              <string>Collections</string>\n              <string>Colon</string>\n              <string>Complex</string>\n              <string>Complex128</string>\n              <string>Complex32</string>\n              <string>Complex64</string>\n              <string>Condition</string>\n              <string>Cptrdiff_t</string>\n              <string>Cshort</string>\n              <string>Csize_t</string>\n              <string>Cssize_t</string>\n              <string>Cuchar</string>\n              <string>Cuint</string>\n              <string>Culong</string>\n              <string>Culonglong</string>\n              <string>Cushort</string>\n              <string>Cwchar_t</string>\n              <string>DArray</string>\n              <string>DenseMatrix</string>\n              <string>DenseVecOrMat</string>\n              <string>DenseVector</string>\n              <string>Diagonal</string>\n              <string>Dict</string>\n              <string>DimensionMismatch</string>\n              <string>Display</string>\n              <string>EOFError</string>\n              <string>EachLine</string>\n              <string>Enumerate</string>\n              <string>ErrorException</string>\n              <string>FFTW</string>\n              <string>Factorization</string>\n              <string>FileMonitor</string>\n              <string>FileOffset</string>\n              <string>Filter</string>\n              <string>FloatRange</string>\n              <string>Graphics</string>\n              <string>Hermitian</string>\n              <string>IO</string>\n              <string>IOBuffer</string>\n              <string>IOStream</string>\n              <string>IPv4</string>\n              <string>IPv6</string>\n              <string>IntSet</string>\n              <string>KeyError</string>\n              <string>LAPACK</string>\n              <string>LoadError</string>\n              <string>LocalProcess</string>\n              <string>MIME</string>\n              <string>Irrational</string>\n              <string>Matrix</string>\n              <string>MersenneTwister</string>\n              <string>Meta</string>\n              <string>MethodError</string>\n              <string>ObjectIdDict</string>\n              <string>Operators</string>\n              <string>OrdinalRange</string>\n              <string>ParseError</string>\n              <string>Pkg</string>\n              <string>PollingFileWatcher</string>\n              <string>ProcessExitedException</string>\n              <string>ProcessGroup</string>\n              <string>Profile</string>\n              <string>Range</string>\n              <string>Range1</string>\n              <string>Ranges</string>\n              <string>Rational</string>\n              <string>RawFD</string>\n              <string>Regex</string>\n              <string>RegexMatch</string>\n              <string>RemoteRef</string>\n              <string>RepString</string>\n              <string>RevString</string>\n              <string>RopeString</string>\n              <string>RoundDown</string>\n              <string>RoundFromZero</string>\n              <string>RoundNearest</string>\n              <string>RoundToZero</string>\n              <string>RoundUp</string>\n              <string>RoundingMode</string>\n              <string>Set</string>\n              <string>SharedArray</string>\n              <string>SharedMatrix</string>\n              <string>SharedVector</string>\n              <string>SparseMatrixCSC</string>\n              <string>Stat</string>\n              <string>StatStruct</string>\n              <string>StepRange</string>\n              <string>StridedArray</string>\n              <string>StridedMatrix</string>\n              <string>StridedVecOrMat</string>\n              <string>StridedVector</string>\n              <string>SubArray</string>\n              <string>SubDArray</string>\n              <string>SubOrDArray</string>\n              <string>SubString</string>\n              <string>SymTridiagonal</string>\n              <string>Symmetric</string>\n              <string>Sys</string>\n              <string>SystemError</string>\n              <string>Test</string>\n              <string>TextDisplay</string>\n              <string>Timer</string>\n              <string>TmStruct</string>\n              <string>Triangular</string>\n              <string>Tridiagonal</string>\n              <string>TypeError</string>\n              <string>UTF16String</string>\n              <string>UTF32String</string>\n              <string>UdpSocket</string>\n              <string>UniformScaling</string>\n              <string>UnitRange</string>\n              <string>VecOrMat</string>\n              <string>Vector</string>\n              <string>VersionNumber</string>\n              <string>WString</string>\n              <string>WeakKeyDict</string>\n              <string>WeakRef</string>\n              <string>Zip</string>\n    </array>\n\n\t<key>Language Features</key>\n\t<dict>\n\t\t<key>Identifier and Keyword Character Class</key>\n\t\t<string>A-Za-z0-9_!</string>\n\n\t\t<key>Escape Char in Strings 1</key>\n\t\t<string>\\</string>\n\n\t\t<key>End-of-line Ends Strings 1</key>\n\t\t<false/>\n\n\t\t<key>End-of-line Ends Strings 2</key>\n\t\t<false/>\n\n        <!-- function-matching regex, might need tweaking -->\n\t\t<key>Function Pattern</key>\n        <string><![CDATA[\n        (?x:\n            (?P<leadspace>^\\s*)\n            (?P<function>\n                function\\s+\n                (?P<function_name>\n                    [a-zA-Z0-9_!?.]+\n                )\n                (?s:.+?)\n                \\r(?P=leadspace)end\n            )\n        )\n        ]]>\n        </string>\n\n        <!-- string-matching regex -->\n        <key>String Pattern</key>\n        <string><![CDATA[\n        (?x:\n            (\\\"\\\"\\\"(\\\\\"\\\"\\\"|[^\\\"\\\"\\\"]|\\\\\\r)*\\\"\\\"\\\")  | (?# Triple-Double-quote)\n            (\"(\\\\\"|[^\"\\r]|\\\\\\r)*\")        | (?# Single-Double-quote)\n            (r\"(\\\\\"|[^\"\\r]|\\\\\\r)*\")       | (?# Regex-quote)\n            ('(\\\\|[^'\\r]|\\\\\\r)*')         | (?# Character single)\n            (`(\\\\\"|[^`\\r]|\\\\\\r)*`)          (?# Back-quote)\n        )\n        ]]></string>\n\n     <!-- comment-matching regex - nicked from the BBEdit docs.\n\n          I can only do a single unnested multiline comment block, but\n          perhaps some fiendishly cunning recursive regex could do nested multiline comments...?\n\n    -->\n\t<key>Comment Pattern</key>\n    <string><![CDATA[\n    (?msx:\n        (\\#=(.*?)=\\#) | (?# one unnested multiline comment block)\n        (\\#.*?$)        (?# a single line comment)\n    )\n    ]]></string>\n\t</dict>\n</dict>\n</plist>\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/base/libdl.jl": "# This file is a part of Julia. License is MIT: http://julialang.org/license\n\nmodule Libdl\n\nexport DL_LOAD_PATH, RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL,\n    RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW, dlclose, dlopen, dlopen_e, dlsym, dlsym_e,\n    dlpath, find_library, dlext, dllist\n\nconst DL_LOAD_PATH = ByteString[]\n@osx_only push!(DL_LOAD_PATH, \"@executable_path/../lib/julia\")\n@osx_only push!(DL_LOAD_PATH, \"@executable_path/../lib\")\n\n# constants to match JL_RTLD_* in src/julia.h\nconst RTLD_LOCAL     = 0x00000001\nconst RTLD_GLOBAL    = 0x00000002\nconst RTLD_LAZY      = 0x00000004\nconst RTLD_NOW       = 0x00000008\nconst RTLD_NODELETE  = 0x00000010\nconst RTLD_NOLOAD    = 0x00000020\nconst RTLD_DEEPBIND  = 0x00000040\nconst RTLD_FIRST     = 0x00000080\n\nfunction dlsym(hnd::Ptr, s::Union{Symbol,AbstractString})\n    hnd == C_NULL && throw(ArgumentError(\"NULL library handle\"))\n    ccall(:jl_dlsym, Ptr{Void}, (Ptr{Void}, Cstring), hnd, s)\nend\n\nfunction dlsym_e(hnd::Ptr, s::Union{Symbol,AbstractString})\n    hnd == C_NULL && throw(ArgumentError(\"NULL library handle\"))\n    ccall(:jl_dlsym_e, Ptr{Void}, (Ptr{Void}, Cstring), hnd, s)\nend\n\ndlopen(s::Symbol, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND) =\n    dlopen(string(s), flags)\n\ndlopen(s::AbstractString, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND) =\n    ccall(:jl_load_dynamic_library, Ptr{Void}, (Cstring,UInt32), s, flags)\n\ndlopen_e(s::Symbol, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND) =\n    dlopen_e(string(s), flags)\n\ndlopen_e(s::AbstractString, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND) =\n    ccall(:jl_load_dynamic_library_e, Ptr{Void}, (Cstring,UInt32), s, flags)\n\nfunction dlclose(p::Ptr)\n    if p != C_NULL\n        ccall(:uv_dlclose,Void,(Ptr{Void},),p)\n        Libc.free(p)\n    end\nend\n\nfunction find_library(libnames::Vector, extrapaths::Vector=ASCIIString[])\n    for lib in libnames\n        for path in extrapaths\n            l = joinpath(path, lib)\n            p = dlopen_e(l, RTLD_LAZY)\n            if p != C_NULL\n                dlclose(p)\n                return l\n            end\n        end\n        p = dlopen_e(lib, RTLD_LAZY)\n        if p != C_NULL\n            dlclose(p)\n            return lib\n        end\n    end\n    return \"\"\nend\n\nfunction dlpath(handle::Ptr{Void})\n    p = ccall(:jl_pathname_for_handle, Ptr{UInt8}, (Ptr{Void},), handle)\n    s = bytestring(p)\n    @windows_only Libc.free(p)\n    return s\nend\n\nfunction dlpath(libname::Union{AbstractString, Symbol})\n    handle = dlopen(libname)\n    path = dlpath(handle)\n    dlclose(handle)\n    return path\nend\n\nif OS_NAME === :Darwin\n    const dlext = \"dylib\"\nelseif OS_NAME === :Windows\n    const dlext = \"dll\"\nelse\n    #assume OS_NAME === :Linux, or similar\n    const dlext = \"so\"\nend\n\n@linux_only begin\n    immutable dl_phdr_info\n        # Base address of object\n        addr::Cuint\n\n        # Null-terminated name of object\n        name::Ptr{UInt8}\n\n        # Pointer to array of ELF program headers for this object\n        phdr::Ptr{Void}\n\n        # Number of program headers for this object\n        phnum::Cshort\n    end\n\n    # This callback function called by dl_iterate_phdr() on Linux\n    function dl_phdr_info_callback(di::dl_phdr_info, size::Csize_t, dynamic_libraries::Array{AbstractString,1})\n        # Skip over objects without a path (as they represent this own object)\n        name = bytestring(di.name)\n        if !isempty(name)\n            push!(dynamic_libraries, name)\n        end\n        return convert(Cint, 0)::Cint\n    end\nend #@linux_only\n\nfunction dllist()\n    dynamic_libraries = Array(AbstractString,0)\n\n    @linux_only begin\n        const callback = cfunction(dl_phdr_info_callback, Cint,\n                                   (Ref{dl_phdr_info}, Csize_t, Ref{Array{AbstractString,1}} ))\n        ccall(:dl_iterate_phdr, Cint, (Ptr{Void}, Ref{Array{AbstractString,1}}), callback, dynamic_libraries)\n    end\n\n    @osx_only begin\n        numImages = ccall(:_dyld_image_count, Cint, (), )\n\n        # start at 1 instead of 0 to skip self\n        for i in 1:numImages-1\n            name = bytestring(ccall(:_dyld_get_image_name, Ptr{UInt8}, (UInt32,), i))\n            push!(dynamic_libraries, name)\n        end\n    end\n\n    @windows_only begin\n        ccall(:jl_dllist, Cint, (Any,), dynamic_libraries)\n    end\n\n    dynamic_libraries\nend\n\nend # module\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/base/deprecated.jl": "# This file is a part of Julia. License is MIT: http://julialang.org/license\n\n# Deprecated functions and objects\n#\n# Please add new deprecations at the bottom of the file.\n# A function deprecated in a release will be removed in the next one.\n# Please also add a reference to the pull request which introduced the\n# deprecation.\n#\n# For simple cases where a direct replacement is available, use @deprecate:\n# the first argument is the signature of the deprecated method, the second one\n# is the call which replaces it. Remove the definition of the deprecated method\n# and unexport it, as @deprecate takes care of calling the replacement\n# and of exporting the function.\n#\n# For more complex cases, move the body of the deprecated method in this file,\n# and call depwarn() directly from inside it. The symbol depwarn() expects is\n# the name of the function, which is used to ensure that the deprecation warning\n# is only printed the first time for each call place.\n\nmacro deprecate(old,new)\n    meta = Expr(:meta, :noinline)\n    if isa(old,Symbol)\n        oldname = Expr(:quote,old)\n        newname = Expr(:quote,new)\n        Expr(:toplevel,\n            Expr(:export,esc(old)),\n            :(function $(esc(old))(args...)\n                  $meta\n                  depwarn(string($oldname,\" is deprecated, use \",$newname,\" instead.\"),\n                          $oldname)\n                  $(esc(new))(args...)\n              end))\n    elseif isa(old,Expr) && old.head == :call\n        remove_linenums!(new)\n        oldcall = sprint(io->show_unquoted(io,old))\n        newcall = sprint(io->show_unquoted(io,new))\n        oldsym = if isa(old.args[1],Symbol)\n            old.args[1]\n        elseif isa(old.args[1],Expr) && old.args[1].head == :curly\n            old.args[1].args[1]\n        else\n            error(\"invalid usage of @deprecate\")\n        end\n        oldname = Expr(:quote, oldsym)\n        Expr(:toplevel,\n            Expr(:export,esc(oldsym)),\n            :($(esc(old)) = begin\n                  $meta\n                  depwarn(string($oldcall,\" is deprecated, use \",$newcall,\" instead.\"),\n                          $oldname)\n                  $(esc(new))\n              end))\n    else\n        error(\"invalid usage of @deprecate\")\n    end\nend\n\nremove_linenums!(ex) = ex\nfunction remove_linenums!(ex::Expr)\n    filter!(x->!((isa(x,Expr) && is(x.head,:line)) || isa(x,LineNumberNode)), ex.args)\n    for subex in ex.args\n        remove_linenums!(subex)\n    end\n    ex\nend\n\nfunction depwarn(msg, funcsym)\n    opts = JLOptions()\n    if opts.depwarn > 0\n        ln = unsafe_load(cglobal(:jl_lineno, Int))\n        fn = bytestring(unsafe_load(cglobal(:jl_filename, Ptr{Cchar})))\n        bt = backtrace()\n        caller = firstcaller(bt, funcsym)\n        if opts.depwarn == 1 # raise a warning\n            warn(msg, once=(caller != C_NULL), key=caller, bt=bt,\n                 filename=fn, lineno=ln)\n        elseif opts.depwarn == 2 # raise an error\n            throw(ErrorException(msg))\n        end\n    end\nend\n\nfunction firstcaller(bt::Array{Ptr{Void},1}, funcsym::Symbol)\n    # Identify the calling line\n    i = 1\n    while i <= length(bt)\n        lkup = ccall(:jl_lookup_code_address, Any, (Ptr{Void},Cint), bt[i], true)\n        i += 1\n        if lkup === ()\n            continue\n        end\n        fname, file, line, inlinedat_file, inlinedat_line, fromC = lkup\n        if fname == funcsym\n            break\n        end\n    end\n    if i <= length(bt)\n        return bt[i]\n    end\n    return C_NULL\nend\n\ndeprecate(s::Symbol) = deprecate(current_module(), s)\ndeprecate(m::Module, s::Symbol) = ccall(:jl_deprecate_binding, Void, (Any, Any), m, s)\n\nmacro deprecate_binding(old, new)\n    Expr(:toplevel,\n         Expr(:export, esc(old)),\n         Expr(:const, Expr(:(=), esc(old), esc(new))),\n         Expr(:call, :deprecate, Expr(:quote, old)))\nend\n\n# 0.4 deprecations\n\n@deprecate split(x,y,l::Integer,k::Bool) split(x,y;limit=l,keep=k)\n@deprecate split(x,y,l::Integer) split(x,y;limit=l)\n@deprecate split(x,y,k::Bool) split(x,y;keep=k)\n\n@deprecate rsplit(x,y,l::Integer,k::Bool) rsplit(x,y;limit=l,keep=k)\n@deprecate rsplit(x,y,l::Integer) rsplit(x,y;limit=l)\n@deprecate rsplit(x,y,k::Bool) rsplit(x,y;keep=k)\n\nconst TcpSocket = TCPSocket\ndeprecate(:TcpSocket)\nconst IpAddr = IPAddr\ndeprecate(:IpAddr)\n@deprecate_binding UdpSocket UDPSocket\n\n@deprecate isblank(c::Char) c == ' ' || c == '\\t'\n@deprecate isblank(s::AbstractString) all(c -> c == ' ' || c == '\\t', s)\n\n@deprecate_binding Nothing Void\n@deprecate_binding None Union{}\n\nexport apply\n@noinline function apply(f, args...)\n    depwarn(\"apply(f, x) is deprecated, use `f(x...)` instead\", :apply)\n    return Core._apply(call, f, args...)\nend\n\n@deprecate median(v::AbstractArray; checknan::Bool=true)  median(v)\n@deprecate median(v::AbstractArray, region; checknan::Bool=true)  median(v, region)\n@deprecate median!(v::AbstractVector; checknan::Bool=true)  median!(v)\n\n@deprecate Dict{K,V}(ks::AbstractArray{K}, vs::AbstractArray{V}) Dict{K,V}(zip(ks, vs))\n@deprecate Dict{K,V}(ks::Tuple{Vararg{K}}, vs::Tuple{Vararg{V}}) Dict{K,V}(zip(ks, vs))\n@deprecate Dict{K}(ks::Tuple{Vararg{K}}, vs::Tuple)              Dict{K,Any}(zip(ks, vs))\n@deprecate Dict{V}(ks::Tuple, vs::Tuple{Vararg{V}})              Dict{Any,V}(zip(ks, vs))\n@deprecate Dict(ks, vs)                                          Dict{Any,Any}(zip(ks, vs))\n\n@deprecate itrunc{T<:Integer}(::Type{T}, n::Integer) (n % T)\n\n@deprecate oftype{T}(::Type{T},c)  convert(T,c)\n\n@deprecate inf(x::AbstractFloat)  oftype(x,Inf)\n@deprecate nan(x::AbstractFloat)  oftype(x,NaN)\n@deprecate inf{T<:AbstractFloat}(::Type{T})  convert(T,Inf)\n@deprecate nan{T<:AbstractFloat}(::Type{T})  convert(T,NaN)\n\n@deprecate_binding String AbstractString\n\n# 13221 - when removing Uint deprecation, remove hack in jl_binding_deprecation_warning\n@deprecate_binding Uint    UInt\n@deprecate_binding Uint8   UInt8\n@deprecate_binding Uint16  UInt16\n@deprecate_binding Uint32  UInt32\n@deprecate_binding Uint64  UInt64\n@deprecate_binding Uint128 UInt128\n\n@deprecate zero{T}(::Type{Ptr{T}}) Ptr{T}(0)\n@deprecate zero{T}(x::Ptr{T})      Ptr{T}(0)\n@deprecate one{T}(::Type{Ptr{T}})  Ptr{T}(1)\n@deprecate one{T}(x::Ptr{T})       Ptr{T}(1)\n\n@deprecate rand!(r::Range, A::AbstractArray) rand!(A, r)\n@deprecate rand!(mt::MersenneTwister, r::Range, A::AbstractArray) rand!(mt, A, r)\n\n@deprecate itrunc(x)              trunc(Integer,x)\n@deprecate itrunc{T<:Integer}(::Type{T},x::Real) trunc(T,x)\n@deprecate iceil(x)               ceil(Integer,x)\n@deprecate iceil{T}(::Type{T},x)  ceil(T,x)\n@deprecate ifloor(x)              floor(Integer,x)\n@deprecate ifloor{T}(::Type{T},x) floor(T,x)\n@deprecate iround(x)              round(Integer,x)\n@deprecate iround{T}(::Type{T},x) round(T,x)\n\n@deprecate_binding Base64Pipe Base64EncodePipe\n@deprecate base64 base64encode\n\n@deprecate prevind(a::Any, i::Integer)   i-1\n@deprecate nextind(a::Any, i::Integer)   i+1\n\n@deprecate givens{T}(f::T, g::T, i1::Integer, i2::Integer, cols::Integer)   givens(f, g, i1, i2)\n\n@deprecate squeeze(X, dims) squeeze(X, tuple(dims...))\n\n@deprecate sizehint(A, n) sizehint!(A, n)\n\n@deprecate randbool!                               rand!\n@deprecate randbool()                              rand(Bool)\n@deprecate randbool(r::AbstractRNG)                rand(r, Bool)\n@deprecate randbool(dims::Dims)                    bitrand(dims)\n@deprecate randbool(dims::Int...)                  bitrand(dims)\n@deprecate randbool(r::AbstractRNG, dims::Dims)    bitrand(r, dims)\n@deprecate randbool(r::AbstractRNG, dims::Int...)  bitrand(r, dims)\n\n@deprecate beginswith startswith\n\n@deprecate functionlocs(f,t)  map(functionloc, methods(f,t))\n\n@deprecate null nullspace\n\n@deprecate error(ex::Exception) throw(ex)\n@deprecate error{E<:Exception}(::Type{E}) throw(E())\n\n@deprecate_binding MemoryError OutOfMemoryError\n\n@deprecate map!(f::Callable, dest::StridedArray, A::StridedArray, B::Number) broadcast!(f, dest, A, B)\n@deprecate map!(f::Callable, dest::StridedArray, A::Number, B::StridedArray) broadcast!(f, dest, A, B)\n\n#9295\n@deprecate push!(t::Associative, key, v)  setindex!(t, v, key)\n\n@deprecate (|>)(src::AbstractCmd,    dest::AbstractCmd)    pipeline(src, dest)\n@deprecate (.>)(src::AbstractCmd,    dest::AbstractCmd)    pipeline(src, stderr=dest)\n@deprecate (|>)(src::Redirectable,   dest::AbstractCmd)    pipeline(src, dest)\n@deprecate (|>)(src::AbstractCmd,    dest::Redirectable)   pipeline(src, dest)\n@deprecate (.>)(src::AbstractCmd,    dest::Redirectable)   pipeline(src, stderr=dest)\n@deprecate (|>)(src::AbstractCmd,    dest::AbstractString) pipeline(src, dest)\n@deprecate (|>)(src::AbstractString, dest::AbstractCmd)    pipeline(src, dest)\n@deprecate (.>)(src::AbstractCmd,    dest::AbstractString) pipeline(src, stderr=dest)\n@deprecate (>>)(src::AbstractCmd,    dest::AbstractString) pipeline(src, stdout=dest, append=true)\n@deprecate (.>>)(src::AbstractCmd,   dest::AbstractString) pipeline(src, stderr=dest, append=true)\n@deprecate pipe pipeline\n\n# 10314\n@deprecate filter!(r::Regex, d::Dict) filter!((k,v)->ismatch(r,k), d)\n\n# 1470\n@deprecate integer(s::AbstractString)   parse(Int,s)\n@deprecate unsigned(s::AbstractString)  parse(UInt,s)\n@deprecate int(s::AbstractString)       parse(Int,s)\n@deprecate uint(s::AbstractString)      parse(UInt,s)\n@deprecate int8(s::AbstractString)      parse(Int8,s)\n@deprecate uint8(s::AbstractString)     parse(UInt8,s)\n@deprecate int16(s::AbstractString)     parse(Int16,s)\n@deprecate uint16(s::AbstractString)    parse(UInt16,s)\n@deprecate int32(s::AbstractString)     parse(Int32,s)\n@deprecate uint32(s::AbstractString)    parse(UInt32,s)\n@deprecate int64(s::AbstractString)     parse(Int64,s)\n@deprecate uint64(s::AbstractString)    parse(UInt64,s)\n@deprecate int128(s::AbstractString)    parse(Int128,s)\n@deprecate uint128(s::AbstractString)   parse(UInt128,s)\n@deprecate float64(s::AbstractString)   parse(Float64,s)\n@deprecate float32(s::AbstractString)   parse(Float32,s)\n\nfor (f,t) in ((:integer, Integer), (:signed, Signed), (:unsigned, Unsigned))\n    @eval begin\n        @deprecate $f(x::AbstractArray) round($t, x)\n    end\nend\n\nfor (f,t) in ((:int,    Int), (:int8,   Int8), (:int16,  Int16), (:int32,  Int32),\n              (:int64,  Int64), (:int128, Int128), (:uint,   UInt), (:uint8,  UInt8),\n              (:uint16, UInt16), (:uint32, UInt32), (:uint64, UInt64), (:uint128,UInt128))\n    ex1 = sprint(io->show_unquoted(io,:([parse($t,s) for s in a])))\n    ex2 = sprint(io->show_unquoted(io,:(round($t, a))))\n    name = Expr(:quote,f)\n    @eval begin\n        function ($f)(x::AbstractArray)\n            if all(y->isa(y,AbstractString), x)\n                depwarn(string($name,\"(a::AbstractArray) is deprecated, use \", $ex1, \" instead.\"), $name)\n                return [parse($t,s) for s in x]\n            elseif all(y->isa(y,Number), x)\n                depwarn(string($name,\"(a::AbstractArray) is deprecated, use \", $ex2, \" instead.\"), $name)\n                return round($t, x)\n            end\n            y = similar(x,$t)\n            i = 1\n            for e in x\n                y[i] = ($f)(e)\n                i += 1\n            end\n            y\n        end\n    end\nend\n\nfor (f,t) in ((:char, Char), (:bool, Bool), (:float16, Float16), (:float32, Float32),\n              (:float64, Float64), (:complex64, Complex64), (:complex128, Complex128))\n    @eval begin\n        @deprecate $f(x::AbstractArray) map($t, x)\n    end\nend\n\nconst convert_funcs_and_types =\n    ((:integer, Integer), (:signed, Signed), (:unsigned, Unsigned), (:int, Int), (:int8, Int8),\n     (:int16, Int16), (:int32, Int32), (:int64, Int64), (:int128, Int128), (:uint, UInt),\n     (:uint8, UInt8), (:uint16, UInt16), (:uint32, UInt32), (:uint64, UInt64), (:uint128,UInt128),\n     (:float16, Float16), (:float32, Float32), (:float64, Float64))\n\nfor (f,t) in convert_funcs_and_types\n     @eval begin\n         @deprecate $f(r::StepRange) map($t, r)\n         @deprecate $f(r::UnitRange) map($t, r)\n     end\nend\n\nfor (f,t) in ((:float16,:Float16),(:float32,:Float32),(:float64,:Float64))\n    @eval begin\n        @deprecate $f(r::FloatRange) map($t, r)\n    end\nend\n\n@deprecate int(x)  Int(x)\n@deprecate uint(x) UInt(x)\n\n@deprecate bool(x::Number)  x!=0\n\n@deprecate char(x)                 Char(x)\n@deprecate char(x::AbstractFloat)  Char(round(UInt32,x))\n@deprecate integer(x::Char)        Int(x)\n\n@deprecate complex128(r::Real, i::Real)  Complex128(r, i)\n@deprecate complex128(z)                 Complex128(z)\n@deprecate complex64(r::Real, i::Real)   Complex64(r, i)\n@deprecate complex64(z)                  Complex64(z)\n@deprecate complex32(r::Real, i::Real)   Complex32(r, i)\n@deprecate complex32(z)                  Complex32(z)\n\nfor (f,t) in convert_funcs_and_types\n    @eval begin\n        @deprecate $f(z::Complex)  Complex($t(real(z)), $t(imag(z)))\n    end\nend\n\n@deprecate float16(x) Float16(x)\n@deprecate float32(x) Float32(x)\n@deprecate float64(x) Float64(x)\n\n@deprecate int8(x)   Int8(x)\n@deprecate int16(x)  Int16(x)\n@deprecate int32(x)  Int32(x)\n@deprecate int64(x)  Int64(x)\n@deprecate int128(x) Int128(x)\n\n@deprecate uint8(x)           UInt8(x)\n@deprecate uint8(x::Integer)  x % UInt8\n@deprecate uint8(x::Bool)     UInt8(x)\n\n@deprecate uint16(x)  UInt16(x)\n@deprecate uint32(x)  UInt32(x)\n@deprecate uint64(x)  UInt64(x)\n@deprecate uint128(x) UInt128(x)\n\n@deprecate integer(x) Integer(x)\n\nfor (f,t) in ((:uint8,:UInt8), (:uint16,:UInt16), (:uint32,:UInt32), (:uint64,:Uint64),\n              (:int8,:Int8),   (:int16,:Int16),   (:int32,:Int32),   (:int64,:Int64),\n              (:int128,:Int128), (:uint128,:UInt128), (:signed,:Int), (:unsigned,:UInt),\n              (:integer,:Int), (:int,:Int), (:uint,:UInt))\n    @eval begin\n        @deprecate ($f)(x::AbstractFloat)  round($t,x)\n        @deprecate ($f)(x::Rational)       round($t,x)\n    end\nend\n\n@deprecate integer(x::Ptr)   convert(UInt, x)\n@deprecate unsigned(x::Ptr)  convert(UInt, x)\n\nfor (f,t) in ((:float32, Float32), (:float64, Float64))\n    @eval begin\n        @deprecate ($f){S<:AbstractString}(a::AbstractArray{S}) [parse($t,s) for s in a]\n    end\nend\n\n@deprecate flipud(A::AbstractArray) flipdim(A, 1)\n@deprecate fliplr(A::AbstractArray) flipdim(A, 2)\n\n@deprecate sub2ind{T<:Integer}(dims::Array{T}, sub::Array{T}) sub2ind(tuple(dims...), sub...)\n@deprecate ind2sub!{T<:Integer}(sub::Array{T}, dims::Array{T}, ind::T) ind2sub!(sub, tuple(dims...), ind)\n\n@deprecate strftime     Libc.strftime\n@deprecate strptime     Libc.strptime\n@deprecate flush_cstdio Libc.flush_cstdio\n@deprecate c_free       Libc.free\n@deprecate c_malloc     Libc.malloc\n@deprecate c_calloc     Libc.calloc\n@deprecate c_realloc    Libc.realloc\n@deprecate errno        Libc.errno\n@deprecate strerror     Libc.strerror\n\n@deprecate dlclose      Libdl.dlclose\n@deprecate dlopen       Libdl.dlopen\n@deprecate dlopen_e     Libdl.dlopen_e\n@deprecate dlsym        Libdl.dlsym\n@deprecate dlsym_e      Libdl.dlsym_e\n@deprecate find_library Libdl.find_library\n\n@deprecate cholfact(A::AbstractMatrix, \u03b2::Number) cholfact(A, shift=\u03b2)\n@deprecate ldltfact(A::AbstractMatrix, \u03b2::Number) ldltfact(A, shift=\u03b2)\n\n@deprecate with_env(f::Function, key::AbstractString, val) withenv(f, key=>val)\n\n@deprecate ntuple(n::Integer, f::Function) ntuple(f, n)\n\n# 0.4 discontinued functions\n\n@noinline function subtypetree(x::DataType, level=-1)\n    depwarn(\"`subtypetree` is discontinued\", :subtypetree)\n    (level == 0 ? (x, []) : (x, Any[subtypetree(y, level-1) for y in subtypes(x)]))\nend\n\n@noinline function unsafe_convert{P}(::Type{P}, x)\n    P<:Ptr || throw(MethodError(unsafe_convert, (Type{P}, x)))\n    ret = convert(P, x) # attempt the call first, so we only print the depwarn if it can even succeed\n    depwarn(\"convert(::Type{Ptr}, ::$(typeof(x))) methods should be converted to be methods of unsafe_convert\", :unsafe_convert)\n    return ret\nend\n\n@noinline function convert{T}(::Type{Ptr{T}}, x::Integer)\n    depwarn(\"converting integers to pointers is discontinued\", :convert)\n    box(Ptr{T},unbox(UInt,UInt(x)))\nend\n@noinline function convert{T}(::Type{Ptr{T}}, x::Signed)\n    depwarn(\"converting signed numbers to pointers is discontinued\", :convert)\n    box(Ptr{T},unbox(Int,Int(x)))\nend\n\n# 8898\n@deprecate precision(x::DateTime) eps(x)\n@deprecate precision(x::Date) eps(x)\n\n@deprecate names(t::DataType) fieldnames(t)\n@deprecate names(v) fieldnames(v)\n\n@noinline function push!(A)\n    depwarn(\"push!(A) has been deprecated\", :push!)\n    A\nend\n\n# 10458\nto_index_nodep(i::Real) = convert(Int,i)::Int\n\n@noinline function to_index(i::Real)\n    depwarn(\"Indexing with non-Integer Reals is deprecated.  It may be that your index arose from an integer division of the form i/j, in which case you should consider using i\u00f7j or div(i,j) instead.\", :to_index)\n    to_index_nodep(i)\nend\n\nto_index{T<:Integer}(A::AbstractArray{T}) = A\n@noinline function to_index{T<:Real}(A::AbstractArray{T})\n    depwarn(\"indexing with non Integer AbstractArrays is deprecated\", :to_index)\n    Int[to_index_nodep(x) for x in A]\nend\n\n@noinline function to_index(I::Tuple)\n    depwarn(\"to_index(I::Tuple) is deprecated, use to_indexes(I...) instead.\", :to_index)\n    to_indexes(I...)\nend\n\n@deprecate getindex(c::Char, I::Real...) getindex(c, map(Int, I)...)\n@deprecate getindex(s::AbstractString, x::Real) getindex(s, Int(x))\n@deprecate checkbounds(s::AbstractString, i::Real) checkbounds(s, Int(i))\n\n@noinline function float_isvalid{T<:Union{Float32,Float64}}(s::AbstractString, out::Array{T,1})\n    tf = tryparse(T, s)\n    isnull(tf) || (out[1] = get(tf))\n    !isnull(tf)\nend\n\n@noinline function float32_isvalid(s::AbstractString, out::Array{Float32,1})\n    depwarn(\"float32_isvalid is deprecated, use tryparse(Float32,s) instead\", :float32_isvalid)\n    float_isvalid(s, out)\nend\n\n@noinline function float64_isvalid(s::AbstractString, out::Array{Float64,1})\n    depwarn(\"float64_isvalid is deprecated, use tryparse(Float64,s) instead\", :float64_isvalid)\n    float_isvalid(s, out)\nend\n\nexport float32_isvalid, float64_isvalid\n\n@deprecate parsefloat(s::AbstractString) parse(Float64,s)\n@deprecate parsefloat(T, s)              parse(T, s)\n\n@deprecate parseint(s)                parse(Int, s)\n@deprecate parseint(s,base)           parse(Int, s, base)\n@deprecate parseint(T::Type, s)       parse(T, s)\n@deprecate parseint(T::Type, s, base) parse(T, s, base)\n\n@deprecate linrange linspace\n\n@deprecate BigFloat(s::AbstractString) parse(BigFloat,s)\n@deprecate BigInt(s::AbstractString) parse(BigInt,s)\n\n@deprecate (~)(x::Char)           Char(~UInt32(x))\n@deprecate (&)(x::Char, y::Char)  Char(UInt32(x) & UInt32(y))\n@deprecate (|)(x::Char, y::Char)  Char(UInt32(x) | UInt32(y))\n@deprecate ($)(x::Char, y::Char)  Char(UInt32(x) $ UInt32(y))\n\n# 11241\n@deprecate is_valid_char(ch::Char)          isvalid(ch)\n@deprecate is_valid_ascii(str::ASCIIString) isvalid(str)\n@deprecate is_valid_utf8(str::UTF8String)   isvalid(str)\n@deprecate is_valid_utf16(str::UTF16String) isvalid(str)\n@deprecate is_valid_utf32(str::UTF32String) isvalid(str)\n@deprecate is_valid_char(ch)   isvalid(Char, ch)\n@deprecate is_valid_ascii(str) isvalid(ASCIIString, str)\n@deprecate is_valid_utf8(str)  isvalid(UTF8String, str)\n@deprecate is_valid_utf16(str) isvalid(UTF16String, str)\n@deprecate is_valid_utf32(str) isvalid(UTF32String, str)\n\n# 11379\n@deprecate utf32(c::Integer...)   UTF32String(UInt32[c...,0])\n\n# 12087\n@deprecate call(P::Base.DFT.Plan, A) P * A\nfor f in (:plan_fft, :plan_ifft, :plan_bfft, :plan_fft!, :plan_ifft!, :plan_bfft!, :plan_rfft)\n    @eval @deprecate $f(A, dims, flags) $f(A, dims; flags=flags)\n    @eval @deprecate $f(A, dims, flags, tlim) $f(A, dims; flags=flags, timelimit=tlim)\nend\nfor f in (:plan_brfft, :plan_irfft)\n    @eval @deprecate $f(A, d, dims, flags) $f(A, d, dims; flags=flags)\n    @eval @deprecate $f(A, d, dims, flags, tlim) $f(A, d, dims; flags=flags, timelimit=tlim)\nend\n\n# 10862\n\n@noinline function chol(A::AbstractMatrix, uplo::Symbol)\n    depwarn(string(\"chol(a::AbstractMatrix, uplo::Symbol) is deprecated, \",\n        \"use chol(a::AbstractMatrix, uplo::Union{Val{:L},Val{:U}}) instead\"), :chol)\n    chol(A, Val{uplo})\nend\n\n# 11554\n\nread!(from::AbstractIOBuffer, p::Ptr, nb::Integer) = read!(from, p, Int(nb))\nfunction read!(from::AbstractIOBuffer, p::Ptr, nb::Int)\n    depwarn(\"read!(::IOBuffer, ::Ptr) is unsafe and therefore deprecated\", :read!)\n    from.readable || throw(ArgumentError(\"read failed, IOBuffer is not readable\"))\n    avail = nb_available(from)\n    adv = min(avail, nb)\n    ccall(:memcpy, Ptr{Void}, (Ptr{Void}, Ptr{Void}, UInt), p, pointer(from.data, from.ptr), adv)\n    from.ptr += adv\n    if nb > avail\n        throw(EOFError())\n    end\n    p\nend\n\n@deprecate gc_enable() gc_enable(true)\n@deprecate gc_disable() gc_enable(false)\n\n@deprecate stop_timer close\n\nfunction Timer(f::Function)\n    error(\"Timer(f) is deprecated. Use Timer(f, delay, repeat) instead.\")\nend\n\nfunction start_timer(t, d, r)\n    error(\"start_timer is deprecated. Use Timer(callback, delay, repeat) instead.\")\nend\n\n@deprecate_binding UnionType Union\n\n@deprecate_binding MathConst Irrational\n\nmacro math_const(sym, val, def)\n    depwarn(\"@math_const is deprecated and renamed to @irrational.\", symbol(\"@math_const\"))\n    :(@irrational $(esc(sym)) $(esc(val)) $(esc(def)))\nend\nexport @math_const\n\n# 11280, mmap\n\nexport msync\nmsync{T}(A::Array{T}) = msync(pointer(A), length(A)*sizeof(T))\nmsync(B::BitArray) = msync(pointer(B.chunks), length(B.chunks)*sizeof(UInt64))\n\n@unix_only begin\nexport mmap\n@noinline function mmap(len::Integer, prot::Integer, flags::Integer, fd, offset::Integer)\n    depwarn(\"`mmap` is deprecated, use `Mmap.mmap(io, Array{T,N}, dims, offset)` instead to return an mmapped-array\", :mmap)\n    const pagesize::Int = ccall(:jl_getpagesize, Clong, ())\n    # Check that none of the computations will overflow\n    if len < 0\n        throw(ArgumentError(\"requested size must be \u2265 0, got $len\"))\n    end\n    if len > typemax(Int)-pagesize\n        throw(ArgumentError(\"requested size must be \u2264 $(typemax(Int)-pagesize), got $len\"))\n    end\n    # Set the offset to a page boundary\n    offset_page::FileOffset = floor(Integer,offset/pagesize)*pagesize\n    len_page::Int = (offset-offset_page) + len\n    # Mmap the file\n    p = ccall(:jl_mmap, Ptr{Void}, (Ptr{Void}, Csize_t, Cint, Cint, Cint, FileOffset), C_NULL, len_page, prot, flags, fd, offset_page)\n    systemerror(\"memory mapping failed\", reinterpret(Int,p) == -1)\n    # Also return a pointer that compensates for any adjustment in the offset\n    return p, Int(offset-offset_page)\nend\n\n@noinline function munmap(p::Ptr,len::Integer)\n    depwarn(\"`munmap` is deprecated, `mmap` Arrays are automatically munmapped when finalized\", :munmap)\n    systemerror(\"munmap\", ccall(:munmap,Cint,(Ptr{Void},Int),p,len) != 0)\nend\n\nconst MS_ASYNC = 1\nconst MS_INVALIDATE = 2\nconst MS_SYNC = 4\n@noinline function msync(p::Ptr, len::Integer, flags::Integer=MS_SYNC)\n    depwarn(\"`msync` is deprecated, use `Mmap.sync!(array)` instead\", :msync)\n    systemerror(\"msync\", ccall(:msync, Cint, (Ptr{Void}, Csize_t, Cint), p, len, flags) != 0)\nend\nend\n\n\n@windows_only begin\n@noinline function munmap(viewhandle::Ptr, mmaphandle::Ptr)\n    depwarn(\"`munmap` is deprecated, `mmap` Arrays are automatically munmapped when finalized\", :munmap)\n    status = ccall(:UnmapViewOfFile, stdcall, Cint, (Ptr{Void},), viewhandle)!=0\n    status |= ccall(:CloseHandle, stdcall, Cint, (Ptr{Void},), mmaphandle)!=0\n    if !status\n        error(\"could not unmap view: $(Libc.FormatMessage())\")\n    end\nend\n\n@noinline function msync(p::Ptr, len::Integer)\n    depwarn(\"`msync` is deprecated, use `Mmap.sync!(array)` instead\", :msync)\n    status = ccall(:FlushViewOfFile, stdcall, Cint, (Ptr{Void}, Csize_t), p, len)!=0\n    if !status\n        error(\"could not msync: $(Libc.FormatMessage())\")\n    end\nend\n\nend\n\n@unix_only @deprecate mmap_array{T,N}(::Type{T}, dims::NTuple{N,Integer}, s::IO, offset=position(s)) Mmap.mmap(s, Array{T,N}, dims, offset)\n\n@windows_only begin\ntype SharedMemSpec\n    name :: AbstractString\n    readonly :: Bool\n    create :: Bool\nend\nexport mmap_array\n@noinline function mmap_array{T,N}(::Type{T}, dims::NTuple{N,Integer}, s::Union{IO,SharedMemSpec}, offset::FileOffset)\n    depwarn(\"`mmap_array` is deprecated, use `Mmap.mmap(io, Array{T,N}, dims, offset)` instead to return an mmapped-array\", :mmap_array)\n    if isa(s,SharedMemSpec)\n        a = Mmap.Anonymous(s.name, s.readonly, s.create)\n    else\n        a = s\n    end\n    return Mmap.mmap(a, Array{T,N}, dims, offset)\nend\nend\n\n@deprecate mmap_bitarray{N}(::Type{Bool}, dims::NTuple{N,Integer}, s::IOStream, offset::FileOffset=position(s)) mmap(s, BitArray, dims, offset)\n@deprecate mmap_bitarray{N}(dims::NTuple{N,Integer}, s::IOStream, offset=position(s)) mmap(s, BitArray, dims, offset)\n\n# T[a:b] and T[a:s:b]\n@noinline function getindex{T<:Union{Char,Number}}(::Type{T}, r::Range)\n    depwarn(\"T[a:b] concatenation is deprecated; use T[a:b;] instead\", :getindex)\n    copy!(Array(T,length(r)), r)\nend\n\n@noinline function getindex{T<:Union{Char,Number}}(::Type{T}, r1::Range, rs::Range...)\n    depwarn(\"T[a:b,...] concatenation is deprecated; use T[a:b;...] instead\", :getindex)\n    a = Array(T,length(r1)+sum(length,rs))\n    o = 1\n    copy!(a, o, r1)\n    o += length(r1)\n    for r in rs\n        copy!(a, o, r)\n        o += length(r)\n    end\n    return a\nend\n\n## require ##\n\nfunction maybe_require_file(name::AbstractString)\n    isabspath(name) && return name\n    isfile(name) && return abspath(name)\n    if !endswith(name,\".jl\")\n        fname = string(name,\".jl\")\n        isfile(fname) && return abspath(fname)\n    end\n    return name\nend\n\ninclude(\"require.jl\")\n@noinline function require(f::AbstractString)\n    depwarn(\"`require` is deprecated, use `using` or `import` instead\", :require)\n    if endswith(f,\".jl\") || contains(f,path_separator)\n        # specifying file path\n        OldRequire.require(f)\n    else\n        # require(\"Foo\") --- ambiguous. might be file or package\n        filename = maybe_require_file(f)\n        if filename == f\n            mod = symbol(require_modname(f))\n            M = current_module()\n            if isdefined(M,mod) && isa(eval(M,mod),Module)\n                return\n            end\n            require(mod)\n        else\n            OldRequire.require(f)\n        end\n    end\nend\n@noinline function require(f::AbstractString, fs::AbstractString...)\n    require(f)\n    for fn in fs\n        require(fn)\n    end\nend\nexport require\n\n## ropes for efficient concatenation, etc. ##\n\nimmutable RopeString <: AbstractString\n    head::AbstractString\n    tail::AbstractString\n    depth::Int32\n    endof::Int\n\n    @inline function _new(h, t, d, e)\n        depwarn(\"`RopeString` is deprecated, use `string` instead\", :RopeString)\n        new(h, t, d, e)\n    end\n\n    @noinline RopeString(h::RopeString, t::RopeString) =\n        strdepth(h.tail) + strdepth(t) < strdepth(h.head) ?\n            RopeString(h.head, RopeString(h.tail, t)) :\n            _new(h, t, max(h.depth,t.depth)+1, endof(h)+endof(t))\n\n    @noinline RopeString(h::RopeString, t::AbstractString) =\n        strdepth(h.tail) < strdepth(h.head) ?\n            RopeString(h.head, RopeString(h.tail, t)) :\n            _new(h, t, h.depth+1, endof(h)+endof(t))\n\n    @noinline RopeString(h::AbstractString, t::RopeString) =\n        strdepth(t.head) < strdepth(t.tail) ?\n            RopeString(RopeString(h, t.head), t.tail) :\n            _new(h, t, t.depth+1, endof(h)+endof(t))\n\n    @noinline RopeString(h::AbstractString, t::AbstractString) =\n        _new(h, t, 1, endof(h)+endof(t))\nend\nRopeString(s::AbstractString) = RopeString(s,\"\")\n\nstrdepth(s::AbstractString) = 0\nstrdepth(s::RopeString) = s.depth\n\nfunction next(s::RopeString, i::Int)\n    eh = endof(s.head)\n    if i <= eh\n        return next(s.head, i)\n    else\n        c, j = next(s.tail, i-eh)\n        return c, j+eh\n    end\nend\n\nendof(s::RopeString) = s.endof\nlength(s::RopeString) = length(s.head) + length(s.tail)\nwrite(io::IO, s::RopeString) = (write(io, s.head); write(io, s.tail))\nsizeof(s::RopeString) = sizeof(s.head) + sizeof(s.tail)\n\nexport RopeString\n\n@noinline function complement!(s::IntSet)\n    depwarn(\"complement IntSets are deprecated\", :complement!);\n    for n = 1:length(s.bits)\n        s.bits[n] = ~s.bits[n]\n    end\n    s.fill1s = !s.fill1s\n    s\nend\n@noinline complement(s::IntSet) = complement!(copy(s))\nexport complement, complement!\n\n\n# 11774\n# when removing these deprecations, move them to reduce.jl, remove the depwarns and uncomment the errors.\n\nnonboolean_warning(f, op, status) = \"\"\"\n\n    Using non-boolean collections with $f(itr) is $status, use reduce($op, itr) instead.\n    If you are using $f(map(f, itr)) or $f([f(x) for x in itr]), use $f(f, itr) instead.\n\"\"\"\n\n\n@noinline function nonboolean_any(itr)\n    depwarn(nonboolean_warning(:any, :|, \"deprecated\"), :nonboolean_any)\n    #throw(ArgumentError(nonboolean_warning(:any, :|, \"not supported\")))\n    reduce(|, itr)\nend\n\n@noinline function nonboolean_all(itr)\n    depwarn(nonboolean_warning(:all, :&, \"deprecated\"), :nonboolean_all)\n    #throw(ArgumentError(nonboolean_warning(:all, :&, \"not supported\")))\n    reduce(&, itr)\nend\n\n@deprecate iseltype(x,T)  eltype(x) <: T\n\n@deprecate_binding FloatingPoint AbstractFloat\n\n# 11447\n\n@noinline function Regex(pattern::AbstractString, options::Integer)\n    flags = string([opt & options != 0? flag : \"\"\n        for (opt,flag) in [\n            (PCRE.CASELESS,  \"i\"),\n            (PCRE.MULTILINE, \"m\"),\n            (PCRE.DOTALL,    \"s\"),\n            (PCRE.EXTENDED,  \"x\")\n        ]\n    ]...)\n    depwarn(\"Constructing regexes with integer flags is deprecated, \"*\n            \"use string flags instead: Regex(\\\"$pattern\\\", \\\"$flags\\\").\", :Regex)\n    Regex(pattern, flags)\nend\n\n@deprecate cartesianmap(f, dims) for idx in CartesianRange(dims); f(idx.I...); end\n\n@deprecate Union(args...) Union{args...}\n\n# 12839\nconst AsyncStream = IO\ndeprecate(:AsyncStream)\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/base/sparse/cholmod.jl": "# This file is a part of Julia. License is MIT: http://julialang.org/license\n\nmodule CHOLMOD\n\nimport Base: (*), convert, copy, eltype, get, getindex, show, showarray, size,\n             linearindexing, LinearFast, LinearSlow, ctranspose\n\nimport Base.LinAlg: (\\), A_mul_Bc, A_mul_Bt, Ac_ldiv_B, Ac_mul_B, At_ldiv_B, At_mul_B,\n                 cholfact, det, diag, ishermitian, isposdef,\n                 issym, ldltfact, logdet\n\nimport Base.SparseMatrix: sparse, nnz\n\nexport\n    Dense,\n    Factor,\n    Sparse\n\nusing Base.SparseMatrix: AbstractSparseMatrix, SparseMatrixCSC, increment, indtype\n\n#########\n# Setup #\n#########\n\ninclude(\"cholmod_h.jl\")\n\nconst CHOLMOD_MIN_VERSION = v\"2.1.1\"\n\n### These offsets are defined in SuiteSparse_wrapper.c\nconst common_size = ccall((:jl_cholmod_common_size,:libsuitesparse_wrapper),Int,())\n\nconst cholmod_com_offsets = Array(Csize_t, 19)\nccall((:jl_cholmod_common_offsets, :libsuitesparse_wrapper),\n    Void, (Ptr{Csize_t},), cholmod_com_offsets)\n\n## macro to generate the name of the C function according to the integer type\nmacro cholmod_name(nm,typ) string(\"cholmod_\", eval(typ) == SuiteSparse_long ? \"l_\" : \"\", nm) end\n\nfunction start(a::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"start\", SuiteSparse_long), :libcholmod),\n        Cint, (Ptr{UInt8},), a)\n    return a\nend\n\nfunction finish(a::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"finish\", SuiteSparse_long), :libcholmod),\n        Cint, (Ptr{UInt8},), a)\n    return a\nend\n\nfunction defaults(a::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"defaults\", SuiteSparse_long), :libcholmod),\n        Cint, (Ptr{UInt8},), a)\n    return a\nend\n\ncommon() = commonStruct\n\nconst build_version_array = Array(Cint, 3)\nccall((:jl_cholmod_version, :libsuitesparse_wrapper), Cint, (Ptr{Cint},), build_version_array)\nconst build_version = VersionNumber(build_version_array...)\n\nfunction __init__()\n    try\n        ### Check if the linked library is compatible with the Julia code\n        if Libdl.dlsym_e(Libdl.dlopen(\"libcholmod\"), :cholmod_version) != C_NULL\n            current_version_array = Array(Cint, 3)\n            ccall((:cholmod_version, :libcholmod), Cint, (Ptr{Cint},), current_version_array)\n            current_version = VersionNumber(current_version_array...)\n        else # CHOLMOD < 2.1.1 does not include cholmod_version()\n            current_version = v\"0.0.0\"\n        end\n\n\n        if current_version < CHOLMOD_MIN_VERSION\n            warn(\"\"\"\n\n                CHOLMOD version incompatibility\n\n                Julia was compiled with CHOLMOD version $build_version. It is\n                currently linked with a version older than\n                $(CHOLMOD_MIN_VERSION). This might cause Julia to\n                terminate when working with sparse matrix factorizations,\n                e.g. solving systems of equations with \\\\.\n\n                It is recommended that you use Julia with a recent version\n                of CHOLMOD, or download the generic binaries\n                from www.julialang.org, which ship with the correct\n                versions of all dependencies.\n            \"\"\")\n        elseif build_version_array[1] != current_version_array[1]\n            warn(\"\"\"\n\n                CHOLMOD version incompatibility\n\n                Julia was compiled with CHOLMOD version $build_version. It is\n                currently linked with version $current_version.\n                This might cause Julia to terminate when working with\n                sparse matrix factorizations, e.g. solving systems of\n                equations with \\\\.\n\n                It is recommended that you use Julia with the same major\n                version of CHOLMOD as the one used during the build, or\n                download the generic binaries from www.julialang.org,\n                which ship with the correct versions of all dependencies.\n            \"\"\")\n        end\n\n        intsize = Int(ccall((:jl_cholmod_sizeof_long,:libsuitesparse_wrapper),Csize_t,()))\n        if intsize != 4length(IndexTypes)\n            warn(\"\"\"\n\n                 CHOLMOD integer size incompatibility\n\n                 Julia was compiled with a version of CHOLMOD that\n                 supported $(32length(IndexTypes)) bit integers. It is\n                 currently linked with version that supports $(8intsize)\n                 integers. This might cause Julia to terminate when\n                 working with sparse matrix factorizations, e.g. solving\n                 systems of equations with \\\\.\n\n                 This problem can be fixed by modifying the Julia build\n                 configuration or by downloading the OS X or generic\n                 Linux binary from www.julialang.org, which include\n                 the correct versions of all dependencies.\n             \"\"\")\n        end\n\n        ### Initiate CHOLMOD\n        ### The common struct. Controls the type of factorization and keeps pointers\n        ### to temporary memory.\n        global const commonStruct = fill(0xff, common_size)\n\n        global const common_supernodal =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[4] + 1))\n        global const common_final_ll =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[7] + 1))\n        global const common_print =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[13] + 1))\n        global const common_itype =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[18] + 1))\n        global const common_dtype =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[19] + 1))\n        global const common_nmethods =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[15] + 1))\n        global const common_postorder =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[17] + 1))\n\n        start(commonStruct)              # initializes CHOLMOD\n        set_print_level(commonStruct, 0) # no printing from CHOLMOD by default\n\n        # Register gc tracked allocator if CHOLMOD is new enough\n        if current_version >= v\"3.0.0\"\n            cnfg = cglobal((:SuiteSparse_config, :libsuitesparseconfig), Ptr{Void})\n            unsafe_store!(cnfg, cglobal(:jl_malloc, Ptr{Void}), 1)\n            unsafe_store!(cnfg, cglobal(:jl_calloc, Ptr{Void}), 2)\n            unsafe_store!(cnfg, cglobal(:jl_realloc, Ptr{Void}), 3)\n            unsafe_store!(cnfg, cglobal(:jl_free, Ptr{Void}), 4)\n        end\n\n    catch ex\n        Base.showerror_nostdio(ex,\n            \"WARNING: Error during initialization of module CHOLMOD\")\n    end\nend\n\nfunction set_print_level(cm::Array{UInt8}, lev::Integer)\n    global common_print\n    unsafe_store!(common_print, lev)\nend\n\n####################\n# Type definitions #\n####################\n\nabstract SuiteSparseStruct\n\n# The three core data types for CHOLMOD: Dense, Sparse and Factor.\n# CHOLMOD manages the memory, so the Julia versions only wrap a\n# pointer to a struct.  Therefore finalizers should be registered each\n# time a pointer is returned from CHOLMOD.\n\n# Dense\nimmutable C_Dense{T<:VTypes} <: SuiteSparseStruct\n    nrow::Csize_t\n    ncol::Csize_t\n    nzmax::Csize_t\n    d::Csize_t\n    x::Ptr{T}\n    z::Ptr{Void}\n    xtype::Cint\n    dtype::Cint\nend\n\ntype Dense{T<:VTypes} <: DenseMatrix{T}\n    p::Ptr{C_Dense{T}}\nend\n\n# Sparse\nimmutable C_Sparse{Tv<:VTypes} <: SuiteSparseStruct\n    nrow::Csize_t\n    ncol::Csize_t\n    nzmax::Csize_t\n    p::Ptr{SuiteSparse_long}\n    i::Ptr{SuiteSparse_long}\n    nz::Ptr{SuiteSparse_long}\n    x::Ptr{Tv}\n    z::Ptr{Void}\n    stype::Cint\n    itype::Cint\n    xtype::Cint\n    dtype::Cint\n    sorted::Cint\n    packed::Cint\nend\n\n# Corresponds to the exact definition of cholmod_sparse_struct in the library.\n# Useful when reading matrices of unknown type from files as in\n# cholmod_read_sparse\nimmutable C_SparseVoid <: SuiteSparseStruct\n    nrow::Csize_t\n    ncol::Csize_t\n    nzmax::Csize_t\n    p::Ptr{Void}\n    i::Ptr{Void}\n    nz::Ptr{Void}\n    x::Ptr{Void}\n    z::Ptr{Void}\n    stype::Cint\n    itype::Cint\n    xtype::Cint\n    dtype::Cint\n    sorted::Cint\n    packed::Cint\nend\n\ntype Sparse{Tv<:VTypes} <: AbstractSparseMatrix{Tv,SuiteSparse_long}\n    p::Ptr{C_Sparse{Tv}}\n    function Sparse(p::Ptr{C_Sparse{Tv}})\n        if p == C_NULL\n            throw(ArgumentError(\"sparse matrix construction failed for unknown reasons. Please submit a bug report.\"))\n        end\n        new(p)\n    end\nend\nSparse{Tv<:VTypes}(p::Ptr{C_Sparse{Tv}}) = Sparse{Tv}(p)\n\n# Factor\n\nif build_version >= v\"2.1.0\" # CHOLMOD version 2.1.0 or later\n    immutable C_Factor{Tv<:VTypes} <: SuiteSparseStruct\n        n::Csize_t\n        minor::Csize_t\n        Perm::Ptr{SuiteSparse_long}\n        ColCount::Ptr{SuiteSparse_long}\n        IPerm::Ptr{SuiteSparse_long}        # this pointer was added in verison 2.1.0\n        nzmax::Csize_t\n        p::Ptr{SuiteSparse_long}\n        i::Ptr{SuiteSparse_long}\n        x::Ptr{Tv}\n        z::Ptr{Void}\n        nz::Ptr{SuiteSparse_long}\n        next::Ptr{SuiteSparse_long}\n        prev::Ptr{SuiteSparse_long}\n        nsuper::Csize_t\n        ssize::Csize_t\n        xsize::Csize_t\n        maxcsize::Csize_t\n        maxesize::Csize_t\n        super::Ptr{SuiteSparse_long}\n        pi::Ptr{SuiteSparse_long}\n        px::Ptr{SuiteSparse_long}\n        s::Ptr{SuiteSparse_long}\n        ordering::Cint\n        is_ll::Cint\n        is_super::Cint\n        is_monotonic::Cint\n        itype::Cint\n        xtype::Cint\n        dtype::Cint\n    end\nelse\n    immutable C_Factor{Tv<:VTypes} <: SuiteSparseStruct\n        n::Csize_t\n        minor::Csize_t\n        Perm::Ptr{SuiteSparse_long}\n        ColCount::Ptr{SuiteSparse_long}\n        nzmax::Csize_t\n        p::Ptr{SuiteSparse_long}\n        i::Ptr{SuiteSparse_long}\n        x::Ptr{Tv}\n        z::Ptr{Void}\n        nz::Ptr{SuiteSparse_long}\n        next::Ptr{SuiteSparse_long}\n        prev::Ptr{SuiteSparse_long}\n        nsuper::Csize_t\n        ssize::Csize_t\n        xsize::Csize_t\n        maxcsize::Csize_t\n        maxesize::Csize_t\n        super::Ptr{SuiteSparse_long}\n        pi::Ptr{SuiteSparse_long}\n        px::Ptr{SuiteSparse_long}\n        s::Ptr{SuiteSparse_long}\n        ordering::Cint\n        is_ll::Cint\n        is_super::Cint\n        is_monotonic::Cint\n        itype::Cint\n        xtype::Cint\n        dtype::Cint\n    end\nend\n\ntype Factor{Tv} <: Factorization{Tv}\n    p::Ptr{C_Factor{Tv}}\n    function Factor(p::Ptr{C_Factor{Tv}})\n        if p == C_NULL\n            throw(ArgumentError(\"factorization construction failed for unknown reasons. Please submit a bug report.\"))\n        end\n        new(p)\n    end\nend\nFactor{Tv<:VTypes}(p::Ptr{C_Factor{Tv}}) = Factor{Tv}(p)\n\n# Define get similar to get(Nullable) to check pointers. All pointer loads should be wrapped in get to make sure\n# that SuiteSparse is not called with a C_NULL pointer which could cause a segfault. Pointers are set to null\n# when serialized so this can happen when mutiple processes are in use.\nfunction get{T<:SuiteSparseStruct}(p::Ptr{T})\n    if p == C_NULL\n        throw(ArgumentError(\"pointer to the $T object is null. This can happen if the object has been serialized.\"))\n    else\n        return p\n    end\nend\n\n# FactorComponent, for encoding particular factors from a factorization\ntype FactorComponent{Tv,S} <: AbstractMatrix{Tv}\n    F::Factor{Tv}\n\n    function FactorComponent(F::Factor{Tv})\n        s = unsafe_load(get(F.p))\n        if s.is_ll != 0\n            S == :L || S == :U || S == :PtL || S == :UP || throw(CHOLMODException(string(S, \" not supported for sparse LLt matrices; try :L, :U, :PtL, or :UP\")))\n        else\n            S == :L || S == :U || S == :PtL || S == :UP ||\n            S == :D || S == :LD || S == :DU || S == :PtLD || S == :DUP ||\n            throw(CHOLMODException(string(S, \" not supported for sparse LDLt matrices; try :L, :U, :PtL, :UP, :D, :LD, :DU, :PtLD, or :DUP\")))\n        end\n        new(F)\n    end\nend\nfunction FactorComponent{Tv}(F::Factor{Tv}, sym::Symbol)\n    FactorComponent{Tv,sym}(F)\nend\n\nFactor(FC::FactorComponent) = Factor(FC.F)\n\n#################\n# Thin wrappers #\n#################\n\n# Dense wrappers\n## Note! Integer type defaults to Cint, but this is actually not necessary, but\n## making this a choice would require another type parameter in the Dense type\n\n### cholmod_core_h ###\nfunction allocate_dense(nrow::Integer, ncol::Integer, d::Integer, ::Type{Float64})\n    d = Dense(ccall((:cholmod_l_allocate_dense, :libcholmod), Ptr{C_Dense{Float64}},\n        (Csize_t, Csize_t, Csize_t, Cint, Ptr{Void}),\n        nrow, ncol, d, REAL, common()))\n    finalizer(d, free!)\n    d\nend\nfunction allocate_dense(nrow::Integer, ncol::Integer, d::Integer, ::Type{Complex{Float64}})\n    d = Dense(ccall((:cholmod_l_allocate_dense, :libcholmod), Ptr{C_Dense{Complex{Float64}}},\n        (Csize_t, Csize_t, Csize_t, Cint, Ptr{Void}),\n        nrow, ncol, d, COMPLEX, common()))\n    finalizer(d, free!)\n    d\nend\n\nfree_dense!{T}(p::Ptr{C_Dense{T}}) = ccall((:cholmod_l_free_dense, :libcholmod), Cint, (Ref{Ptr{C_Dense{T}}}, Ptr{Void}), p, common())\n\nfunction zeros{T<:VTypes}(m::Integer, n::Integer, ::Type{T})\n    d = Dense(ccall((:cholmod_l_zeros, :libcholmod), Ptr{C_Dense{T}},\n        (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n         m, n, xtyp(T), common()))\n    finalizer(d, free!)\n    d\nend\nzeros(m::Integer, n::Integer) = zeros(m, n, Float64)\n\nfunction ones{T<:VTypes}(m::Integer, n::Integer, ::Type{T})\n    d = Dense(ccall((:cholmod_l_ones, :libcholmod), Ptr{C_Dense{T}},\n        (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n         m, n, xtyp(T), common()))\n    finalizer(d, free!)\n    d\nend\nones(m::Integer, n::Integer) = ones(m, n, Float64)\n\nfunction eye{T<:VTypes}(m::Integer, n::Integer, ::Type{T})\n    d = Dense(ccall((:cholmod_l_eye, :libcholmod), Ptr{C_Dense{T}},\n        (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n         m, n, xtyp(T), common()))\n    finalizer(d, free!)\n    d\nend\neye(m::Integer, n::Integer) = eye(m, n, Float64)\neye(n::Integer) = eye(n, n, Float64)\n\nfunction copy_dense{Tv<:VTypes}(A::Dense{Tv})\n    d = Dense(ccall((:cholmod_l_copy_dense, :libcholmod), Ptr{C_Dense{Tv}},\n        (Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n         get(A.p), common()))\n    finalizer(d, free!)\n    d\nend\n\n### cholmod_matrixops.h ###\nfunction norm_dense{Tv<:VTypes}(D::Dense{Tv}, p::Integer)\n    s = unsafe_load(get(D.p))\n    if p == 2\n        if s.ncol > 1\n            throw(ArgumentError(\"2 norm only supported when matrix has one column\"))\n        end\n    elseif p != 0 && p != 1\n        throw(ArgumentError(\"second argument must be either 0 (Inf norm), 1, or 2\"))\n    end\n    ccall((:cholmod_l_norm_dense, :libcholmod), Cdouble,\n        (Ptr{C_Dense{Tv}}, Cint, Ptr{UInt8}),\n          get(D.p), p, common())\nend\n\n### cholmod_check.h ###\nfunction check_dense{T<:VTypes}(A::Dense{T})\n    ccall((:cholmod_l_check_dense, :libcholmod), Cint,\n          (Ptr{C_Dense{T}}, Ptr{UInt8}),\n          A.p, common())!=0\nend\n\n# Non-Dense wrappers\n### cholmod_core.h ###\nfunction allocate_sparse(nrow::Integer, ncol::Integer, nzmax::Integer, sorted::Bool, packed::Bool, stype::Integer, ::Type{Float64})\n    s = Sparse(ccall((@cholmod_name(\"allocate_sparse\", SuiteSparse_long), :libcholmod), Ptr{C_Sparse{Float64}},\n            (Csize_t, Csize_t, Csize_t, Cint,\n                Cint, Cint, Cint, Ptr{Void}),\n            nrow, ncol, nzmax, sorted,\n                packed, stype, REAL, common()))\n    finalizer(s, free!)\n    s\nend\nfunction allocate_sparse(nrow::Integer, ncol::Integer, nzmax::Integer, sorted::Bool, packed::Bool, stype::Integer, ::Type{Complex{Float64}})\n    s = Sparse(ccall((@cholmod_name(\"allocate_sparse\", SuiteSparse_long), :libcholmod),\n            Ptr{C_Sparse{Complex{Float64}}},\n                (Csize_t, Csize_t, Csize_t, Cint,\n                 Cint, Cint, Cint, Ptr{Void}),\n                nrow, ncol, nzmax, sorted,\n                packed, stype, COMPLEX, common()))\n    finalizer(s, free!)\n    s\nend\nfunction free_sparse!{Tv<:VTypes}(ptr::Ptr{C_Sparse{Tv}})\n    @isok ccall((@cholmod_name(\"free_sparse\", SuiteSparse_long), :libcholmod), Cint,\n            (Ptr{Ptr{C_Sparse{Tv}}}, Ptr{UInt8}),\n                &ptr, common())\nend\n\nfunction free_sparse!(ptr::Ptr{C_SparseVoid})\n    @isok ccall((@cholmod_name(\"free_sparse\", SuiteSparse_long), :libcholmod), Cint,\n            (Ptr{Ptr{C_SparseVoid}}, Ptr{UInt8}),\n                &ptr, common())\nend\n\nfunction free_factor!{Tv<:VTypes}(ptr::Ptr{C_Factor{Tv}})\n    # Warning! Important that finalizer doesn't modify the global Common struct.\n    @isok ccall((@cholmod_name(\"free_factor\", SuiteSparse_long), :libcholmod), Cint,\n            (Ptr{Ptr{C_Factor{Tv}}}, Ptr{Void}),\n                &ptr, common())\nend\n\nfunction aat{Tv<:VRealTypes}(A::Sparse{Tv}, fset::Vector{SuiteSparse_long}, mode::Integer)\n    s = Sparse(ccall((@cholmod_name(\"aat\", SuiteSparse_long), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{SuiteSparse_long}, Csize_t, Cint, Ptr{UInt8}),\n                get(A.p), fset, length(fset), mode, common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction sparse_to_dense{Tv<:VTypes}(A::Sparse{Tv})\n    d = Dense(ccall((@cholmod_name(\"sparse_to_dense\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Dense{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                get(A.p), common()))\n    finalizer(d, free!)\n    d\nend\nfunction dense_to_sparse{Tv<:VTypes}(D::Dense{Tv}, ::Type{SuiteSparse_long})\n    s = Sparse(ccall((@cholmod_name(\"dense_to_sparse\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Dense{Tv}}, Cint, Ptr{UInt8}),\n                get(D.p), true, common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction factor_to_sparse!{Tv<:VTypes}(F::Factor{Tv})\n    ss = unsafe_load(F.p)\n    ss.xtype > PATTERN || throw(CHOLMODException(\"only numeric factors are supported\"))\n    s = Sparse(ccall((@cholmod_name(\"factor_to_sparse\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                get(F.p), common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction change_factor!{Tv<:VTypes}(::Type{Float64}, to_ll::Bool, to_super::Bool, to_packed::Bool, to_monotonic::Bool, F::Factor{Tv})\n    @isok ccall((@cholmod_name(\"change_factor\", SuiteSparse_long),:libcholmod), Cint,\n            (Cint, Cint, Cint, Cint, Cint, Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                REAL, to_ll, to_super, to_packed, to_monotonic, get(F.p), common())\n    Factor{Float64}(F.p)\nend\n\nfunction change_factor!{Tv<:VTypes}(::Type{Complex{Float64}}, to_ll::Bool, to_super::Bool, to_packed::Bool, to_monotonic::Bool, F::Factor{Tv})\n    @isok ccall((@cholmod_name(\"change_factor\", SuiteSparse_long),:libcholmod), Cint,\n            (Cint, Cint, Cint, Cint, Cint, Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                COMPLEX, to_ll, to_super, to_packed, to_monotonic, get(F.p), common())\n    Factor{Complex{Float64}}(F.p)\nend\n\nfunction check_sparse{Tv<:VTypes}(A::Sparse{Tv})\n    ccall((@cholmod_name(\"check_sparse\", SuiteSparse_long),:libcholmod), Cint,\n          (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n          get(A.p), common())!=0\nend\n\nfunction check_factor{Tv<:VTypes}(F::Factor{Tv})\n    ccall((@cholmod_name(\"check_factor\", SuiteSparse_long),:libcholmod), Cint,\n          (Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n          get(F.p), common())!=0\nend\n\nfunction nnz{Tv<:VTypes}(A::Sparse{Tv})\n    ccall((@cholmod_name(\"nnz\", SuiteSparse_long),:libcholmod), Int,\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                get(A.p), common())\nend\n\nfunction speye{Tv<:VTypes}(m::Integer, n::Integer, ::Type{Tv})\n    s = Sparse(ccall((@cholmod_name(\"speye\", SuiteSparse_long), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n                m, n, xtyp(Tv), common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction spzeros{Tv<:VTypes}(m::Integer, n::Integer, nzmax::Integer, ::Type{Tv})\n    s = Sparse(ccall((@cholmod_name(\"spzeros\", SuiteSparse_long), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Csize_t, Csize_t, Csize_t, Cint, Ptr{UInt8}),\n             m, n, nzmax, xtyp(Tv), common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction transpose_{Tv<:VTypes}(A::Sparse{Tv}, values::Integer)\n    s = Sparse(ccall((@cholmod_name(\"transpose\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n                get(A.p), values, common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction copy_factor{Tv<:VTypes}(F::Factor{Tv})\n    f = Factor(ccall((@cholmod_name(\"copy_factor\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Factor{Tv}},\n            (Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                get(F.p), common()))\n    finalizer(f, free!)\n    f\nend\nfunction copy_sparse{Tv<:VTypes}(A::Sparse{Tv})\n    s = Sparse(ccall((@cholmod_name(\"copy_sparse\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                get(A.p), common()))\n    finalizer(s, free!)\n    s\nend\nfunction copy{Tv<:VRealTypes}(A::Sparse{Tv}, stype::Integer, mode::Integer)\n    s = Sparse(ccall((@cholmod_name(\"copy\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Cint, Cint, Ptr{UInt8}),\n                get(A.p), stype, mode, common()))\n    finalizer(s, free!)\n    s\nend\n\n### cholmod_check.h ###\nfunction print_sparse{Tv<:VTypes}(A::Sparse{Tv}, name::ASCIIString)\n    cm = common()\n    set_print_level(cm, 3)\n    @isok ccall((@cholmod_name(\"print_sparse\", SuiteSparse_long),:libcholmod), Cint,\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}, Ptr{UInt8}),\n                 get(A.p), name, cm)\n    nothing\nend\nfunction print_factor{Tv<:VTypes}(F::Factor{Tv}, name::ASCIIString)\n    cm = common()\n    set_print_level(cm, 3)\n    @isok ccall((@cholmod_name(\"print_factor\", SuiteSparse_long),:libcholmod), Cint,\n            (Ptr{C_Factor{Tv}}, Ptr{UInt8}, Ptr{UInt8}),\n                get(F.p), name, cm)\n    nothing\nend\n\n### cholmod_matrixops.h ###\nfunction ssmult{Tv<:VRealTypes}(A::Sparse{Tv}, B::Sparse{Tv}, stype::Integer, values::Bool, sorted::Bool)\n    lA = unsafe_load(get(A.p))\n    lB = unsafe_load(get(B.p))\n    if lA.ncol != lB.nrow\n        throw(DimensionMismatch(\"inner matrix dimensions do not fit\"))\n    end\n    s = Sparse(ccall((@cholmod_name(\"ssmult\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{C_Sparse{Tv}}, Cint, Cint,\n                Cint, Ptr{UInt8}),\n             get(A.p), get(B.p), stype, values,\n                sorted, common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction norm_sparse{Tv<:VTypes}(A::Sparse{Tv}, norm::Integer)\n    if norm != 0 && norm != 1\n        throw(ArgumentError(\"norm argument must be either 0 or 1\"))\n    end\n    ccall((@cholmod_name(\"norm_sparse\", SuiteSparse_long), :libcholmod), Cdouble,\n            (Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n                get(A.p), norm, common())\nend\n\nfunction horzcat{Tv<:VRealTypes}(A::Sparse{Tv}, B::Sparse{Tv}, values::Bool)\n    s = Sparse(ccall((@cholmod_name(\"horzcat\", SuiteSparse_long), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n             get(A.p), get(B.p), values, common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction scale!{Tv<:VRealTypes}(S::Dense{Tv}, scale::Integer, A::Sparse{Tv})\n    sS = unsafe_load(get(S.p))\n    sA = unsafe_load(get(A.p))\n    sS.ncol == 1 || sS.nrow == 1 || throw(DimensionMismatch(\"first argument must be a vector\"))\n    if scale == SCALAR && sS.nrow != 1\n        throw(DimensionMismatch(\"scaling argument must have length one\"))\n    elseif scale == ROW && sS.nrow*sS.ncol != sA.nrow\n        throw(DimensionMismatch(\"scaling vector has length $(sS.nrow*sS.ncol), but matrix has $(sA.nrow) rows.\"))\n    elseif scale == COL && sS.nrow*sS.ncol != sA.ncol\n        throw(DimensionMismatch(\"scaling vector has length $(sS.nrow*sS.ncol), but matrix has $(sA.ncol) columns\"))\n    elseif scale == SYM\n        if sA.nrow != sA.ncol\n            throw(DimensionMismatch(\"matrix must be square\"))\n        elseif sS.nrow*sS.ncol != sA.nrow\n            throw(DimensionMismatch(\"scaling vector has length $(sS.nrow*sS.ncol), but matrix has $(sA.ncol) columns and rows\"))\n        end\n    end\n\n    sA = unsafe_load(get(A.p))\n    @isok ccall((@cholmod_name(\"scale\",SuiteSparse_long),:libcholmod), Cint,\n            (Ptr{C_Dense{Tv}}, Cint, Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                get(S.p), scale, get(A.p), common())\n    A\nend\n\nfunction sdmult!{Tv<:VTypes}(A::Sparse{Tv}, transpose::Bool, \u03b1::Number, \u03b2::Number, X::Dense{Tv}, Y::Dense{Tv})\n    m, n = size(A)\n    nc = transpose ? m : n\n    nr = transpose ? n : m\n    if nc != size(X, 1)\n        throw(DimensionMismatch(\"incompatible dimensions, $nc and $(size(X,1))\"))\n    end\n    @isok ccall((@cholmod_name(\"sdmult\", SuiteSparse_long),:libcholmod), Cint,\n            (Ptr{C_Sparse{Tv}}, Cint,\n             Ref{Complex128}, Ref{Complex128},\n             Ptr{C_Dense{Tv}}, Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n                get(A.p), transpose, \u03b1, \u03b2, get(X.p), get(Y.p), common())\n    Y\nend\n\nfunction vertcat{Tv<:VRealTypes}(A::Sparse{Tv}, B::Sparse{Tv}, values::Bool)\n    s = Sparse(ccall((@cholmod_name(\"vertcat\", SuiteSparse_long), :libcholmod), Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n                get(A.p), get(B.p), values, common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction symmetry{Tv<:VTypes}(A::Sparse{Tv}, option::Integer)\n    xmatched = Array(SuiteSparse_long, 1)\n    pmatched = Array(SuiteSparse_long, 1)\n    nzoffdiag = Array(SuiteSparse_long, 1)\n    nzdiag = Array(SuiteSparse_long, 1)\n    rv = ccall((@cholmod_name(\"symmetry\", SuiteSparse_long), :libcholmod), Cint,\n            (Ptr{C_Sparse{Tv}}, Cint, Ptr{SuiteSparse_long}, Ptr{SuiteSparse_long},\n                Ptr{SuiteSparse_long}, Ptr{SuiteSparse_long}, Ptr{UInt8}),\n                    get(A.p), option, xmatched, pmatched,\n                        nzoffdiag, nzdiag, common())\n    rv, xmatched[1], pmatched[1], nzoffdiag[1], nzdiag[1]\nend\n\n# cholmod_cholesky.h\n# For analyze, analyze_p, and factorize_p!, the Common argument must be\n# supplied in order to control if the factorization is LLt or LDLt\nfunction analyze{Tv<:VTypes}(A::Sparse{Tv}, cmmn::Vector{UInt8})\n    f = Factor(ccall((@cholmod_name(\"analyze\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Factor{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                get(A.p), cmmn))\n    finalizer(f, free!)\n    f\nend\nfunction analyze_p{Tv<:VTypes}(A::Sparse{Tv}, perm::Vector{SuiteSparse_long},\n    cmmn::Vector{UInt8})\n    length(perm) != size(A,1) && throw(BoundsError())\n    f = Factor(ccall((@cholmod_name(\"analyze_p\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Factor{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{SuiteSparse_long}, Ptr{SuiteSparse_long}, Csize_t, Ptr{UInt8}),\n                get(A.p), perm, C_NULL, 0, cmmn))\n    finalizer(f, free!)\n    f\nend\nfunction factorize!{Tv<:VTypes}(A::Sparse{Tv}, F::Factor{Tv}, cmmn::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"factorize\", SuiteSparse_long),:libcholmod), Cint,\n        (Ptr{C_Sparse{Tv}}, Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n            get(A.p), get(F.p), cmmn)\n    F\nend\nfunction factorize_p!{Tv<:VTypes}(A::Sparse{Tv}, \u03b2::Real, F::Factor{Tv}, cmmn::Vector{UInt8})\n    # note that \u03b2 is passed as a complex number (double beta[2]),\n    # but the CHOLMOD manual says that only beta[0] (real part) is used\n    @isok ccall((@cholmod_name(\"factorize_p\", SuiteSparse_long),:libcholmod), Cint,\n        (Ptr{C_Sparse{Tv}}, Ref{Complex128}, Ptr{SuiteSparse_long}, Csize_t,\n         Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n            get(A.p), \u03b2, C_NULL, 0, get(F.p), cmmn)\n    F\nend\n\nfunction solve{Tv<:VTypes}(sys::Integer, F::Factor{Tv}, B::Dense{Tv})\n    if size(F,1) != size(B,1)\n        throw(DimensionMismatch(\"LHS and RHS should have the same number of rows. LHS has $(size(F,1)) rows, but RHS has $(size(B,1)) rows.\"))\n    end\n    d = Dense(ccall((@cholmod_name(\"solve\", SuiteSparse_long),:libcholmod), Ptr{C_Dense{Tv}},\n            (Cint, Ptr{C_Factor{Tv}}, Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n                sys, get(F.p), get(B.p), common()))\n    finalizer(d, free!)\n    d\nend\n\nfunction spsolve{Tv<:VTypes}(sys::Integer, F::Factor{Tv}, B::Sparse{Tv})\n    if size(F,1) != size(B,1)\n        throw(DimensionMismatch(\"LHS and RHS should have the same number of rows. LHS has $(size(F,1)) rows, but RHS has $(size(B,1)) rows.\"))\n    end\n    s = Sparse(ccall((@cholmod_name(\"spsolve\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Cint, Ptr{C_Factor{Tv}}, Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                sys, get(F.p), get(B.p), common()))\n    finalizer(s, free!)\n    s\nend\n\n# Autodetects the types\nfunction read_sparse(file::Libc.FILE, ::Type{SuiteSparse_long})\n    ptr = ccall((@cholmod_name(\"read_sparse\", SuiteSparse_long), :libcholmod),\n        Ptr{C_SparseVoid},\n            (Ptr{Void}, Ptr{UInt8}),\n                file.ptr, common())\n    if ptr == C_NULL\n        throw(ArgumentError(\"sparse matrix construction failed. Check that input file is valid.\"))\n    end\n    s = Sparse(ptr)\n    finalizer(s, free!)\n    s\nend\n\nfunction read_sparse(file::IO, T)\n    cfile = Libc.FILE(file)\n    try return read_sparse(cfile, T)\n    finally close(cfile)\n    end\nend\n\nfunction get_perm(F::Factor)\n    s = unsafe_load(get(F.p))\n    p = pointer_to_array(s.Perm, s.n, false)\n    p+1\nend\nget_perm(FC::FactorComponent) = get_perm(Factor(FC))\n\n#########################\n# High level interfaces #\n#########################\n\n# Convertion/construction\nfunction convert(::Type{Dense}, A::VecOrMat)\n    T = promote_type(eltype(A), Float64)\n    d = allocate_dense(size(A, 1), size(A, 2), stride(A, 2), T)\n    s = unsafe_load(d.p)\n    for i in eachindex(A)\n        unsafe_store!(s.x, A[i], i)\n    end\n    d\nend\nconvert(::Type{Dense}, A::Sparse) = sparse_to_dense(A)\n\n# This constructior assumes zero based colptr and rowval\nfunction convert{Tv<:VTypes}(::Type{Sparse}, m::Integer, n::Integer, colptr::Vector{SuiteSparse_long}, rowval::Vector{SuiteSparse_long}, nzval::Vector{Tv}, stype)\n\n    # check if columns are sorted\n    iss = true\n    for i = 2:length(colptr)\n        if !issorted(sub(rowval, colptr[i - 1] + 1:colptr[i]))\n            iss = false\n            break\n        end\n    end\n\n    o = allocate_sparse(m, n, length(nzval), iss, true, stype, Tv)\n    s = unsafe_load(o.p)\n\n    unsafe_copy!(s.p, pointer(colptr), length(colptr))\n    unsafe_copy!(s.i, pointer(rowval), length(rowval))\n    unsafe_copy!(s.x, pointer(nzval), length(nzval))\n\n    @isok check_sparse(o)\n\n    return o\n\nend\nfunction convert{Tv<:VTypes}(::Type{Sparse}, m::Integer, n::Integer, colptr::Vector{SuiteSparse_long}, rowval::Vector{SuiteSparse_long}, nzval::Vector{Tv})\n    o = Sparse(m, n, colptr, rowval, nzval, 0)\n\n    # check if array is symmetric and change stype if it is\n    if ishermitian(o)\n        change_stype!(o, -1)\n    end\n    o\nend\n\nfunction convert{Tv<:VTypes}(::Type{Sparse}, A::SparseMatrixCSC{Tv,SuiteSparse_long}, stype::Integer)\n    o = allocate_sparse(A.m, A.n, length(A.nzval), true, true, stype, Tv)\n    s = unsafe_load(o.p)\n    for i = 1:length(A.colptr)\n        unsafe_store!(s.p, A.colptr[i] - 1, i)\n    end\n    for i = 1:length(A.rowval)\n        unsafe_store!(s.i, A.rowval[i] - 1, i)\n    end\n    unsafe_copy!(s.x, pointer(A.nzval), length(A.nzval))\n\n    @isok check_sparse(o)\n\n    return o\nend\n\nfunction convert{Tv<:VTypes,Ti<:ITypes}(::Type{Sparse}, A::SparseMatrixCSC{Tv,Ti})\n    o = Sparse(A, 0)\n    # check if array is symmetric and change stype if it is\n    if ishermitian(o)\n        change_stype!(o, -1)\n    end\n    o\nend\nconvert{Ti<:ITypes}(::Type{Sparse}, A::SparseMatrixCSC{Float32,Ti}) = convert(Sparse, convert(SparseMatrixCSC{Float64,SuiteSparse_long}, A))\nconvert{Ti<:ITypes}(::Type{Sparse}, A::SparseMatrixCSC{Complex{Float32},Ti}) = convert(Sparse, convert(SparseMatrixCSC{Complex{Float64},SuiteSparse_long}, A))\nconvert(::Type{Sparse}, A::Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}) = Sparse(A.data, A.uplo == 'L' ? -1 : 1)\nconvert{Tv<:VTypes}(::Type{Sparse}, A::Hermitian{Tv,SparseMatrixCSC{Tv,SuiteSparse_long}}) = Sparse(A.data, A.uplo == 'L' ? -1 : 1)\nfunction convert{T,Ti<:ITypes}(::Type{Sparse},\n    A::Union{SparseMatrixCSC{T,Ti},\n             Symmetric{T,SparseMatrixCSC{T,Ti}},\n             Hermitian{T,SparseMatrixCSC{T,Ti}}},\n    args...)\n    return Sparse(float(A), args...)\nend\n\n# Useful when reading in files, but not type stable\nfunction convert(::Type{Sparse}, p::Ptr{C_SparseVoid})\n\n    if p == C_NULL\n        throw(ArgumentError(\"sparse matrix construction failed for unknown reasons. Please submit a bug report.\"))\n    end\n\n    s = unsafe_load(p)\n\n    # Check integer type\n    if s.itype == INT\n        free_sparse!(p)\n        throw(CHOLMODException(\"the value of itype was $s.itype. Only integer type of $SuiteSparse_long is supported.\"))\n    elseif s.itype == INTLONG\n        free_sparse!(p)\n        throw(CHOLMODException(\"the value of itype was $s.itype. This combination of integer types shouldn't happen. Please submit a bug report.\"))\n    elseif s.itype != LONG # must be s.itype == LONG\n        free_sparse!(p)\n        throw(CHOLMODException(\"illegal value of itype: $s.itype\"))\n    end\n\n    # Check for double or single precision\n    if s.dtype == DOUBLE\n        Tv = Float64\n    elseif s.dtype == SINGLE\n        # Tv = Float32 # this should be supported at some point\n        free_sparse!(p)\n        throw(CHOLMODException(\"single precision not supported yet\"))\n    else\n        free_sparse!(p)\n        throw(CHOLMODException(\"illegal value of dtype: $s.dtype\"))\n    end\n\n    # Check for real or complex\n    if s.xtype == COMPLEX\n        Tv = Complex{Tv}\n    elseif s.xtype != REAL\n        free_sparse!(p)\n        throw(CHOLMODException(\"illegal value of xtype: $s.xtype\"))\n    end\n\n    return Sparse(convert(Ptr{C_Sparse{Tv}}, p))\n\nend\n\nconvert(::Type{Sparse}, A::Dense) = dense_to_sparse(A, SuiteSparse_long)\nconvert(::Type{Sparse}, L::Factor) = factor_to_sparse!(copy(L))\nfunction convert(::Type{Sparse}, filename::ByteString)\n    open(filename) do f\n        return read_sparse(f, SuiteSparse_long)\n    end\nend\n\n## convertion back to base Julia types\nfunction convert{T}(::Type{Matrix{T}}, D::Dense{T})\n    s = unsafe_load(D.p)\n    a = Array(T, s.nrow, s.ncol)\n    if s.d == s.nrow\n        unsafe_copy!(pointer(a), s.x, s.d*s.ncol)\n    else\n        for j = 1:s.ncol\n            for i = 1:s.nrow\n                a[i,j] = unsafe_load(s.x, i + (j - 1)*s.d)\n            end\n        end\n    end\n    a\nend\nconvert{T}(::Type{Matrix}, D::Dense{T}) = convert(Matrix{T}, D)\nfunction convert{T}(::Type{Vector{T}}, D::Dense{T})\n    if size(D, 2) > 1\n        throw(DimensionMismatch(\"input must be a vector but had $(size(D, 2)) columns\"))\n    end\n    reshape(convert(Matrix, D), size(D, 1))\nend\nconvert{T}(::Type{Vector}, D::Dense{T}) = convert(Vector{T}, D)\n\nfunction convert{Tv}(::Type{SparseMatrixCSC{Tv,SuiteSparse_long}}, A::Sparse{Tv})\n    s = unsafe_load(A.p)\n    if s.stype != 0\n        throw(ArgumentError(\"matrix has stype != 0. Convert to matrix with stype == 0 before converting to SparseMatrixCSC\"))\n    end\n    return SparseMatrixCSC(s.nrow, s.ncol, increment(pointer_to_array(s.p, (s.ncol + 1,), false)), increment(pointer_to_array(s.i, (s.nzmax,), false)), copy(pointer_to_array(s.x, (s.nzmax,), false)))\nend\nfunction convert(::Type{Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}}, A::Sparse{Float64})\n    s = unsafe_load(A.p)\n    if !issym(A)\n        throw(ArgumentError(\"matrix is not symmetric\"))\n    end\n    return Symmetric(SparseMatrixCSC(s.nrow, s.ncol, increment(pointer_to_array(s.p, (s.ncol + 1,), false)), increment(pointer_to_array(s.i, (s.nzmax,), false)), copy(pointer_to_array(s.x, (s.nzmax,), false))), s.stype > 0 ? :U : :L)\nend\nfunction convert{Tv<:VTypes}(::Type{Hermitian{Tv,SparseMatrixCSC{Tv,SuiteSparse_long}}}, A::Sparse{Tv})\n    s = unsafe_load(A.p)\n    if !ishermitian(A)\n        throw(ArgumentError(\"matrix is not Hermitian\"))\n    end\n    return Hermitian(SparseMatrixCSC(s.nrow, s.ncol, increment(pointer_to_array(s.p, (s.ncol + 1,), false)), increment(pointer_to_array(s.i, (s.nzmax,), false)), copy(pointer_to_array(s.x, (s.nzmax,), false))), s.stype > 0 ? :U : :L)\nend\nfunction sparse(A::Sparse{Float64}) # Notice! Cannot be type stable because of stype\n    s = unsafe_load(A.p)\n    if s.stype == 0\n        return convert(SparseMatrixCSC{Float64,SuiteSparse_long}, A)\n    end\n    return convert(Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}, A)\nend\nfunction sparse(A::Sparse{Complex{Float64}}) # Notice! Cannot be type stable because of stype\n    s = unsafe_load(A.p)\n    if s.stype == 0\n        return convert(SparseMatrixCSC{Complex{Float64},SuiteSparse_long}, A)\n    end\n    return convert(Hermitian{Complex{Float64},SparseMatrixCSC{Complex{Float64},SuiteSparse_long}}, A)\nend\nfunction sparse(F::Factor)\n    s = unsafe_load(F.p)\n    if s.is_ll != 0\n        L = Sparse(F)\n        A = sparse(L*L')\n    else\n        LD = sparse(F[:LD])\n        L, d = getLd!(LD)\n        A = scale(L, d)*L'\n    end\n    SparseMatrix.sortSparseMatrixCSC!(A)\n    p = get_perm(F)\n    if p != [1:s.n;]\n        pinv = Array(Int, length(p))\n        for k = 1:length(p)\n            pinv[p[k]] = k\n        end\n        A = A[pinv,pinv]\n    end\n    A\nend\n\nsparse(D::Dense) = sparse(Sparse(D))\n\nfunction sparse{Tv}(FC::FactorComponent{Tv,:L})\n    F = Factor(FC)\n    s = unsafe_load(F.p)\n    s.is_ll != 0 || throw(CHOLMODException(\"sparse: supported only for :LD on LDLt factorizations\"))\n    sparse(Sparse(F))\nend\nsparse{Tv}(FC::FactorComponent{Tv,:LD}) = sparse(Sparse(Factor(FC)))\n\n# Calculate the offset into the stype field of the cholmod_sparse_struct and\n# change the value\nlet offidx=findfirst(fieldnames(C_Sparse) .== :stype)\n\n    global change_stype!\n    function change_stype!(A::Sparse, i::Integer)\n        offset = fieldoffsets(C_Sparse)[offidx]\n        unsafe_store!(convert(Ptr{Cint}, A.p), i, div(offset, 4) + 1)\n        return A\n    end\nend\n\nfree!(A::Dense) = free_dense!(A.p)\nfree!(A::Sparse) = free_sparse!(A.p)\nfree!(F::Factor) = free_factor!(F.p)\n\neltype{T<:VTypes}(::Type{Dense{T}}) = T\neltype{T<:VTypes}(::Type{Factor{T}}) = T\neltype{T<:VTypes}(::Type{Sparse{T}}) = T\n\nnnz(F::Factor) = nnz(Sparse(F))\n\nfunction show(io::IO, F::Factor)\n    println(io, typeof(F))\n    showfactor(io, F)\nend\n\n# FactorComponent is a subtype of AbstractArray and we therefore define showarray instead of show\nfunction showarray(io::IO, FC::FactorComponent; kargs...)\n    println(io, typeof(FC))\n    showfactor(io, Factor(FC))\nend\n\nfunction showfactor(io::IO, F::Factor)\n    s = unsafe_load(get(F.p))\n    @printf(io, \"type: %12s\\n\", s.is_ll!=0 ? \"LLt\" : \"LDLt\")\n    @printf(io, \"method: %10s\\n\", s.is_super!=0 ? \"supernodal\" : \"simplicial\")\n    @printf(io, \"maxnnz: %10d\\n\", Int(s.nzmax))\n    @printf(io, \"nnz: %13d\\n\", nnz(F))\nend\n\nisvalid(A::Dense) = check_dense(A)\nisvalid(A::Sparse) = check_sparse(A)\nisvalid(A::Factor) = check_factor(A)\n\ncopy(A::Dense) = copy_dense(A)\ncopy(A::Sparse) = copy_sparse(A)\ncopy(A::Factor) = copy_factor(A)\n\nfunction size(A::Union{Dense,Sparse})\n    s = unsafe_load(get(A.p))\n    return (Int(s.nrow), Int(s.ncol))\nend\nfunction size(F::Factor, i::Integer)\n    if i < 1\n        throw(ArgumentError(\"dimension must be positive\"))\n    end\n    s = unsafe_load(get(F.p))\n    if i <= 2\n        return Int(s.n)\n    end\n    return 1\nend\n\nlinearindexing(::Dense) = LinearFast()\n\nsize(FC::FactorComponent, i::Integer) = size(FC.F, i)\nsize(FC::FactorComponent) = size(FC.F)\n\nctranspose{Tv}(FC::FactorComponent{Tv,:L}) = FactorComponent{Tv,:U}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:U}) = FactorComponent{Tv,:L}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:PtL}) = FactorComponent{Tv,:UP}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:UP}) = FactorComponent{Tv,:PtL}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:D}) = FC\nctranspose{Tv}(FC::FactorComponent{Tv,:LD}) = FactorComponent{Tv,:DU}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:DU}) = FactorComponent{Tv,:LD}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:PtLD}) = FactorComponent{Tv,:DUP}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:DUP}) = FactorComponent{Tv,:PtLD}(FC.F)\n\nfunction getindex(A::Dense, i::Integer)\n    s = unsafe_load(get(A.p))\n    0 < i <= s.nrow*s.ncol || throw(BoundsError())\n    unsafe_load(s.x, i)\nend\n\nlinearindexing(::Sparse) = LinearSlow()\nfunction getindex{T}(A::Sparse{T}, i0::Integer, i1::Integer)\n    s = unsafe_load(get(A.p))\n    !(1 <= i0 <= s.nrow && 1 <= i1 <= s.ncol) && throw(BoundsError())\n    s.stype < 0 && i0 < i1 && return conj(A[i1,i0])\n    s.stype > 0 && i0 > i1 && return conj(A[i1,i0])\n\n    r1 = Int(unsafe_load(s.p, i1) + 1)\n    r2 = Int(unsafe_load(s.p, i1 + 1))\n    (r1 > r2) && return zero(T)\n    r1 = Int(searchsortedfirst(pointer_to_array(s.i, (s.nzmax,), false), i0 - 1, r1, r2, Base.Order.Forward))\n    ((r1 > r2) || (unsafe_load(s.i, r1) + 1 != i0)) ? zero(T) : unsafe_load(s.x, r1)\nend\n\nfunction getindex(F::Factor, sym::Symbol)\n    sym == :p && return get_perm(F)\n    FactorComponent(F, sym)\nend\n\nfunction getLd!(S::SparseMatrixCSC)\n    d = Array(eltype(S), size(S, 1))\n    fill!(d, 0)\n    col = 1\n    for k = 1:length(S.nzval)\n        while k >= S.colptr[col+1]\n            col += 1\n        end\n        if S.rowval[k] == col\n            d[col] = S.nzval[k]\n            S.nzval[k] = 1\n        end\n    end\n    S, d\nend\n\n## Multiplication\n(*)(A::Sparse, B::Sparse) = ssmult(A, B, 0, true, true)\n(*)(A::Sparse, B::Dense) = sdmult!(A, false, 1., 0., B, zeros(size(A, 1), size(B, 2)))\n(*)(A::Sparse, B::VecOrMat) = (*)(A, Dense(B))\n\nfunction A_mul_Bc{Tv<:VRealTypes}(A::Sparse{Tv}, B::Sparse{Tv})\n    cm = common()\n\n    if !is(A,B)\n        aa1 = transpose_(B, 2)\n        ## result of ssmult will have stype==0, contain numerical values and be sorted\n        return ssmult(A, aa1, 0, true, true)\n    end\n\n    ## The A*A' case is handled by cholmod_aat. This routine requires\n    ## A->stype == 0 (storage of upper and lower parts). If neccesary\n    ## the matrix A is first converted to stype == 0\n    s = unsafe_load(A.p)\n    if s.stype != 0\n        aa1 = copy(A, 0, 1)\n        return aat(aa1, SuiteSparse_long[0:s.ncol-1;], 1)\n    else\n        return aat(A, SuiteSparse_long[0:s.ncol-1;], 1)\n    end\nend\n\nfunction Ac_mul_B(A::Sparse, B::Sparse)\n    aa1 = transpose_(A, 2)\n    if is(A,B)\n        return A_mul_Bc(aa1, aa1)\n    end\n    ## result of ssmult will have stype==0, contain numerical values and be sorted\n    return ssmult(aa1, B, 0, true, true)\nend\n\nAc_mul_B(A::Sparse, B::Dense) = sdmult!(A, true, 1., 0., B, zeros(size(A, 2), size(B, 2)))\nAc_mul_B(A::Sparse, B::VecOrMat) =  Ac_mul_B(A, Dense(B))\n\n\n## Factorization methods\n\nfunction fact_{Tv<:VTypes}(A::Sparse{Tv}, cm::Array{UInt8};\n    shift::Real=0.0, perm::AbstractVector{SuiteSparse_long}=SuiteSparse_long[],\n    postorder::Bool=true, userperm_only::Bool=true)\n\n    sA = unsafe_load(get(A.p))\n    sA.stype == 0 && throw(ArgumentError(\"sparse matrix is not symmetric/Hermitian\"))\n\n    if !postorder\n        unsafe_store!(common_postorder, 0)\n    end\n\n    if isempty(perm)\n        F = analyze(A, cm)\n    else # user permutation provided\n        if userperm_only # use perm even if it is worse than AMD\n            unsafe_store!(common_nmethods, 1)\n        end\n        F = analyze_p(A, SuiteSparse_long[p-1 for p in perm], cm)\n    end\n\n    factorize_p!(A, shift, F, cm)\n    return F\nend\n\nfunction cholfact(A::Sparse; kws...)\n    cm = defaults(common()) # setting the common struct to default values. Should only be done when creating new factorization.\n    set_print_level(cm, 0) # no printing from CHOLMOD by default\n\n    # Makes it an LLt\n    unsafe_store!(common_final_ll, 1)\n\n    F = fact_(A, cm; kws...)\n    s = unsafe_load(get(F.p))\n    s.minor < size(A, 1) && throw(Base.LinAlg.PosDefException(s.minor))\n    return F\nend\n\nfunction ldltfact(A::Sparse; kws...)\n    cm = defaults(common()) # setting the common struct to default values. Should only be done when creating new factorization.\n    set_print_level(cm, 0) # no printing from CHOLMOD by default\n\n    # Makes it an LDLt\n    unsafe_store!(common_final_ll, 0)\n\n    # Really make sure it's an LDLt by avoiding supernodal factorisation\n    unsafe_store!(common_supernodal, 0)\n\n    F = fact_(A, cm; kws...)\n    s = unsafe_load(get(F.p))\n    s.minor < size(A, 1) && throw(Base.LinAlg.ArgumentError(\"matrix has one or more zero pivots\"))\n    return F\nend\n\n\nfor f in (:cholfact, :ldltfact)\n    @eval begin\n        $f(A::SparseMatrixCSC; kws...) = $f(Sparse(A); kws...)\n        $f(A::Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}; kws...) = $f(Sparse(A); kws...)\n        $f(A::Hermitian{Complex{Float64},SparseMatrixCSC{Complex{Float64},SuiteSparse_long}}; kws...) = $f(Sparse(A); kws...)\n    end\nend\n\nfunction update!{Tv<:VTypes}(F::Factor{Tv}, A::Sparse{Tv}; shift::Real=0.0)\n    cm = defaults(common()) # setting the common struct to default values. Should only be done when creating new factorization.\n    set_print_level(cm, 0) # no printing from CHOLMOD by default\n\n    s = unsafe_load(get(F.p))\n    if s.is_ll!=0\n        unsafe_store!(common_final_ll, 1) # Makes it an LLt\n    end\n    factorize_p!(A, shift, F, cm)\nend\nupdate!{T<:VTypes}(F::Factor{T}, A::SparseMatrixCSC{T}; kws...) = update!(F, Sparse(A); kws...)\n\n## Solvers\n\nfor (T, f) in ((:Dense, :solve), (:Sparse, :spsolve))\n    @eval begin\n        # Solve Lx = b and L'x=b where A = L*L'\n        function (\\){T}(L::FactorComponent{T,:L}, B::$T)\n            ($f)(CHOLMOD_L, Factor(L), B)\n        end\n        function (\\){T}(L::FactorComponent{T,:U}, B::$T)\n            ($f)(CHOLMOD_Lt, Factor(L), B)\n        end\n        # Solve PLx = b and L'P'x=b where A = P*L*L'*P'\n        function (\\){T}(L::FactorComponent{T,:PtL}, B::$T)\n            F = Factor(L)\n            ($f)(CHOLMOD_L, F, ($f)(CHOLMOD_P, F, B))  # Confusingly, CHOLMOD_P solves P'x = b\n        end\n        function (\\){T}(L::FactorComponent{T,:UP}, B::$T)\n            F = Factor(L)\n            ($f)(CHOLMOD_Pt, F, ($f)(CHOLMOD_Lt, F, B))\n        end\n        # Solve various equations for A = L*D*L' and A = P*L*D*L'*P'\n        function (\\){T}(L::FactorComponent{T,:D}, B::$T)\n            ($f)(CHOLMOD_D, Factor(L), B)\n        end\n        function (\\){T}(L::FactorComponent{T,:LD}, B::$T)\n            ($f)(CHOLMOD_LD, Factor(L), B)\n        end\n        function (\\){T}(L::FactorComponent{T,:DU}, B::$T)\n            ($f)(CHOLMOD_DLt, Factor(L), B)\n        end\n        function (\\){T}(L::FactorComponent{T,:PtLD}, B::$T)\n            F = Factor(L)\n            ($f)(CHOLMOD_LD, F, ($f)(CHOLMOD_P, F, B))\n        end\n        function (\\){T}(L::FactorComponent{T,:DUP}, B::$T)\n            F = Factor(L)\n            ($f)(CHOLMOD_Pt, F, ($f)(CHOLMOD_DLt, F, B))\n        end\n    end\nend\n\nfunction (\\)(L::FactorComponent, b::Vector)\n    reshape(convert(Matrix, L\\Dense(b)), length(b))\nend\nfunction (\\)(L::FactorComponent, B::Matrix)\n    convert(Matrix, L\\Dense(B))\nend\nfunction (\\)(L::FactorComponent, B::SparseMatrixCSC)\n    sparse(L\\Sparse(B,0))\nend\n\nAc_ldiv_B(L::FactorComponent, B) = ctranspose(L)\\B\n\n(\\)(L::Factor, B::Dense) = solve(CHOLMOD_A, L, B)\n(\\)(L::Factor, b::Vector) = reshape(convert(Matrix, solve(CHOLMOD_A, L, Dense(b))), length(b))\n(\\)(L::Factor, B::Matrix) = convert(Matrix, solve(CHOLMOD_A, L, Dense(B)))\n(\\)(L::Factor, B::Sparse) = spsolve(CHOLMOD_A, L, B)\n# When right hand side is sparse, we have to ensure that the rhs is not marked as symmetric.\n(\\)(L::Factor, B::SparseMatrixCSC) = sparse(spsolve(CHOLMOD_A, L, Sparse(B, 0)))\n\nAc_ldiv_B(L::Factor, B::Dense) = solve(CHOLMOD_A, L, B)\nAc_ldiv_B(L::Factor, B::VecOrMat) = convert(Matrix, solve(CHOLMOD_A, L, Dense(B)))\nAc_ldiv_B(L::Factor, B::Sparse) = spsolve(CHOLMOD_A, L, B)\nAc_ldiv_B(L::Factor, B::SparseMatrixCSC) = Ac_ldiv_B(L, Sparse(B))\n\n## Other convenience methods\nfunction diag{Tv}(F::Factor{Tv})\n    f = unsafe_load(get(F.p))\n    fsuper = f.super\n    fpi = f.pi\n    res = Base.zeros(Tv, Int(f.n))\n    xv  = f.x\n    if f.is_super!=0\n        px = f.px\n        pos = 1\n        for i in 1:f.nsuper\n            base = unsafe_load(px, i) + 1\n            res[pos] = unsafe_load(xv, base)\n            pos += 1\n            for j in 1:unsafe_load(fsuper, i + 1) - unsafe_load(fsuper, i) - 1\n                res[pos] = unsafe_load(xv, base + j*(unsafe_load(fpi, i + 1) - unsafe_load(fpi, i) + 1))\n                pos += 1\n            end\n        end\n    else\n        c0 = f.p\n        r0 = f.i\n        xv = f.x\n        for j in 1:f.n\n            jj = unsafe_load(c0, j) + 1\n            assert(unsafe_load(r0, jj) == j - 1)\n            res[j] = unsafe_load(xv, jj)\n        end\n    end\n    res\nend\n\nfunction logdet{Tv<:VTypes}(F::Factor{Tv})\n    f = unsafe_load(get(F.p))\n    res = zero(Tv)\n    for d in diag(F) res += log(abs(d)) end\n    f.is_ll!=0 ? 2res : res\nend\n\ndet(L::Factor) = exp(logdet(L))\n\nfunction isposdef{Tv<:VTypes}(A::SparseMatrixCSC{Tv,SuiteSparse_long})\n    if !ishermitian(A)\n        return false\n    end\n    try\n        f = cholfact(A)\n    catch e\n        isa(e, LinAlg.PosDefException) || rethrow(e)\n        return false\n    end\n    true\nend\n\nfunction issym(A::Sparse)\n    s = unsafe_load(A.p)\n    if s.stype != 0\n        return isreal(A)\n    end\n    i = symmetry(A, 1)[1]\n    return i == MM_SYMMETRIC || i == MM_SYMMETRIC_POSDIAG\nend\n\nfunction ishermitian(A::Sparse{Float64})\n    s = unsafe_load(A.p)\n    if s.stype != 0\n        return true\n    else\n        i = symmetry(A, 1)[1]\n        return i == MM_SYMMETRIC || i == MM_SYMMETRIC_POSDIAG\n    end\nend\nfunction ishermitian(A::Sparse{Complex{Float64}})\n    s = unsafe_load(A.p)\n    if s.stype != 0\n        return true\n    else\n        i = symmetry(A, 1)[1]\n        return i == MM_HERMITIAN || i == MM_HERMITIAN_POSDIAG\n    end\nend\n\n(*){Ti}(A::Symmetric{Float64,SparseMatrixCSC{Float64,Ti}}, B::SparseMatrixCSC{Float64,Ti}) = sparse(Sparse(A)*Sparse(B))\n(*){Ti}(A::Hermitian{Complex{Float64},SparseMatrixCSC{Complex{Float64},Ti}}, B::SparseMatrixCSC{Complex{Float64},Ti}) = sparse(Sparse(A)*Sparse(B))\n\nend #module\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/base/docs/helpdb.jl": "# This file is a part of Julia. License is MIT: http://julialang.org/license\n\n# Base.LinAlg.BLAS\n\nimport .Docs: keywords\n\ndoc\"\"\"\n    ger!(alpha, x, y, A)\n\nRank-1 update of the matrix `A` with vectors `x` and `y` as `alpha*x*y' + A`.\n\"\"\"\nLinAlg.BLAS.ger!\n\ndoc\"\"\"\n    gbmv!(trans, m, kl, ku, alpha, A, x, beta, y)\n\nUpdate vector `y` as `alpha*A*x + beta*y` or `alpha*A'*x + beta*y` according to `trans` ('N' or 'T'). The matrix `A` is a general band matrix of dimension `m` by `size(A,2)` with `kl` sub-diagonals and `ku` super-diagonals. Returns the updated `y`.\n\"\"\"\nLinAlg.BLAS.gbmv!\n\ndoc\"\"\"\n    gbmv(trans, m, kl, ku, alpha, A, x, beta, y)\n\nReturns `alpha*A*x` or `alpha*A'*x` according to `trans` ('N' or 'T'). The matrix `A` is a general band matrix of dimension `m` by `size(A,2)` with `kl` sub-diagonals and `ku` super-diagonals.\n\"\"\"\nLinAlg.BLAS.gbmv\n\ndoc\"\"\"\n    gemm!(tA, tB, alpha, A, B, beta, C)\n\nUpdate `C` as `alpha*A*B + beta*C` or the other three variants according to `tA` (transpose `A`) and `tB`. Returns the updated `C`.\n\"\"\"\nLinAlg.BLAS.gemm!\n\ndoc\"\"\"\n    gemv!(tA, alpha, A, x, beta, y)\n\nUpdate the vector `y` as `alpha*A*x + beta*y` or `alpha*A'x + beta*y` according to `tA` (transpose `A`). Returns the updated `y`.\n\"\"\"\nLinAlg.BLAS.gemv!\n\ndoc\"\"\"\n    blascopy!(n, X, incx, Y, incy)\n\nCopy `n` elements of array `X` with stride `incx` to array `Y` with stride `incy`. Returns `Y`.\n\"\"\"\nLinAlg.BLAS.blascopy!\n\ndoc\"\"\"\n    scal!(n, a, X, incx)\n\nOverwrite `X` with `a*X`. Returns `X`.\n\"\"\"\nLinAlg.BLAS.scal!\n\ndoc\"\"\"\n    gemv(tA, alpha, A, x)\n\nReturns `alpha*A*x` or `alpha*A'x` according to `tA` (transpose `A`).\n\"\"\"\nLinAlg.BLAS.gemv(tA, alpha, A, x)\n\ndoc\"\"\"\n    gemv(tA, A, x)\n\nReturns `A*x` or `A'x` according to `tA` (transpose `A`).\n\"\"\"\nLinAlg.BLAS.gemv(tA, A, x)\n\ndoc\"\"\"\n    syr!(uplo, alpha, x, A)\n\nRank-1 update of the symmetric matrix `A` with vector `x` as `alpha*x*x.' + A`. When `uplo` is 'U' the upper triangle of `A` is updated ('L' for lower triangle). Returns `A`.\n\"\"\"\nLinAlg.BLAS.syr!\n\ndoc\"\"\"\n    trsm!(side, ul, tA, dA, alpha, A, B)\n\nOverwrite `B` with the solution to `A*X = alpha*B` or one of the other three variants determined by `side` (`A` on left or right of `X`) and `tA` (transpose `A`). Only the `ul` triangle of `A` is used. `dA` indicates if `A` is unit-triangular (the diagonal is assumed to be all ones). Returns the updated `B`.\n\"\"\"\nLinAlg.BLAS.trsm!\n\ndoc\"\"\"\n    trsv!(ul, tA, dA, A, b)\n\nOverwrite `b` with the solution to `A*x = b` or one of the other two variants determined by `tA` (transpose `A`) and `ul` (triangle of `A` used). `dA` indicates if `A` is unit-triangular (the diagonal is assumed to be all ones). Returns the updated `b`.\n\"\"\"\nLinAlg.BLAS.trsv!\n\ndoc\"\"\"\n    her!(uplo, alpha, x, A)\n\nMethods for complex arrays only. Rank-1 update of the Hermitian matrix `A` with vector `x` as `alpha*x*x' + A`. When `uplo` is 'U' the upper triangle of `A` is updated ('L' for lower triangle). Returns `A`.\n\"\"\"\nLinAlg.BLAS.her!\n\ndoc\"\"\"\n    trsv(ul, tA, dA, A, b)\n\nReturns the solution to `A*x = b` or one of the other two variants determined by `tA` (transpose `A`) and `ul` (triangle of `A` is used.) `dA` indicates if `A` is unit-triangular (the diagonal is assumed to be all ones).\n\"\"\"\nLinAlg.BLAS.trsv\n\ndoc\"\"\"\n    dot(n, X, incx, Y, incy)\n\nDot product of two vectors consisting of `n` elements of array `X` with stride `incx` and `n` elements of array `Y` with stride `incy`.\n\"\"\"\nLinAlg.BLAS.dot\n\ndoc\"\"\"\n    dotu(n, X, incx, Y, incy)\n\nDot function for two complex vectors.\n\"\"\"\nLinAlg.BLAS.dotu\n\ndoc\"\"\"\n    herk!(uplo, trans, alpha, A, beta, C)\n\nMethods for complex arrays only. Rank-k update of the Hermitian matrix `C` as `alpha*A*A' + beta*C` or `alpha*A'*A + beta*C` according to whether `trans` is 'N' or 'T'. When `uplo` is 'U' the upper triangle of `C` is updated ('L' for lower triangle). Returns `C`.\n\"\"\"\nLinAlg.BLAS.herk!\n\ndoc\"\"\"\n    trmv(side, ul, tA, dA, alpha, A, b)\n\nReturns `alpha*A*b` or one of the other three variants determined by `side` (`A` on left or right) and `tA` (transpose `A`). Only the `ul` triangle of `A` is used. `dA` indicates if `A` is unit-triangular (the diagonal is assumed to be all ones).\n\"\"\"\nLinAlg.BLAS.trmv\n\ndoc\"\"\"\n    symv(ul, alpha, A, x)\n\nReturns `alpha*A*x`. `A` is assumed to be symmetric. Only the `ul` triangle of `A` is used.\n\"\"\"\nLinAlg.BLAS.symv(ul, alpha, A, x)\n\ndoc\"\"\"\n    symv(ul, A, x)\n\nReturns `A*x`. `A` is assumed to be symmetric. Only the `ul` triangle of `A` is used.\n\"\"\"\nLinAlg.BLAS.symv(ul, A, x)\n\ndoc\"\"\"\n    dotc(n, X, incx, U, incy)\n\nDot function for two complex vectors conjugating the first vector.\n\"\"\"\nLinAlg.BLAS.dotc\n\ndoc\"\"\"\n    axpy!(a, X, Y)\n\nOverwrite `Y` with `a*X + Y`. Returns `Y`.\n\"\"\"\nLinAlg.BLAS.axpy!\n\ndoc\"\"\"\n    syrk!(uplo, trans, alpha, A, beta, C)\n\nRank-k update of the symmetric matrix `C` as `alpha*A*A.' + beta*C` or `alpha*A.'*A + beta*C` according to whether `trans` is 'N' or 'T'. When `uplo` is 'U' the upper triangle of `C` is updated ('L' for lower triangle). Returns `C`.\n\"\"\"\nLinAlg.BLAS.syrk!\n\ndoc\"\"\"\n    sbmv(uplo, k, alpha, A, x)\n\nReturns `alpha*A*x` where `A` is a symmetric band matrix of order `size(A,2)` with `k` super-diagonals stored in the argument `A`.\n\"\"\"\nLinAlg.BLAS.sbmv(uplo, k, alpha, A, x)\n\ndoc\"\"\"\n    sbmv(uplo, k, A, x)\n\nReturns `A*x` where `A` is a symmetric band matrix of order `size(A,2)` with `k` super-diagonals stored in the argument `A`.\n\"\"\"\nLinAlg.BLAS.sbmv(uplo, k, A, x)\n\ndoc\"\"\"\n    sbmv!(uplo, k, alpha, A, x, beta, y)\n\nUpdate vector `y` as `alpha*A*x + beta*y` where `A` is a a symmetric band matrix of order `size(A,2)` with `k` super-diagonals stored in the argument `A`. The storage layout for `A` is described the reference BLAS module, level-2 BLAS at <http://www.netlib.org/lapack/explore-html/>.\n\nReturns the updated `y`.\n\"\"\"\nLinAlg.BLAS.sbmv!\n\ndoc\"\"\"\n    symv!(ul, alpha, A, x, beta, y)\n\nUpdate the vector `y` as `alpha*A*x + beta*y`. `A` is assumed to be symmetric. Only the `ul` triangle of `A` is used. Returns the updated `y`.\n\"\"\"\nLinAlg.BLAS.symv!\n\ndoc\"\"\"\n    symm(side, ul, alpha, A, B)\n\nReturns `alpha*A*B` or `alpha*B*A` according to `side`. `A` is assumed to be symmetric. Only the `ul` triangle of `A` is used.\n\"\"\"\nLinAlg.BLAS.symm(side, ul, alpha, A, B)\n\ndoc\"\"\"\n    symm(side, ul, A, B)\n\nReturns `A*B` or `B*A` according to `side`. `A` is assumed to be symmetric. Only the `ul` triangle of `A` is used.\n\"\"\"\nLinAlg.BLAS.symm(side, ul, A, B)\n\ndoc\"\"\"\n    symm(tA, tB, alpha, A, B)\n\nReturns `alpha*A*B` or the other three variants according to `tA` (transpose `A`) and `tB`.\n\"\"\"\nLinAlg.BLAS.symm(tA::Char, tB::Char, alpha, A, B)\n\ndoc\"\"\"\n    herk(uplo, trans, alpha, A)\n\nMethods for complex arrays only. Returns either the upper triangle or the lower triangle, according to `uplo` ('U' or 'L'), of `alpha*A*A'` or `alpha*A'*A`, according to `trans` ('N' or 'T').\n\"\"\"\nLinAlg.BLAS.herk\n\ndoc\"\"\"\n    syrk(uplo, trans, alpha, A)\n\nReturns either the upper triangle or the lower triangle, according to `uplo` ('U' or 'L'), of `alpha*A*A.'` or `alpha*A.'*A`, according to `trans` ('N' or 'T').\n\"\"\"\nLinAlg.BLAS.syrk\n\ndoc\"\"\"\n    trsm(side, ul, tA, dA, alpha, A, B)\n\nReturns the solution to `A*X = alpha*B` or one of the other three variants determined by `side` (`A` on left or right of `X`) and `tA` (transpose `A`). Only the `ul` triangle of `A` is used. `dA` indicates if `A` is unit-triangular (the diagonal is assumed to be all ones).\n\"\"\"\nLinAlg.BLAS.trsm\n\ndoc\"\"\"\n    blas_set_num_threads(n)\n\nSet the number of threads the BLAS library should use.\n\"\"\"\nLinAlg.BLAS.blas_set_num_threads\n\ndoc\"\"\"\n    asum(n, X, incx)\n\nsum of the absolute values of the first `n` elements of array `X` with stride `incx`.\n\"\"\"\nLinAlg.BLAS.asum\n\ndoc\"\"\"\n    trmv!(side, ul, tA, dA, alpha, A, b)\n\nUpdate `b` as `alpha*A*b` or one of the other three variants determined by `side` (`A` on left or right) and `tA` (transpose `A`). Only the `ul` triangle of `A` is used. `dA` indicates if `A` is unit-triangular (the diagonal is assumed to be all ones). Returns the updated `b`.\n\"\"\"\nLinAlg.BLAS.trmv!\n\ndoc\"\"\"\n    gemm(tA, tB, alpha, A, B)\n\nReturns `alpha*A*B` or the other three variants according to `tA` (transpose `A`) and `tB`.\n\"\"\"\nLinAlg.BLAS.gemm(tA, tB, alpha, A, B)\n\ndoc\"\"\"\n    gemm(tA, tB, A, B)\n\nReturns `A*B` or the other three variants according to `tA` (transpose `A`) and `tB`.\n\"\"\"\nLinAlg.BLAS.gemm(tA, tB, A, B)\n\ndoc\"\"\"\n    symm!(side, ul, alpha, A, B, beta, C)\n\nUpdate `C` as `alpha*A*B + beta*C` or `alpha*B*A + beta*C` according to `side`. `A` is assumed to be symmetric. Only the `ul` triangle of `A` is used. Returns the updated `C`.\n\"\"\"\nLinAlg.BLAS.symm!\n\ndoc\"\"\"\n    scal(n, a, X, incx)\n\nReturns `a*X`.\n\"\"\"\nLinAlg.BLAS.scal\n\ndoc\"\"\"\n    nrm2(n, X, incx)\n\n2-norm of a vector consisting of `n` elements of array `X` with stride `incx`.\n\"\"\"\nLinAlg.BLAS.nrm2\n\ndoc\"\"\"\n    trmm!(side, ul, tA, dA, alpha, A, B)\n\nUpdate `B` as `alpha*A*B` or one of the other three variants determined by `side` (`A` on left or right) and `tA` (transpose `A`). Only the `ul` triangle of `A` is used. `dA` indicates if `A` is unit-triangular (the diagonal is assumed to be all ones). Returns the updated `B`.\n\"\"\"\nLinAlg.BLAS.trmm!\n\ndoc\"\"\"\n    trmm(side, ul, tA, dA, alpha, A, B)\n\nReturns `alpha*A*B` or one of the other three variants determined by `side` (`A` on left or right) and `tA` (transpose `A`). Only the `ul` triangle of `A` is used. `dA` indicates if `A` is unit-triangular (the diagonal is assumed to be all ones).\n\"\"\"\nLinAlg.BLAS.trmm\n\n# Libdl\n\ndoc\"\"\"\n    dlopen(libfile::AbstractString [, flags::Integer])\n\nLoad a shared library, returning an opaque handle.\n\nThe optional flags argument is a bitwise-or of zero or more of `RTLD_LOCAL`, `RTLD_GLOBAL`, `RTLD_LAZY`, `RTLD_NOW`, `RTLD_NODELETE`, `RTLD_NOLOAD`, `RTLD_DEEPBIND`, and `RTLD_FIRST`. These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default `dlopen` flags are `RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL` while on other platforms the defaults are `RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL`. An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance `RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL` allows the library's symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.\n\"\"\"\nLibdl.dlopen\n\ndoc\"\"\"\n    dlclose(handle)\n\nClose shared library referenced by handle.\n\"\"\"\nLibdl.dlclose\n\ndoc\"\"\"\n    dlsym_e(handle, sym)\n\nLook up a symbol from a shared library handle, silently return `NULL` pointer on lookup failure.\n\"\"\"\nLibdl.dlsym_e\n\ndoc\"\"\"\n```rst\n..  dlopen_e(libfile::AbstractString [, flags::Integer])\n\nSimilar to :func:`dlopen`, except returns a ``NULL`` pointer instead of raising errors.\n```\n\"\"\"\nLibdl.dlopen_e\n\ndoc\"\"\"\n    find_library(names, locations)\n\nSearches for the first library in `names` in the paths in the `locations` list, `DL_LOAD_PATH`, or system library paths (in that order) which can successfully be dlopen'd. On success, the return value will be one of the names (potentially prefixed by one of the paths in locations). This string can be assigned to a `global const` and used as the library name in future `ccall`'s. On failure, it returns the empty string.\n\"\"\"\nLibdl.find_library\n\ndoc\"\"\"\n    dlsym(handle, sym)\n\nLook up a symbol from a shared library handle, return callable function pointer on success.\n\"\"\"\nLibdl.dlsym\n\n# Libc\n\ndoc\"\"\"\n    TmStruct([seconds])\n\nConvert a number of seconds since the epoch to broken-down format, with fields `sec`, `min`, `hour`, `mday`, `month`, `year`, `wday`, `yday`, and `isdst`.\n\"\"\"\nLibc.TmStruct\n\ndoc\"\"\"\n    dlext\n\nFile extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.\n\"\"\"\nLibdl.dlext\n\ndoc\"\"\"\n    time(t::TmStruct)\n\nConverts a `TmStruct` struct to a number of seconds since the epoch.\n\"\"\"\nLibc.time\n\ndoc\"\"\"\n    calloc(num::Integer, size::Integer) -> Ptr{Void}\n\nCall `calloc` from the C standard library.\n\"\"\"\nLibc.calloc\n\ndoc\"\"\"\n    strerror(n=errno())\n\nConvert a system call error code to a descriptive string\n\"\"\"\nLibc.strerror\n\ndoc\"\"\"\n    realloc(addr::Ptr, size::Integer) -> Ptr{Void}\n\nCall `realloc` from the C standard library.\n\nSee warning in the documentation for `free` regarding only using this on memory originally obtained from `malloc`.\n\"\"\"\nLibc.realloc\n\ndoc\"\"\"\n    free(addr::Ptr)\n\nCall `free` from the C standard library. Only use this on memory obtained from `malloc`, not on pointers retrieved from other C libraries. `Ptr` objects obtained from C libraries should be freed by the free functions defined in that library, to avoid assertion failures if multiple `libc` libraries exist on the system.\n\"\"\"\nLibc.free\n\ndoc\"\"\"\n    strftime([format], time)\n\nConvert time, given as a number of seconds since the epoch or a `TmStruct`, to a formatted string using the given format. Supported formats are the same as those in the standard C library.\n\"\"\"\nLibc.strftime\n\ndoc\"\"\"\n    errno([code])\n\nGet the value of the C library's `errno`. If an argument is specified, it is used to set the value of `errno`.\n\nThe value of `errno` is only valid immediately after a `ccall` to a C library routine that sets it. Specifically, you cannot call `errno` at the next prompt in a REPL, because lots of code is executed between prompts.\n\"\"\"\nLibc.errno\n\ndoc\"\"\"\n    malloc(size::Integer) -> Ptr{Void}\n\nCall `malloc` from the C standard library.\n\"\"\"\nLibc.malloc\n\ndoc\"\"\"\n    strptime([format], timestr)\n\nParse a formatted time string into a `TmStruct` giving the seconds, minute, hour, date, etc. Supported formats are the same as those in the standard C library. On some platforms, timezones will not be parsed correctly. If the result of this function will be passed to `time` to convert it to seconds since the epoch, the `isdst` field should be filled in manually. Setting it to `-1` will tell the C library to use the current system settings to determine the timezone.\n\"\"\"\nLibc.strptime\n\ndoc\"\"\"\n    flush_cstdio()\n\nFlushes the C `stdout` and `stderr` streams (which may have been written to by external C code).\n\"\"\"\nLibc.flush_cstdio\n\ndoc\"\"\"\n```rst\n..  msync(ptr, len, [flags])\n\nForces synchronization of the :func:`mmap`\\ ped memory region from ``ptr`` to ``ptr+len``. Flags defaults to ``MS_SYNC``, but can be a combination of ``MS_ASYNC``, ``MS_SYNC``, or ``MS_INVALIDATE``. See your platform man page for specifics. The flags argument is not valid on Windows.\n\nYou may not need to call ``msync``, because synchronization is performed at intervals automatically by the operating system. However, you can call this directly if, for example, you are concerned about losing the result of a long-running calculation.\n```\n\"\"\"\nLibc.msync\n\n# Base.Collections\n\ndoc\"\"\"\n```rst\n..  PriorityQueue(K, V, [ord])\n\nConstruct a new :obj:`PriorityQueue`, with keys of type ``K`` and values/priorites of\ntype ``V``. If an order is not given, the priority queue is min-ordered using\nthe default comparison for ``V``.\n```\n\"\"\"\nCollections.PriorityQueue\n\ndoc\"\"\"\n    enqueue!(pq, k, v)\n\nInsert the a key `k` into a priority queue `pq` with priority `v`.\n\"\"\"\nCollections.enqueue!\n\ndoc\"\"\"\n    dequeue!(pq)\n\nRemove and return the lowest priority key from a priority queue.\n\"\"\"\nCollections.dequeue!\n\ndoc\"\"\"\n    peek(pq)\n\nReturn the lowest priority key from a priority queue without removing that key from the queue.\n\"\"\"\nCollections.peek\n\ndoc\"\"\"\n```rst\n..  heapify!(v, [ord])\n\nIn-place :func:`heapify`.\n```\n\"\"\"\nCollections.heapify!\n\ndoc\"\"\"\n    heappush!(v, x, [ord])\n\nGiven a binary heap-ordered array, push a new element `x`, preserving the heap property. For efficiency, this function does not check that the array is indeed heap-ordered.\n\"\"\"\nCollections.heappush!\n\ndoc\"\"\"\n    heappop!(v, [ord])\n\nGiven a binary heap-ordered array, remove and return the lowest ordered element. For efficiency, this function does not check that the array is indeed heap-ordered.\n\"\"\"\nCollections.heappop!\n\ndoc\"\"\"\n    heapify(v, [ord])\n\nReturn a new vector in binary heap order, optionally using the given ordering.\n\"\"\"\nCollections.heapify\n\ndoc\"\"\"\n    isheap(v, [ord])\n\nReturn `true` iff an array is heap-ordered according to the given order.\n\"\"\"\nCollections.isheap\n\n# Base.Test\n\ndoc\"\"\"\n    @test_throws(extype, ex)\n\nTest that the expression `ex` throws an exception of type `extype` and calls the current handler to handle the result.\n\"\"\"\n:(Test.@test_throws)\n\ndoc\"\"\"\n    @test_approx_eq_eps(a, b, tol)\n\nTest two floating point numbers `a` and `b` for equality taking in account a margin of tolerance given by `tol`.\n\"\"\"\n:(Test.@test_approx_eq_eps)\n\ndoc\"\"\"\n    @test(ex)\n\nTest the expression `ex` and calls the current handler to handle the result.\n\"\"\"\n:(Test.@test)\n\ndoc\"\"\"\n    @test_approx_eq(a, b)\n\nTest two floating point numbers `a` and `b` for equality taking in account small numerical errors.\n\"\"\"\n:(Test.@test_approx_eq)\n\ndoc\"\"\"\n    with_handler(f, handler)\n\nRun the function `f` using the `handler` as the handler.\n\"\"\"\nTest.with_handler\n\n# Base.Profile\n\ndoc\"\"\"\n```rst\n..  print([io::IO = STDOUT,] [data::Vector]; format = :tree, C = false, combine = true, cols = tty_cols(), maxdepth = typemax(Int), sortedby = :filefuncline)\n\nPrints profiling results to ``io`` (by default, ``STDOUT``). If you\ndo not supply a ``data`` vector, the internal buffer of accumulated\nbacktraces will be used.  ``format`` can be ``:tree`` or\n``:flat``. If ``C==true``, backtraces from C and Fortran code are\nshown. ``combine==true`` merges instruction pointers that\ncorrespond to the same line of code.  ``cols`` controls the width\nof the display. ``maxdepth`` can be used to limit the depth of printing in ``:tree``\nformat, while ``sortedby`` can be used to control the order in ``:flat``\nformat (``:filefuncline`` sorts by the source line, whereas ``:count``\nsorts in order of number of collected samples).\n```\n\"\"\"\nProfile.print(io::IO = STDOUT, data::Vector=?)\n\ndoc\"\"\"\n```rst\n..  print([io::IO = STDOUT,] data::Vector, lidict::Dict; kwargs)\n\nPrints profiling results to ``io``. This variant is used to examine\nresults exported by a previous call to :func:`retrieve`.\nSupply the vector ``data`` of backtraces and a dictionary\n``lidict`` of line information.\n\nSee ``Profile.print([io], data)`` for an explanation of the valid keyword arguments.\n```\n\"\"\"\nProfile.print(io::IO = STDOUT, data::Vector = ?, lidict::Dict = ?)\n\ndoc\"\"\"\n    init(; n::Integer, delay::Float64)\n\nConfigure the `delay` between backtraces (measured in seconds), and the number `n` of instruction pointers that may be stored. Each instruction pointer corresponds to a single line of code; backtraces generally consist of a long list of instruction pointers. Default settings can be obtained by calling this function with no arguments, and each can be set independently using keywords or in the order `(n, delay)`.\n\"\"\"\nProfile.init\n\ndoc\"\"\"\n```rst\n..  clear_malloc_data()\n\nClears any stored memory allocation data when running julia with\n``--track-allocation``.  Execute the command(s) you want to test\n(to force JIT-compilation), then call :func:`clear_malloc_data`.\nThen execute your command(s) again, quit Julia, and examine the\nresulting ``*.mem`` files.\n```\n\"\"\"\nProfile.clear_malloc_data\n\ndoc\"\"\"\n```rst\n..  callers(funcname, [data, lidict], [filename=<filename>], [linerange=<start:stop>]) -> Vector{Tuple{count, linfo}}\n\nGiven a previous profiling run, determine who called a particular\nfunction. Supplying the filename (and optionally, range of line\nnumbers over which the function is defined) allows you to\ndisambiguate an overloaded method. The returned value is a vector\ncontaining a count of the number of calls and line information\nabout the caller.  One can optionally supply backtrace data\nobtained from :func:`retrieve`; otherwise, the current internal profile\nbuffer is used.\n```\n\"\"\"\nProfile.callers\n\ndoc\"\"\"\n```rst\n..  fetch() -> data\n\nReturns a reference to the internal buffer of backtraces. Note that\nsubsequent operations, like :func:`clear`, can affect\n``data`` unless you first make a copy. Note that the values in\n``data`` have meaning only on this machine in the current session,\nbecause it depends on the exact memory addresses used in\nJIT-compiling. This function is primarily for internal use;\n:func:`retrieve` may be a better choice for most users.\n```\n\"\"\"\nProfile.fetch\n\ndoc\"\"\"\n    retrieve() -> data, lidict\n\n\"Exports\" profiling results in a portable format, returning the set of all backtraces (`data`) and a dictionary that maps the (session-specific) instruction pointers in `data` to `LineInfo` values that store the file name, function name, and line number. This function allows you to save profiling results for future analysis.\n\"\"\"\nProfile.retrieve\n\ndoc\"\"\"\n    clear()\n\nClear any existing backtraces from the internal buffer.\n\"\"\"\nProfile.clear\n\n# Base.Cartesian\n\ndoc\"\"\"\n    @nall N expr\n\n`@nall 3 d->(i_d > 1)` would generate the expression `(i_1 > 1 && i_2 > 1 && i_3 > 1)`. This can be convenient for bounds-checking.\n\"\"\"\n:(Cartesian.@nall)\n\ndoc\"\"\"\n    @nloops N itersym rangeexpr bodyexpr\n    @nloops N itersym rangeexpr preexpr bodyexpr\n    @nloops N itersym rangeexpr preexpr postexpr bodyexpr\n\nGenerate `N` nested loops, using `itersym` as the prefix for the iteration variables. `rangeexpr` may be an anonymous-function expression, or a simple symbol `var` in which case the range is `1:size(var,d)` for dimension `d`.\n\nOptionally, you can provide \"pre\" and \"post\" expressions. These get executed first and last, respectively, in the body of each loop. For example, :\n\n    @nloops 2 i A d->j_d=min(i_d,5) begin\n        s += @nref 2 A j\n    end\n\nwould generate :\n\n    for i_2 = 1:size(A, 2)\n        j_2 = min(i_2, 5)\n        for i_1 = 1:size(A, 1)\n            j_1 = min(i_1, 5)\n            s += A[j_1,j_2]\n        end\n    end\n\nIf you want just a post-expression, supply `nothing` for the pre-expression. Using parenthesis and semicolons, you can supply multi-statement expressions.\n\"\"\"\n:(Cartesian.@nloops)\n\ndoc\"\"\"\n    @ntuple N expr\n\nGenerates an `N`-tuple. `@ntuple 2 i` would generate `(i_1, i_2)`, and `@ntuple 2 k->k+1` would generate `(2,3)`.\n\"\"\"\n:(Cartesian.@ntuple)\n\ndoc\"\"\"\n    @nif N conditionexpr expr\n    @nif N conditionexpr expr elseexpr\n\nGenerates a sequence of `if ... elseif ... else ... end` statements. For example:\n\n    @nif 3 d->(i_d >= size(A,d)) d->(error(\"Dimension \", d, \" too big\")) d->println(\"All OK\")\n\nwould generate:\n\n    if i_1 > size(A, 1)\n        error(\"Dimension \", 1, \" too big\")\n    elseif i_2 > size(A, 2)\n        error(\"Dimension \", 2, \" too big\")\n    else\n        println(\"All OK\")\n    end\n\"\"\"\n:(Cartesian.@nif)\n\ndoc\"\"\"\n    @nref N A indexexpr\n\nGenerate expressions like `A[i_1,i_2,...]`. `indexexpr` can either be an iteration-symbol prefix, or an anonymous-function expression.\n\"\"\"\n:(Cartesian.@nref)\n\ndoc\"\"\"\n    @nexprs N expr\n\nGenerate `N` expressions. `expr` should be an anonymous-function expression.\n\"\"\"\n:(Cartesian.@nexprs)\n\n# Base\n\ndoc\"\"\"\n    @time\n\nA macro to execute an expression, printing the time it took to execute, the number of allocations, and the total number of bytes its execution caused to be allocated, before returning the value of the expression.\n\"\"\"\n:@time\n\ndoc\"\"\"\n    systemerror(sysfunc, iftrue)\n\nRaises a `SystemError` for `errno` with the descriptive string `sysfunc` if `iftrue` is `true`\n\"\"\"\nsystemerror\n\ndoc\"\"\"\n    writedlm(f, A, delim='\\\\t')\n\nWrite `A` (a vector, matrix or an iterable collection of iterable rows) as text to `f` (either a filename string or an `IO` stream) using the given delimeter `delim` (which defaults to tab, but can be any printable Julia object, typically a `Char` or `AbstractString`).\n\nFor example, two vectors `x` and `y` of the same length can be written as two columns of tab-delimited text to `f` by either `writedlm(f, [x y])` or by `writedlm(f, zip(x, y))`.\n\"\"\"\nwritedlm\n\ndoc\"\"\"\n    cholfact(A, [LU=:U[,pivot=Val{false}]][;tol=-1.0]) -> Cholesky\n\nCompute the Cholesky factorization of a dense symmetric positive (semi)definite matrix `A` and return either a `Cholesky` if `pivot==Val{false}` or `CholeskyPivoted` if `pivot==Val{true}`. `LU` may be `:L` for using the lower part or `:U` for the upper part. The default is to use `:U`. The triangular matrix can be obtained from the factorization `F` with: `F[:L]` and `F[:U]`. The following functions are available for `Cholesky` objects: `size`, `\\`, `inv`, `det`. For `CholeskyPivoted` there is also defined a `rank`. If `pivot==Val{false}` a `PosDefException` exception is thrown in case the matrix is not positive definite. The argument `tol` determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.\n\"\"\"\ncholfact(A, LU=:U, pivot=Val{false})\n\ndoc\"\"\"\n    cholfact(A; shift=0, perm=Int[]) -> CHOLMOD.Factor\n\nCompute the Cholesky factorization of a sparse positive definite matrix `A`. A fill-reducing permutation is used. `F = cholfact(A)` is most frequently used to solve systems of equations with `F\\b`, but also the methods `diag`, `det`, `logdet` are defined for `F`. You can also extract individual factors from `F`, using `F[:L]`. However, since pivoting is on by default, the factorization is internally represented as `A == P'*L*L'*P` with a permutation matrix `P`; using just `L` without accounting for `P` will give incorrect answers. To include the effects of permutation, it's typically preferable to extact \"combined\" factors like `PtL = F[:PtL]` (the equivalent of `P'*L`) and `LtP = F[:UP]` (the equivalent of `L'*P`).\n\nSetting optional `shift` keyword argument computes the factorization of `A+shift*I` instead of `A`. If the `perm` argument is nonempty, it should be a permutation of `1:size(A,1)` giving the ordering to use (instead of CHOLMOD's default AMD ordering).\n\nThe function calls the C library CHOLMOD and many other functions from the library are wrapped but not exported.\n\"\"\"\ncholfact(A)\n\ndoc\"\"\"\n    digamma(x)\n\nCompute the digamma function of `x` (the logarithmic derivative of `gamma(x)`)\n\"\"\"\ndigamma\n\ndoc\"\"\"\n    fill!(A, x)\n\nFill array `A` with the value `x`. If `x` is an object reference, all elements will refer to the same object. `fill!(A, Foo())` will return `A` filled with the result of evaluating `Foo()` once.\n\"\"\"\nfill!\n\ndoc\"\"\"\n    read!(stream, array::Array)\n\nRead binary data from a stream, filling in the argument `array`.\n\"\"\"\nread!\n\ndoc\"\"\"\n    empty!(collection) -> collection\n\nRemove all elements from a `collection`.\n\"\"\"\nempty!\n\ndoc\"\"\"\n    asin(x)\n\nCompute the inverse sine of `x`, where the output is in radians\n\"\"\"\nasin\n\ndoc\"\"\"\n    <:(T1, T2)\n\nSubtype operator, equivalent to `issubtype(T1,T2)`.\n\"\"\"\nBase.(:(<:))\n\ndoc\"\"\"\n    schedule(t::Task, [val]; error=false)\n\nAdd a task to the scheduler's queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as `wait`.\n\nIf a second argument is provided, it will be passed to the task (via the return value of `yieldto`) when it runs again. If `error` is `true`, the value is raised as an exception in the woken task.\n\"\"\"\nschedule\n\ndoc\"\"\"\n```rst\n..  step(r)\n\nGet the step size of a :obj:`Range` object.\n```\n\"\"\"\nstep\n\ndoc\"\"\"\n    utf32(s)\n\nCreate a UTF-32 string from a byte array, array of `Char` or `UInt32`, or any other string type. (Conversions of byte arrays check for a byte-order marker in the first four bytes, and do not include it in the resulting string.)\n\nNote that the resulting `UTF32String` data is terminated by the NUL codepoint (32-bit zero), which is not treated as a character in the string (so that it is mostly invisible in Julia); this allows the string to be passed directly to external functions requiring NUL-terminated data. This NUL is appended automatically by the `utf32(s)` conversion function. If you have a `Char` or `UInt32` array `A` that is already NUL-terminated UTF-32 data, then you can instead use `UTF32String(A)` to construct the string without making a copy of the data and treating the NUL as a terminator rather than as part of the string.\n\"\"\"\nutf32(s)\n\ndoc\"\"\"\n    utf32(::Union{Ptr{Char},Ptr{UInt32},Ptr{Int32}} [, length])\n\nCreate a string from the address of a NUL-terminated UTF-32 string. A copy is made; the pointer can be safely freed. If `length` is specified, the string does not have to be NUL-terminated.\n\"\"\"\nutf32(::Union{Ptr{Char},Ptr{UInt32},Ptr{Int32}}, length=?)\n\ndoc\"\"\"\n    takebuf_array(b::IOBuffer)\n\nObtain the contents of an `IOBuffer` as an array, without copying. Afterwards, the IOBuffer is reset to its initial state.\n\"\"\"\ntakebuf_array\n\ndoc\"\"\"\n    download(url,[localfile])\n\nDownload a file from the given url, optionally renaming it to the given local file name. Note that this function relies on the availability of external tools such as `curl`, `wget` or `fetch` to download the file and is provided for convenience. For production use or situations in which more options are needed, please use a package that provides the desired functionality instead.\n\"\"\"\ndownload\n\ndoc\"\"\"\n    @everywhere\n\nExecute an expression on all processes. Errors on any of the processes are collected into a `CompositeException` and thrown.\n\"\"\"\n:@everywhere\n\ndoc\"\"\"\n    lstrip(string, [chars])\n\nReturn `string` with any leading whitespace removed. If `chars` (a character, or vector or set of characters) is provided, instead remove characters contained in it.\n\"\"\"\nlstrip\n\ndoc\"\"\"\n    reenable_sigint(f::Function)\n\nRe-enable Ctrl-C handler during execution of a function. Temporarily reverses the effect of `disable_sigint`.\n\"\"\"\nreenable_sigint\n\ndoc\"\"\"\n    indmin(itr) -> Integer\n\nReturns the index of the minimum element in a collection.\n\"\"\"\nindmin\n\ndoc\"\"\"\n    powermod(x, p, m)\n\nCompute $x^p \\pmod m$.\n\"\"\"\npowermod\n\ndoc\"\"\"\n    typeintersect(T, S)\n\nCompute a type that contains the intersection of `T` and `S`. Usually this will be the smallest such type or one close to it.\n\"\"\"\ntypeintersect\n\ndoc\"\"\"\n    pointer(array [, index])\n\nGet the native address of an array or string element. Be careful to ensure that a julia reference to `a` exists as long as this pointer will be used. This function is \"unsafe\" like `unsafe_convert`.\n\nCalling `Ref(array[, index])` is generally preferable to this function.\n\"\"\"\npointer\n\ndoc\"\"\"\n    isnan(f) -> Bool\n\nTest whether a floating point number is not a number (NaN)\n\"\"\"\nisnan\n\ndoc\"\"\"\n```rst\n..  println(x)\n\nPrint (using :func:`print`) ``x`` followed by a newline.\n```\n\"\"\"\nprintln\n\ndoc\"\"\"\n    besselj(nu, x)\n\nBessel function of the first kind of order `nu`, $J_\\nu(x)$.\n\"\"\"\nbesselj\n\ndoc\"\"\"\n```rst\n..  @code_lowered\n\nEvaluates the arguments to the function call, determines their types, and calls :func:`code_lowered` on the resulting expression.\n```\n\"\"\"\n:@code_lowered\n\ndoc\"\"\"\n    //(num, den)\n\nDivide two integers or rational numbers, giving a `Rational` result.\n\"\"\"\nBase.(:(//))\n\ndoc\"\"\"\n    At_mul_B(A, B)\n\nFor matrices or vectors $A$ and $B$, calculates $A\u1d40\u22c5B$\n\"\"\"\nAt_mul_B\n\ndoc\"\"\"\n    methods(f, [types])\n\nReturns the method table for `f`.\n\nIf `types` is specified, returns an array of methods whose types match.\n\"\"\"\nmethods\n\ndoc\"\"\"\n```rst\n..  pmap(f, lsts...; err_retry=true, err_stop=false, pids=workers())\n\nTransform collections ``lsts`` by applying ``f`` to each element in parallel.\n(Note that ``f`` must be made available to all worker processes; see :ref:`Code Availability and Loading Packages <man-parallel-computing-code-availability>` for details.)\nIf ``nprocs() > 1``, the calling process will be dedicated to assigning tasks.\nAll other available processes will be used as parallel workers, or on the processes specified by ``pids``.\n\nIf ``err_retry`` is ``true``, it retries a failed application of ``f`` on a different worker.\nIf ``err_stop`` is ``true``, it takes precedence over the value of ``err_retry`` and ``pmap`` stops execution on the first error.\n```\n\"\"\"\npmap\n\ndoc\"\"\"\n    workers()\n\nReturns a list of all worker process identifiers.\n\"\"\"\nworkers\n\ndoc\"\"\"\n    isinteger(x) -> Bool\n\nTest whether `x` or all its elements are numerically equal to some integer\n\"\"\"\nisinteger\n\ndoc\"\"\"\n    sortrows(A, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])\n\nSort the rows of matrix `A` lexicographically.\n\"\"\"\nsortrows\n\ndoc\"\"\"\n    ./(x, y)\n\nElement-wise right division operator.\n\"\"\"\nBase.(:(./))\n\ndoc\"\"\"\n    IPv6(host::Integer) -> IPv6\n\nReturns IPv6 object from ip address formatted as Integer\n\"\"\"\nIPv6\n\ndoc\"\"\"\n    prod!(r, A)\n\nMultiply elements of `A` over the singleton dimensions of `r`, and write results to `r`.\n\"\"\"\nprod!\n\ndoc\"\"\"\n    hist2d!(counts, M, e1, e2) -> (e1, e2, counts)\n\nCompute a \"2d histogram\" with respect to the bins delimited by the edges given in `e1` and `e2`. This function writes the results to a pre-allocated array `counts`.\n\"\"\"\nhist2d!\n\ndoc\"\"\"\n    fieldtype(T, name::Symbol | index::Int)\n\nDetermine the declared type of a field (specified by name or index) in a composite DataType `T`.\n\"\"\"\nfieldtype\n\ndoc\"\"\"\n    hypot(x, y)\n\nCompute the $\\sqrt{x^2+y^2}$ avoiding overflow and underflow\n\"\"\"\nhypot\n\ndoc\"\"\"\n    airybi(x)\n\nAiry function $\\operatorname{Bi}(x)$.\n\"\"\"\nairybi\n\ndoc\"\"\"\n    gensym([tag])\n\nGenerates a symbol which will not conflict with other variable names.\n\"\"\"\ngensym\n\ndoc\"\"\"\n    cummin(A, [dim])\n\nCumulative minimum along a dimension. The dimension defaults to 1.\n\"\"\"\ncummin\n\ndoc\"\"\"\n    minabs!(r, A)\n\nCompute the minimum absolute values over the singleton dimensions of `r`, and write values to `r`.\n\"\"\"\nminabs!\n\ndoc\"\"\"\n    prevprod([k_1,k_2,...], n)\n\nPrevious integer not greater than `n` that can be written as $\\prod k_i^{p_i}$ for integers $p_1$, $p_2$, etc.\n\"\"\"\nprevprod\n\ndoc\"\"\"\n    @evalpoly(z, c...)\n\nEvaluate the polynomial $\\sum_k c[k] z^{k-1}$ for the\ncoefficients `c[1]`, `c[2]`, ...; that is, the coefficients are\ngiven in ascending order by power of `z`.  This macro expands to\nefficient inline code that uses either Horner's method or, for\ncomplex `z`, a more efficient Goertzel-like algorithm.\n\"\"\"\n:@evalpoly\n\ndoc\"\"\"\n```rst\n..  eigfact!(A, [B])\n\nSame as :func:`eigfact`, but saves space by overwriting the input ``A`` (and\n``B``), instead of creating a copy.\n```\n\"\"\"\neigfact!\n\ndoc\"\"\"\n    cosh(x)\n\nCompute hyperbolic cosine of `x`\n\"\"\"\ncosh\n\ndoc\"\"\"\n```rst\n..  ipermutedims(A, perm)\n\nLike :func:`permutedims`, except the inverse of the given permutation is applied.\n```\n\"\"\"\nipermutedims\n\ndoc\"\"\"\n    dirname(path::AbstractString) -> AbstractString\n\nGet the directory part of a path.\n\"\"\"\ndirname\n\ndoc\"\"\"\n    isfile(path) -> Bool\n\nReturns `true` if `path` is a regular file, `false` otherwise.\n\"\"\"\nisfile\n\ndoc\"\"\"\n    symlink(target, link)\n\nCreates a symbolic link to `target` with the name `link`.\n\n**note**\n\nThis function raises an error under operating systems that do not support soft symbolic links, such as Windows XP.\n\"\"\"\nsymlink\n\ndoc\"\"\"\n    task_local_storage(symbol)\n\nLook up the value of a symbol in the current task's task-local storage.\n\"\"\"\ntask_local_storage(symbol)\n\ndoc\"\"\"\n    task_local_storage(symbol, value)\n\nAssign a value to a symbol in the current task's task-local storage.\n\"\"\"\ntask_local_storage(symbol, value)\n\ndoc\"\"\"\n    task_local_storage(body, symbol, value)\n\nCall the function `body` with a modified task-local storage, in which `value` is assigned to `symbol`; the previous value of `symbol`, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.\n\"\"\"\ntask_local_storage(body, symbol, value)\n\ndoc\"\"\"\n    diff(A, [dim])\n\nFinite difference operator of matrix or vector.\n\"\"\"\ndiff\n\ndoc\"\"\"\n    precision(num::AbstractFloat)\n\nGet the precision of a floating point number, as defined by the effective number of bits in the mantissa.\n\"\"\"\nprecision\n\ndoc\"\"\"\n    cor(v1[, v2][, vardim=1, mean=nothing])\n\nCompute the Pearson correlation between the vector(s) in `v1` and `v2`.\n\nUsers can use the keyword argument `vardim` to specify the variable dimension, and `mean` to supply pre-computed mean values.\n\"\"\"\ncor\n\ndoc\"\"\"\n    partitions(n)\n\nGenerate all integer arrays that sum to `n`. Because the number of partitions can be very large, this function returns an iterator object. Use `collect(partitions(n))` to get an array of all partitions. The number of partitions to generate can be efficiently computed using `length(partitions(n))`.\n\"\"\"\npartitions(n::Integer)\n\ndoc\"\"\"\n    partitions(n, m)\n\nGenerate all arrays of `m` integers that sum to `n`. Because the number of partitions can be very large, this function returns an iterator object. Use `collect(partitions(n,m))` to get an array of all partitions. The number of partitions to generate can be efficiently computed using `length(partitions(n,m))`.\n\"\"\"\npartitions(n::Integer, m::Integer)\n\ndoc\"\"\"\n    partitions(array)\n\nGenerate all set partitions of the elements of an array, represented as arrays of arrays. Because the number of partitions can be very large, this function returns an iterator object. Use `collect(partitions(array))` to get an array of all partitions. The number of partitions to generate can be efficiently computed using `length(partitions(array))`.\n\"\"\"\npartitions(array)\n\ndoc\"\"\"\n    partitions(array, m)\n\nGenerate all set partitions of the elements of an array into exactly m subsets, represented as arrays of arrays. Because the number of partitions can be very large, this function returns an iterator object. Use `collect(partitions(array,m))` to get an array of all partitions. The number of partitions into m subsets is equal to the Stirling number of the second kind and can be efficiently computed using `length(partitions(array,m))`.\n\"\"\"\npartitions(array, m::Integer)\n\ndoc\"\"\"\n    readlines(stream)\n\nRead all lines as an array.\n\"\"\"\nreadlines\n\ndoc\"\"\"\n    findnz(A)\n\nReturn a tuple `(I, J, V)` where `I` and `J` are the row and column indexes of the non-zero values in matrix `A`, and `V` is a vector of the non-zero values.\n\"\"\"\nfindnz\n\ndoc\"\"\"\n    RemoteRef()\n\nMake an uninitialized remote reference on the local machine.\n\"\"\"\nRemoteRef()\n\ndoc\"\"\"\n    RemoteRef(n)\n\nMake an uninitialized remote reference on process `n`.\n\"\"\"\nRemoteRef(::Integer)\n\ndoc\"\"\"\n```rst\n..  foldl(op, v0, itr)\n\nLike :func:`reduce`, but with guaranteed left associativity. ``v0``\nwill be used exactly once.\n```\n\"\"\"\nfoldl(op, v0, itr)\n\ndoc\"\"\"\n```rst\n..  foldl(op, itr)\n\nLike ``foldl(op, v0, itr)``, but using the first element of ``itr``\nas ``v0``. In general, this cannot be used with empty collections\n(see ``reduce(op, itr)``).\n```\n\"\"\"\nfoldl(op, itr)\n\ndoc\"\"\"\n    airybiprime(x)\n\nAiry function derivative $\\operatorname{Bi}'(x)$.\n\"\"\"\nairybiprime\n\ndoc\"\"\"\n    Ac_rdiv_B(A, B)\n\nFor matrices or vectors $A$ and $B$, calculates $A\u1d34 / B$\n\"\"\"\nAc_rdiv_B\n\ndoc\"\"\"\n```rst\n..  set_rounding(T, mode)\n\nSet the rounding mode of floating point type ``T``, controlling the\nrounding of basic arithmetic functions (:func:`+`, :func:`-`, :func:`*`,\n:func:`/` and :func:`sqrt`) and type conversion.\n\nNote that this may affect other types, for instance changing the rounding\nmode of ``Float64`` will change the rounding mode of ``Float32``. See\n``get_rounding`` for available modes\n```\n\"\"\"\nset_rounding\n\ndoc\"\"\"\n    linspace(start, stop, n=100)\n\nConstruct a range of `n` linearly spaced elements from `start` to `stop`.\n\"\"\"\nlinspace\n\ndoc\"\"\"\n    promote_type(type1, type2)\n\nDetermine a type big enough to hold values of each argument type without loss, whenever possible. In some cases, where no type exists to which both types can be promoted losslessly, some loss is tolerated; for example, `promote_type(Int64,Float64)` returns `Float64` even though strictly, not all `Int64` values can be represented exactly as `Float64` values.\n\"\"\"\npromote_type\n\ndoc\"\"\"\n    ind2sub(dims, index) -> subscripts\n\nReturns a tuple of subscripts into an array with dimensions `dims`,\ncorresponding to the linear index `index`.\n\n**Example**: `i, j, ... = ind2sub(size(A), indmax(A))` provides the\nindices of the maximum element\n\"\"\"\nind2sub(dims::Tuple, index::Int)\n\ndoc\"\"\"\n    ind2sub(a, index) -> subscripts\n\nReturns a tuple of subscripts into array `a` corresponding to the linear index `index`\n\"\"\"\nind2sub(a, index)\n\ndoc\"\"\"\n    .*(x, y)\n\nElement-wise multiplication operator.\n\"\"\"\nBase.(:(.*))\n\ndoc\"\"\"\n    ror!(dest::BitArray{1}, src::BitArray{1}, i::Integer) -> BitArray{1}\n\nPerforms a right rotation operation on `src` and put the result into `dest`.\n\"\"\"\nror!(dest::BitArray{1}, src::BitArray{1}, i::Integer)\n\ndoc\"\"\"\n    ror!(B::BitArray{1}, i::Integer) -> BitArray{1}\n\nPerforms a right rotation operation on `B`.\n\"\"\"\nror!(B::BitArray{1}, i::Integer)\n\ndoc\"\"\"\n    range(start, [step], length)\n\nConstruct a range by length, given a starting value and optional step (defaults to 1).\n\"\"\"\nrange\n\ndoc\"\"\"\n    eltype(type)\n\nDetermine the type of the elements generated by iterating a collection of the given `type`. For associative collection types, this will be a `Pair{KeyType,ValType}`. The definition `eltype(x) = eltype(typeof(x))` is provided for convenience so that instances can be passed instead of types. However the form that accepts a type argument should be defined for new types.\n\"\"\"\neltype\n\ndoc\"\"\"\n    keytype(collection)\n\nFor associative collection types, this will be the type of the Key, This is not defined for non-associative collections\n\"\"\"\nkeytype\n\ndoc\"\"\"\n    valtype(collection)\n\nFor associative collection types, this will be the type of the Value, This is not defined for non-associative collections\n\"\"\"\nvaltype\n\ndoc\"\"\"\n    edit(file::AbstractString, [line])\n\nEdit a file optionally providing a line number to edit at. Returns to the julia prompt when you quit the editor.\n\"\"\"\nedit(file::AbstractString, line=?)\n\ndoc\"\"\"\n    edit(function, [types])\n\nEdit the definition of a function, optionally specifying a tuple of types to indicate which method to edit.\n\"\"\"\nedit(::Function, types=?)\n\ndoc\"\"\"\n    backtrace()\n\nGet a backtrace object for the current program point.\n\"\"\"\nbacktrace\n\ndoc\"\"\"\n    ignorestatus(command)\n\nMark a command object so that running it will not throw an error if the result code is non-zero.\n\"\"\"\nignorestatus\n\ndoc\"\"\"\n    reducedim(f, A, dims[, initial])\n\nReduce 2-argument function `f` along dimensions of `A`. `dims` is a vector specifying the dimensions to reduce, and `initial` is the initial value to use in the reductions. For `+`, `*`, `max` and `min` the `initial` argument is optional.\n\nThe associativity of the reduction is implementation-dependent; if you need a particular associativity, e.g. left-to-right, you should write your own loop. See documentation for `reduce`.\n\"\"\"\nreducedim\n\ndoc\"\"\"\n    -(x)\n\nUnary minus operator.\n\"\"\"\n-(x)\n\ndoc\"\"\"\n    -(x, y)\n\nSubtraction operator.\n\"\"\"\n-(x, y)\n\ndoc\"\"\"\n```rst\n..  mapfoldr(f, op, v0, itr)\n\nLike :func:`mapreduce`, but with guaranteed right associativity. ``v0``\nwill be used exactly once.\n```\n\"\"\"\nmapfoldr(f, op, v0, itr)\n\ndoc\"\"\"\n```rst\n..  mapfoldr(f, op, itr)\n\nLike ``mapfoldr(f, op, v0, itr)``, but using the first element of\n``itr`` as ``v0``. In general, this cannot be used with empty\ncollections (see ``reduce(op, itr)``).\n```\n\"\"\"\nmapfoldr(f, op, itr)\n\ndoc\"\"\"\n    broadcast_setindex!(A, X, inds...)\n\nBroadcasts the `X` and `inds` arrays to a common size and stores the value from each position in `X` at the indices given by the same positions in `inds`.\n\"\"\"\nbroadcast_setindex!\n\ndoc\"\"\"\n    Nullable(x)\n\nWrap value `x` in an object of type `Nullable`, which indicates whether a value is present. `Nullable(x)` yields a non-empty wrapper, and `Nullable{T}()` yields an empty instance of a wrapper that might contain a value of type `T`.\n\"\"\"\nNullable\n\ndoc\"\"\"\n    bits(n)\n\nA string giving the literal bit representation of a number.\n\"\"\"\nbits\n\ndoc\"\"\"\n    launch(manager::FooManager, params::Dict, launched::Vector{WorkerConfig}, launch_ntfy::Condition)\n\nImplemented by cluster managers. For every Julia worker launched by this function, it should append a `WorkerConfig` entry to `launched` and notify `launch_ntfy`. The function MUST exit once all workers, requested by `manager` have been launched. `params` is a dictionary of all keyword arguments `addprocs` was called with.\n\"\"\"\nlaunch\n\ndoc\"\"\"\n```rst\n..  @code_typed\n\nEvaluates the arguments to the function call, determines their types, and calls :func:`code_typed` on the resulting expression.\n```\n\"\"\"\n:@code_typed\n\ndoc\"\"\"\n    invdigamma(x)\n\nCompute the inverse digamma function of `x`.\n\"\"\"\ninvdigamma\n\ndoc\"\"\"\n```rst\n..  getindex(type[, elements...])\n\nConstruct a 1-d array of the specified type. This is usually called with the syntax ``Type[]``. Element values can be specified using ``Type[a,b,c,...]``.\n```\n\"\"\"\ngetindex(::Type, elements...)\n\ndoc\"\"\"\n```rst\n..  getindex(A, inds...)\n\nReturns a subset of array ``A`` as specified by ``inds``, where each ``ind`` may be an ``Int``, a ``Range``, or a ``Vector``. See the manual section on :ref:`array indexing <man-array-indexing>` for details.\n```\n\"\"\"\ngetindex(::AbstractArray, inds...)\n\ndoc\"\"\"\n```rst\n..  getindex(collection, key...)\n\nRetrieve the value(s) stored at the given key or index within a collection.\nThe syntax ``a[i,j,...]`` is converted by the compiler to\n``getindex(a, i, j, ...)``.\n```\n\"\"\"\ngetindex(collection, key...)\n\ndoc\"\"\"\n    cconvert(T,x)\n\nConvert `x` to a value of type `T`, typically by calling `convert(T,x)`\n\nIn cases where `x` cannot be safely converted to `T`, unlike `convert`, `cconvert` may return an object of a type different from `T`, which however is suitable for `unsafe_convert` to handle.\n\nNeither `convert` nor `cconvert` should take a Julia object and turn it into a `Ptr`.\n\"\"\"\ncconvert\n\ndoc\"\"\"\n    |>(x, f)\n\nApplies a function to the preceding argument. This allows for easy function chaining.\n\n```jldoctest\njulia> [1:5;] |> x->x.^2 |> sum |> inv\n0.01818181818181818\n```\n\"\"\"\nBase.(:(|>))\n\ndoc\"\"\"\n    assert(cond)\n\nThrow an `AssertionError` if `cond` is `false`. Also available as the macro `@assert expr`.\n\"\"\"\nassert\n\ndoc\"\"\"\n    sech(x)\n\nCompute the hyperbolic secant of `x`\n\"\"\"\nsech\n\ndoc\"\"\"\n    nworkers()\n\nGet the number of available worker processes. This is one less than `nprocs()`. Equal to `nprocs()` if `nprocs() == 1`.\n\"\"\"\nnworkers\n\ndoc\"\"\"\n    filemode(file)\n\nEquivalent to `stat(file).mode`\n\"\"\"\nfilemode\n\ndoc\"\"\"\n    print_joined(io, items, delim, [last])\n\nPrint elements of `items` to `io` with `delim` between them. If `last` is specified, it is used as the final delimiter instead of `delim`.\n\"\"\"\nprint_joined\n\ndoc\"\"\"\n    lfact(x)\n\nCompute the logarithmic factorial of `x`\n\"\"\"\nlfact\n\ndoc\"\"\"\n    deconv(b,a)\n\nConstruct vector `c` such that `b = conv(a,c) + r`. Equivalent to polynomial division.\n\"\"\"\ndeconv\n\ndoc\"\"\"\n    insert!(collection, index, item)\n\nInsert an `item` into `collection` at the given `index`.\n`index` is the index of `item` in the resulting `collection`.\n\n```jldoctest\njulia> insert!([6, 5, 4, 2, 1], 4, 3)\n6-element Array{Int64,1}:\n 6\n 5\n 4\n 3\n 2\n 1\n```\n\"\"\"\ninsert!\n\ndoc\"\"\"\n    repmat(A, n, m)\n\nConstruct a matrix by repeating the given matrix `n` times in dimension 1 and `m` times in dimension 2.\n\"\"\"\nrepmat\n\ndoc\"\"\"\n    acos(x)\n\nCompute the inverse cosine of `x`, where the output is in radians\n\"\"\"\nacos\n\ndoc\"\"\"\n    ispath(path) -> Bool\n\nReturns `true` if `path` is a valid filesystem path, `false` otherwise.\n\"\"\"\nispath\n\ndoc\"\"\"\n    fdio([name::AbstractString, ]fd::Integer[, own::Bool]) -> IOStream\n\nCreate an `IOStream` object from an integer file descriptor. If `own` is `true`, closing this object will close the underlying descriptor. By default, an `IOStream` is closed when it is garbage collected. `name` allows you to associate the descriptor with a named file.\n\"\"\"\nfdio\n\ndoc\"\"\"\n    unsafe_copy!(dest::Ptr{T}, src::Ptr{T}, N)\n\nCopy `N` elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.\n\nThe `unsafe` prefix on this function indicates that no validation is performed on the pointers `dest` and `src` to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\"\"\"\nunsafe_copy!{T}(dest::Ptr{T}, src::Ptr{T}, N)\n\ndoc\"\"\"\n    unsafe_copy!(dest::Array, do, src::Array, so, N)\n\nCopy `N` elements from a source array to a destination, starting at offset `so` in the source and `do` in the destination (1-indexed).\n\nThe `unsafe` prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\"\"\"\nunsafe_copy!(dest::Array, d, src::Array, so, N)\n\ndoc\"\"\"\n    diag(M[, k])\n\nThe `k`th diagonal of a matrix, as a vector. Use `diagm` to construct a diagonal matrix.\n\"\"\"\ndiag\n\ndoc\"\"\"\n    .^(x, y)\n\nElement-wise exponentiation operator.\n\"\"\"\nBase.(:(.^))\n\ndoc\"\"\"\n    isspace(c::Union{Char,AbstractString}) -> Bool\n\nTests whether a character is any whitespace character. Includes ASCII characters '\\\\t', '\\\\n', '\\\\v', '\\\\f', '\\\\r', and ' ', Latin-1 character U+0085, and characters in Unicode category Zs. For strings, tests whether this is true for all elements of the string.\n\"\"\"\nisspace\n\ndoc\"\"\"\n    splitext(path::AbstractString) -> (AbstractString,AbstractString)\n\nIf the last component of a path contains a dot, split the path into everything before the dot and everything including and after the dot. Otherwise, return a tuple of the argument unmodified and the empty string.\n\"\"\"\nsplitext\n\ndoc\"\"\"\n    gethostname() -> AbstractString\n\nGet the local machine's host name.\n\"\"\"\ngethostname\n\ndoc\"\"\"\n    code_typed(f, types; optimize=true)\n\nReturns an array of lowered and type-inferred ASTs for the methods matching the given generic function and type signature. The keyword argument `optimize` controls whether additional optimizations, such as inlining, are also applied.\n\"\"\"\ncode_typed\n\ndoc\"\"\"\n    hankelh1x(nu, x)\n\nScaled Bessel function of the third kind of order `nu`, $H^{(1)}_\\nu(x) e^{-x i}$.\n\"\"\"\nhankelh1x\n\ndoc\"\"\"\n    replace(string, pat, r[, n])\n\nSearch for the given pattern `pat`, and replace each occurrence with `r`. If `n` is provided, replace at most `n` occurrences. As with search, the second argument may be a single character, a vector or a set of characters, a string, or a regular expression. If `r` is a function, each occurrence is replaced with `r(s)` where `s` is the matched substring. If `pat` is a regular expression and `r` is a `SubstitutionString`, then capture group references in `r` are replaced with the corresponding matched text.\n\"\"\"\nreplace\n\ndoc\"\"\"\n    randexp([rng], [dims...])\n\nGenerate a random number according to the exponential distribution with scale 1. Optionally generate an array of such random numbers.\n\"\"\"\nrandexp\n\ndoc\"\"\"\n    chop(string)\n\nRemove the last character from a string.\n\"\"\"\nchop\n\ndoc\"\"\"\n    Float32(x [, mode::RoundingMode])\n\nCreate a Float32 from `x`. If `x` is not exactly representable then\n`mode` determines how `x` is rounded.\n\n```jldoctest\njulia> Float32(1/3, RoundDown)\n0.3333333f0\n\njulia> Float32(1/3, RoundUp)\n0.33333334f0\n```\n\nSee `get_rounding` for available rounding modes.\n\"\"\"\nFloat32\n\ndoc\"\"\"\n    readuntil(stream, delim)\n\nRead a string, up to and including the given delimiter byte.\n\"\"\"\nreaduntil\n\ndoc\"\"\"\n```rst\n..  isimmutable(v)\n\nReturn ``true`` iff value ``v`` is immutable.  See :ref:`man-immutable-composite-types` for a discussion of immutability.\nNote that this function works on values, so if you give it a type, it will tell you that a value of ``DataType`` is mutable.\n```\n\"\"\"\nisimmutable\n\ndoc\"\"\"\n    macroexpand(x)\n\nTakes the expression `x` and returns an equivalent expression with all macros removed (expanded).\n\"\"\"\nmacroexpand\n\ndoc\"\"\"\n    issticky(path) -> Bool\n\nReturns `true` if `path` has the sticky bit set, `false` otherwise.\n\"\"\"\nissticky\n\ndoc\"\"\"\n    rol(B::BitArray{1}, i::Integer) -> BitArray{1}\n\nPerforms a left rotation operation.\n\"\"\"\nrol\n\ndoc\"\"\"\n```rst\n..  Mmap.mmap(io::Union{IOStream,AbstractString,Mmap.AnonymousMmap}[, type::Type{Array{T,N}}, dims, offset]; grow::Bool=true, shared::Bool=true)\n           Mmap.mmap(type::Type{Array{T,N}}, dims)\n\nCreate an ``Array`` whose values are linked to a file, using memory-mapping. This provides a convenient way of working with data too large to fit in the computer's memory.\n\nThe type is an ``Array{T,N}`` with a bits-type element of ``T`` and dimension ``N`` that determines how the bytes of the array are interpreted. Note that the file must be stored in binary format, and no format conversions are possible (this is a limitation of operating systems, not Julia).\n\n``dims`` is a tuple or single ``Integer`` specifying the size or length of the array.\n\nThe file is passed via the stream argument, either as an open ``IOStream`` or filename string.  When you initialize the stream, use ``\"r\"`` for a \"read-only\" array, and ``\"w+\"`` to create a new array used to write values to disk.\n\nIf no ``type`` argument is specified, the default is ``Vector{UInt8}``.\n\nOptionally, you can specify an offset (in bytes) if, for example, you want to skip over a header in the file. The default value for the offset is the current stream position for an ``IOStream``.\n\nThe ``grow`` keyword argument specifies whether the disk file should be grown to accommodate the requested size of array (if the total file size is < requested array size). Write privileges are required to grow the file.\n\nThe ``shared`` keyword argument specifies whether the resulting ``Array`` and changes made to it will be visible to other processes mapping the same file.\n\nFor example, the following code::\n\n   # Create a file for mmapping\n   # (you could alternatively use mmap to do this step, too)\n   A = rand(1:20, 5, 30)\n   s = open(\"/tmp/mmap.bin\", \"w+\")\n   # We'll write the dimensions of the array as the first two Ints in the file\n   write(s, size(A,1))\n   write(s, size(A,2))\n   # Now write the data\n   write(s, A)\n   close(s)\n\n   # Test by reading it back in\n   s = open(\"/tmp/mmap.bin\")   # default is read-only\n   m = read(s, Int)\n   n = read(s, Int)\n   A2 = Mmap.mmap(s, Matrix{Int}, (m,n))\n\ncreates a ``m``-by-``n`` ``Matrix{Int}``, linked to the file associated with stream ``s``.\n\nA more portable file would need to encode the word size---32 bit or 64 bit---and endianness information in the header. In practice, consider encoding binary data using standard formats like HDF5 (which can be used with memory-mapping).\n```\n\"\"\"\nMmap.mmap(io, ::Type, dims, offset)\n\ndoc\"\"\"\n```rst\n..  Mmap.mmap(io, BitArray, [dims, offset])\n\nCreate a ``BitArray`` whose values are linked to a file, using memory-mapping; it has the same purpose, works in the same way, and has the same arguments, as :func:`mmap`, but the byte representation is different.\n\n**Example**:  ``B = Mmap.mmap(s, BitArray, (25,30000))``\n\nThis would create a 25-by-30000 ``BitArray``, linked to the file associated with stream ``s``.\n```\n\"\"\"\nMmap.mmap(io, ::BitArray, dims = ?, offset = ?)\n\ndoc\"\"\"\n    airyprime(x)\n\nAiry function derivative $\\operatorname{Ai}'(x)$.\n\"\"\"\nairyprime\n\ndoc\"\"\"\n    bessely0(x)\n\nBessel function of the second kind of order 0, $Y_0(x)$.\n\"\"\"\nbessely0\n\ndoc\"\"\"\n    any!(r, A)\n\nTest whether any values in `A` along the singleton dimensions of `r` are `true`, and write results to `r`.\n\"\"\"\nany!\n\ndoc\"\"\"\n    falses(dims)\n\nCreate a `BitArray` with all values set to `false`\n\"\"\"\nfalses\n\ndoc\"\"\"\n    filter!(function, collection)\n\nUpdate `collection`, removing elements for which `function` is `false`. For associative collections, the function is passed two arguments (key and value).\n\"\"\"\nfilter!\n\ndoc\"\"\"\n    schurfact(A) -> Schur\n\nComputes the Schur factorization of the matrix `A`. The (quasi) triangular Schur factor can be obtained from the `Schur` object `F` with either `F[:Schur]` or `F[:T]` and the unitary/orthogonal Schur vectors can be obtained with `F[:vectors]` or `F[:Z]` such that `A=F[:vectors]*F[:Schur]*F[:vectors]'`. The eigenvalues of `A` can be obtained with `F[:values]`.\n\"\"\"\nschurfact(A)\n\ndoc\"\"\"\n    schurfact(A, B) -> GeneralizedSchur\n\nComputes the Generalized Schur (or QZ) factorization of the matrices `A` and `B`. The (quasi) triangular Schur factors can be obtained from the `Schur` object `F` with `F[:S]` and `F[:T]`, the left unitary/orthogonal Schur vectors can be obtained with `F[:left]` or `F[:Q]` and the right unitary/orthogonal Schur vectors can be obtained with `F[:right]` or `F[:Z]` such that `A=F[:left]*F[:S]*F[:right]'` and `B=F[:left]*F[:T]*F[:right]'`. The generalized eigenvalues of `A` and `B` can be obtained with `F[:alpha]./F[:beta]`.\n\"\"\"\nschurfact(A, B)\n\ndoc\"\"\"\n    base64decode(string)\n\nDecodes the base64-encoded `string` and returns a `Vector{UInt8}` of the decoded bytes.\n\"\"\"\nbase64decode\n\ndoc\"\"\"\n    besselkx(nu, x)\n\nScaled modified Bessel function of the second kind of order `nu`, $K_\\nu(x) e^x$.\n\"\"\"\nbesselkx\n\ndoc\"\"\"\n    myid()\n\nGet the id of the current process.\n\"\"\"\nmyid\n\ndoc\"\"\"\n    oct(n, [pad])\n\nConvert an integer to an octal string, optionally specifying a number of digits to pad to.\n\"\"\"\noct\n\ndoc\"\"\"\n    timedwait(testcb::Function, secs::Float64; pollint::Float64=0.1)\n\nWaits till `testcb` returns `true` or for `secs` seconds, whichever is earlier. `testcb` is polled every `pollint` seconds.\n\"\"\"\ntimedwait\n\ndoc\"\"\"\n    sizeof(T)\n\nSize, in bytes, of the canonical binary representation of the given DataType `T`, if any.\n\"\"\"\nsizeof(::Type)\n\ndoc\"\"\"\n    sizeof(s::AbstractString)\n\nThe number of bytes in string `s`.\n\"\"\"\nsizeof(::AbstractString)\n\ndoc\"\"\"\n```rst\n..  ===(x, y)\n           \u2261(x,y)\n\nSee the :func:`is` operator\n```\n\"\"\"\nBase.(:(===))\n\ndoc\"\"\"\n    ReadOnlyMemoryError()\n\nAn operation tried to write to memory that is read-only.\n\"\"\"\nReadOnlyMemoryError\n\ndoc\"\"\"\n    startswith(string, prefix | chars)\n\nReturns `true` if `string` starts with `prefix`. If the second argument is a vector or set of characters, tests whether the first character of `string` belongs to that set.\n\"\"\"\nstartswith\n\ndoc\"\"\"\n    permutedims!(dest, src, perm)\n\nPermute the dimensions of array `src` and store the result in the array `dest`. `perm` is a vector specifying a permutation of length `ndims(src)`. The preallocated array `dest` should have `size(dest) == size(src)[perm]` and is completely overwritten. No in-place permutation is supported and unexpected results will happen if `src` and `dest` have overlapping memory regions.\n\"\"\"\npermutedims!\n\ndoc\"\"\"\n    functionloc(f::Function, types)\n\nReturns a tuple `(filename,line)` giving the location of a generic `Function` definition.\n\"\"\"\nfunctionloc(f, types)\n\ndoc\"\"\"\n    functionloc(m::Method)\n\nReturns a tuple `(filename,line)` giving the location of a `Method` definition.\n\"\"\"\nfunctionloc(m)\n\ndoc\"\"\"\n    stride(A, k)\n\nReturns the distance in memory (in number of elements) between adjacent elements in dimension `k`.\n\"\"\"\nstride\n\ndoc\"\"\"\n```rst\n..  last(coll)\n\nGet the last element of an ordered collection, if it can be computed in O(1) time.\nThis is accomplished by calling :func:`endof` to get the last index.\nReturns the end point of a :obj:`Range` even if it is empty.\n```\n\"\"\"\nlast\n\ndoc\"\"\"\n    islink(path) -> Bool\n\nReturns `true` if `path` is a symbolic link, `false` otherwise.\n\"\"\"\nislink\n\ndoc\"\"\"\n    istril(A) -> Bool\n\nTest whether a matrix is lower triangular.\n\"\"\"\nistril\n\ndoc\"\"\"\n```rst\n..  lgamma(x)\n\nCompute the logarithm of the absolute value of :func:`gamma` for\n:obj:`Real` ``x``, while for :obj:`Complex` ``x`` it computes the\nlogarithm of ``gamma(x)``.\n```\n\"\"\"\nlgamma\n\ndoc\"\"\"\n    bin(n, [pad])\n\nConvert an integer to a binary string, optionally specifying a number of digits to pad to.\n\"\"\"\nbin\n\ndoc\"\"\"\n    cis(z)\n\nReturn $\\exp(iz)$.\n\"\"\"\ncis\n\ndoc\"\"\"\n    isapprox(x, y; rtol::Real=sqrt(eps), atol::Real=0)\n\nInexact equality comparison: `true` if `norm(x-y) <= atol + rtol*max(norm(x), norm(y))`. The default `atol` is zero and the default `rtol` depends on the types of `x` and `y`.\n\nFor real or complex floating-point values, `rtol` defaults to `sqrt(eps(typeof(real(x-y))))`. This corresponds to requiring equality of about half of the significand digits. For other types, `rtol` defaults to zero.\n\n`x` and `y` may also be arrays of numbers, in which case `norm` defaults to `vecnorm` but may be changed by passing a `norm::Function` keyword argument. (For numbers, `norm` is the same thing as `abs`.)\n\nThe binary operator `\u2248` is equivalent to `isapprox` with the default arguments, and `x \u2249 y` is equivalent to `!isapprox(x,y)`.\n\"\"\"\nisapprox\n\ndoc\"\"\"\n    primes([lo,] hi)\n\nReturns a collection of the prime numbers (from `lo`, if specified) up to `hi`.\n\"\"\"\nprimes\n\ndoc\"\"\"\n    primesmask([lo,] hi)\n\nReturns a prime sieve, as a `BitArray`, of the positive integers (from `lo`, if specified) up to `hi`. Useful when working with either primes or composite numbers.\n\"\"\"\nprimesmask\n\ndoc\"\"\"\n    sinh(x)\n\nCompute hyperbolic sine of `x`\n\"\"\"\nsinh\n\ndoc\"\"\"\n    permutations(array)\n\nGenerate all permutations of an indexable object. Because the number of permutations can be very large, this function returns an iterator object. Use `collect(permutations(array))` to get an array of all permutations.\n\"\"\"\npermutations\n\ndoc\"\"\"\n```rst\n..  ceil([T,] x, [digits, [base]])\n\n``ceil(x)`` returns the nearest integral value of the same type as ``x``\nthat is greater than or equal to ``x``.\n\n``ceil(T, x)`` converts the result to type ``T``, throwing an\n``InexactError`` if the value is not representable.\n\n``digits`` and ``base`` work as for :func:`round`.\n```\n\"\"\"\nceil\n\ndoc\"\"\"\n    mapslices(f, A, dims)\n\nTransform the given dimensions of array `A` using function `f`. `f` is called on each slice of `A` of the form `A[...,:,...,:,...]`. `dims` is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if `dims` is `[1,2]` and `A` is 4-dimensional, `f` is called on `A[:,:,i,j]` for all `i` and `j`.\n\"\"\"\nmapslices\n\ndoc\"\"\"\n    svdvals(A)\n\nReturns the singular values of `A`.\n\"\"\"\nsvdvals(A)\n\ndoc\"\"\"\n    svdvals(A, B)\n\nReturn only the singular values from the generalized singular value decomposition of `A` and `B`.\n\"\"\"\nsvdvals(A, B)\n\ndoc\"\"\"\n    issocket(path) -> Bool\n\nReturns `true` if `path` is a socket, `false` otherwise.\n\"\"\"\nissocket\n\ndoc\"\"\"\n    srand([rng], [seed])\n\nReseed the random number generator. If a `seed` is provided, the RNG will give a reproducible sequence of numbers, otherwise Julia will get entropy from the system. For `MersenneTwister`, the `seed` may be a non-negative integer, a vector of `UInt32` integers or a filename, in which case the seed is read from a file. `RandomDevice` does not support seeding.\n\"\"\"\nsrand\n\ndoc\"\"\"\n```rst\n..  schur(A) -> Schur[:T], Schur[:Z], Schur[:values]\n\nSee :func:`schurfact`\n```\n\"\"\"\nschur(A)\n\ndoc\"\"\"\n```rst\n..  schur(A,B) -> GeneralizedSchur[:S], GeneralizedSchur[:T], GeneralizedSchur[:Q], GeneralizedSchur[:Z]\n\nSee :func:`schurfact`\n```\n\"\"\"\nschur(A,B)\n\ndoc\"\"\"\n    isexecutable(path) -> Bool\n\nReturns `true` if the current user has permission to execute `path`, `false` otherwise.\n\"\"\"\nisexecutable\n\ndoc\"\"\"\n    acot(x)\n\nCompute the inverse cotangent of `x`, where the output is in radians\n\"\"\"\nacot\n\ndoc\"\"\"\n    oftype(x, y)\n\nConvert `y` to the type of `x` (`convert(typeof(x), y)`).\n\"\"\"\noftype\n\ndoc\"\"\"\n    maxabs!(r, A)\n\nCompute the maximum absolute values over the singleton dimensions of `r`, and write values to `r`.\n\"\"\"\nmaxabs!\n\ndoc\"\"\"\n    nullspace(M)\n\nBasis for nullspace of `M`.\n\"\"\"\nnullspace\n\ndoc\"\"\"\n    isfinite(f) -> Bool\n\nTest whether a number is finite\n\"\"\"\nisfinite\n\ndoc\"\"\"\n```rst\n..  push!(collection, items...) -> collection\n\nInsert one or more ``items`` at the end of ``collection``.\n\n.. doctest::\n\n  julia> push!([1, 2, 3], 4, 5, 6)\n  6-element Array{Int64,1}:\n   1\n   2\n   3\n   4\n   5\n   6\n\nUse :func:`append!` to add all the elements of another collection to\n``collection``.\nThe result of the preceding example is equivalent to\n``append!([1, 2, 3], [4, 5, 6])``.\n```\n\"\"\"\npush!\n\ndoc\"\"\"\n    prevpow(a, x)\n\nThe largest `a^n` not greater than `x`, where `n` is a non-negative integer. `a` must be greater than 1, and `x` must not be less than 1.\n\"\"\"\nprevpow\n\ndoc\"\"\"\n    indexin(a, b)\n\nReturns a vector containing the highest index in `b` for each value in `a` that is a member of `b` . The output vector contains 0 wherever `a` is not a member of `b`.\n\"\"\"\nindexin\n\ndoc\"\"\"\n    permutedims(A, perm)\n\nPermute the dimensions of array `A`. `perm` is a vector specifying a permutation of length `ndims(A)`. This is a generalization of transpose for multi-dimensional arrays. Transpose is equivalent to `permutedims(A, [2,1])`.\n\"\"\"\npermutedims\n\ndoc\"\"\"\n```rst\n..  shuffle!([rng,] v)\n\nIn-place version of :func:`shuffle`.\n```\n\"\"\"\nshuffle!\n\ndoc\"\"\"\n    fldmod(x, y)\n\nThe floored quotient and modulus after division. Equivalent to `(fld(x,y), mod(x,y))`.\n\"\"\"\nfldmod\n\ndoc\"\"\"\n    promote(xs...)\n\nConvert all arguments to their common promotion type (if any), and return them all (as a tuple).\n\"\"\"\npromote\n\ndoc\"\"\"\n    @schedule\n\nWrap an expression in a `Task` and add it to the local machine's scheduler queue.\n\"\"\"\n:@schedule\n\ndoc\"\"\"\n    bessely(nu, x)\n\nBessel function of the second kind of order `nu`, $Y_\\nu(x)$.\n\"\"\"\nbessely\n\ndoc\"\"\"\n    gradient(F, [h])\n\nCompute differences along vector `F`, using `h` as the spacing between points. The default spacing is one.\n\"\"\"\ngradient\n\ndoc\"\"\"\n    tan(x)\n\nCompute tangent of `x`, where `x` is in radians\n\"\"\"\ntan\n\ndoc\"\"\"\n    sprint(f::Function, args...)\n\nCall the given function with an I/O stream and the supplied extra arguments. Everything written to this I/O stream is returned as a string.\n\"\"\"\nsprint\n\ndoc\"\"\"\n    fd(stream)\n\nReturns the file descriptor backing the stream or file. Note that this function only applies to synchronous `File`'s and `IOStream`'s not to any of the asynchronous streams.\n\"\"\"\nfd\n\ndoc\"\"\"\n    require(module::Symbol)\n\nThis function is part of the implementation of `using` / `import`, if a module is not already defined in `Main`. It can also be called directly to force reloading a module, regardless of whether it has been loaded before (for example, when interactively developing libraries).\n\nLoads a source files, in the context of the `Main` module, on every active node, searching standard locations for files. `require` is considered a top-level operation, so it sets the current `include` path but does not use it to search for files (see help for `include`). This function is typically used to load library code, and is implicitly called by `using` to load packages.\n\nWhen searching for files, `require` first looks in the current working directory, then looks for package code under `Pkg.dir()`, then tries paths in the global array `LOAD_PATH`.\n\"\"\"\nrequire\n\ndoc\"\"\"\n    expand(x)\n\nTakes the expression `x` and returns an equivalent expression in lowered form.\n\"\"\"\nexpand\n\ndoc\"\"\"\n```rst\n..  peakflops(n; parallel=false)\n\n``peakflops`` computes the peak flop rate of the computer by using double precision :func:`Base.LinAlg.BLAS.gemm!`. By default, if no arguments are specified, it multiplies a matrix of size ``n x n``, where ``n = 2000``. If the underlying BLAS is using multiple threads, higher flop rates are realized. The number of BLAS threads can be set with ``blas_set_num_threads(n)``.\n\nIf the keyword argument ``parallel`` is set to ``true``, ``peakflops`` is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument ``n`` still refers to the size of the problem that is solved on each processor.\n```\n\"\"\"\npeakflops\n\ndoc\"\"\"\n    svd(A, [thin=true]) -> U, S, V\n\nWrapper around `svdfact` extracting all parts the factorization to a tuple. Direct use of `svdfact` is therefore generally more efficient. Computes the SVD of `A`, returning `U`, vector `S`, and `V` such that `A == U*diagm(S)*V'`. If `thin` is `true`, an economy mode decomposition is returned. The default is to produce a thin decomposition.\n\"\"\"\nsvd\n\ndoc\"\"\"\n    svd(A, B) -> U, V, Q, D1, D2, R0\n\nWrapper around `svdfact` extracting all parts the factorization to a tuple. Direct use of `svdfact` is therefore generally more efficient. The function returns the generalized SVD of `A` and `B`, returning `U`, `V`, `Q`, `D1`, `D2`, and `R0` such that `A = U*D1*R0*Q'` and `B = V*D2*R0*Q'`.\n\"\"\"\nsvd(A::AbstractMatrix, B::AbstractMatrix)\n\ndoc\"\"\"\n    ones(type, dims)\n\nCreate an array of all ones of specified type. The type defaults to `Float64` if not specified.\n\"\"\"\nones(t,dims)\n\ndoc\"\"\"\n    ones(A)\n\nCreate an array of all ones with the same element type and shape as `A`.\n\"\"\"\nones(A)\n\ndoc\"\"\"\n    ind2chr(string, i)\n\nConvert a byte index to a character index.\n\"\"\"\nind2chr\n\ndoc\"\"\"\n    reshape(A, dims)\n\nCreate an array with the same data as the given array, but with different dimensions. An implementation for a particular type of array may choose whether the data is copied or shared.\n\"\"\"\nreshape\n\ndoc\"\"\"\n    randsubseq!(S, A, p)\n\nLike `randsubseq`, but the results are stored in `S` (which is resized as needed).\n\"\"\"\nrandsubseq!\n\ndoc\"\"\"\n    maximum(itr)\n\nReturns the largest element in a collection.\n\"\"\"\nmaximum(itr)\n\ndoc\"\"\"\n    maximum(A, dims)\n\nCompute the maximum value of an array over the given dimensions.\n\"\"\"\nmaximum(A,dims)\n\ndoc\"\"\"\n    redisplay(x)\n    redisplay(d::Display, x)\n    redisplay(mime, x)\n    redisplay(d::Display, mime, x)\n\nBy default, the `redisplay` functions simply call `display`. However, some display backends may override `redisplay` to modify an existing display of `x` (if any). Using `redisplay` is also a hint to the backend that `x` may be redisplayed several times, and the backend may choose to defer the display until (for example) the next interactive prompt.\n\"\"\"\nredisplay\n\ndoc\"\"\"\n    A_mul_Bc(A, B)\n\nFor matrices or vectors $A$ and $B$, calculates $A\u22c5B\u1d34$\n\"\"\"\nA_mul_Bc\n\ndoc\"\"\"\n    searchsorted(a, x, [by=<transform>,] [lt=<comparison>,] [rev=false])\n\nReturns the range of indices of `a` which compare as equal to `x` according to the order specified by the `by`, `lt` and `rev` keywords, assuming that `a` is already sorted in that order. Returns an empty range located at the insertion point if `a` does not contain values equal to `x`.\n\"\"\"\nsearchsorted\n\ndoc\"\"\"\n    /(x, y)\n\nRight division operator: multiplication of `x` by the inverse of `y` on the right. Gives floating-point results for integer arguments.\n\"\"\"\nBase.(:(/))\n\ndoc\"\"\"\n    ldltfact(::Union{SparseMatrixCSC,Symmetric{Float64,SparseMatrixCSC{Flaot64,SuiteSparse_long}},Hermitian{Complex{Float64},SparseMatrixCSC{Complex{Float64},SuiteSparse_long}}}; shift=0, perm=Int[]) -> CHOLMOD.Factor\n\nCompute the `LDLt` factorization of a sparse symmetric or Hermitian matrix. A fill-reducing permutation is used. `F = ldltfact(A)` is most frequently used to solve systems of equations `A*x = b` with `F\\b`, but also the methods `diag`, `det`, `logdet` are defined for `F`. You can also extract individual factors from `F`, using `F[:L]`. However, since pivoting is on by default, the factorization is internally represented as `A == P'*L*D*L'*P` with a permutation matrix `P`; using just `L` without accounting for `P` will give incorrect answers. To include the effects of permutation, it's typically preferable to extact \"combined\" factors like `PtL = F[:PtL]` (the equivalent of `P'*L`) and `LtP = F[:UP]` (the equivalent of `L'*P`). The complete list of supported factors is `:L, :PtL, :D, :UP, :U, :LD, :DU, :PtLD, :DUP`.\n\nSetting optional `shift` keyword argument computes the factorization of `A+shift*I` instead of `A`. If the `perm` argument is nonempty, it should be a permutation of `1:size(A,1)` giving the ordering to use (instead of CHOLMOD's default AMD ordering).\n\nThe function calls the C library CHOLMOD and many other functions from the library are wrapped but not exported.\n\"\"\"\nldltfact(A::SparseMatrixCSC; shift=0, perm=Int[])\n\ndoc\"\"\"\n    connect([host],port) -> TCPSocket\n\nConnect to the host `host` on port `port`\n\"\"\"\nconnect(host=?, port)\n\ndoc\"\"\"\n    connect(path) -> PipeEndpoint\n\nConnect to the Named Pipe / Domain Socket at ``path``\n\"\"\"\nconnect(path)\n\ndoc\"\"\"\n    connect(manager::FooManager, pid::Int, config::WorkerConfig) -> (instrm::AsyncStream, outstrm::AsyncStream)\n\nImplemented by cluster managers using custom transports. It should establish a logical connection to worker with id `pid`, specified by `config` and return a pair of `AsyncStream` objects. Messages from `pid` to current process will be read off `instrm`, while messages to be sent to `pid` will be written to `outstrm`. The custom transport implementation must ensure that messages are delivered and received completely and in order. `Base.connect(manager::ClusterManager.....)` sets up TCP/IP socket connections in-between workers.\n\"\"\"\nconnect(manager, pid::Int, config::WorkerConfig)\n\ndoc\"\"\"\n    mean(v[, region])\n\nCompute the mean of whole array `v`, or optionally along the dimensions in `region`. Note: Julia does not ignore `NaN` values in the computation. For applications requiring the handling of missing data, the `DataArray` package is recommended.\n\"\"\"\nmean\n\ndoc\"\"\"\n    split(string, [chars]; limit=0, keep=true)\n\nReturn an array of substrings by splitting the given string on occurrences of the given character delimiters, which may be specified in any of the formats allowed by `search`'s second argument (i.e. a single character, collection of characters, string, or regular expression). If `chars` is omitted, it defaults to the set of all space characters, and `keep` is taken to be `false`. The two keyword arguments are optional: they are are a maximum size for the result and a flag determining whether empty fields should be kept in the result.\n\"\"\"\nsplit\n\ndoc\"\"\"\n    dump(x)\n\nShow all user-visible structure of a value.\n\"\"\"\ndump\n\ndoc\"\"\"\n    sumabs(itr)\n\nSum absolute values of all elements in a collection. This is equivalent to `sum(abs(itr))` but faster.\n\"\"\"\nsumabs(itr)\n\ndoc\"\"\"\n    sumabs(A, dims)\n\nSum absolute values of elements of an array over the given dimensions.\n\"\"\"\nsumabs(A, dims)\n\ndoc\"\"\"\n    svdvals!(A)\n\nReturns the singular values of `A`, while saving space by overwriting the input.\n\"\"\"\nsvdvals!\n\ndoc\"\"\"\n    consume(task, values...)\n\nReceive the next value passed to `produce` by the specified task. Additional arguments may be passed, to be returned from the last `produce` call in the producer.\n\"\"\"\nconsume\n\ndoc\"\"\"\n    hankelh2x(nu, x)\n\nScaled Bessel function of the third kind of order `nu`, $H^{(2)}_\\nu(x) e^{x i}$.\n\"\"\"\nhankelh2x\n\ndoc\"\"\"\n    ndigits(n, b)\n\nCompute the number of digits in number `n` written in base `b`.\n\"\"\"\nndigits\n\ndoc\"\"\"\n    cummax(A, [dim])\n\nCumulative maximum along a dimension. The dimension defaults to 1.\n\"\"\"\ncummax\n\ndoc\"\"\"\n    watch_file(path, timeout_s::Real)\n\nWatch file or directory `path` for changes until a change occurs or `timeout_s` seconds have elapsed.\n\nThe returned value is an object with boolean fields `changed`, `renamed`, and `timedout`, giving the result of watching the file.\n\nThis behavior of this function varies slightly across platforms. See <https://nodejs.org/api/fs.html#fs_caveats> for more detailed information.\n\"\"\"\nwatch_file\n\ndoc\"\"\"\n    At_rdiv_Bt(A, B)\n\nFor matrices or vectors $A$ and $B$, calculates $A\u1d40 / B\u1d40$\n\"\"\"\nAt_rdiv_Bt\n\ndoc\"\"\"\n    isinteractive() -> Bool\n\nDetermine whether Julia is running an interactive session.\n\"\"\"\nisinteractive\n\ndoc\"\"\"\n    At_mul_Bt(A, B)\n\nFor matrices or vectors $A$ and $B$, calculates $A\u1d40\u22c5B\u1d40$\n\"\"\"\nAt_mul_Bt\n\ndoc\"\"\"\n    sum!(r, A)\n\nSum elements of `A` over the singleton dimensions of `r`, and write results to `r`.\n\"\"\"\nsum!\n\ndoc\"\"\"\n    close(stream)\n\nClose an I/O stream. Performs a `flush` first.\n\"\"\"\nclose(stream::IO)\n\ndoc\"\"\"\n    close(Channel)\n\nCloses a channel. An exception is thrown by:\n\n* `put!` on a closed channel.\n* `take!` and `fetch` on an empty, closed channel.\n\"\"\"\nclose(::Channel)\n\ndoc\"\"\"\n    cospi(x)\n\nCompute $\\cos(\\pi x)$ more accurately than `cos(pi*x)`, especially for large `x`.\n\"\"\"\ncospi\n\ndoc\"\"\"\n    parentindexes(A)\n\nFrom an array view `A`, returns the corresponding indexes in the parent\n\"\"\"\nparentindexes\n\ndoc\"\"\"\n    display(x)\n    display(d::Display, x)\n    display(mime, x)\n    display(d::Display, mime, x)\n\nDisplay `x` using the topmost applicable display in the display stack, typically using the richest supported multimedia output for `x`, with plain-text `STDOUT` output as a fallback. The `display(d, x)` variant attempts to display `x` on the given display `d` only, throwing a `MethodError` if `d` cannot display objects of this type.\n\nThere are also two variants with a `mime` argument (a MIME type string, such as `\"image/png\"`), which attempt to display `x` using the requested MIME type *only*, throwing a `MethodError` if this type is not supported by either the display(s) or by `x`. With these variants, one can also supply the \"raw\" data in the requested MIME type by passing `x::AbstractString` (for MIME types with text-based storage, such as text/html or application/postscript) or `x::Vector{UInt8}` (for binary MIME types).\n\"\"\"\ndisplay\n\ndoc\"\"\"\n    @spawnat\n\nAccepts two arguments, `p` and an expression. A closure is created around the expression and run asynchronously on process `p`. Returns a `RemoteRef` to the result.\n\"\"\"\n:@spawnat\n\ndoc\"\"\"\n    print_shortest(io, x)\n\nPrint the shortest possible representation, with the minimum number of consecutive non-zero digits, of number `x`, ensuring that it would parse to the exact same number.\n\"\"\"\nprint_shortest\n\ndoc\"\"\"\n    merge(collection, others...)\n\nConstruct a merged collection from the given collections. If necessary, the\ntypes of the resulting collection will be promoted to accommodate the types of\nthe merged collections. If the same key is present in another collection, the\nvalue for that key will be the value it has in the last collection listed.\n\n```jldoctest\njulia> a = Dict(\"foo\" => 0.0, \"bar\" => 42.0)\nDict{ASCIIString,Float64} with 2 entries:\n  \"bar\" => 42.0\n  \"foo\" => 0.0\n\njulia> b = Dict(utf8(\"baz\") => 17, utf8(\"bar\") => 4711)\nDict{UTF8String,Int64} with 2 entries:\n  \"bar\" => 4711\n  \"baz\" => 17\n\njulia> merge(a, b)\nDict{UTF8String,Float64} with 3 entries:\n  \"bar\" => 4711.0\n  \"baz\" => 17.0\n  \"foo\" => 0.0\n\njulia> merge(b, a)\nDict{UTF8String,Float64} with 3 entries:\n  \"bar\" => 42.0\n  \"baz\" => 17.0\n  \"foo\" => 0.0\n```\n\"\"\"\nmerge\n\ndoc\"\"\"\n    circshift(A,shifts)\n\nCircularly shift the data in an array. The second argument is a vector giving the amount to shift in each dimension.\n\"\"\"\ncircshift\n\ndoc\"\"\"\n    fieldnames(x::DataType)\n\nGet an array of the fields of a `DataType`.\n\"\"\"\nfieldnames\n\ndoc\"\"\"\n    yield()\n\nSwitch to the scheduler to allow another scheduled task to run. A task that calls this function is still runnable, and will be restarted immediately if there are no other runnable tasks.\n\"\"\"\nyield\n\ndoc\"\"\"\n    transpose!(dest,src)\n\nTranspose array `src` and store the result in the preallocated array `dest`, which should have a size corresponding to `(size(src,2),size(src,1))`. No in-place transposition is supported and unexpected results will happen if `src` and `dest` have overlapping memory regions.\n\"\"\"\ntranspose!\n\ndoc\"\"\"\n    isconst([m::Module], s::Symbol) -> Bool\n\nDetermine whether a global is declared `const` in a given `Module`. The default `Module` argument is `current_module()`.\n\"\"\"\nisconst\n\ndoc\"\"\"\n```rst\n..  open(command, mode::AbstractString=\"r\", stdio=DevNull)\n\nStart running ``command`` asynchronously, and return a tuple\n``(stream,process)``.  If ``mode`` is ``\"r\"``, then ``stream``\nreads from the process's standard output and ``stdio`` optionally\nspecifies the process's standard input stream.  If ``mode`` is\n``\"w\"``, then ``stream`` writes to the process's standard input\nand ``stdio`` optionally specifies the process's standard output\nstream.\n```\n\"\"\"\nopen(command::Cmd, mod::AbstractString=\"r\", stdio=DevNull)\n\ndoc\"\"\"\n```rst\n..  open(f::Function, command, mode::AbstractString=\"r\", stdio=DevNull)\n\nSimilar to ``open(command, mode, stdio)``, but calls ``f(stream)``\non the resulting read or write stream, then closes the stream\nand waits for the process to complete.  Returns the value returned\nby ``f``.\n```\n\"\"\"\nopen(f::Function, command::Cmd, mod::AbstractString=\"r\", stdio=DevNull)\n\ndoc\"\"\"\n```rst\n..  open(file_name, [read, write, create, truncate, append]) -> IOStream\n\nOpen a file in a mode specified by five boolean arguments. The default is to open files for reading only. Returns a stream for accessing the file.\n```\n\"\"\"\nopen(file_name, ::Bool, ::Bool, ::Bool, ::Bool, ::Bool)\n\ndoc\"\"\"\n```rst\n..  open(file_name, [mode]) -> IOStream\n\nAlternate syntax for open, where a string-based mode specifier is used instead of the five booleans. The values of ``mode`` correspond to those from ``fopen(3)`` or Perl ``open``, and are equivalent to setting the following boolean groups:\n\n==== =================================\n r    read\n r+   read, write\n w    write, create, truncate\n w+   read, write, create, truncate\n a    write, create, append\n a+   read, write, create, append\n==== =================================\n\n```\n\"\"\"\nopen(file_name, mode=\"r\")\n\ndoc\"\"\"\n    open(f::Function, args...)\n\nApply the function `f` to the result of `open(args...)`\nand close the resulting file descriptor upon completion.\n\n**Example**: `open(readall, \"file.txt\")`\n\"\"\"\nopen(f::Function, args...)\n\ndoc\"\"\"\n    sort(v, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])\n\nVariant of `sort!` that returns a sorted copy of `v` leaving `v` itself unmodified.\n\"\"\"\nsort(v,?,?,?,?)\n\n\"\"\"\n    sort(A, dim, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])\n\nSort a multidimensional array `A` along the given dimension.\n\"\"\"\nsort(A,dim,?,?,?,?)\n\ndoc\"\"\"\n    kron(A, B)\n\nKronecker tensor product of two vectors or two matrices.\n\"\"\"\nkron\n\ndoc\"\"\"\n    >>(x, n)\n\nRight bit shift operator, preserving the sign of `x`.\n\"\"\"\nBase.(:(>>))\n\ndoc\"\"\"\n    fieldoffsets(type)\n\nThe byte offset of each field of a type relative to the data start. For example, we could use it\nin the following manner to summarize information about a struct type:\n\n```jldoctest\njulia> structinfo(T) = [zip(fieldoffsets(T),fieldnames(T),T.types)...];\n\njulia> structinfo(StatStruct)\n12-element Array{Tuple{Int64,Symbol,DataType},1}:\n (0,:device,UInt64)\n (8,:inode,UInt64)\n (16,:mode,UInt64)\n (24,:nlink,Int64)\n (32,:uid,UInt64)\n (40,:gid,UInt64)\n (48,:rdev,UInt64)\n (56,:size,Int64)\n (64,:blksize,Int64)\n (72,:blocks,Int64)\n (80,:mtime,Float64)\n (88,:ctime,Float64)\n```\n\"\"\"\nfieldoffsets\n\ndoc\"\"\"\n    randn([rng], [dims...])\n\nGenerate a normally-distributed random number with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers.\n\"\"\"\nrandn\n\ndoc\"\"\"\n    process_exited(p::Process)\n\nDetermine whether a process has exited.\n\"\"\"\nprocess_exited\n\ndoc\"\"\"\n    tuple(xs...)\n\nConstruct a tuple of the given objects.\n\"\"\"\ntuple\n\ndoc\"\"\"\n    besseli(nu, x)\n\nModified Bessel function of the first kind of order `nu`, $I_\\nu(x)$.\n\"\"\"\nbesseli\n\ndoc\"\"\"\n    eachmatch(r::Regex, s::AbstractString[, overlap::Bool=false])\n\nSearch for all matches of a the regular expression `r` in `s` and return a iterator over the matches. If overlap is `true`, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from distinct character ranges.\n\"\"\"\neachmatch\n\ndoc\"\"\"\n    log10(x)\n\nCompute the logarithm of `x` to base 10. Throws `DomainError` for negative `Real` arguments.\n\"\"\"\nlog10\n\ndoc\"\"\"\n    @profile\n\n`@profile <expression>` runs your expression while taking periodic backtraces. These are appended to an internal buffer of backtraces.\n\"\"\"\n:@profile\n\ndoc\"\"\"\n    extrema(itr)\n\nCompute both the minimum and maximum element in a single pass, and return them as a 2-tuple.\n\"\"\"\nextrema\n\ndoc\"\"\"\n    isdigit(c::Union{Char,AbstractString}) -> Bool\n\nTests whether a character is a numeric digit (0-9), or whether this is true for all elements of a string.\n\"\"\"\nisdigit\n\ndoc\"\"\"\n    @windows\n\nGiven `@windows? a : b`, do `a` on Windows and `b` elsewhere. See documentation for Handling Platform Variations in the Calling C and Fortran Code section of the manual.\n\"\"\"\n:@windows\n\ndoc\"\"\"\n    @unix\n\nGiven `@unix? a : b`, do `a` on Unix systems (including Linux and OS X) and `b` elsewhere. See documentation for Handling Platform Variations in the Calling C and Fortran Code section of the manual.\n\"\"\"\n:@unix\n\ndoc\"\"\"\n    num2hex(f)\n\nGet a hexadecimal string of the binary representation of a floating point number\n\"\"\"\nnum2hex\n\ndoc\"\"\"\n    count_ones(x::Integer) -> Integer\n\nNumber of ones in the binary representation of `x`.\n\n```jldoctest\njulia> count_ones(7)\n3\n```\n\"\"\"\ncount_ones\n\ndoc\"\"\"\n    reim(z)\n\nReturn both the real and imaginary parts of the complex number `z`\n\"\"\"\nreim\n\ndoc\"\"\"\n    displayable(mime) -> Bool\n    displayable(d::Display, mime) -> Bool\n\nReturns a boolean value indicating whether the given `mime` type (string) is displayable by any of the displays in the current display stack, or specifically by the display `d` in the second variant.\n\"\"\"\ndisplayable\n\ndoc\"\"\"\n    sdata(S::SharedArray)\n\nReturns the actual `Array` object backing `S`\n\"\"\"\nsdata\n\ndoc\"\"\"\n    truncate(file,n)\n\nResize the file or buffer given by the first argument to exactly `n` bytes, filling previously unallocated space with '\\\\0' if the file or buffer is grown\n\"\"\"\ntruncate\n\ndoc\"\"\"\n```rst\n..  stat(file)\n\nReturns a structure whose fields contain information about the file. The fields of the structure are:\n\n========= ======================================================================\n size      The size (in bytes) of the file\n device    ID of the device that contains the file\n inode     The inode number of the file\n mode      The protection mode of the file\n nlink     The number of hard links to the file\n uid       The user id of the owner of the file\n gid       The group id of the file owner\n rdev      If this file refers to a device, the ID of the device it refers to\n blksize   The file-system preferred block size for the file\n blocks    The number of such blocks allocated\n mtime     Unix timestamp of when the file was last modified\n ctime     Unix timestamp of when the file was created\n========= ======================================================================\n```\n\"\"\"\nstat\n\ndoc\"\"\"\n    exp10(x)\n\nCompute $10^x$.\n\"\"\"\nexp10\n\ndoc\"\"\"\n    &(x, y)\n\nBitwise and\n\"\"\"\n&\n\ndoc\"\"\"\n    besselyx(nu, x)\n\nScaled Bessel function of the second kind of order `nu`, $Y_\\nu(x) e^{- | \\operatorname{Im}(x) |}$.\n\"\"\"\nbesselyx\n\ndoc\"\"\"\n    eigmax(A)\n\nReturns the largest eigenvalue of `A`.\n\"\"\"\neigmax\n\ndoc\"\"\"\n    PipeBuffer()\n\nAn IOBuffer that allows reading and performs writes by appending. Seeking and truncating are not supported. See IOBuffer for the available constructors.\n\"\"\"\nPipeBuffer()\n\ndoc\"\"\"\n    PipeBuffer(data::Vector{UInt8},[maxsize])\n\nCreate a PipeBuffer to operate on a data vector, optionally specifying a size beyond which the underlying Array may not be grown.\n\"\"\"\nPipeBuffer(data)\n\ndoc\"\"\"\n```rst\n..  sortperm(v, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])\n\nReturn a permutation vector of indices of ``v`` that puts it in sorted order.\nSpecify ``alg`` to choose a particular sorting algorithm (see Sorting Algorithms).\n``MergeSort`` is used by default, and since it is stable, the resulting permutation\nwill be the lexicographically first one that puts the input array into sorted order \u2013\ni.e. indices of equal elements appear in ascending order. If you choose a non-stable\nsorting algorithm such as ``QuickSort``, a different permutation that puts the array\ninto order may be returned. The order is specified using the same keywords as ``sort!``.\n\nSee also :func:`sortperm!`\n```\n\"\"\"\nsortperm\n\ndoc\"\"\"\n    mod2pi(x)\n\nModulus after division by 2pi, returning in the range \\[0,2pi).\n\nThis function computes a floating point representation of the modulus after division by numerically exact 2pi, and is therefore not exactly the same as mod(x,2pi), which would compute the modulus of `x` relative to division by the floating-point number 2pi.\n\"\"\"\nmod2pi\n\ndoc\"\"\"\n    cumsum!(B, A, [dim])\n\nCumulative sum of `A` along a dimension, storing the result in `B`. The dimension defaults to 1.\n\"\"\"\ncumsum!\n\ndoc\"\"\"\n    logdet(M)\n\nLog of matrix determinant. Equivalent to `log(det(M))`, but may provide increased accuracy and/or speed.\n\"\"\"\nlogdet\n\ndoc\"\"\"\n    hcat(A...)\n\nConcatenate along dimension 2\n\"\"\"\nhcat\n\ndoc\"\"\"\n    select(v, k, [by=<transform>,] [lt=<comparison>,] [rev=false])\n\nVariant of `select!` which copies `v` before partially sorting it, thereby returning the same thing as `select!` but leaving `v` unmodified.\n\"\"\"\nselect\n\ndoc\"\"\"\n    lpad(string, n, p)\n\nMake a string at least `n` columns wide when printed, by padding on the left with copies of `p`.\n\"\"\"\nlpad\n\ndoc\"\"\"\n```rst\n..  mapreduce(f, op, v0, itr)\n\nApply function ``f`` to each element in ``itr``, and then reduce\nthe result using the binary function ``op``. ``v0`` must be a\nneutral element for ``op`` that will be returned for empty\ncollections. It is unspecified whether ``v0`` is used for non-empty\ncollections.\n\n:func:`mapreduce` is functionally equivalent to calling ``reduce(op,\nv0, map(f, itr))``, but will in general execute faster since no\nintermediate collection needs to be created. See documentation for\n:func:`reduce` and :func:`map`.\n\n.. doctest::\n\n   julia> mapreduce(x->x^2, +, [1:3;]) # == 1 + 4 + 9\n   14\n\nThe associativity of the reduction is implementation-dependent.\nAdditionally, some implementations may reuse the return value of\n``f`` for elements that appear multiple times in ``itr``.\nUse :func:`mapfoldl` or :func:`mapfoldr` instead for guaranteed\nleft or right associativity and invocation of ``f`` for every value.\n```\n\"\"\"\nmapreduce(f, op, v0, itr)\n\ndoc\"\"\"\n```rst\n..  mapreduce(f, op, itr)\n\nLike ``mapreduce(f, op, v0, itr)``. In general, this cannot be used\nwith empty collections (see ``reduce(op, itr)``).\n```\n\"\"\"\nmapreduce(f, op, itr)\n\ndoc\"\"\"\n    accept(server[,client])\n\nAccepts a connection on the given server and returns a connection to the client. An uninitialized client stream may be provided, in which case it will be used instead of creating a new stream.\n\"\"\"\naccept\n\ndoc\"\"\"\n```rst\n..  ordschur(Q, T, select) -> Schur\n\nReorders the Schur factorization of a real matrix ``A=Q*T*Q'`` according to the logical array ``select`` returning a Schur object ``F``. The selected eigenvalues appear in the leading diagonal of ``F[:Schur]`` and the the corresponding leading columns of ``F[:vectors]`` form an orthonormal basis of the corresponding right invariant subspace. A complex conjugate pair of eigenvalues must be either both included or excluded via ``select``.\n```\n\"\"\"\nordschur(Q, T, select)\n\ndoc\"\"\"\n```rst\n..  ordschur(S, select) -> Schur\n\nReorders the Schur factorization ``S`` of type ``Schur``.\n```\n\"\"\"\nordschur(S::Schur, select)\n\ndoc\"\"\"\n```rst\n..  ordschur(S, T, Q, Z, select) -> GeneralizedSchur\n\nReorders the Generalized Schur factorization of a matrix ``(A, B) = (Q*S*Z^{H}, Q*T*Z^{H})`` according to the logical array ``select`` and returns a GeneralizedSchur object ``GS``.  The selected eigenvalues appear in the leading diagonal of both ``(GS[:S], GS[:T])`` and the left and right unitary/orthogonal Schur vectors are also reordered such that ``(A, B) = GS[:Q]*(GS[:S], GS[:T])*GS[:Z]^{H}`` still holds and the generalized eigenvalues of ``A`` and ``B`` can still be obtained with ``GS[:alpha]./GS[:beta]``.\n```\n\"\"\"\nordschur(S, T, Q, Z)\n\ndoc\"\"\"\n```rst\n..  ordschur(GS, select) -> GeneralizedSchur\n\nReorders the Generalized Schur factorization of a Generalized Schur object.  See :func:`ordschur`.\n```\n\"\"\"\nordschur(GS::GeneralizedSchur, select)\n\ndoc\"\"\"\n    triu!(M)\n\nUpper triangle of a matrix, overwriting `M` in the process.\n\"\"\"\ntriu!(M)\n\ndoc\"\"\"\n    triu!(M, k)\n\nReturns the upper triangle of `M` starting from the `k`th superdiagonal, overwriting `M` in the process.\n\"\"\"\ntriu!(M, k)\n\ndoc\"\"\"\n    readall(stream::IO)\n\nRead the entire contents of an I/O stream as a string.\n\"\"\"\nreadall(stream::IO)\n\ndoc\"\"\"\n    readall(filename::AbstractString)\n\nOpen `filename`, read the entire contents as a string, then close the file. Equivalent to `open(readall, filename)`.\n\"\"\"\nreadall(filename::AbstractString)\n\ndoc\"\"\"\n    poll_file(path, interval_s::Real, timeout_s::Real) -> (previous::StatStruct, current::StatStruct)\n\nMonitor a file for changes by polling every `interval_s` seconds until a change occurs or `timeout_s` seconds have elapsed. The `interval_s` should be a long period; the default is 5.007 seconds.\n\nReturns a pair of `StatStruct` objects `(previous, current)` when a change is detected.\n\nTo determine when a file was modified, compare `mtime(prev) != mtime(current)` to detect notification of changes. However, using `watch_file` for this operation is preferred, since it is more reliable and efficient, although in some situations it may not be available.\n\"\"\"\npoll_file\n\ndoc\"\"\"\n    eachline(stream)\n\nCreate an iterable object that will yield each line from a stream.\n\"\"\"\neachline\n\ndoc\"\"\"\n    isposdef!(A) -> Bool\n\nTest whether a matrix is positive definite, overwriting `A` in the processes.\n\"\"\"\nisposdef!\n\ndoc\"\"\"\n    complex(r, [i])\n\nConvert real numbers or arrays to complex. `i` defaults to zero.\n\"\"\"\ncomplex\n\ndoc\"\"\"\n    setopt(sock::UDPSocket; multicast_loop = nothing, multicast_ttl=nothing, enable_broadcast=nothing, ttl=nothing)\n\nSet UDP socket options. `multicast_loop`: loopback for multicast packets (default: `true`). `multicast_ttl`: TTL for multicast packets. `enable_broadcast`: flag must be set to `true` if socket will be used for broadcast messages, or else the UDP system will return an access error (default: `false`). `ttl`: Time-to-live of packets sent on the socket.\n\"\"\"\nsetopt\n\ndoc\"\"\"\n    Mmap.Anonymous(name, readonly, create)\n\nCreate an `IO`-like object for creating zeroed-out mmapped-memory that is not tied to a file for use in `Mmap.mmap`. Used by `SharedArray` for creating shared memory arrays.\n\"\"\"\nMmap.Anonymous\n\ndoc\"\"\"\n    A_rdiv_Bc(A, B)\n\nFor matrices or vectors $A$ and $B$, calculates $A / B\u1d34$\n\"\"\"\nA_rdiv_Bc\n\ndoc\"\"\"\n```rst\n..  round([T,] x, [digits, [base]], [r::RoundingMode])\n\n``round(x)`` rounds ``x`` to an integer value according to the default\nrounding mode (see :func:`get_rounding`), returning a value of the same type as\n``x``. By default (:obj:`RoundNearest`), this will round to the nearest\ninteger, with ties (fractional values of 0.5) being rounded to the even\ninteger.\n\n.. doctest::\n\n   julia> round(1.7)\n   2.0\n\n   julia> round(1.5)\n   2.0\n\n   julia> round(2.5)\n   2.0\n\nThe optional :obj:`RoundingMode` argument will change how the number gets rounded.\n\n``round(T, x, [r::RoundingMode])`` converts the result to type ``T``, throwing an\n:exc:`InexactError` if the value is not representable.\n\n``round(x, digits)`` rounds to the specified number of digits after the\ndecimal place (or before if negative). ``round(x, digits, base)`` rounds\nusing a base other than 10.\n\n.. doctest::\n\n   julia> round(pi, 2)\n   3.14\n\n   julia> round(pi, 3, 2)\n   3.125\n\n.. note::\n\n   Rounding to specified digits in bases other than 2 can be inexact when\n   operating on binary floating point numbers. For example, the ``Float64``\n   value represented by ``1.15`` is actually *less* than 1.15, yet will be\n   rounded to 1.2.\n\n   .. doctest::\n\n      julia> x = 1.15\n      1.15\n\n      julia> @sprintf \"%.20f\" x\n      \"1.14999999999999991118\"\n\n      julia> x < 115//100\n      true\n\n      julia> round(x, 1)\n      1.2\n```\n\"\"\"\nround(T::Type, x)\n\ndoc\"\"\"\n```rst\n.. round(z, RoundingModeReal, RoundingModeImaginary)\n\nReturns the nearest integral value of the same type as the complex-valued\n``z`` to ``z``, breaking ties using the specified :obj:`RoundingMode`\\ s.\nThe first :obj:`RoundingMode` is used for rounding the real components while\nthe second is used for rounding the imaginary components.\n```\n\"\"\"\nround(z::Real, ::Type{RoundingMode}, ::Type{RoundingMode})\n\ndoc\"\"\"\n    strwidth(s)\n\nGives the number of columns needed to print a string.\n\"\"\"\nstrwidth\n\ndoc\"\"\"\n    function_module(f::Function, types) -> Module\n\nDetermine the module containing a given definition of a generic function.\n\"\"\"\nfunction_module\n\ndoc\"\"\"\n    hex(n, [pad])\n\nConvert an integer to a hexadecimal string, optionally specifying a number of digits to pad to.\n\"\"\"\nhex\n\ndoc\"\"\"\n    workspace()\n\nReplace the top-level module (`Main`) with a new one, providing a clean workspace. The previous `Main` module is made available as `LastMain`. A previously-loaded package can be accessed using a statement such as `using LastMain.Package`.\n\nThis function should only be used interactively.\n\"\"\"\nworkspace\n\ndoc\"\"\"\n    tempdir()\n\nObtain the path of a temporary directory (possibly shared with other processes).\n\"\"\"\ntempdir\n\ndoc\"\"\"\n    reduce(op, v0, itr)\n\nReduce the given collection `\u00ectr` with the given binary operator `op`. `v0` must be a neutral element for `op` that will be returned for empty collections. It is unspecified whether `v0` is used for non-empty collections.\n\nReductions for certain commonly-used operators have special implementations which should be used instead: `maximum(itr)`, `minimum(itr)`, `sum(itr)`, `prod(itr)`, `any(itr)`, `all(itr)`.\n\nThe associativity of the reduction is implementation dependent. This means that you can't use non-associative operations like `-` because it is undefined whether `reduce(-,[1,2,3])` should be evaluated as `(1-2)-3` or `1-(2-3)`. Use `foldl` or `foldr` instead for guaranteed left or right associativity.\n\nSome operations accumulate error, and parallelism will also be easier if the reduction can be executed in groups. Future versions of Julia might change the algorithm. Note that the elements are not reordered if you use an ordered collection.\n\"\"\"\nreduce(op, v0, itr)\n\ndoc\"\"\"\n    reduce(op, itr)\n\nLike `reduce(op, v0, itr)`. This cannot be used with empty collections, except for some special cases (e.g. when `op` is one of `+`, `*`, `max`, `min`, `&`, `|`) when Julia can determine the neutral element of `op`.\n\"\"\"\nreduce(op, itr)\n\ndoc\"\"\"\n    .>=(x, y)\n    .\u2265(x,y)\n\nElement-wise greater-than-or-equals comparison operator.\n\"\"\"\nBase.(:(.>=))\n\ndoc\"\"\"\n    stdm(v, m)\n\nCompute the sample standard deviation of a vector `v` with known mean `m`. Note: Julia does not ignore `NaN` values in the computation.\n\"\"\"\nstdm\n\ndoc\"\"\"\n    mv(src::AbstractString,dst::AbstractString; remove_destination::Bool=false)\n\nMove the file, link, or directory from `src` to `dst`. `remove_destination=true` will first remove an existing `dst`.\n\"\"\"\nmv\n\ndoc\"\"\"\n    erfi(x)\n\nCompute the imaginary error function of `x`,\ndefined by $-i \\operatorname{erf}(ix)$.\n\"\"\"\nerfi\n\ndoc\"\"\"\n```rst\n..  floor([T,] x, [digits, [base]])\n\n``floor(x)`` returns the nearest integral value of the same type as ``x``\nthat is less than or equal to ``x``.\n\n``floor(T, x)`` converts the result to type ``T``, throwing an\n``InexactError`` if the value is not representable.\n\n``digits`` and ``base`` work as for :func:`round`.\n```\n\"\"\"\nfloor\n\ndoc\"\"\"\n    tril!(M)\n\nLower triangle of a matrix, overwriting `M` in the process.\n\"\"\"\ntril!(M)\n\ndoc\"\"\"\n    tril!(M, k)\n\nReturns the lower triangle of `M` starting from the `k`th superdiagonal, overwriting `M` in the process.\n\"\"\"\ntril!(M, k)\n\ndoc\"\"\"\n    divrem(x, y)\n\nThe quotient and remainder from Euclidean division. Equivalent to `(x\u00f7y, x%y)`.\n\"\"\"\ndivrem\n\ndoc\"\"\"\n    ErrorException(msg)\n\nGeneric error type. The error message, in the `.msg` field, may provide more specific details.\n\"\"\"\nErrorException\n\ndoc\"\"\"\n    reverse(v [, start=1 [, stop=length(v) ]] )\n\nReturn a copy of `v` reversed from start to stop.\n\"\"\"\nreverse\n\ndoc\"\"\"\n    reverse(s::AbstractString) -> AbstractString\n\nReverses a string\n\"\"\"\nreverse(s::AbstractString)\n\ndoc\"\"\"\n```rst\n..  reverse!(v [, start=1 [, stop=length(v) ]]) -> v\n\nIn-place version of :func:`reverse`.\n```\n\"\"\"\nreverse!\n\ndoc\"\"\"\n    flipdim(A, d)\n\nReverse `A` in dimension `d`.\n\"\"\"\nflipdim\n\ndoc\"\"\"\n    num(x)\n\nNumerator of the rational representation of `x`\n\"\"\"\nnum\n\ndoc\"\"\"\n    eachindex(A...)\n\nCreates an iterable object for visiting each index of an AbstractArray `A` in an efficient manner. For array types that have opted into fast linear indexing (like `Array`), this is simply the range `1:length(A)`. For other array types, this returns a specialized Cartesian range to efficiently index into the array with indices specified for every dimension. For other iterables, including strings and dictionaries, this returns an iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).\n\nExample for a sparse 2-d array:\n\n```jldoctest\njulia> A = sparse([1, 1, 2], [1, 3, 1], [1, 2, -5])\n2x3 sparse matrix with 3 Int64 entries:\n        [1, 1]  =  1\n        [2, 1]  =  -5\n        [1, 3]  =  2\n\njulia> for iter in eachindex(A)\n           @show iter.I[1], iter.I[2]\n           @show A[iter]\n       end\n(iter.I[1],iter.I[2]) = (1,1)\nA[iter] = 1\n(iter.I[1],iter.I[2]) = (2,1)\nA[iter] = -5\n(iter.I[1],iter.I[2]) = (1,2)\nA[iter] = 0\n(iter.I[1],iter.I[2]) = (2,2)\nA[iter] = 0\n(iter.I[1],iter.I[2]) = (1,3)\nA[iter] = 2\n(iter.I[1],iter.I[2]) = (2,3)\nA[iter] = 0\n```\n\nIf you supply more than one ``AbstractArray`` argument, ``eachindex``\nwill create an iterable object that is fast for all arguments (a\n``UnitRange`` if all inputs have fast linear indexing, a\nCartesianRange otherwise).  If the arrays have different sizes and/or\ndimensionalities, ``eachindex`` returns an iterable that spans the\nlargest range along each dimension.\n\"\"\"\neachindex\n\ndoc\"\"\"\n    .<(x, y)\n\nElement-wise less-than comparison operator.\n\"\"\"\nBase.(:(.<))\n\ndoc\"\"\"\n    UndefRefError()\n\nThe item or field is not defined for the given object.\n\"\"\"\nUndefRefError\n\ndoc\"\"\"\n    bessely1(x)\n\nBessel function of the second kind of order 1, $Y_1(x)$.\n\"\"\"\nbessely1\n\ndoc\"\"\"\n```rst\n..  cumprod(A, [dim])\n\nCumulative product along a dimension ``dim`` (defaults to 1).\nSee also :func:`cumprod!` to use a preallocated output array,\nboth for performance and to control the precision of the\noutput (e.g. to avoid overflow).\n```\n\"\"\"\ncumprod\n\ndoc\"\"\"\n    besseljx(nu, x)\n\nScaled Bessel function of the first kind of order `nu`, $J_\\nu(x) e^{- | \\operatorname{Im}(x) |}$.\n\"\"\"\nbesseljx\n\ndoc\"\"\"\n    print(x)\n\nWrite (to the default output stream) a canonical (un-decorated) text representation of a value if there is one, otherwise call `show`. The representation used by `print` includes minimal formatting and tries to avoid Julia-specific details.\n\"\"\"\nprint\n\ndoc\"\"\"\n    filt(b, a, x, [si])\n\nApply filter described by vectors `a` and `b` to vector `x`, with an optional initial filter state vector `si` (defaults to zeros).\n\"\"\"\nfilt\n\ndoc\"\"\"\n    indexpids(S::SharedArray)\n\nReturns the index of the current worker into the `pids` vector, i.e., the list of workers mapping the SharedArray\n\"\"\"\nindexpids\n\ndoc\"\"\"\n    remotecall_wait(id, func, args...)\n\nPerform `wait(remotecall(...))` in one message.\n\"\"\"\nremotecall_wait\n\ndoc\"\"\"\n```rst\n..  append!(collection, collection2) -> collection.\n\nAdd the elements of ``collection2`` to the end of ``collection``.\n\n.. doctest::\n\n   julia> append!([1],[2,3])\n   3-element Array{Int64,1}:\n    1\n    2\n    3\n\n.. doctest::\n\n   julia> append!([1, 2, 3], [4, 5, 6])\n   6-element Array{Int64,1}:\n    1\n    2\n    3\n    4\n    5\n    6\n\nUse :func:`push!` to add individual items to ``collection`` which are not\nalready themselves in another collection.\nThe result is of the preceding example is equivalent to\n``push!([1, 2, 3], 4, 5, 6)``.\n```\n\"\"\"\nappend!\n\ndoc\"\"\"\n    find(A)\n\nReturn a vector of the linear indexes of the non-zeros in `A` (determined by `A[i]!=0`). A common use of this is to convert a boolean array to an array of indexes of the `true` elements.\n\"\"\"\nfind(A)\n\ndoc\"\"\"\n    find(f,A)\n\nReturn a vector of the linear indexes of `A` where `f` returns `true`.\n\"\"\"\nfind(f, A)\n\ndoc\"\"\"\n    ctranspose(A)\n\nThe conjugate transposition operator (`'`).\n\"\"\"\nctranspose\n\ndoc\"\"\"\n    skip(s, offset)\n\nSeek a stream relative to the current position.\n\"\"\"\nskip\n\ndoc\"\"\"\n    lu(A) -> L, U, p\n\nCompute the LU factorization of `A`, such that `A[p,:] = L*U`.\n\"\"\"\nlu\n\ndoc\"\"\"\n    @task\n\nWrap an expression in a `Task` without executing it, and return the `Task`. This only creates a task, and does not run it.\n\"\"\"\n:@task\n\ndoc\"\"\"\n    fld(x, y)\n\nLargest integer less than or equal to `x/y`.\n\"\"\"\nfld\n\ndoc\"\"\"\n    indmax(itr) -> Integer\n\nReturns the index of the maximum element in a collection.\n\"\"\"\nindmax\n\ndoc\"\"\"\n    writecsv(filename, A)\n\nEquivalent to `writedlm` with `delim` set to comma.\n\"\"\"\nwritecsv\n\ndoc\"\"\"\n    wstring(s)\n\nThis is a synonym for either `utf32(s)` or `utf16(s)`, depending on whether `Cwchar_t` is 32 or 16 bits, respectively. The synonym `WString` for `UTF32String` or `UTF16String` is also provided.\n\"\"\"\nwstring\n\ndoc\"\"\"\n    withenv(f::Function, kv::Pair...)\n\nExecute `f()` in an environment that is temporarily modified (not replaced as in `setenv`) by zero or more `\"var\"=>val` arguments `kv`. `withenv` is generally used via the `withenv(kv...) do ... end` syntax. A value of `nothing` can be used to temporarily unset an environment variable (if it is set). When `withenv` returns, the original environment has been restored.\n\"\"\"\nwithenv\n\ndoc\"\"\"\n    setdiff!(s, iterable)\n\nRemove each element of `iterable` from set `s` in-place.\n\"\"\"\nsetdiff!\n\ndoc\"\"\"\n    EOFError()\n\nNo more data was available to read from a file or stream.\n\"\"\"\nEOFError\n\ndoc\"\"\"\n    isascii(c::Union{Char,AbstractString}) -> Bool\n\nTests whether a character belongs to the ASCII character set, or whether this is true for all elements of a string.\n\"\"\"\nisascii\n\ndoc\"\"\"\n    ucfirst(string)\n\nReturns `string` with the first character converted to uppercase.\n\"\"\"\nucfirst\n\ndoc\"\"\"\n    copysign(x, y)\n\nReturn `x` such that it has the same sign as `y`\n\"\"\"\ncopysign\n\ndoc\"\"\"\n    getaddrinfo(host)\n\nGets the IP address of the `host` (may have to do a DNS lookup)\n\"\"\"\ngetaddrinfo\n\ndoc\"\"\"\n    @show\n\nShow an expression and result, returning the result.\n\"\"\"\n:@show\n\ndoc\"\"\"\n    showcompact(x)\n\nShow a more compact representation of a value. This is used for printing array elements. If a new type has a different compact representation, it should overload `showcompact(io, x)` where the first argument is a stream.\n\"\"\"\nshowcompact\n\ndoc\"\"\"\n    isleaftype(T)\n\nDetermine whether `T` is a concrete type that can have instances, meaning its only subtypes are itself and `None` (but `T` itself is not `None`).\n\"\"\"\nisleaftype\n\ndoc\"\"\"\n    svdfact(A, [thin=true]) -> SVD\n\nCompute the Singular Value Decomposition (SVD) of `A` and return an `SVD` object. `U`, `S`, `V` and `Vt` can be obtained from the factorization `F` with `F[:U]`, `F[:S]`, `F[:V]` and `F[:Vt]`, such that `A = U*diagm(S)*Vt`. If `thin` is `true`, an economy mode decomposition is returned. The algorithm produces `Vt` and hence `Vt` is more efficient to extract than `V`. The default is to produce a thin decomposition.\n\"\"\"\nsvdfact(A)\n\ndoc\"\"\"\n    svdfact(A, B) -> GeneralizedSVD\n\nCompute the generalized SVD of `A` and `B`, returning a `GeneralizedSVD` Factorization object `F`, such that `A = F[:U]*F[:D1]*F[:R0]*F[:Q]'` and `B = F[:V]*F[:D2]*F[:R0]*F[:Q]'`.\n\"\"\"\nsvdfact(A, B)\n\ndoc\"\"\"\n    string(xs...)\n\nCreate a string from any values using the `print` function.\n\"\"\"\nstring\n\ndoc\"\"\"\n    erfc(x)\n\nCompute the complementary error function of ``x``,\ndefined by $1 - \\operatorname{erf}(x)$.\n\"\"\"\nerfc\n\ndoc\"\"\"\n    prevfloat(f) -> AbstractFloat\n\nGet the previous floating point number in lexicographic order\n\"\"\"\nprevfloat\n\ndoc\"\"\"\n    rest(iter, state)\n\nAn iterator that yields the same elements as `iter`, but starting at the given `state`.\n\"\"\"\nrest\n\ndoc\"\"\"\n    getfield(value, name::Symbol)\n\nExtract a named field from a `value` of composite type. The syntax `a.b` calls `getfield(a, :b)`, and the syntax `a.(b)` calls `getfield(a, b)`.\n\"\"\"\ngetfield\n\ndoc\"\"\"\n    utf8(::Array{UInt8,1})\n\nCreate a UTF-8 string from a byte array.\n\"\"\"\nutf8(::Vector{UInt8})\n\ndoc\"\"\"\n    utf8(::Ptr{UInt8}, [length])\n\nCreate a UTF-8 string from the address of a C (0-terminated) string encoded in UTF-8. A copy is made; the ptr can be safely freed. If `length` is specified, the string does not have to be 0-terminated.\n\"\"\"\nutf8(::Ptr{UInt8}, length::Int = 1)\n\ndoc\"\"\"\n    utf8(s)\n\nConvert a string to a contiguous UTF-8 string (all characters must be valid UTF-8 characters).\n\"\"\"\nutf8(s)\n\ndoc\"\"\"\n    hvcat(rows::Tuple{Vararg{Int}}, values...)\n\nHorizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.\n\n```jldoctest\njulia> a, b, c, d, e, f = 1, 2, 3, 4, 5, 6\n(1,2,3,4,5,6)\n\njulia> [a b c; d e f]\n2x3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> hvcat((3,3), a,b,c,d,e,f)\n2x3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> [a b;c d; e f]\n3x2 Array{Int64,2}:\n 1  2\n 3  4\n 5  6\n\njulia> hvcat((2,2,2), a,b,c,d,e,f)\n3x2 Array{Int64,2}:\n 1  2\n 3  4\n 5  6\n```\n\nIf the first argument is a single integer `n`, then all block rows are assumed to have `n` block columns.\n\"\"\"\nhvcat\n\ndoc\"\"\"\n    besselj1(x)\n\nBessel function of the first kind of order 1, $J_1(x)$.\n\"\"\"\nbesselj1\n\ndoc\"\"\"\n    sinpi(x)\n\nCompute $\\sin(\\pi x)$ more accurately than `sin(pi*x)`, especially for large `x`.\n\"\"\"\nsinpi\n\ndoc\"\"\"\n    select!(v, k, [by=<transform>,] [lt=<comparison>,] [rev=false])\n\nPartially sort the vector `v` in place, according to the order specified by `by`, `lt` and `rev` so that the value at index `k` (or range of adjacent values if `k` is a range) occurs at the position where it would appear if the array were fully sorted via a non-stable algorithm. If `k` is a single index, that value is returned; if `k` is a range, an array of values at those indices is returned. Note that `select!` does not fully sort the input array.\n\"\"\"\nselect!\n\ndoc\"\"\"\n    maximum!(r, A)\n\nCompute the maximum value of `A` over the singleton dimensions of `r`, and write results to `r`.\n\"\"\"\nmaximum!\n\ndoc\"\"\"\n    prod(itr)\n\nReturns the product of all elements of a collection.\n\"\"\"\nprod(itr)\n\n\"\"\"\n    prod(A, dims)\n\nMultiply elements of an array over the given dimensions.\n\"\"\"\nprod(A, dims)\n\ndoc\"\"\"\n    Base.linearindexing(A)\n\n`linearindexing` defines how an AbstractArray most efficiently accesses its elements. If `Base.linearindexing(A)` returns `Base.LinearFast()`, this means that linear indexing with only one index is an efficient operation. If it instead returns `Base.LinearSlow()` (by default), this means that the array intrinsically accesses its elements with indices specified for every dimension. Since converting a linear index to multiple indexing subscripts is typically very expensive, this provides a traits-based mechanism to enable efficient generic code for all array types.\n\nAn abstract array subtype `MyArray` that wishes to opt into fast linear indexing behaviors should define `linearindexing` in the type-domain:\n\n    Base.linearindexing{T<:MyArray}(::Type{T}) = Base.LinearFast()\n\"\"\"\nBase.linearindexing\n\ndoc\"\"\"\n    isqrt(n)\n\nInteger square root: the largest integer `m` such that `m*m <= n`.\n\"\"\"\nisqrt\n\ndoc\"\"\"\n    log1p(x)\n\nAccurate natural logarithm of `1+x`. Throws `DomainError` for `Real` arguments less than -1.\n\nThere is an experimental variant in the `Base.Math.JuliaLibm` module, which is typically faster and more accurate.\n\"\"\"\nlog1p\n\ndoc\"\"\"\n    flipsign(x, y)\n\nReturn `x` with its sign flipped if `y` is negative. For example `abs(x) = flipsign(x,x)`.\n\"\"\"\nflipsign\n\ndoc\"\"\"\n    lbeta(x, y)\n\nNatural logarithm of the absolute value of the beta function $\\log(|\\operatorname{B}(x,y)|)$.\n\"\"\"\nlbeta\n\ndoc\"\"\"\n```rst\n..  randstring([rng,] len=8)\n\nCreate a random ASCII string of length ``len``, consisting of upper- and\nlower-case letters and the digits 0-9. The optional ``rng`` argument\nspecifies a random number generator, see :ref:`Random Numbers <random-numbers>`.\n```\n\"\"\"\nrandstring\n\ndoc\"\"\"\n    Float64(x [, mode::RoundingMode])\n\nCreate a Float64 from `x`. If `x` is not exactly representable then\n`mode` determines how `x` is rounded.\n\n```jldoctest\njulia> Float64(pi, RoundDown)\n3.141592653589793\n\njulia> Float64(pi, RoundUp)\n3.1415926535897936\n```\n\nSee `get_rounding` for available rounding modes.\n\"\"\"\nFloat64\n\ndoc\"\"\"\n    function_name(f::Function) -> Symbol\n\nGet the name of a generic `Function` as a symbol, or `:anonymous`.\n\"\"\"\nfunction_name\n\ndoc\"\"\"\n```rst\n..  addprocs(n::Integer; exeflags=``) -> List of process identifiers\n\nLaunches workers using the in-built ``LocalManager`` which only launches workers on the local host.\nThis can be used to take advantage of multiple cores. ``addprocs(4)`` will add 4 processes on the local machine.\n```\n\"\"\"\naddprocs(n::Integer)\n\ndoc\"\"\"\n```rst\n..  addprocs() -> List of process identifiers\n\nEquivalent to ``addprocs(CPU_CORES)``\n\nNote that workers do not run a ``.juliarc.jl`` startup script, nor do they synchronize their global state\n(such as global variables, new method definitions, and loaded modules) with any of the other running processes.\n```\n\"\"\"\naddprocs()\n\n\"\"\"\n```\naddprocs(machines; keyword_args...) -> List of process identifiers\n```\n\nAdd processes on remote machines via SSH. Requires julia to be installed in the same\nlocation on each node, or to be available via a shared file system.\n\n`machines` is a vector of machine specifications.  Worker are started for each specification.\n\nA machine specification is either a string `machine_spec` or a tuple - `(machine_spec, count)`.\n\n`machine_spec` is a string of the form `[user@]host[:port] [bind_addr[:port]]`. `user` defaults\nto current user, `port` to the standard ssh port. If `[bind_addr[:port]]` is specified, other\nworkers will connect to this worker at the specified `bind_addr` and `port`.\n\n`count` is the number of workers to be launched on the specified host. If specified as `:auto`\nit will launch as many workers as the number of cores on the specific host.\n\n\nKeyword arguments:\n\n* `tunnel`: if `true` then SSH tunneling will be used to connect to the worker from the\n            master process. Default is `false`.\n\n* `sshflags`: specifies additional ssh options, e.g.\n\n    sshflags=`-i /home/foo/bar.pem`\n\n* `max_parallel`: specifies the maximum number of workers connected to in parallel at a host.\n                  Defaults to 10.\n\n* `dir`: specifies the working directory on the workers. Defaults to the host's current\n         directory (as found by `pwd()`)\n\n* `exename`: name of the julia executable. Defaults to `\"\\$JULIA_HOME/julia\"` or\n             `\"\\$JULIA_HOME/julia-debug\"` as the case may be.\n\n* `exeflags`: additional flags passed to the worker processes.\n\n* `topology`: Specifies how the workers connect to each other. Sending a message\n            between unconnected workers results in an error.\n\n  + `topology=:all_to_all`  :  All processes are connected to each other.\n                      This is the default.\n\n  + `topology=:master_slave`  :  Only the driver process, i.e. pid 1 connects to the\n                        workers. The workers do not connect to each other.\n\n  + `topology=:custom`  :  The `launch` method of the cluster manager specifes the\n                  connection topology via fields `ident` and `connect_idents` in\n                  `WorkerConfig`. A worker with a cluster manager identity `ident`\n                  will connect to all workers specified in `connect_idents`.\n\n\nEnvironment variables :\n\nIf the master process fails to establish a connection with a newly launched worker within 60.0 seconds,\nthe worker treats it a fatal situation and terminates. This timeout can be controlled via environment\nvariable `JULIA_WORKER_TIMEOUT`. The value of `JULIA_WORKER_TIMEOUT` on the master process, specifies\nthe number of seconds a newly launched worker waits for connection establishment.\n\"\"\"\naddprocs(machines)\n\ndoc\"\"\"\n```rst\n..  addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers\n\nLaunches worker processes via the specified cluster manager.\n\nFor example Beowulf clusters are  supported via a custom cluster manager implemented in package ``ClusterManagers``.\n\nThe number of seconds a newly launched worker waits for connection establishment from the master can be\nspecified via variable ``JULIA_WORKER_TIMEOUT`` in the worker process's environment. Relevant only when using TCP/IP as transport.\n```\n\"\"\"\naddprocs(manager::ClusterManager)\n\ndoc\"\"\"\n    mkpath(path, [mode])\n\nCreate all directories in the given `path`, with permissions `mode`. `mode` defaults to 0o777, modified by the current file creation mask.\n\"\"\"\nmkpath\n\ndoc\"\"\"\n```rst\n..  lufact(A [,pivot=Val{true}]) -> F\n\nCompute the LU factorization of ``A``. The return type of ``F`` depends on the type of ``A``. In most cases, if ``A`` is a subtype ``S`` of AbstractMatrix with an element type ``T`` supporting ``+``, ``-``, ``*`` and ``/`` the return type is ``LU{T,S{T}}``. If pivoting is chosen (default) the element type should also support ``abs`` and ``<``. When ``A`` is sparse and have element of type ``Float32``, ``Float64``, ``Complex{Float32}``, or ``Complex{Float64}`` the return type is ``UmfpackLU``. Some examples are shown in the table below.\n\n======================= ========================= ========================================\nType of input ``A``     Type of output ``F``      Relationship between ``F`` and ``A``\n======================= ========================= ========================================\n:func:`Matrix`           ``LU``                   ``F[:L]*F[:U] == A[F[:p], :]``\n:func:`Tridiagonal`      ``LU{T,Tridiagonal{T}}`` ``F[:L]*F[:U] == A[F[:p], :]``\n:func:`SparseMatrixCSC`  ``UmfpackLU``            ``F[:L]*F[:U] == (F[:Rs] .* A)[F[:p], F[:q]]``\n======================= ========================= ========================================\n\nThe individual components of the factorization ``F`` can be accessed by indexing:\n\n=========== ======================================= ====== ======================== =============\nComponent   Description                             ``LU`` ``LU{T,Tridiagonal{T}}`` ``UmfpackLU``\n=========== ======================================= ====== ======================== =============\n``F[:L]``   ``L`` (lower triangular) part of ``LU``    \u2713            \u2713                        \u2713\n``F[:U]``   ``U`` (upper triangular) part of ``LU``    \u2713            \u2713                        \u2713\n``F[:p]``   (right) permutation ``Vector``             \u2713            \u2713                        \u2713\n``F[:P]``   (right) permutation ``Matrix``             \u2713            \u2713\n``F[:q]``   left permutation ``Vector``                                                      \u2713\n``F[:Rs]``  ``Vector`` of scaling factors                                                    \u2713\n``F[:(:)]`` ``(L,U,p,q,Rs)`` components                                                      \u2713\n=========== ======================================= ====== ======================== =============\n\n================== ====== ======================== =============\nSupported function ``LU`` ``LU{T,Tridiagonal{T}}`` ``UmfpackLU``\n================== ====== ======================== =============\n     ``/``            \u2713\n     ``\\``            \u2713                       \u2713             \u2713\n     ``cond``         \u2713                                     \u2713\n     ``det``          \u2713                       \u2713             \u2713\n     ``logdet``       \u2713                       \u2713\n     ``logabsdet``    \u2713                       \u2713\n     ``size``         \u2713                       \u2713\n================== ====== ======================== =============\n```\n\"\"\"\nlufact\n\ndoc\"\"\"\n    besselix(nu, x)\n\nScaled modified Bessel function of the first kind of order `nu`, $I_\\nu(x) e^{- | \\operatorname{Re}(x) |}$.\n\"\"\"\nbesselix\n\ndoc\"\"\"\n    union(s1,s2...)\n    \u222a(s1,s2...)\n\nConstruct the union of two or more sets. Maintains order with arrays.\n\"\"\"\nunion\n\ndoc\"\"\"\n    lstat(file)\n\nLike stat, but for symbolic links gets the info for the link itself rather than the file it refers to. This function must be called on a file path rather than a file object or a file descriptor.\n\"\"\"\nlstat\n\ndoc\"\"\"\n```rst\n..  mapfoldl(f, op, v0, itr)\n\nLike :func:`mapreduce`, but with guaranteed left associativity. ``v0``\nwill be used exactly once.\n```\n\"\"\"\nmapfoldl(f, op, v0, itr)\n\ndoc\"\"\"\n```rst\n..  mapfoldl(f, op, itr)\n\nLike ``mapfoldl(f, op, v0, itr)``, but using the first element of\n``itr`` as ``v0``. In general, this cannot be used with empty\ncollections (see ``reduce(op, itr)``).\n```\n\"\"\"\nmapfoldl(f, op, itr)\n\ndoc\"\"\"\n    realmax(T)\n\nThe highest finite value representable by the given floating-point DataType `T`.\n\"\"\"\nrealmax\n\ndoc\"\"\"\n    takebuf_string(b::IOBuffer)\n\nObtain the contents of an `IOBuffer` as a string, without copying. Afterwards, the IOBuffer is reset to its initial state.\n\"\"\"\ntakebuf_string\n\ndoc\"\"\"\n    pipeline(from, to, ...)\n\nCreate a pipeline from a data source to a destination. The source and destination can\nbe commands, I/O streams, strings, or results of other `pipeline` calls. At least one\nargument must be a command. Strings refer to filenames.\nWhen called with more than two arguments, they are chained together from left to right.\nFor example `pipeline(a,b,c)` is equivalent to `pipeline(pipeline(a,b),c)`. This provides a more\nconcise way to specify multi-stage pipelines.\n\n**Examples**:\n\n* ``run(pipeline(`ls`, `grep xyz`))``\n* ``run(pipeline(`ls`, \"out.txt\"))``\n* ``run(pipeline(\"out.txt\", `grep xyz`))``\n\n\"\"\"\npipeline(from, to, rest...)\n\ndoc\"\"\"\n    pipeline(command; stdin, stdout, stderr, append=false)\n\nRedirect I/O to or from the given `command`. Keyword arguments specify which of\nthe command's streams should be redirected. `append` controls whether file output\nappends to the file.\nThis is a more general version of the 2-argument `pipeline` function.\n`pipeline(from, to)` is equivalent to `pipeline(from, stdout=to)` when `from` is a\ncommand, and to `pipe(to, stdin=from)` when `from` is another kind of\ndata source.\n\n**Examples**:\n\n* ``run(pipeline(`dothings`, stdout=\"out.txt\", stderr=\"errs.txt\"))``\n* ``run(pipeline(`update`, stdout=\"log.txt\", append=true))``\n\n\"\"\"\npipeline(command)\n\ndoc\"\"\"\n    serialize(stream, value)\n\nWrite an arbitrary value to a stream in an opaque format, such that it can be read back by `deserialize`.\nThe read-back value will be as identical as possible to the original.\nIn general, this process will not work if the reading and writing are done by different versions of Julia,\nor an instance of Julia with a different system image.\n`Ptr` values are serialized as all-zero bit patterns (`NULL`).\n\"\"\"\nserialize\n\ndoc\"\"\"\n    sum(itr)\n\nReturns the sum of all elements in a collection.\n\"\"\"\nsum(itr)\n\ndoc\"\"\"\n    sum(A, dims)\n\nSum elements of an array over the given dimensions.\n\"\"\"\nsum(A, dims)\n\ndoc\"\"\"\n    sum(f, itr)\n\nSum the results of calling function `f` on each element of `itr`.\n\"\"\"\nsum(f::Function, itr)\n\ndoc\"\"\"\n    typemin(T)\n\nThe lowest value representable by the given (real) numeric DataType `T`.\n\"\"\"\ntypemin\n\ndoc\"\"\"\n    call(x, args...)\n\nIf `x` is not a `Function`, then `x(args...)` is equivalent to `call(x, args...)`. This means that function-like behavior can be added to any type by defining new `call` methods.\n\"\"\"\ncall\n\ndoc\"\"\"\n    countfrom(start=1, step=1)\n\nAn iterator that counts forever, starting at `start` and incrementing by `step`.\n\"\"\"\ncountfrom\n\ndoc\"\"\"\n    eof(stream) -> Bool\n\nTests whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return `false`. Therefore it is always safe to read one byte after seeing `eof` return `false`. `eof` will return `false` as long as buffered data is still available, even if the remote end of a connection is closed.\n\"\"\"\neof\n\ndoc\"\"\"\n    mktempdir([parent=tempdir()])\n\nCreate a temporary directory in the `parent` directory and return its path.\n\"\"\"\nmktempdir()\n\ndoc\"\"\"\n    mktempdir(f::Function, [parent=tempdir()])\n\nApply the function `f` to the result of `mktempdir(parent)` and remove the temporary directory upon completion.\n\"\"\"\nmktempdir(f::Function)\n\ndoc\"\"\"\n    tril(M)\n\nLower triangle of a matrix.\n\"\"\"\ntril(M)\n\ndoc\"\"\"\n    tril(M, k)\n\nReturns the lower triangle of `M` starting from the `k`th superdiagonal.\n\"\"\"\ntril(M,k)\n\ndoc\"\"\"\n    @edit\n\nEvaluates the arguments to the function call, determines their types, and calls the `edit` function on the resulting expression.\n\"\"\"\n:@edit\n\ndoc\"\"\"\n    subtypes(T::DataType)\n\nReturn a list of immediate subtypes of DataType `T`. Note that all currently loaded subtypes are included, including those not visible in the current module.\n\"\"\"\nsubtypes\n\ndoc\"\"\"\n    digits(n, [base], [pad])\n\nReturns an array of the digits of `n` in the given base, optionally padded with zeros to a specified size. More significant digits are at higher indexes, such that `n == sum([digits[k]*base^(k-1) for k=1:length(digits)])`.\n\"\"\"\ndigits\n\ndoc\"\"\"\n    bytes2hex(bin_arr::Array{UInt8, 1})\n\nConvert an array of bytes to its hexadecimal representation. All characters are in lower-case. Returns an `ASCIIString`.\n\"\"\"\nbytes2hex\n\ndoc\"\"\"\n    unlock(l::ReentrantLock)\n\nReleases ownership of the lock by the current task. If the lock had been acquired before, it just decrements an internal counter and returns immediately.\n\"\"\"\nunlock\n\ndoc\"\"\"\n```rst\n..  BigFloat(x)\n\nCreate an arbitrary precision floating point number. ``x`` may be\nan ``Integer``, a ``Float64`` or a ``BigInt``. The\nusual mathematical operators are defined for this type, and results\nare promoted to a ``BigFloat``.\n\nNote that because decimal literals are converted to floating point numbers\nwhen parsed, ``BigFloat(2.1)`` may not yield what you expect. You may instead\nprefer to initialize constants from strings via :func:`parse`, or using the\n``big`` string literal.\n\n.. doctest::\n\n   julia> BigFloat(2.1)\n   2.100000000000000088817841970012523233890533447265625000000000000000000000000000\n\n   julia> big\"2.1\"\n   2.099999999999999999999999999999999999999999999999999999999999999999999999999986\n```\n\"\"\"\nBigFloat\n\ndoc\"\"\"\n    xcorr(u,v)\n\nCompute the cross-correlation of two vectors.\n\"\"\"\nxcorr\n\ndoc\"\"\"\n    typeof(x)\n\nGet the concrete type of `x`.\n\"\"\"\ntypeof\n\ndoc\"\"\"\n    drop(iter, n)\n\nAn iterator that generates all but the first `n` elements of `iter`.\n\"\"\"\ndrop\n\ndoc\"\"\"\n    acsc(x)\n\nCompute the inverse cosecant of `x`, where the output is in radians\n\"\"\"\nacsc\n\ndoc\"\"\"\n    log(x)\n\nCompute the natural logarithm of `x`. Throws `DomainError` for negative `Real` arguments. Use complex negative arguments to obtain complex results.\n\nThere is an experimental variant in the `Base.Math.JuliaLibm` module, which is typically faster and more accurate.\n\"\"\"\nlog(x)\n\ndoc\"\"\"\n    log(b,x)\n\nCompute the base `b` logarithm of `x`. Throws `DomainError` for negative `Real` arguments.\n\"\"\"\nlog(b, x)\n\ndoc\"\"\"\n```rst\n..  trunc([T,] x, [digits, [base]])\n\n``trunc(x)`` returns the nearest integral value of the same type as ``x`` whose absolute\nvalue is less than or equal to ``x``.\n\n``trunc(T, x)`` converts the result to type ``T``, throwing an\n``InexactError`` if the value is not representable.\n\n``digits`` and ``base`` work as for :func:`round`.\n```\n\"\"\"\ntrunc\n\ndoc\"\"\"\n    @less\n\nEvaluates the arguments to the function call, determines their types, and calls the `less` function on the resulting expression.\n\"\"\"\n:@less\n\ndoc\"\"\"\n    broadcast_function(f)\n\nReturns a function `broadcast_f` such that `broadcast_function(f)(As...) === broadcast(f, As...)`. Most useful in the form `const broadcast_f = broadcast_function(f)`.\n\"\"\"\nbroadcast_function\n\ndoc\"\"\"\n    unsafe_convert(T,x)\n\nConvert `x` to a value of type `T`\n\nIn cases where `convert` would need to take a Julia object and turn it into a `Ptr`, this function should be used to define and perform that conversion.\n\nBe careful to ensure that a julia reference to `x` exists as long as the result of this function will be used. Accordingly, the argument `x` to this function should never be an expression, only a variable name or field reference. For example, `x=a.b.c` is acceptable, but `x=[a,b,c]` is not.\n\nThe `unsafe` prefix on this function indicates that using the result of this function after the `x` argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.\n\"\"\"\nunsafe_convert\n\ndoc\"\"\"\n    warn(msg)\n\nDisplay a warning. Argument `msg` is a string describing the warning to be displayed.\n\"\"\"\nwarn\n\ndoc\"\"\"\n    erfinv(x)\n\nCompute the inverse error function of a real `x`,\ndefined by $\\operatorname{erf}(\\operatorname{erfinv}(x)) = x$.\n\"\"\"\nerfinv\n\ndoc\"\"\"\n    @async\n\nLike `@schedule`, `@async` wraps an expression in a `Task` and adds it to the local machine's scheduler queue. Additionally it adds the task to the set of items that the nearest enclosing `@sync` waits for. `@async` also wraps the expression in a `let x=x, y=y, ...` block to create a new scope with copies of all variables referenced in the expression.\n\"\"\"\n:@async\n\ndoc\"\"\"\n    rotr90(A)\n\nRotate matrix `A` right 90 degrees.\n\"\"\"\nrotr90(A)\n\ndoc\"\"\"\n    rotr90(A, k)\n\nRotate matrix `A` right 90 degrees an integer `k` number of times. If `k` is zero or a multiple of four, this is equivalent to a `copy`.\n\"\"\"\nrotr90(A, k)\n\ndoc\"\"\"\n    readdir([dir]) -> Vector{ByteString}\n\nReturns the files and directories in the directory `dir` (or the current working directory if not given).\n\"\"\"\nreaddir\n\ndoc\"\"\"\n    seek(s, pos)\n\nSeek a stream to the given position.\n\"\"\"\nseek\n\ndoc\"\"\"\n    acosd(x)\n\nCompute the inverse cosine of `x`, where the output is in degrees\n\"\"\"\nacosd\n\ndoc\"\"\"\n    triu(M)\n\nUpper triangle of a matrix.\n\"\"\"\ntriu(M)\n\ndoc\"\"\"\n    triu(M, k)\n\nReturns the upper triangle of `M` starting from the `k`th superdiagonal.\n\"\"\"\ntriu(M, k)\n\ndoc\"\"\"\n    instances(T::Type)\n\nReturn a collection of all instances of the given type, if applicable. Mostly used for enumerated types (see `@enum`).\n\"\"\"\ninstances\n\ndoc\"\"\"\n    besselj0(x)\n\nBessel function of the first kind of order 0, $J_0(x)$.\n\"\"\"\nbesselj0\n\ndoc\"\"\"\n    erfcinv(x)\n\nCompute the inverse error complementary function of a real `x`,\ndefined by $\\operatorname{erfc}(\\operatorname{erfcinv}(x)) = x$.\n\"\"\"\nerfcinv\n\ndoc\"\"\"\n    minabs(itr)\n\nCompute the minimum absolute value of a collection of values.\n\"\"\"\nminabs(itr)\n\ndoc\"\"\"\n    minabs(A, dims)\n\nCompute the minimum absolute values over given dimensions.\n\"\"\"\nminabs(A, dims)\n\ndoc\"\"\"\n    popdisplay()\n    popdisplay(d::Display)\n\nPop the topmost backend off of the display-backend stack, or the topmost copy of `d` in the second variant.\n\"\"\"\npopdisplay\n\ndoc\"\"\"\n    readdlm(source, delim::Char, T::Type, eol::Char; header=false, skipstart=0, skipblanks=true, use_mmap, ignore_invalid_chars=false, quotes=true, dims, comments=true, comment_char='#')\n\nRead a matrix from the source where each line (separated by `eol`) gives one row, with elements separated by the given delimeter. The source can be a text file, stream or byte array. Memory mapped files can be used by passing the byte array representation of the mapped segment as source.\n\nIf `T` is a numeric type, the result is an array of that type, with any non-numeric elements as `NaN` for floating-point types, or zero. Other useful values of `T` include `ASCIIString`, `AbstractString`, and `Any`.\n\nIf `header` is `true`, the first row of data will be read as header and the tuple `(data_cells, header_cells)` is returned instead of only `data_cells`.\n\nSpecifying `skipstart` will ignore the corresponding number of initial lines from the input.\n\nIf `skipblanks` is `true`, blank lines in the input will be ignored.\n\nIf `use_mmap` is `true`, the file specified by `source` is memory mapped for potential speedups. Default is `true` except on Windows. On Windows, you may want to specify `true` if the file is large, and is only read once and not written to.\n\nIf `ignore_invalid_chars` is `true`, bytes in `source` with invalid character encoding will be ignored. Otherwise an error is thrown indicating the offending character position.\n\nIf `quotes` is `true`, column enclosed within double-quote (\") characters are allowed to contain new lines and column delimiters. Double-quote characters within a quoted field must be escaped with another double-quote.  Specifying `dims` as a tuple of the expected rows and columns (including header, if any) may speed up reading of large files.  If `comments` is `true`, lines beginning with `comment_char` and text following `comment_char` in any line are ignored.\n\"\"\"\nreaddlm(source, delim, T, eol)\n\ndoc\"\"\"\n    readdlm(source, delim::Char, eol::Char; options...)\n\nIf all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a cell array of numbers and strings is returned.\n\"\"\"\nreaddlm(source, delim::Char, eol::Char)\n\ndoc\"\"\"\n    readdlm(source, delim::Char, T::Type; options...)\n\nThe end of line delimiter is taken as `n`.\n\"\"\"\nreaddlm(source, delim::Char, T::Type)\n\ndoc\"\"\"\n    readdlm(source, delim::Char; options...)\n\nThe end of line delimiter is taken as `n`. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a cell array of numbers and strings is returned.\n\"\"\"\nreaddlm(source, delim::Char)\n\ndoc\"\"\"\n    readdlm(source, T::Type; options...)\n\nThe columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as `n`.\n\"\"\"\nreaddlm(source, T::Type)\n\ndoc\"\"\"\n    readdlm(source; options...)\n\nThe columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as `n`. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a cell array of numbers and strings is returned.\n\"\"\"\nreaddlm(source)\n\ndoc\"\"\"\n    filesize(path...)\n\nEquivalent to `stat(file).size`\n\"\"\"\nfilesize\n\ndoc\"\"\"\n    sinc(x)\n\nCompute $\\sin(\\pi x) / (\\pi x)$ if $x \\neq 0$, and $1$ if $x = 0$.\n\"\"\"\nsinc\n\ndoc\"\"\"\n    utf16(s)\n\nCreate a UTF-16 string from a byte array, array of `UInt16`, or any other string type. (Data must be valid UTF-16. Conversions of byte arrays check for a byte-order marker in the first two bytes, and do not include it in the resulting string.)\n\nNote that the resulting `UTF16String` data is terminated by the NUL codepoint (16-bit zero), which is not treated as a character in the string (so that it is mostly invisible in Julia); this allows the string to be passed directly to external functions requiring NUL-terminated data. This NUL is appended automatically by the `utf16(s)` conversion function. If you have a `UInt16` array `A` that is already NUL-terminated valid UTF-16 data, then you can instead use `UTF16String(A)` to construct the string without making a copy of the data and treating the NUL as a terminator rather than as part of the string.\n\"\"\"\nutf16(s)\n\ndoc\"\"\"\n    utf16(::Union{Ptr{UInt16},Ptr{Int16}} [, length])\n\nCreate a string from the address of a NUL-terminated UTF-16 string. A copy is made; the pointer can be safely freed. If `length` is specified, the string does not have to be NUL-terminated.\n\"\"\"\nutf16(::Union{Ptr{UInt16},Ptr{Int16}}, length=?)\n\ndoc\"\"\"\n    median(v[, region])\n\nCompute the median of whole array `v`, or optionally along the dimensions in `region`. For even number of elements no exact median element exists, so the result is equivalent to calculating mean of two median elements. `NaN` is returned if the data contains any `NaN` values. For applications requiring the handling of missing data, the `DataArrays` package is recommended.\n\"\"\"\nmedian\n\ndoc\"\"\"\n    cglobal((symbol, library) [, type=Void])\n\nObtain a pointer to a global variable in a C-exported shared library, specified exactly as in `ccall`. Returns a `Ptr{Type}`, defaulting to `Ptr{Void}` if no Type argument is supplied. The values can be read or written by `unsafe_load` or `unsafe_store!`, respectively.\n\"\"\"\ncglobal\n\ndoc\"\"\"\n    one(x)\n\nGet the multiplicative identity element for the type of `x` (`x` can also specify the type itself). For matrices, returns an identity matrix of the appropriate size and type.\n\"\"\"\none\n\ndoc\"\"\"\n    parseip(addr)\n\nParse a string specifying an IPv4 or IPv6 ip address.\n\"\"\"\nparseip\n\ndoc\"\"\"\n    rationalize([Type=Int,] x; tol=eps(x))\n\nApproximate floating point number `x` as a Rational number with components of the given integer type. The result will differ from `x` by no more than `tol`.\n\"\"\"\nrationalize\n\ndoc\"\"\"\n    splice!(collection, index, [replacement]) -> item\n\nRemove the item at the given index, and return the removed item. Subsequent items\nare shifted down to fill the resulting gap. If specified, replacement values from\nan ordered collection will be spliced in place of the removed item.\n\n```jldoctest\njulia> A = [6, 5, 4, 3, 2, 1]; splice!(A, 5)\n2\n\njulia> A\n5-element Array{Int64,1}:\n 6\n 5\n 4\n 3\n 1\n\njulia> splice!(A, 5, -1)\n1\n\njulia> A\n5-element Array{Int64,1}:\n  6\n  5\n  4\n  3\n -1\n\njulia> splice!(A, 1, [-1, -2, -3])\n6\n\njulia> A\n7-element Array{Int64,1}:\n -1\n -2\n -3\n  5\n  4\n  3\n -1\n```\n\nTo insert `replacement` before an index `n` without removing any items, use\n`splice!(collection, n:n-1, replacement)`.\n\"\"\"\nsplice!(collection, index, replacement = ?)\n\ndoc\"\"\"\n    splice!(collection, range, [replacement]) -> items\n\nRemove items in the specified index range, and return a collection containing the\nremoved items. Subsequent items are shifted down to fill the resulting gap.\nIf specified, replacement values from an ordered collection will be spliced in place\nof the removed items.\n\nTo insert `replacement` before an index `n` without removing any items, use\n`splice!(collection, n:n-1, replacement)`.\n\n```jldoctest\njulia> splice!(A, 4:3, 2)\n0-element Array{Int64,1}\n\njulia> A\n8-element Array{Int64,1}:\n -1\n -2\n -3\n  2\n  5\n  4\n  3\n -1\n```\n\"\"\"\nsplice!(collection, range::Range, replacement)\n\ndoc\"\"\"\n    endof(collection) -> Integer\n\nReturns the last index of the collection.\n\n```jldoctest\njulia> endof([1,2,4])\n3\n```\n\"\"\"\nendof\n\ndoc\"\"\"\n    isfifo(path) -> Bool\n\nReturns `true` if `path` is a FIFO, `false` otherwise.\n\"\"\"\nisfifo\n\ndoc\"\"\"\n    Channel{T}(sz::Int)\n\nConstructs a `Channel` that can hold a maximum of `sz` objects of type `T`. `put!` calls on a full channel block till an object is removed with `take!`.\n\nOther constructors:\n\n- `Channel()` - equivalent to `Channel{Any}(32)`\n- `Channel(sz::Int)` equivalent to `Channel{Any}(sz)`\n\"\"\"\nChannel\n\ndoc\"\"\"\n    next(iter, state) -> item, state\n\nFor a given iterable object and iteration state, return the current item and the next iteration state\n\"\"\"\nnext\n\ndoc\"\"\"\n    unshift!(collection, items...) -> collection\n\nInsert one or more `items` at the beginning of `collection`.\n\n```jldoctest\n  julia> unshift!([1, 2, 3, 4], 5, 6)\n  6-element Array{Int64,1}:\n   5\n   6\n   1\n   2\n   3\n   4\n```\n\"\"\"\nunshift!\n\ndoc\"\"\"\n    log2(x)\n\nCompute the logarithm of `x` to base 2. Throws `DomainError` for negative `Real` arguments.\n\"\"\"\nlog2\n\ndoc\"\"\"\n```rst\n..  SymTridiagonal(d, du)\n\nConstruct a real symmetric tridiagonal matrix from the diagonal and upper diagonal, respectively. The result is of type ``SymTridiagonal`` and provides efficient specialized eigensolvers, but may be converted into a regular matrix with :func:`full`.\n```\n\"\"\"\nSymTridiagonal\n\ndoc\"\"\"\n    colon(start, [step], stop)\n\nCalled by `:` syntax for constructing ranges.\n\"\"\"\ncolon\n\ndoc\"\"\"\n    Base64EncodePipe(ostream)\n\nReturns a new write-only I/O stream, which converts any bytes written to it into base64-encoded ASCII bytes written to `ostream`. Calling `close` on the `Base64Pipe` stream is necessary to complete the encoding (but does not close `ostream`).\n\"\"\"\nBase64EncodePipe\n\ndoc\"\"\"\n    issetgid(path) -> Bool\n\nReturns `true` if `path` has the setgid flag set, `false` otherwise.\n\"\"\"\nissetgid\n\ndoc\"\"\"\n    isnull(x)\n\nIs the `Nullable` object `x` null, i.e. missing a value?\n\"\"\"\nisnull\n\ndoc\"\"\"\n    abs2(x)\n\nSquared absolute value of `x`\n\"\"\"\nabs2\n\ndoc\"\"\"\n    write(stream, x)\n\nWrite the canonical binary representation of a value to the given stream.\nReturns the number of bytes written into the stream.\n\nYou can write multiple values with the same :func:`write` call.\ni.e. the following are equivalent:\n\n    write(stream, x, y...)\n    write(stream, x) + write(stream, y...)\n\"\"\"\nwrite\n\ndoc\"\"\"\n    sizehint!(s, n)\n\nSuggest that collection `s` reserve capacity for at least `n` elements. This can improve performance.\n\"\"\"\nsizehint!\n\ndoc\"\"\"\n    permute!(v, p)\n\nPermute vector `v` in-place, according to permutation `p`. No checking is done to verify that `p` is a permutation.\n\nTo return a new permutation, use `v[p]`. Note that this is generally faster than `permute!(v,p)` for large vectors.\n\"\"\"\npermute!\n\ndoc\"\"\"\n    ifelse(condition::Bool, x, y)\n\nReturn `x` if `condition` is `true`, otherwise return `y`. This differs from `?` or `if` in that it is an ordinary function, so all the arguments are evaluated first. In some cases, using `ifelse` instead of an `if` statement can eliminate the branch in generated code and provide higher performance in tight loops.\n\"\"\"\nifelse\n\ndoc\"\"\"\n    ispow2(n) -> Bool\n\nTest whether `n` is a power of two\n\"\"\"\nispow2\n\ndoc\"\"\"\n    vcat(A...)\n\nConcatenate along dimension 1\n\"\"\"\nvcat\n\ndoc\"\"\"\n    isgraph(c::Union{Char,AbstractString}) -> Bool\n\nTests whether a character is printable, and not a space, or whether this is true for all elements of a string. Any character that would cause a printer to use ink should be classified with `isgraph(c)==true`.\n\"\"\"\nisgraph\n\ndoc\"\"\"\n    OutOfMemoryError()\n\nAn operation allocated too much memory for either the system or the garbage collector to handle properly.\n\"\"\"\nOutOfMemoryError\n\ndoc\"\"\"\n```rst\n..  zip(iters...)\n\nFor a set of iterable objects, returns an iterable of tuples, where the ``i``\\ th tuple contains the ``i``\\ th component of each input iterable.\n\nNote that :func:`zip` is its own inverse: ``collect(zip(zip(a...)...)) == collect(a)``.\n```\n\"\"\"\nzip\n\ndoc\"\"\"\n    SystemError(prefix::AbstractString, [errno::Int32])\n\nA system call failed with an error code (in the `errno` global variable).\n\"\"\"\nSystemError\n\ndoc\"\"\"\n    binomial(n,k)\n\nNumber of ways to choose `k` out of `n` items\n\"\"\"\nbinomial\n\ndoc\"\"\"\n    rot180(A)\n\nRotate matrix `A` 180 degrees.\n\"\"\"\nrot180(A)\n\ndoc\"\"\"\n    rot180(A, k)\n\nRotate matrix `A` 180 degrees an integer `k` number of times. If `k` is even, this is equivalent to a `copy`.\n\"\"\"\nrot180(A, k)\n\ndoc\"\"\"\n    .<=(x, y)\n    .\u2264(x,y)\n\nElement-wise less-than-or-equals comparison operator.\n\"\"\"\nBase.(:(.<=))\n\ndoc\"\"\"\n    checkbounds(array, indexes...)\n\nThrow an error if the specified indexes are not in bounds for the given array.\nSubtypes of `AbstractArray` should specialize this method if they need to\nprovide custom bounds checking behaviors.\n\"\"\"\ncheckbounds(array, indexes...)\n\ndoc\"\"\"\n    checkbounds(::Type{Bool}, dimlength::Integer, index)\n\nReturn a `Bool` describing if the given index is within the bounds of the given\ndimension length. Custom types that would like to behave as indices for all\narrays can extend this method in order to provide a specialized bounds checking\nimplementation.\n\"\"\"\ncheckbounds(::Type{Bool}, ::Integer, index)\n\ndoc\"\"\"\n    asec(x)\n\nCompute the inverse secant of `x`, where the output is in radians\n\"\"\"\nasec\n\ndoc\"\"\"\n    rank(M)\n\nCompute the rank of a matrix.\n\"\"\"\nrank\n\ndoc\"\"\"\n    max(x, y, ...)\n\nReturn the maximum of the arguments. Operates elementwise over arrays.\n\"\"\"\nmax\n\ndoc\"\"\"\n    versioninfo([verbose::Bool])\n\nPrint information about the version of Julia in use. If the `verbose` argument is `true`, detailed system information is shown as well.\n\"\"\"\nversioninfo\n\ndoc\"\"\"\n    DimensionMismatch([msg])\n\nThe objects called do not have matching dimensionality.\nOptional argument `msg` is a descriptive error string.\n\"\"\"\nDimensionMismatch\n\ndoc\"\"\"\n    take!(RemoteRef)\n\nFetch the value of a remote reference, removing it so that the reference is empty again.\n\"\"\"\ntake!(::RemoteRef)\n\ndoc\"\"\"\n    take!(Channel)\n\nRemoves and returns a value from a `Channel`. Blocks till data is available.\n\"\"\"\ntake!(::Channel)\n\ndoc\"\"\"\n    sort!(v, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])\n\nSort the vector `v` in place. `QuickSort` is used by default for numeric arrays while `MergeSort` is used for other arrays. You can specify an algorithm to use via the `alg` keyword (see Sorting Algorithms for available algorithms). The `by` keyword lets you provide a function that will be applied to each element before comparison; the `lt` keyword allows providing a custom \"less than\" function; use `rev=true` to reverse the sorting order. These options are independent and can be used together in all possible combinations: if both `by` and `lt` are specified, the `lt` function is applied to the result of the `by` function; `rev=true` reverses whatever ordering specified via the `by` and `lt` keywords.\n\"\"\"\nsort!\n\ndoc\"\"\"\n    kill(p::Process, signum=SIGTERM)\n\nSend a signal to a process. The default is to terminate the process.\n\"\"\"\nkill(p::Process, signum=SIGTERM)\n\ndoc\"\"\"\n    kill(manager::FooManager, pid::Int, config::WorkerConfig)\n\nImplemented by cluster managers. It is called on the master process, by `rmprocs`. It should cause the remote worker specified by `pid` to exit. `Base.kill(manager::ClusterManager.....)` executes a remote `exit()` on `pid`\n\"\"\"\nkill(manager, pid::Int, config::WorkerConfig)\n\ndoc\"\"\"\n```rst\n..  logm(A)\n\nIf ``A`` has no negative real eigenvalue, compute the principal matrix logarithm of ``A``, i.e. the unique matrix :math:`X` such that :math:`e^X = A` and :math:`-\\pi < Im(\\lambda) < \\pi` for all the eigenvalues :math:`\\lambda` of :math:`X`. If ``A`` has nonpositive eigenvalues, a warning is printed and whenever possible a nonprincipal matrix function is returned.\n\nIf ``A`` is symmetric or Hermitian, its eigendecomposition (:func:`eigfact`) is used, if ``A`` is triangular an improved version of the inverse scaling and squaring method is employed (see [AH12]_ and [AHR13]_). For general matrices, the complex Schur form (:func:`schur`) is computed and the triangular algorithm is used on the triangular factor.\n\n.. [AH12] Awad H. Al-Mohy and Nicholas J. Higham, \"Improved inverse  scaling\n   and squaring algorithms for the matrix logarithm\", SIAM Journal on\n   Scientific Computing, 34(4), 2012, C153-C169.\n   `doi:10.1137/110852553 <http://dx.doi.org/10.1137/110852553>`_\n.. [AHR13] Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton,\n   \"Computing the Fr\u00e9chet derivative of the matrix logarithm and estimating\n   the condition number\", SIAM Journal on Scientific Computing, 35(4), 2013,\n   C394-C410.\n   `doi:10.1137/120885991 <http://dx.doi.org/10.1137/120885991>`_\n```\n\"\"\"\nlogm\n\ndoc\"\"\"\n    sylvester(A, B, C)\n\nComputes the solution `X` to the Sylvester equation `AX + XB + C = 0`, where `A`, `B` and `C` have compatible dimensions and `A` and `-B` have no eigenvalues with equal real part.\n\"\"\"\nsylvester\n\ndoc\"\"\"\n    broadcast!(f, dest, As...)\n\nLike `broadcast`, but store the result of `broadcast(f, As...)` in the `dest` array. Note that `dest` is only used to store the result, and does not supply arguments to `f` unless it is also listed in the `As`, as in `broadcast!(f, A, A, B)` to perform `A[:] = broadcast(f, A, B)`.\n\"\"\"\nbroadcast!\n\ndoc\"\"\"\n    cross(x, y)\n    \u00d7(x,y)\n\nCompute the cross product of two 3-vectors.\n\"\"\"\ncross\n\ndoc\"\"\"\n    strides(A)\n\nReturns a tuple of the memory strides in each dimension\n\"\"\"\nstrides\n\ndoc\"\"\"\n    keys(collection)\n\nReturn an iterator over all keys in a collection. `collect(keys(d))` returns an array of keys.\n\"\"\"\nkeys\n\ndoc\"\"\"\n    repeat(A, inner = Int[], outer = Int[])\n\nConstruct an array by repeating the entries of `A`. The i-th element of `inner` specifies the number of times that the individual entries of the i-th dimension of `A` should be repeated. The i-th element of `outer` specifies the number of times that a slice along the i-th dimension of `A` should be repeated.\n\"\"\"\nrepeat\n\ndoc\"\"\"\n    scale(A, b)\n    scale(b, A)\n\nScale an array `A` by a scalar `b`, returning a new array.\n\nIf `A` is a matrix and `b` is a vector, then `scale(A,b)` scales each column `i` of `A` by `b[i]` (similar to `A*diagm(b)`), while `scale(b,A)` scales each row `i` of `A` by `b[i]` (similar to `diagm(b)*A`), returning a new array.\n\nNote: for large `A`, `scale` can be much faster than `A .* b` or `b .* A`, due to the use of BLAS.\n\"\"\"\nscale\n\ndoc\"\"\"\n    ReentrantLock()\n\nCreates a reentrant lock. The same task can acquire the lock as many times as required. Each lock must be matched with an unlock.\n\"\"\"\nReentrantLock\n\ndoc\"\"\"\n    real(z)\n\nReturn the real part of the complex number `z`\n\"\"\"\nreal\n\ndoc\"\"\"\n    gperm(file)\n\nLike uperm but gets the permissions of the group owning the file\n\"\"\"\ngperm\n\ndoc\"\"\"\n    nb_available(stream)\n\nReturns the number of bytes available for reading before a read from this stream or buffer will block.\n\"\"\"\nnb_available\n\ndoc\"\"\"\n    finalize(x)\n\nImmediately run finalizers registered for object `x`.\n\"\"\"\nfinalize\n\ndoc\"\"\"\n    rand([rng], [S], [dims...])\n\nPick a random element or array of random elements from the set of values specified by `S`; `S` can be\n\n* an indexable collection (for example `1:n` or `['x','y','z']`), or\n* a type: the set of values to pick from is then equivalent to\n`typemin(S):typemax(S)` for integers (this is not applicable to `BigInt`),\nand to $[0, 1)$ for floating point numbers;\n\n`S` defaults to `Float64`.\n\"\"\"\nrand\n\ndoc\"\"\"\n    bitpack(A::AbstractArray{T,N}) -> BitArray\n\nConverts a numeric array to a packed boolean array\n\"\"\"\nbitpack\n\ndoc\"\"\"\n    base(base, n, [pad])\n\nConvert an integer to a string in the given base, optionally specifying a number of digits to pad to. The base can be specified as either an integer, or as a `UInt8` array of character values to use as digit symbols.\n\"\"\"\nbase\n\ndoc\"\"\"\n    Timer(callback::Function, delay, repeat=0)\n\nCreate a timer to call the given `callback` function. The `callback` is passed one argument, the timer object itself. The callback will be invoked after the specified initial `delay`, and then repeating with the given `repeat` interval. If `repeat` is `0`, the timer is only triggered once. Times are in seconds. A timer is stopped and has its resources freed by calling `close` on it.\n\"\"\"\nTimer(::Function,delay,repeat=0)\n\ndoc\"\"\"\n    Timer(delay, repeat=0)\n\nCreate a timer that wakes up tasks waiting for it (by calling `wait` on the timer object) at a specified interval.  Times are in seconds.  Waiting tasks are woken with an error when the timer is closed (by `close`). Use `isopen` to check whether a timer is still active.\n\"\"\"\nTimer(delay, repeat=0)\n\ndoc\"\"\"\n    BoundsError([a],[i])\n\nAn indexing operation into an array, `a`, tried to access an out-of-bounds element, `i`.\n\"\"\"\nBoundsError\n\ndoc\"\"\"\n    disable_sigint(f::Function)\n\nDisable Ctrl-C handler during execution of a function, for calling external code that is not interrupt safe. Intended to be called using `do` block syntax as follows:\n\n    disable_sigint() do\n        # interrupt-unsafe code\n        ...\n    end\n\"\"\"\ndisable_sigint\n\ndoc\"\"\"\n```rst\n..  svdfact!(A, [thin=true]) -> SVD\n\n``svdfact!`` is the same as :func:`svdfact`, but saves space by overwriting the input ``A``, instead of creating a copy. If ``thin`` is ``true``, an economy mode decomposition is returned. The default is to produce a thin decomposition.\n```\n\"\"\"\nsvdfact!\n\ndoc\"\"\"\n    hist2d(M, e1, e2) -> (edge1, edge2, counts)\n\nCompute a \"2d histogram\" of a set of N points specified by N-by-2 matrix `M`. Arguments `e1` and `e2` are bins for each dimension, specified either as integer bin counts or vectors of bin edges. The result is a tuple of `edge1` (the bin edges used in the first dimension), `edge2` (the bin edges used in the second dimension), and `counts`, a histogram matrix of size `(length(edge1)-1, length(edge2)-1)`. Note: Julia does not ignore `NaN` values in the computation.\n\"\"\"\nhist2d\n\ndoc\"\"\"\n    which(f, types)\n\nReturns the method of `f` (a `Method` object) that would be called for arguments of the given `types`.\n\nIf `types` is an abstract type, then the method that would be called by `invoke` is returned.\n\"\"\"\nwhich(f, types)\n\ndoc\"\"\"\n    which(symbol)\n\nReturn the module in which the binding for the variable referenced by `symbol` was created.\n\"\"\"\nwhich(symbol)\n\ndoc\"\"\"\n    conv2(u,v,A)\n\n2-D convolution of the matrix `A` with the 2-D separable kernel generated by the vectors `u` and `v`. Uses 2-D FFT algorithm\n\"\"\"\nconv2(u, v, A)\n\ndoc\"\"\"\n    conv2(B,A)\n\n2-D convolution of the matrix `B` with the matrix `A`. Uses 2-D FFT algorithm\n\"\"\"\nconv2(B, A)\n\ndoc\"\"\"\n    broadcast_getindex(A, inds...)\n\nBroadcasts the `inds` arrays to a common size like `broadcast`, and returns an array of the results `A[ks...]`, where `ks` goes over the positions in the broadcast.\n\"\"\"\nbroadcast_getindex\n\ndoc\"\"\"\n    findn(A)\n\nReturn a vector of indexes for each dimension giving the locations of the non-zeros in `A` (determined by `A[i]!=0`).\n\"\"\"\nfindn\n\ndoc\"\"\"\n    invoke(f, (types...), args...)\n\nInvoke a method for the given generic function matching the specified types (as a tuple), on the specified arguments. The arguments must be compatible with the specified types. This allows invoking a method other than the most specific matching method, which is useful when the behavior of a more general definition is explicitly needed (often as part of the implementation of a more specific method of the same function).\n\"\"\"\ninvoke\n\ndoc\"\"\"\n    parse(str, start; greedy=true, raise=true)\n\nParse the expression string and return an expression (which could later be passed to eval for execution). `start` is the index of the first character to start parsing. If `greedy` is `true` (default), `parse` will try to consume as much input as it can; otherwise, it will stop as soon as it has parsed a valid expression. Incomplete but otherwise syntactically valid expressions will return `Expr(:incomplete, \"(error message)\")`. If `raise` is `true` (default), syntax errors other than incomplete expressions will raise an error. If `raise` is `false`, `parse` will return an expression that will raise an error upon evaluation.\n\"\"\"\nparse(str, start)\n\ndoc\"\"\"\n    parse(str; raise=true)\n\nParse the expression string greedily, returning a single expression. An error is thrown if there are additional characters after the first expression. If `raise` is `true` (default), syntax errors will raise an error; otherwise, `parse` will return an expression that will raise an error upon evaluation.\n\"\"\"\nparse(str)\n\ndoc\"\"\"\n    parse(type, str, [base])\n\nParse a string as a number. If the type is an integer type, then a base can be specified (the default is 10). If the type is a floating point type, the string is parsed as a decimal floating point number. If the string does not contain a valid number, an error is raised.\n\"\"\"\nparse(T::Type, str, base=Int)\n\ndoc\"\"\"\n    touch(path::AbstractString)\n\nUpdate the last-modified timestamp on a file to the current time.\n\"\"\"\ntouch\n\ndoc\"\"\"\n```rst\n..  bkfact!(A) -> BunchKaufman\n\n``bkfact!`` is the same as :func:`bkfact`, but saves space by overwriting the input ``A``, instead of creating a copy.\n```\n\"\"\"\nbkfact!\n\ndoc\"\"\"\n    ^(x, y)\n\nExponentiation operator.\n\"\"\"\nBase.(:(^))(x, y)\n\ndoc\"\"\"\n    ^(s, n)\n\nRepeat `n` times the string `s`. The `repeat` function is an alias to this operator.\n\n```jldoctest\njulia> \"Test \"^3\n\"Test Test Test \"\n```\n\"\"\"\nBase.(:(^))(s::AbstractString, n::Int)\n\ndoc\"\"\"\n    position(s)\n\nGet the current position of a stream.\n\"\"\"\nposition\n\ndoc\"\"\"\n    selectperm(v, k, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])\n\nReturn a partial permutation of the the vector `v`, according to the order specified by `by`, `lt` and `rev`, so that `v[output]` returns the first `k` (or range of adjacent values if `k` is a range) values of a fully sorted version of `v`. If `k` is a single index (Integer), an array of the first `k` indices is returned; if `k` is a range, an array of those indices is returned. Note that the handling of integer values for `k` is different from `select` in that it returns a vector of `k` elements instead of just the `k` th element. Also note that this is equivalent to, but more efficient than, calling `sortperm(...)[k]`\n\"\"\"\nselectperm\n\ndoc\"\"\"\n    isabspath(path::AbstractString) -> Bool\n\nDetermines whether a path is absolute (begins at the root directory).\n\"\"\"\nisabspath\n\ndoc\"\"\"\n    hex2bytes(s::ASCIIString)\n\nConvert an arbitrarily long hexadecimal string to its binary representation. Returns an `Array{UInt8,1}`, i.e. an array of bytes.\n\"\"\"\nhex2bytes\n\ndoc\"\"\"\n    isdir(path) -> Bool\n\nReturns `true` if `path` is a directory, `false` otherwise.\n\"\"\"\nisdir\n\ndoc\"\"\"\n    reinterpret(type, A)\n\nChange the type-interpretation of a block of memory. For example, `reinterpret(Float32, UInt32(7))` interprets the 4 bytes corresponding to `UInt32(7)` as a `Float32`. For arrays, this constructs an array with the same binary data as the given array, but with the specified element type.\n\"\"\"\nreinterpret\n\ndoc\"\"\"\n    squeeze(A, dims)\n\nRemove the dimensions specified by `dims` from array `A`. Elements of `dims` must be unique and within the range `1:ndims(A)`.\n\"\"\"\nsqueeze\n\ndoc\"\"\"\n    ~(x)\n\nBitwise not\n\"\"\"\n~\n\ndoc\"\"\"\n    hankelh1(nu, x)\n\nBessel function of the third kind of order `nu`, $H^{(1)}_\\nu(x)$.\n\"\"\"\nhankelh1\n\ndoc\"\"\"\n```rst\n..  hessfact(A)\n\nCompute the Hessenberg decomposition of ``A`` and return a ``Hessenberg`` object. If ``F`` is the factorization object, the unitary matrix can be accessed with ``F[:Q]`` and the Hessenberg matrix with ``F[:H]``. When ``Q`` is extracted, the resulting type is the ``HessenbergQ`` object, and may be converted to a regular matrix with :func:`full`.\n```\n\"\"\"\nhessfact\n\ndoc\"\"\"\n```rst\n..  gcdx(x,y)\n\nComputes the greatest common (positive) divisor of ``x`` and ``y`` and their B\u00e9zout coefficients, i.e. the integer coefficients ``u`` and ``v`` that satisfy :math:`ux+vy = d = gcd(x,y)`.\n\n.. doctest::\n\n   julia> gcdx(12, 42)\n   (6,-3,1)\n\n.. doctest::\n\n   julia> gcdx(240, 46)\n   (2,-9,47)\n\n.. note::\n\n   B\u00e9zout coefficients are *not* uniquely defined. ``gcdx`` returns the minimal B\u00e9zout coefficients that are computed by the extended Euclid algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) These coefficients ``u`` and ``v`` are minimal in the sense that :math:`|u| < |\\frac y d` and :math:`|v| < |\\frac x d`. Furthermore, the signs of ``u`` and ``v`` are chosen so that ``d`` is positive.\n```\n\"\"\"\ngcdx\n\ndoc\"\"\"\n    rem(x, y)\n    %(x, y)\n\nRemainder from Euclidean division, returning a value of the same sign as `x`, and smaller in magnitude than `y`. This value is always exact.\n\"\"\"\nrem\n\ndoc\"\"\"\n    rotl90(A)\n\nRotate matrix `A` left 90 degrees.\n\"\"\"\nrotl90(A)\n\ndoc\"\"\"\n    rotl90(A, k)\n\nRotate matrix `A` left 90 degrees an integer `k` number of times. If `k` is zero or a multiple of four, this is equivalent to a `copy`.\n\"\"\"\nrotl90(A, k)\n\ndoc\"\"\"\n    info(msg)\n\nDisplay an informational message.\nArgument `msg` is a string describing the information to be displayed.\n\"\"\"\ninfo\n\ndoc\"\"\"\n    eigmin(A)\n\nReturns the smallest eigenvalue of `A`.\n\"\"\"\neigmin\n\ndoc\"\"\"\n    acscd(x)\n\nCompute the inverse cosecant of `x`, where the output is in degrees\n\"\"\"\nacscd\n\ndoc\"\"\"\n    ltoh(x)\n\nConverts the endianness of a value from Little-endian to that used by the Host.\n\"\"\"\nltoh\n\ndoc\"\"\"\n    evalfile(path::AbstractString)\n\nLoad the file using `include`, evaluate all expressions, and return the value of the last one.\n\"\"\"\nevalfile\n\ndoc\"\"\"\n    success(command)\n\nRun a command object, constructed with backticks, and tell whether it was successful (exited with a code of 0). An exception is raised if the process cannot be started.\n\"\"\"\nsuccess\n\ndoc\"\"\"\n```rst\n..  sortperm!(ix, v, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false,] [initialized=false])\n\nLike ``sortperm``, but accepts a preallocated index vector ``ix``.  If ``initialized`` is ``false``\n(the default), ix is initialized to contain the values ``1:length(v)``.\n\nSee also :func:`sortperm`\n```\n\"\"\"\nsortperm!\n\ndoc\"\"\"\n    isodd(x::Integer) -> Bool\n\nReturns `true` if `x` is odd (that is, not divisible by 2), and `false` otherwise.\n\n```jldoctest\njulia> isodd(9)\ntrue\n\njulia> isodd(10)\nfalse\n```\n\"\"\"\nisodd\n\ndoc\"\"\"\n    normalize_string(s, normalform::Symbol)\n\nNormalize the string `s` according to one of the four \"normal\nforms\" of the Unicode standard: `normalform` can be `:NFC`,\n`:NFD`, `:NFKC`, or `:NFKD`.  Normal forms C (canonical\ncomposition) and D (canonical decomposition) convert different\nvisually identical representations of the same abstract string into\na single canonical form, with form C being more compact.  Normal\nforms KC and KD additionally canonicalize \"compatibility\nequivalents\": they convert characters that are abstractly similar\nbut visually distinct into a single canonical choice (e.g. they expand\nligatures into the individual characters), with form KC being more compact.\n\nAlternatively, finer control and additional transformations may be\nbe obtained by calling `normalize_string(s; keywords...)`, where\nany number of the following boolean keywords options (which all default\nto `false` except for `compose`) are specified:\n\n* `compose=false`: do not perform canonical composition\n* `decompose=true`: do canonical decomposition instead of canonical composition (`compose=true` is ignored if present)\n* `compat=true`: compatibility equivalents are canonicalized\n* `casefold=true`: perform Unicode case folding, e.g. for case-insensitive string comparison\n* `newline2lf=true`, `newline2ls=true`, or `newline2ps=true`: convert various newline sequences (LF, CRLF, CR, NEL) into a linefeed (LF), line-separation (LS), or paragraph-separation (PS) character, respectively\n* `stripmark=true`: strip diacritical marks (e.g. accents)\n* `stripignore=true`: strip Unicode's \"default ignorable\" characters (e.g. the soft hyphen or the left-to-right marker)\n* `stripcc=true`: strip control characters; horizontal tabs and form feeds are converted to spaces; newlines are also converted to spaces unless a newline-conversion flag was specified\n* `rejectna=true`: throw an error if unassigned code points are found\n* `stable=true`: enforce Unicode Versioning Stability\n\nFor example, NFKC corresponds to the options `compose=true, compat=true, stable=true`.\n\"\"\"\nnormalize_string\n\ndoc\"\"\"\n    cd([dir::AbstractString=homedir()])\n\nSet the current working directory.\n\"\"\"\ncd(dir::AbstractString)\n\ndoc\"\"\"\n    cd(f, [dir=homedir()])\n\nTemporarily changes the current working directory and applies function `f` before returning.\n\"\"\"\ncd(f, dir=?)\n\ndoc\"\"\"\n    hton(x)\n\nConverts the endianness of a value from that used by the Host to Network byte order (big-endian).\n\"\"\"\nhton\n\ndoc\"\"\"\n    is(x, y) -> Bool\n    ===(x,y) -> Bool\n    \u2261(x,y) -> Bool\n\nDetermine whether `x` and `y` are identical, in the sense that no program could distinguish them. Compares mutable objects by address in memory, and compares immutable objects (such as numbers) by contents at the bit level. This function is sometimes called `egal`.\n\"\"\"\nis(x,y)\n\ndoc\"\"\"\n```rst\n..  mark(s)\n\nAdd a mark at the current position of stream ``s``.  Returns the marked position.\n\nSee also :func:`unmark`, :func:`reset`, :func:`ismarked`\n```\n\"\"\"\nmark\n\ndoc\"\"\"\n    cp(src::AbstractString, dst::AbstractString; remove_destination::Bool=false, follow_symlinks::Bool=false)\n\nCopy the file, link, or directory from *src* to *dest*. `remove_destination=true` will first remove an existing `dst`.\n\nIf `follow_symlinks=false`, and `src` is a symbolic link, `dst` will be created as a symbolic link. If `follow_symlinks=true` and `src` is a symbolic link, `dst` will be a copy of the file or directory `src` refers to.\n\"\"\"\ncp\n\ndoc\"\"\"\n    bswap(n)\n\nByte-swap an integer\n\"\"\"\nbswap\n\ndoc\"\"\"\n```rst\n.. manage(manager::FooManager, pid::Int, config::WorkerConfig. op::Symbol)\n\nImplemented by cluster managers. It is called on the master process, during a worker's lifetime,\nwith appropriate ``op`` values:\n\n- with ``:register``/``:deregister`` when a worker is added / removed\n  from the Julia worker pool.\n- with ``:interrupt`` when ``interrupt(workers)`` is called. The\n  :class:`ClusterManager` should signal the appropriate worker with an\n  interrupt signal.\n- with ``:finalize`` for cleanup purposes.\n```\n\"\"\"\nmanage\n\ndoc\"\"\"\n    resize!(collection, n) -> collection\n\nResize `collection` to contain `n` elements.\nIf `n` is smaller than the current collection length, the first `n`\nelements will be retained. If `n` is larger, the new elements are not\nguaranteed to be initialized.\n\n```jldoctest\njulia> resize!([6, 5, 4, 3, 2, 1], 3)\n3-element Array{Int64,1}:\n 6\n 5\n 4\n```\n\n```jl\njulia> resize!([6, 5, 4, 3, 2, 1], 8)\n8-element Array{Int64,1}:\n 6\n 5\n 4\n 3\n 2\n 1\n 0\n 0\n```\n\"\"\"\nresize!\n\ndoc\"\"\"\n    sumabs2!(r, A)\n\nSum squared absolute values of elements of `A` over the singleton dimensions of `r`, and write results to `r`.\n\"\"\"\nsumabs2!\n\ndoc\"\"\"\n    IPv4(host::Integer) -> IPv4\n\nReturns IPv4 object from ip address formatted as Integer\n\"\"\"\nIPv4\n\ndoc\"\"\"\n    trailing_zeros(x::Integer) -> Integer\n\nNumber of zeros trailing the binary representation of `x`.\n\n```jldoctest\njulia> trailing_zeros(2)\n1\n```\n\"\"\"\ntrailing_zeros\n\ndoc\"\"\"\n    isalnum(c::Union{Char,AbstractString}) -> Bool\n\nTests whether a character is alphanumeric, or whether this is true for all elements of a string. A character is classified as alphabetic if it belongs to the Unicode general category Letter or Number, i.e. a character whose category code begins with 'L' or 'N'.\n\"\"\"\nisalnum\n\ndoc\"\"\"\n    @sprintf(\"%Fmt\", args...)\n\nReturn `@printf` formatted output as string.\n\n    julia> s = @sprintf \"this is a %s %15.1f\" \"test\" 34.567;\n\n    julia> println(s)\n    this is a test            34.6\n\"\"\"\n:@sprintf\n\ndoc\"\"\"\n    tanh(x)\n\nCompute hyperbolic tangent of `x`\n\"\"\"\ntanh\n\ndoc\"\"\"\n    repr(x)\n\nCreate a string from any value using the `showall` function.\n\"\"\"\nrepr\n\ndoc\"\"\"\n    maxintfloat(T)\n\nThe largest integer losslessly representable by the given floating-point DataType `T`.\n\"\"\"\nmaxintfloat\n\ndoc\"\"\"\n    promote_shape(s1, s2)\n\nCheck two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.\n\"\"\"\npromote_shape\n\ndoc\"\"\"\n    methodswith(typ[, module or function][, showparents])\n\nReturn an array of methods with an argument of type `typ`. If optional `showparents` is `true`, also return arguments with a parent type of `typ`, excluding type `Any`.\n\nThe optional second argument restricts the search to a particular module or function.\n\"\"\"\nmethodswith\n\ndoc\"\"\"\n```rst\n..  foldr(op, v0, itr)\n\nLike :func:`reduce`, but with guaranteed right associativity. ``v0``\nwill be used exactly once.\n```\n\"\"\"\nfoldr(op, v0, itr)\n\ndoc\"\"\"\n```rst\n..  foldr(op, itr)\n\nLike ``foldr(op, v0, itr)``, but using the last element of ``itr``\nas ``v0``. In general, this cannot be used with empty collections\n(see ``reduce(op, itr)``).\n```\n\"\"\"\nfoldr(op, itr)\n\ndoc\"\"\"\n    chol(A, [LU]) -> F\n\nCompute the Cholesky factorization of a symmetric positive definite matrix `A` and return the matrix `F`. If `LU` is `Val{:U}` (Upper), `F` is of type `UpperTriangular` and `A = F'*F`. If `LU` is `Val{:L}` (Lower), `F` is of type `LowerTriangular` and `A = F*F'`. `LU` defaults to `Val{:U}`.\n\"\"\"\nchol\n\ndoc\"\"\"\n    ParseError(msg)\n\nThe expression passed to the `parse` function could not be interpreted as a valid Julia expression.\n\"\"\"\nParseError\n\ndoc\"\"\"\n    delete!(collection, key)\n\nDelete the mapping for the given key in a collection, and return the collection.\n\"\"\"\ndelete!\n\ndoc\"\"\"\n    interrupt([pids...])\n\nInterrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.\n\"\"\"\ninterrupt\n\ndoc\"\"\"\n    std(v[, region])\n\nCompute the sample standard deviation of a vector or array `v`, optionally along dimensions in `region`. The algorithm returns an estimator of the generative distribution's standard deviation under the assumption that each entry of `v` is an IID drawn from that generative distribution. This computation is equivalent to calculating `sqrt(sum((v - mean(v)).^2) / (length(v) - 1))`. Note: Julia does not ignore `NaN` values in the computation. For applications requiring the handling of missing data, the `DataArray` package is recommended.\n\"\"\"\nstd\n\ndoc\"\"\"\n    chr2ind(string, i)\n\nConvert a character index to a byte index.\n\"\"\"\nchr2ind\n\ndoc\"\"\"\n    fullname(m::Module)\n\nGet the fully-qualified name of a module as a tuple of symbols. For example, `fullname(Base.Pkg)` gives `(:Base,:Pkg)`, and `fullname(Main)` gives `()`.\n\"\"\"\nfullname\n\ndoc\"\"\"\n    isreadable(path) -> Bool\n\nReturns `true` if the current user has permission to read `path`, `false` otherwise.\n\"\"\"\nisreadable\n\ndoc\"\"\"\n    eps(T)\n\nThe distance between 1.0 and the next larger representable floating-point value of `DataType` `T`. Only floating-point types are sensible arguments.\n\"\"\"\neps(::Union{Type{BigFloat},Type{Float64},Type{Float32},Type{Float16}})\n\ndoc\"\"\"\n    eps()\n\nThe distance between 1.0 and the next larger representable floating-point value of `Float64`.\n\"\"\"\neps()\n\ndoc\"\"\"\n    eps(x)\n\nThe distance between `x` and the next larger representable floating-point value of the same `DataType` as `x`.\n\"\"\"\neps(::AbstractFloat)\n\ndoc\"\"\"\n    rem1(x,m)\n\nRemainder after division, returning in the range (0,m\\]\n\"\"\"\nrem1\n\ndoc\"\"\"\n    isalpha(c::Union{Char,AbstractString}) -> Bool\n\nTests whether a character is alphabetic, or whether this is true for all elements of a string. A character is classified as alphabetic if it belongs to the Unicode general category Letter, i.e. a character whose category code begins with 'L'.\n\"\"\"\nisalpha\n\ndoc\"\"\"\n    lock(l::ReentrantLock)\n\nAssociates `l` with the current task. If `l` is already locked by a different task, waits for it to become available. The same task can acquire the lock multiple times. Each \"lock\" must be matched by an \"unlock\"\n\"\"\"\nlock\n\ndoc\"\"\"\n    transpose(A)\n\nThe transposition operator (`.'`).\n\"\"\"\ntranspose\n\ndoc\"\"\"\n    searchsortedfirst(a, x, [by=<transform>,] [lt=<comparison>,] [rev=false])\n\nReturns the index of the first value in `a` greater than or equal to `x`, according to the specified order. Returns `length(a)+1` if `x` is greater than all values in `a`.\n\"\"\"\nsearchsortedfirst\n\ndoc\"\"\"\n    big(x)\n\nConvert a number to a maximum precision representation (typically `BigInt` or `BigFloat`). See `BigFloat` for information about some pitfalls with floating-point numbers.\n\"\"\"\nbig\n\ndoc\"\"\"\n    names(x::Module[, all=false[, imported=false]])\n\nGet an array of the names exported by a `Module`, with optionally more `Module` globals according to the additional parameters.\n\"\"\"\nnames\n\ndoc\"\"\"\n```rst\n..  quit()\n\nQuit the program indicating that the processes completed successfully. This function calls ``exit(0)`` (see :func:`exit`).\n```\n\"\"\"\nquit\n\ndoc\"\"\"\n    init_worker(manager::FooManager)\n\nCalled by cluster managers implementing custom transports. It initializes a newly launched process as a worker. Command line argument `--worker` has the effect of initializing a process as a worker using TCP/IP sockets for transport.\n\"\"\"\ninit_worker\n\ndoc\"\"\"\n    print_escaped(io, str::AbstractString, esc::AbstractString)\n\nGeneral escaping of traditional C and Unicode escape sequences, plus any characters in esc are also escaped (with a backslash).\n\"\"\"\nprint_escaped\n\ndoc\"\"\"\n    typejoin(T, S)\n\nCompute a type that contains both `T` and `S`.\n\"\"\"\ntypejoin\n\ndoc\"\"\"\n    summary(x)\n\nReturn a string giving a brief description of a value. By default returns `string(typeof(x))`. For arrays, returns strings like \"2x2 Float64 Array\".\n\"\"\"\nsummary\n\ndoc\"\"\"\n    Base64DecodePipe(istream)\n\nReturns a new read-only I/O stream, which decodes base64-encoded data read from `istream`.\n\"\"\"\nBase64DecodePipe\n\ndoc\"\"\"\n    module_parent(m::Module) -> Module\n\nGet a module's enclosing `Module`. `Main` is its own parent, as is `LastMain` after `workspace()`.\n\"\"\"\nmodule_parent\n\ndoc\"\"\"\n    airyaiprime(x)\n\nAiry function derivative $\\operatorname{Ai}'(x)$.\n\"\"\"\nairyaiprime\n\ndoc\"\"\"\n    besselh(nu, k, x)\n\nBessel function of the third kind of order `nu` (Hankel function). `k` is either 1 or 2, selecting `hankelh1` or `hankelh2`, respectively.\n\"\"\"\nbesselh\n\ndoc\"\"\"\n    prepend!(collection, items) -> collection\n\nInsert the elements of `items` to the beginning of `collection`.\n\n```jldoctest\njulia> prepend!([3],[1,2])\n3-element Array{Int64,1}:\n 1\n 2\n 3\n```\n\"\"\"\nprepend!\n\ndoc\"\"\"\n    sum_kbn(A)\n\nReturns the sum of all array elements, using the Kahan-Babuska-Neumaier compensated summation algorithm for additional accuracy.\n\"\"\"\nsum_kbn\n\ndoc\"\"\"\n    beta(x, y)\n\nEuler integral of the first kind $\\operatorname{B}(x,y) = \\Gamma(x)\\Gamma(y)/\\Gamma(x+y)$.\n\"\"\"\nbeta\n\ndoc\"\"\"\n    eye(n)\n\n`n`-by-`n` identity matrix\n\"\"\"\neye(n::Int)\n\ndoc\"\"\"\n    eye(m, n)\n\n`m`-by-`n` identity matrix\n\"\"\"\neye(m, n)\n\ndoc\"\"\"\n    eye(A)\n\nConstructs an identity matrix of the same dimensions and type as `A`.\n\"\"\"\neye(A)\n\ndoc\"\"\"\n    diagind(M[, k])\n\nA `Range` giving the indices of the `k`th diagonal of the matrix `M`.\n\"\"\"\ndiagind\n\ndoc\"\"\"\n    include_string(code::AbstractString, [filename])\n\nLike `include`, except reads code from the given string rather than from a file. Since there is no file path involved, no path processing or fetching from node 1 is done.\n\"\"\"\ninclude_string\n\ndoc\"\"\"\n    chmod(path, mode)\n\nChange the permissions mode of `path` to `mode`. Only integer `mode`s (e.g. 0o777) are currently supported.\n\"\"\"\nchmod\n\ndoc\"\"\"\n    gamma(x)\n\nCompute the gamma function of `x`\n\"\"\"\ngamma\n\ndoc\"\"\"\n    sin(x)\n\nCompute sine of `x`, where `x` is in radians\n\"\"\"\nsin\n\ndoc\"\"\"\n```rst\n..  ordschur!(Q, T, select) -> Schur\n\nReorders the Schur factorization of a real matrix ``A=Q*T*Q'``, overwriting ``Q`` and ``T`` in the process. See :func:`ordschur`\n```\n\"\"\"\nordschur!(Q,T,select)\n\ndoc\"\"\"\n```rst\n..  ordschur!(S, select) -> Schur\n\nReorders the Schur factorization ``S`` of type ``Schur``, overwriting ``S`` in the process. See :func:`ordschur`\n```\n\"\"\"\nordschur!(S,select)\n\ndoc\"\"\"\n```rst\n..  ordschur!(S, T, Q, Z, select) -> GeneralizedSchur\n\nReorders the Generalized Schur factorization of a matrix by overwriting the matrices ``(S, T, Q, Z)`` in the process.  See :func:`ordschur`.\n```\n\"\"\"\nordschur!(S,T,Q,Z,select)\n\ndoc\"\"\"\n```rst\n..  ordschur!(GS, select) -> GeneralizedSchur\n\nReorders the Generalized Schur factorization of a Generalized Schur object by overwriting the object with the new factorization.  See :func:`ordschur`.\n```\n\"\"\"\nordschur!(::LinAlg.GeneralizedSchur,select)\n\ndoc\"\"\"\n```rst\n..  Base.compilecache(module::ByteString)\n\nCreates a precompiled cache file for module (see help for ``require``) and all of its dependencies. This can be used to reduce package load times. Cache files are stored in ``LOAD_CACHE_PATH[1]``, which defaults to ``~/.julia/lib/VERSION``. See :ref:`Module initialization and precompilation <man-modules-initialization-precompilation>` for important notes.\n```\n\"\"\"\ncompilecache\n\ndoc\"\"\"\n    clipboard() -> AbstractString\n\nReturn a string with the contents of the operating system clipboard (\"paste\").\n\"\"\"\nclipboard\n\ndoc\"\"\"\n    clipboard(x)\n\nSend a printed form of `x` to the operating system clipboard (\"copy\").\n\"\"\"\nclipboard(x)\n\ndoc\"\"\"\n    code_lowered(f, types)\n\nReturns an array of lowered ASTs for the methods matching the given generic function and type signature.\n\"\"\"\ncode_lowered\n\ndoc\"\"\"\n    nthperm(v, k)\n\nCompute the kth lexicographic permutation of a vector.\n\"\"\"\nnthperm(v,k)\n\ndoc\"\"\"\n    nthperm(p)\n\nReturn the `k` that generated permutation `p`. Note that `nthperm(nthperm([1:n], k)) == k` for `1 <= k <= factorial(n)`.\n\"\"\"\nnthperm(p)\n\ndoc\"\"\"\n    values(collection)\n\nReturn an iterator over all values in a collection. `collect(values(d))` returns an array of values.\n\"\"\"\nvalues\n\ndoc\"\"\"\n    A_mul_B!(Y, A, B) -> Y\n\nCalculates the matrix-matrix or matrix-vector product $A\u22c5B$ and stores the\nresult in `Y`, overwriting the existing value of `Y`. Note that `Y` must not\nbe aliased with either `A` or `B`.\n\n```jldoctest\njulia> A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; Y = similar(B); A_mul_B!(Y, A, B);\n\njulia> Y\n2x2 Array{Float64,2}:\n 3.0  3.0\n 7.0  7.0\n```\n\"\"\"\nA_mul_B!\n\ndoc\"\"\"\n    ntuple(f::Function, n)\n\nCreate a tuple of length `n`, computing each element as `f(i)`, where `i` is the index of the element.\n\"\"\"\nntuple\n\ndoc\"\"\"\n    Ac_rdiv_Bc(A, B)\n\nFor matrices or vectors $A$ and $B$, calculates $A\u1d34 / B\u1d34$\n\n\"\"\"\nAc_rdiv_Bc\n\ndoc\"\"\"\n    selectperm!(ix, v, k, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false,] [initialized=false])\n\nLike `selectperm`, but accepts a preallocated index vector `ix`. If `initialized` is `false` (the default), ix is initialized to contain the values `1:length(ix)`.\n\"\"\"\nselectperm!\n\ndoc\"\"\"\n    istaskdone(task) -> Bool\n\nTell whether a task has exited.\n\"\"\"\nistaskdone\n\ndoc\"\"\"\n    .>(x, y)\n\nElement-wise greater-than comparison operator.\n\"\"\"\nBase.(:(.>))\n\ndoc\"\"\"\n    search(string, chars, [start])\n\nSearch for the first occurrence of the given characters within the given string. The second argument may be a single character, a vector or a set of characters, a string, or a regular expression (though regular expressions are only allowed on contiguous strings, such as ASCII or UTF-8 strings). The third argument optionally specifies a starting index. The return value is a range of indexes where the matching sequence is found, such that `s[search(s,x)] == x`:\n\n`search(string, \"substring\")` = `start:end` such that `string[start:end] == \"substring\"`, or `0:-1` if unmatched.\n\n`search(string, 'c')` = `index` such that `string[index] == 'c'`, or `0` if unmatched.\n\"\"\"\nsearch\n\ndoc\"\"\"\n    remotecall_fetch(id, func, args...)\n\nPerform `fetch(remotecall(...))` in one message. Any remote exceptions are captured in a `RemoteException` and thrown.\n\"\"\"\nremotecall_fetch\n\ndoc\"\"\"\n    contains(haystack, needle)\n\nDetermine whether the second argument is a substring of the first.\n\"\"\"\ncontains\n\ndoc\"\"\"\n    flush(stream)\n\nCommit all currently buffered writes to the given stream.\n\"\"\"\nflush\n\ndoc\"\"\"\n    detach(command)\n\nMark a command object so that it will be run in a new process group, allowing it to outlive the julia process, and not have Ctrl-C interrupts passed to it.\n\"\"\"\ndetach\n\ndoc\"\"\"\n    precompile(f,args::Tuple{Vararg{Any}})\n\nCompile the given function `f` for the argument tuple (of types) `args`, but do not execute it.\n\"\"\"\nprecompile\n\ndoc\"\"\"\n```rst\n..  toc()\n\nPrint and return the time elapsed since the last :func:`tic`.\n```\n\"\"\"\ntoc\n\ndoc\"\"\"\n    asinh(x)\n\nCompute the inverse hyperbolic sine of `x`\n\"\"\"\nasinh\n\ndoc\"\"\"\n    count(p, itr) -> Integer\n\nCount the number of elements in `itr` for which predicate `p` returns `true`.\n\"\"\"\ncount\n\ndoc\"\"\"\n    atreplinit(f)\n\nRegister a one-argument function to be called before the REPL interface is initialized in interactive sessions; this is useful to customize the interface. The argument of `f` is the REPL object. This function should be called from within the `.juliarc.jl` initialization file.\n\"\"\"\natreplinit\n\ndoc\"\"\"\n    strip(string, [chars])\n\nReturn `string` with any leading and trailing whitespace removed. If `chars` (a character, or vector or set of characters) is provided, instead remove characters contained in it.\n\"\"\"\nstrip\n\ndoc\"\"\"\n    findin(a, b)\n\nReturns the indices of elements in collection `a` that appear in collection `b`\n\"\"\"\nfindin\n\ndoc\"\"\"\n    minimum(itr)\n\nReturns the smallest element in a collection.\n\"\"\"\nminimum(itr)\n\ndoc\"\"\"\n    minimum(A, dims)\n\nCompute the minimum value of an array over the given dimensions.\n\"\"\"\nminimum(A,dims)\n\ndoc\"\"\"\n    var(v[, region])\n\nCompute the sample variance of a vector or array `v`, optionally along dimensions in `region`. The algorithm will return an estimator of the generative distribution's variance under the assumption that each entry of `v` is an IID drawn from that generative distribution. This computation is equivalent to calculating `sumabs2(v - mean(v)) / (length(v) - 1)`. Note: Julia does not ignore `NaN` values in the computation. For applications requiring the handling of missing data, the `DataArray` package is recommended.\n\"\"\"\nvar\n\ndoc\"\"\"\n    lcfirst(string)\n\nReturns `string` with the first character converted to lowercase.\n\"\"\"\nlcfirst\n\ndoc\"\"\"\n```rst\n..  @code_native\n\nEvaluates the arguments to the function call, determines their types, and calls :func:`code_native` on the resulting expression.\n```\n\"\"\"\n:@code_native\n\ndoc\"\"\"\n```rst\n..  flipbits!(B::BitArray{N}) -> BitArray{N}\n\nPerforms a bitwise not operation on ``B``. See :ref:`~ operator <~>`.\n```\n\"\"\"\nflipbits!\n\ndoc\"\"\"\n    readlink(path) -> AbstractString\n\nReturns the value of a symbolic link `path`.\n\"\"\"\nreadlink\n\ndoc\"\"\"\n```rst\n..  @code_warntype\n\nEvaluates the arguments to the function call, determines their types, and calls :func:`code_warntype` on the resulting expression.\n```\n\"\"\"\n:@code_warntype\n\ndoc\"\"\"\n    deg2rad(x)\n\nConvert `x` from degrees to radians\n\"\"\"\ndeg2rad\n\ndoc\"\"\"\n    redirect_stdin([stream])\n\nLike redirect\\_stdout, but for STDIN. Note that the order of the return tuple is still (rd,wr), i.e. data to be read from STDIN, may be written to wr.\n\"\"\"\nredirect_stdin\n\ndoc\"\"\"\n```rst\n..  minmax(x, y)\n\nReturn ``(min(x,y), max(x,y))``.\nSee also: :func:`extrema` that returns ``(minimum(x), maximum(x))``\n```\n\"\"\"\nminmax\n\ndoc\"\"\"\n    mktemp([parent=tempdir()])\n\nReturns `(path, io)`, where `path` is the path of a new temporary file in `parent` and `io` is an open file object for this path.\n\"\"\"\nmktemp(?)\n\ndoc\"\"\"\n    mktemp(f::Function, [parent=tempdir()])\n\nApply the function `f` to the result of `mktemp(parent)` and remove the temporary file upon completion.\n\"\"\"\nmktemp(::Function, ?)\n\ndoc\"\"\"\n    isreadonly(stream) -> Bool\n\nDetermine whether a stream is read-only.\n\"\"\"\nisreadonly\n\ndoc\"\"\"\n```rst\n..  get_rounding(T)\n\nGet the current floating point rounding mode for type ``T``, controlling\nthe rounding of basic arithmetic functions (:func:`+`, :func:`-`,\n:func:`*`, :func:`/` and :func:`sqrt`) and type conversion.\n\nValid modes are ``RoundNearest``, ``RoundToZero``, ``RoundUp``,\n``RoundDown``, and ``RoundFromZero`` (``BigFloat`` only).\n```\n\"\"\"\nget_rounding\n\ndoc\"\"\"\n```rst\n..  code_llvm(f, types)\n\nPrints the LLVM bitcodes generated for running the method matching the given generic function and type signature to :const:`STDOUT`.\n\nAll metadata and dbg.* calls are removed from the printed bitcode. Use code_llvm_raw for the full IR.\n```\n\"\"\"\ncode_llvm\n\ndoc\"\"\"\n```rst\n..  Bidiagonal(dv, ev, isupper)\n\nConstructs an upper (``isupper=true``) or lower (``isupper=false``) bidiagonal matrix\nusing the given diagonal (``dv``) and off-diagonal (``ev``) vectors.  The result is of type ``Bidiagonal`` and provides efficient specialized linear solvers, but may be converted into a regular matrix with :func:`full`.\n```\n\"\"\"\nBidiagonal\n\ndoc\"\"\"\n    notify(condition, val=nothing; all=true, error=false)\n\nWake up tasks waiting for a condition, passing them `val`. If `all` is `true` (the default), all waiting tasks are woken, otherwise only one is. If `error` is `true`, the passed value is raised as an exception in the woken tasks.\n\"\"\"\nnotify\n\ndoc\"\"\"\n```rst\n..  sub(A, inds...)\n\nLike :func:`getindex`, but returns a view into the parent array ``A`` with the given indices instead of making a copy.  Calling :func:`getindex` or :func:`setindex!` on the returned :obj:`SubArray` computes the indices to the parent array on the fly without checking bounds.\n```\n\"\"\"\nsub\n\ndoc\"\"\"\n```rst\n..  cholfact!(A [,LU=:U [,pivot=Val{false}]][;tol=-1.0]) -> Cholesky\n\n``cholfact!`` is the same as :func:`cholfact`, but saves space by overwriting the input ``A``, instead of creating a copy. ``cholfact!`` can also reuse the symbolic factorization from a different matrix ``F`` with the same structure when used as: ``cholfact!(F::CholmodFactor, A)``.\n```\n\"\"\"\ncholfact!\n\ndoc\"\"\"\n    expanduser(path::AbstractString) -> AbstractString\n\nOn Unix systems, replace a tilde character at the start of a path with the current user's home directory.\n\"\"\"\nexpanduser\n\ndoc\"\"\"\n    haskey(collection, key) -> Bool\n\nDetermine whether a collection has a mapping for a given key.\n\"\"\"\nhaskey\n\ndoc\"\"\"\n    cot(x)\n\nCompute the cotangent of `x`, where `x` is in radians\n\"\"\"\ncot\n\ndoc\"\"\"\n```rst\n..  get(x)\n\nAttempt to access the value of the ``Nullable`` object, ``x``. Returns the\nvalue if it is present; otherwise, throws a ``NullException``.\n```\n\"\"\"\nget(x)\n\ndoc\"\"\"\n```rst\n..  get(x, y)\n\nAttempt to access the value of the ``Nullable{T}`` object, ``x``. Returns\nthe value if it is present; otherwise, returns ``convert(T, y)``.\n```\n\"\"\"\nget(x,y)\n\ndoc\"\"\"\n```rst\n..  get(collection, key, default)\n\nReturn the value stored for the given key, or the given default value if no mapping for the key is present.\n```\n\"\"\"\nget(collection,key,default)\n\ndoc\"\"\"\n```rst\n..  get(f::Function, collection, key)\n\nReturn the value stored for the given key, or if no mapping for the key is present, return ``f()``.  Use :func:`get!` to also store the default value in the dictionary.\n\nThis is intended to be called using ``do`` block syntax::\n\n  get(dict, key) do\n      # default value calculated here\n      time()\n  end\n```\n\"\"\"\nget\n\ndoc\"\"\"\n    .!=(x, y)\n    .\u2260(x,y)\n\nElement-wise not-equals comparison operator.\n\"\"\"\nBase.(:(.!=))\n\ndoc\"\"\"\n```rst\n..  lufact!(A) -> LU\n\n``lufact!`` is the same as :func:`lufact`, but saves space by overwriting the input ``A``, instead of creating a copy.  For sparse ``A`` the ``nzval`` field is not overwritten but the index fields, ``colptr`` and ``rowval`` are decremented in place, converting from 1-based indices to 0-based indices.\n```\n\"\"\"\nlufact!\n\ndoc\"\"\"\n    IOBuffer() -> IOBuffer\n\nCreate an in-memory I/O stream.\n\"\"\"\nIOBuffer()\n\ndoc\"\"\"\n    IOBuffer(size::Int)\n\nCreate a fixed size IOBuffer. The buffer will not grow dynamically.\n\"\"\"\nIOBuffer(size::Int)\n\ndoc\"\"\"\n    IOBuffer(string)\n\nCreate a read-only IOBuffer on the data underlying the given string\n\"\"\"\nIOBuffer(::AbstractString)\n\ndoc\"\"\"\n    IOBuffer([data,],[readable,writable,[maxsize]])\n\nCreate an IOBuffer, which may optionally operate on a pre-existing array. If the readable/writable arguments are given, they restrict whether or not the buffer may be read from or written to respectively. By default the buffer is readable but not writable. The last argument optionally specifies a size beyond which the buffer may not be grown.\n\"\"\"\nIOBuffer(data=?)\n\ndoc\"\"\"\n    findmax(itr) -> (x, index)\n\nReturns the maximum element and its index.\n\"\"\"\nfindmax(itr)\n\ndoc\"\"\"\n    findmax(A, dims) -> (maxval, index)\n\nFor an array input, returns the value and index of the maximum over the given dimensions.\n\"\"\"\nfindmax(A,dims)\n\ndoc\"\"\"\n    tempname()\n\nGenerate a unique temporary file path.\n\"\"\"\ntempname\n\ndoc\"\"\"\n    poll_fd(fd, timeout_s::Real; readable=false, writable=false)\n\nMonitor a file descriptor `fd` for changes in the read or write availability, and with a timeout given by `timeout_s` seconds.\n\nThe keyword arguments determine which of read and/or write status should be monitored; at least one of them must be set to `true`.\n\nThe returned value is an object with boolean fields `readable`, `writable`, and `timedout`, giving the result of the polling.\n\"\"\"\npoll_fd\n\ndoc\"\"\"\n    prevpow2(n)\n\nThe largest power of two not greater than `n`. Returns 0 for `n==0`, and returns `-prevpow2(-n)` for negative arguments.\n\"\"\"\nprevpow2\n\ndoc\"\"\"\n```rst\n..  code_warntype(f, types)\n\nDisplays lowered and type-inferred ASTs for the methods matching the given generic function and type signature. The ASTs are annotated in such a way as to cause \"non-leaf\" types to be emphasized (if color is available, displayed in red). This serves as a warning of potential type instability. Not all non-leaf types are particularly problematic for performance, so the results need to be used judiciously. See :ref:`man-code-warntype` for more information.\n```\n\"\"\"\ncode_warntype\n\ndoc\"\"\"\n    broadcast!_function(f)\n\nLike `broadcast_function`, but for `broadcast!`.\n\"\"\"\nbroadcast!_function\n\ndoc\"\"\"\n    with_rounding(f::Function, T, mode)\n\nChange the rounding mode of floating point type `T` for the duration of `f`. It is logically equivalent to:\n\n    old = get_rounding(T)\n    set_rounding(T, mode)\n    f()\n    set_rounding(T, old)\n\nSee `get_rounding` for available rounding modes.\n\"\"\"\nwith_rounding\n\ndoc\"\"\"\n    sleep(seconds)\n\nBlock the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of `0.001`.\n\"\"\"\nsleep\n\ndoc\"\"\"\n    Mmap.sync!(array)\n\nForces synchronization between the in-memory version of a memory-mapped `Array` or `BitArray` and the on-disk version.\n\"\"\"\nMmap.sync!\n\ndoc\"\"\"\n    csc(x)\n\nCompute the cosecant of `x`, where `x` is in radians\n\"\"\"\ncsc\n\ndoc\"\"\"\n    hash(x[, h::UInt])\n\nCompute an integer hash code such that `isequal(x,y)` implies `hash(x)==hash(y)`. The optional second argument `h` is a hash code to be mixed with the result.\n\nNew types should implement the 2-argument form, typically by calling the 2-argument `hash` method recursively in order to mix hashes of the contents with each other (and with `h`). Typically, any type that implements `hash` should also implement its own `==` (hence `isequal`) to guarantee the property mentioned above.\n\"\"\"\nhash\n\ndoc\"\"\"\n    atan2(y, x)\n\nCompute the inverse tangent of `y/x`, using the signs of both `x` and `y` to determine the quadrant of the return value.\n\"\"\"\natan2\n\ndoc\"\"\"\n    send(socket::UDPSocket, host::IPv4, port::Integer, msg)\n\nSend `msg` over `socket` to `host:port`.\n\"\"\"\nsend\n\ndoc\"\"\"\n    atanh(x)\n\nCompute the inverse hyperbolic tangent of `x`\n\"\"\"\natanh\n\ndoc\"\"\"\n    deleteat!(collection, index)\n\nRemove the item at the given `index` and return the modified `collection`.\nSubsequent items are shifted to fill the resulting gap.\n\n```jldoctest\njulia> deleteat!([6, 5, 4, 3, 2, 1], 2)\n5-element Array{Int64,1}:\n 6\n 4\n 3\n 2\n 1\n```\n\"\"\"\ndeleteat!(collection, index::Integer)\n\ndoc\"\"\"\n    deleteat!(collection, itr)\n\nRemove the items at the indices given by `itr`, and return the modified `collection`.\nSubsequent items are shifted to fill the resulting gap. `itr` must be sorted and unique.\n\n```jldoctest\njulia> deleteat!([6, 5, 4, 3, 2, 1], 1:2:5)\n3-element Array{Int64,1}:\n 5\n 3\n 1\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], (2, 2))\nERROR: ArgumentError: indices must be unique and sorted\n in deleteat! at array.jl:546\n```\n\"\"\"\ndeleteat!(collection, itr)\n\ndoc\"\"\"\n```rst\n..  schurfact!(A)\n\nComputes the Schur factorization of ``A``, overwriting ``A`` in the process. See :func:`schurfact`\n```\n\"\"\"\nschurfact!\n\ndoc\"\"\"\n    read(stream, type)\n\nRead a value of the given type from a stream, in canonical binary representation.\n\"\"\"\nread(stream, t)\n\ndoc\"\"\"\n    read(stream, type, dims)\n\nRead a series of values of the given type from a stream, in canonical binary representation. `dims` is either a tuple or a series of integer arguments specifying the size of `Array` to return.\n\"\"\"\nread(stream, t, dims)\n\ndoc\"\"\"\n    @timev\n\nThis is a verbose version of the `@time` macro. It first prints the same information as `@time`, then any non-zero memory allocation counters, and then returns the value of the expression.\n\"\"\"\n:@timev\n\ndoc\"\"\"\n    isopen(object) -> Bool\n\nDetermine whether an object - such as a stream, timer, or mmap -- is not yet closed. Once an object is closed, it will never produce a new event. However, a closed stream may still have data to read in its buffer, use `eof` to check for the ability to read data. Use `poll_fd` to be notified when a stream might be writable or readable.\n\"\"\"\nisopen\n\ndoc\"\"\"\n    shift!(collection) -> item\n\nRemove the first `item` from `collection`.\n\n```jldoctest\njulia> A = [1, 2, 3, 4, 5, 6]\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia> shift!(A)\n1\n\njulia> A\n5-element Array{Int64,1}:\n 2\n 3\n 4\n 5\n 6\n```\n\"\"\"\nshift!\n\ndoc\"\"\"\n    @fetch\n\nEquivalent to `fetch(@spawn expr)`.\n\"\"\"\n:@fetch\n\ndoc\"\"\"\n    spawn(command)\n\nRun a command object asynchronously, returning the resulting `Process` object.\n\"\"\"\nspawn\n\ndoc\"\"\"\n    isposdef(A) -> Bool\n\nTest whether a matrix is positive definite.\n\"\"\"\nisposdef\n\ndoc\"\"\"\n    nextind(str, i)\n\nGet the next valid string index after `i`. Returns a value greater than `endof(str)` at or after the end of the string.\n\"\"\"\nnextind\n\ndoc\"\"\"\n    >>>(x, n)\n\nUnsigned right bit shift operator.\n\"\"\"\nBase.(:(>>>))\n\ndoc\"\"\"\n    @timed\n\nA macro to execute an expression, and return the value of the expression, elapsed time, total bytes allocated, garbage collection time, and an object with various memory allocation counters.\n\"\"\"\n:@timed\n\ndoc\"\"\"\n    code_native(f, types)\n\nPrints the native assembly instructions generated for running the method matching the given generic function and type signature to `STDOUT`.\n\"\"\"\ncode_native\n\ndoc\"\"\"\n    isgeneric(f::Function) -> Bool\n\nDetermine whether a `Function` is generic.\n\"\"\"\nisgeneric\n\ndoc\"\"\"\n    symdiff(s1,s2...)\n\nConstruct the symmetric difference of elements in the passed in sets or arrays. Maintains order with arrays.\n\"\"\"\nsymdiff\n\ndoc\"\"\"\n    histrange(v, n)\n\nCompute *nice* bin ranges for the edges of a histogram of `v`, using approximately `n` bins. The resulting step sizes will be 1, 2 or 5 multiplied by a power of 10. Note: Julia does not ignore `NaN` values in the computation.\n\"\"\"\nhistrange\n\ndoc\"\"\"\n    eta(x)\n\nDirichlet eta function $\\eta(s) = \\sum^\\infty_{n=1}(-)^{n-1}/n^{s}$.\n\"\"\"\neta\n\ndoc\"\"\"\n    isdefined([object,] index | symbol)\n\nTests whether an assignable location is defined. The arguments can be an array and index, a composite object and field name (as a symbol), or a module and a symbol. With a single symbol argument, tests whether a global variable with that name is defined in `current_module()`.\n\"\"\"\nisdefined\n\ndoc\"\"\"\n    cotd(x)\n\nCompute the cotangent of `x`, where `x` is in degrees\n\"\"\"\ncotd\n\ndoc\"\"\"\n    dec(n, [pad])\n\nConvert an integer to a decimal string, optionally specifying a number of digits to pad to.\n\"\"\"\ndec\n\ndoc\"\"\"\n    wait([x])\n\nBlock the current task until some event occurs, depending on the type\nof the argument:\n\n* `RemoteRef`: Wait for a value to become available for the specified remote reference.\n* `Channel`: Wait for a value to be appended to the channel.\n* `Condition`: Wait for `notify` on a condition.\n* `Process`: Wait for a process or process chain to exit. The `exitcode` field of a process can be used to determine success or failure.\n* `Task`: Wait for a `Task` to finish, returning its result value. If the task fails with an exception, the exception is propagated (re-thrown in the task that called `wait`).\n* `RawFD`: Wait for changes on a file descriptor (see `poll_fd` for keyword arguments and return code)\n\nIf no argument is passed, the task blocks for an undefined period. If the task's\nstate is set to `:waiting`, it can only be restarted by an explicit call to\n`schedule` or `yieldto`. If the task's state is `:runnable`, it might be\nrestarted unpredictably.\n\nOften `wait` is called within a `while` loop to ensure a waited-for condition\nis met before proceeding.\n\"\"\"\nwait\n\ndoc\"\"\"\n```rst\n..  shuffle([rng,] v)\n\nReturn a randomly permuted copy of ``v``. The optional ``rng`` argument\nspecifies a random number generator, see :ref:`Random Numbers\n<random-numbers>`.\n```\n\"\"\"\nshuffle\n\ndoc\"\"\"\n```rst\n..  Dict([itr])\n\n``Dict{K,V}()`` constructs a hash table with keys of type ``K`` and values of type ``V``.\n\nGiven a single iterable argument, constructs a :obj:`Dict` whose key-value pairs\nare taken from 2-tuples ``(key,value)`` generated by the argument.\n\n.. doctest::\n\n  julia> Dict([(\"A\", 1), (\"B\", 2)])\n  Dict{ASCIIString,Int64} with 2 entries:\n    \"B\" => 2\n    \"A\" => 1\n\nAlternatively, a sequence of pair arguments may be passed.\n\n.. doctest::\n\n  julia> Dict(\"A\"=>1, \"B\"=>2)\n  Dict{ASCIIString,Int64} with 2 entries:\n    \"B\" => 2\n    \"A\" => 1\n```\n\"\"\"\nDict\n\ndoc\"\"\"\n    sqrt(x)\n\nReturn $\\sqrt{x}$. Throws `DomainError` for negative `Real` arguments. Use complex negative arguments instead.  The prefix operator `\u221a` is equivalent to `sqrt`.\n\"\"\"\nsqrt\n\ndoc\"\"\"\n    atexit(f)\n\nRegister a zero-argument function `f()` to be called at process exit.\n`atexit()` hooks are called in last in first out (LIFO) order and run before object finalizers.\n\"\"\"\natexit\n\ndoc\"\"\"\n    besselk(nu, x)\n\nModified Bessel function of the second kind of order `nu`, $K_\\nu(x)$.\n\"\"\"\nbesselk\n\ndoc\"\"\"\n    readchomp(x)\n\nRead the entirety of `x` as a string but remove trailing newlines. Equivalent to `chomp(readall(x))`.\n\"\"\"\nreadchomp\n\ndoc\"\"\"\n```rst\n..  pinv(M[, tol])\n\nComputes the Moore-Penrose pseudoinverse.\n\nFor matrices ``M`` with floating point elements, it is convenient to compute\nthe pseudoinverse by inverting only singular values above a given threshold,\n``tol``.\n\nThe optimal choice of ``tol`` varies both with the value of ``M``\nand the intended application of the pseudoinverse. The default value of\n``tol`` is ``eps(real(float(one(eltype(M)))))*maximum(size(A))``,\nwhich is essentially machine epsilon for the real part of a matrix element\nmultiplied by the larger matrix dimension.\nFor inverting dense ill-conditioned matrices in a least-squares sense,\n``tol = sqrt(eps(real(float(one(eltype(M))))))`` is recommended.\n\nFor more information, see [issue8859]_, [B96]_, [S84]_, [KY88]_.\n\n.. [issue8859] Issue 8859, \"Fix least squares\", https://github.com/JuliaLang/julia/pull/8859\n.. [B96] \u00c5ke Bj\u00f6rck, \"Numerical Methods for Least Squares Problems\",\n   SIAM Press, Philadelphia, 1996, \"Other Titles in Applied Mathematics\", Vol. 51.\n   `doi:10.1137/1.9781611971484 <http://epubs.siam.org/doi/book/10.1137/1.9781611971484>`_\n.. [S84] G. W. Stewart, \"Rank Degeneracy\", SIAM Journal on\n   Scientific and Statistical Computing, 5(2), 1984, 403-413.\n   `doi:10.1137/0905030 <http://epubs.siam.org/doi/abs/10.1137/0905030>`_\n.. [KY88] Konstantinos Konstantinides and Kung Yao, \"Statistical analysis\n   of effective singular values in matrix rank determination\", IEEE\n   Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988,\n   757-763.\n   `doi:10.1109/29.1585 <http://dx.doi.org/10.1109/29.1585>`_\n```\n\"\"\"\npinv\n\ndoc\"\"\"\n    asecd(x)\n\nCompute the inverse secant of `x`, where the output is in degrees\n\"\"\"\nasecd\n\ndoc\"\"\"\n    readbytes!(stream, b::Vector{UInt8}, nb=length(b); all=true)\n\nRead at most `nb` bytes from the stream into `b`, returning the number of bytes read (increasing the size of `b` as needed).\n\nSee `readbytes` for a description of the `all` option.\n\"\"\"\nreadbytes!\n\ndoc\"\"\"\n    basename(path::AbstractString) -> AbstractString\n\nGet the file name part of a path.\n\"\"\"\nbasename\n\ndoc\"\"\"\n    ArgumentError(msg)\n\nThe parameters to a function call do not match a valid signature.\nArgument `msg` is a descriptive error string.\n\"\"\"\nArgumentError\n\ndoc\"\"\"\n    atand(x)\n\nCompute the inverse tangent of `x`, where the output is in degrees\n\"\"\"\natand\n\ndoc\"\"\"\n    KeyError(key)\n\nAn indexing operation into an `Associative` (`Dict`) or `Set` like object tried to access or delete a non-existent element.\n\"\"\"\nKeyError\n\ndoc\"\"\"\n    isdiag(A) -> Bool\n\nTest whether a matrix is diagonal.\n\"\"\"\nisdiag\n\ndoc\"\"\"\n    !==(x, y)\n    \u2262(x,y)\n\nEquivalent to `!is(x, y)`\n\"\"\"\nBase.(:(!==))\n\ndoc\"\"\"\n    trailing_ones(x::Integer) -> Integer\n\nNumber of ones trailing the binary representation of `x`.\n\n```jldoctest\njulia> trailing_ones(3)\n2\n```\n\"\"\"\ntrailing_ones\n\ndoc\"\"\"\n    repeated(x[, n::Int])\n\nAn iterator that generates the value `x` forever. If `n` is specified, generates `x` that many times (equivalent to `take(repeated(x), n)`).\n\"\"\"\nrepeated\n\ndoc\"\"\"\n    isnumber(c::Union{Char,AbstractString}) -> Bool\n\nTests whether a character is numeric, or whether this is true for all elements of a string. A character is classified as numeric if it belongs to the Unicode general category Number, i.e. a character whose category code begins with 'N'.\n\"\"\"\nisnumber\n\ndoc\"\"\"\n    similar(array, [element_type=eltype(array)], [dims=size(array)])\n\nCreate an uninitialized mutable array with the given element type and size,\nbased upon the given source array. The second and third arguments are both\noptional, defaulting to the given array's `eltype` and `size`. The dimensions\nmay be specified either as a single tuple argument or as a series of integer\narguments.\n\nCustom AbstractArray subtypes may choose which specific array type is\nbest-suited to return for the given element type and dimensionality. If they do\nnot specialize this method, the default is an `Array(element_type, dims...)`.\n\nFor example, `similar(1:10, 1, 4)` returns an uninitialized `Array{Int,2}` since\nranges are neither mutable nor support 2 dimensions:\n\n    julia> similar(1:10, 1, 4)\n    1x4 Array{Int64,2}:\n     4419743872  4374413872  4419743888  0\n\nConversely, `similar(trues(10,10), 2)` returns an uninitialized `BitVector`\nwith two elements since `BitArray`s are both mutable and can support\n1-dimensional arrays:\n\n    julia> similar(trues(10,10), 2)\n    2-element BitArray{1}:\n     false\n     false\n\nSince `BitArray`s can only store elements of type `Bool`, however, if you\nrequest a different element type it will create a regular `Array` instead:\n\n    julia> similar(falses(10), Float64, 2, 4)\n    2x4 Array{Float64,2}:\n     2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314\n     2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314\n\"\"\"\nsimilar\n\ndoc\"\"\"\n    copy(x)\n\nCreate a shallow copy of `x`: the outer structure is copied, but not all internal values. For example, copying an array produces a new array with identically-same elements as the original.\n\"\"\"\ncopy\n\ndoc\"\"\"\n    isempty(collection) -> Bool\n\nDetermine whether a collection is empty (has no elements).\n\n```jldoctest\njulia> isempty([])\ntrue\n\njulia> isempty([1 2 3])\nfalse\n```\n\"\"\"\nisempty\n\ndoc\"\"\"\n    sumabs!(r, A)\n\nSum absolute values of elements of `A` over the singleton dimensions of `r`, and write results to `r`.\n\"\"\"\nsumabs!\n\ndoc\"\"\"\n    abs(x)\n\nAbsolute value of `x`\n\"\"\"\nabs\n\ndoc\"\"\"\n    Sys.set_process_title(title::AbstractString)\n\nSet the process title. No-op on some operating systems. (not exported)\n\"\"\"\nSys.set_process_title\n\ndoc\"\"\"\n    htol(x)\n\nConverts the endianness of a value from that used by the Host to Little-endian.\n\"\"\"\nhtol\n\ndoc\"\"\"\n    ctime(file)\n\nEquivalent to `stat(file).ctime`\n\"\"\"\nctime\n\ndoc\"\"\"\n    normpath(path::AbstractString) -> AbstractString\n\nNormalize a path, removing \".\" and \"..\" entries.\n\"\"\"\nnormpath\n\ndoc\"\"\"\n```rst\n..  unmark(s)\n\nRemove a mark from stream ``s``.\nReturns ``true`` if the stream was marked, ``false`` otherwise.\n\nSee also :func:`mark`, :func:`reset`, :func:`ismarked`\n```\n\"\"\"\nunmark\n\ndoc\"\"\"\n    module_name(m::Module) -> Symbol\n\nGet the name of a `Module` as a `Symbol`.\n\"\"\"\nmodule_name\n\ndoc\"\"\"\n```rst\n..  reset(s)\n\nReset a stream ``s`` to a previously marked position, and remove the mark.\nReturns the previously marked position.\nThrows an error if the stream is not marked.\n\nSee also :func:`mark`, :func:`unmark`, :func:`ismarked`\n```\n\"\"\"\nreset\n\ndoc\"\"\"\n    modf(x)\n\nReturn a tuple (fpart,ipart) of the fractional and integral parts of a number. Both parts have the same sign as the argument.\n\"\"\"\nmodf\n\ndoc\"\"\"\n    hex2num(str)\n\nConvert a hexadecimal string to the floating point number it represents\n\"\"\"\nhex2num\n\ndoc\"\"\"\n    ndims(A) -> Integer\n\nReturns the number of dimensions of `A`\n\"\"\"\nndims\n\ndoc\"\"\"\n    @osx\n\nGiven `@osx? a : b`, do `a` on OS X and `b` elsewhere. See documentation for Handling Platform Variations in the Calling C and Fortran Code section of the manual.\n\"\"\"\n:@osx\n\ndoc\"\"\"\n    ishermitian(A) -> Bool\n\nTest whether a matrix is Hermitian.\n\"\"\"\nishermitian\n\ndoc\"\"\"\n    sind(x)\n\nCompute sine of `x`, where `x` is in degrees.\n\"\"\"\nsind\n\ndoc\"\"\"\n    iseltype(A,T)\n\nTests whether `A` or its elements are of type `T`.\n\"\"\"\niseltype\n\ndoc\"\"\"\n    symperm(A, p)\n\nReturn the symmetric permutation of `A`, which is `A[p,p]`. `A` should be symmetric and sparse, where only the upper triangular part of the matrix is stored. This algorithm ignores the lower triangular part of the matrix. Only the upper triangular part of the result is returned as well.\n\"\"\"\nsymperm\n\ndoc\"\"\"\n    min(x, y, ...)\n\nReturn the minimum of the arguments. Operates elementwise over arrays.\n\"\"\"\nmin\n\ndoc\"\"\"\n    isready(r::RemoteRef)\n\nDetermine whether a `RemoteRef` has a value stored to it. Note that this function can cause race conditions, since by the time you receive its result it may no longer be true. It is recommended that this function only be used on a `RemoteRef` that is assigned once.\n\nIf the argument `RemoteRef` is owned by a different node, this call will block to wait for the answer. It is recommended to wait for `r` in a separate task instead, or to use a local `RemoteRef` as a proxy:\n\n    rr = RemoteRef()\n    @async put!(rr, remotecall_fetch(p, long_computation))\n    isready(rr)  # will not block\n\"\"\"\nisready\n\ndoc\"\"\"\n    InexactError()\n\nType conversion cannot be done exactly.\n\"\"\"\nInexactError\n\ndoc\"\"\"\n    @sync\n\nWait until all dynamically-enclosed uses of `@async`, `@spawn`, `@spawnat` and `@parallel` are complete. All exceptions thrown by enclosed async operations are collected and thrown as a `CompositeException`.\n\"\"\"\n:@sync\n\ndoc\"\"\"\n    typemax(T)\n\nThe highest value representable by the given (real) numeric `DataType`.\n\"\"\"\ntypemax\n\ndoc\"\"\"\n    all(itr) -> Bool\n\nTest whether all elements of a boolean collection are `true`.\n\"\"\"\nall(itr)\n\ndoc\"\"\"\n    all(A, dims)\n\nTest whether all values along the given dimensions of an array are `true`.\n\"\"\"\nall(A::AbstractArray, dims)\n\ndoc\"\"\"\n    all(p, itr) -> Bool\n\nDetermine whether predicate `p` returns `true` for all elements of `itr`.\n\n```jldoctest\njulia> all(i->(4<=i<=6), [4,5,6])\ntrue\n```\n\"\"\"\nall(p, itr)\n\ndoc\"\"\"\n    bind(socket::Union{UDPSocket, TCPSocket}, host::IPv4, port::Integer)\n\nBind `socket` to the given `host:port`. Note that `0.0.0.0` will listen on all devices.\n\"\"\"\nbind\n\ndoc\"\"\"\n    cld(x, y)\n\nSmallest integer larger than or equal to `x/y`.\n\"\"\"\ncld\n\ndoc\"\"\"\n    issetuid(path) -> Bool\n\nReturns `true` if `path` has the setuid flag set, `false` otherwise.\n\"\"\"\nissetuid\n\ndoc\"\"\"\n```rst\n..  scale!(A, b)\n           scale!(b, A)\n\nScale an array ``A`` by a scalar ``b``, similar to :func:`scale` but\noverwriting ``A`` in-place.\n\nIf ``A`` is a matrix and ``b`` is a vector, then ``scale!(A,b)``\nscales each column ``i`` of ``A`` by ``b[i]`` (similar to\n``A*diagm(b)``), while ``scale!(b,A)`` scales each row ``i`` of\n``A`` by ``b[i]`` (similar to ``diagm(b)*A``), again operating in-place\non ``A``.\n```\n\"\"\"\nscale!\n\ndoc\"\"\"\n    DomainError()\n\nThe arguments to a function or constructor are outside the valid domain.\n\"\"\"\nDomainError\n\ndoc\"\"\"\n    issym(A) -> Bool\n\nTest whether a matrix is symmetric.\n\"\"\"\nissym\n\ndoc\"\"\"\n```rst\n..  svds(A; nsv=6, ritzvec=true, tol=0.0, maxiter=1000) -> (left_sv, s, right_sv, nconv, niter, nmult, resid)\n\n``svds`` computes largest singular values ``s`` of ``A`` using Lanczos or Arnoldi iterations.\nUses :func:`eigs` underneath.\n\nInputs are:\n\n* ``A``: Linear operator. It can either subtype of ``AbstractArray`` (e.g., sparse matrix) or duck typed. For duck typing ``A`` has to support ``size(A)``, ``eltype(A)``, ``A * vector`` and ``A' * vector``.\n* ``nsv``: Number of singular values.\n* ``ritzvec``: Whether to return the left and right singular vectors ``left_sv`` and ``right_sv``, default is ``true``. If ``false`` the singular vectors are omitted from the output.\n* ``tol``: tolerance, see :func:`eigs`.\n* ``maxiter``: Maximum number of iterations, see :func:`eigs`.\n\n**Example**::\n\n   X = sprand(10, 5, 0.2)\n   svds(X, nsv = 2)\n```\n\"\"\"\nsvds\n\ndoc\"\"\"\n    acosh(x)\n\nCompute the inverse hyperbolic cosine of `x`\n\"\"\"\nacosh\n\ndoc\"\"\"\n```rst\n..  IntSet([itr])\n\nConstruct a sorted set of positive ``Int``\\ s generated by the given iterable\nobject, or an empty set. Implemented as a bit string, and therefore designed\nfor dense integer sets. Only ``Int``\\ s greater than 0 can be stored. If the\nset will be sparse (for example holding a few very large integers), use\n:obj:`Set` instead.\n```\n\"\"\"\nIntSet\n\ndoc\"\"\"\n    Task(func)\n\nCreate a `Task` (i.e. thread, or coroutine) to execute the given function (which must be callable with no arguments). The task exits when this function returns.\n\"\"\"\nTask\n\ndoc\"\"\"\n    pushdisplay(d::Display)\n\nPushes a new display `d` on top of the global display-backend stack. Calling `display(x)` or `display(mime, x)` will display `x` on the topmost compatible backend in the stack (i.e., the topmost backend that does not throw a `MethodError`).\n\"\"\"\npushdisplay\n\ndoc\"\"\"\n    randexp!([rng], A::Array{Float64,N})\n\nFill the array `A` with random numbers following the exponential distribution (with scale 1).\n\"\"\"\nrandexp!\n\ndoc\"\"\"\n    prevind(str, i)\n\nGet the previous valid string index before `i`. Returns a value less than `1` at the beginning of the string.\n\"\"\"\nprevind\n\ndoc\"\"\"\n    setenv(command, env; dir=working_dir)\n\nSet environment variables to use when running the given `command`. `env` is either a dictionary mapping strings to strings, an array of strings of the form `\"var=val\"`, or zero or more `\"var\"=>val` pair arguments. In order to modify (rather than replace) the existing environment, create `env` by `copy(ENV)` and then setting `env[\"var\"]=val` as desired, or use `withenv`.\n\nThe `dir` keyword argument can be used to specify a working directory for the command.\n\"\"\"\nsetenv\n\ndoc\"\"\"\n    invperm(v)\n\nReturn the inverse permutation of v.\n\"\"\"\ninvperm\n\ndoc\"\"\"\n    lowercase(string)\n\nReturns `string` with all characters converted to lowercase.\n\"\"\"\nlowercase\n\ndoc\"\"\"\n    produce(value)\n\nSend the given value to the last `consume` call, switching to the consumer task. If the next `consume` call passes any values, they are returned by `produce`.\n\"\"\"\nproduce\n\ndoc\"\"\"\n    StackOverflowError()\n\nThe function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.\n\"\"\"\nStackOverflowError\n\ndoc\"\"\"\n    acsch(x)\n\nCompute the inverse hyperbolic cosecant of `x`\n\"\"\"\nacsch\n\ndoc\"\"\"\n    process_running(p::Process)\n\nDetermine whether a process is currently running.\n\"\"\"\nprocess_running\n\ndoc\"\"\"\n```rst\n..  BigInt(x)\n\nCreate an arbitrary precision integer. ``x`` may be an ``Int`` (or anything\nthat can be converted to an ``Int``).  The usual mathematical operators are\ndefined for this type, and results are promoted to a ``BigInt``.\n\nInstances can be constructed from strings via :func:`parse`, or using the\n``big`` string literal.\n```\n\"\"\"\nBigInt\n\ndoc\"\"\"\n    rsearch(string, chars, [start])\n\nSimilar to `search`, but returning the last occurrence of the given characters within the given string, searching in reverse from `start`.\n\"\"\"\nrsearch\n\ndoc\"\"\"\n    isdirpath(path::AbstractString) -> Bool\n\nDetermines whether a path refers to a directory (for example, ends with a path separator).\n\"\"\"\nisdirpath\n\ndoc\"\"\"\n```rst\n..  in(item, collection) -> Bool\n           \u2208(item,collection) -> Bool\n           \u220b(collection,item) -> Bool\n           \u2209(item,collection) -> Bool\n           \u220c(collection,item) -> Bool\n\nDetermine whether an item is in the given collection, in the sense that it is\n``==`` to one of the values generated by iterating over the collection.\nSome collections need a slightly different definition; for example :obj:`Set`\\ s\ncheck whether the item :func:`isequal` to one of the elements. :obj:`Dict`\\ s look for\n``(key,value)`` pairs, and the key is compared using :func:`isequal`. To test\nfor the presence of a key in a dictionary, use :func:`haskey` or\n``k in keys(dict)``.\n```\n\"\"\"\nBase.in\n\ndoc\"\"\"\n    isblockdev(path) -> Bool\n\nReturns `true` if `path` is a block device, `false` otherwise.\n\"\"\"\nisblockdev\n\ndoc\"\"\"\n    ==(x, y)\n\nGeneric equality operator, giving a single `Bool` result. Falls back to `===`. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding.\n\nFollows IEEE semantics for floating-point numbers.\n\nCollections should generally implement `==` by calling `==` recursively on all contents.\n\nNew numeric types should implement this function for two arguments of the new type, and handle comparison to other types via promotion rules where possible.\n\"\"\"\nBase.(:(==))\n\ndoc\"\"\"\n    mapreducedim(f, op, A, dims[, initial])\n\nEvaluates to the same as `reducedim(op, map(f, A), dims, f(initial))`, but is generally faster because the intermediate array is avoided.\n\"\"\"\nmapreducedim\n\ndoc\"\"\"\n    seekstart(s)\n\nSeek a stream to its beginning.\n\"\"\"\nseekstart\n\ndoc\"\"\"\n    nfields(x::DataType) -> Int\n\nGet the number of fields of a `DataType`.\n\"\"\"\nnfields\n\ndoc\"\"\"\n```rst\n..  toq()\n\nReturn, but do not print, the time elapsed since the last :func:`tic`.\n```\n\"\"\"\ntoq\n\ndoc\"\"\"\n    writemime(stream, mime, x)\n\nThe `display` functions ultimately call `writemime` in order to write an object `x` as a given `mime` type to a given I/O `stream` (usually a memory buffer), if possible. In order to provide a rich multimedia representation of a user-defined type `T`, it is only necessary to define a new `writemime` method for `T`, via: `writemime(stream, ::MIME\"mime\", x::T) = ...`, where `mime` is a MIME-type string and the function body calls `write` (or similar) to write that representation of `x` to `stream`. (Note that the `MIME\"\"` notation only supports literal strings; to construct `MIME` types in a more flexible manner use `MIME{symbol(\"\")}`.)\n\nFor example, if you define a `MyImage` type and know how to write it to a PNG file, you could define a function `writemime(stream, ::MIME\"image/png\", x::MyImage) = ...` to allow your images to be displayed on any PNG-capable `Display` (such as IJulia). As usual, be sure to `import Base.writemime` in order to add new methods to the built-in Julia function `writemime`.\n\nTechnically, the `MIME\"mime\"` macro defines a singleton type for the given `mime` string, which allows us to exploit Julia's dispatch mechanisms in determining how to display objects of any given type.\n\"\"\"\nwritemime\n\ndoc\"\"\"\n    mean!(r, v)\n\nCompute the mean of `v` over the singleton dimensions of `r`, and write results to `r`.\n\"\"\"\nmean!\n\ndoc\"\"\"\n    join(strings, delim, [last])\n\nJoin an array of `strings` into a single string, inserting the given delimiter between adjacent strings. If `last` is given, it will be used instead of `delim` between the last two strings. For example, `join([\"apples\", \"bananas\", \"pineapples\"], \", \", \" and \") == \"apples, bananas and pineapples\"`.\n\n`strings` can be any iterable over elements `x` which are convertible to strings via `print(io::IOBuffer, x)`.\n\"\"\"\njoin\n\ndoc\"\"\"\n    linreg(x, y) -> a, b\n\nPerform linear regression. Returns `a` and `b` such that `a + b*x` is the closest\nstraight line to the given points `(x, y)`, i.e., such that the squared error\nbetween `y` and `a + b*x` is minimized.\n\n**Example**:\n\n    using PyPlot\n    x = [1.0:12.0;]\n    y = [5.5, 6.3, 7.6, 8.8, 10.9, 11.79, 13.48, 15.02, 17.77, 20.81, 22.0, 22.99]\n    a, b = linreg(x, y)          # Linear regression\n    plot(x, y, \"o\")              # Plot (x, y) points\n    plot(x, [a+b*i for i in x])  # Plot line determined by linear regression\n\"\"\"\nlinreg(x,y)\n\ndoc\"\"\"\n    linreg(x, y, w)\n\nWeighted least-squares linear regression.\n\"\"\"\nlinreg(x,y,w)\n\ndoc\"\"\"\n    polygamma(m, x)\n\nCompute the polygamma function of order `m` of argument `x` (the `(m+1)th` derivative of the logarithm of `gamma(x)`)\n\"\"\"\npolygamma\n\ndoc\"\"\"\n    isless(x, y)\n\nTest whether `x` is less than `y`, according to a canonical total order. Values that are normally unordered, such as `NaN`, are ordered in an arbitrary but consistent fashion. This is the default comparison used by `sort`. Non-numeric types with a canonical total order should implement this function. Numeric types only need to implement it if they have special values such as `NaN`.\n\"\"\"\nisless\n\ndoc\"\"\"\n    expm1(x)\n\nAccurately compute $e^x-1$.\n\"\"\"\nexpm1\n\ndoc\"\"\"\n    showerror(io, e)\n\nShow a descriptive representation of an exception object.\n\"\"\"\nshowerror\n\ndoc\"\"\"\n    setdiff(s1,s2)\n\nConstruct the set of elements in `s1` but not `s2`. Maintains order with arrays. Note that both arguments must be collections, and both will be iterated over. In particular, `setdiff(set,element)` where `element` is a potential member of `set`, will not work in general.\n\"\"\"\nsetdiff\n\ndoc\"\"\"\n    airyai(x)\n\nAiry function $\\operatorname{Ai}(x)$.\n\"\"\"\nairyai\n\ndoc\"\"\"\n    error(message::AbstractString)\n\nRaise an `ErrorException` with the given message\n\"\"\"\nerror\n\ndoc\"\"\"\n    less(file::AbstractString, [line])\n\nShow a file using the default pager, optionally providing a starting line number. Returns to the julia prompt when you quit the pager.\n\"\"\"\nless(f::AbstractString, ?)\n\ndoc\"\"\"\n    less(function, [types])\n\nShow the definition of a function using the default pager, optionally specifying a tuple of types to indicate which method to see.\n\"\"\"\nless(m::Method, ?)\n\ndoc\"\"\"\n```rst\n..  sqrtm(A)\n\nIf ``A`` has no negative real eigenvalues, compute the principal matrix square root of ``A``, that is the unique matrix :math:`X` with eigenvalues having positive real part such that :math:`X^2 = A`. Otherwise, a nonprincipal square root is returned.\n\nIf ``A`` is symmetric or Hermitian, its eigendecomposition (:func:`eigfact`) is used to compute the square root. Otherwise, the square root is determined by means of the Bj\u00f6rck-Hammarling method, which computes the complex Schur form (:func:`schur`) and then the complex square root of the triangular factor.\n\n.. [BH83] \u00c5ke Bj\u00f6rck and Sven Hammarling, \"A Schur method for the square root\n   of a matrix\", Linear Algebra and its Applications, 52-53, 1983, 127-140.\n   `doi:10.1016/0024-3795(83)80010-X <http://dx.doi.org/10.1016/0024-3795(83)80010-X>`_\n```\n\"\"\"\nsqrtm\n\ndoc\"\"\"\n    conv(u,v)\n\nConvolution of two vectors. Uses FFT algorithm.\n\"\"\"\nconv\n\ndoc\"\"\"\n    unsafe_store!(p::Ptr{T},x,i::Integer)\n\nStore a value of type `T` to the address of the ith element (1-indexed) starting at `p`. This is equivalent to the C expression `p[i-1] = x`.\n\nThe `unsafe` prefix on this function indicates that no validation is performed on the pointer `p` to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\"\"\"\nunsafe_store!\n\ndoc\"\"\"\n```rst\n..  expm(A)\n\nCompute the matrix exponential of ``A``, defined by\n\n.. math::\n\n   e^A = \\sum_{n=0}^{\\infty} \\frac{A^n}{n!}.\n\nFor symmetric or Hermitian ``A``, an eigendecomposition (:func:`eigfact`) is used, otherwise the scaling and squaring algorithm (see [H05]_) is chosen.\n\n.. [H05] Nicholas J. Higham, \"The squaring and scaling method for the matrix\n   exponential revisited\", SIAM Journal on Matrix Analysis and Applications,\n   26(4), 2005, 1179-1193.\n   `doi:10.1137/090768539 <http://dx.doi.org/10.1137/090768539>`_\n```\n\"\"\"\nexpm\n\ndoc\"\"\"\n```rst\n..  hessfact!(A)\n\n``hessfact!`` is the same as :func:`hessfact`, but saves space by overwriting the input ``A``, instead of creating a copy.\n```\n\"\"\"\nhessfact!\n\ndoc\"\"\"\n    Sys.get_process_title()\n\nGet the process title. On some systems, will always return empty string. (not exported)\n\"\"\"\nSys.get_process_title\n\ndoc\"\"\"\n    readcsv(source, [T::Type]; options...)\n\nEquivalent to `readdlm` with `delim` set to comma.\n\"\"\"\nreadcsv\n\ndoc\"\"\"\n    current_module() -> Module\n\nGet the *dynamically* current `Module`, which is the `Module` code is currently being read from. In general, this is not the same as the module containing the call to this function.\n\"\"\"\ncurrent_module\n\ndoc\"\"\"\n    erfcx(x)\n\nCompute the scaled complementary error function of `x`,\ndefined by $e^{x^2} \\operatorname{erfc}(x)$.  Note\nalso that $\\operatorname{erfcx}(-ix)$ computes the\nFaddeeva function $w(x)$.\n\"\"\"\nerfcx\n\ndoc\"\"\"\n    UndefVarError(var::Symbol)\n\nA symbol in the current scope is not defined.\n\"\"\"\nUndefVarError\n\ndoc\"\"\"\n    gc()\n\nPerform garbage collection. This should not generally be used.\n\"\"\"\ngc\n\ndoc\"\"\"\n    iscntrl(c::Union{Char,AbstractString}) -> Bool\n\nTests whether a character is a control character, or whether this is true for all elements of a string. Control characters are the non-printing characters of the Latin-1 subset of Unicode.\n\"\"\"\niscntrl\n\ndoc\"\"\"\n    hist!(counts, v, e) -> e, counts\n\nCompute the histogram of `v`, using a vector/range `e` as the edges for the bins. This function writes the resultant counts to a pre-allocated array `counts`.\n\"\"\"\nhist!\n\ndoc\"\"\"\n    minimum!(r, A)\n\nCompute the minimum value of `A` over the singleton dimensions of `r`, and write results to `r`.\n\"\"\"\nminimum!\n\ndoc\"\"\"\n    diagm(v[, k])\n\nConstruct a diagonal matrix and place `v` on the `k`th diagonal.\n\"\"\"\ndiagm\n\ndoc\"\"\"\n    .-(x, y)\n\nElement-wise subtraction operator.\n\"\"\"\nBase.(:(.-))\n\ndoc\"\"\"\n    imag(z)\n\nReturn the imaginary part of the complex number `z`\n\"\"\"\nimag\n\ndoc\"\"\"\n    unsafe_trunc(T, x)\n\n`unsafe_trunc(T, x)` returns the nearest integral value of type `T` whose absolute value is less than or equal to `x`. If the value is not representable by `T`, an arbitrary value will be returned.\n\"\"\"\nunsafe_trunc\n\ndoc\"\"\"\n    parent(A)\n\nReturns the \"parent array\" of an array view type (e.g., `SubArray`), or the array itself if it is not a view\n\"\"\"\nparent\n\ndoc\"\"\"\n    <(x, y)\n\nLess-than comparison operator. New numeric types should implement this function for two arguments of the new type. Because of the behavior of floating-point NaN values, `<` implements a partial order. Types with a canonical partial order should implement `<`, and types with a canonical total order should implement `isless`.\n\"\"\"\nBase.(:(<))\n\ndoc\"\"\"\n    EnvHash() -> EnvHash\n\nA singleton of this type provides a hash table interface to environment variables.\n\"\"\"\nEnvHash\n\ndoc\"\"\"\n```rst\n..  method_exists(f, Tuple type) -> Bool\n\nDetermine whether the given generic function has a method matching the given :obj:`Tuple` of argument types.\n\n.. doctest::\n\n   julia> method_exists(length, Tuple{Array})\n   true\n```\n\"\"\"\nmethod_exists\n\ndoc\"\"\"\n    nextpow(a, x)\n\nThe smallest `a^n` not less than `x`, where `n` is a non-negative integer. `a` must be greater than 1, and `x` must be greater than 0.\n\"\"\"\nnextpow\n\ndoc\"\"\"\n    rad2deg(x)\n\nConvert `x` from radians to degrees\n\"\"\"\nrad2deg\n\ndoc\"\"\"\n    gc_enable(on::Bool)\n\nControl whether garbage collection is enabled using a boolean argument (`true` for enabled, `false` for disabled). Returns previous GC state. Disabling garbage collection should be used only with extreme caution, as it can cause memory use to grow without bound.\n\"\"\"\ngc_enable\n\ndoc\"\"\"\n    sub2ind(dims, i, j, k...) -> index\n\nThe inverse of `ind2sub`, returns the linear index corresponding to the provided subscripts\n\"\"\"\nsub2ind\n\ndoc\"\"\"\n    isperm(v) -> Bool\n\nReturns `true` if `v` is a valid permutation.\n\"\"\"\nisperm\n\ndoc\"\"\"\n    super(T::DataType)\n\nReturn the supertype of DataType `T`.\n\"\"\"\nsuper\n\ndoc\"\"\"\n    readline(stream=STDIN)\n\nRead a single line of text, including a trailing newline character (if one is reached before the end of the input), from the given `stream` (defaults to `STDIN`),\n\"\"\"\nreadline\n\ndoc\"\"\"\n    atan(x)\n\nCompute the inverse tangent of `x`, where the output is in radians\n\"\"\"\natan\n\ndoc\"\"\"\n    logabsdet(M)\n\nLog of absolute value of determinant of real matrix. Equivalent to `(log(abs(det(M))), sign(det(M)))`, but may provide increased accuracy and/or speed.\n\"\"\"\nlogabsdet\n\ndoc\"\"\"\n    joinpath(parts...) -> AbstractString\n\nJoin path components into a full path. If some argument is an absolute path, then prior components are dropped.\n\"\"\"\njoinpath\n\ndoc\"\"\"\n    get_bigfloat_precision()\n\nGet the precision (in bits) currently used for `BigFloat` arithmetic.\n\"\"\"\nget_bigfloat_precision\n\ndoc\"\"\"\n    homedir() -> AbstractString\n\nReturn the current user's home directory.\n\"\"\"\nhomedir\n\ndoc\"\"\"\n    count_zeros(x::Integer) -> Integer\n\nNumber of zeros in the binary representation of `x`.\n\n```jldoctest\njulia> count_zeros(Int32(2 ^ 16 - 1))\n16\n```\n\"\"\"\ncount_zeros\n\ndoc\"\"\"\n    isinf(f) -> Bool\n\nTest whether a number is infinite\n\"\"\"\nisinf\n\ndoc\"\"\"\n    @fetchfrom\n\nEquivalent to `fetch(@spawnat p expr)`.\n\"\"\"\n:@fetchfrom\n\ndoc\"\"\"\n    secd(x)\n\nCompute the secant of `x`, where `x` is in degrees\n\"\"\"\nsecd\n\ndoc\"\"\"\n    varm(v, m)\n\nCompute the sample variance of a vector `v` with known mean `m`. Note: Julia does not ignore `NaN` values in the computation.\n\"\"\"\nvarm\n\ndoc\"\"\"\n    OverflowError()\n\nThe result of an expression is too large for the specified type and will cause a wraparound.\n\"\"\"\nOverflowError\n\ndoc\"\"\"\n    redirect_stderr([stream])\n\nLike redirect\\_stdout, but for STDERR\n\"\"\"\nredirect_stderr\n\ndoc\"\"\"\n    ctranspose!(dest,src)\n\nConjugate transpose array `src` and store the result in the preallocated array `dest`, which should have a size corresponding to `(size(src,2),size(src,1))`. No in-place transposition is supported and unexpected results will happen if `src` and `dest` have overlapping memory regions.\n\"\"\"\nctranspose!\n\ndoc\"\"\"\n    object_id(x)\n\nGet a unique integer id for `x`. `object_id(x)==object_id(y)` if and only if `is(x,y)`.\n\"\"\"\nobject_id\n\ndoc\"\"\"\n```rst\n..  norm(A, [p])\n\nCompute the ``p``-norm of a vector or the operator norm of a matrix ``A``, defaulting to the ``p=2``-norm.\n\nFor vectors, ``p`` can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, ``norm(A, Inf)`` returns the largest value in ``abs(A)``, whereas ``norm(A, -Inf)`` returns the smallest.\n\nFor matrices, the matrix norm induced by the vector ``p``-norm is used, where valid values of ``p`` are ``1``, ``2``, or ``Inf``. (Note that for sparse matrices, ``p=2`` is currently not implemented.) Use :func:`vecnorm` to compute the Frobenius norm.\n```\n\"\"\"\nnorm\n\ndoc\"\"\"\n```rst\n..  print_unescaped(io, s::AbstractString)\n\nGeneral unescaping of traditional C and Unicode escape sequences. Reverse of :func:`print_escaped`.\n```\n\"\"\"\nprint_unescaped\n\ndoc\"\"\"\n    digits!(array, n, [base])\n\nFills an array of the digits of `n` in the given base. More significant digits are at higher indexes. If the array length is insufficient, the least significant digits are filled up to the array length. If the array length is excessive, the excess portion is filled with zeros.\n\"\"\"\ndigits!\n\ndoc\"\"\"\n    MethodError(f, args)\n\nA method with the required type signature does not exist in the given generic function.\n\"\"\"\nMethodError\n\ndoc\"\"\"\n    cat(dims, A...)\n\nConcatenate the input arrays along the specified dimensions in the iterable `dims`. For dimensions not in `dims`, all input arrays should have the same size, which will also be the size of the output array along that dimension. For dimensions in `dims`, the size of the output array is the sum of the sizes of the input arrays along that dimension. If `dims` is a single number, the different arrays are tightly stacked along that dimension. If `dims` is an iterable containing several dimensions, this allows one to construct block diagonal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example, `cat([1,2], matrices...)` builds a block diagonal matrix, i.e. a block matrix with `matrices[1]`, `matrices[2]`, ... as diagonal blocks and matching zero blocks away from the diagonal.\n\"\"\"\ncat\n\ndoc\"\"\"\n```rst\n..  factorial(n)\n\nFactorial of ``n``.  If ``n`` is an :obj:`Integer`, the factorial\nis computed as an integer (promoted to at least 64 bits).  Note\nthat this may overflow if ``n`` is not small, but you can use\n``factorial(big(n))`` to compute the result exactly in arbitrary\nprecision.  If ``n`` is not an ``Integer``, ``factorial(n)`` is\nequivalent to :func:`gamma(n+1) <gamma>`.\n```\n\"\"\"\nfactorial(n)\n\ndoc\"\"\"\n```rst\n..  factorial(n,k)\n\nCompute ``factorial(n)/factorial(k)``\n```\n\"\"\"\nfactorial(n,k)\n\ndoc\"\"\"\n    bitrand([rng], [dims...])\n\nGenerate a `BitArray` of random boolean values.\n\"\"\"\nbitrand\n\ndoc\"\"\"\n```rst\n..  randcycle([rng,] n)\n\nConstruct a random cyclic permutation of length ``n``. The optional ``rng``\nargument specifies a random number generator, see :ref:`Random Numbers\n<random-numbers>`.\n```\n\"\"\"\nrandcycle\n\ndoc\"\"\"\n    leading_zeros(x::Integer) -> Integer\n\nNumber of zeros leading the binary representation of `x`.\n\n```jldoctest\njulia> leading_zeros(Int32(1))\n31\n```\n\"\"\"\nleading_zeros\n\ndoc\"\"\"\n    hankelh2(nu, x)\n\nBessel function of the third kind of order `nu`, $H^{(2)}_\\nu(x)$.\n\"\"\"\nhankelh2\n\ndoc\"\"\"\n    lexcmp(x, y)\n\nCompare `x` and `y` lexicographically and return -1, 0, or 1 depending on whether `x` is less than, equal to, or greater than `y`, respectively. This function should be defined for lexicographically comparable types, and `lexless` will call `lexcmp` by default.\n\"\"\"\nlexcmp\n\ndoc\"\"\"\n    inf(f)\n\nReturns positive infinity of the floating point type `f` or of the same floating point type as `f`\n\"\"\"\ninf\n\ndoc\"\"\"\n    isupper(c::Union{Char,AbstractString}) -> Bool\n\nTests whether a character is an uppercase letter, or whether this is true for all elements of a string. A character is classified as uppercase if it belongs to Unicode category Lu, Letter: Uppercase, or Lt, Letter: Titlecase.\n\"\"\"\nisupper\n\ndoc\"\"\"\n    pointer_to_array(pointer, dims[, take_ownership::Bool])\n\nWrap a native pointer as a Julia Array object. The pointer element type determines the array element type. `own` optionally specifies whether Julia should take ownership of the memory, calling `free` on the pointer when the array is no longer referenced.\n\"\"\"\npointer_to_array\n\ndoc\"\"\"\n    show(x)\n\nWrite an informative text representation of a value to the current output stream. New types should overload `show(io, x)` where the first argument is a stream. The representation used by `show` generally includes Julia-specific formatting and type information.\n\"\"\"\nshow\n\ndoc\"\"\"\n    @allocated\n\nA macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression. Note: the expression is evaluated inside a local function, instead of the current context, in order to eliminate the effects of compilation, however, there still may be some allocations due to JIT compilation. This also makes the results inconsistent with the `@time` macros, which do not try to adjust for the effects of compilation.\n\"\"\"\n:@allocated\n\ndoc\"\"\"\n    Array(dims)\n\n`Array{T}(dims)` constructs an uninitialized dense array with element type `T`. `dims` may be a tuple or a series of integer arguments. The syntax `Array(T, dims)` is also available, but deprecated.\n\"\"\"\nArray\n\ndoc\"\"\"\n    isreal(x) -> Bool\n\nTest whether `x` or all its elements are numerically equal to some real number\n\"\"\"\nisreal\n\ndoc\"\"\"\n    randsubseq(A, p) -> Vector\n\nReturn a vector consisting of a random subsequence of the given array `A`, where each element of `A` is included (in order) with independent probability `p`. (Complexity is linear in `p*length(A)`, so this function is efficient even if `p` is small and `A` is large.) Technically, this process is known as \"Bernoulli sampling\" of `A`.\n\"\"\"\nrandsubseq\n\ndoc\"\"\"\n    issubtype(type1, type2)\n\nReturn `true` if and only if all values of `type1` are also of `type2`. Can also be written using the `<:` infix operator as `type1 <: type2`.\n\"\"\"\nissubtype(type1, type2)\n\ndoc\"\"\"\n    finalizer(x, function)\n\nRegister a function `f(x)` to be called when there are no program-accessible references to `x`. The behavior of this function is unpredictable if `x` is of a bits type.\n\"\"\"\nfinalizer\n\ndoc\"\"\"\n    nextprod([k_1,k_2,...], n)\n\nNext integer not less than `n` that can be written as $\\prod k_i^{p_i}$ for integers $p_1$, $p_2$, etc.\n\"\"\"\nnextprod\n\ndoc\"\"\"\n    <<(x, n)\n\nLeft bit shift operator.\n\"\"\"\nBase.(:(<<))\n\ndoc\"\"\"\n    csch(x)\n\nCompute the hyperbolic cosecant of `x`\n\"\"\"\ncsch\n\ndoc\"\"\"\n    isequal(x, y)\n\nSimilar to `==`, except treats all floating-point `NaN` values as equal to each other, and treats `-0.0` as unequal to `0.0`. The default implementation of `isequal` calls `==`, so if you have a type that doesn't have these floating-point subtleties then you probably only need to define `==`.\n\n`isequal` is the comparison function used by hash tables (`Dict`). `isequal(x,y)` must imply that `hash(x) == hash(y)`.\n\nThis typically means that if you define your own `==` function then you must define a corresponding `hash` (and vice versa). Collections typically implement `isequal` by calling `isequal` recursively on all contents.\n\nScalar types generally do not need to implement `isequal` separate from `==`, unless they represent floating-point numbers amenable to a more efficient implementation than that provided as a generic fallback (based on `isnan`, `signbit`, and `==`).\n\"\"\"\nisequal\n\ndoc\"\"\"\n    lyap(A, C)\n\nComputes the solution `X` to the continuous Lyapunov equation `AX + XA' + C = 0`, where no eigenvalue of `A` has a zero real part and no two eigenvalues are negative complex conjugates of each other.\n\"\"\"\nlyap\n\ndoc\"\"\"\n    condskeel(M, [x, p])\n\n$$\\kappa_S(M, p) & = \\left\\Vert \\left\\vert M \\right\\vert \\left\\vert M^{-1} \\right\\vert  \\right\\Vert_p \\\\\n\\kappa_S(M, x, p) & = \\left\\Vert \\left\\vert M \\right\\vert \\left\\vert M^{-1} \\right\\vert \\left\\vert x \\right\\vert \\right\\Vert_p$$\n\nSkeel condition number $\\kappa_S$ of the matrix `M`, optionally with respect to\nthe vector `x`, as computed using the operator `p`-norm. `p` is `Inf` by\ndefault, if not provided. Valid values for `p` are `1`, `2`, or `Inf`.\n\nThis quantity is also known in the literature as the Bauer condition number,\nrelative condition number, or componentwise relative condition number.\n\"\"\"\ncondskeel\n\ndoc\"\"\"\n    sec(x)\n\nCompute the secant of `x`, where `x` is in radians\n\"\"\"\nsec\n\ndoc\"\"\"\n    recv(socket::UDPSocket)\n\nRead a UDP packet from the specified socket, and return the bytes received. This call blocks.\n\"\"\"\nrecv\n\ndoc\"\"\"\n    acoth(x)\n\nCompute the inverse hyperbolic cotangent of `x`\n\"\"\"\nacoth\n\ndoc\"\"\"\n    det(M)\n\nMatrix determinant\n\"\"\"\ndet\n\ndoc\"\"\"\n    TypeError(func::Symbol, context::AbstractString, expected::Type, got)\n\nA type assertion failure, or calling an intrinsic function with an incorrect argument type.\n\"\"\"\nTypeError\n\ndoc\"\"\"\n    A_rdiv_Bt(A, B)\n\nFor matrices or vectors $A$ and $B$, calculates $A / B\u1d40$\n\"\"\"\nA_rdiv_Bt\n\ndoc\"\"\"\n    pwd() -> AbstractString\n\nGet the current working directory.\n\"\"\"\npwd\n\ndoc\"\"\"\n    getipaddr() -> AbstractString\n\nGet the IP address of the local machine, as a string of the form \"x.x.x.x\".\n\"\"\"\ngetipaddr\n\ndoc\"\"\"\n    uppercase(string)\n\nReturns `string` with all characters converted to uppercase.\n\"\"\"\nuppercase\n\ndoc\"\"\"\n    cosd(x)\n\nCompute cosine of `x`, where `x` is in degrees\n\"\"\"\ncosd\n\ndoc\"\"\"\n    cycle(iter)\n\nAn iterator that cycles through `iter` forever.\n\"\"\"\ncycle\n\ndoc\"\"\"\n    put!(RemoteRef, value)\n\nStore a value to a remote reference. Implements \"shared queue of length 1\" semantics: if a value is already present, blocks until the value is removed with `take!`. Returns its first argument.\n\"\"\"\nput!(::RemoteRef, value)\n\ndoc\"\"\"\n    put!(Channel, value)\n\nAppends an item to the channel. Blocks if the channel is full.\n\"\"\"\nput!(::Channel, value)\n\ndoc\"\"\"\n    operm(file)\n\nLike uperm but gets the permissions for people who neither own the file nor are a member of the group owning the file\n\"\"\"\noperm\n\ndoc\"\"\"\n```rst\n..  cumsum(A, [dim])\n\nCumulative sum along a dimension ``dim`` (defaults to 1).\nSee also :func:`cumsum!` to use a preallocated output array,\nboth for performance and to control the precision of the\noutput (e.g. to avoid overflow).\n```\n\"\"\"\ncumsum\n\ndoc\"\"\"\n    rmprocs(pids...)\n\nRemoves the specified workers.\n\"\"\"\nrmprocs\n\ndoc\"\"\"\n    rpad(string, n, p)\n\nMake a string at least `n` columns wide when printed, by padding on the right with copies of `p`.\n\"\"\"\nrpad\n\ndoc\"\"\"\n    setfield!(value, name::Symbol, x)\n\nAssign `x` to a named field in `value` of composite type. The syntax `a.b = c` calls `setfield!(a, :b, c)`, and the syntax `a.(b) = c` calls `setfield!(a, b, c)`.\n\"\"\"\nsetfield!\n\ndoc\"\"\"\n    @printf([io::IOStream], \"%Fmt\", args...)\n\nPrint `args` using C `printf()` style format specification string. Optionally, an `IOStream` may be passed as the first argument to redirect output.\n\"\"\"\n:@printf\n\ndoc\"\"\"\n    rstrip(string, [chars])\n\nReturn `string` with any trailing whitespace removed. If `chars` (a character, or vector or set of characters) is provided, instead remove characters contained in it.\n\"\"\"\nrstrip\n\ndoc\"\"\"\n    countlines(io,[eol::Char])\n\nRead `io` until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\\\\n' are supported by passing them as the second argument.\n\"\"\"\ncountlines\n\ndoc\"\"\"\n    *(A, B)\n\nMatrix multiplication\n\"\"\"\nBase.(:(*))(::AbstractMatrix, ::AbstractMatrix)\n\ndoc\"\"\"\n```rst\n..  \\\\(A, B)\n\nMatrix division using a polyalgorithm. For input matrices ``A`` and ``B``, the result ``X`` is such that ``A*X == B`` when ``A`` is square.  The solver that is used depends upon the structure of ``A``.  A direct solver is used for upper or lower triangular ``A``.  For Hermitian ``A`` (equivalent to symmetric ``A`` for non-complex ``A``) the ``BunchKaufman`` factorization is used.  Otherwise an LU factorization is used. For rectangular ``A`` the result is the minimum-norm least squares solution computed by a pivoted QR factorization of ``A`` and a rank estimate of ``A`` based on the R factor.\n\nWhen ``A`` is sparse, a similar polyalgorithm is used. For indefinite matrices, the ``LDLt`` factorization does not use pivoting during the numerical factorization and therefore the procedure can fail even for invertible matrices.\n```\n\"\"\"\nBase.(:(\\))(A,B)\n\ndoc\"\"\"\n```rst\n..  .\\\\(x, y)\n\nElement-wise left division operator.\n```\n\"\"\"\nBase.(:(.\\))(x,y)\n\ndoc\"\"\"\n```rst\n..  \\\\(x, y)\n\nLeft division operator: multiplication of ``y`` by the inverse of ``x`` on the left.\nGives floating-point results for integer arguments.\n```\n\"\"\"\nBase.(:(\\))(x::Number,y::Number)\n\n\ndoc\"\"\"\n    *(x, y...)\n\nMultiplication operator. `x*y*z*...` calls this function with all arguments, i.e.\n`*(x, y, z, ...)`.\n\"\"\"\nBase.(:(*))(x, y...)\n\ndoc\"\"\"\n    *(s, t)\n\nConcatenate strings. The `*` operator is an alias to this function.\n\n```jldoctest\njulia> \"Hello \" * \"world\"\n\"Hello world\"\n```\n\"\"\"\nBase.(:(*))(s::AbstractString, t::AbstractString)\n\ndoc\"\"\"\n```rst\n..  complement!(s)\n\nMutates :obj:`IntSet` ``s`` into its set-complement.\n```\n\"\"\"\ncomplement!\n\ndoc\"\"\"\n```rst\n..  slice(A, inds...)\n\nReturns a view of array ``A`` with the given indices like :func:`sub`, but drops all dimensions indexed with scalars.\n```\n\"\"\"\nslice\n\ndoc\"\"\"\n    time()\n\nGet the system time in seconds since the epoch, with fairly high (typically, microsecond) resolution.\n\"\"\"\ntime()\n\ndoc\"\"\"\n    procs()\n\nReturns a list of all process identifiers.\n\"\"\"\nprocs\n\ndoc\"\"\"\n    procs(S::SharedArray)\n\nGet the vector of processes that have mapped the shared array\n\"\"\"\nprocs(::SharedArray)\n\ndoc\"\"\"\n    mod(x, y)\n\nModulus after division, returning in the range \\[0,`y`), if `y` is positive, or (`y`,0\\] if `y` is negative.\n\"\"\"\nmod\n\ndoc\"\"\"\n    trues(dims)\n\nCreate a `BitArray` with all values set to `true`\n\"\"\"\ntrues\n\ndoc\"\"\"\n    qr(A [,pivot=Val{false}][;thin=true]) -> Q, R, [p]\n\nCompute the (pivoted) QR factorization of `A` such that either `A = Q*R` or `A[:,p] = Q*R`. Also see `qrfact`. The default is to compute a thin factorization. Note that `R` is not extended with zeros when the full `Q` is requested.\n\"\"\"\nqr\n\ndoc\"\"\"\n    invmod(x,m)\n\nTake the inverse of `x` modulo `m`: `y` such that $xy = 1 \\pmod m$.\n\"\"\"\ninvmod\n\ndoc\"\"\"\n    TextDisplay(stream)\n\nReturns a `TextDisplay <: Display`, which can display any object as the text/plain MIME type (only), writing the text representation to the given I/O stream. (The text representation is the same as the way an object is printed in the Julia REPL.)\n\"\"\"\nTextDisplay\n\ndoc\"\"\"\n    factor(n) -> Dict\n\nCompute the prime factorization of an integer `n`. Returns a dictionary. The\nkeys of the dictionary correspond to the factors, and hence are of the same type\nas `n`. The value associated with each key indicates the number of times the\nfactor appears in the factorization.\n\n```jldoctest\njulia> factor(100) # == 2*2*5*5\nDict{Int64,Int64} with 2 entries:\n  2 => 2\n  5 => 2\n```\n\"\"\"\nfactor\n\ndoc\"\"\"\n    ismatch(r::Regex, s::AbstractString) -> Bool\n\nTest whether a string contains a match of the given regular expression.\n\"\"\"\nismatch\n\ndoc\"\"\"\n    exp(x)\n\nCompute $e^x$.\n\"\"\"\nexp\n\ndoc\"\"\"\n    with_bigfloat_precision(f::Function,precision::Integer)\n\nChange the `BigFloat` arithmetic precision (in bits) for the duration of `f`. It is logically equivalent to:\n\n    old = get_bigfloat_precision()\n    set_bigfloat_precision(precision)\n    f()\n    set_bigfloat_precision(old)\n\"\"\"\nwith_bigfloat_precision\n\ndoc\"\"\"\n    searchindex(string, substring, [start])\n\nSimilar to `search`, but return only the start index at which the substring is found, or `0` if it is not.\n\"\"\"\nsearchindex\n\ndoc\"\"\"\n    listenany(port_hint) -> (UInt16,TCPServer)\n\nCreate a `TCPServer` on any port, using hint as a starting point. Returns a tuple of the actual port that the server was created on and the server itself.\n\"\"\"\nlistenany\n\ndoc\"\"\"\n    getpid() -> Int32\n\nGet julia's process ID.\n\"\"\"\ngetpid\n\ndoc\"\"\"\n    cbrt(x)\n\nReturn $x^{1/3}$.  The prefix operator `\u221b` is equivalent to `cbrt`.\n\"\"\"\ncbrt\n\ndoc\"\"\"\n```rst\n..  Tridiagonal(dl, d, du)\n\nConstruct a tridiagonal matrix from the lower diagonal, diagonal, and upper diagonal, respectively.  The result is of type ``Tridiagonal`` and provides efficient specialized linear solvers, but may be converted into a regular matrix with :func:`full`.\n```\n\"\"\"\nTridiagonal\n\ndoc\"\"\"\n    findprev(A, i)\n\nFind the previous index <= `i` of a non-zero element of `A`, or `0` if not found.\n\"\"\"\nfindprev(A,i)\n\ndoc\"\"\"\n    findprev(predicate, A, i)\n\nFind the previous index <= `i` of an element of `A` for which `predicate` returns `true`, or `0` if not found.\n\"\"\"\nfindprev(predicate::Function,A,i)\n\ndoc\"\"\"\n    findprev(A, v, i)\n\nFind the previous index <= `i` of an element of `A` equal to `v` (using `==`), or `0` if not found.\n\"\"\"\nfindprev(A,v,i)\n\ndoc\"\"\"\n    matchall(r::Regex, s::AbstractString[, overlap::Bool=false]) -> Vector{AbstractString}\n\nReturn a vector of the matching substrings from eachmatch.\n\"\"\"\nmatchall\n\ndoc\"\"\"\n    get!(collection, key, default)\n\nReturn the value stored for the given key, or if no mapping for the key is present, store `key => default`, and return `default`.\n\"\"\"\nget!(collection,key,default)\n\ndoc\"\"\"\n    get!(f::Function, collection, key)\n\nReturn the value stored for the given key, or if no mapping for the key is present, store `key => f()`, and return `f()`.\n\nThis is intended to be called using `do` block syntax:\n\n    get!(dict, key) do\n        # default value calculated here\n        time()\n    end\n\"\"\"\nget!(f::Function,collection,key)\n\ndoc\"\"\"\n    inv(M)\n\nMatrix inverse\n\"\"\"\ninv\n\ndoc\"\"\"\n    mod1(x,m)\n\nModulus after division, returning in the range (0,m\\]\n\"\"\"\nmod1\n\ndoc\"\"\"\n    @assert cond [text]\n\nThrow an `AssertionError` if `cond` is `false`. Preferred syntax for writing assertions.\nMessage `text` is optionally displayed upon assertion failure.\n\"\"\"\n:@assert\n\ndoc\"\"\"\n    intersect!(s1, s2)\n\nIntersects sets `s1` and `s2` and overwrites the set `s1` with the result. If needed, `s1` will be expanded to the size of `s2`.\n\"\"\"\nintersect!\n\ndoc\"\"\"\n    listen([addr,]port) -> TCPServer\n\nListen on port on the address specified by `addr`. By default this listens on localhost only. To listen on all interfaces pass `IPv4(0)` or `IPv6(0)` as appropriate.\n\"\"\"\nlisten(addr,port)\n\ndoc\"\"\"\n    listen(path) -> PipeServer\n\nCreate and listen on a Named Pipe / Domain Socket\n\"\"\"\nlisten(path)\n\ndoc\"\"\"\n    leading_ones(x::Integer) -> Integer\n\nNumber of ones leading the binary representation of `x`.\n\n```jldoctest\njulia> leading_ones(UInt32(2 ^ 32 - 2))\n31\n```\n\"\"\"\nleading_ones\n\ndoc\"\"\"\n    deserialize(stream)\n\nRead a value written by `serialize`.\n\"\"\"\ndeserialize\n\ndoc\"\"\"\n    asech(x)\n\nCompute the inverse hyperbolic secant of `x`\n\"\"\"\nasech\n\ndoc\"\"\"\n```rst\n..  ismarked(s)\n\nReturns ``true`` if stream ``s`` is marked.\n\nSee also :func:`mark`, :func:`unmark`, :func:`reset`\n```\n\"\"\"\nismarked\n\ndoc\"\"\"\n```rst\n..  first(coll)\n\nGet the first element of an iterable collection. Returns the start point of a :obj:`Range`\neven if it is empty.\n```\n\"\"\"\nfirst\n\ndoc\"\"\"\n    median!(v)\n\nLike `median`, but may overwrite the input vector.\n\"\"\"\nmedian!\n\ndoc\"\"\"\n    cumprod!(B, A, [dim])\n\nCumulative product of `A` along a dimension, storing the result in `B`. The dimension defaults to 1.\n\"\"\"\ncumprod!\n\ndoc\"\"\"\n    @linux\n\nGiven `@linux? a : b`, do `a` on Linux and `b` elsewhere. See documentation for Handling Platform Variations in the Calling C and Fortran Code section of the manual.\n\"\"\"\n:@linux\n\ndoc\"\"\"\n```rst\n..  complement(s)\n\nReturns the set-complement of :obj:`IntSet` ``s``.\n```\n\"\"\"\ncomplement\n\ndoc\"\"\"\n    rethrow([e])\n\nThrow an object without changing the current exception backtrace. The default argument is the current exception (if called within a `catch` block).\n\"\"\"\nrethrow\n\ndoc\"\"\"\n    reprmime(mime, x)\n\nReturns an `AbstractString` or `Vector{UInt8}` containing the representation of `x` in the requested `mime` type, as written by `writemime` (throwing a `MethodError` if no appropriate `writemime` is available). An `AbstractString` is returned for MIME types with textual representations (such as `\"text/html\"` or `\"application/postscript\"`), whereas binary data is returned as `Vector{UInt8}`. (The function `istext(mime)` returns whether or not Julia treats a given `mime` type as text.)\n\nAs a special case, if `x` is an `AbstractString` (for textual MIME types) or a `Vector{UInt8}` (for binary MIME types), the `reprmime` function assumes that `x` is already in the requested `mime` format and simply returns `x`.\n\"\"\"\nreprmime\n\ndoc\"\"\"\n    rm(path::AbstractString; recursive=false)\n\nDelete the file, link, or empty directory at the given path. If `recursive=true` is passed and the path is a directory, then all contents are removed recursively.\n\"\"\"\nrm\n\ndoc\"\"\"\n    MersenneTwister([seed])\n\nCreate a `MersenneTwister` RNG object. Different RNG objects can have their own seeds, which may be useful for generating different streams of random numbers.\n\"\"\"\nMersenneTwister\n\ndoc\"\"\"\n    graphemes(s) -> iterator over substrings of s\n\nReturns an iterator over substrings of `s` that correspond to the extended graphemes in the string, as defined by Unicode UAX \\#29. (Roughly, these are what users would perceive as single characters, even though they may contain more than one codepoint; for example a letter combined with an accent mark is a single grapheme.)\n\"\"\"\ngraphemes\n\ndoc\"\"\"\n    @__FILE__ -> AbstractString\n\n`@__FILE__` expands to a string with the absolute path and file name of the script being run. Returns `nothing` if run from a REPL or an empty string if evaluated by `julia -e <expr>`.\n\"\"\"\n:@__FILE__\n\nkeywords[symbol(\"@__LINE__\")] = doc\"\"\"\n    @__LINE__ -> Int\n\n`@__LINE__` expands to the line number of the call-site.\n\"\"\"\n\ndoc\"\"\"\n    charwidth(c)\n\nGives the number of columns needed to print a character.\n\"\"\"\ncharwidth\n\ndoc\"\"\"\n    abspath(path::AbstractString) -> AbstractString\n\nConvert a path to an absolute path by adding the current directory if necessary.\n\"\"\"\nabspath\n\ndoc\"\"\"\n    ispunct(c::Union{Char,AbstractString}) -> Bool\n\nTests whether a character belongs to the Unicode general category Punctuation, i.e. a character whose category code begins with 'P'. For strings, tests whether this is true for all elements of the string.\n\"\"\"\nispunct\n\ndoc\"\"\"\n    bitunpack(B::BitArray{N}) -> Array{Bool,N}\n\nConverts a packed boolean array to an array of booleans\n\"\"\"\nbitunpack\n\ndoc\"\"\"\n    @which\n\nApplied to a function call, it evaluates the arguments to the specified function call, and returns the `Method` object for the method that would be called for those arguments. Applied to a variable, it returns the module in which the variable was bound. It calls out to the `which` function.\n\"\"\"\n:@which\n\ndoc\"\"\"\n    size(A, [dim...])\n\nReturns a tuple containing the dimensions of `A`. Optionally you can specify the dimension(s) you want the length of, and get the length of that dimension, or a tuple of the lengths of dimensions you asked for.:\n\n    julia> A = rand(2,3,4);\n\n    julia> size(A, 2)\n    3\n\n    julia> size(A,3,2)\n    (4,3)\n\"\"\"\nsize\n\ndoc\"\"\"\n    trigamma(x)\n\nCompute the trigamma function of `x` (the logarithmic second derivative of `gamma(x)`)\n\"\"\"\ntrigamma\n\ndoc\"\"\"\n    findmin(itr) -> (x, index)\n\nReturns the minimum element and its index.\n\"\"\"\nfindmin(itr)\n\ndoc\"\"\"\n    findmin(A, dims) -> (minval, index)\n\nFor an array input, returns the value and index of the minimum over the given dimensions.\n\"\"\"\nfindmin(A,dims)\n\ndoc\"\"\"\n    ismount(path) -> Bool\n\nReturns `true` if `path` is a mount point, `false` otherwise.\n\"\"\"\nismount\n\ndoc\"\"\"\n    endswith(string, suffix | chars)\n\nReturns `true` if `string` ends with `suffix`. If the second argument is a vector or set of characters, tests whether the last character of `string` belongs to that set.\n\"\"\"\nendswith\n\ndoc\"\"\"\n    airy(k,x)\n\nThe `k`th derivative of the Airy function $\\operatorname{Ai}(x)$.\n\"\"\"\nairy\n\ndoc\"\"\"\n    !(x)\n\nBoolean not\n\"\"\"\nBase.(:(!))\n\ndoc\"\"\"\n    length(A) -> Integer\n\nReturns the number of elements in `A`.\n\"\"\"\nlength(::AbstractArray)\n\ndoc\"\"\"\n    length(collection) -> Integer\n\nFor ordered, indexable collections, the maximum index `i` for which `getindex(collection, i)` is valid. For unordered collections, the number of elements.\n\"\"\"\nlength(collection)\n\ndoc\"\"\"\n    length(s)\n\nThe number of characters in string `s`.\n\"\"\"\nlength(::AbstractString)\n\ndoc\"\"\"\n    rand!([rng], A, [coll])\n\nPopulate the array `A` with random values. If the indexable collection `coll` is specified, the values are picked randomly from `coll`. This is equivalent to `copy!(A, rand(rng, coll, size(A)))` or `copy!(A, rand(rng, eltype(A), size(A)))` but without allocating a new array.\n\"\"\"\nrand!\n\ndoc\"\"\"\n```rst\n..  bkfact(A) -> BunchKaufman\n\nCompute the Bunch-Kaufman [Bunch1977]_ factorization of a real symmetric or complex Hermitian matrix ``A`` and return a ``BunchKaufman`` object. The following functions are available for ``BunchKaufman`` objects: ``size``, ``\\``, ``inv``, ``issym``, ``ishermitian``.\n\n.. [Bunch1977] J R Bunch and L Kaufman, Some stable methods for calculating inertia and solving symmetric linear systems, Mathematics of Computation 31:137 (1977), 163-179. `url <http://www.ams.org/journals/mcom/1977-31-137/S0025-5718-1977-0428694-0>`_.\n```\n\"\"\"\nbkfact\n\ndoc\"\"\"\n    searchsortedlast(a, x, [by=<transform>,] [lt=<comparison>,] [rev=false])\n\nReturns the index of the last value in `a` less than or equal to `x`, according to the specified order. Returns `0` if `x` is less than all values in `a`.\n\"\"\"\nsearchsortedlast\n\ndoc\"\"\"\n    InterruptException()\n\nThe process was stopped by a terminal interrupt (CTRL+C).\n\"\"\"\nInterruptException\n\ndoc\"\"\"\n    cov(v1[, v2][, vardim=1, corrected=true, mean=nothing])\n\nCompute the Pearson covariance between the vector(s) in `v1` and `v2`. Here, `v1` and `v2` can be either vectors or matrices.\n\nThis function accepts three keyword arguments:\n\n- `vardim`: the dimension of variables. When `vardim = 1`, variables are considered in columns while observations in rows; when `vardim = 2`, variables are in rows while observations in columns. By default, it is set to `1`.\n- `corrected`: whether to apply Bessel's correction (divide by `n-1` instead of `n`). By default, it is set to `true`.\n- `mean`: allow users to supply mean values that are known. By default, it is set to `nothing`, which indicates that the mean(s) are unknown, and the function will compute the mean. Users can use `mean=0` to indicate that the input data are centered, and hence there's no need to subtract the mean.\n\nThe size of the result depends on the size of `v1` and `v2`. When both `v1` and `v2` are vectors, it returns the covariance between them as a scalar. When either one is a matrix, it returns a covariance matrix of size `(n1, n2)`, where `n1` and `n2` are the numbers of slices in `v1` and `v2`, which depend on the setting of `vardim`.\n\nNote: `v2` can be omitted, which indicates `v2 = v1`.\n\"\"\"\ncov\n\ndoc\"\"\"\n    den(x)\n\nDenominator of the rational representation of `x`\n\"\"\"\nden\n\ndoc\"\"\"\n    issubnormal(f) -> Bool\n\nTest whether a floating point number is subnormal\n\"\"\"\nissubnormal\n\ndoc\"\"\"\n    Ac_ldiv_B(A, B)\n\nFor matrices or vectors $A$ and $B$, calculates $A\u1d34$ \\ $B$\n\"\"\"\nAc_ldiv_B\n\ndoc\"\"\"\n    NullException()\n\nAn attempted access to a `Nullable` with no defined value.\n\"\"\"\nNullException\n\ndoc\"\"\"\n    .==(x, y)\n\nElement-wise equality comparison operator.\n\"\"\"\nBase.(:(.==))\n\ndoc\"\"\"\n    cfunction(function::Function, ReturnType::Type, (ArgumentTypes...))\n\nGenerate C-callable function pointer from Julia function. Type annotation of the return value in the callback function is a must for situations where Julia cannot infer the return type automatically.\n\nFor example:\n\n    function foo()\n        # body\n\n        retval::Float64\n    end\n\n    bar = cfunction(foo, Float64, ())\n\"\"\"\ncfunction\n\ndoc\"\"\"\n    recvfrom(socket::UDPSocket) -> (address, data)\n\nRead a UDP packet from the specified socket, returning a tuple of (address, data), where address will be either IPv4 or IPv6 as appropriate.\n\"\"\"\nrecvfrom\n\ndoc\"\"\"\n```rst\n..  @code_llvm\n\nEvaluates the arguments to the function call, determines their types, and calls :func:`code_llvm` on the resulting expression.\n```\n\"\"\"\n:@code_llvm\n\ndoc\"\"\"\n    nextfloat(f)\n\nGet the next floating point number in lexicographic order\n\"\"\"\nnextfloat\n\ndoc\"\"\"\n    intersect(s1,s2...)\n    \u2229(s1,s2)\n\nConstruct the intersection of two or more sets. Maintains order and multiplicity of the first argument for arrays and ranges.\n\"\"\"\nintersect\n\ndoc\"\"\"\n    !=(x, y)\n    \u2260(x,y)\n\nNot-equals comparison operator. Always gives the opposite answer as `==`. New types should generally not implement this, and rely on the fallback definition `!=(x,y) = !(x==y)` instead.\n\"\"\"\nBase.(:(!=))\n\ndoc\"\"\"\n    @spawn\n\nCreates a closure around an expression and runs it on an automatically-chosen process, returning a `RemoteRef` to the result.\n\"\"\"\n:@spawn\n\ndoc\"\"\"\n    findfirst(A)\n\nReturn the index of the first non-zero value in `A` (determined by `A[i]!=0`).\n\"\"\"\nfindfirst(A)\n\ndoc\"\"\"\n    findfirst(A,v)\n\nReturn the index of the first element equal to `v` in `A`.\n\"\"\"\nfindfirst(A,v)\n\ndoc\"\"\"\n    findfirst(predicate, A)\n\nReturn the index of the first element of `A` for which `predicate` returns `true`.\n\"\"\"\nfindfirst\n\ndoc\"\"\"\n    factorize(A)\n\nCompute a convenient factorization (including LU, Cholesky, Bunch-Kaufman, LowerTriangular, UpperTriangular) of `A`, based upon the type of the input matrix. The return value can then be reused for efficient solving of multiple systems. For example: `A=factorize(A); x=A\\b; y=A\\C`.\n\"\"\"\nfactorize\n\ndoc\"\"\"\n    promote_rule(type1, type2)\n\nSpecifies what type should be used by `promote` when given values of types `type1` and `type2`. This function should not be called directly, but should have definitions added to it for new types as appropriate.\n\"\"\"\npromote_rule\n\ndoc\"\"\"\n    mtime(file)\n\nEquivalent to `stat(file).mtime`\n\"\"\"\nmtime\n\ndoc\"\"\"\n    logspace(start, stop, n=50)\n\nConstruct a vector of `n` logarithmically spaced numbers from `10^start` to `10^stop`.\n\"\"\"\nlogspace\n\ndoc\"\"\"\n    @gensym\n\nGenerates a gensym symbol for a variable. For example, `@gensym x y` is transformed into `x = gensym(\"x\"); y = gensym(\"y\")`.\n\"\"\"\n:@gensym\n\ndoc\"\"\"\n    sumabs2(itr)\n\nSum squared absolute values of all elements in a collection. This is equivalent to `sum(abs2(itr))` but faster.\n\"\"\"\nsumabs2(itr)\n\ndoc\"\"\"\n    sumabs2(A, dims)\n\nSum squared absolute values of elements of an array over the given dimensions.\n\"\"\"\nsumabs2(A,dims)\n\ndoc\"\"\"\n```rst\n..  uperm(file)\n\nGets the permissions of the owner of the file as a bitfield of\n\n==== =====================\n 01   Execute Permission\n 02   Write Permission\n 04   Read Permission\n==== =====================\n\nFor allowed arguments, see ``stat``.\n```\n\"\"\"\nuperm\n\ndoc\"\"\"\n    run(command)\n\nRun a command object, constructed with backticks. Throws an error if anything goes wrong, including the process exiting with a non-zero status.\n\"\"\"\nrun\n\ndoc\"\"\"\n    showall(x)\n\nSimilar to `show`, except shows all elements of arrays.\n\"\"\"\nshowall\n\ndoc\"\"\"\n    mimewritable(mime, x)\n\nReturns a boolean value indicating whether or not the object `x` can be written as the given `mime` type. (By default, this is determined automatically by the existence of the corresponding `writemime` function for `typeof(x)`.)\n\"\"\"\nmimewritable\n\ndoc\"\"\"\n    vecdot(x, y)\n\nFor any iterable containers `x` and `y` (including arrays of any dimension) of numbers (or any element type for which `dot` is defined), compute the Euclidean dot product (the sum of `dot(x[i],y[i])`) as if they were vectors.\n\"\"\"\nvecdot\n\ndoc\"\"\"\n    isprime(x::Integer) -> Bool\n\nReturns `true` if `x` is prime, and `false` otherwise.\n\n```jldoctest\njulia> isprime(3)\ntrue\n```\n\"\"\"\nisprime(::Integer)\n\ndoc\"\"\"\n    isprime(x::BigInt, [reps = 25]) -> Bool\n\nProbabilistic primality test. Returns `true` if `x` is prime; and\n`false` if `x` is not prime with high probability. The false positive\nrate is about `0.25^reps`. `reps = 25` is considered safe for\ncryptographic applications (Knuth, Seminumerical Algorithms).\n\n```jldoctest\njulia> isprime(big(3))\ntrue\n```\n\"\"\"\nisprime(::BigInt, ?)\n\ndoc\"\"\"\n    >(x, y)\n\nGreater-than comparison operator. Generally, new types should implement `<` instead of this function, and rely on the fallback definition `>(x,y) = y<x`.\n\"\"\"\nBase.(:(>))\n\ndoc\"\"\"\n    match(r::Regex, s::AbstractString[, idx::Integer[, addopts]])\n\nSearch for the first match of the regular expression `r` in `s` and return a `RegexMatch` object containing the match, or nothing if the match failed. The matching substring can be retrieved by accessing `m.match` and the captured sequences can be retrieved by accessing `m.captures` The optional `idx` argument specifies an index at which to start the search.\n\"\"\"\nmatch\n\ndoc\"\"\"\n    nprocs()\n\nGet the number of available processes.\n\"\"\"\nnprocs\n\ndoc\"\"\"\n    Ac_mul_B(A, B)\n\nFor matrices or vectors $A$ and $B$, calculates $A\u1d34\u22c5B$\n\"\"\"\nAc_mul_B\n\ndoc\"\"\"\n```rst\n..  qrfact!(A [,pivot=Val{false}])\n\n``qrfact!`` is the same as :func:`qrfact` when ``A`` is a subtype of ``StridedMatrix``, but saves space by overwriting the input ``A``, instead of creating a copy.\n```\n\"\"\"\nqrfact!\n\ndoc\"\"\"\n    At_rdiv_B(A, B)\n\nFor matrices or vectors $A$ and $B$, calculates $A\u1d40 / B$\n\"\"\"\nAt_rdiv_B\n\ndoc\"\"\"\n    coth(x)\n\nCompute the hyperbolic cotangent of `x`\n\"\"\"\ncoth\n\ndoc\"\"\"\n    conj(z)\n\nCompute the complex conjugate of a complex number `z`\n\"\"\"\nconj\n\ndoc\"\"\"\n    conj!(A)\n\nConvert an array to its complex conjugate in-place\n\"\"\"\nconj!\n\ndoc\"\"\"\n    start(iter) -> state\n\nGet initial iteration state for an iterable object\n\"\"\"\nstart\n\ndoc\"\"\"\n    div(x, y)\n    \u00f7(x, y)\n\nThe quotient from Euclidean division. Computes `x/y`, truncated to an integer.\n\"\"\"\ndiv\n\ndoc\"\"\"\n    relpath(path::AbstractString, startpath::AbstractString = \".\") -> AbstractString\n\nReturn a relative filepath to path either from the current directory or from an optional start directory. This is a path computation: the filesystem is not accessed to confirm the existence or nature of path or startpath.\n\"\"\"\nrelpath\n\ndoc\"\"\"\n    readavailable(stream)\n\nRead all available data on the stream, blocking the task only if no data is available. The result is a `Vector{UInt8,1}`.\n\"\"\"\nreadavailable\n\ndoc\"\"\"\n    remotecall(id, func, args...)\n\nCall a function asynchronously on the given arguments on the specified process. Returns a `RemoteRef`.\n\"\"\"\nremotecall\n\ndoc\"\"\"\n    slicedim(A, d, i)\n\nReturn all the data of `A` where the index for dimension `d` equals `i`. Equivalent to `A[:,:,...,i,:,:,...]` where `i` is in position `d`.\n\"\"\"\nslicedim\n\ndoc\"\"\"\n    isa(x, type) -> Bool\n\nDetermine whether `x` is of the given `type`.\n\"\"\"\nisa\n\ndoc\"\"\"\n    <=(x, y)\n    \u2264(x,y)\n\nLess-than-or-equals comparison operator.\n\"\"\"\nBase.(:(<=))\n\ndoc\"\"\"\n    ProcessExitedException()\n\nAfter a client Julia process has exited, further attempts to reference the dead child will throw this exception.\n\"\"\"\nProcessExitedException\n\ndoc\"\"\"\n    unsafe_load(p::Ptr{T},i::Integer)\n\nLoad a value of type `T` from the address of the ith element (1-indexed) starting at `p`. This is equivalent to the C expression `p[i-1]`.\n\nThe `unsafe` prefix on this function indicates that no validation is performed on the pointer `p` to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.\n\"\"\"\nunsafe_load\n\ndoc\"\"\"\n    catch_backtrace()\n\nGet the backtrace of the current exception, for use within `catch` blocks.\n\"\"\"\ncatch_backtrace\n\ndoc\"\"\"\n    airyx(k,x)\n\nscaled `k`th derivative of the Airy function, return $\\operatorname{Ai}(x) e^{\\frac{2}{3} x \\sqrt{x}}$\nfor `k == 0 || k == 1`, and $\\operatorname{Ai}(x) e^{- \\left| \\operatorname{Re} \\left( \\frac{2}{3} x \\sqrt{x} \\right) \\right|}$\nfor `k == 2 || k == 3`.\n\"\"\"\nairyx\n\ndoc\"\"\"\n    get_zero_subnormals() -> Bool\n\nReturns `false` if operations on subnormal floating-point values (\"denormals\") obey rules for IEEE arithmetic, and ``true`` if they might be converted to zeros.\n\"\"\"\nget_zero_subnormals\n\ndoc\"\"\"\n    cos(x)\n\nCompute cosine of `x`, where `x` is in radians\n\"\"\"\ncos\n\ndoc\"\"\"\n    base64encode(writefunc, args...)\n    base64encode(args...)\n\nGiven a `write`-like function `writefunc`, which takes an I/O stream as its first argument, `base64(writefunc, args...)` calls `writefunc` to write `args...` to a base64-encoded string, and returns the string. `base64(args...)` is equivalent to `base64(write, args...)`: it converts its arguments into bytes using the standard `write` functions and returns the base64-encoded string.\n\"\"\"\nbase64encode\n\ndoc\"\"\"\n    Condition()\n\nCreate an edge-triggered event source that tasks can wait for. Tasks that call `wait` on a `Condition` are suspended and queued. Tasks are woken up when `notify` is later called on the `Condition`. Edge triggering means that only tasks waiting at the time `notify` is called can be woken up. For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The `Channel` type does this, and so can be used for level-triggered events.\n\"\"\"\nCondition\n\ndoc\"\"\"\n```rst\n..  filt!(out, b, a, x, [si])\n\nSame as :func:`filt` but writes the result into the ``out`` argument,\nwhich may alias the input ``x`` to modify it in-place.\n```\n\"\"\"\nfilt!\n\ndoc\"\"\"\n    ascii(::Array{UInt8,1})\n\nCreate an ASCII string from a byte array.\n\"\"\"\nascii(::Vector{UInt8})\n\ndoc\"\"\"\n    ascii(s)\n\nConvert a string to a contiguous ASCII string (all characters must be valid ASCII characters).\n\"\"\"\nascii(s)\n\ndoc\"\"\"\n    ascii(::Ptr{UInt8}, [length])\n\nCreate an ASCII string from the address of a C (0-terminated) string encoded in ASCII. A copy is made; the ptr can be safely freed. If `length` is specified, the string does not have to be 0-terminated.\n\"\"\"\nascii(::Ptr{UInt8},?)\n\ndoc\"\"\"\n    maxabs(itr)\n\nCompute the maximum absolute value of a collection of values.\n\"\"\"\nmaxabs(itr)\n\ndoc\"\"\"\n    maxabs(A, dims)\n\nCompute the maximum absolute values over given dimensions.\n\"\"\"\nmaxabs(A,dims)\n\ndoc\"\"\"\n    done(iter, state) -> Bool\n\nTest whether we are done iterating\n\"\"\"\ndone\n\ndoc\"\"\"\n```rst\n..  convert(T, x)\n\nConvert ``x`` to a value of type ``T``.\n\nIf ``T`` is an ``Integer`` type, an :exc:`InexactError` will be raised if\n``x`` is not representable by ``T``, for example if ``x`` is not\ninteger-valued, or is outside the range supported by ``T``.\n\n.. doctest::\n\n   julia> convert(Int, 3.0)\n   3\n\n   julia> convert(Int, 3.5)\n   ERROR: InexactError()\n    in convert at int.jl:209\n\nIf ``T`` is a :obj:`AbstractFloat` or :obj:`Rational` type, then it will return\nthe closest value to ``x`` representable by ``T``.\n\n.. doctest::\n\n   julia> x = 1/3\n   0.3333333333333333\n\n   julia> convert(Float32, x)\n   0.33333334f0\n\n   julia> convert(Rational{Int32}, x)\n   1//3\n\n   julia> convert(Rational{Int64}, x)\n   6004799503160661//18014398509481984\n```\n\"\"\"\nconvert\n\ndoc\"\"\"\n    A_ldiv_Bt(A, B)\n\nFor matrices or vectors $A$ and $B$, calculates $A$ \\ $B\u1d40$\n\"\"\"\nA_ldiv_Bt\n\ndoc\"\"\"\n    applicable(f, args...) -> Bool\n\nDetermine whether the given generic function has a method applicable to the given arguments.\n\n```jldoctest\njulia> function f(x, y)\n           x + y\n       end;\n\njulia> applicable(f, 1)\nfalse\n\njulia> applicable(f, 1, 2)\ntrue\n```\n\"\"\"\napplicable\n\ndoc\"\"\"\n    xdump(x)\n\nShow all structure of a value, including all fields of objects.\n\"\"\"\nxdump\n\ndoc\"\"\"\n    Base.process_messages(instrm::AsyncStream, outstrm::AsyncStream)\n\nCalled by cluster managers using custom transports. It should be called when the custom transport implementation receives the first message from a remote worker. The custom transport must manage a logical connection to the remote worker and provide two `AsyncStream` objects, one for incoming messages and the other for messages addressed to the remote worker.\n\"\"\"\nBase.process_messages\n\ndoc\"\"\"\n    RandomDevice()\n\nCreate a `RandomDevice` RNG object. Two such objects will always generate different streams of random numbers.\n\"\"\"\nRandomDevice\n\ndoc\"\"\"\n    fma(x, y, z)\n\nComputes `x*y+z` without rounding the intermediate result `x*y`. On some systems this is significantly more expensive than `x*y+z`. `fma` is used to improve accuracy in certain algorithms. See `muladd`.\n\"\"\"\nfma\n\ndoc\"\"\"\n\n    eigvals(A,[irange,][vl,][vu]) -> values\n\nReturns the eigenvalues of `A`. If `A` is `Symmetric`, `Hermitian` or `SymTridiagonal`,\nit is possible to calculate only a subset of the eigenvalues by specifying either a\n`UnitRange` `irange` covering indices of the sorted eigenvalues, or a pair `vl` and `vu`\nfor the lower and upper boundaries of the eigenvalues.\n\nFor general non-symmetric matrices it is possible to specify how the matrix is balanced\nbefore the eigenvector calculation. The option `permute=true` permutes the matrix to\nbecome closer to upper triangular, and `scale=true` scales the matrix by its diagonal\nelements to make rows and columns moreequal in norm. The default is `true` for both\noptions.\n\"\"\"\neigvals\n\ndoc\"\"\"\n    A_ldiv_Bc(A, B)\n\nFor matrices or vectors $A$ and $B$, calculates $A$ \\ $B\u1d34$\n\"\"\"\nA_ldiv_Bc\n\ndoc\"\"\"\n```rst\n..  escape_string(str::AbstractString) -> AbstractString\n\nGeneral escaping of traditional C and Unicode escape sequences. See :func:`print_escaped` for more general escaping.\n```\n\"\"\"\nescape_string\n\ndoc\"\"\"\n    significand(x)\n\nExtract the `significand(s)` (a.k.a. mantissa), in binary representation, of\na floating-point number or array. If `x` is a non-zero finite number,\nthan the result will be a number of the same type on the interval\n$[1,2)$. Otherwise `x` is returned.\n\n```jldoctest\njulia> significand(15.2)/15.2\n0.125\n\njulia> significand(15.2)*8\n15.2\n```\n\"\"\"\nsignificand\n\ndoc\"\"\"\n    pointer_from_objref(object_instance)\n\nGet the memory address of a Julia object as a `Ptr`. The existence of the resulting `Ptr` will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the `Ptr` will be used.\n\"\"\"\npointer_from_objref\n\ndoc\"\"\"\n    cumsum_kbn(A, [dim])\n\nCumulative sum along a dimension, using the Kahan-Babuska-Neumaier compensated summation algorithm for additional accuracy. The dimension defaults to 1.\n\"\"\"\ncumsum_kbn\n\ndoc\"\"\"\n    cmp(x,y)\n\nReturn -1, 0, or 1 depending on whether `x` is less than, equal to, or greater than `y`, respectively. Uses the total order implemented by `isless`. For floating-point numbers, uses `<` but throws an error for unordered arguments.\n\"\"\"\ncmp\n\ndoc\"\"\"\n    tand(x)\n\nCompute tangent of `x`, where `x` is in degrees\n\"\"\"\ntand\n\ndoc\"\"\"\n    issorted(v, [by=<transform>,] [lt=<comparison>,] [rev=false])\n\nTest whether a vector is in sorted order. The `by`, `lt` and `rev` keywords modify what order is considered to be sorted just as they do for `sort`.\n\"\"\"\nissorted\n\ndoc\"\"\"\n    set_bigfloat_precision(x::Int64)\n\nSet the precision (in bits) to be used to `BigFloat` arithmetic.\n\"\"\"\nset_bigfloat_precision\n\ndoc\"\"\"\n    isbits(T)\n\nReturn `true` if `T` is a \"plain data\" type, meaning it is immutable and\ncontains no references to other values. Typical examples are numeric types such\nas `UInt8`, `Float64`, and `Complex{Float64}`.\n\n```jldoctest\njulia> isbits(Complex{Float64})\ntrue\n\njulia> isbits(Complex)\nfalse\n```\n\"\"\"\nisbits\n\ndoc\"\"\"\n    findlast(A)\n\nReturn the index of the last non-zero value in `A` (determined by `A[i]!=0`).\n\"\"\"\nfindlast(A)\n\ndoc\"\"\"\n    findlast(A, v)\n\nReturn the index of the last element equal to `v` in `A`.\n\"\"\"\nfindlast(A,v)\n\ndoc\"\"\"\n    findlast(predicate, A)\n\nReturn the index of the last element of `A` for which `predicate` returns `true`.\n\"\"\"\nfindlast(::Function, A)\n\ndoc\"\"\"\n    @elapsed\n\nA macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute as a floating-point number.\n\"\"\"\n:@elapsed\n\ndoc\"\"\"\n    findnext(A, i)\n\nFind the next index >= `i` of a non-zero element of `A`, or `0` if not found.\n\"\"\"\nfindnext\n\ndoc\"\"\"\n    findnext(predicate, A, i)\n\nFind the next index >= `i` of an element of `A` for which `predicate` returns `true`, or `0` if not found.\n\"\"\"\nfindnext(::Function,A,i)\n\ndoc\"\"\"\n    findnext(A, v, i)\n\nFind the next index >= `i` of an element of `A` equal to `v` (using `==`), or `0` if not found.\n\"\"\"\nfindnext(A,v,i)\n\ndoc\"\"\"\n    fetch(x)\n\nWaits and fetches a value from `x` depending on the type of `x`. Does not remove the item fetched:\n\n* `RemoteRef`: Wait for and get the value of a remote reference. If the remote value is an exception, throws a `RemoteException` which captures the remote exception and backtrace.\n* `Channel` : Wait for and get the first available item from the channel.\n\"\"\"\nfetch\n\ndoc\"\"\"\n    angle(z)\n\nCompute the phase angle in radians of a complex number `z`\n\"\"\"\nangle\n\ndoc\"\"\"\n```rst\n..  tic()\n\nSet a timer to be read by the next call to :func:`toc` or :func:`toq`. The macro call ``@time expr`` can also be used to time evaluation.\n```\n\"\"\"\ntic\n\ndoc\"\"\"\n    LoadError(file::AbstractString, line::Int, error)\n\nAn error occurred while `include`ing, `require`ing, or `using` a file. The error specifics should be available in the `.error` field.\n\"\"\"\nLoadError\n\ndoc\"\"\"\n    InitError(mod::Symbol, error)\n\nAn error occurred when running a module's `__init__` function. The actual error thrown is available in the `.error` field.\n\"\"\"\nInitError\n\ndoc\"\"\"\n    vec(Array) -> Vector\n\nVectorize an array using column-major convention.\n\"\"\"\nvec\n\ndoc\"\"\"\n    copy!(dest, src)\n\nCopy all elements from collection `src` to array `dest`. Returns `dest`.\n\"\"\"\ncopy!(dest,src)\n\ndoc\"\"\"\n    copy!(dest, do, src, so, N)\n\nCopy `N` elements from collection `src` starting at offset `so`, to array `dest` starting at offset `do`. Returns `dest`.\n\"\"\"\ncopy!(dest,d,src,so,N)\n\ndoc\"\"\"\n    broadcast(f, As...)\n\nBroadcasts the arrays `As` to a common size by expanding singleton dimensions, and returns an array of the results `f(as...)` for each position.\n\"\"\"\nbroadcast\n\ndoc\"\"\"\n```rst\n..  eigvecs(A, [eigvals,][permute=true,][scale=true]) -> Matrix\n\nReturns a matrix ``M`` whose columns are the eigenvectors of ``A``.\n(The ``k``\\ th eigenvector can be obtained from the slice ``M[:, k]``.)\nThe ``permute`` and ``scale`` keywords are the same as for :func:`eigfact`.\n\nFor :class:`SymTridiagonal` matrices, if the optional vector of eigenvalues\n``eigvals`` is specified, returns the specific corresponding eigenvectors.\n```\n\"\"\"\neigvecs\n\ndoc\"\"\"\n    ntoh(x)\n\nConverts the endianness of a value from Network byte order (big-endian) to that used by the Host.\n\"\"\"\nntoh\n\ndoc\"\"\"\n```rst\n..  qrfact(A [,pivot=Val{false}]) -> F\n\nComputes the QR factorization of ``A``. The return type of ``F`` depends on the element type of ``A`` and whether pivoting is specified (with ``pivot==Val{true}``).\n\n================ ================= ============== =====================================\nReturn type      ``eltype(A)``     ``pivot``      Relationship between ``F`` and ``A``\n================ ================= ============== =====================================\n``QR``           not ``BlasFloat`` either          ``A==F[:Q]*F[:R]``\n``QRCompactWY``  ``BlasFloat``     ``Val{false}``  ``A==F[:Q]*F[:R]``\n``QRPivoted``    ``BlasFloat``     ``Val{true}``   ``A[:,F[:p]]==F[:Q]*F[:R]``\n================ ================= ============== =====================================\n\n``BlasFloat`` refers to any of: ``Float32``, ``Float64``, ``Complex64`` or ``Complex128``.\n\nThe individual components of the factorization ``F`` can be accessed by indexing:\n\n=========== ============================================= ================== ===================== ==================\nComponent   Description                                   ``QR``             ``QRCompactWY``       ``QRPivoted``\n=========== ============================================= ================== ===================== ==================\n``F[:Q]``   ``Q`` (orthogonal/unitary) part of ``QR``      \u2713 (``QRPackedQ``)  \u2713 (``QRCompactWYQ``)  \u2713 (``QRPackedQ``)\n``F[:R]``   ``R`` (upper right triangular) part of ``QR``  \u2713                  \u2713                     \u2713\n``F[:p]``   pivot ``Vector``                                                                        \u2713\n``F[:P]``   (pivot) permutation ``Matrix``                                                          \u2713\n=========== ============================================= ================== ===================== ==================\n\nThe following functions are available for the ``QR`` objects: ``size``, ``\\``. When ``A`` is rectangular, ``\\`` will return a least squares solution and if the solution is not unique, the one with smallest norm is returned.\n\nMultiplication with respect to either thin or full ``Q`` is allowed, i.e. both ``F[:Q]*F[:R]`` and ``F[:Q]*A`` are supported. A ``Q`` matrix can be converted into a regular matrix with :func:`full` which has a named argument ``thin``.\n\n.. note::\n\n   ``qrfact`` returns multiple types because LAPACK uses several representations that minimize the memory storage requirements of products of Householder elementary reflectors, so that the ``Q`` and ``R`` matrices can be stored compactly rather as two separate dense matrices.\n\n   The data contained in ``QR`` or ``QRPivoted`` can be used to construct the ``QRPackedQ`` type, which is a compact representation of the rotation matrix:\n\n   .. math::\n\n      Q = \\prod_{i=1}^{\\min(m,n)} (I - \\tau_i v_i v_i^T)\n\n   where :math:`\\tau_i` is the scale factor and :math:`v_i` is the projection vector associated with the :math:`i^{th}` Householder elementary reflector.\n\n   The data contained in ``QRCompactWY`` can be used to construct the ``QRCompactWYQ`` type, which is a compact representation of the rotation matrix\n\n   .. math::\n\n      Q = I + Y T Y^T\n\n   where ``Y`` is :math:`m \\times r` lower trapezoidal and ``T`` is :math:`r \\times r` upper triangular. The *compact WY* representation [Schreiber1989]_ is not to be confused with the older, *WY* representation [Bischof1987]_. (The LAPACK documentation uses ``V`` in lieu of ``Y``.)\n\n.. [Bischof1987] C Bischof and C Van Loan, \"The WY representation for products\n   of Householder matrices\", SIAM J Sci Stat Comput 8 (1987), s2-s13.\n   `doi:10.1137/0908009 <http://dx.doi.org/10.1137/0908009>`_\n.. [Schreiber1989] R Schreiber and C Van Loan, \"A storage-efficient WY\n   representation for products of Householder transformations\",\n   SIAM J Sci Stat Comput 10 (1989), 53-57.\n   `doi:10.1137/0910005 <http://dx.doi.org/10.1137/0910005>`_\n```\n\"\"\"\nqrfact(A,?)\n\n\ndoc\"\"\"\n```rst\n..  qrfact(A) -> SPQR.Factorization\n\nCompute the QR factorization of a sparse matrix ``A``. A fill-reducing permutation is used. The main application of this type is to solve least squares problems with ``\\``. The function calls the C library SPQR and a few additional functions from the library are wrapped but not exported.\n```\n\"\"\"\nqrfact(A)\n\ndoc\"\"\"\n    +(x, y...)\n\nAddition operator. `x+y+z+...` calls this function with all arguments, i.e. `+(x, y, z, ...)`.\n\"\"\"\n+\n\ndoc\"\"\"\n    identity(x)\n\nThe identity function. Returns its argument.\n\"\"\"\nidentity\n\ndoc\"\"\"\n    iseven(x::Integer) -> Bool\n\nReturns `true` is `x` is even (that is, divisible by 2), and `false` otherwise.\n\n```jldoctest\njulia> iseven(9)\nfalse\n\njulia> iseven(10)\ntrue\n```\n\"\"\"\niseven\n\ndoc\"\"\"\n    setindex!(A, X, inds...)\n\nStore values from array `X` within some subset of `A` as specified by `inds`.\n\"\"\"\nsetindex!(A::AbstractArray,X,inds...)\n\ndoc\"\"\"\n    setindex!(collection, value, key...)\n\nStore the given value at the given key or index within a collection. The syntax `a[i,j,...] = x` is converted by the compiler to `(setindex!(a, x, i, j, ...); x)`.\n\"\"\"\nsetindex!(collection,value,key...)\n\ndoc\"\"\"\n    signif(x, digits, [base])\n\nRounds (in the sense of `round`) `x` so that there are `digits` significant digits, under a base `base` representation, default 10. E.g., `signif(123.456, 2)` is `120.0`, and `signif(357.913, 4, 2)` is `352.0`.\n\"\"\"\nsignif\n\ndoc\"\"\"\n    nextpow2(n)\n\nThe smallest power of two not less than `n`. Returns 0 for `n==0`, and returns `-nextpow2(-n)` for negative arguments.\n\"\"\"\nnextpow2\n\ndoc\"\"\"\n    ipermute!(v, p)\n\nLike permute!, but the inverse of the given permutation is applied.\n\"\"\"\nipermute!\n\ndoc\"\"\"\n```rst\n..  full(S)\n\nConvert a sparse matrix ``S`` into a dense matrix.\n```\n\"\"\"\nfull(::AbstractSparseMatrix)\n\ndoc\"\"\"\n```rst\n..  full(F)\n\nReconstruct the matrix ``A`` from the factorization ``F=factorize(A)``.\n```\n\"\"\"\nfull(F)\n\ndoc\"\"\"\n```rst\n..  full(QRCompactWYQ[, thin=true]) -> Matrix\n\nConverts an orthogonal or unitary matrix stored as a ``QRCompactWYQ``\nobject, i.e. in the compact WY format [Bischof1987]_, to a dense matrix.\n\nOptionally takes a ``thin`` Boolean argument, which if ``true`` omits the\ncolumns that span the rows of ``R`` in the QR factorization that are zero.\nThe resulting matrix is the ``Q`` in a thin QR factorization (sometimes\ncalled the reduced QR factorization).  If ``false``, returns a ``Q`` that\nspans all rows of ``R`` in its corresponding QR factorization.\n```\n\"\"\"\nfull(::LinAlg.QRCompactWYQ, ?)\n\ndoc\"\"\"\n    map(f, c...) -> collection\n\nTransform collection `c` by applying `f` to each element.\nFor multiple collection arguments, apply `f` elementwise.\n\n```jldoctest\njulia> map((x) -> x * 2, [1, 2, 3])\n3-element Array{Int64,1}:\n 2\n 4\n 6\n\njulia> map(+, [1, 2, 3], [10, 20, 30])\n3-element Array{Int64,1}:\n 11\n 22\n 33\n```\n\"\"\"\nmap\n\ndoc\"\"\"\n    @parallel\n\nA parallel for loop of the form :\n\n    @parallel [reducer] for var = range\n        body\n    end\n\nThe specified range is partitioned and locally executed across all workers. In case an optional reducer function is specified, `@parallel` performs local reductions on each worker with a final reduction on the calling process.\n\nNote that without a reducer function, `@parallel` executes asynchronously, i.e. it spawns independent tasks on all available workers and returns immediately without waiting for completion. To wait for completion, prefix the call with `@sync`, like :\n\n    @sync @parallel for var = range\n        body\n    end\n\"\"\"\n:@parallel\n\ndoc\"\"\"\n    throw(e)\n\nThrow an object as an exception\n\"\"\"\nthrow\n\ndoc\"\"\"\n    isxdigit(c::Union{Char,AbstractString}) -> Bool\n\nTests whether a character is a valid hexadecimal digit, or whether this is true for all elements of a string.\n\"\"\"\nisxdigit\n\ndoc\"\"\"\n    fill(x, dims)\n\nCreate an array filled with the value `x`. For example, `fill(1.0, (10,10))` returns a 10x10 array of floats, with each element initialized to `1.0`.\n\nIf `x` is an object reference, all elements will refer to the same object. `fill(Foo(), dims)` will return an array filled with the result of evaluating `Foo()` once.\n\"\"\"\nfill\n\ndoc\"\"\"\n    rol!(dest::BitArray{1}, src::BitArray{1}, i::Integer) -> BitArray{1}\n\nPerforms a left rotation operation on `src` and put the result into `dest`.\n\"\"\"\nrol!(::BitArray,::BitArray,::Integer)\n\ndoc\"\"\"\n    rol!(B::BitArray{1}, i::Integer) -> BitArray{1}\n\nPerforms a left rotation operation on `B`.\n\"\"\"\nrol!(::BitArray,::Integer)\n\ndoc\"\"\"\n```rst\n..  issubset(a, b)\n           \u2286(a,b) -> Bool\n           \u2288(a,b) -> Bool\n           \u228a(a,b) -> Bool\n\nDetermine whether every element of ``a`` is also in ``b``, using :func:`in`.\n```\n\"\"\"\nissubset(a,b)\n\ndoc\"\"\"\n```rst\n..  issubset(A, S) -> Bool\n             \u2286(A,S) -> Bool\n\nReturn ``true`` if ``A`` is a subset of or equal to ``S``.\n```\n\"\"\"\nissubset\n\ndoc\"\"\"\n    istriu(A) -> Bool\n\nTest whether a matrix is upper triangular.\n\"\"\"\nistriu\n\ndoc\"\"\"\n```rst\n..  map!(function, collection)\n\nIn-place version of :func:`map`.\n```\n\"\"\"\nmap!(f,collection)\n\ndoc\"\"\"\n```rst\n..  map!(function, destination, collection...)\n\nLike :func:`map`, but stores the result in ``destination`` rather than a\nnew collection. ``destination`` must be at least as large as the first\ncollection.\n```\n\"\"\"\nmap!(f,destination,collection...)\n\ndoc\"\"\"\n```rst\n..  unescape_string(s::AbstractString) -> AbstractString\n\nGeneral unescaping of traditional C and Unicode escape sequences. Reverse of :func:`escape_string`. See also :func:`print_unescaped`.\n```\n\"\"\"\nunescape_string\n\ndoc\"\"\"\n    redirect_stdout()\n\nCreate a pipe to which all C and Julia level `STDOUT` output will be redirected. Returns a tuple `(rd,wr)` representing the pipe ends. Data written to `STDOUT` may now be read from the rd end of the pipe. The wr end is given for convenience in case the old `STDOUT` object was cached by the user and needs to be replaced elsewhere.\n\"\"\"\nredirect_stdout\n\ndoc\"\"\"\n    redirect_stdout(stream)\n\nReplace `STDOUT` by stream for all C and julia level output to `STDOUT`. Note that `stream` must be a TTY, a `Pipe` or a `TCPSocket`.\n\"\"\"\nredirect_stdout(stream)\n\ndoc\"\"\"\n    print_with_color(color::Symbol, [io], strings...)\n\nPrint strings in a color specified as a symbol, for example `:red` or `:blue`.\n\"\"\"\nprint_with_color\n\ndoc\"\"\"\n    stringmime(mime, x)\n\nReturns an `AbstractString` containing the representation of `x` in the requested `mime` type. This is similar to `reprmime` except that binary data is base64-encoded as an ASCII string.\n\"\"\"\nstringmime\n\ndoc\"\"\"\n    ischardev(path) -> Bool\n\nReturns `true` if `path` is a character device, `false` otherwise.\n\"\"\"\nischardev\n\ndoc\"\"\"\n    zero(x)\n\nGet the additive identity element for the type of `x` (`x` can also specify the type itself).\n\"\"\"\nzero\n\ndoc\"\"\"\n    any(itr) -> Bool\n\nTest whether any elements of a boolean collection are `true`.\n\"\"\"\nany(itr)\n\ndoc\"\"\"\n    any(A, dims)\n\nTest whether any values along the given dimensions of an array are `true`.\n\"\"\"\nany(::AbstractArray,dims)\n\ndoc\"\"\"\n    any(p, itr) -> Bool\n\nDetermine whether predicate `p` returns `true` for any elements of `itr`.\n\"\"\"\nany(p,itr)\n\ndoc\"\"\"\n    cosc(x)\n\nCompute $\\cos(\\pi x) / x - \\sin(\\pi x) / (\\pi x^2)$ if $x \\neq 0$, and $0$\nif $x = 0$. This is the derivative of `sinc(x)`.\n\"\"\"\ncosc\n\ndoc\"\"\"\n    getkey(collection, key, default)\n\nReturn the key matching argument `key` if one exists in `collection`, otherwise return `default`.\n\"\"\"\ngetkey\n\ndoc\"\"\"\n    At_ldiv_Bt(A, B)\n\nFor matrices or vectors $A$ and $B$, calculates $A\u1d40$ \\ $B\u1d40$\n\"\"\"\nAt_ldiv_Bt\n\ndoc\"\"\"\n    Ac_mul_Bc(A, B)\n\nFor matrices or vectors $A$ and $B$, calculates $A\u1d34 B\u1d34$\n\"\"\"\nAc_mul_Bc\n\ndoc\"\"\"\n    acotd(x)\n\nCompute the inverse cotangent of `x`, where the output is in degrees\n\"\"\"\nacotd\n\ndoc\"\"\"\n    zeros(type, dims)\n\nCreate an array of all zeros of specified type. The type defaults to Float64 if not specified.\n\"\"\"\nzeros(t,dims)\n\ndoc\"\"\"\n    zeros(A)\n\nCreate an array of all zeros with the same element type and shape as `A`.\n\"\"\"\nzeros(A)\n\ndoc\"\"\"\n    symbol(x...) -> Symbol\n\nCreate a `Symbol` by concatenating the string representations of the arguments together.\n\"\"\"\nsymbol\n\ndoc\"\"\"\n    zeta(s)\n\nRiemann zeta function $\\zeta(s)$.\n\"\"\"\nzeta(s)\n\ndoc\"\"\"\n    zeta(s, z)\n\nHurwitz zeta function $\\zeta(s, z)$.  (This is equivalent to\nthe Riemann zeta function $\\zeta(s)$ for the case of `z=1`.)\n\"\"\"\nzeta(s,z)\n\ndoc\"\"\"\n    A_mul_Bt(A, B)\n\nFor matrices or vectors $A$ and $B$, calculates $A\u22c5B\u1d40$\n\"\"\"\nA_mul_Bt\n\ndoc\"\"\"\n    vecnorm(A, [p])\n\nFor any iterable container `A` (including arrays of any dimension) of numbers (or any element type for which `norm` is defined), compute the `p`-norm (defaulting to `p=2`) as if `A` were a vector of the corresponding length.\n\nFor example, if `A` is a matrix and `p=2`, then this is equivalent to the Frobenius norm.\n\"\"\"\nvecnorm\n\ndoc\"\"\"\n    isvalid(value) -> Bool\n\nReturns `true` if the given value is valid for its type, which currently can be one of `Char`, `ASCIIString`, `UTF8String`, `UTF16String`, or `UTF32String`.\n\"\"\"\nisvalid(value)\n\ndoc\"\"\"\n    isvalid(T, value) -> Bool\n\nReturns `true` if the given value is valid for that type. Types currently can be `Char`, `ASCIIString`, `UTF8String`, `UTF16String`, or `UTF32String` Values for `Char` can be of type `Char` or `UInt32` Values for `ASCIIString` and `UTF8String` can be of that type, or `Vector{UInt8}` Values for `UTF16String` can be `UTF16String` or `Vector{UInt16}` Values for `UTF32String` can be `UTF32String`, `Vector{Char}` or `Vector{UInt32}`\n\"\"\"\nisvalid(T,value)\n\ndoc\"\"\"\n    isvalid(str, i)\n\nTells whether index `i` is valid for the given string\n\"\"\"\nisvalid(::AbstractString,i)\n\ndoc\"\"\"\n```rst\n..  esc(e::ANY)\n\nOnly valid in the context of an ``Expr`` returned from a macro. Prevents the macro hygiene pass from turning embedded variables into gensym variables. See the :ref:`man-macros`\nsection of the Metaprogramming chapter of the manual for more details and examples.\n```\n\"\"\"\nesc\n\ndoc\"\"\"\n    bitbroadcast(f, As...)\n\nLike `broadcast`, but allocates a `BitArray` to store the result, rather then an `Array`.\n\"\"\"\nbitbroadcast\n\ndoc\"\"\"\n    set_zero_subnormals(yes::Bool) -> Bool\n\nIf `yes` is `false`, subsequent floating-point operations follow rules for IEEE arithmetic on subnormal values (\"denormals\"). Otherwise, floating-point operations are permitted (but not required) to convert subnormal inputs or outputs to zero. Returns `true` unless `yes==true` but the hardware does not support zeroing of subnormal numbers.\n\n`set_zero_subnormals(true)` can speed up some computations on some hardware. However, it can break identities such as `(x-y==0) == (x==y)`.\n\"\"\"\nset_zero_subnormals\n\ndoc\"\"\"\n    take(iter, n)\n\nAn iterator that generates at most the first `n` elements of `iter`.\n\"\"\"\ntake\n\ndoc\"\"\"\n    combinations(array, n)\n\nGenerate all combinations of `n` elements from an indexable object. Because the number of combinations can be very large, this function returns an iterator object. Use `collect(combinations(array,n))` to get an array of all combinations.\n\"\"\"\ncombinations\n\ndoc\"\"\"\n    frexp(val)\n\nReturn `(x,exp)` such that `x` has a magnitude in the interval $[1/2, 1)$ or 0,\nand val = $x \\times 2^{exp}$.\n\"\"\"\nfrexp\n\ndoc\"\"\"\n    sortcols(A, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])\n\nSort the columns of matrix `A` lexicographically.\n\"\"\"\nsortcols\n\ndoc\"\"\"\n    rsplit(string, [chars]; limit=0, keep=true)\n\nSimilar to `split`, but starting from the end of the string.\n\"\"\"\nrsplit\n\ndoc\"\"\"\n    trace(M)\n\nMatrix trace\n\"\"\"\ntrace\n\ndoc\"\"\"\n    runtests([tests=[\"all\"] [, numcores=iceil(CPU_CORES/2) ]])\n\nRun the Julia unit tests listed in `tests`, which can be either a string or an array of strings, using `numcores` processors. (not exported)\n\"\"\"\nruntests\n\ndoc\"\"\"\n    time_ns()\n\nGet the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.\n\"\"\"\ntime_ns\n\ndoc\"\"\"\n    exponent(x) -> Int\n\nGet the exponent of a normalized floating-point number.\n\"\"\"\nexponent\n\ndoc\"\"\"\n    rsearchindex(string, substring, [start])\n\nSimilar to `rsearch`, but return only the start index at which the substring is found, or `0` if it is not.\n\"\"\"\nrsearchindex\n\ndoc\"\"\"\n    muladd(x, y, z)\n\nCombined multiply-add, computes `x*y+z` in an efficient manner. This may on some systems be equivalent to `x*y+z`, or to `fma(x,y,z)`. `muladd` is used to improve performance. See `fma`.\n\"\"\"\nmuladd\n\ndoc\"\"\"\n    unsigned(x) -> Unsigned\n\nConvert a number to an unsigned integer. If the argument is signed, it is reinterpreted as unsigned without checking for negative values.\n\"\"\"\nunsigned\n\ndoc\"\"\"\n```rst\n..  eigfact(A,[irange,][vl,][vu,][permute=true,][scale=true]) -> Eigen\n\nComputes the eigenvalue decomposition of ``A``, returning an ``Eigen``\nfactorization object ``F`` which contains the eigenvalues in ``F[:values]``\nand the eigenvectors in the columns of the matrix ``F[:vectors]``.\n(The ``k``\\ th eigenvector can be obtained from the slice ``F[:vectors][:, k]``.)\n\nThe following functions are available for ``Eigen`` objects: ``inv``,\n``det``.\n\nIf ``A`` is :class:`Symmetric`, :class:`Hermitian` or :class:`SymTridiagonal`,\nit is possible to calculate only a subset of the eigenvalues by specifying\neither a :class:`UnitRange` ``irange`` covering indices of the sorted\neigenvalues or a pair ``vl`` and ``vu`` for the lower and upper boundaries\nof the eigenvalues.\n\nFor general nonsymmetric matrices it is possible to specify how the matrix\nis balanced before the eigenvector calculation. The option ``permute=true``\npermutes the matrix to become closer to upper triangular, and ``scale=true``\nscales the matrix by its diagonal elements to make rows and columns more\nequal in norm. The default is ``true`` for both options.\n```\n\"\"\"\neigfact(A,?,?,?,?)\n\ndoc\"\"\"\n```rst\n..  eigfact(A, B) -> GeneralizedEigen\n\nComputes the generalized eigenvalue decomposition of ``A`` and ``B``,\nreturning a ``GeneralizedEigen`` factorization object ``F`` which contains\nthe generalized eigenvalues in ``F[:values]`` and the generalized\neigenvectors in the columns of the matrix ``F[:vectors]``. (The ``k``\\ th\ngeneralized eigenvector can be obtained from the slice ``F[:vectors][:,\nk]``.)\n```\n\"\"\"\neigfact(A,B)\n\ndoc\"\"\"\n    rowvals(A)\n\nReturn a vector of the row indices of `A`, and any modifications to the returned vector will mutate `A` as well. Given the internal storage format of sparse matrices, providing access to how the row indices are stored internally can be useful in conjunction with iterating over structural nonzero values. See `nonzeros(A)` and `nzrange(A, col)`.\n\"\"\"\nrowvals\n\ndoc\"\"\"\n    mkdir(path, [mode])\n\nMake a new directory with name `path` and permissions `mode`. `mode` defaults to 0o777, modified by the current file creation mask.\n\"\"\"\nmkdir\n\ndoc\"\"\"\n    bytestring(::Ptr{UInt8}, [length])\n\nCreate a string from the address of a C (0-terminated) string encoded in ASCII or UTF-8. A copy is made; the ptr can be safely freed. If `length` is specified, the string does not have to be 0-terminated.\n\"\"\"\nbytestring(::Ptr{UInt8},?)\n\ndoc\"\"\"\n    bytestring(s)\n\nConvert a string to a contiguous byte array representation appropriate for passing it to C functions. The string will be encoded as either ASCII or UTF-8.\n\"\"\"\nbytestring(s)\n\ndoc\"\"\"\n    midpoints(e)\n\nCompute the midpoints of the bins with edges `e`. The result is a vector/range of length `length(e) - 1`. Note: Julia does not ignore `NaN` values in the computation.\n\"\"\"\nmidpoints\n\ndoc\"\"\"\n    .+(x, y)\n\nElement-wise addition operator.\n\"\"\"\nBase.(:(.+))\n\ndoc\"\"\"\n    reverseind(v, i)\n\nGiven an index `i` in `reverse(v)`, return the corresponding index in `v` so that `v[reverseind(v,i)] == reverse(v)[i]`. (This can be nontrivial in the case where `v` is a Unicode string.)\n\"\"\"\nreverseind\n\ndoc\"\"\"\n    nan(f)\n\nReturns NaN (not-a-number) of the floating point type `f` or of the same floating point type as `f`\n\"\"\"\nnan\n\ndoc\"\"\"\n    float(x)\n\nConvert a number, array, or string to a `AbstractFloat` data type. For numeric data, the smallest suitable `AbstractFloat` type is used. Converts strings to `Float64`.\n\"\"\"\nfloat\n\ndoc\"\"\"\n    include_dependency(path::AbstractString)\n\nIn a module, declare that the file specified by `path` (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.\n\nThis is only needed if your module depends on a file that is not used via `include`. It has no effect outside of compilation.\n\"\"\"\ninclude_dependency\n\ndoc\"\"\"\n    randn!([rng], A::Array{Float64,N})\n\nFill the array `A` with normally-distributed (mean 0, standard deviation 1) random numbers. Also see the rand function.\n\"\"\"\nrandn!\n\ndoc\"\"\"\n    ldexp(x, n)\n\nCompute $x \\times 2^n$.\n\"\"\"\nldexp\n\ndoc\"\"\"\n    quadgk(f, a,b,c...; reltol=sqrt(eps), abstol=0, maxevals=10^7, order=7, norm=vecnorm)\n\nNumerically integrate the function `f(x)` from `a` to `b`, and optionally over additional intervals `b` to `c` and so on. Keyword options include a relative error tolerance `reltol` (defaults to `sqrt(eps)` in the precision of the endpoints), an absolute error tolerance `abstol` (defaults to 0), a maximum number of function evaluations `maxevals` (defaults to `10^7`), and the `order` of the integration rule (defaults to 7).\n\nReturns a pair `(I,E)` of the estimated integral `I` and an estimated upper bound on the absolute error `E`. If `maxevals` is not exceeded then `E <= max(abstol, reltol*norm(I))` will hold. (Note that it is useful to specify a positive `abstol` in cases where `norm(I)` may be zero.)\n\nThe endpoints `a` etcetera can also be complex (in which case the integral is performed over straight-line segments in the complex plane). If the endpoints are `BigFloat`, then the integration will be performed in `BigFloat` precision as well (note: it is advisable to increase the integration `order` in rough proportion to the precision, for smooth integrands). More generally, the precision is set by the precision of the integration endpoints (promoted to floating-point types).\n\nThe integrand `f(x)` can return any numeric scalar, vector, or matrix type, or in fact any type supporting `+`, `-`, multiplication by real values, and a `norm` (i.e., any normed vector space). Alternatively, a different norm can be specified by passing a `norm`-like function as the `norm` keyword argument (which defaults to `vecnorm`).\n\n\\[Only one-dimensional integrals are provided by this function. For multi-dimensional integration (cubature), there are many different algorithms (often much better than simple nested 1d integrals) and the optimal choice tends to be very problem-dependent. See the Julia external-package listing for available algorithms for multidimensional integration or other specialized tasks (such as integrals of highly oscillatory or singular functions).\\]\n\nThe algorithm is an adaptive Gauss-Kronrod integration technique: the integral in each interval is estimated using a Kronrod rule (`2*order+1` points) and the error is estimated using an embedded Gauss rule (`order` points). The interval with the largest error is then subdivided into two intervals and the process is repeated until the desired error tolerance is achieved.\n\nThese quadrature rules work best for smooth functions within each interval, so if your function has a known discontinuity or other singularity, it is best to subdivide your interval to put the singularity at an endpoint. For example, if `f` has a discontinuity at `x=0.7` and you want to integrate from 0 to 1, you should use `quadgk(f, 0,0.7,1)` to subdivide the interval at the point of discontinuity. The integrand is never evaluated exactly at the endpoints of the intervals, so it is possible to integrate functions that diverge at the endpoints as long as the singularity is integrable (for example, a `log(x)` or `1/sqrt(x)` singularity).\n\nFor real-valued endpoints, the starting and/or ending points may be infinite. (A coordinate transformation is performed internally to map the infinite interval to a finite one.)\n\"\"\"\nquadgk\n\ndoc\"\"\"\n    hist(v[, n]) -> e, counts\n\nCompute the histogram of `v`, optionally using approximately `n` bins. The return values are a range `e`, which correspond to the edges of the bins, and `counts` containing the number of elements of `v` in each bin. Note: Julia does not ignore `NaN` values in the computation.\n\"\"\"\nhist(v,n::Int=?)\n\ndoc\"\"\"\n    hist(v, e) -> e, counts\n\nCompute the histogram of `v` using a vector/range `e` as the edges for the bins. The result will be a vector of length `length(e) - 1`, such that the element at location `i` satisfies `sum(e[i] .< v .<= e[i+1])`. Note: Julia does not ignore `NaN` values in the computation.\n\"\"\"\nhist(v,e)\n\ndoc\"\"\"\n    islower(c::Union{Char,AbstractString}) -> Bool\n\nTests whether a character is a lowercase letter, or whether this is true for all elements of a string. A character is classified as lowercase if it belongs to Unicode category Ll, Letter: Lowercase.\n\"\"\"\nislower\n\ndoc\"\"\"\n```rst\n..  nthperm!(v, k)\n\nIn-place version of :func:`nthperm`.\n```\n\"\"\"\nnthperm!\n\ndoc\"\"\"\n    cell(dims)\n\nConstruct an uninitialized cell array (heterogeneous array). `dims` can be either a tuple or a series of integer arguments.\n\"\"\"\ncell\n\ndoc\"\"\"\n    readbytes(stream, nb=typemax(Int); all=true)\n\nRead at most `nb` bytes from the stream, returning a `Vector{UInt8}` of the bytes read.\n\nIf `all` is `true` (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If `all` is `false`, at most one `read` call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the `all` option.\n\"\"\"\nreadbytes\n\ndoc\"\"\"\n```rst\n..  eig(A,[irange,][vl,][vu,][permute=true,][scale=true]) -> D, V\n\nComputes eigenvalues and eigenvectors of ``A``. See :func:`eigfact` for\ndetails on the ``balance`` keyword argument.\n\n.. doctest::\n\n   julia> eig([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])\n   ([1.0,3.0,18.0],\n   3x3 Array{Float64,2}:\n    1.0  0.0  0.0\n    0.0  1.0  0.0\n    0.0  0.0  1.0)\n\n``eig`` is a wrapper around :func:`eigfact`, extracting all parts of the\nfactorization to a tuple; where possible, using :func:`eigfact` is\nrecommended.\n```\n\"\"\"\neig(A,?,?,?)\n\ndoc\"\"\"\n```rst\n..  eig(A, B) -> D, V\n\nComputes generalized eigenvalues and vectors of ``A`` with respect to ``B``.\n\n``eig`` is a wrapper around :func:`eigfact`, extracting all parts of the\nfactorization to a tuple; where possible, using :func:`eigfact` is\nrecommended.\n```\n\"\"\"\neig(A,B)\n\ndoc\"\"\"\n    exp2(x)\n\nCompute $2^x$.\n\"\"\"\nexp2\n\ndoc\"\"\"\n    gcd(x,y)\n\nGreatest common (positive) divisor (or zero if `x` and `y` are both zero).\n\"\"\"\ngcd\n\ndoc\"\"\"\n    signbit(x)\n\nReturns `true` if the value of the sign of `x` is negative, otherwise `false`.\n\"\"\"\nsignbit\n\ndoc\"\"\"\n    istaskstarted(task) -> Bool\n\nTell whether a task has started executing.\n\"\"\"\nistaskstarted\n\ndoc\"\"\"\n    clamp(x, lo, hi)\n\nReturn `x` if `lo <= x <= hi`. If `x < lo`, return `lo`. If `x > hi`, return `hi`. Arguments are promoted to a common type. Operates elementwise over `x` if it is an array.\n\"\"\"\nclamp\n\ndoc\"\"\"\n    cscd(x)\n\nCompute the cosecant of `x`, where `x` is in degrees\n\"\"\"\ncscd\n\ndoc\"\"\"\n    tryparse(type, str, [base])\n\nLike `parse`, but returns a `Nullable` of the requested type. The result will be null if the string does not contain a valid number.\n\"\"\"\ntryparse\n\ndoc\"\"\"\n    lexless(x, y)\n\nDetermine whether `x` is lexicographically less than `y`.\n\"\"\"\nlexless\n\ndoc\"\"\"\n    all!(r, A)\n\nTest whether all values in `A` along the singleton dimensions of `r` are `true`, and write results to `r`.\n\"\"\"\nall!\n\ndoc\"\"\"\n    is_assigned_char(c) -> Bool\n\nReturns `true` if the given char or integer is an assigned Unicode code point.\n\"\"\"\nis_assigned_char\n\ndoc\"\"\"\n    exit([code])\n\nQuit (or control-D at the prompt). The default exit code is zero, indicating that the processes completed successfully.\n\"\"\"\nexit\n\ndoc\"\"\"\n    istext(m::MIME)\n\nDetermine whether a MIME type is text data.\n\"\"\"\nistext\n\ndoc\"\"\"\n    merge!(collection, others...)\n\nUpdate collection with pairs from the other collections\n\"\"\"\nmerge!\n\ndoc\"\"\"\n    realpath(path::AbstractString) -> AbstractString\n\nCanonicalize a path by expanding symbolic links and removing \".\" and \"..\" entries.\n\"\"\"\nrealpath\n\ndoc\"\"\"\n    skipchars(stream, predicate; linecomment::Char)\n\nAdvance the stream until before the first character for which `predicate` returns `false`. For example `skipchars(stream, isspace)` will skip all whitespace. If keyword argument `linecomment` is specified, characters from that character through the end of a line will also be skipped.\n\"\"\"\nskipchars\n\ndoc\"\"\"\n    realmin(T)\n\nThe smallest in absolute value non-subnormal value representable by the given floating-point DataType `T`.\n\"\"\"\nrealmin\n\ndoc\"\"\"\n    union!(s, iterable)\n\nUnion each element of `iterable` into set `s` in-place.\n\"\"\"\nunion!\n\ndoc\"\"\"\n    At_ldiv_B(A, B)\n\nFor matrices or vectors $A$ and $B$, calculates $A\u1d40$ \\ $B$\n\"\"\"\nAt_ldiv_B\n\ndoc\"\"\"\n    dot(x, y)\n    \u22c5(x,y)\n\nCompute the dot product. For complex vectors, the first vector is conjugated.\n\"\"\"\ndot\n\ndoc\"\"\"\n    cond(M, [p])\n\nCondition number of the matrix `M`, computed using the operator `p`-norm. Valid values for `p` are `1`, `2` (default), or `Inf`.\n\"\"\"\ncond\n\ndoc\"\"\"\n    deepcopy(x)\n\nCreate a deep copy of `x`: everything is copied recursively, resulting in a fully independent object. For example, deep-copying an array produces a new array whose elements are deep copies of the original elements. Calling `deepcopy` on an object should generally have the same effect as serializing and then deserializing it.\n\nAs a special case, functions can only be actually deep-copied if they are anonymous, otherwise they are just copied. The difference is only relevant in the case of closures, i.e. functions which may contain hidden internal references.\n\nWhile it isn't normally necessary, user-defined types can override the default `deepcopy` behavior by defining a specialized version of the function `deepcopy_internal(x::T, dict::ObjectIdDict)` (which shouldn't otherwise be used), where `T` is the type to be specialized for, and `dict` keeps track of objects copied so far within the recursion. Within the definition, `deepcopy_internal` should be used in place of `deepcopy`, and the `dict` variable should be updated as appropriate before returning.\n\"\"\"\ndeepcopy\n\ndoc\"\"\"\n    widen(type | x)\n\nIf the argument is a type, return a \"larger\" type (for numeric types, this will be\na type with at least as much range and precision as the argument, and usually more).\nOtherwise the argument `x` is converted to `widen(typeof(x))`.\n\n```jldoctest\njulia> widen(Int32)\nInt64\n\njulia> widen(1.5f0)\n1.5\n```\n\"\"\"\nwiden\n\ndoc\"\"\"\n    @eval\n\nEvaluate an expression and return the value.\n\"\"\"\n:@eval\n\ndoc\"\"\"\n    eval([m::Module], expr::Expr)\n\nEvaluate an expression in the given module and return the result. Every `Module` (except those defined with `baremodule`) has its own 1-argument definition of `eval`, which evaluates expressions in that module.\n\"\"\"\neval\n\ndoc\"\"\"\n```rst\n..  Set([itr])\n\nConstruct a :obj:`Set` of the values generated by the given iterable object, or an empty set.\nShould be used instead of :obj:`IntSet` for sparse integer sets, or for sets of arbitrary objects.\n```\n\"\"\"\nSet\n\ndoc\"\"\"\n    erf(x)\n\nCompute the error function of `x`, defined by\n$\\frac{2}{\\sqrt{\\pi}} \\int_0^x e^{-t^2} dt$\nfor arbitrary complex `x`.\n\"\"\"\nerf\n\ndoc\"\"\"\n    lcm(x,y)\n\nLeast common (non-negative) multiple.\n\"\"\"\nlcm\n\ndoc\"\"\"\n    isprint(c::Union{Char,AbstractString}) -> Bool\n\nTests whether a character is printable, including spaces, but not a control character. For strings, tests whether this is true for all elements of the string.\n\"\"\"\nisprint\n\ndoc\"\"\"\n    splitdir(path::AbstractString) -> (AbstractString,AbstractString)\n\nSplit a path into a tuple of the directory name and file name.\n\"\"\"\nsplitdir\n\ndoc\"\"\"\n    sign(x)\n\nReturn zero if `x==0` and $x/|x|$ otherwise (i.e., \u00b11 for real `x`).\n\"\"\"\nsign\n\ndoc\"\"\"\n    signed(x)\n\nConvert a number to a signed integer. If the argument is unsigned, it is reinterpreted as signed without checking for overflow.\n\"\"\"\nsigned\n\ndoc\"\"\"\n    Val{c}\n\nCreate a \"value type\" out of `c`, which must be an `isbits` value. The intent of this construct is to be able to dispatch on constants, e.g., `f(Val{false})` allows you to dispatch directly (at compile-time) to an implementation `f(::Type{Val{false}})`, without having to test the boolean value at runtime.\n\"\"\"\nVal\n\ndoc\"\"\"\n    iswritable(path) -> Bool\n\nReturns `true` if the current user has permission to write to `path`, `false` otherwise.\n\"\"\"\niswritable\n\ndoc\"\"\"\n    |(x, y)\n\nBitwise or\n\"\"\"\nBase.(:(|))\n\ndoc\"\"\"\n    yieldto(task, arg = nothing)\n\nSwitch to the given task. The first time a task is switched to, the task's function is called with no arguments. On subsequent switches, `arg` is returned from the task's last call to `yieldto`. This is a low-level call that only switches tasks, not considering states or scheduling in any way. Its use is discouraged.\n\"\"\"\nyieldto\n\ndoc\"\"\"\n    readandwrite(command)\n\nStarts running a command asynchronously, and returns a tuple (stdout,stdin,process) of the output stream and input stream of the process, and the process object itself.\n\"\"\"\nreadandwrite\n\ndoc\"\"\"\n    splitdrive(path::AbstractString) -> (AbstractString,AbstractString)\n\nOn Windows, split a path into the drive letter part and the path part. On Unix systems, the first component is always the empty string.\n\"\"\"\nsplitdrive\n\ndoc\"\"\"\n    pop!(collection, key[, default])\n\nDelete and return the mapping for `key` if it exists in `collection`,\notherwise return `default`, or throw an error if default is not specified.\n\"\"\"\npop!(collection,key,?)\n\ndoc\"\"\"\n    pop!(collection) -> item\n\nRemove the last item in `collection` and return it.\n\n```jldoctest\njulia> A=[1, 2, 3, 4, 5, 6]\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia> pop!(A)\n6\n\njulia> A\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n```\n\"\"\"\npop!(collection)\n\ndoc\"\"\"\n    filter(function, collection)\n\nReturn a copy of `collection`, removing elements for which `function` is `false`. For associative collections, the function is passed two arguments (key and value).\n\"\"\"\nfilter\n\ndoc\"\"\"\n```rst\n..  randperm([rng,] n)\n\nConstruct a random permutation of length ``n``. The optional ``rng`` argument\nspecifies a random number generator, see :ref:`Random Numbers <random-numbers>`.\n```\n\"\"\"\nrandperm\n\ndoc\"\"\"\n    seekend(s)\n\nSeek a stream to its end.\n\"\"\"\nseekend\n\ndoc\"\"\"\n    DivideError()\n\nInteger division was attempted with a denominator value of 0.\n\"\"\"\nDivideError\n\ndoc\"\"\"\n    AssertionError([msg])\n\nThe asserted condition did not evaluate to `true`.\nOptional argument `msg` is a descriptive error string.\n\"\"\"\nAssertionError\n\ndoc\"\"\"\n    ror(B::BitArray{1}, i::Integer) -> BitArray{1}\n\nPerforms a right rotation operation.\n\"\"\"\nror\n\ndoc\"\"\"\n    Ac_ldiv_Bc(A, B)\n\nFor matrices or vectors $A$ and $B$, calculates $A\u1d34$ \\ $B\u1d34$\n\"\"\"\nAc_ldiv_Bc\n\ndoc\"\"\"\n```rst\n..  @enum EnumName EnumValue1[=x] EnumValue2[=y]\n\nCreate an :obj:`Enum` type with name ``EnumName`` and enum member values of ``EnumValue1`` and ``EnumValue2`` with optional assigned values of ``x`` and ``y``, respectively. ``EnumName`` can be used just like other types and enum member values as regular values, such as\n\n.. doctest::\n\n   julia> @enum FRUIT apple=1 orange=2 kiwi=3\n\n   julia> f(x::FRUIT) = \"I'm a FRUIT with value: $(Int(x))\"\n   f (generic function with 1 method)\n\n   julia> f(apple)\n   \"I'm a FRUIT with value: 1\"\n```\n\"\"\"\n:@enum\n\ndoc\"\"\"\n    asind(x)\n\nCompute the inverse sine of `x`, where the output is in degrees\n\"\"\"\nasind\n\ndoc\"\"\"\n    widemul(x, y)\n\nMultiply `x` and `y`, giving the result as a larger type.\n\"\"\"\nwidemul\n\ndoc\"\"\"\n    unsafe_pointer_to_objref(p::Ptr)\n\nConvert a `Ptr` to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered \"unsafe\" and should be used with care.\n\"\"\"\nunsafe_pointer_to_objref\n\ndoc\"\"\"\n    chomp(string)\n\nRemove a trailing newline from a string.\n\"\"\"\nchomp\n\ndoc\"\"\"\n    enumerate(iter)\n\nAn iterator that yields `(i, x)` where `i` is an index starting at 1, and\n`x` is the `i`th value from the given iterator. It's useful when you need\nnot only the values `x` over which you are iterating, but also the index `i`\nof the iterations.\n\n```jldoctest\njulia> a = [\"a\", \"b\", \"c\"];\n\njulia> for (index, value) in enumerate(a)\n           println(\"$index $value\")\n       end\n1 a\n2 b\n3 c\n```\n\"\"\"\nenumerate\n\ndoc\"\"\"\n    >=(x, y)\n    \u2265(x,y)\n\nGreater-than-or-equals comparison operator.\n\"\"\"\nBase.(:(>=))\n\ndoc\"\"\"\n    dawson(x)\n\nCompute the Dawson function (scaled imaginary error function) of `x`,\ndefined by $\\frac{\\sqrt{\\pi}}{2} e^{-x^2} \\operatorname{erfi}(x)$.\n\"\"\"\ndawson\n\ndoc\"\"\"\n    current_task()\n\nGet the currently running `Task`.\n\"\"\"\ncurrent_task\n\n# Dates\n\ndoc\"\"\"\n    firstdayofweek(dt::TimeType) -> TimeType\n\nAdjusts `dt` to the Monday of its week.\n\"\"\"\nDates.firstdayofweek\n\ndoc\"\"\"\n    datetime2unix(dt::DateTime) -> Float64\n\nTakes the given `DateTime` and returns the number of seconds since the unix epoch as a `Float64`.\n\"\"\"\nDates.datetime2unix\n\ndoc\"\"\"\n    dayofweekofmonth(dt::TimeType) -> Int\n\nFor the day of week of `dt`, returns which number it is in `dt`'s month. So if the day of the week of `dt` is Monday, then `1 = First Monday of the month, 2 = Second Monday of the month, etc.` In the range 1:5.\n\"\"\"\nDates.dayofweekofmonth\n\ndoc\"\"\"\n    monthabbr(dt::TimeType; locale=\"english\") -> AbstractString\n\nReturn the abbreviated month name of the `Date` or `DateTime` in the given `locale`.\n\"\"\"\nDates.monthabbr\n\ndoc\"\"\"\n    datetime2julian(dt::DateTime) -> Float64\n\nTakes the given `DateTime` and returns the number of Julian calendar days since the julian epoch as a `Float64`.\n\"\"\"\nDates.datetime2julian\n\ndoc\"\"\"\n    dayabbr(dt::TimeType; locale=\"english\") -> AbstractString\n\nReturn the abbreviated name corresponding to the day of the week of the `Date` or `DateTime` in the given `locale`.\n\"\"\"\nDates.dayabbr\n\ndoc\"\"\"\n```rst\n..  DateTime(y, [m, d, h, mi, s, ms]) -> DateTime\n\nConstruct a ``DateTime`` type by parts. Arguments must be convertible to ``Int64``.\n```\n\"\"\"\nDates.DateTime(y)\n\ndoc\"\"\"\n```rst\n..  DateTime(periods::Period...) -> DateTime\n\nConstuct a ``DateTime`` type by ``Period`` type parts. Arguments may be in any order.\nDateTime parts not provided will default to the value of ``Dates.default(period)``.\n```\n\"\"\"\nDates.DateTime(periods::Dates.Period...)\n\ndoc\"\"\"\n```rst\n..  DateTime(f::Function, y[, m, d, h, mi, s]; step=Day(1), negate=false, limit=10000) -> DateTime\n\nCreate a ``DateTime`` through the adjuster API. The starting point will be constructed from the\nprovided ``y, m, d...`` arguments, and will be adjusted until ``f::Function`` returns ``true``. The step size in\nadjusting can be provided manually through the ``step`` keyword. If ``negate=true``, then the adjusting\nwill stop when ``f::Function`` returns ``false`` instead of ``true``. ``limit`` provides a limit to\nthe max number of iterations the adjustment API will pursue before throwing an error (in the case that ``f::Function`` is never satisfied).\n```\n\"\"\"\nDates.DateTime(f::Function, y)\n\ndoc\"\"\"\n```rst\n..  DateTime(dt::Date) -> DateTime\n\nConverts a ``Date`` type to a ``DateTime``.\nThe hour, minute, second, and millisecond parts of the new ``DateTime`` are assumed to be zero.\n```\n\"\"\"\nDates.DateTime(dt::Date)\n\ndoc\"\"\"\n```rst\n..  DateTime(dt::AbstractString, format::AbstractString; locale=\"english\") -> DateTime\n\nConstruct a ``DateTime`` type by parsing the ``dt`` date string following the pattern given in\nthe ``format`` string. The following codes can be used for constructing format strings:\n\n=============== ========= ===============================================================\nCode            Matches    Comment\n=============== ========= ===============================================================\n``y``           1996, 96  Returns year of 1996, 0096\n``m``           1, 01     Matches 1 or 2-digit months\n``u``           Jan       Matches abbreviated months according to the ``locale`` keyword\n``U``           January   Matches full month names according to the ``locale`` keyword\n``d``           1, 01     Matches 1 or 2-digit days\n``H``           00        Matches hours\n``M``           00        Matches minutes\n``S``           00        Matches seconds\n``s``           .500      Matches milliseconds\n``e``           Mon, Tues Matches abbreviated days of the week\n``E``           Monday    Matches full name days of the week\n``yyyymmdd``    19960101  Matches fixed-width year, month, and day\n=============== ========= ===============================================================\n\nAll characters not listed above are treated as delimiters between date and time slots.\nSo a ``dt`` string of \"1996-01-15T00:00:00.0\" would have a ``format`` string like \"y-m-dTH:M:S.s\".\n```\n\"\"\"\nDates.DateTime(dt::AbstractString, format::AbstractString)\n\ndoc\"\"\"\n```rst\n..  DateTime(dt::AbstractString, df::DateFormat) -> DateTime\n\nSimilar form as above for parsing a ``DateTime``, but passes a ``DateFormat`` object instead of a raw formatting string. It is more efficient if similarly formatted date strings will be parsed repeatedly to first create a ``DateFormat`` object then use this method for parsing.\n```\n\"\"\"\nDates.DateTime(dt::AbstractString, df::Dates.DateFormat)\n\ndoc\"\"\"\n    datetime2rata(dt::TimeType) -> Int64\n\nReturns the number of Rata Die days since epoch from the given `Date` or `DateTime`.\n\"\"\"\nDates.datetime2rata\n\ndoc\"\"\"\n    monthname(dt::TimeType; locale=\"english\") -> AbstractString\n\nReturn the full name of the month of the `Date` or `DateTime` in the given `locale`.\n\"\"\"\nDates.monthname\n\ndoc\"\"\"\n    dayname(dt::TimeType; locale=\"english\") -> AbstractString\n\nReturn the full day name corresponding to the day of the week of the `Date` or `DateTime` in the given `locale`.\n\"\"\"\nDates.dayname\n\ndoc\"\"\"\n    Date(y, [m, d]) -> Date\n\nConstruct a `Date` type by parts. Arguments must be convertible to `Int64`.\n\"\"\"\nDates.Date(y)\n\ndoc\"\"\"\n    Date(period::Period...) -> Date\n\nConstuct a `Date` type by `Period` type parts. Arguments may be in any order. `Date` parts not provided will default to the value of `Dates.default(period)`.\n\"\"\"\nDates.Date(period::Dates.Period...)\n\ndoc\"\"\"\n    Date(f::Function, y[, m]; step=Day(1), negate=false, limit=10000) -> Date\n\nCreate a `Date` through the adjuster API. The starting point will be constructed from the provided `y, m` arguments, and will be adjusted until `f::Function` returns `true`. The step size in adjusting can be provided manually through the `step` keyword. If `negate=true`, then the adjusting will stop when `f::Function` returns `false` instead of `true`. `limit` provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (given that `f::Function` is never satisfied).\n\"\"\"\nDates.Date(f::Function, y)\n\ndoc\"\"\"\n    Date(dt::DateTime) -> Date\n\nConverts a `DateTime` type to a `Date`. The hour, minute, second, and millisecond parts of the `DateTime` are truncated, so only the year, month and day parts are used in construction.\n\"\"\"\nDates.Date(dt::DateTime)\n\ndoc\"\"\"\n    Date(dt::AbstractString, format::AbstractString; locale=\"english\") -> Date\n\nConstruct a `Date` type by parsing a `dt` date string following the pattern given in the `format` string. Follows the same conventions as `DateTime` above.\n\"\"\"\nDates.Date(dt::AbstractString, format::AbstractString)\n\ndoc\"\"\"\n    Date(dt::AbstractString, df::DateFormat) -> Date\n\nParse a date from a date string `dt` using a `DateFormat` object `df`.\n\"\"\"\nDates.Date(dt::AbstractString, df::Dates.DateFormat)\n\ndoc\"\"\"\n    firstdayofmonth(dt::TimeType) -> TimeType\n\nAdjusts `dt` to the first day of its month.\n\"\"\"\nDates.firstdayofmonth\n\ndoc\"\"\"\n    tonext(dt::TimeType,dow::Int;same::Bool=false) -> TimeType\n\nAdjusts `dt` to the next day of week corresponding to `dow` with `1 = Monday, 2 = Tuesday, etc`. Setting `same=true` allows the current `dt` to be considered as the next `dow`, allowing for no adjustment to occur.\n\"\"\"\nDates.tonext(::Dates.TimeType,::Int,?)\n\ndoc\"\"\"\n    tonext(func::Function,dt::TimeType;step=Day(1),negate=false,limit=10000,same=false) -> TimeType\n\nAdjusts `dt` by iterating at most `limit` iterations by `step` increments until `func` returns `true`. `func` must take a single `TimeType` argument and return a `Bool`. `same` allows `dt` to be considered in satisfying `func`. `negate` will make the adjustment process terminate when `func` returns `false` instead of `true`.\n\"\"\"\nDates.tonext(::Function,::Dates.TimeType)\n\ndoc\"\"\"\n    dayofyear(dt::TimeType) -> Int\n\nReturns the day of the year for `dt` with January 1st being day 1.\n\"\"\"\nDates.dayofyear\n\ndoc\"\"\"\n    tolast(dt::TimeType,dow::Int;of=Month) -> TimeType\n\nAdjusts `dt` to the last `dow` of its month. Alternatively, `of=Year` will adjust to the last `dow` of the year.\n\"\"\"\nDates.tolast\n\ndoc\"\"\"\n    firstdayofquarter(dt::TimeType) -> TimeType\n\nAdjusts `dt` to the first day of its quarter.\n\"\"\"\nDates.firstdayofquarter\n\ndoc\"\"\"\n```rst\n..  julian2datetime(julian_days) -> DateTime\n\nTakes the number of Julian calendar days since epoch\n``-4713-11-24T12:00:00`` and returns the corresponding ``DateTime``.\n```\n\"\"\"\nDates.julian2datetime\n\ndoc\"\"\"\n    year(dt::TimeType) -> Int64\n    month(dt::TimeType) -> Int64\n    week(dt::TimeType) -> Int64\n    day(dt::TimeType) -> Int64\n    hour(dt::TimeType) -> Int64\n    minute(dt::TimeType) -> Int64\n    second(dt::TimeType) -> Int64\n    millisecond(dt::TimeType) -> Int64\n\nReturn the field part of a `Date` or `DateTime` as an `Int64`.\n\"\"\"\nDates.year\n\ndoc\"\"\"\n    toprev(dt::TimeType,dow::Int;same::Bool=false) -> TimeType\n\nAdjusts `dt` to the previous day of week corresponding to `dow` with `1 = Monday, 2 = Tuesday, etc`. Setting `same=true` allows the current `dt` to be considered as the previous `dow`, allowing for no adjustment to occur.\n\"\"\"\nDates.toprev(::Dates.TimeType,::Int,?)\n\ndoc\"\"\"\n    toprev(func::Function,dt::TimeType;step=Day(-1),negate=false,limit=10000,same=false) -> TimeType\n\nAdjusts `dt` by iterating at most `limit` iterations by `step` increments until `func` returns `true`. `func` must take a single `TimeType` argument and return a `Bool`. `same` allows `dt` to be considered in satisfying `func`. `negate` will make the adjustment process terminate when `func` returns `false` instead of `true`.\n\"\"\"\nDates.toprev(::Function,::Dates.TimeType)\n\ndoc\"\"\"\n    daysinyear(dt::TimeType) -> Int\n\nReturns 366 if the year of `dt` is a leap year, otherwise returns 365.\n\"\"\"\nDates.daysinyear\n\ndoc\"\"\"\n```rst\n..  trunc(dt::TimeType, ::Type{Period}) -> TimeType\n\nTruncates the value of ``dt`` according to the provided ``Period`` type.\nE.g. if ``dt`` is ``1996-01-01T12:30:00``, then ``trunc(dt,Day) == 1996-01-01T00:00:00``.\n```\n\"\"\"\nDates.trunc(::Dates.TimeType, ::Type{Dates.Period})\n\ndoc\"\"\"\n    daysinmonth(dt::TimeType) -> Int\n\nReturns the number of days in the month of `dt`. Value will be 28, 29, 30, or 31.\n\"\"\"\nDates.daysinmonth\n\ndoc\"\"\"\n    yearmonth(dt::TimeType) -> (Int64, Int64)\n\nSimultaneously return the year and month parts of a `Date` or `DateTime`.\n\"\"\"\nDates.yearmonth\n\ndoc\"\"\"\n    daysofweekinmonth(dt::TimeType) -> Int\n\nFor the day of week of `dt`, returns the total number of that day of the week in `dt`'s month. Returns 4 or 5. Useful in temporal expressions for specifying the last day of a week in a month by including `dayofweekofmonth(dt) == daysofweekinmonth(dt)` in the adjuster function.\n\"\"\"\nDates.daysofweekinmonth\n\ndoc\"\"\"\n    yearmonthday(dt::TimeType) -> (Int64, Int64, Int64)\n\nSimultaneously return the year, month, and day parts of a `Date` or `DateTime`.\n\"\"\"\nDates.yearmonthday\n\ndoc\"\"\"\n    Dates.DateFormat(format::AbstractString) -> DateFormat\n\nConstruct a date formatting object that can be passed repeatedly for parsing similarly formatted date strings. `format` is a format string in the form described above (e.g. `\"yyyy-mm-dd\"`).\n\"\"\"\nDates.Dates.DateFormat\n\ndoc\"\"\"\n    lastdayofweek(dt::TimeType) -> TimeType\n\nAdjusts `dt` to the Sunday of its week.\n\"\"\"\nDates.lastdayofweek\n\ndoc\"\"\"\n    recur{T<:TimeType}(func::Function,dr::StepRange{T};negate=false,limit=10000) -> Vector{T}\n\n`func` takes a single TimeType argument and returns a `Bool` indicating whether the input should be \"included\" in the final set. `recur` applies `func` over each element in the range of `dr`, including those elements for which `func` returns `true` in the resulting Array, unless `negate=true`, then only elements where `func` returns `false` are included.\n\"\"\"\nDates.recur\n\ndoc\"\"\"\n    monthday(dt::TimeType) -> (Int64, Int64)\n\nSimultaneously return the month and day parts of a `Date` or `DateTime`.\n\"\"\"\nDates.monthday\n\ndoc\"\"\"\n    default(p::Period) -> Period\n\nReturns a sensible \"default\" value for the input Period by returning `one(p)` for Year, Month, and Day, and `zero(p)` for Hour, Minute, Second, and Millisecond.\n\"\"\"\nDates.default\n\ndoc\"\"\"\n```rst\n..  unix2datetime(x) -> DateTime\n\nTakes the number of seconds since unix epoch ``1970-01-01T00:00:00``\nand converts to the corresponding ``DateTime``.\n```\n\"\"\"\nDates.unix2datetime\n\ndoc\"\"\"\n    eps(::DateTime) -> Millisecond\n    eps(::Date) -> Day\n\nReturns `Millisecond(1)` for `DateTime` values and `Day(1)` for `Date` values.\n\"\"\"\nDates.eps(::Union{Date,DateTime})\n\ndoc\"\"\"\n    firstdayofyear(dt::TimeType) -> TimeType\n\nAdjusts `dt` to the first day of its year.\n\"\"\"\nDates.firstdayofyear\n\ndoc\"\"\"\n```rst\n..  rata2datetime(days) -> DateTime\n\nTakes the number of Rata Die days since epoch ``0000-12-31T00:00:00``\nand returns the corresponding ``DateTime``.\n```\n\"\"\"\nDates.rata2datetime\n\ndoc\"\"\"\n    now() -> DateTime\n\nReturns a `DateTime` corresponding to the user's system time including the system timezone locale.\n\"\"\"\nnow\n\ndoc\"\"\"\n    now(::Type{UTC}) -> DateTime\n\nReturns a `DateTime` corresponding to the user's system time as UTC/GMT.\n\"\"\"\nDates.now(::Type{Dates.UTC})\n\ndoc\"\"\"\n    isleapyear(dt::TimeType) -> Bool\n\nReturns `true` if the year of `dt` is a leap year.\n\"\"\"\nDates.isleapyear\n\ndoc\"\"\"\n    today() -> Date\n\nReturns the date portion of `now()`.\n\"\"\"\nDates.today\n\ndoc\"\"\"\n    lastdayofyear(dt::TimeType) -> TimeType\n\nAdjusts `dt` to the last day of its year.\n\"\"\"\nDates.lastdayofyear\n\ndoc\"\"\"\n    tofirst(dt::TimeType,dow::Int;of=Month) -> TimeType\n\nAdjusts `dt` to the first `dow` of its month. Alternatively, `of=Year` will adjust to the first `dow` of the year.\n\"\"\"\nDates.tofirst\n\ndoc\"\"\"\n    lastdayofmonth(dt::TimeType) -> TimeType\n\nAdjusts `dt` to the last day of its month.\n\"\"\"\nDates.lastdayofmonth\n\ndoc\"\"\"\n    dayofweek(dt::TimeType) -> Int64\n\nReturns the day of the week as an `Int64` with `1 = Monday, 2 = Tuesday, etc.`.\n\"\"\"\nDates.dayofweek\n\ndoc\"\"\"\n    Year(dt::TimeType) -> Year\n    Month(dt::TimeType) -> Month\n    Week(dt::TimeType) -> Week\n    Day(dt::TimeType) -> Day\n    Hour(dt::TimeType) -> Hour\n    Minute(dt::TimeType) -> Minute\n    Second(dt::TimeType) -> Second\n    Millisecond(dt::TimeType) -> Millisecond\n\nReturn the field part of a `Date` or `DateTime` as a `Period` type.\n\"\"\"\nDates.Year(dt::Dates.TimeType)\n\ndoc\"\"\"\n    Year(v)\n    Month(v)\n    Week(v)\n    Day(v)\n    Hour(v)\n    Minute(v)\n    Second(v)\n    Millisecond(v)\n\nConstruct a `Period` type with the given `v` value. Input must be losslessly\nconvertible to an `Int64`.\n\"\"\"\nDates.Year(v)\n\ndoc\"\"\"\n    quarterofyear(dt::TimeType) -> Int\n\nReturns the quarter that `dt` resides in. Range of value is 1:4.\n\"\"\"\nDates.quarterofyear\n\ndoc\"\"\"\n    dayofquarter(dt::TimeType) -> Int\n\nReturns the day of the current quarter of `dt`. Range of value is 1:92.\n\"\"\"\nDates.dayofquarter\n\ndoc\"\"\"\n    lastdayofquarter(dt::TimeType) -> TimeType\n\nAdjusts `dt` to the last day of its quarter.\n\"\"\"\nDates.lastdayofquarter\n\n# Base.Pkg\n\ndoc\"\"\"\n    build()\n\nRun the build scripts for all installed packages in depth-first recursive order.\n\"\"\"\nPkg.build()\n\ndoc\"\"\"\n    build(pkgs...)\n\nRun the build script in `deps/build.jl` for each package in `pkgs` and all of their dependencies in depth-first recursive order. This is called automatically by `Pkg.resolve()` on all installed or updated packages.\n\"\"\"\nPkg.build(pkgs...)\n\ndoc\"\"\"\n    init(meta::AbstractString=DEFAULT_META, branch::AbstractString=META_BRANCH)\n\nInitialize `Pkg.dir()` as a package directory. This will be done automatically when the `JULIA_PKGDIR` is not set and `Pkg.dir()` uses its default value. As part of this process, clones a local METADATA git repository from the site and branch specified by its arguments, which are typically not provided. Explicit (non-default) arguments can be used to support a custom METADATA setup.\n\"\"\"\nPkg.init()\n\ndoc\"\"\"\n    publish()\n\nFor each new package version tagged in `METADATA` not already published, make sure that the tagged package commits have been pushed to the repo at the registered URL for the package and if they all have, open a pull request to `METADATA`.\n\"\"\"\nPkg.publish()\n\ndoc\"\"\"\n    pin(pkg)\n\nPin `pkg` at the current version. To go back to using the newest compatible released version, use `Pkg.free(pkg)`\n\"\"\"\nPkg.pin(pkg)\n\ndoc\"\"\"\n    pin(pkg, version)\n\nPin `pkg` at registered version `version`.\n\"\"\"\nPkg.pin(pkg, version)\n\ndoc\"\"\"\n    resolve()\n\nDetermines an optimal, consistent set of package versions to install or upgrade to. The optimal set of package versions is based on the contents of `Pkg.dir(\"REQUIRE\")` and the state of installed packages in `Pkg.dir()`, Packages that are no longer required are moved into `Pkg.dir(\".trash\")`.\n\"\"\"\nPkg.resolve()\n\ndoc\"\"\"\n    available() -> Vector{ASCIIString}\n\nReturns the names of available packages.\n\"\"\"\nPkg.available()\n\ndoc\"\"\"\n    available(pkg) -> Vector{VersionNumber}\n\nReturns the version numbers available for package `pkg`.\n\"\"\"\nPkg.available(pkg)\n\ndoc\"\"\"\n    register(pkg, [url])\n\nRegister `pkg` at the git URL `url`, defaulting to the configured origin URL of the git repo `Pkg.dir(pkg)`.\n\"\"\"\nPkg.register(pkg, url=?)\n\ndoc\"\"\"\n    rm(pkg)\n\nRemove all requirement entries for `pkg` from `Pkg.dir(\"REQUIRE\")` and call `Pkg.resolve()`.\n\"\"\"\nPkg.rm(pkg)\n\ndoc\"\"\"\n    free(pkg)\n\nFree the package `pkg` to be managed by the package manager again. It calls `Pkg.resolve()` to determine optimal package versions after. This is an inverse for both `Pkg.checkout` and `Pkg.pin`.\n\nYou can also supply an iterable collection of package names, e.g., `Pkg.free((\"Pkg1\", \"Pkg2\"))` to free multiple packages at once.\n\"\"\"\nPkg.free()\n\ndoc\"\"\"\n    status()\n\nPrints out a summary of what packages are installed and what version and state they're in.\n\"\"\"\nPkg.status\n\ndoc\"\"\"\n    edit()\n\nOpens `Pkg.dir(\"REQUIRE\")` in the editor specified by the `VISUAL` or `EDITOR` environment variables; when the editor command returns, it runs `Pkg.resolve()` to determine and install a new optimal set of installed package versions.\n\"\"\"\nPkg.edit()\n\ndoc\"\"\"\n    clone(url, [pkg])\n\nClone a package directly from the git URL `url`. The package does not need to be a registered in `Pkg.dir(\"METADATA\")`. The package repo is cloned by the name `pkg` if provided; if not provided, `pkg` is determined automatically from `url`.\n\"\"\"\nPkg.clone(url,?)\n\ndoc\"\"\"\n    clone(pkg)\n\nIf `pkg` has a URL registered in `Pkg.dir(\"METADATA\")`, clone it from that URL on the default branch. The package does not need to have any registered versions.\n\"\"\"\nPkg.clone(pkg)\n\ndoc\"\"\"\n    checkout(pkg, [branch=\"master\"])\n\nCheckout the `Pkg.dir(pkg)` repo to the branch `branch`. Defaults to checking out the \"master\" branch. To go back to using the newest compatible released version, use `Pkg.free(pkg)`\n\"\"\"\nPkg.checkout(pkg)\n\ndoc\"\"\"\n    update()\n\nUpdate package the metadata repo \u2013 kept in `Pkg.dir(\"METADATA\")` \u2013 then update any fixed packages that can safely be pulled from their origin; then call `Pkg.resolve()` to determine a new optimal set of packages versions.\n\"\"\"\nPkg.update\n\ndoc\"\"\"\n    add(pkg, vers...)\n\nAdd a requirement entry for `pkg` to `Pkg.dir(\"REQUIRE\")` and call `Pkg.resolve()`. If `vers` are given, they must be `VersionNumber` objects and they specify acceptable version intervals for `pkg`.\n\"\"\"\nPkg.add(pkg, vers...)\n\ndoc\"\"\"\n    tag(pkg, [ver, [commit]])\n\nTag `commit` as version `ver` of package `pkg` and create a version entry in `METADATA`. If not provided, `commit` defaults to the current commit of the `pkg` repo. If `ver` is one of the symbols `:patch`, `:minor`, `:major` the next patch, minor or major version is used. If `ver` is not provided, it defaults to `:patch`.\n\"\"\"\nPkg.tag(pkg)\n\ndoc\"\"\"\n    test()\n\nRun the tests for all installed packages ensuring that each package's test dependencies are installed for the duration of the test. A package is tested by running its `test/runtests.jl` file and test dependencies are specified in `test/REQUIRE`.\n\"\"\"\nPkg.test()\n\ndoc\"\"\"\n    test(pkgs...)\n\nRun the tests for each package in `pkgs` ensuring that each package's test dependencies are installed for the duration of the test. A package is tested by running its `test/runtests.jl` file and test dependencies are specified in `test/REQUIRE`.\n\"\"\"\nPkg.test(pkgs...)\n\ndoc\"\"\"\n    generate(pkg,license)\n\nGenerate a new package named `pkg` with one of these license keys: `\"MIT\"`, `\"BSD\"` or `\"ASL\"`. If you want to make a package with a different license, you can edit it afterwards. Generate creates a git repo at `Pkg.dir(pkg)` for the package and inside it `LICENSE.md`, `README.md`, `REQUIRE`, the julia entrypoint `$pkg/src/$pkg.jl`, and Travis and AppVeyor CI configuration files `.travis.yml` and `appveyor.yml`.\n\"\"\"\nPkg.generate(pkg,license)\n\ndoc\"\"\"\n    dir() -> AbstractString\n\nReturns the absolute path of the package directory. This defaults to `joinpath(homedir(),\".julia\",\"v$(VERSION.major).$(VERSION.minor)\")` on all platforms (i.e. `~/.julia/v0.4` in UNIX shell syntax). If the `JULIA_PKGDIR` environment variable is set, then that path is used in the returned value as `joinpath(ENV[\"JULIA_PKGDIR\"],\"v$(VERSION.major).$(VERSION.minor)\")`. If `JULIA_PKGDIR` is a relative path, it is interpreted relative to whatever the current working directory is.\n\"\"\"\nPkg.dir()\n\ndoc\"\"\"\n    dir(names...) -> AbstractString\n\nEquivalent to `normpath(Pkg.dir(),names...)` \u2013 i.e. it appends path components to the package directory and normalizes the resulting path. In particular, `Pkg.dir(pkg)` returns the path to the package `pkg`.\n\"\"\"\nPkg.dir(names...)\n\ndoc\"\"\"\n    installed() -> Dict{ASCIIString,VersionNumber}\n\nReturns a dictionary mapping installed package names to the installed version number of each package.\n\"\"\"\nPkg.installed()\n\ndoc\"\"\"\n    installed(pkg) -> Void | VersionNumber\n\nIf `pkg` is installed, return the installed version number, otherwise return `nothing`.\n\"\"\"\nPkg.installed(pkg)\n\ndoc\"\"\"\n    randjump(r::MersenneTwister, jumps, [jumppoly]) -> Vector{MersenneTwister}\n\nCreate an array of the size `jumps` of initialized `MersenneTwister` RNG objects where the first RNG object given as a parameter and following `MersenneTwister` RNGs in the array initialized such that a state of the RNG object in the array would be moved forward (without generating numbers) from a previous RNG object array element on a particular number of steps encoded by the jump polynomial `jumppoly`.\n\nDefault jump polynomial moves forward `MersenneTwister` RNG state by 10^20 steps.\n\"\"\"\nrandjump\n\ndoc\"\"\"\n```rst\n..  \\:(start, [step], stop)\n\nRange operator. ``a:b`` constructs a range from ``a`` to ``b`` with a step size of 1, and ``a:s:b`` is similar but uses a step size of ``s``. These syntaxes call the function ``colon``.\nThe colon is also used in indexing to select whole dimensions.\n```\n\"\"\"\ncolon(start, step, stop)\n\ndoc\"\"\"\n```rst\n..  $(x, y)\n\nBitwise exclusive or\n```\n\"\"\"\nBase.(:$)(x, y)\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/base/docs/basedocs.jl": "# This file is a part of Julia. License is MIT: http://julialang.org/license\n\nimport .Docs: keywords\n\nkeywords[:hello] = keywords[:hi] = doc\"Hello, Human.\"\n\nconst intro = doc\"\"\"\n  **Welcome to Julia $(string(VERSION)).** The full manual is available at\n\n      http://docs.julialang.org/\n\n  as well many great tutorials and learning resources:\n\n      http://julialang.org/learning/\n\n  For help on a specific function or macro, type `?` followed\n  by its name, e.g. `?fft`, `?@time` or `?html`, and press\n  enter.\n  \"\"\"\n\nkeywords[:help] = keywords[:?] = keywords[:julia] = intro\n\nkeywords[:using] = doc\"\"\"\n  `using` will load the given module or package and make some of its names\n  available for use (see also `export`). For example:\n\n      using Gadfly\n\n  loads the plotting package, Gadfly, so that the `plot` function can be used.\n\n  Names can be used via dot syntax, whether they are exported or not:\n\n      Gadfly.plot(...)\n\n  If you don't want to use the packages exports directly, see also `import`.\n  If you're not sure, `using` is almost definitely what you want.\n  \"\"\"\n\nkeywords[:import] = doc\"\"\"\n      import Gadfly\n\n  `import`, like `using`, will load modules and packages for use. Unlike\n  `using`, however, it will *not* make any `export`ed names available for use.\n  To use Gadfly's `plot` function after importing it, for example, you have\n  to write:\n\n      Gadfly.plot(...)\n\n  Import can also be used with specific names, for example\n\n      import Gadfly: plot, render\n\n  This syntax is used when you want to extend the modules functions with\n  new methods.\n  \"\"\"\n\nkeywords[:export] = doc\"\"\"\n  `export` is used within modules and packages to tell Julia which functions\n  should be made available to the user. For example:\n\n      module Test\n      export foo # foo is exported, but bar isn't\n      foo(x) = x\n      bar(y) = y\n      end\n\n      using Test\n      foo(1) # 1\n      bar(1) # Error: bar not defined\n      Test.bar(1) # 1\n  \"\"\"\n\nkeywords[:abstract] = doc\"\"\"\n  `abstract` declares a type that cannot be instantiated, and serves only as a node in the type graph,\n  thereby describing sets of related concrete types: those concrete types which are their descendants.\n  Abstract types form the conceptual hierarchy which makes Julia\u2019s type system more than just a collection of object implementations.\n  For example:\n\n      abstract Number\n      abstract Real <: Number\n\n  `abstract Number` has no supertype, whereas `abstract Real` is an abstract subtype of `Number`.\n  \"\"\"\n\nkeywords[:module] = doc\"\"\"\n  `module` declares a Module, which is a separate global variable workspace.  Within a module, you can control which names from other modules are visible (via importing), and specify which of your names are intended to be public (via exporting). For example:\n\n      module\n      import Base.show\n      export MyType, foo\n\n      type MyType\n          x\n      end\n\n      bar(x) = 2x\n      foo(a::MyType) = bar(a.x) + 1\n      show(io, a::MyType) = print(io, \"MyType $(a.x)\")\n      end\n\n  Modules allow you to create top-level definitions without worrying about name conflicts when your code is used together with somebody else\u2019s.\n  \"\"\"\n\nkeywords[:baremodule] = doc\"\"\"\n  `baremodule` declares a module that does not contain `using Base`, `import Base.call`,\n  or a definition of `eval`.  It does still import `Core`.\n  \"\"\"\n\nkeywords[:bitstype] = doc\"\"\"\n  `bitstype` declares a concrete type whose data consists of plain old bits. Classic examples of bits types are integers and floating-point values.  Some example built-in bits type declarations:\n\n      bitstype 32 Char\n      bitstype 8  Bool <: Integer\n\n  The first parameter indicates how many bits of storage the type requires. Currently, only sizes that are multiples of 8 bits are supported. The second parameter gives the name of the type.  The `Bool` declaration shows how a bits type can be optionally declared to be a subtype of some supertype.\n  \"\"\"\n\nkeywords[:macro] = doc\"\"\"\n  `macro` defines a method to include generated code in the final body of a program. A macro maps a tuple of arguments to a returned expression, and the resulting expression is compiled directly rather than requiring a runtime `eval()` call. Macro arguments may include expressions, literal values, and symbols. For example:\n\n      macro sayhello(name)\n          return :( println(\"Hello, \", $name) )\n      end\n\n  This macro takes one argument: `name`. When `@sayhello` is encountered, the quoted expression is expanded to interpolate the value of the argument into the final expression.\n  \"\"\"\n\nkeywords[:importall] = doc\"\"\"\n  `importall` imports all names exported by the specified module, as if `import` were used individually on all of them.  For example:\n\n      importall Distributions\n\n  As with `import`, functions imported by `importall` can be extended.\n  \"\"\"\n\nkeywords[:local] = doc\"\"\"\n  `local` introduces a new local variable. For example:\n\n      function foo(n)\n          x = 0\n          for i = 1:n\n              local x\n              x = i\n          end\n          x\n      end\n\n      julia> foo(10)\n      0\n\n  Here `local x` introduces a separate `x` inside the loop, so the function returns `0`.\n  \"\"\"\n\nkeywords[:global] = doc\"\"\"\n  `global x` makes `x` in the current scope and its inner scopes refer to the global variable of that name.   In the example below, `global` is needed so the function can modify the global variable `z`:\n\n      z=3\n      function foo()\n          global z=6\n      end\n\n      julia> foo()\n      6\n      julia> z\n      6\n\n  Without the `global` declaration in `foo()`, a new local variable would have been created inside foo(), and the `z` in the global scope would have remained equal to `3`.\n  \"\"\"\n\nkeywords[:let] = doc\"\"\"\n  `let` statements allocate new variable bindings each time they run. Whereas an assignment modifies an existing value location, `let` creates new locations. This difference is only detectable in the case of variables that outlive their scope via closures.\n  The `let` syntax accepts a comma-separated series of assignments and variable names:\n\n      let var1 = value1, var2, var3 = value3\n          code\n      end\n\n  The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like `let x = x`, since the two `x` variables are distinct and have separate storage.\n  \"\"\"\n\nkeywords[:quote] = doc\"\"\"\n  `quote` creates multiple expression objects in a block without using the explicit `Expr` constructor. For example:\n\n      ex = quote\n          x = 1\n          y = 2\n          x + y\n      end\n\n  Unlike the other means of quoting, `:( ... )`, this form introduces `QuoteNode` elements to the expression tree, which must be considered when directly manipulating the tree. For other purposes, `:( ... )` and `quote .. end` blocks are treated identically.\n  \"\"\"\n\nkeywords[symbol(\"'\")] = doc\"\"\"\n  `'` is the conjugate transposition operator:\n\n      > A = reshape(1:4, 2,2)\n      2x2 Array{Int64,2}:\n       1  3\n       2  4\n\n      > A'\n      2x2 Array{Int64,2}:\n       1  2\n       3  4\n\n      > B = A + im\n      2x2 Array{Complex{Int64},2}:\n       1+1im  3+1im\n       2+1im  4+1im\n\n      > B'\n      2x2 Array{Complex{Int64},2}:\n       1-1im  2-1im\n       3-1im  4-1im\n  \"\"\"\n\nkeywords[symbol(\".'\")] = doc\"\"\"\n  `.'` is the transposition operator:\n\n      > A = reshape(1:4, 2,2)\n      2x2 Array{Int64,2}:\n       1  3\n       2  4\n\n      > A.'\n      2x2 Array{Int64,2}:\n       1  2\n       3  4\n\n      > B = A + im\n      2x2 Array{Complex{Int64},2}:\n       1+1im  3+1im\n       2+1im  4+1im\n\n      > B.'\n      2x2 Array{Complex{Int64},2}:\n       1+1im  2+1im\n       3+1im  4+1im\n  \"\"\"\n\nkeywords[:const] = doc\"\"\"\n  `const` is used to declare global variables which are also constant.\n  In almost all code (and particularly performance sensitive code)\n  global variables should be declared constant in this way.\n\n      const x = 5\n\n  Note that \"constant-ness\" is not enforced inside containers, so if\n  `x` is an array or dictionary (for example) you can still add and remove\n  elements.\n\n  Technically, you can even redefine `const` variables, although this will\n  generate a warning from the compiler. The only strict requirement is that\n  the *type* of the variable does not change, which is why `const` variables\n  are much faster than regular globals.\n  \"\"\"\n\nkeywords[:function] = doc\"\"\"\n  Functions are defined with the `function` keyword:\n\n      function add(a, b)\n          return a + b\n      end\n\n  Or the short form notation:\n\n      add(a, b) = a + b\n\n  The use of the `return` keyword is exactly the same as in other languages,\n  but is often optional. When it's not used, the last expression in the function\n  body will be returned by default:\n\n      function compare(a, b)\n        a == b && return \"equal to\"\n        a < b ? \"less than\" : \"greater than\"\n      end\n  \"\"\"\n\nkeywords[:return] = doc\"\"\"\n  `return` can be used function bodies to exit early and return a given value,\n  e.g.\n\n      function compare(a, b)\n          a == b && return \"equal to\"\n          a < b ? \"less than\" : \"greater than\"\n      end\n\n  In general you can place a `return` statement anywhere within a function\n  body, including within deeply nested loops or conditionals, but be careful\n  with `do` blocks. For example:\n\n      function test1(xs)\n          for x in xs\n              iseven(x) && return 2x\n          end\n      end\n\n      function test2(xs)\n          map(xs) do x\n              iseven(x) && return 2x\n              x\n          end\n      end\n\n  In the first example, the return breaks out of its enclosing function\n  as soon as it hits an even number, so `test1([5,6,7])` returns `12`.\n\n  You might expect the second example to behave the same way, but in fact\n  the `return` there only breaks out of the *inner* function (inside the `do`\n  block) and gives a value back to `map`. `test2([5,6,7])` then returns `[5,12,7]`.\n  \"\"\"\n\nkeywords[:if]  = keywords[:elseif] = keywords[:else] = doc\"\"\"\n  `if`-`elseif`-`else` performs conditional evaluation, which allows portions of code to be evaluated or not evaluated depending on the value of a boolean expression.\n  Here is the anatomy of the `if`-`elseif`-`else` conditional syntax:\n\n      if x < y\n          println(\"x is less than y\")\n      elseif x > y\n          println(\"x is greater than y\")\n      else\n          println(\"x is equal to y\")\n      end\n\n  If the condition expression `x < y` is true, then the corresponding block is evaluated;\n  otherwise the condition expression `x > y` is evaluated, and if it is true, the corresponding block is evaluated; if neither expression is true, the `else` block is evaluated.\n  The `elseif` and `else` blocks are optional, and as many `elseif` blocks as desired can be used.\n  \"\"\"\n\nkeywords[:for] = doc\"\"\"\n  `for` loops repeatedly evaluate the body of the loop by iterating over a sequence of values.  For example:\n\n      for i in [1,4,0]\n          println(i)\n      end\n  \"\"\"\n\nkeywords[:while] = doc\"\"\"\n  `while` loops repeatedly evaluate a conditional expression, and continues evaluating the body of the while loop so long as\n  the expression remains `true`. If the condition expression is false when the while loop is first reached, the body is never evaluated.\n  For example:\n\n      while i <= 5\n          println(i)\n          i += 1\n      end\n  \"\"\"\n\nkeywords[:end] = doc\"\"\"\n  `end` marks the conclusion of a block of expressions.\n  In the example below, `end` marks the conclusion of a `function`.\n\n      function foo()\n          println(\"hello, world\")\n      end\n\n  `end` marks the conclusion of all kinds of expression blocks: `module`, `type`, `begin`, `let`, `for`, etc.\n\n  In addition, `end` may be used when indexing into an array to represent the last index of each dimension:\n\n      x[1:end, 2:end-1]\n  \"\"\"\n\nkeywords[:try] = keywords[:catch] = doc\"\"\"\n  A `try/catch` statement allows for `Exception`s to be tested for. For example, a customized square root function\n  can be written to automatically call either the real or complex square root method on demand using `Exception`s:\n\n      f(x) = try\n          sqrt(x)\n      catch\n          sqrt(complex(x, 0))\n      end\n\n  `try/catch` statements also allow the `Exception` to be saved in a variable, e.g. `catch y`.\n\n  The `catch` clause is not strictly necessary; when omitted, the default return value is `nothing`.\n  The power of the `try/catch` construct lies in the ability to unwind a deeply nested computation\n  immediately to a much higher level in the stack of calling functions.\n  \"\"\"\n\nkeywords[:finally] = doc\"\"\"\n  `finally` provides a way to run some code when a given block of code exits, regardless of how it exits.\n  For example, here is how we can guarantee that an opened file is closed:\n\n      f = open(\"file\")\n      try\n          operate_on_file(f)\n      finally\n          close(f)\n      end\n\n  When control leaves the `try` block (for example due to a `return`, or just finishing normally),\n  `close(f)` will be executed. If the `try` block exits due to an exception, the exception will continue propagating.\n  A `catch` block may be combined with `try` and `finally` as well.\n  In this case the `finally` block will run after `catch` has handled the error.\n  \"\"\"\n\nkeywords[:break] = doc\"\"\"\n  `break` breaks out of a loop immediately. For example\n\n      i = 0\n      while true\n          i += 1\n          i > 10 && break\n          println(i)\n      end\n\n  prints the numbers 1 to 10.\n  \"\"\"\n\nkeywords[:continue] = doc\"\"\"\n  `continue` skips the rest of the current loop, then carries on\n  looping. For example\n\n      for i = 1:10\n          iseven(i) && continue\n          println(i)\n      end\n\n  prints the numbers 1, 3, 5..., skipping the even numbers.\n  \"\"\"\n\nkeywords[:do] = doc\"\"\"\n  The `do` keyword creates an anonymous function. For example\n\n      map(1:10) do x\n          2x\n      end\n\n  is equivalent to `map(x->2x, 1:10)`.\n\n  Use multiple arguments like so:\n\n      map(1:10, 10:20) do x, y\n          x + y\n      end\n  \"\"\"\n\nkeywords[:...] = doc\"\"\"\n  The \"splat\" operator, `...`, represents a sequence of arguments. For example\n\n      add(xs...) = reduce(+, xs)\n\n  can take any number of arguments:\n\n      add(1, 2, 3, 4, 5)\n\n  `...` can also be used to apply a function to a sequence of arguments like so:\n\n      add([1, 2, 3]...) # 6\n      add(7, 1:100..., 1000:1100...) # 111107\n  \"\"\"\n\nkeywords[symbol(\";\")] = doc\"\"\"\n  `;` has a similar role in Julia as in many C-like languages,\n  and is used to delimit the end of the previous statement.\n  `;` is not necessary after new lines, but can be used to\n  separate statements on a single line or to join statements into\n  a single expression:\n\n      function foo()\n          println(\"Hello, \"); println(\"World!\")\n          return true\n      end\n\n      foo() = (println(\"Hello, World!\"); true)\n\n    `;` is also used to suppress output in the REPL and similar\n    interfaces.\n  \"\"\"\n\nkeywords[:(&&)]  = doc\"\"\"\n    x && y\n\nShort-circuiting boolean AND\n\"\"\"\n\nkeywords[:(||)]  = doc\"\"\"\n    x || y\n\nShort-circuiting boolean OR\n\"\"\"\n\nkeywords[:ccall] = doc\"\"\"\n      ccall((symbol, library) or function_pointer, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n\n  Call function in C-exported shared library, specified by\n  `(function name, library)` tuple, where each component is a string\n  or symbol.\n\n  Note that the argument type tuple must be a literal tuple, and not\n  a tuple-valued variable or expression. Alternatively, `ccall` may\n  also be used to call a function pointer, such as one returned by\n  `dlsym`.\n\n  Each `ArgumentValue` to the `ccall` will be converted to the\n  corresponding `ArgumentType`, by automatic insertion of calls to\n  `unsafe_convert(ArgumentType, cconvert(ArgumentType,\n  ArgumentValue))`. (See also the documentation for each of these\n  functions for further details.) In most cases, this simply results\n  in a call to `convert(ArgumentType, ArgumentValue)`.\n  \"\"\"\n\nkeywords[:llvmcall] = doc\"\"\"\n      llvmcall(IR::String, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n\n  Call LLVM IR string in the first argument. Similar to an LLVM function `define`\n  block, arguments are available as consecutive unnamed SSA variables (%0, %1, etc.).\n\n  Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.\n\n  Each `ArgumentValue` to `llvmcall` will be converted to the corresponding `ArgumentType`,\n  by automatic insertion of calls to `unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))`.\n  (see also the documentation for each of these functions for further details).\n  In most cases, this simply results in a call to `convert(ArgumentType, ArgumentValue)`.\n\n  See `test/llvmcall.jl` for usage examples.\n  \"\"\"\n\nkeywords[:begin] = doc\"\"\"\n  `begin...end` denotes a block of code.\n\n      begin\n          println(\"Hello, \")\n          println(\"World!\")\n      end\n\n  Usually `begin` will not be necessary, since keywords\n  such as `function` and `let` implicitly begin blocks of\n  code. See also `;`.\n  \"\"\"\n\nkeywords[:type] = doc\"\"\"\n  At their most basic, Julia types are specified as a name\n  and a set of fields.\n\n      type Point\n          x\n          y\n      end\n\n  Fields can have type restrictions, which may be parametrised:\n\n      type Point{X}\n          x::X\n          y::Float64\n      end\n\n  Type can also declare an abstract super type via `<:` syntax:\n\n      type Point <: AbstractPoint\n          ...\n\n  See the manual for more details, such as information on\n  inner constructors.\n  \"\"\"\n\nkeywords[:typealias] = doc\"\"\"\n  Introduce a new name for an already expressible type.\n  For example, in `base/boot.jl`, `UInt` is type aliased to either `UInt64` or `UInt32` as appropriate\n  for the size of pointers on the system:\n\n      if is(Int,Int64)\n          typealias UInt UInt64\n      else\n          typealias UInt UInt32\n      end\n\n  For parametric types, `typealias` can be convenient for providing names in cases where some parameter\n  choices are fixed.  In `base` for example:\n\n      typealias Vector{T} Array{T,1}\n  \"\"\"\n\nkeywords[:immutable] = doc\"\"\"\n  `immutable` acts in the same way as `type`, but declares\n  that the fields of the type may not be set after construction.\n  See `type` and the manual for more information.\n  \"\"\"\n\n# \"\"\"\n# Executes an expression, printing the time it took to\n# execute and the total number of bytes its execution caused to be\n# allocated. Returns the value of the expression. For example:\n#\n#     @time begin\n#         sleep(1)\n#         2+2\n#     end\n# \"\"\"\n# :@time\n\ndoc\"\"\"\n    @r_str -> Regex\nConstruct a regex, such as `r\"^[a-z]*$\"`. The regex also accepts\none or more flags, listed after the ending quote, to change its\nbehaviour:\n\n\u2022 `i` enables case-insensitive matching\n\u2022 `m` treats the `^` and `$` tokens as matching the start and\n  end of individual lines, as opposed to the whole string.\n\u2022 `s` allows the `.` modifier to match newlines.\n\u2022 `x` enables \"comment mode\": whitespace is enabled except when\n  escaped with `\\`, and `#` is treated as starting a comment.\n\nFor example, this regex has all three flags enabled:\n\n    julia> match(r\"a+.*b+.*?d$\"ism, \"Goodbye,\\nOh, angry,\\nBad world\\n\")\n    RegexMatch(\"angry,\\nBad world\")\n\"\"\"\n:(r\"\")\n\n# \"\"\"\n#     push!(collection, items...) \u2192 collection\n#\n# Insert `items` at the end of `collection`.\n#\n#     push!([1,2,3], 4) == [1,2,3,4]\n# \"\"\"\n# push!\n\nif Base.USE_GPL_LIBS\n\n@doc doc\"\"\"\n    fft(A [, dims])\n\nPerforms a multidimensional FFT of the array `A`.  The optional\n`dims` argument specifies an iterable subset of dimensions (e.g.\nan integer, range, tuple, or array) to transform along.  Most\nefficient if the size of `A` along the transformed dimensions is\na product of small primes; see `nextprod()`.  See also\n`plan_fft()` for even greater efficiency.\n\nA one-dimensional FFT computes the one-dimensional discrete Fourier\ntransform (DFT) as defined by\n\n$$\\operatorname{DFT}(A)[k] =\n  \\sum_{n=1}^{\\operatorname{length}(A)}\n  \\exp\\left(-i\\frac{2\\pi\n  (n-1)(k-1)}{\\operatorname{length}(A)} \\right) A[n].$$\n\nA multidimensional FFT simply performs this operation along each\ntransformed dimension of `A`.\n\nHigher performance is usually possible with multi-threading. Use\n`FFTW.set_num_threads(np)` to use `np` threads, if you have `np`\nprocessors.\n\"\"\" fft\n\nend # USE_GPL_LIBS\n\n\"\"\"\n    include(path::AbstractString)\n\nEvaluate the contents of a source file in the current context.\nDuring including, a task-local include path is set to the directory\ncontaining the file. Nested calls to `include` will search\nrelative to that path. All paths refer to files on node 1 when\nrunning in parallel, and files will be fetched from node 1. This\nfunction is typically used to load source interactively, or to\ncombine files in packages that are broken into multiple source\nfiles.\n\"\"\"\ninclude_from_node1(::AbstractString)\n\n\"\"\"\n0 (zero; BrE: `/\u02c8z\u026a\u0259r\u0259\u028a/` or AmE: `/\u02c8zi\u02d0ro\u028a/`) is both a number and the numerical digit used to represent that number in numerals. It fulfills a central role in mathematics as the additive identity of the integers, real numbers, and many other algebraic structures. As a digit, 0 is used as a placeholder in place value systems. Names for the number 0 in English include zero, nought or (US) naught (`/\u02c8n\u0254\u02d0t/`), nil, or \u2014 in contexts where at least one adjacent digit distinguishes it from the letter \"O\" \u2014 oh or o (`/\u02c8o\u028a/`). Informal or slang terms for zero include zilch and zip. Ought and aught (/\u02c8\u0254\u02d0t/), as well as cipher, have also been used historically.\n\"\"\"\n0\n"
    },
    "skipped": [
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/objects.inv",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/_static/up.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/_static/minus.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/_static/down.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/_static/comment-close.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/_static/up-pressed.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/_static/plus.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/_static/ajax-loader.gif",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/_static/comment-bright.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/_static/comment.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/_static/down-pressed.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/_static/file.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/_static/fonts/fontawesome-webfont.woff",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/_static/fonts/fontawesome-webfont.ttf",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/_static/fonts/fontawesome-webfont.eot",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/_build/html/_static/fonts/FontAwesome.otf",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/images/travis-icon.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/images/jltypes.ai",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/images/github_metadata_pullrequest.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/images/github_metadata_fork.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/doc/images/github_metadata_develbranch.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/virtualenv-1.11.6.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/utf8proc-85789180158ac7fff85b9f008828d6ac44f072ea.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/SuiteSparse-4.4.2.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/Rmath-julia-0.1.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/pcre2-10.20.tar.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/patchelf-0.8.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/openspecfun-381db9bc865e51de67be9dcaa1610a6f90029c72.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/openlibm-3ee2a6e6a9fc68cbf2ab00f830b9059215e40b06.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/openblas-53e849f4fcae4363a64576de00e982722c7304f9.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/objconv.zip",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/mpfr-3.1.2.tar.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/llvm-3.3.src.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/libuv-efb40768b7c7bd9f173a7868f74b92b1c5a61a0e.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/libunwind-1.1.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/libosxunwind-0.0.1.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/libgit2-f6dedf2c2eb806e2a6fdd4cf31f68386efc2ee0b.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/lapack-3.5.0.tgz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/gmp-6.0.0.tar.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/fftw-3.3.4.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/dsfmt-2.2.3.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/deps/arpack-ng-3.2.0.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/contrib/windows/julia.ico",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/contrib/windows/7zS.sfx",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.4.5-u5dqg6lrftpmfstkotl6cxgwifzjmoxz/spack-src/contrib/mac/app/julia.icns"
    ],
    "total_files": 1023
}