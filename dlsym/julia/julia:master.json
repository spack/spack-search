{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/HISTORY.md": "Julia v1.6 Release Notes\n========================\n\nNew language features\n---------------------\n\n* Types written with `where` syntax can now be used to define constructors, e.g.\n  `(Foo{T} where T)(x) = ...`.\n* `<--` and `<-->` are now available as infix operators, with the same precedence\n  and associativity as other arrow-like operators ([#36666]).\n* Compilation and type inference can now be enabled or disabled at the module level\n  using the experimental macro `Base.Experimental.@compiler_options` ([#37041]).\n* The library name passed to `ccall` or `@ccall` can now be an expression involving\n  global variables and function calls. The expression will be evaluated the first\n  time the `ccall` executes ([#36458]).\n* `\ua71b` (U+A71B), `\ua71c` (U+A71C) and `\ua71d` (U+A71D) can now also be used as operator\n  suffixes. They can be tab-completed from `\\^uparrow`, `\\^downarrow` and `\\^!` in the REPL\n  ([#37542]).\n* Standalone \"dotted\" operators now get parsed as `Expr(:., :op)`, which gets lowered to\n  `Base.BroadcastFunction(op)`. This means `.op` is functionally equivalent to\n  `(x...) -> (op).(x...)`, which can be useful for passing the broadcasted version of an\n  operator to higher-order functions, for example `map(.*, A, B)` for an elementwise\n  product of two arrays of arrays ([#37583]).\n* The syntax `import A as B` (plus `import A: x as y`, `import A.x as y`, and `using A: x as y`)\n  can now be used to rename imported modules and identifiers ([#1255]).\n* Unsigned literals (starting with `0x`) which are too big to fit in a `UInt128` object\n  are now interpreted as `BigInt` ([#23546]).\n* It is now possible to use `...` on the left-hand side of assignments for taking any\n  number of items from the front of an iterable collection, while also collecting the rest,\n  for example `a, b... = [1, 2, 3]`. This syntax is implemented using `Base.rest`,\n  which can be overloaded to customize its behavior for different collection types\n  ([#37410]).\n\nLanguage changes\n----------------\n\n* The postfix conjugate transpose operator `'` now accepts Unicode modifiers as\n  suffixes, so e.g. `a'\u1d40` is parsed as `var\"'\u1d40\"(a)`, which can be defined by the\n  user. `a'\u1d40` parsed as `a' * \u1d40` before, so this is a minor breaking change ([#37247]).\n* Macros that return `:quote` expressions (e.g. via `Expr(:quote, ...)`) were previously\n  able to work without escaping (`esc(...)`) their output when needed. This has been\n  corrected, and now `esc` must be used in these macros as it is in other macros ([#37540]).\n* The `-->` operator now lowers to a `:call` expression, so it can be defined as\n  a function like other operators. The dotted version `.-->` is now parsed as well.\n  For backwards compatibility, `-->` still parses using its own expression head\n  instead of `:call`.\n* The `a[begin, k]` syntax now calls `firstindex(a, 1)` rather than `first(axes(a, 1))` ([#35779]),\n  but the former now defaults to the latter for any `a` ([#38742]).\n* `\u233f` (U+233F) and `\u00a6` (U+00A6) are now infix operators with times-like and plus-like precedence,\n  respectively. Previously they were parsed as identifier characters ([#37973]).\n\nCompiler/Runtime improvements\n-----------------------------\n\n* All platforms can now use `@executable_path` within `jl_load_dynamic_library()`.\n  This allows executable-relative paths to be embedded within executables on all\n  platforms, not just MacOS, which the syntax is borrowed from ([#35627]).\n* Constant propagation now occurs through keyword arguments ([#35976]).\n* The precompilation cache is now created atomically ([#36416]). Invoking _n_\n  Julia processes simultaneously may create _n_ temporary caches.\n\nCommand-line option changes\n---------------------------\n\n* There is no longer a concept of \"home project\": starting `julia --project=dir`\n  is now exactly equivalent to starting `julia` and then doing `pkg> activate\n  $dir` and `julia --project` is exactly equivalent to doing that where\n  `dir = Base.current_project()`. In particular, this means that if you do\n  `pkg> activate` after starting `julia` with the `--project` option (or with\n  `JULIA_PROJECT` set) it will take you to the default active project, which is\n  `@v1.6` unless you have modified `LOAD_PATH` ([#36434]).\n\nMulti-threading changes\n-----------------------\n\n* Locks now automatically inhibit finalizers from running, to avoid deadlock ([#38487]).\n* New function `Base.Threads.foreach(f, channel::Channel)` for multithreaded `Channel` consumption ([#34543]).\n\nBuild system changes\n--------------------\n\n* Windows Installer now has the option to 'Add Julia to Path'. To unselect this option\n  from the commandline simply remove the tasks you do not want to be installed: e.g.\n  `./julia-installer.exe /TASKS=\"desktopicon,startmenu,addtopath\"`, adds a desktop\n  icon, a startmenu group icon, and adds Julia to system PATH.\n\nNew library functions\n---------------------\n\n* New function `Base.kron!` and corresponding overloads for various matrix types for performing Kronecker\n  product in-place ([#31069]).\n* New function `Base.readeach(io, T)` for iteratively performing `read(io, T)` ([#36150]).\n* `Iterators.map` is added. It provides another syntax `Iterators.map(f, iterators...)`\n  for writing `(f(args...) for args in zip(iterators...))`, i.e. a lazy `map` ([#34352]).\n* New function `sincospi` for simultaneously computing `sinpi(x)` and `cospi(x)` more\n  efficiently ([#35816]).\n* New function `cispi(x)` for more accurately computing `cis(pi * x)` ([#38449]).\n* New function `addenv` for adding environment mappings into a `Cmd` object, returning the new `Cmd` object.\n* New function `insorted` for determining whether an element is in a sorted collection or not ([#37490]).\n* New function `Base.rest` for taking the rest of a collection, starting from a specific\n  iteration state, in a generic way ([#37410]).\n\nNew library features\n--------------------\n\n* The `redirect_*` functions now accept `devnull` to discard all output redirected to it, and as an empty\n  input ([#36146]).\n* The `redirect_*` functions can now be called on `IOContext` objects ([#36688]).\n* `findfirst`, `findnext`, `findlast`, and `findall` now support `AbstractVector{<:Union{Int8,UInt8}}`\n  (pattern, array) arguments ([#37283]).\n* New constructor `NamedTuple(iterator)` that constructs a named tuple from a key-value pair iterator.\n* A new `reinterpret(reshape, T, a::AbstractArray{S})` reinterprets `a` to have eltype `T` while potentially\n  inserting or consuming the first dimension depending on the ratio of `sizeof(T)` and `sizeof(S)`.\n* New `append!(vector, collections...)` and `prepend!(vector, collections...)` methods accept multiple\n  collections to be appended or prepended ([#36227]).\n* The postfix operator `'\u1d40` can now be used as an alias for `transpose` ([#38062]).\n* `keys(io::IO)` has been added, which returns all keys of `io` if `io` is an `IOContext` and an empty\n  `Base.KeySet` otherwise ([#37753]).\n* `count` now accepts an optional `init` argument to control the accumulation type ([#37461]).\n* New method `occursin(haystack)` that returns a function that checks whether its argument occurs in\n  `haystack` ([#38475]).\n* New methods `\u2209(collection)`, `\u220b(item)`, and `\u220c(item)` returning corresponding containment-testing\n  functions ([#38475]).\n* The `nextprod` function now accepts tuples and other array types for its first argument ([#35791]).\n* The `reverse(A; dims)` function for multidimensional `A` can now reverse multiple dimensions at once\n  by passing a tuple for `dims`, and defaults to reversing all dimensions; there is also a multidimensional\n  in-place `reverse!(A; dims)` ([#37367]).\n* The function `isapprox(x,y)` now accepts the `norm` keyword argument also for numeric (i.e., non-array)\n  arguments `x` and `y` ([#35883]).\n* `ispow2(x)` now supports non-`Integer` arguments `x` ([#37635]).\n* `view`, `@view`, and `@views` now work on `AbstractString`s, returning a `SubString` when appropriate ([#35879]).\n* All `AbstractUnitRange{<:Integer}`s now work with `SubString`, `view`, `@view` and `@views` on strings ([#35879]).\n* `sum`, `prod`, `maximum`, and `minimum` now support `init` keyword argument ([#36188], [#35839]).\n* `unique(f, itr; seen=Set{T}())` now allows you to declare the container type used for\n  keeping track of values returned by `f` on elements of `itr` ([#36280]).\n* `first` and `last` functions now accept an integer as second argument to get that many\n  leading or trailing elements of any iterable ([#34868]).\n* `CartesianIndices` now supports step different from `1`. It can also be constructed from three\n  `CartesianIndex`es `I`, `S`, `J` using `I:S:J`. `step` for `CartesianIndices` now returns a\n  `CartesianIndex` ([#37829]).\n* `RegexMatch` objects can now be probed for whether a named capture group exists within it through `haskey()` ([#36717]).\n* For consistency `haskey(r::RegexMatch, i::Integer)` has also been added and returns if the capture group\n  for `i` exists ([#37300]).\n\nStandard library changes\n------------------------\n\n* A new standard library `TOML` has been added for parsing and printing [TOML files](https://toml.io) ([#37034]).\n* A new standard library `Downloads` has been added, which replaces the old `Base.download` function with\n  `Downloads.download`, providing cross-platform, multi-protocol, in-process download functionality implemented\n  with [libcurl](https://curl.haxx.se/libcurl/) ([#37340]).\n* `Libdl` has been moved to `Base.Libc.Libdl`, however it is still accessible as an stdlib ([#35628]).\n* To download artifacts lazily, `LazyArtifacts` now must be explicitly listed as a dependency, to avoid needing the\n  support machinery to be available when it is not commonly needed ([#37844]).\n* It is no longer possible to create a `LinRange`, `StepRange`, or `StepRangeLen` with a `<: Integer` eltype but\n  non-integer step ([#32439]).\n* `intersect` on `CartesianIndices` now returns `CartesianIndices` instead of `Vector{<:CartesianIndex}` ([#36643]).\n* `push!(c::Channel, v)` now returns channel `c`. Previously, it returned the pushed value `v` ([#34202]).\n* The composition operator `\u2218` now returns a `Base.ComposedFunction` instead of an anonymous function ([#37517]).\n* Logging (such as `@warn`) no longer catches exceptions in the logger itself ([#36600]).\n* `@time` now reports if the time presented included any compilation time, which is shown as a percentage ([#37678]).\n* `@varinfo` can now report non-exported objects within modules, look recursively into submodules, and return a sorted\n  results table ([#38042]).\n* `@testset` now supports the option `verbose` to show the test result summary\n  of the children even if they all pass ([#33755]).\n\n#### Package Manager\n\n* `pkg> precompile` is now parallelized through depth-first precompilation of dependencies. Errors will only throw for\n  direct dependencies listed in the `Project.toml`.\n* `pkg> precompile` is now automatically triggered whenever Pkg changes the active manifest. Auto-precompilation will\n  remember if a package has errored within the given environment and will not retry until it changes.\n  Auto-precompilation can be gracefully interrupted with a `ctrl-c` and disabled by setting the environment variable\n  `JULIA_PKG_PRECOMPILE_AUTO=0`.\n* The `Pkg.BinaryPlatforms` module has been moved into `Base` as `Base.BinaryPlatforms` and heavily reworked.\n  Applications that want to be compatible with the old API should continue to import `Pkg.BinaryPlatforms`,\n  however new users should use `Base.BinaryPlatforms` directly ([#37320]).\n* The `Pkg.Artifacts` module has been imported as a separate standard library.  It is still available as\n  `Pkg.Artifacts`, however starting from Julia v1.6+, packages may import simply `Artifacts` without importing\n  all of `Pkg` alongside ([#37320]).\n\n#### LinearAlgebra\n\n* New method `LinearAlgebra.issuccess(::CholeskyPivoted)` for checking whether pivoted Cholesky factorization was\n  successful ([#36002]).\n* `UniformScaling` can now be indexed into using ranges to return dense matrices and vectors ([#24359]).\n* New function `LinearAlgebra.BLAS.get_num_threads()` for getting the number of BLAS threads ([#36360]).\n* `(+)(::UniformScaling)` is now defined, making `+I` a valid unary operation ([#36784]).\n* Instances of `UniformScaling` are no longer `isequal` to matrices. Previous\n  behaviour violated the rule that `isequal(x, y)` implies `hash(x) == hash(y)`.\n* Transposing `*Triangular` matrices now returns matrices of the opposite triangular type, consistently\n  with `adjoint!(::*Triangular)` and `transpose!(::*Triangular)`. Packages containing methods with, e.g.,\n  `Adjoint{<:Any,<:LowerTriangular{<:Any,<:OwnMatrixType}}` should replace that by\n  `UpperTriangular{<:Any,<:Adjoint{<:Any,<:OwnMatrixType}}` in the method signature ([#38168]).\n\n#### Markdown\n\n\n#### Printf\n\n* Complete overhaul of internal code to use the ryu float printing algorithms (from Julia 1.4); leads to\n  consistent 2-5x performance improvements.\n* New `Printf.tofloat` function allowing custom float types to more easily integrate with Printf formatting\n  by converting their type to `Float16`, `Float32`, `Float64`, or `BigFloat`.\n* New `Printf.format\"...\"` and `Printf.Format(...)` functions that allow creating `Printf.Format` objects\n  that can be passed to `Printf.format` for easier dynamic printf formatting.\n* `Printf.format(f::Printf.Format, args...)` as a non-macro function that applies a printf format `f` to\n  provided `args`.\n\n#### Random\n\n\n#### REPL\n\n* The `AbstractMenu` extension interface of `REPL.TerminalMenus` has been extensively\n  overhauled. The new interface does not rely on global configuration variables, is more\n  consistent in delegating printing of the navigation/selection markers, and provides\n  improved support for dynamic menus.  These changes are compatible with the previous\n  (deprecated) interface, so are non-breaking.\n\n  The new API offers several enhancements:\n\n  + Menus are configured in their constructors via keyword arguments.\n  + For custom menu types, the new `Config` and `MultiSelectConfig` replace the global `CONFIG` `Dict`.\n  + `request(menu; cursor=1)` allows you to control the initial cursor position in the menu (defaults to first item).\n  + `MultiSelectMenu` allows you to pass a list of initially-selected items with the `selected` keyword argument.\n  + `writeLine` was deprecated to `writeline`, and `writeline` methods are not expected to print the cursor indicator.\n    The old `writeLine` continues to work, and any of its method extensions should print the cursor indicator as before.\n  + `printMenu` has been deprecated to `printmenu`, and it both accepts a state input and returns a state output\n    that controls the number of terminal lines erased when the menu is next refreshed. This plus related changes\n    makes `printmenu` work properly when the number of menu items might change depending on user choices.\n  + `numoptions`, returning the number of items in the menu, has been added as an alternative to implementing `options`.\n  + `suppress_output` (primarily a testing option) has been added as a keyword argument to `request`,\n    rather than a configuration option.\n* Tab completion now supports runs of consecutive sub/superscript characters,\n  e.g. `\\^(3)` tab-completes to `\u207d\u00b3\u207e` ([#38649]).\n* Windows REPL now supports 24-bit colors, by correctly interpreting virtual terminal escapes.\n\n#### SparseArrays\n\n* Display large sparse matrices with a Unicode \"spy\" plot of their nonzero patterns,\n  and display small sparse matrices by an `Matrix`-like 2d layout of their contents ([#33821]).\n* New convenient `spdiagm([m, n,] v::AbstractVector)` methods which call\n  `spdiagm([m, n,] 0 => v)`, consistently with their dense `diagm` counterparts ([#37684]).\n\n#### Dates\n\n* `Quarter` period is defined ([#35519]).\n* `canonicalize` can now take `Period` as an input ([#37391]).\n* Zero-valued `FixedPeriod`s and `OtherPeriod`s now compare equal, e.g.,\n  `Year(0) == Day(0)`. The behavior of non-zero `Period`s is not changed ([#37486]).\n\n#### Statistics\n\n\n#### Sockets\n\n\n#### Distributed\n\n* Now supports invoking Windows workers via ssh (via new keyword argument `shell=:wincmd` in `addprocs`) ([#30614]).\n* Other new keyword arguments in `addprocs`: `ssh` to specify the ssh client path, `env` to pass environment\n  variables to workers, and `cmdline_cookie` to work around an ssh problem with Windows workers that run older\n  (pre-ConPTY) versions of Windows, Julia or OpenSSH ([#30614]).\n\n#### UUIDs\n\n* Change `uuid1` and `uuid4` to use `Random.RandomDevice()` as default random number generator ([#35872]).\n* Added `parse(::Type{UUID}, ::AbstractString)` method.\n\n#### Mmap\n\n* On Unix systems, the `Mmap.madvise!` function (along with OS-specific `Mmap.MADV_*`\n  constants) has been added to give advice on handling of memory-mapped arrays ([#37369]).\n\nDeprecated or removed\n---------------------\n\n* The `Base.download` function has been deprecated (silently, by default) in favor of the new `Downloads.download`\n  standard library function ([#37340]).\n* The `Base.Grisu` code has been officially removed (float printing was switched to the ryu algorithm code in 1.4).\n  The code is available from [JuliaAttic](https://github.com/JuliaAttic/Grisu.jl) if needed.\n\nExternal dependencies\n---------------------\n\n\nTooling Improvements\n---------------------\n\n\n<!--- generated by NEWS-update.jl: -->\n[#1255]: https://github.com/JuliaLang/julia/issues/1255\n[#23546]: https://github.com/JuliaLang/julia/issues/23546\n[#24359]: https://github.com/JuliaLang/julia/issues/24359\n[#30614]: https://github.com/JuliaLang/julia/issues/30614\n[#31069]: https://github.com/JuliaLang/julia/issues/31069\n[#32439]: https://github.com/JuliaLang/julia/issues/32439\n[#33755]: https://github.com/JuliaLang/julia/issues/33755\n[#33821]: https://github.com/JuliaLang/julia/issues/33821\n[#34202]: https://github.com/JuliaLang/julia/issues/34202\n[#34352]: https://github.com/JuliaLang/julia/issues/34352\n[#34543]: https://github.com/JuliaLang/julia/issues/34543\n[#34868]: https://github.com/JuliaLang/julia/issues/34868\n[#35519]: https://github.com/JuliaLang/julia/issues/35519\n[#35627]: https://github.com/JuliaLang/julia/issues/35627\n[#35628]: https://github.com/JuliaLang/julia/issues/35628\n[#35779]: https://github.com/JuliaLang/julia/issues/35779\n[#35791]: https://github.com/JuliaLang/julia/issues/35791\n[#35816]: https://github.com/JuliaLang/julia/issues/35816\n[#35839]: https://github.com/JuliaLang/julia/issues/35839\n[#35872]: https://github.com/JuliaLang/julia/issues/35872\n[#35879]: https://github.com/JuliaLang/julia/issues/35879\n[#35883]: https://github.com/JuliaLang/julia/issues/35883\n[#35976]: https://github.com/JuliaLang/julia/issues/35976\n[#36002]: https://github.com/JuliaLang/julia/issues/36002\n[#36146]: https://github.com/JuliaLang/julia/issues/36146\n[#36150]: https://github.com/JuliaLang/julia/issues/36150\n[#36188]: https://github.com/JuliaLang/julia/issues/36188\n[#36227]: https://github.com/JuliaLang/julia/issues/36227\n[#36280]: https://github.com/JuliaLang/julia/issues/36280\n[#36360]: https://github.com/JuliaLang/julia/issues/36360\n[#36416]: https://github.com/JuliaLang/julia/issues/36416\n[#36434]: https://github.com/JuliaLang/julia/issues/36434\n[#36458]: https://github.com/JuliaLang/julia/issues/36458\n[#36600]: https://github.com/JuliaLang/julia/issues/36600\n[#36643]: https://github.com/JuliaLang/julia/issues/36643\n[#36666]: https://github.com/JuliaLang/julia/issues/36666\n[#36688]: https://github.com/JuliaLang/julia/issues/36688\n[#36717]: https://github.com/JuliaLang/julia/issues/36717\n[#36784]: https://github.com/JuliaLang/julia/issues/36784\n[#37034]: https://github.com/JuliaLang/julia/issues/37034\n[#37041]: https://github.com/JuliaLang/julia/issues/37041\n[#37247]: https://github.com/JuliaLang/julia/issues/37247\n[#37283]: https://github.com/JuliaLang/julia/issues/37283\n[#37300]: https://github.com/JuliaLang/julia/issues/37300\n[#37320]: https://github.com/JuliaLang/julia/issues/37320\n[#37340]: https://github.com/JuliaLang/julia/issues/37340\n[#37367]: https://github.com/JuliaLang/julia/issues/37367\n[#37369]: https://github.com/JuliaLang/julia/issues/37369\n[#37391]: https://github.com/JuliaLang/julia/issues/37391\n[#37410]: https://github.com/JuliaLang/julia/issues/37410\n[#37461]: https://github.com/JuliaLang/julia/issues/37461\n[#37486]: https://github.com/JuliaLang/julia/issues/37486\n[#37490]: https://github.com/JuliaLang/julia/issues/37490\n[#37517]: https://github.com/JuliaLang/julia/issues/37517\n[#37540]: https://github.com/JuliaLang/julia/issues/37540\n[#37542]: https://github.com/JuliaLang/julia/issues/37542\n[#37583]: https://github.com/JuliaLang/julia/issues/37583\n[#37635]: https://github.com/JuliaLang/julia/issues/37635\n[#37678]: https://github.com/JuliaLang/julia/issues/37678\n[#37684]: https://github.com/JuliaLang/julia/issues/37684\n[#37753]: https://github.com/JuliaLang/julia/issues/37753\n[#37829]: https://github.com/JuliaLang/julia/issues/37829\n[#37844]: https://github.com/JuliaLang/julia/issues/37844\n[#37973]: https://github.com/JuliaLang/julia/issues/37973\n[#38042]: https://github.com/JuliaLang/julia/issues/38042\n[#38062]: https://github.com/JuliaLang/julia/issues/38062\n[#38168]: https://github.com/JuliaLang/julia/issues/38168\n[#38449]: https://github.com/JuliaLang/julia/issues/38449\n[#38475]: https://github.com/JuliaLang/julia/issues/38475\n[#38487]: https://github.com/JuliaLang/julia/issues/38487\n[#38649]: https://github.com/JuliaLang/julia/issues/38649\n[#38742]: https://github.com/JuliaLang/julia/issues/38742\n\n\nJulia v1.5 Release Notes\n========================\n\nNew language features\n---------------------\n\n* Macro calls `@foo {...}` can now also be written `@foo{...}` (without the space) ([#34498]).\n* `\u2a1f` is now parsed as a binary operator with times precedence. It can be entered in the REPL\n  with `\\bbsemi` followed by <kbd>TAB</kbd> ([#34722]).\n* `\u00b1` and `\u2213` are now unary operators as well, like `+` or `-`. Attention has to be paid in\n  macros and matrix constructors, which are whitespace sensitive, because expressions like\n  `[a \u00b1b]` now get parsed as `[a \u00b1(b)]` instead of `[\u00b1(a, b)]` ([#34200]).\n* Passing an identifier `x` by itself as a keyword argument or named tuple element\n  is equivalent to `x=x`, implicitly using the name of the variable as the keyword\n  or named tuple field name.\n  Similarly, passing an `a.b` expression uses `b` as the keyword or field name ([#29333]).\n* Support for Unicode 13.0.0 (via utf8proc 2.5) ([#35282]).\n* The compiler optimization level can now be set per-module using the experimental macro\n  `Base.Experimental.@optlevel n`. For code that is not performance-critical, setting\n  this to 0 or 1 can provide significant latency improvements ([#34896]).\n\nLanguage changes\n----------------\n\n* The interactive REPL now uses \"soft scope\" for top-level expressions: an assignment inside a\n  scope block such as a `for` loop automatically assigns to a global variable if one has been\n  defined already. This matches the behavior of Julia versions 0.6 and prior, as well as\n  [IJulia](https://github.com/JuliaLang/IJulia.jl).\n  Note that this only affects expressions interactively typed or pasted directly into the\n  default REPL ([#28789], [#33864]).\n* Outside of the REPL (e.g. in a file), assigning to a variable within a top-level scope\n  block is considered ambiguous if a global variable with the same name exists.\n  A warning is given if that happens, to alert you that the code will work differently\n  than in the REPL.\n  A new command line option `--warn-scope` controls this warning ([#33864]).\n* Converting arbitrary tuples to `NTuple`, e.g. `convert(NTuple, (1, \"\"))` now gives an error,\n  where it used to be incorrectly allowed. This is because `NTuple` refers only to homogeneous\n  tuples (this meaning has not changed) ([#34272]).\n* The syntax `(;)` (which was deprecated in v1.4) now creates an empty named tuple ([#30115]).\n* `@inline` macro can now be applied to short-form anonymous functions ([#34953]).\n* In triple-quoted string literals, whitespace stripping is now done before processing\n  escape sequences instead of after. For example, the syntax\n  ```\n  \"\"\"\n    a\\n b\"\"\"\n  ```\n  used to yield the string \" a\\nb\", since the single space before `b` set the indent level.\n  Now the result is \"a\\n b\", since the space before `b` is no longer considered to occur\n  at the start of a line. The old behavior is considered a bug ([#35001]).\n* `<:` and `>:` can now be broadcasted over arrays with `.<:` and `.>:`  ([#35085])\n* The line number of function definitions is now added by the parser as an\n  additional `LineNumberNode` at the start of each function body ([#35138]).\n* Statements of the form `a'` now get lowered to `var\"'\"(a)` instead of `Base.adjoint(a)`. This\n  allows for shadowing this function in local scopes, although this is generally discouraged.\n  By default, Base exports `var\"'\"` as an alias of `Base.adjoint`, so custom types should still\n  extend `Base.adjoint` ([#34634]).\n\nCompiler/Runtime improvements\n-----------------------------\n\n* Immutable structs (including tuples) that contain references can now be allocated\n  on the stack, and allocated inline within arrays and other structs ([#33886]).\n  This significantly reduces the number of heap allocations in some workloads.\n  Code that requires assumptions about object layout and addresses (usually for\n  interoperability with C or other languages) might need to be updated; for\n  example any object that needs a stable address should be a `mutable struct`.\n  As a result, Array `view`s no longer allocate ([#34126]).\n\nCommand-line option changes\n---------------------------\n\n* Deprecation warnings are no longer shown by default. i.e. if the `--depwarn=...` flag is\n  not passed it defaults to `--depwarn=no`. The warnings are printed from tests run by\n  `Pkg.test()` ([#35362]).\n* Color now defaults to on when stdout and stderr are TTYs ([#34347]).\n* `-t N`, `--threads N` starts Julia with `N` threads. This option takes precedence over\n  `JULIA_NUM_THREADS`. The specified number of threads also propagates to worker\n  processes spawned using the `-p`/`--procs` or `--machine-file` command line arguments.\n  In order to set number of threads for worker processes spawned with `addprocs` use the\n  `exeflags` keyword argument, e.g. ```addprocs(...; exeflags=`--threads 4`)``` ([#35108]).\n\nMulti-threading changes\n-----------------------\n\n* Parts of the multi-threading API are now considered stable, with caveats.\n  This includes all documented identifiers from `Base.Threads` except the\n  `atomic_` operations.\n* `@threads` now allows an optional schedule argument. Use `@threads :static ...` to\n  ensure that the same schedule will be used as in past versions; the default schedule\n  is likely to change in the future.\n\nBuild system changes\n--------------------\n\n* The build system now contains a pure-make caching system for expanding expensive operations at the latest\n  possible moment, while still expanding it only once ([#35626]).\n\nNew library functions\n---------------------\n\n* Packages can now provide custom hints to help users resolve errors by using the\n  experimental `Base.Experimental.register_error_hint` function.\n  Packages that define custom exception types can support hints by calling the\n  `Base.Experimental.show_error_hints` from their `showerror` method ([#35094]).\n* The `@ccall` macro has been added to Base. It is a near drop-in replacement for `ccall` with more Julia-like syntax. It also wraps the new `foreigncall` API for varargs of different types, though it lacks the capability to specify an LLVM calling convention ([#32748]).\n* New functions `mergewith` and `mergewith!` supersede `merge` and `merge!` with `combine`\n  argument.  They don't have the restriction for `combine` to be a `Function` and also\n  provide one-argument method that returns a closure.  The old methods of `merge` and\n  `merge!` are still available for backward compatibility ([#34296]).\n* The new `isdisjoint` function indicates whether two collections are disjoint ([#34427]).\n* Add function `ismutable` and deprecate `isimmutable` to check whether something is mutable ([#34652]).\n* `include` now accepts an optional `mapexpr` first argument to transform the parsed\n  expressions before they are evaluated ([#34595]).\n* New function `bitreverse` for reversing the order of bits in a fixed-width integer ([#34791]).\n* New function `bitrotate(x, k)` for rotating the bits in a fixed-width integer ([#33937]).\n* New function `contains(haystack, needle)` and its one argument partially applied form have been added, it acts like `occursin(needle, haystack)` ([#35132]).\n* New function `Base.exit_on_sigint` is added to control if `InterruptException` is\n  thrown by Ctrl-C ([#29411]).\n\nNew library features\n--------------------\n\n* Function composition now works also on one argument `\u2218(f) = f` (#34251).\n* One argument methods `startswith(x)` and `endswith(x)` have been added, returning partially-applied versions of the functions, similar to existing methods like `isequal(x)` ([#33193]).\n* `isapprox` (or `\u2248`) now has a one-argument \"curried\" method `isapprox(x)` which returns a function, like `isequal` (or `==`) ([#32305]).\n* `@NamedTuple{key1::Type1, ...}` macro for convenient `NamedTuple` declarations ([#34548]).\n* `Ref{NTuple{N,T}}` can be passed to `Ptr{T}`/`Ref{T}` `ccall` signatures ([#34199]).\n* `x::Signed % Unsigned` and `x::Unsigned % Signed` are supported for integer bitstypes.\n* `signed(unsigned_type)` is supported for integer bitstypes, `unsigned(signed_type)` has been supported.\n* `accumulate`, `cumsum`, and `cumprod` now support `Tuple` ([#34654]) and arbitrary iterators ([#34656]).\n* `pop!(collection, key, [default])` now has a method for `Vector` to remove an element at an arbitrary index ([#35513]).\n* In `splice!` with no replacement, values to be removed can now be specified with an\n  arbitrary iterable (instead of a `UnitRange`) ([#34524]).\n* The `@view` and `@views` macros now support the `a[begin]` syntax that was introduced in Julia 1.4 ([#35289]).\n* `open` for files now accepts a keyword argument `lock` controlling whether file operations\n  will acquire locks for safe multi-threaded access. Setting it to `false` provides better\n  performance when only one thread will access the file ([#35426]).\n* The introspection macros (`@which`, `@code_typed`, etc.) now work with `do`-block syntax ([#35283]) and with dot syntax ([#35522]).\n* `count` now accepts the `dims` keyword.\n* new in-place `count!` function similar to `sum!`.\n* `peek` is now exported and accepts a type to peek from a stream ([#28811]).\n\nStandard library changes\n------------------------\n\n* Empty ranges now compare equal, regardless of their startpoint and step ([#32348]).\n* A 1-d `Zip` iterator (where `Base.IteratorSize` is `Base.HasShape{1}()`) with defined length of `n` has now also size of `(n,)` (instead of throwing an error with truncated iterators) ([#29927]).\n* The `@timed` macro now returns a `NamedTuple` ([#34149]).\n* New `supertypes(T)` function returns a tuple of all supertypes of `T` ([#34419]).\n* Views of builtin ranges are now recomputed ranges (like indexing returns) instead of\n  `SubArray`s ([#26872]).\n* Sorting-related functions such as `sort` that take the keyword arguments `lt`, `rev`, `order`\n  and `by` now do not discard `order` if `by` or `lt` are passed. In the former case, the\n  order from `order` is used to compare the values of `by(element)`. In the latter case,\n  any order different from `Forward` or `Reverse` will raise an error about the\n  ambiguity.\n* `close` on a file (`IOStream`) can now throw an exception if an error occurs when trying\n  to flush buffered data to disk ([#35303]).\n* The large `StridedArray` `Union` now has special printing to avoid printing out its entire\n  contents ([#31149]).\n\n#### LinearAlgebra\n\n* The BLAS submodule now supports the level-2 BLAS subroutine `hpmv!` ([#34211]).\n* `normalize` now supports multidimensional arrays ([#34239]).\n* `lq` factorizations can now be used to compute the minimum-norm solution to under-determined systems ([#34350]).\n* `sqrt(::Hermitian)` now treats slightly negative eigenvalues as zero for nearly semidefinite matrices, and accepts a new `rtol` keyword argument for this tolerance ([#35057]).\n* The BLAS submodule now supports the level-2 BLAS subroutine `spmv!` ([#34320]).\n* The BLAS submodule now supports the level-1 BLAS subroutine `rot!` ([#35124]).\n* New generic `rotate!(x, y, c, s)` and `reflect!(x, y, c, s)` functions ([#35124]).\n\n#### Markdown\n\n* In docstrings, a level-1 markdown header \"Extended help\" is now interpreted as a marker\n  dividing \"brief help\" from \"extended help\". The REPL help mode only shows the brief help\n  (the content before the \"Extended help\" header) by default; prepend the expression with '?'\n  (in addition to the one that enters the help mode) to see the full docstring ([#25930]).\n\n#### Random\n\n* `randn!(::MersenneTwister, ::Array{Float64})` is faster, and as a result, for a given state of the RNG,\n  the corresponding generated numbers have changed ([#35078]).\n* `rand!(::MersenneTwister, ::Array{Bool})` is faster, and as a result, for a given state of the RNG,\n  the corresponding generated numbers have changed ([#33721]).\n* A new faster algorithm (\"nearly division less\") is used for generating random numbers\n  within a range ([#29240]). As a result, the streams of generated numbers are changed\n  (for ranges, like in `rand(1:9)`, and for collections in general, like in `rand([1, 2, 3])`).\n  Also, for performance, the undocumented property that, given a seed and `a, b` of type `Int`,\n  `rand(a:b)` produces the same stream on 32 and 64 bits architectures, is dropped.\n\n#### REPL\n\n\n#### SparseArrays\n\n* `lu!` accepts `UmfpackLU` as an argument to make use of its symbolic factorization.\n* The `trim` keyword argument for the functions `fkeep!`, `tril!`, `triu!`,\n  `droptol!`,`dropzeros!` and `dropzeros` has been removed in favour of always\n  trimming. Calling these with `trim=false` could result in invalid sparse\n  arrays.\n\n#### Dates\n\n* The `eps` function now accepts `TimeType` types ([#31487]).\n* The `zero` function now accepts `TimeType` types ([#35554]).\n\n#### Statistics\n\n\n#### Sockets\n\n* Joining and leaving UDP multicast groups on a `UDPSocket` is now supported\n  through `join_multicast_group()` and `leave_multicast_group()` ([#35521]).\n\n#### Distributed\n\n* `launch_on_machine` now supports and parses ipv6 square-bracket notation ([#34430]).\n\nDeprecated or removed\n---------------------\n\nExternal dependencies\n---------------------\n\n* OpenBLAS has been updated to v0.3.9 ([#35113]).\n\nTooling Improvements\n---------------------\n\n\n<!--- generated by NEWS-update.jl: -->\n[#25930]: https://github.com/JuliaLang/julia/issues/25930\n[#26872]: https://github.com/JuliaLang/julia/issues/26872\n[#28789]: https://github.com/JuliaLang/julia/issues/28789\n[#29240]: https://github.com/JuliaLang/julia/issues/29240\n[#29333]: https://github.com/JuliaLang/julia/issues/29333\n[#29411]: https://github.com/JuliaLang/julia/issues/29411\n[#29927]: https://github.com/JuliaLang/julia/issues/29927\n[#30115]: https://github.com/JuliaLang/julia/issues/30115\n[#31149]: https://github.com/JuliaLang/julia/issues/31149\n[#31487]: https://github.com/JuliaLang/julia/issues/31487\n[#32305]: https://github.com/JuliaLang/julia/issues/32305\n[#32348]: https://github.com/JuliaLang/julia/issues/32348\n[#32748]: https://github.com/JuliaLang/julia/issues/32748\n[#33193]: https://github.com/JuliaLang/julia/issues/33193\n[#33721]: https://github.com/JuliaLang/julia/issues/33721\n[#33864]: https://github.com/JuliaLang/julia/issues/33864\n[#33886]: https://github.com/JuliaLang/julia/issues/33886\n[#33937]: https://github.com/JuliaLang/julia/issues/33937\n[#34149]: https://github.com/JuliaLang/julia/issues/34149\n[#34199]: https://github.com/JuliaLang/julia/issues/34199\n[#34200]: https://github.com/JuliaLang/julia/issues/34200\n[#34211]: https://github.com/JuliaLang/julia/issues/34211\n[#34239]: https://github.com/JuliaLang/julia/issues/34239\n[#34272]: https://github.com/JuliaLang/julia/issues/34272\n[#34296]: https://github.com/JuliaLang/julia/issues/34296\n[#34320]: https://github.com/JuliaLang/julia/issues/34320\n[#34347]: https://github.com/JuliaLang/julia/issues/34347\n[#34350]: https://github.com/JuliaLang/julia/issues/34350\n[#34419]: https://github.com/JuliaLang/julia/issues/34419\n[#34427]: https://github.com/JuliaLang/julia/issues/34427\n[#34430]: https://github.com/JuliaLang/julia/issues/34430\n[#34498]: https://github.com/JuliaLang/julia/issues/34498\n[#34524]: https://github.com/JuliaLang/julia/issues/34524\n[#34548]: https://github.com/JuliaLang/julia/issues/34548\n[#34595]: https://github.com/JuliaLang/julia/issues/34595\n[#34634]: https://github.com/JuliaLang/julia/issues/34634\n[#34652]: https://github.com/JuliaLang/julia/issues/34652\n[#34654]: https://github.com/JuliaLang/julia/issues/34654\n[#34656]: https://github.com/JuliaLang/julia/issues/34656\n[#34722]: https://github.com/JuliaLang/julia/issues/34722\n[#34791]: https://github.com/JuliaLang/julia/issues/34791\n[#34896]: https://github.com/JuliaLang/julia/issues/34896\n[#34953]: https://github.com/JuliaLang/julia/issues/34953\n[#35001]: https://github.com/JuliaLang/julia/issues/35001\n[#35078]: https://github.com/JuliaLang/julia/issues/35078\n[#35094]: https://github.com/JuliaLang/julia/issues/35094\n[#35108]: https://github.com/JuliaLang/julia/issues/35108\n[#35124]: https://github.com/JuliaLang/julia/issues/35124\n[#35132]: https://github.com/JuliaLang/julia/issues/35132\n[#35138]: https://github.com/JuliaLang/julia/issues/35138\n[#35282]: https://github.com/JuliaLang/julia/issues/35282\n[#35283]: https://github.com/JuliaLang/julia/issues/35283\n[#35289]: https://github.com/JuliaLang/julia/issues/35289\n[#35303]: https://github.com/JuliaLang/julia/issues/35303\n[#35362]: https://github.com/JuliaLang/julia/issues/35362\n[#35426]: https://github.com/JuliaLang/julia/issues/35426\n[#35513]: https://github.com/JuliaLang/julia/issues/35513\n[#35521]: https://github.com/JuliaLang/julia/issues/35521\n[#35522]: https://github.com/JuliaLang/julia/issues/35522\n[#35554]: https://github.com/JuliaLang/julia/issues/35554\n[#35626]: https://github.com/JuliaLang/julia/issues/35626\n\nJulia v1.4 Release Notes\n========================\n\nNew language features\n---------------------\n\n* Structs with all isbits and isbitsunion fields are now stored inline in arrays ([#32448]).\n* `import` now allows quoted symbols, e.g. `import Base.:+` ([#33158]).\n* `a[begin]` can now be used to address the first element of an integer-indexed collection `a`.\n  The index is computed by `firstindex(a)` ([#33946]).\n\nLanguage changes\n----------------\n\n* The syntax `(;)`, which used to parse as an empty block expression, is deprecated.\n  In the future it will indicate an empty named tuple ([#30115]).\n\nMulti-threading changes\n-----------------------\n\n* Values can now be interpolated into `@async` and `@spawn` via `$`, which copies the value directly into the constructed\n  underlying closure ([#33119]).\n\nBuild system changes\n--------------------\n\n* Windows build installer has switched to Inno Setup. Installer command line parameters have thus changed. For example, to extract the installer to a specific directory, the command line parameter is now `/DIR=x:\\dirname`. Use `julia-installer.exe /?` to list all new command line parameters.\n\nNew library functions\n---------------------\n\n* The new `only(x)` function returns the one-and-only element of a collection `x`, and throws an `ArgumentError` if `x` contains zero or multiple elements ([#33129]).\n* `takewhile` and `dropwhile` have been added to the Iterators submodule ([#33437]).\n* `accumulate` has been added to the Iterators submodule ([#34033]).\n* There is a now an `evalpoly` function meant to take the role of the `@evalpoly` macro. The function is just as efficient as the macro while giving added flexibility, so it should be preferred over `@evalpoly`. `evalpoly` takes a list of coefficients as a tuple, so where one might write `@evalpoly(x, p1, p2, p3)` one would instead write `evalpoly(x, (p1, p2, p3))`.\n\nNew library features\n--------------------\n\n* Function composition now supports multiple functions: `\u2218(f, g, h) = f \u2218 g \u2218 h`\n  and splatting `\u2218(fs...)` for composing an iterable collection of functions ([#33568]).\n* Functions `gcd`, `lcm`, and `gcdx` now support `Rational` arguments ([#33910]).\n* The `splitpath` function now accepts any `AbstractString` whereas previously it only accepted paths of type `String` ([#33012]).\n* `filter` can now act on a `Tuple` ([#32968]).\n* The `tempname` function now takes an optional `parent::AbstractString` argument to give it a directory in which to attempt to produce a temporary path name ([#33090]).\n* The `tempname` function now takes a `cleanup::Bool` keyword argument defaulting to `true`, which causes the process to try to ensure that any file or directory at the path returned by `tempname` is deleted upon process exit ([#33090]).\n* The `readdir` function now takes a `join::Bool` keyword argument defaulting to `false`, which when set causes `readdir` to join its directory argument with each listed name ([#33113]).\n* `div` now accepts a rounding mode as the third argument, consistent with the corresponding argument to `rem`. Support for rounding division, by passing one of the RoundNearest modes to this function, was added. For future compatibility, library authors should now extend this function, rather than extending the two-argument `fld`/`cld`/`div` directly ([#33040]).\n* `methods` now accepts a module (or a list thereof) to filter methods defined in it ([#33403]).\n\nStandard library changes\n------------------------\n\n* Calling `show` or `repr` on an `undef`/`UndefInitializer()` array initializer now shows valid Julia code ([#33211]).\n* Calling `show` or `repr` on a 0-dimensional `AbstractArray` now shows valid code for creating an equivalent 0-dimensional array, instead of only showing the contained value ([#33206]).\n* `readdir` output is now guaranteed to be sorted. The `sort` keyword allows opting out of sorting to get names in OS-native order ([#33542]).\n* The methods of `mktemp` and `mktempdir` that take a function to pass temporary paths to no longer throw errors if the path is already deleted when the function returns ([#33091]).\n* Verbose `display` of `Char` (`text/plain` output) now shows the codepoint value in standard-conforming `\"U+XXXX\"` format ([#33291]).\n* `Iterators.partition` now uses views (or smartly re-computed ranges) for partitions of all `AbstractArray`s ([#33533]).\n* Sets are now displayed less compactly in the REPL, as a column of elements, like vectors\n  and dictionaries ([#33300]).\n* `delete!` on `WeakKeyDict`s now returns the `WeakKeyDict` itself instead of the underlying `Dict` used for implementation\n\n#### LinearAlgebra\n\n* `qr` and `qr!` functions support `blocksize` keyword argument ([#33053]).\n* `dot` now admits a 3-argument method `dot(x, A, y)` to compute generalized dot products `dot(x, A*y)`, but without computing and storing the intermediate result `A*y` ([#32739]).\n* `ldlt` and non-pivoted `lu` now throw a new `ZeroPivotException` type ([#33372]).\n* `cond(A, p)` with `p=1` or `p=Inf` now computes the exact condition number instead of an estimate ([#33547]).\n* `UniformScaling` objects may now be exponentiated such that `(a*I)^x = a^x * I`.\n\n#### Markdown\n\n* Tables now have the `align` attribute set when `show`n as HTML ([#33849]).\n\n#### Random\n\n* `AbstractRNG`s now behave like scalars when used in broadcasting ([#33213]).\n* The performance of `rand(::Tuple)` is improved in some cases ([#32208]). As a consequence, the\n  stream of generated values produced for a given seed has changed.\n\n#### REPL\n\n* The attributes of the implicit `IOContext` used by the REPL to display objects can be\n  modified by the user (experimental feature) ([#29249]).\n\n#### SparseArrays\n\n* The return value of `zero(x::AbstractSparseArray)` has no stored zeros anymore ([#31835]).\n  Previously, it would have stored zeros wherever `x` had them. This makes the operation\n  constant time instead of `O(<number of stored values>)`.\n* Products involving sparse arrays now allow more general sparse `eltype`s, such as `StaticArrays` ([#33205])\n\n<!--- generated by NEWS-update.jl: -->\n[#29249]: https://github.com/JuliaLang/julia/issues/29249\n[#30115]: https://github.com/JuliaLang/julia/issues/30115\n[#31835]: https://github.com/JuliaLang/julia/issues/31835\n[#32208]: https://github.com/JuliaLang/julia/issues/32208\n[#32448]: https://github.com/JuliaLang/julia/issues/32448\n[#32739]: https://github.com/JuliaLang/julia/issues/32739\n[#32968]: https://github.com/JuliaLang/julia/issues/32968\n[#33012]: https://github.com/JuliaLang/julia/issues/33012\n[#33040]: https://github.com/JuliaLang/julia/issues/33040\n[#33053]: https://github.com/JuliaLang/julia/issues/33053\n[#33090]: https://github.com/JuliaLang/julia/issues/33090\n[#33091]: https://github.com/JuliaLang/julia/issues/33091\n[#33113]: https://github.com/JuliaLang/julia/issues/33113\n[#33119]: https://github.com/JuliaLang/julia/issues/33119\n[#33129]: https://github.com/JuliaLang/julia/issues/33129\n[#33158]: https://github.com/JuliaLang/julia/issues/33158\n[#33205]: https://github.com/JuliaLang/julia/issues/33205\n[#33206]: https://github.com/JuliaLang/julia/issues/33206\n[#33211]: https://github.com/JuliaLang/julia/issues/33211\n[#33213]: https://github.com/JuliaLang/julia/issues/33213\n[#33291]: https://github.com/JuliaLang/julia/issues/33291\n[#33300]: https://github.com/JuliaLang/julia/issues/33300\n[#33372]: https://github.com/JuliaLang/julia/issues/33372\n[#33403]: https://github.com/JuliaLang/julia/issues/33403\n[#33437]: https://github.com/JuliaLang/julia/issues/33437\n[#33533]: https://github.com/JuliaLang/julia/issues/33533\n[#33542]: https://github.com/JuliaLang/julia/issues/33542\n[#33547]: https://github.com/JuliaLang/julia/issues/33547\n[#33568]: https://github.com/JuliaLang/julia/issues/33568\n[#33849]: https://github.com/JuliaLang/julia/issues/33849\n[#33910]: https://github.com/JuliaLang/julia/issues/33910\n[#33946]: https://github.com/JuliaLang/julia/issues/33946\n[#34033]: https://github.com/JuliaLang/julia/issues/34033\n\nJulia v1.3 Release Notes\n========================\n\nNew language features\n---------------------\n\n* Support for Unicode 12.1.0 ([#32002]).\n* Methods can now be added to an abstract type ([#31916]).\n* Support for unicode bold digits and double-struck digits 0 through 9 as valid identifiers ([#32838]).\n* Added the syntax `var\"#str#\"` for printing and parsing non-standard variable names ([#32408]).\n\nLanguage changes\n----------------\n\n\nMulti-threading changes\n-----------------------\n\n* New experimental `Threads.@spawn` macro that runs a task on any available thread ([#32600]).\n* All system-level I/O operations (e.g. files and sockets) are now thread-safe.\n  This does not include subtypes of `IO` that are entirely in-memory, such as `IOBuffer`,\n  although it specifically does include `BufferStream`.\n  ([#32309], [#32174], [#31981], [#32421]).\n* The global random number generator (`GLOBAL_RNG`) is now thread-safe (and thread-local) ([#32407]).\n* New `Channel(f::Function, spawn=true)` keyword argument to schedule the created Task on\n  any available thread, matching the behavior of `Threads.@spawn` ([#32872]).\n* Simplified the `Channel` constructor, which is now easier to read and more idiomatic julia.\n  Use of the keyword arguments `csize` and `ctype` is now discouraged ([#30855], [#32818]).\n\nBuild system changes\n--------------------\n\n\nNew library functions\n---------------------\n\n* `findfirst`, `findlast`, `findnext` and `findprev` now accept a character as first argument\n  to search for that character in a string passed as the second argument ([#31664]).\n* New `findall(pattern, string)` method where `pattern` is a string or regex ([#31834]).\n* `count(pattern, string)` gives the number of things `findall` would match ([#32849]).\n* `istaskfailed` is now documented and exported, like its siblings `istaskdone` and `istaskstarted` ([#32300]).\n* `RefArray` and `RefValue` objects now accept index `CartesianIndex()` in  `getindex` and `setindex!` ([#32653])\n* Added `sincosd(x)` to simultaneously compute the sine and cosine of `x`, where `x` is in degrees ([#30134]).\n* The function `nonmissingtype`, which removes `Missing` from type unions, is now exported ([#31562]).\n\nStandard library changes\n------------------------\n\n* `Pkg` won't clobber pre-compilation files as often when switching environments ([#32651])\n* `Pkg` can now download and install binary artifacts through the `Pkg.Artifacts`\n   submodule and supporting functions. ([#32918])\n* When `wait` (or `@sync`, or `fetch`) is called on a failing `Task`, the exception is propagated as a\n  `TaskFailedException` wrapping the task.\n  This makes it possible to see the location of the original failure inside the task (as well as the\n  location of the `wait` call, as before) ([#32814]).\n* `Regex` can now be multiplied (`*`) and exponentiated (`^`), like strings ([#23422]).\n* `Cmd` interpolation (``` `$(x::Cmd) a b c` ``` where) now propagates `x`'s process flags\n  (environment, flags, working directory, etc) if `x` is the first interpolant and errors\n  otherwise ([#24353]).\n* Zero-dimensional arrays are now consistently preserved in the return values of mathematical\n  functions that operate on the array(s) as a whole (and are not explicitly broadcasted across their elements).\n  Previously, the functions  `+`, `-`, `*`, `/`, `conj`, `real` and `imag` returned the unwrapped element\n  when operating over zero-dimensional arrays ([#32122]).\n* `IPAddr` subtypes now behave like scalars when used in broadcasting ([#32133]).\n* `Pair` is now treated as a scalar for broadcasting ([#32209]).\n* `clamp` can now handle missing values ([#31066]).\n* `empty` now accepts a `NamedTuple` ([#32534]).\n* `mod` now accepts a unit range as the second argument to easily perform offset modular arithmetic to ensure the result is inside the range ([#32628]).\n* `nothing` can now be `print`ed, and interpolated into strings etc. as the string `\"nothing\"`. It is still not permitted to be interpolated into Cmds (i.e. ``echo `$(nothing)` `` will still error without running anything.) ([#32148])\n* When `open` is called with a function, command, and keyword argument (e.g. ```open(`ls`, read=true) do f ...```)\n  it now correctly throws a `ProcessFailedException` like other similar calls ([#32193]).\n* `mktemp` and `mktempdir` now try, by default, to remove temporary paths they create before the process exits ([#32851]).\n* Added argument `keep` to `unescape_string` ([#27125]).\n\n#### Libdl\n\n* `dlopen()` can now be invoked in `do`-block syntax, similar to `open()`.\n\n#### LinearAlgebra\n\n* The BLAS submodule no longer exports `dot`, which conflicts with that in LinearAlgebra ([#31838]).\n* `diagm` and `spdiagm` now accept optional `m,n` initial arguments to specify a size ([#31654]).\n* `Hessenberg` factorizations `H` now support efficient shifted solves `(H+\u00b5I) \\ b` and determinants, and use a specialized tridiagonal factorization for Hermitian matrices. There is also a new `UpperHessenberg` matrix type ([#31853]).\n* Added keyword argument `alg` to `svd` and `svd!` that allows one to switch between different SVD algorithms ([#31057]).\n* Five-argument `mul!(C, A, B, \u03b1, \u03b2)` now implements inplace multiplication fused with addition _C = A B \u03b1 + C \u03b2_ ([#23919]).\n\n#### SparseArrays\n\n* `SparseMatrixCSC(m,n,colptr,rowval,nzval)` perform consistency checks for arguments:\n  `colptr` must be properly populated and lengths of `colptr`, `rowval`, and `nzval`\n  must be compatible with `m`, `n`, and `eltype(colptr)`.\n* `sparse(I, J, V, m, n)` verifies lengths of `I`, `J`, `V` are equal and compatible with\n  `eltype(I)` and `m`, `n`.\n\n#### Dates\n\n* `DateTime` and `Time` formatting/parsing now supports 12-hour clocks with AM/PM via `I` and `p` codes, similar to `strftime` ([#32308]).\n* Fixed `repr` such that it displays `Time` as it would be entered in Julia ([#32103]).\n\n#### Statistics\n\n* `mean` now accepts both a function argument and a `dims` keyword ([#31576]).\n\n#### Sockets\n\n* `Sockets.recvfrom` now returns both host and port as an InetAddr ([#32729]).\n* Added `InetAddr` constructor from `AbstractString`, representing IP address, and `Integer`,\n  representing port number ([#31459]).\n\n#### Miscellaneous\n\n* `foldr` and `mapfoldr` now work on any iterator that supports `Iterators.reverse`, not just arrays ([#31781]).\n\nDeprecated or removed\n---------------------\n\n* `@spawn expr` from the `Distributed` standard library should be replaced with `@spawnat :any expr` ([#32600]).\n* `Threads.Mutex` and `Threads.RecursiveSpinLock` have been removed; use `ReentrantLock` (preferred) or\n  `Threads.SpinLock` instead ([#32875]).\n\nExternal dependencies\n---------------------\n\nTooling Improvements\n---------------------\n\n* The `ClangSA.jl` static analysis package has been imported, which makes use of\n  the clang static analyzer to validate GC invariants in Julia's C code. The analysis\n  may be run using `make -C src analyzegc`.\n\n<!--- generated by NEWS-update.jl: -->\n[#23422]: https://github.com/JuliaLang/julia/issues/23422\n[#23919]: https://github.com/JuliaLang/julia/issues/23919\n[#24353]: https://github.com/JuliaLang/julia/issues/24353\n[#27125]: https://github.com/JuliaLang/julia/issues/27125\n[#30134]: https://github.com/JuliaLang/julia/issues/30134\n[#30855]: https://github.com/JuliaLang/julia/issues/30855\n[#31057]: https://github.com/JuliaLang/julia/issues/31057\n[#31066]: https://github.com/JuliaLang/julia/issues/31066\n[#31459]: https://github.com/JuliaLang/julia/issues/31459\n[#31562]: https://github.com/JuliaLang/julia/issues/31562\n[#31576]: https://github.com/JuliaLang/julia/issues/31576\n[#31654]: https://github.com/JuliaLang/julia/issues/31654\n[#31664]: https://github.com/JuliaLang/julia/issues/31664\n[#31781]: https://github.com/JuliaLang/julia/issues/31781\n[#31834]: https://github.com/JuliaLang/julia/issues/31834\n[#31838]: https://github.com/JuliaLang/julia/issues/31838\n[#31853]: https://github.com/JuliaLang/julia/issues/31853\n[#31916]: https://github.com/JuliaLang/julia/issues/31916\n[#31981]: https://github.com/JuliaLang/julia/issues/31981\n[#32002]: https://github.com/JuliaLang/julia/issues/32002\n[#32103]: https://github.com/JuliaLang/julia/issues/32103\n[#32122]: https://github.com/JuliaLang/julia/issues/32122\n[#32133]: https://github.com/JuliaLang/julia/issues/32133\n[#32148]: https://github.com/JuliaLang/julia/issues/32148\n[#32174]: https://github.com/JuliaLang/julia/issues/32174\n[#32193]: https://github.com/JuliaLang/julia/issues/32193\n[#32209]: https://github.com/JuliaLang/julia/issues/32209\n[#32300]: https://github.com/JuliaLang/julia/issues/32300\n[#32308]: https://github.com/JuliaLang/julia/issues/32308\n[#32309]: https://github.com/JuliaLang/julia/issues/32309\n[#32407]: https://github.com/JuliaLang/julia/issues/32407\n[#32408]: https://github.com/JuliaLang/julia/issues/32408\n[#32421]: https://github.com/JuliaLang/julia/issues/32421\n[#32534]: https://github.com/JuliaLang/julia/issues/32534\n[#32600]: https://github.com/JuliaLang/julia/issues/32600\n[#32628]: https://github.com/JuliaLang/julia/issues/32628\n[#32653]: https://github.com/JuliaLang/julia/issues/32653\n[#32729]: https://github.com/JuliaLang/julia/issues/32729\n[#32814]: https://github.com/JuliaLang/julia/issues/32814\n[#32818]: https://github.com/JuliaLang/julia/issues/32818\n[#32838]: https://github.com/JuliaLang/julia/issues/32838\n[#32849]: https://github.com/JuliaLang/julia/issues/32849\n[#32851]: https://github.com/JuliaLang/julia/issues/32851\n[#32872]: https://github.com/JuliaLang/julia/issues/32872\n[#32875]: https://github.com/JuliaLang/julia/issues/32875\n\nJulia v1.2 Release Notes\n========================\n\nNew language features\n---------------------\n\n* Argument splatting (`x...`) can now be used in calls to the `new` pseudo-function in\n  constructors ([#30577]).\n* Support for Unicode 12.0.0 ([#31561]).\n* Added `\u22c6` (`\\star`) as unary operator ([#31604]).\n\nLanguage changes\n----------------\n\n* Empty entries in `JULIA_DEPOT_PATH` are now expanded to default depot entries ([#31009]).\n\nMulti-threading changes\n-----------------------\n\n* The `Condition` type now has a thread-safe replacement, accessed as `Threads.Condition`.\n  With that addition, task scheduling primitives such as `ReentrantLock` are now thread-safe ([#30061]).\n* It is possible to schedule and switch Tasks during `@threads` loops, and perform limited I/O ([#31438]).\n\nBuild system changes\n--------------------\n\n* The build system now prefers downloading prebuilt binary tarballs for most dependencies on\n  supported systems, disable by setting `USE_BINARYBUILDER=0` at `make` time ([#31441]).\n\nNew library functions\n---------------------\n\n* `getipaddrs()` function returns all the IP addresses of the local machine, with IPv4 addresses sorting before IPv6 addresses ([#30349, #30604]).\n* `getipaddr(addr_type)` and `getipaddrs(addr_type)` functions returns an IP address(es) of the desired type of the local machine ([#30604]).\n* Added `Base.hasproperty` and `Base.hasfield` ([#28850]).\n* One argument `!=(x)`, `>(x)`, `>=(x)`, `<(x)`, `<=(x)` have been added, returning partially-applied\n  versions of the functions, similar to the existing `==(x)` and `isequal(x)` methods ([#30915]).\n* The new `map!(f, values(::AbstractDict))` method allows to modify in-place values of a dictionary ([#31223]).\n\nStandard library changes\n------------------------\n\n* `Enum` now behaves like a scalar when used in broadcasting ([#30670]).\n* If a `pipeline` is specified with `append=true` set, but no redirection, an `ArgumentError`\n  is thrown, rather than a `ErrorException` ([#27900]).\n* Functions that invoke commands (e.g. `run(::Cmd)`) now throw a `ProcessFailedException`\n  rather than an `ErrorException`, if those commands exit with non-zero exit code ([#27900]).\n* The `extrema` function now accepts a function argument in the same manner as `minimum` and\n  `maximum` ([#30323]).\n* `hasmethod` can now check for matching keyword argument names ([#30712]).\n* `startswith` and `endswith` now accept a `Regex` for the second argument ([#29790]).\n* `retry` supports arbitrary callable objects ([#30382]).\n* A no-argument constructor for `Ptr{T}` has been added which constructs a null pointer ([#30919]).\n* `strip` now accepts a function argument in the same manner as `lstrip` and `rstrip` ([#31211]).\n* `mktempdir` now accepts a `prefix` keyword argument to customize the file name ([#31230], [#22922]).\n* `keytype` and `valtype` now work on `AbstractArray`, and return the `eltype` of `keys(...)` and\n  `values(...)` respectively ([#27749]).\n* `nextfloat(::BigFloat)` and `prevfloat(::BigFloat)` now returns a value with the same precision\n  as their argument, which means that (in particular) `nextfloat(prevfloat(x)) == x` whereas\n  previously this could result in a completely different value with a different precision ([#31310]).\n* `mapreduce` now accepts multiple iterators, similar to `map` ([#31532]).\n* `filter` now supports `SkipMissing`-wrapped arrays ([#31235]).\n* Objects created by calling `skipmissing` on an array can now be indexed using indices\n  from the parent at non-missing positions. This allows functions such as\n  `findall`, `findfirst`, `argmin`/`argmax` and `findmin`/`findmax` to work with these\n  objects, returning the index of matching non-missing elements in the parent ([#31008]).\n* `inv(::Missing)` has now been added and returns `missing` ([#31451]).\n* `nextfloat(::BigFloat, n::Integer)` and `prevfloat(::BigFloat, n::Integer)` methods\n  have been added ([#31310]).\n\n#### LinearAlgebra\n* Added keyword arguments `rtol`, `atol` to `pinv` and `nullspace` ([#29998]).\n* `UniformScaling` instances are now callable such that e.g. `I(3)` will produce a `Diagonal` matrix ([#30298]).\n* Eigenvalues \u03bb of general matrices are now sorted lexicographically by (Re \u03bb, Im \u03bb) ([#21598]).\n* `one` for structured matrices (`Diagonal`, `Bidiagonal`, `Tridiagonal`, `Symtridiagonal`) now preserves\n  structure and type ([#29777]).\n* `diagm(v)` is now a shorthand for `diagm(0 => v)` ([#31125]).\n\n#### SparseArrays\n* Performance improvements for sparse matrix-matrix multiplication ([#30372]).\n* Sparse vector outer products are more performant and maintain sparsity in products of the\n  form `kron(u, v')`, `u * v'`, and `u .* v'` where `u` and `v` are sparse vectors or column\n  views ([#24980]).\n* The `sprand` function is now 2 to 5 times faster ([#30494]). As a consequence of this change, the random stream of matrices produced with `sprand` and `sprandn` has changed.\n\n#### Sockets\n\n* `getipaddrs` returns IP addresses in the order provided by libuv ([#32260]).\n* `getipaddr` prefers to return the first `IPv4` interface address provided by libuv ([#32260]).\n\n#### Dates\n* Fixed `repr` such that it displays `DateTime` as it would be entered in Julia ([#30200]).\n\n#### Statistics\n* `quantile` now accepts in all cases collections whose `eltype` is not a subtype of `Number` ([#30938]).\n\n#### Miscellaneous\n* Since environment variables on Windows are case-insensitive, `ENV` now converts its keys\n  to uppercase for display, iteration, and copying ([#30593]).\n\nExternal dependencies\n---------------------\n\n* libgit2 has been updated to v0.27.7 ([#30584]).\n* OpenBLAS has been updated to v0.3.5 ([#30583]).\n* MbedTLS has been updated to v2.16.0 ([#30618]).\n* libunwind has been updated to v1.3.1 ([#30724]).\n\n<!--- generated by NEWS-update.jl: -->\n[#21598]: https://github.com/JuliaLang/julia/issues/21598\n[#22922]: https://github.com/JuliaLang/julia/issues/22922\n[#24980]: https://github.com/JuliaLang/julia/issues/24980\n[#27749]: https://github.com/JuliaLang/julia/issues/27749\n[#27900]: https://github.com/JuliaLang/julia/issues/27900\n[#28850]: https://github.com/JuliaLang/julia/issues/28850\n[#29777]: https://github.com/JuliaLang/julia/issues/29777\n[#29790]: https://github.com/JuliaLang/julia/issues/29790\n[#29998]: https://github.com/JuliaLang/julia/issues/29998\n[#30061]: https://github.com/JuliaLang/julia/issues/30061\n[#30200]: https://github.com/JuliaLang/julia/issues/30200\n[#30298]: https://github.com/JuliaLang/julia/issues/30298\n[#30323]: https://github.com/JuliaLang/julia/issues/30323\n[#30372]: https://github.com/JuliaLang/julia/issues/30372\n[#30382]: https://github.com/JuliaLang/julia/issues/30382\n[#30494]: https://github.com/JuliaLang/julia/issues/30494\n[#30577]: https://github.com/JuliaLang/julia/issues/30577\n[#30583]: https://github.com/JuliaLang/julia/issues/30583\n[#30584]: https://github.com/JuliaLang/julia/issues/30584\n[#30593]: https://github.com/JuliaLang/julia/issues/30593\n[#30604]: https://github.com/JuliaLang/julia/issues/30604\n[#30618]: https://github.com/JuliaLang/julia/issues/30618\n[#30670]: https://github.com/JuliaLang/julia/issues/30670\n[#30712]: https://github.com/JuliaLang/julia/issues/30712\n[#30724]: https://github.com/JuliaLang/julia/issues/30724\n[#30915]: https://github.com/JuliaLang/julia/issues/30915\n[#30919]: https://github.com/JuliaLang/julia/issues/30919\n[#30938]: https://github.com/JuliaLang/julia/issues/30938\n[#31008]: https://github.com/JuliaLang/julia/issues/31008\n[#31009]: https://github.com/JuliaLang/julia/issues/31009\n[#31125]: https://github.com/JuliaLang/julia/issues/31125\n[#31211]: https://github.com/JuliaLang/julia/issues/31211\n[#31230]: https://github.com/JuliaLang/julia/issues/31230\n[#31235]: https://github.com/JuliaLang/julia/issues/31235\n[#31310]: https://github.com/JuliaLang/julia/issues/31310\n[#31438]: https://github.com/JuliaLang/julia/issues/31438\n[#31441]: https://github.com/JuliaLang/julia/issues/31441\n[#31451]: https://github.com/JuliaLang/julia/issues/31451\n[#31532]: https://github.com/JuliaLang/julia/issues/31532\n[#31561]: https://github.com/JuliaLang/julia/issues/31561\n[#31604]: https://github.com/JuliaLang/julia/issues/31604\n[#32260]: https://github.com/JuliaLang/julia/issues/32260\n\nJulia v1.1 Release Notes\n========================\n\nNew language features\n---------------------\n\n  * An *exception stack* is maintained on each task to make exception handling\n    more robust and enable root cause analysis. The stack may be accessed using\n    the experimental function `Base.catch_stack` ([#28878]).\n  * The experimental macro `Base.@locals` returns a dictionary of current local variable names\n    and values ([#29733]).\n  * Binary `~` can now be dotted, as in `x .~ y` ([#30341]).\n\nLanguage changes\n----------------\n\n  * Parser inputs ending with a comma are now consistently treated as incomplete.\n    Previously they were sometimes parsed as tuples, depending on whitespace ([#28506]).\n  * Spaces were accidentally allowed in broadcast call syntax, e.g. `f. (x)`. They are now\n    disallowed, consistent with normal function call syntax ([#29781]).\n  * Big integer literals and command syntax (backticks) are now parsed with the name of\n    the macro (`@int128_str`, `@uint128_str`, `@big_str`, `@cmd`) qualified to refer\n    to the `Core` module ([#29968]).\n  * Using the same name for both a local variable and a static parameter is now an error instead\n    of a warning ([#29429]).\n  * `findall(in(b), a)` now returns a `CartesianIndex` when `a` is a matrix or a higher-dimensional array,\n    for consistency with other `findall` methods. Use `LinearIndices(a)[findall(in(b), a)]` to get\n    the old behavior, or `CartesianIndices(a)[findall(in(b), a)]` to get the new behavior\n    on previous Julia versions ([#30226]).\n  * `findmin(::BitArray)` and `findmax(::BitArray)` now return a `CartesianIndex` when `a` is a matrix\n    or a higher-dimensional array, for consistency with other array types.\n    Use `LinearIndices(a)[findmin(a)[2]]` to get the old behavior, or `CartesianIndices(a)[findmin(a)[2]]`\n    to get the new behavior on previous Julia versions ([#30102]).\n  * Method signatures such as\n    `f(::Type{T}, ::T) where {T <: X}` and\n    `f(::Type{X}, ::Any)`\n    are now considered ambiguous. Previously a bug caused the first one to be considered more specific in\n    some cases ([#30160]).\n\nCommand-line option changes\n---------------------------\n\n  * When a script run in interactive mode (`-i`) throws an error, the REPL now starts after\n    the error is displayed. Previously the REPL only started if the script completed without\n    error ([#21233]).\n\nNew library functions\n---------------------\n\n  * `splitpath(p::String)` function, which is the opposite of `joinpath(parts...)`: it splits a filepath\n    into its components ([#28156]).\n  * `isnothing(::Any)` predicate, to check whether the argument is `nothing`. ([#29679]).\n  * `getpid(::Process)` method ([#24064]).\n  * `eachrow`, `eachcol` and `eachslice` functions provide efficient iterators over slices of arrays ([#29749]).\n  * `fieldtypes(T::Type)` which returns the declared types of the field in type T ([#29600]).\n  * `uuid5` has been added to the `UUIDs` standard library ([#28761]).\n  * Predicates `Sys.isfreebsd`, `Sys.isopenbsd`, `Sys.isnetbsd`, and `Sys.isdragonfly` for\n    detecting BSD systems have been added ([#30249]).\n  * Internal `Base.disable_library_threading` that sets libraries to use one thread.\n    It executes function hooks that have been registered with\n    `Base.at_disable_library_threading` ([#30004]).\n\nStandard library changes\n------------------------\n\n  * `CartesianIndices` can now be constructed from two `CartesianIndex`es `I` and `J` with `I:J` ([#29440]).\n  * `CartesianIndices` support broadcasting arithmetic (+ and -) with a `CartesianIndex` ([#29890]).\n  * `copy!` support for arrays, dicts, and sets has been moved to Base from the Future package ([#29173]).\n  * Channels now convert inserted values (like containers) instead of requiring types to match ([#29092]).\n  * `range` can accept the stop value as a positional argument, e.g. `range(1,10,step=2)` ([#28708]).\n  * `diff` now supports arrays of arbitrary dimensionality and can operate over any dimension ([#29827]).\n  * The constructor `BigFloat(::BigFloat)` now respects the global precision setting and always\n    returns a `BigFloat` with precision equal to `precision(BigFloat)` ([#29127]). The optional\n    `precision` argument to override the global setting is now a keyword instead of positional\n    argument ([#29157]).\n  * The use of scientific notation when printing `BigFloat` values is now consistent with other floating point\n    types ([#29211]).\n  * `Regex` now behaves like a scalar when used in broadcasting ([#29913]).\n  * `Char` now behaves like a read-only 0-dimensional array ([#29819]).\n  * `parse` now allows strings representing integer 0 and 1 for type `Bool` ([#29980]).\n  * `Base.tail` now works on named tuples ([#29595]).\n  * The process id is appended to malloc log files in order to track memory allocations of\n    multiple processes ([#29969]).\n  * `Base.julia_cmd` now propagates the `--inline=(yes|no)` flag ([#29858]).\n  * `Base.@kwdef` can now be used for parametric structs, and for structs with supertypes ([#29316]).\n  * `merge(::NamedTuple, ::NamedTuple...)` can now be used with more than 2 `NamedTuple`s ([#29259]).\n  * New `ncodeunits(c::Char)` method as a fast equivalent to `ncodeunits(string(c))` ([#29153]).\n  * New `sort!(::AbstractArray; dims)` method that can sort the array along the `dims` dimension ([#28902]).\n  * `range` now accepts `stop` as a positional argument ([#28708]).\n  * `get(A::AbstractArray, (), default)` now returns `A[]` instead of an empty array ([#30270]).\n  * `parse(Bool, str)` is now supported ([#29997]).\n  * `copyto!(::AbstractMatrix, ::UniformScaling)` now supports rectangular matrices ([#28790]).\n  * `current_project()` now searches the parent directories of a Git repository for a `Project.toml` file.\n    This also affects the behavior of the `--project` command line option when using the default\n    `--project=@.` ([#29108]).\n  * The `spawn` API is now more flexible and supports taking IOBuffer directly as an I/O stream,\n    converting to a system pipe as needed ([#30278]).\n\n#### Dates\n  * New `DateTime(::Date, ::Time)` constructor ([#29754]).\n  * `TimeZone` now behaves like a scalar when used in broadcasting ([#30159]).\n\n#### InteractiveUtils\n  * `edit` can now be called on a module to edit the file that defines it ([#29636]).\n  * All compiler-reflection tools (i.e. the `code_` class of functions and macros) now print accurate\n    line number and inlining information in a common style, and take an optional parameter (debuginfo=:default)\n    to control the verbosity of the metadata shown ([#29893]).\n\n#### LinearAlgebra\n  * `isdiag` and `isposdef` for `Diagonal` and `UniformScaling` ([#29638]).\n  * `mul!`, `rmul!` and `lmul!` methods for `UniformScaling` ([#29506]).\n  * `Symmetric` and `Hermitian` matrices now preserve the wrapper when scaled with a number ([#29469]).\n  * Exponentiation operator `^` now supports raising an `Irrational` to an `AbstractMatrix` power ([#29782]).\n  * Added keyword arguments `rtol`, `atol` to `rank` ([#29926]).\n\n#### Random\n  * `randperm` and `randcycle` now use the type of their argument to determine the element type of\n    the returned array ([#29670]).\n  * A new method `rand(::Tuple)` implements sampling from the values of a tuple ([#25278]).\n  * `serialize` and `deserialize` now accept a filename argument, like `write` and `read` ([#30151]).\n\n#### SparseArrays\n  * `sprandn` now supports specifying the output element type ([#30083]).\n\n#### Statistics\n  * `mean` and `var` now handle more kinds of empty inputs ([#29033]).\n\nExternal dependencies\n---------------------\n\n  * 7zip (bundled with Julia on Windows) has been upgraded from version 16.04 to 18.05 ([#30035]).\n  * Busybox is no longer bundled with Julia on Windows ([#30022]).\n  * OpenBLAS has been upgraded from 0.3.2 to 0.3.3 ([#29845]).\n  * The source code for Pkg is no longer included in JuliaLang/julia. Pkg is instead\n    downloaded during the build process ([#29615]).\n  * LLVM has been upgraded to 6.0.1 and support for LLVM < 6.0 has been dropped ([#28745], [#28696]).\n  * Pkg has been upgraded to version 1.1 ([#30342]).\n\nDeprecated or removed\n---------------------\n\n  * `one(i::CartesianIndex)` should be replaced with `oneunit(i::CartesianIndex)` ([#29442]).\n  * The internal array `Base.Grisu.DIGITS` is deprecated; new code should use `Base.Grisu.getbuf()`\n    to get an appropriate task-local buffer and pass it to `grisu()` instead ([#29907]).\n  * The internal function `Base._default_type(T)` has been removed. Calls to it should be\n    replaced with just the argument `T` ([#29739]).\n  * `peakflops` has been scheduled to move from `InteractiveUtils` to `LinearAlgebra`\n    but is already now available as `LinearAlgebra.peakflops` ([#29978]).\n\n<!--- generated by NEWS-update.jl: -->\n[#21233]: https://github.com/JuliaLang/julia/issues/21233\n[#24064]: https://github.com/JuliaLang/julia/issues/24064\n[#25278]: https://github.com/JuliaLang/julia/issues/25278\n[#28156]: https://github.com/JuliaLang/julia/issues/28156\n[#28506]: https://github.com/JuliaLang/julia/issues/28506\n[#28696]: https://github.com/JuliaLang/julia/issues/28696\n[#28708]: https://github.com/JuliaLang/julia/issues/28708\n[#28745]: https://github.com/JuliaLang/julia/issues/28745\n[#28761]: https://github.com/JuliaLang/julia/issues/28761\n[#28790]: https://github.com/JuliaLang/julia/issues/28790\n[#28878]: https://github.com/JuliaLang/julia/issues/28878\n[#28902]: https://github.com/JuliaLang/julia/issues/28902\n[#29033]: https://github.com/JuliaLang/julia/issues/29033\n[#29092]: https://github.com/JuliaLang/julia/issues/29092\n[#29108]: https://github.com/JuliaLang/julia/issues/29108\n[#29127]: https://github.com/JuliaLang/julia/issues/29127\n[#29153]: https://github.com/JuliaLang/julia/issues/29153\n[#29157]: https://github.com/JuliaLang/julia/issues/29157\n[#29173]: https://github.com/JuliaLang/julia/issues/29173\n[#29211]: https://github.com/JuliaLang/julia/issues/29211\n[#29259]: https://github.com/JuliaLang/julia/issues/29259\n[#29316]: https://github.com/JuliaLang/julia/issues/29316\n[#29429]: https://github.com/JuliaLang/julia/issues/29429\n[#29440]: https://github.com/JuliaLang/julia/issues/29440\n[#29442]: https://github.com/JuliaLang/julia/issues/29442\n[#29469]: https://github.com/JuliaLang/julia/issues/29469\n[#29506]: https://github.com/JuliaLang/julia/issues/29506\n[#29595]: https://github.com/JuliaLang/julia/issues/29595\n[#29600]: https://github.com/JuliaLang/julia/issues/29600\n[#29615]: https://github.com/JuliaLang/julia/issues/29615\n[#29636]: https://github.com/JuliaLang/julia/issues/29636\n[#29638]: https://github.com/JuliaLang/julia/issues/29638\n[#29670]: https://github.com/JuliaLang/julia/issues/29670\n[#29679]: https://github.com/JuliaLang/julia/issues/29679\n[#29733]: https://github.com/JuliaLang/julia/issues/29733\n[#29739]: https://github.com/JuliaLang/julia/issues/29739\n[#29749]: https://github.com/JuliaLang/julia/issues/29749\n[#29754]: https://github.com/JuliaLang/julia/issues/29754\n[#29781]: https://github.com/JuliaLang/julia/issues/29781\n[#29782]: https://github.com/JuliaLang/julia/issues/29782\n[#29819]: https://github.com/JuliaLang/julia/issues/29819\n[#29827]: https://github.com/JuliaLang/julia/issues/29827\n[#29845]: https://github.com/JuliaLang/julia/issues/29845\n[#29858]: https://github.com/JuliaLang/julia/issues/29858\n[#29890]: https://github.com/JuliaLang/julia/issues/29890\n[#29893]: https://github.com/JuliaLang/julia/issues/29893\n[#29907]: https://github.com/JuliaLang/julia/issues/29907\n[#29913]: https://github.com/JuliaLang/julia/issues/29913\n[#29926]: https://github.com/JuliaLang/julia/issues/29926\n[#29968]: https://github.com/JuliaLang/julia/issues/29968\n[#29969]: https://github.com/JuliaLang/julia/issues/29969\n[#29978]: https://github.com/JuliaLang/julia/issues/29978\n[#29980]: https://github.com/JuliaLang/julia/issues/29980\n[#29997]: https://github.com/JuliaLang/julia/issues/29997\n[#30004]: https://github.com/JuliaLang/julia/issues/30004\n[#30022]: https://github.com/JuliaLang/julia/issues/30022\n[#30035]: https://github.com/JuliaLang/julia/issues/30035\n[#30083]: https://github.com/JuliaLang/julia/issues/30083\n[#30102]: https://github.com/JuliaLang/julia/issues/30102\n[#30151]: https://github.com/JuliaLang/julia/issues/30151\n[#30159]: https://github.com/JuliaLang/julia/issues/30159\n[#30160]: https://github.com/JuliaLang/julia/issues/30160\n[#30226]: https://github.com/JuliaLang/julia/issues/30226\n[#30249]: https://github.com/JuliaLang/julia/issues/30249\n[#30270]: https://github.com/JuliaLang/julia/issues/30270\n[#30278]: https://github.com/JuliaLang/julia/issues/30278\n[#30341]: https://github.com/JuliaLang/julia/issues/30341\n[#30342]: https://github.com/JuliaLang/julia/issues/30342\n\nJulia v1.0.0 Release Notes\n==========================\n\nJulia v1.0 is identical to the v0.7 release, with the exception that\nit removes all deprecations and deprecation related warnings. When\nupgrading a codebase from v0.6, the process is to first get the code\nto work on v0.7, and fix all the deprecation warnings. Once the code\nruns on v0.7 without warnings, it should be good to run on v1.0.\n\nRefer to the [Release Notes for\nv0.7](https://github.com/JuliaLang/julia/blob/master/HISTORY.md) for a\ndetailed list of changes from Julia v0.6.\n\nStandard Library Changes\n------------------------\n\n* The `Libdl` module's methods `dlopen()` and `dlsym()` have gained a\n  `throw_error` keyword argument, replacing the now-deprecated `dlopen_e()`\n  and `dlsym_e()` methods.  When `throw_error` is `false`, failure to locate\n  a shared library or symbol will return `nothing` rather than `C_NULL`.\n  ([#28888])\n\nDeprecated or removed\n---------------------\n\n* The old package manager (now called `OldPkg`) has been moved to a\n  separate repository at https://github.com/JuliaArchive/OldPkg.jl ([#27930])\n\n<!--- generated by NEWS-update.jl: -->\n[#27930]: https://github.com/JuliaLang/julia/issues/27930\n[#28888]: https://github.com/JuliaLang/julia/issues/28888\n\nJulia v0.7.0 Release Notes\n==========================\n\nNew language features\n---------------------\n\n  * Local variables can be tested for being defined\n    using the new `@isdefined variable` macro ([#22281]).\n\n  * Destructuring in function arguments: when an expression such as `(x, y)` is used as\n    a function argument name, the argument is unpacked into local variables `x` and `y`\n    as in the assignment `(x, y) = arg` ([#6614]).\n\n  * Named tuples, with the syntax `(a=1, b=2)`. These behave very similarly to tuples,\n    except components can also be accessed by name using dot syntax `t.a` ([#22194]).\n\n  * Keyword argument containers (`kw` in `f(; kw...)`) are now based on named tuples. Dictionary\n    functions like `haskey` and indexing can be used on them, and name-value pairs can be\n    iterated using `pairs(kw)`. `kw` can no longer contain multiple entries for the same\n    argument name ([#4916]).\n\n  * Custom infix operators can now be defined by appending Unicode\n    combining marks, primes, and sub/superscripts to other operators.\n    For example, `+\u0302\u2090\u2033` is parsed as an infix operator with the same\n    precedence as `+` ([#22089]).\n\n  * The macro call syntax `@macroname[args]` is now available and is parsed\n    as `@macroname([args])` ([#23519]).\n\n  * The construct `if @generated ...; else ...; end` can be used to provide both\n    `@generated` and normal implementations of part of a function. Surrounding code\n    will be common to both versions ([#23168]).\n\n  * Added `\u27c2` (`\\perp`) operator with comparison precedence ([#24404]).\n\n  * The `missing` singleton object (of type `Missing`) has been added to represent\n    missing values ([#24653]). It propagates through standard operators and mathematical functions,\n    and implements three-valued logic, similar to SQLs `NULL` and R's `NA`.\n\n  * Field access via dot-syntax can now be overloaded by adding methods to\n    `Base.getproperty` and `Base.setproperty!` ([#1974]), optionally along with\n    a corresponding `Base.propertynames` method for reflection ([#25311]).\n\n  * Values for `Enum`s can now be specified inside of a `begin` block when using the\n    `@enum` macro ([#25424]).\n\n  * Keyword arguments can be required: if a default value is omitted, then an\n    exception is thrown if the caller does not assign the keyword a value ([#25830]).\n\n  * The pair operator `=>` is now broadcastable as `.=>` which was previously a parsing error ([#27447])\n\nLanguage changes\n----------------\n\n  * The syntax for parametric methods, `function f{T}(x::T)`, has been\n    changed to `function f(x::T) where {T}` ([#11310]).\n\n  * The fallback constructor that calls `convert` is deprecated. Instead, new types should\n    prefer to define constructors, and add `convert` methods that call those constructors\n    only as necessary ([#15120]).\n\n  * The syntax `1.+2` is deprecated, since it is ambiguous: it could mean either\n    `1 .+ 2` (the current meaning) or `1. + 2` ([#19089]).\n\n  * Mutable structs with no fields are no longer singletons; it is now possible to make\n    multiple instances of them that can be distinguished by `===` ([#25854]).\n    Zero-size immutable structs are still singletons.\n\n  * In string and character literals, backslash `\\` may no longer\n    precede unrecognized escape characters ([#22800]).\n\n  * Juxtaposing binary, octal, and hexadecimal literals is deprecated, since it can lead to\n    confusing code such as `0xapi == 0xa * pi` ([#16356]).\n\n  * Numeric literal juxtaposition now has slighty lower precedence than unary operators,\n    so for example `\u221a2x` parses as `(\u221a2) * x` ([#27641]).\n\n  * Declaring arguments as `x::ANY` to avoid specialization has been replaced\n    by `@nospecialize x`. ([#22666]).\n\n    This can also be used in global scope, to apply to all subsequent method definitions\n    in the module (until `@specialize`). ([#28065])\n\n  * Keyword argument default values are now evaluated in successive scopes ---\n    the scope for each expression includes only previous keyword arguments, in\n    left-to-right order ([#17240]).\n\n  * The parsing of `1<<2*3` as `1<<(2*3)` is deprecated, and will change to\n    `(1<<2)*3` in a future version ([#13079]).\n\n  * The parsing of `<|` is now right associative. `|>` remains left associative ([#24153]).\n\n  * `:` now parses like other operators, as a call to a function named `:`, instead of\n    calling `colon` ([#25947]).\n\n  * `{ }` expressions now use `braces` and `bracescat` as expression heads instead\n    of `cell1d` and `cell2d`, and parse similarly to `vect` and `vcat` ([#8470]).\n\n  * Nested `if` expressions that arise from the keyword `elseif` now use `elseif`\n    as their expression head instead of `if` ([#21774]).\n\n  * `let` blocks now parse the same as `for` loops; the first argument is either an\n    assignment or `block` of assignments, and the second argument is a block of\n    statements ([#21774]).\n\n  * `do` syntax now parses to an expression with head `:do`, instead of as a function\n    call ([#21774]).\n\n  * Parsed and lowered forms of type definitions have been synchronized with their\n    new keywords ([#23157]). Expression heads are renamed as follows:\n\n    + `type`           => `struct`\n\n    + `bitstype`       => `primitive` (order of arguments is also reversed, to match syntax)\n\n    + `composite_type` => `struct_type`\n\n    + `bits_type`      => `primitive_type`\n\n  * The `global` keyword now only introduces a new binding if one doesn't already exist\n    in the module.\n    This means that assignment to a global (`global sin = 3`) may now throw the error:\n    \"cannot assign variable Base.sin from module Main\", rather than emitting a warning.\n    Additionally, the new bindings are now created before the statement is executed.\n    For example, `f() = (global sin = \"gluttony\"; nothing)` will now resolve which module\n    contains `sin` eagerly, rather than delaying that decision until `f` is run. ([#22984]).\n\n  * `global const` declarations may no longer appear inside functions ([#12010]).\n\n  * Uninitialized `BitArray` constructors of the form `BitArray[{N}](shape...)` have been\n    deprecated in favor of equivalents accepting `undef` (an alias for\n    `UndefInitializer()`) as their first argument, as in\n    `BitArray[{N}](undef, shape...)`. For example, `BitVector(3)` is now\n    `BitVector(undef, 3)`, `BitMatrix((2, 4))` is now\n    `BitMatrix(undef, (2, 4))`, and `BitArray{3}(11, 13, 17)` is now\n    `BitArray{3}(undef, 11, 14, 17)` ([#24785]).\n\n  * Dispatch rules have been simplified:\n    method matching is now determined exclusively by subtyping;\n    the rule that method type parameters must also be captured has been removed.\n    Instead, attempting to access the unconstrained parameters will throw an `UndefVarError`.\n    Linting in package tests is recommended to confirm that the set of methods\n    which might throw `UndefVarError` when accessing the static parameters\n    (`need_to_handle_undef_sparam = Set{Any}(m.sig for m in Test.detect_unbound_args(Base, recursive=true))`)\n    is equal (`==`) to some known set (`expected = Set()`). ([#23117])\n\n  * `const` declarations on local variables were previously ignored. They now give a\n    warning, so that this syntax can be disallowed or given a new meaning in a\n    future version ([#5148]).\n\n  * Placing an expression after `catch`, as in `catch f(x)`, is deprecated.\n    Use `catch; f(x)` instead ([#19987]).\n\n  * In `for i = ...`, if a local variable `i` already existed it would be overwritten\n    during the loop. This behavior is deprecated, and in the future `for` loop variables\n    will always be new variables local to the loop ([#22314]).\n    The old behavior of overwriting an existing variable is available via `for outer i = ...`.\n\n  * In `for i in x`, `x` used to be evaluated in a new scope enclosing the `for` loop.\n    Now it is evaluated in the scope outside the `for` loop.\n\n  * In `for i in x, j in y`, all variables now have fresh bindings on each iteration of the\n    innermost loop. For example, an assignment to `i` will not be visible on the next `j`\n    loop iteration ([#330]).\n\n  * Variable bindings local to `while` loop bodies are now freshly allocated on each loop iteration,\n    matching the behavior of `for` loops.\n\n  * Prefix `&` for by-reference arguments to `ccall` has been deprecated in favor of\n    `Ref` argument types ([#6080]).\n\n  * The constructor `Ref(x::T)` now always returns a `Ref{T}` ([#21527]).\n\n  * All line numbers in ASTs are represented by `LineNumberNode`s; the `:line` expression\n    head is no longer used. `QuoteNode`s are also consistently used for quoted symbols instead\n    of the `:quote` expression head (though `:quote` `Expr`s are still used for quoted\n    expressions) ([#23885]).\n\n  * The `+` and `-` methods for `Number` and `UniformScaling` are not ambiguous anymore since `+`\n    and `-` no longer do automatic broadcasting. Hence, the methods for `UniformScaling` and `Number` are\n    no longer deprecated ([#23923]).\n\n  * The keyword `importall` is deprecated. Use `using` and/or individual `import` statements\n    instead ([#22789]).\n\n  * `reduce(+, [...])` and `reduce(*, [...])` no longer widen the iterated over arguments to\n    system word size. `sum` and `prod` still preserve this behavior. ([#22825])\n\n  * Like `_`, variable names consisting only of underscores can be assigned,\n    but accessing their values is deprecated ([#24221]).\n\n  * Raw string literal escaping rules have been changed to make it possible to write all strings.\n    The rule is that backslashes escape both quotes and other backslashes, but only when a sequence\n    of backslashes precedes a quote character. Thus, 2n backslashes followed by a quote encodes n\n    backslashes and the end of the literal while 2n+1 backslashes followed by a quote encodes n\n    backslashes followed by a quote character ([#22926]).\n\n  * `reprmime(mime, x)` has been renamed to `repr(mime, x)`, and along with `repr(x)`\n    and `sprint` it now accepts an optional `context` keyword for `IOContext` attributes.\n    `stringmime` has been moved to the Base64 stdlib package ([#25990]).\n\n  * The syntax `(x...)` for constructing a tuple is deprecated; use `(x...,)` instead ([#24452]).\n\n  * Non-parenthesized interpolated variables in strings, e.g. `\"$x\"`, must be followed\n    by a character that will never be an allowed identifier character (currently\n    operators, space/control characters, or common punctuation characters) ([#25231]).\n\n  * The syntax `using A.B` can now only be used when `A.B` is a module, and the syntax\n    `using A: B` can only be used for adding single bindings ([#8000]).\n\n  * `=>` now has its own precedence level, giving it strictly higher precedence than\n    `=` and `,` ([#25391]).\n\n  * The conditions under which unary operators followed by `(` are parsed as prefix function\n    calls have changed ([#26154]).\n\n  * `begin` is disallowed inside indexing expressions, in order to enable the syntax\n    `a[begin]` (for selecting the first element) in the future ([#23354]).\n\n  * Underscores for `_italics_` and `__bold__` are now supported by the Base Markdown\n    parser. ([#25564])\n\n  * `\u2026` (`\\dots`) and `\u205d` (`\\tricolon`) are now parsed as binary operators ([#26262]).\n\n  * Assignment syntax (`a=b`) inside square bracket expressions (e.g. `A[...]`, `[x, y]`)\n    is deprecated. It will likely be reclaimed in a later version for passing keyword\n    arguments. Note this does not affect updating operators like `+=` ([#25631]).\n\n  * `try` blocks without `catch` or `finally` are no longer allowed. An explicit empty\n    `catch` block should be written instead ([#27554]).\n\n  * `AbstractArray` types that use unconventional (not 1-based) indexing can now support\n    `size`, `length`, and `@inbounds`. To optionally enforce conventional indices,\n    you can `@assert !has_offset_axes(A)`.\n\n  * Module pre-compilation is now the default for code loading. Adding a\n    `__precompile__()` declaration is no longer necessary, although\n    `__precompile__(false)` can still be used to opt-out ([#26991]).\n\nBreaking changes\n----------------\n\nThis section lists changes that do not have deprecation warnings.\n\n  * The package manager `Pkg` has been replaced with a new one. See the manual entries on\n    \"Code Loading\" and \"Pkg\" for documentation.\n\n  * `replace(s::AbstractString, pat=>repl)` for function `repl` arguments formerly\n    passed a substring to `repl` in all cases.  It now passes substrings for\n    string patterns `pat`, but a `Char` for character patterns (when `pat` is a\n    `Char`, collection of `Char`, or a character predicate) ([#25815]).\n\n  * `readuntil` now does *not* include the delimiter in its result, matching the\n    behavior of `readline`. Pass `keep=true` to get the old behavior ([#25633]).\n\n  * `lu` methods now return decomposition objects such as `LU` rather than\n    tuples of arrays or tuples of numbers ([#26997], [#27159], [#27212]).\n\n  * `schur` methods now return decomposition objects such as `Schur` and\n    `GeneralizedSchur` rather than tuples of arrays ([#26997], [#27159], [#27212]).\n\n  * `lq` methods now return decomposition objects such as `LQ`\n    rather than tuples of arrays ([#26997], [#27159], [#27212]).\n\n  * `qr` methods now return decomposition objects such as `QR`, `QRPivoted`,\n    and `QRCompactWY` rather than tuples of arrays ([#26997], [#27159], [#27212]).\n\n  * `svd` methods now return decomposition objects such as `SVD` and\n    `GeneralizedSVD` rather than tuples of arrays or tuples of numbers ([#26997], [#27159], [#27212]).\n\n  * `countlines` now always counts the last non-empty line even if it does not\n    end with EOL, matching the behavior of `eachline` and `readlines` ([#25845]).\n\n  * `getindex(s::String, r::UnitRange{Int})` now throws `StringIndexError` if `last(r)`\n    is not a valid index into `s` ([#22572]).\n\n  * `ntuple(f, n::Integer)` throws `ArgumentError` if `n` is negative.\n    Previously an empty tuple was returned ([#21697]).\n\n  * `\u22ee`, `\u22f1`, `\u22f0`, and `\u22ef` are now parsed as binary operators, not ordinary\n    identifiers.  `\u2254`, `\u2255`, and `\u2a74` now parse with assignment rather than comparison\n    precedence ([#26262]).\n\n  * Juxtaposing string literals (e.g. `\"x\"y`) is now a syntax error ([#20575]).\n\n  * `finalizer(function, object)` now returns `object` rather than `nothing` ([#24679]).\n\n  * The constructor of `SubString` now checks if the requested view range\n    is defined by valid indices in the parent `AbstractString` ([#22511]).\n\n  * Macro calls with `for` expressions are now parsed as generators inside\n    function argument lists ([#18650]). Examples:\n\n    + `sum(@inbounds a[i] for i = 1:n)` used to give a syntax error, but is now\n      parsed as `sum(@inbounds(a[i]) for i = 1:n)`.\n\n    + `sum(@m x for i = 1:n end)` used to parse the argument to `sum` as a 2-argument\n      call to macro `@m`, but now parses it as a generator plus a syntax error\n      for the dangling `end`.\n\n  * `@__DIR__` returns the current working directory rather than `nothing` when not run\n    from a file ([#21759]).\n\n  * `@__FILE__` and `@__DIR__` return information relative to the file that it was parsed from,\n    rather than from the task-local `SOURCE_PATH` global when it was expanded.\n\n  * All macros receive an extra argument `__source__::LineNumberNode` which describes the\n    parser location in the source file for the `@` of the macro call.\n    It can be accessed as a normal argument variable in the body of the macro.\n    This is implemented by inserting an extra leading argument into the\n    `Expr(:macrocall, :@name, LineNumberNode(...), args...)`\n    surface syntax. ([#21746])\n\n  * Passing the same keyword argument multiple times is now a syntax error ([#16937]).\n\n  * `getsockname` on a `TCPSocket` now returns the locally bound address and port\n    of the socket. Previously the address of the remote endpoint was being\n    returned ([#21825]).\n\n  * The `~/.juliarc.jl` file has been moved to `~/.julia/config/startup.jl` and\n    `/etc/julia/juliarc.jl` file has been renamed to `/etc/julia/startup.jl` ([#26161]).\n\n  * Using `ARGS` within `startup.jl` files or within a .jl file loaded with `--load` will no\n    longer contain the script name as the first argument. Instead, the script name will be\n    assigned to `PROGRAM_FILE`. ([#22092])\n\n  * The format for a `ClusterManager` specifying the cookie on the command line is now\n    `--worker=<cookie>`. `--worker <cookie>` will not work as it is now an optional argument.\n\n  * The representation of `CartesianRange` has changed to a\n    tuple-of-AbstractUnitRanges; the `start` and `stop` fields are no\n    longer present. Use `first(R)` and `last(R)` to obtain\n    start/stop. ([#20974])\n\n  * The `Diagonal`, `Bidiagonal`, `Tridiagonal` and `SymTridiagonal` type definitions have\n    changed from `Diagonal{T}`, `Bidiagonal{T}`, `Tridiagonal{T}` and `SymTridiagonal{T}`\n    to `Diagonal{T,V<:AbstractVector{T}}`, `Bidiagonal{T,V<:AbstractVector{T}}`,\n    `Tridiagonal{T,V<:AbstractVector{T}}` and `SymTridiagonal{T,V<:AbstractVector{T}}`\n    respectively ([#22718], [#22925], [#23035], [#23154]).\n\n  * The immediate supertype of `BitArray` is now simply `AbstractArray`. `BitArray` is no longer\n    considered a subtype of `DenseArray` and `StridedArray` ([#25858]).\n\n  * When called with an argument that contains `NaN` elements, `findmin` and `findmax` now return the\n    first `NaN` found and its corresponding index. Previously, `NaN` elements were ignored.\n    The new behavior matches that of `min`, `max`, `minimum`, and `maximum`.\n\n  * `isapprox(x,y)` now tests `norm(x-y) <= max(atol, rtol*max(norm(x), norm(y)))`\n    rather than `norm(x-y) <= atol + ...`, and `rtol` defaults to zero\n    if an `atol > 0` is specified ([#22742]).\n\n  * Spaces are no longer allowed between `@` and the name of a macro in a macro call ([#22868]).\n\n  * Juxtaposition of a non-literal with a macro call (`x@macro`) is no longer valid syntax ([#22868]).\n\n  * On a cluster, all files are now loaded from the local file system rather than node 1 ([#22588]).\n    To load the same file everywhere from node 1, one possible alternative is to broadcast a call to `include_string`:\n    `@everywhere include_string(Main, $(read(\"filename\", String)), \"filename\")`.\n    Improving upon this API is left as an opportunity for packages.\n\n  * `randperm(n)` and `randcycle(n)` now always return a `Vector{Int}` (independent of\n    the type of `n`). Use the corresponding mutating functions `randperm!` and `randcycle!`\n    to control the array type ([#22723]).\n\n  * Hermitian now ignores any imaginary components in the diagonal instead of checking\n    the diagonal. ([#17367])\n\n  * Worker-worker connections are setup lazily for an `:all_to_all` topology. Use keyword\n    arg `lazy=false` to force all connections to be setup during a `addprocs` call. ([#22814])\n\n  * In `joinpath(a, b)` on Windows, if the drive specifications of `a` and `b` do not match,\n    `joinpath` now returns `b` instead of throwing an `ArgumentError`. `joinpath(path...)` is\n    defined to be left associative, so if any argument has a drive path which does not match\n    the drive of the join of the preceding paths, the prior ones are dropped. ([#20912])\n\n  * `^(A::AbstractMatrix{<:Integer}, p::Integer)` now throws a `DomainError`\n    if `p < 0`, unless `A == one(A)` or `A == -one(A)` (same as for\n    `^(A::Integer, p::Integer)`) ([#23366]).\n\n  * `^(A::AbstractMatrix{<:Integer}, p::Integer)` now promotes the element type in the same\n    way as `^(A::Integer, p::Integer)`. This means, for instance, that `[1 1; 0 1]^big(1)`\n    will return a `Matrix{BigInt}` instead of a `Matrix{Int}` ([#23366]).\n\n  * The element type of the input is now preserved in `unique`. Previously the element type\n    of the output was shrunk to fit the union of the type of each element in the input.\n    ([#22696])\n\n  * The `promote` function now raises an error if its arguments are of different types\n    and if attempting to convert them to a common type fails to change any of their types.\n    This avoids stack overflows in the common case of definitions like\n    `f(x, y) = f(promote(x, y)...)` ([#22801]).\n\n  * `indmin` and `indmax` have been renamed to `argmin` and `argmax`, respectively ([#25654]).\n\n  * `findmin`, `findmax`, `argmin`, and `argmax` used to always return linear indices.\n    They now return `CartesianIndex`es for all but 1-d arrays, and in general return\n    the `keys` of indexed collections (e.g. dictionaries) ([#22907]).\n\n  * The `openspecfun` library is no longer built and shipped with Julia, as it is no longer\n    used internally ([#22390]).\n\n  * All loaded packages used to have bindings in `Main` (e.g. `Main.Package`). This is no\n    longer the case; now bindings will only exist for packages brought into scope by\n    typing `using Package` or `import Package` ([#17997]).\n\n  * The rules for mixed-signedness integer arithmetic (e.g. `Int32(1) + UInt64(1)`) have been\n    simplified: if the arguments have different sizes (in bits), then the type of the larger\n    argument is used. If the arguments have the same size, the unsigned type is used ([#9292]).\n\n  * All command line arguments passed via `-e`, `-E`, and `-L` will be executed in the order\n    given on the command line ([#23665]).\n\n  * `I` now yields `UniformScaling{Bool}(true)` rather than `UniformScaling{Int64}(1)`\n    to better preserve types in operations involving `I` ([#24396]).\n\n  * The return type of `reinterpret` has changed to `ReinterpretArray`. `reinterpret` on sparse\n    arrays has been discontinued.\n\n  * `Base.find_in_path` is now `Base.find_package` or `Base.find_source_file` ([#24320]).\n\n  * `finalizer` now takes functions or pointers as its first argument, and the object being\n    finalized as its second (rather than the reverse). For the majority of use cases\n    deprecation warnings will be triggered. However, deprecation warnings will not trigger where\n    (1) the callable argument is not a subtype of `Function`; or (2) both arguments are\n    `Function`s or `Ptr{Cvoid}`s ([#24605]).\n\n  * The `kill` function now throws errors on user error (e.g. on permission\n    errors), but returns successfully if the process had previously exited.\n    Its return value has been removed. Use the `process_running` function\n    to determine if a process has already exited.\n\n  * The logging system has been redesigned - `info` and `warn` are deprecated\n    and replaced with the logging macros `@info`, `@warn`, `@debug` and\n    `@error`.  The `logging` function is also deprecated and replaced with\n    `AbstractLogger` and the functions from the new standard `Logging` library.\n    ([#24490])\n\n  * The `RevString` type has been removed from the language; `reverse(::String)` returns\n    a `String` with code points (or fragments thereof) in reverse order. In general,\n    `reverse(s)` should return a string of the same type and encoding as `s` with code\n    points in reverse order; any string type overrides `reverse` to return a different\n    type of string must also override `reverseind` to compute reversed indices correctly.\n\n  * `eachindex(A, B...)` now requires that all inputs have the same number of elements.\n    When the chosen indexing is Cartesian, they must have the same axes.\n\n  * `AbstractRange` objects are now considered as equal to other `AbstractArray` objects\n    by `==` and `isequal` if all of their elements are equal ([#16401]).\n    This has required changing the hashing algorithm: ranges now use an O(N) fallback\n    instead of a O(1) specialized method unless they define the `Base.RangeStepStyle`\n    trait; see its documentation for details. Types which support subtraction (operator\n    `-`) must now implement `widen` for hashing to work inside heterogeneous arrays.\n\n  * `findn(x::AbstractArray)` has been deprecated in favor of `findall(!iszero, x)`, which\n    now returns cartesian indices for multidimensional arrays (see below, [#25532]).\n\n  * Broadcasting operations are no longer fused into a single operation by Julia's parser.\n    Instead, a lazy `Broadcasted` object is created to represent the fused expression and\n    then realized with `copy(bc::Broadcasted)` or `copyto!(dest, bc::Broadcasted)`\n    to evaluate the wrapper. Consequently, package authors generally need to specialize\n    `copy` and `copyto!` methods rather than `broadcast` and `broadcast!`. This also allows\n    for more customization and control of fused broadcasts. See the\n    [Interfaces chapter](https://docs.julialang.org/en/v1/manual/interfaces/#man-interfaces-broadcasting-1)\n    for more information.\n\n  * `find` has been renamed to `findall`. `findall`, `findfirst`, `findlast`, `findnext`\n    now take and/or return the same type of indices as `keys`/`pairs` for `AbstractArray`,\n    `AbstractDict`, `AbstractString`, `Tuple` and `NamedTuple` objects ([#24774], [#25545]).\n    In particular, this means that they use `CartesianIndex` objects for matrices\n    and higher-dimensional arrays instead of linear indices as was previously the case.\n    Use `LinearIndices(a)[findall(f, a)]` and similar constructs to compute linear indices.\n\n  * The `find*` functions, i.e. `findnext`, `findprev`, `findfirst`,\n    and `findlast`, as well as `indexin`, now return `nothing` when no match is found rather\n    than `0` or `0:-1` ([#25472], [#25662], [#26149])\n\n  * The `Base.HasShape` iterator trait has gained a type parameter `N` indicating the\n    number of dimensions, which must correspond to the length of the tuple returned by\n    `size` ([#25655]).\n\n * `AbstractSet` objects are now considered equal by `==` and `isequal` if all of their\n    elements are equal ([#25368]). This has required changing the hashing algorithm\n    for `BitSet`.\n\n  * the default behavior of `titlecase` is changed in two ways ([#23393]):\n    + characters not starting a word are converted to lowercase;\n      a new keyword argument `strict` is added which\n      allows to get the old behavior when it's `false`.\n    + any non-letter character is considered as a word separator;\n      to get the old behavior (only \"space\" characters are considered as\n      word separators), use the keyword `wordsep=isspace`.\n\n  * `writedlm` in the standard library module DelimitedFiles now writes numeric values\n    using `print` rather than `print_shortest` ([#25745]).\n\n  * The `tempname` function used to create a file on Windows but not on other\n    platforms. It now never creates a file ([#9053]).\n\n  * The `fieldnames` and `propertynames` functions now return a tuple rather than\n    an array ([#25725]).\n\n  * `indexin` now returns the first rather than the last matching index ([#25998]).\n\n  * `parse(::Type, ::Char)` now uses a default base of 10, like other number parsing\n    methods, instead of 36 ([#26576]).\n\n  * `isequal` for `Ptr`s now compares element types; `==` still compares only addresses\n    ([#26858]).\n\n  * `widen` on 8- and 16-bit integer types now widens to 16- and 32-bit types, respectively. ([#28045]).\n\n  * `mv`,`cp`, `touch`, `mkdir`, `mkpath`, `chmod` and `chown` now return the path that was created/modified\n    rather than `nothing` ([#27071]).\n\n  * Regular expressions now default to UCP mode. Escape sequences such as `\\w`\n    will now match based on unicode character properties, e.g. `r\"\\w+\"` will\n    match `caf\u00e9` (not just `caf`). Add the `a` modifier (e.g. `r\"\\w+\"a`) to\n    restore the previous behavior ([#27189]).\n\n  * `@sync` now waits only for *lexically* enclosed (i.e. visible directly in the source\n    text of its argument) `@async` expressions. If you need to wait for a task created by\n    a called function `f`, have `f` return the task and put `@async wait(f(...))` within\n    the `@sync` block.\n    This change makes `@schedule` redundant with `@async`, so `@schedule` has been\n    deprecated ([#27164]).\n\n  * `norm(A::AbstractMatrix, p=2)` computes no longer the operator/matrix norm but the `norm` of `A`\n    as for other iterables, i.e. as if it were a vector. Especially, `norm(A::AbstractMatrix)` is the\n    Frobenius norm. To compute the operator/matrix norm, use the new function `opnorm` ([#27401]).\n\n  * `dot(u, v)` now acts recursively. Instead of `sum(u[i]' * v[i] for i in ...)`, it computes\n    `sum(dot(u[i], v[i]) for i in ...)`, similarly to `vecdot` before ([#27401]).\n\n  * `Sys.CPU_CORES` has been renamed to `Sys.CPU_THREADS`; it still gives the number\n    of \"logical cores\" (including hyperthreading) rather than the number of physical\n    cores present on the CPU. Similarly, the environment variable `JULIA_CPU_CORES` is\n    deprecated in favor of `JULIA_CPU_THREADS` ([#27856]).\n\n  * `WeakKeyDict` does not convert keys on insertion anymore (#24941).\n\nLibrary improvements\n--------------------\n\n  * The function `thisind(s::AbstractString, i::Integer)` returns the largest valid index\n    less or equal than `i` in the string `s` or `0` if no such index exists ([#24414]).\n\n  * Support for Unicode 11 ([#28266]).\n\n  * `Char` is now a subtype of `AbstractChar`, and most of the functions that\n    take character arguments now accept any `AbstractChar` ([#26286]).\n\n  * `pathof(module)` returns the path a module was imported from ([#28310]).\n\n  * `bytes2hex` now accepts an optional `io` argument to output to a hexadecimal stream\n    without allocating a `String` first ([#27121]).\n\n  * `String(array)` now accepts an arbitrary `AbstractVector{UInt8}`. For `Vector`\n    inputs, it \"steals\" the memory buffer, leaving them with an empty buffer which\n    is guaranteed not to be shared with the `String` object. For other types of vectors\n    (in particular immutable vectors), a copy is made and the input is not truncated ([#26093]).\n\n  * `Irrational` is now a subtype of `AbstractIrrational` ([#24245]).\n\n  * Introduced the `empty` function, the functional pair to `empty!` which returns a new,\n    empty container ([#24390]).\n\n  * Jump to first/last history entries in the REPL via \"Alt-<\" and \"Alt->\" ([#22829]).\n\n  * REPL LaTeX-like tab completions have been simplified for several Unicode characters,\n    e.g. `\ud835\udd38` is now `\\bbA` rather than `\\BbbA` ([#25980]).\n\n  * The function `chop` now accepts two arguments `head` and `tail` allowing to specify\n    number of characters to remove from the head and tail of the string ([#24126]).\n\n  * `get(io, :color, false)` can now be used to query whether a stream `io` supports\n    [ANSI color codes](https://en.wikipedia.org/wiki/ANSI_escape_code) ([#25067]),\n    rather than using the undocumented `Base.have_color` global flag.\n\n  * `print_with_color` has been deprecated in favor of\n    `printstyled([io], xs...; bold=false, color=:normal)` for printing styled text ([#25522]).\n\n  * Functions `first` and `last` now accept `nchar` argument for `AbstractString`.\n    If this argument is used they return a string consisting of first/last `nchar`\n    characters from the original string ([#23960]).\n\n  * Expressions `x^-n` where `n` is an *integer literal* now correspond to `inv(x)^n`.\n    For example, `x^-1` is now essentially a synonym for `inv(x)`, and works\n    in a type-stable way even if `typeof(x) != typeof(inv(x))` ([#24240]).\n\n  * New `Iterators.reverse(itr)` for reverse-order iteration ([#24187]).  Iterator\n    types `T` can implement `start` etc. for `Iterators.Reverse{T}` to support this.\n\n  * The functions `nextind` and `prevind` now accept `nchar` argument that indicates\n    the number of characters to move ([#23805]).\n\n  * The functions `strip`, `lstrip` and `rstrip` now return `SubString` ([#22496]).\n\n  * The functions `strwidth` and `charwidth` have been merged into `textwidth`([#20816]).\n\n  * The functions `base` and `digits` digits now accept a negative\n    base (like `ndigits` did) ([#21692]).\n\n  * The function `randn` now accepts complex arguments (`Complex{T <: AbstractFloat}`)\n    ([#21973]).\n\n  * `parse(Complex{T}, string)` can parse complex numbers in some common formats ([#24713]).\n\n  * The function `rand` can now pick up random elements from strings, associatives\n    and sets ([#22228], [#21960], [#18155], [#22224]).\n\n  * It's now possible to specify the characters to pick from in the `randstring` function ([#22222]).\n\n  * Allow multidimensional arrays in `shuffle` and `shuffle!` functions ([#22226]).\n\n  * Method lists are now printed as a numbered list. In addition, the source code of a\n    method can be opened in an editor by entering the corresponding number in the REPL\n    and pressing `^Q` ([#22007]).\n\n  * `getpeername` on a `TCPSocket` returns the address and port of the remote\n    endpoint of the TCP connection ([#21825]).\n\n  * `resize!` and `sizehint!` methods no longer over-reserve memory when the\n    requested array size is more than double of its current size ([#22038]).\n\n  * The `crc32c` function for CRC-32c checksums is now exported ([#22274]).\n\n  * `eye(::Type{Diagonal{T}}, m::Integer)` has been deprecated in favor of\n    `Diagonal{T}(I, m)` ([#24415]).\n\n  * The output of `versioninfo` is now controlled with keyword arguments ([#21974]).\n\n  * The function `LibGit2.set_remote_url` now always sets both the fetch and push URLs for a\n    git repo. Additionally, the argument order was changed to be consistent with the git\n    command line tool ([#22062]).\n\n  * Added `unique!` which is an inplace version of `unique` ([#20549]).\n\n  * `@test isequal(x, y)` and `@test isapprox(x, y)` now prints an evaluated expression when\n    the test fails ([#22296]).\n\n  * Uses of `Val{c}` in `Base` has been replaced with `Val{c}()`, which is now easily\n    accessible via the efficient constructor `Val(c)`. Functions are defined as\n    `f(::Val{c}) = ...` and called by `f(Val(c))`. Notable affected functions include:\n    `ntuple`, `Base.literal_pow`, `sqrtm`, `lufact`, `lufact!`, `qrfact`, `qrfact!`,\n    `cholfact`, `cholfact!`, `_broadcast!`, `reshape`, `cat` and `cat_t`.\n\n  * A new `@macroexpand1` macro for non recursive macro expansion ([#21662]).\n\n  * `Char`s can now be concatenated with `String`s and/or other `Char`s using `*` ([#22532]).\n\n  * `Diagonal`, `Bidiagonal`, `Tridiagonal` and `SymTridiagonal` are now parameterized on\n    the type of the wrapped vectors, allowing `Diagonal`, `Bidiagonal`, `Tridiagonal` and\n    `SymTridiagonal` matrices with arbitrary `AbstractVector`s\n    ([#22718], [#22925], [#23035], [#23154]).\n\n  * Mutating versions of `randperm` and `randcycle` have been added:\n    `randperm!` and `randcycle!` ([#22723]).\n\n  * `BigFloat` random numbers can now be generated ([#22720]).\n\n  * The efficiency of random generation for MersenneTwister RNGs has been improved for\n    integers, `Float64` and ranges; as a result, given a seed, the produced stream of numbers\n    has changed ([#27560], [#25277], [#25197], [#25058], [#25047]).\n\n  * REPL Undo via Ctrl-/ and Ctrl-_\n\n  * `diagm` now accepts several diagonal index/vector `Pair`s ([#24047]).\n\n  * `isequal`, `==`, and `in` have one argument \"curried\" forms. For example `isequal(x)`\n    returns a function that compares its argument to `x` using `isequal` ([#26436]).\n\n  * `reinterpret` now works on any AbstractArray using the new `ReinterpretArray` type.\n    This supersedes the old behavior of reinterpret on Arrays. As a result, reinterpreting\n    arrays with different alignment requirements (removed in 0.6) is once again allowed ([#23750]).\n\n  * The `keys` of an `Associative` are now an `AbstractSet`. `Base.KeyIterator{<:Associative}`\n    has been changed to `KeySet{K, <:Associative{K}} <: AbstractSet{K}` ([#24580]).\n\n  * New function `ncodeunits(s::AbstractString)` gives the number of code units in a string.\n    The generic definition is constant time but calls `lastindex(s)` which may be inefficient.\n    Therefore custom string types may want to define direct `ncodeunits` methods.\n\n  * `reverseind(s::AbstractString, i::Integer)` now has an efficient generic fallback, so\n    custom string types do not need to provide their own efficient definitions. The generic\n    definition relies on `ncodeunits` however, so for optimal performance you may need to\n    define a custom method for that function.\n\n  * The global RNG is being re-seeded with its own seed at the beginning of each `@testset`,\n    and have its original state restored at the end ([#24445]). This is breaking for testsets\n    relying implicitly on the global RNG being in a specific state.\n\n  * `permutedims(m::AbstractMatrix)` is now short for `permutedims(m, (2,1))`, and is now a\n    more convenient way of making a \"shallow transpose\" of a 2D array. This is the\n    recommended approach for manipulating arrays of data, rather than the recursively\n    defined, linear-algebra function `transpose`. Similarly,\n    `permutedims(v::AbstractVector)` will create a row matrix ([#24839]).\n\n  * A new `replace(A, old=>new)` function is introduced to replace `old` by `new` in\n    collection `A`. There is also another method with a different API, and\n    a mutating variant, `replace!` ([#22324], [#25697], [#26206], [#27944]).\n\n  * Adding integers to `CartesianIndex` objects is now deprecated. Instead of\n    `i::Int + x::CartesianIndex`, use `i*one(x) + x` ([#26284]).\n\n  * `CartesianRange` changes ([#24715]):\n    - Inherits from `AbstractArray`, and linear indexing can be used to provide\n      linear-to-cartesian conversion ([#24715])\n    - It has a new constructor taking an array\n\n  * several missing set-like operations have been added ([#23528]):\n    `union`, `intersect`, `symdiff`, `setdiff` are now implemented for\n    all collections with arbitrary many arguments, as well as the\n    mutating counterparts (`union!` etc.). The performance is also\n    much better in many cases. Note that this change is slightly\n    breaking: all the non-mutating functions always return a new\n    object even if only one argument is passed. Moreover the semantics\n    of `intersect` and `symdiff` is changed for vectors:\n    + `intersect` doesn't preserve the multiplicity anymore (use `filter` for\n      the old behavior)\n    + `symdiff` has been made consistent with the corresponding methods for\n      other containers, by taking the multiplicity of the arguments into account.\n      Use `unique` to get the old behavior.\n\n  * The `linearindices` function has been deprecated in favor of the new\n    `LinearIndices` type, which additionally provides conversion from\n    cartesian indices to linear indices using the normal indexing operation.\n    ([#24715], [#26775]).\n\n  * `IdDict{K,V}` replaces `ObjectIdDict`.  It has type parameters\n    like other `AbstractDict` subtypes and its constructors mirror the\n    ones of `Dict`. ([#25210])\n\n  * `IOBuffer` can take the `sizehint` keyword argument to suggest a capacity of\n    the buffer ([#25944]).\n\n  * `lstrip` and `rstrip` now accept a predicate function that defaults to `isspace`\n    ([#27309]).\n\n  * `trunc`, `floor`, `ceil`, and `round` specify `digits`, `sigdigits` and `base` using\n    keyword arguments. ([#26156], [#26670])\n\n  * `Sys.which()` provides a cross-platform method to find executable files, similar to\n    the Unix `which` command. ([#26559])\n\n  * Added an optimized method of `vecdot` for taking the Frobenius inner product\n    of sparse matrices. ([#27470])\n\n  * Added an optimized method of `kron` for taking the tensor product of two\n    `Diagonal` matrices. ([27581])\n\n  * An official API for extending `rand` is now defined ([#23964], [#25002]).\n\n  * The constructor `MersenneTwister()` is re-enabled, producing a randomly initialized RNG\n    (similar to `Random.seed!(MersenneTwister(0))`) ([#21909]).\n\n  * `BitSet` can now store any `Int` (instead of only positive ones) ([#25029]).\n\n  * The initial element `v0` in `reduce(op, v0, itr)` has been replaced with an `init`\n    optional keyword argument, as in `reduce(op, itr; init=v0)`. Similarly for `foldl`,\n    `foldr`, `mapreduce`, `mapfoldl`, `mapfoldr`, `accumulate` and `accumulate!`.\n    ([#27711], [#27859])\n\nCompiler/Runtime improvements\n-----------------------------\n\n  * The inlining heuristic now models the approximate runtime cost of\n    a method (using some strongly-simplifying assumptions). Functions\n    are inlined unless their estimated runtime cost substantially\n    exceeds the cost of setting up and issuing a subroutine\n    call. ([#22210], [#22732])\n\n  * Inference recursion-detection heuristics are now more precise,\n    allowing them to be triggered less often, but being more aggressive when they\n    are triggered to drive the inference computation to a solution ([#23912]).\n\n  * Inference now propagates constants inter-procedurally, and can compute\n    various constants expressions at compile-time ([#24362]).\n\n  * The LLVM SLP Vectorizer optimization pass is now enabled at the default\n    optimization level.\n\nDeprecated or removed\n---------------------\n\n  * The `JULIA_HOME` environment variable has been renamed to `JULIA_BINDIR` and\n    `Base.JULIA_HOME` has been moved to `Sys.BINDIR` ([#20899]).\n\n  * The keyword `immutable` is fully deprecated to `struct`, and\n    `type` is fully deprecated to `mutable struct` ([#19157], [#20418]).\n\n  * `lufact`, `schurfact`, `lqfact`, `qrfact`, `ldltfact`, `svdfact`,\n    `bkfact`, `hessfact`, `eigfact`, and `cholfact` have respectively been\n    deprecated to `lu`, `schur`, `lq`, `qr`, `ldlt`, `svd`, `bunchkaufman`,\n    `hessenberg`, `eigen`, and `cholesky` ([#26997], [#27159], [#27212]).\n\n  * `lufact!`, `schurfact!`, `lqfact!`, `qrfact!`, `ldltfact!`, `svdfact!`,\n    `bkfact!`, `hessfact!`, and `eigfact!` have respectively been deprecated to\n    `lu!`, `schur!`, `lq!`, `qr!`, `ldlt!`, `svd!`, `bunchkaufman!`,\n    `hessenberg!`, and `eigen!` ([#26997], [#27159], [#27212]).\n\n  * `eig(A[, args...])` has been deprecated in favor of `eigen(A[, args...])`.\n    Whereas the former returns a tuple of arrays, the latter returns an `Eigen` object.\n    So for a direct replacement, use `(eigen(A[, args...])...,)`. But going forward,\n    consider using the direct result of `eigen(A[, args...])` instead, either\n    destructured into its components (`vals, vecs = eigen(A[, args...])`) or\n    as an `Eigen` object (`X = eigen(A[, args...])`) ([#26997], [#27159], [#27212]).\n\n  * `eig(A::AbstractMatrix, B::AbstractMatrix)` and `eig(A::Number, B::Number)`\n    have been deprecated in favor of `eigen(A, B)`. Whereas the former each return\n    a tuple of arrays, the latter returns a `GeneralizedEigen` object. So for a direct\n    replacement, use `(eigen(A, B)...,)`. But going forward, consider using the\n    direct result of `eigen(A, B)` instead, either destructured into its components\n    (`vals, vecs = eigen(A, B)`), or as a `GeneralizedEigen` object\n    (`X = eigen(A, B)`) ([#26997], [#27159], [#27212]).\n\n  * `ordschur(T::StridedMatrix{Ty}, Z::StridedMatrix{Ty}, select::Union{Vector{Bool},BitVector})`\n    and `ordschur(S::StridedMatrix{Ty}, T::StridedMatrix{Ty}, Q::StridedMatrix{Ty},\n    Z::StridedMatrix{Ty}, select::Union{Vector{Bool},BitVector})` and their respective\n    inplace versions have been deprecated.\n    Use `ordschur(schur::Schur, select::Union{Vector{Bool},BitVector})` and\n    `ordschur(gschur::GeneralizedSchur, select::Union{Vector{Bool},BitVector})` instead\n    ([#28155]).\n\n  * Indexing into multidimensional arrays with more than one index but fewer indices than there are\n    dimensions is no longer permitted when those trailing dimensions have lengths greater than 1.\n    Instead, reshape the array or add trailing indices so the dimensionality and number of indices\n    match ([#14770], [#23628]).\n\n  * The use of a positional dimension argument has largely been deprecated in favor of a\n    `dims` keyword argument. This includes the functions `sum`, `prod`, `maximum`,\n    `minimum`, `all`, `any`, `findmax`, `findmin`, `mean`, `varm`, `std`, `var`, `cov`,\n    `cor`, `median`, `mapreducedim`, `reducedim`, `sort`, `accumulate`, `accumulate!`,\n    `cumsum`, `cumsum!`, `cumprod`, `cumprod!`, `flipdim`, `dropdims`, and `cat` ([#25501], [#26660], [#27100]).\n\n  * `indices(a)` and `indices(a,d)` have been deprecated in favor of `axes(a)` and\n    `axes(a, d)` ([#25057]).\n\n  * `EnvHash` has been renamed to `EnvDict` ([#24167]).\n\n  * Uninitialized `Array` constructors of the form\n    `Array[{T,N}](shape...)` have been deprecated in favor of equivalents\n    accepting `undef` (an alias for `UndefInitializer()`) as their first argument,\n    as in `Array[{T,N}](undef, shape...)`. For example,\n    `Vector(3)` is now `Vector(undef, 3)`, `Matrix{Int}((2, 4))` is now,\n    `Matrix{Int}(undef, (2, 4))`, and `Array{Float32,3}(11, 13, 17)` is now\n    `Array{Float32,3}(undef, 11, 13, 17)` ([#24781]).\n\n  * Previously `setindex!(A, x, I...)` (and the syntax `A[I...] = x`) supported two\n    different modes of operation when supplied with a set of non-scalar indices `I`\n    (e.g., at least one index is an `AbstractArray`) depending upon the value of `x`\n    on the right hand side. If `x` is an `AbstractArray`, its _contents_ are copied\n    elementwise into the locations in `A` selected by `I` and it must have the same\n    number of elements as `I` selects locations. Otherwise, if `x` is not an\n    `AbstractArray`, then its _value_ is implicitly broadcast to all locations to\n    all locations in `A` selected by `I`. This latter behavior\u2014implicitly broadcasting\n    \"scalar\"-like values across many locations\u2014is now deprecated in favor of explicitly\n    using the broadcasted assignment syntax `A[I...] .= x` or `fill!(view(A, I...), x)`\n    ([#26347]).\n\n  * `broadcast_getindex(A, I...)` and `broadcast_setindex!(A, v, I...)` are deprecated in\n    favor of `getindex.((A,), I...)` and `setindex!.((A,), v, I...)`, respectively ([#27075]).\n\n  * `LinAlg.fillslots!` has been renamed `LinAlg.fillstored!` ([#25030]).\n\n  * `fill!(A::Diagonal, x)` and `fill!(A::AbstractTriangular, x)` have been deprecated\n    in favor of `Base.LinAlg.fillstored!(A, x)` ([#24413]).\n\n  * `eye` has been deprecated in favor of `I` and `Matrix` constructors. Please see the\n    deprecation warnings for replacement details ([#24438]).\n\n  * `zeros(D::Diagonal[, opts...])` has been deprecated ([#24654]).\n\n  * Using Bool values directly as indices is now deprecated and will be an error in the future. Convert\n    them to `Int` before indexing if you intend to access index `1` for `true` and `0` for `false`.\n\n  * `slicedim(A, d, i)` has been deprecated in favor of `copy(selectdim(A, d, i))`. The new\n    `selectdim` function now always returns a view into `A`; in many cases the `copy` is\n    not necessary. Previously, `slicedim` on a vector `V` over dimension `d=1` and scalar\n    index `i` would return the just selected element (unless `V` was a `BitVector`). This\n    has now been made consistent: `selectdim` now always returns a view into the original\n    array, with a zero-dimensional view in this specific case ([#26009]).\n\n  * `whos` has been renamed `varinfo`, and now returns a markdown table instead of printing\n    output ([#12131]).\n\n  * Uninitialized `RowVector` constructors of the form `RowVector{T}(shape...)` have been\n    deprecated in favor of equivalents accepting `undef` (an alias for\n    `UndefInitializer()`) as their first argument, as in\n    `RowVector{T}(undef, shape...)`. For example, `RowVector{Int}(3)` is now\n    `RowVector{Int}(undef, 3)`, and `RowVector{Float32}((1, 4))` is now\n    `RowVector{Float32}(undef, (1, 4))` ([#24786]).\n\n  * `writecsv(io, a; opts...)` has been deprecated in favor of\n    `writedlm(io, a, ','; opts...)` ([#23529]).\n\n  * The method `srand(rng, filename, n=4)` has been deprecated ([#21359]).\n\n  * `readcsv(io[, T::Type]; opts...)` has been deprecated in favor of\n    `readdlm(io, ','[, T]; opts...)` ([#23530]).\n\n  * `sparse(s::UniformScaling, m::Integer)` has been deprecated in favor of the\n    three-argument equivalent `sparse(s::UniformScaling, m, n)` ([#24472]).\n\n  * The `cholfact`/`cholfact!` methods that accepted an `uplo` symbol have been deprecated\n    in favor of using `Hermitian` (or `Symmetric`) views ([#22187], [#22188]).\n\n  * The `thin` keyword argument for orthogonal decomposition methods has\n    been deprecated in favor of `full`, which has the opposite meaning:\n    `thin == true` if and only if `full == false` ([#24279]).\n\n  * `isposdef(A::AbstractMatrix, UL::Symbol)` and `isposdef!(A::AbstractMatrix, UL::Symbol)`\n    have been deprecated in favor of `isposdef(Hermitian(A, UL))` and `isposdef!(Hermitian(A, UL))`\n    respectively ([#22245]).\n\n  * The `bkfact`/`bkfact!` methods that accepted `uplo` and `issymmetric` symbols have been deprecated\n    in favor of using `Hermitian` (or `Symmetric`) views ([#22605]).\n\n  * The function `current_module` is deprecated and replaced with `@__MODULE__`.\n    This caused the deprecation of some reflection methods (such as `macroexpand` and\n    `isconst`), which now require a module argument. And it caused the bugfix of other\n    default arguments to use the Main module (including `whos`, `which`)  ([#22064]).\n\n  * `expand(ex)` and `expand(module, ex)` have been deprecated in favor of\n    `Meta.lower(module, ex)` ([#22064], [#24278]).\n\n  * `ones(A::AbstractArray[, opts...])` and `zeros(A::AbstractArray[, opts...])` methods\n    have been deprecated. For `zeros(A)`, consider `zero(A)`. For `ones(A)` or `zeros(A)`,\n    consider `ones(size(A))`, `zeros(size(A))`, `fill(v, size(A))` for `v` an appropriate\n    one or zero, `fill!(copy(A), {1|0})`, `fill!(similar(A), {1|0})`, or any of the preceding\n    with different element type and/or shape depending on `opts...`. Where strictly\n    necessary, consider `fill!(similar(A[, opts...]), {one(eltype(A)) | zero(eltype(A))})`.\n    For an algebraic multiplicative identity, consider `one(A)` ([#24656]).\n\n  * The `similar(dims->f(..., dims...), [T], axes...)` method to add offset array support\n    to a function `f` that would otherwise create a non-offset array has been deprecated.\n    Instead, call `f(..., axes...)` directly and, if needed, the offset array implementation\n    should add offset axis support to the function `f` directly ([#26733]).\n\n  * The functions `ones` and `zeros` used to accept any objects as dimensional arguments,\n    implicitly converting them to `Int`s.  This is now deprecated; only `Integer`s or\n    `AbstractUnitRange`s are accepted as arguments.  Instead, convert the arguments before\n    calling `ones` or `zeros` ([#26733]).\n\n  * The variadic `size(A, dim1, dim2, dims...)` method to return a tuple of multiple\n    dimension lengths of `A` has been deprecated ([#26862]).\n\n  * The `Operators` module is deprecated. Instead, import required operators explicitly\n    from `Base`, e.g. `import Base: +, -, *, /` ([#22251]).\n\n  * Bindings to the FFTW library have been removed from Base. The DFT framework for building FFT\n    implementations is now in AbstractFFTs.jl, the bindings to the FFTW library are in FFTW.jl,\n    and the Base signal processing functions which used FFTs are now in DSP.jl ([#21956]).\n\n  * The `corrected` positional argument to `cov` has been deprecated in favor of\n    a keyword argument with the same name ([#21709]).\n\n  * Omitting spaces around the `?` and the `:` tokens in a ternary expression has been deprecated.\n    Ternaries must now include some amount of whitespace, e.g. `x ? a : b` rather than\n    `x?a:b` ([#22523] and [#22712]).\n\n  * `?` can no longer be used as an identifier name ([#22712])\n\n  * The method `replace(s::AbstractString, pat, r, [count])` is deprecated\n    in favor of `replace(s::AbstractString, pat => r; [count])` ([#25165]).\n    Moreover, `count` cannot be negative anymore (use `typemax(Int)` instead ([#22325]).\n\n  * `read(io, type, dims)` is deprecated to `read!(io, Array{type}(undef, dims))` ([#21450]).\n\n  * `read(::IO, ::Ref)` is now a method of `read!`, since it mutates its `Ref` argument ([#21592]).\n\n  * `nb_available` is now `bytesavailable` ([#25634]).\n\n  * `skipchars(io::IO, predicate; linecomment=nothing)` is deprecated in favor of\n    `skipchars(predicate, io::IO; linecomment=nothing)` ([#25667]).\n\n  * `Bidiagonal` constructors now use a `Symbol` (`:U` or `:L`) for the upper/lower\n    argument, instead of a `Bool` or a `Char` ([#22703]).\n\n  * `Bidiagonal`, `Tridiagonal` and `SymTridiagonal` constructors that automatically\n    converted the input vectors to the same type are deprecated in favor of explicit\n    conversion ([#22925], [#23035], [#23154].\n\n  * Calling `nfields` on a type to find out how many fields its instances have is deprecated.\n    Use `fieldcount` instead. Use `nfields` only to get the number of fields in a specific object ([#22350]).\n\n  * `fieldnames` now operates only on types. To get the names of fields in an object, use\n    `fieldnames(typeof(x))` ([#22350]).\n\n  * `InexactError`, `DomainError`, and `OverflowError` now take\n    arguments. `InexactError(func::Symbol, type, -3)` now prints as\n    \"ERROR: InexactError: func(type, -3)\", `DomainError(val,\n    [msg])` prints as \"ERROR: DomainError with val:\\nmsg\",\n    and `OverflowError(msg)` prints as \"ERROR: OverflowError: msg\".\n    ([#20005], [#22751], [#22761])\n\n  * The operating system identification functions: `is_linux`, `is_bsd`, `is_apple`, `is_unix`,\n    and `is_windows`, have been deprecated in favor of `Sys.islinux`, `Sys.isbsd`, `Sys.isapple`,\n    `Sys.isunix`, and `Sys.iswindows`, respectively ([#22182]).\n\n  * The forms of `read`, `readstring`, and `eachline` that accepted both a `Cmd` object and an\n    input stream are deprecated. Use e.g. `read(pipeline(stdin, cmd))` instead ([#22762]).\n\n  * The unexported type `AbstractIOBuffer` has been renamed to `GenericIOBuffer` ([#17360] [#22796]).\n\n  * `IOBuffer(data::AbstractVector{UInt8}, read::Bool, write::Bool, maxsize::Integer)`,\n    `IOBuffer(read::Bool, write::Bool)`, and `IOBuffer(maxsize::Integer)` are\n    deprecated in favor of constructors taking keyword arguments ([#25872]).\n\n  * `Display` has been renamed to `AbstractDisplay` ([#24831]).\n\n  * Remaining vectorized methods over `SparseVector`s, particularly `floor`, `ceil`,\n    `trunc`, `round`, and most common transcendental functions such as `exp`, `log`, and\n    `sin` variants, have been deprecated in favor of dot-syntax ([#22961]).\n\n  * The method `String(io::IOBuffer)` is deprecated to `String(take!(copy(io)))` ([#21438]).\n\n  * The function `readstring` is deprecated in favor of `read(io, String)` ([#22793])\n\n  * The function `showall` is deprecated. Showing entire values is the default, unless an\n    `IOContext` specifying `:limit=>true` is in use ([#22847]).\n\n  * `issubtype` has been deprecated in favor of `<:` (which used to be an alias for `issubtype`).\n\n  * Calling `write` on non-isbits arrays is deprecated in favor of explicit loops or\n    `serialize` ([#6466]).\n\n  * The default `startup.jl` file on Windows has been removed. Now must explicitly include the\n    full path if you need access to executables or libraries in the `Sys.BINDIR` directory, e.g.\n    `joinpath(Sys.BINDIR, \"7z.exe\")` for `7z.exe` ([#21540]).\n\n  * `sqrtm` has been deprecated in favor of `sqrt` ([#23504]).\n\n  * `expm` has been deprecated in favor of `exp` ([#23233]).\n\n  * `logm` has been deprecated in favor of `log` ([#23505]).\n\n  * `full` has been deprecated in favor of more specific, better defined alternatives.\n    On structured matrices `A`, consider instead `Matrix(A)`, `Array(A)`,\n    `SparseMatrixCSC(A)`, or `sparse(A)`. On sparse arrays `S`, consider instead\n    `Vector(S)`, `Matrix(S)`, or `Array(S)` as appropriate. On factorizations `F`,\n    consider instead `Matrix(F)`, `Array(F)`, `AbstractMatrix(F)`, or `AbstractArray(F)`.\n    On implicit orthogonal factors `Q`, consider instead `Matrix(Q)` or `Array(Q)`; for\n    implicit orthogonal factors that can be recovered in square or truncated form,\n    see the deprecation message for square recovery instructions. On `Symmetric`,\n    `Hermitian`, or `AbstractTriangular` matrices `A`, consider instead `Matrix(S)`,\n    `Array(S)`, `SparseMatrixCSC(S)`, or `sparse(S)`. On `Symmetric` matrices `A`\n    particularly, consider instead `LinAlg.copytri!(copy(parent(A)), A.uplo)`. On\n    `Hermitian` matrices `A` particularly, consider instead\n    `LinAlg.copytri!(copy(parent(A)), A.uplo, true)`. On `UpperTriangular` matrices `A`\n    particularly, consider instead `triu!(copy(parent(A)))`. On `LowerTriangular` matrices\n    `A` particularly, consider instead `tril!(copy(parent(A)))` ([#24250]).\n\n  * `speye` has been deprecated in favor of `I`, `sparse`, and `SparseMatrixCSC`\n    constructor methods ([#24356]).\n\n  * Calling `union` with no arguments is deprecated; construct an empty set with an appropriate\n    element type using `Set{T}()` instead ([#23144]).\n\n  * Vectorized `DateTime`, `Date`, and `format` methods have been deprecated in favor of\n    dot-syntax ([#23207]).\n\n  * `Base.cpad` has been removed; use an appropriate combination of `rpad` and `lpad`\n    instead ([#23187]).\n\n  * `ctranspose` and `ctranspose!` have been deprecated in favor of `adjoint` and `adjoint!`,\n    respectively ([#23235]).\n\n  * `filter` and `filter!` on dictionaries now pass a single `key=>value` pair to the\n    argument function, instead of two arguments ([#17886]).\n\n  * `rol`, `rol!`, `ror`, and `ror!` have been deprecated in favor of specialized methods for\n    `circshift`/`circshift!` ([#23404]).\n\n  * `Base.SparseArrays.SpDiagIterator` has been removed ([#23261]).\n\n  * The function `cfunction`, has been deprecated in favor of a macro form `@cfunction`.\n    Most existing uses can be upgraded simply by adding a `@`.\n    The new syntax now additionally supports allocating closures at runtime,\n    for dealing with C APIs that don't provide a separate `void* env`-type callback\n    argument. ([#26486])\n\n  * `diagm(v::AbstractVector, k::Integer=0)` has been deprecated in favor of\n    `diagm(k => v)` ([#24047]).\n\n  * `diagm(x::Number)` has been deprecated in favor of `fill(x, 1, 1)` ([#24047]).\n\n  * `diagm(A::SparseMatrixCSC)` has been deprecated in favor of\n    `spdiagm(sparsevec(A))` ([#23341]).\n\n  * `diagm(A::BitMatrix)` has been deprecated, use `diagm(0 => vec(A))` or\n    `BitMatrix(Diagonal(vec(A)))` instead ([#23373], [#24047]).\n\n  * `\u212f` (written as `\\mscre<TAB>` or `\\euler<TAB>`) is now the only (by default) exported\n    name for Euler's number, and the type has changed from `Irrational{:e}` to\n    `Irrational{:\u212f}` ([#23427]).\n\n  * The mathematical constants `\u03c0`, `pi`, `\u212f`, `e`, `\u03b3`, `eulergamma`, `catalan`, `\u03c6` and\n    `golden` have been moved from `Base` to a new module; `Base.MathConstants`.\n    Only `\u03c0`, `pi` and `\u212f` are now exported by default from `Base` ([#23427]).\n\n  * `eu` (previously an alias for `\u212f`) has been deprecated in favor of `\u212f` (or `MathConstants.e`) ([#23427]).\n\n  * `GMP.gmp_version()`, `GMP.GMP_VERSION`, `GMP.gmp_bits_per_limb()`, and `GMP.GMP_BITS_PER_LIMB`\n    have been renamed to `GMP.version()`, `GMP.VERSION`, `GMP.bits_per_limb()`, and `GMP.BITS_PER_LIMB`,\n    respectively. Similarly, `MPFR.get_version()`, has been renamed to `MPFR.version()` ([#23323]). Also,\n    `LinAlg.LAPACK.laver()` has been renamed to `LinAlg.LAPACK.version()` and now returns a `VersionNumber`.\n\n  * `select`, `select!`, `selectperm` and `selectperm!` have been renamed respectively to\n    `partialsort`, `partialsort!`, `partialsortperm` and `partialsortperm!` ([#23051]).\n\n  * The `Range` abstract type has been renamed to `AbstractRange` ([#23570]).\n\n  * `map` on dictionaries previously operated on `key=>value` pairs. This behavior is deprecated,\n    and in the future `map` will operate only on values ([#5794]).\n\n  * `map` on sets previously returned a `Set`, possibly changing the order or number of elements. This\n    behavior is deprecated and in the future `map` will preserve order and number of elements ([#26980]).\n\n  * Previously, broadcast defaulted to treating its arguments as scalars if they were not\n    arrays. This behavior is deprecated, and in the future `broadcast` will default to\n    iterating over all its arguments. Wrap arguments you wish to be treated as scalars with\n    `Ref()` or a 1-tuple. Package developers can choose to allow a non-iterable type `T` to\n    always behave as a scalar by implementing `broadcastable(x::T) = Ref(x)` ([#26212]).\n\n  * Automatically broadcasted `+` and `-` for `array + scalar`, `scalar - array`, and so-on have\n    been deprecated due to inconsistency with linear algebra. Use `.+` and `.-` for these operations\n    instead ([#22880], [#22932]).\n\n  * `flipbits!(B)` is deprecated in favor of using in-place broadcast to negate each element:\n    `B .= .!B` ([#27067]).\n\n  * `isleaftype` is deprecated in favor of the simpler predicates `isconcretetype` and `isdispatchtuple`.\n    Concrete types are those that might equal `typeof(x)` for some `x`;\n    `isleaftype` included some types for which this is not true. Those are now categorized more precisely\n    as \"dispatch tuple types\" and \"!has_free_typevars\" (not exported). ([#17086], [#25496])\n\n  * `contains(eq, itr, item)` is deprecated in favor of `any` with a predicate ([#23716]).\n\n  * `spdiagm(x::AbstractVector)` has been deprecated in favor of `sparse(Diagonal(x))`\n    alternatively `spdiagm(0 => x)` ([#23757]).\n\n  * `spdiagm(x::AbstractVector, d::Integer)` and `spdiagm(x::Tuple{<:AbstractVector}, d::Tuple{<:Integer})`\n    have been deprecated in favor of `spdiagm(d => x)` and `spdiagm(d[1] => x[1], d[2] => x[2], ...)`\n    respectively. The new `spdiagm` implementation now always returns a square matrix ([#23757]).\n\n  * `spones(A::AbstractSparseArray)` has been deprecated in favor of\n    `LinAlg.fillstored!(copy(A), 1)` ([#25037]).\n\n  * Constructors for `LibGit2.UserPasswordCredentials` and `LibGit2.SSHCredentials` which take a\n    `prompt_if_incorrect` argument are deprecated. Instead, prompting behavior is controlled using\n    the `allow_prompt` keyword in the `LibGit2.CredentialPayload` constructor ([#23690]).\n\n  * `gradient` is deprecated and will be removed in the next release ([#23816]).\n\n  * The timing functions `tic`, `toc`, and `toq` are deprecated in favor of `@time` and `@elapsed`\n    ([#17046]).\n\n  * Methods of `findfirst`, `findnext`, `findlast`, and `findprev` that accept a value to\n    search for are deprecated in favor of passing a predicate ([#19186], [#10593]).\n\n  * `find` functions now operate only on booleans by default. To look for non-zeros, use\n    `x->x!=0` or `!iszero` ([#23120]).\n\n  * The ability of `reinterpret` to yield `Array`s of different type than the underlying storage\n    has been removed. The `reinterpret` function is still available, but now returns a\n    `ReinterpretArray`. The three argument form of `reinterpret` that implicitly reshapes\n    has been deprecated ([#23750]).\n\n  * `bits` has been deprecated in favor of `bitstring` ([#24281], [#24263]).\n\n  * `num2hex` and `hex2num` have been deprecated in favor of `reinterpret` combined with `parse`/`hex` ([#22088]).\n\n  * `copy!` is deprecated for `AbstractSet` and `AbstractDict`, with the intention to re-enable\n    it with a cleaner meaning in a future version ([#24844]).\n\n  * `copy!` (resp. `unsafe_copy!`) is deprecated for `AbstractArray` and is renamed `copyto!`\n    (resp. `unsafe_copyto!`); it will be re-introduced with a different meaning in a future\n    version ([#24808]).\n\n  * `a:b` is deprecated for constructing a `StepRange` when `a` and `b` have physical units\n    (Dates and Times). Use `a:s:b`, where `s = Dates.Day(1)` or `s = Dates.Second(1)`.\n\n  * `trues(A::AbstractArray)` and `falses(A::AbstractArray)` are deprecated in favor of\n    `trues(size(A))` and `falses(size(A))` respectively ([#24595]).\n\n  * `workspace` is discontinued, check out [Revise.jl](https://github.com/timholy/Revise.jl)\n    for an alternative workflow ([#25046]).\n\n  * `cumsum`, `cumprod`, `accumulate`, their mutating versions, and `diff` all now require a `dim`\n    argument instead of defaulting to using the first dimension unless there is only\n    one dimension ([#24684], [#25457]).\n\n  * The `sum_kbn` and `cumsum_kbn` functions have been moved to the\n    [KahanSummation](https://github.com/JuliaMath/KahanSummation.jl) package ([#24869]).\n\n  * `isnumber` has been renamed to `isnumeric` ([#25021]).\n\n  * `isalpha` has been renamed to `isletter` ([#26932]).\n\n  * `is_assigned_char` and `normalize_string` have been renamed to `isassigned` and\n    `normalize`, and moved to the new `Unicode` standard library module.\n    `graphemes` has also been moved to that module ([#25021]).\n\n  * Sparse array functionality has moved to the `SparseArrays` standard library module ([#25249]).\n\n  * Linear algebra functionality, and specifically the `LinAlg` module has moved to the\n    `LinearAlgebra` standard library module ([#25571]).\n\n  * `@printf` and `@sprintf` have been moved to the `Printf` standard library ([#23929],[#25056]).\n\n  * The `Libdl` module has moved to the `Libdl` standard library module ([#25459]).\n\n  * The aliases `Complex32`, `Complex64` and `Complex128` have been deprecated in favor of `ComplexF16`,\n    `ComplexF32` and `ComplexF64` respectively ([#24647]).\n\n  * `Base.parentindexes` and `SharedArrays.localindexes` have been renamed to `parentindices`\n    and `localindices`, respectively. Similarly, the `indexes` field in the `SubArray` type\n    has been renamed to `indices` without deprecation ([#25088]).\n\n  * `Associative` has been deprecated in favor of `AbstractDict` ([#25012]).\n\n  * `Void` has been renamed back to `Nothing` with an alias `Cvoid` for use when calling C\n    with a return type of `Cvoid` or a return or argument type of `Ptr{Cvoid}` ([#25162]).\n\n  * `Nullable{T}` has been deprecated and moved to the Nullables package ([#23642]). Use\n    `Union{T, Nothing}` instead, or `Union{Some{T}, Nothing}` if `nothing` is a possible\n    value (i.e. `Nothing <: T`). `isnull(x)` can be replaced with `x === nothing` and\n    `unsafe_get`/`get` can be dropped or replaced with `coalesce`.\n    `NullException` has been removed.\n\n  * `unshift!` and `shift!` have been renamed to `pushfirst!` and `popfirst!` ([#23902])\n\n  * `ipermute!` has been deprecated in favor of `invpermute!` ([#25168]).\n\n  * `CartesianRange` has been renamed `CartesianIndices` ([#24715]).\n\n  * `sub2ind` and `ind2sub` are deprecated in favor of using `CartesianIndices` and `LinearIndices` ([#24715]).\n\n  * `getindex(F::Factorization, s::Symbol)` (usually seen as e.g. `F[:Q]`) is deprecated\n    in favor of dot overloading (`getproperty`) so factors should now be accessed as e.g.\n    `F.Q` instead of `F[:Q]` ([#25184]).\n\n  * `search` and `rsearch` have been deprecated in favor of `findfirst`/`findnext` and\n    `findlast`/`findprev` respectively, in combination with curried `isequal` and `in`\n    predicates for some methods ([#24673]).\n\n  * `search(buf::IOBuffer, delim::UInt8)` has been deprecated in favor of either `occursin(delim, buf)`\n    (to test containment) or `readuntil(buf, delim)` (to read data up to `delim`) ([#26600]).\n\n  * `ismatch(regex, str)` has been deprecated in favor of `occursin(regex, str)` ([#26283]).\n\n  * `matchall` has been deprecated in favor of `collect(m.match for m in eachmatch(r, s))` ([#26071]).\n\n  * `similar(::Associative)` has been deprecated in favor of `empty(::Associative)`, and\n    `similar(::Associative, ::Pair{K, V})` has been deprecated in favour of\n    `empty(::Associative, K, V)` ([#24390]).\n\n  * `findin(a, b)` has been deprecated in favor of `findall(in(b), a)` ([#24673]).\n\n  * `module_name` has been deprecated in favor of a new, general `nameof` function. Similarly,\n    the unexported `Base.function_name` and `Base.datatype_name` have been deprecated in favor\n    of `nameof` methods ([#25622]).\n\n  * The module `Random.dSFMT` is renamed `Random.DSFMT` ([#25567]).\n\n  * `Random.RandomDevice(unlimited::Bool)` (on non-Windows systems) is deprecated in favor of\n    `Random.RandomDevice(; unlimited=unlimited)` ([#25668]).\n\n  * The generic implementations of `strides(::AbstractArray)` and `stride(::AbstractArray, ::Int)`\n     have been deprecated. Subtypes of `AbstractArray` that implement the newly introduced strided\n     array interface should define their own `strides` method ([#25321]).\n\n  * `module_parent`, `Base.datatype_module`, and `Base.function_module` have been deprecated\n    in favor of `parentmodule` ([#TODO]).\n\n  * `rand(t::Tuple{Vararg{Int}})` is deprecated in favor of `rand(Float64, t)` or `rand(t...)`;\n    `rand(::Tuple)` will have another meaning in the future ([#25429], [#25278]).\n\n  * `randjump`, which produced an array, is deprecated in favor of the\n    scalar version `Future.randjump` used with `accumulate` ([#27746]).\n\n  * The `assert` function (and `@assert` macro) have been documented that they are not guaranteed to run under various optimization levels and should therefore not be used to e.g. verify passwords.\n\n  * `ObjectIdDict` has been deprecated in favor of `IdDict{Any,Any}` ([#25210]).\n\n  * `gc` and `gc_enable` have been deprecated in favor of `GC.gc` and `GC.enable` ([#25616]).\n\n  * `Base.@gc_preserve` has been deprecated in favor of `GC.@preserve` ([#25616]).\n\n  * `print_shortest` has been discontinued, but is still available in the `Base.Grisu`\n    submodule ([#25745]).\n\n  * `scale!` has been deprecated in favor of `mul!`, `lmul!`, and `rmul!` ([#25701], [#25812]).\n\n  * The `remove_destination` keyword argument to `cp`, `mv`, and the unexported `cptree`\n    has been renamed to `force` ([#25979]).\n\n  * `contains` has been deprecated in favor of a more general `occursin` function, which\n    takes its arguments in reverse order from `contains` ([#26283]).\n\n  * `Regex` objects are no longer callable. Use `occursin` instead ([#26283]).\n\n  * The methods of `range` based on positional arguments have been deprecated in favor of\n    keyword arguments ([#25896]).\n\n  * `linspace` has been deprecated in favor of `range` with `stop` and `length` keyword\n    arguments ([#25896]).\n\n  * `LinSpace` has been renamed to `LinRange` ([#25896]).\n\n  * `logspace` has been deprecated to its definition ([#25896]).\n\n  * `endof(a)` has been renamed to `lastindex(a)`, and the `end` keyword in indexing expressions now\n    lowers to either `lastindex(a)` (in the case with only one index) or `lastindex(a, d)` (in cases\n    where there is more than one index and `end` appears at dimension `d`) ([#23554], [#25763]).\n\n  * `DateTime()`, `Date()`, and `Time()` have been deprecated, instead use `DateTime(1)`, `Date(1)`\n    and `Time(0)` respectively ([#23724]).\n\n  * The fallback method `^(x, p::Integer)` is deprecated. If your type relied on this definition,\n    add a method such as `^(x::MyType, p::Integer) = Base.power_by_squaring(x, p)` ([#23332]).\n\n  * `DevNull`, `STDIN`, `STDOUT`, and `STDERR` have been renamed to `devnull`, `stdin`, `stdout`,\n    and `stderr`, respectively ([#25786]).\n\n  * `wait` and `fetch` on `Task` now resemble the interface of `Future`.\n\n  * `showcompact(io, x...)` has been deprecated in favor of\n    `show(IOContext(io, :compact => true), x...)` ([#26080]).\n    Use `sprint(show, x..., context=:compact => true)` instead of `sprint(showcompact, x...)`.\n\n  * `isupper`, `islower`, `ucfirst` and `lcfirst` have been deprecated in favor of `isuppercase`,\n    `islowercase`, `uppercasefirst` and `lowercasefirst`, respectively ([#26442]).\n\n  * `signif` has been deprecated in favor of the `sigdigits` keyword argument to `round`.\n\n  * `Base.IntSet` has been deprecated in favor of `Base.BitSet` ([#24282]).\n\n  * `setrounding` has been deprecated for `Float32` and `Float64`, as the behaviour was too unreliable ([#26935]).\n\n  * `gamma`, `lgamma`, `beta`, `lbeta` and `lfact` have been moved to\n    [SpecialFunctions.jl](https://github.com/JuliaMath/SpecialFunctions.jl) ([#27459], [#27473]).\n\n  * `atan2` is now a 2-argument method of `atan` ([#27248]).\n\n  * The functions `eigs` and `svds` have been moved to the `Arpack.jl` package ([#27616]).\n\n  * `vecdot` and `vecnorm` are deprecated in favor of `dot` and `norm`, respectively ([#27401]).\n\n  * `clipboard` has been moved to the `InteractiveUtils` standard library package\n    (along with other utilities mostly used at the interactive prompt, such as `edit`\n    and `less`) ([#27635]).\n\n  * `ndigits(n, b, [pad])` is deprecated in favor of `ndigits(n, base=b, pad=pad)` ([#27908]).\n\n  * `squeeze` is deprecated in favor of `dropdims`.\n\n  * `srand` is deprecated in favor of the unexported `Random.seed!` ([#27726]).\n\n  * `realmin`/`realmax` are deprecated in favor of `floatmin`/`floatmax` ([#28302]).\n\n  * `sortrows`/`sortcols` have been deprecated in favor of the more general `sortslices`.\n\n  * `nextpow2`/`prevpow2` have been deprecated in favor of the more general `nextpow`/`prevpow` functions.\n\nCommand-line option changes\n---------------------------\n\n  * New option `--warn-overwrite={yes|no}` to control the warning for overwriting method\n    definitions. The default is `no` ([#23002]).\n\n  * New option `--banner={yes,no}` allows suppressing or forcing the printing of the\n    startup banner, overriding the default behavior (banner in REPL, no banner otherwise).\n    The `--quiet` option implies `--banner=no` even in REPL mode but can be overridden by\n    passing `--quiet` together with `--banner=yes` ([#23342]).\n\n  * The option `--precompiled` has been renamed to `--sysimage-native-code` ([#23054]).\n\n  * The option `--compilecache` has been renamed to `--compiled-modules` ([#23054]).\n\n<!--- generated by NEWS-update.jl: -->\n[#330]: https://github.com/JuliaLang/julia/issues/330\n[#1974]: https://github.com/JuliaLang/julia/issues/1974\n[#4916]: https://github.com/JuliaLang/julia/issues/4916\n[#5148]: https://github.com/JuliaLang/julia/issues/5148\n[#5794]: https://github.com/JuliaLang/julia/issues/5794\n[#6080]: https://github.com/JuliaLang/julia/issues/6080\n[#6466]: https://github.com/JuliaLang/julia/issues/6466\n[#6614]: https://github.com/JuliaLang/julia/issues/6614\n[#8000]: https://github.com/JuliaLang/julia/issues/8000\n[#8470]: https://github.com/JuliaLang/julia/issues/8470\n[#9053]: https://github.com/JuliaLang/julia/issues/9053\n[#9292]: https://github.com/JuliaLang/julia/issues/9292\n[#10593]: https://github.com/JuliaLang/julia/issues/10593\n[#11310]: https://github.com/JuliaLang/julia/issues/11310\n[#12010]: https://github.com/JuliaLang/julia/issues/12010\n[#12131]: https://github.com/JuliaLang/julia/issues/12131\n[#13079]: https://github.com/JuliaLang/julia/issues/13079\n[#14770]: https://github.com/JuliaLang/julia/issues/14770\n[#15120]: https://github.com/JuliaLang/julia/issues/15120\n[#16356]: https://github.com/JuliaLang/julia/issues/16356\n[#16401]: https://github.com/JuliaLang/julia/issues/16401\n[#16937]: https://github.com/JuliaLang/julia/issues/16937\n[#17046]: https://github.com/JuliaLang/julia/issues/17046\n[#17086]: https://github.com/JuliaLang/julia/issues/17086\n[#17240]: https://github.com/JuliaLang/julia/issues/17240\n[#17360]: https://github.com/JuliaLang/julia/issues/17360\n[#17367]: https://github.com/JuliaLang/julia/issues/17367\n[#17886]: https://github.com/JuliaLang/julia/issues/17886\n[#17997]: https://github.com/JuliaLang/julia/issues/17997\n[#18155]: https://github.com/JuliaLang/julia/issues/18155\n[#18650]: https://github.com/JuliaLang/julia/issues/18650\n[#19089]: https://github.com/JuliaLang/julia/issues/19089\n[#19157]: https://github.com/JuliaLang/julia/issues/19157\n[#19186]: https://github.com/JuliaLang/julia/issues/19186\n[#19987]: https://github.com/JuliaLang/julia/issues/19987\n[#20005]: https://github.com/JuliaLang/julia/issues/20005\n[#20418]: https://github.com/JuliaLang/julia/issues/20418\n[#20549]: https://github.com/JuliaLang/julia/issues/20549\n[#20575]: https://github.com/JuliaLang/julia/issues/20575\n[#20816]: https://github.com/JuliaLang/julia/issues/20816\n[#20899]: https://github.com/JuliaLang/julia/issues/20899\n[#20912]: https://github.com/JuliaLang/julia/issues/20912\n[#20974]: https://github.com/JuliaLang/julia/issues/20974\n[#21359]: https://github.com/JuliaLang/julia/issues/21359\n[#21438]: https://github.com/JuliaLang/julia/issues/21438\n[#21450]: https://github.com/JuliaLang/julia/issues/21450\n[#21527]: https://github.com/JuliaLang/julia/issues/21527\n[#21540]: https://github.com/JuliaLang/julia/issues/21540\n[#21592]: https://github.com/JuliaLang/julia/issues/21592\n[#21662]: https://github.com/JuliaLang/julia/issues/21662\n[#21692]: https://github.com/JuliaLang/julia/issues/21692\n[#21697]: https://github.com/JuliaLang/julia/issues/21697\n[#21709]: https://github.com/JuliaLang/julia/issues/21709\n[#21746]: https://github.com/JuliaLang/julia/issues/21746\n[#21759]: https://github.com/JuliaLang/julia/issues/21759\n[#21774]: https://github.com/JuliaLang/julia/issues/21774\n[#21825]: https://github.com/JuliaLang/julia/issues/21825\n[#21909]: https://github.com/JuliaLang/julia/issues/21909\n[#21956]: https://github.com/JuliaLang/julia/issues/21956\n[#21960]: https://github.com/JuliaLang/julia/issues/21960\n[#21973]: https://github.com/JuliaLang/julia/issues/21973\n[#21974]: https://github.com/JuliaLang/julia/issues/21974\n[#22007]: https://github.com/JuliaLang/julia/issues/22007\n[#22038]: https://github.com/JuliaLang/julia/issues/22038\n[#22062]: https://github.com/JuliaLang/julia/issues/22062\n[#22064]: https://github.com/JuliaLang/julia/issues/22064\n[#22088]: https://github.com/JuliaLang/julia/issues/22088\n[#22089]: https://github.com/JuliaLang/julia/issues/22089\n[#22092]: https://github.com/JuliaLang/julia/issues/22092\n[#22182]: https://github.com/JuliaLang/julia/issues/22182\n[#22187]: https://github.com/JuliaLang/julia/issues/22187\n[#22188]: https://github.com/JuliaLang/julia/issues/22188\n[#22194]: https://github.com/JuliaLang/julia/issues/22194\n[#22210]: https://github.com/JuliaLang/julia/issues/22210\n[#22222]: https://github.com/JuliaLang/julia/issues/22222\n[#22224]: https://github.com/JuliaLang/julia/issues/22224\n[#22226]: https://github.com/JuliaLang/julia/issues/22226\n[#22228]: https://github.com/JuliaLang/julia/issues/22228\n[#22245]: https://github.com/JuliaLang/julia/issues/22245\n[#22251]: https://github.com/JuliaLang/julia/issues/22251\n[#22274]: https://github.com/JuliaLang/julia/issues/22274\n[#22281]: https://github.com/JuliaLang/julia/issues/22281\n[#22296]: https://github.com/JuliaLang/julia/issues/22296\n[#22314]: https://github.com/JuliaLang/julia/issues/22314\n[#22324]: https://github.com/JuliaLang/julia/issues/22324\n[#22325]: https://github.com/JuliaLang/julia/issues/22325\n[#22350]: https://github.com/JuliaLang/julia/issues/22350\n[#22390]: https://github.com/JuliaLang/julia/issues/22390\n[#22496]: https://github.com/JuliaLang/julia/issues/22496\n[#22511]: https://github.com/JuliaLang/julia/issues/22511\n[#22523]: https://github.com/JuliaLang/julia/issues/22523\n[#22532]: https://github.com/JuliaLang/julia/issues/22532\n[#22572]: https://github.com/JuliaLang/julia/issues/22572\n[#22588]: https://github.com/JuliaLang/julia/issues/22588\n[#22605]: https://github.com/JuliaLang/julia/issues/22605\n[#22666]: https://github.com/JuliaLang/julia/issues/22666\n[#22696]: https://github.com/JuliaLang/julia/issues/22696\n[#22703]: https://github.com/JuliaLang/julia/issues/22703\n[#22712]: https://github.com/JuliaLang/julia/issues/22712\n[#22718]: https://github.com/JuliaLang/julia/issues/22718\n[#22720]: https://github.com/JuliaLang/julia/issues/22720\n[#22723]: https://github.com/JuliaLang/julia/issues/22723\n[#22732]: https://github.com/JuliaLang/julia/issues/22732\n[#22742]: https://github.com/JuliaLang/julia/issues/22742\n[#22751]: https://github.com/JuliaLang/julia/issues/22751\n[#22761]: https://github.com/JuliaLang/julia/issues/22761\n[#22762]: https://github.com/JuliaLang/julia/issues/22762\n[#22789]: https://github.com/JuliaLang/julia/issues/22789\n[#22793]: https://github.com/JuliaLang/julia/issues/22793\n[#22796]: https://github.com/JuliaLang/julia/issues/22796\n[#22800]: https://github.com/JuliaLang/julia/issues/22800\n[#22801]: https://github.com/JuliaLang/julia/issues/22801\n[#22814]: https://github.com/JuliaLang/julia/issues/22814\n[#22825]: https://github.com/JuliaLang/julia/issues/22825\n[#22829]: https://github.com/JuliaLang/julia/issues/22829\n[#22847]: https://github.com/JuliaLang/julia/issues/22847\n[#22868]: https://github.com/JuliaLang/julia/issues/22868\n[#22880]: https://github.com/JuliaLang/julia/issues/22880\n[#22907]: https://github.com/JuliaLang/julia/issues/22907\n[#22925]: https://github.com/JuliaLang/julia/issues/22925\n[#22926]: https://github.com/JuliaLang/julia/issues/22926\n[#22932]: https://github.com/JuliaLang/julia/issues/22932\n[#22961]: https://github.com/JuliaLang/julia/issues/22961\n[#22984]: https://github.com/JuliaLang/julia/issues/22984\n[#23002]: https://github.com/JuliaLang/julia/issues/23002\n[#23035]: https://github.com/JuliaLang/julia/issues/23035\n[#23051]: https://github.com/JuliaLang/julia/issues/23051\n[#23054]: https://github.com/JuliaLang/julia/issues/23054\n[#23117]: https://github.com/JuliaLang/julia/issues/23117\n[#23120]: https://github.com/JuliaLang/julia/issues/23120\n[#23144]: https://github.com/JuliaLang/julia/issues/23144\n[#23154]: https://github.com/JuliaLang/julia/issues/23154\n[#23157]: https://github.com/JuliaLang/julia/issues/23157\n[#23168]: https://github.com/JuliaLang/julia/issues/23168\n[#23187]: https://github.com/JuliaLang/julia/issues/23187\n[#23207]: https://github.com/JuliaLang/julia/issues/23207\n[#23233]: https://github.com/JuliaLang/julia/issues/23233\n[#23235]: https://github.com/JuliaLang/julia/issues/23235\n[#23261]: https://github.com/JuliaLang/julia/issues/23261\n[#23323]: https://github.com/JuliaLang/julia/issues/23323\n[#23332]: https://github.com/JuliaLang/julia/issues/23332\n[#23341]: https://github.com/JuliaLang/julia/issues/23341\n[#23342]: https://github.com/JuliaLang/julia/issues/23342\n[#23354]: https://github.com/JuliaLang/julia/issues/23354\n[#23366]: https://github.com/JuliaLang/julia/issues/23366\n[#23373]: https://github.com/JuliaLang/julia/issues/23373\n[#23393]: https://github.com/JuliaLang/julia/issues/23393\n[#23404]: https://github.com/JuliaLang/julia/issues/23404\n[#23427]: https://github.com/JuliaLang/julia/issues/23427\n[#23504]: https://github.com/JuliaLang/julia/issues/23504\n[#23505]: https://github.com/JuliaLang/julia/issues/23505\n[#23519]: https://github.com/JuliaLang/julia/issues/23519\n[#23528]: https://github.com/JuliaLang/julia/issues/23528\n[#23529]: https://github.com/JuliaLang/julia/issues/23529\n[#23530]: https://github.com/JuliaLang/julia/issues/23530\n[#23554]: https://github.com/JuliaLang/julia/issues/23554\n[#23570]: https://github.com/JuliaLang/julia/issues/23570\n[#23628]: https://github.com/JuliaLang/julia/issues/23628\n[#23642]: https://github.com/JuliaLang/julia/issues/23642\n[#23665]: https://github.com/JuliaLang/julia/issues/23665\n[#23690]: https://github.com/JuliaLang/julia/issues/23690\n[#23716]: https://github.com/JuliaLang/julia/issues/23716\n[#23724]: https://github.com/JuliaLang/julia/issues/23724\n[#23750]: https://github.com/JuliaLang/julia/issues/23750\n[#23757]: https://github.com/JuliaLang/julia/issues/23757\n[#23805]: https://github.com/JuliaLang/julia/issues/23805\n[#23816]: https://github.com/JuliaLang/julia/issues/23816\n[#23885]: https://github.com/JuliaLang/julia/issues/23885\n[#23902]: https://github.com/JuliaLang/julia/issues/23902\n[#23912]: https://github.com/JuliaLang/julia/issues/23912\n[#23923]: https://github.com/JuliaLang/julia/issues/23923\n[#23929]: https://github.com/JuliaLang/julia/issues/23929\n[#23960]: https://github.com/JuliaLang/julia/issues/23960\n[#23964]: https://github.com/JuliaLang/julia/issues/23964\n[#24047]: https://github.com/JuliaLang/julia/issues/24047\n[#24126]: https://github.com/JuliaLang/julia/issues/24126\n[#24153]: https://github.com/JuliaLang/julia/issues/24153\n[#24167]: https://github.com/JuliaLang/julia/issues/24167\n[#24187]: https://github.com/JuliaLang/julia/issues/24187\n[#24221]: https://github.com/JuliaLang/julia/issues/24221\n[#24240]: https://github.com/JuliaLang/julia/issues/24240\n[#24245]: https://github.com/JuliaLang/julia/issues/24245\n[#24250]: https://github.com/JuliaLang/julia/issues/24250\n[#24263]: https://github.com/JuliaLang/julia/issues/24263\n[#24278]: https://github.com/JuliaLang/julia/issues/24278\n[#24279]: https://github.com/JuliaLang/julia/issues/24279\n[#24281]: https://github.com/JuliaLang/julia/issues/24281\n[#24282]: https://github.com/JuliaLang/julia/issues/24282\n[#24320]: https://github.com/JuliaLang/julia/issues/24320\n[#24356]: https://github.com/JuliaLang/julia/issues/24356\n[#24362]: https://github.com/JuliaLang/julia/issues/24362\n[#24390]: https://github.com/JuliaLang/julia/issues/24390\n[#24396]: https://github.com/JuliaLang/julia/issues/24396\n[#24404]: https://github.com/JuliaLang/julia/issues/24404\n[#24413]: https://github.com/JuliaLang/julia/issues/24413\n[#24414]: https://github.com/JuliaLang/julia/issues/24414\n[#24415]: https://github.com/JuliaLang/julia/issues/24415\n[#24438]: https://github.com/JuliaLang/julia/issues/24438\n[#24445]: https://github.com/JuliaLang/julia/issues/24445\n[#24452]: https://github.com/JuliaLang/julia/issues/24452\n[#24472]: https://github.com/JuliaLang/julia/issues/24472\n[#24490]: https://github.com/JuliaLang/julia/issues/24490\n[#24580]: https://github.com/JuliaLang/julia/issues/24580\n[#24595]: https://github.com/JuliaLang/julia/issues/24595\n[#24605]: https://github.com/JuliaLang/julia/issues/24605\n[#24647]: https://github.com/JuliaLang/julia/issues/24647\n[#24653]: https://github.com/JuliaLang/julia/issues/24653\n[#24654]: https://github.com/JuliaLang/julia/issues/24654\n[#24656]: https://github.com/JuliaLang/julia/issues/24656\n[#24673]: https://github.com/JuliaLang/julia/issues/24673\n[#24679]: https://github.com/JuliaLang/julia/issues/24679\n[#24684]: https://github.com/JuliaLang/julia/issues/24684\n[#24713]: https://github.com/JuliaLang/julia/issues/24713\n[#24715]: https://github.com/JuliaLang/julia/issues/24715\n[#24774]: https://github.com/JuliaLang/julia/issues/24774\n[#24781]: https://github.com/JuliaLang/julia/issues/24781\n[#24785]: https://github.com/JuliaLang/julia/issues/24785\n[#24786]: https://github.com/JuliaLang/julia/issues/24786\n[#24808]: https://github.com/JuliaLang/julia/issues/24808\n[#24831]: https://github.com/JuliaLang/julia/issues/24831\n[#24839]: https://github.com/JuliaLang/julia/issues/24839\n[#24844]: https://github.com/JuliaLang/julia/issues/24844\n[#24869]: https://github.com/JuliaLang/julia/issues/24869\n[#25002]: https://github.com/JuliaLang/julia/issues/25002\n[#25012]: https://github.com/JuliaLang/julia/issues/25012\n[#25021]: https://github.com/JuliaLang/julia/issues/25021\n[#25029]: https://github.com/JuliaLang/julia/issues/25029\n[#25030]: https://github.com/JuliaLang/julia/issues/25030\n[#25037]: https://github.com/JuliaLang/julia/issues/25037\n[#25046]: https://github.com/JuliaLang/julia/issues/25046\n[#25047]: https://github.com/JuliaLang/julia/issues/25047\n[#25056]: https://github.com/JuliaLang/julia/issues/25056\n[#25057]: https://github.com/JuliaLang/julia/issues/25057\n[#25058]: https://github.com/JuliaLang/julia/issues/25058\n[#25067]: https://github.com/JuliaLang/julia/issues/25067\n[#25088]: https://github.com/JuliaLang/julia/issues/25088\n[#25162]: https://github.com/JuliaLang/julia/issues/25162\n[#25165]: https://github.com/JuliaLang/julia/issues/25165\n[#25168]: https://github.com/JuliaLang/julia/issues/25168\n[#25184]: https://github.com/JuliaLang/julia/issues/25184\n[#25197]: https://github.com/JuliaLang/julia/issues/25197\n[#25210]: https://github.com/JuliaLang/julia/issues/25210\n[#25231]: https://github.com/JuliaLang/julia/issues/25231\n[#25249]: https://github.com/JuliaLang/julia/issues/25249\n[#25277]: https://github.com/JuliaLang/julia/issues/25277\n[#25278]: https://github.com/JuliaLang/julia/issues/25278\n[#25311]: https://github.com/JuliaLang/julia/issues/25311\n[#25321]: https://github.com/JuliaLang/julia/issues/25321\n[#25368]: https://github.com/JuliaLang/julia/issues/25368\n[#25391]: https://github.com/JuliaLang/julia/issues/25391\n[#25424]: https://github.com/JuliaLang/julia/issues/25424\n[#25429]: https://github.com/JuliaLang/julia/issues/25429\n[#25457]: https://github.com/JuliaLang/julia/issues/25457\n[#25459]: https://github.com/JuliaLang/julia/issues/25459\n[#25472]: https://github.com/JuliaLang/julia/issues/25472\n[#25496]: https://github.com/JuliaLang/julia/issues/25496\n[#25501]: https://github.com/JuliaLang/julia/issues/25501\n[#25522]: https://github.com/JuliaLang/julia/issues/25522\n[#25532]: https://github.com/JuliaLang/julia/issues/25532\n[#25545]: https://github.com/JuliaLang/julia/issues/25545\n[#25564]: https://github.com/JuliaLang/julia/issues/25564\n[#25567]: https://github.com/JuliaLang/julia/issues/25567\n[#25571]: https://github.com/JuliaLang/julia/issues/25571\n[#25616]: https://github.com/JuliaLang/julia/issues/25616\n[#25622]: https://github.com/JuliaLang/julia/issues/25622\n[#25631]: https://github.com/JuliaLang/julia/issues/25631\n[#25633]: https://github.com/JuliaLang/julia/issues/25633\n[#25634]: https://github.com/JuliaLang/julia/issues/25634\n[#25654]: https://github.com/JuliaLang/julia/issues/25654\n[#25655]: https://github.com/JuliaLang/julia/issues/25655\n[#25662]: https://github.com/JuliaLang/julia/issues/25662\n[#25667]: https://github.com/JuliaLang/julia/issues/25667\n[#25668]: https://github.com/JuliaLang/julia/issues/25668\n[#25697]: https://github.com/JuliaLang/julia/issues/25697\n[#25701]: https://github.com/JuliaLang/julia/issues/25701\n[#25725]: https://github.com/JuliaLang/julia/issues/25725\n[#25745]: https://github.com/JuliaLang/julia/issues/25745\n[#25763]: https://github.com/JuliaLang/julia/issues/25763\n[#25786]: https://github.com/JuliaLang/julia/issues/25786\n[#25812]: https://github.com/JuliaLang/julia/issues/25812\n[#25815]: https://github.com/JuliaLang/julia/issues/25815\n[#25830]: https://github.com/JuliaLang/julia/issues/25830\n[#25845]: https://github.com/JuliaLang/julia/issues/25845\n[#25854]: https://github.com/JuliaLang/julia/issues/25854\n[#25858]: https://github.com/JuliaLang/julia/issues/25858\n[#25872]: https://github.com/JuliaLang/julia/issues/25872\n[#25896]: https://github.com/JuliaLang/julia/issues/25896\n[#25944]: https://github.com/JuliaLang/julia/issues/25944\n[#25947]: https://github.com/JuliaLang/julia/issues/25947\n[#25979]: https://github.com/JuliaLang/julia/issues/25979\n[#25980]: https://github.com/JuliaLang/julia/issues/25980\n[#25990]: https://github.com/JuliaLang/julia/issues/25990\n[#25998]: https://github.com/JuliaLang/julia/issues/25998\n[#26009]: https://github.com/JuliaLang/julia/issues/26009\n[#26071]: https://github.com/JuliaLang/julia/issues/26071\n[#26080]: https://github.com/JuliaLang/julia/issues/26080\n[#26093]: https://github.com/JuliaLang/julia/issues/26093\n[#26149]: https://github.com/JuliaLang/julia/issues/26149\n[#26154]: https://github.com/JuliaLang/julia/issues/26154\n[#26156]: https://github.com/JuliaLang/julia/issues/26156\n[#26161]: https://github.com/JuliaLang/julia/issues/26161\n[#26206]: https://github.com/JuliaLang/julia/issues/26206\n[#26212]: https://github.com/JuliaLang/julia/issues/26212\n[#26262]: https://github.com/JuliaLang/julia/issues/26262\n[#26283]: https://github.com/JuliaLang/julia/issues/26283\n[#26284]: https://github.com/JuliaLang/julia/issues/26284\n[#26286]: https://github.com/JuliaLang/julia/issues/26286\n[#26347]: https://github.com/JuliaLang/julia/issues/26347\n[#26436]: https://github.com/JuliaLang/julia/issues/26436\n[#26442]: https://github.com/JuliaLang/julia/issues/26442\n[#26486]: https://github.com/JuliaLang/julia/issues/26486\n[#26559]: https://github.com/JuliaLang/julia/issues/26559\n[#26576]: https://github.com/JuliaLang/julia/issues/26576\n[#26600]: https://github.com/JuliaLang/julia/issues/26600\n[#26660]: https://github.com/JuliaLang/julia/issues/26660\n[#26670]: https://github.com/JuliaLang/julia/issues/26670\n[#26733]: https://github.com/JuliaLang/julia/issues/26733\n[#26775]: https://github.com/JuliaLang/julia/issues/26775\n[#26858]: https://github.com/JuliaLang/julia/issues/26858\n[#26862]: https://github.com/JuliaLang/julia/issues/26862\n[#26932]: https://github.com/JuliaLang/julia/issues/26932\n[#26935]: https://github.com/JuliaLang/julia/issues/26935\n[#26980]: https://github.com/JuliaLang/julia/issues/26980\n[#26997]: https://github.com/JuliaLang/julia/issues/26997\n[#27067]: https://github.com/JuliaLang/julia/issues/27067\n[#27071]: https://github.com/JuliaLang/julia/issues/27071\n[#27075]: https://github.com/JuliaLang/julia/issues/27075\n[#27100]: https://github.com/JuliaLang/julia/issues/27100\n[#27121]: https://github.com/JuliaLang/julia/issues/27121\n[#27159]: https://github.com/JuliaLang/julia/issues/27159\n[#27164]: https://github.com/JuliaLang/julia/issues/27164\n[#27189]: https://github.com/JuliaLang/julia/issues/27189\n[#27212]: https://github.com/JuliaLang/julia/issues/27212\n[#27248]: https://github.com/JuliaLang/julia/issues/27248\n[#27309]: https://github.com/JuliaLang/julia/issues/27309\n[#27401]: https://github.com/JuliaLang/julia/issues/27401\n[#27447]: https://github.com/JuliaLang/julia/issues/27447\n[#27459]: https://github.com/JuliaLang/julia/issues/27459\n[#27470]: https://github.com/JuliaLang/julia/issues/27470\n[#27473]: https://github.com/JuliaLang/julia/issues/27473\n[#27554]: https://github.com/JuliaLang/julia/issues/27554\n[#27560]: https://github.com/JuliaLang/julia/issues/27560\n[#27616]: https://github.com/JuliaLang/julia/issues/27616\n[#27635]: https://github.com/JuliaLang/julia/issues/27635\n[#27641]: https://github.com/JuliaLang/julia/issues/27641\n[#27711]: https://github.com/JuliaLang/julia/issues/27711\n[#27726]: https://github.com/JuliaLang/julia/issues/27726\n[#27746]: https://github.com/JuliaLang/julia/issues/27746\n[#27856]: https://github.com/JuliaLang/julia/issues/27856\n[#27859]: https://github.com/JuliaLang/julia/issues/27859\n[#27908]: https://github.com/JuliaLang/julia/issues/27908\n[#27944]: https://github.com/JuliaLang/julia/issues/27944\n[#28045]: https://github.com/JuliaLang/julia/issues/28045\n[#28065]: https://github.com/JuliaLang/julia/issues/28065\n[#28155]: https://github.com/JuliaLang/julia/issues/28155\n[#28266]: https://github.com/JuliaLang/julia/issues/28266\n[#28302]: https://github.com/JuliaLang/julia/issues/28302\n\nJulia v0.6.0 Release Notes\n==========================\n\nNew language features\n---------------------\n\n  * New type system capabilities ([#8974], [#18457])\n\n    + Type parameter constraints can refer to previous parameters, e.g.\n      `type Foo{R<:Real, A<:AbstractArray{R}}`. Can also be used in method definitions.\n\n    + New syntax `Array{T} where T<:Integer`, indicating a union of types over all\n      specified values of `T` (represented by a `UnionAll` type). This provides behavior\n      similar to parametric methods or `typealias`, but can be used anywhere a type is\n      accepted. This syntax can also be used in method definitions, e.g.\n      `function inv(M::Matrix{T}) where T<:AbstractFloat`.\n      Anonymous functions can have type parameters via the syntax\n      `((x::Array{T}) where T<:Real) -> 2x`.\n\n    + Implicit type parameters, e.g. `Vector{<:Real}` is equivalent to\n      `Vector{T} where T<:Real`, and similarly for `Vector{>:Int}` ([#20414]).\n\n    + Much more accurate subtype and type intersection algorithms. Method sorting and\n      identification of equivalent and ambiguous methods are improved as a result.\n\nLanguage changes\n----------------\n\n  * \"Inner constructor\" syntax for parametric types is deprecated. For example,\n    in this definition:\n    ```\n    type Foo{T,S<:Real}\n        x\n        Foo(x) = new(x)\n    end\n    ```\n    the syntax `Foo(x) = new(x)` actually defined a constructor for `Foo{T,S}`,\n    i.e. the case where the type parameters are specified. For clarity, this\n    definition now must be written as `Foo{T,S}(x) where {T,S<:Real} = new(x)`\n    ([#11310], [#20308]).\n\n  * The keywords used to define types have changed ([#19157], [#20418]).\n\n    + `immutable` changes to `struct`\n\n    + `type` changes to `mutable struct`\n\n    + `abstract` changes to `abstract type ... end`\n\n    + `bitstype 32 Char` changes to `primitive type Char 32 end`\n\n    In 0.6, `immutable` and `type` are still allowed as synonyms without a deprecation\n    warning.\n\n  * Multi-line and single-line nonstandard command literals have been added. A\n    nonstandard command literal is like a nonstandard string literal, but the\n    syntax uses backquotes (``` ` ```) instead of double quotes, and the\n    resulting macro called is suffixed with `_cmd`. For instance, the syntax\n    ``` q`xyz` ``` is equivalent to `@q_cmd \"xyz\"` ([#18644]).\n\n  * Nonstandard string and command literals can now be qualified with their\n    module. For instance, `Base.r\"x\"` is now parsed as `Base.@r_str \"x\"`.\n    Previously, this syntax parsed as an implicit multiplication ([#18690]).\n\n  * For every binary operator `\u2a33`, `a .\u2a33 b` is now automatically equivalent to\n    the `broadcast` call `(\u2a33).(a, b)`.  Hence, one no longer defines methods\n    for `.*` etcetera.  This also means that \"dot operations\" automatically\n    fuse into a single loop, along with other dot calls `f.(x)` ([#17623]).\n    Similarly for unary operators ([#20249]).\n\n  * Newly defined methods are no longer callable from the same dynamic runtime\n    scope they were defined in ([#17057]).\n\n  * `isa` is now parsed as an infix operator with the same precedence as `in`\n    ([#19677]).\n\n  * `@.` is now parsed as `@__dot__`, and can be used to add dots to\n    every function call, operator, and assignment in an expression ([#20321]).\n\n  * The identifier `_` can be assigned, but accessing its value is deprecated,\n    allowing this syntax to be used in the future for discarding values ([#9343],\n    [#18251], [#20328]).\n\n  * The `typealias` keyword is deprecated, and should be replaced with\n    `Vector{T} = Array{T,1}` or a `const` assignment ([#20500]).\n\n  * Experimental feature: `x^n` for integer literals `n` (e.g. `x^3`\n    or `x^-3`) is now lowered to `Base.literal_pow(^, x, Val{n})`, to enable\n    compile-time specialization for literal integer exponents ([#20530], [#20889]).\n\nBreaking changes\n----------------\n\nThis section lists changes that do not have deprecation warnings.\n\n  * `readline`, `readlines` and `eachline` return lines without line endings by default.\n    You *must* use `readline(s, chomp=false)`, etc. to get the old behavior where\n    returned lines include trailing end-of-line character(s) ([#19944]).\n\n  * `String`s no longer have a `.data` field (as part of a significant performance\n    improvement). Use `Vector{UInt8}(str)` to access a string as a byte array.\n    However, allocating the `Vector` object has overhead. You can also use\n    `codeunit(str, i)` to access the `i`th byte of a `String`.\n    Use `sizeof(str)` instead of `length(str.data)`, and `pointer(str)` instead of\n    `pointer(str.data)` ([#19449]).\n\n  * Operations between `Float16` and `Integers` now return `Float16` instead of `Float32` ([#17261]).\n\n  * Keyword arguments are processed left-to-right: if the same keyword is specified more than\n    once, the rightmost occurrence takes precedence ([#17785]).\n\n  * The `lgamma(z)` function now uses a different (more standard) branch cut\n    for `real(z) < 0`, which differs from `log(gamma(z))` by multiples of 2\u03c0\n    in the imaginary part ([#18330]).\n\n  * `broadcast` now handles tuples, and treats any argument that is not a tuple\n    or an array as a \"scalar\" ([#16986]).\n\n  * `broadcast` now produces a `BitArray` instead of `Array{Bool}` for\n    functions yielding a boolean result.  If you want `Array{Bool}`, use\n    `broadcast!` or `.=` ([#17623]).\n\n  * Broadcast `A[I...] .= X` with entirely scalar indices `I` is deprecated as\n    its behavior will change in the future.  Use `A[I...] = X` instead.\n\n  * Operations like `.+` and `.*` on `Range` objects are now generic\n    `broadcast` calls (see [above](#language-changes)) and produce an `Array`.\n    If you want a `Range` result, use `+` and `*`, etcetera ([#17623]).\n\n  * `broadcast` now treats `Ref` (except for `Ptr`) arguments as 0-dimensional\n    arrays ([#18965]).\n\n  * `broadcast` now handles missing data (`Nullable`s) allowing operations to\n    be lifted over mixtures of `Nullable`s and scalars, as if the `Nullable`\n    were like an array with zero or one element ([#16961], [#19787]).\n\n  * The runtime now enforces when new method definitions can take effect ([#17057]).\n    The flip-side of this is that new method definitions should now reliably actually\n    take effect, and be called when evaluating new code ([#265]).\n\n  * The array-scalar methods of `/`, `\\`, `*`, `+`, and `-` now follow broadcast promotion\n    rules. (Likewise for the now-deprecated array-scalar methods of `div`, `mod`, `rem`,\n    `&`, `|`, and `xor`; see \"Deprecated or removed\" below.) ([#19692]).\n\n  * `broadcast!(f, A)` now calls `f()` for each element of `A`, rather than doing `fill!(A, f())` ([#19722]).\n\n  * `rmprocs` now throws an exception if requested workers have not been completely\n    removed before `waitfor` seconds. With a `waitfor=0`, `rmprocs` returns immediately\n    without waiting for worker exits.\n\n  * `quadgk` has been moved from Base into a separate package ([#19741]).\n\n  * The `Collections` module has been removed, and all functions defined therein have been\n    moved to the `DataStructures` package ([#19800]).\n\n  * The `RepString` type has been moved to the\n    [LegacyStrings.jl package](https://github.com/JuliaArchive/LegacyStrings.jl).\n\n  * In macro calls with parentheses, e.g. `@m(a=1)`, assignments are now parsed as\n    `=` expressions, instead of as `kw` expressions ([#7669]).\n\n  * When used as an infix operator, `~` is now parsed as a call to an ordinary operator\n    with assignment precedence, instead of as a macro call ([#20406]).\n\n  * (\u00b5 \"micro\" and \u025b \"latin epsilon\") are considered equivalent to\n    the corresponding Greek characters in identifiers.  `\\varepsilon`\n    now tab-completes to U+03B5 (greek small letter epsilon) ([#19464]).\n\n  * `retry` now inputs the keyword arguments `delays` and `check` instead of\n    `n` and `max_delay`.  The previous functionality can be achieved setting\n    `delays` to `ExponentialBackOff` ([#19331]).\n\n  * `transpose(::AbstractVector)` now always returns a `RowVector` view of the input (which is a\n     special 1\u00d7n-sized `AbstractMatrix`), not a `Matrix`, etc. In particular, for\n     `v::AbstractVector` we now have `(v.').' === v` and `v.' * v` is a scalar ([#19670]).\n\n  * Parametric types with \"unspecified\" parameters, such as `Array`, are now represented\n    as `UnionAll` types instead of `DataType`s ([#18457]).\n\n  * `Union` types have two fields, `a` and `b`, instead of a single `types` field.\n    The empty type `Union{}` is represented by a singleton of type `TypeofBottom` ([#18457]).\n\n  * The type `NTuple{N}` now refers to tuples where every element has the same type\n    (since it is shorthand for `NTuple{N,T} where T`). To get the old behavior of matching\n    any tuple, use `NTuple{N,Any}` ([#18457]).\n\n  * `FloatRange` has been replaced by `StepRangeLen`, and the internal\n    representation of `LinSpace` has changed. Aside from changes in\n    the internal field names, this leads to several differences in\n    behavior ([#18777]):\n\n    + Both `StepRangeLen` and `LinSpace` can represent ranges of\n      arbitrary object types---they are no longer limited to\n      floating-point numbers.\n\n    + For ranges that produce `Float64`, `Float32`, or `Float16`\n      numbers, `StepRangeLen` can be used to produce values with\n      little or no roundoff error due to internal arithmetic that is\n      typically twice the precision of the output result.\n\n    + To take advantage of this precision, `linspace(start, stop,\n      len)` now returns a range of type `StepRangeLen` rather than\n      `LinSpace` when `start` and `stop` are\n      `FloatNN`. `LinSpace(start, stop, len)` always returns a\n      `LinSpace`.\n\n    + `StepRangeLen(a, step, len)` constructs an ordinary-precision range\n      using the values and types of `a` and `step` as given, whereas\n      `range(a, step, len)` will attempt to match inputs `a::FloatNN`\n      and `step::FloatNN` to rationals and construct a `StepRangeLen`\n      that internally uses twice-precision arithmetic.  These two\n      outcomes exhibit differences in both precision and speed.\n\n  * `A=>B` expressions are now parsed as calls instead of using `=>` as the\n    expression head ([#20327]).\n\n  * The `count` function no longer sums non-boolean values ([#20404])\n\n  * The generic `getindex(::AbstractString, ::AbstractVector)` method's signature has been\n    tightened to `getindex(::AbstractString, ::AbstractVector{<:Integer})`. Consequently,\n    indexing into `AbstractString`s with non-`AbstractVector{<:Integer}` `AbstractVector`s\n    now throws a `MethodError` in the absence of an appropriate specialization.\n    (Previously such cases failed less explicitly with the exception of\n    `AbstractVector{Bool}`, which now throws an `ArgumentError` noting that\n    logical indexing into strings is not supported.)  ([#20248])\n\n  * Bessel, Hankel, Airy, error, Dawson, eta, zeta, digamma, inverse digamma,\n    trigamma, and polygamma special functions have been moved from Base to\n    the\n    [SpecialFunctions.jl package](https://github.com/JuliaMath/SpecialFunctions.jl)\n    ([#20427]).  Note that `airy`, `airyx` and `airyprime` have been deprecated\n    in favor of more specific functions (`airyai`, `airybi`, `airyaiprime`,\n    `airybiprimex`, `airyaix`, `airybix`, `airyaiprimex`, `airybiprimex`)\n    ([#18050]).\n\n  * When a macro is called in the module in which that macro is defined, global variables\n    in the macro are now correctly resolved in the macro definition environment. Breakage\n    from this change commonly manifests as undefined variable errors that do not occur\n    under 0.5. Fixing such breakage typically requires sprinkling additional `esc`s in\n    the offending macro ([#15850]).\n\n  * `write` on an `IOBuffer` now returns a signed integer in order to be\n    consistent with other buffers ([#20609]).\n\n  * The `<:Integer` division fallback `/(::Integer, ::Integer)`, which formerly\n    inappropriately took precedence over other division methods for some\n    mixed-integer-type division calls, has been removed ([#19779]).\n\n  * `@async`, `@spawn`, `@spawnat`, `@fetch` and `@fetchfrom` no longer implicitly\n    localize variables. Previously, the expression would be wrapped in an implicit\n    `let` block  ([#19594]).\n\n  * `parse` no longer accepts IPv4 addresses including leading zeros, octal, or hexadecimal.\n    Convert IPv4 addresses including octal or hexadecimal to decimal, and remove leading\n    zeros in decimal addresses ([#19811]).\n\n  * Closures shipped for remote execution via `@spawn` or `remotecall` now automatically\n    serialize globals defined under Main. For details, please refer to the paragraph\n    on \"Global variables\" under the \"Parallel computing\" chapter in the manual ([#19594]).\n\n  * `homedir` now determines the user's home directory via `libuv`'s `uv_os_homedir`,\n    rather than from environment variables ([#19636]).\n\n  * Workers now listen on an ephemeral port assigned by the OS. Previously workers would\n    listen on the first free port available from 9009 ([#21818]).\n\n\nLibrary improvements\n--------------------\n\n  * A new `@views` macro was added to convert a whole expression or block of code to\n    use views for all slices ([#20164]).\n\n  * `max`, `min`, and related functions (`minmax`, `maximum`, `minimum`, `extrema`)\n     now return `NaN` for `NaN` arguments ([#12563]).\n\n  * `oneunit(x)` function to return a dimensionful version of `one(x)`\n    (which is clarified to mean a dimensionless quantity if `x` is dimensionful) ([#20268]).\n\n  * The `chop` and `chomp` functions now return a `SubString` ([#18339]).\n\n  * Numbered stackframes printed in stacktraces can now be opened in an editor by\n    entering the corresponding number in the REPL and pressing `^Q` ([#19680]).\n\n  * The REPL now supports something called *prompt pasting* ([#17599]).\n    This activates when pasting text that starts with `julia>\u2007` into the REPL.\n    In that case, only expressions starting with `julia>\u2007` are parsed, the rest are removed.\n    This makes it possible to paste a chunk of code that has been copied from a REPL session\n    without having to scrub away prompts and outputs.\n    This can be disabled or enabled at will with `Base.REPL.enable_promptpaste(::Bool)`.\n\n  * The function `print_with_color` can now take a color\n    represented by an integer between 0 and 255 inclusive\n    as its first argument ([#18473]). For a number-to-color mapping, please refer to\n    [this chart](https://upload.wikimedia.org/wikipedia/commons/1/15/Xterm_256color_chart.svg).\n    It is also possible to use numbers as colors in environment variables that customizes colors in the REPL.\n    For example, to get orange warning messages, simply set `ENV[\"JULIA_WARN_COLOR\"] = 208`.\n    Please note that not all terminals support 256 colors.\n\n  * The function `print_with_color` no longer prints text in bold by default ([#18628]).\n    Instead, the function now take a keyword argument `bold::Bool`\n    which determines whether to print in bold or not. On some terminals, printing a color in non bold\n    results in slightly darker colors being printed than when printing in bold.\n    Therefore, light versions of the colors are now supported.\n    For the available colors see the help entry on `print_with_color`.\n\n  * The default text style for REPL input and answers has been changed from bold to normal ([#11250]).\n    They can be changed back to bold by setting the environment variables\n    `JULIA_INPUT_COLOR` and `JULIA_ANSWER_COLOR` to `\"bold\"`.\n    For example, one way of doing this is adding `ENV[\"JULIA_INPUT_COLOR\"] = :bold`\n    and `ENV[\"JULIA_ANSWER_COLOR\"] = :bold` to the `.juliarc.jl` file. See the\n    [manual section on customizing colors](https://docs.julialang.org/en/v1/stdlib/REPL/#Customizing-Colors-1)\n    for more information.\n\n  * The default color for info messages has been changed from blue to cyan\n    ([#18442]), and for warning messages from red to yellow ([#18453]).  This\n    can be changed back to the original colors by setting the environment\n    variables `JULIA_INFO_COLOR` to `\"blue\"` and `JULIA_WARN_COLOR` to `\"red\"`.\n\n  * Iteration utilities that wrap iterators and return other iterators (`enumerate`, `zip`, `rest`,\n    `countfrom`, `take`, `drop`, `cycle`, `repeated`, `product`, `flatten`, `partition`) have been\n    moved to the module `Base.Iterators` ([#18839]).\n\n  * BitArrays can now be constructed from arbitrary iterables, in particular from generator expressions,\n    e.g. `BitArray(isodd(x) for x = 1:100)` ([#19018]).\n\n  * `hcat`, `vcat`, and `hvcat` now work with `UniformScaling` objects, so\n    you can now do e.g. `[A I]` and it will concatenate an appropriately sized\n    identity matrix ([#19305]).\n\n  * New `accumulate` and `accumulate!` functions were added, which generalize `cumsum` and `cumprod`.\n    Also known as a [scan](https://en.wikipedia.org/wiki/Prefix_sum) operation ([#18931]).\n\n  * `reshape` now allows specifying one dimension with a `Colon()` (`:`) for the new shape, in which case\n    that dimension's length will be computed such that its product with all the other dimensions is equal\n    to the length of the original array ([#19919]).\n\n  * The new `to_indices` function provides a uniform interface for index conversions,\n    taking an array and a tuple of indices as arguments and returning a tuple of\n    integers and/or arrays of supported scalar indices. It will throw an `ArgumentError`\n    for any unsupported indices, and the returned arrays should be iterated over (and\n    not indexed into) to support more efficient logical indexing ([#19730]).\n\n    + Using colons (`:`) to represent a collection of indices is deprecated. They now must be\n      explicitly converted to a specialized array of integers with the `to_indices` function.\n   \u00a0 \u00a0As a result, the type of `SubArray`s that represent views over colon indices has changed.\n\n    + Logical indexing is now more efficient. Logical arrays are converted by `to_indices` to\n      a lazy, iterable collection of indices that doesn't support indexing. A deprecation\n      provides indexing support with O(n) lookup.\n\n    + The performance of indexing with `CartesianIndex`es is also improved in many situations.\n\n  * A new `titlecase` function was added, to capitalize the first character of each word within a string ([#19469]).\n\n  * `any` and `all` now always short-circuit, and `mapreduce` never short-circuits ([#19543]).\n    That is, not every member of the input iterable will be visited if a `true` (in the case of `any`) or\n    `false` (in the case of `all`) value is found, and `mapreduce` will visit all members of the iterable.\n\n  * Additional methods for `ones` and `zeros` functions were added\n    to support the same signature as the `similar` function ([#19635]).\n\n  * `count` now has a `count(itr)` method equivalent to `count(identity, itr)` ([#20403]).\n\n  * Methods for `map` and `filter` with `Nullable` arguments have been implemented;\n    the semantics are as if the `Nullable` were a container with zero or one elements ([#16961]).\n\n  * New `@test_warn` and `@test_nowarn` macros were added in the `Base.Test` module to\n    test for the presence or absence of warning messages ([#19903]).\n\n  * `logging` can now be used to redirect `info`, `warn`, and `error` messages\n    either universally or on a per-module/function basis ([#16213]).\n\n  * New function `Base.invokelatest(f, args...)` to call the latest version\n    of a function in circumstances where an older version may be called\n    instead (e.g. in a function calling `eval`) ([#19784]).\n\n  * A new `iszero(x)` function was added, to quickly check whether `x` is zero\n    (or is all zeros, for an array) ([#19950]).\n\n  * `notify` now returns a count of tasks woken up ([#19841]).\n\n  * A new nonstandard string literal `raw\"...\"` was added,\n    for creating strings with no interpolation or unescaping ([#19900]).\n\n  * A new `Dates.Time` type was added that supports representing the time of day\n    with up to nanosecond resolution ([#12274]).\n\n  * Raising one or negative one to a negative integer power formerly threw a `DomainError`.\n    One raised to any negative integer power now yields one, negative one raised to any\n    negative even integer power now yields one, and negative one raised to any negative\n    odd integer power now yields negative one. Similarly, raising `true` to any negative\n    integer power now yields `true` rather than throwing a `DomainError` ([#18342]).\n\n  * A new `@macroexpand` macro was added as a convenient alternative to the `macroexpand` function ([#18660]).\n\n  * `invoke` now supports keyword arguments ([#20345]).\n\n  * A new `ConjArray` type was added, as a wrapper type for lazy complex conjugation of arrays.\n    Currently, it is used by default for the new `RowVector` type only, and\n    enforces that both `transpose(vec)` and `ctranspose(vec)` are views not copies ([#20047]).\n\n  * `rem` now accepts a `RoundingMode` argument via `rem(x, y, r::RoundingMode)`, yielding\n    `x - y*round(x/y, r)` without intermediate rounding. In particular, `rem(x, y, RoundNearest)`\n    yields a value in the interval `[-abs(y)/2, abs(y)/2]`), which corresponds to the IEE754\n    `remainder` function. Similarly, `rem2pi(x, r::RoundingMode)` now exists as well, yielding\n    `rem(x, 2pi, r::RoundingMode)` but with greater accuracy ([#10946]).\n\n  * `map[!]` and `broadcast[!]` now have dedicated methods for sparse/structured\n    vectors/matrices. Specifically, `map[!]` and `broadcast[!]` over combinations including\n    one or more `SparseVector`, `SparseMatrixCSC`, `Diagonal`, `Bidiagonal`, `Tridiagonal`,\n    or `SymTridiagonal`, and any number of `broadcast` scalars, `Vector`s, or `Matrix`s,\n    now efficiently yield `SparseVector`s or `SparseMatrix`s as appropriate ([#19239],\n    [#19371], [#19518], [#19438], [#19690], [#19724], [#19926], [#19934], [#20009]).\n\n  * The operators `!` and `\u2218` (`\\circ<tab>` at the REPL and in most code editors) now\n    respectively perform predicate function negation and function composition. For example,\n    `map(!iszero, (0, 1))` is now equivalent to `map(x -> !iszero(x), (0, 1))` and\n    `map(uppercase \u2218 hex, 250:255)` is now equivalent to\n    `map(x -> uppercase(hex(x)), 250:255)` ([#17155]).\n\n  * `enumerate` now supports the two-argument form `enumerate(::IndexStyle, iterable)`.\n    This form allows specification of the returned indices' style. For example,\n    `enumerate(IndexLinear, iterable)` yields linear indices and\n    `enumerate(IndexCartesian, iterable)` yields cartesian indices ([#16378]).\n\nCompiler/Runtime improvements\n-----------------------------\n\n  * `ccall` is now implemented as a macro,\n    removing the need for special code-generator support for `Intrinsics` ([#18754]).\n\n  * `ccall` gained limited support for a `llvmcall` calling-convention.\n    This can replace many uses of `llvmcall` with a simpler, shorter declaration ([#18754]).\n\n  * All `Intrinsics` are now `Builtin` functions instead and have proper error checking\n    and fall-back static compilation support ([#18754]).\n\nDeprecated or removed\n---------------------\n\n  * `ipermutedims(A::AbstractArray, p)` has been deprecated in favor of\n    `permutedims(A, invperm(p))` ([#18891]).\n\n  * Linear indexing is now only supported when there is exactly one\n    non-cartesian index provided. Allowing a trailing index at dimension `d` to\n    linearly access the higher dimensions from array `A` (beyond `size(A, d)`)\n    has been deprecated as a stricter constraint during bounds checking.\n    Instead, `reshape` the array such that its dimensionality matches the\n    number of indices ([#20079]).\n\n  * `Multimedia.@textmime \"mime\"` has been deprecated. Instead define\n    `Multimedia.istextmime(::MIME\"mime\") = true` ([#18441]).\n\n  * `isdefined(a::Array, i::Int)` has been deprecated in favor of `isassigned` ([#18346]).\n\n  * The three-argument `SubArray` constructor (which accepts `dims::Tuple` as its third\n    argument) has been deprecated in favor of the two-argument equivalent (the\n    `dims::Tuple` argument being superfluous) ([#19259]).\n\n  * `is` has been deprecated in favor of `===` (which used to be an alias for `is`) ([#17758]).\n\n  * Ambiguous methods for addition and subtraction between `UniformScaling`s and `Number`s,\n    for example `(+)(J::UniformScaling, x::Number)`, have been deprecated in favor of\n    unambiguous, explicit equivalents, for example `J.\u03bb + x` ([#17607]).\n\n  * `num` and `den` have been deprecated in favor of `numerator` and `denominator` respectively ([#19233],[#19246]).\n\n  * `delete!(ENV::EnvDict, k::AbstractString, def)` has been deprecated in favor of\n    `pop!(ENV, k, def)`. Be aware that `pop!` returns `k` or `def`, whereas `delete!`\n    returns `ENV` or `def` ([#18012]).\n\n  * infix operator `$` has been deprecated in favor of infix `\u22bb` or function `xor` ([#18977]).\n\n  * The single-argument form of `write` (`write(x)`, with implicit `STDOUT` output stream),\n    has been deprecated in favor of the explicit equivalent `write(STDOUT, x)` ([#17654]).\n\n  * `Dates.recur` has been deprecated in favor of `filter` ([#19288])\n\n  * A number of ambiguous `convert` operations between `Number`s (especially `Real`s)\n    and `Date`, `DateTime`, and `Period` types have been deprecated in favor of\n    unambiguous `convert` and explicit constructor calls. Additionally, ambiguous colon\n    construction of `<:Period` ranges without step specification, for example\n    `Dates.Hour(1):Dates.Hour(2)`, has been deprecated in favor of such construction\n    including step specification, for example `Dates.Hour(1):Dates.Hour(1):Dates.Hour(2)`\n    ([#19920]).\n\n  * `cummin` and `cummax` have been deprecated in favor of `accumulate` ([#18931]).\n\n  * The `Array` constructor syntax `Array(T, dims...)` has been deprecated\n    in favor of the forms `Array{T,N}(dims...)` (where `N` is known, or\n    particularly `Vector{T}(dims...)` for `N = 1` and `Matrix{T}(dims...)` for `N = 2`),\n    and `Array{T}(dims...)` (where `N` is not known). Likewise for `SharedArray`s ([#19989]).\n\n  * `sumabs` and `sumabs2` have been deprecated in favor of `sum(abs, x)` and `sum(abs2, x)`, respectively.\n    `maxabs` and `minabs` have similarly been deprecated in favor of `maximum(abs, x)` and `minimum(abs, x)`.\n    Likewise for the in-place counterparts of these functions ([#19598]).\n\n  * The array-reducing form of `isinteger` (`isinteger(x::AbstractArray)`) has been\n    deprecated in favor of `all(isinteger, x)` ([#19925]).\n\n  * `produce`, `consume` and iteration over a Task object have been deprecated in favor of\n    using Channels for inter-task communication  ([#19841]).\n\n  * The `negate` keyword has been deprecated from all functions in the `Dates` adjuster\n    API (`adjust`, `tonext`, `toprev`, `Date`, `Time`, and `DateTime`). Instead use\n    predicate function negation via the `!` operator\n    (see [Library Improvements](#library-improvements)) ([#20213]).\n\n  * `@test_approx_eq x y` has been deprecated in favor of `@test isapprox(x,y)` or `@test x \u2248 y` ([#4615]).\n\n  * `Matrix()` and `Matrix{T}()` have been deprecated in favor of the explicit forms\n    `Matrix(0, 0)` and `Matrix{T}(0, 0)` ([#20330]).\n\n  * Vectorized functions have been deprecated in favor of dot syntax ([#17302], [#17265],\n    [#18558], [#19711], [#19712], [#19791], [#19802], [#19931], [#20543], [#20228]).\n\n  *  All methods of character predicates (`isalnum`, `isalpha`, `iscntrl`, `isdigit`,\n     `isnumber`, `isgraph`, `islower`, `isprint`, `ispunct`, `isspace`, `isupper`,\n     `isxdigit`) that accept `AbstractStrings` have been deprecated in favor of `all`.\n     For example, `isnumber(\"123\")` should now be expressed `all(isnumber, \"123\")`\n     ([#20342]).\n\n  * A few names related to indexing traits have been changed: `LinearIndexing` and\n    `linearindexing` have been deprecated in favor of `IndexStyle`. `LinearFast` has\n    been deprecated in favor of `IndexLinear`, and `LinearSlow` has been deprecated in\n    favor of `IndexCartesian` ([#16378]).\n\n  * The two-argument forms of `map` (`map!(f, A)`) and `asyncmap!` (`asyncmap!(f, A)`)\n    have been deprecated in anticipation of future semantic changes ([#19721]).\n\n  * `unsafe_wrap(String, ...)` has been deprecated in favor of `unsafe_string` ([#19449]).\n\n  * `zeros` and `ones` methods accepting an element type as the first argument and an\n    array as the second argument, for example `zeros(Float64, [1, 2, 3])`, have been\n    deprecated in favor of equivalent methods with the second argument instead the\n    size of the array, for example `zeros(Float64, size([1, 2, 3]))` ([#21183]).\n\n  * `Base.promote_eltype_op` has been deprecated ([#19669], [#19814], [#19937]).\n\n  * `isimag` has been deprecated ([#19949]).\n\n  * The tuple-of-types form of `invoke`, `invoke(f, (types...), ...)`, has been deprecated\n    in favor of the tuple-type form `invoke(f, Tuple{types...}, ...)` ([#18444]).\n\n  * `Base._promote_array_type` has been deprecated ([#19766]).\n\n  * `broadcast_zpreserving` has been deprecated ([#19533], [#19720]).\n\n  * Methods allowing indexing of tuples by `AbstractArray`s with more than one dimension\n    have been deprecated. (Indexing a tuple by such a higher-dimensional `AbstractArray`\n    should yield a tuple with more than one dimension, but tuples are one-dimensional.)\n    ([#19737]).\n\n  * `@test_approx_eq a b` has been deprecated in favor of `@test a \u2248 b` (or,\n    equivalently, `@test \u2248(a, b)` or `@test isapprox(a, b)`).\n    `@test_approx_eq_eps` has been deprecated in favor of new `@test` syntax:\n    `@test` now supports the syntax `@test f(args...) key=val ...` for\n    `@test f(args..., key=val...)`. This syntax allows, for example, writing\n    `@test a \u2248 b atol=c` in place of `@test \u2248(a, b, atol=c)` (and hence\n    `@test_approx_eq_eps a b c`) ([#19901]).\n\n  * `takebuf_array` has been deprecated in favor of `take!`, and `takebuf_string(x)`\n    has been deprecated in favor of `String(take!(x))` ([#19088]).\n\n  * `convert` methods from `Diagonal` and `Bidiagonal` to subtypes of\n    `AbstractTriangular` have been deprecated ([#17723]).\n\n  * `Base.LinAlg.arithtype` has been deprecated. If you were using `arithtype` within a\n    `promote_op` call, instead use `promote_op(Base.LinAlg.matprod, Ts...)`. Otherwise,\n    consider defining equivalent functionality locally ([#18218]).\n\n  * Special characters (`#{}()[]<>|&*?~;`) should now be quoted in commands. For example,\n    ``` `export FOO=1\\;` ``` should replace ``` `export FOO=1;` ``` and\n    ``` `cd $dir '&&' $thingie` ``` should replace ``` `cd $dir && $thingie` ``` ([#19786]).\n\n  * Zero-argument `Channel` constructors (`Channel()`, `Channel{T}()`) have been deprecated\n    in favor of equivalents accepting an explicit `Channel` size\n    (`Channel(2)`, `Channel{T}(2)`) ([#18832]).\n\n  * The zero-argument constructor `MersenneTwister()` has been\n    deprecated in favor of the explicit `MersenneTwister(0)` ([#16984]).\n\n  * `Base.promote_type(op::Type, Ts::Type...)` has been removed as part of an overhaul\n    of `broadcast`'s promotion mechanism. If you need the functionality of that\n    `Base.promote_type` method, consider defining it locally via\n    `Core.Compiler.return_type(op, Tuple{Ts...})` ([#18642]).\n\n  * `bitbroadcast` has been deprecated in favor of `broadcast`, which now produces a\n    `BitArray` instead of `Array{Bool}` for functions yielding a boolean result ([#19771]).\n\n  * To complete the deprecation of histogram-related functions, `midpoints` has been\n    deprecated. Instead use the\n    [StatsBase.jl package](https://github.com/JuliaStats/StatsBase.jl)'s\n    `midpoints` function ([#20058]).\n\n  * Passing a type argument to `LibGit2.cat` has been deprecated in favor of a simpler,\n    two-argument method for `LibGit2.cat` ([#20435]).\n\n  * The `LibGit2.owner` function for finding the repository which owns a given Git object\n    has been deprecated in favor of `LibGit2.repository` ([#20135]).\n\n  * The `LibGit2.GitAnyObject` type has been renamed to `LibGit2.GitUnknownObject` to\n    clarify its intent ([#19935]).\n\n  * The `LibGit2.GitOid` type has been renamed to `LibGit2.GitHash` for clarity ([#19878]).\n\n  * Finalizing `LibGit2` objects with `finalize` has been deprecated in favor of using `close`\n    ([#19660]).\n\n  * Parsing string dates from a `Dates.DateFormat` object has been deprecated as part of a\n    larger effort toward faster, more extensible date parsing ([#20952]).\n\nCommand-line option changes\n---------------------------\n\n  * In `polly` builds (`USE_POLLY := 1`), the new flag `--polly={yes|no}` controls whether\n    `@polly` declarations are respected. (With `--polly=no`, `@polly` declarations are\n    ignored.) This flag is also available in non-`polly` builds (`USE_POLLY := 0`),\n    but has no effect ([#18159]).\n\nJulia v0.5.0 Release Notes\n==========================\n\nNew language features\n---------------------\n\n  * Generator expressions: `f(i) for i in 1:n` ([#4470]). This returns an iterator\n    that computes the specified values on demand. This is useful for computing, e.g.\n    `sum(f(i) for i in 1:n)` without creating an intermediate array of values.\n\n  * Generators and comprehensions support filtering using `if` ([#550]) and nested\n    iteration using multiple `for` keywords ([#4867]).\n\n  * Fused broadcasting syntax: ``f.(args...)`` is equivalent to ``broadcast(f, args...)`` ([#15032]),\n    and nested `f.(g.(args...))` calls are fused into a single `broadcast` loop ([#17300]).\n    Similarly, the syntax `x .= ...` is equivalent to a `broadcast!(identity, x, ...)`\n    call and fuses with nested \"dot\" calls; also, `x .+= y` and similar is now\n    equivalent to `x .= x .+ y`, rather than `x = x .+ y` ([#17510]).\n\n  * Macro expander functions are now generic, so macros can have multiple definitions\n    (e.g. for different numbers of arguments, or optional arguments) ([#8846], [#9627]).\n    However note that the argument types refer to the syntax tree representation, and not\n    to the types of run time values.\n\n  * Varargs functions like `foo{T}(x::T...)` may now restrict the number\n    of such arguments using `foo{T,N}(x::Vararg{T,N})` ([#11242]).\n\n  * `x \u2208 X` is now a synonym for `x in X` in `for` loops and comprehensions,\n    as it already was in comparisons ([#13824]).\n\n  * The `PROGRAM_FILE` global is now available for determining the name of the running script ([#14114]).\n\n  * The syntax `x.:sym` (e.g. `Base.:+`) is now supported, while using `x.(:sym)`\n    or `x.(i)` for field access are deprecated in favor of `getfield` ([#15032]).\n\n  * Function return type syntax `function f()::T` has been added ([#1090]). Values returned\n    from a function with such a declaration will be converted to the specified type `T`.\n\n  * Many more operators now support `.` prefixes (e.g. `.\u2264`) ([#17393]).  However,\n    users are discouraged from overloading these, since they are mainly parsed\n    in order to implement backwards compatibility with planned automatic\n    broadcasting of dot operators in Julia 0.6 ([#16285]).  Explicitly qualified\n    operator names like `Base.\u2264` should now use `Base.:\u2264` (prefixed by `@compat`\n    if you need 0.4 compatibility via the `Compat` package).\n\n  * User-extensible bounds check elimination is now possible with the new\n    `@boundscheck` macro ([#14474]). This macro marks bounds checking code blocks,\n    which the compiler may remove when encountered inside an `@inbounds` call.\n\nExperimental language features\n------------------------------\n\n  * Support for\n    [multi-threading](https://docs.julialang.org/en/v1/manual/parallel-computing/#man-multithreading-1).\n    Loops with independent iterations can be easily parallelized with the\n    `Threads.@threads` macro.\n\n  * Support for arrays with indexing starting at values different from 1.\n    The array types are expected to be defined in packages, but now\n    Julia provides an API for writing generic algorithms for arbitrary\n    indexing schemes ([#16260]).\n\nLanguage changes\n----------------\n\n  * Each function and closure now has its own type. The captured variables of a closure\n    are fields of its type. `Function` is now an abstract type, and is the default\n    supertype of functions and closures. All functions, including anonymous functions,\n    are generic and support all features (e.g. keyword arguments). Instead of adding\n    methods to `call`, methods are added by type using the syntax\n    `(::ftype)(...) = ...`. `call` is deprecated ([#13412]). A significant result of\n    this language change is that higher order functions can be specialized on their\n    function arguments, leading to much faster functional programming, typically as\n    fast as if function arguments were manually inlined. See below for details.\n\n  * Square brackets and commas (e.g. `[x, y]`) no longer concatenate arrays, and always\n    simply construct a vector of the provided values. If `x` and `y` are arrays,\n    `[x, y]` will be an array of arrays ([#3737], [#2488], [#8599]).\n\n  * `using` and `import` are now case-sensitive even on case-insensitive filesystems\n    (common on Mac and Windows) ([#13542]).\n\n  * Relational algebra symbols are now allowed as infix operators ([#8036]):\n    `\u2a1d`, `\u27d5`, `\u27d6`, `\u27d7` for joins and `\u25b7` for anti-join.\n\n  * A warning is always given when a method is overwritten; previously, this was done\n    only when the new and old definitions were in separate modules ([#14759]).\n\n  * The `if` keyword cannot be followed immediately by a line break ([#15763]).\n\n  * Juxtaposition of numeric literals ending in `.` (e.g. `1.x`) is no longer\n    allowed ([#15731]).\n\n  * The built-in `NTuple` type has been removed; `NTuple{N,T}` is now\n    implemented internally as `Tuple{Vararg{T,N}}` ([#11242]).\n\n  * Use of the syntax `x::T` to declare the type of a local variable is deprecated.\n    In the future this will always mean type assertion, and declarations should use\n    `local x::T` instead ([#16071]).\n    When `x` is global, `x::T = ...` and `global x::T` used to mean type assertion,\n    but this syntax is now reserved for type declaration ([#964]).\n\n  * Dictionary comprehension syntax `[ a=>b for x in y ]` is deprecated.\n    Use `Dict(a=>b for x in y)` instead ([#16510]).\n\n  * Parentheses are no longer allowed around iteration specifications, e.g.\n    `for (i = 1:n)` ([#17668]).\n\nBreaking changes\n----------------\n\nThis section lists changes that do not have deprecation warnings.\n\n  * All dimensions indexed by scalars are now dropped, whereas previously only\n    trailing scalar dimensions would be omitted from the result ([#13612]). This\n    is a very major behavioral change, but should cause obvious failures. To retain\n    a dimension sliced with a scalar `i` slice with `i:i` instead.\n\n  * The assignment operations `.+=`, `.*=` and so on now generate calls\n    to `broadcast!` on the left-hand side (or call to `view(a, ...)` on the left-hand side\n    if the latter is an indexing expression, e.g. `a[...]`). This means that they will fail\n    if the left-hand side is immutable (or does not support `view`), and will otherwise\n    change the left-hand side in-place ([#17510], [#17546]).\n\n  * Method ambiguities no longer generate warnings when files are loaded,\n    nor do they dispatch to an arbitrarily-chosen method; instead, a call that\n    cannot be resolved to a single method results in a `MethodError` at run time,\n    rather than the previous definition-time warning ([#6190]).\n\n  * Array comprehensions preserve the dimensions of the input ranges. For example,\n    `[2x for x in A]` will have the same dimensions as `A` ([#16622]).\n\n  * The result type of an array comprehension depends only on the types of elements\n    computed, instead of using type inference ([#7258]). If the result is empty, then\n    type inference is still used to determine the element type.\n\n  * `reshape` is now defined to always share data with the original array.\n    If a reshaped copy is needed, use `copy(reshape(a))` or `copy!` to a new array of\n    the desired shape ([#4211]).\n\n  * `mapslices` now re-uses temporary storage. Recipient functions that expect\n    input slices to be persistent should copy data to other storage ([#17266]).\n    All usages of `mapslices` should be carefully audited since this change can cause\n    silent, incorrect behavior, rather than failing noisily.\n\n  * Local variables and arguments are represented in lowered code as numbered `Slot`\n    objects instead of as symbols ([#15609]).\n\n  * The information that used to be in the `ast` field of the `LambdaStaticData` type\n    is now divided among the fields `code`, `slotnames`, `slottypes`, `slotflags`,\n    `gensymtypes`, `rettype`, `nargs`, and `isva` in the `LambdaInfo` type ([#15609]).\n\n  * `A <: B` is parsed as `Expr(:(<:), :A, :B)` in all cases ([#9503]).\n    This also applies to the `>:` operator.\n\n  * Simple 2-argument comparisons like `A < B` are parsed as calls instead of using the\n    `:comparison` expression type ([#15524]). The `:comparison` expression type is still\n    produced in ASTs when comparisons are chained (e.g. `A < B \u2264 C`).\n\n  * `map` on a dictionary now expects a function that expects and returns a `Pair`.\n    The result is now another dictionary instead of an array ([#16622]).\n\n  * Bit shift operations (i.e. `<<`, `>>`, and `>>>`) now handle\n    negative shift counts differently: Negative counts are interpreted\n    as shifts in the opposite direction. For example, `4 >> -1 == 4 <<\n    +1 == 8`. Previously, negative counts would implicitly overflow to\n    large positive counts, always yielding either `0` or `-1`.\n\nLibrary improvements\n--------------------\n\n  * Strings ([#16107]):\n\n    * The `UTF8String` and `ASCIIString` types have been merged into a single\n      `String` type ([#16058]).  Use `isascii(s)` to check whether\n      a string contains only ASCII characters. The `ascii(s)` function now\n      converts `s` to `String`, raising an `ArgumentError` exception if `s` is\n      not pure ASCII.\n\n    * The `UTF16String` and `UTF32String` types and corresponding `utf16` and\n      `utf32` converter functions have been removed from the standard library.\n      If you need these types, they have been moved to the\n      [LegacyStrings.jl package](https://github.com/JuliaArchive/LegacyStrings.jl).\n      In the future, more robust Unicode string support will be provided by the\n      [StringEncodings.jl package](https://github.com/nalimilan/StringEncodings.jl).\n      If you only need these types to call wide string APIs (UTF-16 on Windows,\n      UTF-32 on UNIX), consider using the new `transcode` function (see below)\n      or the `Cwstring` type as a `ccall` argument type, which also ensures\n      correct NUL termination of string data.\n\n    * A `transcode(T, src)` function is now exported for converting data\n      between UTF-xx Unicode encodings ([#17323]).\n\n    * The basic string construction routines are now `string(args...)`,\n      `String(s)`, `unsafe_string(ptr)` (formerly `bytestring(ptr)`), and\n      `unsafe_wrap(String, ptr)` (formerly `pointer_to_string`) ([#16731]).\n\n    * Comparisons between `Char`s and `Integer`s are now deprecated ([#16024]):\n      `'x' == 120` now produces a warning but still evaluates to `true`. In the\n      future it may evaluate to `false` or the comparison may be an error. To\n      compare characters with integers you should either convert the integer to\n      a character value or convert the character to the corresponding code point\n      first: e.g. `'x' == Char(120)` or `Int('x') == 120`. The former is usually\n      preferable.\n\n    * Support for Unicode 9 ([#17402]).\n\n  * Arrays and linear algebra:\n\n    * Dimensions indexed by multidimensional arrays add dimensions. More generally, the\n      dimensionality of the result is the sum of the dimensionalities of the indices ([#15431]).\n\n    * New `normalize` and `normalize!` convenience functions for normalizing\n      vectors ([#13681]).\n\n    * QR matrix factorization:\n\n      * New method for generic QR with column pivoting ([#13480]).\n\n      * New method for polar decompositions of `AbstractVector`s ([#13681]).\n\n    * A new `SparseVector` type allows for one-dimensional sparse arrays.\n      Slicing and reshaping sparse matrices now return vectors when\n      appropriate. The `sparsevec` function returns a one-dimensional sparse\n      vector instead of a one-column sparse matrix. The `SparseMatrix` module\n      has been renamed to `SparseArrays` ([#13440]).\n\n    * Rank one update and downdate functions, `lowrankupdate`, `lowrankupdate!`, `lowrankdowndate`,\n      and `lowrankdowndate!`, have been introduced for dense Cholesky factorizations ([#14243], [#14424]).\n\n    * All `sparse` methods now retain provided numerical zeros as structural nonzeros; to\n      drop numerical zeros, use `dropzeros!` ([#14798], [#15242]).\n\n    * `setindex!` methods for sparse matrices and vectors no longer purge allocated entries\n      on zero assignment. To drop stored entries from sparse matrices and vectors, use\n      `Base.SparseArrays.dropstored!` ([#17404]).\n\n    * Concatenating dense and sparse matrices now returns a sparse matrix ([#15172]).\n\n  * Files and I/O:\n\n    * The `open` function now respects `umask` on UNIX when creating files ([#16466], [#16502]).\n\n    * A new function `walkdir()` returns an iterator that walks the tree of a directory ([#8814], [#13707]).\n\n       ```\n       for (root, dirs, files) in walkdir(expanduser(\"~/.julia/v0.5/Plots/src\"))\n           println(\"$(length(files)) \\t files in $root\")\n       end\n       19    files in /Users/me/.julia/v0.5/Plots/src\n       15    files in /Users/me/.julia/v0.5/Plots/src/backends\n       4     files in /Users/me/.julia/v0.5/Plots/src/deprecated\n      ```\n\n    * A new function `chown()` changes the ownership of files ([#15007]).\n\n    * Display properties can now be passed among output functions (e.g. `show`)\n      using an `IOContext` object ([#13825]).\n\n    * `Cmd(cmd; ...)` now accepts new Windows-specific options `windows_verbatim`\n      (to alter Windows command-line generation) and `windows_hide` (to\n      suppress creation of new console windows) ([#13780]).\n\n    * There is now a default no-op `flush(io)` function for all `IO` types ([#16403]).\n\n  * Parallel computing:\n\n    * `pmap` keyword arguments `err_retry=true` and `err_stop=false` are deprecated.\n      Action to be taken on errors can be specified via the `on_error` keyword argument.\n      Retry is specified via `retry_n`, `retry_on` and `retry_max_delay` ([#15409], [#15975], [#16663]).\n\n    * The functions `remotecall`, `remotecall_fetch`, and `remotecall_wait` now have the\n      function argument as the first argument to allow for do-block syntax ([#13338]).\n\n  * Statistics:\n\n    * Improve performance of `quantile` ([#14413]).\n\n    * `extrema` can now operate over a region ([#15550]).\n\n    * `cov` and `cor` don't use keyword arguments anymore and are therefore now type stable ([#13465]).\n\n    * Histogram functionality has been deprecated in `Base`. Use the\n      [StatsBase.jl package](https://github.com/JuliaStats/StatsBase.jl)\n      instead ([#6842], [#16450]).\n\n  * Testing:\n\n    * The `Base.Test` module now has a `@testset` feature to bundle\n      tests together and delay throwing an error until the end ([#13062]).\n\n    * The new features are mirrored in the\n      [BaseTestNext.jl package](https://github.com/IainNZ/BaseTestNext.jl)\n      for users who would like to use the new functionality on Julia v0.4.\n\n    * The [BaseTestDeprecated.jl package](https://github.com/IainNZ/BaseTestDeprecated.jl)\n      provides the old-style `handler` functionality, for compatibility\n      with code that needs to support both Julia v0.4 and v0.5.\n\n  * Package management:\n\n    * The package system (`Pkg`) is now based on the `libgit2` library, rather\n      than running the `git` program, increasing performance (especially on\n      Windows) ([#11196]).\n\n    * Package-development functions like `Pkg.tag` and `Pkg.publish`\n      have been moved to an external [PkgDev] package ([#13387]).\n\n    * Updating only a subset of the packages is now supported,\n      e.g. `Pkg.update(\"Example\")` ([#17132]).\n\n  * Miscellaneous:\n\n    * Prime number related functions have been moved from `Base` to the\n      [Primes.jl package](https://github.com/JuliaMath/Primes.jl) ([#16481]).\n\n    * Most of the combinatorics functions have been moved from `Base`\n      to the [Combinatorics.jl package](https://github.com/JuliaLang/Combinatorics.jl) ([#13897]).\n\n    * New `foreach` function for calling a function on every element of a collection when\n      the results are not needed ([#13774]). Compared to `map(f, v)`, which allocates and\n      returns a result array, `foreach(f, v)` calls `f` on each element of `v`, returning\n      nothing.\n\n    * The new `Base.StackTraces` module makes stack traces easier to use programmatically ([#14469]).\n\n    * The `libjulia` library is now properly versioned and installed to the public `<prefix>/lib`\n      directory, instead of the private `<prefix>/lib/julia` directory ([#16362]).\n\n    * System reflection is now more consistently exposed from `Sys` and not `Base`\n      (e.g. constants such as `WORD_SIZE` and `CPU_CORES`). `OS_NAME` has been\n      replaced by `Sys.KERNEL` and always reports the name of the kernel (as\n      reported by `uname`). The `@windows_only` and `@osx` family of macros\n      have been replaced with functions such as `is_windows()` and `is_apple()`.\n      There is now also a `@static` macro that will evaluate the condition of an\n      if-statement at compile time, for when a static branch is required ([#16219]).\n\n    * `Date` and `DateTime` values can now be rounded to a specified resolution (e.g., 1 month or\n      15 minutes) with `floor`, `ceil`, and `round` ([#17037]).\n\n[PkgDev]: https://github.com/JuliaLang/PkgDev.jl\n\nCompiler/Runtime improvements\n-----------------------------\n\n  * Machine SIMD types can be represented in Julia as a homogeneous tuple of `VecElement` ([#15244]).\n\n  * The performance of higher-order and anonymous functions has been greatly improved.\n    For example, `map(x->2x, A)` performs as well as `2.*A`([#13412]).\n\n  * On windows, a DLL of standard library code is now precompiled and used by default,\n    improving startup time ([#16953]).\n\n  * LLVM has been upgraded to version 3.7.1, improving the quality of generated\n    code and debug info. However compile times may be slightly longer ([#14623]).\n\nNew architectures\n-----------------\n\n  This release greatly improves support for ARM, and introduces support for Power.\n\n  * [ARM](https://github.com/JuliaLang/julia/issues?utf8=%E2%9C%93&q=label%3Aarm):\n    [#14194], [#14519], [#16645], [#16621]\n\n  * [Power](https://github.com/JuliaLang/julia/issues?utf8=%E2%9C%93&q=label%3Apower):\n    [#16455], [#16404]\n\nDeprecated or removed\n---------------------\n\n  * The following function names have been simplified and unified ([#13232]):\n\n    * `get_bigfloat_precision`  -> `precision(BigFloat)`\n    * `set_bigfloat_precision`  -> `setprecision`\n    * `with_bigfloat_precision` -> `setprecision`\n\n    * `get_rounding`            -> `rounding`\n    * `set_rounding`            -> `setrounding`\n    * `with_rounding`           -> `setrounding`\n\n  * The method `A_ldiv_B!(SparseMatrixCSC, StridedVecOrMat)` has been deprecated\n    in favor of versions that require the matrix to be in factored form\n    ([#13496]).\n\n  * `chol(A,Val{:U/:L})` has been deprecated in favor of `chol(A)` ([#13680]).\n\n  * `rem1(x,y)` is discontinued due to inconsistency for `x==0`. Use `mod1` instead ([#14140]).\n\n  * The `FS` module has been renamed to `Filesystem`. Calling the functions `isreadable`,\n   `iswritable`, and `isexecutable` on filesystem paths has been deprecated ([#12819]).\n\n  * `RemoteRef` has been deprecated in favor of `RemoteChannel` ([#14458]).\n\n  * `super` has been renamed to `supertype` ([#14335]).\n\n  * `parseip(str)` has been deprecated in favor of `parse(IPAddr, str)` ([#14676]).\n\n  * `readall` has been renamed to `readstring`, and `readbytes` has been renamed to `read` ([#14608], [#14660]).\n\n  * `fieldoffsets(x)` has been deprecated in favor of calling `fieldoffset(x, i)` on each field ([#14777]).\n\n  * `issym` is deprecated in favor of `issymmetric` to match similar functions\n    (`ishermitian`, ...) ([#15192]).\n\n  * `scale` is deprecated in favor of either `\u03b1*A`, `Diagonal(x)*A`, or `A*Diagonal(x)` ([#15258]).\n\n  * `istext` has been renamed to `istextmime` ([#12872], [#15708]).\n\n  * \"Functor\" types are no longer necessary and have been deprecated ([#15804]). To maintain\n    performance on older versions of Julia the [Compat.jl package](https://github.com/JuliaLang/Compat.jl/pull/184)\n    provides a `@functorize` macro.\n\n  * `bitunpack(B)` and `bitpack(A)` have been deprecated in favor of\n    `Array(B)` and `BitArray(A)`, respectively ([#16010]).\n\n  * `xdump` is removed, and `dump` now simply shows the full representation of a value.\n    `dump` should not be overloaded, since it is for examining concrete structure ([#4163]).\n\n  * `sprandbool` has been deprecated in favor of `sprand(Bool, ...)` or\n    `sprand(rng, Bool, ...)` ([#11688], [#16098]).\n\n  * The lowercase `symbol` function has been deprecated in favor of the `Symbol`\n    constructor ([#16154]).\n\n  * `writemime` is deprecated, and output methods specifying a MIME type are now\n    methods of `show` ([#14052]).\n\n  * BLAS utility functions `blas_set_num_threads`, `blas_vendor`, and `check_blas`\n    have been moved to the BLAS module as `BLAS.set_num_threads`, `BLAS.vendor`,\n    and `BLAS.check` ([#10548], [#16600]).\n\n  * `print_escaped` has been renamed to `escape_string`, `print_unescaped` has been\n    renamed to `unescape_string`, and `print_joined` has been renamed to `join` ([#16603]).\n\n  * `pointer_to_string` has been renamed to `unsafe_wrap(String, ...)`, and\n    `pointer_to_array` has been renamed to `unsafe_wrap(Array, ...)` ([#16731]).\n\n  * `sub` and `slice` have been deprecated in favor of `view` ([#16972]).\n\n  * Sparse matrix functions `etree`, `ereach`, `csc_permute`, and `symperm` have been moved\n    to the [SuiteSparse.jl package](https://github.com/JuliaSparse/SuiteSparse.jl) ([#12231], [#17033]).\n\n  * The no-op `transpose` fallback for non-numeric arrays has been deprecated. Consider introducing suitable\n    `transpose` methods or calling `permutedims(x, (2, 1))` for matrices and `reshape(x, 1, length(x))` for\n    vectors.  ([#13171], [#17075], [#17374]).\n\n  * The following macros have been deprecated ([#16219]):\n    * `@windows` is deprecated in favor of `is_windows()`\n    * `@unix` is deprecated in favor of `is_unix()`\n    * `@osx` is deprecated in favor of `is_apple()`\n    * `@linux` is deprecated in favor of `is_linux()`\n    * `@windows_only` is deprecated in favor of `if is_windows()`\n    * `@unix_only` is deprecated in favor of `if is_unix()`\n    * `@osx_only` is deprecated in favor of `if is_apple()`\n    * `@linux_only` is deprecated in favor of `if is_linux()`\n    * NOTE: Using `@static` could be useful/necessary when used in a function's local scope. See details at the section entitled [Handling Operating System Variation](https://docs.julialang.org/en/v1/manual/handling-operating-system-variation/) in the manual.\n\nCommand-line option changes\n---------------------------\n\n  * The `-F` flag to load `~/.juliarc` has been deprecated in favor of\n    `--startup-file=yes` ([#9482]).\n\n  * The `-f` and `--no-startup` flags to disable loading of `~/.juliarc` have\n    been deprecated in favor of `--startup-file=no` ([#9482]).\n\n  * The `-P` and `--post-boot` flags for evaluating an expression in \"interactive mode\"\n    have been deprecated in favor of `-i -e` ([#16854]).\n\n  * The `--no-history-file` flag to disable loading of `~/.julia_history` has been\n    deprecated in favor of `--history-file=no` ([#9482]).\n\nLanguage tooling improvements\n-----------------------------\n\n   * The [Julia debugger](https://github.com/Keno/Gallium.jl) makes its debut\n     with this release. Install it with `Pkg.add(\"Gallium\")`, and the\n     [documentation](https://github.com/Keno/Gallium.jl#gallium) should\n     get you going. The [JuliaCon\n     talk](https://www.youtube.com/watch?v=e6-hcOHO0tc&list=PLP8iPy9hna6SQPwZUDtAM59-wPzCPyD_S&index=5)\n     on Gallium shows off various features of the debugger.\n\n   * The [Juno IDE](http://junolab.org) has matured significantly, and now\n     also includes support for plotting and debugging.\n\n   * [Cxx.jl](https://github.com/Keno/Cxx.jl) provides a convenient FFI for\n     calling C++ code from Julia.\n\nJulia v0.4.0 Release Notes\n==========================\n\nNew language features\n---------------------\n\n  * Function call overloading: for arbitrary objects `x` (not of type\n    `Function`), `x(...)` is transformed into `call(x, ...)`, and `call`\n    can be overloaded as desired.  Constructors are now a special case of\n    this mechanism, which allows e.g. constructors for abstract types.\n    `T(...)` falls back to `convert(T, x)`, so all `convert` methods implicitly\n    define a constructor ([#8712], [#2403]).\n\n  * Unicode version 8 is now supported for identifiers etcetera ([#7917], [#12031]).\n\n  * Type parameters now permit any `isbits` type, not just `Int` and `Bool` ([#6081]).\n\n  * Keyword argument names can be computed, using syntax such as `f(; symbol => val)` ([#7704]).\n\n  * The syntax `@generated function` enables generation of specialized methods based on\n    argument types. At compile time, the function is called with its arguments bound to their\n    types instead of to their values. The function then returns an expression forming the\n    body of the function to be called at run time ([#7311]).\n\n  * [Documentation system](https://docs.julialang.org/en/v1/manual/documentation/)\n    for functions, methods, types and macros in packages and user code ([#8791]).\n\n  * The syntax `function foo end` can be used to introduce a generic function without\n    yet adding any methods ([#8283]).\n\n  * Incremental precompilation of modules: call `VERSION >= v\"0.4.0-dev+6521\" && __precompile__()` at the top of a\n    module file to automatically precompile it when it is imported ([#12491]), or manually\n    run `Base.compilecache(modulename)`. The resulting precompiled `.ji` file is saved in\n    `~/.julia/lib/v0.4` ([#8745]).\n\n      * See manual section on `Module initialization and precompilation` (under `Modules`) for\n        details and errata.  In particular, to be safely precompilable a module may need an\n        `__init__` function to separate code that must be executed at runtime rather than precompile\n        time.  Modules that are *not* precompilable should call `__precompile__(false)`.\n\n      * The precompiled `.ji` file includes a list of dependencies (modules and files that\n        were imported/included at precompile-time), and the module is automatically recompiled\n        upon `import` when any of its dependencies have changed.  Explicit dependencies\n        on other files can be declared with `include_dependency(path)` ([#12458]).\n\n      * New option `--output-incremental={yes|no}` added to invoke the equivalent of `Base.compilecache`\n        from the command line.\n\n  * The syntax `new{parameters...}(...)` can be used in constructors to specify parameters for\n    the type to be constructed ([#8135]).\n\n  * `++` is now parsed as an infix operator, but does not yet have a default definition ([#11030], [#11686]).\n\n  * Support for inter-task communication using `Channels` ([#12264]).\n    See https://docs.julialang.org/en/v1/manual/parallel-computing/#Channels-1 for details.\n\n  * `RemoteRef`s now point to remote channels. The remote channels can be of length greater than 1.\n    Default continues to be of length 1 ([#12385]).\n    See https://docs.julialang.org/en/v1/manual/parallel-computing/#Remote-References-and-AbstractChannels-1 for details.\n\n  * `@__LINE__` special macro now available to reflect invocation source line number ([#12727]).\n\nLanguage changes\n----------------\n\n  * Tuple types are now written as `Tuple{A, B}` instead of as `(A, B)`.\n    Tuples of bits types are inlined into structs and arrays, like other\n    immutable types.\n    `...` now does splatting inside parentheses, instead of constructing a\n    variadic tuple type ([#10380]).\n    Variadic tuple types are written as `Tuple{Vararg{T}}`.\n\n  * Using `[x,y]` to concatenate arrays is deprecated, and in the future will\n    construct a vector of `x` and `y` instead ([#3737], [#2488], [#8599]).\n\n  * Significant improvements to `ccall` and `cfunction`\n\n    * As a safer alternative to creating pointers (`Ptr`), the managed reference type\n      `Ref` has been added. A `Ref` points to the data contained by a value in an\n      abstract sense, and in a way that is GC-safe. For example, `Ref(2)` points to\n      a storage location that contains the integer `2`, and `Ref(array,3)` points\n      to the third element of an array. A `Ref` can be automatically converted to a\n      native pointer when passed to a `ccall`.\n\n    * When passing a by-reference argument to `ccall`, you can declare\n      the argument type to be `Ref{T}` instead of `Ptr{T}`, and just\n      pass `x` instead of `&x`.\n\n    * `ccall` is now lowered to call `unsafe_convert(T, cconvert(T, x))` on each\n      argument. `cconvert` falls back to `convert`, but can be used to convert an\n      argument to an arbitrarily-different representation more suitable for passing\n      to C. `unsafe_convert` then handles conversions to `Ptr`.\n\n    * `ccall` and `cfunction` now support correctly passing and returning structs,\n      following the platform ABI (assuming the C types are mirrored accurately in Julia).\n\n    * `cfunction` arguments of struct-like Julia types are now passed by value.\n      If `Ref{T}` is used as a `cfunction` argument type, it will look up the\n      method applicable to `T`, but pass the argument by reference (as Julia functions\n      usually do). However, this should only be used for objects allocated by Julia\n      and for `isbits` types.\n\n  * `convert(Ptr,x)` is deprecated for most types, replaced by\n    `unsafe_convert`. You can still `convert` between pointer types,\n    and between pointers and `Int` or `UInt`.\n\n  * Module `__init__` methods no longer swallow thrown exceptions; they now\n    throw an `InitError` wrapping the thrown exception ([#12576]).\n\n  * Unsigned `BigInt` literal syntax has been removed ([#11105]).\n    Unsigned literals larger than `UInt128` now throw a syntax error.\n\n  * `error(::Exception)` and `error(::Type{Exception})` have been deprecated\n     in favor of using an explicit `throw` ([#9690]).\n\n  * `Uint` etcetera are renamed to `UInt` ([#8905]).\n\n  * `String` is renamed to `AbstractString` ([#8872]).\n\n  * `FloatingPoint` is renamed to `AbstractFloat` ([#12162]).\n\n  * `None` is deprecated; use `Union{}` instead ([#8423]).\n\n  * `Nothing` (the type of `nothing`) is renamed to `Void` ([#8423]).\n\n  * Arrays can be constructed with the syntax `Array{T}(m,n)` ([#3214], [#10075]).\n\n  * `Dict` literal syntax `[a=>b,c=>d]` is replaced by `Dict(a=>b,c=>d)`,\n    `{a=>b}` is replaced by `Dict{Any,Any}(a=>b)`, and\n    `(K=>V)[...]` is replaced by `Dict{K,V}(...)`.\n    The new syntax has many advantages: all of its components are first-class,\n    it generalizes to other types of containers, it is easier to guess how to\n    specify key and value types, and the syntaxes for empty and pre-populated\n    dicts are synchronized. As part of this change, `=>` is parsed as a normal\n    operator, and `Base` defines it to construct `Pair` objects ([#6739]).\n\n  * `Char` is no longer a subtype of `Integer` ([#8816]).\n    Char now supports a more limited set of operations with `Integer` types:\n\n      * comparison / equality\n      * `Char` + `Int` = `Char`\n      * `Char` - `Char` = `Int`\n\n  * `round` rounds to the nearest integer using the default rounding mode,\n    which is ties-to-even by default ([#8750]).\n\n  * A custom triple-quoted string like `x\"\"\"...\"\"\"` no longer invokes an `x_mstr`\n    macro. Instead, the string is first unindented and then `x_str` is invoked,\n    as if the string had been single-quoted ([#10228]).\n\n  * Colons (`:`) within indexing expressions are no longer lowered to the range\n    `1:end`. Instead, the `:` identifier is passed directly. Custom array types\n    that implement `getindex` or `setindex!` methods must also extend those\n    methods to support arguments of type `Colon` ([#10331]).\n\n  * Unions of types should now be written with curly braces instead of parentheses, i.e.\n    `Union{Type1, Type2}` instead of `Union(Type1, Type2)` ([#11432]).\n\n  * The keyword `local` is no longer allowed in global scope. Use `let` instead of\n    `begin` to create a new scope from the top level ([#7234], [#10472]).\n\n  * Triple-quoted strings no longer treat tabs as 8 spaces. Instead, the\n    longest common prefix of spaces and tabs is removed.\n\n  * `global x` in a nested scope is now a syntax error if `x` is local\n    to the enclosing scope ([#7264]/[#11985]).\n\n  * The default `importall Base.Operators` is deprecated, and relying on it\n    will give a warning ([#8113]).\n\n  * `remotecall_fetch` and `fetch` now rethrow any uncaught remote exception locally as a\n    `RemoteException`. Previously they would return the remote exception object.\n    The worker pid, remote exception and remote backtrace are available in the\n    thrown `RemoteException`.\n\n  * If any of the enclosed async operations in a `@sync` block throw exceptions, they\n    are now collected in a `CompositeException` and the `CompositeException` thrown.\n\n\nCommand line option changes\n---------------------------\n\n  * The `-i` option now forces the REPL to run after loading the specified script (if any) ([#11347]).\n\n  * New option `--handle-signals={yes|no}` to disable Julia's signal handlers.\n\n  * The `--depwarn={yes|no|error}` option enables/disables syntax and method deprecation warnings,\n    or turns them into errors ([#9294]).\n\n  * Some command line options are slated for deprecation / removal\n    - `-f, --no-startup` Don't load ~/.juliarc (deprecated, use --startup-file=no)\n    - `-F` Load ~/.juliarc (deprecated, use --startup-file=yes)`\n    - `-P, --post-boot <expr>`  Evaluate <expr>, but don't disable interactive mode (deprecated, use -i -e instead)\n    - `--no-history-file`  Don't load history file (deprecated, use --history-file=no)\n\nCompiler/Runtime improvements\n-----------------------------\n\n  * Functions may be annotated with metadata (`:meta` expressions) to be used by the compiler ([#8297]).\n\n  * `@inline` before a function definition forces the compiler to inline the function ([#8297]).\n\n  * Loads from heap-allocated immutables are hoisted out of loops in more cases ([#8867]).\n\n  * Accessing fields that are always initialized no longer produces undefined checks ([#8827]).\n\n  * New generational garbage collector which greatly reduces GC overhead for many common workloads ([#5227]).\n\nLibrary improvements\n--------------------\n\n  * Build with USE_GPL_LIBS=0 to exclude all GPL libraries and code ([#10870]).\n\n  * Linear algebra\n\n    * The `LinAlg` module is now exported.\n\n    * `sparse(A)` now takes any `AbstractMatrix` A as an argument ([#10031]).\n\n    * Factorization API is now type-stable; functions dispatch on `Val{false}` or `Val{true}` instead of a boolean value ([#9575]).\n\n    * Added generic Cholesky factorization, and the Cholesky factorization is now parametrized by the matrix type ([#7236]).\n\n    * Sparse `cholfact` and `ldltfact` functions now accept a `perm` keyword\n      for user-provided permutations and a `shift` keyword to factorize\n      a shifted matrix ([#10844]).\n\n    * New `svds` function for the sparse truncated SVD ([#9425]).\n\n    * `Symmetric` and `Hermitian` immutables are now parametrized by the matrix type ([#7992]).\n\n    * New `ordschur` and `ordschur!` functions for sorting a Schur factorization by the eigenvalues ([#8467],[#9701]).\n\n    * `Givens` type doesn't have a size anymore and is no longer a subtype of `AbstractMatrix` ([#8660]).\n\n    * Large speedup in sparse `\\` and splitting of Cholesky and LDL\u1d40 factorizations into `cholfact` and `ldltfact` ([#10117]).\n\n    * Add sparse least squares to `\\` by adding `qrfact` for sparse matrices based on the SPQR library ([#10180]).\n\n    * Split `Triangular` type into `UpperTriangular`, `LowerTriangular`, `UnitUpperTriagular` and `UnitLowerTriangular` ([#9779])\n\n    * OpenBLAS 64-bit (ILP64) interface is now compiled with a `64_` suffix ([#8734]) to avoid conflicts with external libraries using a 32-bit BLAS ([#4923]).\n\n    * New `vecdot` function, analogous to `vecnorm`, for Euclidean inner products over any iterable container ([#11067]).\n\n    * `p = plan_fft(x)` and similar functions now return a `Base.DFT.Plan` object, rather\n    than an anonymous function.  Calling it via `p(x)` is deprecated in favor of\n    `p * x` or `p \\ x` (for the inverse), and it can also be used with `A_mul_B!`\n    to employ pre-allocated output arrays ([#12087]).\n\n    * `LU{T,Tridiagonal{T}}` now supports extraction of `L`, `U`, `p`, and `P` factors ([#12137]).\n\n    * Allocations in sparse matrix factorizations are now tracked by Julia's garbage collector ([#12034]).\n\n  * Strings\n\n    * NUL-terminated strings should now be passed to C via the new `Cstring` type, not `Ptr{UInt8}` or `Ptr{Cchar}`,\n      in order to check whether the string is free of NUL characters (which would cause silent truncation in C).\n      The analogous type `Cwstring` should be used for NUL-terminated `wchar_t*` strings ([#10994]).\n\n    * `graphemes(s)` returns an iterator over grapheme substrings of `s` ([#9261]).\n\n    * Character predicates such as `islower()`, `isspace()`, etc. use\n      utf8proc to provide uniform cross-platform behavior and\n      up-to-date, locale-independent support for Unicode standards\n      ([#5939]).\n\n    * `reverseind` function to convert indices in reversed strings (e.g. from\n      reversed regex searches) to indices in the original string ([#9249]).\n\n    * `charwidth(c)` and `strwidth(s)` now return up-to-date cross-platform\n      results (via utf8proc) ([#10659]): Julia now likes pizza ([#3721]), but some terminals still don't.\n\n    * `is_valid_char(c)`, (now `isvalid(Char,c)` ([#11241])), now correctly handles Unicode \"non-characters\", which are valid Unicode codepoints ([#11171]).\n\n    * Backreferences in replacement strings in calls to `replace` with a `Regex` pattern are now supported ([#11849]).\n      Use the `s` string prefix to indicate a replacement string contains a backreference. For example, `replace(\"ab\", r\"(.)(.)\", s\"\\2\\1\")` yields \"ba\".\n\n    * Capture groups in regular expressions can now be named using PCRE syntax, `(?P<group_name>...)`. Capture group matches can be accessed by name by indexing a `Match` object with the name of the group ([#11566]).\n\n    * `countlines()` now counts all lines, not just non-empty ([#11947]).\n\n  * Array and AbstractArray improvements\n\n    * New multidimensional iterators and index types for efficient iteration over `AbstractArray`s. Array iteration should generally be written as `for i in eachindex(A) ... end` rather than `for i = 1:length(A) ... end` ([#8432]).\n\n    * New implementation of SubArrays with substantial performance and functionality improvements ([#8501]).\n\n    * AbstractArray subtypes only need to implement `size` and `getindex`\n      for scalar indices to support indexing; all other indexing behaviors\n      (including logical indexing, ranges of indices, vectors, colons, etc.) are\n      implemented in default fallbacks. Similarly, they only need to implement\n      scalar `setindex!` to support all forms of indexed assingment ([#10525]).\n\n    * AbstractArrays that do not extend `similar` now return an `Array` by\n      default ([#10525]).\n\n  * Data structures\n\n    * New `sortperm!` function for pre-allocated index arrays ([#8792]).\n\n    * Switch from `O(N)` to `O(log N)` algorithm for `dequeue!(pq, key)`\n    with `PriorityQueue`. This provides major speedups for large\n    queues ([#8011]).\n\n    * `PriorityQueue` now includes the order type among its\n      parameters, `PriorityQueue{KeyType,ValueType,OrderType}`. An\n      empty queue can be constructed as `pq =\n      PriorityQueue(KeyType,ValueType)`, if you intend to use the\n      default `Forward` order, or `pq = PriorityQueue(KeyType,\n      ValueType, OrderType)` otherwise ([#8011]).\n\n    * Efficient `mean` and `median` for ranges ([#8089]).\n\n    * `deepcopy` recurses through immutable types and makes copies of their mutable fields ([#8560]).\n\n    * `copy(a::DArray)` will now make a copy of a `DArray` ([#9745]).\n\n  * New types\n\n    * Enums are now supported through the `@enum EnumName EnumValue1\n      EnumValue2` syntax. Enum member values also support abitrary\n      value assignment by the `@enum EnumName EnumValue1=1\n      EnumValue2=10 EnumValue3=20` syntax ([#10168]).\n\n    * New `Dates` module for calendar dates and other time-interval calculations ([#7654]).\n\n    * New `Nullable` type for missing data ([#8152]).\n\n    * A new `Val{T}` type allows one to dispatch on bits-type values ([#9452]).\n\n    * `linspace` now returns a `LinSpace` object which lazily computes linear interpolation of values between the start and stop values. It \"lifts\" endpoints which are approximately rational in the same manner as the `colon` operator.\n\n  * Arithmetic\n\n    * `convert` now checks for overflow when truncating integers or converting between\n    signed and unsigned ([#5413]).\n\n    * Arithmetic is type-preserving for more types; e.g. `(x::Int8) + (y::Int8)` now\n    yields an `Int8` ([#3759]).\n\n    * Reductions (e.g. `reduce`, `sum`) widen small types (integers smaller than `Int`, and `Float16`).\n\n    * Added optional rounding argument to floating-point constructors ([#8845]).\n\n    * Equality (`==`) and inequality (`<`/`<=`) comparisons are now correct\n      across all numeric types ([#9133], [#9198]).\n\n    * Rational arithmetic throws errors on overflow ([#8672]).\n\n    * Optional `log` and `log1p` functions implemented in pure Julia (experimental) ([#10008]).\n\n    * The `MathConst` type has been renamed `Irrational` ([#11922]).\n\n    * `isapprox` now has simpler and more sensible default tolerances ([#12393]), supports arrays, and has synonyms `\u2248` ([U+2248](https://www.fileformat.info/info/unicode/char/2248/index.htm), LaTeX `\\approx`) and `\u2249` ([U+2249](https://www.fileformat.info/info/unicode/char/2249/index.htm), LaTeX `\\napprox`) for `isapprox` and `!isapprox`, respectively ([#12472]).\n\n  * Numbers\n\n    * `primes` is now faster and has been extended to generate the primes in a user defined closed interval ([#12025]).\n\n    * The function `primesmask` which generates a prime sieve for a user defined closed interval is now exported ([#12025]).\n\n  * Random numbers\n\n    * Streamlined random number generation APIs [#8246].\n    The default `rand` no longer uses global state in the underlying C library,\n    dSFMT, making it closer to being thread-safe ([#8399], [#8832]).\n    All APIs can now take an `AbstractRNG` argument ([#8854], [#9065]). The seed argument to `srand` is now optional ([#8320], [#8854]).\n    The APIs accepting a range argument are extended to accept an arbitrary\n    `AbstractArray` ([#9049]).\n    Passing a range of `BigInt` to `rand` or `rand!` is now supported ([#9122]).\n    There are speed improvements across the board ([#8808], [#8941], [#8958], [#9083]).\n\n    * Significantly faster `randn` ([#9126], [#9132]).\n\n    * The `randexp` and `randexp!` functions are exported ([#9144]).\n\n  * File\n\n    * Added function `readlink` which returns the value of a symbolic link \"path\" ([#10714]).\n\n    * Added function `ismount` which checks if a directory is a mount point ([#11279]).\n\n    * The `cp` function now accepts keyword arguments `remove_destination` and `follow_symlinks` ([#10888]).\n\n    * The `mv` function now accepts keyword argument `remove_destination` ([#11145]).\n\n  * `Pipe()` creates a bidirectional I/O object that can be passed to `spawn` or `pipeline`\n    for redirecting process streams ([#12739]).\n\n  * Other improvements\n\n    * You can now tab-complete emoji via their [short names](http://www.emoji-cheat-sheet.com/), using `\\:name:<tab>` ([#10709]).\n\n    * `gc_enable` subsumes `gc_disable`, and also returns the previous GC state.\n\n    * `assert`, `@assert` now throws an `AssertionError` exception type ([#9734]).\n\n    * `@simd` now rejects invalid control flow (`@goto` / break / continue) in the inner loop body at compile time ([#8624]).\n\n    * The `machinefile` now supports a host count ([#7616]).\n\n    * `code_native` now outputs branch labels ([#8897]).\n\n    * Added `recvfrom` to get source address of UDP packets ([#9418]).\n\n    * `ClusterManager` performance improvements ([#9309]) and support for changing transports([#9434]).\n\n    * Added `Base.get_process_title` / `Base.set_process_title` ([#9957]).\n\n    * `readavailable` now returns a byte vector instead of a string.\n\n    * New `lock` and `unlock` functions, operating on `ReentrantLock`, to lock a stream during\n      concurrent writes from multiple tasks ([#10679]).\n\n    * `code_llvm` now outputs stripped IR without debug info or other attached metadata.\n      Use `code_llvm_raw` for the unstripped output ([#10747]).\n\n    * New `withenv(var=>val, ...) do ... end` function to temporarily\n      modify environment variables ([#10914]).\n\n    * New function `relpath` returns a relative filepath to path either from the current\n      directory or from an optional start directory ([#10893]).\n\n    * `mktemp` and `mktempdir` now take an optional argument to set which\n      directory the temporary file or directory is created in.\n\n    * New garbage collector tracked memory allocator functions: `jl_malloc`, `jl_calloc`,\n    `jl_realloc`, and `jl_free` with libc API ([[#12034]]).\n\n    * `mktempdir` and `mktemp` now have variants that take a function as its\n      first argument for automated clean-up ([[#9017]]).\n\nDeprecated or removed\n---------------------\n\n  * several syntax whitespace insensitivities have been deprecated ([#11891]).\n    ```julia\n     # function call\n     f (x)\n\n     # getindex\n     x [17]\n     rand(2) [1]\n\n     # function definition\n     f (x) = x^2\n     function foo (x)\n\tx^2\n     end\n    ```\n\n  * indexing with `Real`s that are not subtypes of `Integer` (`Rational`, `AbstractFloat`, etc.) has been deprecated ([#10458]).\n\n  * `push!(A)` has been deprecated, use `append!` instead of splatting arguments to `push!` ([#10400]).\n\n  * `names` for composite datatypes has been deprecated and\n    renamed to `fieldnames` ([#10332]).\n\n  * `DArray` functionality has been removed from `Base` and is now a\n    standalone package under the JuliaParallel umbrella organization ([#10333]).\n\n  * The `Graphics` module has been removed from `Base` and is now a\n    standalone package ([#10150], [#9862]).\n\n  * The `Woodbury` special matrix type has been removed from `LinAlg` ([#10024]).\n\n  * `median` and `median!` no longer accept a `checknan` keyword argument ([#8605]).\n\n  * `inf` and `nan` are now deprecated in favor of `T(Inf)` and `T(NaN)`, respectively ([#8776]).\n\n  * `oftype(T::Type, x)` is deprecated in favor of `convert(T,x)` (or `T(x)`).\n\n  * `{...}` syntax is deprecated in favor of `Any[...]` ([#8578]).\n\n  * `itrunc`, `ifloor`, `iceil` and `iround` are deprecated in favour of\n    `trunc{T<:Integer}(T,x)`, `floor{T<:Integer}(T,x)`, etc.. `trunc` is now\n    always bound-checked;`Base.unsafe_trunc` provides the old unchecked `itrunc`\n    behaviour ([#9133]).\n\n  * `squeeze` now requires that passed dimension(s) are an `Int` or tuple of `Int`s;\n    calling `squeeze` with an arbitrary iterator is deprecated ([#9271]).\n    Additionally, passed dimensions must be unique and correspond to extant\n    dimensions of the input array.\n\n  * `randbool` is deprecated. Use `rand(Bool)` to produce a random boolean value, and\n    `bitrand` to produce a random BitArray ([#9105], [#9569]).\n\n  * `beginswith` is renamed to `startswith` ([#9578]).\n\n  * `null` is renamed to `nullspace` ([#9714]).\n\n  * The operators `|>`, `.>`, `>>`, and `.>>` as used for process I/O redirection\n    are replaced with the `pipeline` function ([#5349], [#12739]).\n\n  * `flipud(A)` and `fliplr(A)` have been deprecated in favor of `flipdim(A, 1)` and\n    `flipdim(A, 2)`, respectively ([#10446]).\n\n  * Numeric conversion functions whose names are lower-case versions of type\n    names have been removed. To convert a scalar, use the type name, e.g.\n    `Int32(x)`. To convert an array to a different element type, use\n    `Array{T}(x)`, `map(T,x)`, or `round(T,x)`. To parse a string as an integer\n    or floating-point number, use `parse` ([#1470], [#6211]).\n\n  * Low-level functions from the C library and dynamic linker have been moved to\n    modules `Libc` and `Libdl`, respectively ([#10328]).\n\n  * The functions `parseint`, `parsefloat`, `float32_isvalid`,\n  `float64_isvalid`, and the string-argument `BigInt` and `BigFloat` have\n  been replaced by `parse` and `tryparse` with a type argument. The string\n  macro `big\"xx\"` can be used to construct `BigInt` and `BigFloat` literals\n  ([#3631], [#5704], [#9487], [#10543], [#10955]).\n\n  * the `--int-literals` compiler option is no longer accepted ([#9597]).\n\n  * Instead of `linrange`, use `linspace` ([#9666]).\n\n  * The functions `is_valid_char`, `is_valid_ascii`, `is_valid_utf8`, `is_valid_utf16`, and\n    `is_valid_utf32` have been replaced by generic `isvalid` methods.\n    The single argument form `isvalid(value)` can now be used for values of type `Char`, `ASCIIString`,\n    `UTF8String`, `UTF16String` and `UTF32String`.\n    The two argument form `isvalid(type, value)` can be used with the above types, with values\n    of type `Vector{UInt8}`, `Vector{UInt16}`, `Vector{UInt32}`, and `Vector{Char}` ([#11241]).\n\n  * Instead of `utf32(64,123,...)` use `utf32(UInt32[64,123,...])` ([#11379]).\n\n  * `start_timer` and `stop_timer` are replaced by `Timer` and `close`.\n\n  * The following internal julia C functions have been renamed, in order to prevent\n    potential naming conflicts with C libraries: ([#11741])\n\n    * `gc_wb*` -> `jl_gc_wb*`\n\n    * `gc_queue_root` -> `jl_gc_queue_root`\n\n    * `allocobj` -> `jl_gc_allocobj`\n\n    * `alloc_[0-3]w` -> `jl_gc_alloc_*w`\n\n    * `diff_gc_total_bytes` -> `jl_gc_diff_total_bytes`\n\n    * `sync_gc_total_bytes` -> `jl_gc_sync_total_bytes`\n\n  * `require(::AbstractString)` and `reload` (see news about addition of `compile`).\n\n  * `cartesianmap` is deprecated in favor of iterating over a `CartesianRange`\n\nJulia v0.3.0 Release Notes\n==========================\n\nNew language features\n---------------------\n\n  * Greatly enhanced performance for passing and returning `Tuple`s ([#4042]).\n\n  * `Tuple`s (of `Integer`s, `Symbol`s, or `Bool`s) can now be used as type\n    parameters ([#5164]).\n\n  * An additional default \"inner\" constructor accepting any arguments is now\n    generated. Constructors that look like `MyType(a, b) = new(a, b)` do not\n    need to be added manually ([#4026], [#7071]).\n\n  * Expanded array type hierarchy to include an abstract `DenseArray` for\n    in-memory arrays with standard strided storage ([#987], [#2345],\n    [#6212]).\n\n  * When reloading code, types whose definitions have not changed can be\n    ignored in some cases.\n\n  * Binary `~` now parses as a vararg macro call to `@~`.\n    For example `x~y~z` => `@~ x y z` ([#4882]).\n\n  * Structure fields can now be accessed by index ([#4806]).\n\n  * If a module contains a function `__init__()`, it will be called when\n    the module is first loaded, and on process startup if a pre-compiled\n    version of the module is present ([#1268]).\n\n  * Multi-line comments ([#69], [#6128]): `#= .... =#`\n\n  * `--check-bounds=yes|no` compiler option\n\n  * Unicode identifiers are normalized (NFC) so that different encodings\n    of equivalent strings are treated as the same identifier ([#5462]).\n\n  * The set of characters permitted in identifiers has been restricted based\n    on Unicode categories. Generally, punctuation, formatting and control\n    characters, and operator symbols are not allowed in identifiers.\n    Number-like characters cannot begin identifiers ([#5936]).\n\n  * Define a limited number of infix Unicode operators ([#552], [#6582]):\n\n    | Precedence class | Operators (with synonyms, if any)\n    | ---------------- | ---------------------------------\n    |   ==             |  \u2265 (>=) \u2264 (<=) \u2261 (===) \u2260 (!=) \u2262 (!==) .\u2265 (.>=) .\u2264 (.<=) .!= (.\u2260) \u2208 (`in`) \u2209 (`(x,y)->!in(x, y)`) \u220b (`(x,y)->in(y, x)`) \u220c (`(x,y)->!in(y, x)`) \u2286 (`issubset`) \u2288 (`(x,y)->!issubset(x, y)`) \u228a (`(x,y)->x\u2286y && x!=y`) |\n    |   +              | \u222a (`union`) |\n    |   *              | \u00f7 (`div`) \u22c5 (`dot`) \u00d7 (`cross`) \u2229 (`intersect`) |\n    |   unary          | \u221a \u221b |\n\n    In addition to these, many of the Unicode operator symbols are parsed\n    as infix operators and are available for user-defined methods ([#6929]).\n\n  * Improved reporting of syntax errors ([#6179])\n\n  * `break` inside a `for` loop with multiple ranges now exits the entire loop nest ([#5154])\n\n  * Local goto statements using the `@goto` and `@label` macros ([#101]).\n\nREPL improvements\n-----------------\n\n  * New native-Julia REPL implementation, eliminating many problems\n    stemming from the old GNU Readline-based REPL ([#6270]).\n\n  * Tab-substitution of LaTeX math symbols (e.g. `\\alpha` by `\u03b1`) ([#6911]).\n    This also works in IJulia and in Emacs ([#6920]).\n\n  * `workspace()` function for obtaining a fresh workspace ([#1195]).\n\nLibrary improvements\n--------------------\n\n  * `isequal` now compares all numbers by value, ignoring type ([#6624]).\n\n  * Implement limited shared-memory parallelism with `SharedArray`s ([#5380]).\n\n  * Well-behaved floating-point ranges ([#2333], [#5636]).\n    Introduced the `FloatRange` type for floating-point ranges with a step,\n    which will give intuitive/correct results for classically problematic\n    ranges like `0.1:0.1:0.3`, `0.0:0.7:2.1` or `1.0:1/49:27.0`.\n\n  * `mod2pi` function ([#4799], [#4862]).\n\n  * New functions `minmax` and `extrema` ([#5275]).\n\n  * New macros `@edit`, `@less`, `@code_typed`, `@code_lowered`, `@code_llvm` and `@code_native` that all function like `@which` ([#5832]).\n\n  * `consume(p)` extended to `consume(p, args...)`, allowing it\n    to optionally pass `args...` back to the producer ([#4775]).\n\n  * `.juliarc.jl` is now loaded for both script and REPL execution ([#5076]).\n\n  * The `Sys` module now includes convenient functions for working with\n    dynamic library handles; `Sys.dllist` will list out all paths currently\n    loaded via `dlopen`, and `Sys.dlpath` will lookup a path from a handle\n\n  * `readdlm` treats multiple whitespace characters as a single delimiter\n    by default (when no delimiter is specified). This is useful for reading\n    fixed-width or messy whitespace-delimited data ([#5403]).\n\n  * The Airy, Bessel, Hankel, and related functions (`airy*`,\n    `bessel*`, `hankel*`) now detect errors returned by the underlying\n    AMOS library, throwing an `AmosException` in that case ([#4967]).\n\n  * `methodswith` now returns an array of `Method`s ([#5464]) rather\n    than just printing its results.\n\n  * `errno([code])` function to get or set the C library's `errno`.\n\n  * `GitHub` module for interacting with the GitHub API.\n\n  * Package improvements\n\n    * Packages are now installed into `.julia/v0.3` by default (or\n      whatever the current Julia version is), so that different\n      versions of Julia can co-exist with incompatible packages.\n      Existing `.julia` installations are unaffected unless `Pkg.init()`\n      is run to re-create the package directories ([#3344], [#5737]).\n\n    * `Pkg.submit(pkg[,commit])` function to automatically submit\n      a GitHub pull request to the package author.\n\n  * Collections improvements\n\n    * `Array` assignment (e.g. `x[:] = y`) ignores singleton dimensions\n      and allows the last dimension of one side to match all trailing dimensions\n      of the other ([#4048], [#4383]).\n\n    * `Dict(kv)` constructor for any iterator on `(key,value)` pairs.\n\n    * Multi-key `Dict`s: `D[x,y...]` is now a synonym for `D[(x,y...)]`\n      for associations `D` ([#4870]).\n\n    * `push!` and `unshift!` can push multiple arguments ([#4782]).\n\n    * `writedlm` and `writecsv` now accept any iterable collection of\n      iterable rows, in addition to `AbstractArray` arguments, and the\n      `writedlm` delimiter can be any printable object (e.g. a\n      `String`) instead of just a `Char`.\n\n    * `isempty` now works for any iterable collection ([#5827]).\n\n    * `unique` now accepts an optional `dim` argument for finding\n      unique rows or columns of a matrix or regions of a\n      multidimensional array ([#5811]).\n\n  * `Number` improvements\n\n    * The `ImaginaryUnit` type no longer exists. Instead, `im` is of type\n      `Complex{Bool}`. Making this work required changing the semantics of\n      boolean multiplication to approximately, `true * x = x` and\n      `false * x = zero(x)`, which can itself be considered useful ([#5468]).\n\n    * `big` is now vectorized ([#4766])\n\n    * `nextpow` and `prevpow` now return the `a^n` values instead of the\n      exponent `n` ([#4819])\n\n    * Overflow detection in `parseint` ([#4874]).\n\n    * `rand` now supports arbitrary `Ranges` arguments ([#5059]).\n\n    * `expm1` and `log1p` now support complex arguments ([#3141]).\n\n    * Broadcasting `.//` is now included ([#7094]).\n\n    * `prevfloat` and `nextfloat` now saturate at -Inf and Inf,\n      respectively, and have otherwise been fixed to follow the IEEE-754\n      standard functions `nextDown` and `nextUp` ([#5025]).\n\n    * New function `widen` for widening numeric types and values, and `widemul`\n      for multiplying to a larger type ([#6169]).\n\n    * `polygamma`, `digamma`, and `trigamma` now accept complex\n      arguments, and `zeta(s, z)` now provides the Hurwitz zeta ([#7125]).\n\n    * Narrow integer types (< 32 bits) are promoted to `Float64` rather\n      than to `Float32` by `float(x)` ([#7390]).\n\n  * `String` improvements\n\n    * Triple-quoted regex strings, `r\"\"\"...\"\"\"` ([#4934]).\n\n    * New string type, `UTF16String` ([#4930]), constructed by\n      `utf16(s)` from another string, a `Uint16` array or pointer, or\n      a byte array (possibly prefixed by a byte-order marker to\n      indicate endian-ness).  Its data is internally `NULL`-terminated\n      for passing to C ([#7016]).\n\n    * `CharString` is renamed to `UTF32String` ([#4943]), and its data\n      is now internally `NULL`-terminated for passing to C ([#7016]).\n      `CharString(c::Char...)` is deprecated in favor of `utf32(c...)`,\n      and `utf32(s)` otherwise has functionality similar to `utf16(s)`.\n\n    * New `WString` and `wstring` synonyms for either `UTF16String`\n      and `utf16` or `UTF32String` and `utf32`, respectively, depending\n      on the width of `Cwchar_t` ([#7016]).\n\n    * `normalize_string` function to perform Unicode normalization,\n      case-folding, and other transformations ([#5576]).\n\n    * `pointer(s, i=1)` for `ByteString`, `UTF16String`, `UTF32String`,\n      and `SubString`s thereof ([#5703]).\n\n    * `bytestring` is automatically called on `String` arguments for\n      conversion to `Ptr{Uint8}` in `ccall` ([#5677]).\n\n  * Linear algebra improvements\n\n      * Balancing options for eigenvector calculations for general matrices ([#5428]).\n\n      * Mutating linear algebra functions no longer promote ([#5526]).\n\n      * `condskeel` for Skeel condition numbers ([#5726]).\n\n      * `norm(::Matrix)` no longer calculates a vector norm when the first\n        dimension is one ([#5545]); it always uses the operator (induced)\n        matrix norm.\n\n      * New `vecnorm(itr, p=2)` function that computes the norm of\n        any iterable collection of numbers as if it were a vector of\n        the same length.  This generalizes and replaces `normfro` ([#6057]),\n        and `norm` is now type-stable ([#6056]).\n\n      * New `UniformScaling` matrix type and identity `I` constant ([#5810]).\n\n      * None of the concrete matrix factorization types are exported from `Base`\n        by default anymore.\n\n    * Sparse linear algebra\n\n      * 1-d sparse `getindex` has been implemented ([#7047])\n\n      * Faster sparse `getindex` ([#7131]).\n\n      * Faster sparse `kron` ([#4958]).\n\n      * `sparse(A) \\ B` now supports a matrix `B` of right-hand sides ([#5196]).\n\n      * `eigs(A, sigma)` now uses shift-and-invert for nonzero shifts `sigma` and inverse iteration for `which=\"SM\"`. If `sigma==nothing` (the new default), computes ordinary (forward) iterations ([#5776]).\n\n      * `sprand` is faster, and whether any entry is nonzero is now determined independently with the specified probability ([#6726]).\n\n    * Dense linear algebra for special matrix types\n\n      * Interconversions between the special matrix types `Diagonal`, `Bidiagonal`,\n        `SymTridiagonal`, `Triangular`, and `Triangular`, and `Matrix` are now allowed\n        for matrices which are representable in both source and destination types ([5e3f074b]).\n\n      * Allow for addition and subtraction over mixed matrix types, automatically promoting\n        the result to the denser matrix type ([a448e080], [#5927])\n\n      * new algorithms for linear solvers and eigensystems of `Bidiagonal`\n        matrices of generic element types ([#5277])\n\n      * new algorithms for linear solvers, eigensystems and singular systems of `Diagonal`\n        matrices of generic element types ([#5263])\n\n      * new algorithms for linear solvers and eigensystems of `Triangular`\n        matrices of generic element types ([#5255])\n\n      * specialized `inv` and `det` methods for `Tridiagonal` and `SymTridiagonal`\n        based on recurrence relations between principal minors ([#5358])\n\n      * specialized `transpose`, `ctranspose`, `istril`, `istriu` methods for\n        `Triangular` ([#5255]) and `Bidiagonal` ([#5277])\n\n      * new LAPACK wrappers\n        - condition number estimate `cond(A::Triangular)` ([#5255])\n\n      * parametrize `Triangular` on matrix type ([#7064])\n\n      * Lyapunov / Sylvester solver ([#7435])\n\n      * `eigvals` for `Symmetric`, `Tridiagonal` and `Hermitian` matrices now\n        support additional method signatures: ([#3688], [#6652], [#6678], [#7647])\n        - `eigvals(M, el, eu)` finds all eigenvalues in the interval `(el, eu]`\n        - `eigvals(M, il:iu)` finds the `il`th through the `iu`th eigenvalues (in ascending order)\n\n    * Dense linear algebra for generic matrix element types\n\n      * LU factorization ([#5381] and [#5430])\n\n      * QR factorization ([#5526])\n\n  * New function `deleteat!` deletes a specified index or indices and\n    returns the updated collection\n\n  * The `setenv` function for external processes now accepts a `dir` keyword\n    argument for specifying the directory to start the child process in ([#4888]).\n\n  * Constructors for collections (`Set`, `Dict`, etc.) now generally accept a\n    single iterable argument giving the elements of the collection ([#4996], [#4871])\n\n  * Ranges and arrays with the same elements are now unequal. This allows hashing\n    and comparing ranges to be faster ([#5778]).\n\n  * Broadcasting now works on arbitrary `AbstractArrays` ([#5387])\n\n  * Reduction functions that accept a pre-allocated output array, including\n    `sum!`, `prod!`, `maximum!`, `minimum!`, `all!`, `any!` ([#6197], [#5387])\n\n  * Faster performance on `fill!` and `copy!` for array types not supporting\n    efficient linear indexing ([#5671], [#5387])\n\n  * Changes to range types ([#5585])\n\n    * `Range` is now the abstract range type, instead of `Ranges`\n\n    * New function `range` for constructing ranges by length\n\n    * `Range` is now `StepRange`, and `Range1` is now `UnitRange`. Their\n      constructors accept end points instead of lengths. Both are subtypes of a\n      new abstract type `OrdinalRange`.\n\n    * Ranges now support `BigInt` and general ordinal types.\n\n    * Very large ranges (e.g. `0:typemax(Int)`) can now be constructed, but some\n      operations (e.g. `length`) will raise an `OverflowError`.\n\n  * Extended API for `cov` and `cor`, which accept keyword arguments `vardim`,\n    `corrected`, and `mean` ([#6273])\n\n  * New functions `randsubseq` and `randsubseq!` to create a random subsequence of an array ([#6726])\n\n  * New macro `@evalpoly` for efficient inline evaluation of polynomials ([#7146]).\n\n  * The signal filtering function `filt` now accepts an optional initial filter state vector. A new in-place function `filt!` is also exported ([#7513]).\n\n  * Significantly faster `cumsum` and `cumprod` ([#7359]).\n\n  * Implement `findmin` and `findmax` over specified array dimensions ([#6716]).\n\n  * Support memory-mapping of files with offsets on Windows ([#7242]).\n\n  * Catch writes to protect memory, such as when trying to modify a mmapped file opened in read-only mode ([#3434]).\n\nEnvironment improvements\n------------------------\n\n  * New `--code-coverage` and `--track-allocation` startup features allow one to measure the number of executions or the amount of memory allocated, respectively, at each line of code ([#5423],[#7464]).\n\n  * `Profile.init` now accepts keyword arguments, and returns the current settings when no arguments are supplied ([#7365]).\n\nBuild improvements\n------------------\n\n  * Dependencies are now verified against stored MD5/SHA512 hashes, to ensure\n    that the correct file has been downloaded and was not modified ([#6773]).\n\n\nDeprecated or removed\n---------------------\n\n  * `convert(Ptr{T1}, x::Array{T2})` is now deprecated unless `T1 == T2`\n    or `T1 == Void` ([#6073]).  (You can still explicitly `convert`\n    one pointer type into another if needed.)\n\n  * `Sys.shlib_ext` has been renamed to `Sys.dlext`\n\n  * `dense` is deprecated in favor of `full` ([#4759]).\n\n  * The `Stat` type is renamed `StatStruct` ([#4670]).\n\n  * `setrounding`, `rounding` and `setrounding` now take an additional\n    argument specifying the floating point type to which they apply. The old\n    behaviour and `[get/set/with]_bigfloat_rounding` functions are deprecated ([#5007]).\n\n  * `cholpfact` and `qrpfact` are deprecated in favor of keyword arguments in\n    `cholfact(..., pivot=true)` and `qrfact(..., pivot=true)` ([#5330]).\n\n  * `symmetrize!` is deprecated in favor of `Base.LinAlg.copytri!` ([#5427]).\n\n  * `myindexes` has been renamed to `localindexes` ([#5475]).\n\n  * `factorize!` is deprecated in favor of `factorize` ([#5526]).\n\n  * `nnz` counts the number of structural nonzeros in a sparse\n    matrix. Use `countnz` for the actual number of nonzeros ([#6769]).\n\n  * `setfield` is renamed `setfield!` ([#5748]).\n\n  * `put` and `take` are renamed `put!` and `take!` ([#5511]).\n\n  * `put!` now returns its first argument, the remote reference ([#5819]).\n\n  * `read` methods that modify a passed array are now called `read!` ([#5970])\n\n  * `infs` and `nans` are deprecated in favor of the more general `fill`.\n\n  * `*` and `div` are no longer supported for `Char`.\n\n  * `Range` is renamed `StepRange` and `Range1` is renamed `UnitRange`.\n    `Ranges` is renamed `Range`.\n\n  * `bitmix` is replaced by a 2-argument form of `hash`.\n\n  * `readsfrom` and `writesto` are replaced by `open` ([#6948]).\n\n  * `insert!` now throws a `BoundsError` if\n    `index > length(collection)+1` ([#7373]).\n\n  * No longer exported from `Base`:\n    * `start_reading`, `stop_reading`, `start_watching` ([#10885]).\n\nJulia v0.2.0 Release Notes\n==========================\n\nThe 0.2 release brings improvements to many areas of Julia. Among the\nmost visible changes are support for 64-bit Windows, keyword arguments\nto functions, immutable types, a redesigned and polished package\nmanager, a multimedia interface supporting usage of Julia in IPython,\na built-in profiler, and major improvements to Julia's linear algebra,\nI/O, and parallel capabilities. These are accompanied by many other\nchanges adding new features, enhancing the library's consistency,\nimproving performance, increasing test coverage, easing installation,\nand expanding the documentation. While not part of Julia proper, the\npackage ecosystem has also grown and matured considerably since the\n0.1 release. See below for more information about the long list of\nchanges that improve Julia's usability and performance.\n\nNew language features\n---------------------\n\n  * Keyword & optional function arguments ([#485], [#1817]).\n\n  * Immutable types ([#13]).\n\n  * Triple-quoted string literals ([#70]).\n\n  * New infix operator `in` (e.g. `x in S`), and corresponding function\n    `in(x,S)`, replacing `contains(S,x)` function ([#2703]).\n\n  * New variable bindings on each for loop and comprehension iteration ([#1571]).\n    For example, before this change:\n\n        julia> map(f->f(), { ()->i for i=1:3 })\n        3-element Any Array:\n         3\n         3\n         3\n\n    and after:\n\n        julia> map(f->f(), { ()->i for i=1:3 })\n        3-element Any Array:\n         1\n         2\n         3\n\n  * Explicit relative importing ([#2375]).\n\n  * Methods can be added to functions in other modules using dot syntax,\n    as in `Foo.bar(x) = 0`.\n\n  * `import module: name1, name2, ...` ([#5214]).\n\n  * A semicolon is now allowed after an `import` or `using` statement ([#4130]).\n\n  * In an interactive session (REPL), you can use `;cmd` to run `cmd` via an interactive\n    shell. For example:\n\n        julia> ;ls\n        CONTRIBUTING.md  Makefile           VERSION      cli/       deps/   julia@\n        DISTRIBUTING.md  NEWS.md            Windows.inc  doc/       src/    usr/\n        LICENSE.md       README.md          base/        etc/       test/\n        Make.inc         README.windows.md  contrib/     examples/  tmp/\n\nNew library functions\n---------------------\n\n  * Sampling profiler ([#2597]).\n\n  * Functions for examining stages of the compiler's output:\n    `code_lowered`, `code_typed`, `code_llvm`, and `code_native`.\n\n  * Multimedia I/O API (display, writemime, etcetera) ([#3932]).\n\n  * MPFR-based `BigFloat` ([#2814]), and many new `BigFloat` operations.\n\n  * New half-precision IEEE floating-point type, `Float16` ([#3467]).\n\n  * Support for setting floating-point rounding modes ([#3149]).\n\n  * `methodswith` shows all methods with an argument of specific type.\n\n  * `mapslices` provides a general way to perform operations on slices of arrays ([#2204]).\n\n  * `repeat` function for constructing Arrays with repeated elements ([#3605]).\n\n  * `Collections.PriorityQueue` type and `Collections.heap` functions ([#2920]).\n\n  * `quadgk` 1d-integration routine ([#3140]).\n\n  * `erfinv` and `erfcinv` functions ([#2987]).\n\n  * `varm`, `stdm` ([#2265]).\n\n  * `digamma`, `invdigamma`, `trigamma` and `polygamma` for calculating derivatives of `gamma` function ([#3233]).\n\n  * `logdet` ([#3070]).\n\n  * Names for C-compatible types: `Cchar`, `Clong`, etc. ([#2370]).\n\n  * `cglobal` to access global variables ([#1815]).\n\n  * `unsafe_pointer_to_objref` ([#2468]) and `pointer_from_objref` ([#2515]).\n\n  * `readandwrite` for external processes.\n\n  * I/O functions `readbytes` and `readbytes!` ([#3878]).\n\n  * `flush_cstdio` function ([#3949]).\n\n  * ClusterManager makes it possible to support different types of compute clusters\n    ([#3649], [#4014]).\n\n  * `rmprocs` for removing processors from a parallel computing session.\n    The system can also tolerate to some extent processors that die unexpectedly\n    ([#3050]).\n\n  * `interrupt` for interrupting worker processes ([#3819]).\n\n  * `timedwait` does a polled wait for an event till a specified timeout.\n\n  * `Condition` type with `wait` and `notify` functions for `Task` synchronization.\n\n  * `versioninfo` provides detailed version information, especially useful when\n    reporting and diagnosing bugs.\n\n  * `detach` for running child processes in a separate process group.\n\n  * `setenv` for passing environment variables to child processes.\n\n  * `ifelse` eagerly-evaluated conditional function, especially useful for\n    vectorized conditionals.\n\nLibrary improvements\n--------------------\n\n  * `isequal` now returns `false` for numbers of different types.\n    This makes it much easier to define hashing for new numeric types.\n    Uses of `Dict` with numeric keys might need to change\n    to account for this increased strictness.\n\n  * A redesigned and rewritten `Pkg` system is much more robust in case of problems.\n    The basic interface to adding and removing package requirements remains the\n    same, but great deal of additional functionality for developing packages in-place\n    was added. See the new [packages chapter] in the manual for further details.\n\n  * Sorting API updates ([#3665]) \u2013 see [sorting functions].\n\n  * The `delete!(d::Dict, key)` function has been split into separate `pop!`\n    and `delete!` functions ([#3439]).\n    `pop!(d,key)` removes `key` from `d` and returns the value that was associated with it;\n    it throws an exception if `d` does not contain `key`.\n    `delete!(d,key)` removes `key` from `d` and succeeds regardless of whether `d`\n    contained `key` or not, returning `d` itself in either case.\n\n  * Linear-algebra factorization routines (`lu`, `chol`, etc.) now return\n    `Factorization` objects (and `lud`, `chold`, etc. are deprecated; [#2212]).\n\n  * A number of improvements to sparse matrix capabilities and sparse linear algebra.\n\n  * More linear algebra fixes and eigensolver hooks\n    for `SymTridiagonal`, `Tridiagonal` and `Bidiagonal` matrix types\n    ([#2606], [#2608], [#2609], [#2611], [#2678], [#2713], [#2720], [#2725]).\n\n  * Change `integer_valued`, `real_valued`, and so on to `isinteger`, `isreal`,\n    and so on, and semantics of the later are now value-based rather than type-based,\n    unlike MATLAB/Octave ([#3071]). `isbool` and `iscomplex` are eliminated in favor\n    of a general `iseltype` function.\n\n  * Transitive comparison of floats with rationals ([#3102]).\n\n  * Fast prime generation with `primes` and fast primality testing with `isprime`.\n\n  * `sum` and `cumsum` now use [pairwise summation] for better accuracy ([#4039]).\n\n  * Dot operators (`.+`, `.*` etc.) now broadcast singleton dimensions of array arguments.\n    This behavior can be applied to any function using `broadcast(f, ...)`.\n\n  * `combinations`, `permutations`, and `partitions` now return iterators instead of a task,\n    and `integer_partitions` has been renamed to `partitions` ([#3989], [#4055]).\n\n  * `isreadable`/`iswritable` methods added for more IO types ([#3872]).\n\n  * Much faster and improved `readdlm` and `writedlm` ([#3350], [#3468], [#3483]).\n\n  * Faster `matchall` ([#3719]), and various string and regex improvements.\n\n  * Documentation of advanced linear algebra features ([#2807]).\n\n  * Support optional RTLD flags in `dlopen` ([#2380]).\n\n  * `pmap` now works with any iterable collection.\n\n  * Options in `pmap` for retrying or ignoring failed tasks.\n\n  * New `sinpi(x)` and `cospi(x)` functions to compute sine and cosine of `pi*x`\n    more accurately ([#4112]).\n\n  * New implementations of elementary complex functions\n    `sqrt`, `log`, `asin`, `acos`, `atan`, `tanh`, `asinh`, `acosh`, `atanh`\n    with correct branch cuts ([#2891]).\n\n  * Improved behavior of `SubArray` ([#4412], [#4284], [#4044], [#3697], [#3790],\n    [#3148], [#2844], [#2644] and various other fixes).\n\n  * New convenience functions in graphics API.\n\n  * Improved backtraces on Windows and OS X.\n\n  * Implementation of reduction functions (including `reduce`, `mapreduce`, `sum`, `prod`,\n    `maximum`, `minimum`, `all`, and `any`) are refactored, with improved type stability,\n    efficiency, and consistency ([#6116], [#7035], [#7061], [#7106]).\n\nDeprecated or removed\n---------------------\n\n  * Methods of `min` and `max` that do reductions were renamed to\n    `minimum` and `maximum`. `min(x)` is now `minimum(x)`, and\n    `min(x,(),dim)` is now `minimum(x,dim)` ([#4235]).\n\n  * `ComplexPair` was renamed to `Complex` and made `immutable`,\n    and `Complex128` and so on are now aliases to the new `Complex` type.\n\n  * `!` was added to the name of many mutating functions,\n    e.g., `push` was renamed `push!` ([#907]).\n\n  * `ref` renamed to `getindex`, and `assign` to `setindex!` ([#1484]).\n\n  * `writeable` renamed to `writable` ([#3874]).\n\n  * `logb` and `ilogb` renamed to `exponent` ([#2516]).\n\n  * `quote_string` became a method of `repr`.\n\n  * `safe_char`, `check_ascii`, and `check_utf8` replaced by\n    `is_valid_char`, `is_valid_ascii`, and `is_valid_utf8`, respectively.\n\n  * `each_line`, `each_match`, `begins_with`, `ends_with`, `parse_float`,\n    `parse_int`, and `seek_end` replaced by: `eachline`, `eachmatch`, and so on\n    (`_` was removed) ([#1539]).\n\n  * `parse_bin(s)` replaced by `parseint(s,2)`;\n    `parse_oct(s)` replaced by `parseint(s,8)`;\n    `parse_hex(s)` replaced by `parseint(s,16)`.\n\n  * `findn_nzs` replaced by `findnz` ([#1539]).\n\n  * `DivideByZeroError` replaced by `DivideError`.\n\n  * `addprocs_ssh`, `addprocs_ssh_tunnel`, and `addprocs_local`\n    replaced by `addprocs` (with keyword options).\n\n  * `remote_call`, `remote_call_fetch`, and `remote_call_wait`\n    replaced by `remotecall`, `remotecall_fetch`, and `remotecall_wait`.\n\n  * `has` replaced by `in` for sets and by `haskey` for dictionaries.\n\n  * `diagmm` and `diagmm!` replaced by `scale` and `scale!` ([#2916]).\n\n  * `unsafe_ref` and `unsafe_assign` replaced by `unsafe_load` and `unsafe_store!`.\n\n  * `add_each!` and `del_each!` replaced by `union!` and `setdiff!`.\n\n  * `isdenormal` renamed to `issubnormal` ([#3105]).\n\n  * `expr` replaced by direct call to `Expr` constructor.\n\n  * `|`, `&`, `$`, `-`, and `~` for sets replaced by\n    `union`, `intersect`, `symdiff`, `setdiff`, and `complement` ([#3272]).\n\n  * `square` function removed.\n\n  * `pascal` function removed.\n\n  * `add` and `add!` for `Set` replaced by `push!`.\n\n  * `ls` function deprecated in favor of `readdir` or `;ls` in the REPL.\n\n  * `start_timer` now expects arguments in units of seconds, not milliseconds.\n\n  * Shell redirection operators `|`, `>`, and `<` eliminated in favor of a new\n    operator `|>` ([#3523]).\n\n  * `amap` is deprecated in favor of new `mapslices` functionality.\n\n  * The `Reverse` iterator was removed since it did not work in many cases.\n\n  * The `gcd` function now returns a non-negative value regardless of\n    the argument signs, and various other sign problems with `invmod`,\n    `lcm`, `gcdx`, and `powermod` were fixed ([#4811]).\n\nMiscellaneous changes\n---------------------\n\n  * `julia-release-*` executables renamed to `julia-*`,\n    and `libjulia-release` renamed to `libjulia` ([#4177]).\n\n  * Packages will now be installed in `.julia/vX.Y`, where\n    X.Y is the current Julia version.\n\nBugfixes and performance updates\n--------------------------------\n\nToo numerous to mention.\n\n[packages chapter]: https://docs.julialang.org/en/v1/stdlib/Pkg/\n[sorting functions]: https://docs.julialang.org/en/v1/base/sort/\n[pairwise summation]: https://en.wikipedia.org/wiki/Pairwise_summation\n[a448e080]: https://github.com/JuliaLang/julia/commit/a448e080dc736c7fb326426dfcb2528be36973d3\n[5e3f074b]: https://github.com/JuliaLang/julia/commit/5e3f074b9173044a0a4219f9b285879ff7cec041\n<!--- generated by NEWS-update.jl: -->\n[#13]: https://github.com/JuliaLang/julia/issues/13\n[#69]: https://github.com/JuliaLang/julia/issues/69\n[#70]: https://github.com/JuliaLang/julia/issues/70\n[#101]: https://github.com/JuliaLang/julia/issues/101\n[#265]: https://github.com/JuliaLang/julia/issues/265\n[#485]: https://github.com/JuliaLang/julia/issues/485\n[#550]: https://github.com/JuliaLang/julia/issues/550\n[#552]: https://github.com/JuliaLang/julia/issues/552\n[#907]: https://github.com/JuliaLang/julia/issues/907\n[#964]: https://github.com/JuliaLang/julia/issues/964\n[#987]: https://github.com/JuliaLang/julia/issues/987\n[#1090]: https://github.com/JuliaLang/julia/issues/1090\n[#1195]: https://github.com/JuliaLang/julia/issues/1195\n[#1268]: https://github.com/JuliaLang/julia/issues/1268\n[#1470]: https://github.com/JuliaLang/julia/issues/1470\n[#1484]: https://github.com/JuliaLang/julia/issues/1484\n[#1539]: https://github.com/JuliaLang/julia/issues/1539\n[#1571]: https://github.com/JuliaLang/julia/issues/1571\n[#1815]: https://github.com/JuliaLang/julia/issues/1815\n[#1817]: https://github.com/JuliaLang/julia/issues/1817\n[#2204]: https://github.com/JuliaLang/julia/issues/2204\n[#2212]: https://github.com/JuliaLang/julia/issues/2212\n[#2265]: https://github.com/JuliaLang/julia/issues/2265\n[#2333]: https://github.com/JuliaLang/julia/issues/2333\n[#2345]: https://github.com/JuliaLang/julia/issues/2345\n[#2370]: https://github.com/JuliaLang/julia/issues/2370\n[#2375]: https://github.com/JuliaLang/julia/issues/2375\n[#2380]: https://github.com/JuliaLang/julia/issues/2380\n[#2403]: https://github.com/JuliaLang/julia/issues/2403\n[#2468]: https://github.com/JuliaLang/julia/issues/2468\n[#2488]: https://github.com/JuliaLang/julia/issues/2488\n[#2515]: https://github.com/JuliaLang/julia/issues/2515\n[#2516]: https://github.com/JuliaLang/julia/issues/2516\n[#2597]: https://github.com/JuliaLang/julia/issues/2597\n[#2606]: https://github.com/JuliaLang/julia/issues/2606\n[#2608]: https://github.com/JuliaLang/julia/issues/2608\n[#2609]: https://github.com/JuliaLang/julia/issues/2609\n[#2611]: https://github.com/JuliaLang/julia/issues/2611\n[#2644]: https://github.com/JuliaLang/julia/issues/2644\n[#2678]: https://github.com/JuliaLang/julia/issues/2678\n[#2703]: https://github.com/JuliaLang/julia/issues/2703\n[#2713]: https://github.com/JuliaLang/julia/issues/2713\n[#2720]: https://github.com/JuliaLang/julia/issues/2720\n[#2725]: https://github.com/JuliaLang/julia/issues/2725\n[#2807]: https://github.com/JuliaLang/julia/issues/2807\n[#2814]: https://github.com/JuliaLang/julia/issues/2814\n[#2844]: https://github.com/JuliaLang/julia/issues/2844\n[#2891]: https://github.com/JuliaLang/julia/issues/2891\n[#2916]: https://github.com/JuliaLang/julia/issues/2916\n[#2920]: https://github.com/JuliaLang/julia/issues/2920\n[#2987]: https://github.com/JuliaLang/julia/issues/2987\n[#3050]: https://github.com/JuliaLang/julia/issues/3050\n[#3070]: https://github.com/JuliaLang/julia/issues/3070\n[#3071]: https://github.com/JuliaLang/julia/issues/3071\n[#3102]: https://github.com/JuliaLang/julia/issues/3102\n[#3105]: https://github.com/JuliaLang/julia/issues/3105\n[#3140]: https://github.com/JuliaLang/julia/issues/3140\n[#3141]: https://github.com/JuliaLang/julia/issues/3141\n[#3148]: https://github.com/JuliaLang/julia/issues/3148\n[#3149]: https://github.com/JuliaLang/julia/issues/3149\n[#3214]: https://github.com/JuliaLang/julia/issues/3214\n[#3233]: https://github.com/JuliaLang/julia/issues/3233\n[#3272]: https://github.com/JuliaLang/julia/issues/3272\n[#3344]: https://github.com/JuliaLang/julia/issues/3344\n[#3350]: https://github.com/JuliaLang/julia/issues/3350\n[#3434]: https://github.com/JuliaLang/julia/issues/3434\n[#3439]: https://github.com/JuliaLang/julia/issues/3439\n[#3467]: https://github.com/JuliaLang/julia/issues/3467\n[#3468]: https://github.com/JuliaLang/julia/issues/3468\n[#3483]: https://github.com/JuliaLang/julia/issues/3483\n[#3523]: https://github.com/JuliaLang/julia/issues/3523\n[#3605]: https://github.com/JuliaLang/julia/issues/3605\n[#3631]: https://github.com/JuliaLang/julia/issues/3631\n[#3649]: https://github.com/JuliaLang/julia/issues/3649\n[#3665]: https://github.com/JuliaLang/julia/issues/3665\n[#3688]: https://github.com/JuliaLang/julia/issues/3688\n[#3697]: https://github.com/JuliaLang/julia/issues/3697\n[#3719]: https://github.com/JuliaLang/julia/issues/3719\n[#3721]: https://github.com/JuliaLang/julia/issues/3721\n[#3737]: https://github.com/JuliaLang/julia/issues/3737\n[#3759]: https://github.com/JuliaLang/julia/issues/3759\n[#3790]: https://github.com/JuliaLang/julia/issues/3790\n[#3819]: https://github.com/JuliaLang/julia/issues/3819\n[#3872]: https://github.com/JuliaLang/julia/issues/3872\n[#3874]: https://github.com/JuliaLang/julia/issues/3874\n[#3878]: https://github.com/JuliaLang/julia/issues/3878\n[#3932]: https://github.com/JuliaLang/julia/issues/3932\n[#3949]: https://github.com/JuliaLang/julia/issues/3949\n[#3989]: https://github.com/JuliaLang/julia/issues/3989\n[#4014]: https://github.com/JuliaLang/julia/issues/4014\n[#4026]: https://github.com/JuliaLang/julia/issues/4026\n[#4039]: https://github.com/JuliaLang/julia/issues/4039\n[#4042]: https://github.com/JuliaLang/julia/issues/4042\n[#4044]: https://github.com/JuliaLang/julia/issues/4044\n[#4048]: https://github.com/JuliaLang/julia/issues/4048\n[#4055]: https://github.com/JuliaLang/julia/issues/4055\n[#4112]: https://github.com/JuliaLang/julia/issues/4112\n[#4130]: https://github.com/JuliaLang/julia/issues/4130\n[#4163]: https://github.com/JuliaLang/julia/issues/4163\n[#4177]: https://github.com/JuliaLang/julia/issues/4177\n[#4211]: https://github.com/JuliaLang/julia/issues/4211\n[#4235]: https://github.com/JuliaLang/julia/issues/4235\n[#4284]: https://github.com/JuliaLang/julia/issues/4284\n[#4383]: https://github.com/JuliaLang/julia/issues/4383\n[#4412]: https://github.com/JuliaLang/julia/issues/4412\n[#4470]: https://github.com/JuliaLang/julia/issues/4470\n[#4615]: https://github.com/JuliaLang/julia/issues/4615\n[#4670]: https://github.com/JuliaLang/julia/issues/4670\n[#4759]: https://github.com/JuliaLang/julia/issues/4759\n[#4766]: https://github.com/JuliaLang/julia/issues/4766\n[#4775]: https://github.com/JuliaLang/julia/issues/4775\n[#4782]: https://github.com/JuliaLang/julia/issues/4782\n[#4799]: https://github.com/JuliaLang/julia/issues/4799\n[#4806]: https://github.com/JuliaLang/julia/issues/4806\n[#4811]: https://github.com/JuliaLang/julia/issues/4811\n[#4819]: https://github.com/JuliaLang/julia/issues/4819\n[#4862]: https://github.com/JuliaLang/julia/issues/4862\n[#4867]: https://github.com/JuliaLang/julia/issues/4867\n[#4870]: https://github.com/JuliaLang/julia/issues/4870\n[#4871]: https://github.com/JuliaLang/julia/issues/4871\n[#4874]: https://github.com/JuliaLang/julia/issues/4874\n[#4882]: https://github.com/JuliaLang/julia/issues/4882\n[#4888]: https://github.com/JuliaLang/julia/issues/4888\n[#4923]: https://github.com/JuliaLang/julia/issues/4923\n[#4930]: https://github.com/JuliaLang/julia/issues/4930\n[#4934]: https://github.com/JuliaLang/julia/issues/4934\n[#4943]: https://github.com/JuliaLang/julia/issues/4943\n[#4958]: https://github.com/JuliaLang/julia/issues/4958\n[#4967]: https://github.com/JuliaLang/julia/issues/4967\n[#4996]: https://github.com/JuliaLang/julia/issues/4996\n[#5007]: https://github.com/JuliaLang/julia/issues/5007\n[#5025]: https://github.com/JuliaLang/julia/issues/5025\n[#5059]: https://github.com/JuliaLang/julia/issues/5059\n[#5076]: https://github.com/JuliaLang/julia/issues/5076\n[#5154]: https://github.com/JuliaLang/julia/issues/5154\n[#5164]: https://github.com/JuliaLang/julia/issues/5164\n[#5196]: https://github.com/JuliaLang/julia/issues/5196\n[#5214]: https://github.com/JuliaLang/julia/issues/5214\n[#5227]: https://github.com/JuliaLang/julia/issues/5227\n[#5255]: https://github.com/JuliaLang/julia/issues/5255\n[#5263]: https://github.com/JuliaLang/julia/issues/5263\n[#5275]: https://github.com/JuliaLang/julia/issues/5275\n[#5277]: https://github.com/JuliaLang/julia/issues/5277\n[#5330]: https://github.com/JuliaLang/julia/issues/5330\n[#5349]: https://github.com/JuliaLang/julia/issues/5349\n[#5358]: https://github.com/JuliaLang/julia/issues/5358\n[#5380]: https://github.com/JuliaLang/julia/issues/5380\n[#5381]: https://github.com/JuliaLang/julia/issues/5381\n[#5387]: https://github.com/JuliaLang/julia/issues/5387\n[#5403]: https://github.com/JuliaLang/julia/issues/5403\n[#5413]: https://github.com/JuliaLang/julia/issues/5413\n[#5423]: https://github.com/JuliaLang/julia/issues/5423\n[#5427]: https://github.com/JuliaLang/julia/issues/5427\n[#5428]: https://github.com/JuliaLang/julia/issues/5428\n[#5430]: https://github.com/JuliaLang/julia/issues/5430\n[#5462]: https://github.com/JuliaLang/julia/issues/5462\n[#5464]: https://github.com/JuliaLang/julia/issues/5464\n[#5468]: https://github.com/JuliaLang/julia/issues/5468\n[#5475]: https://github.com/JuliaLang/julia/issues/5475\n[#5511]: https://github.com/JuliaLang/julia/issues/5511\n[#5526]: https://github.com/JuliaLang/julia/issues/5526\n[#5545]: https://github.com/JuliaLang/julia/issues/5545\n[#5576]: https://github.com/JuliaLang/julia/issues/5576\n[#5585]: https://github.com/JuliaLang/julia/issues/5585\n[#5636]: https://github.com/JuliaLang/julia/issues/5636\n[#5671]: https://github.com/JuliaLang/julia/issues/5671\n[#5677]: https://github.com/JuliaLang/julia/issues/5677\n[#5703]: https://github.com/JuliaLang/julia/issues/5703\n[#5704]: https://github.com/JuliaLang/julia/issues/5704\n[#5726]: https://github.com/JuliaLang/julia/issues/5726\n[#5737]: https://github.com/JuliaLang/julia/issues/5737\n[#5748]: https://github.com/JuliaLang/julia/issues/5748\n[#5776]: https://github.com/JuliaLang/julia/issues/5776\n[#5778]: https://github.com/JuliaLang/julia/issues/5778\n[#5810]: https://github.com/JuliaLang/julia/issues/5810\n[#5811]: https://github.com/JuliaLang/julia/issues/5811\n[#5819]: https://github.com/JuliaLang/julia/issues/5819\n[#5827]: https://github.com/JuliaLang/julia/issues/5827\n[#5832]: https://github.com/JuliaLang/julia/issues/5832\n[#5927]: https://github.com/JuliaLang/julia/issues/5927\n[#5936]: https://github.com/JuliaLang/julia/issues/5936\n[#5939]: https://github.com/JuliaLang/julia/issues/5939\n[#5970]: https://github.com/JuliaLang/julia/issues/5970\n[#6056]: https://github.com/JuliaLang/julia/issues/6056\n[#6057]: https://github.com/JuliaLang/julia/issues/6057\n[#6073]: https://github.com/JuliaLang/julia/issues/6073\n[#6081]: https://github.com/JuliaLang/julia/issues/6081\n[#6116]: https://github.com/JuliaLang/julia/issues/6116\n[#6128]: https://github.com/JuliaLang/julia/issues/6128\n[#6169]: https://github.com/JuliaLang/julia/issues/6169\n[#6179]: https://github.com/JuliaLang/julia/issues/6179\n[#6190]: https://github.com/JuliaLang/julia/issues/6190\n[#6197]: https://github.com/JuliaLang/julia/issues/6197\n[#6211]: https://github.com/JuliaLang/julia/issues/6211\n[#6212]: https://github.com/JuliaLang/julia/issues/6212\n[#6270]: https://github.com/JuliaLang/julia/issues/6270\n[#6273]: https://github.com/JuliaLang/julia/issues/6273\n[#6582]: https://github.com/JuliaLang/julia/issues/6582\n[#6624]: https://github.com/JuliaLang/julia/issues/6624\n[#6652]: https://github.com/JuliaLang/julia/issues/6652\n[#6678]: https://github.com/JuliaLang/julia/issues/6678\n[#6716]: https://github.com/JuliaLang/julia/issues/6716\n[#6726]: https://github.com/JuliaLang/julia/issues/6726\n[#6739]: https://github.com/JuliaLang/julia/issues/6739\n[#6769]: https://github.com/JuliaLang/julia/issues/6769\n[#6773]: https://github.com/JuliaLang/julia/issues/6773\n[#6842]: https://github.com/JuliaLang/julia/issues/6842\n[#6911]: https://github.com/JuliaLang/julia/issues/6911\n[#6920]: https://github.com/JuliaLang/julia/issues/6920\n[#6929]: https://github.com/JuliaLang/julia/issues/6929\n[#6948]: https://github.com/JuliaLang/julia/issues/6948\n[#7016]: https://github.com/JuliaLang/julia/issues/7016\n[#7035]: https://github.com/JuliaLang/julia/issues/7035\n[#7047]: https://github.com/JuliaLang/julia/issues/7047\n[#7061]: https://github.com/JuliaLang/julia/issues/7061\n[#7064]: https://github.com/JuliaLang/julia/issues/7064\n[#7071]: https://github.com/JuliaLang/julia/issues/7071\n[#7094]: https://github.com/JuliaLang/julia/issues/7094\n[#7106]: https://github.com/JuliaLang/julia/issues/7106\n[#7125]: https://github.com/JuliaLang/julia/issues/7125\n[#7131]: https://github.com/JuliaLang/julia/issues/7131\n[#7146]: https://github.com/JuliaLang/julia/issues/7146\n[#7234]: https://github.com/JuliaLang/julia/issues/7234\n[#7236]: https://github.com/JuliaLang/julia/issues/7236\n[#7242]: https://github.com/JuliaLang/julia/issues/7242\n[#7258]: https://github.com/JuliaLang/julia/issues/7258\n[#7264]: https://github.com/JuliaLang/julia/issues/7264\n[#7311]: https://github.com/JuliaLang/julia/issues/7311\n[#7359]: https://github.com/JuliaLang/julia/issues/7359\n[#7365]: https://github.com/JuliaLang/julia/issues/7365\n[#7373]: https://github.com/JuliaLang/julia/issues/7373\n[#7390]: https://github.com/JuliaLang/julia/issues/7390\n[#7435]: https://github.com/JuliaLang/julia/issues/7435\n[#7464]: https://github.com/JuliaLang/julia/issues/7464\n[#7513]: https://github.com/JuliaLang/julia/issues/7513\n[#7616]: https://github.com/JuliaLang/julia/issues/7616\n[#7647]: https://github.com/JuliaLang/julia/issues/7647\n[#7654]: https://github.com/JuliaLang/julia/issues/7654\n[#7669]: https://github.com/JuliaLang/julia/issues/7669\n[#7704]: https://github.com/JuliaLang/julia/issues/7704\n[#7917]: https://github.com/JuliaLang/julia/issues/7917\n[#7992]: https://github.com/JuliaLang/julia/issues/7992\n[#8011]: https://github.com/JuliaLang/julia/issues/8011\n[#8036]: https://github.com/JuliaLang/julia/issues/8036\n[#8089]: https://github.com/JuliaLang/julia/issues/8089\n[#8113]: https://github.com/JuliaLang/julia/issues/8113\n[#8135]: https://github.com/JuliaLang/julia/issues/8135\n[#8152]: https://github.com/JuliaLang/julia/issues/8152\n[#8246]: https://github.com/JuliaLang/julia/issues/8246\n[#8283]: https://github.com/JuliaLang/julia/issues/8283\n[#8297]: https://github.com/JuliaLang/julia/issues/8297\n[#8320]: https://github.com/JuliaLang/julia/issues/8320\n[#8399]: https://github.com/JuliaLang/julia/issues/8399\n[#8423]: https://github.com/JuliaLang/julia/issues/8423\n[#8432]: https://github.com/JuliaLang/julia/issues/8432\n[#8467]: https://github.com/JuliaLang/julia/issues/8467\n[#8501]: https://github.com/JuliaLang/julia/issues/8501\n[#8560]: https://github.com/JuliaLang/julia/issues/8560\n[#8578]: https://github.com/JuliaLang/julia/issues/8578\n[#8599]: https://github.com/JuliaLang/julia/issues/8599\n[#8605]: https://github.com/JuliaLang/julia/issues/8605\n[#8624]: https://github.com/JuliaLang/julia/issues/8624\n[#8660]: https://github.com/JuliaLang/julia/issues/8660\n[#8672]: https://github.com/JuliaLang/julia/issues/8672\n[#8712]: https://github.com/JuliaLang/julia/issues/8712\n[#8734]: https://github.com/JuliaLang/julia/issues/8734\n[#8745]: https://github.com/JuliaLang/julia/issues/8745\n[#8750]: https://github.com/JuliaLang/julia/issues/8750\n[#8776]: https://github.com/JuliaLang/julia/issues/8776\n[#8791]: https://github.com/JuliaLang/julia/issues/8791\n[#8792]: https://github.com/JuliaLang/julia/issues/8792\n[#8808]: https://github.com/JuliaLang/julia/issues/8808\n[#8814]: https://github.com/JuliaLang/julia/issues/8814\n[#8816]: https://github.com/JuliaLang/julia/issues/8816\n[#8827]: https://github.com/JuliaLang/julia/issues/8827\n[#8832]: https://github.com/JuliaLang/julia/issues/8832\n[#8845]: https://github.com/JuliaLang/julia/issues/8845\n[#8846]: https://github.com/JuliaLang/julia/issues/8846\n[#8854]: https://github.com/JuliaLang/julia/issues/8854\n[#8867]: https://github.com/JuliaLang/julia/issues/8867\n[#8872]: https://github.com/JuliaLang/julia/issues/8872\n[#8897]: https://github.com/JuliaLang/julia/issues/8897\n[#8905]: https://github.com/JuliaLang/julia/issues/8905\n[#8941]: https://github.com/JuliaLang/julia/issues/8941\n[#8958]: https://github.com/JuliaLang/julia/issues/8958\n[#8974]: https://github.com/JuliaLang/julia/issues/8974\n[#9017]: https://github.com/JuliaLang/julia/issues/9017\n[#9049]: https://github.com/JuliaLang/julia/issues/9049\n[#9065]: https://github.com/JuliaLang/julia/issues/9065\n[#9083]: https://github.com/JuliaLang/julia/issues/9083\n[#9105]: https://github.com/JuliaLang/julia/issues/9105\n[#9122]: https://github.com/JuliaLang/julia/issues/9122\n[#9126]: https://github.com/JuliaLang/julia/issues/9126\n[#9132]: https://github.com/JuliaLang/julia/issues/9132\n[#9133]: https://github.com/JuliaLang/julia/issues/9133\n[#9144]: https://github.com/JuliaLang/julia/issues/9144\n[#9198]: https://github.com/JuliaLang/julia/issues/9198\n[#9249]: https://github.com/JuliaLang/julia/issues/9249\n[#9261]: https://github.com/JuliaLang/julia/issues/9261\n[#9271]: https://github.com/JuliaLang/julia/issues/9271\n[#9294]: https://github.com/JuliaLang/julia/issues/9294\n[#9309]: https://github.com/JuliaLang/julia/issues/9309\n[#9343]: https://github.com/JuliaLang/julia/issues/9343\n[#9418]: https://github.com/JuliaLang/julia/issues/9418\n[#9425]: https://github.com/JuliaLang/julia/issues/9425\n[#9434]: https://github.com/JuliaLang/julia/issues/9434\n[#9452]: https://github.com/JuliaLang/julia/issues/9452\n[#9482]: https://github.com/JuliaLang/julia/issues/9482\n[#9487]: https://github.com/JuliaLang/julia/issues/9487\n[#9503]: https://github.com/JuliaLang/julia/issues/9503\n[#9569]: https://github.com/JuliaLang/julia/issues/9569\n[#9575]: https://github.com/JuliaLang/julia/issues/9575\n[#9578]: https://github.com/JuliaLang/julia/issues/9578\n[#9597]: https://github.com/JuliaLang/julia/issues/9597\n[#9627]: https://github.com/JuliaLang/julia/issues/9627\n[#9666]: https://github.com/JuliaLang/julia/issues/9666\n[#9690]: https://github.com/JuliaLang/julia/issues/9690\n[#9701]: https://github.com/JuliaLang/julia/issues/9701\n[#9714]: https://github.com/JuliaLang/julia/issues/9714\n[#9734]: https://github.com/JuliaLang/julia/issues/9734\n[#9745]: https://github.com/JuliaLang/julia/issues/9745\n[#9779]: https://github.com/JuliaLang/julia/issues/9779\n[#9862]: https://github.com/JuliaLang/julia/issues/9862\n[#9957]: https://github.com/JuliaLang/julia/issues/9957\n[#10008]: https://github.com/JuliaLang/julia/issues/10008\n[#10024]: https://github.com/JuliaLang/julia/issues/10024\n[#10031]: https://github.com/JuliaLang/julia/issues/10031\n[#10075]: https://github.com/JuliaLang/julia/issues/10075\n[#10117]: https://github.com/JuliaLang/julia/issues/10117\n[#10150]: https://github.com/JuliaLang/julia/issues/10150\n[#10168]: https://github.com/JuliaLang/julia/issues/10168\n[#10180]: https://github.com/JuliaLang/julia/issues/10180\n[#10228]: https://github.com/JuliaLang/julia/issues/10228\n[#10328]: https://github.com/JuliaLang/julia/issues/10328\n[#10331]: https://github.com/JuliaLang/julia/issues/10331\n[#10332]: https://github.com/JuliaLang/julia/issues/10332\n[#10333]: https://github.com/JuliaLang/julia/issues/10333\n[#10380]: https://github.com/JuliaLang/julia/issues/10380\n[#10400]: https://github.com/JuliaLang/julia/issues/10400\n[#10446]: https://github.com/JuliaLang/julia/issues/10446\n[#10458]: https://github.com/JuliaLang/julia/issues/10458\n[#10472]: https://github.com/JuliaLang/julia/issues/10472\n[#10525]: https://github.com/JuliaLang/julia/issues/10525\n[#10543]: https://github.com/JuliaLang/julia/issues/10543\n[#10548]: https://github.com/JuliaLang/julia/issues/10548\n[#10659]: https://github.com/JuliaLang/julia/issues/10659\n[#10679]: https://github.com/JuliaLang/julia/issues/10679\n[#10709]: https://github.com/JuliaLang/julia/issues/10709\n[#10714]: https://github.com/JuliaLang/julia/issues/10714\n[#10747]: https://github.com/JuliaLang/julia/issues/10747\n[#10844]: https://github.com/JuliaLang/julia/issues/10844\n[#10870]: https://github.com/JuliaLang/julia/issues/10870\n[#10885]: https://github.com/JuliaLang/julia/issues/10885\n[#10888]: https://github.com/JuliaLang/julia/issues/10888\n[#10893]: https://github.com/JuliaLang/julia/issues/10893\n[#10914]: https://github.com/JuliaLang/julia/issues/10914\n[#10946]: https://github.com/JuliaLang/julia/issues/10946\n[#10955]: https://github.com/JuliaLang/julia/issues/10955\n[#10994]: https://github.com/JuliaLang/julia/issues/10994\n[#11030]: https://github.com/JuliaLang/julia/issues/11030\n[#11067]: https://github.com/JuliaLang/julia/issues/11067\n[#11105]: https://github.com/JuliaLang/julia/issues/11105\n[#11145]: https://github.com/JuliaLang/julia/issues/11145\n[#11171]: https://github.com/JuliaLang/julia/issues/11171\n[#11196]: https://github.com/JuliaLang/julia/issues/11196\n[#11241]: https://github.com/JuliaLang/julia/issues/11241\n[#11242]: https://github.com/JuliaLang/julia/issues/11242\n[#11250]: https://github.com/JuliaLang/julia/issues/11250\n[#11279]: https://github.com/JuliaLang/julia/issues/11279\n[#11310]: https://github.com/JuliaLang/julia/issues/11310\n[#11347]: https://github.com/JuliaLang/julia/issues/11347\n[#11379]: https://github.com/JuliaLang/julia/issues/11379\n[#11432]: https://github.com/JuliaLang/julia/issues/11432\n[#11566]: https://github.com/JuliaLang/julia/issues/11566\n[#11686]: https://github.com/JuliaLang/julia/issues/11686\n[#11688]: https://github.com/JuliaLang/julia/issues/11688\n[#11741]: https://github.com/JuliaLang/julia/issues/11741\n[#11849]: https://github.com/JuliaLang/julia/issues/11849\n[#11891]: https://github.com/JuliaLang/julia/issues/11891\n[#11922]: https://github.com/JuliaLang/julia/issues/11922\n[#11947]: https://github.com/JuliaLang/julia/issues/11947\n[#11985]: https://github.com/JuliaLang/julia/issues/11985\n[#12025]: https://github.com/JuliaLang/julia/issues/12025\n[#12031]: https://github.com/JuliaLang/julia/issues/12031\n[#12034]: https://github.com/JuliaLang/julia/issues/12034\n[#12087]: https://github.com/JuliaLang/julia/issues/12087\n[#12137]: https://github.com/JuliaLang/julia/issues/12137\n[#12162]: https://github.com/JuliaLang/julia/issues/12162\n[#12231]: https://github.com/JuliaLang/julia/issues/12231\n[#12264]: https://github.com/JuliaLang/julia/issues/12264\n[#12274]: https://github.com/JuliaLang/julia/issues/12274\n[#12385]: https://github.com/JuliaLang/julia/issues/12385\n[#12393]: https://github.com/JuliaLang/julia/issues/12393\n[#12458]: https://github.com/JuliaLang/julia/issues/12458\n[#12472]: https://github.com/JuliaLang/julia/issues/12472\n[#12491]: https://github.com/JuliaLang/julia/issues/12491\n[#12563]: https://github.com/JuliaLang/julia/issues/12563\n[#12576]: https://github.com/JuliaLang/julia/issues/12576\n[#12727]: https://github.com/JuliaLang/julia/issues/12727\n[#12739]: https://github.com/JuliaLang/julia/issues/12739\n[#12819]: https://github.com/JuliaLang/julia/issues/12819\n[#12872]: https://github.com/JuliaLang/julia/issues/12872\n[#13062]: https://github.com/JuliaLang/julia/issues/13062\n[#13171]: https://github.com/JuliaLang/julia/issues/13171\n[#13232]: https://github.com/JuliaLang/julia/issues/13232\n[#13338]: https://github.com/JuliaLang/julia/issues/13338\n[#13387]: https://github.com/JuliaLang/julia/issues/13387\n[#13412]: https://github.com/JuliaLang/julia/issues/13412\n[#13440]: https://github.com/JuliaLang/julia/issues/13440\n[#13465]: https://github.com/JuliaLang/julia/issues/13465\n[#13480]: https://github.com/JuliaLang/julia/issues/13480\n[#13496]: https://github.com/JuliaLang/julia/issues/13496\n[#13542]: https://github.com/JuliaLang/julia/issues/13542\n[#13612]: https://github.com/JuliaLang/julia/issues/13612\n[#13680]: https://github.com/JuliaLang/julia/issues/13680\n[#13681]: https://github.com/JuliaLang/julia/issues/13681\n[#13707]: https://github.com/JuliaLang/julia/issues/13707\n[#13774]: https://github.com/JuliaLang/julia/issues/13774\n[#13780]: https://github.com/JuliaLang/julia/issues/13780\n[#13824]: https://github.com/JuliaLang/julia/issues/13824\n[#13825]: https://github.com/JuliaLang/julia/issues/13825\n[#13897]: https://github.com/JuliaLang/julia/issues/13897\n[#14052]: https://github.com/JuliaLang/julia/issues/14052\n[#14114]: https://github.com/JuliaLang/julia/issues/14114\n[#14140]: https://github.com/JuliaLang/julia/issues/14140\n[#14194]: https://github.com/JuliaLang/julia/issues/14194\n[#14243]: https://github.com/JuliaLang/julia/issues/14243\n[#14335]: https://github.com/JuliaLang/julia/issues/14335\n[#14413]: https://github.com/JuliaLang/julia/issues/14413\n[#14424]: https://github.com/JuliaLang/julia/issues/14424\n[#14458]: https://github.com/JuliaLang/julia/issues/14458\n[#14469]: https://github.com/JuliaLang/julia/issues/14469\n[#14474]: https://github.com/JuliaLang/julia/issues/14474\n[#14519]: https://github.com/JuliaLang/julia/issues/14519\n[#14608]: https://github.com/JuliaLang/julia/issues/14608\n[#14623]: https://github.com/JuliaLang/julia/issues/14623\n[#14660]: https://github.com/JuliaLang/julia/issues/14660\n[#14676]: https://github.com/JuliaLang/julia/issues/14676\n[#14759]: https://github.com/JuliaLang/julia/issues/14759\n[#14777]: https://github.com/JuliaLang/julia/issues/14777\n[#14798]: https://github.com/JuliaLang/julia/issues/14798\n[#15007]: https://github.com/JuliaLang/julia/issues/15007\n[#15032]: https://github.com/JuliaLang/julia/issues/15032\n[#15172]: https://github.com/JuliaLang/julia/issues/15172\n[#15192]: https://github.com/JuliaLang/julia/issues/15192\n[#15242]: https://github.com/JuliaLang/julia/issues/15242\n[#15244]: https://github.com/JuliaLang/julia/issues/15244\n[#15258]: https://github.com/JuliaLang/julia/issues/15258\n[#15409]: https://github.com/JuliaLang/julia/issues/15409\n[#15431]: https://github.com/JuliaLang/julia/issues/15431\n[#15524]: https://github.com/JuliaLang/julia/issues/15524\n[#15550]: https://github.com/JuliaLang/julia/issues/15550\n[#15609]: https://github.com/JuliaLang/julia/issues/15609\n[#15708]: https://github.com/JuliaLang/julia/issues/15708\n[#15731]: https://github.com/JuliaLang/julia/issues/15731\n[#15763]: https://github.com/JuliaLang/julia/issues/15763\n[#15804]: https://github.com/JuliaLang/julia/issues/15804\n[#15850]: https://github.com/JuliaLang/julia/issues/15850\n[#15975]: https://github.com/JuliaLang/julia/issues/15975\n[#16010]: https://github.com/JuliaLang/julia/issues/16010\n[#16024]: https://github.com/JuliaLang/julia/issues/16024\n[#16058]: https://github.com/JuliaLang/julia/issues/16058\n[#16071]: https://github.com/JuliaLang/julia/issues/16071\n[#16098]: https://github.com/JuliaLang/julia/issues/16098\n[#16107]: https://github.com/JuliaLang/julia/issues/16107\n[#16154]: https://github.com/JuliaLang/julia/issues/16154\n[#16213]: https://github.com/JuliaLang/julia/issues/16213\n[#16219]: https://github.com/JuliaLang/julia/issues/16219\n[#16260]: https://github.com/JuliaLang/julia/issues/16260\n[#16285]: https://github.com/JuliaLang/julia/issues/16285\n[#16362]: https://github.com/JuliaLang/julia/issues/16362\n[#16378]: https://github.com/JuliaLang/julia/issues/16378\n[#16403]: https://github.com/JuliaLang/julia/issues/16403\n[#16404]: https://github.com/JuliaLang/julia/issues/16404\n[#16450]: https://github.com/JuliaLang/julia/issues/16450\n[#16455]: https://github.com/JuliaLang/julia/issues/16455\n[#16466]: https://github.com/JuliaLang/julia/issues/16466\n[#16481]: https://github.com/JuliaLang/julia/issues/16481\n[#16502]: https://github.com/JuliaLang/julia/issues/16502\n[#16510]: https://github.com/JuliaLang/julia/issues/16510\n[#16600]: https://github.com/JuliaLang/julia/issues/16600\n[#16603]: https://github.com/JuliaLang/julia/issues/16603\n[#16621]: https://github.com/JuliaLang/julia/issues/16621\n[#16622]: https://github.com/JuliaLang/julia/issues/16622\n[#16645]: https://github.com/JuliaLang/julia/issues/16645\n[#16663]: https://github.com/JuliaLang/julia/issues/16663\n[#16731]: https://github.com/JuliaLang/julia/issues/16731\n[#16854]: https://github.com/JuliaLang/julia/issues/16854\n[#16953]: https://github.com/JuliaLang/julia/issues/16953\n[#16961]: https://github.com/JuliaLang/julia/issues/16961\n[#16972]: https://github.com/JuliaLang/julia/issues/16972\n[#16984]: https://github.com/JuliaLang/julia/issues/16984\n[#16986]: https://github.com/JuliaLang/julia/issues/16986\n[#17033]: https://github.com/JuliaLang/julia/issues/17033\n[#17037]: https://github.com/JuliaLang/julia/issues/17037\n[#17057]: https://github.com/JuliaLang/julia/issues/17057\n[#17075]: https://github.com/JuliaLang/julia/issues/17075\n[#17132]: https://github.com/JuliaLang/julia/issues/17132\n[#17155]: https://github.com/JuliaLang/julia/issues/17155\n[#17261]: https://github.com/JuliaLang/julia/issues/17261\n[#17265]: https://github.com/JuliaLang/julia/issues/17265\n[#17266]: https://github.com/JuliaLang/julia/issues/17266\n[#17300]: https://github.com/JuliaLang/julia/issues/17300\n[#17302]: https://github.com/JuliaLang/julia/issues/17302\n[#17323]: https://github.com/JuliaLang/julia/issues/17323\n[#17374]: https://github.com/JuliaLang/julia/issues/17374\n[#17393]: https://github.com/JuliaLang/julia/issues/17393\n[#17402]: https://github.com/JuliaLang/julia/issues/17402\n[#17404]: https://github.com/JuliaLang/julia/issues/17404\n[#17510]: https://github.com/JuliaLang/julia/issues/17510\n[#17546]: https://github.com/JuliaLang/julia/issues/17546\n[#17599]: https://github.com/JuliaLang/julia/issues/17599\n[#17607]: https://github.com/JuliaLang/julia/issues/17607\n[#17623]: https://github.com/JuliaLang/julia/issues/17623\n[#17654]: https://github.com/JuliaLang/julia/issues/17654\n[#17668]: https://github.com/JuliaLang/julia/issues/17668\n[#17723]: https://github.com/JuliaLang/julia/issues/17723\n[#17758]: https://github.com/JuliaLang/julia/issues/17758\n[#17785]: https://github.com/JuliaLang/julia/issues/17785\n[#18012]: https://github.com/JuliaLang/julia/issues/18012\n[#18050]: https://github.com/JuliaLang/julia/issues/18050\n[#18159]: https://github.com/JuliaLang/julia/issues/18159\n[#18218]: https://github.com/JuliaLang/julia/issues/18218\n[#18251]: https://github.com/JuliaLang/julia/issues/18251\n[#18330]: https://github.com/JuliaLang/julia/issues/18330\n[#18339]: https://github.com/JuliaLang/julia/issues/18339\n[#18342]: https://github.com/JuliaLang/julia/issues/18342\n[#18346]: https://github.com/JuliaLang/julia/issues/18346\n[#18441]: https://github.com/JuliaLang/julia/issues/18441\n[#18442]: https://github.com/JuliaLang/julia/issues/18442\n[#18444]: https://github.com/JuliaLang/julia/issues/18444\n[#18453]: https://github.com/JuliaLang/julia/issues/18453\n[#18457]: https://github.com/JuliaLang/julia/issues/18457\n[#18473]: https://github.com/JuliaLang/julia/issues/18473\n[#18558]: https://github.com/JuliaLang/julia/issues/18558\n[#18628]: https://github.com/JuliaLang/julia/issues/18628\n[#18642]: https://github.com/JuliaLang/julia/issues/18642\n[#18644]: https://github.com/JuliaLang/julia/issues/18644\n[#18660]: https://github.com/JuliaLang/julia/issues/18660\n[#18690]: https://github.com/JuliaLang/julia/issues/18690\n[#18754]: https://github.com/JuliaLang/julia/issues/18754\n[#18777]: https://github.com/JuliaLang/julia/issues/18777\n[#18832]: https://github.com/JuliaLang/julia/issues/18832\n[#18839]: https://github.com/JuliaLang/julia/issues/18839\n[#18891]: https://github.com/JuliaLang/julia/issues/18891\n[#18931]: https://github.com/JuliaLang/julia/issues/18931\n[#18965]: https://github.com/JuliaLang/julia/issues/18965\n[#18977]: https://github.com/JuliaLang/julia/issues/18977\n[#19018]: https://github.com/JuliaLang/julia/issues/19018\n[#19088]: https://github.com/JuliaLang/julia/issues/19088\n[#19157]: https://github.com/JuliaLang/julia/issues/19157\n[#19233]: https://github.com/JuliaLang/julia/issues/19233\n[#19239]: https://github.com/JuliaLang/julia/issues/19239\n[#19246]: https://github.com/JuliaLang/julia/issues/19246\n[#19259]: https://github.com/JuliaLang/julia/issues/19259\n[#19288]: https://github.com/JuliaLang/julia/issues/19288\n[#19305]: https://github.com/JuliaLang/julia/issues/19305\n[#19331]: https://github.com/JuliaLang/julia/issues/19331\n[#19371]: https://github.com/JuliaLang/julia/issues/19371\n[#19438]: https://github.com/JuliaLang/julia/issues/19438\n[#19449]: https://github.com/JuliaLang/julia/issues/19449\n[#19464]: https://github.com/JuliaLang/julia/issues/19464\n[#19469]: https://github.com/JuliaLang/julia/issues/19469\n[#19518]: https://github.com/JuliaLang/julia/issues/19518\n[#19533]: https://github.com/JuliaLang/julia/issues/19533\n[#19543]: https://github.com/JuliaLang/julia/issues/19543\n[#19594]: https://github.com/JuliaLang/julia/issues/19594\n[#19598]: https://github.com/JuliaLang/julia/issues/19598\n[#19635]: https://github.com/JuliaLang/julia/issues/19635\n[#19636]: https://github.com/JuliaLang/julia/issues/19636\n[#19660]: https://github.com/JuliaLang/julia/issues/19660\n[#19669]: https://github.com/JuliaLang/julia/issues/19669\n[#19670]: https://github.com/JuliaLang/julia/issues/19670\n[#19677]: https://github.com/JuliaLang/julia/issues/19677\n[#19680]: https://github.com/JuliaLang/julia/issues/19680\n[#19690]: https://github.com/JuliaLang/julia/issues/19690\n[#19692]: https://github.com/JuliaLang/julia/issues/19692\n[#19711]: https://github.com/JuliaLang/julia/issues/19711\n[#19712]: https://github.com/JuliaLang/julia/issues/19712\n[#19720]: https://github.com/JuliaLang/julia/issues/19720\n[#19721]: https://github.com/JuliaLang/julia/issues/19721\n[#19722]: https://github.com/JuliaLang/julia/issues/19722\n[#19724]: https://github.com/JuliaLang/julia/issues/19724\n[#19730]: https://github.com/JuliaLang/julia/issues/19730\n[#19737]: https://github.com/JuliaLang/julia/issues/19737\n[#19741]: https://github.com/JuliaLang/julia/issues/19741\n[#19766]: https://github.com/JuliaLang/julia/issues/19766\n[#19771]: https://github.com/JuliaLang/julia/issues/19771\n[#19779]: https://github.com/JuliaLang/julia/issues/19779\n[#19784]: https://github.com/JuliaLang/julia/issues/19784\n[#19786]: https://github.com/JuliaLang/julia/issues/19786\n[#19787]: https://github.com/JuliaLang/julia/issues/19787\n[#19791]: https://github.com/JuliaLang/julia/issues/19791\n[#19800]: https://github.com/JuliaLang/julia/issues/19800\n[#19802]: https://github.com/JuliaLang/julia/issues/19802\n[#19811]: https://github.com/JuliaLang/julia/issues/19811\n[#19814]: https://github.com/JuliaLang/julia/issues/19814\n[#19841]: https://github.com/JuliaLang/julia/issues/19841\n[#19878]: https://github.com/JuliaLang/julia/issues/19878\n[#19900]: https://github.com/JuliaLang/julia/issues/19900\n[#19901]: https://github.com/JuliaLang/julia/issues/19901\n[#19903]: https://github.com/JuliaLang/julia/issues/19903\n[#19919]: https://github.com/JuliaLang/julia/issues/19919\n[#19920]: https://github.com/JuliaLang/julia/issues/19920\n[#19925]: https://github.com/JuliaLang/julia/issues/19925\n[#19926]: https://github.com/JuliaLang/julia/issues/19926\n[#19931]: https://github.com/JuliaLang/julia/issues/19931\n[#19934]: https://github.com/JuliaLang/julia/issues/19934\n[#19935]: https://github.com/JuliaLang/julia/issues/19935\n[#19937]: https://github.com/JuliaLang/julia/issues/19937\n[#19944]: https://github.com/JuliaLang/julia/issues/19944\n[#19949]: https://github.com/JuliaLang/julia/issues/19949\n[#19950]: https://github.com/JuliaLang/julia/issues/19950\n[#19989]: https://github.com/JuliaLang/julia/issues/19989\n[#20009]: https://github.com/JuliaLang/julia/issues/20009\n[#20047]: https://github.com/JuliaLang/julia/issues/20047\n[#20058]: https://github.com/JuliaLang/julia/issues/20058\n[#20079]: https://github.com/JuliaLang/julia/issues/20079\n[#20135]: https://github.com/JuliaLang/julia/issues/20135\n[#20164]: https://github.com/JuliaLang/julia/issues/20164\n[#20213]: https://github.com/JuliaLang/julia/issues/20213\n[#20228]: https://github.com/JuliaLang/julia/issues/20228\n[#20248]: https://github.com/JuliaLang/julia/issues/20248\n[#20249]: https://github.com/JuliaLang/julia/issues/20249\n[#20268]: https://github.com/JuliaLang/julia/issues/20268\n[#20308]: https://github.com/JuliaLang/julia/issues/20308\n[#20321]: https://github.com/JuliaLang/julia/issues/20321\n[#20327]: https://github.com/JuliaLang/julia/issues/20327\n[#20328]: https://github.com/JuliaLang/julia/issues/20328\n[#20330]: https://github.com/JuliaLang/julia/issues/20330\n[#20342]: https://github.com/JuliaLang/julia/issues/20342\n[#20345]: https://github.com/JuliaLang/julia/issues/20345\n[#20403]: https://github.com/JuliaLang/julia/issues/20403\n[#20404]: https://github.com/JuliaLang/julia/issues/20404\n[#20406]: https://github.com/JuliaLang/julia/issues/20406\n[#20414]: https://github.com/JuliaLang/julia/issues/20414\n[#20418]: https://github.com/JuliaLang/julia/issues/20418\n[#20427]: https://github.com/JuliaLang/julia/issues/20427\n[#20435]: https://github.com/JuliaLang/julia/issues/20435\n[#20500]: https://github.com/JuliaLang/julia/issues/20500\n[#20530]: https://github.com/JuliaLang/julia/issues/20530\n[#20543]: https://github.com/JuliaLang/julia/issues/20543\n[#20609]: https://github.com/JuliaLang/julia/issues/20609\n[#20889]: https://github.com/JuliaLang/julia/issues/20889\n[#20952]: https://github.com/JuliaLang/julia/issues/20952\n[#21183]: https://github.com/JuliaLang/julia/issues/21183\n[#21818]: https://github.com/JuliaLang/julia/issues/21818\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/cli/loader_lib.c": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n// This file defines an RPATH-style relative path loader for all platforms\n#include \"loader.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Bring in definitions of symbols exported from libjulia. */\n#include \"jl_exports.h\"\n\n/* Bring in helper functions for windows without libgcc. */\n#ifdef _OS_WINDOWS_\n#include \"loader_win_utils.c\"\n#endif\n\n// Save DEP_LIBS to a variable that is explicitly sized for expansion\nstatic char dep_libs[512] = DEP_LIBS;\n\nJL_DLLEXPORT void jl_loader_print_stderr(const char * msg)\n{\n    fputs(msg, stderr);\n}\n// I use three arguments a lot.\nvoid jl_loader_print_stderr3(const char * msg1, const char * msg2, const char * msg3)\n{\n    jl_loader_print_stderr(msg1);\n    jl_loader_print_stderr(msg2);\n    jl_loader_print_stderr(msg3);\n}\n\n/* Wrapper around dlopen(), with extra relative pathing thrown in*/\nstatic void * load_library(const char * rel_path, const char * src_dir) {\n    char path[2*PATH_MAX + 1] = {0};\n    strncat(path, src_dir, sizeof(path) - 1);\n    strncat(path, PATHSEPSTRING, sizeof(path) - 1);\n    strncat(path, rel_path, sizeof(path) - 1);\n\n    void * handle = NULL;\n#if defined(_OS_WINDOWS_)\n    wchar_t wpath[2*PATH_MAX + 1] = {0};\n    if (!utf8_to_wchar(path, wpath, 2*PATH_MAX)) {\n        jl_loader_print_stderr3(\"ERROR: Unable to convert path \", path, \" to wide string!\\n\");\n        exit(1);\n    }\n    handle = (void *)LoadLibraryExW(wpath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n#else\n    handle = dlopen(path, RTLD_NOW | RTLD_GLOBAL);\n#endif\n\n    if (handle == NULL) {\n        jl_loader_print_stderr3(\"ERROR: Unable to load dependent library \", path, \"\\n\");\n#if defined(_OS_WINDOWS_)\n        LPWSTR wmsg = TEXT(\"\");\n        FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                       FORMAT_MESSAGE_FROM_SYSTEM |\n                       FORMAT_MESSAGE_IGNORE_INSERTS |\n                       FORMAT_MESSAGE_MAX_WIDTH_MASK,\n                       NULL, GetLastError(),\n                       MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),\n                       (LPWSTR)&wmsg, 0, NULL);\n        char err[256] = {0};\n        wchar_to_utf8(wmsg, err, 255);\n        jl_loader_print_stderr3(\"Message:\", err, \"\\n\");\n#else\n        jl_loader_print_stderr3(\"Message:\", dlerror(), \"\\n\");\n#endif\n        exit(1);\n    }\n    return handle;\n}\n\nstatic void * lookup_symbol(const void * lib_handle, const char * symbol_name) {\n#ifdef _OS_WINDOWS_\n    return GetProcAddress((HMODULE) lib_handle, symbol_name);\n#else\n    return dlsym((void *)lib_handle, symbol_name);\n#endif\n}\n\n// Find the location of libjulia.\nchar lib_dir[PATH_MAX];\nJL_DLLEXPORT const char * jl_get_libdir()\n{\n    // Reuse the path if this is not the first call.\n    if (lib_dir[0] != 0) {\n        return lib_dir;\n    }\n#if defined(_OS_WINDOWS_)\n    // On Windows, we use GetModuleFileNameW\n    wchar_t libjulia_path[PATH_MAX];\n    HMODULE libjulia = NULL;\n\n    // Get a handle to libjulia.\n    if (!utf8_to_wchar(LIBJULIA_NAME, libjulia_path, PATH_MAX)) {\n        jl_loader_print_stderr3(\"ERROR: Unable to convert path \", LIBJULIA_NAME, \" to wide string!\\n\");\n        exit(1);\n    }\n    libjulia = LoadLibraryW(libjulia_path);\n    if (libjulia == NULL) {\n        jl_loader_print_stderr3(\"ERROR: Unable to load \", LIBJULIA_NAME, \"!\\n\");\n        exit(1);\n    }\n    if (!GetModuleFileNameW(libjulia, libjulia_path, PATH_MAX)) {\n        jl_loader_print_stderr(\"ERROR: GetModuleFileName() failed\\n\");\n        exit(1);\n    }\n    if (!wchar_to_utf8(libjulia_path, lib_dir, PATH_MAX)) {\n        jl_loader_print_stderr(\"ERROR: Unable to convert julia path to UTF-8\\n\");\n        exit(1);\n    }\n#else\n    // On all other platforms, use dladdr()\n    Dl_info info;\n    if (!dladdr(&jl_get_libdir, &info)) {\n        jl_loader_print_stderr(\"ERROR: Unable to dladdr(&jl_get_libdir)!\\n\");\n        jl_loader_print_stderr3(\"Message:\", dlerror(), \"\\n\");\n        exit(1);\n    }\n    strcpy(lib_dir, info.dli_fname);\n#endif\n    // Finally, convert to dirname\n    const char * new_dir = dirname(lib_dir);\n    if (new_dir != lib_dir) {\n        // On some platforms, dirname() mutates.  On others, it does not.\n        memcpy(lib_dir, new_dir, strlen(new_dir)+1);\n    }\n    return lib_dir;\n}\n\nvoid * libjulia_internal = NULL;\n__attribute__((constructor)) void jl_load_libjulia_internal(void) {\n    // Only initalize this once\n    if (libjulia_internal != NULL) {\n        return;\n    }\n\n    // Introspect to find our own path\n    const char * lib_dir = jl_get_libdir();\n\n    // Pre-load libraries that libjulia-internal needs.\n    int deps_len = strlen(dep_libs);\n    char * curr_dep = &dep_libs[0];\n    while (1) {\n        // try to find next colon character, if we can't, escape out.\n        char * colon = strchr(curr_dep, ':');\n        if (colon == NULL)\n            break;\n\n        // Chop the string at the colon, load this library.\n        *colon = '\\0';\n        load_library(curr_dep, lib_dir);\n\n        // Skip ahead to next dependency\n        curr_dep = colon + 1;\n    }\n\n    // Last dependency is `libjulia-internal`, so load that and we're done with `dep_libs`!\n    libjulia_internal = load_library(curr_dep, lib_dir);\n\n    // Once we have libjulia-internal loaded, re-export its symbols:\n    for (unsigned int symbol_idx=0; jl_exported_func_names[symbol_idx] != NULL; ++symbol_idx) {\n        (*jl_exported_func_addrs[symbol_idx]) = lookup_symbol(libjulia_internal, jl_exported_func_names[symbol_idx]);\n    }\n}\n\n// Load libjulia and run the REPL with the given arguments (in UTF-8 format)\nJL_DLLEXPORT int jl_load_repl(int argc, char * argv[]) {\n    // Some compilers/platforms are known to have `__attribute__((constructor))` issues,\n    // so we have a fallback call of `jl_load_libjulia_internal()` here.\n    if (libjulia_internal == NULL) {\n        jl_load_libjulia_internal();\n        if (libjulia_internal == NULL) {\n            jl_loader_print_stderr(\"ERROR: libjulia-internal could not be loaded!\\n\");\n            exit(1);\n        }\n    }\n    // Next, if we're on Linux/FreeBSD, set up fast TLS.\n#if !defined(_OS_WINDOWS_) && !defined(_OS_DARWIN_)\n    void (*jl_set_ptls_states_getter)(void *) = lookup_symbol(libjulia_internal, \"jl_set_ptls_states_getter\");\n    if (jl_set_ptls_states_getter == NULL) {\n        jl_loader_print_stderr(\"ERROR: Cannot find jl_set_ptls_states_getter() function within libjulia-internal!\\n\");\n        exit(1);\n    }\n    void * (*fptr)(void) = lookup_symbol(RTLD_DEFAULT, \"jl_get_ptls_states_static\");\n    if (fptr == NULL) {\n        jl_loader_print_stderr(\"ERROR: Cannot find jl_get_ptls_states_static(), must define this symbol within calling executable!\\n\");\n        exit(1);\n    }\n    jl_set_ptls_states_getter((void *)fptr);\n#endif\n\n    // Load the repl entrypoint symbol and jump into it!\n    int (*entrypoint)(int, char **) = (int (*)(int, char **))lookup_symbol(libjulia_internal, \"repl_entrypoint\");\n    if (entrypoint == NULL) {\n        jl_loader_print_stderr(\"ERROR: Unable to find `repl_entrypoint()` within libjulia-internal!\\n\");\n        exit(1);\n    }\n    return entrypoint(argc, (char **)argv);\n}\n\n#ifdef _OS_WINDOWS_\nint __stdcall DllMainCRTStartup(void* instance, unsigned reason, void* reserved) {\n    setup_stdio();\n\n    // Because we override DllMainCRTStartup, we have to manually call our constructor methods\n    jl_load_libjulia_internal();\n    return 1;\n}\n#endif\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/staticdata.c": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n/*\n  saving and restoring system images\n*/\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h> // printf\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"builtin_proto.h\"\n#include \"processor.h\"\n\n#ifndef _OS_WINDOWS_\n#include <dlfcn.h>\n#endif\n\n#ifndef _COMPILER_MICROSOFT_\n#include \"valgrind.h\"\n#else\n#define RUNNING_ON_VALGRIND 0\n#endif\n#include \"julia_assert.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// TODO: put WeakRefs on the weak_refs list during deserialization\n// TODO: handle finalizers\n\n#define NUM_TAGS    146\n\n// An array of references that need to be restored from the sysimg\n// This is a manually constructed dual of the gvars array, which would be produced by codegen for Julia code, for C.\njl_value_t **const*const get_tags(void) {\n    // Make sure to keep an extra slot at the end to sentinel length\n    static void * _tags[NUM_TAGS] = {NULL};\n\n    // Lazyily-initialize this list\n    if (_tags[0] == NULL) {\n        unsigned int i = 0;\n#define INSERT_TAG(sym) _tags[i++] = &(sym)\n        // builtin types\n        INSERT_TAG(jl_any_type);\n        INSERT_TAG(jl_symbol_type);\n        INSERT_TAG(jl_ssavalue_type);\n        INSERT_TAG(jl_datatype_type);\n        INSERT_TAG(jl_slotnumber_type);\n        INSERT_TAG(jl_simplevector_type);\n        INSERT_TAG(jl_array_type);\n        INSERT_TAG(jl_typedslot_type);\n        INSERT_TAG(jl_expr_type);\n        INSERT_TAG(jl_globalref_type);\n        INSERT_TAG(jl_string_type);\n        INSERT_TAG(jl_module_type);\n        INSERT_TAG(jl_tvar_type);\n        INSERT_TAG(jl_method_instance_type);\n        INSERT_TAG(jl_method_type);\n        INSERT_TAG(jl_code_instance_type);\n        INSERT_TAG(jl_linenumbernode_type);\n        INSERT_TAG(jl_lineinfonode_type);\n        INSERT_TAG(jl_gotonode_type);\n        INSERT_TAG(jl_quotenode_type);\n        INSERT_TAG(jl_gotoifnot_type);\n        INSERT_TAG(jl_argument_type);\n        INSERT_TAG(jl_returnnode_type);\n        INSERT_TAG(jl_const_type);\n        INSERT_TAG(jl_partial_struct_type);\n        INSERT_TAG(jl_partial_opaque_type);\n        INSERT_TAG(jl_method_match_type);\n        INSERT_TAG(jl_pinode_type);\n        INSERT_TAG(jl_phinode_type);\n        INSERT_TAG(jl_phicnode_type);\n        INSERT_TAG(jl_upsilonnode_type);\n        INSERT_TAG(jl_type_type);\n        INSERT_TAG(jl_bottom_type);\n        INSERT_TAG(jl_ref_type);\n        INSERT_TAG(jl_pointer_type);\n        INSERT_TAG(jl_llvmpointer_type);\n        INSERT_TAG(jl_vararg_type);\n        INSERT_TAG(jl_abstractarray_type);\n        INSERT_TAG(jl_densearray_type);\n        INSERT_TAG(jl_nothing_type);\n        INSERT_TAG(jl_function_type);\n        INSERT_TAG(jl_typeofbottom_type);\n        INSERT_TAG(jl_unionall_type);\n        INSERT_TAG(jl_typename_type);\n        INSERT_TAG(jl_builtin_type);\n        INSERT_TAG(jl_code_info_type);\n        INSERT_TAG(jl_opaque_closure_type);\n        INSERT_TAG(jl_task_type);\n        INSERT_TAG(jl_uniontype_type);\n        INSERT_TAG(jl_abstractstring_type);\n        INSERT_TAG(jl_array_any_type);\n        INSERT_TAG(jl_intrinsic_type);\n        INSERT_TAG(jl_abstractslot_type);\n        INSERT_TAG(jl_methtable_type);\n        INSERT_TAG(jl_typemap_level_type);\n        INSERT_TAG(jl_typemap_entry_type);\n        INSERT_TAG(jl_voidpointer_type);\n        INSERT_TAG(jl_uint8pointer_type);\n        INSERT_TAG(jl_newvarnode_type);\n        INSERT_TAG(jl_anytuple_type_type);\n        INSERT_TAG(jl_anytuple_type);\n        INSERT_TAG(jl_namedtuple_type);\n        INSERT_TAG(jl_emptytuple_type);\n        INSERT_TAG(jl_array_symbol_type);\n        INSERT_TAG(jl_array_uint8_type);\n        INSERT_TAG(jl_array_int32_type);\n        INSERT_TAG(jl_int32_type);\n        INSERT_TAG(jl_int64_type);\n        INSERT_TAG(jl_bool_type);\n        INSERT_TAG(jl_uint8_type);\n        INSERT_TAG(jl_uint32_type);\n        INSERT_TAG(jl_uint64_type);\n        INSERT_TAG(jl_char_type);\n        INSERT_TAG(jl_weakref_type);\n        INSERT_TAG(jl_int8_type);\n        INSERT_TAG(jl_int16_type);\n        INSERT_TAG(jl_uint16_type);\n        INSERT_TAG(jl_float16_type);\n        INSERT_TAG(jl_float32_type);\n        INSERT_TAG(jl_float64_type);\n        INSERT_TAG(jl_floatingpoint_type);\n        INSERT_TAG(jl_number_type);\n        INSERT_TAG(jl_signed_type);\n\n        // special typenames\n        INSERT_TAG(jl_tuple_typename);\n        INSERT_TAG(jl_pointer_typename);\n        INSERT_TAG(jl_llvmpointer_typename);\n        INSERT_TAG(jl_array_typename);\n        INSERT_TAG(jl_type_typename);\n        INSERT_TAG(jl_namedtuple_typename);\n        INSERT_TAG(jl_vecelement_typename);\n        INSERT_TAG(jl_opaque_closure_typename);\n\n        // special exceptions\n        INSERT_TAG(jl_errorexception_type);\n        INSERT_TAG(jl_argumenterror_type);\n        INSERT_TAG(jl_typeerror_type);\n        INSERT_TAG(jl_methoderror_type);\n        INSERT_TAG(jl_loaderror_type);\n        INSERT_TAG(jl_initerror_type);\n        INSERT_TAG(jl_undefvarerror_type);\n        INSERT_TAG(jl_stackovf_exception);\n        INSERT_TAG(jl_diverror_exception);\n        INSERT_TAG(jl_interrupt_exception);\n        INSERT_TAG(jl_boundserror_type);\n        INSERT_TAG(jl_memory_exception);\n        INSERT_TAG(jl_undefref_exception);\n        INSERT_TAG(jl_readonlymemory_exception);\n\n        // other special values\n        INSERT_TAG(jl_emptysvec);\n        INSERT_TAG(jl_emptytuple);\n        INSERT_TAG(jl_false);\n        INSERT_TAG(jl_true);\n        INSERT_TAG(jl_nothing);\n        INSERT_TAG(jl_an_empty_string);\n        INSERT_TAG(jl_an_empty_vec_any);\n        INSERT_TAG(jl_module_init_order);\n        INSERT_TAG(jl_core_module);\n        INSERT_TAG(jl_base_module);\n        INSERT_TAG(jl_main_module);\n        INSERT_TAG(jl_top_module);\n        INSERT_TAG(jl_typeinf_func);\n        INSERT_TAG(jl_type_type_mt);\n        INSERT_TAG(jl_nonfunction_mt);\n\n        // some Core.Builtin Functions that we want to be able to reference:\n        INSERT_TAG(jl_builtin_throw);\n        INSERT_TAG(jl_builtin_is);\n        INSERT_TAG(jl_builtin_typeof);\n        INSERT_TAG(jl_builtin_sizeof);\n        INSERT_TAG(jl_builtin_issubtype);\n        INSERT_TAG(jl_builtin_isa);\n        INSERT_TAG(jl_builtin_typeassert);\n        INSERT_TAG(jl_builtin__apply_iterate);\n        INSERT_TAG(jl_builtin_isdefined);\n        INSERT_TAG(jl_builtin_nfields);\n        INSERT_TAG(jl_builtin_tuple);\n        INSERT_TAG(jl_builtin_svec);\n        INSERT_TAG(jl_builtin_getfield);\n        INSERT_TAG(jl_builtin_setfield);\n        INSERT_TAG(jl_builtin_fieldtype);\n        INSERT_TAG(jl_builtin_arrayref);\n        INSERT_TAG(jl_builtin_const_arrayref);\n        INSERT_TAG(jl_builtin_arrayset);\n        INSERT_TAG(jl_builtin_arraysize);\n        INSERT_TAG(jl_builtin_apply_type);\n        INSERT_TAG(jl_builtin_applicable);\n        INSERT_TAG(jl_builtin_invoke);\n        INSERT_TAG(jl_builtin__expr);\n        INSERT_TAG(jl_builtin_ifelse);\n        INSERT_TAG(jl_builtin__typebody);\n\n        // All optional tags must be placed at the end, so that we\n        // don't accidentally have a `NULL` in the middle\n#ifdef SEGV_EXCEPTION\n        INSERT_TAG(jl_segv_exception);\n#endif\n#undef INSERT_TAG\n        assert(i >= (NUM_TAGS-2) && i < NUM_TAGS);\n    }\n    return (jl_value_t**const*const) _tags;\n}\n\n// hash of definitions for predefined tagged object\nstatic htable_t symbol_table;\nstatic uintptr_t nsym_tag;\n// array of definitions for the predefined tagged object types\n// (reverse of symbol_table)\nstatic arraylist_t deser_sym;\n\n// table of all objects that are serialized\nstatic htable_t backref_table;\nstatic int backref_table_numel;\nstatic arraylist_t layout_table;\n\n// list of (size_t pos, (void *f)(jl_value_t*)) entries\n// for the serializer to mark values in need of rework by function f\n// during deserialization later\nstatic arraylist_t reinit_list;\n\n// @ccallable entry points to install\nstatic arraylist_t ccallable_list;\n\n// hash of definitions for predefined function pointers\nstatic htable_t fptr_to_id;\nvoid *native_functions;\n\n// array of definitions for the predefined function pointers\n// (reverse of fptr_to_id)\n// This is a manually constructed dual of the fvars array, which would be produced by codegen for Julia code, for C.\nstatic const jl_fptr_args_t id_to_fptrs[] = {\n    &jl_f_throw, &jl_f_is, &jl_f_typeof, &jl_f_issubtype, &jl_f_isa,\n    &jl_f_typeassert, &jl_f__apply_iterate, &jl_f__apply_pure,\n    &jl_f__call_latest, &jl_f__call_in_world, &jl_f_isdefined,\n    &jl_f_tuple, &jl_f_svec, &jl_f_intrinsic_call, &jl_f_invoke_kwsorter,\n    &jl_f_getfield, &jl_f_setfield, &jl_f_fieldtype, &jl_f_nfields,\n    &jl_f_arrayref, &jl_f_const_arrayref, &jl_f_arrayset, &jl_f_arraysize, &jl_f_apply_type,\n    &jl_f_applicable, &jl_f_invoke, &jl_f_sizeof, &jl_f__expr, &jl_f__typevar,\n    &jl_f_ifelse, &jl_f__structtype, &jl_f__abstracttype, &jl_f__primitivetype,\n    &jl_f__typebody, &jl_f__setsuper, &jl_f__equiv_typedef, &jl_f_opaque_closure_call,\n    NULL };\n\ntypedef struct {\n    ios_t *s;\n    ios_t *const_data;\n    ios_t *symbols;\n    ios_t *relocs;\n    ios_t *gvar_record;\n    ios_t *fptr_record;\n    arraylist_t relocs_list;\n    arraylist_t gctags_list;\n    jl_ptls_t ptls;\n} jl_serializer_state;\n\nstatic jl_value_t *jl_idtable_type = NULL;\nstatic jl_typename_t *jl_idtable_typename = NULL;\nstatic jl_value_t *jl_bigint_type = NULL;\nstatic int gmp_limb_size = 0;\n\nenum RefTags {\n    DataRef,\n    ConstDataRef,\n    TagRef,\n    SymbolRef,\n    BindingRef,\n    FunctionRef,\n    BuiltinFunctionRef\n};\n\n// calling conventions for internal entry points.\n// this is used to set the method-instance->invoke field\ntypedef enum {\n    JL_API_NULL,\n    JL_API_BOXED,\n    JL_API_CONST,\n    JL_API_WITH_PARAMETERS,\n    JL_API_INTERPRETED,\n    JL_API_BUILTIN,\n    JL_API_MAX\n} jl_callingconv_t;\n\n\n// this supports up to 8 RefTags, 512MB of pointer data, and 4/2 (64/32-bit) GB of constant data.\n// if a larger size is required, will need to add support for writing larger relocations in many cases below\n#define RELOC_TAG_OFFSET 29\n\n\n/* read and write in host byte order */\n\n#define write_uint8(s, n) ios_putc((n), (s))\n#define read_uint8(s) ((uint8_t)ios_getc((s)))\n\nstatic void write_uint32(ios_t *s, uint32_t i) JL_NOTSAFEPOINT\n{\n    ios_write(s, (char*)&i, 4);\n}\n\nstatic uint32_t read_uint32(ios_t *s) JL_NOTSAFEPOINT\n{\n    uint32_t x = 0;\n    ios_read(s, (char*)&x, 4);\n    return x;\n}\n\n\n// --- Static Compile ---\n\nstatic void *jl_sysimg_handle = NULL;\nstatic uint64_t sysimage_base = 0;\nstatic uintptr_t *sysimg_gvars_base = NULL;\nstatic const int32_t *sysimg_gvars_offsets = NULL;\nstatic jl_sysimg_fptrs_t sysimg_fptrs;\n\nstatic inline uintptr_t *sysimg_gvars(uintptr_t *base, size_t idx)\n{\n    return base + sysimg_gvars_offsets[idx] / sizeof(base[0]);\n}\n\nJL_DLLEXPORT int jl_running_on_valgrind(void)\n{\n    return RUNNING_ON_VALGRIND;\n}\n\nstatic void jl_load_sysimg_so(void)\n{\n    int imaging_mode = jl_generating_output() && !jl_options.incremental;\n    // in --build mode only use sysimg data, not precompiled native code\n    if (!imaging_mode && jl_options.use_sysimage_native_code==JL_OPTIONS_USE_SYSIMAGE_NATIVE_CODE_YES) {\n        jl_dlsym(jl_sysimg_handle, \"jl_sysimg_gvars_base\", (void **)&sysimg_gvars_base, 1);\n        jl_dlsym(jl_sysimg_handle, \"jl_sysimg_gvars_offsets\", (void **)&sysimg_gvars_offsets, 1);\n        sysimg_gvars_offsets += 1;\n        assert(sysimg_fptrs.base);\n        uintptr_t *tls_getter_slot;\n        jl_dlsym(jl_sysimg_handle, \"jl_get_ptls_states_slot\", (void **)&tls_getter_slot, 1);\n        *tls_getter_slot = (uintptr_t)jl_get_ptls_states_getter();\n        size_t *tls_offset_idx;\n        jl_dlsym(jl_sysimg_handle, \"jl_tls_offset\", (void **)&tls_offset_idx, 1);\n        *tls_offset_idx = (uintptr_t)(jl_tls_offset == -1 ? 0 : jl_tls_offset);\n\n#ifdef _OS_WINDOWS_\n        sysimage_base = (intptr_t)jl_sysimg_handle;\n#else\n        Dl_info dlinfo;\n        if (dladdr((void*)sysimg_gvars_base, &dlinfo) != 0) {\n            sysimage_base = (intptr_t)dlinfo.dli_fbase;\n        }\n        else {\n            sysimage_base = 0;\n        }\n#endif\n    }\n    else {\n        memset(&sysimg_fptrs, 0, sizeof(sysimg_fptrs));\n    }\n    const char *sysimg_data;\n    jl_dlsym(jl_sysimg_handle, \"jl_system_image_data\", (void **)&sysimg_data, 1);\n    size_t *plen;\n    jl_dlsym(jl_sysimg_handle, \"jl_system_image_size\", (void **)&plen, 1);\n    jl_restore_system_image_data(sysimg_data, *plen);\n}\n\n\n// --- serializer ---\n\nstatic uintptr_t jl_fptr_id(void *fptr)\n{\n    void **pbp = ptrhash_bp(&fptr_to_id, fptr);\n    if (*pbp == HT_NOTFOUND || fptr == NULL)\n        return 0;\n    else\n        return *(uintptr_t*)pbp;\n}\n\n#define jl_serialize_value(s, v) jl_serialize_value_(s,(jl_value_t*)(v),1)\nstatic void jl_serialize_value_(jl_serializer_state *s, jl_value_t *v, int recursive);\n\n\nstatic void jl_serialize_module(jl_serializer_state *s, jl_module_t *m)\n{\n    jl_serialize_value(s, m->name);\n    jl_serialize_value(s, m->parent);\n    size_t i;\n    void **table = m->bindings.table;\n    for (i = 0; i < m->bindings.size; i += 2) {\n        if (table[i+1] != HT_NOTFOUND) {\n            jl_serialize_value(s, (jl_value_t*)table[i]);\n            jl_binding_t *b = (jl_binding_t*)table[i+1];\n            jl_serialize_value(s, b->name);\n            jl_serialize_value(s, b->value);\n            jl_serialize_value(s, b->globalref);\n            jl_serialize_value(s, b->owner);\n        }\n    }\n\n    for (i = 0; i < m->usings.len; i++) {\n        jl_serialize_value(s, (jl_value_t*)m->usings.items[i]);\n    }\n}\n\n\n#define NBOX_C 1024\n\nstatic void jl_serialize_value_(jl_serializer_state *s, jl_value_t *v, int recursive)\n{\n    // ignore items that are given a special representation\n    if (v == NULL || jl_is_symbol(v)) {\n        return;\n    }\n    else if (jl_typeis(v, jl_task_type)) {\n        if (v == (jl_value_t*)s->ptls->root_task) {\n            jl_serialize_value(s, ((jl_task_t*)v)->tls);\n            return;\n        }\n    }\n    else if (jl_typeis(v, jl_int64_type)) {\n        int64_t i64 = *(int64_t*)v + NBOX_C / 2;\n        if ((uint64_t)i64 < NBOX_C)\n            return;\n    }\n    else if (jl_typeis(v, jl_int32_type)) {\n        int32_t i32 = *(int32_t*)v + NBOX_C / 2;\n        if ((uint32_t)i32 < NBOX_C)\n            return;\n    }\n    else if (jl_typeis(v, jl_uint8_type)) {\n        return;\n    }\n\n    void **bp = ptrhash_bp(&backref_table, v);\n    if (*bp != HT_NOTFOUND) {\n        return;\n    }\n\n    size_t item = ++backref_table_numel;\n    assert(item < ((uintptr_t)1 << RELOC_TAG_OFFSET) && \"too many items to serialize\");\n    char *pos = (char*)HT_NOTFOUND + item;\n    *bp = (void*)pos;\n\n    // some values have special representations\n    jl_datatype_t *t = (jl_datatype_t*)jl_typeof(v);\n    jl_serialize_value(s, t);\n\n    if (t->layout->npointers == 0) {\n        // skip it\n    }\n    else if (jl_is_svec(v)) {\n        if (!recursive)\n            return;\n        size_t i, l = jl_svec_len(v);\n        jl_value_t **data = jl_svec_data(v);\n        for (i = 0; i < l; i++) {\n            jl_serialize_value(s, data[i]);\n        }\n    }\n    else if (jl_is_array(v)) {\n        jl_array_t *ar = (jl_array_t*)v;\n        jl_serialize_value(s, jl_typeof(ar));\n        if (ar->flags.ptrarray) {\n            size_t i, l = jl_array_len(ar);\n            for (i = 0; i < l; i++) {\n                jl_serialize_value(s, jl_array_ptr_ref(ar, i));\n            }\n        }\n        else if (ar->flags.hasptr) {\n            const char *data = (const char*)jl_array_data(ar);\n            uint16_t elsz = ar->elsize;\n            size_t i, l = jl_array_len(ar);\n            jl_datatype_t *et = (jl_datatype_t*)jl_tparam0(jl_typeof(ar));\n            size_t j, np = et->layout->npointers;\n            for (i = 0; i < l; i++) {\n                for (j = 0; j < np; j++) {\n                    uint32_t ptr = jl_ptr_offset(et, j);\n                    jl_value_t *fld = ((jl_value_t**)data)[ptr];\n                    JL_GC_PROMISE_ROOTED(fld);\n                    jl_serialize_value(s, fld);\n                }\n                data += elsz;\n            }\n        }\n    }\n    else if (jl_typeis(v, jl_module_type)) {\n        jl_serialize_module(s, (jl_module_t*)v);\n    }\n    else if (jl_is_typename(v)) {\n        jl_typename_t *tn = (jl_typename_t*)v;\n        jl_serialize_value(s, tn->name);\n        jl_serialize_value(s, tn->module);\n        jl_serialize_value(s, tn->names);\n        jl_serialize_value(s, tn->wrapper);\n        jl_serialize_value_(s, (jl_value_t*)tn->cache, 0);\n        jl_serialize_value_(s, (jl_value_t*)tn->linearcache, 0);\n        jl_serialize_value(s, tn->mt);\n        jl_serialize_value(s, tn->partial);\n    }\n    else if (t->layout->nfields > 0) {\n        char *data = (char*)jl_data_ptr(v);\n        size_t i, np = t->layout->npointers;\n        for (i = 0; i < np; i++) {\n            uint32_t ptr = jl_ptr_offset(t, i);\n            jl_value_t *fld = ((jl_value_t* const*)data)[ptr];\n            jl_serialize_value(s, fld);\n        }\n    }\n}\n\nstatic void ios_ensureroom(ios_t *s, size_t newsize) JL_NOTSAFEPOINT\n{\n    size_t prevsize = s->size;\n    if (prevsize < newsize) {\n        ios_trunc(s, newsize);\n        assert(s->size == newsize);\n        memset(&s->buf[prevsize], 0, newsize - prevsize);\n    }\n}\n\nstatic void record_gvar(jl_serializer_state *s, int gid, uintptr_t reloc_id) JL_NOTSAFEPOINT\n{\n    if (gid == 0)\n        return;\n    ios_ensureroom(s->gvar_record, gid * sizeof(uint32_t));\n    ios_seek(s->gvar_record, (gid - 1) * sizeof(uint32_t));\n    assert(reloc_id < UINT32_MAX);\n    write_uint32(s->gvar_record, reloc_id);\n}\n\n\nstatic void write_padding(ios_t *s, size_t nb) JL_NOTSAFEPOINT\n{\n    static const char zeros[16] = {0};\n    while (nb > 16) {\n        ios_write(s, zeros, 16);\n        nb -= 16;\n    }\n    if (nb != 0)\n        ios_write(s, zeros, nb);\n}\n\n\nstatic void write_pointer(ios_t *s) JL_NOTSAFEPOINT\n{\n    assert((ios_pos(s) & (sizeof(void*) - 1)) == 0 && \"stream misaligned for writing a word-sized value\");\n    write_padding(s, sizeof(void*));\n}\n\n\n#define backref_id(s, v) _backref_id(s, (jl_value_t*)(v))\nstatic uintptr_t _backref_id(jl_serializer_state *s, jl_value_t *v) JL_NOTSAFEPOINT\n{\n    assert(v != NULL && \"cannot get backref to NULL object\");\n    void *idx = HT_NOTFOUND;\n    if (jl_is_symbol(v)) {\n        void **pidx = ptrhash_bp(&symbol_table, v);\n        idx = *pidx;\n        if (idx == HT_NOTFOUND) {\n            size_t l = strlen(jl_symbol_name((jl_sym_t*)v));\n            write_uint32(s->symbols, l);\n            ios_write(s->symbols, jl_symbol_name((jl_sym_t*)v), l + 1);\n            size_t offset = ++nsym_tag;\n            assert(offset < ((uintptr_t)1 << RELOC_TAG_OFFSET) && \"too many symbols\");\n            idx = (void*)((char*)HT_NOTFOUND + ((uintptr_t)SymbolRef << RELOC_TAG_OFFSET) + offset);\n            *pidx = idx;\n        }\n    }\n    else if (v == (jl_value_t*)s->ptls->root_task) {\n        return (uintptr_t)TagRef << RELOC_TAG_OFFSET;\n    }\n    else if (jl_typeis(v, jl_int64_type)) {\n        int64_t i64 = *(int64_t*)v + NBOX_C / 2;\n        if ((uint64_t)i64 < NBOX_C)\n            return ((uintptr_t)TagRef << RELOC_TAG_OFFSET) + i64 + 1;\n    }\n    else if (jl_typeis(v, jl_int32_type)) {\n        int32_t i32 = *(int32_t*)v + NBOX_C / 2;\n        if ((uint32_t)i32 < NBOX_C)\n            return ((uintptr_t)TagRef << RELOC_TAG_OFFSET) + i32 + 1 + NBOX_C;\n    }\n    else if (jl_typeis(v, jl_uint8_type)) {\n        uint8_t u8 = *(uint8_t*)v;\n        return ((uintptr_t)TagRef << RELOC_TAG_OFFSET) + u8 + 1 + NBOX_C + NBOX_C;\n    }\n    if (idx == HT_NOTFOUND) {\n        idx = ptrhash_get(&backref_table, v);\n        assert(idx != HT_NOTFOUND && \"object missed during jl_serialize_value pass\");\n    }\n    return (char*)idx - 1 - (char*)HT_NOTFOUND;\n}\n\n\nstatic void write_pointerfield(jl_serializer_state *s, jl_value_t *fld) JL_NOTSAFEPOINT\n{\n    if (fld != NULL) {\n        arraylist_push(&s->relocs_list, (void*)(uintptr_t)ios_pos(s->s));\n        arraylist_push(&s->relocs_list, (void*)backref_id(s, fld));\n    }\n    write_pointer(s->s);\n}\n\nstatic void write_gctaggedfield(jl_serializer_state *s, uintptr_t ref) JL_NOTSAFEPOINT\n{\n    arraylist_push(&s->gctags_list, (void*)(uintptr_t)ios_pos(s->s));\n    arraylist_push(&s->gctags_list, (void*)ref);\n    write_pointer(s->s);\n}\n\n\nstatic void jl_write_module(jl_serializer_state *s, uintptr_t item, jl_module_t *m)\n{\n    size_t reloc_offset = ios_pos(s->s);\n    size_t tot = sizeof(jl_module_t);\n    ios_write(s->s, (char*)m, tot);\n\n    jl_module_t *newm = (jl_module_t*)&s->s->buf[reloc_offset];\n    newm->name = NULL;\n    arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_module_t, name)));\n    arraylist_push(&s->relocs_list, (void*)backref_id(s, m->name));\n    newm->parent = NULL;\n    arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_module_t, parent)));\n    arraylist_push(&s->relocs_list, (void*)backref_id(s, m->parent));\n    newm->primary_world = jl_world_counter;\n\n    // write out the bindings table as a list\n    // immediately after jl_module_t\n    // (the ptrhash will need to be recreated on load)\n    size_t count = 0;\n    size_t i;\n    void **table = m->bindings.table;\n    for (i = 0; i < m->bindings.size; i += 2) {\n        if (table[i+1] != HT_NOTFOUND) {\n            jl_binding_t *b = (jl_binding_t*)table[i+1];\n            write_pointerfield(s, (jl_value_t*)table[i]);\n            tot += sizeof(void*);\n            write_gctaggedfield(s, (uintptr_t)BindingRef << RELOC_TAG_OFFSET);\n            tot += sizeof(void*);\n            size_t binding_reloc_offset = ios_pos(s->s);\n            record_gvar(s, jl_get_llvm_gv(native_functions, (jl_value_t*)b),\n                    ((uintptr_t)DataRef << RELOC_TAG_OFFSET) + binding_reloc_offset);\n            write_pointerfield(s, (jl_value_t*)b->name);\n            write_pointerfield(s, b->value);\n            write_pointerfield(s, b->globalref);\n            write_pointerfield(s, (jl_value_t*)b->owner);\n            size_t flag_offset = offsetof(jl_binding_t, owner) + sizeof(b->owner);\n            ios_write(s->s, (char*)b + flag_offset, sizeof(*b) - flag_offset);\n            tot += sizeof(jl_binding_t);\n            count += 1;\n        }\n    }\n    assert(ios_pos(s->s) - reloc_offset == tot);\n    newm = (jl_module_t*)&s->s->buf[reloc_offset]; // buf might have been reallocated\n    newm->bindings.size = count; // stash the count in newm->size\n    newm->bindings.table = NULL;\n    memset(&newm->bindings._space, 0, sizeof(newm->bindings._space));\n\n    // write out the usings list\n    memset(&newm->usings._space, 0, sizeof(newm->usings._space));\n    if (m->usings.items == &m->usings._space[0]) {\n        newm->usings.items = (void**)offsetof(jl_module_t, usings._space);\n        arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_module_t, usings.items)));\n        arraylist_push(&s->relocs_list, (void*)(((uintptr_t)DataRef << RELOC_TAG_OFFSET) + item));\n        size_t i;\n        for (i = 0; i < m->usings.len; i++) {\n            arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_module_t, usings._space[i])));\n            arraylist_push(&s->relocs_list, (void*)backref_id(s, m->usings._space[i]));\n        }\n    }\n    else {\n        newm->usings.items = (void**)tot;\n        arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_module_t, usings.items)));\n        arraylist_push(&s->relocs_list, (void*)(((uintptr_t)DataRef << RELOC_TAG_OFFSET) + item));\n        size_t i;\n        for (i = 0; i < m->usings.len; i++) {\n            write_pointerfield(s, (jl_value_t*)m->usings.items[i]);\n            tot += sizeof(void*);\n        }\n        for (; i < m->usings.max; i++) {\n            write_pointer(s->s);\n            tot += sizeof(void*);\n        }\n    }\n}\n\n#if 0\nstatic size_t jl_sort_size(jl_datatype_t *dt)\n{\n    if (dt == jl_simplevector_type)\n        return SIZE_MAX - 5;\n    if (dt == jl_string_type)\n        return SIZE_MAX - 4;\n    if (dt->name == jl_array_typename)\n        return SIZE_MAX - 3;\n    if (dt == jl_datatype_type)\n        return SIZE_MAX - 2;\n    if (dt == jl_module_type)\n        return SIZE_MAX - 1;\n    return jl_datatype_size(dt);\n}\n#endif\n\nstatic int sysimg_sort_order(const void *pa, const void *pb)\n{\n    uintptr_t sa = ((uintptr_t*)pa)[1];\n    uintptr_t sb = ((uintptr_t*)pb)[1];\n    return (sa > sb ? 1 : (sa < sb ? -1 : 0));\n#if 0\n    jl_value_t *a = *(jl_value_t**)pa;\n    jl_datatype_t *tya = (jl_datatype_t*)jl_typeof(a);\n    size_t sa = jl_sort_size(tya);\n    jl_value_t *b = *(jl_value_t**)pb;\n    jl_datatype_t *tyb = (jl_datatype_t*)jl_typeof(b);\n    size_t sb = jl_sort_size(tyb);\n    if (sa == sb) {\n        sa = tya->uid;\n        sb = tyb->uid;\n    }\n    return (sa > sb ? 1 : (sa < sb ? -1 : 0));\n#endif\n}\n\njl_value_t *jl_find_ptr = NULL;\nstatic void jl_write_values(jl_serializer_state *s)\n{\n    arraylist_t objects_list;\n    arraylist_new(&objects_list, backref_table_numel * 2);\n\n    arraylist_new(&layout_table, 0);\n    arraylist_grow(&layout_table, backref_table_numel);\n    memset(layout_table.items, 0, backref_table_numel * sizeof(void*));\n\n    size_t i, len = backref_table.size;\n    void **p = backref_table.table;\n    for (i = 0; i < len; i += 2) {\n        char *reloc_id = (char*)p[i + 1];\n        if (reloc_id != HT_NOTFOUND) {\n            jl_value_t *v = (jl_value_t*)p[i];\n            uintptr_t item = reloc_id - 1 - (char*)HT_NOTFOUND;\n            objects_list.items[objects_list.len++] = (void*)v;\n            objects_list.items[objects_list.len++] = (void*)item;\n        }\n    }\n    assert(backref_table_numel * 2 == objects_list.len);\n    qsort(objects_list.items, backref_table_numel, sizeof(void*) * 2, sysimg_sort_order);\n\n    for (i = 0, len = backref_table_numel * 2; i < len; i += 2) {\n        jl_value_t *v = (jl_value_t*)objects_list.items[i];\n        JL_GC_PROMISE_ROOTED(v);\n        uintptr_t item = (uintptr_t)objects_list.items[i + 1];\n        jl_datatype_t *t = (jl_datatype_t*)jl_typeof(v);\n        assert((t->instance == NULL || t->instance == v) && \"detected singleton construction corruption\");\n        // realign stream to expected gc alignment (16 bytes)\n        uintptr_t skip_header_pos = ios_pos(s->s) + sizeof(jl_taggedvalue_t);\n        write_padding(s->s, LLT_ALIGN(skip_header_pos, 16) - skip_header_pos);\n        // write header\n        write_gctaggedfield(s, backref_id(s, t));\n        size_t reloc_offset = ios_pos(s->s);\n        assert(item < layout_table.len && layout_table.items[item] == NULL);\n        layout_table.items[item] = (void*)reloc_offset;\n        record_gvar(s, jl_get_llvm_gv(native_functions, v), ((uintptr_t)DataRef << RELOC_TAG_OFFSET) + reloc_offset);\n\n        // write data\n        if (jl_is_cpointer(v)) {\n            write_pointer(s->s);\n        }\n        else if (jl_is_array(v)) {\n#define JL_ARRAY_ALIGN(jl_value, nbytes) LLT_ALIGN(jl_value, nbytes)\n            jl_array_t *ar = (jl_array_t*)v;\n            jl_value_t *et = jl_tparam0(jl_typeof(v));\n            int ndimwords = jl_array_ndimwords(ar->flags.ndims);\n            size_t tsz = JL_ARRAY_ALIGN(sizeof(jl_array_t) + ndimwords * sizeof(size_t), JL_CACHE_BYTE_ALIGNMENT);\n            // copy header\n            ios_write(s->s, (char*)v, tsz);\n            // make some header modifications in-place\n            jl_array_t *newa = (jl_array_t*)&s->s->buf[reloc_offset];\n            size_t alen = jl_array_len(ar);\n            size_t tot = alen * ar->elsize;\n            if (newa->flags.ndims == 1)\n                newa->maxsize = alen;\n            newa->offset = 0;\n            newa->flags.how = 0;\n            newa->flags.pooled = 0;\n            newa->flags.isshared = 0;\n\n            // write data\n            if (!ar->flags.ptrarray && !ar->flags.hasptr) {\n                uintptr_t data = LLT_ALIGN(ios_pos(s->const_data), 16);\n                // realign stream to max(data-align(array), sizeof(void*))\n                write_padding(s->const_data, data - ios_pos(s->const_data));\n                // write data and relocations\n                newa->data = NULL; // relocation offset\n                data /= sizeof(void*);\n                assert(data < ((uintptr_t)1 << RELOC_TAG_OFFSET) && \"offset to constant data too large\");\n                arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_array_t, data))); // relocation location\n                arraylist_push(&s->relocs_list, (void*)(((uintptr_t)ConstDataRef << RELOC_TAG_OFFSET) + data)); // relocation target\n                if (jl_is_cpointer_type(et)) {\n                    // reset Ptr elements to C_NULL\n                    size_t i;\n                    for (i = 0; i < alen; i++)\n                        write_pointer(s->const_data);\n                }\n                else {\n                    int isbitsunion = jl_array_isbitsunion(ar);\n                    if (ar->elsize == 1 && !isbitsunion)\n                        tot += 1;\n                    ios_write(s->const_data, (char*)jl_array_data(ar), tot);\n                    if (isbitsunion)\n                        ios_write(s->const_data, jl_array_typetagdata(ar), alen);\n                }\n            }\n            else {\n                newa->data = (void*)tsz; // relocation offset\n                arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_array_t, data))); // relocation location\n                arraylist_push(&s->relocs_list, (void*)(((uintptr_t)DataRef << RELOC_TAG_OFFSET) + item)); // relocation target\n                if (ar->flags.hasptr) {\n                    // copy all of the data first\n                    const char *data = (const char*)jl_array_data(ar);\n                    ios_write(s->s, data, tot);\n                    // the rewrite all of the embedded pointers to null+relocation\n                    uint16_t elsz = ar->elsize;\n                    size_t j, np = ((jl_datatype_t*)et)->layout->npointers;\n                    size_t i;\n                    for (i = 0; i < alen; i++) {\n                        for (j = 0; j < np; j++) {\n                            size_t offset = i * elsz + jl_ptr_offset(((jl_datatype_t*)et), j) * sizeof(jl_value_t*);\n                            jl_value_t *fld = *(jl_value_t**)&data[offset];\n                            if (fld != NULL) {\n                                arraylist_push(&s->relocs_list, (void*)(uintptr_t)(reloc_offset + tsz + offset)); // relocation location\n                                arraylist_push(&s->relocs_list, (void*)backref_id(s, fld)); // relocation target\n                                memset(&s->s->buf[reloc_offset + tsz + offset], 0, sizeof(fld)); // relocation offset (none)\n                            }\n                            else {\n                                assert(*(jl_value_t**)&s->s->buf[reloc_offset + tsz + offset] == NULL);\n                            }\n                        }\n                    }\n                }\n                else {\n                    size_t i;\n                    for (i = 0; i < alen; i++) {\n                        jl_value_t *e = jl_array_ptr_ref(v, i);\n                        write_pointerfield(s, e);\n                    }\n                }\n            }\n        }\n        else if (jl_typeis(v, jl_module_type)) {\n            jl_write_module(s, item, (jl_module_t*)v);\n            // will need to recreate the binding table for this\n            arraylist_push(&reinit_list, (void*)item);\n            arraylist_push(&reinit_list, (void*)2);\n        }\n        else if (jl_typeis(v, jl_task_type)) {\n            jl_error(\"Task cannot be serialized\");\n        }\n        else if (jl_is_svec(v)) {\n            ios_write(s->s, (char*)v, sizeof(void*));\n            size_t i, l = jl_svec_len(v);\n            assert(l > 0 || (jl_svec_t*)v == jl_emptysvec);\n            for (i = 0; i < l; i++) {\n                write_pointerfield(s, jl_svecref(v, i));\n            }\n        }\n        else if (jl_is_string(v)) {\n            ios_write(s->s, (char*)v, sizeof(void*) + jl_string_len(v));\n            write_uint8(s->s, '\\0'); // null-terminated strings for easier C-compatibility\n        }\n        else if (jl_datatype_nfields(t) == 0) {\n            assert(t->layout->npointers == 0);\n            if (t->size > 0)\n                ios_write(s->s, (char*)v, t->size);\n        }\n        else if (jl_bigint_type && jl_typeis(v, jl_bigint_type)) {\n            jl_value_t *sizefield = jl_get_nth_field(v, 1);\n            int32_t sz = jl_unbox_int32(sizefield);\n            int32_t nw = (sz == 0 ? 1 : (sz < 0 ? -sz : sz));\n            size_t nb = nw * gmp_limb_size;\n            ios_write(s->s, (char*)&nw, sizeof(int32_t));\n            ios_write(s->s, (char*)&sz, sizeof(int32_t));\n            uintptr_t data = LLT_ALIGN(ios_pos(s->const_data), 8);\n            write_padding(s->const_data, data - ios_pos(s->const_data));\n            data /= sizeof(void*);\n            assert(data < ((uintptr_t)1 << RELOC_TAG_OFFSET) && \"offset to constant data too large\");\n            arraylist_push(&s->relocs_list, (void*)(reloc_offset + 8)); // relocation location\n            arraylist_push(&s->relocs_list, (void*)(((uintptr_t)ConstDataRef << RELOC_TAG_OFFSET) + data)); // relocation target\n            void *pdata = jl_unbox_voidpointer(jl_get_nth_field(v, 2));\n            ios_write(s->const_data, (char*)pdata, nb);\n            write_pointer(s->s);\n        }\n        else {\n            const char *data = (const char*)v;\n            size_t i, nf = jl_datatype_nfields(t);\n            size_t tot = 0;\n            for (i = 0; i < nf; i++) {\n                size_t offset = jl_field_offset(t, i);\n                const char *slot = data + offset;\n                write_padding(s->s, offset - tot);\n                tot = offset;\n                size_t fsz = jl_field_size(t, i);\n                if (t->mutabl && jl_is_cpointer_type(jl_field_type(t, i))) {\n                    // reset Ptr fields to C_NULL\n                    assert(!jl_field_isptr(t, i));\n                    write_pointer(s->s);\n                }\n                else if (fsz > 0) {\n                    ios_write(s->s, slot, fsz);\n                }\n                tot += fsz;\n            }\n\n            size_t np = t->layout->npointers;\n            for (i = 0; i < np; i++) {\n                size_t offset = jl_ptr_offset(t, i) * sizeof(jl_value_t*);\n                jl_value_t *fld = *(jl_value_t**)&data[offset];\n                if (fld != NULL) {\n                    arraylist_push(&s->relocs_list, (void*)(uintptr_t)(offset + reloc_offset)); // relocation location\n                    arraylist_push(&s->relocs_list, (void*)backref_id(s, fld)); // relocation target\n                    memset(&s->s->buf[offset + reloc_offset], 0, sizeof(fld)); // relocation offset (none)\n                }\n            }\n\n            if (jl_is_method(v)) {\n                write_padding(s->s, sizeof(jl_method_t) - tot);\n                if (((jl_method_t*)v)->ccallable) {\n                    arraylist_push(&ccallable_list, (void*)item);\n                    arraylist_push(&ccallable_list, (void*)3);\n                }\n            }\n            else if (jl_is_code_instance(v)) {\n                jl_code_instance_t *m = (jl_code_instance_t*)v;\n                jl_code_instance_t *newm = (jl_code_instance_t*)&s->s->buf[reloc_offset];\n\n                newm->invoke = NULL;\n                newm->isspecsig = 0;\n                newm->specptr.fptr = NULL;\n                int8_t fptr_id = JL_API_NULL;\n                int8_t builtin_id = 0;\n                if (m->invoke == jl_fptr_const_return) {\n                    fptr_id = JL_API_CONST;\n                }\n                else {\n                    if (jl_is_method(m->def->def.method)) {\n                        builtin_id = jl_fptr_id(m->specptr.fptr);\n                        if (builtin_id) { // found in the table of builtins\n                            assert(builtin_id >= 2);\n                            fptr_id = JL_API_BUILTIN;\n                        }\n                        else {\n                            int32_t invokeptr_id = 0;\n                            int32_t specfptr_id = 0;\n                            jl_get_function_id(native_functions, m, &invokeptr_id, &specfptr_id); // see if we generated code for it\n                            if (invokeptr_id) {\n                                if (invokeptr_id == -1) {\n                                    fptr_id = JL_API_BOXED;\n                                }\n                                else if (invokeptr_id == -2) {\n                                    fptr_id = JL_API_WITH_PARAMETERS;\n                                }\n                                else {\n                                    assert(invokeptr_id > 0);\n                                    ios_ensureroom(s->fptr_record, invokeptr_id * sizeof(void*));\n                                    ios_seek(s->fptr_record, (invokeptr_id - 1) * sizeof(void*));\n                                    write_uint32(s->fptr_record, ~reloc_offset);\n#ifdef _P64\n                                    write_padding(s->fptr_record, 4);\n#endif\n                                }\n                                if (specfptr_id) {\n                                    assert(specfptr_id > invokeptr_id && specfptr_id > 0);\n                                    ios_ensureroom(s->fptr_record, specfptr_id * sizeof(void*));\n                                    ios_seek(s->fptr_record, (specfptr_id - 1) * sizeof(void*));\n                                    write_uint32(s->fptr_record, reloc_offset);\n#ifdef _P64\n                                    write_padding(s->fptr_record, 4);\n#endif\n                                }\n                            }\n                        }\n                    }\n                }\n                newm->invoke = NULL; // relocation offset\n                if (fptr_id != JL_API_NULL) {\n                    arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_code_instance_t, invoke))); // relocation location\n                    arraylist_push(&s->relocs_list, (void*)(((uintptr_t)FunctionRef << RELOC_TAG_OFFSET) + fptr_id)); // relocation target\n                }\n                if (builtin_id >= 2) {\n                    arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_code_instance_t, specptr.fptr))); // relocation location\n                    arraylist_push(&s->relocs_list, (void*)(((uintptr_t)BuiltinFunctionRef << RELOC_TAG_OFFSET) + builtin_id - 2)); // relocation target\n                }\n            }\n            else if (jl_is_datatype(v)) {\n                jl_datatype_t *dt = (jl_datatype_t*)v;\n                jl_datatype_t *newdt = (jl_datatype_t*)&s->s->buf[reloc_offset];\n                if (dt->layout != NULL) {\n                    size_t nf = dt->layout->nfields;\n                    size_t np = dt->layout->npointers;\n                    size_t fieldsize = jl_fielddesc_size(dt->layout->fielddesc_type);\n                    char *flddesc = (char*)dt->layout;\n                    size_t fldsize = sizeof(jl_datatype_layout_t) + nf * fieldsize;\n                    if (dt->layout->first_ptr != -1)\n                        fldsize += np << dt->layout->fielddesc_type;\n                    uintptr_t layout = LLT_ALIGN(ios_pos(s->const_data), sizeof(void*));\n                    write_padding(s->const_data, layout - ios_pos(s->const_data)); // realign stream\n                    newdt->layout = NULL; // relocation offset\n                    layout /= sizeof(void*);\n                    arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_datatype_t, layout))); // relocation location\n                    arraylist_push(&s->relocs_list, (void*)(((uintptr_t)ConstDataRef << RELOC_TAG_OFFSET) + layout)); // relocation target\n                    ios_write(s->const_data, flddesc, fldsize);\n                }\n            }\n            else if (((jl_datatype_t*)(jl_typeof(v)))->name == jl_idtable_typename) {\n                // will need to rehash this, later (after types are fully constructed)\n                arraylist_push(&reinit_list, (void*)item);\n                arraylist_push(&reinit_list, (void*)1);\n            }\n            else {\n                write_padding(s->s, t->size - tot);\n            }\n        }\n    }\n}\n\n\nstatic void jl_write_gv_syms(jl_serializer_state *s, jl_sym_t *v)\n{\n    // since symbols are static, they might not have had a\n    // reference anywhere in the code image other than here\n    int32_t gv = jl_get_llvm_gv(native_functions, (jl_value_t*)v);\n    if (gv != 0) {\n        uintptr_t item = backref_id(s, v);\n        assert(item >> RELOC_TAG_OFFSET == SymbolRef);\n        record_gvar(s, gv, item);\n    }\n    if (v->left)\n        jl_write_gv_syms(s, v->left);\n    if (v->right)\n        jl_write_gv_syms(s, v->right);\n}\n\nstatic void jl_write_gv_int(jl_serializer_state *s, jl_value_t *v)\n{\n    int32_t gv = jl_get_llvm_gv(native_functions, (jl_value_t*)v);\n    if (gv != 0) {\n        uintptr_t item = backref_id(s, v);\n        assert(item >> RELOC_TAG_OFFSET == TagRef);\n        record_gvar(s, gv, item);\n    }\n}\nstatic void jl_write_gv_ints(jl_serializer_state *s)\n{\n    // this also ensures all objects referenced in the code have\n    // references in the system image to their global variable\n    // since codegen knows that some integer boxes are static,\n    // they might not have had a reference anywhere in the code\n    // image other than here\n    size_t i;\n    for (i = 0; i < NBOX_C; i++) {\n        jl_write_gv_int(s, jl_box_int32((int32_t)i - NBOX_C / 2));\n        jl_write_gv_int(s, jl_box_int64((int64_t)i - NBOX_C / 2));\n    }\n    for (i = 0; i < 256; i++) {\n        jl_write_gv_int(s, jl_box_uint8(i));\n    }\n}\n\nstatic inline uint32_t load_uint32(uintptr_t *base)\n{\n    uint32_t v = jl_load_unaligned_i32((void*)*base);\n    *base += 4;\n    return v;\n}\n\n\nstatic void jl_read_symbols(jl_serializer_state *s)\n{\n    assert(deser_sym.len == nsym_tag);\n    uintptr_t base = (uintptr_t)&s->symbols->buf[0];\n    uintptr_t end = base + s->symbols->size;\n    while (base < end) {\n        uint32_t len = load_uint32(&base);\n        const char *str = (const char*)base;\n        base += len + 1;\n        //printf(\"symbol %3d: %s\\n\", len, str);\n        jl_sym_t *sym = _jl_symbol(str, len);\n        arraylist_push(&deser_sym, (void*)sym);\n    }\n}\n\n\nstatic uintptr_t get_reloc_for_item(uintptr_t reloc_item, size_t reloc_offset)\n{\n    enum RefTags tag = (enum RefTags)(reloc_item >> RELOC_TAG_OFFSET);\n    if (tag == DataRef) {\n        // need to compute the final relocation offset via the layout table\n        assert(reloc_item < layout_table.len);\n        uintptr_t reloc_base = (uintptr_t)layout_table.items[reloc_item];\n        assert(reloc_base != 0 && \"layout offset missing for relocation item\");\n        // write reloc_offset into s->s at pos\n        return reloc_base + reloc_offset;\n    }\n    else {\n        // just write the item reloc_id directly\n#ifndef JL_NDEBUG\n        assert(reloc_offset == 0 && \"offsets for relocations to builtin objects should be precomposed in the reloc_item\");\n        size_t offset = (reloc_item & (((uintptr_t)1 << RELOC_TAG_OFFSET) - 1));\n        switch (tag) {\n        case ConstDataRef:\n            break;\n        case SymbolRef:\n            assert(offset < nsym_tag && \"corrupt relocation item id\");\n            break;\n        case TagRef:\n            assert(offset < 2 * NBOX_C + 257 && \"corrupt relocation item id\");\n            break;\n        case BindingRef:\n            assert(offset == 0 && \"corrupt relocation offset\");\n            break;\n        case BuiltinFunctionRef:\n            assert(offset < sizeof(id_to_fptrs) / sizeof(*id_to_fptrs) && \"unknown function pointer id\");\n            break;\n        case FunctionRef:\n            assert(offset < JL_API_MAX && \"unknown function pointer id\");\n            break;\n        case DataRef:\n        default:\n            assert(0 && \"corrupt relocation item id\");\n            abort();\n        }\n#endif\n        return reloc_item; // pre-composed relocation + offset\n    }\n}\n\n\nstatic inline uintptr_t get_item_for_reloc(jl_serializer_state *s, uintptr_t base, size_t size, uint32_t reloc_id)\n{\n    enum RefTags tag = (enum RefTags)(reloc_id >> RELOC_TAG_OFFSET);\n    size_t offset = (reloc_id & (((uintptr_t)1 << RELOC_TAG_OFFSET) - 1));\n    switch (tag) {\n    case DataRef:\n        assert(offset <= size);\n        return base + offset;\n    case ConstDataRef:\n        return (uintptr_t)s->const_data->buf + (offset * sizeof(void*));\n    case SymbolRef:\n        assert(offset < deser_sym.len && deser_sym.items[offset] && \"corrupt relocation item id\");\n        return (uintptr_t)deser_sym.items[offset];\n    case BindingRef:\n        return jl_buff_tag | GC_OLD_MARKED;\n    case TagRef:\n        if (offset == 0)\n            return (uintptr_t)s->ptls->root_task;\n        offset -= 1;\n        if (offset < NBOX_C)\n            return (uintptr_t)jl_box_int64((int64_t)offset - NBOX_C / 2);\n        offset -= NBOX_C;\n        if (offset < NBOX_C)\n            return (uintptr_t)jl_box_int32((int32_t)offset - NBOX_C / 2);\n        offset -= NBOX_C;\n        if (offset < 256)\n            return (uintptr_t)jl_box_uint8(offset);\n        // offset -= 256;\n        assert(0 && \"corrupt relocation item id\");\n        jl_unreachable(); // terminate control flow if assertion is disabled.\n    case BuiltinFunctionRef:\n        assert(offset < sizeof(id_to_fptrs) / sizeof(*id_to_fptrs) && \"unknown function pointer ID\");\n        return (uintptr_t)id_to_fptrs[offset];\n    case FunctionRef:\n        switch ((jl_callingconv_t)offset) {\n        case JL_API_BOXED:\n            if (sysimg_fptrs.base)\n                return (uintptr_t)jl_fptr_args;\n            JL_FALLTHROUGH;\n        case JL_API_WITH_PARAMETERS:\n            if (sysimg_fptrs.base)\n                return (uintptr_t)jl_fptr_sparam;\n            return (uintptr_t)NULL;\n        case JL_API_CONST:\n            return (uintptr_t)jl_fptr_const_return;\n        case JL_API_INTERPRETED:\n            return (uintptr_t)jl_fptr_interpret_call;\n        case JL_API_BUILTIN:\n            return (uintptr_t)jl_fptr_args;\n        case JL_API_NULL:\n        case JL_API_MAX:\n        //default:\n            assert(\"corrupt relocation item id\");\n        }\n    }\n    abort();\n}\n\n\nstatic void jl_write_skiplist(ios_t *s, char *base, size_t size, arraylist_t *list)\n{\n    size_t i;\n    for (i = 0; i < list->len; i += 2) {\n        size_t pos = (size_t)list->items[i];\n        size_t item = (size_t)list->items[i + 1];\n        uintptr_t *pv = (uintptr_t*)(base + pos);\n        assert(pos < size && pos != 0);\n        *pv = get_reloc_for_item(item, *pv);\n        // record pos in relocations list\n        // TODO: save space by using delta-compression\n        assert(pos < UINT32_MAX);\n        write_uint32(s, pos);\n    }\n    write_uint32(s, 0);\n}\n\n\nstatic void jl_write_relocations(jl_serializer_state *s)\n{\n    char *base = &s->s->buf[0];\n    jl_write_skiplist(s->relocs, base, s->s->size, &s->gctags_list);\n    jl_write_skiplist(s->relocs, base, s->s->size, &s->relocs_list);\n}\n\n\nstatic void jl_read_relocations(jl_serializer_state *s, uint8_t bits)\n{\n    uintptr_t base = (uintptr_t)&s->s->buf[0];\n    size_t size = s->s->size;\n    while (1) {\n        uintptr_t val = (uintptr_t)&s->relocs->buf[s->relocs->bpos];\n        uint32_t offset = load_uint32(&val);\n        s->relocs->bpos += sizeof(uint32_t);\n        if (offset == 0)\n            break;\n        uintptr_t *pv = (uintptr_t*)(base + offset);\n        uintptr_t v = *pv;\n        v = get_item_for_reloc(s, base, size, v);\n        *pv = v | bits;\n    }\n}\n\nstatic char* sysimg_base;\nstatic char* sysimg_relocs;\nvoid gc_sweep_sysimg(void)\n{\n    uintptr_t base = (uintptr_t)sysimg_base;\n    uintptr_t relocs = (uintptr_t)sysimg_relocs;\n    if (relocs == 0)\n        return;\n    while (1) {\n        uint32_t offset = load_uint32(&relocs);\n        if (offset == 0)\n            break;\n        jl_taggedvalue_t *o = (jl_taggedvalue_t*)(base + offset);\n        o->bits.gc = GC_OLD;\n    }\n}\n\n#define jl_write_value(s, v) _jl_write_value((s), (jl_value_t*)(v))\nstatic void _jl_write_value(jl_serializer_state *s, jl_value_t *v)\n{\n    if (v == NULL) {\n        write_uint32(s->s, 0);\n        return;\n    }\n    uintptr_t item = backref_id(s, v);\n    uintptr_t reloc = get_reloc_for_item(item, 0);\n    assert(reloc < UINT32_MAX);\n    write_uint32(s->s, reloc);\n}\n\n\nstatic jl_value_t *jl_read_value(jl_serializer_state *s)\n{\n    uintptr_t base = (uintptr_t)&s->s->buf[0];\n    size_t size = s->s->size;\n    uintptr_t val = base + s->s->bpos;\n    uint32_t offset = load_uint32(&val);\n    s->s->bpos += sizeof(uint32_t);\n    if (offset == 0)\n        return NULL;\n    return (jl_value_t*)get_item_for_reloc(s, base, size, offset);\n}\n\n\nstatic void jl_update_all_fptrs(jl_serializer_state *s)\n{\n    jl_sysimg_fptrs_t fvars = sysimg_fptrs;\n    // make these NULL now so we skip trying to restore GlobalVariable pointers later\n    sysimg_gvars_base = NULL;\n    sysimg_fptrs.base = NULL;\n    if (fvars.base == NULL)\n        return;\n    int sysimg_fvars_max = s->fptr_record->size / sizeof(void*);\n    size_t i;\n    uintptr_t base = (uintptr_t)&s->s->buf[0];\n    jl_method_instance_t **linfos = (jl_method_instance_t**)&s->fptr_record->buf[0];\n    uint32_t clone_idx = 0;\n    for (i = 0; i < sysimg_fvars_max; i++) {\n        uintptr_t val = (uintptr_t)&linfos[i];\n        uint32_t offset = load_uint32(&val);\n        linfos[i] = NULL;\n        if (offset != 0) {\n            int specfunc = 1;\n            if (offset & ((uintptr_t)1 << (8 * sizeof(uint32_t) - 1))) {\n                // if high bit is set, this is the func wrapper, not the specfunc\n                specfunc = 0;\n                offset = ~offset;\n            }\n            jl_code_instance_t *codeinst = (jl_code_instance_t*)(base + offset);\n            uintptr_t base = (uintptr_t)fvars.base;\n            assert(jl_is_method(codeinst->def->def.method) && codeinst->invoke != jl_fptr_const_return);\n            assert(specfunc ? codeinst->invoke != NULL : codeinst->invoke == NULL);\n            linfos[i] = codeinst->def;\n            int32_t offset = fvars.offsets[i];\n            for (; clone_idx < fvars.nclones; clone_idx++) {\n                uint32_t idx = fvars.clone_idxs[clone_idx] & jl_sysimg_val_mask;\n                if (idx < i)\n                    continue;\n                if (idx == i)\n                    offset = fvars.clone_offsets[clone_idx];\n                break;\n            }\n            void *fptr = (void*)(base + offset);\n            if (specfunc) {\n                codeinst->specptr.fptr = fptr;\n                codeinst->isspecsig = 1; // TODO: set only if confirmed to be true\n            }\n            else {\n                codeinst->invoke = (jl_callptr_t)fptr;\n            }\n        }\n    }\n    jl_register_fptrs(sysimage_base, &fvars, linfos, sysimg_fvars_max);\n}\n\n\nstatic void jl_update_all_gvars(jl_serializer_state *s)\n{\n    if (sysimg_gvars_base == NULL)\n        return;\n    size_t gvname_index = 0;\n    uintptr_t base = (uintptr_t)&s->s->buf[0];\n    size_t size = s->s->size;\n    uintptr_t gvars = (uintptr_t)&s->gvar_record->buf[0];\n    uintptr_t end = gvars + s->gvar_record->size;\n    while (gvars < end) {\n        uint32_t offset = load_uint32(&gvars);\n        if (offset) {\n            uintptr_t v = get_item_for_reloc(s, base, size, offset);\n            *sysimg_gvars(sysimg_gvars_base, gvname_index) = v;\n        }\n        gvname_index += 1;\n    }\n}\n\n\nstatic void jl_finalize_serializer(jl_serializer_state *s, arraylist_t *list)\n{\n    size_t i, l;\n\n    // record list of reinitialization functions\n    l = list->len;\n    for (i = 0; i < l; i += 2) {\n        size_t item = (size_t)list->items[i];\n        size_t reloc_offset = (size_t)layout_table.items[item];\n        assert(reloc_offset != 0);\n        write_uint32(s->s, (uint32_t)reloc_offset);\n        write_uint32(s->s, (uint32_t)((uintptr_t)list->items[i + 1]));\n    }\n    write_uint32(s->s, 0);\n}\n\n\nstatic void jl_reinit_item(jl_value_t *v, int how) JL_GC_DISABLED\n{\n    switch (how) {\n        case 1: { // rehash IdDict\n            jl_array_t **a = (jl_array_t**)v;\n            assert(jl_is_array(*a));\n            // Assume *a don't need a write barrier\n            *a = jl_idtable_rehash(*a, jl_array_len(*a));\n            jl_gc_wb(v, *a);\n            break;\n        }\n        case 2: { // rebuild the binding table for module v\n            jl_module_t *mod = (jl_module_t*)v;\n            assert(jl_is_module(mod));\n            size_t nbindings = mod->bindings.size;\n            htable_new(&mod->bindings, nbindings);\n            struct binding {\n                jl_sym_t *asname;\n                uintptr_t tag;\n                jl_binding_t b;\n            } *b;\n            b = (struct binding*)&mod[1];\n            while (nbindings > 0) {\n                ptrhash_put(&mod->bindings, b->asname, &b->b);\n                b += 1;\n                nbindings -= 1;\n            }\n            if (mod->usings.items != &mod->usings._space[0]) {\n                void **newitems = (void**)malloc_s(mod->usings.max * sizeof(void*));\n                memcpy(newitems, mod->usings.items, mod->usings.len * sizeof(void*));\n                mod->usings.items = newitems;\n            }\n            break;\n        }\n        case 3: { // install ccallable entry point in JIT\n            jl_svec_t *sv = ((jl_method_t*)v)->ccallable;\n            int success = jl_compile_extern_c(NULL, NULL, jl_sysimg_handle, jl_svecref(sv, 0), jl_svecref(sv, 1));\n            assert(success); (void)success;\n            break;\n        }\n        default:\n            assert(0 && \"corrupt deserialization state\");\n            abort();\n    }\n}\n\n\nstatic void jl_finalize_deserializer(jl_serializer_state *s) JL_GC_DISABLED\n{\n    // run reinitialization functions\n    uintptr_t base = (uintptr_t)&s->s->buf[0];\n    while (1) {\n        size_t offset = read_uint32(s->s);\n        if (offset == 0)\n            break;\n        jl_value_t *v = (jl_value_t*)(base + offset);\n        jl_reinit_item(v, read_uint32(s->s));\n    }\n}\n\n\n\nstatic void jl_scan_type_cache_gv(jl_serializer_state *s, jl_svec_t *cache)\n{\n    size_t l = jl_svec_len(cache), i;\n    for (i = 0; i < l; i++) {\n        jl_value_t *ti = jl_svecref(cache, i);\n        if (ti == NULL || ti == jl_nothing)\n            continue;\n        if (jl_get_llvm_gv(native_functions, ti)) {\n            jl_serialize_value(s, ti);\n        }\n        else if (jl_is_datatype(ti)) {\n            jl_value_t *singleton = ((jl_datatype_t*)ti)->instance;\n            if (singleton && jl_get_llvm_gv(native_functions, singleton))\n                jl_serialize_value(s, ti);\n        }\n    }\n}\n\n// remove cached types not referenced in the stream\nstatic void jl_prune_type_cache_hash(jl_svec_t *cache)\n{\n    size_t l = jl_svec_len(cache), i;\n    for (i = 0; i < l; i++) {\n        jl_value_t *ti = jl_svecref(cache, i);\n        if (ti == NULL || ti == jl_nothing)\n            continue;\n        if (ptrhash_get(&backref_table, ti) == HT_NOTFOUND)\n            jl_svecset(cache, i, jl_nothing);\n    }\n}\n\nstatic void jl_prune_type_cache_linear(jl_svec_t *cache)\n{\n    size_t l = jl_svec_len(cache), ins = 0, i;\n    for (i = 0; i < l; i++) {\n        jl_value_t *ti = jl_svecref(cache, i);\n        if (ti == NULL)\n            break;\n        if (ptrhash_get(&backref_table, ti) != HT_NOTFOUND)\n            jl_svecset(cache, ins++, ti);\n    }\n    if (i > ins) {\n        memset(&jl_svec_data(cache)[ins], 0, (i - ins) * sizeof(jl_value_t*));\n    }\n}\n\n\n// --- entry points ---\n\nstatic void jl_init_serializer2(int);\nstatic void jl_cleanup_serializer2(void);\n\nstatic void jl_save_system_image_to_stream(ios_t *f) JL_GC_DISABLED\n{\n    jl_gc_collect(JL_GC_FULL);\n    jl_gc_collect(JL_GC_INCREMENTAL);   // sweep finalizers\n    JL_TIMING(SYSIMG_DUMP);\n    int en = jl_gc_enable(0);\n    jl_init_serializer2(1);\n    htable_reset(&backref_table, 250000);\n    arraylist_new(&reinit_list, 0);\n    arraylist_new(&ccallable_list, 0);\n    backref_table_numel = 0;\n    ios_t sysimg, const_data, symbols, relocs, gvar_record, fptr_record;\n    ios_mem(&sysimg,     1000000);\n    ios_mem(&const_data,  100000);\n    ios_mem(&symbols,     100000);\n    ios_mem(&relocs,      100000);\n    ios_mem(&gvar_record, 100000);\n    ios_mem(&fptr_record, 100000);\n    jl_serializer_state s;\n    s.s = &sysimg;\n    s.const_data = &const_data;\n    s.symbols = &symbols;\n    s.relocs = &relocs;\n    s.gvar_record = &gvar_record;\n    s.fptr_record = &fptr_record;\n    s.ptls = jl_get_ptls_states();\n    arraylist_new(&s.relocs_list, 0);\n    arraylist_new(&s.gctags_list, 0);\n    jl_value_t **const*const tags = get_tags();\n\n    // empty!(Core.ARGS)\n    if (jl_core_module != NULL) {\n        jl_array_t *args = (jl_array_t*)jl_get_global(jl_core_module, jl_symbol(\"ARGS\"));\n        if (args != NULL) {\n            jl_array_del_end(args, jl_array_len(args));\n        }\n    }\n\n    jl_idtable_type = jl_base_module ? jl_get_global(jl_base_module, jl_symbol(\"IdDict\")) : NULL;\n    jl_idtable_typename = jl_base_module ? ((jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)jl_idtable_type))->name : NULL;\n    jl_bigint_type = jl_base_module ? jl_get_global(jl_base_module, jl_symbol(\"BigInt\")) : NULL;\n    if (jl_bigint_type) {\n        gmp_limb_size = jl_unbox_long(jl_get_global((jl_module_t*)jl_get_global(jl_base_module, jl_symbol(\"GMP\")),\n                                                    jl_symbol(\"BITS_PER_LIMB\"))) / 8;\n    }\n\n    { // step 1: record values (recursively) that need to go in the image\n        size_t i;\n        for (i = 0; tags[i] != NULL; i++) {\n            jl_value_t *tag = *tags[i];\n            jl_serialize_value(&s, tag);\n        }\n        // step 1.1: check for values only found in the generated code\n        arraylist_t typenames;\n        arraylist_new(&typenames, 0);\n        for (i = 0; i < backref_table.size; i += 2) {\n            jl_typename_t *tn = (jl_typename_t*)backref_table.table[i];\n            if (tn == HT_NOTFOUND || !jl_is_typename(tn))\n                continue;\n            arraylist_push(&typenames, tn);\n        }\n        for (i = 0; i < typenames.len; i++) {\n            jl_typename_t *tn = (jl_typename_t*)typenames.items[i];\n            jl_scan_type_cache_gv(&s, tn->cache);\n            jl_scan_type_cache_gv(&s, tn->linearcache);\n        }\n        // step 1.2: prune (garbage collect) some special weak references from\n        // built-in type caches\n        for (i = 0; i < typenames.len; i++) {\n            jl_typename_t *tn = (jl_typename_t*)typenames.items[i];\n            jl_prune_type_cache_hash(tn->cache);\n            jl_prune_type_cache_linear(tn->linearcache);\n        }\n        arraylist_free(&typenames);\n    }\n\n    { // step 2: build all the sysimg sections\n        write_padding(&sysimg, sizeof(uint32_t));\n        jl_write_values(&s);\n        jl_write_relocations(&s);\n        jl_write_gv_syms(&s, jl_get_root_symbol());\n        jl_write_gv_ints(&s);\n    }\n\n    if (sysimg.size > ((uintptr_t)1 << RELOC_TAG_OFFSET) ||\n        const_data.size > ((uintptr_t)1 << RELOC_TAG_OFFSET)*sizeof(void*)) {\n        jl_printf(JL_STDERR, \"ERROR: system image too large\\n\");\n        jl_exit(1);\n    }\n\n    // step 3: combine all of the sections into one file\n    write_uint32(f, sysimg.size - sizeof(uint32_t));\n    ios_seek(&sysimg, sizeof(uint32_t));\n    ios_copyall(f, &sysimg);\n    ios_close(&sysimg);\n\n    write_uint32(f, const_data.size);\n    // realign stream to max-alignment for data\n    write_padding(f, LLT_ALIGN(ios_pos(f), 16) - ios_pos(f));\n    ios_seek(&const_data, 0);\n    ios_copyall(f, &const_data);\n    ios_close(&const_data);\n\n    write_uint32(f, symbols.size);\n    ios_seek(&symbols, 0);\n    ios_copyall(f, &symbols);\n    ios_close(&symbols);\n\n    write_uint32(f, relocs.size);\n    ios_seek(&relocs, 0);\n    ios_copyall(f, &relocs);\n    ios_close(&relocs);\n\n    write_uint32(f, gvar_record.size);\n    ios_seek(&gvar_record, 0);\n    ios_copyall(f, &gvar_record);\n    ios_close(&gvar_record);\n\n    write_uint32(f, fptr_record.size);\n    ios_seek(&fptr_record, 0);\n    ios_copyall(f, &fptr_record);\n    ios_close(&fptr_record);\n\n    { // step 4: record locations of special roots\n        s.s = f;\n        size_t i;\n        for (i = 0; tags[i] != NULL; i++) {\n            jl_value_t *tag = *tags[i];\n            jl_write_value(&s, tag);\n        }\n        jl_write_value(&s, s.ptls->root_task->tls);\n        write_uint32(f, jl_get_gs_ctr());\n        write_uint32(f, jl_world_counter);\n        write_uint32(f, jl_typeinf_world);\n        jl_finalize_serializer(&s, &reinit_list);\n        jl_finalize_serializer(&s, &ccallable_list);\n    }\n\n    arraylist_free(&layout_table);\n    arraylist_free(&reinit_list);\n    arraylist_free(&ccallable_list);\n    arraylist_free(&s.relocs_list);\n    arraylist_free(&s.gctags_list);\n    jl_cleanup_serializer2();\n\n    jl_gc_enable(en);\n}\n\nJL_DLLEXPORT ios_t *jl_create_system_image(void *_native_data)\n{\n    ios_t *f = (ios_t*)malloc_s(sizeof(ios_t));\n    ios_mem(f, 0);\n    native_functions = _native_data;\n    jl_save_system_image_to_stream(f);\n    return f;\n}\n\nJL_DLLEXPORT size_t ios_write_direct(ios_t *dest, ios_t *src);\nJL_DLLEXPORT void jl_save_system_image(const char *fname)\n{\n    ios_t f;\n    if (ios_file(&f, fname, 1, 1, 1, 1) == NULL) {\n        jl_errorf(\"cannot open system image file \\\"%s\\\" for writing\", fname);\n    }\n    JL_SIGATOMIC_BEGIN();\n    jl_save_system_image_to_stream(&f);\n    ios_close(&f);\n    JL_SIGATOMIC_END();\n}\n\n// Takes in a path of the form \"usr/lib/julia/sys.so\" (jl_restore_system_image should be passed the same string)\nJL_DLLEXPORT void jl_preload_sysimg_so(const char *fname)\n{\n    if (jl_sysimg_handle)\n        return; // embedded target already called jl_set_sysimg_so\n\n    char *dot = (char*) strrchr(fname, '.');\n    int is_ji = (dot && !strcmp(dot, \".ji\"));\n\n    // Get handle to sys.so\n    if (!is_ji) // .ji extension => load .ji file only\n        jl_set_sysimg_so(jl_load_dynamic_library(fname, JL_RTLD_LOCAL | JL_RTLD_NOW, 1));\n}\n\n// Allow passing in a module handle directly, rather than a path\nJL_DLLEXPORT void jl_set_sysimg_so(void *handle)\n{\n    void* *jl_RTLD_DEFAULT_handle_pointer;\n    int symbol_found = jl_dlsym(handle, \"jl_RTLD_DEFAULT_handle_pointer\", (void **)&jl_RTLD_DEFAULT_handle_pointer, 0);\n    if (!symbol_found || (void*)&jl_RTLD_DEFAULT_handle != *jl_RTLD_DEFAULT_handle_pointer)\n        jl_error(\"System image file failed consistency check: maybe opened the wrong version?\");\n    if (jl_options.cpu_target == NULL)\n        jl_options.cpu_target = \"native\";\n    jl_sysimg_handle = handle;\n    sysimg_fptrs = jl_init_processor_sysimg(handle);\n}\n\nstatic void jl_restore_system_image_from_stream(ios_t *f) JL_GC_DISABLED\n{\n    JL_TIMING(SYSIMG_LOAD);\n    int en = jl_gc_enable(0);\n    jl_init_serializer2(0);\n    ios_t sysimg, const_data, symbols, relocs, gvar_record, fptr_record;\n    jl_serializer_state s;\n    s.s = NULL;\n    s.const_data = &const_data;\n    s.symbols = &symbols;\n    s.relocs = &relocs;\n    s.gvar_record = &gvar_record;\n    s.fptr_record = &fptr_record;\n    s.ptls = jl_get_ptls_states();\n    arraylist_new(&s.relocs_list, 0);\n    arraylist_new(&s.gctags_list, 0);\n    jl_value_t **const*const tags = get_tags();\n\n    // step 1: read section map\n    assert(ios_pos(f) == 0 && f->bm == bm_mem);\n    size_t sizeof_sysimg = read_uint32(f);\n    ios_static_buffer(&sysimg, f->buf, sizeof_sysimg + sizeof(uint32_t));\n    ios_skip(f, sizeof_sysimg);\n\n    size_t sizeof_constdata = read_uint32(f);\n    // realign stream to max-alignment for data\n    ios_seek(f, LLT_ALIGN(ios_pos(f), 16));\n    ios_static_buffer(&const_data, f->buf + f->bpos, sizeof_constdata);\n    ios_skip(f, sizeof_constdata);\n\n    size_t sizeof_symbols = read_uint32(f);\n    ios_static_buffer(&symbols, f->buf + f->bpos, sizeof_symbols);\n    ios_skip(f, sizeof_symbols);\n\n    size_t sizeof_relocations = read_uint32(f);\n    assert(!ios_eof(f));\n    ios_static_buffer(&relocs, f->buf + f->bpos, sizeof_relocations);\n    ios_skip(f, sizeof_relocations);\n\n    size_t sizeof_gvar_record = read_uint32(f);\n    assert(!ios_eof(f));\n    ios_static_buffer(&gvar_record, f->buf + f->bpos, sizeof_gvar_record);\n    ios_skip(f, sizeof_gvar_record);\n\n    size_t sizeof_fptr_record = read_uint32(f);\n    assert(!ios_eof(f));\n    ios_static_buffer(&fptr_record, f->buf + f->bpos, sizeof_fptr_record);\n    ios_skip(f, sizeof_fptr_record);\n\n    // step 2: get references to special values\n    s.s = f;\n    size_t i;\n    for (i = 0; tags[i] != NULL; i++) {\n        jl_value_t **tag = tags[i];\n        *tag = jl_read_value(&s);\n    }\n    s.ptls->root_task = (jl_task_t*)jl_gc_alloc(s.ptls, sizeof(jl_task_t), jl_task_type);\n    memset(s.ptls->root_task, 0, sizeof(jl_task_t));\n    s.ptls->root_task->tls = jl_read_value(&s);\n    jl_init_int32_int64_cache();\n    jl_init_box_caches();\n\n    uint32_t gs_ctr = read_uint32(f);\n    jl_world_counter = read_uint32(f);\n    jl_typeinf_world = read_uint32(f);\n    jl_set_gs_ctr(gs_ctr);\n    s.s = NULL;\n\n    // step 3: apply relocations\n    assert(!ios_eof(f));\n    jl_read_symbols(&s);\n    ios_close(&symbols);\n\n    sysimg_base = &sysimg.buf[0];\n    sysimg_relocs = &relocs.buf[0];\n    jl_gc_set_permalloc_region((void*)sysimg_base, (void*)(sysimg_base + sysimg.size));\n\n    s.s = &sysimg;\n    jl_read_relocations(&s, GC_OLD_MARKED); // gctags\n    size_t sizeof_tags = ios_pos(&relocs);\n    (void)sizeof_tags;\n    jl_read_relocations(&s, 0); // general relocs\n    ios_close(&relocs);\n    ios_close(&const_data);\n    jl_update_all_gvars(&s); // gvars relocs\n    ios_close(&gvar_record);\n    s.s = NULL;\n\n    s.s = f;\n    // reinit items except ccallables\n    jl_finalize_deserializer(&s);\n    s.s = NULL;\n\n    if (0) {\n        printf(\"sysimg size breakdown:\\n\"\n               \"     sys data: %8u\\n\"\n               \"  isbits data: %8u\\n\"\n               \"      symbols: %8u\\n\"\n               \"    tags list: %8u\\n\"\n               \"   reloc list: %8u\\n\"\n               \"    gvar list: %8u\\n\"\n               \"    fptr list: %8u\\n\",\n            (unsigned)sizeof_sysimg,\n            (unsigned)sizeof_constdata,\n            (unsigned)sizeof_symbols,\n            (unsigned)sizeof_tags,\n            (unsigned)(sizeof_relocations - sizeof_tags),\n            (unsigned)sizeof_gvar_record,\n            (unsigned)sizeof_fptr_record);\n    }\n\n    s.s = &sysimg;\n    jl_init_codegen();\n    jl_update_all_fptrs(&s); // fptr relocs and registration\n    // reinit ccallables, which require codegen to be initialized\n    s.s = f;\n    jl_finalize_deserializer(&s);\n\n    ios_close(&fptr_record);\n    ios_close(&sysimg);\n    s.s = NULL;\n\n    jl_gc_reset_alloc_count();\n    jl_gc_enable(en);\n    jl_cleanup_serializer2();\n}\n\n// TODO: need to enforce that the alignment of the buffer is suitable for vectors\nJL_DLLEXPORT void jl_restore_system_image(const char *fname)\n{\n#ifndef JL_NDEBUG\n    char *dot = fname ? (char*)strrchr(fname, '.') : NULL;\n    int is_ji = (dot && !strcmp(dot, \".ji\"));\n    assert((is_ji || jl_sysimg_handle) && \"System image file not preloaded\");\n#endif\n\n    if (jl_sysimg_handle) {\n        // load the pre-compiled sysimage from jl_sysimg_handle\n        jl_load_sysimg_so();\n    }\n    else {\n        ios_t f;\n        if (ios_file(&f, fname, 1, 0, 0, 0) == NULL)\n            jl_errorf(\"System image file \\\"%s\\\" not found.\", fname);\n        ios_bufmode(&f, bm_none);\n        JL_SIGATOMIC_BEGIN();\n        ios_seek_end(&f);\n        size_t len = ios_pos(&f);\n        char *sysimg = (char*)jl_gc_perm_alloc(len, 0, 64, 0);\n        ios_seek(&f, 0);\n        if (ios_readall(&f, sysimg, len) != len)\n            jl_errorf(\"Error reading system image file.\");\n        ios_close(&f);\n        ios_static_buffer(&f, sysimg, len);\n        jl_restore_system_image_from_stream(&f);\n        ios_close(&f);\n        JL_SIGATOMIC_END();\n    }\n}\n\nJL_DLLEXPORT void jl_restore_system_image_data(const char *buf, size_t len)\n{\n    ios_t f;\n    JL_SIGATOMIC_BEGIN();\n    ios_static_buffer(&f, (char*)buf, len);\n    jl_restore_system_image_from_stream(&f);\n    ios_close(&f);\n    JL_SIGATOMIC_END();\n}\n\n// --- init ---\n\nstatic void jl_init_serializer2(int for_serialize)\n{\n    if (for_serialize) {\n        htable_new(&symbol_table, 0);\n        htable_new(&fptr_to_id, sizeof(id_to_fptrs) / sizeof(*id_to_fptrs));\n        htable_new(&backref_table, 0);\n        uintptr_t i;\n        for (i = 0; id_to_fptrs[i] != NULL; i++) {\n            ptrhash_put(&fptr_to_id, (void*)(uintptr_t)id_to_fptrs[i], (void*)(i + 2));\n        }\n    }\n    else {\n        arraylist_new(&deser_sym, 0);\n    }\n    nsym_tag = 0;\n}\n\nstatic void jl_cleanup_serializer2(void)\n{\n    htable_reset(&symbol_table, 0);\n    htable_reset(&fptr_to_id, 0);\n    htable_reset(&backref_table, 0);\n    arraylist_free(&deser_sym);\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/jl_exported_funcs.inc": "#define JL_EXPORTED_FUNCS(XX) \\\n    XX(jl_) \\\n    XX(jl_abs_float) \\\n    XX(jl_abs_float_withtype) \\\n    XX(jl_active_task_stack) \\\n    XX(jl_add_float) \\\n    XX(jl_add_int) \\\n    XX(jl_add_optimization_passes) \\\n    XX(jl_add_ptr) \\\n    XX(jl_add_standard_imports) \\\n    XX(jl_alignment) \\\n    XX(jl_alloc_array_1d) \\\n    XX(jl_alloc_array_2d) \\\n    XX(jl_alloc_array_3d) \\\n    XX(jl_alloc_string) \\\n    XX(jl_alloc_svec) \\\n    XX(jl_alloc_svec_uninit) \\\n    XX(jl_alloc_vec_any) \\\n    XX(jl_and_int) \\\n    XX(jl_apply_array_type) \\\n    XX(jl_apply_generic) \\\n    XX(jl_apply_tuple_type) \\\n    XX(jl_apply_tuple_type_v) \\\n    XX(jl_apply_type) \\\n    XX(jl_apply_type1) \\\n    XX(jl_apply_type2) \\\n    XX(jl_argument_datatype) \\\n    XX(jl_argument_method_table) \\\n    XX(jl_array_cconvert_cstring) \\\n    XX(jl_array_copy) \\\n    XX(jl_array_data_owner) \\\n    XX(jl_array_del_at) \\\n    XX(jl_array_del_beg) \\\n    XX(jl_array_del_end) \\\n    XX(jl_array_eltype) \\\n    XX(jl_array_grow_at) \\\n    XX(jl_array_grow_beg) \\\n    XX(jl_array_grow_end) \\\n    XX(jl_array_isassigned) \\\n    XX(jl_arraylen) \\\n    XX(jl_array_ptr) \\\n    XX(jl_array_ptr_1d_append) \\\n    XX(jl_array_ptr_1d_push) \\\n    XX(jl_array_ptr_copy) \\\n    XX(jl_array_rank) \\\n    XX(jl_arrayref) \\\n    XX(jl_arrayset) \\\n    XX(jl_array_size) \\\n    XX(jl_array_sizehint) \\\n    XX(jl_array_to_string) \\\n    XX(jl_array_typetagdata) \\\n    XX(jl_arrayunset) \\\n    XX(jl_ashr_int) \\\n    XX(jl_astaggedvalue) \\\n    XX(jl_atexit_hook) \\\n    XX(jl_backtrace_from_here) \\\n    XX(jl_base_relative_to) \\\n    XX(jl_binding_owner) \\\n    XX(jl_binding_resolved_p) \\\n    XX(jl_bitcast) \\\n    XX(jl_boundp) \\\n    XX(jl_bounds_error) \\\n    XX(jl_bounds_error_int) \\\n    XX(jl_bounds_error_ints) \\\n    XX(jl_bounds_error_tuple_int) \\\n    XX(jl_bounds_error_unboxed_int) \\\n    XX(jl_bounds_error_v) \\\n    XX(jl_box_bool) \\\n    XX(jl_box_char) \\\n    XX(jl_box_float32) \\\n    XX(jl_box_float64) \\\n    XX(jl_box_int16) \\\n    XX(jl_box_int32) \\\n    XX(jl_box_int64) \\\n    XX(jl_box_int8) \\\n    XX(jl_box_slotnumber) \\\n    XX(jl_box_ssavalue) \\\n    XX(jl_box_uint16) \\\n    XX(jl_box_uint32) \\\n    XX(jl_box_uint64) \\\n    XX(jl_box_uint8) \\\n    XX(jl_box_uint8pointer) \\\n    XX(jl_box_voidpointer) \\\n    XX(jl_breakpoint) \\\n    XX(jl_bswap_int) \\\n    XX(jl_call) \\\n    XX(jl_call0) \\\n    XX(jl_call1) \\\n    XX(jl_call2) \\\n    XX(jl_call3) \\\n    XX(jl_call_in_typeinf_world) \\\n    XX(jl_calloc) \\\n    XX(jl_capture_interp_frame) \\\n    XX(jl_ceil_llvm) \\\n    XX(jl_ceil_llvm_withtype) \\\n    XX(jl_cglobal) \\\n    XX(jl_cglobal_auto) \\\n    XX(jl_checked_assignment) \\\n    XX(jl_checked_sadd_int) \\\n    XX(jl_checked_sdiv_int) \\\n    XX(jl_checked_smul_int) \\\n    XX(jl_checked_srem_int) \\\n    XX(jl_checked_ssub_int) \\\n    XX(jl_checked_uadd_int) \\\n    XX(jl_checked_udiv_int) \\\n    XX(jl_checked_umul_int) \\\n    XX(jl_checked_urem_int) \\\n    XX(jl_checked_usub_int) \\\n    XX(jl_clear_implicit_imports) \\\n    XX(jl_clear_malloc_data) \\\n    XX(jl_clock_now) \\\n    XX(jl_close_uv) \\\n    XX(jl_code_for_staged) \\\n    XX(jl_compile_hint) \\\n    XX(jl_compress_argnames) \\\n    XX(jl_compress_ir) \\\n    XX(jl_compute_fieldtypes) \\\n    XX(jl_copy_ast) \\\n    XX(jl_copy_code_info) \\\n    XX(jl_copysign_float) \\\n    XX(jl_cpuid) \\\n    XX(jl_cpuidex) \\\n    XX(jl_cpu_pause) \\\n    XX(jl_cpu_threads) \\\n    XX(jl_cpu_wake) \\\n    XX(jl_crc32c_sw) \\\n    XX(jl_create_native) \\\n    XX(jl_create_system_image) \\\n    XX(jl_cstr_to_string) \\\n    XX(jl_ctlz_int) \\\n    XX(jl_ctpop_int) \\\n    XX(jl_cttz_int) \\\n    XX(jl_current_exception) \\\n    XX(jl_debug_method_invalidation) \\\n    XX(jl_declare_constant) \\\n    XX(jl_defines_or_exports_p) \\\n    XX(jl_deprecate_binding) \\\n    XX(jl_div_float) \\\n    XX(jl_dlclose) \\\n    XX(jl_dlopen) \\\n    XX(jl_dlsym) \\\n    XX(jl_dump_compiles) \\\n    XX(jl_dump_fptr_asm) \\\n    XX(jl_dump_function_ir) \\\n    XX(jl_dump_host_cpu) \\\n    XX(jl_dump_llvm_asm) \\\n    XX(jl_dump_method_asm) \\\n    XX(jl_egal) \\\n    XX(jl_eh_restore_state) \\\n    XX(jl_enqueue_task) \\\n    XX(jl_enter_handler) \\\n    XX(jl_enter_threaded_region) \\\n    XX(jl_environ) \\\n    XX(jl_eof_error) \\\n    XX(jl_eq_float) \\\n    XX(jl_eq_int) \\\n    XX(jl_eqtable_get) \\\n    XX(jl_eqtable_nextind) \\\n    XX(jl_eqtable_pop) \\\n    XX(jl_eqtable_put) \\\n    XX(jl_errno) \\\n    XX(jl_error) \\\n    XX(jl_errorf) \\\n    XX(jl_eval_string) \\\n    XX(jl_exception_clear) \\\n    XX(jl_exceptionf) \\\n    XX(jl_exception_occurred) \\\n    XX(jl_excstack_state) \\\n    XX(jl_exit) \\\n    XX(jl_exit_on_sigint) \\\n    XX(jl_exit_threaded_region) \\\n    XX(jl_expand) \\\n    XX(jl_expand_and_resolve) \\\n    XX(jl_expand_stmt) \\\n    XX(jl_expand_stmt_with_loc) \\\n    XX(jl_expand_with_loc) \\\n    XX(jl_expand_with_loc_warn) \\\n    XX(jl_extern_c) \\\n    XX(jl_f__abstracttype) \\\n    XX(jl_f__apply) \\\n    XX(jl_f__apply_iterate) \\\n    XX(jl_f__apply_pure) \\\n    XX(jl_f__call_in_world) \\\n    XX(jl_f__call_latest) \\\n    XX(jl_f_applicable) \\\n    XX(jl_f_apply_type) \\\n    XX(jl_f_arrayref) \\\n    XX(jl_f_arrayset) \\\n    XX(jl_f_arraysize) \\\n    XX(jl_f_const_arrayref) \\\n    XX(jl_f__equiv_typedef) \\\n    XX(jl_f__expr) \\\n    XX(jl_f_fieldtype) \\\n    XX(jl_f_getfield) \\\n    XX(jl_field_index) \\\n    XX(jl_field_isdefined) \\\n    XX(jl_f_ifelse) \\\n    XX(jl_finalize) \\\n    XX(jl_finalize_th) \\\n    XX(jl_find_free_typevars) \\\n    XX(jl_f_intrinsic_call) \\\n    XX(jl_f_invoke) \\\n    XX(jl_f_invoke_kwsorter) \\\n    XX(jl_first_argument_datatype) \\\n    XX(jl_f_is) \\\n    XX(jl_f_isa) \\\n    XX(jl_f_isdefined) \\\n    XX(jl_f_issubtype) \\\n    XX(jl_flipsign_int) \\\n    XX(jl_floor_llvm) \\\n    XX(jl_floor_llvm_withtype) \\\n    XX(jl_fl_parse) \\\n    XX(jl_flush_cstdio) \\\n    XX(jl_fma_float) \\\n    XX(jl_f_new_module) \\\n    XX(jl_f_nfields) \\\n    XX(jl_forceclose_uv) \\\n    XX(jl_format_filename) \\\n    XX(jl_fpext) \\\n    XX(jl_fpiseq) \\\n    XX(jl_fpislt) \\\n    XX(jl_f__primitivetype) \\\n    XX(jl_fptosi) \\\n    XX(jl_fptoui) \\\n    XX(jl_fptr_args) \\\n    XX(jl_fptr_const_return) \\\n    XX(jl_fptr_interpret_call) \\\n    XX(jl_fptr_sparam) \\\n    XX(jl_fptrunc) \\\n    XX(jl_free) \\\n    XX(jl_free_stack) \\\n    XX(jl_fs_access) \\\n    XX(jl_fs_chmod) \\\n    XX(jl_fs_chown) \\\n    XX(jl_fs_close) \\\n    XX(jl_f_setfield) \\\n    XX(jl_f__setsuper) \\\n    XX(jl_f_sizeof) \\\n    XX(jl_fs_read) \\\n    XX(jl_fs_read_byte) \\\n    XX(jl_fs_rename) \\\n    XX(jl_fs_sendfile) \\\n    XX(jl_fs_symlink) \\\n    XX(jl_fstat) \\\n    XX(jl_f__structtype) \\\n    XX(jl_fs_unlink) \\\n    XX(jl_f_svec) \\\n    XX(jl_fs_write) \\\n    XX(jl_f_throw) \\\n    XX(jl_ftruncate) \\\n    XX(jl_f_tuple) \\\n    XX(jl_f_typeassert) \\\n    XX(jl_f__typebody) \\\n    XX(jl_f_typeof) \\\n    XX(jl_f__typevar) \\\n    XX(jl_gc_add_finalizer) \\\n    XX(jl_gc_add_finalizer_th) \\\n    XX(jl_gc_add_ptr_finalizer) \\\n    XX(jl_gc_alloc) \\\n    XX(jl_gc_alloc_0w) \\\n    XX(jl_gc_alloc_1w) \\\n    XX(jl_gc_alloc_2w) \\\n    XX(jl_gc_alloc_3w) \\\n    XX(jl_gc_allocobj) \\\n    XX(jl_gc_alloc_typed) \\\n    XX(jl_gc_big_alloc) \\\n    XX(jl_gc_collect) \\\n    XX(jl_gc_conservative_gc_support_enabled) \\\n    XX(jl_gc_counted_calloc) \\\n    XX(jl_gc_counted_free_with_size) \\\n    XX(jl_gc_counted_malloc) \\\n    XX(jl_gc_counted_realloc_with_old_size) \\\n    XX(jl_gc_diff_total_bytes) \\\n    XX(jl_gc_enable) \\\n    XX(jl_gc_enable_conservative_gc_support) \\\n    XX(jl_gc_enable_finalizers) \\\n    XX(jl_gc_external_obj_hdr_size) \\\n    XX(jl_gc_find_taggedvalue_pool) \\\n    XX(jl_gc_get_total_bytes) \\\n    XX(jl_gc_internal_obj_base_ptr) \\\n    XX(jl_gc_is_enabled) \\\n    XX(jl_gc_live_bytes) \\\n    XX(jl_gc_managed_malloc) \\\n    XX(jl_gc_managed_realloc) \\\n    XX(jl_gc_mark_queue_obj) \\\n    XX(jl_gc_mark_queue_objarray) \\\n    XX(jl_gc_max_internal_obj_size) \\\n    XX(jl_gc_new_weakref) \\\n    XX(jl_gc_new_weakref_th) \\\n    XX(jl_gc_num) \\\n    XX(jl_gc_pool_alloc) \\\n    XX(jl_gc_queue_multiroot) \\\n    XX(jl_gc_queue_root) \\\n    XX(jl_gc_safe_enter) \\\n    XX(jl_gc_safe_leave) \\\n    XX(jl_gc_safepoint) \\\n    XX(jl_gc_schedule_foreign_sweepfunc) \\\n    XX(jl_gc_set_cb_notify_external_alloc) \\\n    XX(jl_gc_set_cb_notify_external_free) \\\n    XX(jl_gc_set_cb_post_gc) \\\n    XX(jl_gc_set_cb_pre_gc) \\\n    XX(jl_gc_set_cb_root_scanner) \\\n    XX(jl_gc_set_cb_task_scanner) \\\n    XX(jl_gc_sync_total_bytes) \\\n    XX(jl_gc_total_hrtime) \\\n    XX(jl_gc_unsafe_enter) \\\n    XX(jl_gc_unsafe_leave) \\\n    XX(jl_gdblookup) \\\n    XX(jl_generating_output) \\\n    XX(jl_generic_function_def) \\\n    XX(jl_gensym) \\\n    XX(jl_getaddrinfo) \\\n    XX(jl_getallocationgranularity) \\\n    XX(jl_get_ARCH) \\\n    XX(jl_get_backtrace) \\\n    XX(jl_get_binding) \\\n    XX(jl_get_binding_for_method_def) \\\n    XX(jl_get_binding_or_error) \\\n    XX(jl_get_binding_wr) \\\n    XX(jl_get_cfunction_trampoline) \\\n    XX(jl_get_cpu_name) \\\n    XX(jl_get_current_task) \\\n    XX(jl_get_default_sysimg_path) \\\n    XX(jl_get_excstack) \\\n    XX(jl_get_fenv_consts) \\\n    XX(jl_get_field) \\\n    XX(jl_get_field_offset) \\\n    XX(jl_get_fieldtypes) \\\n    XX(jl_get_function_id) \\\n    XX(jl_get_global) \\\n    XX(jl_get_image_file) \\\n    XX(jl_get_JIT) \\\n    XX(jl_get_julia_bin) \\\n    XX(jl_get_julia_bindir) \\\n    XX(jl_get_keyword_sorter) \\\n    XX(jl_get_kwsorter) \\\n    XX(jl_get_llvm_context) \\\n    XX(jl_get_llvmf_defn) \\\n    XX(jl_get_llvm_function) \\\n    XX(jl_get_llvm_module) \\\n    XX(jl_get_LLVM_VERSION) \\\n    XX(jl_get_method_inferred) \\\n    XX(jl_get_module_binding) \\\n    XX(jl_get_module_compile) \\\n    XX(jl_get_module_infer) \\\n    XX(jl_get_module_of_binding) \\\n    XX(jl_get_module_optlevel) \\\n    XX(jl_getnameinfo) \\\n    XX(jl_get_next_task) \\\n    XX(jl_get_nth_field) \\\n    XX(jl_get_nth_field_checked) \\\n    XX(jl_get_nth_field_noalloc) \\\n    XX(jl_getpagesize) \\\n    XX(jl_getpid) \\\n    XX(jl_get_ptls_states) \\\n    XX(jl_get_root_symbol) \\\n    XX(jl_get_safe_restore) \\\n    XX(jl_get_size) \\\n    XX(jl_get_task_tid) \\\n    XX(jl_gettimeofday) \\\n    XX(jl_get_tls_world_age) \\\n    XX(jl_get_UNAME) \\\n    XX(jl_get_world_counter) \\\n    XX(jl_get_zero_subnormals) \\\n    XX(jl_gf_invoke_lookup) \\\n    XX(jl_gf_invoke_lookup_worlds) \\\n    XX(jl_git_branch) \\\n    XX(jl_git_commit) \\\n    XX(jl_global_event_loop) \\\n    XX(jl_has_empty_intersection) \\\n    XX(jl_has_free_typevars) \\\n    XX(jl_has_so_reuseport) \\\n    XX(jl_has_typevar) \\\n    XX(jl_has_typevar_from_unionall) \\\n    XX(jl_hrtime) \\\n    XX(jl_id_char) \\\n    XX(jl_id_start_char) \\\n    XX(jl_idtable_rehash) \\\n    XX(jl_infer_thunk) \\\n    XX(jl_init_restored_modules) \\\n    XX(jl_init__threading) \\\n    XX(jl_init_with_image__threading) \\\n    XX(jl_install_sigint_handler) \\\n    XX(jl_instantiate_type_in_env) \\\n    XX(jl_instantiate_unionall) \\\n    XX(jl_intersect_types) \\\n    XX(jl_in_threaded_region) \\\n    XX(jl_intrinsic_name) \\\n    XX(jl_invoke) \\\n    XX(jl_invoke_api) \\\n    XX(jl_iolock_begin) \\\n    XX(jl_iolock_end) \\\n    XX(jl_ios_buffer_n) \\\n    XX(jl_ios_fd) \\\n    XX(jl_ios_get_nbyte_int) \\\n    XX(jl_ir_flag_inferred) \\\n    XX(jl_ir_flag_inlineable) \\\n    XX(jl_ir_flag_pure) \\\n    XX(jl_ir_nslots) \\\n    XX(jl_ir_slotflag) \\\n    XX(jl_isa) \\\n    XX(jl_isa_compileable_sig) \\\n    XX(jl_is_binding_deprecated) \\\n    XX(jl_is_char_signed) \\\n    XX(jl_is_const) \\\n    XX(jl_is_debugbuild) \\\n    XX(jl_is_identifier) \\\n    XX(jl_is_imported) \\\n    XX(jl_is_initialized) \\\n    XX(jl_is_in_pure_context) \\\n    XX(jl_islayout_inline) \\\n    XX(jl_is_memdebug) \\\n    XX(jl_is_not_broken_subtype) \\\n    XX(jl_is_operator) \\\n    XX(jl_is_task_started) \\\n    XX(jl_istopmod) \\\n    XX(jl_is_unary_and_binary_operator) \\\n    XX(jl_is_unary_operator) \\\n    XX(jl_lazy_load_and_lookup) \\\n    XX(jl_le_float) \\\n    XX(jl_lisp_prompt) \\\n    XX(jl_LLVMCreateDisasm) \\\n    XX(jl_LLVMDisasmInstruction) \\\n    XX(jl_LLVMFlipSign) \\\n    XX(jl_LLVMSMod) \\\n    XX(jl_load) \\\n    XX(jl_load_) \\\n    XX(jl_load_and_lookup) \\\n    XX(jl_load_dynamic_library) \\\n    XX(jl_load_file_string) \\\n    XX(jl_lookup_code_address) \\\n    XX(jl_lseek) \\\n    XX(jl_lshr_int) \\\n    XX(jl_lstat) \\\n    XX(jl_lt_float) \\\n    XX(jl_macroexpand) \\\n    XX(jl_macroexpand1) \\\n    XX(jl_malloc) \\\n    XX(jl_malloc_stack) \\\n    XX(jl_matching_methods) \\\n    XX(jl_maxrss) \\\n    XX(jl_method_def) \\\n    XX(jl_method_instance_add_backedge) \\\n    XX(jl_method_table_add_backedge) \\\n    XX(jl_method_table_disable) \\\n    XX(jl_method_table_for) \\\n    XX(jl_method_table_insert) \\\n    XX(jl_methtable_lookup) \\\n    XX(jl_mi_cache_insert) \\\n    XX(jl_mmap) \\\n    XX(jl_module_build_id) \\\n    XX(jl_module_export) \\\n    XX(jl_module_exports_p) \\\n    XX(jl_module_globalref) \\\n    XX(jl_module_import) \\\n    XX(jl_module_name) \\\n    XX(jl_module_names) \\\n    XX(jl_module_parent) \\\n    XX(jl_module_use) \\\n    XX(jl_module_using) \\\n    XX(jl_module_usings) \\\n    XX(jl_module_uuid) \\\n    XX(jl_muladd_float) \\\n    XX(jl_mul_float) \\\n    XX(jl_mul_int) \\\n    XX(jl_native_alignment) \\\n    XX(jl_nb_available) \\\n    XX(jl_ne_float) \\\n    XX(jl_neg_float) \\\n    XX(jl_neg_float_withtype) \\\n    XX(jl_neg_int) \\\n    XX(jl_ne_int) \\\n    XX(jl_new_array) \\\n    XX(jl_new_bits) \\\n    XX(jl_new_code_info_uninit) \\\n    XX(jl_new_codeinst) \\\n    XX(jl_new_datatype) \\\n    XX(jl_new_foreign_type) \\\n    XX(jl_new_method_instance_uninit) \\\n    XX(jl_new_method_table) \\\n    XX(jl_new_method_uninit) \\\n    XX(jl_new_module) \\\n    XX(jl_new_primitivetype) \\\n    XX(jl_new_struct) \\\n    XX(jl_new_structt) \\\n    XX(jl_new_struct_uninit) \\\n    XX(jl_new_structv) \\\n    XX(jl_new_task) \\\n    XX(jl_new_typename_in) \\\n    XX(jl_new_typevar) \\\n    XX(jl_next_from_addrinfo) \\\n    XX(jl_no_exc_handler) \\\n    XX(jl_normalize_to_compilable_sig) \\\n    XX(jl_not_int) \\\n    XX(jl_object_id) \\\n    XX(jl_object_id_) \\\n    XX(jl_obvious_subtype) \\\n    XX(jl_operator_precedence) \\\n    XX(jl_op_suffix_char) \\\n    XX(jl_or_int) \\\n    XX(jl_parse) \\\n    XX(jl_parse_all) \\\n    XX(jl_parse_input_line) \\\n    XX(jl_parse_opts) \\\n    XX(jl_parse_string) \\\n    XX(jl_pathname_for_handle) \\\n    XX(jl_pchar_to_array) \\\n    XX(jl_pchar_to_string) \\\n    XX(jl_pointerref) \\\n    XX(jl_pointerset) \\\n    XX(jl_pop_handler) \\\n    XX(jl_preload_sysimg_so) \\\n    XX(jl_prepend_cwd) \\\n    XX(jl_printf) \\\n    XX(jl_process_events) \\\n    XX(jl_profile_clear_data) \\\n    XX(jl_profile_delay_nsec) \\\n    XX(jl_profile_get_data) \\\n    XX(jl_profile_init) \\\n    XX(jl_profile_is_running) \\\n    XX(jl_profile_len_data) \\\n    XX(jl_profile_maxlen_data) \\\n    XX(jl_profile_start_timer) \\\n    XX(jl_profile_stop_timer) \\\n    XX(jl_ptrarrayref) \\\n    XX(jl_ptr_to_array) \\\n    XX(jl_ptr_to_array_1d) \\\n    XX(jl_pwrite) \\\n    XX(jl_queue_work) \\\n    XX(jl_raise_debugger) \\\n    XX(jl_readuntil) \\\n    XX(jl_read_verify_header) \\\n    XX(jl_realloc) \\\n    XX(jl_register_newmeth_tracer) \\\n    XX(jl_rem_float) \\\n    XX(jl_repl_raise_sigtstp) \\\n    XX(jl_reshape_array) \\\n    XX(jl_restore_excstack) \\\n    XX(jl_restore_incremental) \\\n    XX(jl_restore_incremental_from_buf) \\\n    XX(jl_restore_system_image) \\\n    XX(jl_restore_system_image_data) \\\n    XX(jl_rethrow) \\\n    XX(jl_rethrow_other) \\\n    XX(jl_rettype_inferred) \\\n    XX(jl_rint_llvm) \\\n    XX(jl_rint_llvm_withtype) \\\n    XX(jl_running_on_valgrind) \\\n    XX(jl_safe_printf) \\\n    XX(jl_save_incremental) \\\n    XX(jl_save_system_image) \\\n    XX(jl_SC_CLK_TCK) \\\n    XX(jl_sdiv_int) \\\n    XX(jl_set_ARGS) \\\n    XX(jl_set_const) \\\n    XX(jl_set_errno) \\\n    XX(jl_set_global) \\\n    XX(jl_set_istopmod) \\\n    XX(jl_set_module_compile) \\\n    XX(jl_set_module_infer) \\\n    XX(jl_set_module_nospecialize) \\\n    XX(jl_set_module_optlevel) \\\n    XX(jl_set_module_uuid) \\\n    XX(jl_set_next_task) \\\n    XX(jl_set_nth_field) \\\n    XX(jl_set_ptls_states_getter) \\\n    XX(jl_set_safe_restore) \\\n    XX(jl_set_sysimg_so) \\\n    XX(jl_set_task_tid) \\\n    XX(jl_set_typeinf_func) \\\n    XX(jl_set_zero_subnormals) \\\n    XX(jl_sext_int) \\\n    XX(jl_shl_int) \\\n    XX(jl_sigatomic_begin) \\\n    XX(jl_sigatomic_end) \\\n    XX(jl_sig_throw) \\\n    XX(jl_sitofp) \\\n    XX(jl_sizeof_ios_t) \\\n    XX(jl_sizeof_jl_options) \\\n    XX(jl_sizeof_mode_t) \\\n    XX(jl_sizeof_off_t) \\\n    XX(jl_sizeof_stat) \\\n    XX(jl_sizeof_uv_fs_t) \\\n    XX(jl_sle_int) \\\n    XX(jl_slt_int) \\\n    XX(jl_smod_int) \\\n    XX(jl_sockaddr_from_addrinfo) \\\n    XX(jl_sockaddr_host4) \\\n    XX(jl_sockaddr_host6) \\\n    XX(jl_sockaddr_is_ip4) \\\n    XX(jl_sockaddr_is_ip6) \\\n    XX(jl_sockaddr_port4) \\\n    XX(jl_sockaddr_port6) \\\n    XX(jl_sockaddr_set_port) \\\n    XX(jl_spawn) \\\n    XX(jl_specializations_get_linfo) \\\n    XX(jl_specializations_lookup) \\\n    XX(jl_sqrt_llvm) \\\n    XX(jl_sqrt_llvm_fast) \\\n    XX(jl_sqrt_llvm_fast_withtype) \\\n    XX(jl_sqrt_llvm_withtype) \\\n    XX(jl_srem_int) \\\n    XX(jl_stat) \\\n    XX(jl_stat_blksize) \\\n    XX(jl_stat_blocks) \\\n    XX(jl_stat_ctime) \\\n    XX(jl_stat_dev) \\\n    XX(jl_stat_gid) \\\n    XX(jl_static_show) \\\n    XX(jl_static_show_func_sig) \\\n    XX(jl_stat_ino) \\\n    XX(jl_stat_mode) \\\n    XX(jl_stat_mtime) \\\n    XX(jl_stat_nlink) \\\n    XX(jl_stat_rdev) \\\n    XX(jl_stat_size) \\\n    XX(jl_stat_uid) \\\n    XX(jl_stderr_obj) \\\n    XX(jl_stderr_stream) \\\n    XX(jl_stdin_stream) \\\n    XX(jl_stdout_obj) \\\n    XX(jl_stdout_stream) \\\n    XX(jl_stored_inline) \\\n    XX(jl_string_ptr) \\\n    XX(jl_string_to_array) \\\n    XX(jl_strtod_c) \\\n    XX(jl_strtof_c) \\\n    XX(jl_sub_float) \\\n    XX(jl_sub_int) \\\n    XX(jl_sub_ptr) \\\n    XX(jl_substrtod) \\\n    XX(jl_substrtof) \\\n    XX(jl_subtype) \\\n    XX(jl_subtype_env) \\\n    XX(jl_subtype_env_size) \\\n    XX(jl_svec) \\\n    XX(jl_svec1) \\\n    XX(jl_svec2) \\\n    XX(jl_svec_copy) \\\n    XX(jl_svec_fill) \\\n    XX(jl_svec_isassigned) \\\n    XX(jl_svec_len) \\\n    XX(jl_svec_ref) \\\n    XX(jl_switch) \\\n    XX(jl_switchto) \\\n    XX(jl_symbol) \\\n    XX(jl_symbol_lookup) \\\n    XX(jl_symbol_n) \\\n    XX(jl_symbol_name) \\\n    XX(jl_tagged_gensym) \\\n    XX(jl_take_buffer) \\\n    XX(jl_task_get_next) \\\n    XX(jl_task_stack_buffer) \\\n    XX(jl_tcp_bind) \\\n    XX(jl_tcp_connect) \\\n    XX(jl_tcp_getpeername) \\\n    XX(jl_tcp_getsockname) \\\n    XX(jl_tcp_quickack) \\\n    XX(jl_tcp_reuseport) \\\n    XX(jl_test_cpu_feature) \\\n    XX(jl_threadid) \\\n    XX(jl_threading_enabled) \\\n    XX(jl_throw) \\\n    XX(jl_throw_out_of_memory_error) \\\n    XX(jl_too_few_args) \\\n    XX(jl_too_many_args) \\\n    XX(jl_toplevel_eval) \\\n    XX(jl_toplevel_eval_in) \\\n    XX(jl_trunc_int) \\\n    XX(jl_trunc_llvm) \\\n    XX(jl_trunc_llvm_withtype) \\\n    XX(jl_try_substrtod) \\\n    XX(jl_try_substrtof) \\\n    XX(jl_tty_set_mode) \\\n    XX(jl_tupletype_fill) \\\n    XX(jl_typeassert) \\\n    XX(jl_type_equality_is_identity) \\\n    XX(jl_type_error) \\\n    XX(jl_type_error_rt) \\\n    XX(jl_typeinf_begin) \\\n    XX(jl_typeinf_end) \\\n    XX(jl_type_intersection) \\\n    XX(jl_type_intersection_with_env) \\\n    XX(jl_typemax_uint) \\\n    XX(jl_type_morespecific) \\\n    XX(jl_type_morespecific_no_subtype) \\\n    XX(jl_typename_str) \\\n    XX(jl_typeof) \\\n    XX(jl_typeof_str) \\\n    XX(jl_types_equal) \\\n    XX(jl_type_to_llvm) \\\n    XX(jl_type_union) \\\n    XX(jl_type_unionall) \\\n    XX(jl_udiv_int) \\\n    XX(jl_udp_bind) \\\n    XX(jl_udp_send) \\\n    XX(jl_uitofp) \\\n    XX(jl_ule_int) \\\n    XX(jl_ult_int) \\\n    XX(jl_unbox_bool) \\\n    XX(jl_unbox_float32) \\\n    XX(jl_unbox_float64) \\\n    XX(jl_unbox_int16) \\\n    XX(jl_unbox_int32) \\\n    XX(jl_unbox_int64) \\\n    XX(jl_unbox_int8) \\\n    XX(jl_unbox_uint16) \\\n    XX(jl_unbox_uint32) \\\n    XX(jl_unbox_uint64) \\\n    XX(jl_unbox_uint8) \\\n    XX(jl_unbox_uint8pointer) \\\n    XX(jl_unbox_voidpointer) \\\n    XX(jl_uncompress_argname_n) \\\n    XX(jl_uncompress_argnames) \\\n    XX(jl_uncompress_ir) \\\n    XX(jl_undefined_var_error) \\\n    XX(jl_urem_int) \\\n    XX(jl_uv_associate_julia_struct) \\\n    XX(jl_uv_buf_base) \\\n    XX(jl_uv_buf_len) \\\n    XX(jl_uv_buf_set_base) \\\n    XX(jl_uv_buf_set_len) \\\n    XX(jl_uv_connect_handle) \\\n    XX(jl_uv_disassociate_julia_struct) \\\n    XX(jl_uv_file_handle) \\\n    XX(jl_uv_flush) \\\n    XX(jl_uv_fs_t_path) \\\n    XX(jl_uv_fs_t_ptr) \\\n    XX(jl_uv_handle) \\\n    XX(jl_uv_handle_data) \\\n    XX(jl_uv_handle_type) \\\n    XX(jl_uv_interface_addresses) \\\n    XX(jl_uv_interface_address_is_internal) \\\n    XX(jl_uv_interface_address_sockaddr) \\\n    XX(jl_uv_process_data) \\\n    XX(jl_uv_process_pid) \\\n    XX(jl_uv_putb) \\\n    XX(jl_uv_putc) \\\n    XX(jl_uv_puts) \\\n    XX(jl_uv_req_data) \\\n    XX(jl_uv_req_set_data) \\\n    XX(jl_uv_sizeof_interface_address) \\\n    XX(jl_uv_unix_fd_is_watched) \\\n    XX(jl_uv_write) \\\n    XX(jl_uv_writecb) \\\n    XX(jl_uv_write_handle) \\\n    XX(jl_valueof) \\\n    XX(jl_value_ptr) \\\n    XX(jl_ver_is_release) \\\n    XX(jl_ver_major) \\\n    XX(jl_ver_minor) \\\n    XX(jl_ver_patch) \\\n    XX(jl_ver_string) \\\n    XX(jl_vexceptionf) \\\n    XX(jl_vprintf) \\\n    XX(jl_wakeup_thread) \\\n    XX(jl_xor_int) \\\n    XX(jl_yield) \\\n    XX(jl_zext_int)\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/signals-mach.c": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n// Note that this file is `#include`d by \"signals-unix.c\"\n\n#include <mach/clock.h>\n#include <mach/clock_types.h>\n#include <mach/clock_reply.h>\n#include <mach/mach_traps.h>\n#include <mach/task.h>\n#include <mach/mig_errors.h>\n#include <AvailabilityMacros.h>\n\n#ifdef MAC_OS_X_VERSION_10_9\n#include <sys/_types/_ucontext64.h>\n#else\n#define __need_ucontext64_t\n#include <sys/_structs.h>\n#endif\n\n#include \"julia_assert.h\"\n\n// private keymgr stuff\n#define KEYMGR_GCC3_DW2_OBJ_LIST 302\nenum {\n  NM_ALLOW_RECURSION = 1,\n  NM_RECURSION_ILLEGAL = 2\n};\nextern void _keymgr_set_and_unlock_processwide_ptr(unsigned int key, void *ptr);\nextern int _keymgr_unlock_processwide_ptr(unsigned int key);\nextern void *_keymgr_get_and_lock_processwide_ptr(unsigned int key);\nextern int _keymgr_get_and_lock_processwide_ptr_2(unsigned int key, void **result);\nextern int _keymgr_set_lockmode_processwide_ptr(unsigned int key, unsigned int mode);\n\nstatic void attach_exception_port(thread_port_t thread, int segv_only);\n\n// low 16 bits are the thread id, the next 8 bits are the original gc_state\nstatic arraylist_t suspended_threads;\nvoid jl_mach_gc_end(void)\n{\n    // Requires the safepoint lock to be held\n    for (size_t i = 0; i < suspended_threads.len; i++) {\n        uintptr_t item = (uintptr_t)suspended_threads.items[i];\n        int16_t tid = (int16_t)item;\n        int8_t gc_state = (int8_t)(item >> 8);\n        jl_ptls_t ptls2 = jl_all_tls_states[tid];\n        jl_atomic_store_release(&ptls2->gc_state, gc_state);\n        thread_resume(pthread_mach_thread_np(ptls2->system_id));\n    }\n    suspended_threads.len = 0;\n}\n\n// Suspend the thread and return `1` if the GC is running.\n// Otherwise return `0`\nstatic int jl_mach_gc_wait(jl_ptls_t ptls2,\n                           mach_port_t thread, int16_t tid)\n{\n    jl_mutex_lock_nogc(&safepoint_lock);\n    if (!jl_atomic_load_relaxed(&jl_gc_running)) {\n        // relaxed, since gets set to zero only while the safepoint_lock was held\n        // this means we can tell if GC is done before we got the message or\n        // the safepoint was enabled for SIGINT.\n        jl_mutex_unlock_nogc(&safepoint_lock);\n        return 0;\n    }\n    // Otherwise, set the gc state of the thread, suspend and record it\n    int8_t gc_state = ptls2->gc_state;\n    jl_atomic_store_release(&ptls2->gc_state, JL_GC_STATE_WAITING);\n    uintptr_t item = tid | (((uintptr_t)gc_state) << 16);\n    arraylist_push(&suspended_threads, (void*)item);\n    thread_suspend(thread);\n    jl_mutex_unlock_nogc(&safepoint_lock);\n    return 1;\n}\n\nstatic mach_port_t segv_port = 0;\n\nextern boolean_t exc_server(mach_msg_header_t *, mach_msg_header_t *);\n\n#define STR(x) #x\n#define XSTR(x) STR(x)\n#define HANDLE_MACH_ERROR(msg, retval) \\\n    if (retval != KERN_SUCCESS) { mach_error(msg XSTR(: __FILE__:__LINE__:), (retval)); jl_exit(1); }\n\nvoid *mach_segv_listener(void *arg)\n{\n    (void)arg;\n    while (1) {\n        int ret = mach_msg_server(exc_server, 2048, segv_port, MACH_MSG_TIMEOUT_NONE);\n        jl_safe_printf(\"mach_msg_server: %s\\n\", mach_error_string(ret));\n        jl_exit(128 + SIGSEGV);\n    }\n}\n\nstatic void allocate_segv_handler()\n{\n    // ensure KEYMGR_GCC3_DW2_OBJ_LIST is initialized, as this requires malloc\n    // and thus can deadlock when used without first initializing it.\n    // Apple caused this problem in their libunwind in 10.9 (circa keymgr-28)\n    // when they removed this part of the code from keymgr.\n    // Much thanks to Apple for providing source code, or this would probably\n    // have simply remained unsolved forever on their platform.\n    // This is similar to just calling checkKeyMgrRegisteredFDEs\n    // (this is quite thread-unsafe)\n    if (_keymgr_set_lockmode_processwide_ptr(KEYMGR_GCC3_DW2_OBJ_LIST, NM_ALLOW_RECURSION))\n        jl_error(\"_keymgr_set_lockmode_processwide_ptr failed\");\n\n    arraylist_new(&suspended_threads, jl_n_threads);\n    pthread_t thread;\n    pthread_attr_t attr;\n    kern_return_t ret;\n    mach_port_t self = mach_task_self();\n    ret = mach_port_allocate(self, MACH_PORT_RIGHT_RECEIVE, &segv_port);\n    HANDLE_MACH_ERROR(\"mach_port_allocate\",ret);\n    ret = mach_port_insert_right(self, segv_port, segv_port, MACH_MSG_TYPE_MAKE_SEND);\n    HANDLE_MACH_ERROR(\"mach_port_insert_right\",ret);\n    // Alright, create a thread to serve as the listener for exceptions\n    if (pthread_attr_init(&attr) != 0) {\n        jl_error(\"pthread_attr_init failed\");\n    }\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n    if (pthread_create(&thread, &attr, mach_segv_listener, NULL) != 0) {\n        jl_error(\"pthread_create failed\");\n    }\n    pthread_attr_destroy(&attr);\n    for (int16_t tid = 0;tid < jl_n_threads;tid++) {\n        attach_exception_port(pthread_mach_thread_np(jl_all_tls_states[tid]->system_id), 0);\n    }\n}\n\n#ifdef LLVMLIBUNWIND\nvolatile mach_port_t mach_profiler_thread = 0;\nstatic kern_return_t profiler_segv_handler\n                (mach_port_t                          exception_port,\n                 mach_port_t                                  thread,\n                 mach_port_t                                    task,\n                 exception_type_t                          exception,\n                 exception_data_t                               code,\n                 mach_msg_type_number_t                   code_count);\n#endif\n\n#if defined(_CPU_X86_64_)\ntypedef x86_thread_state64_t host_thread_state_t;\ntypedef x86_exception_state64_t host_exception_state_t;\n#define THREAD_STATE x86_THREAD_STATE64\n#define THREAD_STATE_COUNT x86_THREAD_STATE64_COUNT\n#define HOST_EXCEPTION_STATE x86_EXCEPTION_STATE64\n#define HOST_EXCEPTION_STATE_COUNT x86_EXCEPTION_STATE64_COUNT\n\nenum x86_trap_flags {\n    USER_MODE = 0x4,\n    WRITE_FAULT = 0x2,\n    PAGE_PRESENT = 0x1\n};\n\n#elif defined(_CPU_AARCH64_)\ntypedef arm_thread_state64_t host_thread_state_t;\ntypedef arm_exception_state64_t host_exception_state_t;\n#define THREAD_STATE ARM_THREAD_STATE64\n#define THREAD_STATE_COUNT ARM_THREAD_STATE64_COUNT\n#define HOST_EXCEPTION_STATE ARM_EXCEPTION_STATE64\n#define HOST_EXCEPTION_STATE_COUNT ARM_EXCEPTION_STATE64_COUNT\n#endif\n\nstatic void jl_call_in_state(jl_ptls_t ptls2, host_thread_state_t *state,\n                             void (*fptr)(void))\n{\n    uint64_t rsp = (uint64_t)ptls2->signal_stack + sig_stack_size;\n    assert(rsp % 16 == 0);\n\n    // push (null) $RIP onto the stack\n    rsp -= sizeof(void*);\n    *(void**)rsp = NULL;\n\n#ifdef _CPU_X86_64_\n    state->__rsp = rsp; // set stack pointer\n    state->__rip = (uint64_t)fptr; // \"call\" the function\n#else\n    state->__sp = rsp;\n    state->__pc = (uint64_t)fptr;\n#endif\n}\n\nstatic void jl_throw_in_thread(int tid, mach_port_t thread, jl_value_t *exception)\n{\n    unsigned int count = THREAD_STATE_COUNT;\n    host_thread_state_t state;\n    kern_return_t ret = thread_get_state(thread, THREAD_STATE, (thread_state_t)&state, &count);\n    HANDLE_MACH_ERROR(\"thread_get_state\", ret);\n    jl_ptls_t ptls2 = jl_all_tls_states[tid];\n    if (!ptls2->safe_restore) {\n        assert(exception);\n        ptls2->bt_size = rec_backtrace_ctx(ptls2->bt_data, JL_MAX_BT_SIZE,\n                                           (bt_context_t*)&state, ptls2->pgcstack);\n        ptls2->sig_exception = exception;\n    }\n    jl_call_in_state(ptls2, &state, &jl_sig_throw);\n    ret = thread_set_state(thread, THREAD_STATE,\n                           (thread_state_t)&state, count);\n    HANDLE_MACH_ERROR(\"thread_set_state\", ret);\n}\n\n//exc_server uses dlsym to find symbol\nJL_DLLEXPORT\nkern_return_t catch_exception_raise(mach_port_t            exception_port,\n                                    mach_port_t            thread,\n                                    mach_port_t            task,\n                                    exception_type_t       exception,\n                                    exception_data_t       code,\n                                    mach_msg_type_number_t code_count)\n{\n    unsigned int count = THREAD_STATE_COUNT;\n    unsigned int exc_count = HOST_EXCEPTION_STATE_COUNT;\n    host_exception_state_t exc_state;\n    host_thread_state_t state;\n#ifdef LLVMLIBUNWIND\n    if (thread == mach_profiler_thread) {\n        return profiler_segv_handler(exception_port, thread, task, exception, code, code_count);\n    }\n#endif\n    int16_t tid;\n    jl_ptls_t ptls2 = NULL;\n    for (tid = 0;tid < jl_n_threads;tid++) {\n        jl_ptls_t _ptls2 = jl_all_tls_states[tid];\n        if (pthread_mach_thread_np(_ptls2->system_id) == thread) {\n            ptls2 = _ptls2;\n            break;\n        }\n    }\n    if (!ptls2) {\n        // We don't know about this thread, let the kernel try another handler\n        // instead. This shouldn't actually happen since we only register the\n        // handler for the threads we know about.\n        jl_safe_printf(\"ERROR: Exception handler triggered on unmanaged thread.\\n\");\n        return KERN_INVALID_ARGUMENT;\n    }\n    if (exception == EXC_ARITHMETIC) {\n        jl_throw_in_thread(tid, thread, jl_diverror_exception);\n        return KERN_SUCCESS;\n    }\n    assert(exception == EXC_BAD_ACCESS);\n    kern_return_t ret = thread_get_state(thread, HOST_EXCEPTION_STATE, (thread_state_t)&exc_state, &exc_count);\n    HANDLE_MACH_ERROR(\"thread_get_state\", ret);\n#ifdef _CPU_X86_64_\n    uint64_t fault_addr = exc_state.__faultvaddr;\n#else\n    uint64_t fault_addr = exc_state.__far;\n#endif\n    if (jl_addr_is_safepoint(fault_addr)) {\n        if (jl_mach_gc_wait(ptls2, thread, tid))\n            return KERN_SUCCESS;\n        if (ptls2->tid != 0)\n            return KERN_SUCCESS;\n        if (ptls2->defer_signal) {\n            jl_safepoint_defer_sigint();\n        }\n        else if (jl_safepoint_consume_sigint()) {\n            jl_clear_force_sigint();\n            jl_throw_in_thread(tid, thread, jl_interrupt_exception);\n        }\n        return KERN_SUCCESS;\n    }\n    if (ptls2->safe_restore) {\n        jl_throw_in_thread(tid, thread, jl_stackovf_exception);\n        return KERN_SUCCESS;\n    }\n#ifdef SEGV_EXCEPTION\n    if (1) {\n#else\n    if (msync((void*)(fault_addr & ~(jl_page_size - 1)), 1, MS_ASYNC) == 0) { // check if this was a valid address\n#endif\n        jl_value_t *excpt;\n        if (is_addr_on_stack(ptls2, (void*)fault_addr)) {\n            excpt = jl_stackovf_exception;\n        }\n#ifdef SEGV_EXCEPTION\n        else if (msync((void*)(fault_addr & ~(jl_page_size - 1)), 1, MS_ASYNC) != 0) {\n            // no page mapped at this address\n            excpt = jl_segv_exception;\n        }\n#endif\n        else {\n            if (!(exc_state.__err & WRITE_FAULT))\n                return KERN_INVALID_ARGUMENT; // rethrow the SEGV since it wasn't an error with writing to read-only memory\n            excpt = jl_readonlymemory_exception;\n        }\n        jl_throw_in_thread(tid, thread, excpt);\n\n        return KERN_SUCCESS;\n    }\n    else {\n        kern_return_t ret = thread_get_state(thread, THREAD_STATE, (thread_state_t)&state, &count);\n        HANDLE_MACH_ERROR(\"thread_get_state\", ret);\n        jl_critical_error(SIGSEGV, (unw_context_t*)&state,\n                          ptls2->bt_data, &ptls2->bt_size);\n        return KERN_INVALID_ARGUMENT;\n    }\n}\n\nstatic void attach_exception_port(thread_port_t thread, int segv_only)\n{\n    kern_return_t ret;\n    // http://www.opensource.apple.com/source/xnu/xnu-2782.1.97/osfmk/man/thread_set_exception_ports.html\n    exception_mask_t mask = EXC_MASK_BAD_ACCESS;\n    if (!segv_only)\n        mask |= EXC_MASK_ARITHMETIC;\n    ret = thread_set_exception_ports(thread, mask, segv_port, EXCEPTION_DEFAULT, MACHINE_THREAD_STATE);\n    HANDLE_MACH_ERROR(\"thread_set_exception_ports\", ret);\n}\n\nstatic void jl_thread_suspend_and_get_state(int tid, unw_context_t **ctx)\n{\n    jl_ptls_t ptls2 = jl_all_tls_states[tid];\n    mach_port_t tid_port = pthread_mach_thread_np(ptls2->system_id);\n\n    kern_return_t ret = thread_suspend(tid_port);\n    HANDLE_MACH_ERROR(\"thread_suspend\", ret);\n\n    // Do the actual sampling\n    unsigned int count = THREAD_STATE_COUNT;\n    static unw_context_t state;\n    memset(&state, 0, sizeof(unw_context_t));\n\n    // Get the state of the suspended thread\n    ret = thread_get_state(tid_port, THREAD_STATE, (thread_state_t)&state, &count);\n\n    // Initialize the unwind context with the suspend thread's state\n    *ctx = &state;\n}\n\nstatic void jl_thread_resume(int tid, int sig)\n{\n    jl_ptls_t ptls2 = jl_all_tls_states[tid];\n    mach_port_t thread = pthread_mach_thread_np(ptls2->system_id);\n    kern_return_t ret = thread_resume(thread);\n    HANDLE_MACH_ERROR(\"thread_resume\", ret);\n}\n\n// Throw jl_interrupt_exception if the master thread is in a signal async region\n// or if SIGINT happens too often.\nstatic void jl_try_deliver_sigint(void)\n{\n    jl_ptls_t ptls2 = jl_all_tls_states[0];\n    mach_port_t thread = pthread_mach_thread_np(ptls2->system_id);\n\n    kern_return_t ret = thread_suspend(thread);\n    HANDLE_MACH_ERROR(\"thread_suspend\", ret);\n\n    // This aborts `sleep` and other syscalls.\n    ret = thread_abort(thread);\n    HANDLE_MACH_ERROR(\"thread_abort\", ret);\n\n    jl_safepoint_enable_sigint();\n    int force = jl_check_force_sigint();\n    if (force || (!ptls2->defer_signal && ptls2->io_wait)) {\n        jl_safepoint_consume_sigint();\n        if (force)\n            jl_safe_printf(\"WARNING: Force throwing a SIGINT\\n\");\n        jl_clear_force_sigint();\n        jl_throw_in_thread(0, thread, jl_interrupt_exception);\n    }\n    else {\n        jl_wake_libuv();\n    }\n\n    ret = thread_resume(thread);\n    HANDLE_MACH_ERROR(\"thread_resume\", ret);\n}\n\nstatic void jl_exit_thread0(int exitstate)\n{\n    jl_ptls_t ptls2 = jl_all_tls_states[0];\n    mach_port_t thread = pthread_mach_thread_np(ptls2->system_id);\n    kern_return_t ret = thread_suspend(thread);\n    HANDLE_MACH_ERROR(\"thread_suspend\", ret);\n\n    // This aborts `sleep` and other syscalls.\n    ret = thread_abort(thread);\n    HANDLE_MACH_ERROR(\"thread_abort\", ret);\n\n    unsigned int count = THREAD_STATE_COUNT;\n    host_thread_state_t state;\n    ret = thread_get_state(thread, THREAD_STATE,\n                           (thread_state_t)&state, &count);\n\n    void (*exit_func)(int) = &_exit;\n    if (thread0_exit_count <= 1) {\n        exit_func = &jl_exit;\n    }\n    else if (thread0_exit_count == 2) {\n        exit_func = &exit;\n    }\n\n#ifdef _CPU_X86_64_\n    // First integer argument. Not portable but good enough =)\n    state.__rdi = exitstate;\n#elif defined(_CPU_AARCH64_)\n    state.__x[0] = exitstate;\n#else\n#error Fill in first integer argument here\n#endif\n    jl_call_in_state(ptls2, &state, (void (*)(void))exit_func);\n    ret = thread_set_state(thread, THREAD_STATE,\n                           (thread_state_t)&state, count);\n    HANDLE_MACH_ERROR(\"thread_set_state\", ret);\n\n    ret = thread_resume(thread);\n    HANDLE_MACH_ERROR(\"thread_resume\", ret);\n}\n\nstatic int profile_started = 0;\nmach_timespec_t timerprof;\nstatic pthread_t profiler_thread;\nclock_serv_t clk;\nstatic mach_port_t profile_port = 0;\n\n#ifdef LLVMLIBUNWIND\nvolatile static int forceDwarf = -2;\nstatic unw_context_t profiler_uc;\n\nstatic kern_return_t profiler_segv_handler\n                (mach_port_t                          exception_port,\n                 mach_port_t                                  thread,\n                 mach_port_t                                    task,\n                 exception_type_t                          exception,\n                 exception_data_t                               code,\n                 mach_msg_type_number_t                   code_count)\n{\n    assert(thread == mach_profiler_thread);\n    host_thread_state_t state;\n\n    // Not currently unwinding. Raise regular segfault\n    if (forceDwarf == -2)\n        return KERN_INVALID_ARGUMENT;\n\n    if (forceDwarf == 0)\n        forceDwarf = 1;\n    else\n        forceDwarf = -1;\n\n    unsigned int count = THREAD_STATE_COUNT;\n\n    thread_get_state(thread, THREAD_STATE, (thread_state_t)&state, &count);\n\n#ifdef _CPU_X86_64_\n    // don't change cs fs gs rflags\n    uint64_t cs = state.__cs;\n    uint64_t fs = state.__fs;\n    uint64_t gs = state.__gs;\n    uint64_t rflags = state.__rflags;\n#elif defined(_CPU_AARCH64_)\n    uint64_t cpsr = state.__cpsr;\n#else\n#error Unknown CPU\n#endif\n\n    memcpy(&state, &profiler_uc, sizeof(state));\n\n#ifdef _CPU_X86_64_\n    state.__cs = cs;\n    state.__fs = fs;\n    state.__gs = gs;\n    state.__rflags = rflags;\n#else\n    state.__cpsr = cpsr;\n#endif\n\n    kern_return_t ret = thread_set_state(thread, THREAD_STATE, (thread_state_t)&state, count);\n    HANDLE_MACH_ERROR(\"thread_set_state\", ret);\n\n    return KERN_SUCCESS;\n}\n#endif\n\nvoid *mach_profile_listener(void *arg)\n{\n    (void)arg;\n    int i;\n    const int max_size = 512;\n    attach_exception_port(mach_thread_self(), 1);\n#ifdef LLVMLIBUNWIND\n    mach_profiler_thread = mach_thread_self();\n#endif\n    mig_reply_error_t *bufRequest = (mig_reply_error_t*)malloc_s(max_size);\n    while (1) {\n        kern_return_t ret = mach_msg(&bufRequest->Head, MACH_RCV_MSG,\n                                     0, max_size, profile_port,\n                                     MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);\n        HANDLE_MACH_ERROR(\"mach_msg\", ret);\n        // sample each thread, round-robin style in reverse order\n        // (so that thread zero gets notified last)\n        jl_lock_profile();\n        void *unused = NULL;\n        int keymgr_locked = _keymgr_get_and_lock_processwide_ptr_2(KEYMGR_GCC3_DW2_OBJ_LIST, &unused) == 0;\n        for (i = jl_n_threads; i-- > 0; ) {\n            // if there is no space left, break early\n            if (jl_profile_is_buffer_full()) {\n                jl_profile_stop_timer();\n                break;\n            }\n\n            unw_context_t *uc;\n            jl_thread_suspend_and_get_state(i, &uc);\n            if (running) {\n#ifdef LLVMLIBUNWIND\n                /*\n                 *  Unfortunately compact unwind info is incorrectly generated for quite a number of\n                 *  libraries by quite a large number of compilers. We can fall back to DWARF unwind info\n                 *  in some cases, but in quite a number of cases (especially libraries not compiled in debug\n                 *  mode, only the compact unwind info may be available). Even more unfortunately, there is no\n                 *  way to detect such bogus compact unwind info (other than noticing the resulting segfault).\n                 *  What we do here is ugly, but necessary until the compact unwind info situation improves.\n                 *  We try to use the compact unwind info and if that results in a segfault, we retry with DWARF info.\n                 *  Note that in a small number of cases this may result in bogus stack traces, but at least the topmost\n                 *  entry will always be correct, and the number of cases in which this is an issue is rather small.\n                 *  Other than that, this implementation is not incorrect as the other thread is paused while we are profiling\n                 *  and during stack unwinding we only ever read memory, but never write it.\n                 */\n\n                forceDwarf = 0;\n                unw_getcontext(&profiler_uc); // will resume from this point if the next lines segfault at any point\n\n                if (forceDwarf == 0) {\n                    // Save the backtrace\n                    bt_size_cur += rec_backtrace_ctx((jl_bt_element_t*)bt_data_prof + bt_size_cur, bt_size_max - bt_size_cur - 1, uc, NULL);\n                }\n                else if (forceDwarf == 1) {\n                    bt_size_cur += rec_backtrace_ctx_dwarf((jl_bt_element_t*)bt_data_prof + bt_size_cur, bt_size_max - bt_size_cur - 1, uc, NULL);\n                }\n                else if (forceDwarf == -1) {\n                    jl_safe_printf(\"WARNING: profiler attempt to access an invalid memory location\\n\");\n                }\n\n                forceDwarf = -2;\n#else\n                bt_size_cur += rec_backtrace_ctx((jl_bt_element_t*)bt_data_prof + bt_size_cur, bt_size_max - bt_size_cur - 1, uc, NULL);\n#endif\n\n                // Mark the end of this block with 0\n                bt_data_prof[bt_size_cur++].uintptr = 0;\n            }\n            // We're done! Resume the thread.\n            jl_thread_resume(i, 0);\n        }\n        if (keymgr_locked)\n            _keymgr_unlock_processwide_ptr(KEYMGR_GCC3_DW2_OBJ_LIST);\n        jl_unlock_profile();\n        if (running) {\n            // Reset the alarm\n            kern_return_t ret = clock_alarm(clk, TIME_RELATIVE, timerprof, profile_port);\n            HANDLE_MACH_ERROR(\"clock_alarm\", ret)\n        }\n    }\n}\n\nJL_DLLEXPORT int jl_profile_start_timer(void)\n{\n    kern_return_t ret;\n    if (!profile_started) {\n        mach_port_t self = mach_task_self();\n\n        ret = host_get_clock_service(mach_host_self(), SYSTEM_CLOCK, (clock_serv_t *)&clk);\n        HANDLE_MACH_ERROR(\"host_get_clock_service\", ret);\n\n        ret = mach_port_allocate(self, MACH_PORT_RIGHT_RECEIVE, &profile_port);\n        HANDLE_MACH_ERROR(\"mach_port_allocate\", ret);\n\n        // Alright, create a thread to serve as the listener for exceptions\n        pthread_attr_t attr;\n        if (pthread_attr_init(&attr) != 0) {\n            jl_error(\"pthread_attr_init failed\");\n        }\n        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n        if (pthread_create(&profiler_thread, &attr, mach_profile_listener, NULL) != 0) {\n            jl_error(\"pthread_create failed\");\n        }\n        pthread_attr_destroy(&attr);\n\n        profile_started = 1;\n    }\n\n    timerprof.tv_sec = nsecprof/GIGA;\n    timerprof.tv_nsec = nsecprof%GIGA;\n\n    running = 1;\n    // ensure the alarm is running\n    ret = clock_alarm(clk, TIME_RELATIVE, timerprof, profile_port);\n    HANDLE_MACH_ERROR(\"clock_alarm\", ret);\n\n    return 0;\n}\n\nJL_DLLEXPORT void jl_profile_stop_timer(void)\n{\n    running = 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/sys.c": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n/*\n  sys.c\n  I/O and operating system utility functions\n*/\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <fcntl.h>\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n\n#ifdef _OS_WINDOWS_\n#include <psapi.h>\n#else\n#include <unistd.h>\n#if !defined(_SC_NPROCESSORS_ONLN) || defined(_OS_FREEBSD_) || defined(_OS_DARWIN_)\n// try secondary location for _SC_NPROCESSORS_ONLN, or for HW_AVAILCPU on BSDs\n#include <sys/sysctl.h>\n#endif\n#include <sys/wait.h>\n#include <sys/ptrace.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#endif\n\n#ifndef _OS_WINDOWS_\n// for getrusage\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#endif\n\n#ifdef __APPLE__\n#include <mach-o/dyld.h>\n#include <mach-o/nlist.h>\n#include <sys/types.h> // for jl_raise_debugger\n#elif !defined(_OS_WINDOWS_)\n#include <link.h>\n#endif\n\n#ifdef __SSE__\n#include <xmmintrin.h>\n#endif\n\n#if defined _MSC_VER\n#include <io.h>\n#include <intrin.h>\n#endif\n\n#ifdef JL_MSAN_ENABLED\n#include <sanitizer/msan_interface.h>\n#endif\n\n#include \"julia_assert.h\"\n\n#include <llvm-c/Core.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(_OS_WINDOWS_) && !defined(_COMPILER_GCC_)\nJL_DLLEXPORT char *dirname(char *);\n#else\n#include <libgen.h>\n#endif\n\nJL_DLLEXPORT int jl_sizeof_off_t(void) { return sizeof(off_t); }\n#ifndef _OS_WINDOWS_\nJL_DLLEXPORT int jl_sizeof_mode_t(void) { return sizeof(mode_t); }\nJL_DLLEXPORT int jl_ftruncate(int fd, int64_t length)\n{\n    return ftruncate(fd, (off_t)length);\n}\nJL_DLLEXPORT int64_t jl_lseek(int fd, int64_t offset, int whence)\n{\n    return lseek(fd, (off_t)offset, whence);\n}\nJL_DLLEXPORT ssize_t jl_pwrite(int fd, const void *buf, size_t count, int64_t offset)\n{\n    return pwrite(fd, buf, count, (off_t)offset);\n}\nJL_DLLEXPORT void *jl_mmap(void *addr, size_t length, int prot, int flags,\n                           int fd, int64_t offset)\n{\n    return mmap(addr, length, prot, flags, fd, (off_t)offset);\n}\n#else\nJL_DLLEXPORT int64_t jl_lseek(HANDLE fd, int64_t offset, int whence)\n{\n    LARGE_INTEGER tell;\n    tell.QuadPart = offset;\n    if (SetFilePointerEx(fd, tell, &tell, whence) == 0)\n        return -1;\n    return tell.QuadPart;\n}\n#endif\nJL_DLLEXPORT int jl_sizeof_ios_t(void) { return sizeof(ios_t); }\n\nJL_DLLEXPORT long jl_ios_fd(ios_t *s) { return s->fd; }\n\nJL_DLLEXPORT int32_t jl_nb_available(ios_t *s)\n{\n    return (int32_t)(s->size - s->bpos);\n}\n\n// --- dir/file stuff ---\n\nJL_DLLEXPORT int jl_sizeof_uv_fs_t(void) { return sizeof(uv_fs_t); }\nJL_DLLEXPORT char *jl_uv_fs_t_ptr(uv_fs_t *req) { return (char*)req->ptr; }\nJL_DLLEXPORT char *jl_uv_fs_t_path(uv_fs_t *req) { return (char*)req->path; }\n\n// --- stat ---\nJL_DLLEXPORT int jl_sizeof_stat(void) { return sizeof(uv_stat_t); }\n\nJL_DLLEXPORT int32_t jl_stat(const char *path, char *statbuf) JL_NOTSAFEPOINT\n{\n    uv_fs_t req;\n    int ret;\n\n    // Ideally one would use the statbuf for the storage in req, but\n    // it's not clear that this is possible using libuv\n    ret = uv_fs_stat(unused_uv_loop_arg, &req, path, NULL);\n    if (ret == 0)\n        memcpy(statbuf, req.ptr, sizeof(uv_stat_t));\n    uv_fs_req_cleanup(&req);\n    return ret;\n}\n\nJL_DLLEXPORT int32_t jl_lstat(const char *path, char *statbuf)\n{\n    uv_fs_t req;\n    int ret;\n\n    ret = uv_fs_lstat(unused_uv_loop_arg, &req, path, NULL);\n    if (ret == 0)\n        memcpy(statbuf, req.ptr, sizeof(uv_stat_t));\n    uv_fs_req_cleanup(&req);\n    return ret;\n}\n\nJL_DLLEXPORT int32_t jl_fstat(uv_os_fd_t fd, char *statbuf)\n{\n    uv_fs_t req;\n    int ret;\n\n    ret = uv_fs_fstat(unused_uv_loop_arg, &req, fd, NULL);\n    if (ret == 0)\n        memcpy(statbuf, req.ptr, sizeof(uv_stat_t));\n    uv_fs_req_cleanup(&req);\n    return ret;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_dev(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_dev;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_ino(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_ino;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_mode(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_mode;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_nlink(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_nlink;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_uid(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_uid;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_gid(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_gid;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_rdev(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_rdev;\n}\n\nJL_DLLEXPORT uint64_t jl_stat_size(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_size;\n}\n\nJL_DLLEXPORT uint64_t jl_stat_blksize(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_blksize;\n}\n\nJL_DLLEXPORT uint64_t jl_stat_blocks(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_blocks;\n}\n\n/*\n// atime is stupid, let's not support it\nJL_DLLEXPORT double jl_stat_atime(char *statbuf)\n{\n  uv_stat_t *s;\n  s = (uv_stat_t*)statbuf;\n  return (double)s->st_atim.tv_sec + (double)s->st_atim.tv_nsec * 1e-9;\n}\n*/\n\nJL_DLLEXPORT double jl_stat_mtime(char *statbuf)\n{\n    uv_stat_t *s;\n    s = (uv_stat_t*)statbuf;\n    return (double)s->st_mtim.tv_sec + (double)s->st_mtim.tv_nsec * 1e-9;\n}\n\nJL_DLLEXPORT double jl_stat_ctime(char *statbuf)\n{\n    uv_stat_t *s;\n    s = (uv_stat_t*)statbuf;\n    return (double)s->st_ctim.tv_sec + (double)s->st_ctim.tv_nsec * 1e-9;\n}\n\n// --- buffer manipulation ---\n\nJL_DLLEXPORT jl_array_t *jl_take_buffer(ios_t *s)\n{\n    size_t n;\n    jl_array_t *a;\n    if (s->buf == &s->local[0]) {\n        // small data case. copies, but this can be avoided using the\n        // technique of jl_readuntil below.\n        a = jl_pchar_to_array(s->buf, s->size);\n        ios_trunc(s, 0);\n    }\n    else {\n        char *b = ios_take_buffer(s, &n);\n        a = jl_ptr_to_array_1d(jl_array_uint8_type, b, n-1, 1);\n    }\n    return a;\n}\n\n// str: if 1 return a string, otherwise return a Vector{UInt8}\n// chomp:\n//   0 - keep delimiter\n//   1 - remove 1 byte delimiter\n//   2 - remove 2 bytes \\r\\n if present\nJL_DLLEXPORT jl_value_t *jl_readuntil(ios_t *s, uint8_t delim, uint8_t str, uint8_t chomp)\n{\n    jl_array_t *a;\n    // manually inlined common case\n    char *pd = (char*)memchr(s->buf + s->bpos, delim, (size_t)(s->size - s->bpos));\n    if (pd) {\n        size_t n = pd - (s->buf + s->bpos) + 1;\n        size_t nchomp = 0;\n        if (chomp) {\n            nchomp = chomp == 2 ? ios_nchomp(s, n) : 1;\n        }\n        if (str) {\n            jl_value_t *str = jl_pchar_to_string(s->buf + s->bpos, n - nchomp);\n            s->bpos += n;\n            return str;\n        }\n        a = jl_alloc_array_1d(jl_array_uint8_type, n - nchomp);\n        memcpy(jl_array_data(a), s->buf + s->bpos, n - nchomp);\n        s->bpos += n;\n    }\n    else {\n        a = jl_alloc_array_1d(jl_array_uint8_type, 80);\n        ios_t dest;\n        ios_mem(&dest, 0);\n        ios_setbuf(&dest, (char*)a->data, 80, 0);\n        size_t n = ios_copyuntil(&dest, s, delim);\n        if (chomp && n > 0 && dest.buf[n - 1] == delim) {\n            n--;\n            if (chomp == 2 && n > 0 && dest.buf[n - 1] == '\\r') {\n                n--;\n            }\n            int truncret = ios_trunc(&dest, n); // it should always be possible to truncate dest\n            assert(truncret == 0);\n            (void)truncret; // ensure the variable is used to avoid warnings\n        }\n        if (dest.buf != a->data) {\n            a = jl_take_buffer(&dest);\n        }\n        else {\n#ifdef STORE_ARRAY_LEN\n            a->length = n;\n#endif\n            a->nrows = n;\n            ((char*)a->data)[n] = '\\0';\n        }\n        if (str) {\n            JL_GC_PUSH1(&a);\n            jl_value_t *st = jl_array_to_string(a);\n            JL_GC_POP();\n            return st;\n        }\n    }\n    return (jl_value_t*)a;\n}\n\nJL_DLLEXPORT int jl_ios_buffer_n(ios_t *s, const size_t n)\n{\n    size_t space, ret;\n    do {\n        space = (size_t)(s->size - s->bpos);\n        ret = ios_readprep(s, n);\n        if (space == ret && ret < n)\n            return 1;\n    } while (ret < n);\n    return 0;\n}\n\nJL_DLLEXPORT uint64_t jl_ios_get_nbyte_int(ios_t *s, const size_t n)\n{\n    assert(n <= 8);\n    uint64_t x = 0;\n    uint8_t *buf = (uint8_t*)&s->buf[s->bpos];\n    if (n == 8) {\n        // expecting loop unrolling optimization\n        for (size_t i = 0; i < 8; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n    }\n    else if (n >= 4) {\n        // expecting loop unrolling optimization\n        for (size_t i = 0; i < 4; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n        for (size_t i = 4; i < n; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n    }\n    else {\n        for (size_t i = 0; i < n; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n    }\n    s->bpos += n;\n    return x;\n}\n\n// -- syscall utilities --\n\nJL_DLLEXPORT int jl_errno(void) JL_NOTSAFEPOINT { return errno; }\nJL_DLLEXPORT void jl_set_errno(int e) JL_NOTSAFEPOINT { errno = e; }\n\n// -- get the number of CPU threads (logical cores) --\n\n#ifdef _OS_WINDOWS_\ntypedef DWORD (WINAPI *GAPC)(WORD);\n#ifndef ALL_PROCESSOR_GROUPS\n#define ALL_PROCESSOR_GROUPS 0xffff\n#endif\n#endif\n\nJL_DLLEXPORT int jl_cpu_threads(void) JL_NOTSAFEPOINT\n{\n#if defined(HW_AVAILCPU) && defined(HW_NCPU)\n    size_t len = 4;\n    int32_t count;\n    int nm[2] = {CTL_HW, HW_AVAILCPU};\n    sysctl(nm, 2, &count, &len, NULL, 0);\n    if (count < 1) {\n        nm[1] = HW_NCPU;\n        sysctl(nm, 2, &count, &len, NULL, 0);\n        if (count < 1) { count = 1; }\n    }\n    return count;\n#elif defined(_SC_NPROCESSORS_ONLN)\n    long count = sysconf(_SC_NPROCESSORS_ONLN);\n    if (count < 1)\n        return 1;\n    return count;\n#elif defined(_OS_WINDOWS_)\n    //Try to get WIN7 API method\n    GAPC gapc;\n    if (jl_dlsym(jl_kernel32_handle, \"GetActiveProcessorCount\", (void **)&gapc, 0)) {\n        return gapc(ALL_PROCESSOR_GROUPS);\n    }\n    else { //fall back on GetSystemInfo\n        SYSTEM_INFO info;\n        GetSystemInfo(&info);\n        return info.dwNumberOfProcessors;\n    }\n#else\n#warning \"cpu core detection not defined for this platform\"\n    return 1;\n#endif\n}\n\n\n// -- high resolution timers --\n// Returns time in nanosec\nJL_DLLEXPORT uint64_t jl_hrtime(void) JL_NOTSAFEPOINT\n{\n    return uv_hrtime();\n}\n\n// -- iterating the environment --\n\n#ifdef __APPLE__\n#include <crt_externs.h>\n#else\n#if !defined(_OS_WINDOWS_) || defined(_COMPILER_GCC_)\nextern char **environ;\n#endif\n#endif\n\nJL_DLLEXPORT jl_value_t *jl_environ(int i)\n{\n#ifdef __APPLE__\n    char **environ = *_NSGetEnviron();\n#endif\n    char *env = environ[i];\n    return env ? jl_pchar_to_string(env, strlen(env)) : jl_nothing;\n}\n\n// -- child process status --\n\n#if defined _MSC_VER || defined _OS_WINDOWS_\n/* Native Woe32 API.  */\n#include <process.h>\n#define waitpid(pid,statusp,options) _cwait (statusp, pid, WAIT_CHILD)\n#define WAIT_T int\n#define WTERMSIG(x) ((x) & 0xff) /* or: SIGABRT ?? */\n#define WCOREDUMP(x) 0\n#define WEXITSTATUS(x) (((x) >> 8) & 0xff) /* or: (x) ?? */\n#define WIFSIGNALED(x) (WTERMSIG (x) != 0) /* or: ((x) == 3) ?? */\n#define WIFEXITED(x) (WTERMSIG (x) == 0) /* or: ((x) != 3) ?? */\n#define WIFSTOPPED(x) 0\n#define WSTOPSIG(x) 0 //Is this correct?\n#endif\n\nint jl_process_exited(int status)      { return WIFEXITED(status); }\nint jl_process_signaled(int status)    { return WIFSIGNALED(status); }\nint jl_process_stopped(int status)     { return WIFSTOPPED(status); }\n\nint jl_process_exit_status(int status) { return WEXITSTATUS(status); }\nint jl_process_term_signal(int status) { return WTERMSIG(status); }\nint jl_process_stop_signal(int status) { return WSTOPSIG(status); }\n\n// -- access to std filehandles --\n\nJL_STREAM *JL_STDIN  = (JL_STREAM*)STDIN_FILENO;\nJL_STREAM *JL_STDOUT = (JL_STREAM*)STDOUT_FILENO;\nJL_STREAM *JL_STDERR = (JL_STREAM*)STDERR_FILENO;\n\nJL_DLLEXPORT JL_STREAM *jl_stdin_stream(void)  { return JL_STDIN; }\nJL_DLLEXPORT JL_STREAM *jl_stdout_stream(void) { return JL_STDOUT; }\nJL_DLLEXPORT JL_STREAM *jl_stderr_stream(void) { return JL_STDERR; }\n\n// -- processor native alignment information --\n\nJL_DLLEXPORT void jl_native_alignment(uint_t *int8align, uint_t *int16align, uint_t *int32align,\n                                      uint_t *int64align, uint_t *float32align, uint_t *float64align)\n{\n    *int8align = __alignof(uint8_t);\n    *int16align = __alignof(uint16_t);\n    *int32align = __alignof(uint32_t);\n    *int64align = __alignof(uint64_t);\n    *float32align = __alignof(float);\n    *float64align = __alignof(double);\n}\n\nJL_DLLEXPORT jl_value_t *jl_is_char_signed(void)\n{\n    return ((char)255) < 0 ? jl_true : jl_false;\n}\n\n// -- misc sysconf info --\n\n#ifdef _OS_WINDOWS_\nstatic long cachedPagesize = 0;\nJL_DLLEXPORT long jl_getpagesize(void)\n{\n    if (!cachedPagesize) {\n        SYSTEM_INFO systemInfo;\n        GetSystemInfo (&systemInfo);\n        cachedPagesize = systemInfo.dwPageSize;\n    }\n    return cachedPagesize;\n}\n#else\nJL_DLLEXPORT long jl_getpagesize(void)\n{\n    long page_size = sysconf(_SC_PAGESIZE);\n    assert(page_size != -1);\n    return page_size;\n}\n#endif\n\n#ifdef _OS_WINDOWS_\nstatic long cachedAllocationGranularity = 0;\nJL_DLLEXPORT long jl_getallocationgranularity(void) JL_NOTSAFEPOINT\n{\n    if (!cachedAllocationGranularity) {\n        SYSTEM_INFO systemInfo;\n        GetSystemInfo (&systemInfo);\n        cachedAllocationGranularity = systemInfo.dwAllocationGranularity;\n    }\n    return cachedAllocationGranularity;\n}\n#else\nJL_DLLEXPORT long jl_getallocationgranularity(void) JL_NOTSAFEPOINT\n{\n    return jl_getpagesize();\n}\n#endif\n\nJL_DLLEXPORT long jl_SC_CLK_TCK(void)\n{\n#ifndef _OS_WINDOWS_\n    return sysconf(_SC_CLK_TCK);\n#else\n    return 0;\n#endif\n}\n\n// Takes a handle (as returned from dlopen()) and returns the absolute path to the image loaded\nJL_DLLEXPORT const char *jl_pathname_for_handle(void *handle)\n{\n    if (!handle)\n        return NULL;\n\n#ifdef __APPLE__\n    // Iterate through all images currently in memory\n    for (int32_t i = _dyld_image_count() - 1; i >= 0 ; i--) {\n        // dlopen() each image, check handle\n        const char *image_name = _dyld_get_image_name(i);\n        void *probe_lib = jl_load_dynamic_library(image_name, JL_RTLD_DEFAULT | JL_RTLD_NOLOAD, 0);\n        jl_dlclose(probe_lib);\n\n        // If the handle is the same as what was passed in (modulo mode bits), return this image name\n        if (((intptr_t)handle & (-4)) == ((intptr_t)probe_lib & (-4)))\n            return image_name;\n    }\n\n#elif defined(_OS_WINDOWS_)\n\n    wchar_t *pth16 = (wchar_t*)malloc_s(32768 * sizeof(*pth16)); // max long path length\n    DWORD n16 = GetModuleFileNameW((HMODULE)handle, pth16, 32768);\n    if (n16 <= 0) {\n        free(pth16);\n        return NULL;\n    }\n    pth16[n16] = L'\\0';\n    DWORD n8 = WideCharToMultiByte(CP_UTF8, 0, pth16, -1, NULL, 0, NULL, NULL);\n    if (n8 == 0) {\n        free(pth16);\n        return NULL;\n    }\n    char *filepath = (char*)malloc_s(++n8);\n    if (!WideCharToMultiByte(CP_UTF8, 0, pth16, -1, filepath, n8, NULL, NULL)) {\n        free(pth16);\n        free(filepath);\n        return NULL;\n    }\n    free(pth16);\n    return filepath;\n\n#else // Linux, FreeBSD, ...\n\n    struct link_map *map;\n    dlinfo(handle, RTLD_DI_LINKMAP, &map);\n#ifdef JL_MSAN_ENABLED\n    __msan_unpoison(&map,sizeof(struct link_map*));\n    if (map) {\n        __msan_unpoison(map, sizeof(struct link_map));\n        __msan_unpoison_string(map->l_name);\n    }\n#endif\n    if (map)\n        return map->l_name;\n\n#endif\n    return NULL;\n}\n\n#ifdef _OS_WINDOWS_\n// Get a list of all the modules in this process.\nJL_DLLEXPORT int jl_dllist(jl_array_t *list)\n{\n    DWORD cb, cbNeeded;\n    HMODULE *hMods = NULL;\n    unsigned int i;\n    cbNeeded = 1024 * sizeof(*hMods);\n    do {\n        cb = cbNeeded;\n        hMods = (HMODULE*)realloc_s(hMods, cb);\n        if (!EnumProcessModulesEx(GetCurrentProcess(), hMods, cb, &cbNeeded, LIST_MODULES_ALL)) {\n          free(hMods);\n          return FALSE;\n        }\n    } while (cb < cbNeeded);\n    for (i = 0; i < cbNeeded / sizeof(HMODULE); i++) {\n        const char *path = jl_pathname_for_handle(hMods[i]);\n        // XXX: change to jl_arrayset if array storage allocation for Array{String,1} changes:\n        if (path == NULL)\n            continue;\n        jl_array_grow_end((jl_array_t*)list, 1);\n        jl_value_t *v = jl_cstr_to_string(path);\n        free(path);\n        jl_array_ptr_set(list, jl_array_dim0(list) - 1, v);\n    }\n    free(hMods);\n    return TRUE;\n}\n#endif\n\nJL_DLLEXPORT void jl_raise_debugger(void)\n{\n#if defined(_OS_WINDOWS_)\n    if (IsDebuggerPresent() == 1)\n        DebugBreak();\n#else\n    raise(SIGTRAP);\n#endif // _OS_WINDOWS_\n}\n\nJL_DLLEXPORT jl_sym_t *jl_get_UNAME(void) JL_NOTSAFEPOINT\n{\n    return jl_symbol(JL_BUILD_UNAME);\n}\n\nJL_DLLEXPORT jl_sym_t *jl_get_ARCH(void) JL_NOTSAFEPOINT\n{\n    return jl_symbol(JL_BUILD_ARCH);\n}\n\nJL_DLLEXPORT size_t jl_maxrss(void)\n{\n#if defined(_OS_WINDOWS_)\n    PROCESS_MEMORY_COUNTERS counter;\n    GetProcessMemoryInfo( GetCurrentProcess( ), &counter, sizeof(counter) );\n    return (size_t)counter.PeakWorkingSetSize;\n\n// FIXME: `rusage` is available on OpenBSD, DragonFlyBSD and NetBSD as well.\n//        All of them return `ru_maxrss` in kilobytes.\n#elif defined(_OS_LINUX_) || defined(_OS_DARWIN_) || defined (_OS_FREEBSD_)\n    struct rusage rusage;\n    getrusage( RUSAGE_SELF, &rusage );\n\n#if defined(_OS_LINUX_) || defined(_OS_FREEBSD_)\n    return (size_t)(rusage.ru_maxrss * 1024);\n#else\n    return (size_t)rusage.ru_maxrss;\n#endif\n\n#else\n    return (size_t)0;\n#endif\n}\n\nJL_DLLEXPORT int jl_threading_enabled(void)\n{\n    return 1;\n}\n\nJL_DLLEXPORT jl_value_t *jl_get_libllvm(void) JL_NOTSAFEPOINT {\n#if defined(_OS_WINDOWS_)\n    HMODULE mod;\n    // FIXME: GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS on LLVMContextCreate,\n    //        but that just points to libjulia.dll\n    if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, \"LLVM\", &mod))\n        return jl_nothing;\n\n    char path[MAX_PATH];\n    if (!GetModuleFileNameA(mod, path, sizeof(path)))\n        return jl_nothing;\n    return (jl_value_t*) jl_symbol(path);\n#else\n    Dl_info dli;\n    if (!dladdr(LLVMContextCreate, &dli))\n        return jl_nothing;\n    return (jl_value_t*) jl_symbol(dli.dli_fname);\n#endif\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/dlload.c": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n\n#include \"platform.h\"\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#ifdef _OS_WINDOWS_\n#include <windows.h>\n#include <direct.h>\n#else\n#include <unistd.h>\n#include <dlfcn.h>\n#endif\n#include \"julia_assert.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(__APPLE__)\nstatic char const *const extensions[] = { \"\", \".dylib\" };\n#elif defined(_OS_WINDOWS_)\nstatic char const *const extensions[] = { \"\", \".dll\" };\nextern volatile int needsSymRefreshModuleList;\n#else\nstatic char const *const extensions[] = { \"\", \".so\" };\n#endif\n#define N_EXTENSIONS (sizeof(extensions) / sizeof(char*))\n\nstatic int endswith_extension(const char *path) JL_NOTSAFEPOINT\n{\n    if (!path)\n        return 0;\n    size_t len = strlen(path);\n    // Skip the first one since it is empty\n    for (size_t i = 1; i < N_EXTENSIONS; i++) {\n        const char *ext = extensions[i];\n        size_t extlen = strlen(ext);\n        if (len < extlen)\n            return 0;\n        // Skip version extensions if present\n        size_t j = len - 1;\n        while (j > 0) {\n            if (path[j] == '.' || (path[j] >= '0' && path[j] <= '9'))\n                j--;\n            else\n                break;\n        }\n        if ((j == len-1 || path[j+1] == '.') && memcmp(ext, path + j - extlen + 1, extlen) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n#ifdef _OS_WINDOWS_\n#ifdef _MSC_VER\n#if (_MSC_VER >= 1930) || (_MSC_VER < 1800)\n#error This version of MSVC has not been tested.\n#elif _MSC_VER >= 1900 // VC++ 2015 / 2017 / 2019\n#define CRTDLL_BASENAME \"vcruntime140\"\n#elif _MSC_VER >= 1800 // VC++ 2013\n#define CRTDLL_BASENAME \"msvcr120\"\n#endif\n#else\n#define CRTDLL_BASENAME \"msvcrt\"\n#endif\n\nconst char jl_crtdll_basename[] = CRTDLL_BASENAME;\nconst char jl_crtdll_name[] = CRTDLL_BASENAME \".dll\";\n\n#undef CRTDLL_BASENAME\n#endif\n\n#define PATHBUF 4096\n\n#define JL_RTLD(flags, FLAG) (flags & JL_RTLD_ ## FLAG ? RTLD_ ## FLAG : 0)\n\n#ifdef _OS_WINDOWS_\nstatic void win32_formatmessage(DWORD code, char *reason, int len) JL_NOTSAFEPOINT\n{\n    DWORD res;\n    LPWSTR errmsg;\n    res = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                         FORMAT_MESSAGE_FROM_SYSTEM |\n                         FORMAT_MESSAGE_IGNORE_INSERTS |\n                         FORMAT_MESSAGE_MAX_WIDTH_MASK,\n                         NULL, code,\n                         MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),\n                         (LPWSTR)&errmsg, 0, NULL);\n    if (!res && (GetLastError() == ERROR_MUI_FILE_NOT_FOUND ||\n                 GetLastError() == ERROR_RESOURCE_TYPE_NOT_FOUND)) {\n      res = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                           FORMAT_MESSAGE_FROM_SYSTEM |\n                           FORMAT_MESSAGE_IGNORE_INSERTS |\n                           FORMAT_MESSAGE_MAX_WIDTH_MASK,\n                           NULL, code,\n                           0, (LPWSTR)&errmsg, 0, NULL);\n    }\n    res = WideCharToMultiByte(CP_UTF8, 0, errmsg, -1, reason, len, NULL, NULL);\n    assert(res > 0 || GetLastError() == ERROR_INSUFFICIENT_BUFFER);\n    reason[len - 1] = '\\0';\n    LocalFree(errmsg);\n}\n#endif\n\nJL_DLLEXPORT void *jl_dlopen(const char *filename, unsigned flags) JL_NOTSAFEPOINT\n{\n#if defined(_OS_WINDOWS_)\n    size_t len = MultiByteToWideChar(CP_UTF8, 0, filename, -1, NULL, 0);\n    if (!len) return NULL;\n    WCHAR *wfilename = (WCHAR*)alloca(len * sizeof(WCHAR));\n    if (!MultiByteToWideChar(CP_UTF8, 0, filename, -1, wfilename, len)) return NULL;\n    HANDLE lib = LoadLibraryExW(wfilename, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n    if (lib)\n        needsSymRefreshModuleList = 1;\n    return lib;\n#else\n    dlerror(); /* Reset error status. */\n    return dlopen(filename,\n                  (flags & JL_RTLD_NOW ? RTLD_NOW : RTLD_LAZY)\n                  | JL_RTLD(flags, LOCAL)\n                  | JL_RTLD(flags, GLOBAL)\n#ifdef RTLD_NODELETE\n                  | JL_RTLD(flags, NODELETE)\n#endif\n#ifdef RTLD_NOLOAD\n                  | JL_RTLD(flags, NOLOAD)\n#endif\n#if defined(RTLD_DEEPBIND) && !(defined(JL_ASAN_ENABLED) || defined(JL_TSAN_ENABLED) || defined(JL_MSAN_ENABLED))\n                  | JL_RTLD(flags, DEEPBIND)\n#endif\n#ifdef RTLD_FIRST\n                  | JL_RTLD(flags, FIRST)\n#endif\n                  );\n#endif\n}\n\nJL_DLLEXPORT int jl_dlclose(void *handle) JL_NOTSAFEPOINT\n{\n#ifdef _OS_WINDOWS_\n    if (!handle) return -1;\n    return !FreeLibrary((HMODULE) handle);\n#else\n    dlerror(); /* Reset error status. */\n    if (!handle) return -1;\n    return dlclose(handle);\n#endif\n}\n\nJL_DLLEXPORT void *jl_load_dynamic_library(const char *modname, unsigned flags, int throw_err) JL_NOTSAFEPOINT // (or throw)\n{\n    char path[PATHBUF], relocated[PATHBUF];\n    int i;\n#ifdef _OS_WINDOWS_\n    int err;\n#endif\n    uv_stat_t stbuf;\n    void *handle;\n    int abspath;\n    // number of extensions to try \u2014\u00a0if modname already ends with the\n    // standard extension, then we don't try adding additional extensions\n    int n_extensions = endswith_extension(modname) ? 1 : N_EXTENSIONS;\n\n    /*\n      this branch returns handle of libjulia-internal\n    */\n    if (modname == NULL) {\n#ifdef _OS_WINDOWS_\n        if (!GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n                                (LPCWSTR)(uintptr_t)(&jl_load_dynamic_library),\n                                (HMODULE*)&handle)) {\n#ifndef __clang_analyzer__\n            // Hide the error throwing from the analyser since there isn't a way to express\n            // \"safepoint only when throwing error\" currently.\n            jl_error(\"could not load base module\");\n#endif\n        }\n#else\n        Dl_info info;\n        if (!dladdr((void*)(uintptr_t)&jl_load_dynamic_library, &info) || !info.dli_fname) {\n#ifndef __clang_analyzer__\n            // Hide the error throwing from the analyser since there isn't a way to express\n            // \"safepoint only when throwing error\" currently.\n            jl_error(\"could not load base module\");\n#endif\n        }\n        handle = dlopen(info.dli_fname, RTLD_NOW);\n#endif\n        goto done;\n    }\n\n    abspath = isabspath(modname);\n\n    /*\n      this branch permutes all base paths in DL_LOAD_PATH with all extensions\n      note: skip when !jl_base_module to avoid UndefVarError(:DL_LOAD_PATH),\n            and also skip for absolute paths\n      We also do simple string replacement here for elements starting with `@executable_path/`.\n      While these exist as OS concepts on Darwin, we want to use them on other platforms\n      such as Windows, so we emulate them here.\n    */\n    if (!abspath && jl_base_module != NULL) {\n        jl_binding_t *b = jl_get_module_binding(jl_base_module, jl_symbol(\"DL_LOAD_PATH\"));\n        jl_array_t *DL_LOAD_PATH = (jl_array_t*)(b ? b->value : NULL);\n        if (DL_LOAD_PATH != NULL) {\n            size_t j;\n            for (j = 0; j < jl_array_len(DL_LOAD_PATH); j++) {\n                char *dl_path = jl_string_data(jl_array_ptr_data(DL_LOAD_PATH)[j]);\n                size_t len = strlen(dl_path);\n                if (len == 0)\n                    continue;\n\n                // Is this entry supposed to be relative to the bindir?\n                if (len >= 16 && strncmp(dl_path, \"@executable_path\", 16) == 0) {\n                    snprintf(relocated, PATHBUF, \"%s%s\", jl_options.julia_bindir, dl_path + 16);\n                    len = len - 16 + strlen(jl_options.julia_bindir);\n                } else {\n                    strncpy(relocated, dl_path, PATHBUF);\n                    relocated[PATHBUF-1] = '\\0';\n                }\n                for (i = 0; i < n_extensions; i++) {\n                    const char *ext = extensions[i];\n                    path[0] = '\\0';\n                    if (relocated[len-1] == PATHSEPSTRING[0])\n                        snprintf(path, PATHBUF, \"%s%s%s\", relocated, modname, ext);\n                    else\n                        snprintf(path, PATHBUF, \"%s\" PATHSEPSTRING \"%s%s\", relocated, modname, ext);\n#ifdef _OS_WINDOWS_\n                    if (i == 0) { // LoadLibrary already tested the extensions, we just need to check the `stat` result\n#endif\n                        handle = jl_dlopen(path, flags);\n                        if (handle)\n                            goto done;\n#ifdef _OS_WINDOWS_\n                        err = GetLastError();\n                    }\n#endif\n                    // bail out and show the error if file actually exists\n                    if (jl_stat(path, (char*)&stbuf) == 0)\n                        goto notfound;\n                }\n            }\n        }\n    }\n\n    // now fall back and look in default library paths, for all extensions\n    for (i = 0; i < n_extensions; i++) {\n        const char *ext = extensions[i];\n        path[0] = '\\0';\n        snprintf(path, PATHBUF, \"%s%s\", modname, ext);\n        handle = jl_dlopen(path, flags);\n        if (handle)\n            goto done;\n#ifdef _OS_WINDOWS_\n        err = GetLastError();\n        break; // LoadLibrary already tested the rest\n#endif\n    }\n\nnotfound:\n    if (throw_err) {\n#ifdef _OS_WINDOWS_\n        char reason[256];\n        win32_formatmessage(err, reason, sizeof(reason));\n#else\n        const char *reason = dlerror();\n#endif\n#ifndef __clang_analyzer__\n        // Hide the error throwing from the analyser since there isn't a way to express\n        // \"safepoint only when throwing error\" currently.\n        jl_errorf(\"could not load library \\\"%s\\\"\\n%s\", modname, reason);\n#endif\n    }\n    handle = NULL;\n\ndone:\n    return handle;\n}\n\nJL_DLLEXPORT int jl_dlsym(void *handle, const char *symbol, void ** value, int throw_err) JL_NOTSAFEPOINT\n{\n    int symbol_found = 0;\n\n    /* First, get the symbol value */\n#ifdef _OS_WINDOWS_\n    *value = GetProcAddress((HMODULE) handle, symbol);\n#else\n    dlerror(); /* Reset error status. */\n    *value = dlsym(handle, symbol);\n#endif\n\n    /* Next, check for errors.  On Windows, a NULL pointer means the symbol\n     * was not found.  On everything else, we can have NULL symbols, so we check\n     * for non-NULL returns from dlerror().  Note that means we unconditionally\n     * call dlerror() on POSIX systems.*/\n#ifdef _OS_WINDOWS_\n    symbol_found = *value != NULL;\n#else\n    const char *err = dlerror();\n    symbol_found = err == NULL;\n#endif\n\n    if (!symbol_found && throw_err) {\n#ifdef _OS_WINDOWS_\n        char err[256];\n        win32_formatmessage(GetLastError(), err, sizeof(err));\n#endif\n#ifndef __clang_analyzer__\n        // Hide the error throwing from the analyser since there isn't a way to express\n        // \"safepoint only when throwing error\" currently.\n        jl_errorf(\"could not load symbol \\\"%s\\\":\\n%s\", symbol, err);\n#endif\n    }\n    return symbol_found;\n}\n\n#ifdef _OS_WINDOWS_\n//Look for symbols in win32 libraries\nconst char *jl_dlfind_win32(const char *f_name)\n{\n    void * dummy;\n    if (jl_dlsym(jl_exe_handle, f_name, &dummy, 0))\n        return JL_EXE_LIBNAME;\n    if (jl_dlsym(jl_libjulia_internal_handle, f_name, &dummy, 0))\n        return JL_LIBJULIA_INTERNAL_DL_LIBNAME;\n    if (jl_dlsym(jl_libjulia_handle, f_name, &dummy, 0))\n        return JL_LIBJULIA_DL_LIBNAME;\n    if (jl_dlsym(jl_kernel32_handle, f_name, &dummy, 0))\n        return \"kernel32\";\n    if (jl_dlsym(jl_crtdll_handle, f_name, &dummy, 0)) // Prefer crtdll over ntdll\n        return jl_crtdll_basename;\n    if (jl_dlsym(jl_ntdll_handle, f_name, &dummy, 0))\n        return \"ntdll\";\n    if (jl_dlsym(jl_winsock_handle, f_name, &dummy, 0))\n        return \"ws2_32\";\n    // additional common libraries (libc?) could be added here, but in general,\n    // it is better to specify the library explicitly in the code. This exists\n    // mainly to ease compatibility with linux, and for libraries that don't\n    // have a name (julia.exe and libjulia.dll)\n    // We could also loop over all libraries that have been used so far, but, again,\n    // explicit is preferred over implicit\n    return NULL;\n    // oops, we didn't find it. NULL defaults to searching jl_RTLD_DEFAULT_handle,\n    // which defaults to jl_libjulia_internal_handle, where we won't find it, and\n    // will throw the appropriate error.\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/runtime_intrinsics.c": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n// This is in implementation of the Julia intrinsic functions against boxed types\n// excluding the native function call interface (ccall, llvmcall)\n//\n// this file assumes a little-endian processor, although that isn't too hard to fix\n// it also assumes two's complement negative numbers, which might be a bit harder to fix\n//\n// TODO: add half-float support\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"APInt-C.h\"\n\nconst unsigned int host_char_bit = 8;\n\n// run time version of bitcast intrinsic\nJL_DLLEXPORT jl_value_t *jl_bitcast(jl_value_t *ty, jl_value_t *v)\n{\n    JL_TYPECHK(bitcast, datatype, ty);\n    if (!jl_is_concrete_type(ty) || !jl_is_primitivetype(ty))\n        jl_error(\"bitcast: target type not a leaf primitive type\");\n    if (!jl_is_primitivetype(jl_typeof(v)))\n        jl_error(\"bitcast: value not a primitive type\");\n    if (jl_datatype_size(jl_typeof(v)) != jl_datatype_size(ty))\n        jl_error(\"bitcast: argument size does not match size of target type\");\n    if (ty == jl_typeof(v))\n        return v;\n    if (ty == (jl_value_t*)jl_bool_type)\n        return *(uint8_t*)jl_data_ptr(v) & 1 ? jl_true : jl_false;\n    return jl_new_bits(ty, jl_data_ptr(v));\n}\n\n// run time version of pointerref intrinsic (warning: i is not rooted)\nJL_DLLEXPORT jl_value_t *jl_pointerref(jl_value_t *p, jl_value_t *i, jl_value_t *align)\n{\n    JL_TYPECHK(pointerref, pointer, p);\n    JL_TYPECHK(pointerref, long, i)\n    JL_TYPECHK(pointerref, long, align);\n    jl_value_t *ety = jl_tparam0(jl_typeof(p));\n    if (ety == (jl_value_t*)jl_any_type) {\n        jl_value_t **pp = (jl_value_t**)(jl_unbox_long(p) + (jl_unbox_long(i)-1)*sizeof(void*));\n        return *pp;\n    }\n    else {\n        if (!jl_is_datatype(ety))\n            jl_error(\"pointerref: invalid pointer\");\n        size_t nb = LLT_ALIGN(jl_datatype_size(ety), jl_datatype_align(ety));\n        char *pp = (char*)jl_unbox_long(p) + (jl_unbox_long(i)-1)*nb;\n        return jl_new_bits(ety, pp);\n    }\n}\n\n// run time version of pointerset intrinsic (warning: x is not gc-rooted)\nJL_DLLEXPORT jl_value_t *jl_pointerset(jl_value_t *p, jl_value_t *x, jl_value_t *i, jl_value_t *align)\n{\n    JL_TYPECHK(pointerset, pointer, p);\n    JL_TYPECHK(pointerset, long, i);\n    JL_TYPECHK(pointerref, long, align);\n    jl_value_t *ety = jl_tparam0(jl_typeof(p));\n    if (ety == (jl_value_t*)jl_any_type) {\n        jl_value_t **pp = (jl_value_t**)(jl_unbox_long(p) + (jl_unbox_long(i)-1)*sizeof(void*));\n        *pp = x;\n    }\n    else {\n        if (!jl_is_datatype(ety))\n            jl_error(\"pointerset: invalid pointer\");\n        size_t elsz = jl_datatype_size(ety);\n        size_t nb = LLT_ALIGN(elsz, jl_datatype_align(ety));\n        char *pp = (char*)jl_unbox_long(p) + (jl_unbox_long(i)-1)*nb;\n        if (jl_typeof(x) != ety)\n            jl_type_error(\"pointerset\", ety, x);\n        memcpy(pp, x, elsz);\n    }\n    return p;\n}\n\nJL_DLLEXPORT jl_value_t *jl_cglobal(jl_value_t *v, jl_value_t *ty)\n{\n    JL_TYPECHK(cglobal, type, ty);\n    JL_GC_PUSH1(&v);\n    jl_value_t *rt =\n        ty == (jl_value_t*)jl_nothing_type ? (jl_value_t*)jl_voidpointer_type : // a common case\n            (jl_value_t*)jl_apply_type1((jl_value_t*)jl_pointer_type, ty);\n    JL_GC_PROMISE_ROOTED(rt); // (JL_ALWAYS_LEAFTYPE)\n\n    if (!jl_is_concrete_type(rt))\n        jl_error(\"cglobal: type argument not concrete\");\n\n    if (jl_is_tuple(v) && jl_nfields(v) == 1)\n        v = jl_fieldref(v, 0);\n\n    if (jl_is_pointer(v)) {\n        v = jl_bitcast(rt, v);\n        JL_GC_POP();\n        return v;\n    }\n\n    char *f_lib = NULL;\n    if (jl_is_tuple(v) && jl_nfields(v) > 1) {\n        jl_value_t *t1 = jl_fieldref_noalloc(v, 1);\n        v = jl_fieldref(v, 0);\n        if (jl_is_symbol(t1))\n            f_lib = jl_symbol_name((jl_sym_t*)t1);\n        else if (jl_is_string(t1))\n            f_lib = jl_string_data(t1);\n        else\n            JL_TYPECHK(cglobal, symbol, t1)\n    }\n\n    char *f_name = NULL;\n    if (jl_is_symbol(v))\n        f_name = jl_symbol_name((jl_sym_t*)v);\n    else if (jl_is_string(v))\n        f_name = jl_string_data(v);\n    else\n        JL_TYPECHK(cglobal, symbol, v)\n\n#ifdef _OS_WINDOWS_\n    if (!f_lib)\n        f_lib = (char*)jl_dlfind_win32(f_name);\n#endif\n\n    void *ptr;\n    jl_dlsym(jl_get_library(f_lib), f_name, &ptr, 1);\n    jl_value_t *jv = jl_gc_alloc_1w();\n    jl_set_typeof(jv, rt);\n    *(void**)jl_data_ptr(jv) = ptr;\n    JL_GC_POP();\n    return jv;\n}\n\nJL_DLLEXPORT jl_value_t *jl_cglobal_auto(jl_value_t *v) {\n    return jl_cglobal(v, (jl_value_t*)jl_nothing_type);\n}\n\nstatic inline char signbitbyte(void *a, unsigned bytes) JL_NOTSAFEPOINT\n{\n    // sign bit of an signed number of n bytes, as a byte\n    return (((signed char*)a)[bytes - 1] < 0) ? ~0 : 0;\n}\n\nstatic inline char usignbitbyte(void *a, unsigned bytes) JL_NOTSAFEPOINT\n{\n    // sign bit of an unsigned number\n    return 0;\n}\n\nstatic inline unsigned select_by_size(unsigned sz) JL_NOTSAFEPOINT\n{\n    /* choose the right sized function specialization */\n    switch (sz) {\n    default: return 0;\n    case  1: return 1;\n    case  2: return 2;\n    case  4: return 3;\n    case  8: return 4;\n    case 16: return 5;\n    }\n}\n\n#define SELECTOR_FUNC(intrinsic) \\\n    typedef intrinsic##_t select_##intrinsic##_t[6]; \\\n    static inline intrinsic##_t select_##intrinsic(unsigned sz, const select_##intrinsic##_t list) JL_NOTSAFEPOINT \\\n    { \\\n        intrinsic##_t thunk = list[select_by_size(sz)]; \\\n        if (!thunk) thunk = list[0]; \\\n        return thunk; \\\n    }\n\n#define fp_select(a, func) \\\n    sizeof(a) == sizeof(float) ? func##f((float)a) : func(a)\n#define fp_select2(a, b, func) \\\n    sizeof(a) == sizeof(float) ? func##f(a, b) : func(a, b)\n\n// fast-function generators //\n\n// integer input\n// OP::Function macro(input)\n// name::unique string\n// nbits::number of bits\n// c_type::c_type corresponding to nbits\n#define un_iintrinsic_ctype(OP, name, nbits, c_type) \\\nstatic inline void jl_##name##nbits(unsigned runtime_nbits, void *pa, void *pr) JL_NOTSAFEPOINT \\\n{ \\\n    c_type a = *(c_type*)pa; \\\n    *(c_type*)pr = OP(a); \\\n}\n\n// integer input, unsigned output\n// OP::Function macro(input)\n// name::unique string\n// nbits::number of bits\n// c_type::c_type corresponding to nbits\n#define uu_iintrinsic_ctype(OP, name, nbits, c_type) \\\nstatic inline unsigned jl_##name##nbits(unsigned runtime_nbits, void *pa) JL_NOTSAFEPOINT \\\n{ \\\n    c_type a = *(c_type*)pa; \\\n    return OP(a); \\\n}\n\n// floating point\n// OP::Function macro(output pointer, input)\n// name::unique string\n// nbits::number of bits in the *input*\n// c_type::c_type corresponding to nbits\n#define un_fintrinsic_ctype(OP, name, c_type) \\\nstatic inline void name(unsigned osize, void *pa, void *pr) JL_NOTSAFEPOINT \\\n{ \\\n    c_type a = *(c_type*)pa; \\\n    OP((c_type*)pr, a); \\\n}\n\n#define un_fintrinsic_half(OP, name) \\\nstatic inline void name(unsigned osize, void *pa, void *pr) JL_NOTSAFEPOINT \\\n{ \\\n    uint16_t a = *(uint16_t*)pa; \\\n    float A = __gnu_h2f_ieee(a); \\\n    if (osize == 16) { \\\n        float R; \\\n        OP(&R, A); \\\n        *(uint16_t*)pr = __gnu_f2h_ieee(R); \\\n    } else { \\\n        OP((uint16_t*)pr, A); \\\n    } \\\n    }\n\n// float or integer inputs\n// OP::Function macro(inputa, inputb)\n// name::unique string\n// nbits::number of bits\n// c_type::c_type corresponding to nbits\n#define bi_intrinsic_ctype(OP, name, nbits, c_type) \\\nstatic void jl_##name##nbits(unsigned runtime_nbits, void *pa, void *pb, void *pr) JL_NOTSAFEPOINT \\\n{ \\\n    c_type a = *(c_type*)pa; \\\n    c_type b = *(c_type*)pb; \\\n    *(c_type*)pr = (c_type)OP(a, b); \\\n}\n\n#define bi_intrinsic_half(OP, name) \\\nstatic void jl_##name##16(unsigned runtime_nbits, void *pa, void *pb, void *pr) JL_NOTSAFEPOINT \\\n{ \\\n    uint16_t a = *(uint16_t*)pa; \\\n    uint16_t b = *(uint16_t*)pb; \\\n    float A = __gnu_h2f_ieee(a); \\\n    float B = __gnu_h2f_ieee(b); \\\n    runtime_nbits = 16; \\\n    float R = OP(A, B); \\\n    *(uint16_t*)pr = __gnu_f2h_ieee(R); \\\n}\n\n// float or integer inputs, bool output\n// OP::Function macro(inputa, inputb)\n// name::unique string\n// nbits::number of bits\n// c_type::c_type corresponding to nbits\n#define bool_intrinsic_ctype(OP, name, nbits, c_type) \\\nstatic int jl_##name##nbits(unsigned runtime_nbits, void *pa, void *pb) JL_NOTSAFEPOINT \\\n{ \\\n    c_type a = *(c_type*)pa; \\\n    c_type b = *(c_type*)pb; \\\n    return OP(a, b); \\\n}\n\n#define bool_intrinsic_half(OP, name) \\\nstatic int jl_##name##16(unsigned runtime_nbits, void *pa, void *pb) JL_NOTSAFEPOINT \\\n{ \\\n    uint16_t a = *(uint16_t*)pa; \\\n    uint16_t b = *(uint16_t*)pb; \\\n    float A = __gnu_h2f_ieee(a); \\\n    float B = __gnu_h2f_ieee(b); \\\n    runtime_nbits = 16; \\\n    return OP(A, B); \\\n}\n\n\n// integer inputs, with precondition test\n// OP::Function macro(inputa, inputb)\n// name::unique string\n// nbits::number of bits\n// c_type::c_type corresponding to nbits\n#define checked_intrinsic_ctype(CHECK_OP, OP, name, nbits, c_type) \\\nstatic int jl_##name##nbits(unsigned runtime_nbits, void *pa, void *pb, void *pr) JL_NOTSAFEPOINT \\\n{ \\\n    c_type a = *(c_type*)pa; \\\n    c_type b = *(c_type*)pb; \\\n    *(c_type*)pr = (c_type)OP(a, b); \\\n    return CHECK_OP(c_type, a, b);    \\\n}\n\n// float inputs\n// OP::Function macro(inputa, inputb, inputc)\n// name::unique string\n// nbits::number of bits\n// c_type::c_type corresponding to nbits\n#define ter_intrinsic_ctype(OP, name, nbits, c_type) \\\nstatic void jl_##name##nbits(unsigned runtime_nbits, void *pa, void *pb, void *pc, void *pr) JL_NOTSAFEPOINT \\\n{ \\\n    c_type a = *(c_type*)pa; \\\n    c_type b = *(c_type*)pb; \\\n    c_type c = *(c_type*)pc; \\\n    *(c_type*)pr = (c_type)OP(a, b, c); \\\n}\n\n#define ter_intrinsic_half(OP, name) \\\nstatic void jl_##name##16(unsigned runtime_nbits, void *pa, void *pb, void *pc, void *pr) JL_NOTSAFEPOINT \\\n{ \\\n    uint16_t a = *(uint16_t*)pa; \\\n    uint16_t b = *(uint16_t*)pb; \\\n    uint16_t c = *(uint16_t*)pc; \\\n    float A = __gnu_h2f_ieee(a); \\\n    float B = __gnu_h2f_ieee(b); \\\n    float C = __gnu_h2f_ieee(c); \\\n    runtime_nbits = 16; \\\n    float R = OP(A, B, C); \\\n    *(uint16_t*)pr = __gnu_f2h_ieee(R); \\\n}\n\n\n// unary operator generator //\n\ntypedef void (*intrinsic_1_t)(unsigned, void*, void*);\nSELECTOR_FUNC(intrinsic_1)\n#define un_iintrinsic(name, u) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *a) \\\n{ \\\n    return jl_iintrinsic_1(jl_typeof(a), a, #name, u##signbitbyte, jl_intrinsiclambda_ty1, name##_list); \\\n}\n#define un_iintrinsic_fast(LLVMOP, OP, name, u) \\\nun_iintrinsic_ctype(OP, name, 8, u##int##8_t) \\\nun_iintrinsic_ctype(OP, name, 16, u##int##16_t) \\\nun_iintrinsic_ctype(OP, name, 32, u##int##32_t) \\\nun_iintrinsic_ctype(OP, name, 64, u##int##64_t) \\\nstatic const select_intrinsic_1_t name##_list = { \\\n    LLVMOP, \\\n    jl_##name##8, \\\n    jl_##name##16, \\\n    jl_##name##32, \\\n    jl_##name##64, \\\n}; \\\nun_iintrinsic(name, u)\n#define un_iintrinsic_slow(LLVMOP, name, u) \\\nstatic const select_intrinsic_1_t name##_list = { \\\n    LLVMOP \\\n}; \\\nun_iintrinsic(name, u)\n\ntypedef unsigned (*intrinsic_u1_t)(unsigned, void*);\nSELECTOR_FUNC(intrinsic_u1)\n#define uu_iintrinsic(name, u) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *a) \\\n{ \\\n    return jl_iintrinsic_1(jl_typeof(a), a, #name, u##signbitbyte, jl_intrinsiclambda_u1, name##_list); \\\n}\n#define uu_iintrinsic_fast(LLVMOP, OP, name, u) \\\nuu_iintrinsic_ctype(OP, name, 8, u##int##8_t) \\\nuu_iintrinsic_ctype(OP, name, 16, u##int##16_t) \\\nuu_iintrinsic_ctype(OP, name, 32, u##int##32_t) \\\nuu_iintrinsic_ctype(OP, name, 64, u##int##64_t) \\\nstatic const select_intrinsic_u1_t name##_list = { \\\n    LLVMOP, \\\n    jl_##name##8, \\\n    jl_##name##16, \\\n    jl_##name##32, \\\n    jl_##name##64, \\\n}; \\\nuu_iintrinsic(name, u)\n#define uu_iintrinsic_slow(LLVMOP, name, u) \\\nstatic const select_intrinsic_u1_t name##_list = { \\\n    LLVMOP \\\n}; \\\nuu_iintrinsic(name, u)\n\nstatic inline\njl_value_t *jl_iintrinsic_1(jl_value_t *ty, jl_value_t *a, const char *name,\n                            char (*getsign)(void*, unsigned),\n                            jl_value_t *(*lambda1)(jl_value_t*, void*, unsigned, unsigned, const void*), const void *list)\n{\n    if (!jl_is_primitivetype(jl_typeof(a)))\n        jl_errorf(\"%s: value is not a primitive type\", name);\n    if (!jl_is_primitivetype(ty))\n        jl_errorf(\"%s: type is not a primitive type\", name);\n    void *pa = jl_data_ptr(a);\n    unsigned isize = jl_datatype_size(jl_typeof(a));\n    unsigned isize2 = next_power_of_two(isize);\n    unsigned osize = jl_datatype_size(ty);\n    unsigned osize2 = next_power_of_two(osize);\n    if (isize2 > osize2)\n        osize2 = isize2;\n    if (osize2 > isize || isize2 > isize) {\n        /* if needed, round type up to a real c-type and set/clear the unused bits */\n        void *pa2;\n        pa2 = alloca(osize2);\n        /* TODO: this memcpy assumes little-endian,\n         * for big-endian, need to align the copy to the other end */ \\\n        memcpy(pa2, pa, isize);\n        memset((char*)pa2 + isize, getsign(pa, isize), osize2 - isize);\n        pa = pa2;\n    }\n    jl_value_t *newv = lambda1(ty, pa, osize, osize2, list);\n    if (ty == (jl_value_t*)jl_bool_type)\n        return *(uint8_t*)jl_data_ptr(newv) & 1 ? jl_true : jl_false;\n    return newv;\n}\n\nstatic inline jl_value_t *jl_intrinsiclambda_ty1(jl_value_t *ty, void *pa, unsigned osize, unsigned osize2, const void *voidlist)\n{\n    intrinsic_1_t op = select_intrinsic_1(osize2, (const intrinsic_1_t*)voidlist);\n    void *pr = alloca(osize2);\n    op(osize * host_char_bit, pa, pr);\n    return jl_new_bits(ty, pr);\n}\n\nstatic inline jl_value_t *jl_intrinsiclambda_u1(jl_value_t *ty, void *pa, unsigned osize, unsigned osize2, const void *voidlist)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    intrinsic_u1_t op = select_intrinsic_u1(osize2, (const intrinsic_u1_t*)voidlist);\n    uint64_t cnt = op(osize * host_char_bit, pa);\n    // TODO: the following assume little-endian\n    // for big-endian, need to copy from the other end of cnt\n    if (osize <= sizeof(cnt)) {\n        return jl_new_bits(ty, &cnt);\n    }\n    jl_value_t *newv = jl_gc_alloc(ptls, osize, ty);\n    // perform zext, if needed\n    memset((char*)jl_data_ptr(newv) + sizeof(cnt), 0, osize - sizeof(cnt));\n    memcpy(jl_data_ptr(newv), &cnt, sizeof(cnt));\n    return newv;\n}\n\n// conversion operator\n\ntypedef void (*intrinsic_cvt_t)(unsigned, void*, unsigned, void*);\ntypedef unsigned (*intrinsic_cvt_check_t)(unsigned, unsigned, void*);\n#define cvt_iintrinsic(LLVMOP, name) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *ty, jl_value_t *a) \\\n{ \\\n    return jl_intrinsic_cvt(ty, a, #name, LLVMOP); \\\n}\n\nstatic inline jl_value_t *jl_intrinsic_cvt(jl_value_t *ty, jl_value_t *a, const char *name, intrinsic_cvt_t op)\n{\n    jl_value_t *aty = jl_typeof(a);\n    if (!jl_is_primitivetype(aty))\n        jl_errorf(\"%s: value is not a primitive type\", name);\n    if (!jl_is_primitivetype(ty))\n        jl_errorf(\"%s: type is not a primitive type\", name);\n    void *pa = jl_data_ptr(a);\n    unsigned isize = jl_datatype_size(aty);\n    unsigned osize = jl_datatype_size(ty);\n    void *pr = alloca(osize);\n    unsigned isize_bits = isize * host_char_bit;\n    unsigned osize_bits = osize * host_char_bit;\n    op(isize_bits, pa, osize_bits, pr);\n    return jl_new_bits(ty, pr);\n}\n\n// floating point\n\n#define un_fintrinsic_withtype(OP, name) \\\nun_fintrinsic_half(OP, jl_##name##16) \\\nun_fintrinsic_ctype(OP, jl_##name##32, float) \\\nun_fintrinsic_ctype(OP, jl_##name##64, double) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *ty, jl_value_t *a) \\\n{ \\\n    return jl_fintrinsic_1(ty, a, #name, jl_##name##16, jl_##name##32, jl_##name##64); \\\n}\n\n#define un_fintrinsic(OP, name) \\\nun_fintrinsic_withtype(OP, name##_withtype) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *a) \\\n{ \\\n    return jl_##name##_withtype(jl_typeof(a), a); \\\n}\n\ntypedef void (fintrinsic_op1)(unsigned, void*, void*);\n\nstatic inline jl_value_t *jl_fintrinsic_1(jl_value_t *ty, jl_value_t *a, const char *name, fintrinsic_op1 *halfop, fintrinsic_op1 *floatop, fintrinsic_op1 *doubleop)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    if (!jl_is_primitivetype(jl_typeof(a)))\n        jl_errorf(\"%s: value is not a primitive type\", name);\n    if (!jl_is_primitivetype(ty))\n        jl_errorf(\"%s: type is not a primitive type\", name);\n    unsigned sz2 = jl_datatype_size(ty);\n    jl_value_t *newv = jl_gc_alloc(ptls, sz2, ty);\n    void *pa = jl_data_ptr(a), *pr = jl_data_ptr(newv);\n    unsigned sz = jl_datatype_size(jl_typeof(a));\n    switch (sz) {\n    /* choose the right size c-type operation based on the input */\n    case 2:\n        halfop(sz2 * host_char_bit, pa, pr);\n        break;\n    case 4:\n        floatop(sz2 * host_char_bit, pa, pr);\n        break;\n    case 8:\n        doubleop(sz2 * host_char_bit, pa, pr);\n        break;\n    default:\n        jl_errorf(\"%s: runtime floating point intrinsics are not implemented for bit sizes other than 16, 32 and 64\", name);\n    }\n    return newv;\n}\n\n// binary operator generator //\n\n// integer\n\ntypedef void (*intrinsic_2_t)(unsigned, void*, void*, void*);\nSELECTOR_FUNC(intrinsic_2)\n#define bi_iintrinsic(name, u, cvtb) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *a, jl_value_t *b) \\\n{ \\\n    return jl_iintrinsic_2(a, b, #name, u##signbitbyte, jl_intrinsiclambda_2, name##_list, cvtb); \\\n}\n#define bi_iintrinsic_cnvtb_fast(LLVMOP, OP, name, u, cvtb) \\\nbi_intrinsic_ctype(OP, name, 8, u##int##8_t) \\\nbi_intrinsic_ctype(OP, name, 16, u##int##16_t) \\\nbi_intrinsic_ctype(OP, name, 32, u##int##32_t) \\\nbi_intrinsic_ctype(OP, name, 64, u##int##64_t) \\\nstatic const select_intrinsic_2_t name##_list = { \\\n    LLVMOP, \\\n    jl_##name##8, \\\n    jl_##name##16, \\\n    jl_##name##32, \\\n    jl_##name##64, \\\n}; \\\nbi_iintrinsic(name, u, cvtb)\n#define bi_iintrinsic_fast(LLVMOP, OP, name, u) \\\n    bi_iintrinsic_cnvtb_fast(LLVMOP, OP, name, u, 0)\n\ntypedef int (*intrinsic_cmp_t)(unsigned, void*, void*);\nSELECTOR_FUNC(intrinsic_cmp)\n#define cmp_iintrinsic(name, u) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *a, jl_value_t *b) \\\n{ \\\n    return jl_iintrinsic_2(a, b, #name, u##signbitbyte, jl_intrinsiclambda_cmp, name##_list, 0); \\\n}\n#define bool_iintrinsic_fast(LLVMOP, OP, name, u) \\\nbool_intrinsic_ctype(OP, name, 8, u##int##8_t) \\\nbool_intrinsic_ctype(OP, name, 16, u##int##16_t) \\\nbool_intrinsic_ctype(OP, name, 32, u##int##32_t) \\\nbool_intrinsic_ctype(OP, name, 64, u##int##64_t) \\\nstatic const select_intrinsic_cmp_t name##_list = { \\\n    LLVMOP, \\\n    jl_##name##8, \\\n    jl_##name##16, \\\n    jl_##name##32, \\\n    jl_##name##64, \\\n}; \\\ncmp_iintrinsic(name, u)\n\ntypedef int (*intrinsic_checked_t)(unsigned, void*, void*, void*) JL_NOTSAFEPOINT;\nSELECTOR_FUNC(intrinsic_checked)\n#define checked_iintrinsic(name, u, lambda_checked) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *a, jl_value_t *b) \\\n{ \\\n    return jl_iintrinsic_2(a, b, #name, u##signbitbyte, lambda_checked, name##_list, 0); \\\n}\n#define checked_iintrinsic_fast(LLVMOP, CHECK_OP, OP, name, u) \\\nchecked_intrinsic_ctype(CHECK_OP, OP, name, 8, u##int##8_t) \\\nchecked_intrinsic_ctype(CHECK_OP, OP, name, 16, u##int##16_t) \\\nchecked_intrinsic_ctype(CHECK_OP, OP, name, 32, u##int##32_t) \\\nchecked_intrinsic_ctype(CHECK_OP, OP, name, 64, u##int##64_t) \\\nstatic const select_intrinsic_checked_t name##_list = { \\\n    LLVMOP, \\\n    jl_##name##8, \\\n    jl_##name##16, \\\n    jl_##name##32, \\\n    jl_##name##64, \\\n}; \\\nchecked_iintrinsic(name, u, jl_intrinsiclambda_checked)\n#define checked_iintrinsic_slow(LLVMOP, name, u) \\\nstatic const select_intrinsic_checked_t name##_list = { \\\n    LLVMOP \\\n}; \\\nchecked_iintrinsic(name, u, jl_intrinsiclambda_checked)\n#define checked_iintrinsic_div(LLVMOP, name, u) \\\nstatic const select_intrinsic_checked_t name##_list = { \\\n    LLVMOP \\\n}; \\\nchecked_iintrinsic(name, u, jl_intrinsiclambda_checkeddiv)\n\nstatic inline\njl_value_t *jl_iintrinsic_2(jl_value_t *a, jl_value_t *b, const char *name,\n                            char (*getsign)(void*, unsigned),\n                            jl_value_t *(*lambda2)(jl_value_t*, void*, void*, unsigned, unsigned, const void*),\n                            const void *list, int cvtb)\n{\n    jl_value_t *ty = jl_typeof(a);\n    jl_value_t *tyb = jl_typeof(b);\n    if (tyb != ty) {\n        if (!cvtb)\n            jl_errorf(\"%s: types of a and b must match\", name);\n        if (!jl_is_primitivetype(tyb))\n            jl_errorf(\"%s: b is not a primitive type\", name);\n    }\n    if (!jl_is_primitivetype(ty))\n        jl_errorf(\"%s: a is not a primitive type\", name);\n    void *pa = jl_data_ptr(a), *pb = jl_data_ptr(b);\n    unsigned sz = jl_datatype_size(ty);\n    unsigned sz2 = next_power_of_two(sz);\n    unsigned szb = cvtb ? jl_datatype_size(tyb) : sz;\n    if (sz2 > sz) {\n        /* round type up to the appropriate c-type and set/clear the unused bits */\n        void *pa2 = alloca(sz2);\n        memcpy(pa2, pa, sz);\n        memset((char*)pa2 + sz, getsign(pa, sz), sz2 - sz);\n        pa = pa2;\n    }\n    if (sz2 > szb) {\n        /* round type up to the appropriate c-type and set/clear/truncate the unused bits\n         * (zero-extend if cvtb is set, since in that case b is unsigned while the sign of a comes from the op)\n         */\n        void *pb2 = alloca(sz2);\n        memcpy(pb2, pb, szb);\n        memset((char*)pb2 + szb, cvtb ? 0 : getsign(pb, szb), sz2 - szb);\n        pb = pb2;\n    }\n    jl_value_t *newv = lambda2(ty, pa, pb, sz, sz2, list);\n    return newv;\n}\n\nstatic inline jl_value_t *jl_intrinsiclambda_2(jl_value_t *ty, void *pa, void *pb, unsigned sz, unsigned sz2, const void *voidlist)\n{\n    void *pr = alloca(sz2);\n    intrinsic_2_t op = select_intrinsic_2(sz2, (const intrinsic_2_t*)voidlist);\n    op(sz * host_char_bit, pa, pb, pr);\n    return jl_new_bits(ty, pr);\n}\n\nstatic inline jl_value_t *jl_intrinsiclambda_cmp(jl_value_t *ty, void *pa, void *pb, unsigned sz, unsigned sz2, const void *voidlist)\n{\n    intrinsic_cmp_t op = select_intrinsic_cmp(sz2, (const intrinsic_cmp_t*)voidlist);\n    int cmp = op(sz * host_char_bit, pa, pb);\n    return cmp ? jl_true : jl_false;\n}\n\nstatic inline jl_value_t *jl_intrinsiclambda_checked(jl_value_t *ty, void *pa, void *pb, unsigned sz, unsigned sz2, const void *voidlist)\n{\n    jl_value_t *params[2];\n    params[0] = ty;\n    params[1] = (jl_value_t*)jl_bool_type;\n    jl_datatype_t *tuptyp = jl_apply_tuple_type_v(params, 2);\n    JL_GC_PROMISE_ROOTED(tuptyp); // (JL_ALAWYS_LEAFTYPE)\n    jl_ptls_t ptls = jl_get_ptls_states();\n    jl_value_t *newv = jl_gc_alloc(ptls, ((jl_datatype_t*)tuptyp)->size, tuptyp);\n\n    intrinsic_checked_t op = select_intrinsic_checked(sz2, (const intrinsic_checked_t*)voidlist);\n    int ovflw = op(sz * host_char_bit, pa, pb, jl_data_ptr(newv));\n\n    char *ao = (char*)jl_data_ptr(newv) + sz;\n    *ao = (char)ovflw;\n    return newv;\n}\nstatic inline jl_value_t *jl_intrinsiclambda_checkeddiv(jl_value_t *ty, void *pa, void *pb, unsigned sz, unsigned sz2, const void *voidlist)\n{\n    void *pr = alloca(sz2);\n    intrinsic_checked_t op = select_intrinsic_checked(sz2, (const intrinsic_checked_t*)voidlist);\n    int ovflw = op(sz * host_char_bit, pa, pb, pr);\n    if (ovflw)\n        jl_throw(jl_diverror_exception);\n    return jl_new_bits(ty, pr);\n}\n\n// floating point\n\n#define bi_fintrinsic(OP, name) \\\n    bi_intrinsic_half(OP, name) \\\n    bi_intrinsic_ctype(OP, name, 32, float) \\\n    bi_intrinsic_ctype(OP, name, 64, double) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *a, jl_value_t *b) \\\n{ \\\n    jl_ptls_t ptls = jl_get_ptls_states();\\\n    jl_value_t *ty = jl_typeof(a); \\\n    if (jl_typeof(b) != ty) \\\n        jl_error(#name \": types of a and b must match\"); \\\n    if (!jl_is_primitivetype(ty)) \\\n        jl_error(#name \": values are not primitive types\"); \\\n    int sz = jl_datatype_size(ty); \\\n    jl_value_t *newv = jl_gc_alloc(ptls, sz, ty);          \\\n    void *pa = jl_data_ptr(a), *pb = jl_data_ptr(b), *pr = jl_data_ptr(newv); \\\n    switch (sz) { \\\n    /* choose the right size c-type operation */ \\\n    case 2: \\\n        jl_##name##16(16, pa, pb, pr); \\\n        break; \\\n    case 4: \\\n        jl_##name##32(32, pa, pb, pr); \\\n        break; \\\n    case 8: \\\n        jl_##name##64(64, pa, pb, pr); \\\n        break; \\\n    default: \\\n        jl_error(#name \": runtime floating point intrinsics are not implemented for bit sizes other than 16, 32 and 64\"); \\\n    } \\\n    return newv; \\\n}\n\n#define bool_fintrinsic(OP, name) \\\n    bool_intrinsic_half(OP, name) \\\n    bool_intrinsic_ctype(OP, name, 32, float) \\\n    bool_intrinsic_ctype(OP, name, 64, double) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *a, jl_value_t *b) \\\n{ \\\n    jl_value_t *ty = jl_typeof(a); \\\n    if (jl_typeof(b) != ty) \\\n        jl_error(#name \": types of a and b must match\"); \\\n    if (!jl_is_primitivetype(ty)) \\\n        jl_error(#name \": values are not primitive types\"); \\\n    void *pa = jl_data_ptr(a), *pb = jl_data_ptr(b); \\\n    int sz = jl_datatype_size(ty); \\\n    int cmp; \\\n    switch (sz) { \\\n    /* choose the right size c-type operation */ \\\n    case 2: \\\n        cmp = jl_##name##16(16, pa, pb); \\\n        break; \\\n    case 4: \\\n        cmp = jl_##name##32(32, pa, pb); \\\n        break; \\\n    case 8: \\\n        cmp = jl_##name##64(64, pa, pb); \\\n        break; \\\n    default: \\\n        jl_error(#name \": runtime floating point intrinsics are not implemented for bit sizes other than 32 and 64\"); \\\n    } \\\n    return cmp ? jl_true : jl_false; \\\n}\n\n#define ter_fintrinsic(OP, name) \\\n    ter_intrinsic_half(OP, name) \\\n    ter_intrinsic_ctype(OP, name, 32, float) \\\n    ter_intrinsic_ctype(OP, name, 64, double) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *a, jl_value_t *b, jl_value_t *c) \\\n{ \\\n    jl_ptls_t ptls = jl_get_ptls_states();\\\n    jl_value_t *ty = jl_typeof(a); \\\n    if (jl_typeof(b) != ty || jl_typeof(c) != ty) \\\n        jl_error(#name \": types of a, b, and c must match\"); \\\n    if (!jl_is_primitivetype(ty)) \\\n        jl_error(#name \": values are not primitive types\"); \\\n    int sz = jl_datatype_size(ty);                                      \\\n    jl_value_t *newv = jl_gc_alloc(ptls, sz, ty);                       \\\n    void *pa = jl_data_ptr(a), *pb = jl_data_ptr(b), *pc = jl_data_ptr(c), *pr = jl_data_ptr(newv); \\\n    switch (sz) { \\\n    /* choose the right size c-type operation */ \\\n    case 2: \\\n        jl_##name##16(16, pa, pb, pc, pr); \\\n        break; \\\n    case 4: \\\n        jl_##name##32(32, pa, pb, pc, pr); \\\n        break; \\\n    case 8: \\\n        jl_##name##64(64, pa, pb, pc, pr); \\\n        break; \\\n    default: \\\n        jl_error(#name \": runtime floating point intrinsics are not implemented for bit sizes other than 16, 32 and 64\"); \\\n    } \\\n    return newv; \\\n}\n\n// arithmetic\n#define neg(a) -a\n#define neg_float(pr, a) *pr = -a\nun_iintrinsic_fast(LLVMNeg, neg, neg_int, u)\n#define add(a,b) a + b\nbi_iintrinsic_fast(LLVMAdd, add, add_int, u)\nbi_iintrinsic_fast(LLVMAdd, add, add_ptr, u)\n#define sub(a,b) a - b\nbi_iintrinsic_fast(LLVMSub, sub, sub_int, u)\nbi_iintrinsic_fast(LLVMSub, sub, sub_ptr, u)\n#define mul(a,b) a * b\nbi_iintrinsic_fast(LLVMMul, mul, mul_int, u)\n#define div(a,b) a / b\nbi_iintrinsic_fast(LLVMSDiv, div, sdiv_int,  )\nbi_iintrinsic_fast(LLVMUDiv, div, udiv_int, u)\n#define rem(a,b) a % b\nbi_iintrinsic_fast(LLVMSRem, rem, srem_int,  )\nbi_iintrinsic_fast(LLVMURem, rem, urem_int, u)\n#define smod(a,b) ((a < 0) == (b < 0)) ? a % b : (b + (a % b)) % b\nbi_iintrinsic_fast(jl_LLVMSMod, smod, smod_int,  )\n#define frem(a, b) \\\n    fp_select2(a, b, fmod)\n\nun_fintrinsic(neg_float,neg_float)\nbi_fintrinsic(add,add_float)\nbi_fintrinsic(sub,sub_float)\nbi_fintrinsic(mul,mul_float)\nbi_fintrinsic(div,div_float)\nbi_fintrinsic(frem,rem_float)\n\n// ternary operators //\n#define fma(a, b, c) \\\n    sizeof(a) == sizeof(float) ? fmaf(a, b, c) : fma(a, b, c)\n#define muladd(a, b, c) a * b + c\nter_fintrinsic(fma,fma_float)\nter_fintrinsic(muladd,muladd_float)\n\n// same-type comparisons\n#define eq(a,b) a == b\nbool_iintrinsic_fast(LLVMICmpEQ, eq, eq_int, u)\n#define ne(a,b) a != b\nbool_iintrinsic_fast(LLVMICmpNE, ne, ne_int, u)\n#define lt(a,b) a < b\nbool_iintrinsic_fast(LLVMICmpSLT, lt, slt_int,  )\nbool_iintrinsic_fast(LLVMICmpULT, lt, ult_int, u)\n#define le(a,b) a <= b\nbool_iintrinsic_fast(LLVMICmpSLE, le, sle_int,  )\nbool_iintrinsic_fast(LLVMICmpULE, le, ule_int, u)\n\ntypedef union {\n    float f;\n    int32_t d;\n    uint32_t ud;\n} bits32;\ntypedef union {\n    double f;\n    int64_t d;\n    uint64_t ud;\n} bits64;\n\n#define fpiseq_n(c_type, nbits) \\\nstatic inline int fpiseq##nbits(c_type a, c_type b) JL_NOTSAFEPOINT { \\\n    bits##nbits ua, ub; \\\n    ua.f = a; \\\n    ub.f = b; \\\n    return (isnan(a) && isnan(b)) || ua.d == ub.d; \\\n}\nfpiseq_n(float, 32)\nfpiseq_n(double, 64)\n#define fpiseq(a,b) \\\n    sizeof(a) == sizeof(float) ? fpiseq32(a, b) : fpiseq64(a, b)\n\n#define fpislt_n(c_type, nbits)                                         \\\n    static inline int fpislt##nbits(c_type a, c_type b) JL_NOTSAFEPOINT \\\n    {                                                                   \\\n        bits##nbits ua, ub;                                             \\\n        ua.f = a;                                                       \\\n        ub.f = b;                                                       \\\n        if (!isnan(a) && isnan(b))                                      \\\n            return 1;                                                   \\\n        if (isnan(a) || isnan(b))                                       \\\n            return 0;                                                   \\\n        if (ua.d >= 0 && ua.d < ub.d)                                   \\\n            return 1;                                                   \\\n        if (ua.d < 0 && ua.ud > ub.ud)                                  \\\n            return 1;                                                   \\\n        return 0;                                                       \\\n    }\nfpislt_n(float, 32)\nfpislt_n(double, 64)\n#define fpislt(a, b) \\\n    sizeof(a) == sizeof(float) ? fpislt32(a, b) : fpislt64(a, b)\n\nbool_fintrinsic(eq,eq_float)\nbool_fintrinsic(ne,ne_float)\nbool_fintrinsic(lt,lt_float)\nbool_fintrinsic(le,le_float)\nbool_fintrinsic(fpiseq,fpiseq)\nbool_fintrinsic(fpislt,fpislt)\n\n// bitwise operators\n#define and_op(a,b) a & b\nbi_iintrinsic_fast(LLVMAnd, and_op, and_int, u)\n#define or_op(a,b) a | b\nbi_iintrinsic_fast(LLVMOr, or_op, or_int, u)\n#define xor_op(a,b) a ^ b\nbi_iintrinsic_fast(LLVMXor, xor_op, xor_int, u)\n#define shl_op(a,b) b >= 8 * sizeof(a) ? 0 : a << b\nbi_iintrinsic_cnvtb_fast(LLVMShl, shl_op, shl_int, u, 1)\n#define lshr_op(a,b) (b >= 8 * sizeof(a)) ? 0 : a >> b\nbi_iintrinsic_cnvtb_fast(LLVMLShr, lshr_op, lshr_int, u, 1)\n#define ashr_op(a,b) ((b < 0 || b >= 8 * sizeof(a)) ? a >> (8 * sizeof(a) - 1) : a >> b)\nbi_iintrinsic_cnvtb_fast(LLVMAShr, ashr_op, ashr_int, , 1)\n//#define bswap_op(a) __builtin_bswap(a)\n//un_iintrinsic_fast(LLVMByteSwap, bswap_op, bswap_int, u)\nun_iintrinsic_slow(LLVMByteSwap, bswap_int, u)\n//#define ctpop_op(a) __builtin_ctpop(a)\n//uu_iintrinsic_fast(LLVMCountPopulation, ctpop_op, ctpop_int, u)\nuu_iintrinsic_slow(LLVMCountPopulation, ctpop_int, u)\n//#define ctlz_op(a) __builtin_ctlz(a)\n//uu_iintrinsic_fast(LLVMCountLeadingZeros, ctlz_op, ctlz_int, u)\nuu_iintrinsic_slow(LLVMCountLeadingZeros, ctlz_int, u)\n//#define cttz_op(a) __builtin_cttz(a)\n//uu_iintrinsic_fast(LLVMCountTrailingZeros, cttz_op, cttz_int, u)\nuu_iintrinsic_slow(LLVMCountTrailingZeros, cttz_int, u)\n#define not_op(a) ~a\nun_iintrinsic_fast(LLVMFlipAllBits, not_op, not_int, u)\n\n// conversions\ncvt_iintrinsic(LLVMTrunc, trunc_int)\ncvt_iintrinsic(LLVMSExt, sext_int)\ncvt_iintrinsic(LLVMZExt, zext_int)\ncvt_iintrinsic(LLVMSItoFP, sitofp)\ncvt_iintrinsic(LLVMUItoFP, uitofp)\ncvt_iintrinsic(LLVMFPtoSI, fptosi)\ncvt_iintrinsic(LLVMFPtoUI, fptoui)\n\n#define fptrunc(pr, a) \\\n        if (!(osize < 8 * sizeof(a))) \\\n            jl_error(\"fptrunc: output bitsize must be < input bitsize\"); \\\n        else if (osize == 16) \\\n            *(uint16_t*)pr = __gnu_f2h_ieee(a); \\\n        else if (osize == 32) \\\n            *(float*)pr = a; \\\n        else if (osize == 64) \\\n            *(double*)pr = a; \\\n        else \\\n            jl_error(\"fptrunc: runtime floating point intrinsics are not implemented for bit sizes other than 16, 32 and 64\");\n#define fpext(pr, a) \\\n        if (!(osize >= 8 * sizeof(a))) \\\n            jl_error(\"fpext: output bitsize must be >= input bitsize\"); \\\n        if (osize == 32) \\\n            *(float*)pr = a; \\\n        else if (osize == 64) \\\n            *(double*)pr = a; \\\n        else \\\n            jl_error(\"fpext: runtime floating point intrinsics are not implemented for bit sizes other than 32 and 64\");\nun_fintrinsic_withtype(fptrunc,fptrunc)\nun_fintrinsic_withtype(fpext,fpext)\n\n// checked arithmetic\n/**\n * s_typemin = - s_typemax - 1\n * s_typemax = ((t)1 << (runtime_nbits - 1)) - 1\n * u_typemin = 0\n * u_typemax = ((t)1 << runtime_nbits) - 1\n **/\n#define sTYPEMIN(t) -sTYPEMAX(t) - 1\n#define sTYPEMAX(t)                                                \\\n    ((t)(8 * sizeof(a) == runtime_nbits                            \\\n         ? ((((((t)1) << (8 * sizeof(t) - 2)) - 1) << 1) + 1)      \\\n         : (  (((t)1) << (runtime_nbits - 1)) - 1)))\n\n#define uTYPEMIN(t) ((t)0)\n#define uTYPEMAX(t)                                             \\\n    ((t)(8 * sizeof(t) == runtime_nbits                         \\\n         ? (~((t)0)) : (~(((t)~((t)0)) << runtime_nbits))))\n#define check_sadd_int(t, a, b)                                         \\\n        /* this test checks for (b >= 0) ? (a + b > typemax) : (a + b < typemin) ==> overflow */ \\\n        (b >= 0) ? (a > sTYPEMAX(t) - b) : (a < sTYPEMIN(t) - b)\nchecked_iintrinsic_fast(LLVMAdd_sov, check_sadd_int, add, checked_sadd_int,  )\n#define check_uadd_int(t, a, b)                                       \\\n    /* this test checks for (a + b) > typemax(a) ==> overflow */      \\\n    a > uTYPEMAX(t) - b\nchecked_iintrinsic_fast(LLVMAdd_uov, check_uadd_int, add, checked_uadd_int, u)\n#define check_ssub_int(t, a, b)                                         \\\n    /* this test checks for (b >= 0) ? (a - b < typemin) : (a - b > typemax) ==> overflow */ \\\n    (b >= 0) ? (a < sTYPEMIN(t) + b) : (a > sTYPEMAX(t) + b)\nchecked_iintrinsic_fast(LLVMSub_sov, check_ssub_int, sub, checked_ssub_int,  )\n#define check_usub_int(t, a, b)                                   \\\n    /* this test checks for (a - b) < typemin ==> overflow */     \\\n    a < uTYPEMIN(t) + b\nchecked_iintrinsic_fast(LLVMSub_uov, check_usub_int, sub, checked_usub_int, u)\nchecked_iintrinsic_slow(LLVMMul_sov, checked_smul_int,  )\nchecked_iintrinsic_slow(LLVMMul_uov, checked_umul_int, u)\n\nchecked_iintrinsic_div(LLVMDiv_sov, checked_sdiv_int,  )\nchecked_iintrinsic_div(LLVMDiv_uov, checked_udiv_int, u)\nchecked_iintrinsic_div(LLVMRem_sov, checked_srem_int,  )\nchecked_iintrinsic_div(LLVMRem_uov, checked_urem_int, u)\n\n// functions\n#define flipsign(a, b) \\\n        (b >= 0) ? a : -a\nbi_iintrinsic_fast(jl_LLVMFlipSign, flipsign, flipsign_int,  )\n#define abs_float(pr, a)      *pr = fp_select(a, fabs)\n#define ceil_float(pr, a)     *pr = fp_select(a, ceil)\n#define floor_float(pr, a)    *pr = fp_select(a, floor)\n#define trunc_float(pr, a)    *pr = fp_select(a, trunc)\n#define rint_float(pr, a)     *pr = fp_select(a, rint)\n#define sqrt_float(pr, a)     *pr = fp_select(a, sqrt)\n#define copysign_float(a, b)  fp_select2(a, b, copysign)\n\nun_fintrinsic(abs_float,abs_float)\nbi_fintrinsic(copysign_float,copysign_float)\nun_fintrinsic(ceil_float,ceil_llvm)\nun_fintrinsic(floor_float,floor_llvm)\nun_fintrinsic(trunc_float,trunc_llvm)\nun_fintrinsic(rint_float,rint_llvm)\nun_fintrinsic(sqrt_float,sqrt_llvm)\nun_fintrinsic(sqrt_float,sqrt_llvm_fast)\n\nJL_DLLEXPORT jl_value_t *jl_arraylen(jl_value_t *a)\n{\n    JL_TYPECHK(arraylen, array, a);\n    return jl_box_long(jl_array_len((jl_array_t*)a));\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/init.c": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n/*\n  init.c\n  system initialization and global state\n*/\n#include \"platform.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n\n#include <errno.h>\n\n#if !defined(_OS_WINDOWS_) || defined(_COMPILER_GCC_)\n#include <getopt.h>\n#endif\n\n#if defined(_OS_FREEBSD_)\n#include <pthread_np.h>\n#endif\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#define DEFINE_BUILTIN_GLOBALS\n#include \"builtin_proto.h\"\n#undef DEFINE_BUILTIN_GLOBALS\n#include \"threading.h\"\n#include \"julia_assert.h\"\n#include \"processor.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef _MSC_VER\nJL_DLLEXPORT char *dirname(char *);\n#else\n#include <libgen.h>\n#endif\n\n#ifdef _OS_WINDOWS_\nextern int needsSymRefreshModuleList;\nextern BOOL (WINAPI *hSymRefreshModuleList)(HANDLE);\n#else\n#include <sys/resource.h>\n#include <unistd.h>\n#endif\n\n// list of modules being deserialized with __init__ methods\njl_array_t *jl_module_init_order;\n\nsize_t jl_page_size;\n\nvoid jl_init_stack_limits(int ismaster, void **stack_lo, void **stack_hi)\n{\n#ifdef _OS_WINDOWS_\n    (void)ismaster;\n    // https://en.wikipedia.org/wiki/Win32_Thread_Information_Block\n#  ifdef _P64\n    *stack_hi = (void**)__readgsqword(0x08); // Stack Base / Bottom of stack (high address)\n    *stack_lo = (void**)__readgsqword(0x10); // Stack Limit / Ceiling of stack (low address)\n#  else // !_P64\n    *stack_hi = (void**)__readfsdword(0x04); // Stack Base / Bottom of stack (high address)\n    *stack_lo = (void**)__readfsdword(0x08); // Stack Limit / Ceiling of stack (low address)\n#  endif // _P64\n#else // !_OS_WINDOWS_\n    // Only use pthread_*_np functions to get stack address for non-master\n    // threads since it seems to return bogus values for master thread on Linux\n    // and possibly OSX.\n    if (!ismaster) {\n#  if defined(_OS_LINUX_)\n        pthread_attr_t attr;\n        pthread_getattr_np(pthread_self(), &attr);\n        void *stackaddr;\n        size_t stacksize;\n        pthread_attr_getstack(&attr, &stackaddr, &stacksize);\n        pthread_attr_destroy(&attr);\n        *stack_lo = (void*)stackaddr;\n        *stack_hi = (void*)&stacksize;\n        return;\n#  elif defined(_OS_DARWIN_)\n        extern void *pthread_get_stackaddr_np(pthread_t thread);\n        extern size_t pthread_get_stacksize_np(pthread_t thread);\n        pthread_t thread = pthread_self();\n        void *stackaddr = pthread_get_stackaddr_np(thread);\n        size_t stacksize = pthread_get_stacksize_np(thread);\n        *stack_lo = (void*)stackaddr;\n        *stack_hi = (void*)&stacksize;\n        return;\n#  elif defined(_OS_FREEBSD_)\n        pthread_attr_t attr;\n        pthread_attr_init(&attr);\n        pthread_attr_get_np(pthread_self(), &attr);\n        void *stackaddr;\n        size_t stacksize;\n        pthread_attr_getstack(&attr, &stackaddr, &stacksize);\n        pthread_attr_destroy(&attr);\n        *stack_lo = (void*)stackaddr;\n        *stack_hi = (void*)&stacksize;\n        return;\n#  else\n#      warning \"Getting precise stack size for thread is not supported.\"\n#  endif\n    }\n    struct rlimit rl;\n    getrlimit(RLIMIT_STACK, &rl);\n    size_t stacksize = rl.rlim_cur;\n    *stack_hi = (void*)&stacksize;\n    *stack_lo = (void*)((char*)*stack_hi - stacksize);\n#endif\n}\n\nstatic void jl_prep_sanitizers(void)\n{\n#if !defined(_OS_WINDOWS_)\n#if defined(JL_ASAN_ENABLED) || defined(JL_MSAN_ENABLED)\n    struct rlimit rl;\n\n    // When using the sanitizers, increase stack size because they bloat\n    // stack usage\n    const rlim_t kStackSize = 64 * 1024 * 1024;   // 64MiB stack\n    int result;\n\n    result = getrlimit(RLIMIT_STACK, &rl);\n    if (result == 0) {\n        if (rl.rlim_cur < kStackSize) {\n            rl.rlim_cur = kStackSize;\n            result = setrlimit(RLIMIT_STACK, &rl);\n            if (result != 0) {\n                fprintf(stderr, \"setrlimit returned result = %d\\n\", result);\n            }\n        }\n    }\n#endif\n#endif\n}\n\nstruct uv_shutdown_queue_item { uv_handle_t *h; struct uv_shutdown_queue_item *next; };\nstruct uv_shutdown_queue { struct uv_shutdown_queue_item *first; struct uv_shutdown_queue_item *last; };\n\nstatic void jl_uv_exitcleanup_add(uv_handle_t *handle, struct uv_shutdown_queue *queue)\n{\n    struct uv_shutdown_queue_item *item = (struct uv_shutdown_queue_item*)malloc_s(sizeof(struct uv_shutdown_queue_item));\n    item->h = handle;\n    item->next = NULL;\n    if (queue->last)\n        queue->last->next = item;\n    if (!queue->first)\n        queue->first = item;\n    queue->last = item;\n}\n\nstatic void jl_uv_exitcleanup_walk(uv_handle_t *handle, void *arg)\n{\n    jl_uv_exitcleanup_add(handle, (struct uv_shutdown_queue*)arg);\n}\n\nstatic struct uv_shutdown_queue_item *next_shutdown_queue_item(struct uv_shutdown_queue_item *item)\n{\n    struct uv_shutdown_queue_item *rv = item->next;\n    free(item);\n    return rv;\n}\n\nstatic void jl_close_item_atexit(uv_handle_t *handle)\n{\n    if (handle->type != UV_FILE && uv_is_closing(handle))\n        return;\n    switch(handle->type) {\n    case UV_PROCESS:\n        // cause Julia to forget about the Process object\n        if (handle->data)\n            jl_uv_call_close_callback((jl_value_t*)handle->data);\n        // and make libuv think it is already dead\n        ((uv_process_t*)handle)->pid = 0;\n        // fall-through\n    case UV_TTY:\n    case UV_UDP:\n    case UV_TCP:\n    case UV_NAMED_PIPE:\n    case UV_POLL:\n    case UV_TIMER:\n    case UV_ASYNC:\n    case UV_FS_EVENT:\n    case UV_FS_POLL:\n    case UV_IDLE:\n    case UV_PREPARE:\n    case UV_CHECK:\n    case UV_SIGNAL:\n    case UV_FILE:\n        // These will be shutdown as appropriate by jl_close_uv\n        jl_close_uv(handle);\n        break;\n    case UV_HANDLE:\n    case UV_STREAM:\n    default:\n        assert(0 && \"not a valid libuv handle\");\n    }\n}\n\nJL_DLLEXPORT void jl_atexit_hook(int exitcode)\n{\n    if (jl_all_tls_states == NULL)\n        return;\n\n    jl_ptls_t ptls = jl_get_ptls_states();\n\n    if (exitcode == 0)\n        jl_write_compiler_output();\n    jl_print_gc_stats(JL_STDERR);\n    if (jl_options.code_coverage)\n        jl_write_coverage_data(jl_options.output_code_coverage);\n    if (jl_options.malloc_log)\n        jl_write_malloc_log();\n    if (jl_base_module) {\n        jl_value_t *f = jl_get_global(jl_base_module, jl_symbol(\"_atexit\"));\n        if (f != NULL) {\n            JL_TRY {\n                size_t last_age = ptls->world_age;\n                ptls->world_age = jl_get_world_counter();\n                jl_apply(&f, 1);\n                ptls->world_age = last_age;\n            }\n            JL_CATCH {\n                jl_printf((JL_STREAM*)STDERR_FILENO, \"\\natexit hook threw an error: \");\n                jl_static_show((JL_STREAM*)STDERR_FILENO, jl_current_exception());\n                jl_printf((JL_STREAM*)STDERR_FILENO, \"\\n\");\n                jlbacktrace(); // written to STDERR_FILENO\n            }\n        }\n    }\n\n    // replace standard output streams with something that we can still print to\n    // after the finalizers from base/stream.jl close the TTY\n    JL_STDOUT = (uv_stream_t*) STDOUT_FILENO;\n    JL_STDERR = (uv_stream_t*) STDERR_FILENO;\n\n    jl_gc_run_all_finalizers(ptls);\n\n    uv_loop_t *loop = jl_global_event_loop();\n\n    if (loop == NULL) {\n        return;\n    }\n\n    struct uv_shutdown_queue queue = {NULL, NULL};\n    JL_UV_LOCK();\n    uv_walk(loop, jl_uv_exitcleanup_walk, &queue);\n    struct uv_shutdown_queue_item *item = queue.first;\n    if (ptls->current_task != NULL) {\n        while (item) {\n            JL_TRY {\n                while (item) {\n                    jl_close_item_atexit(item->h);\n                    item = next_shutdown_queue_item(item);\n                }\n            }\n            JL_CATCH {\n                //error handling -- continue cleanup, as much as possible\n                assert(item);\n                uv_unref(item->h);\n                jl_printf((JL_STREAM*)STDERR_FILENO, \"error during exit cleanup: close: \");\n                jl_static_show((JL_STREAM*)STDERR_FILENO, jl_current_exception());\n                jl_printf((JL_STREAM*)STDERR_FILENO, \"\\n\");\n                jlbacktrace(); // written to STDERR_FILENO\n                item = next_shutdown_queue_item(item);\n            }\n        }\n    }\n    else {\n        while (item) {\n            jl_close_item_atexit(item->h);\n            item = next_shutdown_queue_item(item);\n        }\n    }\n\n    // force libuv to spin until everything has finished closing\n    loop->stop_flag = 0;\n    while (uv_run(loop, UV_RUN_DEFAULT)) { }\n    JL_UV_UNLOCK();\n\n    // TODO: Destroy threads\n\n    jl_destroy_timing();\n#ifdef ENABLE_TIMINGS\n    jl_print_timings();\n#endif\n\n    jl_teardown_codegen();\n}\n\nstatic void post_boot_hooks(void);\n\nJL_DLLEXPORT void *jl_libjulia_internal_handle;\nJL_DLLEXPORT void *jl_libjulia_handle;\nvoid *jl_RTLD_DEFAULT_handle;\nJL_DLLEXPORT void *jl_exe_handle;\n#ifdef _OS_WINDOWS_\nvoid *jl_ntdll_handle;\nvoid *jl_kernel32_handle;\nvoid *jl_crtdll_handle;\nvoid *jl_winsock_handle;\nextern const char jl_crtdll_name[];\n#endif\n\nuv_loop_t *jl_io_loop;\n\n#ifdef _OS_WINDOWS_\nstatic int uv_dup(uv_os_fd_t fd, uv_os_fd_t* dupfd) {\n    HANDLE current_process;\n\n    if (fd == UV_STDIN_FD || fd == UV_STDOUT_FD || fd == UV_STDERR_FD)\n        fd = GetStdHandle((DWORD)(uintptr_t) fd);\n\n    /* _get_osfhandle will sometimes return -2 in case of an error. This seems */\n    /* to happen when fd <= 2 and the process' corresponding stdio handle is */\n    /* set to NULL. Unfortunately DuplicateHandle will happily duplicate */\n    /* (HANDLE) -2, so this situation goes unnoticed until someone tries to */\n    /* use the duplicate. Therefore we filter out known-invalid handles here. */\n    if (fd == INVALID_HANDLE_VALUE ||\n        fd == NULL ||\n        fd == (HANDLE) -2) {\n        *dupfd = INVALID_HANDLE_VALUE;\n        return 0; // allow the execution to continue even if stdio is not available as in batchmode or without a console\n    }\n\n    current_process = GetCurrentProcess();\n\n    if (!DuplicateHandle(current_process,\n                         fd,\n                         current_process,\n                         dupfd,\n                         0,\n                         TRUE,\n                         DUPLICATE_SAME_ACCESS)) {\n        *dupfd = INVALID_HANDLE_VALUE;\n        return GetLastError();\n    }\n\n    return 0;\n}\n#else\nstatic int uv_dup(uv_os_fd_t fd, uv_os_fd_t* dupfd) {\n    if ((*dupfd = fcntl(fd, F_DUPFD_CLOEXEC, 3)) == -1)\n        return -errno;\n    return 0;\n}\n#endif\n\nstatic void *init_stdio_handle(const char *stdio, uv_os_fd_t fd, int readable)\n{\n    void *handle;\n    int err;\n    // Duplicate the file descriptor so we can later dup it over if we want to redirect\n    // STDIO without having to worry about closing the associated libuv object.\n    // This also helps limit the impact other libraries can cause on our file handle.\n    if ((err = uv_dup(fd, &fd)))\n        jl_errorf(\"error initializing %s in uv_dup: %s (%s %d)\", stdio, uv_strerror(err), uv_err_name(err), err);\n    switch(uv_guess_handle(fd)) {\n    case UV_TTY:\n        handle = malloc_s(sizeof(uv_tty_t));\n        if ((err = uv_tty_init(jl_io_loop, (uv_tty_t*)handle, fd, 0))) {\n            jl_errorf(\"error initializing %s in uv_tty_init: %s (%s %d)\", stdio, uv_strerror(err), uv_err_name(err), err);\n        }\n        ((uv_tty_t*)handle)->data = NULL;\n        uv_tty_set_mode((uv_tty_t*)handle, UV_TTY_MODE_NORMAL); // initialized cooked stdio\n        break;\n    default:\n        assert(0 && \"missing case for uv_guess_handle return handling\");\n        JL_FALLTHROUGH;\n    case UV_UDP:\n        JL_FALLTHROUGH;\n    case UV_UNKNOWN_HANDLE:\n        // dup the descriptor with a new one pointing at the bit bucket ...\n#if defined(_OS_WINDOWS_)\n        CloseHandle(fd);\n        fd = CreateFile(\"NUL\", readable ? FILE_GENERIC_READ : FILE_GENERIC_WRITE | FILE_READ_ATTRIBUTES,\n                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);\n#else\n        {\n            int nullfd;\n            nullfd = open(\"/dev/null\", O_RDWR, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH /* 0666 */);\n            assert(nullfd != -1);\n            dup2(nullfd, fd);\n            close(nullfd);\n        }\n#endif\n        // ...and continue on as in the UV_FILE case\n        JL_FALLTHROUGH;\n    case UV_FILE:\n        handle = malloc_s(sizeof(jl_uv_file_t));\n        {\n            jl_uv_file_t *file = (jl_uv_file_t*)handle;\n            file->loop = jl_io_loop;\n            file->type = UV_FILE;\n            file->file = fd;\n            file->data = NULL;\n        }\n        break;\n    case UV_NAMED_PIPE:\n        handle = malloc_s(sizeof(uv_pipe_t));\n        if ((err = uv_pipe_init(jl_io_loop, (uv_pipe_t*)handle, 0))) {\n            jl_errorf(\"error initializing %s in uv_pipe_init: %s (%s %d)\", stdio, uv_strerror(err), uv_err_name(err), err);\n        }\n        if ((err = uv_pipe_open((uv_pipe_t*)handle, fd))) {\n            jl_errorf(\"error initializing %s in uv_pipe_open: %s (%s %d)\", stdio, uv_strerror(err), uv_err_name(err), err);\n        }\n        ((uv_pipe_t*)handle)->data = NULL;\n        break;\n    case UV_TCP:\n        handle = malloc_s(sizeof(uv_tcp_t));\n        if ((err = uv_tcp_init(jl_io_loop, (uv_tcp_t*)handle))) {\n            jl_errorf(\"error initializing %s in uv_tcp_init: %s (%s %d)\", stdio, uv_strerror(err), uv_err_name(err), err);\n        }\n        if ((err = uv_tcp_open((uv_tcp_t*)handle, (uv_os_sock_t)fd))) {\n            jl_errorf(\"error initializing %s in uv_tcp_open: %s (%s %d)\", stdio, uv_strerror(err), uv_err_name(err), err);\n        }\n        ((uv_tcp_t*)handle)->data = NULL;\n        break;\n    }\n    return handle;\n}\n\nstatic void init_stdio(void)\n{\n    JL_STDIN  = (uv_stream_t*)init_stdio_handle(\"stdin\", UV_STDIN_FD, 1);\n    JL_STDOUT = (uv_stream_t*)init_stdio_handle(\"stdout\", UV_STDOUT_FD, 0);\n    JL_STDERR = (uv_stream_t*)init_stdio_handle(\"stderr\", UV_STDERR_FD, 0);\n    jl_flush_cstdio();\n}\n\n#ifdef JL_USE_INTEL_JITEVENTS\nchar jl_using_intel_jitevents; // Non-zero if running under Intel VTune Amplifier\n#endif\n\n#ifdef JL_USE_OPROFILE_JITEVENTS\nchar jl_using_oprofile_jitevents = 0; // Non-zero if running under OProfile\n#endif\n\n#ifdef JL_USE_PERF_JITEVENTS\nchar jl_using_perf_jitevents = 0;\n#endif\n\nchar jl_using_gdb_jitevents = 0;\n\nint isabspath(const char *in) JL_NOTSAFEPOINT\n{\n#ifdef _OS_WINDOWS_\n    char c0 = in[0];\n    if (c0 == '/' || c0 == '\\\\') {\n        return 1; // absolute path relative to %CD% (current drive), or UNC\n    }\n    else if (c0 && in[1] == ':') {\n        char c2 = in[2];\n        return c2 == '/' || c2 == '\\\\'; // absolute path with drive name\n    }\n#else\n    if (in[0] == '/') return 1; // absolute path\n#endif\n    return 0; // relative path\n}\n\nstatic char *abspath(const char *in, int nprefix)\n{ // compute an absolute realpath location, so that chdir doesn't change the file reference\n  // ignores (copies directly over) nprefix characters at the start of abspath\n#ifndef _OS_WINDOWS_\n    char *out = realpath(in + nprefix, NULL);\n    if (out) {\n        if (nprefix > 0) {\n            size_t sz = strlen(out) + 1;\n            char *cpy = (char*)malloc_s(sz + nprefix);\n            memcpy(cpy, in, nprefix);\n            memcpy(cpy + nprefix, out, sz);\n            free(out);\n            out = cpy;\n        }\n    }\n    else {\n        size_t sz = strlen(in + nprefix) + 1;\n        if (in[nprefix] == PATHSEPSTRING[0]) {\n            out = (char*)malloc_s(sz + nprefix);\n            memcpy(out, in, sz + nprefix);\n        }\n        else {\n            size_t path_size = PATH_MAX;\n            char *path = (char*)malloc_s(PATH_MAX);\n            if (uv_cwd(path, &path_size)) {\n                jl_error(\"fatal error: unexpected error while retrieving current working directory\");\n            }\n            out = (char*)malloc_s(path_size + 1 + sz + nprefix);\n            memcpy(out, in, nprefix);\n            memcpy(out + nprefix, path, path_size);\n            out[nprefix + path_size] = PATHSEPSTRING[0];\n            memcpy(out + nprefix + path_size + 1, in + nprefix, sz);\n            free(path);\n        }\n    }\n#else\n    DWORD n = GetFullPathName(in + nprefix, 0, NULL, NULL);\n    if (n <= 0) {\n        jl_error(\"fatal error: jl_options.image_file path too long or GetFullPathName failed\");\n    }\n    char *out = (char*)malloc_s(n + nprefix);\n    DWORD m = GetFullPathName(in + nprefix, n, out + nprefix, NULL);\n    if (n != m + 1) {\n        jl_error(\"fatal error: jl_options.image_file path too long or GetFullPathName failed\");\n    }\n    memcpy(out, in, nprefix);\n#endif\n    return out;\n}\n\n// create an absolute-path copy of the input path format string\n// formed as `joinpath(replace(pwd(), \"%\" => \"%%\"), in)`\n// unless `in` starts with `%`\nstatic const char *absformat(const char *in)\n{\n    if (in[0] == '%' || isabspath(in))\n        return in;\n    // get an escaped copy of cwd\n    size_t path_size = PATH_MAX;\n    char path[PATH_MAX];\n    if (uv_cwd(path, &path_size)) {\n        jl_error(\"fatal error: unexpected error while retrieving current working directory\");\n    }\n    size_t sz = strlen(in) + 1;\n    size_t i, fmt_size = 0;\n    for (i = 0; i < path_size; i++)\n        fmt_size += (path[i] == '%' ? 2 : 1);\n    char *out = (char*)malloc_s(fmt_size + 1 + sz);\n    fmt_size = 0;\n    for (i = 0; i < path_size; i++) { // copy-replace pwd portion\n        char c = path[i];\n        out[fmt_size++] = c;\n        if (c == '%')\n            out[fmt_size++] = '%';\n    }\n    out[fmt_size++] = PATHSEPSTRING[0]; // path sep\n    memcpy(out + fmt_size, in, sz); // copy over format, including nul\n    return out;\n}\n\nstatic void jl_resolve_sysimg_location(JL_IMAGE_SEARCH rel)\n{   // this function resolves the paths in jl_options to absolute file locations as needed\n    // and it replaces the pointers to `julia_bindir`, `julia_bin`, `image_file`, and output file paths\n    // it may fail, print an error, and exit(1) if any of these paths are longer than PATH_MAX\n    //\n    // note: if you care about lost memory, you should call the appropriate `free()` function\n    // on the original pointer for each `char*` you've inserted into `jl_options`, after\n    // calling `julia_init()`\n    char *free_path = (char*)malloc_s(PATH_MAX);\n    size_t path_size = PATH_MAX;\n    if (uv_exepath(free_path, &path_size)) {\n        jl_error(\"fatal error: unexpected error while retrieving exepath\");\n    }\n    if (path_size >= PATH_MAX) {\n        jl_error(\"fatal error: jl_options.julia_bin path too long\");\n    }\n    jl_options.julia_bin = (char*)malloc_s(path_size + 1);\n    memcpy((char*)jl_options.julia_bin, free_path, path_size);\n    ((char*)jl_options.julia_bin)[path_size] = '\\0';\n    if (!jl_options.julia_bindir) {\n        jl_options.julia_bindir = getenv(\"JULIA_BINDIR\");\n        if (!jl_options.julia_bindir) {\n            jl_options.julia_bindir = dirname(free_path);\n        }\n    }\n    if (jl_options.julia_bindir)\n        jl_options.julia_bindir = abspath(jl_options.julia_bindir, 0);\n    free(free_path);\n    free_path = NULL;\n    if (jl_options.image_file) {\n        if (rel == JL_IMAGE_JULIA_HOME && !isabspath(jl_options.image_file)) {\n            // build time path, relative to JULIA_BINDIR\n            free_path = (char*)malloc_s(PATH_MAX);\n            int n = snprintf(free_path, PATH_MAX, \"%s\" PATHSEPSTRING \"%s\",\n                             jl_options.julia_bindir, jl_options.image_file);\n            if (n >= PATH_MAX || n < 0) {\n                jl_error(\"fatal error: jl_options.image_file path too long\");\n            }\n            jl_options.image_file = free_path;\n        }\n        if (jl_options.image_file)\n            jl_options.image_file = abspath(jl_options.image_file, 0);\n        if (free_path) {\n            free(free_path);\n            free_path = NULL;\n        }\n    }\n    if (jl_options.outputo)\n        jl_options.outputo = abspath(jl_options.outputo, 0);\n    if (jl_options.outputji)\n        jl_options.outputji = abspath(jl_options.outputji, 0);\n    if (jl_options.outputbc)\n        jl_options.outputbc = abspath(jl_options.outputbc, 0);\n    if (jl_options.outputasm)\n        jl_options.outputasm = abspath(jl_options.outputasm, 0);\n    if (jl_options.machine_file)\n        jl_options.machine_file = abspath(jl_options.machine_file, 0);\n    if (jl_options.output_code_coverage)\n        jl_options.output_code_coverage = absformat(jl_options.output_code_coverage);\n\n    const char **cmdp = jl_options.cmds;\n    if (cmdp) {\n        for (; *cmdp; cmdp++) {\n            const char *cmd = *cmdp;\n            if (cmd[0] == 'L') {\n                *cmdp = abspath(cmd, 1);\n            }\n        }\n    }\n}\n\nstatic void jl_set_io_wait(int v)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    ptls->io_wait = v;\n}\n\nextern jl_mutex_t jl_modules_mutex;\n\nstatic void restore_fp_env(void)\n{\n    if (jl_set_zero_subnormals(0) || jl_set_default_nans(0)) {\n        jl_error(\"Failed to configure floating point environment\");\n    }\n}\n\nvoid _julia_init(JL_IMAGE_SEARCH rel)\n{\n    jl_init_timing();\n    // Make sure we finalize the tls callback before starting any threads.\n    jl_get_ptls_states_getter();\n    jl_ptls_t ptls = jl_get_ptls_states();\n    (void)ptls; assert(ptls); // make sure early that we have initialized ptls\n    jl_safepoint_init();\n    libsupport_init();\n    htable_new(&jl_current_modules, 0);\n    JL_MUTEX_INIT(&jl_modules_mutex);\n    ios_set_io_wait_func = jl_set_io_wait;\n    jl_io_loop = uv_default_loop(); // this loop will internal events (spawning process etc.),\n                                    // best to call this first, since it also initializes libuv\n    jl_init_uv();\n    init_stdio();\n    restore_fp_env();\n    restore_signals();\n\n    jl_page_size = jl_getpagesize();\n    uint64_t total_mem = uv_get_total_memory();\n    uint64_t constrained_mem = uv_get_constrained_memory();\n    if (constrained_mem > 0 && constrained_mem < total_mem)\n        total_mem = constrained_mem;\n    if (total_mem >= (size_t)-1) {\n        total_mem = (size_t)-1;\n    }\n    jl_arr_xtralloc_limit = total_mem / 100;  // Extra allocation limited to 1% of total RAM\n    jl_prep_sanitizers();\n    void *stack_lo, *stack_hi;\n    jl_init_stack_limits(1, &stack_lo, &stack_hi);\n\n    // Load libjulia-internal (which contains this function), and libjulia, explicitly.\n    jl_libjulia_internal_handle = jl_load_dynamic_library(NULL, JL_RTLD_DEFAULT, 1);\n    jl_libjulia_handle = jl_load_dynamic_library(JL_LIBJULIA_SONAME, JL_RTLD_DEFAULT, 1);\n#ifdef _OS_WINDOWS_\n    jl_ntdll_handle = jl_dlopen(\"ntdll.dll\", 0); // bypass julia's pathchecking for system dlls\n    jl_kernel32_handle = jl_dlopen(\"kernel32.dll\", 0);\n    jl_crtdll_handle = jl_dlopen(jl_crtdll_name, 0);\n    jl_winsock_handle = jl_dlopen(\"ws2_32.dll\", 0);\n    jl_exe_handle = GetModuleHandleA(NULL);\n    JL_MUTEX_INIT(&jl_in_stackwalk);\n    SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_LINES | SYMOPT_IGNORE_CVREC);\n    if (!SymInitialize(GetCurrentProcess(), \"\", 1)) {\n        jl_printf(JL_STDERR, \"WARNING: failed to initialize stack walk info\\n\");\n    }\n    needsSymRefreshModuleList = 0;\n    HMODULE jl_dbghelp = (HMODULE) jl_dlopen(\"dbghelp.dll\", 0);\n    if (jl_dbghelp)\n        jl_dlsym(jl_dbghelp, \"SymRefreshModuleList\", (void **)&hSymRefreshModuleList, 1);\n#else\n    jl_exe_handle = jl_dlopen(NULL, JL_RTLD_NOW);\n#ifdef RTLD_DEFAULT\n    jl_RTLD_DEFAULT_handle = RTLD_DEFAULT;\n#else\n    jl_RTLD_DEFAULT_handle = jl_exe_handle;\n#endif\n#endif\n\n#if defined(JL_USE_INTEL_JITEVENTS)\n    const char *jit_profiling = getenv(\"ENABLE_JITPROFILING\");\n    if (jit_profiling && atoi(jit_profiling)) {\n        jl_using_intel_jitevents = 1;\n    }\n#endif\n\n#if defined(JL_USE_OPROFILE_JITEVENTS)\n    const char *jit_profiling = getenv(\"ENABLE_JITPROFILING\");\n    if (jit_profiling && atoi(jit_profiling)) {\n        jl_using_oprofile_jitevents = 1;\n    }\n#endif\n\n#if defined(JL_USE_PERF_JITEVENTS)\n    const char *jit_profiling = getenv(\"ENABLE_JITPROFILING\");\n    if (jit_profiling && atoi(jit_profiling)) {\n        jl_using_perf_jitevents= 1;\n    }\n#endif\n\n#if defined(JL_DEBUG_BUILD)\n    jl_using_gdb_jitevents = 1;\n# else\n    const char *jit_gdb = getenv(\"ENABLE_GDBLISTENER\");\n    if (jit_gdb && atoi(jit_gdb)) {\n        jl_using_gdb_jitevents = 1;\n    }\n#endif\n\n    if ((jl_options.outputo || jl_options.outputbc || jl_options.outputasm) &&\n        (jl_options.code_coverage || jl_options.malloc_log)) {\n        jl_error(\"cannot generate code-coverage or track allocation information while generating a .o, .bc, or .s output file\");\n    }\n\n    jl_gc_init();\n\n    jl_init_threading();\n    jl_init_intrinsic_properties();\n\n    jl_gc_enable(0);\n\n    jl_resolve_sysimg_location(rel);\n    // loads sysimg if available, and conditionally sets jl_options.cpu_target\n    if (jl_options.image_file)\n        jl_preload_sysimg_so(jl_options.image_file);\n    if (jl_options.cpu_target == NULL)\n        jl_options.cpu_target = \"native\";\n\n    if (jl_options.image_file) {\n        jl_restore_system_image(jl_options.image_file);\n    }\n    else {\n        jl_init_types();\n        jl_init_codegen();\n    }\n\n    jl_init_tasks();\n    jl_init_root_task(stack_lo, stack_hi);\n    jl_init_common_symbols();\n    jl_init_flisp();\n    jl_init_serializer();\n\n    if (!jl_options.image_file) {\n        jl_core_module = jl_new_module(jl_symbol(\"Core\"));\n        jl_core_module->parent = jl_core_module;\n        jl_type_typename->mt->module = jl_core_module;\n        jl_top_module = jl_core_module;\n        jl_init_intrinsic_functions();\n        jl_init_primitives();\n        jl_init_main_module();\n        jl_load(jl_core_module, \"boot.jl\");\n        post_boot_hooks();\n    }\n\n    if (jl_base_module != NULL) {\n        // Do initialization needed before starting child threads\n        jl_value_t *f = jl_get_global(jl_base_module, jl_symbol(\"__preinit_threads__\"));\n        if (f) {\n            size_t last_age = ptls->world_age;\n            ptls->world_age = jl_get_world_counter();\n            jl_apply(&f, 1);\n            ptls->world_age = last_age;\n        }\n    }\n    else {\n        // nthreads > 1 requires code in Base\n        jl_n_threads = 1;\n    }\n    jl_start_threads();\n\n    // This needs to be after jl_start_threads\n    if (jl_options.handle_signals == JL_OPTIONS_HANDLE_SIGNALS_ON)\n        jl_install_default_signal_handlers();\n\n    jl_gc_enable(1);\n\n    if (jl_options.image_file && (!jl_generating_output() || jl_options.incremental) && jl_module_init_order) {\n        jl_array_t *init_order = jl_module_init_order;\n        JL_GC_PUSH1(&init_order);\n        jl_module_init_order = NULL;\n        int i, l = jl_array_len(init_order);\n        for (i = 0; i < l; i++) {\n            jl_value_t *mod = jl_array_ptr_ref(init_order, i);\n            jl_module_run_initializer((jl_module_t*)mod);\n        }\n        JL_GC_POP();\n    }\n\n    if (jl_options.handle_signals == JL_OPTIONS_HANDLE_SIGNALS_ON)\n        jl_install_sigint_handler();\n}\n\nstatic jl_value_t *core(const char *name)\n{\n    return jl_get_global(jl_core_module, jl_symbol(name));\n}\n\n// fetch references to things defined in boot.jl\nstatic void post_boot_hooks(void)\n{\n    jl_char_type    = (jl_datatype_t*)core(\"Char\");\n    jl_int8_type    = (jl_datatype_t*)core(\"Int8\");\n    jl_int16_type   = (jl_datatype_t*)core(\"Int16\");\n    jl_uint16_type  = (jl_datatype_t*)core(\"UInt16\");\n    jl_float16_type = (jl_datatype_t*)core(\"Float16\");\n    jl_float32_type = (jl_datatype_t*)core(\"Float32\");\n    jl_float64_type = (jl_datatype_t*)core(\"Float64\");\n    jl_floatingpoint_type = (jl_datatype_t*)core(\"AbstractFloat\");\n    jl_number_type  = (jl_datatype_t*)core(\"Number\");\n    jl_signed_type  = (jl_datatype_t*)core(\"Signed\");\n    jl_datatype_t *jl_unsigned_type = (jl_datatype_t*)core(\"Unsigned\");\n    jl_datatype_t *jl_integer_type = (jl_datatype_t*)core(\"Integer\");\n\n    jl_bool_type->super = jl_integer_type;\n    jl_uint8_type->super = jl_unsigned_type;\n    jl_int32_type->super = jl_signed_type;\n    jl_int64_type->super = jl_signed_type;\n    jl_uint32_type->super = jl_unsigned_type;\n    jl_uint64_type->super = jl_unsigned_type;\n\n    jl_errorexception_type = (jl_datatype_t*)core(\"ErrorException\");\n    jl_stackovf_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"StackOverflowError\"));\n    jl_diverror_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"DivideError\"));\n    jl_undefref_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"UndefRefError\"));\n    jl_undefvarerror_type  = (jl_datatype_t*)core(\"UndefVarError\");\n    jl_interrupt_exception = jl_new_struct_uninit((jl_datatype_t*)core(\"InterruptException\"));\n    jl_boundserror_type    = (jl_datatype_t*)core(\"BoundsError\");\n    jl_memory_exception    = jl_new_struct_uninit((jl_datatype_t*)core(\"OutOfMemoryError\"));\n    jl_readonlymemory_exception = jl_new_struct_uninit((jl_datatype_t*)core(\"ReadOnlyMemoryError\"));\n    jl_typeerror_type      = (jl_datatype_t*)core(\"TypeError\");\n#ifdef SEGV_EXCEPTION\n    jl_segv_exception      = jl_new_struct_uninit((jl_datatype_t*)core(\"SegmentationFault\"));\n#endif\n    jl_argumenterror_type  = (jl_datatype_t*)core(\"ArgumentError\");\n    jl_methoderror_type    = (jl_datatype_t*)core(\"MethodError\");\n    jl_loaderror_type      = (jl_datatype_t*)core(\"LoadError\");\n    jl_initerror_type      = (jl_datatype_t*)core(\"InitError\");\n\n    jl_weakref_type = (jl_datatype_t*)core(\"WeakRef\");\n    jl_vecelement_typename = ((jl_datatype_t*)jl_unwrap_unionall(core(\"VecElement\")))->name;\n\n    jl_init_box_caches();\n\n    // set module field of primitive types\n    int i;\n    void **table = jl_core_module->bindings.table;\n    for (i = 1; i < jl_core_module->bindings.size; i += 2) {\n        if (table[i] != HT_NOTFOUND) {\n            jl_binding_t *b = (jl_binding_t*)table[i];\n            jl_value_t *v = b->value;\n            if (v) {\n                if (jl_is_unionall(v))\n                    v = jl_unwrap_unionall(v);\n                if (jl_is_datatype(v)) {\n                    jl_datatype_t *tt = (jl_datatype_t*)v;\n                    tt->name->module = jl_core_module;\n                    if (tt->name->mt)\n                        tt->name->mt->module = jl_core_module;\n                }\n            }\n        }\n    }\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/julia.h": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n#ifndef JULIA_H\n#define JULIA_H\n\n//** Configuration options that affect the Julia ABI **//\n// if this is not defined, only individual dimension sizes are\n// stored and not total length, to save space.\n#define STORE_ARRAY_LEN\n//** End Configuration options **//\n\n#include \"libsupport.h\"\n#include <stdint.h>\n#include <string.h>\n\n#include \"htable.h\"\n#include \"arraylist.h\"\n#include \"analyzer_annotations.h\"\n\n#include <setjmp.h>\n#ifndef _OS_WINDOWS_\n#  define jl_jmp_buf sigjmp_buf\n#  if defined(_CPU_ARM_) || defined(_CPU_PPC_) || defined(_CPU_WASM_)\n#    define MAX_ALIGN 8\n#  elif defined(_CPU_AARCH64_)\n// int128 is 16 bytes aligned on aarch64\n#    define MAX_ALIGN 16\n#  elif defined(_P64)\n// Generically we assume MAX_ALIGN is sizeof(void*)\n#    define MAX_ALIGN 8\n#  else\n#    define MAX_ALIGN 4\n#  endif\n#else\n#  include \"win32_ucontext.h\"\n#  define jl_jmp_buf jmp_buf\n#  define MAX_ALIGN 8\n#endif\n\n#ifdef _P64\n#define NWORDS(sz) (((sz)+7)>>3)\n#else\n#define NWORDS(sz) (((sz)+3)>>2)\n#endif\n\n#if defined(__GNUC__)\n#  define JL_NORETURN __attribute__ ((noreturn))\n#  define JL_CONST_FUNC __attribute__((const))\n#  define JL_USED_FUNC __attribute__((used))\n#  define JL_SECTION(name) __attribute__((section(name)))\n#  define JL_THREAD_LOCAL __thread\n#elif defined(_COMPILER_MICROSOFT_)\n#  define JL_NORETURN __declspec(noreturn)\n// This is the closest I can find for __attribute__((const))\n#  define JL_CONST_FUNC __declspec(noalias)\n// Does MSVC have this?\n#  define JL_USED_FUNC\n// TODO: Figure out what to do on MSVC\n#  define JL_SECTION(x)\n#  define JL_THREAD_LOCAL __declspec(threaD)\n#else\n#  define JL_NORETURN\n#  define JL_CONST_FUNC\n#  define JL_USED_FUNC\n#  define JL_THREAD_LOCAL\n#endif\n\n#if defined(__has_feature) // Clang flavor\n#if __has_feature(address_sanitizer)\n#define JL_ASAN_ENABLED\n#endif\n#if __has_feature(memory_sanitizer)\n#define JL_MSAN_ENABLED\n#endif\n#if __has_feature(thread_sanitizer)\n#if __clang_major__ < 11\n#error Thread sanitizer runtime libraries in clang < 11 leak memory and cannot be used\n#endif\n#define JL_TSAN_ENABLED\n#endif\n#else // GCC flavor\n#if defined(__SANITIZE_ADDRESS__)\n#define JL_ASAN_ENABLED\n#endif\n#endif // __has_feature\n\n#define container_of(ptr, type, member) \\\n    ((type *) ((char *)(ptr) - offsetof(type, member)))\n\ntypedef struct _jl_taggedvalue_t jl_taggedvalue_t;\n\n#include \"atomics.h\"\n#include \"tls.h\"\n#include \"julia_threads.h\"\n#include \"julia_assert.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// core data types ------------------------------------------------------------\n\n// the common fields are hidden before the pointer, but the following macro is\n// used to indicate which types below are subtypes of jl_value_t\n#define JL_DATA_TYPE\n\ntypedef struct _jl_value_t jl_value_t;\n\nstruct _jl_taggedvalue_bits {\n    uintptr_t gc:2;\n};\n\nJL_EXTENSION struct _jl_taggedvalue_t {\n    union {\n        uintptr_t header;\n        jl_taggedvalue_t *next;\n        jl_value_t *type; // 16-byte aligned\n        struct _jl_taggedvalue_bits bits;\n    };\n    // jl_value_t value;\n};\n\n#ifdef __clang_analyzer__\nJL_DLLEXPORT jl_taggedvalue_t *_jl_astaggedvalue(jl_value_t *v JL_PROPAGATES_ROOT) JL_NOTSAFEPOINT;\n#define jl_astaggedvalue(v) _jl_astaggedvalue((jl_value_t*)(v))\njl_value_t *_jl_valueof(jl_taggedvalue_t *tv JL_PROPAGATES_ROOT) JL_NOTSAFEPOINT;\n#define jl_valueof(v) _jl_valueof((jl_taggedvalue_t*)(v))\nJL_DLLEXPORT jl_value_t *_jl_typeof(jl_value_t *v JL_PROPAGATES_ROOT) JL_NOTSAFEPOINT;\n#define jl_typeof(v) _jl_typeof((jl_value_t*)(v))\n#else\n#define jl_astaggedvalue(v)                                             \\\n    ((jl_taggedvalue_t*)((char*)(v) - sizeof(jl_taggedvalue_t)))\n#define jl_valueof(v)                                           \\\n    ((jl_value_t*)((char*)(v) + sizeof(jl_taggedvalue_t)))\n#define jl_typeof(v)                                                    \\\n    ((jl_value_t*)(jl_astaggedvalue(v)->header & ~(uintptr_t)15))\n#endif\nstatic inline void jl_set_typeof(void *v, void *t) JL_NOTSAFEPOINT\n{\n    // Do not call this on a value that is already initialized.\n    jl_taggedvalue_t *tag = jl_astaggedvalue(v);\n    jl_atomic_store_relaxed(&tag->type, (jl_value_t*)t);\n}\n#define jl_typeis(v,t) (jl_typeof(v)==(jl_value_t*)(t))\n\n// Symbols are interned strings (hash-consed) stored as an invasive binary tree.\n// The string data is nul-terminated and hangs off the end of the struct.\ntypedef struct _jl_sym_t {\n    JL_DATA_TYPE\n    struct _jl_sym_t *left;\n    struct _jl_sym_t *right;\n    uintptr_t hash;    // precomputed hash value\n    // JL_ATTRIBUTE_ALIGN_PTRSIZE(char name[]);\n} jl_sym_t;\n\n// A numbered SSA value, for optimized code analysis and generation\n// the `id` is a unique, small number\ntypedef struct _jl_ssavalue_t {\n    JL_DATA_TYPE\n    ssize_t id;\n} jl_ssavalue_t;\n\n// A SimpleVector is an immutable pointer array\n// Data is stored at the end of this variable-length struct.\ntypedef struct {\n    JL_DATA_TYPE\n    size_t length;\n    // pointer size aligned\n    // jl_value_t *data[];\n} jl_svec_t;\n\ntypedef struct {\n    /*\n      how - allocation style\n      0 = data is inlined, or a foreign pointer we don't manage\n      1 = julia-allocated buffer that needs to be marked\n      2 = malloc-allocated pointer this array object manages\n      3 = has a pointer to the object that owns the data\n    */\n    uint16_t how:2;\n    uint16_t ndims:9;\n    uint16_t pooled:1;\n    uint16_t ptrarray:1; // representation is pointer array\n    uint16_t hasptr:1; // representation has embedded pointers\n    uint16_t isshared:1; // data is shared by multiple Arrays\n    uint16_t isaligned:1; // data allocated with memalign\n} jl_array_flags_t;\n\nJL_EXTENSION typedef struct {\n    JL_DATA_TYPE\n    void *data;\n#ifdef STORE_ARRAY_LEN\n    size_t length;\n#endif\n    jl_array_flags_t flags;\n    uint16_t elsize;  // element size including alignment (dim 1 memory stride)\n    uint32_t offset;  // for 1-d only. does not need to get big.\n    size_t nrows;\n    union {\n        // 1d\n        size_t maxsize;\n        // Nd\n        size_t ncols;\n    };\n    // other dim sizes go here for ndims > 2\n\n    // followed by alignment padding and inline data, or owner pointer\n} jl_array_t;\n\n// compute # of extra words needed to store dimensions\nSTATIC_INLINE int jl_array_ndimwords(uint32_t ndims) JL_NOTSAFEPOINT\n{\n    return (ndims < 3 ? 0 : ndims-2);\n}\n\ntypedef struct _jl_datatype_t jl_tupletype_t;\nstruct _jl_code_instance_t;\n\n// TypeMap is an implicitly defined type\n// that can consist of any of the following nodes:\n//   typedef TypeMap Union{TypeMapLevel, TypeMapEntry, Nothing}\n// it forms a roughly tree-shaped structure, consisting of nodes of TypeMapLevels\n// which split the tree when possible, for example based on the key into the tuple type at `offs`\n// when key is a leaftype, (but only when the tree has enough entries for this to be\n// more efficient than storing them sorted linearly)\n// otherwise the leaf entries are stored sorted, linearly\ntypedef jl_value_t jl_typemap_t;\n\ntypedef jl_value_t *(jl_call_t)(jl_value_t*, jl_value_t**, uint32_t, struct _jl_code_instance_t*);\ntypedef jl_call_t *jl_callptr_t;\n\n// \"speccall\" calling convention signatures.\n// This describes some of the special ABI used by compiled julia functions.\nJL_DLLEXPORT extern jl_call_t jl_fptr_args;\ntypedef jl_value_t *(*jl_fptr_args_t)(jl_value_t*, jl_value_t**, uint32_t);\n\nJL_DLLEXPORT extern jl_call_t jl_fptr_const_return;\n\nJL_DLLEXPORT extern jl_call_t jl_fptr_sparam;\ntypedef jl_value_t *(*jl_fptr_sparam_t)(jl_value_t*, jl_value_t**, uint32_t, jl_svec_t*);\n\nJL_DLLEXPORT extern jl_call_t jl_fptr_interpret_call;\n\nJL_EXTENSION typedef union {\n    void* fptr;\n    jl_fptr_args_t fptr1;\n    // 2 constant\n    jl_fptr_sparam_t fptr3;\n    // 4 interpreter\n} jl_generic_specptr_t;\n\ntypedef struct _jl_method_instance_t jl_method_instance_t;\n\ntypedef struct _jl_line_info_node_t {\n    struct _jl_module_t *module;\n    jl_value_t *method;\n    jl_sym_t *file;\n    intptr_t line;\n    intptr_t inlined_at;\n} jl_line_info_node_t;\n\n// This type describes a single function body\ntypedef struct _jl_code_info_t {\n    // ssavalue-indexed arrays of properties:\n    jl_array_t *code;  // Any array of statements\n    jl_value_t *codelocs; // Int32 array of indicies into the line table\n    jl_value_t *ssavaluetypes; // types of ssa values (or count of them)\n    jl_array_t *ssaflags; // flags associated with each statement:\n        // 0 = inbounds\n        // 1,2 = <reserved> inlinehint,always-inline,noinline\n        // 3 = <reserved> strict-ieee (strictfp)\n        // 4-6 = <unused>\n        // 7 = has out-of-band info\n    // miscellaneous data:\n    jl_value_t *method_for_inference_limit_heuristics; // optional method used during inference\n    jl_value_t *linetable; // Table of locations [TODO: make this volatile like slotnames]\n    jl_array_t *slotnames; // names of local variables\n    jl_array_t *slotflags;  // local var bit flags\n    // the following are optional transient properties (not preserved by compression--as they typically get stored elsewhere):\n    jl_value_t *slottypes; // inferred types of slots\n    jl_value_t *rettype;\n    jl_method_instance_t *parent; // context (optionally, if available, otherwise nothing)\n    jl_value_t *edges; // forward edges to method instances that must be invalidated\n    size_t min_world;\n    size_t max_world;\n    // various boolean properties:\n    uint8_t inferred;\n    uint8_t inlineable;\n    uint8_t propagate_inbounds;\n    uint8_t pure;\n    uint8_t aggressive_constprop;\n} jl_code_info_t;\n\n// This type describes a single method definition, and stores data\n// shared by the specializations of a function.\ntypedef struct _jl_method_t {\n    JL_DATA_TYPE\n    jl_sym_t *name;  // for error reporting\n    struct _jl_module_t *module;\n    jl_sym_t *file;\n    int32_t line;\n    size_t primary_world;\n    size_t deleted_world;\n\n    // method's type signature. redundant with TypeMapEntry->specTypes\n    jl_value_t *sig;\n\n    // table of all jl_method_instance_t specializations we have\n    jl_svec_t *specializations; // allocated as [hashable, ..., NULL, linear, ....]\n    jl_array_t *speckeyset; // index lookup by hash into specializations\n\n    jl_value_t *slot_syms; // compacted list of slot names (String)\n    jl_value_t *source;  // original code template (jl_code_info_t, but may be compressed), null for builtins\n    struct _jl_method_instance_t *unspecialized;  // unspecialized executable method instance, or null\n    jl_value_t *generator;  // executable code-generating function if available\n    jl_array_t *roots;  // pointers in generated code (shared to reduce memory), or null\n    jl_svec_t *ccallable; // svec(rettype, sig) if a ccallable entry point is requested for this\n\n    // cache of specializations of this method for invoke(), i.e.\n    // cases where this method was called even though it was not necessarily\n    // the most specific for the argument types.\n    jl_typemap_t *invokes;\n\n    int32_t nargs;\n    int32_t called;        // bit flags: whether each of the first 8 arguments is called\n    int32_t nospecialize;  // bit flags: which arguments should not be specialized\n    int32_t nkw;           // # of leading arguments that are actually keyword arguments\n                           // of another method.\n    uint8_t isva;\n    uint8_t pure;\n    uint8_t is_for_opaque_closure;\n    uint8_t aggressive_constprop;\n\n// hidden fields:\n    // lock for modifications to the method\n    jl_mutex_t writelock;\n} jl_method_t;\n\n// This type is a placeholder to cache data for a specType signature specialization of a Method\n// can can be used as a unique dictionary key representation of a call to a particular Method\n// with a particular set of argument types\nstruct _jl_method_instance_t {\n    JL_DATA_TYPE\n    union {\n        jl_value_t *value; // generic accessor\n        struct _jl_module_t *module; // this is a toplevel thunk\n        jl_method_t *method; // method this is specialized from\n    } def; // pointer back to the context for this code\n    jl_value_t *specTypes;  // argument types this was specialized for\n    jl_svec_t *sparam_vals; // static parameter values, indexed by def.method->sparam_syms\n    jl_value_t *uninferred; // cached uncompressed code, for generated functions, top-level thunks, or the interpreter\n    jl_array_t *backedges; // list of method-instances which contain a call into this method-instance\n    jl_array_t *callbacks; // list of callback functions to inform external caches about invalidations\n    struct _jl_code_instance_t *cache;\n    uint8_t inInference; // flags to tell if inference is running on this object\n};\n\n// OpaqueClosure\ntypedef struct jl_opaque_closure_t {\n    JL_DATA_TYPE\n    jl_value_t *captures;\n    uint8_t isva;\n    size_t world;\n    jl_method_t *source;\n    jl_fptr_args_t invoke;\n    void *specptr;\n} jl_opaque_closure_t;\n\n// This type represents an executable operation\ntypedef struct _jl_code_instance_t {\n    JL_DATA_TYPE\n    jl_method_instance_t *def; // method this is specialized from\n    struct _jl_code_instance_t *next; // pointer to the next cache entry\n\n    // world range for which this object is valid to use\n    size_t min_world;\n    size_t max_world;\n\n    // inference state cache\n    jl_value_t *rettype; // return type for fptr\n    jl_value_t *rettype_const; // inferred constant return value, or null\n    jl_value_t *inferred; // inferred jl_code_info_t, or jl_nothing, or null\n    //TODO: jl_array_t *edges; // stored information about edges from this object\n    //TODO: uint8_t absolute_max; // whether true max world is unknown\n\n    // compilation state cache\n    uint8_t isspecsig; // if specptr is a specialized function signature for specTypes->rettype\n    uint8_t precompile;  // if set, this will be added to the output system image\n    jl_callptr_t invoke; // jlcall entry point\n    jl_generic_specptr_t specptr; // private data for `jlcall entry point`\n} jl_code_instance_t;\n\n// all values are callable as Functions\ntypedef jl_value_t jl_function_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    jl_value_t *lb;   // lower bound\n    jl_value_t *ub;   // upper bound\n} jl_tvar_t;\n\n// UnionAll type (iterated union over all values of a variable in certain bounds)\n// written `body where lb<:var<:ub`\ntypedef struct {\n    JL_DATA_TYPE\n    jl_tvar_t *var;\n    jl_value_t *body;\n} jl_unionall_t;\n\n// represents the \"name\" part of a DataType, describing the syntactic structure\n// of a type and storing all data common to different instantiations of the type,\n// including a cache for hash-consed allocation of DataType objects.\ntypedef struct {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    struct _jl_module_t *module;\n    jl_svec_t *names;  // field names\n    // `wrapper` is either the only instantiation of the type (if no parameters)\n    // or a UnionAll accepting parameters to make an instantiation.\n    jl_value_t *wrapper;\n    jl_svec_t *cache;        // sorted array\n    jl_svec_t *linearcache;  // unsorted array\n    intptr_t hash;\n    struct _jl_methtable_t *mt;\n    jl_array_t *partial;     // incomplete instantiations of this type\n} jl_typename_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_value_t *a;\n    jl_value_t *b;\n} jl_uniontype_t;\n\n// in little-endian, isptr is always the first bit, avoiding the need for a branch in computing isptr\ntypedef struct {\n    uint8_t isptr:1;\n    uint8_t size:7;\n    uint8_t offset;   // offset relative to data start, excluding type tag\n} jl_fielddesc8_t;\n\ntypedef struct {\n    uint16_t isptr:1;\n    uint16_t size:15;\n    uint16_t offset;   // offset relative to data start, excluding type tag\n} jl_fielddesc16_t;\n\ntypedef struct {\n    uint32_t isptr:1;\n    uint32_t size:31;\n    uint32_t offset;   // offset relative to data start, excluding type tag\n} jl_fielddesc32_t;\n\ntypedef struct {\n    uint32_t nfields;\n    uint32_t npointers; // number of pointers embedded inside\n    int32_t first_ptr; // index of the first pointer (or -1)\n    uint16_t alignment; // strictest alignment over all fields\n    uint16_t haspadding : 1; // has internal undefined bytes\n    uint16_t fielddesc_type : 2; // 0 -> 8, 1 -> 16, 2 -> 32, 3 -> foreign type\n    // union {\n    //     jl_fielddesc8_t field8[nfields];\n    //     jl_fielddesc16_t field16[nfields];\n    //     jl_fielddesc32_t field32[nfields];\n    // };\n    // union { // offsets relative to data start in words\n    //     uint8_t ptr8[npointers];\n    //     uint16_t ptr16[npointers];\n    //     uint32_t ptr32[npointers];\n    // };\n} jl_datatype_layout_t;\n\ntypedef struct _jl_datatype_t {\n    JL_DATA_TYPE\n    jl_typename_t *name;\n    struct _jl_datatype_t *super;\n    jl_svec_t *parameters;\n    jl_svec_t *types;\n    jl_svec_t *names;\n    jl_value_t *instance;  // for singletons\n    const jl_datatype_layout_t *layout;\n    int32_t size; // TODO: move to _jl_datatype_layout_t\n    int32_t ninitialized;\n    uint32_t hash;\n    uint8_t abstract;\n    uint8_t mutabl;\n    // memoized properties\n    uint8_t hasfreetypevars; // majority part of isconcrete computation\n    uint8_t isconcretetype; // whether this type can have instances\n    uint8_t isdispatchtuple; // aka isleaftupletype\n    uint8_t isbitstype; // relevant query for C-api and type-parameters\n    uint8_t zeroinit; // if one or more fields requires zero-initialization\n    uint8_t isinlinealloc; // if this is allocated inline\n    uint8_t has_concrete_subtype; // If clear, no value will have this datatype\n    uint8_t cached_by_hash; // stored in hash-based set cache (instead of linear cache)\n} jl_datatype_t;\n\ntypedef struct _jl_vararg_t {\n    JL_DATA_TYPE\n    jl_value_t *T;\n    jl_value_t *N;\n} jl_vararg_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_value_t *value;\n} jl_weakref_t;\n\ntypedef struct {\n    // not first-class\n    jl_sym_t *name;\n    jl_value_t *value;\n    jl_value_t *globalref;  // cached GlobalRef for this binding\n    struct _jl_module_t *owner;  // for individual imported bindings\n    uint8_t constp;\n    uint8_t exportp:1;\n    uint8_t imported:1;\n    uint8_t deprecated:2; // 0=not deprecated, 1=renamed, 2=moved to another package\n} jl_binding_t;\n\ntypedef struct {\n    uint64_t hi;\n    uint64_t lo;\n} jl_uuid_t;\n\ntypedef struct _jl_module_t {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    struct _jl_module_t *parent;\n    // hidden fields:\n    htable_t bindings;\n    arraylist_t usings;  // modules with all bindings potentially imported\n    uint64_t build_id;\n    jl_uuid_t uuid;\n    size_t primary_world;\n    uint32_t counter;\n    int32_t nospecialize;  // global bit flags: initialization for new methods\n    int8_t optlevel;\n    int8_t compile;\n    int8_t infer;\n    uint8_t istopmod;\n    jl_mutex_t lock;\n} jl_module_t;\n\n// one Type-to-Value entry\ntypedef struct _jl_typemap_entry_t {\n    JL_DATA_TYPE\n    struct _jl_typemap_entry_t *next; // invasive linked list\n    jl_tupletype_t *sig; // the type signature for this entry\n    jl_tupletype_t *simplesig; // a simple signature for fast rejection\n    jl_svec_t *guardsigs;\n    size_t min_world;\n    size_t max_world;\n    union {\n        jl_value_t *value; // generic accessor\n        jl_method_instance_t *linfo; // [nullable] for guard entries\n        jl_method_t *method;\n    } func;\n    // memoized properties of sig:\n    int8_t isleafsig; // isleaftype(sig) & !any(isType, sig) : unsorted and very fast\n    int8_t issimplesig; // all(isleaftype | isAny | isType | isVararg, sig) : sorted and fast\n    int8_t va; // isVararg(sig)\n} jl_typemap_entry_t;\n\n// one level in a TypeMap tree (each level splits on a type at a given offset)\ntypedef struct _jl_typemap_level_t {\n    JL_DATA_TYPE\n    // these vectors contains vectors of more levels in their intended visit order\n    // with an index that gives the functionality of a sorted dict.\n    // next split may be on Type{T} as LeafTypes then TypeName's parents up to Any\n    // next split may be on LeafType\n    // next split may be on TypeName\n    jl_array_t *arg1; // contains LeafType\n    jl_array_t *targ; // contains Type{LeafType}\n    jl_array_t *name1; // contains non-abstract TypeName, for parents up to (excluding) Any\n    jl_array_t *tname; // contains a dict of Type{TypeName}, for parents up to Any\n    // next a linear list of things too complicated at this level for analysis (no more levels)\n    jl_typemap_entry_t *linear;\n    // finally, start a new level if the type at offs is Any\n    jl_typemap_t *any;\n} jl_typemap_level_t;\n\n// contains the TypeMap for one Type\ntypedef struct _jl_methtable_t {\n    JL_DATA_TYPE\n    jl_sym_t *name; // sometimes a hack used by serialization to handle kwsorter\n    jl_typemap_t *defs;\n    jl_array_t *leafcache;\n    jl_typemap_t *cache;\n    intptr_t max_args;  // max # of non-vararg arguments in a signature\n    jl_value_t *kwsorter;  // keyword argument sorter function\n    jl_module_t *module; // used for incremental serialization to locate original binding\n    jl_array_t *backedges;\n    jl_mutex_t writelock;\n    uint8_t offs;  // 0, or 1 to skip splitting typemap on first (function) argument\n    uint8_t frozen; // whether this accepts adding new methods\n} jl_methtable_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_sym_t *head;\n    jl_array_t *args;\n} jl_expr_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_tupletype_t *spec_types;\n    jl_svec_t *sparams;\n    jl_method_t *method;\n    // A bool on the julia side, but can be temporarily 0x2 as a sentinel\n    // during construction.\n    uint8_t fully_covers;\n} jl_method_match_t;\n\n// constants and type objects -------------------------------------------------\n\n// kinds\nextern JL_DLLIMPORT jl_datatype_t *jl_typeofbottom_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_datatype_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_uniontype_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_unionall_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_tvar_type JL_GLOBALLY_ROOTED;\n\nextern JL_DLLIMPORT jl_datatype_t *jl_any_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_unionall_t *jl_type_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_typename_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_typename_t *jl_type_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_symbol_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_ssavalue_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_abstractslot_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_slotnumber_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_typedslot_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_argument_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_const_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_partial_struct_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_partial_opaque_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_method_match_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_simplevector_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_typename_t *jl_tuple_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_typename_t *jl_vecelement_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_anytuple_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_emptytuple_type JL_GLOBALLY_ROOTED;\n#define jl_tuple_type jl_anytuple_type\nextern JL_DLLIMPORT jl_unionall_t *jl_anytuple_type_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_vararg_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_function_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_builtin_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_unionall_t *jl_opaque_closure_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_typename_t *jl_opaque_closure_typename JL_GLOBALLY_ROOTED;\n\nextern JL_DLLIMPORT jl_value_t *jl_bottom_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_method_instance_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_code_instance_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_code_info_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_method_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_module_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_unionall_t *jl_abstractarray_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_unionall_t *jl_densearray_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_unionall_t *jl_array_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_typename_t *jl_array_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_weakref_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_abstractstring_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_string_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_errorexception_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_argumenterror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_loaderror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_initerror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_typeerror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_methoderror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_undefvarerror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_lineinfonode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_stackovf_exception JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_memory_exception JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_readonlymemory_exception JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_diverror_exception JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_undefref_exception JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_interrupt_exception JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_boundserror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_an_empty_vec_any JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_an_empty_string JL_GLOBALLY_ROOTED;\n\nextern JL_DLLIMPORT jl_datatype_t *jl_bool_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_char_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_int8_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_uint8_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_int16_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_uint16_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_int32_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_uint32_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_int64_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_uint64_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_float16_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_float32_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_float64_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_floatingpoint_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_number_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_void_type JL_GLOBALLY_ROOTED;  // deprecated\nextern JL_DLLIMPORT jl_datatype_t *jl_nothing_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_signed_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_voidpointer_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_uint8pointer_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_unionall_t *jl_pointer_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_unionall_t *jl_llvmpointer_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_unionall_t *jl_ref_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_typename_t *jl_pointer_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_typename_t *jl_llvmpointer_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_typename_t *jl_namedtuple_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_unionall_t *jl_namedtuple_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_task_type JL_GLOBALLY_ROOTED;\n\nextern JL_DLLIMPORT jl_value_t *jl_array_uint8_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_array_any_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_array_symbol_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_array_int32_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_expr_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_globalref_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_linenumbernode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_gotonode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_gotoifnot_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_returnnode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_phinode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_pinode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_phicnode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_upsilonnode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_quotenode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_newvarnode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_intrinsic_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_methtable_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_typemap_level_type JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_datatype_t *jl_typemap_entry_type JL_GLOBALLY_ROOTED;\n\nextern JL_DLLIMPORT jl_svec_t *jl_emptysvec JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_emptytuple JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_true JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_false JL_GLOBALLY_ROOTED;\nextern JL_DLLIMPORT jl_value_t *jl_nothing JL_GLOBALLY_ROOTED;\n\n// gc -------------------------------------------------------------------------\n\ntypedef struct _jl_gcframe_t {\n    size_t nroots;\n    struct _jl_gcframe_t *prev;\n    // actual roots go here\n} jl_gcframe_t;\n\n// NOTE: it is the caller's responsibility to make sure arguments are\n// rooted such that the gc can see them on the stack.\n// `foo(f(), g())` is not safe,\n// since the result of `f()` is not rooted during the call to `g()`,\n// and the arguments to foo are not gc-protected during the call to foo.\n// foo can't do anything about it, so the caller must do:\n// jl_value_t *x=NULL, *y=NULL; JL_GC_PUSH2(&x, &y);\n// x = f(); y = g(); foo(x, y)\n\n#define jl_pgcstack (jl_get_ptls_states()->pgcstack)\n\n#define JL_GC_ENCODE_PUSHARGS(n)   (((size_t)(n))<<2)\n#define JL_GC_ENCODE_PUSH(n)       ((((size_t)(n))<<2)|1)\n\n#ifdef __clang_analyzer__\n\n// When running with the analyzer make these real function calls, that are\n// easier to detect in the analyzer\nextern void JL_GC_PUSH1(void *) JL_NOTSAFEPOINT;\nextern void JL_GC_PUSH2(void *, void *) JL_NOTSAFEPOINT;\nextern void JL_GC_PUSH3(void *, void *, void *)  JL_NOTSAFEPOINT;\nextern void JL_GC_PUSH4(void *, void *, void *, void *)  JL_NOTSAFEPOINT;\nextern void JL_GC_PUSH5(void *, void *, void *, void *, void *)  JL_NOTSAFEPOINT;\nextern void JL_GC_PUSH7(void *, void *, void *, void *, void *, void *, void *)  JL_NOTSAFEPOINT;\nextern void _JL_GC_PUSHARGS(jl_value_t **, size_t) JL_NOTSAFEPOINT;\n// This is necessary, because otherwise the analyzer considers this undefined\n// behavior and terminates the exploration\n#define JL_GC_PUSHARGS(rts_var, n)     \\\n  rts_var = (jl_value_t **)alloca(sizeof(void*) * (n)); \\\n  memset(rts_var, 0, sizeof(void*) * (n)); \\\n  _JL_GC_PUSHARGS(rts_var, (n));\n\nextern void JL_GC_POP() JL_NOTSAFEPOINT;\n\n#else\n\n#define JL_GC_PUSH1(arg1)                                                                               \\\n  void *__gc_stkf[] = {(void*)JL_GC_ENCODE_PUSH(1), jl_pgcstack, arg1};                                 \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH2(arg1, arg2)                                                                         \\\n  void *__gc_stkf[] = {(void*)JL_GC_ENCODE_PUSH(2), jl_pgcstack, arg1, arg2};                           \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH3(arg1, arg2, arg3)                                                                   \\\n  void *__gc_stkf[] = {(void*)JL_GC_ENCODE_PUSH(3), jl_pgcstack, arg1, arg2, arg3};                     \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH4(arg1, arg2, arg3, arg4)                                                             \\\n  void *__gc_stkf[] = {(void*)JL_GC_ENCODE_PUSH(4), jl_pgcstack, arg1, arg2, arg3, arg4};               \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH5(arg1, arg2, arg3, arg4, arg5)                                                       \\\n  void *__gc_stkf[] = {(void*)JL_GC_ENCODE_PUSH(5), jl_pgcstack, arg1, arg2, arg3, arg4, arg5};         \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH6(arg1, arg2, arg3, arg4, arg5, arg6)                                                 \\\n  void *__gc_stkf[] = {(void*)JL_GC_ENCODE_PUSH(6), jl_pgcstack, arg1, arg2, arg3, arg4, arg5, arg6};   \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH7(arg1, arg2, arg3, arg4, arg5, arg6, arg7)                                           \\\n  void *__gc_stkf[] = {(void*)JL_GC_ENCODE_PUSH(7), jl_pgcstack, arg1, arg2, arg3, arg4, arg5, arg6, arg7}; \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n\n#define JL_GC_PUSHARGS(rts_var,n)                                                                       \\\n  rts_var = ((jl_value_t**)alloca(((n)+2)*sizeof(jl_value_t*)))+2;                                      \\\n  ((void**)rts_var)[-2] = (void*)JL_GC_ENCODE_PUSHARGS(n);                                              \\\n  ((void**)rts_var)[-1] = jl_pgcstack;                                                                  \\\n  memset((void*)rts_var, 0, (n)*sizeof(jl_value_t*));                                                   \\\n  jl_pgcstack = (jl_gcframe_t*)&(((void**)rts_var)[-2])\n\n#define JL_GC_POP() (jl_pgcstack = jl_pgcstack->prev)\n\n#endif\n\nJL_DLLEXPORT int jl_gc_enable(int on);\nJL_DLLEXPORT int jl_gc_is_enabled(void);\n\ntypedef enum {\n    JL_GC_AUTO = 0,         // use heuristics to determine the collection type\n    JL_GC_FULL = 1,         // force a full collection\n    JL_GC_INCREMENTAL = 2,  // force an incremental collection\n} jl_gc_collection_t;\n\nJL_DLLEXPORT void jl_gc_collect(jl_gc_collection_t);\n\nJL_DLLEXPORT void jl_gc_add_finalizer(jl_value_t *v, jl_function_t *f);\nJL_DLLEXPORT void jl_finalize(jl_value_t *o);\nJL_DLLEXPORT jl_weakref_t *jl_gc_new_weakref(jl_value_t *value);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_0w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_1w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_2w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_3w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_allocobj(size_t sz);\nJL_DLLEXPORT void *jl_malloc_stack(size_t *bufsz, struct _jl_task_t *owner) JL_NOTSAFEPOINT;\nJL_DLLEXPORT void jl_free_stack(void *stkbuf, size_t bufsz);\nJL_DLLEXPORT void jl_gc_use(jl_value_t *a);\n\nJL_DLLEXPORT void jl_clear_malloc_data(void);\n\n// GC write barriers\nJL_DLLEXPORT void jl_gc_queue_root(jl_value_t *root) JL_NOTSAFEPOINT;\nJL_DLLEXPORT void jl_gc_queue_multiroot(jl_value_t *root, jl_value_t *stored) JL_NOTSAFEPOINT;\n\nSTATIC_INLINE void jl_gc_wb(void *parent, void *ptr) JL_NOTSAFEPOINT\n{\n    // parent and ptr isa jl_value_t*\n    if (__unlikely(jl_astaggedvalue(parent)->bits.gc == 3 && // parent is old and not in remset\n                   (jl_astaggedvalue(ptr)->bits.gc & 1) == 0)) // ptr is young\n        jl_gc_queue_root((jl_value_t*)parent);\n}\n\nSTATIC_INLINE void jl_gc_wb_back(void *ptr) JL_NOTSAFEPOINT // ptr isa jl_value_t*\n{\n    // if ptr is old\n    if (__unlikely(jl_astaggedvalue(ptr)->bits.gc == 3)) {\n        jl_gc_queue_root((jl_value_t*)ptr);\n    }\n}\n\nSTATIC_INLINE void jl_gc_multi_wb(void *parent, jl_value_t *ptr) JL_NOTSAFEPOINT\n{\n    // ptr is an immutable object\n    if (__likely(jl_astaggedvalue(parent)->bits.gc != 3))\n        return; // parent is young or in remset\n    if (__likely(jl_astaggedvalue(ptr)->bits.gc == 3))\n        return; // ptr is old and not in remset (thus it does not point to young)\n    jl_datatype_t *dt = (jl_datatype_t*)jl_typeof(ptr);\n    const jl_datatype_layout_t *ly = dt->layout;\n    if (ly->npointers)\n        jl_gc_queue_multiroot((jl_value_t*)parent, ptr);\n}\n\nJL_DLLEXPORT void *jl_gc_managed_malloc(size_t sz);\nJL_DLLEXPORT void *jl_gc_managed_realloc(void *d, size_t sz, size_t oldsz,\n                                         int isaligned, jl_value_t *owner);\n\n// object accessors -----------------------------------------------------------\n\n#define jl_svec_len(t)              (((jl_svec_t*)(t))->length)\n#define jl_svec_set_len_unsafe(t,n) (((jl_svec_t*)(t))->length=(n))\n#define jl_svec_data(t) ((jl_value_t**)((char*)(t) + sizeof(jl_svec_t)))\n\n#ifdef __clang_analyzer__\nSTATIC_INLINE jl_value_t *jl_svecref(void *t JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;\nSTATIC_INLINE jl_value_t *jl_svecset(\n    void *t JL_ROOTING_ARGUMENT JL_PROPAGATES_ROOT,\n    size_t i, void *x JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT;\n#else\nSTATIC_INLINE jl_value_t *jl_svecref(void *t JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT\n{\n    assert(jl_typeis(t,jl_simplevector_type));\n    assert(i < jl_svec_len(t));\n    // while svec is supposedly immutable, in practice we sometimes publish it first\n    // and set the values lazily\n    return jl_atomic_load_relaxed(jl_svec_data(t) + i);\n}\nSTATIC_INLINE jl_value_t *jl_svecset(\n    void *t JL_ROOTING_ARGUMENT JL_PROPAGATES_ROOT,\n    size_t i, void *x JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT\n{\n    assert(jl_typeis(t,jl_simplevector_type));\n    assert(i < jl_svec_len(t));\n    // TODO: while svec is supposedly immutable, in practice we sometimes publish it first\n    // and set the values lazily. Those users should be using jl_atomic_store_release here.\n    jl_svec_data(t)[i] = (jl_value_t*)x;\n    if (x) jl_gc_wb(t, x);\n    return (jl_value_t*)x;\n}\n#endif\n\n#ifdef STORE_ARRAY_LEN\n#define jl_array_len(a)   (((jl_array_t*)(a))->length)\n#else\nJL_DLLEXPORT size_t jl_array_len_(jl_array_t *a);\n#define jl_array_len(a)   jl_array_len_((jl_array_t*)(a))\n#endif\n#define jl_array_data(a)  ((void*)((jl_array_t*)(a))->data)\n#define jl_array_dim(a,i) ((&((jl_array_t*)(a))->nrows)[i])\n#define jl_array_dim0(a)  (((jl_array_t*)(a))->nrows)\n#define jl_array_nrows(a) (((jl_array_t*)(a))->nrows)\n#define jl_array_ndims(a) ((int32_t)(((jl_array_t*)a)->flags.ndims))\n#define jl_array_data_owner_offset(ndims) (offsetof(jl_array_t,ncols) + sizeof(size_t)*(1+jl_array_ndimwords(ndims))) // in bytes\n#define jl_array_data_owner(a) (*((jl_value_t**)((char*)a + jl_array_data_owner_offset(jl_array_ndims(a)))))\n\nJL_DLLEXPORT char *jl_array_typetagdata(jl_array_t *a) JL_NOTSAFEPOINT;\n\n#ifdef __clang_analyzer__\njl_value_t **jl_array_ptr_data(jl_array_t *a JL_PROPAGATES_ROOT) JL_NOTSAFEPOINT;\nSTATIC_INLINE jl_value_t *jl_array_ptr_ref(void *a JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;\nSTATIC_INLINE jl_value_t *jl_array_ptr_set(\n    void *a JL_ROOTING_ARGUMENT, size_t i,\n    void *x JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT;\n#else\n#define jl_array_ptr_data(a)  ((jl_value_t**)((jl_array_t*)(a))->data)\nSTATIC_INLINE jl_value_t *jl_array_ptr_ref(void *a JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT\n{\n    assert(((jl_array_t*)a)->flags.ptrarray);\n    assert(i < jl_array_len(a));\n    return jl_atomic_load_relaxed(((jl_value_t**)(jl_array_data(a))) + i);\n}\nSTATIC_INLINE jl_value_t *jl_array_ptr_set(\n    void *a JL_ROOTING_ARGUMENT, size_t i,\n    void *x JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT\n{\n    assert(((jl_array_t*)a)->flags.ptrarray);\n    assert(i < jl_array_len(a));\n    jl_atomic_store_relaxed(((jl_value_t**)(jl_array_data(a))) + i, (jl_value_t*)x);\n    if (x) {\n        if (((jl_array_t*)a)->flags.how == 3) {\n            a = jl_array_data_owner(a);\n        }\n        jl_gc_wb(a, x);\n    }\n    return (jl_value_t*)x;\n}\n#endif\n\nSTATIC_INLINE uint8_t jl_array_uint8_ref(void *a, size_t i) JL_NOTSAFEPOINT\n{\n    assert(i < jl_array_len(a));\n    assert(jl_typeis(a, jl_array_uint8_type));\n    return ((uint8_t*)(jl_array_data(a)))[i];\n}\nSTATIC_INLINE void jl_array_uint8_set(void *a, size_t i, uint8_t x) JL_NOTSAFEPOINT\n{\n    assert(i < jl_array_len(a));\n    assert(jl_typeis(a, jl_array_uint8_type));\n    ((uint8_t*)(jl_array_data(a)))[i] = x;\n}\n\n#define jl_exprarg(e,n) jl_array_ptr_ref(((jl_expr_t*)(e))->args, n)\n#define jl_exprargset(e, n, v) jl_array_ptr_set(((jl_expr_t*)(e))->args, n, v)\n#define jl_expr_nargs(e) jl_array_len(((jl_expr_t*)(e))->args)\n\n#define jl_fieldref(s,i) jl_get_nth_field(((jl_value_t*)(s)),i)\n#define jl_fieldref_noalloc(s,i) jl_get_nth_field_noalloc(((jl_value_t*)(s)),i)\n#define jl_nfields(v)    jl_datatype_nfields(jl_typeof(v))\n\n// Not using jl_fieldref to avoid allocations\n#define jl_linenode_line(x) (((intptr_t*)(x))[0])\n#define jl_linenode_file(x) (((jl_value_t**)(x))[1])\n#define jl_slot_number(x) (((intptr_t*)(x))[0])\n#define jl_typedslot_get_type(x) (((jl_value_t**)(x))[1])\n#define jl_gotonode_label(x) (((intptr_t*)(x))[0])\n#define jl_gotoifnot_cond(x) (((jl_value_t**)(x))[0])\n#define jl_gotoifnot_label(x) (((intptr_t*)(x))[1])\n#define jl_globalref_mod(s) (*(jl_module_t**)(s))\n#define jl_globalref_name(s) (((jl_sym_t**)(s))[1])\n#define jl_quotenode_value(x) (((jl_value_t**)x)[0])\n#define jl_returnnode_value(x) (((jl_value_t**)x)[0])\n\n#define jl_nparams(t)  jl_svec_len(((jl_datatype_t*)(t))->parameters)\n#define jl_tparam0(t)  jl_svecref(((jl_datatype_t*)(t))->parameters, 0)\n#define jl_tparam1(t)  jl_svecref(((jl_datatype_t*)(t))->parameters, 1)\n#define jl_tparam(t,i) jl_svecref(((jl_datatype_t*)(t))->parameters, i)\n\n// get a pointer to the data in a datatype\n#define jl_data_ptr(v)  ((jl_value_t**)v)\n\n#define jl_string_data(s) ((char*)s + sizeof(void*))\n#define jl_string_len(s)  (*(size_t*)s)\n\n#define jl_gf_mtable(f) (((jl_datatype_t*)jl_typeof(f))->name->mt)\n#define jl_gf_name(f)   (jl_gf_mtable(f)->name)\n\n// struct type info\nJL_DLLEXPORT jl_svec_t *jl_compute_fieldtypes(jl_datatype_t *st JL_PROPAGATES_ROOT, void *stack);\n#define jl_get_fieldtypes(st) ((st)->types ? (st)->types : jl_compute_fieldtypes((st), NULL))\nSTATIC_INLINE jl_svec_t *jl_field_names(jl_datatype_t *st) JL_NOTSAFEPOINT\n{\n    jl_svec_t *names = st->names;\n    if (!names)\n        names = st->name->names;\n    return names;\n}\nSTATIC_INLINE jl_sym_t *jl_field_name(jl_datatype_t *st, size_t i) JL_NOTSAFEPOINT\n{\n    return (jl_sym_t*)jl_svecref(jl_field_names(st), i);\n}\nSTATIC_INLINE jl_value_t *jl_field_type(jl_datatype_t *st JL_PROPAGATES_ROOT, size_t i)\n{\n    return jl_svecref(jl_get_fieldtypes(st), i);\n}\nSTATIC_INLINE jl_value_t *jl_field_type_concrete(jl_datatype_t *st JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT\n{\n    assert(st->types);\n    return jl_svecref(st->types, i);\n}\n\n#define jl_datatype_size(t)    (((jl_datatype_t*)t)->size)\n#define jl_datatype_align(t)   (((jl_datatype_t*)t)->layout->alignment)\n#define jl_datatype_nbits(t)   ((((jl_datatype_t*)t)->size)*8)\n#define jl_datatype_nfields(t) (((jl_datatype_t*)(t))->layout->nfields)\n#define jl_datatype_isinlinealloc(t) (((jl_datatype_t *)(t))->isinlinealloc)\n\nJL_DLLEXPORT void *jl_symbol_name(jl_sym_t *s);\n// inline version with strong type check to detect typos in a `->name` chain\nSTATIC_INLINE char *jl_symbol_name_(jl_sym_t *s) JL_NOTSAFEPOINT\n{\n    return (char*)s + LLT_ALIGN(sizeof(jl_sym_t), sizeof(void*));\n}\n#define jl_symbol_name(s) jl_symbol_name_(s)\n\nstatic inline uint32_t jl_fielddesc_size(int8_t fielddesc_type) JL_NOTSAFEPOINT\n{\n    assert(fielddesc_type >= 0 && fielddesc_type <= 2);\n    return 2 << fielddesc_type;\n    //if (fielddesc_type == 0) {\n    //    return sizeof(jl_fielddesc8_t);\n    //}\n    //else if (fielddesc_type == 1) {\n    //    return sizeof(jl_fielddesc16_t);\n    //}\n    //else {\n    //    return sizeof(jl_fielddesc32_t);\n    //}\n}\n\n#define jl_dt_layout_fields(d) ((const char*)(d) + sizeof(jl_datatype_layout_t))\nstatic inline const char *jl_dt_layout_ptrs(const jl_datatype_layout_t *l) JL_NOTSAFEPOINT\n{\n    return jl_dt_layout_fields(l) + jl_fielddesc_size(l->fielddesc_type) * l->nfields;\n}\n\n#define DEFINE_FIELD_ACCESSORS(f)                                             \\\n    static inline uint32_t jl_field_##f(jl_datatype_t *st,                    \\\n                                        int i) JL_NOTSAFEPOINT                \\\n    {                                                                         \\\n        const jl_datatype_layout_t *ly = st->layout;                          \\\n        assert(i >= 0 && (size_t)i < ly->nfields);                            \\\n        if (ly->fielddesc_type == 0) {                                        \\\n            return ((const jl_fielddesc8_t*)jl_dt_layout_fields(ly))[i].f;    \\\n        }                                                                     \\\n        else if (ly->fielddesc_type == 1) {                                   \\\n            return ((const jl_fielddesc16_t*)jl_dt_layout_fields(ly))[i].f;   \\\n        }                                                                     \\\n        else {                                                                \\\n            assert(ly->fielddesc_type == 2);                                  \\\n            return ((const jl_fielddesc32_t*)jl_dt_layout_fields(ly))[i].f;   \\\n        }                                                                     \\\n    }                                                                         \\\n\nDEFINE_FIELD_ACCESSORS(offset)\nDEFINE_FIELD_ACCESSORS(size)\n#undef DEFINE_FIELD_ACCESSORS\n\nstatic inline int jl_field_isptr(jl_datatype_t *st, int i) JL_NOTSAFEPOINT\n{\n    const jl_datatype_layout_t *ly = st->layout;\n    assert(i >= 0 && (size_t)i < ly->nfields);\n    return ((const jl_fielddesc8_t*)(jl_dt_layout_fields(ly) + jl_fielddesc_size(ly->fielddesc_type) * i))->isptr;\n}\n\nstatic inline uint32_t jl_ptr_offset(jl_datatype_t *st, int i) JL_NOTSAFEPOINT\n{\n    const jl_datatype_layout_t *ly = st->layout;\n    assert(i >= 0 && (size_t)i < ly->npointers);\n    const void *ptrs = jl_dt_layout_ptrs(ly);\n    if (ly->fielddesc_type == 0) {\n        return ((const uint8_t*)ptrs)[i];\n    }\n    else if (ly->fielddesc_type == 1) {\n        return ((const uint16_t*)ptrs)[i];\n    }\n    else {\n        assert(ly->fielddesc_type == 2);\n        return ((const uint32_t*)ptrs)[i];\n    }\n}\n\nstatic inline int jl_is_layout_opaque(const jl_datatype_layout_t *l) JL_NOTSAFEPOINT\n{\n    return l->nfields == 0 && l->npointers > 0;\n}\n\n// basic predicates -----------------------------------------------------------\n#define jl_is_nothing(v)     (((jl_value_t*)(v)) == ((jl_value_t*)jl_nothing))\n#define jl_is_tuple(v)       (((jl_datatype_t*)jl_typeof(v))->name == jl_tuple_typename)\n#define jl_is_namedtuple(v)  (((jl_datatype_t*)jl_typeof(v))->name == jl_namedtuple_typename)\n#define jl_is_svec(v)        jl_typeis(v,jl_simplevector_type)\n#define jl_is_simplevector(v) jl_is_svec(v)\n#define jl_is_datatype(v)    jl_typeis(v,jl_datatype_type)\n#define jl_is_mutable(t)     (((jl_datatype_t*)t)->mutabl)\n#define jl_is_mutable_datatype(t) (jl_is_datatype(t) && (((jl_datatype_t*)t)->mutabl))\n#define jl_is_immutable(t)   (!((jl_datatype_t*)t)->mutabl)\n#define jl_is_immutable_datatype(t) (jl_is_datatype(t) && (!((jl_datatype_t*)t)->mutabl))\n#define jl_is_uniontype(v)   jl_typeis(v,jl_uniontype_type)\n#define jl_is_typevar(v)     jl_typeis(v,jl_tvar_type)\n#define jl_is_unionall(v)    jl_typeis(v,jl_unionall_type)\n#define jl_is_typename(v)    jl_typeis(v,jl_typename_type)\n#define jl_is_int8(v)        jl_typeis(v,jl_int8_type)\n#define jl_is_int16(v)       jl_typeis(v,jl_int16_type)\n#define jl_is_int32(v)       jl_typeis(v,jl_int32_type)\n#define jl_is_int64(v)       jl_typeis(v,jl_int64_type)\n#define jl_is_uint8(v)       jl_typeis(v,jl_uint8_type)\n#define jl_is_uint16(v)      jl_typeis(v,jl_uint16_type)\n#define jl_is_uint32(v)      jl_typeis(v,jl_uint32_type)\n#define jl_is_uint64(v)      jl_typeis(v,jl_uint64_type)\n#define jl_is_bool(v)        jl_typeis(v,jl_bool_type)\n#define jl_is_symbol(v)      jl_typeis(v,jl_symbol_type)\n#define jl_is_ssavalue(v)    jl_typeis(v,jl_ssavalue_type)\n#define jl_is_slot(v)        (jl_typeis(v,jl_slotnumber_type) || jl_typeis(v,jl_typedslot_type))\n#define jl_is_expr(v)        jl_typeis(v,jl_expr_type)\n#define jl_is_globalref(v)   jl_typeis(v,jl_globalref_type)\n#define jl_is_gotonode(v)    jl_typeis(v,jl_gotonode_type)\n#define jl_is_gotoifnot(v)   jl_typeis(v,jl_gotoifnot_type)\n#define jl_is_returnnode(v)  jl_typeis(v,jl_returnnode_type)\n#define jl_is_argument(v)    jl_typeis(v,jl_argument_type)\n#define jl_is_pinode(v)      jl_typeis(v,jl_pinode_type)\n#define jl_is_phinode(v)     jl_typeis(v,jl_phinode_type)\n#define jl_is_phicnode(v)    jl_typeis(v,jl_phicnode_type)\n#define jl_is_upsilonnode(v) jl_typeis(v,jl_upsilonnode_type)\n#define jl_is_quotenode(v)   jl_typeis(v,jl_quotenode_type)\n#define jl_is_newvarnode(v)  jl_typeis(v,jl_newvarnode_type)\n#define jl_is_linenode(v)    jl_typeis(v,jl_linenumbernode_type)\n#define jl_is_method_instance(v) jl_typeis(v,jl_method_instance_type)\n#define jl_is_code_instance(v) jl_typeis(v,jl_code_instance_type)\n#define jl_is_code_info(v)   jl_typeis(v,jl_code_info_type)\n#define jl_is_method(v)      jl_typeis(v,jl_method_type)\n#define jl_is_module(v)      jl_typeis(v,jl_module_type)\n#define jl_is_mtable(v)      jl_typeis(v,jl_methtable_type)\n#define jl_is_task(v)        jl_typeis(v,jl_task_type)\n#define jl_is_string(v)      jl_typeis(v,jl_string_type)\n#define jl_is_cpointer(v)    jl_is_cpointer_type(jl_typeof(v))\n#define jl_is_pointer(v)     jl_is_cpointer_type(jl_typeof(v))\n#define jl_is_uint8pointer(v)jl_typeis(v,jl_uint8pointer_type)\n#define jl_is_llvmpointer(v) (((jl_datatype_t*)jl_typeof(v))->name == jl_llvmpointer_typename)\n#define jl_is_intrinsic(v)   jl_typeis(v,jl_intrinsic_type)\n#define jl_array_isbitsunion(a) (!(((jl_array_t*)(a))->flags.ptrarray) && jl_is_uniontype(jl_tparam0(jl_typeof(a))))\n\nJL_DLLEXPORT int jl_subtype(jl_value_t *a, jl_value_t *b);\n\nSTATIC_INLINE int jl_is_kind(jl_value_t *v) JL_NOTSAFEPOINT\n{\n    return (v==(jl_value_t*)jl_uniontype_type || v==(jl_value_t*)jl_datatype_type ||\n            v==(jl_value_t*)jl_unionall_type || v==(jl_value_t*)jl_typeofbottom_type);\n}\n\nSTATIC_INLINE int jl_is_type(jl_value_t *v) JL_NOTSAFEPOINT\n{\n    return jl_is_kind(jl_typeof(v));\n}\n\nSTATIC_INLINE int jl_is_primitivetype(void *v) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(v) && jl_is_immutable(v) &&\n            ((jl_datatype_t*)(v))->layout &&\n            jl_datatype_nfields(v) == 0 &&\n            jl_datatype_size(v) > 0);\n}\n\nSTATIC_INLINE int jl_is_structtype(void *v) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(v) &&\n            !((jl_datatype_t*)(v))->abstract &&\n            !jl_is_primitivetype(v));\n}\n\nSTATIC_INLINE int jl_isbits(void *t) JL_NOTSAFEPOINT // corresponding to isbits() in julia\n{\n    return (jl_is_datatype(t) && ((jl_datatype_t*)t)->isbitstype);\n}\n\nSTATIC_INLINE int jl_is_datatype_singleton(jl_datatype_t *d) JL_NOTSAFEPOINT\n{\n    return (d->instance != NULL);\n}\n\nSTATIC_INLINE int jl_is_abstracttype(void *v) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(v) && ((jl_datatype_t*)(v))->abstract);\n}\n\nSTATIC_INLINE int jl_is_array_type(void *t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_array_typename);\n}\n\nSTATIC_INLINE int jl_is_array(void *v) JL_NOTSAFEPOINT\n{\n    jl_value_t *t = jl_typeof(v);\n    return jl_is_array_type(t);\n}\n\n\nSTATIC_INLINE int jl_is_opaque_closure_type(void *t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_opaque_closure_typename);\n}\n\nSTATIC_INLINE int jl_is_opaque_closure(void *v) JL_NOTSAFEPOINT\n{\n    jl_value_t *t = jl_typeof(v);\n    return jl_is_opaque_closure_type(t);\n}\n\nSTATIC_INLINE int jl_is_cpointer_type(jl_value_t *t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == ((jl_datatype_t*)jl_pointer_type->body)->name);\n}\n\nSTATIC_INLINE int jl_is_llvmpointer_type(jl_value_t *t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_llvmpointer_typename);\n}\n\nSTATIC_INLINE int jl_is_abstract_ref_type(jl_value_t *t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == ((jl_datatype_t*)jl_ref_type->body)->name);\n}\n\nSTATIC_INLINE int jl_is_tuple_type(void *t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_tuple_typename);\n}\n\nSTATIC_INLINE int jl_is_namedtuple_type(void *t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_namedtuple_typename);\n}\n\nSTATIC_INLINE int jl_is_vecelement_type(jl_value_t* t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_vecelement_typename);\n}\n\nSTATIC_INLINE int jl_is_type_type(jl_value_t *v) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(v) &&\n            ((jl_datatype_t*)(v))->name == ((jl_datatype_t*)jl_type_type->body)->name);\n}\n\nSTATIC_INLINE int jl_is_array_zeroinit(jl_array_t *a) JL_NOTSAFEPOINT\n{\n    if (a->flags.ptrarray || a->flags.hasptr)\n        return 1;\n    jl_value_t *elty = jl_tparam0(jl_typeof(a));\n    return jl_is_datatype(elty) && ((jl_datatype_t*)elty)->zeroinit;\n}\n\n// object identity\nJL_DLLEXPORT int jl_egal(jl_value_t *a JL_MAYBE_UNROOTED, jl_value_t *b JL_MAYBE_UNROOTED) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uintptr_t jl_object_id(jl_value_t *v) JL_NOTSAFEPOINT;\n\n// type predicates and basic operations\nJL_DLLEXPORT int jl_type_equality_is_identity(jl_value_t *t1, jl_value_t *t2) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_has_free_typevars(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_has_typevar(jl_value_t *t, jl_tvar_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_has_typevar_from_unionall(jl_value_t *t, jl_unionall_t *ua);\nJL_DLLEXPORT int jl_subtype_env_size(jl_value_t *t);\nJL_DLLEXPORT int jl_subtype_env(jl_value_t *x, jl_value_t *y, jl_value_t **env, int envsz);\nJL_DLLEXPORT int jl_isa(jl_value_t *a, jl_value_t *t);\nJL_DLLEXPORT int jl_types_equal(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT int jl_is_not_broken_subtype(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_type_union(jl_value_t **ts, size_t n);\nJL_DLLEXPORT jl_value_t *jl_type_intersection(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT int jl_has_empty_intersection(jl_value_t *x, jl_value_t *y);\nJL_DLLEXPORT jl_value_t *jl_type_unionall(jl_tvar_t *v, jl_value_t *body);\nJL_DLLEXPORT const char *jl_typename_str(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT const char *jl_typeof_str(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_type_morespecific(jl_value_t *a, jl_value_t *b);\n\nSTATIC_INLINE int jl_is_dispatch_tupletype(jl_value_t *v) JL_NOTSAFEPOINT\n{\n    return jl_is_datatype(v) && ((jl_datatype_t*)v)->isdispatchtuple;\n}\n\nSTATIC_INLINE int jl_is_concrete_type(jl_value_t *v) JL_NOTSAFEPOINT\n{\n    return jl_is_datatype(v) && ((jl_datatype_t*)v)->isconcretetype;\n}\n\nJL_DLLEXPORT int jl_isa_compileable_sig(jl_tupletype_t *type, jl_method_t *definition);\n\n// type constructors\nJL_DLLEXPORT jl_typename_t *jl_new_typename_in(jl_sym_t *name, jl_module_t *inmodule);\nJL_DLLEXPORT jl_tvar_t *jl_new_typevar(jl_sym_t *name, jl_value_t *lb, jl_value_t *ub);\nJL_DLLEXPORT jl_value_t *jl_instantiate_unionall(jl_unionall_t *u, jl_value_t *p);\nJL_DLLEXPORT jl_value_t *jl_apply_type(jl_value_t *tc, jl_value_t **params, size_t n);\nJL_DLLEXPORT jl_value_t *jl_apply_type1(jl_value_t *tc, jl_value_t *p1);\nJL_DLLEXPORT jl_value_t *jl_apply_type2(jl_value_t *tc, jl_value_t *p1, jl_value_t *p2);\nJL_DLLEXPORT jl_tupletype_t *jl_apply_tuple_type(jl_svec_t *params);\nJL_DLLEXPORT jl_tupletype_t *jl_apply_tuple_type_v(jl_value_t **p, size_t np);\nJL_DLLEXPORT jl_datatype_t *jl_new_datatype(jl_sym_t *name,\n                                            jl_module_t *module,\n                                            jl_datatype_t *super,\n                                            jl_svec_t *parameters,\n                                            jl_svec_t *fnames, jl_svec_t *ftypes,\n                                            int abstract, int mutabl,\n                                            int ninitialized);\nJL_DLLEXPORT jl_datatype_t *jl_new_primitivetype(jl_value_t *name,\n                                                 jl_module_t *module,\n                                                 jl_datatype_t *super,\n                                                 jl_svec_t *parameters, size_t nbits);\n\n// constructors\nJL_DLLEXPORT jl_value_t *jl_new_bits(jl_value_t *bt, void *data);\nJL_DLLEXPORT jl_value_t *jl_new_struct(jl_datatype_t *type, ...);\nJL_DLLEXPORT jl_value_t *jl_new_structv(jl_datatype_t *type, jl_value_t **args, uint32_t na);\nJL_DLLEXPORT jl_value_t *jl_new_structt(jl_datatype_t *type, jl_value_t *tup);\nJL_DLLEXPORT jl_value_t *jl_new_struct_uninit(jl_datatype_t *type);\nJL_DLLEXPORT jl_method_instance_t *jl_new_method_instance_uninit(void);\nJL_DLLEXPORT jl_svec_t *jl_svec(size_t n, ...) JL_MAYBE_UNROOTED;\nJL_DLLEXPORT jl_svec_t *jl_svec1(void *a);\nJL_DLLEXPORT jl_svec_t *jl_svec2(void *a, void *b);\nJL_DLLEXPORT jl_svec_t *jl_alloc_svec(size_t n);\nJL_DLLEXPORT jl_svec_t *jl_alloc_svec_uninit(size_t n);\nJL_DLLEXPORT jl_svec_t *jl_svec_copy(jl_svec_t *a);\nJL_DLLEXPORT jl_svec_t *jl_svec_fill(size_t n, jl_value_t *x);\nJL_DLLEXPORT jl_value_t *jl_tupletype_fill(size_t n, jl_value_t *v);\nJL_DLLEXPORT jl_sym_t *jl_symbol(const char *str) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_sym_t *jl_symbol_lookup(const char *str) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_sym_t *jl_symbol_n(const char *str, size_t len) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_sym_t *jl_gensym(void);\nJL_DLLEXPORT jl_sym_t *jl_tagged_gensym(const char *str, size_t len);\nJL_DLLEXPORT jl_sym_t *jl_get_root_symbol(void);\nJL_DLLEXPORT jl_value_t *jl_generic_function_def(jl_sym_t *name,\n                                                 jl_module_t *module,\n                                                 jl_value_t **bp, jl_value_t *bp_owner,\n                                                 jl_binding_t *bnd);\nJL_DLLEXPORT jl_method_t* jl_method_def(jl_svec_t *argdata, jl_code_info_t *f, jl_module_t *module);\nJL_DLLEXPORT jl_code_info_t *jl_code_for_staged(jl_method_instance_t *linfo);\nJL_DLLEXPORT jl_code_info_t *jl_copy_code_info(jl_code_info_t *src);\nJL_DLLEXPORT size_t jl_get_world_counter(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_function_t *jl_get_kwsorter(jl_value_t *ty);\nJL_DLLEXPORT jl_value_t *jl_box_bool(int8_t x) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_box_int8(int8_t x) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_box_uint8(uint8_t x) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_box_int16(int16_t x);\nJL_DLLEXPORT jl_value_t *jl_box_uint16(uint16_t x);\nJL_DLLEXPORT jl_value_t *jl_box_int32(int32_t x);\nJL_DLLEXPORT jl_value_t *jl_box_uint32(uint32_t x);\nJL_DLLEXPORT jl_value_t *jl_box_char(uint32_t x);\nJL_DLLEXPORT jl_value_t *jl_box_int64(int64_t x);\nJL_DLLEXPORT jl_value_t *jl_box_uint64(uint64_t x);\nJL_DLLEXPORT jl_value_t *jl_box_float32(float x);\nJL_DLLEXPORT jl_value_t *jl_box_float64(double x);\nJL_DLLEXPORT jl_value_t *jl_box_voidpointer(void *x);\nJL_DLLEXPORT jl_value_t *jl_box_uint8pointer(uint8_t *x);\nJL_DLLEXPORT jl_value_t *jl_box_ssavalue(size_t x);\nJL_DLLEXPORT jl_value_t *jl_box_slotnumber(size_t x);\nJL_DLLEXPORT int8_t jl_unbox_bool(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int8_t jl_unbox_int8(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint8_t jl_unbox_uint8(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int16_t jl_unbox_int16(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint16_t jl_unbox_uint16(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int32_t jl_unbox_int32(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint32_t jl_unbox_uint32(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int64_t jl_unbox_int64(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint64_t jl_unbox_uint64(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT float jl_unbox_float32(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT double jl_unbox_float64(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT void *jl_unbox_voidpointer(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint8_t *jl_unbox_uint8pointer(jl_value_t *v) JL_NOTSAFEPOINT;\n\nJL_DLLEXPORT int jl_get_size(jl_value_t *val, size_t *pnt);\n\n#ifdef _P64\n#define jl_box_long(x)   jl_box_int64(x)\n#define jl_box_ulong(x)  jl_box_uint64(x)\n#define jl_unbox_long(x) jl_unbox_int64(x)\n#define jl_unbox_ulong(x) jl_unbox_uint64(x)\n#define jl_is_long(x)    jl_is_int64(x)\n#define jl_is_ulong(x)   jl_is_uint64(x)\n#define jl_long_type     jl_int64_type\n#define jl_ulong_type    jl_uint64_type\n#else\n#define jl_box_long(x)   jl_box_int32(x)\n#define jl_box_ulong(x)  jl_box_uint32(x)\n#define jl_unbox_long(x) jl_unbox_int32(x)\n#define jl_unbox_ulong(x) jl_unbox_uint32(x)\n#define jl_is_long(x)    jl_is_int32(x)\n#define jl_is_ulong(x)   jl_is_uint32(x)\n#define jl_long_type     jl_int32_type\n#define jl_ulong_type    jl_uint32_type\n#endif\n\n// structs\nJL_DLLEXPORT int         jl_field_index(jl_datatype_t *t, jl_sym_t *fld, int err);\nJL_DLLEXPORT jl_value_t *jl_get_nth_field(jl_value_t *v, size_t i);\n// Like jl_get_nth_field above, but asserts if it needs to allocate\nJL_DLLEXPORT jl_value_t *jl_get_nth_field_noalloc(jl_value_t *v JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_get_nth_field_checked(jl_value_t *v, size_t i);\nJL_DLLEXPORT void        jl_set_nth_field(jl_value_t *v, size_t i,\n                                          jl_value_t *rhs) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int         jl_field_isdefined(jl_value_t *v, size_t i) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_get_field(jl_value_t *o, const char *fld);\nJL_DLLEXPORT jl_value_t *jl_value_ptr(jl_value_t *a);\nint jl_uniontype_size(jl_value_t *ty, size_t *sz) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_islayout_inline(jl_value_t *eltype, size_t *fsz, size_t *al) JL_NOTSAFEPOINT;\n\n// arrays\nJL_DLLEXPORT jl_array_t *jl_new_array(jl_value_t *atype, jl_value_t *dims);\nJL_DLLEXPORT jl_array_t *jl_reshape_array(jl_value_t *atype, jl_array_t *data,\n                                          jl_value_t *dims);\nJL_DLLEXPORT jl_array_t *jl_ptr_to_array_1d(jl_value_t *atype, void *data,\n                                            size_t nel, int own_buffer);\nJL_DLLEXPORT jl_array_t *jl_ptr_to_array(jl_value_t *atype, void *data,\n                                         jl_value_t *dims, int own_buffer);\n\nJL_DLLEXPORT jl_array_t *jl_alloc_array_1d(jl_value_t *atype, size_t nr);\nJL_DLLEXPORT jl_array_t *jl_alloc_array_2d(jl_value_t *atype, size_t nr,\n                                           size_t nc);\nJL_DLLEXPORT jl_array_t *jl_alloc_array_3d(jl_value_t *atype, size_t nr,\n                                           size_t nc, size_t z);\nJL_DLLEXPORT jl_array_t *jl_pchar_to_array(const char *str, size_t len);\nJL_DLLEXPORT jl_value_t *jl_pchar_to_string(const char *str, size_t len);\nJL_DLLEXPORT jl_value_t *jl_cstr_to_string(const char *str);\nJL_DLLEXPORT jl_value_t *jl_alloc_string(size_t len);\nJL_DLLEXPORT jl_value_t *jl_array_to_string(jl_array_t *a);\nJL_DLLEXPORT jl_array_t *jl_alloc_vec_any(size_t n);\nJL_DLLEXPORT jl_value_t *jl_arrayref(jl_array_t *a, size_t i);  // 0-indexed\nJL_DLLEXPORT jl_value_t *jl_ptrarrayref(jl_array_t *a JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;  // 0-indexed\nJL_DLLEXPORT void jl_arrayset(jl_array_t *a JL_ROOTING_ARGUMENT, jl_value_t *v JL_ROOTED_ARGUMENT JL_MAYBE_UNROOTED, size_t i);  // 0-indexed\nJL_DLLEXPORT void jl_arrayunset(jl_array_t *a, size_t i);  // 0-indexed\nJL_DLLEXPORT int jl_array_isassigned(jl_array_t *a, size_t i);  // 0-indexed\nJL_DLLEXPORT void jl_array_grow_end(jl_array_t *a, size_t inc);\nJL_DLLEXPORT void jl_array_del_end(jl_array_t *a, size_t dec);\nJL_DLLEXPORT void jl_array_grow_beg(jl_array_t *a, size_t inc);\nJL_DLLEXPORT void jl_array_del_beg(jl_array_t *a, size_t dec);\nJL_DLLEXPORT void jl_array_sizehint(jl_array_t *a, size_t sz);\nJL_DLLEXPORT void jl_array_ptr_1d_push(jl_array_t *a, jl_value_t *item);\nJL_DLLEXPORT void jl_array_ptr_1d_append(jl_array_t *a, jl_array_t *a2);\nJL_DLLEXPORT jl_value_t *jl_apply_array_type(jl_value_t *type, size_t dim);\n// property access\nJL_DLLEXPORT void *jl_array_ptr(jl_array_t *a);\nJL_DLLEXPORT void *jl_array_eltype(jl_value_t *a);\nJL_DLLEXPORT int jl_array_rank(jl_value_t *a);\nJL_DLLEXPORT size_t jl_array_size(jl_value_t *a, int d);\n\n// strings\nJL_DLLEXPORT const char *jl_string_ptr(jl_value_t *s);\n\n// modules and global variables\nextern JL_DLLEXPORT jl_module_t *jl_main_module JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_module_t *jl_core_module JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_module_t *jl_base_module JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_module_t *jl_top_module JL_GLOBALLY_ROOTED;\nJL_DLLEXPORT jl_module_t *jl_new_module(jl_sym_t *name);\nJL_DLLEXPORT void jl_set_module_nospecialize(jl_module_t *self, int on);\nJL_DLLEXPORT void jl_set_module_optlevel(jl_module_t *self, int lvl);\nJL_DLLEXPORT int jl_get_module_optlevel(jl_module_t *m);\nJL_DLLEXPORT void jl_set_module_compile(jl_module_t *self, int value);\nJL_DLLEXPORT int jl_get_module_compile(jl_module_t *m);\nJL_DLLEXPORT void jl_set_module_infer(jl_module_t *self, int value);\nJL_DLLEXPORT int jl_get_module_infer(jl_module_t *m);\n// get binding for reading\nJL_DLLEXPORT jl_binding_t *jl_get_binding(jl_module_t *m JL_PROPAGATES_ROOT, jl_sym_t *var);\nJL_DLLEXPORT jl_binding_t *jl_get_binding_or_error(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT jl_value_t *jl_module_globalref(jl_module_t *m, jl_sym_t *var);\n// get binding for assignment\nJL_DLLEXPORT jl_binding_t *jl_get_binding_wr(jl_module_t *m JL_PROPAGATES_ROOT, jl_sym_t *var, int error);\nJL_DLLEXPORT jl_binding_t *jl_get_binding_for_method_def(jl_module_t *m JL_PROPAGATES_ROOT,\n                                                         jl_sym_t *var);\nJL_DLLEXPORT int jl_boundp(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT int jl_defines_or_exports_p(jl_module_t *m, jl_sym_t *var) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_binding_resolved_p(jl_module_t *m, jl_sym_t *var) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_is_const(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT jl_value_t *jl_get_global(jl_module_t *m JL_PROPAGATES_ROOT, jl_sym_t *var);\nJL_DLLEXPORT void jl_set_global(jl_module_t *m JL_ROOTING_ARGUMENT, jl_sym_t *var, jl_value_t *val JL_ROOTED_ARGUMENT);\nJL_DLLEXPORT void jl_set_const(jl_module_t *m JL_ROOTING_ARGUMENT, jl_sym_t *var, jl_value_t *val JL_ROOTED_ARGUMENT);\nJL_DLLEXPORT void jl_checked_assignment(jl_binding_t *b JL_ROOTING_ARGUMENT, jl_value_t *rhs JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT;\nJL_DLLEXPORT void jl_declare_constant(jl_binding_t *b);\nJL_DLLEXPORT void jl_module_using(jl_module_t *to, jl_module_t *from);\nJL_DLLEXPORT void jl_module_use(jl_module_t *to, jl_module_t *from, jl_sym_t *s);\nJL_DLLEXPORT void jl_module_use_as(jl_module_t *to, jl_module_t *from, jl_sym_t *s, jl_sym_t *asname);\nJL_DLLEXPORT void jl_module_import(jl_module_t *to, jl_module_t *from, jl_sym_t *s);\nJL_DLLEXPORT void jl_module_import_as(jl_module_t *to, jl_module_t *from, jl_sym_t *s, jl_sym_t *asname);\nJL_DLLEXPORT void jl_module_export(jl_module_t *from, jl_sym_t *s);\nJL_DLLEXPORT int jl_is_imported(jl_module_t *m, jl_sym_t *s);\nJL_DLLEXPORT int jl_module_exports_p(jl_module_t *m, jl_sym_t *var) JL_NOTSAFEPOINT;\nJL_DLLEXPORT void jl_add_standard_imports(jl_module_t *m);\nSTATIC_INLINE jl_function_t *jl_get_function(jl_module_t *m, const char *name)\n{\n    return (jl_function_t*)jl_get_global(m, jl_symbol(name));\n}\n\n// eq hash tables\nJL_DLLEXPORT jl_array_t *jl_eqtable_put(jl_array_t *h, jl_value_t *key, jl_value_t *val, int *inserted);\nJL_DLLEXPORT jl_value_t *jl_eqtable_get(jl_array_t *h, jl_value_t *key, jl_value_t *deflt) JL_NOTSAFEPOINT;\n\n// system information\nJL_DLLEXPORT int jl_errno(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT void jl_set_errno(int e) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int32_t jl_stat(const char *path, char *statbuf) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_cpu_threads(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT long jl_getpagesize(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT long jl_getallocationgranularity(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_is_debugbuild(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_sym_t *jl_get_UNAME(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_sym_t *jl_get_ARCH(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_get_libllvm(void) JL_NOTSAFEPOINT;\nextern JL_DLLIMPORT int jl_n_threads;\n\n// environment entries\nJL_DLLEXPORT jl_value_t *jl_environ(int i);\n\n// throwing common exceptions\nJL_DLLEXPORT jl_value_t *jl_vexceptionf(jl_datatype_t *exception_type,\n                                        const char *fmt, va_list args);\nJL_DLLEXPORT void JL_NORETURN jl_error(const char *str);\nJL_DLLEXPORT void JL_NORETURN jl_errorf(const char *fmt, ...);\nJL_DLLEXPORT void JL_NORETURN jl_exceptionf(jl_datatype_t *ty,\n                                            const char *fmt, ...);\nJL_DLLEXPORT void JL_NORETURN jl_too_few_args(const char *fname, int min);\nJL_DLLEXPORT void JL_NORETURN jl_too_many_args(const char *fname, int max);\nJL_DLLEXPORT void JL_NORETURN jl_type_error(const char *fname,\n                                            jl_value_t *expected JL_MAYBE_UNROOTED,\n                                            jl_value_t *got JL_MAYBE_UNROOTED);\nJL_DLLEXPORT void JL_NORETURN jl_type_error_rt(const char *fname,\n                                               const char *context,\n                                               jl_value_t *ty JL_MAYBE_UNROOTED,\n                                               jl_value_t *got JL_MAYBE_UNROOTED);\nJL_DLLEXPORT void JL_NORETURN jl_undefined_var_error(jl_sym_t *var);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error(jl_value_t *v JL_MAYBE_UNROOTED,\n                                              jl_value_t *t JL_MAYBE_UNROOTED);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_v(jl_value_t *v JL_MAYBE_UNROOTED,\n                                                jl_value_t **idxs, size_t nidxs);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_int(jl_value_t *v JL_MAYBE_UNROOTED,\n                                                  size_t i);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_tuple_int(jl_value_t **v,\n                                                        size_t nv, size_t i);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_unboxed_int(void *v, jl_value_t *vt, size_t i);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_ints(jl_value_t *v JL_MAYBE_UNROOTED,\n                                                   size_t *idxs, size_t nidxs);\nJL_DLLEXPORT void JL_NORETURN jl_eof_error(void);\n\n// Return the exception currently being handled, or `jl_nothing`.\n//\n// The catch scope is determined dynamically so this works in functions called\n// from a catch block.  The returned value is gc rooted until we exit the\n// enclosing JL_CATCH.\n// FIXME: Teach the static analyzer about this rather than using\n// JL_GLOBALLY_ROOTED which is far too optimistic.\nJL_DLLEXPORT jl_value_t *jl_current_exception(void) JL_GLOBALLY_ROOTED JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_exception_occurred(void);\nJL_DLLEXPORT void jl_exception_clear(void) JL_NOTSAFEPOINT;\n\n#define JL_NARGS(fname, min, max)                               \\\n    if (nargs < min) jl_too_few_args(#fname, min);              \\\n    else if (nargs > max) jl_too_many_args(#fname, max);\n\n#define JL_NARGSV(fname, min)                           \\\n    if (nargs < min) jl_too_few_args(#fname, min);\n\n#define JL_TYPECHK(fname, type, v)                                 \\\n    if (!jl_is_##type(v)) {                                        \\\n        jl_type_error(#fname, (jl_value_t*)jl_##type##_type, (v)); \\\n    }\n#define JL_TYPECHKS(fname, type, v)                                     \\\n    if (!jl_is_##type(v)) {                                             \\\n        jl_type_error(fname, (jl_value_t*)jl_##type##_type, (v));       \\\n    }\n\n// initialization functions\ntypedef enum {\n    JL_IMAGE_CWD = 0,\n    JL_IMAGE_JULIA_HOME = 1,\n    //JL_IMAGE_LIBJULIA = 2,\n} JL_IMAGE_SEARCH;\n// this helps turn threading compilation mismatches into linker errors\n#define julia_init julia_init__threading\n#define jl_init jl_init__threading\n#define jl_init_with_image jl_init_with_image__threading\n\nJL_DLLEXPORT const char *jl_get_libdir(void);\nJL_DLLEXPORT void julia_init(JL_IMAGE_SEARCH rel);\nJL_DLLEXPORT void jl_init(void);\nJL_DLLEXPORT void jl_init_with_image(const char *julia_bindir,\n                                     const char *image_relative_path);\nJL_DLLEXPORT const char *jl_get_default_sysimg_path(void);\nJL_DLLEXPORT int jl_is_initialized(void);\nJL_DLLEXPORT void jl_atexit_hook(int status);\nJL_DLLEXPORT void JL_NORETURN jl_exit(int status);\nJL_DLLEXPORT const char *jl_pathname_for_handle(void *handle);\n\nJL_DLLEXPORT int jl_deserialize_verify_header(ios_t *s);\nJL_DLLEXPORT void jl_preload_sysimg_so(const char *fname);\nJL_DLLEXPORT void jl_set_sysimg_so(void *handle);\nJL_DLLEXPORT ios_t *jl_create_system_image(void *);\nJL_DLLEXPORT void jl_save_system_image(const char *fname);\nJL_DLLEXPORT void jl_restore_system_image(const char *fname);\nJL_DLLEXPORT void jl_restore_system_image_data(const char *buf, size_t len);\nJL_DLLEXPORT int jl_save_incremental(const char *fname, jl_array_t *worklist);\nJL_DLLEXPORT jl_value_t *jl_restore_incremental(const char *fname, jl_array_t *depmods);\nJL_DLLEXPORT jl_value_t *jl_restore_incremental_from_buf(const char *buf, size_t sz, jl_array_t *depmods);\n\n// parsing\nJL_DLLEXPORT jl_value_t *jl_parse_all(const char *text, size_t text_len,\n                                      const char *filename, size_t filename_len);\nJL_DLLEXPORT jl_value_t *jl_parse_string(const char *text, size_t text_len,\n                                         int offset, int greedy);\n// lowering\nJL_DLLEXPORT jl_value_t *jl_expand(jl_value_t *expr, jl_module_t *inmodule);\nJL_DLLEXPORT jl_value_t *jl_expand_with_loc(jl_value_t *expr, jl_module_t *inmodule,\n                                            const char *file, int line);\nJL_DLLEXPORT jl_value_t *jl_expand_with_loc_warn(jl_value_t *expr, jl_module_t *inmodule,\n                                                 const char *file, int line);\nJL_DLLEXPORT jl_value_t *jl_expand_in_world(jl_value_t *expr, jl_module_t *inmodule,\n                                            const char *file, int line, size_t world);\nJL_DLLEXPORT jl_value_t *jl_expand_stmt(jl_value_t *expr, jl_module_t *inmodule);\nJL_DLLEXPORT jl_value_t *jl_expand_stmt_with_loc(jl_value_t *expr, jl_module_t *inmodule,\n                                                 const char *file, int line);\n// deprecated; use jl_parse_all\nJL_DLLEXPORT jl_value_t *jl_parse_input_line(const char *text, size_t text_len,\n                                             const char *filename, size_t filename_len);\n\n// external libraries\nenum JL_RTLD_CONSTANT {\n     JL_RTLD_LOCAL=1U,\n     JL_RTLD_GLOBAL=2U,\n     JL_RTLD_LAZY=4U,\n     JL_RTLD_NOW=8U,\n     /* Linux/glibc and MacOS X: */\n     JL_RTLD_NODELETE=16U,\n     JL_RTLD_NOLOAD=32U,\n     /* Linux/glibc: */\n     JL_RTLD_DEEPBIND=64U,\n     /* MacOS X 10.5+: */\n     JL_RTLD_FIRST=128U\n};\n#define JL_RTLD_DEFAULT (JL_RTLD_LAZY | JL_RTLD_DEEPBIND)\n\ntypedef void *jl_uv_libhandle; // compatible with dlopen (void*) / LoadLibrary (HMODULE)\nJL_DLLEXPORT jl_uv_libhandle jl_load_dynamic_library(const char *fname, unsigned flags, int throw_err) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_uv_libhandle jl_dlopen(const char *filename, unsigned flags) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_dlclose(jl_uv_libhandle handle) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_dlsym(jl_uv_libhandle handle, const char *symbol, void ** value, int throw_err) JL_NOTSAFEPOINT;\n\n// evaluation\nJL_DLLEXPORT jl_value_t *jl_toplevel_eval(jl_module_t *m, jl_value_t *v);\nJL_DLLEXPORT jl_value_t *jl_toplevel_eval_in(jl_module_t *m, jl_value_t *ex);\n// code loading (parsing + evaluation)\nJL_DLLEXPORT jl_value_t *jl_eval_string(const char *str); // embedding interface\nJL_DLLEXPORT jl_value_t *jl_load_file_string(const char *text, size_t len,\n                                             char *filename, jl_module_t *module);\nJL_DLLEXPORT jl_value_t *jl_load(jl_module_t *module, const char *fname);\n\nJL_DLLEXPORT jl_module_t *jl_base_relative_to(jl_module_t *m JL_PROPAGATES_ROOT);\n\n// tracing\nJL_DLLEXPORT void jl_register_newmeth_tracer(void (*callback)(jl_method_t *tracee));\n\n// AST access\nJL_DLLEXPORT jl_value_t *jl_copy_ast(jl_value_t *expr JL_MAYBE_UNROOTED);\n\n// IR representation\nJL_DLLEXPORT jl_array_t *jl_compress_ir(jl_method_t *m, jl_code_info_t *code);\nJL_DLLEXPORT jl_code_info_t *jl_uncompress_ir(jl_method_t *m, jl_code_instance_t *metadata, jl_array_t *data);\nJL_DLLEXPORT uint8_t jl_ir_flag_inferred(jl_array_t *data) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint8_t jl_ir_flag_inlineable(jl_array_t *data) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint8_t jl_ir_flag_pure(jl_array_t *data) JL_NOTSAFEPOINT;\nJL_DLLEXPORT ssize_t jl_ir_nslots(jl_array_t *data) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint8_t jl_ir_slotflag(jl_array_t *data, size_t i) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_compress_argnames(jl_array_t *syms);\nJL_DLLEXPORT jl_array_t *jl_uncompress_argnames(jl_value_t *syms);\nJL_DLLEXPORT jl_value_t *jl_uncompress_argname_n(jl_value_t *syms, size_t i);\n\nJL_DLLEXPORT int jl_is_operator(char *sym);\nJL_DLLEXPORT int jl_is_unary_operator(char *sym);\nJL_DLLEXPORT int jl_is_unary_and_binary_operator(char *sym);\nJL_DLLEXPORT int jl_is_syntactic_operator(char *sym);\nJL_DLLEXPORT int jl_operator_precedence(char *sym);\n\nSTATIC_INLINE int jl_vinfo_sa(uint8_t vi)\n{\n    return (vi&16)!=0;\n}\n\nSTATIC_INLINE int jl_vinfo_usedundef(uint8_t vi)\n{\n    return (vi&32)!=0;\n}\n\n// calling into julia ---------------------------------------------------------\n\nJL_DLLEXPORT jl_value_t *jl_apply_generic(jl_value_t *F, jl_value_t **args, uint32_t nargs);\nJL_DLLEXPORT jl_value_t *jl_invoke(jl_value_t *F, jl_value_t **args, uint32_t nargs, jl_method_instance_t *meth);\nJL_DLLEXPORT int32_t jl_invoke_api(jl_code_instance_t *linfo);\n\nSTATIC_INLINE jl_value_t *jl_apply(jl_value_t **args, uint32_t nargs)\n{\n    return jl_apply_generic(args[0], &args[1], nargs - 1);\n}\n\nJL_DLLEXPORT jl_value_t *jl_call(jl_function_t *f JL_MAYBE_UNROOTED, jl_value_t **args, int32_t nargs);\nJL_DLLEXPORT jl_value_t *jl_call0(jl_function_t *f JL_MAYBE_UNROOTED);\nJL_DLLEXPORT jl_value_t *jl_call1(jl_function_t *f JL_MAYBE_UNROOTED, jl_value_t *a JL_MAYBE_UNROOTED);\nJL_DLLEXPORT jl_value_t *jl_call2(jl_function_t *f JL_MAYBE_UNROOTED, jl_value_t *a JL_MAYBE_UNROOTED, jl_value_t *b JL_MAYBE_UNROOTED);\nJL_DLLEXPORT jl_value_t *jl_call3(jl_function_t *f JL_MAYBE_UNROOTED, jl_value_t *a JL_MAYBE_UNROOTED,\n                                  jl_value_t *b JL_MAYBE_UNROOTED, jl_value_t *c JL_MAYBE_UNROOTED);\n\n// interfacing with Task runtime\nJL_DLLEXPORT void jl_yield(void);\n\n// async signal handling ------------------------------------------------------\n\nJL_DLLEXPORT void jl_install_sigint_handler(void);\nJL_DLLEXPORT void jl_sigatomic_begin(void);\nJL_DLLEXPORT void jl_sigatomic_end(void);\n\n// tasks and exceptions -------------------------------------------------------\n\ntypedef struct _jl_timing_block_t jl_timing_block_t;\ntypedef struct _jl_excstack_t jl_excstack_t;\n\n// info describing an exception handler\ntypedef struct _jl_handler_t {\n    jl_jmp_buf eh_ctx;\n    jl_gcframe_t *gcstack;\n    struct _jl_handler_t *prev;\n    int8_t gc_state;\n    size_t locks_len;\n    sig_atomic_t defer_signal;\n    jl_timing_block_t *timing_stack;\n    size_t world_age;\n} jl_handler_t;\n\ntypedef struct _jl_task_t {\n    JL_DATA_TYPE\n    jl_value_t *next; // invasive linked list for scheduler\n    jl_value_t *queue; // invasive linked list for scheduler\n    jl_value_t *tls;\n    jl_value_t *donenotify;\n    jl_value_t *result;\n    jl_value_t *logstate;\n    jl_function_t *start;\n    uint8_t _state;\n    uint8_t sticky; // record whether this Task can be migrated to a new thread\n    uint8_t _isexception; // set if `result` is an exception to throw or that we exited with\n\n// hidden state:\n    // id of owning thread - does not need to be defined until the task runs\n    int16_t tid;\n    // multiqueue priority\n    int16_t prio;\n    // saved exception stack\n    jl_excstack_t *excstack;\n    // current exception handler\n    jl_handler_t *eh;\n\n    union {\n        jl_ucontext_t ctx; // saved thread state\n#ifdef _OS_WINDOWS_\n        jl_ucontext_t copy_stack_ctx;\n#else\n        struct jl_stack_context_t copy_stack_ctx;\n#endif\n    };\n#if defined(JL_TSAN_ENABLED)\n    void *tsan_state;\n#endif\n    void *stkbuf; // malloc'd memory (either copybuf or stack)\n    size_t bufsz; // actual sizeof stkbuf\n    unsigned int copy_stack:31; // sizeof stack for copybuf\n    unsigned int started:1;\n\n    // saved gc stack top for context switches\n    jl_gcframe_t *gcstack;\n} jl_task_t;\n\n#define JL_TASK_STATE_RUNNABLE 0\n#define JL_TASK_STATE_DONE     1\n#define JL_TASK_STATE_FAILED   2\n\nJL_DLLEXPORT jl_task_t *jl_new_task(jl_function_t*, jl_value_t*, size_t);\nJL_DLLEXPORT void jl_switchto(jl_task_t **pt);\nJL_DLLEXPORT void JL_NORETURN jl_throw(jl_value_t *e JL_MAYBE_UNROOTED);\nJL_DLLEXPORT void JL_NORETURN jl_rethrow(void);\nJL_DLLEXPORT void JL_NORETURN jl_sig_throw(void);\nJL_DLLEXPORT void JL_NORETURN jl_rethrow_other(jl_value_t *e JL_MAYBE_UNROOTED);\nJL_DLLEXPORT void JL_NORETURN jl_no_exc_handler(jl_value_t *e);\n\n#include \"locks.h\"   // requires jl_task_t definition\n\nJL_DLLEXPORT void jl_enter_handler(jl_handler_t *eh);\nJL_DLLEXPORT void jl_eh_restore_state(jl_handler_t *eh);\nJL_DLLEXPORT void jl_pop_handler(int n);\nJL_DLLEXPORT size_t jl_excstack_state(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT void jl_restore_excstack(size_t state) JL_NOTSAFEPOINT;\n\n#if defined(_OS_WINDOWS_)\n#if defined(_COMPILER_GCC_)\nint __attribute__ ((__nothrow__,__returns_twice__)) (jl_setjmp)(jmp_buf _Buf);\n__declspec(noreturn) __attribute__ ((__nothrow__)) void (jl_longjmp)(jmp_buf _Buf, int _Value);\n#else\nint (jl_setjmp)(jmp_buf _Buf);\nvoid (jl_longjmp)(jmp_buf _Buf, int _Value);\n#endif\n#define jl_setjmp_f jl_setjmp\n#define jl_setjmp_name \"jl_setjmp\"\n#define jl_setjmp(a,b) jl_setjmp(a)\n#define jl_longjmp(a,b) jl_longjmp(a,b)\n#elif defined(_OS_EMSCRIPTEN_)\n#define jl_setjmp(a,b) setjmp(a)\n#define jl_longjmp(a,b) longjmp(a,b)\n#define jl_setjmp_f    setjmp\n#define jl_setjmp_name \"setjmp\"\n#else\n// determine actual entry point name\n#if defined(sigsetjmp)\n#define jl_setjmp_f    __sigsetjmp\n#define jl_setjmp_name \"__sigsetjmp\"\n#else\n#define jl_setjmp_f    sigsetjmp\n#define jl_setjmp_name \"sigsetjmp\"\n#endif\n#define jl_setjmp(a,b) sigsetjmp(a,b)\n#define jl_longjmp(a,b) siglongjmp(a,b)\n#endif\n\n\n#ifdef __clang_analyzer__\n\n// This is hard. Ideally we'd teach the static analyzer about the extra control\n// flow edges. But for now, just hide this as best we can\nextern int had_exception;\n#define JL_TRY if (1)\n#define JL_CATCH if (had_exception)\n\n#else\n\n#define JL_TRY                                                    \\\n    int i__tr, i__ca; jl_handler_t __eh;                          \\\n    size_t __excstack_state = jl_excstack_state();                \\\n    jl_enter_handler(&__eh);                                      \\\n    if (!jl_setjmp(__eh.eh_ctx,0))                                \\\n        for (i__tr=1; i__tr; i__tr=0, jl_eh_restore_state(&__eh))\n\n#define JL_CATCH                                                \\\n    else                                                        \\\n        for (i__ca=1, jl_eh_restore_state(&__eh); i__ca; i__ca=0, jl_restore_excstack(__excstack_state))\n\n#endif\n\n// I/O system -----------------------------------------------------------------\n\n#define JL_STREAM uv_stream_t\n#define JL_STDOUT jl_uv_stdout\n#define JL_STDERR jl_uv_stderr\n#define JL_STDIN  jl_uv_stdin\n\nJL_DLLEXPORT int jl_process_events(void);\n\nJL_DLLEXPORT uv_loop_t *jl_global_event_loop(void);\n\nJL_DLLEXPORT void jl_close_uv(uv_handle_t *handle);\n\nJL_DLLEXPORT jl_array_t *jl_take_buffer(ios_t *s);\n\ntypedef struct {\n    void *data;\n    uv_loop_t *loop;\n    uv_handle_type type;\n    uv_os_fd_t file;\n} jl_uv_file_t;\n\n#ifdef __GNUC__\n#define _JL_FORMAT_ATTR(type, str, arg) \\\n    __attribute__((format(type, str, arg)))\n#else\n#define _JL_FORMAT_ATTR(type, str, arg)\n#endif\n\nJL_DLLEXPORT void jl_uv_puts(uv_stream_t *stream, const char *str, size_t n);\nJL_DLLEXPORT int jl_printf(uv_stream_t *s, const char *format, ...)\n    _JL_FORMAT_ATTR(printf, 2, 3);\nJL_DLLEXPORT int jl_vprintf(uv_stream_t *s, const char *format, va_list args)\n    _JL_FORMAT_ATTR(printf, 2, 0);\nJL_DLLEXPORT void jl_safe_printf(const char *str, ...) JL_NOTSAFEPOINT\n    _JL_FORMAT_ATTR(printf, 1, 2);\n\nextern JL_DLLEXPORT JL_STREAM *JL_STDIN;\nextern JL_DLLEXPORT JL_STREAM *JL_STDOUT;\nextern JL_DLLEXPORT JL_STREAM *JL_STDERR;\n\nJL_DLLEXPORT JL_STREAM *jl_stdout_stream(void);\nJL_DLLEXPORT JL_STREAM *jl_stdin_stream(void);\nJL_DLLEXPORT JL_STREAM *jl_stderr_stream(void);\n\n// showing and std streams\nJL_DLLEXPORT void jl_flush_cstdio(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_stdout_obj(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_stderr_obj(void) JL_NOTSAFEPOINT;\nJL_DLLEXPORT size_t jl_static_show(JL_STREAM *out, jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT size_t jl_static_show_func_sig(JL_STREAM *s, jl_value_t *type) JL_NOTSAFEPOINT;\nJL_DLLEXPORT void jlbacktrace(void) JL_NOTSAFEPOINT;\n// Mainly for debugging, use `void*` so that no type cast is needed in C++.\nJL_DLLEXPORT void jl_(void *jl_value) JL_NOTSAFEPOINT;\n\n// julia options -----------------------------------------------------------\n// NOTE: This struct needs to be kept in sync with JLOptions type in base/options.jl\ntypedef struct {\n    int8_t quiet;\n    int8_t banner;\n    const char *julia_bindir;\n    const char *julia_bin;\n    const char **cmds;\n    const char *image_file;\n    const char *cpu_target;\n    int32_t nthreads;\n    int32_t nprocs;\n    const char *machine_file;\n    const char *project;\n    int8_t isinteractive;\n    int8_t color;\n    int8_t historyfile;\n    int8_t startupfile;\n    int8_t compile_enabled;\n    int8_t code_coverage;\n    int8_t malloc_log;\n    int8_t opt_level;\n    int8_t debug_level;\n    int8_t check_bounds;\n    int8_t depwarn;\n    int8_t warn_overwrite;\n    int8_t can_inline;\n    int8_t polly;\n    const char *trace_compile;\n    int8_t fast_math;\n    int8_t worker;\n    const char *cookie;\n    int8_t handle_signals;\n    int8_t use_sysimage_native_code;\n    int8_t use_compiled_modules;\n    const char *bindto;\n    const char *outputbc;\n    const char *outputunoptbc;\n    const char *outputo;\n    const char *outputasm;\n    const char *outputji;\n    const char *output_code_coverage;\n    int8_t incremental;\n    int8_t image_file_specified;\n    int8_t warn_scope;\n    int8_t image_codegen;\n    int8_t rr_detach;\n} jl_options_t;\n\nextern JL_DLLEXPORT jl_options_t jl_options;\nJL_DLLEXPORT ssize_t jl_sizeof_jl_options(void);\n\n// Parse an argc/argv pair to extract general julia options, passing back out\n// any arguments that should be passed on to the script.\nJL_DLLEXPORT void jl_parse_opts(int *argcp, char ***argvp);\nJL_DLLEXPORT char *jl_format_filename(const char *output_pattern);\n\n// Set julia-level ARGS array according to the arguments provided in\n// argc/argv\nJL_DLLEXPORT void jl_set_ARGS(int argc, char **argv);\n\nJL_DLLEXPORT int jl_generating_output(void) JL_NOTSAFEPOINT;\n\n// Settings for code_coverage and malloc_log\n// NOTE: if these numbers change, test/cmdlineargs.jl will have to be updated\n#define JL_LOG_NONE 0\n#define JL_LOG_USER 1\n#define JL_LOG_ALL  2\n\n#define JL_OPTIONS_CHECK_BOUNDS_DEFAULT 0\n#define JL_OPTIONS_CHECK_BOUNDS_ON 1\n#define JL_OPTIONS_CHECK_BOUNDS_OFF 2\n\n#define JL_OPTIONS_COMPILE_DEFAULT 1\n#define JL_OPTIONS_COMPILE_OFF 0\n#define JL_OPTIONS_COMPILE_ON  1\n#define JL_OPTIONS_COMPILE_ALL 2\n#define JL_OPTIONS_COMPILE_MIN 3\n\n#define JL_OPTIONS_COLOR_AUTO 0\n#define JL_OPTIONS_COLOR_ON 1\n#define JL_OPTIONS_COLOR_OFF 2\n\n#define JL_OPTIONS_HISTORYFILE_ON 1\n#define JL_OPTIONS_HISTORYFILE_OFF 0\n\n#define JL_OPTIONS_STARTUPFILE_ON 1\n#define JL_OPTIONS_STARTUPFILE_OFF 2\n\n#define JL_LOGLEVEL_BELOWMIN -1000001\n#define JL_LOGLEVEL_DEBUG    -1000\n#define JL_LOGLEVEL_INFO      0\n#define JL_LOGLEVEL_WARN      1000\n#define JL_LOGLEVEL_ERROR     2000\n#define JL_LOGLEVEL_ABOVEMAX  1000001\n\n#define JL_OPTIONS_DEPWARN_OFF 0\n#define JL_OPTIONS_DEPWARN_ON 1\n#define JL_OPTIONS_DEPWARN_ERROR 2\n\n#define JL_OPTIONS_WARN_OVERWRITE_OFF 0\n#define JL_OPTIONS_WARN_OVERWRITE_ON 1\n\n#define JL_OPTIONS_WARN_SCOPE_OFF 0\n#define JL_OPTIONS_WARN_SCOPE_ON 1\n\n#define JL_OPTIONS_POLLY_ON 1\n#define JL_OPTIONS_POLLY_OFF 0\n\n#define JL_OPTIONS_FAST_MATH_ON 1\n#define JL_OPTIONS_FAST_MATH_OFF 2\n#define JL_OPTIONS_FAST_MATH_DEFAULT 0\n\n#define JL_OPTIONS_HANDLE_SIGNALS_ON 1\n#define JL_OPTIONS_HANDLE_SIGNALS_OFF 0\n\n#define JL_OPTIONS_USE_SYSIMAGE_NATIVE_CODE_YES 1\n#define JL_OPTIONS_USE_SYSIMAGE_NATIVE_CODE_NO 0\n\n#define JL_OPTIONS_USE_COMPILED_MODULES_YES 1\n#define JL_OPTIONS_USE_COMPILED_MODULES_NO 0\n\n// Version information\n#include \"julia_version.h\"\n\nJL_DLLEXPORT extern int jl_ver_major(void);\nJL_DLLEXPORT extern int jl_ver_minor(void);\nJL_DLLEXPORT extern int jl_ver_patch(void);\nJL_DLLEXPORT extern int jl_ver_is_release(void);\nJL_DLLEXPORT extern const char *jl_ver_string(void);\nJL_DLLEXPORT const char *jl_git_branch(void);\nJL_DLLEXPORT const char *jl_git_commit(void);\n\n// nullable struct representations\ntypedef struct {\n    uint8_t hasvalue;\n    double value;\n} jl_nullable_float64_t;\n\ntypedef struct {\n    uint8_t hasvalue;\n    float value;\n} jl_nullable_float32_t;\n\n#define jl_current_task (jl_get_ptls_states()->current_task)\n#define jl_root_task (jl_get_ptls_states()->root_task)\n\nJL_DLLEXPORT jl_value_t *jl_get_current_task(void);\n\nJL_DLLEXPORT jl_jmp_buf *jl_get_safe_restore(void);\nJL_DLLEXPORT void jl_set_safe_restore(jl_jmp_buf *);\n\n// codegen interface ----------------------------------------------------------\n// The root propagation here doesn't have to be literal, but callers should\n// ensure that the return value outlives the MethodInstance\ntypedef jl_value_t *(*jl_codeinstance_lookup_t)(jl_method_instance_t *mi JL_PROPAGATES_ROOT,\n    size_t min_world, size_t max_world);\ntypedef struct {\n    int track_allocations;  // can we track allocations?\n    int code_coverage;      // can we measure coverage?\n    int prefer_specsig;     // are specialized function signatures preferred?\n\n    // controls the emission of debug-info. mirrors the clang options\n    int gnu_pubnames;       // can we emit the gnu pubnames debuginfo\n    int debug_info_kind; // Enum for line-table-only, line-directives-only,\n                            // limited, standalone\n\n    // Cache access. Default: jl_rettype_inferred.\n    jl_codeinstance_lookup_t lookup;\n\n    // If not `nothing`, rewrite all generic calls to call\n    // generic_context(f, args...) instead of f(args...).\n    jl_value_t *generic_context;\n} jl_cgparams_t;\nextern JL_DLLEXPORT jl_cgparams_t jl_default_cgparams;\nextern JL_DLLEXPORT int jl_default_debug_info_kind;\n\n#if !defined(_OS_DARWIN_) && !defined(_OS_WINDOWS_)\n#define JULIA_DEFINE_FAST_TLS()                                                             \\\nJL_DLLEXPORT JL_CONST_FUNC jl_ptls_t jl_get_ptls_states_static(void)                        \\\n{                                                                                           \\\n    static __attribute__((tls_model(\"local-exec\"))) __thread jl_tls_states_t tls_states;    \\\n    return &tls_states;                                                                     \\\n}                                                                                           \\\n__attribute__((constructor)) void jl_register_ptls_states_getter(void)                      \\\n{                                                                                           \\\n    /* We need to make sure this function is called before any reference to */              \\\n    /* TLS variables. */                                                                    \\\n    jl_set_ptls_states_getter(jl_get_ptls_states_static);                                   \\\n}\n#else\n#define JULIA_DEFINE_FAST_TLS()\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/processor_arm.cpp": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n// ARM (AArch32/AArch64) specific processor detection and dispatch\n\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <set>\n#include <fstream>\n#include <algorithm>\n\n// This nesting is required to allow compilation on musl\n#define USE_DYN_GETAUXVAL\n#if defined(_OS_LINUX_) && defined(_CPU_AARCH64_)\n#  undef USE_DYN_GETAUXVAL\n#  include <sys/auxv.h>\n#elif defined(__GLIBC_PREREQ)\n#  if __GLIBC_PREREQ(2, 16)\n#    undef USE_DYN_GETAUXVAL\n#    include <sys/auxv.h>\n#  endif\n#endif\n\nnamespace ARM {\nenum class CPU : uint32_t {\n    generic = 0,\n\n    // Architecture targets\n    armv7_a,\n    armv7_m,\n    armv7e_m,\n    armv7_r,\n    armv8_a,\n    armv8_m_base,\n    armv8_m_main,\n    armv8_r,\n    armv8_1_a,\n    armv8_2_a,\n    armv8_3_a,\n    armv8_4_a,\n    armv8_5_a,\n    armv8_6_a,\n\n    // ARM\n    // armv6l\n    arm_mpcore,\n    arm_1136jf_s,\n    arm_1156t2f_s,\n    arm_1176jzf_s,\n    arm_cortex_m0,\n    arm_cortex_m1,\n    // armv7ml\n    arm_cortex_m3,\n    arm_cortex_m4,\n    arm_cortex_m7,\n    // armv7l\n    arm_cortex_a5,\n    arm_cortex_a7,\n    arm_cortex_a8,\n    arm_cortex_a9,\n    arm_cortex_a12,\n    arm_cortex_a15,\n    arm_cortex_a17,\n    arm_cortex_r4,\n    arm_cortex_r5,\n    arm_cortex_r7,\n    arm_cortex_r8,\n    // armv8ml\n    arm_cortex_m23,\n    arm_cortex_m33,\n    // armv8l\n    arm_cortex_a32,\n    arm_cortex_r52,\n    // aarch64\n    arm_cortex_a34,\n    arm_cortex_a35,\n    arm_cortex_a53,\n    arm_cortex_a55,\n    arm_cortex_a57,\n    arm_cortex_a65,\n    arm_cortex_a65ae,\n    arm_cortex_a72,\n    arm_cortex_a73,\n    arm_cortex_a75,\n    arm_cortex_a76,\n    arm_cortex_a76ae,\n    arm_cortex_a77,\n    arm_cortex_a78,\n    arm_cortex_x1,\n    arm_neoverse_e1,\n    arm_neoverse_n1,\n    arm_neoverse_v1,\n    arm_neoverse_n2,\n\n    // Cavium\n    // aarch64\n    cavium_thunderx,\n    cavium_thunderx88,\n    cavium_thunderx88p1,\n    cavium_thunderx81,\n    cavium_thunderx83,\n    cavium_thunderx2t99,\n    cavium_thunderx2t99p1,\n    cavium_octeontx2,\n    cavium_octeontx2t98,\n    cavium_octeontx2t96,\n    cavium_octeontx2f95,\n    cavium_octeontx2f95n,\n    cavium_octeontx2f95mm,\n\n    // Fujitsu\n    // aarch64\n    fujitsu_a64fx,\n\n    // HiSilicon\n    // aarch64\n    hisilicon_tsv110,\n\n    // Huaxingtong\n    // aarch64\n    hxt_phecda,\n\n    // NVIDIA\n    // aarch64\n    nvidia_denver1,\n    nvidia_denver2,\n    nvidia_carmel,\n\n    // AppliedMicro\n    // aarch64\n    apm_xgene1,\n    apm_xgene2,\n    apm_xgene3,\n\n    // Qualcomm\n    // armv7l\n    qualcomm_scorpion,\n    qualcomm_krait,\n    // aarch64\n    qualcomm_kyro,\n    qualcomm_falkor,\n    qualcomm_saphira,\n\n    // Samsung\n    // aarch64\n    samsung_exynos_m1,\n    samsung_exynos_m2,\n    samsung_exynos_m3,\n    samsung_exynos_m4,\n    samsung_exynos_m5,\n\n    // Apple\n    // armv7l\n    apple_swift,\n    // aarch64\n    apple_a7, // cyclone\n    apple_a8, // typhoon\n    apple_a9, // twister\n    apple_a10, // hurricane\n    apple_a11,\n    apple_a12,\n    apple_a13,\n    apple_s4,\n    apple_s5,\n\n    // Marvell\n    // armv7l\n    marvell_pj4,\n    // aarch64\n    marvell_thunderx3t110,\n\n    // Intel\n    // armv7l\n    intel_3735d,\n};\n\n#ifdef _CPU_AARCH64_\nstatic constexpr size_t feature_sz = 3;\nstatic constexpr FeatureName feature_names[] = {\n#define JL_FEATURE_DEF(name, bit, llvmver) {#name, bit, llvmver},\n#define JL_FEATURE_DEF_NAME(name, bit, llvmver, str) {str, bit, llvmver},\n#include \"features_aarch64.h\"\n#undef JL_FEATURE_DEF\n#undef JL_FEATURE_DEF_NAME\n};\nstatic constexpr uint32_t nfeature_names = sizeof(feature_names) / sizeof(FeatureName);\n\ntemplate<typename... Args>\nstatic inline constexpr FeatureList<feature_sz> get_feature_masks(Args... args)\n{\n    return ::get_feature_masks<feature_sz>(args...);\n}\n\n#define JL_FEATURE_DEF_NAME(name, bit, llvmver, str) JL_FEATURE_DEF(name, bit, llvmver)\nstatic constexpr auto feature_masks = get_feature_masks(\n#define JL_FEATURE_DEF(name, bit, llvmver) bit,\n#include \"features_aarch64.h\"\n#undef JL_FEATURE_DEF\n    -1);\nstatic const auto real_feature_masks =\n    feature_masks & FeatureList<feature_sz>{{(uint32_t)-1, (uint32_t)-1, 0}};\n\nnamespace Feature {\nenum : uint32_t {\n#define JL_FEATURE_DEF(name, bit, llvmver) name = bit,\n#include \"features_aarch64.h\"\n#undef JL_FEATURE_DEF\n};\n#undef JL_FEATURE_DEF_NAME\n// This does not cover all dependencies (e.g. the ones that depends on arm versions)\nstatic constexpr FeatureDep deps[] = {\n    {rcpc_immo, rcpc},\n    {sha3, sha2},\n    // {sha512, sha3},\n    {ccdp, ccpp},\n    {sve, fullfp16},\n    {fp16fml, fullfp16},\n    {altnzcv, fmi},\n    {sve2, sve},\n    {sve2_aes, sve2},\n    {sve2_aes, aes},\n    {sve2_bitperm, sve2},\n    {sve2_sha3, sve2},\n    {sve2_sha3, sha3},\n    {sve2_sm4, sve2},\n    {sve2_sm4, sm4},\n    {f32mm, sve},\n    {f64mm, sve},\n};\n\nconstexpr auto generic = get_feature_masks();\nconstexpr auto armv8a_crc = get_feature_masks(crc);\nconstexpr auto armv8a_crc_crypto = armv8a_crc | get_feature_masks(aes, sha2);\nconstexpr auto armv8_1a = armv8a_crc | get_feature_masks(v8_1a, lse, rdm); // lor\nconstexpr auto armv8_1a_crypto = armv8_1a | get_feature_masks(aes, sha2);\nconstexpr auto armv8_2a = armv8_1a | get_feature_masks(v8_2a, ccpp);\nconstexpr auto armv8_2a_crypto = armv8_2a | get_feature_masks(aes, sha2);\nconstexpr auto armv8_3a = armv8_2a | get_feature_masks(v8_3a, jsconv, complxnum, rcpc);\nconstexpr auto armv8_3a_crypto = armv8_3a | get_feature_masks(aes, sha2);\nconstexpr auto armv8_4a = armv8_3a | get_feature_masks(v8_4a, dit, rcpc_immo, fmi);\nconstexpr auto armv8_4a_crypto = armv8_4a | get_feature_masks(aes, sha2);\nconstexpr auto armv8_5a = armv8_4a | get_feature_masks(v8_5a, sb, ccdp, altnzcv, fptoint);\nconstexpr auto armv8_6a = armv8_5a | get_feature_masks(v8_6a, i8mm, bf16);\n\n// For ARM cores, the features required can be found in the technical reference manual\n// The relevant register values and the features they are related to are:\n// ID_AA64ISAR0_EL1:\n//     .AES: aes, pmull\n//     .SHA1: sha1\n//     .SHA2: sha2, sha512\n//     .CRC32: crc\n//     .Atomic: les\n//     .RDM: rdm\n//     .SHA3: sha3\n//     .SM3: sm3 (sm4)\n//     .SM4: sm4\n//     .DP: dotprod\n//     .FHM: fp16fml\n//     .TS: fmi, altnzcz\n//     .RNDR: rand\n\n// ID_AA64ISAR1_EL1\n//     .JSCVT: jsconv\n//     .FCMA: complxnum\n//     .LRCPC: rcpc, rcpc_immo\n//     .DPB: ccpp, ccdp\n//     .SB: sb\n//     .APA/.API: paca (pa)\n//     .GPA/.GPI: paga (pa)\n//     .FRINTTS: fptoint\n//     .I8MM: i8mm\n//     .BF16: bf16\n//     .DGH: dgh\n\n// ID_AA64PFR0_EL1\n//     .FP: fullfp16\n//     .SVE: sve\n//     .DIT: dit\n//     .BT: bti\n\n// ID_AA64PFR1_EL1\n//     .SSBS: ssbs\n//     .MTE: mte\n\n// ID_AA64MMFR2_EL1.AT: uscat\n\n// ID_AA64ZFR0_EL1\n//     .SVEVer: sve2\n//     .AES: sve2-aes, sve2-pmull\n//     .BitPerm: sve2-bitperm\n//     .SHA3: sve2-sha3\n//     .SM4: sve2-sm4\n//     .F32MM: f32mm\n//     .F64MM: f64mm\n\nconstexpr auto arm_cortex_a34 = armv8a_crc;\nconstexpr auto arm_cortex_a35 = armv8a_crc;\nconstexpr auto arm_cortex_a53 = armv8a_crc;\nconstexpr auto arm_cortex_a55 = armv8_2a | get_feature_masks(dotprod, rcpc, fullfp16, ssbs);\nconstexpr auto arm_cortex_a57 = armv8a_crc;\nconstexpr auto arm_cortex_a65 = armv8_2a | get_feature_masks(rcpc, fullfp16, ssbs);\nconstexpr auto arm_cortex_a72 = armv8a_crc;\nconstexpr auto arm_cortex_a73 = armv8a_crc;\nconstexpr auto arm_cortex_a75 = armv8_2a | get_feature_masks(dotprod, rcpc, fullfp16);\nconstexpr auto arm_cortex_a76 = armv8_2a | get_feature_masks(dotprod, rcpc, fullfp16, ssbs);\nconstexpr auto arm_cortex_a77 = armv8_2a | get_feature_masks(dotprod, rcpc, fullfp16, ssbs);\nconstexpr auto arm_cortex_a78 = armv8_2a | get_feature_masks(dotprod, rcpc, fullfp16, ssbs); // spe\nconstexpr auto arm_cortex_x1 = armv8_2a | get_feature_masks(dotprod, rcpc, fullfp16, ssbs); // spe\nconstexpr auto arm_neoverse_e1 = armv8_2a | get_feature_masks(rcpc, fullfp16, ssbs);\nconstexpr auto arm_neoverse_n1 = armv8_2a | get_feature_masks(dotprod, rcpc, fullfp16, ssbs);\nconstexpr auto arm_neoverse_v1 = armv8_4a | get_feature_masks(sve, i8mm, bf16, fullfp16, ssbs, rand);\nconstexpr auto arm_neoverse_n2 = armv8_5a | get_feature_masks(sve, i8mm, bf16, fullfp16, sve2,\n                                                              sve2_bitperm, rand, mte);\nconstexpr auto cavium_thunderx = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx88 = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx88p1 = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx81 = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx83 = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx2t99 = armv8_1a_crypto;\nconstexpr auto cavium_thunderx2t99p1 = cavium_thunderx2t99;\nconstexpr auto cavium_octeontx2 = armv8_2a_crypto;\nconstexpr auto fujitsu_a64fx = armv8_2a | get_feature_masks(sha2, fullfp16, sve, complxnum);\nconstexpr auto hisilicon_tsv110 = armv8_2a_crypto | get_feature_masks(dotprod, fullfp16);\nconstexpr auto hxt_phecda = armv8a_crc_crypto;\nconstexpr auto marvell_thunderx3t110 = armv8_3a_crypto;\nconstexpr auto nvidia_denver1 = generic; // TODO? (crc, crypto)\nconstexpr auto nvidia_denver2 = armv8a_crc_crypto;\nconstexpr auto nvidia_carmel = armv8_2a_crypto | get_feature_masks(fullfp16);\nconstexpr auto apm_xgene1 = generic;\nconstexpr auto apm_xgene2 = generic; // TODO?\nconstexpr auto apm_xgene3 = generic; // TODO?\nconstexpr auto qualcomm_kyro = armv8a_crc_crypto;\nconstexpr auto qualcomm_falkor = armv8a_crc_crypto | get_feature_masks(rdm);\nconstexpr auto qualcomm_saphira = armv8_4a_crypto;\nconstexpr auto samsung_exynos_m1 = armv8a_crc_crypto;\nconstexpr auto samsung_exynos_m2 = armv8a_crc_crypto;\nconstexpr auto samsung_exynos_m3 = armv8a_crc_crypto;\nconstexpr auto samsung_exynos_m4 = armv8_2a_crypto | get_feature_masks(dotprod, fullfp16);\nconstexpr auto samsung_exynos_m5 = samsung_exynos_m4;\nconstexpr auto apple_a7 = armv8a_crc_crypto;\nconstexpr auto apple_a10 = armv8a_crc_crypto | get_feature_masks(rdm);\nconstexpr auto apple_a11 = armv8_2a_crypto | get_feature_masks(fullfp16);\nconstexpr auto apple_a12 = armv8_3a_crypto | get_feature_masks(fullfp16);\nconstexpr auto apple_a13 = armv8_4a_crypto | get_feature_masks(fp16fml, fullfp16, sha3);\nconstexpr auto apple_s4 = apple_a12;\nconstexpr auto apple_s5 = apple_a12;\n\n}\n\nstatic constexpr CPUSpec<CPU, feature_sz> cpus[] = {\n    {\"generic\", CPU::generic, CPU::generic, 0, Feature::generic},\n    {\"armv8.1-a\", CPU::armv8_1_a, CPU::generic, 0, Feature::armv8_1a},\n    {\"armv8.2-a\", CPU::armv8_2_a, CPU::generic, 0, Feature::armv8_2a},\n    {\"armv8.3_a\", CPU::armv8_3_a, CPU::generic, 0, Feature::armv8_3a},\n    {\"armv8.4-a\", CPU::armv8_4_a, CPU::generic, 0, Feature::armv8_4a},\n    {\"armv8.5-a\", CPU::armv8_5_a, CPU::generic, 0, Feature::armv8_5a},\n    {\"armv8.6_a\", CPU::armv8_6_a, CPU::generic, 0, Feature::armv8_6a},\n    {\"cortex-a34\", CPU::arm_cortex_a34, CPU::arm_cortex_a35, 110000, Feature::arm_cortex_a34},\n    {\"cortex-a35\", CPU::arm_cortex_a35, CPU::generic, 0, Feature::arm_cortex_a35},\n    {\"cortex-a53\", CPU::arm_cortex_a53, CPU::generic, 0, Feature::arm_cortex_a53},\n    {\"cortex-a55\", CPU::arm_cortex_a55, CPU::generic, 0, Feature::arm_cortex_a55},\n    {\"cortex-a57\", CPU::arm_cortex_a57, CPU::generic, 0, Feature::arm_cortex_a57},\n    {\"cortex-a65\", CPU::arm_cortex_a65, CPU::arm_cortex_a75, 100000, Feature::arm_cortex_a65},\n    {\"cortex-a65ae\", CPU::arm_cortex_a65ae, CPU::arm_cortex_a75, 100000, Feature::arm_cortex_a65},\n    {\"cortex-a72\", CPU::arm_cortex_a72, CPU::generic, 0, Feature::arm_cortex_a72},\n    {\"cortex-a73\", CPU::arm_cortex_a73, CPU::generic, 0, Feature::arm_cortex_a73},\n    {\"cortex-a75\", CPU::arm_cortex_a75, CPU::generic, 0, Feature::arm_cortex_a75},\n    {\"cortex-a76\", CPU::arm_cortex_a76, CPU::generic, 0, Feature::arm_cortex_a76},\n    {\"cortex-a76ae\", CPU::arm_cortex_a76ae, CPU::generic, 0, Feature::arm_cortex_a76},\n    {\"cortex-a77\", CPU::arm_cortex_a77, CPU::arm_cortex_a76, 110000, Feature::arm_cortex_a77},\n    {\"cortex-a78\", CPU::arm_cortex_a78, CPU::arm_cortex_a77, 110000, Feature::arm_cortex_a78},\n    {\"cortex-x1\", CPU::arm_cortex_x1, CPU::arm_cortex_a78, 110000, Feature::arm_cortex_x1},\n    {\"neoverse-e1\", CPU::arm_neoverse_e1, CPU::arm_cortex_a76, 100000, Feature::arm_neoverse_e1},\n    {\"neoverse-n1\", CPU::arm_neoverse_n1, CPU::arm_cortex_a76, 100000, Feature::arm_neoverse_n1},\n    {\"neoverse-v1\", CPU::arm_neoverse_v1, CPU::arm_neoverse_n1, UINT32_MAX, Feature::arm_neoverse_v1},\n    {\"neoverse-n2\", CPU::arm_neoverse_n2, CPU::arm_neoverse_n1, UINT32_MAX, Feature::arm_neoverse_n2},\n    {\"thunderx\", CPU::cavium_thunderx, CPU::generic, 0, Feature::cavium_thunderx},\n    {\"thunderxt88\", CPU::cavium_thunderx88, CPU::generic, 0, Feature::cavium_thunderx88},\n    {\"thunderxt88p1\", CPU::cavium_thunderx88p1, CPU::cavium_thunderx88, UINT32_MAX,\n     Feature::cavium_thunderx88p1},\n    {\"thunderxt81\", CPU::cavium_thunderx81, CPU::generic, 0, Feature::cavium_thunderx81},\n    {\"thunderxt83\", CPU::cavium_thunderx83, CPU::generic, 0, Feature::cavium_thunderx83},\n    {\"thunderx2t99\", CPU::cavium_thunderx2t99, CPU::generic, 0, Feature::cavium_thunderx2t99},\n    {\"thunderx2t99p1\", CPU::cavium_thunderx2t99p1, CPU::cavium_thunderx2t99, UINT32_MAX,\n     Feature::cavium_thunderx2t99p1},\n    {\"octeontx2\", CPU::cavium_octeontx2, CPU::arm_cortex_a57, UINT32_MAX,\n     Feature::cavium_octeontx2},\n    {\"octeontx2t98\", CPU::cavium_octeontx2t98, CPU::arm_cortex_a57, UINT32_MAX,\n     Feature::cavium_octeontx2},\n    {\"octeontx2t96\", CPU::cavium_octeontx2t96, CPU::arm_cortex_a57, UINT32_MAX,\n     Feature::cavium_octeontx2},\n    {\"octeontx2f95\", CPU::cavium_octeontx2f95, CPU::arm_cortex_a57, UINT32_MAX,\n     Feature::cavium_octeontx2},\n    {\"octeontx2f95n\", CPU::cavium_octeontx2f95n, CPU::arm_cortex_a57, UINT32_MAX,\n     Feature::cavium_octeontx2},\n    {\"octeontx2f95mm\", CPU::cavium_octeontx2f95mm, CPU::arm_cortex_a57, UINT32_MAX,\n     Feature::cavium_octeontx2},\n    {\"a64fx\", CPU::fujitsu_a64fx, CPU::generic, 110000, Feature::fujitsu_a64fx},\n    {\"tsv110\", CPU::hisilicon_tsv110, CPU::generic, 0, Feature::hisilicon_tsv110},\n    {\"phecda\", CPU::hxt_phecda, CPU::qualcomm_falkor, UINT32_MAX, Feature::hxt_phecda},\n    {\"denver1\", CPU::nvidia_denver1, CPU::generic, UINT32_MAX, Feature::nvidia_denver1},\n    {\"denver2\", CPU::nvidia_denver2, CPU::generic, UINT32_MAX, Feature::nvidia_denver2},\n    {\"carmel\", CPU::nvidia_carmel, CPU::generic, 110000, Feature::nvidia_carmel},\n    {\"xgene1\", CPU::apm_xgene1, CPU::generic, UINT32_MAX, Feature::apm_xgene1},\n    {\"xgene2\", CPU::apm_xgene2, CPU::generic, UINT32_MAX, Feature::apm_xgene2},\n    {\"xgene3\", CPU::apm_xgene3, CPU::generic, UINT32_MAX, Feature::apm_xgene3},\n    {\"kyro\", CPU::qualcomm_kyro, CPU::generic, 0, Feature::qualcomm_kyro},\n    {\"falkor\", CPU::qualcomm_falkor, CPU::generic, 0, Feature::qualcomm_falkor},\n    {\"saphira\", CPU::qualcomm_saphira, CPU::generic, 0, Feature::qualcomm_saphira},\n    {\"exynos-m1\", CPU::samsung_exynos_m1, CPU::generic, UINT32_MAX, Feature::samsung_exynos_m1},\n    {\"exynos-m2\", CPU::samsung_exynos_m2, CPU::generic, UINT32_MAX, Feature::samsung_exynos_m2},\n    {\"exynos-m3\", CPU::samsung_exynos_m3, CPU::generic, 0, Feature::samsung_exynos_m3},\n    {\"exynos-m4\", CPU::samsung_exynos_m4, CPU::generic, 0, Feature::samsung_exynos_m4},\n    {\"exynos-m5\", CPU::samsung_exynos_m5, CPU::samsung_exynos_m4, 110000,\n     Feature::samsung_exynos_m5},\n    {\"apple-a7\", CPU::apple_a7, CPU::generic, 100000, Feature::apple_a7},\n    {\"apple-a8\", CPU::apple_a8, CPU::generic, 100000, Feature::apple_a7},\n    {\"apple-a9\", CPU::apple_a9, CPU::generic, 100000, Feature::apple_a7},\n    {\"apple-a10\", CPU::apple_a10, CPU::generic, 100000, Feature::apple_a10},\n    {\"apple-a11\", CPU::apple_a11, CPU::generic, 100000, Feature::apple_a11},\n    {\"apple-a12\", CPU::apple_a12, CPU::generic, 100000, Feature::apple_a12},\n    {\"apple-a13\", CPU::apple_a13, CPU::generic, 100000, Feature::apple_a13},\n    {\"apple-s4\", CPU::apple_s4, CPU::generic, 100000, Feature::apple_s4},\n    {\"apple-s5\", CPU::apple_s5, CPU::generic, 100000, Feature::apple_s5},\n    {\"thunderx3t110\", CPU::marvell_thunderx3t110, CPU::cavium_thunderx2t99, 110000,\n     Feature::marvell_thunderx3t110},\n};\n#else\nstatic constexpr size_t feature_sz = 3;\nstatic constexpr FeatureName feature_names[] = {\n#define JL_FEATURE_DEF(name, bit, llvmver) {#name, bit, llvmver},\n#define JL_FEATURE_DEF_NAME(name, bit, llvmver, str) {str, bit, llvmver},\n#include \"features_aarch32.h\"\n#undef JL_FEATURE_DEF\n#undef JL_FEATURE_DEF_NAME\n};\nstatic constexpr uint32_t nfeature_names = sizeof(feature_names) / sizeof(FeatureName);\n\ntemplate<typename... Args>\nstatic inline constexpr FeatureList<feature_sz> get_feature_masks(Args... args)\n{\n    return ::get_feature_masks<feature_sz>(args...);\n}\n\n#define JL_FEATURE_DEF_NAME(name, bit, llvmver, str) JL_FEATURE_DEF(name, bit, llvmver)\nstatic constexpr auto feature_masks = get_feature_masks(\n#define JL_FEATURE_DEF(name, bit, llvmver) bit,\n#include \"features_aarch32.h\"\n#undef JL_FEATURE_DEF\n    -1);\nstatic const auto real_feature_masks =\n    feature_masks & FeatureList<feature_sz>{{(uint32_t)-1, (uint32_t)-1, 0}};\n\nnamespace Feature {\nenum : uint32_t {\n#define JL_FEATURE_DEF(name, bit, llvmver) name = bit,\n#include \"features_aarch32.h\"\n#undef JL_FEATURE_DEF\n};\n#undef JL_FEATURE_DEF_NAME\n// This does not cover all dependencies (e.g. the ones that depends on arm versions)\nstatic constexpr FeatureDep deps[] = {\n    {neon, vfp3},\n    {vfp4, vfp3},\n    {crypto, neon},\n};\n\n// These are the real base requirements of the specific architectures\nconstexpr auto _armv7m = get_feature_masks(v7, mclass, hwdiv);\nconstexpr auto _armv7a = get_feature_masks(v7, aclass);\nconstexpr auto _armv7r = get_feature_masks(v7, rclass);\nconstexpr auto _armv8m = get_feature_masks(v7, v8, mclass, hwdiv);\nconstexpr auto _armv8a = get_feature_masks(v7, v8, aclass, neon, vfp3, vfp4, d32,\n                                           hwdiv, hwdiv_arm);\nconstexpr auto _armv8r = get_feature_masks(v7, v8, rclass, neon, vfp3, vfp4, d32,\n                                           hwdiv, hwdiv_arm);\n\n// Set `generic` to match the feature requirement of the `C` code.\n// we'll require at least these when compiling the sysimg.\n#if __ARM_ARCH >= 8\n#  if !defined(__ARM_ARCH_PROFILE)\nconstexpr auto generic = get_feature_masks(v7, v8, hwdiv);\n#  elif __ARM_ARCH_PROFILE == 'A'\nconstexpr auto generic = _armv8a;\n#  elif __ARM_ARCH_PROFILE == 'R'\nconstexpr auto generic = _armv8r;\n#  elif __ARM_ARCH_PROFILE == 'M'\nconstexpr auto generic = _armv8m;\n#  else\nconstexpr auto generic = get_feature_masks(v7, v8, hwdiv);\n#  endif\n#elif __ARM_ARCH == 7\n#  if !defined(__ARM_ARCH_PROFILE)\nconstexpr auto generic = get_feature_masks(v7);\n#  elif __ARM_ARCH_PROFILE == 'A'\nconstexpr auto generic = _armv7a;\n#  elif __ARM_ARCH_PROFILE == 'R'\nconstexpr auto generic = _armv7r;\n#  elif __ARM_ARCH_PROFILE == 'M'\nconstexpr auto generic = _armv7m;\n#  else\nconstexpr auto generic = get_feature_masks(v7);\n#  endif\n#else\nconstexpr auto generic = get_feature_masks();\n#endif\n\n// All feature sets below should use or be or'ed with one of these (or generic).\n// This makes sure that, for example, the `generic` target on `armv7-a` binary is equivalent\n// to the `armv7-a` target.\nconstexpr auto armv7m = generic | _armv7m;\nconstexpr auto armv7a = generic | _armv7a;\nconstexpr auto armv7r = generic | _armv7r;\nconstexpr auto armv8m = generic | _armv8m;\nconstexpr auto armv8a = generic | _armv8a;\nconstexpr auto armv8r = generic | _armv8r;\n\n// armv7l\nconstexpr auto arm_cortex_a5 = armv7a;\nconstexpr auto arm_cortex_a7 = armv7a | get_feature_masks(vfp3, vfp4, neon);\nconstexpr auto arm_cortex_a8 = armv7a | get_feature_masks(d32, vfp3, neon);\nconstexpr auto arm_cortex_a9 = armv7a;\nconstexpr auto arm_cortex_a12 = armv7a | get_feature_masks(d32, vfp3, vfp4, neon);\nconstexpr auto arm_cortex_a15 = armv7a | get_feature_masks(d32, vfp3, vfp4, neon);\nconstexpr auto arm_cortex_a17 = armv7a | get_feature_masks(d32, vfp3, vfp4, neon);\nconstexpr auto arm_cortex_r4 = armv7r | get_feature_masks(vfp3, hwdiv);\nconstexpr auto arm_cortex_r5 = armv7r | get_feature_masks(vfp3, hwdiv, hwdiv_arm);\nconstexpr auto arm_cortex_r7 = armv7r | get_feature_masks(vfp3, hwdiv, hwdiv_arm);\nconstexpr auto arm_cortex_r8 = armv7r | get_feature_masks(vfp3, hwdiv, hwdiv_arm);\nconstexpr auto qualcomm_scorpion = armv7a | get_feature_masks(v7, aclass, vfp3, neon);\nconstexpr auto qualcomm_krait = armv7a | get_feature_masks(vfp3, vfp4, neon, hwdiv, hwdiv_arm);\nconstexpr auto apple_swift = armv7a | get_feature_masks(d32, vfp3, vfp4, neon, hwdiv, hwdiv_arm);\nconstexpr auto marvell_pj4 = armv7a | get_feature_masks(vfp3);\nconstexpr auto intel_3735d = armv7a | get_feature_masks(vfp3, neon);\n// armv8ml\nconstexpr auto arm_cortex_m23 = armv8m; // unsupported\nconstexpr auto arm_cortex_m33 = armv8m | get_feature_masks(v8_m_main); // unsupported\n// armv8l\nconstexpr auto armv8a_crc = armv8a | get_feature_masks(crc);\nconstexpr auto armv8_1a = armv8a_crc | get_feature_masks(v8_1a);\nconstexpr auto armv8_2a = armv8_1a | get_feature_masks(v8_2a);\nconstexpr auto armv8a_crc_crypto = armv8a_crc | get_feature_masks(crypto);\nconstexpr auto armv8_2a_crypto = armv8_2a | get_feature_masks(crypto);\nconstexpr auto armv8_3a = armv8_2a | get_feature_masks(v8_3a);\nconstexpr auto armv8_3a_crypto = armv8_3a | get_feature_masks(crypto);\nconstexpr auto armv8_4a = armv8_3a | get_feature_masks(v8_4a);\nconstexpr auto armv8_4a_crypto = armv8_4a | get_feature_masks(crypto);\nconstexpr auto armv8_5a = armv8_4a | get_feature_masks(v8_5a);\nconstexpr auto armv8_5a_crypto = armv8_5a | get_feature_masks(crypto);\nconstexpr auto armv8_6a = armv8_5a | get_feature_masks(v8_6a);\nconstexpr auto armv8_6a_crypto = armv8_6a | get_feature_masks(crypto);\n\nconstexpr auto arm_cortex_a32 = armv8a_crc;\nconstexpr auto arm_cortex_r52 = armv8a_crc;\nconstexpr auto arm_cortex_a35 = armv8a_crc;\nconstexpr auto arm_cortex_a53 = armv8a_crc;\nconstexpr auto arm_cortex_a55 = armv8_2a;\nconstexpr auto arm_cortex_a57 = armv8a_crc;\nconstexpr auto arm_cortex_a72 = armv8a_crc;\nconstexpr auto arm_cortex_a73 = armv8a_crc;\nconstexpr auto arm_cortex_a75 = armv8_2a;\nconstexpr auto arm_cortex_a76 = armv8_2a;\nconstexpr auto arm_cortex_a77 = armv8_2a;\nconstexpr auto arm_cortex_a78 = armv8_2a;\nconstexpr auto arm_cortex_x1 = armv8_2a;\nconstexpr auto arm_neoverse_n1 = armv8_2a;\nconstexpr auto arm_neoverse_v1 = armv8_4a;\nconstexpr auto arm_neoverse_n2 = armv8_5a;\nconstexpr auto nvidia_denver1 = armv8a; // TODO? (crc, crypto)\nconstexpr auto nvidia_denver2 = armv8a_crc_crypto;\nconstexpr auto apm_xgene1 = armv8a;\nconstexpr auto apm_xgene2 = armv8a; // TODO?\nconstexpr auto apm_xgene3 = armv8a; // TODO?\nconstexpr auto qualcomm_kyro = armv8a_crc_crypto;\nconstexpr auto qualcomm_falkor = armv8a_crc_crypto;\nconstexpr auto qualcomm_saphira = armv8_3a_crypto;\nconstexpr auto samsung_exynos_m1 = armv8a_crc_crypto;\nconstexpr auto samsung_exynos_m2 = armv8a_crc_crypto;\nconstexpr auto samsung_exynos_m3 = armv8a_crc_crypto;\nconstexpr auto samsung_exynos_m4 = armv8_2a_crypto;\nconstexpr auto samsung_exynos_m5 = samsung_exynos_m4;\nconstexpr auto apple_a7 = armv8a_crc_crypto;\n\n}\n\nstatic constexpr CPUSpec<CPU, feature_sz> cpus[] = {\n    {\"generic\", CPU::generic, CPU::generic, 0, Feature::generic},\n    // armv6\n    {\"mpcore\", CPU::arm_mpcore, CPU::generic, 0, Feature::generic},\n    {\"arm1136jf-s\", CPU::arm_1136jf_s, CPU::generic, 0, Feature::generic},\n    {\"arm1156t2f-s\", CPU::arm_1156t2f_s, CPU::generic, 0, Feature::generic},\n    {\"arm1176jzf-s\", CPU::arm_1176jzf_s, CPU::generic, 0, Feature::generic},\n    {\"cortex-m0\", CPU::arm_cortex_m0, CPU::generic, 0, Feature::generic},\n    {\"cortex-m1\", CPU::arm_cortex_m1, CPU::generic, 0, Feature::generic},\n    // armv7ml\n    {\"armv7-m\", CPU::armv7_m, CPU::generic, 0, Feature::armv7m},\n    {\"armv7e-m\", CPU::armv7e_m, CPU::generic, 0, Feature::armv7m},\n    {\"cortex-m3\", CPU::arm_cortex_m3, CPU::generic, 0, Feature::armv7m},\n    {\"cortex-m4\", CPU::arm_cortex_m4, CPU::generic, 0, Feature::armv7m},\n    {\"cortex-m7\", CPU::arm_cortex_m7, CPU::generic, 0, Feature::armv7m},\n    // armv7l\n    {\"armv7-a\", CPU::armv7_a, CPU::generic, 0, Feature::armv7a},\n    {\"armv7-r\", CPU::armv7_r, CPU::generic, 0, Feature::armv7r},\n    {\"cortex-a5\", CPU::arm_cortex_a5, CPU::generic, 0, Feature::arm_cortex_a5},\n    {\"cortex-a7\", CPU::arm_cortex_a7, CPU::generic, 0, Feature::arm_cortex_a7},\n    {\"cortex-a8\", CPU::arm_cortex_a8, CPU::generic, 0, Feature::arm_cortex_a8},\n    {\"cortex-a9\", CPU::arm_cortex_a9, CPU::generic, 0, Feature::arm_cortex_a9},\n    {\"cortex-a12\", CPU::arm_cortex_a12, CPU::generic, 0, Feature::arm_cortex_a12},\n    {\"cortex-a15\", CPU::arm_cortex_a15, CPU::generic, 0, Feature::arm_cortex_a15},\n    {\"cortex-a17\", CPU::arm_cortex_a17, CPU::generic, 0, Feature::arm_cortex_a17},\n    {\"cortex-r4\", CPU::arm_cortex_r4, CPU::generic, 0, Feature::arm_cortex_r4},\n    {\"cortex-r5\", CPU::arm_cortex_r5, CPU::generic, 0, Feature::arm_cortex_r5},\n    {\"cortex-r7\", CPU::arm_cortex_r7, CPU::generic, 0, Feature::arm_cortex_r7},\n    {\"cortex-r8\", CPU::arm_cortex_r8, CPU::generic, 0, Feature::arm_cortex_r8},\n    {\"scorpion\", CPU::qualcomm_scorpion, CPU::armv7_a, UINT32_MAX, Feature::qualcomm_scorpion},\n    {\"krait\", CPU::qualcomm_krait, CPU::generic, 0, Feature::qualcomm_krait},\n    {\"swift\", CPU::apple_swift, CPU::generic, 0, Feature::apple_swift},\n    {\"pj4\", CPU::marvell_pj4, CPU::armv7_a, UINT32_MAX, Feature::marvell_pj4},\n    {\"3735d\", CPU::intel_3735d, CPU::armv7_a, UINT32_MAX, Feature::intel_3735d},\n\n    // armv8ml\n    {\"armv8-m.base\", CPU::armv8_m_base, CPU::generic, 0, Feature::armv8m},\n    {\"armv8-m.main\", CPU::armv8_m_main, CPU::generic, 0, Feature::armv8m},\n    {\"cortex-m23\", CPU::arm_cortex_m23, CPU::armv8_m_base, 0, Feature::arm_cortex_m23},\n    {\"cortex-m33\", CPU::arm_cortex_m33, CPU::armv8_m_main, 0, Feature::arm_cortex_m33},\n\n    // armv8l\n    {\"armv8-a\", CPU::armv8_a, CPU::generic, 0, Feature::armv8a},\n    {\"armv8-r\", CPU::armv8_r, CPU::generic, 0, Feature::armv8r},\n    {\"armv8.1-a\", CPU::armv8_1_a, CPU::generic, 0, Feature::armv8_1a},\n    {\"armv8.2-a\", CPU::armv8_2_a, CPU::generic, 0, Feature::armv8_2a},\n    {\"armv8.3-a\", CPU::armv8_3_a, CPU::generic, 0, Feature::armv8_3a},\n    {\"armv8.4-a\", CPU::armv8_4_a, CPU::generic, 0, Feature::armv8_4a},\n    {\"armv8.5-a\", CPU::armv8_5_a, CPU::generic, 0, Feature::armv8_5a},\n    {\"armv8.6_a\", CPU::armv8_6_a, CPU::generic, 0, Feature::armv8_6a},\n    {\"cortex-a32\", CPU::arm_cortex_a32, CPU::generic, 0, Feature::arm_cortex_a32},\n    {\"cortex-r52\", CPU::arm_cortex_r52, CPU::generic, 0, Feature::arm_cortex_r52},\n    {\"cortex-a35\", CPU::arm_cortex_a35, CPU::generic, 0, Feature::arm_cortex_a35},\n    {\"cortex-a53\", CPU::arm_cortex_a53, CPU::generic, 0, Feature::arm_cortex_a53},\n    {\"cortex-a55\", CPU::arm_cortex_a55, CPU::generic, 0, Feature::arm_cortex_a55},\n    {\"cortex-a57\", CPU::arm_cortex_a57, CPU::generic, 0, Feature::arm_cortex_a57},\n    {\"cortex-a72\", CPU::arm_cortex_a72, CPU::generic, 0, Feature::arm_cortex_a72},\n    {\"cortex-a73\", CPU::arm_cortex_a73, CPU::generic, 0, Feature::arm_cortex_a73},\n    {\"cortex-a75\", CPU::arm_cortex_a75, CPU::generic, 0, Feature::arm_cortex_a75},\n    {\"cortex-a76\", CPU::arm_cortex_a76, CPU::generic, 0, Feature::arm_cortex_a76},\n    {\"cortex-a76ae\", CPU::arm_cortex_a76ae, CPU::generic, 0, Feature::arm_cortex_a76},\n    {\"cortex-a77\", CPU::arm_cortex_a77, CPU::arm_cortex_a76, 110000, Feature::arm_cortex_a77},\n    {\"cortex-a78\", CPU::arm_cortex_a78, CPU::arm_cortex_a77, 110000, Feature::arm_cortex_a78},\n    {\"cortex-x1\", CPU::arm_cortex_x1, CPU::arm_cortex_a78, 110000, Feature::arm_cortex_x1},\n    {\"neoverse-n1\", CPU::arm_neoverse_n1, CPU::arm_cortex_a76, 100000, Feature::arm_neoverse_n1},\n    {\"neoverse-v1\", CPU::arm_neoverse_v1, CPU::arm_neoverse_n1, UINT32_MAX, Feature::arm_neoverse_v1},\n    {\"neoverse-n2\", CPU::arm_neoverse_n2, CPU::arm_neoverse_n1, UINT32_MAX, Feature::arm_neoverse_n2},\n    {\"denver1\", CPU::nvidia_denver1, CPU::arm_cortex_a53, UINT32_MAX, Feature::nvidia_denver1},\n    {\"denver2\", CPU::nvidia_denver2, CPU::arm_cortex_a57, UINT32_MAX, Feature::nvidia_denver2},\n    {\"xgene1\", CPU::apm_xgene1, CPU::armv8_a, UINT32_MAX, Feature::apm_xgene1},\n    {\"xgene2\", CPU::apm_xgene2, CPU::armv8_a, UINT32_MAX, Feature::apm_xgene2},\n    {\"xgene3\", CPU::apm_xgene3, CPU::armv8_a, UINT32_MAX, Feature::apm_xgene3},\n    {\"kyro\", CPU::qualcomm_kyro, CPU::armv8_a, UINT32_MAX, Feature::qualcomm_kyro},\n    {\"falkor\", CPU::qualcomm_falkor, CPU::armv8_a, UINT32_MAX, Feature::qualcomm_falkor},\n    {\"saphira\", CPU::qualcomm_saphira, CPU::armv8_a, UINT32_MAX, Feature::qualcomm_saphira},\n    {\"exynos-m1\", CPU::samsung_exynos_m1, CPU::generic, UINT32_MAX, Feature::samsung_exynos_m1},\n    {\"exynos-m2\", CPU::samsung_exynos_m2, CPU::generic, UINT32_MAX, Feature::samsung_exynos_m2},\n    {\"exynos-m3\", CPU::samsung_exynos_m3, CPU::generic, 0, Feature::samsung_exynos_m3},\n    {\"exynos-m4\", CPU::samsung_exynos_m4, CPU::generic, 0, Feature::samsung_exynos_m4},\n    {\"exynos-m5\", CPU::samsung_exynos_m5, CPU::samsung_exynos_m4, 110000,\n     Feature::samsung_exynos_m5},\n    {\"apple-a7\", CPU::apple_a7, CPU::generic, 0, Feature::apple_a7},\n};\n#endif\nstatic constexpr size_t ncpu_names = sizeof(cpus) / sizeof(cpus[0]);\n\n// auxval reader\n\n#ifndef AT_HWCAP\n#  define AT_HWCAP 16\n#endif\n#ifndef AT_HWCAP2\n#  define AT_HWCAP2 26\n#endif\n\n#if defined(USE_DYN_GETAUXVAL)\nstatic unsigned long getauxval_procfs(unsigned long type)\n{\n    int fd = open(\"/proc/self/auxv\", O_RDONLY);\n    if (fd == -1)\n        return 0;\n    unsigned long val = 0;\n    unsigned long buff[2];\n    while (read(fd, buff, sizeof(buff)) == sizeof(buff)) {\n        if (buff[0] == 0)\n            break;\n        if (buff[0] == type) {\n            val = buff[1];\n            break;\n        }\n    }\n    close(fd);\n    return val;\n}\n\nstatic inline unsigned long jl_getauxval(unsigned long type)\n{\n    // First, try resolving getauxval in libc\n    auto libc = jl_dlopen(nullptr, JL_RTLD_LOCAL);\n    static unsigned long (*getauxval_p)(unsigned long) = NULL;\n    if (getauxval_p == NULL && jl_dlsym(libc, \"getauxval\", (void **)&getauxval_p, 0)) {\n        return getauxval_p(type);\n    }\n\n    // If we couldn't resolve it, use procfs.\n    return getauxval_procfs(type);\n}\n#else\nstatic inline unsigned long jl_getauxval(unsigned long type)\n{\n    return getauxval(type);\n}\n#endif\n\nstruct CPUID {\n    uint8_t implementer;\n    uint8_t variant;\n    uint16_t part;\n    bool operator<(const CPUID &right) const\n    {\n        if (implementer < right.implementer)\n            return true;\n        if (implementer > right.implementer)\n            return false;\n        if (part < right.part)\n            return true;\n        if (part > right.part)\n            return false;\n        return variant < right.variant;\n    }\n};\n\n// /sys/devices/system/cpu/cpu<n>/regs/identification/midr_el1 reader\nstatic inline void get_cpuinfo_sysfs(std::set<CPUID> &res)\n{\n    // This only works on a 64bit 4.7+ kernel\n    auto dir = opendir(\"/sys/devices/system/cpu\");\n    if (!dir)\n        return;\n    while (auto entry = readdir(dir)) {\n        if (entry->d_type != DT_DIR)\n            continue;\n        if (strncmp(entry->d_name, \"cpu\", 3) != 0)\n            continue;\n        std::string stm;\n        llvm::raw_string_ostream(stm) << \"/sys/devices/system/cpu/\" << entry->d_name << \"/regs/identification/midr_el1\";\n        std::ifstream file(stm);\n        if (!file)\n            continue;\n        uint64_t val = 0;\n        file >> std::hex >> val;\n        if (!file)\n            continue;\n        CPUID cpuid = {\n            uint8_t(val >> 24),\n            uint8_t((val >> 20) & 0xf),\n            uint16_t((val >> 4) & 0xfff)\n        };\n        res.insert(cpuid);\n    }\n    closedir(dir);\n}\n\n// Use an external template since lambda's can't be templated in C++11\ntemplate<typename T, typename F>\nstatic inline bool try_read_procfs_line(llvm::StringRef line, const char *prefix, T &out,\n                                        bool &flag, F &&reset)\n{\n    if (!line.startswith(prefix))\n        return false;\n    if (flag)\n        reset();\n    flag = line.substr(strlen(prefix)).ltrim(\"\\t :\").getAsInteger(0, out);\n    return true;\n}\n\n// /proc/cpuinfo reader\nstatic inline void get_cpuinfo_procfs(std::set<CPUID> &res)\n{\n    std::ifstream file(\"/proc/cpuinfo\");\n    CPUID cpuid = {0, 0, 0};\n    bool impl = false;\n    bool part = false;\n    bool var = false;\n    auto reset = [&] () {\n        if (impl && part)\n            res.insert(cpuid);\n        impl = false;\n        part = false;\n        var = false;\n        memset(&cpuid, 0, sizeof(cpuid));\n    };\n    for (std::string line; std::getline(file, line);) {\n        if (line.empty()) {\n            reset();\n            continue;\n        }\n        try_read_procfs_line(line, \"CPU implementer\", cpuid.implementer, impl, reset) ||\n            try_read_procfs_line(line, \"CPU variant\", cpuid.variant, var, reset) ||\n            try_read_procfs_line(line, \"CPU part\", cpuid.part, part, reset);\n    }\n    reset();\n}\n\nstatic std::set<CPUID> get_cpuinfo(void)\n{\n    std::set<CPUID> res;\n    get_cpuinfo_sysfs(res);\n    if (res.empty())\n        get_cpuinfo_procfs(res);\n    return res;\n}\n\nstatic CPU get_cpu_name(CPUID cpuid)\n{\n    switch (cpuid.implementer) {\n    case 0x41: // 'A': ARM\n        switch (cpuid.part) {\n        case 0xb02: return CPU::arm_mpcore;\n        case 0xb36: return CPU::arm_1136jf_s;\n        case 0xb56: return CPU::arm_1156t2f_s;\n        case 0xb76: return CPU::arm_1176jzf_s;\n        case 0xc05: return CPU::arm_cortex_a5;\n        case 0xc07: return CPU::arm_cortex_a7;\n        case 0xc08: return CPU::arm_cortex_a8;\n        case 0xc09: return CPU::arm_cortex_a9;\n        case 0xc0d: return CPU::arm_cortex_a12;\n        case 0xc0f: return CPU::arm_cortex_a15;\n        case 0xc0e: return CPU::arm_cortex_a17;\n        case 0xc14: return CPU::arm_cortex_r4;\n        case 0xc15: return CPU::arm_cortex_r5;\n        case 0xc17: return CPU::arm_cortex_r7;\n        case 0xc18: return CPU::arm_cortex_r8;\n        case 0xc20: return CPU::arm_cortex_m0;\n        case 0xc21: return CPU::arm_cortex_m1;\n        case 0xc23: return CPU::arm_cortex_m3;\n        case 0xc24: return CPU::arm_cortex_m4;\n        case 0xc27: return CPU::arm_cortex_m7;\n        case 0xd01: return CPU::arm_cortex_a32;\n        case 0xd02: return CPU::arm_cortex_a34;\n        case 0xd03: return CPU::arm_cortex_a53;\n        case 0xd04: return CPU::arm_cortex_a35;\n        case 0xd05: return CPU::arm_cortex_a55;\n        case 0xd06: return CPU::arm_cortex_a65;\n        case 0xd07: return CPU::arm_cortex_a57;\n        case 0xd08: return CPU::arm_cortex_a72;\n        case 0xd09: return CPU::arm_cortex_a73;\n        case 0xd0a: return CPU::arm_cortex_a75;\n        case 0xd0b: return CPU::arm_cortex_a76;\n        case 0xd0c: return CPU::arm_neoverse_n1;\n        case 0xd0d: return CPU::arm_cortex_a77;\n        case 0xd0e: return CPU::arm_cortex_a76ae;\n        case 0xd13: return CPU::arm_cortex_r52;\n        case 0xd20: return CPU::arm_cortex_m23;\n        case 0xd21: return CPU::arm_cortex_m33;\n            // case 0xd22: return CPU::arm_cortex_m55;\n        case 0xd40: return CPU::arm_neoverse_v1;\n        case 0xd41: return CPU::arm_cortex_a78;\n        case 0xd43: return CPU::arm_cortex_a65ae;\n        case 0xd44: return CPU::arm_cortex_x1;\n        case 0xd49: return CPU::arm_neoverse_n2;\n        case 0xd4a: return CPU::arm_neoverse_e1;\n        default: return CPU::generic;\n        }\n    case 0x42: // 'B': Broadcom (Cavium)\n        switch (cpuid.part) {\n            // case 0x00f: return CPU::broadcom_brahma_b15;\n            // case 0x100: return CPU::broadcom_brahma_b53;\n        case 0x516: return CPU::cavium_thunderx2t99p1;\n        default: return CPU::generic;\n        }\n    case 0x43: // 'C': Cavium\n        switch (cpuid.part) {\n        case 0xa0: return CPU::cavium_thunderx;\n        case 0xa1:\n            if (cpuid.variant == 0)\n                return CPU::cavium_thunderx88p1;\n            return CPU::cavium_thunderx88;\n        case 0xa2: return CPU::cavium_thunderx81;\n        case 0xa3: return CPU::cavium_thunderx83;\n        case 0xaf: return CPU::cavium_thunderx2t99;\n        case 0xb0: return CPU::cavium_octeontx2;\n        case 0xb1: return CPU::cavium_octeontx2t98;\n        case 0xb2: return CPU::cavium_octeontx2t96;\n        case 0xb3: return CPU::cavium_octeontx2f95;\n        case 0xb4: return CPU::cavium_octeontx2f95n;\n        case 0xb5: return CPU::cavium_octeontx2f95mm;\n        case 0xb8: return CPU::marvell_thunderx3t110;\n        default: return CPU::generic;\n        }\n    case 0x46: // 'F': Fujitsu\n        switch (cpuid.part) {\n        case 0x1: return CPU::fujitsu_a64fx;\n        default: return CPU::generic;\n        }\n    case 0x48: // 'H': HiSilicon\n        switch (cpuid.part) {\n        case 0xd01: return CPU::hisilicon_tsv110;\n        case 0xd40: return CPU::arm_cortex_a76; // Kirin 980\n        default: return CPU::generic;\n        }\n    case 0x4e: // 'N': NVIDIA\n        switch (cpuid.part) {\n        case 0x000: return CPU::nvidia_denver1;\n        case 0x003: return CPU::nvidia_denver2;\n        case 0x004: return CPU::nvidia_carmel;\n        default: return CPU::generic;\n        }\n    case 0x50: // 'P': AppliedMicro\n        // x-gene 2\n        // x-gene 3\n        switch (cpuid.part) {\n        case 0x000: return CPU::apm_xgene1;\n        default: return CPU::generic;\n        }\n    case 0x51: // 'Q': Qualcomm\n        switch (cpuid.part) {\n        case 0x00f:\n        case 0x02d:\n            return CPU::qualcomm_scorpion;\n        case 0x04d:\n        case 0x06f:\n            return CPU::qualcomm_krait;\n        case 0x201: // silver\n        case 0x205: // gold\n        case 0x211: // silver\n            return CPU::qualcomm_kyro;\n            // kryo 2xx\n        case 0x800: // gold\n            return CPU::arm_cortex_a73;\n        case 0x801: // silver\n            return CPU::arm_cortex_a53;\n            // kryo 3xx\n        case 0x802: // gold\n            return CPU::arm_cortex_a75;\n        case 0x803: // silver\n            return CPU::arm_cortex_a55;\n            // kryo 4xx\n        case 0x804: // gold\n            return CPU::arm_cortex_a76;\n        case 0x805: // silver\n            return CPU::arm_cortex_a55;\n            // kryo 5xx seems to be using ID for cortex-a77 directly\n        case 0xc00:\n            return CPU::qualcomm_falkor;\n        case 0xc01:\n            return CPU::qualcomm_saphira;\n        default: return CPU::generic;\n        }\n    case 0x53: // 'S': Samsung\n        if (cpuid.part == 1) {\n            if (cpuid.variant == 4)\n                return CPU::samsung_exynos_m2;\n            return CPU::samsung_exynos_m1;\n        }\n        if (cpuid.variant != 1)\n            return CPU::generic;\n        switch (cpuid.part) {\n        case 0x2: return CPU::samsung_exynos_m3;\n        case 0x3: return CPU::samsung_exynos_m4;\n        case 0x4: return CPU::samsung_exynos_m5;\n        default: return CPU::generic;\n        }\n    case 0x56: // 'V': Marvell\n        switch (cpuid.part) {\n        case 0x581:\n        case 0x584:\n            return CPU::marvell_pj4;\n        default: return CPU::generic;\n        }\n    case 0x61: // 'a': Apple\n        // https://opensource.apple.com/source/xnu/xnu-6153.81.5/osfmk/arm/cpuid.h.auto.html\n        switch (cpuid.part) {\n        case 0x0: // Swift\n            return CPU::apple_swift;\n        case 0x1: // Cyclone\n            return CPU::apple_a7;\n        case 0x2: // Typhoon\n        case 0x3: // Typhoo/Capri\n            return CPU::apple_a8;\n        case 0x4: // Twister\n        case 0x5: // Twister/Elba/Malta\n            return CPU::apple_a9;\n        case 0x6: // Hurricane\n        case 0x7: // Hurricane/Myst\n            return CPU::apple_a10;\n        case 0x8: // Monsoon\n        case 0x9: // Mistral\n            return CPU::apple_a11;\n        case 0xB: // Vortex\n        case 0xC: // Tempest\n        case 0x10: // A12X, Vortex Aruba\n        case 0x11: // A12X, Tempest Aruba\n            return CPU::apple_a12;\n        case 0xF: // Tempest M9\n            return CPU::apple_s4;\n        case 0x12: // Lightning\n        case 0x13: // Thunder\n            return CPU::apple_a13;\n        default: return CPU::generic;\n        }\n    case 0x68: // 'h': Huaxintong Semiconductor\n        switch (cpuid.part) {\n        case 0x0: return CPU::hxt_phecda;\n        default: return CPU::generic;\n        }\n    case 0x69: // 'i': Intel\n        switch (cpuid.part) {\n        case 0x001: return CPU::intel_3735d;\n        default: return CPU::generic;\n        }\n    default:\n        return CPU::generic;\n    }\n}\n\nnamespace {\n\nstruct arm_arch {\n    int version;\n    char klass;\n    constexpr bool mclass() const { return klass == 'M'; }\n};\n\n}\n\nstatic arm_arch get_elf_arch(void)\n{\n#ifdef _CPU_AARCH64_\n    return {8, 'A'};\n#else\n    int ver = 0;\n    char profile = 0;\n    struct utsname name;\n    if (uname(&name) >= 0) {\n        // name.machine is the elf_platform in the kernel.\n        if (strcmp(name.machine, \"armv6l\") == 0) {\n            ver = 6;\n        }\n        else if (strcmp(name.machine, \"armv7l\") == 0) {\n            ver = 7;\n        }\n        else if (strcmp(name.machine, \"armv7ml\") == 0) {\n            ver = 7;\n            profile = 'M';\n        }\n        else if (strcmp(name.machine, \"armv8l\") == 0 || strcmp(name.machine, \"aarch64\") == 0) {\n            ver = 8;\n        }\n    }\n    if (__ARM_ARCH > ver)\n        ver = __ARM_ARCH;\n#  if __ARM_ARCH > 6 && defined(__ARM_ARCH_PROFILE)\n    profile = __ARM_ARCH_PROFILE;\n#  endif\n    return {ver, profile};\n#endif\n}\n\nstatic inline const CPUSpec<CPU,feature_sz> *find_cpu(uint32_t cpu)\n{\n    return ::find_cpu(cpu, cpus, ncpu_names);\n}\n\nstatic inline const CPUSpec<CPU,feature_sz> *find_cpu(llvm::StringRef name)\n{\n    return ::find_cpu(name, cpus, ncpu_names);\n}\n\nstatic inline const char *find_cpu_name(uint32_t cpu)\n{\n    return ::find_cpu_name(cpu, cpus, ncpu_names);\n}\n\nstatic arm_arch feature_arch_version(const FeatureList<feature_sz> &feature)\n{\n#ifdef _CPU_AARCH64_\n    return {8, 'A'};\n#else\n    int ver;\n    if (test_nbit(feature, Feature::v8)) {\n        ver = 8;\n    }\n    else if (test_nbit(feature, Feature::v7)) {\n        ver = 7;\n    }\n    else {\n        return {6, 0};\n    }\n    if (test_nbit(feature, Feature::mclass)) {\n        return {ver, 'M'};\n    }\n    else if (test_nbit(feature, Feature::rclass)) {\n        return {ver, 'R'};\n    }\n    else if (test_nbit(feature, Feature::aclass)) {\n        return {ver, 'A'};\n    }\n    return {ver, 0};\n#endif\n}\n\nstatic CPU generic_for_arch(arm_arch arch)\n{\n#ifdef _CPU_AARCH64_\n    return CPU::generic;\n#else\n#  if defined(__ARM_ARCH_PROFILE)\n    char klass = __ARM_ARCH_PROFILE;\n#  else\n    char klass = arch.klass;\n#  endif\n    if (arch.version >= 8) {\n        if (klass == 'M') {\n            return CPU::armv8_m_base;\n        }\n        else if (klass == 'R') {\n            return CPU::armv8_r;\n        }\n        else {\n            return CPU::armv8_a;\n        }\n    }\n    else if (arch.version == 7) {\n        if (klass == 'M') {\n            return CPU::armv7_m;\n        }\n        else if (klass == 'R') {\n            return CPU::armv7_r;\n        }\n        else {\n            return CPU::armv7_a;\n        }\n    }\n    return CPU::generic;\n#endif\n}\n\nstatic bool check_cpu_arch_ver(uint32_t cpu, arm_arch arch)\n{\n    auto spec = find_cpu(cpu);\n    // This happens on AArch64 and indicates that the cpu name isn't a valid aarch64 CPU\n    if (!spec)\n        return false;\n    auto feature_arch = feature_arch_version(spec->features);\n    if (arch.mclass() != feature_arch.mclass())\n        return false;\n    if (arch.version > feature_arch.version)\n        return false;\n    return true;\n}\n\nstatic void shrink_big_little(std::vector<std::pair<uint32_t,CPUID>> &list,\n                              const CPU *cpus, uint32_t ncpu)\n{\n    auto find = [&] (uint32_t name) {\n        for (uint32_t i = 0; i < ncpu; i++) {\n            if (cpus[i] == CPU(name)) {\n                return (int)i;\n            }\n        }\n        return -1;\n    };\n    int maxidx = -1;\n    for (auto &ele: list) {\n        int idx = find(ele.first);\n        if (idx > maxidx) {\n            maxidx = idx;\n        }\n    }\n    if (maxidx >= 0) {\n        list.erase(std::remove_if(list.begin(), list.end(), [&] (std::pair<uint32_t,CPUID> &ele) {\n                    int idx = find(ele.first);\n                    return idx != -1 && idx < maxidx;\n                }), list.end());\n    }\n}\n\nstatic NOINLINE std::pair<uint32_t,FeatureList<feature_sz>> _get_host_cpu()\n{\n    FeatureList<feature_sz> features = {};\n    // Here we assume that only the lower 32bit are used on aarch64\n    // Change the cast here when that's not the case anymore (and when there's features in the\n    // high bits that we want to detect).\n    features[0] = (uint32_t)jl_getauxval(AT_HWCAP);\n    features[1] = (uint32_t)jl_getauxval(AT_HWCAP2);\n#ifdef _CPU_AARCH64_\n    if (test_nbit(features, 31)) // HWCAP_PACG\n        set_bit(features, Feature::pa, true);\n#endif\n    auto cpuinfo = get_cpuinfo();\n    auto arch = get_elf_arch();\n#ifdef _CPU_ARM_\n    if (arch.version >= 7) {\n        if (arch.klass == 'M') {\n            set_bit(features, Feature::mclass, true);\n        }\n        else if (arch.klass == 'R') {\n            set_bit(features, Feature::rclass, true);\n        }\n        else if (arch.klass == 'A') {\n            set_bit(features, Feature::aclass, true);\n        }\n    }\n    switch (arch.version) {\n    case 8:\n        set_bit(features, Feature::v8, true);\n        JL_FALLTHROUGH;\n    case 7:\n        set_bit(features, Feature::v7, true);\n        break;\n    default:\n        break;\n    }\n#endif\n\n    std::set<uint32_t> cpus;\n    std::vector<std::pair<uint32_t,CPUID>> list;\n    // Ideally the feature detection above should be enough.\n    // However depending on the kernel version not all features are available\n    // and it's also impossible to detect the ISA version which contains\n    // some features not yet exposed by the kernel.\n    // We therefore try to get a more complete feature list from the CPU name.\n    // Since it is possible to pair cores that have different feature set\n    // (Observed for exynos 9810 with exynos-m3 + cortex-a55) we'll compute\n    // an intersection of the known features from each core.\n    // If there's a core that we don't recognize, treat it as generic.\n    bool extra_initialized = false;\n    FeatureList<feature_sz> extra_features = {};\n    for (auto info: cpuinfo) {\n        auto name = (uint32_t)get_cpu_name(info);\n        if (name == 0) {\n            // no need to clear the feature set if it wasn't initialized\n            if (extra_initialized)\n                extra_features = FeatureList<feature_sz>{};\n            extra_initialized = true;\n            continue;\n        }\n        if (!check_cpu_arch_ver(name, arch))\n            continue;\n        if (cpus.insert(name).second) {\n            if (extra_initialized) {\n                extra_features = extra_features & find_cpu(name)->features;\n            }\n            else {\n                extra_initialized = true;\n                extra_features = find_cpu(name)->features;\n            }\n            list.emplace_back(name, info);\n        }\n    }\n    features = features | extra_features;\n\n    // Not all elements/pairs are valid\n    static constexpr CPU v8order[] = {\n        CPU::arm_cortex_a35,\n        CPU::arm_cortex_a53,\n        CPU::arm_cortex_a55,\n        CPU::arm_cortex_a57,\n        CPU::arm_cortex_a72,\n        CPU::arm_cortex_a73,\n        CPU::arm_cortex_a75,\n        CPU::arm_cortex_a76,\n        CPU::arm_neoverse_n1,\n        CPU::arm_neoverse_n2,\n        CPU::arm_neoverse_v1,\n        CPU::nvidia_denver2,\n        CPU::nvidia_carmel,\n        CPU::samsung_exynos_m1,\n        CPU::samsung_exynos_m2,\n        CPU::samsung_exynos_m3,\n        CPU::samsung_exynos_m4,\n        CPU::samsung_exynos_m5,\n    };\n    shrink_big_little(list, v8order, sizeof(v8order) / sizeof(CPU));\n#ifdef _CPU_ARM_\n    // Not all elements/pairs are valid\n    static constexpr CPU v7order[] = {\n        CPU::arm_cortex_a5,\n        CPU::arm_cortex_a7,\n        CPU::arm_cortex_a8,\n        CPU::arm_cortex_a9,\n        CPU::arm_cortex_a12,\n        CPU::arm_cortex_a15,\n        CPU::arm_cortex_a17\n    };\n    shrink_big_little(list, v7order, sizeof(v7order) / sizeof(CPU));\n#endif\n    uint32_t cpu = 0;\n    if (list.empty()) {\n        cpu = (uint32_t)generic_for_arch(arch);\n    }\n    else {\n        // This also covers `list.size() > 1` case which means there's a unknown combination\n        // consists of CPU's we know. Unclear what else we could try so just randomly return\n        // one...\n        cpu = list[0].first;\n    }\n    // Ignore feature bits that we are not interested in.\n    mask_features(feature_masks, &features[0]);\n\n    return std::make_pair(cpu, features);\n}\n\nstatic inline const std::pair<uint32_t,FeatureList<feature_sz>> &get_host_cpu()\n{\n    static auto host_cpu = _get_host_cpu();\n    return host_cpu;\n}\n\nstatic bool is_generic_cpu_name(uint32_t cpu)\n{\n    switch ((CPU)cpu) {\n    case CPU::generic:\n    case CPU::armv7_a:\n    case CPU::armv7_m:\n    case CPU::armv7e_m:\n    case CPU::armv7_r:\n    case CPU::armv8_a:\n    case CPU::armv8_m_base:\n    case CPU::armv8_m_main:\n    case CPU::armv8_r:\n    case CPU::armv8_1_a:\n    case CPU::armv8_2_a:\n    case CPU::armv8_3_a:\n    case CPU::armv8_4_a:\n    case CPU::armv8_5_a:\n    case CPU::armv8_6_a:\n        return true;\n    default:\n        return false;\n    }\n}\n\nstatic inline const std::string &host_cpu_name()\n{\n    static std::string name = [] {\n        if (is_generic_cpu_name(get_host_cpu().first)) {\n            auto llvm_name = jl_get_cpu_name_llvm();\n            if (llvm_name != \"generic\") {\n                return llvm_name;\n            }\n        }\n        return std::string(find_cpu_name(get_host_cpu().first));\n    }();\n    return name;\n}\n\nstatic inline const char *normalize_cpu_name(llvm::StringRef name)\n{\n    if (name == \"ares\")\n        return \"neoverse-n1\";\n    if (name == \"zeus\")\n        return \"neoverse-v1\";\n    if (name == \"cyclone\")\n        return \"apple-a7\";\n    if (name == \"typhoon\")\n        return \"apple-a8\";\n    if (name == \"twister\")\n        return \"apple-a9\";\n    if (name == \"hurricane\")\n        return \"apple-a10\";\n    return nullptr;\n}\n\ntemplate<size_t n>\nstatic inline void enable_depends(FeatureList<n> &features)\n{\n    if (test_nbit(features, Feature::v8_6a))\n        set_bit(features, Feature::v8_5a, true);\n    if (test_nbit(features, Feature::v8_5a))\n        set_bit(features, Feature::v8_4a, true);\n    if (test_nbit(features, Feature::v8_4a))\n        set_bit(features, Feature::v8_3a, true);\n    if (test_nbit(features, Feature::v8_3a))\n        set_bit(features, Feature::v8_2a, true);\n    if (test_nbit(features, Feature::v8_2a))\n        set_bit(features, Feature::v8_1a, true);\n    if (test_nbit(features, Feature::v8_1a))\n        set_bit(features, Feature::crc, true);\n#ifdef _CPU_ARM_\n    if (test_nbit(features, Feature::v8_1a)) {\n        set_bit(features, Feature::v8, true);\n        set_bit(features, Feature::aclass, true);\n    }\n    if (test_nbit(features, Feature::v8_m_main)) {\n        set_bit(features, Feature::v8, true);\n        set_bit(features, Feature::mclass, true);\n    }\n    if (test_nbit(features, Feature::v8)) {\n        set_bit(features, Feature::v7, true);\n        if (test_nbit(features, Feature::aclass)) {\n            set_bit(features, Feature::neon, true);\n            set_bit(features, Feature::vfp3, true);\n            set_bit(features, Feature::vfp4, true);\n            set_bit(features, Feature::hwdiv_arm, true);\n            set_bit(features, Feature::hwdiv, true);\n            set_bit(features, Feature::d32, true);\n        }\n    }\n#else\n    if (test_nbit(features, Feature::v8_1a)) {\n        set_bit(features, Feature::lse, true);\n        set_bit(features, Feature::rdm, true);\n    }\n    if (test_nbit(features, Feature::v8_2a)) {\n        set_bit(features, Feature::ccpp, true);\n    }\n    if (test_nbit(features, Feature::v8_3a)) {\n        set_bit(features, Feature::jsconv, true);\n        set_bit(features, Feature::complxnum, true);\n        set_bit(features, Feature::rcpc, true);\n    }\n    if (test_nbit(features, Feature::v8_4a)) {\n        set_bit(features, Feature::dit, true);\n        set_bit(features, Feature::rcpc_immo, true);\n        set_bit(features, Feature::fmi, true);\n    }\n    if (test_nbit(features, Feature::v8_5a)) {\n        set_bit(features, Feature::sb, true);\n        set_bit(features, Feature::ccdp, true);\n        set_bit(features, Feature::altnzcv, true);\n        set_bit(features, Feature::fptoint, true);\n    }\n    if (test_nbit(features, Feature::v8_6a)) {\n        set_bit(features, Feature::i8mm, true);\n        set_bit(features, Feature::bf16, true);\n    }\n#endif\n    ::enable_depends(features, Feature::deps, sizeof(Feature::deps) / sizeof(FeatureDep));\n}\n\ntemplate<size_t n>\nstatic inline void disable_depends(FeatureList<n> &features)\n{\n    ::disable_depends(features, Feature::deps, sizeof(Feature::deps) / sizeof(FeatureDep));\n}\n\nstatic const std::vector<TargetData<feature_sz>> &get_cmdline_targets(void)\n{\n    auto feature_cb = [] (const char *str, size_t len, FeatureList<feature_sz> &list) {\n#ifdef _CPU_AARCH64_\n        // On AArch64, treat `crypto` as an alias of aes + sha2 just like LLVM\n        if (llvm::StringRef(str, len) == \"crypto\") {\n            set_bit(list, Feature::aes, true);\n            set_bit(list, Feature::sha2, true);\n            return true;\n        }\n#endif\n        auto fbit = find_feature_bit(feature_names, nfeature_names, str, len);\n        if (fbit == (uint32_t)-1)\n            return false;\n        set_bit(list, fbit, true);\n        return true;\n    };\n    auto &targets = ::get_cmdline_targets<feature_sz>(feature_cb);\n    for (auto &t: targets) {\n        if (auto nname = normalize_cpu_name(t.name)) {\n            t.name = nname;\n        }\n    }\n    return targets;\n}\n\nstatic std::vector<TargetData<feature_sz>> jit_targets;\n\nstatic TargetData<feature_sz> arg_target_data(const TargetData<feature_sz> &arg, bool require_host)\n{\n    TargetData<feature_sz> res = arg;\n    const FeatureList<feature_sz> *cpu_features = nullptr;\n    if (res.name == \"native\") {\n        res.name = host_cpu_name();\n        cpu_features = &get_host_cpu().second;\n    }\n    else if (auto spec = find_cpu(res.name)) {\n        cpu_features = &spec->features;\n    }\n    else {\n        res.en.flags |= JL_TARGET_UNKNOWN_NAME;\n    }\n    if (cpu_features) {\n        for (size_t i = 0; i < feature_sz; i++) {\n            res.en.features[i] |= (*cpu_features)[i];\n        }\n    }\n    enable_depends(res.en.features);\n    for (size_t i = 0; i < feature_sz; i++)\n        res.en.features[i] &= ~res.dis.features[i];\n    if (require_host) {\n        for (size_t i = 0; i < feature_sz; i++) {\n            res.en.features[i] &= get_host_cpu().second[i];\n        }\n    }\n    disable_depends(res.en.features);\n    if (cpu_features) {\n        // If the base feature if known, fill in the disable features\n        for (size_t i = 0; i < feature_sz; i++) {\n            res.dis.features[i] = feature_masks[i] & ~res.en.features[i];\n        }\n    }\n    return res;\n}\n\nstatic int max_vector_size(const FeatureList<feature_sz> &features)\n{\n#ifdef _CPU_ARM_\n    if (test_nbit(features, Feature::neon))\n        return 16;\n    return 8;\n#else\n    if (test_nbit(features, Feature::sve2))\n        return 256;\n    if (test_nbit(features, Feature::sve))\n        return 128;\n    return 16;\n#endif\n}\n\nstatic uint32_t sysimg_init_cb(const void *id)\n{\n    // First see what target is requested for the JIT.\n    auto &cmdline = get_cmdline_targets();\n    TargetData<feature_sz> target = arg_target_data(cmdline[0], true);\n    // Then find the best match in the sysimg\n    auto sysimg = deserialize_target_data<feature_sz>((const uint8_t*)id);\n    for (auto &t: sysimg) {\n        if (auto nname = normalize_cpu_name(t.name)) {\n            t.name = nname;\n        }\n    }\n    auto match = match_sysimg_targets(sysimg, target, max_vector_size);\n    // Now we've decided on which sysimg version to use.\n    // Make sure the JIT target is compatible with it and save the JIT target.\n    if (match.vreg_size != max_vector_size(target.en.features) &&\n        (sysimg[match.best_idx].en.flags & JL_TARGET_VEC_CALL)) {\n#ifdef _CPU_ARM_\n        unset_bits(target.en.features, Feature::neon);\n#endif\n    }\n    jit_targets.push_back(std::move(target));\n    return match.best_idx;\n}\n\nstatic void ensure_jit_target(bool imaging)\n{\n    auto &cmdline = get_cmdline_targets();\n    check_cmdline(cmdline, imaging);\n    if (!jit_targets.empty())\n        return;\n    for (auto &arg: cmdline) {\n        auto data = arg_target_data(arg, jit_targets.empty());\n        jit_targets.push_back(std::move(data));\n    }\n    auto ntargets = jit_targets.size();\n    // Now decide the clone condition.\n    for (size_t i = 1; i < ntargets; i++) {\n        auto &t = jit_targets[i];\n        if (t.en.flags & JL_TARGET_CLONE_ALL)\n            continue;\n        // The most useful one in general...\n        t.en.flags |= JL_TARGET_CLONE_LOOP;\n#ifdef _CPU_ARM_\n        auto &features0 = jit_targets[t.base].en.features;\n        static constexpr uint32_t clone_math[] = {Feature::vfp3, Feature::vfp4, Feature::neon};\n        for (auto fe: clone_math) {\n            if (!test_nbit(features0, fe) && test_nbit(t.en.features, fe)) {\n                t.en.flags |= JL_TARGET_CLONE_MATH;\n                break;\n            }\n        }\n        static constexpr uint32_t clone_simd[] = {Feature::neon};\n        for (auto fe: clone_simd) {\n            if (!test_nbit(features0, fe) && test_nbit(t.en.features, fe)) {\n                t.en.flags |= JL_TARGET_CLONE_SIMD;\n                break;\n            }\n        }\n#endif\n    }\n}\n\nstatic std::pair<std::string,std::vector<std::string>>\nget_llvm_target_noext(const TargetData<feature_sz> &data)\n{\n    std::string name = data.name;\n    auto *spec = find_cpu(name);\n    while (spec) {\n        if (spec->llvmver <= JL_LLVM_VERSION)\n            break;\n        spec = find_cpu((uint32_t)spec->fallback);\n        name = spec->name;\n    }\n    auto features = data.en.features;\n    if (spec) {\n        if (is_generic_cpu_name((uint32_t)spec->cpu)) {\n            features = features | spec->features;\n            name = \"generic\";\n        }\n    }\n#ifdef _CPU_ARM_\n    // We use the name on aarch64 internally but the LLVM ARM backend still use the old name...\n    if (name == \"apple-a7\")\n        name = \"cyclone\";\n#endif\n    std::vector<std::string> feature_strs;\n    for (auto &fename: feature_names) {\n        if (fename.llvmver > JL_LLVM_VERSION)\n            continue;\n        if (fename.bit >= 32 * 2)\n            break;\n        const char *fename_str = fename.name;\n        bool enable = test_nbit(features, fename.bit);\n        bool disable = test_nbit(data.dis.features, fename.bit);\n        if (enable) {\n            feature_strs.insert(feature_strs.begin(), std::string(\"+\") + fename_str);\n        }\n        else if (disable) {\n            feature_strs.push_back(std::string(\"-\") + fename_str);\n        }\n    }\n#if JL_LLVM_VERSION >= 110000\n    if (test_nbit(features, Feature::v8_6a))\n        feature_strs.push_back(\"+v8.6a\");\n#endif\n    if (test_nbit(features, Feature::v8_5a))\n        feature_strs.push_back(\"+v8.5a\");\n    if (test_nbit(features, Feature::v8_4a))\n        feature_strs.push_back(\"+v8.4a\");\n    if (test_nbit(features, Feature::v8_3a))\n        feature_strs.push_back(\"+v8.3a\");\n    if (test_nbit(features, Feature::v8_2a))\n        feature_strs.push_back(\"+v8.2a\");\n    if (test_nbit(features, Feature::v8_1a))\n        feature_strs.push_back(\"+v8.1a\");\n#ifdef _CPU_ARM_\n    if (test_nbit(features, Feature::v8_m_main)) {\n        feature_strs.push_back(\"+v8m.main\");\n        feature_strs.push_back(\"+armv8-m.main\");\n    }\n    if (test_nbit(features, Feature::aclass))\n        feature_strs.push_back(\"+aclass\");\n    if (test_nbit(features, Feature::rclass))\n        feature_strs.push_back(\"+rclass\");\n    if (test_nbit(features, Feature::mclass))\n        feature_strs.push_back(\"+mclass\");\n    if (test_nbit(features, Feature::v8)) {\n        feature_strs.push_back(\"+v8\");\n        if (test_nbit(features, Feature::aclass))\n            feature_strs.push_back(\"+armv8-a\");\n        if (test_nbit(features, Feature::rclass))\n            feature_strs.push_back(\"+armv8-r\");\n        if (test_nbit(features, Feature::mclass)) {\n            feature_strs.push_back(\"+v8m\");\n            feature_strs.push_back(\"+armv8-m.base\");\n        }\n    }\n    if (test_nbit(features, Feature::v7)) {\n        feature_strs.push_back(\"+v7\");\n        if (test_nbit(features, Feature::aclass))\n            feature_strs.push_back(\"+armv7-a\");\n        if (test_nbit(features, Feature::rclass))\n            feature_strs.push_back(\"+armv7-r\");\n        if (test_nbit(features, Feature::mclass))\n            feature_strs.push_back(\"+armv7-m\");\n    }\n    feature_strs.push_back(\"+v6\");\n    feature_strs.push_back(\"+vfp2\");\n#else\n    feature_strs.push_back(\"+neon\");\n    feature_strs.push_back(\"+fp-armv8\");\n#endif\n    return std::make_pair(std::move(name), std::move(feature_strs));\n}\n\nstatic std::pair<std::string,std::vector<std::string>>\nget_llvm_target_vec(const TargetData<feature_sz> &data)\n{\n    auto res0 = get_llvm_target_noext(data);\n    append_ext_features(res0.second, data.ext_features);\n    return res0;\n}\n\nstatic std::pair<std::string,std::string>\nget_llvm_target_str(const TargetData<feature_sz> &data)\n{\n    auto res0 = get_llvm_target_noext(data);\n    auto features = join_feature_strs(res0.second);\n    append_ext_features(features, data.ext_features);\n    return std::make_pair(std::move(res0.first), std::move(features));\n}\n\nstatic FeatureList<feature_sz> get_max_feature(void)\n{\n#ifdef _CPU_ARM_\n    auto arch = get_elf_arch();\n    auto features = real_feature_masks;\n    if (arch.klass == 0)\n        arch.klass = 'A';\n    set_bit(features, Feature::v7, true);\n    set_bit(features, Feature::v8, true);\n    if (arch.klass == 'M') {\n        set_bit(features, Feature::mclass, true);\n        set_bit(features, Feature::v8_m_main, true);\n    }\n    else if (arch.klass == 'R') {\n        set_bit(features, Feature::rclass, true);\n    }\n    else if (arch.klass == 'A') {\n        set_bit(features, Feature::aclass, true);\n        set_bit(features, Feature::v8_1a, true);\n        set_bit(features, Feature::v8_2a, true);\n        set_bit(features, Feature::v8_3a, true);\n        set_bit(features, Feature::v8_4a, true);\n        set_bit(features, Feature::v8_5a, true);\n        set_bit(features, Feature::v8_6a, true);\n    }\n    return features;\n#else\n    // There isn't currently any conflicting features on AArch64\n    return feature_masks;\n#endif\n}\n\n}\n\nusing namespace ARM;\n\nJL_DLLEXPORT void jl_dump_host_cpu(void)\n{\n    dump_cpu_spec(get_host_cpu().first, get_host_cpu().second, feature_names, nfeature_names,\n                  cpus, ncpu_names);\n}\n\nJL_DLLEXPORT jl_value_t *jl_get_cpu_name(void)\n{\n    return jl_cstr_to_string(host_cpu_name().c_str());\n}\n\njl_sysimg_fptrs_t jl_init_processor_sysimg(void *hdl)\n{\n    if (!jit_targets.empty())\n        jl_error(\"JIT targets already initialized\");\n    return parse_sysimg(hdl, sysimg_init_cb);\n}\n\nstd::pair<std::string,std::vector<std::string>> jl_get_llvm_target(bool imaging, uint32_t &flags)\n{\n    ensure_jit_target(imaging);\n    flags = jit_targets[0].en.flags;\n    return get_llvm_target_vec(jit_targets[0]);\n}\n\nconst std::pair<std::string,std::string> &jl_get_llvm_disasm_target(void)\n{\n    auto max_feature = get_max_feature();\n    static const auto res = get_llvm_target_str(TargetData<feature_sz>{host_cpu_name(),\n#ifdef _CPU_AARCH64_\n#  if JL_LLVM_VERSION > 110000\n                \"+ecv,\"\n#  endif\n#  if JL_LLVM_VERSION > 100000\n                \"+tme,\"\n#  endif\n                \"+am,+specrestrict,+predres,+lor,+perfmon,+spe,+tracev8.4\",\n#else\n                \"+dotprod\",\n#endif\n                {max_feature, 0}, {feature_masks & ~max_feature, 0}, 0});\n    return res;\n}\n\nstd::vector<jl_target_spec_t> jl_get_llvm_clone_targets(void)\n{\n    if (jit_targets.empty())\n        jl_error(\"JIT targets not initialized\");\n    std::vector<jl_target_spec_t> res;\n    for (auto &target: jit_targets) {\n        auto features_en = target.en.features;\n        auto features_dis = target.dis.features;\n        for (auto &fename: feature_names) {\n            if (fename.llvmver > JL_LLVM_VERSION) {\n                unset_bits(features_en, fename.bit);\n                unset_bits(features_dis, fename.bit);\n            }\n        }\n        ARM::disable_depends(features_en);\n        jl_target_spec_t ele;\n        std::tie(ele.cpu_name, ele.cpu_features) = get_llvm_target_str(target);\n        ele.data = serialize_target_data(target.name, features_en, features_dis,\n                                         target.ext_features);\n        ele.flags = target.en.flags;\n        ele.base = target.base;\n        res.push_back(ele);\n    }\n    return res;\n}\n\nextern \"C\" int jl_test_cpu_feature(jl_cpu_feature_t feature)\n{\n    if (feature >= 32 * feature_sz)\n        return 0;\n    return test_nbit(&get_host_cpu().second[0], feature);\n}\n\n#ifdef _CPU_AARCH64_\n// FPCR FZ, bit [24]\nstatic constexpr uint32_t fpcr_fz_mask = 1 << 24;\n// FPCR DN, bit [25]\nstatic constexpr uint32_t fpcr_dn_mask = 1 << 25;\n\nstatic inline uint32_t get_fpcr_aarch64(void)\n{\n    uint32_t fpcr;\n    asm volatile(\"mrs %0, fpcr\" : \"=r\"(fpcr));\n    return fpcr;\n}\n\nstatic inline void set_fpcr_aarch64(uint32_t fpcr)\n{\n    asm volatile(\"msr fpcr, %0\" :: \"r\"(fpcr));\n}\n\nextern \"C\" JL_DLLEXPORT int32_t jl_get_zero_subnormals(void)\n{\n    return (get_fpcr_aarch64() & fpcr_fz_mask) != 0;\n}\n\nextern \"C\" JL_DLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)\n{\n    uint32_t fpcr = get_fpcr_aarch64();\n    fpcr = isZero ? (fpcr | fpcr_fz_mask) : (fpcr & ~fpcr_fz_mask);\n    set_fpcr_aarch64(fpcr);\n    return 0;\n}\n\nextern \"C\" JL_DLLEXPORT int32_t jl_get_default_nans(void)\n{\n    return (get_fpcr_aarch64() & fpcr_dn_mask) != 0;\n}\n\nextern \"C\" JL_DLLEXPORT int32_t jl_set_default_nans(int8_t isDefault)\n{\n    uint32_t fpcr = get_fpcr_aarch64();\n    fpcr = isDefault ? (fpcr | fpcr_dn_mask) : (fpcr & ~fpcr_dn_mask);\n    set_fpcr_aarch64(fpcr);\n    return 0;\n}\n#else\nextern \"C\" JL_DLLEXPORT int32_t jl_get_zero_subnormals(void)\n{\n    return 0;\n}\n\nextern \"C\" JL_DLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)\n{\n    return isZero;\n}\n\nextern \"C\" JL_DLLEXPORT int32_t jl_get_default_nans(void)\n{\n    return 0;\n}\n\nextern \"C\" JL_DLLEXPORT int32_t jl_set_default_nans(int8_t isDefault)\n{\n    return isDefault;\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/codegen.cpp": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n#include \"llvm-version.h\"\n#include \"platform.h\"\n#if defined(_OS_WINDOWS_)\n// use ELF because RuntimeDyld COFF i686 support didn't exist\n// use ELF because RuntimeDyld COFF X86_64 doesn't seem to work (fails to generate function pointers)?\n#define FORCE_ELF\n#endif\n#if defined(_CPU_X86_)\n#define JL_NEED_FLOATTEMP_VAR 1\n#endif\n#if defined(_OS_WINDOWS_) || defined(_OS_FREEBSD_)\n#define JL_DISABLE_FPO\n#endif\n\n#ifndef __STDC_LIMIT_MACROS\n#define __STDC_LIMIT_MACROS\n#define __STDC_CONSTANT_MACROS\n#endif\n\n#include <setjmp.h>\n#include <string>\n#include <fstream>\n#include <map>\n#include <array>\n#include <vector>\n#include <set>\n#include <functional>\n\n// target machine computation\n#include <llvm/CodeGen/TargetSubtargetInfo.h>\n#include <llvm/Support/TargetRegistry.h>\n#include <llvm/Target/TargetOptions.h>\n#include <llvm/Support/Host.h>\n#include <llvm/Support/TargetSelect.h>\n#include <llvm/Object/SymbolSize.h>\n\n#include <llvm/InitializePasses.h>\n\n// IR building\n#include <llvm/IR/IntrinsicInst.h>\n#include <llvm/Object/ObjectFile.h>\n#include <llvm/IR/DIBuilder.h>\n#include <llvm/AsmParser/Parser.h>\n#include <llvm/DebugInfo/DIContext.h>\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include <llvm/IR/DerivedTypes.h>\n#include <llvm/IR/Intrinsics.h>\n#include <llvm/IR/Attributes.h>\n#include <llvm/IR/IRBuilder.h>\n#include <llvm/IR/MDBuilder.h>\n\n// support\n#include <llvm/ADT/SmallBitVector.h>\n#include <llvm/ADT/Optional.h>\n#include <llvm/ADT/Statistic.h>\n#include <llvm/Support/raw_ostream.h>\n#include <llvm/Support/FormattedStream.h>\n#include <llvm/Support/SourceMgr.h> // for llvmcall\n#include <llvm/Transforms/Utils/Cloning.h> // for llvmcall inlining\n#include <llvm/Transforms/Utils/BasicBlockUtils.h>\n#include <llvm/IR/Verifier.h> // for llvmcall validation\n#include <llvm/IR/PassTimingInfo.h>\n#include <llvm/Bitcode/BitcodeWriter.h>\n\n// C API\n#include <llvm-c/Types.h>\n\n// for configuration options\n#include <llvm/Support/PrettyStackTrace.h>\n#include <llvm/Support/CommandLine.h>\n#if JL_LLVM_VERSION >= 120000\n#include <llvm/Support/Process.h>\n#endif\n\n#include <llvm/IR/InlineAsm.h>\n#if defined(_CPU_ARM_) || defined(_CPU_AARCH64_)\n#  include <sys/utsname.h>\n#endif\n#if defined(USE_POLLY)\n#include <polly/RegisterPasses.h>\n#include <polly/ScopDetection.h>\n#endif\n#include <llvm/Target/TargetMachine.h>\n\nusing namespace llvm;\n\ntypedef Instruction TerminatorInst;\n\n#if defined(_OS_WINDOWS_) && !defined(NOMINMAX)\n#define NOMINMAX\n#endif\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"jitlayers.h\"\n#include \"codegen_shared.h\"\n#include \"processor.h\"\n#include \"julia_assert.h\"\n\nJL_STREAM *dump_emitted_mi_name_stream = NULL;\nextern \"C\" JL_DLLEXPORT\nvoid jl_dump_emitted_mi_name(void *s)\n{\n    dump_emitted_mi_name_stream = (JL_STREAM*)s;\n}\n\nextern \"C\" {\n\n#include \"builtin_proto.h\"\n\n#ifdef HAVE_SSP\nextern uintptr_t __stack_chk_guard;\nextern void __stack_chk_fail();\n#else\nJL_DLLEXPORT uintptr_t __stack_chk_guard = (uintptr_t)0xBAD57ACCBAD67ACC; // 0xBADSTACKBADSTACK\nJL_DLLEXPORT void __stack_chk_fail()\n{\n    /* put your panic function or similar in here */\n    fprintf(stderr, \"fatal error: stack corruption detected\\n\");\n    gc_debug_critical_error();\n    abort(); // end with abort, since the compiler destroyed the stack upon entry to this function, there's no going back now\n}\n#endif\n\n#ifdef _OS_WINDOWS_\n#if defined(_CPU_X86_64_)\n#if defined(_COMPILER_GCC_)\nextern void ___chkstk_ms(void);\n#else\nextern void __chkstk(void);\n#endif\n#else\n#if defined(_COMPILER_GCC_)\n#undef _alloca\nextern void _alloca(void);\n#else\nextern void _chkstk(void);\n#endif\n#endif\n//void *force_chkstk(void) {\n//    return alloca(40960);\n//}\n#endif\n}\n\n#if defined(_COMPILER_MICROSOFT_) && !defined(__alignof__)\n#define __alignof__ __alignof\n#endif\n\n// llvm state\nextern JITEventListener *CreateJuliaJITEventListener();\n\n// for image reloading\nbool imaging_mode = false;\n\n// shared llvm state\nJL_DLLEXPORT LLVMContext &jl_LLVMContext = *(new LLVMContext());\nTargetMachine *jl_TargetMachine;\nstatic DataLayout &jl_data_layout = *(new DataLayout(\"\"));\n#define jl_Module ctx.f->getParent()\n#define jl_builderModule(builder) (builder).GetInsertBlock()->getParent()->getParent()\n#define prepare_call(Callee) prepare_call_in(jl_Module, (Callee))\n\n// types\nstatic Type *T_jlvalue;\nstatic Type *T_pjlvalue;\nstatic Type *T_prjlvalue;\nstatic Type *T_ppjlvalue;\nstatic Type *T_pprjlvalue;\nstatic Type *jl_array_llvmt;\nstatic Type *jl_parray_llvmt;\nstatic FunctionType *jl_func_sig;\nstatic FunctionType *jl_func_sig_sparams;\nstatic Type *T_pvoidfunc;\n\nstatic IntegerType *T_int1;\nstatic IntegerType *T_int8;\nstatic IntegerType *T_int16;\nstatic IntegerType *T_int32;\nstatic IntegerType *T_int64;\n\nstatic IntegerType *T_uint8;\nstatic IntegerType *T_uint16;\nstatic IntegerType *T_uint32;\nstatic IntegerType *T_uint64;\n\nstatic IntegerType *T_char;\nstatic IntegerType *T_size;\nstatic IntegerType *T_sigatomic;\n\nstatic Type *T_float16;\nstatic Type *T_float32;\nstatic Type *T_float64;\nstatic Type *T_float128;\n\nstatic Type *T_pint8;\nstatic Type *T_pint16;\nstatic Type *T_pint32;\nstatic Type *T_pint64;\nstatic Type *T_psize;\nstatic Type *T_pfloat32;\nstatic Type *T_pfloat64;\n\nstatic Type *T_ppint8;\nstatic Type *T_pppint8;\n\nstatic Type *T_void;\n\n// type-based alias analysis nodes.  Indentation of comments indicates hierarchy.\nstatic MDNode *tbaa_root;     // Everything\nstatic MDNode *tbaa_gcframe;    // GC frame\n// LLVM should have enough info for alias analysis of non-gcframe stack slot\n// this is mainly a place holder for `jl_cgval_t::tbaa`\nstatic MDNode *tbaa_stack;      // stack slot\nstatic MDNode *tbaa_unionselbyte;   // a selector byte in isbits Union struct fields\nstatic MDNode *tbaa_data;       // Any user data that `pointerset/ref` are allowed to alias\nstatic MDNode *tbaa_binding;        // jl_binding_t::value\nstatic MDNode *tbaa_value;          // jl_value_t, that is not jl_array_t\nstatic MDNode *tbaa_mutab;              // mutable type\nstatic MDNode *tbaa_datatype;               // datatype\nstatic MDNode *tbaa_immut;              // immutable type\nstatic MDNode *tbaa_ptrarraybuf;    // Data in an array of boxed values\nstatic MDNode *tbaa_arraybuf;       // Data in an array of POD\nstatic MDNode *tbaa_array;      // jl_array_t\nstatic MDNode *tbaa_arrayptr;       // The pointer inside a jl_array_t\nstatic MDNode *tbaa_arraysize;      // A size in a jl_array_t\nstatic MDNode *tbaa_arraylen;       // The len in a jl_array_t\nstatic MDNode *tbaa_arrayflags;     // The flags in a jl_array_t\nstatic MDNode *tbaa_arrayoffset;     // The offset in a jl_array_t\nstatic MDNode *tbaa_arrayselbyte;   // a selector byte in a isbits Union jl_array_t\nstatic MDNode *tbaa_const;      // Memory that is immutable by the time LLVM can see it\n\nstatic Attribute Thunk;\n\n// Basic DITypes\nstatic DICompositeType *jl_value_dillvmt;\nstatic DIDerivedType *jl_pvalue_dillvmt;\nstatic DIDerivedType *jl_ppvalue_dillvmt;\nstatic DISubroutineType *jl_di_func_sig;\nstatic DISubroutineType *jl_di_func_null_sig;\n\n\n// constants\nstatic Constant *V_null;\nstatic Constant *V_rnull;\nstatic Constant *V_size0;\nstatic bool type_is_ghost(Type *ty)\n{\n    return (ty == T_void || ty->isEmptyTy());\n}\n\n// should agree with `Core.Compiler.hasuniquerep`\nstatic bool type_has_unique_rep(jl_value_t *t)\n{\n    if (t == (jl_value_t*)jl_typeofbottom_type)\n        return false;\n    if (t == jl_bottom_type)\n        return true;\n    if (jl_is_typevar(t))\n        return false;\n    if (!jl_is_kind(jl_typeof(t)))\n        return true;\n    if (jl_is_concrete_type(t))\n        return true;\n    if (jl_is_datatype(t)) {\n        jl_datatype_t *dt = (jl_datatype_t*)t;\n        if (dt->name != jl_tuple_typename) {\n            for (size_t i = 0; i < jl_nparams(dt); i++)\n                if (!type_has_unique_rep(jl_tparam(dt, i)))\n                    return false;\n            return true;\n        }\n    }\n    return false;\n}\n\nstatic bool is_uniquerep_Type(jl_value_t *t)\n{\n    return jl_is_type_type(t) && type_has_unique_rep(jl_tparam0(t));\n}\n\nclass jl_codectx_t;\nstruct JuliaVariable {\npublic:\n    StringLiteral name;\n    bool isconst;\n    Type *(*_type)(LLVMContext &C);\n\n    JuliaVariable(const JuliaVariable&) = delete;\n    JuliaVariable(const JuliaVariable&&) = delete;\n    GlobalVariable *realize(Module *m) {\n        if (GlobalValue *V = m->getNamedValue(name))\n            return cast<GlobalVariable>(V);\n        return new GlobalVariable(*m, _type(m->getContext()),\n                isconst, GlobalVariable::ExternalLinkage,\n                NULL, name);\n    }\n    GlobalVariable *realize(jl_codectx_t &ctx);\n};\nstatic inline void add_named_global(JuliaVariable *name, void *addr)\n{\n    add_named_global(name->name, addr);\n}\n\nstruct JuliaFunction {\npublic:\n    StringLiteral name;\n    FunctionType *(*_type)(LLVMContext &C);\n    AttributeList (*_attrs)(LLVMContext &C);\n\n    JuliaFunction(const JuliaFunction&) = delete;\n    JuliaFunction(const JuliaFunction&&) = delete;\n    Function *realize(Module *m) {\n        if (GlobalValue *V = m->getNamedValue(name))\n            return cast<Function>(V);\n        Function *F = Function::Create(_type(m->getContext()),\n                         Function::ExternalLinkage,\n                         name, m);\n        if (_attrs)\n            F->setAttributes(_attrs(m->getContext()));\n        return F;\n    }\n    Function *realize(jl_codectx_t &ctx);\n};\n\ntemplate<typename T>\nstatic inline void add_named_global(JuliaFunction *name, T *addr)\n{\n    // cast through integer to avoid c++ pedantic warning about casting between\n    // data and code pointers\n    add_named_global(name->name, (void*)(uintptr_t)addr);\n}\ntemplate<typename T>\nstatic inline void add_named_global(StringRef name, T *addr)\n{\n    // cast through integer to avoid c++ pedantic warning about casting between\n    // data and code pointers\n    add_named_global(name, (void*)(uintptr_t)addr);\n}\n\nAttributeSet Attributes(LLVMContext &C, std::initializer_list<Attribute::AttrKind> attrkinds)\n{\n    SmallVector<Attribute, 8> attrs(attrkinds.size());\n    for (size_t i = 0; i < attrkinds.size(); i++)\n        attrs[i] = Attribute::get(C, attrkinds.begin()[i]);\n    return AttributeSet::get(C, makeArrayRef(attrs));\n}\n\nstatic Type *get_pjlvalue(LLVMContext &C) { return T_pjlvalue; }\n\nstatic FunctionType *get_func_sig(LLVMContext &C) { return jl_func_sig; }\n\nstatic AttributeList get_func_attrs(LLVMContext &C)\n{\n    return AttributeList::get(C,\n            AttributeSet::get(C, makeArrayRef({Thunk})),\n            Attributes(C, {Attribute::NonNull}),\n            None);\n}\n\nstatic AttributeList get_attrs_noreturn(LLVMContext &C)\n{\n    return AttributeList::get(C,\n                Attributes(C, {Attribute::NoReturn}),\n                AttributeSet(),\n                None);\n}\n\nstatic AttributeList get_attrs_sext(LLVMContext &C)\n{\n    return AttributeList::get(C,\n                AttributeSet(),\n                Attributes(C, {Attribute::NonNull}),\n                {Attributes(C, {Attribute::SExt})});\n}\n\nstatic AttributeList get_attrs_zext(LLVMContext &C)\n{\n    return AttributeList::get(C,\n                AttributeSet(),\n                Attributes(C, {Attribute::NonNull}),\n                {Attributes(C, {Attribute::ZExt})});\n}\n\n\n// global vars\nstatic const auto jlRTLD_DEFAULT_var = new JuliaVariable{\n    \"jl_RTLD_DEFAULT_handle\",\n    true,\n    [](LLVMContext &C) { return T_pint8; },\n};\n#ifdef _OS_WINDOWS_\nstatic const auto jlexe_var = new JuliaVariable{\n    \"jl_exe_handle\",\n    true,\n    [](LLVMContext &C) { return T_pint8; },\n};\nstatic const auto jldll_var = new JuliaVariable{\n    \"jl_libjulia_internal_handle\",\n    true,\n    [](LLVMContext &C) { return T_pint8; },\n};\n#endif //_OS_WINDOWS_\n\nstatic const auto jlstack_chk_guard_var = new JuliaVariable{\n    \"__stack_chk_guard\",\n    true,\n    get_pjlvalue,\n};\n\nstatic const auto jlgetworld_global = new JuliaVariable{\n    \"jl_world_counter\",\n    false,\n    [](LLVMContext &C) { return (Type*)T_size; },\n};\n\nstatic const auto jlboxed_int8_cache = new JuliaVariable{\n    \"jl_boxed_int8_cache\",\n    true,\n    [](LLVMContext &C) { return (Type*)ArrayType::get(T_pjlvalue, 256); },\n};\n\nstatic const auto jlboxed_uint8_cache = new JuliaVariable{\n    \"jl_boxed_uint8_cache\",\n    true,\n    [](LLVMContext &C) { return (Type*)ArrayType::get(T_pjlvalue, 256); },\n};\n\nstatic const auto jltls_states_func = new JuliaFunction{\n    \"julia.ptls_states\",\n    [](LLVMContext &C) { return FunctionType::get(PointerType::get(T_ppjlvalue, 0), false); },\n    nullptr,\n};\n\n\n// important functions\n// Symbols are not gc-tracked, but we'll treat them as callee rooted anyway,\n// because they may come from a gc-rooted location\nstatic const auto jlnew_func = new JuliaFunction{\n    \"jl_new_structv\",\n    get_func_sig,\n    get_func_attrs,\n};\nstatic const auto jlsplatnew_func = new JuliaFunction{\n    \"jl_new_structt\",\n    [](LLVMContext &C) { return FunctionType::get(T_prjlvalue,\n            {T_prjlvalue, T_prjlvalue}, false); },\n    get_func_attrs,\n};\nstatic const auto jlthrow_func = new JuliaFunction{\n    \"jl_throw\",\n    [](LLVMContext &C) { return FunctionType::get(T_void,\n            {PointerType::get(T_jlvalue, AddressSpace::CalleeRooted)}, false); },\n    get_attrs_noreturn,\n};\nstatic const auto jlerror_func = new JuliaFunction{\n    \"jl_error\",\n    [](LLVMContext &C) { return FunctionType::get(T_void,\n            {T_pint8}, false); },\n    get_attrs_noreturn,\n};\nstatic const auto jltypeerror_func = new JuliaFunction{\n    \"jl_type_error\",\n    [](LLVMContext &C) { return FunctionType::get(T_void,\n            {T_pint8, T_prjlvalue, PointerType::get(T_jlvalue, AddressSpace::CalleeRooted)}, false); },\n    get_attrs_noreturn,\n};\nstatic const auto jlundefvarerror_func = new JuliaFunction{\n    \"jl_undefined_var_error\",\n    [](LLVMContext &C) { return FunctionType::get(T_void,\n            {PointerType::get(T_jlvalue, AddressSpace::CalleeRooted)}, false); },\n    get_attrs_noreturn,\n};\nstatic const auto jlboundserrorv_func = new JuliaFunction{\n    \"jl_bounds_error_ints\",\n    [](LLVMContext &C) { return FunctionType::get(T_void,\n            {PointerType::get(T_jlvalue, AddressSpace::CalleeRooted), T_psize, T_size}, false); },\n    get_attrs_noreturn,\n};\nstatic const auto jlboundserror_func = new JuliaFunction{\n    \"jl_bounds_error_int\",\n    [](LLVMContext &C) { return FunctionType::get(T_void,\n            {PointerType::get(T_jlvalue, AddressSpace::CalleeRooted), T_size}, false); },\n    get_attrs_noreturn,\n};\nstatic const auto jlvboundserror_func = new JuliaFunction{\n    \"jl_bounds_error_tuple_int\",\n    [](LLVMContext &C) { return FunctionType::get(T_void,\n            {T_pprjlvalue, T_size, T_size}, false); },\n    get_attrs_noreturn,\n};\nstatic const auto jluboundserror_func = new JuliaFunction{\n    \"jl_bounds_error_unboxed_int\",\n    [](LLVMContext &C) { return FunctionType::get(T_void,\n            {PointerType::get(T_int8, AddressSpace::Derived), T_pjlvalue, T_size}, false); },\n    get_attrs_noreturn,\n};\nstatic const auto jlcheckassign_func = new JuliaFunction{\n    \"jl_checked_assignment\",\n    [](LLVMContext &C) { return FunctionType::get(T_void,\n            {T_pjlvalue, PointerType::get(T_jlvalue, AddressSpace::CalleeRooted)}, false); },\n    nullptr,\n};\nstatic const auto jldeclareconst_func = new JuliaFunction{\n    \"jl_declare_constant\",\n    [](LLVMContext &C) { return FunctionType::get(T_void,\n            {T_pjlvalue}, false); },\n    nullptr,\n};\nstatic const auto jlgetbindingorerror_func = new JuliaFunction{\n    \"jl_get_binding_or_error\",\n    [](LLVMContext &C) { return FunctionType::get(T_pjlvalue,\n                {T_pjlvalue, T_pjlvalue}, false); },\n    nullptr,\n};\nstatic const auto jlboundp_func = new JuliaFunction{\n    \"jl_boundp\",\n    [](LLVMContext &C) { return FunctionType::get(T_int32,\n                {T_pjlvalue, T_pjlvalue}, false); },\n    nullptr,\n};\nstatic const auto jltopeval_func = new JuliaFunction{\n    \"jl_toplevel_eval\",\n    [](LLVMContext &C) { return FunctionType::get(T_pjlvalue,\n                {T_pjlvalue, T_pjlvalue}, false); },\n    [](LLVMContext &C) { return AttributeList::get(C,\n            AttributeSet(),\n            Attributes(C, {Attribute::NonNull}),\n            None); },\n};\nstatic const auto jlcopyast_func = new JuliaFunction{\n    \"jl_copy_ast\",\n    [](LLVMContext &C) { return FunctionType::get(T_prjlvalue,\n                {T_prjlvalue}, false); },\n    [](LLVMContext &C) { return AttributeList::get(C,\n            AttributeSet(),\n            Attributes(C, {Attribute::NonNull}),\n            None); },\n};\n//static const auto jlnsvec_func = new JuliaFunction{\n//    \"jl_svec\",\n//    [](LLVMContext &C) { return FunctionType::get(T_prjlvalue,\n//                {T_size}, true); },\n//    [](LLVMContext &C) { return AttributeList::get(C,\n//            AttributeSet(),\n//            Attributes(C, {Attribute::NonNull}),\n//            None); },\n//};\nstatic const auto jlapplygeneric_func = new JuliaFunction{\n    \"jl_apply_generic\",\n    get_func_sig,\n    get_func_attrs,\n};\nstatic const auto jlinvoke_func = new JuliaFunction{\n    \"jl_invoke\",\n    [](LLVMContext &C) { return FunctionType::get(T_prjlvalue,\n                {T_prjlvalue, T_pprjlvalue, T_uint32, T_prjlvalue}, false); },\n    [](LLVMContext &C) { return AttributeList::get(C,\n            AttributeSet(),\n            Attributes(C, {Attribute::NonNull}),\n            {AttributeSet(),\n             Attributes(C, {Attribute::ReadOnly, Attribute::NoCapture})}); },\n};\nstatic const auto jlmethod_func = new JuliaFunction{\n    \"jl_method_def\",\n    [](LLVMContext &C) { return FunctionType::get(T_prjlvalue,\n                {T_prjlvalue, T_prjlvalue, T_pjlvalue}, false); },\n    nullptr,\n};\nstatic const auto jlgenericfunction_func = new JuliaFunction{\n    \"jl_generic_function_def\",\n    [](LLVMContext &C) { return FunctionType::get(T_prjlvalue,\n                {T_pjlvalue, T_pjlvalue, T_pprjlvalue, T_pjlvalue, T_pjlvalue}, false); },\n    nullptr,\n};\nstatic const auto jlenter_func = new JuliaFunction{\n    \"jl_enter_handler\",\n    [](LLVMContext &C) { return FunctionType::get(T_void,\n            {T_pint8}, false); },\n    nullptr,\n};\nstatic const auto jl_current_exception_func = new JuliaFunction{\n    \"jl_current_exception\",\n    [](LLVMContext &C) { return FunctionType::get(T_prjlvalue, false); },\n    nullptr,\n};\nstatic const auto jlleave_func = new JuliaFunction{\n    \"jl_pop_handler\",\n    [](LLVMContext &C) { return FunctionType::get(T_void,\n            {T_int32}, false); },\n    nullptr,\n};\nstatic const auto jl_restore_excstack_func = new JuliaFunction{\n    \"jl_restore_excstack\",\n    [](LLVMContext &C) { return FunctionType::get(T_void,\n            {T_size}, false); },\n    nullptr,\n};\nstatic const auto jl_excstack_state_func = new JuliaFunction{\n    \"jl_excstack_state\",\n    [](LLVMContext &C) { return FunctionType::get(T_size, false); },\n    nullptr,\n};\nstatic const auto jlegal_func = new JuliaFunction{\n    \"jl_egal\",\n    [](LLVMContext &C) {\n        Type *T = PointerType::get(T_jlvalue, AddressSpace::CalleeRooted);\n        return FunctionType::get(T_int32, {T, T}, false); },\n    nullptr,\n};\nstatic const auto jl_alloc_obj_func = new JuliaFunction{\n    \"julia.gc_alloc_obj\",\n    [](LLVMContext &C) { return FunctionType::get(T_prjlvalue,\n                {T_pint8, T_size, T_prjlvalue}, false); },\n    [](LLVMContext &C) { return AttributeList::get(C,\n            AttributeSet::get(C, makeArrayRef({Attribute::getWithAllocSizeArgs(C, 1, None)})), // returns %1 bytes\n            Attributes(C, {Attribute::NoAlias, Attribute::NonNull}),\n            None); },\n};\nstatic const auto jl_newbits_func = new JuliaFunction{\n    \"jl_new_bits\",\n    [](LLVMContext &C) { return FunctionType::get(T_prjlvalue,\n                {T_prjlvalue, T_pint8}, false); },\n    [](LLVMContext &C) { return AttributeList::get(C,\n            AttributeSet(),\n            Attributes(C, {Attribute::NonNull}),\n            None); },\n};\n// `julia.typeof` does read memory, but it is effectively readnone before we lower\n// the allocation function. This is OK as long as we lower `julia.typeof` no later than\n// `julia.gc_alloc_obj`.\nstatic const auto jl_typeof_func = new JuliaFunction{\n    \"julia.typeof\",\n    [](LLVMContext &C) { return FunctionType::get(T_prjlvalue,\n                {T_prjlvalue}, false); },\n    [](LLVMContext &C) { return AttributeList::get(C,\n            Attributes(C, {Attribute::ReadNone, Attribute::NoUnwind, Attribute::NoRecurse}),\n            Attributes(C, {Attribute::NonNull}),\n            None); },\n};\nstatic const auto jl_loopinfo_marker_func = new JuliaFunction{\n    \"julia.loopinfo_marker\",\n    [](LLVMContext &C) { return FunctionType::get(T_void, false); },\n    [](LLVMContext &C) { return AttributeList::get(C,\n            Attributes(C, {Attribute::ReadOnly, Attribute::NoRecurse, Attribute::InaccessibleMemOnly}),\n            AttributeSet(),\n            None); },\n};\nstatic const auto jl_write_barrier_func = new JuliaFunction{\n    \"julia.write_barrier\",\n    [](LLVMContext &C) { return FunctionType::get(T_void,\n            {T_prjlvalue}, true); },\n    [](LLVMContext &C) { return AttributeList::get(C,\n            Attributes(C, {Attribute::NoUnwind, Attribute::NoRecurse, Attribute::InaccessibleMemOnly}),\n            AttributeSet(),\n            None); },\n};\nstatic const auto jlisa_func = new JuliaFunction{\n    \"jl_isa\",\n    [](LLVMContext &C) { return FunctionType::get(T_int32,\n            {T_prjlvalue, T_prjlvalue}, false); },\n    nullptr,\n};\n\nstatic const auto jlsubtype_func = new JuliaFunction{\n    \"jl_subtype\",\n    [](LLVMContext &C) { return FunctionType::get(T_int32,\n            {T_prjlvalue, T_prjlvalue}, false); },\n    nullptr,\n};\nstatic const auto jlapplytype_func = new JuliaFunction{\n    \"jl_instantiate_type_in_env\",\n    [](LLVMContext &C) { return FunctionType::get(T_prjlvalue,\n            {T_pjlvalue, T_pjlvalue, T_pprjlvalue}, false); },\n    [](LLVMContext &C) {\n        return AttributeList::get(C,\n            AttributeSet(),\n            AttributeSet::get(C, makeArrayRef({Attribute::get(C, Attribute::NonNull),\n                                               Attribute::getWithAlignment(C, Align(16))})),\n            None);\n    },\n};\nstatic const auto jl_object_id__func = new JuliaFunction{\n    \"jl_object_id_\",\n    [](LLVMContext &C) { return FunctionType::get(T_size,\n            {T_prjlvalue, PointerType::get(T_int8, AddressSpace::Derived)}, false); },\n    nullptr,\n};\nstatic const auto setjmp_func = new JuliaFunction{\n    jl_setjmp_name,\n    [](LLVMContext &C) { return FunctionType::get(T_int32,\n            {T_pint8,\n#ifndef _OS_WINDOWS_\n            T_int32,\n#endif\n            }, false); },\n    [](LLVMContext &C) { return AttributeList::get(C,\n            Attributes(C, {Attribute::ReturnsTwice}),\n            AttributeSet(),\n            None); },\n};\nstatic const auto memcmp_func = new JuliaFunction{\n    \"memcmp\",\n    [](LLVMContext &C) { return FunctionType::get(T_int32,\n            {T_pint8, T_pint8, T_size}, false); },\n    [](LLVMContext &C) { return AttributeList::get(C,\n            Attributes(C, {Attribute::ReadOnly, Attribute::NoUnwind, Attribute::ArgMemOnly}),\n            AttributeSet(),\n            None); },\n    // TODO: inferLibFuncAttributes(*memcmp_func, TLI);\n};\nstatic const auto jldlsym_func = new JuliaFunction{\n    \"jl_load_and_lookup\",\n    [](LLVMContext &C) { return FunctionType::get(T_pvoidfunc,\n            {T_pint8, T_pint8, PointerType::get(T_pint8, 0)}, false); },\n    nullptr,\n};\nstatic const auto jllazydlsym_func = new JuliaFunction{\n    \"jl_lazy_load_and_lookup\",\n    [](LLVMContext &C) { return FunctionType::get(T_pvoidfunc,\n            {T_prjlvalue, T_pint8}, false); },\n    nullptr,\n};\nstatic const auto jltypeassert_func = new JuliaFunction{\n    \"jl_typeassert\",\n    [](LLVMContext &C) { return FunctionType::get(T_void,\n            {T_prjlvalue, T_prjlvalue}, false); },\n    nullptr,\n};\nstatic const auto jlgetnthfieldchecked_func = new JuliaFunction{\n    \"jl_get_nth_field_checked\",\n    [](LLVMContext &C) { return FunctionType::get(T_prjlvalue,\n            {T_prjlvalue, T_size}, false); },\n    [](LLVMContext &C) { return AttributeList::get(C,\n            AttributeSet(),\n            Attributes(C, {Attribute::NonNull}),\n            None); },\n};\nstatic const auto jlgetcfunctiontrampoline_func = new JuliaFunction{\n    \"jl_get_cfunction_trampoline\",\n    [](LLVMContext &C) { return FunctionType::get(T_prjlvalue,\n            {\n                T_prjlvalue, // f (object)\n                T_pjlvalue, // result\n                T_pint8, // cache\n                T_pjlvalue, // fill\n                FunctionType::get(T_pint8, { T_pint8, T_ppjlvalue }, false)->getPointerTo(), // trampoline\n                T_pjlvalue, // env\n                T_pprjlvalue, // vals\n            }, false); },\n    [](LLVMContext &C) { return AttributeList::get(C,\n            AttributeSet(),\n            Attributes(C, {Attribute::NonNull}),\n            None); },\n};\nstatic const auto diff_gc_total_bytes_func = new JuliaFunction{\n    \"jl_gc_diff_total_bytes\",\n    [](LLVMContext &C) { return FunctionType::get(T_int64, false); },\n    nullptr,\n};\nstatic const auto sync_gc_total_bytes_func = new JuliaFunction{\n    \"jl_gc_sync_total_bytes\",\n    [](LLVMContext &C) { return FunctionType::get(T_int64,\n            {T_int64}, false); },\n    nullptr,\n};\nstatic const auto jlarray_data_owner_func = new JuliaFunction{\n    \"jl_array_data_owner\",\n    [](LLVMContext &C) { return FunctionType::get(T_prjlvalue,\n            {T_prjlvalue}, false); },\n    [](LLVMContext &C) { return AttributeList::get(C,\n            Attributes(C, {Attribute::ReadOnly, Attribute::NoUnwind}),\n            Attributes(C, {Attribute::NonNull}),\n            None); },\n};\n#define BOX_FUNC(ct,rt,at,attrs)                                              \\\nstatic const auto box_##ct##_func = new JuliaFunction{                        \\\n    \"jl_box_\"#ct,                                                             \\\n    [](LLVMContext &C) { return FunctionType::get(rt,                         \\\n            {at}, false); },                                                  \\\n    attrs,                                                                    \\\n}\nBOX_FUNC(int16, T_prjlvalue, T_int16, get_attrs_sext);\nBOX_FUNC(uint16, T_prjlvalue, T_int16, get_attrs_zext);\nBOX_FUNC(int32, T_prjlvalue, T_int32, get_attrs_sext);\nBOX_FUNC(uint32, T_prjlvalue, T_int32, get_attrs_zext);\nBOX_FUNC(int64, T_prjlvalue, T_int64, get_attrs_sext);\nBOX_FUNC(uint64, T_prjlvalue, T_int64, get_attrs_zext);\nBOX_FUNC(char, T_prjlvalue, T_char, get_attrs_zext);\nBOX_FUNC(float32, T_prjlvalue, T_float32, get_func_attrs);\nBOX_FUNC(float64, T_prjlvalue, T_float64, get_func_attrs);\nBOX_FUNC(ssavalue, T_prjlvalue, T_size, get_func_attrs);\n#undef BOX_FUNC\n\n\n// placeholder functions\nstatic const auto gcroot_flush_func = new JuliaFunction{\n    \"julia.gcroot_flush\",\n    [](LLVMContext &C) { return FunctionType::get(T_void, false); },\n    nullptr,\n};\nstatic const auto gc_preserve_begin_func = new JuliaFunction{\n    \"llvm.julia.gc_preserve_begin\",\n    [](LLVMContext &C) { return FunctionType::get(Type::getTokenTy(C), true); },\n    nullptr,\n};\nstatic const auto gc_preserve_end_func = new JuliaFunction {\n    \"llvm.julia.gc_preserve_end\",\n    [](LLVMContext &C) { return FunctionType::get(T_void, {Type::getTokenTy(C)}, false); },\n    nullptr,\n};\nstatic const auto except_enter_func = new JuliaFunction{\n    \"julia.except_enter\",\n    [](LLVMContext &C) { return FunctionType::get(T_int32, false); },\n    [](LLVMContext &C) { return AttributeList::get(C,\n            AttributeSet::get(C, makeArrayRef({Attribute::get(C, Attribute::ReturnsTwice)})),\n            AttributeSet(),\n            None); },\n};\nstatic const auto pointer_from_objref_func = new JuliaFunction{\n    \"julia.pointer_from_objref\",\n    [](LLVMContext &C) { return FunctionType::get(T_pjlvalue,\n            {PointerType::get(T_jlvalue, AddressSpace::Derived)}, false); },\n    [](LLVMContext &C) { return AttributeList::get(C,\n            AttributeSet::get(C, makeArrayRef({Attribute::get(C, Attribute::ReadNone), Attribute::get(C, Attribute::NoUnwind)})),\n            Attributes(C, {Attribute::NonNull}),\n            None); },\n};\n\nstatic const auto jltuple_func = new JuliaFunction{\"jl_f_tuple\", get_func_sig, get_func_attrs};\nstatic const auto jlgetfield_func = new JuliaFunction{\"jl_f_getfield\", get_func_sig, get_func_attrs};\nstatic const std::map<jl_fptr_args_t, JuliaFunction*> builtin_func_map = {\n    { &jl_f_is,                 new JuliaFunction{\"jl_f_is\", get_func_sig, get_func_attrs} },\n    { &jl_f_typeof,             new JuliaFunction{\"jl_f_typeof\", get_func_sig, get_func_attrs} },\n    { &jl_f_sizeof,             new JuliaFunction{\"jl_f_sizeof\", get_func_sig, get_func_attrs} },\n    { &jl_f_issubtype,          new JuliaFunction{\"jl_f_issubtype\", get_func_sig, get_func_attrs} },\n    { &jl_f_isa,                new JuliaFunction{\"jl_f_isa\", get_func_sig, get_func_attrs} },\n    { &jl_f_typeassert,         new JuliaFunction{\"jl_f_typeassert\", get_func_sig, get_func_attrs} },\n    { &jl_f_ifelse,             new JuliaFunction{\"jl_f_ifelse\", get_func_sig, get_func_attrs} },\n    { &jl_f__apply_iterate,     new JuliaFunction{\"jl_f__apply_iterate\", get_func_sig, get_func_attrs} },\n    { &jl_f__apply_pure,        new JuliaFunction{\"jl_f__apply_pure\", get_func_sig, get_func_attrs} },\n    { &jl_f__call_latest,       new JuliaFunction{\"jl_f__call_latest\", get_func_sig, get_func_attrs} },\n    { &jl_f__call_in_world,     new JuliaFunction{\"jl_f__call_in_world\", get_func_sig, get_func_attrs} },\n    { &jl_f_throw,              new JuliaFunction{\"jl_f_throw\", get_func_sig, get_func_attrs} },\n    { &jl_f_tuple,              jltuple_func },\n    { &jl_f_svec,               new JuliaFunction{\"jl_f_svec\", get_func_sig, get_func_attrs} },\n    { &jl_f_applicable,         new JuliaFunction{\"jl_f_applicable\", get_func_sig, get_func_attrs} },\n    { &jl_f_invoke,             new JuliaFunction{\"jl_f_invoke\", get_func_sig, get_func_attrs} },\n    { &jl_f_invoke_kwsorter,    new JuliaFunction{\"jl_f_invoke_kwsorter\", get_func_sig, get_func_attrs} },\n    { &jl_f_isdefined,          new JuliaFunction{\"jl_f_isdefined\", get_func_sig, get_func_attrs} },\n    { &jl_f_getfield,           jlgetfield_func },\n    { &jl_f_setfield,           new JuliaFunction{\"jl_f_setfield\", get_func_sig, get_func_attrs} },\n    { &jl_f_fieldtype,          new JuliaFunction{\"jl_f_fieldtype\", get_func_sig, get_func_attrs} },\n    { &jl_f_nfields,            new JuliaFunction{\"jl_f_nfields\", get_func_sig, get_func_attrs} },\n    { &jl_f__expr,              new JuliaFunction{\"jl_f__expr\", get_func_sig, get_func_attrs} },\n    { &jl_f__typevar,           new JuliaFunction{\"jl_f__typevar\", get_func_sig, get_func_attrs} },\n    { &jl_f_arrayref,           new JuliaFunction{\"jl_f_arrayref\", get_func_sig, get_func_attrs} },\n    { &jl_f_const_arrayref,     new JuliaFunction{\"jl_f_const_arrayref\", get_func_sig, get_func_attrs} },\n    { &jl_f_arrayset,           new JuliaFunction{\"jl_f_arrayset\", get_func_sig, get_func_attrs} },\n    { &jl_f_arraysize,          new JuliaFunction{\"jl_f_arraysize\", get_func_sig, get_func_attrs} },\n    { &jl_f_apply_type,         new JuliaFunction{\"jl_f_apply_type\", get_func_sig, get_func_attrs} },\n};\n\nstatic const auto jl_new_opaque_closure_jlcall_func = new JuliaFunction{\"jl_new_opaque_closure_jlcall\", get_func_sig, get_func_attrs};\n\nstatic int globalUnique = 0;\n\n// --- code generation ---\nextern \"C\" {\n    int jl_default_debug_info_kind = (int) DICompileUnit::DebugEmissionKind::FullDebug;\n    jl_cgparams_t jl_default_cgparams = {1, 1, 0,\n#ifdef _OS_WINDOWS_\n        0,\n#else\n        1,\n#endif\n        jl_default_debug_info_kind,\n        jl_rettype_inferred, NULL };\n}\n\ntemplate<typename T>\nstatic void add_return_attr(T *f, Attribute::AttrKind Kind)\n{\n    f->addAttribute(AttributeList::ReturnIndex, Kind);\n}\n\nstatic MDNode *best_tbaa(jl_value_t *jt) {\n    jt = jl_unwrap_unionall(jt);\n    if (jt == (jl_value_t*)jl_datatype_type ||\n        (jl_is_type_type(jt) && jl_is_datatype(jl_tparam0(jt))))\n        return tbaa_datatype;\n    if (!jl_is_datatype(jt))\n        return tbaa_value;\n    if (jl_is_abstracttype(jt))\n        return tbaa_value;\n    // If we're here, we know all subtypes are (im)mutable, even if we\n    // don't know what the exact type is\n    return jl_is_mutable(jt) ? tbaa_mutab : tbaa_immut;\n}\n\n// tracks whether codegen is currently able to simply stack-allocate this type\n// note that this includes jl_isbits, although codegen should work regardless\nstatic bool jl_is_concrete_immutable(jl_value_t* t)\n{\n    return jl_is_immutable_datatype(t) && ((jl_datatype_t*)t)->layout;\n}\n\nstatic bool jl_is_pointerfree(jl_value_t* t)\n{\n    if (!jl_is_immutable_datatype(t))\n        return 0;\n    const jl_datatype_layout_t *layout = ((jl_datatype_t*)t)->layout;\n    return layout && layout->npointers == 0;\n}\n\n// these queries are usually related, but we split them out here\n// for convenience and clarity (and because it changes the calling convention)\nstatic bool deserves_stack(jl_value_t* t, bool pointerfree=false)\n{\n    if (!jl_is_concrete_immutable(t))\n        return false;\n    return ((jl_datatype_t*)t)->isinlinealloc;\n}\nstatic bool deserves_argbox(jl_value_t* t)\n{\n    return !deserves_stack(t);\n}\nstatic bool deserves_retbox(jl_value_t* t)\n{\n    return deserves_argbox(t);\n}\nstatic bool deserves_sret(jl_value_t *dt, Type *T)\n{\n    assert(jl_is_datatype(dt));\n    return (size_t)jl_datatype_size(dt) > sizeof(void*) && !T->isFloatingPointTy() && !T->isVectorTy();\n}\n\n\n// metadata tracking for a llvm Value* during codegen\nstruct jl_cgval_t {\n    Value *V; // may be of type T* or T, or set to NULL if ghost (or if the value has not been initialized yet, for a variable definition)\n    // For unions, we may need to keep a reference to the boxed part individually.\n    // If this is non-NULL, then, at runtime, we satisfy the invariant that (for the corresponding\n    // runtime values) if `(TIndex | 0x80) != 0`, then `Vboxed == V` (by value).\n    // For convenience, we also set this value of isboxed values, in which case\n    // it is equal (at compile time) to V.\n    // If this is non-NULL, it is always of type `T_prjlvalue`\n    Value *Vboxed;\n    Value *TIndex; // if `V` is an unboxed (tagged) Union described by `typ`, this gives the DataType index (1-based, small int) as an i8\n    jl_value_t *constant; // constant value (rooted in linfo.def.roots)\n    jl_value_t *typ; // the original type of V, never NULL\n    bool isboxed; // whether this value is a jl_value_t* allocated on the heap with the right type tag\n    bool isghost; // whether this value is \"ghost\"\n    MDNode *tbaa; // The related tbaa node. Non-NULL iff this holds an address.\n    bool ispointer() const\n    {\n        // whether this value is compatible with `data_pointer`\n        return tbaa != nullptr;\n    }\n    jl_cgval_t(Value *V, Value *gcroot, bool isboxed, jl_value_t *typ, Value *tindex) : // general constructor (with pointer type auto-detect)\n        V(V), // V is allowed to be NULL in a jl_varinfo_t context, but not during codegen contexts\n        Vboxed(isboxed ? V : nullptr),\n        TIndex(tindex),\n        constant(NULL),\n        typ(typ),\n        isboxed(isboxed),\n        isghost(false),\n        tbaa(isboxed ? best_tbaa(typ) : nullptr)\n    {\n        if (Vboxed)\n            assert(Vboxed->getType() == T_prjlvalue);\n        assert(gcroot == nullptr);\n        assert(!(isboxed && TIndex != NULL));\n        assert(TIndex == NULL || TIndex->getType() == T_int8);\n    }\n    explicit jl_cgval_t(jl_value_t *typ) : // ghost value constructor\n        // mark explicit to avoid being used implicitly for conversion from NULL (use jl_cgval_t() instead)\n        V(NULL),\n        Vboxed(NULL),\n        TIndex(NULL),\n        constant(((jl_datatype_t*)typ)->instance),\n        typ(typ),\n        isboxed(false),\n        isghost(true),\n        tbaa(nullptr)\n    {\n        assert(jl_is_datatype(typ));\n        assert(constant);\n    }\n    jl_cgval_t(const jl_cgval_t &v, jl_value_t *typ, Value *tindex) : // copy constructor with new type\n        V(v.V),\n        Vboxed(v.Vboxed),\n        TIndex(tindex),\n        constant(v.constant),\n        typ(typ),\n        isboxed(v.isboxed),\n        isghost(v.isghost),\n        tbaa(v.tbaa)\n    {\n        if (Vboxed)\n            assert(Vboxed->getType() == T_prjlvalue);\n        // this constructor expects we had a badly or equivalently typed version\n        // make sure we aren't discarding the actual type information\n        if (v.TIndex) {\n            assert((TIndex == NULL) == jl_is_concrete_type(typ));\n        }\n        else {\n            assert(isboxed || v.typ == typ || tindex);\n        }\n    }\n    jl_cgval_t() : // undef / unreachable / default constructor\n        V(UndefValue::get(T_void)),\n        Vboxed(NULL),\n        TIndex(NULL),\n        constant(NULL),\n        typ(jl_bottom_type),\n        isboxed(false),\n        isghost(true),\n        tbaa(nullptr)\n    {\n    }\n};\n\n// per-local-variable information\nstruct jl_varinfo_t {\n    Instruction *boxroot; // an address, if the var might be in a jl_value_t** stack slot (marked tbaa_const, if appropriate)\n    jl_cgval_t value; // a stack slot or constant value\n    Value *pTIndex; // i8* stack slot for the value.TIndex tag describing `value.V`\n    DILocalVariable *dinfo;\n    // if the variable might be used undefined and is not boxed\n    // this i1 flag is true when it is defined\n    Value *defFlag;\n    bool isSA; // whether all stores dominate all uses\n    bool isVolatile;\n    bool isArgument;\n    bool usedUndef;\n    bool used;\n\n    jl_varinfo_t() : boxroot(NULL),\n                     value(jl_cgval_t()),\n                     pTIndex(NULL),\n                     dinfo(NULL),\n                     defFlag(NULL),\n                     isSA(false),\n                     isVolatile(false),\n                     isArgument(false),\n                     usedUndef(false),\n                     used(false)\n    {\n    }\n};\n\n// information about the context of a piece of code: its enclosing\n// function and module, and visible local variables and labels.\nclass jl_codectx_t {\npublic:\n    IRBuilder<> builder;\n    jl_codegen_params_t &emission_context;\n    jl_codegen_call_targets_t &call_targets;\n    std::map<void*, GlobalVariable*> &global_targets;\n    Function *f = NULL;\n    // local var info. globals are not in here.\n    std::vector<jl_varinfo_t> slots;\n    std::map<int, jl_varinfo_t> phic_slots;\n    std::vector<jl_cgval_t> SAvalues;\n    std::vector<std::tuple<jl_cgval_t, BasicBlock *, AllocaInst *, PHINode *, jl_value_t *>> PhiNodes;\n    std::vector<bool> ssavalue_assigned;\n    std::vector<std::unique_ptr<Module>> oc_modules;\n    jl_module_t *module = NULL;\n    jl_method_instance_t *linfo = NULL;\n    jl_value_t *rettype = NULL;\n    jl_code_info_t *source = NULL;\n    jl_array_t *code = NULL;\n    size_t world = 0;\n    jl_array_t *roots = NULL;\n    const char *name = NULL;\n    StringRef file{};\n    ssize_t *line = NULL;\n    Value *spvals_ptr = NULL;\n    Value *argArray = NULL;\n    Value *argCount = NULL;\n    MDNode *aliasscope = NULL;\n    std::string funcName;\n    int vaSlot = -1;        // name of vararg argument\n    int nReqArgs = 0;\n    int nargs = 0;\n    int nvargs = -1;\n    bool is_opaque_closure = false;\n\n    CallInst *ptlsStates = NULL;\n    Value *signalPage = NULL;\n    Value *world_age_field = NULL;\n\n    bool debug_enabled = false;\n    bool use_cache = false;\n    const jl_cgparams_t *params = NULL;\n\n    std::vector<std::unique_ptr<llvm::Module>> llvmcall_modules;\n\n    jl_codectx_t(LLVMContext &llvmctx, jl_codegen_params_t &params)\n      : builder(llvmctx),\n        emission_context(params),\n        call_targets(params.workqueue),\n        global_targets(params.globals),\n        world(params.world),\n        use_cache(params.cache),\n        params(params.params) { }\n\n    ~jl_codectx_t() {\n        assert(this->roots == NULL);\n    }\n};\n\nGlobalVariable *JuliaVariable::realize(jl_codectx_t &ctx) {\n    return realize(jl_Module);\n}\n\nstatic Type *julia_type_to_llvm(jl_codectx_t &ctx, jl_value_t *jt, bool *isboxed = NULL);\nstatic jl_returninfo_t get_specsig_function(jl_codectx_t &ctx, Module *M, StringRef name, jl_value_t *sig, jl_value_t *jlrettype);\nstatic jl_cgval_t emit_expr(jl_codectx_t &ctx, jl_value_t *expr, ssize_t ssaval = -1);\nstatic Value *global_binding_pointer(jl_codectx_t &ctx, jl_module_t *m, jl_sym_t *s,\n                                     jl_binding_t **pbnd, bool assign);\nstatic jl_cgval_t emit_checked_var(jl_codectx_t &ctx, Value *bp, jl_sym_t *name, bool isvol, MDNode *tbaa);\nstatic jl_cgval_t emit_sparam(jl_codectx_t &ctx, size_t i);\nstatic Value *emit_condition(jl_codectx_t &ctx, const jl_cgval_t &condV, const std::string &msg);\nstatic void allocate_gc_frame(jl_codectx_t &ctx, BasicBlock *b0);\nstatic void CreateTrap(IRBuilder<> &irbuilder);\nstatic CallInst *emit_jlcall(jl_codectx_t &ctx, Function *theFptr, Value *theF,\n                             jl_cgval_t *args, size_t nargs, CallingConv::ID cc);\nstatic CallInst *emit_jlcall(jl_codectx_t &ctx, JuliaFunction *theFptr, Value *theF,\n                             jl_cgval_t *args, size_t nargs, CallingConv::ID cc);\n\nstatic Value *literal_pointer_val(jl_codectx_t &ctx, jl_value_t *p);\nstatic GlobalVariable *prepare_global_in(Module *M, GlobalVariable *G);\nstatic Instruction *tbaa_decorate(MDNode *md, Instruction *inst);\n\nstatic GlobalVariable *prepare_global_in(Module *M, JuliaVariable *G)\n{\n    return G->realize(M);\n}\n\nstatic Function *prepare_call_in(Module *M, JuliaFunction *G)\n{\n    return G->realize(M);\n}\n\nstatic inline GlobalVariable *prepare_global_in(Module *M, GlobalVariable *G)\n{\n    if (G->getParent() == M)\n        return G;\n    GlobalValue *local = M->getNamedValue(G->getName());\n    if (!local) {\n        // Copy the GlobalVariable, but without the initializer, so it becomes a declaration\n        GlobalVariable *proto = new GlobalVariable(*M, G->getType()->getElementType(),\n                G->isConstant(), GlobalVariable::ExternalLinkage,\n                nullptr, G->getName(), nullptr, G->getThreadLocalMode());\n        proto->copyAttributesFrom(G);\n        // DLLImport only needs to be set for the shadow module\n        // it just gets annoying in the JIT\n        proto->setDLLStorageClass(GlobalValue::DefaultStorageClass);\n        return proto;\n    }\n    return cast<GlobalVariable>(local);\n}\n\n\n// --- convenience functions for tagging llvm values with julia types ---\n\nstatic GlobalVariable *get_pointer_to_constant(jl_codegen_params_t &emission_context, Constant *val, StringRef name, Module &M)\n{\n    GlobalVariable *&gv = emission_context.mergedConstants[val];\n    StringRef localname;\n    std::string ssno;\n    if (gv == nullptr) {\n        raw_string_ostream(ssno) << name << emission_context.mergedConstants.size();\n        localname = StringRef(ssno);\n    }\n    else {\n        localname = gv->getName();\n        if (gv->getParent() != &M)\n            gv = cast_or_null<GlobalVariable>(M.getNamedValue(localname));\n    }\n    if (gv == nullptr) {\n        gv = new GlobalVariable(\n                M,\n                val->getType(),\n                true,\n                GlobalVariable::PrivateLinkage,\n                val,\n                localname);\n        gv->setUnnamedAddr(GlobalValue::UnnamedAddr::Global);\n    }\n    assert(localname == gv->getName());\n    assert(val == gv->getInitializer());\n    return gv;\n}\n\nstatic AllocaInst *emit_static_alloca(jl_codectx_t &ctx, Type *lty)\n{\n    return new AllocaInst(lty, 0, \"\", /*InsertBefore=*/ctx.ptlsStates);\n}\n\nstatic void undef_derived_strct(IRBuilder<> &irbuilder, Value *ptr, jl_datatype_t *sty, MDNode *tbaa)\n{\n    assert(ptr->getType()->getPointerAddressSpace() != AddressSpace::Tracked);\n    size_t i, np = sty->layout->npointers;\n    if (np == 0)\n        return;\n    ptr = irbuilder.CreateBitCast(ptr, T_prjlvalue->getPointerTo(ptr->getType()->getPointerAddressSpace()));\n    for (i = 0; i < np; i++) {\n        Value *fld = irbuilder.CreateConstInBoundsGEP1_32(T_prjlvalue, ptr, jl_ptr_offset(sty, i));\n        tbaa_decorate(tbaa, irbuilder.CreateStore(V_rnull, fld));\n    }\n}\n\nstatic Value *emit_inttoptr(jl_codectx_t &ctx, Value *v, Type *ty)\n{\n    // Almost all of our inttoptr are generated due to representing `Ptr` with `T_size`\n    // in LLVM and most of these integers are generated from `ptrtoint` in the first place.\n    if (auto I = dyn_cast<PtrToIntInst>(v)) {\n        auto ptr = I->getOperand(0);\n        if (ty->getPointerAddressSpace() == ptr->getType()->getPointerAddressSpace())\n            return ctx.builder.CreateBitCast(ptr, ty);\n        else if (ty->getPointerElementType() == ptr->getType()->getPointerElementType())\n            return ctx.builder.CreateAddrSpaceCast(ptr, ty);\n    }\n    return ctx.builder.CreateIntToPtr(v, ty);\n}\n\nstatic inline jl_cgval_t ghostValue(jl_value_t *typ)\n{\n    if (typ == jl_bottom_type)\n        return jl_cgval_t(); // Undef{}\n    if (typ == (jl_value_t*)jl_typeofbottom_type) {\n        // normalize TypeofBottom to Type{Union{}}\n        typ = (jl_value_t*)jl_typeofbottom_type->super;\n    }\n    if (jl_is_type_type(typ)) {\n        // replace T::Type{T} with T, by assuming that T must be a leaftype of some sort\n        jl_cgval_t constant(NULL, NULL, true, typ, NULL);\n        constant.constant = jl_tparam0(typ);\n        return constant;\n    }\n    return jl_cgval_t(typ);\n}\nstatic inline jl_cgval_t ghostValue(jl_datatype_t *typ)\n{\n    return ghostValue((jl_value_t*)typ);\n}\n\nstatic inline jl_cgval_t mark_julia_const(jl_value_t *jv)\n{\n    jl_value_t *typ;\n    if (jl_is_type(jv)) {\n        typ = (jl_value_t*)jl_wrap_Type(jv); // TODO: gc-root this?\n    }\n    else {\n        typ = jl_typeof(jv);\n        if (jl_is_datatype_singleton((jl_datatype_t*)typ))\n            return ghostValue(typ);\n    }\n    jl_cgval_t constant(NULL, NULL, true, typ, NULL);\n    constant.constant = jv;\n    return constant;\n}\n\n\nstatic inline jl_cgval_t mark_julia_slot(Value *v, jl_value_t *typ, Value *tindex, MDNode *tbaa)\n{\n    // this enables lazy-copying of immutable values and stack or argument slots\n    assert(tbaa);\n    jl_cgval_t tagval(v, NULL, false, typ, tindex);\n    tagval.tbaa = tbaa;\n    return tagval;\n}\n\nstatic bool valid_as_globalinit(const Value *v) {\n    if (isa<ConstantExpr>(v)) {\n        // llvm can't handle all the things that could be inside a ConstantExpr\n        // (such as addrspacecast), and we don't really mind losing this optimization\n        return false;\n    }\n    if (const auto *CC = dyn_cast<ConstantAggregate>(v)) {\n        for (const Value *elem : CC->operand_values())\n            if (!valid_as_globalinit(elem))\n                return false;\n    }\n    return isa<Constant>(v);\n}\n\nstatic inline jl_cgval_t value_to_pointer(jl_codectx_t &ctx, Value *v, jl_value_t *typ, Value *tindex)\n{\n    Value *loc;\n    if (valid_as_globalinit(v)) { // llvm can't handle all the things that could be inside a ConstantExpr\n        loc = get_pointer_to_constant(ctx.emission_context, cast<Constant>(v), \"_j_const\", *jl_Module);\n    }\n    else {\n        loc = emit_static_alloca(ctx, v->getType());\n        ctx.builder.CreateStore(v, loc);\n    }\n    return mark_julia_slot(loc, typ, tindex, tbaa_stack);\n}\nstatic inline jl_cgval_t value_to_pointer(jl_codectx_t &ctx, const jl_cgval_t &v)\n{\n    if (v.ispointer())\n        return v;\n    return value_to_pointer(ctx, v.V, v.typ, v.TIndex);\n}\n\nstatic inline jl_cgval_t mark_julia_type(jl_codectx_t &ctx, Value *v, bool isboxed, jl_value_t *typ)\n{\n    if (jl_is_datatype(typ) && jl_is_datatype_singleton((jl_datatype_t*)typ)) {\n        // no need to explicitly load/store a constant/ghost value\n        return ghostValue(typ);\n    }\n    if (jl_is_type_type(typ)) {\n        jl_value_t *tp0 = jl_tparam0(typ);\n        if (jl_is_concrete_type(tp0) || tp0 == jl_bottom_type) {\n            // replace T::Type{T} with T\n            return ghostValue(typ);\n        }\n    }\n    Type *T = julia_type_to_llvm(ctx, typ);\n    if (type_is_ghost(T)) {\n        return ghostValue(typ);\n    }\n    if (v && !isboxed && v->getType()->isAggregateType() && !jl_is_vecelement_type(typ) && CountTrackedPointers(v->getType()).count == 0) {\n        // eagerly put this back onto the stack\n        // llvm mem2reg pass will remove this if unneeded\n        return value_to_pointer(ctx, v, typ, NULL);\n    }\n    return jl_cgval_t(v, NULL, isboxed, typ, NULL);\n}\n\nstatic inline jl_cgval_t mark_julia_type(jl_codectx_t &ctx, Value *v, bool isboxed, jl_datatype_t *typ)\n{\n    return mark_julia_type(ctx, v, isboxed, (jl_value_t*)typ);\n}\n\n// see if it might be profitable (and cheap) to change the type of v to typ\nstatic inline jl_cgval_t update_julia_type(jl_codectx_t &ctx, const jl_cgval_t &v, jl_value_t *typ)\n{\n    if (v.typ == typ || v.typ == jl_bottom_type || v.constant || typ == (jl_value_t*)jl_any_type || jl_egal(v.typ, typ))\n        return v; // fast-path\n    if (jl_is_concrete_type(v.typ) && !jl_is_kind(v.typ)) {\n        if (jl_is_concrete_type(typ) && !jl_is_kind(typ)) {\n            // type mismatch: changing from one leaftype to another\n            CreateTrap(ctx.builder);\n            return jl_cgval_t();\n        }\n        return v; // doesn't improve type info\n    }\n    if (v.TIndex) {\n        jl_value_t *utyp = jl_unwrap_unionall(typ);\n        if (jl_is_datatype(utyp)) {\n            bool alwaysboxed;\n            if (jl_is_concrete_type(utyp))\n                alwaysboxed = !jl_is_pointerfree(utyp);\n            else\n                alwaysboxed = !((jl_datatype_t*)utyp)->abstract && ((jl_datatype_t*)utyp)->mutabl;\n            if (alwaysboxed) {\n                // discovered that this union-split type must actually be isboxed\n                if (v.Vboxed) {\n                    return jl_cgval_t(v.Vboxed, nullptr, true, typ, NULL);\n                }\n                else {\n                    // type mismatch (there weren't any boxed values in the union)\n                    CreateTrap(ctx.builder);\n                    return jl_cgval_t();\n                }\n            }\n        }\n        if (!jl_is_concrete_type(typ))\n            return v; // not generally worth trying to change type info (which would require recomputing tindex)\n    }\n    Type *T = julia_type_to_llvm(ctx, typ);\n    if (type_is_ghost(T))\n        return ghostValue(typ);\n    return jl_cgval_t(v, typ, NULL);\n}\n\nstatic jl_cgval_t convert_julia_type(jl_codectx_t &ctx, const jl_cgval_t &v, jl_value_t *typ, Value **skip=nullptr);\n\n// --- allocating local variables ---\n\nstatic jl_sym_t *slot_symbol(jl_codectx_t &ctx, int s)\n{\n    return (jl_sym_t*)jl_array_ptr_ref(ctx.source->slotnames, s);\n}\n\nstatic void store_def_flag(jl_codectx_t &ctx, const jl_varinfo_t &vi, bool val)\n{\n    assert((!vi.boxroot || vi.pTIndex) && \"undef check is null pointer for boxed things\");\n    assert(vi.usedUndef && vi.defFlag && \"undef flag codegen corrupted\");\n    ctx.builder.CreateStore(ConstantInt::get(T_int1, val), vi.defFlag, vi.isVolatile);\n}\n\nstatic void alloc_def_flag(jl_codectx_t &ctx, jl_varinfo_t& vi)\n{\n    assert((!vi.boxroot || vi.pTIndex) && \"undef check is null pointer for boxed things\");\n    if (vi.usedUndef) {\n        vi.defFlag = emit_static_alloca(ctx, T_int1);\n        store_def_flag(ctx, vi, false);\n    }\n}\n\n\n// --- utilities ---\n\nstatic void CreateTrap(IRBuilder<> &irbuilder)\n{\n    Function *f = irbuilder.GetInsertBlock()->getParent();\n    Function *trap_func = Intrinsic::getDeclaration(\n            f->getParent(),\n            Intrinsic::trap);\n    irbuilder.CreateCall(trap_func);\n    irbuilder.CreateUnreachable();\n    BasicBlock *newBB = BasicBlock::Create(irbuilder.getContext(), \"after_noret\", f);\n    irbuilder.SetInsertPoint(newBB);\n}\n\n#if 0 // this code is likely useful, but currently unused\n#ifndef JL_NDEBUG\nstatic void CreateConditionalAbort(IRBuilder<> &irbuilder, Value *test)\n{\n    Function *f = irbuilder.GetInsertBlock()->getParent();\n    BasicBlock *abortBB = BasicBlock::Create(jl_LLVMContext, \"debug_abort\", f);\n    BasicBlock *postBB = BasicBlock::Create(jl_LLVMContext, \"post_abort\", f);\n    irbuilder.CreateCondBr(test, abortBB, postBB);\n    irbuilder.SetInsertPoint(abortBB);\n    Function *trap_func = Intrinsic::getDeclaration(\n            f->getParent(),\n            Intrinsic::trap);\n    irbuilder.CreateCall(trap_func);\n    irbuilder.CreateUnreachable();\n    irbuilder.SetInsertPoint(postBB);\n}\n#endif\n#endif\n\n#include \"cgutils.cpp\"\n\nstatic jl_cgval_t convert_julia_type_union(jl_codectx_t &ctx, const jl_cgval_t &v, jl_value_t *typ, Value **skip)\n{\n    // previous value was a split union, compute new index, or box\n    Value *new_tindex = ConstantInt::get(T_int8, 0x80);\n    SmallBitVector skip_box(1, true);\n    Value *tindex = ctx.builder.CreateAnd(v.TIndex, ConstantInt::get(T_int8, 0x7f));\n    if (jl_is_uniontype(typ)) {\n        // compute the TIndex mapping from v.typ -> typ\n        unsigned counter = 0;\n        for_each_uniontype_small(\n            // for each old union-split value\n            [&](unsigned idx, jl_datatype_t *jt) {\n                unsigned new_idx = get_box_tindex(jt, typ);\n                bool t;\n                if (new_idx) {\n                    // found a matching element,\n                    // match it against either the unboxed index\n                    Value *cmp = ctx.builder.CreateICmpEQ(tindex, ConstantInt::get(T_int8, idx));\n                    new_tindex = ctx.builder.CreateSelect(cmp, ConstantInt::get(T_int8, new_idx), new_tindex);\n                    t = true;\n                }\n                else if (!jl_subtype((jl_value_t*)jt, typ)) {\n                    // new value doesn't need to be boxed\n                    // since it isn't part of the new union\n                    t = true;\n                    if (skip) {\n                        Value *skip1 = ctx.builder.CreateICmpEQ(tindex, ConstantInt::get(T_int8, idx));\n                        *skip = *skip ? ctx.builder.CreateOr(*skip, skip1) : skip1;\n                    }\n                }\n                else {\n                    // will actually need to box this element\n                    // since it appeared as a leaftype in the original type\n                    // but not in the remark type\n                    t = false;\n                }\n                skip_box.resize(idx + 1, t);\n            },\n            v.typ,\n            counter);\n    }\n\n    // some of the values are still unboxed\n    if (!isa<Constant>(new_tindex)) {\n        Value *wasboxed = NULL;\n        // If the old value was boxed and unknown (type tag 0x80),\n        // it is possible that the tag was actually one of the types\n        // that are now explicitly represented. To find out, we need\n        // to compare typeof(v.Vboxed) (i.e. the type of the unknown\n        // value) against all the types that are now explicitly\n        // selected and select the appropriate one as our new tindex.\n        if (v.Vboxed) {\n            wasboxed = ctx.builder.CreateAnd(v.TIndex, ConstantInt::get(T_int8, 0x80));\n            new_tindex = ctx.builder.CreateOr(wasboxed, new_tindex);\n            wasboxed = ctx.builder.CreateICmpNE(wasboxed, ConstantInt::get(T_int8, 0));\n\n            BasicBlock *currBB = ctx.builder.GetInsertBlock();\n\n            // We lazily create a BB for this, once we decide that we\n            // actually need it.\n            Value *union_box_dt = NULL;\n            BasicBlock *union_isaBB = NULL;\n            auto maybe_setup_union_isa = [&]() {\n                if (!union_isaBB) {\n                    union_isaBB = BasicBlock::Create(jl_LLVMContext, \"union_isa\", ctx.f);\n                    ctx.builder.SetInsertPoint(union_isaBB);\n                    union_box_dt = emit_typeof(ctx, v.Vboxed);\n                }\n            };\n\n            // If we don't find a match. The type remains unknown\n            // (0x80). We could use `v.Tindex`, here, since we know\n            // it has to be 0x80, but it seems likely the backend\n            // will like the explicit constant better.\n            Value *union_box_tindex = ConstantInt::get(T_int8, 0x80);\n            unsigned counter = 0;\n            for_each_uniontype_small(\n                // for each new union-split value\n                [&](unsigned idx, jl_datatype_t *jt) {\n                    unsigned old_idx = get_box_tindex(jt, v.typ);\n                    if (old_idx == 0) {\n                        // didn't handle this item before, select its new union index\n                        maybe_setup_union_isa();\n                        Value *cmp = ctx.builder.CreateICmpEQ(track_pjlvalue(ctx, literal_pointer_val(ctx, (jl_value_t*)jt)), union_box_dt);\n                        union_box_tindex = ctx.builder.CreateSelect(cmp, ConstantInt::get(T_int8, 0x80 | idx), union_box_tindex);\n                    }\n                },\n                typ,\n                counter);\n            if (union_box_dt) {\n                BasicBlock *postBB = BasicBlock::Create(jl_LLVMContext, \"post_union_isa\", ctx.f);\n                ctx.builder.CreateBr(postBB);\n                ctx.builder.SetInsertPoint(currBB);\n                Value *wasunknown = ctx.builder.CreateICmpEQ(v.TIndex, ConstantInt::get(T_int8, 0x80));\n                ctx.builder.CreateCondBr(wasunknown, union_isaBB, postBB);\n                ctx.builder.SetInsertPoint(postBB);\n                PHINode *tindex_phi = ctx.builder.CreatePHI(T_int8, 2);\n                tindex_phi->addIncoming(new_tindex, currBB);\n                tindex_phi->addIncoming(union_box_tindex, union_isaBB);\n                new_tindex = tindex_phi;\n            }\n        }\n        if (!skip_box.all()) {\n            // some values weren't unboxed in the new union\n            // box them now (tindex above already selected 0x80 = box for them)\n            Value *boxv = box_union(ctx, v, skip_box);\n            if (v.Vboxed) {\n                // If the value is boxed both before and after, we don't need\n                // to touch it at all. Otherwise we're either transitioning\n                // unboxed->boxed, or leaving an unboxed value in place.\n                Value *isboxed = ctx.builder.CreateICmpNE(\n                    ctx.builder.CreateAnd(new_tindex, ConstantInt::get(T_int8, 0x80)),\n                    ConstantInt::get(T_int8, 0));\n                boxv = ctx.builder.CreateSelect(\n                    ctx.builder.CreateAnd(wasboxed, isboxed), v.Vboxed, boxv);\n            }\n            if (v.V == NULL) {\n                // v.V might be NULL if it was all ghost objects before\n                return jl_cgval_t(boxv, NULL, false, typ, new_tindex);\n            }\n            else {\n                Value *isboxv = ctx.builder.CreateIsNotNull(boxv);\n                Value *slotv;\n                MDNode *tbaa;\n                if (v.ispointer()) {\n                    slotv = v.V;\n                    tbaa = v.tbaa;\n                }\n                else {\n                    slotv = emit_static_alloca(ctx, v.V->getType());\n                    ctx.builder.CreateStore(v.V, slotv);\n                    tbaa = tbaa_stack;\n                }\n                slotv = ctx.builder.CreateSelect(isboxv,\n                            decay_derived(ctx, boxv),\n                            decay_derived(ctx, emit_bitcast(ctx, slotv, boxv->getType())));\n                jl_cgval_t newv = jl_cgval_t(slotv, NULL, false, typ, new_tindex);\n                assert(boxv->getType() == T_prjlvalue);\n                newv.Vboxed = boxv;\n                newv.tbaa = tbaa;\n                return newv;\n            }\n        }\n    }\n    else {\n        return jl_cgval_t(boxed(ctx, v), NULL, true, typ, NULL);\n    }\n    return jl_cgval_t(v, typ, new_tindex);\n}\n\n// given a value marked with type `v.typ`, compute the mapping and/or boxing to return a value of type `typ`\n// TODO: should this set TIndex when trivial (such as 0x80 or concrete types) ?\nstatic jl_cgval_t convert_julia_type(jl_codectx_t &ctx, const jl_cgval_t &v, jl_value_t *typ, Value **skip)\n{\n    if (typ == (jl_value_t*)jl_typeofbottom_type)\n        return ghostValue(typ); // normalize TypeofBottom to Type{Union{}}\n    if (v.typ == typ || v.typ == jl_bottom_type || jl_egal(v.typ, typ))\n        return v; // fast-path\n    Type *T = julia_type_to_llvm(ctx, typ);\n    if (type_is_ghost(T))\n        return ghostValue(typ);\n    Value *new_tindex = NULL;\n    if (jl_is_concrete_type(typ)) {\n        assert(skip == nullptr && \"skip only valid for union type return\");\n        if (v.TIndex && !jl_is_pointerfree(typ)) {\n            // discovered that this union-split type must actually be isboxed\n            if (v.Vboxed) {\n                return jl_cgval_t(v.Vboxed, nullptr, true, typ, NULL);\n            }\n            else {\n                // type mismatch: there weren't any boxed values in the union\n                CreateTrap(ctx.builder);\n                return jl_cgval_t();\n            }\n        }\n        if (jl_is_concrete_type(v.typ) && !jl_is_kind(v.typ)) {\n            if (jl_is_concrete_type(typ) && !jl_is_kind(typ)) {\n                // type mismatch: changing from one leaftype to another\n                CreateTrap(ctx.builder);\n                return jl_cgval_t();\n            }\n        }\n    }\n    else {\n        bool makeboxed = false;\n        if (v.TIndex) {\n            return convert_julia_type_union(ctx, v, typ, skip);\n        }\n        else if (!v.isboxed && jl_is_uniontype(typ)) {\n            // previous value was unboxed (leaftype), statically compute union tindex\n            assert(jl_is_concrete_type(v.typ));\n            unsigned new_idx = get_box_tindex((jl_datatype_t*)v.typ, typ);\n            if (new_idx) {\n                new_tindex = ConstantInt::get(T_int8, new_idx);\n                if (v.V && !v.ispointer()) {\n                    // TODO: remove this branch once all consumers of v.TIndex understand how to handle a non-ispointer value\n                    Value *slotv = emit_static_alloca(ctx, v.V->getType());\n                    ctx.builder.CreateStore(v.V, slotv);\n                    jl_cgval_t newv = jl_cgval_t(slotv, NULL, false, typ, new_tindex);\n                    newv.tbaa = tbaa_stack;\n                    return newv;\n                }\n            }\n            else if (jl_subtype(v.typ, typ)) {\n                makeboxed = true;\n            }\n            else if (skip) {\n                // undef\n                *skip = ConstantInt::get(T_int1, 1);\n                return jl_cgval_t();\n            }\n            else {\n                // unreachable\n                CreateTrap(ctx.builder);\n                return jl_cgval_t();\n            }\n        }\n        else if (!v.isboxed) {\n            makeboxed = true;\n        }\n        if (makeboxed) {\n            // convert to a simple isboxed value\n            return jl_cgval_t(boxed(ctx, v), NULL, true, typ, NULL);\n        }\n    }\n    return jl_cgval_t(v, typ, new_tindex);\n}\n\nstatic void jl_setup_module(Module *m, const jl_cgparams_t *params = &jl_default_cgparams)\n{\n    // Some linkers (*cough* OS X) don't understand DWARF v4, so we use v2 in\n    // imaging mode. The structure of v4 is slightly nicer for debugging JIT\n    // code.\n    if (!m->getModuleFlag(\"Dwarf Version\")) {\n        int dwarf_version = 4;\n#ifdef _OS_DARWIN_\n        if (imaging_mode)\n            dwarf_version = 2;\n#endif\n        m->addModuleFlag(llvm::Module::Warning, \"Dwarf Version\", dwarf_version);\n    }\n    if (!m->getModuleFlag(\"Debug Info Version\"))\n        m->addModuleFlag(llvm::Module::Error, \"Debug Info Version\",\n            llvm::DEBUG_METADATA_VERSION);\n    m->setDataLayout(jl_data_layout);\n    m->setTargetTriple(jl_TargetMachine->getTargetTriple().str());\n}\n\nModule *jl_create_llvm_module(StringRef name)\n{\n    Module *M = new Module(name, jl_LLVMContext);\n    jl_setup_module(M);\n    return M;\n}\n\nstatic void jl_init_function(Function *F)\n{\n    // set any attributes that *must* be set on all functions\n#if defined(_OS_WINDOWS_) && !defined(_CPU_X86_64_)\n    // tell Win32 to realign the stack to the next 16-byte boundary\n    // upon entry to any function. This achieves compatibility\n    // with both MinGW-GCC (which assumes an 16-byte-aligned stack) and\n    // i686 Windows (which uses a 4-byte-aligned stack)\n    AttrBuilder attr;\n    attr.addStackAlignmentAttr(16);\n    F->addAttributes(AttributeList::FunctionIndex, attr);\n#endif\n#if defined(_OS_WINDOWS_) && defined(_CPU_X86_64_)\n    F->setHasUWTable(); // force NeedsWinEH\n#endif\n#ifdef JL_DISABLE_FPO\n#if LLVM_VERSION_MAJOR >= 8\n    F->addFnAttr(\"frame-pointer\", \"all\");\n#else\n    F->addFnAttr(\"no-frame-pointer-elim\", \"true\");\n#endif\n#endif\n}\n\nstatic std::pair<bool, bool> uses_specsig(jl_method_instance_t *lam, jl_value_t *rettype, bool prefer_specsig)\n{\n    size_t nreq = jl_is_method(lam->def.method) ? lam->def.method->nargs : 0;\n    int va = 0;\n    if (nreq > 0 && lam->def.method->isva) {\n        nreq--;\n        va = 1;\n    }\n    jl_value_t *sig = lam->specTypes;\n    bool needsparams = false;\n    if (jl_is_method(lam->def.method)) {\n        if ((size_t)jl_subtype_env_size(lam->def.method->sig) != jl_svec_len(lam->sparam_vals))\n            needsparams = true;\n        for (size_t i = 0; i < jl_svec_len(lam->sparam_vals); ++i) {\n            if (jl_is_typevar(jl_svecref(lam->sparam_vals, i)))\n                needsparams = true;\n        }\n    }\n    if (needsparams)\n        return std::make_pair(false, true);\n    if (sig == (jl_value_t*)jl_anytuple_type)\n        return std::make_pair(false, false);\n    if (!jl_is_datatype(sig))\n        return std::make_pair(false, false);\n    if (jl_nparams(sig) == 0)\n        return std::make_pair(false, false);\n    if (va) {\n        if (jl_is_vararg(jl_tparam(sig, jl_nparams(sig) - 1)))\n            return std::make_pair(false, false);\n    }\n    // not invalid, consider if specialized signature is worthwhile\n    if (prefer_specsig)\n        return std::make_pair(true, false);\n    if (!deserves_retbox(rettype) && !jl_is_datatype_singleton((jl_datatype_t*)rettype))\n        return std::make_pair(true, false);\n    if (jl_is_uniontype(rettype)) {\n        bool allunbox;\n        size_t nbytes, align, min_align;\n        union_alloca_type((jl_uniontype_t*)rettype, allunbox, nbytes, align, min_align);\n        if (nbytes > 0)\n            return std::make_pair(true, false); // some elements of the union could be returned unboxed avoiding allocation\n    }\n    bool allSingleton = true;\n    for (size_t i = 0; i < jl_nparams(sig); i++) {\n        jl_value_t *sigt = jl_tparam(sig, i);\n        bool issing = jl_is_datatype(sigt) && jl_is_datatype_singleton((jl_datatype_t*)sigt);\n        allSingleton &= issing;\n        if (!deserves_argbox(sigt) && !issing) {\n            return std::make_pair(true, false);\n        }\n    }\n    if (allSingleton)\n        return std::make_pair(true, false);\n    return std::make_pair(false, false); // jlcall sig won't require any box allocations\n}\n\n\n// Logging for code coverage and memory allocation\n\nconst int logdata_blocksize = 32; // target getting nearby lines in the same general cache area and reducing calls to malloc by chunking\ntypedef uint64_t logdata_block[logdata_blocksize];\ntypedef StringMap< std::vector<logdata_block*> > logdata_t;\n\nstatic uint64_t *allocLine(std::vector<logdata_block*> &vec, int line)\n{\n    unsigned block = line / logdata_blocksize;\n    line = line % logdata_blocksize;\n    if (vec.size() <= block)\n        vec.resize(block + 1);\n    if (vec[block] == NULL) {\n        vec[block] = (logdata_block*)calloc(1, sizeof(logdata_block));\n    }\n    logdata_block &data = *vec[block];\n    if (data[line] == 0)\n        data[line] = 1;\n    return &data[line];\n}\n\nstatic void visitLine(jl_codectx_t &ctx, std::vector<logdata_block*> &vec, int line, Value *addend, const char* name)\n{\n    uint64_t *ptr = allocLine(vec, line);\n    Value *pv = ConstantExpr::getIntToPtr(\n        ConstantInt::get(T_size, (uintptr_t)ptr),\n        T_pint64);\n    Value *v = ctx.builder.CreateLoad(pv, true, name);\n    v = ctx.builder.CreateAdd(v, addend);\n    ctx.builder.CreateStore(v, pv, true); // volatile, not atomic, so this might be an underestimate,\n                                          // but it's faster this way\n}\n\n// Code coverage\n\nstatic logdata_t coverageData;\n\nstatic void coverageVisitLine(jl_codectx_t &ctx, StringRef filename, int line)\n{\n    assert(!imaging_mode);\n    if (filename == \"\" || filename == \"none\" || filename == \"no file\" || filename == \"<missing>\" || line < 0)\n        return;\n    visitLine(ctx, coverageData[filename], line, ConstantInt::get(T_int64, 1), \"lcnt\");\n}\n\nstatic void coverageAllocLine(StringRef filename, int line)\n{\n    assert(!imaging_mode);\n    if (filename == \"\" || filename == \"none\" || filename == \"no file\" || filename == \"<missing>\" || line < 0)\n        return;\n    allocLine(coverageData[filename], line);\n}\n\n// Memory allocation log (malloc_log)\n\nstatic logdata_t mallocData;\n\nstatic void mallocVisitLine(jl_codectx_t &ctx, StringRef filename, int line, Value *sync)\n{\n    assert(!imaging_mode);\n    if (filename == \"\" || filename == \"none\" || filename == \"no file\" || filename == \"<missing>\" || line < 0)\n        return;\n    Value *addend = sync\n        ? ctx.builder.CreateCall(prepare_call(sync_gc_total_bytes_func), {sync})\n        : ctx.builder.CreateCall(prepare_call(diff_gc_total_bytes_func), {});\n    visitLine(ctx, mallocData[filename], line, addend, \"bytecnt\");\n}\n\n// Resets the malloc counts.\nextern \"C\" JL_DLLEXPORT void jl_clear_malloc_data(void)\n{\n    logdata_t::iterator it = mallocData.begin();\n    for (; it != mallocData.end(); it++) {\n        std::vector<logdata_block*> &bytes = (*it).second;\n        std::vector<logdata_block*>::iterator itb;\n        for (itb = bytes.begin(); itb != bytes.end(); itb++) {\n            if (*itb) {\n                logdata_block &data = **itb;\n                for (int i = 0; i < logdata_blocksize; i++) {\n                    if (data[i] > 0)\n                        data[i] = 1;\n                }\n            }\n        }\n    }\n    jl_gc_sync_total_bytes(0);\n}\n\nstatic void write_log_data(logdata_t &logData, const char *extension)\n{\n    std::string base = std::string(jl_options.julia_bindir);\n    base = base + \"/../share/julia/base/\";\n    logdata_t::iterator it = logData.begin();\n    for (; it != logData.end(); it++) {\n        std::string filename(it->first());\n        std::vector<logdata_block*> &values = it->second;\n        if (!values.empty()) {\n            if (!isabspath(filename.c_str()))\n                filename = base + filename;\n            std::ifstream inf(filename.c_str());\n            if (!inf.is_open())\n                continue;\n            std::string outfile = filename + extension;\n            std::ofstream outf(outfile.c_str(), std::ofstream::trunc | std::ofstream::out | std::ofstream::binary);\n            if (outf.is_open()) {\n                inf.exceptions(std::ifstream::badbit);\n                outf.exceptions(std::ifstream::failbit | std::ifstream::badbit);\n                char line[1024];\n                int l = 1;\n                unsigned block = 0;\n                while (!inf.eof()) {\n                    inf.getline(line, sizeof(line));\n                    if (inf.fail()) {\n                        if (inf.eof())\n                            break; // no content on trailing line\n                        // Read through lines longer than sizeof(line)\n                        inf.clear();\n                        inf.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n                    }\n                    logdata_block *data = NULL;\n                    if (block < values.size()) {\n                        data = values[block];\n                    }\n                    uint64_t value = data ? (*data)[l] : 0;\n                    if (++l >= logdata_blocksize) {\n                        l = 0;\n                        block++;\n                    }\n                    outf.width(9);\n                    if (value == 0)\n                        outf << '-';\n                    else\n                        outf << (value - 1);\n                    outf.width(0);\n                    outf << \" \" << line << '\\n';\n                }\n                outf.close();\n            }\n            inf.close();\n        }\n    }\n}\n\nstatic void write_lcov_data(logdata_t &logData, const std::string &outfile)\n{\n    std::ofstream outf(outfile.c_str(), std::ofstream::ate | std::ofstream::out | std::ofstream::binary);\n    //std::string base = std::string(jl_options.julia_bindir);\n    //base = base + \"/../share/julia/base/\";\n    logdata_t::iterator it = logData.begin();\n    for (; it != logData.end(); it++) {\n        StringRef filename = it->first();\n        const std::vector<logdata_block*> &values = it->second;\n        if (!values.empty()) {\n            outf << \"SF:\" << filename.str() << '\\n';\n            size_t n_covered = 0;\n            size_t n_instrumented = 0;\n            size_t lno = 0;\n            for (auto &itv : values) {\n                if (itv) {\n                    logdata_block &data = *itv;\n                    for (int i = 0; i < logdata_blocksize; i++) {\n                        auto cov = data[i];\n                        if (cov > 0) {\n                            n_instrumented++;\n                            if (cov > 1)\n                                n_covered++;\n                            outf << \"DA:\" << lno << ',' << (cov - 1) << '\\n';\n                        }\n                        lno++;\n                    }\n                }\n                else {\n                    lno += logdata_blocksize;\n                }\n            }\n            outf << \"LH:\" << n_covered << '\\n';\n            outf << \"LF:\" << n_instrumented << '\\n';\n            outf << \"end_of_record\\n\";\n        }\n    }\n    outf.close();\n}\n\nextern \"C\" void jl_write_coverage_data(const char *output)\n{\n    if (output) {\n        StringRef output_pattern(output);\n        if (output_pattern.endswith(\".info\"))\n            write_lcov_data(coverageData, jl_format_filename(output_pattern));\n    }\n    else {\n        std::string stm;\n        raw_string_ostream(stm) << \".\" << jl_getpid() << \".cov\";\n        write_log_data(coverageData, stm.c_str());\n    }\n}\n\nextern \"C\" void jl_write_malloc_log(void)\n{\n    std::string stm;\n    raw_string_ostream(stm) << \".\" << jl_getpid() << \".mem\";\n    write_log_data(mallocData, stm.c_str());\n}\n\n// --- constant determination ---\n\nstatic void show_source_loc(jl_codectx_t &ctx, JL_STREAM *out)\n{\n    jl_printf(out, \"in %s at %s\", ctx.name, ctx.file.str().c_str());\n}\n\nstatic void cg_bdw(jl_codectx_t &ctx, jl_binding_t *b)\n{\n    jl_binding_deprecation_warning(ctx.module, b);\n    if (b->deprecated == 1 && jl_options.depwarn) {\n        show_source_loc(ctx, JL_STDERR);\n        jl_printf(JL_STDERR, \"\\n\");\n    }\n}\n\nstatic jl_value_t *static_apply_type(jl_codectx_t &ctx, const jl_cgval_t *args, size_t nargs)\n{\n    jl_value_t **v = (jl_value_t**)alloca(sizeof(jl_value_t*) * nargs);\n    for (size_t i = 0; i < nargs; i++) {\n        if (!args[i].constant)\n            return NULL;\n        v[i] = args[i].constant;\n    }\n    assert(v[0] == jl_builtin_apply_type);\n    size_t last_age = jl_get_ptls_states()->world_age;\n    // call apply_type, but ignore errors. we know that will work in world 1.\n    jl_get_ptls_states()->world_age = 1;\n    jl_value_t *result;\n    JL_TRY {\n        result = jl_apply(v, nargs);\n    }\n    JL_CATCH {\n        result = NULL;\n    }\n    jl_get_ptls_states()->world_age = last_age;\n    return result;\n}\n\n// try to statically evaluate, NULL if not possible. note that this may allocate, and as\n// such the resulting value should not be embedded directly in the generated code.\nstatic jl_value_t *static_eval(jl_codectx_t &ctx, jl_value_t *ex)\n{\n    if (jl_is_symbol(ex)) {\n        jl_sym_t *sym = (jl_sym_t*)ex;\n        if (jl_is_const(ctx.module, sym))\n            return jl_get_global(ctx.module, sym);\n        return NULL;\n    }\n    if (jl_is_slot(ex) || jl_is_argument(ex))\n        return NULL;\n    if (jl_is_ssavalue(ex)) {\n        ssize_t idx = ((jl_ssavalue_t*)ex)->id - 1;\n        assert(idx >= 0);\n        if (ctx.ssavalue_assigned.at(idx)) {\n            return ctx.SAvalues.at(idx).constant;\n        }\n        return NULL;\n    }\n    if (jl_is_quotenode(ex))\n        return jl_fieldref(ex, 0);\n    if (jl_is_method_instance(ex))\n        return NULL;\n    jl_module_t *m = NULL;\n    jl_sym_t *s = NULL;\n    if (jl_is_globalref(ex)) {\n        s = jl_globalref_name(ex);\n        jl_binding_t *b = jl_get_binding(jl_globalref_mod(ex), s);\n        if (b && b->constp) {\n            if (b->deprecated)\n                cg_bdw(ctx, b);\n            return b->value;\n        }\n        return NULL;\n    }\n    if (jl_is_expr(ex)) {\n        jl_expr_t *e = (jl_expr_t*)ex;\n        if (e->head == call_sym) {\n            jl_value_t *f = static_eval(ctx, jl_exprarg(e, 0));\n            if (f) {\n                if (jl_array_dim0(e->args) == 3 && f == jl_builtin_getfield) {\n                    m = (jl_module_t*)static_eval(ctx, jl_exprarg(e, 1));\n                    // Check the tag before evaluating `s` so that a value of random\n                    // type won't be corrupted.\n                    if (!m || !jl_is_module(m))\n                        return NULL;\n                    // Assumes that the module is rooted somewhere.\n                    s = (jl_sym_t*)static_eval(ctx, jl_exprarg(e, 2));\n                    if (s && jl_is_symbol(s)) {\n                        jl_binding_t *b = jl_get_binding(m, s);\n                        if (b && b->constp) {\n                            if (b->deprecated)\n                                cg_bdw(ctx, b);\n                            return b->value;\n                        }\n                    }\n                }\n                else if (f==jl_builtin_tuple || f==jl_builtin_apply_type) {\n                    size_t i;\n                    size_t n = jl_array_dim0(e->args)-1;\n                    if (n==0 && f==jl_builtin_tuple) return (jl_value_t*)jl_emptytuple;\n                    jl_value_t **v;\n                    JL_GC_PUSHARGS(v, n+1);\n                    v[0] = f;\n                    for (i = 0; i < n; i++) {\n                        v[i+1] = static_eval(ctx, jl_exprarg(e, i+1));\n                        if (v[i+1] == NULL) {\n                            JL_GC_POP();\n                            return NULL;\n                        }\n                    }\n                    size_t last_age = jl_get_ptls_states()->world_age;\n                    // here we know we're calling specific builtin functions that work in world 1.\n                    jl_get_ptls_states()->world_age = 1;\n                    jl_value_t *result;\n                    JL_TRY {\n                        result = jl_apply(v, n+1);\n                    }\n                    JL_CATCH {\n                        result = NULL;\n                    }\n                    jl_get_ptls_states()->world_age = last_age;\n                    JL_GC_POP();\n                    return result;\n                }\n            }\n        }\n        else if (e->head == static_parameter_sym) {\n            size_t idx = jl_unbox_long(jl_exprarg(e, 0));\n            if (idx <= jl_svec_len(ctx.linfo->sparam_vals)) {\n                jl_value_t *e = jl_svecref(ctx.linfo->sparam_vals, idx - 1);\n                if (jl_is_typevar(e))\n                    return NULL;\n                return e;\n            }\n        }\n        return NULL;\n    }\n    return ex;\n}\n\nstatic bool slot_eq(jl_value_t *e, int sl)\n{\n    return (jl_is_slot(e) || jl_is_argument(e)) && jl_slot_number(e)-1 == sl;\n}\n\n// --- code gen for intrinsic functions ---\n\n#include \"intrinsics.cpp\"\n\n// --- find volatile variables ---\n\n// assigned in a try block and used outside that try block\n\nstatic bool local_var_occurs(jl_value_t *e, int sl)\n{\n    if (slot_eq(e, sl)) {\n        return true;\n    }\n    else if (jl_is_expr(e)) {\n        jl_expr_t *ex = (jl_expr_t*)e;\n        size_t alength = jl_array_dim0(ex->args);\n        for(int i=0; i < (int)alength; i++) {\n            if (local_var_occurs(jl_exprarg(ex,i),sl))\n                return true;\n        }\n    }\n    else if (jl_is_returnnode(e)) {\n        jl_value_t *retexpr = jl_returnnode_value(e);\n        if (retexpr != NULL)\n            return local_var_occurs(retexpr, sl);\n    }\n    else if (jl_is_gotoifnot(e)) {\n        return local_var_occurs(jl_gotoifnot_cond(e), sl);\n    }\n    return false;\n}\n\nstatic std::set<int> assigned_in_try(jl_array_t *stmts, int s, long l)\n{\n    std::set<int> av;\n    for(int i=s; i <= l; i++) {\n        jl_value_t *st = jl_array_ptr_ref(stmts,i);\n        if (jl_is_expr(st)) {\n            if (((jl_expr_t*)st)->head == assign_sym) {\n                jl_value_t *ar = jl_exprarg(st, 0);\n                if (jl_is_slot(ar)) {\n                    av.insert(jl_slot_number(ar)-1);\n                }\n            }\n        }\n    }\n    return av;\n}\n\nstatic void mark_volatile_vars(jl_array_t *stmts, std::vector<jl_varinfo_t> &slots)\n{\n    size_t slength = jl_array_dim0(stmts);\n    for (int i = 0; i < (int)slength; i++) {\n        jl_value_t *st = jl_array_ptr_ref(stmts, i);\n        if (jl_is_expr(st)) {\n            if (((jl_expr_t*)st)->head == enter_sym) {\n                int last = jl_unbox_long(jl_exprarg(st, 0));\n                std::set<int> as = assigned_in_try(stmts, i + 1, last);\n                for (int j = 0; j < (int)slength; j++) {\n                    if (j < i || j > last) {\n                        std::set<int>::iterator it = as.begin();\n                        for (; it != as.end(); it++) {\n                            if (local_var_occurs(jl_array_ptr_ref(stmts, j), *it)) {\n                                jl_varinfo_t &vi = slots[*it];\n                                vi.isVolatile = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n// --- use analysis ---\n\n// a very simple, conservative use analysis\n// to eagerly remove slot assignments that are never read from\nstatic void simple_use_analysis(jl_codectx_t &ctx, jl_value_t *expr)\n{\n    if (jl_is_slot(expr) || jl_is_argument(expr)) {\n        int i = jl_slot_number(expr) - 1;\n        ctx.slots[i].used = true;\n    }\n    else if (jl_is_expr(expr)) {\n        jl_expr_t *e = (jl_expr_t*)expr;\n        if (e->head == method_sym) {\n            simple_use_analysis(ctx, jl_exprarg(e, 0));\n            if (jl_expr_nargs(e) > 1) {\n                simple_use_analysis(ctx, jl_exprarg(e, 1));\n                simple_use_analysis(ctx, jl_exprarg(e, 2));\n            }\n        }\n        else if (e->head == assign_sym) {\n            // don't consider assignment LHS as a variable \"use\"\n            simple_use_analysis(ctx, jl_exprarg(e, 1));\n        }\n        else {\n            size_t i, elen = jl_array_dim0(e->args);\n            for (i = 0; i < elen; i++) {\n                simple_use_analysis(ctx, jl_exprarg(e, i));\n            }\n        }\n    }\n    else if (jl_is_returnnode(expr)) {\n        jl_value_t *retexpr = jl_returnnode_value(expr);\n        if (retexpr != NULL)\n            simple_use_analysis(ctx, retexpr);\n    }\n    else if (jl_is_gotoifnot(expr)) {\n        simple_use_analysis(ctx, jl_gotoifnot_cond(expr));\n    }\n    else if (jl_is_pinode(expr)) {\n        simple_use_analysis(ctx, jl_fieldref_noalloc(expr, 0));\n    }\n    else if (jl_is_upsilonnode(expr)) {\n        jl_value_t *val = jl_fieldref_noalloc(expr, 0);\n        if (val)\n            simple_use_analysis(ctx, val);\n    }\n    else if (jl_is_phicnode(expr)) {\n        jl_array_t *values = (jl_array_t*)jl_fieldref_noalloc(expr, 0);\n        size_t i, elen = jl_array_len(values);\n        for (i = 0; i < elen; i++) {\n            jl_value_t *v = jl_array_ptr_ref(values, i);\n            simple_use_analysis(ctx, v);\n        }\n    }\n    else if (jl_is_phinode(expr)) {\n        jl_array_t *values = (jl_array_t*)jl_fieldref_noalloc(expr, 1);\n        size_t i, elen = jl_array_len(values);\n        for (i = 0; i < elen; i++) {\n            jl_value_t *v = jl_array_ptr_ref(values, i);\n            if (v)\n                simple_use_analysis(ctx, v);\n        }\n    }\n}\n\n// --- gc root utils ---\n\n// ---- Get Element Pointer (GEP) instructions within the GC frame ----\n\nstatic void jl_add_method_root(jl_codectx_t &ctx, jl_value_t *val)\n{\n    if (jl_is_concrete_type(val) || jl_is_bool(val) || jl_is_symbol(val) || val == jl_nothing ||\n            val == (jl_value_t*)jl_any_type || val == (jl_value_t*)jl_bottom_type || val == (jl_value_t*)jl_core_module)\n        return;\n    JL_GC_PUSH1(&val);\n    if (ctx.roots == NULL) {\n        ctx.roots = jl_alloc_vec_any(1);\n        jl_array_ptr_set(ctx.roots, 0, val);\n    }\n    else {\n        size_t rlen = jl_array_dim0(ctx.roots);\n        for (size_t i = 0; i < rlen; i++) {\n            if (jl_array_ptr_ref(ctx.roots,i) == val) {\n                JL_GC_POP();\n                return;\n            }\n        }\n        jl_array_ptr_1d_push(ctx.roots, val);\n    }\n    JL_GC_POP();\n}\n\n// --- generating function calls ---\n\nstatic jl_cgval_t emit_globalref(jl_codectx_t &ctx, jl_module_t *mod, jl_sym_t *name)\n{\n    jl_binding_t *bnd = NULL;\n    Value *bp = global_binding_pointer(ctx, mod, name, &bnd, false);\n    if (bnd && bnd->value != NULL) {\n        if (bnd->constp) {\n            return mark_julia_const(bnd->value);\n        }\n        LoadInst *v = ctx.builder.CreateAlignedLoad(T_prjlvalue, bp, Align(sizeof(void*)));\n        v->setOrdering(AtomicOrdering::Unordered);\n        tbaa_decorate(tbaa_binding, v);\n        return mark_julia_type(ctx, v, true, (jl_value_t*)jl_any_type);\n    }\n    // todo: use type info to avoid undef check\n    return emit_checked_var(ctx, bp, name, false, tbaa_binding);\n}\n\nstatic jl_cgval_t emit_getfield(jl_codectx_t &ctx, const jl_cgval_t &strct, jl_sym_t *name)\n{\n    if (strct.constant && jl_is_module(strct.constant))\n        return emit_globalref(ctx, (jl_module_t*)strct.constant, name);\n\n    jl_datatype_t *sty = (jl_datatype_t*)strct.typ;\n    if (jl_is_type_type((jl_value_t*)sty) && jl_is_concrete_type(jl_tparam0(sty)))\n        sty = (jl_datatype_t*)jl_typeof(jl_tparam0(sty));\n    sty = (jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)sty);\n    if (jl_is_structtype(sty) && sty != jl_module_type && sty->layout) {\n        unsigned idx = jl_field_index(sty, name, 0);\n        if (idx != (unsigned)-1) {\n            return emit_getfield_knownidx(ctx, strct, idx, sty);\n        }\n    }\n    // TODO: attempt better codegen for approximate types, if the types\n    // and offsets of some fields are independent of parameters.\n\n    // TODO: generic getfield func with more efficient calling convention\n    jl_cgval_t myargs_array[2] = {\n        strct,\n        mark_julia_const((jl_value_t*)name)\n    };\n    Value *result = emit_jlcall(ctx, jlgetfield_func, V_rnull, myargs_array, 2, JLCALL_F_CC);\n    return mark_julia_type(ctx, result, true, jl_any_type);\n}\n\ntemplate<typename Func>\nstatic Value *emit_guarded_test(jl_codectx_t &ctx, Value *ifnot, Constant *defval, Func &&func)\n{\n    if (auto Cond = dyn_cast<ConstantInt>(ifnot)) {\n        if (Cond->isZero())\n            return defval;\n        return func();\n    }\n    BasicBlock *currBB = ctx.builder.GetInsertBlock();\n    BasicBlock *passBB = BasicBlock::Create(jl_LLVMContext, \"guard_pass\", ctx.f);\n    BasicBlock *exitBB = BasicBlock::Create(jl_LLVMContext, \"guard_exit\", ctx.f);\n    ctx.builder.CreateCondBr(ifnot, passBB, exitBB);\n    ctx.builder.SetInsertPoint(passBB);\n    auto res = func();\n    passBB = ctx.builder.GetInsertBlock();\n    ctx.builder.CreateBr(exitBB);\n    ctx.builder.SetInsertPoint(exitBB);\n    if (defval == nullptr)\n        return nullptr;\n    PHINode *phi = ctx.builder.CreatePHI(defval->getType(), 2);\n    phi->addIncoming(defval, currBB);\n    phi->addIncoming(res, passBB);\n    return phi;\n}\n\ntemplate<typename Func>\nstatic Value *emit_guarded_test(jl_codectx_t &ctx, Value *ifnot, bool defval, Func &&func)\n{\n    return emit_guarded_test(ctx, ifnot, ConstantInt::get(T_int1, defval), func);\n}\n\ntemplate<typename Func>\nstatic Value *emit_nullcheck_guard(jl_codectx_t &ctx, Value *nullcheck, Func &&func)\n{\n    if (!nullcheck)\n        return func();\n    return emit_guarded_test(ctx, null_pointer_cmp(ctx, nullcheck), false, func);\n}\n\ntemplate<typename Func>\nstatic Value *emit_nullcheck_guard2(jl_codectx_t &ctx, Value *nullcheck1,\n                                    Value *nullcheck2, Func &&func)\n{\n    if (!nullcheck1)\n        return emit_nullcheck_guard(ctx, nullcheck2, func);\n    if (!nullcheck2)\n        return emit_nullcheck_guard(ctx, nullcheck1, func);\n    nullcheck1 = null_pointer_cmp(ctx, nullcheck1);\n    nullcheck2 = null_pointer_cmp(ctx, nullcheck2);\n    // If both are NULL, return true.\n    return emit_guarded_test(ctx, ctx.builder.CreateOr(nullcheck1, nullcheck2), true, [&] {\n        return emit_guarded_test(ctx, ctx.builder.CreateAnd(nullcheck1, nullcheck2),\n                                 false, func);\n    });\n}\n\nstatic Value *emit_box_compare(jl_codectx_t &ctx, const jl_cgval_t &arg1, const jl_cgval_t &arg2,\n                               Value *nullcheck1, Value *nullcheck2)\n{\n    if (jl_pointer_egal(arg1.typ) || jl_pointer_egal(arg2.typ)) {\n        Value *varg1 = arg1.constant ? literal_pointer_val(ctx, arg1.constant) : arg1.V;\n        Value *varg2 = arg2.constant ? literal_pointer_val(ctx, arg2.constant) : arg2.V;\n        assert(varg1 && varg2 && (arg1.isboxed || arg1.TIndex) && (arg2.isboxed || arg2.TIndex) &&\n                \"Only boxed types are valid for pointer comparison.\");\n        varg1 = maybe_decay_tracked(ctx, varg1);\n        varg2 = maybe_decay_tracked(ctx, varg2);\n        if (cast<PointerType>(varg1->getType())->getAddressSpace() != cast<PointerType>(varg2->getType())->getAddressSpace()) {\n            varg1 = decay_derived(ctx, varg1);\n            varg2 = decay_derived(ctx, varg2);\n        }\n        return ctx.builder.CreateICmpEQ(emit_bitcast(ctx, varg1, T_pint8),\n                                        emit_bitcast(ctx, varg2, T_pint8));\n    }\n\n    return emit_nullcheck_guard2(ctx, nullcheck1, nullcheck2, [&] {\n        Value *varg1 = mark_callee_rooted(ctx, boxed(ctx, arg1));\n        Value *varg2 = mark_callee_rooted(ctx, boxed(ctx, arg2));\n        return ctx.builder.CreateTrunc(ctx.builder.CreateCall(prepare_call(jlegal_func),\n                                                              {varg1, varg2}), T_int1);\n    });\n}\n\nstatic Value *emit_bits_compare(jl_codectx_t &ctx, jl_cgval_t arg1, jl_cgval_t arg2);\nstatic Value *emit_f_is(jl_codectx_t &ctx, const jl_cgval_t &arg1, const jl_cgval_t &arg2,\n                        Value *nullcheck1 = nullptr, Value *nullcheck2 = nullptr);\n\nstatic Value *emit_bitsunion_compare(jl_codectx_t &ctx, const jl_cgval_t &arg1, const jl_cgval_t &arg2)\n{\n    assert(jl_egal(arg1.typ, arg2.typ) && arg1.TIndex && arg2.TIndex && jl_is_uniontype(arg1.typ) && \"unimplemented\");\n    Value *tindex = arg1.TIndex;\n    BasicBlock *defaultBB = BasicBlock::Create(jl_LLVMContext, \"unionbits_is_boxed\", ctx.f);\n    SwitchInst *switchInst = ctx.builder.CreateSwitch(tindex, defaultBB);\n    BasicBlock *postBB = BasicBlock::Create(jl_LLVMContext, \"post_unionbits_is\", ctx.f);\n    ctx.builder.SetInsertPoint(postBB);\n    PHINode *phi = ctx.builder.CreatePHI(T_int1, 2);\n    unsigned counter = 0;\n    bool allunboxed = for_each_uniontype_small(\n        [&](unsigned idx, jl_datatype_t *jt) {\n            BasicBlock *tempBB = BasicBlock::Create(jl_LLVMContext, \"unionbits_is\", ctx.f);\n            ctx.builder.SetInsertPoint(tempBB);\n            switchInst->addCase(ConstantInt::get(T_int8, idx), tempBB);\n            jl_cgval_t sel_arg1(arg1, (jl_value_t*)jt, NULL);\n            jl_cgval_t sel_arg2(arg2, (jl_value_t*)jt, NULL);\n            Value *cmp = emit_bits_compare(ctx, sel_arg1, sel_arg2);\n            tempBB = ctx.builder.GetInsertBlock(); // could have changed\n            phi->addIncoming(cmp, tempBB);\n            ctx.builder.CreateBr(postBB);\n        },\n        arg1.typ,\n        counter);\n    assert(allunboxed); (void)allunboxed;\n    ctx.builder.SetInsertPoint(defaultBB);\n    Function *trap_func = Intrinsic::getDeclaration(\n        ctx.f->getParent(),\n        Intrinsic::trap);\n    ctx.builder.CreateCall(trap_func);\n    ctx.builder.CreateUnreachable();\n    ctx.builder.SetInsertPoint(postBB);\n    return ctx.builder.CreateAnd(phi, ctx.builder.CreateICmpEQ(arg1.TIndex, arg2.TIndex));\n}\n\nstatic Value *emit_bits_compare(jl_codectx_t &ctx, jl_cgval_t arg1, jl_cgval_t arg2)\n{\n    bool isboxed;\n    Type *at = julia_type_to_llvm(ctx, arg1.typ, &isboxed);\n    assert(jl_is_datatype(arg1.typ) && arg1.typ == arg2.typ && !isboxed);\n\n    if (type_is_ghost(at))\n        return ConstantInt::get(T_int1, 1);\n\n    if (at->isIntegerTy() || at->isPointerTy() || at->isFloatingPointTy()) {\n        Type *at_int = INTT(at);\n        Value *varg1 = emit_unbox(ctx, at_int, arg1, arg1.typ);\n        Value *varg2 = emit_unbox(ctx, at_int, arg2, arg2.typ);\n        return ctx.builder.CreateICmpEQ(varg1, varg2);\n    }\n\n    if (at->isVectorTy()) {\n        jl_svec_t *types = ((jl_datatype_t*)arg1.typ)->types;\n        Value *answer = ConstantInt::get(T_int1, 1);\n        Value *varg1 = emit_unbox(ctx, at, arg1, arg1.typ);\n        Value *varg2 = emit_unbox(ctx, at, arg2, arg2.typ);\n        for (size_t i = 0, l = jl_svec_len(types); i < l; i++) {\n            jl_value_t *fldty = jl_svecref(types, i);\n            Value *subAns, *fld1, *fld2;\n            fld1 = ctx.builder.CreateExtractElement(varg1, ConstantInt::get(T_int32, i)),\n            fld2 = ctx.builder.CreateExtractElement(varg2, ConstantInt::get(T_int32, i)),\n            subAns = emit_bits_compare(ctx,\n                    mark_julia_type(ctx, fld1, false, fldty),\n                    mark_julia_type(ctx, fld2, false, fldty));\n            answer = ctx.builder.CreateAnd(answer, subAns);\n        }\n        return answer;\n    }\n\n    if (at->isAggregateType()) { // Struct or Array\n        jl_datatype_t *sty = (jl_datatype_t*)arg1.typ;\n        size_t sz = jl_datatype_size(sty);\n        if (sz > 512 && !sty->layout->haspadding) {\n            Value *varg1 = arg1.ispointer() ? maybe_decay_tracked(ctx, data_pointer(ctx, arg1)) :\n                value_to_pointer(ctx, arg1).V;\n            Value *varg2 = arg2.ispointer() ? maybe_decay_tracked(ctx, data_pointer(ctx, arg2)) :\n                value_to_pointer(ctx, arg2).V;\n            varg1 = emit_pointer_from_objref(ctx, varg1);\n            varg2 = emit_pointer_from_objref(ctx, varg2);\n            Value *gc_uses[2];\n            int nroots = 0;\n            if ((gc_uses[nroots] = get_gc_root_for(arg1)))\n                nroots++;\n            if ((gc_uses[nroots] = get_gc_root_for(arg2)))\n                nroots++;\n            OperandBundleDef OpBundle(\"jl_roots\", makeArrayRef(gc_uses, nroots));\n            auto answer = ctx.builder.CreateCall(prepare_call(memcmp_func), {\n                        ctx.builder.CreateBitCast(varg1, T_pint8),\n                        ctx.builder.CreateBitCast(varg2, T_pint8),\n                        ConstantInt::get(T_size, sz) },\n                    ArrayRef<OperandBundleDef>(&OpBundle, nroots ? 1 : 0));\n            MDNode *tbaa = nullptr;\n            if (!arg1.tbaa) {\n                tbaa = arg2.tbaa;\n            }\n            else if (!arg2.tbaa) {\n                tbaa = arg1.tbaa;\n            }\n            else {\n                tbaa = MDNode::getMostGenericTBAA(arg1.tbaa, arg2.tbaa);\n            }\n            if (tbaa)\n                tbaa_decorate(tbaa, answer);\n            return ctx.builder.CreateICmpEQ(answer, ConstantInt::get(T_int32, 0));\n        }\n        else {\n            jl_svec_t *types = sty->types;\n            Value *answer = ConstantInt::get(T_int1, 1);\n            for (size_t i = 0, l = jl_svec_len(types); i < l; i++) {\n                jl_value_t *fldty = jl_svecref(types, i);\n                if (type_is_ghost(julia_type_to_llvm(ctx, fldty)))\n                    continue;\n                Value *nullcheck1 = nullptr;\n                Value *nullcheck2 = nullptr;\n                auto fld1 = emit_getfield_knownidx(ctx, arg1, i, sty, &nullcheck1);\n                auto fld2 = emit_getfield_knownidx(ctx, arg2, i, sty, &nullcheck2);\n                Value *fld_answer;\n                if (jl_field_isptr(sty, i) && jl_is_concrete_immutable(fldty)) {\n                    // concrete immutables that are !isinlinealloc might be reference cycles\n                    // issue #37872\n                    fld_answer = emit_box_compare(ctx, fld1, fld2, nullcheck1, nullcheck2);\n                }\n                else {\n                    fld_answer = emit_f_is(ctx, fld1, fld2, nullcheck1, nullcheck2);\n                }\n                answer = ctx.builder.CreateAnd(answer, fld_answer);\n            }\n            return answer;\n        }\n    }\n    assert(0 && \"what is this llvm type?\");\n    abort();\n}\n\n// emit code for is (===).\n// If either `nullcheck1` or `nullcheck2` are non-NULL, they are pointer values\n// representing the undef-ness of `arg1` and `arg2`.\n// This can only happen when comparing two fields of the same time and the result should be\n// true if both are NULL\nstatic Value *emit_f_is(jl_codectx_t &ctx, const jl_cgval_t &arg1, const jl_cgval_t &arg2,\n                        Value *nullcheck1, Value *nullcheck2)\n{\n    // handle simple static expressions with no side-effects\n    if (arg1.constant && arg2.constant)\n        return ConstantInt::get(T_int1, jl_egal(arg1.constant, arg2.constant));\n\n    jl_value_t *rt1 = arg1.typ;\n    jl_value_t *rt2 = arg2.typ;\n    if (jl_is_concrete_type(rt1) && jl_is_concrete_type(rt2) && !jl_is_kind(rt1) && !jl_is_kind(rt2) && rt1 != rt2) {\n        // disjoint concrete leaf types are never equal (quick test)\n        return ConstantInt::get(T_int1, 0);\n    }\n\n    if (arg1.isghost || arg2.isghost || arg1.constant == jl_bottom_type ||\n        arg2.constant == jl_bottom_type) {\n        // comparing to a singleton object, special case for value `jl_bottom_type`\n        // since it is normalized to `::Type{Union{}}` instead...\n        if (arg1.TIndex)\n            return emit_nullcheck_guard(ctx, nullcheck1, [&] {\n                return emit_isa(ctx, arg1, rt2, NULL).first; // rt2 is a singleton type\n            });\n        if (arg2.TIndex)\n            return emit_nullcheck_guard(ctx, nullcheck2, [&] {\n                return emit_isa(ctx, arg2, rt1, NULL).first; // rt1 is a singleton type\n            });\n        // rooting these values isn't needed since we won't load this pointer\n        // and we know at least one of them is a unique Singleton\n        // which is already enough to ensure pointer uniqueness for this test\n        // even if the other pointer managed to get garbage collected\n        return ctx.builder.CreateICmpEQ(\n            mark_callee_rooted(ctx, boxed(ctx, arg1)),\n            mark_callee_rooted(ctx, boxed(ctx, arg2)));\n    }\n\n    if (jl_type_intersection(rt1, rt2) == (jl_value_t*)jl_bottom_type) // types are disjoint (exhaustive test)\n        return ConstantInt::get(T_int1, 0);\n\n    // If both sides are boxed or can be trivially boxed,\n    // we'll prefer to do a pointer check.\n    // At this point, we know that at least one of the arguments isn't a constant\n    // so a runtime content check will involve at least one load from the\n    // pointer (and likely a type check)\n    // so a pointer comparison should be no worse than that even in imaging mode\n    // when the constant pointer has to be loaded.\n    if ((arg1.V || arg1.constant) && (arg2.V || arg2.constant) &&\n        (jl_pointer_egal(rt1) || jl_pointer_egal(rt2)) &&\n        // jl_pointer_egal returns true for Bool, which is not helpful here\n        (rt1 != (jl_value_t*)jl_bool_type || rt2 != (jl_value_t*)jl_bool_type))\n        return ctx.builder.CreateICmpEQ(boxed(ctx, arg1), boxed(ctx, arg2));\n\n    bool justbits1 = jl_is_concrete_immutable(rt1);\n    bool justbits2 = jl_is_concrete_immutable(rt2);\n    if (justbits1 || justbits2) { // whether this type is unique'd by value\n        return emit_nullcheck_guard2(ctx, nullcheck1, nullcheck2, [&] () -> Value* {\n            jl_value_t *typ = justbits1 ? rt1 : rt2;\n            if (rt1 == rt2)\n                return emit_bits_compare(ctx, arg1, arg2);\n            Value *same_type = (typ == rt2) ? emit_isa(ctx, arg1, typ, NULL).first :\n                emit_isa(ctx, arg2, typ, NULL).first;\n            BasicBlock *currBB = ctx.builder.GetInsertBlock();\n            BasicBlock *isaBB = BasicBlock::Create(jl_LLVMContext, \"is\", ctx.f);\n            BasicBlock *postBB = BasicBlock::Create(jl_LLVMContext, \"post_is\", ctx.f);\n            ctx.builder.CreateCondBr(same_type, isaBB, postBB);\n            ctx.builder.SetInsertPoint(isaBB);\n            Value *bitcmp = emit_bits_compare(ctx, jl_cgval_t(arg1, typ, NULL),\n                                              jl_cgval_t(arg2, typ, NULL));\n            isaBB = ctx.builder.GetInsertBlock(); // might have changed\n            ctx.builder.CreateBr(postBB);\n            ctx.builder.SetInsertPoint(postBB);\n            PHINode *cmp = ctx.builder.CreatePHI(T_int1, 2);\n            cmp->addIncoming(ConstantInt::get(T_int1, 0), currBB);\n            cmp->addIncoming(bitcmp, isaBB);\n            return cmp;\n        });\n    }\n\n    // TODO: handle the case where arg1.typ != arg2.typ, or when one of these isn't union,\n    //       or when the union can be pointer\n    if (arg1.TIndex && arg2.TIndex && jl_egal(arg1.typ, arg2.typ) &&\n        jl_is_uniontype(arg1.typ) && is_uniontype_allunboxed(arg1.typ))\n        return emit_nullcheck_guard2(ctx, nullcheck1, nullcheck2, [&] {\n            return emit_bitsunion_compare(ctx, arg1, arg2);\n        });\n\n    return emit_box_compare(ctx, arg1, arg2, nullcheck1, nullcheck2);\n}\n\nstatic std::pair<std::unique_ptr<Module>, jl_llvm_functions_t>\n    emit_function(\n        jl_method_instance_t *lam,\n        jl_code_info_t *src,\n        jl_value_t *jlrettype,\n        jl_codegen_params_t &params,\n        bool vaOverride = false);\n\nstatic bool emit_builtin_call(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n                              const jl_cgval_t *argv, size_t nargs, jl_value_t *rt,\n                              jl_expr_t *ex)\n// returns true if the call has been handled\n{\n    if (f == jl_builtin_is && nargs == 2) {\n        // emit comparison test\n        Value *ans = emit_f_is(ctx, argv[1], argv[2]);\n        *ret = mark_julia_type(ctx, ctx.builder.CreateZExt(ans, T_int8), false, jl_bool_type);\n        return true;\n    }\n\n    else if (f == jl_builtin_typeof && nargs == 1) {\n        *ret = emit_typeof(ctx, argv[1]);\n        return true;\n    }\n\n    else if (f == jl_builtin_typeassert && nargs == 2) {\n        const jl_cgval_t &arg = argv[1];\n        const jl_cgval_t &ty = argv[2];\n        if (jl_is_type_type(ty.typ) && !jl_has_free_typevars(ty.typ)) {\n            jl_value_t *tp0 = jl_tparam0(ty.typ);\n            emit_typecheck(ctx, arg, tp0, \"typeassert\");\n            *ret = arg;\n            return true;\n        }\n        if (jl_subtype(ty.typ, (jl_value_t*)jl_type_type)) {\n            Value *rt_arg = boxed(ctx, arg);\n            Value *rt_ty = boxed(ctx, ty);\n            ctx.builder.CreateCall(prepare_call(jltypeassert_func), {rt_arg, rt_ty});\n            *ret = arg;\n            return true;\n        }\n    }\n\n    else if (f == jl_builtin_isa && nargs == 2) {\n        const jl_cgval_t &arg = argv[1];\n        const jl_cgval_t &ty = argv[2];\n        if (jl_is_type_type(ty.typ) && !jl_has_free_typevars(ty.typ)) {\n            jl_value_t *tp0 = jl_tparam0(ty.typ);\n            Value *isa_result = emit_isa(ctx, arg, tp0, NULL).first;\n            if (isa_result->getType() == T_int1)\n                isa_result = ctx.builder.CreateZExt(isa_result, T_int8);\n            *ret = mark_julia_type(ctx, isa_result, false, jl_bool_type);\n            return true;\n        }\n    }\n\n    else if (f == jl_builtin_issubtype && nargs == 2) {\n        const jl_cgval_t &ta = argv[1];\n        const jl_cgval_t &tb = argv[2];\n        if (jl_is_type_type(ta.typ) && !jl_has_free_typevars(ta.typ) &&\n            jl_is_type_type(tb.typ) && !jl_has_free_typevars(tb.typ)) {\n            int issub = jl_subtype(jl_tparam0(ta.typ), jl_tparam0(tb.typ));\n            *ret = mark_julia_type(ctx, ConstantInt::get(T_int8, issub), false, jl_bool_type);\n            return true;\n        }\n    }\n\n    else if ((f == jl_builtin__apply_iterate && nargs == 3) && ctx.vaSlot > 0) {\n        // turn Core._apply_iterate(iter, f, Tuple) ==> f(Tuple...) using the jlcall calling convention if Tuple is the va allocation\n        if (LoadInst *load = dyn_cast_or_null<LoadInst>(argv[3].V)) {\n            if (load->getPointerOperand() == ctx.slots[ctx.vaSlot].boxroot && ctx.argArray) {\n                Value *theF = boxed(ctx, argv[2]);\n                Value *nva = emit_n_varargs(ctx);\n#ifdef _P64\n                nva = ctx.builder.CreateTrunc(nva, T_int32);\n#endif\n                Value *theArgs = ctx.builder.CreateInBoundsGEP(T_prjlvalue, ctx.argArray, ConstantInt::get(T_size, ctx.nReqArgs));\n                Value *r = ctx.builder.CreateCall(prepare_call(jlapplygeneric_func), { theF, theArgs, nva });\n                *ret = mark_julia_type(ctx, r, true, jl_any_type);\n                return true;\n            }\n        }\n    }\n\n    else if (f == jl_builtin_tuple) {\n        if (nargs == 0) {\n            *ret = ghostValue(jl_emptytuple_type);\n            return true;\n        }\n        if (jl_is_tuple_type(rt) && jl_is_concrete_type(rt) && nargs == jl_datatype_nfields(rt)) {\n            *ret = emit_new_struct(ctx, rt, nargs, &argv[1]);\n            return true;\n        }\n    }\n\n    else if (f == jl_builtin_throw && nargs == 1) {\n        Value *arg1 = boxed(ctx, argv[1]);\n        raise_exception(ctx, arg1);\n        *ret = jl_cgval_t();\n        return true;\n    }\n\n    else if (f == jl_builtin_arraysize && nargs == 2) {\n        const jl_cgval_t &ary = argv[1];\n        const jl_cgval_t &idx = argv[2];\n        jl_value_t *aty = jl_unwrap_unionall(ary.typ);\n        if (jl_is_array_type(aty) && idx.typ == (jl_value_t*)jl_long_type) {\n            jl_value_t *ndp = jl_tparam1(aty);\n            if (jl_is_long(ndp)) {\n                size_t ndims = jl_unbox_long(ndp);\n                if (idx.constant) {\n                    uint32_t idx_const = (uint32_t)jl_unbox_long(idx.constant);\n                    if (idx_const > 0 && idx_const <= ndims) {\n                        jl_value_t *ary_ex = jl_exprarg(ex, 1);\n                        *ret = mark_julia_type(ctx, emit_arraysize(ctx, ary, ary_ex, idx_const), false, jl_long_type);\n                        return true;\n                    }\n                    else if (idx_const > ndims) {\n                        *ret = mark_julia_type(ctx, ConstantInt::get(T_size, 1), false, jl_long_type);\n                        return true;\n                    }\n                }\n                else {\n                    Value *idx_dyn = emit_unbox(ctx, T_size, idx, (jl_value_t*)jl_long_type);\n                    error_unless(ctx, ctx.builder.CreateICmpSGT(idx_dyn, V_size0),\n                                 \"arraysize: dimension out of range\");\n                    BasicBlock *outBB = BasicBlock::Create(jl_LLVMContext, \"outofrange\", ctx.f);\n                    BasicBlock *inBB = BasicBlock::Create(jl_LLVMContext, \"inrange\");\n                    BasicBlock *ansBB = BasicBlock::Create(jl_LLVMContext, \"arraysize\");\n                    ctx.builder.CreateCondBr(ctx.builder.CreateICmpSLE(idx_dyn,\n                                ConstantInt::get(T_size, ndims)),\n                            inBB, outBB);\n                    ctx.builder.SetInsertPoint(outBB);\n                    Value *v_one = ConstantInt::get(T_size, 1);\n                    ctx.builder.CreateBr(ansBB);\n                    ctx.f->getBasicBlockList().push_back(inBB);\n                    ctx.builder.SetInsertPoint(inBB);\n                    Value *v_sz = emit_arraysize(ctx, ary, idx_dyn);\n                    ctx.builder.CreateBr(ansBB);\n                    inBB = ctx.builder.GetInsertBlock(); // could have changed\n                    ctx.f->getBasicBlockList().push_back(ansBB);\n                    ctx.builder.SetInsertPoint(ansBB);\n                    PHINode *result = ctx.builder.CreatePHI(T_size, 2);\n                    result->addIncoming(v_one, outBB);\n                    result->addIncoming(v_sz, inBB);\n                    *ret = mark_julia_type(ctx, result, false, jl_long_type);\n                    return true;\n                }\n            }\n        }\n    }\n\n    else if ((f == jl_builtin_arrayref || f == jl_builtin_const_arrayref) && nargs >= 3) {\n        const jl_cgval_t &ary = argv[2];\n        bool indices_ok = true;\n        for (size_t i = 3; i <= nargs; i++) {\n            if (argv[i].typ != (jl_value_t*)jl_long_type) {\n                indices_ok = false;\n                break;\n            }\n        }\n        jl_value_t *aty_dt = jl_unwrap_unionall(ary.typ);\n        if (jl_is_array_type(aty_dt) && indices_ok) {\n            jl_value_t *ety = jl_tparam0(aty_dt);\n            jl_value_t *ndp = jl_tparam1(aty_dt);\n            if (!jl_has_free_typevars(ety) && (jl_is_long(ndp) || nargs == 3)) {\n                jl_value_t *ary_ex = jl_exprarg(ex, 2);\n                size_t elsz = 0, al = 0;\n                int union_max = jl_islayout_inline(ety, &elsz, &al);\n                bool isboxed = (union_max == 0);\n                if (isboxed)\n                    ety = (jl_value_t*)jl_any_type;\n                ssize_t nd = jl_is_long(ndp) ? jl_unbox_long(ndp) : -1;\n                jl_value_t *boundscheck = argv[1].constant;\n                Value *idx = emit_array_nd_index(ctx, ary, ary_ex, nd, &argv[3], nargs - 2, boundscheck);\n                if (!isboxed && jl_is_datatype(ety) && jl_datatype_size(ety) == 0) {\n                    assert(((jl_datatype_t*)ety)->instance != NULL);\n                    *ret = ghostValue(ety);\n                }\n                else if (!isboxed && jl_is_uniontype(ety)) {\n                    Type *AT = ArrayType::get(IntegerType::get(jl_LLVMContext, 8 * al), (elsz + al - 1) / al);\n                    Value *data = emit_bitcast(ctx, emit_arrayptr(ctx, ary, ary_ex), AT->getPointerTo());\n                    // isbits union selector bytes are stored after a->maxsize\n                    Value *ndims = (nd == -1 ? emit_arrayndims(ctx, ary) : ConstantInt::get(T_int16, nd));\n                    Value *is_vector = ctx.builder.CreateICmpEQ(ndims, ConstantInt::get(T_int16, 1));\n                    Value *offset = emit_arrayoffset(ctx, ary, nd);\n                    Value *selidx_v = ctx.builder.CreateSub(emit_vectormaxsize(ctx, ary), ctx.builder.CreateZExt(offset, T_size));\n                    Value *selidx_m = emit_arraylen(ctx, ary);\n                    Value *selidx = ctx.builder.CreateSelect(is_vector, selidx_v, selidx_m);\n                    Value *ptindex = ctx.builder.CreateInBoundsGEP(AT, data, selidx);\n                    ptindex = emit_bitcast(ctx, ptindex, T_pint8);\n                    ptindex = ctx.builder.CreateInBoundsGEP(T_int8, ptindex, offset);\n                    ptindex = ctx.builder.CreateInBoundsGEP(T_int8, ptindex, idx);\n                    Instruction *tindex = tbaa_decorate(tbaa_arrayselbyte, ctx.builder.CreateAlignedLoad(T_int8, ptindex, Align(1)));\n                    tindex->setMetadata(LLVMContext::MD_range, MDNode::get(jl_LLVMContext, {\n                        ConstantAsMetadata::get(ConstantInt::get(T_int8, 0)),\n                        ConstantAsMetadata::get(ConstantInt::get(T_int8, union_max)) }));\n                    AllocaInst *lv = emit_static_alloca(ctx, AT);\n                    if (al > 1)\n                        lv->setAlignment(Align(al));\n                    emit_memcpy(ctx, lv, tbaa_arraybuf, ctx.builder.CreateInBoundsGEP(AT, data, idx), tbaa_arraybuf, elsz, al, false);\n                    *ret = mark_julia_slot(lv, ety, ctx.builder.CreateNUWAdd(ConstantInt::get(T_int8, 1), tindex), tbaa_arraybuf);\n                }\n                else {\n                    MDNode *aliasscope = (f == jl_builtin_const_arrayref) ? ctx.aliasscope : nullptr;\n                    *ret = typed_load(ctx,\n                            emit_arrayptr(ctx, ary, ary_ex),\n                            idx, ety,\n                            !isboxed ? tbaa_arraybuf : tbaa_ptrarraybuf, aliasscope);\n                }\n                return true;\n            }\n        }\n    }\n\n    else if (f == jl_builtin_arrayset && nargs >= 4) {\n        const jl_cgval_t &ary = argv[2];\n        const jl_cgval_t &val = argv[3];\n        bool indices_ok = true;\n        for (size_t i = 4; i <= nargs; i++) {\n            if (argv[i].typ != (jl_value_t*)jl_long_type) {\n                indices_ok = false;\n                break;\n            }\n        }\n        jl_value_t *aty_dt = jl_unwrap_unionall(ary.typ);\n        if (jl_is_array_type(aty_dt) && indices_ok) {\n            jl_value_t *ety = jl_tparam0(aty_dt);\n            jl_value_t *ndp = jl_tparam1(aty_dt);\n            if (!jl_has_free_typevars(ety) && (jl_is_long(ndp) || nargs == 4)) {\n                if (jl_subtype(val.typ, ety)) { // TODO: probably should just convert this to a type-assert\n                    size_t elsz = 0, al = 0;\n                    int union_max = jl_islayout_inline(ety, &elsz, &al);\n                    bool isboxed = (union_max == 0);\n                    if (isboxed)\n                        ety = (jl_value_t*)jl_any_type;\n                    jl_value_t *ary_ex = jl_exprarg(ex, 2);\n                    ssize_t nd = jl_is_long(ndp) ? jl_unbox_long(ndp) : -1;\n                    jl_value_t *boundscheck = argv[1].constant;\n                    Value *idx = emit_array_nd_index(ctx, ary, ary_ex, nd, &argv[4], nargs - 3, boundscheck);\n                    if (!isboxed && jl_is_datatype(ety) && jl_datatype_size(ety) == 0) {\n                        // no-op\n                    }\n                    else {\n                        PHINode *data_owner = NULL; // owner object against which the write barrier must check\n                        if (isboxed || (jl_is_datatype(ety) && ((jl_datatype_t*)ety)->layout->npointers > 0)) { // if elements are just bits, don't need a write barrier\n                            Value *aryv = boxed(ctx, ary);\n                            Value *flags = emit_arrayflags(ctx, ary);\n                            // the owner of the data is ary itself except if ary->how == 3\n                            flags = ctx.builder.CreateAnd(flags, 3);\n                            Value *is_owned = ctx.builder.CreateICmpEQ(flags, ConstantInt::get(T_int16, 3));\n                            BasicBlock *curBB = ctx.builder.GetInsertBlock();\n                            BasicBlock *ownedBB = BasicBlock::Create(jl_LLVMContext, \"array_owned\", ctx.f);\n                            BasicBlock *mergeBB = BasicBlock::Create(jl_LLVMContext, \"merge_own\", ctx.f);\n                            ctx.builder.CreateCondBr(is_owned, ownedBB, mergeBB);\n                            ctx.builder.SetInsertPoint(ownedBB);\n                            // load owner pointer\n                            Instruction *own_ptr;\n                            if (jl_is_long(ndp)) {\n                                own_ptr = ctx.builder.CreateAlignedLoad(T_prjlvalue,\n                                        ctx.builder.CreateConstInBoundsGEP1_32(T_prjlvalue,\n                                            emit_bitcast(ctx, decay_derived(ctx, aryv), T_pprjlvalue),\n                                            jl_array_data_owner_offset(nd) / sizeof(jl_value_t*)),\n                                        Align(sizeof(void*)));\n                                tbaa_decorate(tbaa_const, maybe_mark_load_dereferenceable(own_ptr, false, (jl_value_t*)jl_array_any_type));\n                            }\n                            else {\n                                own_ptr = ctx.builder.CreateCall(\n                                    prepare_call(jlarray_data_owner_func),\n                                    {aryv});\n                            }\n                            ctx.builder.CreateBr(mergeBB);\n                            ctx.builder.SetInsertPoint(mergeBB);\n                            data_owner = ctx.builder.CreatePHI(T_prjlvalue, 2);\n                            data_owner->addIncoming(aryv, curBB);\n                            data_owner->addIncoming(own_ptr, ownedBB);\n                        }\n                        if (jl_is_uniontype(ety)) {\n                            Type *AT = ArrayType::get(IntegerType::get(jl_LLVMContext, 8 * al), (elsz + al - 1) / al);\n                            Value *data = emit_bitcast(ctx, emit_arrayptr(ctx, ary, ary_ex), AT->getPointerTo());\n                            // compute tindex from val\n                            jl_cgval_t rhs_union = convert_julia_type(ctx, val, ety);\n                            Value *tindex = compute_tindex_unboxed(ctx, rhs_union, ety);\n                            tindex = ctx.builder.CreateNUWSub(tindex, ConstantInt::get(T_int8, 1));\n                            Value *ndims = (nd == -1 ? emit_arrayndims(ctx, ary) : ConstantInt::get(T_int16, nd));\n                            Value *is_vector = ctx.builder.CreateICmpEQ(ndims, ConstantInt::get(T_int16, 1));\n                            Value *offset = emit_arrayoffset(ctx, ary, nd);\n                            Value *selidx_v = ctx.builder.CreateSub(emit_vectormaxsize(ctx, ary), ctx.builder.CreateZExt(offset, T_size));\n                            Value *selidx_m = emit_arraylen(ctx, ary);\n                            Value *selidx = ctx.builder.CreateSelect(is_vector, selidx_v, selidx_m);\n                            Value *ptindex = ctx.builder.CreateInBoundsGEP(AT, data, selidx);\n                            ptindex = emit_bitcast(ctx, ptindex, T_pint8);\n                            ptindex = ctx.builder.CreateInBoundsGEP(T_int8, ptindex, offset);\n                            ptindex = ctx.builder.CreateInBoundsGEP(T_int8, ptindex, idx);\n                            tbaa_decorate(tbaa_arrayselbyte, ctx.builder.CreateStore(tindex, ptindex));\n                            if (jl_is_datatype(val.typ) && jl_datatype_size(val.typ) == 0) {\n                                // no-op\n                            }\n                            else {\n                                // copy data\n                                Value *addr = ctx.builder.CreateInBoundsGEP(AT, data, idx);\n                                emit_unionmove(ctx, addr, tbaa_arraybuf, val, nullptr);\n                            }\n                        }\n                        else {\n                            typed_store(ctx,\n                                        emit_arrayptr(ctx, ary, ary_ex, isboxed),\n                                        idx, val, ety,\n                                        !isboxed ? tbaa_arraybuf : tbaa_ptrarraybuf,\n                                        ctx.aliasscope, data_owner, 0);\n                        }\n                    }\n                    *ret = ary;\n                    return true;\n                }\n            }\n        }\n    }\n\n    else if (f == jl_builtin_getfield && (nargs == 2 || nargs == 3)) {\n        const jl_cgval_t &obj = argv[1];\n        const jl_cgval_t &fld = argv[2];\n        if (fld.constant && fld.typ == (jl_value_t*)jl_symbol_type) {\n            *ret = emit_getfield(ctx, argv[1], (jl_sym_t*)fld.constant);\n            return true;\n        }\n\n        if (fld.typ == (jl_value_t*)jl_long_type) {\n            if (ctx.vaSlot > 0) {\n                // optimize VA tuple\n                if (LoadInst *load = dyn_cast_or_null<LoadInst>(obj.V)) {\n                    if (load->getPointerOperand() == ctx.slots[ctx.vaSlot].boxroot && ctx.argArray) {\n                        Value *valen = emit_n_varargs(ctx);\n                        jl_cgval_t va_ary( // fake instantiation of a cgval, in order to call emit_bounds_check\n                                ctx.builder.CreateInBoundsGEP(T_prjlvalue, ctx.argArray, ConstantInt::get(T_size, ctx.nReqArgs)),\n                                NULL, false, NULL, NULL);\n                        Value *idx = emit_unbox(ctx, T_size, fld, (jl_value_t*)jl_long_type);\n                        jl_value_t *boundscheck = (nargs == 3 ? argv[3].constant : jl_true);\n                        idx = emit_bounds_check(ctx, va_ary, NULL, idx, valen, boundscheck);\n                        idx = ctx.builder.CreateAdd(idx, ConstantInt::get(T_size, ctx.nReqArgs));\n                        Instruction *v = ctx.builder.CreateAlignedLoad(T_prjlvalue, ctx.builder.CreateInBoundsGEP(ctx.argArray, idx), Align(sizeof(void*)));\n                        // if we know the result type of this load, we will mark that information here too\n                        tbaa_decorate(tbaa_value, maybe_mark_load_dereferenceable(v, false, rt));\n                        *ret = mark_julia_type(ctx, v, /*boxed*/ true, rt);\n                        return true;\n                    }\n                }\n            }\n\n            jl_datatype_t *utt = (jl_datatype_t*)jl_unwrap_unionall(obj.typ);\n            if (jl_is_datatype(utt) && utt->layout) {\n                if ((jl_is_structtype(utt) || jl_is_tuple_type(utt)) && !jl_subtype((jl_value_t*)jl_module_type, obj.typ)) {\n                    size_t nfields = jl_datatype_nfields(utt);\n                    // integer index\n                    size_t idx;\n                    if (fld.constant && (idx = jl_unbox_long(fld.constant) - 1) < nfields) {\n                        // known index\n                        *ret = emit_getfield_knownidx(ctx, obj, idx, utt);\n                        return true;\n                    }\n                    else {\n                        // unknown index\n                        Value *vidx = emit_unbox(ctx, T_size, fld, (jl_value_t*)jl_long_type);\n                        jl_value_t *boundscheck = (nargs == 3 ? argv[3].constant : jl_true);\n                        if (emit_getfield_unknownidx(ctx, ret, obj, vidx, utt, boundscheck)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            else {\n                if (jl_is_tuple_type(utt) && is_tupletype_homogeneous(utt->types, true)) {\n                    // For tuples, we can emit code even if we don't know the exact\n                    // type (e.g. because we don't know the length). This is possible\n                    // as long as we know that all elements are of the same (leaf) type.\n                    if (obj.ispointer()) {\n                        // Determine which was the type that was homogenous\n                        jl_value_t *jt = jl_tparam0(utt);\n                        if (jl_is_vararg(jt))\n                            jt = jl_unwrap_vararg(jt);\n                        Value *vidx = emit_unbox(ctx, T_size, fld, (jl_value_t*)jl_long_type);\n                        // This is not necessary for correctness, but allows to omit\n                        // the extra code for getting the length of the tuple\n                        jl_value_t *boundscheck = (nargs == 3 ? argv[3].constant : jl_true);\n                        if (!bounds_check_enabled(ctx, boundscheck)) {\n                            vidx = ctx.builder.CreateSub(vidx, ConstantInt::get(T_size, 1));\n                        } else {\n                            vidx = emit_bounds_check(ctx, obj, (jl_value_t*)obj.typ, vidx,\n                                emit_datatype_nfields(ctx, emit_typeof_boxed(ctx, obj)),\n                                jl_true);\n                        }\n                        bool isboxed = !jl_datatype_isinlinealloc(jt);\n                        Value *ptr = maybe_decay_tracked(ctx, data_pointer(ctx, obj));\n                        *ret = typed_load(ctx, ptr, vidx,\n                                isboxed ? (jl_value_t*)jl_any_type : jt,\n                                obj.tbaa, nullptr, false);\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n\n    else if (f == jl_builtin_setfield && nargs == 3) {\n        const jl_cgval_t &obj = argv[1];\n        const jl_cgval_t &fld = argv[2];\n        const jl_cgval_t &val = argv[3];\n\n        jl_datatype_t *uty = (jl_datatype_t*)jl_unwrap_unionall(obj.typ);\n        if (jl_is_structtype(uty) && uty != jl_module_type && uty->layout) {\n            size_t idx = (size_t)-1;\n            if (fld.constant && fld.typ == (jl_value_t*)jl_symbol_type) {\n                idx = jl_field_index(uty, (jl_sym_t*)fld.constant, 0);\n            }\n            else if (fld.constant && fld.typ == (jl_value_t*)jl_long_type) {\n                ssize_t i = jl_unbox_long(fld.constant);\n                if (i > 0 && i <= jl_datatype_nfields(uty))\n                    idx = i - 1;\n            }\n            if (idx != (size_t)-1) {\n                jl_value_t *ft = jl_svecref(uty->types, idx);\n                if (jl_subtype(val.typ, ft)) {\n                    // TODO: attempt better codegen for approximate types\n                    emit_setfield(ctx, uty, obj, idx, val, true, true);\n                    *ret = val;\n                    return true;\n                }\n            }\n        }\n    }\n\n    else if (f == jl_builtin_nfields && nargs == 1) {\n        const jl_cgval_t &obj = argv[1];\n        if (ctx.vaSlot > 0) {\n            // optimize VA tuple\n            if (LoadInst *load = dyn_cast_or_null<LoadInst>(obj.V)) {\n                if (load->getPointerOperand() == ctx.slots[ctx.vaSlot].boxroot) {\n                    *ret = mark_julia_type(ctx, emit_n_varargs(ctx), false, jl_long_type);\n                    return true;\n                }\n            }\n        }\n        ssize_t nf = -1;\n        if (obj.constant) {\n            nf = jl_datatype_nfields(jl_typeof(obj.constant));\n        }\n        else if (jl_is_type_type(obj.typ)) {\n            jl_value_t *tp0 = jl_tparam0(obj.typ);\n            if (jl_is_datatype(tp0) && jl_is_datatype_singleton((jl_datatype_t*)tp0))\n                nf = jl_datatype_nfields((jl_value_t*)jl_datatype_type);\n        }\n        else if (jl_is_concrete_type(obj.typ)) {\n            nf = jl_datatype_nfields(obj.typ);\n        }\n        Value *sz;\n        if (nf != -1)\n            sz = ConstantInt::get(T_size, nf);\n        else\n            sz = emit_datatype_nfields(ctx, emit_typeof_boxed(ctx, obj));\n        *ret = mark_julia_type(ctx, sz, false, jl_long_type);\n        return true;\n    }\n\n    else if (f == jl_builtin_fieldtype && (nargs == 2 || nargs == 3)) {\n        const jl_cgval_t &typ = argv[1];\n        const jl_cgval_t &fld = argv[2];\n        if ((jl_is_type_type(typ.typ) && jl_is_concrete_type(jl_tparam0(typ.typ))) ||\n                (typ.constant && jl_is_concrete_type(typ.constant))) {\n            if (fld.typ == (jl_value_t*)jl_long_type) {\n                assert(typ.isboxed);\n                Value *tyv = boxed(ctx, typ);\n                Value *types_svec = emit_datatype_types(ctx, tyv);\n                Value *types_len = emit_datatype_nfields(ctx, tyv);\n                Value *idx = emit_unbox(ctx, T_size, fld, (jl_value_t*)jl_long_type);\n                jl_value_t *boundscheck = (nargs == 3 ? argv[3].constant : jl_true);\n                emit_bounds_check(ctx, typ, (jl_value_t*)jl_datatype_type, idx, types_len, boundscheck);\n                Value *fieldtyp_p = ctx.builder.CreateInBoundsGEP(T_prjlvalue, decay_derived(ctx, emit_bitcast(ctx, types_svec, T_pprjlvalue)), idx);\n                Value *fieldtyp = tbaa_decorate(tbaa_const, ctx.builder.CreateAlignedLoad(T_prjlvalue, fieldtyp_p, Align(sizeof(void*))));\n                *ret = mark_julia_type(ctx, fieldtyp, true, (jl_value_t*)jl_type_type);\n                return true;\n            }\n        }\n    }\n\n    else if (f == jl_builtin_sizeof && nargs == 1) {\n        const jl_cgval_t &obj = argv[1];\n        jl_datatype_t *sty = (jl_datatype_t*)jl_unwrap_unionall(obj.typ);\n        assert(jl_string_type->mutabl);\n        if (sty == jl_string_type || sty == jl_simplevector_type) {\n            if (obj.constant) {\n                size_t sz;\n                if (sty == jl_string_type) {\n                    sz = jl_string_len(obj.constant);\n                }\n                else {\n                    sz = (1 + jl_svec_len(obj.constant)) * sizeof(void*);\n                }\n                *ret = mark_julia_type(ctx, ConstantInt::get(T_size, sz), false, jl_long_type);\n                return true;\n            }\n            // String and SimpleVector's length fields have the same layout\n            auto ptr = emit_bitcast(ctx, boxed(ctx, obj), T_psize);\n            Value *len = tbaa_decorate(tbaa_const, ctx.builder.CreateAlignedLoad(T_size, ptr, Align(sizeof(size_t))));\n            MDBuilder MDB(jl_LLVMContext);\n            if (sty == jl_simplevector_type) {\n                auto rng = MDB.createRange(\n                    V_size0, ConstantInt::get(T_size, INTPTR_MAX / sizeof(void*) - 1));\n                cast<LoadInst>(len)->setMetadata(LLVMContext::MD_range, rng);\n                len = ctx.builder.CreateMul(len, ConstantInt::get(T_size, sizeof(void*)));\n                len = ctx.builder.CreateAdd(len, ConstantInt::get(T_size, sizeof(void*)));\n            }\n            else {\n                auto rng = MDB.createRange(V_size0, ConstantInt::get(T_size, INTPTR_MAX));\n                cast<LoadInst>(len)->setMetadata(LLVMContext::MD_range, rng);\n            }\n            *ret = mark_julia_type(ctx, len, false, jl_long_type);\n            return true;\n        }\n        else if (jl_is_array_type(sty)) {\n            auto len = emit_arraylen(ctx, obj);\n            Value *elsize;\n            size_t elsz;\n            if (arraytype_constelsize(sty, &elsz)) {\n                elsize = ConstantInt::get(T_size, elsz);\n            }\n            else {\n                elsize = ctx.builder.CreateZExt(emit_arrayelsize(ctx, obj), T_size);\n            }\n            *ret = mark_julia_type(ctx, ctx.builder.CreateMul(len, elsize), false, jl_long_type);\n            return true;\n        }\n    }\n\n    else if (f == jl_builtin_apply_type && nargs > 0) {\n        if (jl_is_method(ctx.linfo->def.method)) {\n            // don't bother codegen constant-folding for toplevel.\n            jl_value_t *ty = static_apply_type(ctx, argv, nargs + 1);\n            if (ty != NULL) {\n                jl_add_method_root(ctx, ty);\n                *ret = mark_julia_const(ty);\n                return true;\n            }\n        }\n    }\n\n    else if (f == jl_builtin_isdefined && nargs == 2) {\n        const jl_cgval_t &obj = argv[1];\n        const jl_cgval_t &fld = argv[2];\n        jl_datatype_t *stt = (jl_datatype_t*)obj.typ;\n        if (jl_is_type_type((jl_value_t*)stt)) {\n            // the representation type of Type{T} is either typeof(T), or unknown\n            // TODO: could use `issingletontype` predicate here, providing better type knowledge\n            // than only handling DataType\n            if (jl_is_concrete_type(jl_tparam0(stt)))\n                stt = (jl_datatype_t*)jl_typeof(jl_tparam0(stt));\n            else\n                return false;\n        }\n        if (!jl_is_concrete_type((jl_value_t*)stt) || jl_is_array_type(stt) ||\n            stt == jl_module_type) { // TODO: use ->layout here instead of concrete_type\n            return false;\n        }\n        assert(jl_is_datatype(stt));\n\n        ssize_t fieldidx = -1;\n        if (fld.constant && fld.typ == (jl_value_t*)jl_symbol_type) {\n            jl_sym_t *sym = (jl_sym_t*)fld.constant;\n            fieldidx = jl_field_index(stt, sym, 0);\n        }\n        else if (fld.constant && fld.typ == (jl_value_t*)jl_long_type) {\n            fieldidx = jl_unbox_long(fld.constant) - 1;\n        }\n        else {\n            return false;\n        }\n        if (fieldidx < 0 || fieldidx >= jl_datatype_nfields(stt)) {\n            *ret = mark_julia_const(jl_false);\n        }\n        else if (fieldidx < stt->ninitialized) {\n            *ret = mark_julia_const(jl_true);\n        }\n        else if (jl_field_isptr(stt, fieldidx) || jl_type_hasptr(jl_field_type(stt, fieldidx))) {\n            Value *fldv;\n            size_t offs = jl_field_offset(stt, fieldidx) / sizeof(jl_value_t*);\n            auto tbaa = obj.tbaa;\n            if (tbaa == tbaa_datatype && offs != offsetof(jl_datatype_t, types))\n                tbaa = tbaa_const;\n            if (obj.ispointer()) {\n                if (!jl_field_isptr(stt, fieldidx))\n                    offs += ((jl_datatype_t*)jl_field_type(stt, fieldidx))->layout->first_ptr;\n                Value *ptr = emit_bitcast(ctx, maybe_decay_tracked(ctx, data_pointer(ctx, obj)), T_pprjlvalue);\n                Value *addr = ctx.builder.CreateConstInBoundsGEP1_32(T_prjlvalue, ptr, offs);\n                // emit this using the same type as emit_getfield_knownidx\n                // so that LLVM may be able to load-load forward them and fold the result\n                fldv = tbaa_decorate(tbaa, ctx.builder.CreateAlignedLoad(T_prjlvalue, addr, Align(sizeof(size_t))));\n                cast<LoadInst>(fldv)->setOrdering(AtomicOrdering::Unordered);\n            }\n            else {\n                fldv = ctx.builder.CreateExtractValue(obj.V, offs);\n                if (!jl_field_isptr(stt, fieldidx)) {\n                    fldv = extract_first_ptr(ctx, fldv);\n                    assert(fldv);\n                }\n            }\n            Value *isdef = ctx.builder.CreateIsNotNull(fldv);\n            *ret = mark_julia_type(ctx, isdef, false, jl_bool_type);\n        }\n        else {\n            *ret = mark_julia_const(jl_true);\n        }\n        return true;\n    }\n\n    return false;\n}\n\n// Returns T_prjlvalue\nstatic CallInst *emit_jlcall(jl_codectx_t &ctx, Function *theFptr, Value *theF,\n                             jl_cgval_t *argv, size_t nargs, CallingConv::ID cc)\n{\n    // emit arguments\n    SmallVector<Value*, 3> theArgs;\n    SmallVector<Type*, 3> argsT;\n    if (theF) {\n        theArgs.push_back(theF);\n        argsT.push_back(T_prjlvalue);\n    }\n    for (size_t i = 0; i < nargs; i++) {\n        Value *arg = boxed(ctx, argv[i]);\n        theArgs.push_back(arg);\n        argsT.push_back(T_prjlvalue);\n    }\n    FunctionType *FTy = FunctionType::get(T_prjlvalue, argsT, false);\n    CallInst *result = ctx.builder.CreateCall(FTy,\n        ctx.builder.CreateBitCast(theFptr, FTy->getPointerTo()),\n        theArgs);\n    add_return_attr(result, Attribute::NonNull);\n    result->setCallingConv(cc);\n    return result;\n}\n// Returns T_prjlvalue\nstatic CallInst *emit_jlcall(jl_codectx_t &ctx, JuliaFunction *theFptr, Value *theF,\n                             jl_cgval_t *argv, size_t nargs, CallingConv::ID cc)\n{\n    return emit_jlcall(ctx, prepare_call(theFptr), theF, argv, nargs, cc);\n}\n\n\nstatic jl_cgval_t emit_call_specfun_other(jl_codectx_t &ctx, jl_method_instance_t *mi, jl_value_t *jlretty, StringRef specFunctionObject,\n                                          jl_cgval_t *argv, size_t nargs, jl_returninfo_t::CallingConv *cc, unsigned *return_roots, jl_value_t *inferred_retty)\n{\n    // emit specialized call site\n    jl_returninfo_t returninfo = get_specsig_function(ctx, jl_Module, specFunctionObject, mi->specTypes, jlretty);\n    FunctionType *cft = returninfo.decl->getFunctionType();\n    *cc = returninfo.cc;\n    *return_roots = returninfo.return_roots;\n\n    size_t nfargs = cft->getNumParams();\n    Value **argvals = (Value**)alloca(nfargs * sizeof(Value*));\n    unsigned idx = 0;\n    AllocaInst *result;\n    switch (returninfo.cc) {\n    case jl_returninfo_t::Boxed:\n    case jl_returninfo_t::Register:\n    case jl_returninfo_t::Ghosts:\n        break;\n    case jl_returninfo_t::SRet:\n        result = emit_static_alloca(ctx, cft->getParamType(0)->getPointerElementType());\n        argvals[idx] = result;\n        idx++;\n        break;\n    case jl_returninfo_t::Union:\n        result = emit_static_alloca(ctx, ArrayType::get(T_int8, returninfo.union_bytes));\n        if (returninfo.union_align > 1)\n            result->setAlignment(Align(returninfo.union_align));\n        argvals[idx] = result;\n        idx++;\n        break;\n    }\n\n    if (returninfo.return_roots) {\n        AllocaInst *return_roots = emit_static_alloca(ctx, ArrayType::get(T_prjlvalue, returninfo.return_roots));\n        argvals[idx] = return_roots;\n        idx++;\n    }\n\n    for (size_t i = 0; i < nargs; i++) {\n        jl_value_t *jt = jl_nth_slot_type(mi->specTypes, i);\n        if (is_uniquerep_Type(jt))\n            continue;\n        bool isboxed = deserves_argbox(jt);\n        Type *et = isboxed ?  T_prjlvalue : julia_type_to_llvm(ctx, jt);\n        if (type_is_ghost(et))\n            continue;\n        assert(idx < nfargs);\n        Type *at = cft->getParamType(idx);\n        jl_cgval_t arg = argv[i];\n        if (isboxed) {\n            assert(at == T_prjlvalue && et == T_prjlvalue);\n            argvals[idx] = boxed(ctx, arg);\n        }\n        else if (et->isAggregateType()) {\n            if (!arg.ispointer())\n                arg = value_to_pointer(ctx, arg);\n            // can lazy load on demand, no copy needed\n            assert(at == PointerType::get(et, AddressSpace::Derived));\n            argvals[idx] = decay_derived(ctx, maybe_bitcast(ctx,\n                data_pointer(ctx, arg), at));\n        }\n        else {\n            assert(at == et);\n            Value *val = emit_unbox(ctx, et, arg, jt);\n            if (!val) {\n                // There was a type mismatch of some sort - exit early\n                CreateTrap(ctx.builder);\n                return jl_cgval_t();\n            }\n            argvals[idx] = val;\n        }\n        idx++;\n    }\n    assert(idx == nfargs);\n    CallInst *call = ctx.builder.CreateCall(returninfo.decl, ArrayRef<Value*>(&argvals[0], nfargs));\n    call->setAttributes(returninfo.decl->getAttributes());\n\n    jl_cgval_t retval;\n    switch (returninfo.cc) {\n        case jl_returninfo_t::Boxed:\n            retval = mark_julia_type(ctx, call, true, inferred_retty);\n            break;\n        case jl_returninfo_t::Register:\n            retval = mark_julia_type(ctx, call, false, jlretty);\n            break;\n        case jl_returninfo_t::SRet:\n            retval = mark_julia_slot(result, jlretty, NULL, tbaa_stack);\n            break;\n        case jl_returninfo_t::Union: {\n            Value *box = ctx.builder.CreateExtractValue(call, 0);\n            Value *tindex = ctx.builder.CreateExtractValue(call, 1);\n            Value *derived = ctx.builder.CreateSelect(\n                ctx.builder.CreateICmpEQ(\n                        ctx.builder.CreateAnd(tindex, ConstantInt::get(T_int8, 0x80)),\n                        ConstantInt::get(T_int8, 0)),\n                decay_derived(ctx, ctx.builder.CreateBitCast(argvals[0], T_pjlvalue)),\n                decay_derived(ctx, box)\n            );\n            retval = mark_julia_slot(derived,\n                                     jlretty,\n                                     tindex,\n                                     tbaa_stack);\n            retval.Vboxed = box;\n            break;\n        }\n        case jl_returninfo_t::Ghosts:\n            retval = mark_julia_slot(NULL, jlretty, call, tbaa_stack);\n            break;\n    }\n    // see if inference has a different / better type for the call than the lambda\n    if (inferred_retty != retval.typ)\n        retval = update_julia_type(ctx, retval, inferred_retty);\n    return retval;\n}\n\nstatic jl_cgval_t emit_call_specfun_boxed(jl_codectx_t &ctx, StringRef specFunctionObject,\n                                          jl_cgval_t *argv, size_t nargs, jl_value_t *inferred_retty)\n{\n    auto theFptr = cast<Function>(\n        jl_Module->getOrInsertFunction(specFunctionObject, jl_func_sig).getCallee());\n    add_return_attr(theFptr, Attribute::NonNull);\n    theFptr->addFnAttr(Thunk);\n    Value *ret = emit_jlcall(ctx, theFptr, nullptr, argv, nargs, JLCALL_F_CC);\n    return mark_julia_type(ctx, ret, true, inferred_retty);\n}\n\nstatic jl_cgval_t emit_invoke(jl_codectx_t &ctx, jl_expr_t *ex, jl_value_t *rt)\n{\n    jl_value_t **args = (jl_value_t**)jl_array_data(ex->args);\n    size_t arglen = jl_array_dim0(ex->args);\n    size_t nargs = arglen - 1;\n    assert(arglen >= 2);\n\n    jl_cgval_t lival = emit_expr(ctx, args[0]);\n    jl_cgval_t *argv = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * nargs);\n    for (size_t i = 0; i < nargs; ++i) {\n        argv[i] = emit_expr(ctx, args[i + 1]);\n        if (argv[i].typ == jl_bottom_type)\n            return jl_cgval_t();\n    }\n\n    bool handled = false;\n    jl_cgval_t result;\n    if (lival.constant) {\n        jl_method_instance_t *mi = (jl_method_instance_t*)lival.constant;\n        assert(jl_is_method_instance(mi));\n        if (mi == ctx.linfo) {\n            // handle self-recursion specially\n            jl_returninfo_t::CallingConv cc = jl_returninfo_t::CallingConv::Boxed;\n            FunctionType *ft = ctx.f->getFunctionType();\n            StringRef protoname = ctx.f->getName();\n            if (ft == jl_func_sig) {\n                result = emit_call_specfun_boxed(ctx, protoname, argv, nargs, rt);\n                handled = true;\n            }\n            else if (ft != jl_func_sig_sparams) {\n                unsigned return_roots = 0;\n                result = emit_call_specfun_other(ctx, mi, ctx.rettype, protoname, argv, nargs, &cc, &return_roots, rt);\n                handled = true;\n            }\n        }\n        else {\n            jl_value_t *ci = ctx.params->lookup(mi, ctx.world, ctx.world); // TODO: need to use the right pair world here\n            jl_code_instance_t *codeinst = (jl_code_instance_t*)ci;\n            if (ci != jl_nothing && codeinst->invoke != jl_fptr_sparam) { // check if we know we definitely can't handle this specptr\n                if (codeinst->invoke == jl_fptr_const_return) {\n                    result = mark_julia_const(codeinst->rettype_const);\n                    handled = true;\n                }\n                else {\n                    bool specsig, needsparams;\n                    std::tie(specsig, needsparams) = uses_specsig(mi, codeinst->rettype, ctx.params->prefer_specsig);\n                    std::string name;\n                    StringRef protoname;\n                    bool need_to_emit = true;\n                    if (ctx.use_cache) {\n                        // optimization: emit the correct name immediately, if we know it\n                        // TODO: use `emitted` map here too to try to consolidate names?\n                        if (codeinst->specptr.fptr) {\n                            if (specsig ? codeinst->isspecsig : codeinst->invoke == jl_fptr_args) {\n                                protoname = jl_ExecutionEngine->getFunctionAtAddress((uintptr_t)codeinst->specptr.fptr, codeinst);\n                                need_to_emit = false;\n                            }\n                        }\n                    }\n                    if (need_to_emit) {\n                        raw_string_ostream(name) << (specsig ? \"j_\" : \"j1_\") << name_from_method_instance(mi) << \"_\" << globalUnique++;\n                        protoname = StringRef(name);\n                    }\n                    jl_returninfo_t::CallingConv cc = jl_returninfo_t::CallingConv::Boxed;\n                    unsigned return_roots = 0;\n                    if (specsig)\n                        result = emit_call_specfun_other(ctx, mi, codeinst->rettype, protoname, argv, nargs, &cc, &return_roots, rt);\n                    else\n                        result = emit_call_specfun_boxed(ctx, protoname, argv, nargs, rt);\n                    handled = true;\n                    if (need_to_emit) {\n                        Function *trampoline_decl = cast<Function>(jl_Module->getNamedValue(protoname));\n                        ctx.call_targets.push_back(std::make_tuple(codeinst, cc, return_roots, trampoline_decl, specsig));\n                    }\n                }\n            }\n        }\n    }\n    if (!handled) {\n        Value *r = emit_jlcall(ctx, jlinvoke_func, boxed(ctx, lival), argv, nargs, JLCALL_F2_CC);\n        result = mark_julia_type(ctx, r, true, rt);\n    }\n    if (result.typ == jl_bottom_type)\n        CreateTrap(ctx.builder);\n    return result;\n}\n\nstatic jl_cgval_t emit_call(jl_codectx_t &ctx, jl_expr_t *ex, jl_value_t *rt)\n{\n    jl_value_t **args = (jl_value_t**)jl_array_data(ex->args);\n    size_t nargs = jl_array_dim0(ex->args);\n    assert(nargs >= 1);\n    jl_cgval_t f = emit_expr(ctx, args[0]);\n\n    if (f.constant && jl_typeis(f.constant, jl_intrinsic_type)) {\n        JL_I::intrinsic fi = (intrinsic)*(uint32_t*)jl_data_ptr(f.constant);\n        return emit_intrinsic(ctx, fi, args, nargs - 1);\n    }\n\n    jl_value_t *context = ctx.params->generic_context == jl_nothing ? nullptr : ctx.params->generic_context;\n    size_t n_generic_args = nargs + (context ? 1 : 0);\n\n    jl_cgval_t *generic_argv = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * n_generic_args);\n    jl_cgval_t *argv = generic_argv;\n    if (context) {\n        generic_argv[0] = mark_julia_const(context);\n        argv = &generic_argv[1];\n    }\n    argv[0] = f;\n    for (size_t i = 1; i < nargs; ++i) {\n        argv[i] = emit_expr(ctx, args[i]);\n        if (argv[i].typ == jl_bottom_type)\n            return jl_cgval_t(); // anything past here is unreachable\n    }\n\n    if (f.constant && jl_isa(f.constant, (jl_value_t*)jl_builtin_type)) {\n        if (f.constant == jl_builtin_ifelse && nargs == 4)\n            return emit_ifelse(ctx, argv[1], argv[2], argv[3], rt);\n        jl_cgval_t result;\n        bool handled = emit_builtin_call(ctx, &result, f.constant, argv, nargs - 1, rt, ex);\n        if (handled) {\n            return result;\n        }\n\n        // special case for known builtin not handled by emit_builtin_call\n        auto it = builtin_func_map.find(jl_get_builtin_fptr(f.constant));\n        if (it != builtin_func_map.end()) {\n            Value *ret = emit_jlcall(ctx, it->second, V_rnull, &argv[1], nargs - 1, JLCALL_F_CC);\n            return mark_julia_type(ctx, ret, true, rt);\n        }\n    }\n\n    // emit function and arguments\n    Value *callval = emit_jlcall(ctx, jlapplygeneric_func, nullptr, generic_argv, n_generic_args, JLCALL_F_CC);\n    return mark_julia_type(ctx, callval, true, rt);\n}\n\n// --- accessing and assigning variables ---\n\nstatic void undef_var_error_ifnot(jl_codectx_t &ctx, Value *ok, jl_sym_t *name)\n{\n    BasicBlock *err = BasicBlock::Create(jl_LLVMContext, \"err\", ctx.f);\n    BasicBlock *ifok = BasicBlock::Create(jl_LLVMContext, \"ok\");\n    ctx.builder.CreateCondBr(ok, ifok, err);\n    ctx.builder.SetInsertPoint(err);\n    ctx.builder.CreateCall(prepare_call(jlundefvarerror_func),\n        mark_callee_rooted(ctx, literal_pointer_val(ctx, (jl_value_t*)name)));\n    ctx.builder.CreateUnreachable();\n    ctx.f->getBasicBlockList().push_back(ifok);\n    ctx.builder.SetInsertPoint(ifok);\n}\n\n// returns a jl_ppvalue_t location for the global variable m.s\n// if the reference currently bound or assign == true,\n//   pbnd will also be assigned with the binding address\nstatic Value *global_binding_pointer(jl_codectx_t &ctx, jl_module_t *m, jl_sym_t *s,\n                                     jl_binding_t **pbnd, bool assign)\n{\n    jl_binding_t *b = NULL;\n    if (assign) {\n        b = jl_get_binding_wr(m, s, 0);\n        assert(b != NULL);\n        if (b->owner != m) {\n            char *msg;\n            (void)asprintf(&msg, \"cannot assign a value to variable %s.%s from module %s\",\n                    jl_symbol_name(b->owner->name), jl_symbol_name(s), jl_symbol_name(m->name));\n            emit_error(ctx, msg);\n            free(msg);\n        }\n    }\n    else {\n        b = jl_get_binding(m, s);\n        if (b == NULL) {\n            // var not found. switch to delayed lookup.\n            Constant *initnul = V_null;\n            GlobalVariable *bindinggv = new GlobalVariable(*ctx.f->getParent(), T_pjlvalue,\n                    false, GlobalVariable::PrivateLinkage, initnul);\n            LoadInst *cachedval = ctx.builder.CreateAlignedLoad(T_pjlvalue, bindinggv, Align(sizeof(void*)));\n            cachedval->setOrdering(AtomicOrdering::Unordered);\n            BasicBlock *have_val = BasicBlock::Create(jl_LLVMContext, \"found\");\n            BasicBlock *not_found = BasicBlock::Create(jl_LLVMContext, \"notfound\");\n            BasicBlock *currentbb = ctx.builder.GetInsertBlock();\n            ctx.builder.CreateCondBr(ctx.builder.CreateICmpNE(cachedval, initnul), have_val, not_found);\n            ctx.f->getBasicBlockList().push_back(not_found);\n            ctx.builder.SetInsertPoint(not_found);\n            Value *bval = ctx.builder.CreateCall(prepare_call(jlgetbindingorerror_func),\n                    { literal_pointer_val(ctx, (jl_value_t*)m),\n                      literal_pointer_val(ctx, (jl_value_t*)s) });\n            ctx.builder.CreateAlignedStore(bval, bindinggv, Align(sizeof(void*)))->setOrdering(AtomicOrdering::Release);\n            ctx.builder.CreateBr(have_val);\n            ctx.f->getBasicBlockList().push_back(have_val);\n            ctx.builder.SetInsertPoint(have_val);\n            PHINode *p = ctx.builder.CreatePHI(T_pjlvalue, 2);\n            p->addIncoming(cachedval, currentbb);\n            p->addIncoming(bval, not_found);\n            return julia_binding_gv(ctx, emit_bitcast(ctx, p, T_pprjlvalue));\n        }\n        if (b->deprecated)\n            cg_bdw(ctx, b);\n    }\n    if (pbnd)\n        *pbnd = b;\n    return julia_binding_gv(ctx, b);\n}\n\nstatic jl_cgval_t emit_checked_var(jl_codectx_t &ctx, Value *bp, jl_sym_t *name, bool isvol, MDNode *tbaa)\n{\n    LoadInst *v = ctx.builder.CreateAlignedLoad(T_prjlvalue, bp, Align(sizeof(void*)));\n    if (isvol)\n        v->setVolatile(true);\n    v->setOrdering(AtomicOrdering::Unordered);\n    if (tbaa)\n        tbaa_decorate(tbaa, v);\n    undef_var_error_ifnot(ctx, ctx.builder.CreateIsNotNull(v), name);\n    return mark_julia_type(ctx, v, true, jl_any_type);\n}\n\nstatic jl_cgval_t emit_sparam(jl_codectx_t &ctx, size_t i)\n{\n    if (jl_svec_len(ctx.linfo->sparam_vals) > 0) {\n        jl_value_t *e = jl_svecref(ctx.linfo->sparam_vals, i);\n        if (!jl_is_typevar(e)) {\n            return mark_julia_const(e);\n        }\n    }\n    assert(ctx.spvals_ptr != NULL);\n    Value *bp = ctx.builder.CreateConstInBoundsGEP1_32(\n            T_prjlvalue,\n            ctx.spvals_ptr,\n            i + sizeof(jl_svec_t) / sizeof(jl_value_t*));\n    Value *sp = tbaa_decorate(tbaa_const, ctx.builder.CreateAlignedLoad(T_prjlvalue, bp, Align(sizeof(void*))));\n    Value *isnull = ctx.builder.CreateICmpNE(emit_typeof(ctx, sp),\n            track_pjlvalue(ctx, literal_pointer_val(ctx, (jl_value_t*)jl_tvar_type)));\n    jl_unionall_t *sparam = (jl_unionall_t*)ctx.linfo->def.method->sig;\n    for (size_t j = 0; j < i; j++) {\n        sparam = (jl_unionall_t*)sparam->body;\n        assert(jl_is_unionall(sparam));\n    }\n    undef_var_error_ifnot(ctx, isnull, sparam->var->name);\n    return mark_julia_type(ctx, sp, true, jl_any_type);\n}\n\nstatic jl_cgval_t emit_global(jl_codectx_t &ctx, jl_sym_t *sym)\n{\n    jl_binding_t *jbp = NULL;\n    Value *bp = global_binding_pointer(ctx, ctx.module, sym, &jbp, false);\n    assert(bp != NULL);\n    if (jbp && jbp->value != NULL) {\n        if (jbp->constp)\n            return mark_julia_const(jbp->value);\n        // double-check that a global variable is actually defined. this\n        // can be a problem in parallel when a definition is missing on\n        // one machine.\n        LoadInst *v = ctx.builder.CreateAlignedLoad(T_prjlvalue, bp, Align(sizeof(void*)));\n        v->setOrdering(AtomicOrdering::Unordered);\n        tbaa_decorate(tbaa_binding, v);\n        return mark_julia_type(ctx, v, true, jl_any_type);\n    }\n    return emit_checked_var(ctx, bp, sym, false, tbaa_binding);\n}\n\nstatic jl_cgval_t emit_isdefined(jl_codectx_t &ctx, jl_value_t *sym)\n{\n    Value *isnull = NULL;\n    if (jl_is_slot(sym) || jl_is_argument(sym)) {\n        size_t sl = jl_slot_number(sym) - 1;\n        jl_varinfo_t &vi = ctx.slots[sl];\n        if (!vi.usedUndef)\n            return mark_julia_const(jl_true);\n        if (vi.boxroot == NULL || vi.pTIndex != NULL) {\n            assert(vi.defFlag);\n            isnull = ctx.builder.CreateAlignedLoad(T_int1, vi.defFlag, Align(1), vi.isVolatile);\n        }\n        if (vi.boxroot != NULL) {\n            Value *boxed = ctx.builder.CreateAlignedLoad(T_prjlvalue, vi.boxroot, Align(sizeof(void*)), vi.isVolatile);\n            Value *box_isnull = ctx.builder.CreateICmpNE(boxed, V_rnull);\n            if (vi.pTIndex) {\n                // value is either boxed in the stack slot, or unboxed in value\n                // as indicated by testing (pTIndex & 0x80)\n                Value *tindex = ctx.builder.CreateAlignedLoad(T_int8, vi.pTIndex, Align(sizeof(void*)), vi.isVolatile);\n                Value *load_unbox = ctx.builder.CreateICmpEQ(\n                            ctx.builder.CreateAnd(tindex, ConstantInt::get(T_int8, 0x80)),\n                            ConstantInt::get(T_int8, 0));\n                isnull = ctx.builder.CreateSelect(load_unbox, isnull, box_isnull);\n            }\n            else {\n                isnull = box_isnull;\n            }\n        }\n    }\n    else if (jl_is_expr(sym)) {\n        assert(((jl_expr_t*)sym)->head == static_parameter_sym && \"malformed isdefined expression\");\n        size_t i = jl_unbox_long(jl_exprarg(sym, 0)) - 1;\n        if (jl_svec_len(ctx.linfo->sparam_vals) > 0) {\n            jl_value_t *e = jl_svecref(ctx.linfo->sparam_vals, i);\n            if (!jl_is_typevar(e)) {\n                return mark_julia_const(jl_true);\n            }\n        }\n        assert(ctx.spvals_ptr != NULL);\n        Value *bp = ctx.builder.CreateConstInBoundsGEP1_32(\n                T_prjlvalue,\n                ctx.spvals_ptr,\n                i + sizeof(jl_svec_t) / sizeof(jl_value_t*));\n        Value *sp = tbaa_decorate(tbaa_const, ctx.builder.CreateAlignedLoad(T_prjlvalue, bp, Align(sizeof(void*))));\n        isnull = ctx.builder.CreateICmpNE(emit_typeof(ctx, sp),\n            track_pjlvalue(ctx, literal_pointer_val(ctx, (jl_value_t*)jl_tvar_type)));\n    }\n    else {\n        jl_module_t *modu;\n        jl_sym_t *name;\n        if (jl_is_globalref(sym)) {\n            modu = jl_globalref_mod(sym);\n            name = jl_globalref_name(sym);\n        }\n        else {\n            assert(jl_is_symbol(sym) && \"malformed isdefined expression\");\n            modu = ctx.module;\n            name = (jl_sym_t*)sym;\n        }\n        jl_binding_t *bnd = jl_get_binding(modu, name);\n        if (bnd) {\n            if (bnd->value != NULL)\n                return mark_julia_const(jl_true);\n            Value *bp = julia_binding_gv(ctx, bnd);\n            LoadInst *v = ctx.builder.CreateAlignedLoad(T_prjlvalue, bp, Align(sizeof(void*)));\n            tbaa_decorate(tbaa_binding, v);\n            v->setOrdering(AtomicOrdering::Unordered);\n            isnull = ctx.builder.CreateICmpNE(v, V_rnull);\n        }\n        else {\n            Value *v = ctx.builder.CreateCall(prepare_call(jlboundp_func), {\n                    literal_pointer_val(ctx, (jl_value_t*)modu),\n                    literal_pointer_val(ctx, (jl_value_t*)name)\n                });\n            isnull = ctx.builder.CreateICmpNE(v, ConstantInt::get(T_int32, 0));\n        }\n    }\n    return mark_julia_type(ctx, isnull, false, jl_bool_type);\n}\n\nstatic jl_cgval_t emit_varinfo(jl_codectx_t &ctx, jl_varinfo_t &vi, jl_sym_t *varname, jl_value_t *better_typ=NULL) {\n    jl_value_t *typ = better_typ ? better_typ : vi.value.typ;\n    jl_cgval_t v;\n    Value *isnull = NULL;\n    if (vi.boxroot == NULL || vi.pTIndex != NULL) {\n        if ((!vi.isVolatile && vi.isSA) || vi.isArgument || vi.value.constant || !vi.value.V) {\n            v = vi.value;\n            if (vi.pTIndex)\n                v.TIndex = ctx.builder.CreateAlignedLoad(T_int8, vi.pTIndex, Align(1));\n        }\n        else {\n            // copy value to a non-mutable (non-volatile SSA) location\n            AllocaInst *varslot = cast<AllocaInst>(vi.value.V);\n            Type *T = varslot->getAllocatedType();\n            assert(!varslot->isArrayAllocation() && \"variables not expected to be VLA\");\n            AllocaInst *ssaslot = cast<AllocaInst>(varslot->clone());\n            ssaslot->insertAfter(varslot);\n            if (vi.isVolatile) {\n                Value *unbox = ctx.builder.CreateAlignedLoad(ssaslot->getAllocatedType(), varslot,\n#if JL_LLVM_VERSION >= 110000\n                        varslot->getAlign(),\n#else\n                        varslot->getAlignment(),\n#endif\n                        true);\n                ctx.builder.CreateAlignedStore(unbox, ssaslot,\n#if JL_LLVM_VERSION >= 110000\n                        ssaslot->getAlign()\n#else\n                        ssaslot->getAlignment()\n#endif\n                        );\n            }\n            else {\n                const DataLayout &DL = jl_data_layout;\n                uint64_t sz = DL.getTypeStoreSize(T);\n                emit_memcpy(ctx, ssaslot, tbaa_stack, vi.value, sz,\n#if JL_LLVM_VERSION >= 110000\n                        ssaslot->getAlign().value()\n#else\n                        ssaslot->getAlignment()\n#endif\n                        );\n            }\n            Value *tindex = NULL;\n            if (vi.pTIndex)\n                tindex = ctx.builder.CreateAlignedLoad(T_int8, vi.pTIndex, Align(1), vi.isVolatile);\n            v = mark_julia_slot(ssaslot, vi.value.typ, tindex, tbaa_stack);\n        }\n        if (vi.boxroot == NULL)\n            v = update_julia_type(ctx, v, typ);\n        if (vi.usedUndef) {\n            assert(vi.defFlag);\n            isnull = ctx.builder.CreateAlignedLoad(T_int1, vi.defFlag, Align(1), vi.isVolatile);\n        }\n    }\n    if (vi.boxroot != NULL) {\n        Instruction *boxed = ctx.builder.CreateAlignedLoad(T_prjlvalue, vi.boxroot, Align(sizeof(void*)), vi.isVolatile);\n        Value *box_isnull = NULL;\n        if (vi.usedUndef)\n            box_isnull = ctx.builder.CreateICmpNE(boxed, V_rnull);\n        maybe_mark_load_dereferenceable(boxed, vi.usedUndef || vi.pTIndex, typ);\n        if (vi.pTIndex) {\n            // value is either boxed in the stack slot, or unboxed in value\n            // as indicated by testing (pTIndex & 0x80)\n            Value *load_unbox = ctx.builder.CreateICmpEQ(\n                        ctx.builder.CreateAnd(v.TIndex, ConstantInt::get(T_int8, 0x80)),\n                        ConstantInt::get(T_int8, 0));\n            if (vi.usedUndef)\n                isnull = ctx.builder.CreateSelect(load_unbox, isnull, box_isnull);\n            if (v.V) { // v.V will be null if it is a union of all ghost values\n                v.V = ctx.builder.CreateSelect(load_unbox, emit_bitcast(ctx,\n                    decay_derived(ctx, v.V), boxed->getType()), decay_derived(ctx, boxed));\n            } else\n                v.V = boxed;\n            v.Vboxed = boxed;\n            v = update_julia_type(ctx, v, typ);\n        }\n        else {\n            v = mark_julia_type(ctx, boxed, true, typ);\n            if (vi.usedUndef)\n                isnull = box_isnull;\n        }\n    }\n    if (isnull)\n        undef_var_error_ifnot(ctx, isnull, varname);\n    return v;\n}\n\nstatic jl_cgval_t emit_local(jl_codectx_t &ctx, jl_value_t *slotload)\n{\n    size_t sl = jl_slot_number(slotload) - 1;\n    jl_varinfo_t &vi = ctx.slots[sl];\n    jl_sym_t *sym = slot_symbol(ctx, sl);\n    jl_value_t *typ = NULL;\n    if (jl_typeis(slotload, jl_typedslot_type)) {\n        // use the better type from inference for this load\n        typ = jl_typedslot_get_type(slotload);\n        if (jl_is_typevar(typ))\n            typ = ((jl_tvar_t*)typ)->ub;\n    }\n    return emit_varinfo(ctx, vi, sym, typ);\n}\n\nstatic void emit_vi_assignment_unboxed(jl_codectx_t &ctx, jl_varinfo_t &vi, Value *isboxed, jl_cgval_t rval_info)\n{\n    if (vi.usedUndef)\n        store_def_flag(ctx, vi, true);\n\n    if (!vi.value.constant) { // check that this is not a virtual store\n        assert(vi.value.ispointer() || (vi.pTIndex && vi.value.V == NULL));\n        // store value\n        if (vi.value.V == NULL) {\n            // all ghost values in destination - nothing to copy or store\n        }\n        else if (rval_info.constant || !rval_info.ispointer()) {\n            if (rval_info.isghost) {\n                // all ghost values in source - nothing to copy or store\n            }\n            else {\n                if (rval_info.typ != vi.value.typ && !vi.pTIndex && !rval_info.TIndex) {\n                    // isbits cast-on-assignment is invalid. this branch should be dead-code.\n                    CreateTrap(ctx.builder);\n                }\n                else {\n                    Value *dest = vi.value.V;\n                    if (vi.pTIndex)\n                        ctx.builder.CreateStore(UndefValue::get(cast<AllocaInst>(vi.value.V)->getAllocatedType()), vi.value.V);\n                    Type *store_ty = julia_type_to_llvm(ctx, rval_info.constant ? jl_typeof(rval_info.constant) : rval_info.typ);\n                    Type *dest_ty = store_ty->getPointerTo();\n                    if (dest_ty != dest->getType())\n                        dest = emit_bitcast(ctx, dest, dest_ty);\n                    tbaa_decorate(tbaa_stack, ctx.builder.CreateStore(\n                                      emit_unbox(ctx, store_ty, rval_info, rval_info.typ),\n                                      dest,\n                                      vi.isVolatile));\n                }\n            }\n        }\n        else {\n            if (vi.pTIndex == NULL) {\n                assert(jl_is_concrete_type(vi.value.typ));\n                // Sometimes we can get into situations where the LHS and RHS\n                // are the same slot. We're not allowed to memcpy in that case\n                // due to LLVM bugs.\n                // This check should probably mostly catch the relevant situations.\n                if (vi.value.V != rval_info.V) {\n                    Value *copy_bytes = ConstantInt::get(T_int32, jl_datatype_size(vi.value.typ));\n                    emit_memcpy(ctx, vi.value.V, tbaa_stack, rval_info, copy_bytes,\n                                julia_alignment(rval_info.typ), vi.isVolatile);\n                }\n            }\n            else {\n                emit_unionmove(ctx, vi.value.V, tbaa_stack, rval_info, isboxed, vi.isVolatile);\n            }\n        }\n    }\n    else {\n        assert(vi.pTIndex == NULL);\n    }\n}\n\nstatic void emit_phinode_assign(jl_codectx_t &ctx, ssize_t idx, jl_value_t *r)\n{\n    jl_value_t *ssavalue_types = (jl_value_t*)ctx.source->ssavaluetypes;\n    assert(jl_is_array(ssavalue_types));\n    jl_array_t *edges = (jl_array_t*)jl_fieldref_noalloc(r, 0);\n    jl_value_t *phiType = jl_array_ptr_ref(ssavalue_types, idx);\n    BasicBlock *BB = ctx.builder.GetInsertBlock();\n    auto InsertPt = BB->getFirstInsertionPt();\n    if (phiType == jl_bottom_type) {\n        return;\n    }\n    AllocaInst *dest = nullptr;\n    // N.B.: For any memory space, used as a phi,\n    // we need to emit space twice here. The reason for this is that\n    // phi nodes may be arguments of other phi nodes, so if we don't\n    // have two buffers, one may be overwritten before its value is\n    // used. Hopefully LLVM will be able to fold this back where legal.\n    if (jl_is_uniontype(phiType)) {\n        bool allunbox;\n        size_t min_align, nbytes;\n        dest = try_emit_union_alloca(ctx, ((jl_uniontype_t*)phiType), allunbox, min_align, nbytes);\n        if (dest) {\n            Instruction *phi = dest->clone();\n            phi->insertAfter(dest);\n            PHINode *Tindex_phi = PHINode::Create(T_int8, jl_array_len(edges), \"tindex_phi\");\n            BB->getInstList().insert(InsertPt, Tindex_phi);\n            PHINode *ptr_phi = PHINode::Create(T_prjlvalue, jl_array_len(edges), \"ptr_phi\");\n            BB->getInstList().insert(InsertPt, ptr_phi);\n            Value *isboxed = ctx.builder.CreateICmpNE(\n                    ctx.builder.CreateAnd(Tindex_phi, ConstantInt::get(T_int8, 0x80)),\n                    ConstantInt::get(T_int8, 0));\n#if JL_LLVM_VERSION >= 100000\n            ctx.builder.CreateMemCpy(phi, MaybeAlign(min_align), dest, MaybeAlign(0), nbytes, false);\n#else\n            ctx.builder.CreateMemCpy(phi, min_align, dest, 0, nbytes, false);\n#endif\n            ctx.builder.CreateLifetimeEnd(dest);\n            Value *ptr = ctx.builder.CreateSelect(isboxed,\n                maybe_bitcast(ctx, decay_derived(ctx, ptr_phi), T_pint8),\n                maybe_bitcast(ctx, decay_derived(ctx, phi), T_pint8));\n            jl_cgval_t val = mark_julia_slot(ptr, phiType, Tindex_phi, tbaa_stack); // XXX: this TBAA is wrong for ptr_phi\n            val.Vboxed = ptr_phi;\n            ctx.PhiNodes.push_back(std::make_tuple(val, BB, dest, ptr_phi, r));\n            ctx.SAvalues.at(idx) = val;\n            ctx.ssavalue_assigned.at(idx) = true;\n            return;\n        }\n        else if (allunbox) {\n            PHINode *Tindex_phi = PHINode::Create(T_int8, jl_array_len(edges), \"tindex_phi\");\n            BB->getInstList().insert(InsertPt, Tindex_phi);\n            jl_cgval_t val = mark_julia_slot(NULL, phiType, Tindex_phi, tbaa_stack);\n            ctx.PhiNodes.push_back(std::make_tuple(val, BB, dest, (PHINode*)NULL, r));\n            ctx.SAvalues.at(idx) = val;\n            ctx.ssavalue_assigned.at(idx) = true;\n            return;\n        }\n    }\n    bool isboxed = !deserves_stack(phiType);\n    Type *vtype = isboxed ? T_prjlvalue : julia_type_to_llvm(ctx, phiType);\n    // The frontend should really not emit this, but we allow it\n    // for convenience.\n    if (type_is_ghost(vtype)) {\n        assert(jl_is_datatype(phiType) && ((jl_datatype_t*)phiType)->instance);\n        // Skip adding it to the PhiNodes list, since we didn't create one.\n        ctx.SAvalues.at(idx) = mark_julia_const(((jl_datatype_t*)phiType)->instance);\n        ctx.ssavalue_assigned.at(idx) = true;\n        return;\n    }\n    jl_cgval_t slot;\n    PHINode *value_phi = NULL;\n    if (vtype->isAggregateType() && CountTrackedPointers(vtype).count == 0) {\n        // the value will be moved into dest in the predecessor critical block.\n        // here it's moved into phi in the successor (from dest)\n        dest = emit_static_alloca(ctx, vtype);\n        Value *phi = emit_static_alloca(ctx, vtype);\n#if JL_LLVM_VERSION >= 100000\n        ctx.builder.CreateMemCpy(phi, MaybeAlign(julia_alignment(phiType)),\n             dest, MaybeAlign(0),\n             jl_datatype_size(phiType), false);\n#else\n        ctx.builder.CreateMemCpy(phi, julia_alignment(phiType),\n             dest, 0,\n             jl_datatype_size(phiType), false);\n#endif\n        ctx.builder.CreateLifetimeEnd(dest);\n        slot = mark_julia_slot(phi, phiType, NULL, tbaa_stack);\n    }\n    else {\n        value_phi = PHINode::Create(vtype, jl_array_len(edges), \"value_phi\");\n        BB->getInstList().insert(InsertPt, value_phi);\n        slot = mark_julia_type(ctx, value_phi, isboxed, phiType);\n    }\n    ctx.PhiNodes.push_back(std::make_tuple(slot, BB, dest, value_phi, r));\n    ctx.SAvalues.at(idx) = slot;\n    ctx.ssavalue_assigned.at(idx) = true;\n    return;\n}\n\nstatic void emit_ssaval_assign(jl_codectx_t &ctx, ssize_t idx, jl_value_t *r)\n{\n    assert(!ctx.ssavalue_assigned.at(idx));\n    if (jl_is_phinode(r)) {\n        return emit_phinode_assign(ctx, idx, r);\n    }\n\n    jl_cgval_t slot;\n    if (jl_is_phicnode(r)) {\n        jl_varinfo_t &vi = ctx.phic_slots[idx];\n        slot = emit_varinfo(ctx, vi, jl_symbol(\"phic\"));\n    } else {\n        slot = emit_expr(ctx, r, idx); // slot could be a jl_value_t (unboxed) or jl_value_t* (ispointer)\n    }\n    if (slot.isboxed || slot.TIndex) {\n        // see if inference suggested a different type for the ssavalue than the expression\n        // e.g. sometimes the information is inconsistent after inlining getfield on a Tuple\n        jl_value_t *ssavalue_types = (jl_value_t*)ctx.source->ssavaluetypes;\n        if (jl_is_array(ssavalue_types)) {\n            jl_value_t *declType = jl_array_ptr_ref(ssavalue_types, idx);\n            if (declType != slot.typ) {\n                slot = update_julia_type(ctx, slot, declType);\n            }\n        }\n    }\n    ctx.SAvalues.at(idx) = slot; // now SAvalues[idx] contains the SAvalue\n    ctx.ssavalue_assigned.at(idx) = true;\n}\n\nstatic void emit_varinfo_assign(jl_codectx_t &ctx, jl_varinfo_t &vi, jl_cgval_t rval_info, jl_value_t *l=NULL)\n{\n    if (!vi.used || vi.value.typ == jl_bottom_type)\n        return;\n\n    // convert rval-type to lval-type\n    jl_value_t *slot_type = vi.value.typ;\n    rval_info = convert_julia_type(ctx, rval_info, slot_type);\n    if (rval_info.typ == jl_bottom_type)\n        return;\n\n    // compute / store tindex info\n    if (vi.pTIndex) {\n        Value *tindex;\n        if (rval_info.TIndex) {\n            tindex = rval_info.TIndex;\n            if (!vi.boxroot)\n                tindex = ctx.builder.CreateAnd(tindex, ConstantInt::get(T_int8, 0x7f));\n        }\n        else {\n            assert(rval_info.isboxed || rval_info.constant);\n            tindex = compute_tindex_unboxed(ctx, rval_info, vi.value.typ);\n            if (vi.boxroot)\n                tindex = ctx.builder.CreateOr(tindex, ConstantInt::get(T_int8, 0x80));\n            else\n                rval_info.TIndex = tindex;\n        }\n        ctx.builder.CreateStore(tindex, vi.pTIndex, vi.isVolatile);\n    }\n\n    // store boxed variables\n    Value *isboxed = NULL;\n    if (vi.boxroot) {\n        Value *rval;\n        if (vi.pTIndex && rval_info.TIndex) {\n            ctx.builder.CreateStore(rval_info.TIndex, vi.pTIndex, vi.isVolatile);\n            isboxed = ctx.builder.CreateICmpNE(\n                    ctx.builder.CreateAnd(rval_info.TIndex, ConstantInt::get(T_int8, 0x80)),\n                    ConstantInt::get(T_int8, 0));\n            rval = rval_info.Vboxed ? rval_info.Vboxed : V_rnull;\n            assert(rval->getType() == T_prjlvalue);\n            assert(!vi.value.constant);\n        }\n        else {\n            assert(!vi.pTIndex || rval_info.isboxed || rval_info.constant);\n            rval = boxed(ctx, rval_info);\n        }\n        ctx.builder.CreateStore(rval, vi.boxroot, vi.isVolatile);\n    }\n\n    // store unboxed variables\n    if (!vi.boxroot || (vi.pTIndex && rval_info.TIndex)) {\n        emit_vi_assignment_unboxed(ctx, vi, isboxed, rval_info);\n    }\n}\n\nstatic void emit_assignment(jl_codectx_t &ctx, jl_value_t *l, jl_value_t *r, ssize_t ssaval)\n{\n    assert(!jl_is_ssavalue(l));\n\n    jl_sym_t *s = NULL;\n    jl_binding_t *bnd = NULL;\n    Value *bp = NULL;\n    if (jl_is_symbol(l))\n        s = (jl_sym_t*)l;\n    else if (jl_is_globalref(l))\n        bp = global_binding_pointer(ctx, jl_globalref_mod(l), jl_globalref_name(l), &bnd, true); // now bp != NULL\n    else\n        assert(jl_is_slot(l));\n    if (bp == NULL && s != NULL)\n        bp = global_binding_pointer(ctx, ctx.module, s, &bnd, true);\n    if (bp != NULL) { // it's a global\n        assert(bnd);\n        Value *rval = mark_callee_rooted(ctx, boxed(ctx, emit_expr(ctx, r, ssaval)));\n        ctx.builder.CreateCall(prepare_call(jlcheckassign_func),\n                           { literal_pointer_val(ctx, bnd),\n                             rval });\n        // Global variable. Does not need debug info because the debugger knows about\n        // its memory location.\n        return;\n    }\n\n    int sl = jl_slot_number(l) - 1;\n    // it's a local variable\n    jl_varinfo_t &vi = ctx.slots[sl];\n    jl_cgval_t rval_info = emit_expr(ctx, r, ssaval);\n    emit_varinfo_assign(ctx, vi, rval_info, l);\n}\n\nstatic void emit_upsilonnode(jl_codectx_t &ctx, ssize_t phic, jl_value_t *val)\n{\n    jl_varinfo_t &vi = ctx.phic_slots[phic];\n    // If the val is null, we can ignore the store.\n    // The middle end guarantees that the value from this\n    // upsilon node is not dynamically observed.\n    if (val) {\n        jl_cgval_t rval_info = emit_expr(ctx, val);\n        if (rval_info.typ == jl_bottom_type)\n            // as a special case, PhiC nodes are allowed to use undefined\n            // values, since they are just copy operations, so we need to\n            // ignore the store (it will not by dynamically observed), while\n            // normally, for any other operation result, we'd assume this store\n            // was unreachable and dead\n            val = NULL;\n        else\n            emit_varinfo_assign(ctx, vi, rval_info);\n    }\n    if (!val) {\n        if (vi.boxroot) {\n            // memory optimization: eagerly clear this gc-root now\n            ctx.builder.CreateAlignedStore(V_rnull, vi.boxroot, Align(sizeof(void*)), true);\n        }\n        if (vi.pTIndex) {\n            // We don't care what the contents of the variable are, but it\n            // does need to satisfy the union invariants (i.e. inbounds\n            // tindex).\n            ctx.builder.CreateAlignedStore(\n                vi.boxroot ? ConstantInt::get(T_int8, 0x80) :\n                             ConstantInt::get(T_int8, 0x01),\n                vi.pTIndex, Align(1), true);\n        }\n        else if (vi.value.V && !vi.value.constant && vi.value.typ != jl_bottom_type) {\n            assert(vi.value.ispointer());\n            Type *T = cast<AllocaInst>(vi.value.V)->getAllocatedType();\n            if (CountTrackedPointers(T).count) {\n                // make sure gc pointers (including ptr_phi of union-split) are initialized to NULL\n                ctx.builder.CreateStore(Constant::getNullValue(T), vi.value.V, true);\n            }\n        }\n    }\n}\n\n// --- convert expression to code ---\n\nstatic jl_cgval_t emit_cfunction(jl_codectx_t &ctx, jl_value_t *output_type, const jl_cgval_t &fexpr, jl_value_t *rt, jl_svec_t *argt);\n\nstatic Value *emit_condition(jl_codectx_t &ctx, const jl_cgval_t &condV, const std::string &msg)\n{\n    bool isbool = (condV.typ == (jl_value_t*)jl_bool_type);\n    if (!isbool) {\n        if (condV.TIndex) {\n            // check whether this might be bool\n            isbool = jl_subtype((jl_value_t*)jl_bool_type, condV.typ);\n        }\n        emit_typecheck(ctx, condV, (jl_value_t*)jl_bool_type, msg);\n    }\n    if (isbool) {\n        Value *cond = emit_unbox(ctx, T_int8, condV, (jl_value_t*)jl_bool_type);\n        assert(cond->getType() == T_int8);\n        return ctx.builder.CreateXor(ctx.builder.CreateTrunc(cond, T_int1), ConstantInt::get(T_int1, 1));\n    }\n    if (condV.isboxed) {\n        return ctx.builder.CreateICmpEQ(boxed(ctx, condV),\n            track_pjlvalue(ctx, literal_pointer_val(ctx, jl_false)));\n    }\n    // not a boolean\n    return ConstantInt::get(T_int1, 0); // TODO: replace with Undef\n}\n\nstatic Value *emit_condition(jl_codectx_t &ctx, jl_value_t *cond, const std::string &msg)\n{\n    return emit_condition(ctx, emit_expr(ctx, cond), msg);\n}\n\nstatic void emit_stmtpos(jl_codectx_t &ctx, jl_value_t *expr, int ssaval_result)\n{\n    if (jl_is_ssavalue(expr) && ssaval_result == -1)\n        return; // value not used, no point in attempting codegen for it\n    if (jl_is_slot(expr) && ssaval_result == -1) {\n        size_t sl = jl_slot_number(expr) - 1;\n        jl_varinfo_t &vi = ctx.slots[sl];\n        if (vi.usedUndef)\n            (void)emit_expr(ctx, expr);\n        return;\n    }\n    if (jl_is_argument(expr) && ssaval_result == -1) {\n        return;\n    }\n    if (jl_is_newvarnode(expr)) {\n        jl_value_t *var = jl_fieldref(expr, 0);\n        assert(jl_is_slot(var));\n        jl_varinfo_t &vi = ctx.slots[jl_slot_number(var)-1];\n        if (vi.usedUndef) {\n            // create a new uninitialized variable\n            Value *lv = vi.boxroot;\n            if (lv != NULL)\n                ctx.builder.CreateStore(V_rnull, lv);\n            if (lv == NULL || vi.pTIndex != NULL)\n                store_def_flag(ctx, vi, false);\n        }\n        return;\n    }\n    if (!jl_is_expr(expr)) {\n        assert(ssaval_result != -1);\n        emit_ssaval_assign(ctx, ssaval_result, expr);\n        return;\n    }\n    jl_expr_t *ex = (jl_expr_t*)expr;\n    jl_value_t **args = (jl_value_t**)jl_array_data(ex->args);\n    jl_sym_t *head = ex->head;\n    if (head == meta_sym || head == inbounds_sym || head == coverageeffect_sym\n            || head == aliasscope_sym || head == popaliasscope_sym) {\n        // some expression types are metadata and can be ignored\n        // in statement position\n        return;\n    }\n    else if (head == leave_sym) {\n        assert(jl_is_long(args[0]));\n        ctx.builder.CreateCall(prepare_call(jlleave_func),\n                           ConstantInt::get(T_int32, jl_unbox_long(args[0])));\n    }\n    else if (head == pop_exception_sym) {\n        jl_cgval_t excstack_state = emit_expr(ctx, jl_exprarg(expr, 0));\n        assert(excstack_state.V && excstack_state.V->getType() == T_size);\n        ctx.builder.CreateCall(prepare_call(jl_restore_excstack_func), excstack_state.V);\n        return;\n    }\n    else {\n        if (!jl_is_method(ctx.linfo->def.method) && !ctx.is_opaque_closure) {\n            // TODO: inference is invalid if this has any effect (which it often does)\n            Value *world = ctx.builder.CreateAlignedLoad(prepare_global_in(jl_Module, jlgetworld_global), Align(sizeof(size_t)));\n            // TODO: world->setOrdering(AtomicOrdering::Monotonic);\n            ctx.builder.CreateAlignedStore(world, ctx.world_age_field, Align(sizeof(size_t)));\n        }\n        assert(ssaval_result != -1);\n        emit_ssaval_assign(ctx, ssaval_result, expr);\n    }\n}\n\n// `expr` is not clobbered in JL_TRY\nJL_GCC_IGNORE_START(\"-Wclobbered\")\nstatic jl_cgval_t emit_expr(jl_codectx_t &ctx, jl_value_t *expr, ssize_t ssaval)\n{\n    if (jl_is_symbol(expr)) {\n        jl_sym_t *sym = (jl_sym_t*)expr;\n        return emit_global(ctx, sym);\n    }\n    if (jl_is_slot(expr) || jl_is_argument(expr)) {\n        return emit_local(ctx, expr);\n    }\n    if (jl_is_ssavalue(expr)) {\n        ssize_t idx = ((jl_ssavalue_t*)expr)->id - 1;\n        assert(idx >= 0);\n        if (!ctx.ssavalue_assigned.at(idx)) {\n            ctx.ssavalue_assigned.at(idx) = true; // (assignment, not comparison test)\n            return jl_cgval_t(); // dead code branch\n        }\n        else {\n            return ctx.SAvalues.at(idx); // at this point, SAvalues[idx] actually contains the SAvalue\n        }\n    }\n    if (jl_is_globalref(expr)) {\n        return emit_globalref(ctx, jl_globalref_mod(expr), jl_globalref_name(expr));\n    }\n    if (jl_is_linenode(expr)) {\n        jl_error(\"LineNumberNode in value position\");\n    }\n    if (jl_is_gotonode(expr)) {\n        jl_error(\"GotoNode in value position\");\n    }\n    if (jl_is_gotoifnot(expr)) {\n        jl_error(\"GotoIfNot in value position\");\n    }\n    if (jl_is_pinode(expr)) {\n        return convert_julia_type(ctx, emit_expr(ctx, jl_fieldref_noalloc(expr, 0)), jl_fieldref_noalloc(expr, 1));\n    }\n    if (!jl_is_expr(expr)) {\n        int needroot = true;\n        if (jl_is_quotenode(expr)) {\n            expr = jl_fieldref_noalloc(expr,0);\n        }\n        // numeric literals\n        if (jl_is_int32(expr)) {\n            int32_t val = jl_unbox_int32(expr);\n            if ((uint32_t)(val+512) < 1024) {\n                // this can be gotten from the box cache\n                needroot = false;\n                expr = jl_box_int32(val);\n            }\n        }\n        else if (jl_is_int64(expr)) {\n            uint64_t val = jl_unbox_uint64(expr);\n            if ((uint64_t)(val+512) < 1024) {\n                // this can be gotten from the box cache\n                needroot = false;\n                expr = jl_box_int64(val);\n            }\n        }\n        else if (jl_is_uint8(expr)) {\n            expr = jl_box_uint8(jl_unbox_uint8(expr));\n            needroot = false;\n        }\n        if (needroot && jl_is_method(ctx.linfo->def.method)) { // toplevel exprs and some integers are already rooted\n            jl_add_method_root(ctx, expr);\n        }\n        return mark_julia_const(expr);\n    }\n\n    jl_expr_t *ex = (jl_expr_t*)expr;\n    jl_value_t **args = (jl_value_t**)jl_array_data(ex->args);\n    jl_sym_t *head = ex->head;\n    // this is object-disoriented.\n    // however, this is a good way to do it because it should *not* be easy\n    // to add new node types.\n    if (head == isdefined_sym) {\n        return emit_isdefined(ctx, args[0]);\n    }\n    else if (head == throw_undef_if_not_sym) {\n        jl_sym_t *var = (jl_sym_t*)args[0];\n        Value *cond = ctx.builder.CreateTrunc(emit_unbox(ctx, T_int8, emit_expr(ctx, args[1]), (jl_value_t*)jl_bool_type), T_int1);\n        if (var == getfield_undefref_sym) {\n            raise_exception_unless(ctx, cond,\n                literal_pointer_val(ctx, jl_undefref_exception));\n        }\n        else {\n            undef_var_error_ifnot(ctx, cond, var);\n        }\n        return ghostValue(jl_nothing_type);\n    }\n    else if (head == invoke_sym) {\n        assert(ssaval >= 0);\n        jl_value_t *expr_t = jl_is_long(ctx.source->ssavaluetypes) ? (jl_value_t*)jl_any_type :\n            jl_array_ptr_ref(ctx.source->ssavaluetypes, ssaval);\n        return emit_invoke(ctx, ex, expr_t);\n    }\n    else if (head == call_sym) {\n        jl_value_t *expr_t;\n        if (ssaval < 0)\n            // TODO: this case is needed for the call to emit_expr in emit_llvmcall\n            expr_t = (jl_value_t*)jl_any_type;\n        else\n            expr_t = jl_is_long(ctx.source->ssavaluetypes) ? (jl_value_t*)jl_any_type : jl_array_ptr_ref(ctx.source->ssavaluetypes, ssaval);\n        jl_cgval_t res = emit_call(ctx, ex, expr_t);\n        // some intrinsics (e.g. typeassert) can return a wider type\n        // than what's actually possible\n        res = update_julia_type(ctx, res, expr_t);\n        if (res.typ == jl_bottom_type || expr_t == jl_bottom_type) {\n            CreateTrap(ctx.builder);\n        }\n        return res;\n    }\n    else if (head == foreigncall_sym) {\n        return emit_ccall(ctx, args, jl_array_dim0(ex->args));\n    }\n    else if (head == cfunction_sym) {\n        jl_cgval_t fexpr_rt = emit_expr(ctx, args[1]);\n        return emit_cfunction(ctx, args[0], fexpr_rt, args[2], (jl_svec_t*)args[3]);\n    }\n    else if (head == assign_sym) {\n        emit_assignment(ctx, args[0], args[1], ssaval);\n        return ghostValue(jl_nothing_type);\n    }\n    else if (head == static_parameter_sym) {\n        return emit_sparam(ctx, jl_unbox_long(args[0]) - 1);\n    }\n    else if (head == method_sym) {\n        jl_value_t *mn = args[0];\n        assert(jl_expr_nargs(ex) != 1 || jl_is_symbol(mn) || jl_is_slot(mn));\n\n        Value *bp = NULL, *name, *bp_owner = V_null;\n        jl_binding_t *bnd = NULL;\n        bool issym = jl_is_symbol(mn);\n        bool isglobalref = !issym && jl_is_globalref(mn);\n        jl_module_t *mod = ctx.module;\n        if (issym || isglobalref) {\n            if (isglobalref) {\n                mod = jl_globalref_mod(mn);\n                mn = (jl_value_t*)jl_globalref_name(mn);\n            }\n            JL_TRY {\n                if (jl_symbol_name((jl_sym_t*)mn)[0] == '@')\n                    jl_errorf(\"macro definition not allowed inside a local scope\");\n                name = literal_pointer_val(ctx, mn);\n                bnd = jl_get_binding_for_method_def(mod, (jl_sym_t*)mn);\n            }\n            JL_CATCH {\n                jl_value_t *e = jl_current_exception();\n                // errors. boo. root it somehow :(\n                bnd = jl_get_binding_wr(ctx.module, (jl_sym_t*)jl_gensym(), 1);\n                bnd->value = e;\n                bnd->constp = 1;\n                raise_exception(ctx, literal_pointer_val(ctx, e));\n                return ghostValue(jl_nothing_type);\n            }\n            bp = julia_binding_gv(ctx, bnd);\n            bp_owner = literal_pointer_val(ctx, (jl_value_t*)mod);\n        }\n        else if (jl_is_slot(mn) || jl_is_argument(mn)) {\n            int sl = jl_slot_number(mn)-1;\n            jl_varinfo_t &vi = ctx.slots[sl];\n            bp = vi.boxroot;\n            name = literal_pointer_val(ctx, (jl_value_t*)slot_symbol(ctx, sl));\n        }\n        if (bp) {\n            Value *mdargs[5] = { name, literal_pointer_val(ctx, (jl_value_t*)mod), bp,\n                                 bp_owner, literal_pointer_val(ctx, bnd) };\n            jl_cgval_t gf = mark_julia_type(\n                    ctx,\n                    ctx.builder.CreateCall(prepare_call(jlgenericfunction_func), makeArrayRef(mdargs)),\n                    true,\n                    jl_function_type);\n            if (jl_expr_nargs(ex) == 1)\n                return gf;\n        }\n        Value *a1 = boxed(ctx, emit_expr(ctx, args[1]));\n        Value *a2 = boxed(ctx, emit_expr(ctx, args[2]));\n        Value *mdargs[3] = {\n            /*argdata*/a1,\n            /*code*/a2,\n            /*module*/literal_pointer_val(ctx, (jl_value_t*)ctx.module)\n        };\n        jl_cgval_t meth = mark_julia_type(\n            ctx,\n            ctx.builder.CreateCall(prepare_call(jlmethod_func), makeArrayRef(mdargs)),\n            true,\n            jl_method_type);\n        return meth;\n    }\n    else if (head == const_sym) {\n        jl_sym_t *sym = (jl_sym_t*)args[0];\n        jl_module_t *mod = ctx.module;\n        if (jl_is_globalref(sym)) {\n            mod = jl_globalref_mod(sym);\n            sym = jl_globalref_name(sym);\n        }\n        if (jl_is_symbol(sym)) {\n            jl_binding_t *bnd = NULL;\n            (void)global_binding_pointer(ctx, mod, sym, &bnd, true); assert(bnd);\n            ctx.builder.CreateCall(prepare_call(jldeclareconst_func),\n                               literal_pointer_val(ctx, bnd));\n        }\n    }\n    else if (head == new_sym) {\n        size_t nargs = jl_array_len(ex->args);\n        jl_cgval_t *argv = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * nargs);\n        for (size_t i = 0; i < nargs; ++i) {\n            argv[i] = emit_expr(ctx, args[i]);\n        }\n        jl_value_t *ty = argv[0].typ;\n        if (jl_is_type_type(ty) &&\n                jl_is_datatype(jl_tparam0(ty)) &&\n                jl_is_concrete_type(jl_tparam0(ty))) {\n            assert(nargs <= jl_datatype_nfields(jl_tparam0(ty)) + 1);\n            return emit_new_struct(ctx, jl_tparam0(ty), nargs - 1, &argv[1]);\n        }\n        Value *val = emit_jlcall(ctx, jlnew_func, nullptr, argv, nargs, JLCALL_F_CC);\n        // temporarily mark as `Any`, expecting `emit_ssaval_assign` to update\n        // it to the inferred type.\n        return mark_julia_type(ctx, val, true, (jl_value_t*)jl_any_type);\n    }\n    else if (head == splatnew_sym) {\n        jl_cgval_t argv[2];\n        argv[0] = emit_expr(ctx, args[0]);\n        argv[1] = emit_expr(ctx, args[1]);\n        Value *typ = boxed(ctx, argv[0]);\n        Value *tup = boxed(ctx, argv[1]);\n        Value *val = ctx.builder.CreateCall(prepare_call(jlsplatnew_func), { typ, tup });\n        // temporarily mark as `Any`, expecting `emit_ssaval_assign` to update\n        // it to the inferred type.\n        return mark_julia_type(ctx, val, true, (jl_value_t*)jl_any_type);\n    }\n    else if (head == new_opaque_closure_sym) {\n        size_t nargs = jl_array_len(ex->args);\n        assert(nargs >= 5 && \"Not enough arguments in new_opaque_closure\");\n        SmallVector<jl_cgval_t, 5> argv(nargs);\n        for (size_t i = 0; i < nargs; ++i) {\n            argv[i] = emit_expr(ctx, args[i]);\n        }\n        const jl_cgval_t &argt = argv[0];\n        const jl_cgval_t &isva = argv[1];\n        const jl_cgval_t &lb = argv[2];\n        const jl_cgval_t &ub = argv[3];\n        const jl_cgval_t &source = argv[4];\n        if (source.constant == NULL) {\n            // For now, we require non-constant source to be handled by using\n            // eval. This should probably be a verifier error and an abort here.\n            emit_error(ctx, \"(internal error) invalid IR: opaque closure source be constant\");\n            return jl_cgval_t();\n        }\n        bool can_optimize = argt.constant != NULL && lb.constant != NULL && ub.constant != NULL &&\n            isva.constant != NULL &&\n            jl_is_tuple_type(argt.constant) && jl_is_bool(isva.constant) &&\n            jl_is_type(lb.constant) && jl_is_type(ub.constant) && jl_is_method(source.constant);\n\n        if (can_optimize) {\n            can_optimize &= ((jl_method_t*)source.constant)->nargs > 0 || !jl_unbox_bool(isva.constant);\n        }\n\n        if (can_optimize) {\n            // TODO: Emit this inline and outline it late using LLVM's coroutine\n            // support.\n            jl_method_t *closure_method = (jl_method_t *)source.constant;\n            jl_code_info_t *closure_src = jl_uncompress_ir(closure_method, NULL,\n                (jl_array_t*)closure_method->source);\n\n            std::unique_ptr<Module> closure_m;\n            jl_llvm_functions_t closure_decls;\n\n            jl_method_instance_t *li;\n            jl_value_t *closure_t;\n            jl_tupletype_t *env_t;\n            jl_svec_t *sig_args;\n            JL_GC_PUSH5(&li, &closure_src, &closure_t, &env_t, &sig_args);\n\n            li = jl_new_method_instance_uninit();\n            li->def.method = closure_method;\n            jl_tupletype_t *argt_typ = (jl_tupletype_t *)argt.constant;\n\n            closure_t = jl_apply_type2((jl_value_t*)jl_opaque_closure_type, (jl_value_t*)argt_typ, ub.constant);\n\n            size_t nsig = 1 + jl_svec_len(argt_typ->parameters);\n            sig_args = jl_alloc_svec_uninit(nsig);\n            jl_svecset(sig_args, 0, closure_t);\n            for (size_t i = 0; i < jl_svec_len(argt_typ->parameters); ++i) {\n                jl_svecset(sig_args, 1+i, jl_svecref(argt_typ->parameters, i));\n            }\n            li->specTypes = (jl_value_t*)jl_apply_tuple_type_v(jl_svec_data(sig_args), nsig);\n            jl_gc_wb(li, li->specTypes);\n\n            std::tie(closure_m, closure_decls) = emit_function(li, closure_src,\n                ub.constant, ctx.emission_context, jl_unbox_bool(isva.constant));\n\n            jl_value_t **env_component_ts = (jl_value_t**)alloca(sizeof(jl_value_t*) * (nargs-5));\n            for (size_t i = 0; i < nargs - 5; ++i) {\n                env_component_ts[i] = argv[5+i].typ;\n            }\n\n            env_t = jl_apply_tuple_type_v(env_component_ts, nargs-5);\n            jl_cgval_t env;\n            // TODO: Inline the env at the end of the opaque closure and generate a descriptor for GC\n            if (jl_is_concrete_type((jl_value_t*)env_t)) {\n                env = emit_new_struct(ctx, (jl_value_t*)env_t, nargs-5, &argv.data()[5]);\n            }\n            else {\n                Value *env_val = emit_jlcall(ctx, jltuple_func, V_rnull,\n                    &argv[5], nargs-5, JLCALL_F_CC);\n                env = mark_julia_type(ctx, env_val, true, env_t);\n            }\n\n            assert(closure_decls.functionObject != \"jl_fptr_sparam\");\n            bool isspecsig = closure_decls.functionObject != \"jl_fptr_args\";\n\n            Function *F = NULL;\n            std::string fname = isspecsig ?\n                closure_decls.functionObject :\n                closure_decls.specFunctionObject;\n            if (GlobalValue *V = jl_Module->getNamedValue(fname)) {\n                F = cast<Function>(V);\n            }\n            else {\n                F = Function::Create(get_func_sig(jl_LLVMContext),\n                                Function::ExternalLinkage,\n                                fname, jl_Module);\n                F->setAttributes(get_func_attrs(jl_LLVMContext));\n            }\n            jl_cgval_t jlcall_ptr = mark_julia_type(ctx,\n                F, false, jl_voidpointer_type);\n\n            jl_cgval_t fptr;\n            if (!isspecsig) {\n                fptr = jlcall_ptr;\n            } else {\n                Function *specptr = closure_m->getFunction(closure_decls.specFunctionObject);\n                if (specptr) {\n                    jl_returninfo_t returninfo = get_specsig_function(ctx, jl_Module,\n                        closure_decls.specFunctionObject, li->specTypes, ub.constant);\n                    fptr = mark_julia_type(ctx, returninfo.decl, false, jl_voidpointer_type);\n                } else {\n                    fptr = mark_julia_type(ctx,\n                        (llvm::Value*)Constant::getNullValue(T_size),\n                        false, jl_voidpointer_type);\n                }\n            }\n\n            jl_cgval_t world_age = mark_julia_type(ctx,\n                tbaa_decorate(tbaa_gcframe,\n                    ctx.builder.CreateAlignedLoad(ctx.world_age_field, Align(sizeof(size_t)))),\n                    false,\n                    jl_long_type);\n\n            jl_cgval_t closure_fields[6] = {\n                env,\n                isva,\n                world_age,\n                source,\n                jlcall_ptr,\n                fptr\n            };\n\n            jl_cgval_t ret = emit_new_struct(ctx, closure_t, 6, closure_fields);\n\n            ctx.oc_modules.push_back(std::move(closure_m));\n\n            JL_GC_POP();\n            return ret;\n        }\n\n        return mark_julia_type(ctx,\n                emit_jlcall(ctx, jl_new_opaque_closure_jlcall_func, V_rnull, argv.data(), nargs, JLCALL_F_CC),\n                true, jl_any_type);\n    }\n    else if (head == exc_sym) {\n        return mark_julia_type(ctx,\n                ctx.builder.CreateCall(prepare_call(jl_current_exception_func)),\n                true, jl_any_type);\n    }\n    else if (head == copyast_sym) {\n        jl_cgval_t ast = emit_expr(ctx, args[0]);\n        if (ast.typ != (jl_value_t*)jl_expr_type && ast.typ != (jl_value_t*)jl_any_type) {\n            // elide call to jl_copy_ast when possible\n            return ast;\n        }\n        return mark_julia_type(ctx,\n                ctx.builder.CreateCall(prepare_call(jlcopyast_func),\n                                       boxed(ctx, ast)), true, jl_expr_type);\n    }\n    else if (head == loopinfo_sym) {\n        // parse Expr(:loopinfo, \"julia.simdloop\", (\"llvm.loop.vectorize.width\", 4))\n        SmallVector<Metadata *, 8> MDs;\n        for (int i = 0, ie = jl_expr_nargs(ex); i < ie; ++i) {\n            Metadata *MD = to_md_tree(args[i]);\n            if (MD)\n                MDs.push_back(MD);\n        }\n\n        MDNode* MD = MDNode::get(jl_LLVMContext, MDs);\n        CallInst *I = ctx.builder.CreateCall(prepare_call(jl_loopinfo_marker_func));\n        I->setMetadata(\"julia.loopinfo\", MD);\n        return jl_cgval_t();\n    }\n    else if (head == leave_sym || head == coverageeffect_sym\n            || head == pop_exception_sym || head == enter_sym || head == inbounds_sym\n            || head == aliasscope_sym || head == popaliasscope_sym) {\n        jl_errorf(\"Expr(:%s) in value position\", jl_symbol_name(head));\n    }\n    else if (head == boundscheck_sym) {\n        return mark_julia_const(bounds_check_enabled(ctx, jl_true) ? jl_true : jl_false);\n    }\n    else if (head == gc_preserve_begin_sym) {\n        size_t nargs = jl_array_len(ex->args);\n        jl_cgval_t *argv = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * nargs);\n        for (size_t i = 0; i < nargs; ++i) {\n            argv[i] = emit_expr(ctx, args[i]);\n        }\n        std::vector<Value*> vals;\n        for (size_t i = 0; i < nargs; ++i) {\n            const jl_cgval_t &ai = argv[i];\n            if (ai.constant || ai.typ == jl_bottom_type)\n                continue;\n            if (ai.isboxed) {\n                vals.push_back(ai.Vboxed);\n            }\n            else if (jl_is_concrete_immutable(ai.typ) && !jl_is_pointerfree(ai.typ)) {\n                Type *at = julia_type_to_llvm(ctx, ai.typ);\n                vals.push_back(emit_unbox(ctx, at, ai, ai.typ));\n            }\n        }\n        Value *token = vals.empty()\n            ? (Value*)ConstantTokenNone::get(jl_LLVMContext)\n            : ctx.builder.CreateCall(prepare_call(gc_preserve_begin_func), vals);\n        jl_cgval_t tok(token, NULL, false, (jl_value_t*)jl_nothing_type, NULL);\n        return tok;\n    }\n    else if (head == gc_preserve_end_sym) {\n        // We only support ssa values as the argument. Everything else will\n        // fall back to the default behavior of preserving the argument value\n        // until the end of the scope, which is correct, but not optimal.\n        if (!jl_is_ssavalue(args[0])) {\n            return jl_cgval_t((jl_value_t*)jl_nothing_type);\n        }\n        jl_cgval_t token = emit_expr(ctx, args[0]);\n        assert(token.V->getType()->isTokenTy());\n        if (!isa<ConstantTokenNone>(token.V))\n            ctx.builder.CreateCall(prepare_call(gc_preserve_end_func), {token.V});\n        return jl_cgval_t((jl_value_t*)jl_nothing_type);\n    }\n    else {\n        if (jl_is_toplevel_only_expr(expr) &&\n            !jl_is_method(ctx.linfo->def.method)) {\n            // call interpreter to run a toplevel expr from inside a\n            // compiled toplevel thunk.\n            Value *args[2] = {\n                literal_pointer_val(ctx, (jl_value_t*)ctx.module),\n                literal_pointer_val(ctx, expr)\n            };\n            ctx.builder.CreateCall(prepare_call(jltopeval_func), args);\n            return ghostValue(jl_nothing_type);\n        }\n        jl_errorf(\"unsupported or misplaced expression \\\"%s\\\" in function %s\",\n                  jl_symbol_name(head), ctx.name);\n    }\n    return jl_cgval_t();\n}\nJL_GCC_IGNORE_STOP\n\n// --- generate function bodies ---\n\n// gc frame emission\nstatic void allocate_gc_frame(jl_codectx_t &ctx, BasicBlock *b0)\n{\n    // TODO: requires the runtime, but is generated unconditionally\n\n    // allocate a placeholder gc instruction\n    ctx.ptlsStates = ctx.builder.CreateCall(prepare_call(jltls_states_func));\n    int nthfield = offsetof(jl_tls_states_t, safepoint) / sizeof(void*);\n    ctx.signalPage = emit_nthptr_recast(ctx, ctx.ptlsStates, nthfield, tbaa_const,\n                                        PointerType::get(T_psize, 0));\n}\n\nstatic void emit_last_age_field(jl_codectx_t &ctx)\n{\n    ctx.world_age_field = ctx.builder.CreateInBoundsGEP(\n            T_size,\n            ctx.builder.CreateBitCast(ctx.ptlsStates, T_psize),\n            ConstantInt::get(T_size, offsetof(jl_tls_states_t, world_age) / sizeof(size_t)));\n}\n\nstatic Function *emit_tojlinvoke(jl_code_instance_t *codeinst, Module *M, jl_codegen_params_t &params)\n{\n    jl_codectx_t ctx(jl_LLVMContext, params);\n    std::string name;\n    raw_string_ostream(name) << \"tojlinvoke\" << globalUnique++;\n    Function *f = Function::Create(jl_func_sig,\n            GlobalVariable::PrivateLinkage,\n            name, M);\n    jl_init_function(f);\n    f->addFnAttr(Thunk);\n    //f->setAlwaysInline();\n    ctx.f = f; // for jl_Module\n    BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", f);\n    ctx.builder.SetInsertPoint(b0);\n    Function *theFunc;\n    Value *theFarg;\n    if (params.cache && codeinst->invoke != NULL) {\n        StringRef theFptrName = jl_ExecutionEngine->getFunctionAtAddress((uintptr_t)codeinst->invoke, codeinst);\n        theFunc = cast<Function>(\n            M->getOrInsertFunction(theFptrName, jlinvoke_func->_type(jl_LLVMContext)).getCallee());\n        theFarg = literal_pointer_val(ctx, (jl_value_t*)codeinst);\n    }\n    else {\n        theFunc = prepare_call(jlinvoke_func);\n        theFarg = literal_pointer_val(ctx, (jl_value_t*)codeinst->def);\n    }\n    theFarg = track_pjlvalue(ctx, theFarg);\n    auto args = f->arg_begin();\n    CallInst *r = ctx.builder.CreateCall(theFunc, { &*args, &*++args, &*++args, theFarg });\n    r->setAttributes(theFunc->getAttributes());\n    ctx.builder.CreateRet(r);\n    return f;\n}\n\nstatic void emit_cfunc_invalidate(\n        Function *gf_thunk, jl_returninfo_t::CallingConv cc, unsigned return_roots,\n        jl_value_t *calltype, jl_value_t *rettype,\n        size_t nargs,\n        jl_codegen_params_t &params,\n        Function *target)\n{\n    jl_codectx_t ctx(jl_LLVMContext, params);\n    ctx.f = gf_thunk;\n\n    BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", gf_thunk);\n    ctx.builder.SetInsertPoint(b0);\n    DebugLoc noDbg;\n    ctx.builder.SetCurrentDebugLocation(noDbg);\n    allocate_gc_frame(ctx, b0);\n\n    Function::arg_iterator AI = gf_thunk->arg_begin();\n    jl_cgval_t *myargs = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * nargs);\n    if (cc == jl_returninfo_t::SRet || cc == jl_returninfo_t::Union)\n        ++AI;\n    if (return_roots)\n        ++AI;\n    for (size_t i = 0; i < nargs; i++) {\n        jl_value_t *jt = jl_nth_slot_type(calltype, i);\n        bool isboxed = deserves_argbox(jt);\n        Type *et = isboxed ?  T_prjlvalue : julia_type_to_llvm(ctx, jt);\n        if (is_uniquerep_Type(jt)) {\n            myargs[i] = mark_julia_const(jl_tparam0(jt));\n        }\n        else if (type_is_ghost(et)) {\n            assert(jl_is_datatype(jt) && ((jl_datatype_t*)jt)->instance);\n            myargs[i] = mark_julia_const(((jl_datatype_t*)jt)->instance);\n        }\n        else {\n            Value *arg_v = &*AI;\n            ++AI;\n            Type *at = arg_v->getType();\n            if (!isboxed && et->isAggregateType()) {\n                myargs[i] = mark_julia_slot(arg_v, jt, NULL, tbaa_const);\n            }\n            else {\n                assert(at == et);\n                myargs[i] = mark_julia_type(ctx, arg_v, isboxed, jt);\n            }\n            (void)at;\n        }\n    }\n    assert(AI == gf_thunk->arg_end());\n    Value *gf_ret = emit_jlcall(ctx, target, nullptr, myargs, nargs, JLCALL_F_CC);\n    jl_cgval_t gf_retbox = mark_julia_type(ctx, gf_ret, true, jl_any_type);\n    if (cc != jl_returninfo_t::Boxed) {\n        emit_typecheck(ctx, gf_retbox, rettype, \"cfunction\");\n    }\n\n    switch (cc) {\n    case jl_returninfo_t::Boxed:\n        ctx.builder.CreateRet(gf_ret);\n        break;\n    case jl_returninfo_t::Register: {\n        Type *gfrt = gf_thunk->getReturnType();\n        if (gfrt->isVoidTy()) {\n            ctx.builder.CreateRetVoid();\n        }\n        else {\n            gf_ret = emit_bitcast(ctx, gf_ret, gfrt->getPointerTo());\n            ctx.builder.CreateRet(ctx.builder.CreateAlignedLoad(gf_ret, Align(julia_alignment(rettype))));\n        }\n        break;\n    }\n    case jl_returninfo_t::SRet: {\n        if (return_roots) {\n            Value *root1 = gf_thunk->arg_begin() + 1; // root1 has type [n x {}*]*\n            root1 = ctx.builder.CreateConstInBoundsGEP2_32(root1->getType()->getPointerElementType(), root1, 0, 0);\n            ctx.builder.CreateStore(gf_ret, root1);\n        }\n        emit_memcpy(ctx, &*gf_thunk->arg_begin(), nullptr, gf_ret, nullptr, jl_datatype_size(rettype), julia_alignment(rettype));\n        ctx.builder.CreateRetVoid();\n        break;\n    }\n    case jl_returninfo_t::Union: {\n        Type *retty = gf_thunk->getReturnType();\n        Value *gf_retval = UndefValue::get(retty);\n        Value *tindex = compute_box_tindex(ctx, emit_typeof_boxed(ctx, gf_retbox), (jl_value_t*)jl_any_type, rettype);\n        tindex = ctx.builder.CreateOr(tindex, ConstantInt::get(T_int8, 0x80));\n        gf_retval = ctx.builder.CreateInsertValue(gf_retval, gf_ret, 0);\n        gf_retval = ctx.builder.CreateInsertValue(gf_retval, tindex, 1);\n        ctx.builder.CreateRet(gf_retval);\n        break;\n    }\n    case jl_returninfo_t::Ghosts: {\n        Value *gf_retval = compute_tindex_unboxed(ctx, gf_retbox, rettype);\n        ctx.builder.CreateRet(gf_retval);\n        break;\n    }\n    }\n}\n\nstatic void emit_cfunc_invalidate(\n        Function *gf_thunk, jl_returninfo_t::CallingConv cc, unsigned return_roots,\n        jl_value_t *calltype, jl_value_t *rettype,\n        size_t nargs,\n        jl_codegen_params_t &params)\n{\n    emit_cfunc_invalidate(gf_thunk, cc, return_roots, calltype, rettype, nargs, params,\n        prepare_call_in(gf_thunk->getParent(), jlapplygeneric_func));\n}\n\nstatic Function* gen_cfun_wrapper(\n    Module *into, jl_codegen_params_t &params,\n    const function_sig_t &sig, jl_value_t *ff, const char *aliasname,\n    jl_value_t *declrt, jl_method_instance_t *lam,\n    jl_unionall_t *unionall_env, jl_svec_t *sparam_vals, jl_array_t **closure_types)\n{\n    // Generate a c-callable wrapper\n    assert(into);\n    size_t nargs = sig.nccallargs;\n    const char *name = \"cfunction\";\n    size_t world = jl_world_counter;\n    jl_code_instance_t *codeinst = NULL;\n    bool nest = (!ff || unionall_env);\n    jl_value_t *astrt = (jl_value_t*)jl_any_type;\n    void *callptr = NULL;\n    int calltype = 0;\n    if (aliasname)\n        name = aliasname;\n    else if (lam)\n        name = jl_symbol_name(lam->def.method->name);\n    if (lam && params.cache) {\n        // TODO: this isn't ideal to be unconditionally calling type inference (and compile) from here\n        codeinst = jl_compile_method_internal(lam, world);\n        assert(codeinst->invoke);\n        if (codeinst->invoke == jl_fptr_args) {\n            callptr = codeinst->specptr.fptr;\n            calltype = 1;\n        }\n        else if (codeinst->invoke == jl_fptr_const_return) {\n            // don't need the fptr\n            callptr = (void*)codeinst->rettype_const;\n            calltype = 2;\n        }\n        else if (codeinst->isspecsig) {\n            callptr = codeinst->specptr.fptr;\n            calltype = 3;\n        }\n        astrt = codeinst->rettype;\n        if (astrt != (jl_value_t*)jl_bottom_type &&\n            jl_type_intersection(astrt, declrt) == jl_bottom_type) {\n            // Do not warn if the function never returns since it is\n            // occasionally required by the C API (typically error callbacks)\n            // even though we're likely to encounter memory errors in that case\n            jl_printf(JL_STDERR, \"WARNING: cfunction: return type of %s does not match\\n\", name);\n        }\n    }\n\n    std::string funcName;\n    raw_string_ostream(funcName) << \"jlcapi_\" << name << \"_\" << globalUnique++;\n\n    Module *M = into;\n    AttributeList attributes = sig.attributes;\n    FunctionType *functype;\n    if (nest) {\n        // add nest parameter (pointer to jl_value_t* data array) after sret arg\n        assert(closure_types);\n        std::vector<Type*> fargt_sig(sig.fargt_sig);\n        fargt_sig.insert(fargt_sig.begin() + sig.sret, T_pprjlvalue);\n        functype = FunctionType::get(sig.sret ? T_void : sig.prt, fargt_sig, /*isVa*/false);\n        attributes = attributes.addAttribute(jl_LLVMContext, 1 + sig.sret, Attribute::Nest);\n    }\n    else {\n        functype = sig.functype();\n    }\n    Function *cw = Function::Create(functype,\n            GlobalVariable::ExternalLinkage,\n            funcName, M);\n    cw->setAttributes(attributes);\n    jl_init_function(cw);\n\n    jl_codectx_t ctx(jl_LLVMContext, params);\n    ctx.f = cw;\n    ctx.world = world;\n    ctx.name = name;\n    ctx.funcName = name;\n\n    BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", cw);\n    ctx.builder.SetInsertPoint(b0);\n    DebugLoc noDbg;\n    ctx.builder.SetCurrentDebugLocation(noDbg);\n    allocate_gc_frame(ctx, b0);\n    emit_last_age_field(ctx);\n\n    Value *dummy_world = ctx.builder.CreateAlloca(T_size);\n    Value *have_tls = ctx.builder.CreateIsNotNull(ctx.ptlsStates);\n    // TODO: in the future, try to initialize a full TLS context here\n    // for now, just use a dummy field to avoid a branch in this function\n    ctx.world_age_field = ctx.builder.CreateSelect(have_tls, ctx.world_age_field, dummy_world);\n    Value *last_age = tbaa_decorate(tbaa_gcframe, ctx.builder.CreateAlignedLoad(ctx.world_age_field, Align(sizeof(size_t))));\n    Value *valid_tls = ctx.builder.CreateIsNotNull(last_age);\n    have_tls = ctx.builder.CreateAnd(have_tls, valid_tls);\n    ctx.world_age_field = ctx.builder.CreateSelect(valid_tls, ctx.world_age_field, dummy_world);\n    Value *world_v = ctx.builder.CreateAlignedLoad(prepare_global_in(jl_Module, jlgetworld_global), Align(sizeof(size_t)));\n    // TODO: cast<LoadInst>(world_v)->setOrdering(AtomicOrdering::Monotonic);\n\n    Value *age_ok = NULL;\n    if (calltype) {\n        LoadInst *lam_max = ctx.builder.CreateAlignedLoad(\n                T_size,\n                ctx.builder.CreateConstInBoundsGEP1_32(\n                    T_size,\n                    emit_bitcast(ctx, literal_pointer_val(ctx, (jl_value_t*)codeinst), T_psize),\n                    offsetof(jl_code_instance_t, max_world) / sizeof(size_t)),\n                Align(sizeof(size_t)));\n        // XXX: age is always OK if we don't have a TLS. This is a hack required due to `@threadcall` abuse.\n        // and adds quite a bit of complexity here, even though it's still wrong\n        // (anything that tries to interact with the runtime will fault)\n        age_ok = ctx.builder.CreateICmpUGE(lam_max, world_v);\n        world_v = ctx.builder.CreateSelect(ctx.builder.CreateOr(have_tls, age_ok), world_v, lam_max);\n        age_ok = ctx.builder.CreateOr(ctx.builder.CreateNot(have_tls), age_ok);\n    }\n    ctx.builder.CreateStore(world_v, ctx.world_age_field);\n\n    // first emit code to record the arguments\n    Function::arg_iterator AI = cw->arg_begin();\n    Value *sretPtr = sig.sret ? &*AI++ : NULL;\n    Value *nestPtr = nest ? &*AI++ : NULL;\n    jl_cgval_t *inputargs = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * (nargs + 1));\n    if (ff) {\n        // we need to pass the function object even if (even though) it is a singleton\n        inputargs[0] = mark_julia_const(ff);\n    }\n    else {\n        assert(nest && nestPtr);\n        Value *ff = ctx.builder.CreateAlignedLoad(T_prjlvalue, nestPtr, Align(sizeof(void*)));\n        inputargs[0] = mark_julia_type(ctx, ff, true, jl_any_type);\n    }\n    // XXX: these values may need to be rooted until the end of the function\n    jl_value_t *rt1 = NULL;\n    jl_value_t *rt2 = NULL;\n    JL_GC_PUSH2(&rt1, &rt2);\n    for (size_t i = 0; i < nargs; ++i, ++AI) {\n        // figure out how to unpack this argument type\n        Value *val = &*AI;\n        assert(sig.fargt_sig.at(i + sig.sret) == val->getType());\n        jl_cgval_t &inputarg = inputargs[i + 1];\n        jl_value_t *jargty = jl_svecref(sig.at, i);\n        bool aref = jl_is_abstract_ref_type(jargty);\n        if (aref) // a pointer to a value\n            jargty = jl_tparam0(jargty);\n\n        // if we know the outer function sparams, try to fill those in now\n        // so that the julia_to_native type checks are more likely to be doable (e.g. concrete types) at compile-time\n        jl_value_t *jargty_proper = jargty;\n        bool static_at = !(unionall_env && jl_has_typevar_from_unionall(jargty, unionall_env));\n        if (!static_at) {\n            if (sparam_vals) {\n                jargty_proper = rt1 = jl_instantiate_type_in_env(jargty, unionall_env, jl_svec_data(sparam_vals));\n                assert(jargty_proper != jargty);\n                jargty = jargty_proper;\n                static_at = true;\n            }\n            else {\n                jargty_proper = rt1 = jl_rewrap_unionall(jargty, (jl_value_t*)unionall_env);\n            }\n        }\n\n        if (aref) {\n            if (jargty == (jl_value_t*)jl_any_type) {\n                inputarg = mark_julia_type(ctx,\n                        ctx.builder.CreateAlignedLoad(T_prjlvalue, emit_bitcast(ctx, val, T_pprjlvalue), Align(sizeof(void*))),\n                        true, jl_any_type);\n            }\n            else if (static_at && jl_is_concrete_immutable(jargty)) { // anything that could be stored unboxed\n                bool isboxed;\n                Type *T = julia_type_to_llvm(ctx, jargty, &isboxed);\n                assert(!isboxed);\n                // a T* (of unknown origin)\n                if (type_is_ghost(T)) {\n                    inputarg = ghostValue(jargty);\n                }\n                else {\n                    val = emit_bitcast(ctx, val, T->getPointerTo());\n                    val = ctx.builder.CreateAlignedLoad(val, Align(1)); // make no alignment assumption about pointer from C\n                    inputarg = mark_julia_type(ctx, val, false, jargty);\n                }\n            }\n            else if (static_at || (!jl_is_typevar(jargty) && !jl_is_immutable_datatype(jargty))) {\n                // must be a jl_value_t* (because it's mutable or contains gc roots)\n                inputarg = mark_julia_type(ctx, maybe_decay_untracked(ctx, emit_bitcast(ctx, val, T_prjlvalue)), true, jargty_proper);\n            }\n            else {\n                // allocate val into a new box, if it might not be boxed\n                // otherwise preserve / reuse the existing box identity\n                // TODO: could inspect `jargty` and eliminate some of these cases\n                if (!*closure_types)\n                    *closure_types = jl_alloc_vec_any(0);\n                jl_array_ptr_1d_push(*closure_types, jargty);\n                Value *runtime_dt = ctx.builder.CreateAlignedLoad(T_prjlvalue,\n                        ctx.builder.CreateConstInBoundsGEP1_32(T_prjlvalue, nestPtr, jl_array_len(*closure_types)),\n                        Align(sizeof(void*)));\n                BasicBlock *boxedBB = BasicBlock::Create(jl_LLVMContext, \"isboxed\", cw);\n                BasicBlock *loadBB = BasicBlock::Create(jl_LLVMContext, \"need-load\", cw);\n                BasicBlock *unboxedBB = BasicBlock::Create(jl_LLVMContext, \"maybe-unboxed\", cw);\n                BasicBlock *isanyBB = BasicBlock::Create(jl_LLVMContext, \"any\", cw);\n                BasicBlock *afterBB = BasicBlock::Create(jl_LLVMContext, \"after\", cw);\n                Value *isrtboxed = ctx.builder.CreateIsNull(val);\n                ctx.builder.CreateCondBr(isrtboxed, boxedBB, loadBB);\n                ctx.builder.SetInsertPoint(boxedBB);\n                Value *p1 = ctx.builder.CreateBitCast(val, T_pjlvalue);\n                p1 = track_pjlvalue(ctx, p1);\n                ctx.builder.CreateBr(afterBB);\n                ctx.builder.SetInsertPoint(loadBB);\n                Value *isrtany = ctx.builder.CreateICmpEQ(\n                        literal_pointer_val(ctx, (jl_value_t*)jl_any_type),\n                        ctx.builder.CreateBitCast(val, T_pjlvalue));\n                ctx.builder.CreateCondBr(isrtany, isanyBB, unboxedBB);\n                ctx.builder.SetInsertPoint(isanyBB);\n                Value *p2 = ctx.builder.CreateAlignedLoad(T_prjlvalue, ctx.builder.CreateBitCast(val, T_pprjlvalue), Align(sizeof(void*)));\n                ctx.builder.CreateBr(afterBB);\n                ctx.builder.SetInsertPoint(unboxedBB);\n                Value *p3 = emit_new_bits(ctx, runtime_dt, val);\n                unboxedBB = ctx.builder.GetInsertBlock(); // could have changed\n                ctx.builder.CreateBr(afterBB);\n                ctx.builder.SetInsertPoint(afterBB);\n                PHINode *p = ctx.builder.CreatePHI(T_prjlvalue, 3);\n                p->addIncoming(p1, boxedBB);\n                p->addIncoming(p2, isanyBB);\n                p->addIncoming(p3, unboxedBB);\n                inputarg = mark_julia_type(ctx, p, true, jargty_proper);\n            }\n        }\n        else {\n            bool argboxed = sig.fargt_isboxed.at(i);\n            if (argboxed) {\n                // a jl_value_t*, even when represented as a struct\n                inputarg = mark_julia_type(ctx, val, true, jargty_proper);\n            }\n            else {\n                // something of type T\n                // undo whatever we might have done to this poor argument\n                assert(jl_is_datatype(jargty));\n                if (sig.byRefList.at(i)) {\n                    assert(cast<PointerType>(val->getType())->getElementType() == sig.fargt[i]);\n                    val = ctx.builder.CreateAlignedLoad(val, Align(1)); // unknown alignment from C\n                }\n                else {\n                    bool issigned = jl_signed_type && jl_subtype(jargty_proper, (jl_value_t*)jl_signed_type);\n                    val = llvm_type_rewrite(ctx, val, sig.fargt[i], issigned);\n                }\n                // passed an unboxed T, but may need something boxed (not valid to be unboxed)\n                if (static_at) {\n                    bool isboxed;\n                    assert(jargty == jargty_proper);\n                    (void)julia_type_to_llvm(ctx, jargty, &isboxed);\n                    if (isboxed)\n                        inputarg = mark_julia_type(ctx,\n                                box_ccall_result(ctx, val, literal_pointer_val(ctx, jargty), jargty),\n                                true, jargty_proper);\n                    else\n                        inputarg = mark_julia_type(ctx, val, false, jargty);\n                }\n                else {\n                    if (!*closure_types)\n                        *closure_types = jl_alloc_vec_any(0);\n                    jl_array_ptr_1d_push(*closure_types, jargty);\n                    Value *runtime_dt = ctx.builder.CreateAlignedLoad(T_prjlvalue,\n                            ctx.builder.CreateConstInBoundsGEP1_32(T_prjlvalue, nestPtr, jl_array_len(*closure_types)),\n                            Align(sizeof(void*)));\n                    Value *strct = box_ccall_result(ctx, val, runtime_dt, jargty);\n                    inputarg = mark_julia_type(ctx, strct, true, jargty_proper);\n                }\n            }\n        }\n    }\n    JL_GC_POP();\n    assert(AI == cw->arg_end());\n\n    // Create the call\n    bool jlfunc_sret;\n    jl_cgval_t retval;\n    if (calltype == 2) {\n        nargs = 0; // arguments not needed -- TODO: not really true, should emit an age_ok test and jlcall\n        jlfunc_sret = false;\n        retval = mark_julia_const((jl_value_t*)callptr);\n    }\n    else if (calltype == 0 || calltype == 1) {\n        // emit a jlcall\n        jlfunc_sret = false;\n        Function *theFptr = NULL;\n        if (calltype == 1) {\n            StringRef fname = jl_ExecutionEngine->getFunctionAtAddress((uintptr_t)callptr, codeinst);\n            theFptr = cast_or_null<Function>(jl_Module->getNamedValue(fname));\n            if (!theFptr) {\n                theFptr = Function::Create(jl_func_sig, GlobalVariable::ExternalLinkage,\n                                           fname, jl_Module);\n                jl_init_function(theFptr);\n            }\n            else {\n                assert(theFptr->getFunctionType() == jl_func_sig);\n            }\n            add_return_attr(theFptr, Attribute::NonNull);\n            theFptr->addFnAttr(Thunk);\n        }\n        BasicBlock *b_generic, *b_jlcall, *b_after;\n        Value *ret_jlcall;\n        if (age_ok) {\n            assert(theFptr);\n            b_generic = BasicBlock::Create(jl_LLVMContext, \"generic\", cw);\n            b_jlcall = BasicBlock::Create(jl_LLVMContext, \"apply\", cw);\n            b_after = BasicBlock::Create(jl_LLVMContext, \"after\", cw);\n            ctx.builder.CreateCondBr(age_ok, b_jlcall, b_generic);\n            ctx.builder.SetInsertPoint(b_jlcall);\n            // for jlcall, we need to pass the function object even if it is a ghost.\n            Value *theF = boxed(ctx, inputargs[0]);\n            assert(theF);\n            ret_jlcall = emit_jlcall(ctx, theFptr, theF, &inputargs[1], nargs, JLCALL_F_CC);\n            ctx.builder.CreateBr(b_after);\n            ctx.builder.SetInsertPoint(b_generic);\n        }\n        Value *ret = emit_jlcall(ctx, jlapplygeneric_func, NULL, inputargs, nargs + 1, JLCALL_F_CC);\n        if (age_ok) {\n            ctx.builder.CreateBr(b_after);\n            ctx.builder.SetInsertPoint(b_after);\n            PHINode *retphi = ctx.builder.CreatePHI(T_prjlvalue, 2);\n            retphi->addIncoming(ret_jlcall, b_jlcall);\n            retphi->addIncoming(ret, b_generic);\n            ret = retphi;\n        }\n        retval = mark_julia_type(ctx, ret, true, astrt);\n    }\n    else {\n        assert(calltype == 3);\n        // emit a specsig call\n        StringRef protoname = jl_ExecutionEngine->getFunctionAtAddress((uintptr_t)callptr, codeinst);\n        jl_returninfo_t returninfo = get_specsig_function(ctx, M, protoname, lam->specTypes, astrt);\n        FunctionType *cft = returninfo.decl->getFunctionType();\n        jlfunc_sret = (returninfo.cc == jl_returninfo_t::SRet);\n\n        // TODO: Can use use emit_call_specfun_other here?\n        std::vector<Value*> args;\n        Value *result;\n        if (jlfunc_sret || returninfo.cc == jl_returninfo_t::Union) {\n            // fuse the two sret together, or emit an alloca to hold it\n            if (sig.sret && jlfunc_sret) {\n                result = emit_bitcast(ctx, sretPtr, cft->getParamType(0));\n            }\n            else {\n                result = emit_static_alloca(ctx, cft->getParamType(0)->getPointerElementType());\n            }\n            args.push_back(result);\n        }\n        if (returninfo.return_roots) {\n            AllocaInst *return_roots = emit_static_alloca(ctx, ArrayType::get(T_prjlvalue, returninfo.return_roots));\n            args.push_back(return_roots);\n        }\n        for (size_t i = 0; i < nargs + 1; i++) {\n            // figure out how to repack the arguments\n            jl_cgval_t &inputarg = inputargs[i];\n            Value *arg;\n            jl_value_t *spect = jl_nth_slot_type(lam->specTypes, i);\n            bool isboxed = deserves_argbox(spect);\n            Type *T = isboxed ? T_prjlvalue : julia_type_to_llvm(ctx, spect);\n            if (is_uniquerep_Type(spect)) {\n                continue;\n            }\n            else if (isboxed) {\n                arg = boxed(ctx, inputarg);\n            }\n            else if (type_is_ghost(T)) {\n                continue; // ghost types are skipped by the specsig method signature\n            }\n            else if (T->isAggregateType()) {\n                // aggregate types are passed by pointer\n                if (!inputarg.ispointer())\n                    inputarg = value_to_pointer(ctx, inputarg);\n                arg = maybe_bitcast(ctx, decay_derived(ctx, data_pointer(ctx, inputarg)),\n                    T->getPointerTo());\n            }\n            else {\n                arg = emit_unbox(ctx, T, inputarg, spect);\n                assert(!isa<UndefValue>(arg));\n            }\n\n            // add to argument list\n            args.push_back(arg);\n        }\n        Value *theFptr = returninfo.decl;\n        assert(theFptr);\n        if (age_ok) {\n            funcName += \"_gfthunk\";\n            Function *gf_thunk = Function::Create(returninfo.decl->getFunctionType(),\n                    GlobalVariable::InternalLinkage, funcName, M);\n            gf_thunk->setAttributes(returninfo.decl->getAttributes());\n            jl_init_function(gf_thunk);\n            // build a  specsig -> jl_apply_generic converter thunk\n            // this builds a method that calls jl_apply_generic (as a closure over a singleton function pointer),\n            // but which has the signature of a specsig\n            emit_cfunc_invalidate(gf_thunk, returninfo.cc, returninfo.return_roots, lam->specTypes, codeinst->rettype, nargs + 1, ctx.emission_context);\n            theFptr = ctx.builder.CreateSelect(age_ok, theFptr, gf_thunk);\n        }\n        CallInst *call = ctx.builder.CreateCall(\n            cast<FunctionType>(theFptr->getType()->getPointerElementType()),\n            theFptr, ArrayRef<Value*>(args));\n        call->setAttributes(returninfo.decl->getAttributes());\n        switch (returninfo.cc) {\n            case jl_returninfo_t::Boxed:\n                retval = mark_julia_type(ctx, call, true, astrt);\n                break;\n            case jl_returninfo_t::Register:\n                retval = mark_julia_type(ctx, call, false, astrt);\n                break;\n            case jl_returninfo_t::SRet:\n                retval = mark_julia_slot(result, astrt, NULL, tbaa_stack);\n                break;\n            case jl_returninfo_t::Union: {\n                Value *box = ctx.builder.CreateExtractValue(call, 0);\n                Value *tindex = ctx.builder.CreateExtractValue(call, 1);\n                Value *derived = ctx.builder.CreateSelect(\n                    ctx.builder.CreateICmpEQ(\n                            ctx.builder.CreateAnd(tindex, ConstantInt::get(T_int8, 0x80)),\n                            ConstantInt::get(T_int8, 0)),\n                    decay_derived(ctx, ctx.builder.CreateBitCast(result, T_pjlvalue)),\n                    decay_derived(ctx, box));\n                retval = mark_julia_slot(derived,\n                                         astrt,\n                                         tindex,\n                                         tbaa_stack);\n                assert(box->getType() == T_prjlvalue);\n                retval.Vboxed = box;\n                break;\n            }\n            case jl_returninfo_t::Ghosts:\n                retval = mark_julia_slot(NULL, astrt, call, tbaa_stack);\n                break;\n        }\n    }\n\n    // inline a call to typeassert here, if required\n    emit_typecheck(ctx, retval, declrt, \"cfunction\");\n    retval = update_julia_type(ctx, retval, declrt);\n\n    // Prepare the return value\n    Value *r;\n    if (sig.retboxed) {\n        assert(!sig.sret);\n        // return a jl_value_t*\n        r = boxed(ctx, retval);\n    }\n    else if (sig.sret && jlfunc_sret) {\n        // nothing to do\n        r = NULL;\n    }\n    else if (!type_is_ghost(sig.lrt)) {\n        Type *prt = sig.prt;\n        if (sig.sret)\n            prt = sig.fargt_sig[0]->getContainedType(0); // sret is a PointerType\n        bool issigned = jl_signed_type && jl_subtype(declrt, (jl_value_t*)jl_signed_type);\n        Value *v = emit_unbox(ctx, sig.lrt, retval, retval.typ);\n        r = llvm_type_rewrite(ctx, v, prt, issigned);\n        if (sig.sret) {\n            ctx.builder.CreateStore(r, sretPtr);\n            r = NULL;\n        }\n    }\n    else {\n        r = NULL;\n    }\n\n    ctx.builder.CreateStore(last_age, ctx.world_age_field);\n    ctx.builder.CreateRet(r);\n\n    ctx.builder.SetCurrentDebugLocation(noDbg);\n    ctx.builder.ClearInsertionPoint();\n\n    if (aliasname) {\n        GlobalAlias::create(cw->getType()->getElementType(), cw->getType()->getAddressSpace(),\n                            GlobalValue::ExternalLinkage, aliasname, cw, M);\n    }\n\n    if (nest) {\n        funcName += \"make\";\n        Function *cw_make = Function::Create(\n                FunctionType::get(T_pint8, { T_pint8, T_ppjlvalue }, false),\n                GlobalVariable::ExternalLinkage,\n                funcName, M);\n        jl_init_function(cw_make);\n        BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", cw_make);\n        IRBuilder<> cwbuilder(b0);\n        Function::arg_iterator AI = cw_make->arg_begin();\n        Argument *Tramp = &*AI; ++AI;\n        Argument *NVal = &*AI; ++AI;\n        Function *init_trampoline = Intrinsic::getDeclaration(cw_make->getParent(), Intrinsic::init_trampoline);\n        Function *adjust_trampoline = Intrinsic::getDeclaration(cw_make->getParent(), Intrinsic::adjust_trampoline);\n        cwbuilder.CreateCall(init_trampoline, {\n                Tramp,\n                cwbuilder.CreateBitCast(cw, T_pint8),\n                cwbuilder.CreateBitCast(NVal, T_pint8)\n            });\n        cwbuilder.CreateRet(cwbuilder.CreateCall(adjust_trampoline, { Tramp }));\n        cw = cw_make;\n    }\n\n    return cw;\n}\n\n// Get the LLVM Function* for the C-callable entry point for a certain function\n// and argument types.\n// here argt does not include the leading function type argument\nstatic jl_cgval_t emit_cfunction(jl_codectx_t &ctx, jl_value_t *output_type, const jl_cgval_t &fexpr_rt, jl_value_t *declrt, jl_svec_t *argt)\n{\n    jl_unionall_t *unionall_env = (jl_is_method(ctx.linfo->def.method) && jl_is_unionall(ctx.linfo->def.method->sig))\n        ? (jl_unionall_t*)ctx.linfo->def.method->sig\n        : NULL;\n    jl_svec_t *sparam_vals = NULL;\n    if (ctx.spvals_ptr == NULL && jl_svec_len(ctx.linfo->sparam_vals) > 0)\n        sparam_vals = ctx.linfo->sparam_vals;\n\n    jl_value_t *rt = declrt;\n    if (jl_is_abstract_ref_type(declrt)) {\n        declrt = jl_tparam0(declrt);\n        if (!verify_ref_type(ctx, declrt, unionall_env, 0, \"cfunction\")) {\n            return jl_cgval_t();\n        }\n        if (unionall_env)\n            declrt = jl_rewrap_unionall(declrt, (jl_value_t*)unionall_env);\n        rt = (jl_value_t*)jl_any_type; // convert return type to jl_value_t*\n    }\n\n    // some sanity checking and check whether there's a vararg\n    size_t nargt = jl_svec_len(argt);\n    bool isVa = (nargt > 0 && jl_is_vararg(jl_svecref(argt, nargt - 1)));\n    if (isVa) {\n        emit_error(ctx, \"cfunction: Vararg syntax not allowed for argument list\");\n        return jl_cgval_t();\n    }\n\n    jl_array_t *closure_types = NULL;\n    jl_value_t *sigt = NULL; // dispatch-sig = type signature with Ref{} annotations removed and applied to the env\n    JL_GC_PUSH4(&declrt, &sigt, &rt, &closure_types);\n    Type *lrt;\n    bool retboxed;\n    bool static_rt;\n    const std::string err = verify_ccall_sig(\n            /* inputs:  */\n            rt, (jl_value_t*)argt, unionall_env,\n            sparam_vals,\n            &ctx.emission_context,\n            /* outputs: */\n            lrt, retboxed, static_rt);\n    if (!err.empty()) {\n        emit_error(ctx, \"cfunction \" + err);\n        JL_GC_POP();\n        return jl_cgval_t();\n    }\n    if (rt != declrt && rt != (jl_value_t*)jl_any_type)\n        jl_add_method_root(ctx, rt);\n\n    function_sig_t sig(\"cfunction\", lrt, rt, retboxed, argt, unionall_env, false, CallingConv::C, false, &ctx.emission_context);\n    assert(sig.fargt.size() + sig.sret == sig.fargt_sig.size());\n    if (!sig.err_msg.empty()) {\n        emit_error(ctx, sig.err_msg);\n        JL_GC_POP();\n        return jl_cgval_t();\n    }\n\n    // compute+verify the dispatch signature, and see if it depends on the environment sparams\n    bool approx = false;\n    sigt = (jl_value_t*)jl_alloc_svec(nargt + 1);\n    jl_svecset(sigt, 0, fexpr_rt.typ);\n    if (!fexpr_rt.constant && (!jl_is_concrete_type(fexpr_rt.typ) || jl_is_kind(fexpr_rt.typ)))\n        approx = true;\n    for (size_t i = 0; i < nargt; i++) {\n        jl_value_t *jargty = jl_svecref(argt, i);\n        if (jl_is_abstract_ref_type(jargty)) {\n            jargty = jl_tparam0(jargty);\n            if (!verify_ref_type(ctx, jargty, unionall_env, i + 1, \"cfunction\")) {\n                JL_GC_POP();\n                return jl_cgval_t();\n            }\n        }\n        if (unionall_env && jl_has_typevar_from_unionall(jargty, unionall_env)) {\n            if (sparam_vals)\n                jargty = jl_instantiate_type_in_env(jargty, unionall_env, jl_svec_data(sparam_vals));\n            else\n                approx = true;\n        }\n        jl_svecset(sigt, i + 1, jargty);\n    }\n    if (approx) {\n        sigt = NULL;\n    }\n    else {\n        sigt = (jl_value_t*)jl_apply_tuple_type((jl_svec_t*)sigt);\n    }\n    if (sigt && !(unionall_env && jl_has_typevar_from_unionall(rt, unionall_env))) {\n        unionall_env = NULL;\n    }\n\n    bool nest = (!fexpr_rt.constant || unionall_env);\n#if defined(_CPU_AARCH64_) || defined(_CPU_ARM_) || defined(_CPU_PPC64_)\n    if (nest) {\n        emit_error(ctx, \"cfunction: closures are not supported on this platform\");\n        return jl_cgval_t();\n    }\n#endif\n    size_t world = jl_world_counter;\n    size_t min_valid = 0;\n    size_t max_valid = ~(size_t)0;\n    // try to look up this function for direct invoking\n    jl_method_instance_t *lam = sigt ? jl_get_specialization1((jl_tupletype_t*)sigt, world, &min_valid, &max_valid, 0) : NULL;\n    Value *F = gen_cfun_wrapper(\n            jl_Module, ctx.emission_context,\n            sig, fexpr_rt.constant, NULL,\n            declrt, lam,\n            unionall_env, sparam_vals, &closure_types);\n    bool outboxed;\n    if (nest) {\n        // F is actually an init_trampoline function that returns the real address\n        // Now fill in the nest parameters\n        Value *fobj = boxed(ctx, fexpr_rt);\n        jl_svec_t *fill = jl_emptysvec;\n        if (closure_types) {\n            assert(ctx.spvals_ptr);\n            size_t n = jl_array_len(closure_types);\n            jl_svec_t *fill = jl_alloc_svec_uninit(n);\n            for (size_t i = 0; i < n; i++) {\n                jl_svecset(fill, i, jl_array_ptr_ref(closure_types, i));\n            }\n            jl_add_method_root(ctx, (jl_value_t*)fill);\n        }\n        Type *T_htable = ArrayType::get(T_size, sizeof(htable_t) / sizeof(void*));\n        Value *cache = new GlobalVariable(*jl_Module, T_htable, false,\n                               GlobalVariable::PrivateLinkage,\n                               ConstantAggregateZero::get(T_htable));\n        F = ctx.builder.CreateCall(prepare_call(jlgetcfunctiontrampoline_func), {\n                 fobj,\n                 literal_pointer_val(ctx, output_type),\n                 ctx.builder.CreateBitCast(cache, T_pint8),\n                 literal_pointer_val(ctx, (jl_value_t*)fill),\n                 F,\n                 closure_types ? literal_pointer_val(ctx, (jl_value_t*)unionall_env) : V_null,\n                 closure_types ? ctx.spvals_ptr : ConstantPointerNull::get(cast<PointerType>(T_pprjlvalue))\n             });\n        outboxed = true;\n    }\n    else {\n        F = ctx.builder.CreatePtrToInt(F, T_size);\n        outboxed = (output_type != (jl_value_t*)jl_voidpointer_type);\n        if (outboxed) {\n            assert(jl_datatype_size(output_type) == sizeof(void*) * 4);\n            Value *strct = emit_allocobj(ctx, jl_datatype_size(output_type),\n                                         literal_pointer_val(ctx, (jl_value_t*)output_type));\n            Value *derived_strct = emit_bitcast(ctx, decay_derived(ctx, strct), T_psize);\n            MDNode *tbaa = best_tbaa(output_type);\n            tbaa_decorate(tbaa, ctx.builder.CreateStore(F, derived_strct));\n            tbaa_decorate(tbaa, ctx.builder.CreateStore(\n                ctx.builder.CreatePtrToInt(literal_pointer_val(ctx, fexpr_rt.constant), T_size),\n                ctx.builder.CreateConstInBoundsGEP1_32(T_size, derived_strct, 1)));\n            tbaa_decorate(tbaa, ctx.builder.CreateStore(V_size0,\n                    ctx.builder.CreateConstInBoundsGEP1_32(T_size, derived_strct, 2)));\n            tbaa_decorate(tbaa, ctx.builder.CreateStore(V_size0,\n                    ctx.builder.CreateConstInBoundsGEP1_32(T_size, derived_strct, 3)));\n            F = strct;\n        }\n    }\n    JL_GC_POP();\n    return mark_julia_type(ctx, F, outboxed, output_type);\n}\n\n// do codegen to create a C-callable alias/wrapper, or if sysimg_handle is set,\n// restore one from a loaded system image.\nconst char *jl_generate_ccallable(void *llvmmod, void *sysimg_handle, jl_value_t *declrt, jl_value_t *sigt, jl_codegen_params_t &params)\n{\n    jl_datatype_t *ft = (jl_datatype_t*)jl_tparam0(sigt);\n    jl_value_t *ff = ft->instance;\n    assert(ff);\n    const char *name = jl_symbol_name(ft->name->mt->name);\n    jl_value_t *crt = declrt;\n    if (jl_is_abstract_ref_type(declrt)) {\n        declrt = jl_tparam0(declrt);\n        crt = (jl_value_t*)jl_any_type;\n    }\n    bool toboxed;\n    Type *lcrt = _julia_struct_to_llvm(&params, crt, NULL, &toboxed);\n    if (toboxed)\n        lcrt = T_prjlvalue;\n    size_t nargs = jl_nparams(sigt)-1;\n    jl_svec_t *argtypes = NULL;\n    JL_GC_PUSH1(&argtypes);\n    argtypes = jl_alloc_svec(nargs);\n    for (size_t i = 0; i < nargs; i++) {\n        jl_svecset(argtypes, i, jl_tparam(sigt, i+1));\n    }\n    jl_value_t *err;\n    { // scope block for sig\n        function_sig_t sig(\"cfunction\", lcrt, crt, toboxed,\n                           argtypes, NULL, false, CallingConv::C, false, &params);\n        if (sig.err_msg.empty()) {\n            size_t world = jl_world_counter;\n            size_t min_valid = 0;\n            size_t max_valid = ~(size_t)0;\n            if (sysimg_handle) {\n                // restore a ccallable from the system image\n                void *addr;\n                int found = jl_dlsym(sysimg_handle, name, &addr, 0);\n                if (found)\n                    add_named_global(name, addr);\n            }\n            else {\n                jl_method_instance_t *lam = jl_get_specialization1((jl_tupletype_t*)sigt, world, &min_valid, &max_valid, 0);\n                gen_cfun_wrapper((Module*)llvmmod, params, sig, ff, name, declrt, lam, NULL, NULL, NULL);\n            }\n            JL_GC_POP();\n            return name;\n        }\n        err = jl_get_exceptionf(jl_errorexception_type, \"%s\", sig.err_msg.c_str());\n    }\n    jl_throw(err);\n}\n\n// generate a julia-callable function that calls f (AKA lam)\nstatic Function *gen_invoke_wrapper(jl_method_instance_t *lam, jl_value_t *jlretty, const jl_returninfo_t &f, int retarg, StringRef funcName,\n        Module *M, jl_codegen_params_t &params)\n{\n    Function *w = Function::Create(jl_func_sig, GlobalVariable::ExternalLinkage, funcName, M);\n    add_return_attr(w, Attribute::NonNull);\n    w->addFnAttr(Thunk);\n    jl_init_function(w);\n    Function::arg_iterator AI = w->arg_begin();\n    Value *funcArg = &*AI++;\n    Value *argArray = &*AI++;\n    Value *argCount = &*AI++; (void)argCount; // unused\n    //Value *mfunc = &*AI++; (void)mfunc; // unused\n    assert(AI == w->arg_end());\n\n    jl_codectx_t ctx(jl_LLVMContext, params);\n    ctx.f = w;\n    ctx.linfo = lam;\n    ctx.rettype = jlretty;\n    ctx.world = 0;\n\n    BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", w);\n    ctx.builder.SetInsertPoint(b0);\n    DebugLoc noDbg;\n    ctx.builder.SetCurrentDebugLocation(noDbg);\n    allocate_gc_frame(ctx, b0);\n\n    // TODO: replace this with emit_call_specfun_other?\n    FunctionType *ftype = f.decl->getFunctionType();\n    size_t nfargs = ftype->getNumParams();\n    Value **args = (Value**) alloca(nfargs * sizeof(Value*));\n    unsigned idx = 0;\n    AllocaInst *result = NULL;\n    switch (f.cc) {\n    case jl_returninfo_t::Boxed:\n    case jl_returninfo_t::Register:\n    case jl_returninfo_t::Ghosts:\n        break;\n    case jl_returninfo_t::SRet:\n        result = ctx.builder.CreateAlloca(ftype->getParamType(0)->getPointerElementType());\n        args[idx] = result;\n        idx++;\n        break;\n    case jl_returninfo_t::Union:\n        result = ctx.builder.CreateAlloca(ArrayType::get(T_int8, f.union_bytes));\n        if (f.union_align > 1)\n            result->setAlignment(Align(f.union_align));\n        args[idx] = result;\n        idx++;\n        break;\n    }\n    if (f.return_roots) {\n        AllocaInst *return_roots = emit_static_alloca(ctx, ArrayType::get(T_prjlvalue, f.return_roots));\n        args[idx] = return_roots;\n        idx++;\n    }\n\n    for (size_t i = 0; i < jl_nparams(lam->specTypes) && idx < nfargs; ++i) {\n        jl_value_t *ty = jl_nth_slot_type(lam->specTypes, i);\n        bool isboxed = deserves_argbox(ty);\n        Type *lty = isboxed ?  T_prjlvalue : julia_type_to_llvm(ctx, ty);\n        if (type_is_ghost(lty) || is_uniquerep_Type(ty))\n            continue;\n        Value *theArg;\n        if (i == 0) {\n            theArg = funcArg;\n        }\n        else {\n            Value *argPtr = ctx.builder.CreateConstInBoundsGEP1_32(T_prjlvalue, argArray, i - 1);\n            theArg = maybe_mark_load_dereferenceable(\n                    ctx.builder.CreateAlignedLoad(T_prjlvalue, argPtr, Align(sizeof(void*))),\n                    false,\n                    ty);\n        }\n        if (!isboxed) {\n            theArg = decay_derived(ctx, emit_bitcast(ctx, theArg, PointerType::get(lty, 0)));\n            if (!lty->isAggregateType()) // keep \"aggregate\" type values in place as pointers\n                theArg = ctx.builder.CreateAlignedLoad(theArg, Align(julia_alignment(ty)));\n        }\n        assert(dyn_cast<UndefValue>(theArg) == NULL);\n        args[idx] = theArg;\n        idx++;\n    }\n    CallInst *call = ctx.builder.CreateCall(f.decl, ArrayRef<Value*>(&args[0], nfargs));\n    call->setAttributes(f.decl->getAttributes());\n\n    jl_cgval_t retval;\n    if (retarg != -1) {\n        Value *theArg;\n        if (retarg == 0)\n            theArg = funcArg;\n        else\n            theArg = ctx.builder.CreateAlignedLoad(T_prjlvalue,\n                    ctx.builder.CreateConstInBoundsGEP1_32(T_prjlvalue, argArray, retarg - 1),\n                    Align(sizeof(void*)));\n        retval = mark_julia_type(ctx, theArg, true, jl_any_type);\n    }\n    else {\n        switch (f.cc) {\n        case jl_returninfo_t::Boxed:\n            retval = mark_julia_type(ctx, call, true, jlretty);\n            break;\n        case jl_returninfo_t::Register:\n            retval = mark_julia_type(ctx, call, false, jlretty);\n            break;\n        case jl_returninfo_t::SRet:\n            retval = mark_julia_slot(result, jlretty, NULL, tbaa_stack);\n            break;\n        case jl_returninfo_t::Union:\n            // result is technically not right here, but `boxed` will only look at it\n            // for the unboxed values, so it's ok.\n            retval = mark_julia_slot(result,\n                                     jlretty,\n                                     ctx.builder.CreateExtractValue(call, 1),\n                                     tbaa_stack);\n            retval.Vboxed = ctx.builder.CreateExtractValue(call, 0);\n            assert(retval.Vboxed->getType() == T_prjlvalue);\n            break;\n        case jl_returninfo_t::Ghosts:\n            retval = mark_julia_slot(NULL, jlretty, call, tbaa_stack);\n            break;\n        }\n    }\n    ctx.builder.CreateRet(boxed(ctx, retval));\n    assert(!ctx.roots);\n    return w;\n}\n\nstatic jl_returninfo_t get_specsig_function(jl_codectx_t &ctx, Module *M, StringRef name, jl_value_t *sig, jl_value_t *jlrettype)\n{\n    jl_returninfo_t props = {};\n    SmallVector<Type*, 8> fsig;\n    Type *rt;\n    Type *srt;\n    if (jl_is_structtype(jlrettype) && jl_is_datatype_singleton((jl_datatype_t*)jlrettype)) {\n        rt = T_void;\n        props.cc = jl_returninfo_t::Register;\n    }\n    else if (jl_is_uniontype(jlrettype)) {\n        bool allunbox;\n        union_alloca_type((jl_uniontype_t*)jlrettype, allunbox, props.union_bytes, props.union_align, props.union_minalign);\n        if (props.union_bytes) {\n            props.cc = jl_returninfo_t::Union;\n            Type *AT = ArrayType::get(T_int8, props.union_bytes);\n            fsig.push_back(AT->getPointerTo());\n            Type *pair[] = { T_prjlvalue, T_int8 };\n            rt = StructType::get(jl_LLVMContext, makeArrayRef(pair));\n        }\n        else if (allunbox) {\n            props.cc = jl_returninfo_t::Ghosts;\n            rt = T_int8;\n        }\n        else {\n            rt = T_prjlvalue;\n        }\n    }\n    else if (!deserves_retbox(jlrettype)) {\n        bool retboxed;\n        rt = julia_type_to_llvm(ctx, jlrettype, &retboxed);\n        assert(!retboxed);\n        if (rt != T_void && deserves_sret(jlrettype, rt)) {\n            auto tracked = CountTrackedPointers(rt);\n            assert(!tracked.derived);\n            if (tracked.count && !tracked.all)\n                props.return_roots = tracked.count;\n            props.cc = jl_returninfo_t::SRet;\n            fsig.push_back(rt->getPointerTo());\n            srt = rt;\n            rt = T_void;\n        }\n        else {\n            props.cc = jl_returninfo_t::Register;\n        }\n    }\n    else {\n        rt = T_prjlvalue;\n    }\n\n    AttributeList attributes; // function declaration attributes\n    if (props.cc == jl_returninfo_t::SRet) {\n        assert(srt);\n        unsigned argno = 1;\n#if JL_LLVM_VERSION < 120000\n        attributes = attributes.addAttribute(jl_LLVMContext, argno, Attribute::StructRet);\n        (void)srt; // silence unused variable error\n#else\n        Attribute sret = Attribute::getWithStructRetType(jl_LLVMContext, srt);\n        attributes = attributes.addAttribute(jl_LLVMContext, argno, sret);\n#endif\n        attributes = attributes.addAttribute(jl_LLVMContext, argno, Attribute::NoAlias);\n        attributes = attributes.addAttribute(jl_LLVMContext, argno, Attribute::NoCapture);\n    }\n    if (props.cc == jl_returninfo_t::Union) {\n        unsigned argno = 1;\n        attributes = attributes.addAttribute(jl_LLVMContext, argno, Attribute::NoAlias);\n        attributes = attributes.addAttribute(jl_LLVMContext, argno, Attribute::NoCapture);\n    }\n\n    if (props.return_roots) {\n        fsig.push_back(ArrayType::get(T_prjlvalue, props.return_roots)->getPointerTo(0));\n        unsigned argno = fsig.size();\n        attributes = attributes.addAttribute(jl_LLVMContext, argno, Attribute::NoAlias);\n        attributes = attributes.addAttribute(jl_LLVMContext, argno, Attribute::NoCapture);\n    }\n\n    for (size_t i = 0; i < jl_nparams(sig); i++) {\n        jl_value_t *jt = jl_tparam(sig, i);\n        if (is_uniquerep_Type(jt))\n            continue;\n        bool isboxed = deserves_argbox(jt);\n        Type *ty = isboxed ? T_prjlvalue : julia_type_to_llvm(ctx, jt);\n        if (type_is_ghost(ty))\n            continue;\n        unsigned argno = fsig.size();\n        if (ty->isAggregateType()) { // aggregate types are passed by pointer\n            attributes = attributes.addParamAttribute(jl_LLVMContext, argno, Attribute::NoCapture);\n            attributes = attributes.addParamAttribute(jl_LLVMContext, argno, Attribute::ReadOnly);\n            ty = PointerType::get(ty, AddressSpace::Derived);\n        }\n        else if (isboxed && jl_is_immutable_datatype(jt)) {\n            attributes = attributes.addParamAttribute(jl_LLVMContext, argno, Attribute::ReadOnly);\n        }\n        else if (jl_is_primitivetype(jt) && ty->isIntegerTy()) {\n            bool issigned = jl_signed_type && jl_subtype(jt, (jl_value_t*)jl_signed_type);\n            Attribute::AttrKind attr = issigned ? Attribute::SExt : Attribute::ZExt;\n            attributes = attributes.addParamAttribute(jl_LLVMContext, argno, attr);\n        }\n        fsig.push_back(ty);\n    }\n\n    FunctionType *ftype = FunctionType::get(rt, fsig, false);\n    Function *f = M ? cast_or_null<Function>(M->getNamedValue(name)) : NULL;\n    if (f == NULL) {\n        f = Function::Create(ftype, GlobalVariable::ExternalLinkage, name, M);\n        f->setAttributes(attributes);\n        jl_init_function(f);\n    }\n    else {\n        assert(f->getFunctionType() == ftype);\n    }\n    if (rt == T_prjlvalue)\n        add_return_attr(f, Attribute::NonNull);\n    props.decl = f;\n    return props;\n}\n\nstatic void emit_sret_roots(jl_codectx_t &ctx, bool isptr, Value *Src, Type *T, Value *Shadow, unsigned count)\n{\n    if (isptr)\n        Src = maybe_decay_tracked(ctx, Src);\n    if (isptr && Src->getType()->getPointerElementType() != T)\n        Src = ctx.builder.CreateBitCast(Src, T->getPointerTo(Src->getType()->getPointerAddressSpace()));\n    unsigned emitted = TrackWithShadow(Src, T, isptr, Shadow, ctx.builder);\n    assert(emitted == count); (void)emitted; (void)count;\n}\n\nstatic DISubroutineType *\nget_specsig_di(jl_codectx_t &ctx, jl_value_t *rt, jl_value_t *sig, DIBuilder &dbuilder)\n{\n    size_t nargs = jl_nparams(sig); // TODO: if this is a Varargs function, our debug info for the `...` var may be misleading\n    std::vector<Metadata*> ditypes(nargs + 1);\n    ditypes[0] = julia_type_to_di(ctx, rt, &dbuilder, false);\n    for (size_t i = 0; i < nargs; i++) {\n        jl_value_t *jt = jl_tparam(sig, i);\n        ditypes[i + 1] = julia_type_to_di(ctx, jt, &dbuilder, false);\n    }\n    return dbuilder.createSubroutineType(dbuilder.getOrCreateTypeArray(ditypes));\n}\n\nstatic jl_datatype_t *compute_va_type(jl_method_instance_t *lam, size_t nreq)\n{\n    size_t nvargs = jl_nparams(lam->specTypes)-nreq;\n    jl_svec_t *tupargs = jl_alloc_svec(nvargs);\n    JL_GC_PUSH1(&tupargs);\n    for (size_t i = nreq; i < jl_nparams(lam->specTypes); ++i) {\n        jl_value_t *argType = jl_nth_slot_type(lam->specTypes, i);\n        jl_svecset(tupargs, i-nreq, argType);\n    }\n    jl_datatype_t *typ = jl_apply_tuple_type(tupargs);\n    JL_GC_POP();\n    return typ;\n}\n\n// Compile to LLVM IR, using a specialized signature if applicable.\nstatic std::pair<std::unique_ptr<Module>, jl_llvm_functions_t>\n    emit_function(\n        jl_method_instance_t *lam,\n        jl_code_info_t *src,\n        jl_value_t *jlrettype,\n        jl_codegen_params_t &params,\n        bool vaOverride)\n{\n    // step 1. unpack AST and allocate codegen context for this function\n    jl_llvm_functions_t declarations;\n    jl_codectx_t ctx(jl_LLVMContext, params);\n    JL_GC_PUSH2(&ctx.code, &ctx.roots);\n    ctx.code = src->code;\n\n    std::map<int, BasicBlock*> labels;\n    bool toplevel = false;\n    ctx.module = jl_is_method(lam->def.method) ? lam->def.method->module : lam->def.module;\n    ctx.linfo = lam;\n    ctx.name = name_from_method_instance(lam);\n    size_t nreq = 0;\n    int va = 0;\n    if (jl_is_method(lam->def.method)) {\n        ctx.nargs = nreq = lam->def.method->nargs;\n        ctx.is_opaque_closure = lam->def.method->is_for_opaque_closure;\n        if (vaOverride ||\n            (nreq > 0 && jl_is_method(lam->def.value) && lam->def.method->isva)) {\n            assert(nreq > 0 && (ctx.is_opaque_closure || !vaOverride));\n            nreq--;\n            va = 1;\n        }\n    }\n    else {\n        ctx.nargs = 0;\n    }\n    ctx.nReqArgs = nreq;\n    if (va) {\n        jl_sym_t *vn = (jl_sym_t*)jl_array_ptr_ref(src->slotnames, ctx.nargs - 1);\n        if (vn != unused_sym)\n            ctx.vaSlot = ctx.nargs - 1;\n    }\n    toplevel = !jl_is_method(lam->def.method);\n    ctx.rettype = jlrettype;\n    ctx.source = src;\n    ctx.funcName = ctx.name;\n    ctx.spvals_ptr = NULL;\n    jl_array_t *stmts = ctx.code;\n    size_t stmtslen = jl_array_dim0(stmts);\n\n    // step 1b. unpack debug information\n    int coverage_mode = jl_options.code_coverage;\n    int malloc_log_mode = jl_options.malloc_log;\n    if (!JL_FEAT_TEST(ctx, code_coverage))\n        coverage_mode = JL_LOG_NONE;\n    if (!JL_FEAT_TEST(ctx, track_allocations))\n        malloc_log_mode = JL_LOG_NONE;\n\n    StringRef dbgFuncName = ctx.name;\n    int toplineno = -1;\n    if (lam && jl_is_method(lam->def.method)) {\n        toplineno = lam->def.method->line;\n        ctx.file = jl_symbol_name(lam->def.method->file);\n    }\n    else if (jl_array_len(src->linetable) > 0) {\n        jl_value_t *locinfo = jl_array_ptr_ref(src->linetable, 0);\n        ctx.file = jl_symbol_name((jl_sym_t*)jl_fieldref_noalloc(locinfo, 2));\n        toplineno = jl_unbox_long(jl_fieldref(locinfo, 3));\n    }\n    if (ctx.file.empty())\n        ctx.file = \"<missing>\";\n    // jl_printf(JL_STDERR, \"\\n*** compiling %s at %s:%d\\n\\n\",\n    //           jl_symbol_name(ctx.name), ctx.file.str().c_str(), toplineno);\n\n    ctx.debug_enabled = true;\n    if (dbgFuncName.empty()) // Should never happen anymore?\n        ctx.debug_enabled = 0;\n    if (jl_options.debug_level == 0)\n        ctx.debug_enabled = 0;\n\n    // step 2. process var-info lists to see what vars need boxing\n    int n_ssavalues = jl_is_long(src->ssavaluetypes) ? jl_unbox_long(src->ssavaluetypes) : jl_array_len(src->ssavaluetypes);\n    size_t vinfoslen = jl_array_dim0(src->slotflags);\n    ctx.slots.resize(vinfoslen);\n    assert(lam->specTypes); // the specTypes field should always be assigned\n\n\n    // create SAvalue locations for SSAValue objects\n    ctx.ssavalue_assigned.assign(n_ssavalues, false);\n    ctx.SAvalues.assign(n_ssavalues, jl_cgval_t());\n\n    bool specsig, needsparams;\n    std::tie(specsig, needsparams) = uses_specsig(lam, jlrettype, params.params->prefer_specsig);\n    if (!src->inferred)\n        specsig = false;\n\n    // step 3. some variable analysis\n    size_t i;\n    for (i = 0; i < nreq; i++) {\n        jl_varinfo_t &varinfo = ctx.slots[i];\n        varinfo.isArgument = true;\n        jl_sym_t *argname = (jl_sym_t*)jl_array_ptr_ref(src->slotnames, i);\n        if (argname == unused_sym)\n            continue;\n        jl_value_t *ty = jl_nth_slot_type(lam->specTypes, i);\n        // OpaqueClosure implicitly loads the env\n        if (i == 0 && ctx.is_opaque_closure) {\n            if (jl_is_array(src->slottypes)) {\n                ty = jl_arrayref((jl_array_t*)src->slottypes, i);\n            }\n            else {\n                ty = (jl_value_t*)jl_any_type;\n            }\n        }\n        varinfo.value = mark_julia_type(ctx, (Value*)NULL, false, ty);\n    }\n    if (va && ctx.vaSlot != -1) {\n        jl_varinfo_t &varinfo = ctx.slots[ctx.vaSlot];\n        varinfo.isArgument = true;\n        jl_datatype_t *vatyp = specsig ? compute_va_type(lam, nreq) : (jl_tuple_type);\n        varinfo.value = mark_julia_type(ctx, (Value*)NULL, false, vatyp);\n    }\n\n    for (i = 0; i < vinfoslen; i++) {\n        jl_varinfo_t &varinfo = ctx.slots[i];\n        uint8_t flags = jl_array_uint8_ref(src->slotflags, i);\n        varinfo.isSA = (jl_vinfo_sa(flags) != 0) || varinfo.isArgument;\n        varinfo.usedUndef = (jl_vinfo_usedundef(flags) != 0) || (!varinfo.isArgument && !src->inferred);\n        if (!varinfo.isArgument) {\n            varinfo.value = mark_julia_type(ctx, (Value*)NULL, false, (jl_value_t*)jl_any_type);\n        }\n    }\n\n    // finish recording variable use info\n    for (i = 0; i < stmtslen; i++)\n        simple_use_analysis(ctx, jl_array_ptr_ref(stmts, i));\n\n    // determine which vars need to be volatile\n    mark_volatile_vars(stmts, ctx.slots);\n\n    // step 4. determine function signature\n    if (!specsig)\n        ctx.nReqArgs--;  // function not part of argArray in jlcall\n\n    std::string _funcName;\n    raw_string_ostream funcName(_funcName);\n    // try to avoid conflicts in the global symbol table\n    if (specsig)\n        funcName << \"julia_\"; // api 5\n    else if (needsparams)\n        funcName << \"japi3_\";\n    else\n        funcName << \"japi1_\";\n    const char* unadorned_name = ctx.name;\n#if defined(_OS_LINUX_)\n    if (unadorned_name[0] == '@')\n        unadorned_name++;\n#endif\n    funcName << unadorned_name << \"_\" << globalUnique++;\n    declarations.specFunctionObject = funcName.str();\n\n    // allocate Function declarations and wrapper objects\n    Module *M = new Module(ctx.name, jl_LLVMContext);\n    jl_setup_module(M, ctx.params);\n    jl_returninfo_t returninfo = {};\n    Function *f = NULL;\n    bool has_sret = false;\n    if (specsig) { // assumes !va and !needsparams\n        returninfo = get_specsig_function(ctx, M, declarations.specFunctionObject, lam->specTypes, jlrettype);\n        f = returninfo.decl;\n        has_sret = (returninfo.cc == jl_returninfo_t::SRet || returninfo.cc == jl_returninfo_t::Union);\n        jl_init_function(f);\n\n        // common pattern: see if all return statements are an argument in that\n        // case the apply-generic call can re-use the original box for the return\n        int retarg = [stmts, nreq]() {\n            int retarg = -1;\n            for (size_t i = 0; i < jl_array_len(stmts); ++i) {\n                jl_value_t *stmt = jl_array_ptr_ref(stmts, i);\n                if (jl_is_returnnode(stmt)) {\n                    stmt = jl_returnnode_value(stmt);\n                    if (stmt == NULL)\n                        continue;\n                    if (!jl_is_argument(stmt))\n                        return -1;\n                    unsigned sl = jl_slot_number(stmt) - 1;\n                    if (sl >= nreq)\n                        return -1;\n                    if (retarg == -1)\n                        retarg = sl;\n                    else if ((unsigned)retarg != sl)\n                        return -1;\n                }\n            }\n            return retarg;\n        }();\n\n        std::string wrapName;\n        raw_string_ostream(wrapName) << \"jfptr_\" << unadorned_name << \"_\" << globalUnique++;\n        declarations.functionObject = wrapName;\n        (void)gen_invoke_wrapper(lam, jlrettype, returninfo, retarg, declarations.functionObject, M, ctx.emission_context);\n    }\n    else {\n        f = Function::Create(needsparams ? jl_func_sig_sparams : jl_func_sig,\n                             GlobalVariable::ExternalLinkage,\n                             declarations.specFunctionObject, M);\n        jl_init_function(f);\n        add_return_attr(f, Attribute::NonNull);\n        f->addFnAttr(Thunk);\n        // TODO: (if needsparams) add attributes: dereferenceable<sizeof(void*) * length(sp)>, readonly, nocapture\n        // TODO: add attributes: dereferenceable<sizeof(ft)>, readonly, nocapture - e.g. maybe_mark_argument_dereferenceable(Arg, argType);\n        // TODO: add attributes: dereferenceable<sizeof(void*) * nreq>, readonly, nocapture\n        returninfo.decl = f;\n        declarations.functionObject = needsparams ? \"jl_fptr_sparam\" : \"jl_fptr_args\";\n    }\n\n    if (jlrettype == (jl_value_t*)jl_bottom_type)\n        f->setDoesNotReturn();\n\n#ifdef USE_POLLY\n    if (!jl_has_meta(stmts, polly_sym) || jl_options.polly == JL_OPTIONS_POLLY_OFF) {\n        f->addFnAttr(polly::PollySkipFnAttr);\n    }\n#endif\n\n    if (jl_has_meta(stmts, noinline_sym)) {\n        f->addFnAttr(Attribute::NoInline);\n    }\n\n    if (returninfo.cc == jl_returninfo_t::Union) {\n        f->addAttribute(1, Attribute::getWithDereferenceableBytes(jl_LLVMContext, returninfo.union_bytes));\n        f->addAttribute(1, Attribute::getWithAlignment(jl_LLVMContext, Align(returninfo.union_align)));\n    }\n\n#ifdef JL_DEBUG_BUILD\n    f->addFnAttr(Attribute::StackProtectStrong);\n#endif\n\n#ifdef JL_TSAN_ENABLED\n    // TODO: enable this only when a argument like `-race` is passed to Julia\n    //       add a macro for no_sanitize_thread\n    f->addFnAttr(llvm::Attribute::SanitizeThread);\n#endif\n\n    // add the optimization level specified for this module, if any\n    int optlevel = jl_get_module_optlevel(ctx.module);\n    if (optlevel >= 0 && optlevel <= 3) {\n        static const char* const optLevelStrings[] = { \"0\", \"1\", \"2\", \"3\" };\n        f->addFnAttr(\"julia-optimization-level\", optLevelStrings[optlevel]);\n    }\n\n    ctx.f = f;\n\n    // Step 4b. determine debug info signature and other type info for locals\n    DIBuilder dbuilder(*M);\n    DIFile *topfile = NULL;\n    DISubprogram *SP = NULL;\n    DebugLoc noDbg, topdebugloc;\n    if (ctx.debug_enabled) {\n        DICompileUnit::DebugEmissionKind emissionKind = (DICompileUnit::DebugEmissionKind) ctx.params->debug_info_kind;\n        DICompileUnit::DebugNameTableKind tableKind;\n\n        if (JL_FEAT_TEST(ctx, gnu_pubnames)) {\n            tableKind = DICompileUnit::DebugNameTableKind::GNU;\n        }\n        else {\n            tableKind = DICompileUnit::DebugNameTableKind::None;\n        }\n        topfile = dbuilder.createFile(ctx.file, \".\");\n        DICompileUnit *CU =\n            dbuilder.createCompileUnit(llvm::dwarf::DW_LANG_Julia\n                                       ,topfile      // File\n                                       ,\"julia\"      // Producer\n                                       ,true         // isOptimized\n                                       ,\"\"           // Flags\n                                       ,0            // RuntimeVersion\n                                       ,\"\"           // SplitName\n                                       ,emissionKind // Kind\n                                       ,0            // DWOId\n                                       ,true         // SplitDebugInlining\n                                       ,false        // DebugInfoForProfiling\n                                       ,tableKind    // NameTableKind\n                                       );\n\n        DISubroutineType *subrty;\n        if (jl_options.debug_level <= 1) {\n            subrty = jl_di_func_null_sig;\n        }\n        else if (!specsig) {\n            subrty = jl_di_func_sig;\n        }\n        else {\n            subrty = get_specsig_di(ctx, jlrettype, lam->specTypes, dbuilder);\n        }\n        SP = dbuilder.createFunction(CU\n                                     ,dbgFuncName      // Name\n                                     ,f->getName()     // LinkageName\n                                     ,topfile          // File\n                                     ,toplineno        // LineNo\n                                     ,subrty           // Ty\n                                     ,toplineno        // ScopeLine\n                                     ,DINode::FlagZero // Flags\n                                     ,DISubprogram::SPFlagDefinition | DISubprogram::SPFlagOptimized // SPFlags\n                                     ,nullptr          // Template Parameters\n                                     ,nullptr          // Template Declaration\n                                     ,nullptr          // ThrownTypes\n                                     );\n        topdebugloc = DILocation::get(jl_LLVMContext, toplineno, 0, SP, NULL);\n        f->setSubprogram(SP);\n        if (jl_options.debug_level >= 2) {\n            const bool AlwaysPreserve = true;\n            // Go over all arguments and local variables and initialize their debug information\n            for (i = 0; i < nreq; i++) {\n                jl_sym_t *argname = (jl_sym_t*)jl_array_ptr_ref(src->slotnames, i);\n                if (argname == unused_sym)\n                    continue;\n                jl_varinfo_t &varinfo = ctx.slots[i];\n                varinfo.dinfo = dbuilder.createParameterVariable(\n                    SP,                                 // Scope (current function will be fill in later)\n                    jl_symbol_name(argname),            // Variable name\n                    has_sret + i + 1,                   // Argument number (1-based)\n                    topfile,                            // File\n                    toplineno == -1 ? 0 : toplineno,    // Line\n                    // Variable type\n                    julia_type_to_di(ctx, varinfo.value.typ, &dbuilder, false),\n                    AlwaysPreserve,                     // May be deleted if optimized out\n                    DINode::FlagZero);                  // Flags (TODO: Do we need any)\n            }\n            if (va && ctx.vaSlot != -1) {\n                ctx.slots[ctx.vaSlot].dinfo = dbuilder.createParameterVariable(\n                    SP,                                 // Scope (current function will be fill in later)\n                    std::string(jl_symbol_name(slot_symbol(ctx, ctx.vaSlot))) + \"...\",  // Variable name\n                    has_sret + nreq + 1,                // Argument number (1-based)\n                    topfile,                            // File\n                    toplineno == -1 ? 0 : toplineno,    // Line (for now, use lineno of the function)\n                    julia_type_to_di(ctx, ctx.slots[ctx.vaSlot].value.typ, &dbuilder, false),\n                    AlwaysPreserve,                     // May be deleted if optimized out\n                    DINode::FlagZero);                  // Flags (TODO: Do we need any)\n            }\n            for (i = 0; i < vinfoslen; i++) {\n                jl_sym_t *s = (jl_sym_t*)jl_array_ptr_ref(src->slotnames, i);\n                jl_varinfo_t &varinfo = ctx.slots[i];\n                if (varinfo.isArgument || s == empty_sym || s == unused_sym)\n                    continue;\n                // LLVM 4.0: Assume the variable has default alignment\n                varinfo.dinfo = dbuilder.createAutoVariable(\n                    SP,                      // Scope (current function will be fill in later)\n                    jl_symbol_name(s),       // Variable name\n                    topfile,                 // File\n                    toplineno == -1 ? 0 : toplineno, // Line (for now, use lineno of the function)\n                    julia_type_to_di(ctx, varinfo.value.typ, &dbuilder, false), // Variable type\n                    AlwaysPreserve,          // May be deleted if optimized out\n                    DINode::FlagZero         // Flags (TODO: Do we need any)\n                    );\n            }\n        }\n    }\n\n    // step 5. create first basic block\n    BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", f);\n    ctx.builder.SetInsertPoint(b0);\n    ctx.builder.SetCurrentDebugLocation(noDbg);\n\n    // spill arguments into stack slots\n    // so it is more likely to be possible to find them when debugging\n    Value *fArg=NULL, *argArray=NULL, *pargArray=NULL, *argCount=NULL;\n    if (!specsig) {\n        Function::arg_iterator AI = f->arg_begin();\n        fArg = &*AI++;\n        argArray = &*AI++;\n        pargArray = ctx.builder.CreateAlloca(argArray->getType());\n        ctx.builder.CreateStore(argArray, pargArray, true/*volatile store to prevent removal of this alloca*/);\n        argCount = &*AI++;\n        ctx.argArray = argArray;\n        ctx.argCount = argCount;\n        if (needsparams) {\n            ctx.spvals_ptr = &*AI++;\n        }\n    }\n\n    /*\n    // step 6. (optional) check for stack overflow (the slower way)\n    Value *cur_sp =\n        ctx.builder.CreateCall(Intrinsic::getDeclaration(M,\n                                                     Intrinsic::frameaddress),\n                           ConstantInt::get(T_int32, 0));\n    Value *sp_ok =\n        ctx.builder.CreateICmpUGT(cur_sp,\n                              ConstantInt::get(T_size,\n                                               (uptrint_t)jl_stack_lo));\n    error_unless(ctx, sp_ok, \"stack overflow\");\n    */\n\n    // step 7. set up GC frame\n    allocate_gc_frame(ctx, b0);\n    Value *last_age = NULL;\n    emit_last_age_field(ctx);\n    if (toplevel || ctx.is_opaque_closure) {\n        last_age = tbaa_decorate(tbaa_gcframe, ctx.builder.CreateAlignedLoad(ctx.world_age_field, Align(sizeof(size_t))));\n    }\n\n    // step 8. allocate local variables slots\n    // must be in the first basic block for the llvm mem2reg pass to work\n    auto allocate_local = [&](jl_varinfo_t &varinfo, jl_sym_t *s) {\n        jl_value_t *jt = varinfo.value.typ;\n        assert(!varinfo.boxroot); // variables shouldn't have memory locs already\n        if (varinfo.value.constant) {\n            // no need to explicitly load/store a constant/ghost value\n            alloc_def_flag(ctx, varinfo);\n            return;\n        }\n        else if (varinfo.isArgument && !(specsig && i == (size_t)ctx.vaSlot)) {\n            // if we can unbox it, just use the input pointer\n            if (i != (size_t)ctx.vaSlot && jl_is_concrete_immutable(jt))\n                return;\n        }\n        else if (jl_is_uniontype(jt)) {\n            bool allunbox;\n            size_t align, nbytes;\n            Value *lv = try_emit_union_alloca(ctx, (jl_uniontype_t*)jt, allunbox, align, nbytes);\n            if (lv) {\n                lv->setName(jl_symbol_name(s));\n                varinfo.value = mark_julia_slot(lv, jt, NULL, tbaa_stack);\n                varinfo.pTIndex = emit_static_alloca(ctx, T_int8);\n            }\n            else if (allunbox) {\n                // all ghost values just need a selector allocated\n                AllocaInst *lv = emit_static_alloca(ctx, T_int8);\n                lv->setName(jl_symbol_name(s));\n                varinfo.pTIndex = lv;\n                varinfo.value.tbaa = NULL;\n                varinfo.value.isboxed = false;\n            }\n            if (lv || allunbox)\n                alloc_def_flag(ctx, varinfo);\n            if (allunbox)\n                return;\n        }\n        else if (deserves_stack(jt, true)) {\n            bool isboxed;\n            Type *vtype = julia_type_to_llvm(ctx, jt, &isboxed);\n            assert(!isboxed);\n            assert(!type_is_ghost(vtype) && \"constants should already be handled\");\n            // CreateAlloca is OK during prologue setup\n            Value *lv = ctx.builder.CreateAlloca(vtype, NULL, jl_symbol_name(s));\n            varinfo.value = mark_julia_slot(lv, jt, NULL, tbaa_stack);\n            alloc_def_flag(ctx, varinfo);\n            if (ctx.debug_enabled && varinfo.dinfo) {\n                assert((Metadata*)varinfo.dinfo->getType() != jl_pvalue_dillvmt);\n                dbuilder.insertDeclare(lv, varinfo.dinfo, dbuilder.createExpression(),\n                                       topdebugloc,\n                                       ctx.builder.GetInsertBlock());\n            }\n            return;\n        }\n        if (!varinfo.isArgument || // always need a slot if the variable is assigned\n            specsig || // for arguments, give them stack slots if they aren't in `argArray` (otherwise, will use that pointer)\n            (va && (int)i == ctx.vaSlot) || // or it's the va arg tuple\n            i == 0) { // or it is the first argument (which isn't in `argArray`)\n            AllocaInst *av = new AllocaInst(T_prjlvalue, 0,\n                jl_symbol_name(s), /*InsertBefore*/ctx.ptlsStates);\n            StoreInst *SI = new StoreInst(V_rnull, av, false, Align(sizeof(void*)));\n            SI->insertAfter(ctx.ptlsStates);\n            varinfo.boxroot = av;\n            if (ctx.debug_enabled && varinfo.dinfo) {\n                DIExpression *expr;\n                if ((Metadata*)varinfo.dinfo->getType() == jl_pvalue_dillvmt) {\n                    expr = dbuilder.createExpression();\n                }\n                else {\n                    SmallVector<uint64_t, 8> addr;\n                    addr.push_back(llvm::dwarf::DW_OP_deref);\n                    expr = dbuilder.createExpression(addr);\n                }\n                dbuilder.insertDeclare(av, varinfo.dinfo, expr,\n                                            topdebugloc,\n                                ctx.builder.GetInsertBlock());\n            }\n        }\n    };\n\n    // get pointers for locals stored in the gc frame array (argTemp)\n    for (i = 0; i < vinfoslen; i++) {\n        jl_sym_t *s = slot_symbol(ctx, i);\n        if (s == unused_sym)\n            continue;\n        jl_varinfo_t &varinfo = ctx.slots[i];\n        if (!varinfo.used) {\n            varinfo.usedUndef = false;\n            continue;\n        }\n        allocate_local(varinfo, s);\n    }\n\n    std::map<int, int> upsilon_to_phic;\n\n    // Scan for PhiC nodes, emit their slots and record which upsilon nodes\n    // yield to them.\n    {\n        for (size_t i = 0; i < jl_array_len(stmts); ++i) {\n            jl_value_t *stmt = jl_array_ptr_ref(stmts, i);\n            if (jl_is_phicnode(stmt)) {\n                jl_array_t *values = (jl_array_t*)jl_fieldref_noalloc(stmt, 0);\n                for (size_t j = 0; j < jl_array_len(values); ++j) {\n                    jl_value_t *val = jl_array_ptr_ref(values, j);\n                    assert(jl_is_ssavalue(val));\n                    upsilon_to_phic[((jl_ssavalue_t*)val)->id] = i;\n                }\n                ctx.phic_slots[i] = jl_varinfo_t{};\n                jl_varinfo_t &vi = ctx.phic_slots[i];\n                jl_value_t *typ = jl_array_ptr_ref(src->ssavaluetypes, i);\n                vi.used = true;\n                vi.isVolatile = true;\n                vi.value = mark_julia_type(ctx, (Value*)NULL, false, typ);\n                allocate_local(vi, jl_symbol(\"phic\"));\n            }\n        }\n    }\n\n    // step 9. move args into local variables\n    Function::arg_iterator AI = f->arg_begin();\n\n    auto get_specsig_arg = [&](jl_value_t *argType, Type *llvmArgType, bool isboxed) {\n        jl_cgval_t theArg;\n        if (type_is_ghost(llvmArgType)) { // this argument is not actually passed\n            theArg = ghostValue(argType);\n        }\n        else if (is_uniquerep_Type(argType)) {\n            theArg = mark_julia_const(jl_tparam0(argType));\n        }\n        else if (llvmArgType->isAggregateType()) {\n            Argument *Arg = &*AI; ++AI;\n            maybe_mark_argument_dereferenceable(Arg, argType);\n            theArg = mark_julia_slot(Arg, argType, NULL, tbaa_const); // this argument is by-pointer\n        }\n        else {\n            Argument *Arg = &*AI; ++AI;\n            if (isboxed) // e.g. is-pointer\n                maybe_mark_argument_dereferenceable(Arg, argType);\n            theArg = mark_julia_type(ctx, Arg, isboxed, argType);\n            if (theArg.tbaa == tbaa_immut)\n                theArg.tbaa = tbaa_const;\n        }\n        return theArg;\n    };\n\n    if (has_sret)\n        AI++; // skip sret slot\n    if (returninfo.return_roots)\n        AI++; // skip return_roots slot\n    for (i = 0; i < nreq; i++) {\n        jl_sym_t *s = (jl_sym_t*)jl_array_ptr_ref(src->slotnames, i);\n        jl_value_t *argType = jl_nth_slot_type(lam->specTypes, i);\n        bool isboxed = deserves_argbox(argType);\n        Type *llvmArgType = isboxed ? T_prjlvalue : julia_type_to_llvm(ctx, argType);\n        if (s == unused_sym) {\n            if (specsig && !type_is_ghost(llvmArgType) && !is_uniquerep_Type(argType))\n                ++AI;\n            continue;\n        }\n        jl_varinfo_t &vi = ctx.slots[i];\n        jl_cgval_t theArg;\n        if (s == unused_sym || vi.value.constant) {\n            assert(vi.boxroot == NULL);\n            if (specsig && !type_is_ghost(llvmArgType) && !is_uniquerep_Type(argType))\n                ++AI;\n        }\n        else {\n            if (specsig) {\n                theArg = get_specsig_arg(argType, llvmArgType, isboxed);\n            }\n            else {\n                if (i == 0) {\n                    // first (function) arg is separate in jlcall\n                    theArg = mark_julia_type(ctx, fArg, true, ctx.is_opaque_closure ?\n                        argType : vi.value.typ);\n                }\n                else {\n                    Value *argPtr = ctx.builder.CreateInBoundsGEP(T_prjlvalue, argArray, ConstantInt::get(T_size, i-1));\n                    Value *load = maybe_mark_load_dereferenceable(\n                            ctx.builder.CreateAlignedLoad(T_prjlvalue, argPtr, Align(sizeof(void*))),\n                            false, vi.value.typ);\n                    theArg = mark_julia_type(ctx, load, true, vi.value.typ);\n                    if (ctx.debug_enabled && vi.dinfo && !vi.boxroot && !vi.value.V) {\n                        SmallVector<uint64_t, 8> addr;\n                        addr.push_back(llvm::dwarf::DW_OP_deref);\n                        addr.push_back(llvm::dwarf::DW_OP_plus_uconst);\n                        addr.push_back((i - 1) * sizeof(void*));\n                        if ((Metadata*)vi.dinfo->getType() != jl_pvalue_dillvmt)\n                            addr.push_back(llvm::dwarf::DW_OP_deref);\n                        dbuilder.insertDeclare(pargArray, vi.dinfo, dbuilder.createExpression(addr),\n                                        topdebugloc,\n                                        ctx.builder.GetInsertBlock());\n                    }\n                }\n            }\n\n            // If this is an opaque closure, implicitly load the env and switch\n            // the world age.\n            if (i == 0 && ctx.is_opaque_closure) {\n                jl_cgval_t closure_world = emit_getfield_knownidx(ctx, theArg, 2, (jl_datatype_t*)argType);\n                emit_unbox(ctx, T_size, closure_world, (jl_value_t*)jl_long_type, ctx.world_age_field, tbaa_gcframe);\n                theArg = convert_julia_type(ctx,\n                    emit_getfield_knownidx(ctx, theArg, 0, (jl_datatype_t*)argType),\n                    vi.value.typ);\n            }\n\n            if (vi.boxroot == NULL) {\n                assert(vi.value.V == NULL && \"unexpected variable slot created for argument\");\n                // keep track of original (possibly boxed) value to avoid re-boxing or moving\n                vi.value = theArg;\n                if (specsig && theArg.V && ctx.debug_enabled && vi.dinfo) {\n                    SmallVector<uint64_t, 8> addr;\n                    Value *parg;\n                    if (theArg.ispointer()) {\n                        parg = theArg.V;\n                        if ((Metadata*)vi.dinfo->getType() != jl_pvalue_dillvmt)\n                            addr.push_back(llvm::dwarf::DW_OP_deref);\n                    }\n                    else {\n                        parg = ctx.builder.CreateAlloca(theArg.V->getType(), NULL, jl_symbol_name(s));\n                        ctx.builder.CreateStore(theArg.V, parg);\n                    }\n                    dbuilder.insertDeclare(parg, vi.dinfo, dbuilder.createExpression(addr),\n                                                topdebugloc,\n                                                ctx.builder.GetInsertBlock());\n                }\n            }\n            else {\n                Value *argp = boxed(ctx, theArg);\n                ctx.builder.CreateStore(argp, vi.boxroot);\n            }\n        }\n    }\n\n    // step 10. allocate rest argument\n    CallInst *restTuple = NULL;\n    if (va && ctx.vaSlot != -1) {\n        jl_varinfo_t &vi = ctx.slots[ctx.vaSlot];\n        if (vi.value.constant || !vi.used) {\n            assert(vi.boxroot == NULL);\n        }\n        else if (specsig) {\n            ctx.nvargs = jl_nparams(lam->specTypes) - nreq;\n            jl_cgval_t *vargs = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * ctx.nvargs);\n            for (size_t i = nreq; i < jl_nparams(lam->specTypes); ++i) {\n                jl_value_t *argType = jl_nth_slot_type(lam->specTypes, i);\n                bool isboxed = deserves_argbox(argType);\n                Type *llvmArgType = isboxed ?  T_prjlvalue : julia_type_to_llvm(ctx, argType);\n                vargs[i - nreq] = get_specsig_arg(argType, llvmArgType, isboxed);\n            }\n            if (jl_is_concrete_type(vi.value.typ)) {\n                jl_cgval_t tuple = emit_new_struct(ctx, vi.value.typ, ctx.nvargs, vargs);\n                emit_varinfo_assign(ctx, vi, tuple);\n            }\n            else {\n                restTuple = emit_jlcall(ctx, jltuple_func, V_rnull,\n                    vargs, ctx.nvargs, JLCALL_F_CC);\n                jl_cgval_t tuple = mark_julia_type(ctx, restTuple, true, vi.value.typ);\n                emit_varinfo_assign(ctx, vi, tuple);\n            }\n        }\n        else {\n            // restarg = jl_f_tuple(NULL, &args[nreq], nargs - nreq)\n            Function *F = prepare_call(jltuple_func);\n            restTuple =\n                ctx.builder.CreateCall(F,\n                        { V_rnull,\n                          ctx.builder.CreateInBoundsGEP(T_prjlvalue, argArray,\n                                  ConstantInt::get(T_size, nreq - 1)),\n                          ctx.builder.CreateSub(argCount,\n                                  ConstantInt::get(T_int32, nreq - 1)) });\n            restTuple->setAttributes(F->getAttributes());\n            ctx.builder.CreateStore(restTuple, vi.boxroot);\n        }\n    }\n\n    // step 11. Compute properties for each statements\n    //     This needs to be computed by iterating in the IR order\n    //     instead of control flow order.\n    auto in_user_mod = [] (jl_module_t *mod) {\n        return (!jl_is_submodule(mod, jl_base_module) &&\n                !jl_is_submodule(mod, jl_core_module));\n    };\n    bool mod_is_user_mod = in_user_mod(ctx.module);\n    struct DebugLineTable {\n        DebugLoc loc;\n        StringRef file;\n        ssize_t line;\n        bool is_user_code;\n        unsigned inlined_at;\n        bool operator ==(const DebugLineTable &other) const {\n            return other.loc == loc && other.file == file && other.line == line && other.is_user_code == is_user_code && other.inlined_at == inlined_at;\n        }\n    };\n    std::vector<DebugLineTable> linetable;\n    { // populate the linetable data format\n        assert(jl_is_array(src->linetable));\n        size_t nlocs = jl_array_len(src->linetable);\n        std::map<std::tuple<StringRef, StringRef>, DISubprogram*> subprograms;\n        linetable.resize(nlocs + 1);\n        DebugLineTable &topinfo = linetable[0];\n        topinfo.file = ctx.file;\n        topinfo.line = toplineno;\n        topinfo.is_user_code = mod_is_user_mod;\n        topinfo.inlined_at = 0;\n        topinfo.loc = topdebugloc;\n        for (size_t i = 0; i < nlocs; i++) {\n            // LineInfoNode(mod::Module, method::Any, file::Symbol, line::Int, inlined_at::Int)\n            jl_value_t *locinfo = jl_array_ptr_ref(src->linetable, i);\n            DebugLineTable &info = linetable[i + 1];\n            assert(jl_typeis(locinfo, jl_lineinfonode_type));\n            jl_module_t *module = (jl_module_t*)jl_fieldref_noalloc(locinfo, 0);\n            jl_value_t *method = jl_fieldref_noalloc(locinfo, 1);\n            jl_sym_t *filesym = (jl_sym_t*)jl_fieldref_noalloc(locinfo, 2);\n            info.line = jl_unbox_long(jl_fieldref(locinfo, 3));\n            info.inlined_at = jl_unbox_long(jl_fieldref(locinfo, 4));\n            assert(info.inlined_at <= i);\n            if (module == ctx.module)\n                info.is_user_code = mod_is_user_mod;\n            else\n                info.is_user_code = in_user_mod(module);\n            info.file = jl_symbol_name(filesym);\n            if (info.file.empty())\n                info.file = \"<missing>\";\n            if (ctx.debug_enabled) {\n                StringRef fname;\n                if (jl_is_method_instance(method))\n                    method = ((jl_method_instance_t*)method)->def.value;\n                if (jl_is_method(method))\n                    method = (jl_value_t*)((jl_method_t*)method)->name;\n                if (jl_is_symbol(method))\n                    fname = jl_symbol_name((jl_sym_t*)method);\n                if (fname.empty())\n                    fname = \"macro expansion\";\n                if (info.inlined_at == 0 && info.file == ctx.file) { // if everything matches, emit a toplevel line number\n                    info.loc = DILocation::get(jl_LLVMContext, info.line, 0, SP, NULL);\n                }\n                else { // otherwise, describe this as an inlining frame\n                    DISubprogram *&inl_SP = subprograms[std::make_tuple(fname, info.file)];\n                    if (inl_SP == NULL) {\n                        DIFile *difile = dbuilder.createFile(info.file, \".\");\n                        inl_SP = dbuilder.createFunction(difile\n                                                     ,std::string(fname) + \";\" // Name\n                                                     ,fname            // LinkageName\n                                                     ,difile           // File\n                                                     ,0                // LineNo\n                                                     ,jl_di_func_null_sig // Ty\n                                                     ,0                // ScopeLine\n                                                     ,DINode::FlagZero // Flags\n                                                     ,DISubprogram::SPFlagDefinition | DISubprogram::SPFlagOptimized // SPFlags\n                                                     ,nullptr          // Template Parameters\n                                                     ,nullptr          // Template Declaration\n                                                     ,nullptr          // ThrownTypes\n                                                     );\n                    }\n                    DebugLoc inl_loc = (info.inlined_at == 0) ? DebugLoc(DILocation::get(jl_LLVMContext, 0, 0, SP, NULL)) : linetable.at(info.inlined_at).loc;\n                    info.loc = DILocation::get(jl_LLVMContext, info.line, 0, inl_SP, inl_loc);\n                }\n            }\n        }\n    }\n\n    std::vector<MDNode*> aliasscopes;\n    MDNode* current_aliasscope = nullptr;\n    std::vector<Metadata*> scope_stack;\n    std::vector<MDNode*> scope_list_stack;\n    {\n        size_t nstmts = jl_array_len(stmts);\n        aliasscopes.resize(nstmts + 1, nullptr);\n        MDBuilder mbuilder(jl_LLVMContext);\n        MDNode *alias_domain = mbuilder.createAliasScopeDomain(ctx.name);\n        for (i = 0; i < nstmts; i++) {\n            jl_value_t *stmt = jl_array_ptr_ref(stmts, i);\n            jl_expr_t *expr = jl_is_expr(stmt) ? (jl_expr_t*)stmt : nullptr;\n            if (expr) {\n                if (expr->head == aliasscope_sym) {\n                    MDNode *scope = mbuilder.createAliasScope(\"aliasscope\", alias_domain);\n                    scope_stack.push_back(scope);\n                    MDNode *scope_list = MDNode::get(jl_LLVMContext, ArrayRef<Metadata*>(scope_stack));\n                    scope_list_stack.push_back(scope_list);\n                    current_aliasscope = scope_list;\n                } else if (expr->head == popaliasscope_sym) {\n                    scope_stack.pop_back();\n                    scope_list_stack.pop_back();\n                    if (scope_list_stack.empty()) {\n                        current_aliasscope = NULL;\n                    } else {\n                        current_aliasscope = scope_list_stack.back();\n                    }\n                }\n            }\n            aliasscopes[i+1] = current_aliasscope;\n        }\n    }\n\n    Instruction &prologue_end = ctx.builder.GetInsertBlock()->back();\n\n\n    // step 12. Do codegen in control flow order\n    std::vector<int> workstack;\n    std::map<int, BasicBlock*> BB;\n    std::map<size_t, BasicBlock*> come_from_bb;\n    int cursor = 0;\n    auto find_next_stmt = [&] (int seq_next) {\n        // new style ir is always in dominance order, but frontend IR might not be\n        // `seq_next` is the next statement we want to emit\n        // i.e. if it exists, it's the next one following control flow and\n        // should be emitted into the current insert point.\n        if (seq_next >= 0 && (unsigned)seq_next < stmtslen) {\n            workstack.push_back(seq_next);\n        }\n        else if (!ctx.builder.GetInsertBlock()->getTerminator()) {\n            ctx.builder.CreateUnreachable();\n        }\n        while (!workstack.empty()) {\n            int item = workstack.back();\n            workstack.pop_back();\n            auto nextbb = BB.find(item + 1);\n            if (nextbb == BB.end()) {\n                cursor = item;\n                return;\n            }\n            if (seq_next != -1 && !ctx.builder.GetInsertBlock()->getTerminator()) {\n                come_from_bb[cursor + 1] = ctx.builder.GetInsertBlock();\n                ctx.builder.CreateBr(nextbb->second);\n            }\n            seq_next = -1;\n            // if this BB is non-empty, we've visited it before so skip it\n            if (!nextbb->second->getTerminator()) {\n                ctx.builder.SetInsertPoint(nextbb->second);\n                cursor = item;\n                return;\n            }\n        }\n        cursor = -1;\n    };\n\n    auto do_coverage = [&] (bool in_user_code) {\n        return (coverage_mode == JL_LOG_ALL ||\n                (coverage_mode == JL_LOG_USER && in_user_code));\n    };\n    auto do_malloc_log = [&] (bool in_user_code) {\n        return (malloc_log_mode == JL_LOG_ALL ||\n                (malloc_log_mode == JL_LOG_USER && in_user_code));\n    };\n    std::vector<unsigned> current_lineinfo, new_lineinfo;\n    auto coverageVisitStmt = [&] (size_t dbg) {\n        if (dbg == 0)\n            return;\n        // Compute inlining stack for current line, inner frame first\n        while (dbg) {\n            new_lineinfo.push_back(dbg);\n            dbg = linetable.at(dbg).inlined_at;\n        }\n        // Visit frames which differ from previous statement as tracked in\n        // current_lineinfo (tracked outer frame first).\n        current_lineinfo.resize(new_lineinfo.size(), 0);\n        for (dbg = 0; dbg < new_lineinfo.size(); dbg++) {\n            unsigned newdbg = new_lineinfo[new_lineinfo.size() - dbg - 1];\n            if (newdbg != current_lineinfo[dbg]) {\n                current_lineinfo[dbg] = newdbg;\n                const auto &info = linetable.at(newdbg);\n                if (do_coverage(info.is_user_code))\n                    coverageVisitLine(ctx, info.file, info.line);\n            }\n        }\n        new_lineinfo.clear();\n    };\n    auto mallocVisitStmt = [&] (unsigned dbg, Value *sync) {\n        if (!do_malloc_log(mod_is_user_mod) || dbg == 0) {\n            if (do_malloc_log(true) && sync)\n                ctx.builder.CreateCall(prepare_call(sync_gc_total_bytes_func), {sync});\n            return;\n        }\n        while (linetable.at(dbg).inlined_at)\n            dbg = linetable.at(dbg).inlined_at;\n        mallocVisitLine(ctx, ctx.file, linetable.at(dbg).line, sync);\n    };\n    if (coverage_mode != JL_LOG_NONE) {\n        // record all lines that could be covered\n        for (const auto &info : linetable)\n            if (do_coverage(info.is_user_code))\n                coverageAllocLine(info.file, info.line);\n    }\n\n    come_from_bb[0] = ctx.builder.GetInsertBlock();\n\n    // First go through and collect all branch targets, so we know where to\n    // split basic blocks.\n    std::set<int> branch_targets; // 1-indexed\n    {\n        for (size_t i = 0; i < stmtslen; ++i) {\n            jl_value_t *stmt = jl_array_ptr_ref(stmts, i);\n            if (jl_is_gotoifnot(stmt)) {\n                int dest = jl_gotoifnot_label(stmt);\n                branch_targets.insert(dest);\n                // The next 1-indexed statement\n                branch_targets.insert(i + 2);\n            } else if (jl_is_returnnode(stmt)) {\n                // We don't do dead branch elimination before codegen\n                // so we need to make sure to start a BB after any\n                // return node, even if they aren't otherwise branch\n                // targets.\n                if (i + 2 <= stmtslen)\n                    branch_targets.insert(i + 2);\n            } else if (jl_is_expr(stmt)) {\n                if (((jl_expr_t*)stmt)->head == enter_sym) {\n                    branch_targets.insert(i + 1);\n                    if (i + 2 <= stmtslen)\n                        branch_targets.insert(i + 2);\n                    int dest = jl_unbox_long(jl_array_ptr_ref(((jl_expr_t*)stmt)->args, 0));\n                    branch_targets.insert(dest);\n                }\n            } else if (jl_is_gotonode(stmt)) {\n                int dest = jl_gotonode_label(stmt);\n                branch_targets.insert(dest);\n                if (i + 2 <= stmtslen)\n                    branch_targets.insert(i + 2);\n            } else if (jl_is_phinode(stmt)) {\n                jl_array_t *edges = (jl_array_t*)jl_fieldref_noalloc(stmt, 0);\n                for (size_t j = 0; j < jl_array_len(edges); ++j) {\n                    size_t edge = ((int32_t*)jl_array_data(edges))[j];\n                    if (edge == i)\n                        branch_targets.insert(i + 1);\n                }\n            }\n        }\n    }\n\n    for (int label : branch_targets) {\n        BasicBlock *bb = BasicBlock::Create(jl_LLVMContext,\n            \"L\" + std::to_string(label), f);\n        BB[label] = bb;\n    }\n\n    Value *sync_bytes = nullptr;\n    if (do_malloc_log(true))\n        sync_bytes = ctx.builder.CreateCall(prepare_call(diff_gc_total_bytes_func), {});\n    { // coverage for the function definition line number\n        const auto &topinfo = linetable.at(0);\n        if (topinfo == linetable.at(1))\n            current_lineinfo.push_back(1);\n        if (do_coverage(topinfo.is_user_code))\n            coverageVisitLine(ctx, topinfo.file, topinfo.line);\n    }\n\n    find_next_stmt(0);\n    while (cursor != -1) {\n        int32_t debuginfoloc = ((int32_t*)jl_array_data(src->codelocs))[cursor];\n        if (debuginfoloc > 0) {\n            if (ctx.debug_enabled)\n                ctx.builder.SetCurrentDebugLocation(linetable.at(debuginfoloc).loc);\n            coverageVisitStmt(debuginfoloc);\n        }\n        ctx.aliasscope = aliasscopes[cursor];\n        jl_value_t *stmt = jl_array_ptr_ref(stmts, cursor);\n        jl_expr_t *expr = jl_is_expr(stmt) ? (jl_expr_t*)stmt : nullptr;\n        if (jl_is_returnnode(stmt)) {\n            jl_value_t *retexpr = jl_returnnode_value(stmt);\n            if (retexpr == NULL) {\n                ctx.builder.CreateUnreachable();\n                find_next_stmt(-1);\n                continue;\n            }\n            // this is basically a copy of emit_assignment,\n            // but where the assignment slot is the retval\n            jl_cgval_t retvalinfo = emit_expr(ctx, retexpr);\n            retvalinfo = convert_julia_type(ctx, retvalinfo, jlrettype);\n            if (retvalinfo.typ == jl_bottom_type) {\n                ctx.builder.CreateUnreachable();\n                find_next_stmt(-1);\n                continue;\n            }\n\n            Value *isboxed_union = NULL;\n            Value *retval = NULL;\n            Value *sret = has_sret ? f->arg_begin() : NULL;\n            Type *retty = f->getReturnType();\n            switch (returninfo.cc) {\n            case jl_returninfo_t::Boxed:\n                retval = boxed(ctx, retvalinfo); // skip the gcroot on the return path\n                break;\n            case jl_returninfo_t::Register:\n                if (type_is_ghost(retty))\n                    retval = NULL;\n                else\n                    retval = emit_unbox(ctx, retty, retvalinfo, jlrettype);\n                break;\n            case jl_returninfo_t::SRet:\n                retval = NULL;\n                break;\n            case jl_returninfo_t::Union: {\n                Value *data, *tindex;\n                if (retvalinfo.TIndex) {\n                    tindex = retvalinfo.TIndex;\n                    data = V_rnull;\n                    if (retvalinfo.V == NULL) {\n                        // treat this as a simple Ghosts\n                        sret = NULL;\n                    }\n                    else if (retvalinfo.Vboxed) {\n                        // also need to account for the possibility the return object is boxed\n                        // and avoid / skip copying it to the stack\n                        isboxed_union = ctx.builder.CreateICmpNE(\n                            ctx.builder.CreateAnd(tindex, ConstantInt::get(T_int8, 0x80)),\n                            ConstantInt::get(T_int8, 0));\n                        data = ctx.builder.CreateSelect(isboxed_union, retvalinfo.Vboxed, data);\n                    }\n                }\n                else {\n                    // treat this as a simple boxed returninfo\n                    //assert(retvalinfo.isboxed);\n                    tindex = compute_tindex_unboxed(ctx, retvalinfo, jlrettype);\n                    tindex = ctx.builder.CreateOr(tindex, ConstantInt::get(T_int8, 0x80));\n                    data = boxed(ctx, retvalinfo);\n                    sret = NULL;\n                }\n                retval = UndefValue::get(retty);\n                retval = ctx.builder.CreateInsertValue(retval, data, 0);\n                retval = ctx.builder.CreateInsertValue(retval, tindex, 1);\n                break;\n            }\n            case jl_returninfo_t::Ghosts:\n                retval = compute_tindex_unboxed(ctx, retvalinfo, jlrettype);\n                break;\n            }\n            if (sret) {\n                if (retvalinfo.ispointer()) {\n                    if (returninfo.return_roots) {\n                        Type *store_ty = julia_type_to_llvm(ctx, retvalinfo.typ);\n                        emit_sret_roots(ctx, true, data_pointer(ctx, retvalinfo), store_ty, f->arg_begin() + 1, returninfo.return_roots);\n                    }\n                    if (returninfo.cc == jl_returninfo_t::SRet) {\n                        assert(jl_is_concrete_type(jlrettype));\n                        emit_memcpy(ctx, sret, nullptr, retvalinfo, jl_datatype_size(jlrettype),\n                                    julia_alignment(jlrettype));\n                    }\n                    else { // must be jl_returninfo_t::Union\n                        emit_unionmove(ctx, sret, nullptr, retvalinfo, /*skip*/isboxed_union);\n                    }\n                }\n                else {\n                    Type *store_ty = retvalinfo.V->getType();\n                    Type *dest_ty = store_ty->getPointerTo();\n                    Value *Val = retvalinfo.V;\n                    if (returninfo.return_roots) {\n                        assert(julia_type_to_llvm(ctx, retvalinfo.typ) == store_ty);\n                        emit_sret_roots(ctx, false, Val, store_ty, f->arg_begin() + 1, returninfo.return_roots);\n                    }\n                    if (dest_ty != sret->getType())\n                        sret = emit_bitcast(ctx, sret, dest_ty);\n                    ctx.builder.CreateAlignedStore(Val, sret, Align(julia_alignment(retvalinfo.typ)));\n                    assert(retvalinfo.TIndex == NULL && \"unreachable\"); // unimplemented representation\n                }\n            }\n\n            mallocVisitStmt(debuginfoloc, sync_bytes);\n            if (toplevel || ctx.is_opaque_closure)\n                ctx.builder.CreateStore(last_age, ctx.world_age_field);\n            assert(type_is_ghost(retty) || returninfo.cc == jl_returninfo_t::SRet ||\n                retval->getType() == ctx.f->getReturnType());\n            ctx.builder.CreateRet(retval);\n            find_next_stmt(-1);\n            continue;\n        }\n        if (jl_is_gotonode(stmt)) {\n            int lname = jl_gotonode_label(stmt);\n            come_from_bb[cursor+1] = ctx.builder.GetInsertBlock();\n            ctx.builder.CreateBr(BB[lname]);\n            find_next_stmt(lname - 1);\n            continue;\n        }\n        if (jl_is_upsilonnode(stmt)) {\n            emit_upsilonnode(ctx, upsilon_to_phic[cursor + 1], jl_fieldref_noalloc(stmt, 0));\n            find_next_stmt(cursor + 1);\n            continue;\n        }\n        if (jl_is_gotoifnot(stmt)) {\n            jl_value_t *cond = jl_gotoifnot_cond(stmt);\n            int lname = jl_gotoifnot_label(stmt);\n            Value *isfalse = emit_condition(ctx, cond, \"if\");\n            mallocVisitStmt(debuginfoloc, nullptr);\n            come_from_bb[cursor+1] = ctx.builder.GetInsertBlock();\n            workstack.push_back(lname - 1);\n            BasicBlock *ifnot = BB[lname];\n            BasicBlock *ifso = BB[cursor+2];\n            if (ifnot == ifso)\n                ctx.builder.CreateBr(ifnot);\n            else\n                ctx.builder.CreateCondBr(isfalse, ifnot, ifso);\n            find_next_stmt(cursor + 1);\n            continue;\n        }\n        else if (expr && expr->head == enter_sym) {\n            jl_value_t **args = (jl_value_t**)jl_array_data(expr->args);\n\n            assert(jl_is_long(args[0]));\n            int lname = jl_unbox_long(args[0]);\n            // Save exception stack depth at enter for use in pop_exception\n            Value *excstack_state =\n                ctx.builder.CreateCall(prepare_call(jl_excstack_state_func));\n            assert(!ctx.ssavalue_assigned.at(cursor));\n            ctx.SAvalues.at(cursor) = jl_cgval_t(excstack_state, NULL, false,\n                                                 (jl_value_t*)jl_ulong_type, NULL);\n            ctx.ssavalue_assigned.at(cursor) = true;\n            CallInst *sj = ctx.builder.CreateCall(prepare_call(except_enter_func));\n            // We need to mark this on the call site as well. See issue #6757\n            sj->setCanReturnTwice();\n            Value *isz = ctx.builder.CreateICmpEQ(sj, ConstantInt::get(T_int32, 0));\n            BasicBlock *tryblk = BasicBlock::Create(jl_LLVMContext, \"try\", f);\n            BasicBlock *handlr = NULL;\n            handlr = BB[lname];\n            workstack.push_back(lname - 1);\n            come_from_bb[cursor + 1] = ctx.builder.GetInsertBlock();\n            ctx.builder.CreateCondBr(isz, tryblk, handlr);\n            ctx.builder.SetInsertPoint(tryblk);\n        }\n        else {\n            emit_stmtpos(ctx, stmt, cursor);\n            mallocVisitStmt(debuginfoloc, nullptr);\n        }\n        find_next_stmt(cursor + 1);\n    }\n\n    // Delete any unreachable blocks\n    for (auto &item : BB) {\n        if (!item.second->getTerminator())\n            item.second->eraseFromParent();\n    }\n\n    ctx.builder.SetCurrentDebugLocation(noDbg);\n    ctx.builder.ClearInsertionPoint();\n\n    auto undef_value_for_type = [&](Type *T) {\n        auto tracked = CountTrackedPointers(T);\n        Constant *undef;\n        if (tracked.count)\n            // make sure gc pointers (including ptr_phi of union-split) are initialized to NULL\n            undef = Constant::getNullValue(T);\n        else\n            undef = UndefValue::get(T);\n        return undef;\n    };\n\n    // Codegen Phi nodes\n    std::map<std::pair<BasicBlock*, BasicBlock*>, BasicBlock*> BB_rewrite_map;\n    std::vector<llvm::PHINode*> ToDelete;\n    for (auto &tup : ctx.PhiNodes) {\n        jl_cgval_t phi_result;\n        PHINode *VN;\n        jl_value_t *r;\n        AllocaInst *dest;\n        BasicBlock *PhiBB;\n        std::tie(phi_result, PhiBB, dest, VN, r) = tup;\n        jl_value_t *phiType = phi_result.typ;\n        jl_array_t *edges = (jl_array_t*)jl_fieldref_noalloc(r, 0);\n        jl_array_t *values = (jl_array_t*)jl_fieldref_noalloc(r, 1);\n        PHINode *TindexN = cast_or_null<PHINode>(phi_result.TIndex);\n        DenseSet<BasicBlock*> preds;\n        for (size_t i = 0; i < jl_array_len(edges); ++i) {\n            size_t edge = ((int32_t*)jl_array_data(edges))[i];\n            jl_value_t *value = jl_array_ptr_ref(values, i);\n            // This edge value is undef, handle it the same as if the edge wasn't listed at all\n            if (!value)\n                continue;\n            BasicBlock *FromBB = come_from_bb[edge];\n            // This edge was statically unreachable. Don't codegen it.\n            if (!FromBB)\n                continue;\n            // see if this edge has already been rewritten\n            // (we'll continue appending blocks to the current end)\n            std::pair<BasicBlock*, BasicBlock*> LookupKey(FromBB, PhiBB);\n            if (BB_rewrite_map.count(LookupKey)) {\n                FromBB = BB_rewrite_map[LookupKey];\n            }\n            if (!preds.insert(FromBB).second) {\n                // Only codegen this branch once for each PHI (the expression must be the same on all branches)\n#ifndef NDEBUG\n                for (size_t j = 0; j < i; ++j) {\n                    size_t j_edge = ((int32_t*)jl_array_data(edges))[j];\n                    if (j_edge == edge) {\n                        assert(jl_egal(value, jl_array_ptr_ref(values, j)));\n                    }\n                }\n#endif\n                continue;\n            }\n            assert(find(pred_begin(PhiBB), pred_end(PhiBB), FromBB) != pred_end(PhiBB)); // consistency check\n            TerminatorInst *terminator = FromBB->getTerminator();\n            if (!terminator->getParent()->getUniqueSuccessor()) {\n                // Can't use `llvm::SplitCriticalEdge` here because\n                // we may have invalid phi nodes in the destination.\n                BasicBlock *NewBB = BasicBlock::Create(terminator->getContext(),\n                   FromBB->getName() + \".\" + PhiBB->getName() + \"_crit_edge\");\n                Function::iterator FBBI = FromBB->getIterator();\n                ctx.f->getBasicBlockList().insert(++FBBI, NewBB); // insert after existing block\n                terminator->replaceSuccessorWith(PhiBB, NewBB);\n                DebugLoc Loc = terminator->getDebugLoc();\n                terminator = BranchInst::Create(PhiBB);\n                terminator->setDebugLoc(Loc);\n                ctx.builder.SetInsertPoint(NewBB);\n            }\n            else {\n                terminator->removeFromParent();\n                ctx.builder.SetInsertPoint(FromBB);\n            }\n            if (dest)\n                ctx.builder.CreateLifetimeStart(dest);\n            jl_cgval_t val = emit_expr(ctx, value);\n            if (val.constant)\n                val = mark_julia_const(val.constant); // be over-conservative at making sure `.typ` is set concretely, not tindex\n            if (!jl_is_uniontype(phiType) || !TindexN) {\n                Type *lty = julia_type_to_llvm(ctx, phiType);\n                if (VN) {\n                    Value *V;\n                    if (val.typ == (jl_value_t*)jl_bottom_type) {\n                        V = undef_value_for_type(VN->getType());\n                    }\n                    else if (VN->getType() == T_prjlvalue) {\n                        // Includes the jl_is_uniontype(phiType) && !TindexN case\n                        // TODO: if convert_julia_type says it is wasted effort and to skip it, is it worth using V_rnull (dynamically)?\n                        V = boxed(ctx, val);\n                    }\n                    else {\n                        // must be careful to emit undef here (rather than a bitcast or\n                        // load of val) if the runtime type of val isn't phiType\n                        Value *isvalid = emit_isa(ctx, val, phiType, NULL).first;\n                        V = emit_guarded_test(ctx, isvalid, undef_value_for_type(VN->getType()), [&] {\n                            return emit_unbox(ctx, VN->getType(), val, phiType);\n                        });\n                    }\n                    VN->addIncoming(V, ctx.builder.GetInsertBlock());\n                    assert(!TindexN);\n                }\n                else if (dest && val.typ != (jl_value_t*)jl_bottom_type) {\n                    // must be careful to emit undef here (rather than a bitcast or\n                    // load of val) if the runtime type of val isn't phiType\n                    assert(lty != T_prjlvalue);\n                    Value *isvalid = emit_isa(ctx, val, phiType, NULL).first;\n                    emit_guarded_test(ctx, isvalid, nullptr, [&] {\n                        (void)emit_unbox(ctx, lty, val, phiType, maybe_decay_tracked(ctx, dest));\n                        return nullptr;\n                    });\n                }\n            }\n            else {\n                Value *RTindex;\n                // The branch below is a bit too complex for GCC to realize that\n                // `V` is always initialized when it is used.\n                // Ref https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96629\n                Value *V = nullptr;\n                if (val.typ == (jl_value_t*)jl_bottom_type) {\n                    if (VN)\n                        V = undef_value_for_type(VN->getType());\n                    RTindex = UndefValue::get(T_int8);\n                }\n                else if (jl_is_concrete_type(val.typ) || val.constant) {\n                    size_t tindex = get_box_tindex((jl_datatype_t*)val.typ, phiType);\n                    if (tindex == 0) {\n                        if (VN)\n                            V = boxed(ctx, val);\n                        RTindex = ConstantInt::get(T_int8, 0x80);\n                    }\n                    else {\n                        if (VN)\n                            V = V_rnull;\n                        Type *lty = julia_type_to_llvm(ctx, val.typ);\n                        if (dest && !type_is_ghost(lty)) // basically, if !ghost union\n                            emit_unbox(ctx, lty, val, val.typ, dest);\n                        RTindex = ConstantInt::get(T_int8, tindex);\n                    }\n                }\n                else {\n                    Value *skip = NULL;\n                    // must compute skip here, since the runtime type of val might not be in phiType\n                    // caution: only Phi and PhiC are allowed to do this (and maybe sometimes Pi)\n                    jl_cgval_t new_union = convert_julia_type(ctx, val, phiType, &skip);\n                    RTindex = new_union.TIndex;\n                    if (!RTindex) {\n                        assert(new_union.isboxed && new_union.Vboxed && \"convert_julia_type failed\");\n                        RTindex = compute_tindex_unboxed(ctx, new_union, phiType);\n                        if (dest) {\n                            // If dest is not set, this is a ghost union, the recipient of which\n                            // is often not prepared to handle a boxed representation of the ghost.\n                            RTindex = ctx.builder.CreateOr(RTindex, ConstantInt::get(T_int8, 0x80));\n                        }\n                        new_union.TIndex = RTindex;\n                    }\n                    if (VN)\n                        V = new_union.Vboxed ? new_union.Vboxed : V_rnull;\n                    if (dest) { // basically, if !ghost union\n                        if (new_union.Vboxed != nullptr) {\n                            Value *isboxed = ctx.builder.CreateICmpNE( // if 0x80 is set, we won't select this slot anyways\n                                    ctx.builder.CreateAnd(RTindex, ConstantInt::get(T_int8, 0x80)),\n                                    ConstantInt::get(T_int8, 0));\n                            skip = skip ? ctx.builder.CreateOr(isboxed, skip) : isboxed;\n                        }\n                        emit_unionmove(ctx, dest, tbaa_arraybuf, new_union, skip);\n                    }\n                }\n                if (VN)\n                    VN->addIncoming(V, ctx.builder.GetInsertBlock());\n                if (TindexN)\n                    TindexN->addIncoming(RTindex, ctx.builder.GetInsertBlock());\n            }\n            // put the branch back at the end of our current basic block\n            ctx.builder.Insert(terminator);\n            // Record the current tail of this Phi edge in the rewrite map and\n            // check any phi nodes in the Phi block to see if by emitting on the edges\n            // we made things inconsistent.\n            BasicBlock *NewBB = ctx.builder.GetInsertBlock();\n            if (FromBB != NewBB) {\n                BB_rewrite_map[LookupKey] = NewBB;\n                preds.insert(NewBB);\n                PhiBB->replacePhiUsesWith(FromBB, NewBB);\n            }\n            ctx.builder.ClearInsertionPoint();\n        }\n        // In LLVM IR it is illegal to have phi nodes without incoming values, even if\n        // there are no operands (no incoming branches), so delete any such phi nodes\n        if (pred_empty(PhiBB)) {\n            if (VN)\n                ToDelete.push_back(VN);\n            if (TindexN)\n                ToDelete.push_back(TindexN);\n            continue;\n        }\n        // Julia PHINodes may be incomplete with respect to predecessors, LLVM's may not\n        for (auto *FromBB : predecessors(PhiBB)) {\n            if (preds.count(FromBB))\n                continue;\n            ctx.builder.SetInsertPoint(FromBB->getTerminator());\n            // PHI is undef on this branch. But still may need to put a valid pointer in place.\n            Value *RTindex = TindexN ? UndefValue::get(T_int8) : NULL;\n            if (VN) {\n                Value *undef = undef_value_for_type(VN->getType());\n                VN->addIncoming(undef, FromBB);\n                if (TindexN) // let the runtime / optimizer know this is unknown / boxed / null, so that it won't try to union_move / copy it later\n                    RTindex = ConstantInt::get(T_int8, 0x80);\n            }\n            if (TindexN)\n                TindexN->addIncoming(RTindex, FromBB);\n            if (dest) {\n                ctx.builder.CreateLifetimeStart(dest);\n                if (CountTrackedPointers(dest->getAllocatedType()).count)\n                    ctx.builder.CreateStore(Constant::getNullValue(dest->getAllocatedType()), dest);\n            }\n            ctx.builder.ClearInsertionPoint();\n        }\n    }\n\n    for (PHINode *PN : ToDelete) {\n        PN->replaceAllUsesWith(UndefValue::get(PN->getType()));\n        PN->eraseFromParent();\n    }\n\n    // step 13. Perform any delayed instantiations\n    if (ctx.debug_enabled) {\n        bool in_prologue = true;\n        for (auto &BB : *ctx.f) {\n            for (auto &I : BB) {\n                CallBase *call = dyn_cast<CallBase>(&I);\n                if (call && !I.getDebugLoc()) {\n                    // LLVM Verifier: inlinable function call in a function with debug info must have a !dbg location\n                    // make sure that anything we attempt to call has some inlining info, just in case optimization messed up\n                    // (except if we know that it is an intrinsic used in our prologue, which should never have its own debug subprogram)\n                    Function *F = call->getCalledFunction();\n                    if (!in_prologue || !F || !(F->isIntrinsic() || F->getName().startswith(\"julia.\") || &I == restTuple)) {\n                        I.setDebugLoc(topdebugloc);\n                    }\n                }\n                if (&I == &prologue_end)\n                    in_prologue = false;\n            }\n        }\n        dbuilder.finalize();\n    }\n\n    if (ctx.vaSlot > 0) {\n        // remove VA allocation if we never referenced it\n        Instruction *root = cast_or_null<Instruction>(ctx.slots[ctx.vaSlot].boxroot);\n        if (root) {\n            Instruction *store_value = NULL;\n            bool have_real_use = false;\n            for (Use &U : root->uses()) {\n                User *RU = U.getUser();\n                if (StoreInst *SRU = dyn_cast<StoreInst>(RU)) {\n                    if (!store_value)\n                        store_value = dyn_cast<Instruction>(SRU->getValueOperand());\n                }\n                else if (isa<DbgInfoIntrinsic>(RU)) {\n                }\n                else if (isa<LoadInst>(RU) && RU->use_empty()) {\n                }\n                else {\n                    have_real_use = true;\n                    break;\n                }\n            }\n            if (!have_real_use) {\n                Instruction *use = NULL;\n                for (Use &U : root->uses()) {\n                    if (use) // erase after the iterator moves on\n                        use->eraseFromParent();\n                    User *RU = U.getUser();\n                    use = cast<Instruction>(RU);\n                }\n                if (use)\n                    use->eraseFromParent();\n                root->eraseFromParent();\n                assert(!store_value || store_value == restTuple);\n                restTuple->eraseFromParent();\n            }\n        }\n    }\n\n    // copy ctx.roots into m->roots\n    // if we created any new roots during codegen\n    if (ctx.roots) {\n        jl_method_t *m = lam->def.method;\n        JL_LOCK(&m->writelock);\n        if (m->roots == NULL) {\n            m->roots = ctx.roots;\n            jl_gc_wb(m, m->roots);\n        }\n        else {\n            size_t i, ilen = jl_array_dim0(ctx.roots);\n            size_t j, jlen = jl_array_dim0(m->roots);\n            for (i = 0; i < ilen; i++) {\n                jl_value_t *ival = jl_array_ptr_ref(ctx.roots, i);\n                for (j = 0; j < jlen; j++) {\n                    jl_value_t *jval = jl_array_ptr_ref(m->roots, j);\n                    if (ival == jval)\n                        break;\n                }\n                if (j == jlen) // not found - add to array\n                    jl_array_ptr_1d_push(m->roots, ival);\n            }\n        }\n        ctx.roots = NULL;\n        JL_UNLOCK(&m->writelock);\n    }\n\n    // link the dependent llvmcall modules, but switch their function's linkage to private\n    // so that they don't show up in the execution engine.\n    for (auto &Mod : ctx.llvmcall_modules) {\n        SmallVector<std::string, 1> Exports;\n        for (const auto &F: Mod->functions())\n            if (!F.isDeclaration())\n                Exports.push_back(F.getName().str());\n        if (Linker::linkModules(*jl_Module, std::move(Mod))) {\n            jl_error(\"Failed to link LLVM bitcode\");\n        }\n        for (auto FN: Exports)\n            jl_Module->getFunction(FN)->setLinkage(GlobalVariable::PrivateLinkage);\n    }\n\n    // link in opaque closure modules\n    for (auto &Mod : ctx.oc_modules) {\n        SmallVector<std::string, 1> Exports;\n        for (const auto &F: Mod->functions())\n            if (!F.isDeclaration())\n                Exports.push_back(F.getName().str());\n        jl_merge_module(jl_Module, std::move(Mod));\n        for (auto FN: Exports)\n            jl_Module->getFunction(FN)->setLinkage(GlobalVariable::PrivateLinkage);\n    }\n\n    JL_GC_POP();\n    return std::make_pair(std::unique_ptr<Module>(M), declarations);\n}\n\n// --- entry point ---\n\nvoid jl_add_code_in_flight(StringRef name, jl_code_instance_t *codeinst, const DataLayout &DL);\n\nJL_GCC_IGNORE_START(\"-Wclobbered\")\njl_compile_result_t jl_emit_code(\n        jl_method_instance_t *li,\n        jl_code_info_t *src,\n        jl_value_t *jlrettype,\n        jl_codegen_params_t &params)\n{\n    JL_TIMING(CODEGEN);\n    // caller must hold codegen_lock\n    jl_llvm_functions_t decls = {};\n    std::unique_ptr<Module> m;\n    assert((params.params == &jl_default_cgparams /* fast path */ || !params.cache ||\n        compare_cgparams(params.params, &jl_default_cgparams)) &&\n        \"functions compiled with custom codegen params must not be cached\");\n    JL_TRY {\n        std::tie(m, decls) = emit_function(li, src, jlrettype, params);\n        if (dump_emitted_mi_name_stream != NULL) {\n            jl_printf(dump_emitted_mi_name_stream, \"%s\\t\", decls.specFunctionObject.c_str());\n            // NOTE: We print the Type Tuple without surrounding quotes, because the quotes\n            // break CSV parsing if there are any internal quotes in the Type name (e.g. in\n            // Symbol(\"...\")). The \\t delineator should be enough to ensure whitespace is\n            // handled correctly. (And we don't need to worry about any tabs in the printed\n            // string, because tabs are printed as \"\\t\" by `show`.)\n            jl_static_show(dump_emitted_mi_name_stream, li->specTypes);\n            jl_printf(dump_emitted_mi_name_stream, \"\\n\");\n        }\n    }\n    JL_CATCH {\n        // Something failed! This is very, very bad.\n        // Try to pretend that it isn't and attempt to recover.\n        m.reset();\n        decls.functionObject = \"\";\n        decls.specFunctionObject = \"\";\n        const char *mname = name_from_method_instance(li);\n        jl_printf((JL_STREAM*)STDERR_FILENO, \"Internal error: encountered unexpected error during compilation of %s:\\n\", mname);\n        jl_static_show((JL_STREAM*)STDERR_FILENO, jl_current_exception());\n        jl_printf((JL_STREAM*)STDERR_FILENO, \"\\n\");\n        jlbacktrace(); // written to STDERR_FILENO\n    }\n\n    return std::make_tuple(std::move(m), decls);\n}\n\njl_compile_result_t jl_emit_codeinst(\n        jl_code_instance_t *codeinst,\n        jl_code_info_t *src,\n        jl_codegen_params_t &params)\n{\n    JL_TIMING(CODEGEN);\n    JL_GC_PUSH1(&src);\n    if (!src) {\n        src = (jl_code_info_t*)codeinst->inferred;\n        jl_method_t *def = codeinst->def->def.method;\n        if (src && (jl_value_t*)src != jl_nothing && jl_is_method(def))\n            src = jl_uncompress_ir(def, codeinst, (jl_array_t*)src);\n        if (!src || !jl_is_code_info(src)) {\n            JL_GC_POP();\n            return jl_compile_result_t(); // failed\n        }\n    }\n    jl_compile_result_t result = jl_emit_code(codeinst->def, src, codeinst->rettype, params);\n\n    const jl_llvm_functions_t &decls = std::get<1>(result);\n    const std::string &specf = decls.specFunctionObject;\n    const std::string &f = decls.functionObject;\n    if (params.cache && !f.empty()) {\n        const Module *m = std::get<0>(result).get();\n        // Prepare debug info to receive this function\n        // record that this function name came from this linfo,\n        // so we can build a reverse mapping for debug-info.\n        bool toplevel = !jl_is_method(codeinst->def->def.method);\n        if (!toplevel) {\n            const DataLayout &DL = m->getDataLayout();\n            // but don't remember toplevel thunks because\n            // they may not be rooted in the gc for the life of the program,\n            // and the runtime doesn't notify us when the code becomes unreachable :(\n            if (!specf.empty())\n                jl_add_code_in_flight(specf, codeinst, DL);\n            if (!f.empty() && f != \"jl_fptr_args\" && f != \"jl_fptr_sparam\")\n                jl_add_code_in_flight(f, codeinst, DL);\n        }\n\n        if (// don't alter `inferred` when the code is not directly being used\n            params.world &&\n            // don't change inferred state\n            codeinst->inferred) {\n            jl_method_t *def = codeinst->def->def.method;\n            if (// keep code when keeping everything\n                !(JL_DELETE_NON_INLINEABLE) ||\n                // aggressively keep code when debugging level >= 2\n                jl_options.debug_level > 1) {\n                // update the stored code\n                if (codeinst->inferred != (jl_value_t*)src) {\n                    if (jl_is_method(def))\n                        src = (jl_code_info_t*)jl_compress_ir(def, src);\n                    codeinst->inferred = (jl_value_t*)src;\n                    jl_gc_wb(codeinst, src);\n                }\n            }\n            else if (// don't delete toplevel code\n                     jl_is_method(def) &&\n                     // and there is something to delete (test this before calling jl_ir_flag_inlineable)\n                     codeinst->inferred != jl_nothing &&\n                     // don't delete inlineable code, unless it is constant\n                     (codeinst->invoke == jl_fptr_const_return || !jl_ir_flag_inlineable((jl_array_t*)codeinst->inferred)) &&\n                     // don't delete code when generating a precompile file\n                     !imaging_mode) {\n                // if not inlineable, code won't be needed again\n                codeinst->inferred = jl_nothing;\n            }\n        }\n    }\n    JL_GC_POP();\n    return result;\n}\n\n\nvoid jl_compile_workqueue(\n    std::map<jl_code_instance_t*, jl_compile_result_t> &emitted,\n    jl_codegen_params_t &params, CompilationPolicy policy)\n{\n    JL_TIMING(CODEGEN);\n    jl_code_info_t *src = NULL;\n    JL_GC_PUSH1(&src);\n    while (!params.workqueue.empty()) {\n        jl_code_instance_t *codeinst;\n        Function *protodecl;\n        jl_returninfo_t::CallingConv proto_cc;\n        bool proto_specsig;\n        unsigned proto_return_roots;\n        std::tie(codeinst, proto_cc, proto_return_roots, protodecl, proto_specsig) = params.workqueue.back();\n        params.workqueue.pop_back();\n        // try to emit code for this item from the workqueue\n        assert(codeinst->min_world <= params.world && codeinst->max_world >= params.world &&\n            \"invalid world for code-instance\");\n        StringRef preal_decl = \"\";\n        bool preal_specsig = false;\n        if (params.cache && codeinst->invoke != NULL) {\n            if (codeinst->invoke == jl_fptr_args) {\n                preal_decl = jl_ExecutionEngine->getFunctionAtAddress((uintptr_t)codeinst->specptr.fptr, codeinst);\n            }\n            else if (codeinst->isspecsig) {\n                preal_decl = jl_ExecutionEngine->getFunctionAtAddress((uintptr_t)codeinst->specptr.fptr, codeinst);\n                preal_specsig = true;\n            }\n        }\n        else {\n            jl_compile_result_t &result = emitted[codeinst];\n            jl_llvm_functions_t *decls = NULL;\n            if (std::get<0>(result)) {\n                decls = &std::get<1>(result);\n            }\n            else {\n                // Reinfer the function. The JIT came along and removed the inferred\n                // method body. See #34993\n                if (policy == CompilationPolicy::Extern &&\n                    codeinst->inferred && codeinst->inferred == jl_nothing) {\n                    src = jl_type_infer(codeinst->def, jl_world_counter, 0);\n                    if (src)\n                        result = jl_emit_code(codeinst->def, src, src->rettype, params);\n                }\n                else {\n                    result = jl_emit_codeinst(codeinst, NULL, params);\n                }\n                if (std::get<0>(result))\n                    decls = &std::get<1>(result);\n                else\n                    emitted.erase(codeinst); // undo the insert above\n            }\n            if (decls) {\n                if (decls->functionObject == \"jl_fptr_args\") {\n                    preal_decl = decls->specFunctionObject;\n                }\n                else if (decls->functionObject != \"jl_fptr_sparam\") {\n                    preal_decl = decls->specFunctionObject;\n                    preal_specsig = true;\n                }\n            }\n        }\n        // patch up the prototype we emitted earlier\n        Module *mod = protodecl->getParent();\n        assert(protodecl->isDeclaration());\n        if (proto_specsig) {\n            // expected specsig\n            if (!preal_specsig) {\n                // emit specsig-to-(jl)invoke conversion\n                Function *preal = emit_tojlinvoke(codeinst, mod, params);\n                protodecl->setLinkage(GlobalVariable::PrivateLinkage);\n                //protodecl->setAlwaysInline();\n                protodecl->addFnAttr(\"no-frame-pointer-elim\", \"true\");\n                size_t nrealargs = jl_nparams(codeinst->def->specTypes); // number of actual arguments being passed\n                // TODO: maybe this can be cached in codeinst->specfptr?\n                emit_cfunc_invalidate(protodecl, proto_cc, proto_return_roots, codeinst->def->specTypes, codeinst->rettype, nrealargs, params, preal);\n                preal_decl = \"\"; // no need to fixup the name\n            }\n            else {\n                assert(!preal_decl.empty());\n            }\n        }\n        else {\n            // expected non-specsig\n            if (preal_decl.empty() || preal_specsig) {\n                // emit jlcall1-to-(jl)invoke conversion\n                preal_decl = emit_tojlinvoke(codeinst, mod, params)->getName();\n            }\n        }\n        if (!preal_decl.empty()) {\n            // merge and/or rename this prototype to the real function\n            if (Value *specfun = mod->getNamedValue(preal_decl)) {\n                if (protodecl != specfun)\n                    protodecl->replaceAllUsesWith(specfun);\n            }\n            else {\n                protodecl->setName(preal_decl);\n            }\n        }\n    }\n    JL_GC_POP();\n}\n\n\n// --- initialization ---\n\nstd::pair<MDNode*,MDNode*> tbaa_make_child(const char *name, MDNode *parent=nullptr, bool isConstant=false)\n{\n    MDBuilder mbuilder(jl_LLVMContext);\n    if (tbaa_root == nullptr) {\n        MDNode *jtbaa = mbuilder.createTBAARoot(\"jtbaa\");\n        tbaa_root = mbuilder.createTBAAScalarTypeNode(\"jtbaa\", jtbaa);\n    }\n    MDNode *scalar = mbuilder.createTBAAScalarTypeNode(name, parent ? parent : tbaa_root);\n    MDNode *n = mbuilder.createTBAAStructTagNode(scalar, scalar, 0, isConstant);\n    return std::make_pair(n, scalar);\n}\n\nstd::vector<std::pair<jl_value_t**, JuliaVariable*>> gv_for_global;\nstatic void global_jlvalue_to_llvm(JuliaVariable *var, jl_value_t **addr)\n{\n    gv_for_global.push_back(std::make_pair(addr, var));\n}\nstatic JuliaVariable *julia_const_gv(jl_value_t *val)\n{\n    for (auto &kv : gv_for_global) {\n        if (*kv.first == val)\n            return kv.second;\n    }\n    return nullptr;\n}\n\nstatic void init_julia_llvm_meta(void)\n{\n    tbaa_gcframe = tbaa_make_child(\"jtbaa_gcframe\").first;\n    MDNode *tbaa_stack_scalar;\n    std::tie(tbaa_stack, tbaa_stack_scalar) = tbaa_make_child(\"jtbaa_stack\");\n    tbaa_unionselbyte = tbaa_make_child(\"jtbaa_unionselbyte\", tbaa_stack_scalar).first;\n    MDNode *tbaa_data_scalar;\n    std::tie(tbaa_data, tbaa_data_scalar) = tbaa_make_child(\"jtbaa_data\");\n    tbaa_binding = tbaa_make_child(\"jtbaa_binding\", tbaa_data_scalar).first;\n    MDNode *tbaa_value_scalar;\n    std::tie(tbaa_value, tbaa_value_scalar) =\n        tbaa_make_child(\"jtbaa_value\", tbaa_data_scalar);\n    MDNode *tbaa_mutab_scalar;\n    std::tie(tbaa_mutab, tbaa_mutab_scalar) =\n        tbaa_make_child(\"jtbaa_mutab\", tbaa_value_scalar);\n    tbaa_datatype = tbaa_make_child(\"jtbaa_datatype\", tbaa_mutab_scalar).first;\n    tbaa_immut = tbaa_make_child(\"jtbaa_immut\", tbaa_value_scalar).first;\n    tbaa_arraybuf = tbaa_make_child(\"jtbaa_arraybuf\", tbaa_data_scalar).first;\n    tbaa_ptrarraybuf = tbaa_make_child(\"jtbaa_ptrarraybuf\", tbaa_data_scalar).first;\n    MDNode *tbaa_array_scalar;\n    std::tie(tbaa_array, tbaa_array_scalar) = tbaa_make_child(\"jtbaa_array\");\n    tbaa_arrayptr = tbaa_make_child(\"jtbaa_arrayptr\", tbaa_array_scalar).first;\n    tbaa_arraysize = tbaa_make_child(\"jtbaa_arraysize\", tbaa_array_scalar).first;\n    tbaa_arraylen = tbaa_make_child(\"jtbaa_arraylen\", tbaa_array_scalar).first;\n    tbaa_arrayflags = tbaa_make_child(\"jtbaa_arrayflags\", tbaa_array_scalar).first;\n    tbaa_arrayoffset = tbaa_make_child(\"jtbaa_arrayoffset\", tbaa_array_scalar).first;\n    tbaa_const = tbaa_make_child(\"jtbaa_const\", nullptr, true).first;\n    tbaa_arrayselbyte = tbaa_make_child(\"jtbaa_arrayselbyte\", tbaa_array_scalar).first;\n\n    Thunk = Attribute::get(jl_LLVMContext, \"thunk\");\n}\n\nstatic void init_julia_llvm_env(Module *m)\n{\n    // every variable or function mapped in this function must be\n    // exported from libjulia, to support static compilation\n    T_int1  = Type::getInt1Ty(jl_LLVMContext);\n    T_int8  = Type::getInt8Ty(jl_LLVMContext);\n    T_pint8 = PointerType::get(T_int8, 0);\n    T_ppint8 = PointerType::get(T_pint8, 0);\n    T_pppint8 = PointerType::get(T_ppint8, 0);\n    T_int16 = Type::getInt16Ty(jl_LLVMContext);\n    T_pint16 = PointerType::get(T_int16, 0);\n    T_int32 = Type::getInt32Ty(jl_LLVMContext);\n    T_char = Type::getInt32Ty(jl_LLVMContext);\n    T_pint32 = PointerType::get(T_int32, 0);\n    T_int64 = Type::getInt64Ty(jl_LLVMContext);\n    T_pint64 = PointerType::get(T_int64, 0);\n    T_uint8 = T_int8;   T_uint16 = T_int16;\n    T_uint32 = T_int32; T_uint64 = T_int64;\n    if (sizeof(size_t) == 8)\n        T_size = T_uint64;\n    else\n        T_size = T_uint32;\n    T_sigatomic = Type::getIntNTy(jl_LLVMContext, sizeof(sig_atomic_t) * 8);\n    T_psize = PointerType::get(T_size, 0);\n    T_float16 = Type::getHalfTy(jl_LLVMContext);\n    T_float32 = Type::getFloatTy(jl_LLVMContext);\n    T_pfloat32 = PointerType::get(T_float32, 0);\n    T_float64 = Type::getDoubleTy(jl_LLVMContext);\n    T_pfloat64 = PointerType::get(T_float64, 0);\n    T_float128 = Type::getFP128Ty(jl_LLVMContext);\n    T_void = Type::getVoidTy(jl_LLVMContext);\n    T_pvoidfunc = FunctionType::get(T_void, /*isVarArg*/false)->getPointerTo();\n\n    // add needed base debugging definitions to our LLVM environment\n    DIBuilder dbuilder(*m);\n    DIFile *julia_h = dbuilder.createFile(\"julia.h\", \"\");\n    jl_value_dillvmt = dbuilder.createStructType(nullptr,\n        \"jl_value_t\",\n        julia_h,\n        71, // At the time of this writing. Not sure if it's worth it to keep this in sync\n        0 * 8, // sizeof(jl_value_t) * 8,\n        __alignof__(void*) * 8, // __alignof__(jl_value_t) * 8,\n        DINode::FlagZero, // Flags\n        nullptr,    // Derived from\n        nullptr);  // Elements - will be corrected later\n\n    jl_pvalue_dillvmt = dbuilder.createPointerType(jl_value_dillvmt, sizeof(jl_value_t*) * 8,\n                                                   __alignof__(jl_value_t*) * 8);\n\n    SmallVector<llvm::Metadata *, 1> Elts;\n    std::vector<Metadata*> diargs(0);\n    Elts.push_back(jl_pvalue_dillvmt);\n    dbuilder.replaceArrays(jl_value_dillvmt,\n       dbuilder.getOrCreateArray(Elts));\n\n    jl_ppvalue_dillvmt = dbuilder.createPointerType(jl_pvalue_dillvmt, sizeof(jl_value_t**) * 8,\n                                                    __alignof__(jl_value_t**) * 8);\n\n    diargs.push_back(jl_pvalue_dillvmt);    // Return Type (ret value)\n    diargs.push_back(jl_pvalue_dillvmt);    // First Argument (function)\n    diargs.push_back(jl_ppvalue_dillvmt);   // Second Argument (argv)\n    // Third argument (length(argv))\n    diargs.push_back(_julia_type_to_di(NULL, (jl_value_t*)jl_int32_type, &dbuilder, false));\n\n    jl_di_func_sig = dbuilder.createSubroutineType(\n        dbuilder.getOrCreateTypeArray(diargs));\n    jl_di_func_null_sig = dbuilder.createSubroutineType(\n        dbuilder.getOrCreateTypeArray(None));\n\n    T_jlvalue = StructType::get(jl_LLVMContext);\n    T_pjlvalue = PointerType::get(T_jlvalue, 0);\n    T_prjlvalue = PointerType::get(T_jlvalue, AddressSpace::Tracked);\n    T_ppjlvalue = PointerType::get(T_pjlvalue, 0);\n    T_pprjlvalue = PointerType::get(T_prjlvalue, 0);\n    V_null = Constant::getNullValue(T_pjlvalue);\n    V_rnull = Constant::getNullValue(T_prjlvalue);\n    V_size0 = Constant::getNullValue(T_size);\n\n    std::vector<Type*> ftargs(0);\n    ftargs.push_back(T_prjlvalue);  // function\n    ftargs.push_back(T_pprjlvalue); // args[]\n    ftargs.push_back(T_int32);      // nargs\n    jl_func_sig = FunctionType::get(T_prjlvalue, ftargs, false);\n    assert(jl_func_sig != NULL);\n    ftargs.push_back(T_pprjlvalue); // linfo->sparam_vals\n    jl_func_sig_sparams = FunctionType::get(T_prjlvalue, ftargs, false);\n    assert(jl_func_sig_sparams != NULL);\n\n    Type *vaelts[] = {PointerType::get(T_int8, AddressSpace::Loaded)\n#ifdef STORE_ARRAY_LEN\n                      , T_size\n#endif\n                      , T_int16\n                      , T_int16\n                      , T_int32\n    };\n    static_assert(sizeof(jl_array_flags_t) == sizeof(int16_t),\n                  \"Size of jl_array_flags_t is not the same as int16_t\");\n    jl_array_llvmt = StructType::get(jl_LLVMContext, makeArrayRef(vaelts));\n    jl_parray_llvmt = PointerType::get(jl_array_llvmt, 0);\n}\n\nstatic void init_jit_functions(void)\n{\n    add_named_global(jlstack_chk_guard_var, &__stack_chk_guard);\n    add_named_global(jlRTLD_DEFAULT_var, &jl_RTLD_DEFAULT_handle);\n#ifdef _OS_WINDOWS_\n    add_named_global(jlexe_var, &jl_exe_handle);\n    add_named_global(jldll_var, &jl_libjulia_internal_handle);\n#endif\n    global_jlvalue_to_llvm(new JuliaVariable{\"jl_true\", true, get_pjlvalue}, &jl_true);\n    global_jlvalue_to_llvm(new JuliaVariable{\"jl_false\", true, get_pjlvalue}, &jl_false);\n    global_jlvalue_to_llvm(new JuliaVariable{\"jl_emptysvec\", true, get_pjlvalue}, (jl_value_t**)&jl_emptysvec);\n    global_jlvalue_to_llvm(new JuliaVariable{\"jl_emptytuple\", true, get_pjlvalue}, &jl_emptytuple);\n    global_jlvalue_to_llvm(new JuliaVariable{\"jl_diverror_exception\", true, get_pjlvalue}, &jl_diverror_exception);\n    global_jlvalue_to_llvm(new JuliaVariable{\"jl_undefref_exception\", true, get_pjlvalue}, &jl_undefref_exception);\n    add_named_global(jlgetworld_global, &jl_world_counter);\n    add_named_global(\"__stack_chk_fail\", &__stack_chk_fail);\n    add_named_global(jltls_states_func, (void*)NULL);\n    add_named_global(jlerror_func, &jl_error);\n    add_named_global(jlthrow_func, &jl_throw);\n    add_named_global(jlundefvarerror_func, &jl_undefined_var_error);\n    add_named_global(jlboundserrorv_func, &jl_bounds_error_ints);\n    add_named_global(jlboundserror_func, &jl_bounds_error_int);\n    add_named_global(jlvboundserror_func, &jl_bounds_error_tuple_int);\n    add_named_global(jluboundserror_func, &jl_bounds_error_unboxed_int);\n    add_named_global(jlnew_func, &jl_new_structv);\n    add_named_global(jlsplatnew_func, &jl_new_structt);\n    add_named_global(setjmp_func, &jl_setjmp_f);\n    add_named_global(memcmp_func, &memcmp);\n    add_named_global(jltypeerror_func, &jl_type_error);\n    add_named_global(jlcheckassign_func, &jl_checked_assignment);\n    add_named_global(jldeclareconst_func, &jl_declare_constant);\n    add_named_global(jlgetbindingorerror_func, &jl_get_binding_or_error);\n    add_named_global(jlboundp_func, &jl_boundp);\n    for (auto it : builtin_func_map)\n        add_named_global(it.second, it.first);\n    add_named_global(jlapplygeneric_func, &jl_apply_generic);\n    add_named_global(jlinvoke_func, &jl_invoke);\n    add_named_global(jltopeval_func, &jl_toplevel_eval);\n    add_named_global(jlcopyast_func, &jl_copy_ast);\n    //add_named_global(jlnsvec_func, &jl_svec);\n    add_named_global(jlmethod_func, &jl_method_def);\n    add_named_global(jlgenericfunction_func, &jl_generic_function_def);\n    add_named_global(jlenter_func, &jl_enter_handler);\n    add_named_global(jl_current_exception_func, &jl_current_exception);\n    add_named_global(jlleave_func, &jl_pop_handler);\n    add_named_global(jl_restore_excstack_func, &jl_restore_excstack);\n    add_named_global(jl_excstack_state_func, &jl_excstack_state);\n    add_named_global(jlegal_func, &jl_egal);\n    add_named_global(jlisa_func, &jl_isa);\n    add_named_global(jlsubtype_func, &jl_subtype);\n    add_named_global(jltypeassert_func, &jl_typeassert);\n    add_named_global(jlapplytype_func, &jl_instantiate_type_in_env);\n    add_named_global(jl_object_id__func, &jl_object_id_);\n    add_named_global(jl_alloc_obj_func, (void*)NULL);\n    add_named_global(jl_newbits_func, (void*)jl_new_bits);\n    add_named_global(jl_loopinfo_marker_func, (void*)NULL);\n    add_named_global(jl_typeof_func, (void*)NULL);\n    add_named_global(jl_write_barrier_func, (void*)NULL);\n    add_named_global(jldlsym_func, &jl_load_and_lookup);\n    add_named_global(jlgetcfunctiontrampoline_func, &jl_get_cfunction_trampoline);\n    add_named_global(jlgetnthfieldchecked_func, &jl_get_nth_field_checked);\n    add_named_global(diff_gc_total_bytes_func, &jl_gc_diff_total_bytes);\n    add_named_global(sync_gc_total_bytes_func, &jl_gc_sync_total_bytes);\n    add_named_global(jlarray_data_owner_func, &jl_array_data_owner);\n    add_named_global(gcroot_flush_func, (void*)NULL);\n    add_named_global(gc_preserve_begin_func, (void*)NULL);\n    add_named_global(gc_preserve_end_func, (void*)NULL);\n    add_named_global(pointer_from_objref_func, (void*)NULL);\n    add_named_global(except_enter_func, (void*)NULL);\n\n#ifdef _OS_WINDOWS_\n#if defined(_CPU_X86_64_)\n#if defined(_COMPILER_GCC_)\n    add_named_global(\"___chkstk_ms\", &___chkstk_ms);\n#else\n    add_named_global(\"__chkstk\", &__chkstk);\n#endif\n#else\n#if defined(_COMPILER_GCC_)\n    add_named_global(\"_alloca\", &_alloca);\n#else\n    add_named_global(\"_chkstk\", &_chkstk);\n#endif\n#endif\n#endif\n\n#define BOX_F(ct) add_named_global(\"jl_box_\"#ct, &jl_box_##ct);\n    BOX_F(int8); BOX_F(uint8);\n    BOX_F(int16); BOX_F(uint16);\n    BOX_F(int32); BOX_F(uint32);\n    BOX_F(int64); BOX_F(uint64);\n    BOX_F(float32); BOX_F(float64);\n    BOX_F(char); BOX_F(ssavalue);\n#undef BOX_F\n}\n\nextern \"C\" void jl_init_llvm(void)\n{\n    jl_page_size = jl_getpagesize();\n    imaging_mode = jl_options.image_codegen || (jl_generating_output() && !jl_options.incremental);\n    jl_default_cgparams.generic_context = jl_nothing;\n    jl_init_debuginfo();\n\n    InitializeNativeTarget();\n    InitializeNativeTargetAsmPrinter();\n    InitializeNativeTargetAsmParser();\n    InitializeNativeTargetDisassembler();\n\n    // Initialize passes\n    PassRegistry &Registry = *PassRegistry::getPassRegistry();\n    initializeCore(Registry);\n    initializeCoroutines(Registry);\n    initializeScalarOpts(Registry);\n    initializeVectorization(Registry);\n    initializeAnalysis(Registry);\n    initializeTransformUtils(Registry);\n    initializeInstCombine(Registry);\n    initializeAggressiveInstCombine(Registry);\n    initializeInstrumentation(Registry);\n    initializeTarget(Registry);\n#ifdef USE_POLLY\n    polly::initializePollyPasses(Registry);\n#endif\n\n    // Parse command line flags after initialization\n    const char *const argv_tailmerge[] = {\"\", \"-enable-tail-merge=0\"}; // NOO TOUCHIE; NO TOUCH! See #922\n    cl::ParseCommandLineOptions(sizeof(argv_tailmerge)/sizeof(argv_tailmerge[0]), argv_tailmerge, \"disable-tail-merge\\n\");\n#if defined(_OS_WINDOWS_) && defined(_CPU_X86_64_)\n    const char *const argv_copyprop[] = {\"\", \"-disable-copyprop\"}; // llvm bug 21743\n    cl::ParseCommandLineOptions(sizeof(argv_copyprop)/sizeof(argv_copyprop[0]), argv_copyprop, \"disable-copyprop\\n\");\n#endif\n#if defined(_CPU_X86_) || defined(_CPU_X86_64_)\n    const char *const argv_avoidsfb[] = {\"\", \"-x86-disable-avoid-SFB\"}; // llvm bug 41629, see https://gist.github.com/vtjnash/192cab72a6cfc00256ff118238163b55\n    cl::ParseCommandLineOptions(sizeof(argv_avoidsfb)/sizeof(argv_avoidsfb[0]), argv_avoidsfb, \"disable-avoidsfb\\n\");\n#endif\n#if JL_LLVM_VERSION >= 120000\n    // https://reviews.llvm.org/rGc068e9c8c123e7f8c8f3feb57245a012ccd09ccf\n    Optional<std::string> envValue = sys::Process::GetEnv(\"JULIA_LLVM_ARGS\");\n    if (envValue) {\n        SmallVector<const char *, 20> newArgv;\n        BumpPtrAllocator A;\n        StringSaver Saver(A);\n        newArgv.push_back(Saver.save(\"Julia\").data());\n\n        // Parse the value of the environment variable into a \"command line\"\n        // and hand it off to ParseCommandLineOptions().\n        cl::TokenizeGNUCommandLine(*envValue, Saver, newArgv);\n        int newArgc = static_cast<int>(newArgv.size());\n        cl::ParseCommandLineOptions(newArgc, &newArgv[0]);\n    }\n#else\n    cl::ParseEnvironmentOptions(\"Julia\", \"JULIA_LLVM_ARGS\");\n#endif\n\n    // if the patch adding this option has been applied, lower its limit to provide\n    // better DAGCombiner performance.\n    auto &clOptions = cl::getRegisteredOptions();\n    if (clOptions.find(\"combiner-store-merge-dependence-limit\") != clOptions.end()) {\n        const char *const argv_smdl[] = {\"\", \"-combiner-store-merge-dependence-limit=4\"};\n        cl::ParseCommandLineOptions(sizeof(argv_smdl)/sizeof(argv_smdl[0]), argv_smdl);\n    }\n\n    TargetOptions options = TargetOptions();\n    //options.PrintMachineCode = true; //Print machine code produced during JIT compiling\n#if defined(_OS_WINDOWS_) && !defined(_CPU_X86_64_)\n    // tell Win32 to assume the stack is always 16-byte aligned,\n    // and to ensure that it is 16-byte aligned for out-going calls,\n    // to ensure compatibility with GCC codes\n    options.StackAlignmentOverride = 16;\n#endif\n    Triple TheTriple(sys::getProcessTriple());\n#if defined(FORCE_ELF)\n    TheTriple.setObjectFormat(Triple::ELF);\n#endif\n    uint32_t target_flags = 0;\n    auto target = jl_get_llvm_target(imaging_mode, target_flags);\n    auto &TheCPU = target.first;\n    SmallVector<std::string, 10> targetFeatures(target.second.begin(), target.second.end());\n    std::string errorstr;\n    const Target *TheTarget = TargetRegistry::lookupTarget(\"\", TheTriple, errorstr);\n    if (!TheTarget)\n        jl_errorf(\"%s\", errorstr.c_str());\n    if (jl_processor_print_help || (target_flags & JL_TARGET_UNKNOWN_NAME)) {\n        std::unique_ptr<MCSubtargetInfo> MSTI(\n            TheTarget->createMCSubtargetInfo(TheTriple.str(), \"\", \"\"));\n        if (!MSTI->isCPUStringValid(TheCPU))\n            jl_errorf(\"Invalid CPU name \\\"%s\\\".\", TheCPU.c_str());\n        if (jl_processor_print_help) {\n            // This is the only way I can find to print the help message once.\n            // It'll be nice if we can iterate through the features and print our own help\n            // message...\n#if JL_LLVM_VERSION >= 120000\n            MSTI->setDefaultFeatures(\"help\", \"\", \"\");\n#else\n            MSTI->setDefaultFeatures(\"help\", \"\");\n#endif\n        }\n    }\n    // Package up features to be passed to target/subtarget\n    std::string FeaturesStr;\n    if (!targetFeatures.empty()) {\n        SubtargetFeatures Features;\n        for (unsigned i = 0; i != targetFeatures.size(); ++i)\n            Features.AddFeature(targetFeatures[i]);\n        FeaturesStr = Features.getString();\n    }\n    // Allocate a target...\n    Optional<CodeModel::Model> codemodel =\n#ifdef _P64\n        // Make sure we are using the large code model on 64bit\n        // Let LLVM pick a default suitable for jitting on 32bit\n        CodeModel::Large;\n#else\n        None;\n#endif\n    auto optlevel = CodeGenOptLevelFor(jl_options.opt_level);\n    jl_TargetMachine = TheTarget->createTargetMachine(\n            TheTriple.getTriple(), TheCPU, FeaturesStr,\n            options,\n            Reloc::Static, // Generate simpler code for JIT\n            codemodel,\n            optlevel,\n            true // JIT\n            );\n    assert(jl_TargetMachine && \"Failed to select target machine -\"\n                               \" Is the LLVM backend for this CPU enabled?\");\n    #if (!defined(_CPU_ARM_) && !defined(_CPU_PPC64_))\n    // FastISel seems to be buggy for ARM. Ref #13321\n    if (jl_options.opt_level < 2)\n        jl_TargetMachine->setFastISel(true);\n    #endif\n\n    init_julia_llvm_meta();\n    jl_ExecutionEngine = new JuliaOJIT(*jl_TargetMachine, &jl_LLVMContext);\n\n    // Mark our address spaces as non-integral\n    jl_data_layout = jl_ExecutionEngine->getDataLayout();\n    std::string DL = jl_data_layout.getStringRepresentation() + \"-ni:10:11:12:13\";\n    jl_data_layout.reset(DL);\n\n    // Register GDB event listener\n    if(jl_using_gdb_jitevents)\n        jl_ExecutionEngine->RegisterJITEventListener(JITEventListener::createGDBRegistrationListener());\n\n#ifdef JL_USE_INTEL_JITEVENTS\n    if (jl_using_intel_jitevents)\n        jl_ExecutionEngine->RegisterJITEventListener(JITEventListener::createIntelJITEventListener());\n#endif\n\n#ifdef JL_USE_OPROFILE_JITEVENTS\n    if (jl_using_oprofile_jitevents)\n        jl_ExecutionEngine->RegisterJITEventListener(JITEventListener::createOProfileJITEventListener());\n#endif\n\n#ifdef JL_USE_PERF_JITEVENTS\n    if (jl_using_perf_jitevents)\n        jl_ExecutionEngine->RegisterJITEventListener(JITEventListener::createPerfJITEventListener());\n#endif\n}\n\nextern \"C\" void jl_init_codegen(void)\n{\n    jl_init_llvm();\n    // Now that the execution engine exists, initialize all modules\n    jl_init_jit();\n    init_jit_functions();\n\n    Module *m = new Module(\"julia\", jl_LLVMContext);\n    jl_setup_module(m);\n    init_julia_llvm_env(m);\n\n    jl_init_intrinsic_functions_codegen();\n}\n\nextern \"C\" void jl_teardown_codegen()\n{\n    // output LLVM timings and statistics\n    reportAndResetTimings();\n    PrintStatistics();\n}\n\n// the rest of this file are convenience functions\n// that are exported for assisting with debugging from gdb\nextern \"C\" void jl_dump_llvm_value(void *v)\n{\n    llvm_dump((Value*)v);\n}\n\nextern \"C\" void jl_dump_llvm_inst_function(void *v)\n{\n    llvm_dump(cast<Instruction>(((Value*)v))->getParent()->getParent());\n}\n\nextern \"C\" void jl_dump_llvm_type(void *v)\n{\n    llvm_dump((Type*)v);\n}\n\nextern \"C\" void jl_dump_llvm_module(void *v)\n{\n    llvm_dump((Module*)v);\n}\n\nextern \"C\" void jl_dump_llvm_metadata(void *v)\n{\n    llvm_dump((Metadata*)v);\n}\n\nextern \"C\" void jl_dump_llvm_debugloc(void *v)\n{\n    llvm_dump((DebugLoc*)v);\n}\n\nnamespace llvm {\n    class MachineBasicBlock;\n    class MachineFunction;\n    raw_ostream& operator<<(raw_ostream &OS, const MachineBasicBlock &MBB);\n    void printMIR(raw_ostream &OS, const MachineFunction &MF);\n}\nextern \"C\" void jl_dump_llvm_mbb(void *v)\n{\n    errs() << *(llvm::MachineBasicBlock*)v;\n}\nextern \"C\" void jl_dump_llvm_mfunction(void *v)\n{\n    llvm::printMIR(errs(), *(llvm::MachineFunction*)v);\n}\n\n\nextern void jl_write_bitcode_func(void *F, char *fname) {\n    std::error_code EC;\n    raw_fd_ostream OS(fname, EC, sys::fs::F_None);\n    llvm::WriteBitcodeToFile(*((llvm::Function*)F)->getParent(), OS);\n}\n\nextern void jl_write_bitcode_module(void *M, char *fname) {\n    std::error_code EC;\n    raw_fd_ostream OS(fname, EC, sys::fs::F_None);\n    llvm::WriteBitcodeToFile(*(llvm::Module*)M, OS);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/debuginfo.cpp": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n#include \"platform.h\"\n\n#include \"llvm-version.h\"\n#include <llvm/ExecutionEngine/ExecutionEngine.h>\n#include <llvm/ExecutionEngine/JITEventListener.h>\n#include <llvm/DebugInfo/DIContext.h>\n#include <llvm/DebugInfo/DWARF/DWARFContext.h>\n#include <llvm/Object/SymbolSize.h>\n#include <llvm/Support/MemoryBuffer.h>\n#include <llvm/IR/Function.h>\n#include <llvm/ADT/StringRef.h>\n#include <llvm/ADT/StringMap.h>\n#include <llvm/IR/DebugInfo.h>\n#include <llvm/IR/DataLayout.h>\n#include <llvm/IR/Mangler.h>\n#include <llvm/ExecutionEngine/RuntimeDyld.h>\n#include <llvm/BinaryFormat/Magic.h>\n#include <llvm/Object/MachO.h>\n#include <llvm/Object/COFF.h>\n#include <llvm/Object/ELFObjectFile.h>\n\nusing namespace llvm;\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"debuginfo.h\"\n#if defined(_OS_LINUX_)\n#  include <link.h>\n#endif\n#include \"processor.h\"\n\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include \"julia_assert.h\"\n\n#ifdef _OS_DARWIN_\n#include <CoreFoundation/CoreFoundation.h>\n#endif\n\ntypedef object::SymbolRef SymRef;\n\n// Any function that acquires this lock must be either a unmanaged thread\n// or in the GC safe region and must NOT allocate anything through the GC\n// while holding this lock.\n// Certain functions in this file might be called from an unmanaged thread\n// and cannot have any interaction with the julia runtime\nstatic uv_rwlock_t threadsafe;\n\nextern \"C\" void jl_init_debuginfo(void)\n{\n    uv_rwlock_init(&threadsafe);\n}\n\nextern \"C\" void jl_lock_profile(void)\n{\n    uv_rwlock_rdlock(&threadsafe);\n}\n\nextern \"C\" void jl_unlock_profile(void)\n{\n    uv_rwlock_rdunlock(&threadsafe);\n}\n\n// some actions aren't signal (especially profiler) safe so we acquire a lock\n// around them to establish a mutual exclusion with unwinding from a signal\ntemplate <typename T>\nstatic void jl_profile_atomic(T f)\n{\n    uv_rwlock_wrlock(&threadsafe);\n#ifndef _OS_WINDOWS_\n    sigset_t sset;\n    sigset_t oset;\n    sigfillset(&sset);\n    pthread_sigmask(SIG_BLOCK, &sset, &oset);\n#endif\n    f();\n#ifndef _OS_WINDOWS_\n    pthread_sigmask(SIG_SETMASK, &oset, NULL);\n#endif\n    uv_rwlock_wrunlock(&threadsafe);\n}\n\n\n// --- storing and accessing source location metadata ---\n\nstruct ObjectInfo {\n    const object::ObjectFile *object;\n    size_t SectionSize;\n    ptrdiff_t slide;\n    object::SectionRef Section;\n    DIContext *context;\n};\n\n// Maintain a mapping of unrealized function names -> linfo objects\n// so that when we see it get emitted, we can add a link back to the linfo\n// that it came from (providing name, type signature, file info, etc.)\nstatic StringMap<jl_code_instance_t*> codeinst_in_flight;\nstatic std::string mangle(StringRef Name, const DataLayout &DL)\n{\n    std::string MangledName;\n    {\n        raw_string_ostream MangledNameStream(MangledName);\n        Mangler::getNameWithPrefix(MangledNameStream, Name, DL);\n    }\n    return MangledName;\n}\nvoid jl_add_code_in_flight(StringRef name, jl_code_instance_t *codeinst, const DataLayout &DL)\n{\n    codeinst_in_flight[mangle(name, DL)] = codeinst;\n}\n\n\n#ifdef _OS_WINDOWS_\n#if defined(_CPU_X86_64_)\nvoid *lookupWriteAddressFor(RTDyldMemoryManager *memmgr, void *rt_addr);\n#endif\n#endif\n\n#if defined(_OS_WINDOWS_)\nstatic void create_PRUNTIME_FUNCTION(uint8_t *Code, size_t Size, StringRef fnname,\n                                     uint8_t *Section, size_t Allocated, uint8_t *UnwindData)\n{\n    // GC safe\n    DWORD mod_size = 0;\n#if defined(_CPU_X86_64_)\n    PRUNTIME_FUNCTION tbl = (PRUNTIME_FUNCTION)malloc_s(sizeof(RUNTIME_FUNCTION));\n    tbl->BeginAddress = (DWORD)(Code - Section);\n    tbl->EndAddress = (DWORD)(Code - Section + Size);\n    tbl->UnwindData = (DWORD)(UnwindData - Section);\n#else // defined(_CPU_X86_64_)\n    Section += (uintptr_t)Code;\n    mod_size = Size;\n#endif\n    if (0) {\n        JL_LOCK_NOGC(&jl_in_stackwalk);\n        if (mod_size && !SymLoadModuleEx(GetCurrentProcess(), NULL, NULL, NULL, (DWORD64)Section, mod_size, NULL, SLMFLAG_VIRTUAL)) {\n            static int warned = 0;\n            if (!warned) {\n                jl_printf(JL_STDERR, \"WARNING: failed to insert module info for backtrace: %lu\\n\", GetLastError());\n                warned = 1;\n            }\n        }\n        else {\n            size_t len = fnname.size()+1;\n            if (len > MAX_SYM_NAME)\n                len = MAX_SYM_NAME;\n            char *name = (char*)alloca(len);\n            memcpy(name, fnname.data(), len-1);\n            name[len-1] = 0;\n            if (!SymAddSymbol(GetCurrentProcess(), (ULONG64)Section, name,\n                        (DWORD64)Code, (DWORD)Size, 0)) {\n                jl_printf(JL_STDERR, \"WARNING: failed to insert function name %s into debug info: %lu\\n\", name, GetLastError());\n            }\n        }\n        JL_UNLOCK_NOGC(&jl_in_stackwalk);\n    }\n#if defined(_CPU_X86_64_)\n    jl_profile_atomic([&]() {\n        if (!RtlAddFunctionTable(tbl, 1, (DWORD64)Section)) {\n            static int warned = 0;\n            if (!warned) {\n                jl_printf(JL_STDERR, \"WARNING: failed to insert function stack unwind info: %lu\\n\", GetLastError());\n                warned = 1;\n            }\n        }\n    });\n#endif\n}\n#endif\n\nstruct revcomp {\n    bool operator() (const size_t& lhs, const size_t& rhs) const\n    { return lhs>rhs; }\n};\n\nstruct strrefcomp {\n    bool operator() (const StringRef& lhs, const StringRef& rhs) const\n    {\n        return lhs.compare(rhs) > 0;\n    }\n};\n\nclass JuliaJITEventListener: public JITEventListener\n{\n    std::map<size_t, ObjectInfo, revcomp> objectmap;\n    std::map<size_t, std::pair<size_t, jl_method_instance_t *>, revcomp> linfomap;\n\npublic:\n    JuliaJITEventListener(){}\n    virtual ~JuliaJITEventListener() {}\n\n    jl_method_instance_t *lookupLinfo(size_t pointer) JL_NOTSAFEPOINT\n    {\n        uv_rwlock_rdlock(&threadsafe);\n        auto region = linfomap.lower_bound(pointer);\n        jl_method_instance_t *linfo = NULL;\n        if (region != linfomap.end() && pointer < region->first + region->second.first)\n            linfo = region->second.second;\n        uv_rwlock_rdunlock(&threadsafe);\n        return linfo;\n    }\n\n    virtual void NotifyObjectEmitted(const object::ObjectFile &Object,\n                                     const RuntimeDyld::LoadedObjectInfo &L)\n    {\n        return _NotifyObjectEmitted(Object, L, nullptr);\n    }\n\n    virtual void _NotifyObjectEmitted(const object::ObjectFile &Object,\n                                      const RuntimeDyld::LoadedObjectInfo &L,\n                                      RTDyldMemoryManager *memmgr)\n    {\n        jl_ptls_t ptls = jl_get_ptls_states();\n        // This function modify codeinst->fptr in GC safe region.\n        // This should be fine since the GC won't scan this field.\n        int8_t gc_state = jl_gc_safe_enter(ptls);\n\n        auto SavedObject = L.getObjectForDebug(Object).takeBinary();\n        // If the debug object is unavailable, save (a copy of) the original object\n        // for our backtraces.\n        // This copy seems unfortunate, but there doesn't seem to be a way to take\n        // ownership of the original buffer.\n        if (!SavedObject.first) {\n            auto NewBuffer = MemoryBuffer::getMemBufferCopy(\n                    Object.getData(), Object.getFileName());\n            auto NewObj = cantFail(object::ObjectFile::createObjectFile(NewBuffer->getMemBufferRef()));\n            SavedObject = std::make_pair(std::move(NewObj), std::move(NewBuffer));\n        }\n        const object::ObjectFile &debugObj = *SavedObject.first.release();\n        SavedObject.second.release();\n\n        object::section_iterator EndSection = debugObj.section_end();\n        std::map<StringRef, object::SectionRef, strrefcomp> loadedSections;\n        for (const object::SectionRef &lSection: Object.sections()) {\n#if JL_LLVM_VERSION >= 100000\n            auto sName = lSection.getName();\n            if (sName)\n                loadedSections[*sName] = lSection;\n#else\n            StringRef sName;\n            if (!lSection.getName(sName))\n                loadedSections[sName] = lSection;\n#endif\n        }\n        auto getLoadAddress = [&] (const StringRef &sName) -> uint64_t {\n            auto search = loadedSections.find(sName);\n            if (search == loadedSections.end())\n                return 0;\n            return L.getSectionLoadAddress(search->second);\n        };\n\n#ifdef _CPU_ARM_\n        // ARM does not have/use .eh_frame\n        uint64_t arm_exidx_addr = 0;\n        size_t arm_exidx_len = 0;\n        uint64_t arm_text_addr = 0;\n        size_t arm_text_len = 0;\n        for (auto &section: Object.sections()) {\n            bool istext = false;\n            if (section.isText()) {\n                istext = true;\n            }\n            else {\n#if JL_LLVM_VERSION >= 100000\n                auto sName = section.getName();\n                if (!sName)\n                    continue;\n                if (sName.get() != \".ARM.exidx\") {\n                    continue;\n                }\n#else\n                StringRef sName;\n                if (section.getName(sName))\n                    continue;\n                if (sName != \".ARM.exidx\") {\n                    continue;\n                }\n#endif\n            }\n            uint64_t loadaddr = L.getSectionLoadAddress(section);\n            size_t seclen = section.getSize();\n            if (istext) {\n                arm_text_addr = loadaddr;\n                arm_text_len = seclen;\n                if (!arm_exidx_addr) {\n                    continue;\n                }\n            }\n            else {\n                arm_exidx_addr = loadaddr;\n                arm_exidx_len = seclen;\n                if (!arm_text_addr) {\n                    continue;\n                }\n            }\n            unw_dyn_info_t *di = new unw_dyn_info_t;\n            di->gp = 0;\n            di->format = UNW_INFO_FORMAT_ARM_EXIDX;\n            di->start_ip = (uintptr_t)arm_text_addr;\n            di->end_ip = (uintptr_t)(arm_text_addr + arm_text_len);\n            di->u.rti.name_ptr = 0;\n            di->u.rti.table_data = arm_exidx_addr;\n            di->u.rti.table_len = arm_exidx_len;\n            jl_profile_atomic([&]() {\n                _U_dyn_register(di);\n            });\n            break;\n        }\n#endif\n\n#if defined(_OS_WINDOWS_)\n        uint64_t SectionAddrCheck = 0;\n        uint64_t SectionLoadCheck = 0;\n        uint64_t SectionWriteCheck = 0;\n        uint8_t *UnwindData = NULL;\n#if defined(_CPU_X86_64_)\n        uint8_t *catchjmp = NULL;\n        for (const object::SymbolRef &sym_iter : debugObj.symbols()) {\n            StringRef sName = cantFail(sym_iter.getName());\n            uint8_t **pAddr = NULL;\n            if (sName.equals(\"__UnwindData\")) {\n                pAddr = &UnwindData;\n            }\n            else if (sName.equals(\"__catchjmp\")) {\n                pAddr = &catchjmp;\n            }\n            if (pAddr) {\n                uint64_t Addr = cantFail(sym_iter.getAddress());\n                auto Section = cantFail(sym_iter.getSection());\n                assert(Section != EndSection && Section->isText());\n                uint64_t SectionAddr = Section->getAddress();\n#if JL_LLVM_VERSION >= 100000\n                sName = cantFail(Section->getName());\n#else\n                Section->getName(sName);\n#endif\n                uint64_t SectionLoadAddr = getLoadAddress(sName);\n                assert(SectionLoadAddr);\n                if (SectionAddrCheck) // assert that all of the Sections are at the same location\n                    assert(SectionAddrCheck == SectionAddr &&\n                           SectionLoadCheck == SectionLoadAddr);\n                SectionAddrCheck = SectionAddr;\n                SectionLoadCheck = SectionLoadAddr;\n                SectionWriteCheck = SectionLoadAddr;\n                if (memmgr)\n                    SectionWriteCheck = (uintptr_t)lookupWriteAddressFor(memmgr,\n                            (void*)SectionLoadAddr);\n                Addr += SectionWriteCheck - SectionLoadAddr;\n                *pAddr = (uint8_t*)Addr;\n            }\n        }\n        assert(catchjmp);\n        assert(UnwindData);\n        assert(SectionAddrCheck);\n        assert(SectionLoadCheck);\n        assert(!memcmp(catchjmp, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 12) &&\n               !memcmp(UnwindData, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 12));\n        catchjmp[0] = 0x48;\n        catchjmp[1] = 0xb8; // mov RAX, QWORD PTR [&__julia_personality]\n        *(uint64_t*)(&catchjmp[2]) = (uint64_t)&__julia_personality;\n        catchjmp[10] = 0xff;\n        catchjmp[11] = 0xe0; // jmp RAX\n        UnwindData[0] = 0x09; // version info, UNW_FLAG_EHANDLER\n        UnwindData[1] = 4;    // size of prolog (bytes)\n        UnwindData[2] = 2;    // count of unwind codes (slots)\n        UnwindData[3] = 0x05; // frame register (rbp) = rsp\n        UnwindData[4] = 4;    // second instruction\n        UnwindData[5] = 0x03; // mov RBP, RSP\n        UnwindData[6] = 1;    // first instruction\n        UnwindData[7] = 0x50; // push RBP\n        *(DWORD*)&UnwindData[8] = (DWORD)(catchjmp - (uint8_t*)SectionWriteCheck); // relative location of catchjmp\n#endif // defined(_OS_X86_64_)\n#endif // defined(_OS_WINDOWS_)\n\n        auto symbols = object::computeSymbolSizes(debugObj);\n        bool first = true;\n        for (const auto &sym_size : symbols) {\n            const object::SymbolRef &sym_iter = sym_size.first;\n            object::SymbolRef::Type SymbolType = cantFail(sym_iter.getType());\n            if (SymbolType != object::SymbolRef::ST_Function) continue;\n            uint64_t Addr = cantFail(sym_iter.getAddress());\n            auto Section = cantFail(sym_iter.getSection());\n            if (Section == EndSection) continue;\n            if (!Section->isText()) continue;\n            uint64_t SectionAddr = Section->getAddress();\n#if JL_LLVM_VERSION >= 100000\n            StringRef secName = cantFail(Section->getName());\n#else\n            StringRef secName;\n            Section->getName(secName);\n#endif\n            uint64_t SectionLoadAddr = getLoadAddress(secName);\n            Addr -= SectionAddr - SectionLoadAddr;\n            StringRef sName = cantFail(sym_iter.getName());\n            uint64_t SectionSize = Section->getSize();\n            size_t Size = sym_size.second;\n#if defined(_OS_WINDOWS_)\n            if (SectionAddrCheck)\n                assert(SectionAddrCheck == SectionAddr &&\n                       SectionLoadCheck == SectionLoadAddr);\n            SectionAddrCheck = SectionAddr;\n            SectionLoadCheck = SectionLoadAddr;\n            create_PRUNTIME_FUNCTION(\n                   (uint8_t*)(uintptr_t)Addr, (size_t)Size, sName,\n                   (uint8_t*)(uintptr_t)SectionLoadAddr, (size_t)SectionSize, UnwindData);\n#endif\n            StringMap<jl_code_instance_t*>::iterator codeinst_it = codeinst_in_flight.find(sName);\n            jl_code_instance_t *codeinst = NULL;\n            if (codeinst_it != codeinst_in_flight.end()) {\n                codeinst = codeinst_it->second;\n                codeinst_in_flight.erase(codeinst_it);\n            }\n            jl_profile_atomic([&]() {\n                if (codeinst)\n                    linfomap[Addr] = std::make_pair(Size, codeinst->def);\n                if (first) {\n                    ObjectInfo tmp = {&debugObj,\n                        (size_t)SectionSize,\n                        (ptrdiff_t)(SectionAddr - SectionLoadAddr),\n                        *Section,\n                        nullptr,\n                        };\n                    objectmap[SectionLoadAddr] = tmp;\n                    first = false;\n                }\n            });\n        }\n        jl_gc_safe_leave(ptls, gc_state);\n    }\n\n    // must implement if we ever start freeing code\n    // virtual void NotifyFreeingObject(const ObjectImage &Object) {}\n    // virtual void NotifyFreeingObject(const object::ObjectFile &Obj) {}\n\n    std::map<size_t, ObjectInfo, revcomp>& getObjectMap() JL_NOTSAFEPOINT\n    {\n        return objectmap;\n    }\n};\n\nJL_DLLEXPORT void ORCNotifyObjectEmitted(JITEventListener *Listener,\n                                         const object::ObjectFile &Object,\n                                         const RuntimeDyld::LoadedObjectInfo &L,\n                                         RTDyldMemoryManager *memmgr)\n{\n    ((JuliaJITEventListener*)Listener)->_NotifyObjectEmitted(Object, L, memmgr);\n}\n\nstatic std::pair<char *, bool> jl_demangle(const char *name) JL_NOTSAFEPOINT\n{\n    // This function is not allowed to reference any TLS variables since\n    // it can be called from an unmanaged thread on OSX.\n    const char *start = name + 6;\n    const char *end = name + strlen(name);\n    char *ret;\n    if (end <= start)\n        goto done;\n    if (strncmp(name, \"japi1_\", 6) &&\n        strncmp(name, \"japi3_\", 6) &&\n        strncmp(name, \"julia_\", 6) &&\n        strncmp(name, \"jsys1_\", 6) &&\n        strncmp(name, \"jlsys_\", 6))\n        goto done;\n    if (*start == '\\0')\n        goto done;\n    while (*(--end) != '_') {\n        char c = *end;\n        if (c < '0' || c > '9')\n            goto done;\n    }\n    if (end <= start)\n        goto done;\n    ret = (char*)malloc_s(end - start + 1);\n    memcpy(ret, start, end - start);\n    ret[end - start] = '\\0';\n    return std::make_pair(ret, true);\ndone:\n    return std::make_pair(strdup(name), false);\n}\n\nstatic JuliaJITEventListener *jl_jit_events;\nJITEventListener *CreateJuliaJITEventListener(void)\n{\n    jl_jit_events = new JuliaJITEventListener();\n    return jl_jit_events;\n}\n\n// *frames is a one element array containing whatever we could come up\n// with for the current frame. here we'll try to expand it using debug info\n// func_name and file_name are either NULL or malloc'd pointers\nstatic int lookup_pointer(\n        object::SectionRef Section, DIContext *context,\n        jl_frame_t **frames, size_t pointer, int64_t slide,\n        bool demangle, bool noInline) JL_NOTSAFEPOINT\n{\n    // This function is not allowed to reference any TLS variables\n    // since it can be called from an unmanaged thread on OSX.\n    if (!context || !Section.getObject()) {\n        if (demangle) {\n            char *oldname = (*frames)[0].func_name;\n            if (oldname != NULL) {\n                std::pair<char *, bool> demangled = jl_demangle(oldname);\n                (*frames)[0].func_name = demangled.first;\n                (*frames)[0].fromC = !demangled.second;\n                free(oldname);\n            }\n            else {\n                // We do this to hide the jlcall wrappers when getting julia backtraces,\n                // but it is still good to have them for regular lookup of C frames.\n                // Technically not true, but we don't want them\n                // in julia backtraces, so close enough\n                (*frames)[0].fromC = 1;\n            }\n        }\n        return 1;\n    }\n    DILineInfoSpecifier infoSpec(DILineInfoSpecifier::FileLineInfoKind::AbsoluteFilePath,\n                                 DILineInfoSpecifier::FunctionNameKind::ShortName);\n\n    // DWARFContext/DWARFUnit update some internal tables during these queries, so\n    // a lock is needed.\n    uv_rwlock_wrlock(&threadsafe);\n    auto inlineInfo = context->getInliningInfoForAddress(makeAddress(Section, pointer + slide), infoSpec);\n    uv_rwlock_wrunlock(&threadsafe);\n\n    int fromC = (*frames)[0].fromC;\n    int n_frames = inlineInfo.getNumberOfFrames();\n    if (n_frames == 0) {\n        // no line number info available in the context, return without the context\n        return lookup_pointer(object::SectionRef(), NULL, frames, pointer, slide, demangle, noInline);\n    }\n    if (noInline)\n        n_frames = 1;\n    if (n_frames > 1) {\n        jl_frame_t *new_frames = (jl_frame_t*)calloc(sizeof(jl_frame_t), n_frames);\n        memcpy(&new_frames[n_frames - 1], *frames, sizeof(jl_frame_t));\n        free(*frames);\n        *frames = new_frames;\n    }\n    for (int i = 0; i < n_frames; i++) {\n        bool inlined_frame = i != n_frames - 1;\n        DILineInfo info;\n        if (!noInline) {\n            info = inlineInfo.getFrame(i);\n        }\n        else {\n            uv_rwlock_wrlock(&threadsafe);\n            info = context->getLineInfoForAddress(makeAddress(Section, pointer + slide), infoSpec);\n            uv_rwlock_wrunlock(&threadsafe);\n        }\n\n        jl_frame_t *frame = &(*frames)[i];\n        std::string func_name(info.FunctionName);\n\n        if (inlined_frame) {\n            frame->inlined = 1;\n            frame->fromC = fromC;\n            if (!fromC) {\n                std::size_t semi_pos = func_name.find(';');\n                if (semi_pos != std::string::npos) {\n                    func_name = func_name.substr(0, semi_pos);\n                    frame->linfo = NULL; // TODO: if (new_frames[n_frames - 1].linfo) frame->linfo = lookup(func_name in linfo)?\n                }\n            }\n        }\n\n        if (func_name == \"<invalid>\")\n            frame->func_name = NULL;\n        else\n            jl_copy_str(&frame->func_name, func_name.c_str());\n        if (!frame->func_name)\n            frame->fromC = 1;\n\n        frame->line = info.Line;\n        std::string file_name(info.FileName);\n\n        if (file_name == \"<invalid>\")\n            frame->file_name = NULL;\n        else\n            jl_copy_str(&frame->file_name, file_name.c_str());\n    }\n    return n_frames;\n}\n\n#ifdef _OS_DARWIN_\n#include <mach-o/dyld.h>\n#else\n#define LC_UUID 0\n#endif\n#ifndef _OS_WINDOWS_\n#include <dlfcn.h>\n#endif\ntypedef struct {\n    const llvm::object::ObjectFile *obj;\n    DIContext *ctx;\n    int64_t slide;\n} objfileentry_t;\ntypedef std::map<uint64_t, objfileentry_t, revcomp> obfiletype;\nstatic obfiletype objfilemap;\n\nstatic bool getObjUUID(llvm::object::MachOObjectFile *obj, uint8_t uuid[16]) JL_NOTSAFEPOINT\n{\n    for (auto Load : obj->load_commands())\n    {\n        if (Load.C.cmd == LC_UUID) {\n            memcpy(uuid, ((const MachO::uuid_command*)Load.Ptr)->uuid, 16);\n            return true;\n        }\n    }\n    return false;\n}\n\nstruct debug_link_info {\n    StringRef filename;\n    uint32_t crc32;\n};\nstatic debug_link_info getDebuglink(const object::ObjectFile &Obj) JL_NOTSAFEPOINT\n{\n    debug_link_info info = {};\n    for (const object::SectionRef &Section: Obj.sections()) {\n#if JL_LLVM_VERSION >= 100000\n        Expected<StringRef> sName = Section.getName();\n        if (sName && *sName == \".gnu_debuglink\")\n#else\n        StringRef sName;\n        if (!Section.getName(sName) && sName == \".gnu_debuglink\")\n#endif\n        {\n            auto found = Section.getContents();\n            if (found) {\n                StringRef Contents = *found;\n                size_t length = Contents.find('\\0');\n                info.filename = Contents.substr(0, length);\n                info.crc32 = *(const uint32_t*)Contents.substr(LLT_ALIGN(length + 1, 4), 4).data();\n                break;\n            }\n        }\n    }\n    return info;\n}\n/*\n * crc function from http://svnweb.freebsd.org/base/head/sys/libkern/crc32.c (and lldb)\n *\n *   COPYRIGHT (C) 1986 Gary S. Brown. You may use this program, or\n *   code or tables extracted from it, as desired without restriction.\n */\nstatic uint32_t\ncalc_gnu_debuglink_crc32(const void *buf, size_t size)\n{\n    static const uint32_t g_crc32_tab[] =\n    {\n        0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,\n        0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\n        0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,\n        0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n        0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n        0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,\n        0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,\n        0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n        0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,\n        0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n        0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,\n        0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n        0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,\n        0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,\n        0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n        0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n        0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,\n        0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,\n        0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,\n        0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n        0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,\n        0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,\n        0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,\n        0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n        0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n        0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,\n        0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,\n        0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n        0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,\n        0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n        0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,\n        0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n        0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,\n        0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,\n        0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n        0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n        0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,\n        0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,\n        0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,\n        0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n        0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,\n        0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,\n        0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\n    };\n    const uint8_t *p = (const uint8_t *)buf;\n    uint32_t crc;\n\n    crc = ~0U;\n    while (size--)\n        crc = g_crc32_tab[(crc ^ *p++) & 0xFF] ^ (crc >> 8);\n    return crc ^ ~0U;\n}\n\nstatic Expected<object::OwningBinary<object::ObjectFile>>\nopenDebugInfo(StringRef debuginfopath, const debug_link_info &info)\n{\n    auto SplitFile = MemoryBuffer::getFile(debuginfopath);\n    if (std::error_code EC = SplitFile.getError()) {\n        return errorCodeToError(EC);\n    }\n\n    uint32_t crc32 = calc_gnu_debuglink_crc32(\n            SplitFile.get()->getBufferStart(),\n            SplitFile.get()->getBufferSize());\n    if (crc32 != info.crc32) {\n        return errorCodeToError(object::object_error::arch_not_found);\n    }\n\n    auto error_splitobj = object::ObjectFile::createObjectFile(\n            SplitFile.get().get()->getMemBufferRef(),\n            file_magic::unknown);\n    if (!error_splitobj) {\n        return error_splitobj.takeError();\n    }\n\n    // successfully validated and loaded split debug info file\n    return object::OwningBinary<object::ObjectFile>(\n            std::move(error_splitobj.get()),\n            std::move(SplitFile.get()));\n}\n\nstatic uint64_t jl_sysimage_base;\nstatic jl_sysimg_fptrs_t sysimg_fptrs;\nstatic jl_method_instance_t **sysimg_fvars_linfo;\nstatic size_t sysimg_fvars_n;\nvoid jl_register_fptrs(uint64_t sysimage_base, const jl_sysimg_fptrs_t *fptrs,\n                       jl_method_instance_t **linfos, size_t n)\n{\n    jl_sysimage_base = (uintptr_t)sysimage_base;\n    sysimg_fptrs = *fptrs;\n    sysimg_fvars_linfo = linfos;\n    sysimg_fvars_n = n;\n}\n\ntemplate<typename T>\nstatic inline void ignoreError(T &err) JL_NOTSAFEPOINT\n{\n#if !defined(NDEBUG)\n    // Needed only with LLVM assertion build\n    consumeError(err.takeError());\n#endif\n}\n\nstatic void get_function_name_and_base(llvm::object::SectionRef Section, size_t pointer, int64_t slide, bool insysimage,\n                                       void **saddr, char **name, bool untrusted_dladdr) JL_NOTSAFEPOINT\n{\n    // Assume we only need base address for sysimg for now\n    if (!insysimage || !sysimg_fptrs.base)\n        saddr = nullptr;\n    bool needs_saddr = saddr && (!*saddr || untrusted_dladdr);\n    bool needs_name = name && (!*name || untrusted_dladdr);\n    // Try platform specific methods first since they are usually faster\n    if (needs_saddr) {\n#if (defined(_OS_LINUX_) || defined(_OS_FREEBSD_)) && !defined(JL_DISABLE_LIBUNWIND)\n        unw_proc_info_t pip;\n        // Seems that libunwind may return NULL IP depending on what info it finds...\n        if (unw_get_proc_info_by_ip(unw_local_addr_space, pointer,\n                                    &pip, NULL) == 0 && pip.start_ip) {\n            *saddr = (void*)pip.start_ip;\n            needs_saddr = false;\n        }\n#endif\n#if defined(_OS_WINDOWS_) && defined(_CPU_X86_64_)\n        DWORD64 ImageBase;\n        PRUNTIME_FUNCTION fn = RtlLookupFunctionEntry(pointer, &ImageBase, NULL);\n        if (fn) {\n            *saddr = (void*)(ImageBase + fn->BeginAddress);\n            needs_saddr = false;\n        }\n#endif\n    }\n    if (Section.getObject() && (needs_saddr || needs_name)) {\n        size_t distance = (size_t)-1;\n        SymRef sym_found;\n        for (auto sym : Section.getObject()->symbols()) {\n            if (!Section.containsSymbol(sym))\n                continue;\n            auto addr = sym.getAddress();\n            if (!addr)\n                continue;\n            size_t symptr = addr.get();\n            if (symptr > pointer + slide)\n                continue;\n            size_t new_dist = pointer + slide - symptr;\n            if (new_dist > distance)\n                continue;\n            distance = new_dist;\n            sym_found = sym;\n        }\n        if (distance != (size_t)-1) {\n            if (needs_saddr) {\n                uintptr_t addr = cantFail(sym_found.getAddress());\n                *saddr = (void*)(addr - slide);\n                needs_saddr = false;\n            }\n            if (needs_name) {\n                if (auto name_or_err = sym_found.getName()) {\n                    auto nameref = name_or_err.get();\n                    size_t len = nameref.size();\n                    *name = (char*)realloc_s(*name, len + 1);\n                    (*name)[len] = 0;\n                    memcpy(*name, nameref.data(), len);\n                    needs_name = false;\n                }\n            }\n        }\n    }\n#ifdef _OS_WINDOWS_\n    // For ntdll and msvcrt since we are currently only parsing DWARF debug info through LLVM\n    if (!insysimage && needs_name) {\n        static char frame_info_func[\n            sizeof(SYMBOL_INFO) +\n            MAX_SYM_NAME * sizeof(TCHAR)];\n        DWORD64 dwDisplacement64 = 0;\n        DWORD64 dwAddress = pointer;\n        PSYMBOL_INFO pSymbol = (PSYMBOL_INFO)frame_info_func;\n        pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);\n        pSymbol->MaxNameLen = MAX_SYM_NAME;\n        JL_LOCK_NOGC(&jl_in_stackwalk);\n        if (SymFromAddr(GetCurrentProcess(), dwAddress, &dwDisplacement64, pSymbol)) {\n            // errors are ignored\n            jl_copy_str(name, pSymbol->Name);\n        }\n        JL_UNLOCK_NOGC(&jl_in_stackwalk);\n    }\n#endif\n}\n\nstatic objfileentry_t &find_object_file(uint64_t fbase, StringRef fname) JL_NOTSAFEPOINT\n{\n    int isdarwin = 0, islinux = 0, iswindows = 0;\n#if defined(_OS_DARWIN_)\n    isdarwin = 1;\n#elif defined(_OS_LINUX_) || defined(_OS_FREEBSD_)\n    islinux = 1;\n#elif defined(_OS_WINDOWS_)\n    iswindows = 1;\n#endif\n    (void)iswindows;\n\n// GOAL: Read debuginfo from file\n    // TODO: need read/write lock here for objfilemap synchronization\n    obfiletype::iterator it = objfilemap.find(fbase);\n    if (it != objfilemap.end())\n        // Return cached value\n        return it->second;\n    auto &entry = objfilemap[fbase]; // default initialized\n\n// GOAL: Assign errorobj\n    StringRef objpath;\n    std::string debuginfopath;\n    uint8_t uuid[16], uuid2[16];\n    if (isdarwin) {\n        // Hide Darwin symbols (e.g. CoreFoundation) from non-Darwin systems.\n#ifdef _OS_DARWIN_\n\n        size_t msize = (size_t)(((uint64_t)-1) - fbase);\n        std::unique_ptr<MemoryBuffer> membuf = MemoryBuffer::getMemBuffer(\n                StringRef((const char *)fbase, msize), \"\", false);\n        auto origerrorobj = llvm::object::ObjectFile::createObjectFile(\n            membuf->getMemBufferRef(), file_magic::unknown);\n        if (!origerrorobj)\n            return entry;\n\n        llvm::object::MachOObjectFile *morigobj = (llvm::object::MachOObjectFile*)\n            origerrorobj.get().get();\n\n        // First find the uuid of the object file (we'll use this to make sure we find the\n        // correct debug symbol file).\n        if (!getObjUUID(morigobj, uuid))\n            return entry;\n\n        // On macOS, debug symbols are not contained in the dynamic library.\n        // Use DBGCopyFullDSYMURLForUUID from the private DebugSymbols framework\n        // to make use of spotlight to find the dSYM file. If that fails, lookup\n        // the dSYM file in the same directory as the dynamic library.  TODO: If\n        // the DebugSymbols framework is moved or removed, an alternative would\n        // be to directly query Spotlight for the dSYM bundle.\n\n        typedef CFURLRef (*DBGCopyFullDSYMURLForUUIDfn)(CFUUIDRef, CFURLRef) JL_NOTSAFEPOINT;\n        DBGCopyFullDSYMURLForUUIDfn DBGCopyFullDSYMURLForUUID = NULL;\n\n        // First, try to load the private DebugSymbols framework.\n        CFURLRef dsfmwkurl = CFURLCreateWithFileSystemPath(\n            kCFAllocatorDefault,\n            CFSTR(\"/System/Library/PrivateFrameworks/DebugSymbols.framework\"),\n            kCFURLPOSIXPathStyle, true);\n        CFBundleRef dsfmwkbundle =\n            CFBundleCreate(kCFAllocatorDefault, dsfmwkurl);\n        CFRelease(dsfmwkurl);\n\n        if (dsfmwkbundle) {\n            DBGCopyFullDSYMURLForUUID =\n                (DBGCopyFullDSYMURLForUUIDfn)CFBundleGetFunctionPointerForName(\n                    dsfmwkbundle, CFSTR(\"DBGCopyFullDSYMURLForUUID\"));\n        }\n\n        if (DBGCopyFullDSYMURLForUUID != NULL) {\n            // Prepare UUID and shared object path URL.\n            CFUUIDRef objuuid = CFUUIDCreateWithBytes(\n                kCFAllocatorDefault, uuid[0], uuid[1], uuid[2], uuid[3],\n                uuid[4], uuid[5], uuid[6], uuid[7], uuid[8], uuid[9], uuid[10],\n                uuid[11], uuid[12], uuid[13], uuid[14], uuid[15]);\n            CFURLRef objurl = CFURLCreateFromFileSystemRepresentation(\n                kCFAllocatorDefault, (UInt8 const *)fname.data(),\n                (CFIndex)strlen(fname.data()), FALSE);\n\n            // Call private DBGCopyFullDSYMURLForUUID() to find dSYM.\n            CFURLRef dsympathurl = DBGCopyFullDSYMURLForUUID(objuuid, objurl);\n            CFRelease(objuuid);\n            CFRelease(objurl);\n\n            char objpathcstr[PATH_MAX];\n            if (dsympathurl != NULL &&\n                CFURLGetFileSystemRepresentation(\n                    dsympathurl, true, (UInt8 *)objpathcstr,\n                    (CFIndex)sizeof(objpathcstr))) {\n                // The dSYM was found. Copy its path.\n                debuginfopath = objpathcstr;\n                objpath = debuginfopath;\n                CFRelease(dsympathurl);\n            }\n        }\n\n        if (dsfmwkbundle) {\n            CFRelease(dsfmwkbundle);\n        }\n\n        if (objpath.empty()) {\n            // Fall back to simple path relative to the dynamic library.\n            size_t sep = fname.rfind('/');\n            debuginfopath = fname.str();\n            debuginfopath += \".dSYM/Contents/Resources/DWARF/\";\n            debuginfopath += fname.substr(sep + 1);\n            objpath = debuginfopath;\n        }\n#endif\n    }\n    else {\n        // On Linux systems we need to mmap another copy because of the permissions on the mmap'ed shared library.\n        // On Windows we need to mmap another copy since reading the in-memory copy seems to return object_error:unexpected_eof\n        objpath = fname;\n    }\n    auto errorobj = llvm::object::ObjectFile::createObjectFile(objpath);\n\n// GOAL: Find obj, context, slide (if above succeeded)\n    if (errorobj) {\n        auto *debugobj = errorobj->getBinary();\n\n        if (islinux) {\n            // if the file has a .gnu_debuglink section,\n            // try to load its companion file instead\n            // in the expected locations\n            // for now, we don't support the build-id method\n            debug_link_info info = getDebuglink(*debugobj);\n            if (!info.filename.empty()) {\n                size_t sep = fname.rfind('/');\n                Expected<object::OwningBinary<object::ObjectFile>>\n                    DebugInfo(errorCodeToError(std::make_error_code(std::errc::no_such_file_or_directory)));\n                // Can't find a way to construct an empty Expected object\n                // that can be ignored.\n                if (fname.substr(sep + 1) != info.filename) {\n                    debuginfopath = fname.substr(0, sep + 1).str();\n                    debuginfopath += info.filename;\n                    ignoreError(DebugInfo);\n                    DebugInfo = openDebugInfo(debuginfopath, info);\n                }\n                if (!DebugInfo) {\n                    debuginfopath = fname.substr(0, sep + 1).str();\n                    debuginfopath += \".debug/\";\n                    debuginfopath += info.filename;\n                    ignoreError(DebugInfo);\n                    DebugInfo = openDebugInfo(debuginfopath, info);\n                }\n                if (!DebugInfo) {\n                    debuginfopath = \"/usr/lib/debug/\";\n                    debuginfopath += fname.substr(0, sep + 1);\n                    debuginfopath += info.filename;\n                    ignoreError(DebugInfo);\n                    DebugInfo = openDebugInfo(debuginfopath, info);\n                }\n                if (DebugInfo) {\n                    errorobj = std::move(DebugInfo);\n                    // Yes, we've checked, and yes LLVM want us to check again.\n                    assert(errorobj);\n                    debugobj = errorobj->getBinary();\n                }\n                else {\n                    ignoreError(DebugInfo);\n                }\n            }\n        }\n\n        if (isdarwin) {\n            // verify the UUID matches\n            if (!getObjUUID((llvm::object::MachOObjectFile*)debugobj, uuid2) ||\n                    memcmp(uuid, uuid2, sizeof(uuid)) != 0) {\n                return entry;\n            }\n        }\n\n        int64_t slide = 0;\n        if (auto *OF = dyn_cast<const object::COFFObjectFile>(debugobj)) {\n            assert(iswindows);\n            slide = OF->getImageBase() - fbase;\n        }\n        else {\n            slide = -(int64_t)fbase;\n        }\n\n        auto context = DWARFContext::create(*debugobj).release();\n        auto binary = errorobj->takeBinary();\n        binary.first.release();\n        binary.second.release();\n        // update cache\n        entry = {debugobj, context, slide};\n    }\n    else {\n        // TODO: report the error instead of silently consuming it?\n        //       jl_error might run into the same error again...\n        ignoreError(errorobj);\n    }\n    return entry;\n}\n\n// from llvm::SymbolizableObjectFile\nstatic object::SectionRef getModuleSectionForAddress(const object::ObjectFile *obj, uint64_t Address) JL_NOTSAFEPOINT\n{\n  for (object::SectionRef Sec : obj->sections()) {\n      if (!Sec.isText() || Sec.isVirtual())\n          continue;\n      if (Address >= Sec.getAddress() && Address < Sec.getAddress() + Sec.getSize())\n          return Sec;\n  }\n  return object::SectionRef();\n}\n\n\nbool jl_dylib_DI_for_fptr(size_t pointer, object::SectionRef *Section, int64_t *slide, llvm::DIContext **context,\n    bool onlySysImg, bool *isSysImg, void **saddr, char **name, char **filename) JL_NOTSAFEPOINT\n{\n    *Section = object::SectionRef();\n    *context = NULL;\n    // On Windows and FreeBSD, `dladdr` (or its equivalent) returns the closest exported symbol\n    // without checking the size.\n    // This causes the lookup to return incorrect non-NULL result for local functions\n    // when better result is available through other methods.\n    // macOS's `dladdr` returns local symbols and Linux's `dladdr`\n    // checks the symbol size so they do not have this problem.\n    // On systems with an untrusted dladdr, the result cannot be used for sysimg\n    // (it's always wrong) and should in general be used only as the last fallback.\n#if defined(_OS_FREEBSD_) || defined(_OS_WINDOWS_)\n    bool untrusted_dladdr = true;\n#else\n    bool untrusted_dladdr = false;\n#endif\n\n// GOAL: Determine containing Library\n// Assigning fname, fbase\n#ifdef _OS_WINDOWS_\n    IMAGEHLP_MODULE64 ModuleInfo;\n    ModuleInfo.SizeOfStruct = sizeof(IMAGEHLP_MODULE64);\n    JL_LOCK_NOGC(&jl_in_stackwalk);\n    jl_refresh_dbg_module_list();\n    bool isvalid = SymGetModuleInfo64(GetCurrentProcess(), (DWORD64)pointer, &ModuleInfo);\n    JL_UNLOCK_NOGC(&jl_in_stackwalk);\n    if (!isvalid)\n        return false;\n\n    StringRef fname = ModuleInfo.LoadedImageName;\n    if (fname.empty()) // empirically, LoadedImageName might be missing\n        fname = ModuleInfo.ImageName;\n    DWORD64 fbase = ModuleInfo.BaseOfImage;\n    bool insysimage = (fbase == jl_sysimage_base);\n    if (isSysImg)\n        *isSysImg = insysimage;\n    if (onlySysImg && !insysimage)\n        return false;\n    // If we didn't find the filename before in the debug\n    // info, use the dll name\n    if (filename && !*filename)\n        jl_copy_str(filename, fname.data());\n    if (saddr)\n        *saddr = NULL;\n\n#else // ifdef _OS_WINDOWS_\n    Dl_info dlinfo;\n    int dladdr_success;\n    uint64_t fbase;\n#ifdef __GLIBC__\n    struct link_map *extra_info;\n    dladdr_success = dladdr1((void*)pointer, &dlinfo, (void**)&extra_info, RTLD_DL_LINKMAP) != 0;\n#else\n    dladdr_success = dladdr((void*)pointer, &dlinfo) != 0;\n#endif\n    if (!dladdr_success || !dlinfo.dli_fname)\n        return false;\n\n#ifdef __GLIBC__\n    // dlinfo.dli_fbase is not the right value for the main executable on linux\n    fbase = (uintptr_t)extra_info->l_addr;\n#else\n    fbase = (uintptr_t)dlinfo.dli_fbase;\n#endif\n    StringRef fname;\n    bool insysimage = (fbase == jl_sysimage_base);\n    if (saddr && !(insysimage && untrusted_dladdr))\n        *saddr = dlinfo.dli_saddr;\n    if (isSysImg)\n        *isSysImg = insysimage;\n    if (onlySysImg && !insysimage)\n        return false;\n    // In case we fail with the debug info lookup, we at least still\n    // have the function name, even if we don't have line numbers\n    if (name && !(insysimage && untrusted_dladdr))\n        jl_copy_str(name, dlinfo.dli_sname);\n    if (filename)\n        jl_copy_str(filename, dlinfo.dli_fname);\n    fname = dlinfo.dli_fname;\n#endif // ifdef _OS_WINDOWS_\n    auto &entry = find_object_file(fbase, fname);\n    *slide = entry.slide;\n    *context = entry.ctx;\n    if (entry.obj)\n        *Section = getModuleSectionForAddress(entry.obj, pointer + entry.slide);\n    get_function_name_and_base(*Section, pointer, entry.slide, insysimage, saddr, name, untrusted_dladdr);\n    return true;\n}\n\n// *name and *filename should be either NULL or malloc'd pointer\nstatic int jl_getDylibFunctionInfo(jl_frame_t **frames, size_t pointer, int skipC, int noInline) JL_NOTSAFEPOINT\n{\n    // This function is not allowed to reference any TLS variables if noInline\n    // since it can be called from an unmanaged thread (the segfault handler)\n    jl_frame_t *frame0 = *frames;\n#ifdef _OS_WINDOWS_\n    static IMAGEHLP_LINE64 frame_info_line;\n    DWORD dwDisplacement = 0;\n    JL_LOCK_NOGC(&jl_in_stackwalk);\n    DWORD64 dwAddress = pointer;\n    frame_info_line.SizeOfStruct = sizeof(IMAGEHLP_LINE64);\n    if (SymGetLineFromAddr64(GetCurrentProcess(), dwAddress, &dwDisplacement, &frame_info_line)) {\n        // SymGetLineFromAddr64 returned success\n        // record source file name and line number\n        if (frame_info_line.FileName)\n            jl_copy_str(&frame0->file_name, frame_info_line.FileName);\n        frame0->line = frame_info_line.LineNumber;\n    }\n    JL_UNLOCK_NOGC(&jl_in_stackwalk);\n#endif\n    object::SectionRef Section;\n    llvm::DIContext *context = NULL;\n    int64_t slide;\n    bool isSysImg;\n    void *saddr;\n    if (!jl_dylib_DI_for_fptr(pointer, &Section, &slide, &context, skipC, &isSysImg, &saddr, &frame0->func_name, &frame0->file_name)) {\n        frame0->fromC = 1;\n        return 1;\n    }\n    frame0->fromC = !isSysImg;\n    if (isSysImg && sysimg_fptrs.base && saddr) {\n        intptr_t diff = (uintptr_t)saddr - (uintptr_t)sysimg_fptrs.base;\n        for (size_t i = 0; i < sysimg_fptrs.nclones; i++) {\n            if (diff == sysimg_fptrs.clone_offsets[i]) {\n                uint32_t idx = sysimg_fptrs.clone_idxs[i] & jl_sysimg_val_mask;\n                if (idx < sysimg_fvars_n) // items after this were cloned but not referenced directly by a method (such as our ccall PLT thunks)\n                    frame0->linfo = sysimg_fvars_linfo[idx];\n                break;\n            }\n        }\n        for (size_t i = 0; i < sysimg_fvars_n; i++) {\n            if (diff == sysimg_fptrs.offsets[i]) {\n                frame0->linfo = sysimg_fvars_linfo[i];\n                break;\n            }\n        }\n    }\n    return lookup_pointer(Section, context, frames, pointer, slide, isSysImg, noInline);\n}\n\nint jl_DI_for_fptr(uint64_t fptr, uint64_t *symsize, int64_t *slide,\n        object::SectionRef *Section, llvm::DIContext **context) JL_NOTSAFEPOINT\n{\n    int found = 0;\n    uv_rwlock_wrlock(&threadsafe);\n    std::map<size_t, ObjectInfo, revcomp> &objmap = jl_jit_events->getObjectMap();\n    std::map<size_t, ObjectInfo, revcomp>::iterator fit = objmap.lower_bound(fptr);\n\n    if (symsize)\n        *symsize = 0;\n    if (fit != objmap.end() && fptr < fit->first + fit->second.SectionSize) {\n        *slide = fit->second.slide;\n        *Section = fit->second.Section;\n        if (context) {\n            if (fit->second.context == nullptr)\n                fit->second.context = DWARFContext::create(*fit->second.object).release();\n            *context = fit->second.context;\n        }\n        found = 1;\n    }\n    uv_rwlock_wrunlock(&threadsafe);\n    return found;\n}\n\n// Set *name and *filename to either NULL or malloc'd string\nint jl_getFunctionInfo(jl_frame_t **frames_out, size_t pointer, int skipC, int noInline) JL_NOTSAFEPOINT\n{\n    // This function is not allowed to reference any TLS variables if noInline\n    // since it can be called from an unmanaged thread on OSX.\n\n    jl_frame_t *frames = (jl_frame_t*)calloc(sizeof(jl_frame_t), 1);\n    frames[0].line = -1;\n    *frames_out = frames;\n\n    llvm::DIContext *context;\n    object::SectionRef Section;\n    int64_t slide;\n    uint64_t symsize;\n    if (jl_DI_for_fptr(pointer, &symsize, &slide, &Section, &context)) {\n        frames[0].linfo = jl_jit_events->lookupLinfo(pointer);\n        int nf = lookup_pointer(Section, context, frames_out, pointer, slide, true, noInline);\n        return nf;\n    }\n    return jl_getDylibFunctionInfo(frames_out, pointer, skipC, noInline);\n}\n\nextern \"C\" jl_method_instance_t *jl_gdblookuplinfo(void *p) JL_NOTSAFEPOINT\n{\n    return jl_jit_events->lookupLinfo((size_t)p);\n}\n\n#if (defined(_OS_LINUX_) || defined(_OS_FREEBSD_) || (defined(_OS_DARWIN_) && defined(LLVM_SHLIB)))\nextern \"C\" void __register_frame(void*);\nextern \"C\" void __deregister_frame(void*);\n\ntemplate <typename callback>\nstatic void processFDEs(const char *EHFrameAddr, size_t EHFrameSize, callback f)\n{\n    const char *P = EHFrameAddr;\n    const char *End = P + EHFrameSize;\n    do {\n        const char *Entry = P;\n        P += 4;\n        assert(P <= End);\n        uint32_t Length = *(const uint32_t*)Entry;\n        // Length == 0: Terminator\n        if (Length == 0)\n            break;\n        assert(P + Length <= End);\n        uint32_t Offset = *(const uint32_t*)P;\n        // Offset == 0: CIE\n        if (Offset != 0)\n            f(Entry);\n        P += Length;\n    } while (P != End);\n}\n#endif\n\n#if defined(_OS_DARWIN_) && defined(LLVM_SHLIB)\n\n/*\n * We use a custom unwinder, so we need to make sure that when registering dynamic\n * frames, we do so with our unwinder rather than with the system one. If LLVM is\n * statically linked everything works out fine, but if it's dynamically linked\n * it would usually pick up the system one, so we need to do the registration\n * ourselves to ensure the right one gets picked.\n */\n\nstatic void (*libc_register_frame)(void*)   = NULL;\nstatic void (*libc_deregister_frame)(void*) = NULL;\n\n// This implementation handles frame registration for local targets.\nvoid register_eh_frames(uint8_t *Addr, size_t Size)\n{\n  // On OS X OS X __register_frame takes a single FDE as an argument.\n  // See http://lists.cs.uiuc.edu/pipermail/llvmdev/2013-April/061768.html\n  processFDEs((char*)Addr, Size, [](const char *Entry) {\n        if (!libc_register_frame) {\n          libc_register_frame = (void(*)(void*))dlsym(RTLD_NEXT, \"__register_frame\");\n        }\n        assert(libc_register_frame);\n        jl_profile_atomic([&]() {\n            libc_register_frame(const_cast<char *>(Entry));\n            __register_frame(const_cast<char *>(Entry));\n        });\n    });\n}\n\nvoid deregister_eh_frames(uint8_t *Addr, size_t Size)\n{\n   processFDEs((char*)Addr, Size, [](const char *Entry) {\n        if (!libc_deregister_frame) {\n          libc_deregister_frame = (void(*)(void*))dlsym(RTLD_NEXT, \"__deregister_frame\");\n        }\n        assert(libc_deregister_frame);\n        jl_profile_atomic([&]() {\n            libc_deregister_frame(const_cast<char *>(Entry));\n            __deregister_frame(const_cast<char *>(Entry));\n        });\n    });\n}\n\n#elif (defined(_OS_LINUX_) || defined(_OS_FREEBSD_)) && \\\n    defined(JL_UNW_HAS_FORMAT_IP) && \\\n    !defined(_CPU_ARM_) // ARM does not have/use .eh_frame, so we handle this elsewhere\n#include <type_traits>\n\nstruct unw_table_entry\n{\n    int32_t start_ip_offset;\n    int32_t fde_offset;\n};\n\n// Skip over an arbitrary long LEB128 encoding.\n// Return the pointer to the first unprocessed byte.\nstatic const uint8_t *consume_leb128(const uint8_t *Addr, const uint8_t *End)\n{\n    const uint8_t *P = Addr;\n    while ((*P >> 7) != 0 && P < End)\n        ++P;\n    return P + 1;\n}\n\n// Parse a LEB128 encoding to a type T. Truncate the result if there's more\n// bytes than what there are more bytes than what the type can store.\n// Adjust the pointer to the first unprocessed byte.\ntemplate<typename T> static T parse_leb128(const uint8_t *&Addr,\n                                           const uint8_t *End)\n{\n    typedef typename std::make_unsigned<T>::type uT;\n    uT v = 0;\n    for (unsigned i = 0;i < ((sizeof(T) * 8 - 1) / 7 + 1);i++) {\n        uint8_t a = *Addr;\n        Addr++;\n        v |= uT(a & 0x7f) << (i * 7);\n        if ((a & 0x80) == 0 || Addr >= End) {\n            if (a & 0x40 && std::is_signed<T>::value) {\n                int valid_bits = (i + 1) * 7;\n                if (valid_bits < 64) {\n                    v |= -(uT(1) << valid_bits);\n                }\n            }\n            return T(v);\n        }\n    }\n    Addr = consume_leb128(Addr, End);\n    return T(v);\n}\n\ntemplate <typename U, typename T>\nstatic U safe_trunc(T t)\n{\n    assert((t >= static_cast<T>(std::numeric_limits<U>::min()))\n           && (t <= static_cast<T>(std::numeric_limits<U>::max())));\n    return static_cast<U>(t);\n}\n\n// How the address and size in the FDE are encoded.\nenum DW_EH_PE : uint8_t {\n    DW_EH_PE_absptr = 0x00, /* An absolute pointer. The size is determined by\n                             * whether this is a 32-bit or 64-bit address space,\n                             * and will be 32 or 64 bits */\n    DW_EH_PE_omit = 0xff, // The value is omitted\n    DW_EH_PE_uleb128 = 0x01, // The value is an unsigned LEB128\n    DW_EH_PE_udata2 = 0x02,\n    DW_EH_PE_udata4 = 0x03,\n    DW_EH_PE_udata8 = 0x04, /* The value is stored as unsigned data with the\n                             * specified number of bytes. */\n    DW_EH_PE_signed = 0x08, /* A signed number. The size is determined by\n                             * whether this is a 32-bit or 64-bit address space */\n    DW_EH_PE_sleb128 = 0x09, /* A signed LEB128. */\n    DW_EH_PE_sdata2 = 0x0a,\n    DW_EH_PE_sdata4 = 0x0b,\n    DW_EH_PE_sdata8 = 0x0c, /* The value is stored as signed data with the\n                             * specified number of bytes. */\n\n    // In addition the above basic encodings, there are modifiers.\n\n    DW_EH_PE_pcrel = 0x10, // Value is PC relative.\n\n    // We currently don't support the following once.\n    DW_EH_PE_textrel = 0x20, // Value is text relative.\n    DW_EH_PE_datarel = 0x30, // Value is data relative.\n    DW_EH_PE_funcrel = 0x40, // Value is relative to start of function.\n    DW_EH_PE_aligned = 0x50, /* Value is aligned: padding bytes are inserted as\n                              * required to make value be naturally aligned. */\n    DW_EH_PE_indirect = 0x80 /* This is actually the address of the real value. */\n};\n\n// Parse the CIE and return the type of encoding used by FDE\nstatic DW_EH_PE parseCIE(const uint8_t *Addr, const uint8_t *End)\n{\n    // http://www.airs.com/blog/archives/460\n    // Length (4 bytes)\n    uint32_t cie_size = *(const uint32_t*)Addr;\n    const uint8_t *cie_addr = Addr + 4;\n    const uint8_t *p = cie_addr;\n    const uint8_t *cie_end = cie_addr + cie_size;\n    assert(cie_end <= End);\n    // Check this is an CIE record (CIE ID: 4 bytes)\n    assert(*(const uint32_t*)cie_addr == 0);\n    p += 4;\n    // Check CIE version (1 byte)\n    uint8_t cie_version = *p;\n    assert(cie_version == 1 || cie_version == 3);\n    p++;\n    // Augmentation String (NUL terminate)\n    const char *augmentation = (const char*)p;\n    size_t augmentation_len = strlen(augmentation);\n    // Assume there's no EH Data field, which exist when the augmentation\n    // string has \"eh\" in it.\n    p += augmentation_len + 1;\n    // Code Alignment Factor (1 byte)\n    // should always be 1 on x86, 4 on PPC, etc.\n    // (used for DW_CFA_advance_loc / not used here)\n    //assert(*p == 1);\n    p++;\n    // Data Alignment Factor (LEB128)\n    assert(cie_end >= p);\n    p = consume_leb128(p, cie_end);\n    // return address register\n    if (cie_version == 1) {\n        p++;\n    }\n    else {\n        p = consume_leb128(p, cie_end);\n    }\n    // Now it's the augmentation data. which may have the information we\n    // are interested in...\n    for (const char *augp = augmentation;;augp++) {\n        switch (*augp) {\n        case 'z':\n            // Augmentation Length\n            p = consume_leb128(p, cie_end);\n            break;\n        case 'L':\n            // LSDA encoding\n            p++;\n            break;\n        case 'R':\n            // .... the only one we care about ....\n            return static_cast<DW_EH_PE>(*p);\n        case 'P': {\n            // Personality data\n            // Encoding\n            auto encoding = static_cast<DW_EH_PE>(*p);\n            p++;\n            // Personality function\n            switch (encoding & 0xf) {\n            case DW_EH_PE_uleb128:\n            case DW_EH_PE_sleb128:\n                p = consume_leb128(p, cie_end);\n                break;\n            case DW_EH_PE_udata2:\n            case DW_EH_PE_sdata2:\n                p += 2;\n                break;\n            case DW_EH_PE_udata4:\n            case DW_EH_PE_sdata4:\n                p += 4;\n                break;\n            case DW_EH_PE_udata8:\n            case DW_EH_PE_sdata8:\n                p += 8;\n                break;\n            case DW_EH_PE_signed:\n                p += sizeof(void*);\n                break;\n            default:\n                if (encoding == DW_EH_PE_absptr || encoding == DW_EH_PE_omit) {\n                    p += sizeof(void*);\n                }\n                else {\n                    assert(0 && \"Invalid personality encoding.\");\n                }\n                break;\n            }\n        }\n            break;\n        default:\n            continue;\n        }\n        assert(cie_end >= p);\n    }\n    return DW_EH_PE_absptr;\n}\n\nvoid register_eh_frames(uint8_t *Addr, size_t Size)\n{\n    // System unwinder\n    jl_profile_atomic([&]() {\n        __register_frame(Addr);\n    });\n    // Our unwinder\n    unw_dyn_info_t *di = new unw_dyn_info_t;\n    // In a shared library, this is set to the address of the PLT.\n    // For us, just put 0 to emulate a static library. This field does\n    // not seem to be used on our supported architectures.\n    di->gp = 0;\n    // I'm not a great fan of the naming of this constant, but it means the\n    // right thing, which is a table of FDEs and ips.\n    di->format = UNW_INFO_FORMAT_IP_OFFSET;\n    di->u.rti.name_ptr = 0;\n    di->u.rti.segbase = (unw_word_t)Addr;\n    // Now first count the number of FDEs\n    size_t nentries = 0;\n    processFDEs((char*)Addr, Size, [&](const char*){ nentries++; });\n\n    uintptr_t start_ip = (uintptr_t)-1;\n    uintptr_t end_ip = 0;\n\n    // Then allocate a table and fill in the information\n    // While we're at it, also record the start_ip and size,\n    // which we fill in the table\n    unw_table_entry *table = new unw_table_entry[nentries];\n    std::vector<uintptr_t> start_ips(nentries);\n    size_t cur_entry = 0;\n    // Cache the previously parsed CIE entry so that we can support multiple\n    // CIE's (may not happen) without parsing it every time.\n    const uint8_t *cur_cie = nullptr;\n    DW_EH_PE encoding = DW_EH_PE_omit;\n    processFDEs((char*)Addr, Size, [&](const char *Entry) {\n            // Skip Length (4bytes) and CIE offset (4bytes)\n            uint32_t fde_size = *(const uint32_t*)Entry;\n            uint32_t cie_id = ((const uint32_t*)Entry)[1];\n            const uint8_t *cie_addr = (const uint8_t*)(Entry + 4 - cie_id);\n            if (cie_addr != cur_cie)\n                encoding = parseCIE(cie_addr, Addr + Size);\n            const uint8_t *fde_end = (const uint8_t*)(Entry + 4 + fde_size);\n            const uint8_t *EntryPtr = (const uint8_t*)(Entry + 8);\n            uintptr_t start = 0;\n            uintptr_t size = 0;\n            // The next two fields are address and size of the PC range\n            // covered by this FDE.\n            if (encoding == DW_EH_PE_absptr || encoding == DW_EH_PE_omit) {\n                assert(fde_size >= 2 * sizeof(void*) + 4);\n                start = *(const uintptr_t*)EntryPtr;\n                size = *(const uintptr_t*)(EntryPtr + sizeof(void*));\n            }\n            else {\n                uintptr_t baseptr = (uintptr_t)EntryPtr;\n                // Only support pcrel for now...\n                assert((encoding & 0xf0) == 0x10 &&\n                       \"Only pcrel mode is supported\");\n                switch (encoding & 0xf) {\n                case DW_EH_PE_uleb128:\n                    start = baseptr + parse_leb128<uintptr_t>(EntryPtr, fde_end);\n                    size = parse_leb128<uintptr_t>(EntryPtr, fde_end);\n                    break;\n                case DW_EH_PE_udata2:\n                    assert(fde_size >= 2 * 2 + 4);\n                    start = baseptr + ((const uint16_t*)EntryPtr)[0];\n                    size = ((const uint16_t*)EntryPtr)[1];\n                    break;\n                case DW_EH_PE_udata4:\n                    assert(fde_size >= 2 * 4 + 4);\n                    start = baseptr + ((const uint32_t*)EntryPtr)[0];\n                    size = ((const uint32_t*)EntryPtr)[1];\n                    break;\n                case DW_EH_PE_udata8:\n                    assert(fde_size >= 2 * 8 + 4);\n                    start = uintptr_t(baseptr + ((const uint64_t*)EntryPtr)[0]);\n                    size = uintptr_t(((const uint64_t*)EntryPtr)[1]);\n                    break;\n                case DW_EH_PE_signed:\n                    assert(fde_size >= 2 * sizeof(void*) + 4);\n                    start = baseptr + ((const intptr_t*)EntryPtr)[0];\n                    size = ((const intptr_t*)EntryPtr)[1];\n                    break;\n                case DW_EH_PE_sleb128:\n                    start = baseptr + parse_leb128<intptr_t>(EntryPtr, fde_end);\n                    size = parse_leb128<intptr_t>(EntryPtr, fde_end);\n                    break;\n                case DW_EH_PE_sdata2:\n                    assert(fde_size >= 2 * 2 + 4);\n                    start = baseptr + ((const int16_t*)EntryPtr)[0];\n                    size = ((const int16_t*)EntryPtr)[1];\n                    break;\n                case DW_EH_PE_sdata4:\n                    assert(fde_size >= 2 * 4 + 4);\n                    start = baseptr + ((const int32_t*)EntryPtr)[0];\n                    size = ((const int32_t*)EntryPtr)[1];\n                    break;\n                case DW_EH_PE_sdata8:\n                    assert(fde_size >= 2 * 8 + 4);\n                    start = uintptr_t(baseptr + ((const int64_t*)EntryPtr)[0]);\n                    size = uintptr_t(((const int64_t*)EntryPtr)[1]);\n                    break;\n                default:\n                    assert(0 && \"Invalid FDE encoding.\");\n                    break;\n                }\n            }\n\n            if (start < start_ip)\n                start_ip = start;\n            if (end_ip < (start + size))\n                end_ip = start + size;\n            table[cur_entry].fde_offset =\n                safe_trunc<int32_t>((intptr_t)Entry - (intptr_t)Addr);\n            start_ips[cur_entry] = start;\n            cur_entry++;\n        });\n    for (size_t i = 0; i < nentries; i++) {\n        table[i].start_ip_offset =\n            safe_trunc<int32_t>((intptr_t)start_ips[i] - (intptr_t)start_ip);\n    }\n    assert(end_ip != 0);\n\n    di->u.rti.table_len = nentries * sizeof(*table) / sizeof(unw_word_t);\n    di->u.rti.table_data = (unw_word_t)table;\n    di->start_ip = start_ip;\n    di->end_ip = end_ip;\n\n    jl_profile_atomic([&]() {\n        _U_dyn_register(di);\n    });\n}\n\nvoid deregister_eh_frames(uint8_t *Addr, size_t Size)\n{\n    jl_profile_atomic([&]() {\n        __deregister_frame(Addr);\n    });\n    // Deregistering with our unwinder (_U_dyn_cancel) requires a lookup table\n    // to find the allocated entry above (or looking into libunwind's internal\n    // data structures).\n}\n\n#else\n\nvoid register_eh_frames(uint8_t *Addr, size_t Size)\n{\n}\n\nvoid deregister_eh_frames(uint8_t *Addr, size_t Size)\n{\n}\n\n#endif\n\nextern \"C\"\nuint64_t jl_getUnwindInfo(uint64_t dwAddr)\n{\n    // Might be called from unmanaged thread\n    uv_rwlock_rdlock(&threadsafe);\n    std::map<size_t, ObjectInfo, revcomp> &objmap = jl_jit_events->getObjectMap();\n    std::map<size_t, ObjectInfo, revcomp>::iterator it = objmap.lower_bound(dwAddr);\n    uint64_t ipstart = 0; // ip of the start of the section (if found)\n    if (it != objmap.end() && dwAddr < it->first + it->second.SectionSize) {\n        ipstart = (uint64_t)(uintptr_t)(*it).first;\n    }\n    uv_rwlock_rdunlock(&threadsafe);\n    return ipstart;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/ccall.cpp": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n// --- the ccall, cglobal, and llvm intrinsics ---\n#include \"llvm/Support/Path.h\" // for llvm::sys::path\n#include <llvm/Bitcode/BitcodeReader.h>\n#include <llvm/Linker/Linker.h>\n\n#ifdef _OS_WINDOWS_\nextern const char jl_crtdll_basename[];\n#endif\n\n// somewhat unusual variable, in that aotcompile wants to get the address of this for a sanity check\nGlobalVariable *jl_emit_RTLD_DEFAULT_var(Module *M)\n{\n    return prepare_global_in(M, jlRTLD_DEFAULT_var);\n}\n\n// Find or create the GVs for the library and symbol lookup.\n// Return `runtime_lib` (whether the library name is a string)\n// The `lib` and `sym` GV returned may not be in the current module.\nstatic bool runtime_sym_gvs(jl_codegen_params_t &emission_context, const char *f_lib, const char *f_name,\n                            GlobalVariable *&lib, GlobalVariable *&sym)\n{\n    Module *M = emission_context.shared_module(jl_LLVMContext);\n    bool runtime_lib = false;\n    GlobalVariable *libptrgv;\n    jl_codegen_params_t::SymMapGV *symMap;\n#ifdef _OS_WINDOWS_\n    if ((intptr_t)f_lib == (intptr_t)JL_EXE_LIBNAME) {\n        libptrgv = prepare_global_in(M, jlexe_var);\n        symMap = &emission_context.symMapExe;\n    }\n    else if ((intptr_t)f_lib == (intptr_t)JL_LIBJULIA_INTERNAL_DL_LIBNAME) {\n        libptrgv = prepare_global_in(M, jldll_var);\n        symMap = &emission_context.symMapDl;\n    }\n    else\n#endif\n    if (f_lib == NULL) {\n        libptrgv = jl_emit_RTLD_DEFAULT_var(M);\n        symMap = &emission_context.symMapDefault;\n    }\n    else {\n        std::string name = \"ccalllib_\";\n        name += llvm::sys::path::filename(f_lib);\n        name += std::to_string(globalUnique++);\n        runtime_lib = true;\n        auto &libgv = emission_context.libMapGV[f_lib];\n        if (libgv.first == NULL) {\n            libptrgv = new GlobalVariable(*M, T_pint8, false,\n                                          GlobalVariable::ExternalLinkage,\n                                          Constant::getNullValue(T_pint8), name);\n            libgv.first = libptrgv;\n        }\n        else {\n            libptrgv = libgv.first;\n        }\n        symMap = &libgv.second;\n    }\n\n    GlobalVariable *&llvmgv = (*symMap)[f_name];\n    if (llvmgv == NULL) {\n        std::string name = \"ccall_\";\n        name += f_name;\n        name += \"_\";\n        name += std::to_string(globalUnique++);\n        llvmgv = new GlobalVariable(*M, T_pvoidfunc, false,\n                                    GlobalVariable::ExternalLinkage,\n                                    Constant::getNullValue(T_pvoidfunc), name);\n    }\n\n    lib = libptrgv;\n    sym = llvmgv;\n    return runtime_lib;\n}\n\nstatic Value *runtime_sym_lookup(\n        jl_codegen_params_t &emission_context,\n        IRBuilder<> &irbuilder,\n        jl_codectx_t *ctx,\n        PointerType *funcptype, const char *f_lib, jl_value_t *lib_expr,\n        const char *f_name, Function *f,\n        GlobalVariable *libptrgv,\n        GlobalVariable *llvmgv, bool runtime_lib)\n{\n    // in pseudo-code, this function emits the following:\n    //   global HMODULE *libptrgv\n    //   global void **llvmgv\n    //   if (*llvmgv == NULL) {\n    //       *llvmgv = jl_load_and_lookup(f_lib, f_name, libptrgv);\n    //   }\n    //   return (*llvmgv)\n    BasicBlock *enter_bb = irbuilder.GetInsertBlock();\n    BasicBlock *dlsym_lookup = BasicBlock::Create(jl_LLVMContext, \"dlsym\");\n    BasicBlock *ccall_bb = BasicBlock::Create(jl_LLVMContext, \"ccall\");\n    Constant *initnul = ConstantPointerNull::get((PointerType*)T_pvoidfunc);\n    LoadInst *llvmf_orig = irbuilder.CreateAlignedLoad(T_pvoidfunc, llvmgv, Align(sizeof(void*)));\n    // This in principle needs a consume ordering so that load from\n    // this pointer sees a valid value. However, this is not supported by\n    // LLVM (or agreed on in the C/C++ standard FWIW) and should be\n    // almost impossible to happen on every platform we support since this\n    // ordering is enforced by the hardware and LLVM has to speculate an\n    // invalid load from the `cglobal` but doesn't depend on the `cglobal`\n    // value for this to happen.\n    llvmf_orig->setAtomic(AtomicOrdering::Unordered);\n    irbuilder.CreateCondBr(\n            irbuilder.CreateICmpNE(llvmf_orig, initnul),\n            ccall_bb,\n            dlsym_lookup);\n\n    assert(f->getParent() != NULL);\n    f->getBasicBlockList().push_back(dlsym_lookup);\n    irbuilder.SetInsertPoint(dlsym_lookup);\n    Instruction *llvmf;\n    Value *nameval = stringConstPtr(emission_context, irbuilder, f_name);\n    if (lib_expr) {\n        jl_cgval_t libval = emit_expr(*ctx, lib_expr);\n        llvmf = irbuilder.CreateCall(prepare_call_in(jl_builderModule(irbuilder), jllazydlsym_func),\n                    { boxed(*ctx, libval), nameval });\n    }\n    else {\n        Value *libname;\n        if (runtime_lib) {\n            libname = stringConstPtr(emission_context, irbuilder, f_lib);\n        }\n        else {\n            // f_lib is actually one of the special sentinel values\n            libname = ConstantExpr::getIntToPtr(ConstantInt::get(T_size, (uintptr_t)f_lib), T_pint8);\n        }\n        llvmf = irbuilder.CreateCall(prepare_call_in(jl_builderModule(irbuilder), jldlsym_func),\n                    { libname, nameval, libptrgv });\n    }\n    StoreInst *store = irbuilder.CreateAlignedStore(llvmf, llvmgv, Align(sizeof(void*)));\n    store->setAtomic(AtomicOrdering::Release);\n    irbuilder.CreateBr(ccall_bb);\n\n    f->getBasicBlockList().push_back(ccall_bb);\n    irbuilder.SetInsertPoint(ccall_bb);\n    PHINode *p = irbuilder.CreatePHI(T_pvoidfunc, 2);\n    p->addIncoming(llvmf_orig, enter_bb);\n    p->addIncoming(llvmf, llvmf->getParent());\n    return irbuilder.CreateBitCast(p, funcptype);\n}\n\nstatic Value *runtime_sym_lookup(\n        jl_codectx_t &ctx,\n        PointerType *funcptype, const char *f_lib, jl_value_t *lib_expr,\n        const char *f_name, Function *f,\n        GlobalVariable *libptrgv,\n        GlobalVariable *llvmgv, bool runtime_lib)\n{\n    return runtime_sym_lookup(ctx.emission_context, ctx.builder, &ctx, funcptype, f_lib, lib_expr,\n                              f_name, f, libptrgv, llvmgv, runtime_lib);\n}\n\nstatic Value *runtime_sym_lookup(\n        jl_codectx_t &ctx,\n        PointerType *funcptype, const char *f_lib, jl_value_t *lib_expr,\n        const char *f_name, Function *f)\n{\n    GlobalVariable *libptrgv;\n    GlobalVariable *llvmgv;\n    bool runtime_lib;\n    if (lib_expr) {\n        // for computed library names, generate a global variable to cache the function\n        // pointer just for this call site.\n        runtime_lib = true;\n        libptrgv = NULL;\n        std::string gvname = \"libname_\";\n        gvname += f_name;\n        gvname += \"_\";\n        gvname += std::to_string(globalUnique++);\n        llvmgv = new GlobalVariable(*jl_Module, T_pvoidfunc, false,\n                                    GlobalVariable::ExternalLinkage,\n                                    Constant::getNullValue(T_pvoidfunc), gvname);\n    }\n    else {\n        runtime_lib = runtime_sym_gvs(ctx.emission_context, f_lib, f_name, libptrgv, llvmgv);\n        libptrgv = prepare_global_in(jl_Module, libptrgv);\n    }\n    llvmgv = prepare_global_in(jl_Module, llvmgv);\n    return runtime_sym_lookup(ctx, funcptype, f_lib, lib_expr, f_name, f, libptrgv, llvmgv, runtime_lib);\n}\n\n// Emit a \"PLT\" entry that will be lazily initialized\n// when being called the first time.\nstatic GlobalVariable *emit_plt_thunk(\n        jl_codegen_params_t &emission_context,\n        FunctionType *functype, const AttributeList &attrs,\n        CallingConv::ID cc, const char *f_lib, const char *f_name,\n        GlobalVariable *libptrgv, GlobalVariable *llvmgv,\n        bool runtime_lib)\n{\n    Module *M = emission_context.shared_module(jl_LLVMContext);\n    PointerType *funcptype = PointerType::get(functype, 0);\n    libptrgv = prepare_global_in(M, libptrgv);\n    llvmgv = prepare_global_in(M, llvmgv);\n    std::string fname;\n    raw_string_ostream(fname) << \"jlplt_\" << f_name << \"_\" << globalUnique++;\n    Function *plt = Function::Create(functype,\n                                     GlobalVariable::ExternalLinkage,\n                                     fname, M);\n    plt->setAttributes(attrs);\n    if (cc != CallingConv::C)\n        plt->setCallingConv(cc);\n    fname += \"_got\";\n    GlobalVariable *got = new GlobalVariable(*M, T_pvoidfunc, false,\n                                             GlobalVariable::ExternalLinkage,\n                                             ConstantExpr::getBitCast(plt, T_pvoidfunc),\n                                             fname);\n    BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", plt);\n    IRBuilder<> irbuilder(b0);\n    Value *ptr = runtime_sym_lookup(emission_context, irbuilder, NULL, funcptype, f_lib, NULL, f_name, plt, libptrgv,\n                                    llvmgv, runtime_lib);\n    StoreInst *store = irbuilder.CreateAlignedStore(irbuilder.CreateBitCast(ptr, T_pvoidfunc), got, Align(sizeof(void*)));\n    store->setAtomic(AtomicOrdering::Release);\n    SmallVector<Value*, 16> args;\n    for (Function::arg_iterator arg = plt->arg_begin(), arg_e = plt->arg_end(); arg != arg_e; ++arg)\n        args.push_back(&*arg);\n    CallInst *ret = irbuilder.CreateCall(\n        cast<FunctionType>(ptr->getType()->getPointerElementType()),\n        ptr, ArrayRef<Value*>(args));\n    ret->setAttributes(attrs);\n    if (cc != CallingConv::C)\n        ret->setCallingConv(cc);\n    // NoReturn function can trigger LLVM verifier error when declared as\n    // MustTail since other passes might replace the `ret` with\n    // `unreachable` (LLVM should probably accept `unreachable`).\n    if (attrs.hasAttribute(AttributeList::FunctionIndex,\n                           Attribute::NoReturn)) {\n        irbuilder.CreateUnreachable();\n    }\n    else {\n        // musttail support is very bad on ARM, PPC, PPC64 (as of LLVM 3.9)\n        // Known failures includes vararg (not needed here) and sret.\n#if (defined(_CPU_X86_) || defined(_CPU_X86_64_) || \\\n                        defined(_CPU_AARCH64_))\n        // Ref https://bugs.llvm.org/show_bug.cgi?id=47058\n        // LLVM, as of 10.0.1 emits wrong/worse code when musttail is set\n        if (!attrs.hasAttrSomewhere(Attribute::ByVal))\n            ret->setTailCallKind(CallInst::TCK_MustTail);\n#endif\n        if (functype->getReturnType() == T_void) {\n            irbuilder.CreateRetVoid();\n        }\n        else {\n            irbuilder.CreateRet(ret);\n        }\n    }\n    irbuilder.ClearInsertionPoint();\n\n    return got;\n}\n\nstatic Value *emit_plt(\n        jl_codectx_t &ctx,\n        FunctionType *functype,\n        const AttributeList &attrs,\n        CallingConv::ID cc, const char *f_lib, const char *f_name)\n{\n    assert(imaging_mode);\n    // Don't do this for vararg functions so that the `musttail` is only\n    // an optimization and is not required to function correctly.\n    assert(!functype->isVarArg());\n    GlobalVariable *libptrgv;\n    GlobalVariable *llvmgv;\n    bool runtime_lib = runtime_sym_gvs(ctx.emission_context, f_lib, f_name, libptrgv, llvmgv);\n    PointerType *funcptype = PointerType::get(functype, 0);\n\n    auto &pltMap = ctx.emission_context.allPltMap[attrs];\n    auto key = std::make_tuple(llvmgv, functype, cc);\n    GlobalVariable *&sharedgot = pltMap[key];\n    if (!sharedgot) {\n        sharedgot = emit_plt_thunk(ctx.emission_context,\n                functype, attrs, cc, f_lib, f_name, libptrgv, llvmgv, runtime_lib);\n    }\n    GlobalVariable *got = prepare_global_in(jl_Module, sharedgot);\n    LoadInst *got_val = ctx.builder.CreateAlignedLoad(got, Align(sizeof(void*)));\n    // See comment in `runtime_sym_lookup` above. This in principle needs a\n    // consume ordering too. This is even less likely to cause issues though\n    // since the only thing we do to this loaded pointer is to call it\n    // immediately.\n    got_val->setAtomic(AtomicOrdering::Unordered);\n    return ctx.builder.CreateBitCast(got_val, funcptype);\n}\n\n// --- ABI Implementations ---\n// Partially based on the LDC ABI implementations licensed under the BSD 3-clause license\n\nclass AbiLayout {\npublic:\n    virtual ~AbiLayout() {}\n    virtual bool use_sret(jl_datatype_t *ty) = 0;\n    virtual bool needPassByRef(jl_datatype_t *ty, AttrBuilder&) = 0;\n    virtual Type *preferred_llvm_type(jl_datatype_t *ty, bool isret) const = 0;\n};\n\n// Determine if object of bitstype ty maps to a native x86 SIMD type (__m128, __m256, or __m512) in C\nstatic bool is_native_simd_type(jl_datatype_t *dt) {\n    size_t size = jl_datatype_size(dt);\n    if (size != 16 && size != 32 && size != 64)\n        // Wrong size for xmm, ymm, or zmm register.\n        return false;\n    uint32_t n = jl_datatype_nfields(dt);\n    if (n<2)\n        // Not mapped to SIMD register.\n        return false;\n    jl_value_t *ft0 = jl_field_type(dt, 0);\n    for (uint32_t i = 1; i < n; ++i)\n        if (jl_field_type(dt, i) != ft0)\n            // Not homogeneous\n            return false;\n    // Type is homogeneous.  Check if it maps to LLVM vector.\n    return jl_special_vector_alignment(n, ft0) != 0;\n}\n\n#include \"abi_llvm.cpp\"\n\n#include \"abi_arm.cpp\"\n#include \"abi_aarch64.cpp\"\n#include \"abi_ppc64le.cpp\"\n#include \"abi_win32.cpp\"\n#include \"abi_win64.cpp\"\n#include \"abi_x86_64.cpp\"\n#include \"abi_x86.cpp\"\n\n#if defined ABI_LLVM\n  typedef ABI_LLVMLayout DefaultAbiState;\n#elif defined _CPU_X86_64_\n#  if defined _OS_WINDOWS_\n     typedef ABI_Win64Layout DefaultAbiState;\n#  else\n     typedef ABI_x86_64Layout DefaultAbiState;\n#  endif\n#elif defined _CPU_X86_\n#  if defined _OS_WINDOWS_\n     typedef ABI_Win32Layout DefaultAbiState;\n#  else\n     typedef ABI_x86Layout DefaultAbiState;\n#  endif\n#elif defined _CPU_ARM_\n  typedef ABI_ARMLayout DefaultAbiState;\n#elif defined _CPU_AARCH64_\n  typedef ABI_AArch64Layout DefaultAbiState;\n#elif defined _CPU_PPC64_\n  typedef ABI_PPC64leLayout DefaultAbiState;\n#else\n#  warning \"ccall is defaulting to llvm ABI, since no platform ABI has been defined for this CPU/OS combination\"\n  typedef ABI_LLVMLayout DefaultAbiState;\n#endif\n\n// basic type widening and cast conversions\nstatic Value *llvm_type_rewrite(\n        jl_codectx_t &ctx,\n        Value *v, Type *target_type,\n        bool issigned) /* determines whether an integer value should be zero or sign extended */\n{\n    Type *from_type = v->getType();\n    if (target_type == from_type)\n        return v;\n\n    if (from_type == T_void || isa<UndefValue>(v))\n        return UndefValue::get(target_type); // convert undef (unreachable) -> undef (target_type)\n\n    assert(from_type->isPointerTy() == target_type->isPointerTy()); // expect that all ABIs consider all pointers to be equivalent\n    if (target_type->isPointerTy())\n        return emit_bitcast(ctx, v, target_type);\n\n    // simple integer and float widening & conversion cases\n    if (from_type->getPrimitiveSizeInBits() > 0 &&\n            target_type->getPrimitiveSizeInBits() == from_type->getPrimitiveSizeInBits())\n        return emit_bitcast(ctx, v, target_type);\n\n    if (target_type->isFloatingPointTy() && from_type->isFloatingPointTy()) {\n        if (target_type->getPrimitiveSizeInBits() > from_type->getPrimitiveSizeInBits())\n            return ctx.builder.CreateFPExt(v, target_type);\n        else if (target_type->getPrimitiveSizeInBits() < from_type->getPrimitiveSizeInBits())\n            return ctx.builder.CreateFPTrunc(v, target_type);\n        else\n            return v;\n    }\n\n    if (target_type->isIntegerTy() && from_type->isIntegerTy()) {\n        if (issigned)\n            return ctx.builder.CreateSExtOrTrunc(v, target_type);\n        else\n            return ctx.builder.CreateZExtOrTrunc(v, target_type);\n    }\n\n    // one or both of from_type and target_type is a VectorType or AggregateType\n    // LLVM doesn't allow us to cast these values directly, so\n    // we need to use this alloca copy trick instead\n    // On ARM and AArch64, the ABI requires casting through memory to different\n    // sizes.\n    Value *from;\n    Value *to;\n    const DataLayout &DL = jl_data_layout;\n    unsigned align = std::max(DL.getPrefTypeAlignment(target_type), DL.getPrefTypeAlignment(from_type));\n    if (DL.getTypeAllocSize(target_type) >= DL.getTypeAllocSize(from_type)) {\n        to = emit_static_alloca(ctx, target_type);\n        cast<AllocaInst>(to)->setAlignment(Align(align));\n        from = emit_bitcast(ctx, to, from_type->getPointerTo());\n    }\n    else {\n        from = emit_static_alloca(ctx, from_type);\n        cast<AllocaInst>(from)->setAlignment(Align(align));\n        to = emit_bitcast(ctx, from, target_type->getPointerTo());\n    }\n    ctx.builder.CreateAlignedStore(v, from, Align(align));\n    return ctx.builder.CreateAlignedLoad(to, Align(align));\n}\n\n// --- argument passing and scratch space utilities ---\n\n// Returns T_prjlvalue\nstatic Value *runtime_apply_type_env(jl_codectx_t &ctx, jl_value_t *ty)\n{\n    // box if concrete type was not statically known\n    Value *args[] = {\n        literal_pointer_val(ctx, ty),\n        literal_pointer_val(ctx, (jl_value_t*)ctx.linfo->def.method->sig),\n        ctx.builder.CreateInBoundsGEP(\n                T_prjlvalue,\n                ctx.spvals_ptr,\n                ConstantInt::get(T_size, sizeof(jl_svec_t) / sizeof(jl_value_t*)))\n    };\n    auto call = ctx.builder.CreateCall(prepare_call(jlapplytype_func), makeArrayRef(args));\n    call->addAttribute(AttributeList::ReturnIndex,\n                       Attribute::getWithAlignment(jl_LLVMContext, Align(16)));\n    return call;\n}\n\nstatic const std::string make_errmsg(const char *fname, int n, const char *err)\n{\n    std::string _msg;\n    raw_string_ostream msg(_msg);\n    msg << fname;\n    if (n > 0)\n        msg << \" argument \" << n;\n    else\n        msg << \" return\";\n    msg << err;\n    return msg.str();\n}\n\nstatic void typeassert_input(jl_codectx_t &ctx, const jl_cgval_t &jvinfo, jl_value_t *jlto, jl_unionall_t *jlto_env, int argn)\n{\n    if (jlto != (jl_value_t*)jl_any_type && !jl_subtype(jvinfo.typ, jlto)) {\n        if (jlto == (jl_value_t*)jl_voidpointer_type) {\n            // allow a bit more flexibility for what can be passed to (void*) due to Ref{T} conversion behavior in input\n            if (!jl_is_cpointer_type(jvinfo.typ)) {\n                // emit a typecheck, if not statically known to be correct\n                emit_cpointercheck(ctx, jvinfo, make_errmsg(\"ccall\", argn + 1, \"\"));\n            }\n        }\n        else {\n            // emit a typecheck, if not statically known to be correct\n            std::string msg = make_errmsg(\"ccall\", argn + 1, \"\");\n            if (!jlto_env || !jl_has_typevar_from_unionall(jlto, jlto_env)) {\n                emit_typecheck(ctx, jvinfo, jlto, msg);\n            }\n            else {\n                jl_cgval_t jlto_runtime = mark_julia_type(ctx, runtime_apply_type_env(ctx, jlto), true, jl_any_type);\n                Value *vx = boxed(ctx, jvinfo);\n                Value *istype = ctx.builder.CreateICmpNE(\n                        ctx.builder.CreateCall(prepare_call(jlisa_func), { vx, boxed(ctx, jlto_runtime) }),\n                        ConstantInt::get(T_int32, 0));\n                BasicBlock *failBB = BasicBlock::Create(jl_LLVMContext, \"fail\", ctx.f);\n                BasicBlock *passBB = BasicBlock::Create(jl_LLVMContext, \"pass\", ctx.f);\n                ctx.builder.CreateCondBr(istype, passBB, failBB);\n\n                ctx.builder.SetInsertPoint(failBB);\n                emit_type_error(ctx, mark_julia_type(ctx, vx, true, jl_any_type), boxed(ctx, jlto_runtime), msg);\n                ctx.builder.CreateUnreachable();\n                ctx.builder.SetInsertPoint(passBB);\n            }\n        }\n    }\n}\n\n// Emit code to convert argument to form expected by C ABI\n// to = desired LLVM type\n// jlto = Julia type of formal argument\n// jvinfo = value of actual argument\nstatic Value *julia_to_native(\n        jl_codectx_t &ctx,\n        Type *to, bool toboxed, jl_value_t *jlto, jl_unionall_t *jlto_env,\n        const jl_cgval_t &jvinfo,\n        bool byRef, int argn)\n{\n    // We're passing Any\n    if (toboxed) {\n        assert(!byRef); // don't expect any ABI to pass pointers by pointer\n        return boxed(ctx, jvinfo);\n    }\n    assert(jl_is_datatype(jlto) && julia_struct_has_layout((jl_datatype_t*)jlto, jlto_env));\n\n    typeassert_input(ctx, jvinfo, jlto, jlto_env, argn);\n    if (!byRef)\n        return emit_unbox(ctx, to, jvinfo, jlto);\n\n    // pass the address of an alloca'd thing, not a box\n    // since those are immutable.\n    Value *slot = emit_static_alloca(ctx, to);\n    if (!jvinfo.ispointer()) {\n        tbaa_decorate(jvinfo.tbaa, ctx.builder.CreateStore(emit_unbox(ctx, to, jvinfo, jlto), slot));\n    }\n    else {\n        emit_memcpy(ctx, slot, jvinfo.tbaa, jvinfo, jl_datatype_size(jlto), julia_alignment(jlto));\n    }\n    return slot;\n}\n\ntypedef struct {\n    Value *jl_ptr;  // if the argument is a run-time computed pointer\n    void (*fptr)(void);     // if the argument is a constant pointer\n    const char *f_name;   // if the symbol name is known\n    const char *f_lib;    // if a library name is specified\n    jl_value_t *lib_expr; // expression to compute library path lazily\n    jl_value_t *gcroot;\n} native_sym_arg_t;\n\n// --- parse :sym or (:sym, :lib) argument into address info ---\nstatic void interpret_symbol_arg(jl_codectx_t &ctx, native_sym_arg_t &out, jl_value_t *arg, const char *fname, bool llvmcall)\n{\n    Value *&jl_ptr = out.jl_ptr;\n    void (*&fptr)(void) = out.fptr;\n    const char *&f_name = out.f_name;\n    const char *&f_lib = out.f_lib;\n\n    jl_value_t *ptr = static_eval(ctx, arg);\n    if (ptr == NULL) {\n        if (jl_is_expr(arg) && ((jl_expr_t*)arg)->head == call_sym && jl_expr_nargs(arg) == 3 &&\n            jl_is_globalref(jl_exprarg(arg,0)) && jl_globalref_mod(jl_exprarg(arg,0)) == jl_core_module &&\n            jl_globalref_name(jl_exprarg(arg,0)) == jl_symbol(\"tuple\")) {\n            // attempt to interpret a non-constant 2-tuple expression as (func_name, lib_name()), where\n            // `lib_name()` will be executed when first used.\n            jl_value_t *name_val = static_eval(ctx, jl_exprarg(arg,1));\n            if (name_val && jl_is_symbol(name_val)) {\n                f_name = jl_symbol_name((jl_sym_t*)name_val);\n                out.lib_expr = jl_exprarg(arg, 2);\n                return;\n            }\n            else if (name_val && jl_is_string(name_val)) {\n                f_name = jl_string_data(name_val);\n                out.gcroot = name_val;\n                out.lib_expr = jl_exprarg(arg, 2);\n                return;\n            }\n        }\n        jl_cgval_t arg1 = emit_expr(ctx, arg);\n        jl_value_t *ptr_ty = arg1.typ;\n        if (!jl_is_cpointer_type(ptr_ty)) {\n            const char *errmsg = !strcmp(fname, \"ccall\") ?\n                \"ccall: first argument not a pointer or valid constant expression\" :\n                \"cglobal: first argument not a pointer or valid constant expression\";\n            emit_cpointercheck(ctx, arg1, errmsg);\n        }\n        arg1 = update_julia_type(ctx, arg1, (jl_value_t*)jl_voidpointer_type);\n        jl_ptr = emit_unbox(ctx, T_size, arg1, (jl_value_t*)jl_voidpointer_type);\n    }\n    else {\n        out.gcroot = ptr;\n        if (jl_is_tuple(ptr) && jl_nfields(ptr) == 1) {\n            ptr = jl_fieldref(ptr, 0);\n        }\n\n        if (jl_is_symbol(ptr))\n            f_name = jl_symbol_name((jl_sym_t*)ptr);\n        else if (jl_is_string(ptr))\n            f_name = jl_string_data(ptr);\n\n        if (f_name != NULL) {\n            // just symbol, default to JuliaDLHandle\n            // will look in process symbol table\n#ifdef _OS_WINDOWS_\n            if (!llvmcall)\n                f_lib = jl_dlfind_win32(f_name);\n#endif\n        }\n        else if (jl_is_cpointer_type(jl_typeof(ptr))) {\n            fptr = *(void(**)(void))jl_data_ptr(ptr);\n        }\n        else if (jl_is_tuple(ptr) && jl_nfields(ptr) > 1) {\n            jl_value_t *t0 = jl_fieldref(ptr, 0);\n            if (jl_is_symbol(t0))\n                f_name = jl_symbol_name((jl_sym_t*)t0);\n            else if (jl_is_string(t0))\n                f_name = jl_string_data(t0);\n            else\n                JL_TYPECHKS(fname, symbol, t0);\n\n            jl_value_t *t1 = jl_fieldref(ptr, 1);\n            if (jl_is_symbol(t1))\n                f_lib = jl_symbol_name((jl_sym_t*)t1);\n            else if (jl_is_string(t1))\n                f_lib = jl_string_data(t1);\n            else\n                JL_TYPECHKS(fname, symbol, t1);\n        }\n        else {\n            JL_TYPECHKS(fname, pointer, ptr);\n        }\n    }\n}\n\n// --- code generator for cglobal ---\n\nstatic jl_cgval_t emit_runtime_call(jl_codectx_t &ctx, JL_I::intrinsic f, const jl_cgval_t *argv, size_t nargs);\n\nstatic jl_cgval_t emit_cglobal(jl_codectx_t &ctx, jl_value_t **args, size_t nargs)\n{\n    JL_NARGS(cglobal, 1, 2);\n    jl_value_t *rt = NULL;\n    Value *res;\n    native_sym_arg_t sym = {};\n    JL_GC_PUSH2(&rt, &sym.gcroot);\n\n    if (nargs == 2) {\n        rt = static_eval(ctx, args[2]);\n        if (rt == NULL) {\n            JL_GC_POP();\n            jl_cgval_t argv[2];\n            argv[0] = emit_expr(ctx, args[1]);\n            argv[1] = emit_expr(ctx, args[2]);\n            return emit_runtime_call(ctx, JL_I::cglobal, argv, nargs);\n        }\n\n        JL_TYPECHK(cglobal, type, rt);\n        rt = (jl_value_t*)jl_apply_type1((jl_value_t*)jl_pointer_type, rt);\n    }\n    else {\n        rt = (jl_value_t*)jl_voidpointer_type;\n    }\n    Type *lrt = T_size;\n    assert(lrt == julia_type_to_llvm(ctx, rt));\n\n    interpret_symbol_arg(ctx, sym, args[1], \"cglobal\", false);\n\n    if (sym.jl_ptr != NULL) {\n        res = ctx.builder.CreateBitCast(sym.jl_ptr, lrt);\n    }\n    else if (sym.fptr != NULL) {\n        res = ConstantInt::get(lrt, (uint64_t)sym.fptr);\n        if (imaging_mode)\n            jl_printf(JL_STDERR,\"WARNING: literal address used in cglobal for %s; code cannot be statically compiled\\n\", sym.f_name);\n    }\n    else {\n        if (sym.lib_expr) {\n            res = runtime_sym_lookup(ctx, cast<PointerType>(T_pint8), NULL, sym.lib_expr, sym.f_name, ctx.f);\n        }\n        else if (imaging_mode) {\n            res = runtime_sym_lookup(ctx, cast<PointerType>(T_pint8), sym.f_lib, NULL, sym.f_name, ctx.f);\n            res = ctx.builder.CreatePtrToInt(res, lrt);\n        }\n        else {\n            void *symaddr;\n\n            void* libsym = jl_get_library_(sym.f_lib, 0);\n            if (!libsym || !jl_dlsym(libsym, sym.f_name, &symaddr, 0)) {\n                // Error mode, either the library or the symbol couldn't be find during compiletime.\n                // Fallback to a runtime symbol lookup.\n                res = runtime_sym_lookup(ctx, cast<PointerType>(T_pint8), sym.f_lib, NULL, sym.f_name, ctx.f);\n                res = ctx.builder.CreatePtrToInt(res, lrt);\n            } else {\n                // since we aren't saving this code, there's no sense in\n                // putting anything complicated here: just JIT the address of the cglobal\n                res = ConstantInt::get(lrt, (uint64_t)symaddr);\n            }\n        }\n    }\n\n    JL_GC_POP();\n    return mark_julia_type(ctx, res, false, rt);\n}\n\n// --- code generator for llvmcall ---\n\nstatic jl_cgval_t emit_llvmcall(jl_codectx_t &ctx, jl_value_t **args, size_t nargs)\n{\n    // parse and validate arguments\n    //\n    // two forms of llvmcall are supported:\n    // - llvmcall(ir, (rettypes...), (argtypes...), args...)\n    //   where `ir` represents IR that should be pasted in a function body\n    // - llvmcall((mod, fn), (rettypes...), (argtypes...), args...)\n    //   where `mod` represents the assembly of an entire LLVM module,\n    //   and `fn` the name of the function to call\n    JL_NARGSV(llvmcall, 3);\n    jl_value_t *rt = NULL, *at = NULL, *ir = NULL, *entry = NULL;\n    jl_value_t *ir_arg = args[1];\n    JL_GC_PUSH4(&ir, &rt, &at, &entry);\n    if (jl_is_ssavalue(ir_arg))\n        ir_arg = jl_arrayref((jl_array_t*)ctx.source->code, ((jl_ssavalue_t*)ir_arg)->id - 1);\n    ir = static_eval(ctx, ir_arg);\n    if (!ir) {\n        emit_error(ctx, \"error statically evaluating llvm IR argument\");\n        return jl_cgval_t();\n    }\n    if (jl_is_ssavalue(args[2]) && !jl_is_long(ctx.source->ssavaluetypes)) {\n        jl_value_t *rtt = jl_arrayref((jl_array_t*)ctx.source->ssavaluetypes, ((jl_ssavalue_t*)args[2])->id - 1);\n        if (jl_is_type_type(rtt))\n            rt = jl_tparam0(rtt);\n    }\n    if (!rt) {\n        rt = static_eval(ctx, args[2]);\n        if (!rt) {\n            emit_error(ctx, \"error statically evaluating llvmcall return type\");\n            return jl_cgval_t();\n        }\n    }\n    if (jl_is_ssavalue(args[3]) && !jl_is_long(ctx.source->ssavaluetypes)) {\n        jl_value_t *att = jl_arrayref((jl_array_t*)ctx.source->ssavaluetypes, ((jl_ssavalue_t*)args[3])->id - 1);\n        if (jl_is_type_type(att))\n            at = jl_tparam0(att);\n    }\n    if (!at) {\n        at = static_eval(ctx, args[3]);\n        if (!at) {\n            emit_error(ctx, \"error statically evaluating llvmcall argument tuple\");\n            return jl_cgval_t();\n        }\n    }\n    if (jl_is_tuple(ir)) {\n        // if the IR is a tuple, we expect (mod, fn)\n        if (jl_nfields(ir) != 2) {\n            emit_error(ctx, \"Tuple as first argument to llvmcall must have exactly two children\");\n            return jl_cgval_t();\n        }\n        entry = jl_fieldref(ir, 1);\n        if (!jl_is_string(entry)) {\n            emit_error(ctx, \"Function name passed to llvmcall must be a string\");\n            return jl_cgval_t();\n        }\n        ir = jl_fieldref(ir, 0);\n\n        if (!jl_is_string(ir) && !jl_typeis(ir, jl_array_uint8_type)) {\n            emit_error(ctx, \"Module IR passed to llvmcall must be a string or an array of bytes\");\n            return jl_cgval_t();\n        }\n    }\n    else {\n        if (!jl_is_string(ir)) {\n            emit_error(ctx, \"Function IR passed to llvmcall must be a string\");\n            return jl_cgval_t();\n        }\n    }\n\n    JL_TYPECHK(llvmcall, type, rt);\n    JL_TYPECHK(llvmcall, type, at);\n\n    // Generate arguments\n    std::string arguments;\n    raw_string_ostream argstream(arguments);\n    jl_svec_t *tt = ((jl_datatype_t*)at)->parameters;\n    jl_value_t *rtt = rt;\n    size_t nargt = jl_svec_len(tt);\n\n    /*\n     * Semantics for arguments are as follows:\n     * If the argument type is immutable (including bitstype), we pass the loaded llvm value\n     * type. Otherwise we pass a pointer to a jl_value_t.\n     */\n    std::vector<llvm::Type*> argtypes;\n    Value **argvals = (Value**)alloca(nargt * sizeof(Value*));\n    for (size_t i = 0; i < nargt; ++i) {\n        jl_value_t *tti = jl_svecref(tt,i);\n        bool toboxed;\n        Type *t = julia_type_to_llvm(ctx, tti, &toboxed);\n        argtypes.push_back(t);\n        if (4 + i > nargs) {\n            emit_error(ctx, \"Missing arguments to llvmcall!\");\n            return jl_cgval_t();\n        }\n        jl_value_t *argi = args[4 + i];\n        jl_cgval_t arg = emit_expr(ctx, argi);\n\n        Value *v = julia_to_native(ctx, t, toboxed, tti, NULL, arg, false, i);\n        bool issigned = jl_signed_type && jl_subtype(tti, (jl_value_t*)jl_signed_type);\n        argvals[i] = llvm_type_rewrite(ctx, v, t, issigned);\n    }\n\n    bool retboxed;\n    Type *rettype = julia_type_to_llvm(ctx, rtt, &retboxed);\n\n    // Make sure to find a unique name\n    std::string ir_name;\n    while (true) {\n        raw_string_ostream(ir_name) << (ctx.f->getName().str()) << \"u\" << globalUnique++;\n        if (jl_Module->getFunction(ir_name) == NULL)\n            break;\n    }\n\n    // generate a temporary module that contains our IR\n    std::unique_ptr<Module> Mod;\n    if (entry == NULL) {\n        // we only have function IR, which we should put in a function\n\n        bool first = true;\n        for (std::vector<Type *>::iterator it = argtypes.begin(); it != argtypes.end(); ++it) {\n            if (!first)\n                argstream << \",\";\n            else\n                first = false;\n            (*it)->print(argstream);\n            argstream << \" \";\n        }\n\n        std::string rstring;\n        raw_string_ostream rtypename(rstring);\n        rettype->print(rtypename);\n        std::map<uint64_t,std::string> localDecls;\n\n        std::string ir_string;\n        raw_string_ostream ir_stream(ir_string);\n        ir_stream << \"; Number of arguments: \" << nargt << \"\\n\"\n        << \"define \"<<rtypename.str()<<\" @\\\"\" << ir_name << \"\\\"(\"<<argstream.str()<<\") {\\n\"\n        << jl_string_data(ir) << \"\\n}\";\n\n        SMDiagnostic Err = SMDiagnostic();\n        Mod = parseAssemblyString(ir_stream.str(), Err, jl_LLVMContext);\n        if (!Mod) {\n            std::string message = \"Failed to parse LLVM assembly: \\n\";\n            raw_string_ostream stream(message);\n            Err.print(\"\", stream, true);\n            emit_error(ctx, stream.str());\n            return jl_cgval_t();\n        }\n\n        Function *f = Mod->getFunction(ir_name);\n        f->addFnAttr(Attribute::AlwaysInline);\n    }\n    else {\n        // we have the IR or bitcode of an entire module, which we can parse directly\n\n        if (jl_is_string(ir)) {\n            SMDiagnostic Err = SMDiagnostic();\n            Mod = parseAssemblyString(jl_string_data(ir), Err, jl_LLVMContext);\n            if (!Mod) {\n                std::string message = \"Failed to parse LLVM assembly: \\n\";\n                raw_string_ostream stream(message);\n                Err.print(\"\", stream, true);\n                emit_error(ctx, stream.str());\n                return jl_cgval_t();\n            }\n        }\n        else {\n            auto Buf = MemoryBuffer::getMemBuffer(\n                StringRef((char *)jl_array_data(ir), jl_array_len(ir)), \"llvmcall\",\n                /*RequiresNullTerminator*/ false);\n            Expected<std::unique_ptr<Module>> ModuleOrErr =\n                parseBitcodeFile(*Buf, jl_LLVMContext);\n            if (Error Err = ModuleOrErr.takeError()) {\n                std::string Message;\n                handleAllErrors(std::move(Err),\n                                [&](ErrorInfoBase &EIB) { Message = EIB.message(); });\n                std::string message = \"Failed to parse LLVM bitcode: \\n\";\n                raw_string_ostream stream(message);\n                stream << Message;\n                emit_error(ctx, stream.str());\n                return jl_cgval_t();\n            }\n            Mod = std::move(ModuleOrErr.get());\n        }\n\n        Function *f = Mod->getFunction(jl_string_data(entry));\n        if (!f) {\n            emit_error(ctx, \"Module IR does not contain specified entry function\");\n            return jl_cgval_t();\n        }\n        f->setName(ir_name);\n\n        // verify the function type\n        assert(!f->isDeclaration());\n        assert(f->getReturnType() == rettype);\n        int i = 0;\n        for (std::vector<Type *>::iterator it = argtypes.begin();\n            it != argtypes.end(); ++it, ++i)\n            assert(*it == f->getFunctionType()->getParamType(i));\n    }\n\n    // copy module properties that should always match\n    Mod->setTargetTriple(jl_Module->getTargetTriple());\n    Mod->setDataLayout(jl_Module->getDataLayout());\n\n    // verify the definition\n    Function *def = Mod->getFunction(ir_name);\n    assert(def);\n    std::string message = \"Malformed LLVM function: \\n\";\n    raw_string_ostream stream(message);\n    if (verifyFunction(*def, &stream)) {\n        emit_error(ctx, stream.str());\n        return jl_cgval_t();\n    }\n    def->setLinkage(GlobalVariable::LinkOnceODRLinkage);\n\n    // generate a call\n    FunctionType *decl_typ = FunctionType::get(rettype, argtypes, def->isVarArg());\n    Function *decl = Function::Create(decl_typ, def->getLinkage(), def->getAddressSpace(),\n                                      def->getName(), jl_Module);\n    decl->setAttributes(def->getAttributes());\n    CallInst *inst = ctx.builder.CreateCall(decl, ArrayRef<Value *>(&argvals[0], nargt));\n\n    // save the module to be linked later.\n    // we cannot do this right now, because linking mutates the destination module,\n    // which might invalidate LLVM values cached in cgval_t's (specifically constant arrays)\n    ctx.llvmcall_modules.push_back(std::move(Mod));\n\n    JL_GC_POP();\n\n    if (inst->getType() != rettype) {\n        std::string message;\n        raw_string_ostream stream(message);\n        stream << \"llvmcall return type \" << *inst->getType()\n               << \" does not match declared return type\" << *rettype;\n        emit_error(ctx, stream.str());\n        return jl_cgval_t();\n    }\n\n    return mark_julia_type(ctx, inst, retboxed, rtt);\n}\n\n// --- code generator for ccall itself ---\n\n// Returns T_prjlvalue\nstatic Value *box_ccall_result(jl_codectx_t &ctx, Value *result, Value *runtime_dt, jl_value_t *rt)\n{\n    // XXX: need to handle parameterized zero-byte types (singleton)\n    const DataLayout &DL = jl_data_layout;\n    unsigned nb = DL.getTypeStoreSize(result->getType());\n    MDNode *tbaa = jl_is_mutable(rt) ? tbaa_mutab : tbaa_immut;\n    Value *strct = emit_allocobj(ctx, nb, runtime_dt);\n    init_bits_value(ctx, strct, result, tbaa);\n    return strct;\n}\n\nstatic jl_cgval_t mark_or_box_ccall_result(jl_codectx_t &ctx, Value *result, bool isboxed, jl_value_t *rt, jl_unionall_t *unionall, bool static_rt)\n{\n    if (!static_rt) {\n        assert(!isboxed && jl_is_datatype(rt) && ctx.spvals_ptr && unionall);\n        Value *runtime_dt = runtime_apply_type_env(ctx, rt);\n        // TODO: skip this check if rt is not a Tuple\n        emit_concretecheck(ctx, runtime_dt, \"ccall: return type must be a concrete DataType\");\n        Value *strct = box_ccall_result(ctx, result, runtime_dt, rt);\n        return mark_julia_type(ctx, strct, true, rt); // TODO: jl_rewrap_unionall(rt, unionall)\n    }\n    return mark_julia_type(ctx, result, isboxed, rt);\n}\n\nclass function_sig_t {\npublic:\n    std::vector<Type*> fargt; // vector of llvm output types (julia_struct_to_llvm) for arguments\n    std::vector<Type*> fargt_sig; // vector of ABI coercion types for call signature\n    std::vector<bool> fargt_isboxed; // vector of whether the llvm output type is a Julia-box for each argument\n    std::vector<bool> byRefList; // vector of \"byref\" parameters\n    AttributeList attributes; // vector of function call site attributes\n    Type *lrt; // input parameter of the llvm return type (from julia_struct_to_llvm)\n    bool retboxed; // input parameter indicating whether lrt is jl_value_t*\n    Type *prt; // out parameter of the llvm return type for the function signature\n    int sret; // out parameter for indicating whether return value has been moved to the first argument position\n    std::string err_msg;\n    CallingConv::ID cc; // calling convention ABI\n    bool llvmcall;\n    jl_svec_t *at; // svec of julia argument types\n    jl_value_t *rt; // julia return type\n    jl_unionall_t *unionall_env; // UnionAll environment for `at` and `rt`\n    size_t nccallargs; // number of actual arguments\n    size_t nreqargs; // number of required arguments in ccall function definition\n    jl_codegen_params_t *ctx;\n\n    function_sig_t(const char *fname, Type *lrt, jl_value_t *rt, bool retboxed, jl_svec_t *at, jl_unionall_t *unionall_env, size_t nreqargs, CallingConv::ID cc, bool llvmcall, jl_codegen_params_t *ctx)\n      : lrt(lrt), retboxed(retboxed),\n        prt(NULL), sret(0), cc(cc), llvmcall(llvmcall),\n        at(at), rt(rt), unionall_env(unionall_env),\n        nccallargs(jl_svec_len(at)), nreqargs(nreqargs),\n        ctx(ctx)\n    {\n        err_msg = generate_func_sig(fname);\n    }\n\n    FunctionType *functype() const {\n        assert(err_msg.empty());\n        if (nreqargs > 0)\n            return FunctionType::get(sret ? T_void : prt, makeArrayRef(fargt_sig).slice(0, nreqargs), true);\n        else\n            return FunctionType::get(sret ? T_void : prt, fargt_sig, false);\n    }\n\n    jl_cgval_t emit_a_ccall(\n            jl_codectx_t &ctx,\n            const native_sym_arg_t &symarg,\n            jl_cgval_t *argv,\n            SmallVector<Value*, 16> &gc_uses,\n            bool static_rt) const;\n\nprivate:\nstd::string generate_func_sig(const char *fname)\n{\n    assert(rt && !jl_is_abstract_ref_type(rt));\n\n    std::vector<AttrBuilder> paramattrs;\n    std::unique_ptr<AbiLayout> abi;\n    if (llvmcall)\n        abi.reset(new ABI_LLVMLayout());\n    else\n        abi.reset(new DefaultAbiState());\n    sret = 0;\n\n    if (type_is_ghost(lrt)) {\n        prt = lrt = T_void;\n        abi->use_sret(jl_nothing_type);\n    }\n    else {\n        if (!jl_is_datatype(rt) || ((jl_datatype_t*)rt)->layout == NULL || jl_is_cpointer_type(rt) || jl_is_array_type(rt) || retboxed) {\n            prt = lrt; // passed as pointer\n            abi->use_sret(jl_voidpointer_type);\n        }\n        else if (abi->use_sret((jl_datatype_t*)rt)) {\n            AttrBuilder retattrs = AttrBuilder();\n#if !defined(_OS_WINDOWS_) // llvm used to use the old mingw ABI, skipping this marking works around that difference\n#if JL_LLVM_VERSION < 120000\n            retattrs.addAttribute(Attribute::StructRet);\n#else\n            retattrs.addStructRetAttr(lrt);\n#endif\n#endif\n            retattrs.addAttribute(Attribute::NoAlias);\n            paramattrs.push_back(std::move(retattrs));\n            fargt_sig.push_back(PointerType::get(lrt, 0));\n            sret = 1;\n            prt = lrt;\n        }\n        else {\n            prt = abi->preferred_llvm_type((jl_datatype_t*)rt, true);\n            if (prt == NULL)\n                prt = lrt;\n        }\n    }\n\n    for (size_t i = 0; i < nccallargs; ++i) {\n        AttrBuilder ab;\n        jl_value_t *tti = jl_svecref(at, i);\n        Type *t = NULL;\n        bool isboxed;\n        if (jl_is_abstract_ref_type(tti)) {\n            tti = (jl_value_t*)jl_voidpointer_type;\n            t = T_pint8;\n            isboxed = false;\n        }\n        else if (llvmcall && jl_is_llvmpointer_type(tti)) {\n            t = bitstype_to_llvm(tti, true);\n            tti = (jl_value_t*)jl_voidpointer_type;\n            isboxed = false;\n        }\n        else {\n            if (jl_is_primitivetype(tti)) {\n                // see pull req #978. need to annotate signext/zeroext for\n                // small integer arguments.\n                jl_datatype_t *bt = (jl_datatype_t*)tti;\n                if (jl_datatype_size(bt) < 4 && bt != jl_float16_type) {\n                    if (jl_signed_type && jl_subtype(tti, (jl_value_t*)jl_signed_type))\n                        ab.addAttribute(Attribute::SExt);\n                    else\n                        ab.addAttribute(Attribute::ZExt);\n                }\n            }\n\n            t = _julia_struct_to_llvm(ctx, tti, unionall_env, &isboxed, llvmcall);\n            if (t == NULL || t == T_void) {\n                return make_errmsg(fname, i + 1, \" doesn't correspond to a C type\");\n            }\n        }\n\n        Type *pat;\n        if (!jl_is_datatype(tti) || ((jl_datatype_t*)tti)->layout == NULL || jl_is_array_type(tti)) {\n            tti = (jl_value_t*)jl_voidpointer_type; // passed as pointer\n        }\n\n        // Whether or not LLVM wants us to emit a pointer to the data\n        bool byRef = abi->needPassByRef((jl_datatype_t*)tti, ab);\n\n        if (jl_is_cpointer_type(tti)) {\n            pat = t;\n        }\n        else if (byRef) {\n            pat = PointerType::get(t, AddressSpace::Derived);\n        }\n        else {\n            pat = abi->preferred_llvm_type((jl_datatype_t*)tti, false);\n            if (pat == NULL)\n                pat = t;\n        }\n\n        if (!byRef && nreqargs > 0 && i >= nreqargs) { // TODO: handle byRef case too?\n            // The C vararg ABI says that small types must get widened,\n            // but we don't really want to expect the user to know that,\n            // so attempt to do that coercion here\n            if (!llvmcall && cc == CallingConv::C) {\n                if (pat->isIntegerTy() && pat->getPrimitiveSizeInBits() < sizeof(int) * 8)\n                    pat = T_int32;\n                if (pat->isFloatingPointTy() && pat->getPrimitiveSizeInBits() < sizeof(double) * 8)\n                    pat = T_float64;\n                ab.removeAttribute(Attribute::SExt);\n                ab.removeAttribute(Attribute::ZExt);\n            }\n        }\n\n        byRefList.push_back(byRef);\n        fargt.push_back(t);\n        fargt_isboxed.push_back(isboxed);\n        fargt_sig.push_back(pat);\n        paramattrs.push_back(AttributeSet::get(jl_LLVMContext, ab));\n    }\n\n    for (size_t i = 0; i < nccallargs + sret; ++i) {\n        const auto &as = paramattrs.at(i);\n        if (!as.hasAttributes())\n            continue;\n        attributes = attributes.addAttributes(jl_LLVMContext, i + 1, as);\n    }\n    // If return value is boxed it must be non-null.\n    if (retboxed)\n        attributes = attributes.addAttribute(jl_LLVMContext, AttributeList::ReturnIndex,\n                                             Attribute::NonNull);\n    if (rt == jl_bottom_type) {\n        attributes = attributes.addAttribute(jl_LLVMContext,\n                                             AttributeList::FunctionIndex,\n                                             Attribute::NoReturn);\n    }\n    return \"\";\n}\n};\n\nstatic std::pair<CallingConv::ID, bool> convert_cconv(jl_sym_t *lhd)\n{\n    // check for calling convention specifier\n    if (lhd == jl_symbol(\"stdcall\")) {\n        return std::make_pair(CallingConv::X86_StdCall, false);\n    }\n    else if (lhd == jl_symbol(\"cdecl\") || lhd == jl_symbol(\"ccall\")) {\n        // `ccall` calling convention is a placeholder for when there isn't one provided\n        // it is not by itself a valid calling convention name to be specified in the surface\n        // syntax.\n        return std::make_pair(CallingConv::C, false);\n    }\n    else if (lhd == jl_symbol(\"fastcall\")) {\n        return std::make_pair(CallingConv::X86_FastCall, false);\n    }\n    else if (lhd == jl_symbol(\"thiscall\")) {\n        return std::make_pair(CallingConv::X86_ThisCall, false);\n    }\n    else if (lhd == jl_symbol(\"llvmcall\")) {\n        return std::make_pair(CallingConv::C, true);\n    }\n    jl_errorf(\"ccall: invalid calling convention %s\", jl_symbol_name(lhd));\n}\n\nstatic bool verify_ref_type(jl_codectx_t &ctx, jl_value_t* ref, jl_unionall_t *unionall_env, int n, const char *fname)\n{\n    // emit verification that the tparam for Ref isn't Any or a TypeVar\n    const char rt_err_msg_notany[] = \" type Ref{Any} is invalid. Use Any or Ptr{Any} instead.\";\n    if (ref == (jl_value_t*)jl_any_type && n == 0) {\n        emit_error(ctx, make_errmsg(fname, n, rt_err_msg_notany));\n        return false;\n    }\n    else if (jl_is_typevar(ref)) {\n        bool always_error = true;\n        if (unionall_env) {\n            int i;\n            jl_unionall_t *ua = unionall_env;\n            for (i = 0; jl_is_unionall(ua); i++) {\n                if (ua->var == (jl_tvar_t*)ref) {\n                    jl_cgval_t runtime_sp = emit_sparam(ctx, i);\n                    if (n > 0) {\n                        always_error = false;\n                    }\n                    else if (runtime_sp.constant) {\n                        if (runtime_sp.constant != (jl_value_t*)jl_any_type)\n                            always_error = false;\n                    }\n                    else {\n                        Value *notany = ctx.builder.CreateICmpNE(\n                                boxed(ctx, runtime_sp),\n                                track_pjlvalue(ctx, literal_pointer_val(ctx, (jl_value_t*)jl_any_type)));\n                        error_unless(ctx, notany, make_errmsg(fname, n, rt_err_msg_notany));\n                        always_error = false;\n                    }\n                    break;\n                }\n                ua = (jl_unionall_t*)ua->body;\n            }\n        }\n        if (always_error) {\n            emit_error(ctx, make_errmsg(fname, n, \" type Ref should have an element type, not Ref{<:T}.\"));\n            return false;\n        }\n    }\n    return true;\n}\n\nstatic const std::string verify_ccall_sig(jl_value_t *&rt, jl_value_t *at,\n                                          jl_unionall_t *unionall_env, jl_svec_t *sparam_vals,\n                                          jl_codegen_params_t *ctx,\n                                          Type *&lrt, bool &retboxed, bool &static_rt, bool llvmcall=false)\n{\n    JL_TYPECHK(ccall, type, rt);\n    JL_TYPECHK(ccall, simplevector, at);\n\n    if (jl_is_array_type(rt)) {\n        // `Array` used as return type just returns a julia object reference\n        rt = (jl_value_t*)jl_any_type;\n    }\n\n    lrt = _julia_struct_to_llvm(ctx, rt, unionall_env, &retboxed, llvmcall);\n    if (lrt == NULL)\n        return \"return type doesn't correspond to a C type\";\n\n    // is return type fully statically known?\n    if (unionall_env == NULL) {\n        static_rt = true;\n    }\n    else {\n        static_rt = retboxed || !jl_has_typevar_from_unionall(rt, unionall_env);\n        if (!static_rt && sparam_vals != NULL && jl_svec_len(sparam_vals) > 0) {\n            rt = jl_instantiate_type_in_env(rt, unionall_env, jl_svec_data(sparam_vals));\n            // `rt` is gc-rooted by the caller\n            static_rt = true;\n        }\n    }\n\n    return \"\";\n}\n\n// Expr(:foreigncall, pointer, rettype, (argtypes...), nreq, cconv, args..., roots...)\nstatic jl_cgval_t emit_ccall(jl_codectx_t &ctx, jl_value_t **args, size_t nargs)\n{\n    JL_NARGSV(ccall, 5);\n    args -= 1;\n    jl_value_t *rt = args[2];\n    jl_value_t *at = args[3];\n    size_t nccallargs = jl_svec_len(at);\n    size_t nreqargs = jl_unbox_long(args[4]); // if vararg\n    assert(jl_is_quotenode(args[5]));\n    jl_sym_t *cc_sym = *(jl_sym_t**)args[5];\n    assert(jl_is_symbol(cc_sym));\n    native_sym_arg_t symarg = {};\n    JL_GC_PUSH3(&rt, &at, &symarg.gcroot);\n\n    CallingConv::ID cc = CallingConv::C;\n    bool llvmcall = false;\n    std::tie(cc, llvmcall) = convert_cconv(cc_sym);\n\n    interpret_symbol_arg(ctx, symarg, args[1], \"ccall\", llvmcall);\n    Value *&jl_ptr = symarg.jl_ptr;\n    void (*&fptr)(void) = symarg.fptr;\n    const char *&f_name = symarg.f_name;\n    const char *&f_lib = symarg.f_lib;\n\n    if (f_name == NULL && fptr == NULL && jl_ptr == NULL) {\n        emit_error(ctx, \"ccall: null function pointer\");\n        JL_GC_POP();\n        return jl_cgval_t();\n    }\n\n    auto ccallarg = [=] (size_t i) {\n        assert(i < nccallargs && i + 6 <= nargs);\n        return args[6 + i];\n    };\n\n    auto _is_libjulia_func = [&] (uintptr_t ptr, const char *name) {\n        if ((uintptr_t)fptr == ptr)\n            return true;\n        if (f_lib) {\n#ifdef _OS_WINDOWS_\n            if ((f_lib == JL_EXE_LIBNAME) || // preventing invalid pointer access\n                (f_lib == JL_LIBJULIA_INTERNAL_DL_LIBNAME) ||\n                (!strcmp(f_lib, jl_crtdll_basename))) {\n                // libjulia-like\n            }\n            else\n                return false;\n#else\n            return false;\n#endif\n        }\n        return f_name && !strcmp(f_name, name);\n    };\n#define is_libjulia_func(name) _is_libjulia_func((uintptr_t)&(name), #name)\n\n    static jl_ptls_t (*ptls_getter)(void) = [] {\n    // directly accessing the address of an ifunc can cause compile-time linker issues\n    // on some configurations (e.g. AArch64 + -Bsymbolic-functions), so we guard the\n    // `&jl_get_ptls_states` within this `#ifdef` guard, and use a more roundabout\n    // method involving `jl_dlsym()` on Linux platforms instead.\n#ifdef _OS_LINUX_\n        jl_ptls_t (*p)(void);\n        void *handle = jl_dlopen(nullptr, 0);\n        jl_dlsym(handle, \"jl_get_ptls_states\", (void **)&p, 0);\n        jl_dlclose(handle);\n        return p;\n#else\n        return &jl_get_ptls_states;\n#endif\n    }();\n\n    // emit arguments\n    jl_cgval_t *argv = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * nccallargs);\n    for (size_t i = 0; i < nccallargs; i++) {\n        // Julia (expression) value of current parameter\n        jl_value_t *argi = ccallarg(i);\n        argv[i] = emit_expr(ctx, argi);\n    }\n\n    // emit roots\n    SmallVector<Value*, 16> gc_uses;\n    for (size_t i = nccallargs + 6; i <= nargs; i++) {\n        // Julia (expression) value of current parameter gcroot\n        jl_value_t *argi_root = args[i];\n        if (jl_is_long(argi_root))\n            continue;\n        jl_cgval_t arg_root = emit_expr(ctx, argi_root);\n        Value *gc_root = get_gc_root_for(arg_root);\n        if (gc_root)\n            gc_uses.push_back(gc_root);\n    }\n\n    jl_unionall_t *unionall = (jl_is_method(ctx.linfo->def.method) && jl_is_unionall(ctx.linfo->def.method->sig))\n        ? (jl_unionall_t*)ctx.linfo->def.method->sig\n        : NULL;\n\n    if (jl_is_abstract_ref_type(rt)) {\n        if (!verify_ref_type(ctx, jl_tparam0(rt), unionall, 0, \"ccall\")) {\n            JL_GC_POP();\n            return jl_cgval_t();\n        }\n        rt = (jl_value_t*)jl_any_type; // convert return type to jl_value_t*\n    }\n\n    // some sanity checking and check whether there's a vararg\n    Type *lrt;\n    bool retboxed;\n    bool static_rt;\n    std::string err = verify_ccall_sig(\n      /* inputs:  */\n      rt, at, unionall,\n      ctx.spvals_ptr == NULL ? ctx.linfo->sparam_vals : NULL,\n      &ctx.emission_context,\n      /* outputs: */\n      lrt, retboxed, static_rt,\n      /* optional arguments */\n      llvmcall);\n    if (err.empty()) {\n        // some extra checks for ccall\n        if (!retboxed && static_rt) {\n            if (!jl_is_concrete_type(rt)) {\n                if (jl_is_cpointer_type(rt))\n                    err = \"return type Ptr should have an element type (not Ptr{<:T})\";\n                else if (rt != jl_bottom_type)\n                    err = \"return type must be a concrete DataType\";\n            }\n        }\n        assert(jl_svec_len(at) >= nreqargs);\n    }\n    if (!err.empty()) {\n        emit_error(ctx, \"ccall \" + err);\n        JL_GC_POP();\n        return jl_cgval_t();\n    }\n    if (rt != args[2] && rt != (jl_value_t*)jl_any_type)\n        jl_add_method_root(ctx, rt);\n    function_sig_t sig(\"ccall\", lrt, rt, retboxed,\n                       (jl_svec_t*)at, unionall, nreqargs,\n                       cc, llvmcall, &ctx.emission_context);\n    for (size_t i = 0; i < nccallargs; i++) {\n        jl_value_t *tti = jl_svecref(at, i);\n        if (jl_is_abstract_ref_type(tti)) {\n            if (!verify_ref_type(ctx, jl_tparam0(tti), unionall, i + 1, \"ccall\")) {\n                JL_GC_POP();\n                return jl_cgval_t();\n            }\n        }\n    }\n\n    // some special functions\n    bool isVa = nreqargs > 0;\n    (void)isVa; // prevent compiler warning\n    if (is_libjulia_func(jl_array_ptr)) {\n        assert(lrt == T_size);\n        assert(!isVa && !llvmcall && nccallargs == 1);\n        const jl_cgval_t &ary = argv[0];\n        JL_GC_POP();\n        return mark_or_box_ccall_result(ctx, ctx.builder.CreatePtrToInt(emit_unsafe_arrayptr(ctx, ary), lrt),\n                                        retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_value_ptr)) {\n        assert(retboxed ? lrt == T_prjlvalue : lrt == T_size);\n        assert(!isVa && !llvmcall && nccallargs == 1);\n        jl_value_t *tti = jl_svecref(at, 0);\n        Value *ary;\n        Type *largty;\n        bool isboxed;\n        if (jl_is_abstract_ref_type(tti)) {\n            tti = (jl_value_t*)jl_voidpointer_type;\n            largty = T_size;\n            isboxed = false;\n        }\n        else {\n            largty = _julia_struct_to_llvm(&ctx.emission_context, tti, unionall, &isboxed, llvmcall);\n        }\n        if (isboxed) {\n            ary = boxed(ctx, argv[0]);\n        }\n        else {\n            ary = emit_unbox(ctx, largty, argv[0], tti);\n        }\n        JL_GC_POP();\n        if (!retboxed) {\n            return mark_or_box_ccall_result(\n                    ctx,\n                    ctx.builder.CreatePtrToInt(\n                        emit_pointer_from_objref(ctx, emit_bitcast(ctx, ary, T_prjlvalue)),\n                        T_size),\n                    retboxed, rt, unionall, static_rt);\n        }\n        else {\n            return mark_or_box_ccall_result(\n                    ctx,\n                    ctx.builder.CreateAddrSpaceCast(\n                        emit_inttoptr(ctx, ary, T_pjlvalue),\n                        T_prjlvalue), // WARNING: this addrspace cast necessarily implies that the value is rooted elsewhere!\n                    retboxed, rt, unionall, static_rt);\n        }\n    }\n    else if (is_libjulia_func(jl_cpu_pause)) {\n        // Keep in sync with the julia_threads.h version\n        assert(lrt == T_void);\n        assert(!isVa && !llvmcall && nccallargs == 0);\n#ifdef __MIC__\n        // TODO\n#elif defined(_CPU_X86_64_) || defined(_CPU_X86_)  /* !__MIC__ */\n        static auto pauseinst = InlineAsm::get(FunctionType::get(T_void, false), \"pause\",\n                                               \"~{memory}\", true);\n        ctx.builder.CreateCall(pauseinst);\n        JL_GC_POP();\n        return ghostValue(jl_nothing_type);\n#elif defined(_CPU_AARCH64_) || (defined(_CPU_ARM_) && __ARM_ARCH >= 7)\n        static auto wfeinst = InlineAsm::get(FunctionType::get(T_void, false), \"wfe\",\n                                             \"~{memory}\", true);\n        ctx.builder.CreateCall(wfeinst);\n        JL_GC_POP();\n        return ghostValue(jl_nothing_type);\n#else\n        JL_GC_POP();\n        return ghostValue(jl_nothing_type);\n#endif\n    }\n    else if (is_libjulia_func(jl_cpu_wake)) {\n        // Keep in sync with the julia_threads.h version\n        assert(lrt == T_void);\n        assert(!isVa && !llvmcall && nccallargs == 0);\n#if JL_CPU_WAKE_NOOP == 1\n        JL_GC_POP();\n        return ghostValue(jl_nothing_type);\n#elif defined(_CPU_AARCH64_) || (defined(_CPU_ARM_) && __ARM_ARCH >= 7)\n        static auto sevinst = InlineAsm::get(FunctionType::get(T_void, false), \"sev\",\n                                             \"~{memory}\", true);\n        ctx.builder.CreateCall(sevinst);\n        JL_GC_POP();\n        return ghostValue(jl_nothing_type);\n#endif\n    }\n    else if (is_libjulia_func(jl_gc_safepoint)) {\n        assert(lrt == T_void);\n        assert(!isVa && !llvmcall && nccallargs == 0);\n        JL_GC_POP();\n        ctx.builder.CreateCall(prepare_call(gcroot_flush_func));\n        emit_signal_fence(ctx);\n        ctx.builder.CreateLoad(T_size, ctx.signalPage, true);\n        emit_signal_fence(ctx);\n        return ghostValue(jl_nothing_type);\n    }\n    else if (_is_libjulia_func((uintptr_t)ptls_getter, \"jl_get_ptls_states\")) {\n        assert(lrt == T_size);\n        assert(!isVa && !llvmcall && nccallargs == 0);\n        JL_GC_POP();\n        return mark_or_box_ccall_result(ctx,\n            ctx.builder.CreatePtrToInt(ctx.ptlsStates, lrt),\n            retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_threadid)) {\n        assert(lrt == T_int16);\n        assert(!isVa && !llvmcall && nccallargs == 0);\n        JL_GC_POP();\n        Value *ptls_i16 = emit_bitcast(ctx, ctx.ptlsStates, T_pint16);\n        const int tid_offset = offsetof(jl_tls_states_t, tid);\n        Value *ptid = ctx.builder.CreateInBoundsGEP(ptls_i16, ConstantInt::get(T_size, tid_offset / 2));\n        LoadInst *tid = ctx.builder.CreateAlignedLoad(ptid, Align(sizeof(int16_t)));\n        tbaa_decorate(tbaa_const, tid);\n        return mark_or_box_ccall_result(ctx, tid, retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_gc_disable_finalizers_internal)\n#ifdef NDEBUG\n             || is_libjulia_func(jl_gc_enable_finalizers_internal)\n#endif\n             ) {\n        JL_GC_POP();\n        Value *ptls_i32 = emit_bitcast(ctx, ctx.ptlsStates, T_pint32);\n        const int finh_offset = offsetof(jl_tls_states_t, finalizers_inhibited);\n        Value *pfinh = ctx.builder.CreateInBoundsGEP(ptls_i32, ConstantInt::get(T_size, finh_offset / 4));\n        LoadInst *finh = ctx.builder.CreateAlignedLoad(pfinh, Align(sizeof(int32_t)));\n        Value *newval;\n        if (is_libjulia_func(jl_gc_disable_finalizers_internal)) {\n            newval = ctx.builder.CreateAdd(finh, ConstantInt::get(T_int32, 1));\n        }\n        else {\n            newval = ctx.builder.CreateSelect(ctx.builder.CreateICmpEQ(finh, ConstantInt::get(T_int32, 0)),\n                                              ConstantInt::get(T_int32, 0),\n                                              ctx.builder.CreateSub(finh, ConstantInt::get(T_int32, 1)));\n        }\n        ctx.builder.CreateStore(newval, pfinh);\n        return ghostValue(jl_nothing_type);\n    }\n    else if (is_libjulia_func(jl_get_current_task)) {\n        assert(lrt == T_prjlvalue);\n        assert(!isVa && !llvmcall && nccallargs == 0);\n        JL_GC_POP();\n        Value *ptls_pv = emit_bitcast(ctx, ctx.ptlsStates, T_pprjlvalue);\n        const int ct_offset = offsetof(jl_tls_states_t, current_task);\n        Value *pct = ctx.builder.CreateInBoundsGEP(ptls_pv, ConstantInt::get(T_size, ct_offset / sizeof(void*)));\n        LoadInst *ct = ctx.builder.CreateAlignedLoad(pct, Align(sizeof(void*)));\n        tbaa_decorate(tbaa_const, ct);\n        return mark_or_box_ccall_result(ctx, ct, retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_set_next_task)) {\n        assert(lrt == T_void);\n        assert(!isVa && !llvmcall && nccallargs == 1);\n        JL_GC_POP();\n        Value *ptls_pv = emit_bitcast(ctx, ctx.ptlsStates, T_ppjlvalue);\n        const int nt_offset = offsetof(jl_tls_states_t, next_task);\n        Value *pnt = ctx.builder.CreateInBoundsGEP(ptls_pv, ConstantInt::get(T_size, nt_offset / sizeof(void*)));\n        ctx.builder.CreateStore(emit_pointer_from_objref(ctx, boxed(ctx, argv[0])), pnt);\n        return ghostValue(jl_nothing_type);\n    }\n    else if (is_libjulia_func(jl_sigatomic_begin)) {\n        assert(lrt == T_void);\n        assert(!isVa && !llvmcall && nccallargs == 0);\n        JL_GC_POP();\n        ctx.builder.CreateCall(prepare_call(gcroot_flush_func));\n        Value *pdefer_sig = emit_defer_signal(ctx);\n        Value *defer_sig = ctx.builder.CreateLoad(pdefer_sig);\n        defer_sig = ctx.builder.CreateAdd(defer_sig, ConstantInt::get(T_sigatomic, 1));\n        ctx.builder.CreateStore(defer_sig, pdefer_sig);\n        emit_signal_fence(ctx);\n        return ghostValue(jl_nothing_type);\n    }\n    else if (is_libjulia_func(jl_sigatomic_end)) {\n        assert(lrt == T_void);\n        assert(!isVa && !llvmcall && nccallargs == 0);\n        JL_GC_POP();\n        ctx.builder.CreateCall(prepare_call(gcroot_flush_func));\n        Value *pdefer_sig = emit_defer_signal(ctx);\n        Value *defer_sig = ctx.builder.CreateLoad(pdefer_sig);\n        emit_signal_fence(ctx);\n        error_unless(ctx,\n                ctx.builder.CreateICmpNE(defer_sig, ConstantInt::get(T_sigatomic, 0)),\n                \"sigatomic_end called in non-sigatomic region\");\n        defer_sig = ctx.builder.CreateSub(\n                defer_sig,\n                ConstantInt::get(T_sigatomic, 1));\n        ctx.builder.CreateStore(defer_sig, pdefer_sig);\n        BasicBlock *checkBB = BasicBlock::Create(jl_LLVMContext, \"check\",\n                                                 ctx.f);\n        BasicBlock *contBB = BasicBlock::Create(jl_LLVMContext, \"cont\");\n        ctx.builder.CreateCondBr(\n                ctx.builder.CreateICmpEQ(defer_sig, ConstantInt::get(T_sigatomic, 0)),\n                checkBB, contBB);\n        ctx.builder.SetInsertPoint(checkBB);\n        ctx.builder.CreateLoad(\n                ctx.builder.CreateConstInBoundsGEP1_32(T_size, ctx.signalPage, -1),\n                true);\n        ctx.builder.CreateBr(contBB);\n        ctx.f->getBasicBlockList().push_back(contBB);\n        ctx.builder.SetInsertPoint(contBB);\n        return ghostValue(jl_nothing_type);\n    }\n    else if (is_libjulia_func(jl_svec_len)) {\n        assert(!isVa && !llvmcall && nccallargs == 1);\n        const jl_cgval_t &svecv = argv[0];\n        Value *len;\n        if (svecv.constant && svecv.typ == (jl_value_t*)jl_simplevector_type) {\n            // Check the type as well before we call\n            len = ConstantInt::get(T_size, jl_svec_len(svecv.constant));\n        }\n        else {\n            auto ptr = emit_bitcast(ctx, boxed(ctx, svecv), T_psize);\n            len = ctx.builder.CreateAlignedLoad(T_size, ptr, Align(sizeof(size_t)));\n            // Only mark with TBAA if we are sure about the type.\n            // This could otherwise be in a dead branch\n            if (svecv.typ == (jl_value_t*)jl_simplevector_type)\n                tbaa_decorate(tbaa_const, cast<Instruction>(len));\n            MDBuilder MDB(jl_LLVMContext);\n            auto rng = MDB.createRange(\n                V_size0, ConstantInt::get(T_size, INTPTR_MAX / sizeof(void*) - 1));\n            cast<LoadInst>(len)->setMetadata(LLVMContext::MD_range, rng);\n        }\n        JL_GC_POP();\n        return mark_or_box_ccall_result(ctx, len, retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_svec_isassigned) &&\n             argv[1].typ == (jl_value_t*)jl_long_type) {\n        assert(!isVa && !llvmcall && nccallargs == 2);\n        const jl_cgval_t &svecv = argv[0];\n        const jl_cgval_t &idxv = argv[1];\n        Value *idx = emit_unbox(ctx, T_size, idxv, (jl_value_t*)jl_long_type);\n        idx = ctx.builder.CreateAdd(idx, ConstantInt::get(T_size, 1));\n        auto ptr = emit_bitcast(ctx, boxed(ctx, svecv), T_pprjlvalue);\n        Value *slot_addr = ctx.builder.CreateInBoundsGEP(T_prjlvalue,\n                                                         decay_derived(ctx, ptr), idx);\n        LoadInst *load = ctx.builder.CreateAlignedLoad(T_prjlvalue, slot_addr,\n                                                       Align(sizeof(void*)));\n        load->setAtomic(AtomicOrdering::Unordered);\n        // Only mark with TBAA if we are sure about the type.\n        // This could otherwise be in a dead branch\n        if (svecv.typ == (jl_value_t*)jl_simplevector_type)\n            tbaa_decorate(tbaa_const, load);\n        Value *res = ctx.builder.CreateZExt(ctx.builder.CreateICmpNE(load, V_rnull), T_int8);\n        JL_GC_POP();\n        return mark_or_box_ccall_result(ctx, res, retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_svec_ref) && argv[1].typ == (jl_value_t*)jl_long_type) {\n        assert(lrt == T_prjlvalue);\n        assert(!isVa && !llvmcall && nccallargs == 2);\n        const jl_cgval_t &svecv = argv[0];\n        const jl_cgval_t &idxv = argv[1];\n        Value *idx = emit_unbox(ctx, T_size, idxv, (jl_value_t*)jl_long_type);\n        idx = ctx.builder.CreateAdd(idx, ConstantInt::get(T_size, 1));\n        auto ptr = emit_bitcast(ctx, boxed(ctx, svecv), T_pprjlvalue);\n        Value *slot_addr = ctx.builder.CreateInBoundsGEP(T_prjlvalue,\n                                                         decay_derived(ctx, ptr), idx);\n        LoadInst *load = ctx.builder.CreateAlignedLoad(T_prjlvalue, slot_addr,\n                                                       Align(sizeof(void*)));\n        load->setAtomic(AtomicOrdering::Unordered);\n        // Only mark with TBAA if we are sure about the type.\n        // This could otherwise be in a dead branch\n        if (svecv.typ == (jl_value_t*)jl_simplevector_type)\n            tbaa_decorate(tbaa_const, load);\n        null_pointer_check(ctx, load);\n        JL_GC_POP();\n        return mark_or_box_ccall_result(ctx, load, retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_array_isassigned) &&\n             argv[1].typ == (jl_value_t*)jl_ulong_type) {\n        assert(!isVa && !llvmcall && nccallargs == 2);\n        jl_value_t *aryex = ccallarg(0);\n        const jl_cgval_t &aryv = argv[0];\n        const jl_cgval_t &idxv = argv[1];\n        jl_datatype_t *arydt = (jl_datatype_t*)jl_unwrap_unionall(aryv.typ);\n        if (jl_is_array_type(arydt)) {\n            jl_value_t *ety = jl_tparam0(arydt);\n            bool ptrarray = !jl_stored_inline(ety);\n            if (!ptrarray && !jl_type_hasptr(ety)) {\n                JL_GC_POP();\n                return mark_or_box_ccall_result(ctx, ConstantInt::get(T_int32, 1),\n                                                false, rt, unionall, static_rt);\n            }\n            else if (!jl_has_free_typevars(ety)) {\n                Value *idx = emit_unbox(ctx, T_size, idxv, (jl_value_t*)jl_ulong_type);\n                Value *arrayptr = emit_bitcast(ctx, emit_arrayptr(ctx, aryv, aryex), T_pprjlvalue);\n                if (!ptrarray) {\n                    size_t elsz = jl_datatype_size(ety);\n                    unsigned align = jl_datatype_align(ety);\n                    size_t stride = LLT_ALIGN(elsz, align) / sizeof(jl_value_t*);\n                    if (stride != 1)\n                        idx = ctx.builder.CreateMul(idx, ConstantInt::get(T_size, stride));\n                    idx = ctx.builder.CreateAdd(idx, ConstantInt::get(T_size, ((jl_datatype_t*)ety)->layout->first_ptr));\n                }\n                Value *slot_addr = ctx.builder.CreateInBoundsGEP(T_prjlvalue, arrayptr, idx);\n                LoadInst *load = ctx.builder.CreateAlignedLoad(T_prjlvalue, slot_addr, Align(sizeof(void*)));\n                load->setAtomic(AtomicOrdering::Unordered);\n                tbaa_decorate(tbaa_ptrarraybuf, load);\n                Value *res = ctx.builder.CreateZExt(ctx.builder.CreateICmpNE(load, V_rnull), T_int32);\n                JL_GC_POP();\n                return mark_or_box_ccall_result(ctx, res, retboxed, rt, unionall, static_rt);\n            }\n        }\n    }\n    else if (is_libjulia_func(jl_string_ptr)) {\n        assert(lrt == T_size);\n        assert(!isVa && !llvmcall && nccallargs == 1);\n        auto obj = emit_bitcast(ctx, emit_pointer_from_objref(ctx, boxed(ctx, argv[0])),\n                                T_pprjlvalue);\n        // The inbounds gep makes it more clear to LLVM that the resulting value is not\n        // a null pointer.\n        auto strp = ctx.builder.CreateConstInBoundsGEP1_32(T_prjlvalue, obj, 1);\n        strp = ctx.builder.CreatePtrToInt(strp, T_size);\n        JL_GC_POP();\n        return mark_or_box_ccall_result(ctx, strp, retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_symbol_name)) {\n        assert(lrt == T_size);\n        assert(!isVa && !llvmcall && nccallargs == 1);\n        auto obj = emit_bitcast(ctx, emit_pointer_from_objref(ctx, boxed(ctx, argv[0])),\n                                T_pprjlvalue);\n        // The inbounds gep makes it more clear to LLVM that the resulting value is not\n        // a null pointer.\n        auto strp = ctx.builder.CreateConstInBoundsGEP1_32(\n            T_prjlvalue, obj, (sizeof(jl_sym_t) + sizeof(void*) - 1) / sizeof(void*));\n        strp = ctx.builder.CreatePtrToInt(strp, T_size);\n        JL_GC_POP();\n        return mark_or_box_ccall_result(ctx, strp, retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(memcpy) && (rt == (jl_value_t*)jl_nothing_type || jl_is_cpointer_type(rt))) {\n        const jl_cgval_t &dst = argv[0];\n        const jl_cgval_t &src = argv[1];\n        const jl_cgval_t &n = argv[2];\n        Value *destp = emit_unbox(ctx, T_size, dst, (jl_value_t*)jl_voidpointer_type);\n\n        ctx.builder.CreateMemCpy(\n                emit_inttoptr(ctx, destp, T_pint8),\n#if JL_LLVM_VERSION >= 100000\n                MaybeAlign(1),\n#else\n                1,\n#endif\n                emit_inttoptr(ctx,\n                    emit_unbox(ctx, T_size, src, (jl_value_t*)jl_voidpointer_type),\n                    T_pint8),\n#if JL_LLVM_VERSION >= 100000\n                MaybeAlign(0),\n#else\n                0,\n#endif\n                emit_unbox(ctx, T_size, n, (jl_value_t*)jl_ulong_type),\n                false);\n        JL_GC_POP();\n        return rt == (jl_value_t*)jl_nothing_type ? ghostValue(jl_nothing_type) :\n            mark_or_box_ccall_result(ctx, destp, retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_object_id) && nccallargs == 1 &&\n            rt == (jl_value_t*)jl_ulong_type) {\n        jl_cgval_t val = argv[0];\n        if (!val.isboxed) {\n            // If the value is not boxed, try to compute the object id without\n            // reboxing it.\n            auto T_pint8_derived = PointerType::get(T_int8, AddressSpace::Derived);\n            if (!val.isghost && !val.ispointer())\n                val = value_to_pointer(ctx, val);\n            Value *args[] = {\n                emit_typeof_boxed(ctx, val),\n                val.isghost ? ConstantPointerNull::get(T_pint8_derived) :\n                    ctx.builder.CreateBitCast(\n                        decay_derived(ctx, data_pointer(ctx, val)),\n                        T_pint8_derived)\n            };\n            Value *ret = ctx.builder.CreateCall(prepare_call(jl_object_id__func), makeArrayRef(args));\n            JL_GC_POP();\n            return mark_or_box_ccall_result(ctx, ret, retboxed, rt, unionall, static_rt);\n        }\n    }\n\n    jl_cgval_t retval = sig.emit_a_ccall(\n            ctx,\n            symarg,\n            argv,\n            gc_uses,\n            static_rt);\n    JL_GC_POP();\n    return retval;\n}\n\njl_cgval_t function_sig_t::emit_a_ccall(\n        jl_codectx_t &ctx,\n        const native_sym_arg_t &symarg,\n        jl_cgval_t *argv,\n        SmallVector<Value*, 16> &gc_uses,\n        bool static_rt) const\n{\n    if (!err_msg.empty()) {\n        emit_error(ctx, err_msg);\n        return jl_cgval_t();\n    }\n\n    FunctionType *functype = this->functype();\n\n    Value **argvals = (Value**) alloca((nccallargs + sret) * sizeof(Value*));\n    for (size_t ai = 0; ai < nccallargs; ai++) {\n        // Current C function parameter\n        jl_cgval_t &arg = argv[ai];\n        jl_value_t *jargty = jl_svecref(at, ai); // Julia type of the current parameter\n        Type *largty = fargt.at(ai); // LLVM type of the current parameter\n        bool toboxed = fargt_isboxed.at(ai);\n        Type *pargty = fargt_sig.at(ai + sret); // LLVM coercion type\n        bool byRef = byRefList.at(ai); // Argument attributes\n\n        // if we know the function sparams, try to fill those in now\n        // so that the julia_to_native type checks are more likely to be doable (e.g. concrete types) at compile-time\n        jl_value_t *jargty_in_env = jargty;\n        if (ctx.spvals_ptr == NULL && !toboxed && unionall_env && jl_has_typevar_from_unionall(jargty, unionall_env) &&\n                jl_svec_len(ctx.linfo->sparam_vals) > 0) {\n            jargty_in_env = jl_instantiate_type_in_env(jargty_in_env, unionall_env, jl_svec_data(ctx.linfo->sparam_vals));\n            if (jargty_in_env != jargty)\n                jl_add_method_root(ctx, jargty_in_env);\n        }\n\n        Value *v;\n        if (jl_is_abstract_ref_type(jargty)) {\n            if (!jl_is_cpointer_type(arg.typ)) {\n                emit_cpointercheck(ctx, arg, \"ccall: argument to Ref{T} is not a pointer\");\n                arg.typ = (jl_value_t*)jl_voidpointer_type;\n                arg.isboxed = false;\n            }\n            jargty_in_env = (jl_value_t*)jl_voidpointer_type;\n        }\n\n        v = julia_to_native(ctx, largty, toboxed, jargty_in_env, unionall_env, arg, byRef, ai);\n        bool issigned = jl_signed_type && jl_subtype(jargty, (jl_value_t*)jl_signed_type);\n        if (byRef) {\n            v = decay_derived(ctx, v);\n            // julia_to_native should already have done the alloca and store\n            assert(v->getType() == pargty);\n        }\n        else {\n            v = llvm_type_rewrite(ctx, v, pargty, issigned);\n        }\n\n        if (isa<UndefValue>(v)) {\n            return jl_cgval_t();\n        }\n        assert(v->getType() == pargty);\n        argvals[ai + sret] = v;\n    }\n\n    Value *result = NULL;\n    // First, if the ABI requires us to provide the space for the return\n    // argument, allocate the box and store that as the first argument type\n    bool sretboxed = false;\n    if (sret) {\n        assert(!retboxed && jl_is_datatype(rt) && \"sret return type invalid\");\n        if (jl_is_pointerfree(rt)) {\n            result = emit_static_alloca(ctx, lrt);\n            argvals[0] = ctx.builder.CreateBitCast(result, fargt_sig.at(0));\n        }\n        else {\n            // XXX: result needs to be zero'd and given a GC root here\n            // and has incorrect write barriers.\n            // instead this code path should behave like `unsafe_load`\n            assert(jl_datatype_size(rt) > 0 && \"sret shouldn't be a singleton instance\");\n            result = emit_allocobj(ctx, jl_datatype_size(rt),\n                                   literal_pointer_val(ctx, (jl_value_t*)rt));\n            sretboxed = true;\n            gc_uses.push_back(result);\n            argvals[0] = ctx.builder.CreateBitCast(emit_pointer_from_objref(ctx, result), fargt_sig.at(0));\n        }\n    }\n\n    // make LLVM function object for the target\n    // keep this close to the function call, so that the compiler can\n    // optimize the global pointer load in the common case\n    Value *llvmf;\n    if (llvmcall) {\n        if (symarg.jl_ptr != NULL) {\n            emit_error(ctx, \"llvmcall doesn't support dynamic pointers\");\n            return jl_cgval_t();\n        }\n        else if (symarg.fptr != NULL) {\n            emit_error(ctx, \"llvmcall doesn't support static pointers\");\n            return jl_cgval_t();\n        }\n        else if (symarg.f_lib != NULL) {\n            emit_error(ctx, \"llvmcall doesn't support dynamic libraries\");\n            return jl_cgval_t();\n        }\n        else {\n            assert(symarg.f_name != NULL);\n            const char* f_name = symarg.f_name;\n            bool f_extern = (strncmp(f_name, \"extern \", 7) == 0);\n            if (f_extern)\n                f_name += 7;\n            llvmf = jl_Module->getOrInsertFunction(f_name, functype).getCallee();\n            if (!f_extern && (!isa<Function>(llvmf) ||\n                              cast<Function>(llvmf)->getIntrinsicID() ==\n                                      Intrinsic::not_intrinsic)) {\n                emit_error(ctx, \"llvmcall only supports intrinsic calls\");\n                return jl_cgval_t();\n            }\n        }\n    }\n    else if (symarg.jl_ptr != NULL) {\n        null_pointer_check(ctx, symarg.jl_ptr);\n        Type *funcptype = PointerType::get(functype, 0);\n        llvmf = emit_inttoptr(ctx, symarg.jl_ptr, funcptype);\n    }\n    else if (symarg.fptr != NULL) {\n        Type *funcptype = PointerType::get(functype, 0);\n        llvmf = literal_static_pointer_val((void*)(uintptr_t)symarg.fptr, funcptype);\n        if (imaging_mode)\n            jl_printf(JL_STDERR,\"WARNING: literal address used in ccall for %s; code cannot be statically compiled\\n\", symarg.f_name);\n    }\n    else {\n        assert(symarg.f_name != NULL);\n        PointerType *funcptype = PointerType::get(functype, 0);\n        if (symarg.lib_expr) {\n            llvmf = runtime_sym_lookup(ctx, funcptype, NULL, symarg.lib_expr, symarg.f_name, ctx.f);\n        }\n        else if (imaging_mode) {\n            // vararg requires musttail,\n            // but musttail is incompatible with noreturn.\n            if (functype->isVarArg())\n                llvmf = runtime_sym_lookup(ctx, funcptype, symarg.f_lib, NULL, symarg.f_name, ctx.f);\n            else\n                llvmf = emit_plt(ctx, functype, attributes, cc, symarg.f_lib, symarg.f_name);\n        }\n        else {\n            void *symaddr;\n            void *libsym = jl_get_library_(symarg.f_lib, 0);\n            if (!libsym || !jl_dlsym(libsym, symarg.f_name, &symaddr, 0)) {\n                // either the library or the symbol could not be found, place a runtime\n                // lookup here instead.\n                llvmf = runtime_sym_lookup(ctx, funcptype, symarg.f_lib, NULL, symarg.f_name, ctx.f);\n            } else {\n                // since we aren't saving this code, there's no sense in\n                // putting anything complicated here: just JIT the function address\n                llvmf = literal_static_pointer_val(symaddr, funcptype);\n            }\n        }\n    }\n\n    OperandBundleDef OpBundle(\"jl_roots\", gc_uses);\n    // the actual call\n    CallInst *ret = ctx.builder.CreateCall(functype, llvmf,\n            ArrayRef<Value*>(&argvals[0], nccallargs + sret),\n            ArrayRef<OperandBundleDef>(&OpBundle, gc_uses.empty() ? 0 : 1));\n    ((CallInst*)ret)->setAttributes(attributes);\n\n    if (cc != CallingConv::C)\n        ((CallInst*)ret)->setCallingConv(cc);\n    if (!sret)\n        result = ret;\n    if (0) { // Enable this to turn on SSPREQ (-fstack-protector) on the function containing this ccall\n        ctx.f->addFnAttr(Attribute::StackProtectReq);\n    }\n\n    if (rt == jl_bottom_type) {\n        CreateTrap(ctx.builder);\n        return jl_cgval_t();\n    }\n\n    // Finally we need to box the result into julia type\n    // However, if we have already created a box for the return\n    // type because the ABI required us to pass a pointer (sret),\n    // then we do not need to do this.\n    bool jlretboxed;\n    if (retboxed) {\n        assert(!sret);\n        jlretboxed = true;\n    }\n    else if (sret) {\n        jlretboxed = sretboxed;\n        if (!jlretboxed) {\n            // something alloca'd above is SSA\n            if (static_rt)\n                return mark_julia_slot(result, rt, NULL, tbaa_stack);\n            result = ctx.builder.CreateLoad(result);\n        }\n    }\n    else {\n        Type *jlrt = julia_type_to_llvm(ctx, rt, &jlretboxed); // compute the real \"julian\" return type and compute whether it is boxed\n        if (type_is_ghost(jlrt)) {\n            return ghostValue(rt);\n        }\n        else if (jl_is_datatype(rt) && jl_is_datatype_singleton((jl_datatype_t*)rt)) {\n            return mark_julia_const(((jl_datatype_t*)rt)->instance);\n        }\n        else if (jlretboxed && !retboxed) {\n            assert(jl_is_datatype(rt));\n            if (static_rt) {\n                Value *runtime_bt = literal_pointer_val(ctx, rt);\n                size_t rtsz = jl_datatype_size(rt);\n                assert(rtsz > 0);\n                Value *strct = emit_allocobj(ctx, rtsz, runtime_bt);\n                MDNode *tbaa = jl_is_mutable(rt) ? tbaa_mutab : tbaa_immut;\n                int boxalign = julia_alignment(rt);\n                // copy the data from the return value to the new struct\n                const DataLayout &DL = jl_data_layout;\n                auto resultTy = result->getType();\n                if (DL.getTypeStoreSize(resultTy) > rtsz) {\n                    // ARM and AArch64 can use a LLVM type larger than the julia type.\n                    // When this happens, cast through memory.\n                    auto slot = emit_static_alloca(ctx, resultTy);\n                    slot->setAlignment(Align(boxalign));\n                    ctx.builder.CreateAlignedStore(result, slot, Align(boxalign));\n                    emit_memcpy(ctx, strct, tbaa, slot, tbaa, rtsz, boxalign);\n                }\n                else {\n                    init_bits_value(ctx, strct, result, tbaa, boxalign);\n                }\n                return mark_julia_type(ctx, strct, true, rt);\n            }\n            jlretboxed = false; // trigger mark_or_box_ccall_result to build the runtime box\n        }\n        else if (lrt != prt) {\n            assert(jlrt == lrt || !lrt->isStructTy()); // julia_type_to_llvm and julia_struct_to_llvm should be returning the same StructType\n            result = llvm_type_rewrite(ctx, result, lrt, false);\n        }\n    }\n\n    return mark_or_box_ccall_result(ctx, result, jlretboxed, rt, unionall_env, static_rt);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/jitlayers.cpp": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n// Except for parts of this file which were copied from LLVM, under the UIUC license (marked below).\n\n#include \"llvm-version.h\"\n#include \"platform.h\"\n\n\n#include \"llvm/IR/Mangler.h\"\n#include <llvm/ADT/StringMap.h>\n#include <llvm/Analysis/TargetLibraryInfo.h>\n#include <llvm/Analysis/TargetTransformInfo.h>\n#include <llvm/ExecutionEngine/Orc/CompileUtils.h>\n#include <llvm/ExecutionEngine/Orc/ExecutionUtils.h>\n#include <llvm/Support/DynamicLibrary.h>\n#include <llvm/Support/FormattedStream.h>\n#include <llvm/Support/SmallVectorMemoryBuffer.h>\n#include <llvm/Support/TargetRegistry.h>\n#include <llvm/Support/raw_ostream.h>\n#include <llvm/Target/TargetMachine.h>\n#include <llvm/Transforms/Utils/Cloning.h>\n#include <llvm/Transforms/Utils/ModuleUtils.h>\n\nusing namespace llvm;\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"codegen_shared.h\"\n#include \"jitlayers.h\"\n#include \"julia_assert.h\"\n\nRTDyldMemoryManager* createRTDyldMemoryManager(void);\n\nvoid jl_init_jit(void) { }\n\n// Snooping on which functions are being compiled, and how long it takes\nJL_STREAM *dump_compiles_stream = NULL;\nextern \"C\" JL_DLLEXPORT\nvoid jl_dump_compiles(void *s)\n{\n    dump_compiles_stream = (JL_STREAM*)s;\n}\nJL_STREAM *dump_llvm_opt_stream = NULL;\nextern \"C\" JL_DLLEXPORT\nvoid jl_dump_llvm_opt(void *s)\n{\n    dump_llvm_opt_stream = (JL_STREAM*)s;\n}\n\nstatic void jl_add_to_ee(std::unique_ptr<Module> m);\nstatic void jl_add_to_ee(std::unique_ptr<Module> &M, StringMap<std::unique_ptr<Module>*> &NewExports);\nstatic uint64_t getAddressForFunction(StringRef fname);\n\nvoid jl_link_global(GlobalVariable *GV, void *addr)\n{\n    Constant *P = literal_static_pointer_val(addr, GV->getValueType());\n    GV->setInitializer(P);\n    if (jl_options.image_codegen) {\n        // If we are forcing imaging mode codegen for debugging,\n        // emit external non-const symbol to avoid LLVM optimizing the code\n        // similar to non-imaging mode.\n        GV->setLinkage(GlobalValue::ExternalLinkage);\n    }\n    else {\n        GV->setConstant(true);\n        GV->setLinkage(GlobalValue::PrivateLinkage);\n        GV->setUnnamedAddr(GlobalValue::UnnamedAddr::Global);\n    }\n}\n\nvoid jl_jit_globals(std::map<void *, GlobalVariable*> &globals)\n{\n    for (auto &global : globals) {\n        jl_link_global(global.second, global.first);\n    }\n}\n\nextern \"C\" JL_DLLEXPORT\nuint64_t jl_cumulative_compile_time_ns_before()\n{\n    int tid = jl_threadid();\n    jl_measure_compile_time[tid] = 1;\n    return jl_cumulative_compile_time[tid];\n}\nextern \"C\" JL_DLLEXPORT\nuint64_t jl_cumulative_compile_time_ns_after()\n{\n    int tid = jl_threadid();\n    jl_measure_compile_time[tid] = 0;\n    return jl_cumulative_compile_time[tid];\n}\n\n// this generates llvm code for the lambda info\n// and adds the result to the jitlayers\n// (and the shadow module),\n// and generates code for it\nstatic jl_callptr_t _jl_compile_codeinst(\n        jl_code_instance_t *codeinst,\n        jl_code_info_t *src,\n        size_t world)\n{\n    // TODO: Merge with jl_dump_compiles?\n    static ios_t f_precompile;\n    static JL_STREAM* s_precompile = NULL;\n\n    // caller must hold codegen_lock\n    // and have disabled finalizers\n    uint64_t start_time = 0;\n    if (dump_compiles_stream != NULL)\n        start_time = jl_hrtime();\n\n    assert(jl_is_code_instance(codeinst));\n    assert(codeinst->min_world <= world && (codeinst->max_world >= world || codeinst->max_world == 0) &&\n        \"invalid world for method-instance\");\n    assert(src && jl_is_code_info(src));\n\n    jl_callptr_t fptr = NULL;\n    // emit the code in LLVM IR form\n    jl_codegen_params_t params;\n    params.cache = true;\n    params.world = world;\n    std::map<jl_code_instance_t*, jl_compile_result_t> emitted;\n    {\n        jl_compile_result_t result = jl_emit_codeinst(codeinst, src, params);\n        if (std::get<0>(result))\n            emitted[codeinst] = std::move(result);\n        jl_compile_workqueue(emitted, params, CompilationPolicy::Default);\n\n        if (params._shared_module)\n            jl_add_to_ee(std::unique_ptr<Module>(params._shared_module));\n        StringMap<std::unique_ptr<Module>*> NewExports;\n        StringMap<void*> NewGlobals;\n        for (auto &global : params.globals) {\n            NewGlobals[global.second->getName()] = global.first;\n        }\n        for (auto &def : emitted) {\n            std::unique_ptr<Module> &M = std::get<0>(def.second);\n            for (auto &F : M->global_objects()) {\n                if (!F.isDeclaration() && F.getLinkage() == GlobalValue::ExternalLinkage) {\n                    NewExports[F.getName()] = &M;\n                }\n            }\n            // Let's link all globals here also (for now)\n            for (auto &GV : M->globals()) {\n                auto InitValue = NewGlobals.find(GV.getName());\n                if (InitValue != NewGlobals.end()) {\n                    jl_link_global(&GV, InitValue->second);\n                }\n            }\n        }\n        for (auto &def : emitted) {\n            // Add the results to the execution engine now\n            std::unique_ptr<Module> &M = std::get<0>(def.second);\n            jl_add_to_ee(M, NewExports);\n        }\n    }\n    JL_TIMING(LLVM_MODULE_FINISH);\n\n    for (auto &def : emitted) {\n        jl_code_instance_t *this_code = def.first;\n        jl_llvm_functions_t decls = std::get<1>(def.second);\n        jl_callptr_t addr;\n        bool isspecsig = false;\n        if (decls.functionObject == \"jl_fptr_args\") {\n            addr = &jl_fptr_args;\n        }\n        else if (decls.functionObject == \"jl_fptr_sparam\") {\n            addr = &jl_fptr_sparam;\n        }\n        else {\n            addr = (jl_callptr_t)getAddressForFunction(decls.functionObject);\n            isspecsig = true;\n        }\n        if (this_code->invoke == NULL) {\n            // once set, don't change invoke-ptr, as that leads to race conditions\n            // with the (not) simultaneous updates to invoke and specptr\n            if (!decls.specFunctionObject.empty()) {\n                this_code->specptr.fptr = (void*)getAddressForFunction(decls.specFunctionObject);\n                this_code->isspecsig = isspecsig;\n            }\n            jl_atomic_store_release(&this_code->invoke, addr);\n        }\n        else if (this_code->invoke == jl_fptr_const_return && !decls.specFunctionObject.empty()) {\n            // hack to export this pointer value to jl_dump_method_asm\n            this_code->specptr.fptr = (void*)getAddressForFunction(decls.specFunctionObject);\n        }\n        if (this_code== codeinst)\n            fptr = addr;\n    }\n\n    uint64_t end_time = 0;\n    if (dump_compiles_stream != NULL)\n        end_time = jl_hrtime();\n\n    // If logging of the compilation stream is enabled,\n    // then dump the method-instance specialization type to the stream\n    jl_method_instance_t *mi = codeinst->def;\n    if (jl_is_method(mi->def.method)) {\n        if (jl_options.trace_compile != NULL) {\n            if (s_precompile == NULL) {\n                const char* t = jl_options.trace_compile;\n                if (!strncmp(t, \"stderr\", 6))\n                    s_precompile = JL_STDERR;\n                else {\n                    if (ios_file(&f_precompile, t, 1, 1, 1, 1) == NULL)\n                        jl_errorf(\"cannot open precompile statement file \\\"%s\\\" for writing\", t);\n                    s_precompile = (JL_STREAM*) &f_precompile;\n                }\n            }\n            if (!jl_has_free_typevars(mi->specTypes)) {\n                jl_printf(s_precompile, \"precompile(\");\n                jl_static_show(s_precompile, mi->specTypes);\n                jl_printf(s_precompile, \")\\n\");\n\n                if (s_precompile != JL_STDERR)\n                    ios_flush(&f_precompile);\n            }\n        }\n        if (dump_compiles_stream != NULL) {\n            jl_printf(dump_compiles_stream, \"%\" PRIu64 \"\\t\\\"\", end_time - start_time);\n            jl_static_show(dump_compiles_stream, mi->specTypes);\n            jl_printf(dump_compiles_stream, \"\\\"\\n\");\n        }\n    }\n    return fptr;\n}\n\nconst char *jl_generate_ccallable(void *llvmmod, void *sysimg_handle, jl_value_t *declrt, jl_value_t *sigt, jl_codegen_params_t &params);\n\n// compile a C-callable alias\nextern \"C\"\nint jl_compile_extern_c(void *llvmmod, void *p, void *sysimg, jl_value_t *declrt, jl_value_t *sigt)\n{\n    JL_LOCK(&codegen_lock);\n    uint64_t compiler_start_time = 0;\n    int tid = jl_threadid();\n    if (jl_measure_compile_time[tid])\n        compiler_start_time = jl_hrtime();\n    jl_codegen_params_t params;\n    jl_codegen_params_t *pparams = (jl_codegen_params_t*)p;\n    if (pparams == NULL)\n        pparams = &params;\n    Module *into = (Module*)llvmmod;\n    if (into == NULL)\n        into = jl_create_llvm_module(\"cextern\");\n    const char *name = jl_generate_ccallable(into, sysimg, declrt, sigt, *pparams);\n    bool success = true;\n    if (!sysimg) {\n        if (jl_ExecutionEngine->getGlobalValueAddress(name)) {\n            success = false;\n        }\n        if (success && p == NULL) {\n            jl_jit_globals(params.globals);\n            assert(params.workqueue.empty());\n            if (params._shared_module)\n                jl_add_to_ee(std::unique_ptr<Module>(params._shared_module));\n        }\n        if (success && llvmmod == NULL)\n            jl_add_to_ee(std::unique_ptr<Module>(into));\n    }\n    if (codegen_lock.count == 1 && jl_measure_compile_time[tid])\n        jl_cumulative_compile_time[tid] += (jl_hrtime() - compiler_start_time);\n    JL_UNLOCK(&codegen_lock);\n    return success;\n}\n\nbool jl_type_mappable_to_c(jl_value_t *ty);\n\n// declare a C-callable entry point; called during code loading from the toplevel\nextern \"C\" JL_DLLEXPORT\nvoid jl_extern_c(jl_value_t *declrt, jl_tupletype_t *sigt)\n{\n    // validate arguments. try to do as many checks as possible here to avoid\n    // throwing errors later during codegen.\n    JL_TYPECHK(@ccallable, type, declrt);\n    if (!jl_is_tuple_type(sigt))\n        jl_type_error(\"@ccallable\", (jl_value_t*)jl_anytuple_type_type, (jl_value_t*)sigt);\n    // check that f is a guaranteed singleton type\n    jl_datatype_t *ft = (jl_datatype_t*)jl_tparam0(sigt);\n    if (!jl_is_datatype(ft) || ft->instance == NULL)\n        jl_error(\"@ccallable: function object must be a singleton\");\n\n    // compute / validate return type\n    if (!jl_is_concrete_type(declrt) || jl_is_kind(declrt))\n        jl_error(\"@ccallable: return type must be concrete and correspond to a C type\");\n    JL_LOCK(&codegen_lock);\n    if (!jl_type_mappable_to_c(declrt))\n        jl_error(\"@ccallable: return type doesn't correspond to a C type\");\n    JL_UNLOCK(&codegen_lock);\n\n    // validate method signature\n    size_t i, nargs = jl_nparams(sigt);\n    for (i = 1; i < nargs; i++) {\n        jl_value_t *ati = jl_tparam(sigt, i);\n        if (!jl_is_concrete_type(ati) || jl_is_kind(ati))\n            jl_error(\"@ccallable: argument types must be concrete\");\n    }\n\n    // save a record of this so that the alias is generated when we write an object file\n    jl_method_t *meth = (jl_method_t*)jl_methtable_lookup(ft->name->mt, (jl_value_t*)sigt, jl_world_counter);\n    if (!jl_is_method(meth))\n        jl_error(\"@ccallable: could not find requested method\");\n    JL_GC_PUSH1(&meth);\n    meth->ccallable = jl_svec2(declrt, (jl_value_t*)sigt);\n    jl_gc_wb(meth, meth->ccallable);\n    JL_GC_POP();\n\n    // create the alias in the current runtime environment\n    int success = jl_compile_extern_c(NULL, NULL, NULL, declrt, (jl_value_t*)sigt);\n    if (!success)\n        jl_error(\"@ccallable was already defined for this method name\");\n}\n\n// this compiles li and emits fptr\nextern \"C\"\njl_code_instance_t *jl_generate_fptr(jl_method_instance_t *mi JL_PROPAGATES_ROOT, size_t world)\n{\n    JL_LOCK(&codegen_lock); // also disables finalizers, to prevent any unexpected recursion\n    uint64_t compiler_start_time = 0;\n    int tid = jl_threadid();\n    if (jl_measure_compile_time[tid])\n        compiler_start_time = jl_hrtime();\n    // if we don't have any decls already, try to generate it now\n    jl_code_info_t *src = NULL;\n    JL_GC_PUSH1(&src);\n    jl_value_t *ci = jl_rettype_inferred(mi, world, world);\n    jl_code_instance_t *codeinst = (ci == jl_nothing ? NULL : (jl_code_instance_t*)ci);\n    if (codeinst) {\n        src = (jl_code_info_t*)codeinst->inferred;\n        if ((jl_value_t*)src == jl_nothing)\n            src = NULL;\n        else if (jl_is_method(mi->def.method))\n            src = jl_uncompress_ir(mi->def.method, codeinst, (jl_array_t*)src);\n    }\n    if (src == NULL && jl_is_method(mi->def.method) &&\n             jl_symbol_name(mi->def.method->name)[0] != '@') {\n        // If the caller didn't provide the source,\n        // see if it is inferred, or try to infer it for ourself.\n        // (but don't bother with typeinf on macros or toplevel thunks)\n        src = jl_type_infer(mi, world, 0);\n    }\n    jl_code_instance_t *compiled = jl_method_compiled(mi, world);\n    if (compiled) {\n        codeinst = compiled;\n    }\n    else if (src && jl_is_code_info(src)) {\n        if (!codeinst) {\n            codeinst = jl_get_method_inferred(mi, src->rettype, src->min_world, src->max_world);\n            if (src->inferred && !codeinst->inferred)\n                codeinst->inferred = jl_nothing;\n        }\n        _jl_compile_codeinst(codeinst, src, world);\n        if (codeinst->invoke == NULL)\n            codeinst = NULL;\n    }\n    else {\n        codeinst = NULL;\n    }\n    if (codegen_lock.count == 1 && jl_measure_compile_time[tid])\n        jl_cumulative_compile_time[tid] += (jl_hrtime() - compiler_start_time);\n    JL_UNLOCK(&codegen_lock);\n    JL_GC_POP();\n    return codeinst;\n}\n\nextern \"C\"\nvoid jl_generate_fptr_for_unspecialized(jl_code_instance_t *unspec)\n{\n    if (jl_atomic_load_relaxed(&unspec->invoke) != NULL) {\n        return;\n    }\n    JL_LOCK(&codegen_lock);\n    uint64_t compiler_start_time = 0;\n    int tid = jl_threadid();\n    if (jl_measure_compile_time[tid])\n        compiler_start_time = jl_hrtime();\n    if (unspec->invoke == NULL) {\n        jl_code_info_t *src = NULL;\n        JL_GC_PUSH1(&src);\n        jl_method_t *def = unspec->def->def.method;\n        if (jl_is_method(def)) {\n            src = (jl_code_info_t*)def->source;\n            if (src == NULL) {\n                // TODO: this is wrong\n                assert(def->generator);\n                // TODO: jl_code_for_staged can throw\n                src = jl_code_for_staged(unspec->def);\n            }\n            if (src && (jl_value_t*)src != jl_nothing)\n                src = jl_uncompress_ir(def, NULL, (jl_array_t*)src);\n        }\n        else {\n            src = (jl_code_info_t*)unspec->def->uninferred;\n        }\n        assert(src && jl_is_code_info(src));\n        _jl_compile_codeinst(unspec, src, unspec->min_world);\n        if (unspec->invoke == NULL) {\n            // if we hit a codegen bug (or ran into a broken generated function or llvmcall), fall back to the interpreter as a last resort\n            jl_atomic_store_release(&unspec->invoke, &jl_fptr_interpret_call);\n        }\n        JL_GC_POP();\n    }\n    if (codegen_lock.count == 1 && jl_measure_compile_time[tid])\n        jl_cumulative_compile_time[tid] += (jl_hrtime() - compiler_start_time);\n    JL_UNLOCK(&codegen_lock); // Might GC\n}\n\n\n// get a native disassembly for a compiled method\nextern \"C\" JL_DLLEXPORT\njl_value_t *jl_dump_method_asm(jl_method_instance_t *mi, size_t world,\n        int raw_mc, char getwrapper, const char* asm_variant, const char *debuginfo)\n{\n    // printing via disassembly\n    jl_code_instance_t *codeinst = jl_generate_fptr(mi, world);\n    if (codeinst) {\n        uintptr_t fptr = (uintptr_t)codeinst->invoke;\n        if (getwrapper)\n            return jl_dump_fptr_asm(fptr, raw_mc, asm_variant, debuginfo);\n        uintptr_t specfptr = (uintptr_t)codeinst->specptr.fptr;\n        if (fptr == (uintptr_t)&jl_fptr_const_return && specfptr == 0) {\n            // normally we prevent native code from being generated for these functions,\n            // (using sentinel value `1` instead)\n            // so create an exception here so we can print pretty our lies\n            JL_LOCK(&codegen_lock); // also disables finalizers, to prevent any unexpected recursion\n            uint64_t compiler_start_time = 0;\n            int tid = jl_threadid();\n            if (jl_measure_compile_time[tid])\n                compiler_start_time = jl_hrtime();\n            specfptr = (uintptr_t)codeinst->specptr.fptr;\n            if (specfptr == 0) {\n                jl_code_info_t *src = jl_type_infer(mi, world, 0);\n                JL_GC_PUSH1(&src);\n                jl_method_t *def = mi->def.method;\n                if (jl_is_method(def)) {\n                    if (!src) {\n                        // TODO: jl_code_for_staged can throw\n                        src = def->generator ? jl_code_for_staged(mi) : (jl_code_info_t*)def->source;\n                    }\n                    if (src && (jl_value_t*)src != jl_nothing)\n                        src = jl_uncompress_ir(mi->def.method, codeinst, (jl_array_t*)src);\n                }\n                fptr = (uintptr_t)codeinst->invoke;\n                specfptr = (uintptr_t)codeinst->specptr.fptr;\n                if (src && jl_is_code_info(src)) {\n                    if (fptr == (uintptr_t)&jl_fptr_const_return && specfptr == 0) {\n                        fptr = (uintptr_t)_jl_compile_codeinst(codeinst, src, world);\n                        specfptr = (uintptr_t)codeinst->specptr.fptr;\n                    }\n                }\n                JL_GC_POP();\n            }\n            if (jl_measure_compile_time[tid])\n                jl_cumulative_compile_time[tid] += (jl_hrtime() - compiler_start_time);\n            JL_UNLOCK(&codegen_lock);\n        }\n        if (specfptr != 0)\n            return jl_dump_fptr_asm(specfptr, raw_mc, asm_variant, debuginfo);\n    }\n\n    // whatever, that didn't work - use the assembler output instead\n    if (raw_mc) // eh, give up, this flag doesn't really work anyways normally\n        return (jl_value_t*)jl_pchar_to_array(\"\", 0);\n    return jl_dump_llvm_asm(jl_get_llvmf_defn(mi, world, getwrapper, true, jl_default_cgparams), asm_variant, debuginfo);\n}\n\n// A simple forwarding class, since OrcJIT v2 needs a unique_ptr, while we have a shared_ptr\nclass ForwardingMemoryManager : public RuntimeDyld::MemoryManager {\nprivate:\n    std::shared_ptr<RuntimeDyld::MemoryManager> MemMgr;\n\npublic:\n    ForwardingMemoryManager(std::shared_ptr<RuntimeDyld::MemoryManager> MemMgr) : MemMgr(MemMgr) {}\n    virtual ~ForwardingMemoryManager() = default;\n    virtual uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,\n                                     unsigned SectionID,\n                                     StringRef SectionName) override {\n        return MemMgr->allocateCodeSection(Size, Alignment, SectionID, SectionName);\n    }\n    virtual uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n                                     unsigned SectionID,\n                                     StringRef SectionName,\n                                     bool IsReadOnly) override {\n        return MemMgr->allocateDataSection(Size, Alignment, SectionID, SectionName, IsReadOnly);\n    }\n    virtual void reserveAllocationSpace(uintptr_t CodeSize, uint32_t CodeAlign,\n                                        uintptr_t RODataSize,\n                                        uint32_t RODataAlign,\n                                        uintptr_t RWDataSize,\n                                        uint32_t RWDataAlign) override {\n        return MemMgr->reserveAllocationSpace(CodeSize, CodeAlign, RODataSize, RODataAlign, RWDataSize, RWDataAlign);\n    }\n    virtual bool needsToReserveAllocationSpace() override {\n        return MemMgr->needsToReserveAllocationSpace();\n    }\n    virtual void registerEHFrames(uint8_t *Addr, uint64_t LoadAddr,\n                                  size_t Size) override {\n        return MemMgr->registerEHFrames(Addr, LoadAddr, Size);\n    }\n    virtual void deregisterEHFrames() override {\n        return MemMgr->deregisterEHFrames();\n    }\n    virtual bool finalizeMemory(std::string *ErrMsg = nullptr) override {\n        return MemMgr->finalizeMemory(ErrMsg);\n    }\n    virtual void notifyObjectLoaded(RuntimeDyld &RTDyld,\n                                    const object::ObjectFile &Obj) override {\n        return MemMgr->notifyObjectLoaded(RTDyld, Obj);\n    }\n};\n\n\n// Custom object emission notification handler for the JuliaOJIT\nextern JITEventListener *CreateJuliaJITEventListener();\n\nJL_DLLEXPORT void ORCNotifyObjectEmitted(JITEventListener *Listener,\n                                         const object::ObjectFile &obj,\n                                         const RuntimeDyld::LoadedObjectInfo &L,\n                                         RTDyldMemoryManager *memmgr);\n\n#if JL_LLVM_VERSION >= 120000\ntemplate <typename ObjT, typename LoadResult>\nvoid JuliaOJIT::registerObject(const ObjT &Obj, const LoadResult &LO)\n{\n    const ObjT* Object = &Obj;\n    ORCNotifyObjectEmitted(JuliaListener.get(), *Object, *LO, MemMgr.get());\n}\n#else\ntemplate <typename ObjT, typename LoadResult>\nvoid JuliaOJIT::registerObject(RTDyldObjHandleT H, const ObjT &Obj, const LoadResult &LO)\n{\n    const ObjT* Object = &Obj;\n    NotifyFinalizer(H, *Object, *LO);\n    ORCNotifyObjectEmitted(JuliaListener.get(), *Object, *LO, MemMgr.get());\n}\n#endif\n\nCodeGenOpt::Level CodeGenOptLevelFor(int optlevel)\n{\n#ifdef DISABLE_OPT\n    return CodeGenOpt::None;\n#else\n    return optlevel < 2 ? CodeGenOpt::None :\n        optlevel == 2 ? CodeGenOpt::Default :\n        CodeGenOpt::Aggressive;\n#endif\n}\n\nstatic void addPassesForOptLevel(legacy::PassManager &PM, TargetMachine &TM, raw_svector_ostream &ObjStream, MCContext *Ctx, int optlevel)\n{\n    addTargetPasses(&PM, &TM);\n    addOptimizationPasses(&PM, optlevel);\n    addMachinePasses(&PM, &TM);\n    if (TM.addPassesToEmitMC(PM, Ctx, ObjStream))\n        llvm_unreachable(\"Target does not support MC emission.\");\n}\n\nCompilerResultT JuliaOJIT::CompilerT::operator()(Module &M)\n{\n    uint64_t start_time = 0;\n    if (dump_llvm_opt_stream != NULL) {\n        // Print LLVM function statistics _before_ optimization\n        // Print all the information about this invocation as a YAML object\n        jl_printf(dump_llvm_opt_stream, \"- \\n\");\n        // We print the name and some statistics for each function in the module, both\n        // before optimization and again afterwards.\n        jl_printf(dump_llvm_opt_stream, \"  before: \\n\");\n        for (auto &F : M.functions()) {\n            if (F.isDeclaration() || F.getName().startswith(\"jfptr_\")) {\n                continue;\n            }\n            // Count number of Basic Blocks\n            int bbs = 0;\n            for (auto &B : F.getBasicBlockList()) {\n                std::ignore = B;\n                ++bbs;\n            }\n\n            // Each function is printed as a YAML object with several attributes\n            jl_printf(dump_llvm_opt_stream, \"    \\\"%s\\\":\\n\", F.getName().str().c_str());\n            jl_printf(dump_llvm_opt_stream, \"        instructions: %u\\n\", F.getInstructionCount());\n            jl_printf(dump_llvm_opt_stream, \"        basicblocks: %u\\n\", bbs);\n        }\n\n        start_time = jl_hrtime();\n    }\n\n    JL_TIMING(LLVM_OPT);\n\n    int optlevel;\n    if (jl_generating_output()) {\n        optlevel = 0;\n    }\n    else {\n        optlevel = jl_options.opt_level;\n        for (auto &F : M.functions()) {\n            if (!F.getBasicBlockList().empty()) {\n                Attribute attr = F.getFnAttribute(\"julia-optimization-level\");\n                StringRef val = attr.getValueAsString();\n                if (val != \"\") {\n                    int ol = (int)val[0] - '0';\n                    if (ol >= 0 && ol < optlevel)\n                        optlevel = ol;\n                }\n            }\n        }\n    }\n    if (optlevel == 0)\n        jit.PM0.run(M);\n    else if (optlevel == 1)\n        jit.PM1.run(M);\n    else if (optlevel == 2)\n        jit.PM2.run(M);\n    else if (optlevel >= 3)\n        jit.PM3.run(M);\n\n    std::unique_ptr<MemoryBuffer> ObjBuffer(\n        new SmallVectorMemoryBuffer(std::move(jit.ObjBufferSV)));\n    auto Obj = object::ObjectFile::createObjectFile(ObjBuffer->getMemBufferRef());\n\n    if (!Obj) {\n        llvm_dump(&M);\n        std::string Buf;\n        raw_string_ostream OS(Buf);\n        logAllUnhandledErrors(Obj.takeError(), OS, \"\");\n        OS.flush();\n        llvm::report_fatal_error(\"FATAL: Unable to compile LLVM Module: '\" + Buf + \"'\\n\"\n                                 \"The module's content was printed above. Please file a bug report\");\n    }\n\n    uint64_t end_time = 0;\n    if (dump_llvm_opt_stream != NULL) {\n        end_time = jl_hrtime();\n        jl_printf(dump_llvm_opt_stream, \"  time_ns: %\" PRIu64 \"\\n\", end_time - start_time);\n        jl_printf(dump_llvm_opt_stream, \"  optlevel: %d\\n\", optlevel);\n\n        // Print LLVM function statistics _after_ optimization\n        jl_printf(dump_llvm_opt_stream, \"  after: \\n\");\n        for (auto &F : M.functions()) {\n            if (F.isDeclaration() || F.getName().startswith(\"jfptr_\")) {\n                continue;\n            }\n\n            // Count number of Basic Blocks\n            int bbs = 0;\n            for (auto &B : F.getBasicBlockList()) {\n                std::ignore = B;\n                ++bbs;\n            }\n\n            jl_printf(dump_llvm_opt_stream, \"    \\\"%s\\\":\\n\", F.getName().str().c_str());\n            jl_printf(dump_llvm_opt_stream, \"        instructions: %u\\n\", F.getInstructionCount());\n            jl_printf(dump_llvm_opt_stream, \"        basicblocks: %u\\n\", bbs);\n        }\n    }\n\n    return CompilerResultT(std::move(ObjBuffer));\n}\n\nJuliaOJIT::JuliaOJIT(TargetMachine &TM, LLVMContext *LLVMCtx)\n  : TM(TM),\n    DL(TM.createDataLayout()),\n    ObjStream(ObjBufferSV),\n    MemMgr(createRTDyldMemoryManager()),\n    JuliaListener(CreateJuliaJITEventListener()),\n    TSCtx(std::unique_ptr<LLVMContext>(LLVMCtx)),\n    ES(),\n    GlobalJD(ES.createBareJITDylib(\"JuliaGlobals\")),\n    JD(ES.createBareJITDylib(\"JuliaOJIT\")),\n    ObjectLayer(\n            ES,\n            [this]() {\n                std::unique_ptr<RuntimeDyld::MemoryManager> result(new ForwardingMemoryManager(MemMgr));\n                return result;\n            }\n        ),\n    CompileLayer(ES, ObjectLayer, std::make_unique<CompilerT>(this))\n{\n#if JL_LLVM_VERSION >= 120000\n    ObjectLayer.setNotifyLoaded(\n        [this](orc::MaterializationResponsibility &MR,\n               const object::ObjectFile &Object,\n               const RuntimeDyld::LoadedObjectInfo &LOS) {\n            registerObject(Object, &LOS);\n        });\n#else\n    ObjectLayer.setNotifyLoaded(\n        [this](RTDyldObjHandleT H,\n               const object::ObjectFile &Object,\n               const RuntimeDyld::LoadedObjectInfo &LOS) {\n            registerObject(H, Object, &LOS);\n        });\n#endif\n    for (int i = 0; i < 4; i++) {\n        TMs[i] = TM.getTarget().createTargetMachine(TM.getTargetTriple().getTriple(), TM.getTargetCPU(),\n                TM.getTargetFeatureString(), TM.Options, Reloc::Static, TM.getCodeModel(),\n                CodeGenOptLevelFor(i), true);\n    }\n    addPassesForOptLevel(PM0, *TMs[0], ObjStream, Ctx, 0);\n    addPassesForOptLevel(PM1, *TMs[1], ObjStream, Ctx, 1);\n    addPassesForOptLevel(PM2, *TMs[2], ObjStream, Ctx, 2);\n    addPassesForOptLevel(PM3, *TMs[3], ObjStream, Ctx, 3);\n\n    // Make sure SectionMemoryManager::getSymbolAddressInProcess can resolve\n    // symbols in the program as well. The nullptr argument to the function\n    // tells DynamicLibrary to load the program, not a library.\n    std::string ErrorStr;\n    if (sys::DynamicLibrary::LoadLibraryPermanently(nullptr, &ErrorStr))\n        report_fatal_error(\"FATAL: unable to dlopen self\\n\" + ErrorStr);\n\n    GlobalJD.addGenerator(\n      cantFail(orc::DynamicLibrarySearchGenerator::GetForCurrentProcess(\n        DL.getGlobalPrefix())));\n\n    // Resolve non-lock free atomic functions in the libatomic1 library.\n    // This is the library that provides support for c11/c++11 atomic operations.\n    const char *const libatomic =\n#if defined(_OS_LINUX_) || defined(_OS_FREEBSD_)\n        \"libatomic.so.1\";\n#elif defined(_OS_WINDOWS_)\n        \"libatomic-1.dll\";\n#else\n        NULL;\n#endif\n    if (libatomic) {\n        static void *atomic_hdl = jl_load_dynamic_library(libatomic, JL_RTLD_LOCAL, 0);\n        if (atomic_hdl != NULL) {\n            GlobalJD.addGenerator(\n              cantFail(orc::DynamicLibrarySearchGenerator::Load(\n                  libatomic,\n                  DL.getGlobalPrefix(),\n                  [&](const orc::SymbolStringPtr &S) {\n                        const char *const atomic_prefix = \"__atomic_\";\n                        return (*S).startswith(atomic_prefix);\n                  })));\n        }\n    }\n\n    JD.addToLinkOrder(GlobalJD, orc::JITDylibLookupFlags::MatchExportedSymbolsOnly);\n}\n\nvoid JuliaOJIT::addGlobalMapping(StringRef Name, uint64_t Addr)\n{\n    std::string MangleName = getMangledName(Name);\n    cantFail(JD.define(orc::absoluteSymbols({{ES.intern(MangleName), JITEvaluatedSymbol::fromPointer((void*)Addr)}})));\n}\n\nvoid JuliaOJIT::addModule(std::unique_ptr<Module> M)\n{\n    JL_TIMING(LLVM_MODULE_FINISH);\n    std::vector<std::string> NewExports;\n    for (auto &F : M->global_values()) {\n        if (!F.isDeclaration() && F.getLinkage() == GlobalValue::ExternalLinkage) {\n            NewExports.push_back(getMangledName(F.getName()));\n        }\n    }\n#ifndef JL_NDEBUG\n    // validate the relocations for M\n    for (Module::global_object_iterator I = M->global_objects().begin(), E = M->global_objects().end(); I != E; ) {\n        GlobalObject *F = &*I;\n        ++I;\n        if (F->isDeclaration()) {\n            if (F->use_empty())\n                F->eraseFromParent();\n            else if (!((isa<Function>(F) && isIntrinsicFunction(cast<Function>(F))) ||\n                       findUnmangledSymbol(F->getName()) ||\n                       SectionMemoryManager::getSymbolAddressInProcess(\n                           getMangledName(F->getName())))) {\n                llvm::errs() << \"FATAL ERROR: \"\n                             << \"Symbol \\\"\" << F->getName().str() << \"\\\"\"\n                             << \"not found\";\n                abort();\n            }\n        }\n    }\n#endif\n#if JL_LLVM_VERSION >= 120000\n    // TODO: what is the performance characteristics of this?\n    cantFail(CompileLayer.add(JD, orc::ThreadSafeModule(std::move(M), TSCtx)));\n#else\n    auto key = ES.allocateVModule();\n    // TODO: what is the performance characteristics of this?\n    cantFail(CompileLayer.add(JD, orc::ThreadSafeModule(std::move(M), TSCtx), key));\n#endif\n    // force eager compilation (for now), due to memory management specifics\n    // (can't handle compilation recursion)\n    for (auto Name : NewExports)\n        cantFail(ES.lookup({&JD}, Name));\n\n}\n\n#if JL_LLVM_VERSION < 120000\nvoid JuliaOJIT::removeModule(ModuleHandleT H)\n{\n    //(void)CompileLayer.remove(H);\n}\n#endif\n\nJL_JITSymbol JuliaOJIT::findSymbol(StringRef Name, bool ExportedSymbolsOnly)\n{\n    orc::JITDylib* SearchOrders[2] = {&GlobalJD, &JD};\n    ArrayRef<orc::JITDylib*> SearchOrder = makeArrayRef(&SearchOrders[ExportedSymbolsOnly ? 0 : 1], ExportedSymbolsOnly ? 2 : 1);\n    auto Sym = ES.lookup(SearchOrder, Name);\n    if (Sym)\n        return *Sym;\n    return Sym.takeError();\n}\n\nJL_JITSymbol JuliaOJIT::findUnmangledSymbol(StringRef Name)\n{\n    return findSymbol(getMangledName(Name), true);\n}\n\nuint64_t JuliaOJIT::getGlobalValueAddress(StringRef Name)\n{\n    auto addr = findSymbol(getMangledName(Name), false);\n    if (!addr) {\n        consumeError(addr.takeError());\n        return 0;\n    }\n    return cantFail(addr.getAddress());\n}\n\nuint64_t JuliaOJIT::getFunctionAddress(StringRef Name)\n{\n    auto addr = findSymbol(getMangledName(Name), false);\n    if (!addr) {\n        consumeError(addr.takeError());\n        return 0;\n    }\n    return cantFail(addr.getAddress());\n}\n\nstatic int globalUniqueGeneratedNames;\nStringRef JuliaOJIT::getFunctionAtAddress(uint64_t Addr, jl_code_instance_t *codeinst)\n{\n    auto &fname = ReverseLocalSymbolTable[(void*)(uintptr_t)Addr];\n    if (fname.empty()) {\n        std::string string_fname;\n        raw_string_ostream stream_fname(string_fname);\n        // try to pick an appropriate name that describes it\n        if (Addr == (uintptr_t)codeinst->invoke) {\n            stream_fname << \"jsysw_\";\n        }\n        else if (codeinst->invoke == &jl_fptr_args) {\n            stream_fname << \"jsys1_\";\n        }\n        else if (codeinst->invoke == &jl_fptr_sparam) {\n            stream_fname << \"jsys3_\";\n        }\n        else {\n            stream_fname << \"jlsys_\";\n        }\n        const char* unadorned_name = jl_symbol_name(codeinst->def->def.method->name);\n        stream_fname << unadorned_name << \"_\" << globalUniqueGeneratedNames++;\n        fname = strdup(stream_fname.str().c_str());\n        addGlobalMapping(fname, Addr);\n    }\n    return fname;\n}\n\n\nvoid JuliaOJIT::RegisterJITEventListener(JITEventListener *L)\n{\n    if (!L)\n        return;\n#if JL_LLVM_VERSION >= 120000\n    this->ObjectLayer.registerJITEventListener(*L);\n#else\n    EventListeners.push_back(L);\n#endif\n}\n\n#if JL_LLVM_VERSION < 120000\nvoid JuliaOJIT::NotifyFinalizer(RTDyldObjHandleT Key,\n                                const object::ObjectFile &Obj,\n                                const RuntimeDyld::LoadedObjectInfo &LoadedObjectInfo)\n{\n    for (auto &Listener : EventListeners)\n        Listener->notifyObjectLoaded(Key, Obj, LoadedObjectInfo);\n}\n#endif\n\nconst DataLayout& JuliaOJIT::getDataLayout() const\n{\n    return DL;\n}\n\nconst Triple& JuliaOJIT::getTargetTriple() const\n{\n    return TM.getTargetTriple();\n}\n\nstd::string JuliaOJIT::getMangledName(StringRef Name)\n{\n    SmallString<128> FullName;\n    Mangler::getNameWithPrefix(FullName, Name, DL);\n    return FullName.str().str();\n}\n\nstd::string JuliaOJIT::getMangledName(const GlobalValue *GV)\n{\n    return getMangledName(GV->getName());\n}\n\nsize_t getRTDyldMemoryManagerTotalBytes(RTDyldMemoryManager *mm);\n\nsize_t JuliaOJIT::getTotalBytes() const\n{\n    return getRTDyldMemoryManagerTotalBytes(MemMgr.get());\n}\n\nJuliaOJIT *jl_ExecutionEngine;\n\n// destructively move the contents of src into dest\n// this assumes that the targets of the two modules are the same\n// including the DataLayout and ModuleFlags (for example)\n// and that there is no module-level assembly\n// Comdat is also removed, since the JIT doesn't need it\nvoid jl_merge_module(Module *dest, std::unique_ptr<Module> src)\n{\n    assert(dest != src.get());\n    for (Module::global_iterator I = src->global_begin(), E = src->global_end(); I != E;) {\n        GlobalVariable *sG = &*I;\n        GlobalVariable *dG = cast_or_null<GlobalVariable>(dest->getNamedValue(sG->getName()));\n        ++I;\n        // Replace a declaration with the definition:\n        if (dG) {\n            if (sG->isDeclaration()) {\n                sG->replaceAllUsesWith(dG);\n                sG->eraseFromParent();\n                continue;\n            }\n            //// If we start using llvm.used, we need to enable and test this\n            //else if (!dG->isDeclaration() && dG->hasAppendingLinkage() && sG->hasAppendingLinkage()) {\n            //    auto *dCA = cast<ConstantArray>(dG->getInitializer());\n            //    auto *sCA = cast<ConstantArray>(sG->getInitializer());\n            //    SmallVector<Constant *, 16> Init;\n            //    for (auto &Op : dCA->operands())\n            //        Init.push_back(cast_or_null<Constant>(Op));\n            //    for (auto &Op : sCA->operands())\n            //        Init.push_back(cast_or_null<Constant>(Op));\n            //    Type *Int8PtrTy = Type::getInt8PtrTy(dest.getContext());\n            //    ArrayType *ATy = ArrayType::get(Int8PtrTy, Init.size());\n            //    GlobalVariable *GV = new GlobalVariable(dest, ATy, dG->isConstant(),\n            //            GlobalValue::AppendingLinkage, ConstantArray::get(ATy, Init), \"\",\n            //            dG->getThreadLocalMode(), dG->getType()->getAddressSpace());\n            //    GV->copyAttributesFrom(dG);\n            //    sG->replaceAllUsesWith(GV);\n            //    dG->replaceAllUsesWith(GV);\n            //    GV->takeName(sG);\n            //    sG->eraseFromParent();\n            //    dG->eraseFromParent();\n            //    continue;\n            //}\n            else {\n                assert(dG->isDeclaration() || (dG->getInitializer() == sG->getInitializer() &&\n                            dG->isConstant() && sG->isConstant()));\n                dG->replaceAllUsesWith(sG);\n                dG->eraseFromParent();\n            }\n        }\n        // Reparent the global variable:\n        sG->removeFromParent();\n        dest->getGlobalList().push_back(sG);\n        // Comdat is owned by the Module\n        sG->setComdat(nullptr);\n    }\n\n    for (Module::iterator I = src->begin(), E = src->end(); I != E;) {\n        Function *sG = &*I;\n        Function *dG = cast_or_null<Function>(dest->getNamedValue(sG->getName()));\n        ++I;\n        // Replace a declaration with the definition:\n        if (dG) {\n            if (sG->isDeclaration()) {\n                sG->replaceAllUsesWith(dG);\n                sG->eraseFromParent();\n                continue;\n            }\n            else {\n                assert(dG->isDeclaration());\n                dG->replaceAllUsesWith(sG);\n                dG->eraseFromParent();\n            }\n        }\n        // Reparent the global variable:\n        sG->removeFromParent();\n        dest->getFunctionList().push_back(sG);\n        // Comdat is owned by the Module\n        sG->setComdat(nullptr);\n    }\n\n    for (Module::alias_iterator I = src->alias_begin(), E = src->alias_end(); I != E;) {\n        GlobalAlias *sG = &*I;\n        GlobalAlias *dG = cast_or_null<GlobalAlias>(dest->getNamedValue(sG->getName()));\n        ++I;\n        if (dG) {\n            if (!dG->isDeclaration()) { // aliases are always definitions, so this test is reversed from the above two\n                sG->replaceAllUsesWith(dG);\n                sG->eraseFromParent();\n                continue;\n            }\n            else {\n                dG->replaceAllUsesWith(sG);\n                dG->eraseFromParent();\n            }\n        }\n        sG->removeFromParent();\n        dest->getAliasList().push_back(sG);\n    }\n\n    // metadata nodes need to be explicitly merged not just copied\n    // so there are special passes here for each known type of metadata\n    NamedMDNode *sNMD = src->getNamedMetadata(\"llvm.dbg.cu\");\n    if (sNMD) {\n        NamedMDNode *dNMD = dest->getOrInsertNamedMetadata(\"llvm.dbg.cu\");\n        for (NamedMDNode::op_iterator I = sNMD->op_begin(), E = sNMD->op_end(); I != E; ++I) {\n            dNMD->addOperand(*I);\n        }\n    }\n}\n\n// optimize memory by turning long strings into memoized copies, instead of\n// making a copy per object file of output.\nvoid jl_jit_share_data(Module &M)\n{\n    std::vector<GlobalVariable*> erase;\n    for (auto &GV : M.globals()) {\n        if (!GV.hasInitializer() || !GV.isConstant())\n            continue;\n        ConstantDataSequential *CDS = dyn_cast<ConstantDataSequential>(GV.getInitializer());\n        if (CDS == nullptr)\n            continue;\n        StringRef data = CDS->getRawDataValues();\n        if (data.size() > 16) { // only for long strings: keep short ones as values\n            Type *T_size = Type::getIntNTy(GV.getContext(), sizeof(void*) * 8);\n            Constant *v = ConstantExpr::getIntToPtr(\n                ConstantInt::get(T_size, (uintptr_t)data.data()),\n                GV.getType());\n            GV.replaceAllUsesWith(v);\n            erase.push_back(&GV);\n        }\n    }\n    for (auto GV : erase)\n        GV->eraseFromParent();\n}\n\nstatic void jl_add_to_ee(std::unique_ptr<Module> m)\n{\n#if defined(_CPU_X86_64_) && defined(_OS_WINDOWS_)\n    // Add special values used by debuginfo to build the UnwindData table registration for Win64\n    Type *T_uint32 = Type::getInt32Ty(m->getContext());\n    ArrayType *atype = ArrayType::get(T_uint32, 3); // want 4-byte alignment of 12-bytes of data\n    GlobalVariable *gvs[2] = {\n        new GlobalVariable(*m, atype,\n            false, GlobalVariable::InternalLinkage,\n            ConstantAggregateZero::get(atype), \"__UnwindData\"),\n        new GlobalVariable(*m, atype,\n            false, GlobalVariable::InternalLinkage,\n            ConstantAggregateZero::get(atype), \"__catchjmp\") };\n    gvs[0]->setSection(\".text\");\n    gvs[1]->setSection(\".text\");\n    appendToUsed(*m, makeArrayRef((GlobalValue**)gvs, 2));\n#endif\n    jl_jit_share_data(*m);\n    assert(jl_ExecutionEngine);\n    jl_ExecutionEngine->addModule(std::move(m));\n}\n\nstatic int jl_add_to_ee(\n        std::unique_ptr<Module> &M,\n        StringMap<std::unique_ptr<Module>*> &NewExports,\n        DenseMap<Module*, int> &Queued,\n        std::vector<std::vector<std::unique_ptr<Module>*>> &ToMerge,\n        int depth)\n{\n    // DAG-sort (post-dominator) the compile to compute the minimum\n    // merge-module sets for linkage\n    if (!M)\n        return 0;\n    // First check and record if it's on the stack somewhere\n    {\n        auto &Cycle = Queued[M.get()];\n        if (Cycle)\n            return Cycle;\n        ToMerge.push_back({});\n        Cycle = depth;\n    }\n    int MergeUp = depth;\n    // Compute the cycle-id\n    for (auto &F : M->global_objects()) {\n        if (F.isDeclaration() && F.getLinkage() == GlobalValue::ExternalLinkage) {\n            auto Callee = NewExports.find(F.getName());\n            if (Callee != NewExports.end()) {\n                auto &CM = Callee->second;\n                int Down = jl_add_to_ee(*CM, NewExports, Queued, ToMerge, depth + 1);\n                assert(Down <= depth);\n                if (Down && Down < MergeUp)\n                    MergeUp = Down;\n            }\n        }\n    }\n    if (MergeUp == depth) {\n        // Not in a cycle (or at the top of it)\n        Queued.erase(M.get());\n        for (auto &CM : ToMerge.at(depth - 1)) {\n            assert(Queued.find(CM->get())->second == depth);\n            Queued.erase(CM->get());\n            jl_merge_module(M.get(), std::move(*CM));\n        }\n        jl_add_to_ee(std::move(M));\n        MergeUp = 0;\n    }\n    else {\n        // Add our frame(s) to the top of the cycle\n        Queued[M.get()] = MergeUp;\n        auto &Top = ToMerge.at(MergeUp - 1);\n        Top.push_back(&M);\n        for (auto &CM : ToMerge.at(depth - 1)) {\n            assert(Queued.find(CM->get())->second == depth);\n            Queued[CM->get()] = MergeUp;\n            Top.push_back(CM);\n        }\n    }\n    ToMerge.pop_back();\n    return MergeUp;\n}\n\nstatic void jl_add_to_ee(std::unique_ptr<Module> &M, StringMap<std::unique_ptr<Module>*> &NewExports)\n{\n    DenseMap<Module*, int> Queued;\n    std::vector<std::vector<std::unique_ptr<Module>*>> ToMerge;\n    jl_add_to_ee(M, NewExports, Queued, ToMerge, 1);\n    assert(!M);\n}\n\n\nstatic uint64_t getAddressForFunction(StringRef fname)\n{\n    auto addr = jl_ExecutionEngine->getFunctionAddress(fname);\n    assert(addr);\n    return addr;\n}\n\n// helper function for adding a DLLImport (dlsym) address to the execution engine\nvoid add_named_global(StringRef name, void *addr)\n{\n    jl_ExecutionEngine->addGlobalMapping(name, (uint64_t)(uintptr_t)addr);\n}\n\nextern \"C\" JL_DLLEXPORT\nsize_t jl_jit_total_bytes(void)\n{\n    return jl_ExecutionEngine->getTotalBytes();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/processor.cpp": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n// Processor feature detection\n\n#include \"llvm-version.h\"\n#include <llvm/ADT/StringRef.h>\n#include <llvm/Support/MathExtras.h>\n#include <llvm/Support/raw_ostream.h>\n\n#include \"processor.h\"\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n\n#include <map>\n#include <algorithm>\n\n#include \"julia_assert.h\"\n\n// CPU target string is a list of strings separated by `;` each string starts with a CPU\n// or architecture name and followed by an optional list of features separated by `,`.\n// A \"generic\" or empty CPU name means the basic required feature set of the target ISA\n// which is at least the architecture the C/C++ runtime is compiled with.\n\n// CPU dispatch needs to determine the version to be used by the sysimg as well as\n// the target and feature used by the JIT. Currently the only limitation on JIT target\n// and feature is matching register size between the sysimg and JIT so that SIMD vectors\n// can be passed correctly. This means disabling AVX and AVX2 if AVX was not enabled\n// in sysimg and disabling AVX512 if it was not enabled in sysimg.\n// This also possibly means that SVE needs to be disabled on AArch64 if sysimg doesn't have it\n// enabled.\n\n// CPU dispatch starts by first deciding the max feature set and CPU requested for JIT.\n// This is the host or the target specified on the command line with features unavailable\n// on the host disabled. All sysimg targets that require features not available in this set\n// will be ignored.\n\n// The next step is matching CPU name.\n// If exact name match with compatible feature set exists, all versions without name match\n// are ignored.\n// This step will query LLVM first so it can accept CPU names that is recognized by LLVM but\n// not by us (yet) when LLVM is enabled.\n\n// If there are still more than one candidates, a feature match is performed.\n// The ones with the largest register size will be used\n// (i.e. AVX512 > AVX2/AVX > SSE, SVE > ASIMD). If there's a tie, the one with the most features\n// enabled will be used. If there's still a tie the one that appears later in the list will be\n// used. (i.e. the order in the version list is significant in this case).\n\n// Features that are not recognized will be passed to LLVM directly during codegen\n// but ignored otherwise.\n\n// A few special features are supported:\n// 1. `clone_all`\n//\n//     This forces the target to have all functions in sysimg cloned.\n//     When used in negative form (i.e. `-clone_all`), this disables full clone that's\n//     enabled by default for certain targets.\n//\n// 2. `base([0-9]*)`\n//\n//     This specifies the (0-based) base target index. The base target is the target\n//     that the current target is based on, i.e. the functions that are not being cloned\n//     will use the version in the base target. This option causes the base target to be\n//     fully cloned (as if `clone_all` is specified for it) if it is not the default target (0).\n//     The index can only be smaller than the current index.\n//\n// 3. `opt_size`\n//\n//     Optimize for size with minimum performance impact. Clang/GCC's `-Os`.\n//\n// 4. `min_size`\n//\n//     Optimize only for size. Clang's `-Oz`.\n\nbool jl_processor_print_help = false;\n\nnamespace {\n\n// Helper functions to test/set feature bits\n\ntemplate<typename T1, typename T2, typename T3>\nstatic inline bool test_bits(T1 v, T2 mask, T3 test)\n{\n    return T3(v & mask) == test;\n}\n\ntemplate<typename T1, typename T2>\nstatic inline bool test_all_bits(T1 v, T2 mask)\n{\n    return test_bits(v, mask, mask);\n}\n\ntemplate<typename T1, typename T2>\nstatic inline bool test_nbit(const T1 &bits, T2 _bitidx)\n{\n    auto bitidx = static_cast<uint32_t>(_bitidx);\n    auto u32idx = bitidx / 32;\n    auto bit = bitidx % 32;\n    return (bits[u32idx] & (1 << bit)) != 0;\n}\n\ntemplate<typename T>\nstatic inline void unset_bits(T &bits)\n{\n    (void)bits;\n}\n\ntemplate<typename T, typename T1, typename... Rest>\nstatic inline void unset_bits(T &bits, T1 _bitidx, Rest... rest)\n{\n    auto bitidx = static_cast<uint32_t>(_bitidx);\n    auto u32idx = bitidx / 32;\n    auto bit = bitidx % 32;\n    bits[u32idx] = bits[u32idx] & ~uint32_t(1 << bit);\n    unset_bits(bits, rest...);\n}\n\ntemplate<typename T, typename T1>\nstatic inline void set_bit(T &bits, T1 _bitidx, bool val)\n{\n    auto bitidx = static_cast<uint32_t>(_bitidx);\n    auto u32idx = bitidx / 32;\n    auto bit = bitidx % 32;\n    if (val) {\n        bits[u32idx] = bits[u32idx] | uint32_t(1 << bit);\n    }\n    else {\n        bits[u32idx] = bits[u32idx] & ~uint32_t(1 << bit);\n    }\n}\n\n// Helper functions to create feature masks\n\n// This can be `std::array<uint32_t,n>` on C++14\ntemplate<size_t n>\nstruct FeatureList {\n    uint32_t eles[n];\n    uint32_t &operator[](size_t pos)\n    {\n        return eles[pos];\n    }\n    constexpr const uint32_t &operator[](size_t pos) const\n    {\n        return eles[pos];\n    }\n    inline int nbits() const\n    {\n        int cnt = 0;\n        for (size_t i = 0; i < n; i++)\n            cnt += llvm::countPopulation(eles[i]);\n        return cnt;\n    }\n    inline bool empty() const\n    {\n        for (size_t i = 0; i < n; i++) {\n            if (eles[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nstatic inline constexpr uint32_t add_feature_mask_u32(uint32_t mask, uint32_t u32idx)\n{\n    return mask;\n}\n\ntemplate<typename T, typename... Rest>\nstatic inline constexpr uint32_t add_feature_mask_u32(uint32_t mask, uint32_t u32idx,\n                                                      T bit, Rest... args)\n{\n    return add_feature_mask_u32(mask | ((int(bit) >= 0 && int(bit) / 32 == (int)u32idx) ?\n                                        (1 << (int(bit) % 32)) : 0),\n                                u32idx, args...);\n}\n\ntemplate<typename... Args>\nstatic inline constexpr uint32_t get_feature_mask_u32(uint32_t u32idx, Args... args)\n{\n    return add_feature_mask_u32(uint32_t(0), u32idx, args...);\n}\n\ntemplate<uint32_t... Is> struct seq{};\ntemplate<uint32_t N, uint32_t... Is>\nstruct gen_seq : gen_seq<N-1, N-1, Is...>{};\ntemplate<uint32_t... Is>\nstruct gen_seq<0, Is...> : seq<Is...>{};\n\ntemplate<size_t n, uint32_t... I, typename... Args>\nstatic inline constexpr FeatureList<n>\n_get_feature_mask(seq<I...>, Args... args)\n{\n    return FeatureList<n>{{get_feature_mask_u32(I, args...)...}};\n}\n\ntemplate<size_t n, typename... Args>\nstatic inline constexpr FeatureList<n> get_feature_masks(Args... args)\n{\n    return _get_feature_mask<n>(gen_seq<n>(), args...);\n}\n\ntemplate<size_t n, uint32_t... I>\nstatic inline constexpr FeatureList<n>\n_feature_mask_or(seq<I...>, const FeatureList<n> &a, const FeatureList<n> &b)\n{\n    return FeatureList<n>{{(a[I] | b[I])...}};\n}\n\ntemplate<size_t n>\nstatic inline constexpr FeatureList<n> operator|(const FeatureList<n> &a, const FeatureList<n> &b)\n{\n    return _feature_mask_or<n>(gen_seq<n>(), a, b);\n}\n\ntemplate<size_t n, uint32_t... I>\nstatic inline constexpr FeatureList<n>\n_feature_mask_and(seq<I...>, const FeatureList<n> &a, const FeatureList<n> &b)\n{\n    return FeatureList<n>{{(a[I] & b[I])...}};\n}\n\ntemplate<size_t n>\nstatic inline constexpr FeatureList<n> operator&(const FeatureList<n> &a, const FeatureList<n> &b)\n{\n    return _feature_mask_and<n>(gen_seq<n>(), a, b);\n}\n\ntemplate<size_t n, uint32_t... I>\nstatic inline constexpr FeatureList<n>\n_feature_mask_not(seq<I...>, const FeatureList<n> &a)\n{\n    return FeatureList<n>{{(~a[I])...}};\n}\n\ntemplate<size_t n>\nstatic inline constexpr FeatureList<n> operator~(const FeatureList<n> &a)\n{\n    return _feature_mask_not<n>(gen_seq<n>(), a);\n}\n\ntemplate<size_t n>\nstatic inline void mask_features(const FeatureList<n> masks, uint32_t *features)\n{\n    for (size_t i = 0; i < n; i++) {\n        features[i] = features[i] & masks[i];\n    }\n}\n\n// Turn feature list to a string the LLVM accept\nstatic inline std::string join_feature_strs(const std::vector<std::string> &strs)\n{\n    size_t nstr = strs.size();\n    if (!nstr)\n        return std::string(\"\");\n    std::string str = strs[0];\n    for (size_t i = 1; i < nstr; i++)\n        str += ',' + strs[i];\n    return str;\n}\n\nstatic inline void append_ext_features(std::string &features, const std::string &ext_features)\n{\n    if (ext_features.empty())\n        return;\n    if (!features.empty())\n        features.push_back(',');\n    features.append(ext_features);\n}\n\nstatic inline void append_ext_features(std::vector<std::string> &features,\n                                       const std::string &ext_features)\n{\n    if (ext_features.empty())\n        return;\n    const char *start = ext_features.c_str();\n    const char *p = start;\n    for (; *p; p++) {\n        if (*p == ',') {\n            features.emplace_back(start, p - start);\n            start = p + 1;\n        }\n    }\n    if (p > start) {\n        features.emplace_back(start, p - start);\n    }\n}\n\n/**\n * Target specific type/constant definitions, always enable.\n */\n\nstruct FeatureName {\n    const char *name;\n    uint32_t bit; // bit index into a `uint32_t` array;\n    uint32_t llvmver; // 0 if it is available on the oldest LLVM version we support\n};\n\ntemplate<typename CPU, size_t n>\nstruct CPUSpec {\n    const char *name;\n    CPU cpu;\n    CPU fallback;\n    uint32_t llvmver;\n    FeatureList<n> features;\n};\n\nstruct FeatureDep {\n    uint32_t feature;\n    uint32_t dep;\n};\n\n// Recursively enable all features that the current feature set depends on.\ntemplate<size_t n>\nstatic inline void enable_depends(FeatureList<n> &features, const FeatureDep *deps, size_t ndeps)\n{\n    bool changed = true;\n    while (changed) {\n        changed = false;\n        for (ssize_t i = ndeps - 1; i >= 0; i--) {\n            auto &dep = deps[i];\n            if (!test_nbit(features, dep.feature) || test_nbit(features, dep.dep))\n                continue;\n            set_bit(features, dep.dep, true);\n            changed = true;\n        }\n    }\n}\n\n// Recursively disable all features that the current feature set does not provide.\ntemplate<size_t n>\nstatic inline void disable_depends(FeatureList<n> &features, const FeatureDep *deps, size_t ndeps)\n{\n    bool changed = true;\n    while (changed) {\n        changed = false;\n        for (ssize_t i = ndeps - 1; i >= 0; i--) {\n            auto &dep = deps[i];\n            if (!test_nbit(features, dep.feature) || test_nbit(features, dep.dep))\n                continue;\n            unset_bits(features, dep.feature);\n            changed = true;\n        }\n    }\n}\n\ntemplate<typename CPU, size_t n>\nstatic const CPUSpec<CPU,n> *find_cpu(uint32_t cpu, const CPUSpec<CPU,n> *cpus, uint32_t ncpus)\n{\n    for (uint32_t i = 0; i < ncpus; i++) {\n        if (cpu == uint32_t(cpus[i].cpu)) {\n            return &cpus[i];\n        }\n    }\n    return nullptr;\n}\n\ntemplate<typename CPU, size_t n>\nstatic const CPUSpec<CPU,n> *find_cpu(llvm::StringRef name, const CPUSpec<CPU,n> *cpus,\n                                      uint32_t ncpus)\n{\n    for (uint32_t i = 0; i < ncpus; i++) {\n        if (name == cpus[i].name) {\n            return &cpus[i];\n        }\n    }\n    return nullptr;\n}\n\ntemplate<typename CPU, size_t n>\nstatic const char *find_cpu_name(uint32_t cpu, const CPUSpec<CPU,n> *cpus, uint32_t ncpus)\n{\n    if (auto *spec = find_cpu(cpu, cpus, ncpus))\n        return spec->name;\n    return \"generic\";\n}\n\nJL_UNUSED static uint32_t find_feature_bit(const FeatureName *features, size_t nfeatures,\n                                           const char *str, size_t len)\n{\n    for (size_t i = 0; i < nfeatures; i++) {\n        auto &feature = features[i];\n        if (strncmp(feature.name, str, len) == 0 && feature.name[len] == 0) {\n            return feature.bit;\n        }\n    }\n    return (uint32_t)-1;\n}\n\n// This is how we save the target identification.\n// CPU name is saved as string instead of binary data like features because\n// 1. CPU ID is less stable (they are not bound to hardware/OS API)\n// 2. We need to support CPU names that are not recognized by us and therefore doesn't have an ID\n// 3. CPU name is trivial to parse\nstatic inline std::vector<uint8_t> serialize_target_data(llvm::StringRef name,\n                                                         uint32_t nfeature,\n                                                         const uint32_t *features_en,\n                                                         const uint32_t *features_dis,\n                                                         llvm::StringRef ext_features)\n{\n    std::vector<uint8_t> res;\n    auto add_data = [&] (const void *data, size_t sz) {\n        size_t old_sz = res.size();\n        res.resize(old_sz + sz);\n        memcpy(&res[old_sz], data, sz);\n    };\n    add_data(&nfeature, 4);\n    add_data(features_en, 4 * nfeature);\n    add_data(features_dis, 4 * nfeature);\n    uint32_t namelen = name.size();\n    add_data(&namelen, 4);\n    add_data(name.data(), namelen);\n    uint32_t ext_features_len = ext_features.size();\n    add_data(&ext_features_len, 4);\n    add_data(ext_features.data(), ext_features_len);\n    return res;\n}\n\ntemplate<size_t n>\nstatic inline std::vector<uint8_t> serialize_target_data(llvm::StringRef name,\n                                                         const FeatureList<n> &features_en,\n                                                         const FeatureList<n> &features_dis,\n                                                         llvm::StringRef ext_features)\n{\n    return serialize_target_data(name, n, &features_en[0], &features_dis[0], ext_features);\n}\n\ntemplate<size_t n>\nstruct TargetData {\n    std::string name;\n    std::string ext_features;\n    struct {\n        FeatureList<n> features;\n        uint32_t flags;\n    } en, dis;\n    int base;\n};\n\n// In addition to the serialized data, the first `uint32_t` gives the number of targets saved\n// and each target has a `uint32_t` flag before the serialized target data.\ntemplate<size_t n>\nstatic inline std::vector<TargetData<n>> deserialize_target_data(const uint8_t *data)\n{\n    auto load_data = [&] (void *dest, size_t sz) {\n        memcpy(dest, data, sz);\n        data += sz;\n    };\n    auto load_string = [&] () {\n        uint32_t len;\n        load_data(&len, 4);\n        std::string res((const char*)data, len);\n        data += len;\n        return res;\n    };\n    uint32_t ntarget;\n    load_data(&ntarget, 4);\n    std::vector<TargetData<n>> res(ntarget);\n    for (uint32_t i = 0; i < ntarget; i++) {\n        auto &target = res[i];\n        load_data(&target.en.flags, 4);\n        target.dis.flags = 0;\n        // Starting serialized target data\n        uint32_t nfeature;\n        load_data(&nfeature, 4);\n        assert(nfeature == n);\n        load_data(&target.en.features[0], 4 * n);\n        load_data(&target.dis.features[0], 4 * n);\n        target.name = load_string();\n        target.ext_features = load_string();\n        target.base = 0;\n    }\n    return res;\n}\n\n// Try getting clone base argument. Return 1-based index. Return 0 if match failed.\nstatic inline int get_clone_base(const char *start, const char *end)\n{\n    const char *prefix = \"base(\";\n    const int prefix_len = strlen(prefix);\n    if (end - start <= prefix_len)\n        return 0;\n    if (memcmp(start, prefix, prefix_len) != 0)\n        return 0;\n    start += prefix_len;\n    if (*start > '9' || *start < '0')\n        return 0;\n    char *digit_end;\n    auto idx = strtol(start, &digit_end, 10);\n    if (idx < 0)\n        return 0;\n    if (*digit_end != ')' || digit_end + 1 != end)\n        return 0;\n    return (int)idx + 1;\n}\n\n// Parse cmdline string. This handles `clone_all` and `base` special features.\n// Other feature names will be passed to `feature_cb` for target dependent parsing.\ntemplate<size_t n, typename F>\nstatic inline std::vector<TargetData<n>>\nparse_cmdline(const char *option, F &&feature_cb)\n{\n    if (!option)\n        option = \"native\";\n    std::vector<TargetData<n>> res;\n    TargetData<n> arg{};\n    auto reset_arg = [&] {\n        res.push_back(arg);\n        arg.name.clear();\n        arg.ext_features.clear();\n        memset(&arg.en.features[0], 0, 4 * n);\n        memset(&arg.dis.features[0], 0, 4 * n);\n        arg.en.flags = 0;\n        arg.dis.flags = 0;\n    };\n    const char *start = option;\n    for (const char *p = option; ; p++) {\n        switch (*p) {\n        case ',':\n        case ';':\n        case '\\0': {\n            bool done = *p == '\\0';\n            bool next_target = *p == ';' || done;\n            if (arg.name.empty()) {\n                if (p == start)\n                    jl_error(\"Invalid target option: empty CPU name\");\n                arg.name.append(start, p - start);\n                if (arg.name == \"help\") {\n                    arg.name = \"native\";\n                    jl_processor_print_help = true;\n                }\n                start = p + 1;\n                if (next_target)\n                    reset_arg();\n                if (done)\n                    return res;\n                continue;\n            }\n            bool disable = false;\n            const char *full = start;\n            const char *fname = full;\n            start = p + 1;\n            if (*full == '-') {\n                disable = true;\n                fname++;\n            }\n            else if (*full == '+') {\n                fname++;\n            }\n            if (llvm::StringRef(fname, p - fname) == \"clone_all\") {\n                if (!disable) {\n                    arg.en.flags |= JL_TARGET_CLONE_ALL;\n                    arg.dis.flags &= ~JL_TARGET_CLONE_ALL;\n                }\n                else {\n                    arg.dis.flags |= JL_TARGET_CLONE_ALL;\n                    arg.en.flags &= ~JL_TARGET_CLONE_ALL;\n                }\n            }\n            else if (llvm::StringRef(fname, p - fname) == \"opt_size\") {\n                if (disable)\n                    jl_error(\"Invalid target option: disabled opt_size.\");\n                if (arg.en.flags & JL_TARGET_MINSIZE)\n                    jl_error(\"Conflicting target option: both opt_size and min_size are specified.\");\n                arg.en.flags |= JL_TARGET_OPTSIZE;\n            }\n            else if (llvm::StringRef(fname, p - fname) == \"min_size\") {\n                if (disable)\n                    jl_error(\"Invalid target option: disabled min_size.\");\n                if (arg.en.flags & JL_TARGET_OPTSIZE)\n                    jl_error(\"Conflicting target option: both opt_size and min_size are specified.\");\n                arg.en.flags |= JL_TARGET_MINSIZE;\n            }\n            else if (int base = get_clone_base(fname, p)) {\n                if (disable)\n                    jl_error(\"Invalid target option: disabled base index.\");\n                base -= 1;\n                if (base >= (int)res.size())\n                    jl_error(\"Invalid target option: base index must refer to a previous target.\");\n                if (res[base].dis.flags & JL_TARGET_CLONE_ALL ||\n                    !(res[base].en.flags & JL_TARGET_CLONE_ALL))\n                    jl_error(\"Invalid target option: base target must be clone_all.\");\n                arg.base = base;\n            }\n            else if (llvm::StringRef(fname, p - fname) == \"help\") {\n                jl_processor_print_help = true;\n            }\n            else {\n                FeatureList<n> &list = disable ? arg.dis.features : arg.en.features;\n                if (!feature_cb(fname, p - fname, list)) {\n                    if (!arg.ext_features.empty())\n                        arg.ext_features += ',';\n                    arg.ext_features += disable ? '-' : '+';\n                    arg.ext_features.append(fname, p - fname);\n                }\n            }\n            if (next_target)\n                reset_arg();\n            if (done) {\n                return res;\n            }\n        }\n            JL_FALLTHROUGH;\n        default:\n            continue;\n        }\n    }\n}\n\n// Cached version of command line parsing\ntemplate<size_t n, typename F>\nstatic inline std::vector<TargetData<n>> &get_cmdline_targets(F &&feature_cb)\n{\n    static std::vector<TargetData<n>> targets =\n        parse_cmdline<n>(jl_options.cpu_target, std::forward<F>(feature_cb));\n    return targets;\n}\n\n// Load sysimg, use the `callback` for dispatch and perform all relocations\n// for the selected target.\ntemplate<typename F>\nstatic inline jl_sysimg_fptrs_t parse_sysimg(void *hdl, F &&callback)\n{\n    jl_sysimg_fptrs_t res = {nullptr, 0, nullptr, 0, nullptr, nullptr};\n\n    // .data base\n    char *data_base;\n    jl_dlsym(hdl, \"jl_sysimg_gvars_base\", (void**)&data_base, 1);\n    // .text base\n    char *text_base;\n    jl_dlsym(hdl, \"jl_sysimg_fvars_base\", (void**)&text_base, 1);\n    res.base = text_base;\n\n    int32_t *offsets;\n    jl_dlsym(hdl, \"jl_sysimg_fvars_offsets\", (void**)&offsets, 1);\n    uint32_t nfunc = offsets[0];\n    res.offsets = offsets + 1;\n\n    void *ids;\n    jl_dlsym(hdl, \"jl_dispatch_target_ids\", &ids, 1);\n    uint32_t target_idx = callback(ids);\n\n    int32_t *reloc_slots;\n    jl_dlsym(hdl, \"jl_dispatch_reloc_slots\", (void **)&reloc_slots, 1);\n    const uint32_t nreloc = reloc_slots[0];\n    reloc_slots += 1;\n    uint32_t *clone_idxs;\n    int32_t *clone_offsets;\n    jl_dlsym(hdl, \"jl_dispatch_fvars_idxs\", (void**)&clone_idxs, 1);\n    jl_dlsym(hdl, \"jl_dispatch_fvars_offsets\", (void**)&clone_offsets, 1);\n    uint32_t tag_len = clone_idxs[0];\n    clone_idxs += 1;\n\n    assert(tag_len & jl_sysimg_tag_mask);\n    std::vector<const int32_t*> base_offsets = {res.offsets};\n    // Find target\n    for (uint32_t i = 0;i < target_idx;i++) {\n        uint32_t len = jl_sysimg_val_mask & tag_len;\n        if (jl_sysimg_tag_mask & tag_len) {\n            if (i != 0)\n                clone_offsets += nfunc;\n            clone_idxs += len + 1;\n        }\n        else {\n            clone_offsets += len;\n            clone_idxs += len + 2;\n        }\n        tag_len = clone_idxs[-1];\n        base_offsets.push_back(tag_len & jl_sysimg_tag_mask ? clone_offsets : nullptr);\n    }\n\n    bool clone_all = (tag_len & jl_sysimg_tag_mask) != 0;\n    // Fill in return value\n    if (clone_all) {\n        // clone_all\n        if (target_idx != 0) {\n            res.offsets = clone_offsets;\n        }\n    }\n    else {\n        uint32_t base_idx = clone_idxs[0];\n        assert(base_idx < target_idx);\n        if (target_idx != 0) {\n            res.offsets = base_offsets[base_idx];\n            assert(res.offsets);\n        }\n        clone_idxs++;\n        res.nclones = tag_len;\n        res.clone_offsets = clone_offsets;\n        res.clone_idxs = clone_idxs;\n    }\n    // Do relocation\n    uint32_t reloc_i = 0;\n    uint32_t len = jl_sysimg_val_mask & tag_len;\n    for (uint32_t i = 0; i < len; i++) {\n        uint32_t idx = clone_idxs[i];\n        int32_t offset;\n        if (clone_all) {\n            offset = res.offsets[idx];\n        }\n        else if (idx & jl_sysimg_tag_mask) {\n            idx = idx & jl_sysimg_val_mask;\n            offset = clone_offsets[i];\n        }\n        else {\n            continue;\n        }\n        bool found = false;\n        for (; reloc_i < nreloc; reloc_i++) {\n            auto reloc_idx = ((const uint32_t*)reloc_slots)[reloc_i * 2];\n            if (reloc_idx == idx) {\n                found = true;\n                auto slot = (const void**)(data_base + reloc_slots[reloc_i * 2 + 1]);\n                *slot = offset + res.base;\n            }\n            else if (reloc_idx > idx) {\n                break;\n            }\n        }\n        assert(found && \"Cannot find GOT entry for cloned function.\");\n        (void)found;\n    }\n\n    return res;\n}\n\ntemplate<typename T>\nstatic inline void check_cmdline(T &&cmdline, bool imaging)\n{\n    assert(cmdline.size() > 0);\n    // It's unclear what does specifying multiple target when not generating\n    // sysimg means. Make it an error for now.\n    if (!imaging) {\n        if (cmdline.size() > 1) {\n            jl_error(\"More than one command line CPU targets specified \"\n                     \"without a `--output-` flag specified\");\n        }\n        if (cmdline[0].en.flags & JL_TARGET_CLONE_ALL) {\n            jl_error(\"\\\"clone_all\\\" feature specified \"\n                     \"without a `--output-` flag specified\");\n        }\n        if (cmdline[0].en.flags & JL_TARGET_OPTSIZE) {\n            jl_error(\"\\\"opt_size\\\" feature specified \"\n                     \"without a `--output-` flag specified\");\n        }\n        if (cmdline[0].en.flags & JL_TARGET_MINSIZE) {\n            jl_error(\"\\\"min_size\\\" feature specified \"\n                     \"without a `--output-` flag specified\");\n        }\n    }\n}\n\nstruct SysimgMatch {\n    uint32_t best_idx{(uint32_t)-1};\n    int vreg_size{0};\n};\n\n// Find the best match in the sysimg.\n// Select the best one based on the largest vector register and largest compatible feature set.\ntemplate<typename S, typename T, typename F>\nstatic inline SysimgMatch match_sysimg_targets(S &&sysimg, T &&target, F &&max_vector_size)\n{\n    SysimgMatch match;\n    bool match_name = false;\n    int feature_size = 0;\n    for (uint32_t i = 0; i < sysimg.size(); i++) {\n        auto &imgt = sysimg[i];\n        if (!(imgt.en.features & target.dis.features).empty()) {\n            // Check sysimg enabled features against runtime disabled features\n            // This is valid (and all what we can do)\n            // even if one or both of the targets are unknown.\n            continue;\n        }\n        if (imgt.name == target.name) {\n            if (!match_name) {\n                match_name = true;\n                match.vreg_size = 0;\n                feature_size = 0;\n            }\n        }\n        else if (match_name) {\n            continue;\n        }\n        int new_vsz = max_vector_size(imgt.en.features);\n        if (match.vreg_size > new_vsz)\n            continue;\n        int new_feature_size = imgt.en.features.nbits();\n        if (match.vreg_size < new_vsz) {\n            match.best_idx = i;\n            match.vreg_size = new_vsz;\n            feature_size = new_feature_size;\n            continue;\n        }\n        if (new_feature_size < feature_size)\n            continue;\n        match.best_idx = i;\n        feature_size = new_feature_size;\n    }\n    if (match.best_idx == (uint32_t)-1)\n        jl_error(\"Unable to find compatible target in system image.\");\n    return match;\n}\n\n// Debug helper\n\ntemplate<typename CPU, size_t n>\nstatic inline void dump_cpu_spec(uint32_t cpu, const FeatureList<n> &features,\n                                 const FeatureName *feature_names, uint32_t nfeature_names,\n                                 const CPUSpec<CPU,n> *cpus, uint32_t ncpus)\n{\n    bool cpu_found = false;\n    for (uint32_t i = 0;i < ncpus;i++) {\n        if (cpu == uint32_t(cpus[i].cpu)) {\n            cpu_found = true;\n            jl_safe_printf(\"CPU: %s\\n\", cpus[i].name);\n            break;\n        }\n    }\n    if (!cpu_found)\n        jl_safe_printf(\"CPU: generic\\n\");\n    jl_safe_printf(\"Features:\");\n    bool first = true;\n    for (uint32_t i = 0;i < nfeature_names;i++) {\n        if (test_nbit(&features[0], feature_names[i].bit)) {\n            if (first) {\n                jl_safe_printf(\" %s\", feature_names[i].name);\n                first = false;\n            }\n            else {\n                jl_safe_printf(\", %s\", feature_names[i].name);\n            }\n        }\n    }\n    jl_safe_printf(\"\\n\");\n}\n\n}\n\n#if defined(_CPU_X86_) || defined(_CPU_X86_64_)\n\n#include \"processor_x86.cpp\"\n\n#elif defined(_CPU_AARCH64_) || defined(_CPU_ARM_)\n\n#include \"processor_arm.cpp\"\n\n#else\n\n#include \"processor_fallback.cpp\"\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/runtime_ccall.cpp": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n#include \"llvm-version.h\"\n#include <map>\n#include <string>\n#include <llvm/ADT/StringMap.h>\n#include <llvm/Support/Host.h>\n#include <llvm/Support/raw_ostream.h>\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"processor.h\"\n#include \"julia_assert.h\"\n\n#ifndef _OS_WINDOWS_\n#include <sys/mman.h>\n#if defined(_OS_DARWIN_) && !defined(MAP_ANONYMOUS)\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n#endif\n\nusing namespace llvm;\n\n// --- library symbol lookup ---\n\n// map from user-specified lib names to handles\nstatic std::map<std::string, void*> libMap;\nstatic jl_mutex_t libmap_lock;\nextern \"C\"\nvoid *jl_get_library_(const char *f_lib, int throw_err) JL_NOTSAFEPOINT\n{\n    void *hnd;\n    if (f_lib == NULL)\n        return jl_RTLD_DEFAULT_handle;\n#ifdef _OS_WINDOWS_\n    if (f_lib == JL_EXE_LIBNAME)\n        return jl_exe_handle;\n    if (f_lib == JL_LIBJULIA_INTERNAL_DL_LIBNAME)\n        return jl_libjulia_internal_handle;\n    if (strcmp(f_lib, JL_LIBJULIA_DL_LIBNAME) == 0)\n        return jl_libjulia_handle;\n#endif\n    JL_LOCK_NOGC(&libmap_lock);\n    // This is the only operation we do on the map, which doesn't invalidate\n    // any references or iterators.\n    void **map_slot = &libMap[f_lib];\n    JL_UNLOCK_NOGC(&libmap_lock);\n    hnd = jl_atomic_load_acquire(map_slot);\n    if (hnd != NULL)\n        return hnd;\n    // We might run this concurrently on two threads but it doesn't matter.\n    hnd = jl_load_dynamic_library(f_lib, JL_RTLD_DEFAULT, throw_err);\n    if (hnd != NULL)\n        jl_atomic_store_release(map_slot, hnd);\n    return hnd;\n}\n\nextern \"C\" JL_DLLEXPORT\nvoid *jl_load_and_lookup(const char *f_lib, const char *f_name, void **hnd) JL_NOTSAFEPOINT\n{\n    void *handle = jl_atomic_load_acquire(hnd);\n    if (!handle)\n        jl_atomic_store_release(hnd, (handle = jl_get_library(f_lib)));\n    void * ptr;\n    jl_dlsym(handle, f_name, &ptr, 1);\n    return ptr;\n}\n\n// jl_load_and_lookup, but with library computed at run time on first call\nextern \"C\" JL_DLLEXPORT\nvoid *jl_lazy_load_and_lookup(jl_value_t *lib_val, const char *f_name)\n{\n    char *f_lib;\n\n    if (jl_is_symbol(lib_val))\n        f_lib = jl_symbol_name((jl_sym_t*)lib_val);\n    else if (jl_is_string(lib_val))\n        f_lib = jl_string_data(lib_val);\n    else\n        jl_type_error(\"ccall\", (jl_value_t*)jl_symbol_type, lib_val);\n    void *ptr;\n    jl_dlsym(jl_get_library(f_lib), f_name, &ptr, 1);\n    return ptr;\n}\n\n// miscellany\nstd::string jl_get_cpu_name_llvm(void)\n{\n    return llvm::sys::getHostCPUName().str();\n}\n\nstd::string jl_get_cpu_features_llvm(void)\n{\n    StringMap<bool> HostFeatures;\n    llvm::sys::getHostCPUFeatures(HostFeatures);\n    std::string attr;\n    for (auto &ele: HostFeatures) {\n        if (ele.getValue()) {\n            if (!attr.empty()) {\n                attr.append(\",+\");\n            }\n            else {\n                attr.append(\"+\");\n            }\n            attr.append(ele.getKey().str());\n        }\n    }\n    // Explicitly disabled features need to be added at the end so that\n    // they are not re-enabled by other features that implies them by default.\n    for (auto &ele: HostFeatures) {\n        if (!ele.getValue()) {\n            if (!attr.empty()) {\n                attr.append(\",-\");\n            }\n            else {\n                attr.append(\"-\");\n            }\n            attr.append(ele.getKey().str());\n        }\n    }\n    return attr;\n}\n\nextern \"C\" JL_DLLEXPORT\njl_value_t *jl_get_JIT(void)\n{\n    const std::string& HostJITName = \"ORCJIT\";\n    return jl_pchar_to_string(HostJITName.data(), HostJITName.size());\n}\n\n#ifndef MAXHOSTNAMELEN\n# define MAXHOSTNAMELEN 256\n#endif\n\n// Form a file name from a pattern made by replacing tokens,\n// similar to many of those provided by ssh_config TOKENS:\n//\n//           %%    A literal `%'.\n//           %p    The process PID\n//           %d    Local user's home directory.\n//           %i    The local user ID.\n//           %L    The local hostname.\n//           %l    The local hostname, including the domain name.\n//           %u    The local username.\nstd::string jl_format_filename(StringRef output_pattern)\n{\n    std::string buf;\n    raw_string_ostream outfile(buf);\n    bool special = false;\n    char hostname[MAXHOSTNAMELEN + 1];\n    uv_passwd_t pwd;\n    bool got_pwd = false;\n    for (auto c : output_pattern) {\n        if (special) {\n            if (!got_pwd && (c == 'i' || c == 'd' || c == 'u')) {\n                int r = uv_os_get_passwd(&pwd);\n                if (r == 0)\n                    got_pwd = true;\n            }\n            switch (c) {\n            case 'p':\n                outfile << jl_getpid();\n                break;\n            case 'd':\n                if (got_pwd)\n                    outfile << pwd.homedir;\n                break;\n            case 'i':\n                if (got_pwd)\n                    outfile << pwd.uid;\n                break;\n            case 'l':\n            case 'L':\n                if (gethostname(hostname, sizeof(hostname)) == 0) {\n                    hostname[sizeof(hostname) - 1] = '\\0'; /* Null terminate, just to be safe. */\n                    outfile << hostname;\n                }\n#ifndef _OS_WINDOWS_\n                if (c == 'l' && getdomainname(hostname, sizeof(hostname)) == 0) {\n                    hostname[sizeof(hostname) - 1] = '\\0'; /* Null terminate, just to be safe. */\n                    outfile << hostname;\n                }\n#endif\n                break;\n            case 'u':\n                if (got_pwd)\n                    outfile << pwd.username;\n                break;\n            default:\n                outfile << c;\n                break;\n            }\n            special = false;\n        }\n        else if (c == '%') {\n            special = true;\n        }\n        else {\n            outfile << c;\n        }\n    }\n    if (got_pwd)\n        uv_os_free_passwd(&pwd);\n    return outfile.str();\n}\n\nextern \"C\" JL_DLLEXPORT char *jl_format_filename(const char *output_pattern)\n{\n    return strdup(jl_format_filename(StringRef(output_pattern)).c_str());\n}\n\n\nstatic jl_mutex_t trampoline_lock;          // for accesses to the cache and freelist\n\nstatic void *trampoline_freelist;\n\nstatic void *trampoline_alloc()             // lock taken by caller\n{\n    const int sz = 64; // oversized for most platforms. todo: use precise value?\n    if (!trampoline_freelist) {\n        int last_errno = errno;\n#ifdef _OS_WINDOWS_\n        DWORD last_error = GetLastError();\n        void *mem = VirtualAlloc(NULL, jl_page_size,\n                MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n        if (mem == NULL)\n            jl_throw(jl_memory_exception);\n        SetLastError(last_error);\n#else\n        void *mem = mmap(0, jl_page_size, PROT_READ | PROT_WRITE | PROT_EXEC,\n                MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n        errno = last_errno;\n        if (mem == MAP_FAILED)\n            jl_throw(jl_memory_exception);\n#endif\n        errno = last_errno;\n        void *next = NULL;\n        for (size_t i = 0; i + sz <= jl_page_size; i += sz) {\n            void **curr = (void**)((char*)mem + i);\n            *curr = next;\n            next = (void*)curr;\n        }\n        trampoline_freelist = next;\n    }\n    void *tramp = trampoline_freelist;\n    trampoline_freelist = *(void**)tramp;\n    return tramp;\n}\n\nstatic void trampoline_free(void *tramp)    // lock taken by caller\n{\n    *(void**)tramp = trampoline_freelist;\n    trampoline_freelist = tramp;\n}\n\nstatic void trampoline_deleter(void **f)\n{\n    void *tramp = f[0];\n    void *fobj = f[1];\n    void *cache = f[2];\n    void *nval = f[3];\n    f[0] = NULL;\n    f[2] = NULL;\n    f[3] = NULL;\n    JL_LOCK_NOGC(&trampoline_lock);\n    if (tramp)\n        trampoline_free(tramp);\n    if (fobj && cache)\n        ptrhash_remove((htable_t*)cache, fobj);\n    if (nval)\n        free(nval);\n    JL_UNLOCK_NOGC(&trampoline_lock);\n}\n\n// Use of `cache` is not clobbered in JL_TRY\nJL_GCC_IGNORE_START(\"-Wclobbered\")\nextern \"C\" JL_DLLEXPORT\njl_value_t *jl_get_cfunction_trampoline(\n    // dynamic inputs:\n    jl_value_t *fobj,\n    jl_datatype_t *result_type,\n    // call-site constants:\n    htable_t *cache, // weakref htable indexed by (fobj, vals)\n    jl_svec_t *fill,\n    void *(*init_trampoline)(void *tramp, void **nval),\n    jl_unionall_t *env,\n    jl_value_t **vals)\n{\n    // lookup (fobj, vals) in cache\n    JL_LOCK_NOGC(&trampoline_lock);\n    if (!cache->table)\n        htable_new(cache, 1);\n    if (fill != jl_emptysvec) {\n        htable_t **cache2 = (htable_t**)ptrhash_bp(cache, (void*)vals);\n        cache = *cache2;\n        if (cache == HT_NOTFOUND) {\n            cache = htable_new((htable_t*)malloc_s(sizeof(htable_t)), 1);\n            *cache2 = cache;\n        }\n    }\n    void *tramp = ptrhash_get(cache, (void*)fobj);\n    JL_UNLOCK_NOGC(&trampoline_lock);\n    if (tramp != HT_NOTFOUND) {\n        assert((jl_datatype_t*)jl_typeof(tramp) == result_type);\n        return (jl_value_t*)tramp;\n    }\n\n    // not found, allocate a new one\n    size_t n = jl_svec_len(fill);\n    void **nval = (void**)malloc_s(sizeof(void*) * (n + 1));\n    nval[0] = (void*)fobj;\n    jl_value_t *result;\n    JL_TRY {\n        for (size_t i = 0; i < n; i++) {\n            jl_value_t *sparam_val = jl_instantiate_type_in_env(jl_svecref(fill, i), env, vals);\n            if (sparam_val != (jl_value_t*)jl_any_type)\n                if (!jl_is_concrete_type(sparam_val) || !jl_is_immutable(sparam_val))\n                    sparam_val = NULL;\n            nval[i + 1] = (void*)sparam_val;\n        }\n        int permanent =\n            (result_type == jl_voidpointer_type) ||\n            jl_is_concrete_type(fobj) ||\n            (((jl_datatype_t*)jl_typeof(fobj))->instance == fobj);\n        if (jl_is_unionall(fobj)) {\n            jl_value_t *uw = jl_unwrap_unionall(fobj);\n            if (jl_is_datatype(uw) && ((jl_datatype_t*)uw)->name->wrapper == fobj)\n                permanent = true;\n        }\n        if (permanent) {\n            result = jl_gc_permobj(sizeof(jl_taggedvalue_t) + jl_datatype_size(result_type), result_type);\n            memset(result, 0, jl_datatype_size(result_type));\n        }\n        else {\n            result = jl_new_struct_uninit(result_type);\n        }\n        if (result_type != jl_voidpointer_type) {\n            assert(jl_datatype_size(result_type) == sizeof(void*) * 4);\n            ((void**)result)[1] = (void*)fobj;\n        }\n        if (!permanent) {\n            void *ptr_finalizer[2] = {\n                    (void*)jl_voidpointer_type,\n                    (void*)&trampoline_deleter\n                };\n            jl_gc_add_finalizer(result, (jl_value_t*)&ptr_finalizer[1]);\n            ((void**)result)[2] = (void*)cache;\n            ((void**)result)[3] = (void*)nval;\n        }\n    }\n    JL_CATCH {\n        free(nval);\n        jl_rethrow();\n    }\n    JL_LOCK_NOGC(&trampoline_lock);\n    tramp = trampoline_alloc();\n    ((void**)result)[0] = tramp;\n    tramp = init_trampoline(tramp, nval);\n    ptrhash_put(cache, (void*)fobj, result);\n    JL_UNLOCK_NOGC(&trampoline_lock);\n    return result;\n}\nJL_GCC_IGNORE_STOP\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/flisp/print.c": "extern void *memrchr(const void *s, int c, size_t n);\n\nstatic void outc(fl_context_t *fl_ctx, char c, ios_t *f)\n{\n    ios_putc(c, f);\n    if (c == '\\n')\n        fl_ctx->HPOS = 0;\n    else\n        fl_ctx->HPOS++;\n}\nstatic void outs(fl_context_t *fl_ctx, const char *s, ios_t *f)\n{\n    ios_puts(s, f);\n    fl_ctx->HPOS += u8_strwidth(s);\n}\nstatic void outsn(fl_context_t *fl_ctx, const char *s, ios_t *f, size_t n)\n{\n    ios_write(f, s, n);\n    fl_ctx->HPOS += u8_strwidth(s);\n}\nstatic int outindent(fl_context_t *fl_ctx, int n, ios_t *f)\n{\n    // move back to left margin if we get too indented\n    if (n > fl_ctx->SCR_WIDTH-12)\n        n = 2;\n    int n0 = n;\n    ios_putc('\\n', f);\n    fl_ctx->VPOS++;\n    fl_ctx->HPOS = n;\n    while (n >= 8) {\n        ios_putc('\\t', f);\n        n -= 8;\n    }\n    while (n) {\n        ios_putc(' ', f);\n        n--;\n    }\n    return n0;\n}\n\nvoid fl_print_chr(fl_context_t *fl_ctx, char c, ios_t *f)\n{\n    outc(fl_ctx, c, f);\n}\n\nvoid fl_print_str(fl_context_t *fl_ctx, const char *s, ios_t *f)\n{\n    outs(fl_ctx, s, f);\n}\n\nvoid print_traverse(fl_context_t *fl_ctx, value_t v)\n{\n    value_t *bp;\n    while (iscons(v)) {\n        if (ismarked(fl_ctx, v)) {\n            bp = (value_t*)ptrhash_bp(&fl_ctx->printconses, (void*)v);\n            if (*bp == (value_t)HT_NOTFOUND)\n                *bp = fixnum(fl_ctx->printlabel++);\n            return;\n        }\n        mark_cons(fl_ctx, v);\n        print_traverse(fl_ctx, car_(v));\n        v = cdr_(v);\n    }\n    if (!ismanaged(fl_ctx, v) || issymbol(v))\n        return;\n    if (ismarked(fl_ctx, v)) {\n        bp = (value_t*)ptrhash_bp(&fl_ctx->printconses, (void*)v);\n        if (*bp == (value_t)HT_NOTFOUND)\n            *bp = fixnum(fl_ctx->printlabel++);\n        return;\n    }\n    if (isvector(v)) {\n        if (vector_size(v) > 0)\n            mark_cons(fl_ctx, v);\n        unsigned int i;\n        for(i=0; i < vector_size(v); i++)\n            print_traverse(fl_ctx, vector_elt(v,i));\n    }\n    else if (iscprim(v)) {\n        mark_cons(fl_ctx, v);\n    }\n    else if (isclosure(v)) {\n        mark_cons(fl_ctx, v);\n        function_t *f = (function_t*)ptr(v);\n        print_traverse(fl_ctx, f->bcode);\n        print_traverse(fl_ctx, f->vals);\n        print_traverse(fl_ctx, f->env);\n    }\n    else {\n        assert(iscvalue(v));\n        cvalue_t *cv = (cvalue_t*)ptr(v);\n        // don't consider shared references to \"\"\n        if (!cv_isstr(fl_ctx, cv) || cv_len(cv)!=0)\n            mark_cons(fl_ctx, v);\n        fltype_t *t = cv_class(cv);\n        if (t->vtable != NULL && t->vtable->print_traverse != NULL)\n            t->vtable->print_traverse(fl_ctx, v);\n    }\n}\n\nstatic void print_symbol_name(fl_context_t *fl_ctx, ios_t *f, char *name)\n{\n    int i, escape=0, charescape=0;\n\n    if ((name[0] == '\\0') ||\n        (name[0] == '.' && name[1] == '\\0') ||\n        (name[0] == '#') ||\n        isnumtok(fl_ctx, name, NULL))\n        escape = 1;\n    i=0;\n    while (name[i]) {\n        if (!symchar(name[i])) {\n            escape = 1;\n            if (name[i]=='|' || name[i]=='\\\\') {\n                charescape = 1;\n                break;\n            }\n        }\n        i++;\n    }\n    if (escape) {\n        if (charescape) {\n            outc(fl_ctx, '|', f);\n            i=0;\n            while (name[i]) {\n                if (name[i]=='|' || name[i]=='\\\\')\n                    outc(fl_ctx, '\\\\', f);\n                outc(fl_ctx, name[i], f);\n                i++;\n            }\n            outc(fl_ctx, '|', f);\n        }\n        else {\n            outc(fl_ctx, '|', f);\n            outs(fl_ctx, name, f);\n            outc(fl_ctx, '|', f);\n        }\n    }\n    else {\n        outs(fl_ctx, name, f);\n    }\n}\n\n/*\n  The following implements a simple pretty-printing algorithm. This is\n  an unlimited-width approach that doesn't require an extra pass.\n  It uses some heuristics to guess whether an expression is \"small\",\n  and avoids wrapping symbols across lines. The result is high\n  performance and nice output for typical code. Quality is poor for\n  pathological or deeply-nested expressions, but those are difficult\n  to print anyway.\n*/\n#define SMALL_STR_LEN 20\nstatic inline int tinyp(fl_context_t *fl_ctx, value_t v)\n{\n    if (issymbol(v))\n        return (u8_strwidth(symbol_name(fl_ctx, v)) < SMALL_STR_LEN);\n    if (fl_isstring(fl_ctx, v))\n        return (cv_len((cvalue_t*)ptr(v)) < SMALL_STR_LEN);\n    return (isfixnum(v) || isbuiltin(v) || v==fl_ctx->F || v==fl_ctx->T || v==fl_ctx->NIL ||\n            v == fl_ctx->FL_EOF);\n}\n\nstatic int smallp(fl_context_t *fl_ctx, value_t v)\n{\n    if (tinyp(fl_ctx, v)) return 1;\n    if (fl_isnumber(fl_ctx, v)) return 1;\n    if (iscons(v)) {\n        if (tinyp(fl_ctx, car_(v)) && (tinyp(fl_ctx, cdr_(v)) ||\n                               (iscons(cdr_(v)) && tinyp(fl_ctx, car_(cdr_(v))) &&\n                                cdr_(cdr_(v))==fl_ctx->NIL)))\n            return 1;\n        return 0;\n    }\n    if (isvector(v)) {\n        size_t s = vector_size(v);\n        return (s == 0 || (tinyp(fl_ctx, vector_elt(v,0)) &&\n                           (s == 1 || (s == 2 &&\n                                       tinyp(fl_ctx, vector_elt(v,1))))));\n    }\n    return 0;\n}\n\nstatic int specialindent(fl_context_t *fl_ctx, value_t head)\n{\n    // indent these forms 2 spaces, not lined up with the first argument\n    if (head == fl_ctx->LAMBDA || head == fl_ctx->TRYCATCH || head == fl_ctx->definesym ||\n        head == fl_ctx->defmacrosym || head == fl_ctx->forsym)\n        return 2;\n    return -1;\n}\n\nstatic int lengthestimate(fl_context_t *fl_ctx, value_t v)\n{\n    // get the width of an expression if we can do so cheaply\n    if (issymbol(v))\n        return u8_strwidth(symbol_name(fl_ctx, v));\n    return -1;\n}\n\nstatic int allsmallp(fl_context_t *fl_ctx, value_t v)\n{\n    int n = 1;\n    while (iscons(v)) {\n        if (!smallp(fl_ctx, car_(v)))\n            return 0;\n        v = cdr_(v);\n        n++;\n        if (n > 25)\n            return n;\n    }\n    return n;\n}\n\nstatic int indentafter3(fl_context_t *fl_ctx, value_t head, value_t v)\n{\n    // for certain X always indent (X a b c) after b\n    return ((head == fl_ctx->forsym) && !allsmallp(fl_ctx, cdr_(v)));\n}\n\nstatic int indentafter2(fl_context_t *fl_ctx, value_t head, value_t v)\n{\n    // for certain X always indent (X a b) after a\n    return ((head == fl_ctx->definesym || head == fl_ctx->defmacrosym) &&\n            !allsmallp(fl_ctx, cdr_(v)));\n}\n\nstatic int indentevery(fl_context_t *fl_ctx, value_t v)\n{\n    // indent before every subform of a special form, unless every\n    // subform is \"small\"\n    value_t c = car_(v);\n    if (c == fl_ctx->LAMBDA || c == fl_ctx->setqsym)\n        return 0;\n    if (c == fl_ctx->IF) // TODO: others\n        return !allsmallp(fl_ctx, cdr_(v));\n    return 0;\n}\n\nstatic int blockindent(fl_context_t *fl_ctx, value_t v)\n{\n    // in this case we switch to block indent mode, where the head\n    // is no longer considered special:\n    // (a b c d e\n    //  f g h i j)\n    return (allsmallp(fl_ctx, v) > 9);\n}\n\nstatic void print_pair(fl_context_t *fl_ctx, ios_t *f, value_t v)\n{\n    value_t cd;\n    char *op = NULL;\n    if (iscons(cdr_(v)) && cdr_(cdr_(v)) == fl_ctx->NIL &&\n        !ptrhash_has(&fl_ctx->printconses, (void*)cdr_(v)) &&\n        (((car_(v) == fl_ctx->QUOTE)     && (op = \"'\"))  ||\n         ((car_(v) == fl_ctx->BACKQUOTE) && (op = \"`\"))  ||\n         ((car_(v) == fl_ctx->COMMA)     && (op = \",\"))  ||\n         ((car_(v) == fl_ctx->COMMAAT)   && (op = \",@\")) ||\n         ((car_(v) == fl_ctx->COMMADOT)  && (op = \",.\")))) {\n        // special prefix syntax\n        unmark_cons(fl_ctx, v);\n        unmark_cons(fl_ctx, cdr_(v));\n        outs(fl_ctx, op, f);\n        fl_print_child(fl_ctx, f, car_(cdr_(v)));\n        return;\n    }\n    int startpos = fl_ctx->HPOS;\n    outc(fl_ctx, '(', f);\n    int newindent=fl_ctx->HPOS, blk=blockindent(fl_ctx, v);\n    int lastv, n=0, si, ind=0, est, always=0, nextsmall, thistiny;\n    if (!blk) always = indentevery(fl_ctx, v);\n    value_t head = car_(v);\n    int after3 = indentafter3(fl_ctx, head, v);\n    int after2 = indentafter2(fl_ctx, head, v);\n    int n_unindented = 1;\n    while (1) {\n        cd = cdr_(v);\n        if (fl_ctx->print_length >= 0 && n >= fl_ctx->print_length && cd!=fl_ctx->NIL) {\n            outsn(fl_ctx, \"...)\", f, 4);\n            break;\n        }\n        lastv = fl_ctx->VPOS;\n        unmark_cons(fl_ctx, v);\n        fl_print_child(fl_ctx, f, car_(v));\n        if (!iscons(cd) || ptrhash_has(&fl_ctx->printconses, (void*)cd)) {\n            if (cd != fl_ctx->NIL) {\n                outsn(fl_ctx, \" . \", f, 3);\n                fl_print_child(fl_ctx, f, cd);\n            }\n            outc(fl_ctx, ')', f);\n            break;\n        }\n\n        if (!fl_ctx->print_pretty ||\n            ((head == fl_ctx->LAMBDA) && n == 0)) {\n            // never break line before lambda-list\n            ind = 0;\n        }\n        else {\n            est = lengthestimate(fl_ctx, car_(cd));\n            nextsmall = smallp(fl_ctx, car_(cd));\n            thistiny = tinyp(fl_ctx, car_(v));\n            ind = (((fl_ctx->VPOS > lastv) ||\n                    (fl_ctx->HPOS>fl_ctx->SCR_WIDTH/2 && !nextsmall && !thistiny && n>0)) ||\n\n                   (fl_ctx->HPOS > fl_ctx->SCR_WIDTH-4) ||\n\n                   (est!=-1 && (fl_ctx->HPOS+est > fl_ctx->SCR_WIDTH-2)) ||\n\n                   ((head == fl_ctx->LAMBDA) && !nextsmall) ||\n\n                   (n > 0 && always) ||\n\n                   (n == 2 && after3) ||\n                   (n == 1 && after2) ||\n\n                   (n_unindented >= 3 && !nextsmall) ||\n\n                   (n == 0 && !smallp(fl_ctx, head)));\n        }\n\n        if (ind) {\n            newindent = outindent(fl_ctx, newindent, f);\n            n_unindented = 1;\n        }\n        else {\n            n_unindented++;\n            outc(fl_ctx, ' ', f);\n            if (n==0) {\n                // set indent level after printing head\n                si = specialindent(fl_ctx, head);\n                if (si != -1)\n                    newindent = startpos + si;\n                else if (!blk)\n                    newindent = fl_ctx->HPOS;\n            }\n        }\n        n++;\n        v = cd;\n    }\n}\n\nstatic void cvalue_print(fl_context_t *fl_ctx, ios_t *f, value_t v);\n\nstatic int print_circle_prefix(fl_context_t *fl_ctx, ios_t *f, value_t v)\n{\n    value_t label;\n    char buf[64];\n    char *str;\n    if ((label=(value_t)ptrhash_get(&fl_ctx->printconses, (void*)v)) !=\n        (value_t)HT_NOTFOUND) {\n        if (!ismarked(fl_ctx, v)) {\n            //fl_ctx->HPOS+=ios_printf(f, \"#%ld#\", numval(label));\n            outc(fl_ctx, '#', f);\n            str = uint2str(buf, sizeof(buf)-1, numval(label), 10);\n            outs(fl_ctx, str, f);\n            outc(fl_ctx, '#', f);\n            return 1;\n        }\n        //fl_ctx->HPOS+=ios_printf(f, \"#%ld=\", numval(label));\n        outc(fl_ctx, '#', f);\n        str = uint2str(buf, sizeof(buf)-1, numval(label), 10);\n        outs(fl_ctx, str, f);\n        outc(fl_ctx, '=', f);\n    }\n    if (ismanaged(fl_ctx, v))\n        unmark_cons(fl_ctx, v);\n    return 0;\n}\n\nvoid fl_print_child(fl_context_t *fl_ctx, ios_t *f, value_t v)\n{\n    char *name, *str;\n    char buf[64];\n    if (fl_ctx->print_level >= 0 && fl_ctx->P_LEVEL >= fl_ctx->print_level &&\n        (iscons(v) || isvector(v) || isclosure(v))) {\n        outc(fl_ctx, '#', f);\n        return;\n    }\n    fl_ctx->P_LEVEL++;\n\n    switch (tag(v)) {\n    case TAG_NUM :\n    case TAG_NUM1: //fl_ctx->HPOS+=ios_printf(f, \"%ld\", numval(v)); break;\n        str = uint2str(&buf[1], sizeof(buf)-1, labs(numval(v)), 10);\n        if (numval(v)<0)\n            *(--str) = '-';\n        outs(fl_ctx, str, f);\n        break;\n    case TAG_SYM:\n        name = symbol_name(fl_ctx, v);\n        if (fl_ctx->print_princ)\n            outs(fl_ctx, name, f);\n        else if (ismanaged(fl_ctx, v)) {\n            outsn(fl_ctx, \"#:\", f, 2);\n            outs(fl_ctx, name, f);\n        }\n        else\n            print_symbol_name(fl_ctx, f, name);\n        break;\n    case TAG_FUNCTION:\n        if (v == fl_ctx->T) {\n            outsn(fl_ctx, \"#t\", f, 2);\n        }\n        else if (v == fl_ctx->F) {\n            outsn(fl_ctx, \"#f\", f, 2);\n        }\n        else if (v == fl_ctx->NIL) {\n            outsn(fl_ctx, \"()\", f, 2);\n        }\n        else if (v == fl_ctx->FL_EOF) {\n            outsn(fl_ctx, \"#<eof>\", f, 6);\n        }\n        else if (isbuiltin(v)) {\n            if (!fl_ctx->print_princ)\n                outsn(fl_ctx, \"#.\", f, 2);\n            outs(fl_ctx, builtin_names[uintval(v)], f);\n        }\n        else {\n            assert(isclosure(v));\n            if (!fl_ctx->print_princ) {\n                if (print_circle_prefix(fl_ctx, f, v)) break;\n                function_t *fn = (function_t*)ptr(v);\n                outs(fl_ctx, \"#fn(\", f);\n                char *data = (char*)cvalue_data(fn->bcode);\n                size_t i, sz = cvalue_len(fn->bcode);\n                for(i=0; i < sz; i++) data[i] += 48;\n                fl_print_child(fl_ctx, f, fn->bcode);\n                for(i=0; i < sz; i++) data[i] -= 48;\n                outc(fl_ctx, ' ', f);\n                fl_print_child(fl_ctx, f, fn->vals);\n                if (fn->env != fl_ctx->NIL) {\n                    outc(fl_ctx, ' ', f);\n                    fl_print_child(fl_ctx, f, fn->env);\n                }\n                if (fn->name != fl_ctx->LAMBDA) {\n                    outc(fl_ctx, ' ', f);\n                    fl_print_child(fl_ctx, f, fn->name);\n                }\n                outc(fl_ctx, ')', f);\n            }\n            else {\n                outs(fl_ctx, \"#<function>\", f);\n            }\n        }\n        break;\n    case TAG_CVALUE:\n    case TAG_CPRIM:\n        if (v == UNBOUND) { outs(fl_ctx, \"#<undefined>\", f); break; }\n        JL_FALLTHROUGH;\n    case TAG_VECTOR:\n    case TAG_CONS:\n        if (print_circle_prefix(fl_ctx, f, v)) break;\n        if (isvector(v)) {\n            outc(fl_ctx, '[', f);\n            int newindent = fl_ctx->HPOS, est;\n            int i, sz = vector_size(v);\n            for(i=0; i < sz; i++) {\n                if (fl_ctx->print_length >= 0 && i >= fl_ctx->print_length && i < sz-1) {\n                    outsn(fl_ctx, \"...\", f, 3);\n                    break;\n                }\n                fl_print_child(fl_ctx, f, vector_elt(v,i));\n                if (i < sz-1) {\n                    if (!fl_ctx->print_pretty) {\n                        outc(fl_ctx, ' ', f);\n                    }\n                    else {\n                        est = lengthestimate(fl_ctx, vector_elt(v,i+1));\n                        if (fl_ctx->HPOS > fl_ctx->SCR_WIDTH-4 ||\n                            (est!=-1 && (fl_ctx->HPOS+est > fl_ctx->SCR_WIDTH-2)) ||\n                            (fl_ctx->HPOS > fl_ctx->SCR_WIDTH/2 &&\n                             !smallp(fl_ctx, vector_elt(v,i+1)) &&\n                             !tinyp(fl_ctx, vector_elt(v,i))))\n                            newindent = outindent(fl_ctx, newindent, f);\n                        else\n                            outc(fl_ctx, ' ', f);\n                    }\n                }\n            }\n            outc(fl_ctx, ']', f);\n            break;\n        }\n        if (iscvalue(v) || iscprim(v))\n            cvalue_print(fl_ctx, f, v);\n        else\n            print_pair(fl_ctx, f, v);\n        break;\n    }\n    fl_ctx->P_LEVEL--;\n}\n\nstatic void print_string(fl_context_t *fl_ctx, ios_t *f, char *str, size_t sz)\n{\n    char buf[512];\n    size_t i = 0;\n    uint8_t c;\n    static const char hexdig[] = \"0123456789abcdef\";\n\n    outc(fl_ctx, '\"', f);\n    if (!u8_isvalid(str, sz)) {\n        // alternate print algorithm that preserves data if it's not UTF-8\n        for(i=0; i < sz; i++) {\n            c = str[i];\n            if (c == '\\\\')\n                outsn(fl_ctx, \"\\\\\\\\\", f, 2);\n            else if (c == '\"')\n                outsn(fl_ctx, \"\\\\\\\"\", f, 2);\n            else if (c >= 32 && c < 0x7f)\n                outc(fl_ctx, c, f);\n            else {\n                outsn(fl_ctx, \"\\\\x\", f, 2);\n                outc(fl_ctx, hexdig[c>>4], f);\n                outc(fl_ctx, hexdig[c&0xf], f);\n            }\n        }\n    }\n    else {\n        while (i < sz) {\n            size_t n = u8_escape(buf, sizeof(buf), str, &i, sz, 1, 0);\n            outsn(fl_ctx, buf, f, n-1);\n        }\n    }\n    outc(fl_ctx, '\"', f);\n}\n\nstatic numerictype_t sym_to_numtype(fl_context_t *fl_ctx, value_t type);\n#ifndef _OS_WINDOWS_\n#define __USE_GNU\n#include <dlfcn.h>\n#undef __USE_GNU\n#endif\n\n#define sign_bit(r) ((*(int64_t*)&(r)) & BIT63)\n#define DFINITE(d) (((*(int64_t*)&(d))&0x7ff0000000000000LL)!=0x7ff0000000000000LL)\n\n// 'weak' means we don't need to accurately reproduce the type, so\n// for example #int32(0) can be printed as just 0. this is used\n// printing in a context where a type is already implied, e.g. inside\n// an array.\nstatic void cvalue_printdata(fl_context_t *fl_ctx, ios_t *f, void *data,\n                             size_t len, value_t type, int weak)\n{\n    if (type == fl_ctx->bytesym) {\n        unsigned char ch = *(unsigned char*)data;\n        if (fl_ctx->print_princ)\n            outc(fl_ctx, ch, f);\n        else if (weak)\n            fl_ctx->HPOS+=ios_printf(f, \"0x%hhx\", ch);\n        else\n            fl_ctx->HPOS+=ios_printf(f, \"#byte(0x%hhx)\", ch);\n    }\n    else if (type == fl_ctx->wcharsym) {\n        uint32_t wc = *(uint32_t*)data;\n        char seq[8];\n        size_t nb = u8_toutf8(seq, sizeof(seq), &wc, 1);\n        seq[nb] = '\\0';\n        if (fl_ctx->print_princ) {\n            // TODO: better multibyte handling\n            outs(fl_ctx, seq, f);\n        }\n        else {\n            outsn(fl_ctx, \"#\\\\\", f, 2);\n            if      (wc == 0x00) outsn(fl_ctx, \"nul\", f, 3);\n            else if (wc == 0x07) outsn(fl_ctx, \"alarm\", f, 5);\n            else if (wc == 0x08) outsn(fl_ctx, \"backspace\", f, 9);\n            else if (wc == 0x09) outsn(fl_ctx, \"tab\", f, 3);\n            else if (wc == 0x0A) outsn(fl_ctx, \"linefeed\", f, 8);\n            //else if (wc == 0x0A) outsn(fl_ctx, \"newline\", f, 7);\n            else if (wc == 0x0B) outsn(fl_ctx, \"vtab\", f, 4);\n            else if (wc == 0x0C) outsn(fl_ctx, \"page\", f, 4);\n            else if (wc == 0x0D) outsn(fl_ctx, \"return\", f, 6);\n            else if (wc == 0x1B) outsn(fl_ctx, \"esc\", f, 3);\n            else if (wc == 0x20) outsn(fl_ctx, \"space\", f, 5);\n            else if (wc == 0x7F) outsn(fl_ctx, \"delete\", f, 6);\n            else if (iswprint(wc)) outs(fl_ctx, seq, f);\n            else fl_ctx->HPOS+=ios_printf(f, \"x%04x\", (int)wc);\n        }\n    }\n    else if (type == fl_ctx->floatsym || type == fl_ctx->doublesym) {\n        char buf[64];\n        double d;\n        if (type == fl_ctx->floatsym) { d = (double)*(float*)data; }\n        else { d = *(double*)data; }\n        if (!DFINITE(d)) {\n            char *rep;\n            if (d != d)\n                rep = (char*)(sign_bit(d) ? \"-nan.0\" : \"+nan.0\");\n            else\n                rep = (char*)(sign_bit(d) ? \"-inf.0\" : \"+inf.0\");\n            if (type == fl_ctx->floatsym && !fl_ctx->print_princ && !weak)\n                fl_ctx->HPOS+=ios_printf(f, \"#%s(%s)\", symbol_name(fl_ctx, type), rep);\n            else\n                outs(fl_ctx, rep, f);\n        }\n        else if (d == 0) {\n            if (sign_bit(d))\n                outsn(fl_ctx, \"-0.0\", f, 4);\n            else\n                outsn(fl_ctx, \"0.0\", f, 3);\n            if (type == fl_ctx->floatsym && !fl_ctx->print_princ && !weak)\n                outc(fl_ctx, 'f', f);\n        }\n        else {\n            double ad = d < 0 ? -d : d;\n            if ((long)d == d && ad < 1e6 && ad >= 1e-4) {\n                snprintf(buf, sizeof(buf), \"%g\", d);\n            }\n            else {\n                if (type == fl_ctx->floatsym)\n                    snprintf(buf, sizeof(buf), \"%.8g\", d);\n                else\n                    snprintf(buf, sizeof(buf), \"%.16g\", d);\n            }\n            int hasdec = (strpbrk(buf, \".eE\") != NULL);\n            outs(fl_ctx, buf, f);\n            if (!hasdec) outsn(fl_ctx, \".0\", f, 2);\n            if (type == fl_ctx->floatsym && !fl_ctx->print_princ && !weak)\n                outc(fl_ctx, 'f', f);\n        }\n    }\n    else if (type == fl_ctx->uint64sym\n#ifdef _P64\n             || type == fl_ctx->sizesym\n#endif\n             ) {\n        uint64_t ui64 = *(uint64_t*)data;\n        if (weak || fl_ctx->print_princ)\n            fl_ctx->HPOS += ios_printf(f, \"%llu\", ui64);\n        else\n            fl_ctx->HPOS += ios_printf(f, \"#%s(%llu)\", symbol_name(fl_ctx, type), ui64);\n    }\n    else if (issymbol(type)) {\n        // handle other integer prims. we know it's smaller than uint64\n        // at this point, so int64 is big enough to capture everything.\n        numerictype_t nt = sym_to_numtype(fl_ctx, type);\n        if (nt == N_NUMTYPES) {\n            // These states should be context independent.\n            static size_t (*volatile jl_static_print)(ios_t*, void*) = NULL;\n            static volatile int init = 0;\n            // XXX: use uv_once\n            if (init == 0) {\n#if defined(RTLD_SELF)\n                jl_static_print = (size_t (*)(ios_t*, void*))\n                    (uintptr_t)dlsym(RTLD_SELF, \"jl_static_show\");\n#elif defined(RTLD_DEFAULT)\n                jl_static_print = (size_t (*)(ios_t*, void*))\n                    (uintptr_t)dlsym(RTLD_DEFAULT, \"jl_static_show\");\n#elif defined(_OS_WINDOWS_)\n                HMODULE handle;\n                if (GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |\n                                       GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n                                       (LPCWSTR)(&cvalue_printdata),\n                                       &handle)) {\n                    jl_static_print = (size_t (*)(ios_t*, void*))\n                        (uintptr_t)GetProcAddress(handle, \"jl_static_show\");\n                }\n#endif\n                init = 1;\n            }\n            if (jl_static_print != NULL && fl_ctx->jl_sym == type) {\n                fl_ctx->HPOS += ios_printf(f, \"#<julia: \");\n                fl_ctx->HPOS += jl_static_print(f, *(void**)data);\n                fl_ctx->HPOS += ios_printf(f, \">\");\n            }\n            else\n                fl_ctx->HPOS += ios_printf(f, \"#<%s>\", symbol_name(fl_ctx, type));\n        }\n        else {\n            int64_t i64 = conv_to_int64(data, nt);\n            if (weak || fl_ctx->print_princ)\n                fl_ctx->HPOS += ios_printf(f, \"%lld\", i64);\n            else\n                fl_ctx->HPOS += ios_printf(f, \"#%s(%lld)\", symbol_name(fl_ctx, type), i64);\n        }\n    }\n    else if (iscons(type)) {\n        if (car_(type) == fl_ctx->arraysym) {\n            value_t eltype = car(fl_ctx, cdr_(type));\n            size_t cnt, elsize;\n            if (iscons(cdr_(cdr_(type)))) {\n                cnt = tosize(fl_ctx, car_(cdr_(cdr_(type))), \"length\");\n                elsize = cnt ? len/cnt : 0;\n            }\n            else {\n                // incomplete array type\n                int junk;\n                elsize = ctype_sizeof(fl_ctx, eltype, &junk);\n                cnt = elsize ? len/elsize : 0;\n            }\n            if (eltype == fl_ctx->bytesym) {\n                if (fl_ctx->print_princ) {\n                    ios_write(f, (char*)data, len);\n                    /*\n                    char *nl = memrchr(data, '\\n', len);\n                    if (nl)\n                        fl_ctx->HPOS = u8_strwidth(nl+1);\n                    else\n                        fl_ctx->HPOS += u8_strwidth(data);\n                    */\n                }\n                else {\n                    print_string(fl_ctx, f, (char*)data, len);\n                }\n                return;\n            }\n            else if (eltype == fl_ctx->wcharsym) {\n                // TODO wchar\n            }\n            else {\n            }\n            size_t i;\n            if (!weak) {\n                if (eltype == fl_ctx->uint8sym) {\n                    outsn(fl_ctx, \"#vu8(\", f, 5);\n                }\n                else {\n                    outsn(fl_ctx, \"#array(\", f, 7);\n                    fl_print_child(fl_ctx, f, eltype);\n                    if (cnt > 0)\n                        outc(fl_ctx, ' ', f);\n                }\n            }\n            else {\n                outc(fl_ctx, '[', f);\n            }\n            for(i=0; i < cnt; i++) {\n                if (i > 0)\n                    outc(fl_ctx, ' ', f);\n                cvalue_printdata(fl_ctx, f, data, elsize, eltype, 1);\n                data = (char *)data + elsize;\n            }\n            if (!weak)\n                outc(fl_ctx, ')', f);\n            else\n                outc(fl_ctx, ']', f);\n        }\n    }\n}\n\nstatic void cvalue_print(fl_context_t *fl_ctx, ios_t *f, value_t v)\n{\n    cvalue_t *cv = (cvalue_t*)ptr(v);\n    void *data = cptr(v);\n    value_t label;\n\n    if (cv_class(cv) == fl_ctx->builtintype) {\n        void *fptr = *(void**)data;\n        label = (value_t)ptrhash_get(&fl_ctx->reverse_dlsym_lookup_table, cv);\n        if (label == (value_t)HT_NOTFOUND) {\n            fl_ctx->HPOS += ios_printf(f, \"#<builtin @0x%08zx>\", (size_t)fptr);\n        }\n        else {\n            if (fl_ctx->print_princ) {\n                outs(fl_ctx, symbol_name(fl_ctx, label), f);\n            }\n            else {\n                outsn(fl_ctx, \"#fn(\", f, 4);\n                outs(fl_ctx, symbol_name(fl_ctx, label), f);\n                outc(fl_ctx, ')', f);\n            }\n        }\n    }\n    else if (cv_class(cv)->vtable != NULL &&\n             cv_class(cv)->vtable->print != NULL) {\n        cv_class(cv)->vtable->print(fl_ctx, v, f);\n    }\n    else {\n        value_t type = cv_type(cv);\n        size_t len = iscprim(v) ? cv_class(cv)->size : cv_len(cv);\n        cvalue_printdata(fl_ctx, f, data, len, type, 0);\n    }\n}\n\nstatic void set_print_width(fl_context_t *fl_ctx)\n{\n    value_t pw = symbol_value(fl_ctx->printwidthsym);\n    if (!isfixnum(pw)) return;\n    fl_ctx->SCR_WIDTH = numval(pw);\n}\n\nvoid fl_print(fl_context_t *fl_ctx, ios_t *f, value_t v)\n{\n    fl_ctx->print_pretty = (symbol_value(fl_ctx->printprettysym) != fl_ctx->F);\n    if (fl_ctx->print_pretty)\n        set_print_width(fl_ctx);\n    fl_ctx->print_princ = (symbol_value(fl_ctx->printreadablysym) == fl_ctx->F);\n\n    value_t pl = symbol_value(fl_ctx->printlengthsym);\n    if (isfixnum(pl)) fl_ctx->print_length = numval(pl);\n    else fl_ctx->print_length = -1;\n    pl = symbol_value(fl_ctx->printlevelsym);\n    if (isfixnum(pl)) fl_ctx->print_level = numval(pl);\n    else fl_ctx->print_level = -1;\n    fl_ctx->P_LEVEL = 0;\n\n    fl_ctx->printlabel = 0;\n    print_traverse(fl_ctx, v);\n    fl_ctx->HPOS = fl_ctx->VPOS = 0;\n\n    fl_print_child(fl_ctx, f, v);\n\n    if (fl_ctx->print_level >= 0 || fl_ctx->print_length >= 0) {\n        memset(fl_ctx->consflags, 0, 4*bitvector_nwords(fl_ctx->heapsize/sizeof(cons_t)));\n    }\n\n    if ((iscons(v) || isvector(v) || isfunction(v) || iscvalue(v)) &&\n        !fl_isstring(fl_ctx, v) && v!=fl_ctx->T && v!=fl_ctx->F && v!=fl_ctx->NIL) {\n        htable_reset(&fl_ctx->printconses, 32);\n    }\n}\n\nvoid fl_print_init(fl_context_t *fl_ctx)\n{\n    htable_new(&fl_ctx->printconses, 32);\n    fl_ctx->SCR_WIDTH = 80;\n    fl_ctx->HPOS = 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/flisp/flisp.h": "#ifndef FLISP_H\n#define FLISP_H\n\n#include <setjmp.h>\n#include <stdint.h>\n\n#include \"platform.h\"\n#include \"libsupport.h\"\n#include \"uv.h\"\n\n//#define MEMDEBUG\n//#define MEMDEBUG2\n\ntypedef uintptr_t value_t;\ntypedef int_t fixnum_t;\n#if NBITS==64\n#define T_FIXNUM T_INT64\n#define labs llabs\n#else\n#define T_FIXNUM T_INT32\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\ntypedef struct _fl_context_t fl_context_t;\ntypedef struct {\n    value_t car;\n    value_t cdr;\n} cons_t;\n\ntypedef struct _symbol_t {\n    uintptr_t flags;\n    value_t binding;   // global value binding\n    struct _fltype_t *type;\n    uint32_t hash;\n    void *dlcache;     // dlsym address\n    // below fields are private\n    struct _symbol_t *left;\n    struct _symbol_t *right;\n    JL_ATTRIBUTE_ALIGN_PTRSIZE(char name[]);\n} symbol_t;\n\ntypedef struct {\n    value_t isconst;\n    value_t binding;   // global value binding\n    struct _fltype_t *type;\n    uint32_t id;\n} gensym_t;\n\n#define TAG_NUM      0x0\n#define TAG_CPRIM    0x1\n#define TAG_FUNCTION 0x2\n#define TAG_VECTOR   0x3\n#define TAG_NUM1     0x4\n#define TAG_CVALUE   0x5\n#define TAG_SYM      0x6\n#define TAG_CONS     0x7\n#define UNBOUND      ((value_t)0x1) // an invalid value\n#define TAG_FWD      UNBOUND\n#define tag(x) ((x)&0x7)\n#define ptr(x) ((void*)((x)&(~(value_t)0x7)))\n#define tagptr(p,t) (((value_t)(p)) | (t))\n#define fixnum(x) ((value_t)(((uintptr_t)(x))<<2))\n#define numval(x)  (((fixnum_t)(x))>>2)\n#if NBITS==64\n#define fits_fixnum(x) (((x)>>61) == 0 || (~((x)>>61)) == 0)\n#else\n#define fits_fixnum(x) (((x)>>29) == 0 || (~((x)>>29)) == 0)\n#endif\n#define fits_bits(x,b) (((x)>>(b-1)) == 0 || (~((x)>>(b-1))) == 0)\n#define uintval(x)  (((unsigned int)(x))>>3)\n#define builtin(n) tagptr((((int)n)<<3), TAG_FUNCTION)\n#define iscons(x)    (tag(x) == TAG_CONS)\n#define issymbol(x)  (tag(x) == TAG_SYM)\n#define isfixnum(x)  (((x)&3) == TAG_NUM)\n#define bothfixnums(x,y) ((((x)|(y))&3) == TAG_NUM)\n#define isbuiltin(x) ((tag(x) == TAG_FUNCTION) && uintval(x) <= OP_ASET)\n#define isvector(x) (tag(x) == TAG_VECTOR)\n#define iscvalue(x) (tag(x) == TAG_CVALUE)\n#define iscprim(x)  (tag(x) == TAG_CPRIM)\n#define selfevaluating(x) (tag(x)<6)\n// comparable with ==\n#define eq_comparable(a,b) (!(((a)|(b))&1))\n#define eq_comparablep(a) (!((a)&1))\n// doesn't lead to other values\n#define leafp(a) (((a)&3) != 3)\n\n#define isforwarded(v) (((value_t*)ptr(v))[0] == TAG_FWD)\n#define forwardloc(v)  (((value_t*)ptr(v))[1])\n#define forward(v,to) do { (((value_t*)ptr(v))[0] = TAG_FWD); \\\n                           (((value_t*)ptr(v))[1] = to); } while (0)\n\n#define vector_size(v) (((size_t*)ptr(v))[0]>>2)\n#define vector_setsize(v,n) (((size_t*)ptr(v))[0] = ((n)<<2))\n#define vector_elt(v,i) (((value_t*)ptr(v))[1+(i)])\n#define vector_grow_amt(x) ((x)<8 ? 5 : 6*((x)>>3))\n// functions ending in _ are unsafe, faster versions\n#define car_(v) (((cons_t*)ptr(v))->car)\n#define cdr_(v) (((cons_t*)ptr(v))->cdr)\n#define car(fl_ctx, v)  (tocons(fl_ctx, (v),\"car\")->car)\n#define cdr(fl_ctx, v)  (tocons(fl_ctx, (v),\"cdr\")->cdr)\n#define fn_bcode(f) (((value_t*)ptr(f))[0])\n#define fn_vals(f) (((value_t*)ptr(f))[1])\n#define fn_env(f) (((value_t*)ptr(f))[2])\n#define fn_name(f) (((value_t*)ptr(f))[3])\n\n#define set(s, v)  (((symbol_t*)ptr(s))->binding = (v))\n#define setc(s, v) do { ((symbol_t*)ptr(s))->flags |= 1; \\\n                        ((symbol_t*)ptr(s))->binding = (v); } while (0)\n#define isconstant(s) ((s)->flags&0x1)\n#define iskeyword(s) ((s)->flags&0x2)\n#define symbol_value(s) (((symbol_t*)ptr(s))->binding)\n#ifdef MEMDEBUG2\n#define ismanaged(ctx, v) (!issymbol(v) && !isfixnum(v) && ((v)>(N_OPCODES<<3)) && !iscbuiltin(ctx, v))\n#else\n#define ismanaged(ctx, v) ((((unsigned char*)ptr(v)) >= ctx->fromspace) && \\\n                           (((unsigned char*)ptr(v)) < ctx->fromspace + ctx->heapsize))\n#endif\n#define isgensym(ctx, x)  (issymbol(x) && ismanaged(ctx, x))\n\n#define isfunction(x) (tag(x) == TAG_FUNCTION && (x) > (N_BUILTINS<<3))\n#define isclosure(x) isfunction(x)\n#define iscbuiltin(ctx, x) (iscvalue(x) && (cv_class((cvalue_t*)ptr(x))==ctx->builtintype))\n\nvoid fl_gc_handle(fl_context_t *fl_ctx, value_t *pv) JL_NOTSAFEPOINT;\nvoid fl_free_gc_handles(fl_context_t *fl_ctx, uint32_t n) JL_NOTSAFEPOINT;\n\n#include \"opcodes.h\"\n\n// utility for iterating over all arguments in a builtin\n// i=index, i0=start index, arg = var for each arg, args = arg array\n// assumes \"nargs\" is the argument count\n#define FOR_ARGS(i, i0, arg, args)     \\\n    for(i=i0; ((size_t)i)<nargs && ((arg=args[i]) || 1); i++)\n\n#define N_BUILTINS ((int)N_OPCODES)\n\n#define FL_UNSPECIFIED(fl_ctx) fl_ctx->T\n\n/* read, eval, print main entry points */\nvalue_t fl_read_sexpr(fl_context_t *fl_ctx, value_t f);\nvoid fl_print(fl_context_t *fl_ctx, ios_t *f, value_t v);\nvalue_t fl_toplevel_eval(fl_context_t *fl_ctx, value_t expr);\nvalue_t fl_apply(fl_context_t *fl_ctx, value_t f, value_t l) JL_NOTSAFEPOINT;\nvalue_t fl_applyn(fl_context_t *fl_ctx, uint32_t n, value_t f, ...) JL_NOTSAFEPOINT;\n\n/* object model manipulation */\nvalue_t fl_cons(fl_context_t *fl_ctx, value_t a, value_t b) JL_NOTSAFEPOINT;\nvalue_t fl_list2(fl_context_t *fl_ctx, value_t a, value_t b) JL_NOTSAFEPOINT;\nvalue_t fl_listn(fl_context_t *fl_ctx, size_t n, ...) JL_NOTSAFEPOINT;\nvalue_t symbol(fl_context_t *fl_ctx, const char *str) JL_NOTSAFEPOINT;\nchar *symbol_name(fl_context_t *fl_ctx, value_t v);\nint fl_is_keyword_name(const char *str, size_t len);\nvalue_t alloc_vector(fl_context_t *fl_ctx, size_t n, int init);\nsize_t llength(value_t v);\nvalue_t fl_compare(fl_context_t *fl_ctx, value_t a, value_t b);  // -1, 0, or 1\nvalue_t fl_equal(fl_context_t *fl_ctx, value_t a, value_t b);    // T or nil\nint equal_lispvalue(fl_context_t *fl_ctx, value_t a, value_t b);\nuintptr_t hash_lispvalue(fl_context_t *fl_ctx, value_t a);\nint isnumtok_base(fl_context_t *fl_ctx, char *tok, value_t *pval, int base);\n\n/* safe casts */\ncons_t *tocons(fl_context_t *fl_ctx, value_t v, const char *fname);\nsymbol_t *tosymbol(fl_context_t *fl_ctx, value_t v, const char *fname);\nfixnum_t tofixnum(fl_context_t *fl_ctx, value_t v, const char *fname);\nchar *tostring(fl_context_t *fl_ctx, value_t v, const char *fname);\n\n/* error handling */\n#if defined(_OS_WINDOWS_)\n#define fl_jmp_buf jmp_buf\n#if defined(_COMPILER_GCC_)\nint __attribute__ ((__nothrow__,__returns_twice__)) (jl_setjmp)(jmp_buf _Buf);\n__declspec(noreturn) __attribute__ ((__nothrow__)) void (jl_longjmp)(jmp_buf _Buf, int _Value);\n#else\nint (jl_setjmp)(jmp_buf _Buf);\nvoid (jl_longjmp)(jmp_buf _Buf, int _Value);\n#endif\n#define fl_setjmp(a) (jl_setjmp)((a))\n#define fl_longjmp(a, b) (jl_longjmp)((a), (b))\n#else // !_OS_WINDOWS_\n#define fl_jmp_buf sigjmp_buf\n#define fl_setjmp(a) sigsetjmp((a), 0)\n#define fl_longjmp(a, b) siglongjmp((a), (b))\n#endif\n\ntypedef struct _ectx_t {\n    fl_jmp_buf buf;\n    uint32_t sp;\n    uint32_t frame;\n    uint32_t ngchnd;\n    void *rdst;\n    struct _ectx_t *prev;\n} fl_exception_context_t;\n\n#define FL_TRY_EXTERN(fl_ctx)                                           \\\n  fl_exception_context_t _ctx; int l__tr, l__ca;                        \\\n  fl_savestate(fl_ctx, &_ctx); fl_ctx->exc_ctx = &_ctx;                      \\\n  if (!fl_setjmp(_ctx.buf))                                                \\\n      for (l__tr=1; l__tr; l__tr=0, (void)(fl_ctx->exc_ctx=fl_ctx->exc_ctx->prev))\n\n#define FL_CATCH_EXTERN(fl_ctx)                                         \\\n    else                                                                \\\n        for(l__ca=1; l__ca; l__ca=0, fl_restorestate(fl_ctx, &_ctx))\n\n#if defined(_OS_WINDOWS_)\n__declspec(noreturn) void lerrorf(fl_context_t *fl_ctx, value_t e, const char *format, ...);\n__declspec(noreturn) void lerror(fl_context_t *fl_ctx, value_t e, const char *msg) JL_NOTSAFEPOINT;\n__declspec(noreturn) void fl_raise(fl_context_t *fl_ctx, value_t e);\n__declspec(noreturn) void type_error(fl_context_t *fl_ctx, const char *fname, const char *expected, value_t got);\n__declspec(noreturn) void bounds_error(fl_context_t *fl_ctx, const char *fname, value_t arr, value_t ind);\n#else\nvoid lerrorf(fl_context_t *fl_ctx, value_t e, const char *format, ...) __attribute__ ((__noreturn__));\nvoid lerror(fl_context_t *fl_ctx, value_t e, const char *msg) __attribute__((__noreturn__)) JL_NOTSAFEPOINT;\nvoid fl_raise(fl_context_t *fl_ctx, value_t e) __attribute__ ((__noreturn__));\nvoid type_error(fl_context_t *fl_ctx, const char *fname, const char *expected, value_t got) __attribute__ ((__noreturn__));\nvoid bounds_error(fl_context_t *fl_ctx, const char *fname, value_t arr, value_t ind) __attribute__ ((__noreturn__));\n#endif\n\nvoid fl_savestate(fl_context_t *fl_ctx, fl_exception_context_t *_ctx);\nvoid fl_restorestate(fl_context_t *fl_ctx, fl_exception_context_t *_ctx);\n\ntypedef struct {\n    void (*print)(fl_context_t *fl_ctx, value_t self, ios_t *f);\n    void (*relocate)(fl_context_t *fl_ctx, value_t oldv, value_t newv);\n    void (*finalize)(fl_context_t *fl_ctx, value_t self);\n    void (*print_traverse)(fl_context_t *fl_ctx, value_t self);\n} cvtable_t;\n\n/* functions needed to implement the value interface (cvtable_t) */\nvalue_t relocate_lispvalue(fl_context_t *fl_ctx, value_t v);\nvoid print_traverse(fl_context_t *fl_ctx, value_t v);\nvoid fl_print_chr(fl_context_t *fl_ctx, char c, ios_t *f);\nvoid fl_print_str(fl_context_t *fl_ctx, const char *s, ios_t *f);\nvoid fl_print_child(fl_context_t *fl_ctx, ios_t *f, value_t v);\n\ntypedef int (*cvinitfunc_t)(fl_context_t *fl_ctx, struct _fltype_t*, value_t, void*);\n\ntypedef struct _fltype_t {\n    value_t type;\n    numerictype_t numtype;\n    size_t size;\n    size_t elsz;\n    const cvtable_t *vtable;\n    struct _fltype_t *eltype;  // for arrays\n    struct _fltype_t *artype;  // (array this)\n    int marked;\n    cvinitfunc_t init;\n} fltype_t;\n\nJL_EXTENSION typedef struct {\n    fltype_t *type;\n    void *data;\n    size_t len;            // length of *data in bytes\n    union {\n        value_t parent;    // optional\n        char _space[1];    // variable size\n    };\n} cvalue_t;\n\n#define CVALUE_NWORDS 4\n\ntypedef struct {\n    fltype_t *type;\n    char _space[1];\n} cprim_t;\n\ntypedef struct {\n    value_t bcode;\n    value_t vals;\n    value_t env;\n    value_t name;\n} function_t;\n\n#define CPRIM_NWORDS 2\n#define MAX_INL_SIZE 384\n\n#define CV_OWNED_BIT  0x1\n#define CV_PARENT_BIT 0x2\n#define owned(cv)      ((uintptr_t)(cv)->type & CV_OWNED_BIT)\n#define hasparent(cv)  ((uintptr_t)(cv)->type & CV_PARENT_BIT)\n#define isinlined(cv)  ((cv)->data == &(cv)->_space[0])\n#define cv_class(cv)   ((fltype_t*)(((uintptr_t)(cv)->type)&~3))\n#define cv_len(cv)     ((cv)->len)\n#define cv_type(cv)    (cv_class(cv)->type)\n#define cv_data(cv)    ((cv)->data)\n#define cv_isstr(fl_ctx, cv)   (cv_class(cv)->eltype == fl_ctx->bytetype)\n#define cv_isPOD(cv)   (cv_class(cv)->init != NULL)\n\n#define cvalue_data(v) cv_data((cvalue_t*)ptr(v))\n#define cvalue_len(v) cv_len((cvalue_t*)ptr(v))\n#define value2c(type, v) ((type)cv_data((cvalue_t*)ptr(v)))\n\n#define valid_numtype(v) ((v) < N_NUMTYPES)\n#define cp_class(cp)   ((cp)->type)\n#define cp_type(cp)    (cp_class(cp)->type)\n#define cp_numtype(cp) (cp_class(cp)->numtype)\n#define cp_data(cp)    (&(cp)->_space[0])\n\n// WARNING: multiple evaluation!\n#define cptr(v) \\\n    (iscprim(v) ? cp_data((cprim_t*)ptr(v)) : cv_data((cvalue_t*)ptr(v)))\n\n/* C type names corresponding to cvalues type names */\ntypedef int8_t   fl_int8_t;\ntypedef uint8_t  fl_uint8_t;\ntypedef int16_t  fl_int16_t;\ntypedef uint16_t fl_uint16_t;\ntypedef int32_t  fl_int32_t;\ntypedef uint32_t fl_uint32_t;\ntypedef int64_t  fl_int64_t;\ntypedef uint64_t fl_uint64_t;\ntypedef char     fl_char_t;\ntypedef char     char_t;\ntypedef ptrdiff_t fl_ptrdiff_t;\ntypedef size_t   fl_size_t;\ntypedef double   fl_double_t;\ntypedef float    fl_float_t;\n\ntypedef value_t (*builtin_t)(fl_context_t*, value_t*, uint32_t);\n\nvalue_t cvalue(fl_context_t *fl_ctx, fltype_t *type, size_t sz) JL_NOTSAFEPOINT;\nvoid add_finalizer(fl_context_t *fl_ctx, cvalue_t *cv);\nvoid cv_autorelease(fl_context_t *fl_ctx, cvalue_t *cv);\nvoid cv_pin(fl_context_t *fl_ctx, cvalue_t *cv);\nsize_t ctype_sizeof(fl_context_t *fl_ctx, value_t type, int *palign);\nvalue_t cvalue_copy(fl_context_t *fl_ctx, value_t v);\nvalue_t cvalue_from_data(fl_context_t *fl_ctx, fltype_t *type, void *data, size_t sz);\nvalue_t cvalue_from_ref(fl_context_t *fl_ctx, fltype_t *type, void *ptr, size_t sz, value_t parent);\nvalue_t cbuiltin(fl_context_t *fl_ctx, const char *name, builtin_t f);\nsize_t cvalue_arraylen(value_t v);\nvalue_t size_wrap(fl_context_t *fl_ctx, size_t sz);\nsize_t tosize(fl_context_t *fl_ctx, value_t n, const char *fname);\nvalue_t cvalue_string(fl_context_t *fl_ctx, size_t sz);\nvalue_t cvalue_static_cstrn(fl_context_t *fl_ctx, const char *str, size_t n);\nvalue_t cvalue_static_cstring(fl_context_t *fl_ctx, const char *str);\nvalue_t string_from_cstr(fl_context_t *fl_ctx, char *str);\nvalue_t string_from_cstrn(fl_context_t *fl_ctx, char *str, size_t n);\nint fl_isstring(fl_context_t *fl_ctx, value_t v);\nint fl_isnumber(fl_context_t *fl_ctx, value_t v);\nint fl_isgensym(fl_context_t *fl_ctx, value_t v);\nint fl_isiostream(fl_context_t *fl_ctx, value_t v);\nios_t *fl_toiostream(fl_context_t *fl_ctx, value_t v, const char *fname);\nvalue_t cvalue_compare(value_t a, value_t b);\nint numeric_compare(fl_context_t *fl_ctx, value_t a, value_t b, int eq, int eqnans, char *fname);\n\nvoid to_sized_ptr(fl_context_t *fl_ctx, value_t v, const char *fname, char **pdata, size_t *psz);\n\nfltype_t *get_type(fl_context_t *fl_ctx, value_t t);\nfltype_t *get_array_type(fl_context_t *fl_ctx, value_t eltype);\nfltype_t *define_opaque_type(value_t sym, size_t sz, const cvtable_t *vtab,\n                             cvinitfunc_t init) JL_NOTSAFEPOINT;\n\nvalue_t mk_double(fl_context_t *fl_ctx, fl_double_t n);\nvalue_t mk_float(fl_context_t *fl_ctx, fl_float_t n);\nvalue_t mk_uint32(fl_context_t *fl_ctx, uint32_t n);\nvalue_t mk_uint64(fl_context_t *fl_ctx, uint64_t n);\nvalue_t mk_wchar(fl_context_t *fl_ctx, int32_t n);\nvalue_t return_from_uint64(fl_context_t *fl_ctx, uint64_t Uaccum);\nvalue_t return_from_int64(fl_context_t *fl_ctx, int64_t Saccum);\n\ntypedef struct {\n    const char *name;\n    builtin_t fptr;\n} builtinspec_t;\n\nvoid assign_global_builtins(fl_context_t *fl_ctx, const builtinspec_t *b) JL_NOTSAFEPOINT;\n\n/* builtins */\nvalue_t fl_hash(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nvalue_t cvalue_byte(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nvalue_t cvalue_wchar(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\n\nvoid fl_init(fl_context_t *fl_ctx, size_t initial_heapsize) JL_NOTSAFEPOINT;\nint fl_load_system_image(fl_context_t *fl_ctx, value_t ios);\nint fl_load_system_image_str(fl_context_t *fl_ctx, char* str, size_t len) JL_NOTSAFEPOINT;\n\n/* julia extensions */\nJL_DLLEXPORT int jl_id_char(uint32_t wc);\nJL_DLLEXPORT int jl_id_start_char(uint32_t wc);\nJL_DLLEXPORT int jl_op_suffix_char(uint32_t wc);\n\nstruct _fl_context_t {\n    symbol_t *symtab;\n    value_t NIL, T, F, FL_EOF, QUOTE;\n    value_t int8sym, uint8sym, int16sym, uint16sym, int32sym, uint32sym;\n    value_t int64sym, uint64sym;\n\n    value_t ptrdiffsym, sizesym, bytesym, wcharsym;\n    value_t floatsym, doublesym;\n    value_t stringtypesym, wcstringtypesym;\n    value_t emptystringsym;\n\n    value_t arraysym, cfunctionsym, voidsym, pointersym;\n\n    htable_t TypeTable;\n    htable_t reverse_dlsym_lookup_table;\n\n    fltype_t *int8type, *uint8type;\n    fltype_t *int16type, *uint16type;\n    fltype_t *int32type, *uint32type;\n    fltype_t *int64type, *uint64type;\n    fltype_t *ptrdifftype, *sizetype;\n    fltype_t *floattype, *doubletype;\n    fltype_t *bytetype, *wchartype;\n    fltype_t *stringtype, *wcstringtype;\n    fltype_t *builtintype;\n\n    htable_t equal_eq_hashtable;\n\n    value_t tablesym;\n    fltype_t *tabletype;\n    cvtable_t table_vtable;\n\n    uint32_t readtoktype;\n    value_t readtokval;\n    char readbuf[256];\n\n    htable_t printconses;\n    uint32_t printlabel;\n    int print_pretty;\n    int print_princ;\n    fixnum_t print_length;\n    fixnum_t print_level;\n    fixnum_t P_LEVEL;\n    int SCR_WIDTH;\n    int HPOS, VPOS;\n\n    value_t iostreamsym, rdsym, wrsym, apsym, crsym, truncsym;\n    value_t instrsym, outstrsym;\n    fltype_t *iostreamtype;\n\n    size_t malloc_pressure;\n    cvalue_t **Finalizers;\n    size_t nfinalizers;\n    size_t maxfinalizers;\n\n    uint32_t N_STACK;\n    value_t *Stack;\n    uint32_t SP;\n    uint32_t curr_frame;\n\n#define FL_N_GC_HANDLES 8192\n    value_t *GCHandleStack[FL_N_GC_HANDLES];\n    uint32_t N_GCHND;\n\n    value_t IOError, ParseError, TypeError, ArgError, UnboundError, KeyError;\n    value_t OutOfMemoryError, DivideError, BoundsError, EnumerationError;\n    value_t printwidthsym, printreadablysym, printprettysym, printlengthsym;\n    value_t printlevelsym, builtins_table_sym;\n\n    value_t LAMBDA, IF, TRYCATCH;\n    value_t BACKQUOTE, COMMA, COMMAAT, COMMADOT, FUNCTION;\n\n    value_t pairsym, symbolsym, fixnumsym, vectorsym, builtinsym, vu8sym;\n    value_t definesym, defmacrosym, forsym, setqsym;\n    value_t tsym, Tsym, fsym, Fsym, booleansym, nullsym, evalsym, fnsym;\n    // for reading characters\n    value_t nulsym, alarmsym, backspacesym, tabsym, linefeedsym, newlinesym;\n    value_t vtabsym, pagesym, returnsym, escsym, spacesym, deletesym;\n\n    struct _fl_readstate_t *readstate;\n\n    unsigned char *fromspace;\n    unsigned char *tospace;\n    unsigned char *curheap;\n    unsigned char *lim;\n    size_t heapsize;//bytes\n    uint32_t *consflags;\n\n    // error utilities --------------------------------------------------\n\n    // saved execution state for an unwind target\n    fl_exception_context_t *exc_ctx;\n    uint32_t throwing_frame;  // active frame when exception was thrown\n    value_t lasterror;\n\n    uint32_t gensym_ctr;\n    // two static buffers for gensym printing so there can be two\n    // gensym names available at a time, mostly for compare()\n    char gsname[2][16];\n    int gsnameno;\n\n    void *tochain;\n    long long n_allocd;\n\n    value_t the_empty_vector;\n    value_t memory_exception_value;\n\n    int gc_grew;\n    cons_t *apply_c;\n    value_t *apply_pv;\n    int64_t apply_accum;\n    value_t apply_func, apply_v, apply_e;\n\n    value_t jl_sym;\n    // persistent buffer (avoid repeated malloc/free)\n    // for julia_extensions.c: normalize\n    size_t jlbuflen;\n    void *jlbuf;\n};\n\nstatic inline void argcount(fl_context_t *fl_ctx, const char *fname, uint32_t nargs, uint32_t c)\n{\n    if (__unlikely(nargs != c))\n        lerrorf(fl_ctx, fl_ctx->ArgError,\"%s: too %s arguments\", fname, nargs<c ? \"few\":\"many\");\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/src/flisp/cvalues.c": "#ifdef _P64\n#define NWORDS(sz) (((sz)+7)>>3)\n#else\n#define NWORDS(sz) (((sz)+3)>>2)\n#endif\n\nstruct prim_int16{ char a; int16_t i; };\nstruct prim_int32{ char a; int32_t i; };\nstruct prim_int64{ char a; int64_t i; };\nstruct prim_ptr{ char a;  void   *i; };\n\n// compute struct field alignment required for primitives\nstatic const int ALIGN2   = sizeof(struct prim_int16) - 2;\nstatic const int ALIGN4   = sizeof(struct prim_int32) - 4;\nstatic const int ALIGN8   = sizeof(struct prim_int64) - 8;\nstatic const int ALIGNPTR = sizeof(struct prim_ptr) - sizeof(void*);\n\nstatic void cvalue_init(fl_context_t *fl_ctx, fltype_t *type, value_t v, void *dest);\n\n// cvalues-specific builtins\nvalue_t cvalue_new(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nvalue_t cvalue_sizeof(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nvalue_t cvalue_typeof(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\n\n// trigger unconditional GC after this many bytes are allocated\n#define ALLOC_LIMIT_TRIGGER 67108864\n\nvoid add_finalizer(fl_context_t *fl_ctx, cvalue_t *cv)\n{\n    if (fl_ctx->nfinalizers == fl_ctx->maxfinalizers) {\n        size_t nn = (fl_ctx->maxfinalizers==0 ? 256 : fl_ctx->maxfinalizers*2);\n        cvalue_t **temp = (cvalue_t**)realloc(fl_ctx->Finalizers, nn*sizeof(value_t));\n        if (temp == NULL)\n            lerror(fl_ctx, fl_ctx->OutOfMemoryError, \"out of memory\");\n        fl_ctx->Finalizers = temp;\n        fl_ctx->maxfinalizers = nn;\n    }\n    fl_ctx->Finalizers[fl_ctx->nfinalizers++] = cv;\n}\n\n// remove dead objects from finalization list in-place\nstatic void sweep_finalizers(fl_context_t *fl_ctx)\n{\n    cvalue_t **lst = fl_ctx->Finalizers;\n    size_t n=0, ndel=0, l=fl_ctx->nfinalizers;\n    cvalue_t *tmp;\n#define SWAP_sf(a,b) (tmp=a,a=b,b=tmp,1)\n    if (l == 0)\n        return;\n    do {\n        tmp = lst[n];\n        if (isforwarded((value_t)tmp)) {\n            // object is alive\n            lst[n] = (cvalue_t*)ptr(forwardloc((value_t)tmp));\n            n++;\n        }\n        else {\n            fltype_t *t = cv_class(tmp);\n            if (t->vtable != NULL && t->vtable->finalize != NULL) {\n                t->vtable->finalize(fl_ctx, tagptr(tmp, TAG_CVALUE));\n            }\n            if (!isinlined(tmp) && owned(tmp)) {\n#ifdef DEBUG\n                memset(cv_data(tmp), 0xbb, cv_len(tmp));\n#endif\n                free(cv_data(tmp));\n            }\n            ndel++;\n        }\n    } while ((n < l-ndel) && SWAP_sf(lst[n],lst[n+ndel]));\n\n    fl_ctx->nfinalizers -= ndel;\n#ifdef VERBOSEGC\n    if (ndel > 0)\n        printf(\"GC: finalized %d objects\\n\", ndel);\n#endif\n\n    fl_ctx->malloc_pressure = 0;\n}\n\n// compute the size of the metadata object for a cvalue\nstatic size_t cv_nwords(fl_context_t *fl_ctx, cvalue_t *cv)\n{\n    if (isinlined(cv)) {\n        size_t n = cv_len(cv);\n        if (n==0 || cv_isstr(fl_ctx, cv))\n            n++;\n        return CVALUE_NWORDS - 1 + NWORDS(n);\n    }\n    return CVALUE_NWORDS;\n}\n\nstatic void autorelease(fl_context_t *fl_ctx, cvalue_t *cv)\n{\n    cv->type = (fltype_t*)(((uintptr_t)cv->type) | CV_OWNED_BIT);\n    add_finalizer(fl_ctx, cv);\n}\n\nvoid cv_autorelease(fl_context_t *fl_ctx, cvalue_t *cv)\n{\n    autorelease(fl_ctx, cv);\n}\n\nstatic value_t cprim(fl_context_t *fl_ctx, fltype_t *type, size_t sz)\n{\n    cprim_t *pcp = (cprim_t*)alloc_words(fl_ctx, CPRIM_NWORDS-1+NWORDS(sz));\n    pcp->type = type;\n    return tagptr(pcp, TAG_CPRIM);\n}\n\nvalue_t cvalue(fl_context_t *fl_ctx, fltype_t *type, size_t sz)\n{\n    cvalue_t *pcv;\n    int str=0;\n\n    if (valid_numtype(type->numtype)) {\n        return cprim(fl_ctx, type, sz);\n    }\n    if (type->eltype == fl_ctx->bytetype) {\n        if (sz == 0)\n            return symbol_value(fl_ctx->emptystringsym);\n        sz++;\n        str=1;\n    }\n    if (sz <= MAX_INL_SIZE) {\n        size_t nw = CVALUE_NWORDS - 1 + NWORDS(sz) + (sz==0 ? 1 : 0);\n        pcv = (cvalue_t*)alloc_words(fl_ctx, nw);\n        pcv->type = type;\n        pcv->data = &pcv->_space[0];\n        if (type->vtable != NULL && type->vtable->finalize != NULL)\n            add_finalizer(fl_ctx, pcv);\n    }\n    else {\n        if (fl_ctx->malloc_pressure > ALLOC_LIMIT_TRIGGER)\n            gc(fl_ctx, 0);\n        pcv = (cvalue_t*)alloc_words(fl_ctx, CVALUE_NWORDS);\n        pcv->type = type;\n        pcv->data = malloc(sz);\n        // TODO: if pcv->data == NULL\n        autorelease(fl_ctx, pcv);\n        fl_ctx->malloc_pressure += sz;\n    }\n    if (str) {\n        sz--;\n        ((char*)pcv->data)[sz] = '\\0';\n    }\n    pcv->len = sz;\n    return tagptr(pcv, TAG_CVALUE);\n}\n\nvalue_t cvalue_from_data(fl_context_t *fl_ctx, fltype_t *type, void *data, size_t sz)\n{\n    value_t cv;\n    cv = cvalue(fl_ctx, type, sz);\n    memcpy(cptr(cv), data, sz);\n    return cv;\n}\n\n// this effectively dereferences a pointer\n// just like *p in C, it only removes a level of indirection from the type,\n// it doesn't copy any data.\n// this method of creating a cvalue only allocates metadata.\n// ptr is user-managed; we don't autorelease it unless the\n// user explicitly calls (autorelease ) on the result of this function.\n// 'parent' is an optional cvalue that this pointer is known to point\n// into; fl_ctx->NIL if none.\nvalue_t cvalue_from_ref(fl_context_t *fl_ctx, fltype_t *type, void *ptr, size_t sz, value_t parent)\n{\n    cvalue_t *pcv;\n    value_t cv;\n\n    pcv = (cvalue_t*)alloc_words(fl_ctx, CVALUE_NWORDS);\n    pcv->data = ptr;\n    pcv->len = sz;\n    pcv->type = type;\n    if (parent != fl_ctx->NIL) {\n        pcv->type = (fltype_t*)(((uintptr_t)pcv->type) | CV_PARENT_BIT);\n        pcv->parent = parent;\n    }\n    cv = tagptr(pcv, TAG_CVALUE);\n    return cv;\n}\n\nvalue_t cvalue_string(fl_context_t *fl_ctx, size_t sz)\n{\n    return cvalue(fl_ctx, fl_ctx->stringtype, sz);\n}\n\nvalue_t cvalue_static_cstrn(fl_context_t *fl_ctx, const char *str, size_t n)\n{\n    return cvalue_from_ref(fl_ctx, fl_ctx->stringtype, (char*)str, n, fl_ctx->NIL);\n}\n\nvalue_t cvalue_static_cstring(fl_context_t *fl_ctx, const char *str)\n{\n    return cvalue_static_cstrn(fl_ctx, str, strlen(str));\n}\n\nvalue_t string_from_cstrn(fl_context_t *fl_ctx, char *str, size_t n)\n{\n    value_t v = cvalue_string(fl_ctx, n);\n    memcpy(cvalue_data(v), str, n);\n    return v;\n}\n\nvalue_t string_from_cstr(fl_context_t *fl_ctx, char *str)\n{\n    return string_from_cstrn(fl_ctx, str, strlen(str));\n}\n\nint fl_isstring(fl_context_t *fl_ctx, value_t v)\n{\n    return (iscvalue(v) && cv_isstr(fl_ctx, (cvalue_t*)ptr(v)));\n}\n\n// convert to malloc representation (fixed address)\nvoid cv_pin(fl_context_t *fl_ctx, cvalue_t *cv)\n{\n    if (!isinlined(cv))\n        return;\n    size_t sz = cv_len(cv);\n    if (cv_isstr(fl_ctx, cv)) sz++;\n    void *data = malloc(sz);\n    // TODO: if data == NULL\n    memcpy(data, cv_data(cv), sz);\n    cv->data = data;\n    autorelease(fl_ctx, cv);\n}\n\n#define num_init(ctype, cnvt, tag)                                     \\\nstatic int cvalue_##ctype##_init(fl_context_t *fl_ctx, fltype_t *type, \\\n                                 value_t arg, void *dest)              \\\n{                                                                      \\\n    fl_##ctype##_t n=0;                                                \\\n    (void)type;                                                        \\\n    if (isfixnum(arg)) {                                               \\\n        n = numval(arg);                                               \\\n    }                                                                  \\\n    else if (iscprim(arg)) {                                           \\\n        cprim_t *cp = (cprim_t*)ptr(arg);                              \\\n        void *p = cp_data(cp);                                         \\\n        n = (fl_##ctype##_t)conv_to_##cnvt(p, cp_numtype(cp));         \\\n    }                                                                  \\\n    else {                                                             \\\n        return 1;                                                      \\\n    }                                                                  \\\n    memcpy(jl_assume_aligned(dest, sizeof(void*)), &n,                 \\\n            sizeof(fl_##ctype##_t));                                   \\\n    return 0;                                                          \\\n}\nnum_init(int8, int32, T_INT8)\nnum_init(uint8, uint32, T_UINT8)\nnum_init(int16, int32, T_INT16)\nnum_init(uint16, uint32, T_UINT16)\nnum_init(int32, int32, T_INT32)\nnum_init(uint32, uint32, T_UINT32)\nnum_init(int64, int64, T_INT64)\nnum_init(uint64, uint64, T_UINT64)\nnum_init(float, double, T_FLOAT)\nnum_init(double, double, T_DOUBLE)\n\n#define num_ctor_init(typenam, ctype, tag)                              \\\nvalue_t cvalue_##typenam(fl_context_t *fl_ctx, value_t *args, uint32_t nargs) \\\n{                                                                       \\\n    if (nargs==0) { PUSH(fl_ctx, fixnum(0)); args = &fl_ctx->Stack[fl_ctx->SP-1]; } \\\n    value_t cp = cprim(fl_ctx, fl_ctx->typenam##type, sizeof(fl_##ctype##_t)); \\\n    if (cvalue_##ctype##_init(fl_ctx, fl_ctx->typenam##type,            \\\n                              args[0], cp_data((cprim_t*)ptr(cp))))     \\\n        type_error(fl_ctx, #typenam, \"number\", args[0]);                \\\n    return cp;                                                          \\\n}\n\n#define num_ctor_ctor(typenam, ctype, tag)                              \\\nvalue_t mk_##typenam(fl_context_t *fl_ctx, fl_##ctype##_t n)            \\\n{                                                                       \\\n    value_t cp = cprim(fl_ctx, fl_ctx->typenam##type, sizeof(fl_##ctype##_t)); \\\n    *(fl_##ctype##_t*)cp_data((cprim_t*)ptr(cp)) = n;                   \\\n    return cp;                                                          \\\n}\n\n#define num_ctor(typenam, ctype, tag)  \\\n    num_ctor_init(typenam, ctype, tag) \\\n    num_ctor_ctor(typenam, ctype, tag)\n\nnum_ctor(int8, int8, T_INT8)\nnum_ctor(uint8, uint8, T_UINT8)\nnum_ctor(int16, int16, T_INT16)\nnum_ctor(uint16, uint16, T_UINT16)\nnum_ctor(int32, int32, T_INT32)\nnum_ctor(uint32, uint32, T_UINT32)\nnum_ctor(int64, int64, T_INT64)\nnum_ctor(uint64, uint64, T_UINT64)\nnum_ctor(byte,  uint8, T_UINT8)\nnum_ctor(wchar, int32, T_INT32)\n#ifdef _P64\nnum_ctor(ptrdiff, int64, T_INT64)\nnum_ctor(size, uint64, T_UINT64)\n#else\nnum_ctor(ptrdiff, int32, T_INT32)\nnum_ctor(size, uint32, T_UINT32)\n#endif\nnum_ctor(float, float, T_FLOAT)\nnum_ctor(double, double, T_DOUBLE)\n\nvalue_t size_wrap(fl_context_t *fl_ctx, size_t sz)\n{\n    if (fits_fixnum(sz))\n        return fixnum(sz);\n    assert(sizeof(void*) == sizeof(size_t));\n    return mk_size(fl_ctx, sz);\n}\n\nsize_t tosize(fl_context_t *fl_ctx, value_t n, const char *fname)\n{\n    if (isfixnum(n))\n        return numval(n);\n    if (iscprim(n)) {\n        cprim_t *cp = (cprim_t*)ptr(n);\n        return conv_to_size(cp_data(cp), cp_numtype(cp));\n    }\n    type_error(fl_ctx, fname, \"number\", n);\n    return 0;\n}\n\nstatic int isarray(value_t v)\n{\n    return iscvalue(v) && cv_class((cvalue_t*)ptr(v))->eltype != NULL;\n}\n\nstatic size_t predict_arraylen(fl_context_t *fl_ctx, value_t arg)\n{\n    if (isvector(arg))\n        return vector_size(arg);\n    else if (iscons(arg))\n        return llength(arg);\n    else if (arg == fl_ctx->NIL)\n        return 0;\n    if (isarray(arg))\n        return cvalue_arraylen(arg);\n    return 1;\n}\n\nstatic int cvalue_array_init(fl_context_t *fl_ctx, fltype_t *ft, value_t arg, void *dest)\n{\n    value_t type = ft->type;\n    size_t elsize, i, cnt, sz;\n    fltype_t *eltype = ft->eltype;\n\n    elsize = ft->elsz;\n    cnt = predict_arraylen(fl_ctx, arg);\n\n    if (iscons(cdr_(cdr_(type)))) {\n        size_t tc = tosize(fl_ctx, car_(cdr_(cdr_(type))), \"array\");\n        if (tc != cnt)\n            lerror(fl_ctx, fl_ctx->ArgError, \"array: size mismatch\");\n    }\n\n    sz = elsize * cnt;\n\n    if (isvector(arg)) {\n        for(i=0; i < cnt; i++) {\n            cvalue_init(fl_ctx, eltype, vector_elt(arg,i), dest);\n            dest = (char *)dest + elsize;\n        }\n        return 0;\n    }\n    else if (iscons(arg) || arg==fl_ctx->NIL) {\n        i = 0;\n        while (iscons(arg)) {\n            if (i == cnt) { i++; break; } // trigger error\n            cvalue_init(fl_ctx, eltype, car_(arg), dest);\n            i++;\n            dest = (char *)dest + elsize;\n            arg = cdr_(arg);\n        }\n        if (i != cnt)\n            lerror(fl_ctx, fl_ctx->ArgError, \"array: size mismatch\");\n        return 0;\n    }\n    else if (iscvalue(arg)) {\n        cvalue_t *cv = (cvalue_t*)ptr(arg);\n        if (isarray(arg)) {\n            fltype_t *aet = cv_class(cv)->eltype;\n            if (aet == eltype) {\n                if (cv_len(cv) == sz)\n                    memcpy(dest, cv_data(cv), sz);\n                else\n                    lerror(fl_ctx, fl_ctx->ArgError, \"array: size mismatch\");\n                return 0;\n            }\n            else {\n                // TODO: initialize array from different type elements\n                lerror(fl_ctx, fl_ctx->ArgError, \"array: element type mismatch\");\n            }\n        }\n    }\n    if (cnt == 1)\n        cvalue_init(fl_ctx, eltype, arg, dest);\n    else\n        type_error(fl_ctx, \"array\", \"sequence\", arg);\n    return 0;\n}\n\nvalue_t cvalue_array(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    size_t elsize, cnt, sz, i;\n    value_t arg;\n\n    if (nargs < 1)\n        argcount(fl_ctx, \"array\", nargs, 1);\n\n    cnt = nargs - 1;\n    fltype_t *type = get_array_type(fl_ctx, args[0]);\n    elsize = type->elsz;\n    sz = elsize * cnt;\n\n    value_t cv = cvalue(fl_ctx, type, sz);\n    char *dest = (char*)cv_data((cvalue_t*)ptr(cv));\n    FOR_ARGS(i,1,arg,args) {\n        cvalue_init(fl_ctx, type->eltype, arg, dest);\n        dest += elsize;\n    }\n    return cv;\n}\n\n// NOTE: v must be an array\nsize_t cvalue_arraylen(value_t v)\n{\n    cvalue_t *cv = (cvalue_t*)ptr(v);\n    return cv_len(cv)/(cv_class(cv)->elsz);\n}\n\n// *palign is an output argument giving the alignment required by type\nsize_t ctype_sizeof(fl_context_t *fl_ctx, value_t type, int *palign)\n{\n    if (type == fl_ctx->int8sym || type == fl_ctx->uint8sym || type == fl_ctx->bytesym) {\n        *palign = 1;\n        return 1;\n    }\n    if (type == fl_ctx->int16sym || type == fl_ctx->uint16sym) {\n        *palign = ALIGN2;\n        return 2;\n    }\n    if (type == fl_ctx->int32sym || type == fl_ctx->uint32sym || type == fl_ctx->wcharsym ||\n        type == fl_ctx->floatsym) {\n        *palign = ALIGN4;\n        return 4;\n    }\n    if (type == fl_ctx->int64sym || type == fl_ctx->uint64sym || type == fl_ctx->doublesym) {\n        *palign = ALIGN8;\n        return 8;\n    }\n    if (type == fl_ctx->ptrdiffsym || type == fl_ctx->sizesym) {\n#ifdef _P64\n        *palign = ALIGN8;\n        return 8;\n#else\n        *palign = ALIGN4;\n        return 4;\n#endif\n    }\n    if (iscons(type)) {\n        value_t hed = car_(type);\n        if (hed == fl_ctx->pointersym || hed == fl_ctx->cfunctionsym) {\n            *palign = ALIGNPTR;\n            return sizeof(void*);\n        }\n        if (hed == fl_ctx->arraysym) {\n            value_t t = car(fl_ctx, cdr_(type));\n            if (!iscons(cdr_(cdr_(type))))\n                lerror(fl_ctx, fl_ctx->ArgError, \"sizeof: incomplete type\");\n            value_t n = car_(cdr_(cdr_(type)));\n            size_t sz = tosize(fl_ctx, n, \"sizeof\");\n            return sz * ctype_sizeof(fl_ctx, t, palign);\n        }\n    }\n    lerror(fl_ctx, fl_ctx->ArgError, \"sizeof: invalid c type\");\n    return 0;\n}\n\n// get pointer and size for any plain-old-data value\nvoid to_sized_ptr(fl_context_t *fl_ctx, value_t v, const char *fname, char **pdata, size_t *psz)\n{\n    if (iscvalue(v)) {\n        cvalue_t *pcv = (cvalue_t*)ptr(v);\n        ios_t *x = value2c(ios_t*,v);\n        if (cv_class(pcv) == fl_ctx->iostreamtype && (x->bm == bm_mem)) {\n            *pdata = x->buf;\n            *psz = (size_t)x->size;\n            return;\n        }\n        else if (cv_isPOD(pcv)) {\n            *pdata = (char*)cv_data(pcv);\n            *psz = cv_len(pcv);\n            return;\n        }\n    }\n    else if (iscprim(v)) {\n        cprim_t *pcp = (cprim_t*)ptr(v);\n        *pdata = cp_data(pcp);\n        *psz = cp_class(pcp)->size;\n        return;\n    }\n    type_error(fl_ctx, fname, \"plain-old-data\", v);\n}\n\nvalue_t cvalue_sizeof(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    argcount(fl_ctx, \"sizeof\", nargs, 1);\n    if (issymbol(args[0]) || iscons(args[0])) {\n        int a;\n        return size_wrap(fl_ctx, ctype_sizeof(fl_ctx, args[0], &a));\n    }\n    size_t n; char *data;\n    to_sized_ptr(fl_ctx, args[0], \"sizeof\", &data, &n);\n    return size_wrap(fl_ctx, n);\n}\n\nvalue_t cvalue_typeof(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    argcount(fl_ctx, \"typeof\", nargs, 1);\n    switch(tag(args[0])) {\n    case TAG_CONS: return fl_ctx->pairsym;\n    case TAG_NUM1:\n    case TAG_NUM:  return fl_ctx->fixnumsym;\n    case TAG_SYM:  return fl_ctx->symbolsym;\n    case TAG_VECTOR: return fl_ctx->vectorsym;\n    case TAG_FUNCTION:\n        if (args[0] == fl_ctx->T || args[0] == fl_ctx->F)\n            return fl_ctx->booleansym;\n        if (args[0] == fl_ctx->NIL)\n            return fl_ctx->nullsym;\n        if (args[0] == fl_ctx->FL_EOF)\n            return symbol(fl_ctx, \"eof-object\");\n        if (isbuiltin(args[0]))\n            return fl_ctx->builtinsym;\n        return fl_ctx->FUNCTION;\n    }\n    return cv_type((cvalue_t*)ptr(args[0]));\n}\n\nstatic value_t cvalue_relocate(fl_context_t *fl_ctx, value_t v)\n{\n    size_t nw;\n    cvalue_t *cv = (cvalue_t*)ptr(v);\n    cvalue_t *nv;\n    value_t ncv;\n\n    nw = cv_nwords(fl_ctx, cv);\n    nv = (cvalue_t*)alloc_words(fl_ctx, nw);\n    memcpy(nv, cv, nw*sizeof(value_t));\n    if (isinlined(cv))\n        nv->data = &nv->_space[0];\n    ncv = tagptr(nv, TAG_CVALUE);\n    fltype_t *t = cv_class(cv);\n    if (t->vtable != NULL && t->vtable->relocate != NULL)\n        t->vtable->relocate(fl_ctx, v, ncv);\n    forward(v, ncv);\n    return ncv;\n}\n\nvalue_t cvalue_copy(fl_context_t *fl_ctx, value_t v)\n{\n    assert(iscvalue(v));\n    PUSH(fl_ctx, v);\n    cvalue_t *cv = (cvalue_t*)ptr(v);\n    size_t nw = cv_nwords(fl_ctx, cv);\n    cvalue_t *ncv = (cvalue_t*)alloc_words(fl_ctx, nw);\n    v = POP(fl_ctx); cv = (cvalue_t*)ptr(v);\n    memcpy(ncv, cv, nw * sizeof(value_t));\n    if (!isinlined(cv)) {\n        size_t len = cv_len(cv);\n        if (cv_isstr(fl_ctx, cv)) len++;\n        ncv->data = malloc(len);\n        // TODO: if ncv->data == NULL\n        memcpy(ncv->data, cv_data(cv), len);\n        autorelease(fl_ctx, ncv);\n        if (hasparent(cv)) {\n            ncv->type = (fltype_t*)(((uintptr_t)ncv->type) & ~CV_PARENT_BIT);\n            ncv->parent = fl_ctx->NIL;\n        }\n    }\n    else {\n        ncv->data = &ncv->_space[0];\n    }\n\n    return tagptr(ncv, TAG_CVALUE);\n}\n\nvalue_t fl_copy(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    argcount(fl_ctx, \"copy\", nargs, 1);\n    if (iscons(args[0]) || isvector(args[0]))\n        lerror(fl_ctx, fl_ctx->ArgError, \"copy: argument must be a leaf atom\");\n    if (!iscvalue(args[0]))\n        return args[0];\n    if (!cv_isPOD((cvalue_t*)ptr(args[0])))\n        lerror(fl_ctx, fl_ctx->ArgError, \"copy: argument must be a plain-old-data type\");\n    return cvalue_copy(fl_ctx, args[0]);\n}\n\nvalue_t fl_podp(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    argcount(fl_ctx, \"plain-old-data?\", nargs, 1);\n    return (iscprim(args[0]) ||\n            (iscvalue(args[0]) && cv_isPOD((cvalue_t*)ptr(args[0])))) ?\n        fl_ctx->T : fl_ctx->F;\n}\n\nstatic void cvalue_init(fl_context_t *fl_ctx, fltype_t *type, value_t v, void *dest)\n{\n    cvinitfunc_t f=type->init;\n\n    if (f == NULL)\n        lerror(fl_ctx, fl_ctx->ArgError, \"c-value: invalid c type\");\n\n    f(fl_ctx, type, v, dest);\n}\n\nstatic numerictype_t sym_to_numtype(fl_context_t *fl_ctx, value_t type)\n{\n    if (type == fl_ctx->int8sym)\n        return T_INT8;\n    else if (type == fl_ctx->uint8sym || type == fl_ctx->bytesym)\n        return T_UINT8;\n    else if (type == fl_ctx->int16sym)\n        return T_INT16;\n    else if (type == fl_ctx->uint16sym)\n        return T_UINT16;\n#ifdef _P64\n    else if (type == fl_ctx->int32sym || type == fl_ctx->wcharsym)\n#else\n    else if (type == fl_ctx->int32sym || type == fl_ctx->wcharsym || type == fl_ctx->ptrdiffsym)\n#endif\n        return T_INT32;\n#ifdef _P64\n    else if (type == fl_ctx->uint32sym)\n#else\n    else if (type == fl_ctx->uint32sym || type == fl_ctx->sizesym)\n#endif\n        return T_UINT32;\n#ifdef _P64\n    else if (type == fl_ctx->int64sym || type == fl_ctx->ptrdiffsym)\n#else\n    else if (type == fl_ctx->int64sym)\n#endif\n        return T_INT64;\n#ifdef _P64\n    else if (type == fl_ctx->uint64sym || type == fl_ctx->sizesym)\n#else\n    else if (type == fl_ctx->uint64sym)\n#endif\n        return T_UINT64;\n    else if (type == fl_ctx->floatsym)\n        return T_FLOAT;\n    else if (type == fl_ctx->doublesym)\n        return T_DOUBLE;\n    return (numerictype_t)N_NUMTYPES;\n}\n\n// (new type . args)\n// this provides (1) a way to allocate values with a shared type for\n// efficiency, (2) a uniform interface for allocating cvalues of any\n// type, including user-defined.\nvalue_t cvalue_new(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    if (nargs < 1 || nargs > 2)\n        argcount(fl_ctx, \"c-value\", nargs, 2);\n    value_t type = args[0];\n    fltype_t *ft = get_type(fl_ctx, type);\n    value_t cv;\n    if (ft->eltype != NULL) {\n        // special case to handle incomplete array types bla[]\n        size_t elsz = ft->elsz;\n        size_t cnt;\n\n        if (iscons(cdr_(cdr_(type))))\n            cnt = tosize(fl_ctx, car_(cdr_(cdr_(type))), \"array\");\n        else if (nargs == 2)\n            cnt = predict_arraylen(fl_ctx, args[1]);\n        else\n            cnt = 0;\n        cv = cvalue(fl_ctx, ft, elsz * cnt);\n        if (nargs == 2)\n            cvalue_array_init(fl_ctx, ft, args[1], cv_data((cvalue_t*)ptr(cv)));\n    }\n    else {\n        cv = cvalue(fl_ctx, ft, ft->size);\n        if (nargs == 2)\n            cvalue_init(fl_ctx, ft, args[1], cptr(cv));\n    }\n    return cv;\n}\n\n// NOTE: this only compares lexicographically; it ignores numeric formats\nvalue_t cvalue_compare(value_t a, value_t b)\n{\n    cvalue_t *ca = (cvalue_t*)ptr(a);\n    cvalue_t *cb = (cvalue_t*)ptr(b);\n    char *adata = (char*)cv_data(ca);\n    char *bdata = (char*)cv_data(cb);\n    size_t asz = cv_len(ca);\n    size_t bsz = cv_len(cb);\n    size_t minsz = asz < bsz ? asz : bsz;\n    int diff = memcmp(adata, bdata, minsz);\n    if (diff == 0) {\n        if (asz > bsz)\n            return fixnum(1);\n        else if (asz < bsz)\n            return fixnum(-1);\n    }\n    return fixnum(diff);\n}\n\nstatic void check_addr_args(fl_context_t *fl_ctx, const char *fname, value_t arr,\n                            value_t ind, char **data, size_t *index)\n{\n    size_t numel;\n    cvalue_t *cv = (cvalue_t*)ptr(arr);\n    *data = (char*)cv_data(cv);\n    numel = cv_len(cv)/(cv_class(cv)->elsz);\n    *index = tosize(fl_ctx, ind, fname);\n    if (*index >= numel)\n        bounds_error(fl_ctx, fname, arr, ind);\n}\n\nstatic value_t cvalue_array_aref(fl_context_t *fl_ctx, value_t *args)\n{\n    char *data; size_t index;\n    fltype_t *eltype = cv_class((cvalue_t*)ptr(args[0]))->eltype;\n    value_t el = 0;\n    numerictype_t nt = eltype->numtype;\n    if (nt >= T_INT32)\n        el = cvalue(fl_ctx, eltype, eltype->size);\n    check_addr_args(fl_ctx, \"aref\", args[0], args[1], &data, &index);\n    if (nt < T_INT32) {\n        if (nt == T_INT8)\n            return fixnum((int8_t)data[index]);\n        else if (nt == T_UINT8)\n            return fixnum((uint8_t)data[index]);\n        else if (nt == T_INT16)\n            return fixnum(((int16_t*)data)[index]);\n        return fixnum(((uint16_t*)data)[index]);\n    }\n    char *dest = (char*)cptr(el);\n    size_t sz = eltype->size;\n    if (sz == 1)\n        *dest = data[index];\n    else if (sz == 2)\n        *(int16_t*)dest = ((int16_t*)data)[index];\n    else if (sz == 4)\n        *(int32_t*)dest = ((int32_t*)data)[index];\n    else if (sz == 8)\n        *(int64_t*)dest = ((int64_t*)data)[index];\n    else\n        memcpy(dest, data + index*sz, sz);\n    return el;\n}\n\nstatic value_t cvalue_array_aset(fl_context_t *fl_ctx, value_t *args)\n{\n    char *data; size_t index;\n    fltype_t *eltype = cv_class((cvalue_t*)ptr(args[0]))->eltype;\n    check_addr_args(fl_ctx, \"aset!\", args[0], args[1], &data, &index);\n    char *dest = data + index*eltype->size;\n    cvalue_init(fl_ctx, eltype, args[2], dest);\n    return args[2];\n}\n\nvalue_t fl_builtin(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    argcount(fl_ctx, \"builtin\", nargs, 1);\n    symbol_t *name = tosymbol(fl_ctx, args[0], \"builtin\");\n    cvalue_t *cv;\n    if (ismanaged(fl_ctx, args[0]) || (cv=(cvalue_t*)name->dlcache) == NULL) {\n        lerrorf(fl_ctx, fl_ctx->ArgError, \"builtin: function %s not found\", name->name);\n    }\n    return tagptr(cv, TAG_CVALUE);\n}\n\nvalue_t cbuiltin(fl_context_t *fl_ctx, const char *name, builtin_t f)\n{\n    cvalue_t *cv = (cvalue_t*)malloc(CVALUE_NWORDS * sizeof(value_t));\n    // TODO: if cv->data == NULL\n    cv->type = fl_ctx->builtintype;\n    cv->data = &cv->_space[0];\n    cv->len = sizeof(value_t);\n    *(void**)cv->data = (void*)(uintptr_t)f;\n\n    value_t sym = symbol(fl_ctx, name);\n    ((symbol_t*)ptr(sym))->dlcache = cv;\n    ptrhash_put(&fl_ctx->reverse_dlsym_lookup_table, cv, (void*)sym);\n\n    return tagptr(cv, TAG_CVALUE);\n}\n\nstatic value_t fl_logand(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nstatic value_t fl_logior(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nstatic value_t fl_logxor(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nstatic value_t fl_lognot(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nstatic value_t fl_ash(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\n\nstatic const builtinspec_t cvalues_builtin_info[] = {\n    { \"c-value\", cvalue_new },\n    { \"typeof\", cvalue_typeof },\n    { \"sizeof\", cvalue_sizeof },\n    { \"builtin\", fl_builtin },\n    { \"copy\", fl_copy },\n    { \"plain-old-data?\", fl_podp },\n\n    { \"logand\", fl_logand },\n    { \"logior\", fl_logior },\n    { \"logxor\", fl_logxor },\n    { \"lognot\", fl_lognot },\n    { \"ash\", fl_ash },\n    // todo: autorelease\n    { NULL, NULL }\n};\n\n#define cv_intern(fl_ctx, tok) fl_ctx->tok##sym = symbol(fl_ctx, #tok)\n#define ctor_cv_intern(fl_ctx, tok)                             \\\n    cv_intern(fl_ctx, tok);                                     \\\n    set(fl_ctx->tok##sym, cbuiltin(fl_ctx, #tok, cvalue_##tok))\n\n#define mk_primtype(fl_ctx, name)                               \\\n    fl_ctx->name##type = get_type(fl_ctx, fl_ctx->name##sym);   \\\n    fl_ctx->name##type->init = &cvalue_##name##_init\n\n#define mk_primtype_(fl_ctx, name, ctype)                       \\\n    fl_ctx->name##type = get_type(fl_ctx, fl_ctx->name##sym);   \\\n    fl_ctx->name##type->init = &cvalue_##ctype##_init\n\nstatic void cvalues_init(fl_context_t *fl_ctx)\n{\n    fl_ctx->malloc_pressure = 0;\n    fl_ctx->Finalizers = NULL;\n    fl_ctx->nfinalizers = 0;\n    fl_ctx->maxfinalizers = 0;\n\n    htable_new(&fl_ctx->TypeTable, 256);\n    htable_new(&fl_ctx->reverse_dlsym_lookup_table, 256);\n\n    fl_ctx->builtintype = define_opaque_type(fl_ctx->builtinsym, sizeof(builtin_t), NULL, NULL);\n\n    ctor_cv_intern(fl_ctx, int8);\n    ctor_cv_intern(fl_ctx, uint8);\n    ctor_cv_intern(fl_ctx, int16);\n    ctor_cv_intern(fl_ctx, uint16);\n    ctor_cv_intern(fl_ctx, int32);\n    ctor_cv_intern(fl_ctx, uint32);\n    ctor_cv_intern(fl_ctx, int64);\n    ctor_cv_intern(fl_ctx, uint64);\n    ctor_cv_intern(fl_ctx, byte);\n    ctor_cv_intern(fl_ctx, wchar);\n    ctor_cv_intern(fl_ctx, ptrdiff);\n    ctor_cv_intern(fl_ctx, size);\n    ctor_cv_intern(fl_ctx, float);\n    ctor_cv_intern(fl_ctx, double);\n\n    ctor_cv_intern(fl_ctx, array);\n    cv_intern(fl_ctx, pointer);\n    cv_intern(fl_ctx, void);\n    fl_ctx->cfunctionsym = symbol(fl_ctx, \"c-function\");\n\n    assign_global_builtins(fl_ctx, cvalues_builtin_info);\n\n    fl_ctx->stringtypesym = symbol(fl_ctx, \"*string-type*\");\n    setc(fl_ctx->stringtypesym, fl_list2(fl_ctx, fl_ctx->arraysym, fl_ctx->bytesym));\n\n    fl_ctx->wcstringtypesym = symbol(fl_ctx, \"*wcstring-type*\");\n    setc(fl_ctx->wcstringtypesym, fl_list2(fl_ctx, fl_ctx->arraysym, fl_ctx->wcharsym));\n\n    mk_primtype(fl_ctx, int8);\n    mk_primtype(fl_ctx, uint8);\n    mk_primtype(fl_ctx, int16);\n    mk_primtype(fl_ctx, uint16);\n    mk_primtype(fl_ctx, int32);\n    mk_primtype(fl_ctx, uint32);\n    mk_primtype(fl_ctx, int64);\n    mk_primtype(fl_ctx, uint64);\n#ifdef _P64\n    mk_primtype_(fl_ctx, ptrdiff, int64);\n    mk_primtype_(fl_ctx, size, uint64);\n#else\n    mk_primtype_(fl_ctx, ptrdiff, int32);\n    mk_primtype_(fl_ctx, size, uint32);\n#endif\n    mk_primtype_(fl_ctx, byte, uint8);\n    mk_primtype_(fl_ctx, wchar, int32);\n    mk_primtype(fl_ctx, float);\n    mk_primtype(fl_ctx, double);\n\n    fl_ctx->stringtype = get_type(fl_ctx, symbol_value(fl_ctx->stringtypesym));\n    fl_ctx->wcstringtype = get_type(fl_ctx, symbol_value(fl_ctx->wcstringtypesym));\n\n    fl_ctx->emptystringsym = symbol(fl_ctx, \"*empty-string*\");\n    setc(fl_ctx->emptystringsym, cvalue_static_cstring(fl_ctx, \"\"));\n}\n\n#define RETURN_NUM_AS(fl_ctx, var, type) return(mk_##type(fl_ctx, (fl_##type##_t)var))\n\nvalue_t return_from_uint64(fl_context_t *fl_ctx, uint64_t Uaccum)\n{\n    if (fits_fixnum(Uaccum)) {\n        return fixnum((fixnum_t)Uaccum);\n    }\n    if (Uaccum > (uint64_t)S64_MAX) {\n        RETURN_NUM_AS(fl_ctx, Uaccum, uint64);\n    }\n    else if (Uaccum > (uint64_t)INT_MAX) {\n        RETURN_NUM_AS(fl_ctx, Uaccum, int64);\n    }\n    RETURN_NUM_AS(fl_ctx, Uaccum, int32);\n}\n\nvalue_t return_from_int64(fl_context_t *fl_ctx, int64_t Saccum)\n{\n    if (fits_fixnum(Saccum)) {\n        return fixnum((fixnum_t)Saccum);\n    }\n    if (Saccum > (int64_t)INT_MAX || Saccum < (int64_t)INT_MIN) {\n        RETURN_NUM_AS(fl_ctx, Saccum, int64);\n    }\n    RETURN_NUM_AS(fl_ctx, Saccum, int32);\n}\n\nstatic value_t fl_add_any(fl_context_t *fl_ctx, value_t *args, uint32_t nargs, fixnum_t carryIn)\n{\n    uint64_t Uaccum=0;\n    int64_t Saccum = carryIn;\n    double Faccum=0;\n    uint32_t i;\n    value_t arg=fl_ctx->NIL;\n\n    FOR_ARGS(i,0,arg,args) {\n        if (isfixnum(arg)) {\n            Saccum += numval(arg);\n            continue;\n        }\n        else if (iscprim(arg)) {\n            cprim_t *cp = (cprim_t*)ptr(arg);\n            void *a = cp_data(cp);\n            int64_t i64;\n            switch(cp_numtype(cp)) {\n            case T_INT8:   Saccum += *(int8_t*)a; break;\n            case T_UINT8:  Saccum += *(uint8_t*)a; break;\n            case T_INT16:  Saccum += *(int16_t*)a; break;\n            case T_UINT16: Saccum += *(uint16_t*)a; break;\n            case T_INT32:  Saccum += *(int32_t*)a; break;\n            case T_UINT32: Saccum += *(uint32_t*)a; break;\n            case T_INT64:\n                i64 = *(int64_t*)a;\n                if (i64 > 0)\n                    Uaccum += (uint64_t)i64;\n                else\n                    Saccum += i64;\n                break;\n            case T_UINT64: Uaccum += *(uint64_t*)a; break;\n            case T_FLOAT:  Faccum += *(float*)a; break;\n            case T_DOUBLE: Faccum += *(double*)a; break;\n            default:\n                goto add_type_error;\n            }\n            continue;\n        }\n    add_type_error:\n        type_error(fl_ctx, \"+\", \"number\", arg);\n    }\n    if (Faccum != 0) {\n        Faccum += Uaccum;\n        Faccum += Saccum;\n        return mk_double(fl_ctx, Faccum);\n    }\n    else if (Saccum < 0) {\n        uint64_t negpart = (uint64_t)(-Saccum);\n        if (negpart > Uaccum) {\n            Saccum += (int64_t)Uaccum;\n            // return value in Saccum\n            if (Saccum >= INT_MIN) {\n                if (fits_fixnum(Saccum)) {\n                    return fixnum((fixnum_t)Saccum);\n                }\n                RETURN_NUM_AS(fl_ctx, Saccum, int32);\n            }\n            RETURN_NUM_AS(fl_ctx, Saccum, int64);\n        }\n        Uaccum -= negpart;\n    }\n    else {\n        Uaccum += (uint64_t)Saccum;\n    }\n    // return value in Uaccum\n    return return_from_uint64(fl_ctx, Uaccum);\n}\n\nstatic value_t fl_neg(fl_context_t *fl_ctx, value_t n)\n{\n    if (isfixnum(n)) {\n        return fixnum(-numval(n));\n    }\n    else if (iscprim(n)) {\n        cprim_t *cp = (cprim_t*)ptr(n);\n        void *a = cp_data(cp);\n        uint32_t ui32;\n        int32_t i32;\n        int64_t i64;\n        switch(cp_numtype(cp)) {\n        case T_INT8:   return fixnum(-(int32_t)*(int8_t*)a);\n        case T_UINT8:  return fixnum(-(int32_t)*(uint8_t*)a);\n        case T_INT16:  return fixnum(-(int32_t)*(int16_t*)a);\n        case T_UINT16: return fixnum(-(int32_t)*(uint16_t*)a);\n        case T_INT32:\n            i32 = *(int32_t*)a;\n            if (i32 == (int32_t)BIT31)\n                return mk_uint32(fl_ctx, (uint32_t)BIT31);\n            return mk_int32(fl_ctx, -i32);\n        case T_UINT32:\n            ui32 = *(uint32_t*)a;\n            if (ui32 <= ((uint32_t)INT_MAX)+1) return mk_int32(fl_ctx, -(int32_t)ui32);\n            return mk_int64(fl_ctx, -(int64_t)ui32);\n        case T_INT64:\n            i64 = *(int64_t*)a;\n            if (i64 == (int64_t)BIT63)\n                return mk_uint64(fl_ctx, (uint64_t)BIT63);\n            return mk_int64(fl_ctx, -i64);\n        case T_UINT64: return mk_int64(fl_ctx, -(int64_t)*(uint64_t*)a);\n        case T_FLOAT:  return mk_float(fl_ctx, -*(float*)a);\n        case T_DOUBLE: return mk_double(fl_ctx, -*(double*)a);\n            break;\n        }\n    }\n    type_error(fl_ctx, \"-\", \"number\", n);\n}\n\nstatic value_t fl_mul_any(fl_context_t *fl_ctx, value_t *args, uint32_t nargs, int64_t Saccum)\n{\n    uint64_t Uaccum=1;\n    double Faccum=1;\n    uint32_t i;\n    value_t arg=fl_ctx->NIL;\n\n    FOR_ARGS(i,0,arg,args) {\n        if (isfixnum(arg)) {\n            Saccum *= numval(arg);\n            continue;\n        }\n        else if (iscprim(arg)) {\n            cprim_t *cp = (cprim_t*)ptr(arg);\n            void *a = cp_data(cp);\n            int64_t i64;\n            switch(cp_numtype(cp)) {\n            case T_INT8:   Saccum *= *(int8_t*)a; break;\n            case T_UINT8:  Saccum *= *(uint8_t*)a; break;\n            case T_INT16:  Saccum *= *(int16_t*)a; break;\n            case T_UINT16: Saccum *= *(uint16_t*)a; break;\n            case T_INT32:  Saccum *= *(int32_t*)a; break;\n            case T_UINT32: Saccum *= *(uint32_t*)a; break;\n            case T_INT64:\n                i64 = *(int64_t*)a;\n                if (i64 > 0)\n                    Uaccum *= (uint64_t)i64;\n                else\n                    Saccum *= i64;\n                break;\n            case T_UINT64: Uaccum *= *(uint64_t*)a; break;\n            case T_FLOAT:  Faccum *= *(float*)a; break;\n            case T_DOUBLE: Faccum *= *(double*)a; break;\n            default:\n                goto mul_type_error;\n            }\n            continue;\n        }\n    mul_type_error:\n        type_error(fl_ctx, \"*\", \"number\", arg);\n    }\n    if (Faccum != 1) {\n        Faccum *= Uaccum;\n        Faccum *= Saccum;\n        return mk_double(fl_ctx, Faccum);\n    }\n    else if (Saccum < 0) {\n        Saccum *= (int64_t)Uaccum;\n        if (Saccum >= INT_MIN) {\n            if (fits_fixnum(Saccum)) {\n                return fixnum((fixnum_t)Saccum);\n            }\n            RETURN_NUM_AS(fl_ctx, Saccum, int32);\n        }\n        RETURN_NUM_AS(fl_ctx, Saccum, int64);\n    }\n    else {\n        Uaccum *= (uint64_t)Saccum;\n    }\n    return return_from_uint64(fl_ctx, Uaccum);\n}\n\nstatic int num_to_ptr(value_t a, fixnum_t *pi, numerictype_t *pt, void **pp)\n{\n    cprim_t *cp;\n    if (isfixnum(a)) {\n        *pi = numval(a);\n        *pp = pi;\n        *pt = T_FIXNUM;\n    }\n    else if (iscprim(a)) {\n        cp = (cprim_t*)ptr(a);\n        *pp = cp_data(cp);\n        *pt = cp_numtype(cp);\n    }\n    else {\n        return 0;\n    }\n    return 1;\n}\n\n/*\n  returns -1, 0, or 1 based on ordering of a and b\n  eq: consider equality only, returning 0 or nonzero\n  eqnans: NaNs considered equal to each other\n          -0.0 not considered equal to 0.0\n          inexact not considered equal to exact\n  fname: if not NULL, throws type errors, else returns 2 for type errors\n*/\nint numeric_compare(fl_context_t *fl_ctx, value_t a, value_t b, int eq, int eqnans, char *fname)\n{\n    int_t ai, bi;\n    numerictype_t ta, tb;\n    void *aptr, *bptr;\n\n    if (bothfixnums(a,b)) {\n        if (a==b) return 0;\n        if (numval(a) < numval(b)) return -1;\n        return 1;\n    }\n    if (!num_to_ptr(a, &ai, &ta, &aptr)) {\n        if (fname) type_error(fl_ctx, fname, \"number\", a); else return 2;\n    }\n    if (!num_to_ptr(b, &bi, &tb, &bptr)) {\n        if (fname) type_error(fl_ctx, fname, \"number\", b); else return 2;\n    }\n    if (eq && eqnans && ((ta >= T_FLOAT) != (tb >= T_FLOAT)))\n        return 1;\n    if (cmp_eq(aptr, ta, bptr, tb, eqnans))\n        return 0;\n    if (eq) return 1;\n    if (cmp_lt(aptr, ta, bptr, tb))\n        return -1;\n    return 1;\n}\n\n#if defined(_OS_WINDOWS_)\n__declspec(noreturn) static void DivideByZeroError(fl_context_t *fl_ctx);\n#else\nstatic void DivideByZeroError(fl_context_t *fl_ctx) __attribute__ ((__noreturn__));\n#endif\n\nstatic void DivideByZeroError(fl_context_t *fl_ctx)\n{\n    lerror(fl_ctx, fl_ctx->DivideError, \"/: division by zero\");\n}\n\nstatic value_t fl_div2(fl_context_t *fl_ctx, value_t a, value_t b)\n{\n    double da, db;\n    int_t ai, bi;\n    numerictype_t ta, tb;\n    void *aptr, *bptr;\n\n    if (!num_to_ptr(a, &ai, &ta, &aptr))\n        type_error(fl_ctx, \"/\", \"number\", a);\n    if (!num_to_ptr(b, &bi, &tb, &bptr))\n        type_error(fl_ctx, \"/\", \"number\", b);\n\n    da = conv_to_double(aptr, ta);\n    db = conv_to_double(bptr, tb);\n\n    if (db == 0 && tb < T_FLOAT)  // exact 0\n        DivideByZeroError(fl_ctx);\n\n    da = da/db;\n\n    if (ta < T_FLOAT && tb < T_FLOAT && (double)(int64_t)da == da)\n        return return_from_int64(fl_ctx, (int64_t)da);\n    return mk_double(fl_ctx, da);\n}\n\nstatic value_t fl_idiv2(fl_context_t *fl_ctx, value_t a, value_t b)\n{\n    int_t ai, bi;\n    numerictype_t ta, tb;\n    void *aptr, *bptr;\n    int64_t a64, b64;\n\n    if (!num_to_ptr(a, &ai, &ta, &aptr))\n        type_error(fl_ctx, \"div0\", \"number\", a);\n    if (!num_to_ptr(b, &bi, &tb, &bptr))\n        type_error(fl_ctx, \"div0\", \"number\", b);\n\n    if (ta == T_UINT64) {\n        if (tb == T_UINT64) {\n            if (*(uint64_t*)bptr == 0) goto div_error;\n            return return_from_uint64(fl_ctx, *(uint64_t*)aptr / *(uint64_t*)bptr);\n        }\n        b64 = conv_to_int64(bptr, tb);\n        if (b64 < 0) {\n            return return_from_int64(fl_ctx, -(int64_t)(*(uint64_t*)aptr /\n                                                        (uint64_t)(-b64)));\n        }\n        if (b64 == 0)\n            goto div_error;\n        return return_from_uint64(fl_ctx, *(uint64_t*)aptr / (uint64_t)b64);\n    }\n    if (tb == T_UINT64) {\n        if (*(uint64_t*)bptr == 0) goto div_error;\n        a64 = conv_to_int64(aptr, ta);\n        if (a64 < 0) {\n            return return_from_int64(fl_ctx, -((int64_t)((uint64_t)(-a64) /\n                                                         *(uint64_t*)bptr)));\n        }\n        return return_from_uint64(fl_ctx, (uint64_t)a64 / *(uint64_t*)bptr);\n    }\n\n    b64 = conv_to_int64(bptr, tb);\n    if (b64 == 0) goto div_error;\n\n    return return_from_int64(fl_ctx, conv_to_int64(aptr, ta) / b64);\n div_error:\n    DivideByZeroError(fl_ctx);\n}\n\nstatic value_t fl_bitwise_op(fl_context_t *fl_ctx, value_t a, value_t b, int opcode, char *fname)\n{\n    int_t ai, bi;\n    numerictype_t ta, tb, itmp;\n    void *aptr=NULL, *bptr=NULL, *ptmp;\n    int64_t b64;\n\n    if (!num_to_ptr(a, &ai, &ta, &aptr) || ta >= T_FLOAT)\n        type_error(fl_ctx, fname, \"integer\", a);\n    if (!num_to_ptr(b, &bi, &tb, &bptr) || tb >= T_FLOAT)\n        type_error(fl_ctx, fname, \"integer\", b);\n\n    if (ta < tb) {\n        itmp = ta; ta = tb; tb = itmp;\n        ptmp = aptr; aptr = bptr; bptr = ptmp;\n    }\n    // now a's type is larger than or same as b's\n    b64 = conv_to_int64(bptr, tb);\n    switch (opcode) {\n    case 0:\n    switch (ta) {\n    case T_INT8:   return fixnum(   *(int8_t *)aptr  & (int8_t  )b64);\n    case T_UINT8:  return fixnum(   *(uint8_t *)aptr & (uint8_t )b64);\n    case T_INT16:  return fixnum(   *(int16_t*)aptr  & (int16_t )b64);\n    case T_UINT16: return fixnum(   *(uint16_t*)aptr & (uint16_t)b64);\n    case T_INT32:  return mk_int32(fl_ctx,  *(int32_t*)aptr  & (int32_t )b64);\n    case T_UINT32: return mk_uint32(fl_ctx, *(uint32_t*)aptr & (uint32_t)b64);\n    case T_INT64:  return mk_int64(fl_ctx,  *(int64_t*)aptr  & (int64_t )b64);\n    case T_UINT64: return mk_uint64(fl_ctx, *(uint64_t*)aptr & (uint64_t)b64);\n    case T_FLOAT:\n    case T_DOUBLE: assert(0);\n    }\n    break;\n    case 1:\n    switch (ta) {\n    case T_INT8:   return fixnum(   *(int8_t *)aptr  | (int8_t  )b64);\n    case T_UINT8:  return fixnum(   *(uint8_t *)aptr | (uint8_t )b64);\n    case T_INT16:  return fixnum(   *(int16_t*)aptr  | (int16_t )b64);\n    case T_UINT16: return fixnum(   *(uint16_t*)aptr | (uint16_t)b64);\n    case T_INT32:  return mk_int32(fl_ctx,  *(int32_t*)aptr  | (int32_t )b64);\n    case T_UINT32: return mk_uint32(fl_ctx, *(uint32_t*)aptr | (uint32_t)b64);\n    case T_INT64:  return mk_int64(fl_ctx,  *(int64_t*)aptr  | (int64_t )b64);\n    case T_UINT64: return mk_uint64(fl_ctx, *(uint64_t*)aptr | (uint64_t)b64);\n    case T_FLOAT:\n    case T_DOUBLE: assert(0);\n    }\n    break;\n    case 2:\n    switch (ta) {\n    case T_INT8:   return fixnum(   *(int8_t *)aptr  ^ (int8_t  )b64);\n    case T_UINT8:  return fixnum(   *(uint8_t *)aptr ^ (uint8_t )b64);\n    case T_INT16:  return fixnum(   *(int16_t*)aptr  ^ (int16_t )b64);\n    case T_UINT16: return fixnum(   *(uint16_t*)aptr ^ (uint16_t)b64);\n    case T_INT32:  return mk_int32(fl_ctx,  *(int32_t*)aptr  ^ (int32_t )b64);\n    case T_UINT32: return mk_uint32(fl_ctx, *(uint32_t*)aptr ^ (uint32_t)b64);\n    case T_INT64:  return mk_int64(fl_ctx,  *(int64_t*)aptr  ^ (int64_t )b64);\n    case T_UINT64: return mk_uint64(fl_ctx, *(uint64_t*)aptr ^ (uint64_t)b64);\n    case T_FLOAT:\n    case T_DOUBLE: assert(0);\n    }\n    }\n    assert(0);\n    return fl_ctx->NIL;\n}\n\nstatic value_t fl_logand(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    value_t v, e;\n    int i;\n    if (nargs == 0)\n        return fixnum(-1);\n    v = args[0];\n    FOR_ARGS(i,1,e,args) {\n        if (bothfixnums(v, e))\n            v = v & e;\n        else\n            v = fl_bitwise_op(fl_ctx, v, e, 0, \"logand\");\n    }\n    return v;\n}\n\nstatic value_t fl_logior(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    value_t v, e;\n    int i;\n    if (nargs == 0)\n        return fixnum(0);\n    v = args[0];\n    FOR_ARGS(i,1,e,args) {\n        if (bothfixnums(v, e))\n            v = v | e;\n        else\n            v = fl_bitwise_op(fl_ctx, v, e, 1, \"logior\");\n    }\n    return v;\n}\n\nstatic value_t fl_logxor(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    value_t v, e;\n    int i;\n    if (nargs == 0)\n        return fixnum(0);\n    v = args[0];\n    FOR_ARGS(i,1,e,args) {\n        if (bothfixnums(v, e))\n            v = fixnum(numval(v) ^ numval(e));\n        else\n            v = fl_bitwise_op(fl_ctx, v, e, 2, \"logxor\");\n    }\n    return v;\n}\n\nstatic value_t fl_lognot(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    argcount(fl_ctx, \"lognot\", nargs, 1);\n    value_t a = args[0];\n    if (isfixnum(a))\n        return fixnum(~numval(a));\n    cprim_t *cp;\n    int ta;\n    void *aptr;\n\n    if (iscprim(a)) {\n        cp = (cprim_t*)ptr(a);\n        ta = cp_numtype(cp);\n        aptr = cp_data(cp);\n        switch (ta) {\n        case T_INT8:   return fixnum(~*(int8_t *)aptr);\n        case T_UINT8:  return fixnum(~*(uint8_t *)aptr);\n        case T_INT16:  return fixnum(~*(int16_t *)aptr);\n        case T_UINT16: return fixnum(~*(uint16_t*)aptr);\n        case T_INT32:  return mk_int32(fl_ctx, ~*(int32_t *)aptr);\n        case T_UINT32: return mk_uint32(fl_ctx, ~*(uint32_t*)aptr);\n        case T_INT64:  return mk_int64(fl_ctx, ~*(int64_t *)aptr);\n        case T_UINT64: return mk_uint64(fl_ctx, ~*(uint64_t*)aptr);\n        }\n    }\n    type_error(fl_ctx, \"lognot\", \"integer\", a);\n}\n\nstatic value_t fl_ash(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    fixnum_t n;\n    int64_t accum;\n    argcount(fl_ctx, \"ash\", nargs, 2);\n    value_t a = args[0];\n    n = tofixnum(fl_ctx, args[1], \"ash\");\n    if (isfixnum(a)) {\n        if (n <= 0)\n            return fixnum(numval(a)>>(-n));\n        accum = ((int64_t)numval(a))<<n;\n        if (fits_fixnum(accum))\n            return fixnum(accum);\n        else\n            return return_from_int64(fl_ctx, accum);\n    }\n    cprim_t *cp;\n    int ta;\n    void *aptr;\n    if (iscprim(a)) {\n        if (n == 0) return a;\n        cp = (cprim_t*)ptr(a);\n        ta = cp_numtype(cp);\n        aptr = cp_data(cp);\n        if (n < 0) {\n            n = -n;\n            switch (ta) {\n            case T_INT8:   return fixnum((*(int8_t *)aptr) >> n);\n            case T_UINT8:  return fixnum((*(uint8_t *)aptr) >> n);\n            case T_INT16:  return fixnum((*(int16_t *)aptr) >> n);\n            case T_UINT16: return fixnum((*(uint16_t*)aptr) >> n);\n            case T_INT32:  return mk_int32(fl_ctx, (*(int32_t *)aptr) >> n);\n            case T_UINT32: return mk_uint32(fl_ctx, (*(uint32_t*)aptr) >> n);\n            case T_INT64:  return mk_int64(fl_ctx, (*(int64_t *)aptr) >> n);\n            case T_UINT64: return mk_uint64(fl_ctx, (*(uint64_t*)aptr) >> n);\n            }\n        }\n        else {\n            if (ta == T_UINT64)\n                return return_from_uint64(fl_ctx, (*(uint64_t*)aptr)<<n);\n            else if (ta < T_FLOAT) {\n                int64_t i64 = conv_to_int64(aptr, (numerictype_t)ta);\n                return return_from_int64(fl_ctx, i64<<n);\n            }\n        }\n    }\n    type_error(fl_ctx, \"ash\", \"integer\", a);\n    return fl_ctx->NIL;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/base/c.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n# definitions related to C interface\n\nimport Core.Intrinsics: cglobal, bitcast\n\n\"\"\"\n    cglobal((symbol, library) [, type=Cvoid])\n\nObtain a pointer to a global variable in a C-exported shared library, specified exactly as\nin [`ccall`](@ref).\nReturns a `Ptr{Type}`, defaulting to `Ptr{Cvoid}` if no `Type` argument is\nsupplied.\nThe values can be read or written by [`unsafe_load`](@ref) or [`unsafe_store!`](@ref),\nrespectively.\n\"\"\"\ncglobal\n\n\"\"\"\n    CFunction struct\n\nGarbage-collection handle for the return value from `@cfunction`\nwhen the first argument is annotated with '\\\\\\$'.\nLike all `cfunction` handles, it should be passed to `ccall` as a `Ptr{Cvoid}`,\nand will be converted automatically at the call site to the appropriate type.\n\nSee [`@cfunction`](@ref).\n\"\"\"\nmutable struct CFunction <: Ref{Cvoid}\n    ptr::Ptr{Cvoid}\n    f::Any\n    _1::Ptr{Cvoid}\n    _2::Ptr{Cvoid}\n    let constructor = false end\nend\nunsafe_convert(::Type{Ptr{Cvoid}}, cf::CFunction) = cf.ptr\n\n\"\"\"\n    @cfunction(callable, ReturnType, (ArgumentTypes...,)) -> Ptr{Cvoid}\n    @cfunction(\\$callable, ReturnType, (ArgumentTypes...,)) -> CFunction\n\nGenerate a C-callable function pointer from the Julia function `callable`\nfor the given type signature.\nTo pass the return value to a `ccall`, use the argument type `Ptr{Cvoid}` in the signature.\n\nNote that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression\n(although it can include a splat expression). And that these arguments will be evaluated in global scope\nduring compile-time (not deferred until runtime).\nAdding a '\\\\\\$' in front of the function argument changes this to instead create a runtime closure\nover the local variable `callable` (this is not supported on all architectures).\n\nSee [manual section on ccall and cfunction usage](@ref Calling-C-and-Fortran-Code).\n\n# Examples\n```julia-repl\njulia> function foo(x::Int, y::Int)\n           return x + y\n       end\n\njulia> @cfunction(foo, Int, (Int, Int))\nPtr{Cvoid} @0x000000001b82fcd0\n```\n\"\"\"\nmacro cfunction(f, rt, at)\n    if !(isa(at, Expr) && at.head === :tuple)\n        throw(ArgumentError(\"@cfunction argument types must be a literal tuple\"))\n    end\n    at.head = :call\n    pushfirst!(at.args, GlobalRef(Core, :svec))\n    if isa(f, Expr) && f.head === :$\n        fptr = f.args[1]\n        typ = CFunction\n    else\n        fptr = QuoteNode(f)\n        typ = Ptr{Cvoid}\n    end\n    cfun = Expr(:cfunction, typ, fptr, rt, at, QuoteNode(:ccall))\n    return esc(cfun)\nend\n\nif ccall(:jl_is_char_signed, Ref{Bool}, ())\n    const Cchar = Int8\nelse\n    const Cchar = UInt8\nend\n\"\"\"\n    Cchar\n\nEquivalent to the native `char` c-type.\n\"\"\"\nCchar\n\n# The ccall here is equivalent to Sys.iswindows(), but that's not defined yet\n@static if ccall(:jl_get_UNAME, Any, ()) === :NT\n    const Clong = Int32\n    const Culong = UInt32\n    const Cwchar_t = UInt16\nelse\n    const Clong = Int\n    const Culong = UInt\n    const Cwchar_t = Int32\nend\n\n\"\"\"\n    Clong\n\nEquivalent to the native `signed long` c-type.\n\"\"\"\nClong\n\n\"\"\"\n    Culong\n\nEquivalent to the native `unsigned long` c-type.\n\"\"\"\nCulong\n\n\"\"\"\n    Cwchar_t\n\nEquivalent to the native `wchar_t` c-type ([`Int32`](@ref)).\n\"\"\"\nCwchar_t\n\n\"\"\"\n    Cwstring\n\nA C-style string composed of the native wide character type\n[`Cwchar_t`](@ref)s. `Cwstring`s are NUL-terminated. For\nC-style strings composed of the native character\ntype, see [`Cstring`](@ref). For more information\nabout string interopability with C, see the\n[manual](@ref man-bits-types).\n\n\"\"\"\nCwstring\n\n\"\"\"\n    Cstring\n\nA C-style string composed of the native character type\n[`Cchar`](@ref)s. `Cstring`s are NUL-terminated. For\nC-style strings composed of the native wide character\ntype, see [`Cwstring`](@ref). For more information\nabout string interopability with C, see the\n[manual](@ref man-bits-types).\n\"\"\"\nCstring\n\n@static if ccall(:jl_get_UNAME, Any, ()) !== :NT\n    const sizeof_mode_t = ccall(:jl_sizeof_mode_t, Cint, ())\n    if sizeof_mode_t == 2\n        const Cmode_t = Int16\n    elseif sizeof_mode_t == 4\n        const Cmode_t = Int32\n    elseif sizeof_mode_t == 8\n        const Cmode_t = Int64\n    end\nend\n\n# construction from pointers\nCstring(p::Union{Ptr{Int8},Ptr{UInt8},Ptr{Cvoid}}) = bitcast(Cstring, p)\nCwstring(p::Union{Ptr{Cwchar_t},Ptr{Cvoid}})       = bitcast(Cwstring, p)\nPtr{T}(p::Cstring) where {T<:Union{Int8,UInt8,Cvoid}} = bitcast(Ptr{T}, p)\nPtr{T}(p::Cwstring) where {T<:Union{Cwchar_t,Cvoid}}  = bitcast(Ptr{Cwchar_t}, p)\n\nconvert(::Type{Cstring}, p::Union{Ptr{Int8},Ptr{UInt8},Ptr{Cvoid}}) = Cstring(p)\nconvert(::Type{Cwstring}, p::Union{Ptr{Cwchar_t},Ptr{Cvoid}}) = Cwstring(p)\nconvert(::Type{Ptr{T}}, p::Cstring) where {T<:Union{Int8,UInt8,Cvoid}} = Ptr{T}(p)\nconvert(::Type{Ptr{T}}, p::Cwstring) where {T<:Union{Cwchar_t,Cvoid}} = Ptr{T}(p)\n\n\"\"\"\n    pointer(array [, index])\n\nGet the native address of an array or string, optionally at a given location `index`.\n\nThis function is \"unsafe\". Be careful to ensure that a Julia reference to\n`array` exists as long as this pointer will be used. The [`GC.@preserve`](@ref)\nmacro should be used to protect the `array` argument from garbage collection\nwithin a given block of code.\n\nCalling [`Ref(array[, index])`](@ref Ref) is generally preferable to this function as it guarantees validity.\n\"\"\"\nfunction pointer end\n\npointer(p::Cstring) = convert(Ptr{Cchar}, p)\npointer(p::Cwstring) = convert(Ptr{Cwchar_t}, p)\n\n# comparisons against pointers (mainly to support `cstr==C_NULL`)\n==(x::Union{Cstring,Cwstring}, y::Ptr) = pointer(x) == y\n==(x::Ptr, y::Union{Cstring,Cwstring}) = x == pointer(y)\n\nunsafe_string(s::Cstring) = unsafe_string(convert(Ptr{UInt8}, s))\n\n# convert strings to String etc. to pass as pointers\ncconvert(::Type{Cstring}, s::String) = s\ncconvert(::Type{Cstring}, s::AbstractString) =\n    cconvert(Cstring, String(s)::String)\n\nfunction cconvert(::Type{Cwstring}, s::AbstractString)\n    v = transcode(Cwchar_t, String(s))\n    !isempty(v) && v[end] == 0 || push!(v, 0)\n    return v\nend\n\neltype(::Type{Cstring}) = Cchar\neltype(::Type{Cwstring}) = Cwchar_t\n\ncontainsnul(p::Ptr, len) =\n    C_NULL != ccall(:memchr, Ptr{Cchar}, (Ptr{Cchar}, Cint, Csize_t), p, 0, len)\ncontainsnul(s::String) = containsnul(unsafe_convert(Ptr{Cchar}, s), sizeof(s))\ncontainsnul(s::AbstractString) = '\\0' in s\n\nfunction unsafe_convert(::Type{Cstring}, s::Union{String,AbstractVector{UInt8}})\n    p = unsafe_convert(Ptr{Cchar}, s)\n    containsnul(p, sizeof(s)) &&\n        throw(ArgumentError(\"embedded NULs are not allowed in C strings: $(repr(s))\"))\n    return Cstring(p)\nend\n\nfunction unsafe_convert(::Type{Cwstring}, v::Vector{Cwchar_t})\n    for i = 1:length(v)-1\n        v[i] == 0 &&\n            throw(ArgumentError(\"embedded NULs are not allowed in C strings: $(repr(v))\"))\n    end\n    v[end] == 0 ||\n        throw(ArgumentError(\"C string data must be NUL terminated: $(repr(v))\"))\n    p = unsafe_convert(Ptr{Cwchar_t}, v)\n    return Cwstring(p)\nend\n\n# symbols are guaranteed not to contain embedded NUL\ncconvert(::Type{Cstring}, s::Symbol) = s\nunsafe_convert(::Type{Cstring}, s::Symbol) = Cstring(unsafe_convert(Ptr{Cchar}, s))\n\n@static if ccall(:jl_get_UNAME, Any, ()) === :NT\n\"\"\"\n    Base.cwstring(s)\n\nConverts a string `s` to a NUL-terminated `Vector{Cwchar_t}`, suitable for passing to C\nfunctions expecting a `Ptr{Cwchar_t}`. The main advantage of using this over the implicit\nconversion provided by [`Cwstring`](@ref) is if the function is called multiple times with the\nsame argument.\n\nThis is only available on Windows.\n\"\"\"\nfunction cwstring(s::AbstractString)\n    bytes = codeunits(String(s))\n    0 in bytes && throw(ArgumentError(\"embedded NULs are not allowed in C strings: $(repr(s))\"))\n    return push!(transcode(UInt16, bytes), 0)\nend\nend\n\n# transcoding between data in UTF-8 and UTF-16 for Windows APIs,\n# and also UTF-32 for APIs using Cwchar_t on other platforms.\n\n\"\"\"\n    transcode(T, src)\n\nConvert string data between Unicode encodings. `src` is either a\n`String` or a `Vector{UIntXX}` of UTF-XX code units, where\n`XX` is 8, 16, or 32. `T` indicates the encoding of the return value:\n`String` to return a (UTF-8 encoded) `String` or `UIntXX`\nto return a `Vector{UIntXX}` of UTF-`XX` data. (The alias [`Cwchar_t`](@ref)\ncan also be used as the integer type, for converting `wchar_t*` strings\nused by external C libraries.)\n\nThe `transcode` function succeeds as long as the input data can be\nreasonably represented in the target encoding; it always succeeds for\nconversions between UTF-XX encodings, even for invalid Unicode data.\n\nOnly conversion to/from UTF-8 is currently supported.\n\"\"\"\nfunction transcode end\n\ntranscode(::Type{T}, src::AbstractVector{T}) where {T<:Union{UInt8,UInt16,UInt32,Int32}} = src\ntranscode(::Type{T}, src::String) where {T<:Union{Int32,UInt32}} = T[T(c) for c in src]\ntranscode(::Type{T}, src::AbstractVector{UInt8}) where {T<:Union{Int32,UInt32}} =\n    transcode(T, String(Vector(src)))\ntranscode(::Type{T}, src::CodeUnits{UInt8,String}) where {T<:Union{Int32,UInt32}} =\n    transcode(T, String(src))\n\nfunction transcode(::Type{UInt8}, src::Vector{<:Union{Int32,UInt32}})\n    buf = IOBuffer()\n    for c in src\n        print(buf, Char(c))\n    end\n    take!(buf)\nend\ntranscode(::Type{String}, src::String) = src\ntranscode(T, src::String) = transcode(T, codeunits(src))\ntranscode(::Type{String}, src) = String(transcode(UInt8, src))\n\nfunction transcode(::Type{UInt16}, src::AbstractVector{UInt8})\n    require_one_based_indexing(src)\n    dst = UInt16[]\n    i, n = 1, length(src)\n    n > 0 || return dst\n    sizehint!(dst, 2n)\n    a = src[1]\n    while true\n        if i < n && -64 <= a % Int8 <= -12 # multi-byte character\n            b = src[i += 1]\n            if -64 <= (b % Int8) || a == 0xf4 && 0x8f < b\n                # invalid UTF-8 (non-continuation or too-high code point)\n                push!(dst, a)\n                a = b; continue\n            elseif a < 0xe0 # 2-byte UTF-8\n                push!(dst, xor(0x3080, UInt16(a) << 6, b))\n            elseif i < n # 3/4-byte character\n                c = src[i += 1]\n                if -64 <= (c % Int8) # invalid UTF-8 (non-continuation)\n                    push!(dst, a, b)\n                    a = c; continue\n                elseif a < 0xf0 # 3-byte UTF-8\n                    push!(dst, xor(0x2080, UInt16(a) << 12, UInt16(b) << 6, c))\n                elseif i < n\n                    d = src[i += 1]\n                    if -64 <= (d % Int8) # invalid UTF-8 (non-continuation)\n                        push!(dst, a, b, c)\n                        a = d; continue\n                    elseif a == 0xf0 && b < 0x90 # overlong encoding\n                        push!(dst, xor(0x2080, UInt16(b) << 12, UInt16(c) << 6, d))\n                    else # 4-byte UTF-8\n                        push!(dst, 0xe5b8 + (UInt16(a) << 8) + (UInt16(b) << 2) + (c >> 4),\n                                   xor(0xdc80, UInt16(c & 0xf) << 6, d))\n                    end\n                else # too short\n                    push!(dst, a, b, c)\n                    break\n                end\n            else # too short\n                push!(dst, a, b)\n                break\n            end\n        else # ASCII or invalid UTF-8 (continuation byte or too-high code point)\n            push!(dst, a)\n        end\n        i < n || break\n        a = src[i += 1]\n    end\n    return dst\nend\n\nfunction transcode(::Type{UInt8}, src::AbstractVector{UInt16})\n    require_one_based_indexing(src)\n    n = length(src)\n    n == 0 && return UInt8[]\n\n    # Precompute m = sizeof(dst).   This involves annoying duplication\n    # of the loop over the src array.   However, this is not just an\n    # optimization: it is problematic for security reasons to grow\n    # dst dynamically, because Base.winprompt uses this function to\n    # convert passwords to UTF-8 and we don't want to make unintentional\n    # copies of the password data.\n    a = src[1]\n    i, m = 1, 0\n    while true\n        if a < 0x80\n            m += 1\n        elseif a < 0x800 # 2-byte UTF-8\n            m += 2\n        elseif a & 0xfc00 == 0xd800 && i < length(src)\n            b = src[i += 1]\n            if (b & 0xfc00) == 0xdc00 # 2-unit UTF-16 sequence => 4-byte UTF-8\n                m += 4\n            else\n                m += 3\n                a = b; continue\n            end\n        else\n            # 1-unit high UTF-16 or unpaired high surrogate\n            # either way, encode as 3-byte UTF-8 code point\n            m += 3\n        end\n        i < n || break\n        a = src[i += 1]\n    end\n\n    dst = StringVector(m)\n    a = src[1]\n    i, j = 1, 0\n    while true\n        if a < 0x80 # ASCII\n            dst[j += 1] = a % UInt8\n        elseif a < 0x800 # 2-byte UTF-8\n            dst[j += 1] = 0xc0 | ((a >> 6) % UInt8)\n            dst[j += 1] = 0x80 | ((a % UInt8) & 0x3f)\n        elseif a & 0xfc00 == 0xd800 && i < n\n            b = src[i += 1]\n            if (b & 0xfc00) == 0xdc00\n                # 2-unit UTF-16 sequence => 4-byte UTF-8\n                a += 0x2840\n                dst[j += 1] = 0xf0 | ((a >> 8) % UInt8)\n                dst[j += 1] = 0x80 | ((a % UInt8) >> 2)\n                dst[j += 1] = xor(0xf0, ((a % UInt8) << 4) & 0x3f, (b >> 6) % UInt8)\n                dst[j += 1] = 0x80 | ((b % UInt8) & 0x3f)\n            else\n                dst[j += 1] = 0xe0 | ((a >> 12) % UInt8)\n                dst[j += 1] = 0x80 | (((a >> 6) % UInt8) & 0x3f)\n                dst[j += 1] = 0x80 | ((a % UInt8) & 0x3f)\n                a = b; continue\n            end\n        else\n            # 1-unit high UTF-16 or unpaired high surrogate\n            # either way, encode as 3-byte UTF-8 code point\n            dst[j += 1] = 0xe0 | ((a >> 12) % UInt8)\n            dst[j += 1] = 0x80 | (((a >> 6) % UInt8) & 0x3f)\n            dst[j += 1] = 0x80 | ((a % UInt8) & 0x3f)\n        end\n        i < n || break\n        a = src[i += 1]\n    end\n    return dst\nend\n\nfunction unsafe_string(p::Ptr{T}, length::Integer) where {T<:Union{UInt16,UInt32,Cwchar_t}}\n    transcode(String, unsafe_wrap(Array, p, length; own=false))\nend\nfunction unsafe_string(cw::Cwstring)\n    p = convert(Ptr{Cwchar_t}, cw)\n    n = 1\n    while unsafe_load(p, n) != 0\n        n += 1\n    end\n    return unsafe_string(p, n - 1)\nend\n\n# deferring (or un-deferring) ctrl-c handler for external C code that\n# is not interrupt safe (see also issue #2622).  The sigatomic_begin/end\n# functions should always be called in matched pairs, ideally via:\n#            disable_sigint() do .. end\n# reennable_sigint is provided so that immediate ctrl-c handling is\n# re-enabled within a sigatomic region, e.g. inside a Julia callback function\n# within a long-running C routine.\nsigatomic_begin() = ccall(:jl_sigatomic_begin, Cvoid, ())\nsigatomic_end() = ccall(:jl_sigatomic_end, Cvoid, ())\n\n\"\"\"\n    disable_sigint(f::Function)\n\nDisable Ctrl-C handler during execution of a function on the current task,\nfor calling external code that may call julia code that is not interrupt safe.\nIntended to be called using `do` block syntax as follows:\n\n    disable_sigint() do\n        # interrupt-unsafe code\n        ...\n    end\n\nThis is not needed on worker threads (`Threads.threadid() != 1`) since the\n`InterruptException` will only be delivered to the master thread.\nExternal functions that do not call julia code or julia runtime\nautomatically disable sigint during their execution.\n\"\"\"\nfunction disable_sigint(f::Function)\n    sigatomic_begin()\n    res = f()\n    # Exception unwind sigatomic automatically\n    sigatomic_end()\n    res\nend\n\n\"\"\"\n    reenable_sigint(f::Function)\n\nRe-enable Ctrl-C handler during execution of a function.\nTemporarily reverses the effect of [`disable_sigint`](@ref).\n\"\"\"\nfunction reenable_sigint(f::Function)\n    sigatomic_end()\n    res = f()\n    # Exception unwind sigatomic automatically\n    sigatomic_begin()\n    res\nend\n\n\"\"\"\n    exit_on_sigint(on::Bool)\n\nSet `exit_on_sigint` flag of the julia runtime.  If `false`, Ctrl-C\n(SIGINT) is capturable as [`InterruptException`](@ref) in `try` block.\nThis is the default behavior in REPL, any code run via `-e` and `-E`\nand in Julia script run with `-i` option.\n\nIf `true`, `InterruptException` is not thrown by Ctrl-C.  Running code\nupon such event requires [`atexit`](@ref).  This is the default\nbehavior in Julia script run without `-i` option.\n\n!!! compat \"Julia 1.5\"\n    Function `exit_on_sigint` requires at least Julia 1.5.\n\"\"\"\nfunction exit_on_sigint(on::Bool)\n    ccall(:jl_exit_on_sigint, Cvoid, (Cint,), on)\nend\n\nfunction _ccallable(rt::Type, sigt::Type)\n    ccall(:jl_extern_c, Cvoid, (Any, Any), rt, sigt)\nend\n\nfunction expand_ccallable(rt, def)\n    if isa(def,Expr) && (def.head === :(=) || def.head === :function)\n        sig = def.args[1]\n        if sig.head === :(::)\n            if rt === nothing\n                rt = sig.args[2]\n            end\n            sig = sig.args[1]\n        end\n        if rt === nothing\n            error(\"@ccallable requires a return type\")\n        end\n        if sig.head === :call\n            f = sig.args[1]\n            if isa(f,Expr) && f.head === :(::)\n                f = f.args[end]\n            else\n                f = :(typeof($f))\n            end\n            at = map(sig.args[2:end]) do a\n                if isa(a,Expr) && a.head === :(::)\n                    a.args[end]\n                else\n                    :Any\n                end\n            end\n            return quote\n                $(esc(def))\n                _ccallable($(esc(rt)), $(Expr(:curly, :Tuple, esc(f), map(esc, at)...)))\n            end\n        end\n    end\n    error(\"expected method definition in @ccallable\")\nend\n\nmacro ccallable(def)\n    expand_ccallable(nothing, def)\nend\nmacro ccallable(rt, def)\n    expand_ccallable(rt, def)\nend\n\n# @ccall implementation\n\"\"\"\n    ccall_macro_parse(expression)\n\n`ccall_macro_parse` is an implementation detail of `@ccall\n\nit takes an expression like `:(printf(\"%d\"::Cstring, value::Cuint)::Cvoid)`\nreturns: a tuple of `(function_name, return_type, arg_types, args)`\n\nThe above input outputs this:\n\n    (:printf, :Cvoid, [:Cstring, :Cuint], [\"%d\", :value])\n\"\"\"\nfunction ccall_macro_parse(expr::Expr)\n    # setup and check for errors\n    if !Meta.isexpr(expr, :(::))\n        throw(ArgumentError(\"@ccall needs a function signature with a return type\"))\n    end\n    rettype = expr.args[2]\n\n    call = expr.args[1]\n    if !Meta.isexpr(call, :call)\n        throw(ArgumentError(\"@ccall has to take a function call\"))\n    end\n\n    # get the function symbols\n    func = let f = call.args[1]\n        if Meta.isexpr(f, :.)\n            :(($(f.args[2]), $(f.args[1])))\n        elseif Meta.isexpr(f, :$)\n            f\n        elseif f isa Symbol\n            QuoteNode(f)\n        else\n            throw(ArgumentError(\"@ccall function name must be a symbol, a `.` node (e.g. `libc.printf`) or an interpolated function pointer (with `\\$`)\"))\n        end\n    end\n\n    # detect varargs\n    varargs = nothing\n    argstart = 2\n    callargs = call.args\n    if length(callargs) >= 2 && Meta.isexpr(callargs[2], :parameters)\n        argstart = 3\n        varargs = callargs[2].args\n    end\n\n    # collect args and types\n    args = []\n    types = []\n\n    function pusharg!(arg)\n        if !Meta.isexpr(arg, :(::))\n            throw(ArgumentError(\"args in @ccall need type annotations. '$arg' doesn't have one.\"))\n        end\n        push!(args, arg.args[1])\n        push!(types, arg.args[2])\n    end\n\n    for i in argstart:length(callargs)\n        pusharg!(callargs[i])\n    end\n    # add any varargs if necessary\n    nreq = 0\n    if !isnothing(varargs)\n        if length(args) == 0\n            throw(ArgumentError(\"C ABI prohibits vararg without one required argument\"))\n        end\n        nreq = length(args)\n        for a in varargs\n            pusharg!(a)\n        end\n    end\n\n    return func, rettype, types, args, nreq\nend\n\n\nfunction ccall_macro_lower(convention, func, rettype, types, args, nreq)\n    lowering = []\n    realargs = []\n    gcroots = []\n\n    # if interpolation was used, ensure  variable is a function pointer at runtime.\n    if Meta.isexpr(func, :$)\n        push!(lowering, Expr(:(=), :func, esc(func.args[1])))\n        name = QuoteNode(func.args[1])\n        func = :func\n        check = quote\n            if !isa(func, Ptr{Cvoid})\n                name = $name\n                throw(ArgumentError(\"interpolated function `$name` was not a Ptr{Cvoid}, but $(typeof(func))\"))\n            end\n        end\n        push!(lowering, check)\n    else\n        func = esc(func)\n    end\n\n    for (i, (arg, type)) in enumerate(zip(args, types))\n        sym = Symbol(string(\"arg\", i, \"root\"))\n        sym2 = Symbol(string(\"arg\", i, ))\n        earg, etype = esc(arg), esc(type)\n        push!(lowering, :(local $sym = $(GlobalRef(Base, :cconvert))($etype, $earg)))\n        push!(lowering, :(local $sym2 = $(GlobalRef(Base, :unsafe_convert))($etype, $sym)))\n        push!(realargs, sym2)\n        push!(gcroots, sym)\n    end\n    etypes = Expr(:call, Expr(:core, :svec), types...)\n    exp = Expr(:foreigncall,\n               func,\n               esc(rettype),\n               esc(etypes),\n               nreq,\n               QuoteNode(convention),\n               realargs..., gcroots...)\n    push!(lowering, exp)\n\n    return Expr(:block, lowering...)\nend\n\n\"\"\"\n    @ccall library.function_name(argvalue1::argtype1, ...)::returntype\n    @ccall function_name(argvalue1::argtype1, ...)::returntype\n    @ccall \\$function_pointer(argvalue1::argtype1, ...)::returntype\n\nCall a function in a C-exported shared library, specified by\n`library.function_name`, where `library` is a string constant or\nliteral. The library may be omitted, in which case the `function_name`\nis resolved in the current process. Alternatively, `@ccall` may\nalso be used to call a function pointer `\\$function_pointer`, such as\none returned by `dlsym`.\n\nEach `argvalue` to `@ccall` is converted to the corresponding\n`argtype`, by automatic insertion of calls to `unsafe_convert(argtype,\ncconvert(argtype, argvalue))`. (See also the documentation for\n[`unsafe_convert`](@ref Base.unsafe_convert) and [`cconvert`](@ref\nBase.cconvert) for further details.) In most cases, this simply\nresults in a call to `convert(argtype, argvalue)`.\n\n\n# Examples\n\n    @ccall strlen(s::Cstring)::Csize_t\n\nThis calls the C standard library function:\n\n    size_t strlen(char *)\n\nwith a Julia variable named `s`. See also `ccall`.\n\nVarargs are supported with the following convention:\n\n    @ccall printf(\"%s = %d\"::Cstring ; \"foo\"::Cstring, foo::Cint)::Cint\n\nThe semicolon is used to separate required arguments (of which there\nmust be at least one) from variadic arguments.\n\nExample using an external library:\n\n    # C signature of g_uri_escape_string:\n    # char *g_uri_escape_string(const char *unescaped, const char *reserved_chars_allowed, gboolean allow_utf8);\n\n    const glib = \"libglib-2.0\"\n    @ccall glib.g_uri_escape_string(my_uri::Cstring, \":/\"::Cstring, true::Cint)::Cstring\n\nThe string literal could also be used directly before the function\nname, if desired `\"libglib-2.0\".g_uri_escape_string(...`\n\"\"\"\nmacro ccall(expr)\n    return ccall_macro_lower(:ccall, ccall_macro_parse(expr)...)\nend\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/base/libdl.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nmodule Libdl\n@doc \"\"\"\nInterface to libdl. Provides dynamic linking support.\n\"\"\" Libdl\n\nimport Base.DL_LOAD_PATH\n\nexport DL_LOAD_PATH, RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL,\n    RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW, dlclose, dlopen, dlopen_e, dlsym, dlsym_e,\n    dlpath, find_library, dlext, dllist\n\n\"\"\"\n    DL_LOAD_PATH\n\nWhen calling [`dlopen`](@ref), the paths in this list will be searched first, in\norder, before searching the system locations for a valid library handle.\n\"\"\"\nDL_LOAD_PATH\n\n# note: constants to match JL_RTLD_* in src/julia.h, translated\n#       to system-specific values by JL_RTLD macro in src/dlload.c\nconst RTLD_LOCAL     = 0x00000001\nconst RTLD_GLOBAL    = 0x00000002\nconst RTLD_LAZY      = 0x00000004\nconst RTLD_NOW       = 0x00000008\nconst RTLD_NODELETE  = 0x00000010\nconst RTLD_NOLOAD    = 0x00000020\nconst RTLD_DEEPBIND  = 0x00000040\nconst RTLD_FIRST     = 0x00000080\n\n\"\"\"\n    RTLD_DEEPBIND\n    RTLD_FIRST\n    RTLD_GLOBAL\n    RTLD_LAZY\n    RTLD_LOCAL\n    RTLD_NODELETE\n    RTLD_NOLOAD\n    RTLD_NOW\n\nEnum constant for [`dlopen`](@ref). See your platform man page for details, if\napplicable.\n\"\"\"\n(RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL, RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW)\n\n\"\"\"\n    dlsym(handle, sym; throw_error::Bool = true)\n\nLook up a symbol from a shared library handle, return callable function pointer on success.\n\nIf the symbol cannot be found, this method throws an error, unless the keyword argument\n`throw_error` is set to `false`, in which case this method returns `nothing`.\n\"\"\"\nfunction dlsym(hnd::Ptr, s::Union{Symbol,AbstractString}; throw_error::Bool = true)\n    hnd == C_NULL && throw(ArgumentError(\"NULL library handle\"))\n    val = Ref(Ptr{Cvoid}(0))\n    symbol_found = ccall(:jl_dlsym, Cint,\n        (Ptr{Cvoid}, Cstring, Ref{Ptr{Cvoid}}, Cint),\n        hnd, s, val, Int64(throw_error)\n    )\n    if symbol_found == 0\n        return nothing\n    end\n    return val[]\nend\n\n\"\"\"\n    dlsym_e(handle, sym)\n\nLook up a symbol from a shared library handle, silently return `C_NULL` on lookup failure.\nThis method is now deprecated in favor of `dlsym(handle, sym; throw_error=false)`.\n\"\"\"\nfunction dlsym_e(hnd::Ptr, s::Union{Symbol,AbstractString})\n    return something(dlsym(hnd, s; throw_error=false), C_NULL)\nend\n\n\"\"\"\n    dlopen(libfile::AbstractString [, flags::Integer]; throw_error:Bool = true)\n\nLoad a shared library, returning an opaque handle.\n\nThe extension given by the constant `dlext` (`.so`, `.dll`, or `.dylib`)\ncan be omitted from the `libfile` string, as it is automatically appended\nif needed.   If `libfile` is not an absolute path name, then the paths\nin the array `DL_LOAD_PATH` are searched for `libfile`, followed by the\nsystem load path.\n\nThe optional flags argument is a bitwise-or of zero or more of `RTLD_LOCAL`, `RTLD_GLOBAL`,\n`RTLD_LAZY`, `RTLD_NOW`, `RTLD_NODELETE`, `RTLD_NOLOAD`, `RTLD_DEEPBIND`, and `RTLD_FIRST`.\nThese are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS)\ndlopen command, if possible, or are ignored if the specified functionality is not available\non the current platform. The default flags are platform specific. On MacOS the default\n`dlopen` flags are `RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL` while on other platforms the\ndefaults are `RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL`. An important usage of these flags is to\nspecify non default behavior for when the dynamic library loader binds library references to\nexported symbols and if the bound references are put into process local or global scope. For\ninstance `RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL` allows the library's symbols to be available\nfor usage in other shared libraries, addressing situations where there are dependencies\nbetween shared libraries.\n\nIf the library cannot be found, this method throws an error, unless the keyword argument\n`throw_error` is set to `false`, in which case this method returns `nothing`.\n\n!!! note\n     From Julia 1.6 on, this method replaces paths starting with `@executable_path/` with\n     the path to the Julia executable, allowing for relocatable relative-path loads. In\n     Julia 1.5 and earlier, this only worked on macOS.\n\"\"\"\nfunction dlopen end\n\ndlopen(s::Symbol, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND; kwargs...) =\n    dlopen(string(s), flags; kwargs...)\n\nfunction dlopen(s::AbstractString, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND; throw_error::Bool = true)\n    ret = ccall(:jl_load_dynamic_library, Ptr{Cvoid}, (Cstring,UInt32,Cint), s, flags, Cint(throw_error))\n    if ret == C_NULL\n        return nothing\n    end\n    return ret\nend\n\n\"\"\"\n    dlopen(f::Function, args...; kwargs...)\n\nWrapper for usage with `do` blocks to automatically close the dynamic library once\ncontrol flow leaves the `do` block scope.\n\n# Example\n```julia\nvendor = dlopen(\"libblas\") do lib\n    if Libdl.dlsym(lib, :openblas_set_num_threads; throw_error=false) !== nothing\n        return :openblas\n    else\n        return :other\n    end\nend\n```\n\"\"\"\nfunction dlopen(f::Function, args...; kwargs...)\n    hdl = nothing\n    try\n        hdl = dlopen(args...; kwargs...)\n        f(hdl)\n    finally\n        dlclose(hdl)\n    end\nend\n\n\"\"\"\n    dlopen_e(libfile::AbstractString [, flags::Integer])\n\nSimilar to [`dlopen`](@ref), except returns `C_NULL` instead of raising errors.\nThis method is now deprecated in favor of `dlopen(libfile::AbstractString [, flags::Integer]; throw_error=false)`.\n\"\"\"\ndlopen_e(args...) = something(dlopen(args...; throw_error=false), C_NULL)\n\n\"\"\"\n    dlclose(handle)\n\nClose shared library referenced by handle.\n\"\"\"\nfunction dlclose(p::Ptr)\n    0 == ccall(:jl_dlclose, Cint, (Ptr{Cvoid},), p)\nend\n\n\"\"\"\n    dlclose(::Nothing)\n\nFor the very common pattern usage pattern of\n\n    try\n        hdl = dlopen(library_name)\n        ... do something\n    finally\n        dlclose(hdl)\n    end\n\nWe define a `dlclose()` method that accepts a parameter of type `Nothing`, so\nthat user code does not have to change its behavior for the case that `library_name`\nwas not found.\n\"\"\"\nfunction dlclose(p::Nothing)\nend\n\n\"\"\"\n    find_library(names, locations)\n\nSearches for the first library in `names` in the paths in the `locations` list,\n`DL_LOAD_PATH`, or system library paths (in that order) which can successfully be dlopen'd.\nOn success, the return value will be one of the names (potentially prefixed by one of the\npaths in locations). This string can be assigned to a `global const` and used as the library\nname in future `ccall`'s. On failure, it returns the empty string.\n\"\"\"\nfunction find_library(libnames, extrapaths=String[])\n    for lib in libnames\n        for path in extrapaths\n            l = joinpath(path, lib)\n            p = dlopen(l, RTLD_LAZY; throw_error=false)\n            if p !== nothing\n                dlclose(p)\n                return l\n            end\n        end\n        p = dlopen(lib, RTLD_LAZY; throw_error=false)\n        if p !== nothing\n            dlclose(p)\n            return lib\n        end\n    end\n    return \"\"\nend\nfind_library(libname::Union{Symbol,AbstractString}, extrapaths=String[]) =\n    find_library([string(libname)], extrapaths)\n\n\"\"\"\n    dlpath(handle::Ptr{Cvoid})\n\nGiven a library `handle` from `dlopen`, return the full path.\n\"\"\"\nfunction dlpath(handle::Ptr{Cvoid})\n    p = ccall(:jl_pathname_for_handle, Cstring, (Ptr{Cvoid},), handle)\n    s = unsafe_string(p)\n    Sys.iswindows() && Libc.free(p)\n    return s\nend\n\n\"\"\"\n    dlpath(libname::Union{AbstractString, Symbol})\n\nGet the full path of the library `libname`.\n\n# Example\n```julia-repl\njulia> dlpath(\"libjulia\")\n```\n\"\"\"\nfunction dlpath(libname::Union{AbstractString, Symbol})\n    handle = dlopen(libname)\n    path = dlpath(handle)\n    dlclose(handle)\n    return path\nend\n\nif Sys.isapple()\n    const dlext = \"dylib\"\nelseif Sys.iswindows()\n    const dlext = \"dll\"\nelse\n    #assume Sys.islinux, or similar\n    const dlext = \"so\"\nend\n\n\"\"\"\n    dlext\n\nFile extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.\n\"\"\"\ndlext\n\nif (Sys.islinux() || Sys.isbsd()) && !Sys.isapple()\n    struct dl_phdr_info\n        # Base address of object\n        addr::Cuint\n\n        # Null-terminated name of object\n        name::Ptr{UInt8}\n\n        # Pointer to array of ELF program headers for this object\n        phdr::Ptr{Cvoid}\n\n        # Number of program headers for this object\n        phnum::Cshort\n    end\n\n    # This callback function called by dl_iterate_phdr() on Linux and BSD's\n    # DL_ITERATE_PHDR(3) on freebsd\n    function dl_phdr_info_callback(di::dl_phdr_info, size::Csize_t, dynamic_libraries::Array{String,1})\n        name = unsafe_string(di.name)\n        push!(dynamic_libraries, name)\n        return Cint(0)\n    end\nend\n\n\"\"\"\n    dllist()\n\nReturn the paths of dynamic libraries currently loaded in a `Vector{String}`.\n\"\"\"\nfunction dllist()\n    dynamic_libraries = Vector{String}()\n\n    @static if Sys.isapple()\n        numImages = ccall(:_dyld_image_count, Cint, ())\n\n        # start at 1 instead of 0 to skip self\n        for i in 1:numImages-1\n            name = unsafe_string(ccall(:_dyld_get_image_name, Cstring, (UInt32,), i))\n            push!(dynamic_libraries, name)\n        end\n    elseif Sys.islinux() || Sys.isbsd()\n        callback = @cfunction(dl_phdr_info_callback, Cint,\n                              (Ref{dl_phdr_info}, Csize_t, Ref{Vector{String}}))\n        ccall(:dl_iterate_phdr, Cint, (Ptr{Cvoid}, Ref{Vector{String}}), callback, dynamic_libraries)\n        popfirst!(dynamic_libraries)\n        filter!(!isempty, dynamic_libraries)\n    elseif Sys.iswindows()\n        ccall(:jl_dllist, Cint, (Any,), dynamic_libraries)\n    else\n        # unimplemented\n    end\n\n    return dynamic_libraries\nend\n\nend # module Libdl\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/base/binaryplatforms.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nmodule BinaryPlatforms\n\nexport AbstractPlatform, Platform, HostPlatform, platform_dlext, tags, arch, os,\n       os_version, libc, compiler_abi, libgfortran_version, libstdcxx_version,\n       cxxstring_abi, parse_dl_name_version, detect_libgfortran_version,\n       detect_libstdcxx_version, detect_cxxstring_abi, call_abi, wordsize, triplet,\n       select_platform, platforms_match, platform_name\nimport .Libc.Libdl\n\n### Submodule with information about CPU features\ninclude(\"cpuid.jl\")\nusing .CPUID\n\n# This exists to ease compatibility with old-style Platform objects\nabstract type AbstractPlatform; end\n\n\"\"\"\n    Platform\n\nA `Platform` represents all relevant pieces of information that a julia process may need\nto know about its execution environment, such as the processor architecture, operating\nsystem, libc implementation, etc...  It is, at its heart, a key-value mapping of tags\n(such as `arch`, `os`, `libc`, etc...) to values (such as `\"arch\" => \"x86_64\"`, or\n`\"os\" => \"windows\"`, etc...).  `Platform` objects are extensible in that the tag mapping\nis open for users to add their own mappings to, as long as the mappings do not conflict\nwith the set of reserved tags: `arch`, `os`, `os_version`, `libc`, `call_abi`,\n`libgfortran_version`, `libstdcxx_version`, `cxxstring_abi` and `julia_version`.\n\nValid tags and values are composed of alphanumeric and period characters.  All tags and\nvalues will be lowercased when stored to reduce variation.\n\nExample:\n\n    Platform(\"x86_64\", \"windows\"; cuda = \"10.1\")\n\"\"\"\nstruct Platform <: AbstractPlatform\n    tags::Dict{String,String}\n    # The \"compare strategy\" allows selective overriding on how a tag is compared\n    compare_strategies::Dict{String,Function}\n\n    function Platform(arch::String, os::String;\n                      validate_strict::Bool = false,\n                      compare_strategies::Dict{String,<:Function} = Dict{String,Function}(),\n                      kwargs...)\n        # A wee bit of normalization\n        os = lowercase(os)\n        arch = CPUID.normalize_arch(arch)\n\n        tags = Dict{String,String}(\n            \"arch\" => arch,\n            \"os\" => os,\n        )\n        for (tag, value) in kwargs\n            tag = lowercase(string(tag::Symbol))\n            if tag \u2208 (\"arch\", \"os\")\n                throw(ArgumentError(\"Cannot double-pass key $(tag)\"))\n            end\n\n            # Drop `nothing` values; this means feature is not present or use default value.\n            if value === nothing\n                continue\n            end\n\n            # Normalize things that are known to be version numbers so that comparisons are easy.\n            # Note that in our effort to be extremely compatible, we actually allow something that\n            # doesn't parse nicely into a VersionNumber to persist, but if `validate_strict` is\n            # set to `true`, it will cause an error later on.\n            if tag \u2208 (\"libgfortran_version\", \"libstdcxx_version\", \"os_version\")\n                if isa(value, VersionNumber)\n                    value = string(value)\n                elseif isa(value, AbstractString)\n                    v = tryparse(VersionNumber, String(value))\n                    if isa(v, VersionNumber)\n                        value = string(v)\n                    end\n                end\n            end\n\n            # Use `add_tag!()` to add the tag to our collection of tags\n            add_tag!(tags, tag, string(value)::String)\n        end\n\n        # Auto-map call_abi and libc where necessary:\n        if os == \"linux\" && !haskey(tags, \"libc\")\n            # Default to `glibc` on Linux\n            tags[\"libc\"] = \"glibc\"\n        end\n        if os == \"linux\" && arch \u2208 (\"armv7l\", \"armv6l\") && \"call_abi\" \u2209 keys(tags)\n            # default `call_abi` to `eabihf` on 32-bit ARM\n            tags[\"call_abi\"] = \"eabihf\"\n        end\n\n        # If the user is asking for strict validation, do so.\n        if validate_strict\n            validate_tags(tags)\n        end\n\n        # By default, we compare julia_version only against major and minor versions:\n        if haskey(tags, \"julia_version\") && !haskey(compare_strategies, \"julia_version\")\n            compare_strategies[\"julia_version\"] = (a::String, b::String, a_comparator, b_comparator) -> begin\n                a = VersionNumber(a)\n                b = VersionNumber(b)\n                return a.major == b.major && a.minor == b.minor\n            end\n        end\n\n        return new(tags, compare_strategies)\n    end\nend\n\n# Simple tag insertion that performs a little bit of validation\nfunction add_tag!(tags::Dict{String,String}, tag::String, value::String)\n    # I know we said only alphanumeric and dots, but let's be generous so that we can expand\n    # our support in the future while remaining as backwards-compatible as possible.  The\n    # only characters that are absolutely disallowed right now are `-`, `+`, ` ` and things\n    # that are illegal in filenames:\n    nonos = raw\"\"\"+- /<>:\"'\\|?*\"\"\"\n    if any(occursin(nono, tag) for nono in nonos)\n        throw(ArgumentError(\"Invalid character in tag name \\\"$(tag)\\\"!\"))\n    end\n\n    # Normalize and reject nonos\n    value = lowercase(value)\n    if any(occursin(nono, value) for nono in nonos)\n        throw(ArgumentError(\"Invalid character in tag value \\\"$(value)\\\"!\"))\n    end\n    tags[tag] = value\n    return value\nend\n\n# Other `Platform` types can override this (I'm looking at you, `AnyPlatform`)\ntags(p::Platform) = p.tags\n\n# Make it act more like a dict\nBase.getindex(p::AbstractPlatform, k::String) = getindex(tags(p), k)\nBase.haskey(p::AbstractPlatform, k::String) = haskey(tags(p), k)\nfunction Base.setindex!(p::AbstractPlatform, v::String, k::String)\n    add_tag!(tags(p), k, v)\n    return p\nend\n\n# Hash definitino to ensure that it's stable\nfunction Base.hash(p::Platform, h::UInt)\n    h += 0x506c6174666f726d % UInt\n    h = hash(p.tags, h)\n    h = hash(p.compare_strategies, h)\n    return h\nend\n\n# Simple equality definition; for compatibility testing, use `platforms_match()`\nfunction Base.:(==)(a::Platform, b::Platform)\n    return a.tags == b.tags && a.compare_strategies == b.compare_strategies\nend\n\n\n# Allow us to easily serialize Platform objects\nfunction Base.repr(p::Platform; context=nothing)\n    str = string(\n        \"Platform(\",\n        repr(arch(p)),\n        \", \",\n        repr(os(p)),\n        \"; \",\n        join((\"$(k) = $(repr(v))\" for (k, v) in tags(p) if k \u2209 (\"arch\", \"os\")), \", \"),\n        \")\",\n    )\nend\n\n# Make showing the platform a bit more palatable\nfunction Base.show(io::IO, p::Platform)\n    str = string(platform_name(p), \" \", arch(p))\n    # Add on all the other tags not covered by os/arch:\n    other_tags = sort(collect(filter(kv -> kv[1] \u2209 (\"os\", \"arch\"), tags(p))))\n    if !isempty(other_tags)\n        str = string(str, \" {\", join([string(k, \"=\", v) for (k, v) in other_tags], \", \"), \"}\")\n    end\n    print(io, str)\nend\n\nfunction validate_tags(tags::Dict)\n    throw_invalid_key(k) = throw(ArgumentError(\"Key \\\"$(k)\\\" cannot have value \\\"$(tags[k])\\\"\"))\n    # Validate `arch`\n    if tags[\"arch\"] \u2209 (\"x86_64\", \"i686\", \"armv7l\", \"armv6l\", \"aarch64\", \"powerpc64le\")\n        throw_invalid_key(\"arch\")\n    end\n    # Validate `os`\n    if tags[\"os\"] \u2209 (\"linux\", \"macos\", \"freebsd\", \"windows\")\n        throw_invalid_key(\"os\")\n    end\n    # Validate `os`/`arch` combination\n    throw_os_mismatch() = throw(ArgumentError(\"Invalid os/arch combination: $(tags[\"os\"])/$(tags[\"arch\"])\"))\n    if tags[\"os\"] == \"windows\" && tags[\"arch\"] \u2209 (\"x86_64\", \"i686\", \"armv7l\", \"aarch64\")\n        throw_os_mismatch()\n    end\n    if tags[\"os\"] == \"macos\" && tags[\"arch\"] \u2209 (\"x86_64\", \"aarch64\")\n        throw_os_mismatch()\n    end\n\n    # Validate `os`/`libc` combination\n    throw_libc_mismatch() = throw(ArgumentError(\"Invalid os/libc combination: $(tags[\"os\"])/$(tags[\"libc\"])\"))\n    if tags[\"os\"] == \"linux\"\n        # Linux always has a `libc` entry\n        if tags[\"libc\"] \u2209 (\"glibc\", \"musl\")\n            throw_libc_mismatch()\n        end\n    else\n        # Nothing else is allowed to have a `libc` entry\n        if haskey(tags, \"libc\")\n            throw_libc_mismatch()\n        end\n    end\n\n    # Validate `os`/`arch`/`call_abi` combination\n    throw_call_abi_mismatch() = throw(ArgumentError(\"Invalid os/arch/call_abi combination: $(tags[\"os\"])/$(tags[\"arch\"])/$(tags[\"call_abi\"])\"))\n    if tags[\"os\"] == \"linux\" && tags[\"arch\"] \u2208 (\"armv7l\", \"armv6l\")\n        # If an ARM linux has does not have `call_abi` set to something valid, be sad.\n        if !haskey(tags, \"call_abi\") || tags[\"call_abi\"] \u2209 (\"eabihf\", \"eabi\")\n            throw_call_abi_mismatch()\n        end\n    else\n        # Nothing else should have a `call_abi`.\n        if haskey(tags, \"call_abi\")\n            throw_call_abi_mismatch()\n        end\n    end\n\n    # Validate `libgfortran_version` is a parsable `VersionNumber`\n    throw_version_number(k) = throw(ArgumentError(\"\\\"$(k)\\\" cannot have value \\\"$(tags[k])\\\", must be a valid VersionNumber\"))\n    if \"libgfortran_version\" in keys(tags) && tryparse(VersionNumber, tags[\"libgfortran_version\"]) === nothing\n        throw_version_number(\"libgfortran_version\")\n    end\n\n    # Validate `cxxstring_abi` is one of the two valid options:\n    if \"cxxstring_abi\" in keys(tags) && tags[\"cxxstring_abi\"] \u2209 (\"cxx03\", \"cxx11\")\n        throw_invalid_key(\"cxxstring_abi\")\n    end\n\n    # Validate `libstdcxx_version` is a parsable `VersionNumber`\n    if \"libstdcxx_version\" in keys(tags) && tryparse(VersionNumber, tags[\"libstdcxx_version\"]) === nothing\n        throw_version_number(\"libstdcxx_version\")\n    end\nend\n\nfunction set_compare_strategy!(p::Platform, key::String, f::Function)\n    if !haskey(p.tags, key)\n        throw(ArgumentError(\"Cannot set comparison strategy for nonexistant tag $(key)!\"))\n    end\n    p.compare_strategies[key] = f\nend\n\nfunction get_compare_strategy(p::Platform, key::String, default = compare_default)\n    if !haskey(p.tags, key)\n        throw(ArgumentError(\"Cannot get comparison strategy for nonexistant tag $(key)!\"))\n    end\n    return get(p.compare_strategies, key, default)\nend\nget_compare_strategy(p::AbstractPlatform, key::String, default = compare_default) = default\n\n\n\n\"\"\"\n    compare_default(a::String, b::String, a_requested::Bool, b_requested::Bool)\n\nDefault comparison strategy that falls back to `a == b`.  This only ever happens if both\n`a` and `b` request this strategy, as any other strategy is preferrable to this one.\n\"\"\"\nfunction compare_default(a::String, b::String, a_requested::Bool, b_requested::Bool)\n    return a == b\nend\n\n\"\"\"\n    compare_version_cap(a::String, b::String, a_comparator, b_comparator)\n\nExample comparison strategy for `set_comparison_strategy!()` that implements a version\ncap for host platforms that support _up to_ a particular version number.  As an example,\nif an artifact is built for macOS 10.9, it can run on macOS 10.11, however if it were\nbuilt for macOS 10.12, it could not.  Therefore, the host platform of macOS 10.11 has a\nversion cap at `v\"10.11\"`.\n\nNote that because both hosts and artifacts are represented with `Platform` objects it\nis possible to call `platforms_match()` with two artifacts, a host and an artifact, an\nartifact and a host, and even two hosts.  We attempt to do something intelligent for all\ncases, but in the case of comparing version caps between two hosts, we return `true` only\nif the two host platforms are in fact identical.\n\"\"\"\nfunction compare_version_cap(a::String, b::String, a_requested::Bool, b_requested::Bool)\n    a = VersionNumber(a)\n    b = VersionNumber(b)\n\n    # If both b and a requested, then we fall back to equality:\n    if a_requested && b_requested\n        return a == b\n    end\n\n    # Otherwise, do the comparison between the the single version cap and the single version:\n    if a_requested\n        return b <= a\n    else\n        return a <= b\n    end\nend\n\n\n\n\"\"\"\n    HostPlatform(p::AbstractPlatform)\n\nConvert a `Platform` to act like a \"host\"; e.g. if it has a version-bound tag such as\n`\"libstdcxx_version\" => \"3.4.26\"`, it will treat that value as an upper bound, rather\nthan a characteristic.  `Platform` objects that define artifacts generally denote the\nSDK or version that the artifact was built with, but for platforms, these versions are\ngenerally the maximal version the platform can support.  The way this transformation\nis implemented is to change the appropriate comparison strategies to treat these pieces\nof data as bounds rather than points in any comparison.\n\"\"\"\nfunction HostPlatform(p::AbstractPlatform)\n    if haskey(p, \"os_version\")\n        set_compare_strategy!(p, \"os_version\", compare_version_cap)\n    end\n    if haskey(p, \"libstdcxx_version\")\n        set_compare_strategy!(p, \"libstdcxx_version\", compare_version_cap)\n    end\n    return p\nend\n\n\"\"\"\n    arch(p::AbstractPlatform)\n\nGet the architecture for the given `Platform` object as a `String`.\n\n# Examples\n```jldoctest\njulia> arch(Platform(\"aarch64\", \"Linux\"))\n\"aarch64\"\n\njulia> arch(Platform(\"amd64\", \"freebsd\"))\n\"x86_64\"\n```\n\"\"\"\narch(p::AbstractPlatform) = get(tags(p), \"arch\", nothing)\n\n\"\"\"\n    os(p::AbstractPlatform)\n\nGet the operating system for the given `Platform` object as a `String`.\n\n# Examples\n```jldoctest\njulia> os(Platform(\"armv7l\", \"Linux\"))\n\"linux\"\n\njulia> os(Platform(\"aarch64\", \"macos\"))\n\"macos\"\n```\n\"\"\"\nos(p::AbstractPlatform) = get(tags(p), \"os\", nothing)\n\n# As a special helper, it's sometimes useful to know the current OS at compile-time\nfunction os()\n    if Sys.iswindows()\n        return \"windows\"\n    elseif Sys.isapple()\n        return \"macos\"\n    elseif Sys.isbsd()\n        return \"freebsd\"\n    else\n        return \"linux\"\n    end\nend\n\n\"\"\"\n    libc(p::AbstractPlatform)\n\nGet the libc for the given `Platform` object as a `String`.  Returns `nothing` on\nplatforms with no explicit `libc` choices (which is most platforms).\n\n# Examples\n```jldoctest\njulia> libc(Platform(\"armv7l\", \"Linux\"))\n\"glibc\"\n\njulia> libc(Platform(\"aarch64\", \"linux\"; libc=\"musl\"))\n\"musl\"\n\njulia> libc(Platform(\"i686\", \"Windows\"))\n```\n\"\"\"\nlibc(p::AbstractPlatform) = get(tags(p), \"libc\", nothing)\n\n\"\"\"\n    call_abi(p::AbstractPlatform)\n\nGet the call ABI for the given `Platform` object as a `String`.  Returns `nothing` on\nplatforms with no explicit `call_abi` choices (which is most platforms).\n\n# Examples\n```jldoctest\njulia> call_abi(Platform(\"armv7l\", \"Linux\"))\n\"eabihf\"\n\njulia> call_abi(Platform(\"x86_64\", \"macos\"))\n```\n\"\"\"\ncall_abi(p::AbstractPlatform) = get(tags(p), \"call_abi\", nothing)\n\nconst platform_names = Dict(\n    \"linux\" => \"Linux\",\n    \"macos\" => \"macOS\",\n    \"windows\" => \"Windows\",\n    \"freebsd\" => \"FreeBSD\",\n    nothing => \"Unknown\",\n)\n\n\"\"\"\n    platform_name(p::AbstractPlatform)\n\nGet the \"platform name\" of the given platform, returning e.g. \"Linux\" or \"Windows\".\n\"\"\"\nfunction platform_name(p::AbstractPlatform)\n    return platform_names[os(p)]\nend\n\nfunction VNorNothing(d::Dict, key)\n    v = get(d, key, nothing)\n    if v === nothing\n        return nothing\n    end\n    return VersionNumber(v)::VersionNumber\nend\n\n\"\"\"\n    libgfortran_version(p::AbstractPlatform)\n\nGet the libgfortran version dictated by this `Platform` object as a `VersionNumber`,\nor `nothing` if no compatibility bound is imposed.\n\"\"\"\nlibgfortran_version(p::AbstractPlatform) = VNorNothing(tags(p), \"libgfortran_version\")\n\n\"\"\"\n    libstdcxx_version(p::AbstractPlatform)\n\nGet the libstdc++ version dictated by this `Platform` object, or `nothing` if no\ncompatibility bound is imposed.\n\"\"\"\nlibstdcxx_version(p::AbstractPlatform) = VNorNothing(tags(p), \"libstdcxx_version\")\n\n\"\"\"\n    cxxstring_abi(p::AbstractPlatform)\n\nGet the c++ string ABI dictated by this `Platform` object, or `nothing` if no ABI is imposed.\n\"\"\"\ncxxstring_abi(p::AbstractPlatform) = get(tags(p), \"cxxstring_abi\", nothing)\n\n\"\"\"\n    os_version(p::AbstractPlatform)\n\nGet the OS version dictated by this `Platform` object, or `nothing` if no OS version is\nimposed/no data is available.  This is most commonly used by MacOS and FreeBSD objects\nwhere we have high platform SDK fragmentation, and features are available only on certain\nplatform versions.\n\"\"\"\nos_version(p::AbstractPlatform) = VNorNothing(tags(p), \"os_version\")\n\n\"\"\"\n    wordsize(p::AbstractPlatform)\n\nGet the word size for the given `Platform` object.\n\n# Examples\n```jldoctest\njulia> wordsize(Platform(\"armv7l\", \"linux\"))\n32\n\njulia> wordsize(Platform(\"x86_64\", \"macos\"))\n64\n```\n\"\"\"\nwordsize(p::AbstractPlatform) = (arch(p) \u2208 (\"i686\", \"armv6l\", \"armv7l\")) ? 32 : 64\n\n\"\"\"\n    triplet(p::AbstractPlatform; exclude_tags::Vector{String})\n\nGet the target triplet for the given `Platform` object as a `String`.\n\n# Examples\n```jldoctest\njulia> triplet(Platform(\"x86_64\", \"MacOS\"))\n\"x86_64-apple-darwin\"\n\njulia> triplet(Platform(\"i686\", \"Windows\"))\n\"i686-w64-mingw32\"\n\njulia> triplet(Platform(\"armv7l\", \"Linux\"; libgfortran_version=\"3\"))\n\"armv7l-linux-gnueabihf-libgfortran3\"\n```\n\"\"\"\nfunction triplet(p::AbstractPlatform)\n    str = string(\n        arch(p)::Union{Symbol,String},\n        os_str(p),\n        libc_str(p),\n        call_abi_str(p),\n    )\n\n    # Tack on optional compiler ABI flags\n    if libgfortran_version(p) !== nothing\n        str = string(str, \"-libgfortran\", libgfortran_version(p).major)\n    end\n    if cxxstring_abi(p) !== nothing\n        str = string(str, \"-\", cxxstring_abi(p))\n    end\n    if libstdcxx_version(p) !== nothing\n        str = string(str, \"-libstdcxx\", libstdcxx_version(p).patch)\n    end\n\n    # Tack on all extra tags\n    for (tag, val) in tags(p)\n        if tag \u2208 (\"os\", \"arch\", \"libc\", \"call_abi\", \"libgfortran_version\", \"libstdcxx_version\", \"cxxstring_abi\", \"os_version\")\n            continue\n        end\n        str = string(str, \"-\", tag, \"+\", val)\n    end\n    return str\nend\n\nfunction os_str(p::AbstractPlatform)\n    if os(p) == \"linux\"\n        return \"-linux\"\n    elseif os(p) == \"macos\"\n        osvn = os_version(p)\n        if osvn !== nothing\n            return \"-apple-darwin$(osvn.major)\"\n        else\n            return \"-apple-darwin\"\n        end\n    elseif os(p) == \"windows\"\n        return \"-w64-mingw32\"\n    elseif os(p) == \"freebsd\"\n        osvn = os_version(p)\n        if osvn !== nothing\n            return \"-unknown-freebsd$(osvn.major).$(osvn.minor)\"\n        else\n            return \"-unknown-freebsd\"\n        end\n    else\n        return \"-unknown\"\n    end\nend\n\n# Helper functions for Linux and FreeBSD libc/abi mishmashes\nfunction libc_str(p::AbstractPlatform)\n    lc = libc(p)\n    if lc === nothing\n        return \"\"\n    elseif lc === \"glibc\"\n        return \"-gnu\"\n    else\n        return string(\"-\", lc)\n    end\nend\nfunction call_abi_str(p::AbstractPlatform)\n    cabi = call_abi(p)\n    cabi === nothing ? \"\" : string(cabi::Union{Symbol,String})\nend\n\nSys.isapple(p::AbstractPlatform) = os(p) == \"macos\"\nSys.islinux(p::AbstractPlatform) = os(p) == \"linux\"\nSys.iswindows(p::AbstractPlatform) = os(p) == \"windows\"\nSys.isfreebsd(p::AbstractPlatform) = os(p) == \"freebsd\"\nSys.isbsd(p::AbstractPlatform) = os(p) \u2208 (\"freebsd\", \"macos\")\n\nconst arch_mapping = Dict(\n    \"x86_64\" => \"(x86_|amd)64\",\n    \"i686\" => \"i\\\\d86\",\n    \"aarch64\" => \"(aarch64|arm64)\",\n    \"armv7l\" => \"arm(v7l)?\", # if we just see `arm-linux-gnueabihf`, we assume it's `armv7l`\n    \"armv6l\" => \"armv6l\",\n    \"powerpc64le\" => \"p(ower)?pc64le\",\n)\n# Keep this in sync with `CPUID.ISAs_by_family`\n# These are the CPUID side of the microarchitectures targeted by GCC flags in BinaryBuilder.jl\nconst arch_march_isa_mapping = let\n    function get_set(arch, name)\n        all = CPUID.ISAs_by_family[arch]\n        return all[findfirst(x -> x.first == name, all)].second\n    end\n    Dict(\n        \"i686\" => [\n            \"pentium4\" => get_set(\"i686\", \"pentium4\"),\n            \"prescott\" => get_set(\"i686\", \"prescott\"),\n        ],\n        \"x86_64\" => [\n            \"x86_64\" => get_set(\"x86_64\", \"x86_64\"),\n            \"avx\" => get_set(\"x86_64\", \"sandybridge\"),\n            \"avx2\" => get_set(\"x86_64\", \"haswell\"),\n            \"avx512\" => get_set(\"x86_64\", \"skylake_avx512\"),\n        ],\n        \"armv6l\" => [\n            \"arm1176jzfs\" => get_set(\"armv6l\", \"arm1176jzfs\"),\n        ],\n        \"armv7l\" => [\n            \"armv7l\" => get_set(\"armv7l\", \"armv7l\"),\n            \"neonvfpv4\" => get_set(\"armv7l\", \"armv7l+neon+vfpv4\"),\n        ],\n        \"aarch64\" => [\n            \"armv8_0\" => get_set(\"aarch64\", \"armv8.0-a\"),\n            \"armv8_1\" => get_set(\"aarch64\", \"armv8.1-a\"),\n            \"armv8_2_crypto\" => get_set(\"aarch64\", \"armv8.2-a+crypto\"),\n            \"armv8_4_crypto_sve\" => get_set(\"aarch64\", \"armv8.4-a+crypto+sve\"),\n        ],\n        \"powerpc64le\" => [\n            \"power8\" => get_set(\"powerpc64le\", \"power8\"),\n        ]\n    )\nend\nconst os_mapping = Dict(\n    \"macos\" => \"-apple-darwin[\\\\d\\\\.]*\",\n    \"freebsd\" => \"-(.*-)?freebsd[\\\\d\\\\.]*\",\n    \"windows\" => \"-w64-mingw32\",\n    \"linux\" => \"-(.*-)?linux\",\n)\nconst libc_mapping = Dict(\n    \"libc_nothing\" => \"\",\n    \"glibc\" => \"-gnu\",\n    \"musl\" => \"-musl\",\n)\nconst call_abi_mapping = Dict(\n    \"call_abi_nothing\" => \"\",\n    \"eabihf\" => \"eabihf\",\n    \"eabi\" => \"eabi\",\n)\nconst libgfortran_version_mapping = Dict(\n    \"libgfortran_nothing\" => \"\",\n    \"libgfortran3\" => \"(-libgfortran3)|(-gcc4)\", # support old-style `gccX` versioning\n    \"libgfortran4\" => \"(-libgfortran4)|(-gcc7)\",\n    \"libgfortran5\" => \"(-libgfortran5)|(-gcc8)\",\n)\nconst cxxstring_abi_mapping = Dict(\n    \"cxxstring_nothing\" => \"\",\n    \"cxx03\" => \"-cxx03\",\n    \"cxx11\" => \"-cxx11\",\n)\nconst libstdcxx_version_mapping = Dict{String,String}(\n    \"libstdcxx_nothing\" => \"\",\n    \"libstdcxx\" => \"-libstdcxx\\\\d+\",\n)\n\n\"\"\"\n    parse(::Type{Platform}, triplet::AbstractString)\n\nParses a string platform triplet back into a `Platform` object.\n\"\"\"\nfunction Base.parse(::Type{Platform}, triplet::AbstractString; validate_strict::Bool = false)\n    # Helper function to collapse dictionary of mappings down into a regex of\n    # named capture groups joined by \"|\" operators\n    c(mapping) = string(\"(\",join([\"(?<$k>$v)\" for (k, v) in mapping], \"|\"), \")\")\n\n    # We're going to build a mondo regex here to parse everything:\n    triplet_regex = Regex(string(\n        \"^\",\n        # First, the core triplet; arch/os/libc/call_abi\n        c(arch_mapping),\n        c(os_mapping),\n        c(libc_mapping),\n        c(call_abi_mapping),\n        # Next, optional things, like libgfortran/libstdcxx/cxxstring abi\n        c(libgfortran_version_mapping),\n        c(cxxstring_abi_mapping),\n        c(libstdcxx_version_mapping),\n        # Finally, the catch-all for extended tags\n        \"(?<tags>(?:-[^-]+\\\\+[^-]+)*)?\",\n        \"\\$\",\n    ))\n\n    m = match(triplet_regex, triplet)\n    if m !== nothing\n        # Helper function to find the single named field within the giant regex\n        # that is not `nothing` for each mapping we give it.\n        get_field(m, mapping) = begin\n            for k in keys(mapping)\n                if m[k] !== nothing\n                    # Convert our sentinel `nothing` values to actual `nothing`\n                    if endswith(k, \"_nothing\")\n                        return nothing\n                    end\n                    # Convert libgfortran/libstdcxx version numbers\n                    if startswith(k, \"libgfortran\")\n                        return VersionNumber(parse(Int,k[12:end]))\n                    elseif startswith(k, \"libstdcxx\")\n                        return VersionNumber(3, 4, parse(Int,m[k][11:end]))\n                    else\n                        return k\n                    end\n                end\n            end\n        end\n\n        # Extract the information we're interested in:\n        arch = get_field(m, arch_mapping)\n        os = get_field(m, os_mapping)\n        libc = get_field(m, libc_mapping)\n        call_abi = get_field(m, call_abi_mapping)\n        libgfortran_version = get_field(m, libgfortran_version_mapping)\n        libstdcxx_version = get_field(m, libstdcxx_version_mapping)\n        cxxstring_abi = get_field(m, cxxstring_abi_mapping)\n        function split_tags(tagstr)\n            tag_fields = filter(!isempty, split(tagstr, \"-\"))\n            if isempty(tag_fields)\n                return Pair{String,String}[]\n            end\n            return map(v -> Symbol(v[1]) => v[2], split.(tag_fields, \"+\"))\n        end\n        tags = split_tags(m[\"tags\"])\n\n        # Special parsing of os version number, if any exists\n        function extract_os_version(os_name, pattern)\n            m_osvn = match(pattern, m[os_name])\n            if m_osvn !== nothing\n                return VersionNumber(m_osvn.captures[1])\n            end\n            return nothing\n        end\n        os_version = nothing\n        if os == \"macos\"\n            os_version = extract_os_version(\"macos\", r\".*darwin([\\d\\.]+)\")\n        end\n        if os == \"freebsd\"\n            os_version = extract_os_version(\"freebsd\", r\".*freebsd([\\d.]+)\")\n        end\n\n        return Platform(\n            arch, os;\n            validate_strict,\n            libc,\n            call_abi,\n            libgfortran_version,\n            cxxstring_abi,\n            libstdcxx_version,\n            os_version,\n            tags...,\n        )\n    end\n    throw(ArgumentError(\"Platform `$(triplet)` is not an officially supported platform\"))\nend\n\nfunction Base.tryparse(::Type{Platform}, triplet::AbstractString)\n    try\n        parse(Platform, triplet)\n    catch e\n        if isa(e, InterruptException)\n            rethrow(e)\n        end\n        return nothing\n    end\nend\n\n\"\"\"\n    platform_dlext(p::AbstractPlatform = HostPlatform())\n\nReturn the dynamic library extension for the given platform, defaulting to the\ncurrently running platform.  E.g. returns \"so\" for a Linux-based platform,\n\"dll\" for a Windows-based platform, etc...\n\"\"\"\nfunction platform_dlext(p::AbstractPlatform = HostPlatform())\n    if os(p) == \"windows\"\n        return \"dll\"\n    elseif os(p) == \"macos\"\n        return \"dylib\"\n    else\n        return \"so\"\n    end\nend\n\n\"\"\"\n    parse_dl_name_version(path::String, platform::AbstractPlatform)\n\nGiven a path to a dynamic library, parse out what information we can\nfrom the filename.  E.g. given something like \"lib/libfoo.so.3.2\",\nthis function returns `\"libfoo\", v\"3.2\"`.  If the path name is not a\nvalid dynamic library, this method throws an error.  If no soversion\ncan be extracted from the filename, as in \"libbar.so\" this method\nreturns `\"libbar\", nothing`.\n\"\"\"\nfunction parse_dl_name_version(path::String, os::String)\n    # Use an extraction regex that matches the given OS\n    local dlregex\n    if os == \"windows\"\n        # On Windows, libraries look like `libnettle-6.dll`\n        dlregex = r\"^(.*?)(?:-((?:[\\.\\d]+)*))?\\.dll$\"\n    elseif os == \"macos\"\n        # On OSX, libraries look like `libnettle.6.3.dylib`\n        dlregex = r\"^(.*?)((?:\\.[\\d]+)*)\\.dylib$\"\n    else\n        # On Linux and FreeBSD, libraries look like `libnettle.so.6.3.0`\n        dlregex = r\"^(.*?)\\.so((?:\\.[\\d]+)*)$\"\n    end\n\n    m = match(dlregex, basename(path))\n    if m === nothing\n        throw(ArgumentError(\"Invalid dynamic library path '$path'\"))\n    end\n\n    # Extract name and version\n    name = m.captures[1]\n    version = m.captures[2]\n    if version === nothing || isempty(version)\n        version = nothing\n    else\n        version = VersionNumber(strip(version, '.'))\n    end\n    return name, version\nend\n\n# Adapter for `AbstractString`\nfunction parse_dl_name_version(path::AbstractString, os::AbstractString)\n    return parse_dl_name_version(string(path)::String, string(os)::String)\nend\n\n\"\"\"\n    detect_libgfortran_version()\n\nInspects the current Julia process to determine the libgfortran version this Julia is\nlinked against (if any).\n\"\"\"\nfunction detect_libgfortran_version()\n    libgfortran_paths = filter(x -> occursin(\"libgfortran\", x), Libdl.dllist())\n    if isempty(libgfortran_paths)\n        # One day, I hope to not be linking against libgfortran in base Julia\n        return nothing\n    end\n    libgfortran_path = first(libgfortran_paths)\n\n    name, version = parse_dl_name_version(libgfortran_path, os())\n    if version === nothing\n        # Even though we complain about this, we allow it to continue in the hopes that\n        # we shall march on to a BRIGHTER TOMORROW.  One in which we are not shackled\n        # by the constraints of libgfortran compiler ABIs upon our precious programming\n        # languages; one where the mistakes of yesterday are mere memories and not\n        # continual maintenance burdens upon the children of the dawn; one where numeric\n        # code may be cleanly implemented in a modern language and not bestowed onto the\n        # next generation by grizzled ancients, documented only with a faded yellow\n        # sticky note that bears a hastily-scribbled \"good luck\".\n        @warn(\"Unable to determine libgfortran version from '$(libgfortran_path)'\")\n    end\n    return version\nend\n\n\"\"\"\n    detect_libstdcxx_version(max_minor_version::Int=30)\n\nInspects the currently running Julia process to find out what version of libstdc++\nit is linked against (if any).  `max_minor_version` is the latest version in the\n3.4 series of GLIBCXX where the search is performed.\n\"\"\"\nfunction detect_libstdcxx_version(max_minor_version::Int=30)\n    libstdcxx_paths = filter(x -> occursin(\"libstdc++\", x), Libdl.dllist())\n    if isempty(libstdcxx_paths)\n        # This can happen if we were built by clang, so we don't link against\n        # libstdc++ at all.\n        return nothing\n    end\n\n    # Brute-force our way through GLIBCXX_* symbols to discover which version we're linked against\n    hdl = Libdl.dlopen(first(libstdcxx_paths))\n    # Try all GLIBCXX versions down to GCC v4.8:\n    # https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html\n    for minor_version in max_minor_version:-1:18\n        if Libdl.dlsym(hdl, \"GLIBCXX_3.4.$(minor_version)\"; throw_error=false) !== nothing\n            Libdl.dlclose(hdl)\n            return VersionNumber(\"3.4.$(minor_version)\")\n        end\n    end\n    Libdl.dlclose(hdl)\n    return nothing\nend\n\n\"\"\"\n    detect_cxxstring_abi()\n\nInspects the currently running Julia process to see what version of the C++11 string ABI\nit was compiled with (this is only relevant if compiled with `g++`; `clang` has no\nincompatibilities yet, bless its heart).  In reality, this actually checks for symbols\nwithin LLVM, but that is close enough for our purposes, as you can't mix configurations\nbetween Julia and LLVM; they must match.\n\"\"\"\nfunction detect_cxxstring_abi()\n    # First, if we're not linked against libstdc++, then early-exit because this doesn't matter.\n    libstdcxx_paths = filter(x -> occursin(\"libstdc++\", x), Libdl.dllist())\n    if isempty(libstdcxx_paths)\n        # We were probably built by `clang`; we don't link against `libstdc++`` at all.\n        return nothing\n    end\n\n    function open_libllvm(f::Function)\n        for lib_name in (\"libLLVM\", \"LLVM\", \"libLLVMSupport\")\n            hdl = Libdl.dlopen_e(lib_name)\n            if hdl != C_NULL\n                try\n                    return f(hdl)\n                finally\n                    Libdl.dlclose(hdl)\n                end\n            end\n        end\n        error(\"Unable to open libLLVM!\")\n    end\n\n    return open_libllvm() do hdl\n        # Check for llvm::sys::getProcessTriple(), first without cxx11 tag:\n        if Libdl.dlsym_e(hdl, \"_ZN4llvm3sys16getProcessTripleEv\") != C_NULL\n            return \"cxx03\"\n        elseif Libdl.dlsym_e(hdl, \"_ZN4llvm3sys16getProcessTripleB5cxx11Ev\") != C_NULL\n            return \"cxx11\"\n        else\n            @warn(\"Unable to find llvm::sys::getProcessTriple() in libLLVM!\")\n            return nothing\n        end\n    end\nend\n\n\"\"\"\n    host_triplet()\n\nBuild host triplet out of `Sys.MACHINE` and various introspective utilities that\ndetect compiler ABI values such as `libgfortran_version`, `libstdcxx_version` and\n`cxxstring_abi`.  We do this without using any `Platform` tech as it must run before\nwe have much of that built.\n\"\"\"\nfunction host_triplet()\n    str = Base.BUILD_TRIPLET\n\n    if !occursin(\"-libgfortran\", str)\n        libgfortran_version = detect_libgfortran_version()\n        if libgfortran_version !== nothing\n            str = string(str, \"-libgfortran\", libgfortran_version.major)\n        end\n    end\n\n    if !occursin(\"-cxx\", str)\n        cxxstring_abi = detect_cxxstring_abi()\n        if cxxstring_abi !== nothing\n            str = string(str, \"-\", cxxstring_abi)\n        end\n    end\n\n    if !occursin(\"-libstdcxx\", str)\n        libstdcxx_version = detect_libstdcxx_version()\n        if libstdcxx_version !== nothing\n            str = string(str, \"-libstdcxx\", libstdcxx_version.patch)\n        end\n    end\n\n    # Add on julia_version extended tag\n    if !occursin(\"-julia_version+\", str)\n        str = string(str, \"-julia_version+\", VersionNumber(VERSION.major, VERSION.minor, VERSION.patch))\n    end\n    return str\nend\n\n\"\"\"\n    HostPlatform()\n\nReturn the `Platform` object that corresponds to the current host system, with all\nrelevant comparison strategies set to host platform mode.  This is equivalent to:\n\n    HostPlatform(parse(Platform, Base.BinaryPlatforms.host_triplet()))\n\"\"\"\nfunction HostPlatform()\n    return HostPlatform(parse(Platform, host_triplet()))::Platform\nend\n\n\"\"\"\n    platforms_match(a::AbstractPlatform, b::AbstractPlatform)\n\nReturn `true` if `a` and `b` are matching platforms, where matching is determined by\ncomparing all keys contained within the platform objects, and if both objects contain\nentries for that key, they must match.  Comparison, by default, is performed using\nthe `==` operator, however this can be overridden on a key-by-key basis by adding\n\"comparison strategies\" through `set_compare_strategy!(platform, key, func)`.\n\nNote that as the comparison strategy is set on the `Platform` object, and not globally,\na custom comparison strategy is first looked for within the `a` object, then if none\nis found, it is looked for in the `b` object.  Finally, if none is found in either, the\ndefault of `==(ak, bk)` is used.  We throw an error if custom comparison strategies are\nused on both `a` and `b` and they are not the same custom comparison.\n\nThe reserved tags `os_version` and `libstdcxx_version` use this mechanism to provide\nbounded version constraints, where an artifact can specify that it was built using APIs\nonly available in macOS `v\"10.11\"` and later, or an artifact can state that it requires\na libstdc++ that is at least `v\"3.4.22\"`, etc...\n\"\"\"\nfunction platforms_match(a::AbstractPlatform, b::AbstractPlatform)\n    for k in union(keys(tags(a)::Dict{String,String}), keys(tags(b)::Dict{String,String}))\n        ak = get(tags(a), k, nothing)\n        bk = get(tags(b), k, nothing)\n\n        # Only continue if both `ak` and `bk` are not `nothing`\n        if ak === nothing || bk === nothing\n            continue\n        end\n\n        a_comp = get_compare_strategy(a, k)\n        b_comp = get_compare_strategy(b, k)\n\n        # Throw an error if `a` and `b` have both set non-default comparison strategies for `k`\n        # and they're not the same strategy.\n        if a_comp != compare_default && b_comp != compare_default && a_comp != b_comp\n            throw(ArgumentError(\"Cannot compare Platform objects with two different non-default comparison strategies for the same key \\\"$(k)\\\"\"))\n        end\n\n        # Select the custom comparator, if we have one.\n        comparator = a_comp\n        if b_comp != compare_default\n            comparator = b_comp\n        end\n\n        # Call the comparator, passing in which objects requested this comparison (one, the other, or both)\n        # For some comparators this doesn't matter, but for non-symmetrical comparisons, it does.\n        if !comparator(ak, bk, a_comp == comparator, b_comp == comparator)\n            return false\n        end\n    end\n    return true\nend\n\nfunction platforms_match(a::String, b::AbstractPlatform)\n    return platforms_match(parse(Platform, a), b)\nend\nfunction platforms_match(a::AbstractPlatform, b::String)\n    return platforms_match(a, parse(Platform, b))\nend\nplatforms_match(a::String, b::String) = platforms_match(parse(Platform, a), parse(Platform, b))\n\n# Adapters for AbstractString backedge avoidance\nplatforms_match(a::AbstractString, b::AbstractPlatform) = platforms_match(string(a)::String, b)\nplatforms_match(a::AbstractPlatform, b::AbstractString) = platforms_match(a, string(b)::String)\nplatforms_match(a::AbstractString, b::AbstractString) = platforms_match(string(a)::String, string(b)::String)\n\n\n\"\"\"\n    select_platform(download_info::Dict, platform::AbstractPlatform = HostPlatform())\n\nGiven a `download_info` dictionary mapping platforms to some value, choose\nthe value whose key best matches `platform`, returning `nothing` if no matches\ncan be found.\n\nPlatform attributes such as architecture, libc, calling ABI, etc... must all\nmatch exactly, however attributes such as compiler ABI can have wildcards\nwithin them such as `nothing` which matches any version of GCC.\n\"\"\"\nfunction select_platform(download_info::Dict, platform::AbstractPlatform = HostPlatform())\n    ps = collect(filter(p -> platforms_match(p, platform), keys(download_info)))\n\n    if isempty(ps)\n        return nothing\n    end\n\n    # At this point, we may have multiple possibilities.  E.g. if, in the future,\n    # Julia can be built without a direct dependency on libgfortran, we may match\n    # multiple tarballs that vary only within their libgfortran ABI.  To narrow it\n    # down, we just sort by triplet, then pick the last one.  This has the effect\n    # of generally choosing the latest release (e.g. a `libgfortran5` tarball\n    # rather than a `libgfortran3` tarball)\n    p = last(sort(ps, by = p -> triplet(p)))\n    return download_info[p]\nend\n\nend # module\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/base/docs/basedocs.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nmodule BaseDocs\n\n@nospecialize # don't specialize on any arguments of the methods declared herein\n\nstruct Keyword\n    name::Symbol\nend\nmacro kw_str(text)\n    return Keyword(Symbol(text))\nend\n\n\"\"\"\n**Welcome to Julia $(string(VERSION)).** The full manual is available at\n\n    https://docs.julialang.org\n\nas well as many great tutorials and learning resources:\n\n    https://julialang.org/learning/\n\nFor help on a specific function or macro, type `?` followed\nby its name, e.g. `?cos`, or `?@time`, and press enter.\nType `;` to enter shell mode, `]` to enter package mode.\n\"\"\"\nkw\"help\", kw\"Julia\", kw\"julia\", kw\"\"\n\n\"\"\"\n    using\n\n`using Foo` will load the module or package `Foo` and make its [`export`](@ref)ed names\navailable for direct use. Names can also be used via dot syntax (e.g. `Foo.foo` to access\nthe name `foo`), whether they are `export`ed or not.\nSee the [manual section about modules](@ref modules) for details.\n\"\"\"\nkw\"using\"\n\n\"\"\"\n    import\n\n`import Foo` will load the module or package `Foo`.\nNames from the imported `Foo` module can be accessed with dot syntax\n(e.g. `Foo.foo` to access the name `foo`).\nSee the [manual section about modules](@ref modules) for details.\n\"\"\"\nkw\"import\"\n\n\"\"\"\n    export\n\n`export` is used within modules to tell Julia which functions should be\nmade available to the user. For example: `export foo` makes the name\n`foo` available when [`using`](@ref) the module.\nSee the [manual section about modules](@ref modules) for details.\n\"\"\"\nkw\"export\"\n\n\"\"\"\n    abstract type\n\n`abstract type` declares a type that cannot be instantiated, and serves only as a node in the\ntype graph, thereby describing sets of related concrete types: those concrete types\nwhich are their descendants. Abstract types form the conceptual hierarchy which makes\nJulia\u2019s type system more than just a collection of object implementations. For example:\n\n```julia\nabstract type Number end\nabstract type Real <: Number end\n```\n[`Number`](@ref) has no supertype, whereas [`Real`](@ref) is an abstract subtype of `Number`.\n\"\"\"\nkw\"abstract type\", kw\"abstract\"\n\n\"\"\"\n    module\n\n`module` declares a [`Module`](@ref), which is a separate global variable workspace. Within a\nmodule, you can control which names from other modules are visible (via importing), and\nspecify which of your names are intended to be public (via exporting).\nModules allow you to create top-level definitions without worrying about name conflicts\nwhen your code is used together with somebody else\u2019s.\nSee the [manual section about modules](@ref modules) for more details.\n\n# Examples\n```julia\nmodule Foo\nimport Base.show\nexport MyType, foo\n\nstruct MyType\n    x\nend\n\nbar(x) = 2x\nfoo(a::MyType) = bar(a.x) + 1\nshow(io::IO, a::MyType) = print(io, \"MyType \\$(a.x)\")\nend\n```\n\"\"\"\nkw\"module\"\n\n\"\"\"\n    __init__\n\n`__init__()` function in your module would executes immediately *after* the module is loaded at\nruntime for the first time (i.e., it is only called once and only after all statements in the\nmodule have been executed). Because it is called *after* fully importing the module, `__init__`\nfunctions of submodules will be executed *first*. Two typical uses of `__init__` are calling\nruntime initialization functions of external C libraries and initializing global constants\nthat involve pointers returned by external libraries.\nSee the [manual section about modules](@ref modules) for more details.\n\n# Examples\n```julia\nconst foo_data_ptr = Ref{Ptr{Cvoid}}(0)\nfunction __init__()\n    ccall((:foo_init, :libfoo), Cvoid, ())\n    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Cvoid}, ())\n    nothing\nend\n```\n\"\"\"\nkw\"__init__\"\n\n\"\"\"\n    baremodule\n\n`baremodule` declares a module that does not contain `using Base` or local definitions of\n[`eval`](@ref Base.eval) and [`include`](@ref Base.include). It does still import `Core`. In other words,\n\n```julia\nmodule Mod\n\n...\n\nend\n```\n\nis equivalent to\n\n```julia\nbaremodule Mod\n\nusing Base\n\neval(x) = Core.eval(Mod, x)\ninclude(p) = Base.include(Mod, p)\n\n...\n\nend\n```\n\"\"\"\nkw\"baremodule\"\n\n\"\"\"\n    primitive type\n\n`primitive type` declares a concrete type whose data consists only of a series of bits. Classic\nexamples of primitive types are integers and floating-point values. Some example built-in\nprimitive type declarations:\n\n```julia\nprimitive type Char 32 end\nprimitive type Bool <: Integer 8 end\n```\nThe number after the name indicates how many bits of storage the type requires. Currently,\nonly sizes that are multiples of 8 bits are supported.\nThe [`Bool`](@ref) declaration shows how a primitive type can be optionally\ndeclared to be a subtype of some supertype.\n\"\"\"\nkw\"primitive type\"\n\n\"\"\"\n    macro\n\n`macro` defines a method for inserting generated code into a program.\nA macro maps a sequence of argument expressions to a returned expression, and the\nresulting expression is substituted directly into the program at the point where\nthe macro is invoked.\nMacros are a way to run generated code without calling [`eval`](@ref Base.eval), since the generated\ncode instead simply becomes part of the surrounding program.\nMacro arguments may include expressions, literal values, and symbols. Macros can be defined for\nvariable number of arguments (varargs), but do not accept keyword arguments.\nEvery macro also implicitly gets passed the arguments `__source__`, which contains the line number\nand file name the macro is called from, and `__module__`, which is the module the macro is expanded\nin.\n\n# Examples\n```jldoctest\njulia> macro sayhello(name)\n           return :( println(\"Hello, \", \\$name, \"!\") )\n       end\n@sayhello (macro with 1 method)\n\njulia> @sayhello \"Charlie\"\nHello, Charlie!\n\njulia> macro saylots(x...)\n           return :( println(\"Say: \", \\$(x...)) )\n       end\n@saylots (macro with 1 method)\n\njulia> @saylots \"hey \" \"there \" \"friend\"\nSay: hey there friend\n```\n\"\"\"\nkw\"macro\"\n\n\"\"\"\n    __module__\n\nThe argument `__module__` is only visible inside the macro, and it provides information\n(in the form of a `Module` object) about the expansion context of the macro invocation.\nSee the manual section on [Macro invocation](@ref) for more information.\n\"\"\"\nkw\"__module__\"\n\n\"\"\"\n    __source__\n\nThe argument `__source__` is only visible inside the macro, and it provides information\n(in the form of a `LineNumberNode` object) about the parser location of the `@` sign from\nthe macro invocation. See the manual section on [Macro invocation](@ref) for more information.\n\"\"\"\nkw\"__source__\"\n\n\"\"\"\n    local\n\n`local` introduces a new local variable.\nSee the [manual section on variable scoping](@ref scope-of-variables) for more information.\n\n# Examples\n```jldoctest\njulia> function foo(n)\n           x = 0\n           for i = 1:n\n               local x # introduce a loop-local x\n               x = i\n           end\n           x\n       end\nfoo (generic function with 1 method)\n\njulia> foo(10)\n0\n```\n\"\"\"\nkw\"local\"\n\n\"\"\"\n    global\n\n`global x` makes `x` in the current scope and its inner scopes refer to the global\nvariable of that name.\nSee the [manual section on variable scoping](@ref scope-of-variables) for more information.\n\n# Examples\n```jldoctest\njulia> z = 3\n3\n\njulia> function foo()\n           global z = 6 # use the z variable defined outside foo\n       end\nfoo (generic function with 1 method)\n\njulia> foo()\n6\n\njulia> z\n6\n```\n\"\"\"\nkw\"global\"\n\n\"\"\"\n    =\n\n`=` is the assignment operator.\n* For variable `a` and expression `b`, `a = b` makes `a` refer to the value of `b`.\n* For functions `f(x)`, `f(x) = x` defines a new function constant `f`, or adds a new method to `f` if `f` is already defined; this usage is equivalent to `function f(x); x; end`.\n* `a[i] = v` calls [`setindex!`](@ref)`(a,v,i)`.\n* `a.b = c` calls [`setproperty!`](@ref)`(a,:b,c)`.\n* Inside a function call, `f(a=b)` passes `b` as the value of keyword argument `a`.\n* Inside parentheses with commas, `(a=1,)` constructs a [`NamedTuple`](@ref).\n\n# Examples\nAssigning `a` to `b` does not create a copy of `b`; instead use [`copy`](@ref) or [`deepcopy`](@ref).\n\n```jldoctest\njulia> b = [1]; a = b; b[1] = 2; a\n1-element Array{Int64, 1}:\n 2\n\njulia> b = [1]; a = copy(b); b[1] = 2; a\n1-element Array{Int64, 1}:\n 1\n\n```\nCollections passed to functions are also not copied. Functions can modify (mutate) the contents of the objects their arguments refer to. (The names of functions which do this are conventionally suffixed with '!'.)\n```jldoctest\njulia> function f!(x); x[:] .+= 1; end\nf! (generic function with 1 method)\n\njulia> a = [1]; f!(a); a\n1-element Array{Int64, 1}:\n 2\n\n```\nAssignment can operate on multiple variables in parallel, taking values from an iterable:\n```jldoctest\njulia> a, b = 4, 5\n(4, 5)\n\njulia> a, b = 1:3\n1:3\n\njulia> a, b\n(1, 2)\n\n```\nAssignment can operate on multiple variables in series, and will return the value of the right-hand-most expression:\n```jldoctest\njulia> a = [1]; b = [2]; c = [3]; a = b = c\n1-element Array{Int64, 1}:\n 3\n\njulia> b[1] = 2; a, b, c\n([2], [2], [2])\n\n```\nAssignment at out-of-bounds indices does not grow a collection. If the collection is a [`Vector`](@ref) it can instead be grown with [`push!`](@ref) or [`append!`](@ref).\n```jldoctest\njulia> a = [1, 1]; a[3] = 2\nERROR: BoundsError: attempt to access 2-element Array{Int64, 1} at index [3]\n[...]\n\njulia> push!(a, 2, 3)\n4-element Array{Int64, 1}:\n 1\n 1\n 2\n 3\n\n```\nAssigning `[]` does not eliminate elements from a collection; instead use [`filter!`](@ref).\n```jldoctest\njulia> a = collect(1:3); a[a .<= 1] = []\nERROR: DimensionMismatch(\"tried to assign 0 elements to 1 destinations\")\n[...]\n\njulia> filter!(x -> x > 1, a) # in-place & thus more efficient than a = a[a .> 1]\n2-element Array{Int64, 1}:\n 2\n 3\n\n```\n\"\"\"\nkw\"=\"\n\n\"\"\"\n    .=\n\nPerform broadcasted assignment. The right-side argument is expanded as in\n[`broadcast`](@ref) and then assigned into the left-side argument in-place.\nFuses with other dotted operators in the same expression; i.e. the whole\nassignment expression is converted into a single loop.\n\n`A .= B` is similar to `broadcast!(identity, A, B)`.\n\n# Examples\n```jldoctest\njulia> A = zeros(4, 4); B = [1, 2, 3, 4];\n\njulia> A .= B\n4\u00d74 Array{Float64, 2}:\n 1.0  1.0  1.0  1.0\n 2.0  2.0  2.0  2.0\n 3.0  3.0  3.0  3.0\n 4.0  4.0  4.0  4.0\n\njulia> A\n4\u00d74 Array{Float64, 2}:\n 1.0  1.0  1.0  1.0\n 2.0  2.0  2.0  2.0\n 3.0  3.0  3.0  3.0\n 4.0  4.0  4.0  4.0\n```\n\"\"\"\nkw\".=\"\n\n\"\"\"\n    .\n\nThe dot operator is used to access fields or properties of objects and access\nvariables defined inside modules.\n\nIn general, `a.b` calls `getproperty(a, :b)` (see [`getproperty`](@ref Base.getproperty)).\n\n# Examples\n```jldoctest\njulia> z = 1 + 2im; z.im\n2\n\njulia> Iterators.product\nproduct (generic function with 1 method)\n```\n\"\"\"\nkw\".\"\n\n\"\"\"\n    let\n\n`let` statements create a new hard scope block and introduce new variable bindings\neach time they run. Whereas assignments might reassign a new value to an existing value location,\n`let` always creates a new location.\nThis difference is only detectable in the case of variables that outlive their scope via\nclosures. The `let` syntax accepts a comma-separated series of assignments and variable\nnames:\n\n```julia\nlet var1 = value1, var2, var3 = value3\n    code\nend\n```\nThe assignments are evaluated in order, with each right-hand side evaluated in the scope\nbefore the new variable on the left-hand side has been introduced. Therefore it makes\nsense to write something like `let x = x`, since the two `x` variables are distinct and\nhave separate storage.\n\"\"\"\nkw\"let\"\n\n\"\"\"\n    quote\n\n`quote` creates multiple expression objects in a block without using the explicit\n[`Expr`](@ref) constructor. For example:\n\n```julia\nex = quote\n    x = 1\n    y = 2\n    x + y\nend\n```\nUnlike the other means of quoting, `:( ... )`, this form introduces `QuoteNode` elements\nto the expression tree, which must be considered when directly manipulating the tree.\nFor other purposes, `:( ... )` and `quote .. end` blocks are treated identically.\n\"\"\"\nkw\"quote\"\n\n\"\"\"\n    {}\n\nCurly braces are used to specify [type parameters](@ref man-parametric-types).\n\nType parameters allow a single type declaration to introduce a whole family of\nnew types \u2014 one for each possible combination of parameter values. For example,\nthe [`Set`](@ref) type describes many possible types of sets; it uses one type\nparameter to describe the type of the elements it contains. The specific _parameterized_\ntypes `Set{Float64}` and `Set{Int64}` describe two _concrete_ types: both are\nsubtypes ([`<:`](@ref)) of `Set`, but the former has `Float64` elements and the latter\nhas `Int64` elements.\n\"\"\"\nkw\"{\", kw\"{}\", kw\"}\"\n\n\"\"\"\n    []\n\nSquare braces are used for [indexing](@ref man-array-indexing), [indexed assignment](@ref man-indexed-assignment),\n[array literals](@ref man-array-literals), and [array comprehensions](@ref man-comprehensions).\n\"\"\"\nkw\"[\", kw\"[]\", kw\"]\"\n\n\"\"\"\n    ()\n\nParentheses are used to group expressions, call functions, and construct [tuples](@ref Tuple) and [named tuples](@ref NamedTuple).\n\"\"\"\nkw\"(\", kw\"()\", kw\")\"\n\n\"\"\"\n    #\n\nThe number sign (or hash) character is used to begin a single-line comment.\n\"\"\"\nkw\"#\"\n\n\"\"\"\n    #= =#\n\nA multi-line comment begins with `#=` and ends with `=#`, and may be nested.\n\"\"\"\nkw\"#=\", kw\"=#\"\n\n\"\"\"\n    ;\n\nSemicolons are used as statement separators and mark the beginning of keyword arguments in function declarations or calls.\n\"\"\"\nkw\";\"\n\n\"\"\"\n    Expr(head::Symbol, args...)\n\nA type representing compound expressions in parsed julia code (ASTs).\nEach expression consists of a `head` `Symbol` identifying which kind of\nexpression it is (e.g. a call, for loop, conditional statement, etc.),\nand subexpressions (e.g. the arguments of a call).\nThe subexpressions are stored in a `Vector{Any}` field called `args`.\n\nSee the manual chapter on [Metaprogramming](@ref) and the developer\ndocumentation [Julia ASTs](@ref).\n\n# Examples\n```jldoctest\njulia> Expr(:call, :+, 1, 2)\n:(1 + 2)\n\njulia> dump(:(a ? b : c))\nExpr\n  head: Symbol if\n  args: Array{Any}((3,))\n    1: Symbol a\n    2: Symbol b\n    3: Symbol c\n```\n\"\"\"\nExpr\n\n\"\"\"\n    \\$\n\nInterpolation operator for interpolating into e.g. [strings](@ref string-interpolation)\nand [expressions](@ref man-expression-interpolation).\n\n# Examples\n```jldoctest\njulia> name = \"Joe\"\n\"Joe\"\n\njulia> \"My name is \\$name.\"\n\"My name is Joe.\"\n```\n\"\"\"\nkw\"$\"\n\n\"\"\"\n    const\n\n`const` is used to declare global variables whose values will not change. In almost all code\n(and particularly performance sensitive code) global variables should be declared\nconstant in this way.\n\n```julia\nconst x = 5\n```\n\nMultiple variables can be declared within a single `const`:\n```julia\nconst y, z = 7, 11\n```\n\nNote that `const` only applies to one `=` operation, therefore `const x = y = 1`\ndeclares `x` to be constant but not `y`. On the other hand, `const x = const y = 1`\ndeclares both `x` and `y` constant.\n\nNote that \"constant-ness\" does not extend into mutable containers; only the\nassociation between a variable and its value is constant.\nIf `x` is an array or dictionary (for example) you can still modify, add, or remove elements.\n\nIn some cases changing the value of a `const` variable gives a warning instead of\nan error.\nHowever, this can produce unpredictable behavior or corrupt the state of your program,\nand so should be avoided.\nThis feature is intended only for convenience during interactive use.\n\"\"\"\nkw\"const\"\n\n\"\"\"\n    function\n\nFunctions are defined with the `function` keyword:\n\n```julia\nfunction add(a, b)\n    return a + b\nend\n```\nOr the short form notation:\n\n```julia\nadd(a, b) = a + b\n```\n\nThe use of the [`return`](@ref) keyword is exactly the same as in other languages,\nbut is often optional. A function without an explicit `return` statement will return\nthe last expression in the function body.\n\"\"\"\nkw\"function\"\n\n\"\"\"\n    return\n\n`return x` causes the enclosing function to exit early, passing the given value `x`\nback to its caller. `return` by itself with no value is equivalent to `return nothing`\n(see [`nothing`](@ref)).\n\n```julia\nfunction compare(a, b)\n    a == b && return \"equal to\"\n    a < b ? \"less than\" : \"greater than\"\nend\n```\nIn general you can place a `return` statement anywhere within a function body, including\nwithin deeply nested loops or conditionals, but be careful with `do` blocks. For\nexample:\n\n```julia\nfunction test1(xs)\n    for x in xs\n        iseven(x) && return 2x\n    end\nend\n\nfunction test2(xs)\n    map(xs) do x\n        iseven(x) && return 2x\n        x\n    end\nend\n```\nIn the first example, the return breaks out of `test1` as soon as it hits\nan even number, so `test1([5,6,7])` returns `12`.\n\nYou might expect the second example to behave the same way, but in fact the `return`\nthere only breaks out of the *inner* function (inside the `do` block) and gives a value\nback to `map`. `test2([5,6,7])` then returns `[5,12,7]`.\n\nWhen used in a top-level expression (i.e. outside any function), `return` causes\nthe entire current top-level expression to terminate early.\n\"\"\"\nkw\"return\"\n\n\"\"\"\n    if/elseif/else\n\n`if`/`elseif`/`else` performs conditional evaluation, which allows portions of code to\nbe evaluated or not evaluated depending on the value of a boolean expression. Here is\nthe anatomy of the `if`/`elseif`/`else` conditional syntax:\n\n```julia\nif x < y\n    println(\"x is less than y\")\nelseif x > y\n    println(\"x is greater than y\")\nelse\n    println(\"x is equal to y\")\nend\n```\nIf the condition expression `x < y` is true, then the corresponding block is evaluated;\notherwise the condition expression `x > y` is evaluated, and if it is true, the\ncorresponding block is evaluated; if neither expression is true, the `else` block is\nevaluated. The `elseif` and `else` blocks are optional, and as many `elseif` blocks as\ndesired can be used.\n\nIn contrast to some other languages conditions must be of type `Bool`. It does not\nsuffice for conditions to be convertible to `Bool`.\n```jldoctest\njulia> if 1 end\nERROR: TypeError: non-boolean (Int64) used in boolean context\n```\n\"\"\"\nkw\"if\", kw\"elseif\", kw\"else\"\n\n\"\"\"\n    a ? b : c\n\nShort form for conditionals; read \"if `a`, evaluate `b` otherwise evaluate `c`\".\nAlso known as the [ternary operator](https://en.wikipedia.org/wiki/%3F:).\n\nThis syntax is equivalent to `if a; b else c end`, but is often used to\nemphasize the value `b`-or-`c` which is being used as part of a larger\nexpression, rather than the side effects that evaluating `b` or `c` may have.\n\nSee the manual section on [control flow](@ref man-conditional-evaluation) for more details.\n\n# Examples\n```\njulia> x = 1; y = 2;\n\njulia> println(x > y ? \"x is larger\" : \"y is larger\")\ny is larger\n```\n\"\"\"\nkw\"?\", kw\"?:\"\n\n\"\"\"\n    for\n\n`for` loops repeatedly evaluate a block of statements while\niterating over a sequence of values.\n\n# Examples\n```jldoctest\njulia> for i in [1, 4, 0]\n           println(i)\n       end\n1\n4\n0\n```\n\"\"\"\nkw\"for\"\n\n\"\"\"\n    while\n\n`while` loops repeatedly evaluate a conditional expression, and continue evaluating the\nbody of the while loop as long as the expression remains true. If the condition\nexpression is false when the while loop is first reached, the body is never evaluated.\n\n# Examples\n```jldoctest\njulia> i = 1\n1\n\njulia> while i < 5\n           println(i)\n           global i += 1\n       end\n1\n2\n3\n4\n```\n\"\"\"\nkw\"while\"\n\n\"\"\"\n    end\n\n`end` marks the conclusion of a block of expressions, for example\n[`module`](@ref), [`struct`](@ref), [`mutable struct`](@ref),\n[`begin`](@ref), [`let`](@ref), [`for`](@ref) etc.\n`end` may also be used when indexing into an array to represent\nthe last index of a dimension.\n\n# Examples\n```jldoctest\njulia> A = [1 2; 3 4]\n2\u00d72 Array{Int64, 2}:\n 1  2\n 3  4\n\njulia> A[end, :]\n2-element Array{Int64, 1}:\n 3\n 4\n```\n\"\"\"\nkw\"end\"\n\n\"\"\"\n    try/catch\n\nA `try`/`catch` statement allows intercepting errors (exceptions) thrown\nby [`throw`](@ref) so that program execution can continue.\nFor example, the following code attempts to write a file, but warns the user\nand proceeds instead of terminating execution if the file cannot be written:\n\n```julia\ntry\n    open(\"/danger\", \"w\") do f\n        println(f, \"Hello\")\n    end\ncatch\n    @warn \"Could not write file.\"\nend\n```\n\nor, when the file cannot be read into a variable:\n\n```julia\nlines = try\n    open(\"/danger\", \"r\") do f\n        readlines(f)\n    end\ncatch\n    @warn \"File not found.\"\nend\n```\n\nThe syntax `catch e` (where `e` is any variable) assigns the thrown\nexception object to the given variable within the `catch` block.\n\nThe power of the `try`/`catch` construct lies in the ability to unwind a deeply\nnested computation immediately to a much higher level in the stack of calling functions.\n\"\"\"\nkw\"try\", kw\"catch\"\n\n\"\"\"\n    finally\n\nRun some code when a given block of code exits, regardless\nof how it exits. For example, here is how we can guarantee that an opened file is\nclosed:\n\n```julia\nf = open(\"file\")\ntry\n    operate_on_file(f)\nfinally\n    close(f)\nend\n```\n\nWhen control leaves the [`try`](@ref) block (for example, due to a [`return`](@ref), or just finishing\nnormally), [`close(f)`](@ref) will be executed. If the `try` block exits due to an exception,\nthe exception will continue propagating. A `catch` block may be combined with `try` and\n`finally` as well. In this case the `finally` block will run after `catch` has handled\nthe error.\n\"\"\"\nkw\"finally\"\n\n\"\"\"\n    break\n\nBreak out of a loop immediately.\n\n# Examples\n```jldoctest\njulia> i = 0\n0\n\njulia> while true\n           global i += 1\n           i > 5 && break\n           println(i)\n       end\n1\n2\n3\n4\n5\n```\n\"\"\"\nkw\"break\"\n\n\"\"\"\n    continue\n\nSkip the rest of the current loop iteration.\n\n# Examples\n```jldoctest\njulia> for i = 1:6\n           iseven(i) && continue\n           println(i)\n       end\n1\n3\n5\n```\n\"\"\"\nkw\"continue\"\n\n\"\"\"\n    do\n\nCreate an anonymous function and pass it as the first argument to\na function call.\nFor example:\n\n```julia\nmap(1:10) do x\n    2x\nend\n```\n\nis equivalent to `map(x->2x, 1:10)`.\n\nUse multiple arguments like so:\n\n```julia\nmap(1:10, 11:20) do x, y\n    x + y\nend\n```\n\"\"\"\nkw\"do\"\n\n\"\"\"\n    ...\n\nThe \"splat\" operator, `...`, represents a sequence of arguments.\n`...` can be used in function definitions, to indicate that the function\naccepts an arbitrary number of arguments.\n`...` can also be used to apply a function to a sequence of arguments.\n\n# Examples\n```jldoctest\njulia> add(xs...) = reduce(+, xs)\nadd (generic function with 1 method)\n\njulia> add(1, 2, 3, 4, 5)\n15\n\njulia> add([1, 2, 3]...)\n6\n\njulia> add(7, 1:100..., 1000:1100...)\n111107\n```\n\"\"\"\nkw\"...\"\n\n\"\"\"\n    ;\n\n`;` has a similar role in Julia as in many C-like languages, and is used to delimit the\nend of the previous statement. `;` is not necessary after new lines, but can be used to\nseparate statements on a single line or to join statements into a single expression.\n`;` is also used to suppress output printing in the REPL and similar interfaces.\n\n# Examples\n```julia\njulia> function foo()\n           x = \"Hello, \"; x *= \"World!\"\n           return x\n       end\nfoo (generic function with 1 method)\n\njulia> bar() = (x = \"Hello, Mars!\"; return x)\nbar (generic function with 1 method)\n\njulia> foo();\n\njulia> bar()\n\"Hello, Mars!\"\n```\n\"\"\"\nkw\";\"\n\n\"\"\"\n    x && y\n\nShort-circuiting boolean AND.\n\"\"\"\nkw\"&&\"\n\n\"\"\"\n    x || y\n\nShort-circuiting boolean OR.\n\"\"\"\nkw\"||\"\n\n\"\"\"\n    ccall((function_name, library), returntype, (argtype1, ...), argvalue1, ...)\n    ccall(function_name, returntype, (argtype1, ...), argvalue1, ...)\n    ccall(function_pointer, returntype, (argtype1, ...), argvalue1, ...)\n\nCall a function in a C-exported shared library, specified by the tuple `(function_name, library)`,\nwhere each component is either a string or symbol. Instead of specifying a library,\none can also use a `function_name` symbol or string, which is resolved in the current process.\nAlternatively, `ccall` may also be used to call a function pointer `function_pointer`, such as one returned by `dlsym`.\n\nNote that the argument type tuple must be a literal tuple, and not a tuple-valued\nvariable or expression.\n\nEach `argvalue` to the `ccall` will be converted to the corresponding\n`argtype`, by automatic insertion of calls to `unsafe_convert(argtype,\ncconvert(argtype, argvalue))`. (See also the documentation for\n[`unsafe_convert`](@ref Base.unsafe_convert) and [`cconvert`](@ref Base.cconvert) for further details.)\nIn most cases, this simply results in a call to `convert(argtype, argvalue)`.\n\"\"\"\nkw\"ccall\"\n\n\"\"\"\n    llvmcall(fun_ir::String, returntype, Tuple{argtype1, ...}, argvalue1, ...)\n    llvmcall((mod_ir::String, entry_fn::String), returntype, Tuple{argtype1, ...}, argvalue1, ...)\n    llvmcall((mod_bc::Vector{UInt8}, entry_fn::String), returntype, Tuple{argtype1, ...}, argvalue1, ...)\n\nCall the LLVM code provided in the first argument. There are several ways to specify this\nfirst argument:\n\n- as a literal string, representing function-level IR (similar to an LLVM `define` block),\n  with arguments are available as consecutive unnamed SSA variables (%0, %1, etc.);\n- as a 2-element tuple, containing a string of module IR and a string representing the name\n  of the entry-point function to call;\n- as a 2-element tuple, but with the module provided as an `Vector{UINt8}` with bitcode.\n\nNote that contrary to `ccall`, the argument types must be specified as a tuple type, and not\na tuple of types. All types, as well as the LLVM code, should be specified as literals, and\nnot as variables or expressions (it may be necessary to use `@eval` to generate these\nliterals).\n\nSee `test/llvmcall.jl` for usage examples.\n\"\"\"\nCore.Intrinsics.llvmcall\n\n\"\"\"\n    begin\n\n`begin...end` denotes a block of code.\n\n```julia\nbegin\n    println(\"Hello, \")\n    println(\"World!\")\nend\n```\n\nUsually `begin` will not be necessary, since keywords such as [`function`](@ref) and [`let`](@ref)\nimplicitly begin blocks of code. See also [`;`](@ref).\n\"\"\"\nkw\"begin\"\n\n\"\"\"\n    struct\n\nThe most commonly used kind of type in Julia is a struct, specified as a name and a\nset of fields.\n\n```julia\nstruct Point\n    x\n    y\nend\n```\n\nFields can have type restrictions, which may be parameterized:\n\n```julia\nstruct Point{X}\n    x::X\n    y::Float64\nend\n```\n\nA struct can also declare an abstract super type via `<:` syntax:\n\n```julia\nstruct Point <: AbstractPoint\n    x\n    y\nend\n```\n\n`struct`s are immutable by default; an instance of one of these types cannot\nbe modified after construction. Use [`mutable struct`](@ref) instead to declare a\ntype whose instances can be modified.\n\nSee the manual section on [Composite Types](@ref) for more details,\nsuch as how to define constructors.\n\"\"\"\nkw\"struct\"\n\n\"\"\"\n    mutable struct\n\n`mutable struct` is similar to [`struct`](@ref), but additionally allows the\nfields of the type to be set after construction. See the manual section on\n[Composite Types](@ref) for more information.\n\"\"\"\nkw\"mutable struct\"\n\n\"\"\"\n    new\n\nSpecial function available to inner constructors which created a new object\nof the type.\nSee the manual section on [Inner Constructor Methods](@ref man-inner-constructor-methods)\nfor more information.\n\"\"\"\nkw\"new\"\n\n\"\"\"\n    where\n\nThe `where` keyword creates a type that is an iterated union of other types, over all\nvalues of some variable. For example `Vector{T} where T<:Real` includes all [`Vector`](@ref)s\nwhere the element type is some kind of `Real` number.\n\nThe variable bound defaults to [`Any`](@ref) if it is omitted:\n\n```julia\nVector{T} where T    # short for `where T<:Any`\n```\nVariables can also have lower bounds:\n\n```julia\nVector{T} where T>:Int\nVector{T} where Int<:T<:Real\n```\nThere is also a concise syntax for nested `where` expressions. For example, this:\n\n```julia\nPair{T, S} where S<:Array{T} where T<:Number\n```\ncan be shortened to:\n\n```julia\nPair{T, S} where {T<:Number, S<:Array{T}}\n```\nThis form is often found on method signatures.\n\nNote that in this form, the variables are listed outermost-first. This matches the\norder in which variables are substituted when a type is \"applied\" to parameter values\nusing the syntax `T{p1, p2, ...}`.\n\"\"\"\nkw\"where\"\n\n\"\"\"\n    var\n\nThe syntax `var\"#example#\"` refers to a variable named `Symbol(\"#example#\")`,\neven though `#example#` is not a valid Julia identifier name.\n\nThis can be useful for interoperability with programming languages which have\ndifferent rules for the construction of valid identifiers. For example, to\nrefer to the `R` variable `draw.segments`, you can use `var\"draw.segments\"` in\nyour Julia code.\n\nIt is also used to `show` julia source code which has gone through macro\nhygiene or otherwise contains variable names which can't be parsed normally.\n\nNote that this syntax requires parser support so it is expanded directly by the\nparser rather than being implemented as a normal string macro `@var_str`.\n\n!!! compat \"Julia 1.3\"\n    This syntax requires at least Julia 1.3.\n\n\"\"\"\nkw\"var\\\"name\\\"\", kw\"@var_str\"\n\n\"\"\"\n    ans\n\nA variable referring to the last computed value, automatically set at the interactive prompt.\n\"\"\"\nkw\"ans\"\n\n\"\"\"\n    devnull\n\nUsed in a stream redirect to discard all data written to it. Essentially equivalent to\n`/dev/null` on Unix or `NUL` on Windows. Usage:\n\n```julia\nrun(pipeline(`cat test.txt`, devnull))\n```\n\"\"\"\ndevnull\n\n# doc strings for code in boot.jl and built-ins\n\n\"\"\"\n    Nothing\n\nA type with no fields that is the type of [`nothing`](@ref).\n\"\"\"\nNothing\n\n\"\"\"\n    nothing\n\nThe singleton instance of type [`Nothing`](@ref), used by convention when there is no value to return\n(as in a C `void` function) or when a variable or field holds no value.\n\"\"\"\nnothing\n\n\"\"\"\n    Core.TypeofBottom\n\nThe singleton type containing only the value `Union{}` (which represents the empty type).\n\"\"\"\nCore.TypeofBottom\n\n\"\"\"\n    Core.Type{T}\n\n`Core.Type` is an abstract type which has all type objects as its instances.\nThe only instance of the singleton type `Core.Type{T}` is the object\n`T`.\n\n# Examples\n```jldoctest\njulia> isa(Type{Float64}, Type)\ntrue\n\njulia> isa(Float64, Type)\ntrue\n\njulia> isa(Real, Type{Float64})\nfalse\n\njulia> isa(Real, Type{Real})\ntrue\n```\n\"\"\"\nCore.Type\n\n\"\"\"\n    DataType <: Type{T}\n\n`DataType` represents explicitly declared types that have names, explicitly\ndeclared supertypes, and, optionally, parameters.  Every concrete value in the\nsystem is an instance of some `DataType`.\n\n# Examples\n```jldoctest\njulia> typeof(Real)\nDataType\n\njulia> typeof(Int)\nDataType\n\njulia> struct Point\n           x::Int\n           y\n       end\n\njulia> typeof(Point)\nDataType\n```\n\"\"\"\nCore.DataType\n\n\"\"\"\n    Function\n\nAbstract type of all functions.\n\n# Examples\n```jldoctest\njulia> isa(+, Function)\ntrue\n\njulia> typeof(sin)\ntypeof(sin) (singleton type of function sin, subtype of Function)\n\njulia> ans <: Function\ntrue\n```\n\"\"\"\nFunction\n\n\"\"\"\n    ReadOnlyMemoryError()\n\nAn operation tried to write to memory that is read-only.\n\"\"\"\nReadOnlyMemoryError\n\n\"\"\"\n    ErrorException(msg)\n\nGeneric error type. The error message, in the `.msg` field, may provide more specific details.\n\n# Examples\n```jldoctest\njulia> ex = ErrorException(\"I've done a bad thing\");\n\njulia> ex.msg\n\"I've done a bad thing\"\n```\n\"\"\"\nErrorException\n\n\"\"\"\n    WrappedException(msg)\n\nGeneric type for `Exception`s wrapping another `Exception`, such as `LoadError` and\n`InitError`. Those exceptions contain information about the root cause of an\nexception. Subtypes define a field `error` containing the causing `Exception`.\n\"\"\"\nCore.WrappedException\n\n\"\"\"\n    UndefRefError()\n\nThe item or field is not defined for the given object.\n\n# Examples\n```jldoctest\njulia> struct MyType\n           a::Vector{Int}\n           MyType() = new()\n       end\n\njulia> A = MyType()\nMyType(#undef)\n\njulia> A.a\nERROR: UndefRefError: access to undefined reference\nStacktrace:\n[...]\n```\n\"\"\"\nUndefRefError\n\n\"\"\"\n    Float32(x [, mode::RoundingMode])\n\nCreate a `Float32` from `x`. If `x` is not exactly representable then `mode` determines how\n`x` is rounded.\n\n# Examples\n```jldoctest\njulia> Float32(1/3, RoundDown)\n0.3333333f0\n\njulia> Float32(1/3, RoundUp)\n0.33333334f0\n```\n\nSee [`RoundingMode`](@ref) for available rounding modes.\n\"\"\"\nFloat32(x)\n\n\"\"\"\n    Float64(x [, mode::RoundingMode])\n\nCreate a `Float64` from `x`. If `x` is not exactly representable then `mode` determines how\n`x` is rounded.\n\n# Examples\n```jldoctest\njulia> Float64(pi, RoundDown)\n3.141592653589793\n\njulia> Float64(pi, RoundUp)\n3.1415926535897936\n```\n\nSee [`RoundingMode`](@ref) for available rounding modes.\n\"\"\"\nFloat64(x)\n\n\"\"\"\n    OutOfMemoryError()\n\nAn operation allocated too much memory for either the system or the garbage collector to\nhandle properly.\n\"\"\"\nOutOfMemoryError\n\n\"\"\"\n    BoundsError([a],[i])\n\nAn indexing operation into an array, `a`, tried to access an out-of-bounds element at index `i`.\n\n# Examples\n```jldoctest; filter = r\"Stacktrace:(\\\\n \\\\[[0-9]+\\\\].*)*\"\njulia> A = fill(1.0, 7);\n\njulia> A[8]\nERROR: BoundsError: attempt to access 7-element Vector{Float64} at index [8]\n\n\njulia> B = fill(1.0, (2,3));\n\njulia> B[2, 4]\nERROR: BoundsError: attempt to access 2\u00d73 Matrix{Float64} at index [2, 4]\n\n\njulia> B[9]\nERROR: BoundsError: attempt to access 2\u00d73 Matrix{Float64} at index [9]\n\n```\n\"\"\"\nBoundsError\n\n\"\"\"\n    InexactError(name::Symbol, T, val)\n\nCannot exactly convert `val` to type `T` in a method of function `name`.\n\n# Examples\n```jldoctest\njulia> convert(Float64, 1+2im)\nERROR: InexactError: Float64(1 + 2im)\nStacktrace:\n[...]\n```\n\"\"\"\nInexactError\n\n\"\"\"\n    DomainError(val)\n    DomainError(val, msg)\n\nThe argument `val` to a function or constructor is outside the valid domain.\n\n# Examples\n```jldoctest\njulia> sqrt(-1)\nERROR: DomainError with -1.0:\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]\n```\n\"\"\"\nDomainError\n\n\"\"\"\n    Task(func)\n\nCreate a `Task` (i.e. coroutine) to execute the given function `func` (which must be\ncallable with no arguments). The task exits when this function returns.\n\n# Examples\n```jldoctest\njulia> a() = sum(i for i in 1:1000);\n\njulia> b = Task(a);\n```\n\nIn this example, `b` is a runnable `Task` that hasn't started yet.\n\"\"\"\nTask\n\n\"\"\"\n    StackOverflowError()\n\nThe function call grew beyond the size of the call stack. This usually happens when a call\nrecurses infinitely.\n\"\"\"\nStackOverflowError\n\n\"\"\"\n    nfields(x) -> Int\n\nGet the number of fields in the given object.\n\n# Examples\n```jldoctest\njulia> a = 1//2;\n\njulia> nfields(a)\n2\n\njulia> b = 1\n1\n\njulia> nfields(b)\n0\n\njulia> ex = ErrorException(\"I've done a bad thing\");\n\njulia> nfields(ex)\n1\n```\n\nIn these examples, `a` is a [`Rational`](@ref), which has two fields.\n`b` is an `Int`, which is a primitive bitstype with no fields at all.\n`ex` is an [`ErrorException`](@ref), which has one field.\n\"\"\"\nnfields\n\n\"\"\"\n    UndefVarError(var::Symbol)\n\nA symbol in the current scope is not defined.\n\n# Examples\n```jldoctest\njulia> a\nERROR: UndefVarError: a not defined\n\njulia> a = 1;\n\njulia> a\n1\n```\n\"\"\"\nUndefVarError\n\n\"\"\"\n    UndefKeywordError(var::Symbol)\n\nThe required keyword argument `var` was not assigned in a function call.\n\n# Examples\n```jldoctest; filter = r\"Stacktrace:(\\\\n \\\\[[0-9]+\\\\].*)*\"\njulia> function my_func(;my_arg)\n           return my_arg + 1\n       end\nmy_func (generic function with 1 method)\n\njulia> my_func()\nERROR: UndefKeywordError: keyword argument my_arg not assigned\nStacktrace:\n [1] my_func() at ./REPL[1]:2\n [2] top-level scope at REPL[2]:1\n```\n\"\"\"\nUndefKeywordError\n\n\"\"\"\n    OverflowError(msg)\n\nThe result of an expression is too large for the specified type and will cause a wraparound.\n\"\"\"\nOverflowError\n\n\"\"\"\n    TypeError(func::Symbol, context::AbstractString, expected::Type, got)\n\nA type assertion failure, or calling an intrinsic function with an incorrect argument type.\n\"\"\"\nTypeError\n\n\"\"\"\n    InterruptException()\n\nThe process was stopped by a terminal interrupt (CTRL+C).\n\nNote that, in Julia script started without `-i` (interactive) option,\n`InterruptException` is not thrown by default.  Calling\n[`Base.exit_on_sigint(false)`](@ref Base.exit_on_sigint) in the script\ncan recover the behavior of the REPL.  Alternatively, a Julia script\ncan be started with\n\n```sh\njulia -e \"include(popfirst!(ARGS))\" script.jl\n```\n\nto let `InterruptException` be thrown by CTRL+C during the execution.\n\"\"\"\nInterruptException\n\n\"\"\"\n    applicable(f, args...) -> Bool\n\nDetermine whether the given generic function has a method applicable to the given arguments.\n\nSee also [`hasmethod`](@ref).\n\n# Examples\n```jldoctest\njulia> function f(x, y)\n           x + y\n       end;\n\njulia> applicable(f, 1)\nfalse\n\njulia> applicable(f, 1, 2)\ntrue\n```\n\"\"\"\napplicable\n\n\"\"\"\n    invoke(f, argtypes::Type, args...; kwargs...)\n\nInvoke a method for the given generic function `f` matching the specified types `argtypes` on the\nspecified arguments `args` and passing the keyword arguments `kwargs`. The arguments `args` must\nconform with the specified types in `argtypes`, i.e. conversion is not automatically performed.\nThis method allows invoking a method other than the most specific matching method, which is useful\nwhen the behavior of a more general definition is explicitly needed (often as part of the\nimplementation of a more specific method of the same function).\n\nBe careful when using `invoke` for functions that you don't write.  What definition is used\nfor given `argtypes` is an implementation detail unless the function is explicitly states\nthat calling with certain `argtypes` is a part of public API.  For example, the change\nbetween `f1` and `f2` in the example below is usually considered compatible because the\nchange is invisible by the caller with a normal (non-`invoke`) call.  However, the change is\nvisible if you use `invoke`.\n\n# Examples\n```jldoctest\njulia> f(x::Real) = x^2;\n\njulia> f(x::Integer) = 1 + invoke(f, Tuple{Real}, x);\n\njulia> f(2)\n5\n\njulia> f1(::Integer) = Integer\n       f1(::Real) = Real;\n\njulia> f2(x::Real) = _f2(x)\n       _f2(::Integer) = Integer\n       _f2(_) = Real;\n\njulia> f1(1)\nInteger\n\njulia> f2(1)\nInteger\n\njulia> invoke(f1, Tuple{Real}, 1)\nReal\n\njulia> invoke(f2, Tuple{Real}, 1)\nInteger\n```\n\"\"\"\ninvoke\n\n\"\"\"\n    isa(x, type) -> Bool\n\nDetermine whether `x` is of the given `type`. Can also be used as an infix operator, e.g.\n`x isa type`.\n\n# Examples\n```jldoctest\njulia> isa(1, Int)\ntrue\n\njulia> isa(1, Matrix)\nfalse\n\njulia> isa(1, Char)\nfalse\n\njulia> isa(1, Number)\ntrue\n\njulia> 1 isa Number\ntrue\n```\n\"\"\"\nisa\n\n\"\"\"\n    DivideError()\n\nInteger division was attempted with a denominator value of 0.\n\n# Examples\n```jldoctest\njulia> 2/0\nInf\n\njulia> div(2, 0)\nERROR: DivideError: integer division error\nStacktrace:\n[...]\n```\n\"\"\"\nDivideError\n\n\"\"\"\n    Number\n\nAbstract supertype for all number types.\n\"\"\"\nNumber\n\n\"\"\"\n    Real <: Number\n\nAbstract supertype for all real numbers.\n\"\"\"\nReal\n\n\"\"\"\n    AbstractFloat <: Real\n\nAbstract supertype for all floating point numbers.\n\"\"\"\nAbstractFloat\n\n\"\"\"\n    Integer <: Real\n\nAbstract supertype for all integers.\n\"\"\"\nInteger\n\n\"\"\"\n    Signed <: Integer\n\nAbstract supertype for all signed integers.\n\"\"\"\nSigned\n\n\"\"\"\n    Unsigned <: Integer\n\nAbstract supertype for all unsigned integers.\n\"\"\"\nUnsigned\n\n\"\"\"\n    Bool <: Integer\n\nBoolean type, containing the values `true` and `false`.\n\n`Bool` is a kind of number: `false` is numerically\nequal to `0` and `true` is numerically equal to `1`.\nMoreover, `false` acts as a multiplicative \"strong zero\":\n\n```jldoctest\njulia> false == 0\ntrue\n\njulia> true == 1\ntrue\n\njulia> 0 * NaN\nNaN\n\njulia> false * NaN\n0.0\n```\n\"\"\"\nBool\n\nfor (bit, sign, exp, frac) in ((16, 1, 5, 10), (32, 1, 8, 23), (64, 1, 11, 52))\n    @eval begin\n        \"\"\"\n            Float$($bit) <: AbstractFloat\n\n        $($bit)-bit floating point number type (IEEE 754 standard).\n\n        Binary format: $($sign) sign, $($exp) exponent, $($frac) fraction bits.\n        \"\"\"\n        $(Symbol(\"Float\", bit))\n    end\nend\n\nfor bit in (8, 16, 32, 64, 128)\n    @eval begin\n        \"\"\"\n            Int$($bit) <: Signed\n\n        $($bit)-bit signed integer type.\n        \"\"\"\n        $(Symbol(\"Int\", bit))\n\n        \"\"\"\n            UInt$($bit) <: Unsigned\n\n        $($bit)-bit unsigned integer type.\n        \"\"\"\n        $(Symbol(\"UInt\", bit))\n    end\nend\n\n\"\"\"\n    Symbol\n\nThe type of object used to represent identifiers in parsed julia code (ASTs).\nAlso often used as a name or label to identify an entity (e.g. as a dictionary key).\n`Symbol`s can be entered using the `:` quote operator:\n```jldoctest\njulia> :name\n:name\n\njulia> typeof(:name)\nSymbol\n\njulia> x = 42\n42\n\njulia> eval(:x)\n42\n```\n`Symbol`s can also be constructed from strings or other values by calling the\nconstructor `Symbol(x...)`.\n\n`Symbol`s are immutable and should be compared using `===`.\nThe implementation re-uses the same object for all `Symbol`s with the same name,\nso comparison tends to be efficient (it can just compare pointers).\n\nUnlike strings, `Symbol`s are \"atomic\" or \"scalar\" entities that do not support\niteration over characters.\n\"\"\"\nSymbol\n\n\"\"\"\n    Symbol(x...) -> Symbol\n\nCreate a [`Symbol`](@ref) by concatenating the string representations of the arguments together.\n\n# Examples\n```jldoctest\njulia> Symbol(\"my\", \"name\")\n:myname\n\njulia> Symbol(\"day\", 4)\n:day4\n```\n\"\"\"\nSymbol(x...)\n\n\"\"\"\n    tuple(xs...)\n\nConstruct a tuple of the given objects.\n\n# Examples\n```jldoctest\njulia> tuple(1, 'a', pi)\n(1, 'a', \u03c0)\n```\n\"\"\"\ntuple\n\n\"\"\"\n    getfield(value, name::Symbol)\n    getfield(value, i::Int)\n\nExtract a field from a composite `value` by name or position.\nSee also [`getproperty`](@ref Base.getproperty) and [`fieldnames`](@ref).\n\n# Examples\n```jldoctest\njulia> a = 1//2\n1//2\n\njulia> getfield(a, :num)\n1\n\njulia> a.num\n1\n\njulia> getfield(a, 1)\n1\n```\n\"\"\"\ngetfield\n\n\"\"\"\n    setfield!(value, name::Symbol, x)\n\nAssign `x` to a named field in `value` of composite type.\nThe `value` must be mutable and `x` must be a subtype of `fieldtype(typeof(value), name)`.\nSee also [`setproperty!`](@ref Base.setproperty!).\n\n# Examples\n```jldoctest\njulia> mutable struct MyMutableStruct\n           field::Int\n       end\n\njulia> a = MyMutableStruct(1);\n\njulia> setfield!(a, :field, 2);\n\njulia> getfield(a, :field)\n2\n\njulia> a = 1//2\n1//2\n\njulia> setfield!(a, :num, 3);\nERROR: setfield! immutable struct of type Rational cannot be changed\n```\n\"\"\"\nsetfield!\n\n\"\"\"\n    typeof(x)\n\nGet the concrete type of `x`.\n\n# Examples\n```jldoctest\njulia> a = 1//2;\n\njulia> typeof(a)\nRational{Int64}\n\njulia> M = [1 2; 3.5 4];\n\njulia> typeof(M)\nMatrix{Float64} (alias for Array{Float64, 2})\n```\n\"\"\"\ntypeof\n\n\"\"\"\n    isdefined(m::Module, s::Symbol)\n    isdefined(object, s::Symbol)\n    isdefined(object, index::Int)\n\nTests whether a global variable or object field is defined. The arguments can be a module and a symbol\nor a composite object and field name (as a symbol) or index.\n\nTo test whether an array element is defined, use [`isassigned`](@ref) instead.\n\nSee also [`@isdefined`](@ref).\n\n# Examples\n```jldoctest\njulia> isdefined(Base, :sum)\ntrue\n\njulia> isdefined(Base, :NonExistentMethod)\nfalse\n\njulia> a = 1//2;\n\njulia> isdefined(a, 2)\ntrue\n\njulia> isdefined(a, 3)\nfalse\n\njulia> isdefined(a, :num)\ntrue\n\njulia> isdefined(a, :numerator)\nfalse\n```\n\"\"\"\nisdefined\n\n\n\"\"\"\n    Vector{T}(undef, n)\n\nConstruct an uninitialized [`Vector{T}`](@ref) of length `n`. See [`undef`](@ref).\n\n# Examples\n```julia-repl\njulia> Vector{Float64}(undef, 3)\n3-element Array{Float64, 1}:\n 6.90966e-310\n 6.90966e-310\n 6.90966e-310\n```\n\"\"\"\nVector{T}(::UndefInitializer, n)\n\n\"\"\"\n    Vector{T}(nothing, m)\n\nConstruct a [`Vector{T}`](@ref) of length `m`, initialized with\n[`nothing`](@ref) entries. Element type `T` must be able to hold\nthese values, i.e. `Nothing <: T`.\n\n# Examples\n```jldoctest\njulia> Vector{Union{Nothing, String}}(nothing, 2)\n2-element Vector{Union{Nothing, String}}:\n nothing\n nothing\n```\n\"\"\"\nVector{T}(::Nothing, n)\n\n\"\"\"\n    Vector{T}(missing, m)\n\nConstruct a [`Vector{T}`](@ref) of length `m`, initialized with\n[`missing`](@ref) entries. Element type `T` must be able to hold\nthese values, i.e. `Missing <: T`.\n\n# Examples\n```jldoctest\njulia> Vector{Union{Missing, String}}(missing, 2)\n2-element Vector{Union{Missing, String}}:\n missing\n missing\n```\n\"\"\"\nVector{T}(::Missing, n)\n\n\"\"\"\n    Matrix{T}(undef, m, n)\n\nConstruct an uninitialized [`Matrix{T}`](@ref) of size `m`\u00d7`n`. See [`undef`](@ref).\n\n# Examples\n```julia-repl\njulia> Matrix{Float64}(undef, 2, 3)\n2\u00d73 Array{Float64, 2}:\n 6.93517e-310  6.93517e-310  6.93517e-310\n 6.93517e-310  6.93517e-310  1.29396e-320\n```\n\"\"\"\nMatrix{T}(::UndefInitializer, m, n)\n\n\"\"\"\n    Matrix{T}(nothing, m, n)\n\nConstruct a [`Matrix{T}`](@ref) of size `m`\u00d7`n`, initialized with\n[`nothing`](@ref) entries. Element type `T` must be able to hold\nthese values, i.e. `Nothing <: T`.\n\n# Examples\n```jldoctest\njulia> Matrix{Union{Nothing, String}}(nothing, 2, 3)\n2\u00d73 Matrix{Union{Nothing, String}}:\n nothing  nothing  nothing\n nothing  nothing  nothing\n```\n\"\"\"\nMatrix{T}(::Nothing, m, n)\n\n\"\"\"\n    Matrix{T}(missing, m, n)\n\nConstruct a [`Matrix{T}`](@ref) of size `m`\u00d7`n`, initialized with\n[`missing`](@ref) entries. Element type `T` must be able to hold\nthese values, i.e. `Missing <: T`.\n\n# Examples\n```jldoctest\njulia> Matrix{Union{Missing, String}}(missing, 2, 3)\n2\u00d73 Matrix{Union{Missing, String}}:\n missing  missing  missing\n missing  missing  missing\n```\n\"\"\"\nMatrix{T}(::Missing, m, n)\n\n\"\"\"\n    Array{T}(undef, dims)\n    Array{T,N}(undef, dims)\n\nConstruct an uninitialized `N`-dimensional [`Array`](@ref)\ncontaining elements of type `T`. `N` can either be supplied explicitly,\nas in `Array{T,N}(undef, dims)`, or be determined by the length or number of `dims`.\n`dims` may be a tuple or a series of integer arguments corresponding to the lengths\nin each dimension. If the rank `N` is supplied explicitly, then it must\nmatch the length or number of `dims`. See [`undef`](@ref).\n\n# Examples\n```julia-repl\njulia> A = Array{Float64, 2}(undef, 2, 3) # N given explicitly\n2\u00d73 Array{Float64, 2}:\n 6.90198e-310  6.90198e-310  6.90198e-310\n 6.90198e-310  6.90198e-310  0.0\n\njulia> B = Array{Float64}(undef, 2) # N determined by the input\n2-element Array{Float64, 1}:\n 1.87103e-320\n 0.0\n```\n\"\"\"\nArray{T,N}(::UndefInitializer, dims)\n\n\"\"\"\n    Array{T}(nothing, dims)\n    Array{T,N}(nothing, dims)\n\nConstruct an `N`-dimensional [`Array`](@ref) containing elements of type `T`,\ninitialized with [`nothing`](@ref) entries. Element type `T` must be able\nto hold these values, i.e. `Nothing <: T`.\n\n# Examples\n```jldoctest\njulia> Array{Union{Nothing, String}}(nothing, 2)\n2-element Vector{Union{Nothing, String}}:\n nothing\n nothing\n\njulia> Array{Union{Nothing, Int}}(nothing, 2, 3)\n2\u00d73 Matrix{Union{Nothing, Int64}}:\n nothing  nothing  nothing\n nothing  nothing  nothing\n```\n\"\"\"\nArray{T,N}(::Nothing, dims)\n\n\n\"\"\"\n    Array{T}(missing, dims)\n    Array{T,N}(missing, dims)\n\nConstruct an `N`-dimensional [`Array`](@ref) containing elements of type `T`,\ninitialized with [`missing`](@ref) entries. Element type `T` must be able\nto hold these values, i.e. `Missing <: T`.\n\n# Examples\n```jldoctest\njulia> Array{Union{Missing, String}}(missing, 2)\n2-element Vector{Union{Missing, String}}:\n missing\n missing\n\njulia> Array{Union{Missing, Int}}(missing, 2, 3)\n2\u00d73 Matrix{Union{Missing, Int64}}:\n missing  missing  missing\n missing  missing  missing\n```\n\"\"\"\nArray{T,N}(::Missing, dims)\n\n\"\"\"\n    UndefInitializer\n\nSingleton type used in array initialization, indicating the array-constructor-caller\nwould like an uninitialized array. See also [`undef`](@ref),\nan alias for `UndefInitializer()`.\n\n# Examples\n```julia-repl\njulia> Array{Float64, 1}(UndefInitializer(), 3)\n3-element Array{Float64, 1}:\n 2.2752528595e-314\n 2.202942107e-314\n 2.275252907e-314\n```\n\"\"\"\nUndefInitializer\n\n\"\"\"\n    undef\n\nAlias for `UndefInitializer()`, which constructs an instance of the singleton type\n[`UndefInitializer`](@ref), used in array initialization to indicate the\narray-constructor-caller would like an uninitialized array.\n\n# Examples\n```julia-repl\njulia> Array{Float64, 1}(undef, 3)\n3-element Array{Float64, 1}:\n 2.2752528595e-314\n 2.202942107e-314\n 2.275252907e-314\n```\n\"\"\"\nundef\n\n\"\"\"\n    Ptr{T}()\n\nCreates a null pointer to type `T`.\n\"\"\"\nPtr{T}()\n\n\"\"\"\n    +(x, y...)\n\nAddition operator. `x+y+z+...` calls this function with all arguments, i.e. `+(x, y, z, ...)`.\n\n# Examples\n```jldoctest\njulia> 1 + 20 + 4\n25\n\njulia> +(1, 20, 4)\n25\n```\n\"\"\"\n(+)(x, y...)\n\n\"\"\"\n    -(x)\n\nUnary minus operator.\n\n# Examples\n```jldoctest\njulia> -1\n-1\n\njulia> -(2)\n-2\n\njulia> -[1 2; 3 4]\n2\u00d72 Matrix{Int64}:\n -1  -2\n -3  -4\n```\n\"\"\"\n-(x)\n\n\"\"\"\n    -(x, y)\n\nSubtraction operator.\n\n# Examples\n```jldoctest\njulia> 2 - 3\n-1\n\njulia> -(2, 4.5)\n-2.5\n```\n\"\"\"\n-(x, y)\n\n\"\"\"\n    *(x, y...)\n\nMultiplication operator. `x*y*z*...` calls this function with all arguments, i.e. `*(x, y, z, ...)`.\n\n# Examples\n```jldoctest\njulia> 2 * 7 * 8\n112\n\njulia> *(2, 7, 8)\n112\n```\n\"\"\"\n(*)(x, y...)\n\n\"\"\"\n    /(x, y)\n\nRight division operator: multiplication of `x` by the inverse of `y` on the right. Gives\nfloating-point results for integer arguments.\n\n# Examples\n```jldoctest\njulia> 1/2\n0.5\n\njulia> 4/2\n2.0\n\njulia> 4.5/2\n2.25\n```\n\"\"\"\n/(x, y)\n\n\"\"\"\n    ArgumentError(msg)\n\nThe parameters to a function call do not match a valid signature. Argument `msg` is a\ndescriptive error string.\n\"\"\"\nArgumentError\n\n\"\"\"\n    MethodError(f, args)\n\nA method with the required type signature does not exist in the given generic function.\nAlternatively, there is no unique most-specific method.\n\"\"\"\nMethodError\n\n\"\"\"\n    AssertionError([msg])\n\nThe asserted condition did not evaluate to `true`.\nOptional argument `msg` is a descriptive error string.\n\n# Examples\n```jldoctest\njulia> @assert false \"this is not true\"\nERROR: AssertionError: this is not true\n```\n\n`AssertionError` is usually thrown from [`@assert`](@ref).\n\"\"\"\nAssertionError\n\n\"\"\"\n    LoadError(file::AbstractString, line::Int, error)\n\nAn error occurred while [`include`](@ref Base.include)ing, [`require`](@ref Base.require)ing, or [`using`](@ref) a file. The error specifics\nshould be available in the `.error` field.\n\"\"\"\nLoadError\n\n\"\"\"\n    InitError(mod::Symbol, error)\n\nAn error occurred when running a module's `__init__` function. The actual error thrown is\navailable in the `.error` field.\n\"\"\"\nInitError\n\n\"\"\"\n    Any::DataType\n\n`Any` is the union of all types. It has the defining property `isa(x, Any) == true` for any `x`. `Any` therefore\ndescribes the entire universe of possible values. For example `Integer` is a subset of `Any` that includes `Int`,\n`Int8`, and other integer types.\n\"\"\"\nAny\n\n\"\"\"\n    Union{}\n\n`Union{}`, the empty [`Union`](@ref) of types, is the type that has no values. That is, it has the defining\nproperty `isa(x, Union{}) == false` for any `x`. `Base.Bottom` is defined as its alias and the type of `Union{}`\nis `Core.TypeofBottom`.\n\n# Examples\n```jldoctest\njulia> isa(nothing, Union{})\nfalse\n```\n\"\"\"\nkw\"Union{}\", Base.Bottom\n\n\"\"\"\n    Union{Types...}\n\nA type union is an abstract type which includes all instances of any of its argument types. The empty\nunion [`Union{}`](@ref) is the bottom type of Julia.\n\n# Examples\n```jldoctest\njulia> IntOrString = Union{Int,AbstractString}\nUnion{Int64, AbstractString}\n\njulia> 1 :: IntOrString\n1\n\njulia> \"Hello!\" :: IntOrString\n\"Hello!\"\n\njulia> 1.0 :: IntOrString\nERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got a value of type Float64\n```\n\"\"\"\nUnion\n\n\n\"\"\"\n    UnionAll\n\nA union of types over all values of a type parameter. `UnionAll` is used to describe parametric types\nwhere the values of some parameters are not known.\n\n# Examples\n```jldoctest\njulia> typeof(Vector)\nUnionAll\n\njulia> typeof(Vector{Int})\nDataType\n```\n\"\"\"\nUnionAll\n\n\"\"\"\n    ::\n\nWith the `::`-operator type annotations are attached to expressions and variables in programs.\nSee the manual section on [Type Declarations](@ref).\n\nOutside of declarations `::` is used to assert that expressions and variables in programs have a given type.\n\n# Examples\n```jldoctest\njulia> (1+2)::AbstractFloat\nERROR: TypeError: typeassert: expected AbstractFloat, got a value of type Int64\n\njulia> (1+2)::Int\n3\n```\n\"\"\"\nkw\"::\"\n\n\"\"\"\n    Vararg{T,N}\n\nThe last parameter of a tuple type [`Tuple`](@ref) can be the special value `Vararg`, which denotes any\nnumber of trailing elements. `Vararg{T,N}` corresponds to exactly `N` elements of type `T`. Finally\n`Vararg{T}` corresponds to zero or more elements of type `T`. `Vararg` tuple types are used to represent the\narguments accepted by varargs methods (see the section on [Varargs Functions](@ref) in the manual.)\n\n# Examples\n```jldoctest\njulia> mytupletype = Tuple{AbstractString, Vararg{Int}}\nTuple{AbstractString, Vararg{Int64}}\n\njulia> isa((\"1\",), mytupletype)\ntrue\n\njulia> isa((\"1\",1), mytupletype)\ntrue\n\njulia> isa((\"1\",1,2), mytupletype)\ntrue\n\njulia> isa((\"1\",1,2,3.0), mytupletype)\nfalse\n```\n\"\"\"\nVararg\n\n\"\"\"\n    Tuple{Types...}\n\nTuples are an abstraction of the arguments of a function \u2013 without the function itself. The salient aspects of\na function's arguments are their order and their types. Therefore a tuple type is similar to a parameterized\nimmutable type where each parameter is the type of one field. Tuple types may have any number of parameters.\n\nTuple types are covariant in their parameters: `Tuple{Int}` is a subtype of `Tuple{Any}`. Therefore `Tuple{Any}`\nis considered an abstract type, and tuple types are only concrete if their parameters are. Tuples do not have\nfield names; fields are only accessed by index.\n\nSee the manual section on [Tuple Types](@ref).\n\"\"\"\nTuple\n\n\"\"\"\n    NamedTuple{names}(args::Tuple)\n\nConstruct a named tuple with the given `names` (a tuple of Symbols) from a tuple of values.\n\"\"\"\nNamedTuple{names}(args::Tuple)\n\n\"\"\"\n    NamedTuple{names,T}(args::Tuple)\n\nConstruct a named tuple with the given `names` (a tuple of Symbols) and field types `T`\n(a `Tuple` type) from a tuple of values.\n\"\"\"\nNamedTuple{names,T}(args::Tuple)\n\n\"\"\"\n    NamedTuple{names}(nt::NamedTuple)\n\nConstruct a named tuple by selecting fields in `names` (a tuple of Symbols) from\nanother named tuple.\n\"\"\"\nNamedTuple{names}(nt::NamedTuple)\n\n\"\"\"\n    NamedTuple(itr)\n\nConstruct a named tuple from an iterator of key-value pairs (where the keys must be\n`Symbol`s). Equivalent to `(; itr...)`.\n\n!!! compat \"Julia 1.6\"\n    This method requires at least Julia 1.6.\n\"\"\"\nNamedTuple(itr)\n\n\"\"\"\n    typeassert(x, type)\n\nThrow a [`TypeError`](@ref) unless `x isa type`.\nThe syntax `x::type` calls this function.\n\n# Examples\n```jldoctest\njulia> typeassert(2.5, Int)\nERROR: TypeError: in typeassert, expected Int64, got a value of type Float64\nStacktrace:\n[...]\n```\n\"\"\"\ntypeassert\n\n\"\"\"\n    getproperty(value, name::Symbol)\n\nThe syntax `a.b` calls `getproperty(a, :b)`.\n\n# Examples\n```jldoctest\njulia> struct MyType\n           x\n       end\n\njulia> function Base.getproperty(obj::MyType, sym::Symbol)\n           if sym === :special\n               return obj.x + 1\n           else # fallback to getfield\n               return getfield(obj, sym)\n           end\n       end\n\njulia> obj = MyType(1);\n\njulia> obj.special\n2\n\njulia> obj.x\n1\n```\n\nSee also [`propertynames`](@ref Base.propertynames) and\n[`setproperty!`](@ref Base.setproperty!).\n\"\"\"\nBase.getproperty\n\n\"\"\"\n    setproperty!(value, name::Symbol, x)\n\nThe syntax `a.b = c` calls `setproperty!(a, :b, c)`.\n\nSee also [`propertynames`](@ref Base.propertynames) and\n[`getproperty`](@ref Base.getproperty).\n\"\"\"\nBase.setproperty!\n\n\"\"\"\n    StridedArray{T, N}\n\nA hard-coded [`Union`](@ref) of common array types that follow the [strided array interface](@ref man-interface-strided-arrays),\nwith elements of type `T` and `N` dimensions.\n\nIf `A` is a `StridedArray`, then its elements are stored in memory with offsets, which may\nvary between dimensions but are constant within a dimension. For example, `A` could\nhave stride 2 in dimension 1, and stride 3 in dimension 2. Incrementing `A` along\ndimension `d` jumps in memory by [`strides(A, d)`] slots. Strided arrays are\nparticularly important and useful because they can sometimes be passed directly\nas pointers to foreign language libraries like BLAS.\n\"\"\"\nStridedArray\n\n\"\"\"\n    StridedVector{T}\n\nOne dimensional [`StridedArray`](@ref) with elements of type `T`.\n\"\"\"\nStridedVector\n\n\"\"\"\n    StridedMatrix{T}\n\nTwo dimensional [`StridedArray`](@ref) with elements of type `T`.\n\"\"\"\nStridedMatrix\n\n\"\"\"\n    StridedVecOrMat{T}\n\nUnion type of [`StridedVector`](@ref) and [`StridedMatrix`](@ref) with elements of type `T`.\n\"\"\"\nStridedVecOrMat\n\n\"\"\"\n    Module\n\nA `Module` is a separate global variable workspace. See [`module`](@ref) and the [manual section about modules](@ref modules) for details.\n\"\"\"\nModule\n\n\"\"\"\n    Core\n\n`Core` is the module that contains all identifiers considered \"built in\" to the language, i.e. part of the core language and not libraries. Every module implicitly specifies `using Core`, since you can't do anything without those definitions.\n\"\"\"\nCore.Core\n\n\"\"\"\n    Main\n\n`Main` is the top-level module, and Julia starts with `Main` set as the current module.  Variables defined at the prompt go in `Main`, and `varinfo` lists variables in `Main`.\n```jldoctest\njulia> @__MODULE__\nMain\n```\n\"\"\"\nMain.Main\n\n\"\"\"\n    Base\n\nThe base library of Julia. `Base` is a module that contains basic functionality (the contents of `base/`). All modules implicitly contain `using Base`, since this is needed in the vast majority of cases.\n\"\"\"\nBase.Base\n\n\"\"\"\n    QuoteNode\n\nA quoted piece of code, that does not support interpolation. See the [manual section about QuoteNodes](@ref man-quote-node) for details.\n\"\"\"\nQuoteNode\n\nend\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/OpenBLAS_jll/test/runtests.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nusing Test, Libdl, OpenBLAS_jll\n\n@testset \"OpenBLAS_jll\" begin\n    @test dlsym(OpenBLAS_jll.libopenblas_handle, :openblas_set_num_threads; throw_error=false) !== nothing ||\n          dlsym(OpenBLAS_jll.libopenblas_handle, :openblas_set_num_threads64_; throw_error=false) !== nothing\nend\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/LLVMLibUnwind_jll/test/runtests.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nusing Test, Libdl\nusing LLVMLibUnwind_jll: llvmlibunwind_handle\n\n@testset \"LLVMLibUnwind_jll\" begin\n    if Sys.isapple()\n        @test dlsym(llvmlibunwind_handle, :unw_getcontext; throw_error=false) !== nothing\n        @test dlsym(llvmlibunwind_handle, :unw_init_local; throw_error=false) !== nothing\n        @test dlsym(llvmlibunwind_handle, :unw_init_local_dwarf; throw_error=false) !== nothing\n        @test dlsym(llvmlibunwind_handle, :unw_step; throw_error=false) !== nothing\n        @test dlsym(llvmlibunwind_handle, :unw_get_reg; throw_error=false) !== nothing\n        @test dlsym(llvmlibunwind_handle, :unw_set_reg; throw_error=false) !== nothing\n        @test dlsym(llvmlibunwind_handle, :unw_resume; throw_error=false) !== nothing\n    end\nend\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/LinearAlgebra/src/blas.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n\"\"\"\nInterface to BLAS subroutines.\n\"\"\"\nmodule BLAS\n\nimport ..axpy!, ..axpby!\nimport Base: copyto!\nusing Base: require_one_based_indexing\n\nexport\n# Level 1\n    asum,\n    axpy!,\n    axpby!,\n    blascopy!,\n    dotc,\n    dotu,\n    rot!,\n    scal!,\n    scal,\n    nrm2,\n    iamax,\n# Level 2\n    gbmv!,\n    gbmv,\n    gemv!,\n    gemv,\n    hemv!,\n    hemv,\n    hpmv!,\n    sbmv!,\n    sbmv,\n    spmv!,\n    symv!,\n    symv,\n    trsv!,\n    trsv,\n    trmv!,\n    trmv,\n    ger!,\n    syr!,\n    her!,\n# Level 3\n    herk!,\n    herk,\n    her2k!,\n    her2k,\n    gemm!,\n    gemm,\n    symm!,\n    symm,\n    hemm!,\n    hemm,\n    syrk!,\n    syrk,\n    syr2k!,\n    syr2k,\n    trmm!,\n    trmm,\n    trsm!,\n    trsm\n\n\nconst libblas = Base.libblas_name\nconst liblapack = Base.liblapack_name\n\nimport LinearAlgebra\nimport LinearAlgebra: BlasReal, BlasComplex, BlasFloat, BlasInt, DimensionMismatch, checksquare, stride1, chkstride1, axpy!\n\nimport Libdl\n\n# utility routines\nlet lib = C_NULL\nglobal function determine_vendor()\n    if lib == C_NULL\n        lib = something(Libdl.dlopen(libblas; throw_error=false), C_NULL)\n    end\n    vend = :unknown\n    if lib != C_NULL\n        if Libdl.dlsym(lib, :openblas_set_num_threads; throw_error=false) !== nothing\n            vend = :openblas\n        elseif Libdl.dlsym(lib, :openblas_set_num_threads64_; throw_error=false) !== nothing\n            vend = :openblas64\n        elseif Libdl.dlsym(lib, :MKL_Set_Num_Threads; throw_error=false) !== nothing\n            vend = :mkl\n        end\n    end\n    return vend\nend\nend\n\nconst _vendor = determine_vendor()\nvendor() = _vendor\n\nif vendor() === :openblas64\n    macro blasfunc(x)\n        return Expr(:quote, Symbol(x, \"64_\"))\n    end\nelse\n    macro blasfunc(x)\n        return Expr(:quote, x)\n    end\nend\n\nopenblas_get_config() = strip(unsafe_string(ccall((@blasfunc(openblas_get_config), libblas), Ptr{UInt8}, () )))\n\nfunction guess_vendor()\n    # like determine_vendor, but guesses blas in some cases\n    # where determine_vendor returns :unknown\n    ret = vendor()\n    if Sys.isapple() && (ret == :unknown)\n        ret = :osxblas\n    end\n    ret\nend\n\n\n\"\"\"\n    set_num_threads(n::Integer)\n    set_num_threads(::Nothing)\n\nSet the number of threads the BLAS library should use equal to `n::Integer`.\n\nAlso accepts `nothing`, in which case julia tries to guess the default number of threads.\nPassing `nothing` is discouraged and mainly exists for the following reason:\n\nOn exotic variants of BLAS, `nothing` may be returned by `get_num_threads()`.\nThus on exotic variants of BLAS, the following pattern may fail to set the number of threads:\n\n```julia\nold = get_num_threads()\nset_num_threads(1)\n@threads for i in 1:10\n    # single-threaded BLAS calls\nend\nset_num_threads(old)\n```\nBecause `set_num_threads` accepts `nothing`, this code can still run\non exotic variants of BLAS without error. Warnings will be raised instead.\n\n!!! compat \"Julia 1.6\"\n    `set_num_threads(::Nothing)` requires at least Julia 1.6.\n\"\"\"\nset_num_threads(n)::Nothing = _set_num_threads(n)\n\nfunction _set_num_threads(n::Integer; _blas = guess_vendor())\n    if _blas === :openblas || _blas == :openblas64\n        return ccall((@blasfunc(openblas_set_num_threads), libblas), Cvoid, (Cint,), n)\n    elseif _blas === :mkl\n        # MKL may let us set the number of threads in several ways\n        return ccall((:MKL_Set_Num_Threads, libblas), Cvoid, (Cint,), n)\n    elseif _blas === :osxblas\n        # OSX BLAS looks at an environment variable\n        ENV[\"VECLIB_MAXIMUM_THREADS\"] = n\n    else\n        @assert _blas === :unknown\n        @warn \"Failed to set number of BLAS threads.\" maxlog=1\n    end\n    return nothing\nend\n\n_tryparse_env_int(key) = tryparse(Int, get(ENV, key, \"\"))\n\nfunction _set_num_threads(::Nothing; _blas = guess_vendor())\n    n = something(\n        _tryparse_env_int(\"OPENBLAS_NUM_THREADS\"),\n        _tryparse_env_int(\"OMP_NUM_THREADS\"),\n        max(1, Sys.CPU_THREADS \u00f7 2),\n    )\n    _set_num_threads(n; _blas)\nend\n\n\"\"\"\n    get_num_threads()\n\nGet the number of threads the BLAS library is using.\n\nOn exotic variants of `BLAS` this function can fail, which is indicated by returning `nothing`.\n\n!!! compat \"Julia 1.6\"\n    `get_num_threads` requires at least Julia 1.6.\n\"\"\"\nget_num_threads()::Union{Int, Nothing} = _get_num_threads()\n\nfunction _get_num_threads(; _blas = guess_vendor())::Union{Int, Nothing}\n    if _blas === :openblas || _blas === :openblas64\n        return Int(ccall((@blasfunc(openblas_get_num_threads), libblas), Cint, ()))\n    elseif _blas === :mkl\n        return Int(ccall((:mkl_get_max_threads, libblas), Cint, ()))\n    elseif _blas === :osxblas\n        key = \"VECLIB_MAXIMUM_THREADS\"\n        nt = _tryparse_env_int(key)\n        if nt === nothing\n            @warn \"Failed to read environment variable $key\" maxlog=1\n        else\n            return nt\n        end\n    else\n        @assert _blas === :unknown\n    end\n    @warn \"Could not get number of BLAS threads. Returning `nothing` instead.\" maxlog=1\n    return nothing\nend\n\nconst _testmat = [1.0 0.0; 0.0 -1.0]\nfunction check()\n    blas = vendor()\n    if blas === :openblas || blas === :openblas64\n        openblas_config = openblas_get_config()\n        openblas64 = occursin(r\".*USE64BITINT.*\", openblas_config)\n        if Base.USE_BLAS64 != openblas64\n            if !openblas64\n                @error \"\"\"\n                    OpenBLAS was not built with 64bit integer support.\n                    You're seeing this error because Julia was built with USE_BLAS64=1.\n                    Please rebuild Julia with USE_BLAS64=0\"\"\"\n            else\n                @error \"\"\"\n                    Julia was not built with support for OpenBLAS with 64bit integer support.\n                    You're seeing this error because Julia was built with USE_BLAS64=0.\n                    Please rebuild Julia with USE_BLAS64=1\"\"\"\n            end\n            println(\"Quitting.\")\n            exit()\n        end\n    elseif blas === :mkl\n        if Base.USE_BLAS64\n            ENV[\"MKL_INTERFACE_LAYER\"] = \"ILP64\"\n        end\n    end\n\n    #\n    # Check if BlasInt is the expected bitsize, by triggering an error\n    #\n    (_, info) = LinearAlgebra.LAPACK.potrf!('U', _testmat)\n    if info != 2 # mangled info code\n        if info == 2^33\n            error(\"BLAS and LAPACK are compiled with 32-bit integer support, but Julia expects 64-bit integers. Please build Julia with USE_BLAS64=0.\")\n        elseif info == 0\n            error(\"BLAS and LAPACK are compiled with 64-bit integer support but Julia expects 32-bit integers. Please build Julia with USE_BLAS64=1.\")\n        else\n            error(\"The LAPACK library produced an undefined error code. Please verify the installation of BLAS and LAPACK.\")\n        end\n    end\n\nend\n\n\n# Level 1\n## copy\n\n\"\"\"\n    blascopy!(n, X, incx, Y, incy)\n\nCopy `n` elements of array `X` with stride `incx` to array `Y` with stride `incy`. Returns `Y`.\n\"\"\"\nfunction blascopy! end\n\nfor (fname, elty) in ((:dcopy_,:Float64),\n                      (:scopy_,:Float32),\n                      (:zcopy_,:ComplexF64),\n                      (:ccopy_,:ComplexF32))\n    @eval begin\n        # SUBROUTINE DCOPY(N,DX,INCX,DY,INCY)\n        function blascopy!(n::Integer, DX::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer, DY::Union{Ptr{$elty},AbstractArray{$elty}}, incy::Integer)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 n, DX, incx, DY, incy)\n            DY\n        end\n    end\nend\n\n\n## rot\n\n\"\"\"\n    rot!(n, X, incx, Y, incy, c, s)\n\nOverwrite `X` with `c*X + s*Y` and `Y` with `-conj(s)*X + c*Y` for the first `n` elements of array `X` with stride `incx` and\nfirst `n` elements of array `Y` with stride `incy`. Returns `X` and `Y`.\n\n!!! compat \"Julia 1.5\"\n    `rot!` requires at least Julia 1.5.\n\"\"\"\nfunction rot! end\n\nfor (fname, elty, cty, sty, lib) in ((:drot_, :Float64, :Float64, :Float64, libblas),\n                                     (:srot_, :Float32, :Float32, :Float32, libblas),\n                                     (:zdrot_, :ComplexF64, :Float64, :Float64, libblas),\n                                     (:csrot_, :ComplexF32, :Float32, :Float32, libblas),\n                                     (:zrot_, :ComplexF64, :Float64, :ComplexF64, liblapack),\n                                     (:crot_, :ComplexF32, :Float32, :ComplexF32, liblapack))\n    @eval begin\n        # SUBROUTINE DROT(N,DX,INCX,DY,INCY,C,S)\n        function rot!(n::Integer, DX::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer, DY::Union{Ptr{$elty},AbstractArray{$elty}}, incy::Integer, C::$cty, S::$sty)\n            ccall((@blasfunc($fname), $lib), Cvoid,\n                (Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ref{$cty}, Ref{$sty}),\n                 n, DX, incx, DY, incy, C, S)\n            DX, DY\n        end\n    end\nend\n\n## scal\n\n\"\"\"\n    scal!(n, a, X, incx)\n\nOverwrite `X` with `a*X` for the first `n` elements of array `X` with stride `incx`. Returns `X`.\n\"\"\"\nfunction scal! end\n\n\"\"\"\n    scal(n, a, X, incx)\n\nReturn `X` scaled by `a` for the first `n` elements of array `X` with stride `incx`.\n\"\"\"\nfunction scal end\n\nfor (fname, elty) in ((:dscal_,:Float64),\n                      (:sscal_,:Float32),\n                      (:zscal_,:ComplexF64),\n                      (:cscal_,:ComplexF32))\n    @eval begin\n        # SUBROUTINE DSCAL(N,DA,DX,INCX)\n        function scal!(n::Integer, DA::$elty, DX::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                  (Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt}),\n                  n, DA, DX, incx)\n            DX\n        end\n    end\nend\nscal(n, DA, DX, incx) = scal!(n, DA, copy(DX), incx)\n\n## dot\n\n\"\"\"\n    dot(n, X, incx, Y, incy)\n\nDot product of two vectors consisting of `n` elements of array `X` with stride `incx` and\n`n` elements of array `Y` with stride `incy`.\n\n# Examples\n```jldoctest\njulia> BLAS.dot(10, fill(1.0, 10), 1, fill(1.0, 20), 2)\n10.0\n```\n\"\"\"\nfunction dot end\n\n\"\"\"\n    dotc(n, X, incx, U, incy)\n\nDot function for two complex vectors, consisting of `n` elements of array `X`\nwith stride `incx` and `n` elements of array `U` with stride `incy`,\nconjugating the first vector.\n\n# Examples\n```jldoctest\njulia> BLAS.dotc(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)\n10.0 - 10.0im\n```\n\"\"\"\nfunction dotc end\n\n\"\"\"\n    dotu(n, X, incx, Y, incy)\n\nDot function for two complex vectors consisting of `n` elements of array `X`\nwith stride `incx` and `n` elements of array `Y` with stride `incy`.\n\n# Examples\n```jldoctest\njulia> BLAS.dotu(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)\n-10.0 + 10.0im\n```\n\"\"\"\nfunction dotu end\n\nfor (fname, elty) in ((:ddot_,:Float64),\n                      (:sdot_,:Float32))\n    @eval begin\n                #       DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY)\n                # *     .. Scalar Arguments ..\n                #       INTEGER INCX,INCY,N\n                # *     ..\n                # *     .. Array Arguments ..\n                #       DOUBLE PRECISION DX(*),DY(*)\n        function dot(n::Integer, DX::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer, DY::Union{Ptr{$elty},AbstractArray{$elty}}, incy::Integer)\n            ccall((@blasfunc($fname), libblas), $elty,\n                (Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 n, DX, incx, DY, incy)\n        end\n    end\nend\nfor (fname, elty) in ((:cblas_zdotc_sub,:ComplexF64),\n                      (:cblas_cdotc_sub,:ComplexF32))\n    @eval begin\n                #       DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY)\n                # *     .. Scalar Arguments ..\n                #       INTEGER INCX,INCY,N\n                # *     ..\n                # *     .. Array Arguments ..\n                #       DOUBLE PRECISION DX(*),DY(*)\n        function dotc(n::Integer, DX::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer, DY::Union{Ptr{$elty},AbstractArray{$elty}}, incy::Integer)\n            result = Ref{$elty}()\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (BlasInt, Ptr{$elty}, BlasInt, Ptr{$elty}, BlasInt, Ptr{$elty}),\n                 n, DX, incx, DY, incy, result)\n            result[]\n        end\n    end\nend\nfor (fname, elty) in ((:cblas_zdotu_sub,:ComplexF64),\n                      (:cblas_cdotu_sub,:ComplexF32))\n    @eval begin\n                #       DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY)\n                # *     .. Scalar Arguments ..\n                #       INTEGER INCX,INCY,N\n                # *     ..\n                # *     .. Array Arguments ..\n                #       DOUBLE PRECISION DX(*),DY(*)\n        function dotu(n::Integer, DX::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer, DY::Union{Ptr{$elty},AbstractArray{$elty}}, incy::Integer)\n            result = Ref{$elty}()\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (BlasInt, Ptr{$elty}, BlasInt, Ptr{$elty}, BlasInt, Ptr{$elty}),\n                 n, DX, incx, DY, incy, result)\n            result[]\n        end\n    end\nend\n\nfunction dot(DX::Union{DenseArray{T},AbstractVector{T}}, DY::Union{DenseArray{T},AbstractVector{T}}) where T<:BlasReal\n    require_one_based_indexing(DX, DY)\n    n = length(DX)\n    if n != length(DY)\n        throw(DimensionMismatch(\"dot product arguments have lengths $(length(DX)) and $(length(DY))\"))\n    end\n    return dot(n, DX, stride(DX, 1), DY, stride(DY, 1))\nend\nfunction dotc(DX::Union{DenseArray{T},AbstractVector{T}}, DY::Union{DenseArray{T},AbstractVector{T}}) where T<:BlasComplex\n    require_one_based_indexing(DX, DY)\n    n = length(DX)\n    if n != length(DY)\n        throw(DimensionMismatch(\"dot product arguments have lengths $(length(DX)) and $(length(DY))\"))\n    end\n    return dotc(n, DX, stride(DX, 1), DY, stride(DY, 1))\nend\nfunction dotu(DX::Union{DenseArray{T},AbstractVector{T}}, DY::Union{DenseArray{T},AbstractVector{T}}) where T<:BlasComplex\n    require_one_based_indexing(DX, DY)\n    n = length(DX)\n    if n != length(DY)\n        throw(DimensionMismatch(\"dot product arguments have lengths $(length(DX)) and $(length(DY))\"))\n    end\n    return dotu(n, DX, stride(DX, 1), DY, stride(DY, 1))\nend\n\n## nrm2\n\n\"\"\"\n    nrm2(n, X, incx)\n\n2-norm of a vector consisting of `n` elements of array `X` with stride `incx`.\n\n# Examples\n```jldoctest\njulia> BLAS.nrm2(4, fill(1.0, 8), 2)\n2.0\n\njulia> BLAS.nrm2(1, fill(1.0, 8), 2)\n1.0\n```\n\"\"\"\nfunction nrm2 end\n\nfor (fname, elty, ret_type) in ((:dnrm2_,:Float64,:Float64),\n                                (:snrm2_,:Float32,:Float32),\n                                (:dznrm2_,:ComplexF64,:Float64),\n                                (:scnrm2_,:ComplexF32,:Float32))\n    @eval begin\n        # SUBROUTINE DNRM2(N,X,INCX)\n        function nrm2(n::Integer, X::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer)\n            ccall((@blasfunc($fname), libblas), $ret_type,\n                (Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 n, X, incx)\n        end\n    end\nend\nnrm2(x::Union{AbstractVector,DenseArray}) = nrm2(length(x), x, stride1(x))\n\n## asum\n\n\"\"\"\n    asum(n, X, incx)\n\nSum of the magnitudes of the first `n` elements of array `X` with stride `incx`.\n\nFor a real array, the magnitude is the absolute value. For a complex array, the\nmagnitude is the sum of the absolute value of the real part and the absolute value\nof the imaginary part.\n\n# Examples\n```jldoctest\njulia> BLAS.asum(5, fill(1.0im, 10), 2)\n5.0\n\njulia> BLAS.asum(2, fill(1.0im, 10), 5)\n2.0\n```\n\"\"\"\nfunction asum end\n\nfor (fname, elty, ret_type) in ((:dasum_,:Float64,:Float64),\n                                (:sasum_,:Float32,:Float32),\n                                (:dzasum_,:ComplexF64,:Float64),\n                                (:scasum_,:ComplexF32,:Float32))\n    @eval begin\n        # SUBROUTINE ASUM(N, X, INCX)\n        function asum(n::Integer, X::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer)\n            ccall((@blasfunc($fname), libblas), $ret_type,\n                (Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 n, X, incx)\n        end\n    end\nend\nasum(x::Union{AbstractVector,DenseArray}) = asum(length(x), x, stride1(x))\n\n## axpy\n\n\"\"\"\n    axpy!(a, X, Y)\n\nOverwrite `Y` with `X*a + Y`, where `a` is a scalar. Return `Y`.\n\n# Examples\n```jldoctest\njulia> x = [1; 2; 3];\n\njulia> y = [4; 5; 6];\n\njulia> BLAS.axpy!(2, x, y)\n3-element Vector{Int64}:\n  6\n  9\n 12\n```\n\"\"\"\nfunction axpy! end\n\nfor (fname, elty) in ((:daxpy_,:Float64),\n                      (:saxpy_,:Float32),\n                      (:zaxpy_,:ComplexF64),\n                      (:caxpy_,:ComplexF32))\n    @eval begin\n                # SUBROUTINE DAXPY(N,DA,DX,INCX,DY,INCY)\n                # DY <- DA*DX + DY\n                #*     .. Scalar Arguments ..\n                #      DOUBLE PRECISION DA\n                #      INTEGER INCX,INCY,N\n                #*     .. Array Arguments ..\n                #      DOUBLE PRECISION DX(*),DY(*)\n        function axpy!(n::Integer, alpha::($elty), dx::Union{Ptr{$elty}, AbstractArray{$elty}}, incx::Integer, dy::Union{Ptr{$elty}, AbstractArray{$elty}}, incy::Integer)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 n, alpha, dx, incx, dy, incy)\n            dy\n        end\n    end\nend\nfunction axpy!(alpha::Number, x::Union{DenseArray{T},StridedVector{T}}, y::Union{DenseArray{T},StridedVector{T}}) where T<:BlasFloat\n    if length(x) != length(y)\n        throw(DimensionMismatch(\"x has length $(length(x)), but y has length $(length(y))\"))\n    end\n    return axpy!(length(x), convert(T,alpha), x, stride(x, 1), y, stride(y, 1))\nend\n\nfunction axpy!(alpha::Number, x::Array{T}, rx::Union{UnitRange{Ti},AbstractRange{Ti}},\n               y::Array{T}, ry::Union{UnitRange{Ti},AbstractRange{Ti}}) where {T<:BlasFloat,Ti<:Integer}\n    if length(rx) != length(ry)\n        throw(DimensionMismatch(\"ranges of differing lengths\"))\n    end\n    if minimum(rx) < 1 || maximum(rx) > length(x)\n        throw(ArgumentError(\"range out of bounds for x, of length $(length(x))\"))\n    end\n    if minimum(ry) < 1 || maximum(ry) > length(y)\n        throw(ArgumentError(\"range out of bounds for y, of length $(length(y))\"))\n    end\n    GC.@preserve x y axpy!(\n        length(rx),\n        convert(T, alpha),\n        pointer(x) + (first(rx) - 1)*sizeof(T),\n        step(rx),\n        pointer(y) + (first(ry) - 1)*sizeof(T),\n        step(ry))\n\n    return y\nend\n\n\"\"\"\n    axpby!(a, X, b, Y)\n\nOverwrite `Y` with `X*a + Y*b`, where `a` and `b` are scalars. Return `Y`.\n\n# Examples\n```jldoctest\njulia> x = [1., 2, 3];\n\njulia> y = [4., 5, 6];\n\njulia> BLAS.axpby!(2., x, 3., y)\n3-element Vector{Float64}:\n 14.0\n 19.0\n 24.0\n```\n\"\"\"\nfunction axpby! end\n\nfor (fname, elty) in ((:daxpby_,:Float64), (:saxpby_,:Float32),\n                      (:zaxpby_,:ComplexF64), (:caxpby_,:ComplexF32))\n    @eval begin\n        # SUBROUTINE DAXPBY(N,DA,DX,INCX,DB,DY,INCY)\n        # DY <- DA*DX + DB*DY\n        #*     .. Scalar Arguments ..\n        #      DOUBLE PRECISION DA,DB\n        #      INTEGER INCX,INCY,N\n        #*     .. Array Arguments ..\n        #      DOUBLE PRECISION DX(*),DY(*)\n        function axpby!(n::Integer, alpha::($elty), dx::Union{Ptr{$elty},\n                        AbstractArray{$elty}}, incx::Integer, beta::($elty),\n                        dy::Union{Ptr{$elty}, AbstractArray{$elty}}, incy::Integer)\n            ccall((@blasfunc($fname), libblas), Cvoid, (Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt}),\n                n, alpha, dx, incx, beta, dy, incy)\n            dy\n        end\n    end\nend\n\nfunction axpby!(alpha::Number, x::Union{DenseArray{T},AbstractVector{T}}, beta::Number, y::Union{DenseArray{T},AbstractVector{T}}) where T<:BlasFloat\n    require_one_based_indexing(x, y)\n    if length(x) != length(y)\n        throw(DimensionMismatch(\"x has length $(length(x)), but y has length $(length(y))\"))\n    end\n    return axpby!(length(x), convert(T, alpha), x, stride(x, 1), convert(T, beta), y, stride(y, 1))\nend\n\n## iamax\nfor (fname, elty) in ((:idamax_,:Float64),\n                      (:isamax_,:Float32),\n                      (:izamax_,:ComplexF64),\n                      (:icamax_,:ComplexF32))\n    @eval begin\n        function iamax(n::Integer, dx::Union{Ptr{$elty}, AbstractArray{$elty}}, incx::Integer)\n            ccall((@blasfunc($fname), libblas),BlasInt,\n                (Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                n, dx, incx)\n        end\n    end\nend\niamax(dx::Union{AbstractVector,DenseArray}) = iamax(length(dx), dx, stride1(dx))\n\n\"\"\"\n    iamax(n, dx, incx)\n    iamax(dx)\n\nFind the index of the element of `dx` with the maximum absolute value. `n` is the length of `dx`, and `incx` is the\nstride. If `n` and `incx` are not provided, they assume default values of `n=length(dx)` and `incx=stride1(dx)`.\n\"\"\"\niamax\n\n# Level 2\n## mv\n### gemv\nfor (fname, elty) in ((:dgemv_,:Float64),\n                      (:sgemv_,:Float32),\n                      (:zgemv_,:ComplexF64),\n                      (:cgemv_,:ComplexF32))\n    @eval begin\n             #SUBROUTINE DGEMV(TRANS,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)\n             #*     .. Scalar Arguments ..\n             #      DOUBLE PRECISION ALPHA,BETA\n             #      INTEGER INCX,INCY,LDA,M,N\n             #      CHARACTER TRANS\n             #*     .. Array Arguments ..\n             #      DOUBLE PRECISION A(LDA,*),X(*),Y(*)\n        function gemv!(trans::AbstractChar, alpha::Union{($elty), Bool},\n                       A::AbstractVecOrMat{$elty}, X::AbstractVector{$elty},\n                       beta::Union{($elty), Bool}, Y::AbstractVector{$elty})\n            require_one_based_indexing(A, X, Y)\n            m,n = size(A,1),size(A,2)\n            if trans == 'N' && (length(X) != n || length(Y) != m)\n                throw(DimensionMismatch(\"A has dimensions $(size(A)), X has length $(length(X)) and Y has length $(length(Y))\"))\n            elseif trans == 'C' && (length(X) != m || length(Y) != n)\n                throw(DimensionMismatch(\"the adjoint of A has dimensions $n, $m, X has length $(length(X)) and Y has length $(length(Y))\"))\n            elseif trans == 'T' && (length(X) != m || length(Y) != n)\n                throw(DimensionMismatch(\"the transpose of A has dimensions $n, $m, X has length $(length(X)) and Y has length $(length(Y))\"))\n            end\n            chkstride1(A)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt}, Ref{$elty},\n                 Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt},\n                 Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Clong),\n                 trans, size(A,1), size(A,2), alpha,\n                 A, max(1,stride(A,2)), X, stride(X,1),\n                 beta, Y, stride(Y,1), 1)\n            Y\n        end\n        function gemv(trans::AbstractChar, alpha::($elty), A::AbstractMatrix{$elty}, X::AbstractVector{$elty})\n            gemv!(trans, alpha, A, X, zero($elty), similar(X, $elty, size(A, (trans == 'N' ? 1 : 2))))\n        end\n        function gemv(trans::AbstractChar, A::AbstractMatrix{$elty}, X::AbstractVector{$elty})\n            gemv!(trans, one($elty), A, X, zero($elty), similar(X, $elty, size(A, (trans == 'N' ? 1 : 2))))\n        end\n    end\nend\n\n\"\"\"\n    gemv!(tA, alpha, A, x, beta, y)\n\nUpdate the vector `y` as `alpha*A*x + beta*y` or `alpha*A'x + beta*y`\naccording to [`tA`](@ref stdlib-blas-trans).\n`alpha` and `beta` are scalars. Return the updated `y`.\n\"\"\"\ngemv!\n\n\"\"\"\n    gemv(tA, alpha, A, x)\n\nReturn `alpha*A*x` or `alpha*A'x` according to [`tA`](@ref stdlib-blas-trans).\n`alpha` is a scalar.\n\"\"\"\ngemv(tA, alpha, A, x)\n\n\"\"\"\n    gemv(tA, A, x)\n\nReturn `A*x` or `A'x` according to [`tA`](@ref stdlib-blas-trans).\n\"\"\"\ngemv(tA, A, x)\n\n### (GB) general banded matrix-vector multiplication\n\n\"\"\"\n    gbmv!(trans, m, kl, ku, alpha, A, x, beta, y)\n\nUpdate vector `y` as `alpha*A*x + beta*y` or `alpha*A'*x + beta*y` according to [`trans`](@ref stdlib-blas-trans).\nThe matrix `A` is a general band matrix of dimension `m` by `size(A,2)` with `kl`\nsub-diagonals and `ku` super-diagonals. `alpha` and `beta` are scalars. Return the updated `y`.\n\"\"\"\nfunction gbmv! end\n\n\"\"\"\n    gbmv(trans, m, kl, ku, alpha, A, x)\n\nReturn `alpha*A*x` or `alpha*A'*x` according to [`trans`](@ref stdlib-blas-trans).\nThe matrix `A` is a general band matrix of dimension `m` by `size(A,2)` with `kl` sub-diagonals and `ku`\nsuper-diagonals, and `alpha` is a scalar.\n\"\"\"\nfunction gbmv end\n\nfor (fname, elty) in ((:dgbmv_,:Float64),\n                      (:sgbmv_,:Float32),\n                      (:zgbmv_,:ComplexF64),\n                      (:cgbmv_,:ComplexF32))\n    @eval begin\n             # SUBROUTINE DGBMV(TRANS,M,N,KL,KU,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)\n             # *     .. Scalar Arguments ..\n             #       DOUBLE PRECISION ALPHA,BETA\n             #       INTEGER INCX,INCY,KL,KU,LDA,M,N\n             #       CHARACTER TRANS\n             # *     .. Array Arguments ..\n             #       DOUBLE PRECISION A(LDA,*),X(*),Y(*)\n        function gbmv!(trans::AbstractChar, m::Integer, kl::Integer, ku::Integer,\n                       alpha::Union{($elty), Bool}, A::AbstractMatrix{$elty},\n                       x::AbstractVector{$elty}, beta::Union{($elty), Bool},\n                       y::AbstractVector{$elty})\n            require_one_based_indexing(A, x, y)\n            chkstride1(A)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt}, Ref{BlasInt},\n                 Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt},\n                 Ptr{$elty}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}, Clong),\n                 trans, m, size(A,2), kl,\n                 ku, alpha, A, max(1,stride(A,2)),\n                 x, stride(x,1), beta, y, stride(y,1), 1)\n            y\n        end\n        function gbmv(trans::AbstractChar, m::Integer, kl::Integer, ku::Integer, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            n = size(A,2)\n            leny = trans == 'N' ? m : n\n            gbmv!(trans, m, kl, ku, alpha, A, x, zero($elty), similar(x, $elty, leny))\n        end\n        function gbmv(trans::AbstractChar, m::Integer, kl::Integer, ku::Integer, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            gbmv(trans, m, kl, ku, one($elty), A, x)\n        end\n    end\nend\n\n### symv\n\n\"\"\"\n    symv!(ul, alpha, A, x, beta, y)\n\nUpdate the vector `y` as `alpha*A*x + beta*y`. `A` is assumed to be symmetric.\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n`alpha` and `beta` are scalars. Return the updated `y`.\n\"\"\"\nfunction symv! end\n\nfor (fname, elty, lib) in ((:dsymv_,:Float64,libblas),\n                           (:ssymv_,:Float32,libblas),\n                           (:zsymv_,:ComplexF64,liblapack),\n                           (:csymv_,:ComplexF32,liblapack))\n    # Note that the complex symv are not BLAS but auiliary functions in LAPACK\n    @eval begin\n             #      SUBROUTINE DSYMV(UPLO,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)\n             #     .. Scalar Arguments ..\n             #      DOUBLE PRECISION ALPHA,BETA\n             #      INTEGER INCX,INCY,LDA,N\n             #      CHARACTER UPLO\n             #     .. Array Arguments ..\n             #      DOUBLE PRECISION A(LDA,*),X(*),Y(*)\n        function symv!(uplo::AbstractChar, alpha::Union{($elty), Bool},\n                       A::AbstractMatrix{$elty}, x::AbstractVector{$elty},\n                       beta::Union{($elty), Bool}, y::AbstractVector{$elty})\n            require_one_based_indexing(A, x, y)\n            m, n = size(A)\n            if m != n\n                throw(DimensionMismatch(\"matrix A is $m by $n but must be square\"))\n            end\n            if n != length(x)\n                throw(DimensionMismatch(\"A has size $(size(A)), and x has length $(length(x))\"))\n            end\n            if m != length(y)\n                throw(DimensionMismatch(\"A has size $(size(A)), and y has length $(length(y))\"))\n            end\n            chkstride1(A)\n            ccall((@blasfunc($fname), $lib), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ref{$elty},\n                 Ptr{$elty}, Ref{BlasInt}, Clong),\n                 uplo, n, alpha, A,\n                 max(1,stride(A,2)), x, stride(x,1), beta,\n                 y, stride(y,1), 1)\n            y\n        end\n        function symv(uplo::AbstractChar, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n                symv!(uplo, alpha, A, x, zero($elty), similar(x))\n        end\n        function symv(uplo::AbstractChar, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            symv(uplo, one($elty), A, x)\n        end\n    end\nend\n\n\"\"\"\n    symv(ul, alpha, A, x)\n\nReturn `alpha*A*x`. `A` is assumed to be symmetric.\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n`alpha` is a scalar.\n\"\"\"\nsymv(ul, alpha, A, x)\n\n\"\"\"\n    symv(ul, A, x)\n\nReturn `A*x`. `A` is assumed to be symmetric.\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n\"\"\"\nsymv(ul, A, x)\n\n### hemv\n\"\"\"\n    hemv!(ul, alpha, A, x, beta, y)\n\nUpdate the vector `y` as `alpha*A*x + beta*y`. `A` is assumed to be Hermitian.\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n`alpha` and `beta` are scalars. Return the updated `y`.\n\"\"\"\nfunction hemv! end\n\nfor (fname, elty) in ((:zhemv_,:ComplexF64),\n                      (:chemv_,:ComplexF32))\n    @eval begin\n        function hemv!(uplo::AbstractChar, \u03b1::Union{$elty, Bool}, A::AbstractMatrix{$elty}, x::AbstractVector{$elty}, \u03b2::Union{$elty, Bool}, y::AbstractVector{$elty})\n            require_one_based_indexing(A, x, y)\n            m, n = size(A)\n            if m != n\n                throw(DimensionMismatch(\"matrix A is $m by $n but must be square\"))\n            end\n            if n != length(x)\n                throw(DimensionMismatch(\"A has size $(size(A)), and x has length $(length(x))\"))\n            end\n            if m != length(y)\n                throw(DimensionMismatch(\"A has size $(size(A)), and y has length $(length(y))\"))\n            end\n            chkstride1(A)\n            lda = max(1, stride(A, 2))\n            incx = stride(x, 1)\n            incy = stride(y, 1)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ref{$elty},\n                 Ptr{$elty}, Ref{BlasInt}, Clong),\n                uplo, n, \u03b1, A,\n                lda, x, incx, \u03b2,\n                y, incy, 1)\n            y\n        end\n        function hemv(uplo::AbstractChar, \u03b1::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            hemv!(uplo, \u03b1, A, x, zero($elty), similar(x))\n        end\n        function hemv(uplo::AbstractChar, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            hemv(uplo, one($elty), A, x)\n        end\n    end\nend\n\n\"\"\"\n    hemv(ul, alpha, A, x)\n\nReturn `alpha*A*x`. `A` is assumed to be Hermitian.\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n`alpha` is a scalar.\n\"\"\"\nhemv(ul, alpha, A, x)\n\n\"\"\"\n    hemv(ul, A, x)\n\nReturn `A*x`. `A` is assumed to be Hermitian.\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n\"\"\"\nhemv(ul, A, x)\n\n### hpmv!, (HP) Hermitian packed matrix-vector operation defined as y := alpha*A*x + beta*y.\nfor (fname, elty) in ((:zhpmv_, :ComplexF64),\n                      (:chpmv_, :ComplexF32))\n    @eval begin\n        # SUBROUTINE ZHPMV(UPLO,N,ALPHA,AP,X,INCX,BETA,Y,INCY)\n        # Y <- ALPHA*AP*X + BETA*Y\n        # *     .. Scalar Arguments ..\n        #       DOUBLE PRECISION ALPHA,BETA\n        #       INTEGER INCX,INCY,N\n        #       CHARACTER UPLO\n        # *     .. Array Arguments ..\n        #       DOUBLE PRECISION A(N,N),X(N),Y(N)\n        function hpmv!(uplo::AbstractChar,\n                       n::Integer,\n                       \u03b1::$elty,\n                       AP::Union{Ptr{$elty}, AbstractArray{$elty}},\n                       x::Union{Ptr{$elty}, AbstractArray{$elty}},\n                       incx::Integer,\n                       \u03b2::$elty,\n                       y::Union{Ptr{$elty}, AbstractArray{$elty}},\n                       incy::Integer)\n\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                  (Ref{UInt8},     # uplo,\n                   Ref{BlasInt},   # n,\n                   Ref{$elty},     # \u03b1,\n                   Ptr{$elty},     # AP,\n                   Ptr{$elty},     # x,\n                   Ref{BlasInt},   # incx,\n                   Ref{$elty},     # \u03b2,\n                   Ptr{$elty},     # y, output\n                   Ref{BlasInt},   # incy\n                   Clong),         # length of uplo\n                  uplo,\n                  n,\n                  \u03b1,\n                  AP,\n                  x,\n                  incx,\n                  \u03b2,\n                  y,\n                  incy,\n                  1)\n            return y\n        end\n    end\nend\n\nfunction hpmv!(uplo::AbstractChar,\n               \u03b1::Number, AP::Union{DenseArray{T}, AbstractVector{T}}, x::Union{DenseArray{T}, AbstractVector{T}},\n               \u03b2::Number, y::Union{DenseArray{T}, AbstractVector{T}}) where {T <: BlasComplex}\n    require_one_based_indexing(AP, x, y)\n    N = length(x)\n    if N != length(y)\n        throw(DimensionMismatch(\"x has length $(N), but y has length $(length(y))\"))\n    end\n    if 2*length(AP) < N*(N + 1)\n        throw(DimensionMismatch(\"Packed Hermitian matrix A has size smaller than length(x) =  $(N).\"))\n    end\n    return hpmv!(uplo, N, convert(T, \u03b1), AP, x, stride(x, 1), convert(T, \u03b2), y, stride(y, 1))\nend\n\n\"\"\"\n    hpmv!(uplo, \u03b1, AP, x, \u03b2, y)\n\nUpdate vector `y` as `\u03b1*A*x + \u03b2*y`, where `A` is a Hermitian matrix provided\nin packed format `AP`.\n\nWith `uplo = 'U'`, the array AP must contain the upper triangular part of the\nHermitian matrix packed sequentially, column by column, so that `AP[1]`\ncontains `A[1, 1]`, `AP[2]` and `AP[3]` contain `A[1, 2]` and `A[2, 2]`\nrespectively, and so on.\n\nWith `uplo = 'L'`, the array AP must contain the lower triangular part of the\nHermitian matrix packed sequentially, column by column, so that `AP[1]`\ncontains `A[1, 1]`, `AP[2]` and `AP[3]` contain `A[2, 1]` and `A[3, 1]`\nrespectively, and so on.\n\nThe scalar inputs `\u03b1` and `\u03b2` must be complex or real numbers.\n\nThe array inputs `x`, `y` and `AP` must all be of `ComplexF32` or `ComplexF64` type.\n\nReturn the updated `y`.\n\"\"\"\nhpmv!\n\n### sbmv, (SB) symmetric banded matrix-vector multiplication\nfor (fname, elty) in ((:dsbmv_,:Float64),\n                      (:ssbmv_,:Float32))\n    @eval begin\n             #       SUBROUTINE DSBMV(UPLO,N,K,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)\n             # *     .. Scalar Arguments ..\n             #       DOUBLE PRECISION ALPHA,BETA\n             #       INTEGER INCX,INCY,K,LDA,N\n             #       CHARACTER UPLO\n             # *     .. Array Arguments ..\n             #       DOUBLE PRECISION A(LDA,*),X(*),Y(*)\n        function sbmv!(uplo::AbstractChar, k::Integer, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty}, beta::($elty), y::AbstractVector{$elty})\n            require_one_based_indexing(A, x, y)\n            chkstride1(A)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt}, Ref{$elty},\n                 Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt},\n                 Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Clong),\n                 uplo, size(A,2), k, alpha,\n                 A, max(1,stride(A,2)), x, stride(x,1),\n                 beta, y, stride(y,1), 1)\n            y\n        end\n        function sbmv(uplo::AbstractChar, k::Integer, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            n = size(A,2)\n            sbmv!(uplo, k, alpha, A, x, zero($elty), similar(x, $elty, n))\n        end\n        function sbmv(uplo::AbstractChar, k::Integer, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            sbmv(uplo, k, one($elty), A, x)\n        end\n    end\nend\n\n\"\"\"\n    sbmv(uplo, k, alpha, A, x)\n\nReturn `alpha*A*x` where `A` is a symmetric band matrix of order `size(A,2)` with `k`\nsuper-diagonals stored in the argument `A`.\nOnly the [`uplo`](@ref stdlib-blas-uplo) triangle of `A` is used.\n\"\"\"\nsbmv(uplo, k, alpha, A, x)\n\n\"\"\"\n    sbmv(uplo, k, A, x)\n\nReturn `A*x` where `A` is a symmetric band matrix of order `size(A,2)` with `k`\nsuper-diagonals stored in the argument `A`.\nOnly the [`uplo`](@ref stdlib-blas-uplo) triangle of `A` is used.\n\"\"\"\nsbmv(uplo, k, A, x)\n\n\"\"\"\n    sbmv!(uplo, k, alpha, A, x, beta, y)\n\nUpdate vector `y` as `alpha*A*x + beta*y` where `A` is a symmetric band matrix of order\n`size(A,2)` with `k` super-diagonals stored in the argument `A`. The storage layout for `A`\nis described the reference BLAS module, level-2 BLAS at\n<http://www.netlib.org/lapack/explore-html/>.\nOnly the [`uplo`](@ref stdlib-blas-uplo) triangle of `A` is used.\n\nReturn the updated `y`.\n\"\"\"\nsbmv!\n\n### spmv!, (SP) symmetric packed matrix-vector operation defined as y := alpha*A*x + beta*y.\nfor (fname, elty) in ((:dspmv_, :Float64),\n                      (:sspmv_, :Float32))\n    @eval begin\n        # SUBROUTINE DSPMV(UPLO,N,ALPHA,AP,X,INCX,BETA,Y,INCY)\n        # Y <- ALPHA*AP*X + BETA*Y\n        # *     .. Scalar Arguments ..\n        #       DOUBLE PRECISION ALPHA,BETA\n        #       INTEGER INCX,INCY,N\n        #       CHARACTER UPLO\n        # *     .. Array Arguments ..\n        #       DOUBLE PRECISION A(N,N),X(N),Y(N)\n        function spmv!(uplo::AbstractChar,\n                       n::Integer,\n                       \u03b1::$elty,\n                       AP::Union{Ptr{$elty}, AbstractArray{$elty}},\n                       x::Union{Ptr{$elty}, AbstractArray{$elty}},\n                       incx::Integer,\n                       \u03b2::$elty,\n                       y::Union{Ptr{$elty}, AbstractArray{$elty}},\n                       incy::Integer)\n\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                  (Ref{UInt8},     # uplo,\n                   Ref{BlasInt},   # n,\n                   Ref{$elty},     # \u03b1,\n                   Ptr{$elty},     # AP,\n                   Ptr{$elty},     # x,\n                   Ref{BlasInt},   # incx,\n                   Ref{$elty},     # \u03b2,\n                   Ptr{$elty},     # y, out\n                   Ref{BlasInt},   # incy\n                   Clong),         # length of uplo\n                  uplo,\n                  n,\n                  \u03b1,\n                  AP,\n                  x,\n                  incx,\n                  \u03b2,\n                  y,\n                  incy,\n                  1)\n            return y\n        end\n    end\nend\n\nfunction spmv!(uplo::AbstractChar,\n               \u03b1::Real, AP::Union{DenseArray{T}, AbstractVector{T}}, x::Union{DenseArray{T}, AbstractVector{T}},\n               \u03b2::Real, y::Union{DenseArray{T}, AbstractVector{T}}) where {T <: BlasReal}\n    require_one_based_indexing(AP, x, y)\n    N = length(x)\n    if N != length(y)\n        throw(DimensionMismatch(\"x has length $(N), but y has length $(length(y))\"))\n    end\n    if 2*length(AP) < N*(N + 1)\n        throw(DimensionMismatch(\"Packed symmetric matrix A has size smaller than length(x) = $(N).\"))\n    end\n    return spmv!(uplo, N, convert(T, \u03b1), AP, x, stride(x, 1), convert(T, \u03b2), y, stride(y, 1))\nend\n\n\"\"\"\n    spmv!(uplo, \u03b1, AP, x, \u03b2, y)\n\nUpdate vector `y` as `\u03b1*A*x + \u03b2*y`, where `A` is a symmetric matrix provided\nin packed format `AP`.\n\nWith `uplo = 'U'`, the array AP must contain the upper triangular part of the\nsymmetric matrix packed sequentially, column by column, so that `AP[1]`\ncontains `A[1, 1]`, `AP[2]` and `AP[3]` contain `A[1, 2]` and `A[2, 2]`\nrespectively, and so on.\n\nWith `uplo = 'L'`, the array AP must contain the lower triangular part of the\nsymmetric matrix packed sequentially, column by column, so that `AP[1]`\ncontains `A[1, 1]`, `AP[2]` and `AP[3]` contain `A[2, 1]` and `A[3, 1]`\nrespectively, and so on.\n\nThe scalar inputs `\u03b1` and `\u03b2` must be real.\n\nThe array inputs `x`, `y` and `AP` must all be of `Float32` or `Float64` type.\n\nReturn the updated `y`.\n\"\"\"\nspmv!\n\n### hbmv, (HB) Hermitian banded matrix-vector multiplication\nfor (fname, elty) in ((:zhbmv_,:ComplexF64),\n                      (:chbmv_,:ComplexF32))\n    @eval begin\n             #       SUBROUTINE ZHBMV(UPLO,N,K,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)\n             # *     .. Scalar Arguments ..\n             #       DOUBLE PRECISION ALPHA,BETA\n             #       INTEGER INCX,INCY,K,LDA,N\n             #       CHARACTER UPLO\n             # *     .. Array Arguments ..\n             #       DOUBLE PRECISION A(LDA,*),X(*),Y(*)\n        function hbmv!(uplo::AbstractChar, k::Integer, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty}, beta::($elty), y::AbstractVector{$elty})\n            require_one_based_indexing(A, x, y)\n            chkstride1(A)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt}, Ref{$elty},\n                 Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt},\n                 Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Clong),\n                 uplo, size(A,2), k, alpha,\n                 A, max(1,stride(A,2)), x, stride(x,1),\n                 beta, y, stride(y,1), 1)\n            y\n        end\n        function hbmv(uplo::AbstractChar, k::Integer, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            n = size(A,2)\n            hbmv!(uplo, k, alpha, A, x, zero($elty), similar(x, $elty, n))\n        end\n        function hbmv(uplo::AbstractChar, k::Integer, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            hbmv(uplo, k, one($elty), A, x)\n        end\n    end\nend\n\n### trmv, Triangular matrix-vector multiplication\n\n\"\"\"\n    trmv(ul, tA, dA, A, b)\n\nReturn `op(A)*b`, where `op` is determined by [`tA`](@ref stdlib-blas-trans).\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\n\"\"\"\nfunction trmv end\n\n\"\"\"\n    trmv!(ul, tA, dA, A, b)\n\nReturn `op(A)*b`, where `op` is determined by [`tA`](@ref stdlib-blas-trans).\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\nThe multiplication occurs in-place on `b`.\n\"\"\"\nfunction trmv! end\n\nfor (fname, elty) in ((:dtrmv_,:Float64),\n                        (:strmv_,:Float32),\n                        (:ztrmv_,:ComplexF64),\n                        (:ctrmv_,:ComplexF32))\n    @eval begin\n                #       SUBROUTINE DTRMV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX)\n                # *     .. Scalar Arguments ..\n                #       INTEGER INCX,LDA,N\n                #       CHARACTER DIAG,TRANS,UPLO\n                # *     .. Array Arguments ..\n                #       DOUBLE PRECISION A(LDA,*),X(*)\n        function trmv!(uplo::AbstractChar, trans::AbstractChar, diag::AbstractChar, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            require_one_based_indexing(A, x)\n            n = checksquare(A)\n            if n != length(x)\n                throw(DimensionMismatch(\"A has size ($n,$n), x has length $(length(x))\"))\n            end\n            chkstride1(A)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{UInt8}, Ref{BlasInt},\n                 Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt},\n                 Clong, Clong, Clong),\n                 uplo, trans, diag, n,\n                 A, max(1,stride(A,2)), x, max(1,stride(x, 1)), 1, 1, 1)\n            x\n        end\n        function trmv(uplo::AbstractChar, trans::AbstractChar, diag::AbstractChar, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            trmv!(uplo, trans, diag, A, copy(x))\n        end\n    end\nend\n\n### trsv, Triangular matrix-vector solve\n\n\"\"\"\n    trsv!(ul, tA, dA, A, b)\n\nOverwrite `b` with the solution to `A*x = b` or one of the other two variants determined by\n[`tA`](@ref stdlib-blas-trans) and [`ul`](@ref stdlib-blas-uplo).\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\nReturn the updated `b`.\n\"\"\"\nfunction trsv! end\n\n\"\"\"\n    trsv(ul, tA, dA, A, b)\n\nReturn the solution to `A*x = b` or one of the other two variants determined by\n[`tA`](@ref stdlib-blas-trans) and [`ul`](@ref stdlib-blas-uplo).\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\n\"\"\"\nfunction trsv end\n\nfor (fname, elty) in ((:dtrsv_,:Float64),\n                        (:strsv_,:Float32),\n                        (:ztrsv_,:ComplexF64),\n                        (:ctrsv_,:ComplexF32))\n    @eval begin\n                #       SUBROUTINE DTRSV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX)\n                #       .. Scalar Arguments ..\n                #       INTEGER INCX,LDA,N\n                #       CHARACTER DIAG,TRANS,UPLO\n                #       .. Array Arguments ..\n                #       DOUBLE PRECISION A(LDA,*),X(*)\n        function trsv!(uplo::AbstractChar, trans::AbstractChar, diag::AbstractChar, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            require_one_based_indexing(A, x)\n            n = checksquare(A)\n            if n != length(x)\n                throw(DimensionMismatch(\"size of A is $n != length(x) = $(length(x))\"))\n            end\n            chkstride1(A)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{UInt8}, Ref{BlasInt},\n                 Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt},\n                 Clong, Clong, Clong),\n                 uplo, trans, diag, n,\n                 A, max(1,stride(A,2)), x, stride(x, 1), 1, 1, 1)\n            x\n        end\n        function trsv(uplo::AbstractChar, trans::AbstractChar, diag::AbstractChar, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            trsv!(uplo, trans, diag, A, copy(x))\n        end\n    end\nend\n\n### ger\n\n\"\"\"\n    ger!(alpha, x, y, A)\n\nRank-1 update of the matrix `A` with vectors `x` and `y` as `alpha*x*y' + A`.\n\"\"\"\nfunction ger! end\n\nfor (fname, elty) in ((:dger_,:Float64),\n                      (:sger_,:Float32),\n                      (:zgerc_,:ComplexF64),\n                      (:cgerc_,:ComplexF32))\n    @eval begin\n        function ger!(\u03b1::$elty, x::AbstractVector{$elty}, y::AbstractVector{$elty}, A::AbstractMatrix{$elty})\n            require_one_based_indexing(A, x, y)\n            m, n = size(A)\n            if m != length(x) || n != length(y)\n                throw(DimensionMismatch(\"A has size ($m,$n), x has length $(length(x)), y has length $(length(y))\"))\n            end\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{BlasInt}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty},\n                 Ref{BlasInt}),\n                 m, n, \u03b1, x,\n                 stride(x, 1), y, stride(y, 1), A,\n                 max(1,stride(A,2)))\n            A\n        end\n    end\nend\n\n### syr\n\n\"\"\"\n    syr!(uplo, alpha, x, A)\n\nRank-1 update of the symmetric matrix `A` with vector `x` as `alpha*x*transpose(x) + A`.\n[`uplo`](@ref stdlib-blas-uplo) controls which triangle of `A` is updated. Returns `A`.\n\"\"\"\nfunction syr! end\n\nfor (fname, elty, lib) in ((:dsyr_,:Float64,libblas),\n                           (:ssyr_,:Float32,libblas),\n                           (:zsyr_,:ComplexF64,liblapack),\n                           (:csyr_,:ComplexF32,liblapack))\n    @eval begin\n        function syr!(uplo::AbstractChar, \u03b1::$elty, x::AbstractVector{$elty}, A::AbstractMatrix{$elty})\n            require_one_based_indexing(A, x)\n            n = checksquare(A)\n            if length(x) != n\n                throw(DimensionMismatch(\"A has size ($n,$n), x has length $(length(x))\"))\n            end\n            ccall((@blasfunc($fname), $lib), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 uplo, n, \u03b1, x,\n                 stride(x, 1), A, max(1,stride(A, 2)))\n            A\n        end\n    end\nend\n\n### her\n\n\"\"\"\n    her!(uplo, alpha, x, A)\n\nMethods for complex arrays only. Rank-1 update of the Hermitian matrix `A` with vector `x`\nas `alpha*x*x' + A`.\n[`uplo`](@ref stdlib-blas-uplo) controls which triangle of `A` is updated. Returns `A`.\n\"\"\"\nfunction her! end\n\nfor (fname, elty, relty) in ((:zher_,:ComplexF64, :Float64),\n                             (:cher_,:ComplexF32, :Float32))\n    @eval begin\n        function her!(uplo::AbstractChar, \u03b1::$relty, x::AbstractVector{$elty}, A::AbstractMatrix{$elty})\n            require_one_based_indexing(A, x)\n            n = checksquare(A)\n            if length(x) != n\n                throw(DimensionMismatch(\"A has size ($n,$n), x has length $(length(x))\"))\n            end\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{$relty}, Ptr{$elty},\n                 Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Clong),\n                 uplo, n, \u03b1, x,\n                 stride(x, 1), A, max(1,stride(A,2)), 1)\n            A\n        end\n    end\nend\n\n# Level 3\n## (GE) general matrix-matrix multiplication\n\n\"\"\"\n    gemm!(tA, tB, alpha, A, B, beta, C)\n\nUpdate `C` as `alpha*A*B + beta*C` or the other three variants according to\n[`tA`](@ref stdlib-blas-trans) and `tB`. Return the updated `C`.\n\"\"\"\nfunction gemm! end\n\nfor (gemm, elty) in\n        ((:dgemm_,:Float64),\n         (:sgemm_,:Float32),\n         (:zgemm_,:ComplexF64),\n         (:cgemm_,:ComplexF32))\n    @eval begin\n             # SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n             # *     .. Scalar Arguments ..\n             #       DOUBLE PRECISION ALPHA,BETA\n             #       INTEGER K,LDA,LDB,LDC,M,N\n             #       CHARACTER TRANSA,TRANSB\n             # *     .. Array Arguments ..\n             #       DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)\n        function gemm!(transA::AbstractChar, transB::AbstractChar,\n                       alpha::Union{($elty), Bool},\n                       A::AbstractVecOrMat{$elty}, B::AbstractVecOrMat{$elty},\n                       beta::Union{($elty), Bool},\n                       C::AbstractVecOrMat{$elty})\n#           if any([stride(A,1), stride(B,1), stride(C,1)] .!= 1)\n#               error(\"gemm!: BLAS module requires contiguous matrix columns\")\n#           end  # should this be checked on every call?\n            require_one_based_indexing(A, B, C)\n            m = size(A, transA == 'N' ? 1 : 2)\n            ka = size(A, transA == 'N' ? 2 : 1)\n            kb = size(B, transB == 'N' ? 1 : 2)\n            n = size(B, transB == 'N' ? 2 : 1)\n            if ka != kb || m != size(C,1) || n != size(C,2)\n                throw(DimensionMismatch(\"A has size ($m,$ka), B has size ($kb,$n), C has size $(size(C))\"))\n            end\n            chkstride1(A)\n            chkstride1(B)\n            chkstride1(C)\n            ccall((@blasfunc($gemm), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                 Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt},\n                 Ptr{$elty}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}, Clong, Clong),\n                 transA, transB, m, n,\n                 ka, alpha, A, max(1,stride(A,2)),\n                 B, max(1,stride(B,2)), beta, C,\n                 max(1,stride(C,2)), 1, 1)\n            C\n        end\n        function gemm(transA::AbstractChar, transB::AbstractChar, alpha::($elty), A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            gemm!(transA, transB, alpha, A, B, zero($elty), similar(B, $elty, (size(A, transA == 'N' ? 1 : 2), size(B, transB == 'N' ? 2 : 1))))\n        end\n        function gemm(transA::AbstractChar, transB::AbstractChar, A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            gemm(transA, transB, one($elty), A, B)\n        end\n    end\nend\n\n\"\"\"\n    gemm(tA, tB, alpha, A, B)\n\nReturn `alpha*A*B` or the other three variants according to [`tA`](@ref stdlib-blas-trans) and `tB`.\n\"\"\"\ngemm(tA, tB, alpha, A, B)\n\n\"\"\"\n    gemm(tA, tB, A, B)\n\nReturn `A*B` or the other three variants according to [`tA`](@ref stdlib-blas-trans) and `tB`.\n\"\"\"\ngemm(tA, tB, A, B)\n\n\n## (SY) symmetric matrix-matrix and matrix-vector multiplication\nfor (mfname, elty) in ((:dsymm_,:Float64),\n                       (:ssymm_,:Float32),\n                       (:zsymm_,:ComplexF64),\n                       (:csymm_,:ComplexF32))\n    @eval begin\n             #     SUBROUTINE DSYMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n             #     .. Scalar Arguments ..\n             #     DOUBLE PRECISION ALPHA,BETA\n             #     INTEGER LDA,LDB,LDC,M,N\n             #     CHARACTER SIDE,UPLO\n             #     .. Array Arguments ..\n             #     DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)\n        function symm!(side::AbstractChar, uplo::AbstractChar, alpha::Union{($elty), Bool},\n                       A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty},\n                       beta::Union{($elty), Bool}, C::AbstractMatrix{$elty})\n            require_one_based_indexing(A, B, C)\n            m, n = size(C)\n            j = checksquare(A)\n            if j != (side == 'L' ? m : n)\n                throw(DimensionMismatch(\"A has size $(size(A)), C has size ($m,$n)\"))\n            end\n            if size(B,2) != n\n                throw(DimensionMismatch(\"B has second dimension $(size(B,2)) but needs to match second dimension of C, $n\"))\n            end\n            chkstride1(A)\n            chkstride1(B)\n            chkstride1(C)\n            ccall((@blasfunc($mfname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                 Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty},\n                 Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt},\n                 Clong, Clong),\n                 side, uplo, m, n,\n                 alpha, A, max(1,stride(A,2)), B,\n                 max(1,stride(B,2)), beta, C, max(1,stride(C,2)),\n                 1, 1)\n            C\n        end\n        function symm(side::AbstractChar, uplo::AbstractChar, alpha::($elty), A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            symm!(side, uplo, alpha, A, B, zero($elty), similar(B))\n        end\n        function symm(side::AbstractChar, uplo::AbstractChar, A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            symm(side, uplo, one($elty), A, B)\n        end\n    end\nend\n\n\"\"\"\n    symm(side, ul, alpha, A, B)\n\nReturn `alpha*A*B` or `alpha*B*A` according to [`side`](@ref stdlib-blas-side).\n`A` is assumed to be symmetric. Only\nthe [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n\"\"\"\nsymm(side, ul, alpha, A, B)\n\n\"\"\"\n    symm(side, ul, A, B)\n\nReturn `A*B` or `B*A` according to [`side`](@ref stdlib-blas-side).\n`A` is assumed to be symmetric. Only the [`ul`](@ref stdlib-blas-uplo)\ntriangle of `A` is used.\n\"\"\"\nsymm(side, ul, A, B)\n\n\"\"\"\n    symm!(side, ul, alpha, A, B, beta, C)\n\nUpdate `C` as `alpha*A*B + beta*C` or `alpha*B*A + beta*C` according to [`side`](@ref stdlib-blas-side).\n`A` is assumed to be symmetric. Only the [`ul`](@ref stdlib-blas-uplo) triangle of\n`A` is used. Return the updated `C`.\n\"\"\"\nsymm!\n\n## (HE) Hermitian matrix-matrix and matrix-vector multiplication\nfor (mfname, elty) in ((:zhemm_,:ComplexF64),\n                       (:chemm_,:ComplexF32))\n    @eval begin\n             #     SUBROUTINE DHEMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n             #     .. Scalar Arguments ..\n             #     DOUBLE PRECISION ALPHA,BETA\n             #     INTEGER LDA,LDB,LDC,M,N\n             #     CHARACTER SIDE,UPLO\n             #     .. Array Arguments ..\n             #     DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)\n        function hemm!(side::AbstractChar, uplo::AbstractChar, alpha::Union{($elty), Bool},\n                       A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty},\n                       beta::Union{($elty), Bool}, C::AbstractMatrix{$elty})\n            require_one_based_indexing(A, B, C)\n            m, n = size(C)\n            j = checksquare(A)\n            if j != (side == 'L' ? m : n)\n                throw(DimensionMismatch(\"A has size $(size(A)), C has size ($m,$n)\"))\n            end\n            if size(B,2) != n\n                throw(DimensionMismatch(\"B has second dimension $(size(B,2)) but needs to match second dimension of C, $n\"))\n            end\n            chkstride1(A)\n            chkstride1(B)\n            chkstride1(C)\n            ccall((@blasfunc($mfname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                 Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty},\n                 Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt},\n                 Clong, Clong),\n                 side, uplo, m, n,\n                 alpha, A, max(1,stride(A,2)), B,\n                 max(1,stride(B,2)), beta, C, max(1,stride(C,2)),\n                 1, 1)\n            C\n        end\n        function hemm(side::AbstractChar, uplo::AbstractChar, alpha::($elty), A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            hemm!(side, uplo, alpha, A, B, zero($elty), similar(B))\n        end\n        function hemm(side::AbstractChar, uplo::AbstractChar, A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            hemm(side, uplo, one($elty), A, B)\n        end\n    end\nend\n\n\"\"\"\n    hemm(side, ul, alpha, A, B)\n\nReturn `alpha*A*B` or `alpha*B*A` according to [`side`](@ref stdlib-blas-side).\n`A` is assumed to be Hermitian. Only the [`ul`](@ref stdlib-blas-uplo) triangle\nof `A` is used.\n\"\"\"\nhemm(side, ul, alpha, A, B)\n\n\"\"\"\n    hemm(side, ul, A, B)\n\nReturn `A*B` or `B*A` according to [`side`](@ref stdlib-blas-side). `A` is assumed\nto be Hermitian. Only the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n\"\"\"\nhemm(side, ul, A, B)\n\n\"\"\"\n    hemm!(side, ul, alpha, A, B, beta, C)\n\nUpdate `C` as `alpha*A*B + beta*C` or `alpha*B*A + beta*C` according to\n[`side`](@ref stdlib-blas-side). `A` is assumed to be Hermitian. Only the\n[`ul`](@ref stdlib-blas-uplo) triangle of `A` is used. Return the updated `C`.\n\"\"\"\nhemm!\n\n## syrk\n\n\"\"\"\n    syrk!(uplo, trans, alpha, A, beta, C)\n\nRank-k update of the symmetric matrix `C` as `alpha*A*transpose(A) + beta*C` or\n`alpha*transpose(A)*A + beta*C` according to [`trans`](@ref stdlib-blas-trans).\nOnly the [`uplo`](@ref stdlib-blas-uplo) triangle of `C` is used. Returns `C`.\n\"\"\"\nfunction syrk! end\n\n\"\"\"\n    syrk(uplo, trans, alpha, A)\n\nReturns either the upper triangle or the lower triangle of `A`,\naccording to [`uplo`](@ref stdlib-blas-uplo),\nof `alpha*A*transpose(A)` or `alpha*transpose(A)*A`,\naccording to [`trans`](@ref stdlib-blas-trans).\n\"\"\"\nfunction syrk end\n\nfor (fname, elty) in ((:dsyrk_,:Float64),\n                      (:ssyrk_,:Float32),\n                      (:zsyrk_,:ComplexF64),\n                      (:csyrk_,:ComplexF32))\n   @eval begin\n       # SUBROUTINE DSYRK(UPLO,TRANS,N,K,ALPHA,A,LDA,BETA,C,LDC)\n       # *     .. Scalar Arguments ..\n       #       REAL ALPHA,BETA\n       #       INTEGER K,LDA,LDC,N\n       #       CHARACTER TRANS,UPLO\n       # *     .. Array Arguments ..\n       #       REAL A(LDA,*),C(LDC,*)\n       function syrk!(uplo::AbstractChar, trans::AbstractChar,\n                      alpha::Union{($elty), Bool}, A::AbstractVecOrMat{$elty},\n                      beta::Union{($elty), Bool}, C::AbstractMatrix{$elty})\n           require_one_based_indexing(A, C)\n           n = checksquare(C)\n           nn = size(A, trans == 'N' ? 1 : 2)\n           if nn != n throw(DimensionMismatch(\"C has size ($n,$n), corresponding dimension of A is $nn\")) end\n           k  = size(A, trans == 'N' ? 2 : 1)\n           chkstride1(A)\n           chkstride1(C)\n           ccall((@blasfunc($fname), libblas), Cvoid,\n                 (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                  Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Ref{$elty},\n                  Ptr{$elty}, Ref{BlasInt}, Clong, Clong),\n                 uplo, trans, n, k,\n                 alpha, A, max(1,stride(A,2)), beta,\n                 C, max(1,stride(C,2)), 1, 1)\n            C\n        end\n    end\nend\nfunction syrk(uplo::AbstractChar, trans::AbstractChar, alpha::Number, A::AbstractVecOrMat)\n    T = eltype(A)\n    n = size(A, trans == 'N' ? 1 : 2)\n    syrk!(uplo, trans, convert(T,alpha), A, zero(T), similar(A, T, (n, n)))\nend\nsyrk(uplo::AbstractChar, trans::AbstractChar, A::AbstractVecOrMat) = syrk(uplo, trans, one(eltype(A)), A)\n\n\"\"\"\n    herk!(uplo, trans, alpha, A, beta, C)\n\nMethods for complex arrays only. Rank-k update of the Hermitian matrix `C` as\n`alpha*A*A' + beta*C` or `alpha*A'*A + beta*C` according to [`trans`](@ref stdlib-blas-trans).\nOnly the [`uplo`](@ref stdlib-blas-uplo) triangle of `C` is updated. Returns `C`.\n\"\"\"\nfunction herk! end\n\n\"\"\"\n    herk(uplo, trans, alpha, A)\n\nMethods for complex arrays only. Returns the [`uplo`](@ref stdlib-blas-uplo)\ntriangle of `alpha*A*A'` or `alpha*A'*A`, according to [`trans`](@ref stdlib-blas-trans).\n\"\"\"\nfunction herk end\n\nfor (fname, elty, relty) in ((:zherk_, :ComplexF64, :Float64),\n                             (:cherk_, :ComplexF32, :Float32))\n   @eval begin\n       # SUBROUTINE CHERK(UPLO,TRANS,N,K,ALPHA,A,LDA,BETA,C,LDC)\n       # *     .. Scalar Arguments ..\n       #       REAL ALPHA,BETA\n       #       INTEGER K,LDA,LDC,N\n       #       CHARACTER TRANS,UPLO\n       # *     ..\n       # *     .. Array Arguments ..\n       #       COMPLEX A(LDA,*),C(LDC,*)\n       function herk!(uplo::AbstractChar, trans::AbstractChar,\n                      \u03b1::Union{$relty, Bool}, A::AbstractVecOrMat{$elty},\n                      \u03b2::Union{$relty, Bool}, C::AbstractMatrix{$elty})\n           require_one_based_indexing(A, C)\n           n = checksquare(C)\n           nn = size(A, trans == 'N' ? 1 : 2)\n           if nn != n\n               throw(DimensionMismatch(\"the matrix to update has dimension $n but the implied dimension of the update is $(size(A, trans == 'N' ? 1 : 2))\"))\n           end\n           chkstride1(A)\n           chkstride1(C)\n           k  = size(A, trans == 'N' ? 2 : 1)\n           ccall((@blasfunc($fname), libblas), Cvoid,\n                 (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                  Ref{$relty}, Ptr{$elty}, Ref{BlasInt}, Ref{$relty},\n                  Ptr{$elty}, Ref{BlasInt}, Clong, Clong),\n                 uplo, trans, n, k,\n                 \u03b1, A, max(1,stride(A,2)), \u03b2,\n                 C, max(1,stride(C,2)), 1, 1)\n           C\n       end\n       function herk(uplo::AbstractChar, trans::AbstractChar, \u03b1::$relty, A::AbstractVecOrMat{$elty})\n           n = size(A, trans == 'N' ? 1 : 2)\n           herk!(uplo, trans, \u03b1, A, zero($relty), similar(A, (n,n)))\n       end\n       herk(uplo::AbstractChar, trans::AbstractChar, A::AbstractVecOrMat{$elty}) = herk(uplo, trans, one($relty), A)\n   end\nend\n\n## syr2k\nfor (fname, elty) in ((:dsyr2k_,:Float64),\n                      (:ssyr2k_,:Float32),\n                      (:zsyr2k_,:ComplexF64),\n                      (:csyr2k_,:ComplexF32))\n    @eval begin\n             #       SUBROUTINE DSYR2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n             #\n             #       .. Scalar Arguments ..\n             #       REAL PRECISION ALPHA,BETA\n             #       INTEGER K,LDA,LDB,LDC,N\n             #       CHARACTER TRANS,UPLO\n             #       ..\n             #       .. Array Arguments ..\n             #       REAL PRECISION A(LDA,*),B(LDB,*),C(LDC,*)\n        function syr2k!(uplo::AbstractChar, trans::AbstractChar,\n                        alpha::($elty), A::AbstractVecOrMat{$elty}, B::AbstractVecOrMat{$elty},\n                        beta::($elty), C::AbstractMatrix{$elty})\n            require_one_based_indexing(A, B, C)\n            n = checksquare(C)\n            nn = size(A, trans == 'N' ? 1 : 2)\n            if nn != n throw(DimensionMismatch(\"C has size ($n,$n), corresponding dimension of A is $nn\")) end\n            k  = size(A, trans == 'N' ? 2 : 1)\n            chkstride1(A)\n            chkstride1(B)\n            chkstride1(C)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                 Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ref{$elty},\n                 Ptr{$elty}, Ref{BlasInt}, Clong, Clong),\n                 uplo, trans, n, k,\n                 alpha, A, max(1,stride(A,2)), B, max(1,stride(B,2)), beta,\n                 C, max(1,stride(C,2)), 1, 1)\n            C\n        end\n    end\nend\n\n\"\"\"\n    syr2k!(uplo, trans, alpha, A, B, beta, C)\n\nRank-2k update of the symmetric matrix `C` as\n`alpha*A*transpose(B) + alpha*B*transpose(A) + beta*C` or\n`alpha*transpose(A)*B + alpha*transpose(B)*A + beta*C`\naccording to [`trans`](@ref stdlib-blas-trans).\nOnly the [`uplo`](@ref stdlib-blas-uplo) triangle of `C` is used. Returns `C`.\n\"\"\"\nfunction syr2k! end\n\n\"\"\"\n    syr2k(uplo, trans, alpha, A, B)\n\nReturns the [`uplo`](@ref stdlib-blas-uplo) triangle of\n`alpha*A*transpose(B) + alpha*B*transpose(A)` or\n`alpha*transpose(A)*B + alpha*transpose(B)*A`,\naccording to [`trans`](@ref stdlib-blas-trans).\n\"\"\"\nfunction syr2k(uplo::AbstractChar, trans::AbstractChar, alpha::Number, A::AbstractVecOrMat, B::AbstractVecOrMat)\n    T = eltype(A)\n    n = size(A, trans == 'N' ? 1 : 2)\n    syr2k!(uplo, trans, convert(T,alpha), A, B, zero(T), similar(A, T, (n, n)))\nend\n\"\"\"\n    syr2k(uplo, trans, A, B)\n\nReturns the [`uplo`](@ref stdlib-blas-uplo) triangle of `A*transpose(B) + B*transpose(A)`\nor `transpose(A)*B + transpose(B)*A`, according to [`trans`](@ref stdlib-blas-trans).\n\"\"\"\nsyr2k(uplo::AbstractChar, trans::AbstractChar, A::AbstractVecOrMat, B::AbstractVecOrMat) = syr2k(uplo, trans, one(eltype(A)), A, B)\n\nfor (fname, elty1, elty2) in ((:zher2k_,:ComplexF64,:Float64), (:cher2k_,:ComplexF32,:Float32))\n   @eval begin\n       # SUBROUTINE CHER2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n       #\n       #       .. Scalar Arguments ..\n       #       COMPLEX ALPHA\n       #       REAL BETA\n       #       INTEGER K,LDA,LDB,LDC,N\n       #       CHARACTER TRANS,UPLO\n       #       ..\n       #       .. Array Arguments ..\n       #       COMPLEX A(LDA,*),B(LDB,*),C(LDC,*)\n       function her2k!(uplo::AbstractChar, trans::AbstractChar, alpha::($elty1),\n                       A::AbstractVecOrMat{$elty1}, B::AbstractVecOrMat{$elty1},\n                       beta::($elty2), C::AbstractMatrix{$elty1})\n           require_one_based_indexing(A, B, C)\n           n = checksquare(C)\n           nn = size(A, trans == 'N' ? 1 : 2)\n           if nn != n throw(DimensionMismatch(\"C has size ($n,$n), corresponding dimension of A is $nn\")) end\n           chkstride1(A)\n           chkstride1(B)\n           chkstride1(C)\n           k  = size(A, trans == 'N' ? 2 : 1)\n           ccall((@blasfunc($fname), libblas), Cvoid,\n                 (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                  Ref{$elty1}, Ptr{$elty1}, Ref{BlasInt}, Ptr{$elty1}, Ref{BlasInt},\n                  Ref{$elty2},  Ptr{$elty1}, Ref{BlasInt}, Clong, Clong),\n                 uplo, trans, n, k,\n                 alpha, A, max(1,stride(A,2)), B, max(1,stride(B,2)),\n                 beta, C, max(1,stride(C,2)), 1, 1)\n           C\n       end\n       function her2k(uplo::AbstractChar, trans::AbstractChar, alpha::($elty1), A::AbstractVecOrMat{$elty1}, B::AbstractVecOrMat{$elty1})\n           n = size(A, trans == 'N' ? 1 : 2)\n           her2k!(uplo, trans, alpha, A, B, zero($elty2), similar(A, $elty1, (n,n)))\n       end\n       her2k(uplo::AbstractChar, trans::AbstractChar, A::AbstractVecOrMat{$elty1}, B::AbstractVecOrMat{$elty1}) = her2k(uplo, trans, one($elty1), A, B)\n   end\nend\n\n\"\"\"\n    her2k!(uplo, trans, alpha, A, B, beta, C)\n\nRank-2k update of the Hermitian matrix `C` as\n`alpha*A*B' + alpha*B*A' + beta*C` or `alpha*A'*B + alpha*B'*A + beta*C`\naccording to [`trans`](@ref stdlib-blas-trans). The scalar `beta` has to be real.\nOnly the [`uplo`](@ref stdlib-blas-uplo) triangle of `C` is used. Returns `C`.\n\"\"\"\nfunction her2k! end\n\n\"\"\"\n    her2k(uplo, trans, alpha, A, B)\n\nReturns the [`uplo`](@ref stdlib-blas-uplo) triangle of `alpha*A*B' + alpha*B*A'`\nor `alpha*A'*B + alpha*B'*A`, according to [`trans`](@ref stdlib-blas-trans).\n\"\"\"\nher2k(uplo, trans, alpha, A, B)\n\n\"\"\"\n    her2k(uplo, trans, A, B)\n\nReturns the [`uplo`](@ref stdlib-blas-uplo) triangle of `A*B' + B*A'`\nor `A'*B + B'*A`, according to [`trans`](@ref stdlib-blas-trans).\n\"\"\"\nher2k(uplo, trans, A, B)\n\n## (TR) Triangular matrix and vector multiplication and solution\n\n\"\"\"\n    trmm!(side, ul, tA, dA, alpha, A, B)\n\nUpdate `B` as `alpha*A*B` or one of the other three variants determined by\n[`side`](@ref stdlib-blas-side) and [`tA`](@ref stdlib-blas-trans).\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\nReturns the updated `B`.\n\"\"\"\nfunction trmm! end\n\n\"\"\"\n    trmm(side, ul, tA, dA, alpha, A, B)\n\nReturns `alpha*A*B` or one of the other three variants determined by\n[`side`](@ref stdlib-blas-side) and [`tA`](@ref stdlib-blas-trans).\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\n\"\"\"\nfunction trmm end\n\n\"\"\"\n    trsm!(side, ul, tA, dA, alpha, A, B)\n\nOverwrite `B` with the solution to `A*X = alpha*B` or one of the other three variants\ndetermined by [`side`](@ref stdlib-blas-side) and [`tA`](@ref stdlib-blas-trans).\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\nReturns the updated `B`.\n\"\"\"\nfunction trsm! end\n\n\"\"\"\n    trsm(side, ul, tA, dA, alpha, A, B)\n\nReturn the solution to `A*X = alpha*B` or one of the other three variants determined by\ndetermined by [`side`](@ref stdlib-blas-side) and [`tA`](@ref stdlib-blas-trans).\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\n\"\"\"\nfunction trsm end\n\nfor (mmname, smname, elty) in\n        ((:dtrmm_,:dtrsm_,:Float64),\n         (:strmm_,:strsm_,:Float32),\n         (:ztrmm_,:ztrsm_,:ComplexF64),\n         (:ctrmm_,:ctrsm_,:ComplexF32))\n    @eval begin\n        #       SUBROUTINE DTRMM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB)\n        # *     .. Scalar Arguments ..\n        #       DOUBLE PRECISION ALPHA\n        #       INTEGER LDA,LDB,M,N\n        #       CHARACTER DIAG,SIDE,TRANSA,UPLO\n        # *     .. Array Arguments ..\n        #       DOUBLE PRECISION A(LDA,*),B(LDB,*)\n        function trmm!(side::AbstractChar, uplo::AbstractChar, transa::AbstractChar, diag::AbstractChar, alpha::Number,\n                       A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            require_one_based_indexing(A, B)\n            m, n = size(B)\n            nA = checksquare(A)\n            if nA != (side == 'L' ? m : n)\n                throw(DimensionMismatch(\"size of A, $(size(A)), doesn't match $side size of B with dims, $(size(B))\"))\n            end\n            chkstride1(A)\n            chkstride1(B)\n            ccall((@blasfunc($mmname), libblas), Cvoid,\n                  (Ref{UInt8}, Ref{UInt8}, Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                   Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt},\n                   Clong, Clong, Clong, Clong),\n                  side, uplo, transa, diag, m, n,\n                  alpha, A, max(1,stride(A,2)), B, max(1,stride(B,2)),\n                  1, 1, 1, 1)\n            B\n        end\n        function trmm(side::AbstractChar, uplo::AbstractChar, transa::AbstractChar, diag::AbstractChar,\n                      alpha::$elty, A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            trmm!(side, uplo, transa, diag, alpha, A, copy(B))\n        end\n        #       SUBROUTINE DTRSM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB)\n        # *     .. Scalar Arguments ..\n        #       DOUBLE PRECISION ALPHA\n        #       INTEGER LDA,LDB,M,N\n        #       CHARACTER DIAG,SIDE,TRANSA,UPLO\n        # *     .. Array Arguments ..\n        #       DOUBLE PRECISION A(LDA,*),B(LDB,*)\n        function trsm!(side::AbstractChar, uplo::AbstractChar, transa::AbstractChar, diag::AbstractChar,\n                       alpha::$elty, A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            require_one_based_indexing(A, B)\n            m, n = size(B)\n            k = checksquare(A)\n            if k != (side == 'L' ? m : n)\n                throw(DimensionMismatch(\"size of A is ($k,$k), size of B is ($m,$n), side is $side, and transa='$transa'\"))\n            end\n            chkstride1(A)\n            chkstride1(B)\n            ccall((@blasfunc($smname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{UInt8}, Ref{UInt8},\n                 Ref{BlasInt}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt},\n                 Clong, Clong, Clong, Clong),\n                 side, uplo, transa, diag,\n                 m, n, alpha, A,\n                 max(1,stride(A,2)), B, max(1,stride(B,2)),\n                 1, 1, 1, 1)\n            B\n        end\n        function trsm(side::AbstractChar, uplo::AbstractChar, transa::AbstractChar, diag::AbstractChar, alpha::$elty, A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            trsm!(side, uplo, transa, diag, alpha, A, copy(B))\n        end\n    end\nend\n\nend # module\n\nfunction copyto!(dest::Array{T}, rdest::Union{UnitRange{Ti},AbstractRange{Ti}},\n                 src::Array{T}, rsrc::Union{UnitRange{Ti},AbstractRange{Ti}}) where {T<:BlasFloat,Ti<:Integer}\n    if minimum(rdest) < 1 || maximum(rdest) > length(dest)\n        throw(ArgumentError(\"range out of bounds for dest, of length $(length(dest))\"))\n    end\n    if minimum(rsrc) < 1 || maximum(rsrc) > length(src)\n        throw(ArgumentError(\"range out of bounds for src, of length $(length(src))\"))\n    end\n    if length(rdest) != length(rsrc)\n        throw(DimensionMismatch(\"ranges must be of the same length\"))\n    end\n    GC.@preserve src dest BLAS.blascopy!(\n        length(rsrc),\n        pointer(src) + (first(rsrc) - 1) * sizeof(T),\n        step(rsrc),\n        pointer(dest) + (first(rdest) - 1) * sizeof(T),\n        step(rdest))\n\n    return dest\nend\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/Libdl/src/Libdl.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nmodule Libdl\n# Just re-export Base.Libc.Libdl:\nexport DL_LOAD_PATH, RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL,\n    RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW, dlclose, dlopen, dlopen_e, dlsym, dlsym_e,\n    dlpath, find_library, dlext, dllist\n\nimport Base.Libc.Libdl: DL_LOAD_PATH, RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL,\n                        RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW, dlclose, dlopen, dlopen_e, dlsym, dlsym_e,\n                        dlpath, find_library, dlext, dllist\n\nend # module\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/Libdl/test/runtests.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nusing Test\nimport Libdl\n\n# these could fail on an embedded installation\n# but for now, we don't handle that case\ndlls = Libdl.dllist()\n@test !isempty(dlls)\n@test length(dlls) > 3 # at a bare minimum, probably have some version of libstdc, libgcc, libjulia, ...\nif !Sys.iswindows() || Sys.windows_version() >= Sys.WINDOWS_VISTA_VER\n    for dl in dlls\n        if isfile(dl) && (Libdl.dlopen(dl; throw_error=false) !== nothing)\n            @test Base.samefile(Libdl.dlpath(dl), dl)\n        end\n    end\nend\n@test length(filter(dlls) do dl\n      if Base.DARWIN_FRAMEWORK\n          return occursin(Regex(\"^$(Base.DARWIN_FRAMEWORK_NAME)(?:_debug)?\\$\"), basename(dl))\n      else\n          return occursin(Regex(\"^libjulia-internal(?:.*)\\\\.$(Libdl.dlext)(?:\\\\..+)?\\$\"), basename(dl))\n      end\n    end) == 1 # look for something libjulia-like (but only one)\n\n# library handle pointer must not be NULL\n@test_throws ArgumentError Libdl.dlsym(C_NULL, :foo)\n@test_throws ArgumentError Libdl.dlsym_e(C_NULL, :foo)\n\ncd(@__DIR__) do\n\n# Find the library directory by finding the path of libjulia-internal (or libjulia-internal-debug,\n# as the case may be) to get the private library directory\nprivate_libdir = if Base.DARWIN_FRAMEWORK\n    if ccall(:jl_is_debugbuild, Cint, ()) != 0\n        dirname(abspath(Libdl.dlpath(Base.DARWIN_FRAMEWORK_NAME * \"_debug\")))\n    else\n        joinpath(dirname(abspath(Libdl.dlpath(Base.DARWIN_FRAMEWORK_NAME))),\"Frameworks\")\n    end\nelseif ccall(:jl_is_debugbuild, Cint, ()) != 0\n    dirname(abspath(Libdl.dlpath(\"libjulia-internal-debug\")))\nelse\n    dirname(abspath(Libdl.dlpath(\"libjulia-internal\")))\nend\n\n@test !isempty(Libdl.find_library([\"libccalltest\"], [private_libdir]))\n@test !isempty(Libdl.find_library(\"libccalltest\", [private_libdir]))\n@test !isempty(Libdl.find_library(:libccalltest, [private_libdir]))\n\n# dlopen should be able to handle absolute and relative paths, with and without dlext\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(abspath(joinpath(private_libdir, \"libccalltest\")); throw_error=false)\n        @test dl !== nothing\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(abspath(joinpath(private_libdir, \"libccalltest.$(Libdl.dlext)\")); throw_error=false)\n        @test dl !== nothing\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(relpath(joinpath(private_libdir, \"libccalltest\")); throw_error=false)\n        @test dl !== nothing\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(relpath(joinpath(private_libdir, \"libccalltest.$(Libdl.dlext)\")); throw_error=false)\n        @test dl !== nothing\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(\"./foo\"; throw_error=false)\n        @test dl === nothing\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# unqualified names present in DL_LOAD_PATH\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(\"libccalltest\"; throw_error=false)\n        @test dl !== nothing\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(string(\"libccalltest\",\".\",Libdl.dlext); throw_error=false)\n        @test dl !== nothing\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# path with dlopen-able file first in load path\n#=\nlet dl = C_NULL,\n    tmpdir = mktempdir(),\n    fpath = joinpath(tmpdir,\"libccalltest\")\n    try\n        write(open(fpath,\"w\"))\n        push!(Libdl.DL_LOAD_PATH, @__DIR__)\n        push!(Libdl.DL_LOAD_PATH, dirname(fpath))\n        dl = Libdl.dlopen_e(\"libccalltest\")\n        @test dl != C_NULL\n    finally\n        pop!(Libdl.DL_LOAD_PATH)\n        pop!(Libdl.DL_LOAD_PATH)\n        rm(tmpdir, recursive=true)\n    end\nend\n=#\n\n# path with dlopen-able file second in load path\n#=\nlet dl = C_NULL,\n    tmpdir = mktempdir(),\n    fpath = joinpath(tmpdir,\"libccalltest\")\n    try\n        write(open(fpath,\"w\"))\n        push!(Libdl.DL_LOAD_PATH, dirname(fpath))\n        push!(Libdl.DL_LOAD_PATH, @__DIR__)\n        dl = Libdl.dlopen_e(\"libccalltest\")\n        @test dl != C_NULL\n    finally\n        pop!(Libdl.DL_LOAD_PATH)\n        pop!(Libdl.DL_LOAD_PATH)\n        rm(tmpdir, recursive=true)\n    end\nend\n=#\n\n# test dlpath\nlet dl = C_NULL\n    try\n        path = abspath(joinpath(private_libdir, \"libccalltest\"))\n        dl = Libdl.dlopen(path; throw_error=false)\n        @test dl !== nothing\n        @test Base.samefile(abspath(Libdl.dlpath(dl)),\n                            abspath(Libdl.dlpath(path)))\n        @test Base.samefile(abspath(Libdl.dlpath(dl)),\n                            string(path,\".\",Libdl.dlext))\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# opening a library that does not exist throws an ErrorException\n@test_throws ErrorException Libdl.dlopen(\"./foo\")\n\n# opening a versioned library that does not exist does not result in adding extension twice\nerr = @test_throws ErrorException Libdl.dlopen(\"./foo.$(Libdl.dlext).0\")\n@test !occursin(\"foo.$(Libdl.dlext).0.$(Libdl.dlext)\", err.value.msg)\nerr = @test_throws ErrorException Libdl.dlopen(\"./foo.$(Libdl.dlext).0.22.1\")\n@test !occursin(\"foo.$(Libdl.dlext).0.22.1.$(Libdl.dlext)\", err.value.msg)\n\n# test dlsym\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(abspath(joinpath(private_libdir, \"libccalltest\")))\n        fptr = Libdl.dlsym(dl, :set_verbose)\n        @test fptr !== nothing\n        @test_throws ErrorException Libdl.dlsym(dl, :foo)\n\n        fptr = Libdl.dlsym_e(dl, :set_verbose)\n        @test fptr != C_NULL\n        fptr = Libdl.dlsym_e(dl, :foo)\n        @test fptr == C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# test do-block dlopen\nLibdl.dlopen(abspath(joinpath(private_libdir, \"libccalltest\"))) do dl\n    fptr = Libdl.dlsym(dl, :set_verbose)\n    @test fptr !== nothing\n    @test_throws ErrorException Libdl.dlsym(dl, :foo)\n\n    fptr = Libdl.dlsym_e(dl, :set_verbose)\n    @test fptr != C_NULL\n    fptr = Libdl.dlsym_e(dl, :foo)\n    @test fptr == C_NULL\nend\n\n# test dlclose\n# If dl is NULL, jl_dlclose should return -1 and dlclose should return false\n# dlclose should return true on success and false on failure\nlet dl = C_NULL\n    @test -1 == ccall(:jl_dlclose, Cint, (Ptr{Cvoid},), dl)\n    @test !Libdl.dlclose(dl)\n\n    dl = Libdl.dlopen(\"libccalltest\"; throw_error=false)\n    @test dl !== nothing\n\n    @test Libdl.dlclose(dl)\n    @test_skip !Libdl.dlclose(dl)   # Syscall doesn't fail on Win32\nend\n\n# test DL_LOAD_PATH handling and @executable_path expansion\nmktempdir() do dir\n    # Create a `libdcalltest` in a directory that is not on our load path\n    src_path = joinpath(private_libdir, \"libccalltest.$(Libdl.dlext)\")\n    dst_path = joinpath(dir, \"libdcalltest.$(Libdl.dlext)\")\n    cp(src_path, dst_path)\n\n    # Add an absurdly long entry to the load path to verify it doesn't lead to a buffer overflow\n    push!(Base.DL_LOAD_PATH, joinpath(dir, join(rand('a':'z', 10000))))\n\n    # Add the temporary directors to load path by absolute path\n    push!(Base.DL_LOAD_PATH, dir)\n\n    # Test that we can now open that file\n    Libdl.dlopen(\"libdcalltest\") do dl\n        fptr = Libdl.dlsym(dl, :set_verbose)\n        @test fptr !== nothing\n        @test_throws ErrorException Libdl.dlsym(dl, :foo)\n\n        fptr = Libdl.dlsym_e(dl, :set_verbose)\n        @test fptr != C_NULL\n        fptr = Libdl.dlsym_e(dl, :foo)\n        @test fptr == C_NULL\n    end\n\n    # Skip these tests if the temporary directory is not on the same filesystem\n    # as the BINDIR, as in that case, a relative path will never work.\n    if Base.Filesystem.splitdrive(dir)[1] != Base.Filesystem.splitdrive(Sys.BINDIR)[1]\n        return\n    end\n\n    empty!(Base.DL_LOAD_PATH)\n    push!(Base.DL_LOAD_PATH, joinpath(dir, join(rand('a':'z', 10000))))\n\n    # Add this temporary directory to our load path, now using `@executable_path` to do so.\n    push!(Base.DL_LOAD_PATH, joinpath(\"@executable_path\", relpath(dir, Sys.BINDIR)))\n\n    # Test that we can now open that file\n    Libdl.dlopen(\"libdcalltest\") do dl\n        fptr = Libdl.dlsym(dl, :set_verbose)\n        @test fptr !== nothing\n        @test_throws ErrorException Libdl.dlsym(dl, :foo)\n\n        fptr = Libdl.dlsym_e(dl, :set_verbose)\n        @test fptr != C_NULL\n        fptr = Libdl.dlsym_e(dl, :foo)\n        @test fptr == C_NULL\n    end\nend\n\nend\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/Libdl/docs/src/index.md": "# Dynamic Linker\n\n```@docs\nLibdl.dlopen\nLibdl.dlopen_e\nLibdl.RTLD_NOW\nLibdl.dlsym\nLibdl.dlsym_e\nLibdl.dlclose\nLibdl.dlext\nLibdl.dllist\nLibdl.dlpath\nLibdl.find_library\nLibdl.DL_LOAD_PATH\n```\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/SuiteSparse/src/cholmod.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\n# Theoretically CHOLMOD supports both Int32 and Int64 indices on 64-bit.\n# However experience suggests that using both in the same session causes memory\n# leaks, so we restrict indices to be SuiteSparse_long (see cholmod_h.jl).\n# Ref: https://github.com/JuliaLang/julia/issues/12664\n\n# Additionally, only Float64/ComplexF64 are supported in practice.\n# Ref: https://github.com/JuliaLang/julia/issues/25986\n\nmodule CHOLMOD\n\nimport Base: (*), convert, copy, eltype, getindex, getproperty, show, size,\n             IndexStyle, IndexLinear, IndexCartesian, adjoint, axes\nusing Base: require_one_based_indexing\n\nusing LinearAlgebra\nimport LinearAlgebra: (\\),\n                 cholesky, cholesky!, det, diag, ishermitian, isposdef,\n                 issuccess, issymmetric, ldlt, ldlt!, logdet\n\nusing SparseArrays\nusing SparseArrays: getcolptr\nimport Libdl\n\nexport\n    Dense,\n    Factor,\n    Sparse\n\nimport SparseArrays: AbstractSparseMatrix, SparseMatrixCSC, indtype, sparse, spzeros, nnz\n\nimport ..increment, ..increment!, ..decrement, ..decrement!\n\n#########\n# Setup #\n#########\n\ninclude(\"cholmod_h.jl\")\n\nconst CHOLMOD_MIN_VERSION = v\"2.1.1\"\n\nconst common_struct = Vector{Vector{UInt8}}()\n\nconst common_supernodal = Vector{Ptr{Cint}}()\nconst common_final_ll   = Vector{Ptr{Cint}}()\nconst common_print      = Vector{Ptr{Cint}}()\nconst common_itype      = Vector{Ptr{Cint}}()\nconst common_dtype      = Vector{Ptr{Cint}}()\nconst common_nmethods   = Vector{Ptr{Cint}}()\nconst common_postorder  = Vector{Ptr{Cint}}()\n\n### These offsets are defined in SuiteSparse_wrapper.c\nconst common_size = ccall((:jl_cholmod_common_size,:libsuitesparse_wrapper),Int,())\n\nconst cholmod_com_offsets = Vector{Csize_t}(undef, 19)\nccall((:jl_cholmod_common_offsets, :libsuitesparse_wrapper),\n    Nothing, (Ptr{Csize_t},), cholmod_com_offsets)\n\n## macro to generate the name of the C function according to the integer type\nmacro cholmod_name(nm)\n    string(\"cholmod_l_\", nm)\nend\n\nfunction start(a::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"start\"), :libcholmod),\n        Cint, (Ptr{UInt8},), a)\n    return a\nend\n\nfunction finish(a::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"finish\"), :libcholmod),\n        Cint, (Ptr{UInt8},), a)\n    return a\nend\n\nfunction defaults(a::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"defaults\"), :libcholmod),\n        Cint, (Ptr{UInt8},), a)\n    return a\nend\n\nconst build_version_array = Vector{Cint}(undef, 3)\nccall((:jl_cholmod_version, :libsuitesparse_wrapper), Cint, (Ptr{Cint},), build_version_array)\nconst build_version = VersionNumber(build_version_array...)\n\nfunction __init__()\n    try\n        ### Check if the linked library is compatible with the Julia code\n        if Libdl.dlsym_e(Libdl.dlopen(\"libcholmod\"), :cholmod_version) != C_NULL\n            current_version_array = Vector{Cint}(undef, 3)\n            ccall((:cholmod_version, :libcholmod), Cint, (Ptr{Cint},), current_version_array)\n            current_version = VersionNumber(current_version_array...)\n        else # CHOLMOD < 2.1.1 does not include cholmod_version()\n            current_version = v\"0.0.0\"\n        end\n\n\n        if current_version < CHOLMOD_MIN_VERSION\n            @warn \"\"\"\n                CHOLMOD version incompatibility\n\n                Julia was compiled with CHOLMOD version $build_version. It is\n                currently linked with a version older than\n                $(CHOLMOD_MIN_VERSION). This might cause Julia to\n                terminate when working with sparse matrix factorizations,\n                e.g. solving systems of equations with \\\\.\n\n                It is recommended that you use Julia with a recent version\n                of CHOLMOD, or download the generic binaries\n                from www.julialang.org, which ship with the correct\n                versions of all dependencies.\n                \"\"\"\n        elseif build_version_array[1] != current_version_array[1]\n            @warn \"\"\"\n                CHOLMOD version incompatibility\n\n                Julia was compiled with CHOLMOD version $build_version. It is\n                currently linked with version $current_version.\n                This might cause Julia to terminate when working with\n                sparse matrix factorizations, e.g. solving systems of\n                equations with \\\\.\n\n                It is recommended that you use Julia with the same major\n                version of CHOLMOD as the one used during the build, or\n                download the generic binaries from www.julialang.org,\n                which ship with the correct versions of all dependencies.\n                \"\"\"\n        end\n\n        intsize = Int(ccall((:jl_cholmod_sizeof_long,:libsuitesparse_wrapper),Csize_t,()))\n        if intsize != 4length(IndexTypes)\n            @error \"\"\"\n                 CHOLMOD integer size incompatibility\n\n                 Julia was compiled with a version of CHOLMOD that\n                 supported $(32length(IndexTypes)) bit integers. It is\n                 currently linked with version that supports $(8intsize)\n                 integers. This might cause Julia to terminate when\n                 working with sparse matrix factorizations, e.g. solving\n                 systems of equations with \\\\.\n\n                 This problem can be fixed by modifying the Julia build\n                 configuration or by downloading the OS X or generic\n                 Linux binary from www.julialang.org, which include\n                 the correct versions of all dependencies.\n                 \"\"\"\n        end\n\n        ### Initiate CHOLMOD\n        ### common_struct controls the type of factorization and keeps pointers\n        ### to temporary memory. We need to manage a copy for each thread.\n        nt = Threads.nthreads()\n        resize!(common_struct    , nt)\n        resize!(common_supernodal, nt)\n        resize!(common_final_ll  , nt)\n        resize!(common_print     , nt)\n        resize!(common_itype     , nt)\n        resize!(common_dtype     , nt)\n        resize!(common_nmethods  , nt)\n        resize!(common_postorder , nt)\n        for i in 1:nt\n            common_struct[i] = fill(0xff, common_size)\n\n            common_supernodal[i] = pointer(common_struct[i], cholmod_com_offsets[4] + 1)\n            common_final_ll[i]   = pointer(common_struct[i], cholmod_com_offsets[7] + 1)\n            common_print[i]      = pointer(common_struct[i], cholmod_com_offsets[13] + 1)\n            common_itype[i]      = pointer(common_struct[i], cholmod_com_offsets[18] + 1)\n            common_dtype[i]      = pointer(common_struct[i], cholmod_com_offsets[19] + 1)\n            common_nmethods[i]   = pointer(common_struct[i], cholmod_com_offsets[15] + 1)\n            common_postorder[i]  = pointer(common_struct[i], cholmod_com_offsets[17] + 1)\n\n            start(common_struct[i])              # initializes CHOLMOD\n            set_print_level(common_struct[i], 0) # no printing from CHOLMOD by default\n        end\n\n        # Register gc tracked allocator if CHOLMOD is new enough\n        if current_version >= v\"3.0.0\"\n            cnfg = cglobal((:SuiteSparse_config, :libsuitesparseconfig), Ptr{Cvoid})\n            unsafe_store!(cnfg, cglobal(:jl_malloc, Ptr{Cvoid}), 1)\n            unsafe_store!(cnfg, cglobal(:jl_calloc, Ptr{Cvoid}), 2)\n            unsafe_store!(cnfg, cglobal(:jl_realloc, Ptr{Cvoid}), 3)\n            unsafe_store!(cnfg, cglobal(:jl_free, Ptr{Cvoid}), 4)\n        end\n\n    catch ex\n        @error \"Error during initialization of module CHOLMOD\" exception=ex,catch_backtrace()\n    end\nend\n\nfunction set_print_level(cm::Vector{UInt8}, lev::Integer)\n    unsafe_store!(common_print[Threads.threadid()], lev)\nend\n\n####################\n# Type definitions #\n####################\n\nabstract type SuiteSparseStruct end\n\n# The three core data types for CHOLMOD: Dense, Sparse and Factor.\n# CHOLMOD manages the memory, so the Julia versions only wrap a\n# pointer to a struct.  Therefore finalizers should be registered each\n# time a pointer is returned from CHOLMOD.\n\n# Dense\nstruct C_Dense{T<:VTypes} <: SuiteSparseStruct\n    nrow::Csize_t\n    ncol::Csize_t\n    nzmax::Csize_t\n    d::Csize_t\n    x::Ptr{T}\n    z::Ptr{Cvoid}\n    xtype::Cint\n    dtype::Cint\nend\n\nmutable struct Dense{Tv<:VTypes} <: DenseMatrix{Tv}\n    ptr::Ptr{C_Dense{Tv}}\n    function Dense{Tv}(ptr::Ptr{C_Dense{Tv}}) where Tv<:VTypes\n        if ptr == C_NULL\n            throw(ArgumentError(\"dense matrix construction failed for \" *\n                \"unknown reasons. Please submit a bug report.\"))\n        end\n        s = unsafe_load(ptr)\n        if s.xtype != xtyp(Tv)\n            free!(ptr)\n            throw(CHOLMODException(\"xtype=$(s.xtype) not supported\"))\n        elseif s.dtype != dtyp(Tv)\n            free!(ptr)\n            throw(CHOLMODException(\"dtype=$(s.dtype) not supported\"))\n        end\n        A = new(ptr)\n        finalizer(free!, A)\n        return A\n    end\nend\nDense(p::Ptr{C_Dense{Tv}}) where {Tv<:VTypes} = Dense{Tv}(p)\n\n# Sparse\n# allow Cvoid pointer for reading matrices of unknown type from files as in\n# cholmod_read_sparse\nstruct C_Sparse{Tv<:Union{Cvoid, VTypes}} <: SuiteSparseStruct\n    nrow::Csize_t\n    ncol::Csize_t\n    nzmax::Csize_t\n    p::Ptr{SuiteSparse_long}\n    i::Ptr{SuiteSparse_long}\n    nz::Ptr{SuiteSparse_long}\n    x::Ptr{Tv}\n    z::Ptr{Cvoid}\n    stype::Cint\n    itype::Cint\n    xtype::Cint\n    dtype::Cint\n    sorted::Cint\n    packed::Cint\nend\n\nmutable struct Sparse{Tv<:VTypes} <: AbstractSparseMatrix{Tv,SuiteSparse_long}\n    ptr::Ptr{C_Sparse{Tv}}\n    function Sparse{Tv}(ptr::Ptr{C_Sparse{Tv}}) where Tv<:VTypes\n        if ptr == C_NULL\n            throw(ArgumentError(\"sparse matrix construction failed for \" *\n                \"unknown reasons. Please submit a bug report.\"))\n        end\n        s = unsafe_load(ptr)\n        if s.itype != ityp(SuiteSparse_long)\n            free!(ptr)\n            throw(CHOLMODException(\"itype=$(s.itype) not supported\"))\n        elseif s.xtype != xtyp(Tv)\n            free!(ptr)\n            throw(CHOLMODException(\"xtype=$(s.xtype) not supported\"))\n        elseif s.dtype != dtyp(Tv)\n            free!(ptr)\n            throw(CHOLMODException(\"dtype=$(s.dtype) not supported\"))\n        end\n        A = new(ptr)\n        finalizer(free!, A)\n        return A\n    end\nend\nSparse(p::Ptr{C_Sparse{Tv}}) where {Tv<:VTypes} = Sparse{Tv}(p)\n\n# Useful when reading in files, but not type stable\nfunction Sparse(p::Ptr{C_Sparse{Cvoid}})\n    if p == C_NULL\n        throw(ArgumentError(\"sparse matrix construction failed for \" *\n                            \"unknown reasons. Please submit a bug report.\"))\n    end\n    s = unsafe_load(p)\n    Tv = s.xtype == REAL ? Float64 : ComplexF64\n    Sparse(convert(Ptr{C_Sparse{Tv}}, p))\nend\n\nBase.unsafe_convert(::Type{Ptr{Tv}}, A::Sparse{Tv}) where {Tv} = getfield(A, :ptr)\n\n# Factor\n# Cvoid is used for pattern-only factors\nstruct C_Factor{Tv<:VTypes} <: SuiteSparseStruct\n    n::Csize_t\n    minor::Csize_t\n    Perm::Ptr{SuiteSparse_long}\n    ColCount::Ptr{SuiteSparse_long}\n    @static if build_version >= v\"2.1.0\"\n        IPerm::Ptr{SuiteSparse_long}  # this pointer was added in version 2.1.0\n    end\n    nzmax::Csize_t\n    p::Ptr{SuiteSparse_long}\n    i::Ptr{SuiteSparse_long}\n    x::Ptr{Tv}\n    z::Ptr{Cvoid}\n    nz::Ptr{SuiteSparse_long}\n    next::Ptr{SuiteSparse_long}\n    prev::Ptr{SuiteSparse_long}\n    nsuper::Csize_t\n    ssize::Csize_t\n    xsize::Csize_t\n    maxcsize::Csize_t\n    maxesize::Csize_t\n    super::Ptr{SuiteSparse_long}\n    pi::Ptr{SuiteSparse_long}\n    px::Ptr{SuiteSparse_long}\n    s::Ptr{SuiteSparse_long}\n    ordering::Cint\n    is_ll::Cint\n    is_super::Cint\n    is_monotonic::Cint\n    itype::Cint\n    xtype::Cint\n    dtype::Cint\nend\n\nmutable struct Factor{Tv<:VTypes} <: Factorization{Tv}\n    ptr::Ptr{C_Factor{Tv}}\n    function Factor{Tv}(ptr::Ptr{C_Factor{Tv}}, register_finalizer = true) where Tv\n        if ptr == C_NULL\n            throw(ArgumentError(\"factorization construction failed for \" *\n                \"unknown reasons. Please submit a bug report.\"))\n        end\n        s = unsafe_load(ptr)\n        if s.itype != ityp(SuiteSparse_long)\n            free!(ptr)\n            throw(CHOLMODException(\"itype=$(s.itype) not supported\"))\n        elseif s.xtype != xtyp(Tv) && s.xtype != PATTERN\n            free!(ptr)\n            throw(CHOLMODException(\"xtype=$(s.xtype) not supported\"))\n        elseif s.dtype != dtyp(Tv)\n            free!(ptr)\n            throw(CHOLMODException(\"dtype=$(s.dtype) not supported\"))\n        end\n        F = new(ptr)\n        if register_finalizer\n            finalizer(free!, F)\n        end\n        return F\n    end\nend\nFactor(ptr::Ptr{C_Factor{Tv}}) where {Tv<:VTypes} = Factor{Tv}(ptr)\nFactor(x::Factor) = x\n\nBase.adjoint(F::Factor) = Adjoint(F)\nBase.transpose(F::Factor) = Transpose(F)\n\n# All pointer loads should be checked to make sure that SuiteSparse is not called with\n# a C_NULL pointer which could cause a segfault. Pointers are set to null\n# when serialized so this can happen when multiple processes are in use.\nfunction Base.unsafe_convert(::Type{Ptr{T}}, x::Union{Dense,Sparse,Factor}) where T<:SuiteSparseStruct\n    xp = getfield(x, :ptr)\n    if xp == C_NULL\n        throw(ArgumentError(\"pointer to the $T object is null. This can \" *\n            \"happen if the object has been serialized.\"))\n    else\n        return xp\n    end\nend\nBase.pointer(x::Dense{Tv}) where {Tv}  = Base.unsafe_convert(Ptr{C_Dense{Tv}}, x)\nBase.pointer(x::Sparse{Tv}) where {Tv} = Base.unsafe_convert(Ptr{C_Sparse{Tv}}, x)\nBase.pointer(x::Factor{Tv}) where {Tv} = Base.unsafe_convert(Ptr{C_Factor{Tv}}, x)\n\n# FactorComponent, for encoding particular factors from a factorization\nmutable struct FactorComponent{Tv,S} <: AbstractMatrix{Tv}\n    F::Factor{Tv}\n\n    function FactorComponent{Tv,S}(F::Factor{Tv}) where {Tv,S}\n        s = unsafe_load(pointer(F))\n        if s.is_ll != 0\n            if !(S === :L || S === :U || S === :PtL || S === :UP)\n                throw(CHOLMODException(string(S, \" not supported for sparse \",\n                    \"LLt matrices; try :L, :U, :PtL, or :UP\")))\n            end\n        elseif !(S === :L || S === :U || S === :PtL || S === :UP ||\n                S === :D || S === :LD || S === :DU || S === :PtLD || S === :DUP)\n            throw(CHOLMODException(string(S, \" not supported for sparse LDLt \",\n                \"matrices; try :L, :U, :PtL, :UP, :D, :LD, :DU, :PtLD, or :DUP\")))\n        end\n        new(F)\n    end\nend\nfunction FactorComponent(F::Factor{Tv}, sym::Symbol) where Tv\n    FactorComponent{Tv,sym}(F)\nend\n\nFactor(FC::FactorComponent) = Factor(FC.F)\n\n#################\n# Thin wrappers #\n#################\n\n# Dense wrappers\n\n### cholmod_core_h ###\nfunction allocate_dense(m::Integer, n::Integer, d::Integer, ::Type{Tv}) where {Tv<:VTypes}\n    Dense(ccall((@cholmod_name(\"allocate_dense\"), :libcholmod), Ptr{C_Dense{Tv}},\n                (Csize_t, Csize_t, Csize_t, Cint, Ptr{Cvoid}),\n                m, n, d, xtyp(Tv), common_struct[Threads.threadid()]))\nend\n\nfunction free!(p::Ptr{C_Dense{Tv}}) where {Tv<:VTypes}\n    @isok ccall((@cholmod_name(\"free_dense\"), :libcholmod), Cint,\n                (Ref{Ptr{C_Dense{Tv}}}, Ptr{Cvoid}),\n                p, common_struct[Threads.threadid()])\nend\nfunction zeros(m::Integer, n::Integer, ::Type{Tv}) where Tv<:VTypes\n    Dense(ccall((@cholmod_name(\"zeros\"), :libcholmod), Ptr{C_Dense{Tv}},\n                (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n                m, n, xtyp(Tv), common_struct[Threads.threadid()]))\nend\nzeros(m::Integer, n::Integer) = zeros(m, n, Float64)\n\nfunction ones(m::Integer, n::Integer, ::Type{Tv}) where Tv<:VTypes\n    Dense(ccall((@cholmod_name(\"ones\"), :libcholmod), Ptr{C_Dense{Tv}},\n                (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n                m, n, xtyp(Tv), common_struct[Threads.threadid()]))\nend\nones(m::Integer, n::Integer) = ones(m, n, Float64)\n\nfunction eye(m::Integer, n::Integer, ::Type{Tv}) where Tv<:VTypes\n    Dense(ccall((@cholmod_name(\"eye\"), :libcholmod), Ptr{C_Dense{Tv}},\n                (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n                m, n, xtyp(Tv), common_struct[Threads.threadid()]))\nend\neye(m::Integer, n::Integer) = eye(m, n, Float64)\neye(n::Integer) = eye(n, n, Float64)\n\nfunction copy(A::Dense{Tv}) where Tv<:VTypes\n    Dense(ccall((@cholmod_name(\"copy_dense\"), :libcholmod), Ptr{C_Dense{Tv}},\n                (Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n                A, common_struct[Threads.threadid()]))\nend\n\nfunction sort!(S::Sparse{Tv}) where Tv<:VTypes\n    @isok ccall((@cholmod_name(\"sort\"), :libcholmod), Cint,\n                (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                S, common_struct[Threads.threadid()])\n    return S\nend\n\n### cholmod_matrixops.h ###\nfunction norm_dense(D::Dense{Tv}, p::Integer) where Tv<:VTypes\n    s = unsafe_load(pointer(D))\n    if p == 2\n        if s.ncol > 1\n            throw(ArgumentError(\"2 norm only supported when matrix has one column\"))\n        end\n    elseif p != 0 && p != 1\n        throw(ArgumentError(\"second argument must be either 0 (Inf norm), 1, or 2\"))\n    end\n    ccall((@cholmod_name(\"norm_dense\"), :libcholmod), Cdouble,\n        (Ptr{C_Dense{Tv}}, Cint, Ptr{UInt8}),\n          D, p, common_struct[Threads.threadid()])\nend\n\n### cholmod_check.h ###\nfunction check_dense(A::Dense{Tv}) where Tv<:VTypes\n    ccall((@cholmod_name(\"check_dense\"), :libcholmod), Cint,\n          (Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n          pointer(A), common_struct[Threads.threadid()]) != 0\nend\n\n# Non-Dense wrappers\n### cholmod_core.h ###\nfunction allocate_sparse(nrow::Integer, ncol::Integer, nzmax::Integer,\n        sorted::Bool, packed::Bool, stype::Integer, ::Type{Tv}) where {Tv<:VTypes}\n    Sparse(ccall((@cholmod_name(\"allocate_sparse\"), :libcholmod),\n            Ptr{C_Sparse{Tv}},\n                (Csize_t, Csize_t, Csize_t, Cint,\n                 Cint, Cint, Cint, Ptr{Cvoid}),\n                nrow, ncol, nzmax, sorted,\n                packed, stype, xtyp(Tv), common_struct[Threads.threadid()]))\nend\n\nfunction free!(ptr::Ptr{C_Sparse{Tv}}) where Tv<:VTypes\n    @isok ccall((@cholmod_name(\"free_sparse\"), :libcholmod), Cint,\n            (Ref{Ptr{C_Sparse{Tv}}}, Ptr{UInt8}),\n                ptr, common_struct[Threads.threadid()])\nend\n\nfunction free!(ptr::Ptr{C_Factor{Tv}}) where Tv<:VTypes\n    # Warning! Important that finalizer doesn't modify the global Common struct.\n    @isok ccall((@cholmod_name(\"free_factor\"), :libcholmod), Cint,\n            (Ref{Ptr{C_Factor{Tv}}}, Ptr{Cvoid}),\n                ptr, common_struct[Threads.threadid()])\nend\n\nfunction aat(A::Sparse{Tv}, fset::Vector{SuiteSparse_long}, mode::Integer) where Tv<:VRealTypes\n    Sparse(ccall((@cholmod_name(\"aat\"), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{SuiteSparse_long}, Csize_t, Cint, Ptr{UInt8}),\n                A, fset, length(fset), mode, common_struct[Threads.threadid()]))\nend\n\nfunction sparse_to_dense(A::Sparse{Tv}) where Tv<:VTypes\n    Dense(ccall((@cholmod_name(\"sparse_to_dense\"),:libcholmod),\n        Ptr{C_Dense{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                A, common_struct[Threads.threadid()]))\nend\nfunction dense_to_sparse(D::Dense{Tv}, ::Type{SuiteSparse_long}) where Tv<:VTypes\n    Sparse(ccall((@cholmod_name(\"dense_to_sparse\"),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Dense{Tv}}, Cint, Ptr{UInt8}),\n                D, true, common_struct[Threads.threadid()]))\nend\n\nfunction factor_to_sparse!(F::Factor{Tv}) where Tv<:VTypes\n    ss = unsafe_load(pointer(F))\n    ss.xtype == PATTERN && throw(CHOLMODException(\"only numeric factors are supported\"))\n    Sparse(ccall((@cholmod_name(\"factor_to_sparse\"),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                F, common_struct[Threads.threadid()]))\nend\n\nfunction change_factor!(F::Factor{Tv}, to_ll::Bool, to_super::Bool, to_packed::Bool,\n                        to_monotonic::Bool) where Tv<:VTypes\n    @isok ccall((@cholmod_name(\"change_factor\"),:libcholmod), Cint,\n            (Cint, Cint, Cint, Cint, Cint, Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                xtyp(Tv), to_ll, to_super, to_packed, to_monotonic, F, common_struct[Threads.threadid()])\nend\n\nfunction check_sparse(A::Sparse{Tv}) where Tv<:VTypes\n    ccall((@cholmod_name(\"check_sparse\"),:libcholmod), Cint,\n          (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n           A, common_struct[Threads.threadid()]) != 0\nend\n\nfunction check_factor(F::Factor{Tv}) where Tv<:VTypes\n    ccall((@cholmod_name(\"check_factor\"),:libcholmod), Cint,\n          (Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n           F, common_struct[Threads.threadid()]) != 0\nend\n\nfunction nnz(A::Sparse{Tv}) where Tv<:VTypes\n    ccall((@cholmod_name(\"nnz\"),:libcholmod), Int,\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                A, common_struct[Threads.threadid()])\nend\n\nfunction speye(m::Integer, n::Integer, ::Type{Tv}) where Tv<:VTypes\n    Sparse(ccall((@cholmod_name(\"speye\"), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n                m, n, xtyp(Tv), common_struct[Threads.threadid()]))\nend\n\nfunction spzeros(m::Integer, n::Integer, nzmax::Integer, ::Type{Tv}) where Tv<:VTypes\n    Sparse(ccall((@cholmod_name(\"spzeros\"), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Csize_t, Csize_t, Csize_t, Cint, Ptr{UInt8}),\n             m, n, nzmax, xtyp(Tv), common_struct[Threads.threadid()]))\nend\n\nfunction transpose_(A::Sparse{Tv}, values::Integer) where Tv<:VTypes\n    Sparse(ccall((@cholmod_name(\"transpose\"),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n                A, values, common_struct[Threads.threadid()]))\nend\n\nfunction copy(F::Factor{Tv}) where Tv<:VTypes\n    Factor(ccall((@cholmod_name(\"copy_factor\"),:libcholmod),\n        Ptr{C_Factor{Tv}},\n            (Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                F, common_struct[Threads.threadid()]))\nend\nfunction copy(A::Sparse{Tv}) where Tv<:VTypes\n    Sparse(ccall((@cholmod_name(\"copy_sparse\"),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                A, common_struct[Threads.threadid()]))\nend\nfunction copy(A::Sparse{Tv}, stype::Integer, mode::Integer) where Tv<:VRealTypes\n    Sparse(ccall((@cholmod_name(\"copy\"),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Cint, Cint, Ptr{UInt8}),\n                A, stype, mode, common_struct[Threads.threadid()]))\nend\n\n### cholmod_check.h ###\nfunction print_sparse(A::Sparse{Tv}, name::String) where Tv<:VTypes\n    isascii(name) || error(\"non-ASCII name: $name\")\n    set_print_level(common_struct[Threads.threadid()], 3)\n    @isok ccall((@cholmod_name(\"print_sparse\"),:libcholmod), Cint,\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}, Ptr{UInt8}),\n                 A, name, common_struct[Threads.threadid()])\n    nothing\nend\nfunction print_factor(F::Factor{Tv}, name::String) where Tv<:VTypes\n    set_print_level(common_struct[Threads.threadid()], 3)\n    @isok ccall((@cholmod_name(\"print_factor\"),:libcholmod), Cint,\n            (Ptr{C_Factor{Tv}}, Ptr{UInt8}, Ptr{UInt8}),\n                F, name, common_struct[Threads.threadid()])\n    nothing\nend\n\n### cholmod_matrixops.h ###\nfunction ssmult(A::Sparse{Tv}, B::Sparse{Tv}, stype::Integer,\n        values::Bool, sorted::Bool) where Tv<:VRealTypes\n    lA = unsafe_load(pointer(A))\n    lB = unsafe_load(pointer(B))\n    if lA.ncol != lB.nrow\n        throw(DimensionMismatch(\"inner matrix dimensions do not fit\"))\n    end\n    Sparse(ccall((@cholmod_name(\"ssmult\"),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{C_Sparse{Tv}}, Cint, Cint,\n                Cint, Ptr{UInt8}),\n             A, B, stype, values,\n                sorted, common_struct[Threads.threadid()]))\nend\n\nfunction norm_sparse(A::Sparse{Tv}, norm::Integer) where Tv<:VTypes\n    if norm != 0 && norm != 1\n        throw(ArgumentError(\"norm argument must be either 0 or 1\"))\n    end\n    ccall((@cholmod_name(\"norm_sparse\"), :libcholmod), Cdouble,\n            (Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n                A, norm, common_struct[Threads.threadid()])\nend\n\nfunction horzcat(A::Sparse{Tv}, B::Sparse{Tv}, values::Bool) where Tv<:VRealTypes\n    Sparse(ccall((@cholmod_name(\"horzcat\"), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n             A, B, values, common_struct[Threads.threadid()]))\nend\n\nfunction scale!(S::Dense{Tv}, scale::Integer, A::Sparse{Tv}) where Tv<:VRealTypes\n    sS = unsafe_load(pointer(S))\n    sA = unsafe_load(pointer(A))\n    if sS.ncol != 1 && sS.nrow != 1\n        throw(DimensionMismatch(\"first argument must be a vector\"))\n    end\n    if scale == SCALAR && sS.nrow != 1\n        throw(DimensionMismatch(\"scaling argument must have length one\"))\n    elseif scale == ROW && sS.nrow*sS.ncol != sA.nrow\n        throw(DimensionMismatch(\"scaling vector has length $(sS.nrow*sS.ncol), \" *\n            \"but matrix has $(sA.nrow) rows.\"))\n    elseif scale == COL && sS.nrow*sS.ncol != sA.ncol\n        throw(DimensionMismatch(\"scaling vector has length $(sS.nrow*sS.ncol), \" *\n            \"but matrix has $(sA.ncol) columns\"))\n    elseif scale == SYM\n        if sA.nrow != sA.ncol\n            throw(DimensionMismatch(\"matrix must be square\"))\n        elseif sS.nrow*sS.ncol != sA.nrow\n            throw(DimensionMismatch(\"scaling vector has length $(sS.nrow*sS.ncol), \" *\n                \"but matrix has $(sA.ncol) columns and rows\"))\n        end\n    end\n\n    sA = unsafe_load(pointer(A))\n    @isok ccall((@cholmod_name(\"scale\"),:libcholmod), Cint,\n            (Ptr{C_Dense{Tv}}, Cint, Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                S, scale, A, common_struct[Threads.threadid()])\n    A\nend\n\nfunction sdmult!(A::Sparse{Tv}, transpose::Bool,\n        \u03b1::Number, \u03b2::Number, X::Dense{Tv}, Y::Dense{Tv}) where Tv<:VTypes\n    m, n = size(A)\n    nc = transpose ? m : n\n    nr = transpose ? n : m\n    if nc != size(X, 1)\n        throw(DimensionMismatch(\"incompatible dimensions, $nc and $(size(X,1))\"))\n    end\n    @isok ccall((@cholmod_name(\"sdmult\"),:libcholmod), Cint,\n            (Ptr{C_Sparse{Tv}}, Cint,\n             Ref{ComplexF64}, Ref{ComplexF64},\n             Ptr{C_Dense{Tv}}, Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n                A, transpose, \u03b1, \u03b2, X, Y, common_struct[Threads.threadid()])\n    Y\nend\n\nfunction vertcat(A::Sparse{Tv}, B::Sparse{Tv}, values::Bool) where Tv<:VRealTypes\n    Sparse(ccall((@cholmod_name(\"vertcat\"), :libcholmod),\n            Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n                A, B, values, common_struct[Threads.threadid()]))\nend\n\nfunction symmetry(A::Sparse{Tv}, option::Integer) where Tv<:VTypes\n    xmatched = Ref{SuiteSparse_long}()\n    pmatched = Ref{SuiteSparse_long}()\n    nzoffdiag = Ref{SuiteSparse_long}()\n    nzdiag = Ref{SuiteSparse_long}()\n    rv = ccall((@cholmod_name(\"symmetry\"), :libcholmod), Cint,\n            (Ptr{C_Sparse{Tv}}, Cint, Ptr{SuiteSparse_long}, Ptr{SuiteSparse_long},\n                Ptr{SuiteSparse_long}, Ptr{SuiteSparse_long}, Ptr{UInt8}),\n                    A, option, xmatched, pmatched,\n                        nzoffdiag, nzdiag, common_struct[Threads.threadid()])\n    rv, xmatched[], pmatched[], nzoffdiag[], nzdiag[]\nend\n\n# cholmod_cholesky.h\n# For analyze, analyze_p, and factorize_p!, the Common argument must be\n# supplied in order to control if the factorization is LLt or LDLt\nfunction analyze(A::Sparse{Tv}, cmmn::Vector{UInt8}) where Tv<:VTypes\n    Factor(ccall((@cholmod_name(\"analyze\"),:libcholmod),\n        Ptr{C_Factor{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                A, cmmn))\nend\nfunction analyze_p(A::Sparse{Tv}, perm::Vector{SuiteSparse_long},\n                   cmmn::Vector{UInt8}) where Tv<:VTypes\n    length(perm) != size(A,1) && throw(BoundsError())\n    Factor(ccall((@cholmod_name(\"analyze_p\"),:libcholmod),\n            Ptr{C_Factor{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{SuiteSparse_long}, Ptr{SuiteSparse_long},\n                Csize_t, Ptr{UInt8}),\n                A, perm, C_NULL, 0, cmmn))\nend\nfunction factorize!(A::Sparse{Tv}, F::Factor{Tv}, cmmn::Vector{UInt8}) where Tv<:VTypes\n    @isok ccall((@cholmod_name(\"factorize\"),:libcholmod), Cint,\n        (Ptr{C_Sparse{Tv}}, Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n            A, F, cmmn)\n    F\nend\nfunction factorize_p!(A::Sparse{Tv}, \u03b2::Real, F::Factor{Tv}, cmmn::Vector{UInt8}) where Tv<:VTypes\n    # note that \u03b2 is passed as a complex number (double beta[2]),\n    # but the CHOLMOD manual says that only beta[0] (real part) is used\n    @isok ccall((@cholmod_name(\"factorize_p\"),:libcholmod), Cint,\n        (Ptr{C_Sparse{Tv}}, Ref{ComplexF64}, Ptr{SuiteSparse_long}, Csize_t,\n         Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n            A, \u03b2, C_NULL, 0, F, cmmn)\n    F\nend\n\nfunction solve(sys::Integer, F::Factor{Tv}, B::Dense{Tv}) where Tv<:VTypes\n    if size(F,1) != size(B,1)\n        throw(DimensionMismatch(\"LHS and RHS should have the same number of rows. \" *\n            \"LHS has $(size(F,1)) rows, but RHS has $(size(B,1)) rows.\"))\n    end\n    if !issuccess(F)\n        s = unsafe_load(pointer(F))\n        if s.is_ll == 1\n            throw(LinearAlgebra.PosDefException(s.minor))\n        else\n            throw(LinearAlgebra.ZeroPivotException(s.minor))\n        end\n    end\n    Dense(ccall((@cholmod_name(\"solve\"),:libcholmod), Ptr{C_Dense{Tv}},\n            (Cint, Ptr{C_Factor{Tv}}, Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n                sys, F, B, common_struct[Threads.threadid()]))\nend\n\nfunction spsolve(sys::Integer, F::Factor{Tv}, B::Sparse{Tv}) where Tv<:VTypes\n    if size(F,1) != size(B,1)\n        throw(DimensionMismatch(\"LHS and RHS should have the same number of rows. \" *\n            \"LHS has $(size(F,1)) rows, but RHS has $(size(B,1)) rows.\"))\n    end\n    Sparse(ccall((@cholmod_name(\"spsolve\"),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Cint, Ptr{C_Factor{Tv}}, Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                sys, F, B, common_struct[Threads.threadid()]))\nend\n\n# Autodetects the types\nfunction read_sparse(file::Libc.FILE, ::Type{SuiteSparse_long})\n    ptr = ccall((@cholmod_name(\"read_sparse\"), :libcholmod),\n        Ptr{C_Sparse{Cvoid}},\n            (Ptr{Cvoid}, Ptr{UInt8}),\n                file.ptr, common_struct[Threads.threadid()])\n    if ptr == C_NULL\n        throw(ArgumentError(\"sparse matrix construction failed. Check that input file is valid.\"))\n    end\n    Sparse(ptr)\nend\n\nfunction read_sparse(file::IO, T)\n    cfile = Libc.FILE(file)\n    try return read_sparse(cfile, T)\n    finally close(cfile)\n    end\nend\n\nfunction get_perm(F::Factor)\n    s = unsafe_load(pointer(F))\n    p = unsafe_wrap(Array, s.Perm, s.n, own = false)\n    p .+ 1\nend\nget_perm(FC::FactorComponent) = get_perm(Factor(FC))\n\n#########################\n# High level interfaces #\n#########################\n\n# Conversion/construction\nfunction Dense{T}(A::StridedVecOrMat) where T<:VTypes\n    d = allocate_dense(size(A, 1), size(A, 2), stride(A, 2), T)\n    GC.@preserve d begin\n        s = unsafe_load(pointer(d))\n        for (i, c) in enumerate(eachindex(A))\n            unsafe_store!(s.x, A[c], i)\n        end\n    end\n    d\nend\nfunction Dense{T}(A::Union{Adjoint{<:Any, <:StridedVecOrMat}, Transpose{<:Any, <:StridedVecOrMat}}) where T<:VTypes\n    d = allocate_dense(size(A, 1), size(A, 2), size(A, 1), T)\n    GC.@preserve d begin\n        s = unsafe_load(pointer(d))\n        for (i, c) in enumerate(eachindex(A))\n            unsafe_store!(s.x, A[c], i)\n        end\n    end\n    d\nend\nfunction Dense(A::Union{StridedVecOrMat, Adjoint{<:Any, <:StridedVecOrMat}, Transpose{<:Any, <:StridedVecOrMat}})\n    T = promote_type(eltype(A), Float64)\n    return Dense{T}(A)\nend\nDense(A::Sparse) = sparse_to_dense(A)\n\n# This constructior assumes zero based colptr and rowval\nfunction Sparse(m::Integer, n::Integer,\n        colptr0::Vector{SuiteSparse_long}, rowval0::Vector{SuiteSparse_long},\n        nzval::Vector{Tv}, stype) where Tv<:VTypes\n    # checks\n    ## length of input\n    if length(colptr0) <= n\n        throw(ArgumentError(\"length of colptr0 must be at least n + 1 = $(n + 1) but was $(length(colptr0))\"))\n    end\n    if colptr0[n + 1] > length(rowval0)\n        throw(ArgumentError(\"length of rowval0 is $(length(rowval0)) but value of colptr0 requires length to be at least $(colptr0[n + 1])\"))\n    end\n    if colptr0[n + 1] > length(nzval)\n        throw(ArgumentError(\"length of nzval is $(length(nzval)) but value of colptr0 requires length to be at least $(colptr0[n + 1])\"))\n    end\n    ## columns are sorted\n    iss = true\n    for i = 2:length(colptr0)\n        if !issorted(view(rowval0, colptr0[i - 1] + 1:colptr0[i]))\n            iss = false\n            break\n        end\n    end\n\n    o = allocate_sparse(m, n, colptr0[n + 1], iss, true, stype, Tv)\n    s = unsafe_load(pointer(o))\n\n    unsafe_copyto!(s.p, pointer(colptr0), n + 1)\n    unsafe_copyto!(s.i, pointer(rowval0), colptr0[n + 1])\n    unsafe_copyto!(s.x, pointer(nzval) , colptr0[n + 1])\n\n    @isok check_sparse(o)\n\n    return o\nend\n\nfunction Sparse(m::Integer, n::Integer,\n        colptr0::Vector{SuiteSparse_long},\n        rowval0::Vector{SuiteSparse_long},\n        nzval::Vector{<:VTypes})\n    o = Sparse(m, n, colptr0, rowval0, nzval, 0)\n\n    # sort indices\n    sort!(o)\n\n    # check if array is symmetric and change stype if it is\n    if ishermitian(o)\n        change_stype!(o, -1)\n    end\n    o\nend\n\nfunction Sparse{Tv}(A::SparseMatrixCSC, stype::Integer) where Tv<:VTypes\n    ## Check length of input. This should never fail but see #20024\n    if length(getcolptr(A)) <= size(A, 2)\n        throw(ArgumentError(\"length of colptr must be at least size(A,2) + 1 = $(size(A, 2) + 1) but was $(length(getcolptr(A)))\"))\n    end\n    if nnz(A) > length(rowvals(A))\n        throw(ArgumentError(\"length of rowval is $(length(rowvals(A))) but value of colptr requires length to be at least $(nnz(A))\"))\n    end\n    if nnz(A) > length(nonzeros(A))\n        throw(ArgumentError(\"length of nzval is $(length(nonzeros(A))) but value of colptr requires length to be at least $(nnz(A))\"))\n    end\n\n    o = allocate_sparse(size(A, 1), size(A, 2), nnz(A), true, true, stype, Tv)\n    s = unsafe_load(pointer(o))\n    for i = 1:(size(A, 2) + 1)\n        unsafe_store!(s.p, getcolptr(A)[i] - 1, i)\n    end\n    for i = 1:nnz(A)\n        unsafe_store!(s.i, rowvals(A)[i] - 1, i)\n    end\n    if Tv <: Complex && stype != 0\n        # Need to remove any non real elements in the diagonal because, in contrast to\n        # BLAS/LAPACK these are not ignored by CHOLMOD. If even tiny imaginary parts are\n        # present CHOLMOD will fail with a non-positive definite/zero pivot error.\n        for j = 1:size(A, 2)\n            for ip = getcolptr(A)[j]:getcolptr(A)[j + 1] - 1\n                v = nonzeros(A)[ip]\n                unsafe_store!(s.x, rowvals(A)[ip] == j ? Complex(real(v)) : v, ip)\n            end\n        end\n    elseif Tv == eltype(nonzeros(A))\n        unsafe_copyto!(s.x, pointer(nonzeros(A)), nnz(A))\n    else\n        for i = 1:nnz(A)\n            unsafe_store!(s.x, nonzeros(A)[i], i)\n        end\n    end\n\n    @isok check_sparse(o)\n\n    return o\nend\n\n# handle promotion\nfunction Sparse(A::SparseMatrixCSC{Tv,SuiteSparse_long}, stype::Integer) where {Tv}\n    T = promote_type(Tv, Float64)\n    return Sparse{T}(A, stype)\nend\n\n# convert SparseVectors into CHOLMOD Sparse types through a mx1 CSC matrix\nSparse(A::SparseVector) = Sparse(SparseMatrixCSC(A))\nfunction Sparse(A::SparseMatrixCSC)\n    o = Sparse(A, 0)\n    # check if array is symmetric and change stype if it is\n    if ishermitian(o)\n        change_stype!(o, -1)\n    end\n    o\nend\n\nSparse(A::Symmetric{Tv, SparseMatrixCSC{Tv,Ti}}) where {Tv<:Real, Ti} =\n    Sparse(A.data, A.uplo == 'L' ? -1 : 1)\nSparse(A::Hermitian{Tv,SparseMatrixCSC{Tv,Ti}}) where {Tv, Ti} =\n    Sparse(A.data, A.uplo == 'L' ? -1 : 1)\n\nSparse(A::Dense) = dense_to_sparse(A, SuiteSparse_long)\nSparse(L::Factor) = factor_to_sparse!(copy(L))\nfunction Sparse(filename::String)\n    open(filename) do f\n        return read_sparse(f, SuiteSparse_long)\n    end\nend\n\n## conversion back to base Julia types\nfunction Matrix{T}(D::Dense{T}) where T\n    s = unsafe_load(pointer(D))\n    a = Matrix{T}(undef, s.nrow, s.ncol)\n    copyto!(a, D)\nend\n\nBase.copyto!(dest::Base.PermutedDimsArrays.PermutedDimsArray, src::Dense) = _copy!(dest, src) # ambig\nBase.copyto!(dest::Dense{T}, D::Dense{T}) where {T<:VTypes} = _copy!(dest, D)\nBase.copyto!(dest::AbstractArray{T}, D::Dense{T}) where {T<:VTypes} = _copy!(dest, D)\nBase.copyto!(dest::AbstractArray{T,2}, D::Dense{T}) where {T<:VTypes} = _copy!(dest, D)\nBase.copyto!(dest::AbstractArray, D::Dense) = _copy!(dest, D)\n\nfunction _copy!(dest::AbstractArray, D::Dense)\n    require_one_based_indexing(dest)\n    s = unsafe_load(pointer(D))\n    n = s.nrow*s.ncol\n    n <= length(dest) || throw(BoundsError(dest, n))\n    if s.d == s.nrow && isa(dest, Array)\n        unsafe_copyto!(pointer(dest), s.x, s.d*s.ncol)\n    else\n        k = 0\n        for j = 1:s.ncol\n            for i = 1:s.nrow\n                dest[k+=1] = unsafe_load(s.x, i + (j - 1)*s.d)\n            end\n        end\n    end\n    dest\nend\nMatrix(D::Dense{T}) where {T} = Matrix{T}(D)\nfunction Vector{T}(D::Dense{T}) where T\n    if size(D, 2) > 1\n        throw(DimensionMismatch(\"input must be a vector but had $(size(D, 2)) columns\"))\n    end\n    copyto!(Vector{T}(undef, size(D, 1)), D)\nend\nVector(D::Dense{T}) where {T} = Vector{T}(D)\n\nfunction SparseMatrixCSC{Tv,SuiteSparse_long}(A::Sparse{Tv}) where Tv\n    s = unsafe_load(pointer(A))\n    if s.stype != 0\n        throw(ArgumentError(\"matrix has stype != 0. Convert to matrix \" *\n            \"with stype == 0 before converting to SparseMatrixCSC\"))\n    end\n\n    B = SparseMatrixCSC(s.nrow, s.ncol,\n        increment(unsafe_wrap(Array, s.p, (s.ncol + 1,), own = false)),\n        increment(unsafe_wrap(Array, s.i, (s.nzmax,), own = false)),\n        copy(unsafe_wrap(Array, s.x, (s.nzmax,), own = false)))\n\n    if s.sorted == 0\n        return SparseArrays.sortSparseMatrixCSC!(B)\n    else\n        return B\n    end\nend\n\nfunction Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}(A::Sparse{Float64})\n    s = unsafe_load(pointer(A))\n    if !issymmetric(A)\n        throw(ArgumentError(\"matrix is not symmetric\"))\n    end\n\n    B = Symmetric(SparseMatrixCSC(s.nrow, s.ncol,\n        increment(unsafe_wrap(Array, s.p, (s.ncol + 1,), own = false)),\n        increment(unsafe_wrap(Array, s.i, (s.nzmax,), own = false)),\n        copy(unsafe_wrap(Array, s.x, (s.nzmax,), own = false))), s.stype > 0 ? :U : :L)\n\n    if s.sorted == 0\n        return SparseArrays.sortSparseMatrixCSC!(B.data)\n    else\n        return B\n    end\nend\nconvert(T::Type{Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}}, A::Sparse{Float64}) = T(A)\n\nfunction Hermitian{Tv,SparseMatrixCSC{Tv,SuiteSparse_long}}(A::Sparse{Tv}) where Tv<:VTypes\n    s = unsafe_load(pointer(A))\n    if !ishermitian(A)\n        throw(ArgumentError(\"matrix is not Hermitian\"))\n    end\n\n    B = Hermitian(SparseMatrixCSC(s.nrow, s.ncol,\n        increment(unsafe_wrap(Array, s.p, (s.ncol + 1,), own = false)),\n        increment(unsafe_wrap(Array, s.i, (s.nzmax,), own = false)),\n        copy(unsafe_wrap(Array, s.x, (s.nzmax,), own = false))), s.stype > 0 ? :U : :L)\n\n    if s.sorted == 0\n        return SparseArrays.sortSparseMatrixCSC!(B.data)\n    else\n        return B\n    end\nend\nconvert(T::Type{Hermitian{Tv,SparseMatrixCSC{Tv,SuiteSparse_long}}}, A::Sparse{Tv}) where {Tv<:VTypes} = T(A)\n\nfunction sparse(A::Sparse{Float64}) # Notice! Cannot be type stable because of stype\n    s = unsafe_load(pointer(A))\n    if s.stype == 0\n        return SparseMatrixCSC{Float64,SuiteSparse_long}(A)\n    end\n    return Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}(A)\nend\nfunction sparse(A::Sparse{ComplexF64}) # Notice! Cannot be type stable because of stype\n    s = unsafe_load(pointer(A))\n    if s.stype == 0\n        return SparseMatrixCSC{ComplexF64,SuiteSparse_long}(A)\n    end\n    return Hermitian{ComplexF64,SparseMatrixCSC{ComplexF64,SuiteSparse_long}}(A)\nend\nfunction sparse(F::Factor)\n    s = unsafe_load(pointer(F))\n    if s.is_ll != 0\n        L = Sparse(F)\n        A = sparse(L*L')\n    else\n        LD = sparse(F.LD)\n        L, d = getLd!(LD)\n        A = (L * Diagonal(d)) * L'\n    end\n    SparseArrays.sortSparseMatrixCSC!(A)\n    p = get_perm(F)\n    if p != [1:s.n;]\n        pinv = Vector{Int}(undef, length(p))\n        for k = 1:length(p)\n            pinv[p[k]] = k\n        end\n        A = A[pinv,pinv]\n    end\n    A\nend\n\nsparse(D::Dense) = sparse(Sparse(D))\n\nfunction sparse(FC::FactorComponent{Tv,:L}) where Tv\n    F = Factor(FC)\n    s = unsafe_load(pointer(F))\n    if s.is_ll == 0\n        throw(CHOLMODException(\"sparse: supported only for :LD on LDLt factorizations\"))\n    end\n    sparse(Sparse(F))\nend\nsparse(FC::FactorComponent{Tv,:LD}) where {Tv} = sparse(Sparse(Factor(FC)))\n\n# Calculate the offset into the stype field of the cholmod_sparse_struct and\n# change the value\nlet offset = fieldoffset(C_Sparse{Float64}, findfirst(name -> name === :stype, fieldnames(C_Sparse{Float64}))::Int)\n    global change_stype!\n    function change_stype!(A::Sparse, i::Integer)\n        unsafe_store!(convert(Ptr{Cint}, pointer(A)), i, div(offset, 4) + 1)\n        return A\n    end\nend\n\nfree!(A::Dense)  = free!(pointer(A))\nfree!(A::Sparse) = free!(pointer(A))\nfree!(F::Factor) = free!(pointer(F))\n\neltype(::Type{Dense{T}}) where {T<:VTypes} = T\neltype(::Type{Factor{T}}) where {T<:VTypes} = T\neltype(::Type{Sparse{T}}) where {T<:VTypes} = T\n\nnnz(F::Factor) = nnz(Sparse(F))\n\nfunction show(io::IO, F::Factor)\n    println(io, typeof(F))\n    showfactor(io, F)\nend\n\nfunction show(io::IO, FC::FactorComponent)\n    println(io, typeof(FC))\n    showfactor(io, Factor(FC))\nend\n\nfunction showfactor(io::IO, F::Factor)\n    s = unsafe_load(pointer(F))\n    print(io, \"\"\"\n        type:    $(s.is_ll!=0 ? \"LLt\" : \"LDLt\")\n        method:  $(s.is_super!=0 ? \"supernodal\" : \"simplicial\")\n        maxnnz:  $(Int(s.nzmax))\n        nnz:     $(nnz(F))\n        success: $(s.minor == size(F, 1))\n        \"\"\")\nend\n\n# getindex not defined for these, so don't use the normal array printer\nshow(io::IO, ::MIME\"text/plain\", FC::FactorComponent) = show(io, FC)\nshow(io::IO, ::MIME\"text/plain\", F::Factor) = show(io, F)\n\nisvalid(A::Dense) = check_dense(A)\nisvalid(A::Sparse) = check_sparse(A)\nisvalid(A::Factor) = check_factor(A)\n\nfunction size(A::Union{Dense,Sparse})\n    s = unsafe_load(pointer(A))\n    return (Int(s.nrow), Int(s.ncol))\nend\nfunction size(F::Factor, i::Integer)\n    if i < 1\n        throw(ArgumentError(\"dimension must be positive\"))\n    end\n    s = unsafe_load(pointer(F))\n    if i <= 2\n        return Int(s.n)\n    end\n    return 1\nend\nsize(F::Factor) = (size(F, 1), size(F, 2))\naxes(A::Union{Dense,Sparse,Factor}) = map(Base.OneTo, size(A))\n\nIndexStyle(::Dense) = IndexLinear()\n\nsize(FC::FactorComponent, i::Integer) = size(FC.F, i)\nsize(FC::FactorComponent) = size(FC.F)\n\nadjoint(FC::FactorComponent{Tv,:L}) where {Tv} = FactorComponent{Tv,:U}(FC.F)\nadjoint(FC::FactorComponent{Tv,:U}) where {Tv} = FactorComponent{Tv,:L}(FC.F)\nadjoint(FC::FactorComponent{Tv,:PtL}) where {Tv} = FactorComponent{Tv,:UP}(FC.F)\nadjoint(FC::FactorComponent{Tv,:UP}) where {Tv} = FactorComponent{Tv,:PtL}(FC.F)\nadjoint(FC::FactorComponent{Tv,:D}) where {Tv} = FC\nadjoint(FC::FactorComponent{Tv,:LD}) where {Tv} = FactorComponent{Tv,:DU}(FC.F)\nadjoint(FC::FactorComponent{Tv,:DU}) where {Tv} = FactorComponent{Tv,:LD}(FC.F)\nadjoint(FC::FactorComponent{Tv,:PtLD}) where {Tv} = FactorComponent{Tv,:DUP}(FC.F)\nadjoint(FC::FactorComponent{Tv,:DUP}) where {Tv} = FactorComponent{Tv,:PtLD}(FC.F)\n\nfunction getindex(A::Dense, i::Integer)\n    s = unsafe_load(pointer(A))\n    0 < i <= s.nrow*s.ncol || throw(BoundsError())\n    unsafe_load(s.x, i)\nend\n\nIndexStyle(::Sparse) = IndexCartesian()\nfunction getindex(A::Sparse{T}, i0::Integer, i1::Integer) where T\n    s = unsafe_load(pointer(A))\n    !(1 <= i0 <= s.nrow && 1 <= i1 <= s.ncol) && throw(BoundsError())\n    s.stype < 0 && i0 < i1 && return conj(A[i1,i0])\n    s.stype > 0 && i0 > i1 && return conj(A[i1,i0])\n\n    r1 = Int(unsafe_load(s.p, i1) + 1)\n    r2 = Int(unsafe_load(s.p, i1 + 1))\n    (r1 > r2) && return zero(T)\n    r1 = Int(searchsortedfirst(unsafe_wrap(Array, s.i, (s.nzmax,), own = false),\n        i0 - 1, r1, r2, Base.Order.Forward))\n    ((r1 > r2) || (unsafe_load(s.i, r1) + 1 != i0)) ? zero(T) : unsafe_load(s.x, r1)\nend\n\n@inline function getproperty(F::Factor, sym::Symbol)\n    if sym === :p\n        return get_perm(F)\n    elseif sym === :ptr\n        return getfield(F, :ptr)\n    else\n        return FactorComponent(F, sym)\n    end\nend\n\nfunction getLd!(S::SparseMatrixCSC)\n    d = Vector{eltype(S)}(undef, size(S, 1))\n    fill!(d, 0)\n    col = 1\n    for k = 1:nnz(S)\n        while k >= getcolptr(S)[col+1]\n            col += 1\n        end\n        if rowvals(S)[k] == col\n            d[col] = nonzeros(S)[k]\n            nonzeros(S)[k] = 1\n        end\n    end\n    S, d\nend\n\n## Multiplication\n(*)(A::Sparse, B::Sparse) = ssmult(A, B, 0, true, true)\n(*)(A::Sparse, B::Dense) = sdmult!(A, false, 1., 0., B, zeros(size(A, 1), size(B, 2)))\n(*)(A::Sparse, B::VecOrMat) = (*)(A, Dense(B))\n\nfunction *(A::Sparse{Tv}, adjB::Adjoint{Tv,Sparse{Tv}}) where Tv<:VRealTypes\n    B = adjB.parent\n    if A !== B\n        aa1 = transpose_(B, 2)\n        ## result of ssmult will have stype==0, contain numerical values and be sorted\n        return ssmult(A, aa1, 0, true, true)\n    end\n\n    ## The A*A' case is handled by cholmod_aat. This routine requires\n    ## A->stype == 0 (storage of upper and lower parts). If necessary\n    ## the matrix A is first converted to stype == 0\n    s = unsafe_load(pointer(A))\n    fset = s.ncol == 0 ? SuiteSparse_long[] : SuiteSparse_long[0:s.ncol-1;]\n    if s.stype != 0\n        aa1 = copy(A, 0, 1)\n        return aat(aa1, fset, 1)\n    else\n        return aat(A, fset, 1)\n    end\nend\n\nfunction *(adjA::Adjoint{<:Any,<:Sparse}, B::Sparse)\n    A = adjA.parent\n    aa1 = transpose_(A, 2)\n    if A === B\n        return *(aa1, adjoint(aa1))\n    end\n    ## result of ssmult will have stype==0, contain numerical values and be sorted\n    return ssmult(aa1, B, 0, true, true)\nend\n\n*(adjA::Adjoint{<:Any,<:Sparse}, B::Dense) =\n    (A = adjA.parent; sdmult!(A, true, 1., 0., B, zeros(size(A, 2), size(B, 2))))\n*(adjA::Adjoint{<:Any,<:Sparse}, B::VecOrMat) =\n    (A = adjA.parent; *(adjoint(A), Dense(B)))\n\n\n## Factorization methods\n\n## Compute that symbolic factorization only\nfunction fact_(A::Sparse{<:VTypes}, cm::Array{UInt8};\n    perm::Union{Nothing,AbstractVector{SuiteSparse_long}}=nothing,\n    postorder::Bool=true, userperm_only::Bool=true)\n\n    sA = unsafe_load(pointer(A))\n    sA.stype == 0 && throw(ArgumentError(\"sparse matrix is not symmetric/Hermitian\"))\n\n    if !postorder\n        unsafe_store!(common_postorder[Threads.threadid()], 0)\n    end\n\n    if perm === nothing || isempty(perm) # TODO: deprecate empty perm\n        F = analyze(A, cm)\n    else # user permutation provided\n        if userperm_only # use perm even if it is worse than AMD\n            unsafe_store!(common_nmethods[Threads.threadid()], 1)\n        end\n        F = analyze_p(A, SuiteSparse_long[p-1 for p in perm], cm)\n    end\n\n    return F\nend\n\nfunction cholesky!(F::Factor{Tv}, A::Sparse{Tv};\n                   shift::Real=0.0, check::Bool = true) where Tv\n    # Makes it an LLt\n    unsafe_store!(common_final_ll[Threads.threadid()], 1)\n\n    # Compute the numerical factorization\n    factorize_p!(A, shift, F, common_struct[Threads.threadid()])\n\n    check && (issuccess(F) || throw(LinearAlgebra.PosDefException(1)))\n    return F\nend\n\n\"\"\"\n    cholesky!(F::CHOLMOD.Factor, A::SparseMatrixCSC; shift = 0.0, check = true) -> CHOLMOD.Factor\n\nCompute the Cholesky (``LL'``) factorization of `A`, reusing the symbolic\nfactorization `F`. `A` must be a [`SparseMatrixCSC`](@ref) or a [`Symmetric`](@ref)/\n[`Hermitian`](@ref) view of a `SparseMatrixCSC`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\n\nSee also [`cholesky`](@ref).\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{ComplexF64}`\n    as appropriate.\n\"\"\"\ncholesky!(F::Factor, A::Union{SparseMatrixCSC{T},\n          SparseMatrixCSC{Complex{T}},\n          Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n          Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n          Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n          shift = 0.0, check::Bool = true) where {T<:Real} =\n    cholesky!(F, Sparse(A); shift = shift, check = check)\n\nfunction cholesky(A::Sparse; shift::Real=0.0, check::Bool = true,\n    perm::Union{Nothing,AbstractVector{SuiteSparse_long}}=nothing)\n\n    cm = defaults(common_struct[Threads.threadid()])\n    set_print_level(cm, 0)\n\n    # Compute the symbolic factorization\n    F = fact_(A, cm; perm = perm)\n\n    # Compute the numerical factorization\n    cholesky!(F, A; shift = shift, check = check)\n\n    return F\nend\n\n\"\"\"\n    cholesky(A::SparseMatrixCSC; shift = 0.0, check = true, perm = nothing) -> CHOLMOD.Factor\n\nCompute the Cholesky factorization of a sparse positive definite matrix `A`.\n`A` must be a [`SparseMatrixCSC`](@ref) or a [`Symmetric`](@ref)/[`Hermitian`](@ref)\nview of a `SparseMatrixCSC`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\nIf `perm` is not given, a fill-reducing permutation is used.\n`F = cholesky(A)` is most frequently used to solve systems of equations with `F\\\\b`,\nbut also the methods [`diag`](@ref), [`det`](@ref), and\n[`logdet`](@ref) are defined for `F`.\nYou can also extract individual factors from `F`, using `F.L`.\nHowever, since pivoting is on by default, the factorization is internally\nrepresented as `A == P'*L*L'*P` with a permutation matrix `P`;\nusing just `L` without accounting for `P` will give incorrect answers.\nTo include the effects of permutation,\nit's typically preferable to extract \"combined\" factors like `PtL = F.PtL`\n(the equivalent of `P'*L`) and `LtP = F.UP` (the equivalent of `L'*P`).\n\nWhen `check = true`, an error is thrown if the decomposition fails.\nWhen `check = false`, responsibility for checking the decomposition's\nvalidity (via [`issuccess`](@ref)) lies with the user.\n\nSetting the optional `shift` keyword argument computes the factorization of\n`A+shift*I` instead of `A`. If the `perm` argument is provided,\nit should be a permutation of `1:size(A,1)` giving the ordering to use\n(instead of CHOLMOD's default AMD ordering).\n\n# Examples\n\nIn the following example, the fill-reducing permutation used is `[3, 2, 1]`.\nIf `perm` is set to `1:3` to enforce no permutation, the number of nonzero\nelements in the factor is 6.\n```jldoctest\njulia> A = [2 1 1; 1 2 0; 1 0 2]\n3\u00d73 Matrix{Int64}:\n 2  1  1\n 1  2  0\n 1  0  2\n\njulia> C = cholesky(sparse(A))\nSuiteSparse.CHOLMOD.Factor{Float64}\ntype:    LLt\nmethod:  simplicial\nmaxnnz:  5\nnnz:     5\nsuccess: true\n\njulia> C.p\n3-element Vector{Int64}:\n 3\n 2\n 1\n\njulia> L = sparse(C.L);\n\njulia> Matrix(L)\n3\u00d73 Matrix{Float64}:\n 1.41421   0.0       0.0\n 0.0       1.41421   0.0\n 0.707107  0.707107  1.0\n\njulia> L * L' \u2248 A[C.p, C.p]\ntrue\n\njulia> P = sparse(1:3, C.p, ones(3))\n3\u00d73 SparseMatrixCSC{Float64, Int64} with 3 stored entries:\n  \u22c5    \u22c5   1.0\n  \u22c5   1.0   \u22c5\n 1.0   \u22c5    \u22c5\n\njulia> P' * L * L' * P \u2248 A\ntrue\n\njulia> C = cholesky(sparse(A), perm=1:3)\nSuiteSparse.CHOLMOD.Factor{Float64}\ntype:    LLt\nmethod:  simplicial\nmaxnnz:  6\nnnz:     6\nsuccess: true\n\njulia> L = sparse(C.L);\n\njulia> Matrix(L)\n3\u00d73 Matrix{Float64}:\n 1.41421    0.0       0.0\n 0.707107   1.22474   0.0\n 0.707107  -0.408248  1.1547\n\njulia> L * L' \u2248 A\ntrue\n```\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{ComplexF64}`\n    as appropriate.\n\n    Many other functions from CHOLMOD are wrapped but not exported from the\n    `Base.SparseArrays.CHOLMOD` module.\n\"\"\"\ncholesky(A::Union{SparseMatrixCSC{T}, SparseMatrixCSC{Complex{T}},\n    Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n    Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n    Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n    kws...) where {T<:Real} = cholesky(Sparse(A); kws...)\n\n\nfunction ldlt!(F::Factor{Tv}, A::Sparse{Tv};\n               shift::Real=0.0, check::Bool = true) where Tv\n    cm = defaults(common_struct[Threads.threadid()])\n    set_print_level(cm, 0)\n\n    # Makes it an LDLt\n    change_factor!(F, false, false, true, false)\n\n    # Compute the numerical factorization\n    factorize_p!(A, shift, F, cm)\n\n    check && (issuccess(F) || throw(LinearAlgebra.ZeroPivotException(1)))\n    return F\nend\n\n\"\"\"\n    ldlt!(F::CHOLMOD.Factor, A::SparseMatrixCSC; shift = 0.0, check = true) -> CHOLMOD.Factor\n\nCompute the ``LDL'`` factorization of `A`, reusing the symbolic factorization `F`.\n`A` must be a [`SparseMatrixCSC`](@ref) or a [`Symmetric`](@ref)/[`Hermitian`](@ref)\nview of a `SparseMatrixCSC`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\n\nSee also [`ldlt`](@ref).\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{ComplexF64}`\n    as appropriate.\n\"\"\"\nldlt!(F::Factor, A::Union{SparseMatrixCSC{T},\n    SparseMatrixCSC{Complex{T}},\n    Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n    Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n    Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n    shift = 0.0, check::Bool = true) where {T<:Real} =\n    ldlt!(F, Sparse(A), shift = shift, check = check)\n\nfunction ldlt(A::Sparse; shift::Real=0.0, check::Bool = true,\n    perm::Union{Nothing,AbstractVector{SuiteSparse_long}}=nothing)\n\n    cm = defaults(common_struct[Threads.threadid()])\n    set_print_level(cm, 0)\n\n    # Makes it an LDLt\n    unsafe_store!(common_final_ll[Threads.threadid()], 0)\n    # Really make sure it's an LDLt by avoiding supernodal factorization\n    unsafe_store!(common_supernodal[Threads.threadid()], 0)\n\n    # Compute the symbolic factorization\n    F = fact_(A, cm; perm = perm)\n\n    # Compute the numerical factorization\n    ldlt!(F, A; shift = shift, check = check)\n\n    return F\nend\n\n\"\"\"\n    ldlt(A::SparseMatrixCSC; shift = 0.0, check = true, perm=nothing) -> CHOLMOD.Factor\n\nCompute the ``LDL'`` factorization of a sparse matrix `A`.\n`A` must be a [`SparseMatrixCSC`](@ref) or a [`Symmetric`](@ref)/[`Hermitian`](@ref)\nview of a `SparseMatrixCSC`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\nA fill-reducing permutation is used. `F = ldlt(A)` is most frequently\nused to solve systems of equations `A*x = b` with `F\\\\b`. The returned\nfactorization object `F` also supports the methods [`diag`](@ref),\n[`det`](@ref), [`logdet`](@ref), and [`inv`](@ref).\nYou can extract individual factors from `F` using `F.L`.\nHowever, since pivoting is on by default, the factorization is internally\nrepresented as `A == P'*L*D*L'*P` with a permutation matrix `P`;\nusing just `L` without accounting for `P` will give incorrect answers.\nTo include the effects of permutation, it is typically preferable to extract\n\"combined\" factors like `PtL = F.PtL` (the equivalent of\n`P'*L`) and `LtP = F.UP` (the equivalent of `L'*P`).\nThe complete list of supported factors is `:L, :PtL, :D, :UP, :U, :LD, :DU, :PtLD, :DUP`.\n\nWhen `check = true`, an error is thrown if the decomposition fails.\nWhen `check = false`, responsibility for checking the decomposition's\nvalidity (via [`issuccess`](@ref)) lies with the user.\n\nSetting the optional `shift` keyword argument computes the factorization of\n`A+shift*I` instead of `A`. If the `perm` argument is provided,\nit should be a permutation of `1:size(A,1)` giving the ordering to use\n(instead of CHOLMOD's default AMD ordering).\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{ComplexF64}`\n    as appropriate.\n\n    Many other functions from CHOLMOD are wrapped but not exported from the\n    `Base.SparseArrays.CHOLMOD` module.\n\"\"\"\nldlt(A::Union{SparseMatrixCSC{T},SparseMatrixCSC{Complex{T}},\n    Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n    Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n    Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n    kws...) where {T<:Real} = ldlt(Sparse(A); kws...)\n\n## Rank updates\n\n\"\"\"\n    lowrankupdowndate!(F::CHOLMOD.Factor, C::Sparse, update::Cint)\n\nUpdate an `LDLt` or `LLt` Factorization `F` of `A` to a factorization of `A \u00b1 C*C'`.\n\nIf sparsity preserving factorization is used, i.e. `L*L' == P*A*P'` then the new\nfactor will be `L*L' == P*A*P' + C'*C`\n\n`update`: `Cint(1)` for `A + CC'`, `Cint(0)` for `A - CC'`\n\"\"\"\nfunction lowrankupdowndate!(F::Factor{Tv}, C::Sparse{Tv}, update::Cint) where Tv<:VTypes\n    lF = unsafe_load(pointer(F))\n    lC = unsafe_load(pointer(C))\n    if lF.n != lC.nrow\n        throw(DimensionMismatch(\"matrix dimensions do not fit\"))\n    end\n    @isok ccall((@cholmod_name(\"updown\"), :libcholmod), Cint,\n        (Cint, Ptr{C_Sparse{Tv}}, Ptr{C_Factor{Tv}}, Ptr{Cvoid}),\n        update, C, F, common_struct[Threads.threadid()])\n    F\nend\n\n#Helper functions for rank updates\nlowrank_reorder(V::AbstractArray,p) = Sparse(sparse(V[p,:]))\nlowrank_reorder(V::AbstractSparseArray,p) = Sparse(V[p,:])\n\n\"\"\"\n    lowrankupdate!(F::CHOLMOD.Factor, C::AbstractArray)\n\nUpdate an `LDLt` or `LLt` Factorization `F` of `A` to a factorization of `A + C*C'`.\n\n`LLt` factorizations are converted to `LDLt`.\n\nSee also [`lowrankupdate`](@ref), [`lowrankdowndate`](@ref), [`lowrankdowndate!`](@ref).\n\"\"\"\nfunction lowrankupdate!(F::Factor{Tv}, V::AbstractArray{Tv}) where Tv<:VTypes\n    #Reorder and copy V to account for permutation\n    C = lowrank_reorder(V, get_perm(F))\n    lowrankupdowndate!(F, C, Cint(1))\nend\n\n\"\"\"\n    lowrankdowndate!(F::CHOLMOD.Factor, C::AbstractArray)\n\nUpdate an `LDLt` or `LLt` Factorization `F` of `A` to a factorization of `A - C*C'`.\n\n`LLt` factorizations are converted to `LDLt`.\n\nSee also [`lowrankdowndate`](@ref), [`lowrankupdate`](@ref), [`lowrankupdate!`](@ref).\n\"\"\"\nfunction lowrankdowndate!(F::Factor{Tv}, V::AbstractArray{Tv}) where Tv<:VTypes\n    #Reorder and copy V to account for permutation\n    C = lowrank_reorder(V, get_perm(F))\n    lowrankupdowndate!(F, C, Cint(0))\nend\n\n\"\"\"\n    lowrankupdate(F::CHOLMOD.Factor, C::AbstractArray) -> FF::CHOLMOD.Factor\n\nGet an `LDLt` Factorization of `A + C*C'` given an `LDLt` or `LLt` factorization `F` of `A`.\n\nThe returned factor is always an `LDLt` factorization.\n\nSee also [`lowrankupdate!`](@ref), [`lowrankdowndate`](@ref), [`lowrankdowndate!`](@ref).\n\"\"\"\nlowrankupdate(F::Factor{Tv}, V::AbstractArray{Tv}) where {Tv<:VTypes} =\n    lowrankupdate!(copy(F), V)\n\n\"\"\"\n    lowrankupdate(F::CHOLMOD.Factor, C::AbstractArray) -> FF::CHOLMOD.Factor\n\nGet an `LDLt` Factorization of `A + C*C'` given an `LDLt` or `LLt` factorization `F` of `A`.\n\nThe returned factor is always an `LDLt` factorization.\n\nSee also [`lowrankdowndate!`](@ref), [`lowrankupdate`](@ref), [`lowrankupdate!`](@ref).\n\"\"\"\nlowrankdowndate(F::Factor{Tv}, V::AbstractArray{Tv}) where {Tv<:VTypes} =\n    lowrankdowndate!(copy(F), V)\n\n## Solvers\n\nfor (T, f) in ((:Dense, :solve), (:Sparse, :spsolve))\n    @eval begin\n        # Solve Lx = b and L'x=b where A = L*L'\n        function (\\)(L::FactorComponent{T,:L}, B::$T) where T\n            ($f)(CHOLMOD_L, Factor(L), B)\n        end\n        function (\\)(L::FactorComponent{T,:U}, B::$T) where T\n            ($f)(CHOLMOD_Lt, Factor(L), B)\n        end\n        # Solve PLx = b and L'P'x=b where A = P*L*L'*P'\n        function (\\)(L::FactorComponent{T,:PtL}, B::$T) where T\n            F = Factor(L)\n            ($f)(CHOLMOD_L, F, ($f)(CHOLMOD_P, F, B)) # Confusingly, CHOLMOD_P solves P'x = b\n        end\n        function (\\)(L::FactorComponent{T,:UP}, B::$T) where T\n            F = Factor(L)\n            ($f)(CHOLMOD_Pt, F, ($f)(CHOLMOD_Lt, F, B))\n        end\n        # Solve various equations for A = L*D*L' and A = P*L*D*L'*P'\n        function (\\)(L::FactorComponent{T,:D}, B::$T) where T\n            ($f)(CHOLMOD_D, Factor(L), B)\n        end\n        function (\\)(L::FactorComponent{T,:LD}, B::$T) where T\n            ($f)(CHOLMOD_LD, Factor(L), B)\n        end\n        function (\\)(L::FactorComponent{T,:DU}, B::$T) where T\n            ($f)(CHOLMOD_DLt, Factor(L), B)\n        end\n        function (\\)(L::FactorComponent{T,:PtLD}, B::$T) where T\n            F = Factor(L)\n            ($f)(CHOLMOD_LD, F, ($f)(CHOLMOD_P, F, B))\n        end\n        function (\\)(L::FactorComponent{T,:DUP}, B::$T) where T\n            F = Factor(L)\n            ($f)(CHOLMOD_Pt, F, ($f)(CHOLMOD_DLt, F, B))\n        end\n    end\nend\n\nSparseVecOrMat{Tv,Ti} = Union{SparseVector{Tv,Ti}, SparseMatrixCSC{Tv,Ti}}\n\nfunction (\\)(L::FactorComponent, b::Vector)\n    reshape(Matrix(L\\Dense(b)), length(b))\nend\nfunction (\\)(L::FactorComponent, B::Matrix)\n    Matrix(L\\Dense(B))\nend\nfunction (\\)(L::FactorComponent, B::SparseVecOrMat)\n    sparse(L\\Sparse(B,0))\nend\n(\\)(L::FactorComponent, B::Adjoint{<:Any,<:SparseMatrixCSC}) = L \\ copy(B)\n(\\)(L::FactorComponent, B::Transpose{<:Any,<:SparseMatrixCSC}) = L \\ copy(B)\n\n\\(adjL::Adjoint{<:Any,<:FactorComponent}, B::Union{VecOrMat,SparseVecOrMat}) = (L = adjL.parent; adjoint(L)\\B)\n\n(\\)(L::Factor{T}, B::Dense{T}) where {T<:VTypes} = solve(CHOLMOD_A, L, B)\n# Explicit typevars are necessary to avoid ambiguities with defs in linalg/factorizations.jl\n# Likewise the two following explicit Vector and Matrix defs (rather than a single VecOrMat)\n(\\)(L::Factor{T}, B::Vector{Complex{T}}) where {T<:Float64} = complex.(L\\real(B), L\\imag(B))\n(\\)(L::Factor{T}, B::Matrix{Complex{T}}) where {T<:Float64} = complex.(L\\real(B), L\\imag(B))\n(\\)(L::Factor{T}, B::Adjoint{<:Any, <:Matrix{Complex{T}}}) where {T<:Float64} = complex.(L\\real(B), L\\imag(B))\n(\\)(L::Factor{T}, B::Transpose{<:Any, <:Matrix{Complex{T}}}) where {T<:Float64} = complex.(L\\real(B), L\\imag(B))\n\n(\\)(L::Factor{T}, b::StridedVector) where {T<:VTypes} = Vector(L\\Dense{T}(b))\n(\\)(L::Factor{T}, B::StridedMatrix) where {T<:VTypes} = Matrix(L\\Dense{T}(B))\n(\\)(L::Factor{T}, B::Adjoint{<:Any, <:StridedMatrix}) where {T<:VTypes} = Matrix(L\\Dense{T}(B))\n(\\)(L::Factor{T}, B::Transpose{<:Any, <:StridedMatrix}) where {T<:VTypes} = Matrix(L\\Dense{T}(B))\n\n(\\)(L::Factor, B::Sparse) = spsolve(CHOLMOD_A, L, B)\n# When right hand side is sparse, we have to ensure that the rhs is not marked as symmetric.\n(\\)(L::Factor, B::SparseMatrixCSC) = sparse(spsolve(CHOLMOD_A, L, Sparse(B, 0)))\n(\\)(L::Factor, B::Adjoint{<:Any,<:SparseMatrixCSC}) = L \\ copy(B)\n(\\)(L::Factor, B::Transpose{<:Any,<:SparseMatrixCSC}) = L \\ copy(B)\n(\\)(L::Factor, B::SparseVector) = sparse(spsolve(CHOLMOD_A, L, Sparse(B)))\n\n\\(adjL::Adjoint{<:Any,<:Factor}, B::Dense) = (L = adjL.parent; solve(CHOLMOD_A, L, B))\n\\(adjL::Adjoint{<:Any,<:Factor}, B::Sparse) = (L = adjL.parent; spsolve(CHOLMOD_A, L, B))\n\\(adjL::Adjoint{<:Any,<:Factor}, B::SparseVecOrMat) = (L = adjL.parent; \\(adjoint(L), Sparse(B)))\n\nfunction \\(adjL::Adjoint{<:Any,<:Factor}, b::StridedVector)\n    L = adjL.parent\n    return Vector(solve(CHOLMOD_A, L, Dense(b)))\nend\nfunction \\(adjL::Adjoint{<:Any,<:Factor}, B::StridedMatrix)\n    L = adjL.parent\n    return Matrix(solve(CHOLMOD_A, L, Dense(B)))\nend\n\nconst RealHermSymComplexHermF64SSL = Union{\n    Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}},\n    Hermitian{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}},\n    Hermitian{ComplexF64,SparseMatrixCSC{ComplexF64,SuiteSparse_long}}}\nconst StridedVecOrMatInclAdjAndTrans = Union{StridedVecOrMat, Adjoint{<:Any, <:StridedVecOrMat}, Transpose{<:Any, <:StridedVecOrMat}}\nfunction \\(A::RealHermSymComplexHermF64SSL, B::StridedVecOrMatInclAdjAndTrans)\n    F = cholesky(A; check = false)\n    if issuccess(F)\n        return \\(F, B)\n    else\n        ldlt!(F, A; check = false)\n        if issuccess(F)\n            return \\(F, B)\n        else\n            return \\(lu(SparseMatrixCSC{eltype(A), SuiteSparse_long}(A)), B)\n        end\n    end\nend\nfunction \\(adjA::Adjoint{<:Any,<:RealHermSymComplexHermF64SSL}, B::StridedVecOrMatInclAdjAndTrans)\n    A = adjA.parent\n    F = cholesky(A; check = false)\n    if issuccess(F)\n        return \\(adjoint(F), B)\n    else\n        ldlt!(F, A; check = false)\n        if issuccess(F)\n            return \\(adjoint(F), B)\n        else\n            return \\(adjoint(lu(SparseMatrixCSC{eltype(A), SuiteSparse_long}(A))), B)\n        end\n    end\nend\n\n## Other convenience methods\nfunction diag(F::Factor{Tv}) where Tv\n    f = unsafe_load(pointer(F))\n    fsuper = f.super\n    fpi = f.pi\n    res = Base.zeros(Tv, Int(f.n))\n    xv  = f.x\n    if f.is_super!=0\n        px = f.px\n        pos = 1\n        for i in 1:f.nsuper\n            base = unsafe_load(px, i) + 1\n            res[pos] = unsafe_load(xv, base)\n            pos += 1\n            for j in 1:unsafe_load(fsuper, i + 1) - unsafe_load(fsuper, i) - 1\n                res[pos] = unsafe_load(xv, base + j*(unsafe_load(fpi, i + 1) -\n                    unsafe_load(fpi, i) + 1))\n                pos += 1\n            end\n        end\n    else\n        c0 = f.p\n        r0 = f.i\n        xv = f.x\n        for j in 1:f.n\n            jj = unsafe_load(c0, j) + 1\n            @assert(unsafe_load(r0, jj) == j - 1)\n            res[j] = unsafe_load(xv, jj)\n        end\n    end\n    res\nend\n\nfunction logdet(F::Factor{Tv}) where Tv<:VTypes\n    f = unsafe_load(pointer(F))\n    res = zero(Tv)\n    for d in diag(F); res += log(abs(d)) end\n    f.is_ll != 0 ? 2res : res\nend\n\ndet(L::Factor) = exp(logdet(L))\n\nfunction issuccess(F::Factor)\n    s = unsafe_load(pointer(F))\n    return s.minor == size(F, 1)\nend\n\nfunction isposdef(F::Factor)\n    if issuccess(F)\n        s = unsafe_load(pointer(F))\n        if s.is_ll == 1\n            return true\n        else\n            # try conversion to LLt\n            change_factor!(F, true, s.is_super, true, s.is_monotonic)\n            b = issuccess(F)\n            # convert back\n            change_factor!(F, false, s.is_super, true, s.is_monotonic)\n            return b\n        end\n    else\n        return false\n    end\nend\n\nfunction ishermitian(A::Sparse{Float64})\n    s = unsafe_load(pointer(A))\n    if s.stype != 0\n        return true\n    else\n        i = symmetry(A, 1)[1]\n        if i < 0\n            throw(CHOLMODException(\"negative value returned from CHOLMOD's symmetry function. This\n                is either because the indices are not sorted or because of a memory error\"))\n        end\n        return i == MM_SYMMETRIC || i == MM_SYMMETRIC_POSDIAG\n    end\nend\nfunction ishermitian(A::Sparse{ComplexF64})\n    s = unsafe_load(pointer(A))\n    if s.stype != 0\n        return true\n    else\n        i = symmetry(A, 1)[1]\n        if i < 0\n            throw(CHOLMODException(\"negative value returned from CHOLMOD's symmetry function. This\n                is either because the indices are not sorted or because of a memory error\"))\n        end\n        return i == MM_HERMITIAN || i == MM_HERMITIAN_POSDIAG\n    end\nend\n\n(*)(A::Symmetric{Float64,SparseMatrixCSC{Float64,Ti}},\n    B::SparseVecOrMat{Float64,Ti}) where {Ti} = sparse(Sparse(A)*Sparse(B))\n(*)(A::Hermitian{ComplexF64,SparseMatrixCSC{ComplexF64,Ti}},\n    B::SparseVecOrMat{ComplexF64,Ti}) where {Ti} = sparse(Sparse(A)*Sparse(B))\n(*)(A::Hermitian{Float64,SparseMatrixCSC{Float64,Ti}},\n    B::SparseVecOrMat{Float64,Ti}) where {Ti} = sparse(Sparse(A)*Sparse(B))\n\n(*)(A::SparseVecOrMat{Float64,Ti},\n    B::Symmetric{Float64,SparseMatrixCSC{Float64,Ti}}) where {Ti} = sparse(Sparse(A)*Sparse(B))\n(*)(A::SparseVecOrMat{ComplexF64,Ti},\n    B::Hermitian{ComplexF64,SparseMatrixCSC{ComplexF64,Ti}}) where {Ti} = sparse(Sparse(A)*Sparse(B))\n(*)(A::SparseVecOrMat{Float64,Ti},\n    B::Hermitian{Float64,SparseMatrixCSC{Float64,Ti}}) where {Ti} = sparse(Sparse(A)*Sparse(B))\n\nend #module\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/LibUnwind_jll/test/runtests.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nusing Test, Libdl, LibUnwind_jll\n\n@testset \"LibUnwind_jll\" begin\n    if !Sys.isapple() && !Sys.iswindows()\n        @test dlsym(LibUnwind_jll.libunwind_handle, :unw_backtrace; throw_error=false) !== nothing\n    end\nend\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/stdlib/libLLVM_jll/test/runtests.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nusing Test, Libdl, libLLVM_jll\n\n@testset \"libLLVM_jll\" begin\n    @test dlsym(libLLVM_jll.libLLVM_handle, :LLVMInitializeTarget; throw_error=false) !== nothing\nend\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/test/ccall.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nimport Base.copy, Base.==\nusing Random\nusing InteractiveUtils: code_llvm\n\nimport Libdl\n\n# for cfunction_closure\ninclude(\"testenv.jl\")\n# for cfunction error\nisdefined(Main, :MacroCalls) || @eval Main include(\"testhelpers/MacroCalls.jl\")\nusing Main.MacroCalls\n\nconst libccalltest = \"libccalltest\"\n\nconst verbose = false\nccall((:set_verbose, libccalltest), Cvoid, (Int32,), verbose)\n\n@eval function cvarargs()\n    strp = Ref{Ptr{Cchar}}(0)\n    fmt = \"%3.1f\"\n    len = ccall(:asprintf, Cint, (Ptr{Ptr{Cchar}}, Cstring, Cfloat...), strp, fmt, 0.1)\n    str = unsafe_string(strp[], len)\n    Libc.free(strp[])\n    return str\nend\n@test cvarargs() == \"0.1\"\n\n\n# test multiple-type vararg handling (there's no syntax for this currently)\n@eval function foreign_varargs()\n    strp = Ref{Ptr{Cchar}}(0)\n    fmt = \"hi+%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%.1f-%.1f-%.1f-%.1f-%.1f-%.1f-%.1f-%.1f-%.1f\\n\"\n    len = $(Expr(:foreigncall, :(:asprintf), Cint,\n        Core.svec(Ptr{Ptr{Cchar}}, Cstring,\n            UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8,\n            Cfloat, Cfloat, Cfloat, Cfloat, Cfloat, Cfloat, Cfloat, Cfloat, Cfloat),\n            2, :(:cdecl),\n            :(Base.unsafe_convert(Ptr{Ptr{Cchar}}, strp)), :(Base.unsafe_convert(Cstring, fmt)),\n            0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,\n            Cfloat(1.1), Cfloat(2.2), Cfloat(3.3), Cfloat(4.4), Cfloat(5.5), Cfloat(6.6), Cfloat(7.7), Cfloat(8.8), Cfloat(9.9),\n            :strp, :fmt))\n    str = unsafe_string(strp[], len)\n    Libc.free(strp[])\n    return str\nend\n@test foreign_varargs() == \"hi+1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-1.1-2.2-3.3-4.4-5.5-6.6-7.7-8.8-9.9\\n\"\n\n\n# Test for proper argument register truncation\nccall_test_func(x) = ccall((:testUcharX, libccalltest), Int32, (UInt8,), x % UInt8)\n@test ccall_test_func(3) == 1\n@test ccall_test_func(259) == 1\n\n\n# Test for proper round-trip of Ref{T} type\nfunction gen_ccall_echo(x, T, U, ret=nothing)\n    # Construct a noninline function to do all the work, this is necessary\n    # to make sure object x is still valid (rooted as argument)\n    # when loading the pointer.\n    # This works as long as we still keep the argument\n    # rooted but might fail if we are smarter about eliminating dead root.\n\n    # `eval` in global scope to make sure the function is not a closure\n    func_ex = :(ccall((:test_echo_p, libccalltest), $T, ($U,), x))\n    # It is not allowed to allocate after the ccall returns\n    # and before calling `ret`.\n    if ret !== nothing\n        func_ex = :($ret($func_ex))\n    end\n    @gensym func_name\n    @eval @noinline $func_name(x) = $func_ex\n    :($func_name($(esc(x))))\nend\n\nmacro ccall_echo_func(x, T, U)\n    gen_ccall_echo(x, T, U)\nend\nmacro ccall_echo_load(x, T, U)\n    gen_ccall_echo(x, T, U, :unsafe_load)\nend\nmacro ccall_echo_objref(x, T, U)\n    gen_ccall_echo(x, :(Ptr{$T}), U, :unsafe_pointer_to_objref)\nend\n\nmutable struct IntLike\n    x::Int\nend\n@test @ccall_echo_load(132, Ptr{Int}, Ref{Int}) === 132\n@test @ccall_echo_load(Ref(921), Ptr{Int}, Ref{Int}) === 921\n@test @ccall_echo_load(IntLike(993), Ptr{Int}, Ref{IntLike}) === 993\n@test @ccall_echo_load(IntLike(881), Ptr{IntLike}, Ref{IntLike}).x === 881\n@test @ccall_echo_func(532, Int, Int) === 532\nif Sys.WORD_SIZE == 64\n    # this test is valid only for x86_64 and win64\n    @test @ccall_echo_func(164, IntLike, Int).x === 164\nend\n@test @ccall_echo_func(IntLike(828), Int, IntLike) === 828\n@test @ccall_echo_func(913, Any, Any) === 913\n@test @ccall_echo_objref(553, Ptr{Any}, Any) === 553\n@test @ccall_echo_func(124, Ref{Int}, Any) === 124\n@test @ccall_echo_load(422, Ptr{Any}, Ref{Any}) === 422\n@test @ccall_echo_load([383], Ptr{Int}, Ref{Int}) === 383\n@test @ccall_echo_load(Ref([144,172],2), Ptr{Int}, Ref{Int}) === 172\n# @test @ccall_echo_load(Ref([8],1,1), Ptr{Int}, Ref{Int}) === 8\n\n\n## Tests for passing and returning structs\n\nlet a, ci_ary, x\n    a = 20 + 51im\n\n    x = ccall((:ctest, libccalltest), Complex{Int}, (Complex{Int},), a)\n\n    @test x == a + 1 - 2im\n\n    ci_ary = [a] # Make sure the array is alive during unsafe_load\n    x = unsafe_load(ccall((:cptest, libccalltest), Ptr{Complex{Int}},\n                          (Ptr{Complex{Int}},), ci_ary))\n\n    @test x == a + 1 - 2im\n    @test a == 20 + 51im\n\n    x = ccall((:cptest_static, libccalltest), Ptr{Complex{Int}}, (Ref{Complex{Int}},), a)\n    @test unsafe_load(x) == a\n    Libc.free(convert(Ptr{Cvoid}, x))\nend\n\nlet a, b, x\n    a = 2.84 + 5.2im\n\n    x = ccall((:cgtest, libccalltest), ComplexF64, (ComplexF64,), a)\n\n    @test x == a + 1 - 2im\n\n    b = [a] # Make sure the array is alive during unsafe_load\n    x = unsafe_load(ccall((:cgptest, libccalltest), Ptr{ComplexF64}, (Ptr{ComplexF64},), b))\n\n    @test x == a + 1 - 2im\n    @test a == 2.84 + 5.2im\nend\n\nlet a, b, x\n    a = 3.34f0 + 53.2f0im\n\n    x = ccall((:cftest, libccalltest), ComplexF32, (ComplexF32,), a)\n\n    @test x == a + 1 - 2im\n\n    b = [a] # Make sure the array is alive during unsafe_load\n    x = unsafe_load(ccall((:cfptest, libccalltest), Ptr{ComplexF32}, (Ptr{ComplexF32},), b))\n\n    @test x == a + 1 - 2im\n    @test a == 3.34f0 + 53.2f0im\nend\n\n\n## Tests for native Julia data types\n\nlet a\n    a = 2.84 + 5.2im\n\n    @test_throws MethodError ccall((:cptest, libccalltest), Ptr{Complex{Int}}, (Ptr{Complex{Int}},), a)\nend\n\n\n## Tests for various sized data types (ByVal)\n\nmutable struct Struct1\n    x::Float32\n    y::Float64\nend\nstruct Struct1I\n    x::Float32\n    y::Float64\nend\ncopy(a::Struct1) = Struct1(a.x, a.y)\ncopy(a::Struct1I) = a\n\nfunction test_struct1(::Type{Struct}) where {Struct}\n    a = Struct(352.39422f23, 19.287577)\n    b = Float32(123.456)\n\n    a2 = copy(a)\n    if Struct === Struct1\n        x = ccall((:test_1, libccalltest), Struct1, (Struct1, Float32), a2, b)\n    else\n        x = ccall((:test_1, libccalltest), Struct1I, (Struct1I, Float32), a2, b)\n    end\n\n    @test a2.x == a.x && a2.y == a.y\n    @test !(a2 === x)\n\n    @test x.x \u2248 a.x + 1*b\n    @test x.y \u2248 a.y - 2*b\nend\ntest_struct1(Struct1)\ntest_struct1(Struct1I)\n\nlet a, b, x\n    a = Struct1(352.39422f23, 19.287577)\n    b = Float32(123.456)\n    a2 = copy(a)\n\n    x = ccall((:test_1long_a, libccalltest), Struct1, (Int, Int, Int, Struct1, Float32), 2, 3, 4, a2, b)\n    @test a2.x == a.x && a2.y == a.y\n    @test !(a2 === x)\n    @test x.x \u2248 a.x + b + 9\n    @test x.y \u2248 a.y - 2*b\n\n    x = ccall((:test_1long_b, libccalltest), Struct1, (Int, Float64, Int, Struct1, Float32), 2, 3, 4, a2, b)\n    @test a2.x == a.x && a2.y == a.y\n    @test !(a2 === x)\n    @test x.x \u2248 a.x + b + 9\n    @test x.y \u2248 a.y - 2*b\n\n    x = ccall((:test_1long_c, libccalltest), Struct1, (Int, Float64, Int, Int, Struct1, Float32), 2, 3, 4, 5, a2, b)\n    @test a2.x == a.x && a2.y == a.y\n    @test !(a2 === x)\n    @test x.x \u2248 a.x + b + 14\n    @test x.y \u2248 a.y - 2*b\nend\n\nlet a, b, x, y\n    a = Complex{Int32}(Int32(10),Int32(31))\n    b = Int32(42)\n\n    x = ccall((:test_2a, libccalltest), Complex{Int32}, (Complex{Int32}, Int32), a, b)\n    y = ccall((:test_2b, libccalltest), Complex{Int32}, (Complex{Int32},Int32), a, b)\n\n    @test a == Complex{Int32}(Int32(10),Int32(31))\n\n    @test x == y\n    @test x == a + b*1 - b*2im\nend\n\nlet a, b, x, y, z\n    a = Complex{Int64}(Int64(20),Int64(51))\n    b = Int64(42)\n\n    x = ccall((:test_3a, libccalltest), Complex{Int64}, (Complex{Int64}, Int64), a, b)\n    y = ccall((:test_3b, libccalltest), Complex{Int64}, (Complex{Int64}, Int64), a, b)\n    z = ccall((:test_128, libccalltest), Complex{Int64}, (Complex{Int64}, Int64), a, b)\n\n    @test a == Complex{Int64}(Int64(20),Int64(51))\n\n    @test x == y\n    @test x == a + b*1 - b*2im\n\n    @test z == a + 1*b\nend\n\nmutable struct Struct4\n    x::Int32\n    y::Int32\n    z::Int32\nend\nstruct Struct4I\n    x::Int32\n    y::Int32\n    z::Int32\nend\n\nfunction test_struct4(::Type{Struct}) where {Struct}\n    a = Struct(-512275808,882558299,-2133022131)\n    b = Int32(42)\n\n    if Struct === Struct4\n        x = ccall((:test_4, libccalltest), Struct4, (Struct4, Int32), a, b)\n    else\n        x = ccall((:test_4, libccalltest), Struct4I, (Struct4I, Int32), a, b)\n    end\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\nend\ntest_struct4(Struct4)\ntest_struct4(Struct4I)\n\nmutable struct Struct5\n    x::Int32\n    y::Int32\n    z::Int32\n    a::Int32\nend\nstruct Struct5I\n    x::Int32\n    y::Int32\n    z::Int32\n    a::Int32\nend\n\nfunction test_struct5(::Type{Struct}) where {Struct}\n    a = Struct(1771319039, 406394736, -1269509787, -745020976)\n    b = Int32(42)\n\n    if Struct === Struct5\n        x = ccall((:test_5, libccalltest), Struct5, (Struct5, Int32), a, b)\n    else\n        x = ccall((:test_5, libccalltest), Struct5I, (Struct5I, Int32), a, b)\n    end\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\n    @test x.a == a.a-b*4\nend\ntest_struct5(Struct5)\ntest_struct5(Struct5I)\n\nmutable struct Struct6\n    x::Int64\n    y::Int64\n    z::Int64\nend\nstruct Struct6I\n    x::Int64\n    y::Int64\n    z::Int64\nend\n\nfunction test_struct6(::Type{Struct}) where {Struct}\n    a = Struct(-654017936452753226, -5573248801240918230, -983717165097205098)\n    b = Int64(42)\n\n    if Struct === Struct6\n        x = ccall((:test_6, libccalltest), Struct6, (Struct6, Int64), a, b)\n    else\n        x = ccall((:test_6, libccalltest), Struct6I, (Struct6I, Int64), a, b)\n    end\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\nend\ntest_struct6(Struct6)\ntest_struct6(Struct6I)\n\nmutable struct Struct7\n    x::Int64\n    y::Cchar\nend\nstruct Struct7I\n    x::Int64\n    y::Cchar\nend\n\nfunction test_struct7(::Type{Struct}) where {Struct}\n    a = Struct(-384082741977533896, 'h')\n    b = Int8(42)\n\n    if Struct === Struct7\n        x = ccall((:test_7, libccalltest), Struct7, (Struct7, Int8), a, b)\n    else\n        x = ccall((:test_7, libccalltest), Struct7I, (Struct7I, Int8), a, b)\n    end\n\n    @test x.x == a.x+Int(b)*1\n    @test x.y == a.y-Int(b)*2\nend\ntest_struct7(Struct7)\ntest_struct7(Struct7I)\n\nmutable struct Struct8\n    x::Int32\n    y::Cchar\nend\nstruct Struct8I\n    x::Int32\n    y::Cchar\nend\n\nfunction test_struct8(::Type{Struct}) where {Struct}\n    a = Struct(-384082896, 'h')\n    b = Int8(42)\n\n    if Struct === Struct8\n        r8 = ccall((:test_8, libccalltest), Struct8, (Struct8, Int8), a, b)\n    else\n        r8 = ccall((:test_8, libccalltest), Struct8I, (Struct8I, Int8), a, b)\n    end\n\n    @test r8.x == a.x+b*1\n    @test r8.y == a.y-b*2\nend\ntest_struct8(Struct8)\ntest_struct8(Struct8I)\n\nmutable struct Struct9\n    x::Int32\n    y::Int16\nend\nstruct Struct9I\n    x::Int32\n    y::Int16\nend\n\nfunction test_struct9(::Type{Struct}) where {Struct}\n    a = Struct(-394092996, -3840)\n    b = Int16(42)\n\n    if Struct === Struct9\n        x = ccall((:test_9, libccalltest), Struct9, (Struct9, Int16), a, b)\n    else\n        x = ccall((:test_9, libccalltest), Struct9I, (Struct9I, Int16), a, b)\n    end\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\nend\ntest_struct9(Struct9)\ntest_struct9(Struct9I)\n\nmutable struct Struct10\n    x::Cchar\n    y::Cchar\n    z::Cchar\n    a::Cchar\nend\nstruct Struct10I\n    x::Cchar\n    y::Cchar\n    z::Cchar\n    a::Cchar\nend\n\nfunction test_struct10(::Type{Struct}) where {Struct}\n    a = Struct('0', '1', '2', '3')\n    b = Int8(2)\n\n    if Struct === Struct10\n        x = ccall((:test_10, libccalltest), Struct10, (Struct10, Int8), a, b)\n    else\n        x = ccall((:test_10, libccalltest), Struct10I, (Struct10I, Int8), a, b)\n    end\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\n    @test x.a == a.a-b*4\nend\ntest_struct10(Struct10)\ntest_struct10(Struct10I)\n\nmutable struct Struct11\n    x::ComplexF32\nend\nstruct Struct11I\n    x::ComplexF32\nend\n\nfunction test_struct11(::Type{Struct}) where {Struct}\n    a = Struct(0.8877077f0 + 0.4591081f0im)\n    b = Float32(42)\n\n    if Struct === Struct11\n        x = ccall((:test_11, libccalltest), Struct11, (Struct11, Float32), a, b)\n    else\n        x = ccall((:test_11, libccalltest), Struct11I, (Struct11I, Float32), a, b)\n    end\n\n    @test x.x \u2248 a.x + b*1 - b*2im\nend\ntest_struct11(Struct11)\ntest_struct11(Struct11I)\n\nmutable struct Struct12\n    x::ComplexF32\n    y::ComplexF32\nend\nstruct Struct12I\n    x::ComplexF32\n    y::ComplexF32\nend\n\nfunction test_struct12(::Type{Struct}) where {Struct}\n    a = Struct(0.8877077f5 + 0.4591081f2im, 0.0004842868f0 - 6982.3265f3im)\n    b = Float32(42)\n\n    if Struct === Struct12\n        x = ccall((:test_12, libccalltest), Struct12, (Struct12, Float32), a, b)\n    else\n        x = ccall((:test_12, libccalltest), Struct12I, (Struct12I, Float32), a, b)\n    end\n\n    @test x.x \u2248 a.x + b*1 - b*2im\n    @test x.y \u2248 a.y + b*3 - b*4im\nend\ntest_struct12(Struct12)\ntest_struct12(Struct12I)\n\nmutable struct Struct13\n    x::ComplexF64\nend\nstruct Struct13I\n    x::ComplexF64\nend\n\nfunction test_struct13(::Type{Struct}) where {Struct}\n    a = Struct(42968.97560380495 - 803.0576845153616im)\n    b = Float64(42)\n\n    if Struct === Struct13\n        x = ccall((:test_13, libccalltest), Struct13, (Struct13, Float64), a, b)\n    else\n        x = ccall((:test_13, libccalltest), Struct13I, (Struct13I, Float64), a, b)\n    end\n\n    @test x.x \u2248 a.x + b*1 - b*2im\nend\ntest_struct13(Struct13)\ntest_struct13(Struct13I)\n\nmutable struct Struct14\n    x::Float32\n    y::Float32\nend\nstruct Struct14I\n    x::Float32\n    y::Float32\nend\n\nfunction test_struct14(::Type{Struct}) where {Struct}\n    a = Struct(0.024138331f0, 0.89759064f32)\n    b = Float32(42)\n\n    if Struct === Struct14\n        x = ccall((:test_14, libccalltest), Struct14, (Struct14, Float32), a, b)\n    else\n        x = ccall((:test_14, libccalltest), Struct14I, (Struct14I, Float32), a, b)\n    end\n\n    @test x.x \u2248 a.x + b*1\n    @test x.y \u2248 a.y - b*2\nend\ntest_struct14(Struct14)\ntest_struct14(Struct14I)\n\nmutable struct Struct15\n    x::Float64\n    y::Float64\nend\nstruct Struct15I\n    x::Float64\n    y::Float64\nend\n\nfunction test_struct15(::Type{Struct}) where {Struct}\n    a = Struct(4.180997967273657, -0.404218594294923)\n    b = Float64(42)\n\n    if Struct === Struct15\n        x = ccall((:test_15, libccalltest), Struct15, (Struct15, Float64), a, b)\n    else\n        x = ccall((:test_15, libccalltest), Struct15I, (Struct15I, Float64), a, b)\n    end\n\n    @test x.x \u2248 a.x + b*1\n    @test x.y \u2248 a.y - b*2\nend\ntest_struct15(Struct15)\ntest_struct15(Struct15I)\n\nmutable struct Struct16\n    x::Float32\n    y::Float32\n    z::Float32\n    a::Float64\n    b::Float64\n    c::Float64\nend\nstruct Struct16I\n    x::Float32\n    y::Float32\n    z::Float32\n    a::Float64\n    b::Float64\n    c::Float64\nend\n\nfunction test_struct16(::Type{Struct}, quoteplz = false) where {Struct}\n    a = Struct(0.1604656f0, 0.6297606f0, 0.83588994f0,\n               0.6460273620993535, 0.9472692581106656, 0.47328535437352093)\n    b = Float32(42)\n\n    if Struct === Struct16\n        x = ccall((:test_16, libccalltest), Struct16, (Struct16, Float32), a, b)\n    else\n        if quoteplz\n          x = eval(:(ccall((:test_16, libccalltest), Struct16I, (Struct16I, Float32), $(QuoteNode(a)), Float32(42))))\n        else\n          x = ccall((:test_16, libccalltest), Struct16I, (Struct16I, Float32), a, b)\n        end\n    end\n\n    @test x.x \u2248 a.x + b*1\n    @test x.y \u2248 a.y - b*2\n    @test x.z \u2248 a.z + b*3\n    @test x.a \u2248 a.a - b*4\n    @test x.b \u2248 a.b + b*5\n    @test x.c \u2248 a.c - b*6\nend\n\ntest_struct16(Struct16, false)\ntest_struct16(Struct16I, false)\ntest_struct16(Struct16I, true)\n\nmutable struct Struct17\n    a::Int8\n    b::Int16\nend\nstruct Struct17I\n    a::Int8\n    b::Int16\nend\n\nfunction test_struct17(::Type{Struct}) where {Struct}\n    a = Struct(2, 10)\n    b = Int8(2)\n\n    if Struct === Struct17\n        x = ccall((:test_17, libccalltest), Struct17, (Struct17, Int8), a, b)\n    else\n        x = ccall((:test_17, libccalltest), Struct17I, (Struct17I, Int8), a, b)\n    end\n\n    @test x.a == a.a + b * 1\n    @test x.b == a.b - b * 2\nend\ntest_struct17(Struct17)\ntest_struct17(Struct17I)\n\nmutable struct Struct18\n    a::Int8\n    b::Int8\n    c::Int8\nend\nstruct Struct18I\n    a::Int8\n    b::Int8\n    c::Int8\nend\n\nfunction test_struct18(::Type{Struct}) where {Struct}\n    a = Struct(2, 10, -3)\n    b = Int8(2)\n\n    if Struct === Struct18\n        x = ccall((:test_18, libccalltest), Struct18, (Struct18, Int8), a, b)\n    else\n        x = ccall((:test_18, libccalltest), Struct18I, (Struct18I, Int8), a, b)\n    end\n\n    @test x.a == a.a + b * 1\n    @test x.b == a.b - b * 2\n    @test x.c == a.c + b * 3\nend\ntest_struct18(Struct18)\ntest_struct18(Struct18I)\n\nlet a, b, x\n    a = Int128(0x7f00123456789abc)<<64 + typemax(UInt64)\n    b = Int64(1)\n\n    x = ccall((:test_128, libccalltest), Int128, (Int128, Int64), a, b)\n\n    @test x == a + b*1\n    @test a == Int128(0x7f00123456789abc)<<64 + typemax(UInt64)\nend\n\nmutable struct Struct_Big\n    x::Int\n    y::Int\n    z::Int8\nend\nstruct Struct_BigI\n    x::Int\n    y::Int\n    z::Int8\nend\ncopy(a::Struct_Big) = Struct_Big(a.x, a.y, a.z)\ncopy(a::Struct_BigI) = a\n\nfunction test_struct_big(::Type{Struct}) where {Struct}\n    a = Struct(424,-5,Int8('Z'))\n    a2 = copy(a)\n\n    if Struct == Struct_Big\n        x = ccall((:test_big, libccalltest), Struct_Big, (Struct_Big,), a2)\n    else\n        x = ccall((:test_big, libccalltest), Struct_BigI, (Struct_BigI,), a2)\n    end\n\n    @test a2.x == a.x && a2.y == a.y && a2.z == a.z\n    @test x.x == a.x + 1\n    @test x.y == a.y - 2\n    @test x.z == a.z - Int('A')\nend\ntest_struct_big(Struct_Big)\ntest_struct_big(Struct_BigI)\n\nlet a, a2, x\n    a = Struct_Big(424,-5,Int8('Z'))\n    a2 = copy(a)\n    x = ccall((:test_big_long, libccalltest), Struct_Big, (Int, Int, Int, Struct_Big,), 2, 3, 4, a2)\n    @test a2.x == a.x && a2.y == a.y && a2.z == a.z\n    @test x.x == a.x + 10\n    @test x.y == a.y - 2\n    @test x.z == a.z - Int('A')\nend\n\nconst Struct_huge1a = NTuple{8, Int64}\nconst Struct_huge1b = NTuple{9, Int64}\nconst Struct_huge2a = NTuple{8, Cdouble}\nconst Struct_huge2b = NTuple{9, Cdouble}\nmutable struct Struct_huge3a\n    cf::NTuple{3, Complex{Cfloat}}\n    f7::Cfloat\n    f8::Cfloat\nend\nmutable struct Struct_huge3b\n    cf::NTuple{7, Complex{Cfloat}}\n    r8a::Cfloat\n    r8b::Cfloat\nend\nmutable struct Struct_huge3c\n    cf::NTuple{7, Complex{Cfloat}}\n    r8a::Cfloat\n    r8b::Cfloat\n    r9::Cfloat\nend\nmutable struct Struct_huge4a\n    r12::Complex{Cdouble}\n    r34::Complex{Cdouble}\n    r5::Complex{Cfloat}\n    r67::Complex{Cdouble}\n    r8::Cdouble\nend\nmutable struct Struct_huge4b\n    r12::Complex{Cdouble}\n    r34::Complex{Cdouble}\n    r5::Complex{Cfloat}\n    r67::Complex{Cdouble}\n    r89::Complex{Cdouble}\nend\nconst Struct_huge5a = NTuple{8, Complex{Cint}}\nconst Struct_huge5b = NTuple{9, Complex{Cint}}\n\nfunction verify_huge(init, a, b)\n    @test typeof(init) === typeof(a) === typeof(b)\n    verbose && @show (a, b)\n    # make sure a was unmodified\n    for i = 1:nfields(a)\n        @test getfield(init, i) === getfield(a, i)\n    end\n    # make sure b was modified as expected\n    a1, b1 = getfield(a, 1), getfield(b, 1)\n    while isa(a1, Tuple)\n        @test a1[2:end] === b1[2:end]\n        a1 = a1[1]\n        b1 = b1[1]\n    end\n    if isa(a1, VecElement)\n        a1 = a1.value\n        b1 = b1.value\n    end\n    @test oftype(a1, a1 * 39) === b1\n    for i = 2:nfields(a)\n        @test getfield(a, i) === getfield(b, i)\n    end\nend\nmacro test_huge(i, b, init)\n    f = QuoteNode(Symbol(\"test_huge\", i, b))\n    ty = Symbol(\"Struct_huge\", i, b)\n    return quote\n        let a = $ty($(esc(init))...), f\n            f(b) = ccall(($f, libccalltest), $ty, (Cchar, $ty, Cchar), '0' + $i, a, $b[1])\n            #code_llvm(f, typeof((a,)))\n            verify_huge($ty($(esc(init))...), a, f(a))\n        end\n    end\nend\n@test_huge 1 'a' ((1, 2, 3, 4, 5, 6, 7, 8),)\n@test_huge 1 'b' ((1, 2, 3, 4, 5, 6, 7, 8, 9),)\n@test_huge 2 'a' ((1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0),)\n@test_huge 2 'b' ((1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0),)\n@test_huge 3 'a' ((1.0 + 2.0im, 3.0 + 4.0im, 5.0 + 6.0im), 7.0, 8.0)\n@test_huge 3 'b' ((1.0 + 2.0im, 3.0 + 4.0im, 5.0 + 6.0im, 7.0 + 8.0im, 9.0 + 10.0im, 11.0 + 12.0im, 13.0 + 14.0im), 7.0, 8.0)\n@test_huge 3 'c' ((1.0 + 2.0im, 3.0 + 4.0im, 5.0 + 6.0im, 7.0 + 8.0im, 9.0 + 10.0im, 11.0 + 12.0im, 13.0 + 14.0im), 7.0, 8.0, 9.0)\n@test_huge 4 'a' (1.0 + 2.0im, 3.0 + 4.0im, 5.0f0 + 6.0f0im, 7.0 + 8.0im, 9.0)\n@test_huge 4 'b' (1.0 + 2.0im, 3.0 + 4.0im, 5.0f0 + 6.0f0im, 7.0 + 8.0im, 9.0 + 10.0im)\n@test_huge 5 'a' ((1 + 2im, 3 + 4im, 5 + 6im, 7 + 8im, 9 + 10im, 11 + 12im, 13 + 14im, 15 + 16im),)\n@test_huge 5 'b' ((1 + 2im, 3 + 4im, 5 + 6im, 7 + 8im, 9 + 10im, 11 + 12im, 13 + 14im, 15 + 16im, 17 + 17im),)\n\n## cfunction roundtrip\n\nverbose && Libc.flush_cstdio()\n\nif cfunction_closure\nverbose && println(\"Testing cfunction closures: \")\n\n# helper Type for testing that constructors work\n# with cfucntion and that object identity is preserved\nmutable struct IdentityTestKV{K, V}\n    (T::Type{<:IdentityTestKV})(S) = (@test T === S; T)\nend\n\n@noinline function testclosure(f, a::T, permanent::Bool=false, tt::Type{S}=Any) where {T, S}\n    @nospecialize(f, a, tt)\n    # generic API 1\n    cf = @cfunction $f Ref{T} (Ref{T},)\n    GC.gc()\n    @test cf.ptr != C_NULL\n    @test cf.f === f\n    @test (cf._1 == C_NULL) == permanent\n    @test (cf._2 == C_NULL) == permanent\n    @assert cf === Base.cconvert(Ptr{Cvoid}, cf)\n    GC.@preserve cf begin\n        fptr = Base.unsafe_convert(Ptr{Cvoid}, cf)\n        b = ccall(fptr, Ref{T}, (Ref{T},), a)\n    end\n    # generic API 2\n    cf2 = @cfunction $f Any (Ref{S},)\n    GC.gc()\n    @test cf2.ptr != C_NULL\n    @test cf2.f === f\n    @test (cf2._1 == C_NULL) == permanent\n    @test (cf2._2 == C_NULL) == permanent\n    @assert cf2 === Base.cconvert(Ptr{Cvoid}, cf2)\n    GC.@preserve cf2 begin\n        fptr = Base.unsafe_convert(Ptr{Cvoid}, cf2)\n        b = ccall(fptr, Any, (Ref{S},), a)\n    end\n    return b\nend\n\n# We can't (currently) execute some of these signatures (without compile-all),\n# but we can at least look at some of the generated code\nfunction check_code_trampoline(f, t, n::Int)\n    @nospecialize(f, t)\n    @test Base.return_types(f, t) == Any[Any]\n    llvm = sprint(code_llvm, f, t)\n    @test count(x -> true, eachmatch(r\"@jl_get_cfunction_trampoline\\(\", llvm)) == n\nend\ncheck_code_trampoline(testclosure, (Any, Any, Bool, Type), 2)\ncheck_code_trampoline(testclosure, (Any, Int, Bool, Type{Int}), 2)\ncheck_code_trampoline(testclosure, (Any, String, Bool, Type{String}), 2)\ncheck_code_trampoline(testclosure, (typeof(identity), Any, Bool, Type), 2)\ncheck_code_trampoline(testclosure, (typeof(identity), Int, Bool, Type{Int}), 0)\ncheck_code_trampoline(testclosure, (typeof(identity), String, Bool, Type{String}), 0)\n\nfunction g(i)\n    x = -332210 + i\n    y = \"foo\"\n    a(z) = x\n    b(z) = y\n    c(z) = (y = z)\n    IdentityTestVK{V, K} = IdentityTestKV{K, V}\n    @test IdentityTestVK !== IdentityTestKV\n    @test IdentityTestVK == IdentityTestKV\n    for _ = 1:5\n        @test testclosure(a, 23) == -332210 + i\n        @test testclosure(b, \"bar\") == \"foo\"\n        @test testclosure(c, \"bar\") == \"bar\"\n        @test testclosure(b, \"foo\") == \"bar\"\n        @test testclosure(c, \"foo\") == \"foo\"\n        @test testclosure(identity, IdentityTestKV, true) === IdentityTestKV\n        @test testclosure(identity, IdentityTestVK, true) === IdentityTestVK\n        @test testclosure(IdentityTestKV, IdentityTestKV, true) === IdentityTestKV\n        @test testclosure(IdentityTestVK, IdentityTestVK, false) === IdentityTestVK\n    end\nend\ng(1)\ng(2)\ng(3)\n\nverbose && println(\"Testing cfunction roundtrip: \")\n\ncf64 = 2.84+5.2im\ncf32 = 3.34f0+53.2f0im\nci32 = Complex{Int32}(Int32(10), Int32(31))\nci64 = Complex{Int64}(Int64(20), Int64(51))\ns1 = Struct1(352.39422f23, 19.287577)\n==(a::Struct1, b::Struct1) = (a.x == b.x && a.y == b.y)\n\nfor (t, v) in ((Complex{Int32}, :ci32), (Complex{Int64}, :ci64),\n              (ComplexF32, :cf32), (ComplexF64, :cf64), (Struct1, :s1))\n    fname = Symbol(\"foo\", v)\n    fname1 = Symbol(\"foo1\", v)\n    a = copy(@eval $v)\n    verbose && println(t)\n    verbose && println(\"A: \", a)\n    @eval begin\n        global function $fname1(s::$t)\n            verbose && println(\"B: \", s)\n            @test s == $v\n            @test s === $a\n            global c = s\n            return s\n        end\n        global function $fname1(s)\n            @assert false\n        end\n        global function $fname(s::$t)\n            verbose && println(\"B: \", s)\n            @test s == $v\n            if($(t).mutable)\n                @test !(s === $a)\n            end\n            global c = s\n            return s\n        end\n        global function $fname(s)\n            @assert false\n        end\n    end\n    @eval let a = $a, b\n        b = testclosure($fname1, a, true)\n        verbose && println(\"C: \", b)\n        @test b == $v\n        @test b === a\n        @test b === c\n        let cf = @cfunction($fname1, Ref{$t}, (Ref{$t},))\n            b = ccall(cf, Ref{$t}, (Ref{$t},), a)\n        end\n        verbose && println(\"C: \", b)\n        @test b == $v\n        @test b === a\n        @test b === c\n        let cf = @cfunction($fname, $t, ($t,))\n            b = ccall(cf, $t, ($t,), a)\n        end\n        verbose && println(\"C: \",b)\n        @test b == $v\n        if ($(t).mutable)\n            @test !(b === c)\n            @test !(b === a)\n        end\n        let cf = @cfunction($fname1, $t, (Ref{$t},))\n            b = ccall(cf, $t, (Ref{$t},), a)\n        end\n        verbose && println(\"C: \",b)\n        @test b == $v\n        if ($(t).mutable)\n            @test !(b === c)\n            @test !(b === a)\n        end\n        let cf = @cfunction($fname, Ref{$t}, ($t,))\n            b = ccall(cf, Ref{$t}, ($t,), a)\n        end\n        verbose && println(\"C: \",b)\n        @test b == $v\n        @test b === c\n        if ($(t).mutable)\n            @test !(b === a)\n        end\n        let cf = @cfunction($fname, Any, (Ref{$t},))\n            b = ccall(cf, Any, (Ref{$t},), $v)\n        end\n        verbose && println(\"C: \",b)\n        @test b == $v\n        @test b === c\n        if ($(t).mutable)\n            @test !(b === a)\n        end\n        let cf = @cfunction($fname, Any, (Ref{Any},))\n            b = ccall(cf, Any, (Ref{Any},), $v)\n        end\n        @test b == $v\n        @test b === c\n        if ($(t).mutable)\n            @test !(b === a)\n        end\n        let cf = @cfunction($fname, Ref{AbstractString}, (Ref{Any},))\n            @test_throws TypeError ccall(cf, Any, (Ref{Any},), $v)\n        end\n        let cf = @cfunction($fname, AbstractString, (Ref{Any},))\n            @test_throws TypeError ccall(cf, Any, (Ref{Any},), $v)\n        end\n    end\nend\n\nelse\n\n@test_broken \"cfunction: no support for closures on this platform\"\n\nend\n\n# issue 13031\nfoo13031(x) = Cint(1)\nfoo13031p = @cfunction(foo13031, Cint, (Ref{Tuple{}},))\nccall(foo13031p, Cint, (Ref{Tuple{}},), ())\n\nfoo13031(x,y,z) = z\nfoo13031p = @cfunction(foo13031, Cint, (Ref{Tuple{}}, Ref{Tuple{}}, Cint))\nccall(foo13031p, Cint, (Ref{Tuple{}},Ref{Tuple{}},Cint), (), (), 8)\n\n# issue 26078\n\nunstable26078(x) = x > 0 ? x : \"foo\"\nhandle26078 = @cfunction(unstable26078, Int32, (Int32,))\n@test ccall(handle26078, Int32, (Int32,), 1) == 1\n\n# issue 17219\nfunction ccall_reassigned_ptr(ptr::Ptr{Cvoid})\n    ptr = Libdl.dlsym(Libdl.dlopen(libccalltest), \"test_echo_p\")\n    ccall(ptr, Any, (Any,), \"foo\")\nend\n@test ccall_reassigned_ptr(C_NULL) == \"foo\"\n\n# @threadcall functionality\nthreadcall_test_func(x) =\n    @threadcall((:testUcharX, libccalltest), Int32, (UInt8,), x % UInt8)\n\n@test threadcall_test_func(3) == 1\n@test threadcall_test_func(259) == 1\n\n# issue 17819\n# NOTE: can't use cfunction or reuse ccalltest Struct methods, as those call into the runtime\n@test @threadcall((:threadcall_args, libccalltest), Cint, (Cint, Cint), 1, 2) == 3\n\nlet n=3\n    tids = Culong[]\n    @sync for i in 1:10^n\n        @async push!(tids, @threadcall(:uv_thread_self, Culong, ()))\n    end\n\n    # The work should not be done on the master thread\n    t0 = ccall(:uv_thread_self, Culong, ())\n    @test length(tids) == 10^n\n    for t in tids\n        @test t != t0\n    end\nend\n\n@test ccall(:jl_getpagesize, Clong, ()) == @threadcall(:jl_getpagesize, Clong, ())\n\n# make sure our malloc/realloc/free adapters are thread-safe and repeatable\nfor i = 1:8\n    ptr = @threadcall(:jl_malloc, Ptr{Cint}, (Csize_t,), sizeof(Cint))\n    @test ptr != C_NULL\n    unsafe_store!(ptr, 3)\n    @test unsafe_load(ptr) == 3\n    ptr = @threadcall(:jl_realloc, Ptr{Cint}, (Ptr{Cint}, Csize_t,), ptr, 2 * sizeof(Cint))\n    @test ptr != C_NULL\n    unsafe_store!(ptr, 4, 2)\n    @test unsafe_load(ptr, 1) == 3\n    @test unsafe_load(ptr, 2) == 4\n    @threadcall(:jl_free, Cvoid, (Ptr{Cint},), ptr)\nend\n\n# Pointer finalizer (issue #15408)\nlet A = [1]\n    ccall((:set_c_int, libccalltest), Cvoid, (Cint,), 1)\n    @test ccall((:get_c_int, libccalltest), Cint, ()) == 1\n    finalizer(cglobal((:finalizer_cptr, libccalltest), Cvoid), A)\n    finalize(A)\n    @test ccall((:get_c_int, libccalltest), Cint, ()) == -1\nend\n\n# Pointer finalizer at exit (PR #19911)\nlet result = read(`$(Base.julia_cmd()) --startup-file=no -e \"A = Ref{Cint}(42); finalizer(cglobal((:c_exit_finalizer, \\\"$libccalltest\\\"), Cvoid), A)\"`, String)\n    @test result == \"c_exit_finalizer: 42, 0\"\nend\n\n# SIMD Registers\n\nconst VecReg{N,T} = NTuple{N,VecElement{T}}\nconst V2xF32 = VecReg{2,Float32}\nconst V4xF32 = VecReg{4,Float32}\nconst V2xF64 = VecReg{2,Float64}\nconst V2xI32 = VecReg{2,Int32}\nconst V4xI32 = VecReg{4,Int32}\n\nstruct Struct_AA64_1\n    v1::Int32\n    v2::Int128\nend\nstruct Struct_AA64_2\n    v1::Float16\n    v2::Float64\nend\n\n# This is a homogenious short vector aggregate\nstruct Struct_AA64_3\n    v1::VecReg{8,Int8}\n    v2::VecReg{2,Float32}\nend\n# This is NOT a homogenious short vector aggregate\nstruct Struct_AA64_4\n    v2::VecReg{2,Float32}\n    v1::VecReg{8,Int16}\nend\n\nmutable struct Struct_huge1_ppc64\n    m::Int64\n    v::V4xF32\nend\n\nmutable struct Struct_huge2_ppc64\n    v1::V4xF32\n    v2::V2xI32\nend\n\nmutable struct Struct_huge3_ppc64\n    v1::V4xF32\n    f::NTuple{4,Float32}\nend\n\nmutable struct Struct_huge4_ppc64\n    v1::V2xF32\n    v2::V2xF64\nend\n\nmutable struct Struct_huge5_ppc64\n    v1::NTuple{9,V4xF32}\nend\n\nmutable struct Struct_huge6_ppc64\n    v1::NTuple{8,V4xF32}\n    v2::V4xF32\nend\n\nmutable struct Struct_huge7_ppc64\n    v1::VecReg{3,Int32}\n    v2::VecReg{3,Int32}\nend\n\nmutable struct Struct_huge1_ppc64_hva\n    v1::NTuple{8,V4xF32}\nend\n\nmutable struct Struct_huge2_ppc64_hva\n    v1::NTuple{2,NTuple{2,V4xF32}}\nend\n\nmutable struct Struct_huge3_ppc64_hva\n    vf1::V4xF32\n    vf2::Tuple{NTuple{2,V4xF32}}\nend\n\nmutable struct Struct_huge4_ppc64_hva\n    v1::V4xI32\n    v2::V4xF32\nend\n\nmutable struct Struct_huge5_ppc64_hva\n    v1::V4xI32\n    v2::V2xF64\nend\n\nif Sys.ARCH === :x86_64\n    function test_sse(a1::V4xF32, a2::V4xF32, a3::V4xF32, a4::V4xF32)\n        ccall((:test_m128, libccalltest), V4xF32, (V4xF32, V4xF32, V4xF32, V4xF32), a1, a2, a3, a4)\n    end\n\n    function test_sse(a1::V4xI32, a2::V4xI32, a3::V4xI32, a4::V4xI32)\n        ccall((:test_m128i, libccalltest), V4xI32, (V4xI32, V4xI32, V4xI32, V4xI32), a1, a2, a3, a4)\n    end\n\n    foo_ams(a1, a2, a3, a4) = VecReg(ntuple(i -> VecElement(a1[i].value + a2[i].value * (a3[i].value - a4[i].value)), 4))\n\n    for s in [Float32, Int32]\n        T = NTuple{4, VecElement{s}}\n        @eval function rt_sse(a1::$T, a2::$T, a3::$T, a4::$T)\n            return ccall(\n                @cfunction(foo_ams, $T, ($T, $T, $T, $T)),\n                $T, ($T, $T, $T, $T),\n                     a1, a2, a3, a4)\n        end\n\n        a1 = VecReg(ntuple(i -> VecElement(s(1i)), 4))\n        a2 = VecReg(ntuple(i -> VecElement(s(2i)), 4))\n        a3 = VecReg(ntuple(i -> VecElement(s(3i)), 4))\n        a4 = VecReg(ntuple(i -> VecElement(s(4i)), 4))\n        r = VecReg(ntuple(i -> VecElement(s(1i + 2i * (3i - 4i))), 4))\n        @test test_sse(a1, a2, a3, a4) == r\n\n        # cfunction round-trip\n        @test rt_sse(a1, a2, a3, a4) == r\n    end\n\nelseif Sys.ARCH === :aarch64\n    for v1 in 1:99:1000, v2 in -100:-1999:-20000\n        @test ccall((:test_aa64_i128_1, libccalltest), Int128,\n                    (Int64, Int128), v1, v2) == v1 * 2 - v2\n    end\n    for v1 in 1:4, v2 in -4:-1, v3_1 in 3:5, v3_2 in 7:9\n        res = ccall((:test_aa64_i128_2, libccalltest), Struct_AA64_1,\n                    (Int64, Int128, Struct_AA64_1),\n                    v1, v2, Struct_AA64_1(v3_1, v3_2))\n        expected = Struct_AA64_1(v1 \u00f7 2 + 1 - v3_1, v2 * 2 - 1 - v3_2)\n        @test res === expected\n    end\n    for v1 in 1:4, v2 in -4:-1, v3 in 3:5, v4 in -(1:3)\n        res = ccall((:test_aa64_fp16_1, libccalltest), Float16,\n                    (Cint, Float32, Float64, Float16),\n                    v1, v2, v3, v4)\n        expected = Float16(v1 + v2 * 2 + v3 * 3 + v4 * 4)\n        @test res === expected\n\n        res = ccall((:test_aa64_fp16_2, libccalltest), Struct_AA64_2,\n                    (Cint, Float32, Float64, Float16),\n                    v1, v2, v3, v4)\n        expected = Struct_AA64_2(v4 / 2 + 1, v1 * 2 + v2 * 4 - v3)\n        @test res === expected\n    end\n    for v1_1 in 1:4, v1_2 in -2:2, v2 in -4:-1, v3_1 in 3:5, v3_2 in 6:8\n        res = ccall((:test_aa64_vec_1, libccalltest),\n                    VecReg{2,Int64},\n                    (VecReg{2,Int32}, Float32, VecReg{2,Int32}),\n                    (VecElement(Int32(v1_1)), VecElement(Int32(v1_2))),\n                    v2, (VecElement(Int32(v3_1)), VecElement(Int32(v3_2))))\n        expected = (VecElement(v1_1 * v2 + v3_1), VecElement(v1_2 * v2 + v3_2))\n        @test res === expected\n    end\n    for v1_11 in 1:4, v1_12 in -2:2, v1_21 in 1:4, v1_22 in -2:2,\n        v2_11 in 1:4, v2_12 in -2:2, v2_21 in 1:4, v2_22 in -2:2\n        v1 = Struct_AA64_3((VecElement(Int8(v1_11)), VecElement(Int8(v1_12)),\n                            VecElement(Int8(0)), VecElement(Int8(0)),\n                            VecElement(Int8(0)), VecElement(Int8(0)),\n                            VecElement(Int8(0)), VecElement(Int8(0))),\n                           (VecElement(Float32(v1_21)),\n                            VecElement(Float32(v1_22))))\n        v2 = Struct_AA64_4((VecElement(Float32(v2_21)),\n                            VecElement(Float32(v2_22))),\n                           (VecElement(Int16(v2_11)), VecElement(Int16(v2_12)),\n                            VecElement(Int16(0)), VecElement(Int16(0)),\n                            VecElement(Int16(0)), VecElement(Int16(0)),\n                            VecElement(Int16(0)), VecElement(Int16(0))))\n        res = ccall((:test_aa64_vec_2, libccalltest),\n                    Struct_AA64_3, (Struct_AA64_3, Struct_AA64_4), v1, v2)\n        expected = Struct_AA64_3((VecElement(Int8(v1_11 + v2_11)),\n                                  VecElement(Int8(v1_12 + v2_12)),\n                                  VecElement(Int8(0)), VecElement(Int8(0)),\n                                  VecElement(Int8(0)), VecElement(Int8(0)),\n                                  VecElement(Int8(0)), VecElement(Int8(0))),\n                                 (VecElement(Float32(v1_21 - v2_21)),\n                                  VecElement(Float32(v1_22 - v2_22))))\n        @test res === expected\n    end\n\nelseif Sys.ARCH === :powerpc64le || Sys.ARCH === :ppc64le\n@test_huge 1 \"_ppc64\" (1, (2.0, 3.0, 4.0, 5.0),)\n@test_huge 2 \"_ppc64\" ((1.0, 2.0, 3.0, 4.0), (11, 12))\n@test_huge 3 \"_ppc64\" ((1, 2, 3, 4), (11.0, 12.0, 13.0, 14.0))\n@test_huge 4 \"_ppc64\" ((1, 2), (11.0, 12.0))\n@test_huge 5 \"_ppc64\" ((((1.0, 2.0, 3.0, 4.0),\n                         (5.0, 6.0, 7.0, 8.0),\n                         (11.0, 12.0, 13.0, 14.0),\n                         (15.0, 16.0, 17.0, 18.0),\n                         (21.0, 22.0, 23.0, 24.0),\n                         (25.0, 26.0, 27.0, 28.0),\n                         (31.0, 32.0, 33.0, 34.0),\n                         (35.0, 36.0, 37.0, 38.0),\n                         (41.0, 42.0, 43.0, 44.0)),))\n@test_huge 6 \"_ppc64\" ((((1.0, 2.0, 3.0, 4.0),\n                         (5.0, 6.0, 7.0, 8.0),\n                         (11.0, 12.0, 13.0, 14.0),\n                         (15.0, 16.0, 17.0, 18.0),\n                         (21.0, 22.0, 23.0, 24.0),\n                         (25.0, 26.0, 27.0, 28.0),\n                         (31.0, 32.0, 33.0, 34.0),\n                         (35.0, 36.0, 37.0, 38.0)),\n                        (41.0, 42.0, 43.0, 44.0)))\n@test_huge 1 \"_ppc64_hva\" ((((1.0, 2.0, 3.0, 4.0),\n                             (5.0, 6.0, 7.0, 8.0),\n                             (11.0, 12.0, 13.0, 14.0),\n                             (15.0, 16.0, 17.0, 18.0),\n                             (21.0, 22.0, 23.0, 24.0),\n                             (25.0, 26.0, 27.0, 28.0),\n                             (31.0, 32.0, 33.0, 34.0),\n                             (35.0, 36.0, 37.0, 38.0)),))\n@test_huge 2 \"_ppc64_hva\" (((((1.0, 2.0, 3.0, 4.0),\n                              (5.0, 6.0, 7.0, 8.0)),\n                             ((11.0, 12.0, 13.0, 14.0),\n                              (15.0, 16.0, 17.0, 18.0))),))\n@test_huge 3 \"_ppc64_hva\" (((1.0, 2.0, 3.0, 4.0),\n                            (((11.0, 12.0, 13.0, 14.0),\n                              (15.0, 16.0, 17.0, 18.0)),)))\n@test_huge 4 \"_ppc64_hva\" (((1, 2, 3, 4),\n                            (11.0, 12.0, 13.0, 14.0)))\n@test_huge 5 \"_ppc64_hva\" (((1, 2, 3, 4),\n                            (11.0, 12.0)))\n\n@test 18451 == ccall((:test_ppc64_vec1long, libccalltest), Int64,\n    (Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Struct_huge1_ppc64),\n    1, 2, 3, 4, 5, 6, 7, 8, 9, Struct_huge1_ppc64(18000, (100, 101, 102, 103)))\n\n@test 941 == ccall((:test_ppc64_vec1long_vec, libccalltest), Int64,\n    (Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, V4xF32),\n    11, 12, 13, 14, 15, 16, 17, 18, 19, (200, 201, 202, 203))\n\n@test V4xF32((614232, 614218, 614204, 614190)) ==\n     ccall((:test_ppc64_vec2, libccalltest), V4xF32,\n    (Int64, V4xF32, V4xF32, V4xF32, V4xF32,\n     V4xF32, V4xF32, V4xF32, V4xF32, V4xF32,\n     V4xF32, V4xF32, V4xF32, V4xF32, V4xF32),\n    600000, (4, 3, 2, 1), (5, 4, 3, 2), (6, 5, 4, 3), (7, 6, 5, 4),\n    (14, 13, 12, 11), (15, 14, 13, 12), (16, 15, 14, 13), (17, 16, 15, 14), (18, 17, 16, 15),\n    (1024, 1023, 1022, 1021), (1025, 1024, 1023, 1022), (1026, 1025, 1024, 1023), (1027, 1026, 1025, 1024), (10028, 10027, 10026, 10025))\n\nelseif Sys.ARCH !== :i686 && Sys.ARCH !== :arm # TODO\n@warn \"ccall: no VecReg tests run for this platform\"\n\nend\n\n# Special calling convention for `Array`\nfunction f17204(a)\n    b = similar(a)\n    for i in eachindex(a)\n        b[i] = a[i] + 10\n    end\n    return b\nend\n@test ccall(@cfunction(f17204, Vector{Any}, (Vector{Any},)),\n            Vector{Any}, (Vector{Any},), Any[1:10;]) == Any[11:20;]\n\n# This used to trigger incorrect ccall callee inlining.\n# Not sure if there's a more reliable way to test this.\n# Do not put these in a function.\n@noinline g17413() = rand()\n@inline f17413() = (g17413(); g17413())\nccall((:test_echo_p, libccalltest), Ptr{Cvoid}, (Any,), f17413())\nfor i in 1:3\n    ccall((:test_echo_p, libccalltest), Ptr{Cvoid}, (Any,), f17413())\nend\n\nlet r = Ref{Any}(10)\n    @GC.preserve r begin\n        pa = Base.unsafe_convert(Ptr{Any}, r) # pointer to value\n        pv = Base.unsafe_convert(Ptr{Cvoid}, r) # pointer to data\n        @test Ptr{Cvoid}(pa) != pv\n        @test unsafe_load(pa) === 10\n        @test unsafe_load(Ptr{Ptr{Cvoid}}(pa)) === pv\n        @test unsafe_load(Ptr{Int}(pv)) === 10\n    end\nend\n\nlet r = Ref{Any}(\"123456789\")\n    @GC.preserve r begin\n        pa = Base.unsafe_convert(Ptr{Any}, r) # pointer to value\n        pv = Base.unsafe_convert(Ptr{Cvoid}, r) # pointer to data\n        @test Ptr{Cvoid}(pa) != pv\n        @test unsafe_load(pa) === r[]\n        @test unsafe_load(Ptr{Ptr{Cvoid}}(pa)) === pv\n        @test unsafe_load(Ptr{Int}(pv)) === length(r[])\n    end\nend\n\n\nstruct SpillPint\n    a::Ptr{Cint}\n    b::Ptr{Cint}\nend\nBase.cconvert(::Type{SpillPint}, v::NTuple{2,Cint}) =\n    Base.cconvert(Ref{NTuple{2,Cint}}, v)\nfunction Base.unsafe_convert(::Type{SpillPint}, vr)\n    ptr = Base.unsafe_convert(Ref{NTuple{2,Cint}}, vr)\n    return SpillPint(ptr, ptr + 4)\nend\n\nmacro test_spill_n(n::Int, intargs, floatargs)\n    fname_int = Symbol(:test_spill_int, n)\n    fname_float = Symbol(:test_spill_float, n)\n    quote\n        local ints = $(esc(intargs))\n        local floats = $(esc(intargs))\n        @test ccall(($(QuoteNode(fname_int)), libccalltest), Cint,\n                    ($((:(Ref{Cint}) for j in 1:n)...), SpillPint),\n                    $((:(ints[$j]) for j in 1:n)...),\n                    (ints[$n + 1], ints[$n + 2])) == sum(ints[1:($n + 2)])\n        @test ccall(($(QuoteNode(fname_float)), libccalltest), Float32,\n                    ($((:Float32 for j in 1:n)...), NTuple{2,Float32}),\n                    $((:(floats[$j]) for j in 1:n)...),\n                    (floats[$n + 1], floats[$n + 2])) == sum(floats[1:($n + 2)])\n    end\nend\n\nfor i in 1:100\n    local intargs = rand(1:10000, 14)\n    local int32args = Int32.(intargs)\n    local intsum = sum(intargs)\n    local floatargs = rand(14)\n    local float32args = Float32.(floatargs)\n    local float32sum = sum(float32args)\n    local float64sum = sum(floatargs)\n    @test ccall((:test_long_args_intp, libccalltest), Cint,\n                (Ref{Cint}, Ref{Cint}, Ref{Cint}, Ref{Cint},\n                 Ref{Cint}, Ref{Cint}, Ref{Cint}, Ref{Cint},\n                 Ref{Cint}, Ref{Cint}, Ref{Cint}, Ref{Cint},\n                 Ref{Cint}, Ref{Cint}),\n                intargs[1], intargs[2], intargs[3], intargs[4],\n                intargs[5], intargs[6], intargs[7], intargs[8],\n                intargs[9], intargs[10], intargs[11], intargs[12],\n                intargs[13], intargs[14]) == intsum\n    @test ccall((:test_long_args_int, libccalltest), Cint,\n                (Cint, Cint, Cint, Cint, Cint, Cint, Cint, Cint,\n                 Cint, Cint, Cint, Cint, Cint, Cint),\n                intargs[1], intargs[2], intargs[3], intargs[4],\n                intargs[5], intargs[6], intargs[7], intargs[8],\n                intargs[9], intargs[10], intargs[11], intargs[12],\n                intargs[13], intargs[14]) == intsum\n    @test ccall((:test_long_args_float, libccalltest), Float32,\n                (Float32, Float32, Float32, Float32, Float32, Float32,\n                 Float32, Float32, Float32, Float32, Float32, Float32,\n                 Float32, Float32),\n                floatargs[1], floatargs[2], floatargs[3], floatargs[4],\n                floatargs[5], floatargs[6], floatargs[7], floatargs[8],\n                floatargs[9], floatargs[10], floatargs[11], floatargs[12],\n                floatargs[13], floatargs[14]) \u2248 float32sum\n    @test ccall((:test_long_args_double, libccalltest), Float64,\n                (Float64, Float64, Float64, Float64, Float64, Float64,\n                 Float64, Float64, Float64, Float64, Float64, Float64,\n                 Float64, Float64),\n                floatargs[1], floatargs[2], floatargs[3], floatargs[4],\n                floatargs[5], floatargs[6], floatargs[7], floatargs[8],\n                floatargs[9], floatargs[10], floatargs[11], floatargs[12],\n                floatargs[13], floatargs[14]) \u2248 float64sum\n\n    @test_spill_n 1 int32args float32args\n    @test_spill_n 2 int32args float32args\n    @test_spill_n 3 int32args float32args\n    @test_spill_n 4 int32args float32args\n    @test_spill_n 5 int32args float32args\n    @test_spill_n 6 int32args float32args\n    @test_spill_n 7 int32args float32args\n    @test_spill_n 8 int32args float32args\n    @test_spill_n 9 int32args float32args\n    @test_spill_n 10 int32args float32args\nend\n\n# issue #20835\n@test_throws(ErrorException(\"could not evaluate ccall argument type (it might depend on a local variable)\"),\n             eval(:(f20835(x) = ccall(:fn, Cvoid, (Ptr{typeof(x)},), x))))\n@test_throws(UndefVarError(:Something_not_defined_20835),\n             eval(:(f20835(x) = ccall(:fn, Something_not_defined_20835, (Ptr{typeof(x)},), x))))\n\n@noinline f21104at(::Type{T}) where {T} = ccall(:fn, Cvoid, (Some{T},), Some(0))\n@noinline f21104rt(::Type{T}) where {T} = ccall(:fn, Some{T}, ())\n@test code_llvm(devnull, f21104at, (Type{Float64},)) === nothing\n@test code_llvm(devnull, f21104rt, (Type{Float64},)) === nothing\n@test_throws(ErrorException(\"ccall argument 1 doesn't correspond to a C type\"),\n             f21104at(Float64))\n@test_throws(ErrorException(\"ccall return type doesn't correspond to a C type\"),\n             f21104rt(Float64))\n\n# test for malformed syntax errors\n@test Expr(:error, \"more arguments than types for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (), x)))\n@test Expr(:error, \"more arguments than types for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B,), x, y)))\n@test Expr(:error, \"more arguments than types for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B,), x, y, z)))\n@test Expr(:error, \"more arguments than types for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B,), x, y)))\n@test Expr(:error, \"more arguments than types for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B,), x, y, z)))\n@test Expr(:error, \"more arguments than types for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B, C), x, y, z)))\n@test Expr(:error, \"more types than arguments for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B,),)))\n@test Expr(:error, \"more types than arguments for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B, C), )))\n@test Expr(:error, \"more types than arguments for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B..., C...), )))\n@test Expr(:error, \"C ABI prohibits vararg without one required argument\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B...,), x)))\n@test Expr(:error, \"only the trailing ccall argument type should have \\\"...\\\"\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (A, B..., C...), a, x)))\n@test Expr(:error, \"only the trailing ccall argument type should have \\\"...\\\"\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (A, B..., C...), a, x, y, z)))\n@test Expr(:error, \"more types than arguments for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B, C...), )))\n\n# cfunction on non-function singleton\nstruct CallableSingleton\nend\n(::CallableSingleton)(x, y) = x + y\n@test ccall(@cfunction(CallableSingleton(), Int, (Int, Int)),\n            Int, (Int, Int), 1, 2) === 3\n\n# 19805\nmutable struct callinfos_19805{FUNC_FT<:Function}\n    f :: FUNC_FT\nend\n\nevalf_callback_19805(ci::callinfos_19805{FUNC_FT}) where {FUNC_FT} = ci.f(0.5)::Float64\n\nevalf_callback_c_19805(ci::callinfos_19805{FUNC_FT}) where {FUNC_FT} = @cfunction(\n    evalf_callback_19805, Float64, (callinfos_19805{FUNC_FT},))\n\n@test_throws(ErrorException(\"cfunction argument 1 doesn't correspond to a C type\"),\n             evalf_callback_c_19805( callinfos_19805(sin) ))\n@test_throws(ErrorException(\"cfunction argument 2 doesn't correspond to a C type\"),\n             @cfunction(+, Int, (Int, Nothing)))\n@test_throws(ErrorException(\"cfunction: Vararg syntax not allowed for argument list\"),\n             @cfunction(+, Int, (Vararg{Int},)))\n@test_throws(ErrorException(\"could not evaluate cfunction argument type (it might depend on a local variable)\"),\n             @eval () -> @cfunction(+, Int, (Ref{T}, Ref{T})) where T)\n@test_throws(ErrorException(\"could not evaluate cfunction return type (it might depend on a local variable)\"),\n             @eval () -> @cfunction(+, Ref{T}, (Int, Int)) where T)\n@test_throws(ErrorException(\"cfunction return type Ref{Any} is invalid. Use Any or Ptr{Any} instead.\"),\n             @cfunction(+, Ref{Any}, (Int, Int)))\n\n# test Ref{abstract_type} calling parameter passes a heap box\nabstract type Abstract22734 end\nstruct Bits22734 <: Abstract22734\n    x::Int\n    y::Float64\nend\nfunction cb22734(ptr::Ptr{Cvoid})\n    GC.gc()\n    obj = unsafe_pointer_to_objref(ptr)::Bits22734\n    obj.x + obj.y\nend\nptr22734 = @cfunction(cb22734, Float64, (Ptr{Cvoid},))\nfunction caller22734(ptr)\n    obj = Bits22734(12, 20)\n    ccall(ptr, Float64, (Ref{Abstract22734},), obj)\nend\n@test caller22734(ptr22734) === 32.0\n\n# 26297#issuecomment-371165725\n#   test that the first argument to cglobal is recognized as a tuple literal even through\n#   macro expansion\nmacro cglobal26297(sym)\n    :(cglobal(($(esc(sym)), libccalltest), Cint))\nend\ncglobal26297() = @cglobal26297(:global_var)\n@test cglobal26297() != C_NULL\n\n# issue #26607\nnoop_func_26607 = () -> nothing\nfunction callthis_26607(args)\n    @cfunction(noop_func_26607, Cvoid, ())\n    return nothing\nend\n@test callthis_26607(Int64(0)) === nothing\n@test callthis_26607(Int32(0)) === nothing\n\n# issue #27178 (cfunction special case in inlining)\nmutable struct CallThisFunc27178{FCN_TYPE}\n    fcn::FCN_TYPE\nend\n\ncallback27178(cb::CTF) where CTF<:CallThisFunc27178 = nothing\n@inline make_cfunc27178(cbi::CI) where CI = @cfunction(callback27178, Cvoid, (Ref{CI},))\nget_c_func(fcn::FCN_TYPE) where {FCN_TYPE<:Function} = return make_cfunc27178(CallThisFunc27178(fcn))\n@test isa(get_c_func(sin), Ptr)\n\n# issue #27215\nfunction once_removed()\n    function mycompare(a, b)::Cint\n        return (a < b) ? -1 : ((a > b) ? +1 : 0)\n    end\n    mycompare_c = @cfunction($mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}))\nend\n@test isa(once_removed(), Base.CFunction)\n\n# issue #27478\nfunction ccall27478()\n    module_lib = Libdl.dlopen(\"libjulia\")\n    ccall(Libdl.dlsym(module_lib, \"getpid\"), Cint, ())\nend\n@test code_typed(ccall27478, ()) isa Array\n\n# issue #27477\n@eval module Pkg27477\nconst libccalltest = $libccalltest\nend\n\nmodule Test27477\nusing ..Pkg27477\ntest27477() = ccall((:ctest, Pkg27477.libccalltest), Complex{Int}, (Complex{Int},), 1 + 2im)\nend\n\n@test Test27477.test27477() == 2 + 0im\n\n# issue #31073\nlet\n    a = ['0']\n    arr = Vector{Char}(undef, 2)\n    ptr = pointer(arr)\n    elsz = sizeof(Char)\n    na = length(a)\n    nba = na * elsz\n    ptr = eval(:(ccall(:memcpy, Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}, UInt), $(arr), $(a), $(nba))))\n    @test isa(ptr, Ptr{Cvoid})\n    @test arr[1] == '0'\nend\n\n# issue #38751\nlet\n    function f38751!(dest::Vector{UInt8}, src::Vector{UInt8}, n::UInt)\n        d, s = pointer(dest), pointer(src)\n        GC.@preserve dest src ccall(:memcpy, Cvoid, (Ptr{UInt8}, Ptr{UInt8}, Csize_t), d, s, n)\n        return dest\n    end\n    dest = zeros(UInt8, 8)\n    @test f38751!(dest, collect(0x1:0x8), UInt(8)) == 0x1:0x8\n    llvm = sprint(code_llvm, f38751!, (Vector{UInt8}, Vector{UInt8}, UInt))\n    @test !occursin(\"call void inttoptr\", llvm)\nend\n\n# issue #34061\nlet o_file = tempname(), err = Base.PipeEndpoint()\n    run(pipeline(Cmd(`$(Base.julia_cmd()) --color=no --output-o=$o_file -e '\n        Base.reinit_stdio();\n        f() = ccall((:dne, :does_not_exist), Cvoid, ());\n        f()'`; ignorestatus=true), stderr=err), wait=false)\n    output = read(err, String)\n    @test occursin(\"\"\"ERROR: could not load library \"does_not_exist\"\n    \"\"\", output)\n    @test !isfile(o_file)\nend\n\n# pass NTuple{N,T} as Ptr{T}/Ref{T}\nlet\n    dest = Ref((0,0,0))\n\n    src  = Ref((1,2,3))\n    ccall(:memcpy, Ptr{Cvoid}, (Ptr{Int}, Ptr{Int}, Csize_t), dest, src, 3*sizeof(Int))\n    @test dest[] == (1,2,3)\n\n    src  = Ref((4,5,6))\n    ccall(:memcpy, Ptr{Cvoid}, (Ref{Int}, Ref{Int}, Csize_t), dest, src, 3*sizeof(Int))\n    @test dest[] == (4,5,6)\n\n    src  = (7,8,9)\n    ccall(:memcpy, Ptr{Cvoid}, (Ref{Int}, Ref{Int}, Csize_t), dest, src, 3*sizeof(Int))\n    @test dest[] == (7,8,9)\nend\n\n\n# @ccall macro\nusing Base: ccall_macro_parse, ccall_macro_lower\n@testset \"test basic ccall_macro_parse functionality\" begin\n    callexpr = :(\n        libc.printf(\"%s = %d\\n\"::Cstring ; name::Cstring, value::Cint)::Cvoid\n    )\n    @test ccall_macro_parse(callexpr) == (\n        :((:printf, libc)),               # function\n        :Cvoid,                           # returntype\n        Any[:Cstring, :Cstring, :Cint],   # argument types\n        Any[\"%s = %d\\n\", :name, :value],  # argument symbols\n        1                                 # number of required arguments (for varargs)\n    )\nend\n\n@testset \"ensure the base-case of @ccall works, including library name and pointer interpolation\" begin\n    call = ccall_macro_lower(:ccall, ccall_macro_parse( :( libstring.func(\n        str::Cstring,\n        num1::Cint,\n        num2::Cint\n    )::Cstring))...)\n    @test call == Base.remove_linenums!(\n        quote\n        local arg1root = $(GlobalRef(Base, :cconvert))($(Expr(:escape, :Cstring)), $(Expr(:escape, :str)))\n        local arg1 = $(GlobalRef(Base, :unsafe_convert))($(Expr(:escape, :Cstring)), arg1root)\n        local arg2root = $(GlobalRef(Base, :cconvert))($(Expr(:escape, :Cint)), $(Expr(:escape, :num1)))\n        local arg2 = $(GlobalRef(Base, :unsafe_convert))($(Expr(:escape, :Cint)), arg2root)\n        local arg3root = $(GlobalRef(Base, :cconvert))($(Expr(:escape, :Cint)), $(Expr(:escape, :num2)))\n        local arg3 = $(GlobalRef(Base, :unsafe_convert))($(Expr(:escape, :Cint)), arg3root)\n        $(Expr(:foreigncall,\n               :($(Expr(:escape, :((:func, libstring))))),\n               :($(Expr(:escape, :Cstring))),\n               :($(Expr(:escape, :(($(Expr(:core, :svec)))(Cstring, Cint, Cint))))),\n               0,\n               :(:ccall),\n               :arg1, :arg2, :arg3, :arg1root, :arg2root, :arg3root))\n        end)\n\n    # pointer interpolation\n    call = ccall_macro_lower(:ccall, ccall_macro_parse(:( $(Expr(:$, :fptr))(\"bar\"::Cstring)::Cvoid ))...)\n    @test Base.remove_linenums!(call) == Base.remove_linenums!(\n    quote\n        func = $(Expr(:escape, :fptr))\n        begin\n            if !(func isa Ptr{Cvoid})\n                name = :fptr\n                throw(ArgumentError(\"interpolated function `$(name)` was not a Ptr{Cvoid}, but $(typeof(func))\"))\n            end\n        end\n        local arg1root = $(GlobalRef(Base, :cconvert))($(Expr(:escape, :Cstring)), $(Expr(:escape, \"bar\")))\n        local arg1 = $(GlobalRef(Base, :unsafe_convert))($(Expr(:escape, :Cstring)), arg1root)\n        $(Expr(:foreigncall, :func, :($(Expr(:escape, :Cvoid))), :($(Expr(:escape, :(($(Expr(:core, :svec)))(Cstring))))), 0, :(:ccall), :arg1, :arg1root))\n    end)\n\nend\n\n@testset \"check error paths\" begin\n    # missing return type\n    @test_throws ArgumentError(\"@ccall needs a function signature with a return type\") ccall_macro_parse(:( foo(4.0::Cdouble )))\n    # not a function call\n    @test_throws ArgumentError(\"@ccall has to take a function call\") ccall_macro_parse(:( foo::Type ))\n    # missing type annotations on arguments\n    @test_throws ArgumentError(\"args in @ccall need type annotations. 'x' doesn't have one.\") ccall_macro_parse(:( foo(x)::Cint ))\n    # missing type annotations on varargs arguments\n    @test_throws ArgumentError(\"args in @ccall need type annotations. 'y' doesn't have one.\") ccall_macro_parse(:( foo(x::Cint ; y)::Cint ))\n    # no reqired args on varargs call\n    @test_throws ArgumentError(\"C ABI prohibits vararg without one required argument\") ccall_macro_parse(:( foo(; x::Cint)::Cint ))\n    # not a function pointer\n    @test_throws ArgumentError(\"interpolated function `PROGRAM_FILE` was not a Ptr{Cvoid}, but String\") @ccall $PROGRAM_FILE(\"foo\"::Cstring)::Cvoid\nend\n\n@testset \"check error path for @cfunction\" begin\n    @test_throws ArgumentError(\"@cfunction argument types must be a literal tuple\") @macrocall(@cfunction(identity, Cstring, Cstring))\nend\n\n# call some c functions\n@testset \"run @ccall with C standard library functions\" begin\n    @test @ccall(sqrt(4.0::Cdouble)::Cdouble) == 2.0\n\n    str = \"hello\"\n    buf = Ptr{UInt8}(Libc.malloc((length(str) + 1) * sizeof(Cchar)))\n    @ccall strcpy(buf::Cstring, str::Cstring)::Cstring\n    @test unsafe_string(buf) == str\n    Libc.free(buf)\n\n    # test pointer interpolation\n    str_identity = @cfunction(identity, Cstring, (Cstring,))\n    foo = @ccall $str_identity(\"foo\"::Cstring)::Cstring\n    @test unsafe_string(foo) == \"foo\"\n    # test interpolation of an expresison that returns a pointer.\n    foo = @ccall $(@cfunction(identity, Cstring, (Cstring,)))(\"foo\"::Cstring)::Cstring\n    @test unsafe_string(foo) == \"foo\"\n\n    # test of a vararg foreigncall using @ccall\n    strp = Ref{Ptr{Cchar}}(0)\n    fmt = \"hi+%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%hhd-%.1f-%.1f-%.1f-%.1f-%.1f-%.1f-%.1f-%.1f-%.1f\\n\"\n\n    len = @ccall asprintf(\n        strp::Ptr{Ptr{Cchar}},\n        fmt::Cstring,\n        ; # begin varargs\n        0x1::UInt8, 0x2::UInt8, 0x3::UInt8, 0x4::UInt8, 0x5::UInt8, 0x6::UInt8, 0x7::UInt8, 0x8::UInt8, 0x9::UInt8, 0xa::UInt8, 0xb::UInt8, 0xc::UInt8, 0xd::UInt8, 0xe::UInt8, 0xf::UInt8,\n        1.1::Cfloat, 2.2::Cfloat, 3.3::Cfloat, 4.4::Cfloat, 5.5::Cfloat, 6.6::Cfloat, 7.7::Cfloat, 8.8::Cfloat, 9.9::Cfloat,\n    )::Cint\n    str = unsafe_string(strp[], len)\n    @ccall free(strp[]::Cstring)::Cvoid\n    @test str == \"hi+1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-1.1-2.2-3.3-4.4-5.5-6.6-7.7-8.8-9.9\\n\"\nend\n\n\n@testset \"Cwstring\" begin\n    buffer = Array{Cwchar_t}(undef, 100)\n    len = @static if Sys.iswindows()\n            @ccall swprintf_s(buffer::Ptr{Cwchar_t}, length(buffer)::Csize_t, \"\u03b1+%ls=%hhd\"::Cwstring; \"\u03b2\"::Cwstring, 0xf::UInt8)::Cint\n        else\n            @ccall swprintf(buffer::Ptr{Cwchar_t}, length(buffer)::Csize_t, \"\u03b1+%ls=%hhd\"::Cwstring; \"\u03b2\"::Cwstring, 0xf::UInt8)::Cint\n        end\n    Libc.systemerror(\"swprintf\", len < 0)\n    str = GC.@preserve buffer unsafe_string(pointer(buffer), len)\n    @test str == \"\u03b1+\u03b2=15\"\n    str = GC.@preserve buffer unsafe_string(Cwstring(pointer(buffer)))\n    @test str == \"\u03b1+\u03b2=15\"\nend\n\n# issue #36458\ncompute_lib_name() = \"libcc\" * \"alltest\"\nccall_lazy_lib_name(x) = ccall((:testUcharX, compute_lib_name()), Int32, (UInt8,), x % UInt8)\n@test ccall_lazy_lib_name(0) == 0\n@test ccall_lazy_lib_name(3) == 1\nccall_with_undefined_lib() = ccall((:time, xx_nOt_DeFiNeD_xx), Cint, (Ptr{Cvoid},), C_NULL)\n@test_throws UndefVarError(:xx_nOt_DeFiNeD_xx) ccall_with_undefined_lib()\n\n@testset \"transcode for UInt8 and UInt16\" begin\n    a   = [UInt8(1), UInt8(2), UInt8(3)]\n    a16 = transcode(UInt16, a)\n    a8  = transcode(UInt8, a16)\n    @test a8 == a\n    b   = [UInt16(1), UInt16(2), UInt16(3)]\n    b8  = transcode(UInt8, b)\n    b16 = transcode(UInt16, b8)\n    @test b16 == b\nend\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/doc/src/manual/calling-c-and-fortran-code.md": "# Calling C and Fortran Code\n\nThough most code can be written in Julia, there are many high-quality, mature libraries for numerical\ncomputing already written in C and Fortran. To allow easy use of this existing code, Julia makes\nit simple and efficient to call C and Fortran functions. Julia has a \"no boilerplate\" philosophy:\nfunctions can be called directly from Julia without any \"glue\" code, code generation, or compilation\n-- even from the interactive prompt. This is accomplished just by making an appropriate call with\n[`ccall`](@ref) syntax, which looks like an ordinary function call.\n\nThe code to be called must be available as a shared library. Most C and Fortran libraries ship\ncompiled as shared libraries already, but if you are compiling the code yourself using GCC (or\nClang), you will need to use the `-shared` and `-fPIC` options. The machine instructions generated\nby Julia's JIT are the same as a native C call would be, so the resulting overhead is the same\nas calling a library function from C code. [^1]\n\nShared libraries and functions are referenced by a tuple of the form `(:function, \"library\")`\nor `(\"function\", \"library\")` where `function` is the C-exported function name, and `library` refers\nto the shared library name.  Shared libraries available in the (platform-specific) load path will\nbe resolved by name.  The full path to the library may also be specified.\n\nA function name may be used alone in place of the tuple (just `:function` or `\"function\"`). In\nthis case the name is resolved within the current process. This form can be used to call C library\nfunctions, functions in the Julia runtime, or functions in an application linked to Julia.\n\nBy default, Fortran compilers [generate mangled\nnames](https://en.wikipedia.org/wiki/Name_mangling#Fortran) (for example,\nconverting function names to lowercase or uppercase, often appending an\nunderscore), and so to call a Fortran function via [`ccall`](@ref) you must pass\nthe mangled identifier corresponding to the rule followed by your Fortran\ncompiler.  Also, when calling a Fortran function, all inputs must be passed as\npointers to allocated values on the heap or stack. This applies not only to\narrays and other mutable objects which are normally heap-allocated, but also to\nscalar values such as integers and floats which are normally stack-allocated and\ncommonly passed in registers when using C or Julia calling conventions.\n\nFinally, you can use [`ccall`](@ref) to actually generate a call to the library function. The arguments\nto [`ccall`](@ref) are:\n\n1. A `(:function, \"library\")` pair (most common),\n\n   OR\n\n   a `:function` name symbol or `\"function\"` name string (for symbols in the current process or libc),\n\n   OR\n\n   a function pointer (for example, from `dlsym`).\n\n2. The function's return type\n\n3. A tuple of input types, corresponding to the function signature\n\n4. The actual argument values to be passed to the function, if any; each is a separate parameter.\n\n!!! note\n    The `(:function, \"library\")` pair, return type, and input types must be literal constants\n    (i.e., they can't be variables, but see [Non-constant Function Specifications](@ref) below).\n\n    The remaining parameters are evaluated at compile time, when the containing method is defined.\n\n!!! note\n    See below for how to [map C types to Julia types](@ref mapping-c-types-to-julia).\n\nAs a complete but simple example, the following calls the `clock` function from the standard C\nlibrary on most Unix-derived systems:\n\n```julia-repl\njulia> t = ccall(:clock, Int32, ())\n2292761\n\njulia> t\n2292761\n\njulia> typeof(t)\nInt32\n```\n\n`clock` takes no arguments and returns an [`Int32`](@ref). One common mistake is forgetting that a 1-tuple of\nargument types must be written with a trailing comma. For example, to call the `getenv` function\nto get a pointer to the value of an environment variable, one makes a call like this:\n\n```julia-repl\njulia> path = ccall(:getenv, Cstring, (Cstring,), \"SHELL\")\nCstring(@0x00007fff5fbffc45)\n\njulia> unsafe_string(path)\n\"/bin/bash\"\n```\n\nNote that the argument type tuple must be written as `(Cstring,)`, not `(Cstring)`. This\nis because `(Cstring)` is just the expression `Cstring` surrounded by parentheses, rather than\na 1-tuple containing `Cstring`:\n\n```jldoctest\njulia> (Cstring)\nCstring\n\njulia> (Cstring,)\n(Cstring,)\n```\n\nIn practice, especially when providing reusable functionality, one generally wraps [`ccall`](@ref)\nuses in Julia functions that set up arguments and then check for errors in whatever manner the\nC or Fortran function specifies. And if an error occurs it is thrown as a normal Julia exception. This is especially\nimportant since C and Fortran APIs are notoriously inconsistent about how they indicate error\nconditions. For example, the `getenv` C library function is wrapped in the following Julia function,\nwhich is a simplified version of the actual definition from [`env.jl`](https://github.com/JuliaLang/julia/blob/master/base/env.jl):\n\n```julia\nfunction getenv(var::AbstractString)\n    val = ccall(:getenv, Cstring, (Cstring,), var)\n    if val == C_NULL\n        error(\"getenv: undefined variable: \", var)\n    end\n    return unsafe_string(val)\nend\n```\n\nThe C `getenv` function indicates an error by returning `NULL`, but other standard C functions\nindicate errors in various different ways, including by returning -1, 0, 1 and other special values.\nThis wrapper throws an exception clearly indicating the problem if the caller tries to get a non-existent\nenvironment variable:\n\n```julia-repl\njulia> getenv(\"SHELL\")\n\"/bin/bash\"\n\njulia> getenv(\"FOOBAR\")\ngetenv: undefined variable: FOOBAR\n```\n\nHere is a slightly more complex example that discovers the local machine's hostname.\nIn this example, the networking library code is assumed to be in a shared library named \"libc\".\nIn practice, this function is usually part of the C standard library, and so the \"libc\"\nportion should be omitted, but we wish to show here the usage of this syntax.\n\n```julia\nfunction gethostname()\n    hostname = Vector{UInt8}(undef, 256) # MAXHOSTNAMELEN\n    err = ccall((:gethostname, \"libc\"), Int32,\n                (Ptr{UInt8}, Csize_t),\n                hostname, sizeof(hostname))\n    Base.systemerror(\"gethostname\", err != 0)\n    hostname[end] = 0 # ensure null-termination\n    return GC.@preserve hostname unsafe_string(pointer(hostname))\nend\n```\n\nThis example first allocates an array of bytes. It then calls the C library function `gethostname`\nto populate the array with the hostname. Finally, it takes a pointer to the hostname buffer, and\nconverts the pointer to a Julia string, assuming that it is a NUL-terminated C string.\n\nIt is common for C libraries to use this pattern of requiring the caller to allocate memory to be\npassed to the callee and populated. Allocation of memory from Julia like this is generally\naccomplished by creating an uninitialized array and passing a pointer to its data to the C function.\nThis is why we don't use the `Cstring` type here: as the array is uninitialized, it could contain\nNUL bytes. Converting to a `Cstring` as part of the [`ccall`](@ref) checks for contained NUL bytes\nand could therefore throw a conversion error.\n\nDeferencing `pointer(hostname)` with `unsafe_string` is an unsafe operation as it requires access to\nthe memory allocated for `hostname` that may have been in the meanwhile garbage collected. The macro\n[`GC.@preserve`](@ref) prevents this from happening and therefore accessing an invalid memory location.\n\n## Creating C-Compatible Julia Function Pointers\n\nIt is possible to pass Julia functions to native C functions that accept function pointer arguments.\nFor example, to match C prototypes of the form:\n\n```c\ntypedef returntype (*functiontype)(argumenttype, ...)\n```\n\nThe macro [`@cfunction`](@ref) generates the C-compatible function pointer for a call to a\nJulia function. The arguments to [`@cfunction`](@ref) are:\n\n1. A Julia function\n2. The function's return type\n3. A tuple of input types, corresponding to the function signature\n\n!!! note\n    As with `ccall`, the return type and tuple of input types must be literal constants.\n\n!!! note\n    Currently, only the platform-default C calling convention is supported. This means that\n    `@cfunction`-generated pointers cannot be used in calls where WINAPI expects a `stdcall`\n    function on 32-bit Windows, but can be used on WIN64 (where `stdcall` is unified with the\n    C calling convention).\n\nA classic example is the standard C library `qsort` function, declared as:\n\n```c\nvoid qsort(void *base, size_t nmemb, size_t size,\n           int (*compare)(const void*, const void*));\n```\n\nThe `base` argument is a pointer to an array of length `nmemb`, with elements of `size` bytes\neach. `compare` is a callback function which takes pointers to two elements `a` and `b` and returns\nan integer less/greater than zero if `a` should appear before/after `b` (or zero if any order\nis permitted).\n\nNow, suppose that we have a 1-d array `A` of values in Julia that we want to sort\nusing the `qsort` function (rather than Julia's built-in `sort` function). Before we consider\ncalling `qsort` and passing arguments, we need to write a comparison function:\n\n```jldoctest mycompare\njulia> function mycompare(a, b)::Cint\n           return (a < b) ? -1 : ((a > b) ? +1 : 0)\n       end\nmycompare (generic function with 1 method)\n```\n\n`qsort` expects a comparison function that return a C `int`, so we annotate the return type\nto be `Cint`.\n\nIn order to pass this function to C, we obtain its address using the macro `@cfunction`:\n\n```jldoctest mycompare\njulia> mycompare_c = @cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));\n```\n\n[`@cfunction`](@ref) requires three arguments: the Julia function (`mycompare`), the return type\n(`Cint`), and a literal tuple of the input argument types, in this case to sort an array of `Cdouble`\n([`Float64`](@ref)) elements.\n\nThe final call to `qsort` looks like this:\n\n```jldoctest mycompare\njulia> A = [1.3, -2.7, 4.4, 3.1]\n4-element Vector{Float64}:\n  1.3\n -2.7\n  4.4\n  3.1\n\njulia> ccall(:qsort, Cvoid, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Cvoid}),\n             A, length(A), sizeof(eltype(A)), mycompare_c)\n\njulia> A\n4-element Vector{Float64}:\n -2.7\n  1.3\n  3.1\n  4.4\n```\n\nAs the example shows, the original Julia array `A` has now been sorted: `[-2.7, 1.3, 3.1, 4.4]`. Note that Julia\n[takes care of converting the array to a `Ptr{Cdouble}`](@ref automatic-type-conversion)), computing\nthe size of the element type in bytes, and so on.\n\nFor fun, try inserting a `println(\"mycompare($a, $b)\")` line into `mycompare`, which will allow\nyou to see the comparisons that `qsort` is performing (and to verify that it is really calling\nthe Julia function that you passed to it).\n\n## [Mapping C Types to Julia](@id mapping-c-types-to-julia)\n\nIt is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies\ncan cause code that works correctly on one system to fail or produce indeterminate results on\na different system.\n\nNote that no C header files are used anywhere in the process of calling C functions: you are responsible\nfor making sure that your Julia types and call signatures accurately reflect those in the C header\nfile.[^2]\n\n### [Automatic Type Conversion](@id automatic-type-conversion)\n\nJulia automatically inserts calls to the [`Base.cconvert`](@ref) function to convert each argument\nto the specified type. For example, the following call:\n\n```julia\nccall((:foo, \"libfoo\"), Cvoid, (Int32, Float64), x, y)\n```\n\nwill behave as if it were written like this:\n\n```julia\nccall((:foo, \"libfoo\"), Cvoid, (Int32, Float64),\n      Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),\n      Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))\n```\n\n[`Base.cconvert`](@ref) normally just calls [`convert`](@ref), but can be defined to return an\narbitrary new object more appropriate for passing to C.\nThis should be used to perform all allocations of memory that will be accessed by the C code.\nFor example, this is used to convert an `Array` of objects (e.g. strings) to an array of pointers.\n\n[`Base.unsafe_convert`](@ref) handles conversion to [`Ptr`](@ref) types. It is considered unsafe because\nconverting an object to a native pointer can hide the object from the garbage collector, causing\nit to be freed prematurely.\n\n### Type Correspondences\n\nFirst, let's review some relevant Julia type terminology:\n\n| Syntax / Keyword              | Example                                     | Description                                                                                                                                                                                                                                                                    |\n|:----------------------------- |:------------------------------------------- |:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `mutable struct`              | `BitSet`                                    | \"Leaf Type\" :: A group of related data that includes a type-tag, is managed by the Julia GC, and is defined by object-identity. The type parameters of a leaf type must be fully defined (no `TypeVars` are allowed) in order for the instance to be constructed.              |\n| `abstract type`               | `Any`, `AbstractArray{T, N}`, `Complex{T}`  | \"Super Type\" :: A super-type (not a leaf-type) that cannot be instantiated, but can be used to describe a group of types.                                                                                                                                                      |\n| `T{A}`                        | `Vector{Int}`                               | \"Type Parameter\" :: A specialization of a type (typically used for dispatch or storage optimization).                                                                                                                                                                          |\n|                               |                                             | \"TypeVar\" :: The `T` in the type parameter declaration is referred to as a TypeVar (short for type variable).                                                                                                                                                                  |\n| `primitive type`              | `Int`, `Float64`                            | \"Primitive Type\" :: A type with no fields, but a size. It is stored and defined by-value.                                                                                                                                                                                           |\n| `struct`                      | `Pair{Int, Int}`                            | \"Struct\" :: A type with all fields defined to be constant. It is defined by-value, and may be stored with a type-tag.                                                                                                                                                       |\n|                               | `ComplexF64` (`isbits`)                     | \"Is-Bits\"   :: A `primitive type`, or a `struct` type where all fields are other `isbits` types. It is defined by-value, and is stored without a type-tag.                                                                                                                       |\n| `struct ...; end`             | `nothing`                                   | \"Singleton\" :: a Leaf Type or Struct with no fields.                                                                                                                                                                                                                        |\n| `(...)` or `tuple(...)`       | `(1, 2, 3)`                                 | \"Tuple\" :: an immutable data-structure similar to an anonymous struct type, or a constant array. Represented as either an array or a struct.                                                                                                                                |\n\n### [Bits Types](@id man-bits-types)\n\nThere are several special types to be aware of, as no other type can be defined to behave the\nsame:\n\n  * `Float32`\n\n    Exactly corresponds to the `float` type in C (or `REAL*4` in Fortran).\n\n  * `Float64`\n\n    Exactly corresponds to the `double` type in C (or `REAL*8` in Fortran).\n\n  * `ComplexF32`\n\n    Exactly corresponds to the `complex float` type in C (or `COMPLEX*8` in Fortran).\n\n  * `ComplexF64`\n\n    Exactly corresponds to the `complex double` type in C (or `COMPLEX*16` in Fortran).\n\n  * `Signed`\n\n    Exactly corresponds to the `signed` type annotation in C (or any `INTEGER` type in Fortran).\n    Any Julia type that is not a subtype of [`Signed`](@ref) is assumed to be unsigned.\n\n\n  * `Ref{T}`\n\n    Behaves like a `Ptr{T}` that can manage its memory via the Julia GC.\n\n\n  * `Array{T,N}`\n\n    When an array is passed to C as a `Ptr{T}` argument, it is not reinterpret-cast: Julia requires\n    that the element type of the array matches `T`, and the address of the first element is passed.\n\n    Therefore, if an `Array` contains data in the wrong format, it will have to be explicitly converted\n    using a call such as `trunc(Int32, a)`.\n\n    To pass an array `A` as a pointer of a different type *without* converting the data beforehand\n    (for example, to pass a `Float64` array to a function that operates on uninterpreted bytes), you\n    can declare the argument as `Ptr{Cvoid}`.\n\n    If an array of eltype `Ptr{T}` is passed as a `Ptr{Ptr{T}}` argument, [`Base.cconvert`](@ref)\n    will attempt to first make a null-terminated copy of the array with each element replaced by its\n    [`Base.cconvert`](@ref) version. This allows, for example, passing an `argv` pointer array of type\n    `Vector{String}` to an argument of type `Ptr{Ptr{Cchar}}`.\n\nOn all systems we currently support, basic C/C++ value types may be translated to Julia types\nas follows. Every C type also has a corresponding Julia type with the same name, prefixed by C.\nThis can help when writing portable code (and remembering that an `int` in C is not the same as\nan `Int` in Julia).\n\n\n**System Independent Types**\n\n| C name                                                  | Fortran name             | Standard Julia Alias | Julia Base Type                                                                                                |\n|:------------------------------------------------------- |:------------------------ |:-------------------- |:-------------------------------------------------------------------------------------------------------------- |\n| `unsigned char`                                         | `CHARACTER`              | `Cuchar`             | `UInt8`                                                                                                        |\n| `bool` (_Bool in C99+)                                  |                          | `Cuchar`             | `UInt8`                                                                                                        |\n| `short`                                                 | `INTEGER*2`, `LOGICAL*2` | `Cshort`             | `Int16`                                                                                                        |\n| `unsigned short`                                        |                          | `Cushort`            | `UInt16`                                                                                                       |\n| `int`, `BOOL` (C, typical)                              | `INTEGER*4`, `LOGICAL*4` | `Cint`               | `Int32`                                                                                                        |\n| `unsigned int`                                          |                          | `Cuint`              | `UInt32`                                                                                                       |\n| `long long`                                             | `INTEGER*8`, `LOGICAL*8` | `Clonglong`          | `Int64`                                                                                                        |\n| `unsigned long long`                                    |                          | `Culonglong`         | `UInt64`                                                                                                       |\n| `intmax_t`                                              |                          | `Cintmax_t`          | `Int64`                                                                                                        |\n| `uintmax_t`                                             |                          | `Cuintmax_t`         | `UInt64`                                                                                                       |\n| `float`                                                 | `REAL*4i`                | `Cfloat`             | `Float32`                                                                                                      |\n| `double`                                                | `REAL*8`                 | `Cdouble`            | `Float64`                                                                                                      |\n| `complex float`                                         | `COMPLEX*8`              | `ComplexF32`         | `Complex{Float32}`                                                                                             |\n| `complex double`                                        | `COMPLEX*16`             | `ComplexF64`         | `Complex{Float64}`                                                                                             |\n| `ptrdiff_t`                                             |                          | `Cptrdiff_t`         | `Int`                                                                                                          |\n| `ssize_t`                                               |                          | `Cssize_t`           | `Int`                                                                                                          |\n| `size_t`                                                |                          | `Csize_t`            | `UInt`                                                                                                         |\n| `void`                                                  |                          |                      | `Cvoid`                                                                                                        |\n| `void` and `[[noreturn]]` or `_Noreturn`                |                          |                      | `Union{}`                                                                                                      |\n| `void*`                                                 |                          |                      | `Ptr{Cvoid}` (or similarly `Ref{Cvoid}`)                                                                       |\n| `T*` (where T represents an appropriately defined type) |                          |                      | `Ref{T}` (T may be safely mutated only if T is an isbits type)                                                 |\n| `char*` (or `char[]`, e.g. a string)                    | `CHARACTER*N`            |                      | `Cstring` if NUL-terminated, or `Ptr{UInt8}` if not                                                            |\n| `char**` (or `*char[]`)                                 |                          |                      | `Ptr{Ptr{UInt8}}`                                                                                              |\n| `jl_value_t*` (any Julia Type)                          |                          |                      | `Any`                                                                                                          |\n| `jl_value_t* const*` (a reference to a Julia value)     |                          |                      | `Ref{Any}` (const, since mutation would require a write barrier, which is not possible to insert correctly)    |\n| `va_arg`                                                |                          |                      | Not supported                                                                                                  |\n| `...` (variadic function specification)                 |                          |                      | `T...` (where `T` is one of the above types, when using the `ccall` function)                                  |\n| `...` (variadic function specification)                 |                          |                      | `; va_arg1::T, va_arg2::S, etc.` (only supported with `@ccall` macro)                                          |\n\nThe [`Cstring`](@ref) type is essentially a synonym for `Ptr{UInt8}`, except the conversion to `Cstring`\nthrows an error if the Julia string contains any embedded NUL characters (which would cause the\nstring to be silently truncated if the C routine treats NUL as the terminator).  If you are passing\na `char*` to a C routine that does not assume NUL termination (e.g. because you pass an explicit\nstring length), or if you know for certain that your Julia string does not contain NUL and want\nto skip the check, you can use `Ptr{UInt8}` as the argument type. `Cstring` can also be used as\nthe [`ccall`](@ref) return type, but in that case it obviously does not introduce any extra\nchecks and is only meant to improve readability of the call.\n\n**System Dependent Types**\n\n| C name          | Standard Julia Alias | Julia Base Type                              |\n|:--------------- |:-------------------- |:-------------------------------------------- |\n| `char`          | `Cchar`              | `Int8` (x86, x86_64), `UInt8` (powerpc, arm) |\n| `long`          | `Clong`              | `Int` (UNIX), `Int32` (Windows)              |\n| `unsigned long` | `Culong`             | `UInt` (UNIX), `UInt32` (Windows)            |\n| `wchar_t`       | `Cwchar_t`           | `Int32` (UNIX), `UInt16` (Windows)           |\n\n!!! note\n    When calling Fortran, all inputs must be passed by pointers to heap- or stack-allocated\n    values, so all type correspondences above should contain an additional `Ptr{..}` or\n    `Ref{..}` wrapper around their type specification.\n\n!!! warning\n    For string arguments (`char*`) the Julia type should be `Cstring` (if NUL- terminated data is\n    expected), or either `Ptr{Cchar}` or `Ptr{UInt8}` otherwise (these two pointer types have the same\n    effect), as described above, not `String`. Similarly, for array arguments (`T[]` or `T*`), the\n    Julia type should again be `Ptr{T}`, not `Vector{T}`.\n\n!!! warning\n    Julia's `Char` type is 32 bits, which is not the same as the wide character type (`wchar_t` or\n    `wint_t`) on all platforms.\n\n!!! warning\n    A return type of `Union{}` means the function will not return, i.e., C++11 `[[noreturn]]` or C11\n    `_Noreturn` (e.g. `jl_throw` or `longjmp`). Do not use this for functions that return no value\n    (`void`) but do return, use `Cvoid` instead.\n\n!!! note\n    For `wchar_t*` arguments, the Julia type should be [`Cwstring`](@ref) (if the C routine expects a\n    NUL-terminated string), or `Ptr{Cwchar_t}` otherwise. Note also that UTF-8 string data in Julia is\n    internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without\n    making a copy (but using the `Cwstring` type will cause an error to be thrown if the string itself\n    contains NUL characters).\n\n!!! note\n    C functions that take an argument of type `char**` can be called by using a `Ptr{Ptr{UInt8}}`\n    type within Julia. For example, C functions of the form:\n\n    ```c\n    int main(int argc, char **argv);\n    ```\n\n    can be called via the following Julia code:\n\n    ```julia\n    argv = [ \"a.out\", \"arg1\", \"arg2\" ]\n    ccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)\n    ```\n\n!!! note\n    For Fortran functions taking variable length strings of type `character(len=*)` the string lengths\n    are provided as *hidden arguments*. Type and position of these arguments in the list are compiler\n    specific, where compiler vendors usually default to using `Csize_t` as type and append the hidden\n    arguments at the end of the argument list. While this behaviour is fixed for some compilers (GNU),\n    others *optionally* permit placing hidden arguments directly after the character argument (Intel, PGI).\n    For example, Fortran subroutines of the form\n\n    ```fortran\n    subroutine test(str1, str2)\n    character(len=*) :: str1,str2\n    ```\n\n    can be called via the following Julia code, where the lengths are appended\n\n    ```julia\n    str1 = \"foo\"\n    str2 = \"bar\"\n    ccall(:test, Cvoid, (Ptr{UInt8}, Ptr{UInt8}, Csize_t, Csize_t),\n                        str1, str2, sizeof(str1), sizeof(str2))\n    ```\n\n!!! warning\n    Fortran compilers *may* also add other hidden arguments for pointers, assumed-shape (`:`)\n    and assumed-size (`*`) arrays. Such behaviour can be avoided by using `ISO_C_BINDING` and\n    including `bind(c)` in the definition of the subroutine, which is strongly recommended for\n    interoperable code. In this case there will be no hidden arguments, at the cost of some\n    language features (e.g. only `character(len=1)` will be permitted to pass strings).\n\n!!! note\n    A C function declared to return `Cvoid` will return the value `nothing` in Julia.\n\n### Struct Type Correspondences\n\nComposite types such as `struct` in C or `TYPE` in Fortran90 (or `STRUCTURE` / `RECORD` in some variants\nof F77), can be mirrored in Julia by creating a `struct` definition with the same\nfield layout.\n\nWhen used recursively, `isbits` types are stored inline. All other types are stored as a pointer\nto the data. When mirroring a struct used by-value inside another struct in C, it is imperative\nthat you do not attempt to manually copy the fields over, as this will not preserve the correct\nfield alignment. Instead, declare an `isbits` struct type and use that instead. Unnamed structs\nare not possible in the translation to Julia.\n\nPacked structs and union declarations are not supported by Julia.\n\nYou can get an approximation of a `union` if you know, a priori, the field that will have\nthe greatest size (potentially including padding). When translating your fields to Julia, declare\nthe Julia field to be only of that type.\n\nArrays of parameters can be expressed with `NTuple`.  For example, the struct in C notation written as\n\n```c\nstruct B {\n    int A[3];\n};\n\nb_a_2 = B.A[2];\n```\n\ncan be written in Julia as\n\n```julia\nstruct B\n    A::NTuple{3, Cint}\nend\n\nb_a_2 = B.A[3]  # note the difference in indexing (1-based in Julia, 0-based in C)\n```\n\nArrays of unknown size (C99-compliant variable length structs specified by `[]` or `[0]`) are not directly\nsupported. Often the best way to deal with these is to deal with the byte offsets directly.\nFor example, if a C library declared a proper string type and returned a pointer to it:\n\n```c\nstruct String {\n    int strlen;\n    char data[];\n};\n```\n\nIn Julia, we can access the parts independently to make a copy of that string:\n\n```julia\nstr = from_c::Ptr{Cvoid}\nlen = unsafe_load(Ptr{Cint}(str))\nunsafe_string(str + Core.sizeof(Cint), len)\n```\n\n### Type Parameters\n\nThe type arguments to `ccall` and `@cfunction` are evaluated statically,\nwhen the method containing the usage is defined.\nThey therefore must take the form of a literal tuple, not a variable,\nand cannot reference local variables.\n\nThis may sound like a strange restriction,\nbut remember that since C is not a dynamic language like Julia,\nits functions can only accept argument types with a statically-known, fixed signature.\n\nHowever, while the type layout must be known statically to compute the intended C ABI,\nthe static parameters of the function are considered to be part of this static environment.\nThe static parameters of the function may be used as type parameters in the call signature,\nas long as they don't affect the layout of the type.\nFor example, `f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)`\nis valid, since `Ptr` is always a word-size primitive type.\nBut, `g(x::T) where {T} = ccall(:notvalid, T, (T,), x)`\nis not valid, since the type layout of `T` is not known statically.\n\n### SIMD Values\n\nNote: This feature is currently implemented on 64-bit x86 and AArch64 platforms only.\n\nIf a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding\nJulia type is a homogeneous tuple of `VecElement` that naturally maps to the SIMD type.  Specifically:\n\n>   * The tuple must be the same size as the SIMD type. For example, a tuple representing an `__m128`\n>     on x86 must have a size of 16 bytes.\n>   * The element type of the tuple must be an instance of `VecElement{T}` where `T` is a primitive type that\n>     is 1, 2, 4 or 8 bytes.\n\nFor instance, consider this C routine that uses AVX intrinsics:\n\n```c\n#include <immintrin.h>\n\n__m256 dist( __m256 a, __m256 b ) {\n    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),\n                                        _mm256_mul_ps(b, b)));\n}\n```\n\nThe following Julia code calls `dist` using `ccall`:\n\n```julia\nconst m256 = NTuple{8, VecElement{Float32}}\n\na = m256(ntuple(i -> VecElement(sin(Float32(i))), 8))\nb = m256(ntuple(i -> VecElement(cos(Float32(i))), 8))\n\nfunction call_dist(a::m256, b::m256)\n    ccall((:dist, \"libdist\"), m256, (m256, m256), a, b)\nend\n\nprintln(call_dist(a,b))\n```\n\nThe host machine must have the requisite SIMD registers.  For example, the code above will not\nwork on hosts without AVX support.\n\n### Memory Ownership\n\n**malloc/free**\n\nMemory allocation and deallocation of such objects must be handled by calls to the appropriate\ncleanup routines in the libraries being used, just like in any C program. Do not try to free an\nobject received from a C library with [`Libc.free`](@ref) in Julia, as this may result in the `free` function\nbeing called via the wrong library and cause the process to abort. The reverse (passing an object\nallocated in Julia to be freed by an external library) is equally invalid.\n\n### When to use T, Ptr{T} and Ref{T}\n\nIn Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared\nto be of type `T` inside the [`ccall`](@ref), as they are passed by value.  For C code accepting\npointers, [`Ref{T}`](@ref) should generally be used for the types of input arguments, allowing the use\nof pointers to memory managed by either Julia or C through the implicit call to [`Base.cconvert`](@ref).\nIn contrast, pointers returned by the C function called should be declared to be of output type\n[`Ptr{T}`](@ref), reflecting that the memory pointed to is managed by C only. Pointers contained in C\nstructs should be represented as fields of type `Ptr{T}` within the corresponding Julia struct\ntypes designed to mimic the internal structure of corresponding C structs.\n\nIn Julia code wrapping calls to external Fortran routines, all input arguments\nshould be declared as of type `Ref{T}`, as Fortran passes all variables by\npointers to memory locations. The return type should either be `Cvoid` for\nFortran subroutines, or a `T` for Fortran functions returning the type `T`.\n\n## Mapping C Functions to Julia\n\n### `ccall` / `@cfunction` argument translation guide\n\nFor translating a C argument list to Julia:\n\n  * `T`, where `T` is one of the primitive types: `char`, `int`, `long`, `short`, `float`, `double`,\n    `complex`, `enum` or any of their `typedef` equivalents\n\n      * `T`, where `T` is an equivalent Julia Bits Type (per the table above)\n      * if `T` is an `enum`, the argument type should be equivalent to `Cint` or `Cuint`\n      * argument value will be copied (passed by value)\n  * `struct T` (including typedef to a struct)\n\n      * `T`, where `T` is a Julia leaf type\n      * argument value will be copied (passed by value)\n  * `void*`\n\n      * depends on how this parameter is used, first translate this to the intended pointer type, then\n        determine the Julia equivalent using the remaining rules in this list\n      * this argument may be declared as `Ptr{Cvoid}`, if it really is just an unknown pointer\n  * `jl_value_t*`\n\n      * `Any`\n      * argument value must be a valid Julia object\n  * `jl_value_t* const*`\n\n      * `Ref{Any}`\n      * argument list must be a valid Julia object (or `C_NULL`)\n      * cannot be used for an output parameter, unless the user is able to\n        manage to separate arrange for the object to be GC-preserved\n  * `T*`\n\n      * `Ref{T}`, where `T` is the Julia type corresponding to `T`\n      * argument value will be copied if it is an `inlinealloc` type (which\n        includes `isbits` otherwise, the value must be a valid Julia object\n  * `T (*)(...)` (e.g. a pointer to a function)\n\n      * `Ptr{Cvoid}` (you may need to use [`@cfunction`](@ref) explicitly to\n        create this pointer)\n  * `...` (e.g. a vararg)\n\n      * [for `ccall`]: `T...`, where `T` is the single Julia type of all\n        remaining arguments\n      * [for `@ccall`]: `; va_arg1::T, va_arg2::S, etc`, where `T` and `S` are\n        the Julia type (i.e. separate the regular arguments from varargs with\n        a `;`)\n      * currently unsupported by `@cfunction`\n  * `va_arg`\n\n      * not supported by `ccall` or `@cfunction`\n\n### `ccall` / `@cfunction` return type translation guide\n\nFor translating a C return type to Julia:\n\n  * `void`\n\n      * `Cvoid` (this will return the singleton instance `nothing::Cvoid`)\n  * `T`, where `T` is one of the primitive types: `char`, `int`, `long`, `short`, `float`, `double`,\n    `complex`, `enum` or any of their `typedef` equivalents\n\n      * `T`, where `T` is an equivalent Julia Bits Type (per the table above)\n      * if `T` is an `enum`, the argument type should be equivalent to `Cint` or `Cuint`\n      * argument value will be copied (returned by-value)\n  * `struct T` (including typedef to a struct)\n\n      * `T`, where `T` is a Julia Leaf Type\n      * argument value will be copied (returned by-value)\n  * `void*`\n\n      * depends on how this parameter is used, first translate this to the intended pointer type, then\n        determine the Julia equivalent using the remaining rules in this list\n      * this argument may be declared as `Ptr{Cvoid}`, if it really is just an unknown pointer\n  * `jl_value_t*`\n\n      * `Any`\n      * argument value must be a valid Julia object\n  * `jl_value_t**`\n\n      * `Ptr{Any}` (`Ref{Any}` is invalid as a return type)\n  * `T*`\n\n      * If the memory is already owned by Julia, or is an `isbits` type, and is known to be non-null:\n\n          * `Ref{T}`, where `T` is the Julia type corresponding to `T`\n          * a return type of `Ref{Any}` is invalid, it should either be `Any` (corresponding to\n            `jl_value_t*`) or `Ptr{Any}` (corresponding to `jl_value_t**`)\n          * C **MUST NOT** modify the memory returned via `Ref{T}` if `T` is an `isbits` type\n      * If the memory is owned by C:\n\n          * `Ptr{T}`, where `T` is the Julia type corresponding to `T`\n  * `T (*)(...)` (e.g. a pointer to a function)\n\n      * `Ptr{Cvoid}` (you may need to use [`@cfunction`](@ref) explicitly to create this pointer)\n\n### Passing Pointers for Modifying Inputs\n\nBecause C doesn't support multiple return values, often C functions will take pointers to data\nthat the function will modify. To accomplish this within a [`ccall`](@ref), you need to first\nencapsulate the value inside a [`Ref{T}`](@ref) of the appropriate type. When you pass this `Ref` object\nas an argument, Julia will automatically pass a C pointer to the encapsulated data:\n\n```julia\nwidth = Ref{Cint}(0)\nrange = Ref{Cfloat}(0)\nccall(:foo, Cvoid, (Ref{Cint}, Ref{Cfloat}), width, range)\n```\n\nUpon return, the contents of `width` and `range` can be retrieved (if they were changed by `foo`)\nby `width[]` and `range[]`; that is, they act like zero-dimensional arrays.\n\n## C Wrapper Examples\n\nLet's start with a simple example of a C wrapper that returns a `Ptr` type:\n\n```julia\nmutable struct gsl_permutation\nend\n\n# The corresponding C signature is\n#     gsl_permutation * gsl_permutation_alloc (size_t n);\nfunction permutation_alloc(n::Integer)\n    output_ptr = ccall(\n        (:gsl_permutation_alloc, :libgsl), # name of C function and library\n        Ptr{gsl_permutation},              # output type\n        (Csize_t,),                        # tuple of input types\n        n                                  # name of Julia variable to pass in\n    )\n    if output_ptr == C_NULL # Could not allocate memory\n        throw(OutOfMemoryError())\n    end\n    return output_ptr\nend\n```\n\nThe [GNU Scientific Library](https://www.gnu.org/software/gsl/) (here assumed to be accessible\nthrough `:libgsl`) defines an opaque pointer, `gsl_permutation *`, as the return type of the C\nfunction `gsl_permutation_alloc`. As user code never has to look inside the `gsl_permutation`\nstruct, the corresponding Julia wrapper simply needs a new type declaration, `gsl_permutation`,\nthat has no internal fields and whose sole purpose is to be placed in the type parameter of a\n`Ptr` type.  The return type of the [`ccall`](@ref) is declared as `Ptr{gsl_permutation}`, since\nthe memory allocated and pointed to by `output_ptr` is controlled by C.\n\nThe input `n` is passed by value, and so the function's input signature is\nsimply declared as `(Csize_t,)` without any `Ref` or `Ptr` necessary. (If the\nwrapper was calling a Fortran function instead, the corresponding function input\nsignature would instead be `(Ref{Csize_t},)`, since Fortran variables are\npassed by pointers.) Furthermore, `n` can be any type that is convertible to a\n`Csize_t` integer; the [`ccall`](@ref) implicitly calls [`Base.cconvert(Csize_t,\nn)`](@ref).\n\nHere is a second example wrapping the corresponding destructor:\n\n```julia\n# The corresponding C signature is\n#     void gsl_permutation_free (gsl_permutation * p);\nfunction permutation_free(p::Ref{gsl_permutation})\n    ccall(\n        (:gsl_permutation_free, :libgsl), # name of C function and library\n        Cvoid,                             # output type\n        (Ref{gsl_permutation},),          # tuple of input types\n        p                                 # name of Julia variable to pass in\n    )\nend\n```\n\nHere, the input `p` is declared to be of type `Ref{gsl_permutation}`, meaning that the memory\nthat `p` points to may be managed by Julia or by C. A pointer to memory allocated by C should\nbe of type `Ptr{gsl_permutation}`, but it is convertible using [`Base.cconvert`](@ref) and therefore\n\nNow if you look closely enough at this example, you may notice that it is incorrect, given our explanation\nabove of preferred declaration types. Do you see it? The function we are calling is going to free the\nmemory. This type of operation cannot be given a Julia object (it will crash or cause memory corruption).\nTherefore, it may be preferable to declare the `p` type as `Ptr{gsl_permutation }`, to make it harder for the\nuser to mistakenly pass another sort of object there than one obtained via `gsl_permutation_alloc`.\n\nIf the C wrapper never expects the user to pass pointers to memory managed by Julia, then using\n`p::Ptr{gsl_permutation}` for the method signature of the wrapper and similarly in the [`ccall`](@ref)\nis also acceptable.\n\nHere is a third example passing Julia arrays:\n\n```julia\n# The corresponding C signature is\n#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,\n#                                double result_array[])\nfunction sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)\n    if nmax < nmin\n        throw(DomainError())\n    end\n    result_array = Vector{Cdouble}(undef, nmax - nmin + 1)\n    errorcode = ccall(\n        (:gsl_sf_bessel_Jn_array, :libgsl), # name of C function and library\n        Cint,                               # output type\n        (Cint, Cint, Cdouble, Ref{Cdouble}),# tuple of input types\n        nmin, nmax, x, result_array         # names of Julia variables to pass in\n    )\n    if errorcode != 0\n        error(\"GSL error code $errorcode\")\n    end\n    return result_array\nend\n```\n\nThe C function wrapped returns an integer error code; the results of the actual evaluation of\nthe Bessel J function populate the Julia array `result_array`. This variable is declared as a\n`Ref{Cdouble}`, since its memory is allocated and managed by Julia. The implicit call to\n[`Base.cconvert(Ref{Cdouble}, result_array)`](@ref) unpacks\nthe Julia pointer to a Julia array data structure into a form understandable by C.\n\n## Fortran Wrapper Example\n\nThe following example utilizes ccall to call a function in a common Fortran library (libBLAS) to\ncomputes a dot product. Notice that the argument mapping is a bit different here than above, as\nwe need to map from Julia to Fortran.  On every argument type, we specify `Ref` or `Ptr`. This\nmangling convention may be specific to your fortran compiler and operating system, and is likely\nundocumented. However, wrapping each in a `Ref` (or `Ptr`, where equivalent) is a frequent\nrequirement of Fortran compiler implementations:\n\n```julia\nfunction compute_dot(DX::Vector{Float64}, DY::Vector{Float64})\n    @assert length(DX) == length(DY)\n    n = length(DX)\n    incx = incy = 1\n    product = ccall((:ddot_, \"libLAPACK\"),\n                    Float64,\n                    (Ref{Int32}, Ptr{Float64}, Ref{Int32}, Ptr{Float64}, Ref{Int32}),\n                    n, DX, incx, DY, incy)\n    return product\nend\n```\n\n\n## Garbage Collection Safety\n\nWhen passing data to a [`ccall`](@ref), it is best to avoid using the [`pointer`](@ref) function.\nInstead define a convert method and pass the variables directly to the [`ccall`](@ref). [`ccall`](@ref)\nautomatically arranges that all of its arguments will be preserved from garbage collection until\nthe call returns. If a C API will store a reference to memory allocated by Julia, after the [`ccall`](@ref)\nreturns, you must ensure that the object remains visible to the garbage collector. The suggested\nway to do this is to make a global variable of type `Array{Ref,1}` to hold these values, until\nthe C library notifies you that it is finished with them.\n\nWhenever you have created a pointer to Julia data, you must ensure the original data exists until\nyou have finished using the pointer. Many methods in Julia such as [`unsafe_load`](@ref) and\n[`String`](@ref) make copies of data instead of taking ownership of the buffer, so that it is\nsafe to free (or alter) the original data without affecting Julia. A notable exception is\n[`unsafe_wrap`](@ref) which, for performance reasons, shares (or can be told to take ownership of) the\nunderlying buffer.\n\nThe garbage collector does not guarantee any order of finalization. That is, if `a` contained\na reference to `b` and both `a` and `b` are due for garbage collection, there is no guarantee\nthat `b` would be finalized after `a`. If proper finalization of `a` depends on `b` being valid,\nit must be handled in other ways.\n\n## Non-constant Function Specifications\n\nIn some cases, the exact name or path of the needed library is not known in advance and must\nbe computed at run time. To handle such cases, the library component of a `(name, library)`\nspecification can be a function call, e.g. `(:dgemm_, find_blas())`. The call expression will\nbe executed when the `ccall` itself is executed. However, it is assumed that the library\nlocation does not change once it is determined, so the result of the call can be cached and\nreused. Therefore, the number of times the expression executes is unspecified, and returning\ndifferent values for multiple calls results in unspecified behavior.\n\nIf even more flexibility is needed, it is possible\nto use computed values as function names by staging through [`eval`](@ref) as follows:\n\n```\n@eval ccall(($(string(\"a\", \"b\")), \"lib\"), ...\n```\n\nThis expression constructs a name using `string`, then substitutes this name into a new [`ccall`](@ref)\nexpression, which is then evaluated. Keep in mind that `eval` only operates at the top level,\nso within this expression local variables will not be available (unless their values are substituted\nwith `$`). For this reason, `eval` is typically only used to form top-level definitions, for example\nwhen wrapping libraries that contain many similar functions.\nA similar example can be constructed for [`@cfunction`](@ref).\n\nHowever, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep\nreading.\nThe next section discusses how to use indirect calls to efficiently achieve a similar effect.\n\n## Indirect Calls\n\nThe first argument to [`ccall`](@ref) can also be an expression evaluated at run time. In this\ncase, the expression must evaluate to a `Ptr`, which will be used as the address of the native\nfunction to call. This behavior occurs when the first [`ccall`](@ref) argument contains references\nto non-constants, such as local variables, function arguments, or non-constant globals.\n\nFor example, you might look up the function via `dlsym`,\nthen cache it in a shared reference for that session. For example:\n\n```julia\nmacro dlsym(func, lib)\n    z = Ref{Ptr{Cvoid}}(C_NULL)\n    quote\n        let zlocal = $z[]\n            if zlocal == C_NULL\n                zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}\n                $z[] = $zlocal\n            end\n            zlocal\n        end\n    end\nend\n\nmylibvar = Libdl.dlopen(\"mylib\")\nccall(@dlsym(\"myfunc\", mylibvar), Cvoid, ())\n```\n\n## Closure cfunctions\n\nThe first argument to [`@cfunction`](@ref) can be marked with a `$`, in which case\nthe return value will instead be a `struct CFunction` which closes over the argument.\nYou must ensure that this return object is kept alive until all uses of it are done.\nThe contents and code at the cfunction pointer will be erased via a [`finalizer`](@ref)\nwhen this reference is dropped and atexit. This is not usually needed, since this\nfunctionality is not present in C, but can be useful for dealing with ill-designed APIs\nwhich don't provide a separate closure environment parameter.\n\n```julia\nfunction qsort(a::Vector{T}, cmp) where T\n    isbits(T) || throw(ArgumentError(\"this method can only qsort isbits arrays\"))\n    callback = @cfunction $cmp Cint (Ref{T}, Ref{T})\n    # Here, `callback` isa Base.CFunction, which will be converted to Ptr{Cvoid}\n    # (and protected against finalization) by the ccall\n    ccall(:qsort, Cvoid, (Ptr{T}, Csize_t, Csize_t, Ptr{Cvoid}),\n        a, length(a), Base.elsize(a), callback)\n    # We could instead use:\n    #    GC.@preserve callback begin\n    #        use(Base.unsafe_convert(Ptr{Cvoid}, callback))\n    #    end\n    # if we needed to use it outside of a `ccall`\n    return a\nend\n```\n\n!!! note\n    Closure [`@cfunction`](@ref) rely on LLVM trampolines, which are not available on all\n    platforms (for example ARM and PowerPC).\n\n\n## Closing a Library\n\nIt is sometimes useful to close (unload) a library so that it can be reloaded.\nFor instance, when developing C code for use with Julia, one may need to compile,\ncall the C code from Julia, then close the library, make an edit, recompile,\nand load in the new changes. One can either restart Julia or use the\n`Libdl` functions to manage the library explicitly, such as:\n\n```julia\nlib = Libdl.dlopen(\"./my_lib.so\") # Open the library explicitly.\nsym = Libdl.dlsym(lib, :my_fcn)   # Get a symbol for the function to call.\nccall(sym, ...) # Use the pointer `sym` instead of the (symbol, library) tuple (remaining arguments are the same).\nLibdl.dlclose(lib) # Close the library explicitly.\n```\n\nNote that when using `ccall` with the tuple input\n(e.g., `ccall((:my_fcn, \"./my_lib.so\"), ...)`), the library is opened implicitly\nand it may not be explicitly closed.\n\n## Calling Convention\n\nThe second argument to [`ccall`](@ref) can optionally be a calling convention specifier (immediately\npreceding return type). Without any specifier, the platform-default C calling convention is used.\nOther supported conventions are: `stdcall`, `cdecl`, `fastcall`, and `thiscall` (no-op on 64-bit Windows).\nFor example (from `base/libc.jl`) we see the same `gethostname`[`ccall`](@ref) as above, but with the correct\nsignature for Windows:\n\n```julia\nhn = Vector{UInt8}(undef, 256)\nerr = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))\n```\n\nFor more information, please see the [LLVM Language Reference](http://llvm.org/docs/LangRef.html#calling-conventions).\n\nThere is one additional special calling convention [`llvmcall`](@ref Base.llvmcall),\nwhich allows inserting calls to LLVM intrinsics directly.\nThis can be especially useful when targeting unusual platforms such as GPGPUs.\nFor example, for [CUDA](http://llvm.org/docs/NVPTXUsage.html), we need to be able to read the thread index:\n\n```julia\nccall(\"llvm.nvvm.read.ptx.sreg.tid.x\", llvmcall, Int32, ())\n```\n\nAs with any `ccall`, it is essential to get the argument signature exactly correct.\nAlso, note that there is no compatibility layer that ensures the intrinsic makes\nsense and works on the current target,\nunlike the equivalent Julia functions exposed by `Core.Intrinsics`.\n\n## Accessing Global Variables\n\nGlobal variables exported by native libraries can be accessed by name using the [`cglobal`](@ref)\nfunction. The arguments to [`cglobal`](@ref) are a symbol specification identical to that used\nby [`ccall`](@ref), and a type describing the value stored in the variable:\n\n```julia-repl\njulia> cglobal((:errno, :libc), Int32)\nPtr{Int32} @0x00007f418d0816b8\n```\n\nThe result is a pointer giving the address of the value. The value can be manipulated through\nthis pointer using [`unsafe_load`](@ref) and [`unsafe_store!`](@ref).\n\n!!! note\n    This `errno` symbol may not be found in a library named \"libc\", as this is an implementation detail of\n    your system compiler. Typically standard library symbols should be accessed just by name,\n    allowing the compiler to fill in the correct one.\n    Also, however, the `errno` symbol shown in this example is special in most compilers, and so the value\n    seen here is probably not what you expect or want. Compiling the equivalent code in C on any\n    multi-threaded-capable system would typically actually call a different function (via macro preprocessor\n    overloading), and may give a different result than the legacy value printed here.\n\n## Accessing Data through a Pointer\n\nThe following methods are described as \"unsafe\" because a bad pointer or type declaration can\ncause Julia to terminate abruptly.\n\nGiven a `Ptr{T}`, the contents of type `T` can generally be copied from the referenced memory\ninto a Julia object using `unsafe_load(ptr, [index])`. The index argument is optional (default\nis 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar\nto the behavior of [`getindex`](@ref) and [`setindex!`](@ref) (e.g. `[]` access syntax).\n\nThe return value will be a new object initialized to contain a copy of the contents of the referenced\nmemory. The referenced memory can safely be freed or released.\n\nIf `T` is `Any`, then the memory is assumed to contain a reference to a Julia object (a `jl_value_t*`),\nthe result will be a reference to this object, and the object will not be copied. You must be\ncareful in this case to ensure that the object was always visible to the garbage collector (pointers\ndo not count, but the new reference does) to ensure the memory is not prematurely freed. Note\nthat if the object was not originally allocated by Julia, the new object will never be finalized\nby Julia's garbage collector.  If the `Ptr` itself is actually a `jl_value_t*`, it can be converted\nback to a Julia object reference by [`unsafe_pointer_to_objref(ptr)`](@ref). (Julia values `v`\ncan be converted to `jl_value_t*` pointers, as `Ptr{Cvoid}`, by calling [`pointer_from_objref(v)`](@ref).)\n\nThe reverse operation (writing data to a `Ptr{T}`), can be performed using [`unsafe_store!(ptr, value, [index])`](@ref).\nCurrently, this is only supported for primitive types or other pointer-free (`isbits`) immutable struct\ntypes.\n\nAny operation that throws an error is probably currently unimplemented and should be posted as\na bug so that it can be resolved.\n\nIf the pointer of interest is a plain-data array (primitive type or immutable struct), the function\n[`unsafe_wrap(Array, ptr,dims, own = false)`](@ref)\nmay be more useful. The final parameter should be true if Julia should \"take ownership\" of the\nunderlying buffer and call `free(ptr)` when the returned `Array` object is finalized.  If the\n`own` parameter is omitted or false, the caller must ensure the buffer remains in existence until\nall access is complete.\n\nArithmetic on the `Ptr` type in Julia (e.g. using `+`) does not behave the same as C's pointer\narithmetic. Adding an integer to a `Ptr` in Julia always moves the pointer by some number of\n*bytes*, not elements. This way, the address values obtained from pointer arithmetic do not depend\non the element types of pointers.\n\n## Thread-safety\n\nSome C libraries execute their callbacks from a different thread, and since Julia isn't thread-safe\nyou'll need to take some extra precautions. In particular, you'll need to set up a two-layered\nsystem: the C callback should only *schedule* (via Julia's event loop) the execution of your \"real\"\ncallback. To do this, create an [`AsyncCondition`](@ref Base.AsyncCondition) object and [`wait`](@ref) on it:\n\n```julia\ncond = Base.AsyncCondition()\nwait(cond)\n```\n\nThe callback you pass to C should only execute a [`ccall`](@ref) to `:uv_async_send`, passing\n`cond.handle` as the argument, taking care to avoid any allocations or other interactions with the\nJulia runtime.\n\nNote that events may be coalesced, so multiple calls to `uv_async_send` may result in a single wakeup\nnotification to the condition.\n\n## More About Callbacks\n\nFor more details on how to pass callbacks to C libraries, see this [blog post](https://julialang.org/blog/2013/05/callback).\n\n## C++\n\nFor direct C++ interfacing, see the [Cxx](https://github.com/Keno/Cxx.jl) package. For tools to create C++\nbindings, see the [CxxWrap](https://github.com/JuliaInterop/CxxWrap.jl) package.\n\n\n\n[^1]: Non-library function calls in both C and Julia can be inlined and thus may have\n    even less overhead than calls to shared library functions.\n    The point above is that the cost of actually doing foreign function call is about the same as doing a call in either native language.\n\n[^2]: The [Clang package](https://github.com/ihnorton/Clang.jl) can be used to auto-generate Julia code\n    from a C header file.\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/.git/objects/pack/pack-d9bbfd9f56ffb1d0d9a5cb51790f50fb30713aae.idx",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/.git/objects/pack/pack-d9bbfd9f56ffb1d0d9a5cb51790f50fb30713aae.pack",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/windows/julia.ico",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/windows/julia-banner.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/windows/julia-dots.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/app/julia.icns",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/installresources/logo_hires.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/julia.idraw",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/512.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/256@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/128@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/16@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/32.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/512@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/256.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/128.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/16.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/contrib/mac/frameworkapp/JuliaLauncher/Assets.xcassets/AppIcon.appiconset/32@2x.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-master-ixx76ns55myup264xb4zzfifr2lgdkvi/spack-src/doc/src/assets/julia.ico"
    ],
    "total_files": 1634
}