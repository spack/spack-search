{
    "matches": {
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/test/libdl.jl": "# This file is a part of Julia. License is MIT: http://julialang.org/license\n\n# these could fail on an embedded installation\n# but for now, we don't handle that case\ndlls = Libdl.dllist()\n@test !isempty(dlls)\n@test length(dlls) > 3 # at a bare minimum, probably have some version of libstdc, libgcc, libjulia, ...\nif !is_windows() || Sys.windows_version() >= Sys.WINDOWS_VISTA_VER\n    for dl in dlls\n        if isfile(dl) && (Libdl.dlopen_e(dl) != C_NULL)\n            @test Base.samefile(Libdl.dlpath(dl), dl)\n        end\n    end\nend\n@test length(filter(dlls) do dl\n        return ismatch(Regex(\"^libjulia(?:.*)\\.$(Libdl.dlext)(?:\\..+)?\\$\"), basename(dl))\n    end) == 1 # look for something libjulia-like (but only one)\n\n# library handle pointer must not be NULL\n@test_throws ArgumentError Libdl.dlsym(C_NULL, :foo)\n@test_throws ArgumentError Libdl.dlsym_e(C_NULL, :foo)\n\ncd(dirname(@__FILE__)) do\n\n# Find the library directory by finding the path of libjulia (or libjulia-debug, as the case may be)\n# and then adding on /julia to that directory path to get the private library directory, if we need\n# to (where \"need to\" is defined as private_libdir/julia/libccalltest.dlext exists\nprivate_libdir = if ccall(:jl_is_debugbuild, Cint, ()) != 0\n    dirname(abspath(Libdl.dlpath(\"libjulia-debug\")))\nelse\n    dirname(abspath(Libdl.dlpath(\"libjulia\")))\nend\n\nif isfile(joinpath(private_libdir,\"julia\",\"libccalltest.\"*Libdl.dlext))\n    private_libdir = joinpath(private_libdir, \"julia\")\nend\n\n@test !isempty(Libdl.find_library([\"libccalltest\"], [private_libdir]))\n@test !isempty(Libdl.find_library(\"libccalltest\", [private_libdir]))\n@test !isempty(Libdl.find_library(:libccalltest, [private_libdir]))\n\n# dlopen should be able to handle absolute and relative paths, with and without dlext\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(abspath(joinpath(private_libdir, \"libccalltest\")))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(abspath(joinpath(private_libdir, \"libccalltest.$(Libdl.dlext)\")))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(relpath(joinpath(private_libdir, \"libccalltest\")))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(relpath(joinpath(private_libdir, \"libccalltest.$(Libdl.dlext)\")))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(\"./foo\")\n        @test dl == C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# unqualified names present in DL_LOAD_PATH\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(\"libccalltest\")\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(string(\"libccalltest\",\".\",Libdl.dlext))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# path with dlopen-able file first in load path\n#=\nlet dl = C_NULL,\n    tmpdir = mktempdir(),\n    fpath = joinpath(tmpdir,\"libccalltest\")\n    try\n        write(open(fpath,\"w\"))\n        push!(Libdl.DL_LOAD_PATH, dirname(@__FILE__))\n        push!(Libdl.DL_LOAD_PATH, dirname(fpath))\n        dl = Libdl.dlopen_e(\"libccalltest\")\n        @test dl != C_NULL\n    finally\n        pop!(Libdl.DL_LOAD_PATH)\n        pop!(Libdl.DL_LOAD_PATH)\n        rm(tmpdir, recursive=true)\n    end\nend\n=#\n\n# path with dlopen-able file second in load path\n#=\nlet dl = C_NULL,\n    tmpdir = mktempdir(),\n    fpath = joinpath(tmpdir,\"libccalltest\")\n    try\n        write(open(fpath,\"w\"))\n        push!(Libdl.DL_LOAD_PATH, dirname(fpath))\n        push!(Libdl.DL_LOAD_PATH, dirname(@__FILE__))\n        dl = Libdl.dlopen_e(\"libccalltest\")\n        @test dl != C_NULL\n    finally\n        pop!(Libdl.DL_LOAD_PATH)\n        pop!(Libdl.DL_LOAD_PATH)\n        rm(tmpdir, recursive=true)\n    end\nend\n=#\n\n# test dlpath\nlet dl = C_NULL\n    try\n        path = abspath(joinpath(private_libdir, \"libccalltest\"))\n        dl = Libdl.dlopen(path)\n        @test dl != C_NULL\n        @test Base.samefile(abspath(Libdl.dlpath(dl)),\n                            abspath(Libdl.dlpath(path)))\n        @test Base.samefile(abspath(Libdl.dlpath(dl)),\n                            string(path,\".\",Libdl.dlext))\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# opening a library that does not exist throws an ErrorException\n@test_throws ErrorException Libdl.dlopen(\"./foo\")\n\n# test dlsym\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(abspath(joinpath(private_libdir, \"libccalltest\")))\n        fptr = Libdl.dlsym(dl, :set_verbose)\n        @test fptr != C_NULL\n        @test_throws ErrorException Libdl.dlsym(dl, :foo)\n\n        fptr = Libdl.dlsym_e(dl, :set_verbose)\n        @test fptr != C_NULL\n        fptr = Libdl.dlsym_e(dl, :foo)\n        @test fptr == C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nif Sys.KERNEL in (:Linux, :FreeBSD)\n    ccall(:jl_read_sonames, Void, ())\nend\n\nend\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/test/ccall.jl": "# This file is a part of Julia. License is MIT: http://julialang.org/license\n\nimport Base.copy, Base.==\n\nconst libccalltest = \"libccalltest\"\n\nconst verbose = false\nccall((:set_verbose, libccalltest), Void, (Int32,), verbose)\n\n\n# Test for proper argument register truncation\nccall_test_func(x) = ccall((:testUcharX, libccalltest), Int32, (UInt8,), x % UInt8)\n@test ccall_test_func(3) == 1\n@test ccall_test_func(259) == 1\n\n\n# Test for proper round-trip of Ref{T} type\nccall_echo_func{T,U}(x, ::Type{T}, ::Type{U}) = ccall((:test_echo_p, libccalltest), T, (U,), x)\n# Make sure object x is still valid (rooted as argument)\n# when loading the pointer. This works as long as we still keep the argument\n# rooted but might fail if we are smarter about eliminating dead root.\n@noinline ccall_echo_load{T,U}(x, ::Type{T}, ::Type{U}) =\n    unsafe_load(ccall_echo_func(x, T, U))\n@noinline ccall_echo_objref{T,U}(x, ::Type{T}, ::Type{U}) =\n    unsafe_pointer_to_objref(ccall_echo_func(x, Ptr{T}, U))\ntype IntLike\n    x::Int\nend\n@test ccall_echo_load(132, Ptr{Int}, Ref{Int}) === 132\n@test ccall_echo_load(Ref(921), Ptr{Int}, Ref{Int}) === 921\n@test ccall_echo_load(IntLike(993), Ptr{Int}, Ref{IntLike}) === 993\n@test ccall_echo_load(IntLike(881), Ptr{IntLike}, Ref{IntLike}).x === 881\n@test ccall_echo_func(532, Int, Int) === 532\nif Sys.WORD_SIZE == 64\n    # this test is valid only for x86_64 and win64\n    @test ccall_echo_func(164, IntLike, Int).x === 164\nend\n@test ccall_echo_func(IntLike(828), Int, IntLike) === 828\n@test ccall_echo_func(913, Any, Any) === 913\n@test ccall_echo_objref(553, Ptr{Any}, Any) === 553\n@test ccall_echo_func(124, Ref{Int}, Any) === 124\n@test ccall_echo_load(422, Ptr{Any}, Ref{Any}) === 422\n@test ccall_echo_load([383], Ptr{Int}, Ref{Int}) === 383\n@test ccall_echo_load(Ref([144,172],2), Ptr{Int}, Ref{Int}) === 172\n# @test ccall_echo_load(Ref([8],1,1), Ptr{Int}, Ref{Int}) === 8\n\n\n## Tests for passing and returning structs\n\nlet a, ci_ary, x\n    a = 20 + 51im\n\n    x = ccall((:ctest, libccalltest), Complex{Int}, (Complex{Int},), a)\n\n    @test x == a + 1 - 2im\n\n    ci_ary = [a] # Make sure the array is alive during unsafe_load\n    x = unsafe_load(ccall((:cptest, libccalltest), Ptr{Complex{Int}},\n                          (Ptr{Complex{Int}},), ci_ary))\n\n    @test x == a + 1 - 2im\n    @test a == 20 + 51im\n\n    x = ccall((:cptest_static, libccalltest), Ptr{Complex{Int}}, (Ptr{Complex{Int}},), &a)\n    @test unsafe_load(x) == a\n    Libc.free(convert(Ptr{Void},x))\nend\n\nlet a, b, x\n    a = 2.84 + 5.2im\n\n    x = ccall((:cgtest, libccalltest), Complex128, (Complex128,), a)\n\n    @test x == a + 1 - 2im\n\n    b = [a] # Make sure the array is alive during unsafe_load\n    x = unsafe_load(ccall((:cgptest, libccalltest), Ptr{Complex128}, (Ptr{Complex128},), b))\n\n    @test x == a + 1 - 2im\n    @test a == 2.84 + 5.2im\nend\n\nlet a, b, x\n    a = 3.34f0 + 53.2f0im\n\n    x = ccall((:cftest, libccalltest), Complex64, (Complex64,), a)\n\n    @test x == a + 1 - 2im\n\n    b = [a] # Make sure the array is alive during unsafe_load\n    x = unsafe_load(ccall((:cfptest, libccalltest), Ptr{Complex64}, (Ptr{Complex64},), b))\n\n    @test x == a + 1 - 2im\n    @test a == 3.34f0 + 53.2f0im\nend\n\n\n## Tests for native Julia data types\n\nlet a\n    a = 2.84 + 5.2im\n\n    @test_throws MethodError ccall((:cptest, libccalltest), Ptr{Complex{Int}}, (Ptr{Complex{Int}},), a)\n    @test_throws MethodError ccall((:cptest, libccalltest), Ptr{Complex{Int}}, (Complex{Int},), &a)\nend\n\n\n## Tests for various sized data types (ByVal)\n\ntype Struct1\n    x::Float32\n    y::Float64\nend\nimmutable Struct1I\n    x::Float32\n    y::Float64\nend\ncopy(a::Struct1) = Struct1(a.x, a.y)\ncopy(a::Struct1I) = a\n\nfunction test_struct1{Struct}(::Type{Struct})\n    a = Struct(352.39422f23, 19.287577)\n    b = Float32(123.456)\n\n    a2 = copy(a)\n    x = ccall((:test_1, libccalltest), Struct, (Struct, Float32), a2, b)\n\n    @test a2.x == a.x && a2.y == a.y\n    @test !(a2 === x)\n\n    @test x.x \u2248 a.x + 1*b\n    @test x.y \u2248 a.y - 2*b\nend\ntest_struct1(Struct1)\ntest_struct1(Struct1I)\n\nlet a, b, x, y\n    a = Complex{Int32}(Int32(10),Int32(31))\n    b = Int32(42)\n\n    x = ccall((:test_2a, libccalltest), Complex{Int32}, (Complex{Int32}, Int32), a, b)\n    y = ccall((:test_2b, libccalltest), Complex{Int32}, (Complex{Int32},Int32), a, b)\n\n    @test a == Complex{Int32}(Int32(10),Int32(31))\n\n    @test x == y\n    @test x == a + b*1 - b*2im\nend\n\nlet a, b, x, y, z\n    a = Complex{Int64}(Int64(20),Int64(51))\n    b = Int64(42)\n\n    x = ccall((:test_3a, libccalltest), Complex{Int64}, (Complex{Int64}, Int64), a, b)\n    y = ccall((:test_3b, libccalltest), Complex{Int64}, (Complex{Int64}, Int64), a, b)\n    z = ccall((:test_128, libccalltest), Complex{Int64}, (Complex{Int64}, Int64), a, b)\n\n    @test a == Complex{Int64}(Int64(20),Int64(51))\n\n    @test x == y\n    @test x == a + b*1 - b*2im\n\n    @test z == a + 1*b\nend\n\ntype Struct4\n    x::Int32\n    y::Int32\n    z::Int32\nend\nimmutable Struct4I\n    x::Int32\n    y::Int32\n    z::Int32\nend\n\nfunction test_struct4{Struct}(::Type{Struct})\n    a = Struct(-512275808,882558299,-2133022131)\n    b = Int32(42)\n\n    x = ccall((:test_4, libccalltest), Struct, (Struct, Int32), a, b)\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\nend\ntest_struct4(Struct4)\ntest_struct4(Struct4I)\n\ntype Struct5\n    x::Int32\n    y::Int32\n    z::Int32\n    a::Int32\nend\nimmutable Struct5I\n    x::Int32\n    y::Int32\n    z::Int32\n    a::Int32\nend\n\nfunction test_struct5{Struct}(::Type{Struct})\n    a = Struct(1771319039, 406394736, -1269509787, -745020976)\n    b = Int32(42)\n\n    x = ccall((:test_5, libccalltest), Struct, (Struct, Int32), a, b)\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\n    @test x.a == a.a-b*4\nend\ntest_struct5(Struct5)\ntest_struct5(Struct5I)\n\ntype Struct6\n    x::Int64\n    y::Int64\n    z::Int64\nend\nimmutable Struct6I\n    x::Int64\n    y::Int64\n    z::Int64\nend\n\nfunction test_struct6{Struct}(::Type{Struct})\n    a = Struct(-654017936452753226, -5573248801240918230, -983717165097205098)\n    b = Int64(42)\n\n    x = ccall((:test_6, libccalltest), Struct, (Struct, Int64), a, b)\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\nend\ntest_struct6(Struct6)\ntest_struct6(Struct6I)\n\ntype Struct7\n    x::Int64\n    y::Cchar\nend\nimmutable Struct7I\n    x::Int64\n    y::Cchar\nend\n\nfunction test_struct7{Struct}(::Type{Struct})\n    a = Struct(-384082741977533896, 'h')\n    b = Int8(42)\n\n    x = ccall((:test_7, libccalltest), Struct, (Struct, Int8), a, b)\n\n    @test x.x == a.x+Int(b)*1\n    @test x.y == a.y-Int(b)*2\nend\ntest_struct7(Struct7)\ntest_struct7(Struct7I)\n\ntype Struct8\n    x::Int32\n    y::Cchar\nend\nimmutable Struct8I\n    x::Int32\n    y::Cchar\nend\n\nfunction test_struct8{Struct}(::Type{Struct})\n    a = Struct(-384082896, 'h')\n    b = Int8(42)\n\n    r8 = ccall((:test_8, libccalltest), Struct, (Struct, Int8), a, b)\n\n    @test r8.x == a.x+b*1\n    @test r8.y == a.y-b*2\nend\ntest_struct8(Struct8)\ntest_struct8(Struct8I)\n\ntype Struct9\n    x::Int32\n    y::Int16\nend\nimmutable Struct9I\n    x::Int32\n    y::Int16\nend\n\nfunction test_struct9{Struct}(::Type{Struct})\n    a = Struct(-394092996, -3840)\n    b = Int16(42)\n\n    x = ccall((:test_9, libccalltest), Struct, (Struct, Int16), a, b)\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\nend\ntest_struct9(Struct9)\ntest_struct9(Struct9I)\n\ntype Struct10\n    x::Cchar\n    y::Cchar\n    z::Cchar\n    a::Cchar\nend\nimmutable Struct10I\n    x::Cchar\n    y::Cchar\n    z::Cchar\n    a::Cchar\nend\n\nfunction test_struct10{Struct}(::Type{Struct})\n    a = Struct('0', '1', '2', '3')\n    b = Int8(2)\n\n    x = ccall((:test_10, libccalltest), Struct, (Struct, Int8), a, b)\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\n    @test x.a == a.a-b*4\nend\ntest_struct10(Struct10)\ntest_struct10(Struct10I)\n\ntype Struct11\n    x::Complex64\nend\nimmutable Struct11I\n    x::Complex64\nend\n\nfunction test_struct11{Struct}(::Type{Struct})\n    a = Struct(0.8877077f0 + 0.4591081f0im)\n    b = Float32(42)\n\n    x = ccall((:test_11, libccalltest), Struct, (Struct, Float32), a, b)\n\n    @test x.x \u2248 a.x + b*1 - b*2im\nend\ntest_struct11(Struct11)\ntest_struct11(Struct11I)\n\ntype Struct12\n    x::Complex64\n    y::Complex64\nend\nimmutable Struct12I\n    x::Complex64\n    y::Complex64\nend\n\nfunction test_struct12{Struct}(::Type{Struct})\n    a = Struct(0.8877077f5 + 0.4591081f2im, 0.0004842868f0 - 6982.3265f3im)\n    b = Float32(42)\n\n    x = ccall((:test_12, libccalltest), Struct, (Struct, Float32), a, b)\n\n    @test x.x \u2248 a.x + b*1 - b*2im\n    @test x.y \u2248 a.y + b*3 - b*4im\nend\ntest_struct12(Struct12)\ntest_struct12(Struct12I)\n\ntype Struct13\n    x::Complex128\nend\nimmutable Struct13I\n    x::Complex128\nend\n\nfunction test_struct13{Struct}(::Type{Struct})\n    a = Struct(42968.97560380495 - 803.0576845153616im)\n    b = Float64(42)\n\n    x = ccall((:test_13, libccalltest), Struct, (Struct, Float64), a, b)\n\n    @test x.x \u2248 a.x + b*1 - b*2im\nend\ntest_struct13(Struct13)\ntest_struct13(Struct13I)\n\ntype Struct14\n    x::Float32\n    y::Float32\nend\nimmutable Struct14I\n    x::Float32\n    y::Float32\nend\n\nfunction test_struct14{Struct}(::Type{Struct})\n    a = Struct(0.024138331f0, 0.89759064f32)\n    b = Float32(42)\n\n    x = ccall((:test_14, libccalltest), Struct, (Struct, Float32), a, b)\n\n    @test x.x \u2248 a.x + b*1\n    @test x.y \u2248 a.y - b*2\nend\ntest_struct14(Struct14)\ntest_struct14(Struct14I)\n\ntype Struct15\n    x::Float64\n    y::Float64\nend\nimmutable Struct15I\n    x::Float64\n    y::Float64\nend\n\nfunction test_struct15{Struct}(::Type{Struct})\n    a = Struct(4.180997967273657, -0.404218594294923)\n    b = Float64(42)\n\n    x = ccall((:test_15, libccalltest), Struct, (Struct, Float64), a, b)\n\n    @test x.x \u2248 a.x + b*1\n    @test x.y \u2248 a.y - b*2\nend\ntest_struct15(Struct15)\ntest_struct15(Struct15I)\n\ntype Struct16\n    x::Float32\n    y::Float32\n    z::Float32\n    a::Float64\n    b::Float64\n    c::Float64\nend\nimmutable Struct16I\n    x::Float32\n    y::Float32\n    z::Float32\n    a::Float64\n    b::Float64\n    c::Float64\nend\n\nfunction test_struct16{Struct}(::Type{Struct})\n    a = Struct(0.1604656f0, 0.6297606f0, 0.83588994f0,\n               0.6460273620993535, 0.9472692581106656, 0.47328535437352093)\n    b = Float32(42)\n\n    x = ccall((:test_16, libccalltest), Struct, (Struct, Float32), a, b)\n\n    @test x.x \u2248 a.x + b*1\n    @test x.y \u2248 a.y - b*2\n    @test x.z \u2248 a.z + b*3\n    @test x.a \u2248 a.a - b*4\n    @test x.b \u2248 a.b + b*5\n    @test x.c \u2248 a.c - b*6\nend\ntest_struct16(Struct16)\ntest_struct16(Struct16I)\n\ntype Struct17\n    a::Int8\n    b::Int16\nend\nimmutable Struct17I\n    a::Int8\n    b::Int16\nend\n\nfunction test_struct17{Struct}(::Type{Struct})\n    a = Struct(2, 10)\n    b = Int8(2)\n\n    x = ccall((:test_17, libccalltest), Struct, (Struct, Int8), a, b)\n\n    @test x.a == a.a + b * 1\n    @test x.b == a.b - b * 2\nend\ntest_struct17(Struct17)\ntest_struct17(Struct17I)\n\ntype Struct18\n    a::Int8\n    b::Int8\n    c::Int8\nend\nimmutable Struct18I\n    a::Int8\n    b::Int8\n    c::Int8\nend\n\nfunction test_struct18{Struct}(::Type{Struct})\n    a = Struct(2, 10, -3)\n    b = Int8(2)\n\n    x = ccall((:test_18, libccalltest), Struct, (Struct, Int8), a, b)\n\n    @test x.a == a.a + b * 1\n    @test x.b == a.b - b * 2\n    @test x.c == a.c + b * 3\nend\ntest_struct18(Struct18)\ntest_struct18(Struct18I)\n\nlet a, b, x\n    a = Int128(0x7f00123456789abc)<<64 + typemax(UInt64)\n    b = Int64(1)\n\n    x = ccall((:test_128, libccalltest), Int128, (Int128, Int64), a, b)\n\n    @test x == a + b*1\n    @test a == Int128(0x7f00123456789abc)<<64 + typemax(UInt64)\nend\n\ntype Struct_Big\n    x::Int\n    y::Int\n    z::Int8\nend\nimmutable Struct_BigI\n    x::Int\n    y::Int\n    z::Int8\nend\ncopy(a::Struct_Big) = Struct_Big(a.x, a.y, a.z)\ncopy(a::Struct_BigI) = a\n\nfunction test_struct_big{Struct}(::Type{Struct})\n    a = Struct(424,-5,Int8('Z'))\n    a2 = copy(a)\n\n    x = ccall((:test_big, libccalltest), Struct, (Struct,), a2)\n\n    @test a2.x == a.x && a2.y == a.y && a2.z == a.z\n    @test x.x == a.x + 1\n    @test x.y == a.y - 2\n    @test x.z == a.z - Int('A')\nend\ntest_struct_big(Struct_Big)\ntest_struct_big(Struct_BigI)\n\nconst Struct_huge1a = NTuple{8, Int64}\nconst Struct_huge1b = NTuple{9, Int64}\nconst Struct_huge2a = NTuple{8, Cdouble}\nconst Struct_huge2b = NTuple{9, Cdouble}\ntype Struct_huge3a\n    cf::NTuple{3, Complex{Cfloat}}\n    f7::Cfloat\n    f8::Cfloat\nend\ntype Struct_huge3b\n    cf::NTuple{7, Complex{Cfloat}}\n    r8a::Cfloat\n    r8b::Cfloat\nend\ntype Struct_huge3c\n    cf::NTuple{7, Complex{Cfloat}}\n    r8a::Cfloat\n    r8b::Cfloat\n    r9::Cfloat\nend\ntype Struct_huge4a\n    r12::Complex{Cdouble}\n    r34::Complex{Cdouble}\n    r5::Complex{Cfloat}\n    r67::Complex{Cdouble}\n    r8::Cdouble\nend\ntype Struct_huge4b\n    r12::Complex{Cdouble}\n    r34::Complex{Cdouble}\n    r5::Complex{Cfloat}\n    r67::Complex{Cdouble}\n    r89::Complex{Cdouble}\nend\nconst Struct_huge5a = NTuple{8, Complex{Cint}}\nconst Struct_huge5b = NTuple{9, Complex{Cint}}\n\nfunction verify_huge(init, a, b)\n    @test typeof(init) === typeof(a) === typeof(b)\n    verbose && @show (a, b)\n    # make sure a was unmodified\n    for i = 1:nfields(a)\n        @test getfield(init, i) === getfield(a, i)\n    end\n    # make sure b was modifed as expected\n    a1, b1 = getfield(a, 1), getfield(b, 1)\n    while isa(a1, Tuple)\n        @test a1[2:end] === b1[2:end]\n        a1 = a1[1]\n        b1 = b1[1]\n    end\n    if isa(a1, VecElement)\n        a1 = a1.value\n        b1 = b1.value\n    end\n    @test oftype(a1, a1 * 39) === b1\n    for i = 2:nfields(a)\n        @test getfield(a, i) === getfield(b, i)\n    end\nend\nmacro test_huge(i, b, init)\n    f = QuoteNode(Symbol(\"test_huge\", i, b))\n    ty = Symbol(\"Struct_huge\", i, b)\n    return quote\n        let a = $ty($(esc(init))...), f\n            f(b) = ccall(($f, libccalltest), $ty, (Cchar, $ty, Cchar), '0' + $i, a, $b[1])\n            #code_llvm(f, typeof((a,)))\n            verify_huge($ty($(esc(init))...), a, f(a))\n        end\n    end\nend\n@test_huge 1 'a' ((1, 2, 3, 4, 5, 6, 7, 8),)\n@test_huge 1 'b' ((1, 2, 3, 4, 5, 6, 7, 8, 9),)\n@test_huge 2 'a' ((1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0),)\n@test_huge 2 'b' ((1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0),)\n@test_huge 3 'a' ((1.0 + 2.0im, 3.0 + 4.0im, 5.0 + 6.0im), 7.0, 8.0)\n@test_huge 3 'b' ((1.0 + 2.0im, 3.0 + 4.0im, 5.0 + 6.0im, 7.0 + 8.0im, 9.0 + 10.0im, 11.0 + 12.0im, 13.0 + 14.0im), 7.0, 8.0)\n@test_huge 3 'c' ((1.0 + 2.0im, 3.0 + 4.0im, 5.0 + 6.0im, 7.0 + 8.0im, 9.0 + 10.0im, 11.0 + 12.0im, 13.0 + 14.0im), 7.0, 8.0, 9.0)\n@test_huge 4 'a' (1.0 + 2.0im, 3.0 + 4.0im, 5.0f0 + 6.0f0im, 7.0 + 8.0im, 9.0)\n@test_huge 4 'b' (1.0 + 2.0im, 3.0 + 4.0im, 5.0f0 + 6.0f0im, 7.0 + 8.0im, 9.0 + 10.0im)\n@test_huge 5 'a' ((1 + 2im, 3 + 4im, 5 + 6im, 7 + 8im, 9 + 10im, 11 + 12im, 13 + 14im, 15 + 16im),)\n@test_huge 5 'b' ((1 + 2im, 3 + 4im, 5 + 6im, 7 + 8im, 9 + 10im, 11 + 12im, 13 + 14im, 15 + 16im, 17 + 17im),)\n\n## cfunction roundtrip\n\nverbose && Libc.flush_cstdio()\nverbose && println(\"Testing cfunction roundtrip: \")\n\ncf64 = 2.84+5.2im\ncf32 = 3.34f0+53.2f0im\nci32 = Complex{Int32}(Int32(10),Int32(31))\nci64 = Complex{Int64}(Int64(20),Int64(51))\ns1 = Struct1(352.39422f23, 19.287577)\n==(a::Struct1,b::Struct1) = a.x == b.x && a.y == b.y\n\nfor (t,v) in ((Complex{Int32},:ci32),(Complex{Int64},:ci64),\n              (Complex64,:cf32),(Complex128,:cf64),(Struct1,:s1))\n    fname = Symbol(\"foo\",v)\n    fname1 = Symbol(\"foo1\",v)\n    @eval begin\n        verbose && println($t)\n        a = copy($v)\n        verbose && println(\"A: \",a)\n        function $fname1(s::$t)\n            verbose && println(\"B: \",s)\n            @test s == $v\n            @test s === a\n            global c = s\n            s\n        end\n        function $fname1(s)\n            @assert false\n        end\n        function $fname(s::$t)\n            verbose && println(\"B: \",s)\n            @test s == $v\n            if($(t).mutable)\n                @test !(s === a)\n            end\n            global c = s\n            s\n        end\n        function $fname(s)\n            @assert false\n        end\n        b = ccall(cfunction($fname1,Ref{$t},(Ref{$t},)),Ref{$t},(Ref{$t},),a)\n        verbose && println(\"C: \",b)\n        @test b == $v\n        @test b === a\n        @test b === c\n        b = ccall(cfunction($fname,$t,($t,)),$t,($t,),a)\n        verbose && println(\"C: \",b)\n        @test b == $v\n        if ($(t).mutable)\n            @test !(b === c)\n            @test !(b === a)\n        end\n        b = ccall(cfunction($fname1,$t,(Ref{$t},)),$t,(Ref{$t},),a)\n        verbose && println(\"C: \",b)\n        @test b == $v\n        if ($(t).mutable)\n            @test !(b === c)\n            @test !(b === a)\n        end\n        b = ccall(cfunction($fname,Ref{$t},($t,)),Ref{$t},($t,),a)\n        verbose && println(\"C: \",b)\n        @test b == $v\n        @test b === c\n        if ($(t).mutable)\n            @test !(b === a)\n        end\n        b = ccall(cfunction($fname,Any,(Ref{$t},)),Any,(Ref{$t},),$v)\n        verbose && println(\"C: \",b)\n        @test b == $v\n        @test b === c\n        if ($(t).mutable)\n            @test !(b === a)\n        end\n        b = ccall(cfunction($fname,Any,(Ref{Any},)),Any,(Ref{Any},),$v)\n        @test b == $v\n        @test b === c\n        if ($(t).mutable)\n            @test !(b === a)\n        end\n        @test_throws TypeError ccall(cfunction($fname,Ref{AbstractString},(Ref{Any},)),Any,(Ref{Any},),$v)\n        @test_throws TypeError ccall(cfunction($fname,AbstractString,(Ref{Any},)),Any,(Ref{Any},),$v)\n    end\nend\n\n# issue 13031\nfoo13031(x) = Cint(1)\nfoo13031p = cfunction(foo13031, Cint, (Ref{Tuple{}},))\nccall(foo13031p, Cint, (Ref{Tuple{}},), ())\n\nfoo13031(x,y,z) = z\nfoo13031p = cfunction(foo13031, Cint, (Ref{Tuple{}},Ref{Tuple{}},Cint))\nccall(foo13031p, Cint, (Ref{Tuple{}},Ref{Tuple{}},Cint), (), (), 8)\n\n# issue 17219\nfunction ccall_reassigned_ptr(ptr::Ptr{Void})\n    ptr = Libdl.dlsym(Libdl.dlopen(libccalltest), \"test_echo_p\")\n    ccall(ptr, Any, (Any,), \"foo\")\nend\n@test ccall_reassigned_ptr(C_NULL) == \"foo\"\n\n# @threadcall functionality\nthreadcall_test_func(x) =\n    @threadcall((:testUcharX, libccalltest), Int32, (UInt8,), x % UInt8)\n\n@test threadcall_test_func(3) == 1\n@test threadcall_test_func(259) == 1\n\n# issue 17819\n# NOTE: can't use cfunction or reuse ccalltest Struct methods, as those call into the runtime\n@test @threadcall((:threadcall_args, libccalltest), Cint, (Cint, Cint), 1, 2) == 3\n\nlet n=3\n    tids = Culong[]\n    @sync for i in 1:10^n\n        @async push!(tids, @threadcall(:uv_thread_self, Culong, ()))\n    end\n\n    # The work should not be done on the master thread\n    t0 = ccall(:uv_thread_self, Culong, ())\n    @test length(tids) == 10^n\n    for t in tids\n        @test t != t0\n    end\nend\n\n@test ccall(:jl_getpagesize, Clong, ()) == @threadcall(:jl_getpagesize, Clong, ())\n\n# Pointer finalizer (issue #15408)\nlet A = [1]\n    ccall((:set_c_int, libccalltest), Void, (Cint,), 1)\n    @test ccall((:get_c_int, libccalltest), Cint, ()) == 1\n    finalizer(A, cglobal((:finalizer_cptr, libccalltest), Void))\n    finalize(A)\n    @test ccall((:get_c_int, libccalltest), Cint, ()) == -1\nend\n\n# SIMD Registers\n\ntypealias VecReg{N,T} NTuple{N,VecElement{T}}\ntypealias V2xF32 VecReg{2,Float32}\ntypealias V4xF32 VecReg{4,Float32}\ntypealias V2xF64 VecReg{2,Float64}\ntypealias V2xI32 VecReg{2,Int32}\ntypealias V4xI32 VecReg{4,Int32}\n\nimmutable Struct_AA64_1\n    v1::Int32\n    v2::Int128\nend\nimmutable Struct_AA64_2\n    v1::Float16\n    v2::Float64\nend\n\n# This is a homogenious short vector aggregate\nimmutable Struct_AA64_3\n    v1::VecReg{8,Int8}\n    v2::VecReg{2,Float32}\nend\n# This is NOT a homogenious short vector aggregate\nimmutable Struct_AA64_4\n    v2::VecReg{2,Float32}\n    v1::VecReg{8,Int16}\nend\n\ntype Struct_huge1_ppc64\n    m::Int64\n    v::V4xF32\nend\n\ntype Struct_huge2_ppc64\n    v1::V4xF32\n    v2::V2xI32\nend\n\ntype Struct_huge3_ppc64\n    v1::V4xF32\n    f::NTuple{4,Float32}\nend\n\ntype Struct_huge4_ppc64\n    v1::V2xF32\n    v2::V2xF64\nend\n\ntype Struct_huge5_ppc64\n    v1::NTuple{9,V4xF32}\nend\n\ntype Struct_huge6_ppc64\n    v1::NTuple{8,V4xF32}\n    v2::V4xF32\nend\n\ntype Struct_huge7_ppc64\n    v1::VecReg{3,Int32}\n    v2::VecReg{3,Int32}\nend\n\ntype Struct_huge1_ppc64_hva\n    v1::NTuple{8,V4xF32}\nend\n\ntype Struct_huge2_ppc64_hva\n    v1::NTuple{2,NTuple{2,V4xF32}}\nend\n\ntype Struct_huge3_ppc64_hva\n    vf1::V4xF32\n    vf2::Tuple{NTuple{2,V4xF32}}\nend\n\ntype Struct_huge4_ppc64_hva\n    v1::V4xI32\n    v2::V4xF32\nend\n\ntype Struct_huge5_ppc64_hva\n    v1::V4xI32\n    v2::V2xF64\nend\n\nif Sys.ARCH === :x86_64\n    function test_sse(a1::V4xF32,a2::V4xF32,a3::V4xF32,a4::V4xF32)\n        ccall((:test_m128, libccalltest), V4xF32, (V4xF32,V4xF32,V4xF32,V4xF32), a1, a2, a3, a4)\n    end\n\n    function test_sse(a1::V4xI32,a2::V4xI32,a3::V4xI32,a4::V4xI32)\n        ccall((:test_m128i, libccalltest), V4xI32, (V4xI32,V4xI32,V4xI32,V4xI32), a1, a2, a3, a4)\n    end\n\n    foo_ams(a1, a2, a3, a4) = VecReg(ntuple(i->VecElement(a1[i].value+a2[i].value*(a3[i].value-a4[i].value)),4))\n\n    rt_sse{T}(a1::T,a2::T,a3::T,a4::T) = ccall(cfunction(foo_ams,T,(T,T,T,T)), T, (T,T,T,T), a1, a2, a3,a4)\n\n    for s in [Float32,Int32]\n        a1 = VecReg(ntuple(i->VecElement(s(1i)),4))\n        a2 = VecReg(ntuple(i->VecElement(s(2i)),4))\n        a3 = VecReg(ntuple(i->VecElement(s(3i)),4))\n        a4 = VecReg(ntuple(i->VecElement(s(4i)),4))\n        r = VecReg(ntuple(i->VecElement(s(1i+2i*(3i-4i))),4))\n        @test test_sse(a1,a2,a3,a4) == r\n\n        # cfunction round-trip\n        @test rt_sse(a1,a2,a3,a4) == r\n    end\n\nelseif Sys.ARCH === :aarch64\n    for v1 in 1:99:1000, v2 in -100:-1999:-20000\n        @test ccall((:test_aa64_i128_1, libccalltest), Int128,\n                    (Int64, Int128), v1, v2) == v1 * 2 - v2\n    end\n    for v1 in 1:4, v2 in -4:-1, v3_1 in 3:5, v3_2 in 7:9\n        res = ccall((:test_aa64_i128_2, libccalltest), Struct_AA64_1,\n                    (Int64, Int128, Struct_AA64_1),\n                    v1, v2, Struct_AA64_1(v3_1, v3_2))\n        expected = Struct_AA64_1(v1 \u00f7 2 + 1 - v3_1, v2 * 2 - 1 - v3_2)\n        @test res === expected\n    end\n    for v1 in 1:4, v2 in -4:-1, v3 in 3:5, v4 in -(1:3)\n        res = ccall((:test_aa64_fp16_1, libccalltest), Float16,\n                    (Cint, Float32, Float64, Float16),\n                    v1, v2, v3, v4)\n        expected = Float16(v1 + v2 * 2 + v3 * 3 + v4 * 4)\n        @test res === expected\n\n        res = ccall((:test_aa64_fp16_2, libccalltest), Struct_AA64_2,\n                    (Cint, Float32, Float64, Float16),\n                    v1, v2, v3, v4)\n        expected = Struct_AA64_2(v4 / 2 + 1, v1 * 2 + v2 * 4 - v3)\n        @test res === expected\n    end\n    for v1_1 in 1:4, v1_2 in -2:2, v2 in -4:-1, v3_1 in 3:5, v3_2 in 6:8\n        res = ccall((:test_aa64_vec_1, libccalltest),\n                    VecReg{2,Int64},\n                    (VecReg{2,Int32}, Float32, VecReg{2,Int32}),\n                    (VecElement(Int32(v1_1)), VecElement(Int32(v1_2))),\n                    v2, (VecElement(Int32(v3_1)), VecElement(Int32(v3_2))))\n        expected = (VecElement(v1_1 * v2 + v3_1), VecElement(v1_2 * v2 + v3_2))\n        @test res === expected\n    end\n    for v1_11 in 1:4, v1_12 in -2:2, v1_21 in 1:4, v1_22 in -2:2,\n        v2_11 in 1:4, v2_12 in -2:2, v2_21 in 1:4, v2_22 in -2:2\n        v1 = Struct_AA64_3((VecElement(Int8(v1_11)), VecElement(Int8(v1_12)),\n                            VecElement(Int8(0)), VecElement(Int8(0)),\n                            VecElement(Int8(0)), VecElement(Int8(0)),\n                            VecElement(Int8(0)), VecElement(Int8(0))),\n                           (VecElement(Float32(v1_21)),\n                            VecElement(Float32(v1_22))))\n        v2 = Struct_AA64_4((VecElement(Float32(v2_21)),\n                            VecElement(Float32(v2_22))),\n                           (VecElement(Int16(v2_11)), VecElement(Int16(v2_12)),\n                            VecElement(Int16(0)), VecElement(Int16(0)),\n                            VecElement(Int16(0)), VecElement(Int16(0)),\n                            VecElement(Int16(0)), VecElement(Int16(0))))\n        res = ccall((:test_aa64_vec_2, libccalltest),\n                    Struct_AA64_3, (Struct_AA64_3, Struct_AA64_4), v1, v2)\n        expected = Struct_AA64_3((VecElement(Int8(v1_11 + v2_11)),\n                                  VecElement(Int8(v1_12 + v2_12)),\n                                  VecElement(Int8(0)), VecElement(Int8(0)),\n                                  VecElement(Int8(0)), VecElement(Int8(0)),\n                                  VecElement(Int8(0)), VecElement(Int8(0))),\n                                 (VecElement(Float32(v1_21 - v2_21)),\n                                  VecElement(Float32(v1_22 - v2_22))))\n        @test res === expected\n    end\n\nelseif Sys.ARCH === :powerpc64le || Sys.ARCH === :ppc64le\n@test_huge 1 \"_ppc64\" (1, (2.0, 3.0, 4.0, 5.0),)\n@test_huge 2 \"_ppc64\" ((1.0, 2.0, 3.0, 4.0), (11, 12))\n@test_huge 3 \"_ppc64\" ((1, 2, 3, 4), (11.0, 12.0, 13.0, 14.0))\n@test_huge 4 \"_ppc64\" ((1, 2), (11.0, 12.0))\n@test_huge 5 \"_ppc64\" ((((1.0, 2.0, 3.0, 4.0),\n                         (5.0, 6.0, 7.0, 8.0),\n                         (11.0, 12.0, 13.0, 14.0),\n                         (15.0, 16.0, 17.0, 18.0),\n                         (21.0, 22.0, 23.0, 24.0),\n                         (25.0, 26.0, 27.0, 28.0),\n                         (31.0, 32.0, 33.0, 34.0),\n                         (35.0, 36.0, 37.0, 38.0),\n                         (41.0, 42.0, 43.0, 44.0)),))\n@test_huge 6 \"_ppc64\" ((((1.0, 2.0, 3.0, 4.0),\n                         (5.0, 6.0, 7.0, 8.0),\n                         (11.0, 12.0, 13.0, 14.0),\n                         (15.0, 16.0, 17.0, 18.0),\n                         (21.0, 22.0, 23.0, 24.0),\n                         (25.0, 26.0, 27.0, 28.0),\n                         (31.0, 32.0, 33.0, 34.0),\n                         (35.0, 36.0, 37.0, 38.0)),\n                        (41.0, 42.0, 43.0, 44.0)))\n@test_huge 1 \"_ppc64_hva\" ((((1.0, 2.0, 3.0, 4.0),\n                             (5.0, 6.0, 7.0, 8.0),\n                             (11.0, 12.0, 13.0, 14.0),\n                             (15.0, 16.0, 17.0, 18.0),\n                             (21.0, 22.0, 23.0, 24.0),\n                             (25.0, 26.0, 27.0, 28.0),\n                             (31.0, 32.0, 33.0, 34.0),\n                             (35.0, 36.0, 37.0, 38.0)),))\n@test_huge 2 \"_ppc64_hva\" (((((1.0, 2.0, 3.0, 4.0),\n                              (5.0, 6.0, 7.0, 8.0)),\n                             ((11.0, 12.0, 13.0, 14.0),\n                              (15.0, 16.0, 17.0, 18.0))),))\n@test_huge 3 \"_ppc64_hva\" (((1.0, 2.0, 3.0, 4.0),\n                            (((11.0, 12.0, 13.0, 14.0),\n                              (15.0, 16.0, 17.0, 18.0)),)))\n@test_huge 4 \"_ppc64_hva\" (((1, 2, 3, 4),\n                            (11.0, 12.0, 13.0, 14.0)))\n@test_huge 5 \"_ppc64_hva\" (((1, 2, 3, 4),\n                            (11.0, 12.0)))\n\n@test 18451 == ccall((:test_ppc64_vec1long, libccalltest), Int64,\n    (Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Struct_huge1_ppc64),\n    1, 2, 3, 4, 5, 6, 7, 8, 9, Struct_huge1_ppc64(18000, (100, 101, 102, 103)))\n\n@test 941 == ccall((:test_ppc64_vec1long_vec, libccalltest), Int64,\n    (Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, V4xF32),\n    11, 12, 13, 14, 15, 16, 17, 18, 19, (200, 201, 202, 203))\n\n@test V4xF32((614232, 614218, 614204, 614190)) ==\n     ccall((:test_ppc64_vec2, libccalltest), V4xF32,\n    (Int64, V4xF32, V4xF32, V4xF32, V4xF32,\n     V4xF32, V4xF32, V4xF32, V4xF32, V4xF32,\n     V4xF32, V4xF32, V4xF32, V4xF32, V4xF32),\n    600000, (4, 3, 2, 1), (5, 4, 3, 2), (6, 5, 4, 3), (7, 6, 5, 4),\n    (14, 13, 12, 11), (15, 14, 13, 12), (16, 15, 14, 13), (17, 16, 15, 14), (18, 17, 16, 15),\n    (1024, 1023, 1022, 1021), (1025, 1024, 1023, 1022), (1026, 1025, 1024, 1023), (1027, 1026, 1025, 1024), (10028, 10027, 10026, 10025))\n\nelseif Sys.ARCH !== :i686 && Sys.ARCH !== :arm # TODO\nwarn(\"ccall: no VecReg tests run for this platform\")\n\nend\n\n# Special calling convention for `Array`\nfunction f17204(a)\n    b = similar(a)\n    for i in eachindex(a)\n        b[i] = a[i] + 10\n    end\n    return b\nend\n@test ccall(cfunction(f17204, Vector{Any}, Tuple{Vector{Any}}),\n            Vector{Any}, (Vector{Any},), Any[1:10;]) == Any[11:20;]\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/sys.c": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n/*\n  sys.c\n  I/O and operating system utility functions\n*/\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#ifdef _OS_WINDOWS_\n#include <psapi.h>\n#else\n#include <sys/sysctl.h>\n#include <sys/wait.h>\n#include <sys/ptrace.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#endif\n#include <errno.h>\n#include <signal.h>\n#include <fcntl.h>\n\n#ifndef _OS_WINDOWS_\n// for getrusage\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#endif\n\n#ifdef __APPLE__\n#include <mach-o/dyld.h>\n#include <mach-o/nlist.h>\n#include <sys/types.h> // for jl_raise_debugger\n#elif !defined(_OS_WINDOWS_)\n#include <link.h>\n#endif\n\n#ifdef __SSE__\n#include <xmmintrin.h>\n#endif\n\n#if defined _MSC_VER\n#include <io.h>\n#include <intrin.h>\n#endif\n\n#ifdef JL_MSAN_ENABLED\n#include <sanitizer/msan_interface.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(_OS_WINDOWS_) && !defined(_COMPILER_MINGW_)\nJL_DLLEXPORT char *dirname(char *);\n#else\n#include <libgen.h>\n#endif\n\nJL_DLLEXPORT uint32_t jl_getutf8(ios_t *s)\n{\n    uint32_t wc=0;\n    ios_getutf8(s, &wc);\n    return wc;\n}\n\nJL_DLLEXPORT int jl_sizeof_uv_mutex(void) { return sizeof(uv_mutex_t); }\nJL_DLLEXPORT int jl_sizeof_off_t(void) { return sizeof(off_t); }\n#ifndef _OS_WINDOWS_\nJL_DLLEXPORT int jl_sizeof_mode_t(void) { return sizeof(mode_t); }\nJL_DLLEXPORT int jl_ftruncate(int fd, int64_t length)\n{\n    return ftruncate(fd, (off_t)length);\n}\nJL_DLLEXPORT int64_t jl_lseek(int fd, int64_t offset, int whence)\n{\n    return lseek(fd, (off_t)offset, whence);\n}\nJL_DLLEXPORT ssize_t jl_pwrite(int fd, const void *buf, size_t count, int64_t offset)\n{\n    return pwrite(fd, buf, count, (off_t)offset);\n}\nJL_DLLEXPORT void *jl_mmap(void *addr, size_t length, int prot, int flags,\n                           int fd, int64_t offset)\n{\n    return mmap(addr, length, prot, flags, fd, (off_t)offset);\n}\n#else\nJL_DLLEXPORT int64_t jl_lseek(int fd, int64_t offset, int whence)\n{\n    return _lseeki64(fd, offset, whence);\n}\n#endif\nJL_DLLEXPORT int jl_sizeof_ios_t(void) { return sizeof(ios_t); }\n\nJL_DLLEXPORT long jl_ios_fd(ios_t *s) { return s->fd; }\n\nJL_DLLEXPORT int32_t jl_nb_available(ios_t *s)\n{\n    return (int32_t)(s->size - s->bpos);\n}\n\n// --- dir/file stuff ---\n\nJL_DLLEXPORT int jl_sizeof_uv_fs_t(void) { return sizeof(uv_fs_t); }\nJL_DLLEXPORT void jl_uv_fs_req_cleanup(uv_fs_t *req) { uv_fs_req_cleanup(req); }\nJL_DLLEXPORT char *jl_uv_fs_t_ptr(uv_fs_t *req) { return (char*)req->ptr; }\nJL_DLLEXPORT int jl_uv_fs_result(uv_fs_t *f) { return f->result; }\n\n// --- stat ---\nJL_DLLEXPORT int jl_sizeof_stat(void) { return sizeof(uv_stat_t); }\n\nJL_DLLEXPORT int32_t jl_stat(const char *path, char *statbuf)\n{\n    uv_fs_t req;\n    int ret;\n\n    // Ideally one would use the statbuf for the storage in req, but\n    // it's not clear that this is possible using libuv\n    ret = uv_fs_stat(uv_default_loop(), &req, path, NULL);\n    if (ret == 0)\n        memcpy(statbuf, req.ptr, sizeof(uv_stat_t));\n    uv_fs_req_cleanup(&req);\n    return ret;\n}\n\nJL_DLLEXPORT int32_t jl_lstat(const char *path, char *statbuf)\n{\n    uv_fs_t req;\n    int ret;\n\n    ret = uv_fs_lstat(uv_default_loop(), &req, path, NULL);\n    if (ret == 0)\n        memcpy(statbuf, req.ptr, sizeof(uv_stat_t));\n    uv_fs_req_cleanup(&req);\n    return ret;\n}\n\nJL_DLLEXPORT int32_t jl_fstat(int fd, char *statbuf)\n{\n    uv_fs_t req;\n    int ret;\n\n    ret = uv_fs_fstat(uv_default_loop(), &req, fd, NULL);\n    if (ret == 0)\n        memcpy(statbuf, req.ptr, sizeof(uv_stat_t));\n    uv_fs_req_cleanup(&req);\n    return ret;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_dev(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_dev;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_ino(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_ino;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_mode(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_mode;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_nlink(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_nlink;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_uid(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_uid;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_gid(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_gid;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_rdev(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_rdev;\n}\n\nJL_DLLEXPORT uint64_t jl_stat_size(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_size;\n}\n\nJL_DLLEXPORT uint64_t jl_stat_blksize(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_blksize;\n}\n\nJL_DLLEXPORT uint64_t jl_stat_blocks(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_blocks;\n}\n\n/*\n// atime is stupid, let's not support it\nJL_DLLEXPORT double jl_stat_atime(char *statbuf)\n{\n  uv_stat_t *s;\n  s = (uv_stat_t*)statbuf;\n  return (double)s->st_atim.tv_sec + (double)s->st_atim.tv_nsec * 1e-9;\n}\n*/\n\nJL_DLLEXPORT double jl_stat_mtime(char *statbuf)\n{\n    uv_stat_t *s;\n    s = (uv_stat_t*)statbuf;\n    return (double)s->st_mtim.tv_sec + (double)s->st_mtim.tv_nsec * 1e-9;\n}\n\nJL_DLLEXPORT double jl_stat_ctime(char *statbuf)\n{\n    uv_stat_t *s;\n    s = (uv_stat_t*)statbuf;\n    return (double)s->st_ctim.tv_sec + (double)s->st_ctim.tv_nsec * 1e-9;\n}\n\n// --- buffer manipulation ---\n\nJL_DLLEXPORT jl_array_t *jl_takebuf_array(ios_t *s)\n{\n    size_t n;\n    jl_array_t *a;\n    if (s->buf == &s->local[0]) {\n        // small data case. copies, but this can be avoided using the\n        // technique of jl_readuntil below.\n        a = jl_pchar_to_array(s->buf, s->size);\n        ios_trunc(s, 0);\n    }\n    else {\n        char *b = ios_takebuf(s, &n);\n        a = jl_ptr_to_array_1d(jl_array_uint8_type, b, n-1, 1);\n    }\n    return a;\n}\n\nJL_DLLEXPORT jl_value_t *jl_takebuf_string(ios_t *s)\n{\n    jl_array_t *a = jl_takebuf_array(s);\n    JL_GC_PUSH1(&a);\n    jl_value_t *str = jl_array_to_string(a);\n    JL_GC_POP();\n    return str;\n}\n\n// the returned buffer must be manually freed. To determine the size,\n// call position(s) before using this function.\nJL_DLLEXPORT void *jl_takebuf_raw(ios_t *s)\n{\n    size_t sz;\n    void *buf = ios_takebuf(s, &sz);\n    return buf;\n}\n\nJL_DLLEXPORT jl_value_t *jl_readuntil(ios_t *s, uint8_t delim)\n{\n    jl_array_t *a;\n    // manually inlined common case\n    char *pd = (char*)memchr(s->buf+s->bpos, delim, (size_t)(s->size - s->bpos));\n    if (pd) {\n        size_t n = pd-(s->buf+s->bpos)+1;\n        a = jl_alloc_array_1d(jl_array_uint8_type, n);\n        memcpy(jl_array_data(a), s->buf + s->bpos, n);\n        s->bpos += n;\n    }\n    else {\n        a = jl_alloc_array_1d(jl_array_uint8_type, 80);\n        ios_t dest;\n        ios_mem(&dest, 0);\n        ios_setbuf(&dest, (char*)a->data, 80, 0);\n        size_t n = ios_copyuntil(&dest, s, delim);\n        if (dest.buf != a->data) {\n            a = jl_takebuf_array(&dest);\n        }\n        else {\n#ifdef STORE_ARRAY_LEN\n            a->length = n;\n#endif\n            a->nrows = n;\n            ((char*)a->data)[n] = '\\0';\n        }\n    }\n    return (jl_value_t*)a;\n}\n\nJL_DLLEXPORT uint64_t jl_ios_get_nbyte_int(ios_t *s, const size_t n)\n{\n    assert(n <= 8);\n    size_t space, ret;\n    do {\n        space = (size_t)(s->size - s->bpos);\n        ret = ios_readprep(s, n);\n        if (space == ret && ret < n)\n            jl_eof_error();\n    } while(ret < n);\n    uint64_t x = 0;\n    uint8_t *buf = (uint8_t*)&s->buf[s->bpos];\n    if (n == 8) {\n        // expecting loop unrolling optimization\n        for (size_t i = 0; i < 8; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n    }\n    else if (n >= 4) {\n        // expecting loop unrolling optimization\n        for (size_t i = 0; i < 4; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n        for (size_t i = 4; i < n; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n    }\n    else {\n        for (size_t i = 0; i < n; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n    }\n    s->bpos += n;\n    return x;\n}\n\n// -- syscall utilities --\n\nJL_DLLEXPORT int jl_errno(void) { return errno; }\nJL_DLLEXPORT void jl_set_errno(int e) { errno = e; }\n\n// -- get the number of CPU cores --\n\n#ifdef _OS_WINDOWS_\ntypedef DWORD (WINAPI *GAPC)(WORD);\n#ifndef ALL_PROCESSOR_GROUPS\n#define ALL_PROCESSOR_GROUPS 0xffff\n#endif\n#endif\n\nJL_DLLEXPORT int jl_cpu_cores(void)\n{\n#if defined(HW_AVAILCPU) && defined(HW_NCPU)\n    size_t len = 4;\n    int32_t count;\n    int nm[2] = {CTL_HW, HW_AVAILCPU};\n    sysctl(nm, 2, &count, &len, NULL, 0);\n    if (count < 1) {\n        nm[1] = HW_NCPU;\n        sysctl(nm, 2, &count, &len, NULL, 0);\n        if (count < 1) { count = 1; }\n    }\n    return count;\n#elif defined(_SC_NPROCESSORS_ONLN)\n    return sysconf(_SC_NPROCESSORS_ONLN);\n#elif defined(_OS_WINDOWS_)\n    //Try to get WIN7 API method\n    GAPC gapc = (GAPC) jl_dlsym_e(\n        jl_kernel32_handle,\n        \"GetActiveProcessorCount\"\n    );\n\n    if (gapc) {\n        return gapc(ALL_PROCESSOR_GROUPS);\n    }\n    else { //fall back on GetSystemInfo\n        SYSTEM_INFO info;\n        GetSystemInfo(&info);\n        return info.dwNumberOfProcessors;\n    }\n#else\n    return 1;\n#endif\n}\n\n// -- high resolution timers --\n// Returns time in nanosec\nJL_DLLEXPORT uint64_t jl_hrtime(void)\n{\n    return uv_hrtime();\n}\n\n// -- iterating the environment --\n\n#ifdef __APPLE__\n#include <crt_externs.h>\n#else\n#if !defined(_OS_WINDOWS_) || defined(_COMPILER_MINGW_)\nextern char **environ;\n#endif\n#endif\n\nJL_DLLEXPORT jl_value_t *jl_environ(int i)\n{\n#ifdef __APPLE__\n    char **environ = *_NSGetEnviron();\n#endif\n    char *env = environ[i];\n    return env ? jl_pchar_to_string(env, strlen(env)) : jl_nothing;\n}\n\n// -- child process status --\n\n#if defined _MSC_VER || defined _OS_WINDOWS_\n/* Native Woe32 API.  */\n#include <process.h>\n#define waitpid(pid,statusp,options) _cwait (statusp, pid, WAIT_CHILD)\n#define WAIT_T int\n#define WTERMSIG(x) ((x) & 0xff) /* or: SIGABRT ?? */\n#define WCOREDUMP(x) 0\n#define WEXITSTATUS(x) (((x) >> 8) & 0xff) /* or: (x) ?? */\n#define WIFSIGNALED(x) (WTERMSIG (x) != 0) /* or: ((x) == 3) ?? */\n#define WIFEXITED(x) (WTERMSIG (x) == 0) /* or: ((x) != 3) ?? */\n#define WIFSTOPPED(x) 0\n#define WSTOPSIG(x) 0 //Is this correct?\n#endif\n\nint jl_process_exited(int status)      { return WIFEXITED(status); }\nint jl_process_signaled(int status)    { return WIFSIGNALED(status); }\nint jl_process_stopped(int status)     { return WIFSTOPPED(status); }\n\nint jl_process_exit_status(int status) { return WEXITSTATUS(status); }\nint jl_process_term_signal(int status) { return WTERMSIG(status); }\nint jl_process_stop_signal(int status) { return WSTOPSIG(status); }\n\n// -- access to std filehandles --\n\nJL_STREAM *JL_STDIN  = (JL_STREAM*)STDIN_FILENO;\nJL_STREAM *JL_STDOUT = (JL_STREAM*)STDOUT_FILENO;\nJL_STREAM *JL_STDERR = (JL_STREAM*)STDERR_FILENO;\n\nJL_DLLEXPORT JL_STREAM *jl_stdin_stream(void)  { return JL_STDIN; }\nJL_DLLEXPORT JL_STREAM *jl_stdout_stream(void) { return JL_STDOUT; }\nJL_DLLEXPORT JL_STREAM *jl_stderr_stream(void) { return JL_STDERR; }\n\n// CPUID\n\n#ifdef HAVE_CPUID\nJL_DLLEXPORT void jl_cpuid(int32_t CPUInfo[4], int32_t InfoType)\n{\n#if defined _MSC_VER\n    __cpuid(CPUInfo, InfoType);\n#else\n    __asm__ __volatile__ (\n        #if defined(__i386__) && defined(__PIC__)\n        \"xchg %%ebx, %%esi;\"\n        \"cpuid;\"\n        \"xchg %%esi, %%ebx;\":\n        \"=S\" (CPUInfo[1]) ,\n        #else\n        \"cpuid\":\n        \"=b\" (CPUInfo[1]),\n        #endif\n        \"=a\" (CPUInfo[0]),\n        \"=c\" (CPUInfo[2]),\n        \"=d\" (CPUInfo[3]) :\n        \"a\" (InfoType)\n    );\n#endif\n}\n#endif\n\n// -- set/clear the FZ/DAZ flags on x86 & x86-64 --\n#ifdef __SSE__\n\n// Cache of information recovered from jl_cpuid.\n// In a multithreaded environment, there will be races on subnormal_flags,\n// but they are harmless idempotent races.  If we ever embrace C11, then\n// subnormal_flags should be declared atomic.\nstatic volatile int32_t subnormal_flags = 1;\n\nstatic int32_t get_subnormal_flags(void)\n{\n    uint32_t f = subnormal_flags;\n    if (f & 1) {\n        // CPU capabilities not yet inspected.\n        f = 0;\n        int32_t info[4];\n        jl_cpuid(info, 0);\n        if (info[0] >= 1) {\n            jl_cpuid(info, 0x00000001);\n            if (info[3] & (1 << 26)) {\n                // SSE2 supports both FZ and DAZ\n                f = 0x00008040;\n            }\n            else if (info[3] & (1 << 25)) {\n                // SSE supports only the FZ flag\n                f = 0x00008000;\n            }\n        }\n        subnormal_flags = f;\n    }\n    return f;\n}\n\n// Returns non-zero if subnormals go to 0; zero otherwise.\nJL_DLLEXPORT int32_t jl_get_zero_subnormals(void)\n{\n    uint32_t flags = get_subnormal_flags();\n    return _mm_getcsr() & flags;\n}\n\n// Return zero on success, non-zero on failure.\nJL_DLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)\n{\n    uint32_t flags = get_subnormal_flags();\n    if (flags) {\n        uint32_t state = _mm_getcsr();\n        if (isZero)\n            state |= flags;\n        else\n            state &= ~flags;\n        _mm_setcsr(state);\n        return 0;\n    }\n    else {\n        // Report a failure only if user is trying to enable FTZ/DAZ.\n        return isZero;\n    }\n}\n\n#elif defined(_CPU_AARCH64_)\n\n// FZ, bit [24]\nstatic const uint32_t fpcr_fz_mask = 1 << 24;\n\nstatic inline uint32_t get_fpcr_aarch64(void)\n{\n    uint32_t fpcr;\n    asm volatile(\"mrs %0, fpcr\" : \"=r\"(fpcr));\n    return fpcr;\n}\n\nstatic inline void set_fpcr_aarch64(uint32_t fpcr)\n{\n    asm volatile(\"msr fpcr, %0\" :: \"r\"(fpcr));\n}\n\nJL_DLLEXPORT int32_t jl_get_zero_subnormals(void)\n{\n    return (get_fpcr_aarch64() & fpcr_fz_mask) != 0;\n}\n\nJL_DLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)\n{\n    uint32_t fpcr = get_fpcr_aarch64();\n    fpcr = isZero ? (fpcr | fpcr_fz_mask) : (fpcr & ~fpcr_fz_mask);\n    set_fpcr_aarch64(fpcr);\n    return 0;\n}\n\n#else\n\nJL_DLLEXPORT int32_t jl_get_zero_subnormals(void)\n{\n    return 0;\n}\n\nJL_DLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)\n{\n    return isZero;\n}\n\n#endif\n\n// -- processor native alignment information --\n\nJL_DLLEXPORT void jl_native_alignment(uint_t *int8align, uint_t *int16align, uint_t *int32align,\n                                      uint_t *int64align, uint_t *float32align, uint_t *float64align)\n{\n    *int8align = __alignof(uint8_t);\n    *int16align = __alignof(uint16_t);\n    *int32align = __alignof(uint32_t);\n    *int64align = __alignof(uint64_t);\n    *float32align = __alignof(float);\n    *float64align = __alignof(double);\n}\n\nJL_DLLEXPORT jl_value_t *jl_is_char_signed(void)\n{\n    return ((char)255) < 0 ? jl_true : jl_false;\n}\n\n// -- misc sysconf info --\n\n#ifdef _OS_WINDOWS_\nstatic long cachedPagesize = 0;\nJL_DLLEXPORT long jl_getpagesize(void)\n{\n    if (!cachedPagesize) {\n        SYSTEM_INFO systemInfo;\n        GetSystemInfo (&systemInfo);\n        cachedPagesize = systemInfo.dwPageSize;\n    }\n    return cachedPagesize;\n}\n#else\nJL_DLLEXPORT long jl_getpagesize(void)\n{\n    return sysconf(_SC_PAGESIZE);\n}\n#endif\n\n#ifdef _OS_WINDOWS_\nstatic long cachedAllocationGranularity = 0;\nJL_DLLEXPORT long jl_getallocationgranularity(void)\n{\n    if (!cachedAllocationGranularity) {\n        SYSTEM_INFO systemInfo;\n        GetSystemInfo (&systemInfo);\n        cachedAllocationGranularity = systemInfo.dwAllocationGranularity;\n    }\n    return cachedAllocationGranularity;\n}\n#else\nJL_DLLEXPORT long jl_getallocationgranularity(void)\n{\n    return jl_getpagesize();\n}\n#endif\n\nJL_DLLEXPORT long jl_SC_CLK_TCK(void)\n{\n#ifndef _OS_WINDOWS_\n    return sysconf(_SC_CLK_TCK);\n#else\n    return 0;\n#endif\n}\n\nJL_DLLEXPORT size_t jl_get_field_offset(jl_datatype_t *ty, int field)\n{\n    if (ty->layout == NULL || field > jl_datatype_nfields(ty) || field < 1)\n        jl_bounds_error_int((jl_value_t*)ty, field);\n    return jl_field_offset(ty, field - 1);\n}\n\nJL_DLLEXPORT size_t jl_get_alignment(jl_datatype_t *ty)\n{\n    if (ty->layout == NULL)\n        jl_error(\"non-leaf type doesn't have an alignment\");\n    return ty->layout->alignment;\n}\n\n// Takes a handle (as returned from dlopen()) and returns the absolute path to the image loaded\nJL_DLLEXPORT const char *jl_pathname_for_handle(void *handle)\n{\n    if (!handle)\n        return NULL;\n\n#ifdef __APPLE__\n    // Iterate through all images currently in memory\n    for (int32_t i = _dyld_image_count(); i >= 0 ; i--) {\n        // dlopen() each image, check handle\n        const char *image_name = _dyld_get_image_name(i);\n        void *probe_lib = jl_load_dynamic_library(image_name, JL_RTLD_DEFAULT);\n        jl_dlclose(probe_lib);\n\n        // If the handle is the same as what was passed in (modulo mode bits), return this image name\n        if (((intptr_t)handle & (-4)) == ((intptr_t)probe_lib & (-4)))\n            return image_name;\n    }\n\n#elif defined(_OS_WINDOWS_)\n\n    wchar_t *pth16 = (wchar_t*)malloc(32768); // max long path length\n    DWORD n16 = GetModuleFileNameW((HMODULE)handle,pth16,32768);\n    if (n16 <= 0) {\n        free(pth16);\n        return NULL;\n    }\n    pth16[n16] = L'\\0';\n    DWORD n8 = WideCharToMultiByte(CP_UTF8, 0, pth16, -1, NULL, 0, NULL, NULL);\n    if (n8 == 0) {\n        free(pth16);\n        return NULL;\n    }\n    char *filepath = (char*)malloc(++n8);\n    if (!WideCharToMultiByte(CP_UTF8, 0, pth16, -1, filepath, n8, NULL, NULL)) {\n        free(pth16);\n        free(filepath);\n        return NULL;\n    }\n    free(pth16);\n    return filepath;\n\n#else // Linux, FreeBSD, ...\n\n    struct link_map *map;\n    dlinfo(handle, RTLD_DI_LINKMAP, &map);\n#ifdef JL_MSAN_ENABLED\n    __msan_unpoison(&map,sizeof(struct link_map*));\n    if (map) {\n        __msan_unpoison(map, sizeof(struct link_map));\n        __msan_unpoison_string(map->l_name);\n    }\n#endif\n    if (map)\n        return map->l_name;\n\n#endif\n    return NULL;\n}\n\n#ifdef _OS_WINDOWS_\nstatic BOOL CALLBACK jl_EnumerateLoadedModulesProc64(\n  _In_      PCTSTR ModuleName,\n  _In_      DWORD64 ModuleBase,\n  _In_      ULONG ModuleSize,\n  _In_opt_  PVOID a\n)\n{\n    jl_array_grow_end((jl_array_t*)a, 1);\n    //XXX: change to jl_arrayset if array storage allocation for Array{String,1} changes:\n    jl_value_t *v = jl_cstr_to_string(ModuleName);\n    jl_array_ptr_set(a, jl_array_dim0(a)-1, v);\n    return TRUE;\n}\n// Takes a handle (as returned from dlopen()) and returns the absolute path to the image loaded\nJL_DLLEXPORT int jl_dllist(jl_array_t *list)\n{\n    return EnumerateLoadedModules64(GetCurrentProcess(), jl_EnumerateLoadedModulesProc64, list);\n}\n#endif\n\nJL_DLLEXPORT void jl_raise_debugger(void)\n{\n#if defined(_OS_WINDOWS_)\n    if (IsDebuggerPresent() == 1)\n        DebugBreak();\n#else\n    raise(SIGTRAP);\n#endif // _OS_WINDOWS_\n}\n\nJL_DLLEXPORT jl_sym_t *jl_get_UNAME(void)\n{\n    return jl_symbol(JL_BUILD_UNAME);\n}\n\nJL_DLLEXPORT jl_sym_t *jl_get_ARCH(void)\n{\n    return jl_symbol(JL_BUILD_ARCH);\n}\n\nJL_DLLEXPORT size_t jl_maxrss(void)\n{\n#if defined(_OS_WINDOWS_)\n    PROCESS_MEMORY_COUNTERS counter;\n    GetProcessMemoryInfo( GetCurrentProcess( ), &counter, sizeof(counter) );\n    return (size_t)counter.PeakWorkingSetSize;\n\n#elif defined(_OS_LINUX_) || defined(_OS_DARWIN_) || defined (_OS_FREEBSD_)\n    struct rusage rusage;\n    getrusage( RUSAGE_SELF, &rusage );\n\n#if defined(_OS_LINUX_)\n    return (size_t)(rusage.ru_maxrss * 1024);\n#else\n    return (size_t)rusage.ru_maxrss;\n#endif\n\n#else\n    return (size_t)0;\n#endif\n}\n\nJL_DLLEXPORT int jl_threading_enabled(void)\n{\n#ifdef JULIA_ENABLE_THREADING\n    return 1;\n#else\n    return 0;\n#endif\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/signals-win.c": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n// Windows\n\n#define sig_stack_size 131072 // 128k reserved for SEGV handling\nstatic BOOL (*pSetThreadStackGuarantee)(PULONG);\n\n// Copied from MINGW_FLOAT_H which may not be found due to a collision with the builtin gcc float.h\n// eventually we can probably integrate this into OpenLibm.\n#if defined(_COMPILER_MINGW_)\nvoid __cdecl __MINGW_NOTHROW _fpreset (void);\nvoid __cdecl __MINGW_NOTHROW fpreset (void);\n#else\nvoid __cdecl _fpreset (void);\nvoid __cdecl fpreset (void);\n#endif\n#define _FPE_INVALID        0x81\n#define _FPE_DENORMAL       0x82\n#define _FPE_ZERODIVIDE     0x83\n#define _FPE_OVERFLOW       0x84\n#define _FPE_UNDERFLOW      0x85\n#define _FPE_INEXACT        0x86\n#define _FPE_UNEMULATED     0x87\n#define _FPE_SQRTNEG        0x88\n#define _FPE_STACKOVERFLOW  0x8a\n#define _FPE_STACKUNDERFLOW 0x8b\n#define _FPE_EXPLICITGEN    0x8c    /* raise( SIGFPE ); */\n\nstatic char *strsignal(int sig)\n{\n    switch (sig) {\n    case SIGINT:         return \"SIGINT\"; break;\n    case SIGILL:         return \"SIGILL\"; break;\n    case SIGABRT_COMPAT: return \"SIGABRT_COMPAT\"; break;\n    case SIGFPE:         return \"SIGFPE\"; break;\n    case SIGSEGV:        return \"SIGSEGV\"; break;\n    case SIGTERM:        return \"SIGTERM\"; break;\n    case SIGBREAK:       return \"SIGBREAK\"; break;\n    case SIGABRT:        return \"SIGABRT\"; break;\n    }\n    return \"?\";\n}\n\nstatic void jl_try_throw_sigint(void)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    jl_safepoint_enable_sigint();\n    jl_wake_libuv();\n    int force = jl_check_force_sigint();\n    if (force || (!ptls->defer_signal && ptls->io_wait)) {\n        jl_safepoint_consume_sigint();\n        if (force)\n            jl_safe_printf(\"WARNING: Force throwing a SIGINT\\n\");\n        // Force a throw\n        jl_clear_force_sigint();\n        jl_throw(jl_interrupt_exception);\n    }\n}\n\nvoid __cdecl crt_sig_handler(int sig, int num)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    CONTEXT Context;\n    switch (sig) {\n    case SIGFPE:\n        fpreset();\n        signal(SIGFPE, (void (__cdecl *)(int))crt_sig_handler);\n        switch(num) {\n        case _FPE_INVALID:\n        case _FPE_OVERFLOW:\n        case _FPE_UNDERFLOW:\n        default:\n            jl_errorf(\"Unexpected FPE Error 0x%X\", num);\n            break;\n        case _FPE_ZERODIVIDE:\n            jl_throw(jl_diverror_exception);\n            break;\n        }\n        break;\n    case SIGINT:\n        signal(SIGINT, (void (__cdecl *)(int))crt_sig_handler);\n        if (exit_on_sigint)\n            jl_exit(130); // 128 + SIGINT\n        if (!jl_ignore_sigint())\n            jl_try_throw_sigint();\n        break;\n    default: // SIGSEGV, (SSIGTERM, IGILL)\n        memset(&Context, 0, sizeof(Context));\n        RtlCaptureContext(&Context);\n        jl_critical_error(sig, &Context, ptls->bt_data, &ptls->bt_size);\n        raise(sig);\n    }\n}\n\nvoid restore_signals(void)\n{\n    // turn on ctrl-c handler\n    SetConsoleCtrlHandler(NULL, 0);\n    // see if SetThreadStackGuarantee exists\n    pSetThreadStackGuarantee = (BOOL (*)(PULONG)) jl_dlsym_e(jl_kernel32_handle,\n        \"SetThreadStackGuarantee\");\n}\n\nvoid jl_throw_in_ctx(jl_value_t *excpt, CONTEXT *ctxThread, int bt)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    assert(excpt != NULL);\n#if defined(_CPU_X86_64_)\n    DWORD64 Rsp = (ctxThread->Rsp&(DWORD64)-16) - 8;\n#elif defined(_CPU_X86_)\n    DWORD32 Esp = (ctxThread->Esp&(DWORD32)-16) - 4;\n#else\n#error WIN16 not supported :P\n#endif\n    ptls->bt_size = bt ? rec_backtrace_ctx(ptls->bt_data, JL_MAX_BT_SIZE,\n                                           ctxThread) : 0;\n    ptls->exception_in_transit = excpt;\n#if defined(_CPU_X86_64_)\n    *(DWORD64*)Rsp = 0;\n    ctxThread->Rsp = Rsp;\n    ctxThread->Rip = (DWORD64)&jl_rethrow;\n#elif defined(_CPU_X86_)\n    *(DWORD32*)Esp = 0;\n    ctxThread->Esp = Esp;\n    ctxThread->Eip = (DWORD)&jl_rethrow;\n#endif\n}\n\nHANDLE hMainThread = INVALID_HANDLE_VALUE;\n\n// Try to throw the exception in the master thread.\nstatic void jl_try_deliver_sigint(void)\n{\n    jl_ptls_t ptls2 = jl_all_tls_states[0];\n    jl_safepoint_enable_sigint();\n    jl_wake_libuv();\n    if ((DWORD)-1 == SuspendThread(hMainThread)) {\n        // error\n        jl_safe_printf(\"error: SuspendThread failed\\n\");\n        return;\n    }\n    int force = jl_check_force_sigint();\n    if (force || (!ptls2->defer_signal && ptls2->io_wait)) {\n        jl_safepoint_consume_sigint();\n        if (force)\n            jl_safe_printf(\"WARNING: Force throwing a SIGINT\\n\");\n        // Force a throw\n        jl_clear_force_sigint();\n        CONTEXT ctxThread;\n        memset(&ctxThread, 0, sizeof(CONTEXT));\n        ctxThread.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;\n        if (!GetThreadContext(hMainThread, &ctxThread)) {\n            // error\n            jl_safe_printf(\"error: GetThreadContext failed\\n\");\n            return;\n        }\n        jl_throw_in_ctx(jl_interrupt_exception, &ctxThread, 1);\n        ctxThread.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;\n        if (!SetThreadContext(hMainThread, &ctxThread)) {\n            jl_safe_printf(\"error: SetThreadContext failed\\n\");\n            // error\n            return;\n        }\n    }\n    if ((DWORD)-1 == ResumeThread(hMainThread)) {\n        jl_safe_printf(\"error: ResumeThread failed\\n\");\n        // error\n        return;\n    }\n}\n\nstatic BOOL WINAPI sigint_handler(DWORD wsig) //This needs winapi types to guarantee __stdcall\n{\n    int sig;\n    //windows signals use different numbers from unix (raise)\n    switch(wsig) {\n        case CTRL_C_EVENT: sig = SIGINT; break;\n        //case CTRL_BREAK_EVENT: sig = SIGTERM; break;\n        // etc.\n        default: sig = SIGTERM; break;\n    }\n    if (exit_on_sigint)\n        jl_exit(128 + sig); // 128 + SIGINT\n    if (!jl_ignore_sigint())\n        jl_try_deliver_sigint();\n    return 1;\n}\n\nstatic LONG WINAPI _exception_handler(struct _EXCEPTION_POINTERS *ExceptionInfo, int in_ctx)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    if (ExceptionInfo->ExceptionRecord->ExceptionFlags == 0) {\n        switch (ExceptionInfo->ExceptionRecord->ExceptionCode) {\n            case EXCEPTION_INT_DIVIDE_BY_ZERO:\n                fpreset();\n                jl_throw_in_ctx(jl_diverror_exception,\n                    ExceptionInfo->ContextRecord,in_ctx);\n                return EXCEPTION_CONTINUE_EXECUTION;\n            case EXCEPTION_STACK_OVERFLOW:\n                jl_throw_in_ctx(jl_stackovf_exception,\n                    ExceptionInfo->ContextRecord,in_ctx&&pSetThreadStackGuarantee);\n                return EXCEPTION_CONTINUE_EXECUTION;\n            case EXCEPTION_ACCESS_VIOLATION:\n                if (jl_addr_is_safepoint(ExceptionInfo->ExceptionRecord->ExceptionInformation[1])) {\n#ifdef JULIA_ENABLE_THREADING\n                    jl_set_gc_and_wait();\n                    // Do not raise sigint on worker thread\n                    if (ptls->tid != 0)\n                        return EXCEPTION_CONTINUE_EXECUTION;\n#endif\n                    if (ptls->defer_signal) {\n                        jl_safepoint_defer_sigint();\n                    }\n                    else if (jl_safepoint_consume_sigint()) {\n                        jl_clear_force_sigint();\n                        jl_throw_in_ctx(jl_interrupt_exception,\n                                        ExceptionInfo->ContextRecord, in_ctx);\n                    }\n                    return EXCEPTION_CONTINUE_EXECUTION;\n                }\n                if (ExceptionInfo->ExceptionRecord->ExceptionInformation[0] == 1) { // writing to read-only memory (e.g. mmap)\n                    jl_throw_in_ctx(jl_readonlymemory_exception,\n                        ExceptionInfo->ContextRecord,in_ctx);\n                    return EXCEPTION_CONTINUE_EXECUTION;\n                }\n        }\n        jl_safe_printf(\"\\nPlease submit a bug report with steps to reproduce this fault, and any error messages that follow (in their entirety). Thanks.\\nException: \");\n        switch (ExceptionInfo->ExceptionRecord->ExceptionCode) {\n            case EXCEPTION_ACCESS_VIOLATION:\n                jl_safe_printf(\"EXCEPTION_ACCESS_VIOLATION\"); break;\n            case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n                jl_safe_printf(\"EXCEPTION_ARRAY_BOUNDS_EXCEEDED\"); break;\n            case EXCEPTION_BREAKPOINT:\n                jl_safe_printf(\"EXCEPTION_BREAKPOINT\"); break;\n            case EXCEPTION_DATATYPE_MISALIGNMENT:\n                jl_safe_printf(\"EXCEPTION_DATATYPE_MISALIGNMENT\"); break;\n            case EXCEPTION_FLT_DENORMAL_OPERAND:\n                jl_safe_printf(\"EXCEPTION_FLT_DENORMAL_OPERAND\"); break;\n            case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n                jl_safe_printf(\"EXCEPTION_FLT_DIVIDE_BY_ZERO\"); break;\n            case EXCEPTION_FLT_INEXACT_RESULT:\n                jl_safe_printf(\"EXCEPTION_FLT_INEXACT_RESULT\"); break;\n            case EXCEPTION_FLT_INVALID_OPERATION:\n                jl_safe_printf(\"EXCEPTION_FLT_INVALID_OPERATION\"); break;\n            case EXCEPTION_FLT_OVERFLOW:\n                jl_safe_printf(\"EXCEPTION_FLT_OVERFLOW\"); break;\n            case EXCEPTION_FLT_STACK_CHECK:\n                jl_safe_printf(\"EXCEPTION_FLT_STACK_CHECK\"); break;\n            case EXCEPTION_FLT_UNDERFLOW:\n                jl_safe_printf(\"EXCEPTION_FLT_UNDERFLOW\"); break;\n            case EXCEPTION_ILLEGAL_INSTRUCTION:\n                jl_safe_printf(\"EXCEPTION_ILLEGAL_INSTRUCTION\"); break;\n            case EXCEPTION_IN_PAGE_ERROR:\n                jl_safe_printf(\"EXCEPTION_IN_PAGE_ERROR\"); break;\n            case EXCEPTION_INT_DIVIDE_BY_ZERO:\n                jl_safe_printf(\"EXCEPTION_INT_DIVIDE_BY_ZERO\"); break;\n            case EXCEPTION_INT_OVERFLOW:\n                jl_safe_printf(\"EXCEPTION_INT_OVERFLOW\"); break;\n            case EXCEPTION_INVALID_DISPOSITION:\n                jl_safe_printf(\"EXCEPTION_INVALID_DISPOSITION\"); break;\n            case EXCEPTION_NONCONTINUABLE_EXCEPTION:\n                jl_safe_printf(\"EXCEPTION_NONCONTINUABLE_EXCEPTION\"); break;\n            case EXCEPTION_PRIV_INSTRUCTION:\n                jl_safe_printf(\"EXCEPTION_PRIV_INSTRUCTION\"); break;\n            case EXCEPTION_SINGLE_STEP:\n                jl_safe_printf(\"EXCEPTION_SINGLE_STEP\"); break;\n            case EXCEPTION_STACK_OVERFLOW:\n                jl_safe_printf(\"EXCEPTION_STACK_OVERFLOW\"); break;\n            default:\n                jl_safe_printf(\"UNKNOWN\"); break;\n        }\n        jl_safe_printf(\" at 0x%Ix -- \", (size_t)ExceptionInfo->ExceptionRecord->ExceptionAddress);\n        jl_gdblookup((uintptr_t)ExceptionInfo->ExceptionRecord->ExceptionAddress);\n\n        jl_critical_error(0, ExceptionInfo->ContextRecord,\n                          ptls->bt_data, &ptls->bt_size);\n        static int recursion = 0;\n        if (recursion++)\n            exit(1);\n        else\n            jl_exit(1);\n    }\n    return EXCEPTION_CONTINUE_SEARCH;\n}\n\nstatic LONG WINAPI exception_handler(struct _EXCEPTION_POINTERS *ExceptionInfo)\n{\n    return _exception_handler(ExceptionInfo,1);\n}\n\n#if defined(_CPU_X86_64_)\nJL_DLLEXPORT EXCEPTION_DISPOSITION __julia_personality(\n        PEXCEPTION_RECORD ExceptionRecord,\n        void *EstablisherFrame,\n        PCONTEXT ContextRecord,\n        void *DispatcherContext)\n{\n    EXCEPTION_POINTERS ExceptionInfo;\n    ExceptionInfo.ExceptionRecord = ExceptionRecord;\n    ExceptionInfo.ContextRecord = ContextRecord;\n\n    EXCEPTION_DISPOSITION rval;\n    switch (_exception_handler(&ExceptionInfo,1)) {\n        case EXCEPTION_CONTINUE_EXECUTION:\n            rval = ExceptionContinueExecution; break;\n        case EXCEPTION_CONTINUE_SEARCH:\n            rval = ExceptionContinueSearch; break;\n#ifndef _MSC_VER\n        case EXCEPTION_EXECUTE_HANDLER:\n            rval = ExceptionExecuteHandler; break;\n#endif\n    }\n\n    return rval;\n}\n#endif\n\nJL_DLLEXPORT void jl_install_sigint_handler(void)\n{\n    SetConsoleCtrlHandler((PHANDLER_ROUTINE)sigint_handler,1);\n}\n\nvolatile HANDLE hBtThread = 0;\nstatic DWORD WINAPI profile_bt( LPVOID lparam )\n{\n    // Note: illegal to use jl_* functions from this thread\n\n    TIMECAPS tc;\n    if (MMSYSERR_NOERROR!=timeGetDevCaps(&tc, sizeof(tc))) {\n        fputs(\"failed to get timer resolution\",stderr);\n        hBtThread = 0;\n        return 0;\n    }\n    while (1) {\n        if (running && bt_size_cur < bt_size_max) {\n            DWORD timeout = nsecprof/GIGA;\n            timeout = min(max(timeout,tc.wPeriodMin*2),tc.wPeriodMax/2);\n            Sleep(timeout);\n            if ((DWORD)-1 == SuspendThread(hMainThread)) {\n                fputs(\"failed to suspend main thread. aborting profiling.\",stderr);\n                break;\n            }\n            CONTEXT ctxThread;\n            memset(&ctxThread, 0, sizeof(CONTEXT));\n            ctxThread.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;\n            if (!GetThreadContext(hMainThread, &ctxThread)) {\n                fputs(\"failed to get context from main thread. aborting profiling.\",stderr);\n                break;\n            }\n            // Get backtrace data\n            bt_size_cur += rec_backtrace_ctx((uintptr_t*)bt_data_prof + bt_size_cur,\n                bt_size_max - bt_size_cur - 1, &ctxThread);\n            // Mark the end of this block with 0\n            bt_data_prof[bt_size_cur] = 0;\n            bt_size_cur++;\n            if ((DWORD)-1 == ResumeThread(hMainThread)) {\n                fputs(\"failed to resume main thread! aborting.\",stderr);\n                gc_debug_critical_error();\n                abort();\n            }\n        }\n        else {\n            SuspendThread(GetCurrentThread());\n        }\n    }\n    hBtThread = 0;\n    return 0;\n}\n\nJL_DLLEXPORT int jl_profile_start_timer(void)\n{\n    running = 1;\n    if (hBtThread == 0) {\n        hBtThread = CreateThread(\n            NULL,                   // default security attributes\n            0,                      // use default stack size\n            profile_bt,            // thread function name\n            0,                      // argument to thread function\n            0,                      // use default creation flags\n            0);                     // returns the thread identifier\n        (void)SetThreadPriority(hBtThread,THREAD_PRIORITY_ABOVE_NORMAL);\n    }\n    else {\n        if ((DWORD)-1 == ResumeThread(hBtThread)) {\n            fputs(\"failed to resume profiling thread.\",stderr);\n            return -2;\n        }\n    }\n    return (hBtThread != NULL ? 0 : -1);\n}\nJL_DLLEXPORT void jl_profile_stop_timer(void)\n{\n    running = 0;\n}\n\nvoid jl_install_default_signal_handlers(void)\n{\n    if (signal(SIGFPE, (void (__cdecl *)(int))crt_sig_handler) == SIG_ERR) {\n        jl_error(\"fatal error: Couldn't set SIGFPE\");\n    }\n    if (signal(SIGILL, (void (__cdecl *)(int))crt_sig_handler) == SIG_ERR) {\n        jl_error(\"fatal error: Couldn't set SIGILL\");\n    }\n    if (signal(SIGINT, (void (__cdecl *)(int))crt_sig_handler) == SIG_ERR) {\n        jl_error(\"fatal error: Couldn't set SIGINT\");\n    }\n    if (signal(SIGSEGV, (void (__cdecl *)(int))crt_sig_handler) == SIG_ERR) {\n        jl_error(\"fatal error: Couldn't set SIGSEGV\");\n    }\n    if (signal(SIGTERM, (void (__cdecl *)(int))crt_sig_handler) == SIG_ERR) {\n        jl_error(\"fatal error: Couldn't set SIGTERM\");\n    }\n    if (signal(SIGABRT, (void (__cdecl *)(int))crt_sig_handler) == SIG_ERR) {\n        jl_error(\"fatal error: Couldn't set SIGABRT\");\n    }\n    SetUnhandledExceptionFilter(exception_handler);\n}\n\nvoid jl_install_thread_signal_handler(jl_ptls_t ptls)\n{\n    (void)ptls;\n    // Ensure the stack overflow handler has enough space to collect the backtrace\n    ULONG StackSizeInBytes = sig_stack_size;\n    if (pSetThreadStackGuarantee) {\n        if (!pSetThreadStackGuarantee(&StackSizeInBytes)) {\n            pSetThreadStackGuarantee = NULL;\n        }\n    }\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/signals-mach.c": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n#include <mach/clock.h>\n#include <mach/clock_types.h>\n#include <mach/clock_reply.h>\n#include <mach/mach_traps.h>\n#include <mach/task.h>\n#include <mach/mig_errors.h>\n#include <AvailabilityMacros.h>\n\n#ifdef MAC_OS_X_VERSION_10_9\n#include <sys/_types/_ucontext64.h>\n#else\n#define __need_ucontext64_t\n#include <sys/_structs.h>\n#endif\n\nstatic void attach_exception_port(thread_port_t thread);\n\n#ifdef JULIA_ENABLE_THREADING\n// low 16 bits are the thread id, the next 8 bits are the original gc_state\nstatic arraylist_t suspended_threads;\nvoid jl_mach_gc_end(void)\n{\n    // Requires the safepoint lock to be held\n    for (size_t i = 0;i < suspended_threads.len;i++) {\n        uintptr_t item = (uintptr_t)suspended_threads.items[i];\n        int16_t tid = (int16_t)item;\n        int8_t gc_state = (int8_t)(item >> 8);\n        jl_ptls_t ptls2 = jl_all_tls_states[tid];\n        jl_atomic_store_release(&ptls2->gc_state, gc_state);\n        thread_resume(pthread_mach_thread_np(ptls2->system_id));\n    }\n    suspended_threads.len = 0;\n}\n\n// Suspend the thread and return `1` if the GC is running.\n// Otherwise return `0`\nstatic int jl_mach_gc_wait(jl_ptls_t ptls2,\n                           mach_port_t thread, int16_t tid)\n{\n    jl_mutex_lock_nogc(&safepoint_lock);\n    if (!jl_gc_running) {\n        // GC is done before we get the message or the safepoint is enabled\n        // for SIGINT.\n        jl_mutex_unlock_nogc(&safepoint_lock);\n        return 0;\n    }\n    // Otherwise, set the gc state of the thread, suspend and record it\n    int8_t gc_state = ptls2->gc_state;\n    jl_atomic_store_release(&ptls2->gc_state, JL_GC_STATE_WAITING);\n    uintptr_t item = tid | (((uintptr_t)gc_state) << 16);\n    arraylist_push(&suspended_threads, (void*)item);\n    thread_suspend(thread);\n    jl_mutex_unlock_nogc(&safepoint_lock);\n    return 1;\n}\n#endif\n\nstatic mach_port_t segv_port = 0;\n\nextern boolean_t exc_server(mach_msg_header_t *, mach_msg_header_t *);\n\n#define STR(x) #x\n#define XSTR(x) STR(x)\n#define HANDLE_MACH_ERROR(msg, retval) \\\n    if (retval != KERN_SUCCESS) { mach_error(msg XSTR(: __FILE__:__LINE__:), (retval)); jl_exit(1); }\n\nvoid *mach_segv_listener(void *arg)\n{\n    (void)arg;\n    while (1) {\n        int ret = mach_msg_server(exc_server, 2048, segv_port, MACH_MSG_TIMEOUT_NONE);\n        jl_safe_printf(\"mach_msg_server: %s\\n\", mach_error_string(ret));\n        jl_exit(128 + SIGSEGV);\n    }\n}\n\nstatic void allocate_segv_handler()\n{\n#ifdef JULIA_ENABLE_THREADING\n    arraylist_new(&suspended_threads, jl_n_threads);\n#endif\n    pthread_t thread;\n    pthread_attr_t attr;\n    kern_return_t ret;\n    mach_port_t self = mach_task_self();\n    ret = mach_port_allocate(self, MACH_PORT_RIGHT_RECEIVE, &segv_port);\n    HANDLE_MACH_ERROR(\"mach_port_allocate\",ret);\n    ret = mach_port_insert_right(self, segv_port, segv_port, MACH_MSG_TYPE_MAKE_SEND);\n    HANDLE_MACH_ERROR(\"mach_port_insert_right\",ret);\n    // Alright, create a thread to serve as the listener for exceptions\n    if (pthread_attr_init(&attr) != 0) {\n        jl_error(\"pthread_attr_init failed\");\n    }\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n    if (pthread_create(&thread, &attr, mach_segv_listener, NULL) != 0) {\n        jl_error(\"pthread_create failed\");\n    }\n    pthread_attr_destroy(&attr);\n    for (int16_t tid = 0;tid < jl_n_threads;tid++) {\n        attach_exception_port(pthread_mach_thread_np(jl_all_tls_states[tid]->system_id));\n    }\n}\n\n#ifdef LIBOSXUNWIND\nvolatile mach_port_t mach_profiler_thread = 0;\nstatic kern_return_t profiler_segv_handler\n                (mach_port_t                          exception_port,\n                 mach_port_t                                  thread,\n                 mach_port_t                                    task,\n                 exception_type_t                          exception,\n                 exception_data_t                               code,\n                 mach_msg_type_number_t                   code_count);\n#endif\n\nenum x86_trap_flags {\n    USER_MODE = 0x4,\n    WRITE_FAULT = 0x2,\n    PAGE_PRESENT = 0x1\n};\n\nvoid jl_throw_in_thread(int tid, mach_port_t thread, jl_value_t *exception)\n{\n    unsigned int count = MACHINE_THREAD_STATE_COUNT;\n    x86_thread_state64_t state;\n    kern_return_t ret = thread_get_state(thread, x86_THREAD_STATE64, (thread_state_t)&state, &count);\n    HANDLE_MACH_ERROR(\"thread_get_state\", ret);\n    jl_ptls_t ptls2 = jl_all_tls_states[tid];\n\n    ptls2->bt_size = rec_backtrace_ctx(ptls2->bt_data, JL_MAX_BT_SIZE,\n                                       (bt_context_t*)&state);\n    ptls2->exception_in_transit = exception;\n\n    uint64_t rsp = (uint64_t)ptls2->signal_stack + sig_stack_size;\n    rsp &= -16; // ensure 16-byte alignment\n\n    // push (null) $RIP onto the stack\n    rsp -= sizeof(void*);\n    *(void**)rsp = NULL;\n\n    state.__rsp = rsp; // set stack pointer\n    state.__rip = (uint64_t)&jl_rethrow; // \"call\" the function\n\n    ret = thread_set_state(thread, x86_THREAD_STATE64, (thread_state_t)&state, count);\n    HANDLE_MACH_ERROR(\"thread_set_state\",ret);\n}\n\n//exc_server uses dlsym to find symbol\nJL_DLLEXPORT\nkern_return_t catch_exception_raise(mach_port_t            exception_port,\n                                    mach_port_t            thread,\n                                    mach_port_t            task,\n                                    exception_type_t       exception,\n                                    exception_data_t       code,\n                                    mach_msg_type_number_t code_count)\n{\n    unsigned int count = MACHINE_THREAD_STATE_COUNT;\n    unsigned int exc_count = X86_EXCEPTION_STATE64_COUNT;\n    x86_exception_state64_t exc_state;\n    x86_thread_state64_t state;\n#ifdef LIBOSXUNWIND\n    if (thread == mach_profiler_thread) {\n        return profiler_segv_handler(exception_port, thread, task, exception, code, code_count);\n    }\n#endif\n    int16_t tid;\n#ifdef JULIA_ENABLE_THREADING\n    jl_ptls_t ptls2 = NULL;\n    for (tid = 0;tid < jl_n_threads;tid++) {\n        jl_ptls_t _ptls2 = jl_all_tls_states[tid];\n        if (pthread_mach_thread_np(_ptls2->system_id) == thread) {\n            ptls2 = _ptls2;\n            break;\n        }\n    }\n    if (!ptls2) {\n        // We don't know about this thread, let the kernel try another handler\n        // instead. This shouldn't actually happen since we only register the\n        // handler for the threads we know about.\n        jl_safe_printf(\"ERROR: Exception handler triggered on unmanaged thread.\\n\");\n        return KERN_INVALID_ARGUMENT;\n    }\n#else\n    jl_ptls_t ptls2 = &jl_tls_states;\n    tid = 0;\n#endif\n    kern_return_t ret = thread_get_state(thread, x86_EXCEPTION_STATE64, (thread_state_t)&exc_state, &exc_count);\n    HANDLE_MACH_ERROR(\"thread_get_state\", ret);\n    uint64_t fault_addr = exc_state.__faultvaddr;\n    if (jl_addr_is_safepoint(fault_addr)) {\n#ifdef JULIA_ENABLE_THREADING\n        if (jl_mach_gc_wait(ptls2, thread, tid))\n            return KERN_SUCCESS;\n        if (ptls2->tid != 0)\n            return KERN_SUCCESS;\n#endif\n        if (ptls2->defer_signal) {\n            jl_safepoint_defer_sigint();\n        }\n        else if (jl_safepoint_consume_sigint()) {\n            jl_clear_force_sigint();\n            jl_throw_in_thread(tid, thread, jl_interrupt_exception);\n        }\n        return KERN_SUCCESS;\n    }\n#ifdef SEGV_EXCEPTION\n    if (1) {\n#else\n    if (msync((void*)(fault_addr & ~(jl_page_size - 1)), 1, MS_ASYNC) == 0) { // check if this was a valid address\n#endif\n        jl_value_t *excpt;\n        if (is_addr_on_stack(ptls2, (void*)fault_addr)) {\n            excpt = jl_stackovf_exception;\n        }\n#ifdef SEGV_EXCEPTION\n        else if (msync((void*)(fault_addr & ~(jl_page_size - 1)), 1, MS_ASYNC) != 0) {\n            // no page mapped at this address\n            excpt = jl_segv_exception;\n        }\n#endif\n        else {\n            if (!(exc_state.__err & WRITE_FAULT))\n                return KERN_INVALID_ARGUMENT; // rethrow the SEGV since it wasn't an error with writing to read-only memory\n            excpt = jl_readonlymemory_exception;\n        }\n        jl_throw_in_thread(tid, thread, excpt);\n\n        return KERN_SUCCESS;\n    }\n    else {\n        kern_return_t ret = thread_get_state(thread, x86_THREAD_STATE64, (thread_state_t)&state, &count);\n        HANDLE_MACH_ERROR(\"thread_get_state\", ret);\n        jl_critical_error(SIGSEGV, (unw_context_t*)&state,\n                          ptls2->bt_data, &ptls2->bt_size);\n        return KERN_INVALID_ARGUMENT;\n    }\n}\n\nstatic void attach_exception_port(thread_port_t thread)\n{\n    kern_return_t ret;\n    // http://www.opensource.apple.com/source/xnu/xnu-2782.1.97/osfmk/man/thread_set_exception_ports.html\n    ret = thread_set_exception_ports(thread, EXC_MASK_BAD_ACCESS, segv_port, EXCEPTION_DEFAULT, MACHINE_THREAD_STATE);\n    HANDLE_MACH_ERROR(\"thread_set_exception_ports\", ret);\n}\n\nstatic void jl_thread_suspend_and_get_state(int tid, unw_context_t **ctx)\n{\n    jl_ptls_t ptls2 = jl_all_tls_states[tid];\n    mach_port_t tid_port = pthread_mach_thread_np(ptls2->system_id);\n\n    kern_return_t ret = thread_suspend(tid_port);\n    HANDLE_MACH_ERROR(\"thread_suspend\", ret);\n\n    // Do the actual sampling\n    unsigned int count = MACHINE_THREAD_STATE_COUNT;\n    static unw_context_t state;\n    memset(&state, 0, sizeof(unw_context_t));\n\n    // Get the state of the suspended thread\n    ret = thread_get_state(tid_port, x86_THREAD_STATE64, (thread_state_t)&state, &count);\n\n    // Initialize the unwind context with the suspend thread's state\n    *ctx = &state;\n}\n\nstatic void jl_thread_resume(int tid, int sig)\n{\n    jl_ptls_t ptls2 = jl_all_tls_states[tid];\n    mach_port_t thread = pthread_mach_thread_np(ptls2->system_id);\n    kern_return_t ret = thread_resume(thread);\n    HANDLE_MACH_ERROR(\"thread_resume\", ret);\n}\n\n// Throw jl_interrupt_exception if the master thread is in a signal async region\n// or if SIGINT happens too often.\nstatic void jl_try_deliver_sigint(void)\n{\n    jl_ptls_t ptls2 = jl_all_tls_states[0];\n    mach_port_t thread = pthread_mach_thread_np(ptls2->system_id);\n\n    kern_return_t ret = thread_suspend(thread);\n    HANDLE_MACH_ERROR(\"thread_suspend\", ret);\n\n    // This aborts `sleep` and other syscall.\n    ret = thread_abort(thread);\n    HANDLE_MACH_ERROR(\"thread_abort\", ret);\n\n    jl_safepoint_enable_sigint();\n    int force = jl_check_force_sigint();\n    if (force || (!ptls2->defer_signal && ptls2->io_wait)) {\n        jl_safepoint_consume_sigint();\n        if (force)\n            jl_safe_printf(\"WARNING: Force throwing a SIGINT\\n\");\n        jl_clear_force_sigint();\n        jl_throw_in_thread(0, thread, jl_interrupt_exception);\n    }\n    else {\n        jl_wake_libuv();\n    }\n\n    ret = thread_resume(thread);\n    HANDLE_MACH_ERROR(\"thread_resume\", ret);\n}\n\nstatic int profile_started = 0;\nmach_timespec_t timerprof;\nstatic pthread_t profiler_thread;\nclock_serv_t clk;\nstatic mach_port_t profile_port = 0;\n\n#ifdef LIBOSXUNWIND\nvolatile static int forceDwarf = -2;\nstatic unw_context_t profiler_uc;\n\nstatic kern_return_t profiler_segv_handler\n                (mach_port_t                          exception_port,\n                 mach_port_t                                  thread,\n                 mach_port_t                                    task,\n                 exception_type_t                          exception,\n                 exception_data_t                               code,\n                 mach_msg_type_number_t                   code_count)\n{\n    assert(thread == mach_profiler_thread);\n    x86_thread_state64_t state;\n\n    // Not currently unwinding. Raise regular segfault\n    if (forceDwarf == -2)\n        return KERN_INVALID_ARGUMENT;\n\n    if (forceDwarf == 0)\n        forceDwarf = 1;\n    else\n        forceDwarf = -1;\n\n    unsigned int count = MACHINE_THREAD_STATE_COUNT;\n\n    thread_get_state(thread, x86_THREAD_STATE64, (thread_state_t)&state, &count);\n\n    // don't change cs fs gs rflags\n    uint64_t cs = state.__cs;\n    uint64_t fs = state.__fs;\n    uint64_t gs = state.__gs;\n    uint64_t rflags = state.__rflags;\n\n    memcpy(&state, &profiler_uc, sizeof(x86_thread_state64_t));\n\n    state.__cs = cs;\n    state.__fs = fs;\n    state.__gs = gs;\n    state.__rflags = rflags;\n\n    kern_return_t ret = thread_set_state(thread, x86_THREAD_STATE64, (thread_state_t)&state, count);\n    HANDLE_MACH_ERROR(\"thread_set_state\", ret);\n\n    return KERN_SUCCESS;\n}\n#endif\n\nvoid *mach_profile_listener(void *arg)\n{\n    (void)arg;\n    int i;\n    const int max_size = 512;\n    attach_exception_port(mach_thread_self());\n#ifdef LIBOSXUNWIND\n    mach_profiler_thread = mach_thread_self();\n#endif\n    mig_reply_error_t *bufRequest = (mig_reply_error_t *) malloc(max_size);\n    while (1) {\n        kern_return_t ret = mach_msg(&bufRequest->Head, MACH_RCV_MSG,\n                                     0, max_size, profile_port,\n                                     MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);\n        HANDLE_MACH_ERROR(\"mach_msg\", ret);\n        // sample each thread, round-robin style in reverse order\n        // (so that thread zero gets notified last)\n        for (i = jl_n_threads; i-- > 0; ) {\n            // if there is no space left, break early\n            if (bt_size_cur >= bt_size_max - 1)\n                break;\n\n            unw_context_t *uc;\n            jl_thread_suspend_and_get_state(i, &uc);\n\n#ifdef LIBOSXUNWIND\n            /*\n             *  Unfortunately compact unwind info is incorrectly generated for quite a number of\n             *  libraries by quite a large number of compilers. We can fall back to DWARF unwind info\n             *  in some cases, but in quite a number of cases (especially libraries not compiled in debug\n             *  mode, only the compact unwind info may be available). Even more unfortunately, there is no\n             *  way to detect such bogus compact unwind info (other than noticing the resulting segfault).\n             *  What we do here is ugly, but necessary until the compact unwind info situation improves.\n             *  We try to use the compact unwind info and if that results in a segfault, we retry with DWARF info.\n             *  Note that in a small number of cases this may result in bogus stack traces, but at least the topmost\n             *  entry will always be correct, and the number of cases in which this is an issue is rather small.\n             *  Other than that, this implementation is not incorrect as the other thread is paused while we are profiling\n             *  and during stack unwinding we only ever read memory, but never write it.\n             */\n\n            forceDwarf = 0;\n            unw_getcontext(&profiler_uc); // will resume from this point if the next lines segfault at any point\n\n            if (forceDwarf == 0) {\n                // Save the backtrace\n                bt_size_cur += rec_backtrace_ctx((uintptr_t*)bt_data_prof + bt_size_cur, bt_size_max - bt_size_cur - 1, uc);\n            }\n            else if (forceDwarf == 1) {\n                bt_size_cur += rec_backtrace_ctx_dwarf((uintptr_t*)bt_data_prof + bt_size_cur, bt_size_max - bt_size_cur - 1, uc);\n            }\n            else if (forceDwarf == -1) {\n                jl_safe_printf(\"WARNING: profiler attempt to access an invalid memory location\\n\");\n            }\n\n            forceDwarf = -2;\n#else\n            bt_size_cur += rec_backtrace_ctx((uintptr_t*)bt_data_prof + bt_size_cur, bt_size_max - bt_size_cur - 1, uc);\n#endif\n\n            // Mark the end of this block with 0\n            bt_data_prof[bt_size_cur++] = 0;\n\n            // We're done! Resume the thread.\n            jl_thread_resume(i, 0);\n\n            if (running) {\n                // Reset the alarm\n                kern_return_t ret = clock_alarm(clk, TIME_RELATIVE, timerprof, profile_port);\n                HANDLE_MACH_ERROR(\"clock_alarm\", ret)\n            }\n        }\n    }\n}\n\nJL_DLLEXPORT int jl_profile_start_timer(void)\n{\n    kern_return_t ret;\n    if (!profile_started) {\n        mach_port_t self = mach_task_self();\n\n        ret = host_get_clock_service(mach_host_self(), SYSTEM_CLOCK, (clock_serv_t *)&clk);\n        HANDLE_MACH_ERROR(\"host_get_clock_service\", ret);\n\n        ret = mach_port_allocate(self, MACH_PORT_RIGHT_RECEIVE, &profile_port);\n        HANDLE_MACH_ERROR(\"mach_port_allocate\", ret);\n\n        // Alright, create a thread to serve as the listener for exceptions\n        pthread_attr_t attr;\n        if (pthread_attr_init(&attr) != 0) {\n            jl_error(\"pthread_attr_init failed\");\n        }\n        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n        if (pthread_create(&profiler_thread, &attr, mach_profile_listener, NULL) != 0) {\n            jl_error(\"pthread_create failed\");\n        }\n        pthread_attr_destroy(&attr);\n\n        profile_started = 1;\n    }\n\n    timerprof.tv_sec = nsecprof/GIGA;\n    timerprof.tv_nsec = nsecprof%GIGA;\n\n    running = 1;\n    ret = clock_alarm(clk, TIME_RELATIVE, timerprof, profile_port);\n    HANDLE_MACH_ERROR(\"clock_alarm\", ret);\n\n    return 0;\n}\n\nJL_DLLEXPORT void jl_profile_stop_timer(void)\n{\n    running = 0;\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/runtime_ccall.cpp": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n#include <map>\n#include <string>\n#include <cstdio>\n#include <llvm/Support/Host.h>\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"llvm-version.h\"\nusing namespace llvm;\n\n// --- library symbol lookup ---\n\n// map from \"libX\" to full soname \"libX.so.ver\"\n#if defined(__linux__) || defined(__FreeBSD__)\nstatic uv_rwlock_t soname_lock;\nstatic std::map<std::string, std::string> sonameMap;\nstatic bool got_sonames = false;\n\nextern \"C\" void jl_init_runtime_ccall(void)\n{\n    uv_rwlock_init(&soname_lock);\n}\n\n// This reloads the sonames, necessary after system upgrade.\n// Keep this DLLEXPORTed, this is used by `BinDeps.jl` to make sure\n// newly installed libraries can be found.\nextern \"C\" JL_DLLEXPORT void jl_read_sonames(void)\n{\n    char *line=NULL;\n    size_t sz=0;\n#if defined(__linux__)\n    FILE *ldc = popen(\"/sbin/ldconfig -p\", \"r\");\n#else\n    FILE *ldc = popen(\"/sbin/ldconfig -r\", \"r\");\n#endif\n    if (ldc == NULL) return; // ignore errors in running ldconfig (other than whatever might have been printed to stderr)\n\n    // This loop is not allowed to call julia GC while holding the lock\n    uv_rwlock_wrlock(&soname_lock);\n    sonameMap.clear();\n    while (!feof(ldc)) {\n        ssize_t n = getline(&line, &sz, ldc);\n        if (n == -1)\n            break;\n        if (n > 2 && isspace((unsigned char)line[0])) {\n#ifdef __linux__\n            int i = 0;\n            while (isspace((unsigned char)line[++i])) ;\n            char *name = &line[i];\n            char *dot = strstr(name, \".so\");\n            i = 0;\n#else\n            char *name = strstr(line, \":-l\");\n            if (name == NULL) continue;\n            strncpy(name, \"lib\", 3);\n            char *dot = strchr(name, '.');\n#endif\n\n            if (NULL == dot)\n                continue;\n\n#ifdef __linux__\n            // Detect if this entry is for the current architecture\n            while (!isspace((unsigned char)dot[++i])) ;\n            while (isspace((unsigned char)dot[++i])) ;\n            int j = i;\n            while (!isspace((unsigned char)dot[++j])) ;\n            char *arch = strstr(dot+i,\"x86-64\");\n            if (arch != NULL && arch < dot + j) {\n#ifdef _P32\n                continue;\n#endif\n            }\n            else {\n#ifdef _P64\n                continue;\n#endif\n            }\n#endif // __linux__\n\n            char *abslibpath = strrchr(line, ' ');\n            if (dot != NULL && abslibpath != NULL) {\n                std::string pfx(name, dot - name);\n                // Do not include ' ' in front and '\\n' at the end\n                std::string soname(abslibpath+1, line+n-(abslibpath+1)-1);\n                sonameMap[pfx] = soname;\n            }\n        }\n    }\n\n    free(line);\n    pclose(ldc);\n    uv_rwlock_wrunlock(&soname_lock);\n}\n\n// This API is not thread safe. The return value can be free'd if\n// `jl_read_sonames()` is called on another thread.\nextern \"C\" JL_DLLEXPORT const char *jl_lookup_soname(const char *pfx, size_t n)\n{\n    if (!got_sonames) {\n        jl_read_sonames();\n        got_sonames = true;\n    }\n    const char *res = nullptr;\n    uv_rwlock_rdlock(&soname_lock);\n    auto search = sonameMap.find(std::string(pfx, n));\n    if (search != sonameMap.end())\n        res = search->second.c_str();\n    uv_rwlock_rdunlock(&soname_lock);\n    return res;\n}\n\nextern \"C\" void *jl_dlopen_soname(const char *pfx, size_t n, unsigned flags)\n{\n    if (!got_sonames) {\n        jl_read_sonames();\n        got_sonames = true;\n    }\n    void *res = nullptr;\n    uv_rwlock_rdlock(&soname_lock);\n    auto search = sonameMap.find(std::string(pfx, n));\n    if (search != sonameMap.end())\n        res = jl_dlopen(search->second.c_str(), flags);\n    uv_rwlock_rdunlock(&soname_lock);\n    return res;\n}\n#else\nextern \"C\" void jl_init_runtime_ccall(void)\n{\n}\n#endif\n\n// map from user-specified lib names to handles\nstatic std::map<std::string, void*> libMap;\n\nextern \"C\"\nvoid *jl_get_library(const char *f_lib)\n{\n    void *hnd;\n#ifdef _OS_WINDOWS_\n    if ((intptr_t)f_lib == 1)\n        return jl_exe_handle;\n    if ((intptr_t)f_lib == 2)\n        return jl_dl_handle;\n#endif\n    if (f_lib == NULL)\n        return jl_RTLD_DEFAULT_handle;\n    hnd = libMap[f_lib];\n    if (hnd != NULL)\n        return hnd;\n    hnd = jl_load_dynamic_library(f_lib, JL_RTLD_DEFAULT);\n    if (hnd != NULL)\n        libMap[f_lib] = hnd;\n    return hnd;\n}\n\nextern \"C\" JL_DLLEXPORT\nvoid *jl_load_and_lookup(const char *f_lib, const char *f_name, void **hnd)\n{\n    void *handle = *hnd;\n    if (!handle)\n        *hnd = handle = jl_get_library(f_lib);\n    return jl_dlsym(handle, f_name);\n}\n\n// miscellany\nextern \"C\" JL_DLLEXPORT\njl_value_t *jl_get_cpu_name(void)\n{\n#ifdef LLVM35\n    StringRef HostCPUName = llvm::sys::getHostCPUName();\n#else\n    const std::string& HostCPUName = llvm::sys::getHostCPUName();\n#endif\n    return jl_pchar_to_string(HostCPUName.data(), HostCPUName.size());\n}\n\nextern \"C\" JL_DLLEXPORT\njl_value_t *jl_get_JIT(void)\n{\n#if defined(USE_ORCJIT)\n    const std::string& HostJITName = \"ORCJIT\";\n#elif defined(USE_MCJIT)\n    const std::string& HostJITName = \"MCJIT\";\n#else\n    const std::string& HostJITName = \"Unknown\";\n#endif\n    return jl_pchar_to_string(HostJITName.data(), HostJITName.size());\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/julia.h": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n#ifndef JULIA_H\n#define JULIA_H\n\n//** Configuration options that affect the Julia ABI **//\n// if this is not defined, only individual dimension sizes are\n// stored and not total length, to save space.\n#define STORE_ARRAY_LEN\n//** End Configuration options **//\n\n#include \"libsupport.h\"\n#include <stdint.h>\n#include <string.h>\n\n#include \"htable.h\"\n#include \"arraylist.h\"\n\n#include <setjmp.h>\n#ifndef _OS_WINDOWS_\n#  define jl_jmp_buf sigjmp_buf\n#  if defined(_CPU_ARM_) || defined(_CPU_PPC_)\n#    define MAX_ALIGN 8\n#  elif defined(_CPU_AARCH64_)\n// int128 is 16 bytes aligned on aarch64\n#    define MAX_ALIGN 16\n#  else\n#    define MAX_ALIGN sizeof(void*)\n#  endif\n#else\n#  define jl_jmp_buf jmp_buf\n#  include <malloc.h> //for _resetstkoflw\n#  define MAX_ALIGN 8\n#endif\n\n#ifdef _P64\n#define NWORDS(sz) (((sz)+7)>>3)\n#else\n#define NWORDS(sz) (((sz)+3)>>2)\n#endif\n\n#if defined(__GNUC__)\n#  define JL_NORETURN __attribute__ ((noreturn))\n#  define JL_CONST_FUNC __attribute__((const))\n#elif defined(_COMPILER_MICROSOFT_)\n#  define JL_NORETURN __declspec(noreturn)\n// This is the closest I can find for __attribute__((const))\n#  define JL_CONST_FUNC __declspec(noalias)\n#else\n#  define JL_NORETURN\n#  define JL_CONST_FUNC\n#endif\n\n#define container_of(ptr, type, member) \\\n    ((type *) ((char *)(ptr) - offsetof(type, member)))\n\ntypedef struct _jl_taggedvalue_t jl_taggedvalue_t;\n\n#include <julia_threads.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// core data types ------------------------------------------------------------\n\n// the common fields are hidden before the pointer, but the following macro is\n// used to indicate which types below are subtypes of jl_value_t\n#define JL_DATA_TYPE\n\ntypedef struct _jl_value_t jl_value_t;\n\nstruct _jl_taggedvalue_bits {\n    uintptr_t gc:2;\n};\n\nstruct _jl_taggedvalue_t {\n    union {\n        uintptr_t header;\n        jl_taggedvalue_t *next;\n        jl_value_t *type; // 16-byte aligned\n        struct _jl_taggedvalue_bits bits;\n    };\n    // jl_value_t value;\n};\n\n#define jl_astaggedvalue(v)                                             \\\n    ((jl_taggedvalue_t*)((char*)(v) - sizeof(jl_taggedvalue_t)))\n#define jl_valueof(v)                                           \\\n    ((jl_value_t*)((char*)(v) + sizeof(jl_taggedvalue_t)))\n#define jl_typeof(v)                                                    \\\n    ((jl_value_t*)(jl_astaggedvalue(v)->header & ~(uintptr_t)15))\nstatic inline void jl_set_typeof(void *v, void *t)\n{\n    // Do not call this on a value that is already initialized.\n    jl_taggedvalue_t *tag = jl_astaggedvalue(v);\n    tag->type = (jl_value_t*)t;\n}\n#define jl_typeis(v,t) (jl_typeof(v)==(jl_value_t*)(t))\n\n// Symbols are interned strings (hash-consed) stored as an invasive binary tree.\n// The string data is nul-terminated and hangs off the end of the struct.\ntypedef struct _jl_sym_t {\n    JL_DATA_TYPE\n    struct _jl_sym_t *left;\n    struct _jl_sym_t *right;\n    uintptr_t hash;    // precomputed hash value\n    // JL_ATTRIBUTE_ALIGN_PTRSIZE(char name[]);\n} jl_sym_t;\n\n// A numbered SSA value, for optimized code analysis and generation\n// the `id` is a unique, small number\ntypedef struct _jl_ssavalue_t {\n    JL_DATA_TYPE\n    ssize_t id;\n} jl_ssavalue_t;\n\n// A SimpleVector is an immutable pointer array\n// Data is stored at the end of this variable-length struct.\ntypedef struct {\n    JL_DATA_TYPE\n    size_t length;\n    // pointer size aligned\n    // jl_value_t *data[];\n} jl_svec_t;\n\ntypedef struct {\n    /*\n      how - allocation style\n      0 = data is inlined, or a foreign pointer we don't manage\n      1 = julia-allocated buffer that needs to be marked\n      2 = malloc-allocated pointer this array object manages\n      3 = has a pointer to the Array that owns the data\n    */\n    uint16_t how:2;\n    uint16_t ndims:10;\n    uint16_t pooled:1;\n    uint16_t ptrarray:1;  // representation is pointer array\n    uint16_t isshared:1;  // data is shared by multiple Arrays\n    uint16_t isaligned:1; // data allocated with memalign\n} jl_array_flags_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    void *data;\n#ifdef STORE_ARRAY_LEN\n    size_t length;\n#endif\n    jl_array_flags_t flags;\n    uint16_t elsize;\n    uint32_t offset;  // for 1-d only. does not need to get big.\n    size_t nrows;\n    union {\n        // 1d\n        size_t maxsize;\n        // Nd\n        size_t ncols;\n    };\n    // other dim sizes go here for ndims > 2\n\n    // followed by alignment padding and inline data, or owner pointer\n} jl_array_t;\n\n// compute # of extra words needed to store dimensions\nSTATIC_INLINE int jl_array_ndimwords(uint32_t ndims)\n{\n    return (ndims < 3 ? 0 : ndims-2);\n}\n\ntypedef struct _jl_datatype_t jl_tupletype_t;\nstruct _jl_lambda_info_t;\n\n// TypeMap is an implicitly defined type\n// that can consist of any of the following nodes:\n//   typedef TypeMap Union{TypeMapLevel, TypeMapEntry, Void}\n// it forms a roughly tree-shaped structure, consisting of nodes of TypeMapLevels\n// which split the tree when possible, for example based on the key into the tuple type at `offs`\n// when key is a leaftype, (but only when the tree has enough entries for this to be\n// more efficient than storing them sorted linearly)\n// otherwise the leaf entries are stored sorted, linearly\nunion jl_typemap_t {\n    struct _jl_typemap_level_t *node;\n    struct _jl_typemap_entry_t *leaf;\n    struct _jl_value_t *unknown; // nothing\n};\n\n// \"jlcall\" calling convention signatures.\n// This defines the default ABI used by compiled julia functions.\ntypedef jl_value_t *(*jl_fptr_t)(jl_value_t*, jl_value_t**, uint32_t);\ntypedef jl_value_t *(*jl_fptr_sparam_t)(jl_svec_t*, jl_value_t*, jl_value_t**, uint32_t);\ntypedef jl_value_t *(*jl_fptr_linfo_t)(struct _jl_lambda_info_t*, jl_value_t**, uint32_t, jl_svec_t*);\n\ntypedef struct _jl_llvm_functions_t {\n    void *functionObject;     // jlcall llvm Function\n    void *specFunctionObject; // specialized llvm Function\n} jl_llvm_functions_t;\n\n// This type describes a single method definition, and stores data\n// shared by the specializations of a function.\ntypedef struct _jl_method_t {\n    JL_DATA_TYPE\n    jl_sym_t *name;  // for error reporting\n    struct _jl_module_t *module;\n    jl_sym_t *file;\n    int32_t line;\n\n    // method's type signature. partly redundant with lambda_template->specTypes\n    jl_tupletype_t *sig;\n    // bound type variables (static parameters). redundant with TypeMapEntry->tvars\n    jl_svec_t *tvars;\n    // list of potentially-ambiguous methods (nothing = none, Vector{Any} of Methods otherwise)\n    jl_value_t *ambig;\n\n    // table of all argument types for which we've inferred or compiled this code\n    union jl_typemap_t specializations;\n\n    // the AST template (or, for isstaged, code for the generator)\n    struct _jl_lambda_info_t *lambda_template;\n    jl_array_t *roots;  // pointers in generated code (shared to reduce memory)\n\n    // cache of specializations of this method for invoke(), i.e.\n    // cases where this method was called even though it was not necessarily\n    // the most specific for the argument types.\n    union jl_typemap_t invokes;\n\n    int32_t called;  // bit flags: whether each of the first 8 arguments is called\n    int8_t isstaged;\n    // if there are intrinsic calls, sparams are probably required to compile successfully,\n    // and so unspecialized will be created for each linfo instead of using linfo->def->template\n    // 0 = no, 1 = yes, 2 = not yet known\n    uint8_t needs_sparam_vals_ducttape;\n    uint8_t traced;\n\n// hidden fields:\n    // lock for modifications to the method\n    jl_mutex_t writelock;\n} jl_method_t;\n\n// This holds data for a single executable function body:\n// code in Julia IR, static parameters, and (if it has been compiled)\n// a function pointer.\ntypedef struct _jl_lambda_info_t {\n    JL_DATA_TYPE\n    jl_value_t *rettype;\n    jl_svec_t *sparam_syms; // sparams is a vector of values indexed by symbols\n    jl_svec_t *sparam_vals;\n    jl_tupletype_t *specTypes;  // argument types this was specialized for\n    jl_value_t *code;  // compressed uint8 array, or Any array of statements\n    jl_value_t *slottypes;\n    jl_value_t *ssavaluetypes;  // types of ssa values\n    jl_array_t *slotnames; // names of local variables\n    jl_array_t *slotflags;  // local var bit flags\n    struct _jl_lambda_info_t *unspecialized_ducttape; // if template can't be compiled due to intrinsics, an un-inferred executable copy may get stored here\n    jl_method_t *def; // method this is specialized from, (null if this is a toplevel thunk)\n    jl_value_t *constval;  // value of the function if jlcall_api==2\n    int32_t nargs;\n    int8_t isva;\n    int8_t inferred;\n    int8_t pure;\n    int8_t inlineable;\n    int8_t inInference; // flags to tell if inference is running on this function\n    int8_t inCompile; // flag to tell if codegen is running on this function\n    int8_t jlcall_api; // the c-abi for fptr; 0 = jl_fptr_t, 1 = jl_fptr_sparam_t, 2 = constval\n    int8_t compile_traced; // if set will notify callback if this linfo is compiled\n    jl_fptr_t fptr; // jlcall entry point\n\n// hidden fields:\n    // On the old JIT, handles to all Functions generated for this linfo\n    // For the new JITs, handles to declarations in the shadow module\n    // with the same name as the generated functions for this linfo, suitable\n    // for referencing in LLVM IR\n    jl_llvm_functions_t functionObjectsDecls;\n} jl_lambda_info_t;\n\n// all values are callable as Functions\ntypedef jl_value_t jl_function_t;\n\n// a TypeConstructor (typealias)\n// for example, Vector{T}:\n//   body is the Vector{T} <: Type\n//   parameters is the set {T}, the bound TypeVars in body\ntypedef struct {\n    JL_DATA_TYPE\n    jl_svec_t *parameters;\n    jl_value_t *body;\n} jl_typector_t;\n\n// represents the \"name\" part of a DataType, describing the syntactic structure\n// of a type and storing all data common to different instantiations of the type,\n// including a cache for hash-consed allocation of DataType objects.\ntypedef struct {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    struct _jl_module_t *module;\n    jl_svec_t *names;  // field names\n    // if this is the name of a parametric type, this field points to the\n    // original type.\n    // a type alias, for example, might make a type constructor that is\n    // not the original.\n    jl_value_t *primary;\n    jl_svec_t *cache;        // sorted array\n    jl_svec_t *linearcache;  // unsorted array\n    intptr_t hash;\n    struct _jl_methtable_t *mt;\n} jl_typename_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_svec_t *types;\n} jl_uniontype_t;\n\n// in little-endian, isptr is always the first bit, avoiding the need for a branch in computing isptr\ntypedef struct {\n    uint8_t isptr:1;\n    uint8_t size:7;\n    uint8_t offset;   // offset relative to data start, excluding type tag\n} jl_fielddesc8_t;\n\ntypedef struct {\n    uint16_t isptr:1;\n    uint16_t size:15;\n    uint16_t offset;   // offset relative to data start, excluding type tag\n} jl_fielddesc16_t;\n\ntypedef struct {\n    uint32_t isptr:1;\n    uint32_t size:31;\n    uint32_t offset;   // offset relative to data start, excluding type tag\n} jl_fielddesc32_t;\n\ntypedef struct {\n    uint32_t nfields;\n    uint32_t alignment : 28;  // strictest alignment over all fields\n    uint32_t haspadding : 1;  // has internal undefined bytes\n    uint32_t pointerfree : 1; // has any julia gc pointers\n    uint32_t fielddesc_type : 2; // 0 -> 8, 1 -> 16, 2 -> 32\n    // union {\n    //     jl_fielddesc8_t field8[];\n    //     jl_fielddesc16_t field16[];\n    //     jl_fielddesc32_t field32[];\n    // };\n} jl_datatype_layout_t;\n\ntypedef struct _jl_datatype_t {\n    JL_DATA_TYPE\n    jl_typename_t *name;\n    struct _jl_datatype_t *super;\n    jl_svec_t *parameters;\n    jl_svec_t *types;\n    jl_value_t *instance;  // for singletons\n    const jl_datatype_layout_t *layout;\n    int32_t size; // TODO: move to _jl_datatype_layout_t\n    int32_t ninitialized;\n    uint32_t uid;\n    uint8_t abstract;\n    uint8_t mutabl;\n    // memoized properties\n    void *struct_decl;  //llvm::Type*\n    void *ditype; // llvm::MDNode* to be used as llvm::DIType(ditype)\n    int32_t depth;\n    int8_t hastypevars; // bound\n    int8_t haswildcard; // unbound\n    int8_t isleaftype;\n} jl_datatype_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    jl_value_t *lb;   // lower bound\n    jl_value_t *ub;   // upper bound\n    uint8_t bound;    // part of a constraint environment\n} jl_tvar_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_value_t *value;\n} jl_weakref_t;\n\ntypedef struct {\n    // not first-class\n    jl_sym_t *name;\n    jl_value_t *value;\n    jl_value_t *globalref;  // cached GlobalRef for this binding\n    struct _jl_module_t *owner;  // for individual imported bindings\n    unsigned constp:1;\n    unsigned exportp:1;\n    unsigned imported:1;\n    unsigned deprecated:1;\n} jl_binding_t;\n\ntypedef struct _jl_module_t {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    struct _jl_module_t *parent;\n    htable_t bindings;\n    arraylist_t usings;  // modules with all bindings potentially imported\n    uint8_t istopmod;\n    uint64_t uuid;\n    uint32_t counter;\n} jl_module_t;\n\n// one Type-to-Value entry\ntypedef struct _jl_typemap_entry_t {\n    JL_DATA_TYPE\n    struct _jl_typemap_entry_t *next; // invasive linked list\n    jl_tupletype_t *sig; // the type signature for this entry\n    jl_svec_t *tvars; // the bound type variables for sig\n    jl_tupletype_t *simplesig; // a simple signature for fast rejection\n    jl_svec_t *guardsigs;\n    union {\n        jl_value_t *value;\n        jl_lambda_info_t *linfo; // [nullable] for guard entries\n        jl_method_t *method;\n    } func;\n    // memoized properties of sig:\n    int8_t isleafsig; // isleaftype(sig) & !any(isType, sig) : unsorted and very fast\n    int8_t issimplesig; // all(isleaftype | isAny | isType | isVararg, sig) : sorted and fast\n    int8_t va; // isVararg(sig)\n} jl_typemap_entry_t;\n\n// one level in a TypeMap tree\n// indexed by key if it is a sublevel in an array\nstruct jl_ordereddict_t {\n    jl_array_t *indexes; // Array{Int{8,16,32}}\n    jl_array_t *values; // Array{union jl_typemap_t}\n};\ntypedef struct _jl_typemap_level_t {\n    JL_DATA_TYPE\n    struct jl_ordereddict_t arg1;\n    struct jl_ordereddict_t targ;\n    jl_typemap_entry_t *linear; // union jl_typemap_t (but no more levels)\n    union jl_typemap_t any; // type at offs is Any\n    jl_value_t *key; // [nullable]\n} jl_typemap_level_t;\n\n// contains the TypeMap for one Type\ntypedef struct _jl_methtable_t {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    union jl_typemap_t defs;\n    union jl_typemap_t cache;\n    intptr_t max_args;  // max # of non-vararg arguments in a signature\n    jl_value_t *kwsorter;  // keyword argument sorter function\n    jl_module_t *module; // used for incremental serialization to locate original binding\n    jl_mutex_t writelock;\n} jl_methtable_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_sym_t *head;\n    jl_array_t *args;\n    jl_value_t *etype;\n} jl_expr_t;\n\n// constants and type objects -------------------------------------------------\n\nextern JL_DLLEXPORT jl_datatype_t *jl_any_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_type_type;\nextern JL_DLLEXPORT jl_tvar_t     *jl_typetype_tvar;\nextern JL_DLLEXPORT jl_datatype_t *jl_typetype_type;\nextern JL_DLLEXPORT jl_value_t    *jl_ANY_flag;\nextern JL_DLLEXPORT jl_datatype_t *jl_typename_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_typector_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_sym_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_symbol_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_ssavalue_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_abstractslot_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_slotnumber_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_typedslot_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_simplevector_type;\nextern JL_DLLEXPORT jl_typename_t *jl_tuple_typename;\nextern JL_DLLEXPORT jl_typename_t *jl_vecelement_typename;\nextern JL_DLLEXPORT jl_datatype_t *jl_anytuple_type;\n#define jl_tuple_type jl_anytuple_type\nextern JL_DLLEXPORT jl_datatype_t *jl_anytuple_type_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_vararg_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_tvar_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_task_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_function_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_builtin_type;\n\nextern JL_DLLEXPORT jl_datatype_t *jl_uniontype_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_datatype_type;\n\nextern JL_DLLEXPORT jl_value_t *jl_bottom_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_lambda_info_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_method_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_module_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_abstractarray_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_densearray_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_array_type;\nextern JL_DLLEXPORT jl_typename_t *jl_array_typename;\nextern JL_DLLEXPORT jl_datatype_t *jl_weakref_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_string_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_errorexception_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_argumenterror_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_loaderror_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_initerror_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_typeerror_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_methoderror_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_undefvarerror_type;\nextern JL_DLLEXPORT jl_value_t *jl_stackovf_exception;\nextern JL_DLLEXPORT jl_value_t *jl_memory_exception;\nextern JL_DLLEXPORT jl_value_t *jl_readonlymemory_exception;\nextern JL_DLLEXPORT jl_value_t *jl_diverror_exception;\nextern JL_DLLEXPORT jl_value_t *jl_domain_exception;\nextern JL_DLLEXPORT jl_value_t *jl_overflow_exception;\nextern JL_DLLEXPORT jl_value_t *jl_inexact_exception;\nextern JL_DLLEXPORT jl_value_t *jl_undefref_exception;\nextern JL_DLLEXPORT jl_value_t *jl_interrupt_exception;\nextern JL_DLLEXPORT jl_datatype_t *jl_boundserror_type;\nextern JL_DLLEXPORT jl_value_t *jl_an_empty_vec_any;\n\nextern JL_DLLEXPORT jl_datatype_t *jl_bool_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_char_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_int8_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_uint8_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_int16_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_uint16_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_int32_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_uint32_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_int64_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_uint64_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_float16_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_float32_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_float64_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_floatingpoint_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_number_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_void_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_complex_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_signed_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_voidpointer_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_pointer_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_ref_type;\n\nextern JL_DLLEXPORT jl_value_t *jl_array_uint8_type;\nextern JL_DLLEXPORT jl_value_t *jl_array_any_type;\nextern JL_DLLEXPORT jl_value_t *jl_array_symbol_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_expr_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_globalref_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_linenumbernode_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_labelnode_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_gotonode_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_quotenode_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_newvarnode_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_intrinsic_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_methtable_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_typemap_level_type;\nextern JL_DLLEXPORT jl_datatype_t *jl_typemap_entry_type;\n\nextern JL_DLLEXPORT jl_svec_t *jl_emptysvec;\nextern JL_DLLEXPORT jl_value_t *jl_emptytuple;\nextern JL_DLLEXPORT jl_value_t *jl_true;\nextern JL_DLLEXPORT jl_value_t *jl_false;\nextern JL_DLLEXPORT jl_value_t *jl_nothing;\n\n// some important symbols\nextern jl_sym_t *call_sym;    extern jl_sym_t *invoke_sym;\nextern jl_sym_t *empty_sym;   extern jl_sym_t *body_sym;\nextern jl_sym_t *dots_sym;    extern jl_sym_t *vararg_sym;\nextern jl_sym_t *quote_sym;   extern jl_sym_t *newvar_sym;\nextern jl_sym_t *top_sym;     extern jl_sym_t *dot_sym;\nextern jl_sym_t *line_sym;    extern jl_sym_t *toplevel_sym;\nextern jl_sym_t *core_sym;    extern jl_sym_t *globalref_sym;\nextern JL_DLLEXPORT jl_sym_t *jl_incomplete_sym;\nextern jl_sym_t *error_sym;   extern jl_sym_t *amp_sym;\nextern jl_sym_t *module_sym;  extern jl_sym_t *colons_sym;\nextern jl_sym_t *export_sym;  extern jl_sym_t *import_sym;\nextern jl_sym_t *importall_sym; extern jl_sym_t *using_sym;\nextern jl_sym_t *goto_sym;    extern jl_sym_t *goto_ifnot_sym;\nextern jl_sym_t *label_sym;   extern jl_sym_t *return_sym;\nextern jl_sym_t *lambda_sym;  extern jl_sym_t *assign_sym;\nextern jl_sym_t *method_sym;  extern jl_sym_t *slot_sym;\nextern jl_sym_t *enter_sym;   extern jl_sym_t *leave_sym;\nextern jl_sym_t *exc_sym;     extern jl_sym_t *new_sym;\nextern jl_sym_t *compiler_temp_sym;\nextern jl_sym_t *const_sym;   extern jl_sym_t *thunk_sym;\nextern jl_sym_t *anonymous_sym;  extern jl_sym_t *underscore_sym;\nextern jl_sym_t *abstracttype_sym; extern jl_sym_t *bitstype_sym;\nextern jl_sym_t *compositetype_sym;\nextern jl_sym_t *global_sym; extern jl_sym_t *unused_sym;\nextern jl_sym_t *boundscheck_sym; extern jl_sym_t *inbounds_sym;\nextern jl_sym_t *copyast_sym; extern jl_sym_t *fastmath_sym;\nextern jl_sym_t *pure_sym; extern jl_sym_t *simdloop_sym;\nextern jl_sym_t *meta_sym; extern jl_sym_t *list_sym;\nextern jl_sym_t *inert_sym; extern jl_sym_t *static_parameter_sym;\nextern jl_sym_t *polly_sym; extern jl_sym_t *inline_sym;\n\n// gc -------------------------------------------------------------------------\n\ntypedef struct _jl_gcframe_t {\n    size_t nroots;\n    struct _jl_gcframe_t *prev;\n    // actual roots go here\n} jl_gcframe_t;\n\n// NOTE: it is the caller's responsibility to make sure arguments are\n// rooted such that the gc can see them on the stack.\n// `foo(f(), g())` is not safe,\n// since the result of `f()` is not rooted during the call to `g()`,\n// and the arguments to foo are not gc-protected during the call to foo.\n// foo can't do anything about it, so the caller must do:\n// jl_value_t *x=NULL, *y=NULL; JL_GC_PUSH2(&x, &y);\n// x = f(); y = g(); foo(x, y)\n\n#define jl_pgcstack (jl_get_ptls_states()->pgcstack)\n\n#define JL_GC_PUSH1(arg1)                                                 \\\n  void *__gc_stkf[] = {(void*)3, jl_pgcstack, arg1};                      \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH2(arg1, arg2)                                           \\\n  void *__gc_stkf[] = {(void*)5, jl_pgcstack, arg1, arg2};                \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH3(arg1, arg2, arg3)                                     \\\n  void *__gc_stkf[] = {(void*)7, jl_pgcstack, arg1, arg2, arg3};          \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH4(arg1, arg2, arg3, arg4)                               \\\n  void *__gc_stkf[] = {(void*)9, jl_pgcstack, arg1, arg2, arg3, arg4};    \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH5(arg1, arg2, arg3, arg4, arg5)                               \\\n  void *__gc_stkf[] = {(void*)11, jl_pgcstack, arg1, arg2, arg3, arg4, arg5};    \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSHARGS(rts_var,n)                               \\\n  rts_var = ((jl_value_t**)alloca(((n)+2)*sizeof(jl_value_t*)))+2;    \\\n  ((void**)rts_var)[-2] = (void*)(((size_t)(n))<<1);                  \\\n  ((void**)rts_var)[-1] = jl_pgcstack;                          \\\n  memset((void*)rts_var, 0, (n)*sizeof(jl_value_t*));           \\\n  jl_pgcstack = (jl_gcframe_t*)&(((void**)rts_var)[-2])\n\n#define JL_GC_POP() (jl_pgcstack = jl_pgcstack->prev)\n\nJL_DLLEXPORT int jl_gc_enable(int on);\nJL_DLLEXPORT int jl_gc_is_enabled(void);\nJL_DLLEXPORT int64_t jl_gc_total_bytes(void);\nJL_DLLEXPORT uint64_t jl_gc_total_hrtime(void);\nJL_DLLEXPORT int64_t jl_gc_diff_total_bytes(void);\n\nJL_DLLEXPORT void jl_gc_collect(int);\n\nJL_DLLEXPORT void jl_gc_add_finalizer(jl_value_t *v, jl_function_t *f);\nJL_DLLEXPORT void jl_finalize(jl_value_t *o);\nJL_DLLEXPORT jl_weakref_t *jl_gc_new_weakref(jl_value_t *value);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_0w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_1w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_2w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_3w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_allocobj(size_t sz);\n\nJL_DLLEXPORT void jl_clear_malloc_data(void);\n\n// GC write barriers\nJL_DLLEXPORT void jl_gc_queue_root(jl_value_t *root); // root isa jl_value_t*\n\n// Do NOT put a safepoint here\nSTATIC_INLINE void jl_gc_wb(void *parent, void *ptr)\n{\n    // parent and ptr isa jl_value_t*\n    if (__unlikely(jl_astaggedvalue(parent)->bits.gc == 3 &&\n                   (jl_astaggedvalue(ptr)->bits.gc & 1) == 0))\n        jl_gc_queue_root((jl_value_t*)parent);\n}\n\nSTATIC_INLINE void jl_gc_wb_back(void *ptr) // ptr isa jl_value_t*\n{\n    // if ptr is old\n    if (__unlikely(jl_astaggedvalue(ptr)->bits.gc == 3)) {\n        jl_gc_queue_root((jl_value_t*)ptr);\n    }\n}\n\nJL_DLLEXPORT void *jl_gc_managed_malloc(size_t sz);\nJL_DLLEXPORT void *jl_gc_managed_realloc(void *d, size_t sz, size_t oldsz,\n                                         int isaligned, jl_value_t *owner);\n\n// object accessors -----------------------------------------------------------\n\n#define jl_svec_len(t)              (((jl_svec_t*)(t))->length)\n#define jl_svec_set_len_unsafe(t,n) (((jl_svec_t*)(t))->length=(n))\n#define jl_svec_data(t) ((jl_value_t**)((char*)(t) + sizeof(jl_svec_t)))\n\nSTATIC_INLINE jl_value_t *jl_svecref(void *t, size_t i)\n{\n    assert(jl_typeis(t,jl_simplevector_type));\n    assert(i < jl_svec_len(t));\n    return jl_svec_data(t)[i];\n}\nSTATIC_INLINE jl_value_t *jl_svecset(void *t, size_t i, void *x)\n{\n    assert(jl_typeis(t,jl_simplevector_type));\n    assert(i < jl_svec_len(t));\n    jl_svec_data(t)[i] = (jl_value_t*)x;\n    if (x) jl_gc_wb(t, x);\n    return (jl_value_t*)x;\n}\n\n#ifdef STORE_ARRAY_LEN\n#define jl_array_len(a)   (((jl_array_t*)(a))->length)\n#else\nJL_DLLEXPORT size_t jl_array_len_(jl_array_t *a);\n#define jl_array_len(a)   jl_array_len_((jl_array_t*)(a))\n#endif\n#define jl_array_data(a)  ((void*)((jl_array_t*)(a))->data)\n#define jl_array_dim(a,i) ((&((jl_array_t*)(a))->nrows)[i])\n#define jl_array_dim0(a)  (((jl_array_t*)(a))->nrows)\n#define jl_array_nrows(a) (((jl_array_t*)(a))->nrows)\n#define jl_array_ndims(a) ((int32_t)(((jl_array_t*)a)->flags.ndims))\n#define jl_array_data_owner_offset(ndims) (offsetof(jl_array_t,ncols) + sizeof(size_t)*(1+jl_array_ndimwords(ndims))) // in bytes\n#define jl_array_data_owner(a) (*((jl_value_t**)((char*)a + jl_array_data_owner_offset(jl_array_ndims(a)))))\n\nSTATIC_INLINE jl_value_t *jl_array_ptr_ref(void *a, size_t i)\n{\n    assert(i < jl_array_len(a));\n    return ((jl_value_t**)(jl_array_data(a)))[i];\n}\nSTATIC_INLINE jl_value_t *jl_array_ptr_set(void *a, size_t i, void *x)\n{\n    assert(i < jl_array_len(a));\n    ((jl_value_t**)(jl_array_data(a)))[i] = (jl_value_t*)x;\n    if (x) {\n        if (((jl_array_t*)a)->flags.how == 3) {\n            a = jl_array_data_owner(a);\n        }\n        jl_gc_wb(a, x);\n    }\n    return (jl_value_t*)x;\n}\n\nSTATIC_INLINE uint8_t jl_array_uint8_ref(void *a, size_t i)\n{\n    assert(i < jl_array_len(a));\n    assert(jl_typeis(a, jl_array_uint8_type));\n    return ((uint8_t*)(jl_array_data(a)))[i];\n}\nSTATIC_INLINE void jl_array_uint8_set(void *a, size_t i, uint8_t x)\n{\n    assert(i < jl_array_len(a));\n    assert(jl_typeis(a, jl_array_uint8_type));\n    ((uint8_t*)(jl_array_data(a)))[i] = x;\n}\n\n#define jl_exprarg(e,n) (((jl_value_t**)jl_array_data(((jl_expr_t*)(e))->args))[n])\n#define jl_exprargset(e, n, v) jl_array_ptr_set(((jl_expr_t*)(e))->args, n, v)\n#define jl_expr_nargs(e) jl_array_len(((jl_expr_t*)(e))->args)\n\n#define jl_fieldref(s,i) jl_get_nth_field(((jl_value_t*)s),i)\n#define jl_nfields(v)    jl_datatype_nfields(jl_typeof(v))\n\n// Not using jl_fieldref to avoid allocations\n#define jl_linenode_line(x) (((intptr_t*)x)[0])\n#define jl_labelnode_label(x) (((intptr_t*)x)[0])\n#define jl_slot_number(x) (((intptr_t*)x)[0])\n#define jl_typedslot_get_type(x) (((jl_value_t**)x)[1])\n#define jl_gotonode_label(x) (((intptr_t*)x)[0])\n#define jl_globalref_mod(s) (*(jl_module_t**)s)\n#define jl_globalref_name(s) (((jl_sym_t**)s)[1])\n\n#define jl_nparams(t)  jl_svec_len(((jl_datatype_t*)(t))->parameters)\n#define jl_tparam0(t)  jl_svecref(((jl_datatype_t*)(t))->parameters, 0)\n#define jl_tparam1(t)  jl_svecref(((jl_datatype_t*)(t))->parameters, 1)\n#define jl_tparam(t,i) jl_svecref(((jl_datatype_t*)(t))->parameters, i)\n\n// get a pointer to the data in a datatype\n#define jl_data_ptr(v)  ((jl_value_t**)v)\n\n#define jl_array_ptr_data(a)   ((jl_value_t**)((jl_array_t*)a)->data)\n#define jl_string_data(s) ((char*)((jl_array_t*)jl_data_ptr(s)[0])->data)\n#define jl_string_len(s)  (jl_array_len((jl_array_t*)(jl_data_ptr(s)[0])))\n#define jl_iostr_data(s)  ((char*)((jl_array_t*)jl_data_ptr(s)[0])->data)\n\n#define jl_gf_mtable(f) (((jl_datatype_t*)jl_typeof(f))->name->mt)\n#define jl_gf_name(f)   (jl_gf_mtable(f)->name)\n\n// struct type info\n#define jl_field_name(st,i)    (jl_sym_t*)jl_svecref(((jl_datatype_t*)st)->name->names, (i))\n#define jl_field_type(st,i)    jl_svecref(((jl_datatype_t*)st)->types, (i))\n#define jl_field_count(st)     jl_svec_len(((jl_datatype_t*)st)->types)\n#define jl_datatype_size(t)    (((jl_datatype_t*)t)->size)\n#define jl_datatype_nfields(t) (((jl_datatype_t*)(t))->layout->nfields)\n\n// inline version with strong type check to detect typos in a `->name` chain\nSTATIC_INLINE char *jl_symbol_name_(jl_sym_t *s)\n{\n    return (char*)s + LLT_ALIGN(sizeof(jl_sym_t), sizeof(void*));\n}\n#define jl_symbol_name(s) jl_symbol_name_(s)\n\n#define jl_dt_layout_fields(d) ((const char*)(d) + sizeof(jl_datatype_layout_t))\n\n#define DEFINE_FIELD_ACCESSORS(f)                                             \\\n    static inline uint32_t jl_field_##f(jl_datatype_t *st, int i)             \\\n    {                                                                         \\\n        const jl_datatype_layout_t *ly = st->layout;                          \\\n        assert(i >= 0 && (size_t)i < ly->nfields);                            \\\n        if (ly->fielddesc_type == 0) {                                        \\\n            return ((const jl_fielddesc8_t*)jl_dt_layout_fields(ly))[i].f;    \\\n        }                                                                     \\\n        else if (ly->fielddesc_type == 1) {                                   \\\n            return ((const jl_fielddesc16_t*)jl_dt_layout_fields(ly))[i].f;   \\\n        }                                                                     \\\n        else {                                                                \\\n            return ((const jl_fielddesc32_t*)jl_dt_layout_fields(ly))[i].f;   \\\n        }                                                                     \\\n    }                                                                         \\\n\nDEFINE_FIELD_ACCESSORS(offset)\nDEFINE_FIELD_ACCESSORS(size)\nstatic inline int jl_field_isptr(jl_datatype_t *st, int i)\n{\n    const jl_datatype_layout_t *ly = st->layout;\n    assert(i >= 0 && (size_t)i < ly->nfields);\n    return ((const jl_fielddesc8_t*)(jl_dt_layout_fields(ly) + (i << (ly->fielddesc_type + 1))))->isptr;\n}\n\nstatic inline uint32_t jl_fielddesc_size(int8_t fielddesc_type)\n{\n    if (fielddesc_type == 0) {\n        return sizeof(jl_fielddesc8_t);\n    }\n    else if (fielddesc_type == 1) {\n        return sizeof(jl_fielddesc16_t);\n    }\n    else {\n        return sizeof(jl_fielddesc32_t);\n    }\n}\n\n#undef DEFINE_FIELD_ACCESSORS\n\n// basic predicates -----------------------------------------------------------\n#define jl_is_nothing(v)     (((jl_value_t*)(v)) == ((jl_value_t*)jl_nothing))\n#define jl_is_tuple(v)       (((jl_datatype_t*)jl_typeof(v))->name == jl_tuple_typename)\n#define jl_is_svec(v)        jl_typeis(v,jl_simplevector_type)\n#define jl_is_simplevector(v) jl_is_svec(v)\n#define jl_is_datatype(v)    jl_typeis(v,jl_datatype_type)\n#define jl_is_mutable(t)     (((jl_datatype_t*)t)->mutabl)\n#define jl_is_mutable_datatype(t) (jl_is_datatype(t) && (((jl_datatype_t*)t)->mutabl))\n#define jl_is_immutable(t)   (!((jl_datatype_t*)t)->mutabl)\n#define jl_is_immutable_datatype(t) (jl_is_datatype(t) && (!((jl_datatype_t*)t)->mutabl))\n#define jl_is_uniontype(v)   jl_typeis(v,jl_uniontype_type)\n#define jl_is_typevar(v)     jl_typeis(v,jl_tvar_type)\n#define jl_is_typector(v)    jl_typeis(v,jl_typector_type)\n#define jl_is_TypeConstructor(v)    jl_typeis(v,jl_typector_type)\n#define jl_is_typename(v)    jl_typeis(v,jl_typename_type)\n#define jl_is_int8(v)        jl_typeis(v,jl_int8_type)\n#define jl_is_int16(v)       jl_typeis(v,jl_int16_type)\n#define jl_is_int32(v)       jl_typeis(v,jl_int32_type)\n#define jl_is_int64(v)       jl_typeis(v,jl_int64_type)\n#define jl_is_uint8(v)       jl_typeis(v,jl_uint8_type)\n#define jl_is_uint16(v)      jl_typeis(v,jl_uint16_type)\n#define jl_is_uint32(v)      jl_typeis(v,jl_uint32_type)\n#define jl_is_uint64(v)      jl_typeis(v,jl_uint64_type)\n#define jl_is_float(v)       jl_subtype(v,(jl_value_t*)jl_floatingpoint_type,1)\n#define jl_is_floattype(v)   jl_subtype(v,(jl_value_t*)jl_floatingpoint_type,0)\n#define jl_is_float32(v)     jl_typeis(v,jl_float32_type)\n#define jl_is_float64(v)     jl_typeis(v,jl_float64_type)\n#define jl_is_bool(v)        jl_typeis(v,jl_bool_type)\n#define jl_is_symbol(v)      jl_typeis(v,jl_sym_type)\n#define jl_is_ssavalue(v)    jl_typeis(v,jl_ssavalue_type)\n#define jl_is_slot(v)        (jl_typeis(v,jl_slotnumber_type) || jl_typeis(v,jl_typedslot_type))\n#define jl_is_expr(v)        jl_typeis(v,jl_expr_type)\n#define jl_is_globalref(v)   jl_typeis(v,jl_globalref_type)\n#define jl_is_labelnode(v)   jl_typeis(v,jl_labelnode_type)\n#define jl_is_gotonode(v)    jl_typeis(v,jl_gotonode_type)\n#define jl_is_quotenode(v)   jl_typeis(v,jl_quotenode_type)\n#define jl_is_newvarnode(v)  jl_typeis(v,jl_newvarnode_type)\n#define jl_is_linenode(v)    jl_typeis(v,jl_linenumbernode_type)\n#define jl_is_lambda_info(v) jl_typeis(v,jl_lambda_info_type)\n#define jl_is_method(v)      jl_typeis(v,jl_method_type)\n#define jl_is_module(v)      jl_typeis(v,jl_module_type)\n#define jl_is_mtable(v)      jl_typeis(v,jl_methtable_type)\n#define jl_is_task(v)        jl_typeis(v,jl_task_type)\n#define jl_is_string(v)      jl_typeis(v,jl_string_type)\n#define jl_is_cpointer(v)    jl_is_cpointer_type(jl_typeof(v))\n#define jl_is_pointer(v)     jl_is_cpointer_type(jl_typeof(v))\n\nSTATIC_INLINE int jl_is_bitstype(void *v)\n{\n    return (jl_is_datatype(v) && jl_is_immutable(v) &&\n            ((jl_datatype_t*)(v))->layout &&\n            jl_datatype_nfields(v) == 0 &&\n            ((jl_datatype_t*)(v))->size > 0);\n}\n\nSTATIC_INLINE int jl_is_structtype(void *v)\n{\n    return (jl_is_datatype(v) &&\n            (jl_field_count(v) > 0 ||\n             ((jl_datatype_t*)(v))->size == 0) &&\n            !((jl_datatype_t*)(v))->abstract);\n}\n\nSTATIC_INLINE int jl_isbits(void *t)   // corresponding to isbits() in julia\n{\n    return (jl_is_datatype(t) && ((jl_datatype_t*)t)->layout &&\n            !((jl_datatype_t*)t)->mutabl && ((jl_datatype_t*)t)->layout->pointerfree);\n}\n\nSTATIC_INLINE int jl_is_datatype_singleton(jl_datatype_t *d)\n{\n    return (d->instance != NULL);\n}\n\nSTATIC_INLINE int jl_is_datatype_make_singleton(jl_datatype_t *d)\n{\n    return (!d->abstract && d->size == 0 && d != jl_sym_type && d->name != jl_array_typename &&\n            d->uid != 0 && (d->name->names == jl_emptysvec || !d->mutabl));\n}\n\nSTATIC_INLINE int jl_is_abstracttype(void *v)\n{\n    return (jl_is_datatype(v) && ((jl_datatype_t*)(v))->abstract);\n}\n\nSTATIC_INLINE int jl_is_array_type(void *t)\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_array_typename);\n}\n\nSTATIC_INLINE int jl_is_array(void *v)\n{\n    jl_value_t *t = jl_typeof(v);\n    return jl_is_array_type(t);\n}\n\nSTATIC_INLINE int jl_is_cpointer_type(jl_value_t *t)\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_pointer_type->name);\n}\n\nSTATIC_INLINE int jl_is_abstract_ref_type(jl_value_t *t)\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_ref_type->name);\n}\n\nSTATIC_INLINE jl_value_t *jl_is_ref_type(jl_value_t *t)\n{\n    if (!jl_is_datatype(t)) return 0;\n    jl_datatype_t *dt = (jl_datatype_t*)t;\n    while (dt != jl_any_type && dt->name != dt->super->name) {\n        if (dt->name == jl_ref_type->name)\n            return (jl_value_t*)dt;\n        dt = dt->super;\n    }\n    return 0;\n}\n\nSTATIC_INLINE int jl_is_tuple_type(void *t)\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_tuple_typename);\n}\n\nSTATIC_INLINE int jl_is_vecelement_type(jl_value_t* t)\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_vecelement_typename);\n}\n\nSTATIC_INLINE int jl_is_type_type(jl_value_t *v)\n{\n    return (jl_is_datatype(v) &&\n            ((jl_datatype_t*)(v))->name == jl_type_type->name);\n}\n\n// object identity\nJL_DLLEXPORT int jl_egal(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT uintptr_t jl_object_id(jl_value_t *v);\n\n// type predicates and basic operations\nJL_DLLEXPORT int jl_is_leaf_type(jl_value_t *v);\nJL_DLLEXPORT int jl_has_typevars(jl_value_t *v);\nJL_DLLEXPORT int jl_subtype(jl_value_t *a, jl_value_t *b, int ta);\nJL_DLLEXPORT int jl_types_equal(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_type_union(jl_svec_t *types);\nJL_DLLEXPORT jl_value_t *jl_type_intersection(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT int jl_args_morespecific(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT const char *jl_typename_str(jl_value_t *v);\nJL_DLLEXPORT const char *jl_typeof_str(jl_value_t *v);\nJL_DLLEXPORT int jl_type_morespecific(jl_value_t *a, jl_value_t *b);\n\n#ifdef NDEBUG\nSTATIC_INLINE int jl_is_leaf_type_(jl_value_t *v)\n{\n    return jl_is_datatype(v) && ((jl_datatype_t*)v)->isleaftype;\n}\n#define jl_is_leaf_type(v) jl_is_leaf_type_(v)\n#endif\n\n// type constructors\nJL_DLLEXPORT jl_typename_t *jl_new_typename(jl_sym_t *name);\nJL_DLLEXPORT jl_tvar_t *jl_new_typevar(jl_sym_t *name,jl_value_t *lb,jl_value_t *ub);\nJL_DLLEXPORT jl_value_t *jl_apply_type(jl_value_t *tc, jl_svec_t *params);\nJL_DLLEXPORT jl_tupletype_t *jl_apply_tuple_type(jl_svec_t *params);\nJL_DLLEXPORT jl_tupletype_t *jl_apply_tuple_type_v(jl_value_t **p, size_t np);\nJL_DLLEXPORT jl_datatype_t *jl_new_datatype(jl_sym_t *name, jl_datatype_t *super,\n                                            jl_svec_t *parameters,\n                                            jl_svec_t *fnames, jl_svec_t *ftypes,\n                                            int abstract, int mutabl,\n                                            int ninitialized);\nJL_DLLEXPORT jl_datatype_t *jl_new_bitstype(jl_value_t *name,\n                                            jl_datatype_t *super,\n                                            jl_svec_t *parameters, size_t nbits);\n\n// constructors\nJL_DLLEXPORT jl_value_t *jl_new_bits(jl_value_t *bt, void *data);\nJL_DLLEXPORT jl_value_t *jl_new_struct(jl_datatype_t *type, ...);\nJL_DLLEXPORT jl_value_t *jl_new_structv(jl_datatype_t *type, jl_value_t **args,\n                                        uint32_t na);\nJL_DLLEXPORT jl_value_t *jl_new_struct_uninit(jl_datatype_t *type);\nJL_DLLEXPORT jl_lambda_info_t *jl_new_lambda_info_uninit(void);\nJL_DLLEXPORT jl_lambda_info_t *jl_new_lambda_info_from_ast(jl_expr_t *ast);\nJL_DLLEXPORT jl_method_t *jl_new_method(jl_lambda_info_t *definition, jl_sym_t *name, jl_tupletype_t *sig, jl_svec_t *tvars, int isstaged);\nJL_DLLEXPORT jl_svec_t *jl_svec(size_t n, ...);\nJL_DLLEXPORT jl_svec_t *jl_svec1(void *a);\nJL_DLLEXPORT jl_svec_t *jl_svec2(void *a, void *b);\nJL_DLLEXPORT jl_svec_t *jl_alloc_svec(size_t n);\nJL_DLLEXPORT jl_svec_t *jl_alloc_svec_uninit(size_t n);\nJL_DLLEXPORT jl_svec_t *jl_svec_copy(jl_svec_t *a);\nJL_DLLEXPORT jl_svec_t *jl_svec_fill(size_t n, jl_value_t *x);\nJL_DLLEXPORT jl_value_t *jl_tupletype_fill(size_t n, jl_value_t *v);\nJL_DLLEXPORT jl_sym_t *jl_symbol(const char *str);\nJL_DLLEXPORT jl_sym_t *jl_symbol_lookup(const char *str);\nJL_DLLEXPORT jl_sym_t *jl_symbol_n(const char *str, int32_t len);\nJL_DLLEXPORT jl_sym_t *jl_gensym(void);\nJL_DLLEXPORT jl_sym_t *jl_tagged_gensym(const char *str, int32_t len);\nJL_DLLEXPORT jl_sym_t *jl_get_root_symbol(void);\nJL_DLLEXPORT jl_value_t *jl_generic_function_def(jl_sym_t *name, jl_value_t **bp,\n                                                 jl_value_t *bp_owner,\n                                                 jl_binding_t *bnd);\nJL_DLLEXPORT void jl_method_def(jl_svec_t *argdata, jl_lambda_info_t *f, jl_value_t *isstaged);\nJL_DLLEXPORT jl_function_t *jl_get_kwsorter(jl_typename_t *tn);\nJL_DLLEXPORT jl_value_t *jl_box_bool(int8_t x);\nJL_DLLEXPORT jl_value_t *jl_box_int8(int8_t x);\nJL_DLLEXPORT jl_value_t *jl_box_uint8(uint8_t x);\nJL_DLLEXPORT jl_value_t *jl_box_int16(int16_t x);\nJL_DLLEXPORT jl_value_t *jl_box_uint16(uint16_t x);\nJL_DLLEXPORT jl_value_t *jl_box_int32(int32_t x);\nJL_DLLEXPORT jl_value_t *jl_box_uint32(uint32_t x);\nJL_DLLEXPORT jl_value_t *jl_box_char(uint32_t x);\nJL_DLLEXPORT jl_value_t *jl_box_int64(int64_t x);\nJL_DLLEXPORT jl_value_t *jl_box_uint64(uint64_t x);\nJL_DLLEXPORT jl_value_t *jl_box_float32(float x);\nJL_DLLEXPORT jl_value_t *jl_box_float64(double x);\nJL_DLLEXPORT jl_value_t *jl_box_voidpointer(void *x);\nJL_DLLEXPORT jl_value_t *jl_box_ssavalue(size_t x);\nJL_DLLEXPORT jl_value_t *jl_box_slotnumber(size_t x);\nJL_DLLEXPORT jl_value_t *jl_box8 (jl_datatype_t *t, int8_t  x);\nJL_DLLEXPORT jl_value_t *jl_box16(jl_datatype_t *t, int16_t x);\nJL_DLLEXPORT jl_value_t *jl_box32(jl_datatype_t *t, int32_t x);\nJL_DLLEXPORT jl_value_t *jl_box64(jl_datatype_t *t, int64_t x);\nJL_DLLEXPORT int8_t jl_unbox_bool(jl_value_t *v);\nJL_DLLEXPORT int8_t jl_unbox_int8(jl_value_t *v);\nJL_DLLEXPORT uint8_t jl_unbox_uint8(jl_value_t *v);\nJL_DLLEXPORT int16_t jl_unbox_int16(jl_value_t *v);\nJL_DLLEXPORT uint16_t jl_unbox_uint16(jl_value_t *v);\nJL_DLLEXPORT int32_t jl_unbox_int32(jl_value_t *v);\nJL_DLLEXPORT uint32_t jl_unbox_uint32(jl_value_t *v);\nJL_DLLEXPORT int64_t jl_unbox_int64(jl_value_t *v);\nJL_DLLEXPORT uint64_t jl_unbox_uint64(jl_value_t *v);\nJL_DLLEXPORT float jl_unbox_float32(jl_value_t *v);\nJL_DLLEXPORT double jl_unbox_float64(jl_value_t *v);\nJL_DLLEXPORT void *jl_unbox_voidpointer(jl_value_t *v);\n\nJL_DLLEXPORT int jl_get_size(jl_value_t *val, size_t *pnt);\n\n#ifdef _P64\n#define jl_box_long(x)   jl_box_int64(x)\n#define jl_box_ulong(x)  jl_box_uint64(x)\n#define jl_unbox_long(x) jl_unbox_int64(x)\n#define jl_is_long(x)    jl_is_int64(x)\n#define jl_long_type     jl_int64_type\n#else\n#define jl_box_long(x)   jl_box_int32(x)\n#define jl_box_ulong(x)  jl_box_uint32(x)\n#define jl_unbox_long(x) jl_unbox_int32(x)\n#define jl_is_long(x)    jl_is_int32(x)\n#define jl_long_type     jl_int32_type\n#endif\n\n// Each tuple can exist in one of 4 Vararg states:\n//   NONE: no vararg                            Tuple{Int,Float32}\n//   INT: vararg with integer length            Tuple{Int,Vararg{Float32,2}}\n//   BOUND: vararg with bound TypeVar length    Tuple{Int,Vararg{Float32,N}}\n//   UNBOUND: vararg with unbound length        Tuple{Int,Vararg{Float32}}\ntypedef enum {\n    JL_VARARG_NONE    = 0,\n    JL_VARARG_INT     = 1,\n    JL_VARARG_BOUND   = 2,\n    JL_VARARG_UNBOUND = 3\n} jl_vararg_kind_t;\n\nSTATIC_INLINE int jl_is_vararg_type(jl_value_t *v)\n{\n    return (jl_is_datatype(v) &&\n            ((jl_datatype_t*)(v))->name == jl_vararg_type->name);\n}\n\nSTATIC_INLINE jl_vararg_kind_t jl_vararg_kind(jl_value_t *v)\n{\n    if (!jl_is_vararg_type(v))\n        return JL_VARARG_NONE;\n    jl_value_t *lenv = jl_tparam1(v);\n    if (jl_is_long(lenv))\n        return JL_VARARG_INT;\n    if (jl_is_typevar(lenv))\n        return ((jl_tvar_t*)lenv)->bound ? JL_VARARG_BOUND : JL_VARARG_UNBOUND;\n    return JL_VARARG_UNBOUND;\n}\n\nSTATIC_INLINE int jl_is_va_tuple(jl_datatype_t *t)\n{\n    assert(jl_is_tuple_type(t));\n    size_t l = jl_svec_len(t->parameters);\n    return (l>0 && jl_is_vararg_type(jl_tparam(t,l-1)));\n}\n\nSTATIC_INLINE jl_vararg_kind_t jl_va_tuple_kind(jl_datatype_t *t)\n{\n    assert(jl_is_tuple_type(t));\n    size_t l = jl_svec_len(t->parameters);\n    if (l == 0)\n        return JL_VARARG_NONE;\n    return jl_vararg_kind(jl_tparam(t,l-1));\n}\n\n// structs\nJL_DLLEXPORT int         jl_field_index(jl_datatype_t *t, jl_sym_t *fld, int err);\nJL_DLLEXPORT jl_value_t *jl_get_nth_field(jl_value_t *v, size_t i);\nJL_DLLEXPORT jl_value_t *jl_get_nth_field_checked(jl_value_t *v, size_t i);\nJL_DLLEXPORT void        jl_set_nth_field(jl_value_t *v, size_t i,\n                                          jl_value_t *rhs);\nJL_DLLEXPORT int         jl_field_isdefined(jl_value_t *v, size_t i);\nJL_DLLEXPORT jl_value_t *jl_get_field(jl_value_t *o, const char *fld);\nJL_DLLEXPORT jl_value_t *jl_value_ptr(jl_value_t *a);\n\n// arrays\nJL_DLLEXPORT jl_array_t *jl_new_array(jl_value_t *atype, jl_value_t *dims);\nJL_DLLEXPORT jl_array_t *jl_reshape_array(jl_value_t *atype, jl_array_t *data,\n                                          jl_value_t *dims);\nJL_DLLEXPORT jl_array_t *jl_ptr_to_array_1d(jl_value_t *atype, void *data,\n                                            size_t nel, int own_buffer);\nJL_DLLEXPORT jl_array_t *jl_ptr_to_array(jl_value_t *atype, void *data,\n                                         jl_value_t *dims, int own_buffer);\n\nJL_DLLEXPORT jl_array_t *jl_alloc_array_1d(jl_value_t *atype, size_t nr);\nJL_DLLEXPORT jl_array_t *jl_alloc_array_2d(jl_value_t *atype, size_t nr,\n                                           size_t nc);\nJL_DLLEXPORT jl_array_t *jl_alloc_array_3d(jl_value_t *atype, size_t nr,\n                                           size_t nc, size_t z);\nJL_DLLEXPORT jl_array_t *jl_pchar_to_array(const char *str, size_t len);\nJL_DLLEXPORT jl_value_t *jl_pchar_to_string(const char *str, size_t len);\nJL_DLLEXPORT jl_value_t *jl_cstr_to_string(const char *str);\nJL_DLLEXPORT jl_value_t *jl_array_to_string(jl_array_t *a);\nJL_DLLEXPORT jl_array_t *jl_alloc_vec_any(size_t n);\nJL_DLLEXPORT jl_value_t *jl_arrayref(jl_array_t *a, size_t i);  // 0-indexed\nJL_DLLEXPORT void jl_arrayset(jl_array_t *a, jl_value_t *v, size_t i);  // 0-indexed\nJL_DLLEXPORT void jl_arrayunset(jl_array_t *a, size_t i);  // 0-indexed\nJL_DLLEXPORT void jl_array_grow_end(jl_array_t *a, size_t inc);\nJL_DLLEXPORT void jl_array_del_end(jl_array_t *a, size_t dec);\nJL_DLLEXPORT void jl_array_grow_beg(jl_array_t *a, size_t inc);\nJL_DLLEXPORT void jl_array_del_beg(jl_array_t *a, size_t dec);\nJL_DLLEXPORT void jl_array_sizehint(jl_array_t *a, size_t sz);\nJL_DLLEXPORT void jl_array_ptr_1d_push(jl_array_t *a, jl_value_t *item);\nJL_DLLEXPORT void jl_array_ptr_1d_push2(jl_array_t *a, jl_value_t *b, jl_value_t *c);\nJL_DLLEXPORT jl_value_t *jl_apply_array_type(jl_datatype_t *type, size_t dim);\n// property access\nJL_DLLEXPORT void *jl_array_ptr(jl_array_t *a);\nJL_DLLEXPORT void *jl_array_eltype(jl_value_t *a);\nJL_DLLEXPORT int jl_array_rank(jl_value_t *a);\nJL_DLLEXPORT size_t jl_array_size(jl_value_t *a, int d);\n\n// strings\nJL_DLLEXPORT const char *jl_string_ptr(jl_value_t *s);\n\n// modules and global variables\nextern JL_DLLEXPORT jl_module_t *jl_main_module;\nextern JL_DLLEXPORT jl_module_t *jl_internal_main_module;\nextern JL_DLLEXPORT jl_module_t *jl_core_module;\nextern JL_DLLEXPORT jl_module_t *jl_base_module;\nextern JL_DLLEXPORT jl_module_t *jl_top_module;\nJL_DLLEXPORT jl_module_t *jl_new_module(jl_sym_t *name);\n// get binding for reading\nJL_DLLEXPORT jl_binding_t *jl_get_binding(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT jl_binding_t *jl_get_binding_or_error(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT jl_value_t *jl_module_globalref(jl_module_t *m, jl_sym_t *var);\n// get binding for assignment\nJL_DLLEXPORT jl_binding_t *jl_get_binding_wr(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT jl_binding_t *jl_get_binding_for_method_def(jl_module_t *m,\n                                                         jl_sym_t *var);\nJL_DLLEXPORT int jl_boundp(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT int jl_defines_or_exports_p(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT int jl_binding_resolved_p(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT int jl_is_const(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT jl_value_t *jl_get_global(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT void jl_set_global(jl_module_t *m, jl_sym_t *var, jl_value_t *val);\nJL_DLLEXPORT void jl_set_const(jl_module_t *m, jl_sym_t *var, jl_value_t *val);\nJL_DLLEXPORT void jl_checked_assignment(jl_binding_t *b, jl_value_t *rhs);\nJL_DLLEXPORT void jl_declare_constant(jl_binding_t *b);\nJL_DLLEXPORT void jl_module_using(jl_module_t *to, jl_module_t *from);\nJL_DLLEXPORT void jl_module_use(jl_module_t *to, jl_module_t *from, jl_sym_t *s);\nJL_DLLEXPORT void jl_module_import(jl_module_t *to, jl_module_t *from,\n                                   jl_sym_t *s);\nJL_DLLEXPORT void jl_module_importall(jl_module_t *to, jl_module_t *from);\nJL_DLLEXPORT void jl_module_export(jl_module_t *from, jl_sym_t *s);\nJL_DLLEXPORT int jl_is_imported(jl_module_t *m, jl_sym_t *s);\nJL_DLLEXPORT jl_module_t *jl_new_main_module(void);\nJL_DLLEXPORT void jl_add_standard_imports(jl_module_t *m);\nSTATIC_INLINE jl_function_t *jl_get_function(jl_module_t *m, const char *name)\n{\n    return (jl_function_t*)jl_get_global(m, jl_symbol(name));\n}\nint jl_is_submodule(jl_module_t *child, jl_module_t *parent);\n\n// eq hash tables\nJL_DLLEXPORT jl_array_t *jl_eqtable_put(jl_array_t *h, void *key, void *val);\nJL_DLLEXPORT jl_value_t *jl_eqtable_get(jl_array_t *h, void *key,\n                                        jl_value_t *deflt);\n\n// system information\nJL_DLLEXPORT int jl_errno(void);\nJL_DLLEXPORT void jl_set_errno(int e);\nJL_DLLEXPORT int32_t jl_stat(const char *path, char *statbuf);\nJL_DLLEXPORT int jl_cpu_cores(void);\nJL_DLLEXPORT long jl_getpagesize(void);\nJL_DLLEXPORT long jl_getallocationgranularity(void);\nJL_DLLEXPORT int jl_is_debugbuild(void);\nJL_DLLEXPORT jl_sym_t *jl_get_UNAME(void);\nJL_DLLEXPORT jl_sym_t *jl_get_ARCH(void);\n\n// environment entries\nJL_DLLEXPORT jl_value_t *jl_environ(int i);\n\n// throwing common exceptions\nJL_DLLEXPORT void JL_NORETURN jl_error(const char *str);\nJL_DLLEXPORT void JL_NORETURN jl_errorf(const char *fmt, ...);\nJL_DLLEXPORT void JL_NORETURN jl_exceptionf(jl_datatype_t *ty,\n                                            const char *fmt, ...);\nJL_DLLEXPORT void JL_NORETURN jl_too_few_args(const char *fname, int min);\nJL_DLLEXPORT void JL_NORETURN jl_too_many_args(const char *fname, int max);\nJL_DLLEXPORT void JL_NORETURN jl_type_error(const char *fname,\n                                            jl_value_t *expected,\n                                            jl_value_t *got);\nJL_DLLEXPORT void JL_NORETURN jl_type_error_rt(const char *fname,\n                                               const char *context,\n                                               jl_value_t *ty, jl_value_t *got);\nJL_DLLEXPORT void JL_NORETURN jl_undefined_var_error(jl_sym_t *var);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error(jl_value_t *v, jl_value_t *t);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_v(jl_value_t *v,\n                                                jl_value_t **idxs, size_t nidxs);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_int(jl_value_t *v, size_t i);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_tuple_int(jl_value_t **v,\n                                                        size_t nv, size_t i);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_unboxed_int(void *v, jl_value_t *vt, size_t i);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_ints(jl_value_t *v, size_t *idxs, size_t nidxs);\nJL_DLLEXPORT void JL_NORETURN jl_eof_error(void);\nJL_DLLEXPORT jl_value_t *jl_exception_occurred(void);\nJL_DLLEXPORT void jl_exception_clear(void);\n\n#define JL_NARGS(fname, min, max)                               \\\n    if (nargs < min) jl_too_few_args(#fname, min);              \\\n    else if (nargs > max) jl_too_many_args(#fname, max);\n\n#define JL_NARGSV(fname, min)                           \\\n    if (nargs < min) jl_too_few_args(#fname, min);\n\n#define JL_TYPECHK(fname, type, v)                                      \\\n    if (!jl_is_##type(v)) {                                             \\\n        jl_type_error(#fname, (jl_value_t*)jl_##type##_type, (v));      \\\n    }\n#define JL_TYPECHKS(fname, type, v)                                     \\\n    if (!jl_is_##type(v)) {                                             \\\n        jl_type_error(fname, (jl_value_t*)jl_##type##_type, (v));       \\\n    }\n\n// initialization functions\ntypedef enum {\n    JL_IMAGE_CWD = 0,\n    JL_IMAGE_JULIA_HOME = 1,\n    //JL_IMAGE_LIBJULIA = 2,\n} JL_IMAGE_SEARCH;\nJL_DLLEXPORT void julia_init(JL_IMAGE_SEARCH rel);\nJL_DLLEXPORT void jl_init(const char *julia_home_dir);\nJL_DLLEXPORT void jl_init_with_image(const char *julia_home_dir,\n                                     const char *image_relative_path);\nJL_DLLEXPORT int jl_is_initialized(void);\nJL_DLLEXPORT void jl_atexit_hook(int status);\nJL_DLLEXPORT void JL_NORETURN jl_exit(int status);\n\nJL_DLLEXPORT int jl_deserialize_verify_header(ios_t *s);\nJL_DLLEXPORT void jl_preload_sysimg_so(const char *fname);\nJL_DLLEXPORT ios_t *jl_create_system_image(void);\nJL_DLLEXPORT void jl_save_system_image(const char *fname);\nJL_DLLEXPORT void jl_restore_system_image(const char *fname);\nJL_DLLEXPORT void jl_restore_system_image_data(const char *buf, size_t len);\nJL_DLLEXPORT int jl_save_incremental(const char *fname, jl_array_t *worklist);\nJL_DLLEXPORT jl_value_t *jl_restore_incremental(const char *fname);\nJL_DLLEXPORT jl_value_t *jl_restore_incremental_from_buf(const char *buf, size_t sz);\n\n// front end interface\nJL_DLLEXPORT jl_value_t *jl_parse_input_line(const char *str, size_t len,\n                                             const char *filename, size_t filename_len);\nJL_DLLEXPORT jl_value_t *jl_parse_string(const char *str, size_t len,\n                                         int pos0, int greedy);\nJL_DLLEXPORT int jl_parse_depwarn(int warn);\nJL_DLLEXPORT jl_value_t *jl_load_file_string(const char *text, size_t len,\n                                             char *filename);\nJL_DLLEXPORT jl_value_t *jl_expand(jl_value_t *expr);\nJL_DLLEXPORT jl_value_t *jl_eval_string(const char *str);\n\n// external libraries\nenum JL_RTLD_CONSTANT {\n     JL_RTLD_LOCAL=1U,\n     JL_RTLD_GLOBAL=2U,\n     JL_RTLD_LAZY=4U,\n     JL_RTLD_NOW=8U,\n     /* Linux/glibc and MacOS X: */\n     JL_RTLD_NODELETE=16U,\n     JL_RTLD_NOLOAD=32U,\n     /* Linux/glibc: */\n     JL_RTLD_DEEPBIND=64U,\n     /* MacOS X 10.5+: */\n     JL_RTLD_FIRST=128U\n};\n#define JL_RTLD_DEFAULT (JL_RTLD_LAZY | JL_RTLD_DEEPBIND)\n\ntypedef void *jl_uv_libhandle; // compatible with dlopen (void*) / LoadLibrary (HMODULE)\nJL_DLLEXPORT jl_uv_libhandle jl_load_dynamic_library(const char *fname, unsigned flags);\nJL_DLLEXPORT jl_uv_libhandle jl_load_dynamic_library_e(const char *fname, unsigned flags);\nJL_DLLEXPORT jl_uv_libhandle jl_dlopen(const char *filename, unsigned flags);\nJL_DLLEXPORT int jl_dlclose(jl_uv_libhandle handle);\nJL_DLLEXPORT void *jl_dlsym_e(jl_uv_libhandle handle, const char *symbol);\nJL_DLLEXPORT void *jl_dlsym(jl_uv_libhandle handle, const char *symbol);\n\n#if defined(__linux__) || defined(__FreeBSD__)\nJL_DLLEXPORT const char *jl_lookup_soname(const char *pfx, size_t n);\n#endif\n\n// compiler\nJL_DLLEXPORT jl_value_t *jl_toplevel_eval(jl_value_t *v);\nJL_DLLEXPORT jl_value_t *jl_toplevel_eval_in(jl_module_t *m, jl_value_t *ex);\nJL_DLLEXPORT jl_value_t *jl_load(const char *fname);\nJL_DLLEXPORT jl_value_t *jl_interpret_toplevel_expr_in(jl_module_t *m, jl_value_t *e,\n                                                       jl_lambda_info_t *lam);\nJL_DLLEXPORT jl_module_t *jl_base_relative_to(jl_module_t *m);\n\n// tracing\nJL_DLLEXPORT void jl_trace_method(jl_method_t *m);\nJL_DLLEXPORT void jl_untrace_method(jl_method_t *m);\nJL_DLLEXPORT void jl_trace_linfo(jl_lambda_info_t *linfo);\nJL_DLLEXPORT void jl_untrace_linfo(jl_lambda_info_t *linfo);\nJL_DLLEXPORT void jl_register_linfo_tracer(void (*callback)(jl_lambda_info_t *tracee));\nJL_DLLEXPORT void jl_register_method_tracer(void (*callback)(jl_lambda_info_t *tracee));\nJL_DLLEXPORT void jl_register_newmeth_tracer(void (*callback)(jl_method_t *tracee));\n\n// AST access\nJL_DLLEXPORT int jl_is_rest_arg(jl_value_t *ex);\n\nJL_DLLEXPORT jl_value_t *jl_copy_ast(jl_value_t *expr);\n\nJL_DLLEXPORT jl_array_t *jl_compress_ast(jl_lambda_info_t *li, jl_array_t *ast);\nJL_DLLEXPORT jl_array_t *jl_uncompress_ast(jl_lambda_info_t *li, jl_array_t *data);\n\nJL_DLLEXPORT int jl_is_operator(char *sym);\nJL_DLLEXPORT int jl_operator_precedence(char *sym);\n\nSTATIC_INLINE int jl_vinfo_sa(uint8_t vi)\n{\n    return (vi&16)!=0;\n}\n\nSTATIC_INLINE int jl_vinfo_usedundef(uint8_t vi)\n{\n    return (vi&32)!=0;\n}\n\n// calling into julia ---------------------------------------------------------\n\nJL_DLLEXPORT jl_value_t *jl_apply_generic(jl_value_t **args, uint32_t nargs);\nJL_DLLEXPORT jl_value_t *jl_invoke(jl_lambda_info_t *meth, jl_value_t **args, uint32_t nargs);\n\nSTATIC_INLINE\njl_value_t *jl_apply(jl_value_t **args, uint32_t nargs)\n{\n    return jl_apply_generic(args, nargs);\n}\n\nJL_DLLEXPORT jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs);\nJL_DLLEXPORT jl_value_t *jl_call0(jl_function_t *f);\nJL_DLLEXPORT jl_value_t *jl_call1(jl_function_t *f, jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_call2(jl_function_t *f, jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_call3(jl_function_t *f, jl_value_t *a,\n                                  jl_value_t *b, jl_value_t *c);\n\n// interfacing with Task runtime\nJL_DLLEXPORT void jl_yield(void);\n\n// async signal handling ------------------------------------------------------\n\nJL_DLLEXPORT void jl_install_sigint_handler(void);\nJL_DLLEXPORT void jl_sigatomic_begin(void);\nJL_DLLEXPORT void jl_sigatomic_end(void);\n\n// tasks and exceptions -------------------------------------------------------\n\ntypedef struct _jl_timing_block_t jl_timing_block_t;\n// info describing an exception handler\ntypedef struct _jl_handler_t {\n    jl_jmp_buf eh_ctx;\n    jl_gcframe_t *gcstack;\n    struct _jl_handler_t *prev;\n    int8_t gc_state;\n#ifdef JULIA_ENABLE_THREADING\n    size_t locks_len;\n#endif\n    sig_atomic_t defer_signal;\n    int finalizers_inhibited;\n    jl_timing_block_t *timing_stack;\n} jl_handler_t;\n\ntypedef struct _jl_task_t {\n    JL_DATA_TYPE\n    struct _jl_task_t *parent;\n    jl_value_t *tls;\n    jl_sym_t *state;\n    jl_value_t *consumers;\n    jl_value_t *donenotify;\n    jl_value_t *result;\n    jl_value_t *exception;\n    jl_value_t *backtrace;\n    jl_function_t *start;\n    jl_jmp_buf ctx;\n    size_t bufsz;\n    void *stkbuf;\n\n    size_t ssize;\n    size_t started:1;\n\n    // current exception handler\n    jl_handler_t *eh;\n    // saved gc stack top for context switches\n    jl_gcframe_t *gcstack;\n    // current module, or NULL if this task has not set one\n    jl_module_t *current_module;\n\n    // id of owning thread\n    // does not need to be defined until the task runs\n    int16_t tid;\n#ifdef JULIA_ENABLE_THREADING\n    // This is statically initialized when the task is not holding any locks\n    arraylist_t locks;\n#endif\n    jl_timing_block_t *timing_stack;\n} jl_task_t;\n\nJL_DLLEXPORT jl_task_t *jl_new_task(jl_function_t *start, size_t ssize);\nJL_DLLEXPORT jl_value_t *jl_switchto(jl_task_t *t, jl_value_t *arg);\nJL_DLLEXPORT void JL_NORETURN jl_throw(jl_value_t *e);\nJL_DLLEXPORT void JL_NORETURN jl_rethrow(void);\nJL_DLLEXPORT void JL_NORETURN jl_rethrow_other(jl_value_t *e);\n\n#ifdef JULIA_ENABLE_THREADING\nstatic inline void jl_lock_frame_push(jl_mutex_t *lock)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    // For early bootstrap\n    if (__unlikely(!ptls->current_task))\n        return;\n    arraylist_t *locks = &ptls->current_task->locks;\n    size_t len = locks->len;\n    if (__unlikely(len >= locks->max)) {\n        arraylist_grow(locks, 1);\n    }\n    else {\n        locks->len = len + 1;\n    }\n    locks->items[len] = (void*)lock;\n}\nstatic inline void jl_lock_frame_pop(void)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    if (__likely(ptls->current_task)) {\n        ptls->current_task->locks.len--;\n    }\n}\n#else\nstatic inline void jl_lock_frame_push(jl_mutex_t *lock)\n{\n    (void)lock;\n}\nstatic inline void jl_lock_frame_pop(void)\n{\n}\n#endif // ifndef JULIA_ENABLE_THREADING\n\nSTATIC_INLINE void jl_eh_restore_state(jl_handler_t *eh)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    jl_task_t *current_task = ptls->current_task;\n    // `eh` may not be `ptls->current_task->eh`. See `jl_pop_handler`\n    // This function should **NOT** have any safepoint before the ones at the\n    // end.\n    sig_atomic_t old_defer_signal = ptls->defer_signal;\n    int8_t old_gc_state = ptls->gc_state;\n    current_task->eh = eh->prev;\n    ptls->pgcstack = eh->gcstack;\n#ifdef JULIA_ENABLE_THREADING\n    arraylist_t *locks = &current_task->locks;\n    if (locks->len > eh->locks_len) {\n        for (size_t i = locks->len;i > eh->locks_len;i--)\n            jl_mutex_unlock_nogc((jl_mutex_t*)locks->items[i - 1]);\n        locks->len = eh->locks_len;\n    }\n#endif\n    ptls->defer_signal = eh->defer_signal;\n    ptls->gc_state = eh->gc_state;\n    ptls->finalizers_inhibited = eh->finalizers_inhibited;\n    if (old_gc_state && !eh->gc_state) {\n        jl_gc_safepoint_(ptls);\n    }\n    if (old_defer_signal && !eh->defer_signal) {\n        jl_sigint_safepoint(ptls);\n    }\n}\n\nJL_DLLEXPORT void jl_enter_handler(jl_handler_t *eh);\nJL_DLLEXPORT void jl_pop_handler(int n);\n\n#if defined(_OS_WINDOWS_)\n#if defined(_COMPILER_MINGW_)\nint __attribute__ ((__nothrow__,__returns_twice__)) jl_setjmp(jmp_buf _Buf);\n__declspec(noreturn) __attribute__ ((__nothrow__)) void jl_longjmp(jmp_buf _Buf,int _Value);\n#else\nint jl_setjmp(jmp_buf _Buf);\nvoid jl_longjmp(jmp_buf _Buf,int _Value);\n#endif\n#define jl_setjmp_f jl_setjmp\n#define jl_setjmp_name \"jl_setjmp\"\n#define jl_setjmp(a,b) jl_setjmp(a)\n#define jl_longjmp(a,b) jl_longjmp(a,b)\n#else\n// determine actual entry point name\n#if defined(sigsetjmp)\n#define jl_setjmp_f    __sigsetjmp\n#define jl_setjmp_name \"__sigsetjmp\"\n#else\n#define jl_setjmp_f    sigsetjmp\n#define jl_setjmp_name \"sigsetjmp\"\n#endif\n#define jl_setjmp(a,b) sigsetjmp(a,b)\n#define jl_longjmp(a,b) siglongjmp(a,b)\n#endif\n\n#define JL_TRY                                                    \\\n    int i__tr, i__ca; jl_handler_t __eh;                          \\\n    jl_enter_handler(&__eh);                                      \\\n    if (!jl_setjmp(__eh.eh_ctx,0))                                \\\n        for (i__tr=1; i__tr; i__tr=0, jl_eh_restore_state(&__eh))\n\n#define JL_EH_POP() jl_eh_restore_state(&__eh)\n\n#ifdef _OS_WINDOWS_\n#define JL_CATCH                                                \\\n    else                                                        \\\n        for (i__ca=1, jl_eh_restore_state(&__eh); i__ca; i__ca=0) \\\n            if (((jl_get_ptls_states()->exception_in_transit==jl_stackovf_exception) && _resetstkoflw()) || 1)\n#else\n#define JL_CATCH                                                \\\n    else                                                        \\\n        for (i__ca=1, jl_eh_restore_state(&__eh); i__ca; i__ca=0)\n#endif\n\n// I/O system -----------------------------------------------------------------\n\n#define JL_STREAM uv_stream_t\n#define JL_STDOUT jl_uv_stdout\n#define JL_STDERR jl_uv_stderr\n#define JL_STDIN  jl_uv_stdin\n\nJL_DLLEXPORT void jl_run_event_loop(uv_loop_t *loop);\nJL_DLLEXPORT int jl_run_once(uv_loop_t *loop);\nJL_DLLEXPORT int jl_process_events(uv_loop_t *loop);\n\nJL_DLLEXPORT uv_loop_t *jl_global_event_loop(void);\n\nJL_DLLEXPORT void jl_close_uv(uv_handle_t *handle);\n\nJL_DLLEXPORT int jl_tcp_bind(uv_tcp_t *handle, uint16_t port, uint32_t host,\n                             unsigned int flags);\n\nJL_DLLEXPORT int jl_sizeof_ios_t(void);\n\nJL_DLLEXPORT jl_array_t *jl_takebuf_array(ios_t *s);\nJL_DLLEXPORT jl_value_t *jl_takebuf_string(ios_t *s);\nJL_DLLEXPORT void *jl_takebuf_raw(ios_t *s);\nJL_DLLEXPORT jl_value_t *jl_readuntil(ios_t *s, uint8_t delim);\n\ntypedef struct {\n    void *data;\n    uv_loop_t *loop;\n    uv_handle_type type;\n    uv_file file;\n} jl_uv_file_t;\n\n#ifdef __GNUC__\n#define _JL_FORMAT_ATTR(type, str, arg) \\\n    __attribute__((format(type, str, arg)))\n#else\n#define _JL_FORMAT_ATTR(type, str, arg)\n#endif\n\nJL_DLLEXPORT int jl_printf(uv_stream_t *s, const char *format, ...)\n    _JL_FORMAT_ATTR(printf, 2, 3);\nJL_DLLEXPORT int jl_vprintf(uv_stream_t *s, const char *format, va_list args)\n    _JL_FORMAT_ATTR(printf, 2, 0);\nJL_DLLEXPORT void jl_safe_printf(const char *str, ...)\n    _JL_FORMAT_ATTR(printf, 1, 2);\n\nextern JL_DLLEXPORT JL_STREAM *JL_STDIN;\nextern JL_DLLEXPORT JL_STREAM *JL_STDOUT;\nextern JL_DLLEXPORT JL_STREAM *JL_STDERR;\n\nJL_DLLEXPORT JL_STREAM *jl_stdout_stream(void);\nJL_DLLEXPORT JL_STREAM *jl_stdin_stream(void);\nJL_DLLEXPORT JL_STREAM *jl_stderr_stream(void);\n\n// showing and std streams\nJL_DLLEXPORT void jl_show(jl_value_t *stream, jl_value_t *v);\nJL_DLLEXPORT void jl_flush_cstdio(void);\nJL_DLLEXPORT jl_value_t *jl_stdout_obj(void);\nJL_DLLEXPORT jl_value_t *jl_stderr_obj(void);\nJL_DLLEXPORT size_t jl_static_show(JL_STREAM *out, jl_value_t *v);\nJL_DLLEXPORT size_t jl_static_show_func_sig(JL_STREAM *s, jl_value_t *type);\nJL_DLLEXPORT void jlbacktrace(void);\n// Mainly for debugging, use `void*` so that no type cast is needed in C++.\nJL_DLLEXPORT void jl_(void *jl_value);\n\n// julia options -----------------------------------------------------------\n// NOTE: This struct needs to be kept in sync with JLOptions type in base/options.jl\ntypedef struct {\n    int8_t quiet;\n    const char *julia_home;\n    const char *julia_bin;\n    const char *eval;\n    const char *print;\n    const char *postboot;\n    const char *load;\n    const char *image_file;\n    const char *cpu_target;\n    int32_t nprocs;\n    const char *machinefile;\n    int8_t isinteractive;\n    int8_t color;\n    int8_t historyfile;\n    int8_t startupfile;\n    int8_t compile_enabled;\n    int8_t code_coverage;\n    int8_t malloc_log;\n    int8_t opt_level;\n    int8_t check_bounds;\n    int8_t depwarn;\n    int8_t can_inline;\n    int8_t fast_math;\n    const char *worker;\n    int8_t handle_signals;\n    int8_t use_precompiled;\n    int8_t use_compilecache;\n    const char *bindto;\n    const char *outputbc;\n    const char *outputo;\n    const char *outputji;\n    int8_t incremental;\n    int8_t image_file_specified;\n} jl_options_t;\n\nextern JL_DLLEXPORT jl_options_t jl_options;\n\n// Parse an argc/argv pair to extract general julia options, passing back out\n// any arguments that should be passed on to the script.\nJL_DLLEXPORT void jl_parse_opts(int *argcp, char ***argvp);\n\n// Set julia-level ARGS array according to the arguments provided in\n// argc/argv\nJL_DLLEXPORT void jl_set_ARGS(int argc, char **argv);\n\nJL_DLLEXPORT int jl_generating_output(void);\n\n// Settings for code_coverage and malloc_log\n// NOTE: if these numbers change, test/cmdlineargs.jl will have to be updated\n#define JL_LOG_NONE 0\n#define JL_LOG_USER 1\n#define JL_LOG_ALL  2\n\n#define JL_OPTIONS_CHECK_BOUNDS_DEFAULT 0\n#define JL_OPTIONS_CHECK_BOUNDS_ON 1\n#define JL_OPTIONS_CHECK_BOUNDS_OFF 2\n\n#define JL_OPTIONS_COMPILE_DEFAULT 1\n#define JL_OPTIONS_COMPILE_OFF 0\n#define JL_OPTIONS_COMPILE_ON  1\n#define JL_OPTIONS_COMPILE_ALL 2\n#define JL_OPTIONS_COMPILE_MIN 3\n\n#define JL_OPTIONS_COLOR_ON 1\n#define JL_OPTIONS_COLOR_OFF 2\n\n#define JL_OPTIONS_HISTORYFILE_ON 1\n#define JL_OPTIONS_HISTORYFILE_OFF 0\n\n#define JL_OPTIONS_STARTUPFILE_ON 1\n#define JL_OPTIONS_STARTUPFILE_OFF 2\n\n#define JL_OPTIONS_DEPWARN_OFF 0\n#define JL_OPTIONS_DEPWARN_ON 1\n#define JL_OPTIONS_DEPWARN_ERROR 2\n\n#define JL_OPTIONS_FAST_MATH_ON 1\n#define JL_OPTIONS_FAST_MATH_OFF 2\n#define JL_OPTIONS_FAST_MATH_DEFAULT 0\n\n#define JL_OPTIONS_HANDLE_SIGNALS_ON 1\n#define JL_OPTIONS_HANDLE_SIGNALS_OFF 0\n\n#define JL_OPTIONS_USE_PRECOMPILED_YES 1\n#define JL_OPTIONS_USE_PRECOMPILED_NO 0\n\n#define JL_OPTIONS_USE_COMPILECACHE_YES 1\n#define JL_OPTIONS_USE_COMPILECACHE_NO 0\n\n// Version information\n#include <julia_version.h>\n\nJL_DLLEXPORT extern int jl_ver_major(void);\nJL_DLLEXPORT extern int jl_ver_minor(void);\nJL_DLLEXPORT extern int jl_ver_patch(void);\nJL_DLLEXPORT extern int jl_ver_is_release(void);\nJL_DLLEXPORT extern const char *jl_ver_string(void);\nJL_DLLEXPORT const char *jl_git_branch(void);\nJL_DLLEXPORT const char *jl_git_commit(void);\n\n// nullable struct representations\ntypedef struct {\n    uint8_t isnull;\n    double value;\n} jl_nullable_float64_t;\n\ntypedef struct {\n    uint8_t isnull;\n    float value;\n} jl_nullable_float32_t;\n\n#define jl_current_module (jl_get_ptls_states()->current_module)\n#define jl_current_task (jl_get_ptls_states()->current_task)\n#define jl_root_task (jl_get_ptls_states()->root_task)\n#define jl_exception_in_transit (jl_get_ptls_states()->exception_in_transit)\n#define jl_task_arg_in_transit (jl_get_ptls_states()->task_arg_in_transit)\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/jitlayers.cpp": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n#include \"llvm-version.h\"\n#include \"platform.h\"\n#include \"options.h\"\n#include <iostream>\n#include <sstream>\n\n// analysis passes\n#include <llvm/Analysis/Passes.h>\n#ifdef LLVM38\n#include <llvm/Analysis/BasicAliasAnalysis.h>\n#include <llvm/Analysis/TypeBasedAliasAnalysis.h>\n#endif\n#ifdef LLVM37\n#include <llvm/Analysis/TargetTransformInfo.h>\n#include <llvm/Analysis/TargetLibraryInfo.h>\n#endif\n#ifdef LLVM35\n#include <llvm/IR/Verifier.h>\n#else\n#include <llvm/Analysis/Verifier.h>\n#endif\n#if defined(USE_POLLY)\n#include <polly/RegisterPasses.h>\n#endif\n\n#include <llvm/Transforms/Scalar.h>\n#include <llvm/Transforms/Utils/BasicBlockUtils.h>\n#include <llvm/Transforms/Instrumentation.h>\n#include <llvm/Transforms/Vectorize.h>\n#ifdef LLVM39\n#include <llvm/Transforms/Scalar/GVN.h>\n#endif\n\nnamespace llvm {\n    extern Pass *createLowerSimdLoopPass();\n}\n\n#include <llvm/Bitcode/ReaderWriter.h>\n#ifdef LLVM35\n#include <llvm/Bitcode/BitcodeWriterPass.h>\n#endif\n\n#include <llvm/Transforms/Utils/Cloning.h>\n#include <llvm/ExecutionEngine/JITEventListener.h>\n\n// target support\n#include <llvm/ADT/Triple.h>\n#include <llvm/Support/TargetRegistry.h>\n#ifndef LLVM37\n#include <llvm/Target/TargetLibraryInfo.h>\n#endif\n#include <llvm/IR/DataLayout.h>\n#include <llvm/Support/DynamicLibrary.h>\n\n\n#include <llvm/Support/raw_ostream.h>\n#include <llvm/Support/FormattedStream.h>\n\nusing namespace llvm;\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"jitlayers.h\"\n#ifdef USE_MCJIT\nRTDyldMemoryManager* createRTDyldMemoryManager(void);\n#endif\n\nstatic Type *T_void;\nstatic IntegerType *T_uint32;\nstatic IntegerType *T_uint64;\nstatic IntegerType *T_size;\nstatic Type *T_psize;\nstatic Type *T_pvoidfunc;\nstatic Type *T_pjlvalue;\nvoid jl_init_jit(Type *T_pjlvalue_)\n{\n    T_void = Type::getVoidTy(jl_LLVMContext);\n    T_uint32 = Type::getInt32Ty(jl_LLVMContext);\n    T_uint64 = Type::getInt64Ty(jl_LLVMContext);\n    if (sizeof(size_t) == 8)\n        T_size = T_uint64;\n    else\n        T_size = T_uint32;\n    T_psize = PointerType::get(T_size, 0);\n    T_pvoidfunc = FunctionType::get(T_void, /*isVarArg*/false)->getPointerTo();\n    T_pjlvalue = T_pjlvalue_;\n}\n\n// Except for parts of this file which were copied from LLVM, under the UIUC license (marked below).\n\n// this defines the set of optimization passes defined for Julia at various optimization levels\n#ifdef LLVM37\nvoid addOptimizationPasses(legacy::PassManager *PM)\n#else\nvoid addOptimizationPasses(PassManager *PM)\n#endif\n{\n    PM->add(createLowerGCFramePass(tbaa_gcframe));\n#ifdef JL_DEBUG_BUILD\n    PM->add(createVerifierPass());\n#endif\n\n#if defined(JL_ASAN_ENABLED)\n#   if defined(LLVM37) && !defined(LLVM38)\n    // LLVM 3.7 BUG: ASAN pass doesn't properly initialize its dependencies\n    initializeTargetLibraryInfoWrapperPassPass(*PassRegistry::getPassRegistry());\n#   endif\n    PM->add(createAddressSanitizerFunctionPass());\n#endif\n#if defined(JL_MSAN_ENABLED)\n    PM->add(llvm::createMemorySanitizerPass(true));\n#endif\n    if (jl_options.opt_level == 0) {\n        PM->add(createLowerPTLSPass(imaging_mode, tbaa_const));\n        return;\n    }\n#ifdef LLVM37\n    PM->add(createTargetTransformInfoWrapperPass(jl_TargetMachine->getTargetIRAnalysis()));\n#else\n    jl_TargetMachine->addAnalysisPasses(*PM);\n#endif\n#ifdef LLVM38\n    PM->add(createTypeBasedAAWrapperPass());\n#else\n    PM->add(createTypeBasedAliasAnalysisPass());\n#endif\n    if (jl_options.opt_level >= 3) {\n#ifdef LLVM38\n        PM->add(createBasicAAWrapperPass());\n#else\n        PM->add(createBasicAliasAnalysisPass());\n#endif\n    }\n    // list of passes from vmkit\n    PM->add(createCFGSimplificationPass()); // Clean up disgusting code\n    PM->add(createPromoteMemoryToRegisterPass());// Kill useless allocas\n\n#ifndef INSTCOMBINE_BUG\n    PM->add(createInstructionCombiningPass()); // Cleanup for scalarrepl.\n#endif\n    // Let the InstCombine pass remove the unnecessary load of\n    // safepoint address first\n    PM->add(createLowerPTLSPass(imaging_mode, tbaa_const));\n    PM->add(createSROAPass());                 // Break up aggregate allocas\n#ifndef INSTCOMBINE_BUG\n    PM->add(createInstructionCombiningPass()); // Cleanup for scalarrepl.\n#endif\n    PM->add(createJumpThreadingPass());        // Thread jumps.\n    // NOTE: CFG simp passes after this point seem to hurt native codegen.\n    // See issue #6112. Should be re-evaluated when we switch to MCJIT.\n    //PM->add(createCFGSimplificationPass());    // Merge & remove BBs\n#ifndef INSTCOMBINE_BUG\n    PM->add(createInstructionCombiningPass()); // Combine silly seq's\n#endif\n\n    //PM->add(createCFGSimplificationPass());    // Merge & remove BBs\n    PM->add(createReassociatePass());          // Reassociate expressions\n\n    // this has the potential to make some things a bit slower\n    //PM->add(createBBVectorizePass());\n\n    PM->add(createEarlyCSEPass()); //// ****\n\n#ifdef USE_POLLY\n    polly::registerPollyPasses(*PM);\n#endif\n\n    PM->add(createLoopIdiomPass()); //// ****\n    PM->add(createLoopRotatePass());           // Rotate loops.\n    // LoopRotate strips metadata from terminator, so run LowerSIMD afterwards\n    PM->add(createLowerSimdLoopPass());        // Annotate loop marked with \"simdloop\" as LLVM parallel loop\n    PM->add(createLICMPass());                 // Hoist loop invariants\n    PM->add(createLoopUnswitchPass());         // Unswitch loops.\n    // Subsequent passes not stripping metadata from terminator\n#ifndef INSTCOMBINE_BUG\n    PM->add(createInstructionCombiningPass());\n#endif\n    PM->add(createIndVarSimplifyPass());       // Canonicalize indvars\n    PM->add(createLoopDeletionPass());         // Delete dead loops\n#if defined(LLVM35)\n    PM->add(createSimpleLoopUnrollPass());     // Unroll small loops\n#else\n    PM->add(createLoopUnrollPass());           // Unroll small loops\n#endif\n#if !defined(LLVM35) && !defined(INSTCOMBINE_BUG)\n    PM->add(createLoopVectorizePass());        // Vectorize loops\n#endif\n    //PM->add(createLoopStrengthReducePass());   // (jwb added)\n\n#ifndef INSTCOMBINE_BUG\n    PM->add(createInstructionCombiningPass()); // Clean up after the unroller\n#endif\n    PM->add(createGVNPass());                  // Remove redundancies\n    PM->add(createMemCpyOptPass());            // Remove memcpy / form memset\n    PM->add(createSCCPPass());                 // Constant prop with SCCP\n\n    // Run instcombine after redundancy elimination to exploit opportunities\n    // opened up by them.\n    PM->add(createSinkingPass()); ////////////// ****\n    PM->add(createInstructionSimplifierPass());///////// ****\n#ifndef INSTCOMBINE_BUG\n    PM->add(createInstructionCombiningPass());\n#endif\n    PM->add(createJumpThreadingPass());         // Thread jumps\n    PM->add(createDeadStoreEliminationPass());  // Delete dead stores\n#if !defined(INSTCOMBINE_BUG)\n    if (jl_options.opt_level >= 3) {\n        PM->add(createSLPVectorizerPass());     // Vectorize straight-line code\n    }\n#endif\n\n    PM->add(createAggressiveDCEPass());         // Delete dead instructions\n#if !defined(INSTCOMBINE_BUG)\n    if (jl_options.opt_level >= 3)\n        PM->add(createInstructionCombiningPass());   // Clean up after SLP loop vectorizer\n#endif\n#if defined(LLVM35)\n    PM->add(createLoopVectorizePass());         // Vectorize loops\n    PM->add(createInstructionCombiningPass());  // Clean up after loop vectorizer\n#endif\n    //PM->add(createCFGSimplificationPass());     // Merge & remove BBs\n}\n\n#ifdef USE_ORCJIT\n\n#ifndef LLVM38\nvoid notifyObjectLoaded(RTDyldMemoryManager *memmgr,\n                        llvm::orc::ObjectLinkingLayerBase::ObjSetHandleT H);\n#endif\n\n// ------------------------ TEMPORARILY COPIED FROM LLVM -----------------\n// This must be kept in sync with gdb/gdb/jit.h .\nextern \"C\" {\n\n  typedef enum {\n    JIT_NOACTION = 0,\n    JIT_REGISTER_FN,\n    JIT_UNREGISTER_FN\n  } jit_actions_t;\n\n  struct jit_code_entry {\n    struct jit_code_entry *next_entry;\n    struct jit_code_entry *prev_entry;\n    const char *symfile_addr;\n    uint64_t symfile_size;\n  };\n\n  struct jit_descriptor {\n    uint32_t version;\n    // This should be jit_actions_t, but we want to be specific about the\n    // bit-width.\n    uint32_t action_flag;\n    struct jit_code_entry *relevant_entry;\n    struct jit_code_entry *first_entry;\n  };\n\n  // We put information about the JITed function in this global, which the\n  // debugger reads.  Make sure to specify the version statically, because the\n  // debugger checks the version before we can set it during runtime.\n  extern struct jit_descriptor __jit_debug_descriptor;\n\n  LLVM_ATTRIBUTE_NOINLINE extern void __jit_debug_register_code();\n}\n\nnamespace {\n\nusing namespace llvm;\nusing namespace llvm::object;\nusing namespace llvm::orc;\n\n/// Do the registration.\nvoid NotifyDebugger(jit_code_entry *JITCodeEntry)\n{\n    __jit_debug_descriptor.action_flag = JIT_REGISTER_FN;\n\n    // Insert this entry at the head of the list.\n    JITCodeEntry->prev_entry = nullptr;\n    jit_code_entry *NextEntry = __jit_debug_descriptor.first_entry;\n    JITCodeEntry->next_entry = NextEntry;\n    if (NextEntry) {\n        NextEntry->prev_entry = JITCodeEntry;\n    }\n    __jit_debug_descriptor.first_entry = JITCodeEntry;\n    __jit_debug_descriptor.relevant_entry = JITCodeEntry;\n    __jit_debug_register_code();\n}\n}\n// ------------------------ END OF TEMPORARY COPY FROM LLVM -----------------\n\n#ifdef _OS_LINUX_\n// Resolve non-lock free atomic functions in the libatomic library.\n// This is the library that provides support for c11/c++11 atomic operations.\nstatic uint64_t resolve_atomic(const char *name)\n{\n    static void *atomic_hdl = jl_load_dynamic_library_e(\"libatomic\",\n                                                        JL_RTLD_LOCAL);\n    static const char *const atomic_prefix = \"__atomic_\";\n    if (!atomic_hdl)\n        return 0;\n    if (strncmp(name, atomic_prefix, strlen(atomic_prefix)) != 0)\n        return 0;\n    return (uintptr_t)jl_dlsym_e(atomic_hdl, name);\n}\n#endif\n\n// Custom object emission notification handler for the JuliaOJIT\nextern JITEventListener *CreateJuliaJITEventListener();\nJuliaOJIT::DebugObjectRegistrar::DebugObjectRegistrar(JuliaOJIT &JIT)\n    : JuliaListener(CreateJuliaJITEventListener()),\n      JIT(JIT) {}\n\nJL_DLLEXPORT void ORCNotifyObjectEmitted(JITEventListener *Listener,\n                                         const object::ObjectFile &obj,\n                                         const object::ObjectFile &debugObj,\n                                         const RuntimeDyld::LoadedObjectInfo &L,\n                                         RTDyldMemoryManager *memmgr);\n\n// TODO: hook up RegisterJITEventListener, instead of hard-coding the GDB and JuliaListener targets\ntemplate <typename ObjSetT, typename LoadResult>\nvoid JuliaOJIT::DebugObjectRegistrar::operator()(ObjectLinkingLayerBase::ObjSetHandleT H, const ObjSetT &Objects,\n                const LoadResult &LOS)\n{\n#ifndef LLVM38\n    notifyObjectLoaded(JIT.MemMgr, H);\n#endif\n    auto oit = Objects.begin();\n    auto lit = LOS.begin();\n    for (; oit != Objects.end(); ++oit, ++lit) {\n#ifdef LLVM39\n        const auto &Object = (*oit)->getBinary();\n#else\n        auto &Object = *oit;\n#endif\n        auto &LO = *lit;\n\n        OwningBinary<object::ObjectFile> SavedObject = LO->getObjectForDebug(*Object);\n\n        // If the debug object is unavailable, save (a copy of) the original object\n        // for our backtraces\n        if (!SavedObject.getBinary()) {\n            // This is unfortunate, but there doesn't seem to be a way to take\n            // ownership of the original buffer\n            auto NewBuffer = MemoryBuffer::getMemBufferCopy(Object->getData(), Object->getFileName());\n            auto NewObj = ObjectFile::createObjectFile(NewBuffer->getMemBufferRef());\n            assert(NewObj);\n            SavedObject = OwningBinary<object::ObjectFile>(std::move(*NewObj),std::move(NewBuffer));\n        }\n        else {\n            NotifyGDB(SavedObject);\n        }\n\n        SavedObjects.push_back(std::move(SavedObject));\n\n        ORCNotifyObjectEmitted(JuliaListener.get(),\n                *Object,\n                *SavedObjects.back().getBinary(),\n                *LO, JIT.MemMgr);\n\n        // record all of the exported symbols defined in this object\n        // in the primary hash table for the enclosing JIT\n        for (auto &Symbol : Object->symbols()) {\n            auto Flags = Symbol.getFlags();\n            if (Flags & object::BasicSymbolRef::SF_Undefined)\n                continue;\n            if (!(Flags & object::BasicSymbolRef::SF_Exported))\n                continue;\n            auto NameOrError = Symbol.getName();\n            assert(NameOrError);\n            auto Name = NameOrError.get();\n            orc::JITSymbol Sym = JIT.CompileLayer.findSymbolIn(H, Name, true);\n            assert(Sym);\n            // note: calling getAddress here eagerly finalizes H\n            // as an alternative, we could store the JITSymbol instead\n            // (which would present a lazy-initializer functor interface instead)\n            JIT.LocalSymbolTable[Name] = (void*)(uintptr_t)Sym.getAddress();\n        }\n    }\n}\n\nvoid JuliaOJIT::DebugObjectRegistrar::NotifyGDB(OwningBinary<object::ObjectFile> &DebugObj)\n{\n    const char *Buffer = DebugObj.getBinary()->getMemoryBufferRef().getBufferStart();\n    size_t      Size = DebugObj.getBinary()->getMemoryBufferRef().getBufferSize();\n\n    assert(Buffer && \"Attempt to register a null object with a debugger.\");\n    jit_code_entry *JITCodeEntry = new jit_code_entry();\n\n    if (!JITCodeEntry) {\n        jl_printf(JL_STDERR, \"WARNING: Allocation failed when registering a JIT entry!\\n\");\n    }\n    else {\n        JITCodeEntry->symfile_addr = Buffer;\n        JITCodeEntry->symfile_size = Size;\n\n        NotifyDebugger(JITCodeEntry);\n    }\n}\n\nJuliaOJIT::JuliaOJIT(TargetMachine &TM)\n  : TM(TM),\n    DL(TM.createDataLayout()),\n    ObjStream(ObjBufferSV),\n    MemMgr(createRTDyldMemoryManager()),\n    ObjectLayer(DebugObjectRegistrar(*this)),\n    CompileLayer(\n            ObjectLayer,\n            [this](Module &M) {\n                JL_TIMING(LLVM_OPT);\n                PM.run(M);\n                std::unique_ptr<MemoryBuffer> ObjBuffer(\n                    new ObjectMemoryBuffer(std::move(ObjBufferSV)));\n                auto Obj = object::ObjectFile::createObjectFile(ObjBuffer->getMemBufferRef());\n\n                if (!Obj) {\n                    M.dump();\n#ifdef LLVM39\n                    std::string Buf;\n                    raw_string_ostream OS(Buf);\n                    logAllUnhandledErrors(Obj.takeError(), OS, \"\");\n                    OS.flush();\n                    llvm::report_fatal_error(\"FATAL: Unable to compile LLVM Module: '\" + Buf + \"'\\n\"\n                        \"The module's content was printed above. Please file a bug report\");\n#else\n                    llvm::report_fatal_error(\"FATAL: Unable to compile LLVM Module.\\n\"\n                        \"The module's content was printed above. Please file a bug report\");\n#endif\n                }\n\n                return OwningObj(std::move(*Obj), std::move(ObjBuffer));\n            }\n        )\n{\n    addOptimizationPasses(&PM);\n    if (TM.addPassesToEmitMC(PM, Ctx, ObjStream))\n        llvm_unreachable(\"Target does not support MC emission.\");\n\n    // Make sure SectionMemoryManager::getSymbolAddressInProcess can resolve\n    // symbols in the program as well. The nullptr argument to the function\n    // tells DynamicLibrary to load the program, not a library.\n    std::string *ErrorStr = nullptr;\n    if (sys::DynamicLibrary::LoadLibraryPermanently(nullptr, ErrorStr))\n        report_fatal_error(\"FATAL: unable to dlopen self\\n\" + *ErrorStr);\n}\n\nvoid JuliaOJIT::addGlobalMapping(StringRef Name, uint64_t Addr)\n{\n    bool successful = GlobalSymbolTable.insert(std::make_pair(Name, (void*)Addr)).second;\n    (void)successful;\n    assert(successful);\n}\n\nvoid JuliaOJIT::addGlobalMapping(const GlobalValue *GV, void *Addr)\n{\n    addGlobalMapping(getMangledName(GV), (uintptr_t)Addr);\n}\n\nvoid *JuliaOJIT::getPointerToGlobalIfAvailable(StringRef S)\n{\n    SymbolTableT::const_iterator pos = GlobalSymbolTable.find(S);\n    if (pos != GlobalSymbolTable.end())\n        return pos->second;\n    return nullptr;\n}\n\nvoid *JuliaOJIT::getPointerToGlobalIfAvailable(const GlobalValue *GV)\n{\n    return getPointerToGlobalIfAvailable(getMangledName(GV));\n}\n\n\nvoid JuliaOJIT::addModule(std::unique_ptr<Module> M)\n{\n#ifndef NDEBUG\n    // validate the relocations for M\n    for (Module::iterator I = M->begin(), E = M->end(); I != E; ) {\n        Function *F = &*I;\n        ++I;\n        if (F->isDeclaration()) {\n            if (F->use_empty())\n                F->eraseFromParent();\n            else if (!(isIntrinsicFunction(F) ||\n                       findUnmangledSymbol(F->getName()) ||\n                       SectionMemoryManager::getSymbolAddressInProcess(\n                           F->getName()))) {\n                std::cerr << \"FATAL ERROR: \"\n                          << \"Symbol \\\"\" << F->getName().str() << \"\\\"\"\n                          << \"not found\";\n                abort();\n            }\n        }\n    }\n#endif\n    JL_TIMING(LLVM_MODULE_FINISH);\n    // We need a memory manager to allocate memory and resolve symbols for this\n    // new module. Create one that resolves symbols by looking back into the JIT.\n    auto Resolver = orc::createLambdaResolver(\n                      [&](const std::string &Name) {\n                        // TODO: consider moving the FunctionMover resolver here\n                        // Step 0: ObjectLinkingLayer has checked whether it is in the current module\n                        // Step 1: See if it's something known to the ExecutionEngine\n                        if (auto Sym = findSymbol(Name, true))\n                          return RuntimeDyld::SymbolInfo(Sym.getAddress(),\n                                                         Sym.getFlags());\n                        // Step 2: Search the program symbols\n                        if (uint64_t addr = SectionMemoryManager::getSymbolAddressInProcess(Name))\n                            return RuntimeDyld::SymbolInfo(addr, JITSymbolFlags::Exported);\n#ifdef _OS_LINUX_\n                        if (uint64_t addr = resolve_atomic(Name.c_str()))\n                            return RuntimeDyld::SymbolInfo(addr, JITSymbolFlags::Exported);\n#endif\n                        // Return failure code\n                        return RuntimeDyld::SymbolInfo(nullptr);\n                      },\n                      [](const std::string &S) { return nullptr; }\n                    );\n    SmallVector<std::unique_ptr<Module>,1> Ms;\n    Ms.push_back(std::move(M));\n    auto modset = CompileLayer.addModuleSet(std::move(Ms), MemMgr,\n                                            std::move(Resolver));\n    // Force LLVM to emit the module so that we can register the symbols\n    // in our lookup table.\n    CompileLayer.emitAndFinalize(modset);\n}\n\nvoid JuliaOJIT::removeModule(ModuleHandleT H)\n{\n    CompileLayer.removeModuleSet(H);\n}\n\norc::JITSymbol JuliaOJIT::findSymbol(const std::string &Name, bool ExportedSymbolsOnly)\n{\n    void *Addr = nullptr;\n    if (ExportedSymbolsOnly) {\n        // Step 1: Check against list of known external globals\n        Addr = getPointerToGlobalIfAvailable(Name);\n    }\n    // Step 2: Search all previously emitted symbols\n    if (Addr == nullptr)\n        Addr = LocalSymbolTable[Name];\n    return orc::JITSymbol((uintptr_t)Addr, JITSymbolFlags::Exported);\n}\n\norc::JITSymbol JuliaOJIT::findUnmangledSymbol(const std::string Name)\n{\n    return findSymbol(getMangledName(Name), true);\n}\n\nuint64_t JuliaOJIT::getGlobalValueAddress(const std::string &Name)\n{\n    return findSymbol(getMangledName(Name), false).getAddress();\n}\n\nuint64_t JuliaOJIT::getFunctionAddress(const std::string &Name)\n{\n    return findSymbol(getMangledName(Name), false).getAddress();\n}\n\nFunction *JuliaOJIT::FindFunctionNamed(const std::string &Name)\n{\n    return shadow_output->getFunction(Name);\n}\n\nvoid JuliaOJIT::RegisterJITEventListener(JITEventListener *L)\n{\n    // TODO\n}\n\nconst DataLayout& JuliaOJIT::getDataLayout() const\n{\n    return DL;\n}\n\nconst Triple& JuliaOJIT::getTargetTriple() const\n{\n    return TM.getTargetTriple();\n}\n\nstd::string JuliaOJIT::getMangledName(const std::string &Name)\n{\n    SmallString<128> FullName;\n    Mangler::getNameWithPrefix(FullName, Name, DL);\n    return FullName.str();\n}\n\nstd::string JuliaOJIT::getMangledName(const GlobalValue *GV)\n{\n    return getMangledName(GV->getName());\n}\n\nJuliaOJIT *jl_ExecutionEngine;\n#else\nExecutionEngine *jl_ExecutionEngine;\n#endif\n\n// MSVC's link.exe requires each function declaration to have a Comdat section\n// So rather than litter the code with conditionals,\n// all global values that get emitted call this function\n// and it decides whether the definition needs a Comdat section and adds the appropriate declaration\n// TODO: consider moving this into jl_add_to_shadow or jl_dump_shadow? the JIT doesn't care, so most calls are now no-ops\ntemplate<class T> // for GlobalObject's\nstatic T *addComdat(T *G)\n{\n#if defined(_OS_WINDOWS_) && defined(LLVM35)\n    if (imaging_mode && !G->isDeclaration()) {\n        // Add comdat information to make MSVC link.exe happy\n        // it's valid to emit this for ld.exe too,\n        // but makes it very slow to link for no benefit\n        if (G->getParent() == shadow_output) {\n#if defined(_COMPILER_MICROSOFT_)\n            Comdat *jl_Comdat = G->getParent()->getOrInsertComdat(G->getName());\n            // ELF only supports Comdat::Any\n            jl_Comdat->setSelectionKind(Comdat::NoDuplicates);\n            G->setComdat(jl_Comdat);\n#endif\n#if defined(_CPU_X86_64_)\n            // Add unwind exception personalities to functions to handle async exceptions\n            assert(!juliapersonality_func || juliapersonality_func->getParent() == shadow_output);\n            if (Function *F = dyn_cast<Function>(G))\n                F->setPersonalityFn(juliapersonality_func);\n#endif\n        }\n        // add __declspec(dllexport) to everything marked for export\n        if (G->getLinkage() == GlobalValue::ExternalLinkage)\n            G->setDLLStorageClass(GlobalValue::DLLExportStorageClass);\n        else\n            G->setDLLStorageClass(GlobalValue::DefaultStorageClass);\n    }\n#endif\n    return G;\n}\n\n// destructively move the contents of src into dest\n// this assumes that the targets of the two modules are the same\n// including the DataLayout and ModuleFlags (for example)\n// and that there is no module-level assembly\nstatic void jl_merge_module(Module *dest, std::unique_ptr<Module> src)\n{\n    assert(dest != src.get());\n    for (Module::global_iterator I = src->global_begin(), E = src->global_end(); I != E;) {\n        GlobalVariable *sG = &*I;\n        GlobalValue *dG = dest->getNamedValue(sG->getName());\n        ++I;\n        // Replace a declaration with the definition:\n        if (dG) {\n            if (sG->isDeclaration()) {\n                sG->replaceAllUsesWith(dG);\n                sG->eraseFromParent();\n                continue;\n            }\n            else {\n                dG->replaceAllUsesWith(sG);\n                dG->eraseFromParent();\n            }\n        }\n        // Reparent the global variable:\n        sG->removeFromParent();\n        dest->getGlobalList().push_back(sG);\n        // Comdat is owned by the Module, recreate it in the new parent:\n        addComdat(sG);\n    }\n\n    for (Module::iterator I = src->begin(), E = src->end(); I != E;) {\n        Function *sG = &*I;\n        GlobalValue *dG = dest->getNamedValue(sG->getName());\n        ++I;\n        // Replace a declaration with the definition:\n        if (dG) {\n            if (sG->isDeclaration()) {\n                sG->replaceAllUsesWith(dG);\n                sG->eraseFromParent();\n                continue;\n            }\n            else {\n                dG->replaceAllUsesWith(sG);\n                dG->eraseFromParent();\n            }\n        }\n        // Reparent the global variable:\n        sG->removeFromParent();\n        dest->getFunctionList().push_back(sG);\n        // Comdat is owned by the Module, recreate it in the new parent:\n        addComdat(sG);\n    }\n\n    for (Module::alias_iterator I = src->alias_begin(), E = src->alias_end(); I != E;) {\n        GlobalAlias *sG = &*I;\n        GlobalValue *dG = dest->getNamedValue(sG->getName());\n        ++I;\n        if (dG) {\n            if (!dG->isDeclaration()) { // aliases are always definitions, so this test is reversed from the above two\n                sG->replaceAllUsesWith(dG);\n                sG->eraseFromParent();\n                continue;\n            }\n            else {\n                dG->replaceAllUsesWith(sG);\n                dG->eraseFromParent();\n            }\n        }\n        sG->removeFromParent();\n        dest->getAliasList().push_back(sG);\n    }\n\n    // metadata nodes need to be explicitly merged not just copied\n    // so there are special passes here for each known type of metadata\n    NamedMDNode *sNMD = src->getNamedMetadata(\"llvm.dbg.cu\");\n    if (sNMD) {\n        NamedMDNode *dNMD = dest->getOrInsertNamedMetadata(\"llvm.dbg.cu\");\n#ifdef LLVM35\n        for (NamedMDNode::op_iterator I = sNMD->op_begin(), E = sNMD->op_end(); I != E; ++I) {\n            dNMD->addOperand(*I);\n        }\n#else\n        for (unsigned i = 0, l = sNMD->getNumOperands(); i < l; i++) {\n            dNMD->addOperand(sNMD->getOperand(i));\n        }\n#endif\n    }\n}\n\n// to finalizing a function, look up its name in the `module_for_fname` map of unfinalized functions\n// and merge it, plus any other modules it depends upon, into `collector`\n// then add `collector` to the execution engine\n//\n// in the old JIT, functions are finalized by adding them to the shadow module\n// (which aliases the engine module), so this is unneeded\n#ifdef USE_MCJIT\nstatic StringMap<Module*> module_for_fname;\nstatic void jl_finalize_function(const std::string &F, Module *collector)\n{\n    std::unique_ptr<Module> m(module_for_fname.lookup(F));\n    if (m) {\n        // probably not many unresolved declarations, but be sure iterate over their Names,\n        // since the declarations may get destroyed by the jl_merge_module call.\n        // this is also why we copy the Name string, rather than save a StringRef\n        SmallVector<std::string, 8> to_finalize;\n        for (Module::iterator I = m->begin(), E = m->end(); I != E; ++I) {\n            Function *F = &*I;\n            if (!F->isDeclaration()) {\n                module_for_fname.erase(F->getName());\n            }\n            else if (!isIntrinsicFunction(F)) {\n                to_finalize.push_back(F->getName().str());\n            }\n        }\n\n        for (const auto F : to_finalize) {\n            jl_finalize_function(F, collector ? collector : m.get());\n        }\n\n        if (collector) {\n            jl_merge_module(collector, std::move(m));\n        }\n        else {\n#if defined(_CPU_X86_64_) && defined(_OS_WINDOWS_) && defined(LLVM35)\n            // Add special values used by debuginfo to build the UnwindData table registration for Win64\n            ArrayType *atype = ArrayType::get(T_uint32, 3); // want 4-byte alignment of 12-bytes of data\n            (new GlobalVariable(*m, atype,\n                false, GlobalVariable::InternalLinkage,\n                ConstantAggregateZero::get(atype), \"__UnwindData\"))->setSection(\".text\");\n            (new GlobalVariable(*m, atype,\n                false, GlobalVariable::InternalLinkage,\n                ConstantAggregateZero::get(atype), \"__catchjmp\"))->setSection(\".text\");\n#endif\n            assert(jl_ExecutionEngine);\n#if defined(LLVM36)\n            jl_ExecutionEngine->addModule(std::move(m));\n#else\n            jl_ExecutionEngine->addModule(m.release());\n#endif\n        }\n    }\n}\nvoid jl_finalize_function(Function *F, Module *collector)\n{\n    jl_finalize_function(F->getName().str(), collector);\n}\n#endif\n\n// this takes ownership of a module after code emission is complete\n// and will add it to the execution engine when required (by jl_finalize_function)\nvoid jl_finalize_module(Module *m, bool shadow)\n{\n#if !defined(USE_ORCJIT)\n    jl_globalPM->run(*m);\n#endif\n#ifdef USE_MCJIT\n    // record the function names that are part of this Module\n    // so it can be added to the JIT when needed\n    for (Module::iterator I = m->begin(), E = m->end(); I != E; ++I) {\n        Function *F = &*I;\n        if (!F->isDeclaration())\n            module_for_fname[F->getName()] = m;\n    }\n#endif\n#if defined(USE_ORCJIT) || defined(USE_MCJIT)\n    // in the newer JITs, the shadow module is separate from the execution module\n    if (shadow)\n#endif\n        jl_add_to_shadow(m);\n}\n\n// helper function for adding a DLLImport (dlsym) address to the execution engine\n// (for values created locally or in the sysimage, jl_emit_and_add_to_shadow is generally preferable)\n#ifdef LLVM35\nvoid add_named_global(GlobalObject *gv, void *addr, bool dllimport)\n#else\nvoid add_named_global(GlobalValue *gv, void *addr, bool dllimport)\n#endif\n{\n#ifdef _OS_WINDOWS_\n    // setting JL_DLLEXPORT correctly only matters when building a binary\n    // (global_proto will strip this from the JIT)\n    if (dllimport && imaging_mode) {\n        assert(gv->getLinkage() == GlobalValue::ExternalLinkage);\n#ifdef LLVM35\n        // add the __declspec(dllimport) attribute\n        gv->setDLLStorageClass(GlobalValue::DLLImportStorageClass);\n#else\n        gv->setLinkage(GlobalValue::DLLImportLinkage);\n#if defined(_P64)\n        // __imp_ variables are indirection pointers, so use malloc to simulate that\n        void **imp_addr = (void**)malloc(sizeof(void*));\n        *imp_addr = addr;\n        addr = (void*)imp_addr;\n#endif\n#endif\n    }\n#endif // _OS_WINDOWS_\n\n    jl_ExecutionEngine->addGlobalMapping(gv, addr);\n}\n\nstatic std::vector<Constant*> jl_sysimg_gvars;\nstatic std::vector<Constant*> jl_sysimg_fvars;\nstatic std::map<void*, jl_value_llvm> jl_value_to_llvm;\n\n// global variables to pointers are pretty common,\n// so this method is available as a convenience for emitting them.\n// for other types, the formula for implementation is straightforward:\n// (see stringConstPtr, for an alternative example to the code below)\n//\n// if in imaging_mode, emit a GlobalVariable with the same name and an initializer to the shadow_module\n// making it valid for emission and reloading in the sysimage\n//\n// then add a global mapping to the current value (usually from calloc'd space)\n// to the execution engine to make it valid for the current session (with the current value)\nvoid* jl_emit_and_add_to_shadow(GlobalVariable *gv, void *gvarinit)\n{\n    PointerType *T = cast<PointerType>(gv->getType()->getElementType()); // pointer is the only supported type here\n\n    GlobalVariable *shadowvar = NULL;\n#if defined(USE_MCJIT) || defined(USE_ORCJIT)\n    if (imaging_mode)\n#endif\n        shadowvar = global_proto(gv, shadow_output);\n\n    if (shadowvar) {\n        shadowvar->setInitializer(ConstantPointerNull::get(T));\n        shadowvar->setLinkage(GlobalVariable::InternalLinkage);\n        addComdat(shadowvar);\n        if (imaging_mode && gvarinit) {\n            // make the pointer valid for future sessions\n            jl_sysimg_gvars.push_back(ConstantExpr::getBitCast(shadowvar, T_psize));\n            jl_value_llvm gv_struct;\n            gv_struct.gv = global_proto(gv);\n            gv_struct.index = jl_sysimg_gvars.size();\n            jl_value_to_llvm[gvarinit] = gv_struct;\n        }\n    }\n\n    // make the pointer valid for this session\n#if defined(USE_MCJIT) || defined(USE_ORCJIT)\n    void *slot = calloc(1, sizeof(void*));\n    jl_ExecutionEngine->addGlobalMapping(gv, slot);\n    return slot;\n#else\n    return jl_ExecutionEngine->getPointerToGlobal(shadowvar);\n#endif\n}\n\n// Emit a slot in the system image to be filled at sysimg init time.\n// Returns the global var. Fill `idx` with 1-base index in the sysimg gv.\n// Use as an optimization for runtime constant addresses to have one less\n// load. (Used only by threading).\nGlobalVariable *jl_emit_sysimg_slot(Module *m, Type *typ, const char *name,\n                                           uintptr_t init, size_t &idx)\n{\n    assert(imaging_mode);\n    // This is **NOT** a external variable or a normal global variable\n    // This is a special internal global slot with a special index\n    // in the global variable table.\n    GlobalVariable *gv = new GlobalVariable(*m, typ, false,\n                                            GlobalVariable::InternalLinkage,\n                                            ConstantPointerNull::get((PointerType*)typ), name);\n    addComdat(gv);\n    // make the pointer valid for this session\n#if defined(USE_MCJIT) || defined(USE_ORCJIT)\n    auto p = new uintptr_t(init);\n    jl_ExecutionEngine->addGlobalMapping(gv, (void*)p);\n#else\n    uintptr_t *p = (uintptr_t*)jl_ExecutionEngine->getPointerToGlobal(gv);\n    *p = init;\n#endif\n    jl_sysimg_gvars.push_back(ConstantExpr::getBitCast(gv, T_psize));\n    idx = jl_sysimg_gvars.size();\n    return gv;\n}\n\nvoid* jl_get_global(GlobalVariable *gv)\n{\n#if defined(USE_MCJIT) || defined(USE_ORCJIT)\n    void *p = (void*)(intptr_t)jl_ExecutionEngine->getPointerToGlobalIfAvailable(gv);\n#else\n    void *p = jl_ExecutionEngine->getPointerToGlobal(\n            shadow_output->getNamedValue(gv->getName()));\n#endif\n    assert(p);\n    return p;\n}\n\n// clones the contents of the module `m` to the shadow_output collector\n// in the old JIT, this is equivalent to also adding it to the execution engine\nvoid jl_add_to_shadow(Module *m)\n{\n#if defined(USE_MCJIT) || defined(USE_ORCJIT)\n#ifndef KEEP_BODIES\n    if (!imaging_mode)\n        return;\n#endif\n    ValueToValueMapTy VMap;\n    std::unique_ptr<Module> clone(CloneModule(m, VMap));\n    for (Module::iterator I = clone->begin(), E = clone->end(); I != E; ++I) {\n        Function *F = &*I;\n        if (!F->isDeclaration()) {\n            F->setLinkage(Function::InternalLinkage);\n            addComdat(F);\n        }\n    }\n#else\n    // on the old jit, the shadow_module is the same as the execution engine_module\n    std::unique_ptr<Module> clone(m);\n#endif\n    jl_merge_module(shadow_output, std::move(clone));\n}\n\n#ifdef HAVE_CPUID\nextern \"C\" {\n    extern void jl_cpuid(int32_t CPUInfo[4], int32_t InfoType);\n}\n#endif\n\nstatic void jl_gen_llvm_globaldata(llvm::Module *mod, ValueToValueMapTy &VMap,\n                                   const char *sysimg_data, size_t sysimg_len)\n{\n    ArrayType *gvars_type = ArrayType::get(T_psize, jl_sysimg_gvars.size());\n    addComdat(new GlobalVariable(*mod,\n                                 gvars_type,\n                                 true,\n                                 GlobalVariable::ExternalLinkage,\n                                 MapValue(ConstantArray::get(gvars_type, ArrayRef<Constant*>(jl_sysimg_gvars)), VMap),\n                                 \"jl_sysimg_gvars\"));\n    ArrayType *fvars_type = ArrayType::get(T_pvoidfunc, jl_sysimg_fvars.size());\n    addComdat(new GlobalVariable(*mod,\n                                 fvars_type,\n                                 true,\n                                 GlobalVariable::ExternalLinkage,\n                                 MapValue(ConstantArray::get(fvars_type, ArrayRef<Constant*>(jl_sysimg_fvars)), VMap),\n                                 \"jl_sysimg_fvars\"));\n    addComdat(new GlobalVariable(*mod,\n                                 T_size,\n                                 true,\n                                 GlobalVariable::ExternalLinkage,\n                                 ConstantInt::get(T_size, globalUnique+1),\n                                 \"jl_globalUnique\"));\n#ifdef JULIA_ENABLE_THREADING\n    addComdat(new GlobalVariable(*mod,\n                                 T_size,\n                                 true,\n                                 GlobalVariable::ExternalLinkage,\n                                 ConstantInt::get(T_size, jltls_states_func_idx),\n                                 \"jl_ptls_states_getter_idx\"));\n#endif\n\n    Constant *feature_string = ConstantDataArray::getString(jl_LLVMContext, jl_options.cpu_target);\n    addComdat(new GlobalVariable(*mod,\n                                 feature_string->getType(),\n                                 true,\n                                 GlobalVariable::ExternalLinkage,\n                                 feature_string,\n                                 \"jl_sysimg_cpu_target\"));\n\n#ifdef HAVE_CPUID\n    // For native also store the cpuid\n    if (strcmp(jl_options.cpu_target,\"native\") == 0) {\n        uint32_t info[4];\n\n        jl_cpuid((int32_t*)info, 1);\n        addComdat(new GlobalVariable(*mod,\n                                     T_uint64,\n                                     true,\n                                     GlobalVariable::ExternalLinkage,\n                                     ConstantInt::get(T_uint64,((uint64_t)info[2])|(((uint64_t)info[3])<<32)),\n                                     \"jl_sysimg_cpu_cpuid\"));\n    }\n#endif\n\n    if (sysimg_data) {\n        Constant *data = ConstantDataArray::get(jl_LLVMContext, ArrayRef<uint8_t>((const unsigned char*)sysimg_data, sysimg_len));\n        addComdat(new GlobalVariable(*mod, data->getType(), true,\n                                     GlobalVariable::ExternalLinkage,\n                                     data, \"jl_system_image_data\"));\n        Constant *len = ConstantInt::get(T_size, sysimg_len);\n        addComdat(new GlobalVariable(*mod, len->getType(), true,\n                                     GlobalVariable::ExternalLinkage,\n                                     len, \"jl_system_image_size\"));\n    }\n}\n\n// takes the running content that has collected in the shadow module and dump it to disk\n// this builds the object file portion of the sysimage files for fast startup\nextern \"C\"\nvoid jl_dump_native(const char *bc_fname, const char *obj_fname, const char *sysimg_data, size_t sysimg_len)\n{\n    assert(imaging_mode);\n    // We don't want to use MCJIT's target machine because\n    // it uses the large code model and we may potentially\n    // want less optimizations there.\n    Triple TheTriple = Triple(jl_TargetMachine->getTargetTriple());\n    // make sure to emit the native object format, even if FORCE_ELF was set in codegen\n#if defined(_OS_WINDOWS_)\n#ifdef LLVM35\n    TheTriple.setObjectFormat(Triple::COFF);\n#else\n    TheTriple.setEnvironment(Triple::UnknownEnvironment);\n#endif\n#elif defined(_OS_DARWIN_)\n#ifdef LLVM35\n    TheTriple.setObjectFormat(Triple::MachO);\n#else\n    TheTriple.setEnvironment(Triple::MachO);\n#endif\n#endif\n#ifdef LLVM35\n    std::unique_ptr<TargetMachine>\n#else\n    OwningPtr<TargetMachine>\n#endif\n    TM(jl_TargetMachine->getTarget().createTargetMachine(\n        TheTriple.getTriple(),\n        jl_TargetMachine->getTargetCPU(),\n        jl_TargetMachine->getTargetFeatureString(),\n        jl_TargetMachine->Options,\n#if defined(_OS_LINUX_) || defined(_OS_FREEBSD_)\n        Reloc::PIC_,\n#elif defined(LLVM39)\n        Optional<Reloc::Model>(),\n#else\n        Reloc::Default,\n#endif\n        CodeModel::Default,\n        CodeGenOpt::Aggressive // -O3 TODO: respect command -O0 flag?\n        ));\n\n#ifdef LLVM37\n    legacy::PassManager PM;\n#else\n    PassManager PM;\n#endif\n#ifndef LLVM37\n    PM.add(new TargetLibraryInfo(Triple(TM->getTargetTriple())));\n#else\n    PM.add(new TargetLibraryInfoWrapperPass(Triple(TM->getTargetTriple())));\n#endif\n\n\n    // set up optimization passes\n#ifdef LLVM37\n    // No DataLayout pass needed anymore.\n#elif defined(LLVM36)\n    PM.add(new DataLayoutPass());\n#elif defined(LLVM35)\n    PM.add(new DataLayoutPass(*jl_ExecutionEngine->getDataLayout()));\n#else\n    PM.add(new DataLayout(*jl_ExecutionEngine->getDataLayout()));\n#endif\n\n    addOptimizationPasses(&PM);\n\n    std::unique_ptr<raw_fd_ostream> bc_OS;\n    std::unique_ptr<raw_fd_ostream> obj_OS;\n#ifdef LLVM37 // 3.7 simplified formatted output; just use the raw stream alone\n    std::unique_ptr<raw_fd_ostream> &bc_FOS = bc_OS;\n    std::unique_ptr<raw_fd_ostream> &obj_FOS = obj_OS;\n#else\n    std::unique_ptr<formatted_raw_ostream> bc_FOS;\n    std::unique_ptr<formatted_raw_ostream> obj_FOS;\n#endif\n\n    if (bc_fname) {\n#if defined(LLVM35)\n        // call output handler directly to avoid special case handling of `-` filename\n        int FD;\n        std::error_code EC = sys::fs::openFileForWrite(bc_fname, FD, sys::fs::F_None);\n        bc_OS.reset(new raw_fd_ostream(FD, true));\n        std::string err;\n        if (EC)\n            err = \"ERROR: failed to open --output-bc file '\" + std::string(bc_fname) + \"': \" + EC.message();\n#else\n        std::string err;\n        bc_OS.reset(new raw_fd_ostream(bc_fname, err, raw_fd_ostream::F_Binary));\n#endif\n        if (!err.empty())\n            jl_safe_printf(\"%s\\n\", err.c_str());\n        else {\n#ifndef LLVM37\n            bc_FOS.reset(new formatted_raw_ostream(*bc_OS.get()));\n#endif\n            PM.add(createBitcodeWriterPass(*bc_FOS.get()));     // Unroll small loops\n        }\n    }\n\n    if (obj_fname) {\n#if defined(LLVM35)\n        // call output handler directly to avoid special case handling of `-` filename\n        int FD;\n        std::error_code EC = sys::fs::openFileForWrite(obj_fname, FD, sys::fs::F_None);\n        obj_OS.reset(new raw_fd_ostream(FD, true));\n        std::string err;\n        if (EC)\n            err = \"ERROR: failed to open --output-o file '\" + std::string(obj_fname) + \"': \" + EC.message();\n#else\n        std::string err;\n        obj_OS.reset(new raw_fd_ostream(obj_fname, err, raw_fd_ostream::F_Binary));\n#endif\n        if (!err.empty())\n            jl_safe_printf(\"%s\\n\", err.c_str());\n        else {\n#ifndef LLVM37\n            obj_FOS.reset(new formatted_raw_ostream(*obj_OS.get()));\n#endif\n            if (TM->addPassesToEmitFile(PM, *obj_FOS.get(), TargetMachine::CGFT_ObjectFile, false)) {\n                jl_safe_printf(\"ERROR: target does not support generation of object files\\n\");\n            }\n        }\n    }\n\n    ValueToValueMapTy VMap;\n#if defined(USE_MCJIT) || defined(USE_ORCJIT)\n    // now copy the module (if using the old JIT), since PM.run may modify it\n    Module *clone = shadow_output;\n#else\n    Module *clone = CloneModule(shadow_output, VMap);\n#endif\n\n#ifdef LLVM37\n    // Reset the target triple to make sure it matches the new target machine\n    clone->setTargetTriple(TM->getTargetTriple().str());\n#ifdef LLVM38\n    clone->setDataLayout(TM->createDataLayout());\n#else\n    clone->setDataLayout(TM->getDataLayout()->getStringRepresentation());\n#endif\n#endif\n\n    // add metadata information\n    jl_gen_llvm_globaldata(clone, VMap, sysimg_data, sysimg_len);\n\n    // do the actual work\n    PM.run(*clone);\n#if !defined(USE_MCJIT) && !defined(USE_ORCJIT)\n    delete clone;\n#endif\n    imaging_mode = false;\n}\n\nextern \"C\" int32_t jl_assign_functionID(void *function)\n{\n    // give the function an index in the constant lookup table\n    assert(imaging_mode);\n    if (function == NULL)\n        return 0;\n    jl_sysimg_fvars.push_back(ConstantExpr::getBitCast(\n                shadow_output->getNamedValue(((Function*)function)->getName()),\n                T_pvoidfunc));\n    return jl_sysimg_fvars.size();\n}\n\nextern \"C\" int32_t jl_get_llvm_gv(jl_value_t *p)\n{\n    // map a jl_value_t memory location to a GlobalVariable\n    std::map<void*, jl_value_llvm>::iterator it;\n    it = jl_value_to_llvm.find(p);\n    if (it == jl_value_to_llvm.end())\n        return 0;\n    return it->second.index;\n}\n\nGlobalVariable *jl_get_global_for(const char *cname, void *addr, Module *M)\n{\n    // emit a GlobalVariable for a jl_value_t named \"cname\"\n    std::map<void*, jl_value_llvm>::iterator it;\n    // first see if there already is a GlobalVariable for this address\n    it = jl_value_to_llvm.find(addr);\n    if (it != jl_value_to_llvm.end())\n        return prepare_global((llvm::GlobalVariable*)it->second.gv, M);\n\n    std::stringstream gvname;\n    gvname << cname << globalUnique++;\n    // no existing GlobalVariable, create one and store it\n    GlobalVariable *gv = new GlobalVariable(*M, T_pjlvalue,\n                           false, GlobalVariable::ExternalLinkage,\n                           NULL, gvname.str());\n    *(void**)jl_emit_and_add_to_shadow(gv, addr) = addr;\n    return gv;\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/init.c": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n/*\n  init.c\n  system initialization and global state\n*/\n#include \"platform.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n#include <fcntl.h>\n\n#include <errno.h>\n\n#if !defined(_OS_WINDOWS_) || defined(_COMPILER_MINGW_)\n#include <getopt.h>\n#endif\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#define DEFINE_BUILTIN_GLOBALS\n#include \"builtin_proto.h\"\n#undef DEFINE_BUILTIN_GLOBALS\n#include \"threading.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef _MSC_VER\nJL_DLLEXPORT char *dirname(char *);\n#else\n#include <libgen.h>\n#endif\n\n#ifdef _OS_WINDOWS_\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n#include <io.h>\nextern int needsSymRefreshModuleList;\nextern BOOL (WINAPI *hSymRefreshModuleList)(HANDLE);\n#else\n#include <sys/resource.h>\n#include <unistd.h>\n#endif\n\n#ifdef JL_ASAN_ENABLED\nJL_DLLEXPORT const char* __asan_default_options() {\n    return \"allow_user_segv_handler=1:detect_leaks=0\";\n    // FIXME: enable LSAN after fixing leaks & defining __lsan_default_suppressions(),\n    //        or defining __lsan_default_options = exitcode=0 once publicly available\n    //        (here and in flisp/flmain.c)\n}\n#endif\n\nstatic const char system_image_path[256] = \"\\0\" JL_SYSTEM_IMAGE_PATH;\n\njl_options_t jl_options = { 0,    // quiet\n                            NULL, // julia_home\n                            NULL, // julia_bin\n                            NULL, // eval\n                            NULL, // print\n                            NULL, // postboot\n                            NULL, // load\n                            &system_image_path[1], // image_file\n                            NULL, // cpu_taget (\"native\", \"core2\", etc...)\n                            0,    // nprocs\n                            NULL, // machinefile\n                            0,    // isinteractive\n                            0,    // color\n                            JL_OPTIONS_HISTORYFILE_ON, // historyfile\n                            0,    // startupfile\n                            JL_OPTIONS_COMPILE_DEFAULT, // compile_enabled\n                            0,    // code_coverage\n                            0,    // malloc_log\n                            2,    // opt_level\n                            JL_OPTIONS_CHECK_BOUNDS_DEFAULT, // check_bounds\n                            1,    // depwarn\n                            1,    // can_inline\n                            JL_OPTIONS_FAST_MATH_DEFAULT,\n                            0,    // worker\n                            JL_OPTIONS_HANDLE_SIGNALS_ON,\n                            JL_OPTIONS_USE_PRECOMPILED_YES,\n                            JL_OPTIONS_USE_COMPILECACHE_YES,\n                            NULL, // bindto\n                            NULL, // outputbc\n                            NULL, // outputo\n                            NULL, // outputji\n                            0, // incremental\n                            0 // image_file_specified\n};\n\nint jl_boot_file_loaded = 0;\nsize_t jl_page_size;\n\nvoid jl_init_stack_limits(int ismaster)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n#ifdef _OS_WINDOWS_\n    (void)ismaster;\n#  ifdef _COMPILER_MICROSOFT_\n#    ifdef _P64\n    void **tib = (void**)__readgsqword(0x30);\n#    else\n    void **tib = (void**)__readfsdword(0x18);\n#    endif\n#  else\n    void **tib;\n#    ifdef _P64\n    __asm__(\"movq %%gs:0x30, %0\" : \"=r\" (tib) : : );\n#    else\n    __asm__(\"movl %%fs:0x18, %0\" : \"=r\" (tib) : : );\n#    endif\n#  endif\n    // https://en.wikipedia.org/wiki/Win32_Thread_Information_Block\n    ptls->stack_hi = (char*)tib[1]; // Stack Base / Bottom of stack (high address)\n    ptls->stack_lo = (char*)tib[2]; // Stack Limit / Ceiling of stack (low address)\n#else\n#  ifdef JULIA_ENABLE_THREADING\n    // Only use pthread_*_np functions to get stack address for non-master\n    // threads since it seems to return bogus values for master thread on Linux\n    // and possibly OSX.\n    if (!ismaster) {\n#    if defined(_OS_LINUX_)\n        pthread_attr_t attr;\n        pthread_getattr_np(pthread_self(), &attr);\n        void *stackaddr;\n        size_t stacksize;\n        pthread_attr_getstack(&attr, &stackaddr, &stacksize);\n        pthread_attr_destroy(&attr);\n        ptls->stack_lo = (char*)stackaddr;\n        ptls->stack_hi = (char*)stackaddr + stacksize;\n        return;\n#    elif defined(_OS_DARWIN_)\n        extern void *pthread_get_stackaddr_np(pthread_t thread);\n        extern size_t pthread_get_stacksize_np(pthread_t thread);\n        pthread_t thread = pthread_self();\n        void *stackaddr = pthread_get_stackaddr_np(thread);\n        size_t stacksize = pthread_get_stacksize_np(thread);\n        ptls->stack_lo = (char*)stackaddr;\n        ptls->stack_hi = (char*)stackaddr + stacksize;\n        return;\n#    elif defined(_OS_FREEBSD_)\n        pthread_attr_t attr;\n        pthread_attr_init(&attr);\n        pthread_attr_get_np(pthread_self(), &attr);\n        void *stackaddr;\n        size_t stacksize;\n        pthread_attr_getstack(&attr, &stackaddr, &stacksize);\n        pthread_attr_destroy(&attr);\n        ptls->stack_lo = (char*)stackaddr;\n        ptls->stack_hi = (char*)stackaddr + stacksize;\n        return;\n#    else\n#      warning \"Getting stack size for thread is not supported.\"\n#    endif\n    }\n#  else\n    (void)ismaster;\n#  endif\n    struct rlimit rl;\n    getrlimit(RLIMIT_STACK, &rl);\n    size_t stack_size = rl.rlim_cur;\n    ptls->stack_hi = (char*)&stack_size;\n    ptls->stack_lo = ptls->stack_hi - stack_size;\n#endif\n}\n\nstatic void jl_find_stack_bottom(void)\n{\n#if !defined(_OS_WINDOWS_)\n#if defined(JL_ASAN_ENABLED) || defined(JL_MSAN_ENABLED)\n    struct rlimit rl;\n\n    // When using the sanitizers, increase stack size because they bloat\n    // stack usage\n    const rlim_t kStackSize = 32 * 1024 * 1024;   // 32MB stack\n    int result;\n\n    result = getrlimit(RLIMIT_STACK, &rl);\n    if (result == 0) {\n        if (rl.rlim_cur < kStackSize) {\n            rl.rlim_cur = kStackSize;\n            result = setrlimit(RLIMIT_STACK, &rl);\n            if (result != 0) {\n                fprintf(stderr, \"setrlimit returned result = %d\\n\", result);\n            }\n        }\n    }\n#endif\n#endif\n    jl_init_stack_limits(1);\n}\n\nstruct uv_shutdown_queue_item { uv_handle_t *h; struct uv_shutdown_queue_item *next; };\nstruct uv_shutdown_queue { struct uv_shutdown_queue_item *first; struct uv_shutdown_queue_item *last; };\n\nstatic void jl_uv_exitcleanup_add(uv_handle_t *handle, struct uv_shutdown_queue *queue)\n{\n    struct uv_shutdown_queue_item *item = (struct uv_shutdown_queue_item*)malloc(sizeof(struct uv_shutdown_queue_item));\n    item->h = handle;\n    item->next = NULL;\n    if (queue->last) queue->last->next = item;\n    if (!queue->first) queue->first = item;\n    queue->last = item;\n}\n\nstatic void jl_uv_exitcleanup_walk(uv_handle_t *handle, void *arg)\n{\n    if (handle != (uv_handle_t*)JL_STDOUT && handle != (uv_handle_t*)JL_STDERR)\n        jl_uv_exitcleanup_add(handle, (struct uv_shutdown_queue*)arg);\n}\n\nvoid jl_write_coverage_data(void);\nvoid jl_write_malloc_log(void);\nstatic void julia_save(void);\n\nstatic struct uv_shutdown_queue_item *next_shutdown_queue_item(struct uv_shutdown_queue_item *item)\n{\n    struct uv_shutdown_queue_item *rv = item->next;\n    free(item);\n    return rv;\n}\n\nvoid jl_init_timing(void);\nvoid jl_destroy_timing(void);\nvoid jl_uv_call_close_callback(jl_value_t *val);\n\nJL_DLLEXPORT void jl_atexit_hook(int exitcode)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    if (exitcode == 0) julia_save();\n    jl_print_gc_stats(JL_STDERR);\n    if (jl_options.code_coverage)\n        jl_write_coverage_data();\n    if (jl_options.malloc_log)\n        jl_write_malloc_log();\n    if (jl_base_module) {\n        jl_value_t *f = jl_get_global(jl_base_module, jl_symbol(\"_atexit\"));\n        if (f != NULL) {\n            JL_TRY {\n                jl_apply(&f, 1);\n            }\n            JL_CATCH {\n                jl_printf(JL_STDERR, \"\\natexit hook threw an error: \");\n                jl_static_show(JL_STDERR, ptls->exception_in_transit);\n            }\n        }\n    }\n\n    jl_gc_run_all_finalizers(ptls);\n\n    uv_loop_t *loop = jl_global_event_loop();\n\n    if (loop == NULL) {\n        return;\n    }\n\n    struct uv_shutdown_queue queue = {NULL, NULL};\n    uv_walk(loop, jl_uv_exitcleanup_walk, &queue);\n    // close stdout and stderr last, since we like being\n    // able to show stuff (incl. printf's)\n    if (JL_STDOUT != (void*) STDOUT_FILENO &&\n        ((uv_handle_t*)JL_STDOUT)->type < UV_HANDLE_TYPE_MAX)\n        jl_uv_exitcleanup_add((uv_handle_t*)JL_STDOUT, &queue);\n    if (JL_STDERR != (void*) STDERR_FILENO &&\n        ((uv_handle_t*)JL_STDERR)->type < UV_HANDLE_TYPE_MAX)\n        jl_uv_exitcleanup_add((uv_handle_t*)JL_STDERR, &queue);\n    //uv_unref((uv_handle_t*)JL_STDOUT);\n    //uv_unref((uv_handle_t*)JL_STDERR);\n    struct uv_shutdown_queue_item *item = queue.first;\n    while (item) {\n        JL_TRY {\n            while (item) {\n                uv_handle_t *handle = item->h;\n                if (handle->type != UV_FILE && uv_is_closing(handle)) {\n                    item = next_shutdown_queue_item(item);\n                    continue;\n                }\n                switch(handle->type) {\n                case UV_PROCESS:\n                    // cause Julia to forget about the Process object\n                    if (handle->data)\n                        jl_uv_call_close_callback((jl_value_t*)handle->data);\n                    // and make libuv think it is already dead\n                    ((uv_process_t*)handle)->pid = 0;\n                    // fall-through\n                case UV_TTY:\n                case UV_UDP:\n                case UV_TCP:\n                case UV_NAMED_PIPE:\n                case UV_POLL:\n                case UV_TIMER:\n                case UV_ASYNC:\n                case UV_FS_EVENT:\n                case UV_FS_POLL:\n                case UV_IDLE:\n                case UV_PREPARE:\n                case UV_CHECK:\n                case UV_SIGNAL:\n                case UV_FILE:\n                    // These will be shutdown as appropriate by jl_close_uv\n                    jl_close_uv(handle);\n                    break;\n                case UV_HANDLE:\n                case UV_STREAM:\n                case UV_UNKNOWN_HANDLE:\n                case UV_HANDLE_TYPE_MAX:\n                case UV_RAW_FD:\n                case UV_RAW_HANDLE:\n                default:\n                    assert(0);\n                }\n                item = next_shutdown_queue_item(item);\n            }\n        }\n        JL_CATCH {\n            //error handling -- continue cleanup, as much as possible\n            uv_unref(item->h);\n            jl_printf(JL_STDERR, \"error during exit cleanup: close: \");\n            jl_static_show(JL_STDERR, ptls->exception_in_transit);\n            item = next_shutdown_queue_item(item);\n        }\n    }\n    // force libuv to spin until everything has finished closing\n    loop->stop_flag = 0;\n    while (uv_run(loop,UV_RUN_DEFAULT)) {}\n\n    jl_destroy_timing();\n#ifdef ENABLE_TIMINGS\n    jl_print_timings();\n#endif\n}\n\nvoid jl_get_builtin_hooks(void);\nvoid jl_get_builtins(void);\n\nJL_DLLEXPORT void *jl_dl_handle;\nvoid *jl_RTLD_DEFAULT_handle;\n#ifdef _OS_WINDOWS_\nJL_DLLEXPORT void *jl_exe_handle;\nvoid *jl_ntdll_handle;\nvoid *jl_kernel32_handle;\nvoid *jl_crtdll_handle;\nvoid *jl_winsock_handle;\n#endif\n\nuv_loop_t *jl_io_loop;\n\nstatic void *init_stdio_handle(uv_file fd,int readable)\n{\n    void *handle;\n    uv_handle_type type = uv_guess_handle(fd);\n    jl_uv_file_t *file;\n#ifndef _OS_WINDOWS_\n    // Duplicate the file descriptor so we can later dup it over if we want to redirect\n    // STDIO without having to worry about closing the associated libuv object.\n    // On windows however, libuv objects remember streams by their HANDLE, so this is\n    // unnecessary.\n    fd = dup(fd);\n#endif\n    //jl_printf(JL_STDOUT, \"%d: %d -- %d\\n\", fd, type, 0);\n    switch(type) {\n        case UV_TTY:\n            handle = malloc(sizeof(uv_tty_t));\n            if (uv_tty_init(jl_io_loop,(uv_tty_t*)handle,fd,readable)) {\n                jl_errorf(\"error initializing stdio in uv_tty_init (%d, %d)\", fd, type);\n            }\n            ((uv_tty_t*)handle)->data=0;\n            uv_tty_set_mode((uv_tty_t*)handle, UV_TTY_MODE_NORMAL); //cooked stdio\n            break;\n        case UV_UNKNOWN_HANDLE:\n            // dup the descriptor with a new one pointing at the bit bucket ...\n#if defined(_OS_WINDOWS_)\n            _dup2(_open(\"NUL\", O_RDWR | O_BINARY, _S_IREAD | _S_IWRITE), fd);\n#else\n            dup2(open(\"/dev/null\", O_RDWR, S_IRUSR | S_IWUSR /* 0600 */ | S_IRGRP | S_IROTH /* 0644 */), fd);\n#endif\n            // ...and continue on as in the UV_FILE case\n        case UV_FILE:\n            file = (jl_uv_file_t*)malloc(sizeof(jl_uv_file_t));\n            file->loop = jl_io_loop;\n            file->type = UV_FILE;\n            file->file = fd;\n            file->data = 0;\n            handle = file;\n            break;\n        case UV_NAMED_PIPE:\n            handle = malloc(sizeof(uv_pipe_t));\n            if (uv_pipe_init(jl_io_loop, (uv_pipe_t*)handle, (readable?UV_PIPE_READABLE:UV_PIPE_WRITABLE))) {\n                jl_errorf(\"error initializing stdio in uv_pipe_init (%d, %d)\", fd, type);\n            }\n            if (uv_pipe_open((uv_pipe_t*)handle,fd)) {\n                jl_errorf(\"error initializing stdio in uv_pipe_open (%d, %d)\", fd, type);\n            }\n            ((uv_pipe_t*)handle)->data=0;\n            break;\n        case UV_TCP:\n            handle = malloc(sizeof(uv_tcp_t));\n            if (uv_tcp_init(jl_io_loop, (uv_tcp_t*)handle)) {\n                jl_errorf(\"error initializing stdio in uv_tcp_init (%d, %d)\", fd, type);\n            }\n            if (uv_tcp_open((uv_tcp_t*)handle,fd)) {\n                jl_errorf(\"error initializing stdio in uv_tcp_open (%d, %d)\", fd, type);\n            }\n            ((uv_tcp_t*)handle)->data=0;\n            break;\n        case UV_UDP:\n        default:\n            jl_errorf(\"this type of handle for stdio is not yet supported (%d, %d)\", fd, type);\n            break;\n    }\n    return handle;\n}\n\nvoid init_stdio(void)\n{   //order must be 2,1,0\n    JL_STDERR = (uv_stream_t*)init_stdio_handle(STDERR_FILENO,0);\n    JL_STDOUT = (uv_stream_t*)init_stdio_handle(STDOUT_FILENO,0);\n    JL_STDIN  = (uv_stream_t*)init_stdio_handle(STDIN_FILENO,1);\n\n    jl_flush_cstdio();\n}\n\n#ifdef JL_USE_INTEL_JITEVENTS\nchar jl_using_intel_jitevents; // Non-zero if running under Intel VTune Amplifier\n#endif\n\n#ifdef JL_USE_OPROFILE_JITEVENTS\nchar jl_using_oprofile_jitevents = 0; // Non-zero if running under OProfile\n#endif\n\nint isabspath(const char *in)\n{\n#ifdef _OS_WINDOWS_\n    char c0 = in[0];\n    if (c0 == '/' || c0 == '\\\\') {\n        return 1; // absolute path relative to %CD% (current drive), or UNC\n    }\n    else {\n        int s = strlen(in);\n        if (s > 2) {\n            char c1 = in[1];\n            char c2 = in[2];\n            if (c1 == ':' && (c2 == '/' || c2 == '\\\\')) return 1; // absolute path\n        }\n    }\n#else\n    if (in[0] == '/') return 1; // absolute path\n#endif\n    return 0; // relative path\n}\n\nstatic char *abspath(const char *in)\n{ // compute an absolute path location, so that chdir doesn't change the file reference\n#ifndef _OS_WINDOWS_\n    char *out = realpath(in, NULL);\n    if (!out) {\n        if (in[0] == PATHSEPSTRING[0]) {\n            out = strdup(in);\n        }\n        else {\n            size_t path_size = PATH_MAX;\n            size_t len = strlen(in);\n            char *path = (char*)malloc(PATH_MAX);\n            if (uv_cwd(path, &path_size)) {\n                jl_error(\"fatal error: unexpected error while retrieving current working directory\");\n            }\n            if (path_size + len + 2 >= PATH_MAX) {\n                jl_error(\"fatal error: current working directory path too long\");\n            }\n            path[path_size] = PATHSEPSTRING[0];\n            memcpy(path + path_size + 1, in, len+1);\n            out = strdup(path);\n            free(path);\n        }\n    }\n#else\n    DWORD n = GetFullPathName(in, 0, NULL, NULL);\n    if (n <= 0) {\n        jl_error(\"fatal error: jl_options.image_file path too long or GetFullPathName failed\");\n    }\n    char *out = (char*)malloc(n);\n    DWORD m = GetFullPathName(in, n, out, NULL);\n    if (n != m + 1) {\n        jl_error(\"fatal error: jl_options.image_file path too long or GetFullPathName failed\");\n    }\n#endif\n    return out;\n}\n\nstatic void jl_resolve_sysimg_location(JL_IMAGE_SEARCH rel)\n{   // this function resolves the paths in jl_options to absolute file locations as needed\n    // and it replaces the pointers to `julia_home`, `julia_bin`, `image_file`, and output file paths\n    // it may fail, print an error, and exit(1) if any of these paths are longer than PATH_MAX\n    //\n    // note: if you care about lost memory, you should call the appropriate `free()` function\n    // on the original pointer for each `char*` you've inserted into `jl_options`, after\n    // calling `julia_init()`\n    char *free_path = (char*)malloc(PATH_MAX);\n    size_t path_size = PATH_MAX;\n    if (uv_exepath(free_path, &path_size)) {\n        jl_error(\"fatal error: unexpected error while retrieving exepath\");\n    }\n    if (path_size >= PATH_MAX) {\n        jl_error(\"fatal error: jl_options.julia_bin path too long\");\n    }\n    jl_options.julia_bin = (char*)malloc(path_size+1);\n    memcpy((char*)jl_options.julia_bin, free_path, path_size);\n    ((char*)jl_options.julia_bin)[path_size] = '\\0';\n    if (!jl_options.julia_home) {\n        jl_options.julia_home = getenv(\"JULIA_HOME\");\n        if (!jl_options.julia_home) {\n            jl_options.julia_home = dirname(free_path);\n        }\n    }\n    if (jl_options.julia_home)\n        jl_options.julia_home = abspath(jl_options.julia_home);\n    free(free_path);\n    free_path = NULL;\n    if (jl_options.image_file) {\n        if (rel == JL_IMAGE_JULIA_HOME && !isabspath(jl_options.image_file)) {\n            // build time path, relative to JULIA_HOME\n            free_path = (char*)malloc(PATH_MAX);\n            int n = snprintf(free_path, PATH_MAX, \"%s\" PATHSEPSTRING \"%s\",\n                             jl_options.julia_home, jl_options.image_file);\n            if (n >= PATH_MAX || n < 0) {\n                jl_error(\"fatal error: jl_options.image_file path too long\");\n            }\n            jl_options.image_file = free_path;\n        }\n        if (jl_options.image_file)\n            jl_options.image_file = abspath(jl_options.image_file);\n        if (free_path) {\n            free(free_path);\n            free_path = NULL;\n        }\n    }\n    if (jl_options.outputo)\n        jl_options.outputo = abspath(jl_options.outputo);\n    if (jl_options.outputji)\n        jl_options.outputji = abspath(jl_options.outputji);\n    if (jl_options.outputbc)\n        jl_options.outputbc = abspath(jl_options.outputbc);\n    if (jl_options.machinefile)\n        jl_options.machinefile = abspath(jl_options.machinefile);\n    if (jl_options.load)\n        jl_options.load = abspath(jl_options.load);\n}\n\nstatic void jl_set_io_wait(int v)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    ptls->io_wait = v;\n}\n\nvoid _julia_init(JL_IMAGE_SEARCH rel)\n{\n    jl_init_timing();\n#ifdef JULIA_ENABLE_THREADING\n    // Make sure we finalize the tls callback before starting any threads.\n    jl_get_ptls_states_getter();\n#endif\n    jl_ptls_t ptls = jl_get_ptls_states();\n    jl_safepoint_init();\n    libsupport_init();\n    ios_set_io_wait_func = jl_set_io_wait;\n    jl_io_loop = uv_default_loop(); // this loop will internal events (spawning process etc.),\n                                    // best to call this first, since it also initializes libuv\n    jl_init_signal_async();\n    restore_signals();\n    jl_resolve_sysimg_location(rel);\n    // loads sysimg if available, and conditionally sets jl_options.cpu_target\n    jl_preload_sysimg_so(jl_options.image_file);\n    if (jl_options.cpu_target == NULL)\n        jl_options.cpu_target = \"native\";\n\n    jl_page_size = jl_getpagesize();\n    uint64_t total_mem = uv_get_total_memory();\n    if (total_mem >= (size_t)-1) {\n        total_mem = (size_t)-1;\n    }\n    jl_arr_xtralloc_limit = total_mem / 100;  // Extra allocation limited to 1% of total RAM\n    jl_find_stack_bottom();\n    jl_dl_handle = jl_load_dynamic_library(NULL, JL_RTLD_DEFAULT);\n#ifdef RTLD_DEFAULT\n    jl_RTLD_DEFAULT_handle = RTLD_DEFAULT;\n#else\n    jl_RTLD_DEFAULT_handle = jl_dl_handle;\n#endif\n#ifdef _OS_WINDOWS_\n    jl_ntdll_handle = jl_dlopen(\"ntdll.dll\", 0); // bypass julia's pathchecking for system dlls\n    jl_kernel32_handle = jl_dlopen(\"kernel32.dll\", 0);\n#if defined(_MSC_VER) && _MSC_VER == 1800\n    jl_crtdll_handle = jl_dlopen(\"msvcr120.dll\", 0);\n#else\n    jl_crtdll_handle = jl_dlopen(\"msvcrt.dll\", 0);\n#endif\n    jl_winsock_handle = jl_dlopen(\"ws2_32.dll\", 0);\n    jl_exe_handle = GetModuleHandleA(NULL);\n    SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_LINES);\n    if (!SymInitialize(GetCurrentProcess(), NULL, 1)) {\n        jl_printf(JL_STDERR, \"WARNING: failed to initialize stack walk info\\n\");\n    }\n    needsSymRefreshModuleList = 0;\n    HMODULE jl_dbghelp = (HMODULE) jl_dlopen(\"dbghelp.dll\", 0);\n    if (jl_dbghelp)\n        hSymRefreshModuleList = (BOOL (WINAPI*)(HANDLE)) jl_dlsym(jl_dbghelp, \"SymRefreshModuleList\");\n#endif\n\n#if defined(JL_USE_INTEL_JITEVENTS)\n    const char *jit_profiling = getenv(\"ENABLE_JITPROFILING\");\n    if (jit_profiling && atoi(jit_profiling)) {\n        jl_using_intel_jitevents = 1;\n    }\n#endif\n\n#if defined(JL_USE_OPROFILE_JITEVENTS)\n    const char *jit_profiling = getenv(\"ENABLE_JITPROFILING\");\n    if (jit_profiling && atoi(jit_profiling)) {\n        jl_using_oprofile_jitevents = 1;\n    }\n#endif\n\n\n#if defined(__linux__)\n    int ncores = jl_cpu_cores();\n    if (ncores > 1) {\n        cpu_set_t cpumask;\n        CPU_ZERO(&cpumask);\n        for(int i=0; i < ncores; i++) {\n            CPU_SET(i, &cpumask);\n        }\n        sched_setaffinity(0, sizeof(cpu_set_t), &cpumask);\n    }\n#endif\n\n    jl_init_threading();\n\n    jl_gc_init();\n    jl_gc_enable(0);\n    jl_init_frontend();\n    jl_init_types();\n    jl_init_tasks();\n    jl_init_root_task(ptls->stack_lo, ptls->stack_hi-ptls->stack_lo);\n\n#ifdef ENABLE_TIMINGS\n    jl_root_task->timing_stack = jl_root_timing;\n#endif\n\n    init_stdio();\n    // libuv stdio cleanup depends on jl_init_tasks() because JL_TRY is used in jl_atexit_hook()\n\n    if ((jl_options.outputo || jl_options.outputbc) &&\n        (jl_options.code_coverage || jl_options.malloc_log)) {\n        jl_error(\"cannot generate code-coverage or track allocation information while generating a .o or .bc output file\");\n    }\n\n    jl_init_codegen();\n\n    jl_start_threads();\n\n    jl_an_empty_vec_any = (jl_value_t*)jl_alloc_vec_any(0);\n    jl_init_serializer();\n\n    if (!jl_options.image_file) {\n        jl_core_module = jl_new_module(jl_symbol(\"Core\"));\n        jl_type_type->name->mt->module = jl_core_module;\n        jl_top_module = jl_core_module;\n        ptls->current_module = jl_core_module;\n        jl_init_intrinsic_functions();\n        jl_init_primitives();\n        jl_get_builtins();\n\n        jl_new_main_module();\n        jl_internal_main_module = jl_main_module;\n\n        ptls->current_module = jl_core_module;\n        for (int t = 0;t < jl_n_threads;t++) {\n            jl_all_tls_states[t]->root_task->current_module = ptls->current_module;\n        }\n\n        jl_load(\"boot.jl\");\n        jl_get_builtin_hooks();\n        jl_boot_file_loaded = 1;\n        jl_init_box_caches();\n    }\n\n    if (jl_options.image_file) {\n        JL_TRY {\n            jl_restore_system_image(jl_options.image_file);\n        }\n        JL_CATCH {\n            jl_printf(JL_STDERR, \"error during init:\\n\");\n            jl_static_show(JL_STDERR, ptls->exception_in_transit);\n            jl_printf(JL_STDERR, \"\\n\");\n            jl_exit(1);\n        }\n    }\n\n    // set module field of primitive types\n    int i;\n    void **table = jl_core_module->bindings.table;\n    for(i=1; i < jl_core_module->bindings.size; i+=2) {\n        if (table[i] != HT_NOTFOUND) {\n            jl_binding_t *b = (jl_binding_t*)table[i];\n            if (b->value && jl_is_datatype(b->value)) {\n                jl_datatype_t *tt = (jl_datatype_t*)b->value;\n                tt->name->module = jl_core_module;\n                if (tt->name->mt)\n                    tt->name->mt->module = jl_core_module;\n            }\n        }\n    }\n\n    // the Main module is the one which is always open, and set as the\n    // current module for bare (non-module-wrapped) toplevel expressions.\n    // it does \"using Base\" if Base is available.\n    if (jl_base_module != NULL) {\n        jl_add_standard_imports(jl_main_module);\n    }\n    ptls->current_module = jl_main_module;\n    for (int t = 0;t < jl_n_threads;t++) {\n        jl_all_tls_states[t]->root_task->current_module = ptls->current_module;\n    }\n\n    // This needs to be after jl_start_threads\n    if (jl_options.handle_signals == JL_OPTIONS_HANDLE_SIGNALS_ON)\n        jl_install_default_signal_handlers();\n\n    jl_gc_enable(1);\n\n    if (jl_options.image_file && (!jl_generating_output() || jl_options.incremental) && jl_module_init_order) {\n        jl_array_t *init_order = jl_module_init_order;\n        JL_GC_PUSH1(&init_order);\n        jl_module_init_order = NULL;\n        int i, l = jl_array_len(init_order);\n        for (i = 0; i < l; i++) {\n            jl_value_t *mod = jl_array_ptr_ref(init_order, i);\n            jl_module_run_initializer((jl_module_t*)mod);\n        }\n        JL_GC_POP();\n    }\n\n    if (jl_options.handle_signals == JL_OPTIONS_HANDLE_SIGNALS_ON)\n        jl_install_sigint_handler();\n}\n\nextern int asprintf(char **str, const char *fmt, ...);\n\nJL_DLLEXPORT int jl_generating_output(void)\n{\n    return jl_options.outputo || jl_options.outputbc || jl_options.outputji;\n}\n\nvoid jl_precompile(int all);\n\nstatic void julia_save(void)\n{\n    if (!jl_generating_output())\n        return;\n\n    if (!jl_options.incremental)\n        jl_precompile(jl_options.compile_enabled == JL_OPTIONS_COMPILE_ALL);\n\n    if (!jl_module_init_order) {\n        jl_printf(JL_STDERR, \"WARNING: --output requested, but no modules defined during run\\n\");\n        return;\n    }\n\n    jl_array_t *worklist = jl_module_init_order;\n    JL_GC_PUSH1(&worklist);\n    jl_module_init_order = jl_alloc_vec_any(0);\n    int i, l = jl_array_len(worklist);\n    for (i = 0; i < l; i++) {\n        jl_value_t *m = jl_arrayref(worklist, i);\n        if (jl_get_global((jl_module_t*)m, jl_symbol(\"__init__\"))) {\n            jl_array_ptr_1d_push(jl_module_init_order, m);\n        }\n    }\n\n    if (jl_options.incremental) {\n        if (jl_options.outputji)\n            if (jl_save_incremental(jl_options.outputji, worklist))\n                jl_exit(1);\n        if (jl_options.outputbc)\n            jl_printf(JL_STDERR, \"WARNING: incremental output to a .bc file is not implemented\\n\");\n        if (jl_options.outputo)\n            jl_printf(JL_STDERR, \"WARNING: incremental output to a .o file is not implemented\\n\");\n    }\n    else {\n        ios_t *s = NULL;\n        if (jl_options.outputo || jl_options.outputbc)\n            s = jl_create_system_image();\n\n        if (jl_options.outputji) {\n            if (s == NULL) {\n                jl_save_system_image(jl_options.outputji);\n            }\n            else {\n                ios_t f;\n                if (ios_file(&f, jl_options.outputji, 1, 1, 1, 1) == NULL)\n                    jl_errorf(\"cannot open system image file \\\"%s\\\" for writing\", jl_options.outputji);\n                ios_write(&f, (const char*)s->buf, (size_t)s->size);\n                ios_close(&f);\n            }\n        }\n\n        if (jl_options.outputo || jl_options.outputbc)\n            jl_dump_native(jl_options.outputbc,\n                           jl_options.outputo,\n                           (const char*)s->buf, (size_t)s->size);\n    }\n    JL_GC_POP();\n}\n\nstatic jl_value_t *core(const char *name)\n{\n    return jl_get_global(jl_core_module, jl_symbol(name));\n}\n\nstatic jl_value_t *basemod(const char *name)\n{\n    return jl_get_global(jl_base_module, jl_symbol(name));\n}\n\n// fetch references to things defined in boot.jl\nvoid jl_get_builtin_hooks(void)\n{\n    int t;\n    for (t = 0; t < jl_n_threads; t++) {\n        jl_ptls_t ptls2 = jl_all_tls_states[t];\n        ptls2->root_task->tls = jl_nothing;\n        ptls2->root_task->consumers = jl_nothing;\n        ptls2->root_task->donenotify = jl_nothing;\n        ptls2->root_task->exception = jl_nothing;\n        ptls2->root_task->result = jl_nothing;\n    }\n\n    jl_char_type    = (jl_datatype_t*)core(\"Char\");\n    jl_int8_type    = (jl_datatype_t*)core(\"Int8\");\n    jl_int16_type   = (jl_datatype_t*)core(\"Int16\");\n    jl_uint16_type  = (jl_datatype_t*)core(\"UInt16\");\n    jl_uint32_type  = (jl_datatype_t*)core(\"UInt32\");\n    jl_uint64_type  = (jl_datatype_t*)core(\"UInt64\");\n\n    jl_float16_type = (jl_datatype_t*)core(\"Float16\");\n    jl_float32_type = (jl_datatype_t*)core(\"Float32\");\n    jl_float64_type = (jl_datatype_t*)core(\"Float64\");\n    jl_floatingpoint_type = (jl_datatype_t*)core(\"AbstractFloat\");\n    jl_number_type = (jl_datatype_t*)core(\"Number\");\n    jl_signed_type = (jl_datatype_t*)core(\"Signed\");\n\n    jl_errorexception_type = (jl_datatype_t*)core(\"ErrorException\");\n    jl_stackovf_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"StackOverflowError\"));\n    jl_diverror_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"DivideError\"));\n    jl_domain_exception    = jl_new_struct_uninit((jl_datatype_t*)core(\"DomainError\"));\n    jl_overflow_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"OverflowError\"));\n    jl_inexact_exception   = jl_new_struct_uninit((jl_datatype_t*)core(\"InexactError\"));\n    jl_undefref_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"UndefRefError\"));\n    jl_undefvarerror_type  = (jl_datatype_t*)core(\"UndefVarError\");\n    jl_interrupt_exception = jl_new_struct_uninit((jl_datatype_t*)core(\"InterruptException\"));\n    jl_boundserror_type    = (jl_datatype_t*)core(\"BoundsError\");\n    jl_memory_exception    = jl_new_struct_uninit((jl_datatype_t*)core(\"OutOfMemoryError\"));\n    jl_readonlymemory_exception = jl_new_struct_uninit((jl_datatype_t*)core(\"ReadOnlyMemoryError\"));\n    jl_typeerror_type = (jl_datatype_t*)core(\"TypeError\");\n\n#ifdef SEGV_EXCEPTION\n    jl_segv_exception      = jl_new_struct_uninit((jl_datatype_t*)core(\"SegmentationFault\"));\n#endif\n\n    jl_string_type = (jl_datatype_t*)core(\"String\");\n    jl_weakref_type = (jl_datatype_t*)core(\"WeakRef\");\n    jl_vecelement_typename = ((jl_datatype_t*)core(\"VecElement\"))->name;\n}\n\nJL_DLLEXPORT void jl_get_system_hooks(void)\n{\n    if (jl_argumenterror_type) return; // only do this once\n\n    jl_argumenterror_type = (jl_datatype_t*)basemod(\"ArgumentError\");\n    jl_methoderror_type = (jl_datatype_t*)basemod(\"MethodError\");\n    jl_loaderror_type = (jl_datatype_t*)basemod(\"LoadError\");\n    jl_initerror_type = (jl_datatype_t*)basemod(\"InitError\");\n    jl_complex_type = (jl_datatype_t*)basemod(\"Complex\");\n}\n\nvoid jl_get_builtins(void)\n{\n    jl_builtin_throw = core(\"throw\");           jl_builtin_is = core(\"is\");\n    jl_builtin_typeof = core(\"typeof\");         jl_builtin_sizeof = core(\"sizeof\");\n    jl_builtin_issubtype = core(\"issubtype\");   jl_builtin_isa = core(\"isa\");\n    jl_builtin_typeassert = core(\"typeassert\"); jl_builtin__apply = core(\"_apply\");\n    jl_builtin_isdefined = core(\"isdefined\");   jl_builtin_nfields = core(\"nfields\");\n    jl_builtin_tuple = core(\"tuple\");           jl_builtin_svec = core(\"svec\");\n    jl_builtin_getfield = core(\"getfield\");     jl_builtin_setfield = core(\"setfield!\");\n    jl_builtin_fieldtype = core(\"fieldtype\");   jl_builtin_arrayref = core(\"arrayref\");\n    jl_builtin_arrayset = core(\"arrayset\");     jl_builtin_arraysize = core(\"arraysize\");\n    jl_builtin_apply_type = core(\"apply_type\"); jl_builtin_applicable = core(\"applicable\");\n    jl_builtin_invoke = core(\"invoke\");         jl_builtin__expr = core(\"_expr\");\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/dump.c": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n/*\n  saving and restoring system images\n*/\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"builtin_proto.h\"\n\n#ifndef _OS_WINDOWS_\n#include <dlfcn.h>\n#endif\n\n#ifndef _COMPILER_MICROSOFT_\n#include \"valgrind.h\"\n#else\n#define RUNNING_ON_VALGRIND 0\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// TODO: put WeakRefs on the weak_refs list during deserialization\n// TODO: handle finalizers\n\n// hash of definitions for predefined tagged object\nstatic htable_t ser_tag;\n// array of definitions for the predefined tagged object types\n// (reverse of ser_tag)\nstatic jl_value_t *deser_tag[256];\n// hash of some common symbols, encoded as CommonSym_tag plus 1 byte\nstatic htable_t common_symbol_tag;\nstatic jl_value_t *deser_symbols[256];\n\n// table of all objects that have been deserialized, indexed by pos\n// (the order in the serializer stream) in MODE_MODULE, the low\n// bit is reserved for flagging certain entries and pos is\n// left shift by 1\n// (not used in MODE_AST)\nstatic htable_t backref_table;\nint backref_table_numel;\nstatic arraylist_t backref_list;\n\n// list of (jl_value_t **loc, size_t pos) entries\n// for anything that was flagged by the deserializer for later\n// type-rewriting of some sort\n// (not used in MODE_AST)\nstatic arraylist_t flagref_list;\n\n// list of (size_t pos, (void *f)(jl_value_t*)) entries\n// for the serializer to mark values in need of rework by function f\n// during deserialization later\n// (not used in MODE_AST)\nstatic arraylist_t reinit_list;\n\n// list of stuff that is being serialized\n// (only used by the incremental serializer in MODE_MODULE)\nstatic jl_array_t *serializer_worklist;\n\n// list of modules being deserialized with __init__ methods\n// (not used in MODE_AST)\njl_array_t *jl_module_init_order;\n\n// hash of definitions for predefined function pointers\nstatic htable_t fptr_to_id;\n// array of definitions for the predefined function pointers\n// (reverse of fptr_to_id)\nstatic const jl_fptr_t id_to_fptrs[] = {\n  NULL, NULL,\n  jl_f_throw, jl_f_is, jl_f_typeof, jl_f_issubtype, jl_f_isa,\n  jl_f_typeassert, jl_f__apply, jl_f_isdefined, jl_f_tuple, jl_f_svec,\n  jl_f_getfield, jl_f_setfield, jl_f_fieldtype, jl_f_nfields,\n  jl_f_arrayref, jl_f_arrayset, jl_f_arraysize, jl_f_apply_type,\n  jl_f_applicable, jl_f_invoke, jl_unprotect_stack, jl_f_sizeof, jl_f__expr,\n  jl_f_intrinsic_call,\n  NULL };\n\nstatic const intptr_t LongSymbol_tag   = 23;\nstatic const intptr_t LongSvec_tag     = 24;\nstatic const intptr_t LongExpr_tag     = 25;\nstatic const intptr_t LiteralVal_tag   = 26;\nstatic const intptr_t SmallInt64_tag   = 27;\nstatic const intptr_t SmallDataType_tag= 28;\nstatic const intptr_t Int32_tag        = 29;\nstatic const intptr_t Array1d_tag      = 30;\nstatic const intptr_t Singleton_tag    = 31;\nstatic const intptr_t CommonSym_tag    = 32;\nstatic const intptr_t NearbyGlobal_tag = 33;  // a GlobalRef pointing to tree_enclosing_module\nstatic const intptr_t Null_tag         = 253;\nstatic const intptr_t ShortBackRef_tag = 254;\nstatic const intptr_t BackRef_tag      = 255;\n\nstatic intptr_t VALUE_TAGS;\n\ntypedef enum _DUMP_MODES {\n    // not in the serializer at all, or\n    // something is seriously wrong\n    MODE_INVALID = 0,\n\n    // jl_uncompress_ast\n    // compressing / decompressing an AST Expr in a LambdaInfo\n    MODE_AST,\n\n    // jl_restore_system_image\n    // restoring an entire system image from disk\n    MODE_SYSTEM_IMAGE,\n\n    // jl_restore_new_module\n    // restoring a single module from disk for integration\n    // into the currently running system image / environment\n    MODE_MODULE\n} DUMP_MODES;\n\ntypedef struct {\n    ios_t *s;\n    DUMP_MODES mode;\n    // pointers to non-AST-ish objects in a compressed tree\n    // (only used in MODE_AST)\n    jl_array_t *tree_literal_values;\n    jl_module_t *tree_enclosing_module;\n    jl_ptls_t ptls;\n} jl_serializer_state;\n\nstatic jl_value_t *jl_idtable_type = NULL;\nstatic arraylist_t builtin_types;\n\n#define write_uint8(s, n) ios_putc((n), (s))\n#define read_uint8(s) ((uint8_t)ios_getc(s))\n#define write_int8(s, n) write_uint8(s, n)\n#define read_int8(s) read_uint8(s)\n\n/* read and write in network (bigendian) order: */\n\nstatic void write_int32(ios_t *s, int32_t i)\n{\n    write_uint8(s, (i>>24) & 0xff);\n    write_uint8(s, (i>>16) & 0xff);\n    write_uint8(s, (i>> 8) & 0xff);\n    write_uint8(s, i       & 0xff);\n}\n\nstatic int32_t read_int32(ios_t *s)\n{\n    int b3 = read_uint8(s);\n    int b2 = read_uint8(s);\n    int b1 = read_uint8(s);\n    int b0 = read_uint8(s);\n    return b0 | (b1<<8) | (b2<<16) | (b3<<24);\n}\n\nstatic void write_uint64(ios_t *s, uint64_t i)\n{\n    write_int32(s, (i>>32) & 0xffffffff);\n    write_int32(s, i       & 0xffffffff);\n}\n\nstatic uint64_t read_uint64(ios_t *s)\n{\n    uint64_t b1 = (uint32_t)read_int32(s);\n    uint64_t b0 = (uint32_t)read_int32(s);\n    return b0 | (b1<<32);\n}\n\nstatic void write_uint16(ios_t *s, uint16_t i)\n{\n    write_uint8(s, (i>> 8) & 0xff);\n    write_uint8(s, i       & 0xff);\n}\n\nstatic uint16_t read_uint16(ios_t *s)\n{\n    int b1 = read_uint8(s);\n    int b0 = read_uint8(s);\n    return b0 | (b1<<8);\n}\n\nstatic void writetag(ios_t *s, void *v)\n{\n    write_uint8(s, (uint8_t)(intptr_t)ptrhash_get(&ser_tag, v));\n}\n\nstatic void write_as_tag(ios_t *s, uint8_t tag)\n{\n    if (tag < VALUE_TAGS) {\n        write_uint8(s, 0);\n    }\n    write_uint8(s, tag);\n}\n\nstatic void write_float64(ios_t *s, double x)\n{\n    write_uint64(s, *((uint64_t*)&x));\n}\n\n// --- Static Compile ---\n\n#define jl_serialize_value(s, v) jl_serialize_value_(s,(jl_value_t*)(v))\nstatic void jl_serialize_value_(jl_serializer_state *s, jl_value_t *v);\nstatic jl_value_t *jl_deserialize_value(jl_serializer_state *s, jl_value_t **loc);\nstatic jl_value_t ***sysimg_gvars = NULL;\nstatic void **sysimg_fvars = NULL;\n\n#ifdef HAVE_CPUID\nextern void jl_cpuid(int32_t CPUInfo[4], int32_t InfoType);\n#endif\n\nextern int globalUnique;\nstatic void *jl_sysimg_handle = NULL;\nstatic uint64_t sysimage_base = 0;\n\nJL_DLLEXPORT int jl_running_on_valgrind(void)\n{\n    return RUNNING_ON_VALGRIND;\n}\n\nstatic int jl_load_sysimg_so(void)\n{\n#ifndef _OS_WINDOWS_\n    Dl_info dlinfo;\n#endif\n    // attempt to load the pre-compiled sysimage from jl_sysimg_handle\n    if (jl_sysimg_handle == 0)\n        return -1;\n\n    int imaging_mode = jl_generating_output() && !jl_options.incremental;\n    // in --build mode only use sysimg data, not precompiled native code\n    if (!imaging_mode && jl_options.use_precompiled==JL_OPTIONS_USE_PRECOMPILED_YES) {\n        sysimg_gvars = (jl_value_t***)jl_dlsym(jl_sysimg_handle, \"jl_sysimg_gvars\");\n        sysimg_fvars = (void**)jl_dlsym(jl_sysimg_handle, \"jl_sysimg_fvars\");\n        globalUnique = *(size_t*)jl_dlsym(jl_sysimg_handle, \"jl_globalUnique\");\n#ifdef JULIA_ENABLE_THREADING\n        size_t tls_getter_idx = *(size_t*)jl_dlsym(jl_sysimg_handle,\n                                                   \"jl_ptls_states_getter_idx\");\n        *sysimg_gvars[tls_getter_idx - 1] =\n            (jl_value_t*)jl_get_ptls_states_getter();\n#endif\n        const char *cpu_target = (const char*)jl_dlsym(jl_sysimg_handle, \"jl_sysimg_cpu_target\");\n        if (strcmp(cpu_target,jl_options.cpu_target) != 0)\n            jl_error(\"Julia and the system image were compiled for different architectures.\\n\"\n                     \"Please delete or regenerate sys.{so,dll,dylib}.\");\n#ifdef HAVE_CPUID\n        uint32_t info[4];\n        jl_cpuid((int32_t*)info, 1);\n        if (strcmp(cpu_target, \"native\") == 0) {\n            if (!RUNNING_ON_VALGRIND) {\n                uint64_t saved_cpuid = *(uint64_t*)jl_dlsym(jl_sysimg_handle, \"jl_sysimg_cpu_cpuid\");\n                if (saved_cpuid != (((uint64_t)info[2])|(((uint64_t)info[3])<<32)))\n                    jl_error(\"Target architecture mismatch. Please delete or regenerate sys.{so,dll,dylib}.\");\n            }\n        }\n        else if (strcmp(cpu_target,\"core2\") == 0) {\n            int HasSSSE3 = (info[2] & 1<<9);\n            if (!HasSSSE3)\n                jl_error(\"The current host does not support SSSE3, but the system image was compiled for Core2.\\n\"\n                         \"Please delete or regenerate sys.{so,dll,dylib}.\");\n        }\n#endif\n\n#ifdef _OS_WINDOWS_\n        sysimage_base = (intptr_t)jl_sysimg_handle;\n#else\n        if (dladdr((void*)sysimg_gvars, &dlinfo) != 0) {\n            sysimage_base = (intptr_t)dlinfo.dli_fbase;\n        }\n        else {\n            sysimage_base = 0;\n        }\n#endif\n    }\n    const char *sysimg_data = (const char*)jl_dlsym_e(jl_sysimg_handle, \"jl_system_image_data\");\n    if (sysimg_data) {\n        size_t len = *(size_t*)jl_dlsym(jl_sysimg_handle, \"jl_system_image_size\");\n        jl_restore_system_image_data(sysimg_data, len);\n        return 0;\n    }\n    return -1;\n}\n\nstatic jl_value_t *jl_deserialize_gv(jl_serializer_state *s, jl_value_t *v)\n{\n    // Restore the GlobalVariable reference to this jl_value_t via the sysimg_gvars table\n    int32_t gvname_index = read_int32(s->s)-1;\n    if (sysimg_gvars != NULL && gvname_index >= 0 && s->mode == MODE_SYSTEM_IMAGE) {\n        *sysimg_gvars[gvname_index] = v;\n    }\n    return v;\n}\n\nstatic void jl_serialize_gv(jl_serializer_state *s, jl_value_t *v)\n{\n    // write the index of the literal_pointer_val into the system image\n    write_int32(s->s, jl_get_llvm_gv(v));\n}\n\nstatic void jl_serialize_globalvals(jl_serializer_state *s)\n{\n    size_t i, len = backref_table.size;\n    void **p = backref_table.table;\n    for(i=0; i < len; i+=2) {\n        char *offs = (char*)p[i+1];\n        if (offs != HT_NOTFOUND) {\n            uintptr_t pos = offs - (char*)HT_NOTFOUND - 1;\n            int32_t gv = jl_get_llvm_gv((jl_value_t*)p[i]);\n            if (gv != 0) {\n                write_int32(s->s, pos + 1);\n                write_int32(s->s, gv);\n            }\n        }\n    }\n    write_int32(s->s, 0);\n}\n\nstatic void jl_deserialize_globalvals(jl_serializer_state *s)\n{\n    while (1) {\n        intptr_t key = read_int32(s->s);\n        if (key == 0) break;\n        jl_deserialize_gv(s, (jl_value_t*)backref_list.items[key - 1]);\n    }\n}\n\nstatic void jl_serialize_gv_syms(jl_serializer_state *s, jl_sym_t *v)\n{\n    // since symbols are static, they might not have had a\n    // reference anywhere in the code image other than here\n    void *bp = ptrhash_get(&backref_table, v);\n    if (bp == HT_NOTFOUND) {\n        int32_t gv = jl_get_llvm_gv((jl_value_t*)v);\n        if (gv != 0) {\n            jl_serialize_value(s, v);\n            write_int32(s->s, gv);\n        }\n    }\n    if (v->left) jl_serialize_gv_syms(s, v->left);\n    if (v->right) jl_serialize_gv_syms(s, v->right);\n}\n\nstatic void jl_serialize_gv_others(jl_serializer_state *s)\n{\n    // ensures all objects referenced in the code have\n    // references in the system image to their global variable\n    // since codegen knows that some integer boxes are static,\n    // they might not have had a reference anywhere in the code\n    // image other than here\n    int32_t i;\n    for (i = -512; i < 512; i++) {\n        jl_value_t *v32 = jl_box_int32(i);\n        void *bp32 = ptrhash_get(&backref_table, v32);\n        if (bp32 == HT_NOTFOUND) {\n            int32_t gv32 = jl_get_llvm_gv(v32);\n            if (gv32 != 0) {\n                jl_serialize_value(s, v32);\n                write_int32(s->s, gv32);\n            }\n        }\n    }\n    for (i = -512; i < 512; i++) {\n        jl_value_t *v64 = jl_box_int64(i);\n        void *bp64 = ptrhash_get(&backref_table, v64);\n        if (bp64 == HT_NOTFOUND) {\n            int32_t gv64 = jl_get_llvm_gv(v64);\n            if (gv64 != 0) {\n                jl_serialize_value(s, v64);\n                write_int32(s->s, gv64);\n            }\n        }\n    }\n    jl_serialize_gv_syms(s, jl_get_root_symbol());\n    jl_serialize_value(s, NULL); // signal the end of this list\n}\n\nstatic void jl_deserialize_gv_others(jl_serializer_state *s)\n{\n    while (1) {\n        jl_value_t *v = jl_deserialize_value(s, NULL);\n        if (!v) break;\n        jl_deserialize_gv(s, v);\n    }\n}\n\nstatic struct delayed_fptrs_t {\n    jl_lambda_info_t *li;\n    int32_t func;\n    int32_t cfunc;\n} *delayed_fptrs = NULL;\nstatic size_t delayed_fptrs_n = 0;\nstatic size_t delayed_fptrs_max = 0;\nstatic size_t sysimg_fvars_max = 0;\n\nstatic void jl_delayed_fptrs(jl_lambda_info_t *li, int32_t func, int32_t cfunc)\n{\n    // can't restore the fptrs until after the system image is fully restored,\n    // since it will try to decompress the function AST to determine the argument types\n    if (cfunc || func) {\n        if (delayed_fptrs_max < delayed_fptrs_n + 1) {\n            if (delayed_fptrs_max == 0)\n                // current measurements put the number of functions at 4508\n                delayed_fptrs_max = 4096;\n            else\n                delayed_fptrs_max *= 2;\n            delayed_fptrs = (struct delayed_fptrs_t*)realloc(delayed_fptrs, delayed_fptrs_max*sizeof(delayed_fptrs[0])); //assumes sizeof==alignof\n        }\n        delayed_fptrs[delayed_fptrs_n].li = li;\n        delayed_fptrs[delayed_fptrs_n].func = func;\n        delayed_fptrs[delayed_fptrs_n].cfunc = cfunc;\n        delayed_fptrs_n++;\n        if (func > 0 && func > sysimg_fvars_max)\n            sysimg_fvars_max = func;\n        if (cfunc > 0 && cfunc > sysimg_fvars_max)\n            sysimg_fvars_max = cfunc;\n    }\n}\n\nvoid jl_register_fptrs(uint64_t sysimage_base, void **fptrs, jl_lambda_info_t **linfos, size_t n);\n\nstatic void jl_update_all_fptrs(void)\n{\n    //jl_printf(JL_STDOUT, \"delayed_fptrs_n: %d\\n\", delayed_fptrs_n);\n    void **fvars = sysimg_fvars;\n    if (fvars == 0) return;\n    // jl_fptr_to_llvm needs to decompress some ASTs, therefore this needs to be NULL\n    // to skip trying to restore GlobalVariable pointers in jl_deserialize_gv\n    sysimg_gvars = NULL;\n    sysimg_fvars = NULL;\n    size_t i;\n    jl_lambda_info_t **linfos = (jl_lambda_info_t**)malloc(sizeof(jl_lambda_info_t*) * sysimg_fvars_max);\n    for (i = 0; i < delayed_fptrs_n; i++) {\n        jl_lambda_info_t *li = delayed_fptrs[i].li;\n        int32_t func = delayed_fptrs[i].func - 1;\n        if (func >= 0) {\n            jl_fptr_to_llvm((jl_fptr_t)fvars[func], li, 0);\n            linfos[func] = li;\n        }\n        int32_t cfunc = delayed_fptrs[i].cfunc - 1;\n        if (cfunc >= 0) {\n            jl_fptr_to_llvm((jl_fptr_t)fvars[cfunc], li, 1);\n            linfos[cfunc] = li;\n        }\n    }\n    jl_register_fptrs(sysimage_base, fvars, linfos, sysimg_fvars_max);\n    delayed_fptrs_n = 0;\n    delayed_fptrs_max = 0;\n    sysimg_fvars_max = 0;\n    free(delayed_fptrs);\n    delayed_fptrs = NULL;\n}\n\n// --- serialize ---\n\nstatic void jl_serialize_fptr(jl_serializer_state *s, void *fptr)\n{\n    void **pbp = ptrhash_bp(&fptr_to_id, fptr);\n    if (*pbp == HT_NOTFOUND || fptr == NULL)\n        write_uint16(s->s, 1);\n    else\n        write_uint16(s->s, *(intptr_t*)pbp);\n}\n\nstatic int module_in_worklist(jl_module_t *mod)\n{\n    int i, l = jl_array_len(serializer_worklist);\n    for (i = 0; i < l; i++) {\n        jl_module_t *workmod = (jl_module_t*)jl_array_ptr_ref(serializer_worklist, i);\n        if (jl_is_module(workmod) && jl_is_submodule(mod, workmod))\n            return 1;\n    }\n    return 0;\n}\n\n// compute whether a type references something internal to worklist\n// and thus could not have existed before deserialize\n// and thus does not need delayed unique-ing\nstatic int type_in_worklist(jl_datatype_t *dt)\n{\n    if (module_in_worklist(dt->name->module))\n        return 1;\n    int i, l = jl_svec_len(dt->parameters);\n    for (i = 0; i < l; i++) {\n        jl_value_t *p = jl_tparam(dt, i);\n        if (type_in_worklist((jl_datatype_t*)(jl_is_datatype(p) ? p : jl_typeof(p))))\n            return 1;\n    }\n    return 0;\n}\n\n// returns true if all of the parameters are tag 6 or 7\nstatic int type_recursively_external(jl_datatype_t *dt)\n{\n    if (dt->uid == 0)\n        return 0;\n    if (jl_svec_len(dt->parameters) == 0)\n        return 1;\n\n    int i, l = jl_svec_len(dt->parameters);\n    for (i = 0; i < l; i++) {\n        jl_datatype_t *p = (jl_datatype_t*)jl_tparam(dt, i);\n        if (!jl_is_datatype(p))\n            return 0;\n        if (module_in_worklist(p->name->module))\n            return 0;\n        if (p->name->primary != (jl_value_t*)p) {\n            if (!type_recursively_external(p))\n                return 0;\n        }\n    }\n    return 1;\n}\n\nstatic int jl_prune_tcache(jl_typemap_entry_t *ml, void *closure)\n{\n    jl_value_t *ret = ml->func.value;\n    if (jl_is_lambda_info(ret) &&\n        ((!jl_is_leaf_type((jl_value_t*)ml->sig) && !((jl_lambda_info_t*)ret)->inlineable) ||\n         ((jl_lambda_info_t*)ret)->code == jl_nothing)) {\n        ml->func.value = ((jl_lambda_info_t*)ret)->rettype;\n        jl_gc_wb(ml, ml->func.value);\n    }\n    return 1;\n}\n\n\nstatic void jl_serialize_datatype(jl_serializer_state *s, jl_datatype_t *dt)\n{\n    int tag = 0;\n    if (s->mode == MODE_MODULE) {\n        int internal = module_in_worklist(dt->name->module);\n        if (!internal && dt->name->primary == (jl_value_t*)dt) {\n            tag = 6; // external primary type\n        }\n        else if (dt->uid == 0) {\n            tag = 0; // normal struct\n        }\n        else if (internal) {\n            if (dt->name->primary == (jl_value_t*)dt) // comes up often since functions create types\n                tag = 5; // internal, and not in the typename cache (just needs uid reassigned)\n            else\n                tag = 10; // anything else that's internal (just needs uid reassigned and possibly recaching)\n        }\n        else if (type_recursively_external(dt)) {\n            tag = 7; // external type that can be immediately recreated (with apply_type)\n        }\n        else if (type_in_worklist(dt)) {\n            tag = 10; // external, but definitely new (still needs uid and caching, but not full unique-ing)\n        }\n        else {\n            // this'll need a uid and unique-ing later\n            // flag this in the backref table as special\n            uintptr_t *bp = (uintptr_t*)ptrhash_bp(&backref_table, dt);\n            assert(*bp != (uintptr_t)HT_NOTFOUND);\n            *bp |= 1;\n            tag = 10;\n        }\n    }\n    else if (dt == jl_int32_type)\n        tag = 2;\n    else if (dt == jl_bool_type)\n        tag = 3;\n    else if (dt == jl_int64_type)\n        tag = 4;\n    else if (dt == jl_uint8_type)\n        tag = 8;\n\n    if (strncmp(jl_symbol_name(dt->name->name), \"#kw#\", 4) == 0) {\n        /* XXX: yuck, but the auto-generated kw types from the serializer isn't a real type, so we *must* be very careful */\n        assert(tag == 0 || tag == 5 || tag == 6 || tag == 10);\n        if (tag == 6) {\n            jl_methtable_t *mt = dt->name->mt;\n            jl_datatype_t *primarydt = (jl_datatype_t*)jl_get_global(mt->module, mt->name);\n            assert(jl_is_datatype(primarydt));\n            assert(jl_typeof(primarydt->name->mt->kwsorter) == (jl_value_t*)dt);\n            dt = primarydt;\n            tag = 9;\n        }\n    }\n\n    writetag(s->s, (jl_value_t*)SmallDataType_tag);\n    write_uint8(s->s, 0); // virtual size\n    jl_serialize_value(s, (jl_value_t*)jl_datatype_type);\n    write_uint8(s->s, tag);\n    if (tag == 6) {\n        jl_serialize_value(s, dt->name);\n        return;\n    }\n    if (tag == 7) {\n        jl_serialize_value(s, dt->name);\n        jl_serialize_value(s, dt->parameters);\n        return;\n    }\n    if (tag == 9) {\n        jl_serialize_value(s, dt);\n        return;\n    }\n\n    write_int32(s->s, dt->size);\n    int has_instance = (dt->instance != NULL);\n    int has_layout = (dt->layout != NULL);\n    write_uint8(s->s, dt->abstract | (dt->mutabl<<1) | (has_layout<<2) | (has_instance<<3) |\n        (dt->hastypevars<<4) | (dt->haswildcard<<5) | (dt->isleaftype<<6));\n    write_int32(s->s, dt->depth);\n    if (!dt->abstract) {\n        write_uint16(s->s, dt->ninitialized);\n        if (s->mode != MODE_MODULE) {\n            write_int32(s->s, dt->uid);\n        }\n    }\n\n    if (has_layout) {\n        uint8_t layout = 0;\n        if (dt->layout == jl_array_type->layout) {\n            layout = 1;\n        }\n        else if (dt->layout == jl_void_type->layout) {\n            layout = 2;\n        }\n        else if (dt->layout == jl_pointer_type->layout) {\n            layout = 3;\n        }\n        write_uint8(s->s, layout);\n        if (layout == 0) {\n            size_t nf = dt->layout->nfields;\n            write_uint16(s->s, nf);\n            write_int8(s->s, dt->layout->fielddesc_type);\n            write_int32(s->s, dt->layout->alignment);\n            write_int8(s->s, dt->layout->haspadding);\n            write_int8(s->s, dt->layout->pointerfree);\n            size_t fieldsize = jl_fielddesc_size(dt->layout->fielddesc_type);\n            ios_write(s->s, (char*)(&dt->layout[1]), nf * fieldsize);\n        }\n    }\n\n    if (has_instance)\n        jl_serialize_value(s, dt->instance);\n    jl_serialize_value(s, dt->name);\n    jl_serialize_value(s, dt->parameters);\n    jl_serialize_value(s, dt->super);\n    jl_serialize_value(s, dt->types);\n}\n\nstatic void jl_serialize_module(jl_serializer_state *s, jl_module_t *m)\n{\n    writetag(s->s, jl_module_type);\n    jl_serialize_value(s, m->name);\n    int ref_only = 0;\n    if (s->mode == MODE_MODULE) {\n        if (!module_in_worklist(m))\n            ref_only = 1;\n        write_int8(s->s, ref_only);\n    }\n    jl_serialize_value(s, m->parent);\n    if (ref_only) {\n        assert(m->parent != m);\n        return;\n    }\n    size_t i;\n    void **table = m->bindings.table;\n    for(i=1; i < m->bindings.size; i+=2) {\n        if (table[i] != HT_NOTFOUND) {\n            jl_binding_t *b = (jl_binding_t*)table[i];\n            if (b->owner == m || m != jl_main_module) {\n                jl_serialize_value(s, b->name);\n                jl_serialize_value(s, b->value);\n                jl_serialize_value(s, b->globalref);\n                jl_serialize_value(s, b->owner);\n                write_int8(s->s, (b->deprecated<<3) | (b->constp<<2) | (b->exportp<<1) | (b->imported));\n                jl_serialize_gv(s, (jl_value_t*)b);\n            }\n        }\n    }\n    jl_serialize_value(s, NULL);\n    if (m == jl_main_module) {\n        write_int32(s->s, 1);\n        jl_serialize_value(s, (jl_value_t*)jl_core_module);\n    }\n    else {\n        write_int32(s->s, m->usings.len);\n        for(i=0; i < m->usings.len; i++) {\n            jl_serialize_value(s, (jl_value_t*)m->usings.items[i]);\n        }\n    }\n    write_uint8(s->s, m->istopmod);\n    write_uint64(s->s, m->uuid);\n    write_int32(s->s, m->counter);\n}\n\nstatic int is_ast_node(jl_value_t *v)\n{\n    return jl_is_symbol(v) || jl_is_slot(v) || jl_is_ssavalue(v) ||\n        jl_is_expr(v) || jl_is_newvarnode(v) || jl_is_svec(v) || jl_is_tuple(v) ||\n        jl_is_uniontype(v) || jl_is_int32(v) || jl_is_int64(v) ||\n        jl_is_bool(v) || jl_is_quotenode(v) || jl_is_gotonode(v) ||\n        jl_is_labelnode(v) || jl_is_linenode(v) || jl_is_globalref(v);\n}\n\nstatic int literal_val_id(jl_serializer_state *s, jl_value_t *v)\n{\n    int i, l = jl_array_len(s->tree_literal_values);\n    for (i = 0; i < l; i++) {\n        if (jl_egal(jl_array_ptr_ref(s->tree_literal_values, i), v))\n            return i;\n    }\n    jl_array_ptr_1d_push(s->tree_literal_values, v);\n    return jl_array_len(s->tree_literal_values) - 1;\n}\n\nstatic void jl_serialize_value_(jl_serializer_state *s, jl_value_t *v)\n{\n    if (v == NULL) {\n        write_uint8(s->s, Null_tag);\n        return;\n    }\n\n    void **bp = ptrhash_bp(&ser_tag, v);\n    if (*bp != HT_NOTFOUND) {\n        write_as_tag(s->s, (uint8_t)(intptr_t)*bp);\n        return;\n    }\n    if (jl_is_symbol(v)) {\n        void *idx = ptrhash_get(&common_symbol_tag, v);\n        if (idx != HT_NOTFOUND) {\n            writetag(s->s, (jl_value_t*)CommonSym_tag);\n            write_uint8(s->s, (uint8_t)(size_t)idx);\n            return;\n        }\n    }\n\n    if (s->mode == MODE_AST) {\n        // compressing tree\n        if (!is_ast_node(v)) {\n            writetag(s->s, (jl_value_t*)LiteralVal_tag);\n            int id = literal_val_id(s, v);\n            assert(id >= 0 && id < UINT16_MAX);\n            write_uint16(s->s, id);\n            return;\n        }\n    }\n    else {\n        bp = ptrhash_bp(&backref_table, v);\n        if (*bp != HT_NOTFOUND) {\n            uintptr_t pos = (char*)*bp - (char*)HT_NOTFOUND - 1;\n            if (pos < 65536) {\n                write_uint8(s->s, ShortBackRef_tag);\n                write_uint16(s->s, pos);\n            }\n            else {\n                write_uint8(s->s, BackRef_tag);\n                write_int32(s->s, pos);\n            }\n            return;\n        }\n        intptr_t pos = backref_table_numel++;\n        if (jl_typeof(v) == jl_idtable_type) {\n            // will need to rehash this, later (after types are fully constructed)\n            arraylist_push(&reinit_list, (void*)pos);\n            arraylist_push(&reinit_list, (void*)1);\n        }\n        if (s->mode == MODE_MODULE && jl_is_module(v)) {\n            jl_module_t *m = (jl_module_t*)v;\n            if (module_in_worklist(m) && !module_in_worklist(m->parent)) {\n                // will need to reinsert this into parent bindings, later (in case of any errors during reinsert)\n                arraylist_push(&reinit_list, (void*)pos);\n                arraylist_push(&reinit_list, (void*)2);\n            }\n        }\n        if (s->mode == MODE_MODULE) {\n            // TypeMapLevels need to be rehashed\n            if (jl_is_mtable(v)) {\n                arraylist_push(&reinit_list, (void*)pos);\n                arraylist_push(&reinit_list, (void*)3);\n            }\n            if (jl_is_method(v) && jl_typeof(((jl_method_t*)v)->specializations.unknown) == (jl_value_t*)jl_typemap_level_type) {\n                arraylist_push(&reinit_list, (void*)pos);\n                arraylist_push(&reinit_list, (void*)4);\n            }\n        }\n        if (s->mode == MODE_MODULE)\n            pos <<= 1;\n        ptrhash_put(&backref_table, v, (char*)HT_NOTFOUND + pos + 1);\n    }\n\n    size_t i;\n    if (jl_is_svec(v)) {\n        size_t l = jl_svec_len(v);\n        if (l <= 255) {\n            writetag(s->s, jl_simplevector_type);\n            write_uint8(s->s, (uint8_t)l);\n        }\n        else {\n            writetag(s->s, (jl_value_t*)LongSvec_tag);\n            write_int32(s->s, l);\n        }\n        for(i=0; i < l; i++) {\n            jl_serialize_value(s, jl_svecref(v, i));\n        }\n    }\n    else if (jl_is_symbol(v)) {\n        size_t l = strlen(jl_symbol_name((jl_sym_t*)v));\n        if (l <= 255) {\n            writetag(s->s, jl_symbol_type);\n            write_uint8(s->s, (uint8_t)l);\n        }\n        else {\n            writetag(s->s, (jl_value_t*)LongSymbol_tag);\n            write_int32(s->s, l);\n        }\n        ios_write(s->s, jl_symbol_name((jl_sym_t*)v), l);\n    }\n    else if (jl_is_globalref(v)) {\n        if (s->mode == MODE_AST && jl_globalref_mod(v) == s->tree_enclosing_module) {\n            writetag(s->s, (jl_value_t*)NearbyGlobal_tag);\n            jl_serialize_value(s, jl_globalref_name(v));\n        }\n        else {\n            writetag(s->s, (jl_value_t*)jl_globalref_type);\n            jl_serialize_value(s, jl_globalref_mod(v));\n            jl_serialize_value(s, jl_globalref_name(v));\n        }\n    }\n    else if (jl_is_ssavalue(v) && ((jl_ssavalue_t*)v)->id < 65536) {\n        writetag(s->s, (jl_value_t*)jl_ssavalue_type);\n        write_uint16(s->s, ((jl_ssavalue_t*)v)->id);\n    }\n    else if (jl_typeis(v,jl_slotnumber_type) && jl_slot_number(v) < 65536) {\n        writetag(s->s, (jl_value_t*)jl_slotnumber_type);\n        write_uint16(s->s, jl_slot_number(v));\n    }\n    else if (jl_is_array(v)) {\n        jl_array_t *ar = (jl_array_t*)v;\n        if (ar->flags.ndims == 1 && ar->elsize < 128) {\n            writetag(s->s, (jl_value_t*)Array1d_tag);\n            write_uint8(s->s, (ar->flags.ptrarray<<7) | (ar->elsize & 0x7f));\n        }\n        else {\n            writetag(s->s, (jl_value_t*)jl_array_type);\n            write_uint16(s->s, ar->flags.ndims);\n            write_uint16(s->s, (ar->flags.ptrarray<<15) | (ar->elsize & 0x7fff));\n        }\n        for (i=0; i < ar->flags.ndims; i++)\n            jl_serialize_value(s, jl_box_long(jl_array_dim(ar,i)));\n        jl_serialize_value(s, jl_typeof(ar));\n        if (!ar->flags.ptrarray) {\n            size_t tot = jl_array_len(ar) * ar->elsize;\n            ios_write(s->s, (char*)jl_array_data(ar), tot);\n        }\n        else {\n            for(i=0; i < jl_array_len(ar); i++) {\n                jl_serialize_value(s, jl_array_ptr_ref(v, i));\n            }\n        }\n    }\n    else if (jl_is_expr(v)) {\n        jl_expr_t *e = (jl_expr_t*)v;\n        size_t l = jl_array_len(e->args);\n        if (l <= 255) {\n            writetag(s->s, jl_expr_type);\n            write_uint8(s->s, (uint8_t)l);\n        }\n        else {\n            writetag(s->s, (jl_value_t*)LongExpr_tag);\n            write_int32(s->s, l);\n        }\n        jl_serialize_value(s, e->head);\n        jl_serialize_value(s, e->etype);\n        for (i = 0; i < l; i++) {\n            jl_serialize_value(s, jl_exprarg(e, i));\n        }\n    }\n    else if (jl_is_datatype(v)) {\n        jl_serialize_datatype(s, (jl_datatype_t*)v);\n    }\n    else if (jl_is_typevar(v)) {\n        writetag(s->s, jl_tvar_type);\n        jl_serialize_value(s, ((jl_tvar_t*)v)->name);\n        jl_serialize_value(s, ((jl_tvar_t*)v)->lb);\n        jl_serialize_value(s, ((jl_tvar_t*)v)->ub);\n        write_int8(s->s, ((jl_tvar_t*)v)->bound);\n    }\n    else if (jl_is_method(v)) {\n        writetag(s->s, jl_method_type);\n        jl_method_t *m = (jl_method_t*)v;\n        int internal = 1;\n        int external_mt = 0;\n        if (s->mode == MODE_MODULE) {\n            internal = module_in_worklist(m->module);\n            if (!internal) {\n                // flag this in the backref table as special\n                uintptr_t *bp = (uintptr_t*)ptrhash_bp(&backref_table, v);\n                assert(*bp != (uintptr_t)HT_NOTFOUND);\n                *bp |= 1;\n            }\n        }\n        jl_serialize_value(s, (jl_value_t*)m->sig);\n        if (s->mode == MODE_MODULE) {\n            write_uint8(s->s, internal);\n            if (!internal)\n                return;\n            jl_datatype_t *gf = jl_first_argument_datatype((jl_value_t*)m->sig);\n            assert(jl_is_datatype(gf) && gf->name->mt);\n            external_mt = !module_in_worklist(gf->name->mt->module);\n        }\n        union jl_typemap_t *tf = &m->specializations;\n        if (tf->unknown && tf->unknown != jl_nothing) {\n            // go through the t-func cache, replacing ASTs with just return\n            // types for abstract argument types. these ASTs are generally\n            // not needed (e.g. they don't get inlined).\n            jl_typemap_visitor(*tf, jl_prune_tcache, NULL);\n        }\n        jl_serialize_value(s, tf->unknown);\n        jl_serialize_value(s, (jl_value_t*)m->name);\n        write_int8(s->s, m->isstaged);\n        jl_serialize_value(s, (jl_value_t*)m->file);\n        write_int32(s->s, m->line);\n        jl_serialize_value(s, (jl_value_t*)m->tvars);\n        if (external_mt)\n            jl_serialize_value(s, jl_nothing);\n        else\n            jl_serialize_value(s, (jl_value_t*)m->ambig);\n        write_int8(s->s, m->called);\n        jl_serialize_value(s, (jl_value_t*)m->module);\n        jl_serialize_value(s, (jl_value_t*)m->roots);\n        jl_serialize_value(s, (jl_value_t*)m->lambda_template);\n        jl_serialize_value(s, (jl_value_t*)m->invokes.unknown);\n        write_int8(s->s, m->needs_sparam_vals_ducttape);\n    }\n    else if (jl_is_lambda_info(v)) {\n        writetag(s->s, jl_lambda_info_type);\n        jl_lambda_info_t *li = (jl_lambda_info_t*)v;\n        int external = 0;\n        if (s->mode == MODE_MODULE) {\n            external = li->def && !module_in_worklist(li->def->module);\n            if (external) {\n                // also flag this in the backref table as special\n                uintptr_t *bp = (uintptr_t*)ptrhash_bp(&backref_table, v);\n                assert(*bp != (uintptr_t)HT_NOTFOUND);\n                *bp |= 1;\n            }\n        }\n        jl_serialize_value(s, (jl_value_t*)li->specTypes);\n        write_int8(s->s, li->inferred);\n        jl_serialize_value(s, li->rettype);\n        if (s->mode == MODE_MODULE && external)\n            jl_serialize_value(s, (jl_value_t*)li->def->sig);\n        else\n            jl_serialize_value(s, (jl_value_t*)li->def);\n        if (s->mode == MODE_MODULE) {\n            write_uint8(s->s, external);\n            if (external)\n                return;\n        }\n\n        if (li->jlcall_api == 2)\n            jl_serialize_value(s, jl_nothing);\n        else\n            jl_serialize_value(s, li->code);\n        jl_serialize_value(s, li->slotnames);\n        jl_serialize_value(s, li->slottypes);\n        jl_serialize_value(s, li->slotflags);\n        jl_serialize_value(s, li->ssavaluetypes);\n        jl_serialize_value(s, (jl_value_t*)li->sparam_syms);\n        jl_serialize_value(s, (jl_value_t*)li->sparam_vals);\n        write_int8(s->s, li->pure);\n        write_int8(s->s, li->inlineable);\n        write_int8(s->s, li->isva);\n        write_int32(s->s, li->nargs);\n        jl_serialize_value(s, li->constval);\n        jl_serialize_fptr(s, (void*)(uintptr_t)li->fptr);\n        // save functionObject pointers\n        write_int32(s->s, jl_assign_functionID(li->functionObjectsDecls.functionObject));\n        write_int32(s->s, jl_assign_functionID(li->functionObjectsDecls.specFunctionObject));\n        write_int8(s->s, li->jlcall_api);\n    }\n    else if (jl_typeis(v, jl_module_type)) {\n        jl_serialize_module(s, (jl_module_t*)v);\n    }\n    else if (jl_typeis(v, jl_task_type)) {\n        jl_error(\"Task cannot be serialized\");\n    }\n    else {\n        jl_datatype_t *t = (jl_datatype_t*)jl_typeof(v);\n        void *data = jl_data_ptr(v);\n        if (t == jl_int64_type &&\n            *(int64_t*)data >= S32_MIN && *(int64_t*)data <= S32_MAX) {\n            writetag(s->s, (jl_value_t*)SmallInt64_tag);\n            write_int32(s->s, (int32_t)*(int64_t*)data);\n        }\n        else if (t == jl_int32_type) {\n            writetag(s->s, (jl_value_t*)Int32_tag);\n            write_int32(s->s, (int32_t)*(int32_t*)data);\n        }\n        else {\n            if (v == t->instance) {\n                if (s->mode == MODE_MODULE && !type_in_worklist(t)) {\n                    // also flag this in the backref table as special\n                    // if it might not be unique (is external)\n                    uintptr_t *bp = (uintptr_t*)ptrhash_bp(&backref_table, v);\n                    assert(*bp != (uintptr_t)HT_NOTFOUND);\n                    *bp |= 1;\n                }\n                writetag(s->s, (jl_value_t*)Singleton_tag);\n                jl_serialize_value(s, t);\n                return;\n            }\n            if (t->size <= 255) {\n                writetag(s->s, (jl_value_t*)SmallDataType_tag);\n                write_uint8(s->s, t->size);\n            }\n            else {\n                writetag(s->s, (jl_value_t*)jl_datatype_type);\n                write_int32(s->s, t->size);\n            }\n            jl_serialize_value(s, t);\n            if (s->mode == MODE_MODULE) {\n                if (t == jl_typename_type) {\n                    if (module_in_worklist(((jl_typename_t*)v)->module)) {\n                        write_uint8(s->s, 0);\n                    }\n                    else {\n                        write_uint8(s->s, 1);\n                        jl_typename_t *tn = (jl_typename_t*)v;\n                        jl_serialize_value(s, tn->module);\n                        jl_serialize_value(s, tn->name);\n                        return;\n                    }\n                }\n                if (t == jl_typemap_level_type) {\n                    // perform some compression on the typemap levels\n                    // (which will need to be rehashed during deserialization anyhow)\n                    jl_typemap_level_t *node = (jl_typemap_level_t*)v;\n                    assert( // make sure this type has the expected ordering\n                        offsetof(jl_typemap_level_t, arg1) == 0 * sizeof(jl_value_t*) &&\n                        offsetof(jl_typemap_level_t, targ) == 2 * sizeof(jl_value_t*) &&\n                        offsetof(jl_typemap_level_t, linear) == 4 * sizeof(jl_value_t*) &&\n                        offsetof(jl_typemap_level_t, any) == 5 * sizeof(jl_value_t*) &&\n                        offsetof(jl_typemap_level_t, key) == 6 * sizeof(jl_value_t*) &&\n                        sizeof(jl_typemap_level_t) == 7 * sizeof(jl_value_t*));\n                    jl_serialize_value(s, jl_nothing);\n                    jl_serialize_value(s, node->arg1.values);\n                    jl_serialize_value(s, jl_nothing);\n                    jl_serialize_value(s, node->targ.values);\n                    jl_serialize_value(s, node->linear);\n                    jl_serialize_value(s, node->any.unknown);\n                    jl_serialize_value(s, node->key);\n                    return;\n                }\n            }\n            size_t nf = jl_datatype_nfields(t);\n            if (nf == 0 && jl_datatype_size(t)>0) {\n                if (t->name == jl_pointer_type->name) {\n                    write_int32(s->s, 0);\n#ifdef _P64\n                    write_int32(s->s, 0);\n#endif\n                }\n                else {\n                    ios_write(s->s, (char*)data, jl_datatype_size(t));\n                }\n            }\n            else {\n                size_t i;\n                for (i = 0; i < nf; i++) {\n                    if (jl_field_size(t, i) > 0) {\n                        jl_serialize_value(s, jl_get_nth_field(v, i));\n                    }\n                }\n            }\n        }\n    }\n}\n\nstruct jl_serialize_methcache_from_mod_env {\n    jl_serializer_state *s;\n    jl_sym_t *name;\n    jl_module_t *mod;\n};\n\nstatic int jl_serialize_methcache_from_mod(jl_typemap_entry_t *ml, void *closure)\n{\n    struct jl_serialize_methcache_from_mod_env *env = (struct jl_serialize_methcache_from_mod_env*)closure;\n    if (module_in_worklist(ml->func.method->module)) {\n        jl_serialize_value(env->s, ml->func.method);\n        jl_serialize_value(env->s, ml->simplesig);\n    }\n    return 1;\n}\n\nstatic void jl_serialize_methtable_from_mod(jl_serializer_state *s, jl_typename_t *tn)\n{\n    struct jl_serialize_methcache_from_mod_env env;\n    env.s = s;\n    env.mod = tn->module;\n    env.name = tn->name;\n    assert(tn->module);\n    jl_typemap_visitor(tn->mt->defs, jl_serialize_methcache_from_mod, &env);\n}\n\nstatic void jl_serialize_lambdas_from_mod(jl_serializer_state *s, jl_module_t *m)\n{\n    if (module_in_worklist(m)) return;\n    size_t i;\n    void **table = m->bindings.table;\n    for(i=1; i < m->bindings.size; i+=2) {\n        if (table[i] != HT_NOTFOUND) {\n            jl_binding_t *b = (jl_binding_t*)table[i];\n            if (b->owner == m && b->value && b->constp) {\n                if (jl_is_datatype(b->value)) {\n                    jl_typename_t *tn = ((jl_datatype_t*)b->value)->name;\n                    if (tn->module == m && tn->name == b->name) {\n                        jl_methtable_t *mt = tn->mt;\n                        if (mt != NULL && (jl_value_t*)mt != jl_nothing && (mt != jl_type_type_mt || tn == jl_type_type->name)) {\n                            jl_serialize_methtable_from_mod(s, tn);\n                        }\n                    }\n                }\n                else if (jl_is_module(b->value)) {\n                    jl_module_t *child = (jl_module_t*)b->value;\n                    if (child != m && child->parent == m && child->name == b->name) {\n                        // this is the original/primary binding for the submodule\n                        jl_serialize_lambdas_from_mod(s, (jl_module_t*)b->value);\n                    }\n                }\n            }\n        }\n    }\n}\n\n// serialize information about all of the modules accessible directly from Main\nstatic void write_mod_list(ios_t *s)\n{\n    jl_module_t *m = jl_main_module;\n    size_t i;\n    void **table = m->bindings.table;\n    for(i=1; i < m->bindings.size; i+=2) {\n        if (table[i] != HT_NOTFOUND) {\n            jl_binding_t *b = (jl_binding_t*)table[i];\n            if (b->owner == m &&\n                    b->value && b->constp &&\n                    jl_is_module(b->value) &&\n                    !module_in_worklist((jl_module_t*)b->value)) {\n                jl_module_t *child = (jl_module_t*)b->value;\n                if (child->name == b->name) {\n                    // this is the original/primary binding for the submodule\n                    size_t l = strlen(jl_symbol_name(child->name));\n                    write_int32(s, l);\n                    ios_write(s, jl_symbol_name(child->name), l);\n                    write_uint64(s, child->uuid);\n                }\n            }\n        }\n    }\n    write_int32(s, 0);\n}\n\n// \"magic\" string and version header of .ji file\nstatic const int JI_FORMAT_VERSION = 3;\nstatic const char JI_MAGIC[] = \"\\373jli\\r\\n\\032\\n\"; // based on PNG signature\nstatic const uint16_t BOM = 0xFEFF; // byte-order marker\nstatic void write_header(ios_t *s)\n{\n    ios_write(s, JI_MAGIC, strlen(JI_MAGIC));\n    write_uint16(s, JI_FORMAT_VERSION);\n    ios_write(s, (char *) &BOM, 2);\n    write_uint8(s, sizeof(void*));\n    ios_write(s, JL_BUILD_UNAME, strlen(JL_BUILD_UNAME)+1);\n    ios_write(s, JL_BUILD_ARCH, strlen(JL_BUILD_ARCH)+1);\n    ios_write(s, JULIA_VERSION_STRING, strlen(JULIA_VERSION_STRING)+1);\n    const char *branch = jl_git_branch(), *commit = jl_git_commit();\n    ios_write(s, branch, strlen(branch)+1);\n    ios_write(s, commit, strlen(commit)+1);\n}\n\n// serialize information about the result of deserializing this file\nstatic void write_work_list(ios_t *s)\n{\n    int i, l = jl_array_len(serializer_worklist);\n    for (i = 0; i < l; i++) {\n        jl_module_t *workmod = (jl_module_t*)jl_array_ptr_ref(serializer_worklist, i);\n        if (workmod->parent == jl_main_module) {\n            size_t l = strlen(jl_symbol_name(workmod->name));\n            write_int32(s, l);\n            ios_write(s, jl_symbol_name(workmod->name), l);\n            write_uint64(s, workmod->uuid);\n        }\n    }\n    write_int32(s, 0);\n}\n\n// serialize the global _require_dependencies array of pathnames that\n// are include depenencies\nstatic void write_dependency_list(ios_t *s)\n{\n    size_t total_size = 0;\n    static jl_array_t *deps = NULL;\n    if (!deps)\n        deps = (jl_array_t*)jl_get_global(jl_base_module, jl_symbol(\"_require_dependencies\"));\n\n    // unique(deps) to eliminate duplicates while preserving order:\n    // we preserve order so that the topmost included .jl file comes first\n    static jl_value_t *unique_func = NULL;\n    if (!unique_func)\n        unique_func = jl_get_global(jl_base_module, jl_symbol(\"unique\"));\n    jl_value_t *uniqargs[2] = {unique_func,(jl_value_t*)deps};\n    jl_array_t *udeps = deps && unique_func ? (jl_array_t*)jl_apply(uniqargs, 2) : NULL;\n\n    JL_GC_PUSH1(&udeps);\n    if (udeps) {\n        size_t l = jl_array_len(udeps);\n        for (size_t i=0; i < l; i++) {\n            jl_value_t *dep = jl_fieldref(jl_array_ptr_ref(udeps, i), 0);\n            size_t slen = jl_string_len(dep);\n            total_size += 4 + slen + 8;\n        }\n        total_size += 4;\n    }\n    // write the total size so that we can quickly seek past all of the\n    // dependencies if we don't need them\n    write_uint64(s, total_size);\n    if (udeps) {\n        size_t l = jl_array_len(udeps);\n        for (size_t i=0; i < l; i++) {\n            jl_value_t *deptuple = jl_array_ptr_ref(udeps, i);\n            jl_value_t *dep = jl_fieldref(deptuple, 0);\n            size_t slen = jl_string_len(dep);\n            write_int32(s, slen);\n            ios_write(s, jl_string_data(dep), slen);\n            write_float64(s, jl_unbox_float64(jl_fieldref(deptuple, 1)));\n        }\n        write_int32(s, 0); // terminator, for ease of reading\n    }\n    JL_GC_POP();\n}\n\n// --- deserialize ---\n\nstatic jl_fptr_t jl_deserialize_fptr(jl_serializer_state *s)\n{\n    int fptr = read_uint16(s->s);\n    if (fptr < 2)\n        return NULL;\n\n    if (fptr >= sizeof(id_to_fptrs)/sizeof(*id_to_fptrs))\n        jl_error(\"unknown function pointer ID\");\n    return id_to_fptrs[fptr];\n}\n\nstatic jl_value_t *jl_deserialize_datatype(jl_serializer_state *s, int pos, jl_value_t **loc)\n{\n    int tag = read_uint8(s->s);\n    if (tag == 6 || tag == 7) {\n        jl_typename_t *name = (jl_typename_t*)jl_deserialize_value(s, NULL);\n        jl_value_t *dtv = name->primary;\n        if (tag == 7) {\n            jl_svec_t *parameters = (jl_svec_t*)jl_deserialize_value(s, NULL);\n            dtv = jl_apply_type(dtv, parameters);\n        }\n        backref_list.items[pos] = dtv;\n        return dtv;\n    }\n    if (tag == 9) {\n        jl_datatype_t *primarydt = (jl_datatype_t*)jl_deserialize_value(s, NULL);\n        jl_value_t *dtv = jl_typeof(jl_get_kwsorter(primarydt->name));\n        backref_list.items[pos] = dtv;\n        return dtv;\n    }\n    size_t size = read_int32(s->s);\n    uint8_t flags = read_uint8(s->s);\n    uint8_t depth = read_int32(s->s);\n    jl_datatype_t *dt = NULL;\n    if (tag == 2)\n        dt = jl_int32_type;\n    else if (tag == 3)\n        dt = jl_bool_type;\n    else if (tag == 4)\n        dt = jl_int64_type;\n    else if (tag == 8)\n        dt = jl_uint8_type;\n    else if (tag == 0 || tag == 5 || tag == 10)\n        dt = jl_new_uninitialized_datatype();\n    else {\n        assert(0 && \"corrupt deserialization state\");\n        abort();\n    }\n    assert(s->tree_literal_values==NULL && s->mode != MODE_AST && \"no new data-types expected during MODE_AST\");\n    assert(pos == backref_list.len - 1 && \"nothing should have been deserialized since assigning pos\");\n    backref_list.items[pos] = dt;\n    dt->size = size;\n    dt->struct_decl = NULL;\n    dt->instance = NULL;\n    dt->ditype = NULL;\n    dt->abstract = flags&1;\n    dt->mutabl = (flags>>1)&1;\n    int has_layout = (flags>>2)&1;\n    int has_instance = (flags>>3)&1;\n    dt->hastypevars = (flags>>4)&1;\n    dt->haswildcard = (flags>>5)&1;\n    dt->isleaftype = (flags>>6)&1;\n    dt->depth = depth;\n    dt->types = NULL;\n    dt->parameters = NULL;\n    dt->name = NULL;\n    dt->super = NULL;\n    dt->layout = NULL;\n    if (!dt->abstract) {\n        dt->ninitialized = read_uint16(s->s);\n        dt->uid = (s->mode != MODE_MODULE) ? read_int32(s->s) : 0;\n    }\n    else {\n        dt->ninitialized = 0;\n        dt->uid = 0;\n    }\n\n    if (has_layout) {\n        uint8_t layout = read_uint8(s->s);\n        if (layout == 1) {\n            dt->layout = jl_array_type->layout;\n        }\n        else if (layout == 2) {\n            dt->layout = jl_void_type->layout;\n        }\n        else if (layout == 3) {\n            dt->layout = jl_pointer_type->layout;\n        }\n        else {\n            assert(layout == 0);\n            uint16_t nf = read_uint16(s->s);\n            uint8_t fielddesc_type = read_int8(s->s);\n            size_t fielddesc_size = nf > 0 ? jl_fielddesc_size(fielddesc_type) : 0;\n            jl_datatype_layout_t *layout = (jl_datatype_layout_t*)jl_gc_perm_alloc(\n                    sizeof(jl_datatype_layout_t) + nf * fielddesc_size);\n            layout->nfields = nf;\n            layout->fielddesc_type = fielddesc_type;\n            layout->alignment = read_int32(s->s);\n            layout->haspadding = read_int8(s->s);\n            layout->pointerfree = read_int8(s->s);\n            ios_read(s->s, (char*)&layout[1], nf * fielddesc_size);\n            dt->layout = layout;\n        }\n    }\n\n    if (tag == 5) {\n        dt->uid = jl_assign_type_uid();\n    }\n    else if (tag == 10) {\n        assert(pos > 0);\n        arraylist_push(&flagref_list, loc == HT_NOTFOUND ? NULL : loc);\n        arraylist_push(&flagref_list, (void*)(uintptr_t)pos);\n        dt->uid = -1; // mark that this type needs a new uid\n    }\n\n    if (has_instance) {\n        assert(dt->uid != 0 && \"there shouldn't be an instance on a type with uid = 0\");\n        dt->instance = jl_deserialize_value(s, &dt->instance);\n        jl_gc_wb(dt, dt->instance);\n    }\n    dt->name = (jl_typename_t*)jl_deserialize_value(s, (jl_value_t**)&dt->name);\n    jl_gc_wb(dt, dt->name);\n    dt->parameters = (jl_svec_t*)jl_deserialize_value(s, (jl_value_t**)&dt->parameters);\n    jl_gc_wb(dt, dt->parameters);\n    dt->super = (jl_datatype_t*)jl_deserialize_value(s, (jl_value_t**)&dt->super);\n    jl_gc_wb(dt, dt->super);\n    dt->types = (jl_svec_t*)jl_deserialize_value(s, (jl_value_t**)&dt->types);\n    jl_gc_wb(dt, dt->types);\n\n    return (jl_value_t*)dt;\n}\n\nstatic jl_value_t *jl_deserialize_value_(jl_serializer_state *s, jl_value_t *vtag, jl_value_t **loc);\nstatic jl_value_t *jl_deserialize_value(jl_serializer_state *s, jl_value_t **loc)\n{\n    assert(!ios_eof(s->s));\n    uint8_t tag = read_uint8(s->s);\n    if (tag == Null_tag)\n        return NULL;\n    if (tag == 0) {\n        tag = read_uint8(s->s);\n        jl_value_t *v = deser_tag[tag];\n        assert(v != NULL);\n        return v;\n    }\n    if (tag == BackRef_tag || tag == ShortBackRef_tag) {\n        assert(s->tree_literal_values == NULL && s->mode != MODE_AST);\n        uintptr_t offs = (tag == BackRef_tag) ? read_int32(s->s) : read_uint16(s->s);\n        int isflagref = 0;\n        if (s->mode == MODE_MODULE) {\n            isflagref = !!(offs & 1);\n            offs >>= 1;\n        }\n        // assert(offs >= 0); // offs is unsigned so this is always true\n        assert(offs < backref_list.len);\n        jl_value_t *bp = (jl_value_t*)backref_list.items[offs];\n        assert(bp);\n        if (isflagref && loc != HT_NOTFOUND) {\n            assert(loc != NULL);\n            arraylist_push(&flagref_list, loc);\n            arraylist_push(&flagref_list, (void*)(uintptr_t)-1);\n        }\n        return (jl_value_t*)bp;\n    }\n\n    jl_value_t *vtag = deser_tag[tag];\n    if (tag >= VALUE_TAGS) {\n        return vtag;\n    }\n    else if (vtag == (jl_value_t*)LiteralVal_tag) {\n        return jl_array_ptr_ref(s->tree_literal_values, read_uint16(s->s));\n    }\n    jl_value_t *v = jl_deserialize_value_(s, vtag, loc);\n    return v;\n}\n\nstatic jl_value_t *jl_deserialize_value_svec(jl_serializer_state *s, jl_value_t *vtag)\n{\n    int usetable = (s->mode != MODE_AST);\n    size_t i, len;\n    if (vtag == (jl_value_t*)jl_simplevector_type)\n        len = read_uint8(s->s);\n    else\n        len = read_int32(s->s);\n    jl_svec_t *sv = jl_alloc_svec_uninit(len);\n    if (usetable)\n        arraylist_push(&backref_list, (jl_value_t*)sv);\n    jl_value_t **data = jl_svec_data(sv);\n    for (i = 0; i < len; i++) {\n        data[i] = jl_deserialize_value(s, &data[i]);\n    }\n    return (jl_value_t*)sv;\n}\n\nstatic jl_value_t *jl_deserialize_value_symbol(jl_serializer_state *s, jl_value_t *vtag)\n{\n    int usetable = (s->mode != MODE_AST);\n    size_t len;\n    if (vtag == (jl_value_t*)jl_symbol_type)\n        len = read_uint8(s->s);\n    else\n        len = read_int32(s->s);\n    char *name = (char*)(len >= 256 ? malloc(len + 1) : alloca(len + 1));\n    ios_read(s->s, name, len);\n    name[len] = '\\0';\n    jl_value_t *sym = (jl_value_t*)jl_symbol(name);\n    if (len >= 256)\n        free(name);\n    if (usetable)\n        arraylist_push(&backref_list, sym);\n    return sym;\n}\n\nstatic jl_value_t *jl_deserialize_value_array(jl_serializer_state *s, jl_value_t *vtag)\n{\n    int usetable = (s->mode != MODE_AST);\n    int16_t i, ndims;\n    int isunboxed, elsize;\n    if (vtag == (jl_value_t*)Array1d_tag) {\n        ndims = 1;\n        elsize = read_uint8(s->s);\n        isunboxed = !(elsize >> 7);\n        elsize = elsize & 0x7f;\n    }\n    else {\n        ndims = read_uint16(s->s);\n        elsize = read_uint16(s->s);\n        isunboxed = !(elsize >> 15);\n        elsize = elsize & 0x7fff;\n    }\n    uintptr_t pos = backref_list.len;\n    if (usetable)\n        arraylist_push(&backref_list, NULL);\n    size_t *dims = (size_t*)alloca(ndims * sizeof(size_t));\n    for (i = 0; i < ndims; i++) {\n        dims[i] = jl_unbox_long(jl_deserialize_value(s, NULL));\n    }\n    jl_array_t *a = jl_new_array_for_deserialization((jl_value_t*)NULL, ndims, dims, isunboxed, elsize);\n    if (usetable)\n        backref_list.items[pos] = a;\n    jl_value_t *aty = jl_deserialize_value(s, &jl_astaggedvalue(a)->type);\n    jl_set_typeof(a, aty);\n    if (!a->flags.ptrarray) {\n        size_t tot = jl_array_len(a) * a->elsize;\n        ios_read(s->s, (char*)jl_array_data(a), tot);\n    }\n    else {\n        jl_value_t **data = (jl_value_t**)jl_array_data(a);\n        size_t i, numel = jl_array_len(a);\n        for (i = 0; i < numel; i++) {\n            data[i] = jl_deserialize_value(s, &data[i]);\n            if (data[i])\n                jl_gc_wb(a, data[i]);\n        }\n    }\n    return (jl_value_t*)a;\n}\n\nstatic jl_value_t *jl_deserialize_value_expr(jl_serializer_state *s, jl_value_t *vtag)\n{\n    int usetable = (s->mode != MODE_AST);\n    size_t i, len;\n    if (vtag == (jl_value_t*)jl_expr_type)\n        len = read_uint8(s->s);\n    else\n        len = read_int32(s->s);\n    int pos = backref_list.len;\n    if (usetable)\n        arraylist_push(&backref_list, NULL);\n    jl_expr_t *e = jl_exprn((jl_sym_t*)jl_deserialize_value(s, NULL), len);\n    if (usetable)\n        backref_list.items[pos] = e;\n    e->etype = jl_deserialize_value(s, &e->etype);\n    jl_gc_wb(e, e->etype);\n    jl_value_t **data = (jl_value_t**)(e->args->data);\n    for (i = 0; i < len; i++) {\n        data[i] = jl_deserialize_value(s, &data[i]);\n    }\n    return (jl_value_t*)e;\n}\n\nstatic jl_value_t *jl_deserialize_value_method(jl_serializer_state *s, jl_value_t **loc)\n{\n    int usetable = (s->mode != MODE_AST);\n    jl_method_t *m =\n        (jl_method_t*)jl_gc_alloc(s->ptls, sizeof(jl_method_t),\n                                  jl_method_type);\n    memset(m, 0, sizeof(jl_method_type));\n    uintptr_t pos = backref_list.len;\n    if (usetable)\n        arraylist_push(&backref_list, m);\n    m->sig = (jl_tupletype_t*)jl_deserialize_value(s, (jl_value_t**)&m->sig);\n    jl_gc_wb(m, m->sig);\n    if (s->mode == MODE_MODULE) {\n        int internal = read_uint8(s->s);\n        if (!internal) {\n            assert(loc != NULL && loc != HT_NOTFOUND);\n            arraylist_push(&flagref_list, loc);\n            arraylist_push(&flagref_list, (void*)pos);\n            return (jl_value_t*)m;\n        }\n    }\n    m->specializations.unknown = jl_deserialize_value(s, (jl_value_t**)&m->specializations);\n    jl_gc_wb(m, m->specializations.unknown);\n    m->name = (jl_sym_t*)jl_deserialize_value(s, NULL);\n    jl_gc_wb(m, m->name);\n    m->isstaged = read_int8(s->s);\n    m->file = (jl_sym_t*)jl_deserialize_value(s, NULL);\n    m->line = read_int32(s->s);\n    m->tvars = (jl_svec_t*)jl_deserialize_value(s, (jl_value_t**)&m->tvars);\n    jl_gc_wb(m, m->tvars);\n    m->ambig = jl_deserialize_value(s, (jl_value_t**)&m->ambig);\n    jl_gc_wb(m, m->ambig);\n    m->called = read_int8(s->s);\n    m->module = (jl_module_t*)jl_deserialize_value(s, (jl_value_t**)&m->module);\n    jl_gc_wb(m, m->module);\n    m->roots = (jl_array_t*)jl_deserialize_value(s, (jl_value_t**)&m->roots);\n    if (m->roots) jl_gc_wb(m, m->roots);\n    m->lambda_template = (jl_lambda_info_t*)jl_deserialize_value(s, (jl_value_t**)&m->lambda_template);\n    if (m->lambda_template) jl_gc_wb(m, m->lambda_template);\n    m->invokes.unknown = jl_deserialize_value(s, (jl_value_t**)&m->invokes);\n    jl_gc_wb(m, m->invokes.unknown);\n    m->needs_sparam_vals_ducttape = read_int8(s->s);\n    m->traced = 0;\n    JL_MUTEX_INIT(&m->writelock);\n    return (jl_value_t*)m;\n}\n\nstatic jl_value_t *jl_deserialize_value_lambda_info(jl_serializer_state *s, jl_value_t **loc)\n{\n    int usetable = (s->mode != MODE_AST);\n    jl_lambda_info_t *li =\n        (jl_lambda_info_t*)jl_gc_alloc(s->ptls, sizeof(jl_lambda_info_t),\n                                       jl_lambda_info_type);\n    memset(li, 0, sizeof(jl_lambda_info_t));\n    uintptr_t pos = backref_list.len;\n    if (usetable)\n        arraylist_push(&backref_list, li);\n\n    li->specTypes = (jl_tupletype_t*)jl_deserialize_value(s, (jl_value_t**)&li->specTypes);\n    if (li->specTypes)\n        jl_gc_wb(li, li->specTypes);\n    int inferred = read_int8(s->s);\n    li->inferred = inferred;\n    li->rettype = jl_deserialize_value(s, &li->rettype);\n    jl_gc_wb(li, li->rettype);\n    li->def = (jl_method_t*)jl_deserialize_value(s, (jl_value_t**)&li->def);\n    if (li->def)\n        jl_gc_wb(li, li->def);\n\n    if (s->mode == MODE_MODULE) {\n        int external = read_uint8(s->s);\n        if (external) {\n            assert(loc != NULL && loc != HT_NOTFOUND);\n            arraylist_push(&flagref_list, loc);\n            arraylist_push(&flagref_list, (void*)pos);\n            return (jl_value_t*)li;\n        }\n    }\n\n    li->code = jl_deserialize_value(s, &li->code); jl_gc_wb(li, li->code);\n    li->slotnames = (jl_array_t*)jl_deserialize_value(s, (jl_value_t**)&li->slotnames); jl_gc_wb(li, li->slotnames);\n    li->slottypes = jl_deserialize_value(s, &li->slottypes); jl_gc_wb(li, li->slottypes);\n    li->slotflags = (jl_array_t*)jl_deserialize_value(s, (jl_value_t**)&li->slotflags); jl_gc_wb(li, li->slotflags);\n    li->ssavaluetypes = jl_deserialize_value(s, &li->ssavaluetypes); jl_gc_wb(li, li->ssavaluetypes);\n    li->sparam_syms = (jl_svec_t*)jl_deserialize_value(s, (jl_value_t**)&li->sparam_syms);\n    jl_gc_wb(li, li->sparam_syms);\n    li->sparam_vals = (jl_svec_t*)jl_deserialize_value(s, (jl_value_t**)&li->sparam_vals);\n    jl_gc_wb(li, li->sparam_vals);\n    li->unspecialized_ducttape = NULL;\n    li->pure = read_int8(s->s);\n    li->inlineable = read_int8(s->s);\n    li->isva = read_int8(s->s);\n    li->nargs = read_int32(s->s);\n    li->constval = jl_deserialize_value(s, &li->constval);\n    if (li->constval) jl_gc_wb(li, li->constval);\n    li->fptr = NULL;\n    li->functionObjectsDecls.functionObject = NULL;\n    li->functionObjectsDecls.specFunctionObject = NULL;\n    li->inInference = 0;\n    li->inCompile = 0;\n    li->fptr = jl_deserialize_fptr(s);\n    int32_t cfunc_llvm, func_llvm;\n    func_llvm = read_int32(s->s);\n    cfunc_llvm = read_int32(s->s);\n    jl_delayed_fptrs(li, func_llvm, cfunc_llvm);\n    li->jlcall_api = read_int8(s->s);\n    li->compile_traced = 0;\n    return (jl_value_t*)li;\n}\n\nstatic jl_value_t *jl_deserialize_value_module(jl_serializer_state *s)\n{\n    int usetable = (s->mode != MODE_AST);\n    uintptr_t pos = backref_list.len;\n    if (usetable)\n        arraylist_push(&backref_list, NULL);\n    jl_sym_t *mname = (jl_sym_t*)jl_deserialize_value(s, NULL);\n    if (s->mode == MODE_MODULE) {\n        int ref_only = read_uint8(s->s);\n        if (ref_only) {\n            jl_value_t *m_ref = jl_get_global((jl_module_t*)jl_deserialize_value(s, NULL), mname);\n            if (usetable)\n                backref_list.items[pos] = m_ref;\n            return m_ref;\n        }\n    }\n    jl_module_t *m = jl_new_module(mname);\n    if (usetable)\n        backref_list.items[pos] = m;\n    m->parent = (jl_module_t*)jl_deserialize_value(s, (jl_value_t**)&m->parent);\n    jl_gc_wb(m, m->parent);\n\n    while (1) {\n        jl_sym_t *name = (jl_sym_t*)jl_deserialize_value(s, NULL);\n        if (name == NULL)\n            break;\n        jl_binding_t *b = jl_get_binding_wr(m, name);\n        b->value = jl_deserialize_value(s, &b->value);\n        jl_gc_wb_buf(m, b, sizeof(jl_binding_t));\n        if (b->value != NULL) jl_gc_wb(m, b->value);\n        b->globalref = jl_deserialize_value(s, &b->globalref);\n        if (b->globalref != NULL) jl_gc_wb(m, b->globalref);\n        b->owner = (jl_module_t*)jl_deserialize_value(s, (jl_value_t**)&b->owner);\n        if (b->owner != NULL) jl_gc_wb(m, b->owner);\n        int8_t flags = read_int8(s->s);\n        b->deprecated = (flags>>3) & 1;\n        b->constp = (flags>>2) & 1;\n        b->exportp = (flags>>1) & 1;\n        b->imported = (flags) & 1;\n        jl_deserialize_gv(s, (jl_value_t*)b);\n    }\n    size_t i = m->usings.len;\n    size_t ni = read_int32(s->s);\n    arraylist_grow(&m->usings, ni);\n    ni += i;\n    while (i < ni) {\n        m->usings.items[i] = jl_deserialize_value(s, (jl_value_t**)&m->usings.items[i]);\n        i++;\n    }\n    m->istopmod = read_uint8(s->s);\n    m->uuid = read_uint64(s->s);\n    m->counter = read_int32(s->s);\n    return (jl_value_t*)m;\n}\n\nstatic jl_value_t *jl_deserialize_value_globalref(jl_serializer_state *s)\n{\n    int usetable = (s->mode != MODE_AST);\n    if (usetable) {\n        jl_value_t *v = jl_new_struct_uninit(jl_globalref_type);\n        arraylist_push(&backref_list, v);\n        jl_value_t **data = jl_data_ptr(v);\n        data[0] = jl_deserialize_value(s, &data[0]);\n        data[1] = jl_deserialize_value(s, &data[1]);\n        return v;\n    }\n    else {\n        jl_value_t *mod = jl_deserialize_value(s, NULL);\n        jl_value_t *var = jl_deserialize_value(s, NULL);\n        return jl_module_globalref((jl_module_t*)mod, (jl_sym_t*)var);\n    }\n}\n\nstatic jl_value_t *jl_deserialize_value_singleton(jl_serializer_state *s, jl_value_t **loc)\n{\n    int usetable = (s->mode != MODE_AST);\n    jl_value_t *v = (jl_value_t*)jl_gc_alloc(s->ptls, 0, NULL);\n    if (usetable) {\n        uintptr_t pos = backref_list.len;\n        arraylist_push(&backref_list, (void*)v);\n        if (s->mode == MODE_MODULE) {\n            // TODO: optimize the case where the value can easily be obtained\n            // from an external module (tag == 6) as dt->instance\n            assert(loc != NULL && loc != HT_NOTFOUND);\n            arraylist_push(&flagref_list, loc);\n            arraylist_push(&flagref_list, (void*)pos);\n        }\n    }\n    jl_datatype_t *dt = (jl_datatype_t*)jl_deserialize_value(s, (jl_value_t**)HT_NOTFOUND); // no loc, since if dt is replaced, then dt->instance would be also\n    jl_set_typeof(v, dt);\n    return v;\n}\n\nstatic jl_value_t *jl_deserialize_value_any(jl_serializer_state *s, jl_value_t *vtag, jl_value_t **loc)\n{\n    int usetable = (s->mode != MODE_AST);\n    int32_t sz = (vtag == (jl_value_t*)SmallDataType_tag ? read_uint8(s->s) : read_int32(s->s));\n    jl_value_t *v = jl_gc_alloc(s->ptls, sz, NULL);\n    jl_set_typeof(v, (void*)(intptr_t)0x50);\n    uintptr_t pos = backref_list.len;\n    if (usetable)\n        arraylist_push(&backref_list, v);\n    jl_datatype_t *dt = (jl_datatype_t*)jl_deserialize_value(s, &jl_astaggedvalue(v)->type);\n    if (dt == jl_datatype_type) {\n        return jl_deserialize_datatype(s, pos, loc);\n    }\n    assert(s->mode == MODE_AST || sz != 0 || loc);\n    if (s->mode == MODE_MODULE && dt == jl_typename_type) {\n        int ref_only = read_uint8(s->s);\n        if (ref_only) {\n            jl_module_t *m = (jl_module_t*)jl_deserialize_value(s, NULL);\n            jl_sym_t *sym = (jl_sym_t*)jl_deserialize_value(s, NULL);\n            jl_datatype_t *dt = (jl_datatype_t*)jl_get_global(m, sym);\n            assert(jl_is_datatype(dt));\n            jl_value_t *v = (jl_value_t*)dt->name;\n            if (usetable)\n                backref_list.items[pos] = v;\n            return v;\n        }\n    }\n    jl_set_typeof(v, dt);\n    size_t i, nf = jl_datatype_nfields(dt);\n    if (nf == 0 && jl_datatype_size(dt)>0) {\n        int nby = jl_datatype_size(dt);\n        ios_read(s->s, (char*)jl_data_ptr(v), nby);\n    }\n    else {\n        char *data = (char*)jl_data_ptr(v);\n        for (i = 0; i < nf; i++) {\n            if (jl_field_size(dt,i) > 0) {\n                if (jl_field_isptr(dt,i)) {\n                    jl_value_t **fld = (jl_value_t**)(data + jl_field_offset(dt, i));\n                    *fld = jl_deserialize_value(s, fld);\n                }\n                else {\n                    jl_set_nth_field(v, i, jl_deserialize_value(s, NULL));\n                }\n            }\n        }\n        if (s->mode == MODE_MODULE) {\n            if (dt == jl_typename_type) {\n                jl_typename_t *tn = (jl_typename_t*)v;\n                tn->cache = jl_emptysvec; // the cache is refilled later (tag 5)\n                tn->linearcache = jl_emptysvec; // the cache is refilled later (tag 5)\n            }\n        }\n    }\n    return v;\n}\n\nstatic jl_value_t *jl_deserialize_value_(jl_serializer_state *s, jl_value_t *vtag, jl_value_t **loc)\n{\n    int usetable = (s->mode != MODE_AST);\n    if (vtag == (jl_value_t*)jl_simplevector_type ||\n        vtag == (jl_value_t*)LongSvec_tag) {\n        return jl_deserialize_value_svec(s, vtag);\n    }\n    else if (vtag == (jl_value_t*)CommonSym_tag) {\n        return deser_symbols[read_uint8(s->s)];\n    }\n    else if (vtag == (jl_value_t*)jl_symbol_type ||\n             vtag == (jl_value_t*)LongSymbol_tag) {\n        return jl_deserialize_value_symbol(s, vtag);\n    }\n    else if (vtag == (jl_value_t*)jl_ssavalue_type) {\n        jl_value_t *v = jl_box_ssavalue(read_uint16(s->s));\n        if (usetable)\n            arraylist_push(&backref_list, v);\n        return v;\n    }\n    else if (vtag == (jl_value_t*)jl_slotnumber_type) {\n        jl_value_t *v = jl_box_slotnumber(read_uint16(s->s));\n        if (usetable)\n            arraylist_push(&backref_list, v);\n        return v;\n    }\n    else if (vtag == (jl_value_t*)jl_array_type ||\n             vtag == (jl_value_t*)Array1d_tag) {\n        return jl_deserialize_value_array(s, vtag);\n    }\n    else if (vtag == (jl_value_t*)jl_expr_type ||\n             vtag == (jl_value_t*)LongExpr_tag) {\n        return jl_deserialize_value_expr(s, vtag);\n    }\n    else if (vtag == (jl_value_t*)jl_tvar_type) {\n        jl_tvar_t *tv = (jl_tvar_t*)jl_gc_alloc(s->ptls, sizeof(jl_tvar_t),\n                                                jl_tvar_type);\n        if (usetable)\n            arraylist_push(&backref_list, tv);\n        tv->name = (jl_sym_t*)jl_deserialize_value(s, NULL);\n        jl_gc_wb(tv, tv->name);\n        tv->lb = jl_deserialize_value(s, &tv->lb);\n        jl_gc_wb(tv, tv->lb);\n        tv->ub = jl_deserialize_value(s, &tv->ub);\n        jl_gc_wb(tv, tv->ub);\n        tv->bound = read_int8(s->s);\n        return (jl_value_t*)tv;\n    }\n    else if (vtag == (jl_value_t*)jl_method_type) {\n        return jl_deserialize_value_method(s, loc);\n    }\n    else if (vtag == (jl_value_t*)jl_lambda_info_type) {\n        return jl_deserialize_value_lambda_info(s, loc);\n    }\n    else if (vtag == (jl_value_t*)jl_module_type) {\n        return jl_deserialize_value_module(s);\n    }\n    else if (vtag == (jl_value_t*)SmallInt64_tag) {\n        jl_value_t *v = jl_box_int64(read_int32(s->s));\n        if (usetable)\n            arraylist_push(&backref_list, v);\n        return v;\n    }\n    else if (vtag == (jl_value_t*)Int32_tag) {\n        jl_value_t *v = jl_box_int32(read_int32(s->s));\n        if (usetable)\n            arraylist_push(&backref_list, v);\n        return v;\n    }\n    else if (vtag == (jl_value_t*)NearbyGlobal_tag) {\n        assert(s->tree_enclosing_module != NULL);\n        jl_value_t *sym = jl_deserialize_value(s, NULL);\n        return jl_module_globalref(s->tree_enclosing_module, (jl_sym_t*)sym);\n    }\n    else if (vtag == (jl_value_t*)jl_globalref_type) {\n        return jl_deserialize_value_globalref(s);\n    }\n    else if (vtag == (jl_value_t*)Singleton_tag) {\n        return jl_deserialize_value_singleton(s, loc);\n    }\n    else {\n        assert(vtag == (jl_value_t*)jl_datatype_type || vtag == (jl_value_t*)SmallDataType_tag);\n        return jl_deserialize_value_any(s, vtag, loc);\n    }\n}\n\ntypedef struct _linkedlist_t {\n    struct _linkedlist_t *next;\n    struct {\n        jl_method_t *meth;\n        jl_tupletype_t *simpletype;\n    } def[100];\n    size_t count;\n} linkedlist_t;\n\nstatic void jl_deserialize_methods_from_mod(jl_serializer_state *s, linkedlist_t *list)\n{\n    list->count = 0;\n    list->next = NULL;\n    while (1) {\n        if (list->count == sizeof(list->def) / sizeof(list->def[0])) {\n            list->next = (linkedlist_t*)malloc(sizeof(linkedlist_t));\n            list = list->next;\n            list->count = 0;\n            list->next = NULL;\n        }\n        // using a linked list so that we can take these addresses\n        // and have them remain constant (arraylist reallocates)\n        jl_value_t **loc_meth = (jl_value_t**)&list->def[list->count].meth;\n        jl_value_t **loc_styp = (jl_value_t**)&list->def[list->count].simpletype;\n        *loc_meth = jl_deserialize_value(s, loc_meth);\n        if (*loc_meth == NULL)\n            return;\n        *loc_styp = jl_deserialize_value(s, loc_styp);\n        list->count++;\n    }\n}\n\nstatic void jl_insert_methods(linkedlist_t *list)\n{\n    while (list) {\n        size_t i;\n        for (i = 0; i < list->count; i++) {\n            jl_method_t *meth = list->def[i].meth;\n            jl_datatype_t *gf = jl_first_argument_datatype((jl_value_t*)meth->sig);\n            assert(jl_is_datatype(gf) && gf->name->mt);\n            jl_method_table_insert(gf->name->mt, meth, list->def[i].simpletype);\n        }\n        list = list->next;\n    }\n}\n\nstatic void free_linkedlist(linkedlist_t *list)\n{\n    while (list) {\n        linkedlist_t *prev = list;\n        list = list->next;\n        free(prev);\n    }\n}\n\nstatic jl_value_t *read_verify_mod_list(ios_t *s)\n{\n    if (!jl_main_module->uuid) {\n        return jl_get_exceptionf(jl_errorexception_type,\n                \"Main module uuid state is invalid for module deserialization.\");\n    }\n    while (1) {\n        size_t len = read_int32(s);\n        if (len == 0)\n            return NULL;\n        char *name = (char*)alloca(len+1);\n        ios_read(s, name, len);\n        name[len] = '\\0';\n        uint64_t uuid = read_uint64(s);\n        jl_sym_t *sym = jl_symbol(name);\n        jl_module_t *m = NULL;\n        if (jl_binding_resolved_p(jl_main_module, sym))\n            m = (jl_module_t*)jl_get_global(jl_main_module, sym);\n        if (!m) {\n            static jl_value_t *require_func = NULL;\n            if (!require_func)\n                require_func = jl_get_global(jl_base_module, jl_symbol(\"require\"));\n            jl_value_t *reqargs[2] = {require_func, (jl_value_t*)sym};\n            JL_TRY {\n                jl_apply(reqargs, 2);\n            }\n            JL_CATCH {\n                ios_close(s);\n                jl_rethrow();\n            }\n            m = (jl_module_t*)jl_get_global(jl_main_module, sym);\n        }\n        if (!m) {\n            return jl_get_exceptionf(jl_errorexception_type,\n                    \"Requiring \\\"%s\\\" did not define a corresponding module.\", name);\n        }\n        if (!jl_is_module(m)) {\n            ios_close(s);\n            return jl_get_exceptionf(jl_errorexception_type,\n                \"Invalid module path (%s does not name a module).\", name);\n        }\n        if (m->uuid != uuid) {\n            return jl_get_exceptionf(jl_errorexception_type,\n                \"Module %s uuid did not match cache file.\", name);\n        }\n    }\n}\n\nstatic int readstr_verify(ios_t *s, const char *str)\n{\n    size_t i, len = strlen(str);\n    for (i = 0; i < len; ++i)\n        if ((char)read_uint8(s) != str[i])\n            return 0;\n    return 1;\n}\n\nJL_DLLEXPORT int jl_read_verify_header(ios_t *s)\n{\n    uint16_t bom;\n    return (readstr_verify(s, JI_MAGIC) &&\n            read_uint16(s) == JI_FORMAT_VERSION &&\n            ios_read(s, (char *) &bom, 2) == 2 && bom == BOM &&\n            read_uint8(s) == sizeof(void*) &&\n            readstr_verify(s, JL_BUILD_UNAME) && !read_uint8(s) &&\n            readstr_verify(s, JL_BUILD_ARCH) && !read_uint8(s) &&\n            readstr_verify(s, JULIA_VERSION_STRING) && !read_uint8(s) &&\n            readstr_verify(s, jl_git_branch()) && !read_uint8(s) &&\n            readstr_verify(s, jl_git_commit()) && !read_uint8(s));\n}\n\nstatic void jl_finalize_serializer(jl_serializer_state *s)\n{\n    size_t i, l;\n    // save module initialization order\n    if (jl_module_init_order != NULL) {\n        l = jl_array_len(jl_module_init_order);\n        for (i = 0; i < l; i++) {\n            // verify that all these modules were saved\n            assert(ptrhash_get(&backref_table, jl_array_ptr_ref(jl_module_init_order, i)) != HT_NOTFOUND);\n        }\n    }\n    jl_serialize_value(s, jl_module_init_order);\n\n    // record list of reinitialization functions\n    l = reinit_list.len;\n    for (i = 0; i < l; i += 2) {\n        write_int32(s->s, (int)((uintptr_t) reinit_list.items[i]));\n        write_int32(s->s, (int)((uintptr_t) reinit_list.items[i+1]));\n    }\n    write_int32(s->s, -1);\n}\n\nvoid jl_typemap_rehash(union jl_typemap_t ml, int8_t offs);\nstatic void jl_reinit_item(jl_value_t *v, int how, arraylist_t *tracee_list)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    JL_TRY {\n        switch (how) {\n            case 1: { // rehash ObjectIdDict\n                jl_array_t **a = (jl_array_t**)v;\n                // Assume *a don't need a write barrier\n                *a = jl_idtable_rehash(*a, jl_array_len(*a));\n                jl_gc_wb(v, *a);\n                break;\n            }\n            case 2: { // reinsert module v into parent (const)\n                jl_module_t *mod = (jl_module_t*)v;\n                jl_binding_t *b = jl_get_binding_wr(mod->parent, mod->name);\n                jl_declare_constant(b); // this can throw\n                if (b->value != NULL) {\n                    if (!jl_is_module(b->value)) {\n                        jl_errorf(\"Invalid redefinition of constant %s.\",\n                                  jl_symbol_name(mod->name)); // this also throws\n                    }\n                    if (jl_generating_output() && jl_options.incremental) {\n                        jl_errorf(\"Cannot replace module %s during incremental precompile.\", jl_symbol_name(mod->name));\n                    }\n                    jl_printf(JL_STDERR, \"WARNING: replacing module %s.\\n\",\n                              jl_symbol_name(mod->name));\n                }\n                b->value = v;\n                jl_gc_wb_binding(b, v);\n                break;\n            }\n            case 3: { // rehash MethodTable\n                jl_methtable_t *mt = (jl_methtable_t*)v;\n                jl_typemap_rehash(mt->defs, 0);\n                jl_typemap_rehash(mt->cache, (mt == jl_type_type->name->mt) ? 0 : 1);\n                if (tracee_list)\n                    arraylist_push(tracee_list, mt);\n                break;\n            }\n            case 4: { // rehash specializations tfunc\n                jl_method_t *m = (jl_method_t*)v;\n                jl_typemap_rehash(m->specializations, 0);\n                break;\n            }\n            default:\n                assert(0 && \"corrupt deserialization state\");\n                abort();\n        }\n    }\n    JL_CATCH {\n        jl_printf(JL_STDERR, \"WARNING: error while reinitializing value \");\n        jl_static_show(JL_STDERR, v);\n        jl_printf(JL_STDERR, \":\\n\");\n        jl_static_show(JL_STDERR, ptls->exception_in_transit);\n        jl_printf(JL_STDERR, \"\\n\");\n    }\n}\n\nstatic jl_array_t *jl_finalize_deserializer(jl_serializer_state *s, arraylist_t *tracee_list)\n{\n    jl_array_t *init_order = (jl_array_t*)jl_deserialize_value(s, NULL);\n\n    // run reinitialization functions\n    int pos = read_int32(s->s);\n    while (pos != -1) {\n        jl_reinit_item((jl_value_t*)backref_list.items[pos], read_int32(s->s), tracee_list);\n        pos = read_int32(s->s);\n    }\n    return init_order;\n}\n\nstatic void jl_init_restored_modules(jl_array_t *init_order)\n{\n    if (!init_order)\n        return;\n    int i, l = jl_array_len(init_order);\n    for (i = 0; i < l; i++) {\n        jl_value_t *mod = jl_array_ptr_ref(init_order, i);\n        if (!jl_generating_output() || jl_options.incremental) {\n            jl_module_run_initializer((jl_module_t*)mod);\n        }\n        else {\n            if (jl_module_init_order == NULL)\n                jl_module_init_order = jl_alloc_vec_any(0);\n            jl_array_ptr_1d_push(jl_module_init_order, mod);\n        }\n    }\n}\n\n\n// --- entry points ---\n\nstatic void jl_save_system_image_to_stream(ios_t *f)\n{\n    jl_gc_collect(1); // full\n    jl_gc_collect(0); // incremental (sweep finalizers)\n    JL_TIMING(SYSIMG_DUMP);\n    int en = jl_gc_enable(0);\n    htable_reset(&backref_table, 250000);\n    arraylist_new(&reinit_list, 0);\n    backref_table_numel = 0;\n    jl_serializer_state s = {\n        f, MODE_SYSTEM_IMAGE,\n        NULL, NULL,\n        jl_get_ptls_states()\n    };\n\n    // orphan old Base module if present\n    jl_base_module = (jl_module_t*)jl_get_global(jl_main_module, jl_symbol(\"Base\"));\n\n    // empty!(Core.ARGS)\n    if (jl_core_module != NULL) {\n        jl_array_t *args = (jl_array_t*)jl_get_global(jl_core_module, jl_symbol(\"ARGS\"));\n        if (args != NULL) {\n            jl_array_del_end(args, jl_array_len(args));\n        }\n    }\n\n    jl_idtable_type = jl_base_module ? jl_get_global(jl_base_module, jl_symbol(\"ObjectIdDict\")) : NULL;\n\n    jl_serialize_value(&s, jl_main_module);\n    jl_serialize_value(&s, jl_top_module);\n    jl_serialize_value(&s, jl_typeinf_func);\n    jl_serialize_value(&s, jl_type_type->name->mt);\n\n    intptr_t i;\n    for (i = 0; i < builtin_types.len; i++) {\n        jl_serialize_value(&s, ((jl_datatype_t*)builtin_types.items[i])->name->cache);\n        jl_serialize_value(&s, ((jl_datatype_t*)builtin_types.items[i])->name->linearcache);\n    }\n\n    // ensure everything in deser_tag is reassociated with its GlobalValue\n    for (i = 2; i < 255; i++) {\n        jl_serialize_gv(&s, deser_tag[i]);\n    }\n\n    jl_serialize_globalvals(&s);\n    jl_serialize_gv_others(&s); // serialize things that might not have visible gc roots roots with GlobalValue references\n\n    write_int32(f, jl_get_t_uid_ctr());\n    write_int32(f, jl_get_gs_ctr());\n    jl_finalize_serializer(&s); // done with f and s\n\n    htable_reset(&backref_table, 0);\n    arraylist_free(&reinit_list);\n\n    jl_gc_enable(en);\n}\n\nJL_DLLEXPORT void jl_save_system_image(const char *fname)\n{\n    ios_t f;\n    if (ios_file(&f, fname, 1, 1, 1, 1) == NULL) {\n        jl_errorf(\"cannot open system image file \\\"%s\\\" for writing\", fname);\n    }\n    JL_SIGATOMIC_BEGIN();\n    jl_save_system_image_to_stream(&f);\n    ios_close(&f);\n    JL_SIGATOMIC_END();\n}\n\nJL_DLLEXPORT ios_t *jl_create_system_image(void)\n{\n    ios_t *f = (ios_t*)malloc(sizeof(ios_t));\n    ios_mem(f, 1000000);\n    jl_save_system_image_to_stream(f);\n    return f;\n}\n\nextern jl_function_t *jl_typeinf_func;\nextern int jl_boot_file_loaded;\nextern void jl_get_builtins(void);\nextern void jl_get_builtin_hooks(void);\nextern void jl_get_system_hooks(void);\n\n// Takes in a path of the form \"usr/lib/julia/sys.{ji,so}\", as passed to jl_restore_system_image()\nJL_DLLEXPORT void jl_preload_sysimg_so(const char *fname)\n{\n    // If passed NULL, don't even bother\n    if (!fname)\n        return;\n\n    // First, get \"sys\" from \"sys.ji\"\n    char *fname_shlib = (char*)alloca(strlen(fname)+1);\n    strcpy(fname_shlib, fname);\n    char *fname_shlib_dot = strrchr(fname_shlib, '.');\n    if (fname_shlib_dot != NULL) {\n        if (!strcmp(fname_shlib_dot, \".ji\"))\n            return;  // .ji extension => load .ji file only\n        *fname_shlib_dot = 0;\n    }\n\n    // Get handle to sys.so\n    jl_sysimg_handle = jl_load_dynamic_library_e(fname_shlib, JL_RTLD_LOCAL | JL_RTLD_NOW);\n\n    // set cpu target if unspecified by user and available from sysimg\n    // otherwise default to native.\n    if (jl_sysimg_handle && jl_options.cpu_target == NULL)\n        jl_options.cpu_target = (const char *)jl_dlsym(jl_sysimg_handle, \"jl_sysimg_cpu_target\");\n}\n\nstatic void jl_restore_system_image_from_stream(ios_t *f)\n{\n    JL_TIMING(SYSIMG_LOAD);\n    jl_ptls_t ptls = jl_get_ptls_states();\n    int en = jl_gc_enable(0);\n    arraylist_new(&backref_list, 250000);\n    jl_serializer_state s = {\n        f, MODE_SYSTEM_IMAGE,\n        NULL, NULL,\n        jl_get_ptls_states()\n    };\n\n    jl_main_module = (jl_module_t*)jl_deserialize_value(&s, NULL);\n    jl_top_module = (jl_module_t*)jl_deserialize_value(&s, NULL);\n    jl_internal_main_module = jl_main_module;\n    jl_typeinf_func = (jl_function_t*)jl_deserialize_value(&s, NULL);\n    jl_type_type_mt = (jl_methtable_t*)jl_deserialize_value(&s, NULL);\n    jl_type_type->name->mt = jl_typector_type->name->mt = jl_uniontype_type->name->mt = jl_datatype_type->name->mt =\n        jl_type_type_mt;\n\n    intptr_t i;\n    for(i=0; i < builtin_types.len; i++) {\n        jl_typename_t *tn = ((jl_datatype_t*)builtin_types.items[i])->name;\n        tn->cache = (jl_svec_t*)jl_deserialize_value(&s, NULL); jl_gc_wb(tn, tn->cache);\n        tn->linearcache = (jl_svec_t*)jl_deserialize_value(&s, NULL); jl_gc_wb(tn, tn->linearcache);\n        jl_resort_type_cache(tn->cache);\n    }\n\n    jl_core_module = (jl_module_t*)jl_get_global(jl_main_module,\n                                                 jl_symbol(\"Core\"));\n    jl_base_module = (jl_module_t*)jl_get_global(jl_main_module,\n                                                 jl_symbol(\"Base\"));\n    ptls->current_module = jl_base_module; // run start_image in Base\n\n    // ensure everything in deser_tag is reassociated with its GlobalValue\n    for (i = 2; i < 255; i++) {\n        jl_deserialize_gv(&s, deser_tag[i]);\n    }\n    jl_deserialize_globalvals(&s);\n    jl_deserialize_gv_others(&s);\n\n    int uid_ctr = read_int32(f);\n    int gs_ctr = read_int32(f);\n    jl_module_init_order = jl_finalize_deserializer(&s, NULL); // done with s and f\n\n    jl_set_t_uid_ctr(uid_ctr);\n    jl_set_gs_ctr(gs_ctr);\n\n    jl_get_builtins();\n    jl_get_builtin_hooks();\n    if (jl_base_module) {\n        jl_get_system_hooks();\n    }\n    jl_boot_file_loaded = 1;\n    jl_init_box_caches();\n\n    //jl_printf(JL_STDERR, \"backref_list.len = %d\\n\", backref_list.len);\n    arraylist_free(&backref_list);\n\n    jl_gc_reset_alloc_count();\n    jl_gc_enable(en);\n    jl_update_all_fptrs();\n}\n\nJL_DLLEXPORT void jl_restore_system_image(const char *fname)\n{\n    char *dot = (char*) strrchr(fname, '.');\n    int is_ji = (dot && !strcmp(dot, \".ji\"));\n\n    if (!is_ji) {\n        int err = jl_load_sysimg_so();\n        if (err != 0) {\n            if (jl_sysimg_handle == 0)\n                jl_errorf(\"System image file \\\"%s\\\" not found.\", fname);\n            jl_errorf(\"Library \\\"%s\\\" does not contain a valid system image.\", fname);\n        }\n    }\n    else {\n        ios_t f;\n        if (ios_file(&f, fname, 1, 0, 0, 0) == NULL)\n            jl_errorf(\"System image file \\\"%s\\\" not found.\", fname);\n        JL_SIGATOMIC_BEGIN();\n        jl_restore_system_image_from_stream(&f);\n        ios_close(&f);\n        JL_SIGATOMIC_END();\n    }\n}\n\nJL_DLLEXPORT void jl_restore_system_image_data(const char *buf, size_t len)\n{\n    ios_t f;\n    JL_SIGATOMIC_BEGIN();\n    ios_static_buffer(&f, (char*)buf, len);\n    jl_restore_system_image_from_stream(&f);\n    ios_close(&f);\n    JL_SIGATOMIC_END();\n}\n\nJL_DLLEXPORT jl_array_t *jl_compress_ast(jl_lambda_info_t *li, jl_array_t *ast)\n{\n    JL_TIMING(AST_COMPRESS);\n    JL_LOCK(&li->def->writelock); // protect the roots array (Might GC)\n    assert(jl_is_lambda_info(li));\n    assert(jl_is_array(ast));\n    ios_t dest;\n    ios_mem(&dest, 0);\n    int en = jl_gc_enable(0); // Might GC\n\n    if (li->def->roots == NULL) {\n        li->def->roots = jl_alloc_vec_any(0);\n        jl_gc_wb(li->def, li->def->roots);\n    }\n    jl_serializer_state s = {\n        &dest, MODE_AST,\n        li->def->roots, li->def->module,\n        jl_get_ptls_states()\n    };\n    size_t i, nstmts = jl_array_len(ast);\n    assert(nstmts < INT32_MAX);\n    write_int32(&dest, nstmts);\n    for (i = 0; i < nstmts; i++) {\n        jl_serialize_value(&s, jl_array_ptr_ref(ast, i));\n    }\n\n    //jl_printf(JL_STDERR, \"%d bytes, %d values\\n\", dest.size, vals->length);\n\n    jl_array_t *v = jl_takebuf_array(&dest);\n    if (jl_array_len(li->def->roots) == 0) {\n        li->def->roots = NULL;\n    }\n    JL_GC_PUSH1(&v);\n    jl_gc_enable(en);\n    JL_UNLOCK(&li->def->writelock); // Might GC\n    JL_GC_POP();\n    return v;\n}\n\nJL_DLLEXPORT jl_array_t *jl_uncompress_ast(jl_lambda_info_t *li, jl_array_t *data)\n{\n    JL_TIMING(AST_UNCOMPRESS);\n    JL_LOCK(&li->def->writelock); // protect the roots array (Might GC)\n    assert(jl_is_lambda_info(li));\n    assert(jl_is_array(data));\n    jl_array_t *bytes = (jl_array_t*)data;\n    ios_t src;\n    ios_mem(&src, 0);\n    ios_setbuf(&src, (char*)bytes->data, jl_array_len(bytes), 0);\n    src.size = jl_array_len(bytes);\n    int en = jl_gc_enable(0); // Might GC\n    jl_serializer_state s = {\n        &src, MODE_AST,\n        li->def->roots, li->def->module,\n        jl_get_ptls_states()\n    };\n\n    size_t i, nstmts = read_int32(&src);\n    jl_array_t *ast = jl_alloc_vec_any(nstmts);\n    JL_GC_PUSH1(&ast);\n    for (i = 0; i < nstmts; i++) {\n        jl_array_ptr_set(ast, i, jl_deserialize_value(&s, NULL));\n    }\n    jl_gc_enable(en);\n    JL_UNLOCK(&li->def->writelock); // Might GC\n    JL_GC_POP();\n    return ast;\n}\n\nJL_DLLEXPORT int jl_save_incremental(const char *fname, jl_array_t *worklist)\n{\n    char *tmpfname = strcat(strcpy((char *) alloca(strlen(fname)+8), fname), \".XXXXXX\");\n    ios_t f;\n    if (ios_mkstemp(&f, tmpfname) == NULL) {\n        jl_printf(JL_STDERR, \"Cannot open cache file \\\"%s\\\" for writing.\\n\", tmpfname);\n        return 1;\n    }\n    serializer_worklist = worklist;\n    write_header(&f);\n    write_work_list(&f);\n    write_dependency_list(&f);\n    write_mod_list(&f); // this can return errors during deserialize,\n                        // best to keep it early (before any actual initialization)\n\n    arraylist_new(&reinit_list, 0);\n    htable_new(&backref_table, 5000);\n    ptrhash_put(&backref_table, jl_main_module, (char*)HT_NOTFOUND + 1);\n    backref_table_numel = 1;\n    jl_idtable_type = jl_base_module ? jl_get_global(jl_base_module, jl_symbol(\"ObjectIdDict\")) : NULL;\n\n    int en = jl_gc_enable(0);\n    jl_serializer_state s = {\n        &f, MODE_MODULE,\n        NULL, NULL,\n        jl_get_ptls_states()\n    };\n    jl_serialize_value(&s, worklist);\n    jl_serialize_lambdas_from_mod(&s, jl_main_module);\n    jl_serialize_value(&s, NULL); // signal end of lambdas\n    jl_finalize_serializer(&s); // done with f\n    serializer_worklist = NULL;\n\n    jl_gc_enable(en);\n    htable_reset(&backref_table, 0);\n    arraylist_free(&reinit_list);\n    ios_close(&f);\n\n    if (jl_fs_rename(tmpfname, fname) < 0) {\n        jl_printf(JL_STDERR, \"Cannot write cache file \\\"%s\\\".\\n\", fname);\n        return 1;\n    }\n\n    return 0;\n}\n\nstatic jl_datatype_t *jl_recache_type(jl_datatype_t *dt, size_t start, jl_value_t *v)\n{\n    if (v == NULL)\n        v = dt->instance; // the instance before unique'ing\n    jl_svec_t *tt = dt->parameters;\n    if (dt->uid == 0 || dt->uid == -1) {\n        // recache all type parameters\n        size_t i, l = jl_svec_len(tt);\n        for (i = 0; i < l; i++) {\n            jl_datatype_t *p = (jl_datatype_t*)jl_svecref(tt, i);\n            if (jl_is_datatype(p)) {\n                if (p->uid == -1 || p->uid == 0) {\n                    jl_datatype_t *cachep = jl_recache_type(p, start, NULL);\n                    if (p != cachep) {\n                        assert(jl_types_equal((jl_value_t*)p, (jl_value_t*)cachep));\n                        jl_svecset(tt, i, cachep);\n                    }\n                }\n            }\n            else {\n                jl_datatype_t *tp = (jl_datatype_t*)jl_typeof(p);\n                assert(tp->uid != 0);\n                if (tp->uid == -1) {\n                    tp = jl_recache_type(tp, start, NULL);\n                }\n                if (tp->instance && (jl_value_t*)p != tp->instance)\n                    jl_svecset(tt, i, tp->instance);\n            }\n        }\n    }\n\n    jl_datatype_t *t; // the type after unique'ing\n    if (dt->uid == 0) {\n        return dt;\n    }\n    else if (dt->uid == -1) {\n        if (jl_svec_len(tt) == 0) { // jl_cache_type doesn't work if length(parameters) == 0\n            dt->uid = jl_assign_type_uid();\n            t = dt;\n        }\n        else {\n            dt->uid = 0;\n            t = (jl_datatype_t*)jl_cache_type_(dt);\n            assert(jl_types_equal((jl_value_t*)t, (jl_value_t*)dt));\n        }\n    }\n    else {\n        t = dt;\n    }\n    assert(t->uid != 0);\n    // delete / replace any other usages of this type in the backref list\n    // with the newly constructed object\n    size_t i = start;\n    while (i < flagref_list.len) {\n        jl_value_t **loc = (jl_value_t**)flagref_list.items[i + 0];\n        int offs = (int)(intptr_t)flagref_list.items[i + 1];\n        jl_value_t *o = loc ? *loc : (jl_value_t*)backref_list.items[offs];\n        if ((jl_value_t*)dt == o) {\n            if (t != dt) {\n                if (loc)\n                    *loc = (jl_value_t*)t;\n                if (offs > 0)\n                    backref_list.items[offs] = t;\n            }\n        }\n        else if (v == o) {\n            if (t->instance != v) {\n                *loc = t->instance;\n                if (offs > 0)\n                    backref_list.items[offs] = t->instance;\n            }\n        }\n        else {\n            i += 2;\n            continue;\n        }\n        // delete this item from the flagref list, so it won't be re-encountered later\n        flagref_list.len -= 2;\n        if (i >= flagref_list.len)\n            break;\n        flagref_list.items[i + 0] = flagref_list.items[flagref_list.len + 0];\n        flagref_list.items[i + 1] = flagref_list.items[flagref_list.len + 1];\n    }\n    return t;\n}\n\nstatic void jl_recache_types(void)\n{\n    size_t i = 0;\n    while (i < flagref_list.len) {\n        jl_value_t **loc = (jl_value_t**)flagref_list.items[i + 0];\n        int offs = (int)(intptr_t)flagref_list.items[i + 1];\n        jl_value_t *o = loc ? *loc : (jl_value_t*)backref_list.items[offs];\n        if (jl_is_method(o) || jl_is_lambda_info(o)) {\n            i += 2;\n        }\n        else {\n            jl_value_t *v;\n            jl_datatype_t *dt, *t;\n            if (jl_is_datatype(o)) {\n                dt = (jl_datatype_t*)o;\n                v = dt->instance;\n                assert(dt->uid == -1);\n                t = jl_recache_type(dt, i + 2, NULL);\n            }\n            else {\n                dt = (jl_datatype_t*)jl_typeof(o);\n                v = o;\n                assert(dt->instance);\n                t = jl_recache_type(dt, i + 2, v);\n            }\n            assert(dt);\n            if (t != dt) {\n                assert(!type_in_worklist(t));\n                jl_set_typeof(dt, (void*)(intptr_t)0x10); // invalidate the old datatype to help catch errors\n                if ((jl_value_t*)dt == o) {\n                    if (loc)\n                        *loc = (jl_value_t*)t;\n                    if (offs > 0)\n                        backref_list.items[offs] = t;\n                }\n            }\n            if (t->instance != v) {\n                jl_set_typeof(v, (void*)(intptr_t)0x20); // invalidate the old value to help catch errors\n                if (v == o) {\n                    *loc = t->instance;\n                    if (offs > 0)\n                        backref_list.items[offs] = t->instance;\n                }\n            }\n            // delete this item from the flagref list, so it won't be re-encountered later\n            flagref_list.len -= 2;\n            if (i >= flagref_list.len)\n                break;\n            flagref_list.items[i + 0] = flagref_list.items[flagref_list.len + 0];\n            flagref_list.items[i + 1] = flagref_list.items[flagref_list.len + 1];\n        }\n    }\n}\n\nstatic void jl_update_backref_list(jl_value_t *old, jl_value_t *_new, size_t start)\n{\n    // update the backref list\n    size_t i = start;\n    while (i < flagref_list.len) {\n        jl_value_t **loc = (jl_value_t**)flagref_list.items[i + 0];\n        int offs = (int)(intptr_t)flagref_list.items[i + 1];\n        jl_value_t *v = loc ? *loc : (jl_value_t*)backref_list.items[offs];\n        if ((jl_value_t*)v == old) { // same item, update this entry\n            if (loc)\n                *loc = (jl_value_t*)_new;\n            if (offs > 0)\n                backref_list.items[offs] = _new;\n            // delete this item from the flagref list, so it won't be re-encountered later\n            flagref_list.len -= 2;\n            if (i >= flagref_list.len)\n                break;\n            flagref_list.items[i + 0] = flagref_list.items[flagref_list.len + 0];\n            flagref_list.items[i + 1] = flagref_list.items[flagref_list.len + 1];\n        }\n        else {\n            i += 2;\n        }\n    }\n}\n\njl_method_t *jl_recache_method(jl_method_t *m, size_t start)\n{\n    jl_datatype_t *sig = m->sig;\n    jl_datatype_t *ftype = jl_first_argument_datatype((jl_value_t*)sig);\n    jl_methtable_t *mt = ftype->name->mt;\n    jl_set_typeof(m, (void*)(intptr_t)0x30); // invalidate the old value to help catch errors\n    jl_method_t *_new = (jl_method_t*)jl_methtable_lookup(mt, sig);\n    assert(_new && jl_is_method(_new));\n    jl_update_backref_list((jl_value_t*)m, (jl_value_t*)_new, start);\n    return _new;\n}\n\njl_lambda_info_t *jl_recache_lambda_info(jl_lambda_info_t *li, size_t start)\n{\n    assert(jl_is_datatype(li->def));\n    jl_datatype_t *sig = (jl_datatype_t*)li->def;\n    jl_datatype_t *ftype = jl_first_argument_datatype((jl_value_t*)sig);\n    jl_methtable_t *mt = ftype->name->mt;\n    jl_method_t *m = (jl_method_t*)jl_methtable_lookup(mt, sig);\n    assert(m && jl_is_method(m));\n\n    // lookup the real LambdaInfo based on the placeholder specTypes\n    int inferred = li->inferred;\n    jl_datatype_t *argtypes = li->specTypes;\n    jl_value_t *rettype = li->rettype;\n    jl_set_typeof(li, (void*)(intptr_t)0x40); // invalidate the old value to help catch errors\n    jl_svec_t *env = jl_emptysvec;\n    jl_value_t *ti = jl_type_intersection_matching((jl_value_t*)m->sig, (jl_value_t*)argtypes, &env, m->tvars);\n    //assert(ti != jl_bottom_type); (void)ti;\n    if (ti == jl_bottom_type)\n        env = jl_emptysvec; // the intersection may fail now if the type system had made an incorrect subtype env in the past\n    jl_lambda_info_t *_new = jl_specializations_get_linfo(m, argtypes, env, 0);\n    assert(_new);\n    // if it can be inferred but isn't, encourage codegen to infer it\n    if (inferred && !_new->inferred) {\n        jl_set_lambda_code_null(_new);\n        _new->inferred = 1;\n        _new->rettype = rettype;\n        jl_gc_wb(_new, _new->rettype);\n    }\n    jl_update_backref_list((jl_value_t*)li, (jl_value_t*)_new, start);\n    return _new;\n}\n\nstatic void jl_recache_other(void)\n{\n    size_t i = 0;\n    while (i < flagref_list.len) {\n        jl_value_t **loc = (jl_value_t**)flagref_list.items[i + 0];\n        int offs = (int)(intptr_t)flagref_list.items[i + 1];\n        jl_value_t *_new, *o = loc ? *loc : (jl_value_t*)backref_list.items[offs];\n        i += 2;\n        if (jl_is_method(o)) {\n            // lookup the real Method based on the placeholder sig\n            _new = (jl_value_t*)jl_recache_method((jl_method_t*)o, i);\n        }\n        else if (jl_is_lambda_info(o)) {\n            // lookup the real MethodInstance based on the placeholder specTypes\n            _new = (jl_value_t*)jl_recache_lambda_info((jl_lambda_info_t*)o, i);\n        }\n        else {\n            assert(0 && \"unexpected type encountered in flagref list\");\n            abort();\n        }\n        if (loc)\n            *loc = _new;\n        if (offs > 0)\n            backref_list.items[offs] = _new;\n    }\n}\n\nextern tracer_cb jl_newmeth_tracer;\nstatic int trace_method(jl_typemap_entry_t *entry, void *closure)\n{\n    jl_call_tracer(jl_newmeth_tracer, (jl_value_t*)entry->func.method);\n    return 1;\n}\n\nstatic jl_value_t *_jl_restore_incremental(ios_t *f)\n{\n    if (ios_eof(f) || !jl_read_verify_header(f)) {\n        ios_close(f);\n        return jl_get_exceptionf(jl_errorexception_type,\n                \"Precompile file header verification checks failed.\");\n    }\n    { // skip past the mod list\n        size_t len;\n        while ((len = read_int32(f)))\n            ios_skip(f, len + sizeof(uint64_t));\n    }\n    { // skip past the dependency list\n        size_t deplen = read_uint64(f);\n        ios_skip(f, deplen);\n    }\n\n    // verify that the system state is valid\n    jl_value_t *verify_error = read_verify_mod_list(f);\n    if (verify_error) {\n        ios_close(f);\n        return verify_error;\n    }\n\n    // prepare to deserialize\n    arraylist_new(&backref_list, 4000);\n    arraylist_push(&backref_list, jl_main_module);\n    arraylist_new(&flagref_list, 0);\n\n    int en = jl_gc_enable(0);\n    jl_serializer_state s = {\n        f, MODE_MODULE,\n        NULL, NULL,\n        jl_get_ptls_states()\n    };\n    jl_array_t *restored = NULL;\n    jl_array_t *init_order = NULL;\n    restored = (jl_array_t*)jl_deserialize_value(&s, (jl_value_t**)&restored);\n    serializer_worklist = restored;\n\n    // get list of external generic functions\n    linkedlist_t external_methods;\n    jl_deserialize_methods_from_mod(&s, &external_methods);\n\n    arraylist_t *tracee_list = NULL;\n    if (jl_newmeth_tracer)\n        tracee_list = arraylist_new((arraylist_t*)malloc(sizeof(arraylist_t)), 0);\n\n    // at this point, the AST is fully reconstructed, but still completely disconnected\n    // now all of the interconnects will be created\n    jl_recache_types(); // make all of the types identities correct\n    jl_recache_other(); // make all of the other objects identities correct\n    init_order = jl_finalize_deserializer(&s, tracee_list); // done with f and s\n    jl_insert_methods(&external_methods); // hook up methods of external generic functions\n    free_linkedlist(external_methods.next);\n    serializer_worklist = NULL;\n\n    JL_GC_PUSH2(&init_order, &restored);\n    jl_gc_enable(en);\n    arraylist_free(&flagref_list);\n    arraylist_free(&backref_list);\n    ios_close(f);\n\n    if (tracee_list) {\n        jl_methtable_t *mt;\n        while ((mt = (jl_methtable_t*)arraylist_pop(tracee_list)) != NULL)\n            jl_typemap_visitor(mt->defs, trace_method, NULL);\n        arraylist_free(tracee_list);\n        free(tracee_list);\n    }\n    jl_init_restored_modules(init_order);\n    JL_GC_POP();\n\n    return (jl_value_t*)restored;\n}\n\nJL_DLLEXPORT jl_value_t *jl_restore_incremental_from_buf(const char *buf, size_t sz)\n{\n    ios_t f;\n    ios_static_buffer(&f, (char*)buf, sz);\n    return _jl_restore_incremental(&f);\n}\n\nJL_DLLEXPORT jl_value_t *jl_restore_incremental(const char *fname)\n{\n    ios_t f;\n    if (ios_file(&f, fname, 1, 0, 0, 0) == NULL) {\n        return jl_get_exceptionf(jl_errorexception_type,\n            \"Cache file \\\"%s\\\" not found.\\n\", fname);\n    }\n    return _jl_restore_incremental(&f);\n}\n\n// --- init ---\n\nvoid jl_init_serializer(void)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    htable_new(&ser_tag, 0);\n    htable_new(&common_symbol_tag, 0);\n    htable_new(&fptr_to_id, sizeof(id_to_fptrs)/sizeof(*id_to_fptrs));\n    htable_new(&backref_table, 0);\n\n    void *tags[] = { jl_symbol_type, jl_ssavalue_type, jl_datatype_type, jl_slotnumber_type,\n                     jl_simplevector_type, jl_array_type, jl_typedslot_type,\n                     jl_expr_type, (void*)LongSymbol_tag, (void*)LongSvec_tag,\n                     (void*)LongExpr_tag, (void*)LiteralVal_tag,\n                     (void*)SmallInt64_tag, (void*)SmallDataType_tag,\n                     (void*)Int32_tag, (void*)Array1d_tag, (void*)Singleton_tag,\n                     jl_module_type, jl_tvar_type, jl_lambda_info_type, jl_method_type,\n                     (void*)CommonSym_tag, (void*)NearbyGlobal_tag, jl_globalref_type,\n                     // everything above here represents a class of object rather than only a literal\n\n                     jl_emptysvec, jl_emptytuple, jl_false, jl_true, jl_nothing, jl_any_type,\n                     call_sym, invoke_sym, goto_ifnot_sym, return_sym, body_sym, line_sym,\n                     lambda_sym, jl_symbol(\"tuple\"), assign_sym,\n\n                     // empirical list of very common symbols\n                     #include \"common_symbols1.inc\"\n\n                     jl_box_int32(0), jl_box_int32(1), jl_box_int32(2),\n                     jl_box_int32(3), jl_box_int32(4), jl_box_int32(5),\n                     jl_box_int32(6), jl_box_int32(7), jl_box_int32(8),\n                     jl_box_int32(9), jl_box_int32(10), jl_box_int32(11),\n                     jl_box_int32(12), jl_box_int32(13), jl_box_int32(14),\n                     jl_box_int32(15), jl_box_int32(16), jl_box_int32(17),\n                     jl_box_int32(18), jl_box_int32(19), jl_box_int32(20),\n                     jl_box_int32(21), jl_box_int32(22), jl_box_int32(23),\n                     jl_box_int32(24), jl_box_int32(25), jl_box_int32(26),\n                     jl_box_int32(27), jl_box_int32(28), jl_box_int32(29),\n                     jl_box_int32(30), jl_box_int32(31), jl_box_int32(32),\n#ifndef _P64\n                     jl_box_int32(33), jl_box_int32(34), jl_box_int32(35),\n                     jl_box_int32(36), jl_box_int32(37), jl_box_int32(38),\n                     jl_box_int32(39), jl_box_int32(40), jl_box_int32(41),\n                     jl_box_int32(42), jl_box_int32(43),\n#endif\n                     jl_box_int64(0), jl_box_int64(1), jl_box_int64(2),\n                     jl_box_int64(3), jl_box_int64(4), jl_box_int64(5),\n                     jl_box_int64(6), jl_box_int64(7), jl_box_int64(8),\n                     jl_box_int64(9), jl_box_int64(10), jl_box_int64(11),\n                     jl_box_int64(12), jl_box_int64(13), jl_box_int64(14),\n                     jl_box_int64(15), jl_box_int64(16), jl_box_int64(17),\n                     jl_box_int64(18), jl_box_int64(19), jl_box_int64(20),\n                     jl_box_int64(21), jl_box_int64(22), jl_box_int64(23),\n                     jl_box_int64(24), jl_box_int64(25), jl_box_int64(26),\n                     jl_box_int64(27), jl_box_int64(28), jl_box_int64(29),\n                     jl_box_int64(30), jl_box_int64(31), jl_box_int64(32),\n#ifdef _P64\n                     jl_box_int64(33), jl_box_int64(34), jl_box_int64(35),\n                     jl_box_int64(36), jl_box_int64(37), jl_box_int64(38),\n                     jl_box_int64(39), jl_box_int64(40), jl_box_int64(41),\n                     jl_box_int64(42), jl_box_int64(43),\n#endif\n                     jl_labelnode_type, jl_linenumbernode_type,\n                     jl_gotonode_type, jl_quotenode_type,\n                     jl_type_type, jl_bottom_type, jl_ref_type, jl_pointer_type,\n                     jl_vararg_type, jl_abstractarray_type,\n                     jl_densearray_type, jl_void_type, jl_function_type,\n                     jl_typector_type, jl_typename_type, jl_builtin_type,\n                     jl_task_type, jl_uniontype_type, jl_typetype_type, jl_typetype_tvar,\n                     jl_ANY_flag, jl_array_any_type, jl_intrinsic_type, jl_abstractslot_type,\n                     jl_methtable_type, jl_typemap_level_type, jl_typemap_entry_type,\n                     jl_voidpointer_type, jl_newvarnode_type,\n                     jl_array_symbol_type, jl_anytuple_type, jl_tparam0(jl_anytuple_type),\n                     jl_typeof(jl_emptytuple), jl_array_uint8_type,\n                     jl_symbol_type->name, jl_ssavalue_type->name, jl_tuple_typename,\n                     jl_ref_type->name, jl_pointer_type->name, jl_simplevector_type->name,\n                     jl_datatype_type->name, jl_uniontype_type->name, jl_array_type->name,\n                     jl_expr_type->name, jl_typename_type->name, jl_type_type->name,\n                     jl_methtable_type->name, jl_typemap_level_type->name, jl_typemap_entry_type->name, jl_tvar_type->name,\n                     jl_abstractarray_type->name, jl_vararg_type->name,\n                     jl_densearray_type->name, jl_void_type->name, jl_lambda_info_type->name, jl_method_type->name,\n                     jl_module_type->name, jl_function_type->name, jl_typedslot_type->name,\n                     jl_abstractslot_type->name, jl_slotnumber_type->name,\n                     jl_typector_type->name, jl_intrinsic_type->name, jl_task_type->name,\n                     jl_labelnode_type->name, jl_linenumbernode_type->name, jl_builtin_type->name,\n                     jl_gotonode_type->name, jl_quotenode_type->name,\n                     jl_globalref_type->name,\n\n                     ptls->root_task,\n\n                     NULL };\n\n    // more common symbols, less common than those above. will get 2-byte encodings.\n    void *common_symbols[] = {\n        #include \"common_symbols2.inc\"\n        NULL\n    };\n\n    intptr_t i=2;\n    while (tags[i-2] != NULL) {\n        ptrhash_put(&ser_tag, tags[i-2], (void*)i);\n        deser_tag[i] = (jl_value_t*)tags[i-2];\n        i += 1;\n    }\n    assert(i <= Null_tag);\n    VALUE_TAGS = (intptr_t)ptrhash_get(&ser_tag, jl_emptysvec);\n\n    i=2;\n    while (id_to_fptrs[i] != NULL) {\n        ptrhash_put(&fptr_to_id, (void*)id_to_fptrs[i], (void*)i);\n        i += 1;\n    }\n\n    i=2;\n    while (common_symbols[i-2] != NULL) {\n        ptrhash_put(&common_symbol_tag, common_symbols[i-2], (void*)i);\n        deser_symbols[i] = (jl_value_t*)common_symbols[i-2];\n        i += 1;\n    }\n    assert(i <= 256);\n\n    arraylist_new(&builtin_types, 0);\n    arraylist_push(&builtin_types, jl_array_type);\n    arraylist_push(&builtin_types, jl_ref_type);\n    arraylist_push(&builtin_types, jl_pointer_type);\n    arraylist_push(&builtin_types, jl_type_type);\n    arraylist_push(&builtin_types, jl_abstractarray_type);\n    arraylist_push(&builtin_types, jl_densearray_type);\n    arraylist_push(&builtin_types, jl_tuple_type);\n    arraylist_push(&builtin_types, jl_vararg_type);\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/dlload.c": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <sys/stat.h>\n\n#include \"platform.h\"\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#ifdef _OS_WINDOWS_\n#include <windows.h>\n#include <direct.h>\n#else\n#include <unistd.h>\n#include <dlfcn.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// The empty extension at the beginning and the end is a trick to change\n// the order of the loop.\n#if defined(__APPLE__)\nstatic char const *const extensions[] = { \"\", \".dylib\", \"\" };\n#elif defined(_OS_WINDOWS_)\nstatic char const *const extensions[] = { \"\", \".dll\", \"\" };\nextern int needsSymRefreshModuleList;\n#else\nstatic char const *const extensions[] = { \"\", \".so\", \"\" };\n#endif\n#define N_EXTENSIONS (sizeof(extensions) / sizeof(char*) - 1)\n\nstatic int endswith_extension(const char *path)\n{\n    if (!path)\n        return 0;\n    size_t len = strlen(path);\n    // Skip the first one since it is empty\n    for (size_t i = 1;i < N_EXTENSIONS;i++) {\n        const char *ext = extensions[i];\n        size_t extlen = strlen(ext);\n        if (len >= extlen && memcmp(ext, path + len - extlen, extlen) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n#define PATHBUF 512\n\nextern char *julia_home;\n\n#define JL_RTLD(flags, FLAG) (flags & JL_RTLD_ ## FLAG ? RTLD_ ## FLAG : 0)\n\nstatic void JL_NORETURN jl_dlerror(const char *fmt, const char *sym)\n{\n#ifdef _OS_WINDOWS_\n    CHAR reason[256];\n    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n            NULL, GetLastError(),\n            MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),\n            reason, sizeof(reason) / sizeof(reason[0]), NULL);\n#else\n    const char *reason = dlerror();\n#endif\n    jl_errorf(fmt, sym, reason);\n}\n\nJL_DLLEXPORT void *jl_dlopen(const char *filename, unsigned flags)\n{\n#if defined(_OS_WINDOWS_)\n    needsSymRefreshModuleList = 1;\n    size_t len = MultiByteToWideChar(CP_UTF8, 0, filename, -1, NULL, 0);\n    if (!len) return NULL;\n    WCHAR *wfilename = (WCHAR*)alloca(len * sizeof(WCHAR));\n    if (!MultiByteToWideChar(CP_UTF8, 0, filename, -1, wfilename, len)) return NULL;\n    return LoadLibraryExW(wfilename, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n#else\n    dlerror(); /* Reset error status. */\n    return dlopen(filename,\n                  (flags & JL_RTLD_NOW ? RTLD_NOW : RTLD_LAZY)\n                  | JL_RTLD(flags, LOCAL)\n                  | JL_RTLD(flags, GLOBAL)\n#ifdef RTLD_NODELETE\n                  | JL_RTLD(flags, NODELETE)\n#endif\n#ifdef RTLD_NOLOAD\n                  | JL_RTLD(flags, NOLOAD)\n#endif\n#if defined(RTLD_DEEPBIND) && !defined(JL_ASAN_ENABLED)\n                  | JL_RTLD(flags, DEEPBIND)\n#endif\n#ifdef RTLD_FIRST\n                  | JL_RTLD(flags, FIRST)\n#endif\n                  );\n#endif\n}\n\nJL_DLLEXPORT int jl_dlclose(void *handle)\n{\n#ifdef _OS_WINDOWS_\n    if (!handle) return -1;\n    return FreeLibrary((HMODULE) handle);\n#else\n    dlerror(); /* Reset error status. */\n    if (!handle) return -1;\n    return dlclose(handle);\n#endif\n}\n\nstatic void *jl_load_dynamic_library_(const char *modname, unsigned flags, int throw_err)\n{\n    char path[PATHBUF];\n    int i;\n    uv_stat_t stbuf;\n    void *handle;\n    // This determines if we try the no-extension name first or last\n    // We want to make sure the last one we try has higher chance of being\n    // a real file since the error reported will otherwise be a unhelpful\n    // file not found error due to the extra or missing extension name.\n    int hasext = endswith_extension(modname);\n\n    /*\n      this branch returns handle of libjulia\n    */\n    if (modname == NULL) {\n#ifdef _OS_WINDOWS_\n        if (!GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n                                (LPCWSTR)(&jl_load_dynamic_library),\n                                (HMODULE*)&handle)) {\n            jl_error(\"could not load base module\");\n        }\n#else\n        handle = dlopen(NULL, RTLD_NOW);\n#endif\n        goto done;\n    }\n    /*\n      this branch shortcuts absolute paths\n    */\n#ifdef _OS_WINDOWS_\n    else if (modname[1] == ':') {\n#else\n    else if (modname[0] == '/') {\n#endif\n        handle = jl_dlopen(modname, flags);\n        if (handle)\n            goto done;\n        // bail out and show the error if file actually exists\n        if (jl_stat(modname, (char*)&stbuf) == 0)\n            goto notfound;\n    }\n    /*\n      this branch permutes all base paths in DL_LOAD_PATH with all extensions\n      note: skip when !jl_base_module to avoid UndefVarError(:DL_LOAD_PATH)\n    */\n    else if (jl_base_module != NULL) {\n        jl_array_t *DL_LOAD_PATH = (jl_array_t*)jl_get_global(jl_base_module, jl_symbol(\"DL_LOAD_PATH\"));\n        if (DL_LOAD_PATH != NULL) {\n            size_t j;\n            for (j = 0; j < jl_array_len(DL_LOAD_PATH); j++) {\n                char *dl_path = jl_string_data(jl_array_ptr_data(DL_LOAD_PATH)[j]);\n                size_t len = strlen(dl_path);\n                if (len == 0)\n                    continue;\n                for (i=0; i < N_EXTENSIONS; i++) {\n                    // Do the no-ext one last if hasext == 1\n                    const char *ext = extensions[i + hasext];\n                    path[0] = '\\0';\n                    if (dl_path[len-1] == PATHSEPSTRING[0])\n                        snprintf(path, PATHBUF, \"%s%s%s\", dl_path, modname, ext);\n                    else\n                        snprintf(path, PATHBUF, \"%s\" PATHSEPSTRING \"%s%s\", dl_path, modname, ext);\n                    handle = jl_dlopen(path, flags);\n                    if (handle)\n                        goto done;\n                    // bail out and show the error if file actually exists\n                    if (jl_stat(path, (char*)&stbuf) == 0)\n                        goto notfound;\n                }\n            }\n        }\n    }\n\n    // now fall back and look in default library paths, for all extensions\n    for(i=0; i < N_EXTENSIONS; i++) {\n        // Do the no-ext one last if hasext == 1\n        const char *ext = extensions[i + hasext];\n        path[0] = '\\0';\n        snprintf(path, PATHBUF, \"%s%s\", modname, ext);\n        handle = jl_dlopen(path, flags);\n        if (handle)\n            goto done;\n    }\n\n#if defined(__linux__) || defined(__FreeBSD__)\n    // check map of versioned libs from \"libX\" to full soname \"libX.so.ver\"\n    handle = jl_dlopen_soname(modname, strlen(modname), flags);\n    if (handle)\n        goto done;\n#endif\n\nnotfound:\n    if (throw_err)\n        jl_dlerror(\"could not load library \\\"%s\\\"\\n%s\", modname);\n    return NULL;\n\ndone:\n    return handle;\n}\n\nJL_DLLEXPORT void *jl_load_dynamic_library_e(const char *modname, unsigned flags)\n{\n    return jl_load_dynamic_library_(modname, flags, 0);\n}\n\nJL_DLLEXPORT void *jl_load_dynamic_library(const char *modname, unsigned flags)\n{\n    return jl_load_dynamic_library_(modname, flags, 1);\n}\n\nJL_DLLEXPORT void *jl_dlsym_e(void *handle, const char *symbol)\n{\n#ifdef _OS_WINDOWS_\n    void *ptr = GetProcAddress((HMODULE) handle, symbol);\n#else\n    dlerror(); /* Reset error status. */\n    void *ptr = dlsym(handle, symbol);\n#endif\n    return ptr;\n}\n\nJL_DLLEXPORT void *jl_dlsym(void *handle, const char *symbol)\n{\n    void *ptr = jl_dlsym_e(handle, symbol);\n    if (!ptr)\n        jl_dlerror(\"could not load symbol \\\"%s\\\":\\n%s\", symbol);\n    return ptr;\n}\n\n#ifdef _OS_WINDOWS_\n//Look for symbols in win32 libraries\nconst char *jl_dlfind_win32(const char *f_name)\n{\n    if (jl_dlsym_e(jl_exe_handle, f_name))\n        return (const char*)1;\n    if (jl_dlsym_e(jl_dl_handle, f_name))\n        return (const char*)2;\n    if (jl_dlsym_e(jl_kernel32_handle, f_name))\n        return \"kernel32\";\n    if (jl_dlsym_e(jl_ntdll_handle, f_name))\n        return \"ntdll\";\n    if (jl_dlsym_e(jl_crtdll_handle, f_name))\n#if defined(_MSC_VER)\n#if _MSC_VER == 1800\n        return \"msvcr120\";\n#else\n#error This version of MSVC has not been tested.\n#endif\n#else\n        return \"msvcrt\";\n#endif\n    if (jl_dlsym_e(jl_winsock_handle, f_name))\n        return \"ws2_32\";\n    // additional common libraries (libc?) could be added here, but in general,\n    // it is better to specify the library explicitly in the code. This exists\n    // mainly to ease compatibility with linux, and for libraries that don't\n    // have a name (julia.exe and libjulia.dll)\n    // We could also loop over all libraries that have been used so far, but, again,\n    // explicit is preferred over implicit\n    return NULL;\n    // oops, we didn't find it. NULL defaults to searching jl_RTLD_DEFAULT_handle,\n    // which defaults to jl_dl_handle, where we won't find it, and will throw the\n    // appropriate error.\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/debuginfo.cpp": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n#include \"platform.h\"\n\n#include \"llvm-version.h\"\n#include <llvm/ExecutionEngine/ExecutionEngine.h>\n#include <llvm/ExecutionEngine/JITEventListener.h>\n#include <llvm/DebugInfo/DIContext.h>\n#ifdef LLVM37\n#include <llvm/DebugInfo/DWARF/DWARFContext.h>\n#include <llvm/Object/SymbolSize.h>\n#endif\n#include <llvm/Support/MemoryBuffer.h>\n#include <llvm/IR/Function.h>\n#include <llvm/ADT/StringRef.h>\n#include <llvm/ADT/StringMap.h>\n#ifdef LLVM35\n#include <llvm/IR/DebugInfo.h>\n#else\n#include <llvm/DebugInfo.h>\n#endif\n#if defined(USE_MCJIT) || defined(USE_ORCJIT)\n#include <llvm/IR/DataLayout.h>\n#include <llvm/IR/Mangler.h>\n#ifndef LLVM36\n#include <llvm/ExecutionEngine/ObjectImage.h>\n#endif\n#include <llvm/ExecutionEngine/RuntimeDyld.h>\n#else\n#include <llvm/ExecutionEngine/JITMemoryManager.h>\n#endif\n#include <llvm/Object/MachO.h>\n#include <llvm/Object/COFF.h>\n#ifdef LLVM37\n#  include <llvm/Object/ELFObjectFile.h>\n#endif\n\n#if defined(USE_MCJIT) && !defined(LLVM36) && defined(_OS_DARWIN_)\n#include \"../deps/llvm-3.5.0/lib/ExecutionEngine/MCJIT/MCJIT.h\"\n#endif\n\nusing namespace llvm;\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"codegen_internal.h\"\n#ifdef _OS_LINUX_\n#  define UNW_LOCAL_ONLY\n#  include <libunwind.h>\n#  include <link.h>\n#endif\n\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <map>\n#include <vector>\n#include <set>\n#include <cstdio>\n#include <cassert>\n\n#if defined(LLVM35) && !defined(LLVM36)\nextern ExecutionEngine *jl_ExecutionEngine;\n#endif\n\n#ifdef USE_MCJIT\ntypedef object::SymbolRef SymRef;\n#endif\n\n// Any function that acquires this lock must be either a unmanaged thread\n// or in the GC safe region and must NOT allocate anything through the GC\n// while holding this lock.\n// Certain functions in this file might be called from an unmanaged thread\n// and cannot have any interaction with the julia runtime\nstatic uv_rwlock_t threadsafe;\n\nextern \"C\" void jl_init_debuginfo()\n{\n    uv_rwlock_init(&threadsafe);\n}\n\n// --- storing and accessing source location metadata ---\n\n#ifndef USE_MCJIT\nstruct FuncInfo {\n    const Function *func;\n    size_t lengthAdr;\n    std::vector<JITEvent_EmittedFunctionDetails::LineStart> lines;\n    jl_lambda_info_t *linfo;\n};\n#else\nstruct ObjectInfo {\n    const object::ObjectFile *object;\n    size_t SectionSize;\n    ptrdiff_t slide;\n#ifdef LLVM37\n    DIContext *context;\n#endif\n#if defined(_OS_DARWIN_) && !defined(LLVM37)\n    const char *name;\n#endif\n};\n#endif\n\n// Maintain a mapping of unrealized function names -> linfo objects\n// so that when we see it get emitted, we can add a link back to the linfo\n// that it came from (providing name, type signature, file info, etc.)\nstatic StringMap<jl_lambda_info_t*> linfo_in_flight;\nstatic std::string mangle(const std::string &Name, const DataLayout &DL)\n{\n#if defined(USE_MCJIT) || defined(USE_ORCJIT)\n    std::string MangledName;\n    {\n        raw_string_ostream MangledNameStream(MangledName);\n        Mangler::getNameWithPrefix(MangledNameStream, Name, DL);\n    }\n    return MangledName;\n#else\n    return Name;\n#endif\n}\nvoid jl_add_linfo_in_flight(StringRef name, jl_lambda_info_t *linfo, const DataLayout &DL)\n{\n    linfo_in_flight[mangle(name, DL)] = linfo;\n}\n\n#if defined(_OS_WINDOWS_)\nstatic void create_PRUNTIME_FUNCTION(uint8_t *Code, size_t Size, StringRef fnname,\n                                     uint8_t *Section, size_t Allocated, uint8_t *UnwindData)\n{\n    // GC safe\n    DWORD mod_size = 0;\n#if defined(_CPU_X86_64_)\n#if !defined(USE_MCJIT)\n    uint8_t *catchjmp = Section+Allocated;\n    UnwindData = (uint8_t*)(((uintptr_t)catchjmp+12+3)&~(uintptr_t)3);\n    if (!catchjmp[0]) {\n        catchjmp[0] = 0x48;\n        catchjmp[1] = 0xb8; // mov RAX, QWORD PTR [...]\n        *(uint64_t*)(&catchjmp[2]) = (uint64_t)&__julia_personality;\n        catchjmp[10] = 0xff;\n        catchjmp[11] = 0xe0; // jmp RAX\n        UnwindData[0] = 0x09; // version info, UNW_FLAG_EHANDLER\n        UnwindData[1] = 4;    // size of prolog (bytes)\n        UnwindData[2] = 2;    // count of unwind codes (slots)\n        UnwindData[3] = 0x05; // frame register (rbp) = rsp\n        UnwindData[4] = 4;    // second instruction\n        UnwindData[5] = 0x03; // mov RBP, RSP\n        UnwindData[6] = 1;    // first instruction\n        UnwindData[7] = 0x50; // push RBP\n        *(DWORD*)&UnwindData[8] = (DWORD)(catchjmp - Section); // relative location of catchjmp\n        mod_size = (DWORD)Allocated+48;\n    }\n    PRUNTIME_FUNCTION tbl = (PRUNTIME_FUNCTION)(UnwindData+12);\n#else\n    PRUNTIME_FUNCTION tbl = (PRUNTIME_FUNCTION)malloc(sizeof(RUNTIME_FUNCTION));\n#endif\n    tbl->BeginAddress = (DWORD)(Code - Section);\n    tbl->EndAddress = (DWORD)(Code - Section + Size);\n    tbl->UnwindData = (DWORD)(UnwindData - Section);\n#else // defined(_CPU_X86_64_)\n    Section += (uintptr_t)Code;\n    mod_size = Size;\n#endif\n    if (0) {\n        assert(!jl_in_stackwalk);\n        jl_in_stackwalk = 1;\n        if (mod_size && !SymLoadModuleEx(GetCurrentProcess(), NULL, NULL, NULL, (DWORD64)Section, mod_size, NULL, SLMFLAG_VIRTUAL)) {\n#if defined(_CPU_X86_64_) && !defined(USE_MCJIT)\n            catchjmp[0] = 0;\n#endif\n            static int warned = 0;\n            if (!warned) {\n                jl_printf(JL_STDERR, \"WARNING: failed to insert module info for backtrace: %lu\\n\", GetLastError());\n                warned = 1;\n            }\n        }\n        else {\n            size_t len = fnname.size()+1;\n            if (len > MAX_SYM_NAME)\n                len = MAX_SYM_NAME;\n            char *name = (char*)alloca(len);\n            memcpy(name, fnname.data(), len-1);\n            name[len-1] = 0;\n            if (!SymAddSymbol(GetCurrentProcess(), (ULONG64)Section, name,\n                        (DWORD64)Code, (DWORD)Size, 0)) {\n                jl_printf(JL_STDERR, \"WARNING: failed to insert function name %s into debug info: %lu\\n\", name, GetLastError());\n            }\n        }\n        jl_in_stackwalk = 0;\n    }\n#if defined(_CPU_X86_64_)\n    if (!RtlAddFunctionTable(tbl, 1, (DWORD64)Section)) {\n        static int warned = 0;\n        if (!warned) {\n            jl_printf(JL_STDERR, \"WARNING: failed to insert function stack unwind info: %lu\\n\", GetLastError());\n            warned = 1;\n        }\n    }\n#endif\n}\n#endif\n\nstruct revcomp {\n    bool operator() (const size_t& lhs, const size_t& rhs) const\n    { return lhs>rhs; }\n};\n\n#ifdef LLVM38\nstruct strrefcomp {\n    bool operator() (const StringRef& lhs, const StringRef& rhs) const\n    {\n        return lhs.compare(rhs) > 0;\n    }\n};\n#endif\n\nextern \"C\" tracer_cb jl_linfo_tracer;\nstatic std::vector<jl_lambda_info_t*> triggered_linfos;\nvoid jl_callback_triggered_linfos(void)\n{\n    if (triggered_linfos.empty())\n        return;\n    if (jl_linfo_tracer) {\n        std::vector<jl_lambda_info_t*> to_process(std::move(triggered_linfos));\n        for (jl_lambda_info_t *linfo : to_process)\n            jl_call_tracer(jl_linfo_tracer, (jl_value_t*)linfo);\n    }\n}\n\nclass JuliaJITEventListener: public JITEventListener\n{\n#ifndef USE_MCJIT\n    std::map<size_t, FuncInfo, revcomp> info;\n#else\n    std::map<size_t, ObjectInfo, revcomp> objectmap;\n    std::map<size_t, std::pair<size_t, jl_lambda_info_t *>, revcomp> linfomap;\n#endif\n\npublic:\n    JuliaJITEventListener(){}\n    virtual ~JuliaJITEventListener() {}\n\n#ifndef USE_MCJIT\n    virtual void NotifyFunctionEmitted(const Function &F, void *Code,\n                                       size_t Size, const EmittedFunctionDetails &Details)\n    {\n        jl_ptls_t ptls = jl_get_ptls_states();\n        // This function modify linfo->fptr in GC safe region.\n        // This should be fine since the GC won't scan this field.\n        int8_t gc_state = jl_gc_safe_enter(ptls);\n        uv_rwlock_wrlock(&threadsafe);\n        StringRef sName = F.getName();\n        StringMap<jl_lambda_info_t*>::iterator linfo_it = linfo_in_flight.find(sName);\n        jl_lambda_info_t *linfo = NULL;\n        if (linfo_it != linfo_in_flight.end()) {\n            linfo = linfo_it->second;\n            linfo_in_flight.erase(linfo_it);\n            if (((Function*)linfo->functionObjectsDecls.functionObject)->getName().equals(sName))\n                linfo->fptr = (jl_fptr_t)(uintptr_t)Code;\n        }\n#if defined(_OS_WINDOWS_)\n        create_PRUNTIME_FUNCTION((uint8_t*)Code, Size, F.getName(), (uint8_t*)Code, Size, NULL);\n#endif\n        FuncInfo tmp = {&F, Size, Details.LineStarts, linfo};\n        info[(size_t)(Code)] = tmp;\n#ifndef KEEP_BODIES\n        if (!jl_generating_output())\n            const_cast<Function*>(&F)->deleteBody();\n#endif\n        uv_rwlock_wrunlock(&threadsafe);\n        jl_gc_safe_leave(ptls, gc_state);\n    }\n\n    std::map<size_t, FuncInfo, revcomp>& getMap()\n    {\n        uv_rwlock_rdlock(&threadsafe);\n        return info;\n    }\n#endif // ifndef USE_MCJIT\n\n#ifdef USE_MCJIT\n    jl_lambda_info_t *lookupLinfo(size_t pointer)\n    {\n        auto linfo = linfomap.lower_bound(pointer);\n        if (linfo != linfomap.end() && pointer < linfo->first + linfo->second.first)\n            return linfo->second.second;\n        else\n            return NULL;\n    }\n#ifdef LLVM36\n\n    virtual void NotifyObjectEmitted(const object::ObjectFile &obj,\n                                     const RuntimeDyld::LoadedObjectInfo &L)\n    {\n        return _NotifyObjectEmitted(obj,obj,L,nullptr);\n    }\n\n    virtual void _NotifyObjectEmitted(const object::ObjectFile &obj,\n                                      const object::ObjectFile &debugObj,\n                                      const RuntimeDyld::LoadedObjectInfo &L,\n                                      RTDyldMemoryManager *memmgr)\n#else\n    virtual void NotifyObjectEmitted(const ObjectImage &obj)\n#endif\n    {\n        jl_ptls_t ptls = jl_get_ptls_states();\n        // This function modify linfo->fptr in GC safe region.\n        // This should be fine since the GC won't scan this field.\n        int8_t gc_state = jl_gc_safe_enter(ptls);\n        uv_rwlock_wrlock(&threadsafe);\n#ifdef LLVM36\n        object::section_iterator Section = debugObj.section_begin();\n        object::section_iterator EndSection = debugObj.section_end();\n#else\n        object::section_iterator Section = debugObj.begin_sections();\n        object::section_iterator EndSection = debugObj.end_sections();\n#endif\n\n#ifdef LLVM38\n        std::map<StringRef,object::SectionRef,strrefcomp> loadedSections;\n        for (const object::SectionRef &lSection: obj.sections()) {\n            StringRef sName;\n            if (!lSection.getName(sName)) {\n                loadedSections[sName] = lSection;\n            }\n        }\n        auto getLoadAddress = [&] (const StringRef &sName) -> uint64_t {\n            auto search = loadedSections.find(sName);\n            if (search == loadedSections.end())\n                return 0;\n            return L.getSectionLoadAddress(search->second);\n        };\n#endif\n\n#if defined(_OS_WINDOWS_)\n        uint64_t SectionAddrCheck = 0; // assert that all of the Sections are at the same location\n        uint8_t *UnwindData = NULL;\n#if defined(_CPU_X86_64_)\n        uint64_t SectionLoadOffset = 1; // The real offset shouldn't be 1.\n        uint8_t *catchjmp = NULL;\n        for (const object::SymbolRef &sym_iter : debugObj.symbols()) {\n            StringRef sName;\n#ifdef LLVM37\n            auto sNameOrError = sym_iter.getName();\n            assert(sNameOrError);\n            sName = sNameOrError.get();\n#else\n            sym_iter.getName(sName);\n#endif\n            uint8_t **pAddr = NULL;\n            if (sName.equals(\"__UnwindData\")) {\n                pAddr = &UnwindData;\n            }\n            else if (sName.equals(\"__catchjmp\")) {\n                pAddr = &catchjmp;\n            }\n            if (pAddr) {\n                uint64_t Addr, SectionAddr, SectionLoadAddr;\n#if defined(LLVM38)\n                auto AddrOrError = sym_iter.getAddress();\n                assert(AddrOrError);\n                Addr = AddrOrError.get();\n                auto SectionOrError = sym_iter.getSection();\n                assert(SectionOrError);\n                Section = SectionOrError.get();\n                assert(Section != EndSection && Section->isText());\n                SectionAddr = Section->getAddress();\n                Section->getName(sName);\n                SectionLoadAddr = getLoadAddress(sName);\n#elif defined(LLVM37)\n                auto AddrOrError = sym_iter.getAddress();\n                assert(AddrOrError);\n                Addr = AddrOrError.get();\n                sym_iter.getSection(Section);\n                assert(Section != EndSection && Section->isText());\n                Section->getName(sName);\n                SectionAddr = Section->getAddress();\n                SectionLoadAddr = L.getSectionLoadAddress(sName);\n#elif defined(LLVM36)\n                sym_iter.getAddress(Addr);\n                sym_iter.getSection(Section);\n                assert(Section != EndSection && Section->isText());\n                Section->getName(sName);\n                SectionAddr = Section->getAddress();\n                SectionLoadAddr = L.getSectionLoadAddress(sName);\n#else // LLVM35\n                sym_iter.getAddress(Addr);\n                sym_iter.getSection(Section);\n                assert(Section != EndSection);\n                assert(!Section->isText(isText) && isText);\n                Section->getAddress(SectionAddr);\n                Section->getAddress(SectionLoadAddr);\n#endif\n                Addr -= SectionAddr - SectionLoadAddr;\n                *pAddr = (uint8_t*)Addr;\n                if (SectionAddrCheck)\n                    assert(SectionAddrCheck == SectionLoadAddr);\n                else\n                    SectionAddrCheck = SectionLoadAddr;\n#ifdef USE_ORCJIT\n                if (memmgr)\n                    SectionAddr =\n                        (uintptr_t)lookupWriteAddressFor(memmgr,\n                                                         (void*)SectionLoadAddr);\n#endif\n                if (SectionLoadOffset != 1)\n                    assert(SectionLoadOffset == SectionAddr - SectionLoadAddr);\n                else\n                    SectionLoadOffset = SectionAddr - SectionLoadAddr;\n            }\n        }\n        assert(catchjmp);\n        assert(UnwindData);\n        assert(SectionAddrCheck);\n        assert(SectionLoadOffset != 1);\n        catchjmp[SectionLoadOffset] = 0x48;\n        catchjmp[SectionLoadOffset + 1] = 0xb8; // mov RAX, QWORD PTR [&__julia_personality]\n        *(uint64_t*)(&catchjmp[SectionLoadOffset + 2]) =\n            (uint64_t)&__julia_personality;\n        catchjmp[SectionLoadOffset + 10] = 0xff;\n        catchjmp[SectionLoadOffset + 11] = 0xe0; // jmp RAX\n        UnwindData[SectionLoadOffset] = 0x09; // version info, UNW_FLAG_EHANDLER\n        UnwindData[SectionLoadOffset + 1] = 4;    // size of prolog (bytes)\n        UnwindData[SectionLoadOffset + 2] = 2;    // count of unwind codes (slots)\n        UnwindData[SectionLoadOffset + 3] = 0x05; // frame register (rbp) = rsp\n        UnwindData[SectionLoadOffset + 4] = 4;    // second instruction\n        UnwindData[SectionLoadOffset + 5] = 0x03; // mov RBP, RSP\n        UnwindData[SectionLoadOffset + 6] = 1;    // first instruction\n        UnwindData[SectionLoadOffset + 7] = 0x50; // push RBP\n        *(DWORD*)&UnwindData[SectionLoadOffset + 8] = (DWORD)(catchjmp - (uint8_t*)SectionAddrCheck); // relative location of catchjmp\n#endif // defined(_OS_X86_64_)\n#endif // defined(_OS_WINDOWS_)\n\n#ifdef LLVM37\n        auto symbols = object::computeSymbolSizes(debugObj);\n        bool first = true;\n        for(const auto &sym_size : symbols) {\n            const object::SymbolRef &sym_iter = sym_size.first;\n#ifdef LLVM39\n            auto SymbolTypeOrError = sym_iter.getType();\n            assert(SymbolTypeOrError);\n            object::SymbolRef::Type SymbolType = SymbolTypeOrError.get();\n#else\n            object::SymbolRef::Type SymbolType = sym_iter.getType();\n#endif\n            if (SymbolType != object::SymbolRef::ST_Function) continue;\n            auto AddrOrError = sym_iter.getAddress();\n            assert(AddrOrError);\n            uint64_t Addr = AddrOrError.get();\n#ifdef LLVM38\n            auto SectionOrError = sym_iter.getSection();\n            assert(SectionOrError);\n            Section = SectionOrError.get();\n#else\n            sym_iter.getSection(Section);\n#endif\n            if (Section == EndSection) continue;\n            if (!Section->isText()) continue;\n            uint64_t SectionAddr = Section->getAddress();\n            StringRef secName;\n            Section->getName(secName);\n#ifdef LLVM38\n            uint64_t SectionLoadAddr = getLoadAddress(secName);\n#else\n            uint64_t SectionLoadAddr = L.getSectionLoadAddress(secName);\n#endif\n            Addr -= SectionAddr - SectionLoadAddr;\n            auto sNameOrError = sym_iter.getName();\n            assert(sNameOrError);\n            StringRef sName = sNameOrError.get();\n            uint64_t SectionSize = Section->getSize();\n            size_t Size = sym_size.second;\n#if defined(_OS_WINDOWS_)\n            if (SectionAddrCheck)\n                assert(SectionAddrCheck == SectionLoadAddr);\n            else\n                SectionAddrCheck = SectionLoadAddr;\n            create_PRUNTIME_FUNCTION(\n                   (uint8_t*)(uintptr_t)Addr, (size_t)Size, sName,\n                   (uint8_t*)(uintptr_t)SectionLoadAddr, (size_t)SectionSize, UnwindData);\n#endif\n            StringMap<jl_lambda_info_t*>::iterator linfo_it = linfo_in_flight.find(sName);\n            jl_lambda_info_t *linfo = NULL;\n            if (linfo_it != linfo_in_flight.end()) {\n                linfo = linfo_it->second;\n                if (linfo->compile_traced)\n                    triggered_linfos.push_back(linfo);\n                linfo_in_flight.erase(linfo_it);\n                if (((Function*)linfo->functionObjectsDecls.functionObject)->getName().equals(sName))\n                    linfo->fptr = (jl_fptr_t)(uintptr_t)Addr;\n            }\n            if (linfo)\n                linfomap[Addr] = std::make_pair(Size, linfo);\n            if (first) {\n                ObjectInfo tmp = {&debugObj,\n                    (size_t)SectionSize,\n                    (ptrdiff_t)(SectionAddr - SectionLoadAddr),\n                    new DWARFContextInMemory(debugObj, &L),\n                    };\n                objectmap[SectionLoadAddr] = tmp;\n                first = false;\n           }\n        }\n\n#else // pre-LLVM37\n        uint64_t Addr;\n        uint64_t Size;\n        object::SymbolRef::Type SymbolType;\n        StringRef sName;\n        uint64_t SectionLoadAddr = 0, SectionAddr = 0;\n#ifndef LLVM36\n        bool isText;\n#endif\n\n#if defined(LLVM35)\n        for (const object::SymbolRef &sym_iter : obj.symbols()) {\n            sym_iter.getType(SymbolType);\n            if (SymbolType != object::SymbolRef::ST_Function) continue;\n            sym_iter.getSize(Size);\n            sym_iter.getAddress(Addr);\n            sym_iter.getSection(Section);\n            if (Section == EndSection) continue;\n#if defined(LLVM36)\n            if (!Section->isText()) continue;\n            Section->getName(sName);\n            SectionAddr = Section->getAddress();\n            SectionLoadAddr = L.getSectionLoadAddress(sName);\n            Addr += SectionLoadAddr;\n#else\n            if (Section->isText(isText) || !isText) continue;\n            Section->getAddress(SectionAddr);\n            Section->getAddress(SectionLoadAddr);\n#endif\n            sym_iter.getName(sName);\n#ifdef _OS_DARWIN_\n#   if !defined(LLVM36)\n            Addr = ((MCJIT*)jl_ExecutionEngine)->getSymbolAddress(sName, true);\n            if (!Addr && sName[0] == '_') {\n                Addr = ((MCJIT*)jl_ExecutionEngine)->getSymbolAddress(sName.substr(1), true);\n            }\n            if (!Addr) continue;\n#   endif\n#elif defined(_OS_WINDOWS_)\n            uint64_t SectionSize = 0;\n#   if defined(LLVM36)\n            SectionSize = Section->getSize();\n#   else\n            Section->getSize(SectionSize);\n#   endif\n            if (SectionAddrCheck)\n                assert(SectionAddrCheck == SectionLoadAddr);\n            else\n                SectionAddrCheck = SectionLoadAddr;\n            create_PRUNTIME_FUNCTION(\n                   (uint8_t*)(uintptr_t)Addr, (size_t)Size, sName,\n                   (uint8_t*)(uintptr_t)SectionLoadAddr, (size_t)SectionSize, UnwindData);\n#endif\n            StringMap<jl_lambda_info_t*>::iterator linfo_it = linfo_in_flight.find(sName);\n            jl_lambda_info_t *linfo = NULL;\n            if (linfo_it != linfo_in_flight.end()) {\n                linfo = linfo_it->second;\n                linfo_in_flight.erase(linfo_it);\n                if (((Function*)linfo->functionObjectsDecls.functionObject)->getName().equals(sName))\n                    linfo->fptr = (jl_fptr_t)(uintptr_t)Addr;\n            }\n            if (linfo)\n                linfomap[Addr] = std::make_pair(Size, linfo);\n            const object::ObjectFile *objfile =\n#ifdef LLVM36\n                &obj;\n#else\n                obj.getObjectFile();\n#endif\n            ObjectInfo tmp = {objfile, (size_t)Size,\n                (ptrdiff_t)(SectionAddr - SectionLoadAddr),\n#ifdef _OS_DARWIN_\n                strndup(sName.data(), sName.size()),\n#endif\n                linfo\n            };\n            objectmap[Addr] = tmp;\n        }\n#else //LLVM34\n        error_code itererr;\n        object::symbol_iterator sym_iter = obj.begin_symbols();\n        object::symbol_iterator sym_end = obj.end_symbols();\n        for (; sym_iter != sym_end; sym_iter.increment(itererr)) {\n            sym_iter->getType(SymbolType);\n            if (SymbolType != object::SymbolRef::ST_Function) continue;\n            sym_iter->getAddress(Addr);\n            sym_iter->getSize(Size);\n\n            ObjectInfo tmp = {obj.getObjectFile(), (size_t)Size};\n            objectmap[Addr] = tmp;\n        }\n#endif\n#endif\n        uv_rwlock_wrunlock(&threadsafe);\n        jl_gc_safe_leave(ptls, gc_state);\n    }\n\n    // must implement if we ever start freeing code\n    // virtual void NotifyFreeingObject(const ObjectImage &obj) {}\n    // virtual void NotifyFreeingObject(const object::ObjectFile &Obj) {}\n\n    std::map<size_t, ObjectInfo, revcomp>& getObjectMap()\n    {\n        uv_rwlock_rdlock(&threadsafe);\n        return objectmap;\n    }\n#endif // USE_MCJIT\n};\n\n#ifdef USE_ORCJIT\nJL_DLLEXPORT void ORCNotifyObjectEmitted(JITEventListener *Listener,\n                                         const object::ObjectFile &obj,\n                                         const object::ObjectFile &debugObj,\n                                         const RuntimeDyld::LoadedObjectInfo &L,\n                                         RTDyldMemoryManager *memmgr)\n{\n    ((JuliaJITEventListener*)Listener)->_NotifyObjectEmitted(obj,debugObj,L,memmgr);\n}\n#endif\n\nextern \"C\"\nchar *jl_demangle(const char *name)\n{\n    // This function is not allowed to reference any TLS variables since\n    // it can be called from an unmanaged thread on OSX.\n    const char *start = name + 6;\n    const char *end = name + strlen(name);\n    char *ret;\n    if (strncmp(name, \"julia_\", 6)) goto done;\n    if (*start == '\\0') goto done;\n    while (*(--end) != '_') {\n        char c = *end;\n        if (c < '0' || c > '9') goto done;\n    }\n    if (end <= start) goto done;\n    ret = (char*)malloc(end-start+1);\n    memcpy(ret,start,end-start);\n    ret[end-start] = '\\0';\n    return ret;\n done:\n    return strdup(name);\n}\n\nstatic JuliaJITEventListener *jl_jit_events;\nJITEventListener *CreateJuliaJITEventListener()\n{\n    jl_jit_events = new JuliaJITEventListener();\n    return jl_jit_events;\n}\n\n// *frames is a one element array containing whatever we could come up\n// with for the current frame. here we'll try to expand it using debug info\n// func_name and file_name are either NULL or malloc'd pointers\nstatic int lookup_pointer(DIContext *context, jl_frame_t **frames,\n                          size_t pointer, int demangle, int noInline)\n{\n    // This function is not allowed to reference any TLS variables\n    // since it can be called from an unmanaged thread on OSX.\n    if (!context) {\n        if (demangle) {\n            if ((*frames)[0].func_name != NULL) {\n                char *oldname = (*frames)[0].func_name;\n                (*frames)[0].func_name = jl_demangle(oldname);\n                free(oldname);\n            }\n            else {\n                // We do this to hide the jlcall wrappers when getting julia backtraces,\n                // but it is still good to have them for regular lookup of C frames.\n                // Technically not true, but we don't want them\n                // in julia backtraces, so close enough\n                (*frames)[0].fromC = 1;\n            }\n        }\n        return 1;\n    }\n#ifdef LLVM35\n    DILineInfoSpecifier infoSpec(DILineInfoSpecifier::FileLineInfoKind::AbsoluteFilePath,\n                                 DILineInfoSpecifier::FunctionNameKind::ShortName);\n#else\n    int infoSpec = DILineInfoSpecifier::FileLineInfo |\n                   DILineInfoSpecifier::AbsoluteFilePath |\n                   DILineInfoSpecifier::FunctionName;\n#endif\n\n    auto inlineInfo = context->getInliningInfoForAddress(pointer, infoSpec);\n\n    int fromC = (*frames)[0].fromC;\n    int n_frames = inlineInfo.getNumberOfFrames();\n    if (n_frames == 0)\n        // no line number info available in the context, return without the context\n        return lookup_pointer(NULL, frames, pointer, demangle, noInline);\n    if (noInline)\n        n_frames = 1;\n    if (n_frames > 1) {\n        jl_frame_t *new_frames = (jl_frame_t*)calloc(sizeof(jl_frame_t), n_frames);\n        memcpy(&new_frames[n_frames - 1], *frames, sizeof(jl_frame_t));\n        free(*frames);\n        *frames = new_frames;\n    }\n    for (int i = 0; i < n_frames; i++) {\n        bool inlined_frame = i != n_frames - 1;\n        DILineInfo info;\n        if (!noInline) {\n            info = inlineInfo.getFrame(i);\n        }\n        else {\n            info = context->getLineInfoForAddress(pointer, infoSpec);\n        }\n\n        jl_frame_t *frame = &(*frames)[i];\n#ifndef LLVM35\n        std::string func_name(info.getFunctionName());\n#else\n        std::string func_name(info.FunctionName);\n#endif\n\n        if (inlined_frame) {\n            frame->inlined = 1;\n            frame->fromC = fromC;\n            if ((*frames)[n_frames-1].linfo) {\n                std::size_t semi_pos = func_name.find(';');\n                if (semi_pos != std::string::npos) {\n                    func_name = func_name.substr(0, semi_pos);\n                    frame->linfo = NULL; // TODO\n                }\n            }\n        }\n\n        if (func_name == \"<invalid>\")\n            frame->func_name = NULL;\n        else\n            jl_copy_str(&frame->func_name, func_name.c_str());\n#ifndef LLVM35\n        frame->line = info.getLine();\n        std::string file_name(info.getFileName());\n#else\n        frame->line = info.Line;\n        std::string file_name(info.FileName);\n#endif\n        if (file_name == \"<invalid>\")\n            frame->file_name = NULL;\n        else\n            jl_copy_str(&frame->file_name, file_name.c_str());\n\n        if (!frame->func_name || !func_name.compare(0, 7, \"jlcall_\") || !func_name.compare(0, 7, \"jlcapi_\")) {\n            frame->fromC = 1;\n        }\n    }\n    return n_frames;\n}\n\n#ifdef _OS_DARWIN_\n#include <mach-o/dyld.h>\n#else\n#define LC_UUID 0\n#endif\n#ifndef _OS_WINDOWS_\n#include <dlfcn.h>\n#endif\ntypedef struct {\n    const llvm::object::ObjectFile *obj;\n    DIContext *ctx;\n    int64_t slide;\n    int64_t section_slide;\n} objfileentry_t;\ntypedef std::map<uint64_t, objfileentry_t, revcomp> obfiletype;\nstatic obfiletype objfilemap;\n\nstatic bool getObjUUID(llvm::object::MachOObjectFile *obj, uint8_t uuid[16])\n{\n# ifdef LLVM37\n    for (auto Load : obj->load_commands())\n# else\n#  ifdef LLVM35\n    uint32_t LoadCommandCount = obj->getHeader().ncmds;\n#  else\n    uint32_t LoadCommandCount = obj->getHeader().NumLoadCommands;\n#  endif\n    llvm::object::MachOObjectFile::LoadCommandInfo Load = obj->getFirstLoadCommandInfo();\n    for (unsigned I = 0; ; ++I)\n# endif\n    {\n        if (\n# ifdef LLVM35\n            Load.C.cmd == LC_UUID\n# else\n            Load.C.Type == LC_UUID\n# endif\n            ) {\n            memcpy(uuid, ((const MachO::uuid_command*)Load.Ptr)->uuid, 16);\n            return true;\n        }\n# ifndef LLVM37\n        else if (I == LoadCommandCount - 1) {\n            return false;\n        }\n        else {\n            Load = obj->getNextLoadCommandInfo(Load);\n        }\n# endif\n    }\n    return false;\n}\n\n#ifdef LLVM36\nstruct debug_link_info {\n    StringRef filename;\n    uint32_t crc32;\n};\nstatic debug_link_info getDebuglink(const object::ObjectFile &Obj)\n{\n    debug_link_info info = {};\n    for (const object::SectionRef &Section: Obj.sections()) {\n        StringRef sName;\n        if (!Section.getName(sName) && sName == \".gnu_debuglink\") {\n            StringRef Contents;\n            if (!Section.getContents(Contents)) {\n                size_t length = Contents.find('\\0');\n                info.filename = Contents.substr(0, length);\n                info.crc32 = *(const uint32_t*)Contents.substr(LLT_ALIGN(length + 1, 4), 4).data();\n                break;\n            }\n        }\n    }\n    return info;\n}\n/*\n * crc function from http://svnweb.freebsd.org/base/head/sys/libkern/crc32.c (and lldb)\n *\n *   COPYRIGHT (C) 1986 Gary S. Brown. You may use this program, or\n *   code or tables extracted from it, as desired without restriction.\n */\nstatic uint32_t\ncalc_gnu_debuglink_crc32(const void *buf, size_t size)\n{\n    static const uint32_t g_crc32_tab[] =\n    {\n        0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,\n        0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\n        0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,\n        0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n        0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n        0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,\n        0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,\n        0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n        0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,\n        0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n        0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,\n        0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n        0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,\n        0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,\n        0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n        0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n        0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,\n        0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,\n        0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,\n        0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n        0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,\n        0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,\n        0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,\n        0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n        0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n        0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,\n        0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,\n        0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n        0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,\n        0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n        0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,\n        0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n        0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,\n        0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,\n        0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n        0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n        0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,\n        0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,\n        0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,\n        0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n        0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,\n        0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,\n        0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\n    };\n    const uint8_t *p = (const uint8_t *)buf;\n    uint32_t crc;\n\n    crc = ~0U;\n    while (size--)\n        crc = g_crc32_tab[(crc ^ *p++) & 0xFF] ^ (crc >> 8);\n    return crc ^ ~0U;\n}\n\n#ifdef LLVM39\nstatic Expected<object::OwningBinary<object::ObjectFile>>\n#else\nstatic ErrorOr<object::OwningBinary<object::ObjectFile>>\n#endif\nopenDebugInfo(StringRef debuginfopath, const debug_link_info &info)\n{\n    auto SplitFile = MemoryBuffer::getFile(debuginfopath);\n    if (std::error_code EC = SplitFile.getError()) {\n#ifdef LLVM39\n        return errorCodeToError(EC);\n#else\n        return EC;\n#endif\n    }\n\n    uint32_t crc32 = calc_gnu_debuglink_crc32(\n            SplitFile.get()->getBufferStart(),\n            SplitFile.get()->getBufferSize());\n    if (crc32 != info.crc32) {\n#ifdef LLVM39\n        return errorCodeToError(object::object_error::arch_not_found);\n#else\n        return object::object_error::arch_not_found;\n#endif\n    }\n\n    auto error_splitobj = object::ObjectFile::createObjectFile(\n            SplitFile.get().get()->getMemBufferRef(),\n            sys::fs::file_magic::unknown);\n    if (!error_splitobj) {\n#ifdef LLVM39\n        return error_splitobj.takeError();\n#else\n        return error_splitobj.getError();\n#endif\n    }\n\n    // successfully validated and loaded split debug info file\n    return object::OwningBinary<object::ObjectFile>(\n            std::move(error_splitobj.get()),\n            std::move(SplitFile.get()));\n}\n#endif\n\nstatic uint64_t jl_sysimage_base;\nstatic void **sysimg_fvars;\nstatic jl_lambda_info_t **sysimg_fvars_linfo;\nstatic size_t sysimg_fvars_n;\nextern \"C\" void jl_register_fptrs(uint64_t sysimage_base, void **fptrs, jl_lambda_info_t **linfos, size_t n)\n{\n    jl_sysimage_base = (uintptr_t)sysimage_base;\n    sysimg_fvars = fptrs;\n    sysimg_fvars_linfo = linfos;\n    sysimg_fvars_n = n;\n}\n\ntemplate<typename T>\nstatic inline void ignoreError(T &err)\n{\n#if defined(LLVM39) && !defined(NDEBUG)\n    consumeError(err.takeError());\n#endif\n}\n\nextern \"C\" void jl_refresh_dbg_module_list(void);\nbool jl_dylib_DI_for_fptr(size_t pointer, const llvm::object::ObjectFile **obj, llvm::DIContext **context, int64_t *slide, int64_t *section_slide,\n    bool onlySysImg, bool *isSysImg, void **saddr, char **name, char **filename)\n{\n    *obj = NULL;\n    *context = NULL;\n    *slide = 0;\n    *section_slide = 0;\n\n// GOAL: Determine containing Library\n// Assigning fname, fbase\n#ifdef _OS_WINDOWS_\n    IMAGEHLP_MODULE64 ModuleInfo;\n    ModuleInfo.SizeOfStruct = sizeof(IMAGEHLP_MODULE64);\n    jl_refresh_dbg_module_list();\n    jl_in_stackwalk = 1;\n    bool isvalid = SymGetModuleInfo64(GetCurrentProcess(), (DWORD64)pointer, &ModuleInfo);\n    jl_in_stackwalk = 0;\n    if (!isvalid) return false;\n\n    StringRef fname = ModuleInfo.LoadedImageName;\n    if (fname.empty()) // empirically, LoadedImageName might be missing\n        fname = ModuleInfo.ImageName;\n    DWORD64 fbase = ModuleInfo.BaseOfImage;\n    bool insysimage = (fbase == jl_sysimage_base);\n    if (isSysImg)\n        *isSysImg = insysimage;\n    if (onlySysImg && !insysimage) {\n        return false;\n    }\n    static char frame_info_func[\n        sizeof(SYMBOL_INFO) +\n        MAX_SYM_NAME * sizeof(TCHAR)];\n    DWORD64 dwDisplacement64 = 0;\n    DWORD64 dwAddress = pointer;\n    PSYMBOL_INFO pSymbol = (PSYMBOL_INFO)frame_info_func;\n    pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);\n    pSymbol->MaxNameLen = MAX_SYM_NAME;\n    jl_in_stackwalk = 1;\n    if (SymFromAddr(GetCurrentProcess(), dwAddress, &dwDisplacement64,\n                    pSymbol)) {\n        // SymFromAddr returned success\n        // errors are ignored, but are hopefully patched up by\n        // using llvm to read the object (below)\n        if (name)\n            jl_copy_str(name, pSymbol->Name);\n        if (saddr)\n            *saddr = (void*)(uintptr_t)pSymbol->Address;\n    }\n    else if (saddr) {\n        *saddr = NULL;\n    }\n\n    // If we didn't find the filename before in the debug\n    // info, use the dll name\n    if (filename && !*filename)\n        jl_copy_str(filename, fname.data());\n\n    jl_in_stackwalk = 0;\n\n#else // ifdef _OS_WINDOWS_\n    Dl_info dlinfo;\n    int dladdr_success;\n    uint64_t fbase;\n#ifdef __GLIBC__\n    struct link_map *extra_info;\n    dladdr_success = dladdr1((void*)pointer, &dlinfo, (void**)&extra_info, RTLD_DL_LINKMAP) != 0;\n#else\n    dladdr_success = dladdr((void*)pointer, &dlinfo) != 0;\n#endif\n    if (!dladdr_success || !dlinfo.dli_fname)\n        return false;\n\n#ifdef __GLIBC__\n    // dlinfo.dli_fbase is not the right value for the main executable on linux\n    fbase = (uintptr_t)extra_info->l_addr;\n#else\n    fbase = (uintptr_t)dlinfo.dli_fbase;\n#endif\n    StringRef fname;\n    if (saddr)\n        *saddr = dlinfo.dli_saddr;\n    bool insysimage = (fbase == jl_sysimage_base);\n    if (isSysImg)\n        *isSysImg = insysimage;\n    if (onlySysImg && !insysimage) {\n        return false;\n    }\n    // In case we fail with the debug info lookup, we at least still\n    // have the function name, even if we don't have line numbers\n    if (name)\n        jl_copy_str(name, dlinfo.dli_sname);\n    if (filename)\n        jl_copy_str(filename, dlinfo.dli_fname);\n    fname = dlinfo.dli_fname;\n#endif // ifdef _OS_WINDOWS_\n\n    int isdarwin = 0, islinux = 0, iswindows = 0;\n#if defined(_OS_DARWIN_)\n    isdarwin = 1;\n#elif defined(_OS_LINUX_) || defined(_OS_FREEBSD_)\n    islinux = 1;\n#elif defined(_OS_WINDOWS_)\n    iswindows = 1;\n#endif\n\n#ifndef LLVM35\n    if (iswindows) {\n        return true;\n    }\n#endif\n\n// GOAL: Read debuginfo from file\n    // TODO: need read/write lock here for objfilemap synchronization\n    obfiletype::iterator it = objfilemap.find(fbase);\n    if (it != objfilemap.end()) {\n        // Return cached value\n        *obj = it->second.obj;\n        *context = it->second.ctx;\n        *slide = it->second.slide;\n        *section_slide = it->second.section_slide;\n        return true;\n    }\n\n// GOAL: Assign errorobj\n    StringRef objpath;\n    std::string debuginfopath;\n    uint8_t uuid[16], uuid2[16];\n    if (isdarwin) {\n        size_t msize = (size_t)(((uint64_t)-1) - fbase);\n#ifdef LLVM36\n        std::unique_ptr<MemoryBuffer> membuf = MemoryBuffer::getMemBuffer(\n                StringRef((const char *)fbase, msize), \"\", false);\n        auto origerrorobj = llvm::object::ObjectFile::createObjectFile(\n            membuf->getMemBufferRef(), sys::fs::file_magic::unknown);\n#elif defined(LLVM35)\n        MemoryBuffer *membuf = MemoryBuffer::getMemBuffer(\n            StringRef((const char *)fbase, msize), \"\", false);\n        std::unique_ptr<MemoryBuffer> buf(membuf);\n        auto origerrorobj = llvm::object::ObjectFile::createObjectFile(\n            buf, sys::fs::file_magic::unknown);\n#else\n        MemoryBuffer *membuf = MemoryBuffer::getMemBuffer(\n            StringRef((const char *)fbase, msize), \"\", false);\n        std::unique_ptr<llvm::object::ObjectFile> origerrorobj(llvm::object::ObjectFile::createObjectFile(\n            membuf));\n#endif\n        if (!origerrorobj) {\n            objfileentry_t entry = {};\n            objfilemap[fbase] = entry;\n            return true;\n        }\n\n        llvm::object::MachOObjectFile *morigobj = (llvm::object::MachOObjectFile*)\n#ifdef LLVM36\n            origerrorobj.get().get();\n#else\n            origerrorobj.get();\n#endif\n\n        // First find the uuid of the object file (we'll use this to make sure we find the\n        // correct debug symbol file).\n        if (!getObjUUID(morigobj, uuid)) {\n            objfileentry_t entry = {};\n            objfilemap[fbase] = entry;\n            return true;\n        }\n\n        // On OS X debug symbols are not contained in the dynamic library.\n        // For now we only support .dSYM files in the same directory\n        // as the shared library. In the future we may use DBGCopyFullDSYMURLForUUID from CoreFoundation to make\n        // use of spotlight to find the .dSYM file.\n        size_t sep = fname.rfind('/');\n        debuginfopath = fname;\n        debuginfopath += \".dSYM/Contents/Resources/DWARF/\";\n        debuginfopath += fname.substr(sep + 1);\n        objpath = debuginfopath;\n    }\n    else {\n        // On Linux systems we need to mmap another copy because of the permissions on the mmap'ed shared library.\n        // On Windows we need to mmap another copy since reading the in-memory copy seems to return object_error:unexpected_eof\n        objpath = fname;\n    }\n#ifdef LLVM35\n    auto errorobj = llvm::object::ObjectFile::createObjectFile(objpath);\n#else\n    std::unique_ptr<llvm::object::ObjectFile> errorobj(llvm::object::ObjectFile::createObjectFile(objpath));\n#endif\n\n// GOAL: Assign *obj, *context, *slide (if above succeeded)\n    if (errorobj) {\n#ifdef LLVM36\n        auto *debugobj = errorobj->getBinary();\n#else\n        auto *debugobj = errorobj.get();\n#endif\n\n        if (islinux) {\n#ifdef LLVM36\n            // if the file has a .gnu_debuglink section,\n            // try to load its companion file instead\n            // in the expected locations\n            // for now, we don't support the build-id method\n            debug_link_info info = getDebuglink(*debugobj);\n            if (!info.filename.empty()) {\n                size_t sep = fname.rfind('/');\n#ifdef LLVM39\n                Expected<object::OwningBinary<object::ObjectFile>>\n                    DebugInfo(errorCodeToError(std::make_error_code(std::errc::no_such_file_or_directory)));\n                // Can't find a way to construct an empty Expected object\n                // that can be ignored.\n                ignoreError(DebugInfo);\n#else\n                ErrorOr<object::OwningBinary<object::ObjectFile>>\n                    DebugInfo(std::errc::no_such_file_or_directory);\n#endif\n                if (fname.substr(sep + 1) != info.filename) {\n                    debuginfopath = fname.substr(0, sep + 1);\n                    debuginfopath += info.filename;\n                    DebugInfo = openDebugInfo(debuginfopath, info);\n                }\n                if (!DebugInfo) {\n                    debuginfopath = fname.substr(0, sep + 1);\n                    debuginfopath += \".debug/\";\n                    debuginfopath += info.filename;\n                    ignoreError(DebugInfo);\n                    DebugInfo = openDebugInfo(debuginfopath, info);\n                }\n                if (!DebugInfo) {\n                    debuginfopath = \"/usr/lib/debug/\";\n                    debuginfopath += fname.substr(0, sep + 1);\n                    debuginfopath += info.filename;\n                    ignoreError(DebugInfo);\n                    DebugInfo = openDebugInfo(debuginfopath, info);\n                }\n                if (DebugInfo) {\n                    errorobj = std::move(DebugInfo);\n                    // Yes, we've checked, and yes LLVM want us to check again.\n                    assert(errorobj);\n                    debugobj = errorobj->getBinary();\n                }\n                else {\n                    ignoreError(DebugInfo);\n                }\n            }\n#endif\n        }\n\n        if (isdarwin) {\n            // verify the UUID matches\n            if (!getObjUUID((llvm::object::MachOObjectFile*)debugobj, uuid2) ||\n                    memcmp(uuid, uuid2, sizeof(uuid)) != 0) {\n                objfileentry_t entry = {};\n                objfilemap[fbase] = entry;\n                return true;\n            }\n        }\n\n        if (iswindows) {\n#ifdef LLVM35\n            assert(debugobj->isCOFF());\n            const llvm::object::COFFObjectFile *coffobj = (const llvm::object::COFFObjectFile*)debugobj;\n            const llvm::object::pe32plus_header *pe32plus;\n            coffobj->getPE32PlusHeader(pe32plus);\n            if (pe32plus != NULL) {\n                *slide = pe32plus->ImageBase - fbase;\n                *section_slide = -(int64_t)pe32plus->ImageBase;\n            }\n            else {\n                const llvm::object::pe32_header *pe32;\n                coffobj->getPE32Header(pe32);\n                if (pe32 == NULL) {\n                    objfileentry_t entry = {};\n                    objfilemap[fbase] = entry;\n                    return true;\n                }\n                else {\n                    *slide = pe32->ImageBase - fbase;\n                    *section_slide = -(int64_t)pe32->ImageBase;\n                }\n            }\n#endif\n        }\n        else {\n            *slide = -(int64_t)fbase;\n        }\n\n#ifdef LLVM37\n        *context = new DWARFContextInMemory(*debugobj);\n#elif defined(LLVM36)\n        *context = DIContext::getDWARFContext(*debugobj);\n#else\n        *context = DIContext::getDWARFContext(debugobj);\n#endif\n        *obj = debugobj;\n#ifdef LLVM36\n        auto binary = errorobj->takeBinary();\n        binary.first.release();\n        binary.second.release();\n#else\n        errorobj.release();\n#endif\n    }\n    else {\n        // TODO: report the error instead of silently consuming it?\n        //       jl_error might run into the same error again...\n        ignoreError(errorobj);\n    }\n\n    // update cache\n    objfileentry_t entry = {*obj, *context, *slide, *section_slide};\n    objfilemap[fbase] = entry;\n    return true;\n}\n\n// *name and *filename should be either NULL or malloc'd pointer\nstatic int jl_getDylibFunctionInfo(jl_frame_t **frames, size_t pointer, int skipC, int noInline)\n{\n    // This function is not allowed to reference any TLS variables if noInline\n    // since it can be called from an unmanaged thread on OSX.\n    jl_frame_t *frame0 = *frames;\n#ifdef _OS_WINDOWS_\n    static IMAGEHLP_LINE64 frame_info_line;\n    DWORD dwDisplacement = 0;\n    if (jl_in_stackwalk) {\n        frame0->fromC = 1;\n        return 1;\n    }\n    jl_in_stackwalk = 1;\n    DWORD64 dwAddress = pointer;\n    frame_info_line.SizeOfStruct = sizeof(IMAGEHLP_LINE64);\n    if (SymGetLineFromAddr64(GetCurrentProcess(), dwAddress, &dwDisplacement, &frame_info_line)) {\n        // SymGetLineFromAddr64 returned success\n        // record source file name and line number\n        if (frame_info_line.FileName)\n            jl_copy_str(&frame0->file_name, frame_info_line.FileName);\n        frame0->line = frame_info_line.LineNumber;\n    }\n    jl_in_stackwalk = 0;\n#endif\n    const object::ObjectFile *object;\n    llvm::DIContext *context = NULL;\n    bool isSysImg;\n    void *saddr;\n    int64_t slide, section_slide;\n    if (!jl_dylib_DI_for_fptr(pointer, &object, &context, &slide, &section_slide, skipC, &isSysImg, &saddr, &frame0->func_name, &frame0->file_name)) {\n        frame0->fromC = 1;\n        return 1;\n    }\n    frame0->fromC = !isSysImg;\n    if (isSysImg && sysimg_fvars) {\n#ifdef _OS_LINUX_\n        unw_proc_info_t pip;\n        if (!saddr && unw_get_proc_info_by_ip(unw_local_addr_space,\n                                              pointer, &pip, NULL) == 0)\n            saddr = (void*)pip.start_ip;\n#endif\n#if defined(_OS_WINDOWS_) && defined(_CPU_X86_64_)\n        if (!saddr) {\n            DWORD64 ImageBase;\n            PRUNTIME_FUNCTION fn = RtlLookupFunctionEntry(pointer, &ImageBase, NULL);\n            if (fn)\n                saddr = (void*)(ImageBase + fn->BeginAddress);\n        }\n#endif\n        if (saddr) {\n            for (size_t i = 0; i < sysimg_fvars_n; i++) {\n                if (saddr == sysimg_fvars[i]) {\n                    frame0->linfo = sysimg_fvars_linfo[i];\n                    break;\n                }\n            }\n        }\n        return lookup_pointer(context, frames, pointer+slide, isSysImg, noInline);\n    }\n    return lookup_pointer(context, frames, pointer+slide, isSysImg, noInline);\n}\n\nint jl_DI_for_fptr(uint64_t fptr, uint64_t *symsize, int64_t *slide, int64_t *section_slide,\n                      const object::ObjectFile **object,\n#ifdef USE_MCJIT\n                      llvm::DIContext **context\n#else\n                      std::vector<JITEvent_EmittedFunctionDetails::LineStart> *lines\n#endif\n                      )\n{\n    int found = 0;\n    *slide = 0;\n#ifndef USE_MCJIT\n    std::map<size_t, FuncInfo, revcomp> &fmap = jl_jit_events->getMap();\n    std::map<size_t, FuncInfo, revcomp>::iterator fit = fmap.lower_bound(fptr);\n\n    if (fit != fmap.end() && fptr < fit->first + fit->second.lengthAdr) {\n        if (symsize)\n            *symsize = fit->second.lengthAdr;\n        *lines = fit->second.lines;\n        found = 1;\n    }\n#else // MCJIT version\n    std::map<size_t, ObjectInfo, revcomp> &objmap = jl_jit_events->getObjectMap();\n    std::map<size_t, ObjectInfo, revcomp>::iterator fit = objmap.lower_bound(fptr);\n\n    if (fit != objmap.end() && fptr < fit->first + fit->second.SectionSize) {\n        if (symsize)\n            *symsize = 0;\n        if (section_slide)\n            *section_slide = fit->second.slide;\n        *object = fit->second.object;\n        if (context) {\n#if defined(LLVM37)\n            *context = fit->second.context;\n#else\n            *context = DIContext::getDWARFContext(*fit->second.object);\n#endif\n        }\n        found = 1;\n    }\n#endif\n    uv_rwlock_rdunlock(&threadsafe);\n    return found;\n}\n\n#ifdef USE_MCJIT\nextern \"C\"\nJL_DLLEXPORT jl_value_t *jl_get_dobj_data(uint64_t fptr)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    // Used by Gallium.jl\n    const object::ObjectFile *object = NULL;\n    DIContext *context;\n    int64_t slide, section_slide;\n    int8_t gc_state = jl_gc_safe_enter(ptls);\n    if (!jl_DI_for_fptr(fptr, NULL, &slide, NULL, &object, NULL))\n        if (!jl_dylib_DI_for_fptr(fptr, &object, &context, &slide, &section_slide, false, NULL, NULL, NULL, NULL)) {\n            jl_gc_safe_leave(ptls, gc_state);\n            return jl_nothing;\n        }\n    jl_gc_safe_leave(ptls, gc_state);\n    if (object == NULL)\n        return jl_nothing;\n    return (jl_value_t*)jl_ptr_to_array_1d((jl_value_t*)jl_array_uint8_type,\n        const_cast<char*>(object->getData().data()),\n        object->getData().size(), false);\n}\n\nextern \"C\"\nJL_DLLEXPORT uint64_t jl_get_section_start(uint64_t fptr)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    // Used by Gallium.jl\n    int8_t gc_state = jl_gc_safe_enter(ptls);\n    std::map<size_t, ObjectInfo, revcomp> &objmap = jl_jit_events->getObjectMap();\n    std::map<size_t, ObjectInfo, revcomp>::iterator fit = objmap.lower_bound(fptr);\n\n    uint64_t ret = 0;\n    if (fit != objmap.end() && fptr < fit->first + fit->second.SectionSize) {\n        ret = fit->first;\n    }\n    else {\n       obfiletype::iterator objit = objfilemap.lower_bound(fptr);\n       // Ideally we'd have a containment check here, but we can't really\n       // get the shared library size easily.\n       if (objit != objfilemap.end()) {\n           ret = objit->first;\n       }\n    }\n    uv_rwlock_rdunlock(&threadsafe);\n    jl_gc_safe_leave(ptls, gc_state);\n    return ret;\n}\n\n#endif\n\n// Set *name and *filename to either NULL or malloc'd string\nint jl_getFunctionInfo(jl_frame_t **frames_out, size_t pointer, int skipC, int noInline)\n{\n    // This function is not allowed to reference any TLS variables if noInline\n    // since it can be called from an unmanaged thread on OSX.\n\n    jl_frame_t *frames = (jl_frame_t*)calloc(sizeof(jl_frame_t), 1);\n    frames[0].line = -1;\n    *frames_out = frames;\n\n#ifdef USE_MCJIT\n    llvm::DIContext *context;\n    const llvm::object::ObjectFile *object;\n    uint64_t symsize;\n    int64_t slide = 0;\n    if (jl_DI_for_fptr(pointer, &symsize, &slide, NULL, &object, &context)) {\n        frames[0].linfo = jl_jit_events->lookupLinfo(pointer);\n        int nf = lookup_pointer(context, frames_out, pointer+slide, 1, noInline);\n        return nf;\n    }\n#else // !USE_MCJIT\n// Without MCJIT we use the FuncInfo structure containing address maps\n    std::map<size_t, FuncInfo, revcomp> &info = jl_jit_events->getMap();\n    std::map<size_t, FuncInfo, revcomp>::iterator it = info.lower_bound(pointer);\n    if (it != info.end() && (uintptr_t)(*it).first + (*it).second.lengthAdr >= pointer) {\n        // We do this to hide the jlcall wrappers when getting julia backtraces,\n        // but it is still good to have them for regular lookup of C frames.\n        if (skipC && (*it).second.lines.empty()) {\n            // Technically not true, but we don't want them\n            // in julia backtraces, so close enough\n            frames[0].fromC = 1;\n            uv_rwlock_rdunlock(&threadsafe);\n            return 1;\n        }\n\n        jl_copy_str(&frames[0].func_name, (*it).second.func->getName().str().c_str());\n        jl_copy_str(&frames[0].file_name, \"\");\n\n        if ((*it).second.lines.empty()) {\n            frames[0].fromC = 1;\n            uv_rwlock_rdunlock(&threadsafe);\n            return 1;\n        }\n\n        frames[0].linfo = (*it).second.linfo;\n        std::vector<JITEvent_EmittedFunctionDetails::LineStart>::iterator vit =\n            (*it).second.lines.begin();\n        JITEvent_EmittedFunctionDetails::LineStart prev = *vit;\n        LLVMContext &Ctx = (*it).second.func->getContext();\n\n        DISubprogram debugscope(prev.Loc.getScope(Ctx));\n        jl_copy_str(&frames[0].file_name, debugscope.getFilename().str().c_str());\n        // The DISubprogram has the un-mangled name, so use that if\n        // available. However, the scope need not be the current subprogram.\n        if (debugscope.getName().data() != NULL) {\n            jl_copy_str(&frames[0].func_name, debugscope.getName().str().c_str());\n        }\n        else {\n            char *oldname = frames[0].func_name;\n            frames[0].func_name = jl_demangle(frames[0].func_name);\n            free(oldname);\n        }\n\n        // find nearest line info\n        ++vit;\n        while (vit != (*it).second.lines.end()) {\n            if (pointer <= (*vit).Address) {\n                break;\n            }\n            prev = *vit;\n            ++vit;\n        }\n\n        // read out inlining and line number information\n        int n_frames = 1;\n        if (!noInline) {\n            MDNode *inlinedAt = prev.Loc.getInlinedAt(Ctx);\n            while (inlinedAt != NULL) {\n                DebugLoc inlineloc = DebugLoc::getFromDILocation(inlinedAt);\n                inlinedAt = inlineloc.getInlinedAt(Ctx);\n                n_frames++;\n            }\n            if (n_frames > 1) {\n                frames = (jl_frame_t*)calloc(sizeof(jl_frame_t), n_frames);\n                memcpy(&frames[n_frames - 1], *frames_out, sizeof(jl_frame_t));\n                free(*frames_out);\n                *frames_out = frames;\n            }\n        }\n        DebugLoc inlineloc = prev.Loc;\n        for (int i = 0; i < n_frames; i++) {\n            frames[i].inlined = i != n_frames - 1;\n            frames[i].line = inlineloc.getLine();\n            DISubprogram locscope(inlineloc.getScope(Ctx));\n            jl_copy_str(&frames[i].file_name, locscope.getFilename().str().c_str());\n            jl_copy_str(&frames[i].func_name, locscope.getName().str().c_str());\n            MDNode *inlinedAt = inlineloc.getInlinedAt(Ctx);\n            inlineloc = DebugLoc::getFromDILocation(inlinedAt);\n        }\n\n        uv_rwlock_rdunlock(&threadsafe);\n        return n_frames;\n    }\n    uv_rwlock_rdunlock(&threadsafe);\n#endif // USE_MCJIT\n    return jl_getDylibFunctionInfo(frames_out, pointer, skipC, noInline);\n}\n\nextern \"C\" jl_lambda_info_t *jl_gdblookuplinfo(void *p)\n{\n#ifndef USE_MCJIT\n    std::map<size_t, FuncInfo, revcomp> &info = jl_jit_events->getMap();\n    std::map<size_t, FuncInfo, revcomp>::iterator it = info.lower_bound((size_t)p);\n    jl_lambda_info_t *li = NULL;\n    if (it != info.end() && (uintptr_t)(*it).first + (*it).second.lengthAdr >= (uintptr_t)p)\n        li = (*it).second.linfo;\n    uv_rwlock_rdunlock(&threadsafe);\n    return li;\n#else\n    return jl_jit_events->lookupLinfo((size_t)p);\n#endif\n}\n\n#if defined(LLVM37) && (defined(_OS_LINUX_) || (defined(_OS_DARWIN_) && defined(LLVM_SHLIB)))\nextern \"C\" void __register_frame(void*);\nextern \"C\" void __deregister_frame(void*);\n\ntemplate <typename callback>\nstatic void processFDEs(const char *EHFrameAddr, size_t EHFrameSize, callback f)\n{\n    const char *P = EHFrameAddr;\n    const char *End = P + EHFrameSize;\n    do {\n        const char *Entry = P;\n        P += 4;\n        assert(P <= End);\n        uint32_t Length = *(const uint32_t*)Entry;\n        // Length == 0: Terminator\n        if (Length == 0)\n            break;\n        assert(P + Length <= End);\n        uint32_t Offset = *(const uint32_t*)P;\n        // Offset == 0: CIE\n        if (Offset != 0)\n            f(Entry);\n        P += Length;\n    } while (P != End);\n}\n#endif\n\n#if defined(_OS_DARWIN_) && defined(LLVM37) && defined(LLVM_SHLIB)\n\n/*\n * We use a custom unwinder, so we need to make sure that when registering dynamic\n * frames, we do so with our unwinder rather than with the system one. If LLVM is\n * statically linked everything works out fine, but if it's dynamically linked\n * it would usually pick up the system one, so we need to do the registration\n * ourselves to ensure the right one gets picked.\n */\n\nstatic void (*libc_register_frame)(void*)   = NULL;\nstatic void (*libc_deregister_frame)(void*) = NULL;\n\n// This implementation handles frame registration for local targets.\nvoid register_eh_frames(uint8_t *Addr, size_t Size)\n{\n  // On OS X OS X __register_frame takes a single FDE as an argument.\n  // See http://lists.cs.uiuc.edu/pipermail/llvmdev/2013-April/061768.html\n  processFDEs((char*)Addr, Size, [](const char *Entry) {\n        if (!libc_register_frame) {\n          libc_register_frame = (void(*)(void*))dlsym(RTLD_NEXT,\"__register_frame\");\n        }\n        assert(libc_register_frame);\n        libc_register_frame(const_cast<char *>(Entry));\n        __register_frame(const_cast<char *>(Entry));\n    });\n}\n\nvoid deregister_eh_frames(uint8_t *Addr, size_t Size)\n{\n   processFDEs((char*)Addr, Size, [](const char *Entry) {\n        if (!libc_deregister_frame) {\n          libc_deregister_frame = (void(*)(void*))dlsym(RTLD_NEXT,\"__deregister_frame\");\n        }\n        assert(libc_deregister_frame);\n        libc_deregister_frame(const_cast<char *>(Entry));\n        __deregister_frame(const_cast<char *>(Entry));\n    });\n}\n\n#elif defined(_OS_LINUX_) && defined(LLVM37) && defined(JL_UNW_HAS_FORMAT_IP)\n#include <type_traits>\n\nstruct unw_table_entry\n{\n    int32_t start_ip_offset;\n    int32_t fde_offset;\n};\n\n// Skip over an arbitrary long LEB128 encoding.\n// Return the pointer to the first unprocessed byte.\nstatic const uint8_t *consume_leb128(const uint8_t *Addr, const uint8_t *End)\n{\n    const uint8_t *P = Addr;\n    while ((*P >> 7) != 0 && P < End)\n        ++P;\n    return P + 1;\n}\n\n// Parse a LEB128 encoding to a type T. Truncate the result if there's more\n// bytes than what there are more bytes than what the type can store.\n// Adjust the pointer to the first unprocessed byte.\ntemplate<typename T> static T parse_leb128(const uint8_t *&Addr,\n                                           const uint8_t *End)\n{\n    typedef typename std::make_unsigned<T>::type uT;\n    uT v = 0;\n    for (unsigned i = 0;i < ((sizeof(T) * 8 - 1) / 7 + 1);i++) {\n        uint8_t a = *Addr;\n        Addr++;\n        v |= uT(a & 0x7f) << (i * 7);\n        if ((a & 0x80) == 0 || Addr >= End) {\n            if (a & 0x40 && std::is_signed<T>::value) {\n                int valid_bits = (i + 1) * 7;\n                if (valid_bits < 64) {\n                    v |= -(uT(1) << valid_bits);\n                }\n            }\n            return T(v);\n        }\n    }\n    Addr = consume_leb128(Addr, End);\n    return T(v);\n}\n\ntemplate <typename U, typename T>\nstatic U safe_trunc(T t)\n{\n    assert((t >= static_cast<T>(std::numeric_limits<U>::min()))\n           && (t <= static_cast<T>(std::numeric_limits<U>::max())));\n    return static_cast<U>(t);\n}\n\n// How the address and size in the FDE are encoded.\nenum DW_EH_PE : uint8_t {\n    DW_EH_PE_absptr = 0x00, /* An absolute pointer. The size is determined by\n                             * whether this is a 32-bit or 64-bit address space,\n                             * and will be 32 or 64 bits */\n    DW_EH_PE_omit = 0xff, // The value is omitted\n    DW_EH_PE_uleb128 = 0x01, // The value is an unsigned LEB128\n    DW_EH_PE_udata2 = 0x02,\n    DW_EH_PE_udata4 = 0x03,\n    DW_EH_PE_udata8 = 0x04, /* The value is stored as unsigned data with the\n                             * specified number of bytes. */\n    DW_EH_PE_signed = 0x08, /* A signed number. The size is determined by\n                             * whether this is a 32-bit or 64-bit address space */\n    DW_EH_PE_sleb128 = 0x09, /* A signed LEB128. */\n    DW_EH_PE_sdata2 = 0x0a,\n    DW_EH_PE_sdata4 = 0x0b,\n    DW_EH_PE_sdata8 = 0x0c, /* The value is stored as signed data with the\n                             * specified number of bytes. */\n\n    // In addition the above basic encodings, there are modifiers.\n\n    DW_EH_PE_pcrel = 0x10, // Value is PC relative.\n\n    // We currently don't support the following once.\n    DW_EH_PE_textrel = 0x20, // Value is text relative.\n    DW_EH_PE_datarel = 0x30, // Value is data relative.\n    DW_EH_PE_funcrel = 0x40, // Value is relative to start of function.\n    DW_EH_PE_aligned = 0x50, /* Value is aligned: padding bytes are inserted as\n                              * required to make value be naturally aligned. */\n    DW_EH_PE_indirect = 0x80 /* This is actually the address of the real value. */\n};\n\n// Parse the CIE and return the type of encoding used by FDE\nstatic DW_EH_PE parseCIE(const uint8_t *Addr, const uint8_t *End)\n{\n    // http://www.airs.com/blog/archives/460\n    // Length (4 bytes)\n    uint32_t cie_size = *(const uint32_t*)Addr;\n    const uint8_t *cie_addr = Addr + 4;\n    const uint8_t *p = cie_addr;\n    const uint8_t *cie_end = cie_addr + cie_size;\n    assert(cie_end <= End);\n    // Check this is an CIE record (CIE ID: 4 bytes)\n    assert(*(const uint32_t*)cie_addr == 0);\n    p += 4;\n    // Check CIE version (1 byte)\n    uint8_t cie_version = *p;\n    assert(cie_version == 1 || cie_version == 3);\n    p++;\n    // Augmentation String (NUL terminate)\n    const char *augmentation = (const char*)p;\n    size_t augmentation_len = strlen(augmentation);\n    // Assume there's no EH Data field, which exist when the augmentation\n    // string has \"eh\" in it.\n    p += augmentation_len + 1;\n    // Code Alignment Factor (1 byte)\n    // should always be 1 on x86, 4 on PPC, etc.\n    // (used for DW_CFA_advance_loc / not used here)\n    //assert(*p == 1);\n    p++;\n    // Data Alignment Factor (LEB128)\n    assert(cie_end >= p);\n    p = consume_leb128(p, cie_end);\n    // return address register\n    if (cie_version == 1) {\n        p++;\n    }\n    else {\n        p = consume_leb128(p, cie_end);\n    }\n    // Now it's the augmentation data. which may have the information we\n    // are interested in...\n    for (const char *augp = augmentation;;augp++) {\n        switch (*augp) {\n        case 'z':\n            // Augmentation Length\n            p = consume_leb128(p, cie_end);\n            break;\n        case 'L':\n            // LSDA encoding\n            p++;\n            break;\n        case 'R':\n            // .... the only one we care about ....\n            return static_cast<DW_EH_PE>(*p);\n        case 'P': {\n            // Personality data\n            // Encoding\n            auto encoding = static_cast<DW_EH_PE>(*p);\n            p++;\n            // Personality function\n            switch (encoding & 0xf) {\n            case DW_EH_PE_uleb128:\n            case DW_EH_PE_sleb128:\n                p = consume_leb128(p, cie_end);\n                break;\n            case DW_EH_PE_udata2:\n            case DW_EH_PE_sdata2:\n                p += 2;\n                break;\n            case DW_EH_PE_udata4:\n            case DW_EH_PE_sdata4:\n                p += 4;\n                break;\n            case DW_EH_PE_udata8:\n            case DW_EH_PE_sdata8:\n                p += 8;\n                break;\n            case DW_EH_PE_signed:\n                p += sizeof(void*);\n                break;\n            default:\n                if (encoding == DW_EH_PE_absptr || encoding == DW_EH_PE_omit) {\n                    p += sizeof(void*);\n                }\n                else {\n                    assert(0 && \"Invalid personality encoding.\");\n                }\n                break;\n            }\n        }\n            break;\n        default:\n            continue;\n        }\n        assert(cie_end >= p);\n    }\n    return DW_EH_PE_absptr;\n}\n\nvoid register_eh_frames(uint8_t *Addr, size_t Size)\n{\n#ifndef _CPU_ARM_\n    // System unwinder\n    // Linux uses setjmp/longjmp exception handling on ARM.\n    __register_frame(Addr);\n#endif\n    // Our unwinder\n    unw_dyn_info_t *di = new unw_dyn_info_t;\n    // In a shared library, this is set to the address of the PLT.\n    // For us, just put 0 to emulate a static library. This field does\n    // not seem to be used on our supported architectures.\n    di->gp = 0;\n    // I'm not a great fan of the naming of this constant, but it means the\n    // right thing, which is a table of FDEs and ips.\n    di->format = UNW_INFO_FORMAT_IP_OFFSET;\n    di->u.rti.name_ptr = 0;\n    di->u.rti.segbase = (unw_word_t)Addr;\n    // Now first count the number of FDEs\n    size_t nentries = 0;\n    processFDEs((char*)Addr, Size, [&](const char*){ nentries++; });\n\n    uintptr_t start_ip = (uintptr_t)-1;\n    uintptr_t end_ip = 0;\n\n    // Then allocate a table and fill in the information\n    // While we're at it, also record the start_ip and size,\n    // which we fill in the table\n    unw_table_entry *table = new unw_table_entry[nentries];\n    std::vector<uintptr_t> start_ips(nentries);\n    size_t cur_entry = 0;\n    // Cache the previously parsed CIE entry so that we can support multiple\n    // CIE's (may not happen) without parsing it everytime.\n    const uint8_t *cur_cie = nullptr;\n    DW_EH_PE encoding = DW_EH_PE_omit;\n    processFDEs((char*)Addr, Size, [&](const char *Entry) {\n            // Skip Length (4bytes) and CIE offset (4bytes)\n            uint32_t fde_size = *(const uint32_t*)Entry;\n            uint32_t cie_id = ((const uint32_t*)Entry)[1];\n            const uint8_t *cie_addr = (const uint8_t*)(Entry + 4 - cie_id);\n            if (cie_addr != cur_cie)\n                encoding = parseCIE(cie_addr, Addr + Size);\n            const uint8_t *fde_end = (const uint8_t*)(Entry + 4 + fde_size);\n            const uint8_t *EntryPtr = (const uint8_t*)(Entry + 8);\n            uintptr_t start = 0;\n            uintptr_t size = 0;\n            // The next two fields are address and size of the PC range\n            // covered by this FDE.\n            if (encoding == DW_EH_PE_absptr || encoding == DW_EH_PE_omit) {\n                assert(fde_size >= 2 * sizeof(void*) + 4);\n                start = *(const uintptr_t*)EntryPtr;\n                size = *(const uintptr_t*)(EntryPtr + sizeof(void*));\n            }\n            else {\n                uintptr_t baseptr = (uintptr_t)EntryPtr;\n                // Only support pcrel for now...\n                assert((encoding & 0xf0) == 0x10 &&\n                       \"Only pcrel mode is supported\");\n                switch (encoding & 0xf) {\n                case DW_EH_PE_uleb128:\n                    start = baseptr + parse_leb128<uintptr_t>(EntryPtr, fde_end);\n                    size = parse_leb128<uintptr_t>(EntryPtr, fde_end);\n                    break;\n                case DW_EH_PE_udata2:\n                    assert(fde_size >= 2 * 2 + 4);\n                    start = baseptr + ((const uint16_t*)EntryPtr)[0];\n                    size = ((const uint16_t*)EntryPtr)[1];\n                    break;\n                case DW_EH_PE_udata4:\n                    assert(fde_size >= 2 * 4 + 4);\n                    start = baseptr + ((const uint32_t*)EntryPtr)[0];\n                    size = ((const uint32_t*)EntryPtr)[1];\n                    break;\n                case DW_EH_PE_udata8:\n                    assert(fde_size >= 2 * 8 + 4);\n                    start = uintptr_t(baseptr + ((const uint64_t*)EntryPtr)[0]);\n                    size = uintptr_t(((const uint64_t*)EntryPtr)[1]);\n                    break;\n                case DW_EH_PE_signed:\n                    assert(fde_size >= 2 * sizeof(void*) + 4);\n                    start = baseptr + ((const intptr_t*)EntryPtr)[0];\n                    size = ((const intptr_t*)EntryPtr)[1];\n                    break;\n                case DW_EH_PE_sleb128:\n                    start = baseptr + parse_leb128<intptr_t>(EntryPtr, fde_end);\n                    size = parse_leb128<intptr_t>(EntryPtr, fde_end);\n                    break;\n                case DW_EH_PE_sdata2:\n                    assert(fde_size >= 2 * 2 + 4);\n                    start = baseptr + ((const int16_t*)EntryPtr)[0];\n                    size = ((const int16_t*)EntryPtr)[1];\n                    break;\n                case DW_EH_PE_sdata4:\n                    assert(fde_size >= 2 * 4 + 4);\n                    start = baseptr + ((const int32_t*)EntryPtr)[0];\n                    size = ((const int32_t*)EntryPtr)[1];\n                    break;\n                case DW_EH_PE_sdata8:\n                    assert(fde_size >= 2 * 8 + 4);\n                    start = uintptr_t(baseptr + ((const int64_t*)EntryPtr)[0]);\n                    size = uintptr_t(((const int64_t*)EntryPtr)[1]);\n                    break;\n                default:\n                    assert(0 && \"Invalid FDE encoding.\");\n                    break;\n                }\n            }\n\n            if (start < start_ip)\n                start_ip = start;\n            if (end_ip < (start + size))\n                end_ip = start + size;\n            table[cur_entry].fde_offset =\n                safe_trunc<int32_t>((intptr_t)Entry - (intptr_t)Addr);\n            start_ips[cur_entry] = start;\n            cur_entry++;\n        });\n    for (size_t i = 0;i < nentries;i++) {\n        table[i].start_ip_offset =\n            safe_trunc<int32_t>((intptr_t)start_ips[i] - (intptr_t)start_ip);\n    }\n    assert(end_ip != 0);\n\n    di->u.rti.table_len = nentries * sizeof(*table) / sizeof(unw_word_t);\n    di->u.rti.table_data = (unw_word_t)table;\n    di->start_ip = start_ip;\n    di->end_ip = end_ip;\n\n    _U_dyn_register(di);\n}\n\nvoid deregister_eh_frames(uint8_t *Addr, size_t Size)\n{\n#ifndef _CPU_ARM_\n    __deregister_frame(Addr);\n#endif\n    // Deregistering with our unwinder requires a lookup table to find the\n    // the allocated entry above (or we could look in libunwind's internal\n    // data structures).\n}\n\n#else\n\nvoid register_eh_frames(uint8_t *Addr, size_t Size)\n{\n}\n\nvoid deregister_eh_frames(uint8_t *Addr, size_t Size)\n{\n}\n\n#endif\n\n#ifdef USE_MCJIT\nextern \"C\"\nuint64_t jl_getUnwindInfo(uint64_t dwAddr)\n{\n    // Might be called from unmanaged thread\n    std::map<size_t, ObjectInfo, revcomp> &objmap = jl_jit_events->getObjectMap();\n    std::map<size_t, ObjectInfo, revcomp>::iterator it = objmap.lower_bound(dwAddr);\n    uint64_t ipstart = 0; // ip of the start of the section (if found)\n    if (it != objmap.end() && dwAddr < it->first + it->second.SectionSize) {\n        ipstart = (uint64_t)(uintptr_t)(*it).first;\n    }\n    uv_rwlock_rdunlock(&threadsafe);\n    return ipstart;\n}\n#else\nextern \"C\"\nuint64_t jl_getUnwindInfo(uint64_t dwAddr)\n{\n    // Might be called from unmanaged thread\n    std::map<size_t, FuncInfo, revcomp> &info = jl_jit_events->getMap();\n    std::map<size_t, FuncInfo, revcomp>::iterator it = info.lower_bound(dwAddr);\n    uint64_t ipstart = 0; // ip of the first instruction in the function (if found)\n    if (it != info.end() && (uintptr_t)(*it).first + (*it).second.lengthAdr > dwAddr) {\n        ipstart = (uint64_t)(uintptr_t)(*it).first;\n    }\n    uv_rwlock_rdunlock(&threadsafe);\n    return ipstart;\n}\n#endif\n\n\n#if defined(_OS_WINDOWS_) && !defined(USE_MCJIT) && defined(_CPU_X86_64_)\n// Custom memory manager for exception handling on Windows\n// we overallocate 48 bytes at the end of each function\n// for unwind information (see NotifyFunctionEmitted)\nclass JITMemoryManagerWin : public JITMemoryManager {\nprivate:\n    JITMemoryManager *JMM;\npublic:\n    JITMemoryManagerWin() : JITMemoryManager()\n    {\n        JMM = JITMemoryManager::CreateDefaultMemManager();\n    }\n    virtual void setMemoryWritable() { return JMM->setMemoryWritable(); }\n    virtual void setMemoryExecutable() { return JMM->setMemoryExecutable(); }\n    virtual void setPoisonMemory(bool poison) { return JMM->setPoisonMemory(poison); }\n    virtual void AllocateGOT() { JMM->AllocateGOT(); HasGOT = true; }\n    virtual uint8_t *getGOTBase() const { return JMM->getGOTBase(); }\n    virtual uint8_t *startFunctionBody(const Function *F, uintptr_t &ActualSize)\n    {\n        if (ActualSize == 0)\n            ActualSize += 64;\n        ActualSize += 48;\n        uint8_t *mem = JMM->startFunctionBody(F,ActualSize);\n        ActualSize -= 48;\n        return mem;\n    }\n    virtual uint8_t *allocateStub(const GlobalValue *F, unsigned StubSize, unsigned Alignment)\n    {\n        return JMM->allocateStub(F,StubSize,Alignment);\n    }\n    virtual void endFunctionBody(const Function *F, uint8_t *FunctionStart, uint8_t *FunctionEnd)\n    {\n        FunctionEnd[0] = 0;\n        JMM->endFunctionBody(F,FunctionStart,FunctionEnd+48);\n    }\n    virtual uint8_t *allocateSpace(intptr_t Size, unsigned Alignment) { return JMM->allocateSpace(Size,Alignment); }\n    virtual uint8_t *allocateGlobal(uintptr_t Size, unsigned Alignment) { return JMM->allocateGlobal(Size,Alignment); }\n    virtual void deallocateFunctionBody(void *Body) { return JMM->deallocateFunctionBody(Body); }\n    virtual uint8_t *startExceptionTable(const Function *F,\n                                         uintptr_t &ActualSize) { return JMM->startExceptionTable(F,ActualSize); }\n    virtual void endExceptionTable(const Function *F, uint8_t *TableStart,\n                                   uint8_t *TableEnd, uint8_t *FrameRegister) { return JMM->endExceptionTable(F,TableStart,TableEnd,FrameRegister); }\n    virtual void deallocateExceptionTable(void *ET) { return JMM->deallocateExceptionTable(ET); }\n    virtual bool CheckInvariants(std::string &str) { return JMM->CheckInvariants(str); }\n    virtual size_t GetDefaultCodeSlabSize() { return JMM->GetDefaultCodeSlabSize(); }\n    virtual size_t GetDefaultDataSlabSize() { return JMM->GetDefaultDataSlabSize(); }\n    virtual size_t GetDefaultStubSlabSize() { return JMM->GetDefaultStubSlabSize(); }\n    virtual unsigned GetNumCodeSlabs() { return JMM->GetNumCodeSlabs(); }\n    virtual unsigned GetNumDataSlabs() { return JMM->GetNumDataSlabs(); }\n    virtual unsigned GetNumStubSlabs() { return JMM->GetNumStubSlabs(); }\n\n#ifdef LLVM35\n    virtual uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,\n                                         unsigned SectionID, llvm::StringRef SectionName)\n    {\n        uint8_t *mem = JMM->allocateCodeSection(Size+48, Alignment, SectionID, SectionName);\n        mem[Size] = 0;\n        return mem;\n    }\n    virtual uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n                                         unsigned SectionID, llvm::StringRef SectionName, bool IsReadOnly)\n    {\n        return JMM->allocateDataSection(Size,Alignment,SectionID,SectionName,IsReadOnly);\n    }\n#else\n    virtual uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment, unsigned SectionID)\n    {\n        uint8_t *mem = JMM->allocateCodeSection(Size+48, Alignment, SectionID);\n        mem[Size] = 0;\n        return mem;\n    }\n    virtual uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n                                         unsigned SectionID, bool IsReadOnly)\n    {\n        return JMM->allocateDataSection(Size,Alignment,SectionID,IsReadOnly);\n    }\n#endif\n    virtual void *getPointerToNamedFunction(const std::string &Name, bool AbortOnFailure = true)\n    {\n        return JMM->getPointerToNamedFunction(Name,AbortOnFailure);\n    }\n    virtual bool applyPermissions(std::string *ErrMsg = 0) { return JMM->applyPermissions(ErrMsg); }\n    virtual void registerEHFrames(StringRef SectionData) { return JMM->registerEHFrames(SectionData); }\n};\nJITMemoryManager *createJITMemoryManagerWin()\n{\n    return new JITMemoryManagerWin();\n}\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/codegen.cpp": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n#include \"llvm-version.h\"\n#include \"platform.h\"\n#include \"options.h\"\n#if defined(_OS_WINDOWS_) && !defined(LLVM39)\n// trick pre-llvm39 into skipping the generation of _chkstk calls\n//   since it has some codegen issues associated with them:\n//   (a) assumed to be within 32-bit offset\n//   (b) bad asm is generated for certain code patterns:\n//       see https://github.com/JuliaLang/julia/pull/11644#issuecomment-112276813\n// also, use ELF because RuntimeDyld COFF I686 support didn't exist\n// also, use ELF because RuntimeDyld COFF X86_64 doesn't seem to work (fails to generate function pointers)?\n#define FORCE_ELF\n#endif\n#if defined(_CPU_X86_)\n#define JL_NEED_FLOATTEMP_VAR 1\n#endif\n\n#ifndef __STDC_LIMIT_MACROS\n#define __STDC_LIMIT_MACROS\n#define __STDC_CONSTANT_MACROS\n#endif\n\n#include <setjmp.h>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <map>\n#include <vector>\n#include <set>\n#include <cstdio>\n#include <cassert>\n#include <iostream>\n\n// target machine computation\n#include <llvm/Target/TargetSubtargetInfo.h>\n#include <llvm/Support/TargetRegistry.h>\n#ifndef LLVM37\n#include <llvm/Target/TargetLibraryInfo.h>\n#endif\n#include <llvm/Target/TargetOptions.h>\n#include <llvm/Support/Host.h>\n#include <llvm/Support/TargetSelect.h>\n#ifdef LLVM37\n#include <llvm/Analysis/TargetLibraryInfo.h>\n#endif\n\n#ifdef LLVM37\n#include <llvm/Object/SymbolSize.h>\n#endif\n\n// IR building\n#include <llvm/IR/IntrinsicInst.h>\n#ifdef LLVM35\n#include <llvm/Object/ObjectFile.h>\n#include <llvm/IR/DIBuilder.h>\n#include <llvm/AsmParser/Parser.h>\n#else\n#include <llvm/Assembly/Parser.h>\n#endif\n#include <llvm/DebugInfo/DIContext.h>\n#include <llvm/IR/DerivedTypes.h>\n#include <llvm/IR/Intrinsics.h>\n#include <llvm/IR/Attributes.h>\n#include <llvm/IR/IRBuilder.h>\n#include <llvm/IR/MDBuilder.h>\n#ifndef LLVM35\n#include <llvm/DebugInfo.h>\n#include <llvm/DIBuilder.h>\n#endif\n\n// support\n#include <llvm/Support/raw_ostream.h>\n#include <llvm/Support/FormattedStream.h>\n#include <llvm/Support/SourceMgr.h> // for llvmcall\n#include <llvm/Transforms/Utils/Cloning.h> // for llvmcall inlining\n#ifdef LLVM35\n#include <llvm/IR/Verifier.h> // for llvmcall validation\n#else\n#include <llvm/Analysis/Verifier.h>\n#endif\n\n// for configuration options\n#include <llvm/Support/PrettyStackTrace.h>\n#include <llvm/Support/CommandLine.h>\n\n#if defined(_CPU_ARM_) || defined(_CPU_AARCH64_)\n#  include <llvm/IR/InlineAsm.h>\n#endif\n#if defined(USE_POLLY)\n#include <polly/RegisterPasses.h>\n#include <polly/ScopDetection.h>\n#endif\n\nusing namespace llvm;\nnamespace llvm {\n    extern bool annotateSimdLoop(BasicBlock *latch);\n}\n\n#if defined(_OS_WINDOWS_) && !defined(NOMINMAX)\n#define NOMINMAX\n#endif\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"jitlayers.h\"\n#include \"codegen_internal.h\"\n\n// LLVM version compatibility macros\n#ifdef LLVM37\nlegacy::PassManager *jl_globalPM;\n#define LLVM37_param(x) (x),\n#else\n#define LLVM37_param(x)\nPassManager *jl_globalPM;\n#endif\n\n#ifndef LLVM35\n#define AddrSpaceCastInst BitCastInst\n#endif\n\n#if !defined(_COMPILER_MICROSOFT_) && __cplusplus < 201103L && !defined(static_assert)\n#  define static_assert(...)\n#endif\n\nextern \"C\" {\n\n#include \"builtin_proto.h\"\n\n#ifdef HAVE_SSP\nextern uintptr_t __stack_chk_guard;\nextern void __stack_chk_fail();\n#else\nJL_DLLEXPORT uintptr_t __stack_chk_guard = (uintptr_t)0xBAD57ACCBAD67ACC; // 0xBADSTACKBADSTACK\nJL_DLLEXPORT void __stack_chk_fail()\n{\n    /* put your panic function or similar in here */\n    fprintf(stderr, \"fatal error: stack corruption detected\\n\");\n    gc_debug_critical_error();\n    abort(); // end with abort, since the compiler destroyed the stack upon entry to this function, there's no going back now\n}\n#endif\n\n#ifdef _OS_WINDOWS_\n#if defined(_CPU_X86_64_)\n#if defined(_COMPILER_MINGW_)\nextern void ___chkstk_ms(void);\n#else\nextern void __chkstk(void);\n#endif\n#else\n#if defined(_COMPILER_MINGW_)\n#undef _alloca\nextern void _alloca(void);\n#else\nextern void _chkstk(void);\n#endif\n#endif\n//void *force_chkstk(void) {\n//    return alloca(40960);\n//}\n#endif\n}\n\n#if defined(_COMPILER_MICROSOFT_) && !defined(__alignof__)\n#define __alignof__ __alignof\n#endif\n\n#define DISABLE_FLOAT16\n\n// llvm state\n#ifdef LLVM39\nJL_DLLEXPORT LLVMContext jl_LLVMContext;\n#else\nJL_DLLEXPORT LLVMContext &jl_LLVMContext = getGlobalContext();\n#endif\nstatic IRBuilder<> builder(jl_LLVMContext);\nstatic bool nested_compile = false;\nTargetMachine *jl_TargetMachine;\n\nextern JITEventListener *CreateJuliaJITEventListener();\n\n// for image reloading\nbool imaging_mode = false;\n\nModule *shadow_output;\n#define jl_Module ctx->f->getParent()\n#define jl_builderModule builder.GetInsertBlock()->getParent()->getParent()\nstatic MDBuilder *mbuilder;\n\n#ifdef LLVM37\n// No DataLayout pass needed anymore.\n#elif defined(LLVM35)\nstatic DataLayoutPass *jl_data_layout;\n#else\nstatic DataLayout *jl_data_layout;\n#endif\n\n// types\nstatic Type *T_jlvalue;\nstatic Type *T_pjlvalue;\nstatic Type *T_ppjlvalue;\nstatic Type *jl_parray_llvmt;\nstatic FunctionType *jl_func_sig;\nstatic FunctionType *jl_func_sig_sparams;\nstatic Type *T_pvoidfunc;\n\nstatic IntegerType *T_int1;\nstatic IntegerType *T_int8;\nstatic IntegerType *T_int16;\nstatic IntegerType *T_int32;\nstatic IntegerType *T_int64;\n\nstatic IntegerType *T_uint8;\nstatic IntegerType *T_uint16;\nstatic IntegerType *T_uint32;\nstatic IntegerType *T_uint64;\n\nstatic IntegerType *T_char;\nstatic IntegerType *T_size;\nstatic IntegerType *T_sigatomic;\n\nstatic Type *T_float16;\nstatic Type *T_float32;\nstatic Type *T_float64;\nstatic Type *T_float128;\n\nstatic Type *T_pint8;\nstatic Type *T_pint16;\nstatic Type *T_pint32;\nstatic Type *T_pint64;\nstatic Type *T_psize;\nstatic Type *T_pfloat32;\nstatic Type *T_pfloat64;\n\nstatic Type *T_ppint8;\nstatic Type *T_pppint8;\n\nstatic Type *T_void;\n\n// type-based alias analysis nodes.  Indentation of comments indicates hierarchy.\nMDNode *tbaa_gcframe;           // GC frame\n// LLVM should have enough info for alias analysis of non-gcframe stack slot\n// this is mainly a place holder for `jl_cgval_t::tbaa`\nstatic MDNode *tbaa_stack;      // stack slot\nstatic MDNode *tbaa_data;       // Any user data that `pointerset/ref` are allowed to alias\nstatic MDNode *tbaa_tag;            // Type tag\nstatic MDNode *tbaa_binding;        // jl_binding_t::value\nstatic MDNode *tbaa_value;          // jl_value_t, that is not jl_array_t\nstatic MDNode *tbaa_mutab;              // mutable type\nstatic MDNode *tbaa_immut;              // immutable type\nstatic MDNode *tbaa_arraybuf;       // Data in an array\nstatic MDNode *tbaa_array;      // jl_array_t\nstatic MDNode *tbaa_arrayptr;       // The pointer inside a jl_array_t\nstatic MDNode *tbaa_arraysize;      // A size in a jl_array_t\nstatic MDNode *tbaa_arraylen;       // The len in a jl_array_t\nstatic MDNode *tbaa_arrayflags;     // The flags in a jl_array_t\nMDNode *tbaa_const;             // Memory that is immutable by the time LLVM can see it\n\n// Basic DITypes\n#ifdef LLVM37\nstatic DICompositeType *jl_value_dillvmt;\nstatic DIDerivedType *jl_pvalue_dillvmt;\nstatic DIDerivedType *jl_ppvalue_dillvmt;\nstatic DISubroutineType *jl_di_func_sig;\n#else\nstatic DICompositeType jl_value_dillvmt;\nstatic DIDerivedType jl_pvalue_dillvmt;\nstatic DIDerivedType jl_ppvalue_dillvmt;\n#ifdef LLVM36\nDISubroutineType jl_di_func_sig;\n#else\nDICompositeType jl_di_func_sig;\n#endif\n#endif\n\n// constants\nstatic Value *V_null;\nstatic Type *NoopType;\nstatic Value *literal_pointer_val(jl_value_t *p);\nextern \"C\" {\nJL_DLLEXPORT Type *julia_type_to_llvm(jl_value_t *jt, bool *isboxed=NULL);\n}\nstatic bool type_is_ghost(Type *ty)\n{\n    return (ty == T_void || ty->isEmptyTy());\n}\n\n// global vars\nstatic GlobalVariable *jlRTLD_DEFAULT_var;\n#ifdef _OS_WINDOWS_\nstatic GlobalVariable *jlexe_var;\nstatic GlobalVariable *jldll_var;\n#if defined(_CPU_X86_64_) && !defined(USE_MCJIT)\nJITMemoryManager *createJITMemoryManagerWin();\n#endif\n#endif //_OS_WINDOWS_\n\nstatic Function *jltls_states_func;\n#ifndef JULIA_ENABLE_THREADING\nstatic GlobalVariable *jltls_states_var;\n#else\n// Imaging mode only\nstatic GlobalVariable *jltls_states_func_ptr = NULL;\nsize_t jltls_states_func_idx = 0;\n#endif\n\n// important functions\nstatic Function *jlnew_func;\nstatic Function *jlthrow_func;\nstatic Function *jlerror_func;\nstatic Function *jltypeerror_func;\nstatic Function *jlundefvarerror_func;\nstatic Function *jlboundserror_func;\nstatic Function *jluboundserror_func;\nstatic Function *jlvboundserror_func;\nstatic Function *jlboundserrorv_func;\nstatic Function *jlcheckassign_func;\nstatic Function *jldeclareconst_func;\nstatic Function *jlgetbindingorerror_func;\nstatic Function *jlpref_func;\nstatic Function *jlpset_func;\nstatic Function *jltopeval_func;\nstatic Function *jlcopyast_func;\nstatic Function *jltuple_func;\nstatic Function *jlnsvec_func;\nstatic Function *jlapplygeneric_func;\nstatic Function *jlinvoke_func;\nstatic Function *jlapply2va_func;\nstatic Function *jlgetfield_func;\nstatic Function *jlmethod_func;\nstatic Function *jlgenericfunction_func;\nstatic Function *jlenter_func;\nstatic Function *jlleave_func;\nstatic Function *jlegal_func;\nstatic Function *jlalloc_pool_func;\nstatic Function *jlalloc_big_func;\nstatic Function *jlsubtype_func;\nstatic Function *setjmp_func;\nstatic Function *memcmp_func;\nstatic Function *box_int8_func;\nstatic Function *box_uint8_func;\nstatic Function *box_int16_func;\nstatic Function *box_uint16_func;\nstatic Function *box_int32_func;\nstatic Function *box_char_func;\nstatic Function *box_uint32_func;\nstatic Function *box_int64_func;\nstatic Function *box_uint64_func;\nstatic Function *box_float32_func;\nstatic Function *box_float64_func;\nstatic Function *box_ssavalue_func;\nstatic Function *box8_func;\nstatic Function *box16_func;\nstatic Function *box32_func;\nstatic Function *box64_func;\nstatic Function *queuerootfun;\nstatic Function *expect_func;\nstatic Function *jldlsym_func;\nstatic Function *jlnewbits_func;\nstatic Function *jltypeassert_func;\n#ifndef LLVM36\nstatic Function *jlpow_func;\nstatic Function *jlpowf_func;\n#endif\n//static Function *jlgetnthfield_func;\nstatic Function *jlgetnthfieldchecked_func;\n//static Function *jlsetnthfield_func;\n#ifdef _OS_WINDOWS_\nstatic Function *resetstkoflw_func;\n#if defined(_CPU_X86_64_)\nFunction *juliapersonality_func;\n#endif\n#endif\nstatic Function *diff_gc_total_bytes_func;\nstatic Function *jlarray_data_owner_func;\n\n// placeholder functions\nstatic Function *gcroot_func;\nstatic Function *gckill_func;\nstatic Function *jlcall_frame_func;\nstatic Function *gcroot_flush_func;\n\nstatic std::vector<Type *> two_pvalue_llvmt;\nstatic std::vector<Type *> three_pvalue_llvmt;\nstatic std::vector<Type *> four_pvalue_llvmt;\n\nstatic std::map<jl_fptr_t, Function*> builtin_func_map;\n\n// --- code generation ---\nextern \"C\" {\n    int globalUnique = 0;\n}\n\n// metadata tracking for a llvm Value* during codegen\nstruct jl_cgval_t {\n    Value *V; // may be of type T* or T, or set to NULL if ghost (or if the value has not been initialized yet, for a variable definition)\n    jl_value_t *constant; // constant value (rooted in linfo.def.roots)\n    Value *gcroot; // the gcroot associated with V (if it has one)\n    jl_value_t *typ; // the original type of V, never NULL\n    bool isboxed; // whether this value is a jl_value_t* allocated on the heap with the right type tag\n    bool isghost; // whether this value is \"ghost\"\n    bool isimmutable; // V points to something that is definitely immutable (e.g. single-assignment, but including memory)\n    MDNode *tbaa; // The related tbaa node. Non-NULL iff this is not a pointer.\n    bool ispointer() const\n    {\n        return tbaa != nullptr;\n    }\n    jl_cgval_t(Value *V, Value *gcroot, bool isboxed, jl_value_t *typ) : // general constructor (with pointer type auto-detect)\n        V(V), // V is allowed to be NULL in a jl_varinfo_t context, but not during codegen contexts\n        constant(NULL),\n        gcroot(gcroot),\n        typ(typ),\n        isboxed(isboxed),\n        isghost(false),\n        isimmutable(isboxed && jl_is_immutable_datatype(typ)),\n        tbaa(isboxed ? (jl_is_leaf_type(typ) ?\n                        (jl_is_mutable(typ) ? tbaa_mutab : tbaa_immut) :\n                        tbaa_value) : nullptr)\n    {\n    }\n    jl_cgval_t(jl_value_t *typ) : // ghost value constructor\n        V(NULL),\n        constant(((jl_datatype_t*)typ)->instance),\n        gcroot(NULL),\n        typ(typ),\n        isboxed(false),\n        isghost(true),\n        isimmutable(true),\n        tbaa(nullptr)\n    {\n        assert(jl_is_datatype(typ));\n        assert(constant);\n    }\n    jl_cgval_t(const jl_cgval_t &v, jl_value_t *typ) : // copy constructor with new type\n        V(v.V),\n        constant(v.constant),\n        gcroot(v.gcroot),\n        typ(typ),\n        isboxed(v.isboxed),\n        isghost(v.isghost),\n        isimmutable(v.isimmutable),\n        tbaa(v.tbaa)\n    {\n        assert(isboxed || v.typ == typ); // expect a badly or equivalently typed version\n    }\n    jl_cgval_t() : // undef / unreachable / default constructor\n        V(UndefValue::get(T_void)),\n        constant(NULL),\n        gcroot(NULL),\n        typ(jl_bottom_type),\n        isboxed(false),\n        isghost(true),\n        isimmutable(true),\n        tbaa(nullptr)\n    {\n    }\n};\n\n// per-local-variable information\nstruct jl_varinfo_t {\n    Value *memloc; // an address, if the var is in a jl_value_t* gc stack slot or jl_box_t* Box object (marked tbaa_const, if appropriate)\n    jl_cgval_t value; // a value, if the var is unboxed or SSA (and thus memloc == NULL)\n#ifdef LLVM37\n    DILocalVariable *dinfo;\n#else\n    DIVariable dinfo;\n#endif\n    bool isSA;\n    bool isVolatile;\n    bool isArgument;\n    bool escapes;\n    bool usedUndef;\n    bool used;\n\n    jl_varinfo_t() : memloc(NULL), value(jl_cgval_t()),\n#ifdef LLVM37\n                     dinfo(NULL),\n#else\n                     dinfo(DIVariable()),\n#endif\n                     isSA(false),\n                     isVolatile(false), isArgument(false),\n                     escapes(true), usedUndef(false), used(false)\n    {\n    }\n};\n\n// aggregate of array metadata\ntypedef struct {\n    Value *dataptr;\n    Value *len;\n    std::vector<Value*> sizes;\n    jl_value_t *ty;\n} jl_arrayvar_t;\n\n// information about the context of a piece of code: its enclosing\n// function and module, and visible local variables and labels.\ntypedef struct {\n    Function *f;\n    // local var info. globals are not in here.\n    std::vector<jl_varinfo_t> slots;\n    std::vector<jl_cgval_t> SAvalues;\n    std::vector<bool> ssavalue_assigned;\n    std::map<int, jl_arrayvar_t> *arrayvars;\n    std::map<int, BasicBlock*> *labels;\n    std::map<int, Value*> *handlers;\n    jl_module_t *module;\n    jl_lambda_info_t *linfo;\n    const char *name;\n    StringRef file;\n    Value *spvals_ptr;\n    Value *argArray;\n    Value *argCount;\n    std::string funcName;\n    int vaSlot;        // name of vararg argument\n    bool vaStack;      // varargs stack-allocated\n    bool sret;\n    int nReqArgs;\n    std::vector<bool> boundsCheck;\n    std::vector<bool> inbounds;\n\n    CallInst *ptlsStates;\n    Value *signalPage;\n\n    llvm::DIBuilder *dbuilder;\n    bool debug_enabled;\n    std::vector<CallInst*> to_inline;\n} jl_codectx_t;\n\nstatic jl_cgval_t emit_expr(jl_value_t *expr, jl_codectx_t *ctx);\n\nstatic Value *emit_local_root(jl_codectx_t *ctx, jl_varinfo_t *vi = NULL);\nstatic void mark_gc_use(const jl_cgval_t &v);\nstatic Value *make_jlcall(ArrayRef<const jl_cgval_t*> args, jl_codectx_t *ctx);\nstatic Value *global_binding_pointer(jl_module_t *m, jl_sym_t *s,\n                                     jl_binding_t **pbnd, bool assign, jl_codectx_t *ctx);\nstatic jl_cgval_t emit_checked_var(Value *bp, jl_sym_t *name, jl_codectx_t *ctx, bool isvol, MDNode *tbaa);\nstatic Value *emit_condition(jl_value_t *cond, const std::string &msg, jl_codectx_t *ctx);\nstatic void allocate_gc_frame(BasicBlock *b0, jl_codectx_t *ctx);\nstatic GlobalVariable *prepare_global(GlobalVariable *G, Module *M = jl_builderModule);\nstatic llvm::Value *prepare_call(llvm::Value *Callee);\n\ntemplate<typename T> static void push_gc_use(T &&vec, const jl_cgval_t &v)\n{\n    if (v.gcroot) {\n        vec.push_back(v.gcroot);\n    }\n}\n\ntemplate<typename T> static void mark_gc_uses(T &&vec)\n{\n    auto f = prepare_call(gckill_func);\n    for (auto &v: vec) {\n        builder.CreateCall(f, v);\n    }\n}\n\n// --- convenience functions for tagging llvm values with julia types ---\n\nstatic AllocaInst *emit_static_alloca(Type *lty, int arraysize, jl_codectx_t *ctx)\n{\n    return new AllocaInst(lty, ConstantInt::get(T_int32, arraysize), \"\", /*InsertBefore=*/ctx->ptlsStates);\n}\nstatic AllocaInst *emit_static_alloca(Type *lty, jl_codectx_t *ctx)\n{\n    return emit_static_alloca(lty, 1, ctx);\n}\nstatic AllocaInst *emit_static_alloca(Type *lty)\n{\n    return new AllocaInst(lty, \"\",\n            /*InsertBefore=*/&*builder.GetInsertBlock()->getParent()->getEntryBlock().getFirstInsertionPt());\n}\n\nstatic inline jl_cgval_t ghostValue(jl_value_t *typ)\n{\n    if (typ == jl_bottom_type)\n        return jl_cgval_t(); // Undef{}\n    return jl_cgval_t(typ);\n}\nstatic inline jl_cgval_t ghostValue(jl_datatype_t *typ)\n{\n    return ghostValue((jl_value_t*)typ);\n}\n\nstatic inline jl_cgval_t mark_julia_slot(Value *v, jl_value_t *typ, MDNode *tbaa)\n{\n    // eagerly put this back onto the stack\n    assert(v->getType() != T_pjlvalue);\n    assert(tbaa);\n    jl_cgval_t tagval(v, NULL, false, typ);\n    tagval.tbaa = tbaa;\n    tagval.isimmutable = true;\n    return tagval;\n}\n\nstatic inline jl_cgval_t mark_julia_type(Value *v, bool isboxed, jl_value_t *typ, jl_codectx_t *ctx, bool needsroot = true)\n{\n    Type *T = julia_type_to_llvm(typ);\n    if (type_is_ghost(T)) {\n        return ghostValue(typ);\n    }\n    if (v && T->isAggregateType() && !isboxed) {\n        assert(v->getType() != T_pjlvalue);\n        // eagerly put this back onto the stack\n        // llvm mem2reg pass will remove this if unneeded\n        Value *loc = emit_static_alloca(T);\n        builder.CreateStore(v, loc);\n        return mark_julia_slot(loc, typ, tbaa_stack);\n    }\n    Value *froot = NULL;\n    if (needsroot && isboxed) {\n        froot = emit_local_root(ctx);\n        builder.CreateStore(v, froot);\n    }\n    return jl_cgval_t(v, froot, isboxed, typ);\n}\n\nstatic inline jl_cgval_t mark_julia_type(Value *v, bool isboxed, jl_datatype_t *typ, jl_codectx_t *ctx, bool needsroot = true)\n{\n    return mark_julia_type(v, isboxed, (jl_value_t*)typ, ctx, needsroot);\n}\n\nstatic inline jl_cgval_t remark_julia_type(const jl_cgval_t &v, jl_value_t *typ)\n{\n    Type *T = julia_type_to_llvm(typ);\n    if (type_is_ghost(T)) {\n        return ghostValue(typ);\n    }\n    return jl_cgval_t(v, typ);\n}\n\nstatic inline jl_cgval_t mark_julia_const(jl_value_t *jv)\n{\n    jl_value_t *typ;\n    if (jl_is_datatype(jv) || jl_is_uniontype(jv) || jl_is_typector(jv))\n        typ = (jl_value_t*)jl_wrap_Type(jv);\n    else\n        typ = jl_typeof(jv);\n    if (type_is_ghost(julia_type_to_llvm(typ))) {\n        return ghostValue(typ);\n    }\n    jl_cgval_t constant(NULL, NULL, true, typ);\n    constant.constant = jv;\n    return constant;\n}\n\n// --- utilities ---\n\nstatic void emit_write_barrier(jl_codectx_t*, Value*, Value*);\n\n#include \"cgutils.cpp\"\n\nstatic void jl_rethrow_with_add(const char *fmt, ...)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    if (jl_typeis(ptls->exception_in_transit, jl_errorexception_type)) {\n        char *str = jl_string_data(jl_fieldref(ptls->exception_in_transit,0));\n        char buf[1024];\n        va_list args;\n        va_start(args, fmt);\n        int nc = vsnprintf(buf, sizeof(buf), fmt, args);\n        va_end(args);\n        nc += snprintf(buf+nc, sizeof(buf)-nc, \": %s\", str);\n        jl_value_t *msg = jl_pchar_to_string(buf, nc);\n        JL_GC_PUSH1(&msg);\n        jl_throw(jl_new_struct(jl_errorexception_type, msg));\n    }\n    jl_rethrow();\n}\n\nstatic void CreateTrap(IRBuilder<> &builder)\n{\n    Function *f = builder.GetInsertBlock()->getParent();\n    Function *trap_func = Intrinsic::getDeclaration(\n            f->getParent(),\n            Intrinsic::trap);\n    builder.CreateCall(trap_func);\n    builder.CreateUnreachable();\n    BasicBlock *newBB = BasicBlock::Create(builder.getContext(), \"after_noret\", f);\n    builder.SetInsertPoint(newBB);\n}\n\n// --- allocating local variables ---\n\nstatic bool isbits_spec(jl_value_t *jt, bool allow_unsized = true)\n{\n    return jl_isbits(jt) && jl_is_leaf_type(jt) && (allow_unsized ||\n        ((jl_is_bitstype(jt) && jl_datatype_size(jt) > 0) ||\n         (jl_is_datatype(jt) && jl_datatype_nfields(jt)>0)));\n}\n\nstatic bool store_unboxed_p(jl_value_t *jt)\n{\n    return (isbits_spec(jt,false) &&\n        // don't unbox intrinsics, since inference depends on their having\n        // stable addresses for table lookup.\n        jt != (jl_value_t*)jl_intrinsic_type);\n}\n\nstatic bool store_unboxed_p(int s, jl_codectx_t *ctx)\n{\n    jl_varinfo_t &vi = ctx->slots[s];\n    // only store a variable unboxed if type inference has run, which\n    // checks that the variable is not referenced undefined.\n    return (ctx->linfo->inferred && !vi.usedUndef &&\n            // don't unbox vararg tuples\n            s != ctx->vaSlot && store_unboxed_p(vi.value.typ));\n}\n\nstatic jl_sym_t *slot_symbol(int s, jl_codectx_t *ctx)\n{\n    return (jl_sym_t*)jl_array_ptr_ref(ctx->linfo->slotnames, s);\n}\n\nstatic Value *alloc_local(int s, jl_codectx_t *ctx)\n{\n    jl_varinfo_t &vi = ctx->slots[s];\n    jl_value_t *jt = vi.value.typ;\n    assert(store_unboxed_p(s,ctx));\n    Type *vtype = julia_type_to_llvm(jt);\n    assert(vtype != T_pjlvalue);\n    if (type_is_ghost(vtype)) {\n        vi.value = ghostValue(jt);\n        return NULL;\n    }\n    // CreateAlloca is OK here because alloc_local is only called during prologue setup\n    Value *lv = builder.CreateAlloca(vtype, 0, jl_symbol_name(slot_symbol(s,ctx)));\n    vi.value = mark_julia_slot(lv, jt, tbaa_stack);\n    // slot is not immutable if there are multiple assignments\n    vi.value.isimmutable &= (vi.isSA && s >= ctx->linfo->nargs);\n    assert(vi.value.isboxed == false);\n    return lv;\n}\n\nstatic void maybe_alloc_arrayvar(int s, jl_codectx_t *ctx)\n{\n    jl_value_t *jt = ctx->slots[s].value.typ;\n    if (arraytype_constshape(jt)) {\n        // TODO: this optimization does not yet work with 1-d arrays, since the\n        // length and data pointer can change at any time via push!\n        // we could make it work by reloading the metadata when the array is\n        // passed to an external function (ideally only impure functions)\n        jl_arrayvar_t av;\n        int ndims = jl_unbox_long(jl_tparam1(jt));\n        Type *elt = julia_type_to_llvm(jl_tparam0(jt));\n        if (type_is_ghost(elt))\n            return;\n        // CreateAlloca is OK here because maybe_alloc_arrayvar is only called in the prologue setup\n        av.dataptr = builder.CreateAlloca(PointerType::get(elt,0));\n        av.len = builder.CreateAlloca(T_size);\n        for(int i=0; i < ndims-1; i++)\n            av.sizes.push_back(builder.CreateAlloca(T_size));\n        av.ty = jt;\n        (*ctx->arrayvars)[s] = av;\n    }\n}\n\n// Snooping on which functions are being compiled, and how long it takes\nJL_STREAM *dump_compiles_stream = NULL;\nuint64_t last_time = 0;\nextern \"C\" JL_DLLEXPORT\nvoid jl_dump_compiles(void *s)\n{\n    dump_compiles_stream = (JL_STREAM*)s;\n}\n\n// --- entry point ---\n//static int n_emit=0;\nstatic std::unique_ptr<Module> emit_function(jl_lambda_info_t *lam, jl_llvm_functions_t *declarations);\nvoid jl_add_linfo_in_flight(StringRef name, jl_lambda_info_t *linfo, const DataLayout &DL);\n\n// this generates llvm code for the lambda info\n// and adds the result to the jitlayers\n// (and the shadow module), but doesn't yet compile\n// or generate object code for it\n// objective: assign li->functionObject\nextern \"C\" void jl_compile_linfo(jl_lambda_info_t *li)\n{\n    JL_TIMING(CODEGEN);\n    if (li->jlcall_api == 2) {\n        // delete code for functions reduced to a constant\n        jl_set_lambda_code_null(li);\n        return;\n    }\n    // grab the codegen lock and see if this needs to be compiled\n    if (li->functionObjectsDecls.functionObject != NULL) {\n        return;\n    }\n    JL_LOCK(&codegen_lock);\n    if (li->functionObjectsDecls.functionObject != NULL) {\n        JL_UNLOCK(&codegen_lock);\n        return;\n    }\n    // setup global state\n    assert(!li->inInference);\n    li->inCompile = 1;\n    BasicBlock *old = nested_compile ? builder.GetInsertBlock() : NULL;\n    DebugLoc olddl = builder.getCurrentDebugLocation();\n    bool last_n_c = nested_compile;\n    if (!nested_compile && dump_compiles_stream != NULL)\n        last_time = jl_hrtime();\n    nested_compile = true;\n    std::unique_ptr<Module> m;\n    Function *f = NULL, *specf = NULL;\n    // actually do the work of emitting the function\n    JL_TRY {\n        m = emit_function(li, &li->functionObjectsDecls);\n        f = (Function*)li->functionObjectsDecls.functionObject;\n        specf = (Function*)li->functionObjectsDecls.specFunctionObject;\n        //n_emit++;\n    }\n    JL_CATCH {\n        // something failed! this is very bad, since other WIP may be pointing to this function\n        // but there's not much we can do now. try to clear much of the WIP anyways.\n        li->functionObjectsDecls.functionObject = NULL;\n        li->functionObjectsDecls.specFunctionObject = NULL;\n        nested_compile = last_n_c;\n        if (old != NULL) {\n            builder.SetInsertPoint(old);\n            builder.SetCurrentDebugLocation(olddl);\n        }\n        li->inCompile = 0;\n        JL_UNLOCK(&codegen_lock); // Might GC\n        jl_rethrow_with_add(\"error compiling %s\", jl_symbol_name(li->def ? li->def->name : anonymous_sym));\n    }\n    // record that this function name came from this linfo,\n    // so we can build a reverse mapping for debug-info.\n    bool toplevel = li->def == NULL;\n    if (!toplevel) {\n        const DataLayout &DL =\n#ifdef LLVM35\n            m->getDataLayout();\n#else\n            *jl_data_layout;\n#endif\n        // but don't remember toplevel thunks because\n        // they may not be rooted in the gc for the life of the program,\n        // and the runtime doesn't notify us when the code becomes unreachable :(\n        jl_add_linfo_in_flight((specf ? specf : f)->getName(), li, DL);\n    }\n\n    // mark the pointer calling convention\n    li->jlcall_api = (f->getFunctionType() == jl_func_sig ? 0 : 1);\n    li->fptr = NULL;\n\n    // success. add the result to the execution engine now\n    jl_finalize_module(m.release(), !toplevel);\n\n    // if not inlineable, code won't be needed again\n    if (JL_DELETE_NON_INLINEABLE &&\n        li->def && li->inferred && !li->inlineable &&\n        li != li->def->lambda_template && !imaging_mode) {\n        jl_set_lambda_code_null(li);\n    }\n\n    // done compiling: restore global state\n    if (old != NULL) {\n        builder.SetInsertPoint(old);\n        builder.SetCurrentDebugLocation(olddl);\n    }\n    li->inCompile = 0;\n    nested_compile = last_n_c;\n    JL_UNLOCK(&codegen_lock); // Might GC\n    if (dump_compiles_stream != NULL) {\n        uint64_t this_time = jl_hrtime();\n        jl_printf(dump_compiles_stream, \"%\" PRIu64 \"\\t\\\"\", this_time - last_time);\n        jl_static_show(dump_compiles_stream, (jl_value_t*)li);\n        jl_printf(dump_compiles_stream, \"\\\"\\n\");\n        last_time = this_time;\n    }\n}\n\n#ifndef LLVM37\nstatic Value *getModuleFlag(Module *m, StringRef Key)\n{\n    SmallVector<Module::ModuleFlagEntry, 8> ModuleFlags;\n    m->getModuleFlagsMetadata(ModuleFlags);\n    SmallVector<Module::ModuleFlagEntry, 8>::iterator it = ModuleFlags.begin();\n    for (;it != ModuleFlags.end(); ++it) {\n        if (Key == it->Key->getString())\n            return it->Val;\n    }\n    return NULL;\n}\n#else\n#define getModuleFlag(m,str) m->getModuleFlag(str)\n#endif\n\nstatic void jl_setup_module(Module *m)\n{\n    // Some linkers (*cough* OS X) don't understand DWARF v4, so we use v2 in\n    // imaging mode. The structure of v4 is slightly nicer for debugging JIT\n    // code.\n    if (!getModuleFlag(m,\"Dwarf Version\")) {\n        int dwarf_version = 4;\n#ifdef _OS_DARWIN_\n        if (imaging_mode)\n            dwarf_version = 2;\n#endif\n        m->addModuleFlag(llvm::Module::Warning, \"Dwarf Version\", dwarf_version);\n    }\n#ifdef LLVM34\n    if (!getModuleFlag(m,\"Debug Info Version\"))\n        m->addModuleFlag(llvm::Module::Error, \"Debug Info Version\",\n            llvm::DEBUG_METADATA_VERSION);\n#endif\n#ifdef LLVM37\n#ifdef USE_ORCJIT\n    m->setDataLayout(jl_ExecutionEngine->getDataLayout());\n#elif defined(LLVM38)\n    m->setDataLayout(jl_ExecutionEngine->getDataLayout().getStringRepresentation());\n#else\n    m->setDataLayout(jl_ExecutionEngine->getDataLayout()->getStringRepresentation());\n#endif\n    m->setTargetTriple(jl_TargetMachine->getTargetTriple().str());\n#elif defined(LLVM36)\n    m->setDataLayout(jl_ExecutionEngine->getDataLayout());\n#endif\n}\n\n// this ensures that llvmf has been emitted to the execution engine,\n// returning the function pointer to it\nextern void jl_callback_triggered_linfos(void);\nstatic uint64_t getAddressForFunction(llvm::Function *llvmf)\n{\n    JL_TIMING(LLVM_EMIT);\n#ifdef JL_DEBUG_BUILD\n    llvm::raw_fd_ostream out(1,false);\n#endif\n#ifdef USE_MCJIT\n    jl_finalize_function(llvmf, NULL);\n    uint64_t ret = jl_ExecutionEngine->getFunctionAddress(llvmf->getName());\n    // delay executing trace callbacks until here to make sure there's no\n    // recursive compilation.\n    jl_callback_triggered_linfos();\n    return ret;\n#else\n    return (uint64_t)jl_ExecutionEngine->getPointerToFunction(\n            cast<Function>(shadow_output->getNamedValue(llvmf->getName())));\n#endif\n}\n\nextern \"C\" JL_DLLEXPORT\nuint64_t jl_get_llvm_fptr(llvm::Function *llvmf)\n{\n    uint64_t addr = getAddressForFunction(llvmf);\n#ifdef USE_ORCJIT\n    if (!addr)\n        addr = jl_ExecutionEngine->findUnmangledSymbol(llvmf->getName()).getAddress();\n#endif\n    return addr;\n}\n\n// this assumes that jl_compile_linfo has already been called\n// and forces compilation of the lambda info\nextern \"C\" void jl_generate_fptr(jl_lambda_info_t *li)\n{\n    if (li->jlcall_api == 2) return;\n    JL_LOCK(&codegen_lock);\n    // objective: assign li->fptr\n    assert(li->functionObjectsDecls.functionObject);\n    assert(!li->inCompile);\n    if (li->fptr == NULL) {\n        li->fptr = (jl_fptr_t)getAddressForFunction((Function*)li->functionObjectsDecls.functionObject);\n        assert(li->fptr != NULL);\n    }\n    JL_UNLOCK(&codegen_lock); // Might GC\n}\n\nstatic Function *jl_cfunction_object(jl_function_t *f, jl_value_t *rt, jl_tupletype_t *argt);\n// get the address of a C-callable entry point for a function\nextern \"C\" JL_DLLEXPORT\nvoid *jl_function_ptr(jl_function_t *f, jl_value_t *rt, jl_value_t *argt)\n{\n    JL_GC_PUSH1(&argt);\n    if (jl_is_tuple(argt)) {\n        // TODO: maybe deprecation warning, better checking\n        argt = (jl_value_t*)jl_apply_tuple_type_v((jl_value_t**)jl_data_ptr(argt), jl_nfields(argt));\n    }\n    Function *llvmf = jl_cfunction_object(f, rt, (jl_tupletype_t*)argt);\n    JL_GC_POP();\n    return (void*)getAddressForFunction(llvmf);\n}\n\n\n// convenience function for debugging from gdb (pre-OrcJIT)\n// it generally helps to have define KEEP_BODIES if you plan on using this\nextern \"C\" JL_DLLEXPORT\nvoid *jl_function_ptr_by_llvm_name(char *name) {\n#ifdef JL_MSAN_ENABLED\n    __msan_unpoison_string(name);\n#endif\n    return (void*)(intptr_t)jl_ExecutionEngine->FindFunctionNamed(name);\n}\n\n// export a C-callable entry point for a function (dllexport'ed dlsym), with a given name\nextern \"C\" JL_DLLEXPORT\nvoid jl_extern_c(jl_function_t *f, jl_value_t *rt, jl_value_t *argt, char *name)\n{\n    assert(jl_is_tuple_type(argt));\n    Function *llvmf = jl_cfunction_object(f, rt, (jl_tupletype_t*)argt);\n    if (llvmf) {\n        // force eager emission of the function (llvm 3.3 gets confused otherwise and tries to do recursive compilation)\n        uint64_t Addr = getAddressForFunction(llvmf);\n\n#if defined(USE_ORCJIT) || defined(USE_MCJIT)\n        if (imaging_mode)\n             // in the old JIT, the shadow_module aliases the engine_module,\n             // otherwise, just point the alias to the declaration\n#endif\n            llvmf = cast<Function>(shadow_output->getNamedValue(llvmf->getName()));\n\n        // make the alias to the shadow_module\n        GlobalAlias *GA =\n#if defined(LLVM38)\n            GlobalAlias::create(llvmf->getType()->getElementType(), llvmf->getType()->getAddressSpace(),\n                                GlobalValue::ExternalLinkage, name, llvmf, shadow_output);\n#elif defined(LLVM37)\n            GlobalAlias::create(cast<PointerType>(llvmf->getType()),\n                                GlobalValue::ExternalLinkage, name, llvmf, shadow_output);\n#else\n            new GlobalAlias(llvmf->getType(), GlobalValue::ExternalLinkage, name, llvmf, shadow_output);\n#endif\n\n#if defined(USE_ORCJIT) || defined(USE_MCJIT)\n        // make the alias name is valid for the current session\n        jl_ExecutionEngine->addGlobalMapping(GA, (void*)(uintptr_t)Addr);\n#else\n        (void)GA; (void)Addr;\n#endif\n    }\n}\n\n// --- native code info, and dump function to IR and ASM ---\n// Get pointer to llvm::Function instance, compiling if necessary\n// for use in reflection from Julia.\n// this is paired with jl_dump_function_ir and jl_dump_function_asm in particular ways:\n// misuse will leak memory or cause read-after-free\nextern \"C\" JL_DLLEXPORT\nvoid *jl_get_llvmf(jl_tupletype_t *tt, bool getwrapper, bool getdeclarations)\n{\n    jl_lambda_info_t *linfo = NULL, *temp = NULL;\n    JL_GC_PUSH3(&linfo, &temp, &tt);\n    if (tt != NULL) {\n        linfo = jl_get_specialization1(tt);\n        if (linfo == NULL) {\n            linfo = jl_method_lookup_by_type(\n                ((jl_datatype_t*)jl_tparam0(tt))->name->mt, tt, 0, 0, 1);\n            if (linfo == NULL || jl_has_call_ambiguities(tt, linfo->def)) {\n                JL_GC_POP();\n                return NULL;\n            }\n        }\n    }\n    if (linfo == NULL) {\n        // no function found for argument tuple type\n        JL_GC_POP();\n        return NULL;\n    }\n    if (linfo->def->lambda_template->code == jl_nothing) {\n        // not a generic function\n        JL_GC_POP();\n        return NULL;\n    }\n\n    // make sure to compile this normally first,\n    // since `emit_function` doesn't handle recursive compilation correctly\n    linfo = jl_compile_for_dispatch(linfo);\n\n    if (!getdeclarations) {\n        if (linfo->code == jl_nothing) {\n            // re-infer if we've deleted the code\n            // first copy the linfo to avoid corrupting it and\n            // confusing the compiler about the\n            // validity of the code it already generated\n            temp = jl_get_specialized(linfo->def, linfo->specTypes, linfo->sparam_vals, 1);\n            jl_type_infer(temp, 0);\n            if (temp->code == jl_nothing || temp->inInference) {\n                JL_GC_POP();\n                return NULL;\n            }\n        }\n        // emit this function into a new module\n        Function *f, *specf;\n        jl_llvm_functions_t declarations;\n        std::unique_ptr<Module> m = emit_function(temp ? temp : linfo, &declarations);\n        jl_globalPM->run(*m.get());\n        f = (llvm::Function*)declarations.functionObject;\n        specf = (llvm::Function*)declarations.specFunctionObject;\n        // swap declarations for definitions and destroy declarations\n        if (specf) {\n            Function *tempf = cast<Function>(m->getNamedValue(specf->getName()));\n            delete specf;\n            specf = tempf;\n        }\n        if (f) {\n            Function *tempf = cast<Function>(m->getNamedValue(f->getName()));\n            delete f;\n            f = tempf;\n        }\n        Function *specf_decl = (Function*)linfo->functionObjectsDecls.specFunctionObject;\n        if (specf_decl) {\n            specf->setName(specf_decl->getName());\n        }\n        Function *f_decl = (Function*)linfo->functionObjectsDecls.functionObject;\n        if (f_decl) {\n            f->setName(f_decl->getName());\n        }\n        m.release(); // the return object `llvmf` will be the owning pointer\n        JL_GC_POP();\n        if (getwrapper || !specf) {\n            return f;\n        }\n        else {\n            return specf;\n        }\n    }\n    if (linfo->jlcall_api == 2) {\n        // normally we don't generate native code for these functions, so need an exception here\n        // This leaks a bit of memory to cache the native code that we'll never actually need\n        if (linfo->functionObjectsDecls.functionObject == NULL) {\n            temp = jl_get_specialized(linfo->def, linfo->specTypes, linfo->sparam_vals, 1);\n            jl_type_infer(temp, 0);\n            temp->jlcall_api = 0;\n            temp->constval = jl_nothing;\n            if (temp->code == jl_nothing || temp->inInference) {\n                JL_GC_POP();\n                return NULL;\n            }\n            jl_compile_linfo(temp);\n            linfo->functionObjectsDecls = temp->functionObjectsDecls;\n        }\n        jl_set_lambda_code_null(linfo);\n    }\n    Function *llvmf;\n    if (!getwrapper && linfo->functionObjectsDecls.specFunctionObject != NULL) {\n        llvmf = (Function*)linfo->functionObjectsDecls.specFunctionObject;\n    }\n    else {\n        llvmf = (Function*)linfo->functionObjectsDecls.functionObject;\n    }\n    JL_GC_POP();\n    return llvmf;\n}\n\n// print an llvm IR acquired from jl_get_llvmf\n// warning: this takes ownership of, and destroys, f->getParent()\nextern \"C\" JL_DLLEXPORT\nconst jl_value_t *jl_dump_function_ir(void *f, bool strip_ir_metadata, bool dump_module)\n{\n    std::string code;\n    llvm::raw_string_ostream stream(code);\n\n    Function *llvmf = dyn_cast<Function>((Function*)f);\n    if (!llvmf || (!llvmf->isDeclaration() && !llvmf->getParent()))\n        jl_error(\"jl_dump_function_ir: Expected Function* in a temporary Module\");\n\n    if (!llvmf->getParent()) {\n        // print the function declaration as-is\n        llvmf->print(stream);\n    }\n    else {\n        Module *m = llvmf->getParent();\n        if (strip_ir_metadata) {\n            // strip metadata from all instructions in the module\n            for (Module::iterator I = m->begin(), E = m->end(); I != E; ++I) {\n                Function *f2 = &*I;\n                Function::BasicBlockListType::iterator f2_bb = f2->getBasicBlockList().begin();\n                // iterate over all basic blocks in the function\n                for (; f2_bb != f2->getBasicBlockList().end(); ++f2_bb) {\n                    BasicBlock::InstListType::iterator f2_il = (*f2_bb).getInstList().begin();\n                    // iterate over instructions in basic block\n                    for (; f2_il != (*f2_bb).getInstList().end(); ) {\n                        Instruction *inst = &*f2_il++;\n                        // remove dbg.declare and dbg.value calls\n                        if (isa<DbgDeclareInst>(inst) || isa<DbgValueInst>(inst)) {\n                            inst->eraseFromParent();\n                            continue;\n                        }\n\n                        SmallVector<std::pair<unsigned, MDNode*>, 4> MDForInst;\n                        inst->getAllMetadata(MDForInst);\n                        SmallVector<std::pair<unsigned, MDNode*>, 4>::iterator md_iter = MDForInst.begin();\n\n                        // iterate over all metadata kinds and set to NULL to remove\n                        for (; md_iter != MDForInst.end(); ++md_iter) {\n                            inst->setMetadata((*md_iter).first, NULL);\n                        }\n                    }\n                }\n            }\n        }\n        if (dump_module) {\n            m->print(stream, NULL);\n        }\n        else {\n            llvmf->print(stream);\n        }\n        delete m;\n    }\n\n    return jl_cstr_to_string(const_cast<char*>(stream.str().c_str()));\n}\n\n// This isn't particularly fast, but it's only used for interactive mode\nstatic uint64_t compute_obj_symsize(const object::ObjectFile *obj, uint64_t offset)\n{\n    // Scan the object file for the closest symbols above and below offset in the .text section\n    uint64_t lo = 0;\n    uint64_t hi = 0;\n    bool setlo = false;\n#ifdef LLVM37\n    for (const object::SectionRef &Section : obj->sections()) {\n#else\n    llvm::error_code err;\n    for (object::section_iterator I = obj->begin_sections(), E = obj->end_sections();\n            !err && I != E; I.increment(err)) {\n        object::SectionRef Section = *I;\n#endif\n        uint64_t SAddr, SSize;\n#ifdef LLVM35\n        if (!Section.isText()) continue;\n#else\n        bool isText;\n        if (Section.isText(isText) || !isText) continue;\n#endif\n#ifdef LLVM36\n        SAddr = Section.getAddress();\n        SSize = Section.getSize();\n#else\n        Section.getAddress(SAddr);\n        Section.getSize(SSize);\n#endif\n        if (offset < SAddr || offset >= SAddr + SSize) continue;\n        assert(hi == 0);\n\n        // test for lower and upper symbol bounds relative to other symbols\n        hi = SAddr + SSize;\n#ifdef LLVM37\n        object::section_iterator ESection = obj->section_end();\n        for (const object::SymbolRef &Sym : obj->symbols()) {\n#else\n        llvm::error_code err;\n        object::section_iterator ESection = obj->end_sections();\n        for (object::symbol_iterator I = obj->begin_symbols(), E = obj->end_symbols();\n                !err && I != E; I.increment(err)) {\n            object::SymbolRef Sym = *I;\n#endif\n            uint64_t Addr;\n            object::section_iterator Sect = ESection;\n#ifdef LLVM38\n            auto SectOrError = Sym.getSection();\n            assert(SectOrError);\n            Sect = SectOrError.get();\n#else\n            if (Sym.getSection(Sect)) continue;\n#endif\n            if (Sect == ESection) continue;\n            if (Sect != Section) continue;\n#ifdef LLVM37\n            auto AddrOrError = Sym.getAddress();\n            assert(AddrOrError);\n            Addr = AddrOrError.get();\n#else\n            if (Sym.getAddress(Addr)) continue;\n#endif\n            if (Addr <= offset && Addr >= lo) {\n                // test for lower bound on symbol\n                lo = Addr;\n                setlo = true;\n            }\n            if (Addr > offset && Addr < hi) {\n                // test for upper bound on symbol\n                hi = Addr;\n            }\n        }\n    }\n    if (setlo)\n        return hi - lo;\n    return 0;\n}\n\n// print a native disassembly for f (an LLVM function)\nextern \"C\" JL_DLLEXPORT\nconst jl_value_t *jl_dump_function_asm(void *f, int raw_mc)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    std::string code;\n    llvm::raw_string_ostream stream(code);\n#ifndef LLVM37\n    llvm::formatted_raw_ostream fstream(stream);\n#endif\n\n    Function *llvmf = dyn_cast<Function>((Function*)f);\n    if (!llvmf)\n        jl_error(\"jl_dump_function_asm: Expected Function*\");\n\n    // Dump assembly code\n    uint64_t symsize = 0;\n    int64_t slide = 0, section_slide = 0;\n    uint64_t fptr = getAddressForFunction(llvmf);\n#ifdef USE_MCJIT\n    // Look in the system image as well\n    if (fptr == 0)\n        fptr = (uintptr_t)jl_ExecutionEngine->getPointerToGlobalIfAvailable(llvmf);\n    llvm::DIContext *context = NULL;\n    llvm::DIContext *&objcontext = context;\n#else\n    std::vector<JITEvent_EmittedFunctionDetails::LineStart> context;\n    llvm::DIContext *objcontext = NULL;\n#endif\n    const object::ObjectFile *object = NULL;\n    assert(fptr != 0);\n    if (!jl_DI_for_fptr(fptr, &symsize, &slide, &section_slide, &object, &context)) {\n        if (!jl_dylib_DI_for_fptr(fptr, &object, &objcontext, &slide, &section_slide, false,\n            NULL, NULL, NULL, NULL)) {\n                jl_printf(JL_STDERR, \"WARNING: Unable to find function pointer\\n\");\n                return jl_cstr_to_string(\"\");\n        }\n    }\n    if (symsize == 0 && object != NULL)\n        symsize = compute_obj_symsize(object, fptr + slide + section_slide);\n    if (symsize == 0) {\n        jl_printf(JL_STDERR, \"WARNING: Could not determine size of symbol\\n\");\n        return jl_cstr_to_string(\"\");\n    }\n\n    if (raw_mc) {\n        return (jl_value_t*)jl_pchar_to_array((char*)fptr, symsize);\n    }\n\n    int8_t gc_state = jl_gc_safe_enter(ptls);\n    jl_dump_asm_internal(fptr, symsize, slide,\n#ifndef USE_MCJIT\n            context,\n#endif\n            object, objcontext,\n#ifdef LLVM37\n            stream\n#else\n            fstream\n#endif\n            );\n\n#ifndef LLVM37\n    fstream.flush();\n#endif\n    jl_gc_safe_leave(ptls, gc_state);\n\n    return jl_cstr_to_string(const_cast<char*>(stream.str().c_str()));\n}\n\n// Logging for code coverage and memory allocation\n\nconst int logdata_blocksize = 32; // target getting nearby lines in the same general cache area and reducing calls to malloc by chunking\ntypedef uint64_t logdata_block[logdata_blocksize];\ntypedef StringMap< std::vector<logdata_block*> > logdata_t;\n\nstatic void visitLine(std::vector<logdata_block*> &vec, int line, Value *addend, const char* name)\n{\n    unsigned block = line / logdata_blocksize;\n    line = line % logdata_blocksize;\n    if (vec.size() <= block)\n        vec.resize(block + 1);\n    if (vec[block] == NULL) {\n        vec[block] = (logdata_block*)calloc(1, sizeof(logdata_block));\n    }\n    logdata_block &data = *vec[block];\n    if (data[line] == 0)\n        data[line] = 1;\n    Value *v = ConstantExpr::getIntToPtr(\n        ConstantInt::get(T_size, (uintptr_t)&data[line]),\n        T_pint64);\n    builder.CreateStore(builder.CreateAdd(builder.CreateLoad(v, true, name),\n                                          addend),\n                        v, true); // not atomic, so this might be an underestimate,\n                                  // but it's faster this way\n}\n\n// Code coverage\n\nstatic logdata_t coverageData;\n\nstatic void coverageVisitLine(StringRef filename, int line)\n{\n    assert(!imaging_mode);\n    if (filename == \"\" || filename == \"none\" || filename == \"no file\" || filename == \"<missing>\" || line < 0)\n        return;\n    visitLine(coverageData[filename], line, ConstantInt::get(T_int64, 1), \"lcnt\");\n}\n\n// Memory allocation log (malloc_log)\n\nstatic logdata_t mallocData;\n\nstatic void mallocVisitLine(StringRef filename, int line)\n{\n    assert(!imaging_mode);\n    if (filename == \"\" || filename == \"none\" || filename == \"no file\" || filename == \"<missing>\" || line < 0) {\n        jl_gc_sync_total_bytes();\n        return;\n    }\n    visitLine( mallocData[filename], line,\n               builder.CreateCall(prepare_call(diff_gc_total_bytes_func)\n#ifdef LLVM37\n                                  , {}\n#endif\n                                  ),\n                        \"bytecnt\");\n}\n\n// Resets the malloc counts. Needed to avoid including memory usage\n// from JITting.\nextern \"C\" JL_DLLEXPORT void jl_clear_malloc_data(void)\n{\n    logdata_t::iterator it = mallocData.begin();\n    for (; it != mallocData.end(); it++) {\n        std::vector<logdata_block*> &bytes = (*it).second;\n        std::vector<logdata_block*>::iterator itb;\n        for (itb = bytes.begin(); itb != bytes.end(); itb++) {\n            if (*itb) {\n                logdata_block &data = **itb;\n                for (int i = 0; i < logdata_blocksize; i++) {\n                    if (data[i] > 0)\n                        data[i] = 1;\n                }\n            }\n        }\n    }\n    jl_gc_sync_total_bytes();\n}\n\nextern \"C\" int isabspath(const char *in);\n\nstatic void write_log_data(logdata_t &logData, const char *extension)\n{\n    std::string base = std::string(jl_options.julia_home);\n    base = base + \"/../share/julia/base/\";\n    logdata_t::iterator it = logData.begin();\n    for (; it != logData.end(); it++) {\n        std::string filename = it->first();\n        std::vector<logdata_block*> &values = it->second;\n        if (!values.empty()) {\n            if (!isabspath(filename.c_str()))\n                filename = base + filename;\n            std::ifstream inf(filename.c_str());\n            if (inf.is_open()) {\n                std::string outfile = filename + extension;\n                std::ofstream outf(outfile.c_str(), std::ofstream::trunc | std::ofstream::out);\n                char line[1024];\n                int l = 1;\n                unsigned block = 0;\n                while (!inf.eof()) {\n                    inf.getline(line, sizeof(line));\n                    if (inf.fail() && !inf.bad()) {\n                        // Read through lines longer than sizeof(line)\n                        inf.clear();\n                        inf.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n                    }\n                    logdata_block *data = NULL;\n                    if (block < values.size()) {\n                        data = values[block];\n                    }\n                    uint64_t value = data ? (*data)[l] : 0;\n                    if (++l >= logdata_blocksize) {\n                        l = 0;\n                        block++;\n                    }\n                    outf.width(9);\n                    if (value == 0)\n                        outf << '-';\n                    else\n                        outf << (value - 1);\n                    outf.width(0);\n                    outf << \" \" << line << std::endl;\n                }\n                outf.close();\n                inf.close();\n            }\n        }\n    }\n}\n\nextern \"C\" int jl_getpid();\nextern \"C\" void jl_write_coverage_data(void)\n{\n    std::ostringstream stm;\n    stm << jl_getpid();\n    std::string outf = \".\" + stm.str() + \".cov\";\n    write_log_data(coverageData, outf.c_str());\n}\n\nextern \"C\" void jl_write_malloc_log(void)\n{\n    write_log_data(mallocData, \".mem\");\n}\n\n// --- code gen for intrinsic functions ---\n\n#include \"intrinsics.cpp\"\n\n// --- constant determination ---\n\nstatic void show_source_loc(JL_STREAM *out, jl_codectx_t *ctx)\n{\n    if (ctx == NULL) return;\n    jl_printf(out, \"in %s at %s\", ctx->name, ctx->file.str().c_str());\n}\n\nextern \"C\" void jl_binding_deprecation_warning(jl_binding_t *b);\n\nstatic void cg_bdw(jl_binding_t *b, jl_codectx_t *ctx)\n{\n    jl_binding_deprecation_warning(b);\n    if (jl_options.depwarn) {\n        show_source_loc(JL_STDERR, ctx);\n        jl_printf(JL_STDERR, \"\\n\");\n    }\n}\n\n// try to statically evaluate, NULL if not possible\nextern \"C\"\njl_value_t *jl_static_eval(jl_value_t *ex, void *ctx_, jl_module_t *mod,\n                           jl_lambda_info_t *linfo, int sparams, int allow_alloc)\n{\n    jl_codectx_t *ctx = (jl_codectx_t*)ctx_;\n    if (jl_is_symbol(ex)) {\n        jl_sym_t *sym = (jl_sym_t*)ex;\n        if (jl_is_const(mod, sym))\n            return jl_get_global(mod, sym);\n        return NULL;\n    }\n    if (jl_is_slot(ex))\n        return NULL;\n    if (jl_is_ssavalue(ex)) {\n        ssize_t idx = ((jl_ssavalue_t*)ex)->id;\n        assert(idx >= 0);\n        if (ctx != NULL && ctx->ssavalue_assigned.at(idx)) {\n            return ctx->SAvalues.at(idx).constant;\n        }\n        return NULL;\n    }\n    if (jl_is_quotenode(ex))\n        return jl_fieldref(ex,0);\n    if (jl_is_lambda_info(ex))\n        return NULL;\n    jl_module_t *m = NULL;\n    jl_sym_t *s = NULL;\n    if (jl_is_globalref(ex)) {\n        s = (jl_sym_t*)jl_globalref_name(ex);\n        if (s && jl_is_symbol(s)) {\n            jl_binding_t *b = jl_get_binding(jl_globalref_mod(ex), s);\n            if (b && b->constp) {\n                if (b->deprecated) cg_bdw(b, ctx);\n                return b->value;\n            }\n        }\n        return NULL;\n    }\n    if (jl_is_expr(ex)) {\n        jl_expr_t *e = (jl_expr_t*)ex;\n        if (e->head == call_sym) {\n            jl_value_t *f = jl_static_eval(jl_exprarg(e,0),ctx,mod,linfo,sparams,allow_alloc);\n            if (f) {\n                if (jl_array_dim0(e->args) == 3 && f==jl_builtin_getfield) {\n                    m = (jl_module_t*)jl_static_eval(jl_exprarg(e,1),ctx,mod,linfo,sparams,allow_alloc);\n                    s = (jl_sym_t*)jl_static_eval(jl_exprarg(e,2),ctx,mod,linfo,sparams,allow_alloc);\n                    if (m && jl_is_module(m) && s && jl_is_symbol(s)) {\n                        jl_binding_t *b = jl_get_binding(m, s);\n                        if (b && b->constp) {\n                            if (b->deprecated) cg_bdw(b, ctx);\n                            return b->value;\n                        }\n                    }\n                }\n                else if (f==jl_builtin_tuple || f==jl_builtin_apply_type) {\n                    size_t i;\n                    size_t n = jl_array_dim0(e->args)-1;\n                    if (n==0 && f==jl_builtin_tuple) return (jl_value_t*)jl_emptytuple;\n                    if (!allow_alloc)\n                        return NULL;\n                    jl_value_t **v;\n                    JL_GC_PUSHARGS(v, n);\n                    for (i = 0; i < n; i++) {\n                        v[i] = jl_static_eval(jl_exprarg(e,i+1),ctx,mod,linfo,sparams,allow_alloc);\n                        if (v[i] == NULL) {\n                            JL_GC_POP();\n                            return NULL;\n                        }\n                    }\n                    jl_value_t *result;\n                    JL_TRY {\n                        if (f == jl_builtin_tuple)\n                            result = jl_f_tuple(NULL, v, n);\n                        else\n                            result = jl_f_apply_type(NULL, v, n);\n                    }\n                    JL_CATCH {\n                        result = NULL;\n                    }\n                    JL_GC_POP();\n                    return result;\n                }\n            }\n        }\n        else if (e->head == static_parameter_sym) {\n            size_t idx = jl_unbox_long(jl_exprarg(e,0));\n            if (linfo && idx <= jl_svec_len(linfo->sparam_vals)) {\n                jl_value_t *e = jl_svecref(linfo->sparam_vals, idx - 1);\n                if (jl_is_typevar(e))\n                    return NULL;\n                return e;\n            }\n        }\n        return NULL;\n    }\n    return ex;\n}\n\nstatic jl_value_t *static_eval(jl_value_t *ex, jl_codectx_t *ctx, bool sparams,\n                               bool allow_alloc)\n{\n    return jl_static_eval(ex, ctx, ctx->module, ctx->linfo, sparams, allow_alloc);\n}\n\nstatic bool is_constant(jl_value_t *ex, jl_codectx_t *ctx, bool sparams=true)\n{\n    return static_eval(ex,ctx,sparams) != NULL;\n}\n\nstatic bool slot_eq(jl_value_t *e, int sl)\n{\n    return jl_is_slot(e) && jl_slot_number(e)-1 == sl;\n}\n\n// --- find volatile variables ---\n\n// assigned in a try block and used outside that try block\n\nstatic bool local_var_occurs(jl_value_t *e, int sl)\n{\n    if (slot_eq(e, sl)) {\n        return true;\n    }\n    else if (jl_is_expr(e)) {\n        jl_expr_t *ex = (jl_expr_t*)e;\n        size_t alength = jl_array_dim0(ex->args);\n        for(int i=0; i < (int)alength; i++) {\n            if (local_var_occurs(jl_exprarg(ex,i),sl))\n                return true;\n        }\n    }\n    return false;\n}\n\nstatic std::set<int> assigned_in_try(jl_array_t *stmts, int s, long l, int *pend)\n{\n    std::set<int> av;\n    size_t slength = jl_array_dim0(stmts);\n    for(int i=s; i < (int)slength; i++) {\n        jl_value_t *st = jl_array_ptr_ref(stmts,i);\n        if (jl_is_expr(st)) {\n            if (((jl_expr_t*)st)->head == assign_sym) {\n                jl_value_t *ar = jl_exprarg(st, 0);\n                if (jl_is_slot(ar)) {\n                    av.insert(jl_slot_number(ar)-1);\n                }\n            }\n        }\n        if (jl_is_labelnode(st)) {\n            if (jl_labelnode_label(st) == l) {\n                *pend = i;\n                break;\n            }\n        }\n    }\n    return av;\n}\n\nstatic void mark_volatile_vars(jl_array_t *stmts, std::vector<jl_varinfo_t> &slots)\n{\n    size_t slength = jl_array_dim0(stmts);\n    for(int i=0; i < (int)slength; i++) {\n        jl_value_t *st = jl_array_ptr_ref(stmts,i);\n        if (jl_is_expr(st)) {\n            if (((jl_expr_t*)st)->head == enter_sym) {\n                int last = (int)slength-1;\n                std::set<int> as =\n                    assigned_in_try(stmts, i+1,\n                                    jl_unbox_long(jl_exprarg(st,0)), &last);\n                for(int j=0; j < (int)slength; j++) {\n                    if (j < i || j > last) {\n                        std::set<int>::iterator it = as.begin();\n                        for(; it != as.end(); it++) {\n                            if (local_var_occurs(jl_array_ptr_ref(stmts,j), *it)) {\n                                jl_varinfo_t &vi = slots[*it];\n                                if (!vi.value.constant)\n                                    vi.isVolatile = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n// --- escape analysis ---\n\nstatic bool expr_is_symbol(jl_value_t *e)\n{\n    return (jl_is_symbol(e) || jl_is_globalref(e));\n}\n\n// a very simple, conservative escape analysis that is sufficient for\n// eliding allocation of varargs tuples.\n// \"esc\" means \"in escaping context\"\nstatic void simple_escape_analysis(jl_value_t *expr, bool esc, jl_codectx_t *ctx)\n{\n    if (jl_is_expr(expr)) {\n        esc = true;\n        jl_expr_t *e = (jl_expr_t*)expr;\n        size_t i;\n        if (e->head == call_sym || e->head == new_sym) {\n            int alen = jl_array_dim0(e->args);\n            jl_value_t *f = jl_exprarg(e,0);\n            simple_escape_analysis(f, esc, ctx);\n            if (expr_is_symbol(f)) {\n                if (is_constant(f, ctx, false)) {\n                    jl_value_t *fv = jl_interpret_toplevel_expr_in(ctx->module, f, NULL);\n                    if (jl_typeis(fv, jl_intrinsic_type)) {\n                        esc = false;\n                        JL_I::intrinsic fi = (JL_I::intrinsic)jl_unbox_int32(fv);\n                        if (fi == JL_I::ccall) {\n                            esc = true;\n                            simple_escape_analysis(jl_exprarg(e,1), esc, ctx);\n                            // 2nd and 3d arguments are static\n                            for(i=4; i < (size_t)alen; i+=2) {\n                                simple_escape_analysis(jl_exprarg(e,i), esc, ctx);\n                            }\n                            return;\n                        }\n                    }\n                    else {\n                        if ((fv==jl_builtin_getfield && alen==3 &&\n                             expr_type(jl_exprarg(e,2),ctx) == (jl_value_t*)jl_long_type) ||\n                            fv==jl_builtin_nfields ||\n                            (fv==jl_builtin__apply && alen==3)) {\n                            esc = false;\n                        }\n                    }\n                }\n            }\n\n            for(i=1; i < (size_t)alen; i++) {\n                simple_escape_analysis(jl_exprarg(e,i), esc, ctx);\n            }\n        }\n        else if (e->head == method_sym) {\n            simple_escape_analysis(jl_exprarg(e,0), esc, ctx);\n            if (jl_expr_nargs(e) > 1) {\n                simple_escape_analysis(jl_exprarg(e,1), esc, ctx);\n                simple_escape_analysis(jl_exprarg(e,2), esc, ctx);\n            }\n        }\n        else if (e->head == assign_sym) {\n            // don't consider assignment LHS as a variable \"use\"\n            simple_escape_analysis(jl_exprarg(e,1), esc, ctx);\n        }\n        else if (e->head != line_sym) {\n            size_t elen = jl_array_dim0(e->args);\n            for(i=0; i < elen; i++) {\n                simple_escape_analysis(jl_exprarg(e,i), esc, ctx);\n            }\n        }\n        return;\n    }\n    if (jl_is_slot(expr)) {\n        int i = jl_slot_number(expr)-1;\n        jl_varinfo_t &vi = ctx->slots[i];\n        vi.escapes |= esc;\n        vi.used = true;\n    }\n}\n\n// --- gc root utils ---\n\n// ---- Get Element Pointer (GEP) instructions within the GC frame ----\n\n// Emit a gc-root slot indicator\nstatic Value *emit_local_root(jl_codectx_t *ctx, jl_varinfo_t *vi)\n{\n    CallInst *newroot = CallInst::Create(prepare_call(gcroot_func), \"\", /*InsertBefore*/ctx->ptlsStates);\n    if (vi) {\n        vi->memloc->replaceAllUsesWith(newroot);\n        newroot->takeName(vi->memloc);\n        vi->memloc = newroot;\n    }\n    return newroot;\n}\n\n\n// Marks a use (and thus a potential kill) of a gcroot\n// Note that if the operation that needs the root has terminating control flow\n// (e.g. `unreachable`, `noreturn` functions) the use needs to be marked before\n// the operation as well as after it.\nstatic void mark_gc_use(const jl_cgval_t &v)\n{\n    if (v.gcroot)\n        builder.CreateCall(prepare_call(gckill_func), v.gcroot);\n}\n\n// turn an array of arguments into a single object suitable for passing to a jlcall\nstatic Value *make_jlcall(ArrayRef<const jl_cgval_t*> args, jl_codectx_t *ctx)\n{\n    // the temporary variables are after all local variables in the GC frame.\n    CallInst *largs = CallInst::Create(prepare_call(jlcall_frame_func),\n            ConstantInt::get(T_int32, args.size()),\n            \"\",\n            /*InsertBefore*/ctx->ptlsStates);\n    int slot = 0;\n    assert(args.size() > 0);\n    for (ArrayRef<const jl_cgval_t*>::iterator I = args.begin(), E = args.end(); I < E; ++I, ++slot) {\n        Value *arg = boxed(**I, ctx, false); // mark_gc_use isn't needed since jlcall_frame_func can take ownership of this root\n        GetElementPtrInst *newroot = GetElementPtrInst::Create(LLVM37_param(NULL) largs,\n                ArrayRef<Value*>(ConstantInt::get(T_int32, slot)));\n        newroot->insertAfter(ctx->ptlsStates);\n        builder.CreateStore(arg, newroot);\n    }\n    return largs;\n}\n\nstatic void jl_add_linfo_root(jl_lambda_info_t *li, jl_value_t *val)\n{\n    if (jl_is_leaf_type(val) || jl_is_bool(val) || jl_is_symbol(val))\n        return;\n    jl_method_t *m = li->def;\n    JL_GC_PUSH1(&val);\n    JL_LOCK(&m->writelock);\n    if (m->roots == NULL) {\n        m->roots = jl_alloc_vec_any(1);\n        jl_gc_wb(m, m->roots);\n        jl_array_ptr_set(m->roots, 0, val);\n    }\n    else {\n        size_t rlen = jl_array_dim0(m->roots);\n        for(size_t i=0; i < rlen; i++) {\n            if (jl_array_ptr_ref(m->roots,i) == val) {\n                JL_UNLOCK(&li->def->writelock);\n                JL_GC_POP();\n                return;\n            }\n        }\n        jl_array_ptr_1d_push(m->roots, val);\n    }\n    JL_UNLOCK(&li->def->writelock);\n    JL_GC_POP();\n}\n\n// --- generating function calls ---\n\nstatic jl_cgval_t emit_getfield(jl_value_t *expr, jl_sym_t *name, jl_codectx_t *ctx)\n{\n    if (jl_is_quotenode(expr) && jl_is_module(jl_fieldref(expr,0)))\n        expr = jl_fieldref(expr,0);\n\n    jl_value_t *static_val = static_eval(expr, ctx, true, false);\n    if (static_val != NULL && jl_is_module(static_val))\n        expr = static_val;\n\n    if (jl_is_module(expr)) {\n        jl_binding_t *bnd = NULL;\n        Value *bp = global_binding_pointer((jl_module_t*)expr, name, &bnd, false, ctx);\n        // TODO: refactor. this partially duplicates code in emit_var\n        if (bnd && bnd->value != NULL) {\n            if (bnd->constp) {\n                return mark_julia_const(bnd->value);\n            }\n            return mark_julia_type(tbaa_decorate(tbaa_binding, builder.CreateLoad(bp)), true, (jl_value_t*)jl_any_type, ctx);\n        }\n        // todo: use type info to avoid undef check\n        return emit_checked_var(bp, name, ctx, false, tbaa_binding);\n    }\n\n    jl_datatype_t *sty = (jl_datatype_t*)expr_type(expr, ctx);\n    JL_GC_PUSH1(&sty);\n    if (jl_is_type_type((jl_value_t*)sty) && jl_is_leaf_type(jl_tparam0(sty)))\n        sty = (jl_datatype_t*)jl_typeof(jl_tparam0(sty));\n    if (jl_is_structtype(sty) && sty != jl_module_type && sty->uid != 0 &&\n        jl_is_leaf_type((jl_value_t*)sty)) {\n        unsigned idx = jl_field_index(sty, name, 0);\n        if (idx != (unsigned)-1) {\n            jl_cgval_t strct = emit_expr(expr, ctx);\n            jl_cgval_t fld = emit_getfield_knownidx(strct, idx, sty, ctx);\n            JL_GC_POP();\n            return fld;\n        }\n    }\n    JL_GC_POP(); // kill sty\n    // TODO: attempt better codegen for approximate types, if the types\n    // and offsets of some fields are independent of parameters.\n\n    // TODO: generic getfield func with more efficient calling convention\n    jl_cgval_t arg1 = emit_expr(expr, ctx);\n    jl_cgval_t arg2 = mark_julia_const((jl_value_t*)name);\n    const jl_cgval_t* myargs_array[2] = {&arg1, &arg2};\n    Value *myargs = make_jlcall(makeArrayRef(myargs_array), ctx);\n#ifdef LLVM37\n    Value *result = builder.CreateCall(prepare_call(jlgetfield_func), {V_null, myargs,\n                                        ConstantInt::get(T_int32,2)});\n#else\n    Value *result = builder.CreateCall3(prepare_call(jlgetfield_func), V_null, myargs,\n                                        ConstantInt::get(T_int32,2));\n#endif\n    bool needsgcroot = true; // !arg1.isimmutable || !jl_is_leaf_type(arg1.typ) || !is_datatype_all_pointers((jl_datatype_t*)arg1.typ); // TODO: probably want this as a llvm pass\n    jl_cgval_t ret = mark_julia_type(result, true, jl_any_type, ctx, needsgcroot); // (typ will be patched up by caller)\n    return ret;\n}\n\nstatic Value *emit_bits_compare(const jl_cgval_t &arg1, const jl_cgval_t &arg2, jl_codectx_t *ctx)\n{\n    assert(jl_is_datatype(arg1.typ) && arg1.typ == arg2.typ);\n    Type *at = julia_type_to_llvm(arg1.typ);\n\n    if (at->isIntegerTy() || at->isPointerTy() || at->isFloatingPointTy()) {\n        Value *varg1 = emit_unbox(at, arg1, arg1.typ);\n        Value *varg2 = emit_unbox(at, arg2, arg2.typ);\n        return builder.CreateICmpEQ(JL_INT(varg1),JL_INT(varg2));\n    }\n\n    if (at->isVectorTy()) {\n        jl_svec_t *types = ((jl_datatype_t*)arg1.typ)->types;\n        Value *answer = ConstantInt::get(T_int1, 1);\n        Value *varg1 = emit_unbox(at, arg1, arg1.typ);\n        Value *varg2 = emit_unbox(at, arg2, arg2.typ);\n        size_t l = jl_svec_len(types);\n        for(unsigned i=0; i < l; i++) {\n            jl_value_t *fldty = jl_svecref(types,i);\n            Value *subAns, *fld1, *fld2;\n            fld1 = builder.CreateExtractElement(varg1, ConstantInt::get(T_int32,i)),\n            fld2 = builder.CreateExtractElement(varg2, ConstantInt::get(T_int32,i)),\n            subAns = emit_bits_compare(mark_julia_type(fld1, false, fldty, ctx), mark_julia_type(fld2, false, fldty, ctx), ctx);\n            answer = builder.CreateAnd(answer, subAns);\n        }\n        return answer;\n    }\n\n    if (at->isAggregateType()) { // Struct or Array\n        assert(arg1.ispointer() && arg2.ispointer());\n        size_t sz = jl_datatype_size(arg1.typ);\n        if (sz > 512 && !((jl_datatype_t*)arg1.typ)->layout->haspadding) {\n#ifdef LLVM37\n            Value *answer = builder.CreateCall(prepare_call(memcmp_func),\n                            {\n                            data_pointer(arg1, ctx, T_pint8),\n                            data_pointer(arg2, ctx, T_pint8),\n                            ConstantInt::get(T_size, sz)\n                            });\n#else\n            Value *answer = builder.CreateCall3(prepare_call(memcmp_func),\n                    data_pointer(arg1, ctx, T_pint8),\n                    data_pointer(arg2, ctx, T_pint8),\n                    ConstantInt::get(T_size, sz));\n#endif\n            return builder.CreateICmpEQ(answer, ConstantInt::get(T_int32, 0));\n        }\n        else {\n            Type *atp = at->getPointerTo();\n            Value *varg1 = data_pointer(arg1, ctx, atp);\n            Value *varg2 = data_pointer(arg2, ctx, atp);\n            jl_svec_t *types = ((jl_datatype_t*)arg1.typ)->types;\n            Value *answer = ConstantInt::get(T_int1, 1);\n            size_t l = jl_svec_len(types);\n            for(unsigned i=0; i < l; i++) {\n                jl_value_t *fldty = jl_svecref(types, i);\n                Value *subAns, *fld1, *fld2;\n                fld1 = builder.CreateConstGEP2_32(LLVM37_param(at) varg1, 0, i);\n                fld2 = builder.CreateConstGEP2_32(LLVM37_param(at) varg2, 0, i);\n                if (type_is_ghost(fld1->getType()->getPointerElementType()))\n                    continue;\n                subAns = emit_bits_compare(mark_julia_slot(fld1, fldty, arg1.tbaa), mark_julia_slot(fld2, fldty, arg2.tbaa), ctx);\n                answer = builder.CreateAnd(answer, subAns);\n            }\n            return answer;\n        }\n    }\n    assert(0 && \"what is this llvm type?\");\n    return 0;\n}\n\n// emit code for is (===).\nstatic Value *emit_f_is(const jl_cgval_t &arg1, const jl_cgval_t &arg2, jl_codectx_t *ctx)\n{\n    jl_value_t *rt1 = arg1.typ, *rt2 = arg2.typ;\n    bool isleaf = jl_is_leaf_type(rt1) && jl_is_leaf_type(rt2);\n    if (isleaf && rt1 != rt2 && !jl_is_type_type(rt1) && !jl_is_type_type(rt2))\n        // disjoint leaf types are never equal (quick test)\n        return ConstantInt::get(T_int1, 0);\n    if (arg1.isghost || (isleaf && jl_is_datatype_singleton((jl_datatype_t*)rt1))) {\n        if (arg2.isghost || (isleaf && jl_is_datatype_singleton((jl_datatype_t*)rt2))) {\n            if (rt1 == rt2) {\n                // singleton objects of the same type\n                return ConstantInt::get(T_int1, 1);\n            }\n        }\n    }\n\n    if (jl_type_intersection(rt1, rt2) == (jl_value_t*)jl_bottom_type) // types are disjoint (exhaustive test)\n        return ConstantInt::get(T_int1, 0);\n\n    bool isbits = isleaf && jl_isbits(rt1) && jl_types_equal(rt1, rt2);\n    if (isbits) { // whether this type is unique'd by value\n        return emit_bits_compare(arg1, arg2, ctx);\n    }\n\n    int ptr_comparable = 0; // whether this type is unique'd by pointer\n    if (rt1==(jl_value_t*)jl_sym_type || rt2==(jl_value_t*)jl_sym_type ||\n        jl_is_mutable_datatype(rt1) || jl_is_mutable_datatype(rt2)) // excludes abstract types\n        ptr_comparable = 1;\n    if (jl_subtype(rt1, (jl_value_t*)jl_type_type, 0) ||\n        jl_subtype(rt2, (jl_value_t*)jl_type_type, 0)) // use typeseq for datatypes\n        ptr_comparable = 0;\n    if ((jl_is_type_type(rt1) && jl_is_leaf_type(jl_tparam0(rt1))) ||\n        (jl_is_type_type(rt2) && jl_is_leaf_type(jl_tparam0(rt2)))) // can compare leaf types by pointer\n        ptr_comparable = 1;\n    if (ptr_comparable) {\n        assert(arg1.isboxed && arg2.isboxed); // only boxed types are valid for pointer comparison\n        return builder.CreateICmpEQ(boxed(arg1, ctx), boxed(arg2, ctx));\n    }\n\n    Value *varg1 = boxed(arg1, ctx);\n    Value *varg2 = boxed(arg2, ctx, false); // potentially unrooted!\n#ifdef LLVM37\n    return builder.CreateTrunc(builder.CreateCall(prepare_call(jlegal_func), {varg1, varg2}), T_int1);\n#else\n    return builder.CreateTrunc(builder.CreateCall2(prepare_call(jlegal_func), varg1, varg2), T_int1);\n#endif\n}\n\nstatic bool emit_builtin_call(jl_cgval_t *ret, jl_value_t *f, jl_value_t **args, size_t nargs,\n                              jl_codectx_t *ctx, jl_value_t *expr)\n// returns true if the call has been handled\n{\n    jl_value_t *rt1=NULL, *rt2=NULL, *rt3=NULL;\n    JL_GC_PUSH3(&rt1, &rt2, &rt3);\n\n    if (f==jl_builtin_is && nargs==2) {\n        // handle simple static expressions with no side-effects\n        rt1 = static_eval(args[1], ctx, true);\n        if (rt1) {\n            rt2 = static_eval(args[2], ctx, true);\n            if (rt2) {\n                *ret = mark_julia_type(ConstantInt::get(T_int8, jl_egal(rt1, rt2)), false, jl_bool_type, ctx);\n                JL_GC_POP();\n                return true;\n            }\n        }\n        // emit values\n        jl_cgval_t v1 = emit_expr(args[1], ctx);\n        jl_cgval_t v2 = emit_expr(args[2], ctx);\n        // FIXME: v.typ is roughly equiv. to expr_type, but with typeof(T) == Type{T} instead of DataType in a few cases\n        if (v1.typ == (jl_value_t*)jl_datatype_type)\n            v1 = remark_julia_type(v1, expr_type(args[1], ctx)); // patch up typ if necessary\n        if (v2.typ == (jl_value_t*)jl_datatype_type)\n            v2 = remark_julia_type(v2, expr_type(args[2], ctx)); // patch up typ if necessary\n        // emit comparison test\n        Value *ans = emit_f_is(v1, v2, ctx);\n        mark_gc_use(v1);\n        mark_gc_use(v2);\n        *ret = mark_julia_type(builder.CreateZExt(ans,T_int8), false, jl_bool_type, ctx);\n        JL_GC_POP();\n        return true;\n    }\n\n    else if (f==jl_builtin_typeof && nargs==1) {\n        jl_cgval_t arg1 = emit_expr(args[1], ctx);\n        *ret = emit_typeof(arg1,ctx);\n        JL_GC_POP();\n        return true;\n    }\n\n    else if (f==jl_builtin_typeassert && nargs==2) {\n        jl_value_t *arg = expr_type(args[1], ctx); rt1 = arg;\n        jl_value_t *ty  = expr_type(args[2], ctx); rt2 = ty;\n        if (jl_is_type_type(ty) && !jl_is_typevar(jl_tparam0(ty))) {\n            jl_value_t *tp0 = jl_tparam0(ty);\n            if (jl_subtype(arg, tp0, 0)) {\n                *ret = emit_expr(args[1], ctx);\n                JL_GC_POP();\n                return true;\n            }\n            if (tp0 == jl_bottom_type) {\n                emit_expr(args[1], ctx);\n                *ret = jl_cgval_t();\n                emit_error(\"reached code declared unreachable\", ctx);\n                JL_GC_POP();\n                return true;\n            }\n            if (!jl_is_tuple_type(tp0) && jl_is_leaf_type(tp0)) {\n                *ret = emit_expr(args[1], ctx);\n                emit_typecheck(*ret, tp0, \"typeassert\", ctx);\n                if (ret->isboxed)\n                    *ret = remark_julia_type(*ret, expr_type(expr, ctx));\n                JL_GC_POP();\n                return true;\n            }\n        }\n        if (jl_subtype(ty, (jl_value_t*)jl_type_type, 0)) {\n            *ret = emit_expr(args[1], ctx);\n#ifdef LLVM37\n            builder.CreateCall(prepare_call(jltypeassert_func), {boxed(*ret, ctx), boxed(emit_expr(args[2], ctx), ctx)});\n#else\n            builder.CreateCall2(prepare_call(jltypeassert_func), boxed(*ret, ctx), boxed(emit_expr(args[2], ctx), ctx));\n#endif\n            JL_GC_POP();\n            return true;\n        }\n    }\n\n    else if (f==jl_builtin_isa && nargs==2) {\n        jl_value_t *arg = expr_type(args[1], ctx); rt1 = arg;\n        jl_value_t *ty  = expr_type(args[2], ctx); rt2 = ty;\n        if (arg == jl_bottom_type) {\n            emit_expr(args[1], ctx);\n            *ret = jl_cgval_t();\n            JL_GC_POP();\n            return true;\n        }\n        if (jl_is_type_type(ty) && !jl_has_typevars(jl_tparam0(ty))) {\n            jl_value_t *tp0 = jl_tparam0(ty);\n            if (jl_subtype(arg, tp0, 0)) {\n                emit_expr(args[1], ctx);  // TODO remove if no side effects\n                *ret = mark_julia_type(ConstantInt::get(T_int8, 1), false, jl_bool_type, ctx);\n                JL_GC_POP();\n                return true;\n            }\n            if (!jl_subtype(tp0, (jl_value_t*)jl_type_type, 0)) {\n                if (jl_is_leaf_type(arg)) {\n                    emit_expr(args[1], ctx);  // TODO remove if no side effects\n                    *ret = mark_julia_type(ConstantInt::get(T_int8, 0), false, jl_bool_type, ctx);\n                    JL_GC_POP();\n                    return true;\n                }\n                if (jl_is_leaf_type(tp0)) {\n                    jl_cgval_t arg1 = emit_expr(args[1], ctx);\n                    *ret = mark_julia_type(builder.CreateZExt(builder.CreateICmpEQ(emit_typeof_boxed(arg1,ctx),\n                                                                                   literal_pointer_val(tp0)),\n                                                              T_int8),\n                                           false,\n                                           jl_bool_type, ctx);\n                    JL_GC_POP();\n                    return true;\n                }\n            }\n        }\n    }\n\n    else if (f==jl_builtin_issubtype && nargs == 2) {\n        rt1 = expr_type(args[1], ctx);\n        rt2 = expr_type(args[2], ctx);\n        if (jl_is_type_type(rt1) && !jl_is_typevar(jl_tparam0(rt1)) &&\n            jl_is_type_type(rt2) && !jl_is_typevar(jl_tparam0(rt2))) {\n            int issub = jl_subtype(jl_tparam0(rt1), jl_tparam0(rt2), 0);\n            // TODO: emit args[1] and args[2] in case of side effects?\n            *ret = mark_julia_type(ConstantInt::get(T_int8, issub), false, jl_bool_type, ctx);\n            JL_GC_POP();\n            return true;\n        }\n    }\n\n    else if (f==jl_builtin__apply && nargs==2 && ctx->vaStack && slot_eq(args[2], ctx->vaSlot)) {\n        // turn Core._apply(f, Tuple) ==> f(Tuple...) using the jlcall calling convention if Tuple is the vaStack allocation\n        Value *theF = boxed(emit_expr(args[1], ctx), ctx);\n        Value *nva = emit_n_varargs(ctx);\n#ifdef _P64\n        nva = builder.CreateTrunc(nva, T_int32);\n#endif\n        Value *r =\n#ifdef LLVM37\n            builder.CreateCall(prepare_call(jlapply2va_func), {theF,\n                                builder.CreateGEP(ctx->argArray,\n                                                  ConstantInt::get(T_size, ctx->nReqArgs)),\n                                nva});\n#else\n            builder.CreateCall3(prepare_call(jlapply2va_func), theF,\n                                builder.CreateGEP(ctx->argArray,\n                                                  ConstantInt::get(T_size, ctx->nReqArgs)),\n                                nva);\n#endif\n        *ret = mark_julia_type(r, true, expr_type(expr, ctx), ctx);\n        JL_GC_POP();\n        return true;\n    }\n\n    else if (f==jl_builtin_tuple) {\n        if (nargs == 0) {\n            *ret = ghostValue(jl_typeof(jl_emptytuple));\n            JL_GC_POP();\n            return true;\n        }\n        if (ctx->linfo->inferred) {\n            rt1 = expr_type(expr, ctx);\n            if (jl_is_tuple_type(rt1) && jl_is_leaf_type(rt1) && nargs == jl_datatype_nfields(rt1)) {\n                *ret = emit_new_struct(rt1, nargs+1, args, ctx);\n                JL_GC_POP();\n                return true;\n            }\n        }\n    }\n\n    else if (f==jl_builtin_throw && nargs==1) {\n        Value *arg1 = boxed(emit_expr(args[1], ctx), ctx, false); // rooted by throw\n        raise_exception(arg1, ctx);\n        *ret = jl_cgval_t();\n        JL_GC_POP();\n        return true;\n    }\n\n    else if (f==jl_builtin_arraysize && nargs==2) {\n        jl_value_t *aty = expr_type(args[1], ctx); rt1 = aty;\n        jl_value_t *ity = expr_type(args[2], ctx); rt2 = ity;\n        if (jl_is_array_type(aty) && ity == (jl_value_t*)jl_long_type) {\n            jl_value_t *ndp = jl_tparam1(aty);\n            if (jl_is_long(ndp)) {\n                jl_cgval_t ary = emit_expr(args[1], ctx);\n                size_t ndims = jl_unbox_long(ndp);\n                if (jl_is_long(args[2])) {\n                    uint32_t idx = (uint32_t)jl_unbox_long(args[2]);\n                    if (idx > 0 && idx <= ndims) {\n                        *ret = mark_julia_type(emit_arraysize(ary, args[1], idx, ctx), false, jl_long_type, ctx);\n                        JL_GC_POP();\n                        return true;\n                    }\n                    else if (idx > ndims) {\n                        *ret = mark_julia_type(ConstantInt::get(T_size, 1), false, jl_long_type, ctx);\n                        JL_GC_POP();\n                        return true;\n                    }\n                }\n                else {\n                    Value *idx = emit_unbox(T_size, emit_expr(args[2], ctx), ity);\n                    error_unless(builder.CreateICmpSGT(idx,\n                                                      ConstantInt::get(T_size,0)),\n                                 \"arraysize: dimension out of range\", ctx);\n                    BasicBlock *outBB = BasicBlock::Create(jl_LLVMContext,\"outofrange\",ctx->f);\n                    BasicBlock *inBB = BasicBlock::Create(jl_LLVMContext,\"inrange\");\n                    BasicBlock *ansBB = BasicBlock::Create(jl_LLVMContext,\"arraysize\");\n                    builder.CreateCondBr(builder.CreateICmpSLE(idx,\n                                                              ConstantInt::get(T_size, ndims)),\n                                         inBB, outBB);\n                    builder.SetInsertPoint(outBB);\n                    Value *v_one = ConstantInt::get(T_size, 1);\n                    builder.CreateBr(ansBB);\n                    ctx->f->getBasicBlockList().push_back(inBB);\n                    builder.SetInsertPoint(inBB);\n                    Value *v_sz = emit_arraysize(ary, idx, ctx);\n                    builder.CreateBr(ansBB);\n                    ctx->f->getBasicBlockList().push_back(ansBB);\n                    builder.SetInsertPoint(ansBB);\n                    PHINode *result = builder.CreatePHI(T_size, 2);\n                    result->addIncoming(v_one, outBB);\n                    result->addIncoming(v_sz, inBB);\n                    *ret = mark_julia_type(result, false, jl_long_type, ctx);\n                    JL_GC_POP();\n                    return true;\n                }\n            }\n        }\n    }\n\n    else if (f==jl_builtin_arrayref && nargs>=2) {\n        jl_value_t *aty = expr_type(args[1], ctx); rt1 = aty;\n        bool indexes_ok = true;\n        for (size_t i=2; i <= nargs; i++) {\n            if (expr_type(args[i], ctx) != (jl_value_t*)jl_long_type) {\n                indexes_ok = false; break;\n            }\n        }\n        if (jl_is_array_type(aty) && indexes_ok) {\n            jl_value_t *ety = jl_tparam0(aty);\n            if (!jl_is_typevar(ety)) {\n                if (!jl_array_store_unboxed(ety))\n                    ety = (jl_value_t*)jl_any_type;\n                jl_value_t *ndp = jl_tparam1(aty);\n                if (jl_is_long(ndp) || nargs==2) {\n                    jl_cgval_t ary = emit_expr(args[1], ctx);\n                    size_t nd = jl_is_long(ndp) ? jl_unbox_long(ndp) : 1;\n                    Value *idx = emit_array_nd_index(ary, args[1], nd, &args[2], nargs-1, ctx);\n                    if (jl_array_store_unboxed(ety) &&\n                        ((jl_datatype_t*)ety)->size == 0) {\n                        assert(jl_is_datatype(ety));\n                        assert(((jl_datatype_t*)ety)->instance != NULL);\n                        *ret = ghostValue(ety);\n                    }\n                    else {\n                        *ret = typed_load(emit_arrayptr(ary, args[1], ctx), idx, ety, ctx, tbaa_arraybuf);\n                    }\n                    JL_GC_POP();\n                    return true;\n                }\n            }\n        }\n    }\n\n    else if (f==jl_builtin_arrayset && nargs>=3) {\n        jl_value_t *aty = expr_type(args[1], ctx); rt1 = aty;\n        jl_value_t *vty = expr_type(args[2], ctx); rt2 = vty;\n        bool indexes_ok = true;\n        for (size_t i=3; i <= nargs; i++) {\n            if (expr_type(args[i], ctx) != (jl_value_t*)jl_long_type) {\n                indexes_ok = false; break;\n            }\n        }\n        if (jl_is_array_type(aty) && indexes_ok) {\n            jl_value_t *ety = jl_tparam0(aty);\n            if (!jl_is_typevar(ety) && jl_subtype(vty, ety, 0)) {\n                if (!jl_array_store_unboxed(ety))\n                    ety = (jl_value_t*)jl_any_type;\n                jl_value_t *ndp = jl_tparam1(aty);\n                if (jl_is_long(ndp) || nargs==3) {\n                    jl_cgval_t ary = emit_expr(args[1], ctx);\n                    size_t nd = jl_is_long(ndp) ? jl_unbox_long(ndp) : 1;\n                    Value *idx = emit_array_nd_index(ary, args[1], nd, &args[3], nargs-2, ctx);\n                    bool isboxed = !jl_array_store_unboxed(ety);\n                    if (!isboxed && ((jl_datatype_t*)ety)->size == 0) {\n                        // no-op, but emit expr for possible effects\n                        assert(jl_is_datatype(ety));\n                        emit_expr(args[2], ctx);\n                    }\n                    else {\n                        jl_cgval_t v = emit_expr(args[2], ctx);\n                        PHINode *data_owner = NULL; // owner object against which the write barrier must check\n                        if (isboxed) { // if not boxed we don't need a write barrier\n                            assert(ary.isboxed);\n                            Value *aryv = boxed(ary, ctx);\n                            Value *flags = emit_arrayflags(ary, ctx);\n                            // the owner of the data is ary itself except if ary->how == 3\n                            flags = builder.CreateAnd(flags, 3);\n                            Value *is_owned = builder.CreateICmpEQ(flags, ConstantInt::get(T_int16, 3));\n                            BasicBlock *curBB = builder.GetInsertBlock();\n                            BasicBlock *ownedBB = BasicBlock::Create(jl_LLVMContext, \"array_owned\", ctx->f);\n                            BasicBlock *mergeBB = BasicBlock::Create(jl_LLVMContext, \"merge_own\", ctx->f);\n                            builder.CreateCondBr(is_owned, ownedBB, mergeBB);\n                            builder.SetInsertPoint(ownedBB);\n                            // load owner pointer\n                            Value *own_ptr;\n                            if (jl_is_long(ndp)) {\n                                own_ptr = tbaa_decorate(tbaa_const, builder.CreateLoad(\n                                    emit_bitcast(\n                                        builder.CreateConstGEP1_32(\n                                            emit_bitcast(aryv, T_pint8),\n                                            jl_array_data_owner_offset(nd)),\n                                        T_ppjlvalue)));\n                            }\n                            else {\n#ifdef LLVM37\n                                own_ptr = builder.CreateCall(\n                                    prepare_call(jlarray_data_owner_func),\n                                    {aryv});\n#else\n                                own_ptr = builder.CreateCall(\n                                    prepare_call(jlarray_data_owner_func),\n                                    aryv);\n#endif\n                            }\n                            builder.CreateBr(mergeBB);\n                            builder.SetInsertPoint(mergeBB);\n                            data_owner = builder.CreatePHI(T_pjlvalue, 2);\n                            data_owner->addIncoming(aryv, curBB);\n                            data_owner->addIncoming(own_ptr, ownedBB);\n                        }\n                        typed_store(emit_arrayptr(ary,args[1],ctx), idx, v,\n                                    ety, ctx, tbaa_arraybuf, data_owner, 0,\n                                    false); // don't need to root the box if we had to make one since it's being stored in the array immediatly\n                    }\n                    *ret = ary;\n                    JL_GC_POP();\n                    return true;\n                }\n            }\n        }\n    }\n\n    else if (f==jl_builtin_getfield && nargs==2) {\n        if (jl_is_quotenode(args[2]) && jl_is_symbol(jl_fieldref(args[2],0))) {\n            *ret = emit_getfield(args[1],\n                                 (jl_sym_t*)jl_fieldref(args[2],0), ctx);\n            if (ret->typ == (jl_value_t*)jl_any_type) // improve the type, if known from the expr\n                *ret = remark_julia_type(*ret, expr_type(expr, ctx));\n            JL_GC_POP();\n            return true;\n        }\n        jl_datatype_t *stt = (jl_datatype_t*)expr_type(args[1], ctx);\n        jl_value_t *fldt   = expr_type(args[2], ctx);\n\n        // VA tuple\n        if (ctx->vaStack && slot_eq(args[1], ctx->vaSlot)) {\n            Value *valen = emit_n_varargs(ctx);\n            Value *idx = emit_unbox(T_size, emit_expr(args[2], ctx), fldt);\n            idx = emit_bounds_check(\n                    jl_cgval_t(builder.CreateGEP(ctx->argArray, ConstantInt::get(T_size, ctx->nReqArgs)), NULL, false, NULL),\n                    NULL, idx, valen, ctx);\n            idx = builder.CreateAdd(idx, ConstantInt::get(T_size, ctx->nReqArgs));\n            *ret = mark_julia_type(\n                tbaa_decorate(tbaa_value, builder.CreateLoad(builder.CreateGEP(ctx->argArray, idx))),\n                /*boxed*/ true, expr_type(expr, ctx), ctx, /*needsgcroot*/ false);\n            JL_GC_POP();\n            return true;\n        }\n\n        if (fldt == (jl_value_t*)jl_long_type && jl_is_leaf_type((jl_value_t*)stt)) {\n            if ((jl_is_structtype(stt) || jl_is_tuple_type(stt)) && !jl_subtype((jl_value_t*)jl_module_type, (jl_value_t*)stt, 0)) {\n                size_t nfields = jl_datatype_nfields(stt);\n                jl_cgval_t strct = emit_expr(args[1], ctx);\n                // integer index\n                size_t idx;\n                if (jl_is_long(args[2]) && (idx=jl_unbox_long(args[2])-1) < nfields) {\n                    // known index\n                    *ret = emit_getfield_knownidx(strct, idx, stt, ctx);\n                    JL_GC_POP();\n                    return true;\n                }\n                else {\n                    // unknown index\n                    Value *vidx = emit_unbox(T_size, emit_expr(args[2], ctx), (jl_value_t*)jl_long_type);\n                    if (emit_getfield_unknownidx(ret, strct, vidx, stt, ctx)) {\n                        if (ret->typ == (jl_value_t*)jl_any_type) // improve the type, if known from the expr\n                            ret->typ = expr_type(expr, ctx);\n                        JL_GC_POP();\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n\n    else if (f==jl_builtin_setfield && nargs==3) {\n        jl_datatype_t *sty = (jl_datatype_t*)expr_type(args[1], ctx);\n        rt1 = (jl_value_t*)sty;\n        if (jl_is_structtype(sty) && sty != jl_module_type &&\n            jl_is_quotenode(args[2]) && jl_is_symbol(jl_fieldref(args[2],0))) {\n            size_t idx = jl_field_index(sty,\n                                        (jl_sym_t*)jl_fieldref(args[2],0), 0);\n            if (idx != (size_t)-1) {\n                jl_value_t *ft = jl_svecref(sty->types, idx);\n                jl_value_t *rhst = expr_type(args[3], ctx);\n                rt2 = rhst;\n                if (jl_is_leaf_type((jl_value_t*)sty) && jl_subtype(rhst, ft, 0)) {\n                    // TODO: attempt better codegen for approximate types\n                    jl_cgval_t strct = emit_expr(args[1], ctx); // emit lhs\n                    *ret = emit_expr(args[3], ctx);\n                    emit_setfield(sty, strct, idx, *ret, ctx, true, true);\n                    JL_GC_POP();\n                    return true;\n                }\n            }\n        }\n        // TODO: faster code for integer index\n    }\n\n    else if (f==jl_builtin_nfields && nargs==1) {\n        if (ctx->vaStack && slot_eq(args[1], ctx->vaSlot)) {\n            *ret = mark_julia_type(emit_n_varargs(ctx), false, jl_long_type, ctx);\n            JL_GC_POP();\n            return true;\n        }\n        jl_value_t *aty = expr_type(args[1], ctx); rt1 = aty;\n        if (jl_is_type_type(aty)) {\n            jl_value_t *tp0 = jl_tparam0(aty);\n            if (jl_is_leaf_type(tp0)) {\n                emit_expr(args[1], ctx);\n                assert(jl_is_datatype(tp0));\n                *ret = mark_julia_type(ConstantInt::get(T_size, jl_datatype_nfields(tp0)), false, jl_long_type, ctx);\n                JL_GC_POP();\n                return true;\n            }\n        }\n        else if (jl_is_leaf_type(aty)) {\n            jl_cgval_t arg1 = emit_expr(args[1], ctx);\n            Value *sz;\n            if (arg1.constant) {\n                sz = ConstantInt::get(T_size, jl_datatype_nfields(arg1.typ));\n            }\n            else if (aty == (jl_value_t*)jl_datatype_type) {\n                assert(arg1.isboxed);\n                sz = emit_datatype_nfields(boxed(arg1, ctx));\n            }\n            else {\n                sz = ConstantInt::get(T_size, jl_datatype_nfields(aty));\n            }\n            *ret = mark_julia_type(sz, false, jl_long_type, ctx);\n            JL_GC_POP();\n            return true;\n        }\n    }\n\n    else if (f==jl_builtin_fieldtype && nargs==2) {\n        jl_datatype_t *sty = (jl_datatype_t*)expr_type(args[1], ctx);\n        rt1 = (jl_value_t*)sty;\n        if (jl_is_type_type((jl_value_t*)sty) || sty == jl_datatype_type) {\n            rt2 = expr_type(args[2], ctx); // index argument type\n            if (rt2 == (jl_value_t*)jl_long_type) {\n                jl_cgval_t ty = emit_expr(args[1], ctx);\n                assert(ty.isboxed);\n                Value *tyv = boxed(ty, ctx);\n                Value *types_svec = emit_datatype_types(tyv);\n                Value *types_len = emit_datatype_nfields(tyv);\n                Value *idx = emit_unbox(T_size, emit_expr(args[2], ctx), (jl_value_t*)jl_long_type);\n                emit_bounds_check(ty, (jl_value_t*)jl_datatype_type, idx, types_len, ctx);\n                Value *fieldtyp = tbaa_decorate(tbaa_const, builder.CreateLoad(builder.CreateGEP(emit_bitcast(types_svec, T_ppjlvalue), idx)));\n                *ret = mark_julia_type(fieldtyp, true, expr_type(expr, ctx), ctx);\n                JL_GC_POP();\n                return true;\n            }\n        }\n    }\n\n    else if (f==jl_builtin_sizeof && nargs == 1) {\n        jl_datatype_t *sty = (jl_datatype_t*)expr_type(args[1], ctx);\n        rt1 = (jl_value_t*)sty;\n        if (jl_is_type_type((jl_value_t*)sty) && !jl_is_typevar(jl_tparam0(sty))) {\n            sty = (jl_datatype_t*)jl_tparam0(sty);\n        }\n        if (jl_is_datatype(sty) && sty != jl_symbol_type && sty->name != jl_array_typename &&\n            sty != jl_simplevector_type &&\n            // exclude DataType, since each DataType has its own size, not sizeof(DataType).\n            // this is issue #8798\n            sty != jl_datatype_type) {\n            if (jl_is_leaf_type((jl_value_t*)sty) ||\n                (sty->name->names == jl_emptysvec && sty->size > 0)) {\n                *ret = mark_julia_type(ConstantInt::get(T_size, sty->size), false, jl_long_type, ctx);\n                JL_GC_POP();\n                return true;\n            }\n        }\n    }\n\n    else if (f==jl_builtin_apply_type && nargs > 0) {\n        size_t i;\n        if (ctx->linfo->def == NULL) {\n            // don't bother codegen constant-folding for toplevel\n            JL_GC_POP();\n            return false;\n        }\n        for (i=1; i <= nargs; i++) {\n            if (!is_constant(args[i], ctx))\n                break;\n        }\n        if (i > nargs) {\n            jl_value_t *ty = static_eval(expr, ctx, true, true);\n            if (ty!=NULL && jl_is_leaf_type(ty)) {\n                if (jl_has_typevars(ty)) {\n                    // add root for types not cached. issue #7065\n                    jl_add_linfo_root(ctx->linfo, ty);\n                }\n                *ret = mark_julia_const(ty);\n                JL_GC_POP();\n                return true;\n            }\n        }\n    }\n    // TODO: other known builtins\n    JL_GC_POP();\n    return false;\n}\n\nstatic Value *emit_jlcall(Value *theFptr, Value *theF, jl_value_t **args,\n                          size_t nargs, jl_codectx_t *ctx)\n{\n    // emit arguments\n    Value *myargs;\n    if (nargs > 0) {\n        jl_cgval_t *anArg = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * nargs);\n        const jl_cgval_t **largs = (const jl_cgval_t**)alloca(sizeof(jl_cgval_t*) * nargs);\n        for(size_t i=0; i < nargs; i++) {\n            anArg[i] = emit_expr(args[i], ctx);\n            largs[i] = &anArg[i];\n        }\n        // put into argument space\n        myargs = make_jlcall(makeArrayRef(largs, nargs), ctx);\n    }\n    else {\n        myargs = Constant::getNullValue(T_ppjlvalue);\n    }\n#ifdef LLVM37\n    Value *result = builder.CreateCall(prepare_call(theFptr), {theF, myargs,\n                                       ConstantInt::get(T_int32,nargs)});\n#else\n    Value *result = builder.CreateCall3(prepare_call(theFptr), theF, myargs,\n                                        ConstantInt::get(T_int32,nargs));\n#endif\n    return result;\n}\n\nstatic jl_cgval_t emit_call_function_object(jl_lambda_info_t *li, const jl_cgval_t &theF, Value *theFptr,\n                                            jl_value_t **args, size_t nargs, jl_value_t *callexpr, jl_codectx_t *ctx)\n{\n    if (li->functionObjectsDecls.specFunctionObject != NULL) {\n        // emit specialized call site\n        jl_value_t *jlretty = li->rettype;\n        bool retboxed;\n        (void)julia_type_to_llvm(jlretty, &retboxed);\n        Function *cf = cast<Function>(prepare_call((Function*)li->functionObjectsDecls.specFunctionObject));\n        FunctionType *cft = cf->getFunctionType();\n        size_t nfargs = cft->getNumParams();\n        Value **argvals = (Value**) alloca(nfargs*sizeof(Value*));\n        bool sret = cf->hasStructRetAttr();\n        unsigned idx = 0;\n        Value *result;\n        if (sret) {\n            result = emit_static_alloca(cft->getParamType(0)->getContainedType(0), ctx);\n            argvals[idx] = result;\n            idx++;\n        }\n        SmallVector<Value*, 16> gc_uses;\n        for(size_t i=0; i < nargs+1; i++) {\n            jl_value_t *jt = jl_nth_slot_type(li->specTypes,i);\n            bool isboxed;\n            Type *et = julia_type_to_llvm(jt, &isboxed);\n            if (type_is_ghost(et)) {\n                // Still emit the expression in case it has side effects\n                if (i>0) emit_expr(args[i], ctx);\n                continue;\n            }\n            assert(idx < nfargs);\n            Type *at = cft->getParamType(idx);\n            if (isboxed) {\n                assert(at == T_pjlvalue && et == T_pjlvalue);\n                jl_cgval_t origval = i==0 ? theF : emit_expr(args[i], ctx);\n                argvals[idx] = boxed(origval, ctx);\n            }\n            else if (et->isAggregateType()) {\n                // can lazy load on demand, no copy needed\n                assert(at == PointerType::get(et, 0));\n                jl_cgval_t arg = i==0 ? theF : emit_expr(args[i], ctx);\n                assert(arg.ispointer());\n                argvals[idx] = data_pointer(arg, ctx, at);\n                push_gc_use(gc_uses, arg);\n            }\n            else {\n                assert(at == et);\n                if (i == 0)\n                    argvals[idx] = emit_unbox(et, theF, jt);\n                else\n                    argvals[idx] = emit_unbox(et, emit_expr(args[i], ctx), jt);\n            }\n            idx++;\n        }\n        assert(idx == nfargs);\n        mark_gc_uses(gc_uses);\n        CallInst *call = builder.CreateCall(prepare_call(cf), ArrayRef<Value*>(&argvals[0], nfargs));\n        call->setAttributes(cf->getAttributes());\n        mark_gc_uses(gc_uses);\n        return sret ? mark_julia_slot(result, jlretty, tbaa_stack) : mark_julia_type(call, retboxed, jlretty, ctx);\n    }\n    return mark_julia_type(emit_jlcall(theFptr, boxed(theF,ctx), &args[1], nargs, ctx), true,\n                           expr_type(callexpr, ctx), ctx);\n}\n\nstatic jl_cgval_t emit_invoke(jl_expr_t *ex, jl_codectx_t *ctx)\n{\n    jl_value_t **args = (jl_value_t**)jl_array_data(ex->args);\n    size_t arglen = jl_array_dim0(ex->args);\n    size_t nargs = arglen - 1;\n    assert(arglen >= 2);\n\n    jl_cgval_t lival = emit_expr(args[0], ctx);\n    if (lival.constant) {\n        jl_lambda_info_t *li = (jl_lambda_info_t*)lival.constant;\n        assert(jl_is_lambda_info(li));\n        if (li->jlcall_api == 2) {\n            assert(li->constval);\n            return mark_julia_const(li->constval);\n        }\n        if (li->functionObjectsDecls.functionObject == NULL) {\n            assert(!li->inCompile);\n            if (li->code == jl_nothing && !li->inInference && li->inferred) {\n                // XXX: it was inferred in the past, so it's almost valid to re-infer it now\n                jl_type_infer(li, 0);\n            }\n            if (!li->inInference && li->inferred && li->code != jl_nothing) {\n                jl_compile_linfo(li);\n            }\n        }\n        Value *theFptr = (Value*)li->functionObjectsDecls.functionObject;\n        if (theFptr && li->jlcall_api == 0) {\n            jl_cgval_t fval = emit_expr(args[1], ctx);\n            jl_cgval_t result = emit_call_function_object(li, fval, theFptr, &args[1], nargs - 1, (jl_value_t*)ex, ctx);\n            if (result.typ == jl_bottom_type)\n                CreateTrap(builder);\n            return result;\n        }\n    }\n    jl_cgval_t result = mark_julia_type(emit_jlcall(prepare_call(jlinvoke_func), boxed(lival, ctx, false),\n                                                    &args[1], nargs, ctx),\n                                        true, expr_type((jl_value_t*)ex, ctx), ctx);\n    if (result.typ == jl_bottom_type)\n        CreateTrap(builder);\n    return result;\n}\n\nstatic jl_cgval_t emit_call(jl_expr_t *ex, jl_codectx_t *ctx)\n{\n    jl_value_t *expr = (jl_value_t*)ex;\n    jl_value_t **args = (jl_value_t**)jl_array_data(ex->args);\n    size_t arglen = jl_array_dim0(ex->args);\n    size_t nargs = arglen - 1;\n    assert(arglen >= 1);\n    Value *theFptr = NULL;\n    jl_cgval_t result;\n\n    jl_function_t *f = (jl_function_t*)static_eval(args[0], ctx, true);\n    JL_GC_PUSH1(&f);\n    if (f != NULL) {\n        // function is a compile-time constant\n        if (jl_typeis(f, jl_intrinsic_type)) {\n            result = emit_intrinsic((intrinsic)*(uint32_t*)jl_data_ptr(f), args, nargs, ctx);\n            if (result.typ == (jl_value_t*)jl_any_type) // the select_value intrinsic may be missing type information\n                result = remark_julia_type(result, expr_type(expr, ctx));\n            JL_GC_POP();\n            return result;\n        }\n        if (jl_subtype(f, (jl_value_t*)jl_builtin_type, 1)) {\n            bool handled = emit_builtin_call(&result, (jl_value_t*)f, args, nargs, ctx, expr);\n            if (handled) {\n                JL_GC_POP();\n                return result;\n            }\n        }\n    }\n\n    // special case for known builtin not handled by emit_builtin_call\n    if (f && jl_subtype(f, (jl_value_t*)jl_builtin_type, 1)) {\n        std::map<jl_fptr_t,Function*>::iterator it = builtin_func_map.find(jl_get_builtin_fptr(f));\n        if (it != builtin_func_map.end()) {\n            theFptr = (*it).second;\n            result = mark_julia_type(emit_jlcall(theFptr, V_null, &args[1], nargs, ctx), true, expr_type(expr,ctx), ctx);\n            JL_GC_POP();\n            return result;\n        }\n    }\n\n    // emit function and arguments\n    nargs++; // add function to nargs count\n    jl_cgval_t *anArg = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * nargs);\n    const jl_cgval_t **largs = (const jl_cgval_t**)alloca(sizeof(jl_cgval_t*) * nargs);\n    for(size_t i=0; i < nargs; i++) {\n        anArg[i] = emit_expr(args[i], ctx);\n        largs[i] = &anArg[i];\n    }\n    // put into argument space\n    Value *myargs = make_jlcall(makeArrayRef(largs, nargs), ctx);\n#ifdef LLVM37\n    Value *callval = builder.CreateCall(prepare_call(jlapplygeneric_func),\n                                 {myargs, ConstantInt::get(T_int32, nargs)});\n#else\n    Value *callval = builder.CreateCall2(prepare_call(jlapplygeneric_func),\n                                  myargs, ConstantInt::get(T_int32, nargs));\n#endif\n    result = mark_julia_type(callval, true, expr_type(expr, ctx), ctx);\n\n    JL_GC_POP();\n    return result;\n}\n\n// --- accessing and assigning variables ---\n\nstatic void undef_var_error_if_null(Value *v, jl_sym_t *name, jl_codectx_t *ctx)\n{\n    Value *ok = builder.CreateICmpNE(v, V_null);\n    BasicBlock *err = BasicBlock::Create(jl_LLVMContext, \"err\", ctx->f);\n    BasicBlock *ifok = BasicBlock::Create(jl_LLVMContext, \"ok\");\n    builder.CreateCondBr(ok, ifok, err);\n    builder.SetInsertPoint(err);\n    builder.CreateCall(prepare_call(jlundefvarerror_func), literal_pointer_val((jl_value_t*)name));\n    builder.CreateUnreachable();\n    ctx->f->getBasicBlockList().push_back(ifok);\n    builder.SetInsertPoint(ifok);\n}\n\n// returns a jl_ppvalue_t location for the global variable m.s\n// if the reference currently bound or assign == true,\n//   pbnd will also be assigned with the binding address\nstatic Value *global_binding_pointer(jl_module_t *m, jl_sym_t *s,\n                                     jl_binding_t **pbnd, bool assign, jl_codectx_t *ctx)\n{\n    jl_binding_t *b = NULL;\n    if (assign) {\n        b = jl_get_binding_wr(m, s);\n        assert(b != NULL);\n    }\n    else {\n        b = jl_get_binding(m, s);\n        if (b == NULL) {\n            // var not found. switch to delayed lookup.\n            std::stringstream name;\n            name << \"delayedvar\" << globalUnique++;\n            Constant *initnul = ConstantPointerNull::get((PointerType*)T_pjlvalue);\n            GlobalVariable *bindinggv = new GlobalVariable(*ctx->f->getParent(), T_pjlvalue,\n                    false, GlobalVariable::InternalLinkage,\n                    initnul, name.str());\n            Value *cachedval = builder.CreateLoad(bindinggv);\n            BasicBlock *have_val = BasicBlock::Create(jl_LLVMContext, \"found\"),\n                *not_found = BasicBlock::Create(jl_LLVMContext, \"notfound\");\n            BasicBlock *currentbb = builder.GetInsertBlock();\n            builder.CreateCondBr(builder.CreateICmpNE(cachedval, initnul), have_val, not_found);\n            ctx->f->getBasicBlockList().push_back(not_found);\n            builder.SetInsertPoint(not_found);\n#ifdef LLVM37\n            Value *bval = builder.CreateCall(prepare_call(jlgetbindingorerror_func),\n                                              {literal_pointer_val((jl_value_t*)m),\n                                              literal_pointer_val((jl_value_t*)s)});\n#else\n            Value *bval = builder.CreateCall2(prepare_call(jlgetbindingorerror_func),\n                                              literal_pointer_val((jl_value_t*)m),\n                                              literal_pointer_val((jl_value_t*)s));\n#endif\n            builder.CreateStore(bval, bindinggv);\n            builder.CreateBr(have_val);\n            ctx->f->getBasicBlockList().push_back(have_val);\n            builder.SetInsertPoint(have_val);\n            PHINode *p = builder.CreatePHI(T_pjlvalue, 2);\n            p->addIncoming(cachedval, currentbb);\n            p->addIncoming(bval, not_found);\n            return julia_binding_gv(emit_bitcast(p, T_ppjlvalue));\n        }\n        if (b->deprecated) cg_bdw(b, ctx);\n    }\n    if (pbnd) *pbnd = b;\n    return julia_binding_gv(b);\n}\n\nstatic jl_cgval_t emit_checked_var(Value *bp, jl_sym_t *name, jl_codectx_t *ctx, bool isvol, MDNode *tbaa)\n{\n    assert(bp->getType() == T_ppjlvalue);\n    Instruction *v = builder.CreateLoad(bp, isvol);\n    if (tbaa)\n        tbaa_decorate(tbaa, v);\n    undef_var_error_if_null(v, name, ctx);\n    return mark_julia_type(v, true, jl_any_type, ctx);\n}\n\nstatic jl_cgval_t emit_sparam(size_t i, jl_codectx_t *ctx)\n{\n    if (jl_svec_len(ctx->linfo->sparam_vals) > 0) {\n        jl_value_t *e = jl_svecref(ctx->linfo->sparam_vals, i);\n        if (!jl_is_typevar(e)) {\n            return mark_julia_const(e);\n        }\n    }\n    assert(ctx->spvals_ptr != NULL);\n    Value *bp = builder.CreateConstInBoundsGEP1_32(LLVM37_param(T_pjlvalue)\n            emit_bitcast(ctx->spvals_ptr, T_ppjlvalue),\n            i + sizeof(jl_svec_t) / sizeof(jl_value_t*));\n    return mark_julia_type(tbaa_decorate(tbaa_const, builder.CreateLoad(bp)), true, jl_any_type, ctx);\n}\n\nstatic jl_cgval_t emit_global(jl_sym_t *sym, jl_codectx_t *ctx)\n{\n    jl_binding_t *jbp=NULL;\n    Value *bp = global_binding_pointer(ctx->module, sym, &jbp, false, ctx);\n    assert(bp != NULL);\n    if (jbp && jbp->value != NULL) {\n        if (jbp->constp)\n            return mark_julia_const(jbp->value);\n        // double-check that a global variable is actually defined. this\n        // can be a problem in parallel when a definition is missing on\n        // one machine.\n        return mark_julia_type(tbaa_decorate(tbaa_binding, builder.CreateLoad(bp)), true, jl_any_type, ctx);\n    }\n    return emit_checked_var(bp, sym, ctx, false, tbaa_binding);\n}\n\nstatic jl_cgval_t emit_local(jl_value_t *slotload, jl_codectx_t *ctx)\n{\n    size_t sl = jl_slot_number(slotload) - 1;\n    jl_varinfo_t &vi = ctx->slots[sl];\n    jl_sym_t *sym = slot_symbol(sl, ctx);\n    if (vi.memloc) {\n        Value *bp = vi.memloc;\n        jl_value_t *typ;\n        if (ctx->linfo->inferred) {\n            // use the better type from inference for this load\n            typ = expr_type(slotload, ctx);\n            if (jl_is_typevar(typ))\n                typ = ((jl_tvar_t*)typ)->ub;\n        }\n        else {\n            // use the static type of the slot\n            typ = vi.value.typ;\n        }\n\n        if (vi.isArgument || !vi.usedUndef) { // arguments are always defined\n            Instruction *v = builder.CreateLoad(bp, vi.isVolatile);\n            return mark_julia_type(v, true, typ, ctx,\n                                   !vi.isArgument); // if an argument, doesn't need an additional root\n        }\n        else {\n            jl_cgval_t v = emit_checked_var(bp, sym, ctx, vi.isVolatile, nullptr);\n            v = remark_julia_type(v, typ); // patch up type, if possible\n            return v;\n        }\n    }\n    else if (!vi.isVolatile || vi.isArgument) {\n        return vi.value;\n    }\n    else {\n        // copy value to a non-mutable location\n        Type *T = julia_type_to_llvm(vi.value.typ)->getPointerTo();\n        Value *v = data_pointer(vi.value, ctx, T);\n        return mark_julia_type(builder.CreateLoad(v, vi.isVolatile), false, vi.value.typ, ctx);\n    }\n}\n\nstatic void emit_assignment(jl_value_t *l, jl_value_t *r, jl_codectx_t *ctx)\n{\n    if (jl_is_ssavalue(l)) {\n        ssize_t idx = ((jl_ssavalue_t*)l)->id;\n        assert(idx >= 0);\n        assert(!ctx->ssavalue_assigned.at(idx));\n        jl_cgval_t slot = emit_expr(r, ctx); // slot could be a jl_value_t (unboxed) or jl_value_t* (ispointer)\n        if (!slot.isboxed && !slot.isimmutable) { // emit a copy of values stored in mutable slots\n            Type *vtype = julia_type_to_llvm(slot.typ);\n            assert(vtype != T_pjlvalue);\n            Value *dest = emit_static_alloca(vtype);\n            emit_unbox(vtype, slot, slot.typ, dest);\n            slot = mark_julia_slot(dest, slot.typ, tbaa_stack);\n        }\n        if (slot.isboxed && slot.isimmutable) {\n            // see if inference had a better type for the ssavalue than the expression (after inlining getfield on a Tuple)\n            jl_value_t *ssavalue_types = (jl_value_t*)ctx->linfo->ssavaluetypes;\n            if (jl_is_array(ssavalue_types)) {\n                jl_value_t *declType = jl_array_ptr_ref(ssavalue_types, idx);\n                if (declType != slot.typ) {\n                    slot = remark_julia_type(slot, declType);\n                }\n            }\n        }\n        ctx->SAvalues.at(idx) = slot; // now SAvalues[idx] contains the SAvalue\n        ctx->ssavalue_assigned.at(idx) = true;\n        return;\n    }\n\n    jl_sym_t *s = NULL;\n    jl_binding_t *bnd = NULL;\n    Value *bp = NULL;\n    if (jl_is_symbol(l))\n        s = (jl_sym_t*)l;\n    else if (jl_is_globalref(l))\n        bp = global_binding_pointer(jl_globalref_mod(l), jl_globalref_name(l), &bnd, true, ctx); // now bp != NULL\n    else\n        assert(jl_is_slot(l));\n    if (bp == NULL && s != NULL)\n        bp = global_binding_pointer(ctx->module, s, &bnd, true, ctx);\n    if (bp != NULL) { // it's a global\n        assert(bnd);\n        Value *rval = boxed(emit_expr(r, ctx), ctx, false); // no root needed since this is about to be assigned to a global\n#ifdef LLVM37\n        builder.CreateCall(prepare_call(jlcheckassign_func),\n                           {literal_pointer_val(bnd),\n                            rval});\n#else\n        builder.CreateCall2(prepare_call(jlcheckassign_func),\n                           literal_pointer_val(bnd),\n                            rval);\n#endif\n        // Global variable. Does not need debug info because the debugger knows about\n        // its memory location.\n        return;\n    }\n\n    int sl = jl_slot_number(l)-1;\n    // it's a local variable\n    jl_varinfo_t &vi = ctx->slots[sl];\n    jl_cgval_t rval_info = emit_expr(r, ctx);\n    if (!vi.used)\n        return;\n\n    // add info to arrayvar list\n    if (rval_info.isboxed) {\n        // check isboxed in case rval isn't the right type (for example, on a dead branch),\n        // so we don't try to assign it to the arrayvar info\n        jl_arrayvar_t *av = arrayvar_for(l, ctx);\n        if (av != NULL)\n            assign_arrayvar(*av, rval_info, ctx);\n    }\n\n    if (vi.memloc) {\n        // boxed variables\n        if (((!vi.isSA && rval_info.gcroot) || !rval_info.isboxed) && isa<AllocaInst>(vi.memloc)) {\n            // rval had a gcroot, so lval needs one too: promote variable slot to a gcroot\n            emit_local_root(ctx, &vi);\n        }\n        Value *rval = boxed(rval_info, ctx, false); // no root needed on the temporary since it is about to be assigned to the variable slot\n        builder.CreateStore(rval, vi.memloc, vi.isVolatile);\n    }\n    else if (vi.value.constant) {\n        // virtual store\n    }\n    else {\n        // store unboxed\n        assert(vi.value.ispointer());\n        emit_unbox(julia_type_to_llvm(vi.value.typ), rval_info, vi.value.typ, vi.value.V, vi.isVolatile);\n    }\n}\n\n// --- convert expression to code ---\n\nstatic Value *emit_condition(const jl_cgval_t &condV, const std::string &msg,\n                             jl_codectx_t *ctx)\n{\n    if (condV.typ == (jl_value_t*)jl_bool_type) {\n        Value *cond = emit_unbox(T_int8, condV, (jl_value_t*)jl_bool_type);\n        assert(cond->getType() == T_int8);\n        return builder.CreateXor(builder.CreateTrunc(cond,T_int1), ConstantInt::get(T_int1,1));\n    }\n    emit_typecheck(condV, (jl_value_t*)jl_bool_type, msg, ctx);\n    if (condV.isboxed) {\n        return builder.CreateICmpEQ(boxed(condV, ctx), literal_pointer_val(jl_false));\n    }\n    // not a boolean\n    return ConstantInt::get(T_int1,0); // TODO: replace with Undef\n}\n\nstatic Value *emit_condition(jl_value_t *cond, const std::string &msg, jl_codectx_t *ctx)\n{\n    return emit_condition(emit_expr(cond, ctx), msg, ctx);\n}\n\nstatic void emit_stmtpos(jl_value_t *expr, jl_codectx_t *ctx)\n{\n    if (jl_is_ssavalue(expr))\n        return; // value not used, no point in attempting codegen for it\n    if (jl_is_linenode(expr))\n        return;\n    if (jl_is_slot(expr)) {\n        size_t sl = jl_slot_number(expr) - 1;\n        jl_varinfo_t &vi = ctx->slots[sl];\n        if (vi.usedUndef)\n            (void)emit_expr(expr, ctx);\n        return;\n    }\n    if (jl_is_newvarnode(expr)) {\n        jl_value_t *var = jl_fieldref(expr, 0);\n        assert(jl_is_slot(var));\n        jl_varinfo_t &vi = ctx->slots[jl_slot_number(var)-1];\n        Value *lv = vi.memloc;\n        if (lv != NULL) {\n            // create a new uninitialized variable\n            if (vi.usedUndef)\n                builder.CreateStore(V_null, lv);\n        }\n        return;\n    }\n    if (jl_is_expr(expr)) {\n        jl_sym_t *head = ((jl_expr_t*)expr)->head;\n        // some expression types are metadata and can be ignored in statement position\n        if (head == line_sym || head == meta_sym)\n            return;\n        // fall-through\n    }\n    (void)emit_expr(expr, ctx);\n}\n\nstatic jl_cgval_t emit_expr(jl_value_t *expr, jl_codectx_t *ctx)\n{\n    if (jl_is_symbol(expr)) {\n        jl_sym_t *sym = (jl_sym_t*)expr;\n        return emit_global(sym, ctx);\n    }\n    if (jl_is_slot(expr)) {\n        return emit_local(expr, ctx);\n    }\n    if (jl_is_ssavalue(expr)) {\n        ssize_t idx = ((jl_ssavalue_t*)expr)->id;\n        assert(idx >= 0);\n        if (!ctx->ssavalue_assigned.at(idx)) {\n            ctx->ssavalue_assigned.at(idx) = true; // (assignment, not comparison test)\n            return jl_cgval_t(); // dead code branch\n        }\n        else {\n            return ctx->SAvalues.at(idx); // at this point, SAvalues[idx] actually contains the SAvalue\n        }\n    }\n    if (jl_is_labelnode(expr)) {\n        int labelname = jl_labelnode_label(expr);\n        BasicBlock *bb = (*ctx->labels)[labelname];\n        assert(bb);\n        if (builder.GetInsertBlock()->getTerminator() == NULL) {\n            builder.CreateBr(bb); // all BasicBlocks must exit explicitly\n        }\n        builder.SetInsertPoint(bb);\n        return jl_cgval_t();\n    }\n    if (jl_is_linenode(expr)) {\n        jl_error(\"Linenode in value position\");\n    }\n    if (jl_is_gotonode(expr)) {\n        if (builder.GetInsertBlock()->getTerminator() == NULL) {\n            int labelname = jl_gotonode_label(expr);\n            BasicBlock *bb = (*ctx->labels)[labelname];\n            assert(bb);\n            builder.CreateBr(bb);\n            BasicBlock *after = BasicBlock::Create(jl_LLVMContext,\n                                                   \"br\", ctx->f);\n            builder.SetInsertPoint(after);\n        }\n        return jl_cgval_t();\n    }\n    if (jl_is_globalref(expr)) {\n        return emit_getfield((jl_value_t*)jl_globalref_mod(expr), jl_globalref_name(expr), ctx);\n    }\n    if (!jl_is_expr(expr)) {\n        int needroot = true;\n        if (jl_is_quotenode(expr)) {\n            expr = jl_fieldref(expr,0);\n        }\n        // numeric literals\n        if (jl_is_int32(expr)) {\n            int32_t val = jl_unbox_int32(expr);\n            if ((uint32_t)(val+512) < 1024) {\n                // this can be gotten from the box cache\n                needroot = false;\n                expr = jl_box_int32(val);\n            }\n        }\n        else if (jl_is_int64(expr)) {\n            uint64_t val = jl_unbox_uint64(expr);\n            if ((uint64_t)(val+512) < 1024) {\n                // this can be gotten from the box cache\n                needroot = false;\n                expr = jl_box_int64(val);\n            }\n        }\n        if (needroot && ctx->linfo->def) { // toplevel exprs and some integers are already rooted\n            jl_add_linfo_root(ctx->linfo, expr);\n        }\n        return mark_julia_const(expr);\n    }\n\n    jl_expr_t *ex = (jl_expr_t*)expr;\n    jl_value_t **args = (jl_value_t**)jl_array_data(ex->args);\n    jl_sym_t *head = ex->head;\n    // this is object-disoriented.\n    // however, this is a good way to do it because it should *not* be easy\n    // to add new node types.\n    if (head == goto_ifnot_sym) {\n        jl_value_t *cond = args[0];\n        int labelname = jl_unbox_long(args[1]);\n        BasicBlock *ifso = BasicBlock::Create(jl_LLVMContext, \"if\", ctx->f);\n        BasicBlock *ifnot = (*ctx->labels)[labelname];\n        assert(ifnot);\n        // Any branches treated as constant in type inference should be\n        // eliminated before running\n        Value *isfalse = emit_condition(cond, \"if\", ctx);\n        builder.CreateCondBr(isfalse, ifnot, ifso);\n        builder.SetInsertPoint(ifso);\n    }\n    else if (head == invoke_sym) {\n        return emit_invoke(ex, ctx);\n    }\n    else if (head == call_sym) {\n        if (ctx->linfo->def) { // don't bother codegen constant-folding for toplevel\n            jl_value_t *c = static_eval(expr, ctx, true, true);\n            if (c) {\n                jl_add_linfo_root(ctx->linfo, c);\n                return mark_julia_const(c);\n            }\n        }\n        jl_cgval_t res = emit_call(ex, ctx);\n        // some intrinsics (e.g. typeassert) can return a wider type\n        // than what's actually possible\n        jl_value_t *expr_t = expr_type((jl_value_t*)ex, ctx);\n        if (res.typ != expr_t && res.isboxed && !jl_is_leaf_type(res.typ)) {\n            res = remark_julia_type(res, expr_t);\n        }\n        if (res.typ == jl_bottom_type || expr_t == jl_bottom_type) {\n            CreateTrap(builder);\n        }\n        return res;\n    }\n    else if (head == assign_sym) {\n        emit_assignment(args[0], args[1], ctx);\n        return ghostValue(jl_void_type);\n    }\n    else if (head == static_parameter_sym) {\n        return emit_sparam(jl_unbox_long(args[0])-1, ctx);\n    }\n    else if (head == method_sym) {\n        jl_value_t *mn = args[0];\n        assert(jl_expr_nargs(ex) != 1 || jl_is_symbol(mn) || jl_is_slot(mn));\n\n        Value *bp = NULL, *name, *bp_owner = V_null;\n        jl_binding_t *bnd = NULL;\n        if (jl_is_symbol(mn)) {\n            if (jl_symbol_name((jl_sym_t*)mn)[0] == '@')\n                jl_errorf(\"macro definition not allowed inside a local scope\");\n            name = literal_pointer_val(mn);\n            bnd = jl_get_binding_for_method_def(ctx->module, (jl_sym_t*)mn);\n            bp = julia_binding_gv(bnd);\n            bp_owner = literal_pointer_val((jl_value_t*)ctx->module);\n        }\n        else if (jl_is_slot(mn)) {\n            int sl = jl_slot_number(mn)-1;\n            jl_varinfo_t &vi = ctx->slots[sl];\n            bp = vi.memloc;\n            name = literal_pointer_val((jl_value_t*)slot_symbol(sl, ctx));\n        }\n        if (bp) {\n            Value *mdargs[4] = { name, bp, bp_owner, literal_pointer_val(bnd) };\n            jl_cgval_t gf = mark_julia_type(\n                    builder.CreateCall(prepare_call(jlgenericfunction_func), ArrayRef<Value*>(&mdargs[0], 4)),\n                    true, jl_function_type, ctx);\n            if (jl_expr_nargs(ex) == 1)\n                return gf;\n        }\n        Value *a1 = boxed(emit_expr(args[1], ctx), ctx);\n        Value *a2 = boxed(emit_expr(args[2], ctx), ctx);\n        Value *mdargs[3] = { a1, a2, literal_pointer_val(args[3]) };\n        builder.CreateCall(prepare_call(jlmethod_func), ArrayRef<Value*>(&mdargs[0], 3));\n        return ghostValue(jl_void_type);\n    }\n    else if (head == const_sym) {\n        jl_sym_t *sym = (jl_sym_t*)args[0];\n        if (jl_is_symbol(sym)) {\n            jl_binding_t *bnd = NULL;\n            (void)global_binding_pointer(ctx->module, sym, &bnd, true, ctx); assert(bnd);\n            builder.CreateCall(prepare_call(jldeclareconst_func),\n                               literal_pointer_val(bnd));\n        }\n    }\n    else if (head == new_sym) {\n        jl_value_t *ty = expr_type(args[0], ctx);\n        size_t nargs = jl_array_len(ex->args);\n        if (jl_is_type_type(ty) &&\n            jl_is_datatype(jl_tparam0(ty)) &&\n            jl_is_leaf_type(jl_tparam0(ty))) {\n            assert(nargs <= jl_datatype_nfields(jl_tparam0(ty))+1);\n            return emit_new_struct(jl_tparam0(ty),nargs,args,ctx);\n        }\n        Value *typ = boxed(emit_expr(args[0], ctx), ctx);\n        Value *val = emit_jlcall(jlnew_func, typ, &args[1], nargs-1, ctx);\n        return mark_julia_type(val, true, ty, ctx);\n    }\n    else if (head == exc_sym) { // *ptls->exception_in_transit\n        return mark_julia_type(builder.CreateLoad(emit_exc_in_transit(ctx),\n                                                  /*isvolatile*/true),\n                               true, jl_any_type, ctx);\n    }\n    else if (head == leave_sym) {\n        assert(jl_is_long(args[0]));\n        builder.CreateCall(prepare_call(jlleave_func),\n                           ConstantInt::get(T_int32, jl_unbox_long(args[0])));\n    }\n    else if (head == enter_sym) {\n        assert(jl_is_long(args[0]));\n        int labl = jl_unbox_long(args[0]);\n        Value *jbuf = builder.CreateGEP((*ctx->handlers)[labl],\n                                        ConstantInt::get(T_size,0));\n        builder.CreateCall(prepare_call(jlenter_func), jbuf);\n#ifndef _OS_WINDOWS_\n#ifdef LLVM37\n        CallInst *sj = builder.CreateCall(prepare_call(setjmp_func), { jbuf, ConstantInt::get(T_int32,0) });\n#else\n        CallInst *sj = builder.CreateCall2(prepare_call(setjmp_func), jbuf, ConstantInt::get(T_int32,0));\n#endif\n#else\n        CallInst *sj = builder.CreateCall(prepare_call(setjmp_func), jbuf);\n#endif\n        // We need to mark this on the call site as well. See issue #6757\n        sj->setCanReturnTwice();\n        Value *isz = builder.CreateICmpEQ(sj, ConstantInt::get(T_int32,0));\n        BasicBlock *tryblk = BasicBlock::Create(jl_LLVMContext, \"try\",\n                                                ctx->f);\n        BasicBlock *handlr = (*ctx->labels)[labl];\n        assert(handlr);\n#ifdef _OS_WINDOWS_\n        BasicBlock *cond_resetstkoflw_blk = BasicBlock::Create(jl_LLVMContext, \"cond_resetstkoflw\", ctx->f);\n        BasicBlock *resetstkoflw_blk = BasicBlock::Create(jl_LLVMContext, \"resetstkoflw\", ctx->f);\n        builder.CreateCondBr(isz, tryblk, cond_resetstkoflw_blk);\n        builder.SetInsertPoint(cond_resetstkoflw_blk);\n        builder.CreateCondBr(builder.CreateICmpEQ(\n                    literal_pointer_val(jl_stackovf_exception),\n                    builder.CreateLoad(emit_exc_in_transit(ctx), true)),\n                resetstkoflw_blk, handlr);\n        builder.SetInsertPoint(resetstkoflw_blk);\n        builder.CreateCall(prepare_call(resetstkoflw_func)\n#                          ifdef LLVM37\n                           , {}\n#                          endif\n                           );\n        builder.CreateBr(handlr);\n#else\n        builder.CreateCondBr(isz, tryblk, handlr);\n#endif\n        builder.SetInsertPoint(tryblk);\n    }\n    else if (head == inbounds_sym) {\n        // manipulate inbounds stack\n        // note that when entering an inbounds context, we must also update\n        // the boundsCheck context to be false\n        if (jl_array_len(ex->args) > 0) {\n            jl_value_t *arg = args[0];\n            if (arg == jl_true) {\n                ctx->inbounds.push_back(true);\n                ctx->boundsCheck.push_back(false);\n            }\n            else if (arg == jl_false) {\n                ctx->inbounds.push_back(false);\n                ctx->boundsCheck.push_back(false);\n            }\n            else {\n                if (!ctx->inbounds.empty())\n                    ctx->inbounds.pop_back();\n                if (!ctx->boundsCheck.empty())\n                    ctx->boundsCheck.pop_back();\n            }\n        }\n        return ghostValue(jl_void_type);\n    }\n    else if (head == boundscheck_sym) {\n        if (jl_array_len(ex->args) > 0) {\n            jl_value_t *arg = args[0];\n            if (arg == jl_true) {\n                ctx->boundsCheck.push_back(true);\n            }\n            else if (arg == jl_false) {\n                ctx->boundsCheck.push_back(false);\n            }\n            else {\n                if (!ctx->boundsCheck.empty())\n                    ctx->boundsCheck.pop_back();\n            }\n        }\n        return ghostValue(jl_void_type);\n    }\n    else if (head == copyast_sym) {\n        jl_value_t *arg = args[0];\n        if (jl_is_quotenode(arg)) {\n            jl_value_t *arg1 = jl_fieldref(arg,0);\n            if (!(jl_is_expr(arg1) || jl_typeis(arg1,jl_array_any_type) || jl_is_quotenode(arg1))) {\n                // elide call to jl_copy_ast when possible\n                return emit_expr(arg, ctx);\n            }\n        }\n        jl_cgval_t ast = emit_expr(arg, ctx);\n        return mark_julia_type(builder.CreateCall(prepare_call(jlcopyast_func), boxed(ast, ctx)), true, ast.typ, ctx);\n    }\n    else if (head == simdloop_sym) {\n        llvm::annotateSimdLoop(builder.GetInsertBlock());\n        return jl_cgval_t();\n    }\n    else {\n        if (!strcmp(jl_symbol_name(head), \"$\"))\n            jl_error(\"syntax: prefix \\\"$\\\" in non-quoted expression\");\n        if (jl_is_toplevel_only_expr(expr) &&\n            ctx->linfo->def == NULL) {\n            // call interpreter to run a toplevel expr from inside a\n            // compiled toplevel thunk.\n            builder.CreateCall(prepare_call(jltopeval_func), literal_pointer_val(expr));\n            return ghostValue(jl_void_type);\n        }\n        if (head == abstracttype_sym || head == compositetype_sym ||\n            head == bitstype_sym) {\n            jl_errorf(\"type definition not allowed inside a local scope\");\n        }\n        else {\n            jl_errorf(\"unsupported or misplaced expression \\\"%s\\\" in function %s\",\n                      jl_symbol_name(head), ctx->name);\n        }\n    }\n    return jl_cgval_t();\n}\n\n// --- generate function bodies ---\n\n// gc frame emission\nstatic void allocate_gc_frame(BasicBlock *b0, jl_codectx_t *ctx)\n{\n    // allocate a placeholder gc instruction\n    ctx->ptlsStates = builder.CreateCall(prepare_call(jltls_states_func));\n    int nthfield = offsetof(jl_tls_states_t, safepoint) / sizeof(void*);\n    ctx->signalPage = emit_nthptr_recast(ctx->ptlsStates, nthfield, tbaa_const,\n                                         PointerType::get(T_psize, 0));\n}\n\nstatic Function *gen_cfun_wrapper(jl_function_t *ff, jl_value_t *jlrettype, jl_tupletype_t *argt,\n                                  jl_typemap_entry_t *sf, jl_value_t *declrt, jl_tupletype_t *sigt)\n{\n    // Generate a c-callable wrapper\n    bool toboxed;\n    Type *crt = julia_struct_to_llvm(jlrettype, &toboxed);\n    if (crt == NULL)\n        jl_error(\"cfunction: return type doesn't correspond to a C type\");\n\n    std::vector<Type*> fargt(0);\n    std::vector<bool> fargt_isboxed(0);\n    std::vector<Type*> fargt_sig(0);\n    Type *fargt_vasig;\n    std::vector<bool> inRegList(0);\n    std::vector<bool> byRefList(0);\n    AttributeSet attrs;\n    Type *prt = NULL;\n    int sret = 0;\n    size_t nargs = jl_nparams(argt);\n    std::string err_msg = generate_func_sig(&crt, &prt, sret, fargt, fargt_isboxed, fargt_sig, fargt_vasig, inRegList, byRefList, attrs,\n                                            jlrettype, argt->parameters, nargs);\n    if (!err_msg.empty())\n        jl_error(err_msg.c_str());\n    if (fargt.size() + sret != fargt_sig.size())\n        jl_error(\"va_arg syntax not allowed for cfunction argument list\");\n\n    const char *name = \"cfunction\";\n    // try to look up this function for direct invoking\n    jl_lambda_info_t *lam = jl_get_specialization1((jl_tupletype_t*)sigt);\n    jl_value_t *astrt = (jl_value_t*)jl_any_type;\n    // infer it first, if necessary\n    if (lam && lam->inInference)\n        lam = NULL; // TODO: use emit_invoke framework to dispatch these\n    if (lam) {\n        if (lam->functionObjectsDecls.functionObject == NULL && lam->jlcall_api != 2) {\n            if (lam && (lam->code == jl_nothing || !lam->inferred))\n                jl_type_infer(lam, 0);\n            if (lam && (lam->inInference || !lam->inferred))\n                lam = NULL; // TODO: use emit_invoke framework to dispatch these\n        }\n    }\n    if (lam != NULL) {\n        jl_compile_linfo(lam);\n        name = jl_symbol_name(lam->def->name);\n        astrt = lam->rettype;\n        if (astrt != (jl_value_t*)jl_bottom_type &&\n            jl_type_intersection(astrt, declrt) == jl_bottom_type) {\n            // Do not warn if the function does not return since it is\n            // occasionally required by the C API (typically error callbacks)\n            // and doesn't capture the majority of the case when a function\n            // may throw.\n            jl_printf(JL_STDERR, \"WARNING: cfunction: return type of %s does not match\", name);\n        }\n        if (!lam->functionObjectsDecls.functionObject && lam->jlcall_api != 2) {\n            jl_errorf(\"ERROR: cfunction: compiling %s failed\", name);\n        }\n    }\n\n    std::stringstream funcName;\n    funcName << \"jlcapi_\" << name << \"_\" << globalUnique++;\n\n    Module *M = new Module(name, jl_LLVMContext);\n    jl_setup_module(M);\n    Function *cw = Function::Create(FunctionType::get(sret ? T_void : prt, fargt_sig, false),\n            GlobalVariable::ExternalLinkage,\n            funcName.str(), M);\n    cw->setAttributes(attrs);\n#ifdef LLVM37\n    cw->addFnAttr(\"no-frame-pointer-elim\", \"true\");\n#endif\n    Function *cw_proto = function_proto(cw);\n\n    BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", cw);\n    builder.SetInsertPoint(b0);\n    DebugLoc noDbg;\n    builder.SetCurrentDebugLocation(noDbg);\n\n    jl_codectx_t ctx = {};\n    ctx.f = cw;\n    ctx.linfo = lam;\n    ctx.sret = false;\n    ctx.spvals_ptr = NULL;\n    allocate_gc_frame(b0, &ctx);\n\n    // Save the Function object reference\n    sf->func.value = jl_box_voidpointer((void*)cw_proto);\n    jl_gc_wb(sf, sf->func.value);\n\n    // See whether this function is specsig or jlcall or generic (unknown)\n    bool specsig, jlfunc_sret;\n    Function *theFptr;\n    Value *result;\n    Value *myargs;\n    size_t FParamIndex = 0;\n    std::vector<Value*> args;\n    Function::arg_iterator AI = cw->arg_begin();\n    Value *sretPtr = sret ? &*AI++ : NULL;\n    if (lam == NULL) {\n        theFptr = jlapplygeneric_func;\n        specsig = false;\n        jlfunc_sret = false;\n        myargs = CallInst::Create(prepare_call(jlcall_frame_func),\n            ConstantInt::get(T_int32, nargs + 1),\n            \"\",\n            /*InsertBefore*/ctx.ptlsStates);\n        GetElementPtrInst *slot = GetElementPtrInst::Create(LLVM37_param(NULL) myargs,\n                ArrayRef<Value*>(ConstantInt::get(T_int32, FParamIndex++)));\n        slot->insertAfter(ctx.ptlsStates);\n        Value *theF = literal_pointer_val((jl_value_t*)ff);\n        builder.CreateStore(theF, slot);\n    }\n    else if (lam->functionObjectsDecls.specFunctionObject != NULL) {\n        theFptr = (Function*)lam->functionObjectsDecls.specFunctionObject;\n        specsig = true;\n        jlfunc_sret = theFptr->hasStructRetAttr();\n        if (jlfunc_sret) {\n            // fuse the two sret together, or emit an alloca to hold it\n            if (sret)\n                result = emit_bitcast(sretPtr, theFptr->getFunctionType()->getParamType(0));\n            else\n                result = builder.CreateAlloca(theFptr->getFunctionType()->getParamType(0)->getContainedType(0));\n            args.push_back(result);\n            FParamIndex++;\n        }\n        myargs = NULL;\n    }\n    else if (lam->jlcall_api == 2) {\n        nargs = 0; // arguments not needed\n        specsig = false;\n        jlfunc_sret = false;\n        myargs = NULL;\n        theFptr = NULL;\n    }\n    else {\n        theFptr = (Function*)lam->functionObjectsDecls.functionObject;\n        specsig = false;\n        jlfunc_sret = false;\n        myargs = CallInst::Create(prepare_call(jlcall_frame_func),\n            ConstantInt::get(T_int32, nargs),\n            \"\",\n            /*InsertBefore*/ctx.ptlsStates);\n    }\n\n    // first emit the arguments\n    for (size_t i = 0; i < nargs; i++) {\n        Value *val = &*AI++;\n        jl_value_t *jargty = jl_nth_slot_type(argt, i);\n        // figure out how to unpack this type\n        jl_cgval_t inputarg;\n        if (jl_is_abstract_ref_type(jargty)) {\n            // a pointer to a value\n            jargty = jl_tparam0(jargty);\n            if (jargty == (jl_value_t*)jl_any_type) {\n                inputarg = mark_julia_type(\n                        builder.CreateLoad(builder.CreatePointerCast(val, T_ppjlvalue)),\n                        true, jargty, &ctx);\n            }\n            else if (!jl_isbits(jargty)) {\n                // must be a jl_value_t* (because it's mutable or contains gc roots)\n                inputarg = mark_julia_type(builder.CreatePointerCast(val, T_pjlvalue), true, jargty, &ctx);\n            }\n            else {\n                bool isboxed;\n                Type *T = julia_type_to_llvm(jargty, &isboxed);\n                assert(!isboxed);\n                // a T* (of unknown origin)\n                if (type_is_ghost(T)) {\n                    inputarg = ghostValue(jargty);\n                }\n                else {\n                    val = builder.CreatePointerCast(val, T->getPointerTo());\n                    val = builder.CreateAlignedLoad(val, 1); // make no alignment assumption about pointer from C\n                    inputarg = mark_julia_type(val, false, jargty, &ctx);\n                }\n            }\n        }\n        else {\n            bool argboxed;\n            (void)julia_struct_to_llvm(jargty, &argboxed);\n            if (argboxed) {\n                // a jl_value_t*, even when represented as a struct\n                inputarg = mark_julia_type(val, true, jargty, &ctx);\n            }\n            else {\n                // something of type T\n                // undo whatever we might have done to this poor argument\n                bool issigned = jl_signed_type && jl_subtype(jargty, (jl_value_t*)jl_signed_type, 0);\n                val = llvm_type_rewrite(val, val->getType(), fargt[i], true, byRefList[i], issigned, &ctx);\n                bool isboxed;\n                (void)julia_type_to_llvm(jargty, &isboxed);\n                if (isboxed) {\n                    // passed an unboxed T, but want something boxed\n                    Value *mem = emit_allocobj(&ctx, jl_datatype_size(jargty),\n                                               literal_pointer_val((jl_value_t*)jargty));\n                    tbaa_decorate(jl_is_mutable(jargty) ? tbaa_mutab : tbaa_immut,\n                                  builder.CreateAlignedStore(val,\n                                                             emit_bitcast(mem, val->getType()->getPointerTo()),\n                                                             16)); // julia's gc gives 16-byte aligned addresses\n                    inputarg = mark_julia_type(mem, true, jargty, &ctx);\n                }\n                else {\n                    // mark that this is an unboxed T\n                    inputarg = mark_julia_type(val, false, jargty, &ctx);\n                }\n            }\n        }\n\n        // figure out how to repack this type\n        if (!specsig) {\n            Value *arg = boxed(inputarg, &ctx, false); // don't want a gcroot, since it's about to be but into the jlcall frame anyways\n            GetElementPtrInst *slot = GetElementPtrInst::Create(LLVM37_param(NULL) myargs,\n                    ArrayRef<Value*>(ConstantInt::get(T_int32, FParamIndex)));\n            slot->insertAfter(ctx.ptlsStates);\n            builder.CreateStore(arg, slot);\n        }\n        else {\n            Value *arg;\n            jl_value_t *spect = jl_nth_slot_type(lam->specTypes, i + 1); // +1 because argt excludes function\n            bool isboxed;\n            Type *T = julia_type_to_llvm(spect, &isboxed);\n            if (isboxed) {\n                arg = boxed(inputarg, &ctx);\n            }\n            else if (type_is_ghost(T)) {\n                continue; // ghost types are skipped by the specsig method signature\n            }\n            else if (T->isAggregateType()) {\n                // aggregate types are passed by pointer\n                arg = data_pointer(inputarg, &ctx, T->getPointerTo());\n            }\n            else {\n                arg = emit_unbox(T, inputarg, spect);\n                assert(!isa<UndefValue>(arg));\n            }\n\n            // add to argument list\n            args.push_back(arg);\n        }\n        FParamIndex++;\n    }\n\n    // Create the call\n    jl_cgval_t retval;\n    if (lam == NULL) {\n        assert(theFptr);\n#ifdef LLVM37\n        Value *ret = builder.CreateCall(prepare_call(theFptr), {myargs,\n                                        ConstantInt::get(T_int32, nargs + 1)});\n#else\n        Value *ret = builder.CreateCall2(prepare_call(theFptr), myargs,\n                                         ConstantInt::get(T_int32, nargs + 1));\n#endif\n        retval = mark_julia_type(ret, true, astrt, &ctx);\n    }\n    else if (specsig) {\n        assert(theFptr);\n        bool retboxed;\n        CallInst *call = builder.CreateCall(prepare_call(theFptr), ArrayRef<Value*>(args));\n        call->setAttributes(theFptr->getAttributes());\n        (void)julia_type_to_llvm(astrt, &retboxed);\n        retval = mark_julia_type(jlfunc_sret ? (Value*)builder.CreateLoad(result) : (Value*)call, retboxed, astrt, &ctx);\n    }\n    else if (lam->jlcall_api == 2) {\n        retval = mark_julia_const(lam->constval);\n    }\n    else {\n        assert(theFptr);\n        // for jlcall, we need to pass the function object even if it is a ghost.\n        // here we reconstruct the function instance from its type (first elt of argt)\n        Value *theF = literal_pointer_val((jl_value_t*)ff);\n#ifdef LLVM37\n        Value *ret = builder.CreateCall(prepare_call(theFptr), {theF, myargs,\n                                        ConstantInt::get(T_int32, nargs)});\n#else\n        Value *ret = builder.CreateCall3(prepare_call(theFptr), theF, myargs,\n                                         ConstantInt::get(T_int32, nargs));\n#endif\n        retval = mark_julia_type(ret, true, astrt, &ctx);\n    }\n\n    if (!jl_subtype(astrt, declrt, 0)) {\n        // inline a call to typeassert here\n        emit_typecheck(retval, declrt, \"cfunction\", &ctx);\n    }\n\n    // Prepare the return value\n    Value *r;\n    if (toboxed) {\n        assert(!sret);\n        // return a jl_value_t*\n        r = boxed(retval, &ctx, false); // no gcroot since this is on the return path\n    }\n    else if (sret && jlfunc_sret) {\n        // nothing to do\n    }\n    else if (!type_is_ghost(crt)) {\n        if (sret)\n            prt = fargt_sig[0]->getContainedType(0); // sret is a PointerType\n        bool issigned = jl_signed_type && jl_subtype(declrt, (jl_value_t*)jl_signed_type, 0);\n        Value *v = julia_to_native(crt, toboxed, declrt, retval,\n                false, false, false, false, false, 0, &ctx, NULL);\n        r = llvm_type_rewrite(v, crt, prt, false, false, issigned, &ctx);\n        if (sret)\n            builder.CreateStore(r, sretPtr);\n    }\n    else {\n        assert(type_is_ghost(prt));\n        sret = true;\n    }\n\n    if (sret)\n        builder.CreateRetVoid();\n    else\n        builder.CreateRet(r);\n\n    builder.SetCurrentDebugLocation(noDbg);\n    builder.ClearInsertionPoint();\n\n    jl_finalize_module(M, true);\n\n    return cw_proto;\n}\n\nconst struct jl_typemap_info cfunction_cache = {\n    1, &jl_voidpointer_type\n};\n\n// Get the LLVM Function* for the C-callable entry point for a certain function\n// and argument types.\n// here argt does not include the leading function type argument\nstatic Function *jl_cfunction_object(jl_function_t *ff, jl_value_t *declrt, jl_tupletype_t *argt)\n{\n    // validate and unpack the arguments\n    JL_TYPECHK(cfunction, type, declrt);\n    JL_TYPECHK(cfunction, type, (jl_value_t*)argt);\n    if (!jl_is_datatype_singleton((jl_datatype_t*)jl_typeof(ff)))\n        jl_error(\"closures are not yet c-callable\");\n\n    size_t i, nargs = jl_nparams(argt);\n    jl_value_t *sigt = NULL; // type signature with Ref{} annotations removed\n    jl_value_t *cfunc_sig = NULL; // type signature of the call to cfunction (for caching)\n    JL_GC_PUSH2(&sigt, &cfunc_sig);\n    sigt = (jl_value_t*)jl_alloc_svec(nargs + 1);\n    cfunc_sig = (jl_value_t*)jl_alloc_svec(nargs + 2);\n\n    jl_value_t *crt = declrt;\n    jl_svecset(cfunc_sig, nargs + 1, declrt);\n    if (jl_is_abstract_ref_type(declrt)) {\n        declrt = jl_tparam0(declrt);\n        if (jl_is_typevar(declrt))\n            jl_error(\"cfunction: return type Ref should have an element type, not Ref{T}\");\n        if (declrt == (jl_value_t*)jl_any_type)\n            jl_error(\"cfunction: return type Ref{Any} is invalid. Use Any or Ptr{Any} instead.\");\n        if (!jl_is_leaf_type(declrt))\n            jl_svecset(cfunc_sig, nargs + 1, declrt); // Ref{Abstract} is the same calling convention as Abstract\n        crt = (jl_value_t*)jl_any_type;\n    }\n\n    if (jl_is_type(ff))\n        jl_svecset(sigt, 0, jl_wrap_Type(ff));\n    else\n        jl_svecset(sigt, 0, jl_typeof(ff));\n    jl_svecset(cfunc_sig, 0, jl_svecref(sigt, 0));\n    for (i = 0; i < nargs; i++) {\n        jl_value_t *ati = jl_tparam(argt, i);\n        jl_svecset(cfunc_sig, i + 1, ati);\n        if (jl_is_abstract_ref_type(ati)) {\n            ati = jl_tparam0(ati);\n            if (jl_is_typevar(ati))\n                jl_error(\"cfunction: argument type Ref should have an element type, not Ref{T}\");\n            if (ati != (jl_value_t*)jl_any_type && !jl_is_leaf_type(ati))\n                jl_svecset(cfunc_sig, i + 1, ati); // Ref{Abstract} is the same calling convention as Abstract\n        }\n        if (jl_is_pointer(ati) && jl_is_typevar(jl_tparam0(ati)))\n            jl_error(\"cfunction: argument type Ptr should have an element type, Ptr{T}\");\n        jl_svecset(sigt, i + 1, ati);\n    }\n    sigt = (jl_value_t*)jl_apply_tuple_type((jl_svec_t*)sigt);\n    cfunc_sig = (jl_value_t*)jl_apply_tuple_type((jl_svec_t*)cfunc_sig);\n\n    // check the cache\n    if (jl_cfunction_list.unknown != jl_nothing) {\n        jl_typemap_entry_t *sf = jl_typemap_assoc_by_type(jl_cfunction_list, (jl_tupletype_t*)cfunc_sig, NULL, 1, 0, /*offs*/0);\n        if (sf) {\n            Function *f = (Function*)jl_unbox_voidpointer(sf->func.value);\n            if (f) {\n               JL_GC_POP();\n               return f;\n            }\n        }\n    }\n    jl_typemap_entry_t *sf = jl_typemap_insert(&jl_cfunction_list, (jl_value_t*)jl_cfunction_list.unknown, (jl_tupletype_t*)cfunc_sig,\n            jl_emptysvec, NULL, jl_emptysvec, NULL, /*offs*/0, &cfunction_cache, NULL);\n\n    // Backup the info for the nested compile\n    JL_LOCK(&codegen_lock);\n    BasicBlock *old = nested_compile ? builder.GetInsertBlock() : NULL;\n    DebugLoc olddl = builder.getCurrentDebugLocation();\n    bool last_n_c = nested_compile;\n    nested_compile = true;\n    Function *f = gen_cfun_wrapper(ff, crt, (jl_tupletype_t*)argt, sf, declrt, (jl_tupletype_t*)sigt);\n    // Restore the previous compile context\n    if (old != NULL) {\n        builder.SetInsertPoint(old);\n        builder.SetCurrentDebugLocation(olddl);\n    }\n    nested_compile = last_n_c;\n    JL_UNLOCK(&codegen_lock); // Might GC\n    JL_GC_POP();\n    return f;\n}\n\n// generate a julia-callable function that calls f (AKA lam)\nstatic Function *gen_jlcall_wrapper(jl_lambda_info_t *lam, Function *f, bool sret, Module *M)\n{\n    std::stringstream funcName;\n    const std::string &fname = f->getName().str();\n    funcName << \"jlcall_\";\n    if (fname.compare(0, 6, \"julia_\") == 0)\n        funcName << fname.substr(6);\n    else\n        funcName << fname;\n\n    Function *w = Function::Create(jl_func_sig, GlobalVariable::ExternalLinkage,\n                                   funcName.str(), M);\n#ifdef LLVM37\n    w->addFnAttr(\"no-frame-pointer-elim\", \"true\");\n#endif\n    Function::arg_iterator AI = w->arg_begin();\n    Value *fArg = &*AI++;\n    Value *argArray = &*AI++;\n    /* const Argument &argCount = *AI++; */\n    BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", w);\n\n    builder.SetInsertPoint(b0);\n    DebugLoc noDbg;\n    builder.SetCurrentDebugLocation(noDbg);\n\n    jl_codectx_t ctx = {};\n    ctx.f = w;\n    ctx.linfo = lam;\n    ctx.sret = false;\n    ctx.spvals_ptr = NULL;\n    allocate_gc_frame(b0, &ctx);\n\n    size_t nargs = lam->nargs;\n    size_t nfargs = f->getFunctionType()->getNumParams();\n    Value **args = (Value**) alloca(nfargs*sizeof(Value*));\n    unsigned idx = 0;\n    Value *result;\n    if (sret) {\n        result = builder.CreateAlloca(f->getFunctionType()->getParamType(0)->getContainedType(0));\n        args[idx] = result;\n        idx++;\n    }\n    for(size_t i=0; i < nargs; i++) {\n        jl_value_t *ty = jl_nth_slot_type(lam->specTypes, i);\n        bool isboxed;\n        Type *lty = julia_type_to_llvm(ty, &isboxed);\n        if (lty != NULL && type_is_ghost(lty))\n            continue;\n        Value *theArg;\n        if (i == 0) {\n            theArg = fArg;\n        }\n        else {\n            Value *argPtr = builder.CreateGEP(argArray, ConstantInt::get(T_size, i-1));\n            theArg = builder.CreateLoad(argPtr);\n        }\n        if (lty != NULL && !isboxed) {\n            theArg = builder.CreatePointerCast(theArg, PointerType::get(lty,0));\n            if (!lty->isAggregateType()) // keep \"aggregate\" type values in place as pointers\n                theArg = build_load(theArg, ty);\n        }\n        assert(dyn_cast<UndefValue>(theArg) == NULL);\n        args[idx] = theArg;\n        idx++;\n    }\n    CallInst *call = builder.CreateCall(prepare_call(f), ArrayRef<Value*>(&args[0], nfargs));\n    call->setAttributes(f->getAttributes());\n\n    jl_value_t *jlretty = lam->rettype;\n    bool retboxed;\n    (void)julia_type_to_llvm(jlretty, &retboxed);\n    if (sret) { assert(!retboxed); }\n    jl_cgval_t retval = sret ? mark_julia_slot(result, jlretty, tbaa_stack) : mark_julia_type(call, retboxed, jlretty, &ctx, /*needsroot*/false);\n    builder.CreateRet(boxed(retval, &ctx, false)); // no gcroot needed since this on the return path\n\n    return w;\n}\n\n// Compile to LLVM IR, using a specialized signature if applicable.\nstatic std::unique_ptr<Module> emit_function(jl_lambda_info_t *lam, jl_llvm_functions_t *declarations)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    assert(declarations && \"Capturing declarations is always required\");\n\n    // step 1. unpack AST and allocate codegen context for this function\n    jl_array_t *code = (jl_array_t*)lam->code;\n    JL_GC_PUSH1(&code);\n    if (!jl_typeis(code,jl_array_any_type))\n        code = jl_uncompress_ast(lam, code);\n    //jl_static_show(JL_STDOUT, (jl_value_t*)ast);\n    //jl_printf(JL_STDOUT, \"\\n\");\n    std::map<int, jl_arrayvar_t> arrayvars;\n    std::map<int, BasicBlock*> labels;\n    std::map<int, Value*> handlers;\n    jl_codectx_t ctx = {};\n    ctx.arrayvars = &arrayvars;\n    ctx.labels = &labels;\n    ctx.handlers = &handlers;\n    ctx.module = lam->def ? lam->def->module : ptls->current_module;\n    ctx.linfo = lam;\n    ctx.name = jl_symbol_name(lam->def ? lam->def->name : anonymous_sym);\n    ctx.funcName = ctx.name;\n    ctx.vaSlot = -1;\n    ctx.vaStack = false;\n    ctx.inbounds.push_back(false);\n    ctx.boundsCheck.push_back(false);\n    ctx.spvals_ptr = NULL;\n\n    // step 2. process var-info lists to see what vars need boxing\n    int n_ssavalues = jl_is_long(lam->ssavaluetypes) ? jl_unbox_long(lam->ssavaluetypes) : jl_array_len(lam->ssavaluetypes);\n    size_t largslen = lam->nargs;\n    size_t vinfoslen = jl_array_dim0(lam->slotnames);\n    ctx.slots.resize(vinfoslen);\n    size_t nreq = largslen;\n    int va = 0;\n\n    assert(lam->specTypes); // this could happen if the user tries to compile a generic-function\n                            // without specializing (or unspecializing) it first\n                            // compiling this would cause all specializations to inherit\n                            // this code and could create an broken compile / function cache\n\n    if (nreq > 0 && lam->isva) {\n        nreq--;\n        va = 1;\n        jl_sym_t *vn = (jl_sym_t*)jl_array_ptr_ref(lam->slotnames,largslen-1);\n        if (vn != unused_sym)\n            ctx.vaSlot = largslen-1;\n    }\n    ctx.nReqArgs = nreq;\n\n    // create SAvalue locations for SSAValue objects\n    ctx.ssavalue_assigned.assign(n_ssavalues, false);\n    ctx.SAvalues.assign(n_ssavalues, jl_cgval_t());\n\n    // step 3. some variable analysis\n    size_t i;\n    for(i=0; i < nreq; i++) {\n        jl_sym_t *argname = (jl_sym_t*)jl_array_ptr_ref(lam->slotnames,i);\n        if (argname == unused_sym) continue;\n        jl_varinfo_t &varinfo = ctx.slots[i];\n        varinfo.isArgument = true;\n        jl_value_t *ty = jl_nth_slot_type(lam->specTypes, i);\n        varinfo.value = mark_julia_type((Value*)NULL, false, ty, &ctx);\n    }\n    if (va && ctx.vaSlot != -1) {\n        jl_varinfo_t &varinfo = ctx.slots[ctx.vaSlot];\n        varinfo.isArgument = true;\n        varinfo.value = mark_julia_type((Value*)NULL, false, jl_tuple_type, &ctx);\n    }\n\n    for(i=0; i < vinfoslen; i++) {\n        jl_varinfo_t &varinfo = ctx.slots[i];\n        uint8_t flags = jl_array_uint8_ref(lam->slotflags, i);\n        varinfo.escapes = false;\n        varinfo.isSA = (jl_vinfo_sa(flags)!=0);\n        varinfo.usedUndef = (jl_vinfo_usedundef(flags)!=0) || (!varinfo.isArgument && !lam->inferred);\n        if (!varinfo.isArgument) {\n            jl_value_t *typ = jl_is_array(lam->slottypes) ? jl_array_ptr_ref(lam->slottypes,i) : (jl_value_t*)jl_any_type;\n            if (!jl_is_type(typ))\n                typ = (jl_value_t*)jl_any_type;\n            varinfo.value = mark_julia_type((Value*)NULL, false, typ, &ctx);\n        }\n    }\n\n    jl_array_t *stmts = code;\n    size_t stmtslen = jl_array_dim0(stmts);\n\n    // finish recording escape info\n    for(i=0; i < stmtslen; i++)\n        simple_escape_analysis(jl_array_ptr_ref(stmts,i), true, &ctx);\n\n    // determine which vars need to be volatile\n    mark_volatile_vars(stmts, ctx.slots);\n\n    // step 4. determine function signature\n    jl_value_t *jlrettype = lam->rettype;\n    Function *f = NULL;\n\n    bool specsig = false;\n    bool needsparams = jl_svec_len(lam->sparam_syms) != jl_svec_len(lam->sparam_vals);\n    for (i = 0; !needsparams && i < jl_svec_len(lam->sparam_vals); i++) {\n        jl_value_t *e = jl_svecref(lam->sparam_vals, i);\n        if (jl_is_typevar(e))\n            needsparams = true;\n    }\n    if (!va && !needsparams && lam->specTypes != jl_anytuple_type && lam->inferred) {\n        // not vararg, consider specialized signature\n        for(size_t i=0; i < jl_nparams(lam->specTypes); i++) {\n            if (isbits_spec(jl_tparam(lam->specTypes, i))) { // assumes !va\n                specsig = true;\n                break;\n            }\n        }\n        if (jl_nparams(lam->specTypes) == 0)\n            specsig = true;\n        if (isbits_spec(jlrettype))\n            specsig = true;\n    }\n    if (!specsig)\n        ctx.nReqArgs--;  // function not part of argArray in jlcall\n\n    std::stringstream funcName;\n    // try to avoid conflicts in the global symbol table\n    funcName << \"julia_\" << ctx.name\n#if (defined(_OS_LINUX_) && !defined(LLVM34))\n        + (ctx.name[0] == '@') ? 1 : 0\n#endif\n    ;\n\n    Function *fwrap = NULL;\n    funcName << \"_\" << globalUnique++;\n\n    ctx.sret = false;\n    Module *M = new Module(ctx.name, jl_LLVMContext);\n    jl_setup_module(M);\n    if (specsig) { // assumes !va and !needsparams\n        std::vector<Type*> fsig(0);\n        Type *rt;\n        bool retboxed;\n        if (jlrettype == (jl_value_t*)jl_void_type) {\n            rt = T_void;\n            retboxed = false;\n        }\n        else {\n            rt = julia_type_to_llvm(jlrettype, &retboxed);\n        }\n        if (!retboxed && rt != T_void && deserves_sret(jlrettype, rt)) {\n            ctx.sret = true;\n            fsig.push_back(rt->getPointerTo());\n            rt = T_void;\n        }\n        for(size_t i=0; i < jl_nparams(lam->specTypes); i++) {\n            Type *ty = julia_type_to_llvm(jl_tparam(lam->specTypes,i));\n            if (type_is_ghost(ty))\n                continue;\n            if (ty->isAggregateType()) // aggregate types are passed by pointer\n                ty = PointerType::get(ty,0);\n            fsig.push_back(ty);\n        }\n        f = Function::Create(FunctionType::get(rt, fsig, false),\n                             GlobalVariable::ExternalLinkage,\n                             funcName.str(), M);\n        if (ctx.sret) {\n            f->addAttribute(1, Attribute::StructRet);\n            f->addAttribute(1, Attribute::NoAlias);\n        }\n#ifdef LLVM37\n        f->addFnAttr(\"no-frame-pointer-elim\", \"true\");\n#endif\n        fwrap = gen_jlcall_wrapper(lam, f, ctx.sret, M);\n        declarations->functionObject = function_proto(fwrap);\n        declarations->specFunctionObject = function_proto(f);\n    }\n    else {\n        f = Function::Create(needsparams ? jl_func_sig_sparams : jl_func_sig,\n                             GlobalVariable::ExternalLinkage,\n                             funcName.str(), M);\n#ifdef LLVM37\n        f->addFnAttr(\"no-frame-pointer-elim\", \"true\");\n#endif\n        declarations->functionObject = function_proto(f);\n        declarations->specFunctionObject = NULL;\n    }\n    if (jlrettype == (jl_value_t*)jl_bottom_type)\n        f->setDoesNotReturn();\n#if defined(_OS_WINDOWS_) && !defined(_CPU_X86_64_)\n    // tell Win32 to realign the stack to the next 16-byte boundary\n    // upon entry to any function. This achieves compatibility\n    // with both MinGW-GCC (which assumes an 16-byte-aligned stack) and\n    // i686 Windows (which uses a 4-byte-aligned stack)\n    AttrBuilder *attr = new AttrBuilder();\n    attr->addStackAlignmentAttr(16);\n    f->addAttributes(AttributeSet::FunctionIndex,\n        AttributeSet::get(f->getContext(),\n            AttributeSet::FunctionIndex,*attr));\n#endif\n\n#if defined(_OS_WINDOWS_) && defined(_CPU_X86_64_) && defined(LLVM35)\n    f->setHasUWTable(); // force NeedsWinEH\n#endif\n\n#ifdef USE_POLLY\n    if (!jl_has_meta(code, polly_sym)) {\n        f->addFnAttr(polly::PollySkipFnAttr);\n    }\n#endif\n\n#ifdef JL_DEBUG_BUILD\n    f->addFnAttr(Attribute::StackProtectReq);\n#endif\n    ctx.f = f;\n\n    // step 5. set up debug info context and create first basic block\n    bool in_user_code = !jl_is_submodule(ctx.module, jl_base_module) &&\n                        !jl_is_submodule(ctx.module, jl_core_module);\n    bool do_coverage = jl_options.code_coverage == JL_LOG_ALL ||\n        (jl_options.code_coverage == JL_LOG_USER && in_user_code);\n    bool do_malloc_log = jl_options.malloc_log  == JL_LOG_ALL ||\n        (jl_options.malloc_log    == JL_LOG_USER && in_user_code);\n    StringRef filename = \"<missing>\";\n    StringRef dbgFuncName = ctx.name;\n    int toplineno = -1;\n    if (lam->def) {\n        toplineno = lam->def->line;\n        if (lam->def->file != empty_sym)\n            filename = jl_symbol_name(lam->def->file);\n    }\n    ctx.file = filename;\n\n    DIBuilder dbuilder(*M);\n    ctx.dbuilder = &dbuilder;\n#ifdef LLVM37\n    DIFile *topfile = NULL;\n    DISubprogram *SP = NULL;\n    std::vector<DILocation *> DI_loc_stack;\n    std::vector<DISubprogram *> DI_sp_stack;\n#else\n    DIFile topfile;\n    DISubprogram SP;\n    std::vector<DebugLoc> DI_loc_stack;\n    std::vector<DISubprogram> DI_sp_stack;\n#endif\n\n    BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", f);\n    builder.SetInsertPoint(b0);\n\n    // jl_printf(JL_STDERR, \"\\n*** compiling %s at %s:%d\\n\\n\",\n    //           jl_symbol_name(lam->name), filename.c_str(), toplineno);\n\n    DebugLoc noDbg, topdebugloc;\n    ctx.debug_enabled = true;\n    if (dbgFuncName.empty()) {\n        // special value: if function name is empty, disable debug info\n        do_coverage = false;\n        do_malloc_log = false;\n        //dbgFuncName = filename; // for testing, uncomment this line\n        ctx.debug_enabled = !dbgFuncName.empty();\n    }\n\n    if (ctx.debug_enabled) {\n        // TODO: Fix when moving to new LLVM version\n        #ifndef LLVM34\n        dbuilder.createCompileUnit(0x01, filename, \".\", \"julia\", true, \"\", 0);\n        #elif defined(LLVM37)\n        DICompileUnit *CU = dbuilder.createCompileUnit(0x01, filename, \".\", \"julia\", true, \"\", 0);\n        #else\n        DICompileUnit CU = dbuilder.createCompileUnit(0x01, filename, \".\", \"julia\", true, \"\", 0);\n        assert(CU.Verify());\n        #endif\n\n#ifdef LLVM37\n        DISubroutineType *subrty;\n#elif defined(LLVM36)\n        DISubroutineType subrty;\n#else\n        DICompositeType subrty;\n#endif\n\n        if (!specsig) {\n            subrty = jl_di_func_sig;\n        }\n        else {\n#ifdef LLVM36\n            std::vector<Metadata*> ditypes(0);\n#else\n            std::vector<Value*> ditypes(0);\n#endif\n            for(size_t i=0; i < jl_nparams(lam->specTypes); i++) { // assumes !va\n                if (i < largslen && ctx.slots[i].value.isghost)\n                    continue;\n                ditypes.push_back(julia_type_to_di(jl_tparam(lam->specTypes,i),ctx.dbuilder,false));\n            }\n#ifdef LLVM38\n            subrty = ctx.dbuilder->createSubroutineType(ctx.dbuilder->getOrCreateTypeArray(ditypes));\n#elif defined(LLVM36)\n            subrty = ctx.dbuilder->createSubroutineType(topfile,ctx.dbuilder->getOrCreateTypeArray(ditypes));\n#else\n            subrty = ctx.dbuilder->createSubroutineType(topfile,ctx.dbuilder->getOrCreateArray(ditypes));\n#endif\n        }\n\n        topfile = dbuilder.createFile(filename, \".\");\n        #ifndef LLVM34\n        SP = dbuilder.createFunction((DIDescriptor)dbuilder.getCU(),\n        #else\n        SP = dbuilder.createFunction(CU,\n        #endif\n                                    dbgFuncName,  // Name\n                                    f->getName(), // LinkageName\n                                    topfile,       // File\n                                    0,            // LineNo\n                                    subrty,       // Ty\n                                    false,        // isLocalToUnit\n                                    true,         // isDefinition\n                                    0,            // ScopeLine\n                                    0,            // Flags\n                                    true,         // isOptimized\n        #ifdef LLVM38\n                                    nullptr);       // Template Parameters\n        #else\n                                    f);             // Function\n        #endif\n        topdebugloc = DebugLoc::get(toplineno, 0, SP, NULL);\n        #ifdef LLVM38\n        f->setSubprogram(SP);\n        #endif\n        #ifndef LLVM37\n        assert(SP.Verify() && SP.describes(f) && SP.getFunction() == f);\n        #endif\n    }\n    builder.SetCurrentDebugLocation(noDbg);\n\n    if (ctx.debug_enabled) {\n        const bool AlwaysPreserve = true;\n        // Go over all arguments and local variables and initialize their debug information\n        for(i=0; i < nreq; i++) {\n            jl_sym_t *argname = (jl_sym_t*)jl_array_ptr_ref(lam->slotnames,i);\n            if (argname == unused_sym) continue;\n            jl_varinfo_t &varinfo = ctx.slots[i];\n#ifdef LLVM38\n            varinfo.dinfo = ctx.dbuilder->createParameterVariable(\n                SP,                                 // Scope (current function will be fill in later)\n                jl_symbol_name(argname),            // Variable name\n                ctx.sret + i + 1,                   // Argument number (1-based)\n                topfile,                            // File\n                toplineno == -1 ? 0 : toplineno,  // Line\n                // Variable type\n                julia_type_to_di(varinfo.value.typ,ctx.dbuilder,false),\n                AlwaysPreserve,                  // May be deleted if optimized out\n                0);                     // Flags (TODO: Do we need any)\n#else\n            varinfo.dinfo = ctx.dbuilder->createLocalVariable(\n                llvm::dwarf::DW_TAG_arg_variable,    // Tag\n                SP,         // Scope (current function will be fill in later)\n                jl_symbol_name(argname),    // Variable name\n                topfile,                    // File\n                toplineno == -1 ? 0 : toplineno,             // Line (for now, use lineno of the function)\n                julia_type_to_di(varinfo.value.typ, ctx.dbuilder,false), // Variable type\n                AlwaysPreserve,                  // May be deleted if optimized out\n                0,                      // Flags (TODO: Do we need any)\n                ctx.sret + i + 1);                   // Argument number (1-based)\n#endif\n        }\n        if (va && ctx.vaSlot != -1) {\n#ifdef LLVM38\n            ctx.slots[ctx.vaSlot].dinfo = ctx.dbuilder->createParameterVariable(\n                SP,                     // Scope (current function will be fill in later)\n                std::string(jl_symbol_name(slot_symbol(ctx.vaSlot, &ctx))) + \"...\",  // Variable name\n                ctx.sret + nreq + 1,               // Argument number (1-based)\n                topfile,                    // File\n                toplineno == -1 ? 0 : toplineno,             // Line (for now, use lineno of the function)\n                julia_type_to_di(ctx.slots[ctx.vaSlot].value.typ, ctx.dbuilder, false),\n                AlwaysPreserve,                  // May be deleted if optimized out\n                0);                     // Flags (TODO: Do we need any)\n#else\n            ctx.slots[ctx.vaSlot].dinfo = ctx.dbuilder->createLocalVariable(\n                llvm::dwarf::DW_TAG_arg_variable,   // Tag\n                SP,                                 // Scope (current function will be fill in later)\n                std::string(jl_symbol_name(slot_symbol(ctx.vaSlot, &ctx))) + \"...\",  // Variable name\n                topfile,                            // File\n                toplineno == -1 ? 0 : toplineno,  // Line (for now, use lineno of the function)\n                julia_type_to_di(ctx.slots[ctx.vaSlot].value.typ, ctx.dbuilder, false),      // Variable type\n                AlwaysPreserve,                  // May be deleted if optimized out\n                0,                      // Flags (TODO: Do we need any)\n                ctx.sret + nreq + 1);              // Argument number (1-based)\n#endif\n        }\n        for(i=0; i < vinfoslen; i++) {\n            jl_sym_t *s = (jl_sym_t*)jl_array_ptr_ref(lam->slotnames,i);\n            jl_varinfo_t &varinfo = ctx.slots[i];\n            if (varinfo.isArgument || s == compiler_temp_sym || s == unused_sym)\n                continue;\n#ifdef LLVM38\n            varinfo.dinfo = ctx.dbuilder->createAutoVariable(\n#else\n            varinfo.dinfo = ctx.dbuilder->createLocalVariable(\n                llvm::dwarf::DW_TAG_auto_variable,    // Tag\n#endif\n                SP,                     // Scope (current function will be fill in later)\n                jl_symbol_name(s),       // Variable name\n                topfile,                 // File\n                toplineno == -1 ? 0 : toplineno, // Line (for now, use lineno of the function)\n                julia_type_to_di(varinfo.value.typ, ctx.dbuilder, false), // Variable type\n                AlwaysPreserve,                  // May be deleted if optimized out\n                0                       // Flags (TODO: Do we need any)\n#ifndef LLVM38\n                ,0                      // Argument number (1-based)\n#endif\n                );\n        }\n    }\n\n#ifdef LLVM37\n    std::map<jl_sym_t *, DIFile *> filescopes;\n#else\n    std::map<jl_sym_t *, MDNode *> filescopes;\n#endif\n\n    Value *fArg=NULL, *argArray=NULL, *pargArray=NULL, *argCount=NULL;\n    if (!specsig) {\n        Function::arg_iterator AI = f->arg_begin();\n        if (needsparams) {\n            ctx.spvals_ptr = &*AI++;\n        }\n        fArg = &*AI++;\n        argArray = &*AI++;\n        pargArray = builder.CreateAlloca(argArray->getType());\n        builder.CreateStore(argArray, pargArray, true/*volatile store to prevent removal of this alloca*/);\n        argCount = &*AI++;\n        ctx.argArray = argArray;\n        ctx.argCount = argCount;\n    }\n\n    /*\n    // step 6. (optional) check for stack overflow (the slower way)\n    Value *cur_sp =\n        builder.CreateCall(Intrinsic::getDeclaration(M,\n                                                     Intrinsic::frameaddress),\n                           ConstantInt::get(T_int32, 0));\n    Value *sp_ok =\n        builder.CreateICmpUGT(cur_sp,\n                              ConstantInt::get(T_size,\n                                               (uptrint_t)jl_stack_lo));\n    error_unless(sp_ok, \"stack overflow\", &ctx);\n    */\n\n    // step 7. set up GC frame\n    allocate_gc_frame(b0, &ctx);\n\n    // step 8. allocate space for exception handler contexts\n    for(i=0; i < stmtslen; i++) {\n        jl_value_t *stmt = jl_array_ptr_ref(stmts,i);\n        if (jl_is_expr(stmt) && ((jl_expr_t*)stmt)->head == enter_sym) {\n            int labl = jl_unbox_long(jl_exprarg(stmt,0));\n            AllocaInst *handlr =\n                builder.CreateAlloca(T_int8,\n                                     ConstantInt::get(T_int32,\n                                                      sizeof(jl_handler_t)));\n            handlr->setAlignment(16);\n            handlers[labl] = handlr;\n        }\n    }\n\n    // step 9. allocate local variables slots\n    // must be in the first basic block for the llvm mem2reg pass to work\n\n    // get pointers for locals stored in the gc frame array (argTemp)\n    for(i=0; i < vinfoslen; i++) {\n        jl_sym_t *s = slot_symbol(i, &ctx);\n        if (s == unused_sym) continue;\n        jl_varinfo_t &varinfo = ctx.slots[i];\n        assert(!varinfo.memloc); // variables shouldn't have memory locs already\n        if (!varinfo.usedUndef) {\n            if (varinfo.value.constant) {\n                // no need to explicitly load/store a constant/ghost value\n                continue;\n            }\n            else if (jl_is_type_type(varinfo.value.typ) && jl_is_leaf_type(jl_tparam0(varinfo.value.typ))) {\n                // replace T::Type{T} with T\n                varinfo.value = mark_julia_const(jl_tparam0(varinfo.value.typ));\n                continue;\n            }\n            else if (store_unboxed_p(i, &ctx)) {\n                if (!varinfo.isArgument) { // otherwise, just leave it in the input register\n                    Value *lv = alloc_local(i, &ctx); (void)lv;\n#ifdef LLVM36\n                    if (ctx.debug_enabled && varinfo.dinfo) {\n                        assert((Metadata*)varinfo.dinfo->getType() != jl_pvalue_dillvmt);\n                        ctx.dbuilder->insertDeclare(lv, varinfo.dinfo, ctx.dbuilder->createExpression(),\n#ifdef LLVM37\n                                                    topdebugloc,\n#endif\n                                builder.GetInsertBlock());\n                    }\n#endif\n                }\n                continue;\n            }\n        }\n        if (!varinfo.isArgument || // always need a slot if the variable is assigned\n            specsig || // for arguments, give them stack slots if they aren't in `argArray` (otherwise, will use that pointer)\n            (va && (int)i == ctx.vaSlot && varinfo.escapes) || // or it's the va arg tuple\n            (s != unused_sym && i == 0)) { // or it is the first argument (which isn't in `argArray`)\n            AllocaInst *av = new AllocaInst(T_pjlvalue, jl_symbol_name(s), /*InsertBefore*/ctx.ptlsStates);\n            varinfo.memloc = av;\n#ifdef LLVM36\n            if (ctx.debug_enabled && varinfo.dinfo) {\n                DIExpression *expr;\n                if ((Metadata*)varinfo.dinfo->getType() == jl_pvalue_dillvmt) {\n                    expr = ctx.dbuilder->createExpression();\n                }\n                else {\n                    SmallVector<uint64_t, 8> addr;\n                    addr.push_back(llvm::dwarf::DW_OP_deref);\n                    expr = ctx.dbuilder->createExpression(addr);\n                }\n                ctx.dbuilder->insertDeclare(av, varinfo.dinfo, expr,\n#ifdef LLVM37\n                                            topdebugloc,\n#endif\n                                builder.GetInsertBlock());\n            }\n#endif\n        }\n        maybe_alloc_arrayvar(i, &ctx);\n    }\n\n    // step 10. move args into local variables\n    Function::arg_iterator AI = f->arg_begin();\n    if (ctx.sret)\n        AI++; // skip sret slot\n    for(i=0; i < nreq; i++) {\n        jl_sym_t *s = (jl_sym_t*)jl_array_ptr_ref(lam->slotnames,i);\n        jl_value_t *argType = jl_nth_slot_type(lam->specTypes, i);\n        bool isboxed;\n        Type *llvmArgType = julia_type_to_llvm(argType, &isboxed);\n        if (s == unused_sym) {\n            if (specsig && !type_is_ghost(llvmArgType)) ++AI;\n            continue;\n        }\n        jl_varinfo_t &vi = ctx.slots[i];\n        jl_cgval_t theArg;\n        if (s == unused_sym || vi.value.constant) {\n            assert(vi.memloc == NULL);\n            if (specsig && !type_is_ghost(llvmArgType)) ++AI;\n        }\n        else {\n            if (specsig) {\n                if (type_is_ghost(llvmArgType)) { // this argument is not actually passed\n                    theArg = ghostValue(argType);\n                }\n                else if (llvmArgType->isAggregateType()) {\n                    theArg = mark_julia_slot(&*AI++, argType, tbaa_const); // this argument is by-pointer\n                    theArg.isimmutable = true;\n                }\n                else {\n                    theArg = mark_julia_type(&*AI++, isboxed, argType, &ctx, /*needsgcroot*/false);\n                }\n            }\n            else {\n                if (i == 0) {\n                    // first (function) arg is separate in jlcall\n                    theArg = mark_julia_type(fArg, true, vi.value.typ, &ctx, /*needsgcroot*/false);\n                }\n                else {\n                    Value *argPtr = builder.CreateGEP(argArray, ConstantInt::get(T_size, i-1));\n                    theArg = mark_julia_type(builder.CreateLoad(argPtr), true, vi.value.typ, &ctx, /*needsgcroot*/false);\n#ifdef LLVM36\n                    if (ctx.debug_enabled && !vi.memloc && !vi.value.V) {\n                        SmallVector<uint64_t, 8> addr;\n                        addr.push_back(llvm::dwarf::DW_OP_deref);\n                        addr.push_back(llvm::dwarf::DW_OP_plus);\n                        addr.push_back((i - 1) * sizeof(void*));\n                        if ((Metadata*)vi.dinfo->getType() != jl_pvalue_dillvmt)\n                            addr.push_back(llvm::dwarf::DW_OP_deref);\n                        ctx.dbuilder->insertDeclare(pargArray, vi.dinfo, ctx.dbuilder->createExpression(addr),\n#ifdef LLVM37\n                                        topdebugloc,\n#endif\n                                        builder.GetInsertBlock());\n                    }\n#endif\n                }\n            }\n\n            if (vi.memloc == NULL) {\n                if (vi.value.V) {\n                    // copy theArg into its local variable slot (unboxed)\n                    assert(vi.value.ispointer());\n                    tbaa_decorate(vi.value.tbaa,\n                                  builder.CreateStore(emit_unbox(vi.value.V->getType()->getContainedType(0),\n                                                                 theArg, vi.value.typ),\n                                                      vi.value.V));\n                }\n                else {\n                    // keep track of original (possibly boxed) value to avoid re-boxing or moving\n                    vi.value = theArg;\n#ifdef LLVM36\n                    if (specsig && theArg.V && ctx.debug_enabled) {\n                        SmallVector<uint64_t, 8> addr;\n                        if ((Metadata*)vi.dinfo->getType() != jl_pvalue_dillvmt && theArg.ispointer())\n                            addr.push_back(llvm::dwarf::DW_OP_deref);\n                        AllocaInst *parg = dyn_cast<AllocaInst>(theArg.V);\n                        if (!parg) {\n                            parg = builder.CreateAlloca(theArg.V->getType(), NULL, jl_symbol_name(s));\n                            builder.CreateStore(theArg.V, parg);\n                        }\n                        ctx.dbuilder->insertDeclare(parg, vi.dinfo, ctx.dbuilder->createExpression(addr),\n#ifdef LLVM37\n                                                    topdebugloc,\n#endif\n                                                    builder.GetInsertBlock());\n                    }\n#endif\n                }\n            }\n            else {\n                Value *argp = boxed(theArg, &ctx, false); // skip the temporary gcroot since it would be folded to argp anyways\n                builder.CreateStore(argp, vi.memloc);\n                if (!theArg.isboxed)\n                    emit_local_root(&ctx, &vi); // create a root for vi\n            }\n            // get arrayvar data if applicable\n            if (arrayvars.find(i) != arrayvars.end()) {\n                jl_arrayvar_t av = arrayvars[i];\n                assign_arrayvar(av, theArg, &ctx);\n            }\n        }\n    }\n\n    // step 11. allocate rest argument if necessary\n    if (va && ctx.vaSlot != -1) {\n        jl_varinfo_t &vi = ctx.slots[ctx.vaSlot];\n        if (!vi.escapes) {\n            ctx.vaStack = true;\n        }\n        else if (!vi.value.constant) {\n            // restarg = jl_f_tuple(NULL, &args[nreq], nargs-nreq)\n            if (vi.memloc != NULL) {\n#ifdef LLVM37\n                Value *restTuple =\n                    builder.CreateCall(prepare_call(jltuple_func), {V_null,\n                                        builder.CreateGEP(argArray,\n                                                          ConstantInt::get(T_size,nreq-1)),\n                                        builder.CreateSub(argCount,\n                                                          ConstantInt::get(T_int32,nreq-1))});\n#else\n                Value *restTuple =\n                    builder.CreateCall3(prepare_call(jltuple_func), V_null,\n                                        builder.CreateGEP(argArray,\n                                                          ConstantInt::get(T_size,nreq-1)),\n                                        builder.CreateSub(argCount,\n                                                          ConstantInt::get(T_int32,nreq-1)));\n#endif\n                builder.CreateStore(restTuple, vi.memloc);\n                emit_local_root(&ctx, &vi); // create a root for vi\n            }\n            else {\n                // TODO: Perhaps allow this in the future, but for now since varargs\n                // are always unspecialized we don't\n                assert(false);\n            }\n        }\n        else {\n            assert(vi.memloc == NULL);\n        }\n    }\n\n    // step 12. associate labels with basic blocks to resolve forward jumps\n    BasicBlock *prev=NULL;\n    for(i=0; i < stmtslen; i++) {\n        jl_value_t *ex = jl_array_ptr_ref(stmts,i);\n        if (jl_is_labelnode(ex)) {\n            int lname = jl_labelnode_label(ex);\n            if (prev != NULL) {\n                // fuse consecutive labels\n                labels[lname] = prev;\n            }\n            else {\n                prev = BasicBlock::Create(jl_LLVMContext, \"L\", f);\n                labels[lname] = prev;\n            }\n        }\n        else {\n            prev = NULL;\n        }\n    }\n\n    // step 13. compile body statements\n    if (ctx.debug_enabled)\n        // set initial line number\n        builder.SetCurrentDebugLocation(topdebugloc);\n    if (do_coverage)\n        coverageVisitLine(ctx.file, toplineno);\n    bool prevlabel = false;\n    int lno = -1;\n    int prevlno = -1;\n    for (i = 0; i < stmtslen; i++) {\n        jl_value_t *stmt = jl_array_ptr_ref(stmts, i);\n        if (jl_is_linenode(stmt) ||\n            (jl_is_expr(stmt) && ((jl_expr_t*)stmt)->head == line_sym)) {\n\n            if (jl_is_linenode(stmt)) {\n                lno = jl_linenode_line(stmt);\n            }\n            else if (jl_is_expr(stmt)) {\n                lno = jl_unbox_long(jl_exprarg(stmt,0));\n            }\n            MDNode *inlinedAt = NULL;\n            if (DI_loc_stack.size() > 0) {\n#ifdef LLVM37\n                inlinedAt = DI_loc_stack.back();\n#else\n                inlinedAt = DI_loc_stack.back().getAsMDNode(jl_LLVMContext);\n#endif\n            }\n            if (ctx.debug_enabled)\n                builder.SetCurrentDebugLocation(DebugLoc::get(lno, 0, SP, inlinedAt));\n        }\n        else if (ctx.debug_enabled && jl_is_expr(stmt) && ((jl_expr_t*)stmt)->head == meta_sym && jl_array_len(((jl_expr_t*)stmt)->args) >= 1) {\n            jl_expr_t *stmt_e = (jl_expr_t*)stmt;\n            jl_value_t *meta_arg = jl_exprarg(stmt_e, 0);\n            if (meta_arg == (jl_value_t*)jl_symbol(\"push_loc\")) {\n                std::string new_filename = \"<missing>\";\n                assert(jl_array_len(stmt_e->args) > 1);\n                jl_sym_t *filesym = (jl_sym_t*)jl_exprarg(stmt_e, 1);\n                if (filesym != empty_sym)\n                    new_filename = jl_symbol_name(filesym);\n#ifdef LLVM37\n                DIFile *new_file = dbuilder.createFile(new_filename, \".\");\n#else\n                DIFile new_file = dbuilder.createFile(new_filename, \".\");\n#endif\n                DI_sp_stack.push_back(SP);\n                DI_loc_stack.push_back(builder.getCurrentDebugLocation());\n                std::string inl_name;\n                int inlined_func_lineno = 0;\n                if (jl_array_len(stmt_e->args) > 2) {\n                    size_t ii;\n                    for(ii=2; ii < jl_array_len(stmt_e->args); ii++) {\n                        jl_value_t *arg = jl_exprarg(stmt_e, ii);\n                        if (jl_is_symbol(arg))\n                            inl_name = jl_symbol_name((jl_sym_t*)arg);\n                        else if (jl_is_int32(arg))\n                            inlined_func_lineno = jl_unbox_int32(arg);\n                        else if (jl_is_int64(arg))\n                            inlined_func_lineno = jl_unbox_int64(arg);\n                    }\n                }\n                else {\n                    inl_name = \"macro expansion\";\n                }\n                SP = dbuilder.createFunction(new_file,\n                                             inl_name + \";\",\n                                             inl_name,\n                                             new_file,\n                                             0,\n                                             jl_di_func_sig,\n                                             false,\n                                             true,\n                                             0,\n                                             0,\n                                             true,\n                                             nullptr);\n                MDNode *inlinedAt = NULL;\n#ifdef LLVM37\n                inlinedAt = builder.getCurrentDebugLocation();\n#else\n                inlinedAt = builder.getCurrentDebugLocation().getAsMDNode(jl_LLVMContext);\n#endif\n                builder.SetCurrentDebugLocation(DebugLoc::get(inlined_func_lineno, 0, SP, inlinedAt));\n            }\n            else if (meta_arg == (jl_value_t*)jl_symbol(\"pop_loc\")) {\n                SP = DI_sp_stack.back();\n                DI_sp_stack.pop_back(); // because why not make pop a void function\n                builder.SetCurrentDebugLocation(DI_loc_stack.back());\n                DI_loc_stack.pop_back();\n            }\n        }\n\n        if (do_coverage)\n            coverageVisitLine(filename, lno);\n        if (jl_is_labelnode(stmt)) {\n            if (prevlabel) continue;\n            prevlabel = true;\n        }\n        else {\n            prevlabel = false;\n        }\n        if (do_malloc_log) {\n            // Check memory allocation after finishing a line or hitting the next branch\n            if (lno != prevlno ||\n                (jl_is_expr(stmt) && ((jl_expr_t*)stmt)->head == goto_ifnot_sym) ||\n                jl_is_gotonode(stmt)) {\n                if (prevlno != -1)\n                    mallocVisitLine(filename, prevlno);\n                prevlno = lno;\n            }\n        }\n        if (jl_is_expr(stmt) && ((jl_expr_t*)stmt)->head == return_sym) {\n            jl_expr_t *ex = (jl_expr_t*)stmt;\n            Value *retval;\n            bool retboxed;\n            Type *retty;\n            if (specsig) {\n                retty = julia_type_to_llvm(jlrettype, &retboxed);\n            }\n            else {\n                retty = T_pjlvalue;\n                retboxed = true;\n            }\n            jl_cgval_t retvalinfo = emit_expr(jl_exprarg(ex,0), &ctx);\n            if (retboxed) {\n                retval = boxed(retvalinfo, &ctx, false); // skip the gcroot on the return path\n                assert(!ctx.sret);\n            }\n            else if (!type_is_ghost(retty)) {\n                retval = emit_unbox(retty, retvalinfo, jlrettype,\n                                    ctx.sret ? &*ctx.f->arg_begin() : NULL);\n            }\n            else // undef return type\n                retval = NULL;\n            if (do_malloc_log && lno != -1)\n                mallocVisitLine(filename, lno);\n            if (type_is_ghost(retty) || ctx.sret)\n                builder.CreateRetVoid();\n            else\n                builder.CreateRet(retval);\n            if (i != stmtslen-1) {\n                BasicBlock *bb =\n                    BasicBlock::Create(jl_LLVMContext, \"ret\", ctx.f);\n                builder.SetInsertPoint(bb);\n            }\n        }\n        else if (jl_is_expr(stmt) && ((jl_expr_t*)stmt)->head == boundscheck_sym) {\n            // always emit expressions that update the boundscheck stack\n            emit_stmtpos(stmt, &ctx);\n        }\n        else if (is_inbounds(&ctx) && is_bounds_check_block(&ctx) &&\n                 jl_options.check_bounds != JL_OPTIONS_CHECK_BOUNDS_ON) {\n            // elide bounds check blocks in inbounds context\n        }\n        else if (is_bounds_check_block(&ctx) &&\n                 jl_options.check_bounds == JL_OPTIONS_CHECK_BOUNDS_OFF) {\n            // elide bounds check blocks when turned off by options\n        }\n        else {\n            emit_stmtpos(stmt, &ctx);\n        }\n    }\n\n    builder.SetCurrentDebugLocation(noDbg);\n\n    // sometimes we have dangling labels after the end\n    if (builder.GetInsertBlock()->getTerminator() == NULL) {\n        builder.CreateUnreachable();\n    }\n\n    // patch up dangling BasicBlocks from skipped labels\n    for (std::map<int,BasicBlock*>::iterator it = labels.begin(); it != labels.end(); ++it) {\n        if (it->second->getTerminator() == NULL) {\n            builder.SetInsertPoint(it->second);\n            builder.CreateUnreachable();\n        }\n    }\n\n    builder.ClearInsertionPoint();\n\n    // step 14, Apply LLVM level inlining\n    for(std::vector<CallInst*>::iterator it = ctx.to_inline.begin(); it != ctx.to_inline.end(); ++it) {\n        Function *inlinef = (*it)->getCalledFunction();\n        assert(inlinef->getParent());\n        InlineFunctionInfo info;\n        if (!InlineFunction(*it,info))\n            jl_error(\"Inlining Pass failed\");\n        if (inlinef->getParent())\n            inlinef->eraseFromParent();\n        else {\n            inlinef->dropAllReferences();\n            delete inlinef;\n        }\n    }\n\n    // step 15. Perform any delayed instantiations\n    if (ctx.debug_enabled) {\n        ctx.dbuilder->finalize();\n    }\n\n    JL_GC_POP();\n\n    return std::unique_ptr<Module>(M);\n}\n\n// --- initialization ---\n\nstatic MDNode *tbaa_make_child( const char *name, MDNode *parent, bool isConstant=false )\n{\n    MDNode *n = mbuilder->createTBAANode(name,parent,isConstant);\n#ifndef LLVM36\n#ifdef LLVM35\n    n->setValueName( ValueName::Create(name));\n#else\n    n->setValueName( ValueName::Create(name, name+strlen(name)));\n#endif\n#endif\n    return n;\n}\n\nstatic GlobalVariable *global_to_llvm(const std::string &cname, void *addr, Module *m)\n{\n    GlobalVariable *gv =\n        new GlobalVariable(*m, T_pjlvalue, true,\n                           GlobalVariable::ExternalLinkage, NULL, cname);\n    add_named_global(gv, addr);\n    return gv;\n}\nllvm::SmallVector<std::pair<jl_value_t**, GlobalVariable*>, 16> gv_for_global;\nstatic GlobalVariable *global_jlvalue_to_llvm(const std::string &cname, jl_value_t **addr, Module *m)\n{\n    GlobalVariable *gv = global_to_llvm(cname, (void*)addr, m);\n    gv_for_global.push_back(std::make_pair(addr, gv));\n    return gv;\n}\nstatic GlobalVariable *julia_const_gv(jl_value_t *val)\n{\n    for (auto& kv : gv_for_global) {\n        if (*kv.first == val)\n            return kv.second;\n    }\n    return nullptr;\n}\n\nstatic Function *jlcall_func_to_llvm(const std::string &cname, jl_fptr_t addr, Module *m)\n{\n    Function *f = Function::Create(jl_func_sig, Function::ExternalLinkage, cname, m);\n    add_named_global(f, addr);\n    return f;\n}\n\nextern \"C\" void jl_fptr_to_llvm(jl_fptr_t fptr, jl_lambda_info_t *lam, int specsig)\n{\n    if (imaging_mode) {\n        if (!specsig) {\n            lam->fptr = fptr; // in imaging mode, it's fine to use the fptr, but we don't want it in the shadow_module\n        }\n    }\n    else {\n        // this assigns a function pointer (from loading the system image), to the function object\n        std::stringstream funcName;\n        funcName << \"jlsys_\" << jl_symbol_name(lam->def->name) << \"_\" << globalUnique++;\n        if (specsig) { // assumes !va\n            SmallVector<Type*, 8> fsig;\n            jl_value_t *jlrettype = lam->rettype;\n            bool retboxed;\n            Type *rt;\n            if (jlrettype == (jl_value_t*)jl_void_type) {\n                rt = T_void;\n                retboxed = false;\n            }\n            else {\n                rt = julia_type_to_llvm(jlrettype, &retboxed);\n            }\n            bool sret = false;\n            if (!retboxed && rt != T_void && deserves_sret(jlrettype, rt)) {\n                sret = true;\n                fsig.push_back(rt->getPointerTo());\n                rt = T_void;\n            }\n            for (size_t i=0; i < jl_nparams(lam->specTypes); i++) {\n                Type *ty = julia_type_to_llvm(jl_tparam(lam->specTypes,i));\n                if (type_is_ghost(ty))\n                    continue;\n                if (ty->isAggregateType()) // aggregate types are passed by pointer\n                    ty = PointerType::get(ty,0);\n                fsig.push_back(ty);\n            }\n            Function *f = Function::Create(FunctionType::get(rt, fsig, false), Function::ExternalLinkage, funcName.str(), shadow_output);\n            if (sret)\n                f->addAttribute(1, Attribute::StructRet);\n\n            if (lam->functionObjectsDecls.specFunctionObject == NULL) {\n                lam->functionObjectsDecls.specFunctionObject = (void*)f;\n            }\n            add_named_global(f, fptr);\n        }\n        else {\n            if (lam->jlcall_api == 1) { // jl_func_sig_sparams -- don't bother emitting the FunctionObject (since can't be used right now)\n                assert(lam->fptr == NULL);\n                lam->fptr = fptr;\n            }\n            else {\n                Function *f = jlcall_func_to_llvm(funcName.str(), fptr, shadow_output);\n                if (lam->functionObjectsDecls.functionObject == NULL) {\n                    lam->functionObjectsDecls.functionObject = (void*)f;\n                    assert(lam->fptr == NULL);\n                    lam->fptr = fptr;\n                }\n            }\n        }\n    }\n}\n\n#if LLVM_VERSION_MAJOR == 3 && LLVM_VERSION_MINOR == 3 && defined(SYSTEM_LLVM)\n#define INSTCOMBINE_BUG\n#define V128_BUG\n#endif\n\nstatic void init_julia_llvm_meta(void)\n{\n    mbuilder = new MDBuilder(jl_LLVMContext);\n    MDNode *tbaa_root = mbuilder->createTBAARoot(\"jtbaa\");\n    tbaa_gcframe = tbaa_make_child(\"jtbaa_gcframe\", tbaa_root);\n    tbaa_stack = tbaa_make_child(\"jtbaa_stack\", tbaa_root);\n    tbaa_data = tbaa_make_child(\"jtbaa_data\", tbaa_root);\n    tbaa_tag = tbaa_make_child(\"jtbaa_tag\", tbaa_data);\n    tbaa_binding = tbaa_make_child(\"jtbaa_binding\", tbaa_data);\n    tbaa_value = tbaa_make_child(\"jtbaa_value\", tbaa_data);\n    tbaa_mutab = tbaa_make_child(\"jtbaa_mutab\", tbaa_value);\n    tbaa_immut = tbaa_make_child(\"jtbaa_immut\", tbaa_value);\n    tbaa_arraybuf = tbaa_make_child(\"jtbaa_arraybuf\", tbaa_data);\n    tbaa_array = tbaa_make_child(\"jtbaa_array\", tbaa_root);\n    tbaa_arrayptr = tbaa_make_child(\"jtbaa_arrayptr\", tbaa_array);\n    tbaa_arraysize = tbaa_make_child(\"jtbaa_arraysize\", tbaa_array);\n    tbaa_arraylen = tbaa_make_child(\"jtbaa_arraylen\", tbaa_array);\n    tbaa_arrayflags = tbaa_make_child(\"jtbaa_arrayflags\", tbaa_array);\n    tbaa_const = tbaa_make_child(\"jtbaa_const\", tbaa_root, true);\n}\n\nstatic void init_julia_llvm_env(Module *m)\n{\n    // every variable or function mapped in this function must be\n    // exported from libjulia, to support static compilation\n    T_int1  = Type::getInt1Ty(jl_LLVMContext);\n    T_int8  = Type::getInt8Ty(jl_LLVMContext);\n    T_pint8 = PointerType::get(T_int8, 0);\n    T_ppint8 = PointerType::get(T_pint8, 0);\n    T_pppint8 = PointerType::get(T_ppint8, 0);\n    T_int16 = Type::getInt16Ty(jl_LLVMContext);\n    T_pint16 = PointerType::get(T_int16, 0);\n    T_int32 = Type::getInt32Ty(jl_LLVMContext);\n    T_char = Type::getInt32Ty(jl_LLVMContext);\n    T_pint32 = PointerType::get(T_int32, 0);\n    T_int64 = Type::getInt64Ty(jl_LLVMContext);\n    T_pint64 = PointerType::get(T_int64, 0);\n    T_uint8 = T_int8;   T_uint16 = T_int16;\n    T_uint32 = T_int32; T_uint64 = T_int64;\n    if (sizeof(size_t) == 8)\n        T_size = T_uint64;\n    else\n        T_size = T_uint32;\n    T_sigatomic = Type::getIntNTy(jl_LLVMContext, sizeof(sig_atomic_t) * 8);\n    T_psize = PointerType::get(T_size, 0);\n    T_float16 = Type::getHalfTy(jl_LLVMContext);\n    T_float32 = Type::getFloatTy(jl_LLVMContext);\n    T_pfloat32 = PointerType::get(T_float32, 0);\n    T_float64 = Type::getDoubleTy(jl_LLVMContext);\n    T_pfloat64 = PointerType::get(T_float64, 0);\n    T_float128 = Type::getFP128Ty(jl_LLVMContext);\n    T_void = Type::getVoidTy(jl_LLVMContext);\n    T_pvoidfunc = FunctionType::get(T_void, /*isVarArg*/false)->getPointerTo();\n\n    // This type is used to create undef Values for use in struct declarations to skip indices\n    NoopType = ArrayType::get(T_int1, 0);\n\n    // add needed base definitions to our LLVM environment\n    StructType *valueSt = StructType::create(jl_LLVMContext, \"jl_value_t\");\n    Type *valueStructElts[1] = { PointerType::getUnqual(valueSt) };\n    ArrayRef<Type*> vselts(valueStructElts);\n    valueSt->setBody(vselts);\n    T_jlvalue = valueSt;\n\n    DIBuilder dbuilder(*m);\n#ifdef LLVM37\n    DIFile *julia_h = dbuilder.createFile(\"julia.h\",\"\");\n    jl_value_dillvmt = dbuilder.createStructType(nullptr,\n#else\n    DIFile julia_h = dbuilder.createFile(\"julia.h\",\"\");\n    jl_value_dillvmt = dbuilder.createStructType(DIDescriptor(),\n#endif\n        \"jl_value_t\",\n        julia_h,\n        71, // At the time of this writing. Not sure if it's worth it to keep this in sync\n        0 * 8, // sizeof(jl_value_t) * 8,\n        __alignof__(void*) * 8, // __alignof__(jl_value_t) * 8,\n        0, // Flags\n#ifdef LLVM37\n        nullptr,    // Derived from\n        nullptr);  // Elements - will be corrected later\n#else\n        DIType(), // Derived from\n        DIArray()); // Elements - will be corrected later\n#endif\n\n    jl_pvalue_dillvmt = dbuilder.createPointerType(jl_value_dillvmt, sizeof(jl_value_t*) * 8,\n                                                   __alignof__(jl_value_t*) * 8);\n\n#ifdef LLVM36\n    SmallVector<llvm::Metadata *, 1> Elts;\n    std::vector<Metadata*> diargs(0);\n    Elts.push_back(jl_pvalue_dillvmt);\n    dbuilder.replaceArrays(jl_value_dillvmt,\n       dbuilder.getOrCreateArray(Elts));\n#else\n    SmallVector<llvm::Value *, 1> Elts;\n    std::vector<Value*> diargs(0);\n    Elts.push_back(jl_pvalue_dillvmt);\n    jl_value_dillvmt.setTypeArray(dbuilder.getOrCreateArray(Elts));\n#endif\n\n    jl_ppvalue_dillvmt = dbuilder.createPointerType(jl_pvalue_dillvmt,sizeof(jl_value_t**)*8,\n                                                    __alignof__(jl_value_t**)*8);\n\n    diargs.push_back(jl_pvalue_dillvmt);    // Return Type (ret value)\n    diargs.push_back(jl_pvalue_dillvmt);    // First Argument (function)\n    diargs.push_back(jl_ppvalue_dillvmt);   // Second Argument (argv)\n    // Third argument (length(argv))\n    diargs.push_back(julia_type_to_di((jl_value_t*)jl_int32_type,&dbuilder,false));\n\n#ifdef LLVM38\n    jl_di_func_sig = dbuilder.createSubroutineType(\n        dbuilder.getOrCreateTypeArray(diargs));\n#elif defined(LLVM36)\n    jl_di_func_sig = dbuilder.createSubroutineType(julia_h,\n        dbuilder.getOrCreateTypeArray(diargs));\n#else\n    jl_di_func_sig = dbuilder.createSubroutineType(julia_h,\n        dbuilder.getOrCreateArray(diargs));\n#endif\n\n    T_pjlvalue = PointerType::get(T_jlvalue, 0);\n    T_ppjlvalue = PointerType::get(T_pjlvalue, 0);\n    two_pvalue_llvmt.push_back(T_pjlvalue);\n    two_pvalue_llvmt.push_back(T_pjlvalue);\n    three_pvalue_llvmt.push_back(T_pjlvalue);\n    three_pvalue_llvmt.push_back(T_pjlvalue);\n    three_pvalue_llvmt.push_back(T_pjlvalue);\n    four_pvalue_llvmt.push_back(T_pjlvalue);\n    four_pvalue_llvmt.push_back(T_pjlvalue);\n    four_pvalue_llvmt.push_back(T_pjlvalue);\n    four_pvalue_llvmt.push_back(T_pjlvalue);\n    V_null = Constant::getNullValue(T_pjlvalue);\n    jl_init_jit(T_pjlvalue);\n\n    std::vector<Type*> ftargs(0);\n    ftargs.push_back(T_pjlvalue);  // linfo->sparam_vals\n    ftargs.push_back(T_pjlvalue);  // function\n    ftargs.push_back(T_ppjlvalue); // args[]\n    ftargs.push_back(T_int32);     // nargs\n    jl_func_sig_sparams = FunctionType::get(T_pjlvalue, ftargs, false);\n    assert(jl_func_sig_sparams != NULL);\n    ftargs.erase(ftargs.begin());  // drop linfo->sparams_vals argument\n    jl_func_sig = FunctionType::get(T_pjlvalue, ftargs, false);\n    assert(jl_func_sig != NULL);\n\n    Type *vaelts[] = {T_pint8\n#ifdef STORE_ARRAY_LEN\n                      , T_size\n#endif\n                      , T_int16\n    };\n    static_assert(sizeof(jl_array_flags_t) == sizeof(int16_t),\n                  \"Size of jl_array_flags_t is not the same as int16_t\");\n    Type *jl_array_llvmt =\n        StructType::create(jl_LLVMContext,\n                           ArrayRef<Type*>(vaelts,sizeof(vaelts)/sizeof(vaelts[0])),\n                           \"jl_array_t\");\n    jl_parray_llvmt = PointerType::get(jl_array_llvmt,0);\n\n    global_to_llvm(\"__stack_chk_guard\", (void*)&__stack_chk_guard, m);\n    Function *jl__stack_chk_fail =\n        Function::Create(FunctionType::get(T_void, false),\n                         Function::ExternalLinkage,\n                         \"__stack_chk_fail\", m);\n    jl__stack_chk_fail->setDoesNotReturn();\n    add_named_global(jl__stack_chk_fail, &__stack_chk_fail);\n\n    global_jlvalue_to_llvm(\"jl_true\", &jl_true, m);\n    global_jlvalue_to_llvm(\"jl_false\", &jl_false, m);\n    global_jlvalue_to_llvm(\"jl_emptysvec\", (jl_value_t**)&jl_emptysvec, m);\n    global_jlvalue_to_llvm(\"jl_emptytuple\", &jl_emptytuple, m);\n    global_jlvalue_to_llvm(\"jl_diverror_exception\", &jl_diverror_exception, m);\n    global_jlvalue_to_llvm(\"jl_undefref_exception\", &jl_undefref_exception, m);\n    global_jlvalue_to_llvm(\"jl_domain_exception\", &jl_domain_exception, m);\n    global_jlvalue_to_llvm(\"jl_overflow_exception\", &jl_overflow_exception, m);\n    global_jlvalue_to_llvm(\"jl_inexact_exception\", &jl_inexact_exception, m);\n\n    jlRTLD_DEFAULT_var =\n        new GlobalVariable(*m, T_pint8,\n                           true, GlobalVariable::ExternalLinkage,\n                           NULL, \"jl_RTLD_DEFAULT_handle\");\n    add_named_global(jlRTLD_DEFAULT_var, &jl_RTLD_DEFAULT_handle);\n#ifdef _OS_WINDOWS_\n    jlexe_var =\n        new GlobalVariable(*m, T_pint8,\n                           true, GlobalVariable::ExternalLinkage,\n                           NULL, \"jl_exe_handle\");\n    add_named_global(jlexe_var, &jl_exe_handle);\n    jldll_var =\n        new GlobalVariable(*m, T_pint8,\n                           true, GlobalVariable::ExternalLinkage,\n                           NULL, \"jl_dl_handle\");\n    add_named_global(jldll_var, &jl_dl_handle);\n#endif\n\n#ifndef JULIA_ENABLE_THREADING\n    // For non-threading, we use the address of the global variable directly\n    jltls_states_var =\n        new GlobalVariable(*m, T_ppjlvalue,\n                           false, GlobalVariable::ExternalLinkage,\n                           NULL, \"jl_tls_states\");\n    add_named_global(jltls_states_var, &jl_tls_states);\n    // placeholder function for keeping track of the end of the gcframe\n    jltls_states_func = Function::Create(FunctionType::get(jltls_states_var->getType(), false),\n                                         Function::ExternalLinkage,\n                                         \"jl_get_ptls_states\", m);\n    add_named_global(jltls_states_func, (void*)NULL, /*dllimport*/false);\n#else\n    // For threading, we emit a call to the getter function.\n    // In non-imaging mode, (i.e. the code will not be saved to disk), we\n    // use the address of the actual getter function directly\n    // (`jl_tls_states_cb` returned by `jl_get_ptls_states_getter()`)\n    // (Alternatively if we know how to generate the tls address directly\n    // we will inline the assembly, see `finalize_gc_frame(Function*)`)\n    // In imaging mode, we emit the function address as a load of a static\n    // variable to be filled (in `dump.c`) at initialization time of the sysimg.\n    // This way we can by pass the extra indirection in `jl_get_ptls_states`\n    // since we don't know which getter function to use ahead of time.\n    jltls_states_func = Function::Create(FunctionType::get(PointerType::get(T_ppjlvalue, 0), false),\n                                         Function::ExternalLinkage,\n                                         \"jl_get_ptls_states\", m);\n    add_named_global(jltls_states_func, jl_get_ptls_states_getter());\n    if (imaging_mode) {\n        PointerType *pfunctype = jltls_states_func->getFunctionType()->getPointerTo();\n        jltls_states_func_ptr =\n            jl_emit_sysimg_slot(m, pfunctype, \"jl_get_ptls_states.ptr\",\n                                (uintptr_t)jl_get_ptls_states_getter(),\n                                jltls_states_func_idx);\n    }\n#endif\n\n    std::vector<Type*> args1(0);\n    args1.push_back(T_pint8);\n    jlerror_func =\n        Function::Create(FunctionType::get(T_void, args1, false),\n                         Function::ExternalLinkage,\n                         \"jl_error\", m);\n    jlerror_func->setDoesNotReturn();\n    add_named_global(jlerror_func, &jl_error);\n\n    std::vector<Type*> args1_(0);\n    args1_.push_back(T_pjlvalue);\n    jlthrow_func =\n        Function::Create(FunctionType::get(T_void, args1_, false),\n                         Function::ExternalLinkage,\n                         \"jl_throw\", m);\n    jlthrow_func->setDoesNotReturn();\n    add_named_global(jlthrow_func, &jl_throw);\n\n    jlundefvarerror_func =\n        Function::Create(FunctionType::get(T_void, args1_, false),\n                         Function::ExternalLinkage,\n                         \"jl_undefined_var_error\", m);\n    jlundefvarerror_func->setDoesNotReturn();\n    add_named_global(jlundefvarerror_func, &jl_undefined_var_error);\n\n    std::vector<Type*> args2_boundserrorv(0);\n    args2_boundserrorv.push_back(T_pjlvalue);\n    args2_boundserrorv.push_back(T_psize);\n    args2_boundserrorv.push_back(T_size);\n    jlboundserrorv_func =\n        Function::Create(FunctionType::get(T_void, args2_boundserrorv, false),\n                         Function::ExternalLinkage,\n                         \"jl_bounds_error_ints\", m);\n    jlboundserrorv_func->setDoesNotReturn();\n    add_named_global(jlboundserrorv_func, &jl_bounds_error_ints);\n\n    std::vector<Type*> args2_boundserror(0);\n    args2_boundserror.push_back(T_pjlvalue);\n    args2_boundserror.push_back(T_size);\n    jlboundserror_func =\n        Function::Create(FunctionType::get(T_void, args2_boundserror, false),\n                         Function::ExternalLinkage,\n                         \"jl_bounds_error_int\", m);\n    jlboundserror_func->setDoesNotReturn();\n    add_named_global(jlboundserror_func, &jl_bounds_error_int);\n\n    std::vector<Type*> args3_vboundserror(0);\n    args3_vboundserror.push_back(T_ppjlvalue);\n    args3_vboundserror.push_back(T_size);\n    args3_vboundserror.push_back(T_size);\n    jlvboundserror_func =\n        Function::Create(FunctionType::get(T_void, args3_vboundserror, false),\n                         Function::ExternalLinkage,\n                         \"jl_bounds_error_tuple_int\", m);\n    jlvboundserror_func->setDoesNotReturn();\n    add_named_global(jlvboundserror_func, &jl_bounds_error_tuple_int);\n\n    std::vector<Type*> args3_uboundserror(0);\n    args3_uboundserror.push_back(T_pint8);\n    args3_uboundserror.push_back(T_pjlvalue);\n    args3_uboundserror.push_back(T_size);\n    jluboundserror_func =\n        Function::Create(FunctionType::get(T_void, args3_uboundserror, false),\n                         Function::ExternalLinkage,\n                         \"jl_bounds_error_unboxed_int\", m);\n    jluboundserror_func->setDoesNotReturn();\n    add_named_global(jluboundserror_func, &jl_bounds_error_unboxed_int);\n\n    jlnew_func =\n        Function::Create(jl_func_sig, Function::ExternalLinkage,\n                         \"jl_new_structv\", m);\n    add_named_global(jlnew_func, &jl_new_structv);\n\n    std::vector<Type*> args2(0);\n    args2.push_back(T_pint8);\n#ifndef _OS_WINDOWS_\n    args2.push_back(T_int32);\n#endif\n    setjmp_func =\n        Function::Create(FunctionType::get(T_int32, args2, false),\n                         Function::ExternalLinkage, jl_setjmp_name, m);\n    setjmp_func->addFnAttr(Attribute::ReturnsTwice);\n    add_named_global(setjmp_func, &jl_setjmp_f);\n\n    std::vector<Type*> args_memcmp(0);\n    args_memcmp.push_back(T_pint8);\n    args_memcmp.push_back(T_pint8);\n    args_memcmp.push_back(T_size);\n    memcmp_func =\n        Function::Create(FunctionType::get(T_int32, args_memcmp, false),\n                         Function::ExternalLinkage, \"memcmp\", m);\n    add_named_global(memcmp_func, &memcmp);\n\n    std::vector<Type*> te_args(0);\n    te_args.push_back(T_pint8);\n    te_args.push_back(T_pint8);\n    te_args.push_back(T_pjlvalue);\n    te_args.push_back(T_pjlvalue);\n    jltypeerror_func =\n        Function::Create(FunctionType::get(T_void, te_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_type_error_rt\", m);\n    jltypeerror_func->setDoesNotReturn();\n    add_named_global(jltypeerror_func, &jl_type_error_rt);\n\n    std::vector<Type *> args_2ptrs(0);\n    args_2ptrs.push_back(T_pjlvalue);\n    args_2ptrs.push_back(T_pjlvalue);\n    jlcheckassign_func =\n        Function::Create(FunctionType::get(T_void, args_2ptrs, false),\n                         Function::ExternalLinkage,\n                         \"jl_checked_assignment\", m);\n    add_named_global(jlcheckassign_func, &jl_checked_assignment);\n\n    std::vector<Type *> args_1ptr(0);\n    args_1ptr.push_back(T_pjlvalue);\n    jldeclareconst_func =\n        Function::Create(FunctionType::get(T_void, args_1ptr, false),\n                         Function::ExternalLinkage,\n                         \"jl_declare_constant\", m);\n    add_named_global(jldeclareconst_func, &jl_declare_constant);\n\n    jlgetbindingorerror_func =\n        Function::Create(FunctionType::get(T_pjlvalue, args_2ptrs, false),\n                         Function::ExternalLinkage,\n                         \"jl_get_binding_or_error\", m);\n    add_named_global(jlgetbindingorerror_func, &jl_get_binding_or_error);\n\n    jlpref_func = Function::Create(FunctionType::get(T_pjlvalue, three_pvalue_llvmt, false),\n                            Function::ExternalLinkage,\n                            \"jl_pointerref\", m);\n\n    jlpset_func = Function::Create(FunctionType::get(T_pjlvalue, four_pvalue_llvmt, false),\n                            Function::ExternalLinkage,\n                            \"jl_pointerset\", m);\n\n\n    builtin_func_map[jl_f_is] = jlcall_func_to_llvm(\"jl_f_is\", &jl_f_is, m);\n    builtin_func_map[jl_f_typeof] = jlcall_func_to_llvm(\"jl_f_typeof\", &jl_f_typeof, m);\n    builtin_func_map[jl_f_sizeof] = jlcall_func_to_llvm(\"jl_f_sizeof\", &jl_f_sizeof, m);\n    builtin_func_map[jl_f_issubtype] = jlcall_func_to_llvm(\"jl_f_issubtype\", &jl_f_issubtype, m);\n    builtin_func_map[jl_f_isa] = jlcall_func_to_llvm(\"jl_f_isa\", &jl_f_isa, m);\n    builtin_func_map[jl_f_typeassert] = jlcall_func_to_llvm(\"jl_f_typeassert\", &jl_f_typeassert, m);\n    builtin_func_map[jl_f__apply] = jlcall_func_to_llvm(\"jl_f__apply\", &jl_f__apply, m);\n    builtin_func_map[jl_f_throw] = jlcall_func_to_llvm(\"jl_f_throw\", &jl_f_throw, m);\n    builtin_func_map[jl_f_tuple] = jlcall_func_to_llvm(\"jl_f_tuple\", &jl_f_tuple, m);\n    builtin_func_map[jl_f_svec] = jlcall_func_to_llvm(\"jl_f_svec\", &jl_f_svec, m);\n    builtin_func_map[jl_f_applicable] = jlcall_func_to_llvm(\"jl_f_applicable\", &jl_f_applicable, m);\n    builtin_func_map[jl_f_invoke] = jlcall_func_to_llvm(\"jl_f_invoke\", &jl_f_invoke, m);\n    builtin_func_map[jl_f_isdefined] = jlcall_func_to_llvm(\"jl_f_isdefined\", &jl_f_isdefined, m);\n    builtin_func_map[jl_f_getfield] = jlcall_func_to_llvm(\"jl_f_getfield\", &jl_f_getfield, m);\n    builtin_func_map[jl_f_setfield] = jlcall_func_to_llvm(\"jl_f_setfield\", &jl_f_setfield, m);\n    builtin_func_map[jl_f_fieldtype] = jlcall_func_to_llvm(\"jl_f_fieldtype\", &jl_f_fieldtype, m);\n    builtin_func_map[jl_f_nfields] = jlcall_func_to_llvm(\"jl_f_nfields\", &jl_f_nfields, m);\n    builtin_func_map[jl_f__expr] = jlcall_func_to_llvm(\"jl_f__expr\", &jl_f__expr, m);\n    builtin_func_map[jl_f_arrayref] = jlcall_func_to_llvm(\"jl_f_arrayref\", &jl_f_arrayref, m);\n    builtin_func_map[jl_f_arrayset] = jlcall_func_to_llvm(\"jl_f_arrayset\", &jl_f_arrayset, m);\n    builtin_func_map[jl_f_arraysize] = jlcall_func_to_llvm(\"jl_f_arraysize\", &jl_f_arraysize, m);\n    builtin_func_map[jl_f_apply_type] = jlcall_func_to_llvm(\"jl_f_apply_type\", &jl_f_apply_type, m);\n    jltuple_func = builtin_func_map[jl_f_tuple];\n    jlgetfield_func = builtin_func_map[jl_f_getfield];\n\n    jlapply2va_func = jlcall_func_to_llvm(\"jl_apply_2va\", &jl_apply_2va, m);\n\n    jltypeassert_func = Function::Create(FunctionType::get(T_void, two_pvalue_llvmt, false),\n                                        Function::ExternalLinkage,\n                                        \"jl_typeassert\", m);\n    add_named_global(jltypeassert_func, &jl_typeassert);\n\n    queuerootfun = Function::Create(FunctionType::get(T_void, args_1ptr, false),\n                                    Function::ExternalLinkage,\n                                    \"jl_gc_queue_root\", m);\n    add_named_global(queuerootfun, &jl_gc_queue_root);\n\n    std::vector<Type *> agargs(0);\n    agargs.push_back(T_ppjlvalue);\n    agargs.push_back(T_uint32);\n    jlapplygeneric_func = Function::Create(FunctionType::get(T_pjlvalue, agargs, false),\n                                           Function::ExternalLinkage,\n                                           \"jl_apply_generic\", m);\n    add_named_global(jlapplygeneric_func, &jl_apply_generic);\n\n    std::vector<Type *> invokeargs(0);\n    invokeargs.push_back(T_pjlvalue);\n    invokeargs.push_back(T_ppjlvalue);\n    invokeargs.push_back(T_uint32);\n    jlinvoke_func = Function::Create(FunctionType::get(T_pjlvalue, invokeargs, false),\n                                     Function::ExternalLinkage,\n                                     \"jl_invoke\", m);\n    add_named_global(jlinvoke_func, &jl_invoke);\n\n    std::vector<Type *> exp_args(0);\n    exp_args.push_back(T_int1);\n    expect_func = Intrinsic::getDeclaration(m, Intrinsic::expect, exp_args);\n\n    std::vector<Type*> args3(0);\n    args3.push_back(T_pjlvalue);\n    jltopeval_func =\n        Function::Create(FunctionType::get(T_pjlvalue, args3, false),\n                         Function::ExternalLinkage,\n                         \"jl_toplevel_eval\", m);\n    add_named_global(jltopeval_func, &jl_toplevel_eval);\n\n    jlcopyast_func =\n        Function::Create(FunctionType::get(T_pjlvalue, args3, false),\n                         Function::ExternalLinkage,\n                         \"jl_copy_ast\", m);\n    add_named_global(jlcopyast_func, &jl_copy_ast);\n\n    std::vector<Type*> args5(0);\n    args5.push_back(T_size);\n    jlnsvec_func =\n        Function::Create(FunctionType::get(T_pjlvalue, args5, true),\n                         Function::ExternalLinkage,\n                         \"jl_svec\", m);\n    add_named_global(jlnsvec_func, &jl_svec);\n\n    std::vector<Type*> mdargs(0);\n    mdargs.push_back(T_pjlvalue);\n    mdargs.push_back(T_pjlvalue);\n    mdargs.push_back(T_pjlvalue);\n    jlmethod_func =\n        Function::Create(FunctionType::get(T_void, mdargs, false),\n                         Function::ExternalLinkage,\n                         \"jl_method_def\", m);\n    add_named_global(jlmethod_func, &jl_method_def);\n\n    std::vector<Type*> funcdefargs(0);\n    funcdefargs.push_back(T_pjlvalue);\n    funcdefargs.push_back(T_ppjlvalue);\n    funcdefargs.push_back(T_pjlvalue);\n    funcdefargs.push_back(T_pjlvalue);\n    jlgenericfunction_func =\n        Function::Create(FunctionType::get(T_pjlvalue, funcdefargs, false),\n                         Function::ExternalLinkage,\n                         \"jl_generic_function_def\", m);\n    add_named_global(jlgenericfunction_func, &jl_generic_function_def);\n\n    std::vector<Type*> ehargs(0);\n    ehargs.push_back(T_pint8);\n    jlenter_func =\n        Function::Create(FunctionType::get(T_void, ehargs, false),\n                         Function::ExternalLinkage,\n                         \"jl_enter_handler\", m);\n    add_named_global(jlenter_func, &jl_enter_handler);\n\n#ifdef _OS_WINDOWS_\n    resetstkoflw_func = Function::Create(FunctionType::get(T_int32, false),\n            Function::ExternalLinkage, \"_resetstkoflw\", m);\n    add_named_global(resetstkoflw_func, &_resetstkoflw);\n#if defined(_CPU_X86_64_)\n    juliapersonality_func = Function::Create(FunctionType::get(T_int32, true),\n            Function::ExternalLinkage, \"__julia_personality\", m);\n    add_named_global(juliapersonality_func, &__julia_personality);\n#endif\n#ifndef FORCE_ELF\n#if defined(_CPU_X86_64_)\n#if defined(_COMPILER_MINGW_)\n    Function *chkstk_func = Function::Create(FunctionType::get(T_void, false),\n            Function::ExternalLinkage, \"___chkstk_ms\", m);\n    add_named_global(chkstk_func, &___chkstk_ms, /*dllimport*/false);\n#else\n    Function *chkstk_func = Function::Create(FunctionType::get(T_void, false),\n            Function::ExternalLinkage, \"__chkstk\", m);\n    add_named_global(chkstk_func, &__chkstk, /*dllimport*/false);\n#endif\n#else\n#if defined(_COMPILER_MINGW_)\n    Function *chkstk_func = Function::Create(FunctionType::get(T_void, false),\n            Function::ExternalLinkage, \"_alloca\", m);\n    add_named_global(chkstk_func, &_alloca, /*dllimport*/false);\n#else\n    Function *chkstk_func = Function::Create(FunctionType::get(T_void, false),\n            Function::ExternalLinkage, \"_chkstk\", m);\n    add_named_global(chkstk_func, &_chkstk, /*dllimport*/false);\n#endif\n#endif\n#endif\n#endif\n\n    std::vector<Type*> lhargs(0);\n    lhargs.push_back(T_int32);\n    jlleave_func =\n        Function::Create(FunctionType::get(T_void, lhargs, false),\n                         Function::ExternalLinkage,\n                         \"jl_pop_handler\", m);\n    add_named_global(jlleave_func, &jl_pop_handler);\n\n    std::vector<Type *> args_2vals(0);\n    args_2vals.push_back(T_pjlvalue);\n    args_2vals.push_back(T_pjlvalue);\n    jlegal_func =\n        Function::Create(FunctionType::get(T_int32, args_2vals, false),\n                         Function::ExternalLinkage,\n                         \"jl_egal\", m);\n    add_named_global(jlegal_func, &jl_egal);\n\n    std::vector<Type *> subt_args(0);\n    subt_args.push_back(T_pjlvalue);\n    subt_args.push_back(T_pjlvalue);\n    subt_args.push_back(T_int32);\n    jlsubtype_func =\n        Function::Create(FunctionType::get(T_int32, subt_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_subtype\", m);\n    add_named_global(jlsubtype_func, &jl_subtype);\n\n    std::vector<Type*> alloc_pool_args(0);\n    alloc_pool_args.push_back(T_pint8);\n    alloc_pool_args.push_back(T_int32);\n    alloc_pool_args.push_back(T_int32);\n    jlalloc_pool_func =\n        Function::Create(FunctionType::get(T_pjlvalue, alloc_pool_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_gc_pool_alloc\", m);\n    add_named_global(jlalloc_pool_func, &jl_gc_pool_alloc);\n\n    std::vector<Type*> alloc_big_args(0);\n    alloc_big_args.push_back(T_pint8);\n    alloc_big_args.push_back(T_size);\n    jlalloc_big_func =\n        Function::Create(FunctionType::get(T_pjlvalue, alloc_big_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_gc_big_alloc\", m);\n    add_named_global(jlalloc_big_func, &jl_gc_big_alloc);\n\n    std::vector<Type *> dlsym_args(0);\n    dlsym_args.push_back(T_pint8);\n    dlsym_args.push_back(T_pint8);\n    dlsym_args.push_back(PointerType::get(T_pint8,0));\n    jldlsym_func =\n        Function::Create(FunctionType::get(T_pvoidfunc, dlsym_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_load_and_lookup\", m);\n    add_named_global(jldlsym_func, &jl_load_and_lookup);\n\n    std::vector<Type *> newbits_args(0);\n    newbits_args.push_back(T_pjlvalue);\n    newbits_args.push_back(T_pint8);\n    jlnewbits_func =\n        Function::Create(FunctionType::get(T_pjlvalue, newbits_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_new_bits\", m);\n    add_named_global(jlnewbits_func, &jl_new_bits);\n\n    std::vector<Type *> getnthfld_args(0);\n    getnthfld_args.push_back(T_pjlvalue);\n    getnthfld_args.push_back(T_size);\n    jlgetnthfieldchecked_func =\n        Function::Create(FunctionType::get(T_pjlvalue, getnthfld_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_get_nth_field_checked\", m);\n    add_named_global(jlgetnthfieldchecked_func, *jl_get_nth_field_checked);\n\n    diff_gc_total_bytes_func =\n        Function::Create(FunctionType::get(T_int64, false),\n                         Function::ExternalLinkage,\n                         \"jl_gc_diff_total_bytes\", m);\n    add_named_global(diff_gc_total_bytes_func, *jl_gc_diff_total_bytes);\n\n#ifndef LLVM36\n    Type *powf_type[2] = { T_float32, T_float32 };\n    jlpowf_func = Function::Create(FunctionType::get(T_float32, powf_type, false),\n                                   Function::ExternalLinkage,\n                                   \"powf\", m);\n    add_named_global(jlpowf_func, &powf, false);\n\n    Type *pow_type[2] = { T_float64, T_float64 };\n    jlpow_func = Function::Create(FunctionType::get(T_float64, pow_type, false),\n                                  Function::ExternalLinkage,\n                                  \"pow\", m);\n    add_named_global(jlpow_func,\n#ifdef _COMPILER_MICROSOFT_\n        static_cast<double (*)(double, double)>(&pow),\n#else\n        &pow,\n#endif\n        false);\n#endif\n    std::vector<Type*> array_owner_args(0);\n    array_owner_args.push_back(T_pjlvalue);\n    jlarray_data_owner_func =\n        Function::Create(FunctionType::get(T_pjlvalue, array_owner_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_array_data_owner\", m);\n    jlarray_data_owner_func->setAttributes(\n        jlarray_data_owner_func->getAttributes()\n        .addAttribute(jlarray_data_owner_func->getContext(),\n                      AttributeSet::FunctionIndex, Attribute::ReadOnly)\n        .addAttribute(jlarray_data_owner_func->getContext(),\n                      AttributeSet::FunctionIndex, Attribute::NoUnwind));\n    add_named_global(jlarray_data_owner_func, jl_array_data_owner);\n\n    gcroot_func =\n        Function::Create(FunctionType::get(T_ppjlvalue, false),\n                     Function::ExternalLinkage,\n                     \"julia.gc_root_decl\", m);\n    add_named_global(gcroot_func, (void*)NULL, /*dllimport*/false);\n\n    gckill_func =\n        Function::Create(FunctionType::get(T_void, ArrayRef<Type*>(T_ppjlvalue), false),\n                     Function::ExternalLinkage,\n                     \"julia.gc_root_kill\", m);\n    add_named_global(gckill_func, (void*)NULL, /*dllimport*/false);\n\n    jlcall_frame_func =\n        Function::Create(FunctionType::get(T_ppjlvalue, ArrayRef<Type*>(T_int32), false),\n                     Function::ExternalLinkage,\n                     \"julia.jlcall_frame_decl\", m);\n    add_named_global(jlcall_frame_func, (void*)NULL, /*dllimport*/false);\n\n    gcroot_flush_func = Function::Create(FunctionType::get(T_void, false),\n                                         Function::ExternalLinkage,\n                                         \"julia.gcroot_flush\", m);\n    add_named_global(gcroot_flush_func, (void*)NULL, /*dllimport*/false);\n\n    // set up optimization passes\n#ifdef LLVM37\n// No DataLayout pass needed anymore.\n#elif defined(LLVM36)\n    jl_data_layout = new llvm::DataLayoutPass();\n#elif defined(LLVM35)\n    jl_data_layout = new llvm::DataLayoutPass(*jl_ExecutionEngine->getDataLayout());\n#else\n    jl_data_layout = new DataLayout(*jl_ExecutionEngine->getDataLayout());\n#endif\n\n#ifdef LLVM37\n    jl_globalPM = new legacy::PassManager();\n#else\n    jl_globalPM = new PassManager();\n#endif\n#ifndef LLVM37\n    jl_globalPM->add(new TargetLibraryInfo(Triple(jl_TargetMachine->getTargetTriple())));\n#else\n    jl_globalPM->add(new TargetLibraryInfoWrapperPass(Triple(jl_TargetMachine->getTargetTriple())));\n#endif\n#ifndef LLVM37\n    jl_globalPM->add(jl_data_layout);\n#endif\n    addOptimizationPasses(jl_globalPM);\n}\n\n// Helper to figure out what features to set for the LLVM target\n// If the user specifies native (or does not specify) we default\n// using the API provided by LLVM\nstatic inline SmallVector<std::string,10> getTargetFeatures()\n{\n    StringMap<bool> HostFeatures;\n    if (!strcmp(jl_options.cpu_target,\"native\")) {\n        // On earlier versions of LLVM this is empty\n        llvm::sys::getHostCPUFeatures(HostFeatures);\n    }\n\n    // Platform specific overides follow\n#if defined(_CPU_X86_64_) || defined(_CPU_X86_)\n#ifndef USE_MCJIT\n    // Temporarily disable Haswell BMI2 features due to LLVM bug.\n    HostFeatures[\"bmi2\"] = false;\n    HostFeatures[\"avx2\"] = false;\n#endif\n#ifdef V128_BUG\n    HostFeatures[\"avx\"] = false;\n#endif\n#endif\n#if defined(_CPU_X86_64_) && defined(LLVM36)\n    // Require cx16 (cmpxchg16b)\n    // We need this for 128-bit atomic operations. We only need this\n    // when threading is enabled; however, to test whether this\n    // excludes important systems, we require this even when threading\n    // is disabled.\n    HostFeatures[\"cx16\"] = true;\n#endif\n\n    // Figure out if we know the cpu_target\n    std::string cpu = strcmp(jl_options.cpu_target,\"native\") ? jl_options.cpu_target : sys::getHostCPUName();\n    if (cpu.empty() || cpu == \"generic\") {\n        jl_printf(JL_STDERR, \"WARNING: unable to determine host cpu name.\\n\");\n#if defined(_CPU_ARM_) && defined(__ARM_PCS_VFP)\n        // Check if this is required when you have read the features directly from the processor\n        // This affects the platform calling convention.\n        // TODO: enable vfp3 for ARMv7+ (but adapt the ABI)\n        HostFeatures[\"vfp2\"] = true;\n#endif\n    }\n\n    SmallVector<std::string,10> attr;\n    for (StringMap<bool>::const_iterator it = HostFeatures.begin(); it != HostFeatures.end(); it++) {\n        std::string att = it->getValue() ? it->getKey().str() :\n                          std::string(\"-\") + it->getKey().str();\n        attr.append(1, att);\n    }\n    return attr;\n}\n\nextern \"C\" void jl_init_codegen(void)\n{\n    const char *const argv_tailmerge[] = {\"\", \"-enable-tail-merge=0\"}; // NOO TOUCHIE; NO TOUCH! See #922\n    cl::ParseCommandLineOptions(sizeof(argv_tailmerge)/sizeof(argv_tailmerge[0]), argv_tailmerge, \"disable-tail-merge\\n\");\n#if defined(_OS_WINDOWS_) && defined(_CPU_X86_64_)\n    const char *const argv_copyprop[] = {\"\", \"-disable-copyprop\"}; // llvm bug 21743\n    cl::ParseCommandLineOptions(sizeof(argv_copyprop)/sizeof(argv_copyprop[0]), argv_copyprop, \"disable-copyprop\\n\");\n#endif\n#ifdef JL_DEBUG_BUILD\n    cl::ParseEnvironmentOptions(\"Julia\", \"JULIA_LLVM_ARGS\");\n#endif\n\n    imaging_mode = jl_generating_output();\n    jl_init_debuginfo();\n    jl_init_runtime_ccall();\n\n#ifndef LLVM34\n    // this option disables LLVM's signal handlers\n    llvm::DisablePrettyStackTrace = true;\n#endif\n\n#ifdef USE_POLLY\n    PassRegistry &Registry = *PassRegistry::getPassRegistry();\n    polly::initializePollyPasses(Registry);\n    initializeAnalysis(Registry);\n#endif\n\n    InitializeNativeTarget();\n    InitializeNativeTargetAsmPrinter();\n    InitializeNativeTargetAsmParser();\n    InitializeNativeTargetDisassembler();\n\n    Module *m, *engine_module;\n    engine_module = new Module(\"julia\", jl_LLVMContext);\n#ifdef USE_MCJIT\n    m = new Module(\"julia\", jl_LLVMContext);\n#else\n    m = engine_module;\n#endif\n    shadow_output = m;\n\n    TargetOptions options = TargetOptions();\n    //options.PrintMachineCode = true; //Print machine code produced during JIT compiling\n#if defined(JL_DEBUG_BUILD) && !defined(LLVM37)\n    options.JITEmitDebugInfo = true;\n#endif\n#ifndef LLVM37\n    options.NoFramePointerElim = true;\n#endif\n#ifndef LLVM34\n    options.NoFramePointerElimNonLeaf = true;\n#endif\n#if defined(_OS_WINDOWS_) && !defined(_CPU_X86_64_)\n    // tell Win32 to assume the stack is always 16-byte aligned,\n    // and to ensure that it is 16-byte aligned for out-going calls,\n    // to ensure compatibility with GCC codes\n    options.StackAlignmentOverride = 16;\n#endif\n#if defined(__APPLE__) && !defined(LLVM34)\n    // turn on JIT support for libunwind to walk the stack\n    options.JITExceptionHandling = 1;\n#endif\n\n#ifdef LLVM36\n    EngineBuilder eb((std::unique_ptr<Module>(engine_module)));\n#else\n    EngineBuilder eb(engine_module);\n#endif\n    std::string ErrorStr;\n    eb  .setEngineKind(EngineKind::JIT)\n#if defined(_OS_WINDOWS_) && defined(_CPU_X86_64_) && !defined(USE_MCJIT)\n        .setJITMemoryManager(createJITMemoryManagerWin())\n#elif defined(USE_MCJIT)\n        .setMCJITMemoryManager(std::unique_ptr<RTDyldMemoryManager>{createRTDyldMemoryManager()})\n#endif\n        .setTargetOptions(options)\n#if (defined(_OS_LINUX_) && defined(_CPU_X86_64_))\n        .setRelocationModel(Reloc::PIC_)\n#elif !defined(LLVM39)\n        .setRelocationModel(Reloc::Default)\n#endif\n#ifdef _P64\n        .setCodeModel(CodeModel::Large)\n#else\n        .setCodeModel(CodeModel::JITDefault)\n#endif\n#ifdef DISABLE_OPT\n        .setOptLevel(CodeGenOpt::None)\n#else\n        .setOptLevel(jl_options.opt_level == 0 ? CodeGenOpt::None : CodeGenOpt::Aggressive)\n#endif\n#if defined(USE_MCJIT) && !defined(LLVM36)\n        .setUseMCJIT(true)\n#endif\n#ifdef USE_ORCMCJIT\n        .setUseOrcMCJITReplacement(true)\n#endif\n    ;\n    Triple TheTriple(sys::getProcessTriple());\n#if defined(FORCE_ELF)\n#ifdef LLVM35\n    TheTriple.setObjectFormat(Triple::ELF);\n#else\n    TheTriple.setEnvironment(Triple::ELF);\n#endif\n#endif\n    std::string TheCPU = strcmp(jl_options.cpu_target,\"native\") ? jl_options.cpu_target : sys::getHostCPUName();\n    SmallVector<std::string, 10>  targetFeatures = getTargetFeatures( );\n    jl_TargetMachine = eb.selectTarget(\n            TheTriple,\n            \"\",\n            TheCPU,\n            targetFeatures);\n    assert(jl_TargetMachine && \"Failed to select target machine -\"\n                               \" Is the LLVM backend for this CPU enabled?\");\n#if defined(USE_MCJIT) && (!defined(_CPU_ARM_) && !defined(_CPU_PPC64_))\n    // FastISel seems to be buggy for ARM. Ref #13321\n    if (jl_options.opt_level < 2)\n        jl_TargetMachine->setFastISel(true);\n#endif\n\n    init_julia_llvm_meta();\n\n#ifdef USE_ORCJIT\n    jl_ExecutionEngine = new JuliaOJIT(*jl_TargetMachine);\n#else\n    jl_ExecutionEngine = eb.create(jl_TargetMachine);\n    //jl_printf(JL_STDERR,\"%s\\n\",jl_ExecutionEngine->getDataLayout()->getStringRepresentation().c_str());\n    if (!jl_ExecutionEngine) {\n        jl_printf(JL_STDERR, \"Critical error initializing llvm: %s\\n\",\n                  ErrorStr.c_str());\n        exit(1);\n    }\n#if defined(LLVM35) && !defined(USE_ORCMCJIT)\n    jl_ExecutionEngine->setProcessAllSections(true);\n#endif\n    jl_ExecutionEngine->DisableLazyCompilation();\n#endif\n\n    // Now that the execution engine exists, initialize all modules\n    jl_setup_module(engine_module);\n    jl_setup_module(m);\n    init_julia_llvm_env(m);\n\n#ifndef USE_ORCJIT\n    jl_ExecutionEngine->RegisterJITEventListener(CreateJuliaJITEventListener());\n#ifdef JL_USE_INTEL_JITEVENTS\n    if (jl_using_intel_jitevents)\n        jl_ExecutionEngine->RegisterJITEventListener(\n            JITEventListener::createIntelJITEventListener());\n#endif // JL_USE_INTEL_JITEVENTS\n\n#ifdef JL_USE_OPROFILE_JITEVENTS\n    if (jl_using_oprofile_jitevents)\n        jl_ExecutionEngine->RegisterJITEventListener(\n            JITEventListener::createOProfileJITEventListener());\n#endif // JL_USE_OPROFILE_JITEVENTS\n#endif\n\n    BOX_F(int8,int8);  UBOX_F(uint8,uint8);\n    BOX_F(int16,int16); UBOX_F(uint16,uint16);\n    BOX_F(int32,int32); UBOX_F(uint32,uint32);\n    BOX_F(int64,int64); UBOX_F(uint64,uint64);\n    BOX_F(float32,float32); BOX_F(float64,float64);\n    BOX_F(char,char);\n    UBOX_F(ssavalue,size);\n\n    box8_func  = boxfunc_llvm(ft2arg(T_pjlvalue, T_pjlvalue, T_int8),\n                              \"jl_box8\", &jl_box8, m);\n    box16_func = boxfunc_llvm(ft2arg(T_pjlvalue, T_pjlvalue, T_int16),\n                              \"jl_box16\", &jl_box16, m);\n    box32_func = boxfunc_llvm(ft2arg(T_pjlvalue, T_pjlvalue, T_int32),\n                              \"jl_box32\", &jl_box32, m);\n    box64_func = boxfunc_llvm(ft2arg(T_pjlvalue, T_pjlvalue, T_int64),\n                              \"jl_box64\", &jl_box64, m);\n    jl_init_intrinsic_functions_codegen(m);\n}\n\n// for debugging from gdb\nextern \"C\" void jl_dump_llvm_value(void *v)\n{\n    ((Value*)v)->dump();\n}\nextern \"C\" void jl_dump_llvm_type(void *v)\n{\n    ((Type*)v)->dump(); putchar('\\n');\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/ccall.cpp": "// This file is a part of Julia. License is MIT: http://julialang.org/license\n\n#include \"support/hashing.h\"\n\n// --- the ccall, cglobal, and llvm intrinsics ---\n\n// Map from symbol name (in a certain library) to its GV in sysimg and the\n// DL handle address in the current session.\ntypedef StringMap<std::pair<GlobalVariable*,void*>> SymMapGV;\nstatic StringMap<std::pair<GlobalVariable*,SymMapGV>> libMapGV;\n#ifdef _OS_WINDOWS_\nstatic SymMapGV symMapExe;\nstatic SymMapGV symMapDl;\n#endif\nstatic SymMapGV symMapDefault;\n\ntemplate<typename Func>\nstruct LazyModule {\n    Func func;\n    Module *m;\n    template<typename Func2>\n    LazyModule(Func2 &&func)\n        : func(std::forward<Func2>(func)),\n          m(nullptr)\n    {}\n    Module *get()\n    {\n        if (!m)\n            m = func();\n        return m;\n    }\n    Module &operator*()\n    {\n        return *get();\n    }\n};\n\ntemplate<typename Func>\nstatic LazyModule<typename std::remove_reference<Func>::type>\nlazyModule(Func &&func)\n{\n    return LazyModule<typename std::remove_reference<Func>::type>(\n        std::forward<Func>(func));\n}\n\n// Find or create the GVs for the library and symbol lookup.\n// Return `runtime_lib` (whether the library name is a string)\n// Optionally return the symbol address in the current session\n// when `symaddr != nullptr`.\n// The `lib` and `sym` GV returned may not be in the current module.\ntemplate<typename MT>\nstatic bool runtime_sym_gvs(const char *f_lib, const char *f_name, MT &&M,\n                            GlobalVariable *&lib, GlobalVariable *&sym,\n                            void **symaddr=nullptr)\n{\n    void *libsym = NULL;\n    bool runtime_lib = false;\n    GlobalVariable *libptrgv;\n    SymMapGV *symMap;\n#ifdef _OS_WINDOWS_\n    if ((intptr_t)f_lib == 1) {\n        libptrgv = jlexe_var;\n        libsym = jl_exe_handle;\n        symMap = &symMapExe;\n    }\n    else if ((intptr_t)f_lib == 2) {\n        libptrgv = jldll_var;\n        libsym = jl_dl_handle;\n        symMap = &symMapDl;\n    }\n    else\n#endif\n    if (f_lib == NULL) {\n        libptrgv = jlRTLD_DEFAULT_var;\n        libsym = jl_RTLD_DEFAULT_handle;\n        symMap = &symMapDefault;\n    }\n    else {\n        std::string name = \"ccalllib_\";\n        name += f_lib;\n        runtime_lib = true;\n        auto iter = libMapGV.find(f_lib);\n        if (iter == libMapGV.end()) {\n            libptrgv = new GlobalVariable(*M, T_pint8, false,\n                                          GlobalVariable::ExternalLinkage,\n                                          NULL, name);\n            auto &libgv = libMapGV[f_lib];\n            libgv = std::make_pair(global_proto(libptrgv), SymMapGV());\n            symMap = &libgv.second;\n            libsym = jl_get_library(f_lib);\n            assert(libsym != NULL);\n            *(void**)jl_emit_and_add_to_shadow(libptrgv) = libsym;\n        }\n        else {\n            libptrgv = iter->second.first;\n            symMap = &iter->second.second;\n        }\n    }\n    if (libsym == NULL) {\n        libsym = *(void**)jl_get_global(libptrgv);\n    }\n    assert(libsym != NULL);\n\n    GlobalVariable *llvmgv;\n    auto sym_iter = symMap->find(f_name);\n    if (sym_iter == symMap->end()) {\n        // MCJIT forces this to have external linkage eventually, so we would clobber\n        // the symbol of the actual function.\n        std::string name = \"ccall_\";\n        name += f_name;\n        name += \"_\";\n        name += std::to_string(globalUnique++);\n        llvmgv = new GlobalVariable(*M, T_pvoidfunc, false,\n                                    GlobalVariable::ExternalLinkage, NULL, name);\n        llvmgv = global_proto(llvmgv);\n        void *addr = jl_dlsym_e(libsym, f_name);\n        (*symMap)[f_name] = std::make_pair(llvmgv, addr);\n        if (symaddr)\n            *symaddr = addr;\n        *(void**)jl_emit_and_add_to_shadow(llvmgv) = addr;\n    }\n    else {\n        if (symaddr)\n            *symaddr = sym_iter->second.second;\n        llvmgv = sym_iter->second.first;\n    }\n\n    lib = libptrgv;\n    sym = llvmgv;\n    return runtime_lib;\n}\n\nstatic Value *runtime_sym_lookup(PointerType *funcptype, const char *f_lib,\n                                 const char *f_name, Function *f,\n                                 GlobalVariable *libptrgv,\n                                 GlobalVariable *llvmgv, bool runtime_lib)\n{\n    // in pseudo-code, this function emits the following:\n    //   global HMODULE *libptrgv\n    //   global void **llvmgv\n    //   if (*llvmgv == NULL) {\n    //       *llvmgv = jl_load_and_lookup(f_lib, f_name, libptrgv);\n    //   }\n    //   return (*llvmgv)\n    BasicBlock *dlsym_lookup = BasicBlock::Create(jl_LLVMContext, \"dlsym\");\n    BasicBlock *ccall_bb = BasicBlock::Create(jl_LLVMContext, \"ccall\");\n    Constant *initnul = ConstantPointerNull::get((PointerType*)T_pvoidfunc);\n    builder.CreateCondBr(builder.CreateICmpNE(builder.CreateLoad(llvmgv), initnul), ccall_bb, dlsym_lookup);\n\n    assert(f->getParent() != NULL);\n    f->getBasicBlockList().push_back(dlsym_lookup);\n    builder.SetInsertPoint(dlsym_lookup);\n    Value *libname;\n    if (runtime_lib) {\n        libname = stringConstPtr(f_lib);\n    }\n    else {\n        libname = literal_static_pointer_val(f_lib, T_pint8);\n    }\n#ifdef LLVM37\n    Value *llvmf = builder.CreateCall(prepare_call(jldlsym_func), { libname, stringConstPtr(f_name), libptrgv });\n#else\n    Value *llvmf = builder.CreateCall3(prepare_call(jldlsym_func), libname, stringConstPtr(f_name), libptrgv);\n#endif\n    builder.CreateStore(llvmf, llvmgv);\n    builder.CreateBr(ccall_bb);\n\n    f->getBasicBlockList().push_back(ccall_bb);\n    builder.SetInsertPoint(ccall_bb);\n    llvmf = builder.CreateLoad(llvmgv);\n    return builder.CreatePointerCast(llvmf,funcptype);\n}\n\nstatic Value *runtime_sym_lookup(PointerType *funcptype, const char *f_lib,\n                                 const char *f_name, Function *f)\n{\n    GlobalVariable *libptrgv;\n    GlobalVariable *llvmgv;\n    bool runtime_lib = runtime_sym_gvs(f_lib, f_name, f->getParent(),\n                                       libptrgv, llvmgv);\n    libptrgv = prepare_global(libptrgv);\n    llvmgv = prepare_global(llvmgv);\n    return runtime_sym_lookup(funcptype, f_lib, f_name, f, libptrgv, llvmgv,\n                              runtime_lib);\n}\n\n// Map from distinct callee's to its GOT entry.\n// In principle the attribute, function type and calling convention\n// don't need to be part of the key but it seems impossible to forward\n// all the arguments without writing assembly directly.\n// This doesn't matter too much in reality since a single function is usually\n// not called with multiple signatures.\nstatic DenseMap<AttributeSet,\n                std::map<std::tuple<GlobalVariable*,FunctionType*,\n                                    CallingConv::ID>,GlobalVariable*>> allPltMap;\n\n// Emit a \"PLT\" entry that will be lazily initialized\n// when being called the first time.\nstatic Value *emit_plt(FunctionType *functype, const AttributeSet &attrs,\n                       CallingConv::ID cc, const char *f_lib, const char *f_name)\n{\n    assert(imaging_mode);\n    // Don't do this for vararg functions so that the `musttail` is only\n    // an optimization and is not required to function correctly.\n    assert(!functype->isVarArg());\n    GlobalVariable *libptrgv;\n    GlobalVariable *llvmgv;\n    void *symaddr;\n    auto LM = lazyModule([&] {\n            Module *m = new Module(f_name, jl_LLVMContext);\n            jl_setup_module(m);\n            return m;\n        });\n    bool runtime_lib = runtime_sym_gvs(f_lib, f_name, LM,\n                                       libptrgv, llvmgv, &symaddr);\n    PointerType *funcptype = PointerType::get(functype, 0);\n\n    auto &pltMap = allPltMap[attrs];\n    auto key = std::make_tuple(llvmgv, functype, cc);\n    auto &slot = pltMap[key];\n    GlobalVariable *got;\n    if (!slot) {\n        Module *M = LM.get();\n        libptrgv = prepare_global(libptrgv, M);\n        llvmgv = prepare_global(llvmgv, M);\n        BasicBlock *old = builder.GetInsertBlock();\n        DebugLoc olddl = builder.getCurrentDebugLocation();\n        DebugLoc noDbg;\n        builder.SetCurrentDebugLocation(noDbg);\n        std::stringstream funcName;\n        funcName << \"jlplt_\" << f_name << \"_\" << globalUnique++;\n        auto fname = funcName.str();\n        Function *plt = Function::Create(functype,\n                                         GlobalVariable::ExternalLinkage,\n                                         fname, M);\n        plt->setAttributes(attrs);\n        if (cc != CallingConv::C)\n            plt->setCallingConv(cc);\n        funcName << \"_got\";\n        auto gname = funcName.str();\n        got = new GlobalVariable(*M, T_pvoidfunc, false,\n                                 GlobalVariable::ExternalLinkage,\n                                 nullptr, gname);\n        slot = global_proto(got);\n        *(void**)jl_emit_and_add_to_shadow(got) = symaddr;\n        BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", plt);\n        builder.SetInsertPoint(b0);\n        Value *ptr = runtime_sym_lookup(funcptype, f_lib, f_name, plt, libptrgv,\n                                        llvmgv, runtime_lib);\n        builder.CreateStore(builder.CreateBitCast(ptr, T_pvoidfunc), got);\n        SmallVector<Value*, 16> args;\n        for (Function::arg_iterator arg = plt->arg_begin(), arg_e = plt->arg_end(); arg != arg_e; ++arg)\n            args.push_back(&*arg);\n        CallInst *ret = builder.CreateCall(ptr, ArrayRef<Value*>(args));\n        ret->setAttributes(attrs);\n        if (cc != CallingConv::C)\n            ret->setCallingConv(cc);\n        // NoReturn function can trigger LLVM verifier error when declared as\n        // MustTail since other passes might replace the `ret` with\n        // `unreachable` (LLVM should probably accept `unreachable`).\n        if (attrs.hasAttribute(AttributeSet::FunctionIndex,\n                               Attribute::NoReturn)) {\n            builder.CreateUnreachable();\n        }\n        else {\n            // musttail support is very bad on ARM, PPC, PPC64 (as of LLVM 3.9)\n            // Known failures includes vararg (not needed here) and sret.\n#if defined(LLVM37) && (defined(_CPU_X86_) || defined(_CPU_X86_64_) || \\\n                        defined(_CPU_AARCH64_))\n            ret->setTailCallKind(CallInst::TCK_MustTail);\n#endif\n            if (functype->getReturnType() == T_void) {\n                builder.CreateRetVoid();\n            }\n            else {\n                builder.CreateRet(ret);\n            }\n        }\n        builder.SetInsertPoint(old);\n        builder.SetCurrentDebugLocation(olddl);\n        jl_finalize_module(M, true);\n        auto shadowgot =\n            cast<GlobalVariable>(shadow_output->getNamedValue(gname));\n        auto shadowplt = cast<Function>(shadow_output->getNamedValue(fname));\n        shadowgot->setInitializer(ConstantExpr::getBitCast(shadowplt,\n                                                           T_pvoidfunc));\n        got = prepare_global(shadowgot);\n    }\n    else {\n        // `runtime_sym_gvs` shouldn't have created anything in a new module\n        // if it returns a GV that already exists.\n        assert(!LM.m);\n        got = prepare_global(slot);\n    }\n    return builder.CreateBitCast(builder.CreateLoad(got), funcptype);\n}\n\n// --- ABI Implementations ---\n// Partially based on the LDC ABI implementations licensed under the BSD 3-clause license\n\n#if defined ABI_LLVM\n#  include \"abi_llvm.cpp\"\n#elif defined _CPU_X86_64_\n#  if defined _OS_WINDOWS_\n#    include \"abi_win64.cpp\"\n#  else\n#    include \"abi_x86_64.cpp\"\n#  endif\n#elif defined _CPU_X86_\n#  if defined _OS_WINDOWS_\n#    include \"abi_win32.cpp\"\n#  else\n#    include \"abi_x86.cpp\"\n#  endif\n#elif defined _CPU_ARM_\n#  include \"abi_arm.cpp\"\n#elif defined _CPU_AARCH64_\n#  include \"abi_aarch64.cpp\"\n#elif defined _CPU_PPC64_\n#  include \"abi_ppc64le.cpp\"\n#else\n#  warning \"ccall is defaulting to llvm ABI, since no platform ABI has been defined for this CPU/OS combination\"\n#  include \"abi_llvm.cpp\"\n#endif\n\nValue *llvm_type_rewrite(Value *v, Type *from_type, Type *target_type,\n        bool tojulia, /* only matters if byref is set (declares the direction of the byref attribute) */\n        bool byref, /* only applies to arguments, set false for return values -- effectively the same as jl_cgval_t.ispointer() */\n        bool issigned, /* determines whether an integer value should be zero or sign extended */\n        jl_codectx_t *ctx)\n{\n    if (v->getType() == T_void)\n        return UndefValue::get(target_type); // convert undef (unreachable) -> undef (target_type)\n\n    if (byref) {\n        if (tojulia) {\n            Type *ptarget_type = PointerType::get(target_type, 0);\n            if (v->getType() != ptarget_type)\n                v = builder.CreatePointerCast(v, ptarget_type);\n            return builder.CreateAlignedLoad(v, 1); // unknown alignment from C\n        }\n        else {\n            // julia_to_native should already have done the alloca and store\n            if (v->getType() != target_type)\n                v = builder.CreatePointerCast(v, target_type);\n            return v;\n        }\n    }\n    assert(v->getType() == from_type);\n\n    if (target_type == from_type) {\n        return v;\n    }\n\n    assert(from_type->isPointerTy() == target_type->isPointerTy()); // expect that all ABIs consider all pointers to be equivalent\n    if (target_type->isPointerTy()) {\n        return builder.CreatePointerCast(v, target_type);\n    }\n\n    // simple integer and float widening & conversion cases\n    if (from_type->getPrimitiveSizeInBits() > 0 && target_type->getPrimitiveSizeInBits() == from_type->getPrimitiveSizeInBits()) {\n        return emit_bitcast(v, target_type);\n    }\n    if (target_type->isFloatingPointTy() && from_type->isFloatingPointTy()) {\n        if (target_type->getPrimitiveSizeInBits() > from_type->getPrimitiveSizeInBits())\n            return builder.CreateFPExt(v, target_type);\n        else if (target_type->getPrimitiveSizeInBits() < from_type->getPrimitiveSizeInBits())\n            return builder.CreateFPTrunc(v, target_type);\n        else\n            return v;\n    }\n    if (target_type->isIntegerTy() && from_type->isIntegerTy()) {\n        if (issigned)\n            return builder.CreateSExtOrTrunc(v, target_type);\n        else\n            return builder.CreateZExtOrTrunc(v, target_type);\n    }\n\n    // one or both of from_type and target_type is a VectorType or AggregateType\n    // LLVM doesn't allow us to cast these values directly, so\n    // we need to use this alloca copy trick instead\n    // On ARM and AArch64, the ABI requires casting through memory to different\n    // sizes.\n    Value *from;\n    Value *to;\n#ifdef LLVM36\n    const DataLayout &DL = jl_ExecutionEngine->getDataLayout();\n#else\n    const DataLayout &DL = *jl_ExecutionEngine->getDataLayout();\n#endif\n    if (DL.getTypeAllocSize(target_type) >= DL.getTypeAllocSize(from_type)) {\n        to = emit_static_alloca(target_type, ctx);\n        from = builder.CreatePointerCast(to, from_type->getPointerTo());\n    }\n    else {\n        from = emit_static_alloca(from_type, ctx);\n        to = builder.CreatePointerCast(from, target_type->getPointerTo());\n    }\n    builder.CreateStore(v, from);\n    return builder.CreateLoad(to);\n}\n\n// --- argument passing and scratch space utilities ---\n\n// Emit code to convert argument to form expected by C ABI\n// to = desired LLVM type\n// jlto = Julia type of formal argument\n// jvinfo = value of actual argument\nstatic Value *julia_to_native(Type *to, bool toboxed, jl_value_t *jlto, const jl_cgval_t &jvinfo,\n                              bool addressOf, bool byRef, bool inReg, bool needCopy,\n                              bool tojulia, int argn, jl_codectx_t *ctx,\n                              bool *needStackRestore)\n{\n    // We're passing Any\n    if (toboxed) {\n        assert(!addressOf && !byRef); // don't expect any ABI to pass pointers by pointer\n        return boxed(jvinfo, ctx);\n    }\n    assert(jl_is_leaf_type(jlto));\n\n    // TODO: Tuple arguments are currently undefined behavior, for defining the calling convention that they match to.\n    // XXX: However, they are used in the llvmcall test, so I guess it'll have to stay.\n    //if (jl_is_tuple(jlto) || jl_is_tuple_type(jlto)) {\n    //    emit_error(\"ccall: unimplemented: unboxed tuple argument type\", ctx);\n    //    return UndefValue::get(to);\n    //}\n\n    jl_value_t *ety = jlto;\n    if (addressOf) {\n        if (!jl_is_cpointer_type(jlto)) {\n            emit_error(\"ccall: & on argument was not matched by Ptr{T} argument type\", ctx);\n            return UndefValue::get(T_void);\n        }\n        ety = jl_tparam0(jlto);\n        if (jlto == (jl_value_t*)jl_voidpointer_type)\n            ety = jvinfo.typ; // skip the type-check\n        assert(to->isPointerTy());\n    }\n    if (jvinfo.typ != ety && ety != (jl_value_t*)jl_any_type) {\n        if (!addressOf && ety == (jl_value_t*)jl_voidpointer_type) {\n            // allow a bit more flexibility for what can be passed to (void*) due to Ref{T} conversion behavior below\n            if (!jl_is_cpointer_type(jvinfo.typ)) {\n                // emit a typecheck, if not statically known to be correct\n                std::stringstream msg;\n                msg << \"ccall argument \";\n                msg << argn;\n                emit_cpointercheck(jvinfo, msg.str(), ctx);\n            }\n        }\n        else {\n            // emit a typecheck, if not statically known to be correct\n            std::stringstream msg;\n            msg << \"ccall argument \";\n            msg << argn;\n            emit_typecheck(jvinfo, ety, msg.str(), ctx);\n        }\n    }\n\n    if (!addressOf && !byRef)\n        return emit_unbox(to, jvinfo, ety);\n\n    if (addressOf && jvinfo.isboxed) {\n        if (!jl_is_abstracttype(ety)) {\n            if (jl_is_mutable_datatype(ety)) {\n                // no copy, just reference the data field\n                return data_pointer(jvinfo, ctx, to);\n            }\n            else if (jl_is_immutable_datatype(ety) && jlto != (jl_value_t*)jl_voidpointer_type) {\n                // yes copy\n                Value *nbytes;\n                AllocaInst *ai;\n                if (jl_is_leaf_type(ety)) {\n                    int nb = jl_datatype_size(ety);\n                    nbytes = ConstantInt::get(T_int32, nb);\n                    ai = emit_static_alloca(T_int8, nb, ctx);\n                }\n                else {\n                    nbytes = emit_datatype_size(emit_typeof_boxed(jvinfo,ctx));\n                    ai = builder.CreateAlloca(T_int8, nbytes);\n                    *needStackRestore = true;\n                }\n                ai->setAlignment(16);\n                prepare_call(\n                    builder.CreateMemCpy(ai, data_pointer(jvinfo, ctx, T_pint8), nbytes, sizeof(void*))->getCalledValue()); // minimum gc-alignment in julia is pointer size\n                return emit_bitcast(ai, to);\n            }\n        }\n        // emit maybe copy\n        *needStackRestore = true;\n        Value *jvt = emit_typeof_boxed(jvinfo, ctx);\n        BasicBlock *mutableBB = BasicBlock::Create(jl_LLVMContext,\"is-mutable\",ctx->f);\n        BasicBlock *immutableBB = BasicBlock::Create(jl_LLVMContext,\"is-immutable\",ctx->f);\n        BasicBlock *afterBB = BasicBlock::Create(jl_LLVMContext,\"after\",ctx->f);\n        Value *ismutable = emit_datatype_mutabl(jvt);\n        builder.CreateCondBr(ismutable, mutableBB, immutableBB);\n        builder.SetInsertPoint(mutableBB);\n        Value *p1 = data_pointer(jvinfo, ctx, to);\n        builder.CreateBr(afterBB);\n        builder.SetInsertPoint(immutableBB);\n        Value *nbytes = emit_datatype_size(jvt);\n        AllocaInst *ai = builder.CreateAlloca(T_int8, nbytes);\n        ai->setAlignment(16);\n        prepare_call(builder.CreateMemCpy(ai, data_pointer(jvinfo, ctx, T_pint8), nbytes, sizeof(void*))->getCalledValue()); // minimum gc-alignment in julia is pointer size\n        Value *p2 = emit_bitcast(ai, to);\n        builder.CreateBr(afterBB);\n        builder.SetInsertPoint(afterBB);\n        PHINode *p = builder.CreatePHI(to, 2);\n        p->addIncoming(p1, mutableBB);\n        p->addIncoming(p2, immutableBB);\n        return p;\n    }\n\n    // pass the address of an alloca'd thing, not a box\n    // since those are immutable.\n    if (addressOf)\n        to = to->getContainedType(0);\n    Value *slot = emit_static_alloca(to, ctx);\n    if (!jvinfo.ispointer()) {\n        builder.CreateStore(emit_unbox(to, jvinfo, ety), slot);\n    }\n    else {\n        prepare_call(builder.CreateMemCpy(slot, data_pointer(jvinfo, ctx, slot->getType()),\n                    (uint64_t)jl_datatype_size(ety),\n                    (uint64_t)((jl_datatype_t*)ety)->layout->alignment)->getCalledValue());\n        mark_gc_use(jvinfo);\n    }\n    return slot;\n}\n\ntypedef struct {\n    Value *jl_ptr;  // if the argument is a run-time computed pointer\n    void (*fptr)(void);     // if the argument is a constant pointer\n    const char *f_name;   // if the symbol name is known\n    const char *f_lib;    // if a library name is specified\n} native_sym_arg_t;\n\n// --- parse :sym or (:sym, :lib) argument into address info ---\nstatic native_sym_arg_t interpret_symbol_arg(jl_value_t *arg, jl_codectx_t *ctx, const char *fname)\n{\n    jl_value_t *ptr = NULL;\n    Value *jl_ptr=NULL;\n\n    ptr = static_eval(arg, ctx, true);\n    if (ptr == NULL) {\n        jl_value_t *ptr_ty = expr_type(arg, ctx);\n        jl_cgval_t arg1 = emit_expr(arg, ctx);\n        if (!jl_is_cpointer_type(ptr_ty)) {\n            emit_cpointercheck(arg1,\n                               !strcmp(fname,\"ccall\") ?\n                               \"ccall: first argument not a pointer or valid constant expression\" :\n                               \"cglobal: first argument not a pointer or valid constant expression\",\n                               ctx);\n        }\n        arg1 = remark_julia_type(arg1, (jl_value_t*)jl_voidpointer_type);\n        jl_ptr = emit_unbox(T_size, arg1, (jl_value_t*)jl_voidpointer_type);\n    }\n\n    void (*fptr)(void) = NULL;\n    const char *f_name=NULL, *f_lib=NULL;\n    jl_value_t *t0 = NULL, *t1 = NULL;\n    JL_GC_PUSH3(&ptr, &t0, &t1);\n    if (ptr != NULL) {\n        if (jl_is_tuple(ptr) && jl_nfields(ptr)==1) {\n            ptr = jl_fieldref(ptr,0);\n        }\n        if (jl_is_symbol(ptr))\n            f_name = jl_symbol_name((jl_sym_t*)ptr);\n        else if (jl_is_string(ptr))\n            f_name = jl_string_data(ptr);\n        if (f_name != NULL) {\n            // just symbol, default to JuliaDLHandle\n            // will look in process symbol table\n#ifdef _OS_WINDOWS_\n            f_lib = jl_dlfind_win32(f_name);\n#endif\n        }\n        else if (jl_is_cpointer_type(jl_typeof(ptr))) {\n            fptr = *(void(**)(void))jl_data_ptr(ptr);\n        }\n        else if (jl_is_tuple(ptr) && jl_nfields(ptr)>1) {\n            jl_value_t *t0 = jl_fieldref(ptr,0);\n            jl_value_t *t1 = jl_fieldref(ptr,1);\n            if (jl_is_symbol(t0))\n                f_name = jl_symbol_name((jl_sym_t*)t0);\n            else if (jl_is_string(t0))\n                f_name = jl_string_data(t0);\n            else\n                JL_TYPECHKS(fname, symbol, t0);\n            if (jl_is_symbol(t1))\n                f_lib = jl_symbol_name((jl_sym_t*)t1);\n            else if (jl_is_string(t1))\n                f_lib = jl_string_data(t1);\n            else\n                JL_TYPECHKS(fname, symbol, t1);\n        }\n        else {\n            JL_TYPECHKS(fname, pointer, ptr);\n        }\n    }\n    JL_GC_POP();\n    native_sym_arg_t r;\n    r.jl_ptr = jl_ptr;\n    r.fptr = fptr;\n    r.f_name = f_name;\n    r.f_lib = f_lib;\n    return r;\n}\n\n\nstatic jl_value_t* try_eval(jl_value_t *ex, jl_codectx_t *ctx, const char *failure, bool compiletime=false)\n{\n    jl_value_t *constant = NULL;\n    constant = static_eval(ex, ctx, true, true);\n    if (constant || jl_is_ssavalue(ex))\n        return constant;\n    JL_TRY {\n        constant = jl_interpret_toplevel_expr_in(ctx->module, ex, ctx->linfo);\n    }\n    JL_CATCH {\n        if (compiletime)\n            jl_rethrow_with_add(failure);\n        if (failure)\n            emit_error(failure, ctx);\n        constant = NULL;\n    }\n    return constant;\n}\n\n// --- code generator for cglobal ---\n\nstatic jl_cgval_t emit_cglobal(jl_value_t **args, size_t nargs, jl_codectx_t *ctx)\n{\n    JL_NARGS(cglobal, 1, 2);\n    jl_value_t *rt=NULL;\n    Value *res;\n    JL_GC_PUSH1(&rt);\n\n    if (nargs == 2) {\n        rt = try_eval(args[2], ctx, \"error interpreting cglobal pointer type\");\n        if (rt == NULL) {\n            JL_GC_POP();\n            return jl_cgval_t();\n        }\n\n        JL_TYPECHK(cglobal, type, rt);\n        rt = (jl_value_t*)jl_apply_type((jl_value_t*)jl_pointer_type, jl_svec1(rt));\n    }\n    else {\n        rt = (jl_value_t*)jl_voidpointer_type;\n    }\n    Type *lrt = julia_type_to_llvm(rt);\n    if (lrt == NULL) lrt = T_pint8;\n\n    native_sym_arg_t sym = interpret_symbol_arg(args[1], ctx, \"cglobal\");\n\n    if (sym.jl_ptr != NULL) {\n        res = builder.CreateIntToPtr(sym.jl_ptr, lrt);\n    }\n    else if (sym.fptr != NULL) {\n        res = literal_static_pointer_val((void*)(uintptr_t)sym.fptr, lrt);\n        if (imaging_mode)\n            jl_printf(JL_STDERR,\"WARNING: literal address used in cglobal for %s; code cannot be statically compiled\\n\", sym.f_name);\n    }\n    else {\n        if (imaging_mode) {\n            res = runtime_sym_lookup((PointerType*)lrt, sym.f_lib, sym.f_name, ctx->f);\n        }\n        else {\n            void *symaddr = jl_dlsym_e(jl_get_library(sym.f_lib), sym.f_name);\n            if (symaddr == NULL) {\n                std::stringstream msg;\n                msg << \"cglobal: could not find symbol \";\n                msg << sym.f_name;\n                if (sym.f_lib != NULL) {\n#ifdef _OS_WINDOWS_\n                    assert((intptr_t)sym.f_lib != 1 && (intptr_t)sym.f_lib != 2);\n#endif\n                    msg << \" in library \";\n                    msg << sym.f_lib;\n                }\n                emit_error(msg.str(), ctx);\n            }\n            // since we aren't saving this code, there's no sense in\n            // putting anything complicated here: just JIT the address of the cglobal\n            res = literal_static_pointer_val(symaddr, lrt);\n        }\n    }\n\n    JL_GC_POP();\n    return mark_julia_type(res, false, rt, ctx);\n}\n\n#ifdef USE_MCJIT\nclass FunctionMover : public ValueMaterializer\n{\npublic:\n    FunctionMover(llvm::Module *dest,llvm::Module *src) :\n        ValueMaterializer(), VMap(), destModule(dest), srcModule(src),\n        LazyFunctions(0)\n    {\n    }\n    ValueToValueMapTy VMap;\n    llvm::Module *destModule;\n    llvm::Module *srcModule;\n    std::vector<Function *> LazyFunctions;\n\n    Function *CloneFunctionProto(Function *F)\n    {\n        assert(!F->isDeclaration());\n        Function *NewF = Function::Create(F->getFunctionType(),\n                                          Function::ExternalLinkage,\n                                          F->getName(),\n                                          destModule);\n        LazyFunctions.push_back(F);\n        VMap[F] = NewF;\n        return NewF;\n    }\n\n    void CloneFunctionBody(Function *F)\n    {\n        Function *NewF = (Function*)(Value*)VMap[F];\n        assert(NewF != NULL);\n\n        Function::arg_iterator DestI = NewF->arg_begin();\n        for (Function::const_arg_iterator I = F->arg_begin(), E = F->arg_end(); I != E; ++I) {\n            DestI->setName(I->getName());    // Copy the name over...\n            VMap[&*I] = &*(DestI++);        // Add mapping to VMap\n        }\n\n    #ifdef LLVM36\n        // Clone debug info - Not yet public API\n        // llvm::CloneDebugInfoMetadata(NewF,F,VMap);\n    #endif\n\n        SmallVector<ReturnInst*, 8> Returns;\n        llvm::CloneFunctionInto(NewF,F,VMap,true,Returns,\"\",NULL,NULL,this);\n        NewF->setComdat(nullptr);\n        NewF->setSection(\"\");\n    }\n\n    Function *CloneFunction(Function *F)\n    {\n        Function *NewF = (llvm::Function*)MapValue(F,VMap,RF_None,NULL,this);\n        ResolveLazyFunctions();\n        return NewF;\n    }\n\n    void ResolveLazyFunctions()\n    {\n        while (!LazyFunctions.empty()) {\n            Function *F = LazyFunctions.back();\n            LazyFunctions.pop_back();\n\n            CloneFunctionBody(F);\n        }\n    }\n\n    Value *InjectFunctionProto(Function *F)\n    {\n        Function *NewF = destModule->getFunction(F->getName());\n        if (!NewF) {\n            NewF = function_proto(F);\n            NewF->setComdat(nullptr);\n            destModule->getFunctionList().push_back(NewF);\n        }\n        return NewF;\n    }\n\n#if defined(LLVM39)\n    virtual Value *materialize(Value *V) override\n#elif defined(LLVM38)\n    virtual Value *materializeDeclFor(Value *V) override\n#else\n    virtual Value *materializeValueFor (Value *V) override\n#endif\n    {\n        Function *F = dyn_cast<Function>(V);\n        if (F) {\n            if (isIntrinsicFunction(F)) {\n                return destModule->getOrInsertFunction(F->getName(),F->getFunctionType());\n            }\n            if (F->isDeclaration() || F->getParent() != destModule) {\n                if (F->getName().empty())\n                    return CloneFunctionProto(F);\n                Function *shadow = srcModule->getFunction(F->getName());\n                if (shadow != NULL && !shadow->isDeclaration()) {\n                    Function *oldF = destModule->getFunction(F->getName());\n                    if (oldF)\n                        return oldF;\n\n                    #ifdef USE_ORCJIT\n                    if (jl_ExecutionEngine->findSymbol(F->getName(), false))\n                        return InjectFunctionProto(F);\n                    #endif\n\n                    return CloneFunctionProto(shadow);\n                }\n                else if (!F->isDeclaration()) {\n                    return CloneFunctionProto(F);\n                }\n            }\n            // Still a declaration and still in a different module\n            if (F->isDeclaration() && F->getParent() != destModule) {\n                // Create forward declaration in current module\n                return InjectFunctionProto(F);\n            }\n        }\n        else if (isa<GlobalVariable>(V)) {\n            GlobalVariable *GV = cast<GlobalVariable>(V);\n            assert(GV != NULL);\n            GlobalVariable *oldGV = destModule->getGlobalVariable(GV->getName());\n            if (oldGV != NULL)\n                return oldGV;\n            GlobalVariable *newGV = new GlobalVariable(*destModule,\n                GV->getType()->getElementType(),\n                GV->isConstant(),\n                GlobalVariable::ExternalLinkage,\n                NULL,\n                GV->getName(),\n                NULL,\n                GV->getThreadLocalMode(),\n                GV->getType()->getPointerAddressSpace());\n            newGV->copyAttributesFrom(GV);\n            newGV->setComdat(nullptr);\n            if (GV->isDeclaration())\n                return newGV;\n            if (!GV->getName().empty()) {\n                uint64_t addr = jl_ExecutionEngine->getGlobalValueAddress(GV->getName());\n                if (addr != 0) {\n                    newGV->setExternallyInitialized(true);\n                    return newGV;\n                }\n            }\n            if (GV->hasInitializer()) {\n                Value *C = MapValue(GV->getInitializer(),VMap,RF_None,NULL,this);\n                newGV->setInitializer(cast<Constant>(C));\n            }\n            return newGV;\n        }\n        return NULL;\n    };\n};\n#endif\n\n// llvmcall(ir, (rettypes...), (argtypes...), args...)\nstatic jl_cgval_t emit_llvmcall(jl_value_t **args, size_t nargs, jl_codectx_t *ctx)\n{\n    JL_NARGSV(llvmcall, 3);\n    jl_value_t *rt = NULL, *at = NULL, *ir = NULL, *decl = NULL;\n    jl_svec_t *stt = NULL;\n    JL_GC_PUSH5(&ir, &rt, &at, &stt, &decl);\n    at = try_eval(args[3], ctx, \"error statically evaluating llvmcall argument tuple\", true);\n    rt = try_eval(args[2], ctx, \"error statically evaluating llvmcall return type\", true);\n    ir = try_eval(args[1], ctx, \"error statically evaluating llvm IR argument\", true);\n    int i = 1;\n    if (jl_is_tuple(ir)) {\n        // if the IR is a tuple, we expect (declarations, ir)\n        if (jl_nfields(ir) != 2)\n            jl_error(\"Tuple as first argument to llvmcall must have exactly two children\");\n        decl = jl_fieldref(ir,0);\n        ir = jl_fieldref(ir,1);\n        if (!jl_is_string(decl))\n            jl_error(\"Declarations passed to llvmcall must be a string\");\n    }\n    bool isString = jl_is_string(ir);\n    bool isPtr = jl_is_cpointer(ir);\n    if (!isString && !isPtr) {\n        jl_error(\"IR passed to llvmcall must be a string or pointer to an LLVM Function\");\n    }\n\n    JL_TYPECHK(llvmcall, type, rt);\n    JL_TYPECHK(llvmcall, type, at);\n\n    std::stringstream ir_stream;\n\n    stt = jl_alloc_svec(nargs - 3);\n\n    for (size_t i = 0; i < nargs-3; ++i) {\n        jl_svecset(stt,i,expr_type(args[4+i],ctx));\n    }\n\n    // Generate arguments\n    std::string arguments;\n    llvm::raw_string_ostream argstream(arguments);\n    jl_svec_t *tt = ((jl_datatype_t*)at)->parameters;\n    jl_value_t *rtt = rt;\n\n    size_t nargt = jl_svec_len(tt);\n    Value **argvals = (Value**) alloca(nargt*sizeof(Value*));\n    std::vector<llvm::Type*> argtypes;\n    /*\n     * Semantics for arguments are as follows:\n     * If the argument type is immutable (including bitstype), we pass the loaded llvm value\n     * type. Otherwise we pass a pointer to a jl_value_t.\n     */\n    jl_cgval_t *argv = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * nargt);\n    for (size_t i = 0; i < nargt; ++i) {\n        jl_value_t *tti = jl_svecref(tt,i);\n        bool toboxed;\n        Type *t = julia_type_to_llvm(tti, &toboxed);\n        argtypes.push_back(t);\n        if (4+i > nargs) {\n            jl_error(\"Missing arguments to llvmcall!\");\n        }\n        jl_value_t *argi = args[4 + i];\n        jl_cgval_t &arg = argv[i];\n        arg = emit_expr(argi, ctx);\n\n        Value *v = julia_to_native(t, toboxed, tti, arg, false, false, false, false, false, i, ctx, NULL);\n        // make sure args are rooted\n        bool issigned = jl_signed_type && jl_subtype(tti, (jl_value_t*)jl_signed_type, 0);\n        argvals[i] = llvm_type_rewrite(v, t, t, false, false, issigned, ctx);\n    }\n\n    Function *f;\n    bool retboxed;\n    Type *rettype = julia_type_to_llvm(rtt, &retboxed);\n    if (isString) {\n        // Make sure to find a unique name\n        std::string ir_name;\n        while(true) {\n            std::stringstream name;\n            name << (ctx->f->getName().str()) << \"u\" << i++;\n            ir_name = name.str();\n            if (jl_Module->getFunction(ir_name) == NULL)\n                break;\n        }\n\n        bool first = true;\n        for (std::vector<Type *>::iterator it = argtypes.begin(); it != argtypes.end(); ++it) {\n            if (!first)\n                argstream << \",\";\n            else\n                first = false;\n            (*it)->print(argstream);\n            argstream << \" \";\n        }\n\n        std::string rstring;\n        llvm::raw_string_ostream rtypename(rstring);\n        rettype->print(rtypename);\n        std::map<uint64_t,std::string> localDecls;\n\n        if (decl != NULL) {\n            std::stringstream declarations(jl_string_data(decl));\n\n            // parse string line by line\n            std::string declstr;\n            while (std::getline(declarations, declstr, '\\n')) {\n                // Find name of declaration by searching for '@'\n                std::string::size_type atpos = declstr.find('@') + 1;\n                // Find end of declaration by searching for '('\n                std::string::size_type bracepos = declstr.find('(', atpos);\n                // Declaration name is the string between @ and (\n                std::string declname = declstr.substr(atpos, bracepos - atpos);\n\n                // Check if declaration already present in module\n                if(jl_Module->getNamedValue(declname) == NULL) {\n                    ir_stream << \"; Declarations\\n\" << declstr << \"\\n\";\n                }\n            }\n        }\n        ir_stream << \"; Number of arguments: \" << nargt << \"\\n\"\n        << \"define \"<<rtypename.str()<<\" @\\\"\" << ir_name << \"\\\"(\"<<argstream.str()<<\") {\\n\"\n        << jl_string_data(ir) << \"\\n}\";\n        SMDiagnostic Err = SMDiagnostic();\n        std::string ir_string = ir_stream.str();\n#ifdef LLVM36\n        Module *m = NULL;\n        bool failed = parseAssemblyInto(llvm::MemoryBufferRef(ir_string,\"llvmcall\"),*jl_Module,Err);\n        if (!failed)\n            m = jl_Module;\n#else\n        Module *m = ParseAssemblyString(ir_string.c_str(),jl_Module,Err,jl_LLVMContext);\n#endif\n        if (m == NULL) {\n            std::string message = \"Failed to parse LLVM Assembly: \\n\";\n            llvm::raw_string_ostream stream(message);\n            Err.print(\"julia\",stream,true);\n            jl_error(stream.str().c_str());\n        }\n        f = m->getFunction(ir_name);\n    }\n    else {\n        assert(isPtr);\n        // Create Function skeleton\n        f = (llvm::Function*)jl_unbox_voidpointer(ir);\n        assert(f->getReturnType() == rettype);\n        int i = 0;\n        for (std::vector<Type *>::iterator it = argtypes.begin();\n            it != argtypes.end(); ++it, ++i)\n            assert(*it == f->getFunctionType()->getParamType(i));\n\n#ifdef USE_MCJIT\n        if (f->getParent() != jl_Module) {\n            FunctionMover mover(jl_Module, f->getParent());\n            f = mover.CloneFunction(f);\n        }\n#endif\n\n        //f->dump();\n        #ifndef LLVM35\n        if (verifyFunction(*f,PrintMessageAction)) {\n        #else\n        llvm::raw_fd_ostream out(1,false);\n        if (verifyFunction(*f,&out)) {\n        #endif\n            f->dump();\n            jl_error(\"Malformed LLVM Function\");\n        }\n    }\n\n    /*\n     * It might be tempting to just try to set the Always inline attribute on the function\n     * and hope for the best. However, this doesn't work since that would require an inlining\n     * pass (which is a Call Graph pass and cannot be managed by a FunctionPassManager). Instead\n     * We are sneaky and call the inliner directly. This however doesn't work until we've actually\n     * generated the entire function, so we need to store it in the context until the end of the\n     * function. This also has the benefit of looking exactly like we cut/pasted it in in `code_llvm`.\n     */\n\n    // Since we dumped all of f's dependencies into the active module,\n    // we cannot reasonably inline it, so leave it there and just emit\n    // a regular call\n    if (!isString) {\n        static int llvmcallnumbering = 0;\n        std::stringstream name;\n        name << \"jl_llvmcall\" << llvmcallnumbering++;\n        f->setName(name.str());\n        f = cast<Function>(prepare_call(function_proto(f)));\n    }\n    else\n        f->setLinkage(GlobalValue::LinkOnceODRLinkage);\n\n    // the actual call\n    builder.CreateCall(prepare_call(gcroot_flush_func));\n    SmallVector<Value*, 16> gc_uses;\n    for (size_t i = 0; i < nargt; ++i) {\n        const jl_cgval_t &arg = argv[i];\n        push_gc_use(gc_uses, arg);\n    }\n    // Mark GC use before **and** after the llvmcall to make sure the arguments\n    // are alive during the llvmcall even if the llvmcall has `unreachable`.\n    // If the llvmcall generates GC safepoint, it might need to emit its own\n    // gckill.\n    mark_gc_uses(gc_uses);\n    CallInst *inst = builder.CreateCall(f, ArrayRef<Value*>(&argvals[0], nargt));\n    if (isString)\n        ctx->to_inline.push_back(inst);\n    mark_gc_uses(gc_uses);\n\n    JL_GC_POP();\n\n    if (inst->getType() != rettype) {\n        jl_error(\"Return type of llvmcall'ed function does not match declared return type\");\n    }\n\n    return mark_julia_type(inst, retboxed, rtt, ctx);\n}\n\n// --- code generator for ccall itself ---\n\nstatic jl_cgval_t mark_or_box_ccall_result(Value *result, bool isboxed, jl_value_t *rt_expr, jl_value_t *rt, bool static_rt, jl_codectx_t *ctx)\n{\n    if (!static_rt) {\n        // box if concrete type was not statically known\n        assert(rt == (jl_value_t*)jl_voidpointer_type);\n        Value *runtime_bt = boxed(emit_expr(rt_expr, ctx), ctx);\n        int nb = sizeof(void*);\n        // TODO: can this be tighter than tbaa_value?\n        return mark_julia_type(\n            init_bits_value(emit_allocobj(ctx, nb, runtime_bt), result, tbaa_value),\n            true, (jl_value_t*)jl_pointer_type, ctx);\n    }\n    return mark_julia_type(result, isboxed, rt, ctx);\n}\n\nstatic std::string generate_func_sig(\n        Type **lrt, // input parameter of the llvm return type (from julia_struct_to_llvm)\n        Type **prt, // out parameter of the llvm return type for the function signature\n        int &sret, // out parameter for indicating whether return value has been moved to the first argument position\n        std::vector<Type *> &fargt, // vector of llvm output types (julia_struct_to_llvm) for arguments (vararg is the last item, if applicable)\n        std::vector<bool> &fargt_isboxed, // vector of whether the llvm output types is boxed for each argument (vararg is the last item, if applicable)\n        std::vector<Type *> &fargt_sig, // vector of ABI coercion types for call signature\n        Type *&fargt_vasig, // ABI coercion type for vararg list\n        std::vector<bool> &inRegList, // vector of \"inreg\" parameters (vararg is the last item, if applicable)\n        std::vector<bool> &byRefList, // vector of \"byref\" parameters (vararg is the last item, if applicable)\n        AttributeSet &attributes, // vector of function call site attributes (vararg is the last item, if applicable)\n        jl_value_t *rt, // julia return type\n        jl_svec_t *tt, // tuple of julia argument types\n        size_t nargs) // number of actual arguments (can be different from the size of tt when varargs)\n{\n    size_t nargt = jl_svec_len(tt);\n    assert(rt && !jl_is_abstract_ref_type(rt));\n\n    std::vector<AttrBuilder> paramattrs;\n    AbiState abi = default_abi_state;\n    sret = 0;\n\n    if (type_is_ghost(*lrt)) {\n        *prt = *lrt = T_void;\n    }\n    else {\n        if (!jl_is_datatype(rt) || ((jl_datatype_t*)rt)->layout == NULL || jl_is_cpointer_type(rt) || jl_is_array_type(rt)) {\n            *prt = *lrt; // passed as pointer\n        }\n        else if (use_sret(&abi, (jl_datatype_t*)rt)) {\n            paramattrs.push_back(AttrBuilder());\n            paramattrs[0].clear();\n#if !defined(_OS_WINDOWS_) || defined(LLVM35) // llvm used to use the old mingw ABI, skipping this marking works around that difference\n            paramattrs[0].addAttribute(Attribute::StructRet);\n#endif\n            paramattrs[0].addAttribute(Attribute::NoAlias);\n            fargt_sig.push_back(PointerType::get(*lrt, 0));\n            sret = 1;\n            *prt = *lrt;\n        }\n        else {\n            *prt = preferred_llvm_type((jl_datatype_t*)rt, true);\n            if (*prt == NULL)\n                *prt = *lrt;\n        }\n    }\n\n    size_t i;\n    bool current_isVa = false;\n    for(i = 0; i < nargt;) {\n        jl_value_t *tti = jl_svecref(tt,i);\n        if (jl_is_vararg_type(tti)) {\n            current_isVa = true;\n            tti = jl_tparam0(tti);\n        }\n        Type *t = NULL;\n        bool isboxed;\n        Attribute::AttrKind av = Attribute::None;\n        if (jl_is_abstract_ref_type(tti)) {\n            if (jl_is_typevar(jl_tparam0(tti)))\n                jl_error(\"ccall: argument type Ref should have an element type, not Ref{T}\");\n            tti = (jl_value_t*)jl_voidpointer_type;\n            t = T_pint8;\n            isboxed = false;\n        }\n        else {\n            if (jl_is_cpointer_type(tti) && jl_is_typevar(jl_tparam0(tti)))\n                jl_error(\"ccall: argument type Ptr should have an element type, not Ptr{T}\");\n            if (jl_is_bitstype(tti)) {\n                // see pull req #978. need to annotate signext/zeroext for\n                // small integer arguments.\n                jl_datatype_t *bt = (jl_datatype_t*)tti;\n                if (bt->size < 4) {\n                    if (jl_signed_type && jl_subtype(tti, (jl_value_t*)jl_signed_type, 0))\n                        av = Attribute::SExt;\n                    else\n                        av = Attribute::ZExt;\n                }\n            }\n\n            t = julia_struct_to_llvm(tti, &isboxed);\n            if (t == NULL || t == T_void) {\n                std::stringstream msg;\n                msg << \"ccall: the type of argument \";\n                msg << i+1;\n                msg << \" doesn't correspond to a C type\";\n                return msg.str();\n            }\n        }\n\n        // Whether or not LLVM wants us to emit a pointer to the data\n        bool byRef = false;\n\n        // Whether or not to pass this in registers\n        bool inReg = false;\n\n        Type *pat;\n        if (!jl_is_datatype(tti) || ((jl_datatype_t*)tti)->layout == NULL || jl_is_array_type(tti))\n            tti = (jl_value_t*)jl_voidpointer_type; // passed as pointer\n\n        needPassByRef(&abi, (jl_datatype_t*)tti, &byRef, &inReg);\n        if (jl_is_cpointer_type(tti)) {\n            pat = t;\n        }\n        else if (byRef) {\n            pat = PointerType::get(t, 0);\n        }\n        else {\n            pat = preferred_llvm_type((jl_datatype_t*)tti, false);\n            if (pat == NULL)\n                pat = t;\n        }\n\n        byRefList.push_back(byRef);\n        inRegList.push_back(inReg);\n        fargt.push_back(t);\n        fargt_isboxed.push_back(isboxed);\n        if (!current_isVa)\n            fargt_sig.push_back(pat);\n        else\n            fargt_vasig = pat;\n\n        do { // for each arg for which this type applies, add the appropriate LLVM parameter attributes\n            if (i < nargs) { // if vararg, the last declared arg type may not have a corresponding arg value\n                paramattrs.push_back(AttrBuilder());\n                // Note that even though the LLVM argument is called ByVal\n                // this really means that the thing we're passing is pointing to\n                // the thing we want to pass by value\n#ifndef _CPU_AARCH64_\n                // the aarch64 backend seems to interpret ByVal as\n                // implicitly passed on stack.\n                if (byRef)\n                    paramattrs[i + sret].addAttribute(Attribute::ByVal);\n#endif\n                if (inReg)\n                    paramattrs[i + sret].addAttribute(Attribute::InReg);\n                if (av != Attribute::None)\n                    paramattrs[i + sret].addAttribute(av);\n            }\n            i++;\n        } while (current_isVa && i < nargs); // if is this is the vararg, loop to the end\n    }\n\n    for (i = 0; i < nargs + sret; ++i) {\n        if (paramattrs[i].hasAttributes()) {\n            attributes = attributes.addAttributes(jl_LLVMContext, i + 1,\n                                                  AttributeSet::get(jl_LLVMContext, i + 1, paramattrs[i]));\n        }\n    }\n    if (rt == jl_bottom_type)\n        attributes = attributes.addAttribute(jl_LLVMContext,\n                                             AttributeSet::FunctionIndex,\n                                             Attribute::NoReturn);\n    return \"\";\n}\n\n\n// ccall(pointer, rettype, (argtypes...), args...)\nstatic jl_cgval_t emit_ccall(jl_value_t **args, size_t nargs, jl_codectx_t *ctx)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    JL_NARGSV(ccall, 3);\n    jl_value_t *rt=NULL, *at=NULL;\n    JL_GC_PUSH2(&rt, &at);\n\n    native_sym_arg_t symarg = interpret_symbol_arg(args[1], ctx, \"ccall\");\n    Value *jl_ptr=NULL;\n    void (*fptr)(void) = NULL;\n    const char *f_name = NULL, *f_lib = NULL;\n    jl_ptr = symarg.jl_ptr;\n    fptr = symarg.fptr;\n    f_name = symarg.f_name;\n    f_lib = symarg.f_lib;\n    bool isVa = false;\n\n    if (f_name == NULL && fptr == NULL && jl_ptr == NULL) {\n        emit_error(\"ccall: null function pointer\", ctx);\n        JL_GC_POP();\n        return jl_cgval_t();\n    }\n\n    jl_value_t *rtt_ = expr_type(args[2], ctx);\n    bool static_rt = true;  // is return type fully statically known?\n    if (jl_is_type_type(rtt_) && jl_is_leaf_type(jl_tparam0(rtt_))) {\n        rt = jl_tparam0(rtt_);\n    }\n    else {\n        rt = try_eval(args[2], ctx, NULL);\n        if (rt == NULL) {\n            static_rt = false;\n            if (jl_is_type_type(rtt_)) {\n                if (jl_subtype(jl_tparam0(rtt_), (jl_value_t*)jl_pointer_type, 0)) {\n                    // substitute Ptr{Void} for statically-unknown pointer type\n                    rt = (jl_value_t*)jl_voidpointer_type;\n                }\n                else if (jl_subtype(jl_tparam0(rtt_), (jl_value_t*)jl_array_type, 0)) {\n                    // `Array` used as return type just returns a julia object reference\n                    rt = (jl_value_t*)jl_any_type;\n                    static_rt = true;\n                }\n                else if (jl_is_typevar(jl_tparam0(rtt_)) && jl_is_abstract_ref_type(((jl_tvar_t*)jl_tparam0(rtt_))->ub)) {\n                    // `Ref{T}` used as return type just returns T (from a jl_value_t*)\n                    rt = (jl_value_t*)jl_any_type;\n                    static_rt = true;\n                }\n            }\n            if (rt == NULL) {\n                if (jl_is_expr(args[2])) {\n                    jl_expr_t *rtexpr = (jl_expr_t*)args[2];\n                    if (rtexpr->head == call_sym && jl_expr_nargs(rtexpr) == 4 &&\n                        static_eval(jl_exprarg(rtexpr, 0), ctx, true, false) == jl_builtin_apply_type &&\n                        static_eval(jl_exprarg(rtexpr, 1), ctx, true, false) == (jl_value_t*)jl_array_type) {\n                        // `Array` used as return type just returns a julia object reference\n                        rt = (jl_value_t*)jl_any_type;\n                        static_rt = true;\n                    }\n                    else if (rtexpr->head == call_sym && jl_expr_nargs(rtexpr) == 3 &&\n                             static_eval(jl_exprarg(rtexpr, 0), ctx, true, false) == jl_builtin_apply_type &&\n                             static_eval(jl_exprarg(rtexpr, 1), ctx, true, false) == (jl_value_t*)jl_pointer_type) {\n                        // substitute Ptr{Void} for statically-unknown pointer type\n                        rt = (jl_value_t*)jl_voidpointer_type;\n                    }\n                    else if (rtexpr->head == call_sym && jl_expr_nargs(rtexpr) == 3 &&\n                             static_eval(jl_exprarg(rtexpr, 0), ctx, true, false) == jl_builtin_apply_type &&\n                             static_eval(jl_exprarg(rtexpr, 1), ctx, true, false) == (jl_value_t*)jl_ref_type) {\n                        // `Ref{T}` used as return type just returns T (from a jl_value_t*)\n                        rt = (jl_value_t*)jl_any_type;\n                        static_rt = true;\n                    }\n                }\n            }\n            if (rt == NULL) {\n                if (ptls->exception_in_transit &&\n                    jl_typeis(ptls->exception_in_transit,\n                              jl_undefvarerror_type) &&\n                    jl_is_symbol(args[2])) {\n                    std::string msg = \"ccall return type undefined: \" +\n                                      std::string(jl_symbol_name((jl_sym_t*)args[2]));\n                    emit_error(msg.c_str(), ctx);\n                    JL_GC_POP();\n                    return jl_cgval_t();\n                }\n                emit_error(\"error interpreting ccall return type\", ctx);\n                JL_GC_POP();\n                return jl_cgval_t();\n            }\n        }\n    }\n\n    if (jl_is_svec(rt)) {\n        std::string msg = \"in \" + ctx->funcName +\n            \": ccall: missing return type\";\n        jl_error(msg.c_str());\n    }\n    if (jl_is_cpointer_type(rt) && jl_is_typevar(jl_tparam0(rt)))\n        jl_error(\"ccall: return type Ptr should have an element type, not Ptr{_<:T}\");\n\n    if (jl_is_abstract_ref_type(rt)) {\n        if (jl_tparam0(rt) == (jl_value_t*)jl_any_type)\n            jl_error(\"ccall: return type Ref{Any} is invalid. use Ptr{Any} instead.\");\n        rt = (jl_value_t*)jl_any_type; // convert return type to jl_value_t*\n    }\n\n    if (jl_is_array_type(rt)) {\n        // `Array` used as return type just returns a julia object reference\n        rt = (jl_value_t*)jl_any_type;\n    }\n\n    JL_TYPECHK(ccall, type, rt);\n    bool retboxed;\n    Type *lrt = julia_struct_to_llvm(rt, &retboxed);\n    if (lrt == NULL) {\n        emit_error(\"ccall: return type doesn't correspond to a C type\", ctx);\n        JL_GC_POP();\n        return jl_cgval_t();\n    }\n\n    at = try_eval(args[3], ctx, \"error interpreting ccall argument tuple\");\n    if (at == NULL) {\n        JL_GC_POP();\n        return jl_cgval_t();\n    }\n\n    JL_TYPECHK(ccall, simplevector, at);\n    //JL_TYPECHK(ccall, type, at);\n    jl_svec_t *tt = (jl_svec_t*)at;\n\n    // check for calling convention specifier\n    CallingConv::ID cc = CallingConv::C;\n    jl_value_t *last = args[nargs];\n    if (jl_is_expr(last)) {\n        jl_sym_t *lhd = ((jl_expr_t*)last)->head;\n        if (lhd == jl_symbol(\"stdcall\")) {\n            cc = CallingConv::X86_StdCall;\n            nargs--;\n        }\n        else if (lhd == jl_symbol(\"cdecl\")) {\n            cc = CallingConv::C;\n            nargs--;\n        }\n        else if (lhd == jl_symbol(\"fastcall\")) {\n            cc = CallingConv::X86_FastCall;\n            nargs--;\n        }\n        else if (lhd == jl_symbol(\"thiscall\")) {\n            cc = CallingConv::X86_ThisCall;\n            nargs--;\n        }\n    }\n\n    // some sanity checking and check whether there's a vararg\n    size_t i;\n    size_t nargt = jl_svec_len(tt);\n    for(i=0; i < nargt; i++) {\n        jl_value_t *tti = jl_svecref(tt,i);\n        if (jl_is_cpointer_type(tti) && jl_is_typevar(jl_tparam0(tti))) {\n            JL_GC_POP();\n            emit_error(\"ccall: argument type Ptr should have an element type, Ptr{T}\",ctx);\n            return jl_cgval_t();\n        }\n        if (jl_is_vararg_type(tti))\n            isVa = true;\n    }\n\n    if ((!isVa && nargt  != (nargs - 2)/2) ||\n        ( isVa && nargt-1 > (nargs - 2)/2))\n        jl_error(\"ccall: wrong number of arguments to C function\");\n\n    // some special functions\n    if (fptr == (void(*)(void))&jl_array_ptr ||\n        ((f_lib==NULL || (intptr_t)f_lib==2)\n         && f_name && !strcmp(f_name,\"jl_array_ptr\"))) {\n        assert(lrt->isPointerTy());\n        assert(!isVa);\n        assert(nargt==1);\n        jl_value_t *argi = args[4];\n        assert(!(jl_is_expr(argi) && ((jl_expr_t*)argi)->head == amp_sym));\n        jl_cgval_t ary = emit_expr(argi, ctx);\n        JL_GC_POP();\n        return mark_or_box_ccall_result(emit_bitcast(emit_arrayptr(ary, ctx), lrt),\n                                        retboxed, args[2], rt, static_rt, ctx);\n    }\n    if (fptr == (void(*)(void))&jl_value_ptr ||\n        ((f_lib==NULL || (intptr_t)f_lib==2)\n         && f_name && !strcmp(f_name,\"jl_value_ptr\"))) {\n        assert(lrt->isPointerTy());\n        assert(!isVa);\n        assert(nargt==1);\n        jl_value_t *argi = args[4];\n        bool addressOf = false;\n        jl_value_t *tti = jl_svecref(tt,0);\n        if (jl_is_expr(argi) && ((jl_expr_t*)argi)->head == amp_sym) {\n            addressOf = true;\n            argi = jl_exprarg(argi,0);\n        }\n        else if (jl_is_abstract_ref_type(tti)) {\n            tti = (jl_value_t*)jl_voidpointer_type;\n        }\n        Value *ary;\n        Type *largty;\n        bool isboxed;\n        if (addressOf) {\n            largty = T_pjlvalue;\n            isboxed = true;\n        }\n        else {\n            largty = julia_struct_to_llvm(tti, &isboxed);\n        }\n        if (isboxed) {\n            ary = boxed(emit_expr(argi, ctx), ctx);\n        }\n        else {\n            assert(!addressOf);\n            ary = emit_unbox(largty, emit_expr(argi, ctx), tti);\n        }\n        JL_GC_POP();\n        return mark_or_box_ccall_result(emit_bitcast(ary, lrt),\n                                        retboxed, args[2], rt, static_rt, ctx);\n    }\n    if (JL_CPU_WAKE_NOOP &&\n        (fptr == &jl_cpu_wake || ((!f_lib || (intptr_t)f_lib == 2) &&\n                                  f_name && !strcmp(f_name, \"jl_cpu_wake\")))) {\n        assert(lrt == T_void);\n        assert(!isVa);\n        assert(nargt == 0);\n        JL_GC_POP();\n        return ghostValue(jl_void_type);\n    }\n    if (fptr == &jl_gc_safepoint ||\n        ((!f_lib || (intptr_t)f_lib == 2) && f_name &&\n         strcmp(f_name, \"jl_gc_safepoint\") == 0)) {\n        assert(lrt == T_void);\n        assert(!isVa);\n        assert(nargt == 0);\n        JL_GC_POP();\n        builder.CreateCall(prepare_call(gcroot_flush_func));\n        emit_signal_fence();\n        builder.CreateLoad(ctx->signalPage, true);\n        emit_signal_fence();\n        return ghostValue(jl_void_type);\n    }\n#ifdef _OS_LINUX_\n    // directly access the address of a ifunc can cause linker issue on\n    // some configurations (e.g. AArch64 + -Bsymbolic-functions).\n    static const auto ptls_getter = jl_dlsym_e(jl_dlopen(nullptr, 0),\n                                               \"jl_get_ptls_states\");\n#else\n    static const auto ptls_getter = &jl_get_ptls_states;\n#endif\n    if (fptr == (void(*)(void))(uintptr_t)ptls_getter ||\n        ((!f_lib || (intptr_t)f_lib == 2) && f_name &&\n         strcmp(f_name, \"jl_get_ptls_states\") == 0)) {\n        assert(lrt == T_pint8);\n        assert(!isVa);\n        assert(nargt == 0);\n        JL_GC_POP();\n        return mark_or_box_ccall_result(\n            emit_bitcast(ctx->ptlsStates, lrt),\n            retboxed, args[2], rt, static_rt, ctx);\n    }\n    if (fptr == &jl_sigatomic_begin ||\n        ((!f_lib || (intptr_t)f_lib == 2) && f_name &&\n         strcmp(f_name, \"jl_sigatomic_begin\") == 0)) {\n        assert(lrt == T_void);\n        assert(!isVa);\n        assert(nargt == 0);\n        JL_GC_POP();\n        builder.CreateCall(prepare_call(gcroot_flush_func));\n        Value *pdefer_sig = emit_defer_signal(ctx);\n        Value *defer_sig = builder.CreateLoad(pdefer_sig);\n        defer_sig = builder.CreateAdd(defer_sig,\n                                      ConstantInt::get(T_sigatomic, 1));\n        builder.CreateStore(defer_sig, pdefer_sig);\n        emit_signal_fence();\n        return ghostValue(jl_void_type);\n    }\n    if (fptr == &jl_sigatomic_end ||\n        ((!f_lib || (intptr_t)f_lib == 2) && f_name &&\n         strcmp(f_name, \"jl_sigatomic_end\") == 0)) {\n        assert(lrt == T_void);\n        assert(!isVa);\n        assert(nargt == 0);\n        JL_GC_POP();\n        builder.CreateCall(prepare_call(gcroot_flush_func));\n        Value *pdefer_sig = emit_defer_signal(ctx);\n        Value *defer_sig = builder.CreateLoad(pdefer_sig);\n        emit_signal_fence();\n        error_unless(builder.CreateICmpNE(defer_sig,\n                                          ConstantInt::get(T_sigatomic, 0)),\n                     \"sigatomic_end called in non-sigatomic region\", ctx);\n        defer_sig = builder.CreateSub(defer_sig,\n                                      ConstantInt::get(T_sigatomic, 1));\n        builder.CreateStore(defer_sig, pdefer_sig);\n        BasicBlock *checkBB = BasicBlock::Create(jl_LLVMContext, \"check\",\n                                                 ctx->f);\n        BasicBlock *contBB = BasicBlock::Create(jl_LLVMContext, \"cont\");\n        builder.CreateCondBr(\n            builder.CreateICmpEQ(defer_sig, ConstantInt::get(T_sigatomic, 0)),\n            checkBB, contBB);\n        builder.SetInsertPoint(checkBB);\n        builder.CreateLoad(builder.CreateConstGEP1_32(ctx->signalPage, -1),\n                           true);\n        builder.CreateBr(contBB);\n        ctx->f->getBasicBlockList().push_back(contBB);\n        builder.SetInsertPoint(contBB);\n        return ghostValue(jl_void_type);\n    }\n    if (fptr == (void(*)(void))&jl_is_leaf_type ||\n        ((f_lib==NULL || (intptr_t)f_lib==2)\n         && f_name && !strcmp(f_name, \"jl_is_leaf_type\"))) {\n        assert(nargt == 1);\n        jl_value_t *arg = args[4];\n        jl_value_t *ty = expr_type(arg, ctx);\n        if (jl_is_type_type(ty) && !jl_is_typevar(jl_tparam0(ty))) {\n            int isleaf = jl_is_leaf_type(jl_tparam0(ty));\n            JL_GC_POP();\n            return mark_or_box_ccall_result(ConstantInt::get(T_int32, isleaf),\n                    false, args[2], rt, static_rt, ctx);\n        }\n    }\n    if (fptr == (void(*)(void))&jl_function_ptr ||\n        ((f_lib==NULL || (intptr_t)f_lib==2)\n         && f_name && !strcmp(f_name, \"jl_function_ptr\"))) {\n        assert(nargt == 3);\n        jl_value_t *f = static_eval(args[4], ctx, false, false);\n        jl_value_t *frt = expr_type(args[6], ctx);\n        if (f && (jl_is_type_type((jl_value_t*)frt) && !jl_has_typevars(jl_tparam0(frt)))) {\n            jl_value_t *fargt = static_eval(args[8], ctx, true, true);\n            if (fargt) {\n                if (jl_is_tuple(fargt)) {\n                    // TODO: maybe deprecation warning, better checking\n                    fargt = (jl_value_t*)jl_apply_tuple_type_v((jl_value_t**)jl_data_ptr(fargt), jl_nfields(fargt));\n                }\n            }\n            else {\n                fargt = expr_type(args[8], ctx);\n                if (jl_is_type_type((jl_value_t*)fargt))\n                    fargt = jl_tparam0(fargt);\n            }\n            if (jl_is_tuple_type(fargt) && jl_is_leaf_type(fargt)) {\n                frt = jl_tparam0(frt);\n                Value *llvmf = NULL;\n                JL_TRY {\n                    llvmf = jl_cfunction_object((jl_function_t*)f, frt, (jl_tupletype_t*)fargt);\n                }\n                JL_CATCH {\n                    llvmf = NULL;\n                }\n                if (llvmf) {\n                    llvmf = prepare_call(llvmf);\n                    // make sure to emit any side-effects that may have been part of the original expression\n                    emit_expr(args[4], ctx);\n                    emit_expr(args[6], ctx);\n                    emit_expr(args[8], ctx);\n                    JL_GC_POP();\n                    return mark_or_box_ccall_result(emit_bitcast(llvmf, lrt),\n                                                    retboxed, args[2], rt, static_rt, ctx);\n                }\n            }\n        }\n    }\n\n    // save place before arguments, for possible insertion of temp arg\n    // area saving code.\n    Value *stacksave=NULL;\n    BasicBlock::InstListType &instList = builder.GetInsertBlock()->getInstList();\n    Instruction *savespot;\n    if (instList.empty()) {\n        savespot = NULL;\n    }\n    else {\n        // hey C++, there's this thing called pointers...\n        Instruction &_savespot = builder.GetInsertBlock()->back();\n        savespot = &_savespot;\n    }\n\n    std::vector<Type*> fargt(0);\n    std::vector<Type*> fargt_sig(0);\n    std::vector<bool> fargt_isboxed(0);\n    Type *fargt_vasig = NULL;\n    std::vector<bool> inRegList(0);\n    std::vector<bool> byRefList(0);\n    AttributeSet attrs;\n    Type *prt = NULL;\n    int sret = 0;\n    std::string err_msg = generate_func_sig(&lrt, &prt, sret, fargt, fargt_isboxed, fargt_sig, fargt_vasig,\n                                            inRegList, byRefList, attrs, rt, tt, (nargs - 3)/2);\n    if (!err_msg.empty()) {\n        JL_GC_POP();\n        emit_error(err_msg,ctx);\n        return jl_cgval_t();\n    }\n\n    // emit arguments\n    Value **argvals = (Value**) alloca(((nargs - 3) / 2 + sret) * sizeof(Value*));\n    Value *result = NULL;\n    bool needStackRestore = false;\n\n    // First, if the ABI requires us to provide the space for the return\n    // argument, allocate the box and store that as the first argument type\n    bool sretboxed = false;\n    if (sret) {\n        jl_cgval_t sret_val = emit_new_struct(rt,1,NULL,ctx); // TODO: is it valid to be creating an incomplete type this way?\n        assert(sret_val.typ != NULL && \"Type was not concrete\");\n        if (!sret_val.ispointer()) {\n            Value *mem = emit_static_alloca(lrt, ctx);\n            builder.CreateStore(sret_val.V, mem);\n            result = mem;\n        }\n        else {\n            // XXX: result needs a GC root here if result->getType() == T_pjlvalue\n            result = sret_val.V;\n        }\n        argvals[0] = emit_bitcast(result, fargt_sig.at(0));\n        sretboxed = sret_val.isboxed;\n    }\n\n    // number of parameters to the c function\n    jl_cgval_t *argv = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * (nargs - 3)/2);\n    for(i = 4; i < nargs + 1; i += 2) {\n        // Current C function parameter\n        size_t ai = (i - 4) / 2;\n\n        // Julia (expression) value of current parameter\n        jl_value_t *argi = args[i];\n\n        // pass the address of the argument rather than the argument itself\n        bool addressOf = false;\n        if (jl_is_expr(argi) && ((jl_expr_t*)argi)->head == amp_sym) {\n            addressOf = true;\n            argi = jl_exprarg(argi,0);\n        }\n\n        Type *largty; // LLVM type of the current parameter\n        bool toboxed;\n        jl_value_t *jargty; // Julia type of the current parameter\n        bool byRef, inReg; // Argument attributes\n        if (isVa && ai >= nargt - 1) {\n            largty = fargt.at(nargt - 1);\n            toboxed = fargt_isboxed.at(nargt - 1);\n            jargty = jl_tparam0(jl_svecref(tt, nargt - 1));\n            byRef = byRefList.at(nargt - 1);\n            inReg = inRegList.at(nargt - 1);\n        }\n        else {\n            largty = fargt.at(ai);\n            toboxed = fargt_isboxed.at(ai);\n            jargty = jl_svecref(tt, ai);\n            byRef = byRefList.at(ai);\n            inReg = inRegList.at(ai);\n        }\n\n        jl_cgval_t &arg = argv[ai];\n        arg = emit_expr((jl_value_t*)argi, ctx);\n        if (jl_is_abstract_ref_type(jargty)) {\n            if (addressOf) {\n                JL_GC_POP();\n                emit_error(\"ccall: & on a Ref{T} argument is invalid\", ctx);\n                return jl_cgval_t();\n            }\n            if (!jl_is_cpointer_type(arg.typ)) {\n                emit_cpointercheck(arg, \"ccall: argument to Ref{T} is not a pointer\", ctx);\n                arg.typ = (jl_value_t*)jl_voidpointer_type;\n                arg.isboxed = false;\n            }\n            jargty = (jl_value_t*)jl_voidpointer_type;\n        }\n\n        Value *v = julia_to_native(largty, toboxed, jargty, arg, addressOf, byRef, inReg,\n                    need_private_copy(jargty, byRef), false, ai + 1, ctx, &needStackRestore);\n        bool issigned = jl_signed_type && jl_subtype(jargty, (jl_value_t*)jl_signed_type, 0);\n        argvals[ai + sret] = llvm_type_rewrite(v, largty,\n                ai + sret < fargt_sig.size() ? fargt_sig.at(ai + sret) : fargt_vasig,\n                false, byRef, issigned, ctx);\n    }\n\n\n    // make LLVM function object for the target\n    // keep this close to the function call, so that the compiler can\n    // optimize the global pointer load in the common case\n    Value *llvmf;\n    FunctionType *functype = FunctionType::get(sret ? T_void : prt, fargt_sig, isVa);\n\n    if (jl_ptr != NULL) {\n        null_pointer_check(jl_ptr,ctx);\n        Type *funcptype = PointerType::get(functype,0);\n        llvmf = builder.CreateIntToPtr(jl_ptr, funcptype);\n    }\n    else if (fptr != NULL) {\n        Type *funcptype = PointerType::get(functype,0);\n        llvmf = literal_static_pointer_val((void*)(uintptr_t)fptr, funcptype);\n        if (imaging_mode)\n            jl_printf(JL_STDERR,\"WARNING: literal address used in ccall for %s; code cannot be statically compiled\\n\", f_name);\n    }\n    else {\n        assert(f_name != NULL);\n\n        PointerType *funcptype = PointerType::get(functype,0);\n        if (imaging_mode) {\n            // vararg requires musttail,\n            // but musttail is incompatible with noreturn.\n            if (functype->isVarArg())\n                llvmf = runtime_sym_lookup(funcptype, f_lib, f_name, ctx->f);\n            else\n                llvmf = emit_plt(functype, attrs, cc, f_lib, f_name);\n        }\n        else {\n            void *symaddr = jl_dlsym_e(jl_get_library(f_lib), f_name);\n            if (symaddr == NULL) {\n                JL_GC_POP();\n                std::stringstream msg;\n                msg << \"ccall: could not find function \";\n                msg << f_name;\n                if (f_lib != NULL) {\n#ifdef _OS_WINDOWS_\n                    assert((intptr_t)f_lib != 1 && (intptr_t)f_lib != 2);\n#endif\n                    msg << \" in library \";\n                    msg << f_lib;\n                }\n                emit_error(msg.str(), ctx);\n                return jl_cgval_t();\n            }\n            // since we aren't saving this code, there's no sense in\n            // putting anything complicated here: just JIT the function address\n            llvmf = literal_static_pointer_val(symaddr, funcptype);\n        }\n    }\n\n    if (needStackRestore) {\n        stacksave = CallInst::Create(Intrinsic::getDeclaration(jl_Module,\n                                                               Intrinsic::stacksave));\n        if (savespot) {\n#ifdef LLVM38\n                instList.insertAfter(savespot->getIterator(), (Instruction*)stacksave);\n#else\n                instList.insertAfter((Instruction*)savespot, (Instruction*)stacksave);\n#endif\n        }\n        else\n            instList.push_front((Instruction*)stacksave);\n    }\n\n    //llvmf->dump();\n    //for (int i = 0; i < (nargs - 3) / 2 + sret; ++i)\n    //    argvals[i]->dump();\n\n    // Mark GC use before **and** after the ccall to make sure the arguments\n    // are alive during the ccall even if the function called is `noreturn`.\n    SmallVector<Value*, 16> gc_uses;\n    for(i = 4; i < nargs + 1; i += 2) {\n        // Current C function parameter\n        size_t ai = (i - 4) / 2;\n        push_gc_use(gc_uses, argv[ai]);\n\n        // Julia (expression) value of current parameter gcroot\n        jl_value_t *argi = args[i + 1];\n        if (jl_is_long(argi)) continue;\n        jl_cgval_t arg = emit_expr(argi, ctx);\n        push_gc_use(gc_uses, arg);\n    }\n    mark_gc_uses(gc_uses);\n    // the actual call\n    Value *ret = builder.CreateCall(prepare_call(llvmf),\n                                    ArrayRef<Value*>(&argvals[0], (nargs - 3) / 2 + sret));\n    ((CallInst*)ret)->setAttributes(attrs);\n\n    if (cc != CallingConv::C)\n        ((CallInst*)ret)->setCallingConv(cc);\n    if (!sret)\n        result = ret;\n    if (needStackRestore) {\n        assert(stacksave != NULL);\n        builder.CreateCall(Intrinsic::getDeclaration(jl_Module, Intrinsic::stackrestore), stacksave);\n    }\n    if (0) { // Enable this to turn on SSPREQ (-fstack-protector) on the function containing this ccall\n        ctx->f->addFnAttr(Attribute::StackProtectReq);\n    }\n\n    mark_gc_uses(gc_uses);\n    JL_GC_POP();\n    if (rt == jl_bottom_type) {\n        // Do this after we marked all the GC uses.\n        CreateTrap(builder);\n    }\n    // Finally we need to box the result into julia type\n    // However, if we have already created a box for the return\n    // type because the ABI required us to pass a pointer (sret),\n    // then we do not need to do this.\n    if (!sret) {\n        Type *jlrt = julia_type_to_llvm(rt, &retboxed); // compute the real \"julian\" return type and update retboxed\n        if (type_is_ghost(jlrt)) {\n            return ghostValue(rt);\n        }\n        else if (lrt->isStructTy() && retboxed) {\n            assert(jl_is_structtype(rt));\n            jl_cgval_t newst = emit_new_struct(rt, 1, NULL, ctx); // emit a new, empty struct\n            assert(newst.typ != NULL && \"Type was not concrete\");\n            assert(newst.isboxed);\n            size_t rtsz = jl_datatype_size(rt);\n            assert(rtsz > 0);\n            int boxalign = jl_gc_alignment(rtsz);\n#ifndef NDEBUG\n#ifdef LLVM36\n            const DataLayout &DL = jl_ExecutionEngine->getDataLayout();\n#else\n            const DataLayout &DL = *jl_ExecutionEngine->getDataLayout();\n#endif\n            // ARM and AArch64 can use a LLVM type larger than the julia\n            // type. However, the LLVM type size should be no larger than\n            // the GC allocation size. (multiple of `sizeof(void*)`)\n            assert(DL.getTypeStoreSize(lrt) <= LLT_ALIGN(jl_datatype_size(rt),\n                                                         boxalign));\n#endif\n            // copy the data from the return value to the new struct\n            tbaa_decorate(newst.tbaa, builder.CreateAlignedStore(result, emit_bitcast(newst.V, prt->getPointerTo()), boxalign));\n            return newst;\n        }\n        else if (jlrt != prt) {\n            assert(lrt == jlrt); // jl_struct_to_llvm and julia_type_to_llvm should only differ for concrete types, per the case above\n            result = llvm_type_rewrite(result, prt, jlrt, true, false, false, ctx);\n        }\n    }\n    else {\n        retboxed = sretboxed;\n        if (!retboxed)\n            result = builder.CreateLoad(result); // something alloca'd above\n    }\n\n    return mark_or_box_ccall_result(result, retboxed, args[2], rt, static_rt, ctx);\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/flisp/print.c": "extern void *memrchr(const void *s, int c, size_t n);\n\nstatic void outc(fl_context_t *fl_ctx, char c, ios_t *f)\n{\n    ios_putc(c, f);\n    if (c == '\\n')\n        fl_ctx->HPOS = 0;\n    else\n        fl_ctx->HPOS++;\n}\nstatic void outs(fl_context_t *fl_ctx, const char *s, ios_t *f)\n{\n    ios_puts(s, f);\n    fl_ctx->HPOS += u8_strwidth(s);\n}\nstatic void outsn(fl_context_t *fl_ctx, const char *s, ios_t *f, size_t n)\n{\n    ios_write(f, s, n);\n    fl_ctx->HPOS += u8_strwidth(s);\n}\nstatic int outindent(fl_context_t *fl_ctx, int n, ios_t *f)\n{\n    // move back to left margin if we get too indented\n    if (n > fl_ctx->SCR_WIDTH-12)\n        n = 2;\n    int n0 = n;\n    ios_putc('\\n', f);\n    fl_ctx->VPOS++;\n    fl_ctx->HPOS = n;\n    while (n >= 8) {\n        ios_putc('\\t', f);\n        n -= 8;\n    }\n    while (n) {\n        ios_putc(' ', f);\n        n--;\n    }\n    return n0;\n}\n\nvoid fl_print_chr(fl_context_t *fl_ctx, char c, ios_t *f)\n{\n    outc(fl_ctx, c, f);\n}\n\nvoid fl_print_str(fl_context_t *fl_ctx, const char *s, ios_t *f)\n{\n    outs(fl_ctx, s, f);\n}\n\nvoid print_traverse(fl_context_t *fl_ctx, value_t v)\n{\n    value_t *bp;\n    while (iscons(v)) {\n        if (ismarked(fl_ctx, v)) {\n            bp = (value_t*)ptrhash_bp(&fl_ctx->printconses, (void*)v);\n            if (*bp == (value_t)HT_NOTFOUND)\n                *bp = fixnum(fl_ctx->printlabel++);\n            return;\n        }\n        mark_cons(fl_ctx, v);\n        print_traverse(fl_ctx, car_(v));\n        v = cdr_(v);\n    }\n    if (!ismanaged(fl_ctx, v) || issymbol(v))\n        return;\n    if (ismarked(fl_ctx, v)) {\n        bp = (value_t*)ptrhash_bp(&fl_ctx->printconses, (void*)v);\n        if (*bp == (value_t)HT_NOTFOUND)\n            *bp = fixnum(fl_ctx->printlabel++);\n        return;\n    }\n    if (isvector(v)) {\n        if (vector_size(v) > 0)\n            mark_cons(fl_ctx, v);\n        unsigned int i;\n        for(i=0; i < vector_size(v); i++)\n            print_traverse(fl_ctx, vector_elt(v,i));\n    }\n    else if (iscprim(v)) {\n        mark_cons(fl_ctx, v);\n    }\n    else if (isclosure(v)) {\n        mark_cons(fl_ctx, v);\n        function_t *f = (function_t*)ptr(v);\n        print_traverse(fl_ctx, f->bcode);\n        print_traverse(fl_ctx, f->vals);\n        print_traverse(fl_ctx, f->env);\n    }\n    else {\n        assert(iscvalue(v));\n        cvalue_t *cv = (cvalue_t*)ptr(v);\n        // don't consider shared references to \"\"\n        if (!cv_isstr(fl_ctx, cv) || cv_len(cv)!=0)\n            mark_cons(fl_ctx, v);\n        fltype_t *t = cv_class(cv);\n        if (t->vtable != NULL && t->vtable->print_traverse != NULL)\n            t->vtable->print_traverse(fl_ctx, v);\n    }\n}\n\nstatic void print_symbol_name(fl_context_t *fl_ctx, ios_t *f, char *name)\n{\n    int i, escape=0, charescape=0;\n\n    if ((name[0] == '\\0') ||\n        (name[0] == '.' && name[1] == '\\0') ||\n        (name[0] == '#') ||\n        isnumtok(fl_ctx, name, NULL))\n        escape = 1;\n    i=0;\n    while (name[i]) {\n        if (!symchar(name[i])) {\n            escape = 1;\n            if (name[i]=='|' || name[i]=='\\\\') {\n                charescape = 1;\n                break;\n            }\n        }\n        i++;\n    }\n    if (escape) {\n        if (charescape) {\n            outc(fl_ctx, '|', f);\n            i=0;\n            while (name[i]) {\n                if (name[i]=='|' || name[i]=='\\\\')\n                    outc(fl_ctx, '\\\\', f);\n                outc(fl_ctx, name[i], f);\n                i++;\n            }\n            outc(fl_ctx, '|', f);\n        }\n        else {\n            outc(fl_ctx, '|', f);\n            outs(fl_ctx, name, f);\n            outc(fl_ctx, '|', f);\n        }\n    }\n    else {\n        outs(fl_ctx, name, f);\n    }\n}\n\n/*\n  The following implements a simple pretty-printing algorithm. This is\n  an unlimited-width approach that doesn't require an extra pass.\n  It uses some heuristics to guess whether an expression is \"small\",\n  and avoids wrapping symbols across lines. The result is high\n  performance and nice output for typical code. Quality is poor for\n  pathological or deeply-nested expressions, but those are difficult\n  to print anyway.\n*/\n#define SMALL_STR_LEN 20\nstatic inline int tinyp(fl_context_t *fl_ctx, value_t v)\n{\n    if (issymbol(v))\n        return (u8_strwidth(symbol_name(fl_ctx, v)) < SMALL_STR_LEN);\n    if (fl_isstring(fl_ctx, v))\n        return (cv_len((cvalue_t*)ptr(v)) < SMALL_STR_LEN);\n    return (isfixnum(v) || isbuiltin(v) || v==fl_ctx->F || v==fl_ctx->T || v==fl_ctx->NIL ||\n            v == fl_ctx->FL_EOF);\n}\n\nstatic int smallp(fl_context_t *fl_ctx, value_t v)\n{\n    if (tinyp(fl_ctx, v)) return 1;\n    if (fl_isnumber(fl_ctx, v)) return 1;\n    if (iscons(v)) {\n        if (tinyp(fl_ctx, car_(v)) && (tinyp(fl_ctx, cdr_(v)) ||\n                               (iscons(cdr_(v)) && tinyp(fl_ctx, car_(cdr_(v))) &&\n                                cdr_(cdr_(v))==fl_ctx->NIL)))\n            return 1;\n        return 0;\n    }\n    if (isvector(v)) {\n        size_t s = vector_size(v);\n        return (s == 0 || (tinyp(fl_ctx, vector_elt(v,0)) &&\n                           (s == 1 || (s == 2 &&\n                                       tinyp(fl_ctx, vector_elt(v,1))))));\n    }\n    return 0;\n}\n\nstatic int specialindent(fl_context_t *fl_ctx, value_t head)\n{\n    // indent these forms 2 spaces, not lined up with the first argument\n    if (head == fl_ctx->LAMBDA || head == fl_ctx->TRYCATCH || head == fl_ctx->definesym ||\n        head == fl_ctx->defmacrosym || head == fl_ctx->forsym)\n        return 2;\n    return -1;\n}\n\nstatic int lengthestimate(fl_context_t *fl_ctx, value_t v)\n{\n    // get the width of an expression if we can do so cheaply\n    if (issymbol(v))\n        return u8_strwidth(symbol_name(fl_ctx, v));\n    return -1;\n}\n\nstatic int allsmallp(fl_context_t *fl_ctx, value_t v)\n{\n    int n = 1;\n    while (iscons(v)) {\n        if (!smallp(fl_ctx, car_(v)))\n            return 0;\n        v = cdr_(v);\n        n++;\n        if (n > 25)\n            return n;\n    }\n    return n;\n}\n\nstatic int indentafter3(fl_context_t *fl_ctx, value_t head, value_t v)\n{\n    // for certain X always indent (X a b c) after b\n    return ((head == fl_ctx->forsym) && !allsmallp(fl_ctx, cdr_(v)));\n}\n\nstatic int indentafter2(fl_context_t *fl_ctx, value_t head, value_t v)\n{\n    // for certain X always indent (X a b) after a\n    return ((head == fl_ctx->definesym || head == fl_ctx->defmacrosym) &&\n            !allsmallp(fl_ctx, cdr_(v)));\n}\n\nstatic int indentevery(fl_context_t *fl_ctx, value_t v)\n{\n    // indent before every subform of a special form, unless every\n    // subform is \"small\"\n    value_t c = car_(v);\n    if (c == fl_ctx->LAMBDA || c == fl_ctx->setqsym)\n        return 0;\n    if (c == fl_ctx->IF) // TODO: others\n        return !allsmallp(fl_ctx, cdr_(v));\n    return 0;\n}\n\nstatic int blockindent(fl_context_t *fl_ctx, value_t v)\n{\n    // in this case we switch to block indent mode, where the head\n    // is no longer considered special:\n    // (a b c d e\n    //  f g h i j)\n    return (allsmallp(fl_ctx, v) > 9);\n}\n\nstatic void print_pair(fl_context_t *fl_ctx, ios_t *f, value_t v)\n{\n    value_t cd;\n    char *op = NULL;\n    if (iscons(cdr_(v)) && cdr_(cdr_(v)) == fl_ctx->NIL &&\n        !ptrhash_has(&fl_ctx->printconses, (void*)cdr_(v)) &&\n        (((car_(v) == fl_ctx->QUOTE)     && (op = \"'\"))  ||\n         ((car_(v) == fl_ctx->BACKQUOTE) && (op = \"`\"))  ||\n         ((car_(v) == fl_ctx->COMMA)     && (op = \",\"))  ||\n         ((car_(v) == fl_ctx->COMMAAT)   && (op = \",@\")) ||\n         ((car_(v) == fl_ctx->COMMADOT)  && (op = \",.\")))) {\n        // special prefix syntax\n        unmark_cons(fl_ctx, v);\n        unmark_cons(fl_ctx, cdr_(v));\n        outs(fl_ctx, op, f);\n        fl_print_child(fl_ctx, f, car_(cdr_(v)));\n        return;\n    }\n    int startpos = fl_ctx->HPOS;\n    outc(fl_ctx, '(', f);\n    int newindent=fl_ctx->HPOS, blk=blockindent(fl_ctx, v);\n    int lastv, n=0, si, ind=0, est, always=0, nextsmall, thistiny;\n    if (!blk) always = indentevery(fl_ctx, v);\n    value_t head = car_(v);\n    int after3 = indentafter3(fl_ctx, head, v);\n    int after2 = indentafter2(fl_ctx, head, v);\n    int n_unindented = 1;\n    while (1) {\n        cd = cdr_(v);\n        if (fl_ctx->print_length >= 0 && n >= fl_ctx->print_length && cd!=fl_ctx->NIL) {\n            outsn(fl_ctx, \"...)\", f, 4);\n            break;\n        }\n        lastv = fl_ctx->VPOS;\n        unmark_cons(fl_ctx, v);\n        fl_print_child(fl_ctx, f, car_(v));\n        if (!iscons(cd) || ptrhash_has(&fl_ctx->printconses, (void*)cd)) {\n            if (cd != fl_ctx->NIL) {\n                outsn(fl_ctx, \" . \", f, 3);\n                fl_print_child(fl_ctx, f, cd);\n            }\n            outc(fl_ctx, ')', f);\n            break;\n        }\n\n        if (!fl_ctx->print_pretty ||\n            ((head == fl_ctx->LAMBDA) && n == 0)) {\n            // never break line before lambda-list\n            ind = 0;\n        }\n        else {\n            est = lengthestimate(fl_ctx, car_(cd));\n            nextsmall = smallp(fl_ctx, car_(cd));\n            thistiny = tinyp(fl_ctx, car_(v));\n            ind = (((fl_ctx->VPOS > lastv) ||\n                    (fl_ctx->HPOS>fl_ctx->SCR_WIDTH/2 && !nextsmall && !thistiny && n>0)) ||\n\n                   (fl_ctx->HPOS > fl_ctx->SCR_WIDTH-4) ||\n\n                   (est!=-1 && (fl_ctx->HPOS+est > fl_ctx->SCR_WIDTH-2)) ||\n\n                   ((head == fl_ctx->LAMBDA) && !nextsmall) ||\n\n                   (n > 0 && always) ||\n\n                   (n == 2 && after3) ||\n                   (n == 1 && after2) ||\n\n                   (n_unindented >= 3 && !nextsmall) ||\n\n                   (n == 0 && !smallp(fl_ctx, head)));\n        }\n\n        if (ind) {\n            newindent = outindent(fl_ctx, newindent, f);\n            n_unindented = 1;\n        }\n        else {\n            n_unindented++;\n            outc(fl_ctx, ' ', f);\n            if (n==0) {\n                // set indent level after printing head\n                si = specialindent(fl_ctx, head);\n                if (si != -1)\n                    newindent = startpos + si;\n                else if (!blk)\n                    newindent = fl_ctx->HPOS;\n            }\n        }\n        n++;\n        v = cd;\n    }\n}\n\nstatic void cvalue_print(fl_context_t *fl_ctx, ios_t *f, value_t v);\n\nstatic int print_circle_prefix(fl_context_t *fl_ctx, ios_t *f, value_t v)\n{\n    value_t label;\n    char buf[64];\n    char *str;\n    if ((label=(value_t)ptrhash_get(&fl_ctx->printconses, (void*)v)) !=\n        (value_t)HT_NOTFOUND) {\n        if (!ismarked(fl_ctx, v)) {\n            //fl_ctx->HPOS+=ios_printf(f, \"#%ld#\", numval(label));\n            outc(fl_ctx, '#', f);\n            str = uint2str(buf, sizeof(buf)-1, numval(label), 10);\n            outs(fl_ctx, str, f);\n            outc(fl_ctx, '#', f);\n            return 1;\n        }\n        //fl_ctx->HPOS+=ios_printf(f, \"#%ld=\", numval(label));\n        outc(fl_ctx, '#', f);\n        str = uint2str(buf, sizeof(buf)-1, numval(label), 10);\n        outs(fl_ctx, str, f);\n        outc(fl_ctx, '=', f);\n    }\n    if (ismanaged(fl_ctx, v))\n        unmark_cons(fl_ctx, v);\n    return 0;\n}\n\nvoid fl_print_child(fl_context_t *fl_ctx, ios_t *f, value_t v)\n{\n    char *name, *str;\n    char buf[64];\n    if (fl_ctx->print_level >= 0 && fl_ctx->P_LEVEL >= fl_ctx->print_level &&\n        (iscons(v) || isvector(v) || isclosure(v))) {\n        outc(fl_ctx, '#', f);\n        return;\n    }\n    fl_ctx->P_LEVEL++;\n\n    switch (tag(v)) {\n    case TAG_NUM :\n    case TAG_NUM1: //fl_ctx->HPOS+=ios_printf(f, \"%ld\", numval(v)); break;\n        str = uint2str(&buf[1], sizeof(buf)-1, labs(numval(v)), 10);\n        if (numval(v)<0)\n            *(--str) = '-';\n        outs(fl_ctx, str, f);\n        break;\n    case TAG_SYM:\n        name = symbol_name(fl_ctx, v);\n        if (fl_ctx->print_princ)\n            outs(fl_ctx, name, f);\n        else if (ismanaged(fl_ctx, v)) {\n            outsn(fl_ctx, \"#:\", f, 2);\n            outs(fl_ctx, name, f);\n        }\n        else\n            print_symbol_name(fl_ctx, f, name);\n        break;\n    case TAG_FUNCTION:\n        if (v == fl_ctx->T) {\n            outsn(fl_ctx, \"#t\", f, 2);\n        }\n        else if (v == fl_ctx->F) {\n            outsn(fl_ctx, \"#f\", f, 2);\n        }\n        else if (v == fl_ctx->NIL) {\n            outsn(fl_ctx, \"()\", f, 2);\n        }\n        else if (v == fl_ctx->FL_EOF) {\n            outsn(fl_ctx, \"#<eof>\", f, 6);\n        }\n        else if (isbuiltin(v)) {\n            if (!fl_ctx->print_princ)\n                outsn(fl_ctx, \"#.\", f, 2);\n            outs(fl_ctx, builtin_names[uintval(v)], f);\n        }\n        else {\n            assert(isclosure(v));\n            if (!fl_ctx->print_princ) {\n                if (print_circle_prefix(fl_ctx, f, v)) break;\n                function_t *fn = (function_t*)ptr(v);\n                outs(fl_ctx, \"#fn(\", f);\n                char *data = (char*)cvalue_data(fn->bcode);\n                size_t i, sz = cvalue_len(fn->bcode);\n                for(i=0; i < sz; i++) data[i] += 48;\n                fl_print_child(fl_ctx, f, fn->bcode);\n                for(i=0; i < sz; i++) data[i] -= 48;\n                outc(fl_ctx, ' ', f);\n                fl_print_child(fl_ctx, f, fn->vals);\n                if (fn->env != fl_ctx->NIL) {\n                    outc(fl_ctx, ' ', f);\n                    fl_print_child(fl_ctx, f, fn->env);\n                }\n                if (fn->name != fl_ctx->LAMBDA) {\n                    outc(fl_ctx, ' ', f);\n                    fl_print_child(fl_ctx, f, fn->name);\n                }\n                outc(fl_ctx, ')', f);\n            }\n            else {\n                outs(fl_ctx, \"#<function>\", f);\n            }\n        }\n        break;\n    case TAG_CVALUE:\n    case TAG_CPRIM:\n        if (v == UNBOUND) { outs(fl_ctx, \"#<undefined>\", f); break; }\n    case TAG_VECTOR:\n    case TAG_CONS:\n        if (print_circle_prefix(fl_ctx, f, v)) break;\n        if (isvector(v)) {\n            outc(fl_ctx, '[', f);\n            int newindent = fl_ctx->HPOS, est;\n            int i, sz = vector_size(v);\n            for(i=0; i < sz; i++) {\n                if (fl_ctx->print_length >= 0 && i >= fl_ctx->print_length && i < sz-1) {\n                    outsn(fl_ctx, \"...\", f, 3);\n                    break;\n                }\n                fl_print_child(fl_ctx, f, vector_elt(v,i));\n                if (i < sz-1) {\n                    if (!fl_ctx->print_pretty) {\n                        outc(fl_ctx, ' ', f);\n                    }\n                    else {\n                        est = lengthestimate(fl_ctx, vector_elt(v,i+1));\n                        if (fl_ctx->HPOS > fl_ctx->SCR_WIDTH-4 ||\n                            (est!=-1 && (fl_ctx->HPOS+est > fl_ctx->SCR_WIDTH-2)) ||\n                            (fl_ctx->HPOS > fl_ctx->SCR_WIDTH/2 &&\n                             !smallp(fl_ctx, vector_elt(v,i+1)) &&\n                             !tinyp(fl_ctx, vector_elt(v,i))))\n                            newindent = outindent(fl_ctx, newindent, f);\n                        else\n                            outc(fl_ctx, ' ', f);\n                    }\n                }\n            }\n            outc(fl_ctx, ']', f);\n            break;\n        }\n        if (iscvalue(v) || iscprim(v))\n            cvalue_print(fl_ctx, f, v);\n        else\n            print_pair(fl_ctx, f, v);\n        break;\n    }\n    fl_ctx->P_LEVEL--;\n}\n\nstatic void print_string(fl_context_t *fl_ctx, ios_t *f, char *str, size_t sz)\n{\n    char buf[512];\n    size_t i = 0;\n    uint8_t c;\n    static const char hexdig[] = \"0123456789abcdef\";\n\n    outc(fl_ctx, '\"', f);\n    if (!u8_isvalid(str, sz)) {\n        // alternate print algorithm that preserves data if it's not UTF-8\n        for(i=0; i < sz; i++) {\n            c = str[i];\n            if (c == '\\\\')\n                outsn(fl_ctx, \"\\\\\\\\\", f, 2);\n            else if (c == '\"')\n                outsn(fl_ctx, \"\\\\\\\"\", f, 2);\n            else if (c >= 32 && c < 0x7f)\n                outc(fl_ctx, c, f);\n            else {\n                outsn(fl_ctx, \"\\\\x\", f, 2);\n                outc(fl_ctx, hexdig[c>>4], f);\n                outc(fl_ctx, hexdig[c&0xf], f);\n            }\n        }\n    }\n    else {\n        while (i < sz) {\n            size_t n = u8_escape(buf, sizeof(buf), str, &i, sz, 1, 0);\n            outsn(fl_ctx, buf, f, n-1);\n        }\n    }\n    outc(fl_ctx, '\"', f);\n}\n\nstatic numerictype_t sym_to_numtype(fl_context_t *fl_ctx, value_t type);\n#ifndef _OS_WINDOWS_\n#define __USE_GNU\n#include <dlfcn.h>\n#undef __USE_GNU\n#endif\n\n#define sign_bit(r) ((*(int64_t*)&(r)) & BIT63)\n#define DFINITE(d) (((*(int64_t*)&(d))&0x7ff0000000000000LL)!=0x7ff0000000000000LL)\n\n// 'weak' means we don't need to accurately reproduce the type, so\n// for example #int32(0) can be printed as just 0. this is used\n// printing in a context where a type is already implied, e.g. inside\n// an array.\nstatic void cvalue_printdata(fl_context_t *fl_ctx, ios_t *f, void *data,\n                             size_t len, value_t type, int weak)\n{\n    if (type == fl_ctx->bytesym) {\n        unsigned char ch = *(unsigned char*)data;\n        if (fl_ctx->print_princ)\n            outc(fl_ctx, ch, f);\n        else if (weak)\n            fl_ctx->HPOS+=ios_printf(f, \"0x%hhx\", ch);\n        else\n            fl_ctx->HPOS+=ios_printf(f, \"#byte(0x%hhx)\", ch);\n    }\n    else if (type == fl_ctx->wcharsym) {\n        uint32_t wc = *(uint32_t*)data;\n        char seq[8];\n        size_t nb = u8_toutf8(seq, sizeof(seq), &wc, 1);\n        seq[nb] = '\\0';\n        if (fl_ctx->print_princ) {\n            // TODO: better multibyte handling\n            outs(fl_ctx, seq, f);\n        }\n        else {\n            outsn(fl_ctx, \"#\\\\\", f, 2);\n            if      (wc == 0x00) outsn(fl_ctx, \"nul\", f, 3);\n            else if (wc == 0x07) outsn(fl_ctx, \"alarm\", f, 5);\n            else if (wc == 0x08) outsn(fl_ctx, \"backspace\", f, 9);\n            else if (wc == 0x09) outsn(fl_ctx, \"tab\", f, 3);\n            else if (wc == 0x0A) outsn(fl_ctx, \"linefeed\", f, 8);\n            //else if (wc == 0x0A) outsn(fl_ctx, \"newline\", f, 7);\n            else if (wc == 0x0B) outsn(fl_ctx, \"vtab\", f, 4);\n            else if (wc == 0x0C) outsn(fl_ctx, \"page\", f, 4);\n            else if (wc == 0x0D) outsn(fl_ctx, \"return\", f, 6);\n            else if (wc == 0x1B) outsn(fl_ctx, \"esc\", f, 3);\n            else if (wc == 0x20) outsn(fl_ctx, \"space\", f, 5);\n            else if (wc == 0x7F) outsn(fl_ctx, \"delete\", f, 6);\n            else if (iswprint(wc)) outs(fl_ctx, seq, f);\n            else fl_ctx->HPOS+=ios_printf(f, \"x%04x\", (int)wc);\n        }\n    }\n    else if (type == fl_ctx->floatsym || type == fl_ctx->doublesym) {\n        char buf[64];\n        double d;\n        if (type == fl_ctx->floatsym) { d = (double)*(float*)data; }\n        else { d = *(double*)data; }\n        if (!DFINITE(d)) {\n            char *rep;\n            if (d != d)\n                rep = (char*)(sign_bit(d) ? \"-nan.0\" : \"+nan.0\");\n            else\n                rep = (char*)(sign_bit(d) ? \"-inf.0\" : \"+inf.0\");\n            if (type == fl_ctx->floatsym && !fl_ctx->print_princ && !weak)\n                fl_ctx->HPOS+=ios_printf(f, \"#%s(%s)\", symbol_name(fl_ctx, type), rep);\n            else\n                outs(fl_ctx, rep, f);\n        }\n        else if (d == 0) {\n            if (sign_bit(d))\n                outsn(fl_ctx, \"-0.0\", f, 4);\n            else\n                outsn(fl_ctx, \"0.0\", f, 3);\n            if (type == fl_ctx->floatsym && !fl_ctx->print_princ && !weak)\n                outc(fl_ctx, 'f', f);\n        }\n        else {\n            double ad = d < 0 ? -d : d;\n            if ((long)d == d && ad < 1e6 && ad >= 1e-4) {\n                snprintf(buf, sizeof(buf), \"%g\", d);\n            }\n            else {\n                if (type == fl_ctx->floatsym)\n                    snprintf(buf, sizeof(buf), \"%.8g\", d);\n                else\n                    snprintf(buf, sizeof(buf), \"%.16g\", d);\n            }\n            int hasdec = (strpbrk(buf, \".eE\") != NULL);\n            outs(fl_ctx, buf, f);\n            if (!hasdec) outsn(fl_ctx, \".0\", f, 2);\n            if (type == fl_ctx->floatsym && !fl_ctx->print_princ && !weak)\n                outc(fl_ctx, 'f', f);\n        }\n    }\n    else if (type == fl_ctx->uint64sym\n#ifdef _P64\n             || type == fl_ctx->sizesym\n#endif\n             ) {\n        uint64_t ui64 = *(uint64_t*)data;\n        if (weak || fl_ctx->print_princ)\n            fl_ctx->HPOS += ios_printf(f, \"%llu\", ui64);\n        else\n            fl_ctx->HPOS += ios_printf(f, \"#%s(%llu)\", symbol_name(fl_ctx, type), ui64);\n    }\n    else if (issymbol(type)) {\n        // handle other integer prims. we know it's smaller than uint64\n        // at this point, so int64 is big enough to capture everything.\n        numerictype_t nt = sym_to_numtype(fl_ctx, type);\n        if (nt == N_NUMTYPES) {\n            // These states should be context independent.\n            static size_t (*volatile jl_static_print)(ios_t*, void*) = NULL;\n            static volatile int init = 0;\n            if (init == 0) {\n#if defined(RTLD_SELF)\n                jl_static_print = (size_t (*)(ios_t*, void*))\n                    dlsym(RTLD_SELF, \"jl_static_show\");\n#elif defined(RTLD_DEFAULT)\n                jl_static_print = (size_t (*)(ios_t*, void*))\n                    dlsym(RTLD_DEFAULT, \"jl_static_show\");\n#elif defined(_OS_WINDOWS_)\n                HMODULE handle;\n                if (GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |\n                                       GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n                                       (LPCWSTR)(&cvalue_printdata),\n                                       &handle)) {\n                    jl_static_print = (size_t (*)(ios_t*, void*))\n                        GetProcAddress(handle, \"jl_static_show\");\n                }\n#endif\n                init = 1;\n            }\n            if (jl_static_print != NULL && fl_ctx->jl_sym == type) {\n                fl_ctx->HPOS += ios_printf(f, \"#<julia: \");\n                fl_ctx->HPOS += jl_static_print(f, *(void**)data);\n                fl_ctx->HPOS += ios_printf(f, \">\");\n            }\n            else\n                fl_ctx->HPOS += ios_printf(f, \"#<%s>\", symbol_name(fl_ctx, type));\n        }\n        else {\n            int64_t i64 = conv_to_int64(data, nt);\n            if (weak || fl_ctx->print_princ)\n                fl_ctx->HPOS += ios_printf(f, \"%lld\", i64);\n            else\n                fl_ctx->HPOS += ios_printf(f, \"#%s(%lld)\", symbol_name(fl_ctx, type), i64);\n        }\n    }\n    else if (iscons(type)) {\n        if (car_(type) == fl_ctx->arraysym) {\n            value_t eltype = car(fl_ctx, cdr_(type));\n            size_t cnt, elsize;\n            if (iscons(cdr_(cdr_(type)))) {\n                cnt = tosize(fl_ctx, car_(cdr_(cdr_(type))), \"length\");\n                elsize = cnt ? len/cnt : 0;\n            }\n            else {\n                // incomplete array type\n                int junk;\n                elsize = ctype_sizeof(fl_ctx, eltype, &junk);\n                cnt = elsize ? len/elsize : 0;\n            }\n            if (eltype == fl_ctx->bytesym) {\n                if (fl_ctx->print_princ) {\n                    ios_write(f, (char*)data, len);\n                    /*\n                    char *nl = memrchr(data, '\\n', len);\n                    if (nl)\n                        fl_ctx->HPOS = u8_strwidth(nl+1);\n                    else\n                        fl_ctx->HPOS += u8_strwidth(data);\n                    */\n                }\n                else {\n                    print_string(fl_ctx, f, (char*)data, len);\n                }\n                return;\n            }\n            else if (eltype == fl_ctx->wcharsym) {\n                // TODO wchar\n            }\n            else {\n            }\n            size_t i;\n            if (!weak) {\n                if (eltype == fl_ctx->uint8sym) {\n                    outsn(fl_ctx, \"#vu8(\", f, 5);\n                }\n                else {\n                    outsn(fl_ctx, \"#array(\", f, 7);\n                    fl_print_child(fl_ctx, f, eltype);\n                    if (cnt > 0)\n                        outc(fl_ctx, ' ', f);\n                }\n            }\n            else {\n                outc(fl_ctx, '[', f);\n            }\n            for(i=0; i < cnt; i++) {\n                if (i > 0)\n                    outc(fl_ctx, ' ', f);\n                cvalue_printdata(fl_ctx, f, data, elsize, eltype, 1);\n                data = (char *)data + elsize;\n            }\n            if (!weak)\n                outc(fl_ctx, ')', f);\n            else\n                outc(fl_ctx, ']', f);\n        }\n    }\n}\n\nstatic void cvalue_print(fl_context_t *fl_ctx, ios_t *f, value_t v)\n{\n    cvalue_t *cv = (cvalue_t*)ptr(v);\n    void *data = cptr(v);\n    value_t label;\n\n    if (cv_class(cv) == fl_ctx->builtintype) {\n        void *fptr = *(void**)data;\n        label = (value_t)ptrhash_get(&fl_ctx->reverse_dlsym_lookup_table, cv);\n        if (label == (value_t)HT_NOTFOUND) {\n            fl_ctx->HPOS += ios_printf(f, \"#<builtin @0x%08zx>\",\n                                  (size_t)(builtin_t)fptr);\n        }\n        else {\n            if (fl_ctx->print_princ) {\n                outs(fl_ctx, symbol_name(fl_ctx, label), f);\n            }\n            else {\n                outsn(fl_ctx, \"#fn(\", f, 4);\n                outs(fl_ctx, symbol_name(fl_ctx, label), f);\n                outc(fl_ctx, ')', f);\n            }\n        }\n    }\n    else if (cv_class(cv)->vtable != NULL &&\n             cv_class(cv)->vtable->print != NULL) {\n        cv_class(cv)->vtable->print(fl_ctx, v, f);\n    }\n    else {\n        value_t type = cv_type(cv);\n        size_t len = iscprim(v) ? cv_class(cv)->size : cv_len(cv);\n        cvalue_printdata(fl_ctx, f, data, len, type, 0);\n    }\n}\n\nstatic void set_print_width(fl_context_t *fl_ctx)\n{\n    value_t pw = symbol_value(fl_ctx->printwidthsym);\n    if (!isfixnum(pw)) return;\n    fl_ctx->SCR_WIDTH = numval(pw);\n}\n\nvoid fl_print(fl_context_t *fl_ctx, ios_t *f, value_t v)\n{\n    fl_ctx->print_pretty = (symbol_value(fl_ctx->printprettysym) != fl_ctx->F);\n    if (fl_ctx->print_pretty)\n        set_print_width(fl_ctx);\n    fl_ctx->print_princ = (symbol_value(fl_ctx->printreadablysym) == fl_ctx->F);\n\n    value_t pl = symbol_value(fl_ctx->printlengthsym);\n    if (isfixnum(pl)) fl_ctx->print_length = numval(pl);\n    else fl_ctx->print_length = -1;\n    pl = symbol_value(fl_ctx->printlevelsym);\n    if (isfixnum(pl)) fl_ctx->print_level = numval(pl);\n    else fl_ctx->print_level = -1;\n    fl_ctx->P_LEVEL = 0;\n\n    fl_ctx->printlabel = 0;\n    print_traverse(fl_ctx, v);\n    fl_ctx->HPOS = fl_ctx->VPOS = 0;\n\n    fl_print_child(fl_ctx, f, v);\n\n    if (fl_ctx->print_level >= 0 || fl_ctx->print_length >= 0) {\n        memset(fl_ctx->consflags, 0, 4*bitvector_nwords(fl_ctx->heapsize/sizeof(cons_t)));\n    }\n\n    if ((iscons(v) || isvector(v) || isfunction(v) || iscvalue(v)) &&\n        !fl_isstring(fl_ctx, v) && v!=fl_ctx->T && v!=fl_ctx->F && v!=fl_ctx->NIL) {\n        htable_reset(&fl_ctx->printconses, 32);\n    }\n}\n\nvoid fl_print_init(fl_context_t *fl_ctx)\n{\n    htable_new(&fl_ctx->printconses, 32);\n    fl_ctx->SCR_WIDTH = 80;\n    fl_ctx->HPOS = 0;\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/flisp/flisp.h": "#ifndef FLISP_H\n#define FLISP_H\n\n#include <setjmp.h>\n#include <stdint.h>\n\n#include \"platform.h\"\n#include \"libsupport.h\"\n#include \"uv.h\"\n\n//#define MEMDEBUG\n//#define MEMDEBUG2\n\ntypedef uintptr_t value_t;\ntypedef int_t fixnum_t;\n#if NBITS==64\n#define T_FIXNUM T_INT64\n#define labs llabs\n#else\n#define T_FIXNUM T_INT32\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\ntypedef struct _fl_context_t fl_context_t;\ntypedef struct {\n    value_t car;\n    value_t cdr;\n} cons_t;\n\ntypedef struct _symbol_t {\n    uintptr_t flags;\n    value_t binding;   // global value binding\n    struct _fltype_t *type;\n    uint32_t hash;\n    void *dlcache;     // dlsym address\n    // below fields are private\n    struct _symbol_t *left;\n    struct _symbol_t *right;\n    JL_ATTRIBUTE_ALIGN_PTRSIZE(char name[]);\n} symbol_t;\n\ntypedef struct {\n    value_t isconst;\n    value_t binding;   // global value binding\n    struct _fltype_t *type;\n    uint32_t id;\n} gensym_t;\n\n#define TAG_NUM      0x0\n#define TAG_CPRIM    0x1\n#define TAG_FUNCTION 0x2\n#define TAG_VECTOR   0x3\n#define TAG_NUM1     0x4\n#define TAG_CVALUE   0x5\n#define TAG_SYM      0x6\n#define TAG_CONS     0x7\n#define UNBOUND      ((value_t)0x1) // an invalid value\n#define TAG_FWD      UNBOUND\n#define tag(x) ((x)&0x7)\n#define ptr(x) ((void*)((x)&(~(value_t)0x7)))\n#define tagptr(p,t) (((value_t)(p)) | (t))\n#define fixnum(x) ((value_t)(((uintptr_t)(x))<<2))\n#define numval(x)  (((fixnum_t)(x))>>2)\n#if NBITS==64\n#define fits_fixnum(x) (((x)>>61) == 0 || (~((x)>>61)) == 0)\n#else\n#define fits_fixnum(x) (((x)>>29) == 0 || (~((x)>>29)) == 0)\n#endif\n#define fits_bits(x,b) (((x)>>(b-1)) == 0 || (~((x)>>(b-1))) == 0)\n#define uintval(x)  (((unsigned int)(x))>>3)\n#define builtin(n) tagptr((((int)n)<<3), TAG_FUNCTION)\n#define iscons(x)    (tag(x) == TAG_CONS)\n#define issymbol(x)  (tag(x) == TAG_SYM)\n#define isfixnum(x)  (((x)&3) == TAG_NUM)\n#define bothfixnums(x,y) ((((x)|(y))&3) == TAG_NUM)\n#define isbuiltin(x) ((tag(x) == TAG_FUNCTION) && uintval(x) <= OP_ASET)\n#define isvector(x) (tag(x) == TAG_VECTOR)\n#define iscvalue(x) (tag(x) == TAG_CVALUE)\n#define iscprim(x)  (tag(x) == TAG_CPRIM)\n#define selfevaluating(x) (tag(x)<6)\n// comparable with ==\n#define eq_comparable(a,b) (!(((a)|(b))&1))\n#define eq_comparablep(a) (!((a)&1))\n// doesn't lead to other values\n#define leafp(a) (((a)&3) != 3)\n\n#define isforwarded(v) (((value_t*)ptr(v))[0] == TAG_FWD)\n#define forwardloc(v)  (((value_t*)ptr(v))[1])\n#define forward(v,to) do { (((value_t*)ptr(v))[0] = TAG_FWD); \\\n                           (((value_t*)ptr(v))[1] = to); } while (0)\n\n#define vector_size(v) (((size_t*)ptr(v))[0]>>2)\n#define vector_setsize(v,n) (((size_t*)ptr(v))[0] = ((n)<<2))\n#define vector_elt(v,i) (((value_t*)ptr(v))[1+(i)])\n#define vector_grow_amt(x) ((x)<8 ? 5 : 6*((x)>>3))\n// functions ending in _ are unsafe, faster versions\n#define car_(v) (((cons_t*)ptr(v))->car)\n#define cdr_(v) (((cons_t*)ptr(v))->cdr)\n#define car(fl_ctx, v)  (tocons(fl_ctx, (v),\"car\")->car)\n#define cdr(fl_ctx, v)  (tocons(fl_ctx, (v),\"cdr\")->cdr)\n#define fn_bcode(f) (((value_t*)ptr(f))[0])\n#define fn_vals(f) (((value_t*)ptr(f))[1])\n#define fn_env(f) (((value_t*)ptr(f))[2])\n#define fn_name(f) (((value_t*)ptr(f))[3])\n\n#define set(s, v)  (((symbol_t*)ptr(s))->binding = (v))\n#define setc(s, v) do { ((symbol_t*)ptr(s))->flags |= 1; \\\n                        ((symbol_t*)ptr(s))->binding = (v); } while (0)\n#define isconstant(s) ((s)->flags&0x1)\n#define iskeyword(s) ((s)->flags&0x2)\n#define symbol_value(s) (((symbol_t*)ptr(s))->binding)\n#ifdef MEMDEBUG2\n#define ismanaged(ctx, v) (!issymbol(v) && !isfixnum(v) && ((v)>(N_OPCODES<<3)) && !iscbuiltin(ctx, v))\n#else\n#define ismanaged(ctx, v) ((((unsigned char*)ptr(v)) >= ctx->fromspace) && \\\n                           (((unsigned char*)ptr(v)) < ctx->fromspace + ctx->heapsize))\n#endif\n#define isgensym(ctx, x)  (issymbol(x) && ismanaged(ctx, x))\n\n#define isfunction(x) (tag(x) == TAG_FUNCTION && (x) > (N_BUILTINS<<3))\n#define isclosure(x) isfunction(x)\n#define iscbuiltin(ctx, x) (iscvalue(x) && (cv_class((cvalue_t*)ptr(x))==ctx->builtintype))\n\nvoid fl_gc_handle(fl_context_t *fl_ctx, value_t *pv);\nvoid fl_free_gc_handles(fl_context_t *fl_ctx, uint32_t n);\n\n#include \"opcodes.h\"\n\n// utility for iterating over all arguments in a builtin\n// i=index, i0=start index, arg = var for each arg, args = arg array\n// assumes \"nargs\" is the argument count\n#define FOR_ARGS(i, i0, arg, args)     \\\n    for(i=i0; ((size_t)i)<nargs && ((arg=args[i]) || 1); i++)\n\n#define N_BUILTINS ((int)N_OPCODES)\n\n#define FL_UNSPECIFIED(fl_ctx) fl_ctx->T\n\n/* read, eval, print main entry points */\nvalue_t fl_read_sexpr(fl_context_t *fl_ctx, value_t f);\nvoid fl_print(fl_context_t *fl_ctx, ios_t *f, value_t v);\nvalue_t fl_toplevel_eval(fl_context_t *fl_ctx, value_t expr);\nvalue_t fl_apply(fl_context_t *fl_ctx, value_t f, value_t l);\nvalue_t fl_applyn(fl_context_t *fl_ctx, uint32_t n, value_t f, ...);\n\n/* object model manipulation */\nvalue_t fl_cons(fl_context_t *fl_ctx, value_t a, value_t b);\nvalue_t fl_list2(fl_context_t *fl_ctx, value_t a, value_t b);\nvalue_t fl_listn(fl_context_t *fl_ctx, size_t n, ...);\nvalue_t symbol(fl_context_t *fl_ctx, const char *str);\nchar *symbol_name(fl_context_t *fl_ctx, value_t v);\nint fl_is_keyword_name(const char *str, size_t len);\nvalue_t alloc_vector(fl_context_t *fl_ctx, size_t n, int init);\nsize_t llength(value_t v);\nvalue_t fl_compare(fl_context_t *fl_ctx, value_t a, value_t b);  // -1, 0, or 1\nvalue_t fl_equal(fl_context_t *fl_ctx, value_t a, value_t b);    // T or nil\nint equal_lispvalue(fl_context_t *fl_ctx, value_t a, value_t b);\nuintptr_t hash_lispvalue(fl_context_t *fl_ctx, value_t a);\nint isnumtok_base(fl_context_t *fl_ctx, char *tok, value_t *pval, int base);\n\n/* safe casts */\ncons_t *tocons(fl_context_t *fl_ctx, value_t v, const char *fname);\nsymbol_t *tosymbol(fl_context_t *fl_ctx, value_t v, const char *fname);\nfixnum_t tofixnum(fl_context_t *fl_ctx, value_t v, const char *fname);\nchar *tostring(fl_context_t *fl_ctx, value_t v, const char *fname);\n\n/* error handling */\ntypedef struct _ectx_t {\n    jmp_buf buf;\n    uint32_t sp;\n    uint32_t frame;\n    uint32_t ngchnd;\n    void *rdst;\n    struct _ectx_t *prev;\n} fl_exception_context_t;\n\n#define FL_TRY_EXTERN(fl_ctx)                                           \\\n  fl_exception_context_t _ctx; int l__tr, l__ca;                        \\\n  fl_savestate(fl_ctx, &_ctx); fl_ctx->exc_ctx = &_ctx;                      \\\n  if (!setjmp(_ctx.buf))                                                \\\n      for (l__tr=1; l__tr; l__tr=0, (void)(fl_ctx->exc_ctx=fl_ctx->exc_ctx->prev))\n\n#define FL_CATCH_EXTERN(fl_ctx)                                         \\\n    else                                                                \\\n        for(l__ca=1; l__ca; l__ca=0, fl_restorestate(fl_ctx, &_ctx))\n\n#if defined(_OS_WINDOWS_)\n__declspec(noreturn) void lerrorf(fl_context_t *fl_ctx, value_t e, const char *format, ...);\n__declspec(noreturn) void lerror(fl_context_t *fl_ctx, value_t e, const char *msg);\n__declspec(noreturn) void fl_raise(fl_context_t *fl_ctx, value_t e);\n__declspec(noreturn) void type_error(fl_context_t *fl_ctx, const char *fname, const char *expected, value_t got);\n__declspec(noreturn) void bounds_error(fl_context_t *fl_ctx, const char *fname, value_t arr, value_t ind);\n#else\nvoid lerrorf(fl_context_t *fl_ctx, value_t e, const char *format, ...) __attribute__ ((__noreturn__));\nvoid lerror(fl_context_t *fl_ctx, value_t e, const char *msg) __attribute__ ((__noreturn__));\nvoid fl_raise(fl_context_t *fl_ctx, value_t e) __attribute__ ((__noreturn__));\nvoid type_error(fl_context_t *fl_ctx, const char *fname, const char *expected, value_t got) __attribute__ ((__noreturn__));\nvoid bounds_error(fl_context_t *fl_ctx, const char *fname, value_t arr, value_t ind) __attribute__ ((__noreturn__));\n#endif\n\nvoid fl_savestate(fl_context_t *fl_ctx, fl_exception_context_t *_ctx);\nvoid fl_restorestate(fl_context_t *fl_ctx, fl_exception_context_t *_ctx);\n\ntypedef struct {\n    void (*print)(fl_context_t *fl_ctx, value_t self, ios_t *f);\n    void (*relocate)(fl_context_t *fl_ctx, value_t oldv, value_t newv);\n    void (*finalize)(fl_context_t *fl_ctx, value_t self);\n    void (*print_traverse)(fl_context_t *fl_ctx, value_t self);\n} cvtable_t;\n\n/* functions needed to implement the value interface (cvtable_t) */\nvalue_t relocate_lispvalue(fl_context_t *fl_ctx, value_t v);\nvoid print_traverse(fl_context_t *fl_ctx, value_t v);\nvoid fl_print_chr(fl_context_t *fl_ctx, char c, ios_t *f);\nvoid fl_print_str(fl_context_t *fl_ctx, const char *s, ios_t *f);\nvoid fl_print_child(fl_context_t *fl_ctx, ios_t *f, value_t v);\n\ntypedef int (*cvinitfunc_t)(fl_context_t *fl_ctx, struct _fltype_t*, value_t, void*);\n\ntypedef struct _fltype_t {\n    value_t type;\n    numerictype_t numtype;\n    size_t size;\n    size_t elsz;\n    const cvtable_t *vtable;\n    struct _fltype_t *eltype;  // for arrays\n    struct _fltype_t *artype;  // (array this)\n    int marked;\n    cvinitfunc_t init;\n} fltype_t;\n\ntypedef struct {\n    fltype_t *type;\n    void *data;\n    size_t len;            // length of *data in bytes\n    union {\n        value_t parent;    // optional\n        char _space[1];    // variable size\n    };\n} cvalue_t;\n\n#define CVALUE_NWORDS 4\n\ntypedef struct {\n    fltype_t *type;\n    char _space[1];\n} cprim_t;\n\ntypedef struct {\n    value_t bcode;\n    value_t vals;\n    value_t env;\n    value_t name;\n} function_t;\n\n#define CPRIM_NWORDS 2\n#define MAX_INL_SIZE 384\n\n#define CV_OWNED_BIT  0x1\n#define CV_PARENT_BIT 0x2\n#define owned(cv)      ((uintptr_t)(cv)->type & CV_OWNED_BIT)\n#define hasparent(cv)  ((uintptr_t)(cv)->type & CV_PARENT_BIT)\n#define isinlined(cv)  ((cv)->data == &(cv)->_space[0])\n#define cv_class(cv)   ((fltype_t*)(((uintptr_t)(cv)->type)&~3))\n#define cv_len(cv)     ((cv)->len)\n#define cv_type(cv)    (cv_class(cv)->type)\n#define cv_data(cv)    ((cv)->data)\n#define cv_isstr(fl_ctx, cv)   (cv_class(cv)->eltype == fl_ctx->bytetype)\n#define cv_isPOD(cv)   (cv_class(cv)->init != NULL)\n\n#define cvalue_data(v) cv_data((cvalue_t*)ptr(v))\n#define cvalue_len(v) cv_len((cvalue_t*)ptr(v))\n#define value2c(type, v) ((type)cv_data((cvalue_t*)ptr(v)))\n\n#define valid_numtype(v) ((v) < N_NUMTYPES)\n#define cp_class(cp)   ((cp)->type)\n#define cp_type(cp)    (cp_class(cp)->type)\n#define cp_numtype(cp) (cp_class(cp)->numtype)\n#define cp_data(cp)    (&(cp)->_space[0])\n\n// WARNING: multiple evaluation!\n#define cptr(v) \\\n    (iscprim(v) ? cp_data((cprim_t*)ptr(v)) : cv_data((cvalue_t*)ptr(v)))\n\n/* C type names corresponding to cvalues type names */\ntypedef int8_t   fl_int8_t;\ntypedef uint8_t  fl_uint8_t;\ntypedef int16_t  fl_int16_t;\ntypedef uint16_t fl_uint16_t;\ntypedef int32_t  fl_int32_t;\ntypedef uint32_t fl_uint32_t;\ntypedef int64_t  fl_int64_t;\ntypedef uint64_t fl_uint64_t;\ntypedef char     fl_char_t;\ntypedef char     char_t;\ntypedef ptrdiff_t fl_ptrdiff_t;\ntypedef size_t   fl_size_t;\ntypedef double   fl_double_t;\ntypedef float    fl_float_t;\n\ntypedef value_t (*builtin_t)(fl_context_t*, value_t*, uint32_t);\n\nvalue_t cvalue(fl_context_t *fl_ctx, fltype_t *type, size_t sz);\nvoid add_finalizer(fl_context_t *fl_ctx, cvalue_t *cv);\nvoid cv_autorelease(fl_context_t *fl_ctx, cvalue_t *cv);\nvoid cv_pin(fl_context_t *fl_ctx, cvalue_t *cv);\nsize_t ctype_sizeof(fl_context_t *fl_ctx, value_t type, int *palign);\nvalue_t cvalue_copy(fl_context_t *fl_ctx, value_t v);\nvalue_t cvalue_from_data(fl_context_t *fl_ctx, fltype_t *type, void *data, size_t sz);\nvalue_t cvalue_from_ref(fl_context_t *fl_ctx, fltype_t *type, void *ptr, size_t sz, value_t parent);\nvalue_t cbuiltin(fl_context_t *fl_ctx, const char *name, builtin_t f);\nsize_t cvalue_arraylen(value_t v);\nvalue_t size_wrap(fl_context_t *fl_ctx, size_t sz);\nsize_t tosize(fl_context_t *fl_ctx, value_t n, const char *fname);\nvalue_t cvalue_string(fl_context_t *fl_ctx, size_t sz);\nvalue_t cvalue_static_cstrn(fl_context_t *fl_ctx, const char *str, size_t n);\nvalue_t cvalue_static_cstring(fl_context_t *fl_ctx, const char *str);\nvalue_t string_from_cstr(fl_context_t *fl_ctx, char *str);\nvalue_t string_from_cstrn(fl_context_t *fl_ctx, char *str, size_t n);\nint fl_isstring(fl_context_t *fl_ctx, value_t v);\nint fl_isnumber(fl_context_t *fl_ctx, value_t v);\nint fl_isgensym(fl_context_t *fl_ctx, value_t v);\nint fl_isiostream(fl_context_t *fl_ctx, value_t v);\nios_t *fl_toiostream(fl_context_t *fl_ctx, value_t v, const char *fname);\nvalue_t cvalue_compare(value_t a, value_t b);\nint numeric_compare(fl_context_t *fl_ctx, value_t a, value_t b, int eq, int eqnans, char *fname);\n\nvoid to_sized_ptr(fl_context_t *fl_ctx, value_t v, const char *fname, char **pdata, size_t *psz);\n\nfltype_t *get_type(fl_context_t *fl_ctx, value_t t);\nfltype_t *get_array_type(fl_context_t *fl_ctx, value_t eltype);\nfltype_t *define_opaque_type(value_t sym, size_t sz, const cvtable_t *vtab,\n                             cvinitfunc_t init);\n\nvalue_t mk_double(fl_context_t *fl_ctx, fl_double_t n);\nvalue_t mk_float(fl_context_t *fl_ctx, fl_float_t n);\nvalue_t mk_uint32(fl_context_t *fl_ctx, uint32_t n);\nvalue_t mk_uint64(fl_context_t *fl_ctx, uint64_t n);\nvalue_t mk_wchar(fl_context_t *fl_ctx, int32_t n);\nvalue_t return_from_uint64(fl_context_t *fl_ctx, uint64_t Uaccum);\nvalue_t return_from_int64(fl_context_t *fl_ctx, int64_t Saccum);\n\ntypedef struct {\n    const char *name;\n    builtin_t fptr;\n} builtinspec_t;\n\nvoid assign_global_builtins(fl_context_t *fl_ctx, const builtinspec_t *b);\n\n/* builtins */\nvalue_t fl_hash(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nvalue_t cvalue_byte(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nvalue_t cvalue_wchar(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\n\nvoid fl_init(fl_context_t *fl_ctx, size_t initial_heapsize);\nint fl_load_system_image(fl_context_t *fl_ctx, value_t ios);\nint fl_load_system_image_str(fl_context_t *fl_ctx, char* str, size_t len);\n\n/* julia extensions */\nJL_DLLEXPORT int jl_id_char(uint32_t wc);\nJL_DLLEXPORT int jl_id_start_char(uint32_t wc);\n\nstruct _fl_context_t {\n    symbol_t *symtab;\n    value_t NIL, T, F, FL_EOF, QUOTE;\n    value_t int8sym, uint8sym, int16sym, uint16sym, int32sym, uint32sym;\n    value_t int64sym, uint64sym;\n\n    value_t ptrdiffsym, sizesym, bytesym, wcharsym;\n    value_t floatsym, doublesym;\n    value_t stringtypesym, wcstringtypesym;\n    value_t emptystringsym;\n\n    value_t arraysym, cfunctionsym, voidsym, pointersym;\n\n    htable_t TypeTable;\n    htable_t reverse_dlsym_lookup_table;\n\n    fltype_t *int8type, *uint8type;\n    fltype_t *int16type, *uint16type;\n    fltype_t *int32type, *uint32type;\n    fltype_t *int64type, *uint64type;\n    fltype_t *ptrdifftype, *sizetype;\n    fltype_t *floattype, *doubletype;\n    fltype_t *bytetype, *wchartype;\n    fltype_t *stringtype, *wcstringtype;\n    fltype_t *builtintype;\n\n    htable_t equal_eq_hashtable;\n\n    value_t tablesym;\n    fltype_t *tabletype;\n    cvtable_t table_vtable;\n\n    uint32_t readtoktype;\n    value_t readtokval;\n    char readbuf[256];\n\n    htable_t printconses;\n    uint32_t printlabel;\n    int print_pretty;\n    int print_princ;\n    fixnum_t print_length;\n    fixnum_t print_level;\n    fixnum_t P_LEVEL;\n    int SCR_WIDTH;\n    int HPOS, VPOS;\n\n    value_t iostreamsym, rdsym, wrsym, apsym, crsym, truncsym;\n    value_t instrsym, outstrsym;\n    fltype_t *iostreamtype;\n\n    size_t malloc_pressure;\n    cvalue_t **Finalizers;\n    size_t nfinalizers;\n    size_t maxfinalizers;\n\n    uint32_t N_STACK;\n    value_t *Stack;\n    uint32_t SP;\n    uint32_t curr_frame;\n\n#define FL_N_GC_HANDLES 8192\n    value_t *GCHandleStack[FL_N_GC_HANDLES];\n    uint32_t N_GCHND;\n\n    value_t IOError, ParseError, TypeError, ArgError, UnboundError, KeyError;\n    value_t OutOfMemoryError, DivideError, BoundsError, EnumerationError;\n    value_t printwidthsym, printreadablysym, printprettysym, printlengthsym;\n    value_t printlevelsym, builtins_table_sym;\n\n    value_t LAMBDA, IF, TRYCATCH;\n    value_t BACKQUOTE, COMMA, COMMAAT, COMMADOT, FUNCTION;\n\n    value_t pairsym, symbolsym, fixnumsym, vectorsym, builtinsym, vu8sym;\n    value_t definesym, defmacrosym, forsym, setqsym;\n    value_t tsym, Tsym, fsym, Fsym, booleansym, nullsym, evalsym, fnsym;\n    // for reading characters\n    value_t nulsym, alarmsym, backspacesym, tabsym, linefeedsym, newlinesym;\n    value_t vtabsym, pagesym, returnsym, escsym, spacesym, deletesym;\n\n    struct _fl_readstate_t *readstate;\n\n    unsigned char *fromspace;\n    unsigned char *tospace;\n    unsigned char *curheap;\n    unsigned char *lim;\n    uint32_t heapsize;//bytes\n    uint32_t *consflags;\n\n    // error utilities --------------------------------------------------\n\n    // saved execution state for an unwind target\n    fl_exception_context_t *exc_ctx;\n    uint32_t throwing_frame;  // active frame when exception was thrown\n    value_t lasterror;\n\n    uint32_t gensym_ctr;\n    // two static buffers for gensym printing so there can be two\n    // gensym names available at a time, mostly for compare()\n    char gsname[2][16];\n    int gsnameno;\n\n    void *tochain;\n    long long n_allocd;\n\n    value_t the_empty_vector;\n    value_t memory_exception_value;\n\n    int gc_grew;\n    cons_t *apply_c;\n    value_t *apply_pv;\n    int64_t apply_accum;\n    value_t apply_func, apply_v, apply_e;\n\n    value_t jl_sym;\n    // persistent buffer (avoid repeated malloc/free)\n    // for julia_extensions.c: normalize\n    size_t jlbuflen;\n    void *jlbuf;\n};\n\nstatic inline void argcount(fl_context_t *fl_ctx, const char *fname, uint32_t nargs, uint32_t c)\n{\n    if (__unlikely(nargs != c))\n        lerrorf(fl_ctx, fl_ctx->ArgError,\"%s: too %s arguments\", fname, nargs<c ? \"few\":\"many\");\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/src/flisp/cvalues.c": "#ifdef _P64\n#define NWORDS(sz) (((sz)+7)>>3)\n#else\n#define NWORDS(sz) (((sz)+3)>>2)\n#endif\n\nstruct prim_int16{ char a; int16_t i; };\nstruct prim_int32{ char a; int32_t i; };\nstruct prim_int64{ char a; int64_t i; };\nstruct prim_ptr{ char a;  void   *i; };\n\n// compute struct field alignment required for primitives\nstatic const int ALIGN2   = sizeof(struct prim_int16) - 2;\nstatic const int ALIGN4   = sizeof(struct prim_int32) - 4;\nstatic const int ALIGN8   = sizeof(struct prim_int64) - 8;\nstatic const int ALIGNPTR = sizeof(struct prim_ptr) - sizeof(void*);\n\nstatic void cvalue_init(fl_context_t *fl_ctx, fltype_t *type, value_t v, void *dest);\n\n// cvalues-specific builtins\nvalue_t cvalue_new(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nvalue_t cvalue_sizeof(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nvalue_t cvalue_typeof(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\n\n// trigger unconditional GC after this many bytes are allocated\n#define ALLOC_LIMIT_TRIGGER 67108864\n\nvoid add_finalizer(fl_context_t *fl_ctx, cvalue_t *cv)\n{\n    if (fl_ctx->nfinalizers == fl_ctx->maxfinalizers) {\n        size_t nn = (fl_ctx->maxfinalizers==0 ? 256 : fl_ctx->maxfinalizers*2);\n        cvalue_t **temp = (cvalue_t**)realloc(fl_ctx->Finalizers, nn*sizeof(value_t));\n        if (temp == NULL)\n            lerror(fl_ctx, fl_ctx->OutOfMemoryError, \"out of memory\");\n        fl_ctx->Finalizers = temp;\n        fl_ctx->maxfinalizers = nn;\n    }\n    fl_ctx->Finalizers[fl_ctx->nfinalizers++] = cv;\n}\n\n// remove dead objects from finalization list in-place\nstatic void sweep_finalizers(fl_context_t *fl_ctx)\n{\n    cvalue_t **lst = fl_ctx->Finalizers;\n    size_t n=0, ndel=0, l=fl_ctx->nfinalizers;\n    cvalue_t *tmp;\n#define SWAP_sf(a,b) (tmp=a,a=b,b=tmp,1)\n    if (l == 0)\n        return;\n    do {\n        tmp = lst[n];\n        if (isforwarded((value_t)tmp)) {\n            // object is alive\n            lst[n] = (cvalue_t*)ptr(forwardloc((value_t)tmp));\n            n++;\n        }\n        else {\n            fltype_t *t = cv_class(tmp);\n            if (t->vtable != NULL && t->vtable->finalize != NULL) {\n                t->vtable->finalize(fl_ctx, tagptr(tmp, TAG_CVALUE));\n            }\n            if (!isinlined(tmp) && owned(tmp)) {\n#ifdef DEBUG\n                memset(cv_data(tmp), 0xbb, cv_len(tmp));\n#endif\n                free(cv_data(tmp));\n            }\n            ndel++;\n        }\n    } while ((n < l-ndel) && SWAP_sf(lst[n],lst[n+ndel]));\n\n    fl_ctx->nfinalizers -= ndel;\n#ifdef VERBOSEGC\n    if (ndel > 0)\n        printf(\"GC: finalized %d objects\\n\", ndel);\n#endif\n\n    fl_ctx->malloc_pressure = 0;\n}\n\n// compute the size of the metadata object for a cvalue\nstatic size_t cv_nwords(fl_context_t *fl_ctx, cvalue_t *cv)\n{\n    if (isinlined(cv)) {\n        size_t n = cv_len(cv);\n        if (n==0 || cv_isstr(fl_ctx, cv))\n            n++;\n        return CVALUE_NWORDS - 1 + NWORDS(n);\n    }\n    return CVALUE_NWORDS;\n}\n\nstatic void autorelease(fl_context_t *fl_ctx, cvalue_t *cv)\n{\n    cv->type = (fltype_t*)(((uintptr_t)cv->type) | CV_OWNED_BIT);\n    add_finalizer(fl_ctx, cv);\n}\n\nvoid cv_autorelease(fl_context_t *fl_ctx, cvalue_t *cv)\n{\n    autorelease(fl_ctx, cv);\n}\n\nstatic value_t cprim(fl_context_t *fl_ctx, fltype_t *type, size_t sz)\n{\n    cprim_t *pcp = (cprim_t*)alloc_words(fl_ctx, CPRIM_NWORDS-1+NWORDS(sz));\n    pcp->type = type;\n    return tagptr(pcp, TAG_CPRIM);\n}\n\nvalue_t cvalue(fl_context_t *fl_ctx, fltype_t *type, size_t sz)\n{\n    cvalue_t *pcv;\n    int str=0;\n\n    if (valid_numtype(type->numtype)) {\n        return cprim(fl_ctx, type, sz);\n    }\n    if (type->eltype == fl_ctx->bytetype) {\n        if (sz == 0)\n            return symbol_value(fl_ctx->emptystringsym);\n        sz++;\n        str=1;\n    }\n    if (sz <= MAX_INL_SIZE) {\n        size_t nw = CVALUE_NWORDS - 1 + NWORDS(sz) + (sz==0 ? 1 : 0);\n        pcv = (cvalue_t*)alloc_words(fl_ctx, nw);\n        pcv->type = type;\n        pcv->data = &pcv->_space[0];\n        if (type->vtable != NULL && type->vtable->finalize != NULL)\n            add_finalizer(fl_ctx, pcv);\n    }\n    else {\n        if (fl_ctx->malloc_pressure > ALLOC_LIMIT_TRIGGER)\n            gc(fl_ctx, 0);\n        pcv = (cvalue_t*)alloc_words(fl_ctx, CVALUE_NWORDS);\n        pcv->type = type;\n        pcv->data = malloc(sz);\n        autorelease(fl_ctx, pcv);\n        fl_ctx->malloc_pressure += sz;\n    }\n    if (str) {\n        sz--;\n        ((char*)pcv->data)[sz] = '\\0';\n    }\n    pcv->len = sz;\n    return tagptr(pcv, TAG_CVALUE);\n}\n\nvalue_t cvalue_from_data(fl_context_t *fl_ctx, fltype_t *type, void *data, size_t sz)\n{\n    value_t cv;\n    cv = cvalue(fl_ctx, type, sz);\n    memcpy(cptr(cv), data, sz);\n    return cv;\n}\n\n// this effectively dereferences a pointer\n// just like *p in C, it only removes a level of indirection from the type,\n// it doesn't copy any data.\n// this method of creating a cvalue only allocates metadata.\n// ptr is user-managed; we don't autorelease it unless the\n// user explicitly calls (autorelease ) on the result of this function.\n// 'parent' is an optional cvalue that this pointer is known to point\n// into; fl_ctx->NIL if none.\nvalue_t cvalue_from_ref(fl_context_t *fl_ctx, fltype_t *type, void *ptr, size_t sz, value_t parent)\n{\n    cvalue_t *pcv;\n    value_t cv;\n\n    pcv = (cvalue_t*)alloc_words(fl_ctx, CVALUE_NWORDS);\n    pcv->data = ptr;\n    pcv->len = sz;\n    pcv->type = type;\n    if (parent != fl_ctx->NIL) {\n        pcv->type = (fltype_t*)(((uintptr_t)pcv->type) | CV_PARENT_BIT);\n        pcv->parent = parent;\n    }\n    cv = tagptr(pcv, TAG_CVALUE);\n    return cv;\n}\n\nvalue_t cvalue_string(fl_context_t *fl_ctx, size_t sz)\n{\n    return cvalue(fl_ctx, fl_ctx->stringtype, sz);\n}\n\nvalue_t cvalue_static_cstrn(fl_context_t *fl_ctx, const char *str, size_t n)\n{\n    return cvalue_from_ref(fl_ctx, fl_ctx->stringtype, (char*)str, n, fl_ctx->NIL);\n}\n\nvalue_t cvalue_static_cstring(fl_context_t *fl_ctx, const char *str)\n{\n    return cvalue_static_cstrn(fl_ctx, str, strlen(str));\n}\n\nvalue_t string_from_cstrn(fl_context_t *fl_ctx, char *str, size_t n)\n{\n    value_t v = cvalue_string(fl_ctx, n);\n    memcpy(cvalue_data(v), str, n);\n    return v;\n}\n\nvalue_t string_from_cstr(fl_context_t *fl_ctx, char *str)\n{\n    return string_from_cstrn(fl_ctx, str, strlen(str));\n}\n\nint fl_isstring(fl_context_t *fl_ctx, value_t v)\n{\n    return (iscvalue(v) && cv_isstr(fl_ctx, (cvalue_t*)ptr(v)));\n}\n\n// convert to malloc representation (fixed address)\nvoid cv_pin(fl_context_t *fl_ctx, cvalue_t *cv)\n{\n    if (!isinlined(cv))\n        return;\n    size_t sz = cv_len(cv);\n    if (cv_isstr(fl_ctx, cv)) sz++;\n    void *data = malloc(sz);\n    memcpy(data, cv_data(cv), sz);\n    cv->data = data;\n    autorelease(fl_ctx, cv);\n}\n\n#define num_init(ctype, cnvt, tag)                                     \\\nstatic int cvalue_##ctype##_init(fl_context_t *fl_ctx, fltype_t *type, \\\n                                 value_t arg, void *dest)              \\\n{                                                                      \\\n    fl_##ctype##_t n=0;                                                \\\n    (void)type;                                                        \\\n    if (isfixnum(arg)) {                                               \\\n        n = numval(arg);                                               \\\n    }                                                                  \\\n    else if (iscprim(arg)) {                                           \\\n        cprim_t *cp = (cprim_t*)ptr(arg);                              \\\n        void *p = cp_data(cp);                                         \\\n        n = (fl_##ctype##_t)conv_to_##cnvt(p, cp_numtype(cp));         \\\n    }                                                                  \\\n    else {                                                             \\\n        return 1;                                                      \\\n    }                                                                  \\\n    *((fl_##ctype##_t*)dest) = n;                                      \\\n    return 0;                                                          \\\n}\nnum_init(int8, int32, T_INT8)\nnum_init(uint8, uint32, T_UINT8)\nnum_init(int16, int32, T_INT16)\nnum_init(uint16, uint32, T_UINT16)\nnum_init(int32, int32, T_INT32)\nnum_init(uint32, uint32, T_UINT32)\nnum_init(int64, int64, T_INT64)\nnum_init(uint64, uint64, T_UINT64)\nnum_init(float, double, T_FLOAT)\nnum_init(double, double, T_DOUBLE)\n\n#define num_ctor_init(typenam, ctype, tag)                              \\\nvalue_t cvalue_##typenam(fl_context_t *fl_ctx, value_t *args, uint32_t nargs) \\\n{                                                                       \\\n    if (nargs==0) { PUSH(fl_ctx, fixnum(0)); args = &fl_ctx->Stack[fl_ctx->SP-1]; } \\\n    value_t cp = cprim(fl_ctx, fl_ctx->typenam##type, sizeof(fl_##ctype##_t)); \\\n    if (cvalue_##ctype##_init(fl_ctx, fl_ctx->typenam##type,            \\\n                              args[0], cp_data((cprim_t*)ptr(cp))))     \\\n        type_error(fl_ctx, #typenam, \"number\", args[0]);                \\\n    return cp;                                                          \\\n}\n\n#define num_ctor_ctor(typenam, ctype, tag)                              \\\nvalue_t mk_##typenam(fl_context_t *fl_ctx, fl_##ctype##_t n)            \\\n{                                                                       \\\n    value_t cp = cprim(fl_ctx, fl_ctx->typenam##type, sizeof(fl_##ctype##_t)); \\\n    *(fl_##ctype##_t*)cp_data((cprim_t*)ptr(cp)) = n;                   \\\n    return cp;                                                          \\\n}\n\n#define num_ctor(typenam, ctype, tag)  \\\n    num_ctor_init(typenam, ctype, tag) \\\n    num_ctor_ctor(typenam, ctype, tag)\n\nnum_ctor(int8, int8, T_INT8)\nnum_ctor(uint8, uint8, T_UINT8)\nnum_ctor(int16, int16, T_INT16)\nnum_ctor(uint16, uint16, T_UINT16)\nnum_ctor(int32, int32, T_INT32)\nnum_ctor(uint32, uint32, T_UINT32)\nnum_ctor(int64, int64, T_INT64)\nnum_ctor(uint64, uint64, T_UINT64)\nnum_ctor(byte,  uint8, T_UINT8)\nnum_ctor(wchar, int32, T_INT32)\n#ifdef _P64\nnum_ctor(ptrdiff, int64, T_INT64)\nnum_ctor(size, uint64, T_UINT64)\n#else\nnum_ctor(ptrdiff, int32, T_INT32)\nnum_ctor(size, uint32, T_UINT32)\n#endif\nnum_ctor(float, float, T_FLOAT)\nnum_ctor(double, double, T_DOUBLE)\n\nvalue_t size_wrap(fl_context_t *fl_ctx, size_t sz)\n{\n    if (fits_fixnum(sz))\n        return fixnum(sz);\n    assert(sizeof(void*) == sizeof(size_t));\n    return mk_size(fl_ctx, sz);\n}\n\nsize_t tosize(fl_context_t *fl_ctx, value_t n, const char *fname)\n{\n    if (isfixnum(n))\n        return numval(n);\n    if (iscprim(n)) {\n        cprim_t *cp = (cprim_t*)ptr(n);\n        return conv_to_size(cp_data(cp), cp_numtype(cp));\n    }\n    type_error(fl_ctx, fname, \"number\", n);\n    return 0;\n}\n\nstatic int isarray(value_t v)\n{\n    return iscvalue(v) && cv_class((cvalue_t*)ptr(v))->eltype != NULL;\n}\n\nstatic size_t predict_arraylen(fl_context_t *fl_ctx, value_t arg)\n{\n    if (isvector(arg))\n        return vector_size(arg);\n    else if (iscons(arg))\n        return llength(arg);\n    else if (arg == fl_ctx->NIL)\n        return 0;\n    if (isarray(arg))\n        return cvalue_arraylen(arg);\n    return 1;\n}\n\nstatic int cvalue_array_init(fl_context_t *fl_ctx, fltype_t *ft, value_t arg, void *dest)\n{\n    value_t type = ft->type;\n    size_t elsize, i, cnt, sz;\n    fltype_t *eltype = ft->eltype;\n\n    elsize = ft->elsz;\n    cnt = predict_arraylen(fl_ctx, arg);\n\n    if (iscons(cdr_(cdr_(type)))) {\n        size_t tc = tosize(fl_ctx, car_(cdr_(cdr_(type))), \"array\");\n        if (tc != cnt)\n            lerror(fl_ctx, fl_ctx->ArgError, \"array: size mismatch\");\n    }\n\n    sz = elsize * cnt;\n\n    if (isvector(arg)) {\n        for(i=0; i < cnt; i++) {\n            cvalue_init(fl_ctx, eltype, vector_elt(arg,i), dest);\n            dest = (char *)dest + elsize;\n        }\n        return 0;\n    }\n    else if (iscons(arg) || arg==fl_ctx->NIL) {\n        i = 0;\n        while (iscons(arg)) {\n            if (i == cnt) { i++; break; } // trigger error\n            cvalue_init(fl_ctx, eltype, car_(arg), dest);\n            i++;\n            dest = (char *)dest + elsize;\n            arg = cdr_(arg);\n        }\n        if (i != cnt)\n            lerror(fl_ctx, fl_ctx->ArgError, \"array: size mismatch\");\n        return 0;\n    }\n    else if (iscvalue(arg)) {\n        cvalue_t *cv = (cvalue_t*)ptr(arg);\n        if (isarray(arg)) {\n            fltype_t *aet = cv_class(cv)->eltype;\n            if (aet == eltype) {\n                if (cv_len(cv) == sz)\n                    memcpy(dest, cv_data(cv), sz);\n                else\n                    lerror(fl_ctx, fl_ctx->ArgError, \"array: size mismatch\");\n                return 0;\n            }\n            else {\n                // TODO: initialize array from different type elements\n                lerror(fl_ctx, fl_ctx->ArgError, \"array: element type mismatch\");\n            }\n        }\n    }\n    if (cnt == 1)\n        cvalue_init(fl_ctx, eltype, arg, dest);\n    else\n        type_error(fl_ctx, \"array\", \"sequence\", arg);\n    return 0;\n}\n\nvalue_t cvalue_array(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    size_t elsize, cnt, sz, i;\n    value_t arg;\n\n    if (nargs < 1)\n        argcount(fl_ctx, \"array\", nargs, 1);\n\n    cnt = nargs - 1;\n    fltype_t *type = get_array_type(fl_ctx, args[0]);\n    elsize = type->elsz;\n    sz = elsize * cnt;\n\n    value_t cv = cvalue(fl_ctx, type, sz);\n    char *dest = (char*)cv_data((cvalue_t*)ptr(cv));\n    FOR_ARGS(i,1,arg,args) {\n        cvalue_init(fl_ctx, type->eltype, arg, dest);\n        dest += elsize;\n    }\n    return cv;\n}\n\n// NOTE: v must be an array\nsize_t cvalue_arraylen(value_t v)\n{\n    cvalue_t *cv = (cvalue_t*)ptr(v);\n    return cv_len(cv)/(cv_class(cv)->elsz);\n}\n\n// *palign is an output argument giving the alignment required by type\nsize_t ctype_sizeof(fl_context_t *fl_ctx, value_t type, int *palign)\n{\n    if (type == fl_ctx->int8sym || type == fl_ctx->uint8sym || type == fl_ctx->bytesym) {\n        *palign = 1;\n        return 1;\n    }\n    if (type == fl_ctx->int16sym || type == fl_ctx->uint16sym) {\n        *palign = ALIGN2;\n        return 2;\n    }\n    if (type == fl_ctx->int32sym || type == fl_ctx->uint32sym || type == fl_ctx->wcharsym ||\n        type == fl_ctx->floatsym) {\n        *palign = ALIGN4;\n        return 4;\n    }\n    if (type == fl_ctx->int64sym || type == fl_ctx->uint64sym || type == fl_ctx->doublesym) {\n        *palign = ALIGN8;\n        return 8;\n    }\n    if (type == fl_ctx->ptrdiffsym || type == fl_ctx->sizesym) {\n#ifdef _P64\n        *palign = ALIGN8;\n        return 8;\n#else\n        *palign = ALIGN4;\n        return 4;\n#endif\n    }\n    if (iscons(type)) {\n        value_t hed = car_(type);\n        if (hed == fl_ctx->pointersym || hed == fl_ctx->cfunctionsym) {\n            *palign = ALIGNPTR;\n            return sizeof(void*);\n        }\n        if (hed == fl_ctx->arraysym) {\n            value_t t = car(fl_ctx, cdr_(type));\n            if (!iscons(cdr_(cdr_(type))))\n                lerror(fl_ctx, fl_ctx->ArgError, \"sizeof: incomplete type\");\n            value_t n = car_(cdr_(cdr_(type)));\n            size_t sz = tosize(fl_ctx, n, \"sizeof\");\n            return sz * ctype_sizeof(fl_ctx, t, palign);\n        }\n    }\n    lerror(fl_ctx, fl_ctx->ArgError, \"sizeof: invalid c type\");\n    return 0;\n}\n\n// get pointer and size for any plain-old-data value\nvoid to_sized_ptr(fl_context_t *fl_ctx, value_t v, const char *fname, char **pdata, size_t *psz)\n{\n    if (iscvalue(v)) {\n        cvalue_t *pcv = (cvalue_t*)ptr(v);\n        ios_t *x = value2c(ios_t*,v);\n        if (cv_class(pcv) == fl_ctx->iostreamtype && (x->bm == bm_mem)) {\n            *pdata = x->buf;\n            *psz = (size_t)x->size;\n            return;\n        }\n        else if (cv_isPOD(pcv)) {\n            *pdata = (char*)cv_data(pcv);\n            *psz = cv_len(pcv);\n            return;\n        }\n    }\n    else if (iscprim(v)) {\n        cprim_t *pcp = (cprim_t*)ptr(v);\n        *pdata = cp_data(pcp);\n        *psz = cp_class(pcp)->size;\n        return;\n    }\n    type_error(fl_ctx, fname, \"plain-old-data\", v);\n}\n\nvalue_t cvalue_sizeof(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    argcount(fl_ctx, \"sizeof\", nargs, 1);\n    if (issymbol(args[0]) || iscons(args[0])) {\n        int a;\n        return size_wrap(fl_ctx, ctype_sizeof(fl_ctx, args[0], &a));\n    }\n    size_t n; char *data;\n    to_sized_ptr(fl_ctx, args[0], \"sizeof\", &data, &n);\n    return size_wrap(fl_ctx, n);\n}\n\nvalue_t cvalue_typeof(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    argcount(fl_ctx, \"typeof\", nargs, 1);\n    switch(tag(args[0])) {\n    case TAG_CONS: return fl_ctx->pairsym;\n    case TAG_NUM1:\n    case TAG_NUM:  return fl_ctx->fixnumsym;\n    case TAG_SYM:  return fl_ctx->symbolsym;\n    case TAG_VECTOR: return fl_ctx->vectorsym;\n    case TAG_FUNCTION:\n        if (args[0] == fl_ctx->T || args[0] == fl_ctx->F)\n            return fl_ctx->booleansym;\n        if (args[0] == fl_ctx->NIL)\n            return fl_ctx->nullsym;\n        if (args[0] == fl_ctx->FL_EOF)\n            return symbol(fl_ctx, \"eof-object\");\n        if (isbuiltin(args[0]))\n            return fl_ctx->builtinsym;\n        return fl_ctx->FUNCTION;\n    }\n    return cv_type((cvalue_t*)ptr(args[0]));\n}\n\nstatic value_t cvalue_relocate(fl_context_t *fl_ctx, value_t v)\n{\n    size_t nw;\n    cvalue_t *cv = (cvalue_t*)ptr(v);\n    cvalue_t *nv;\n    value_t ncv;\n\n    nw = cv_nwords(fl_ctx, cv);\n    nv = (cvalue_t*)alloc_words(fl_ctx, nw);\n    memcpy(nv, cv, nw*sizeof(value_t));\n    if (isinlined(cv))\n        nv->data = &nv->_space[0];\n    ncv = tagptr(nv, TAG_CVALUE);\n    fltype_t *t = cv_class(cv);\n    if (t->vtable != NULL && t->vtable->relocate != NULL)\n        t->vtable->relocate(fl_ctx, v, ncv);\n    forward(v, ncv);\n    return ncv;\n}\n\nvalue_t cvalue_copy(fl_context_t *fl_ctx, value_t v)\n{\n    assert(iscvalue(v));\n    PUSH(fl_ctx, v);\n    cvalue_t *cv = (cvalue_t*)ptr(v);\n    size_t nw = cv_nwords(fl_ctx, cv);\n    cvalue_t *ncv = (cvalue_t*)alloc_words(fl_ctx, nw);\n    v = POP(fl_ctx); cv = (cvalue_t*)ptr(v);\n    memcpy(ncv, cv, nw * sizeof(value_t));\n    if (!isinlined(cv)) {\n        size_t len = cv_len(cv);\n        if (cv_isstr(fl_ctx, cv)) len++;\n        ncv->data = malloc(len);\n        memcpy(ncv->data, cv_data(cv), len);\n        autorelease(fl_ctx, ncv);\n        if (hasparent(cv)) {\n            ncv->type = (fltype_t*)(((uintptr_t)ncv->type) & ~CV_PARENT_BIT);\n            ncv->parent = fl_ctx->NIL;\n        }\n    }\n    else {\n        ncv->data = &ncv->_space[0];\n    }\n\n    return tagptr(ncv, TAG_CVALUE);\n}\n\nvalue_t fl_copy(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    argcount(fl_ctx, \"copy\", nargs, 1);\n    if (iscons(args[0]) || isvector(args[0]))\n        lerror(fl_ctx, fl_ctx->ArgError, \"copy: argument must be a leaf atom\");\n    if (!iscvalue(args[0]))\n        return args[0];\n    if (!cv_isPOD((cvalue_t*)ptr(args[0])))\n        lerror(fl_ctx, fl_ctx->ArgError, \"copy: argument must be a plain-old-data type\");\n    return cvalue_copy(fl_ctx, args[0]);\n}\n\nvalue_t fl_podp(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    argcount(fl_ctx, \"plain-old-data?\", nargs, 1);\n    return (iscprim(args[0]) ||\n            (iscvalue(args[0]) && cv_isPOD((cvalue_t*)ptr(args[0])))) ?\n        fl_ctx->T : fl_ctx->F;\n}\n\nstatic void cvalue_init(fl_context_t *fl_ctx, fltype_t *type, value_t v, void *dest)\n{\n    cvinitfunc_t f=type->init;\n\n    if (f == NULL)\n        lerror(fl_ctx, fl_ctx->ArgError, \"c-value: invalid c type\");\n\n    f(fl_ctx, type, v, dest);\n}\n\nstatic numerictype_t sym_to_numtype(fl_context_t *fl_ctx, value_t type)\n{\n    if (type == fl_ctx->int8sym)\n        return T_INT8;\n    else if (type == fl_ctx->uint8sym || type == fl_ctx->bytesym)\n        return T_UINT8;\n    else if (type == fl_ctx->int16sym)\n        return T_INT16;\n    else if (type == fl_ctx->uint16sym)\n        return T_UINT16;\n#ifdef _P64\n    else if (type == fl_ctx->int32sym || type == fl_ctx->wcharsym)\n#else\n    else if (type == fl_ctx->int32sym || type == fl_ctx->wcharsym || type == fl_ctx->ptrdiffsym)\n#endif\n        return T_INT32;\n#ifdef _P64\n    else if (type == fl_ctx->uint32sym)\n#else\n    else if (type == fl_ctx->uint32sym || type == fl_ctx->sizesym)\n#endif\n        return T_UINT32;\n#ifdef _P64\n    else if (type == fl_ctx->int64sym || type == fl_ctx->ptrdiffsym)\n#else\n    else if (type == fl_ctx->int64sym)\n#endif\n        return T_INT64;\n#ifdef _P64\n    else if (type == fl_ctx->uint64sym || type == fl_ctx->sizesym)\n#else\n    else if (type == fl_ctx->uint64sym)\n#endif\n        return T_UINT64;\n    else if (type == fl_ctx->floatsym)\n        return T_FLOAT;\n    else if (type == fl_ctx->doublesym)\n        return T_DOUBLE;\n    return (numerictype_t)N_NUMTYPES;\n}\n\n// (new type . args)\n// this provides (1) a way to allocate values with a shared type for\n// efficiency, (2) a uniform interface for allocating cvalues of any\n// type, including user-defined.\nvalue_t cvalue_new(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    if (nargs < 1 || nargs > 2)\n        argcount(fl_ctx, \"c-value\", nargs, 2);\n    value_t type = args[0];\n    fltype_t *ft = get_type(fl_ctx, type);\n    value_t cv;\n    if (ft->eltype != NULL) {\n        // special case to handle incomplete array types bla[]\n        size_t elsz = ft->elsz;\n        size_t cnt;\n\n        if (iscons(cdr_(cdr_(type))))\n            cnt = tosize(fl_ctx, car_(cdr_(cdr_(type))), \"array\");\n        else if (nargs == 2)\n            cnt = predict_arraylen(fl_ctx, args[1]);\n        else\n            cnt = 0;\n        cv = cvalue(fl_ctx, ft, elsz * cnt);\n        if (nargs == 2)\n            cvalue_array_init(fl_ctx, ft, args[1], cv_data((cvalue_t*)ptr(cv)));\n    }\n    else {\n        cv = cvalue(fl_ctx, ft, ft->size);\n        if (nargs == 2)\n            cvalue_init(fl_ctx, ft, args[1], cptr(cv));\n    }\n    return cv;\n}\n\n// NOTE: this only compares lexicographically; it ignores numeric formats\nvalue_t cvalue_compare(value_t a, value_t b)\n{\n    cvalue_t *ca = (cvalue_t*)ptr(a);\n    cvalue_t *cb = (cvalue_t*)ptr(b);\n    char *adata = (char*)cv_data(ca);\n    char *bdata = (char*)cv_data(cb);\n    size_t asz = cv_len(ca);\n    size_t bsz = cv_len(cb);\n    size_t minsz = asz < bsz ? asz : bsz;\n    int diff = memcmp(adata, bdata, minsz);\n    if (diff == 0) {\n        if (asz > bsz)\n            return fixnum(1);\n        else if (asz < bsz)\n            return fixnum(-1);\n    }\n    return fixnum(diff);\n}\n\nstatic void check_addr_args(fl_context_t *fl_ctx, const char *fname, value_t arr,\n                            value_t ind, char **data, size_t *index)\n{\n    size_t numel;\n    cvalue_t *cv = (cvalue_t*)ptr(arr);\n    *data = (char*)cv_data(cv);\n    numel = cv_len(cv)/(cv_class(cv)->elsz);\n    *index = tosize(fl_ctx, ind, fname);\n    if (*index >= numel)\n        bounds_error(fl_ctx, fname, arr, ind);\n}\n\nstatic value_t cvalue_array_aref(fl_context_t *fl_ctx, value_t *args)\n{\n    char *data; size_t index;\n    fltype_t *eltype = cv_class((cvalue_t*)ptr(args[0]))->eltype;\n    value_t el = 0;\n    numerictype_t nt = eltype->numtype;\n    if (nt >= T_INT32)\n        el = cvalue(fl_ctx, eltype, eltype->size);\n    check_addr_args(fl_ctx, \"aref\", args[0], args[1], &data, &index);\n    if (nt < T_INT32) {\n        if (nt == T_INT8)\n            return fixnum((int8_t)data[index]);\n        else if (nt == T_UINT8)\n            return fixnum((uint8_t)data[index]);\n        else if (nt == T_INT16)\n            return fixnum(((int16_t*)data)[index]);\n        return fixnum(((uint16_t*)data)[index]);\n    }\n    char *dest = (char*)cptr(el);\n    size_t sz = eltype->size;\n    if (sz == 1)\n        *dest = data[index];\n    else if (sz == 2)\n        *(int16_t*)dest = ((int16_t*)data)[index];\n    else if (sz == 4)\n        *(int32_t*)dest = ((int32_t*)data)[index];\n    else if (sz == 8)\n        *(int64_t*)dest = ((int64_t*)data)[index];\n    else\n        memcpy(dest, data + index*sz, sz);\n    return el;\n}\n\nstatic value_t cvalue_array_aset(fl_context_t *fl_ctx, value_t *args)\n{\n    char *data; size_t index;\n    fltype_t *eltype = cv_class((cvalue_t*)ptr(args[0]))->eltype;\n    check_addr_args(fl_ctx, \"aset!\", args[0], args[1], &data, &index);\n    char *dest = data + index*eltype->size;\n    cvalue_init(fl_ctx, eltype, args[2], dest);\n    return args[2];\n}\n\nvalue_t fl_builtin(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    argcount(fl_ctx, \"builtin\", nargs, 1);\n    symbol_t *name = tosymbol(fl_ctx, args[0], \"builtin\");\n    cvalue_t *cv;\n    if (ismanaged(fl_ctx, args[0]) || (cv=(cvalue_t*)name->dlcache) == NULL) {\n        lerrorf(fl_ctx, fl_ctx->ArgError, \"builtin: function %s not found\", name->name);\n    }\n    return tagptr(cv, TAG_CVALUE);\n}\n\nvalue_t cbuiltin(fl_context_t *fl_ctx, const char *name, builtin_t f)\n{\n    cvalue_t *cv = (cvalue_t*)malloc(CVALUE_NWORDS * sizeof(value_t));\n    cv->type = fl_ctx->builtintype;\n    cv->data = &cv->_space[0];\n    cv->len = sizeof(value_t);\n    *(void**)cv->data = (void*)f;\n\n    value_t sym = symbol(fl_ctx, name);\n    ((symbol_t*)ptr(sym))->dlcache = cv;\n    ptrhash_put(&fl_ctx->reverse_dlsym_lookup_table, cv, (void*)sym);\n\n    return tagptr(cv, TAG_CVALUE);\n}\n\nstatic value_t fl_logand(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nstatic value_t fl_logior(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nstatic value_t fl_logxor(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nstatic value_t fl_lognot(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nstatic value_t fl_ash(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\n\nstatic const builtinspec_t cvalues_builtin_info[] = {\n    { \"c-value\", cvalue_new },\n    { \"typeof\", cvalue_typeof },\n    { \"sizeof\", cvalue_sizeof },\n    { \"builtin\", fl_builtin },\n    { \"copy\", fl_copy },\n    { \"plain-old-data?\", fl_podp },\n\n    { \"logand\", fl_logand },\n    { \"logior\", fl_logior },\n    { \"logxor\", fl_logxor },\n    { \"lognot\", fl_lognot },\n    { \"ash\", fl_ash },\n    // todo: autorelease\n    { NULL, NULL }\n};\n\n#define cv_intern(fl_ctx, tok) fl_ctx->tok##sym = symbol(fl_ctx, #tok)\n#define ctor_cv_intern(fl_ctx, tok)                             \\\n    cv_intern(fl_ctx, tok);                                     \\\n    set(fl_ctx->tok##sym, cbuiltin(fl_ctx, #tok, cvalue_##tok))\n\n#define mk_primtype(fl_ctx, name)                               \\\n    fl_ctx->name##type = get_type(fl_ctx, fl_ctx->name##sym);   \\\n    fl_ctx->name##type->init = &cvalue_##name##_init\n\n#define mk_primtype_(fl_ctx, name, ctype)                       \\\n    fl_ctx->name##type = get_type(fl_ctx, fl_ctx->name##sym);   \\\n    fl_ctx->name##type->init = &cvalue_##ctype##_init\n\nstatic void cvalues_init(fl_context_t *fl_ctx)\n{\n    fl_ctx->malloc_pressure = 0;\n    fl_ctx->Finalizers = NULL;\n    fl_ctx->nfinalizers = 0;\n    fl_ctx->maxfinalizers = 0;\n\n    htable_new(&fl_ctx->TypeTable, 256);\n    htable_new(&fl_ctx->reverse_dlsym_lookup_table, 256);\n\n    fl_ctx->builtintype = define_opaque_type(fl_ctx->builtinsym, sizeof(builtin_t), NULL, NULL);\n\n    ctor_cv_intern(fl_ctx, int8);\n    ctor_cv_intern(fl_ctx, uint8);\n    ctor_cv_intern(fl_ctx, int16);\n    ctor_cv_intern(fl_ctx, uint16);\n    ctor_cv_intern(fl_ctx, int32);\n    ctor_cv_intern(fl_ctx, uint32);\n    ctor_cv_intern(fl_ctx, int64);\n    ctor_cv_intern(fl_ctx, uint64);\n    ctor_cv_intern(fl_ctx, byte);\n    ctor_cv_intern(fl_ctx, wchar);\n    ctor_cv_intern(fl_ctx, ptrdiff);\n    ctor_cv_intern(fl_ctx, size);\n    ctor_cv_intern(fl_ctx, float);\n    ctor_cv_intern(fl_ctx, double);\n\n    ctor_cv_intern(fl_ctx, array);\n    cv_intern(fl_ctx, pointer);\n    cv_intern(fl_ctx, void);\n    fl_ctx->cfunctionsym = symbol(fl_ctx, \"c-function\");\n\n    assign_global_builtins(fl_ctx, cvalues_builtin_info);\n\n    fl_ctx->stringtypesym = symbol(fl_ctx, \"*string-type*\");\n    setc(fl_ctx->stringtypesym, fl_list2(fl_ctx, fl_ctx->arraysym, fl_ctx->bytesym));\n\n    fl_ctx->wcstringtypesym = symbol(fl_ctx, \"*wcstring-type*\");\n    setc(fl_ctx->wcstringtypesym, fl_list2(fl_ctx, fl_ctx->arraysym, fl_ctx->wcharsym));\n\n    mk_primtype(fl_ctx, int8);\n    mk_primtype(fl_ctx, uint8);\n    mk_primtype(fl_ctx, int16);\n    mk_primtype(fl_ctx, uint16);\n    mk_primtype(fl_ctx, int32);\n    mk_primtype(fl_ctx, uint32);\n    mk_primtype(fl_ctx, int64);\n    mk_primtype(fl_ctx, uint64);\n#ifdef _P64\n    mk_primtype_(fl_ctx, ptrdiff, int64);\n    mk_primtype_(fl_ctx, size, uint64);\n#else\n    mk_primtype_(fl_ctx, ptrdiff, int32);\n    mk_primtype_(fl_ctx, size, uint32);\n#endif\n    mk_primtype_(fl_ctx, byte, uint8);\n    mk_primtype_(fl_ctx, wchar, int32);\n    mk_primtype(fl_ctx, float);\n    mk_primtype(fl_ctx, double);\n\n    fl_ctx->stringtype = get_type(fl_ctx, symbol_value(fl_ctx->stringtypesym));\n    fl_ctx->wcstringtype = get_type(fl_ctx, symbol_value(fl_ctx->wcstringtypesym));\n\n    fl_ctx->emptystringsym = symbol(fl_ctx, \"*empty-string*\");\n    setc(fl_ctx->emptystringsym, cvalue_static_cstring(fl_ctx, \"\"));\n}\n\n#define RETURN_NUM_AS(fl_ctx, var, type) return(mk_##type(fl_ctx, (fl_##type##_t)var))\n\nvalue_t return_from_uint64(fl_context_t *fl_ctx, uint64_t Uaccum)\n{\n    if (fits_fixnum(Uaccum)) {\n        return fixnum((fixnum_t)Uaccum);\n    }\n    if (Uaccum > (uint64_t)S64_MAX) {\n        RETURN_NUM_AS(fl_ctx, Uaccum, uint64);\n    }\n    else if (Uaccum > (uint64_t)INT_MAX) {\n        RETURN_NUM_AS(fl_ctx, Uaccum, int64);\n    }\n    RETURN_NUM_AS(fl_ctx, Uaccum, int32);\n}\n\nvalue_t return_from_int64(fl_context_t *fl_ctx, int64_t Saccum)\n{\n    if (fits_fixnum(Saccum)) {\n        return fixnum((fixnum_t)Saccum);\n    }\n    if (Saccum > (int64_t)INT_MAX || Saccum < (int64_t)INT_MIN) {\n        RETURN_NUM_AS(fl_ctx, Saccum, int64);\n    }\n    RETURN_NUM_AS(fl_ctx, Saccum, int32);\n}\n\nstatic value_t fl_add_any(fl_context_t *fl_ctx, value_t *args, uint32_t nargs, fixnum_t carryIn)\n{\n    uint64_t Uaccum=0;\n    int64_t Saccum = carryIn;\n    double Faccum=0;\n    uint32_t i;\n    value_t arg=fl_ctx->NIL;\n\n    FOR_ARGS(i,0,arg,args) {\n        if (isfixnum(arg)) {\n            Saccum += numval(arg);\n            continue;\n        }\n        else if (iscprim(arg)) {\n            cprim_t *cp = (cprim_t*)ptr(arg);\n            void *a = cp_data(cp);\n            int64_t i64;\n            switch(cp_numtype(cp)) {\n            case T_INT8:   Saccum += *(int8_t*)a; break;\n            case T_UINT8:  Saccum += *(uint8_t*)a; break;\n            case T_INT16:  Saccum += *(int16_t*)a; break;\n            case T_UINT16: Saccum += *(uint16_t*)a; break;\n            case T_INT32:  Saccum += *(int32_t*)a; break;\n            case T_UINT32: Saccum += *(uint32_t*)a; break;\n            case T_INT64:\n                i64 = *(int64_t*)a;\n                if (i64 > 0)\n                    Uaccum += (uint64_t)i64;\n                else\n                    Saccum += i64;\n                break;\n            case T_UINT64: Uaccum += *(uint64_t*)a; break;\n            case T_FLOAT:  Faccum += *(float*)a; break;\n            case T_DOUBLE: Faccum += *(double*)a; break;\n            default:\n                goto add_type_error;\n            }\n            continue;\n        }\n    add_type_error:\n        type_error(fl_ctx, \"+\", \"number\", arg);\n    }\n    if (Faccum != 0) {\n        Faccum += Uaccum;\n        Faccum += Saccum;\n        return mk_double(fl_ctx, Faccum);\n    }\n    else if (Saccum < 0) {\n        uint64_t negpart = (uint64_t)(-Saccum);\n        if (negpart > Uaccum) {\n            Saccum += (int64_t)Uaccum;\n            // return value in Saccum\n            if (Saccum >= INT_MIN) {\n                if (fits_fixnum(Saccum)) {\n                    return fixnum((fixnum_t)Saccum);\n                }\n                RETURN_NUM_AS(fl_ctx, Saccum, int32);\n            }\n            RETURN_NUM_AS(fl_ctx, Saccum, int64);\n        }\n        Uaccum -= negpart;\n    }\n    else {\n        Uaccum += (uint64_t)Saccum;\n    }\n    // return value in Uaccum\n    return return_from_uint64(fl_ctx, Uaccum);\n}\n\nstatic value_t fl_neg(fl_context_t *fl_ctx, value_t n)\n{\n    if (isfixnum(n)) {\n        return fixnum(-numval(n));\n    }\n    else if (iscprim(n)) {\n        cprim_t *cp = (cprim_t*)ptr(n);\n        void *a = cp_data(cp);\n        uint32_t ui32;\n        int32_t i32;\n        int64_t i64;\n        switch(cp_numtype(cp)) {\n        case T_INT8:   return fixnum(-(int32_t)*(int8_t*)a);\n        case T_UINT8:  return fixnum(-(int32_t)*(uint8_t*)a);\n        case T_INT16:  return fixnum(-(int32_t)*(int16_t*)a);\n        case T_UINT16: return fixnum(-(int32_t)*(uint16_t*)a);\n        case T_INT32:\n            i32 = *(int32_t*)a;\n            if (i32 == (int32_t)BIT31)\n                return mk_uint32(fl_ctx, (uint32_t)BIT31);\n            return mk_int32(fl_ctx, -i32);\n        case T_UINT32:\n            ui32 = *(uint32_t*)a;\n            if (ui32 <= ((uint32_t)INT_MAX)+1) return mk_int32(fl_ctx, -(int32_t)ui32);\n            return mk_int64(fl_ctx, -(int64_t)ui32);\n        case T_INT64:\n            i64 = *(int64_t*)a;\n            if (i64 == (int64_t)BIT63)\n                return mk_uint64(fl_ctx, (uint64_t)BIT63);\n            return mk_int64(fl_ctx, -i64);\n        case T_UINT64: return mk_int64(fl_ctx, -(int64_t)*(uint64_t*)a);\n        case T_FLOAT:  return mk_float(fl_ctx, -*(float*)a);\n        case T_DOUBLE: return mk_double(fl_ctx, -*(double*)a);\n            break;\n        }\n    }\n    type_error(fl_ctx, \"-\", \"number\", n);\n}\n\nstatic value_t fl_mul_any(fl_context_t *fl_ctx, value_t *args, uint32_t nargs, int64_t Saccum)\n{\n    uint64_t Uaccum=1;\n    double Faccum=1;\n    uint32_t i;\n    value_t arg=fl_ctx->NIL;\n\n    FOR_ARGS(i,0,arg,args) {\n        if (isfixnum(arg)) {\n            Saccum *= numval(arg);\n            continue;\n        }\n        else if (iscprim(arg)) {\n            cprim_t *cp = (cprim_t*)ptr(arg);\n            void *a = cp_data(cp);\n            int64_t i64;\n            switch(cp_numtype(cp)) {\n            case T_INT8:   Saccum *= *(int8_t*)a; break;\n            case T_UINT8:  Saccum *= *(uint8_t*)a; break;\n            case T_INT16:  Saccum *= *(int16_t*)a; break;\n            case T_UINT16: Saccum *= *(uint16_t*)a; break;\n            case T_INT32:  Saccum *= *(int32_t*)a; break;\n            case T_UINT32: Saccum *= *(uint32_t*)a; break;\n            case T_INT64:\n                i64 = *(int64_t*)a;\n                if (i64 > 0)\n                    Uaccum *= (uint64_t)i64;\n                else\n                    Saccum *= i64;\n                break;\n            case T_UINT64: Uaccum *= *(uint64_t*)a; break;\n            case T_FLOAT:  Faccum *= *(float*)a; break;\n            case T_DOUBLE: Faccum *= *(double*)a; break;\n            default:\n                goto mul_type_error;\n            }\n            continue;\n        }\n    mul_type_error:\n        type_error(fl_ctx, \"*\", \"number\", arg);\n    }\n    if (Faccum != 1) {\n        Faccum *= Uaccum;\n        Faccum *= Saccum;\n        return mk_double(fl_ctx, Faccum);\n    }\n    else if (Saccum < 0) {\n        Saccum *= (int64_t)Uaccum;\n        if (Saccum >= INT_MIN) {\n            if (fits_fixnum(Saccum)) {\n                return fixnum((fixnum_t)Saccum);\n            }\n            RETURN_NUM_AS(fl_ctx, Saccum, int32);\n        }\n        RETURN_NUM_AS(fl_ctx, Saccum, int64);\n    }\n    else {\n        Uaccum *= (uint64_t)Saccum;\n    }\n    return return_from_uint64(fl_ctx, Uaccum);\n}\n\nstatic int num_to_ptr(value_t a, fixnum_t *pi, numerictype_t *pt, void **pp)\n{\n    cprim_t *cp;\n    if (isfixnum(a)) {\n        *pi = numval(a);\n        *pp = pi;\n        *pt = T_FIXNUM;\n    }\n    else if (iscprim(a)) {\n        cp = (cprim_t*)ptr(a);\n        *pp = cp_data(cp);\n        *pt = cp_numtype(cp);\n    }\n    else {\n        return 0;\n    }\n    return 1;\n}\n\n/*\n  returns -1, 0, or 1 based on ordering of a and b\n  eq: consider equality only, returning 0 or nonzero\n  eqnans: NaNs considered equal to each other\n          -0.0 not considered equal to 0.0\n          inexact not considered equal to exact\n  fname: if not NULL, throws type errors, else returns 2 for type errors\n*/\nint numeric_compare(fl_context_t *fl_ctx, value_t a, value_t b, int eq, int eqnans, char *fname)\n{\n    int_t ai, bi;\n    numerictype_t ta, tb;\n    void *aptr, *bptr;\n\n    if (bothfixnums(a,b)) {\n        if (a==b) return 0;\n        if (numval(a) < numval(b)) return -1;\n        return 1;\n    }\n    if (!num_to_ptr(a, &ai, &ta, &aptr)) {\n        if (fname) type_error(fl_ctx, fname, \"number\", a); else return 2;\n    }\n    if (!num_to_ptr(b, &bi, &tb, &bptr)) {\n        if (fname) type_error(fl_ctx, fname, \"number\", b); else return 2;\n    }\n    if (eq && eqnans && ((ta >= T_FLOAT) != (tb >= T_FLOAT)))\n        return 1;\n    if (cmp_eq(aptr, ta, bptr, tb, eqnans))\n        return 0;\n    if (eq) return 1;\n    if (cmp_lt(aptr, ta, bptr, tb))\n        return -1;\n    return 1;\n}\n\n#if defined(_OS_WINDOWS_)\n__declspec(noreturn) static void DivideByZeroError(fl_context_t *fl_ctx);\n#else\nstatic void DivideByZeroError(fl_context_t *fl_ctx) __attribute__ ((__noreturn__));\n#endif\n\nstatic void DivideByZeroError(fl_context_t *fl_ctx)\n{\n    lerror(fl_ctx, fl_ctx->DivideError, \"/: division by zero\");\n}\n\nstatic value_t fl_div2(fl_context_t *fl_ctx, value_t a, value_t b)\n{\n    double da, db;\n    int_t ai, bi;\n    numerictype_t ta, tb;\n    void *aptr, *bptr;\n\n    if (!num_to_ptr(a, &ai, &ta, &aptr))\n        type_error(fl_ctx, \"/\", \"number\", a);\n    if (!num_to_ptr(b, &bi, &tb, &bptr))\n        type_error(fl_ctx, \"/\", \"number\", b);\n\n    da = conv_to_double(aptr, ta);\n    db = conv_to_double(bptr, tb);\n\n    if (db == 0 && tb < T_FLOAT)  // exact 0\n        DivideByZeroError(fl_ctx);\n\n    da = da/db;\n\n    if (ta < T_FLOAT && tb < T_FLOAT && (double)(int64_t)da == da)\n        return return_from_int64(fl_ctx, (int64_t)da);\n    return mk_double(fl_ctx, da);\n}\n\nstatic value_t fl_idiv2(fl_context_t *fl_ctx, value_t a, value_t b)\n{\n    int_t ai, bi;\n    numerictype_t ta, tb;\n    void *aptr, *bptr;\n    int64_t a64, b64;\n\n    if (!num_to_ptr(a, &ai, &ta, &aptr))\n        type_error(fl_ctx, \"div0\", \"number\", a);\n    if (!num_to_ptr(b, &bi, &tb, &bptr))\n        type_error(fl_ctx, \"div0\", \"number\", b);\n\n    if (ta == T_UINT64) {\n        if (tb == T_UINT64) {\n            if (*(uint64_t*)bptr == 0) goto div_error;\n            return return_from_uint64(fl_ctx, *(uint64_t*)aptr / *(uint64_t*)bptr);\n        }\n        b64 = conv_to_int64(bptr, tb);\n        if (b64 < 0) {\n            return return_from_int64(fl_ctx, -(int64_t)(*(uint64_t*)aptr /\n                                                        (uint64_t)(-b64)));\n        }\n        if (b64 == 0)\n            goto div_error;\n        return return_from_uint64(fl_ctx, *(uint64_t*)aptr / (uint64_t)b64);\n    }\n    if (tb == T_UINT64) {\n        if (*(uint64_t*)bptr == 0) goto div_error;\n        a64 = conv_to_int64(aptr, ta);\n        if (a64 < 0) {\n            return return_from_int64(fl_ctx, -((int64_t)((uint64_t)(-a64) /\n                                                         *(uint64_t*)bptr)));\n        }\n        return return_from_uint64(fl_ctx, (uint64_t)a64 / *(uint64_t*)bptr);\n    }\n\n    b64 = conv_to_int64(bptr, tb);\n    if (b64 == 0) goto div_error;\n\n    return return_from_int64(fl_ctx, conv_to_int64(aptr, ta) / b64);\n div_error:\n    DivideByZeroError(fl_ctx);\n}\n\nstatic value_t fl_bitwise_op(fl_context_t *fl_ctx, value_t a, value_t b, int opcode, char *fname)\n{\n    int_t ai, bi;\n    numerictype_t ta, tb, itmp;\n    void *aptr=NULL, *bptr=NULL, *ptmp;\n    int64_t b64;\n\n    if (!num_to_ptr(a, &ai, &ta, &aptr) || ta >= T_FLOAT)\n        type_error(fl_ctx, fname, \"integer\", a);\n    if (!num_to_ptr(b, &bi, &tb, &bptr) || tb >= T_FLOAT)\n        type_error(fl_ctx, fname, \"integer\", b);\n\n    if (ta < tb) {\n        itmp = ta; ta = tb; tb = itmp;\n        ptmp = aptr; aptr = bptr; bptr = ptmp;\n    }\n    // now a's type is larger than or same as b's\n    b64 = conv_to_int64(bptr, tb);\n    switch (opcode) {\n    case 0:\n    switch (ta) {\n    case T_INT8:   return fixnum(   *(int8_t *)aptr  & (int8_t  )b64);\n    case T_UINT8:  return fixnum(   *(uint8_t *)aptr & (uint8_t )b64);\n    case T_INT16:  return fixnum(   *(int16_t*)aptr  & (int16_t )b64);\n    case T_UINT16: return fixnum(   *(uint16_t*)aptr & (uint16_t)b64);\n    case T_INT32:  return mk_int32(fl_ctx,  *(int32_t*)aptr  & (int32_t )b64);\n    case T_UINT32: return mk_uint32(fl_ctx, *(uint32_t*)aptr & (uint32_t)b64);\n    case T_INT64:  return mk_int64(fl_ctx,  *(int64_t*)aptr  & (int64_t )b64);\n    case T_UINT64: return mk_uint64(fl_ctx, *(uint64_t*)aptr & (uint64_t)b64);\n    case T_FLOAT:\n    case T_DOUBLE: assert(0);\n    }\n    break;\n    case 1:\n    switch (ta) {\n    case T_INT8:   return fixnum(   *(int8_t *)aptr  | (int8_t  )b64);\n    case T_UINT8:  return fixnum(   *(uint8_t *)aptr | (uint8_t )b64);\n    case T_INT16:  return fixnum(   *(int16_t*)aptr  | (int16_t )b64);\n    case T_UINT16: return fixnum(   *(uint16_t*)aptr | (uint16_t)b64);\n    case T_INT32:  return mk_int32(fl_ctx,  *(int32_t*)aptr  | (int32_t )b64);\n    case T_UINT32: return mk_uint32(fl_ctx, *(uint32_t*)aptr | (uint32_t)b64);\n    case T_INT64:  return mk_int64(fl_ctx,  *(int64_t*)aptr  | (int64_t )b64);\n    case T_UINT64: return mk_uint64(fl_ctx, *(uint64_t*)aptr | (uint64_t)b64);\n    case T_FLOAT:\n    case T_DOUBLE: assert(0);\n    }\n    break;\n    case 2:\n    switch (ta) {\n    case T_INT8:   return fixnum(   *(int8_t *)aptr  ^ (int8_t  )b64);\n    case T_UINT8:  return fixnum(   *(uint8_t *)aptr ^ (uint8_t )b64);\n    case T_INT16:  return fixnum(   *(int16_t*)aptr  ^ (int16_t )b64);\n    case T_UINT16: return fixnum(   *(uint16_t*)aptr ^ (uint16_t)b64);\n    case T_INT32:  return mk_int32(fl_ctx,  *(int32_t*)aptr  ^ (int32_t )b64);\n    case T_UINT32: return mk_uint32(fl_ctx, *(uint32_t*)aptr ^ (uint32_t)b64);\n    case T_INT64:  return mk_int64(fl_ctx,  *(int64_t*)aptr  ^ (int64_t )b64);\n    case T_UINT64: return mk_uint64(fl_ctx, *(uint64_t*)aptr ^ (uint64_t)b64);\n    case T_FLOAT:\n    case T_DOUBLE: assert(0);\n    }\n    }\n    assert(0);\n    return fl_ctx->NIL;\n}\n\nstatic value_t fl_logand(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    value_t v, e;\n    int i;\n    if (nargs == 0)\n        return fixnum(-1);\n    v = args[0];\n    FOR_ARGS(i,1,e,args) {\n        if (bothfixnums(v, e))\n            v = v & e;\n        else\n            v = fl_bitwise_op(fl_ctx, v, e, 0, \"logand\");\n    }\n    return v;\n}\n\nstatic value_t fl_logior(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    value_t v, e;\n    int i;\n    if (nargs == 0)\n        return fixnum(0);\n    v = args[0];\n    FOR_ARGS(i,1,e,args) {\n        if (bothfixnums(v, e))\n            v = v | e;\n        else\n            v = fl_bitwise_op(fl_ctx, v, e, 1, \"logior\");\n    }\n    return v;\n}\n\nstatic value_t fl_logxor(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    value_t v, e;\n    int i;\n    if (nargs == 0)\n        return fixnum(0);\n    v = args[0];\n    FOR_ARGS(i,1,e,args) {\n        if (bothfixnums(v, e))\n            v = fixnum(numval(v) ^ numval(e));\n        else\n            v = fl_bitwise_op(fl_ctx, v, e, 2, \"logxor\");\n    }\n    return v;\n}\n\nstatic value_t fl_lognot(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    argcount(fl_ctx, \"lognot\", nargs, 1);\n    value_t a = args[0];\n    if (isfixnum(a))\n        return fixnum(~numval(a));\n    cprim_t *cp;\n    int ta;\n    void *aptr;\n\n    if (iscprim(a)) {\n        cp = (cprim_t*)ptr(a);\n        ta = cp_numtype(cp);\n        aptr = cp_data(cp);\n        switch (ta) {\n        case T_INT8:   return fixnum(~*(int8_t *)aptr);\n        case T_UINT8:  return fixnum(~*(uint8_t *)aptr);\n        case T_INT16:  return fixnum(~*(int16_t *)aptr);\n        case T_UINT16: return fixnum(~*(uint16_t*)aptr);\n        case T_INT32:  return mk_int32(fl_ctx, ~*(int32_t *)aptr);\n        case T_UINT32: return mk_uint32(fl_ctx, ~*(uint32_t*)aptr);\n        case T_INT64:  return mk_int64(fl_ctx, ~*(int64_t *)aptr);\n        case T_UINT64: return mk_uint64(fl_ctx, ~*(uint64_t*)aptr);\n        }\n    }\n    type_error(fl_ctx, \"lognot\", \"integer\", a);\n}\n\nstatic value_t fl_ash(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    fixnum_t n;\n    int64_t accum;\n    argcount(fl_ctx, \"ash\", nargs, 2);\n    value_t a = args[0];\n    n = tofixnum(fl_ctx, args[1], \"ash\");\n    if (isfixnum(a)) {\n        if (n <= 0)\n            return fixnum(numval(a)>>(-n));\n        accum = ((int64_t)numval(a))<<n;\n        if (fits_fixnum(accum))\n            return fixnum(accum);\n        else\n            return return_from_int64(fl_ctx, accum);\n    }\n    cprim_t *cp;\n    int ta;\n    void *aptr;\n    if (iscprim(a)) {\n        if (n == 0) return a;\n        cp = (cprim_t*)ptr(a);\n        ta = cp_numtype(cp);\n        aptr = cp_data(cp);\n        if (n < 0) {\n            n = -n;\n            switch (ta) {\n            case T_INT8:   return fixnum((*(int8_t *)aptr) >> n);\n            case T_UINT8:  return fixnum((*(uint8_t *)aptr) >> n);\n            case T_INT16:  return fixnum((*(int16_t *)aptr) >> n);\n            case T_UINT16: return fixnum((*(uint16_t*)aptr) >> n);\n            case T_INT32:  return mk_int32(fl_ctx, (*(int32_t *)aptr) >> n);\n            case T_UINT32: return mk_uint32(fl_ctx, (*(uint32_t*)aptr) >> n);\n            case T_INT64:  return mk_int64(fl_ctx, (*(int64_t *)aptr) >> n);\n            case T_UINT64: return mk_uint64(fl_ctx, (*(uint64_t*)aptr) >> n);\n            }\n        }\n        else {\n            if (ta == T_UINT64)\n                return return_from_uint64(fl_ctx, (*(uint64_t*)aptr)<<n);\n            else if (ta < T_FLOAT) {\n                int64_t i64 = conv_to_int64(aptr, (numerictype_t)ta);\n                return return_from_int64(fl_ctx, i64<<n);\n            }\n        }\n    }\n    type_error(fl_ctx, \"ash\", \"integer\", a);\n    return fl_ctx->NIL;\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/searchindex.js": "Search.setIndex({envversion:49,filenames:[\"devdocs/C\",\"devdocs/ast\",\"devdocs/backtraces\",\"devdocs/boundscheck\",\"devdocs/callconv\",\"devdocs/cartesian\",\"devdocs/debuggingtips\",\"devdocs/eval\",\"devdocs/functions\",\"devdocs/init\",\"devdocs/julia\",\"devdocs/llvm\",\"devdocs/locks\",\"devdocs/meta\",\"devdocs/object\",\"devdocs/offset-arrays\",\"devdocs/reflection\",\"devdocs/sanitizers\",\"devdocs/stdio\",\"devdocs/subarrays\",\"devdocs/sysimg\",\"devdocs/types\",\"devdocs/valgrind\",\"index\",\"latex\",\"manual/arrays\",\"manual/calling-c-and-fortran-code\",\"manual/complex-and-rational-numbers\",\"manual/constructors\",\"manual/control-flow\",\"manual/conversion-and-promotion\",\"manual/dates\",\"manual/documentation\",\"manual/embedding\",\"manual/faq\",\"manual/functions\",\"manual/getting-started\",\"manual/handling-operating-system-variation\",\"manual/index\",\"manual/integers-and-floating-point-numbers\",\"manual/interacting-with-julia\",\"manual/interfaces\",\"manual/introduction\",\"manual/linear-algebra\",\"manual/mathematical-operations\",\"manual/metaprogramming\",\"manual/methods\",\"manual/modules\",\"manual/networking-and-streams\",\"manual/noteworthy-differences\",\"manual/packages\",\"manual/parallel-computing\",\"manual/performance-tips\",\"manual/profile\",\"manual/running-external-programs\",\"manual/stacktraces\",\"manual/strings\",\"manual/style-guide\",\"manual/types\",\"manual/unicode-input\",\"manual/variables\",\"manual/variables-and-scoping\",\"manual/workflow-tips\",\"stdlib/arrays\",\"stdlib/base\",\"stdlib/c\",\"stdlib/collections\",\"stdlib/constants\",\"stdlib/dates\",\"stdlib/file\",\"stdlib/index\",\"stdlib/io-network\",\"stdlib/libc\",\"stdlib/libdl\",\"stdlib/linalg\",\"stdlib/math\",\"stdlib/numbers\",\"stdlib/parallel\",\"stdlib/pkg\",\"stdlib/profile\",\"stdlib/punctuation\",\"stdlib/simd-types\",\"stdlib/sort\",\"stdlib/stacktraces\",\"stdlib/strings\",\"stdlib/test\"],objects:{\"\":{\"@__doc__\":[32,4,1,\"\"],Dates:[68,6,0,\"-\"],Libc:[72,6,0,\"-\"],Libdl:[73,6,0,\"-\"],Profile:[79,6,0,\"-\"],StackTraces:[83,6,0,\"-\"],build_sysimg:[20,4,1,\"\"]},\"Base.\":{\"!=\":[75,4,1,\"\"],\"&gt;\":[75,4,1,\"Base..>\"],\"&gt;=\":[75,4,1,\"Base..>=\"],\"&lt;\":[75,4,1,\"Base..<\"],\"&lt;=\":[75,4,1,\"Base..<=\"],\"*\":[75,4,1,\"\"],\"+\":[75,4,1,\"\"],\"-\":[75,4,1,\"\"],\"/\":[75,4,1,\"\"],\"==\":[75,4,1,\"\"],\"\\\\\":[75,4,1,\"\"],\"\\u2260\":[75,4,1,\"\"],\"\\u2264\":[75,4,1,\"\"],\"\\u2265\":[75,4,1,\"\"],\"^\":[75,4,1,\"\"]},\"Base.Base\":{OneTo:[75,4,1,\"\"],channel_from_id:[77,4,1,\"\"],checked_abs:[75,4,1,\"\"],checked_add:[75,4,1,\"\"],checked_cld:[75,4,1,\"\"],checked_div:[75,4,1,\"\"],checked_fld:[75,4,1,\"\"],checked_mod:[75,4,1,\"\"],checked_mul:[75,4,1,\"\"],checked_neg:[75,4,1,\"\"],checked_rem:[75,4,1,\"\"],checked_sub:[75,4,1,\"\"],cluster_cookie:[77,4,1,\"\"],compilecache:[64,4,1,\"\"],datatype_module:[64,4,1,\"\"],function_module:[64,4,1,\"\"],function_name:[64,4,1,\"\"],linearindexing:[63,4,1,\"\"],process_messages:[77,4,1,\"\"],remoteref_id:[77,4,1,\"\"],summarysize:[64,4,1,\"\"],worker_id_from_socket:[77,4,1,\"\"]},\"Base.Collections\":{\"dequeue!\":[66,4,1,\"\"],\"enqueue!\":[66,4,1,\"\"],\"heapify!\":[66,4,1,\"\"],\"heappop!\":[66,4,1,\"\"],\"heappush!\":[66,4,1,\"\"],PriorityQueue:[66,4,1,\"\"],heapify:[66,4,1,\"\"],isheap:[66,4,1,\"\"],peek:[66,4,1,\"\"]},\"Base.FFTW\":{\"plan_r2r!\":[75,4,1,\"\"],\"r2r!\":[75,4,1,\"\"],plan_r2r:[75,4,1,\"\"],r2r:[75,4,1,\"\"]},\"Base.Libc\":{FormatMessage:[72,4,1,\"\"],GetLastError:[72,4,1,\"\"],TmStruct:[72,4,1,\"\"],calloc:[72,4,1,\"\"],errno:[72,4,1,\"\"],flush_cstdio:[72,4,1,\"\"],free:[72,4,1,\"\"],malloc:[72,4,1,\"\"],realloc:[72,4,1,\"\"],strerror:[72,4,1,\"\"],strftime:[72,4,1,\"\"],strptime:[72,4,1,\"\"],time:[72,4,1,\"\"]},\"Base.Libdl\":{DL_LOAD_PATH:[73,5,1,\"\"],RTLD_DEEPBIND:[73,5,1,\"\"],RTLD_FIRST:[73,5,1,\"\"],RTLD_GLOBAL:[73,5,1,\"\"],RTLD_LAZY:[73,5,1,\"\"],RTLD_LOCAL:[73,5,1,\"\"],RTLD_NODELETE:[73,5,1,\"\"],RTLD_NOLOAD:[73,5,1,\"\"],RTLD_NOW:[73,5,1,\"\"],dlclose:[73,4,1,\"\"],dlext:[73,5,1,\"\"],dlopen:[73,4,1,\"\"],dlopen_e:[73,4,1,\"\"],dlsym:[73,4,1,\"\"],dlsym_e:[73,4,1,\"\"],find_library:[73,4,1,\"\"]},\"Base.LinAlg\":{\"lowrankdowndate!\":[74,4,1,\"\"],\"lowrankupdate!\":[74,4,1,\"\"],\"qr!\":[74,4,1,\"\"],BLAS:[74,6,0,\"-\"],Givens:[74,4,1,\"\"],LAPACK:[74,6,0,\"-\"],checksquare:[63,4,1,\"\"],lowrankdowndate:[74,4,1,\"\"],lowrankupdate:[74,4,1,\"\"]},\"Base.LinAlg.BLAS\":{\"axpy!\":[74,4,1,\"\"],\"blascopy!\":[74,4,1,\"\"],\"gbmv!\":[74,4,1,\"\"],\"gemm!\":[74,4,1,\"\"],\"gemv!\":[74,4,1,\"\"],\"ger!\":[74,4,1,\"\"],\"her!\":[74,4,1,\"\"],\"herk!\":[74,4,1,\"\"],\"sbmv!\":[74,4,1,\"\"],\"scal!\":[74,4,1,\"\"],\"symm!\":[74,4,1,\"\"],\"symv!\":[74,4,1,\"\"],\"syr!\":[74,4,1,\"\"],\"syrk!\":[74,4,1,\"\"],\"trmm!\":[74,4,1,\"\"],\"trmv!\":[74,4,1,\"\"],\"trsm!\":[74,4,1,\"\"],\"trsv!\":[74,4,1,\"\"],I:[74,5,1,\"\"],asum:[74,4,1,\"\"],dot:[74,4,1,\"\"],dotc:[74,4,1,\"\"],dotu:[74,4,1,\"\"],gbmv:[74,4,1,\"\"],gemm:[74,4,1,\"\"],gemv:[74,4,1,\"\"],herk:[74,4,1,\"\"],nrm2:[74,4,1,\"\"],sbmv:[74,4,1,\"\"],scal:[74,4,1,\"\"],set_num_threads:[74,4,1,\"\"],symm:[74,4,1,\"\"],symv:[74,4,1,\"\"],syrk:[74,4,1,\"\"],trmm:[74,4,1,\"\"],trmv:[74,4,1,\"\"],trsm:[74,4,1,\"\"],trsv:[74,4,1,\"\"]},\"Base.LinAlg.LAPACK\":{\"bdsdc!\":[74,4,1,\"\"],\"bdsqr!\":[74,4,1,\"\"],\"gbtrf!\":[74,4,1,\"\"],\"gbtrs!\":[74,4,1,\"\"],\"gebak!\":[74,4,1,\"\"],\"gebal!\":[74,4,1,\"\"],\"gebrd!\":[74,4,1,\"\"],\"gecon!\":[74,4,1,\"\"],\"gees!\":[74,4,1,\"\"],\"geev!\":[74,4,1,\"\"],\"geevx!\":[74,4,1,\"\"],\"gehrd!\":[74,4,1,\"\"],\"gelqf!\":[74,4,1,\"\"],\"gels!\":[74,4,1,\"\"],\"gelsd!\":[74,4,1,\"\"],\"gelsy!\":[74,4,1,\"\"],\"gemqrt!\":[74,4,1,\"\"],\"geqlf!\":[74,4,1,\"\"],\"geqp3!\":[74,4,1,\"\"],\"geqrf!\":[74,4,1,\"\"],\"geqrt!\":[74,4,1,\"\"],\"geqrt3!\":[74,4,1,\"\"],\"gerqf!\":[74,4,1,\"\"],\"gesdd!\":[74,4,1,\"\"],\"gesv!\":[74,4,1,\"\"],\"gesvd!\":[74,4,1,\"\"],\"gesvx!\":[74,4,1,\"\"],\"getrf!\":[74,4,1,\"\"],\"getri!\":[74,4,1,\"\"],\"getrs!\":[74,4,1,\"\"],\"gges!\":[74,4,1,\"\"],\"ggev!\":[74,4,1,\"\"],\"gglse!\":[74,4,1,\"\"],\"ggsvd!\":[74,4,1,\"\"],\"ggsvd3!\":[74,4,1,\"\"],\"gtsv!\":[74,4,1,\"\"],\"gttrf!\":[74,4,1,\"\"],\"gttrs!\":[74,4,1,\"\"],\"hesv!\":[74,4,1,\"\"],\"hetrf!\":[74,4,1,\"\"],\"hetri!\":[74,4,1,\"\"],\"hetrs!\":[74,4,1,\"\"],\"orghr!\":[74,4,1,\"\"],\"orglq!\":[74,4,1,\"\"],\"orgql!\":[74,4,1,\"\"],\"orgqr!\":[74,4,1,\"\"],\"orgrq!\":[74,4,1,\"\"],\"ormlq!\":[74,4,1,\"\"],\"ormql!\":[74,4,1,\"\"],\"ormqr!\":[74,4,1,\"\"],\"ormrq!\":[74,4,1,\"\"],\"ormrz!\":[74,4,1,\"\"],\"posv!\":[74,4,1,\"\"],\"potrf!\":[74,4,1,\"\"],\"potri!\":[74,4,1,\"\"],\"potrs!\":[74,4,1,\"\"],\"pstrf!\":[74,4,1,\"\"],\"ptsv!\":[74,4,1,\"\"],\"pttrf!\":[74,4,1,\"\"],\"pttrs!\":[74,4,1,\"\"],\"stebz!\":[74,4,1,\"\"],\"stegr!\":[74,4,1,\"\"],\"stein!\":[74,4,1,\"\"],\"stev!\":[74,4,1,\"\"],\"syconv!\":[74,4,1,\"\"],\"syev!\":[74,4,1,\"\"],\"syevr!\":[74,4,1,\"\"],\"sygvd!\":[74,4,1,\"\"],\"sysv!\":[74,4,1,\"\"],\"sytrf!\":[74,4,1,\"\"],\"sytri!\":[74,4,1,\"\"],\"sytrs!\":[74,4,1,\"\"],\"tgsen!\":[74,4,1,\"\"],\"trcon!\":[74,4,1,\"\"],\"trevc!\":[74,4,1,\"\"],\"trexc!\":[74,4,1,\"\"],\"trrfs!\":[74,4,1,\"\"],\"trsen!\":[74,4,1,\"\"],\"trsyl!\":[74,4,1,\"\"],\"trtri!\":[74,4,1,\"\"],\"trtrs!\":[74,4,1,\"\"],\"tzrzf!\":[74,4,1,\"\"]},\"Base.Mmap\":{\"sync!\":[71,4,1,\"\"],Anonymous:[71,4,1,\"\"],mmap:[71,4,1,\"\"]},\"Base.Pkg\":{\"setprotocol!\":[78,4,1,\"\"],add:[78,4,1,\"\"],available:[78,4,1,\"\"],build:[78,4,1,\"\"],checkout:[78,4,1,\"\"],clone:[78,4,1,\"\"],dependents:[78,4,1,\"\"],dir:[78,4,1,\"\"],edit:[78,4,1,\"\"],free:[78,4,1,\"\"],init:[78,4,1,\"\"],installed:[78,4,1,\"\"],pin:[78,4,1,\"\"],resolve:[78,4,1,\"\"],rm:[78,4,1,\"\"],status:[78,4,1,\"\"],test:[78,4,1,\"\"],update:[78,4,1,\"\"]},\"Base.Profile\":{callers:[79,4,1,\"\"],clear:[79,4,1,\"\"],clear_malloc_data:[79,4,1,\"\"],fetch:[79,4,1,\"\"],init:[79,4,1,\"\"],print:[79,4,1,\"\"],retrieve:[79,4,1,\"\"]},\"Base.StackTraces\":{\"remove_frames!\":[83,4,1,\"\"],lookup:[83,4,1,\"\"]},\"Base.Sys\":{ARCH:[67,5,1,\"\"],CPU_CORES:[67,5,1,\"\"],KERNEL:[67,5,1,\"\"],MACHINE:[67,5,1,\"\"],WORD_SIZE:[67,5,1,\"\"],get_process_title:[64,4,1,\"\"],set_process_title:[64,4,1,\"\"]},\"Base.Test\":{\"@test_approx_eq\":[85,4,1,\"\"],\"@test_approx_eq_eps\":[85,4,1,\"\"],finish:[85,4,1,\"\"],get_testset:[85,4,1,\"\"],get_testset_depth:[85,4,1,\"\"],record:[85,4,1,\"\"]},\"Base.Threads\":{\"@threads\":[77,4,1,\"\"],\"Atomic{T}\":[77,4,1,\"\"],\"atomic_add!{T}\":[77,4,1,\"\"],\"atomic_and!{T}\":[77,4,1,\"\"],\"atomic_cas!{T}\":[77,4,1,\"\"],\"atomic_max!{T}\":[77,4,1,\"\"],\"atomic_min!{T}\":[77,4,1,\"\"],\"atomic_nand!{T}\":[77,4,1,\"\"],\"atomic_or!{T}\":[77,4,1,\"\"],\"atomic_sub!{T}\":[77,4,1,\"\"],\"atomic_xchg!{T}\":[77,4,1,\"\"],\"atomic_xor!{T}\":[77,4,1,\"\"],atomic_fence:[77,4,1,\"\"],nthreads:[77,4,1,\"\"],threadid:[77,4,1,\"\"]},Base:{\"!\":[75,4,1,\"\"],\"!=\":[75,4,1,\"\"],\"!==\":[75,4,1,\"\"],\"$\":[75,4,1,\"\"],\"%\":[75,4,1,\"\"],\"&amp;\":[75,4,1,\"Base.&\"],\"&gt;\":[75,4,1,\"Base.>\"],\"&gt;&gt;\":[75,4,1,\"Base.>>\"],\"&gt;&gt;&gt;\":[75,4,1,\"Base.>>>\"],\"&gt;=\":[75,4,1,\"Base.>=\"],\"&lt;\":[75,4,1,\"Base.<\"],\"&lt;&lt;\":[75,4,1,\"Base.<<\"],\"&lt;:\":[64,4,1,\"Base.<:\"],\"&lt;=\":[75,4,1,\"Base.<=\"],\"*\":[84,4,1,\"\"],\"+\":[75,4,1,\"\"],\"-\":[75,4,1,\"\"],\"/\":[75,4,1,\"\"],\"//\":[75,4,1,\"\"],\":\":[75,4,1,\"\"],\"==\":[75,4,1,\"\"],\"===\":[75,4,1,\"\"],\"@__FILE__\":[69,4,1,\"\"],\"@__LINE__\":[69,4,1,\"\"],\"@allocated\":[64,4,1,\"\"],\"@async\":[77,4,1,\"\"],\"@code_llvm\":[64,4,1,\"\"],\"@code_lowered\":[64,4,1,\"\"],\"@code_native\":[64,4,1,\"\"],\"@code_typed\":[64,4,1,\"\"],\"@code_warntype\":[64,4,1,\"\"],\"@edit\":[64,4,1,\"\"],\"@elapsed\":[64,4,1,\"\"],\"@eval\":[64,4,1,\"\"],\"@evalpoly\":[75,4,1,\"\"],\"@fetch\":[77,4,1,\"\"],\"@fetchfrom\":[77,4,1,\"\"],\"@functionloc\":[64,4,1,\"\"],\"@gensym\":[64,4,1,\"\"],\"@html_str\":[84,4,1,\"\"],\"@less\":[64,4,1,\"\"],\"@parallel\":[77,4,1,\"\"],\"@printf\":[71,4,1,\"\"],\"@profile\":[79,4,1,\"\"],\"@r_str\":[84,4,1,\"\"],\"@schedule\":[77,4,1,\"\"],\"@show\":[64,4,1,\"\"],\"@spawn\":[77,4,1,\"\"],\"@spawnat\":[77,4,1,\"\"],\"@sprintf\":[71,4,1,\"\"],\"@static\":[64,4,1,\"\"],\"@sync\":[77,4,1,\"\"],\"@task\":[77,4,1,\"\"],\"@text_str\":[84,4,1,\"\"],\"@threadcall\":[77,4,1,\"\"],\"@time\":[64,4,1,\"\"],\"@timed\":[64,4,1,\"\"],\"@timev\":[64,4,1,\"\"],\"@which\":[64,4,1,\"\"],\"A_ldiv_B!\":[74,4,1,\"\"],\"A_mul_B!\":[74,4,1,\"\"],\"Ac_ldiv_B!\":[74,4,1,\"\"],\"At_ldiv_B!\":[74,4,1,\"\"],\"Channel{T}\":[77,4,1,\"\"],\"Ptr{T}\":[65,5,1,\"\"],\"Ref{T}\":[65,5,1,\"\"],\"Val{c}\":[64,4,1,\"\"],\"\\\\\":[75,4,1,\"\"],\"\\u00d7\":[74,4,1,\"\"],\"\\u00f7\":[75,4,1,\"\"],\"\\u03b3\":[76,5,1,\"\"],\"\\u03c0\":[76,5,1,\"\"],\"\\u03c6\":[76,5,1,\"\"],\"\\u2208\":[66,4,1,\"\"],\"\\u2209\":[66,4,1,\"\"],\"\\u220b\":[66,4,1,\"\"],\"\\u220c\":[66,4,1,\"\"],\"\\u2229\":[66,4,1,\"\"],\"\\u222a\":[66,4,1,\"\"],\"\\u2260\":[75,4,1,\"\"],\"\\u2261\":[75,4,1,\"\"],\"\\u2262\":[75,4,1,\"\"],\"\\u2264\":[75,4,1,\"\"],\"\\u2265\":[75,4,1,\"\"],\"\\u2286\":[66,4,1,\"\"],\"\\u2288\":[66,4,1,\"\"],\"\\u228a\":[66,4,1,\"\"],\"\\u22c5\":[74,4,1,\"\"],\"^\":[84,4,1,\"\"],\"all!\":[66,4,1,\"\"],\"any!\":[66,4,1,\"\"],\"append!\":[66,4,1,\"\"],\"bfft!\":[75,4,1,\"\"],\"bkfact!\":[74,4,1,\"\"],\"broadcast!\":[63,4,1,\"\"],\"broadcast_setindex!\":[63,4,1,\"\"],\"cholfact!\":[74,4,1,\"\"],\"clamp!\":[75,4,1,\"\"],\"clear!\":[77,4,1,\"\"],\"conj!\":[63,4,1,\"\"],\"copy!\":[65,4,1,\"\"],\"ctranspose!\":[74,4,1,\"\"],\"cumprod!\":[63,4,1,\"\"],\"cumsum!\":[63,4,1,\"\"],\"dct!\":[75,4,1,\"\"],\"delete!\":[66,4,1,\"\"],\"deleteat!\":[66,4,1,\"\"],\"digits!\":[76,4,1,\"\"],\"dropzeros!\":[63,4,1,\"\"],\"eigfact!\":[74,4,1,\"\"],\"eigvals!\":[74,4,1,\"\"],\"empty!\":[66,4,1,\"\"],\"fft!\":[75,4,1,\"\"],\"fill!\":[63,4,1,\"\"],\"filt!\":[75,4,1,\"\"],\"filter!\":[66,4,1,\"\"],\"findmax!\":[66,4,1,\"\"],\"findmin!\":[66,4,1,\"\"],\"flipbits!\":[63,4,1,\"\"],\"float\":[76,4,1,\"\"],\"get!\":[66,4,1,\"\"],\"givens{T}\":[74,4,1,\"\"],\"hessfact!\":[74,4,1,\"\"],\"idct!\":[75,4,1,\"\"],\"ifft!\":[75,4,1,\"\"],\"in\":[66,4,1,\"\"],\"insert!\":[66,4,1,\"\"],\"intersect!\":[66,4,1,\"\"],\"ipermute!\":[63,4,1,\"\"],\"isposdef!\":[74,4,1,\"\"],\"ldltfact!\":[74,4,1,\"\"],\"lqfact!\":[74,4,1,\"\"],\"lufact!\":[74,4,1,\"\"],\"map!\":[66,4,1,\"\"],\"maxabs!\":[66,4,1,\"\"],\"maximum!\":[66,4,1,\"\"],\"mean!\":[75,4,1,\"\"],\"median!\":[75,4,1,\"\"],\"merge!\":[66,4,1,\"\"],\"minabs!\":[66,4,1,\"\"],\"minimum!\":[66,4,1,\"\"],\"normalize!\":[74,4,1,\"\"],\"ordschur!\":[74,4,1,\"\"],\"permute!\":[63,4,1,\"\"],\"permutedims!\":[63,4,1,\"\"],\"plan_bfft!\":[75,4,1,\"\"],\"plan_dct!\":[75,4,1,\"\"],\"plan_fft!\":[75,4,1,\"\"],\"plan_idct!\":[75,4,1,\"\"],\"plan_ifft!\":[75,4,1,\"\"],\"pop!\":[66,4,1,\"\"],\"prepend!\":[66,4,1,\"\"],\"prod!\":[66,4,1,\"\"],\"push!\":[66,4,1,\"\"],\"put!\":[77,4,1,\"\"],\"q::AbstractVector{Tq})\":[63,4,1,\"\"],\"qrfact!\":[74,4,1,\"\"],\"quantile!\":[75,4,1,\"\"],\"rand!\":[76,4,1,\"\"],\"randexp!\":[76,4,1,\"\"],\"randn!\":[76,4,1,\"\"],\"randsubseq!\":[63,4,1,\"\"],\"read!\":[71,4,1,\"\"],\"readbytes!\":[71,4,1,\"\"],\"resize!\":[66,4,1,\"\"],\"reverse!\":[63,4,1,\"\"],\"rol!\":[63,4,1,\"\"],\"ror!\":[63,4,1,\"\"],\"scale!\":[74,4,1,\"\"],\"schurfact!\":[74,4,1,\"\"],\"select!\":[82,4,1,\"\"],\"selectperm!\":[82,4,1,\"\"],\"setdiff!\":[66,4,1,\"\"],\"setfield!\":[64,4,1,\"\"],\"setindex!\":[66,4,1,\"\"],\"shift!\":[66,4,1,\"\"],\"shuffle!\":[63,4,1,\"\"],\"sizehint!\":[66,4,1,\"\"],\"sort!\":[82,4,1,\"\"],\"sortperm!\":[82,4,1,\"\"],\"splice!\":[66,4,1,\"\"],\"sum!\":[66,4,1,\"\"],\"sumabs!\":[66,4,1,\"\"],\"sumabs2!\":[66,4,1,\"\"],\"svdfact!\":[74,4,1,\"\"],\"svdvals!\":[74,4,1,\"\"],\"symdiff!\":[66,4,1,\"\"],\"take!\":[77,4,1,\"\"],\"throw\":[64,4,1,\"\"],\"transpose!\":[74,4,1,\"\"],\"tril!\":[74,4,1,\"\"],\"triu!\":[74,4,1,\"\"],\"typeof\":[64,4,1,\"\"],\"union!\":[66,4,1,\"\"],\"unsafe_copy!\":[65,4,1,\"\"],\"unsafe_store!\":[65,4,1,\"\"],\"unshift!\":[66,4,1,\"\"],\"var\":[75,4,1,\"\"],\"|\":[75,4,1,\"\"],\"|&gt;\":[64,4,1,\"Base.|>\"],\"~\":[75,4,1,\"\"],ANY:[67,5,1,\"\"],ARGS:[67,5,1,\"\"],A_ldiv_Bc:[74,4,1,\"\"],A_ldiv_Bt:[74,4,1,\"\"],A_mul_Bc:[74,4,1,\"\"],A_mul_Bt:[74,4,1,\"\"],A_rdiv_Bc:[74,4,1,\"\"],A_rdiv_Bt:[74,4,1,\"\"],AbstractLock:[77,5,1,\"\"],Ac_ldiv_B:[74,4,1,\"\"],Ac_ldiv_Bc:[74,4,1,\"\"],Ac_mul_B:[74,4,1,\"\"],Ac_mul_Bc:[74,4,1,\"\"],Ac_rdiv_B:[74,4,1,\"\"],Ac_rdiv_Bc:[74,4,1,\"\"],ArgumentError:[64,4,1,\"\"],Array:[63,4,1,\"\"],AssertionError:[64,4,1,\"\"],AsyncCondition:[64,4,1,\"\"],At_ldiv_B:[74,4,1,\"\"],At_ldiv_Bt:[74,4,1,\"\"],At_mul_B:[74,4,1,\"\"],At_mul_Bt:[74,4,1,\"\"],At_rdiv_B:[74,4,1,\"\"],At_rdiv_Bt:[74,4,1,\"\"],Base64DecodePipe:[71,4,1,\"\"],Base64EncodePipe:[71,4,1,\"\"],Bidiagonal:[74,4,1,\"\"],BigFloat:[76,4,1,\"\"],BigInt:[76,4,1,\"\"],BoundsError:[64,4,1,\"\"],C_NULL:[67,5,1,\"\"],CachingPool:[77,4,1,\"\"],Cartesian:[5,6,0,\"-\"],Cchar:[65,5,1,\"\"],Cdouble:[65,5,1,\"\"],Cfloat:[65,5,1,\"\"],Cint:[65,5,1,\"\"],Cintmax_t:[65,5,1,\"\"],Clong:[65,5,1,\"\"],Clonglong:[65,5,1,\"\"],Collections:[66,6,0,\"-\"],Condition:[77,4,1,\"\"],Cptrdiff_t:[65,5,1,\"\"],Cshort:[65,5,1,\"\"],Csize_t:[65,5,1,\"\"],Cssize_t:[65,5,1,\"\"],Cuchar:[65,5,1,\"\"],Cuint:[65,5,1,\"\"],Cuintmax_t:[65,5,1,\"\"],Culong:[65,5,1,\"\"],Culonglong:[65,5,1,\"\"],Cushort:[65,5,1,\"\"],Cwchar_t:[65,5,1,\"\"],DevNull:[64,5,1,\"\"],Diagonal:[74,4,1,\"\"],Dict:[66,4,1,\"\"],DimensionMismatch:[64,4,1,\"\"],DivideError:[64,4,1,\"\"],DomainError:[64,4,1,\"\"],ENDIAN_BOM:[71,5,1,\"\"],ENV:[64,5,1,\"\"],EOFError:[64,4,1,\"\"],EnvHash:[64,4,1,\"\"],ErrorException:[64,4,1,\"\"],Float32:[76,4,1,\"\"],Float64:[76,4,1,\"\"],Future:[77,4,1,\"\"],Hermitian:[74,4,1,\"\"],IOBuffer:[71,4,1,\"\"],IOContext:[71,7,1,\"\"],IPv4:[71,4,1,\"\"],IPv6:[71,4,1,\"\"],InexactError:[64,4,1,\"\"],Inf16:[76,5,1,\"\"],Inf32:[76,5,1,\"\"],Inf:[76,5,1,\"\"],InitError:[64,4,1,\"\"],IntSet:[66,4,1,\"\"],InterruptException:[64,4,1,\"\"],JULIA_HOME:[67,5,1,\"\"],KeyError:[64,4,1,\"\"],LOAD_PATH:[67,5,1,\"\"],LinAlg:[74,6,0,\"-\"],LoadError:[64,4,1,\"\"],MersenneTwister:[76,4,1,\"\"],MethodError:[64,4,1,\"\"],Mutex:[77,4,1,\"\"],NaN16:[76,5,1,\"\"],NaN32:[76,5,1,\"\"],NaN:[76,5,1,\"\"],NullException:[64,4,1,\"\"],Nullable:[64,4,1,\"\"],OutOfMemoryError:[64,4,1,\"\"],OverflowError:[64,4,1,\"\"],PROGRAM_FILE:[67,5,1,\"\"],ParseError:[64,4,1,\"\"],PipeBuffer:[71,4,1,\"\"],Pkg:[78,6,0,\"-\"],ProcessExitedException:[64,4,1,\"\"],RandomDevice:[76,4,1,\"\"],ReadOnlyMemoryError:[64,4,1,\"\"],RecursiveSpinLock:[77,4,1,\"\"],ReentrantLock:[77,4,1,\"\"],RemoteChannel:[77,4,1,\"\"],RemoteException:[77,4,1,\"\"],RoundDown:[75,5,1,\"\"],RoundNearest:[75,5,1,\"\"],RoundNearestTiesAway:[75,5,1,\"\"],RoundNearestTiesUp:[75,5,1,\"\"],RoundToZero:[75,5,1,\"\"],RoundUp:[75,5,1,\"\"],RoundingMode:[75,7,1,\"\"],STDERR:[71,5,1,\"\"],STDIN:[71,5,1,\"\"],STDOUT:[71,5,1,\"\"],Semaphore:[77,4,1,\"\"],Set:[66,4,1,\"\"],SharedArray:[77,4,1,\"\"],SpinLock:[77,4,1,\"\"],StackFrame:[83,5,1,\"\"],StackOverflowError:[64,4,1,\"\"],StackTrace:[83,5,1,\"\"],String:[84,4,1,\"\"],SymTridiagonal:[74,4,1,\"\"],Symbol:[84,4,1,\"\"],Symmetric:[74,4,1,\"\"],SystemError:[64,4,1,\"\"],Task:[77,4,1,\"\"],Test:[85,6,0,\"-\"],TextDisplay:[71,4,1,\"\"],Timer:[64,4,1,\"\"],Tridiagonal:[74,4,1,\"\"],TypeError:[64,4,1,\"\"],UndefRefError:[64,4,1,\"\"],UndefVarError:[64,4,1,\"\"],VERSION:[67,5,1,\"\"],WorkerPool:[77,4,1,\"\"],__precompile__:[64,4,1,\"\"],abs2:[75,4,1,\"\"],abs:[75,4,1,\"\"],abspath:[69,4,1,\"\"],accept:[71,4,1,\"\"],acos:[75,4,1,\"\"],acosd:[75,4,1,\"\"],acosh:[75,4,1,\"\"],acot:[75,4,1,\"\"],acotd:[75,4,1,\"\"],acoth:[75,4,1,\"\"],acquire:[77,4,1,\"\"],acsc:[75,4,1,\"\"],acscd:[75,4,1,\"\"],acsch:[75,4,1,\"\"],addprocs:[77,4,1,\"\"],airy:[75,4,1,\"\"],airyai:[75,4,1,\"\"],airyaiprime:[75,4,1,\"\"],airybi:[75,4,1,\"\"],airybiprime:[75,4,1,\"\"],airyprime:[75,4,1,\"\"],airyx:[75,4,1,\"\"],all:[66,4,1,\"\"],allunique:[66,4,1,\"\"],angle:[75,4,1,\"\"],ans:[64,5,1,\"\"],any:[66,4,1,\"\"],applicable:[64,4,1,\"\"],apropos:[64,4,1,\"\"],ascii:[84,4,1,\"\"],asec:[75,4,1,\"\"],asecd:[75,4,1,\"\"],asech:[75,4,1,\"\"],asin:[75,4,1,\"\"],asind:[75,4,1,\"\"],asinh:[75,4,1,\"\"],assert:[64,4,1,\"\"],asyncmap:[77,4,1,\"\"],atan2:[75,4,1,\"\"],atan:[75,4,1,\"\"],atand:[75,4,1,\"\"],atanh:[75,4,1,\"\"],atexit:[64,4,1,\"\"],atreplinit:[64,4,1,\"\"],backtrace:[64,4,1,\"\"],base64decode:[71,4,1,\"\"],base64encode:[71,4,1,\"\"],base:[76,4,1,\"\"],basename:[69,4,1,\"\"],besselh:[75,4,1,\"\"],besselhx:[75,4,1,\"\"],besseli:[75,4,1,\"\"],besselix:[75,4,1,\"\"],besselj0:[75,4,1,\"\"],besselj1:[75,4,1,\"\"],besselj:[75,4,1,\"\"],besseljx:[75,4,1,\"\"],besselk:[75,4,1,\"\"],besselkx:[75,4,1,\"\"],bessely0:[75,4,1,\"\"],bessely1:[75,4,1,\"\"],bessely:[75,4,1,\"\"],besselyx:[75,4,1,\"\"],beta:[75,4,1,\"\"],bfft:[75,4,1,\"\"],big:[76,4,1,\"\"],bin:[76,4,1,\"\"],bind:[71,4,1,\"\"],binomial:[75,4,1,\"\"],bitbroadcast:[63,4,1,\"\"],bitrand:[76,4,1,\"\"],bits:[76,4,1,\"\"],bkfact:[74,4,1,\"\"],blkdiag:[74,4,1,\"\"],brfft:[75,4,1,\"\"],broadcast:[63,4,1,\"\"],broadcast_getindex:[63,4,1,\"\"],bswap:[76,4,1,\"\"],bytes2hex:[76,4,1,\"\"],cat:[63,4,1,\"\"],catalan:[76,5,1,\"\"],catch_backtrace:[64,4,1,\"\"],catch_stacktrace:[83,4,1,\"\"],cbrt:[75,4,1,\"\"],ccall:[65,4,1,\"\"],cconvert:[65,4,1,\"\"],cd:[69,4,1,\"\"],ceil:[75,4,1,\"\"],cfunction:[65,4,1,\"\"],cglobal:[65,4,1,\"\"],charwidth:[84,4,1,\"\"],checkbounds:[63,4,1,\"\"],checkindex:[63,4,1,\"\"],chmod:[69,4,1,\"\"],chol:[74,4,1,\"\"],cholfact:[74,4,1,\"\"],chomp:[84,4,1,\"\"],chop:[84,4,1,\"\"],chown:[69,4,1,\"\"],chr2ind:[84,4,1,\"\"],circshift:[63,4,1,\"\"],cis:[75,4,1,\"\"],clamp:[75,4,1,\"\"],cld:[75,4,1,\"\"],clipboard:[64,4,1,\"\"],close:[77,4,1,\"\"],cmp:[75,4,1,\"\"],code_llvm:[64,4,1,\"\"],code_lowered:[64,4,1,\"\"],code_native:[64,4,1,\"\"],code_typed:[64,4,1,\"\"],code_warntype:[64,4,1,\"\"],collect:[66,4,1,\"\"],colon:[75,4,1,\"\"],complex:[76,4,1,\"\"],cond:[74,4,1,\"\"],condskeel:[74,4,1,\"\"],conj:[75,4,1,\"\"],connect:[77,4,1,\"\"],consume:[77,4,1,\"\"],contains:[84,4,1,\"\"],conv2:[75,4,1,\"\"],conv:[75,4,1,\"\"],convert:[64,4,1,\"\"],copy:[64,4,1,\"\"],copysign:[75,4,1,\"\"],cor:[75,4,1,\"\"],cos:[75,4,1,\"\"],cosc:[75,4,1,\"\"],cosd:[75,4,1,\"\"],cosh:[75,4,1,\"\"],cospi:[75,4,1,\"\"],cot:[75,4,1,\"\"],cotd:[75,4,1,\"\"],coth:[75,4,1,\"\"],count:[66,4,1,\"\"],count_ones:[76,4,1,\"\"],count_zeros:[76,4,1,\"\"],countfrom:[66,4,1,\"\"],countlines:[71,4,1,\"\"],countnz:[63,4,1,\"\"],cov:[75,4,1,\"\"],cp:[69,4,1,\"\"],cross:[74,4,1,\"\"],csc:[75,4,1,\"\"],cscd:[75,4,1,\"\"],csch:[75,4,1,\"\"],ctime:[69,4,1,\"\"],ctranspose:[74,4,1,\"\"],cummax:[63,4,1,\"\"],cummin:[63,4,1,\"\"],cumprod:[63,4,1,\"\"],cumsum:[63,4,1,\"\"],cumsum_kbn:[63,4,1,\"\"],current_module:[64,4,1,\"\"],current_task:[77,4,1,\"\"],cycle:[66,4,1,\"\"],dawson:[75,4,1,\"\"],dct:[75,4,1,\"\"],dec:[76,4,1,\"\"],deconv:[75,4,1,\"\"],deepcopy:[64,4,1,\"\"],default_worker_pool:[77,4,1,\"\"],deg2rad:[75,4,1,\"\"],den:[75,4,1,\"\"],deserialize:[71,4,1,\"\"],det:[74,4,1,\"\"],detach:[64,4,1,\"\"],diag:[74,4,1,\"\"],diagind:[74,4,1,\"\"],diagm:[74,4,1,\"\"],diff:[63,4,1,\"\"],digamma:[75,4,1,\"\"],digits:[76,4,1,\"\"],dirname:[69,4,1,\"\"],disable_sigint:[65,4,1,\"\"],display:[71,4,1,\"\"],displayable:[71,4,1,\"\"],displaysize:[71,4,1,\"\"],div:[75,4,1,\"\"],divrem:[75,4,1,\"\"],done:[66,4,1,\"\"],dot:[74,4,1,\"\"],download:[69,4,1,\"\"],drop:[66,4,1,\"\"],dropzeros:[63,4,1,\"\"],dump:[71,4,1,\"\"],e:[76,5,1,\"\"],eachindex:[63,4,1,\"\"],eachline:[71,4,1,\"\"],eachmatch:[84,4,1,\"\"],edit:[64,4,1,\"\"],eig:[74,4,1,\"\"],eigfact:[74,4,1,\"\"],eigmax:[74,4,1,\"\"],eigmin:[74,4,1,\"\"],eigs:[74,4,1,\"\"],eigvals:[74,4,1,\"\"],eigvecs:[74,4,1,\"\"],eltype:[66,4,1,\"\"],endof:[66,4,1,\"\"],endswith:[84,4,1,\"\"],enumerate:[66,4,1,\"\"],eof:[71,4,1,\"\"],eps:[64,4,1,\"\"],erf:[75,4,1,\"\"],erfc:[75,4,1,\"\"],erfcinv:[75,4,1,\"\"],erfcx:[75,4,1,\"\"],erfi:[75,4,1,\"\"],erfinv:[75,4,1,\"\"],error:[64,4,1,\"\"],esc:[64,4,1,\"\"],escape_string:[84,4,1,\"\"],eta:[75,4,1,\"\"],eu:[76,5,1,\"\"],eulergamma:[76,5,1,\"\"],eval:[64,4,1,\"\"],evalfile:[64,4,1,\"\"],exit:[64,4,1,\"\"],exp10:[75,4,1,\"\"],exp2:[75,4,1,\"\"],exp:[75,4,1,\"\"],expand:[64,4,1,\"\"],expanduser:[69,4,1,\"\"],expm1:[75,4,1,\"\"],expm:[74,4,1,\"\"],exponent:[76,4,1,\"\"],extrema:[66,4,1,\"\"],eye:[63,4,1,\"\"],factorial:[75,4,1,\"\"],factorize:[74,4,1,\"\"],falses:[63,4,1,\"\"],fd:[71,4,1,\"\"],fdio:[71,4,1,\"\"],fetch:[77,4,1,\"\"],fft:[75,4,1,\"\"],fftshift:[75,4,1,\"\"],fieldname:[64,4,1,\"\"],fieldnames:[64,4,1,\"\"],fieldoffset:[64,4,1,\"\"],fieldtype:[64,4,1,\"\"],filemode:[69,4,1,\"\"],filesize:[69,4,1,\"\"],fill:[63,4,1,\"\"],filt:[75,4,1,\"\"],filter:[66,4,1,\"\"],finalize:[64,4,1,\"\"],finalizer:[64,4,1,\"\"],find:[63,4,1,\"\"],findfirst:[63,4,1,\"\"],findin:[66,4,1,\"\"],findlast:[63,4,1,\"\"],findmax:[66,4,1,\"\"],findmin:[66,4,1,\"\"],findn:[63,4,1,\"\"],findnext:[63,4,1,\"\"],findnz:[63,4,1,\"\"],findprev:[63,4,1,\"\"],first:[66,4,1,\"\"],fld1:[75,4,1,\"\"],fld:[75,4,1,\"\"],fldmod1:[75,4,1,\"\"],fldmod:[75,4,1,\"\"],flipdim:[63,4,1,\"\"],flipsign:[75,4,1,\"\"],floor:[75,4,1,\"\"],flush:[71,4,1,\"\"],fma:[75,4,1,\"\"],foldl:[66,4,1,\"\"],foldr:[66,4,1,\"\"],foreach:[66,4,1,\"\"],frexp:[75,4,1,\"\"],full:[74,4,1,\"\"],fullname:[64,4,1,\"\"],functionloc:[64,4,1,\"\"],gamma:[75,4,1,\"\"],gc:[64,4,1,\"\"],gc_enable:[64,4,1,\"\"],gcd:[75,4,1,\"\"],gcdx:[75,4,1,\"\"],gensym:[64,4,1,\"\"],get:[66,4,1,\"\"],get_zero_subnormals:[76,4,1,\"\"],getaddrinfo:[71,4,1,\"\"],getfield:[64,4,1,\"\"],gethostname:[64,4,1,\"\"],getindex:[66,4,1,\"\"],getipaddr:[64,4,1,\"\"],getkey:[66,4,1,\"\"],getpid:[64,4,1,\"\"],getsockname:[71,4,1,\"\"],givens:[74,4,1,\"\"],golden:[76,5,1,\"\"],gperm:[69,4,1,\"\"],gradient:[63,4,1,\"\"],graphemes:[84,4,1,\"\"],hankelh1:[75,4,1,\"\"],hankelh1x:[75,4,1,\"\"],hankelh2:[75,4,1,\"\"],hankelh2x:[75,4,1,\"\"],hash:[64,4,1,\"\"],haskey:[66,4,1,\"\"],hcat:[63,4,1,\"\"],hessfact:[74,4,1,\"\"],hex2bytes:[76,4,1,\"\"],hex2num:[76,4,1,\"\"],hex:[76,4,1,\"\"],homedir:[69,4,1,\"\"],htol:[71,4,1,\"\"],hton:[71,4,1,\"\"],hvcat:[63,4,1,\"\"],hypot:[75,4,1,\"\"],idct:[75,4,1,\"\"],identity:[64,4,1,\"\"],ifelse:[64,4,1,\"\"],ifft:[75,4,1,\"\"],ifftshift:[75,4,1,\"\"],ignorestatus:[64,4,1,\"\"],im:[76,5,1,\"\"],imag:[75,4,1,\"\"],include:[64,4,1,\"\"],include_dependency:[64,4,1,\"\"],include_string:[64,4,1,\"\"],ind2chr:[84,4,1,\"\"],ind2sub:[63,4,1,\"\"],indexin:[66,4,1,\"\"],indexpids:[77,4,1,\"\"],indices:[63,4,1,\"\"],indmax:[66,4,1,\"\"],indmin:[66,4,1,\"\"],info:[71,4,1,\"\"],init_worker:[77,4,1,\"\"],instances:[64,4,1,\"\"],interrupt:[77,4,1,\"\"],intersect:[66,4,1,\"\"],inv:[74,4,1,\"\"],invdigamma:[75,4,1,\"\"],invmod:[75,4,1,\"\"],invoke:[64,4,1,\"\"],invperm:[63,4,1,\"\"],ipermutedims:[63,4,1,\"\"],irfft:[75,4,1,\"\"],is:[64,4,1,\"\"],is_apple:[64,4,1,\"\"],is_assigned_char:[84,4,1,\"\"],is_bsd:[64,4,1,\"\"],is_linux:[64,4,1,\"\"],is_unix:[64,4,1,\"\"],is_windows:[64,4,1,\"\"],isa:[64,4,1,\"\"],isabspath:[69,4,1,\"\"],isalnum:[84,4,1,\"\"],isalpha:[84,4,1,\"\"],isapprox:[75,4,1,\"\"],isascii:[84,4,1,\"\"],isassigned:[63,4,1,\"\"],isbits:[64,4,1,\"\"],isblockdev:[69,4,1,\"\"],ischardev:[69,4,1,\"\"],iscntrl:[84,4,1,\"\"],isconst:[64,4,1,\"\"],isdefined:[64,4,1,\"\"],isdiag:[74,4,1,\"\"],isdigit:[84,4,1,\"\"],isdir:[69,4,1,\"\"],isdirpath:[69,4,1,\"\"],isempty:[66,4,1,\"\"],isequal:[64,4,1,\"\"],iseven:[76,4,1,\"\"],isfifo:[69,4,1,\"\"],isfile:[69,4,1,\"\"],isfinite:[76,4,1,\"\"],isgraph:[84,4,1,\"\"],ishermitian:[74,4,1,\"\"],isimag:[76,4,1,\"\"],isimmutable:[64,4,1,\"\"],isinf:[76,4,1,\"\"],isinteger:[76,4,1,\"\"],isinteractive:[64,4,1,\"\"],isleaftype:[64,4,1,\"\"],isless:[64,4,1,\"\"],islink:[69,4,1,\"\"],islocked:[77,4,1,\"\"],islower:[84,4,1,\"\"],ismarked:[71,4,1,\"\"],ismatch:[84,4,1,\"\"],ismount:[69,4,1,\"\"],isnan:[76,4,1,\"\"],isnull:[64,4,1,\"\"],isnumber:[84,4,1,\"\"],isodd:[76,4,1,\"\"],isopen:[71,4,1,\"\"],ispath:[69,4,1,\"\"],isperm:[63,4,1,\"\"],isposdef:[74,4,1,\"\"],ispow2:[75,4,1,\"\"],isprint:[84,4,1,\"\"],ispunct:[84,4,1,\"\"],isqrt:[75,4,1,\"\"],isreadable:[71,4,1,\"\"],isreadonly:[71,4,1,\"\"],isready:[77,4,1,\"\"],isreal:[76,4,1,\"\"],issetgid:[69,4,1,\"\"],issetuid:[69,4,1,\"\"],issocket:[69,4,1,\"\"],issorted:[82,4,1,\"\"],isspace:[84,4,1,\"\"],issparse:[63,4,1,\"\"],issticky:[69,4,1,\"\"],issubnormal:[76,4,1,\"\"],issubset:[66,4,1,\"\"],issubtype:[64,4,1,\"\"],issymmetric:[74,4,1,\"\"],istaskdone:[77,4,1,\"\"],istaskstarted:[77,4,1,\"\"],istextmime:[71,4,1,\"\"],istril:[74,4,1,\"\"],istriu:[74,4,1,\"\"],isupper:[84,4,1,\"\"],isvalid:[84,4,1,\"\"],iswritable:[71,4,1,\"\"],isxdigit:[84,4,1,\"\"],iteratoreltype:[66,4,1,\"\"],iteratorsize:[66,4,1,\"\"],join:[84,4,1,\"\"],joinpath:[69,4,1,\"\"],keys:[66,4,1,\"\"],keytype:[66,4,1,\"\"],kill:[77,4,1,\"\"],kron:[74,4,1,\"\"],last:[66,4,1,\"\"],launch:[77,4,1,\"\"],lbeta:[75,4,1,\"\"],lcfirst:[84,4,1,\"\"],lcm:[75,4,1,\"\"],ldexp:[75,4,1,\"\"],ldltfact:[74,4,1,\"\"],leading_ones:[76,4,1,\"\"],leading_zeros:[76,4,1,\"\"],length:[84,4,1,\"\"],less:[64,4,1,\"\"],lexcmp:[64,4,1,\"\"],lexless:[64,4,1,\"\"],lfact:[75,4,1,\"\"],lgamma:[75,4,1,\"\"],linearindices:[63,4,1,\"\"],linreg:[74,4,1,\"\"],linspace:[63,4,1,\"\"],listen:[71,4,1,\"\"],listenany:[71,4,1,\"\"],llvmcall:[65,4,1,\"\"],localindexes:[77,4,1,\"\"],lock:[77,4,1,\"\"],log10:[75,4,1,\"\"],log1p:[75,4,1,\"\"],log2:[75,4,1,\"\"],log:[75,4,1,\"\"],logabsdet:[74,4,1,\"\"],logdet:[74,4,1,\"\"],logm:[74,4,1,\"\"],logspace:[63,4,1,\"\"],lowercase:[84,4,1,\"\"],lpad:[84,4,1,\"\"],lq:[74,4,1,\"\"],lqfact:[74,4,1,\"\"],lstat:[69,4,1,\"\"],lstrip:[84,4,1,\"\"],ltoh:[71,4,1,\"\"],lu:[74,4,1,\"\"],lufact:[74,4,1,\"\"],lyap:[74,4,1,\"\"],macroexpand:[64,4,1,\"\"],manage:[77,4,1,\"\"],map:[66,4,1,\"\"],mapfoldl:[66,4,1,\"\"],mapfoldr:[66,4,1,\"\"],mapreduce:[66,4,1,\"\"],mapreducedim:[63,4,1,\"\"],mapslices:[63,4,1,\"\"],mark:[71,4,1,\"\"],match:[84,4,1,\"\"],matchall:[84,4,1,\"\"],max:[75,4,1,\"\"],maxabs:[66,4,1,\"\"],maximum:[66,4,1,\"\"],maxintfloat:[64,4,1,\"\"],mean:[75,4,1,\"\"],median:[75,4,1,\"\"],merge:[66,4,1,\"\"],method_exists:[64,4,1,\"\"],methods:[64,4,1,\"\"],methodswith:[64,4,1,\"\"],middle:[75,4,1,\"\"],midpoints:[75,4,1,\"\"],mimewritable:[71,4,1,\"\"],min:[75,4,1,\"\"],minabs:[66,4,1,\"\"],minimum:[66,4,1,\"\"],minmax:[75,4,1,\"\"],mkdir:[69,4,1,\"\"],mkpath:[69,4,1,\"\"],mktemp:[69,4,1,\"\"],mktempdir:[69,4,1,\"\"],mod1:[75,4,1,\"\"],mod2pi:[75,4,1,\"\"],mod:[75,4,1,\"\"],modf:[75,4,1,\"\"],module_name:[64,4,1,\"\"],module_parent:[64,4,1,\"\"],mtime:[69,4,1,\"\"],muladd:[75,4,1,\"\"],mv:[69,4,1,\"\"],myid:[77,4,1,\"\"],names:[64,4,1,\"\"],nb_available:[71,4,1,\"\"],ndigits:[75,4,1,\"\"],ndims:[63,4,1,\"\"],next:[66,4,1,\"\"],nextfloat:[76,4,1,\"\"],nextind:[84,4,1,\"\"],nextpow2:[75,4,1,\"\"],nextpow:[75,4,1,\"\"],nextprod:[75,4,1,\"\"],nfields:[64,4,1,\"\"],nnz:[63,4,1,\"\"],nonzeros:[63,4,1,\"\"],norm:[74,4,1,\"\"],normalize:[74,4,1,\"\"],normalize_string:[84,4,1,\"\"],normpath:[69,4,1,\"\"],nothing:[67,5,1,\"\"],notify:[77,4,1,\"\"],nprocs:[77,4,1,\"\"],ntoh:[71,4,1,\"\"],ntuple:[64,4,1,\"\"],nullspace:[74,4,1,\"\"],num2hex:[76,4,1,\"\"],num:[75,4,1,\"\"],nworkers:[77,4,1,\"\"],nzrange:[63,4,1,\"\"],object_id:[64,4,1,\"\"],oct:[76,4,1,\"\"],oftype:[64,4,1,\"\"],one:[76,4,1,\"\"],ones:[63,4,1,\"\"],open:[71,4,1,\"\"],operm:[69,4,1,\"\"],ordschur:[74,4,1,\"\"],parent:[63,4,1,\"\"],parentindexes:[63,4,1,\"\"],parse:[76,4,1,\"\"],peakflops:[74,4,1,\"\"],permutedims:[63,4,1,\"\"],pi:[76,5,1,\"\"],pinv:[74,4,1,\"\"],pipeline:[64,4,1,\"\"],plan_bfft:[75,4,1,\"\"],plan_brfft:[75,4,1,\"\"],plan_dct:[75,4,1,\"\"],plan_fft:[75,4,1,\"\"],plan_idct:[75,4,1,\"\"],plan_ifft:[75,4,1,\"\"],plan_irfft:[75,4,1,\"\"],plan_rfft:[75,4,1,\"\"],pmap:[77,4,1,\"\"],pointer:[65,4,1,\"\"],pointer_from_objref:[65,4,1,\"\"],poll_fd:[71,4,1,\"\"],poll_file:[71,4,1,\"\"],polygamma:[75,4,1,\"\"],popdisplay:[71,4,1,\"\"],position:[71,4,1,\"\"],powermod:[75,4,1,\"\"],precision:[76,4,1,\"\"],precompile:[64,4,1,\"\"],prevfloat:[76,4,1,\"\"],prevind:[84,4,1,\"\"],prevpow2:[75,4,1,\"\"],prevpow:[75,4,1,\"\"],print:[71,4,1,\"\"],print_shortest:[71,4,1,\"\"],print_with_color:[71,4,1,\"\"],println:[71,4,1,\"\"],process_exited:[64,4,1,\"\"],process_running:[64,4,1,\"\"],procs:[77,4,1,\"\"],prod:[66,4,1,\"\"],produce:[77,4,1,\"\"],promote:[64,4,1,\"\"],promote_rule:[64,4,1,\"\"],promote_shape:[63,4,1,\"\"],promote_type:[64,4,1,\"\"],pushdisplay:[71,4,1,\"\"],pwd:[69,4,1,\"\"],qr:[74,4,1,\"\"],qrfact:[74,4,1,\"\"],quadgk:[75,4,1,\"\"],quantile:[75,4,1,\"\"],quit:[64,4,1,\"\"],rad2deg:[75,4,1,\"\"],rand:[76,4,1,\"\"],randcycle:[63,4,1,\"\"],randexp:[76,4,1,\"\"],randjump:[76,4,1,\"\"],randn:[76,4,1,\"\"],randperm:[63,4,1,\"\"],randstring:[84,4,1,\"\"],randsubseq:[63,4,1,\"\"],range:[75,4,1,\"\"],rank:[74,4,1,\"\"],rationalize:[75,4,1,\"\"],read:[71,4,1,\"\"],readandwrite:[64,4,1,\"\"],readavailable:[71,4,1,\"\"],readchomp:[71,4,1,\"\"],readcsv:[71,4,1,\"\"],readdir:[69,4,1,\"\"],readdlm:[71,4,1,\"\"],readline:[71,4,1,\"\"],readlines:[71,4,1,\"\"],readlink:[69,4,1,\"\"],readstring:[71,4,1,\"\"],readuntil:[71,4,1,\"\"],real:[75,4,1,\"\"],realmax:[64,4,1,\"\"],realmin:[64,4,1,\"\"],realpath:[69,4,1,\"\"],recv:[71,4,1,\"\"],recvfrom:[71,4,1,\"\"],redirect_stderr:[71,4,1,\"\"],redirect_stdin:[71,4,1,\"\"],redirect_stdout:[71,4,1,\"\"],redisplay:[71,4,1,\"\"],reduce:[66,4,1,\"\"],reducedim:[63,4,1,\"\"],reenable_sigint:[65,4,1,\"\"],reim:[75,4,1,\"\"],reinterpret:[63,4,1,\"\"],release:[77,4,1,\"\"],reload:[64,4,1,\"\"],relpath:[69,4,1,\"\"],rem:[75,4,1,\"\"],remote:[77,4,1,\"\"],remotecall:[77,4,1,\"\"],remotecall_fetch:[77,4,1,\"\"],remotecall_wait:[77,4,1,\"\"],repeat:[74,4,1,\"\"],repeated:[66,4,1,\"\"],replace:[84,4,1,\"\"],repmat:[74,4,1,\"\"],repr:[84,4,1,\"\"],reprmime:[71,4,1,\"\"],require:[64,4,1,\"\"],reset:[71,4,1,\"\"],reshape:[63,4,1,\"\"],rest:[66,4,1,\"\"],rethrow:[64,4,1,\"\"],retry:[64,4,1,\"\"],reverse:[84,4,1,\"\"],reverseind:[63,4,1,\"\"],rfft:[75,4,1,\"\"],rm:[69,4,1,\"\"],rmprocs:[77,4,1,\"\"],rol:[63,4,1,\"\"],ror:[63,4,1,\"\"],rot180:[63,4,1,\"\"],rotl90:[63,4,1,\"\"],rotr90:[63,4,1,\"\"],round:[75,4,1,\"\"],rounding:[76,4,1,\"\"],rowvals:[63,4,1,\"\"],rpad:[84,4,1,\"\"],rsearch:[84,4,1,\"\"],rsearchindex:[84,4,1,\"\"],rsplit:[84,4,1,\"\"],rstrip:[84,4,1,\"\"],run:[64,4,1,\"\"],runtests:[85,4,1,\"\"],schedule:[77,4,1,\"\"],schur:[74,4,1,\"\"],schurfact:[74,4,1,\"\"],sdata:[77,4,1,\"\"],search:[84,4,1,\"\"],searchindex:[84,4,1,\"\"],searchsorted:[82,4,1,\"\"],searchsortedfirst:[82,4,1,\"\"],searchsortedlast:[82,4,1,\"\"],sec:[75,4,1,\"\"],secd:[75,4,1,\"\"],sech:[75,4,1,\"\"],seek:[71,4,1,\"\"],seekend:[71,4,1,\"\"],seekstart:[71,4,1,\"\"],select:[82,4,1,\"\"],selectperm:[82,4,1,\"\"],send:[71,4,1,\"\"],serialize:[71,4,1,\"\"],set_zero_subnormals:[76,4,1,\"\"],setdiff:[66,4,1,\"\"],setenv:[64,4,1,\"\"],setopt:[71,4,1,\"\"],setprecision:[76,4,1,\"\"],setrounding:[76,4,1,\"\"],show:[71,4,1,\"\"],showall:[71,4,1,\"\"],showcompact:[71,4,1,\"\"],showerror:[71,4,1,\"\"],shuffle:[63,4,1,\"\"],sign:[75,4,1,\"\"],signbit:[75,4,1,\"\"],signed:[76,4,1,\"\"],signif:[75,4,1,\"\"],significand:[76,4,1,\"\"],similar:[63,4,1,\"\"],sin:[75,4,1,\"\"],sinc:[75,4,1,\"\"],sind:[75,4,1,\"\"],sinh:[75,4,1,\"\"],sinpi:[75,4,1,\"\"],size:[63,4,1,\"\"],sizeof:[84,4,1,\"\"],skip:[71,4,1,\"\"],skipchars:[71,4,1,\"\"],sleep:[77,4,1,\"\"],slicedim:[63,4,1,\"\"],sort:[82,4,1,\"\"],sortcols:[82,4,1,\"\"],sortperm:[82,4,1,\"\"],sortrows:[82,4,1,\"\"],sparse:[63,4,1,\"\"],sparsevec:[63,4,1,\"\"],spawn:[64,4,1,\"\"],spdiagm:[63,4,1,\"\"],speye:[63,4,1,\"\"],split:[84,4,1,\"\"],splitdir:[69,4,1,\"\"],splitdrive:[69,4,1,\"\"],splitext:[69,4,1,\"\"],spones:[63,4,1,\"\"],sprand:[63,4,1,\"\"],sprandn:[63,4,1,\"\"],sprint:[71,4,1,\"\"],spzeros:[63,4,1,\"\"],sqrt:[75,4,1,\"\"],sqrtm:[74,4,1,\"\"],squeeze:[63,4,1,\"\"],srand:[76,4,1,\"\"],stacktrace:[83,4,1,\"\"],start:[66,4,1,\"\"],startswith:[84,4,1,\"\"],stat:[69,4,1,\"\"],std:[75,4,1,\"\"],stdm:[75,4,1,\"\"],step:[66,4,1,\"\"],stride:[63,4,1,\"\"],strides:[63,4,1,\"\"],string:[84,4,1,\"\"],stringmime:[71,4,1,\"\"],strip:[84,4,1,\"\"],strwidth:[84,4,1,\"\"],sub2ind:[63,4,1,\"\"],subtypes:[64,4,1,\"\"],success:[64,4,1,\"\"],sum:[66,4,1,\"\"],sum_kbn:[63,4,1,\"\"],sumabs2:[66,4,1,\"\"],sumabs:[66,4,1,\"\"],summary:[71,4,1,\"\"],supertype:[64,4,1,\"\"],svd:[74,4,1,\"\"],svdfact:[74,4,1,\"\"],svds:[74,4,1,\"\"],svdvals:[74,4,1,\"\"],sylvester:[74,4,1,\"\"],symdiff:[66,4,1,\"\"],symlink:[69,4,1,\"\"],systemerror:[65,4,1,\"\"],take:[66,4,1,\"\"],takebuf_array:[71,4,1,\"\"],takebuf_string:[71,4,1,\"\"],tan:[75,4,1,\"\"],tand:[75,4,1,\"\"],tanh:[75,4,1,\"\"],task_local_storage:[77,4,1,\"\"],tempdir:[69,4,1,\"\"],tempname:[69,4,1,\"\"],tic:[64,4,1,\"\"],time:[64,4,1,\"\"],time_ns:[64,4,1,\"\"],timedwait:[77,4,1,\"\"],toc:[64,4,1,\"\"],toq:[64,4,1,\"\"],touch:[69,4,1,\"\"],trace:[74,4,1,\"\"],trailing_ones:[76,4,1,\"\"],trailing_zeros:[76,4,1,\"\"],transcode:[84,4,1,\"\"],transpose:[74,4,1,\"\"],trigamma:[75,4,1,\"\"],tril:[74,4,1,\"\"],triu:[74,4,1,\"\"],trues:[63,4,1,\"\"],trunc:[75,4,1,\"\"],truncate:[71,4,1,\"\"],trylock:[77,4,1,\"\"],tryparse:[76,4,1,\"\"],tuple:[64,4,1,\"\"],typeintersect:[64,4,1,\"\"],typejoin:[64,4,1,\"\"],typemax:[64,4,1,\"\"],typemin:[64,4,1,\"\"],ucfirst:[84,4,1,\"\"],unescape_string:[84,4,1,\"\"],union:[66,4,1,\"\"],unique:[66,4,1,\"\"],unlock:[77,4,1,\"\"],unmark:[71,4,1,\"\"],unsafe_convert:[65,4,1,\"\"],unsafe_load:[65,4,1,\"\"],unsafe_pointer_to_objref:[65,4,1,\"\"],unsafe_read:[71,4,1,\"\"],unsafe_string:[84,4,1,\"\"],unsafe_trunc:[75,4,1,\"\"],unsafe_wrap:[84,4,1,\"\"],unsafe_write:[71,4,1,\"\"],unsigned:[76,4,1,\"\"],uperm:[69,4,1,\"\"],uppercase:[84,4,1,\"\"],valtype:[66,4,1,\"\"],values:[66,4,1,\"\"],varm:[75,4,1,\"\"],vcat:[63,4,1,\"\"],vec:[63,4,1,\"\"],vecdot:[74,4,1,\"\"],vecnorm:[74,4,1,\"\"],versioninfo:[64,4,1,\"\"],view:[63,4,1,\"\"],wait:[77,4,1,\"\"],walkdir:[69,4,1,\"\"],warn:[71,4,1,\"\"],watch_file:[71,4,1,\"\"],which:[64,4,1,\"\"],whos:[64,4,1,\"\"],widemul:[75,4,1,\"\"],widen:[64,4,1,\"\"],windows_version:[64,4,1,\"\"],withenv:[64,4,1,\"\"],workers:[77,4,1,\"\"],workspace:[64,4,1,\"\"],write:[71,4,1,\"\"],writecsv:[71,4,1,\"\"],writedlm:[71,4,1,\"\"],xcorr:[75,4,1,\"\"],yield:[77,4,1,\"\"],yieldto:[77,4,1,\"\"],zero:[76,4,1,\"\"],zeros:[63,4,1,\"\"],zeta:[75,4,1,\"\"],zip:[66,4,1,\"\"]},Dates:{\"UTInstant{T}\":[68,5,1,\"\"],\"default\":[68,4,1,\"\"],\"recur{T&lt;:TimeType}\":[68,4,1,\"Dates.recur{T<:TimeType}\"],CompoundPeriod:[68,7,1,\"\"],Date:[68,5,1,\"\"],DateFormat:[68,4,1,\"\"],DateTime:[68,5,1,\"\"],Day:[68,5,1,\"\"],Hour:[68,5,1,\"\"],Instant:[68,5,1,\"\"],Millisecond:[68,5,1,\"\"],Minute:[68,5,1,\"\"],Month:[68,5,1,\"\"],Period:[68,5,1,\"\"],Second:[68,5,1,\"\"],TimeType:[68,5,1,\"\"],Week:[68,5,1,\"\"],Year:[68,5,1,\"\"],ceil:[68,4,1,\"\"],date2epochdays:[68,4,1,\"\"],datetime2epochms:[68,4,1,\"\"],datetime2julian:[68,4,1,\"\"],datetime2rata:[68,4,1,\"\"],datetime2unix:[68,4,1,\"\"],day:[68,4,1,\"\"],dayabbr:[68,4,1,\"\"],dayname:[68,4,1,\"\"],dayofmonth:[68,4,1,\"\"],dayofquarter:[68,4,1,\"\"],dayofweek:[68,4,1,\"\"],dayofweekofmonth:[68,4,1,\"\"],dayofyear:[68,4,1,\"\"],daysinmonth:[68,4,1,\"\"],daysinyear:[68,4,1,\"\"],daysofweekinmonth:[68,4,1,\"\"],epochdays2date:[68,4,1,\"\"],epochms2datetime:[68,4,1,\"\"],eps:[68,4,1,\"\"],firstdayofmonth:[68,4,1,\"\"],firstdayofquarter:[68,4,1,\"\"],firstdayofweek:[68,4,1,\"\"],firstdayofyear:[68,4,1,\"\"],floor:[68,4,1,\"\"],floorceil:[68,4,1,\"\"],format:[68,4,1,\"\"],hour:[68,4,1,\"\"],isleapyear:[68,4,1,\"\"],julian2datetime:[68,4,1,\"\"],lastdayofmonth:[68,4,1,\"\"],lastdayofquarter:[68,4,1,\"\"],lastdayofweek:[68,4,1,\"\"],lastdayofyear:[68,4,1,\"\"],millisecond:[68,4,1,\"\"],minute:[68,4,1,\"\"],month:[68,4,1,\"\"],monthabbr:[68,4,1,\"\"],monthday:[68,4,1,\"\"],monthname:[68,4,1,\"\"],now:[68,4,1,\"\"],quarterofyear:[68,4,1,\"\"],rata2datetime:[68,4,1,\"\"],round:[68,4,1,\"\"],second:[68,4,1,\"\"],today:[68,4,1,\"\"],tofirst:[68,4,1,\"\"],tolast:[68,4,1,\"\"],tonext:[68,4,1,\"\"],toprev:[68,4,1,\"\"],trunc:[68,4,1,\"\"],unix2datetime:[68,4,1,\"\"],week:[68,4,1,\"\"],year:[68,4,1,\"\"],yearmonth:[68,4,1,\"\"],yearmonthday:[68,4,1,\"\"]}},objnames:{\"0\":[\"jl\",\"function\",\"Julia function\"],\"1\":[\"jl\",\"data\",\"Julia data\"],\"2\":[\"jl\",\"module\",\"Julia module\"],\"3\":[\"jl\",\"type\",\"type\"],\"4\":[\"py\",\"function\",\"Python function\"],\"5\":[\"py\",\"data\",\"Python data\"],\"6\":[\"py\",\"module\",\"Python module\"],\"7\":[\"py\",\"type\",\"type\"]},objtypes:{\"0\":\"jl:function\",\"1\":\"jl:data\",\"2\":\"jl:module\",\"3\":\"jl:type\",\"4\":\"py:function\",\"5\":\"py:data\",\"6\":\"py:module\",\"7\":\"py:type\"},terms:{\"0000001f\":52,\"00025f0\":39,\"000_000_005\":39,\"000a1\":59,\"000a3\":59,\"000a5\":59,\"000a6\":59,\"000a7\":59,\"000a8\":59,\"000a9\":59,\"000aa\":59,\"000ac\":59,\"000ae\":59,\"000af\":59,\"000b0\":59,\"000b1\":59,\"000b2\":59,\"000b3\":59,\"000b4\":59,\"000b6\":59,\"000b7\":59,\"000b9\":59,\"000ba\":59,\"000bc\":59,\"000bd\":59,\"000be\":59,\"000bf\":59,\"000c5\":59,\"000c6\":59,\"000d0\":59,\"000d7\":59,\"000d8\":59,\"000de\":59,\"000df\":59,\"000e5\":59,\"000e6\":59,\"000f0\":59,\"000f7\":59,\"000f8\":59,\"000fe\":59,\"0014a\":59,\"0014b\":59,\"0019e\":59,\"001b5\":59,\"001c2\":59,\"0025b\":59,\"0026c\":59,\"0026d\":59,\"0026f\":59,\"0027a\":59,\"0027b\":59,\"0027c\":59,\"0027d\":59,\"0027e\":59,\"0028a\":59,\"0028b\":59,\"0028c\":59,\"0028d\":59,\"0028e\":59,\"0029e\":59,\"002a4\":59,\"002a7\":59,\"002b0\":59,\"002b2\":59,\"002b3\":59,\"002b7\":59,\"002b8\":59,\"002bc\":59,\"002c7\":59,\"002c8\":59,\"002cc\":59,\"002d0\":59,\"002d1\":59,\"002d2\":59,\"002d3\":59,\"002d4\":59,\"002d5\":59,\"002d8\":59,\"002dc\":59,\"002e1\":59,\"002e2\":59,\"002e3\":59,\"0030a\":59,\"0030b\":59,\"0030c\":59,\"0031a\":59,\"0032a\":59,\"0034d\":59,\"0039a\":59,\"0039b\":59,\"0039c\":59,\"0039d\":59,\"0039e\":59,\"0039f\":59,\"003a0\":59,\"003a1\":59,\"003a3\":59,\"003a4\":59,\"003a5\":59,\"003a6\":59,\"003a7\":59,\"003a8\":59,\"003a9\":59,\"003b1\":59,\"003b2\":59,\"003b3\":59,\"003b4\":59,\"003b5\":59,\"003b6\":59,\"003b7\":59,\"003b8\":59,\"003b9\":59,\"003ba\":59,\"003bb\":59,\"003bc\":59,\"003bd\":59,\"003be\":59,\"003bf\":59,\"003c0\":59,\"003c1\":59,\"003c2\":59,\"003c3\":59,\"003c4\":59,\"003c5\":59,\"003c6\":59,\"003c7\":59,\"003c8\":59,\"003c9\":59,\"003d0\":59,\"003d1\":59,\"003d5\":59,\"003d6\":59,\"003d8\":59,\"003d9\":59,\"003da\":59,\"003db\":59,\"003dc\":59,\"003dd\":59,\"003de\":59,\"003df\":59,\"003e0\":59,\"003e1\":59,\"003f0\":59,\"003f1\":59,\"003f4\":59,\"003f5\":59,\"003f6\":59,\"00a0\":60,\"01d2c\":59,\"01d2e\":59,\"01d30\":59,\"01d31\":59,\"01d33\":59,\"01d34\":59,\"01d35\":59,\"01d36\":59,\"01d37\":59,\"01d38\":59,\"01d39\":59,\"01d3a\":59,\"01d3c\":59,\"01d3e\":59,\"01d3f\":59,\"01d40\":59,\"01d41\":59,\"01d42\":59,\"01d43\":59,\"01d45\":59,\"01d47\":59,\"01d48\":59,\"01d49\":59,\"01d4b\":59,\"01d4d\":59,\"01d4f\":59,\"01d50\":59,\"01d52\":59,\"01d56\":59,\"01d57\":59,\"01d58\":59,\"01d5b\":59,\"01d5d\":59,\"01d5e\":59,\"01d5f\":59,\"01d60\":59,\"01d61\":59,\"01d62\":59,\"01d63\":59,\"01d64\":59,\"01d65\":59,\"01d66\":59,\"01d67\":59,\"01d68\":59,\"01d69\":59,\"01d6a\":59,\"01d9c\":59,\"01da0\":59,\"01da5\":59,\"01db2\":59,\"01dbb\":59,\"01dbf\":59,\"01t00\":[31,68],\"01t12\":[31,68],\"0200a\":59,\"0201b\":59,\"0201c\":59,\"0201d\":59,\"0203a\":59,\"0203c\":59,\"0207a\":59,\"0207b\":59,\"0207c\":59,\"0207d\":59,\"0207e\":59,\"0207f\":59,\"0208a\":59,\"0208b\":59,\"0208c\":59,\"0208d\":59,\"0208e\":59,\"0209a\":59,\"0209b\":59,\"0209c\":59,\"020a7\":59,\"020ac\":59,\"020d0\":59,\"020d1\":59,\"020d2\":59,\"020d6\":59,\"020d7\":59,\"020db\":59,\"020dc\":59,\"020dd\":59,\"020de\":59,\"020df\":59,\"020e1\":59,\"020e4\":59,\"020e7\":59,\"020e8\":59,\"020e9\":59,\"020ec\":59,\"020ed\":59,\"020ee\":59,\"020ef\":59,\"020f0\":59,\"0210a\":59,\"0210b\":59,\"0210c\":59,\"0210d\":59,\"0210e\":59,\"0210f\":59,\"0211a\":59,\"0211b\":59,\"0211c\":59,\"0211d\":59,\"0211e\":59,\"0212b\":59,\"0212c\":59,\"0212d\":59,\"0212f\":59,\"0213c\":59,\"0213d\":59,\"0213e\":59,\"0213f\":59,\"0214a\":59,\"0214b\":59,\"0219a\":59,\"0219b\":59,\"0219c\":59,\"0219d\":59,\"0219e\":59,\"0219f\":59,\"021a0\":59,\"021a1\":59,\"021a2\":59,\"021a3\":59,\"021a4\":59,\"021a5\":59,\"021a6\":59,\"021a7\":59,\"021a8\":59,\"021a9\":59,\"021aa\":59,\"021ab\":59,\"021ac\":59,\"021ad\":59,\"021ae\":59,\"021af\":59,\"021b0\":59,\"021b1\":59,\"021b2\":59,\"021b3\":59,\"021b4\":59,\"021b5\":59,\"021b6\":59,\"021b7\":59,\"021b8\":59,\"021b9\":59,\"021ba\":59,\"021bb\":59,\"021bc\":59,\"021bd\":59,\"021be\":59,\"021bf\":59,\"021c0\":59,\"021c1\":59,\"021c2\":59,\"021c3\":59,\"021c4\":59,\"021c5\":59,\"021c6\":59,\"021c7\":59,\"021c8\":59,\"021c9\":59,\"021ca\":59,\"021cb\":59,\"021cc\":59,\"021cd\":59,\"021ce\":59,\"021cf\":59,\"021d0\":59,\"021d1\":59,\"021d2\":59,\"021d3\":59,\"021d4\":59,\"021d5\":59,\"021d6\":59,\"021d7\":59,\"021d8\":59,\"021d9\":59,\"021da\":59,\"021db\":59,\"021dc\":59,\"021dd\":59,\"021de\":59,\"021df\":59,\"021e0\":59,\"021e1\":59,\"021e2\":59,\"021e3\":59,\"021e4\":59,\"021e5\":59,\"021e6\":59,\"021e7\":59,\"021e8\":59,\"021e9\":59,\"021ea\":59,\"021f4\":59,\"021f5\":59,\"021f6\":59,\"021f7\":59,\"021f8\":59,\"021f9\":59,\"021fa\":59,\"021fb\":59,\"021fc\":59,\"021fd\":59,\"021fe\":59,\"021ff\":59,\"0220a\":59,\"0220b\":59,\"0220c\":59,\"0220d\":59,\"0220e\":59,\"0220f\":59,\"0221a\":59,\"0221b\":59,\"0221c\":59,\"0221d\":59,\"0221e\":59,\"0221f\":59,\"0222a\":59,\"0222b\":59,\"0222c\":59,\"0222d\":59,\"0222e\":59,\"0222f\":59,\"0223a\":59,\"0223b\":59,\"0223c\":59,\"0223d\":59,\"0223e\":59,\"0223f\":59,\"0224a\":59,\"0224b\":59,\"0224c\":59,\"0224d\":59,\"0224e\":59,\"0224f\":59,\"0225a\":59,\"0225b\":59,\"0225c\":59,\"0225d\":59,\"0225e\":59,\"0225f\":59,\"0226a\":59,\"0226b\":59,\"0226c\":59,\"0226d\":59,\"0226e\":59,\"0226f\":59,\"0227a\":59,\"0227b\":59,\"0227c\":59,\"0227d\":59,\"0227e\":59,\"0227f\":59,\"0228a\":59,\"0228b\":59,\"0228d\":59,\"0228e\":59,\"0228f\":59,\"0229a\":59,\"0229b\":59,\"0229c\":59,\"0229d\":59,\"0229e\":59,\"0229f\":59,\"022a0\":59,\"022a1\":59,\"022a2\":59,\"022a3\":59,\"022a4\":59,\"022a5\":59,\"022a7\":59,\"022a8\":59,\"022a9\":59,\"022aa\":59,\"022ab\":59,\"022ac\":59,\"022ad\":59,\"022ae\":59,\"022af\":59,\"022b0\":59,\"022b1\":59,\"022b2\":59,\"022b3\":59,\"022b4\":59,\"022b5\":59,\"022b6\":59,\"022b7\":59,\"022b8\":59,\"022b9\":59,\"022ba\":59,\"022bb\":59,\"022bc\":59,\"022bd\":59,\"022be\":59,\"022bf\":59,\"022c0\":59,\"022c1\":59,\"022c2\":59,\"022c3\":59,\"022c4\":59,\"022c5\":59,\"022c6\":59,\"022c7\":59,\"022c8\":59,\"022c9\":59,\"022ca\":59,\"022cb\":59,\"022cc\":59,\"022cd\":59,\"022ce\":59,\"022cf\":59,\"022d0\":59,\"022d1\":59,\"022d2\":59,\"022d3\":59,\"022d4\":59,\"022d5\":59,\"022d6\":59,\"022d7\":59,\"022d8\":59,\"022d9\":59,\"022da\":59,\"022db\":59,\"022dc\":59,\"022dd\":59,\"022de\":59,\"022df\":59,\"022e0\":59,\"022e1\":59,\"022e2\":59,\"022e3\":59,\"022e4\":59,\"022e5\":59,\"022e6\":59,\"022e7\":59,\"022e8\":59,\"022e9\":59,\"022ea\":59,\"022eb\":59,\"022ec\":59,\"022ed\":59,\"022ee\":59,\"022ef\":59,\"022f0\":59,\"022f1\":59,\"022f2\":59,\"022f3\":59,\"022f4\":59,\"022f5\":59,\"022f6\":59,\"022f7\":59,\"022f8\":59,\"022f9\":59,\"022fa\":59,\"022fb\":59,\"022fc\":59,\"022fd\":59,\"022fe\":59,\"022ff\":59,\"0230a\":59,\"0230b\":59,\"0231a\":59,\"0231b\":59,\"0231c\":59,\"0231d\":59,\"0231e\":59,\"0231f\":59,\"0232c\":59,\"0233d\":59,\"0233f\":59,\"023a3\":59,\"023b0\":59,\"023b1\":59,\"023b4\":59,\"023b5\":59,\"023b6\":59,\"023b7\":59,\"023b8\":59,\"023b9\":59,\"023ce\":59,\"023de\":59,\"023df\":59,\"023e2\":59,\"023e3\":59,\"023e4\":59,\"023e5\":59,\"023e6\":59,\"023e7\":59,\"023e9\":59,\"023ea\":59,\"023eb\":59,\"023ec\":59,\"023f0\":59,\"023f3\":59,\"024c2\":59,\"024c8\":59,\"0258c\":59,\"025a0\":59,\"025a1\":59,\"025a2\":59,\"025a3\":59,\"025a4\":59,\"025a5\":59,\"025a6\":59,\"025a7\":59,\"025a8\":59,\"025a9\":59,\"025aa\":59,\"025ab\":59,\"025ac\":59,\"025ad\":59,\"025ae\":59,\"025af\":59,\"025b0\":59,\"025b1\":59,\"025b2\":59,\"025b3\":59,\"025b4\":59,\"025b5\":59,\"025b6\":59,\"025b7\":59,\"025b8\":59,\"025b9\":59,\"025ba\":59,\"025bb\":59,\"025bc\":59,\"025bd\":59,\"025be\":59,\"025bf\":59,\"025c0\":59,\"025c1\":59,\"025c2\":59,\"025c3\":59,\"025c4\":59,\"025c5\":59,\"025c6\":59,\"025c7\":59,\"025c8\":59,\"025c9\":59,\"025ca\":59,\"025cb\":59,\"025cc\":59,\"025cd\":59,\"025ce\":59,\"025cf\":59,\"025d0\":59,\"025d1\":59,\"025d2\":59,\"025d3\":59,\"025d4\":59,\"025d5\":59,\"025d6\":59,\"025d7\":59,\"025d8\":59,\"025d9\":59,\"025da\":59,\"025db\":59,\"025dc\":59,\"025dd\":59,\"025de\":59,\"025df\":59,\"025e0\":59,\"025e1\":59,\"025e2\":59,\"025e3\":59,\"025e4\":59,\"025e5\":59,\"025e6\":59,\"025e7\":59,\"025e8\":59,\"025e9\":59,\"025ea\":59,\"025eb\":59,\"025ec\":59,\"025ed\":59,\"025ee\":59,\"025ef\":59,\"025f0\":59,\"025f1\":59,\"025f2\":59,\"025f3\":59,\"025f4\":59,\"025f5\":59,\"025f6\":59,\"025f7\":59,\"025f8\":59,\"025f9\":59,\"025fa\":59,\"025fb\":59,\"025fc\":59,\"025fd\":59,\"025fe\":59,\"025ff\":59,\"0260e\":59,\"0261d\":59,\"0263a\":59,\"0263b\":59,\"0263c\":59,\"0263d\":59,\"0263e\":59,\"0263f\":59,\"0264a\":59,\"0264b\":59,\"0264c\":59,\"0264d\":59,\"0264e\":59,\"0264f\":59,\"0266a\":59,\"0266b\":59,\"0266d\":59,\"0266e\":59,\"0266f\":59,\"0267b\":59,\"0267e\":59,\"0267f\":59,\"026a0\":59,\"026a1\":59,\"026a5\":59,\"026aa\":59,\"026ab\":59,\"026ac\":59,\"026b2\":59,\"026bd\":59,\"026be\":59,\"026c4\":59,\"026c5\":59,\"026ce\":59,\"026d4\":59,\"026ea\":59,\"026f2\":59,\"026f3\":59,\"026f5\":59,\"026fa\":59,\"026fd\":59,\"0270a\":59,\"0270b\":59,\"0270c\":59,\"0270f\":59,\"0272a\":59,\"0273d\":59,\"0274c\":59,\"0274e\":59,\"0279b\":59,\"027a1\":59,\"027b0\":59,\"027bf\":59,\"027c0\":59,\"027c1\":59,\"027c2\":59,\"027c8\":59,\"027c9\":59,\"027d1\":59,\"027d2\":59,\"027d5\":59,\"027d6\":59,\"027d7\":59,\"027d8\":59,\"027d9\":59,\"027e6\":59,\"027e7\":59,\"027e8\":59,\"027e9\":59,\"027f0\":59,\"027f1\":59,\"027f5\":59,\"027f6\":59,\"027f7\":59,\"027f8\":59,\"027f9\":59,\"027fa\":59,\"027fb\":59,\"027fc\":59,\"027fd\":59,\"027fe\":59,\"027ff\":59,\"0290a\":59,\"0290b\":59,\"0290c\":59,\"0290d\":59,\"0290e\":59,\"0290f\":59,\"0291d\":59,\"0291e\":59,\"0291f\":59,\"0292a\":59,\"0292b\":59,\"0292c\":59,\"0292d\":59,\"0292e\":59,\"0292f\":59,\"0294a\":59,\"0294b\":59,\"0294c\":59,\"0294d\":59,\"0294e\":59,\"0294f\":59,\"0295a\":59,\"0295b\":59,\"0295c\":59,\"0295d\":59,\"0295e\":59,\"0295f\":59,\"0296a\":59,\"0296b\":59,\"0296c\":59,\"0296d\":59,\"0296e\":59,\"0296f\":59,\"0299b\":59,\"0299c\":59,\"0299d\":59,\"0299e\":59,\"0299f\":59,\"029a0\":59,\"029a1\":59,\"029a2\":59,\"029a3\":59,\"029a4\":59,\"029a5\":59,\"029a6\":59,\"029a7\":59,\"029a8\":59,\"029a9\":59,\"029aa\":59,\"029ab\":59,\"029ac\":59,\"029ad\":59,\"029ae\":59,\"029af\":59,\"029b0\":59,\"029b1\":59,\"029b2\":59,\"029b3\":59,\"029b4\":59,\"029b7\":59,\"029b8\":59,\"029bc\":59,\"029be\":59,\"029bf\":59,\"029c0\":59,\"029c1\":59,\"029c4\":59,\"029c5\":59,\"029c6\":59,\"029c7\":59,\"029ca\":59,\"029cb\":59,\"029cf\":59,\"029d0\":59,\"029df\":59,\"029e1\":59,\"029e2\":59,\"029e3\":59,\"029e4\":59,\"029e5\":59,\"029eb\":59,\"029f4\":59,\"029f6\":59,\"029f7\":59,\"029fa\":59,\"029fb\":59,\"02a00\":59,\"02a01\":59,\"02a02\":59,\"02a03\":59,\"02a04\":59,\"02a05\":59,\"02a06\":59,\"02a07\":59,\"02a08\":59,\"02a09\":59,\"02a0a\":59,\"02a0b\":59,\"02a0c\":59,\"02a0d\":59,\"02a0e\":59,\"02a0f\":59,\"02a10\":59,\"02a11\":59,\"02a12\":59,\"02a13\":59,\"02a14\":59,\"02a15\":59,\"02a16\":59,\"02a18\":59,\"02a19\":59,\"02a1a\":59,\"02a1b\":59,\"02a1c\":59,\"02a1d\":59,\"02a22\":59,\"02a23\":59,\"02a24\":59,\"02a25\":59,\"02a26\":59,\"02a27\":59,\"02a28\":59,\"02a29\":59,\"02a2a\":59,\"02a2b\":59,\"02a2c\":59,\"02a2d\":59,\"02a2e\":59,\"02a2f\":59,\"02a30\":59,\"02a31\":59,\"02a32\":59,\"02a33\":59,\"02a34\":59,\"02a35\":59,\"02a36\":59,\"02a37\":59,\"02a38\":59,\"02a39\":59,\"02a3a\":59,\"02a3b\":59,\"02a3c\":59,\"02a3d\":59,\"02a3f\":59,\"02a40\":59,\"02a41\":59,\"02a42\":59,\"02a43\":59,\"02a44\":59,\"02a45\":59,\"02a4a\":59,\"02a4b\":59,\"02a4c\":59,\"02a4d\":59,\"02a4e\":59,\"02a4f\":59,\"02a50\":59,\"02a51\":59,\"02a52\":59,\"02a53\":59,\"02a54\":59,\"02a55\":59,\"02a56\":59,\"02a57\":59,\"02a58\":59,\"02a5a\":59,\"02a5b\":59,\"02a5c\":59,\"02a5d\":59,\"02a5e\":59,\"02a5f\":59,\"02a60\":59,\"02a61\":59,\"02a62\":59,\"02a63\":59,\"02a66\":59,\"02a67\":59,\"02a6a\":59,\"02a6b\":59,\"02a6c\":59,\"02a6d\":59,\"02a6e\":59,\"02a6f\":59,\"02a70\":59,\"02a71\":59,\"02a72\":59,\"02a73\":59,\"02a74\":59,\"02a75\":59,\"02a76\":59,\"02a77\":59,\"02a78\":59,\"02a79\":59,\"02a7a\":59,\"02a7b\":59,\"02a7c\":59,\"02a7d\":59,\"02a7e\":59,\"02a7f\":59,\"02a80\":59,\"02a81\":59,\"02a82\":59,\"02a83\":59,\"02a84\":59,\"02a85\":59,\"02a86\":59,\"02a87\":59,\"02a88\":59,\"02a89\":59,\"02a8a\":59,\"02a8b\":59,\"02a8c\":59,\"02a8d\":59,\"02a8e\":59,\"02a8f\":59,\"02a90\":59,\"02a91\":59,\"02a92\":59,\"02a93\":59,\"02a94\":59,\"02a95\":59,\"02a96\":59,\"02a97\":59,\"02a98\":59,\"02a99\":59,\"02a9a\":59,\"02a9b\":59,\"02a9c\":59,\"02a9d\":59,\"02a9e\":59,\"02a9f\":59,\"02aa0\":59,\"02aa1\":59,\"02aa2\":59,\"02aa3\":59,\"02aa4\":59,\"02aa5\":59,\"02aa6\":59,\"02aa7\":59,\"02aa8\":59,\"02aa9\":59,\"02aaa\":59,\"02aab\":59,\"02aac\":59,\"02aad\":59,\"02aae\":59,\"02aaf\":59,\"02ab0\":59,\"02ab1\":59,\"02ab2\":59,\"02ab3\":59,\"02ab4\":59,\"02ab5\":59,\"02ab6\":59,\"02ab7\":59,\"02ab8\":59,\"02ab9\":59,\"02aba\":59,\"02abb\":59,\"02abc\":59,\"02abd\":59,\"02abe\":59,\"02abf\":59,\"02ac0\":59,\"02ac1\":59,\"02ac2\":59,\"02ac3\":59,\"02ac4\":59,\"02ac5\":59,\"02ac6\":59,\"02ac7\":59,\"02ac8\":59,\"02ac9\":59,\"02aca\":59,\"02acb\":59,\"02acc\":59,\"02acd\":59,\"02ace\":59,\"02acf\":59,\"02ad0\":59,\"02ad1\":59,\"02ad2\":59,\"02ad3\":59,\"02ad4\":59,\"02ad5\":59,\"02ad6\":59,\"02ad7\":59,\"02ad8\":59,\"02ad9\":59,\"02adb\":59,\"02adc\":59,\"02add\":59,\"02ae3\":59,\"02ae4\":59,\"02af4\":59,\"02af6\":59,\"02af7\":59,\"02af8\":59,\"02af9\":59,\"02afa\":59,\"02b05\":59,\"02b06\":59,\"02b07\":59,\"02b12\":59,\"02b13\":59,\"02b14\":59,\"02b15\":59,\"02b16\":59,\"02b17\":59,\"02b18\":59,\"02b19\":59,\"02b1a\":59,\"02b1b\":59,\"02b1c\":59,\"02b1d\":59,\"02b1e\":59,\"02b1f\":59,\"02b20\":59,\"02b21\":59,\"02b22\":59,\"02b23\":59,\"02b24\":59,\"02b25\":59,\"02b26\":59,\"02b27\":59,\"02b28\":59,\"02b29\":59,\"02b2a\":59,\"02b2b\":59,\"02b2c\":59,\"02b2d\":59,\"02b2e\":59,\"02b2f\":59,\"02b30\":59,\"02b31\":59,\"02b32\":59,\"02b33\":59,\"02b34\":59,\"02b35\":59,\"02b36\":59,\"02b37\":59,\"02b38\":59,\"02b39\":59,\"02b3a\":59,\"02b3b\":59,\"02b3c\":59,\"02b3d\":59,\"02b3e\":59,\"02b3f\":59,\"02b40\":59,\"02b41\":59,\"02b42\":59,\"02b43\":59,\"02b44\":59,\"02b45\":59,\"02b46\":59,\"02b47\":59,\"02b48\":59,\"02b49\":59,\"02b4a\":59,\"02b4b\":59,\"02b4c\":59,\"02b50\":59,\"02b51\":59,\"02b52\":59,\"02b53\":59,\"02b54\":59,\"02b55\":59,\"02c7c\":59,\"02c7d\":59,\"0303d\":59,\"03t00\":31,\"0518977991518im\":27,\"06t00\":68,\"07t00\":[31,68],\"08708053414102428im\":27,\"0b10\":39,\"0b1011_0010\":39,\"0e10\":39,\"0f0\":[39,49,52],\"0fe00\":59,\"0im\":[27,29,30,34,58,74],\"0mq\":51,\"0o10\":39,\"0o777\":69,\"0x0\":49,\"0x00\":[48,49],\"0x000\":49,\"0x0000\":49,\"0x0000000000000000\":64,\"0x0000000000000008\":64,\"0x0000000000000010\":64,\"0x0000000000000018\":64,\"0x0000000000000020\":64,\"0x0000000000000028\":64,\"0x0000000000000030\":64,\"0x0000000000000038\":64,\"0x0000000000000040\":64,\"0x0000000000000048\":64,\"0x0000000000000050\":64,\"0x0000000000000058\":64,\"0x00000001009e9620\":55,\"0x00000001009e9635\":55,\"0x00000001009f64e7\":55,\"0x00000001009fc7b6\":55,\"0x00000001009fdae3\":55,\"0x00000001009fe0d2\":55,\"0x00000001009fe1e8\":55,\"0x0000000100a06418\":55,\"0x0000000100a1321b\":55,\"0x0000000100a26fc2\":55,\"0x000000010265ac5d\":55,\"0x000000010265acc1\":55,\"0x00000001029435df\":55,\"0x0000000102943635\":55,\"0x000000031006feec\":55,\"0x00000003100701b0\":55,\"0x000000031007744b\":55,\"0x0000000310077537\":55,\"0x00007f418d0816b8\":26,\"0x00007f5998a04370\":21,\"0x00007f5998a570d0\":21,\"0x00007fcc7de64850\":21,\"0x00007fcc80c4d930\":21,\"0x00007fd31dc11870\":48,\"0x00007fd31dc11ae0\":48,\"0x00007fd31dc12e60\":48,\"0x00007ffde56bd01a\":6,\"0x00007fff5fbffc45\":26,\"0x00007ffff6541154\":6,\"0x00007ffff65412fe\":6,\"0x00007ffff7928bf7\":6,\"0x000f\":49,\"0x01\":[39,44],\"0x01020304\":71,\"0x0123\":39,\"0x01234567\":39,\"0x0123456789abcdef\":39,\"0x02\":39,\"0x04030201\":71,\"0x08\":39,\"0x0c\":30,\"0x1\":39,\"0x10265acc1\":55,\"0x102943635\":55,\"0x110000\":56,\"0x123\":39,\"0x1234567\":39,\"0x123456789abcdef\":39,\"0x1289d070\":6,\"0x1p0\":39,\"0x2812060\":6,\"0x3100701b0\":55,\"0x310077537\":55,\"0x41\":56,\"0x44\":56,\"0x54\":56,\"0x61\":48,\"0x62\":48,\"0x63\":48,\"0x64\":48,\"0x7ffde56be000\":6,\"0x7ffdf35e8010\":21,\"0x7ffdf367f630\":6,\"0x7ffdf39b1030\":6,\"0x7ffdf42de400\":6,\"0x7ffdf7409150\":21,\"0x7ffdf74091b0\":21,\"0x7ffdf74d7a90\":21,\"0x7ffdf74d7af0\":21,\"0x7ffff6dcb07d\":21,\"0x7fffffffc2b0\":6,\"0x7fffffffcc70\":21,\"0x7fffffffcc90\":21,\"0x80\":56,\"0x84\":44,\"0x88\":56,\"0xb2\":39,\"0xbf\":56,\"0xc3\":56,\"0xdead_beef\":39,\"0xdeadbeef\":39,\"0xe2\":56,\"0xf\":49,\"0xf0\":49,\"0xff\":[39,56],\"0xfff0\":49,\"0xffffff84\":44,\"0xfffffffffffffffff\":1,\"1000x\":6,\"10_000\":39,\"10ffff\":56,\"1368683772161603e\":39,\"13ghz\":2,\"13t00\":[31,68],\"15im\":27,\"15t00\":68,\"17t08\":31,\"17t12\":31,\"18425e\":63,\"1920929f\":39,\"1995y01m\":68,\"1996y01m\":68,\"1d400\":59,\"1d401\":59,\"1d402\":59,\"1d403\":59,\"1d404\":59,\"1d405\":59,\"1d406\":59,\"1d407\":59,\"1d408\":59,\"1d409\":59,\"1d40a\":59,\"1d40b\":59,\"1d40c\":59,\"1d40d\":59,\"1d40e\":59,\"1d40f\":59,\"1d410\":59,\"1d411\":59,\"1d412\":59,\"1d413\":59,\"1d414\":59,\"1d415\":59,\"1d416\":59,\"1d417\":59,\"1d418\":59,\"1d419\":59,\"1d41a\":59,\"1d41b\":59,\"1d41c\":59,\"1d41d\":59,\"1d41e\":59,\"1d41f\":59,\"1d420\":59,\"1d421\":59,\"1d422\":59,\"1d423\":59,\"1d424\":59,\"1d425\":59,\"1d426\":59,\"1d427\":59,\"1d428\":59,\"1d429\":59,\"1d42a\":59,\"1d42b\":59,\"1d42c\":59,\"1d42d\":59,\"1d42e\":59,\"1d42f\":59,\"1d430\":59,\"1d431\":59,\"1d432\":59,\"1d433\":59,\"1d434\":59,\"1d435\":59,\"1d436\":59,\"1d437\":59,\"1d438\":59,\"1d439\":59,\"1d43a\":59,\"1d43b\":59,\"1d43c\":59,\"1d43d\":59,\"1d43e\":59,\"1d43f\":59,\"1d440\":59,\"1d441\":59,\"1d442\":59,\"1d443\":59,\"1d444\":59,\"1d445\":59,\"1d446\":59,\"1d447\":59,\"1d448\":59,\"1d449\":59,\"1d44a\":59,\"1d44b\":59,\"1d44c\":59,\"1d44d\":59,\"1d44e\":59,\"1d44f\":59,\"1d450\":59,\"1d451\":59,\"1d452\":59,\"1d453\":59,\"1d454\":59,\"1d456\":59,\"1d457\":59,\"1d458\":59,\"1d459\":59,\"1d45a\":59,\"1d45b\":59,\"1d45c\":59,\"1d45d\":59,\"1d45e\":59,\"1d45f\":59,\"1d460\":59,\"1d461\":59,\"1d462\":59,\"1d463\":59,\"1d464\":59,\"1d465\":59,\"1d466\":59,\"1d467\":59,\"1d468\":59,\"1d469\":59,\"1d46a\":59,\"1d46b\":59,\"1d46c\":59,\"1d46d\":59,\"1d46e\":59,\"1d46f\":59,\"1d470\":59,\"1d471\":59,\"1d472\":59,\"1d473\":59,\"1d474\":59,\"1d475\":59,\"1d476\":59,\"1d477\":59,\"1d478\":59,\"1d479\":59,\"1d47a\":59,\"1d47b\":59,\"1d47c\":59,\"1d47d\":59,\"1d47e\":59,\"1d47f\":59,\"1d480\":59,\"1d481\":59,\"1d482\":59,\"1d483\":59,\"1d484\":59,\"1d485\":59,\"1d486\":59,\"1d487\":59,\"1d488\":59,\"1d489\":59,\"1d48a\":59,\"1d48b\":59,\"1d48c\":59,\"1d48d\":59,\"1d48e\":59,\"1d48f\":59,\"1d490\":59,\"1d491\":59,\"1d492\":59,\"1d493\":59,\"1d494\":59,\"1d495\":59,\"1d496\":59,\"1d497\":59,\"1d498\":59,\"1d499\":59,\"1d49a\":59,\"1d49b\":59,\"1d49c\":59,\"1d49e\":59,\"1d49f\":59,\"1d4a2\":59,\"1d4a5\":59,\"1d4a6\":59,\"1d4a9\":59,\"1d4aa\":59,\"1d4ab\":59,\"1d4ac\":59,\"1d4ae\":59,\"1d4af\":59,\"1d4b0\":59,\"1d4b1\":59,\"1d4b2\":59,\"1d4b3\":59,\"1d4b4\":59,\"1d4b5\":59,\"1d4b6\":59,\"1d4b7\":59,\"1d4b8\":59,\"1d4b9\":59,\"1d4bb\":59,\"1d4bd\":59,\"1d4be\":59,\"1d4bf\":59,\"1d4c0\":59,\"1d4c1\":59,\"1d4c2\":59,\"1d4c3\":59,\"1d4c5\":59,\"1d4c6\":59,\"1d4c7\":59,\"1d4c8\":59,\"1d4c9\":59,\"1d4ca\":59,\"1d4cb\":59,\"1d4cc\":59,\"1d4cd\":59,\"1d4ce\":59,\"1d4cf\":59,\"1d4d0\":59,\"1d4d1\":59,\"1d4d2\":59,\"1d4d3\":59,\"1d4d4\":59,\"1d4d5\":59,\"1d4d6\":59,\"1d4d7\":59,\"1d4d8\":59,\"1d4d9\":59,\"1d4da\":59,\"1d4db\":59,\"1d4dc\":59,\"1d4dd\":59,\"1d4de\":59,\"1d4df\":59,\"1d4e0\":59,\"1d4e1\":59,\"1d4e2\":59,\"1d4e3\":59,\"1d4e4\":59,\"1d4e5\":59,\"1d4e6\":59,\"1d4e7\":59,\"1d4e8\":59,\"1d4e9\":59,\"1d4ea\":59,\"1d4eb\":59,\"1d4ec\":59,\"1d4ed\":59,\"1d4ee\":59,\"1d4ef\":59,\"1d4f0\":59,\"1d4f1\":59,\"1d4f2\":59,\"1d4f3\":59,\"1d4f4\":59,\"1d4f5\":59,\"1d4f6\":59,\"1d4f7\":59,\"1d4f8\":59,\"1d4f9\":59,\"1d4fa\":59,\"1d4fb\":59,\"1d4fc\":59,\"1d4fd\":59,\"1d4fe\":59,\"1d4ff\":59,\"1d500\":59,\"1d501\":59,\"1d502\":59,\"1d503\":59,\"1d504\":59,\"1d505\":59,\"1d507\":59,\"1d508\":59,\"1d509\":59,\"1d50a\":59,\"1d50d\":59,\"1d50e\":59,\"1d50f\":59,\"1d510\":59,\"1d511\":59,\"1d512\":59,\"1d513\":59,\"1d514\":59,\"1d516\":59,\"1d517\":59,\"1d518\":59,\"1d519\":59,\"1d51a\":59,\"1d51b\":59,\"1d51c\":59,\"1d51e\":59,\"1d51f\":59,\"1d520\":59,\"1d521\":59,\"1d522\":59,\"1d523\":59,\"1d524\":59,\"1d525\":59,\"1d526\":59,\"1d527\":59,\"1d528\":59,\"1d529\":59,\"1d52a\":59,\"1d52b\":59,\"1d52c\":59,\"1d52d\":59,\"1d52e\":59,\"1d52f\":59,\"1d530\":59,\"1d531\":59,\"1d532\":59,\"1d533\":59,\"1d534\":59,\"1d535\":59,\"1d536\":59,\"1d537\":59,\"1d538\":59,\"1d539\":59,\"1d53b\":59,\"1d53c\":59,\"1d53d\":59,\"1d53e\":59,\"1d540\":59,\"1d541\":59,\"1d542\":59,\"1d543\":59,\"1d544\":59,\"1d546\":59,\"1d54a\":59,\"1d54b\":59,\"1d54c\":59,\"1d54d\":59,\"1d54e\":59,\"1d54f\":59,\"1d550\":59,\"1d552\":59,\"1d553\":59,\"1d554\":59,\"1d555\":59,\"1d556\":59,\"1d557\":59,\"1d558\":59,\"1d559\":59,\"1d55a\":59,\"1d55b\":59,\"1d55c\":59,\"1d55d\":59,\"1d55e\":59,\"1d55f\":59,\"1d560\":59,\"1d561\":59,\"1d562\":59,\"1d563\":59,\"1d564\":59,\"1d565\":59,\"1d566\":59,\"1d567\":59,\"1d568\":59,\"1d569\":59,\"1d56a\":59,\"1d56b\":59,\"1d56c\":59,\"1d56d\":59,\"1d56e\":59,\"1d56f\":59,\"1d570\":59,\"1d571\":59,\"1d572\":59,\"1d573\":59,\"1d574\":59,\"1d575\":59,\"1d576\":59,\"1d577\":59,\"1d578\":59,\"1d579\":59,\"1d57a\":59,\"1d57b\":59,\"1d57c\":59,\"1d57d\":59,\"1d57e\":59,\"1d57f\":59,\"1d580\":59,\"1d581\":59,\"1d582\":59,\"1d583\":59,\"1d584\":59,\"1d585\":59,\"1d586\":59,\"1d587\":59,\"1d588\":59,\"1d589\":59,\"1d58a\":59,\"1d58b\":59,\"1d58c\":59,\"1d58d\":59,\"1d58e\":59,\"1d58f\":59,\"1d590\":59,\"1d591\":59,\"1d592\":59,\"1d593\":59,\"1d594\":59,\"1d595\":59,\"1d596\":59,\"1d597\":59,\"1d598\":59,\"1d599\":59,\"1d59a\":59,\"1d59b\":59,\"1d59c\":59,\"1d59d\":59,\"1d59e\":59,\"1d59f\":59,\"1d5a0\":59,\"1d5a1\":59,\"1d5a2\":59,\"1d5a3\":59,\"1d5a4\":59,\"1d5a5\":59,\"1d5a6\":59,\"1d5a7\":59,\"1d5a8\":59,\"1d5a9\":59,\"1d5aa\":59,\"1d5ab\":59,\"1d5ac\":59,\"1d5ad\":59,\"1d5ae\":59,\"1d5af\":59,\"1d5b0\":59,\"1d5b1\":59,\"1d5b2\":59,\"1d5b3\":59,\"1d5b4\":59,\"1d5b5\":59,\"1d5b6\":59,\"1d5b7\":59,\"1d5b8\":59,\"1d5b9\":59,\"1d5ba\":59,\"1d5bb\":59,\"1d5bc\":59,\"1d5bd\":59,\"1d5be\":59,\"1d5bf\":59,\"1d5c0\":59,\"1d5c1\":59,\"1d5c2\":59,\"1d5c3\":59,\"1d5c4\":59,\"1d5c5\":59,\"1d5c6\":59,\"1d5c7\":59,\"1d5c8\":59,\"1d5c9\":59,\"1d5ca\":59,\"1d5cb\":59,\"1d5cc\":59,\"1d5cd\":59,\"1d5ce\":59,\"1d5cf\":59,\"1d5d0\":59,\"1d5d1\":59,\"1d5d2\":59,\"1d5d3\":59,\"1d5d4\":59,\"1d5d5\":59,\"1d5d6\":59,\"1d5d7\":59,\"1d5d8\":59,\"1d5d9\":59,\"1d5da\":59,\"1d5db\":59,\"1d5dc\":59,\"1d5dd\":59,\"1d5de\":59,\"1d5df\":59,\"1d5e0\":59,\"1d5e1\":59,\"1d5e2\":59,\"1d5e3\":59,\"1d5e4\":59,\"1d5e5\":59,\"1d5e6\":59,\"1d5e7\":59,\"1d5e8\":59,\"1d5e9\":59,\"1d5ea\":59,\"1d5eb\":59,\"1d5ec\":59,\"1d5ed\":59,\"1d5ee\":59,\"1d5ef\":59,\"1d5f0\":59,\"1d5f1\":59,\"1d5f2\":59,\"1d5f3\":59,\"1d5f4\":59,\"1d5f5\":59,\"1d5f6\":59,\"1d5f7\":59,\"1d5f8\":59,\"1d5f9\":59,\"1d5fa\":59,\"1d5fb\":59,\"1d5fc\":59,\"1d5fd\":59,\"1d5fe\":59,\"1d5ff\":59,\"1d600\":59,\"1d601\":59,\"1d602\":59,\"1d603\":59,\"1d604\":59,\"1d605\":59,\"1d606\":59,\"1d607\":59,\"1d608\":59,\"1d609\":59,\"1d60a\":59,\"1d60b\":59,\"1d60c\":59,\"1d60d\":59,\"1d60e\":59,\"1d60f\":59,\"1d610\":59,\"1d611\":59,\"1d612\":59,\"1d613\":59,\"1d614\":59,\"1d615\":59,\"1d616\":59,\"1d617\":59,\"1d618\":59,\"1d619\":59,\"1d61a\":59,\"1d61b\":59,\"1d61c\":59,\"1d61d\":59,\"1d61e\":59,\"1d61f\":59,\"1d620\":59,\"1d621\":59,\"1d622\":59,\"1d623\":59,\"1d624\":59,\"1d625\":59,\"1d626\":59,\"1d627\":59,\"1d628\":59,\"1d629\":59,\"1d62a\":59,\"1d62b\":59,\"1d62c\":59,\"1d62d\":59,\"1d62e\":59,\"1d62f\":59,\"1d630\":59,\"1d631\":59,\"1d632\":59,\"1d633\":59,\"1d634\":59,\"1d635\":59,\"1d636\":59,\"1d637\":59,\"1d638\":59,\"1d639\":59,\"1d63a\":59,\"1d63b\":59,\"1d63c\":59,\"1d63d\":59,\"1d63e\":59,\"1d63f\":59,\"1d640\":59,\"1d641\":59,\"1d642\":59,\"1d643\":59,\"1d644\":59,\"1d645\":59,\"1d646\":59,\"1d647\":59,\"1d648\":59,\"1d649\":59,\"1d64a\":59,\"1d64b\":59,\"1d64c\":59,\"1d64d\":59,\"1d64e\":59,\"1d64f\":59,\"1d650\":59,\"1d651\":59,\"1d652\":59,\"1d653\":59,\"1d654\":59,\"1d655\":59,\"1d656\":59,\"1d657\":59,\"1d658\":59,\"1d659\":59,\"1d65a\":59,\"1d65b\":59,\"1d65c\":59,\"1d65d\":59,\"1d65e\":59,\"1d65f\":59,\"1d660\":59,\"1d661\":59,\"1d662\":59,\"1d663\":59,\"1d664\":59,\"1d665\":59,\"1d666\":59,\"1d667\":59,\"1d668\":59,\"1d669\":59,\"1d66a\":59,\"1d66b\":59,\"1d66c\":59,\"1d66d\":59,\"1d66e\":59,\"1d66f\":59,\"1d670\":59,\"1d671\":59,\"1d672\":59,\"1d673\":59,\"1d674\":59,\"1d675\":59,\"1d676\":59,\"1d677\":59,\"1d678\":59,\"1d679\":59,\"1d67a\":59,\"1d67b\":59,\"1d67c\":59,\"1d67d\":59,\"1d67e\":59,\"1d67f\":59,\"1d680\":59,\"1d681\":59,\"1d682\":59,\"1d683\":59,\"1d684\":59,\"1d685\":59,\"1d686\":59,\"1d687\":59,\"1d688\":59,\"1d689\":59,\"1d68a\":59,\"1d68b\":59,\"1d68c\":59,\"1d68d\":59,\"1d68e\":59,\"1d68f\":59,\"1d690\":59,\"1d691\":59,\"1d692\":59,\"1d693\":59,\"1d694\":59,\"1d695\":59,\"1d696\":59,\"1d697\":59,\"1d698\":59,\"1d699\":59,\"1d69a\":59,\"1d69b\":59,\"1d69c\":59,\"1d69d\":59,\"1d69e\":59,\"1d69f\":59,\"1d6a0\":59,\"1d6a1\":59,\"1d6a2\":59,\"1d6a3\":59,\"1d6a4\":59,\"1d6a5\":59,\"1d6a8\":59,\"1d6a9\":59,\"1d6aa\":59,\"1d6ab\":59,\"1d6ac\":59,\"1d6ad\":59,\"1d6ae\":59,\"1d6af\":59,\"1d6b0\":59,\"1d6b1\":59,\"1d6b2\":59,\"1d6b3\":59,\"1d6b4\":59,\"1d6b5\":59,\"1d6b6\":59,\"1d6b7\":59,\"1d6b8\":59,\"1d6b9\":59,\"1d6ba\":59,\"1d6bb\":59,\"1d6bc\":59,\"1d6bd\":59,\"1d6be\":59,\"1d6bf\":59,\"1d6c0\":59,\"1d6c1\":59,\"1d6c2\":59,\"1d6c3\":59,\"1d6c4\":59,\"1d6c5\":59,\"1d6c6\":59,\"1d6c7\":59,\"1d6c8\":59,\"1d6c9\":59,\"1d6ca\":59,\"1d6cb\":59,\"1d6cc\":59,\"1d6cd\":59,\"1d6ce\":59,\"1d6cf\":59,\"1d6d0\":59,\"1d6d1\":59,\"1d6d2\":59,\"1d6d3\":59,\"1d6d4\":59,\"1d6d5\":59,\"1d6d6\":59,\"1d6d7\":59,\"1d6d8\":59,\"1d6d9\":59,\"1d6da\":59,\"1d6db\":59,\"1d6dc\":59,\"1d6dd\":59,\"1d6de\":59,\"1d6df\":59,\"1d6e0\":59,\"1d6e1\":59,\"1d6e2\":59,\"1d6e3\":59,\"1d6e4\":59,\"1d6e5\":59,\"1d6e6\":59,\"1d6e7\":59,\"1d6e8\":59,\"1d6e9\":59,\"1d6ea\":59,\"1d6eb\":59,\"1d6ec\":59,\"1d6ed\":59,\"1d6ee\":59,\"1d6ef\":59,\"1d6f0\":59,\"1d6f1\":59,\"1d6f2\":59,\"1d6f3\":59,\"1d6f4\":59,\"1d6f5\":59,\"1d6f6\":59,\"1d6f7\":59,\"1d6f8\":59,\"1d6f9\":59,\"1d6fa\":59,\"1d6fb\":59,\"1d6fc\":59,\"1d6fd\":59,\"1d6fe\":59,\"1d6ff\":59,\"1d700\":59,\"1d701\":59,\"1d702\":59,\"1d703\":59,\"1d704\":59,\"1d705\":59,\"1d706\":59,\"1d707\":59,\"1d708\":59,\"1d709\":59,\"1d70a\":59,\"1d70b\":59,\"1d70c\":59,\"1d70d\":59,\"1d70e\":59,\"1d70f\":59,\"1d710\":59,\"1d711\":59,\"1d712\":59,\"1d713\":59,\"1d714\":59,\"1d715\":59,\"1d716\":59,\"1d717\":59,\"1d718\":59,\"1d719\":59,\"1d71a\":59,\"1d71b\":59,\"1d71c\":59,\"1d71d\":59,\"1d71e\":59,\"1d71f\":59,\"1d720\":59,\"1d721\":59,\"1d722\":59,\"1d723\":59,\"1d724\":59,\"1d725\":59,\"1d726\":59,\"1d727\":59,\"1d728\":59,\"1d729\":59,\"1d72a\":59,\"1d72b\":59,\"1d72c\":59,\"1d72d\":59,\"1d72e\":59,\"1d72f\":59,\"1d730\":59,\"1d731\":59,\"1d732\":59,\"1d733\":59,\"1d734\":59,\"1d735\":59,\"1d736\":59,\"1d737\":59,\"1d738\":59,\"1d739\":59,\"1d73a\":59,\"1d73b\":59,\"1d73c\":59,\"1d73d\":59,\"1d73e\":59,\"1d73f\":59,\"1d740\":59,\"1d741\":59,\"1d742\":59,\"1d743\":59,\"1d744\":59,\"1d745\":59,\"1d746\":59,\"1d747\":59,\"1d748\":59,\"1d749\":59,\"1d74a\":59,\"1d74b\":59,\"1d74c\":59,\"1d74d\":59,\"1d74e\":59,\"1d74f\":59,\"1d750\":59,\"1d751\":59,\"1d752\":59,\"1d753\":59,\"1d754\":59,\"1d755\":59,\"1d756\":59,\"1d757\":59,\"1d758\":59,\"1d759\":59,\"1d75a\":59,\"1d75b\":59,\"1d75c\":59,\"1d75d\":59,\"1d75e\":59,\"1d75f\":59,\"1d760\":59,\"1d761\":59,\"1d762\":59,\"1d763\":59,\"1d764\":59,\"1d765\":59,\"1d766\":59,\"1d767\":59,\"1d768\":59,\"1d769\":59,\"1d76a\":59,\"1d76b\":59,\"1d76c\":59,\"1d76d\":59,\"1d76e\":59,\"1d76f\":59,\"1d770\":59,\"1d771\":59,\"1d772\":59,\"1d773\":59,\"1d774\":59,\"1d775\":59,\"1d776\":59,\"1d777\":59,\"1d778\":59,\"1d779\":59,\"1d77a\":59,\"1d77b\":59,\"1d77c\":59,\"1d77d\":59,\"1d77e\":59,\"1d77f\":59,\"1d780\":59,\"1d781\":59,\"1d782\":59,\"1d783\":59,\"1d784\":59,\"1d785\":59,\"1d786\":59,\"1d787\":59,\"1d788\":59,\"1d789\":59,\"1d78a\":59,\"1d78b\":59,\"1d78c\":59,\"1d78d\":59,\"1d78e\":59,\"1d78f\":59,\"1d790\":59,\"1d791\":59,\"1d792\":59,\"1d793\":59,\"1d794\":59,\"1d795\":59,\"1d796\":59,\"1d797\":59,\"1d798\":59,\"1d799\":59,\"1d79a\":59,\"1d79b\":59,\"1d79c\":59,\"1d79d\":59,\"1d79e\":59,\"1d79f\":59,\"1d7a0\":59,\"1d7a1\":59,\"1d7a2\":59,\"1d7a3\":59,\"1d7a4\":59,\"1d7a5\":59,\"1d7a6\":59,\"1d7a7\":59,\"1d7a8\":59,\"1d7a9\":59,\"1d7aa\":59,\"1d7ab\":59,\"1d7ac\":59,\"1d7ad\":59,\"1d7ae\":59,\"1d7af\":59,\"1d7b0\":59,\"1d7b1\":59,\"1d7b2\":59,\"1d7b3\":59,\"1d7b4\":59,\"1d7b5\":59,\"1d7b6\":59,\"1d7b7\":59,\"1d7b8\":59,\"1d7b9\":59,\"1d7ba\":59,\"1d7bb\":59,\"1d7bc\":59,\"1d7bd\":59,\"1d7be\":59,\"1d7bf\":59,\"1d7c0\":59,\"1d7c1\":59,\"1d7c2\":59,\"1d7c3\":59,\"1d7c4\":59,\"1d7c5\":59,\"1d7c6\":59,\"1d7c7\":59,\"1d7c8\":59,\"1d7c9\":59,\"1d7ca\":59,\"1d7cb\":59,\"1d7ce\":59,\"1d7cf\":59,\"1d7d0\":59,\"1d7d1\":59,\"1d7d2\":59,\"1d7d3\":59,\"1d7d4\":59,\"1d7d5\":59,\"1d7d6\":59,\"1d7d7\":59,\"1d7d8\":59,\"1d7d9\":59,\"1d7da\":59,\"1d7db\":59,\"1d7dc\":59,\"1d7dd\":59,\"1d7de\":59,\"1d7df\":59,\"1d7e0\":59,\"1d7e1\":59,\"1d7e2\":59,\"1d7e3\":59,\"1d7e4\":59,\"1d7e5\":59,\"1d7e6\":59,\"1d7e7\":59,\"1d7e8\":59,\"1d7e9\":59,\"1d7ea\":59,\"1d7eb\":59,\"1d7ec\":59,\"1d7ed\":59,\"1d7ee\":59,\"1d7ef\":59,\"1d7f0\":59,\"1d7f1\":59,\"1d7f2\":59,\"1d7f3\":59,\"1d7f4\":59,\"1d7f5\":59,\"1d7f6\":59,\"1d7f7\":59,\"1d7f8\":59,\"1d7f9\":59,\"1d7fa\":59,\"1d7fb\":59,\"1d7fc\":59,\"1d7fd\":59,\"1d7fe\":59,\"1d7ff\":59,\"1e10\":39,\"1f004\":59,\"1f0cf\":59,\"1f170\":59,\"1f171\":59,\"1f17e\":59,\"1f17f\":59,\"1f18e\":59,\"1f191\":59,\"1f192\":59,\"1f193\":59,\"1f194\":59,\"1f195\":59,\"1f196\":59,\"1f197\":59,\"1f198\":59,\"1f199\":59,\"1f19a\":59,\"1f201\":59,\"1f202\":59,\"1f21a\":59,\"1f22f\":59,\"1f232\":59,\"1f233\":59,\"1f234\":59,\"1f235\":59,\"1f236\":59,\"1f237\":59,\"1f238\":59,\"1f239\":59,\"1f23a\":59,\"1f250\":59,\"1f251\":59,\"1f300\":59,\"1f301\":59,\"1f302\":59,\"1f303\":59,\"1f304\":59,\"1f305\":59,\"1f306\":59,\"1f307\":59,\"1f308\":59,\"1f309\":59,\"1f30a\":59,\"1f30b\":59,\"1f30c\":59,\"1f30d\":59,\"1f30e\":59,\"1f30f\":59,\"1f310\":59,\"1f311\":59,\"1f312\":59,\"1f313\":59,\"1f314\":59,\"1f315\":59,\"1f316\":59,\"1f317\":59,\"1f318\":59,\"1f319\":59,\"1f31a\":59,\"1f31b\":59,\"1f31c\":59,\"1f31d\":59,\"1f31e\":59,\"1f31f\":59,\"1f320\":59,\"1f330\":59,\"1f331\":59,\"1f332\":59,\"1f333\":59,\"1f334\":59,\"1f335\":59,\"1f337\":59,\"1f338\":59,\"1f339\":59,\"1f33a\":59,\"1f33b\":59,\"1f33c\":59,\"1f33d\":59,\"1f33e\":59,\"1f33f\":59,\"1f340\":59,\"1f341\":59,\"1f342\":59,\"1f343\":59,\"1f344\":59,\"1f345\":59,\"1f346\":59,\"1f347\":59,\"1f348\":59,\"1f349\":59,\"1f34a\":59,\"1f34b\":59,\"1f34c\":59,\"1f34d\":59,\"1f34e\":59,\"1f34f\":59,\"1f350\":59,\"1f351\":59,\"1f352\":59,\"1f353\":59,\"1f354\":59,\"1f355\":59,\"1f356\":59,\"1f357\":59,\"1f358\":59,\"1f359\":59,\"1f35a\":59,\"1f35b\":59,\"1f35c\":59,\"1f35d\":59,\"1f35e\":59,\"1f35f\":59,\"1f360\":59,\"1f361\":59,\"1f362\":59,\"1f363\":59,\"1f364\":59,\"1f365\":59,\"1f366\":59,\"1f367\":59,\"1f368\":59,\"1f369\":59,\"1f36a\":59,\"1f36b\":59,\"1f36c\":59,\"1f36d\":59,\"1f36e\":59,\"1f36f\":59,\"1f370\":59,\"1f371\":59,\"1f372\":59,\"1f373\":59,\"1f374\":59,\"1f375\":59,\"1f376\":59,\"1f377\":59,\"1f378\":59,\"1f379\":59,\"1f37a\":59,\"1f37b\":59,\"1f37c\":59,\"1f380\":59,\"1f381\":59,\"1f382\":59,\"1f383\":59,\"1f384\":59,\"1f385\":59,\"1f386\":59,\"1f387\":59,\"1f388\":59,\"1f389\":59,\"1f38a\":59,\"1f38b\":59,\"1f38c\":59,\"1f38d\":59,\"1f38e\":59,\"1f38f\":59,\"1f390\":59,\"1f391\":59,\"1f392\":59,\"1f393\":59,\"1f3a0\":59,\"1f3a1\":59,\"1f3a2\":59,\"1f3a3\":59,\"1f3a4\":59,\"1f3a5\":59,\"1f3a6\":59,\"1f3a7\":59,\"1f3a8\":59,\"1f3a9\":59,\"1f3aa\":59,\"1f3ab\":59,\"1f3ac\":59,\"1f3ad\":59,\"1f3ae\":59,\"1f3af\":59,\"1f3b0\":59,\"1f3b1\":59,\"1f3b2\":59,\"1f3b3\":59,\"1f3b4\":59,\"1f3b5\":59,\"1f3b6\":59,\"1f3b7\":59,\"1f3b8\":59,\"1f3b9\":59,\"1f3ba\":59,\"1f3bb\":59,\"1f3bc\":59,\"1f3bd\":59,\"1f3be\":59,\"1f3bf\":59,\"1f3c0\":59,\"1f3c1\":59,\"1f3c2\":59,\"1f3c3\":59,\"1f3c4\":59,\"1f3c6\":59,\"1f3c7\":59,\"1f3c8\":59,\"1f3c9\":59,\"1f3ca\":59,\"1f3e0\":59,\"1f3e1\":59,\"1f3e2\":59,\"1f3e3\":59,\"1f3e4\":59,\"1f3e5\":59,\"1f3e6\":59,\"1f3e7\":59,\"1f3e8\":59,\"1f3e9\":59,\"1f3ea\":59,\"1f3eb\":59,\"1f3ec\":59,\"1f3ed\":59,\"1f3ee\":59,\"1f3ef\":59,\"1f3f0\":59,\"1f3fb\":59,\"1f3fc\":59,\"1f3fd\":59,\"1f3fe\":59,\"1f3ff\":59,\"1f400\":59,\"1f401\":59,\"1f402\":59,\"1f403\":59,\"1f404\":59,\"1f405\":59,\"1f406\":59,\"1f407\":59,\"1f408\":59,\"1f409\":59,\"1f40a\":59,\"1f40b\":59,\"1f40c\":59,\"1f40d\":59,\"1f40e\":59,\"1f40f\":59,\"1f410\":59,\"1f411\":59,\"1f412\":59,\"1f413\":59,\"1f414\":59,\"1f415\":59,\"1f416\":59,\"1f417\":59,\"1f418\":59,\"1f419\":59,\"1f41a\":59,\"1f41b\":59,\"1f41c\":59,\"1f41d\":59,\"1f41e\":59,\"1f41f\":59,\"1f420\":59,\"1f421\":59,\"1f422\":59,\"1f423\":59,\"1f424\":59,\"1f425\":59,\"1f426\":59,\"1f427\":59,\"1f428\":59,\"1f429\":59,\"1f42a\":59,\"1f42b\":59,\"1f42c\":59,\"1f42d\":59,\"1f42e\":59,\"1f42f\":59,\"1f430\":59,\"1f431\":59,\"1f432\":59,\"1f433\":59,\"1f434\":59,\"1f435\":59,\"1f436\":59,\"1f437\":59,\"1f438\":59,\"1f439\":59,\"1f43a\":59,\"1f43b\":59,\"1f43c\":59,\"1f43d\":59,\"1f43e\":59,\"1f440\":59,\"1f442\":59,\"1f443\":59,\"1f444\":59,\"1f445\":59,\"1f446\":59,\"1f447\":59,\"1f448\":59,\"1f449\":59,\"1f44a\":59,\"1f44b\":59,\"1f44c\":59,\"1f44d\":59,\"1f44e\":59,\"1f44f\":59,\"1f450\":59,\"1f451\":59,\"1f452\":59,\"1f453\":59,\"1f454\":59,\"1f455\":59,\"1f456\":59,\"1f457\":59,\"1f458\":59,\"1f459\":59,\"1f45a\":59,\"1f45b\":59,\"1f45c\":59,\"1f45d\":59,\"1f45e\":59,\"1f45f\":59,\"1f460\":59,\"1f461\":59,\"1f462\":59,\"1f463\":59,\"1f464\":59,\"1f465\":59,\"1f466\":59,\"1f467\":59,\"1f468\":59,\"1f469\":59,\"1f46a\":59,\"1f46b\":59,\"1f46c\":59,\"1f46d\":59,\"1f46e\":59,\"1f46f\":59,\"1f470\":59,\"1f471\":59,\"1f472\":59,\"1f473\":59,\"1f474\":59,\"1f475\":59,\"1f476\":59,\"1f477\":59,\"1f478\":59,\"1f479\":59,\"1f47a\":59,\"1f47b\":59,\"1f47c\":59,\"1f47d\":59,\"1f47e\":59,\"1f47f\":59,\"1f480\":59,\"1f481\":59,\"1f482\":59,\"1f483\":59,\"1f484\":59,\"1f485\":59,\"1f486\":59,\"1f487\":59,\"1f488\":59,\"1f489\":59,\"1f48a\":59,\"1f48b\":59,\"1f48c\":59,\"1f48d\":59,\"1f48e\":59,\"1f48f\":59,\"1f490\":59,\"1f491\":59,\"1f492\":59,\"1f493\":59,\"1f494\":59,\"1f495\":59,\"1f496\":59,\"1f497\":59,\"1f498\":59,\"1f499\":59,\"1f49a\":59,\"1f49b\":59,\"1f49c\":59,\"1f49d\":59,\"1f49e\":59,\"1f49f\":59,\"1f4a0\":59,\"1f4a1\":59,\"1f4a2\":59,\"1f4a3\":59,\"1f4a4\":59,\"1f4a5\":59,\"1f4a6\":59,\"1f4a7\":59,\"1f4a8\":59,\"1f4a9\":59,\"1f4aa\":59,\"1f4ab\":59,\"1f4ac\":59,\"1f4ad\":59,\"1f4ae\":59,\"1f4af\":59,\"1f4b0\":59,\"1f4b1\":59,\"1f4b2\":59,\"1f4b3\":59,\"1f4b4\":59,\"1f4b5\":59,\"1f4b6\":59,\"1f4b7\":59,\"1f4b8\":59,\"1f4b9\":59,\"1f4ba\":59,\"1f4bb\":59,\"1f4bc\":59,\"1f4bd\":59,\"1f4be\":59,\"1f4bf\":59,\"1f4c0\":59,\"1f4c1\":59,\"1f4c2\":59,\"1f4c3\":59,\"1f4c4\":59,\"1f4c5\":59,\"1f4c6\":59,\"1f4c7\":59,\"1f4c8\":59,\"1f4c9\":59,\"1f4ca\":59,\"1f4cb\":59,\"1f4cc\":59,\"1f4cd\":59,\"1f4ce\":59,\"1f4cf\":59,\"1f4d0\":59,\"1f4d1\":59,\"1f4d2\":59,\"1f4d3\":59,\"1f4d4\":59,\"1f4d5\":59,\"1f4d6\":59,\"1f4d7\":59,\"1f4d8\":59,\"1f4d9\":59,\"1f4da\":59,\"1f4db\":59,\"1f4dc\":59,\"1f4dd\":59,\"1f4de\":59,\"1f4df\":59,\"1f4e0\":59,\"1f4e1\":59,\"1f4e2\":59,\"1f4e3\":59,\"1f4e4\":59,\"1f4e5\":59,\"1f4e6\":59,\"1f4e7\":59,\"1f4e8\":59,\"1f4e9\":59,\"1f4ea\":59,\"1f4eb\":59,\"1f4ec\":59,\"1f4ed\":59,\"1f4ee\":59,\"1f4ef\":59,\"1f4f0\":59,\"1f4f1\":59,\"1f4f2\":59,\"1f4f3\":59,\"1f4f4\":59,\"1f4f5\":59,\"1f4f6\":59,\"1f4f7\":59,\"1f4f9\":59,\"1f4fa\":59,\"1f4fb\":59,\"1f4fc\":59,\"1f500\":59,\"1f501\":59,\"1f502\":59,\"1f503\":59,\"1f504\":59,\"1f505\":59,\"1f506\":59,\"1f507\":59,\"1f508\":59,\"1f509\":59,\"1f50a\":59,\"1f50b\":59,\"1f50c\":59,\"1f50d\":59,\"1f50e\":59,\"1f50f\":59,\"1f510\":59,\"1f511\":59,\"1f512\":59,\"1f513\":59,\"1f514\":59,\"1f515\":59,\"1f516\":59,\"1f517\":59,\"1f518\":59,\"1f519\":59,\"1f51a\":59,\"1f51b\":59,\"1f51c\":59,\"1f51d\":59,\"1f51e\":59,\"1f51f\":59,\"1f520\":59,\"1f521\":59,\"1f522\":59,\"1f523\":59,\"1f524\":59,\"1f525\":59,\"1f526\":59,\"1f527\":59,\"1f528\":59,\"1f529\":59,\"1f52a\":59,\"1f52b\":59,\"1f52c\":59,\"1f52d\":59,\"1f52e\":59,\"1f52f\":59,\"1f530\":59,\"1f531\":59,\"1f532\":59,\"1f533\":59,\"1f534\":59,\"1f535\":59,\"1f536\":59,\"1f537\":59,\"1f538\":59,\"1f539\":59,\"1f53a\":59,\"1f53b\":59,\"1f53c\":59,\"1f53d\":59,\"1f550\":59,\"1f551\":59,\"1f552\":59,\"1f553\":59,\"1f554\":59,\"1f555\":59,\"1f556\":59,\"1f557\":59,\"1f558\":59,\"1f559\":59,\"1f55a\":59,\"1f55b\":59,\"1f55c\":59,\"1f55d\":59,\"1f55e\":59,\"1f55f\":59,\"1f560\":59,\"1f561\":59,\"1f562\":59,\"1f563\":59,\"1f564\":59,\"1f565\":59,\"1f566\":59,\"1f567\":59,\"1f5fb\":59,\"1f5fc\":59,\"1f5fd\":59,\"1f5fe\":59,\"1f5ff\":59,\"1f600\":59,\"1f601\":59,\"1f602\":59,\"1f603\":59,\"1f604\":59,\"1f605\":59,\"1f606\":59,\"1f607\":59,\"1f608\":59,\"1f609\":59,\"1f60a\":59,\"1f60b\":59,\"1f60c\":59,\"1f60d\":59,\"1f60e\":59,\"1f60f\":59,\"1f610\":59,\"1f611\":59,\"1f612\":59,\"1f613\":59,\"1f614\":59,\"1f615\":59,\"1f616\":59,\"1f617\":59,\"1f618\":59,\"1f619\":59,\"1f61a\":59,\"1f61b\":59,\"1f61c\":59,\"1f61d\":59,\"1f61e\":59,\"1f61f\":59,\"1f620\":59,\"1f621\":59,\"1f622\":59,\"1f623\":59,\"1f624\":59,\"1f625\":59,\"1f626\":59,\"1f627\":59,\"1f628\":59,\"1f629\":59,\"1f62a\":59,\"1f62b\":59,\"1f62c\":59,\"1f62d\":59,\"1f62e\":59,\"1f62f\":59,\"1f630\":59,\"1f631\":59,\"1f632\":59,\"1f633\":59,\"1f634\":59,\"1f635\":59,\"1f636\":59,\"1f637\":59,\"1f638\":59,\"1f639\":59,\"1f63a\":59,\"1f63b\":59,\"1f63c\":59,\"1f63d\":59,\"1f63e\":59,\"1f63f\":59,\"1f640\":59,\"1f645\":59,\"1f646\":59,\"1f647\":59,\"1f648\":59,\"1f649\":59,\"1f64a\":59,\"1f64b\":59,\"1f64c\":59,\"1f64d\":59,\"1f64e\":59,\"1f64f\":59,\"1f680\":59,\"1f681\":59,\"1f682\":59,\"1f683\":59,\"1f684\":59,\"1f685\":59,\"1f686\":59,\"1f687\":59,\"1f688\":59,\"1f689\":59,\"1f68a\":59,\"1f68b\":59,\"1f68c\":59,\"1f68d\":59,\"1f68e\":59,\"1f68f\":59,\"1f690\":59,\"1f691\":59,\"1f692\":59,\"1f693\":59,\"1f694\":59,\"1f695\":59,\"1f696\":59,\"1f697\":59,\"1f698\":59,\"1f699\":59,\"1f69a\":59,\"1f69b\":59,\"1f69c\":59,\"1f69d\":59,\"1f69e\":59,\"1f69f\":59,\"1f6a0\":59,\"1f6a1\":59,\"1f6a2\":59,\"1f6a3\":59,\"1f6a4\":59,\"1f6a5\":59,\"1f6a6\":59,\"1f6a7\":59,\"1f6a8\":59,\"1f6a9\":59,\"1f6aa\":59,\"1f6ab\":59,\"1f6ac\":59,\"1f6ad\":59,\"1f6ae\":59,\"1f6af\":59,\"1f6b0\":59,\"1f6b1\":59,\"1f6b2\":59,\"1f6b3\":59,\"1f6b4\":59,\"1f6b5\":59,\"1f6b6\":59,\"1f6b7\":59,\"1f6b8\":59,\"1f6b9\":59,\"1f6ba\":59,\"1f6bb\":59,\"1f6bc\":59,\"1f6bd\":59,\"1f6be\":59,\"1f6bf\":59,\"1f6c0\":59,\"1f6c1\":59,\"1f6c2\":59,\"1f6c3\":59,\"1f6c4\":59,\"1f6c5\":59,\"1fd0983b\":50,\"1im\":[27,30,74],\"1st\":[31,68],\"1xn\":49,\"20f\":75,\"220446049250313e\":[39,85],\"223372036854776e18\":52,\"2499999f0\":39,\"24t12\":68,\"2500001f0\":39,\"25f0\":39,\"28th\":31,\"29t00\":31,\"29th\":31,\"2bb94d6\":36,\"2ffork\":50,\"2fgithub\":50,\"2fjulialang\":50,\"2fmetadata\":50,\"2im\":[27,28,30],\"2nd\":31,\"2pi\":[44,52],\"30e525\":50,\"30ish\":77,\"31st\":31,\"31t00\":[31,68],\"33333334f0\":[64,76],\"3333333f0\":76,\"3ef4f5c4\":50,\"3im\":[27,58],\"4031192506220405im\":27,\"4142135623730951im\":34,\"417b50a\":2,\"459565876494606882133333333333333333333333333333333333333333333333333333333344e\":39,\"4717266720048188im\":27,\"47c198b1\":50,\"4ghz\":52,\"4im\":27,\"4th\":[12,31,68],\"5000025e11\":52,\"5172413793103449im\":27,\"53rd\":68,\"55b6\":59,\"5714285714285714im\":27,\"5f0\":[39,52,64],\"5fcfb13\":50,\"5im\":27,\"5th\":31,\"60im\":27,\"64f437b\":40,\"6e80\":59,\"7071067811865475im\":27,\"75im\":27,\"7861513777574233im\":27,\"793662034335766e\":39,\"7a7a\":59,\"84b8e266dae6de30ab9703150b3bf771ec7b6285\":50,\"8ball\":59,\"8im\":27,\"8p3\":39,\"960664459571898im\":27,\"9f71f4becb05cadacb983c54a72eed744e5c019d\":50,\"\\u00e5ke\":74,\"\\u00ectr\":66,\"\\u0111\":59,\"\\u0127\":[40,59],\"\\u0142\":59,\"\\u014b\":59,\"\\u0153\":59,\"\\u0195\":59,\"\\u019e\":59,\"\\u01b6\":59,\"\\u01c2\":59,\"\\u0250\":59,\"\\u0252\":59,\"\\u0254\":59,\"\\u0256\":59,\"\\u0259\":59,\"\\u025b\":[59,74],\"\\u0263\":59,\"\\u0264\":59,\"\\u0265\":59,\"\\u026c\":59,\"\\u026d\":59,\"\\u026f\":59,\"\\u0270\":59,\"\\u0271\":59,\"\\u0272\":59,\"\\u0273\":59,\"\\u0277\":59,\"\\u0278\":59,\"\\u0279\":59,\"\\u027a\":59,\"\\u027b\":59,\"\\u027c\":59,\"\\u027d\":59,\"\\u027e\":59,\"\\u0282\":59,\"\\u0283\":59,\"\\u0287\":59,\"\\u0288\":59,\"\\u028a\":59,\"\\u028b\":59,\"\\u028c\":59,\"\\u028d\":59,\"\\u028e\":59,\"\\u0290\":59,\"\\u0292\":59,\"\\u0294\":59,\"\\u0295\":59,\"\\u0296\":59,\"\\u029e\":59,\"\\u02a4\":59,\"\\u02a7\":59,\"\\u02b0\":59,\"\\u02b2\":59,\"\\u02b3\":59,\"\\u02b7\":59,\"\\u02b8\":59,\"\\u02bc\":59,\"\\u02c7\":59,\"\\u02c8\":59,\"\\u02cc\":59,\"\\u02d0\":59,\"\\u02d1\":59,\"\\u02e1\":59,\"\\u02e2\":59,\"\\u02e3\":59,\"\\u03b1\":[32,40,59,60,74],\"\\u03b2\":[59,74],\"\\u03b3\":[59,76],\"\\u03b4\":[59,60],\"\\u03b4t\":52,\"\\u03b5\":59,\"\\u03b6\":59,\"\\u03b7\":59,\"\\u03b8\":[58,59],\"\\u03b9\":59,\"\\u03ba\":59,\"\\u03bb\":[43,59,74],\"\\u03bc\":59,\"\\u03bd\":59,\"\\u03be\":59,\"\\u03bf\":59,\"\\u03c0\":[40,59,60,76],\"\\u03c1\":59,\"\\u03c2\":59,\"\\u03c3\":59,\"\\u03c4\":59,\"\\u03c5\":59,\"\\u03c6\":[59,76],\"\\u03c7\":59,\"\\u03c8\":59,\"\\u03c9\":59,\"\\u03d0\":59,\"\\u03d1\":59,\"\\u03d5\":59,\"\\u03d6\":59,\"\\u03d9\":59,\"\\u03db\":59,\"\\u03dd\":59,\"\\u03df\":59,\"\\u03e1\":59,\"\\u03f0\":59,\"\\u03f1\":59,\"\\u03f5\":59,\"\\u1d2c\":59,\"\\u1d2e\":59,\"\\u1d30\":59,\"\\u1d31\":59,\"\\u1d33\":59,\"\\u1d34\":59,\"\\u1d35\":59,\"\\u1d36\":59,\"\\u1d37\":59,\"\\u1d38\":59,\"\\u1d39\":59,\"\\u1d3a\":59,\"\\u1d3c\":59,\"\\u1d3e\":59,\"\\u1d3f\":59,\"\\u1d40\":59,\"\\u1d41\":59,\"\\u1d42\":59,\"\\u1d43\":59,\"\\u1d45\":59,\"\\u1d47\":59,\"\\u1d48\":59,\"\\u1d49\":59,\"\\u1d4b\":59,\"\\u1d4d\":59,\"\\u1d4f\":59,\"\\u1d50\":59,\"\\u1d52\":59,\"\\u1d56\":59,\"\\u1d57\":59,\"\\u1d58\":59,\"\\u1d5b\":59,\"\\u1d5d\":59,\"\\u1d5e\":59,\"\\u1d5f\":59,\"\\u1d60\":59,\"\\u1d61\":59,\"\\u1d62\":59,\"\\u1d63\":59,\"\\u1d64\":59,\"\\u1d65\":59,\"\\u1d66\":59,\"\\u1d67\":59,\"\\u1d68\":59,\"\\u1d69\":59,\"\\u1d6a\":59,\"\\u1d9c\":59,\"\\u1da0\":59,\"\\u1da5\":59,\"\\u1db2\":59,\"\\u1dbb\":59,\"\\u1dbf\":59,\"\\u2070\":59,\"\\u2071\":59,\"\\u2074\":59,\"\\u2075\":59,\"\\u2076\":59,\"\\u2077\":59,\"\\u2078\":59,\"\\u2079\":59,\"\\u207f\":59,\"\\u2080\":59,\"\\u2081\":59,\"\\u2082\":[59,60],\"\\u2083\":59,\"\\u2084\":59,\"\\u2085\":59,\"\\u2086\":59,\"\\u2087\":59,\"\\u2088\":59,\"\\u2089\":59,\"\\u2090\":59,\"\\u2091\":59,\"\\u2092\":59,\"\\u2093\":59,\"\\u2094\":59,\"\\u2102\":59,\"\\u2107\":59,\"\\u210a\":59,\"\\u210b\":59,\"\\u210c\":59,\"\\u210d\":59,\"\\u210e\":59,\"\\u210f\":59,\"\\u2110\":59,\"\\u2111\":59,\"\\u2112\":59,\"\\u2113\":59,\"\\u2115\":59,\"\\u2119\":59,\"\\u211a\":59,\"\\u211b\":59,\"\\u211c\":59,\"\\u211d\":59,\"\\u2124\":59,\"\\u2128\":59,\"\\u212c\":59,\"\\u212d\":59,\"\\u212f\":59,\"\\u2130\":59,\"\\u2131\":59,\"\\u2133\":59,\"\\u2134\":59,\"\\u2135\":59,\"\\u2136\":59,\"\\u2137\":59,\"\\u2138\":59,\"\\u2139\":59,\"\\u213c\":59,\"\\u213d\":59,\"\\u213e\":59,\"\\u213f\":59,\"\\u2145\":59,\"\\u2146\":59,\"\\u2147\":59,\"\\u2148\":59,\"\\u2149\":59,\"\\u214e\":59,\"\\u2c7c\":59,\"\\u2c7d\":59,\"\\u4eba\\u4eba\\u751f\\u800c\\u81ea\\u7531\":60,\"\\u4f60\\u597d\":36,\"\\u5728\\u5c0a\\u4e25\\u548c\\u6743\\u5229\\u4e0a\\u4e00\\u5f8b\\u5e73\\u7b49\":60,\"\\uc548\\ub155\\ud558\\uc138\\uc694\":[36,60],\"abstract\":[1,7,8,15,16,21,25,26,28,30,31,32,39],\"b\\u00e9zout\":75,\"bj\\u00f6rck\":74,\"boolean\":[1,19,21,25,29,30,33,44,46,49,58,63,64,66,71,74,75,76,77,80,84],\"break\":[1,2,6,15,29,31,32,33,34,49,50,51],\"byte\":[14,16,26,36,39,45,48,51,52,53],\"case\":[1,3,5,8,14,15,17,18,19,21,22,25,26,27],\"catch\":[1,6,8,17],\"char\":[6,7,9,14,18,26,33,40,46,48,56,58,65,68,71,74,84],\"class\":[11,25,35,36,44,49,54,56,58,71],\"const\":[1,14,18,26,31,32,33,40,47,52,60,61,64,73,77],\"default\":[3,6,8,11,15,16,17,20,21,22,25,26,28,29,31,32,34],\"double\":59,\"enum\":[26,32,49,64,73],\"export\":[1,5,11,15,16,26,31,33,34,47,50,51,64,65,68,73,74,78,79,83,85],\"false\":49,\"final\":[1,6,7,8,9,12,16,19,21,26,28],\"float\":[6,23,26,27,28,30,36,38],\"fr\\u00e9chet\":74,\"function\":[1,3,4],\"goto\":[52,85],\"int\":[1,8,9,14,15,16,18,19,21,25,26,28,29,30,31,33,34,35,39,40,41,44,45,46,47,49,51,52,53,56,57,58,59,63,64,65,66,68,69,71,74,75,76,77,79,83,85],\"long\":[3,5,15,17,26,29,46,50,51,53,59,61,65,71,74,75,76,77,79,84],\"new\":[1,2,6,7,8,9,12,13,14,15,20,26,28,29],\"null\":[1,6,7,9,18,26,28,33],\"package\":[50,59],\"public\":[47,50,51,59],\"return\":[1,3,4,6,7,8,9,13,15,16,18,19,21,25],\"short\":[6,7,26,28],\"static\":[1,11,18,30,37,42,49],\"super\":[9,26,30,74],\"switch\":[29,34,36,50,51,52,77],\"throw\":[3,8,15,19,26,28],\"transient\":46,\"true\":[1,5,6,8,15,16,19,20,21,25,26,27,28,29,30,31,32,34,36,39,41,44,45,46,48,49,51,52,53,54,55,56,58,59,61,63,64,65,66,68,69,71,74,75,76,77,78,79,82,83,84,85],\"try\":[1,2,3,8,12,15,21,26,27,28],\"typeof\":[8,16,18,26,27,28,29,30,33,34,39,44,45,52,56,57,58,64,66,71,75,85],\"var\":[1,5,21,26,29,40,45,64,75,77],\"void\":[6,14,18,21,26,33,34,47,55,56,57,65,66,67,72,78,83],\"while\":[1,2,5,6,12,14,15,16,17,19,21,26,28,29,30,31,32,33,34,36,39,41,42,45,46,47,48,49,50,51,52,53,54,55,56,57,58,60,61,64,66,68,73,74,75,77,79,82],_130862:16,__doc__:32,__file__:[47,67,69],__init__:[9,18,47,64],__line__:69,__m128:26,__m256:26,__precompile__:[47,64],__text:34,_always_:74,_appli:8,_atexit:[7,9],_beta:59,_chi:59,_expr:8,_fileno:18,_fopen:37,_gamma:59,_getindex:3,_init:62,_j_str267:6,_julia_init:9,_mm256_add_p:26,_mm256_mul_p:26,_mm256_sqrt_p:26,_nogc:12,_noreturn:26,_phi:59,_rho:59,_schwa:59,_start:7,_var0:52,_var1:52,_var2:52,_var3:52,_var4:52,a_1:[5,26],a_2:[5,26],a_3:[5,26],a_ldiv_b:[74,75],a_ldiv_bc:74,a_ldiv_bt:74,a_mul_b:[74,75],a_mul_bc:74,a_mul_bt:74,a_rdiv_bc:74,a_rdiv_bt:74,aaaa1aaaa2aaaa3:56,aarch64:26,abbr:68,abbrevi:[31,45,57,68],abbreviat:68,abc:[59,85],abcd:[48,59],abi_:7,abil:[5,29,42,45,46,47,48,58,71],abl:[3,6,21,28,29,32,34,35,40,41,48,50,51,52,58,61,64],abnrm:74,abort:6,about:[3,6,7,8,10,11,14,15],abov:[1,8,9,12,14,16,19,21,26,29,30,31,32,33,34,35,39,40,41,42,45,46,47,48,50,51,52,53,54,55,56,57,58,61,64,68,71,74,77,83],above:59,abracadabra:56,abruptli:26,abs2:[25,27,44,52,66,75],absenc:[30,31,46,58],absent:14,absolut:[27,31,32,39],abspath:69,abstol:[8,74,75],abstract_cal:53,abstract_call_gf:53,abstract_ev:53,abstractarrai:[3,15,19,25,26,32,35,40,41,46,51,52,57,63,64,66,74,75,76,82],abstractcartesianindex:40,abstractfloat:[16,21,30,46,52,58,63,64,76],abstractli:[46,84],abstractlock:77,abstractmatrix:[19,25,63,74],abstractremoteref:77,abstractrepl:40,abstractrng:76,abstractsparsearrai:40,abstractsparsematrix:25,abstractstr:[26,32,34,39,40,51,56,57,58,64,66,68,69,71,73,76,77,78,84,85],abstractvector:[15,19,25,52,63,71,74,77],abstractworkerpool:77,abus:[28,45],ac_ldiv_b:74,ac_ldiv_bc:74,ac_mul_b:74,ac_mul_bc:74,ac_rdiv_b:74,ac_rdiv_bc:74,accent:[56,59,84],accept:[8,15,16,21,25,26,27,31,32,34,35,40,41,48,49,50,52,56,57,58,59,61,65,66,71,76,77,78,82,84,85],access:[3,6,8,11,14,19,25],accident:[34,45,47,50],accommod:[21,47,63,66,71],accompani:74,accomplish:[26,28,29,31,35,41,45,47,50,54,58,66],accord:[25,31,39,44,50,52,63,64,66,68,74,75,76,82,84],accordingli:[28,35,46,50,52,58,65],account:[39,47,49,50,56,74,85],accumul:[51,52],accur:[2,26,28,44,50,54,75],accuraci:[17,39,47,63,74,75],accurat:75,accurr:59,accustom:49,acd:56,achiev:[3,21,28,34,35,42,45,48,49,50,51,52,75],acidfre:59,aco:[25,44,75],acosd:[25,44,75],acosh:[25,44,75],acot:[25,44,75],acotd:[25,44,75],acoth:[25,44,75],acoustic:74,acquir:[12,77],acronym:[7,50],across:[19,26,42,44,49,51,58,71,74,77,85],acsc:[25,44,75],acscd:[25,44,75],acsch:[25,44,75],act:[6,25,26,35,45,46,49,51,58,63,66,77],action:[7,12,21,29,30,40,45,53],activ:[2,48,54,64,85],actual:[6,8,25,26,28,29,30,31,32,34,35,39,45,48,50,52,53,54,55,56,58,61,64,65,71,75,77],actualli:54,actually:59,acut:59,acute:59,ada:[30,58],adapt:[52,75],add:[1,6,7,8,15,16,22,25,28,31,32,33,34,40,44,45,46,47,48,50,51,52,53,57,58,62,66,71,75,77,78,81],add_builtin_func:9,add_float:52,adder:8,addict:57,addit:[3,5,6,13,17,19,22,25,26,27,28,29,30,31,33,34,36,40,41,42,44,45,46,47,48,50,51,52,56,58,60,62,63,64,66,68,74,75,76,77,81,84],addition:[12,21,25,28,29,31,32,33,34,37,39,41,44,50,51,52,56,64,66,75,77,84],addon:57,addopt:84,addp:81,addproc:[51,77],addr:[71,72],address:[6,12,14,15],adjac:[25,39,63,82,84],adjust:[22,31,50,64,68],adopt:[15,19,52,60],adot:59,advanc:[25,29],advantag:[15,33,34,39,42,45,47,51,52,58,62,77],advantage:59,advection_chunk:51,advection_parallel:51,advection_seri:51,advection_shar:51,advection_shared_chunk:51,advic:52,advis:[32,59,75],aerial:59,aerial_tramwai:59,affect:[9,26,35,47,52,57,61,76,79],affix:51,aforement:46,africa:59,after:[1,6,9,11,22,25,26,28,29,30,31,32,33,34,35,40,44,45,46,47,48,49,50,51,52,53,56,58,60,64,65,69,71,72,74,75,77,78,84,85],afterward:[28,29,32,50,71,77,84],again:[9,26,29,30,35,40,45,48,50,51,52,71,74,77,78,79],against:[11,21,33,34,50,57],agent:50,aggreg:4,aggress:34,agnost:19,agre:[28,56],agroup:56,ah12:74,ahead:[31,51],ahr13:74,aid:[31,33,49],aim:42,airi:[25,44,75],airplan:59,airplane:59,airyai:[25,44,75],airyaiprim:[25,44,75],airybi:[25,44,75],airybiprim:[25,44,75],airyprim:[25,44,75],airyx:[44,75],aka:[21,26],akin:25,alarm:59,alarm_clock:59,albeit:[7,51],alef:59,aleph:59,alert:[26,57,85],alg:82,algebra:[23,34,38],algorithm:[5,12,14,15,19,21,30,34,41,46,50,51,52,58,63,66,74,75,77],alia:9,alias:[25,26,39],alien:59,align:[14,16,26,32],all:[1,3,5,6,7,8,11,12,14,15,16,19,20,21,22,25,26,27,28,29,30,31,32,33,34,35,36,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,56,57,58,59,61,63],all_to_al:[51,77],allequ:59,allevi:56,alloc:[1,7,9,12],allow:[3,5,6,12,15,18,19,21,25,26,27,28,29,30,32,33,34,35,39,40,41,43,44,45,46,47,48,49,50,51,52,53,56,58],allow_user_segv_handl:17,alluniqu:66,almost:[12,25,33,34,43,45,46,49,52,59,61],alon:[26,34,45,57,58,61],along:[7,8,15,25,28,31,32,41,50,51],alpha:[32,40,56,59,60,74],alphabet:84,alphanumer:[32,84],alreadi:[1,12,26,28,32,33,34,35,40,41,45,47,50,51,52,57,58,62,64,66,71,74,77,82],also:[1,5,6,7,8,11,12,14,15,16,17,20,21,22,25,26,27,28,29,30,31,32,33,34,35,36,39,40,41,42,44,45,46,47,48,49,50,51,52,53,55,56,57,58,60,61,62,63,64,65,66,67,68,71,74,75,76,77,78,80,82,83,84,85],alt:40,alter:[15,26,28,35,45,58],altern:[6,8,14,29,30,32,33,34,39,45,47,49,52,53,54,57,62,64,65,66,67,68,69,71,75,84,85],alternat:71,alternation:59,although:[7,14,21,28,29,30,35,42,45,46,49,50,51,52,53,58,61,71,74,75],altogeth:[46,51,52,57],alveolar:59,alwai:[1,2,4,12,13,15,25,26,28,29,30,31,32,33,34,35,36,39,41,42,46,47,49,51,52,54,56,57,58,61,64,66,69,71,75,76,84],amalg:59,amalgamation:59,amazon:51,ambigu:[3,15,39,45,46,50,54],ambul:59,ambulance:59,amd:74,amen:[52,64],american:[59,75],americas:59,among:[15,21,29,35,47,50,51,52,53,57,71,77],amongst:[51,77],amount:[42,45,47,51,52,53,56,63,64,71,77],ampersand:59,amplifi:34,analog:[31,34,52,63],analogu:[49,63],analysi:[7,8],analyt:75,analyz:0,anatomi:29,anchor:59,and_int:52,angdnr:59,angel:59,anger:59,angl:[25,27,44,59,74,75],angle:59,angleubar:59,angri:[56,59,84],angry:59,angstrom:59,anguish:59,anguished:59,ani:[2,3,5,6,7,8,11,12,13,14,15,16,18,19,21,22,25,26,27,28,29,30,31,32,33,34,35,39,40,41,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,61,63,64,65,66,68,71,74,75,77,78,79,84,85],animal:85,annot:1,annuiti:59,annuity:59,anonymousmmap:71,anorm:74,anoth:[3,8,17,21,26,28,29,30,31,32,33,34,40,45,47,48,49,50,51,52,54,57,58,62,64,66,71,77],another:[6,8,22,25,32,45,50,54,56,57,58],answer:[15,25,31,40,51,65,74,75,77],answer_color:40,ant:59,antenna:59,anticlockwise:59,any:[1,6,8,9,13,16,19],anymor:[15,50,61],anyon:[30,45,50,51],anyth:[25,29,34,40,41,42,44,45,47,50,56,64,66,76],anywai:[25,31,34,57],anywher:[26,29,32,35,46,56,58],apach:50,apart:[19,34],apex:58,api:[8,14,26,31,33,34,42,48,50,51,68,71,74,77,82],apl:59,aplboxquest:59,aplboxupcaret:59,aplnotbackslash:59,aplnotslash:59,apolog:54,apostrophe:59,appar:[46,47,56],appeal:[19,34],appear:[1,3,5,8,15,26,28,32,33,34,40,46,49,50,52,53,55,59,61,66,74,82],append:[13,19,26,32,46,49,51,53],appl:[36,40,56,59,64,84],apple:[49,59,64],appli:[4,19,25,27,28,29,30,32,35,39,42,44,45,46,49,50,51,52,58,63,64,66,68,69,71,74,75,77,82,85],applic:[5,8,12,16,25,26,29,30,32,33,35,39,42,46,48,52,53,55,56,64,71,73,74,75,76],applicat:74,apply:[46,66,69,71,75],apply_typ:[8,16],appreci:[11,52],approach:[5,6,19,31,34,35,36,40,42,45,50,51,52,74],approaches:59,appropri:[15,19,25,26,28,29,30,34,39,40,41,42,45,46,48,50,51,52,54,55,56,57,58,64,66,71,74,76,77,84],approv:50,approx:[59,85],approxeq:59,approxeqq:59,approxim:[26,30,53,64,75,85],approximate:59,approximately:59,approxnotequ:59,appveyor:50,apr:68,april:[31,68],apropo:64,aptli:45,aquariu:59,aquarius:59,arabic:56,arbitrari:[1,12,15,25,26,30,32,35],arbitrarili:[32,44,46,49,50,58,76],arc:59,arceq:59,arch:67,archaic:59,architectur:[39,56,67,74],archiv:7,aren:[28,47,50,54,56,74],arg1:[26,36,46,49],arg2:[26,36,46,49],arg3:49,arg:[1,2,4,6,8,13,14,15,18,21,25,27,28,33,34,35,36,40,45,52,64,71,77],argc:[9,26,33],args:[7,9,36,67],args_morespecif:21,argtyp:[33,77],argtype:16,argument:[1,3,4],argumenterror:[27,29,64,66,75,84],argumenttyp:[26,65],argumenttype1:65,argumentvalu:65,argumentvalue1:65,argv:[9,26,33,54],argval:77,ari:[1,43,59],aries:59,aris:[1,6,39,43,45],arisen:[30,58],arithmet:[25,26,27,30],arm:[26,59],armed:21,arnoldi:74,around:[7,8,26,28,33,34,35,45,50,51,57,58,59],arrai:[1,3,4,5,6,8,9,10,11,12,13,14],arrang:[8,26,45,52,54],array3:52,array_typ:33,arraycontain:52,arraymath:46,arrayref:[3,8,52],arrays:8,arrayset:[3,8],arraytyp:41,arriv:[9,29],arrow:[40,59],arrow_backward:59,arrow_double_down:59,arrow_double_up:59,arrow_down:59,arrow_down_smal:59,arrow_forward:59,arrow_heading_down:59,arrow_heading_up:59,arrow_left:59,arrow_lower_left:59,arrow_lower_right:59,arrow_right:59,arrow_right_hook:59,arrow_up:59,arrow_up_down:59,arrow_up_smal:59,arrow_upper_left:59,arrow_upper_right:59,arrows:59,arrows_clockwis:59,arrows_counterclockwis:59,art:59,arthur:46,articl:39,articulated:59,articulated_lorri:59,artifici:46,artist:59,arts:59,ary:59,asan_options:17,ascend:[50,66,75,82],ascii:[9,34,56,71,77,84],asec:[25,44,75],asecd:[25,44,75],asech:[25,44,75],asia:59,asid:[32,57],aside:8,asin:[25,44,75],asind:[25,44,75],asinh:[25,44,75],ask:[19,21,31,41,50,51,52,56,57,58,63],asked:23,asl:50,aspect:[52,54,57,58],assembl:[7,64],assert:[15,26,45,46,52,58,64,72,85],assertionerror:[45,64],assign:[1,16,21,25,26,28,29,31,34,35,41,44,45,47,49,51,52,56,58,60,61,63,64,73,77,84],assist:58,associ:[8,14,15,29,31,32,34,43,46,47,48,50,51,58,60,63,64],assum:[14,15,22,26,29,31,33,39,47,48,50,52,61,63,66,68,71,74,75,82,84],assume:[33,52,58,65],assumpt:[15,22,31,33,75],asteq:59,asteracc:59,asterisk:[32,59],astonish:59,astonished:59,astrosun:59,asum:74,asymp:59,asymptot:75,asymptotically:59,async:[29,34,48,51,52,54,64,77],asynccondit:[26,64],asyncmap:77,at_ldiv_b:74,at_ldiv_bt:74,at_mul_b:74,at_mul_bt:74,at_rdiv_b:74,at_rdiv_bt:74,atan2:[25,44,75],atan:[25,44,75],atand:[25,44,75],atanh:[25,44,75],atexit:[7,64],athletic:59,athletic_sho:59,atm:59,atol:75,atom:[1,77],atomic:77,atomic_:77,atomic_add:77,atomic_and:77,atomic_ca:77,atomic_f:77,atomic_max:77,atomic_min:77,atomic_nand:77,atomic_or:77,atomic_sub:77,atomic_xchg:77,atomic_xor:77,atomicrmw:77,atreplinit:[40,64],attach:[6,32,58],attempt:[2,7,12,19,26,40,47,48,50,52,54,56,58,64,66,71],attent:[25,32,34],attitud:50,attr:16,atyp:14,aubergine:59,audio:71,audit:[2,15,50],aug:68,augment:42,august:68,australia:59,authent:[51,77],author:[32,50,53],auto:8,auto_unbox:6,autom:[20,50],automat:[16,25,26,28,29,30,32],automated:59,automobile:59,autotool:17,aux:54,auxiliari:[28,30],avail:[7,16,18,19,20,26,29,31,34,36,39,40,43,45,47,48,50,51,52,53,55,57,58,60,61,63,64,65,66,67,69,71,72,73,74,75,76,77,78,82,85],availabl:47,averag:25,average:59,avoid:[3,12,15,19,25,26,27,28,31,32,34,35,39,45,46,47,48,49,50,51],avx:26,awad:74,awai:[29,39,50,52,63,75],awar:[26,31,33,46,47,51,54,57],awint:59,awkward:[35,56],awri:2,axi:[44,52],axpi:74,b96:74,b_a:26,b_a_2:26,babi:59,babuska:63,baby:59,baby_bottl:59,baby_chick:59,baby_symbol:59,back:[6,7,9,21,26,28,29,30,33,44,50,51,52,56,58,59,61,63,71,75,77,78],backbon:58,backend:71,backepsilon:59,backhand:59,backppprim:59,backpprim:59,backprim:59,backsim:59,backsimeq:59,backslash:[56,59,60,64,68,71,80],backspac:40,backtick:[32,54,64],backtrac:[2,6,7,9,17,29,53],backtransform:74,backward:[64,74,75],bactrian:59,bad:[8,26,29],bad_funct:55,badge:59,badli:50,bag:[58,59],baggage:59,baggage_claim:59,bagmemb:59,bail:[8,50],balanc:74,ball:59,balloon:59,ballot:59,ballot_box_with_check:59,bamboo:59,banana:[49,56,59,84],band:74,bang:82,bangbang:59,bank:59,banknote:59,banner:[36,40],bar:[28,29,32,34,35,36,45,46,47,50,52,53,54,58,59,61,64,65,66,77,85],bar_chart:59,barb:59,barbar:45,barber:59,barcap:59,barcup:59,baremodul:[32,47,61,64],barleftarrow:59,barleftarrowrightarrowbar:59,barovernorthwestarrow:59,barred:59,barrier:33,barrightarrowdiamond:59,bars:59,barve:59,barwedg:59,base64:71,base64decod:71,base64decodepip:71,base64encod:71,base64encodepip:71,base:[1,2],basebal:59,baseball:59,baselin:8,basenam:69,bash:[11,26],basi:[31,74,82],basic:1,basketbal:59,basketball:59,batch:77,batch_siz:77,bath:59,bathtub:59,batteri:59,battery:59,bauer:74,baz:[28,29,34,35,45,54,58,66],bbb:59,bbba:59,bbbb:59,bbbc:59,bbbd:59,bbbe:59,bbbeight:59,bbbf:59,bbbfive:59,bbbfour:59,bbbg:59,bbbgamma:59,bbbh:59,bbbi:59,bbbj:59,bbbk:59,bbbl:59,bbbm:59,bbbn:59,bbbnine:59,bbbo:59,bbbone:59,bbbp:59,bbbpi:59,bbbq:59,bbbr:59,bbbs:59,bbbseven:59,bbbsix:59,bbbt:59,bbbthree:59,bbbtwo:59,bbbu:59,bbbv:59,bbbw:59,bbbx:59,bbby:59,bbbz:59,bbbzero:59,bbrktbrk:59,bbsum:59,bce:31,bdsdc:74,bdsqr:74,beam:59,beamed:59,bear:59,beating:59,becaus:[6,7,8,15,16,18,21,25,26,28,29,31,33,34,35,42,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,63,65,66,72,74,75,76,79,84,85],because:59,becom:[15,25,28,29,34,35,45,51,52,53,54,55,56,57,58,60,68,74,77],bee:59,been:[2,3,6,7,15,16,28,29,30,34,35,40,42,43,44,47,48,50,51,52,53,54,55,56,58,61,64,71,72,74,77,78],beer:59,beetl:59,beetle:59,befor:[1,5,7,8,9,11,17,18,19,22,25,26,28,29,30,31,32,33,34,35,39,40,42,44,45,46,47,48,49,50,51,52,53,54,56,58,61,64,66,68,69,71,73,74,75,77,82,84],beforehand:26,begin:[1,5,8,9,15,16,19,21,28,29,31,32,34,35,36,40,45,48,50,51,52,53,56,58,60,61,62,66,69,71,77,80,84,85],beginn:59,beginner:59,behav:[1,15,22,25,26,27,28,31,34,45,46,51,52,56,57,58,61,63,66,75],behavior:[3,15,21,25,26,28,29,30,34],behaviour:[30,31,32,51,75,84],behind:[34,48,50,59],believ:42,bell:59,belong:[8,46,50,58,84],below:[5,9,12,15,17,19,21,25,26,29,32,33,35,36,41,45,47,50,51,52,53,56,58,59,61,64,74],belt:59,benchmark:[52,75],beneath:50,benefici:[32,34,35,58],benefit:[48,51,52,77],bento:59,benzene:59,benzenr:59,beowulf:77,bernoulli:63,berr:74,besid:[11,30,50,56,76],beside:59,bess:[25,44,75],bessel:[26,44,75],besselh:[25,44,75],besselhx:75,besselix:[44,75],besselj0:[25,44,75],besselj1:[25,44,75],besselj:[25,44,75],besseljx:[44,75],besselk:[25,44,75],besselkx:[44,75],bessely0:[25,44,75],bessely1:[25,44,75],besselyx:[44,75],best:[2,11,15,19,26,28,29,34,47,49,50,52,53,63,71,74,75],bet:[2,59],beta:25,beth:59,better:[11,15,19,22,25,28,30,45,47,50,51,52,54,57,64,75,79,85],between:[3,5,11],beverage:59,bewar:32,beyond:[25,30,46,56,64,71],bfft:75,bh83:74,bias:74,biceps:59,bicycle:59,bicycles:59,bicyclist:59,bidiagon:[43,74],big:[5,30,64,71,75,76],big_str:1,bigblacktriangledown:59,bigblacktriangleup:59,bigbot:59,bigcap:59,bigcirc:59,bigcup:59,bigcupdot:59,bigfloat:[16,39,49,75],bigger:34,biggest:[51,52],bigint:[30,34,39,49,75,76],biglib:47,bigodot:59,bigoplu:59,bigotim:59,bigslopedve:59,bigslopedwedg:59,bigsqcap:59,bigsqcup:59,bigstar:59,bigtim:59,bigtop:59,bigtriangledown:59,bigtriangleup:59,biguplu:59,bigve:59,bigwedg:59,bigwhitestar:59,bike:[50,59],bikini:59,bilater:63,billiards:59,bin:[2,6,11,26,33,40,71,75,76],bin_arr:76,binari:[2,25,34,36,39,43,44,48,49,50,63,64,66,71,75,76,77,85],binary:59,bind:[1,9,16,27,28,32,34,35,36],bind_addr:[36,51,77],bindep:47,binomi:75,bird:59,birthdai:59,birthday:59,bischof1987:74,bischof:74,bisecting:59,bit:[1,6,7,9],bitarrai:15,bitbroadcast:63,bitbucket:50,bitcod:[36,64],bitfield:69,bitrand:76,bitshift:44,bitstyp:[26,56,58,77,81],bitvector:[63,66,74],bitwis:[25,29,39],bkarow:59,bkfact:74,black:[8,35,40,59,71],black_circl:59,black_jok:59,black_large_squar:59,black_medium_small_squar:59,black_medium_squar:59,black_nib:59,black_small_squar:59,black_square_button:59,blackcircledrightdot:59,blackcircledtwodot:59,blackcircleulquadwhit:59,blackinwhitediamond:59,blackinwhitesquar:59,blacklefthalfcircl:59,blacklozeng:59,blackpointerleft:59,blackpointerright:59,blackrighthalfcircl:59,blacksmilei:59,blacksquar:59,blacktriangl:59,blacktriangledown:59,blacktriangleleft:59,blacktriangleright:59,blank:[32,40,56,59,71,78],blanksymbol:59,blas:[2,25,26,51],blascopi:74,blasfloat:74,blindli:41,blkdiag:74,blkhorzov:59,blksize:[64,69],blkvertov:59,blockful:59,blockhalfshad:59,blocklefthalf:59,blocklowhalf:59,blockqtrshad:59,blockrighthalf:59,blockthreeqtrshad:59,blockuphalf:59,blog:[26,34,39,44,50],blond:59,bloomfilt:50,blossom:59,blow:8,blowfish:59,blue:[40,59,71],blue_book:59,blue_car:59,blue_heart:59,blush:[34,59],boar:59,board:59,boat:59,bodi:[1,3,5,6,8,13,15,29,30,34,35,41,45,46,47,49,52,57,61,65,66,71,77,85],bodyexpr:5,boi:59,boilerpl:[26,45],boldfac:32,bolt:59,bomb:59,bone:59,bonu:21,boo:45,book:[32,39,50,59],bookmark:59,bookmark_tab:59,books:59,bool:[3,6,8,13,21,25,26,29,30,31,34,39,44,46,49,51,52,55,58,63,64,66,68,69,71,74,75,76,77,83,84,85],boom:[31,59],boot:[7,9,21,40,55,58,59],boots:59,bootup:2,borrow:[42,54],bot:59,both:[1,5,7,15,16,19,21,22,25,26,27,28,29,30,31,32,34,35,39,40,41,45,46,47,49,50,51,52,53,54,55,56,57,58,59,61,63,64,66,68,74,75,78,82],bother:15,botsemicircl:59,bottle:59,bottleneck:[52,53],bound:1,boundari:[26,52,56,74],boundscheck:[1,3,15],boundserror:[29,41,45,49,56,64],bouquet:59,bourn:51,bow:59,bowing:59,bowl:59,bowling:59,bowti:59,bowtie:59,box:[4,6,7,9,14,33,52,58,59],boxast:59,boxbar:59,boxbslash:59,boxcircl:59,boxdiag:59,boxdot:59,boxed_uint8_cach:9,boxminu:59,boxplu:59,boxtim:59,boy:59,brace:58,branch:[1,3,29,34],bread:59,breakag:50,bref:51,breve:59,brfft:75,bride:59,bride_with_veil:59,bridg:33,bridge:59,bridge_at_night:59,brief:[39,41,50,51,71],briefcas:59,briefcase:59,briefli:[28,46,52],brightness:59,bring:[32,68],brittl:50,broad:[39,44,64],broadcast_getindex:[25,63],broadcast_setindex:[25,63],broadli:19,broke:50,broken_heart:59,broker:51,brought:[47,51],browser:[53,59],bruce:39,bsd:[6,50,64],bsimilarleftarrow:59,bsimilarrightarrow:59,bsolhsub:59,bswap:76,btime:59,buf:18,buffalo:59,buffer:[18,26,40,48,53,54,58,71,79],bufferstream:51,bug:[15,17,22,26,34,50,52,57,59],bugfix:34,build:2,build_llvm_clang:17,build_sysimg:20,building:59,buildings:59,built:[3,6,9,11,14,21,25,26],builtin:[4,6,7],bulb:59,bulid:11,bulk:[7,50],bullet:[32,59],bullettrain_front:59,bullettrain_sid:59,bullsey:59,bullseye:59,bumpeq:59,bumpeqq:59,bumpy:59,bunch1977:74,bunch:[50,74],bunchkaufman:74,bundl:58,bunny:59,bus:59,busi:53,busstop:59,bust:59,bust_in_silhouett:59,busts:59,busts_in_silhouett:59,button:59,bypass:8,bytes2hex:76,c11:26,c153:74,c169:74,c1cb1c1:50,c394:74,c410:74,c_char_p:33,c_func:83,c_null:[26,67],cableway:59,cach:[6,8,12,21,26,45,47,50,51,52,64,71,75,77],cache_method:8,cachingpool:77,cactu:59,cactus:59,cake:59,calcul:[5,19,29,31,33,39,45,51,52,66,74,75,77,85],calendar:[31,59,68],calendr:31,call1:52,call_array3:52,call_dist:26,callabl:[4,8,28,33,39,46,65,73,77],calle:[26,28,29],caller:[4,12,15,18,26,29,35,45,49,51,52],calloc:72,callstack:55,came:1,camel:[57,59,60],camera:59,camp:[30,58],can:[1,2,5,6,7,8,11,12,13,14,15,17,18,19,20,21,22,25,26,27,28,29,30,31,32,33],cancel:[40,75],cancellation:59,cancer:59,candi:59,candid:[15,21,28,35,46,56,58],candra:59,candrabindu:59,candy:59,canin:85,cannot:[3,7,19,26,28,29,30,32,34,35,39,42,45,46,47,49,50,51,52,54,56,58,61,64,65,66,71,72,74,75,77,81],canon:[8,48,64,68,71,75,84],canonic:[68,69,84],cap:[52,59],capabl:[7,16,42,45,49,51,71,77],capac:66,capdot:59,capit:[39,48,57,60],capital:59,capital_abcd:59,capricorn:59,capricornu:59,captur:[1,8,45,47,51,53,54,56,77,84],capturedexcept:77,capwedg:59,car:[52,59],card:59,card_index:59,cardinal:59,cards:59,care:10,carefulli:[25,30,54],caret:59,carlo:51,caron:59,carousel:59,carousel_hors:59,carp:59,carri:[25,49,51,53],carriag:56,carriagereturn:59,cars:59,cartesianindex:[3,19,25],cartesianindex_2:25,cartesianrang:63,casefold:84,casino:31,cast:[26,33,39,46],castle:59,casual:42,cat2:59,cat:[18,25,50,59,63,64,85],catalan:76,catch_backtrac:[29,64],catch_block:1,catch_stacktrac:[55,83],catdoc:32,categori:[30,44,60,84],caught:[1,6,15],caus:[6,8,12,15,25,26,29,34,35,44,45,47,51,52,53,54,58,64,65,75,77,84,85],caution:[52,57,59,64],cbind:49,cbrt:[25,44,59,75],ccall:[6,7,9,11,18,21],cchar:[26,65],cconvert:[26,65],cdecl:26,cdll:33,cdot:59,cdotp:59,cdoubl:[26,65],cedilla:59,ceil:[25,31,44,50,52,57,68,75,85],ceiling:59,celebration:59,cell:[32,49],center:[8,32],centered:59,central:[43,46],centred:59,cenv_t:21,ceremony:59,certain:3,certainli:[8,54],cetera:75,cflag:33,cflags:[22,33],cfloat:[26,65],cfunc:77,cglobal:[26,65],cgutil:11,chain:[1,3,29,37],chang:[3,11,15,25,26,28,29,31,33,34,39,40,44,45,46,47,48,49],change_arrai:34,change_valu:34,changedfil:50,channel_from_id:77,chapter:[28,45,64],charact:[1,26,31,32,34,40,45,48,49,50,54],character:[26,59],characterist:[34,39,43,51,52],charg:29,chart:59,chart_with_downwards_trend:59,chart_with_upwards_trend:59,charwidth:84,cheatsheet:36,check:1,checkbound:[3,15,63],checkbounds_indic:3,checkbounds_log:3,checked_ab:75,checked_add:75,checked_cld:75,checked_div:75,checked_fld:75,checked_lib:47,checked_mod:75,checked_mul:75,checked_neg:75,checked_rem:75,checked_sub:75,checker:22,checkered_flag:59,checkindex:[3,15,63],checkmark:59,checksquar:63,cheering:59,chequered:59,cherri:59,cherries:59,cherry:59,cherry_blossom:59,chestnut:59,chi:59,chick:59,chicken:59,child:[33,53,54,55,58,64,85],children:[22,54,58,59],children_cross:59,chime:59,chines:56,chmod:69,chocolate:59,chocolate_bar:59,choic:[29,34,46,51,52,53,58,59,74,75,78,79,84],chol:74,choleski:[43,74],choleskypivot:[43,74],cholfact:74,cholmod:74,chomp:[54,71,84],choos:[34,46,50,51,53,57,58,63,71,75,82],chop:84,chosen:[25,29,31,35,47,51,52,66,74,75,77,82],chown:69,chr2ind:[56,84],christmas:59,christmas_tre:59,chunk:[7,26,51,58],church:59,cinema:59,cint:[21,26,65],cintmax_t:[26,65],circ:59,circeq:59,circl:8,circle:59,circlearrowleft:59,circlearrowright:59,circled:59,circledast:59,circledbullet:59,circledcirc:59,circleddash:59,circledequ:59,circledparallel:59,circledr:59,circledrightdot:59,circleds:59,circledstar:59,circledtwodot:59,circledwhitebullet:59,circlellquad:59,circlelrquad:59,circleonleftarrow:59,circleonrightarrow:59,circletophalfblack:59,circleulquad:59,circleurquad:59,circleurquadblack:59,circlevertfil:59,circshift:63,circular:[12,59],circularli:63,circulation:59,circumflex:59,circumst:[3,13,14,29,52],circumv:[6,50,52],circus:59,circus_t:59,cirfnint:59,city_sunris:59,city_sunset:59,cityscape:59,cjk:[36,59,60],claim:59,clamp:75,clang:[17,26,33,52],clap:59,clapper:59,clapping:59,clarifi:[52,57],clariti:[29,50],clark:46,clarke61:46,clash:45,classic:[26,31,35,54,58],classifi:[45,84],claus:1,cld:[44,52,75],clean:[7,9,29,31,50,61,64],cleaner:[39,57],cleanli:28,cleanup:[26,33,47,51,77],clear:[1,6,15,19,28,31,32,34,40,47,50,51],clear_malloc_data:[53,79],clearer:[32,39,53,58],clearest:49,clearli:[26,29,34,35,45,47,58],clever:[30,34,46],cleverest:34,clib:77,click:[36,40,50,59],client:[9,48,51,53,55,64,71],clientsid:48,clinking:59,clipboard:[59,64],clock1030:59,clock10:59,clock1130:59,clock11:59,clock1230:59,clock12:59,clock130:59,clock1:59,clock230:59,clock2:59,clock330:59,clock3:59,clock430:59,clock4:59,clock530:59,clock5:59,clock630:59,clock6:59,clock730:59,clock7:59,clock830:59,clock8:59,clock930:59,clock9:59,clock:[26,59,68],clockoint:59,clockwise:59,clonabl:50,clone:[49,50,78],clong:[26,65],clonglong:[26,65],close:[1,7,21,29,35,48,50,51,53,56,58,64,71,73,74,77],closed:59,closed_book:59,closed_lock_with_kei:59,closed_umbrella:59,closedvarcap:59,closedvarcup:59,closedvarcupsmashprod:59,closer:[16,34,49,74],closest:[21,28,35,46,56,58,64,74],closet:59,closing:59,clothes:59,cloud:[51,59],clover:59,club:59,clubsuit:59,cluster_cooki:[51,77],clutter:32,clwintegr:59,cmd:[1,45,51,54,64],cmd_gen:45,cmp:[34,75,77],cmpxchg:77,coalesc:26,coarser:68,coaster:59,cocktail:59,code_llvm:[16,52,64],code_llvm_raw:64,code_low:[16,52,64],code_n:[16,34,52,64,81],code_typ:[16,52,64],code_warntyp:16,codegen:[6,7,11,12],codepoint:84,coeff:46,coeffici:27,coexist:15,coffe:59,coffman:12,coin:51,col:[52,53,63],cold:59,cold_sweat:59,coll:[66,76],collabor:50,collect:[2,11,21,23,25],collection2:66,collector:[6,7],collid:50,collision:59,colon:[15,19,25,35,40,52,59,63,75],coloneq:59,color:[8,35,36],colptr:[25,64],column:15,columnwis:74,com:[48,50,74],combin:[7,8,19,27,28,29,30,33],combinatori:52,combining:59,come:[5,7,28,29,30,39,40,41,45,49,50,51,52,53,56,61,82],comfort:[34,50],comma:[25,26,45,58,59,61,71],commaminu:59,command:[6,7,9,11,20,22],comment:[11,14,21,28,45,49,50,56,68,71,80,84],comment_char:71,commit:[2,36,40,50,71,74],committe:51,commmon:58,common:[2,14,26,27,28,29,30,34,35,39,40,41,44,45,46,47,48,49,50,51,52,53,54],commonli:[1,14,25,39,51,56,58,66],commun:[50,51],compact:[5,35,42,43,58,71,74,84],compactli:[58,71,74],compar:[3,14,21,25,26,29,30,31,35,42,44,45,50,51,52,56,57,58,64,66,71,75,77,82],comparison:[1,3,25,26,27,29],compat:16,compens:63,compil:[1,2,3,6,7],compilecach:[36,47,64],complain:50,complement:[39,59,75],complementari:[44,75],complet:[6,14,18,25,26,28,30,32,34,35,36],complete_m:28,complex128:[26,74,76],complex64:[26,74,76],complex:[1,7,8,21,23,25,26],complic:[8,19,29,33,41,45,47,50,52,54],compon:[65,66,69,74,75,78,80],componentwis:74,compos:[7,32,56,84],composit:[26,27,28,46,47],composite_typ:8,compositeexcept:[29,77],compoundperiod:68,compq:74,comprehens:1,compress:[1,6],compris:[51,56],comput:[5,7,15,19,21,23,25,26,28,29,30,32,33,34,35,36,38,39,40,41,42,43,44,45,47,49,50],compute_dot:26,computer:59,conceiv:[21,52],concept:[43,46,57,58,61],conceptu:[8,46,56,58],concern:[8,34,45,61],concis:[29,35,52,57,64],conclud:[53,57],conclus:50,concret:[16,19,21,25,28,46,51,52,56,57,58,64],cond:[26,29,49,64,74],condit:1,condition:37,conditionexpr:5,condskeel:74,confetti:59,confetti_bal:59,confid:53,configur:[9,33,40,50,51],confirm:[58,69],conflict:[12,21],confound:59,confounded:59,confus:[30,31,34,47,49,50,53,56],confused:59,cong:59,congdot:59,congratul:[2,59],congratulation:59,congruent:[44,59],conical:59,conictap:59,conj:[27,63,75],conjquant:59,conjug:[49,63,74,75],conjugate:59,conjunct:[35,40,62,63],connect:[29,36,48,50,51,54,56,58,71,77],connect_at:51,connect_id:[51,77],connector:60,conqueq:74,conquer:74,conscious:30,consecut:[1,35,65,71],consecutive:59,consequ:[3,8,15,19,21,34,45,50,51,52,53,58,77],conserv:[50,52],consid:[3,5,8,13,15,19,21,22,26,28,29,30,31,33,34,35,41,44,45,47,48,49,50,51,52,53,56,57,58,61,64,65,68,71,74,77,82],consider:15,consist:[1,8,14,28,32,35,46,50],consol:[40,53,64],constant:[1,7,9,18,23,25],constantli:77,constitut:[21,51],constrain:[21,28,35],constraint:[21,28,46,74],construct:[1,5,6,12,14,19,21],construction:59,construction_work:59,consult:50,consum:[19,29,34,53,54,64,77],consumpt:64,contain:[1,2,3,5,7,8,9,13,14,18,19,20,21,25,26,28,29,31,32,33,35,41,45,47,49,50,51],containing:59,contains:59,contend:77,content:[6,9,20,26,28,32,33,34,45,47,48,50,54,62,64,69,71,75,77,78],context:[3,14,26,28,29,31,33,34,45,47,49,50,51,52,55,58,60,64,71,77,80,83,85],contigu:[19,52,58,84],continu:[1,9,15,21,28,29,30,31,42,46,48,49,52,53,56,68,74,77,85],contour:59,contrast:[21,25,26,34,35,45,49,50,51,52,53,58,61],contravari:58,contrib:[2,22],contribut:[2,22,34,50],contributor:50,contriv:[29,45,52,56],control:[1,7,23,25,26],conv2:75,conv:75,convei:[34,42,61],conveni:[5,13,15,16,19,21,25,27,28,29,30,31,33,35,44,45,46,48,49,50,51,52,56,57,58,61,63,66,68,69,71,74,77,83],convenience:59,convenience_stor:59,convention:15,converg:74,convers:[3,23,25],convert:[1,6,7,8,14,19,25,26,27,28,30,31,32],convolut:75,cook:[9,39,44],cooked:59,cookie:59,cooking:59,cool:59,cooper:[29,48,51],coordin:[8,19,29,44,58,75],cop:59,copi:[1,25,26,33,35,45,47,50,51,52,53,57,58,62,63,64,65,66,69,71,74,76,77,79,82,84],coprod:59,coproduct:59,copy_col:52,copy_col_row:52,copy_row:52,copy_row_col:52,copyast:[1,45],copyright:59,copysign:[8,25,44,75],cor:75,core2:20,core:[1,2,7,8,9,16,19,21,28],corn:59,corner:[50,59],corners:59,corpu:2,correct:[8,26,28,34,39,45,52,58,65,71,75,85],correctli:[19,25,26,30,32,44,47,50,56,72,85],correl:75,correspond:[1,6,8,14,18,19,21],corresponds:59,corrupt:[14,52,56,65],cosc:[25,44,75],cosd:[25,44,75],cosec:75,cosh:[25,44,75],cosin:[74,75],cospi:[25,44,75],cost:[17,34,39,45,53,62,75,82],cot:[25,44,75],cotang:75,cotd:[25,44,75],coth:[25,44,75],could:[8,12,15,19,25,26,28,29,30,31,32,34,35,36,39,40,41,44,45,46,47,48,51,52,53,56,57,58,64,68,71,83,85],count:[25,26,29,31,34,36,41,46,50,51,53,63,66,71,77,79,85],count_head:51,count_on:76,count_zero:76,counter:[11,34,47,53,61,64,66,77],counterintuit:[15,58],counterpart:[25,49,63],counterproduct:52,countfrom:66,countlin:71,countnz:[25,63],coupl:[15,51,52,59],couple:59,couple_with_heart:59,couplekiss:59,cours:[12,28,32,34,35,45,47,50,51,52,53,54,56,58,62],cousin:52,cov:[74,75],covari:[21,26,58,75],cover:[14,32,45,46,51,56,59,74],coverag:[36,53,78],cow2:59,cow:59,cplex:50,cpp:[6,7,11,26],cptrdiff_t:[26,65],cpu:[2,19,20,29,36,51,52,67],cpu_cores:[67,75,77,85],cpu_target:20,crack:28,cracker:59,crash:0,crazi:52,cream:59,creat:[1,2,5,7],creation:[7,14,28,35,69,75],credenti:51,credit:59,credit_card:59,crescent:59,crescent_moon:59,criterion:[31,74],critic:[3,8,16,26,51,52,74,77],crlf:[56,84],crocodil:59,crocodile:59,cross:[7,18,56,59,74,75],crossed:59,crossed_flag:59,crosshatch:59,crossing:59,crown:59,crucial:[22,34,42],cruft:50,cry:59,crying:59,crying_cat_fac:59,crystal:59,crystal_bal:59,cscd:[25,44,75],csch:[25,44,75],cshort:[26,65],csize_t:[26,65],cssize_t:[26,65],cstring:26,cstyle:6,csub:59,csube:59,csup:59,csupe:59,csv:[54,77],ct_eval_cal:53,ctime:[64,69],ctranspos:[35,74],ctrl:[32,64,65,77],cubatur:75,cube:[44,59],cuchar:[26,65],cuint:[26,65],cuintmax_t:[26,65],culong:[26,65],culonglong:[26,65],cumbersom:[48,56],cummax:63,cummin:63,cumprod:63,cumsum:63,cumsum_kbn:63,cumul:[53,63],cup:59,cupdot:59,cupid:59,cupve:59,curat:50,curiou:30,curl:[59,69],curled:59,curli:[1,58],curly:59,curly_loop:59,curlyeqprec:59,curlyeqsucc:59,curlyve:59,curlywedg:59,currenc:60,currency:59,currency_exchang:59,current:[1,5,6,7,8,9,11,20,21,22,25,26,29,33,34,36,41,46,47,48,49,50,51,52,53,54,55,56,58,59,61,64,65,66,67,68,69,71,72,73,74,75,76,77,78,79,82,83,84,85],current_modul:[9,26,47,64],current_task:[12,29,77],curri:59,curry:59,cursor:[32,40],curv:52,curve:59,curvearrowleft:59,curvearrowright:59,curving:59,cushort:[26,65],custard:59,custom:[3,10,11],customari:58,customary_phras:60,customize_color:40,customize_kei:40,customs:59,customtestset:85,customunitrang:15,cut:54,cwchar_t:[26,65,84],cwd:48,cwstring:26,cxx:[17,26],cxxflags:33,cyan:[40,71],cycl:66,cyclic:63,cyclon:59,cyclone:59,cyril:56,d7ff:56,dagger:59,dai:[31,36,40,68],daili:42,dalet:59,daleth:59,damag:[52,54],dan:34,dancer:59,dango:59,dark:59,darrai:51,dart:59,darwin13:[36,40],darwin:64,dash:[50,59],dashed:59,dashleftharpoondown:59,dashrightharpoondown:59,dashv:59,data:[1,3,6,7,11],data_cel:71,dataarrai:75,databas:31,dataflow:8,datafram:[49,50],datarootdir:[20,33],datatyp:[8,15,16,33,40,47,58,64],datatype_modul:64,date2epochdai:68,date:[2,23],date_str:31,dateformat:[31,68],datefunct:31,datetim:23,datetime2epochm:68,datetime2julian:68,datetime2rata:68,datetime2unix:68,david:39,dawson:[25,39,44,75],dayabbr:68,daylight:31,daynam:[31,68],dayofmonth:68,dayofquart:[31,68],dayofweek:[31,68],dayofweekofmonth:[31,68],dayofyear:[31,68],daysinmonth:[31,68],daysinyear:68,daysofweekinmonth:68,dbg:[16,64],dbkarow:59,dblarrowupdown:59,dct:75,ddagger:59,ddddot:59,dddot:59,ddot:59,ddot_:26,ddotseq:59,ddownarrow:59,ddthh:68,de77ee4dc0689b12c5e8b574aef7f70e8b311b0:50,dead:[12,64],deadlock:12,dealloc:26,dealt:31,debug_bootstrap:2,debugg:[6,21],debuginfo:[7,11],dec:[68,76],decad:42,decemb:68,decid:[7,28,35,50,51,52,53,57,58],deciduous:59,deciduous_tre:59,decim:[49,75,76],decis:[19,52,58],declar:[1,3,4,8,12,14,16,21,26,28,29,30],decod:71,decompos:84,decomposit:[25,43,74,84],deconv:75,decor:[32,71],decoration:59,decorative:59,decoupl:46,decreas:[52,53,71],decrement:77,dedent:56,dedic:[15,17,30,40,45],deem:[27,34,46],deep:64,deepcopi:[25,64],deepcopy_intern:64,deeper:[3,53],deepli:[15,29,34,45,53,58],deeply:59,def:[12,21],defalg:82,default_handl:85,default_meta:78,default_retry_max_delay:77,default_retry_on:77,default_sysimg_path:20,default_val:52,default_worker_pool:77,defaultclustermanag:77,defaulttestset:85,defaut:85,defeat:34,defer:71,defici:74,defin:[1,3,6,7,8,9,12,13,14,15,16,17,18,19,21,25,26,27,28,29],definit:1,definition:59,deflat:74,deg2rad:75,degeneraci:74,degrad:34,degre:[28,30,44,59,63,75],degree:59,del:59,delai:[35,53,64,79],delayed:59,deleg:[28,30,46,51,78],delet:6,deleteat:66,deliber:34,delicious:59,delim:[71,84],delimit:[31,32,36,47,49,56,68,71,80,84],delimiter:59,deliv:[65,77],deliveri:17,delivery:59,delta:[50,59,60],demand:[7,14,25,29,58],demonstr:[35,37,45,47,50,51,58],den:[8,27,28,30,58,75],denomin:[25,27,28,30,58,64,75],denorm:[52,76],denot:[34,49,58,85],densearrai:[21,25,40],densest:39,densiti:[25,63],dep:[2,11,78],department:[51,59],department_stor:59,departur:42,depend:[7,14,15,19,21,25,26,29,31,32,34,35,39,45,46,47,48,49,50,51,52,55,56,58,63,64,66,71,73,74,75,77,78,79,80],deploi:42,depth:[8,16,39,78,79],depwarn:36,dereferenc:49,deregist:[51,77],deriv:[25,44,52,64,74,75],desc:85,descend:58,describ:[5,6,7,8,15,17,19,21,22,26,27,28,29,32,33,34,35,39,40,41,42,47,50,51,53,56,58,61,67,71,74,75,77],descript:[9,25,26,32,39,41,44],descriptor:[54,69,71,77],deseri:[7,64,71,77],deserialis:9,deserv:28,design:[3,4,8,15],desir:[7,29,31,47,51,52,53,57,64,69,74,75],desk:59,despit:[21,34,46,53,58],dest:[15,63,65,69,74],destin:[25,64,65,66],destroi:[33,34,74],destruct:66,destructor:26,destructur:[35,56],det:[43,74],detach:64,detail:[7,14,15,16],detect:[17,21,22,34,53,61,71],detect_leak:17,determin:[2,6,7,19,25,26,28,29,30],determinist:[6,45,54],dev:[18,36,40,50,64],devector:[42,49],deviat:[75,76],devic:[47,52,64,69,71],devnul:[64,71],devot:7,dezh:59,dft:75,dht:75,diacrit:[60,84],diaeresis:59,diag:[49,74],diagdown:59,diagind:74,diagm:[49,74],diagnos:52,diagnost:[11,29],diagon:[43,49,58,63,74],diagonal:59,diagpoint:58,diagup:59,diamet:59,diameter:59,diamond:59,diamond_shape_with_a_dot_insid:59,diamondbotblack:59,diamondleftarrow:59,diamondleftarrowbar:59,diamondleftblack:59,diamondrightblack:59,diamondsuit:59,diamondtopblack:59,diassembl:11,dicei:59,diceii:59,diceiii:59,diceiv:59,dicev:59,dicevi:59,dict:[31,40,41,47,49,50,51,63,64,66,71,77,78,79],dictat:[30,58],dictchannel:51,dictionari:[32,35,40,47,50,51,52,57,63,64,66,71,77,78,79],did:[13,20,45,48,51,52,54,64,85],didn:[34,48,57],die:[31,59,68],diff:[19,50,63],differ:[1,8],difference:59,differenti:[58,75],differential:59,difficult:[31,34,35,52,57,58,61],difficulti:[28,34,58],dig:21,digamma:[25,44,59,75],digest:52,digit:[1,7,39,49,56,59,60,68,71,75,76,84],digraph:59,dim:[5,14,15,25,26,32,33,41,45,51,63,65,66,71,75,76,77,82],dimanch:31,dimens:[3,5,15,19,25,32,33,41,44,45,49,51,52,58,63,65,66,71,74,75,76,80,82],dimension:[15,19,23],dimensional:59,dimensionmismatch:[15,64],diminish:42,dingasterisk:59,dir:[36,50,64,69,77,78],direct:[2,16,20,25,26,27,29,45,47,50,58,59,74],directindexstr:40,directli:[1,7,8,11,14,18,19,25,26,27,28,29,30,32,33,39,41,42,45,47,50,51,52,53,54,57,63,64,71,74,78,82,85],directly:59,directori:[2,6,7,11,22,33,47,49,50,53,62,64,67,69,71,77,78],dirichlet:[44,75],dirnam:69,disabl:[1,12,22,33,36,47,52,64,65,71],disable_sigint:65,disadvantag:62,disallow:[36,60],disambigu:[46,56,57,79],disappear:[47,52],disappoint:59,disappointed:59,disappointed_reliev:59,disasm:11,disastr:19,disc:59,discard:[3,50,64],disclaim:45,disconnect:48,discontinu:75,discourag:[49,60,77],discov:[6,15,26,40],discret:[31,68,75],discuss:[16,19,21,29,30,32,35,39,45,46,48,50,52,53,56,58,64],disin:59,disjoint:51,disjquant:59,disk:[2,48,59,71,77],dispar:46,dispatch:[1,4,7,8,16,19,21,26,28,30,35,42,45,46,49],display:71,displays:71,dispos:51,disregard:47,disrupt:57,dist:26,distanc:[25,27,39,63,64],distinct:[1,4,15,21,28,29,31,34,41,45,46,47,51,56,58,61,66,75,84],distinguish:[8,21,31,44,45,49,51,64,82],distr:1,distribut:[2,7,22,25,33,34,42,49,50],div:[19,25,28,30,31,32,39,44,52,59,75],diverg:[50,75],divid:[28,30,31,32,39,44,51,57,74,75],divide:59,divideerror:[29,39,64],divideontim:59,divides:59,divis:[27,28,30,31],division:59,divisor:[28,44,75],divrem:[44,75],dizzi:59,dizzy:59,dizzy_fac:59,dl_load_path:[67,73],dlclose:73,dlext:73,dll:[20,73],dlopen:[26,73],dlopen_:73,dlsym:[26,65,73],dlsym_:73,dmemdebug2:22,dmemdebug:22,dns:71,do_cal:[9,55],do_comput:54,do_not_litt:59,do_quadgk:8,do_test:85,do_work:54,doc:[1,32,36,40,51,75,84],doc_str:32,docil:32,dockerenv:40,dockerinit:40,docstr:[3,32],docsystem:32,doctest:32,document:[5,8],doe:[1,8,9,12,15,19,21,22,25,26,27,28,29,30,31,32,33],does:59,doesn:[6,12,15,19,26,28,30,34,39,45,49,50,52,53,56,57,58,61,64,74,83],dog2:59,dog:[59,85],doi:74,doll:59,dollar:59,dolls:59,dolphin:59,domain:[42,48,49,50,51,52,63,64,71],domainerror:[26,27,29],domin:52,don:[8,15,19,25,26,28,31,34,45,50,52,54],done:[9,26,28,29,31,32,33,34,39,41,45,46,47,48,49,50,51,52,54,57,61,63,64,66,71,74,78],door:59,dot:[25,26],dotc:74,doteq:59,dotequiv:59,doth:64,dotless:59,dotminu:59,dotplu:59,dots:59,dotsim:59,dotsminusdot:59,dotted:59,dottedcircl:59,dottedsquar:59,dottim:59,dotu:74,doubl:[25,26,32,33,36,39,40,45,50,54,56,57,64,65,71,74],doublebarve:59,doubleplu:59,doubt:15,doughnut:59,dow:68,down:[2,8,9,29,31,34,40,53,55,59,66,69,72,77],downarrow:59,downarrowbar:59,downarrowuparrow:59,downdasharrow:59,downdat:74,downdownarrow:59,downharpoonleft:59,downharpoonright:59,downharpoonsleftright:59,downleftrightvector:59,downleftteevector:59,downleftvectorbar:59,download:[34,36,50,69],downrightteevector:59,downrightvectorbar:59,downsid:52,downwards:59,downwhitearrow:59,downzigzagarrow:59,dozen:[34,46],drafting:59,draftingarrow:59,dragon:59,dragon_fac:59,dramat:[19,51],draw:8,drawback:[34,58],drawings:59,drawn:75,drbkarrow:59,dress:59,drill:9,drink:59,drive:[51,69],driver:[51,63,77],droang:59,dromedary:59,dromedary_camel:59,drop:[19,25,63,66,69],droplet:59,drops:59,dropzero:63,dsfmt:53,dsfmt_gv_fill_array_close_open:53,dsol:59,dst:69,dt2:31,dth:68,dtruss:2,du2:74,dual:71,dualmap:59,duck:57,due:[2,8,12,26,29,34,40,50,51,52,53,54,57,64,68,85],dumbsum3:53,dumbsum:53,dummi:58,dummymodul:51,dump:[6,7,8,9,11,16,18,21,31,45,53,71],dup:74,duplic:63,dusk:59,dvd:59,dylib:[20,33,73],dynam:[1,7,8,11,23,26,30,32,33,35,40,42,45,46,47,49,51,52,56,58,64,70,71],dynamic_arch:2,e000:56,e10:39,each:[1,5,6,7,8,9,11,12,14,15,16,18,19,21,25,26,28,29,31,32,33,34,35,36,37,39,40,41,44,45,46,47,49,50,51,52,53,54,55,56,58,61,63,64,65,66,68,71,74,75,77,78,79,82,84,85],eachindex:[25,63],eachlin:[48,66,71],eachmatch:84,eagerli:49,ear:59,ear_of_ric:59,earli:[2,7,9,15,29],earlier:[6,15,28,50,52,77],ears:59,earth:[31,59,68],earth_africa:59,earth_america:59,earth_asia:59,eas:[42,55],easi:[8,17,19,21,25,26,29,32,35,39,40,42,45,50,51,55,57,58,64],easier:[5,29,35,37,47,48,49,50,51,57,58,66],easiest:[6,8,21,29,36,45,50],easili:[1,19,27,28,29,30,32,34,39,41,42,45,46,50,52,54,56,58,82],east:59,eax:34,ec2:51,echo:[18,36,40,45,48,50,54,64],ecosystem:[14,15,52],edg:[45,75,77],edge:77,edit:[16,32,50,60,64,78],edit_move_up:40,edite:40,editor:[50,56],ef45f54b:50,effect:[1,6,8,19,25,26,28,29,32,34,35,39,44],effici:7,efficient:42,effortless:27,egal:[14,64],egg:59,eggplant:59,egsdot:59,eiffel:58,eig:[43,74],eigen:[43,74],eigendecomposit:74,eigensolv:74,eigensystem:74,eigenvalu:74,eigenvector:74,eigfact:74,eight:[56,58,59],eight_pointed_black_star:59,eight_spoked_asterisk:59,eighteen:59,eighth:59,eighthnot:59,eigmax:[43,74],eigmin:[43,74],eigval:[43,74],eigvalu:74,eigvec:[43,74],eip:6,either:[1,3,5,11,15,21,22,25,26,28,29,30,31,32,34,35,36,41,44,45,46,49,50,52,56,57,58,61,63,64,65,69,71,74,75,77,84,85],elaps:[45,52,64,71],electric:59,electric_plug:59,electrical:59,eleg:39,elegant:42,element:[1,5,8,16,19,21,25,26,28,29,31],element_typ:[25,63,66],elementari:[23,27,29,30,38],elementwis:[25,35,44,66,75,77,80],eleph:59,elephant:59,eleven:59,elid:3,elig:61,elimin:[3,7,26,34,42,51,52,64],elint:59,ell:59,ellips:45,ellipse:59,ellipsi:35,ellipsis:59,elor:59,elroang:59,els:[1,5,7,8,9,22,28,29,30,34,35,37,42,44,45,46,47,50,51,52,56,58,60,71],elsdot:59,elseexpr:5,elseif:[1,5,19,29,35,37,52],elsewher:[32,63,71,75],eltyp:[3,8,25,26,41,52,63,66,74,76],eltypeunknown:[41,66],elzand:59,elzbar:59,elzbtdl:59,elzcirfb:59,elzcirfl:59,elzcirfr:59,elzclomeg:59,elzddfnc:59,elzdefa:59,elzdlcorn:59,elzdshfnc:59,elzdyogh:59,elzesh:59,elzfhr:59,elzglst:59,elzhlmrk:59,elzinglst:59,elzinvv:59,elzinvw:59,elzlap:59,elzlmrk:59,elzlow:59,elzlpargt:59,elzltlmr:59,elzltln:59,elzminhat:59,elzopeno:59,elzor:59,elzpalh:59,elzpbgam:59,elzpe:59,elzpgamma:59,elzpscrv:59,elzpupsil:59,elzrai:59,elzrarrx:59,elzreapo:59,elzreglst:59,elzrh:59,elzrl:59,elzrlarr:59,elzrtl:59,elzrtld:59,elzrtll:59,elzrtln:59,elzrtlr:59,elzrtlt:59,elzrtlz:59,elzrttrnr:59,elzrvbull:59,elzsbbrg:59,elzsblhr:59,elzsbrhr:59,elzschwa:59,elzsqfl:59,elzsqfnw:59,elzsqfr:59,elzsqfse:59,elzsqspne:59,elztdcol:59,elztesh:59,elztime:59,elztrna:59,elztrnh:59,elztrnm:59,elztrnmlr:59,elztrnr:59,elztrnrl:59,elztrnsa:59,elztrnt:59,elztrny:59,elzvert:59,elzverti:59,elzvrecto:59,elzxh:59,elzxl:59,elzxrat:59,elzyogh:59,email:[50,59],embed:[14,20,23,26],embed_exampl:33,emblem:59,emdash:59,emerg:30,emiss:7,emit:[3,7,34,36,47,52],emit_cal:6,emit_expr:[6,7],emit_funct:[6,7],emit_intrins:9,emit_known_cal:7,emoji:59,emphas:[45,57,64,77],emphasis:32,empiric:8,emploi:[5,21,74],empti:[8,13,21,25,34,36,40,45,46,48,51,56,58,63,64,66,67,69,73,74,77,80,82,84],empty:[25,32],emptyfunc:46,emptyset:59,emptysetoarr:59,emptysetoarrl:59,emptysetobar:59,emptysetocirc:59,emul:[54,77],enabl:[4,7,11,12,15,17,22,32,33,36,41,47,50,51,52,58,63,64,65,71,83,84],enable_broadcast:71,enc:53,encapsul:26,enclos:[1,25,32,45,47,49,61,64,71,77],enclosecircl:59,enclosediamond:59,enclosesquar:59,enclosetriangl:59,enclosing:59,encod:[19,56,60,71,75,76,84],encompass:61,encount:[2,7,8,35,39,45,47,50,56,58,69],encourag:[15,49,50,54,85],encrypt:51,end:[1,2,3,5,7,8,12,13,15,16,19,21,25,26,28,29,30,31,32,34,35,36,37,39,40,41,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,69,71,74,75,76,77,80,81,84,85],endash:59,ended:59,endian:71,endian_bom:[67,71],ending:59,endof:[35,40,41,56,57,66,84],endors:50,endpoint:75,endswith:84,enforc:[15,28,52,84],eng:59,engin:[39,50],engine:59,english:[31,56,68],enhanc:[39,50,62],enorm:[52,58],enough:[8,11,25,28,30,34,39,42,45,51,52,53,63,64,68,71],enqueu:66,enspac:59,ensur:[3,12,15,18,19,25,26,27,28,32,34,35,44,45,47,50,51,52,57,58,65,71,77,78,85],entail:[31,39,51],enter:[1,2,12,21,32,35,36,39,40,46,48,53,56,60,69],enthusiasm:52,entir:[1,7,19,21,22,25,28,29,32,34,45,48,50,51,53,55,56,58,71,74,75,77,80],entireti:71,entiti:21,entri:[1,8,19,21,25,29,40,44,49,50,58,63,66,69,74,75,77,78],entropi:76,entry:59,enumer:[8,34,49,52,57,64,66],enumnam:64,enumvalue1:64,enumvalue2:64,env:[21,26,40,64,67,78],envcolor:40,envelope:59,envelope_with_arrow:59,envhash:[64,66],eof:[48,71],eoferror:[29,64],eol:71,eparsl:59,ephemer:52,epochdays2d:68,epochms2datetim:68,epsilon:30,eq_float:52,eqc:21,eqcirc:59,eqcolon:59,eqdef:59,eqdot:59,eqeqeq:59,eqgtr:59,eqless:59,eqqgtr:59,eqqless:59,eqqplu:59,eqqsim:59,eqqslantgtr:59,eqqslantless:59,eqsim:59,eqslantgtr:59,eqslantless:59,equ:74,equal:[19,21,26,27,29,32,39,44,45,47,49,50,51],equalleftarrow:59,equalparallel:59,equals:59,equation:32,equiangular:59,equilbr:74,equilibr:74,equiv:59,equival:[14,15,18,21,25,26,28,29,32,34,35,36,39,40,44,45,46,48,49,50,51,52,56,58,61,63,64,65,66,67,68,69,71,74,75,76,77,78,82,84],equivalent:59,equivdd:59,eqvparsl:59,era:31,erf:[25,44,75],erfc:[25,44,75],erfcinv:[25,44,75],erfcx:[25,44,75],erfi:[25,44,75],erfinv:[25,44,75],err:[26,50,54,55,64],errno:[26,64,65,72],erron:39,error:1,errorcod:26,errorexcept:[6,29,54,64],esc:[13,26,32,45,64,71],escap:[32,45,54,56,64,68,71,84],escape_str:[71,84],esh:59,esoter:7,especi:[2,3,19,25,26,28,30,35,44,50,51,52,57,58,61,75,77],especial:50,essenc:52,essenti:[15,26,28,29,33,39,45,58,74],essential:[23,52],ession:45,establish:[33,48,50,51,77],estim:[64,74,75],estimat:74,estimate:75,estimates:59,esym:5,esym_1:5,esym_2:5,esym_n:5,eta:[25,44,59,75],etc:[2,6,18,25,31,34,40,44,47,48,49,51,52,54,56,58,65,68,72,74,75,77,78],etcetera:[28,35,58],eth:59,etymolog:7,euclidean:[74,75],euler:[59,75,76],eulerconst:59,eulergamma:76,eulers:59,euro:59,europe:59,european:59,european_castl:59,european_post_offic:59,ev_in:74,eval_bodi:55,eval_user_input:[53,55],evalfil:64,evalpoli:75,evalu:[1,5,7,8,9,16,25,26,29,33,35,36,39,40,44],evaluat:1,even:[6,14,15,19,21,26,27,28,29,30,31,32,34,35,39,40,42,45,46,47,48,49,50,51,52,53,54,56,57,58,59,60,61,63,64,66,71,74,75,76,84],evenli:31,event:[6,26],eventu:[21,29,35],eventual:7,ever:[8,28,30,46,52,58],evergreen:59,evergreen_tre:59,everi:[6,8,25,26,28,30,31,32,33,34,35,39,41,42,44,45,47,48,49,51,52,56,58,63,64,66,71,74,77],everydai:29,everyth:[6,8,30,31,33,44,50,52,56,58,64,69,71],everywher:[30,34,51,53,62,77],evil:59,ex1:45,ex2:45,ex3:45,exact:[25,27,35,39,57,58,71,75,79],exactli:[4,6,21,26,32,33,35,39,45,46,49,56,58,63,64,65,66,71,74,75,76],examin:[5,6,7,19,21,32,45,47,48,52,53,54,79],exampl:[1,3,5,6,7,8,9,11,13,14,15,16,17,19,20,21,25],exce:42,exceed:[39,75],excel:[34,39,44,56],except:[1,8,12,19,20,21,25,26,27,29,30,31,33,34,35,39,43,44,45,46,49,50,52,53,54,55,56,58,63,64,66,68,71,73,74,75,77,84,85],excerpt:[32,56],excess:[8,52,54],exchang:77,exchange:59,exclam:[59,64],exclamation:59,exclud:[50,56,64,74,75],exclus:[37,44,75,77],exec:[2,54],exec_program:9,execut:[2,5,6],exeflag:[51,77],exenam:[51,77],exhaust:[36,71],exhibit:[25,28,53],exist:[1,12],existingarrai:33,exists:59,exit:[6,7,29,35,36,40,51,64,74,77],exit_cod:7,exitcod:77,exp10:75,exp2:[25,75],exp:[25,27,29,44,58,75],expand:[1,5,7,8,16,19,25,26,32,34,45,63,64,66,69,75,84],expandus:69,expans:[7,19,33,45,55],expat:50,expect:[2,8,12,13,15,25,26,27,28,29,30,31,32,34,42,45,47,48,50,52,53,56,57,58,64,71,75,76,85],expedit:50,expens:[25,41,51,53,63,74,75,77],experi:[15,29,36,39,62],experienc:2,experiment:15,expert:[42,50,63],explain:[8,28,30,50,56,57,58,61,74],explan:[29,79],explic:47,explicit:[1,15,25,26,28,30,33,34,35,39,45,46,47,49,50,51,52,56,58,61,68,77,78],explicitli:[2,12,25,26,27,28,29,30,31,35,39,42,44,46,47,49,50,51,52,53,58,60,63,64,66,74,82,85],exploit:[15,25,58,63,71,75],explor:[45,58,74],explore:62,explos:52,expm1:[25,44,75],expm:[43,74],expon:[25,44,76,80],exponenti:[39,44,49,52,64,74,75,76],expos:[7,8,34,41,48],expr1:45,expr2:45,express:1,expressionless:59,ext:54,extact:74,extend:[7,30,32,33,34,35,41,42,47,51,63,67,74,75,80,84],extens:[28,32,39,41,42,47,50,56,58,73,82,85],extent:31,extern:[2,25,26,29,32,41,47,49,50,51,54,56,64,65,67,69,71,72,75,80,84],external:[23,38,51],extra:[15,19,25,26,35,41,45,50,52,53,55,58,61,71,77,85],extra_repl_keymap:40,extract:[5,6,8,13,14,19,21,27,33,35,45,49],extraordinarili:45,extraterrestrial:59,extrem:[8,30,45,50,52,53,56,58,60,64],extrema:[66,75],extyp:85,eye:59,eyeglass:59,eyeglasses:59,eyes:59,ezh:59,f77:26,f_improv:52,face:[59,74],facepunch:59,facil:42,facilit:[5,29,35,46,51,62,77],facing:59,fact:[28,29,31,34,35,45,51,52,53,54,57,58,68,74,75],factor:[2,17,27],factori:[29,39,44,59,75],factoris:74,factory:59,faddeeva:75,fail:[2,22,26,28,29,32,34,35,45,50,51,54,56,58,64,74,77,84,85],failur:[6,34,47,50,64,72,73,77,85],fairli:[19,28,29,51,55,64],faithfulli:30,fall:[28,30,46,58,75],fallback:[8,15,25,41,47,64,71,75,85],fallen:[58,59],fallen_leaf:59,falling:59,fallingdotseq:59,fals:[1,3,6,8,16,19,20,21,25,26,27,28,29,30,31,34,39,40,44,45,46,47,49,51,52,53,55,56,58,60,61,63,64,65,66,68,69,71,74,75,76,77,78,79,82,83,84,85],falsifi:29,famili:[8,50,58,59],familiar:[31,32,45,48,49,50,56,57],family:59,fan:75,fancier:41,faq:[49,57],far:[6,15,34,35,45,46,49,52,53,58,63,64,66],farther:39,fashion:[3,44,64],fast:[4,19,25,34,35,36,42,43,50,51,52,63,75,77,78,82],fast_forward:59,fast_unwind_on_malloc:17,fastcal:26,faster:[7,19,22,34,45,50,52,57,58,63,66,75,77,82],fastest:[51,75],fastmath:[36,52],fatal:77,father:[39,59],favor:[39,49,74],favorit:50,fax:59,fdiagovnearrow:59,fdiagovrdiag:59,fdio:71,fear:59,fearful:59,featur:[1,5,7,8,15,19,26,28,29,32,36,39,40,42,43,45,46,47,52,56,58,61,76],feb:[31,68],februari:[31,68],feed:[51,54,84],feedback:50,feeder:51,feel:[48,50,58],feet:59,felin:85,femal:59,female:59,feminine:59,femtolisp:[7,9,18,22],fenc:[32,77],fence:59,ferr:74,ferris:59,ferris_wheel:59,fetch:[8,45,51,52,53,54,57,64,69,77,79],fetchfrom:77,few:[2,3,5,6,15],fewer:[1,28,34,46,71],ffast:52,ffi:7,fft:[32,49,75],fftshift:75,fftw:75,field:[1,6,7,8,14,15,16,18],fieldnam:[16,58,64],fieldoffset:[16,64],fieldptr:14,fieldtyp:[8,64],fifo:69,figur:[2,6,31,50,52],file1:[47,51],file2:[47,51],file:1,file_fold:59,filefunclin:[53,79],filemod:69,filenam:[1,7,34,48,64,71,76,77,79],filepath:69,files:69,filesystem:[23,47,64],fill:[7,8,25,26,33,41,42,51,52,53,59,63,66,71,72,74,75,76],fill_two:52,fillval:52,filt:75,filter3:52,filter:[8,25,49,52,66,75],finally_block:1,find:[2,5,11,14,21,22,25,31,34,40,42,43,45,46,47,49,50,52,53,55,56,57,58,63,66,74,75,85],find_librari:73,findfirst:63,findin:66,findlast:63,findmax:66,findmin:66,findn:[25,63],findnext:63,findnz:[25,63],findprev:63,fine:[15,22,31,35,52,58,74],finer:[51,84],finish:[21,26,28,29,30,50,51,77,85],finit:[39,44,52,56,63,64,66,75,76],finite:59,finv:59,fire:[21,59],fire_engin:59,firewal:50,firework:59,fireworks:59,first:[1,2,3,5,6,7,8,11,12,13,15,19,21,25,26,28,29,30,31,32,33,34,35,36,40,41,42,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,63,64,65,66,68,69,71,73,74,75,76,77,78,79,82,83,84,85],first_quarter_moon:59,first_quarter_moon_with_fac:59,firstdayofmonth:68,firstdayofquart:68,firstdayofweek:[31,68],firstdayofyear:68,firstlast:58,fish:59,fish_cak:59,fishey:59,fisheye:59,fishhook:59,fishing:59,fishing_pole_and_fish:59,fist:59,fisted:59,fit:[32,34,42,44,49,52,58,71],fitzpatrick:59,five:[29,32,54,59,71],fix:[8,11,12,15,31,34,39,47],fixbar:50,fixbar_backup:50,fizz:85,fkeep:63,fl_ctx:6,fl_invoke_julia_macro:7,fl_print:[6,18],flag:[1,17,22,33,34,40,47,48,51,55,56,59,69,71,73,75,77,84],flags:59,flashlight:59,flat:[53,59,79],flatness:59,flatten:[19,52],flavor:51,flavour:32,fld1:75,fld:[14,44,52,75],fldmod1:75,fldmod:[44,75],flexed:59,flexibl:[5,28,29,39,42,45,46,51,58,60,71,82],flip:[35,51,75],flipbit:63,flipdim:63,flipsign:[44,75],flisp:[6,7,12,18],float16:[16,39,46,58,76,77],float32:[6,8,15,16,21,25,26,30,39,46,49,52,58,63,64,65,74,76,81],float64:[6,8,16,19,21,25,26,28,29,30,33,34,35,39,41,44,46,49,51,52,57,58,63,64,65,66,68,74,75,76,77,79,82,85],floor:[25,31,44,50,52,57,59,68,75],floorceil:68,flop:74,floppy:59,floppy_disk:59,flow:[1,23],flower:59,flower_playing_card:59,flowing:59,fltn:59,flush:[7,48,54,59,71,72],flush_cstdio:72,flushed:59,fluttering:59,fly:[48,63],fma:75,fmt:[33,40,52,71],fname:6,focu:[1,42,58],focus:[15,21,52],foggi:59,foggy:59,foist:34,fold:[76,84],folded:59,folder:[2,17,20,33,50,51,59],foldl:66,foldr:66,follow:[1,2,5,6,7,8,12,14,15,16,18,21,22,25,26,27,28,29,30,31,32,33,34,35,36,37,39,40,43,44,45,46,47,48,49,50,51,52,53,56,57,58,60,61,62,63,64,65,66,68,71,74,75,76,77,80,81,83,84],follow_symlink:69,font:59,foo:[1,8,21,26,28,29,30,32,34,35,36,45,46,47,50,52,54,57,58,61,63,64,65,66,77,85],foo_data:47,foo_data_ptr:47,foo_init:47,foobar:[26,50,77],food:59,foomanag:51,foot:7,footbal:59,football:59,footprint:59,footprints:59,fopen:[37,71],foral:59,forbid:58,forc:[6,15,20,31,33,34,49,50,51,52,53,54,57,61,64,69,71,79],force:59,forces:59,foreach:66,foremost:19,forest:8,forev:66,forget:50,forgo:63,forgot:50,fork:[6,50,54,59],fork_and_knif:59,forking:59,forksnot:59,forkv:59,formal:[31,74],format:[18,19,25,26,30,31,32,39,40,50,53,58,68,71,72,74,75],format_str:31,formatmessag:72,former:[35,52,54,56],formerli:52,forms:59,formula:[39,41,74],forth:[29,50],fortran90:26,fortran:[15,23,25],fortun:[8,19,42,51,56],forum:51,forward:[40,50,51,52,61,66,74,76,78],forwardord:66,found:[1,8,13,14,21,25,28,29,31,32,33,34,35,40,43,47,48,49,50,52,56,58,63,71,74,77,83,84],fountain:59,four:[4,16,30,32,40,52,56,58,59,63,68,74,82,84],four_leaf_clov:59,fourier:75,fourth:[19,30,46,53,59],fourthroot:59,fpart:75,fpic:[26,33],fptosi:52,fptr:[6,8],fptrunc:6,frac:32,fraction:[44,59,75],fragment:[7,45],fraktur:59,frame:[6,9,12,33,49,55,83],free:[1,12,26,33,34,39,42],freed:[26,33,51,64,72,84],freeli:[50,58],french:[31,59],french_daysofweek:31,frequent:[9,23,29],fresh:[36,40,50,53],freshli:61,frexp:75,fri:[59,68],fricative:59,fridai:[31,68],fried:59,fried_shrimp:59,friendli:11,fries:59,frobeniu:74,frog:59,from:[1,2,3,4,5],from_c:[55,83],front:[1,8,51,52,58,59],frown:59,frowning:59,frozen:7,fruit:[49,64],frustrat:15,fs_caveat:71,fuel:59,fuelpump:59,fuji:59,full:[2,7,16,18,22,25,27,31,39,40,45,47,49,50,51,52,53,56,58,59,63,64,67,68,69,74,77],full_moon:59,full_moon_with_fac:59,fulli:[7,26,28,29,34,40,47,52,56,58,61,64,66,82],fullnam:64,fullouterjoin:59,fun:26,func10:45,func:[5,26,32,33,35,45,52,55,64,68,77,83],funcnam:79,function_modul:64,function_nam:[33,64],function_point:65,functional:59,functionloc:64,functionobject:6,functiontyp:26,functor:46,fundament:[21,28,31,58],further:[3,8,14,16,22,29,31,33,34],furthermor:[26,35,49,51,57,75],fuse:[35,52],fusion:35,fuss:31,fussi:29,fussy_sqrt:29,futur:[7,15,17,26,32,34,35,46,47,50,51,52,57,66,73,74,77,79,81],fwrite:18,gadfli:50,gain:[25,26,58],gambl:31,game:[31,59],game_di:59,gamma:[25,44,59,75],gamut:27,gap:[64,66],garbag:[6,7],garden:59,gather:52,gauss:75,gaussian:25,gbmv:74,gbsn:60,gbtr:74,gbtrf:74,gc_enabl:64,gc_perm_lock:12,gcc:[20,26,33,34],gcd:[28,44,75],gcdx:75,gdb:[0,2],gebak:74,gebal:74,gebrd:74,gecon:74,gee:74,geev:74,geevx:74,gehrd:74,gel:74,gelqf:74,gelsd:74,gelsi:74,gem:59,gemini:59,gemm:74,gemqrt:74,gemv:74,gener:[1,2,4,5],generalizedeigen:74,generalizedschur:74,generalizedsvd:[43,74],gensym:[26,45,64],geometric:59,geometrically:59,geqlf:74,geqp3:74,geqq:59,geqqslant:59,geqrf:74,geqrt3:74,geqrt:74,geqslant:59,ger:74,gerqf:74,gescc:59,gesdd:74,gesdot:59,gesdoto:59,gesdotol:59,gesl:59,gesture:59,gesv:74,gesvd:74,gesvx:74,get:[2,5,6,7,11,12,13,14,15,19,21,23,25,26,28,29,31,33,34],get_process_titl:64,get_testset:85,get_testset_depth:85,get_year:52,get_zero_subnorm:76,getaddrinfo:[48,71],getenv:26,getfield:[8,52,64],gethostnam:[26,64],getindex:[3,19,25,26,35,41,46,51,56,57,63,66,71],getipaddr:64,getkei:66,getlasterror:72,getpid:64,getr:74,getrf:74,getri:74,getsocknam:71,getstdout:47,gflop:52,gge:74,ggev:74,ggg:59,gggnest:59,gglse:74,ggsvd3:74,ggsvd:74,ghost:[4,59],ghz:52,gibbous:59,gid:[64,69],gift:59,gift_heart:59,gigabyt:34,gimel:59,girl:59,gist:2,git:[50,78],github:[2,50,74,78],gitignor:50,give:[1,16,20,25,26,27,28,31,32],given:[1,3,6,7,8,12,13,15,16,19,20,25,26,28,29,30,31,32,34,35,36,39,40,45,46,47,48,50,51,53,55,56,58,63,64,65,66,68,69,71,72,74,75,76,77,78,79,82,83,84,85],gla:59,glass:59,gle:59,glj:59,glm:49,global:[1,9],globalref:[1,52],globe:59,globe_with_meridian:59,gloss:56,glottal:59,glowing:59,glue:26,glyph:59,gmp:39,gmt:68,gnapprox:59,gneq:59,gneqq:59,gnsim:59,gnu:[2,26,33,39,73,76],goal:[49,71],goat:59,goblin:59,goe:[1,2,29,50,54,63,64],goertzel:75,goldberg:39,golden:76,golf:59,good:[6,21,28,31,32,42,47,50,51,52,53,56,59,62],goodby:[56,84],googl:48,got:[34,58,64],gotcha:[26,58],gotoifnot:1,gotonod:1,gotta:8,gperm:69,gracefulli:[7,34,56],gradient:63,gradual:58,graduation:59,grain:[58,74],grandpar:55,grant:52,grape:59,grapes:59,graph:58,graphem:84,graphic:[53,71],grave:59,great:[40,44,45,48,58],greater:[26,28,29,30,31,32,39,44,50,56,59,60,64,66,68,71,74,75,77,82,84],greatest:[26,28,44,50,58,75],greatli:[2,52],greedi:64,greedili:64,greek:[56,59],green:[40,42,59,71],green_appl:59,green_book:59,green_heart:59,greet:[36,40,56],gregorian:[31,68],grep:[54,64],grew:64,grey_exclam:59,grey_quest:59,grid:25,grimac:59,grimacing:59,grin:59,grinning:59,group:[8,11,26,31,56,64,66,69,71,84,85],groupnam:56,grow:[8,39,49,53,64,71],growing:59,grown:71,growth:74,gsime:59,gsiml:59,gsl:26,gsl_permut:26,gsl_permutation_alloc:26,gsl_permutation_fre:26,gsl_sf_bessel_jn_arrai:26,gtcc:59,gtcir:59,gtquest:59,gtrapprox:59,gtrdot:59,gtreqless:59,gtreqqless:59,gtrless:59,gtrsim:59,gtsv:74,gttr:74,gttrf:74,gua:59,guarante:[15,19,25,26,28,29,35,57,58,64,65,66,75],guard:34,guardsman:59,guess:[31,52,74],guid:[2,23],guidanc:50,guidelin:34,guillemet:59,guilsinglleft:59,guilsinglright:59,guitar:59,gun:59,gvertneqq:59,h05:74,habit:50,hacek:59,hack:[8,18],had:[47,48,50,52,53,55],hadamard:49,hair:59,haircut:59,half:[25,34,39,59,74,75,82],halfcomplex:75,halo:59,halv:75,hamburg:59,hamburger:59,hammarl:74,hammer:59,hamster:59,hand:[4,6,7,11,15,28,29,30,31,34,35,36,39,41,42,44,45,49,50,51,58,59,61,74],handbag:59,handi:[13,25,29,35,45,56],handl:[3,6,7,8,9,11,15,18,19,21,23,26],handle:59,handler:[1,8,9,18,29,36,58,65],handoff:7,hands:59,handshak:77,hankei:59,hankel:[44,75],hankelh1:[25,44,75],hankelh1x:[44,75],hankelh2:[25,44,75],hankelh2x:[44,75],happen:[1,3,19,21,29,30,31,32,33,34,35,45,48,51,52,53,54,56,57,58,63,64,74,77,85],happi:50,happy:59,har:51,hard:[5,34,36,45,50,52,60],harder:[52,57],hardest:7,hardli:30,hardwar:[39,51,52,76],harm:[26,27],harpoon:59,hartlei:75,haseltyp:[41,66],hash:[8,21,44,47,49,50,64,66],haskei:[57,66],haskel:58,haslength:[41,66],hasn:50,hasplain:28,hasshap:[41,66],hassl:50,hat:[40,59,60],hatapprox:59,hatched_chick:59,hatching:59,hatching_chick:59,have:[1,2,3,5,8,13,14,15,16,17,19,21,25,26,27,28,29,30,31,32,33,34,35,36,39,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,60,61,62,63,64,66,68,71,72,74,75,76,77,78,79,84,85],haven:[47,50,52],haystack:84,hbar:[40,59],hc2r:75,hcat:[1,25,35,49,63],hdf5:71,head:[1,8,45,59],headach:44,headed:59,header:[2,14,26],header_cel:71,headphon:59,headphone:59,heap:[33,34,47,65],heapifi:66,heappop:66,heappush:66,hear:59,hear_no_evil:59,heart:[21,59],heart_decor:59,heart_ey:59,heart_eyes_cat:59,heartbeat:59,heartpuls:59,hearts:59,heartsuit:[40,59],heatflow:52,heavi:[18,21,28,48],heavili:[19,21,32],heavy:59,heavy_check_mark:59,heavy_division_sign:59,heavy_dollar_sign:59,heavy_minus_sign:59,heavy_multiplication_x:59,heavy_plus_sign:59,hebrew:56,heeled:59,held:[12,15,28,40,51,77],helicopt:59,helicopter:59,hello:[9,18,40,45,48,52,54,56,58,60,64,84],help:[2,6,15,21,22,26,31,32,34,35,36],help_color:40,helper:[7,26],henc:[19,21,29,31,47,51,53,58,63,64,65,74],her:74,herb:59,here:[2,3,5,6,8,11,12,13,14,15,19,21,25,26,28,29,30,31,32,33,34,35,39,40,44,45,46,47,48,50,51,52,53,54,56,57,58,61,62,64,66,76,77,80,82,85],herk:74,hermaphrodit:59,hermitconjmatrix:[40,59],hermitian:[43,59,74],hessenberg:[43,74],hessenbergq:74,hessfact:74,hesv:74,heterogen:[25,71],hetr:74,hetrf:74,hetri:74,heurist:[7,8],hex2byt:76,hex2num:76,hex:[39,49,76],hexadecim:[39,49,56,76,84],hexagon:59,hexagonblack:59,hibiscu:59,hibiscus:59,hidden:[8,45,47,64,85],hide:[26,37],hierarch:[50,58],high:[17,26,29,32],high_bright:59,high_heel:59,higham:74,higher:[2,6,8,19,25,29,31,45,49,51,57,63,64,74,75,76],highest:[42,44,54,64,66],highli:[14,42,50,52,58,74,75],highlight:[16,32,39],hindi:56,hint:[1,8,13,45,48,52,71],hist:40,histori:[36,39,40,50],history_next:40,history_prev:40,hit:[2,12,36,40,50,59],hksearow:[40,59],hkswarow:[40,59],hlower:74,hocho:59,hoist:[7,52],hold:[8,12,21,26,28,30,33,41],holding:59,hole:[52,59],holidai:31,home:[2,36,40,50,51,62,69,77],homebrew:50,homedir:[69,78],homer:36,homogen:[4,26,52,81],homothetic:59,honda:52,honest:31,honey:59,honey_pot:59,honeybee:59,hood:21,hook:[9,43,59,64],hookleftarrow:[40,59],hookrightarrow:[40,59],hoop:59,hop:51,hope:5,hopefulli:[7,15,19,45],horizontal:59,horn:59,horner:75,horns:59,hors:59,horse:59,horse_rac:59,hospit:59,hospital:59,host:[17,26,33,36,48,50,51,64,71,77,78],hostnam:[26,51],hot:[41,59],hotel:59,hotspr:59,hour:[22,31,56,68,72],hourglass:59,hourglass_flowing_sand:59,hous:59,house:59,house_with_garden:59,household:74,how:[6,7,8,9,19,21,25,26,28,29,30,31,32,33],howev:[1,2,3,5,6,8,9,14,15,18,19,21,25,26,27,28,29,30,31,32,33,34,35,39,41,42,44,45,46,47,48,50,51,52,53,54,56,58,60,61,63,64,65,66,71,74,75,76,77,81,85],howmni:74,hrectangl:59,hrectangleblack:59,hslash:[40,59],hspace:[40,59],html:[32,50,58,71,74,84],html_str:84,htol:71,hton:71,http:[32,34,36,40,50,51,71,74,75,78],http_get:64,hub:50,huge:3,human:[1,31,45,55,68],hundr:52,hundred:59,hupper:74,hurt:58,hurwitz:75,hush:59,hushed:59,hvcat:[25,35,49,63],hvcat_fil:52,hwloc:67,hybrid:34,hyndman:75,hyperlink:50,hyphen:[59,84],hypot:[8,25,35,44,75],hypotenus:[35,44,75],i64:16,i686:6,i_1:[5,25],i_2:[5,25],i_3:[5,25],i_d:5,i_j:5,i_k:25,i_n:25,ia1:3,iana:31,iblock:74,iblock_in:74,ice:59,ice_cream:59,icecream:59,icon:50,idct:75,idea:[7,28,32,35,50,52,53,58,62],ideal:[34,39,57],ident:[21,25,26,27,28,32,35,43,44,45,51,52,54,56,58,61,63,64,66,71,74,75,76,77,84],identical:59,identifi:[1,14,15,26,27,32,35,39,41,45,46,47,49,50,51,52,53,56,58,60,77],ideograph:59,ideograph_advantag:59,idiom:[29,56],idiomat:[33,35,46,49,57],idl:77,idx:[51,52,84],ieee:[36,39,44,52,74,75,76],if_fals:80,if_tru:80,ifels:[52,64],iff:64,ifft:75,ifftshift:75,ifst:74,iftru:65,ignor:[1,6,36,40,45,47,50,56,64,71,73,74,75,84],ignorestatu:64,ihi:74,iid:[25,75],iii:75,iiiint:59,iiint:59,iint:59,ijulia:[32,36,58,62,71],ill:74,illus:35,illustr:[29,32,45,47,52,53,58],ilo:74,ilst:74,imag:[7,8,9,14],image_fil:[7,9],imagin:[15,31,45,50,51,52],imaginari:[27,28,44,49,74,75,76],imath:59,immedi:[8,26,28,29,34,35,36,39,44,45,46,47,51,54,56,58,64,72,77,85],immediat:[50,64],immintrin:26,immut:[7,8,19,26,28,31,32],immutabl:26,imp:59,impact:52,imper:[26,29,32,35,42,50],implement:[1,7,8,13,14],impli:[7,17,21,28,30,36,39,44,46,50,52,58,64,74],implic:58,implicit:[26,28,29,51],implicitli:[12,15,19,26,46,47,51,58,64,74],important:41,importantli:19,impos:[21,42,58,60,75],imposs:[33,34,45,52,58],imprecis:85,improp:58,improv:[3,11,20,26,33,34,50,52,53,54,58,66,74,75],imul:34,inabl:34,inadvert:58,inappropri:58,inbound:1,inbox:59,inbox_trai:59,inbuilt:51,inc:34,incant:2,incept:42,inci:[26,74],includ:[1,2,3,5,6,7,8,12,15,16,19,20,21,22,25,26,29,30,31,32,33,34,35,36,37,39,41,42,44,45,47,49,50,51,52,53,55,56,58,60,62,63,64,65,67,68,69,71,74,75,77,82,84,85],include:[2,20,32,47,84],include_depend:[47,64],include_str:64,including:59,inclus:[11,31,66,77],incom:[48,51,77],incoming:59,incoming_envelop:59,incompat:[17,47],inconsist:[26,59,64],inconveni:[30,34],incorpor:50,incorrect:[15,19,45,50,64,65,74,76],incorrectli:52,increas:[25,31,52,53,58,63,64,71,74,75,77],increases:59,increment:[31,34,36,40,47,50,59,66,68],incur:[17,39,45,52,53],incx:[26,74],ind2chr:[56,84],ind2sub:[15,19,63],ind:[15,41,45,63,66],inde:[8,19,21,35,63,66,82],indeed:[8,34,52],indefinit:74,indent:[32,45,47,53,56],indentat:[49,53],independ:[25,26,45,51,53,58,63,64,77,79,82],indetermin:26,index:[1,3,5],indexexpr:5,indexin:[57,66],indexoffset:15,indexpid:[51,77],indic:[1,2,3,10],indicat:85,indicator:59,indice:3,indices1:15,indirect:19,indirectli:25,indistinguish:[46,82],individu:[3,32,34,35,47,50,51,52,53,55,58,66,68,74,84],indmax:[63,66],indmin:66,induc:74,indxin:57,ineffici:[25,56,61],inequ:44,inertia:74,inevit:[30,54],inexact:[44,75],inexacterror:[28,29,30,44,58,64,74,75],inf16:[39,76],inf1:8,inf2:8,inf32:[39,76],inf:[27,39,44,52,74,75,76],infer:[1,6,7,8,12,16,25,28,40,42,45,52,53,61,64,65,66,75,85],inference0:8,infin:[39,44,74,75,76],infinit:[8,27,44,64,75,76],infinity:59,infix:[29,30,35,60,64],influenc:51,inform:[2,3,7,8,11,13,14,19,21,26,28],informat:33,information:59,information_desk_person:59,information_sourc:59,infrastructur:[13,18,50,51,85],infrequ:53,infti:59,ing:[41,51,64],inher:57,inherit:[18,25,41,58,61,71,76,85],init:[9,18,50,51,52,53,66,77,78,79],init_stdio:18,init_work:[51,77],initerror:[29,64],initfn:[51,77],initi:[6,7,8,14],initial:8,initialis:9,inject:52,ink:[59,84],inlin:[1,3,7,13,26,29,32,34,36,52,53,55,56,57,64,75,77,83],inline:1,inner:[1,3,19],innermost:[25,52,83],innersimd:52,innoc:[31,52,59],innocu:[28,45],inod:[64,69],inplaceop:49,input:[1,19,21,23,25],input_color:40,inputindex:19,insan:45,insensit:[56,64,84],insert:1,insertionsort:82,insid:[1,2,3,7,12,13,21,25,26,28,29,30],inside:[35,54,59,61],insist:51,instabl:[34,52,58,64],instal:[33,36,47,50,51,77,78,85],instanc:[1,3,8,14,21,22,25,26,28,29,30,32,33,40,41,43,44,45,46,47,49,51,52,54],instant:[31,68],instanti:[21,26,58,80],instead:[1,3,4,7,8,13,14,16,19,21,25,26,27,28,29,30,31,32,34,35,39,41,44,45,46,47,48,49,50,51,52,54,55,56,57,58,60,61,62,63,64,66,68,69,71,73,74,75,76,77,82,84],insteadof:50,instrm:77,instruct:[2,3,7,9,13,20,26,34,36,42,50,52,53,58,64,77,79,81],instrument:[17,53],insuffici:[22,76,77],int128:[34,39,40,46,49,58,76,77],int128_str:1,int16:[26,39,40,46,58,65,76],int32:[9,25,26,28,30,32,39,40,46,49,52,56,57,58,64,65,66,74,76],int32_t:[8,33],int64:[16,19,21,25,26,27,28,29,30,31,32,34,35,39,40,41,44,45,46,49,51,52,56,58,61,63,64,65,66,68,71,74,76,82,83,85],int8:[8,21,25,26,30,39,40,44,46,58,75,76,77],int_:32,intbar:59,intcap:59,intcup:59,integ:[1,5,9,18,19,21,25,26,27,28,30,31,32,33],integer:[15,16,18,21,23,25,26,28,30,32,36,38],integr:[27,28,33,54,58,71,75],integral:59,integrand:75,integration:59,intel:[2,52],intellig:[32,50,56],intend:[3,5,25,26,37,44,47,50,51,53,60,64,65,66,74,81],intens:[11,42,52],intent:[47,50,51,61,64],intention:[26,45],inter:25,interact:[6,7,14,21,23,26,27,29,33,35,36,38,39],interc:59,intercalate:59,interchang:[49,58],interconvert:25,interest:[11,15,16,21,26,28,34,39,45,50,54],interfac:7,interior:59,interleav:59,intermedi:[1,16,52,63,66,75],intermediari:19,intermitt:85,intern:[1,6,12,16,19],internet:50,interoper:[30,34,39],interpol:[16,19,32,39],interpret:[6,7,9,11,19,25,29,30,32,35,39,42,44,45,47,50,52,53,54,55,56,63,64,68,71,77,78,84],interrobang:59,interrog:16,interrupt:[29,40,51,64,65,77],interruptexcept:[29,64,65],intersect:[21,46,52,64,66],intersect_tupl:21,intersecting:59,intersection:59,interv:[8,25,43,50,53,64,74,75,76,78],interval_:71,interven:[35,54],interview:39,intfunc:34,intmax_t:[26,65],intorstring:58,intprod:59,intprodr:59,intract:19,intrins:[3,7,9,11,26,41,63,64],intrinsic:[7,9],introduc:[26,28,29,34,39,40,45,46,47,51,53,54,56,57,58,61],introductori:[36,53],intset:66,intuit:[11,58,61],intuitiv:58,intx:59,inv:[43,64,74,75],invalid:[3,7,25,26,27,28,33,34,37,47,51,52,56,64,65,76,84],invalidstateexcept:29,invalu:45,invari:[19,21,28,58,74],invdigamma:75,invers:[12,25,44,63,66,74,75,78],inverse:59,inversewhitecircl:59,invert:74,inverted:59,investig:[22,40],invis:30,invmod:75,invnot:59,invok:[1,6,7,8,12,28,29,30,33,35,45,46,47,48,49,53,54,58,64,71,80,82],invoke:64,involv:[7,8,11,19,30,34,47,48,51,57,58,61,62,64,74],invperm:63,invwhitelowerhalfcircl:59,invwhiteupperhalfcircl:59,iobuffer:[51,71,84],iocontext:[48,71],ios_init_stdstream:9,ios_stdout:6,ios_t:18,ios_writ:18,iostream:[18,40,48,71],iota:59,ipaddr:[64,71],ipart:75,ipermut:63,ipermutedim:63,iphon:59,ipiv:74,ipv4:[48,71],ipv6:[48,71],ipv6onli:71,ipython:71,irang:[51,74],irfft:75,irregular:31,irrelev:[45,61],irrespect:77,is_appl:[37,64],is_assigned_char:84,is_bsd:[37,64],is_linux:[37,64],is_unix:[37,64],is_window:[37,64],isa:[8,13,15,19,29,44,45,52,57,58,64],isabspath:69,isalnum:84,isalpha:84,isapprox:[75,85],isascii:84,isassign:[63,64],isbit:[14,16,26,47,58,64],isblockdev:69,ischardev:69,iscntrl:84,isconst:64,isdefin:[8,34,64],isdiag:74,isdigit:84,isdir:69,isdirpath:69,isdst:72,isempti:[45,66],isequ:[27,44,57,64,66],iseven:[35,52,61,63,76],isfifo:69,isfil:[62,69],isfinit:[25,44,76],isgn:74,isgraph:84,isheap:66,ishermitian:74,isimag:76,isimmut:64,isin:59,isindot:59,isine:59,isinf:[8,25,30,44,76],isinfinit:[41,66],isinobar:59,isinteg:76,isinteract:[36,64],isinvb:59,isleaftyp:64,isleapyear:[31,68],isless:[64,75,82],islink:69,islock:77,islow:84,ism:[56,84],ismark:71,ismatch:[56,84],ismount:69,isn:[21,26,30,34,50,54,58,64],isnan:[25,30,44,64,76],isnul:[58,64],isnumb:84,iso:[31,68],isodd:[61,63,66,76],isol:[5,11,49,52],isopen:[48,64,71],ispath:69,isperm:63,isplit:74,isplit_in:74,isposdef:74,ispow2:[25,34,75],isprecompil:64,isprint:84,isprocess:58,ispunct:84,isqrt:75,isread:71,isreadi:[51,77],isreadonli:71,isreal:76,issetgid:69,issetuid:69,issocket:69,issort:82,isspac:[71,84],isspars:[25,63],issticki:69,issu:2,issubnorm:76,issubset:66,issubtyp:[8,57,64],issue8859:74,issue:74,issymmetr:74,istaskdon:[29,77],istaskstart:[29,77],istextmim:71,istream:71,istril:74,istriu:74,istuesdai:31,isupp:[74,84],isva:1,isvalid:[56,84],iswrit:71,isxdigit:84,isym:5,ital:[32,58],item:[21,32,41,49,51,52,64,66,71,75,77],iter1:1,iter2:1,iter:[1,5,9],iteratoreltyp:[41,66],iterators:[41,66],iteratorsmd:25,itersym:5,itertyp:[41,66],ith:65,itr:66,its:59,itself:[1,7,8,12,15,16,20,21,25,26,28,32,34,36,39,41,42,44,45,46,47],ityp:74,izakaya:59,izakaya_lantern:59,j_1:5,j_2:5,j_d:5,jack:59,jack_o_lantern:59,jan:[31,68],januari:[31,68],japan:59,japanes:56,japanese:59,japanese_castl:59,japanese_goblin:59,japanese_ogr:59,jargon:50,java:[29,30,31,34,46,49,56,58,75],javascript:[31,75],jean:59,jeans:59,jeudi:31,jl_:[4,6,21,33],jl_add_standard_import:9,jl_alloc_array_1d:[14,33],jl_alloc_array_2d:[14,33],jl_alloc_array_3d:14,jl_alloc_tupl:14,jl_alloc_vec_ani:14,jl_any_typ:9,jl_appli:[6,8,9,55],jl_apply_array_typ:[14,33],jl_apply_gener:[6,8,9,55],jl_apply_typ:14,jl_args_morespecif:21,jl_array_data:33,jl_array_dim:33,jl_array_len:33,jl_array_ndim:33,jl_array_t:[14,33],jl_ast_context_list_t:12,jl_atexit_hook:7,jl_backtrace_from_her:55,jl_base_modul:[9,33],jl_bottom_typ:21,jl_box_:33,jl_box_float32:33,jl_box_float64:33,jl_box_int32:33,jl_box_uint16:14,jl_box_uint8:9,jl_breakpoint:[6,21],jl_call0:33,jl_call1:33,jl_call2:33,jl_call3:33,jl_call:[8,33],jl_call_method_intern:55,jl_callable:4,jl_compil:6,jl_compile_al:9,jl_core_modul:9,jl_critical_error:6,jl_current_task:9,jl_datatype_t:[9,14],jl_dump_llvm_valu:6,jl_egal:14,jl_error:[6,33],jl_errorf:33,jl_eval_str:[6,33],jl_exception_in_transit:1,jl_exception_occur:33,jl_expand:7,jl_f_appli:9,jl_f_i:9,jl_f_top_ev:9,jl_filenam:6,jl_first_argument_datatyp:8,jl_float64_typ:33,jl_function_t:[6,8,14,33],jl_gc_allocobj:14,jl_gc_collect:33,jl_gc_enabl:33,jl_gc_init:9,jl_gc_is_en:33,jl_gc_pop:33,jl_gc_push1:33,jl_gc_push2:33,jl_gc_push3:33,jl_gc_push4:33,jl_gc_push:33,jl_gc_pushargs:33,jl_gc_run_all_fin:[7,9],jl_gc_wb:[14,33],jl_gdblookup:6,jl_get_builtin_hook:9,jl_get_field:14,jl_get_funct:33,jl_get_glob:[8,9],jl_get_nth_field_check:14,jl_gf_mtabl:6,jl_init:33,jl_init_box_cach:9,jl_init_codegen:[7,9],jl_init_frontend:9,jl_init_intrinsic_funct:9,jl_init_primit:9,jl_init_restored_modul:9,jl_init_seri:9,jl_init_task:9,jl_init_typ:[9,14],jl_int32_typ:9,jl_interpret_cal:55,jl_interpret_toplevel_expr:9,jl_interrupt_except:9,jl_intrinsic_typ:9,jl_is_:33,jl_is_float64:33,jl_is_mut:14,jl_lambda_info_t:[6,7,14],jl_lamdbda_info_t:6,jl_lineno:6,jl_load:[6,7,9],jl_lock:12,jl_macroexpand:7,jl_main_modul:9,jl_method_def:8,jl_module_run_initi:9,jl_new_abstracttyp:9,jl_new_arrai:14,jl_new_arrayv:14,jl_new_bit:14,jl_new_bitstyp:9,jl_new_generic_funct:[8,14],jl_new_lambda_info:14,jl_new_main_modul:9,jl_new_modul:9,jl_new_struct:14,jl_new_structv:14,jl_new_uniontyp:14,jl_null:9,jl_option:[6,7,9,33],jl_parse_eval_al:9,jl_parse_input_lin:9,jl_printf:18,jl_ptr_to_array_1d:33,jl_pvalue_t:14,jl_resolve_sysimg_loc:9,jl_restore_system_imag:[7,9],jl_root_task:9,jl_safe_printf:18,jl_save_system_imag:[7,9],jl_set_typeof:14,jl_share:33,jl_static_show:18,jl_stderr:18,jl_stdin:18,jl_stdout:[9,18],jl_subtype_l:21,jl_svec_t:21,jl_sym_t:14,jl_symbol:[9,14],jl_symbol_nam:6,jl_task_typ:9,jl_throw:[6,9,26],jl_too_few_arg:6,jl_too_many_arg:6,jl_toplevel_ev:9,jl_toplevel_eval_flex:[7,9,55],jl_toplevel_eval_in:9,jl_toplevel_eval_in_warn:55,jl_trampolin:9,jl_tupl:14,jl_tuple_t:14,jl_tupletype_t:6,jl_tuplev:14,jl_type_error:33,jl_type_intersect:21,jl_type_morespecif:21,jl_type_typ:9,jl_typeof:[6,14],jl_typeof_str:33,jl_typetag_t:14,jl_unbox_float64:33,jl_uncompress_ast:6,jl_uniontype_t:14,jl_unlock:12,jl_uv:[9,18],jl_uv_handle_typ:18,jl_uv_put:18,jl_uv_stderr:6,jl_uv_writ:[9,18],jl_value_t:[6,8,9],jl_vprintf:18,jl_yield:51,jlbacktrac:6,jlcall:8,jlcall_:4,jlcall_print_284639:9,jlcapi_:4,jldoctest:32,jle:34,jlfrontend:7,jltype:14,jmath:59,job:[8,9,29,51,52,53,74],jobq:74,jobsvl:74,jobu:74,jobv:74,jobvl:74,jobvr:74,jobvsl:74,jobvsr:74,jobvt:74,jobz:74,john:[39,44],joi:[31,59],join:[56,59,69,71,84],joined:59,joiner:59,joinpath:[20,33,62,69,78],jointli:51,joker:59,journal:74,joy:59,joy_cat:59,jpvt:74,jrang:51,judgment:52,judici:[45,64],jul:68,juli:[31,68],julia_:[4,16],julia_convert_16886:6,julia_dir:33,julia_home:[20,33,67,77],julia_info_color:40,julia_init:7,julia_init_dir:33,julia_intern:55,julia_llvm_args:11,julia_load_path:47,julia_num_threads:51,julia_pkgdir:78,julia_print_284639:9,julia_root:2,julia_warn_color:40,julia_worker_timeout:77,julia_write_282942:9,juliabox:40,juliacon:36,julialang:[32,34,36,40,50,74],julialibm:75,julian2datetim:68,julian_dai:68,juliapars:50,juliarc:[36,40,47,51,62,64,77],juliastat:[49,50],jump:[1,48,52,76],jumppoli:76,jun:68,june:68,juno:32,jupit:59,jupiter:59,just:[1,5,7,8,9,11,14,15,19,21,22,25,26,27,28,29,30,31,32,33,34,35,36,39,40,41,42,44,45,46,48,49,50,51,52,53,54,56],justifi:15,juxtapos:[27,39],juxtaposit:39,k_1:75,k_2:75,kahan:[39,63],kappa:59,karpinski:50,katakana:59,kaufman:74,keep:[8,21,22,26,29,33,40,41,47,50,51,52,62,64,77,84],kei:[8,19,21,29,31,35,36],kept:[14,42,78,84],kernel:[29,37,51],kernelcontract:59,key:59,keyboard:59,keycap:59,keycap_ten:59,keyerror:[29,64],keyfil:51,keymap:40,keytyp:66,kib:50,kick:52,kill:[40,51,64,77],kimono:59,kind:[1,6,8,15,19,22,28,29,30,31,34,35,44,45,46,48,52,56,58,61,64,75],kindli:50,kiss:59,kissing:59,kissing_cat:59,kissing_closed_ey:59,kissing_heart:59,kissing_smiling_ey:59,kiwi:64,knew:51,knife:59,know:[2,7,15,26,29,30,31,33,34,35,39,41,45,47,50,51,52,54,56,57,71,74,77],knowledg:[21,52],known:[1,7,14,21,25,26,27,28,29,31,32,35,36,39,41,45,46,47,50,52,53,57,58,59,63,66,74,75,76],knuth:75,koala:59,koko:59,konstantinid:74,konstantino:74,koppa:59,korean:56,kron:[60,74],kroneck:[60,74],kronrod:75,krylov:74,kung:74,kwarg:[35,77,79],kwftype:8,kwfunc:8,kwsorter:[8,12,21],ky88:74,label:[1,32,35,52,65,84],labelnod:1,labor:11,lack:[34,42,45,49,57,63,77],lady:59,laid:[19,25],lambda:[1,6,55,59,64,74,77],lamda:59,lanczo:74,land:50,langl:59,languag:[3,7,8,15,23,25,26,29,30,31,32,33,34,35,38,42,44,45,46,47],lantern:59,lapack:[2,25,43],lappli:49,laptop:[51,53],larg:[4,8,14,25,30,32,33,34,35,41,42,44,45,47,49,50,51,52,58,63,64,66,68,71,74,75,77,85],large:59,large_blue_circl:59,large_blue_diamond:59,large_orange_diamond:59,larger:[8,25,28,30,31,33,39,49,50,52,56,59,64,66,74,75],largest:[25,30,31,34,39,63,64,66,74,75,76],last:[1,3,5,6,11,21,25,29,30,31,32,33,35,36,39,40,41,44,45,48,49,50,51,56,57,58,59,61,63,64,66,68,69,71,74,75,77,82,84],last_quarter_moon:59,last_quarter_moon_with_fac:59,lastdayofmonth:[31,68],lastdayofquart:[31,68],lastdayofweek:68,lastdayofyear:68,lastmain:64,lat:59,late:59,latenc:[52,54],later:[9,19,25,28,29,31,35,46,50,51,52,57,58,60,64,65,77],latest:[11,34,50,51,78],latex:[5,32,40,60],lather:62,latin:[59,84],latter:[21,30,40,49,50,52,54,56,61,63,74],laugh:59,launch:[6,29,36,51,53,64,77],launch_ntfi:77,law:[42,46],layer:[3,7,26,51],layout:10,lazi:[28,49],lazili:49,lazy:59,lazysinv:59,lbeta:[25,44,75],lceil:59,lcfirst:84,lcm:[44,75],ldexp:[44,75],ldflag:33,ldflags:33,ldlib:33,ldlibs:33,ldlt:74,ldltfact:74,ldot:59,ldsh:59,lea:34,lead:[25,31,34,47,49,50,52,61,74,75,76,84],leading_on:76,leading_zero:76,leaf:[12,14,26,52,59,64],leak:[22,26],leaki:29,leap:[31,68],learn:[7,21,34,36,52],least:[15,21,25,39,44,48,50,51,52,53,56,64,66,71,74,75,76,84],leav:[1,28,29,34,45,50,57,59,77,82],led:53,ledger:59,left:[1,5,25,29,32,34,35,39,40,44,45,49,50,56,58,59,61,63,64,66,68,74,75,77,84],left_luggag:59,left_right_arrow:59,left_sv:74,leftarrow:59,leftarrowapprox:59,leftarrowbackapprox:59,leftarrowbsimilar:59,leftarrowonoplu:59,leftarrowplu:59,leftarrowtail:59,leftarrowtriangl:59,leftarrowx:59,leftbkarrow:59,leftcurvedarrow:59,leftdasharrow:59,leftdbkarrow:59,leftdotarrow:59,leftdownteevector:59,leftdownvectorbar:59,leftharpoonacc:59,leftharpoondown:59,leftharpoonsupdown:59,leftharpoonup:59,leftharpoonupdash:59,leftleftarrow:59,leftmoon:59,leftouterjoin:59,leftrightarrow:59,leftrightarrowcircl:59,leftrightarrowtriangl:59,leftrightharpoon:59,leftrightharpoondownup:59,leftrightharpoonsdown:59,leftrightharpoonsup:59,leftrightharpoonupdown:59,leftrightsquigarrow:59,leftrightvector:59,leftsquigarrow:59,leftteevector:59,leftthreearrow:59,leftthreetim:59,lefttrianglebar:59,leftupdownvector:59,leftupteevector:59,leftupvectorbar:59,leftvectorbar:59,leftwards:59,leftwards_arrow_with_hook:59,leftwavearrow:59,leftwhitearrow:59,leg:59,legaci:9,legacystr:56,legend:43,lehoucq:74,lemon:59,len:[9,12,84],length:[3,4,14],leo:59,leopard:59,leqq:59,leqqslant:59,leqslant:59,lescc:59,lesdot:59,lesdoto:59,lesdotor:59,lesg:59,less:[1,19,21,25,26,28,29,31,34,39,44,45,46,49,50,51,53,54,56,57,58,59,64,68,74,75,77,82,84],lessapprox:59,lessdot:59,lesseqgtr:59,lesseqqgtr:59,lesser:32,lessgtr:59,lesssim:59,let:[1,5,6,7,15,21,25,26,28,29,31,32,33,41,45,47,48,49,50,51,52,53,54,56,58,60],letter:[54,56,59,60,69,84],letters:59,level:[3,7,8,11,12,14,16,19,25,26,29,32],leverag:[28,51],lexcmp:64,lexic:61,lexicograph:[56,64,82],lexless:64,lfact:[25,44,75],lfloor:59,lgamma:[25,44,75],lgblkcircl:59,lgblksquar:59,lge:59,lgwhtcircl:59,lgwhtsquar:59,lib64:40,lib:[6,20,26,33,40,47,64],libc:[26,54,67,72,73],libdist:26,libdl:[67,73],liber:34,liberty:59,libfil:73,libfoo:[26,47],libgit2:50,libgsl:26,libjulia:[20,33],liblapack:26,libllvm:[2,7],libm:[2,52],libopenbla:2,libopenlibm:2,libra:59,librari:[7,9,17],libstdc:33,libsupport_init:9,libuv:[7,9],licens:[42,50,52],license:50,lidict:79,lie:21,lieu:[9,49,74],life:45,lifetim:[51,77],lifo:64,lift:28,ligatur:84,ligature:59,light:59,light_rail:59,lighter:77,lightweight:[6,29,42,50],like:[1,2,3,5,6,8,11,13,15,18,19,21,22,25,26,28,29,30,31,32,33,34,35,40,41,42,44,45],likelihood:3,likewis:[15,16,19,21,29,34,56,58],limit:[7,8,26,30,31,32,36,40,42,45,50,51,53,56,59,68,71,74,75,77,79,84],linalg:[63,74],lindahua:50,line:[1,6,7,9,11,15,18,19,20,21,22,26,28,29,30,31,32],lineag:42,linearcach:21,linearfast:[3,19,25,41,63],linearindex:[3,25,41,63],linearli:[19,25,63],linearslow:[19,25,41,63],linecom:71,lineedit:40,linefe:[59,84],lineinfo:79,linenumbernod:1,liner:[29,54],linerang:79,linfo:[6,55,83],lingo:58,link:[2,11,26],linker:[23,33,70],linreg:74,linspac:[25,49,51,63,66],lint:52,linux:[2,6,9,33,50,51,64],lip:59,lipstick:59,lisp:[7,35,42,45],list:[1,6,8,9,11,12,14,16,19,21,25,26,29],list_of_remote_host:51,listen:[48,51,71],listenani:71,liter:[26,27,29,30],literatur:74,litter:59,littl:[21,31,34,42,46,50,51,52,53,57,58,71],live:[20,34,51,71],ljulia:33,llarc:59,llblacktriangl:59,llbracket:59,llcorner:59,lldb:6,lleftarrow:59,lllnest:59,lltriangl:59,llvm:[2,4,7,9,10],llvm_assertions:11,llvm_debug:11,llvm_sanitize:17,llvm_use_cmake:17,llvm_ver:11,llvmcall:[7,65,81],llvmcontext:12,lmoustach:59,lnapprox:59,lneq:59,lneqq:59,lnsim:59,load:2,load_cache_path:[47,64],load_path:[47,64,67],loader:73,loaderror:[29,64],loan:74,local:[1,9,26,28,29,31,33,36,45,47,50,51,52,56,58],localdatetim:31,localfil:69,localhost:[48,71],localindex:[51,77],locat:[1,8,15,25,33,34,35,36,50,51],lock:10,lock_with_ink_pen:59,locomotive:59,log10:[25,44,75],log1p:[25,44,75],log2:[25,44,75],log:25,logabsdet:74,logarithm:[44,63,74,75],logdet:[43,74],logic:[3,8,25,30,44,47,49,50,51,63,67,74,76,77],logical:[26,59],login:[36,50,51],logm:74,logspac:63,lollipop:59,long_comput:77,longer:[8,15,19,29,33,34,45,50,53,56,62,65,68,77,78,84],longest:56,longjmp:26,longleftarrow:59,longleftrightarrow:59,longleftsquigarrow:59,longmapsfrom:59,longmapsto:59,longrightarrow:59,longrightsquigarrow:59,look:[6,8,9,11,12,21,25,26,33,34,35,41,45,47,50,51,52,53,55,56,58,59,64,66,67,73,77,83,85],lookup:[6,26,47,52,55,71,73,83],loop:[1,3,5,7,8,11],looparrowleft:59,looparrowright:59,loopback:[51,71],loopinc:52,loopinc_prealloc:52,lorry:59,lose:50,loss:[28,31,58,64],lossless:28,losslessli:[64,68],lot:[19,21,25,34,41,58,72],loud_sound:59,loudly:59,loudspeak:59,loudspeaker:59,love:59,love_hotel:59,love_lett:59,low:[7,8,14,19,32,35,39,51,59],low_bright:59,lowercas:[26,31,56,57,84],lowered:59,lowertriangular:43,lowest:[14,27,28,39,44,64,66],lowint:59,lowrankdownd:74,lowrankupd:74,lozeng:59,lozenge:59,lpad:[39,84],lqfact:74,lrarc:59,lrblacktriangl:59,lrcorner:59,lrtriangl:59,lrtriangleeq:59,lsh:59,lsime:59,lsimg:59,lsqhook:59,lst:51,lstat:69,lstrip:84,lt_float:52,ltcc:59,ltcir:59,ltime:59,ltoh:71,ltp:74,ltquest:59,lua:42,lucid:39,lufact:74,luggage:59,lump:53,lunate:59,lundi:31,lutridiagon:43,luu:34,lvboxlin:59,lvertneqq:59,lyap:74,lyapunov:74,m128:81,m256:26,mac:47,mach:77,machin:[7,16,26,30,31],machine:[59,67],machine_spec:77,machinefil:[36,51],macintosh:64,macos:[64,73],macrocal:1,macroexpand:[5,7,16,45,64],macron:59,mad:50,made:[25,28,34,35,47,50,51,52,64,71,77],mag:59,mag_right:59,magenta:[40,71],magic:[3,46],magnifi:58,magnifying:59,magnitud:[44,52,74,75],mahjong:59,mai:[2,3,5,6,7,12,14,15,16,19,20,21,22,25,26,28,29,30,31,32,33,34,35,36,37,39,40,42,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,63,64,65,66,68,71,72,74,75,76,77,78,79,82,84],mail:[52,59],mailbox:59,mailbox_clos:59,mailbox_with_mail:59,mailbox_with_no_mail:59,main:7,mainli:34,mainstream:58,maintain:[1,2,29,47,54,66,77,85],mainten:10,maize:59,major:[8,15,25,33,34,45,47,49,50,51,52,53,56,64,78],make:[2,3,6,7,8,11,12,15,17,18,19,21,22,25,26,27,28,29,30,32,33,34,35,37,39,40,41,42,44,45,46,47,48,49],make_expr2:45,male:59,malform:71,malici:51,malloc:[14,26,33,72],malloc_context_s:17,maltes:59,maltese:59,man:[39,59,73],man_with_gua_pi_mao:59,man_with_turban:59,manag:[2,23,26,29],mangl:26,mani:[1,2,3,5,6,7,8,12,14,15,16,19,20,21,25,26,28,29,30,31,32,33],manipul:[1,6,7,25,26,27,29],manner:[19,25,26,28,29,30,39,44,45,48,51,58,63,64,65,71,75,77],manpag:56,mans:59,mans_sho:59,mantissa:[44,76],manual:[2,7,14,19,21],mao:59,map:[8,9,15,25],mapfoldl:66,mapfoldr:66,maple:59,maple_leaf:59,mapreduc:66,mapreducedim:63,mapsdown:59,mapsfrom:59,mapslic:63,mapsto:59,mapsup:59,mar:[31,59,68],march:[20,31,68],mardi:31,margin:85,mark:[1,3],marker:[71,84],markup:[32,52],masculine:59,mask:[9,25,49,59,69],massag:59,massage:59,master:[36,40,50,51,65,77,78],master_slav:[51,77],match:[1,2,6,8,15,17,21,25,26,28,32,34,35,40,41,42,43,44,45,46,47,50,52,56,58,63,64,66,68,75,77,84,85],matchal:84,math:[5,27,29,32,34,36,40,52,60,75],math_expr:45,mathemat:[23,25,27,29,30,32,34,35,38,39,42],mathematical:59,matlab:[29,34,42],matrix:19,matter:[2,21,25,30,31,34,45,50,51,52,56,58],matur:[26,50],max:[25,40,49,52,53,63,66,68,74,75,77,85],max_arg:21,max_delai:[64,77],max_parallel:[51,77],maxab:66,maxdepth:[53,79],maxev:[8,75],maxim:56,maximum:[25,35,39,49,51,53,57,63,66,74,75,76,77,84],maxintfloat:64,maxit:74,maxsiz:71,maxval:66,mbf:59,mbfa:59,mbfalpha:59,mbfb:59,mbfbeta:59,mbfc:59,mbfchi:59,mbfd:59,mbfdelta:59,mbfdigamma:59,mbfe:59,mbfeight:59,mbfepsilon:59,mbfeta:59,mbff:59,mbffive:59,mbffour:59,mbffrak:59,mbffraka:59,mbffrakb:59,mbffrakc:59,mbffrakd:59,mbffrake:59,mbffrakf:59,mbffrakg:59,mbffrakh:59,mbffraki:59,mbffrakj:59,mbffrakk:59,mbffrakl:59,mbffrakm:59,mbffrakn:59,mbffrako:59,mbffrakp:59,mbffrakq:59,mbffrakr:59,mbffraks:59,mbffrakt:59,mbffraku:59,mbffrakv:59,mbffrakw:59,mbffrakx:59,mbffraky:59,mbffrakz:59,mbfg:59,mbfgamma:59,mbfh:59,mbfi:59,mbfiota:59,mbfit:59,mbfita:59,mbfitalpha:59,mbfitb:59,mbfitbeta:59,mbfitc:59,mbfitchi:59,mbfitd:59,mbfitdelta:59,mbfite:59,mbfitepsilon:59,mbfiteta:59,mbfitf:59,mbfitg:59,mbfitgamma:59,mbfith:59,mbfiti:59,mbfitiota:59,mbfitj:59,mbfitk:59,mbfitkappa:59,mbfitl:59,mbfitlambda:59,mbfitm:59,mbfitmu:59,mbfitn:59,mbfitnabla:59,mbfitnu:59,mbfito:59,mbfitomega:59,mbfitomicron:59,mbfitp:59,mbfitparti:59,mbfitphi:59,mbfitpi:59,mbfitpsi:59,mbfitq:59,mbfitr:59,mbfitrho:59,mbfits:59,mbfitsans:59,mbfitsansa:59,mbfitsansalpha:59,mbfitsansb:59,mbfitsansbeta:59,mbfitsansc:59,mbfitsanschi:59,mbfitsansd:59,mbfitsansdelta:59,mbfitsanse:59,mbfitsansepsilon:59,mbfitsanseta:59,mbfitsansf:59,mbfitsansg:59,mbfitsansgamma:59,mbfitsansh:59,mbfitsansi:59,mbfitsansiota:59,mbfitsansj:59,mbfitsansk:59,mbfitsanskappa:59,mbfitsansl:59,mbfitsanslambda:59,mbfitsansm:59,mbfitsansmu:59,mbfitsansn:59,mbfitsansnabla:59,mbfitsansnu:59,mbfitsanso:59,mbfitsansomega:59,mbfitsansomicron:59,mbfitsansp:59,mbfitsansparti:59,mbfitsansphi:59,mbfitsanspi:59,mbfitsanspsi:59,mbfitsansq:59,mbfitsansr:59,mbfitsansrho:59,mbfitsanss:59,mbfitsanssigma:59,mbfitsanst:59,mbfitsanstau:59,mbfitsanstheta:59,mbfitsansu:59,mbfitsansupsilon:59,mbfitsansv:59,mbfitsansvarepsilon:59,mbfitsansvarkappa:59,mbfitsansvarphi:59,mbfitsansvarpi:59,mbfitsansvarrho:59,mbfitsansvarsigma:59,mbfitsansvartheta:59,mbfitsansw:59,mbfitsansx:59,mbfitsansxi:59,mbfitsansy:59,mbfitsansz:59,mbfitsanszeta:59,mbfitsigma:59,mbfitt:59,mbfittau:59,mbfittheta:59,mbfitu:59,mbfitupsilon:59,mbfitv:59,mbfitvarepsilon:59,mbfitvarkappa:59,mbfitvarphi:59,mbfitvarpi:59,mbfitvarrho:59,mbfitvarsigma:59,mbfitvartheta:59,mbfitw:59,mbfitx:59,mbfitxi:59,mbfity:59,mbfitz:59,mbfitzeta:59,mbfj:59,mbfk:59,mbfkappa:59,mbfl:59,mbflambda:59,mbfm:59,mbfmu:59,mbfn:59,mbfnabla:59,mbfnine:59,mbfnu:59,mbfo:59,mbfomega:59,mbfomicron:59,mbfone:59,mbfp:59,mbfpartial:59,mbfphi:59,mbfpi:59,mbfpsi:59,mbfq:59,mbfr:59,mbfrho:59,mbfs:59,mbfsans:59,mbfsansa:59,mbfsansalpha:59,mbfsansb:59,mbfsansbeta:59,mbfsansc:59,mbfsanschi:59,mbfsansd:59,mbfsansdelta:59,mbfsanse:59,mbfsanseight:59,mbfsansepsilon:59,mbfsanseta:59,mbfsansf:59,mbfsansfiv:59,mbfsansfour:59,mbfsansg:59,mbfsansgamma:59,mbfsansh:59,mbfsansi:59,mbfsansiota:59,mbfsansj:59,mbfsansk:59,mbfsanskappa:59,mbfsansl:59,mbfsanslambda:59,mbfsansm:59,mbfsansmu:59,mbfsansn:59,mbfsansnabla:59,mbfsansnin:59,mbfsansnu:59,mbfsanso:59,mbfsansomega:59,mbfsansomicron:59,mbfsanson:59,mbfsansp:59,mbfsansparti:59,mbfsansphi:59,mbfsanspi:59,mbfsanspsi:59,mbfsansq:59,mbfsansr:59,mbfsansrho:59,mbfsanss:59,mbfsansseven:59,mbfsanssigma:59,mbfsanssix:59,mbfsanst:59,mbfsanstau:59,mbfsanstheta:59,mbfsansthre:59,mbfsanstwo:59,mbfsansu:59,mbfsansupsilon:59,mbfsansv:59,mbfsansvarepsilon:59,mbfsansvarkappa:59,mbfsansvarphi:59,mbfsansvarpi:59,mbfsansvarrho:59,mbfsansvarsigma:59,mbfsansvartheta:59,mbfsansw:59,mbfsansx:59,mbfsansxi:59,mbfsansy:59,mbfsansz:59,mbfsanszero:59,mbfsanszeta:59,mbfscr:59,mbfscra:59,mbfscrb:59,mbfscrc:59,mbfscrd:59,mbfscre:59,mbfscrf:59,mbfscrg:59,mbfscrh:59,mbfscri:59,mbfscrj:59,mbfscrk:59,mbfscrl:59,mbfscrm:59,mbfscrn:59,mbfscro:59,mbfscrp:59,mbfscrq:59,mbfscrr:59,mbfscrs:59,mbfscrt:59,mbfscru:59,mbfscrv:59,mbfscrw:59,mbfscrx:59,mbfscry:59,mbfscrz:59,mbfseven:59,mbfsigma:59,mbfsix:59,mbft:59,mbftau:59,mbftheta:59,mbfthree:59,mbftwo:59,mbfu:59,mbfupsilon:59,mbfv:59,mbfvarepsilon:59,mbfvarkappa:59,mbfvarphi:59,mbfvarpi:59,mbfvarrho:59,mbfvarsigma:59,mbfvartheta:59,mbfw:59,mbfx:59,mbfxi:59,mbfy:59,mbfz:59,mbfzero:59,mbfzeta:59,mcjit:7,mdai:72,mdblkcircl:59,mdblkdiamond:59,mdblklozeng:59,mdblksquar:59,mdlgblkcircl:59,mdlgblkdiamond:59,mdlgwhtdiamond:59,mdnode:11,mdsmblksquar:59,mdsmwhtcircl:59,mdsmwhtsquar:59,mdwhtcircl:59,mdwhtdiamond:59,mdwhtlozeng:59,mdwhtsquar:59,mean:[1,7,8,12,15,19,20,21,25,26,28,29,31,32,33],meaning:[58,66],meaningless:82,meant:[26,30,47,50,54],meantim:50,meanwhil:48,measangledltosw:59,measangledrtos:59,measangleldtosw:59,measanglelutonw:59,measanglerdtos:59,measangleruton:59,measangleultonw:59,measangleurton:59,measeq:59,measur:[31,51],measure:75,measured:59,measuredangl:59,measuredangleleft:59,meat:59,meat_on_bon:59,mechan:[9,10,12],medblackstar:59,media:40,median:75,medical:59,medium:59,medwhitestar:59,mega:59,megaphone:59,melon:59,mem:[52,53,79],member:[49,59,64,66,69],membership:59,memdebug2:22,memdebug:22,memo:59,memori:[7,8,10],men:59,mens:59,mental:[31,50],mention:[17,28,30,32,34,35,46,48,53,58,64,71],mercredi:31,mercuri:59,mercury:59,mere:[51,52],merg:[19,34,35,50,66,78,79],mergesort:82,meridians:59,merit:15,mersenn:76,mersennetwist:76,mesh:51,mess:28,messag:18,met:77,meta:[1,10],meta_branch:[50,78],metacharact:[54,56],metadata:[1,11,13,14,32,47,48],metaprogram:[16,23,32,38,42],meth:46,method:[1,3],method_exist:64,method_to_break:6,methoderror:[15,21,28,29,30,35,39,41,46,56,57,58,64,71,85],methodswith:[16,64],methodt:[8,12,21,47],metro:59,mfrak:59,mfraka:59,mfrakb:59,mfrakc:59,mfrakd:59,mfrake:59,mfrakf:59,mfrakg:59,mfrakh:59,mfraki:59,mfrakj:59,mfrakk:59,mfrakl:59,mfrakm:59,mfrakn:59,mfrako:59,mfrakp:59,mfrakq:59,mfrakr:59,mfraks:59,mfrakt:59,mfraku:59,mfrakv:59,mfrakw:59,mfrakx:59,mfraky:59,mfrakz:59,mho:59,microphon:59,microphone:59,microscop:59,microscope:59,microsecond:[53,64],microsoft:64,mid:[52,59],midbarve:59,midbarwedg:59,middl:[44,51,75],middle:59,midline:59,midpoint:[34,75],midwai:18,might:[1,3,6,8,12,13,15,19,25,26,29,33,34,35,45,46,48,50,51,52,53,57,58,61,62,63,64,66,71,75,76,77,81,85],milky:59,milky_wai:59,mille:59,millisecond:[31,51,64,68,77],mime:[58,71],mimewrit:71,mimic:[26,32,54],min:[5,25,36,49,63,66,72,75,77],minab:66,mind:[22,26,34,52],minibu:59,minibus:59,minidisc:59,minim:[7,22,31,50,51,58,71,74,75],minimum:[25,29,39,49,50,56,63,66,68,71,74,75,77],minmax:75,minor:[8,34,50,52,56,64,78],minu:[44,59,74,75],minus:59,minusdot:59,minusfdot:59,minusrdot:59,minut:[8,31,36,56,68,72],minval:66,mirror:[14,26,31],misalign:32,miser:22,misplac:45,miss:[14,19,32],mit:[36,42,50,59],mita:59,mitalpha:59,mitb:59,mitbbb:59,mitbbbd:59,mitbbbi:59,mitbbbj:59,mitbeta:59,mitc:59,mitchi:59,mitd:59,mitdelta:59,mite:59,mitepsilon:59,miteta:59,mitf:59,mitg:59,mitgamma:59,mith:59,miti:59,mitiota:59,mitj:59,mitk:59,mitkappa:59,mitl:59,mitlambda:59,mitm:59,mitmu:59,mitn:59,mitnabla:59,mitnu:59,mito:59,mitomega:59,mitomicron:59,mitp:59,mitparti:59,mitphi:59,mitpi:59,mitpsi:59,mitq:59,mitr:59,mitrho:59,mits:59,mitsans:59,mitsansa:59,mitsansb:59,mitsansc:59,mitsansd:59,mitsanse:59,mitsansf:59,mitsansg:59,mitsansh:59,mitsansi:59,mitsansj:59,mitsansk:59,mitsansl:59,mitsansm:59,mitsansn:59,mitsanso:59,mitsansp:59,mitsansq:59,mitsansr:59,mitsanss:59,mitsanst:59,mitsansu:59,mitsansv:59,mitsansw:59,mitsansx:59,mitsansy:59,mitsansz:59,mitsigma:59,mitt:59,mittau:59,mittheta:59,mitu:59,mitupsilon:59,mitv:59,mitvarepsilon:59,mitvarkappa:59,mitvarphi:59,mitvarpi:59,mitvarrho:59,mitvarsigma:59,mitvartheta:59,mitw:59,mitx:59,mitxi:59,mity:59,mitz:59,mitzeta:59,mix:30,mixin:47,mixtur:[30,44],mkdir:69,mkpath:69,mktemp:69,mktempdir:69,mlcp:59,mmap:[71,77],mnemon:8,mnt:40,mobile:59,mobile_phone_off:59,mod1:[44,75],mod2pi:[44,75],mod:[1,25,39,44,47,49,64,75],modal:41,mode:[22,31,32,36],model:[42,49,52,59],models:59,modern:[3,39,42,51],modf:75,modif:[12,14,25,26,35,47,53,56,58,61,63,74],modifi:[6,8,20,22,25],modifier:59,modtwosum:59,modul:[1,5,6,7,8,9,12,16,18,20,21,23,31],modular:39,module_nam:64,module_par:64,modulea:15,moduleb:15,modulenam:47,modulo:[44,59,75],modulu:[39,44,49,75],mohi:74,moment:[21,31,50,52],mon:68,mondai:[31,68],money:59,money_with_w:59,moneybag:59,monitor:71,monkei:59,monkey:59,monkey_fac:59,monorail:59,monospace:59,monster:59,mont:51,month:[31,34,68,72],monthabbr:68,monthdai:[31,68],monthnam:[31,68],monthtovalue:31,monthtovalueabbr:31,moon:59,moor:[42,74],more:[1,3,5,6],moreequ:74,moreov:[15,25,26,28,35,44,45,53,54,58],morespecif:21,morev:76,mortar_board:59,most:[1,3,5,6,8,12,14,15,17,19,21,22,25,26,28,29,30,31,32,33,34,35,39,40,41,42,44,45,46,47,49,50,51,52,53,54,55,56,58,60,61,62,63,64,65,66,68,71,74,75,76,77,79,83,84],mostli:[18,42,47,49,56,64,81],motiv:[31,45,51],mount:[59,69],mount_fuji:59,mountain:59,mountain_bicyclist:59,mountain_cablewai:59,mountain_railwai:59,mountains:59,mous:59,mouse2:59,mouse:59,mouth:59,mov:34,move:[8,25,26,29,39,40,42,45,47,50,51,61,69,76,78],movement:40,movie:59,movie_camera:59,moyai:59,mpfr:[39,76],mpi:51,ms_async:67,ms_invalidate:67,ms_sync:67,msans:59,msansa:59,msansb:59,msansc:59,msansd:59,msanse:59,msanseight:59,msansf:59,msansfiv:59,msansfour:59,msansg:59,msansh:59,msansi:59,msansj:59,msansk:59,msansl:59,msansm:59,msansn:59,msansnin:59,msanso:59,msanson:59,msansp:59,msansq:59,msansr:59,msanss:59,msansseven:59,msanssix:59,msanst:59,msansthre:59,msanstwo:59,msansu:59,msansv:59,msansw:59,msansx:59,msansy:59,msansz:59,msanszero:59,mscr:59,mscra:59,mscrb:59,mscrc:59,mscrd:59,mscre:59,mscrf:59,mscrg:59,mscrh:59,mscri:59,mscrj:59,mscrk:59,mscrl:59,mscrm:59,mscrn:59,mscro:59,mscrp:59,mscrq:59,mscrr:59,mscrs:59,mscrt:59,mscru:59,mscrv:59,mscrw:59,mscrx:59,mscry:59,mscrz:59,msg:[45,55,64,71],msg_bodi:45,msys2:33,mtime:[47,64,69,71],mtt:59,mtta:59,mttb:59,mttc:59,mttd:59,mtte:59,mtteight:59,mttf:59,mttfive:59,mttfour:59,mttg:59,mtth:59,mtti:59,mttj:59,mttk:59,mttl:59,mttm:59,mttn:59,mttnine:59,mtto:59,mttone:59,mttp:59,mttq:59,mttr:59,mtts:59,mttseven:59,mttsix:59,mttt:59,mttthree:59,mtttwo:59,mttu:59,mttv:59,mttw:59,mttx:59,mtty:59,mttz:59,mttzero:59,much:[1,7,8,15,17,22,28,29,31,34,39,42,46,47,49,50,51,52,53,54,57,58,59,64,74,75],mug:59,mugs:59,muladd:75,multi:[5,10],multicast:71,multicast_loop:71,multicast_ttl:71,multicor:51,multidimension:[3,5,25],multilin:[29,49],multilinear:45,multimap:59,multimedia:58,multipl:[3,5,6,7,8,14,15,19,20,22,25,26,27,28,29,30,31],multiple:59,multiplex:51,multipli:[30,32,34,39,66,74,75,80],multiplication:59,multiplicativeinvers:40,multiprocess:51,multiset:59,multitask:29,muscl:59,mushroom:59,music:59,musical:59,musical_keyboard:59,musical_not:59,musical_scor:59,must:[2,5,7,8,11,12,14,15,19,25,26,27,28,29,30,32,33,34,35,36,37,39,40,41,42,43,44,45,46,47,48,49,50,51,52,56,58,60,63,64,65,66,68,69,71,74,75,76,77,78,84],mutabl:[1,12,14,25,26,34,35,41,58,61,63,64],mutat:[25,32,34,41,49,60,63,74,82],mute:59,mutex:77,mutual:[37,61],mvs:43,myaccount:50,myambiguouscontain:52,myambiguoustyp:52,myappend:46,myarg:29,myarrai:[3,25,63],mybettercontain:52,mycod:47,mycompar:26,mycompare_c:26,mycontain:52,mycopi:15,mycustomexcept:29,myfix:50,myfork:50,myfun:52,myfunc:[26,52,53],myfunct:[13,49],myid:[47,51,77],myimag:71,myintersect:21,mykei:40,mylib:26,mylibvar:26,mymacro:49,mymodul:[34,45,47],mynewcod:34,mypackag:20,myplu:58,myrang:51,mysimplecontain:52,mystdout:47,mysteri:[21,45],mystillambiguoustyp:52,mysum:5,mytask:29,mytyp:[21,34,47,51,52,57,71],mytypeof:46,myundefvarerror:29,n_1:75,n_d:75,nabla:59,nadir:58,nail:59,nail_car:59,naiv:[8,19,45],nall:5,name:[1,4,6,7,8,9,14,16,20,21,25,26,27,29,30,31,32,34],name_badg:59,namespac:34,nan16:[39,76],nan32:[39,44,76],nan:[27,39,44,52,64,71,75,76,85],nan_dom_err:52,nand:[59,77],nani:5,nanosecond:64,napprox:59,narg:[1,4,6,8,33],nargout:49,narrow:6,nasti:19,nasymp:59,nativetyp:57,natur:[5,19,26,28,29,30,31,34,39,44,50,51,52,57,58,59,69,75],natural:59,navig:50,nb_avail:71,nbad:[56,84],nbumpeq:59,nbyte:[14,71],ncall:5,nce:53,nchunk:51,ncol:49,ncong:59,nconv:74,ncv:74,ndigit:75,ndim:[15,25,33,41,63,74,75],nearbi:44,nearest:[31,39,40,44,47,68,75,77],nearli:[8,25,42,53,54],nearrow:59,necessari:[1,5,8,13,15,19,25,26,27,29,30,32,33,34,35,37,44,45,47,49,50,51,52,54,57,58,61,64,65,66,69,71,77,85],necessarili:[1,13,19,29,31,33,47,56,74],neckti:59,necktie:59,need:[2,5,6,7,8,12,14,15,17,18,19,21,25,26,28,29,30,31,32,33,34,35,40,41,42,44,45,46,47,48,49,50,51,52,53,54,56,57,58,60,61,62,63,64,65,66,68,69,71,73,74,75,77,78,79,82,83,84],needl:84,neg:[27,28,29,31,34,39,44,49,59,74,75,76],negat:[29,39,44,50,68],negated:59,negative:59,negative_squared_cross_mark:59,neglig:82,nehalem:2,neighbor:25,neither:[19,21,29,34,39,46,56,59,63,65,69],nel:84,nelli:46,neovnwarrow:59,neovsearrow:59,neptun:59,neptune:59,neqsim:59,nequiv:59,nest:[3,5,13,16,19,29,32,35,45,53,61,64,75,85],nestabl:80,nested:59,nestedgreatergreat:59,nestedlessless:59,net:52,netlib:74,network:[23,38],neumaier:63,neuter:59,neutral:[59,66],neutral_fac:59,nev:74,never:[15,19,26,29,30,35,36,45,52,54,58,61,65,68,71,75,77],nevertheless:46,new_moon:59,new_moon_with_fac:59,newbranch:50,newcom:[34,50],newer:[8,50,74],newest:78,newli:[34,48,50,51,58,61,77],newlin:[48,56,71,84],newline2l:84,newline2lf:84,newline2p:84,newobj:14,newspap:59,newspaper:59,newstruct:14,newval:77,newvarnod:1,nexist:59,nexpr:5,next:[1,2,8,9,19,20,26,29,31,33,34,39,40,41,45,48,49,50,51,52,53,56,58,61,63,64,66,68,71,72,75,77,84],nextfloat:[39,76],nextidx:51,nextind:[56,84],nextpow2:75,nextpow:75,nextprod:75,nextract:5,nfc:84,nfd:84,nfield:[8,14,64],nfkc:84,nfkd:84,ngener:5,ngeq:59,ngeqslant:59,ngtr:59,ngtrsim:59,nhdownarrow:59,nhead:51,nhuparrow:59,nib:59,nice:32,nichola:74,nif:5,night:59,night_with_star:59,nine:59,niobar:59,nisd:59,niter:74,nle:54,nleftarrow:59,nleftrightarrow:59,nleq:59,nleqslant:59,nless:59,nlesssim:59,nlink:[64,69],nloop:5,nmax:26,nmemb:26,nmid:59,nmin:26,nmult:74,nni:59,nnz:[25,63],no_affinity:2,no_bel:59,no_bicycl:59,no_entri:59,no_entry_sign:59,no_good:59,no_mobile_phon:59,no_mouth:59,no_pedestrian:59,no_smok:59,node:[1,7,36,51,58,64,77],nodej:71,nofield:58,noh:[56,84],noinlin:[1,32,55],nois:[35,39,52,53],nolinebreak:59,nolta:50,nomenclatur:28,nomin:[58,71],non:[1,4,5],none:[1,21,22,25,28,29,34,35,36,41,45,46,52,53,55,57,58,61,63,77,78,85],nonempti:74,nonforking:59,nonneg:29,nonposit:74,nonprincip:74,nonscalar:41,nonsingular:74,nonstandard:64,nonsymmetr:74,nontrivi:[55,63],nonzero:[25,58,63,64,74],noop:43,nope:31,noprint:6,nor:[39,46,51,56,59,63,65,69,77],noreturn:26,norm:[52,58,74,75],normal:[2,6,8,25,26,27,28,29,31,33,34,35,40,45,47,49,50,54,56,59,61,63,64,68,69,71,74,75,76,78,84,85],normalform:84,normalize_str:84,normpath:[69,78],normtyp:74,north:59,nose:59,nostop:6,notabl:[11,26,33,44,61],notat:[25,27,31,35,39,42,44,45,46,49,54,56,58,61,66,71,77],notation:59,note:[2,3,6,7,8,9,12,14,15,16,17,19,20,21,22,25,26,27,29,30,31,32,33,34,35,36,37,39,41,44,45],notebook:[59,71],notebook_with_decorative_cov:59,notes:59,noteworthi:[23,38],notgreatergreat:59,notgreaterless:59,noth:[1,5,8,9,14,15,20,21,26,29,30,33,34,40,45,48,50,52,54,56,57,58,64,67,69,71,74,75,77,78,84],nothing:14,notic:[8,26,29,30,33,34,35,41,45,46,47,48,51,52,55,56,58],notif:[26,51,71,77],notifi:[14,26,29,33,50,51,64,71,77],notin:59,notion:[30,31,54,66,75,82],notlefttrianglebar:59,notlessgreat:59,notlessless:59,notnestedgreatergreat:59,notnestedlessless:59,notori:26,notrighttrianglebar:59,notsquaresubset:59,notsquaresuperset:59,nov:[31,68],novel:3,novemb:[31,68],now:[6,9,12,15,17,19,20,21,26,28,30,31,33,34,41,45,46,48,49,50,51,52,53,55,58,62,68,71,74,77],nowher:30,nparallel:59,npolint:59,nprec:59,npreccurlyeq:59,npreceq:59,nprecsim:59,nproc:[51,77],nref:5,nrightarrow:59,nrm2:74,nrm:8,nrow:49,nsim:59,nsime:59,nsqsubseteq:59,nsqsupseteq:59,nstep:52,nsubset:59,nsubseteq:59,nsubseteqq:59,nsucc:59,nsucccurlyeq:59,nsucceq:59,nsuccsim:59,nsupset:59,nsupseteq:59,nsupseteqq:59,nsv:74,nth:56,nthread:[51,77],ntoh:71,ntriangleleft:59,ntrianglelefteq:59,ntriangleright:59,ntrianglerighteq:59,ntupl:[5,26,41,45,51,52,58,64,74,77,81],nul:[26,64,84],nullabl:[34,51,55,57],nullexcept:[58,64],nullspac:74,num2hex:76,num:[27,28,30,35,58,72,75,76],numbers:59,numcor:85,numer:[11,26,27,28,30,31,34,36],numericextens:50,numero:59,numpi:[49,52],nut:59,nut_and_bolt:59,nutshel:50,nvdash:59,nvleftarrow:59,nvleftarrowtail:59,nvleftrightarrow:59,nvrightarrow:59,nvrightarrowtail:59,nvtwoheadleftarrow:59,nvtwoheadleftarrowtail:59,nvtwoheadrightarrow:59,nvtwoheadrightarrowtail:59,nwarrow:59,nworker:[52,77],nwovnearrow:59,nx1:49,nzind:63,nzrang:63,nzval:[25,63],obar:59,obei:76,obj1:34,obj2:34,obj3:34,obj:[6,28,46,64],objconstructor:34,object:[1,6,7,8,9,10,11],object_id:[47,64],object_inst:65,objectiddict:[47,64,66],oblique:59,observ:[16,30,39,56],obslash:59,obtain:[12,26,29,33,51,53,55,60,63,65,69,71,72,74,75,79,84],obviat:52,obviou:[1,15,19,28,29,31,34,35,51,55,56],obvious:[17,26,60],obviousli:[47,52],occas:58,occasion:[2,34,45,46,50,51,62],occur:[2,6,8,26,29,30,34,35,39,41,45,46,47,49,51,52,53,54,56,58,64,68,71,74,75,77,82,85],occurr:84,ocean:59,ocirc:59,oclock:59,ocommatopright:59,oct:[50,68,76],octal:[39,49,56,76],octave:75,october:68,octopu:59,octopus:59,odd:[19,31,32,50,52,58,61,76],oden:59,odiv:59,odot:59,odotslashdot:59,off:[1,7,29,30,42,44,47,50,51,59,71,74,77],offer:[2,25,44,71],offic:59,office:59,officer:59,offici:[41,50],official:50,offset1:19,offset:[7,15,16,19,25,40,44,45,56,64,65,71,77],often:[2,6,15,19,21,22,25,26,28,29,30,31,32,35,37,39,41,42,43,44,45,46,47,49,50,51,52,53,57,58,64,75,76,77,84],oftentim:52,oftyp:[52,64],ogonek:59,ogre:59,ogreaterthan:59,ohm:59,oiiint:59,oiint:59,oint:59,ointctrclockwis:59,ok_hand:59,ok_woman:59,old:[8,15,33,34,36,39,40,58,71,76,77],older:[5,20,40,59,74],older_man:59,older_woman:59,olessthan:59,omega:59,omicron:59,ominu:59,omiss:15,omit:[4,15,21,25,26,29,30,35,36,46,51,57,58,74,75,84],on_error:77,onc:[1,2,8,28,33,34,44,45,46,47,49,50,51,52,53,54,61,63,64,66,71,77,78],once:[6,15,21,36,39,42,47,50,51,52,71],oncoming:59,oncoming_automobil:59,oncoming_bu:59,oncoming_police_car:59,oncoming_taxi:59,one:[7,8,21,26,28,29,31,32,33,34,35,41,45,47,48,49,50,53,56,57,58,59,79,85],onerror:69,oneto:[15,41,75],ongo:30,onli:[1,3,6,8,9,11,12,14,15,19,21,25,26,27],onlin:[39,50],only:[6,32,51,52,58,64,66,69,72,74,75,77,84],onto:[1,29,34,39,49,51,71],oop:[34,50],op1:45,op2:45,opaqu:[14,26,71,73],open:[2,25,29,35,42,47,48,50,51,53,54,56,59,64,69,71,74,78],open_file_fold:59,open_hand:59,open_mouth:59,openbracketleft:59,openbracketright:59,opene:48,opening:59,oper:[1,6,7,8,11,12,19,20,21],operand:[27,28,29,30,35,44,52,58],operator:59,operm:69,ophiuchu:59,ophiuchus:59,oplu:59,opluslhrim:59,oplusrhrim:59,oppos:[2,29,32,84],opposit:[33,49,58,68,75],opr1:45,opr1f:45,opr2:45,opr2f:45,opt:[11,27,40,41,61,63,71],optical:59,optim:[7,8],optimis:76,option:[1,6,8,9],optional:[5,15,28,32],or_int:52,orang:64,orange:59,orange_book:59,ord:[56,66],order:[1,3,6,7,8,12,19,21,25,26,28,29,31,32,33,35,39,41,44,45,47,49,50,51],ordere:[32,66],orderedpair:28,ordin:51,ordinal:59,ordinalrang:82,ordinari:[8,26,34,45,46,56,58,64,74,75],ordinarili:41,ordschur:74,org:[32,34,36,40,50,51,71,74,75],organ:[3,46,49,50],organiz:58,orghr:74,orglq:74,orgql:74,orgqr:74,orgrq:74,orient:[30,42,46,58,74],origin:[1,8,19,25,26,29,30,31,50,51,52,58,59,64,66,71,72,74,78,82,84],original:59,ormlq:74,ormql:74,ormqr:74,ormrq:74,ormrz:74,ornament:59,orthogon:[19,74],orthogonal:59,oscillatori:75,oslash:59,ostream:71,ostrich:12,osx:[2,9,50,51],other:[2,3,5,6,7,8,9,11,12,14,15,17,19,21,23,25,26,27,28,29,30,31,32,33,34,35,36,38,39,40,41,42,43,44,45,46,47,48],otherlib:47,otherwis:[3,7,11,14,15,16,21,25,26,28,29,31,34,39,44,45,46,49,50,51,54,58,60,63,64,66,68,69,71,74,75,76,77,78,79,84],otim:59,otime:59,otimeshat:59,otimeslhrim:59,otimesrhrim:59,oturnedcomma:59,ouch:34,ouput:2,our:[2,9,19,21,30,31,33,34,41,46,51,52,53,85],ourselv:41,out:[1,2,3,6,8,11,19,21,25,26,27,28,31,32,33,45,46,48,49,50,51,52,53,54,58,59,61,63,64,71,74,75,77,78],outbox:59,outbox_trai:59,outcom:[31,34,47],outfil:35,outlin:29,outliv:[61,64],outofmemoryerror:[26,29,64],output:[2,6,16,18,26,32,33],output_ptr:26,outset:50,outsid:[15,28,29],outstrm:77,outward:46,over:[1,6,7,8,9,19,21,25,26,29,32,34,35,39,41,42,44,45,46,49,50,51,52,56,57,58,59,63,66,68,71,74,75,76,77,79,84,85],overal:[3,28,46,52,53],overbar:59,overbrac:59,overbracket:59,overflow:[34,35],overflowerror:[29,64],overhead:[19,26,34,39,43,49,51,52,53,74],overlap:[18,52,56,63,74,84],overlapping:59,overlay:59,overleftarrow:59,overleftrightarrow:59,overline:59,overrid:[3,11,17,36,41,58,64,66,71,77],overridden:32,overscore:59,overwrit:[35,66,74,75],overwritten:[9,25,60,63,74,75],ovhook:59,own:[1,14,15,21,26,28,29,30,35,41,42,44,45,47,49,50,51,52,53,56,58,63,64,65,66,69,71,74,76,77,84,85],owner:[50,69],ownership:15,pace:[15,42],pack:[26,57,58,63],packag:[15,20,23,25,26,31,32],packagenam:78,packet:71,pad:[26,68,76,84],page:[2,15,19,32,34,40,41,50,59,73],page_facing_up:59,page_with_curl:59,pagealloc:12,pager:[59,64],pai:[25,34],pair:[19,21,26,28,30,32,33,35,44,45,46,47,51,56,58,61,64,66,71,74,75,77],paired:59,palatalized:59,palette:59,palm:59,palm_tre:59,panda:59,panda_fac:59,paper:[39,59],paperclip:59,paq:63,paradigm:[42,46],parallel:[12,23,29,36,38,42,49],parallelogram:59,parallelogramblack:59,param:[14,51,77],paramet:[1,4,8],parameter:[8,29,52,58,74],parametr:[21,25],paren:57,parent:[6,8,14,19,22,25,33,47,53,54,55,58,61,63,64,69,77,85],parenthes:[1,5,25,26,29,32,35,37,39,45,49,56],parenthesi:[35,49],parenthesis:59,parenthet:39,parentindex:[19,63],park:59,parlanc:[31,45,58],parlett:74,pars:[1,5,6],parse_opt:9,parseerror:[29,64],parser:[1,7,9,31,32,45,56,74],part:[1,7,8,25,26,27,28,30,31,32,34,41,45,47,51,52,54,56,58,59,64,68,69,71,74,75,76,78],part_alternation_mark:59,parti:15,partial:[8,21,29,45,50,52,56,59,64,66,68,75,82],partialmeetcontract:59,partialquicksort:82,particip:[30,39,46,50,51,77],particular:3,particularli:[6,21,29,30,46,49,52,56,57,58,64],partit:77,partli:[42,50],partly_sunni:59,party:59,pass:[4,6,7,8],passport:59,passport_control:59,passwd:54,passwordless:[36,51],past:[42,45,54,64],pat:84,patch:[50,51,56],patchwork:46,path:[8,9,26,29,32,33,40],path_to_your_script:2,patholog:45,patient:75,pattern:[5,7,15,25,26,29,41,45,48,49,51,52,56,62,64,68,71,84],paus:48,paw:59,pcre:56,pdf:54,peac:15,peach:59,peak:74,peakflop:74,pear:[49,59],pearson:75,pedagog:30,pedestrian:59,pedestrians:59,peek:66,peer:77,pem:77,pen:59,penalti:[52,57,75],pencil2:59,pencil:[50,59],pend:33,penguin:59,penros:74,pensiv:59,pensive:59,pentagon:59,pentagonblack:59,penv:21,peopl:[50,69],per:[1,26,32,45,47,51,56,59,63],perceiv:84,percept:75,perfect:31,perfectli:[47,51,52,74],perform:[1,3,5,8,13,15,17,19,21,23,25,26,27,29,30,31,32,33,34,35,38,39,41,42,44,45,46,47,49,50,51],performing:59,performing_art:59,perhap:[5,6,12,15,21,28,31,34,41,45,46,51,52,56,58,77],perl:[29,30,35,36,42,54,56,71],perlr:56,perm:[63,74],perman:50,permanent:59,permiss:[52,69],permit:[3,14,21,26,36,44,58,66,76,77],permut:[30,63,74,82],permutation_alloc:26,permutation_fre:26,permutedim:63,perp:59,perpendicular:59,persever:59,persevering:59,persist:47,person:[32,45,50,59],person_frown:59,person_with_blond_hair:59,person_with_pouting_fac:59,personal:59,perspcorrespond:59,perspect:45,perspective:59,pertain:[49,61],pertin:2,perus:28,peseta:59,pharyngeal:59,phase:[2,6,27,47,75],phi:59,philadelphia:74,philosophi:[26,50],phone:59,phones:59,php:31,phrase:7,physic:[31,67,77],pick:[6,8,11,15,21,29,46,50,51,66,75,76,82],pictur:[35,52,85],pid:[51,52,77],piec:[7,18,19,28,29,51,53,57,58],piecewis:46,pig2:59,pig:59,pig_nos:59,pilcrow:59,pile:59,pill:59,pine:59,pineappl:[56,59,84],pineapple:59,pinv:74,pipe:[48,54,59,71],pipebuff:71,pipeendpoint:[18,71],pipeserv:[48,71],pisc:59,pisces:59,pistol:59,pitchfork:59,pitfal:[54,76],pittsburgh:31,piv:74,pivot:[43,74],pivotedcholeski:74,pizza:59,pkg1:78,pkg2:78,pkg:[40,47,50,56,64,78],pkgdev:[50,78],pki:51,place:[3,8,13,18,20,21,25,26,29,30,32,33,34,35,39,40,44,45,47,49,52,53,55,58,59,60,61,63,64,66,71,74,75,77,82],placehold:32,plai:[21,52],plain:[19,26,28,32,35,45,51,56,58,64,71],plan:[11,47,50,75],plan_bfft:75,plan_brfft:75,plan_dct:75,plan_fft:75,plan_idct:75,plan_ifft:75,plan_irfft:75,plan_r2r:75,plan_rfft:75,planck:59,planckconst:59,plane:75,planner:75,platform:[2,6,9,14,18,20,26,34,37,40,51,64,71,72,73,78,85],playing:59,pleas:[2,26,58,69],plot:[35,50,74],plu:[8,40,44,53,57,66,71,74],plug:[59,76],plumb:[51,54],plural:50,plus:59,plusdot:59,pluseqq:59,plushat:59,plussim:59,plussubtwo:59,plustrif:59,pluto:59,pma:50,pmap:[51,77],pmax:49,pmin:49,png:[32,71],point:[1,6,7,8,9,11,12,14,16,18,21,23,25,26,27,28,29,30,32,33,34,35,36,38],point_down:59,point_left:59,point_right:59,point_up:59,point_up_2:59,pointed:59,pointer:[4,7,8,9,14,18,19,25],pointer_from_objref:[21,26,65],pointi:58,pointing:59,pointint:59,pointless:35,points:59,polar:[58,74],pole:59,police:59,police_car:59,polici:[11,51],polish:59,poll:[71,77],poll_fd:[71,77],poll_fil:71,pollint:77,polyalgorithm:74,polygamma:75,polymorph:[30,58],polynomi:[35,39,46,75,76],poo:59,poodl:59,poodle:59,pool:[9,12,14,22,51,77],poor:[28,34],poorer:52,poorli:[19,52],pop:[1,34,57,66,71],pop_loc:1,popdisplai:71,popmeta:13,popper:59,popul:[21,25,26,49,50,76],popular:[27,42,58],port:[36,48,51,54,71,77],port_hint:71,portabl:[26,44,71,79],portion:[2,14,29,51,56,68,76],posdefexcept:74,posit:[8,25,29,31,32,35,39,44,46,50,52,56,61,63,66,71,74,75,76,82,84],posix:73,possess:51,possibl:[8,12,14,19,20,21,22,25,26,28,29,30,31,32,33,34,35,37,39,41,42,45,46,47,50,51,52,53,56],post:[5,26,34,39,44],post_offic:59,postal:59,postal_horn:59,postalmark:59,postbox:59,postexpr:5,postscript:71,posv:74,pot:59,potable:59,potable_wat:59,potato:59,potenti:[8,12,26,29,34,44,45,47,49,50,52,53,60,64,66,71,73],potr:74,potrf:74,potri:74,pouch:59,poultry:59,poultry_leg:59,pound:59,pouting:59,pouting_cat:59,pow:49,power:[5,25,28,29,34,35,41,42],power_by_squar:34,powermod:75,powerpc:26,pppprime:59,ppprime:59,pprime:59,practic:[5,8,15,26,29,30,31,32,47,51,52,56,58,71,81],prai:59,pre:[2,5,9,15,19,21,30,35,50,51],prealloc:[41,52,63,74,75,82],prec:59,precapprox:59,precaut:26,preccurlyeq:59,preced:[26,29,39],precede:59,precedes:59,preceding:59,preceq:59,preceqq:59,precis:[19,25,30,31,34,35],precnapprox:59,precneq:59,precneqq:59,precnsim:59,precsim:59,predefin:[27,30,58],predic:[63,64,66,71],predict:[33,34,52],preemptiv:51,preexpr:5,prefer:[15,32,34,40,42,50,57,64,65,69,71,74,76,82,85],prefix:[4,5,9,25,26,39,40,45,49,51,54,56,64,65,68,73,75,77,78,80,84],preload:51,prematur:26,premium:34,prepar:[5,15,47],prepars:[2,20],prepend:[8,25,32,62,66],preprocessor:45,prereleas:[40,50],prescription:59,presenc:[31,34,51,66,75],present:[1,5,28,32,34,36,39,46,48,50,52,54,58,59,63,64,66,77,84],preserv:[9,25,26,57,66,75],press:[32,40,48,74,77],pressur:51,presum:[8,28],pretend:[8,56],pretti:[31,32,41],prettiest:8,prev:71,prevent:[3,6,12,47,51,52,64],prevfloat:[39,76],prevind:84,previou:[25,29,32,33,35,40,45,50,52,53,54,58,63,64,68,71,74,76,77,79,84],previous:[7,15,16,28,52,58,64,71],prevpow2:75,prevpow:75,primari:[8,21,35,55,58],primarili:[7,56,79,83],prime:[59,60,75],primit:[7,26,27,29,33,39,42,44,51],princess:59,princip:[27,52,74],print:[2,6,7,8,9,11,16,18,21,29,32,33,34,36,40,44,45,47,48,49,50,51,52,53,54,56],print_shortest:71,print_with_color:71,printabl:[71,84],printarg:34,printer:84,printf:10,println:[5,9,16,18,26,29,33,34,36,39,41,44,45,46,48,49,51,52,54,55,56,58,66,69,71],printout:45,prints:59,prior:[30,34,35,68,69,74,83],priori:[14,26],priorit:66,prioriti:[12,66],privat:[41,45,47,50,61],privileg:71,pro:6,probabl:[15,25,26,28,29,31,34,42,44,49,52,53,58,63,64,75],problem:[6,8,26,28,29,30,34,42,45,46,50,51,52,56,57,61,74,75,76],problemat:[15,34,64],proc:[36,40,51,77],proce:[7,50,51],procedur:[2,8,29,50,53,74],proceed:77,process:2,process_exit:64,process_messag:[51,77],process_opt:9,process_run:64,processexitedexcept:64,processor:[20,36,51,52,74,85],processs:77,prod:[25,41,49,59,66],produc:[8,15,25,26,28,29,30,32,34,35,39,45,47,49,51,52,53,54,56,60,64,66,68,71,74,75,77],product:[25,26,29,42,43,49,52,54,59,60,63,66,69,74,75],prof:53,profil:[6,22,23,38,46,52],profileview:[52,53],proflin:59,profoundli:45,profsurf:59,prog:45,prognam:22,program:[2,3,7,9,14,22,23,25,26,29,30,32,33,34,35,36,38,39,40,42],program_file:[36,67,69],programfil:36,programm:[29,30,34,42,45,48,51,58],programmat:[28,32,45,50,51,55,56],progress:[21,52],prohibit:12,project:[33,42,50,52,62,74],projective:59,prolept:[31,68],promis:52,promot:[23,27,28],promote_rul:[30,64],promote_shap:63,promote_typ:[30,57,64],prompt:[6,21,26,32,36],prompt_color:40,promptstat:40,proof:59,propagate_inbound:3,proper:10,propercas:31,properli:[2,15,17,35,47,64],properti:[1,6,13,14,33],property:59,propertylin:59,propon:8,proport:[53,75],proportion:59,proportional:59,propos:[12,50],propto:59,protect:[12,50,65,69,75],proto:78,protocol:[50,78],prototyp:[26,42],prove:59,provid:[4,5,13,15,16,17,18,19,22,25,26,27,28,29,30,31,32,35,36,37,39,41,42,44,45,46,47,48,49,50,51,53,55,56,57,58,60,61,62,63,64,66,68,69,71,74,75,76,77,78,82,83,84,85],provis:28,proxi:[51,77],prurel:59,pseudo:[1,7,50],pseudoinvers:74,psi:59,pstrf:74,pthread:77,pthread_mutex_t:77,ptl:[12,74],ptld:74,ptr:[14,18,21,25],ptrdiff_t:[26,65],ptsv:74,pttr:74,pttrf:74,publicli:50,publish:34,pull:[7,50,53,74,78],pump:59,punctuat:[23,32,56,60,70],punt:19,pure:[3,15,19,35,58,76,77],pure_instruct:34,purer:58,purple:59,purple_heart:59,purpos:[4,8,14,15,16,25,26,32,35,39,45,46,47,51,52,58,61,64,67,71,77],purs:59,purse:59,pursu:68,push:[1,8,19,33,34,41,47,49,50,52,57,66,71,85],push_loc:1,pushdisplai:71,pushmeta:13,pushpin:59,put:[15,32,33,36,40,46,47,50,51,52,53,59,62,63,73,75,77,82,85],put_litter_in_its_plac:59,pwd:[22,62,69,77],pyplot:[50,74],python:[29,30,31,33,35,42,44],qbp:74,qed:59,qrcompactwy:[43,74],qrcompactwyq:74,qrfact:74,qrpackedq:74,qrpivot:[43,74],qsort:26,quad:59,quadgk:[8,75],quadrant:[59,75],quadratur:75,quadruple:59,qualifi:[34,47,61,64],qualiti:26,quantil:75,quantiti:74,quarter:[31,59,68],quarternot:59,quarterofyear:[31,68],quarters:59,quasi:[1,74],quaternion:59,queri:[14,25,29],questeq:59,question:[15,23,30,33],questioned:59,queu:[29,77],queue:[29,51,66,77],quick:[25,40,57],quickest:77,quickli:[8,51,75],quicksort:82,quiet:36,quit:[7,22,25,26,28,29,30,31,34,35,36,40,41,44,45,46,50,51,52,53,54,56,58,61,64,79,82],quot:[1,5,13,16,26],quotat:[32,56],quotation:59,quoteblock:32,quotenod:[1,45],quotient:[44,75],qux:[54,58],qword:34,r2hc:75,r2r:75,r_str:[45,84],r_stream:77,rabbit2:59,rabbit:59,race:[54,77],racehors:59,racing:59,racquet:59,rad2deg:75,radian:[27,44,75],radic:31,radical:59,radio:59,radio_button:59,radiu:8,rage:59,rail:59,railway:59,railway_car:59,rain:59,rainbow:59,rais:[1,8,15,28,29,33,34,44,45,46,47,52,56,58,64,65,69,73,76,77],raised:59,raised_hand:59,raising:59,raising_hand:59,ram:[51,59],ramen:59,ramif:31,rams:59,rand2:51,rand:[25,29,32,41,45,49,51,52,53,71,74,76,77,82],randcycl:63,randexp:76,randjump:76,randn:[25,51,52,74,76,82],random:[25,49,51,52,53,63,64],randomdevic:76,randomli:[51,52,63,76],randommatric:50,randperm:63,randstr:84,randsubseq:63,rang:[5,15,25,26,29,31,34,39,40,41,43,47,49,50,51,52,56,58,63,64,66,68,74,75,77,79,80,82,84,85],rangeexpr:5,rangl:59,rank:[51,74],rapid:85,rapidli:[9,52],rasp:59,rat:[50,59],rata2datetim:68,rata:[31,68],rate:[34,74],rather:[6,15,19,21,25,26,28,29,31,32,34,35,36,39,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,61,63,64,66,69,74,83],ratio:[27,28,30,58,76],ration:23,rational:[1,39],raw:[7,31,47,48,71],rawfd:77,rax:34,rays:59,rbind:49,rbp:34,rc1:[50,56],rc2:56,rceil:59,rcond:74,rcondv:74,rdev:[64,69],rdi:34,rdiagovfdiag:59,rdiagovsearrow:59,rdsh:59,reach:[7,21,28,29,51,71],reachabl:[14,18,64],read:[5,7,11,14,18,29,30,32,33,34],read_and_capit:48,readabl:[25,26,37,45,46,49,55,56,57,71],readandwrit:64,readavail:71,readbyt:71,readchomp:71,readcsv:71,readdir:69,readdlm:71,reader:[28,30,32,51,54,58],readi:[29,35,50,51,53],readili:52,readlin:[48,71],readlink:69,readme:[50,78],readonli:71,readonlymemoryerror:[29,64],readstr:[48,54,71],readuntil:71,real:[3,6,8,21,26,27,28,29,30,31,32,33,34,35,39,40,46,49,51,52,56,57,58,64,71,74,75,76],realist:29,realiz:[34,57,74],realli:[6,8,15,21,26,28,30,32,34,45,50,52,53,57,58,74],realloc:72,realmax:64,realmin:64,realpath:69,reappear:50,rearrang:1,reason:[3,8,15,19,20,21,22,26,28,29,30,31,34,42,45,47,51,52,53,54,56,58,61,74,75,82,84],reassign:[7,34,60],rebind:[34,44,49],rebound:34,rebuild:20,recal:[19,28,30,39,45,46,56,58],recap:58,receiv:[26,41,45,46,50,51,71,77],receiver:59,recent:[6,40,50,55,71,83],reciproc:74,recommend:[5,25,27,32,33,37,39,42,44,46,50,52,53,60,71,74,75,77],recompil:[6,47,52,58,64],recomput:50,reconstruct:[25,34,74],record_backtrac:6,recorder:59,recreational:59,rectangle:59,rectangular:[59,74],recur:[31,68],recurs:[1,7,8,12,16,19,25,26,28,29,45,47,50,53,61,64,69,74,75,77,78],recursivespinlock:77,recv:71,recvfrom:71,recycl:59,recycling:59,red:[8,40,52,59,64,71],red_circl:59,redefin:[34,60],redefinit:34,redesign:47,redft00:75,redft01:75,redft10:75,redft11:75,redirect:[40,54,64,71],redirect_stderr:71,redirect_stdin:71,redirect_stdout:71,redisplai:71,reduc:[3,17,22,26,27,34,35,39,47,49,51,52,53,56,63,64,66,74,77],reducedim:63,reduct:[49,51,52,63,66,77],redund:[30,32,45,50,57,58,71],reenable_sigint:65,reentrant:77,reentrantlock:[34,77],ref:[1,9],refer:[1,2,4],referenc:[25,26,32,33,47,51,56,58,64,65,66,73,77,84],referenti:28,reflect:14,reflector:74,regard:[49,56,72],regardless:[16,18,29,35,39,46,50,58,64],regex:[45,56,64,84],regexmatch:[56,84],region:[51,61,63,66,74,75],regist:[6,7,14,26,40,47,50,51,59,64,71,77,78,82],registered:59,registr:50,regress:74,regular:[25,34,45,51],reid:36,reim:75,reindex:19,reinit_stdio:18,reinstal:50,reinterpret:[25,26,63,76],rejectna:84,rel:[3,14,15,16,19,30,31,32,39],relat:[6,21,23,26,29,31,32,51,52,56,58,64,70,74,76],relation:59,relationship:[11,58,74],relax:[28,59],releas:[11,12,26,33],relev:[7,8,21,26,32,49,51,52,53,57,64,74,77],reli:[3,17,18,19,34,41,57,58,63,69,75,81,82],reliabl:71,reliev:59,relieved:59,reload:[34,47,50,62,64],relpath:69,reltol:[8,75],relton:74,rem:[39,44,75],remain:[7,8,19,26,29,41,45,46,50,51,52,58,63,65,67,82],remaind:[39,44,45,49,75,77,80],remedi:55,rememb:[26,29,31,33,35,50,51,52,57],remind:15,reminisc:[15,45],remot:50,remote_host:51,remotecal:[51,57,77],remotecall_fetch:[51,52,57,77],remotecall_wait:[51,77],remotechannel:[51,77],remoteexcept:[29,77],remoteref_id:77,remov:[3,15,17],remove_destin:69,remove_fram:83,renam:[45,69,71],renc:53,render:[32,33,40,58,59,71],reorder:[52,66,74],rep:52,repeat:[5,17],repeat_on:59,repeatedli:[9,29,50,52,68,71],repetit:[5,29,45,74],repl:[7,9,21,32,33],replac:[5,6,8,11,15],replbackend:55,replic:[25,44],repmat:[25,52,74],repo:[50,78],report:0,repr:84,repres:[1,4,5,8,14,16,18,19,21,25,26,27,28,29,30,31,32,33,34,39,43,45,49,51,52,53,54,56,57],represent:[1,4,7,14,16,25,28,30,31,34,39,44],reprmim:71,reproduc:[32,76],repstr:40,request:[2,3,9,25,28,29,30,33,36,48,50,51,53,63,65,71,74,76,77,84],requir:[1,6,8,12,14,15,16,17,19,25,26,28,29,30,32,33,34,35,41,42,44,45,47,48,49],requisit:[26,57],rescal:74,rese:76,resembl:[51,58],reserv:[35,47,66],reset:[1,50,53,71],reshapedarrai:[19,25,40],resid:[53,68,74],residu:74,resiz:[63,66,71],resolut:[31,48,50,64,68],resolv:[8,26,31,34,39,45,47],resort:50,resourc:[8,12,29],respect:[5,17,21,25,27,29,30,31,32,39,40,44,47,49,52,54,56,58,63,64,65,71,74,75,77,84],respond:50,respons:[26,29,33,50,51,52,64,85],rest:[1,7,25,28,30,50,51,52,66,85],restart:[29,51,62,74,77],restor:[12,64,77],restore_sign:9,restrict:[26,28,46,47,51,58,60,64,71,74,75,77],restroom:59,restructur:32,result:[1,6,7,8,11,14,15,16,21,25,26,27,28,29,30,31,32,33],result_arrai:26,resum:[29,48,77],ret:[16,33,34,52],ret_unbox:33,retain:[15,51,54,63,66],retexpr:45,rethrow:[29,33,64,77],rethrown:77,retri:[64,77],retriev:[18,25,26,31,32,33,48,51,61,66,71,72,79,84,85],retroflex:59,retry_max_delai:77,retry_n:77,retry_on:[64,77],rettyp:77,retun:51,return_to:50,returntyp:[26,65],retval:65,reus:[50,52,61,66,74,75],reusabl:[26,52,57],rev:82,revangl:59,revangleubar:59,reveal:[21,28,53,58],revemptyset:59,revers:[7,8,26,33,40,49,63,65,66,71,82,84],reverse:59,reversed:59,reverseind:63,reverseupequilibrium:59,revert:9,review:26,revisit:74,revolut:68,revolving:59,revolving_heart:59,revstr:40,rewind:59,rewrit:[15,33,35,45,51,52,56],rewritten:45,rfft:75,rfloor:59,rfn:63,rho:59,ribbon:59,rice:59,rice_bal:59,rice_crack:59,rice_scen:59,rich:[41,42,43,48,62,71],richer:[58,71],richest:71,riemann:[44,75],right:[5,7,8,12,15,25,29,30,31,32,34,35,40,41,44,48,49,50,58,59,61,63,64,66,74,75,84],right_sv:74,rightangl:59,rightanglearc:59,rightanglemdot:59,rightarrow:59,rightarrowbackapprox:59,rightarrowbar:59,rightarrowbsimilar:59,rightarrowdiamond:59,rightarrowgtr:59,rightarrowplu:59,rightarrowsupset:59,rightarrowtail:59,rightarrowtriangl:59,rightdasharrow:59,rightdotarrow:59,rightdownteevector:59,rightdownvectorbar:59,righthand:59,rightharpoonacc:59,rightharpoondown:59,rightharpoonsupdown:59,rightharpoonup:59,rightharpoonupdash:59,rightleftarrow:59,rightleftharpoon:59,rightleftharpoonsdown:59,rightleftharpoonsup:59,rightmoon:59,rightmost:74,rightouterjoin:59,rightpentagon:59,rightpentagonblack:59,rightrightarrow:59,rightsquigarrow:59,rightteevector:59,rightthreearrow:59,rightthreetim:59,righttrianglebar:59,rightupdownvector:59,rightupteevector:59,rightupvectorbar:59,rightvectorbar:59,rightwards:59,rightwavearrow:59,rightwhitearrow:59,rind:66,ring:59,ringplu:59,rins:62,rip:6,rising:59,risingdotseq:59,risk:28,ritz:74,ritzvec:74,rival:42,rma:51,rmoustach:59,rmproc:[51,77],rmt:50,rndmat:50,rng:[32,63,76,84],rnk:74,roasted:59,robust:58,rocket:59,rodft00:75,rodft01:75,rodft10:75,rodft11:75,rol:63,role:[21,32,42,52],roll:50,roller:59,roller_coast:59,room:53,rooster:59,root:[2,9,12,27,29,33,40],rootpath:69,ror:63,rose:59,rot180:63,rotat:[31,63,74],rotated:59,rotating_light:59,rotl90:63,rotr90:63,rough:75,roughli:[8,21,75,84],round:[22,25,30],round_pushpin:59,rounddown:[39,68,75,76],rounded:59,roundfromzero:75,roundimpli:59,roundingmod:[31,68,75,76],roundingmodeimaginari:75,roundingmoder:75,roundnearest:[39,75,76],roundnearesttiesawai:75,roundnearesttiesup:[31,68,75],roundtozero:75,roundup:[39,68,75,76],rout:18,routin:[25,26,29,43,47,52,58,72,74],row:[1,25,32,49,51,52,63,71,74,82],rowboat:59,rowval:[25,63],rpad:[52,84],rppolint:59,rrbracket:59,rrid:77,rrightarrow:59,rsearch:84,rsearchindex:84,rsh:59,rsi:34,rsolbar:59,rsp:34,rsplit:84,rsqhook:59,rstrip:84,rtime:59,rtld_deepbind:[67,73],rtld_first:[67,73],rtld_global:[33,67,73],rtld_lazy:[67,73],rtld_local:[67,73],rtld_nodelete:[67,73],rtld_noload:[67,73],rtld_now:[67,73],rtol:75,rubi:[29,35,36,42,54,58],rug:34,rugby:59,rugby_footbal:59,rule:[3,21,26],ruledelai:59,ruler:59,run:1,run_repl:53,runnabl:[29,32,48,77],runner:59,running:59,running_shirt_with_sash:59,runtest:[22,50,78,85],runtim:3,rval:66,rvboxlin:59,s0895479895281484:74,s13:74,s29:6,s84:74,s_1:5,s_2:5,s_3:5,s_4:5,s_j:5,saba:2,sacrif:25,safe:[12,15,26,33,47,51,52,54,56,57],safe_oper:47,safepoint:12,safeti:3,sagittariu:59,sagittarius:59,sai:[6,7,15,28,30,31,34,41,45,50,51,52,53,58,62],sailboat:59,sake:[29,59],salient:58,same:[1,2,6,8,12,15,20,21,25,26,28,29,30,31,32,33],same_typ:46,same_type_numer:46,samedi:31,sampi:59,sampl:[6,22,33,51,53,63,75,79],samuel:74,sand:59,sandal:59,sanit:0,sanitize:17,sanitize_memory:17,sans:59,sanslmirror:59,sanslturn:59,santa:59,sash:59,sat:68,satchel:59,satellit:59,satellite:59,satisfi:[8,19,31,44,50,63,68,74,75],satur:[34,54],saturdai:68,saturn:59,sauc:32,save:[7,8,9,21,25,29,31,33,36,40,41,50,53,62,74,75,79],savouring:59,saw:[21,48],saxophon:59,saxophone:59,sayhello:45,sbin:40,sbmv:74,scal:74,scala:58,scalabl:51,scalar:[4,19,25,26,35,41,43,44,49,64,74,75],scale:42,scan:13,scanner:9,scatter:52,scenario:[3,47,50,51,58],scene:48,schedul:[26,29],scheme:[1,19,35,56],school:59,school_satchel:59,schreiber1989:74,schreiber:74,schur:74,schurfact:74,schwa:59,sci:74,scientif:[26,39,42,64,74],scientist:39,scissor:59,scissors:59,scm:[1,7,50],scope:[1,23,29,34],score:59,scorpio:59,scorpiu:59,scorpius:59,scpolint:59,scratch:62,scream:59,scream_cat:59,screaming:59,screen:[40,71],scriptfil:36,scroll:59,scurel:59,sdata:[51,77],seamless:46,seamlessli:42,search:[9,16,21,32],searchabl:40,searchindex:84,searchsort:[25,82],searchsortedfirst:82,searchsortedlast:82,searrow:59,seat:59,sec:[25,44,52,72,75,77],secant:75,secd:[25,44,75],sech:[25,44,75],second:[1,5,8,9,19,21,25,26,28,29,30,31,32,33,35,39,40,41,44,45,46,47,48,49,50,51,52,53,54,56,57,58,59,63,64,68,71,72,74,75,77,79,84],secret:[32,59],section:[1,5,14,16,22,25,26,27,29,30,32,34,35,40,41,42,43,45,46,49,50,51,52,56,57,58,59,61,63,64,66,75,77],secur:51,see:[6,8,9,14,15,16,18,19,21,22,25,26,28,29,30,31,32,33,34,35,36,39,40,41,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,61,62,63,64,65,66,67,68,69,71,72,73,74,75,76,77,78,79,82,84,85],see_no_evil:59,seed:76,seedl:59,seedling:59,seek:71,seekend:71,seekstart:71,seem:[8,15,21,29,31,34,35,46,50,51,52,58,61],seen:[28,33,39,45,49],segfault:[0,1],segment:[51,59,71,75],select:[3,7,16,25,49,58,62,66,74,75,82],selector:59,selectperm:82,self:[7,18,22,28,32],selfreferenti:28,sem_siz:77,semant:[35,45,56,60,61,75,77],semaphor:77,semi:[8,74],semicircle:59,semicircular:59,semicolon:[5,25,29,35,36,40,49,53],semidirect:59,send:[40,50,51,64,71,77],sens:[15,28,30,33,34,35,44,46,47,51,54,57,58,61,64,66,74,75,77,82],sensibl:28,sensit:[3,21,52,60,64],sent:[6,48,51,54,64,71,77],sentenc:32,seovnearrow:59,sep:68,separ:[6,8,18,19,25,28,29,32,34,35,36,39,41,45,46,47,49,50,51],septemb:68,sequenc:[1,5,7,29,32,39,41,53,56,59,66,71,75,76,84],sequenti:[35,41,66,68,77],seri:[25,29,39,45,56,57,61,63,71],serial:[7,12,47,51,52,64,71,77],serialis:[9,18],serializ:77,serif:59,serifs:59,seriou:8,serious:52,serv:[3,21,28,32,35,52,58,64],server:[48,71],servic:50,session:[6,20,26,29,32],set:[6,7,9,11,17,18,19,20],set_num_thread:[74,75],set_process_titl:64,set_zero_subnorm:[52,76],setdiff:66,setenv:64,setfield:[8,64],setgid:69,setindex:[19,25,26,35,41,63,66],setjmp:1,setminu:59,setopt:71,setprecis:[39,76],setprotocol:[50,78],setround:[39,75,76],setuid:69,setup:33,setup_interfac:40,seven:[32,59],sever:[6,8,14,16,22,26,28,29,31,32,33,34,35,37,39,40,47,48,49,50,51,52,54,58,60,63,71,74,75],sf_bessel_jn_arrai:26,sha1:50,shade:59,shadow:35,shall:12,shallow:64,shape:[15,25,35,41,59,63,66,75],shaped:59,share:8,shared_map:12,sharedarrai:[51,71,77],sharp:59,shaved:59,shaved_ic:59,shed:50,sheep:59,sheer:52,shell:[26,33],shell_color:40,shell_pars:45,shield:52,shift:[15,44,49,63,66,74,75],shini:50,ship:[20,22,26,27,59],shirt:59,shoe:59,shooting:59,shortcake:59,shortcut:[47,68],shorten:68,shorter:[45,48,50,52,68],shortest:[56,71],shorthand:[2,6,9,21,25,44,49,56],shortli:28,shot:29,should:[2,3,5,6,7,8,12,14,15,17,19,20,21,22,25,26,28,30,31,32,33,34,35,36,39,40,41,44,45,46,47,48,49,50,51,52,56,57,58,61,63,64,65,66,68,71,72,74,75,77,84,85],shouldn:64,show:[8,9,21,22,25,32,33,36,40,44,45,46,47,48,50,51,53,54,57,58,59,63,64,71],show_sexpr:[16,45],showal:[71,84],showarg:45,showcompact:[48,71],shower:59,showerror:[29,71],shown:[32,36,40,47,51,52,56,58,60,64,79,85],showpar:64,shrimp:59,shuffl:[59,63],shuffle:59,shut:77,siam:74,side:[6,7,34,35,44,45,47,48,49,50,51,58,61,74],sidestep:58,sig:21,sigabrt:9,sigbus:9,sigdie_handl:[6,9],sigfpe:9,sigill:9,siginfo:9,sigint:[9,65],sigint_handl:9,sigma:[59,74],sign:[7,21,26,28,30,39],signal_strength:59,signatur:[4,6,7,8,13,16,21,26,30,32,35,40,46,51,57,58,64,71],signbit:[44,64,75],signedmultiplicativeinvers:40,signif:75,signific:[1,8,29,32,39,42,45,49,51,52,56,58,75,76],significand:[25,39,44,75,76],significantli:[39,53,58,75],signs:59,signum:64,sigpipe:9,sigquit:9,sigsegv:[6,9],sigsys:9,sigterm:[9,64],sigusr2:6,sigusrs:6,silent:[26,34,52,56,73],silhouette:59,sim:59,simd:[3,11,23],simdloop:11,simeq:59,simge:59,simgtr:59,similar:[2,3,5,7],similarleftarrow:59,similarli:[6,25,26,29,30,31,32,35,39,40,49,50,57,58,61,63,64,66,68,71,74],simle:59,simless:59,simminussim:59,simpl:[5,7,25,26,28,29,31,32,33,34,35,37,41,44,45,46],simpler:[7,31,41,45,48,58],simplest:[15,19,25,28,30,50],simplevector:[1,21],simpli:[1,8,14,19,21,26,28,29,30,31,32,33,34,35,40,41,45,46,47,50,51,56,57,58,63,65,71,75],simplic:[12,58,71],simplif:74,simplifi:[15,26,31,32,45,50,58],simplu:59,simrdot:59,simul:[35,51],simultan:[12,51,54,63,68],sin:[8,25,26,35,44,47,52,58,75],sinc:[1,6,7,8,9,12,14,19,25,26,27,28,29,30,31,32,33,34,35,39,41,44,45,46,47,48,49,50,51,52,53,54,56,57,58,61,63,64,65,66,68,71,72,74,75,77,81,82],sind:[25,44,75],sine:[44,59,74,75],sinewav:59,singl:[1,3,5,8,11,15,19,21,25,26,28,29,30,31,32,34,35,39,41,42,44,45,46,47,49,50,51,52,54,56,57,58,63,64,66,68,71,75,77,79,80,82,84],single:59,singleton:[1,6,8],singular:[43,49,51,74,75],sinh:[25,27,44,75],sinpi:[25,44,75],sit:[2,20],site:[8,34,45,52,58,69,78],sitofp:52,situat:[3,28,29,33,34,35,39,44,45,47,51,52,56,58,65,69,71,73,74,77],six:[32,56,59],six_pointed_star:59,size0:33,size1:33,size:[5,8,14],size_t:[14,21,26,33,65],sizehint:66,sizeof:[8,9,26,33,39,64,84],sizeunknown:[41,66],skeel:74,ski:59,skin:59,skip:[3,7,19,26,67,71,77,85],skipblank:71,skipchar:71,skipstart:71,skull:59,slanted:59,slash:59,sleep:[54,59,77],sleepi:59,sleeping:59,sleepy:59,slice:[19,49,52,59,63,74],slicedim:63,slight:61,slightli:[26,28,31,34,35,45,48,52,56,58,61,66,71,75,77],sloping:59,slot:[1,4,8,31,34,45,59,68],slot_machin:59,slotflag:1,slotnam:1,slotnumb:1,slottyp:1,slow:[19,25,35,42,52],slow_utf8_next:56,slowdown:52,slower:[2,6,25,29,39,42,74],slowest:19,slowli:52,slt_int:[52,85],small:[4,7,25,29,30,33,41,50,51,52,59,63,71,75,82,85],small_blue_diamond:59,small_orange_diamond:59,small_red_triangl:59,small_red_triangle_down:59,smallblacktriangleleft:59,smallblacktriangleright:59,smaller:[7,14,39,52,58,59,66,68,75,77,85],smallest:[25,34,39,64,66,74,75,76],smallin:59,smallni:59,smalltalk:58,smalltriangleleft:59,smalltriangleright:59,smart:51,smash:59,smashtim:59,smblkdiamond:59,smblklozeng:59,smblksquar:59,smc:22,smeparsl:59,smile:59,smile_cat:59,smilei:59,smiley_cat:59,smiling:59,smiling_imp:59,smirk:59,smirk_cat:59,smirking:59,smoke:59,smoking:59,smooth:75,smoothli:[46,50],smt:59,smte:59,smwhitestar:59,smwhtcircl:59,smwhtlozeng:59,smwhtsquar:59,snail:59,snake:59,snapshot:53,sneaki:21,snippet:[33,47],snow:59,snowboard:59,snowboarder:59,snowflak:59,snowflake:59,snowman:59,sob:59,soccer:59,sock:[48,71],socket:[48,51,69,71,77],soft:59,softwar:[39,50,56],software:59,sold:32,sole:26,solid:35,solidus:59,solut:[12,17,28,32,41,50,51,52,54,74,75],solv:[29,45,52,57,61,74],solve_tvar_constraint:21,solver:74,some:[1,2,5,6,7,8,11,13,14,15,19,21,22,25],some_arrai:33,some_complicated_th:37,some_different_th:37,some_old_valu:33,some_other_valu:33,some_specific_typ:33,some_valu:33,some_young_valu:33,somebodi:47,somefunct:34,someon:[28,31,50],someotherfunct:34,someth:[2,5,6,15,21,25,30,33,34,40,41,42,45,48,49,50,52,54,55,56],sometim:[4,6,15,19,25,28,29,30,31,33,34,35,42,45,46,47,48,51,52,53,58,60,64,67,74],somewhat:[21,29,48,52,56,58,61],somewher:[6,8,51,57],soon:[35,51,57,59,64,74],sooner:51,sophist:[28,30,35,45,49,54],sorensen:74,sorri:31,sortcol:82,sortedbi:[53,79],sorter:8,sortingalgorithm:50,sortperm:82,sortrow:82,sos:59,sound:59,sourc:[1,2,7,9,12,20,22,32,33,34,36,42,45,47,50,52,53,55,61,63,64,65,71,77,79,85],source:59,source_path:47,sout:59,south:59,space:[6,9,21,25,29,32,41,44,49,50,51,53,54,56,57,59,63,64,66,71,74,75,77,80,84],space_invad:59,spacing:59,spade:59,spadesuit:59,spaghetti:59,span:[25,32,51,63,74],sparam:14,sparam_sym:1,sparam_v:1,sparkl:59,sparkle:59,sparkler:59,sparkles:59,sparkling:59,sparkling_heart:59,sparsearrai:[41,57,63,74],sparsematrixcsc:[19,25,41,63,64,74],sparser:39,sparsevec:63,sparsevector:[40,63],sparsiti:25,spawn:[6,36,51,54,64,77],spawnat:[51,52,77],spdiagm:63,speak:[5,19,21,42],speak_no_evil:59,speaker:[56,59],specfunctionobject:6,special:[1,3,4,6,8,12,13,14],specif:[1,3,6,7,9,16,19,21,25],specifi:[1,3,5,11,13,15,17,19,21,25,26,28,29,30,31,32,34,35,36,39,41,44,45,46,47,48,49,50],specific:74,spectral:43,spectrum:74,spectyp:6,speech:[59,74],speech_balloon:59,speed:[4,9,42,51,53,59,71,74,76],speedboat:59,speedup:[52,71],spell:61,spend:75,spent:53,spey:[25,63,64],spherical:59,sphericalangl:59,sphericalangleup:59,spin:77,spinlock:77,spiral:59,splashing:59,splat:5,splice:[35,45,57,66,80],split:[19,32],splitdir:69,splitdriv:69,splitext:69,splitter:40,spoil:28,spoked:59,spone:[25,63],spot:[6,52,53],spouting:59,spqr:74,sprand:[25,63,74],sprandn:[25,63],springs:59,sprint:71,sprintf:[71,75],spun:8,spuriou:22,spzero:[25,63],sqcap:59,sqcup:59,sqlozeng:59,sqrint:59,sqrt:[25,27,29,33,34,35,39,40,44,49,52,53,58,59,60,74,75,76],sqrt_second:29,sqrtbottom:59,sqrtm:[43,74],sqsubset:59,sqsubseteq:59,sqsubsetneq:59,sqsupset:59,sqsupseteq:59,squar:[25,27,29,32,33,34,41,43,44,49,51,52,59,63,66,74,75],square:59,squarebotblack:59,squarecrossfil:59,squared:59,squarehfil:59,squarehvfil:59,squarellblack:59,squarellquad:59,squarelrquad:59,squareneswfil:59,squarenwsefil:59,squaresvector:41,squaretopblack:59,squareulblack:59,squareulquad:59,squareurblack:59,squareurquad:59,squarevfil:59,squeez:63,squiggle:59,squoval:59,srand:76,src:[2,7,11,15,18,50,63,65,69,74,84],sret:4,srv:40,ssa:[1,65],ssavalu:1,ssavaluetyp:1,ssh:[36,50,51,77],sshflag:[51,77],ssize_t:[26,65],sspreq:16,ssr:74,stabil:[34,52,57,82,84,85],stack:[1,3,6,8,9,23,29,33,38,52],stackfram:[55,83],stackoverflowerror:64,stacktrac:[23,55],stackwalk:55,stage:[1,6,7,12,26,50,54,64],stai:50,stand:[7,21],standalon:47,standard:[15,16,18,19,21],star2:59,star:[51,59],starequ:59,stars:59,start:[1,2,5,6,7,9,13,15,16,19,20,21,23,25,29,31,32,33,34],start_task:55,startpath:69,startswith:84,stat:[50,69,74],state:[6,9,12,21,28],statement:[1,5,13,16],static_ev:12,static_paramet:1,station:59,statist:[34,49,53,74],statistician:75,statstruct:[64,71],statu:[16,29],statue:59,statue_of_liberti:59,std:[18,41,74,75],stdcall:26,stderr:[6,18,54,64,67,71,72],stderr_fileno:18,stdin:[18,48,54,64,67,71],stdio:[6,9,10],stdm:75,stdout:[18,34,47,48,51,53,54,58,64,67,71,72,79],stdout_fileno:18,steam:59,steam_locomot:59,steaming:59,stebz:74,stefan:50,stefankarpinski:50,stegr:74,stein:74,stem:59,step:[2,6,7,8,11,15,21,28,33,45,47,50,51,52,57,66,68,71,75,76],steprang:[25,31,68],sterl:59,stev:74,stew:59,stewart:74,stick:57,sticki:69,stigma:59,stile:59,still:[6,8,15,18,26,28,29,31,32],stmt1:1,stmt2:1,stone:59,stop:[25,29,31,35,53,59,63,64,68,75,77,79],storag:[8,9,14],storagetyp:[15,63],store:[8,9,14,16,19,20,25,26,28,29,31,32,33,34,46,47,51,52,53,54,57,58,59,60,61,63,64,65,66,71,74,77,79],stori:28,str:[6,14,18,33,40,45,56,64,71,76,84],strace:2,straight:[32,52,59,74,75],straight_rul:59,straightforward:[15,21,31,36,56],straightness:59,strang:35,strange_two:52,strategi:[11,12,19,50],strawberri:59,strawberry:59,strcmp:6,stream:[1,6,9,18,23],streamer:59,street:31,strength:[48,53],strerror:72,strftime:72,stri:40,strict:[28,30,52],stricter:29,strictli:[1,19,21,29,30,49,64],strictly:59,stride1:19,stride:[5,19,25,40,52,63,74],stridedarrai:40,stridedmatrix:[25,40,74],stridedvecormat:40,stridedvector:[25,40,74],stringmim:[40,71],strip:[11,40,50,56,84],stripcc:84,stripignor:84,stripmark:84,strn:59,stroke:59,strokes:59,strong:42,strongest:45,strongli:[33,44,50,54,59,74],strptime:72,struck:59,struct:[1,4,6,7,9,14,21],structinfo:64,structur:[1,4,7,8],structure:26,strwidth:84,stuck:59,stuck_out_tongu:59,stuck_out_tongue_closed_ey:59,stuck_out_tongue_winking_ey:59,studi:[8,11],style:[16,19,23,25,29,35,38,40,45,47,49,52,56],sub2ind:[15,19,45,63],sub2ind_gen:45,sub2ind_gen_impl:45,sub2ind_loop:45,sub2ind_rec:45,sub:[32,47,74,77],subarrai:10,subclass:[46,71],subdiagon:74,subdivid:[58,75],subedot:59,subexpress:[1,29,32,45],subgroup:59,subject:[28,39,44,53,74],sublist:32,submatric:74,submatrix:74,submit:[22,50],submodul:47,submult:59,subroutin:26,subscript:[41,52,59,63],subsequ:[7,25,31,34,35,41,45,46,47,51,56,60,63,64,66,75,76,77,79],subset:[21,30,35,37,50,53,59,60,63,66,74,75,84],subsetapprox:59,subsetdot:59,subseteq:59,subseteqq:59,subsetneq:59,subsetneqq:59,subsetplu:59,subsim:59,subsitut:56,subspac:74,substanti:[34,52,53],substit:8,substitut:[26,33,40,45,56,74],substitutionstr:84,substr:[40,49,56,84],subsub:59,subsup:59,subtl:[22,48,52],subtleti:[39,61,64],subtract:[30,32,34,44,45,75,77],subtyp:[1,8,16],succ:59,succapprox:59,succcurlyeq:59,succe:[28,56,84,85],succeed:[59,74],succeeds:59,succeq:59,succeqq:59,success:[19,28,48,64,73,74,77],successfulli:[6,28,29,50,51,54,64,73],succinctli:[31,52],succnapprox:59,succneq:59,succneqq:59,succnsim:59,succsim:59,suffer:[8,52],suffic:[15,27,52,58],suffici:[30,32,46,58],suffix:[44,49,50,74,84],sugar:49,suggest:[11,26,40,50,52,53,57,66],suit:8,suitabl:[7,65,76],suitespars:74,sum:[3,25,28,30,41,49,51,52,53,59,63,64,66,74,75,76,77],sum_kbn:[57,63],sumab:66,sumabs2:[66,75],sumfoo:52,sumint:59,summar:[32,43,52,64],summarys:64,summat:63,summation:59,summedarrai:28,summer:31,sun:[59,68],sun_with_fac:59,sundai:[31,68],sunflow:59,sunflower:59,sunglass:59,sunglasses:59,sunni:59,sunris:59,sunrise:59,sunrise_over_mountain:59,sunset:59,sup:58,supdsub:59,supedot:59,superdiagon:74,superfici:34,superscript:[58,59],superset:59,supertyp:[40,41,58,64,77],suphsol:59,suphsub:59,supmult:59,supp:22,supper:74,suppli:3,support:[0,1,8,15],suppos:[26,28,29,34,47,50,54,58,85],supset:59,supsetapprox:59,supsetdot:59,supseteq:59,supseteqq:59,supsetneq:59,supsetneqq:59,supsetplu:59,supsim:59,supsub:59,supsup:59,surd:59,sure:[11,15,25,26,29,32,33,35,40,47,48,50,58,71,85],surface:59,surfer:59,surpris:[8,21,31,34,39,44,52,53],surprisingli:[45,51,52,58],surrend:51,surround:[7,26,32,45,46,58],surviv:33,suscept:[57,75],sushi:59,suspect:52,suspend:[29,51,77],suspens:28,suspension:59,suspension_railwai:59,svd:[43,49,51,52,74],svdfact:74,svdval:[43,74],svec:[8,16,21],sven:74,svn:11,swap:[75,76],swarrow:59,sweat:59,sweat_drop:59,sweat_smil:59,sweep:34,sweet:59,sweet_potato:59,swimmer:59,swirl:59,syconv:74,syev:74,syevr:74,sygvd:74,sylvest:74,sym:[5,32,45,73],symbol:[1,2,5,6,8,9,13,14,16,21,26,29,30,32,33,34,35,40],symbols:59,symdiff:66,symlink:69,symm:74,symmetr:[29,43,66,74],symmetri:[30,43,74,75],symptom:2,symtridiagon:[43,74],symv:74,sync:[34,51,52,71,77],synchron:6,synonym:26,syntact:[1,35,39,45,47,49,64],syr:74,syring:59,syringe:59,syrk:74,sys0:6,syscal:6,sysfunc:65,sysimag:36,sysimg_path:20,system:[1,6],systemat:50,systemerror:[29,64,65,69],sysv:74,sytr:74,sytrf:74,sytri:74,t_interpret:53,tabl:2,tabs:59,tack:59,tackl:56,tada:59,tag:[6,7,9,14,26,32],tail:[8,45,54,59],tailed:59,take:[6,7,8,12,16,17,20,21,22,25,26,27,28,29,30,31,32,33,34,35,36,39,41,44,45,46,47,48,49,50,51,52,53,57,58,59,64,65,66,68,71,74,75,77,79,83,84,85],takebuf_arrai:71,takebuf_str:71,taken:[5,8,29,32,36,44,46,49,51],talk:10,tan:[25,44,75],tanabata:59,tanabata_tre:59,tand:[25,44,75],tangent:75,tangerin:59,tangerine:59,tanh:[25,44,75],taocp:75,taper:59,target:[1,20,36,39,52,53,63,69,84],task:[6,7,9,19,20,23],task_local_storag:[29,77],taskhdl:29,tast:50,tau:[59,74],taup:74,tauq:74,tauru:59,taurus:59,taxi:59,tbaa:11,tcpserver:[48,71],tcpsocket:[48,51,71],tea:59,teacup:59,tear:59,teardrop:59,tears:59,teaser:52,technic:[25,32,34,35,36,40,58,63,71,75],techniqu:[6,34,35,42,52,53,58,74,75],technolog:46,tediou:45,tedium:52,telephone:59,telephone_receiv:59,telescop:59,telescope:59,television:59,tell:[1,3,32,33,46,50,56,58,64,72,84],teller:59,tempdir:69,templat:58,tempnam:69,tempor:[31,68],temporari:[1,12,18,25,34,35,45,49,52,54,62,69,82],temporarili:[29,64,65,69],tempt:[52,57],ten:[45,59],tend:[25,44,53,57,75],tendenc:52,tenni:59,tennis:59,tensor:[51,74],tent:[53,59],term:[2,5,7,15,19,21,27,28,30,31,35,41,45,46,47,54,56,58,75],termin:[26,29,33,40,48,49,50,51,56,58,64,68,71,77,84],terminolog:[26,28],ternari:29,terribl:54,territori:50,ters:[29,35,45],tesh:59,test:[2,6,8,14,15,21],test_approx_eq:85,test_approx_eq_ep:85,test_broken:85,test_error:64,test_skip:85,test_throw:85,testabl:57,testall1:17,testcb:77,testset:85,testsetexcept:85,testsocket:48,text:[31,32,36,40],text_color:40,text_str:84,textasciiacut:59,textasciicaron:59,textasciidieresi:59,textasciimacron:59,textbrokenbar:59,textdisplai:71,textdoublepip:59,textexclamdown:59,texthvlig:59,textnrleg:59,textnumero:59,textonehalf:59,textonequart:59,textordfeminin:59,textordmasculin:59,textpertenthousand:59,textperthousand:59,textphi:59,textquestiondown:59,textquotedblleft:59,textquotedblright:59,texttheta:59,textthreequart:59,texttildelow:59,texttrademark:59,textturnk:59,textual:[45,71],textvisiblespac:59,tfunc:12,tgsen:74,than:[1,2,3,6,8,15,19,21,22,25,26,27,28,29,30,31,32,33,34,35,36,39,41,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,63,64,66,68,69,71,74,75,76,77,82,83,84],thank:[39,58],thankfulli:31,thanksgiv:31,the_except:1,the_lock:77,thei:[1,6,7,8,12,19,21,25,26,27,28,29,30,31,32,34,35,39,41,42,44,45,46,47,49,50,51,52,54,56,57,58,59,60,61,63,64,65,66,71,74,76,77,78,82,84,85],them:[7,8,12,19,21,25,26,27,28,29,30,32,34,35,39,43,44,45,47,49,50,51,52,53,54,55,56,57,58,61,64,65,66,71,74,76,77,78],themselv:[16,28,32,35,42,47,51,56,58,66],theoret:12,theori:[21,34,58],therebi:[20,28,35,47,51,52,58,82],therefor:[7,8,11,16,19,21,25,26,28,30,32,35,40,43,45,49,51,52,56,57,58,59,61,62,66,71,74,75],therefore:59,therein:47,thereof:[16,19,58,77],theta:[32,59],thi:[1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,25,26,27,28,29,30,31,32,33,34,35,36,37,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,63,64,65,66,69,71,72,73,74,75,76,77,78,79,82,83,84,85],thickspac:59,thin:[33,59,74],thing1:47,thing2:47,thing:[8,15,19,21,22,28,31,32,33,34,45,48,50,51,52,54,56,57,58,61,75,82],think:[2,19,29,30,31,34,48,51,58],thinspac:59,third:[5,19,25,26,28,30,31,32,35,44,46,53,56,59,63,75,84],thirty:59,this_function_does_not_exist:33,thiscal:26,thisindex:19,thorn:59,those:1,though:[9,19,21,25,26,27,30,31,32,33,35,41,46,48,49,50,53,58,64,74,84,85],thought:[34,51,58,59],thought_balloon:59,thousand:[52,59],thread:[6,10],threadid:[51,65,77],threadpool:51,threadsaf:[12,77],three:[4,8,21,26,29,32,35,39,41,44,45,46,47,50,51,52,54,56,57,58,59,61,71,74,75,84],threearg:34,threedangl:59,threeunderdot:59,threshold:[30,74],threw:[35,85],through:[3,6,7,8,9,12,15,18,21],throughout:[8,15,18,28,41,57,58],throughput:54,throwing:59,thrown:[26,28,29,30,33,56,57,58,64,71,74,77,83,85],thta:4,thu:[3,12,15,25,26,28,30,31,34,39,44,45,46,48,50,51,52,56,57,58,61,66,68,75],thumb:52,thumbs:59,thunk:16,thursdai:[31,68],tic:[49,52,64],ticket:59,tidi:50,tie:[28,59],tieconcat:59,tiger2:59,tiger:59,tight:[3,52,64],tightli:[27,44,63],tightly:59,tild:[59,69],tilde:59,tildetrpl:59,tile:59,till:[51,77],time:[1,2,5,6,7,8,9,12,15,17,20,22,23,25,26,29,31,32,33,34,35,42,43,44,45,46,47,49,50,51],time_n:64,timedout:71,timedwait:77,timeit:52,timelimit:75,timelin:[31,68],timeout:[71,77],timeout_:71,timeperiod:31,timer:[51,64,71],times:59,timesbar:59,timestamp:69,timestep:52,timestr:72,timev:64,timezon:[31,68,72],tini:[51,52],tip:0,tired:59,tired_fac:59,titl:[32,64,74],titlecas:84,tmp:[20,35,40,50,53,62,71],tmstruct:72,to_funct:6,to_index:3,to_shap:41,toc:[49,52,64],todai:[34,68],todo:9,toea:59,tofirst:68,togeth:[7,8,19,28,29,30,32,36,40,45,46,47,51,53,56,57,64,68,77,82,84],toggl:[47,66],toi:[41,51],toilet:59,token:[7,50,84],tokyo:59,tokyo_tow:59,tol:[30,74,75,85],tolast:68,told:26,toler:[30,64,74,75,85],tomato:59,tona:59,tone:59,tonext:[31,68],tongu:59,tongue:59,too:[5,8,14,18,19,32,33,35,41,45,49,50,51,52,58,64,71],took:[34,64],tool:[2,11,22,32,45,50],toolchain:17,top:[8,11,12,14,15,16,26,32,39,41],top_fram:55,topbot:59,topdown:69,tophat:59,topic:[29,32,39,40,64],toplevel:[1,7,9,12,16],topmost:71,toprev:[31,68],topsemicircl:59,toq:64,torch:59,tosa:59,total:[15,50,51,53,64,68,71,75,82,85],touch:69,towa:59,toward:[2,30,31,39,44,75],tower:59,trace:[6,22,23,38],track:[2,7,11,14,29,36,41,50,51,52,53,55,64,77,79],tractor:59,trade:[42,59],trademark:59,tradit:[27,35,41,42,46,56,58,71,84],tradition:[30,35,42,58],traffic:[51,59],traffic_light:59,trail:[26,35,36,40,56,58,63,71,76,84],trailing_on:76,trailing_zero:76,train2:59,train:59,tram:59,tramway:59,tran:74,trang:51,transa:74,transact:[74,77],transb:74,transcod:[56,84],transfer:77,transfinite:59,transform:[7,8,25,28,35,45,49,63,64,66,74,75,77,82,84],transit:31,translat:9,transliter:49,transpar:[14,34],transpos:[25,35,40,41,63,74,80],transposit:[49,74],transversal:59,trap:34,trapezium:59,trapezoid:74,trash:78,travers:[64,69],travi:50,tray:59,trcon:74,treat:[25,26,45,49],tree:[2,7,16,32,33,45,50,53,59,69,79],trend:59,trevc:74,trexc:74,tri:[7,26,31,33,64,71,77],trial:[51,52],triangl:[35,44,74],triangle:59,trianglecdot:59,triangledown:59,triangleleft:59,triangleleftblack:59,trianglelefteq:59,triangleminu:59,triangleplu:59,triangleq:59,triangleright:59,trianglerightblack:59,trianglerighteq:59,triangletim:59,triangular:[43,59,74],triangular_flag_on_post:59,triangular_rul:59,trick:52,tricki:[12,31,44],trickier:47,trident:59,tridiagon:[43,74],trigamma:75,trigger:[6,8,16,21,47,53,64,77],tril:74,trim:63,trip:[7,49,52],tripl:[32,49],triple:59,tripleplu:59,triu:74,triumph:59,trivial:[8,34,50,51,52],trmm:74,trmv:74,trolleybu:59,trolleybus:59,trophi:59,trophy:59,tropical:59,tropical_drink:59,tropical_fish:59,troubl:[51,56,57],trrf:74,trsen:74,trsm:74,trsv:74,trsyl:74,trtr:74,trtri:74,truck:59,trumpet:59,trunc:[25,26,44,52,68,75],truncat:[26,30,44,47,52,53,68,71,75],try_block:1,trylock:77,trypars:76,tst:62,ttl:71,tty:[9,18,48,71],tty_col:53,tue:[31,68],tuesdai:[31,68],tulip:59,tunnel:[51,77],tupl:[1,3,4,5,6,8,11,13,14,15,16,18,19],tuple2:58,turban:59,turn:[1,7,8,13,28,29,31,36,47,52,53,56,58,64,65,74],turnangl:59,turned:59,turnediota:59,turnednot:59,turnstile:59,turtl:59,turtle:59,tutori:36,tvar:21,twelve:59,twice:[44,53],twisted:59,twisted_rightwards_arrow:59,twister:76,two:[1,6,8,14,15,19,21,25,26,28,29,30,31,32],two_heart:59,two_men_holding_hand:59,two_women_holding_hand:59,twocap:59,twocup:59,twoheaddownarrow:59,twoheadleftarrow:59,twoheadleftarrowtail:59,twoheadleftdbkarrow:59,twoheadmapsfrom:59,twoheadmapsto:59,twoheadrightarrow:59,twoheadrightarrowtail:59,twoheaduparrow:59,twoheaduparrowcircl:59,twonot:59,twostep:45,txt:[48,53,54,64,71],typ:[1,45,64],type1:64,type2:64,type_intersection_match:21,type_match:21,type_match_morespecif:21,type_morespecif:21,typea:49,typealia:[26,32,58,81],typeassert:[8,26,58],typeb:49,typecach:12,typecheck:52,typeconstructor:8,typed_comprehens:1,typed_hcat:1,typed_vcat:1,typedef:[14,21,26],typedslot:1,typeerror:[29,58,64],typeinf:[7,12,53],typeinf_uncach:8,typeintersect:[21,64],typejoin:[21,64],typeless:42,typemapentri:47,typemaplevel:47,typemax:[34,39,53,64,71,75,76,79],typemin:[34,39,64,75,76],typenam:8,typesof:16,typic:[1,2,3,7,8,13,14,22,25,26,27,28,29,30,33,35,39,41,42,46,47,49,51,53,55,56,57,58,63,64,65,71,74,75,76,78,82,85],typo:50,tzrzf:74,u10ffff:56,u110000:56,u2200:[45,56],u2203:56,u5272:59,u5408:59,u55b6:59,u6307:59,u6708:59,u6709:59,u6e80:59,u7121:59,u7533:59,u78:56,u7981:59,u7a7a:59,u80:56,uax:84,ucfirst:84,udp:71,udpsocket:71,uff:56,uglier:52,uid:[21,64,69],uint128:[39,46,49,58,76,77],uint128_str:1,uint16:[26,30,39,46,49,58,65,71,76],uint16_t:14,uint32:[26,39,44,46,49,58,63,65,76,84],uint32_t:[8,9,14],uint64:[26,39,46,49,58,64,65,76],uint8:[1,21,26,30,39,44,46,48,49,52,56,57,58,64,65,71,76,77,84],uint8_t:9,uint:[26,39,58,64,65,71,83],uintmax_t:[26,65],uintxx:84,ularc:59,ulblacktriangl:59,ulcorn:59,ull:49,ultim:[28,29,34,71],ultriangl:59,umbrella:[58,59],umfpack:[43,74],umfpacklu:[43,74],uminu:59,unabl:[6,29,51],unalloc:71,unalt:56,unam:67,unambigu:58,unamus:59,unamused:59,unannot:16,unari:[25,39,44,75],unassign:[28,84],unavoid:[15,47,50,51],unawar:31,unbalanc:51,unbind:34,unbound:[21,34,76],unbox:[7,11,14,33],uncaught:29,uncertain:[31,52],uncertainti:[52,53],unchecked_aliasing_permut:63,unchecked_noalias_permut:63,unclear:[12,49],uncommon:50,uncondit:1,uncondition:52,unconnect:[51,77],unconstrain:[46,58],unconvent:[15,63],undeclared_vari:55,undecor:32,undef:21,undefin:[1,14,26,28,35,41,44,45,46,51,57,63,64,65,66,75,77],undefreferror:[28,29,64],undefvarerror:[29,45,61,64],under:[6,19,21],underag:59,underbar:59,underbrac:59,underbracket:59,underdot:59,underflow:[34,75],undergo:2,underleftarrow:59,underleftharpoondown:59,underleftrightarrow:59,underli:[15,19,21,25,26,31,34,39,48,51,52,65,71,74,77],underneath:74,underrightarrow:59,underrightharpoondown:59,underscor:[26,39,57,60],underscore:59,understand:[8,14,16,21,26,29,30,39,42,45,47,51,52,53,55],undesir:54,undoe:75,unduli:58,unencrypt:51,unequ:64,unescap:[56,71,84],unescape_str:[71,84],unevenli:63,unexpect:[29,31,52,60,63,74,76],unexpectedli:[2,22,25,34,52,58],unexport:[3,63],unfamiliar:39,unfavor:58,unfetch:51,unfortun:[19,34,52],unhappi:34,unicod:[23,32,35,38,40,42],unicodeerror:[29,56],unifi:[18,42],unified:59,uniform:[18,19],uniformli:[25,76],uniformsc:[43,74],unimpl:26,uniniti:[17,25,26,28,34,63,71],unintend:3,uninterpret:26,unintuit:[29,42],uninvit:28,union:[8,15],uniqu:[1,6,14,21,27,40,45,46,47,50,53,63,64,66,69,74,75,77],uniquedbyid:47,unit:[23,44,49,52,59,70,74,76,84],unitari:[74,75],unitrang:[15,19,25,52,57,63,66,74],univers:21,universal:59,universaldeclarationofhumanrightsstart:60,unix2datetim:68,unix:[26,48,50,51,53,54,64,68,69,71,78],unknown:[1,11,12,14,26,58],unless:[20,26,47,50,52,53,54,56,57,58,60,61,63,64,68,74,76,77,79,82,84,85],unlik:[25,29,31,32,49,54,56,65],unlike:[1,21,25,29,31,34,41,44,49,51,58,61,77],unlimit:58,unlock:[34,59,77],unmark:71,unmatch:84,unmodifi:[49,69,74,77,82],unnam:65,unname:26,unnatur:42,unnecessari:[31,32,39,48,52,56],unnorm:75,unobtrus:[42,58],unord:[32,64,66,75],unorder:32,unpack:[8,26],unpermut:74,unpin:50,unpreced:42,unpredict:[34,51,64],unquot:[16,45,49,56],unrel:[47,56],unrestrict:12,unrol:[34,45],unsaf:[14,26,36],unsafe_convert:[25,26,65],unsafe_copi:65,unsafe_load:[26,57,65],unsafe_pointer_to_objref:[26,65],unsafe_read:71,unsafe_stor:[26,65],unsafe_str:[26,84],unsafe_trunc:75,unsafe_wrap:[26,65,84],unsafe_writ:71,unscal:74,unset:64,unsettl:34,unshift:66,unsign:[26,39,44,49,58,65,75,76],unsort:25,unspecifi:[28,36,52,66,75,77],unstabl:[34,52,56],unsupport:[26,45],untest:32,until:[7,18,21,26,28,29,46,50,51,58,68,71,75,77],untouch:34,unus:[1,8],unusu:[50,52],unwant:[49,57],unwind:[5,9,29],upand:59,uparrow:59,uparrowbar:59,upcom:47,updasharrow:59,updat:[15,33,34,35,40,41,44,47,49,50,51,64,74,78],updownarrow:59,updownarrowbar:59,updownharpoonleftright:59,updownharpoonrightleft:59,upepsilon:59,upequilibrium:59,uperm:69,upgrad:[50,78],upgrade:50,upharpoonleft:59,upharpoonright:59,upharpoonsleftright:59,upin:59,upint:59,upkoppa:59,uplo:74,upload:50,uplu:59,upmu:59,upnu:59,upoldkoppa:59,upomicron:59,upper:[21,43,50,56,59,60,74,75,77,84],uppercas:[26,48,56,84],uppertriangular:[43,74],upsampi:59,upsilon:59,upstigma:59,upstream:[50,78],upuparrow:59,upvarbeta:59,upward:59,upwards:59,upwhitearrow:59,uranu:59,uranus:59,urarc:59,urblacktriangl:59,urcorn:59,url:[32,50,64,69,74,78],urtriangl:59,usa:50,usabl:[6,7,58],use64bitint:2,use:[11,18,20,25,27,32],use_llvm_shlib:11,use_mmap:71,useclang:17,used:[51,56,64,71],usefulli:[6,46],user:[3,7,11,15,19,20,22,25,26,28,29,30,31,32,34,35,36,39,40,42,45,47,49,50,51,52,53,54,57,58,59,60,64,68,69,71,74,77,79,84,85],userdata:51,userimg:20,userimg_path:20,usernam:50,username:50,using:[0,5],usr:[2,6,11,33,40],usual:[3,4,6,11,25,27,28,31,32,35,42,44,47,48,50,52,53,55,57,61,63,64,71,74,75,76,83],usualli:[52,64,74],ut1:31,utc:[2,36,40,68],utf16:50,utf16string:56,utf32string:56,utf8:[36,60],utf:[26,42],util:[11,40,45,47,58],utinstant:[31,68],uuparrow:59,uv_async_send:[26,64],uv_handle_type:18,uv_handle_type_max:18,uv_stream_t:18,uv_threadpool_size:[51,77],uv_writ:[9,18],uverror:64,uvw:18,va_arg:26,va_list:18,vagu:25,val1:1,val2:1,val:[26,33,45,49,52,58,63,64,74,75,77,85],valgrind:0,valid:[1,15,18,19,20,25,26,28,30,31,33,34,39,41,44,47,49,50,56,57,58,60,63,64,65,66,68,69,71,72,73,74,75,76,77,79,84],valtyp:66,valu:[1,4,5,6,7,8,9,14,15,18,19,21,25],value1:[49,61],value2:49,value3:61,value_t:6,valuetodayofweek:31,valuetomonth:31,valuetyp:66,van:74,var1:[1,61],var2:[1,61],var3:61,var_sym:45,vararg:[8,15,21,26],varbarwedg:59,varcarriagereturn:59,varclubsuit:59,vardiamondsuit:59,vardim:75,vardoublebarwedg:59,varepsilon:59,varheartsuit:59,varhexagon:59,varhexagonblack:59,varhexagonlrbond:59,vari:[34,40,55,71,74],variabl:[1,5],variablenam:49,variad:[1,26],varianc:75,variant:[12,26,32,44,52,56,59,71,74,75,79,82],variat:[8,23,34],variation:59,varieti:[3,16,29,30,58],variou:[7,9,14,26,29,30,36,37,43,46,48,50,51,54,56,58,64,75,84],varisin:59,varisinobar:59,varkappa:59,varlrtriangl:59,varm:75,varni:59,varniobar:59,varnoth:59,varointclockwis:59,varphi:59,varpi:59,varrho:59,varsigma:59,varspadesuit:59,varstar:59,varsubsetneqq:59,varsupsetneq:59,vartheta:59,vartriangl:59,vartriangleleft:59,vartriangleright:59,varveebar:59,vast:[8,45,47],vastli:[20,52],vcat:[1,25,35,49,63],vdash:59,vdot:59,vec:[34,52,59,63],vecdot:74,vecelement:[26,81],vecnorm:[74,75],vect:1,vector1:35,vector2:35,vector:[1,3,4,11,15],vectorize_1arg:25,vectorize_2arg:25,vee:59,veebar:59,veedoublebar:59,veeeq:59,veemidvert:59,veeodot:59,vehicle:59,veil:59,vendredi:31,venu:59,ver:78,verbatim:45,verbos:[45,56,58,64],verbose:6,verbose_fussy_sqrt:29,veri:[1,2,6,7,8,13,19,21,28,29,30,32,34,41,42,45,46,48,49,50,51,52,53,56,58,63,66,75,77,82],verifi:[26,28,33,50,51,52,63,74,85],versa:[19,44,64],versioninfo:[2,64],versionnumb:[50,56,67,78],versu:[27,52,62],vert:59,vertcat:49,vertic:[32,49,63,80],vertical:59,vertical_traffic_light:59,vertoverlai:59,very:59,verymuchless:59,via:[4,7,8,11,15,21,26,32,34,35,36,42,46,47,49,50,51,52,53,54,56,58,61,62,63,64,71,74,75,76,77,81,82,84,85],vibration:59,vibration_mod:59,vice:[19,44,64],victory:59,video:[36,59,71],video_camera:59,video_gam:59,videocassette:59,view:[6,7,16,19,25,31,35,45,47,51,53],viewdata:59,viewindex:19,viewing:59,violat:[12,28,45,58],violin:59,virgo:59,virtual:[7,49],visibl:[25,26,29,31,35,47,49,50,51,61,64,71],visit:[25,63],visual:[1,35,39,50,52,78,84],voiced:59,vol:[74,75],volcano:59,voltage:59,volum:54,volume:59,vrectangleblack:59,vsl:74,vsr:74,vulgar:59,vvdash:59,vvert:59,vysmblkcircl:59,vysmblksquar:59,vysmwhtsquar:59,w_in:74,w_stream:77,wai:[5,6,7,8,9,11,15,18,19,21,22,25,26,28,29,30,32,33,34,36,39,41,42,45,47,48,49,50,51,52,53,56,57,58,61,63,64,71,75,77,82,85],wait:[2,7,12,26,29,34,48,51,52,54,64,71,77],waitfor:77,wake:[64,77],wakeup:26,walk:[6,15,59,69],walkdir:69,waning:59,waning_crescent_moon:59,waning_gibbous_moon:59,want:[3,5,6,7,13,15,22,26,28,29,30],warm:21,warn:[11,18,22],warning:[29,59,60],wast:[25,52],watch:[6,21,49,59,71],watch_fil:71,water:59,water_buffalo:59,watermelon:59,wave:[52,59],waves:59,waving:59,wavy:59,wavy_dash:59,waxing:59,waxing_crescent_moon:59,way:59,wchar_t:[26,65,84],wdai:72,weak:[9,66],weakkeydict:66,weakref:47,weari:59,weary:59,web:50,websit:[32,50],wed:[50,59,68],wedding:59,wedg:59,wedgedot:59,wedgedoublebar:59,wedgemidvert:59,wedgeodot:59,wedgeonwedg:59,wedgeq:59,wednesdai:[31,68],week:[31,68],weight:[25,77],well:[7,8,17,22,29,30,31,32,33,39,40,41,43,44,46,49,50,51,52,53,56,57,58,60,61,63,64,74,75,82],were:[5,6,8,19,26,28,31,34,35,40,44,46,47,49,53,58,74,82],weren:29,west:59,wget:69,whale2:59,whale:59,what:[2,5,6,7,8,12,15,19,21,28,29,30,31,32,33],whatev:[7,9,26,45,50,61,78,82],whatsoev:56,wheel:59,wheelchair:59,when:1,whenc:77,whenev:[7,14,26,28,29,32,35,36,46,47,51,52,64,74],where:[1,3,4,5,6,8,9,11,15,18,19,20,21,25,26,27,28,29,31,32,33,34,35,39,40,41,42,44,45,46,47,49,50,51,52,53,55,57,58,61,63,64,65,66,67,68,69,71,73,74,75,76,77,82,84,85],wherea:[3,5,15,19,21,25,45,49,54,56,58,71,74,75,79],wherebi:25,wherein:[51,58],wherev:[18,32,44,50,66],whether:[1,5,7,8,12,15,18,19,21,27,28,29,30,31,32,33,35,36,39,42,43,44,46,47,50,52,53,55,56],which:[1,3,5,6,7,8,9,12,13,14,15,16,17,19,20,21,25,26,28,29,30,31,32,33,34,35,37,39,40,41,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,61,62,63,64,65,66,67,68,69,71,72,73,74,75,76,77,78,79,82,84,85],whichev:[51,63,64,77],white:[40,59,71],white_check_mark:59,white_circl:59,white_flow:59,white_large_squar:59,white_medium_small_squar:59,white_medium_squar:59,white_small_squar:59,white_square_button:59,whitearrowupfrombar:59,whiteinwhitetriangl:59,whitepointerleft:59,whitepointerright:59,whitespac:[32,39,40,45,49,50,56,71,84],whizbang:50,who:[6,29,33,34,39,47,50,64,69,79],whoa:46,whole:[7,9,25,26,28,47,51,52,56,58,65,71,75,84],whom:56,whoop:55,whose:[1,8,26,28,30,35,44,47,48,51,56,58,63,64,66,69,71,74,75,84],whthorzov:59,whtvertov:59,why:[2,5,21,26,29,31],wide:[26,30,50,53,56,59,84],wideangledown:59,wideangleup:59,widebridgeabov:59,widemul:75,widen:[8,28,64],wider:[25,53],wideutild:59,width:[26,31,35,56,68],wil:50,william:39,willing:34,win32:72,win64:56,wind:[50,59],wind_chim:59,window:[6,9,20,26,33,48,50,51,53,64,69,71,72,77],windows_hid:64,windows_verbatim:64,windows_vers:64,wine:59,wine_glass:59,wings:59,wink:59,winking:59,winston:50,wint_t:26,wip:50,wise:[34,49,52,74,75],wish:[3,13,25,29,50,51,52,63,71,77],with_keyword:52,withenv:64,within:[3,6,13,17,21,25,26,30,32,34,35,39,45,47,49,50,51,52,56,61,62,63,64,66,67,71,74,75,77,84],without:[5,7,13,14,15,19,25,26,28,29,32,33,34,35,39,40,43,45,46,47,49,50,51,52,54,56,57,58,59,60,61,62,63,64,65,66,68,71,74,75,76,77,78,83,84,85],wittingli:20,wizardri:63,woken:[64,77],wolf:59,woman:59,womans:59,womans_cloth:59,womans_hat:59,women:59,womens:59,won:[45,47,50,54,58],word:[7,8,15,21,30,32,34,35,39,40,44,45,46,49,50,53,54,57,58,59,60,67,71],word_size:[2,39,67],work:[5,6,7,8,9,10],workaround:34,workcolptr:63,worker:[6,22,36,51,52,54,59,65,74,77],worker_id_from_socket:77,workerconfig:[51,77],workerpool:77,workflow:[23,34,38],working_dir:64,workload:51,workspac:[47,61,64,74],world:[6,9,28,45,48,52,54,56,58,60,64,84],worri:[26,30,47,48,50,59],worried:59,wors:[19,34,52,58,61],worst:8,worth:[15,21,44,51,57,58,75,77],worthwhil:52,would:[5,7,8,11,12,15,19,20,21,22,25,26,28,29,30,31,32,34,35,44,45,46,47,48,49,50,51,52,53,54,56,57,58,60,61,63,64,65,66,68,71,75,76,77,82,84],wouldn:[1,34],wrap:[1,8,15,26,29,31,33,34,35,39,41,45,49,50,52,57,62,64,65,68,71,74,77,84],wraparound:[39,64],wrapped:59,wrapper:[4,7,9],wreath:59,wrench:[19,59],wrinkl:[8,28],writabl:[71,77],write:[3,5,6,9,12],writeal:54,writecsv:71,writedlm:71,writefunc:71,writelock:12,writer:[51,54],written:[1,4,7,15,21,25,26,27,29,32,33,34,35,36,40,41,42,44,45,46,47,48,49,50,51,52,53,54,57,58,64,65,71,72,75,77],wrong:[2,26,29,35,45,47,64,77],wry:59,www:[32,74,75],x7f:56,x80:56,x86:[26,81],x86_64:[2,26,36,40],x_1:5,x_2:5,x_3:5,x_str:1,xarg:33,xchg:77,xcorr:75,xdata:33,xff:[39,45,56],xggsvd3:74,xinc:52,xor:[44,49,59,77,80],xylophon:[54,56],xyz:64,yank:40,yao:74,ydai:72,year:[31,50,52,64,68,72],yearmonth:[31,68],yearmonthdai:[31,68],yellow:[40,59,71],yellow_heart:59,yen:59,yet:[8,13,15,21,26,29,31,35,39,42,45,46,48,50,52,56,58,64,71,75,85],yield:[1,5,26,34,35,39,51,52,64,66,68,71,75,76,77],yieldto:[29,77],yml:50,ymm:68,yogh:59,you:[2,3,5,6,8,11,13,14,15,17,19,21,22,25,26,27,28,29,30,31,32,33,34,35,36,40,41,42,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,60,62,63,64,65,66,68,71,72,74,75,76,77,78,79,82,85],young:33,your:[2,3,6,13,15,17,22,25,26,28,29,32,34,35,40,41,44,45,47,48],yourself:[21,26,28,32,34,50,52,53],youtub:36,yum:59,yup:59,yyyi:68,yyyymm:31,yyyymmdd:[31,68],zap:59,zbar:59,zero:[3,4,5,9,15,25,26,27,28,29,30,31,33,34,35],zeroarrai:15,zeromq:51,zerorang:15,zerox:45,zeta:[25,44,59,75],zigzag:59,zip2:66,zip:[49,66,71],zlocal:26,zmat:74,zone:31,zzz:59},titles:[\"Developing/debugging Julia&#8217;s C code\",\"Julia ASTs\",\"Reporting and analyzing crashes (segfaults)\",\"Bounds checking\",\"Calling Conventions\",\"Base.Cartesian\",\"gdb debugging tips\",\"Eval of Julia code\",\"Julia Functions\",\"Initialization of the Julia runtime\",\"Documentation of Julia&#8217;s Internals\",\"Working with LLVM\",\"Proper maintenance and care of multi-threading locks\",\"Talking to the compiler (the <code class=\\\"docutils literal\\\"><span class=\\\"pre\\\">:meta</span></code> mechanism)\",\"Memory layout of Julia Objects\",\"Arrays with custom indices\",\"Reflection and introspection\",\"Sanitizer support\",\"printf() and stdio in the Julia runtime\",\"SubArrays\",\"System Image Building\",\"More about types\",\"Using Valgrind with Julia\",\"Julia Documentation\",\"Julia Documentation\",\"Multi-dimensional Arrays\",\"Calling C and Fortran Code\",\"Complex and Rational Numbers\",\"Constructors\",\"Control Flow\",\"Conversion and Promotion\",\"Date and DateTime\",\"Documentation\",\"Embedding Julia\",\"Frequently Asked Questions\",\"Functions\",\"Getting Started\",\"Handling Operating System Variation\",\"The Julia Manual\",\"Integers and Floating-Point Numbers\",\"Interacting With Julia\",\"Interfaces\",\"Introduction\",\"Linear algebra\",\"Mathematical Operations and Elementary Functions\",\"Metaprogramming\",\"Methods\",\"Modules\",\"Networking and Streams\",\"Noteworthy Differences from other Languages\",\"Packages\",\"Parallel Computing\",\"Performance Tips\",\"Profiling\",\"Running External Programs\",\"Stack Traces\",\"Strings\",\"Style Guide\",\"Types\",\"Unicode Input\",\"Variables\",\"Scope of Variables\",\"Workflow Tips\",\"Arrays\",\"Essentials\",\"C Interface\",\"Collections and Data Structures\",\"Constants\",\"Dates and Time\",\"Filesystem\",\"The Julia Standard Library\",\"I/O and Network\",\"C Standard Library\",\"Dynamic Linker\",\"Linear Algebra\",\"Mathematics\",\"Numbers\",\"Tasks and Parallel Computing\",\"Package Manager Functions\",\"Profiling\",\"Punctuation\",\"SIMD Support\",\"Sorting and Related Functions\",\"StackTraces\",\"Strings\",\"Unit Testing\"],titleterms:{\"abstract\":[41,52,58],\"break\":52,\"byte\":56,\"case\":[28,30],\"catch\":[29,57],\"default\":[35,47],\"final\":29,\"float\":[39,57],\"function\":[5,6,8,25,26,29,31,32,33,34,35,44,45,46,52,57,63,64,66,68,74,75,76,78,82],\"import\":[1,34],\"new\":[30,50],\"null\":34,\"return\":[26,33,35],\"short\":29,\"static\":57,\"throw\":[29,33],\"try\":[29,57],_start:9,abi:4,about:[21,26,57],absolut:[44,47],abstractchannel:51,abstracttestset:85,abstractunitrang:15,abus:52,access:[26,32,33,52,58],accessor:[31,68],accumul:53,adding:[8,50],address:[17,48],adjuster:[31,68],admonit:32,advanc:[32,45],aka:[29,52],algebra:[43,74],algorithm:82,alia:11,alias:58,all:64,alloc:[14,34,52,53],allocat:15,allow:60,along:52,ambiguiti:46,analysi:[11,53],analyz:2,annot:15,annotat:52,anonym:[5,35],any:21,append:57,arbitrari:39,argument:[5,8,26,34,35,46,52,57],arithmet:[31,34,39,44],around:64,arrai:[15,25,33,34,41,51,52,56,63,77],asan:17,asked:34,assignment:[25,63],associ:66,ast:1,asynchron:34,attent:52,auto:26,automat:33,availabl:[50,51],avoid:[52,54,57],background:[15,39],backtrac:55,bare:47,barrier:52,base:[5,9,57,62,85],basic:[5,25,45,48,53,56,62,63,85],behavior:[35,39],beta:34,between:[18,34],bigfloat:76,bind:40,bit:[14,26,58],bitarrai:63,bitwis:44,blas:74,block:[1,32,35,61],bold:32,bootstrap:[2,6,7],bottom:21,bound:[3,15],bracket:1,branch:50,breakpoint:6,broadcast:25,broken:[12,85],browser:62,build:[6,11,20,33,45],built:29,builtin:8,call:[1,3,4,6,8,26,33,34],callback:26,caller:57,can:34,care:[12,57],cartesian:[5,19],caveat:22,ccall:[26,77],certain:[6,34],cfunction:26,chain:44,chang:[50,52],channel:51,charact:56,check:[3,15,58],checkout:50,circuit:29,claus:29,clear:53,closur:8,cluster:[51,77],clustermanag:51,code:[0,7,15,18,26,32,45,50,51,57],code_warntyp:52,coeffici:39,collect:[26,51,66],collector:[14,33],color:40,column:[25,52],combin:34,combinator:63,command:33,common:56,comparison:[31,44,55],compat:26,compil:[8,13],complet:40,complex:[27,54],composit:58,compound:29,comprehens:[25,61],compress:25,comput:[51,77],concaten:[25,63],concurr:34,condit:[6,29,57],config:33,configur:53,conflict:39,confus:57,consider:[17,22],consist:57,constant:[26,61,67,68,76],constrain:46,construct:[25,58],constructor:[8,25,28,31,34,63],contain:[52,57],contextu:48,control:[29,53],convent:[4,26,57,60],convers:[26,28,30,44,68],convert:33,cooki:51,core:29,coroutin:29,correspond:[25,26],crash:2,creat:[8,26,50,85],csc:25,custom:[15,40,50,51,58,85],danger:52,data:[12,26,51,66,76],date:[31,68],datetim:31,deadlock:54,deal:6,debug:[0,6],declar:[34,52,58],defin:[30,46],definit:[7,34,47,52],delet:34,dens:25,deprec:[15,26,34,52],dequeu:66,descript:50,design:19,detail:[19,50],determin:33,develop:[0,23,50],differ:[11,34,40,49],dimension:25,dirti:50,dispatch:52,displai:[6,32,53],distribut:51,divers:57,divis:[39,44],document:[10,23,24,32,50],doe:34,domainerror:34,don:57,dot:35,durat:31,dure:[2,6,18,52],dynam:73,editor:62,effect:45,effici:8,elabor:57,element:32,elementari:[43,44],elide:3,embed:33,empty:46,environ:2,epoch:31,epsilon:39,equal:57,equat:32,error:[2,6,29,39,55,64],essential:64,eval:[7,9,45],evalu:45,evaluat:[29,35],event:[29,64],exampl:[26,33,45,48,54],exception:[29,33],excess:57,execut:[7,50,52],exist:[15,50],expansion:7,experiment:[51,77],expos:57,expr:1,express:5,expression:[25,29,45,56],extension:32,external:54,extract:55,factor:43,few:19,field:[19,52,57],file:[6,47,48],filesystem:69,fix:[50,52],flow:29,footnot:32,form:1,format:76,fortran:26,framework:6,free:50,frequent:34,from:[6,49,52],further:35,garbag:[14,26,33,51],gdb:6,gener:[7,8,15,17,22,25,32,45,46,50,57,64,66,71,76,77],get:[36,64],give:34,global:[12,26,32,52,61],glossari:2,guid:[26,32,57],guidelin:50,handl:[29,37,55,57],hard:61,header:32,heap:66,help:40,hierarchi:3,high:33,hoc:50,hold:45,horizont:32,how:34,hygien:45,hyperbol:44,imag:20,image:[7,20,32],immut:34,immutabl:58,implement:[15,25],importal:34,improve:11,inbound:3,incomplet:28,index:[15,19,25,41,63],indexabl:66,indic:15,indirect:26,inferenc:7,info:2,inform:[29,55],initi:[25,47,62],initial:[9,25,28,50],initialis:18,inline:32,inner:28,input:[26,59],insert:6,insid:34,inspect:6,install:50,installat:50,instanc:57,integ:34,integer:[39,76],integrat:75,inter:34,interact:40,interfac:[11,18,41,57,65,77],intern:21,internal:[10,64],interpol:[45,52,54,56],introduct:[21,42,64],introspect:16,invoc:45,issu:8,italic:32,iter:15,iterabl:66,iterat:[25,41,66],itself:50,jit:7,jl_atexit_hook:9,jl_std:18,jl_value_t:14,jltype:21,julia:[0,1,2,4,6,7,8,9,10,11,14,18,20,22,23,24,26,33,34,38,40,57,70,85],julia_init:9,julia_sav:9,julian:40,just:57,kei:40,kernel:52,keybind:40,keyword:[8,35,46,52],lambdainfo:1,languag:49,lapack:74,layout:14,legaci:18,length:15,let:61,level:[33,47,57,74],librari:[18,23,70,72],libuv:18,like:[46,66],line:33,linear:[15,19,43,74],linearindic:15,link:32,linker:73,list:32,liter:[32,39,45,56,57],llvm:[11,65],load:[6,51],local:61,localmanag:51,locat:52,lock:12,log:44,loop:[15,29,51,61],low:74,lower:1,machin:[34,39],machineri:21,macro:[1,5,7,32,45,51,57,85],main:9,mainten:12,make:50,makefil:33,manag:[33,51,77,78],mani:34,manipul:33,manual:[23,38,50],map:[26,51,71],mark:14,markdown:32,mathemat:[44,63,75],matlab:49,matric:[25,43,63],matrix:[25,43,74],mean:34,measur:52,mechan:13,memori:[14,17,26,33,34,52,53,71],messag:29,meta:13,metadata:50,metaprogram:45,method:[6,8,21,25,28,32,46,57],miscellanea:47,miss:[34,58],mix:34,mode:[39,40],modifi:[26,34,57],modul:[32,34,47],more:[7,21,26,52],movement:51,mozilla:6,msan:17,multi:[12,25,51,77],multidimension:33,multimedia:71,multipl:[32,35,52],name:[35,50,57,60],namespac:47,nativ:[4,34],network:[48,51,52,71],nightli:34,non:[15,26,45,56],note:46,noteworthi:49,nothing:34,nullabl:[58,64],number:[1,5,27,39,52,56,76],numer:[39,44,57,75,76],object:[14,32,34,46,58,64],offline:50,onli:28,oper:[25,29,34,43,44,57,63,74],operat:[1,25,35,37,44,56,58,75],optim:11,optimiz:52,option:[11,53],optional:[35,46],order:[52,82],other:[49,85],outer:28,output:[34,48,52],outsid:34,overflow:39,overli:57,overload:57,overus:57,overview:11,ownership:26,packag:[34,50,51,78],pai:52,paragraph:32,parallel:[51,52,77],paramet:[19,33,52,57],parametr:[28,46,58],parenthes:57,pars:7,particular:6,pass:[11,26,34,35],path:47,perform:52,period:[31,68],pin:50,pipelin:54,point:39,pointer:26,possibl:57,post:50,power:44,pre:52,preced:44,precis:39,precompil:[6,47],pretti:58,primit:77,principl:5,print:58,printf:18,priorityqueu:66,process:[6,75],profil:[53,79],program:[45,54],promot:30,prompt:40,propag:3,proper:12,properti:48,ptr:26,publish:50,punctuat:80,python:49,queri:[31,68],question:34,quot:[32,45,54,56],random:76,ration:[27,28,30],read:35,rebas:50,record:6,ref:26,refer:[5,26,32,39,51],reflect:[16,64],regular:56,rel:47,relat:82,releas:34,remot:51,remov:[34,50],repeat:29,repl:[34,62],replac:19,replai:6,report:2,repositori:50,repres:58,represent:45,requir:[50,51],require:50,reshap:15,resolv:48,resourc:36,result:[34,53],root:44,round:[31,39,44,68],rule:[30,32],run:[2,22,54],runtim:[9,18],safe:58,safeti:26,same:34,sanit:17,scale:43,schedul:51,scope:[35,61],script:[2,57],search:40,seemingli:34,segfault:2,sensibl:34,separ:52,session:34,set:[21,66,85],setup:[50,51],share:[12,51,77],shell:40,sign:44,signal:[6,75],simd:[26,81],similar:15,simpl:48,simplifi:62,singleton:[14,58],size:15,slurp:34,soft:61,some:26,someth:57,sort:[21,82],spars:[25,63],speak:50,special:[15,26,35,39,43,44],specif:[26,50,57],specifi:51,splat:34,split:34,squash:50,sshmanag:51,stabl:[34,52],stack:55,stacktrac:83,standard:[23,45,47,56,70,72,74,76],start:36,startup:2,state:29,statement:29,statist:75,statu:50,stdio:18,still:34,storag:[15,25],strang:57,stream:[34,48],string:[1,45,52,56,84],struct:26,structur:[12,66],studi:[28,30],style:57,stylist:60,subarrai:19,subnorm:52,subtyp:21,suit:22,summari:[15,47,50],suppli:5,support:[17,77,81],suppress:22,surfac:1,symbol:45,synchron:[34,51,77],syntax:[1,5,26,32,35,39,64],sysimg:[2,9],system:[7,20,37,64],tab:40,tabl:[8,32],tag:50,taken:52,talk:13,task:[29,77],tcp:48,test:[22,85],text:[48,71],those:6,thread:[12,26,51,77],threadcal:51,threadpool:77,through:26,time:[52,68],timetyp:31,tip:[6,52,62],tool:52,top:47,toplevel:32,topolog:51,trace:55,trait:25,translat:[19,26],transport:51,treat:52,trigonometr:44,tripl:56,true_main:9,tupl:[21,58],tweak:52,two:34,type:[1,7,14,15,19,21,25,26,31,32,33,34,52,57,58,64,68,76,85],typenam:21,typevar:21,unchang:34,under:22,unicod:[56,59],uniform:43,union:[21,57,58],unit:85,unnecessari:57,unregist:50,unsaf:57,untyp:52,update:[44,50],upon:6,usag:[5,47,53],usage:32,use:[33,57],useful:6,using:[15,22,33],utf:56,valgrind:22,valu:[26,34,35,39,44,52,58],vararg:[35,46,58],variabl:[6,26,32,34,52,60,61],variat:37,vector:[25,35,63],version:[2,11,34,56],view:55,want:34,warn:[29,52],what:34,when:[2,26,34,57],whether:57,why:[34,45],work:[11,33,34,48,85],workflow:62,wrapper:[18,26],write:[15,34,52,57],your:50,zero:[39,52]}})",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/genindex.html": "\n\n\n<!DOCTYPE html>\n<!--[if IE 8]><html class=\"no-js lt-ie9\" lang=\"en\" > <![endif]-->\n<!--[if gt IE 8]><!--> <html class=\"no-js\" lang=\"en\" > <!--<![endif]-->\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  \n  <title>Index &mdash; Julia Language 0.5.1 documentation</title>\n  \n\n  \n  \n\n  \n  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>\n\n  \n  \n    \n\n  \n\n  \n  \n    <link rel=\"stylesheet\" href=\"_static/julia.css\" type=\"text/css\" />\n  \n\n  \n    <link rel=\"stylesheet\" href=\"_static/julia.css\" type=\"text/css\" />\n  \n    <link rel=\"top\" title=\"Julia Language 0.5.1 documentation\" href=\"index.html\"/> \n\n  \n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js\"></script>\n\n</head>\n\n<body class=\"wy-body-for-nav\" role=\"document\">\n\n  <div class=\"wy-grid-for-nav\">\n\n    \n    <nav data-toggle=\"wy-nav-shift\" class=\"wy-nav-side\">\n      <div class=\"wy-side-nav-search\">\n        <a href=\"http://julialang.org/\"><img src=\"_static/julia-logo.svg\" class=\"logo\"></a>\n        <!--\n        <a href=\"index.html\" class=\"fa fa-home\"> Julia Language</a>\n        -->\n        <div role=\"search\">\n  <form id =\"rtd-search-form\" class=\"wy-form\" action=\"search.html\" method=\"get\">\n    <input type=\"text\" name=\"q\" placeholder=\"Search docs\" />\n    <input type=\"hidden\" name=\"check_keywords\" value=\"yes\" />\n    <input type=\"hidden\" name=\"area\" value=\"default\" />\n  </form>\n</div>\n      </div>\n\n      <div class=\"wy-menu wy-menu-vertical\" data-spy=\"affix\" role=\"navigation\" aria-label=\"main navigation\">\n        \n        \n            <ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/introduction.html\">Introduction</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/getting-started.html\">Getting Started</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/getting-started.html#resources\">Resources</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/variables.html\">Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/variables.html#allowed-variable-names\">Allowed Variable Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/variables.html#stylistic-conventions\">Stylistic Conventions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/integers-and-floating-point-numbers.html\">Integers and Floating-Point Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/integers-and-floating-point-numbers.html#integers\">Integers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/integers-and-floating-point-numbers.html#floating-point-numbers\">Floating-Point Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/integers-and-floating-point-numbers.html#arbitrary-precision-arithmetic\">Arbitrary Precision Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/integers-and-floating-point-numbers.html#numeric-literal-coefficients\">Numeric Literal Coefficients</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/integers-and-floating-point-numbers.html#literal-zero-and-one\">Literal zero and one</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/mathematical-operations.html\">Mathematical Operations and Elementary Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/mathematical-operations.html#arithmetic-operators\">Arithmetic Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/mathematical-operations.html#bitwise-operators\">Bitwise Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/mathematical-operations.html#updating-operators\">Updating operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/mathematical-operations.html#numeric-comparisons\">Numeric Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/mathematical-operations.html#numerical-conversions\">Numerical Conversions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/complex-and-rational-numbers.html\">Complex and Rational Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/complex-and-rational-numbers.html#complex-numbers\">Complex Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/complex-and-rational-numbers.html#rational-numbers\">Rational Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/strings.html\">Strings</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#characters\">Characters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#string-basics\">String Basics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#unicode-and-utf-8\">Unicode and UTF-8</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#triple-quoted-string-literals\">Triple-Quoted String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#common-operations\">Common Operations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#regular-expressions\">Regular Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#id2\">Byte Array Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/strings.html#version-number-literals\">Version Number Literals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/functions.html\">Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#argument-passing-behavior\">Argument Passing Behavior</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#the-return-keyword\">The <code class=\"docutils literal\"><span class=\"pre\">return</span></code> Keyword</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#operators-are-functions\">Operators Are Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#operators-with-special-names\">Operators With Special Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#anonymous-functions\">Anonymous Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#multiple-return-values\">Multiple Return Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#varargs-functions\">Varargs Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#optional-arguments\">Optional Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#keyword-arguments\">Keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#evaluation-scope-of-default-values\">Evaluation Scope of Default Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#do-block-syntax-for-function-arguments\">Do-Block Syntax for Function Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#dot-syntax-for-vectorizing-functions\">Dot Syntax for Vectorizing Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/functions.html#further-reading\">Further Reading</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/control-flow.html\">Control Flow</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/control-flow.html#compound-expressions\">Compound Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/control-flow.html#conditional-evaluation\">Conditional Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/control-flow.html#short-circuit-evaluation\">Short-Circuit Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/control-flow.html#repeated-evaluation-loops\">Repeated Evaluation: Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/control-flow.html#exception-handling\">Exception Handling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/control-flow.html#tasks-aka-coroutines\">Tasks (aka Coroutines)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/variables-and-scoping.html\">Scope of Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/variables-and-scoping.html#global-scope\">Global Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/variables-and-scoping.html#local-scope\">Local Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/variables-and-scoping.html#constants\">Constants</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/types.html\">Types</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#type-declarations\">Type Declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#abstract-types\">Abstract Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#bits-types\">Bits Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#composite-types\">Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#immutable-composite-types\">Immutable Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#declared-types\">Declared Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#type-unions\">Type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#man-parametric-types\">Parametric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#type-aliases\">Type Aliases</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#operations-on-types\">Operations on Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#custom-pretty-printing\">Custom pretty-printing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#value-types\">&#8220;Value types&#8221;</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/types.html#nullable-types-representing-missing-values\">Nullable Types: Representing Missing Values</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/methods.html\">Methods</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#defining-methods\">Defining Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#method-ambiguities\">Method Ambiguities</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#parametric-methods\">Parametric Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#parametrically-constrained-varargs-methods\">Parametrically-constrained Varargs methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#note-on-optional-and-keyword-arguments\">Note on Optional and keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#function-like-objects\">Function-like objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/methods.html#empty-generic-functions\">Empty generic functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/constructors.html\">Constructors</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#outer-constructor-methods\">Outer Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#inner-constructor-methods\">Inner Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#incomplete-initialization\">Incomplete Initialization</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#parametric-constructors\">Parametric Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#case-study-rational\">Case Study: Rational</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#constructors-and-conversion\">Constructors and Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/constructors.html#outer-only-constructors\">Outer-only constructors</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/conversion-and-promotion.html\">Conversion and Promotion</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/conversion-and-promotion.html#conversion\">Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/conversion-and-promotion.html#promotion\">Promotion</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/interfaces.html\">Interfaces</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interfaces.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interfaces.html#indexing\">Indexing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interfaces.html#abstract-arrays\">Abstract Arrays</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/modules.html\">Modules</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/modules.html#summary-of-module-usage\">Summary of module usage</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/documentation.html\">Documentation</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/documentation.html#accessing-documentation\">Accessing Documentation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/documentation.html#functions-methods\">Functions &amp; Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/documentation.html#advanced-usage\">Advanced Usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/documentation.html#syntax-guide\">Syntax Guide</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/documentation.html#markdown-syntax\">Markdown syntax</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/documentation.html#markdown-syntax-extensions\">Markdown Syntax Extensions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/metaprogramming.html\">Metaprogramming</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/metaprogramming.html#program-representation\">Program representation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/metaprogramming.html#expressions-and-evaluation\">Expressions and evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/metaprogramming.html#macros\">Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/metaprogramming.html#code-generation\">Code Generation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/metaprogramming.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/metaprogramming.html#generated-functions\">Generated functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/arrays.html\">Multi-dimensional Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/arrays.html#arrays\">Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/arrays.html#sparse-matrices\">Sparse Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/linear-algebra.html\">Linear algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/linear-algebra.html#matrix-factorizations\">Matrix factorizations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/linear-algebra.html#special-matrices\">Special matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html\">Networking and Streams</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html#basic-stream-i-o\">Basic Stream I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html#io-output-contextual-properties\">IO Output Contextual Properties</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html#working-with-files\">Working with Files</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html#a-simple-tcp-example\">A simple TCP example</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/networking-and-streams.html#resolving-ip-addresses\">Resolving IP Addresses</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/parallel-computing.html\">Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#code-availability-and-loading-packages\">Code Availability and Loading Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#data-movement\">Data Movement</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#parallel-map-and-loops\">Parallel Map and Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#synchronization-with-remote-references\">Synchronization With Remote References</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#scheduling\">Scheduling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#channels\">Channels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#remote-references-and-abstractchannels\">Remote references and AbstractChannels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#remote-references-and-distributed-garbage-collection\">Remote References and Distributed Garbage Collection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#id2\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#shared-arrays-and-distributed-garbage-collection\">Shared Arrays and Distributed Garbage Collection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#clustermanagers\">ClusterManagers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#cluster-managers-with-custom-transports\">Cluster Managers with custom transports</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#network-requirements-for-localmanager-and-sshmanager\">Network requirements for LocalManager and SSHManager</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#cluster-cookie\">Cluster cookie</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#specifying-network-topology-experimental\">Specifying network topology (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#multi-threading-experimental\">Multi-threading (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/parallel-computing.html#threadcall-experimental\">&#64;threadcall (Experimental)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/dates.html\">Date and DateTime</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#durations-comparisons\">Durations/Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#accessor-functions\">Accessor Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#query-functions\">Query Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#timetype-period-arithmetic\">TimeType-Period Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#adjuster-functions\">Adjuster Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#period-types\">Period Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/dates.html#rounding\">Rounding</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/running-external-programs.html\">Running External Programs</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/running-external-programs.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/running-external-programs.html#quoting\">Quoting</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/running-external-programs.html#pipelines\">Pipelines</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html\">Calling C and Fortran Code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#creating-c-compatible-julia-function-pointers\">Creating C-Compatible Julia Function Pointers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#mapping-c-types-to-julia\">Mapping C Types to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#mapping-c-functions-to-julia\">Mapping C Functions to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#some-examples-of-c-wrappers\">Some Examples of C Wrappers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#garbage-collection-safety\">Garbage Collection Safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#non-constant-function-specifications\">Non-constant Function Specifications</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#indirect-calls\">Indirect Calls</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#calling-convention\">Calling Convention</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#accessing-global-variables\">Accessing Global Variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#accessing-data-through-a-pointer\">Accessing Data through a Pointer</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#thread-safety\">Thread-safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#more-about-callbacks\">More About Callbacks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/calling-c-and-fortran-code.html#c\">C++</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/handling-operating-system-variation.html\">Handling Operating System Variation</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/interacting-with-julia.html\">Interacting With Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interacting-with-julia.html#the-different-prompt-modes\">The different prompt modes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interacting-with-julia.html#key-bindings\">Key bindings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interacting-with-julia.html#tab-completion\">Tab completion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/interacting-with-julia.html#customizing-colors\">Customizing Colors</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/embedding.html\">Embedding Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/embedding.html#high-level-embedding\">High-Level Embedding</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/embedding.html#converting-types\">Converting Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/embedding.html#calling-julia-functions\">Calling Julia Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/embedding.html#memory-management\">Memory Management</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/embedding.html#working-with-arrays\">Working with Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/embedding.html#exceptions\">Exceptions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/packages.html\">Packages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#package-status\">Package Status</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#adding-and-removing-packages\">Adding and Removing Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#offline-installation-of-packages\">Offline Installation of Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#installing-unregistered-packages\">Installing Unregistered Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#updating-packages\">Updating Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#checkout-pin-and-free\">Checkout, Pin and Free</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#custom-metadata-repository\">Custom METADATA Repository</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/packages.html#package-development\">Package Development</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#initial-setup\">Initial Setup</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#making-changes-to-an-existing-package\">Making changes to an existing package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#creating-a-new-package\">Creating a new Package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#fixing-package-requirements\">Fixing Package Requirements</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/packages.html#man-package-requirements\">Requirements Specification</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/profile.html\">Profiling</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/profile.html#basic-usage\">Basic usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/profile.html#accumulation-and-clearing\">Accumulation and clearing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/profile.html#options-for-controlling-the-display-of-profile-results\">Options for controlling the display of profile results</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/profile.html#configuration\">Configuration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/profile.html#memory-allocation-analysis\">Memory allocation analysis</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/stacktraces.html\">Stack Traces</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/stacktraces.html#viewing-a-stack-trace\">Viewing a stack trace</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/stacktraces.html#extracting-useful-information\">Extracting useful information</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/stacktraces.html#error-handling\">Error handling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/stacktraces.html#comparison-with-backtrace\">Comparison with <code class=\"docutils literal\"><span class=\"pre\">backtrace()</span></code></a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/performance-tips.html\">Performance Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#avoid-global-variables\">Avoid global variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#measure-performance-with-time-and-pay-attention-to-memory-allocation\">Measure performance with <code class=\"docutils literal\"><span class=\"pre\">&#64;time</span></code> and pay attention to memory allocation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#tools\">Tools</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#avoid-containers-with-abstract-type-parameters\">Avoid containers with abstract type parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#type-declarations\">Type declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#break-functions-into-multiple-definitions\">Break functions into multiple definitions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#write-type-stable-functions\">Write &#8220;type-stable&#8221; functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#avoid-changing-the-type-of-a-variable\">Avoid changing the type of a variable</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#separate-kernel-functions-aka-function-barriers\">Separate kernel functions (aka, function barriers)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#types-with-values-as-parameters\">Types with values-as-parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#the-dangers-of-abusing-multiple-dispatch-aka-more-on-types-with-values-as-parameters\">The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#access-arrays-in-memory-order-along-columns\">Access arrays in memory order, along columns</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#pre-allocating-outputs\">Pre-allocating outputs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#avoid-string-interpolation-for-i-o\">Avoid string interpolation for I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#optimize-network-i-o-during-parallel-execution\">Optimize network I/O during parallel execution</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#fix-deprecation-warnings\">Fix deprecation warnings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#tweaks\">Tweaks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#performance-annotations\">Performance Annotations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#treat-subnormal-numbers-as-zeros\">Treat Subnormal Numbers as Zeros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/performance-tips.html#code-warntype\"><code class=\"docutils literal\"><span class=\"pre\">&#64;code_warntype</span></code></a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/workflow-tips.html\">Workflow Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/workflow-tips.html#repl-based-workflow\">REPL-based workflow</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/workflow-tips.html#browser-based-workflow\">Browser-based workflow</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/style-guide.html\">Style Guide</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#write-functions-not-just-scripts\">Write functions, not just scripts</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#avoid-writing-overly-specific-types\">Avoid writing overly-specific types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#handle-excess-argument-diversity-in-the-caller\">Handle excess argument diversity in the caller</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#append-to-names-of-functions-that-modify-their-arguments\">Append <code class=\"docutils literal\"><span class=\"pre\">!</span></code> to names of functions that modify their arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#avoid-strange-type-unions\">Avoid strange type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#avoid-type-unions-in-fields\">Avoid type Unions in fields</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#avoid-elaborate-container-types\">Avoid elaborate container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#use-naming-conventions-consistent-with-julia-s-base\">Use naming conventions consistent with Julia&#8217;s <code class=\"docutils literal\"><span class=\"pre\">base/</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-overuse-try-catch\">Don&#8217;t overuse try-catch</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-parenthesize-conditions\">Don&#8217;t parenthesize conditions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-overuse\">Don&#8217;t overuse ...</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-use-unnecessary-static-parameters\">Don&#8217;t use unnecessary static parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#avoid-confusion-about-whether-something-is-an-instance-or-a-type\">Avoid confusion about whether something is an instance or a type</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-overuse-macros\">Don&#8217;t overuse macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-expose-unsafe-operations-at-the-interface-level\">Don&#8217;t expose unsafe operations at the interface level</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#don-t-overload-methods-of-base-container-types\">Don&#8217;t overload methods of base container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#be-careful-with-type-equality\">Be careful with type equality</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#do-not-write-x-f-x\">Do not write <code class=\"docutils literal\"><span class=\"pre\">x-&gt;f(x)</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/style-guide.html#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible\">Avoid using floats for numeric literals in generic code when possible</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/faq.html\">Frequently Asked Questions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#sessions-and-the-repl\">Sessions and the REPL</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#functions\">Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#types-type-declarations-and-constructors\">Types, type declarations, and constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#packages-and-modules\">Packages and Modules</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#nothingness-and-missing-values\">Nothingness and missing values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#memory\">Memory</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#asynchronous-io-and-concurrent-synchronous-writes\">Asynchronous IO and concurrent synchronous writes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/faq.html#julia-releases\">Julia Releases</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/noteworthy-differences.html\">Noteworthy Differences from other Languages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/noteworthy-differences.html#noteworthy-differences-from-matlab\">Noteworthy differences from MATLAB</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/noteworthy-differences.html#noteworthy-differences-from-r\">Noteworthy differences from R</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/noteworthy-differences.html#noteworthy-differences-from-python\">Noteworthy differences from Python</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"manual/noteworthy-differences.html#noteworthy-differences-from-c-c\">Noteworthy differences from C/C++</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"manual/unicode-input.html\">Unicode Input</a></li>\n</ul>\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/base.html\">Essentials</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#introduction\">Introduction</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#getting-around\">Getting Around</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#all-objects\">All Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#types\">Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#generic-functions\">Generic Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#syntax\">Syntax</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#nullables\">Nullables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#system\">System</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#errors\">Errors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#events\">Events</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#reflection\">Reflection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/base.html#internals\">Internals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/collections.html\">Collections and Data Structures</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#general-collections\">General Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#iterable-collections\">Iterable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#indexable-collections\">Indexable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#associative-collections\">Associative Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#set-like-collections\">Set-Like Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#dequeues\">Dequeues</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#priorityqueue\">PriorityQueue</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/collections.html#heap-functions\">Heap Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/math.html\">Mathematics</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/math.html#mathematical-operators\">Mathematical Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/math.html#mathematical-functions\">Mathematical Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/math.html#statistics\">Statistics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/math.html#signal-processing\">Signal Processing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/math.html#numerical-integration\">Numerical Integration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/numbers.html\">Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/numbers.html#standard-numeric-types\">Standard Numeric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/numbers.html#data-formats\">Data Formats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/numbers.html#general-number-functions-and-constants\">General Number Functions and Constants</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/numbers.html#bigfloats\">BigFloats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/numbers.html#random-numbers\">Random Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/strings.html\">Strings</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/arrays.html\">Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#basic-functions\">Basic functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#mathematical-operators-and-functions\">Mathematical operators and functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#indexing-assignment-and-concatenation\">Indexing, Assignment, and Concatenation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#array-functions\">Array functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#combinatorics\">Combinatorics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#bitarrays\">BitArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/arrays.html#sparse-vectors-and-matrices\">Sparse Vectors and Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/parallel.html\">Tasks and Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/parallel.html#tasks\">Tasks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/parallel.html#general-parallel-computing-support\">General Parallel Computing Support</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/parallel.html#shared-arrays\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/parallel.html#multi-threading\">Multi-Threading</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/parallel.html#ccall-using-a-threadpool-experimental\">ccall using a threadpool (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/parallel.html#synchronization-primitives\">Synchronization Primitives</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/parallel.html#cluster-manager-interface\">Cluster Manager Interface</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/linalg.html\">Linear Algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/linalg.html#module-Base.LinAlg\">Standard Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/linalg.html#low-level-matrix-operations\">Low-level matrix operations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/linalg.html#module-Base.LinAlg.BLAS\">BLAS Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/linalg.html#module-Base.LinAlg.LAPACK\">LAPACK Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/constants.html\">Constants</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/file.html\">Filesystem</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/io-network.html\">I/O and Network</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/io-network.html#general-i-o\">General I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/io-network.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/io-network.html#multimedia-i-o\">Multimedia I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/io-network.html#memory-mapped-i-o\">Memory-mapped I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/io-network.html#network-i-o\">Network I/O</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/punctuation.html\">Punctuation</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/sort.html\">Sorting and Related Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/sort.html#sorting-functions\">Sorting Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/sort.html#order-related-functions\">Order-Related Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/sort.html#sorting-algorithms\">Sorting Algorithms</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/pkg.html\">Package Manager Functions</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/dates.html\">Dates and Time</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/dates.html#dates-and-time-types\">Dates and Time Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/dates.html#dates-functions\">Dates Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/test.html\">Unit Testing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/test.html#testing-base-julia\">Testing Base Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/test.html#basic-unit-tests\">Basic Unit Tests</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/test.html#working-with-test-sets\">Working with Test Sets</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/test.html#other-test-macros\">Other Test Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/test.html#broken-tests\">Broken Tests</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stdlib/test.html#creating-custom-abstracttestset-types\">Creating Custom <code class=\"docutils literal\"><span class=\"pre\">AbstractTestSet</span></code> Types</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/c.html\">C Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/c.html#llvm-interface\">LLVM Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/libc.html\">C Standard Library</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/libdl.html\">Dynamic Linker</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/profile.html\">Profiling</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/stacktraces.html\">StackTraces</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stdlib/simd-types.html\">SIMD Support</a></li>\n</ul>\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"devdocs/reflection.html\">Reflection and introspection</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"devdocs/julia.html\">Documentation of Julia&#8217;s Internals</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/init.html\">Initialization of the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/eval.html\">Eval of Julia code</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/ast.html\">Julia ASTs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/types.html\">More about types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/object.html\">Memory layout of Julia Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/functions.html\">Julia Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/callconv.html\">Calling Conventions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/cartesian.html\">Base.Cartesian</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/meta.html\">Talking to the compiler (the <code class=\"docutils literal\"><span class=\"pre\">:meta</span></code> mechanism)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/subarrays.html\">SubArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/sysimg.html\">System Image Building</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/llvm.html\">Working with LLVM</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/stdio.html\">printf() and stdio in the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/boundscheck.html\">Bounds checking</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/locks.html\">Proper maintenance and care of multi-threading locks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/offset-arrays.html\">Arrays with custom indices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"devdocs/C.html\">Developing/debugging Julia&#8217;s C code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/backtraces.html\">Reporting and analyzing crashes (segfaults)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/debuggingtips.html\">gdb debugging tips</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/valgrind.html\">Using Valgrind with Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"devdocs/sanitizers.html\">Sanitizer support</a></li>\n</ul>\n</li>\n</ul>\n\n        \n      </div>\n      &nbsp;\n    </nav>\n\n    <section data-toggle=\"wy-nav-shift\" class=\"wy-nav-content-wrap\">\n\n      \n      <nav class=\"wy-nav-top\" role=\"navigation\" aria-label=\"top navigation\">\n        <i data-toggle=\"wy-nav-top\" class=\"fa fa-bars\"></i>\n        <a href=\"index.html\">Julia Language</a>\n      </nav>\n\n\n      \n      <div class=\"wy-nav-content\">\n        <div class=\"rst-content\">\n          <div role=\"navigation\" aria-label=\"breadcrumbs navigation\">\n  <ul class=\"wy-breadcrumbs\">\n    <li><a href=\"index.html\">Docs</a> &raquo;</li>\n      \n    <li>Index</li>\n      <li class=\"wy-breadcrumbs-aside\">\n        \n      </li>\n  </ul>\n  <hr/>\n</div>\n          <div role=\"main\" class=\"document\">\n            \n\n<h1 id=\"index\">Index</h1>\n\n<div class=\"genindex-jumpbox\">\n <a href=\"#Symbols\"><strong>Symbols</strong></a>\n | <a href=\"#_\"><strong>_</strong></a>\n | <a href=\"#A\"><strong>A</strong></a>\n | <a href=\"#B\"><strong>B</strong></a>\n | <a href=\"#C\"><strong>C</strong></a>\n | <a href=\"#D\"><strong>D</strong></a>\n | <a href=\"#E\"><strong>E</strong></a>\n | <a href=\"#F\"><strong>F</strong></a>\n | <a href=\"#G\"><strong>G</strong></a>\n | <a href=\"#H\"><strong>H</strong></a>\n | <a href=\"#I\"><strong>I</strong></a>\n | <a href=\"#J\"><strong>J</strong></a>\n | <a href=\"#K\"><strong>K</strong></a>\n | <a href=\"#L\"><strong>L</strong></a>\n | <a href=\"#M\"><strong>M</strong></a>\n | <a href=\"#N\"><strong>N</strong></a>\n | <a href=\"#O\"><strong>O</strong></a>\n | <a href=\"#P\"><strong>P</strong></a>\n | <a href=\"#Q\"><strong>Q</strong></a>\n | <a href=\"#R\"><strong>R</strong></a>\n | <a href=\"#S\"><strong>S</strong></a>\n | <a href=\"#T\"><strong>T</strong></a>\n | <a href=\"#U\"><strong>U</strong></a>\n | <a href=\"#V\"><strong>V</strong></a>\n | <a href=\"#W\"><strong>W</strong></a>\n | <a href=\"#X\"><strong>X</strong></a>\n | <a href=\"#Y\"><strong>Y</strong></a>\n | <a href=\"#Z\"><strong>Z</strong></a>\n | <a href=\"#Symbols\"><strong>Symbols</strong></a>\n \n</div>\n<h2 id=\"Symbols\">Symbols</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.!\">!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.!=\">!=() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.!==\">!==() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.$\">$() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.%\">%() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.&\">&amp;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.*\">*() (in module Base)</a>, <a href=\"stdlib/math.html#Base.*\">[1]</a>, <a href=\"stdlib/strings.html#Base.*\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.+\">+() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.-\">-() (in module Base)</a>, <a href=\"stdlib/math.html#Base.-\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..!=\">.!=() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..*\">.*() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..+\">.+() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..-\">.-() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base../\">./() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..<\">.&lt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..<=\">.&lt;=() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..==\">.==() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..\u2260\">.\u2260() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..>\">.&gt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..>=\">.&gt;=() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..\\\">.\\() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..^\">.^() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..\u2264\">.\u2264() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base..\u2265\">.\u2265() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base./\">/() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.//\">//() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.:\">:() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.<\">&lt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.<:\">&lt;:() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.<<\">&lt;&lt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.<=\">&lt;=() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.==\">==() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.===\">===() (in module Base)</a>, <a href=\"stdlib/math.html#Base.===\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.\u2260\">\u2260() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.>\">&gt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.>=\">&gt;=() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.>>\">&gt;&gt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.>>>\">&gt;&gt;&gt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/documentation.html#@__doc__\">@__doc__() (built-in function)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.@__FILE__\">@__FILE__() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.@__LINE__\">@__LINE__() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@allocated\">@allocated() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@async\">@async() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@code_llvm\">@code_llvm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@code_lowered\">@code_lowered() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@code_native\">@code_native() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@code_typed\">@code_typed() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@code_warntype\">@code_warntype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@edit\">@edit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@elapsed\">@elapsed() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@eval\">@eval() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.@evalpoly\">@evalpoly() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@fetch\">@fetch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@fetchfrom\">@fetchfrom() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@functionloc\">@functionloc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@gensym\">@gensym() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.@html_str\">@html_str() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@less\">@less() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@parallel\">@parallel() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.@printf\">@printf() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/profile.html#Base.@profile\">@profile() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.@r_str\">@r_str() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@schedule\">@schedule() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@show\">@show() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@spawn\">@spawn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@spawnat\">@spawnat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.@sprintf\">@sprintf() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@static\">@static() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@sync\">@sync() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@task\">@task() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#Base.Test.@test_approx_eq\">@test_approx_eq() (in module Base.Test)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#Base.Test.@test_approx_eq_eps\">@test_approx_eq_eps() (in module Base.Test)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.@text_str\">@text_str() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.@threadcall\">@threadcall() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@time\">@time() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@timed\">@timed() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@timev\">@timev() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.@which\">@which() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.\\\">\\() (in module Base)</a>, <a href=\"stdlib/math.html#Base.\\\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.^\">^() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.^\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.|\">|() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.|>\">|&gt;() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.~\">~() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"_\">_</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.__precompile__\">__precompile__() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"A\">A</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.A_ldiv_B!\">A_ldiv_B!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.A_ldiv_Bc\">A_ldiv_Bc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.A_ldiv_Bt\">A_ldiv_Bt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.A_mul_B!\">A_mul_B!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.A_mul_Bc\">A_mul_Bc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.A_mul_Bt\">A_mul_Bt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.A_rdiv_Bc\">A_rdiv_Bc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.A_rdiv_Bt\">A_rdiv_Bt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.abs\">abs() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.abs2\">abs2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.abspath\">abspath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.AbstractLock\">AbstractLock (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Ac_ldiv_B!\">Ac_ldiv_B!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Ac_ldiv_B\">Ac_ldiv_B() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Ac_ldiv_Bc\">Ac_ldiv_Bc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Ac_mul_B\">Ac_mul_B() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Ac_mul_Bc\">Ac_mul_Bc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Ac_rdiv_B\">Ac_rdiv_B() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Ac_rdiv_Bc\">Ac_rdiv_Bc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.accept\">accept() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acos\">acos() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acosd\">acosd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acosh\">acosh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acot\">acot() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acotd\">acotd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acoth\">acoth() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.acquire\">acquire() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acsc\">acsc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acscd\">acscd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.acsch\">acsch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.add\">add() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.addprocs\">addprocs() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.addprocs\">[1]</a>, <a href=\"stdlib/parallel.html#Base.addprocs\">[2]</a>, <a href=\"stdlib/parallel.html#Base.addprocs\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airy\">airy() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airyai\">airyai() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airyaiprime\">airyaiprime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airybi\">airybi() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airybiprime\">airybiprime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airyprime\">airyprime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.airyx\">airyx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.all!\">all!() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/collections.html#Base.all\">all() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.all\">[1]</a>, <a href=\"stdlib/collections.html#Base.all\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.allunique\">allunique() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.angle\">angle() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ans\">ans (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.ANY\">ANY (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.any!\">any!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.any\">any() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.any\">[1]</a>, <a href=\"stdlib/collections.html#Base.any\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.append!\">append!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.applicable\">applicable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.apropos\">apropos() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.ARGS\">ARGS (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ArgumentError\">ArgumentError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.Array\">Array() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.ascii\">ascii() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.asec\">asec() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.asecd\">asecd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.asech\">asech() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.asin\">asin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.asind\">asind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.asinh\">asinh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.assert\">assert() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.AssertionError\">AssertionError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.asum\">asum() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.AsyncCondition\">AsyncCondition() (in module Base)</a>, <a href=\"stdlib/base.html#Base.AsyncCondition\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.asyncmap\">asyncmap() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.At_ldiv_B!\">At_ldiv_B!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.At_ldiv_B\">At_ldiv_B() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.At_ldiv_Bt\">At_ldiv_Bt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.At_mul_B\">At_mul_B() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.At_mul_Bt\">At_mul_Bt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.At_rdiv_B\">At_rdiv_B() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.At_rdiv_Bt\">At_rdiv_Bt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.atan\">atan() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.atan2\">atan2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.atand\">atand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.atanh\">atanh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.atexit\">atexit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.atreplinit\">atreplinit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.available\">available() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.available\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.axpy!\">axpy!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"B\">B</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.backtrace\">backtrace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/modules.html#index-0\">baremodule</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.base\">base() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"devdocs/cartesian.html#module-Base.Cartesian\">Base.Cartesian (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Base.channel_from_id\">Base.channel_from_id() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_abs\">Base.checked_abs() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_add\">Base.checked_add() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_cld\">Base.checked_cld() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_div\">Base.checked_div() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_fld\">Base.checked_fld() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_mod\">Base.checked_mod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_mul\">Base.checked_mul() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_neg\">Base.checked_neg() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_rem\">Base.checked_rem() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.checked_sub\">Base.checked_sub() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Base.cluster_cookie\">Base.cluster_cookie() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.Base.cluster_cookie\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#module-Base.Collections\">Base.Collections (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Base.compilecache\">Base.compilecache() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Base.datatype_module\">Base.datatype_module() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Base.function_module\">Base.function_module() (in module Base)</a>, <a href=\"stdlib/base.html#Base.Base.function_module\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Base.function_name\">Base.function_name() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#module-Base.LinAlg\">Base.LinAlg (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#module-Base.LinAlg.BLAS\">Base.LinAlg.BLAS (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#module-Base.LinAlg.LAPACK\">Base.LinAlg.LAPACK (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.Base.linearindexing\">Base.linearindexing() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.Base.OneTo\">Base.OneTo() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#module-Base.Pkg\">Base.Pkg (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Base.process_messages\">Base.process_messages() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Base.remoteref_id\">Base.remoteref_id() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Base.summarysize\">Base.summarysize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#module-Base.Test\">Base.Test (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Base.worker_id_from_socket\">Base.worker_id_from_socket() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.base64decode\">base64decode() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.Base64DecodePipe\">Base64DecodePipe() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.base64encode\">base64encode() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.Base64EncodePipe\">Base64EncodePipe() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.basename\">basename() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.bdsdc!\">bdsdc!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.bdsqr!\">bdsqr!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselh\">besselh() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.besselhx\">besselhx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besseli\">besseli() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselix\">besselix() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselj\">besselj() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselj0\">besselj0() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselj1\">besselj1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besseljx\">besseljx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselk\">besselk() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselkx\">besselkx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.bessely\">bessely() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.bessely0\">bessely0() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.bessely1\">bessely1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.besselyx\">besselyx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.beta\">beta() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.bfft!\">bfft!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.bfft\">bfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Bidiagonal\">Bidiagonal() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.Bidiagonal\">[1]</a>, <a href=\"stdlib/linalg.html#Base.Bidiagonal\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.big\">big() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.BigFloat\">BigFloat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.BigInt\">BigInt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.bin\">bin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.bind\">bind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.binomial\">binomial() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.bitbroadcast\">bitbroadcast() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.bitrand\">bitrand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.bits\">bits() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.bkfact!\">bkfact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.bkfact\">bkfact() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.blascopy!\">blascopy!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.blkdiag\">blkdiag() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.BoundsError\">BoundsError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.brfft\">brfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.broadcast!\">broadcast!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.broadcast\">broadcast() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.broadcast_getindex\">broadcast_getindex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.broadcast_setindex!\">broadcast_setindex!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.bswap\">bswap() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.build\">build() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.build\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"devdocs/sysimg.html#build_sysimg\">build_sysimg() (built-in function)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.bytes2hex\">bytes2hex() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"C\">C</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/constants.html#Base.C_NULL\">C_NULL (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.CachingPool\">CachingPool() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/profile.html#Base.Profile.callers\">callers() (in module Base.Profile)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.calloc\">calloc() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cat\">cat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.catalan\">catalan (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.catch_backtrace\">catch_backtrace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/stacktraces.html#Base.catch_stacktrace\">catch_stacktrace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cbrt\">cbrt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.ccall\">ccall() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cchar\">Cchar (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.cconvert\">cconvert() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.cd\">cd() (in module Base)</a>, <a href=\"stdlib/file.html#Base.cd\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cdouble\">Cdouble (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ceil\">ceil() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/dates.html#Dates.ceil\">(in module Dates)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/c.html#Base.Cfloat\">Cfloat (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.cfunction\">cfunction() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.cglobal\">cglobal() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Channel{T}\">Channel{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.charwidth\">charwidth() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.checkbounds\">checkbounds() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.checkbounds\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.checkindex\">checkindex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.checkout\">checkout() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.chmod\">chmod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.chol\">chol() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.chol\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.cholfact!\">cholfact!() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.cholfact!\">[1]</a>, <a href=\"stdlib/linalg.html#Base.cholfact!\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.cholfact\">cholfact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.cholfact\">[1]</a>, <a href=\"stdlib/linalg.html#Base.cholfact\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.chomp\">chomp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.chop\">chop() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.chown\">chown() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.chr2ind\">chr2ind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cint\">Cint (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cintmax_t\">Cintmax_t (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.circshift\">circshift() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cis\">cis() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.clamp!\">clamp!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.clamp\">clamp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cld\">cld() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.clear!\">clear!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/profile.html#Base.Profile.clear\">clear() (in module Base.Profile)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/profile.html#Base.Profile.clear_malloc_data\">clear_malloc_data() (in module Base.Profile)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.clipboard\">clipboard() (in module Base)</a>, <a href=\"stdlib/base.html#Base.clipboard\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.clone\">clone() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.clone\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Clong\">Clong (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Clonglong\">Clonglong (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.close\">close() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.close\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cmp\">cmp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.code_llvm\">code_llvm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.code_lowered\">code_lowered() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.code_native\">code_native() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.code_typed\">code_typed() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.code_warntype\">code_warntype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.collect\">collect() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.collect\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.colon\">colon() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.complex\">complex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.CompoundPeriod\">CompoundPeriod() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.cond\">cond() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Condition\">Condition() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.condskeel\">condskeel() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.conj!\">conj!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.conj\">conj() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.connect\">connect() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.connect\">[1]</a>, <a href=\"stdlib/parallel.html#Base.connect\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.consume\">consume() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.contains\">contains() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.conv\">conv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.conv2\">conv2() (in module Base)</a>, <a href=\"stdlib/math.html#Base.conv2\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.convert\">convert() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.copy!\">copy!() (in module Base)</a>, <a href=\"stdlib/c.html#Base.copy!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.copy\">copy() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.copysign\">copysign() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cor\">cor() (in module Base)</a>, <a href=\"stdlib/math.html#Base.cor\">[1]</a>, <a href=\"stdlib/math.html#Base.cor\">[2]</a>, <a href=\"stdlib/math.html#Base.cor\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cos\">cos() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cosc\">cosc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cosd\">cosd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cosh\">cosh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cospi\">cospi() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cot\">cot() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cotd\">cotd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.coth\">coth() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.count\">count() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.count_ones\">count_ones() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.count_zeros\">count_zeros() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.countfrom\">countfrom() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.countlines\">countlines() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.countnz\">countnz() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cov\">cov() (in module Base)</a>, <a href=\"stdlib/math.html#Base.cov\">[1]</a>, <a href=\"stdlib/math.html#Base.cov\">[2]</a>, <a href=\"stdlib/math.html#Base.cov\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.cp\">cp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cptrdiff_t\">Cptrdiff_t (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.cross\">cross() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.csc\">csc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.cscd\">cscd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.csch\">csch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cshort\">Cshort (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Csize_t\">Csize_t (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cssize_t\">Cssize_t (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.ctime\">ctime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ctranspose!\">ctranspose!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ctranspose\">ctranspose() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cuchar\">Cuchar (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cuint\">Cuint (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cuintmax_t\">Cuintmax_t (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Culong\">Culong (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Culonglong\">Culonglong (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cummax\">cummax() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cummin\">cummin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cumprod!\">cumprod!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cumprod\">cumprod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cumsum!\">cumsum!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cumsum\">cumsum() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.cumsum_kbn\">cumsum_kbn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.current_module\">current_module() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.current_task\">current_task() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cushort\">Cushort (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Cwchar_t\">Cwchar_t (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.cycle\">cycle() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"D\">D</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Date\">Date (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Date\">Date() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Date\">[1]</a>, <a href=\"stdlib/dates.html#Dates.Date\">[2]</a>, <a href=\"stdlib/dates.html#Dates.Date\">[3]</a>, <a href=\"stdlib/dates.html#Dates.Date\">[4]</a>, <a href=\"stdlib/dates.html#Dates.Date\">[5]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.date2epochdays\">date2epochdays() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.DateFormat\">DateFormat() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#module-Dates\">Dates (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.DateTime\">DateTime (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.DateTime\">DateTime() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.DateTime\">[1]</a>, <a href=\"stdlib/dates.html#Dates.DateTime\">[2]</a>, <a href=\"stdlib/dates.html#Dates.DateTime\">[3]</a>, <a href=\"stdlib/dates.html#Dates.DateTime\">[4]</a>, <a href=\"stdlib/dates.html#Dates.DateTime\">[5]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.datetime2epochms\">datetime2epochms() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.datetime2julian\">datetime2julian() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.datetime2rata\">datetime2rata() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.datetime2unix\">datetime2unix() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.dawson\">dawson() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Day\">Day (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Day\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Day\">Day() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.day\">day() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayabbr\">dayabbr() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayname\">dayname() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayofmonth\">dayofmonth() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayofquarter\">dayofquarter() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayofweek\">dayofweek() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayofweekofmonth\">dayofweekofmonth() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.dayofyear\">dayofyear() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.daysinmonth\">daysinmonth() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.daysinyear\">daysinyear() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.daysofweekinmonth\">daysofweekinmonth() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.dct!\">dct!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.dct\">dct() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.dec\">dec() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.deconv\">deconv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.deepcopy\">deepcopy() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.default\">default() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.default_worker_pool\">default_worker_pool() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.deg2rad\">deg2rad() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.delete!\">delete!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.deleteat!\">deleteat!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.deleteat!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.den\">den() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.dependents\">dependents() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.dequeue!\">dequeue!() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.deserialize\">deserialize() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.det\">det() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.detach\">detach() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.DevNull\">DevNull (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.diag\">diag() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.diagind\">diagind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.diagm\">diagm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Diagonal\">Diagonal() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.Diagonal\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Dict\">Dict() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.diff\">diff() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.digamma\">digamma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.digits!\">digits!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.digits\">digits() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.DimensionMismatch\">DimensionMismatch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.dir\">dir() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.dir\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.dirname\">dirname() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.disable_sigint\">disable_sigint() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.display\">display() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.displayable\">displayable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.displaysize\">displaysize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.div\">div() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.DivideError\">DivideError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.divrem\">divrem() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.DL_LOAD_PATH\">DL_LOAD_PATH (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.dlclose\">dlclose() (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.dlext\">dlext (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.dlopen\">dlopen() (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.dlopen_e\">dlopen_e() (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.dlsym\">dlsym() (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.dlsym_e\">dlsym_e() (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.DomainError\">DomainError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.done\">done() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.dot\">dot() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.dot\">(in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.dotc\">dotc() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.dotu\">dotu() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.download\">download() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.drop\">drop() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.dropzeros!\">dropzeros!() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.dropzeros!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.dropzeros\">dropzeros() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.dropzeros\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.dump\">dump() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"E\">E</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/numbers.html#Base.e\">e (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.eachindex\">eachindex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.eachline\">eachline() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.eachmatch\">eachmatch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.edit\">edit() (in module Base)</a>, <a href=\"stdlib/base.html#Base.edit\">[1]</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.edit\">(in module Base.Pkg)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eig\">eig() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.eig\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigfact!\">eigfact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigfact\">eigfact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.eigfact\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigmax\">eigmax() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigmin\">eigmin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigs\">eigs() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.eigs\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigvals!\">eigvals!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigvals\">eigvals() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.eigvecs\">eigvecs() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.eltype\">eltype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.empty!\">empty!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.ENDIAN_BOM\">ENDIAN_BOM (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.endof\">endof() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.endswith\">endswith() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.enqueue!\">enqueue!() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.enumerate\">enumerate() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ENV\">ENV (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.EnvHash\">EnvHash() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.eof\">eof() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.EOFError\">EOFError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.epochdays2date\">epochdays2date() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.epochms2datetime\">epochms2datetime() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.eps\">eps() (in module Base)</a>, <a href=\"stdlib/base.html#Base.eps\">[1]</a>, <a href=\"stdlib/base.html#Base.eps\">[2]</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/dates.html#Dates.eps\">(in module Dates)</a>\n  </dt>\n\n      </dl></dd>\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.erf\">erf() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.erfc\">erfc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.erfcinv\">erfcinv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.erfcx\">erfcx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.erfi\">erfi() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.erfinv\">erfinv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.errno\">errno() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.error\">error() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ErrorException\">ErrorException() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.esc\">esc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.escape_string\">escape_string() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.escape_string\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.eta\">eta() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.eu\">eu (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.eulergamma\">eulergamma (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.eval\">eval() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.evalfile\">evalfile() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.exit\">exit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.exp\">exp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.exp10\">exp10() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.exp2\">exp2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.expand\">expand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.expanduser\">expanduser() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.expm\">expm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.expm1\">expm1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.exponent\">exponent() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/modules.html#index-0\">export</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.extrema\">extrema() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.extrema\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.eye\">eye() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.eye\">[1]</a>, <a href=\"stdlib/arrays.html#Base.eye\">[2]</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"F\">F</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.factorial\">factorial() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.factorize\">factorize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.falses\">falses() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.falses\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.fd\">fd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.fdio\">fdio() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.fetch\">fetch() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/profile.html#Base.Profile.fetch\">(in module Base.Profile)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/math.html#Base.fft!\">fft!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.fft\">fft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.fftshift\">fftshift() (in module Base)</a>, <a href=\"stdlib/math.html#Base.fftshift\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.fieldname\">fieldname() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.fieldnames\">fieldnames() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.fieldoffset\">fieldoffset() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.fieldtype\">fieldtype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.filemode\">filemode() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.filesize\">filesize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.fill!\">fill!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.fill\">fill() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.filt!\">filt!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.filt\">filt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.filter!\">filter!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.filter\">filter() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.finalize\">finalize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.finalizer\">finalizer() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.find\">find() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.find\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.find_library\">find_library() (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.findfirst\">findfirst() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.findfirst\">[1]</a>, <a href=\"stdlib/arrays.html#Base.findfirst\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.findin\">findin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.findlast\">findlast() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.findlast\">[1]</a>, <a href=\"stdlib/arrays.html#Base.findlast\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.findmax!\">findmax!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.findmax\">findmax() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.findmax\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.findmin!\">findmin!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.findmin\">findmin() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.findmin\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.findn\">findn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.findnext\">findnext() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.findnext\">[1]</a>, <a href=\"stdlib/arrays.html#Base.findnext\">[2]</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/arrays.html#Base.findnz\">findnz() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.findprev\">findprev() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.findprev\">[1]</a>, <a href=\"stdlib/arrays.html#Base.findprev\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#Base.Test.finish\">finish() (in module Base.Test)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.first\">first() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.firstdayofmonth\">firstdayofmonth() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.firstdayofquarter\">firstdayofquarter() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.firstdayofweek\">firstdayofweek() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.firstdayofyear\">firstdayofyear() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.fld\">fld() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.fld1\">fld1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.fldmod\">fldmod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.fldmod1\">fldmod1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.flipbits!\">flipbits!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.flipdim\">flipdim() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.flipsign\">flipsign() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.float\">float() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.Float32\">Float32() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.Float64\">Float64() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.floor\">floor() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/dates.html#Dates.floor\">(in module Dates)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/dates.html#Dates.floorceil\">floorceil() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.flush\">flush() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.flush_cstdio\">flush_cstdio() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.fma\">fma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.foldl\">foldl() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.foldl\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.foldr\">foldr() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.foldr\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.foreach\">foreach() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.format\">format() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.FormatMessage\">FormatMessage() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.free\">free() (in module Base.Libc)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.free\">(in module Base.Pkg)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/math.html#Base.frexp\">frexp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.full\">full() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.full\">[1]</a>, <a href=\"stdlib/linalg.html#Base.full\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.fullname\">fullname() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.functionloc\">functionloc() (in module Base)</a>, <a href=\"stdlib/base.html#Base.functionloc\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Future\">Future() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"G\">G</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.gamma\">gamma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gbmv!\">gbmv!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gbmv\">gbmv() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gbtrf!\">gbtrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gbtrs!\">gbtrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.gc\">gc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.gc_enable\">gc_enable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.gcd\">gcd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.gcdx\">gcdx() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gebak!\">gebak!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gebal!\">gebal!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gebrd!\">gebrd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gecon!\">gecon!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gees!\">gees!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geev!\">geev!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geevx!\">geevx!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gehrd!\">gehrd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gelqf!\">gelqf!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gelqf!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gels!\">gels!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gelsd!\">gelsd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gelsy!\">gelsy!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gemm!\">gemm!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gemm\">gemm() (in module Base.LinAlg.BLAS)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gemm\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gemqrt!\">gemqrt!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gemv!\">gemv!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gemv\">gemv() (in module Base.LinAlg.BLAS)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.gemv\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.gensym\">gensym() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqlf!\">geqlf!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqlf!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqp3!\">geqp3!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqp3!\">[1]</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqp3!\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqrf!\">geqrf!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqrf!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqrt!\">geqrt!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqrt!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqrt3!\">geqrt3!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.geqrt3!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.ger!\">ger!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gerqf!\">gerqf!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gerqf!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gesdd!\">gesdd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gesv!\">gesv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gesvd!\">gesvd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gesvx!\">gesvx!() (in module Base.LinAlg.LAPACK)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gesvx!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.get!\">get!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.get!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.get\">get() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.get\">[1]</a>, <a href=\"stdlib/collections.html#Base.get\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#Base.Test.get_testset\">get_testset() (in module Base.Test)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#Base.Test.get_testset_depth\">get_testset_depth() (in module Base.Test)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.get_zero_subnormals\">get_zero_subnormals() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.getaddrinfo\">getaddrinfo() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.getfield\">getfield() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.gethostname\">gethostname() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.getindex\">getindex() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.getindex\">[1]</a>, <a href=\"stdlib/collections.html#Base.getindex\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.getipaddr\">getipaddr() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.getkey\">getkey() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.GetLastError\">GetLastError() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.getpid\">getpid() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.getrf!\">getrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.getri!\">getri!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.getrs!\">getrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.getsockname\">getsockname() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gges!\">gges!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ggev!\">ggev!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gglse!\">gglse!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ggsvd!\">ggsvd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ggsvd3!\">ggsvd3!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.givens\">givens() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.givens\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.givens{T}\">givens{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.golden\">golden (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.gperm\">gperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.gradient\">gradient() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.graphemes\">graphemes() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gtsv!\">gtsv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gttrf!\">gttrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.gttrs!\">gttrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"H\">H</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.hankelh1\">hankelh1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.hankelh1x\">hankelh1x() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.hankelh2\">hankelh2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.hankelh2x\">hankelh2x() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.hash\">hash() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.haskey\">haskey() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.hcat\">hcat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.heapify!\">heapify!() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.heapify\">heapify() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.heappop!\">heappop!() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.heappush!\">heappush!() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.her!\">her!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.herk!\">herk!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.herk\">herk() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Hermitian\">Hermitian() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.hessfact!\">hessfact!() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.hessfact\">hessfact() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.hesv!\">hesv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.hetrf!\">hetrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.hetri!\">hetri!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.hetrs!\">hetrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.hex\">hex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.hex2bytes\">hex2bytes() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.hex2num\">hex2num() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.homedir\">homedir() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Hour\">Hour (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Hour\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Hour\">Hour() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.hour\">hour() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.htol\">htol() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.hton\">hton() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.hvcat\">hvcat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.hypot\">hypot() (in module Base)</a>, <a href=\"stdlib/math.html#Base.hypot\">[1]</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"I\">I</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.I\">I (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.idct!\">idct!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.idct\">idct() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.identity\">identity() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ifelse\">ifelse() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ifft!\">ifft!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ifft\">ifft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ifftshift\">ifftshift() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ignorestatus\">ignorestatus() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.im\">im (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.imag\">imag() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/modules.html#index-0\">import</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/modules.html#index-0\">importall</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.in\">in() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.include\">include() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.include_dependency\">include_dependency() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.include_string\">include_string() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.ind2chr\">ind2chr() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ind2sub\">ind2sub() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.ind2sub\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.indexin\">indexin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.indexpids\">indexpids() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.indices\">indices() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.indices\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.indmax\">indmax() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.indmin\">indmin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.InexactError\">InexactError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.Inf\">Inf (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.Inf16\">Inf16 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.Inf32\">Inf32 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.info\">info() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.init\">init() (in module Base.Pkg)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/profile.html#Base.Profile.init\">(in module Base.Profile)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/parallel.html#Base.init_worker\">init_worker() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.InitError\">InitError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.insert!\">insert!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.installed\">installed() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.installed\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.instances\">instances() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Instant\">Instant (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.interrupt\">interrupt() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.interrupt\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.InterruptException\">InterruptException() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.intersect!\">intersect!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.intersect\">intersect() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.IntSet\">IntSet() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.inv\">inv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.invdigamma\">invdigamma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.invmod\">invmod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.invoke\">invoke() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.invperm\">invperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.IOBuffer\">IOBuffer() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.IOBuffer\">[1]</a>, <a href=\"stdlib/io-network.html#Base.IOBuffer\">[2]</a>, <a href=\"stdlib/io-network.html#Base.IOBuffer\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.IOContext\">IOContext() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.IOContext\">[1]</a>, <a href=\"stdlib/io-network.html#Base.IOContext\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ipermute!\">ipermute!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ipermutedims\">ipermutedims() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.IPv4\">IPv4() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.IPv6\">IPv6() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.irfft\">irfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.is\">is() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.is_apple\">is_apple() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.is_assigned_char\">is_assigned_char() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.is_bsd\">is_bsd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.is_linux\">is_linux() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.is_unix\">is_unix() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.is_windows\">is_windows() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isa\">isa() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isabspath\">isabspath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isalnum\">isalnum() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isalpha\">isalpha() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.isapprox\">isapprox() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isascii\">isascii() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.isassigned\">isassigned() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isbits\">isbits() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isblockdev\">isblockdev() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.ischardev\">ischardev() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/strings.html#Base.iscntrl\">iscntrl() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isconst\">isconst() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isdefined\">isdefined() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.isdiag\">isdiag() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isdigit\">isdigit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isdir\">isdir() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isdirpath\">isdirpath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.isempty\">isempty() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isequal\">isequal() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.iseven\">iseven() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isfifo\">isfifo() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.isfile\">isfile() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isfinite\">isfinite() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isgraph\">isgraph() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.isheap\">isheap() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ishermitian\">ishermitian() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isimag\">isimag() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isimmutable\">isimmutable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isinf\">isinf() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isinteger\">isinteger() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isinteractive\">isinteractive() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isleaftype\">isleaftype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.isleapyear\">isleapyear() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isless\">isless() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.islink\">islink() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.islocked\">islocked() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.islower\">islower() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.ismarked\">ismarked() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.ismatch\">ismatch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.ismount\">ismount() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isnan\">isnan() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.isnull\">isnull() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isnumber\">isnumber() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isodd\">isodd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.isopen\">isopen() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.ispath\">ispath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.isperm\">isperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.isposdef!\">isposdef!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.isposdef\">isposdef() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ispow2\">ispow2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isprint\">isprint() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.ispunct\">ispunct() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.isqrt\">isqrt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.isreadable\">isreadable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.isreadonly\">isreadonly() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.isready\">isready() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.isready\">[1]</a>, <a href=\"stdlib/parallel.html#Base.isready\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.isreal\">isreal() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.issetgid\">issetgid() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.issetuid\">issetuid() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.issocket\">issocket() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.issorted\">issorted() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isspace\">isspace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.issparse\">issparse() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.issticky\">issticky() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.issubnormal\">issubnormal() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.issubset\">issubset() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.issubset\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.issubtype\">issubtype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.issymmetric\">issymmetric() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.istaskdone\">istaskdone() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.istaskstarted\">istaskstarted() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.istextmime\">istextmime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.istril\">istril() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.istriu\">istriu() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isupper\">isupper() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isvalid\">isvalid() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.isvalid\">[1]</a>, <a href=\"stdlib/strings.html#Base.isvalid\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.iswritable\">iswritable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.isxdigit\">isxdigit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.iteratoreltype\">iteratoreltype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.iteratorsize\">iteratorsize() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"J\">J</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/io-network.html#Base.join\">join() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.join\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.joinpath\">joinpath() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/constants.html#Base.JULIA_HOME\">JULIA_HOME (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.julian2datetime\">julian2datetime() (in module Dates)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"K\">K</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.KeyError\">KeyError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.keys\">keys() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.keytype\">keytype() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.kill\">kill() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.kill\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.kron\">kron() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"L\">L</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/collections.html#Base.last\">last() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.lastdayofmonth\">lastdayofmonth() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.lastdayofquarter\">lastdayofquarter() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.lastdayofweek\">lastdayofweek() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.lastdayofyear\">lastdayofyear() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.launch\">launch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.lbeta\">lbeta() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.lcfirst\">lcfirst() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.lcm\">lcm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ldexp\">ldexp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ldltfact!\">ldltfact!() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.ldltfact!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ldltfact\">ldltfact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.ldltfact\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.leading_ones\">leading_ones() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.leading_zeros\">leading_zeros() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.length\">length() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.length\">[1]</a>, <a href=\"stdlib/strings.html#Base.length\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.less\">less() (in module Base)</a>, <a href=\"stdlib/base.html#Base.less\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.lexcmp\">lexcmp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.lexless\">lexless() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.lfact\">lfact() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.lgamma\">lgamma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#module-Libc\">Libc (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#module-Libdl\">Libdl (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.LinAlg.checksquare\">LinAlg.checksquare() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.Givens\">LinAlg.Givens() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.qr!\">LinAlg.qr!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.linearindices\">linearindices() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.linreg\">linreg() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.linspace\">linspace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.listen\">listen() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.listen\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.listenany\">listenany() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/c.html#Base.llvmcall\">llvmcall() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.LOAD_PATH\">LOAD_PATH (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.LoadError\">LoadError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.localindexes\">localindexes() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.lock\">lock() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.log\">log() (in module Base)</a>, <a href=\"stdlib/math.html#Base.log\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.log10\">log10() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.log1p\">log1p() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.log2\">log2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.logabsdet\">logabsdet() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.logdet\">logdet() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.logm\">logm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.logspace\">logspace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/stacktraces.html#Base.StackTraces.lookup\">lookup() (in module Base.StackTraces)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.lowercase\">lowercase() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.lowrankdowndate!\">lowrankdowndate!() (in module Base.LinAlg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.lowrankdowndate\">lowrankdowndate() (in module Base.LinAlg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.lowrankupdate!\">lowrankupdate!() (in module Base.LinAlg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.lowrankupdate\">lowrankupdate() (in module Base.LinAlg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.lpad\">lpad() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.lq\">lq() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.lqfact!\">lqfact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.lqfact\">lqfact() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.lstat\">lstat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.lstrip\">lstrip() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.ltoh\">ltoh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.lu\">lu() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.lufact!\">lufact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.lufact\">lufact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.lufact\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.lyap\">lyap() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"M\">M</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.macroexpand\">macroexpand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.malloc\">malloc() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.manage\">manage() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.map!\">map!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.map!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.map\">map() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.mapfoldl\">mapfoldl() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.mapfoldl\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.mapfoldr\">mapfoldr() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.mapfoldr\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.mapreduce\">mapreduce() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.mapreduce\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.mapreducedim\">mapreducedim() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.mapslices\">mapslices() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.mark\">mark() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.match\">match() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.matchall\">matchall() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.max\">max() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.maxabs!\">maxabs!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.maxabs\">maxabs() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.maxabs\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.maximum!\">maximum!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.maximum\">maximum() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.maximum\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.maxintfloat\">maxintfloat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.mean!\">mean!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.mean\">mean() (in module Base)</a>, <a href=\"stdlib/math.html#Base.mean\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.median!\">median!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.median\">median() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.merge!\">merge!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.merge\">merge() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.MersenneTwister\">MersenneTwister() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.method_exists\">method_exists() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.MethodError\">MethodError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.methods\">methods() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.methodswith\">methodswith() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.middle\">middle() (in module Base)</a>, <a href=\"stdlib/math.html#Base.middle\">[1]</a>, <a href=\"stdlib/math.html#Base.middle\">[2]</a>, <a href=\"stdlib/math.html#Base.middle\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.midpoints\">midpoints() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Millisecond\">Millisecond (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Millisecond\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Millisecond\">Millisecond() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.millisecond\">millisecond() (in module Dates)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/io-network.html#Base.mimewritable\">mimewritable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.min\">min() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.minabs!\">minabs!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.minabs\">minabs() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.minabs\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.minimum!\">minimum!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.minimum\">minimum() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.minimum\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.minmax\">minmax() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Minute\">Minute (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Minute\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Minute\">Minute() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.minute\">minute() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.mkdir\">mkdir() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.mkpath\">mkpath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.mktemp\">mktemp() (in module Base)</a>, <a href=\"stdlib/file.html#Base.mktemp\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.mktempdir\">mktempdir() (in module Base)</a>, <a href=\"stdlib/file.html#Base.mktempdir\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.Mmap.Anonymous\">Mmap.Anonymous() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.Mmap.mmap\">Mmap.mmap() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.Mmap.mmap\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.Mmap.sync!\">Mmap.sync!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.mod\">mod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.mod1\">mod1() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.mod2pi\">mod2pi() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.modf\">modf() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/modules.html#index-0\">module</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.module_name\">module_name() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.module_parent\">module_parent() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Month\">Month (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Month\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Month\">Month() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.month\">month() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.monthabbr\">monthabbr() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.monthday\">monthday() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.monthname\">monthname() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.mtime\">mtime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.muladd\">muladd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Mutex\">Mutex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.mv\">mv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.myid\">myid() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"N\">N</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.names\">names() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.NaN\">NaN (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.NaN16\">NaN16 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.NaN32\">NaN32 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.nb_available\">nb_available() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.ndigits\">ndigits() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ndims\">ndims() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.next\">next() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.nextfloat\">nextfloat() (in module Base)</a>, <a href=\"stdlib/numbers.html#Base.nextfloat\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.nextind\">nextind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.nextpow\">nextpow() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.nextpow2\">nextpow2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.nextprod\">nextprod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.nfields\">nfields() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.nnz\">nnz() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.nonzeros\">nonzeros() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.norm\">norm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.normalize!\">normalize!() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.normalize\">normalize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.normalize_string\">normalize_string() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.normpath\">normpath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.nothing\">nothing (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.notify\">notify() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.now\">now() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.now\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.nprocs\">nprocs() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.nrm2\">nrm2() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.ntoh\">ntoh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ntuple\">ntuple() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Nullable\">Nullable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.NullException\">NullException() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.nullspace\">nullspace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.num\">num() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.num2hex\">num2hex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.nworkers\">nworkers() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.nzrange\">nzrange() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"O\">O</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.object_id\">object_id() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.oct\">oct() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.oftype\">oftype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.one\">one() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ones\">ones() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.ones\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.open\">open() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.open\">[1]</a>, <a href=\"stdlib/io-network.html#Base.open\">[2]</a>, <a href=\"stdlib/io-network.html#Base.open\">[3]</a>, <a href=\"stdlib/io-network.html#Base.open\">[4]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.operm\">operm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ordschur!\">ordschur!() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.ordschur!\">[1]</a>, <a href=\"stdlib/linalg.html#Base.ordschur!\">[2]</a>, <a href=\"stdlib/linalg.html#Base.ordschur!\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.ordschur\">ordschur() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.ordschur\">[1]</a>, <a href=\"stdlib/linalg.html#Base.ordschur\">[2]</a>, <a href=\"stdlib/linalg.html#Base.ordschur\">[3]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.orghr!\">orghr!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.orglq!\">orglq!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.orgql!\">orgql!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.orgqr!\">orgqr!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.orgrq!\">orgrq!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ormlq!\">ormlq!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ormql!\">ormql!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ormqr!\">ormqr!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ormrq!\">ormrq!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ormrz!\">ormrz!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.OutOfMemoryError\">OutOfMemoryError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.OverflowError\">OverflowError() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"P\">P</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/arrays.html#Base.parent\">parent() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.parentindexes\">parentindexes() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.parse\">parse() (in module Base)</a>, <a href=\"stdlib/base.html#Base.parse\">[1]</a>, <a href=\"stdlib/numbers.html#Base.parse\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ParseError\">ParseError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.peakflops\">peakflops() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.peek\">peek() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Period\">Period (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.permute!\">permute!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.permutedims!\">permutedims!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.permutedims\">permutedims() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.pi\">pi (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.pin\">pin() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.pin\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.pinv\">pinv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.PipeBuffer\">PipeBuffer() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.PipeBuffer\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.pipeline\">pipeline() (in module Base)</a>, <a href=\"stdlib/base.html#Base.pipeline\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_bfft!\">plan_bfft!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_bfft\">plan_bfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_brfft\">plan_brfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_dct!\">plan_dct!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_dct\">plan_dct() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_fft!\">plan_fft!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_fft\">plan_fft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_idct!\">plan_idct!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_idct\">plan_idct() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_ifft!\">plan_ifft!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_ifft\">plan_ifft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_irfft\">plan_irfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.FFTW.plan_r2r!\">plan_r2r!() (in module Base.FFTW)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.FFTW.plan_r2r\">plan_r2r() (in module Base.FFTW)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.plan_rfft\">plan_rfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.pmap\">pmap() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.pointer\">pointer() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.pointer_from_objref\">pointer_from_objref() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.poll_fd\">poll_fd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.poll_file\">poll_file() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.polygamma\">polygamma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.pop!\">pop!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.pop!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.popdisplay\">popdisplay() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.position\">position() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.posv!\">posv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.potrf!\">potrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.potri!\">potri!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.potrs!\">potrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.powermod\">powermod() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.precision\">precision() (in module Base)</a>, <a href=\"stdlib/numbers.html#Base.precision\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.precompile\">precompile() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.prepend!\">prepend!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.prevfloat\">prevfloat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.prevind\">prevind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.prevpow\">prevpow() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.prevpow2\">prevpow2() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.print\">print() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/profile.html#Base.Profile.print\">(in module Base.Profile)</a>, <a href=\"stdlib/profile.html#Base.Profile.print\">[1]</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/io-network.html#Base.print_shortest\">print_shortest() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.print_with_color\">print_with_color() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.println\">println() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Collections.PriorityQueue\">PriorityQueue() (in module Base.Collections)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.process_exited\">process_exited() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.process_running\">process_running() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ProcessExitedException\">ProcessExitedException() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.procs\">procs() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.procs\">[1]</a>, <a href=\"stdlib/parallel.html#Base.procs\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.prod!\">prod!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.prod\">prod() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.prod\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.produce\">produce() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/profile.html#module-Profile\">Profile (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.PROGRAM_FILE\">PROGRAM_FILE (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.promote\">promote() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.promote_rule\">promote_rule() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.promote_shape\">promote_shape() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.promote_type\">promote_type() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.pstrf!\">pstrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Ptr{T}\">Ptr{T} (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.ptsv!\">ptsv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.pttrf!\">pttrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.pttrs!\">pttrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.push!\">push!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.pushdisplay\">pushdisplay() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.put!\">put!() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.put!\">[1]</a>, <a href=\"stdlib/parallel.html#Base.put!\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.pwd\">pwd() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"Q\">Q</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/arrays.html#Base.q::AbstractVector{Tq})\">q::AbstractVector{Tq})() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.qr\">qr() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.qr\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.qrfact!\">qrfact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.qrfact\">qrfact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.qrfact\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.quadgk\">quadgk() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.quantile!\">quantile!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.quantile\">quantile() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.quarterofyear\">quarterofyear() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.quit\">quit() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"R\">R</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.FFTW.r2r!\">r2r!() (in module Base.FFTW)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.FFTW.r2r\">r2r() (in module Base.FFTW)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.rad2deg\">rad2deg() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.rand!\">rand!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.rand\">rand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.randcycle\">randcycle() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.randexp!\">randexp!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.randexp\">randexp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.randjump\">randjump() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.randn!\">randn!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.randn\">randn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.RandomDevice\">RandomDevice() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.randperm\">randperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.randstring\">randstring() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.randsubseq!\">randsubseq!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.randsubseq\">randsubseq() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.range\">range() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.rank\">rank() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.rata2datetime\">rata2datetime() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.rationalize\">rationalize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.read!\">read!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.read\">read() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.read\">[1]</a>, <a href=\"stdlib/io-network.html#Base.read\">[2]</a>, <a href=\"stdlib/io-network.html#Base.read\">[3]</a>, <a href=\"stdlib/io-network.html#Base.read\">[4]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.readandwrite\">readandwrite() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readavailable\">readavailable() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readbytes!\">readbytes!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readchomp\">readchomp() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readcsv\">readcsv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.readdir\">readdir() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readdlm\">readdlm() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.readdlm\">[1]</a>, <a href=\"stdlib/io-network.html#Base.readdlm\">[2]</a>, <a href=\"stdlib/io-network.html#Base.readdlm\">[3]</a>, <a href=\"stdlib/io-network.html#Base.readdlm\">[4]</a>, <a href=\"stdlib/io-network.html#Base.readdlm\">[5]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readline\">readline() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readlines\">readlines() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.readlink\">readlink() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.ReadOnlyMemoryError\">ReadOnlyMemoryError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readstring\">readstring() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.readuntil\">readuntil() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.real\">real() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.realloc\">realloc() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.realmax\">realmax() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.realmin\">realmin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.realpath\">realpath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#Base.Test.record\">record() (in module Base.Test)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.RecursiveSpinLock\">RecursiveSpinLock() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.recur{T<:TimeType}\">recur{T&lt;:TimeType}() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.recv\">recv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.recvfrom\">recvfrom() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.redirect_stderr\">redirect_stderr() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.redirect_stdin\">redirect_stdin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.redirect_stdout\">redirect_stdout() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.redirect_stdout\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.redisplay\">redisplay() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.reduce\">reduce() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.reduce\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.reducedim\">reducedim() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.reenable_sigint\">reenable_sigint() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.ReentrantLock\">ReentrantLock() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.Ref{T}\">Ref{T} (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.reim\">reim() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.reinterpret\">reinterpret() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.release\">release() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.reload\">reload() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.relpath\">relpath() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.rem\">rem() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/parallel.html#Base.remote\">remote() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.remotecall\">remotecall() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.remotecall\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.remotecall_fetch\">remotecall_fetch() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.remotecall_fetch\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.remotecall_wait\">remotecall_wait() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.remotecall_wait\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.RemoteChannel\">RemoteChannel() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.RemoteChannel\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.RemoteException\">RemoteException() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/stacktraces.html#Base.StackTraces.remove_frames!\">remove_frames!() (in module Base.StackTraces)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.repeat\">repeat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.repeated\">repeated() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.replace\">replace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.repmat\">repmat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.repr\">repr() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.reprmime\">reprmime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.require\">require() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.reset\">reset() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.reshape\">reshape() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.resize!\">resize!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.resolve\">resolve() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.rest\">rest() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.rethrow\">rethrow() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/profile.html#Base.Profile.retrieve\">retrieve() (in module Base.Profile)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.retry\">retry() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.reverse!\">reverse!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.reverse\">reverse() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.reverse\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.reverseind\">reverseind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.rfft\">rfft() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.rm\">rm() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.rm\">(in module Base.Pkg)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/parallel.html#Base.rmprocs\">rmprocs() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.rol!\">rol!() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.rol!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.rol\">rol() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ror!\">ror!() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.ror!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.ror\">ror() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.rot180\">rot180() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.rot180\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.rotl90\">rotl90() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.rotl90\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.rotr90\">rotr90() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.rotr90\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.round\">round() (in module Base)</a>, <a href=\"stdlib/math.html#Base.round\">[1]</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/dates.html#Dates.round\">(in module Dates)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/math.html#Base.RoundDown\">RoundDown (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.rounding\">rounding() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.RoundNearest\">RoundNearest (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.RoundNearestTiesAway\">RoundNearestTiesAway (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.RoundNearestTiesUp\">RoundNearestTiesUp (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.RoundToZero\">RoundToZero (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.RoundUp\">RoundUp (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.rowvals\">rowvals() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.rpad\">rpad() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.rsearch\">rsearch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.rsearchindex\">rsearchindex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.rsplit\">rsplit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.rstrip\">rstrip() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.RTLD_DEEPBIND\">RTLD_DEEPBIND (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.RTLD_FIRST\">RTLD_FIRST (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.RTLD_GLOBAL\">RTLD_GLOBAL (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.RTLD_LAZY\">RTLD_LAZY (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.RTLD_LOCAL\">RTLD_LOCAL (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.RTLD_NODELETE\">RTLD_NODELETE (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.RTLD_NOLOAD\">RTLD_NOLOAD (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libdl.html#Base.Libdl.RTLD_NOW\">RTLD_NOW (in module Base.Libdl)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.run\">run() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/test.html#Base.runtests\">runtests() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"S\">S</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.sbmv!\">sbmv!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.sbmv\">sbmv() (in module Base.LinAlg.BLAS)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.sbmv\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.scal!\">scal!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.scal\">scal() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.scale!\">scale!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.schedule\">schedule() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.schur\">schur() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.schur\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.schurfact!\">schurfact!() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.schurfact!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.schurfact\">schurfact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.schurfact\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.sdata\">sdata() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.search\">search() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.searchindex\">searchindex() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.searchsorted\">searchsorted() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.searchsortedfirst\">searchsortedfirst() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.searchsortedlast\">searchsortedlast() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sec\">sec() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.secd\">secd() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sech\">sech() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Second\">Second (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Second\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Second\">Second() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.second\">second() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.seek\">seek() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.seekend\">seekend() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.seekstart\">seekstart() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.select!\">select!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.select\">select() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.selectperm!\">selectperm!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.selectperm\">selectperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Semaphore\">Semaphore() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.send\">send() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.serialize\">serialize() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.Set\">Set() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.set_num_threads\">set_num_threads() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.set_zero_subnormals\">set_zero_subnormals() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.setdiff!\">setdiff!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.setdiff\">setdiff() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.setenv\">setenv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.setfield!\">setfield!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.setindex!\">setindex!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.setindex!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.setopt\">setopt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.setprecision\">setprecision() (in module Base)</a>, <a href=\"stdlib/numbers.html#Base.setprecision\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.setprotocol!\">setprotocol!() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.setrounding\">setrounding() (in module Base)</a>, <a href=\"stdlib/numbers.html#Base.setrounding\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.SharedArray\">SharedArray() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.SharedArray\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.shift!\">shift!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.show\">show() (in module Base)</a>, <a href=\"stdlib/io-network.html#Base.show\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.showall\">showall() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.showcompact\">showcompact() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.showerror\">showerror() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.shuffle!\">shuffle!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.shuffle\">shuffle() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sign\">sign() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.signbit\">signbit() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.signed\">signed() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.signif\">signif() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.significand\">significand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.similar\">similar() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.similar\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sin\">sin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sinc\">sinc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sind\">sind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sinh\">sinh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sinpi\">sinpi() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.size\">size() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sizehint!\">sizehint!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.sizeof\">sizeof() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.sizeof\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.skip\">skip() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.skipchars\">skipchars() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.sleep\">sleep() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.slicedim\">slicedim() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.sort!\">sort!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.sort\">sort() (in module Base)</a>, <a href=\"stdlib/sort.html#Base.sort\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.sortcols\">sortcols() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.sortperm!\">sortperm!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.sortperm\">sortperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/sort.html#Base.sortrows\">sortrows() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sparse\">sparse() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.sparse\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sparsevec\">sparsevec() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.sparsevec\">[1]</a>, <a href=\"stdlib/arrays.html#Base.sparsevec\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.spawn\">spawn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.spdiagm\">spdiagm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.speye\">speye() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.speye\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.SpinLock\">SpinLock() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.splice!\">splice!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.splice!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.split\">split() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.splitdir\">splitdir() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.splitdrive\">splitdrive() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.splitext\">splitext() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.spones\">spones() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sprand\">sprand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sprandn\">sprandn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.sprint\">sprint() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.spzeros\">spzeros() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.sqrt\">sqrt() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.sqrtm\">sqrtm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.squeeze\">squeeze() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.srand\">srand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/stacktraces.html#Base.StackFrame\">StackFrame (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.StackOverflowError\">StackOverflowError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/stacktraces.html#Base.StackTrace\">StackTrace (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/stacktraces.html#Base.stacktrace\">stacktrace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/stacktraces.html#module-StackTraces\">StackTraces (module)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.start\">start() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.startswith\">startswith() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.stat\">stat() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.status\">status() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.status\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.std\">std() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.STDERR\">STDERR (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.STDIN\">STDIN (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.stdm\">stdm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.STDOUT\">STDOUT (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.stebz!\">stebz!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.stegr!\">stegr!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.stein!\">stein!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.step\">step() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.stev!\">stev!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.strerror\">strerror() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.strftime\">strftime() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.stride\">stride() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.strides\">strides() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.String\">String() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.string\">string() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.stringmime\">stringmime() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.strip\">strip() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.strptime\">strptime() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.strwidth\">strwidth() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sub2ind\">sub2ind() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.subtypes\">subtypes() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.success\">success() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sum!\">sum!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sum\">sum() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.sum\">[1]</a>, <a href=\"stdlib/collections.html#Base.sum\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.sum_kbn\">sum_kbn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sumabs!\">sumabs!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sumabs\">sumabs() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.sumabs\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sumabs2!\">sumabs2!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.sumabs2\">sumabs2() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.sumabs2\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.summary\">summary() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.supertype\">supertype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.svd\">svd() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.svd\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.svdfact!\">svdfact!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.svdfact\">svdfact() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.svdfact\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.svds\">svds() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.svdvals!\">svdvals!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.svdvals\">svdvals() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.svdvals\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.syconv!\">syconv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.syev!\">syev!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.syevr!\">syevr!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.sygvd!\">sygvd!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.sylvester\">sylvester() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.Symbol\">Symbol() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.symdiff!\">symdiff!() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.symdiff!\">[1]</a>, <a href=\"stdlib/collections.html#Base.symdiff!\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.symdiff\">symdiff() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.symlink\">symlink() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symm!\">symm!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symm\">symm() (in module Base.LinAlg.BLAS)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symm\">[1]</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symm\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Symmetric\">Symmetric() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.SymTridiagonal\">SymTridiagonal() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symv!\">symv!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symv\">symv() (in module Base.LinAlg.BLAS)</a>, <a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.symv\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.syr!\">syr!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.syrk!\">syrk!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.syrk\">syrk() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.Sys.ARCH\">Sys.ARCH (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.Sys.CPU_CORES\">Sys.CPU_CORES (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Sys.get_process_title\">Sys.get_process_title() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.Sys.KERNEL\">Sys.KERNEL (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.Sys.MACHINE\">Sys.MACHINE (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Sys.set_process_title\">Sys.set_process_title() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.Sys.WORD_SIZE\">Sys.WORD_SIZE (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.SystemError\">SystemError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.systemerror\">systemerror() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.sysv!\">sysv!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.sytrf!\">sytrf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.sytri!\">sytri!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.sytrs!\">sytrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"T\">T</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/parallel.html#Base.take!\">take!() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.take!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.take\">take() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.takebuf_array\">takebuf_array() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.takebuf_string\">takebuf_string() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.tan\">tan() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.tand\">tand() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.tanh\">tanh() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Task\">Task() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.task_local_storage\">task_local_storage() (in module Base)</a>, <a href=\"stdlib/parallel.html#Base.task_local_storage\">[1]</a>, <a href=\"stdlib/parallel.html#Base.task_local_storage\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.tempdir\">tempdir() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.tempname\">tempname() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.test\">test() (in module Base.Pkg)</a>, <a href=\"stdlib/pkg.html#Base.Pkg.test\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.TextDisplay\">TextDisplay() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.tgsen!\">tgsen!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.@threads\">Threads.@threads() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_add!{T}\">Threads.atomic_add!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_and!{T}\">Threads.atomic_and!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_cas!{T}\">Threads.atomic_cas!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_fence\">Threads.atomic_fence() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_max!{T}\">Threads.atomic_max!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_min!{T}\">Threads.atomic_min!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_nand!{T}\">Threads.atomic_nand!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_or!{T}\">Threads.atomic_or!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_sub!{T}\">Threads.atomic_sub!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_xchg!{T}\">Threads.atomic_xchg!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.atomic_xor!{T}\">Threads.atomic_xor!{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.Atomic{T}\">Threads.Atomic{T}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.nthreads\">Threads.nthreads() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.Threads.threadid\">Threads.threadid() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.throw\">throw() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.tic\">tic() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.time\">time() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/libc.html#Base.Libc.time\">(in module Base.Libc)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/base.html#Base.time_ns\">time_ns() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.timedwait\">timedwait() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Timer\">Timer() (in module Base)</a>, <a href=\"stdlib/base.html#Base.Timer\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.TimeType\">TimeType (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/libc.html#Base.Libc.TmStruct\">TmStruct() (in module Base.Libc)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.toc\">toc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.today\">today() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.tofirst\">tofirst() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.tolast\">tolast() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.tonext\">tonext() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.tonext\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.toprev\">toprev() (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.toprev\">[1]</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.toq\">toq() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.touch\">touch() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.trace\">trace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.trailing_ones\">trailing_ones() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.trailing_zeros\">trailing_zeros() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.transcode\">transcode() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.transpose!\">transpose!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.transpose\">transpose() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trcon!\">trcon!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trevc!\">trevc!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trexc!\">trexc!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.Tridiagonal\">Tridiagonal() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.Tridiagonal\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.trigamma\">trigamma() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.tril!\">tril!() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.tril!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.tril\">tril() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.tril\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.triu!\">triu!() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.triu!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.triu\">triu() (in module Base)</a>, <a href=\"stdlib/linalg.html#Base.triu\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trmm!\">trmm!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trmm\">trmm() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trmv!\">trmv!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trmv\">trmv() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trrfs!\">trrfs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trsen!\">trsen!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trsm!\">trsm!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trsm\">trsm() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trsv!\">trsv!() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.BLAS.trsv\">trsv() (in module Base.LinAlg.BLAS)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trsyl!\">trsyl!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trtri!\">trtri!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.trtrs!\">trtrs!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.trues\">trues() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.trues\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.trunc\">trunc() (in module Base)</a>\n  </dt>\n\n      <dd><dl>\n        \n  <dt><a href=\"stdlib/dates.html#Dates.trunc\">(in module Dates)</a>\n  </dt>\n\n      </dl></dd>\n      \n  <dt><a href=\"stdlib/io-network.html#Base.truncate\">truncate() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.trylock\">trylock() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.tryparse\">tryparse() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.tuple\">tuple() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.TypeError\">TypeError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.typeintersect\">typeintersect() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.typejoin\">typejoin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.typemax\">typemax() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.typemin\">typemin() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.typeof\">typeof() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.LinAlg.LAPACK.tzrzf!\">tzrzf!() (in module Base.LinAlg.LAPACK)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"U\">U</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/strings.html#Base.ucfirst\">ucfirst() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.UndefRefError\">UndefRefError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.UndefVarError\">UndefVarError() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.unescape_string\">unescape_string() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.unescape_string\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.union!\">union!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.union\">union() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.unique\">unique() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.unique\">[1]</a>, <a href=\"stdlib/collections.html#Base.unique\">[2]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.unix2datetime\">unix2datetime() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.unlock\">unlock() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.unmark\">unmark() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.unsafe_convert\">unsafe_convert() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.unsafe_copy!\">unsafe_copy!() (in module Base)</a>, <a href=\"stdlib/c.html#Base.unsafe_copy!\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.unsafe_load\">unsafe_load() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.unsafe_pointer_to_objref\">unsafe_pointer_to_objref() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/io-network.html#Base.unsafe_read\">unsafe_read() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.unsafe_store!\">unsafe_store!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.unsafe_string\">unsafe_string() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.unsafe_trunc\">unsafe_trunc() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/c.html#Base.unsafe_wrap\">unsafe_wrap() (in module Base)</a>, <a href=\"stdlib/strings.html#Base.unsafe_wrap\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.unsafe_write\">unsafe_write() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.unshift!\">unshift!() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.unsigned\">unsigned() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/pkg.html#Base.Pkg.update\">update() (in module Base.Pkg)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.uperm\">uperm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/strings.html#Base.uppercase\">uppercase() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"manual/modules.html#index-0\">using</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.UTInstant{T}\">UTInstant{T} (in module Dates)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"V\">V</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/collections.html#Base.valtype\">valtype() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.values\">values() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.Val{c}\">Val{c}() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.var\">var() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.varm\">varm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.vcat\">vcat() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/arrays.html#Base.vec\">vec() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.vecdot\">vecdot() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.vecnorm\">vecnorm() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/constants.html#Base.VERSION\">VERSION (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.versioninfo\">versioninfo() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.view\">view() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"W\">W</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/parallel.html#Base.wait\">wait() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/file.html#Base.walkdir\">walkdir() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.warn\">warn() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.watch_file\">watch_file() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Week\">Week (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Week\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Week\">Week() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.week\">week() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.which\">which() (in module Base)</a>, <a href=\"stdlib/base.html#Base.which\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.whos\">whos() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.widemul\">widemul() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/base.html#Base.widen\">widen() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.windows_version\">windows_version() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.withenv\">withenv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.WorkerPool\">WorkerPool() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.workers\">workers() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.workspace\">workspace() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.write\">write() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.writecsv\">writecsv() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/io-network.html#Base.writedlm\">writedlm() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"X\">X</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.xcorr\">xcorr() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"Y\">Y</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Year\">Year (in module Dates)</a>, <a href=\"stdlib/dates.html#Dates.Year\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.Year\">Year() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.year\">year() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/dates.html#Dates.yearmonth\">yearmonth() (in module Dates)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/dates.html#Dates.yearmonthday\">yearmonthday() (in module Dates)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.yield\">yield() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/parallel.html#Base.yieldto\">yieldto() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"Z\">Z</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/numbers.html#Base.zero\">zero() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/arrays.html#Base.zeros\">zeros() (in module Base)</a>, <a href=\"stdlib/arrays.html#Base.zeros\">[1]</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/math.html#Base.zeta\">zeta() (in module Base)</a>, <a href=\"stdlib/math.html#Base.zeta\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.zip\">zip() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n<h2 id=\"Symbols\">Symbols</h2>\n<table style=\"width: 100%\" class=\"indextable genindextable\"><tr>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/linalg.html#Base.\u00d7\">\u00d7() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.\u00f7\">\u00f7() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.\u03b3\">\u03b3 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.\u03c0\">\u03c0 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/numbers.html#Base.\u03c6\">\u03c6 (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u2208\">\u2208() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u2209\">\u2209() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u220b\">\u220b() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u220c\">\u220c() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u2229\">\u2229() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n  <td style=\"width: 33%\" valign=\"top\"><dl>\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u222a\">\u222a() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/base.html#Base.\u2261\">\u2261() (in module Base)</a>, <a href=\"stdlib/math.html#Base.\u2261\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.\u2262\">\u2262() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.\u2264\">\u2264() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/math.html#Base.\u2265\">\u2265() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u2286\">\u2286() (in module Base)</a>, <a href=\"stdlib/collections.html#Base.\u2286\">[1]</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u2288\">\u2288() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/collections.html#Base.\u228a\">\u228a() (in module Base)</a>\n  </dt>\n\n      \n  <dt><a href=\"stdlib/linalg.html#Base.\u22c5\">\u22c5() (in module Base)</a>\n  </dt>\n\n  </dl></td>\n</tr></table>\n\n\n\n          </div>\n          <footer>\n  \n\n  <hr/>\n\n  <div role=\"contentinfo\">\n    <p>\n    </p>\n  </div>\n\n  <a href=\"https://github.com/snide/sphinx_rtd_theme\">Sphinx theme</a> provided by <a href=\"https://readthedocs.org\">Read the Docs</a>\n</footer>\n        </div>\n      </div>\n\n    </section>\n\n  </div>\n  \n\n  \n\n    <script type=\"text/javascript\">\n        var DOCUMENTATION_OPTIONS = {\n            URL_ROOT:'./',\n            VERSION:'0.5.1',\n            COLLAPSE_INDEX:false,\n            FILE_SUFFIX:'.html',\n            HAS_SOURCE:  true\n        };\n    </script>\n      <script type=\"text/javascript\" src=\"_static/jquery.js\"></script>\n      <script type=\"text/javascript\" src=\"_static/underscore.js\"></script>\n      <script type=\"text/javascript\" src=\"_static/doctools.js\"></script>\n      <script type=\"text/javascript\" src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>\n\n  \n\n  \n  \n    <script type=\"text/javascript\" src=\"_static/js/theme.js\"></script>\n  \n\n  \n  \n  <script type=\"text/javascript\">\n      jQuery(function () {\n          SphinxRtdTheme.StickyNav.enable();\n      });\n  </script>\n   \n\n</body>\n</html>",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_sources/stdlib/libdl.txt": ".. module:: Libdl\n\n****************\n Dynamic Linker\n****************\n\n.. currentmodule:: Base.Libdl\n\nThe names in :mod:`Base.Libdl` are not exported and need to be called e.g. as ``Libdl.dlopen()``.\n\n.. function:: dlopen(libfile::AbstractString [, flags::Integer])\n\n   .. Docstring generated from Julia source\n\n   Load a shared library, returning an opaque handle.\n\n   The optional flags argument is a bitwise-or of zero or more of ``RTLD_LOCAL``\\ , ``RTLD_GLOBAL``\\ , ``RTLD_LAZY``\\ , ``RTLD_NOW``\\ , ``RTLD_NODELETE``\\ , ``RTLD_NOLOAD``\\ , ``RTLD_DEEPBIND``\\ , and ``RTLD_FIRST``\\ . These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default ``dlopen`` flags are ``RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL`` while on other platforms the defaults are ``RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL``\\ . An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance ``RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL`` allows the library's symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.\n\n.. function:: dlopen_e(libfile::AbstractString [, flags::Integer])\n\n   .. Docstring generated from Julia source\n\n   Similar to :func:`dlopen`\\ , except returns a ``NULL`` pointer instead of raising errors.\n\n.. data:: RTLD_DEEPBIND\n          RTLD_FIRST\n          RTLD_GLOBAL\n          RTLD_LAZY\n          RTLD_LOCAL\n          RTLD_NODELETE\n          RTLD_NOLOAD\n          RTLD_NOW\n\n   .. Docstring generated from Julia source\n\n   Enum constant for :func:`dlopen`\\ . See your platform man page for details, if applicable.\n\n.. function:: dlsym(handle, sym)\n\n   .. Docstring generated from Julia source\n\n   Look up a symbol from a shared library handle, return callable function pointer on success.\n\n.. function:: dlsym_e(handle, sym)\n\n   .. Docstring generated from Julia source\n\n   Look up a symbol from a shared library handle, silently return ``NULL`` pointer on lookup failure.\n\n.. function:: dlclose(handle)\n\n   .. Docstring generated from Julia source\n\n   Close shared library referenced by handle.\n\n.. data:: dlext\n\n   .. Docstring generated from Julia source\n\n   File extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.\n\n.. function:: find_library(names, locations)\n\n   .. Docstring generated from Julia source\n\n   Searches for the first library in ``names`` in the paths in the ``locations`` list, ``DL_LOAD_PATH``\\ , or system library paths (in that order) which can successfully be dlopen'd. On success, the return value will be one of the names (potentially prefixed by one of the paths in locations). This string can be assigned to a ``global const`` and used as the library name in future ``ccall``\\ 's. On failure, it returns the empty string.\n\n.. data:: DL_LOAD_PATH\n\n   .. Docstring generated from Julia source\n\n   When calling :func:`dlopen`\\ , the paths in this list will be searched first, in order, before searching the system locations for a valid library handle.\n\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_sources/stdlib/c.txt": ".. currentmodule:: Base\n\n*************\n C Interface\n*************\n\n.. function:: ccall((symbol, library) or function_pointer, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n\n   .. Docstring generated from Julia source\n\n   Call function in C-exported shared library, specified by ``(function name, library)`` tuple, where each component is a string or symbol.\n\n   Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression. Alternatively, ``ccall`` may also be used to call a function pointer, such as one returned by ``dlsym``\\ .\n\n   Each ``ArgumentValue`` to the ``ccall`` will be converted to the corresponding ``ArgumentType``\\ , by automatic insertion of calls to ``unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))``\\ . (See also the documentation for each of these functions for further details.) In most cases, this simply results in a call to ``convert(ArgumentType, ArgumentValue)``\\ .\n\n.. function:: cglobal((symbol, library) [, type=Void])\n\n   .. Docstring generated from Julia source\n\n   Obtain a pointer to a global variable in a C-exported shared library, specified exactly as in ``ccall``\\ . Returns a ``Ptr{Type}``\\ , defaulting to ``Ptr{Void}`` if no Type argument is supplied. The values can be read or written by ``unsafe_load`` or ``unsafe_store!``\\ , respectively.\n\n.. function:: cfunction(function::Function, ReturnType::Type, (ArgumentTypes...))\n\n   .. Docstring generated from Julia source\n\n   Generate C-callable function pointer from Julia function. Type annotation of the return value in the callback function is a must for situations where Julia cannot infer the return type automatically.\n\n   For example:\n\n   .. code-block:: julia\n\n       function foo()\n           # body\n\n           retval::Float64\n       end\n\n       bar = cfunction(foo, Float64, ())\n\n.. function:: unsafe_convert(T,x)\n\n   .. Docstring generated from Julia source\n\n   Convert ``x`` to a value of type ``T``\n\n   In cases where ``convert`` would need to take a Julia object and turn it into a ``Ptr``\\ , this function should be used to define and perform that conversion.\n\n   Be careful to ensure that a Julia reference to ``x`` exists as long as the result of this function will be used. Accordingly, the argument ``x`` to this function should never be an expression, only a variable name or field reference. For example, ``x=a.b.c`` is acceptable, but ``x=[a,b,c]`` is not.\n\n   The ``unsafe`` prefix on this function indicates that using the result of this function after the ``x`` argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.\n\n.. function:: cconvert(T,x)\n\n   .. Docstring generated from Julia source\n\n   Convert ``x`` to a value of type ``T``\\ , typically by calling ``convert(T,x)``\n\n   In cases where ``x`` cannot be safely converted to ``T``\\ , unlike ``convert``\\ , ``cconvert`` may return an object of a type different from ``T``\\ , which however is suitable for ``unsafe_convert`` to handle.\n\n   Neither ``convert`` nor ``cconvert`` should take a Julia object and turn it into a ``Ptr``\\ .\n\n.. function:: unsafe_load(p::Ptr{T}, [i::Integer=1])\n\n   .. Docstring generated from Julia source\n\n   Load a value of type ``T`` from the address of the ith element (1-indexed) starting at ``p``\\ . This is equivalent to the C expression ``p[i-1]``\\ .\n\n   The ``unsafe`` prefix on this function indicates that no validation is performed on the pointer ``p`` to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.\n\n.. function:: unsafe_store!(p::Ptr{T}, x, [i::Integer=1])\n\n   .. Docstring generated from Julia source\n\n   Store a value of type ``T`` to the address of the ith element (1-indexed) starting at ``p``\\ . This is equivalent to the C expression ``p[i-1] = x``\\ .\n\n   The ``unsafe`` prefix on this function indicates that no validation is performed on the pointer ``p`` to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n.. function:: unsafe_copy!(dest::Ptr{T}, src::Ptr{T}, N)\n\n   .. Docstring generated from Julia source\n\n   Copy ``N`` elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.\n\n   The ``unsafe`` prefix on this function indicates that no validation is performed on the pointers ``dest`` and ``src`` to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n.. function:: unsafe_copy!(dest::Array, do, src::Array, so, N)\n\n   .. Docstring generated from Julia source\n\n   Copy ``N`` elements from a source array to a destination, starting at offset ``so`` in the source and ``do`` in the destination (1-indexed).\n\n   The ``unsafe`` prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n.. function:: copy!(dest, src)\n\n   .. Docstring generated from Julia source\n\n   Copy all elements from collection ``src`` to array ``dest``\\ . Returns ``dest``\\ .\n\n.. function:: copy!(dest, do, src, so, N)\n\n   .. Docstring generated from Julia source\n\n   Copy ``N`` elements from collection ``src`` starting at offset ``so``\\ , to array ``dest`` starting at offset ``do``\\ . Returns ``dest``\\ .\n\n.. function:: pointer(array [, index])\n\n   .. Docstring generated from Julia source\n\n   Get the native address of an array or string element. Be careful to ensure that a Julia reference to ``a`` exists as long as this pointer will be used. This function is \"unsafe\" like ``unsafe_convert``\\ .\n\n   Calling ``Ref(array[, index])`` is generally preferable to this function.\n\n.. function:: unsafe_wrap(Array, pointer::Ptr{T}, dims, own=false)\n\n   .. Docstring generated from Julia source\n\n   Wrap a Julia ``Array`` object around the data at the address given by ``pointer``\\ , without making a copy.  The pointer element type ``T`` determines the array element type. ``dims`` is either an integer (for a 1d array) or a tuple of the array dimensions. ``own`` optionally specifies whether Julia should take ownership of the memory, calling ``free`` on the pointer when the array is no longer referenced.\n\n   This function is labelled \"unsafe\" because it will crash if ``pointer`` is not a valid memory address to data of the requested length.\n\n.. function:: pointer_from_objref(object_instance)\n\n   .. Docstring generated from Julia source\n\n   Get the memory address of a Julia object as a ``Ptr``\\ . The existence of the resulting ``Ptr`` will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the ``Ptr`` will be used.\n\n.. function:: unsafe_pointer_to_objref(p::Ptr)\n\n   .. Docstring generated from Julia source\n\n   Convert a ``Ptr`` to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered \"unsafe\" and should be used with care.\n\n.. function:: disable_sigint(f::Function)\n\n   .. Docstring generated from Julia source\n\n   Disable Ctrl-C handler during execution of a function on the current task, for calling external code that may call julia code that is not interrupt safe. Intended to be called using ``do`` block syntax as follows:\n\n   .. code-block:: julia\n\n       disable_sigint() do\n           # interrupt-unsafe code\n           ...\n       end\n\n   This is not needed on worker threads (``Threads.threadid() != 1``\\ ) since the ``InterruptException`` will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.\n\n.. function:: reenable_sigint(f::Function)\n\n   .. Docstring generated from Julia source\n\n   Re-enable Ctrl-C handler during execution of a function. Temporarily reverses the effect of ``disable_sigint``\\ .\n\n.. function:: systemerror(sysfunc, iftrue)\n\n   .. Docstring generated from Julia source\n\n   Raises a ``SystemError`` for ``errno`` with the descriptive string ``sysfunc`` if ``iftrue`` is ``true``\n\n.. data:: Ptr{T}\n\n   .. Docstring generated from Julia source\n\n   A memory address referring to data of type ``T``\\ .  However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.\n\n.. data:: Ref{T}\n\n   .. Docstring generated from Julia source\n\n   An object that safely references data of type ``T``\\ . This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the ``Ref`` itself is referenced.\n\n   When passed as a ``ccall`` argument (either as a ``Ptr`` or ``Ref`` type), a ``Ref`` object will be converted to a native pointer to the data it references.\n\n   There is no invalid (NULL) ``Ref``\\ .\n\n.. data:: Cchar\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``char`` c-type.\n\n.. data:: Cuchar\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``unsigned char`` c-type (``UInt8``\\ ).\n\n.. data:: Cshort\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``signed short`` c-type (``Int16``\\ ).\n\n.. data:: Cushort\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``unsigned short`` c-type (``UInt16``\\ ).\n\n.. data:: Cint\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``signed int`` c-type (``Int32``\\ ).\n\n.. data:: Cuint\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``unsigned int`` c-type (``UInt32``\\ ).\n\n.. data:: Clong\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``signed long`` c-type.\n\n.. data:: Culong\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``unsigned long`` c-type.\n\n.. data:: Clonglong\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``signed long long`` c-type (``Int64``\\ ).\n\n.. data:: Culonglong\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``unsigned long long`` c-type (``UInt64``\\ ).\n\n.. data:: Cintmax_t\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``intmax_t`` c-type (``Int64``\\ ).\n\n.. data:: Cuintmax_t\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``uintmax_t`` c-type (``UInt64``\\ ).\n\n.. data:: Csize_t\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``size_t`` c-type (``UInt``\\ ).\n\n.. data:: Cssize_t\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``ssize_t`` c-type.\n\n.. data:: Cptrdiff_t\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``ptrdiff_t`` c-type (``Int``\\ ).\n\n.. data:: Cwchar_t\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``wchar_t`` c-type (``Int32``\\ ).\n\n.. data:: Cfloat\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``float`` c-type (``Float32``\\ ).\n\n.. data:: Cdouble\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``double`` c-type (``Float64``\\ ).\n\n****************\n LLVM Interface\n****************\n\n.. function:: llvmcall(IR::String, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n              llvmcall((declarations::String, IR::String), ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n\n   .. Docstring generated from Julia source\n\n   Call LLVM IR string in the first argument. Similar to an LLVM function ``define`` block, arguments are available as consecutive unnamed SSA variables (%0, %1, etc.).\n\n   The optional declarations string contains external functions declarations that are necessary for llvm to compile the IR string. Multiple declarations can be passed in by separating them with line breaks.\n\n   Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.\n\n   Each ``ArgumentValue`` to ``llvmcall`` will be converted to the corresponding ``ArgumentType``\\ , by automatic insertion of calls to ``unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))``\\ . (see also the documentation for each of these functions for further details). In most cases, this simply results in a call to ``convert(ArgumentType, ArgumentValue)``\\ .\n\n   See ``test/llvmcall.jl`` for usage examples.\n\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_sources/manual/calling-c-and-fortran-code.txt": ".. _man-calling-c-and-fortran-code:\n\n.. currentmodule:: Base\n\n****************************\n Calling C and Fortran Code\n****************************\n\nThough most code can be written in Julia, there are many high-quality,\nmature libraries for numerical computing already written in C and\nFortran. To allow easy use of this existing code, Julia makes it simple\nand efficient to call C and Fortran functions. Julia has a \"no\nboilerplate\" philosophy: functions can be called directly from Julia\nwithout any \"glue\" code, code generation, or compilation \u2014 even from the\ninteractive prompt. This is accomplished just by making an appropriate call\nwith :func:`ccall` syntax, which looks like an ordinary function call.\n\nThe code to be called must be available as a shared library. Most C and\nFortran libraries ship compiled as shared libraries already, but if you\nare compiling the code yourself using GCC (or Clang), you will need to\nuse the ``-shared`` and ``-fPIC`` options. The machine instructions\ngenerated by Julia's JIT are the same as a native C call would be, so\nthe resulting overhead is the same as calling a library function from C\ncode. (Non-library function calls in both C and Julia can be inlined and\nthus may have even less overhead than calls to shared library functions.\nWhen both libraries and executables are generated by LLVM, it is\npossible to perform whole-program optimizations that can even optimize\nacross this boundary, but Julia does not yet support that. In the\nfuture, however, it may do so, yielding even greater performance gains.)\n\nShared libraries and functions are referenced by a tuple of the\nform ``(:function, \"library\")`` or ``(\"function\", \"library\")`` where ``function``\nis the C-exported function name. ``library`` refers to the shared library\nname: shared libraries available in the (platform-specific) load path\nwill be resolved by name, and if necessary a direct path may be specified.\n\nA function name may be used alone in place of the tuple (just\n``:function`` or ``\"function\"``). In this case the name is resolved within\nthe current process. This form can be used to call C library functions,\nfunctions in the Julia runtime, or functions in an application linked to\nJulia.\n\nBy default, Fortran compilers `generate mangled names\n<https://en.wikipedia.org/wiki/Name_mangling#Fortran>`_\n(for example, converting function names to lowercase or uppercase,\noften appending an underscore), and so to call a Fortran function via\n:func:`ccall` you must pass the mangled identifier corresponding to the rule\nfollowed by your Fortran compiler.  Also, when calling a Fortran\nfunction, all inputs must be passed by reference.\n\nFinally, you can use :func:`ccall` to actually generate a call to the\nlibrary function. Arguments to :func:`ccall` are as follows:\n\n1. (:function, \"library\") pair (must be a constant, but see below).\n\n2. Return type (see below for mapping the declared C type to Julia)\n\n   - This argument will be evaluated at compile-time.\n\n3. A tuple of input types. The input types must be written as a literal tuple,\n   not a tuple-valued variable or expression.\n\n   - This argument will be evaluated at compile-time.\n\n4. The following arguments, if any, are the actual argument values\n   passed to the function.\n\nAs a complete but simple example, the following calls the ``clock``\nfunction from the standard C library::\n\n    julia> t = ccall( (:clock, \"libc\"), Int32, ())\n    2292761\n\n    julia> t\n    2292761\n\n    julia> typeof(ans)\n    Int32\n\n``clock`` takes no arguments and returns an ``Int32``. One common gotcha\nis that a 1-tuple must be written with a trailing comma. For\nexample, to call the ``getenv`` function to get a pointer to the value\nof an environment variable, one makes a call like this::\n\n    julia> path = ccall((:getenv, \"libc\"), Cstring, (Cstring,), \"SHELL\")\n    Cstring(@0x00007fff5fbffc45)\n\n    julia> unsafe_string(path)\n    \"/bin/bash\"\n\nNote that the argument type tuple must be written as ``(Cstring,)``,\nrather than ``(Cstring)``. This is because ``(Cstring)`` is just\nthe expression ``Cstring`` surrounded by parentheses, rather than\na 1-tuple containing ``Cstring``:\n\n.. doctest::\n\n    julia> (Cstring)\n    Cstring\n\n    julia> (Cstring,)\n    (Cstring,)\n\nIn practice, especially when providing reusable functionality, one\ngenerally wraps :func:`ccall` uses in Julia functions that set up arguments\nand then check for errors in whatever manner the C or Fortran function\nindicates them, propagating to the Julia caller as exceptions. This is\nespecially important since C and Fortran APIs are notoriously\ninconsistent about how they indicate error conditions. For example, the\n``getenv`` C library function is wrapped in the following Julia function,\nwhich is a simplified version of the actual definition from\n`env.jl <https://github.com/JuliaLang/julia/blob/release-0.5/base/env.jl>`_::\n\n    function getenv(var::AbstractString)\n      val = ccall((:getenv, \"libc\"),\n                  Cstring, (Cstring,), var)\n      if val == C_NULL\n        error(\"getenv: undefined variable: \", var)\n      end\n      unsafe_string(val)\n    end\n\nThe C ``getenv`` function indicates an error by returning ``NULL``, but\nother standard C functions indicate errors in various different ways,\nincluding by returning -1, 0, 1 and other special values. This wrapper\nthrows an exception clearly indicating the problem if the caller tries\nto get a non-existent environment variable::\n\n    julia> getenv(\"SHELL\")\n    \"/bin/bash\"\n\n    julia> getenv(\"FOOBAR\")\n    getenv: undefined variable: FOOBAR\n\nHere is a slightly more complex example that discovers the local\nmachine's hostname::\n\n    function gethostname()\n      hostname = Array{UInt8}(128)\n      ccall((:gethostname, \"libc\"), Int32,\n            (Ptr{UInt8}, Csize_t),\n            hostname, sizeof(hostname))\n      hostname[end] = 0; # ensure null-termination\n      return unsafe_string(pointer(hostname))\n    end\n\nThis example first allocates an array of bytes, then calls the C library\nfunction ``gethostname`` to fill the array in with the hostname, takes a\npointer to the hostname buffer, and converts the pointer to a Julia\nstring, assuming that it is a NUL-terminated C string. It is common for\nC libraries to use this pattern of requiring the caller to allocate\nmemory to be passed to the callee and filled in. Allocation of memory\nfrom Julia like this is generally accomplished by creating an\nuninitialized array and passing a pointer to its data to the C function.\nThis is why we don't use the ``Cstring`` type here: as the array is\nuninitialized, it could contain NUL bytes. Converting to a ``Cstring`` as\npart of the :func:`ccall` checks for contained NUL bytes and could therefore\nthrow a conversion error.\n\nCreating C-Compatible Julia Function Pointers\n---------------------------------------------\n\nIt is possible to pass Julia functions to native C functions that accept\nfunction pointer arguments. For example, to match C prototypes of the form::\n\n    typedef returntype (*functiontype)(argumenttype,...)\n\nThe function :func:`cfunction` generates the C-compatible function pointer for\na call to a Julia library function.\nArguments to :func:`cfunction` are as follows:\n\n1. A Julia Function\n\n2. Return type\n\n3. A tuple of input types\n\nA classic example is the standard C library ``qsort`` function,\ndeclared as::\n\n    void qsort(void *base, size_t nmemb, size_t size,\n               int(*compare)(const void *a, const void *b));\n\nThe ``base`` argument is a pointer to an array of length ``nmemb``, with elements of\n``size`` bytes each. ``compare`` is a callback function which takes pointers to two\nelements ``a`` and ``b`` and returns an integer less/greater than zero if ``a`` should\nappear before/after ``b`` (or zero if any order is permitted). Now, suppose that we\nhave a 1d array ``A`` of values in Julia that we want to sort using the ``qsort``\nfunction (rather than Julia's built-in ``sort`` function). Before we worry about calling\n``qsort`` and passing arguments, we need to write a comparison function that works for\nsome arbitrary type T::\n\n    function mycompare{T}(a::T, b::T)\n        return convert(Cint, a < b ? -1 : a > b ? +1 : 0)::Cint\n    end\n\nNotice that we have to be careful about the return type: ``qsort`` expects a function\nreturning a C ``int``, so we must be sure to return ``Cint`` via a call to ``convert``\nand a ``typeassert``.\n\nIn order to pass this function to C, we obtain its address using the function ``cfunction``::\n\n    const mycompare_c = cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}))\n\n:func:`cfunction` accepts three arguments: the Julia function (``mycompare``),\nthe return type (``Cint``), and a tuple of the argument types, in this case to\nsort an array of ``Cdouble`` (``Float64``) elements.\n\nThe final call to ``qsort`` looks like this::\n\n    A = [1.3, -2.7, 4.4, 3.1]\n    ccall(:qsort, Void, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Void}),\n          A, length(A), sizeof(eltype(A)), mycompare_c)\n\nAfter this executes, ``A`` is changed to the sorted array ``[-2.7, 1.3, 3.1, 4.4]``.\nNote that Julia knows how to convert an array into a ``Ptr{Cdouble}``, how to compute\nthe size of a type in bytes (identical to C's ``sizeof`` operator), and so on.\nFor fun, try inserting a ``println(\"mycompare($a,$b)\")`` line into ``mycompare``, which\nwill allow you to see the comparisons that ``qsort`` is performing (and to verify that\nit is really calling the Julia function that you passed to it).\n\n\nMapping C Types to Julia\n------------------------\n\nIt is critical to exactly match the declared C type with its declaration\nin Julia. Inconsistencies can cause code that works correctly on one system\nto fail or produce indeterminate results on a different system.\n\nNote that no C header files are used anywhere in the process of calling C\nfunctions: you are responsible for making sure that your Julia types and\ncall signatures accurately reflect those in the C header file. (The `Clang\npackage <https://github.com/ihnorton/Clang.jl>`_ can be used to auto-generate\nJulia code from a C header file.)\n\nAuto-conversion:\n~~~~~~~~~~~~~~~~\n\nJulia automatically inserts calls to the :func:`cconvert` function to convert\neach argument to the specified type. For example, the following call::\n\n    ccall((:foo, \"libfoo\"), Void, (Int32, Float64), x, y)\n\nwill behave as if the following were written::\n\n    ccall((:foo, \"libfoo\"), Void, (Int32, Float64),\n          Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),\n          Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))\n\n:func:`cconvert` normally just calls :func:`convert`, but can be defined to return\nan arbitrary new object more appropriate for passing to C. For example,\nthis is used to convert an ``Array`` of objects (e.g. strings) to an\narray of pointers.\n\n:func:`unsafe_convert` handles conversion to ``Ptr`` types. It is considered\nunsafe because converting an object to a native pointer can hide the object\nfrom the garbage collector, causing it to be freed prematurely.\n\nType Correspondences:\n~~~~~~~~~~~~~~~~~~~~~\n\nFirst, a review of some relevant Julia type terminology:\n\n.. rst-class:: text-wrap\n\n==============================  ==============================  ======================================================\nSyntax / Keyword                Example                         Description\n==============================  ==============================  ======================================================\n``type``                        ``String``                      \"Leaf Type\" :: A group of related data that includes\n                                                                a type-tag, is managed by the Julia GC, and\n                                                                is defined by object-identity.\n                                                                The type parameters of a leaf type must be fully defined\n                                                                (no ``TypeVars`` are allowed)\n                                                                in order for the instance to be constructed.\n\n``abstract``                    ``Any``,                        \"Super Type\" :: A super-type (not a leaf-type)\n                                ``AbstractArray{T,N}``,         that cannot be instantiated, but can be used to\n                                ``Complex{T}``                  describe a group of types.\n\n``{T}``                         ``Vector{Int}``                 \"Type Parameter\" :: A specialization of a type\n                                                                (typically used for dispatch or storage optimization).\n\n                                                                \"TypeVar\" :: The ``T`` in the type parameter declaration\n                                                                is referred to as a TypeVar (short for type variable).\n\n``bitstype``                    ``Int``,                        \"Bits Type\" :: A type with no fields, but a size. It\n                                ``Float64``                     is stored and defined by-value.\n\n``immutable``                   ``Pair{Int,Int}``               \"Immutable\" :: A type with all fields defined to be\n                                                                constant. It is defined by-value. And may be stored\n                                                                with a type-tag.\n\n                                ``Complex128`` (``isbits``)     \"Is-Bits\" :: A ``bitstype``, or an ``immutable`` type\n                                                                where all fields are other ``isbits`` types. It is\n                                                                defined by-value, and is stored without a type-tag.\n\n``type ...; end``               ``nothing``                     \"Singleton\" :: a Leaf Type or Immutable with no fields.\n\n``(...)`` or ``tuple(...)```    ``(1,2,3)``                     \"Tuple\" :: an immutable data-structure similar to an\n                                                                anonymous immutable type, or a constant array.\n                                                                Represented as either an array or a struct.\n\n``typealias``                   Not applicable here             Type aliases, and other similar mechanisms of\n                                                                doing type indirection, are resolved to their base\n                                                                type (this includes assigning a type to another name,\n                                                                or getting the type out of a function call).\n==============================  ==============================  ======================================================\n\nBits Types:\n~~~~~~~~~~~\n\nThere are several special types to be aware of, as no other type can be defined to behave the same:\n\n``Float32``\n    Exactly corresponds to the ``float`` type in C (or ``REAL*4`` in Fortran).\n\n``Float64``\n    Exactly corresponds to the ``double`` type in C (or ``REAL*8`` in Fortran).\n\n``Complex64``\n    Exactly corresponds to the ``complex float`` type in C (or ``COMPLEX*8`` in Fortran).\n\n``Complex128``\n    Exactly corresponds to the ``complex double`` type in C (or ``COMPLEX*16`` in Fortran).\n\n``Signed``\n    Exactly corresponds to the ``signed`` type annotation in C (or any ``INTEGER`` type in Fortran). Any Julia type that is not a subtype of ``Signed`` is assumed to be unsigned.\n\n``Ref{T}``\n    Behaves like a ``Ptr{T}`` that owns its memory.\n\n``Array{T,N}``\n    When an array is passed to C as a ``Ptr{T}`` argument, it is\n    not reinterpret-cast: Julia requires that the element type of the\n    array matches ``T``, and the address of the first element is passed.\n\n    Therefore, if an ``Array`` contains data in the wrong format, it will\n    have to be explicitly converted using a call such as ``trunc(Int32,a)``.\n\n    To pass an array ``A`` as a pointer of a different type *without*\n    converting the data beforehand (for example, to pass a ``Float64`` array\n    to a function that operates on uninterpreted bytes), you can\n    declare the argument as ``Ptr{Void}``.\n\n    If an array of eltype ``Ptr{T}`` is passed as a ``Ptr{Ptr{T}}`` argument,\n    :func:`Base.cconvert` will attempt to first make a null-terminated copy of the array with\n    each element replaced by its :func:`cconvert` version. This allows, for example, passing an ``argv``\n    pointer array of type ``Vector{String}`` to an argument of type ``Ptr{Ptr{Cchar}}``.\n\nOn all systems we currently support, basic C/C++ value types may be\ntranslated to Julia types as follows. Every C type also has a corresponding\nJulia type with the same name, prefixed by C. This can help for writing portable code (and remembering that an ``int`` in C is not the same as an ``Int`` in Julia).\n\n**System Independent:**\n\n.. rst-class:: text-wrap\n\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| C name                            | Fortran name    | Standard Julia Alias | Julia Base Type                   |\n+===================================+=================+======================+===================================+\n| ``unsigned char``                 | ``CHARACTER``   | ``Cuchar``           | ``UInt8``                         |\n|                                   |                 |                      |                                   |\n| ``bool`` (C++)                    |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``short``                         | ``INTEGER*2``   | ``Cshort``           | ``Int16``                         |\n|                                   |                 |                      |                                   |\n|                                   | ``LOGICAL*2``   |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``unsigned short``                |                 | ``Cushort``          | ``UInt16``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``int``                           | ``INTEGER*4``   | ``Cint``             | ``Int32``                         |\n|                                   |                 |                      |                                   |\n| ``BOOL`` (C, typical)             | ``LOGICAL*4``   |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``unsigned int``                  |                 | ``Cuint``            | ``UInt32``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``long long``                     | ``INTEGER*8``   | ``Clonglong``        | ``Int64``                         |\n|                                   |                 |                      |                                   |\n|                                   | ``LOGICAL*8``   |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``unsigned long long``            |                 | ``Culonglong``       | ``UInt64``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``intmax_t``                      |                 | ``Cintmax_t``        | ``Int64``                         |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``uintmax_t``                     |                 | ``Cuintmax_t``       | ``UInt64``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``float``                         | ``REAL*4i``     | ``Cfloat``           | ``Float32``                       |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``double``                        | ``REAL*8``      | ``Cdouble``          | ``Float64``                       |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``complex float``                 | ``COMPLEX*8``   | ``Complex64``        | ``Complex{Float32}``              |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``complex double``                | ``COMPLEX*16``  | ``Complex128``       | ``Complex{Float64}``              |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``ptrdiff_t``                     |                 | ``Cptrdiff_t``       | ``Int``                           |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``ssize_t``                       |                 | ``Cssize_t``         | ``Int``                           |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``size_t``                        |                 | ``Csize_t``          | ``UInt``                          |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``void``                          |                 |                      | ``Void``                          |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``void`` and                      |                 |                      | ``Union{}``                       |\n| ``[[noreturn]]`` or ``_Noreturn`` |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``void*``                         |                 |                      | ``Ptr{Void}``                     |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``T*`` (where T represents an     |                 |                      | ``Ref{T}``                        |\n| appropriately defined type)       |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``char*``                         | ``CHARACTER*N`` |                      | ``Cstring`` if NUL-terminated, or |\n| (or ``char[]``, e.g. a string)    |                 |                      | ``Ptr{UInt8}`` if not             |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``char**`` (or ``*char[]``)       |                 |                      | ``Ptr{Ptr{UInt8}}``               |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``jl_value_t*``                   |                 |                      | ``Any``                           |\n| (any Julia Type)                  |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``jl_value_t**``                  |                 |                      | ``Ref{Any}``                      |\n| (a reference to a Julia Type)     |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``va_arg``                        |                 |                      | Not supported                     |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``...``                           |                 |                      | ``T...`` (where ``T``             |\n| (variadic function specification) |                 |                      | is one of the above types,        |\n|                                   |                 |                      | variadic functions of different   |\n|                                   |                 |                      | argument types are not supported) |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n\nThe ``Cstring`` type is essentially a synonym for ``Ptr{UInt8}``, except the conversion to ``Cstring`` throws an\nerror if the Julia string contains any embedded NUL characters (which would cause the string to be silently\ntruncated if the C routine treats NUL as the terminator).  If you are passing a ``char*`` to a C routine that\ndoes not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that\nyour Julia string does not contain NUL and want to skip the check, you can use ``Ptr{UInt8}`` as the argument type.\n``Cstring`` can also be used as the :func:`ccall` return type, but in that case it obviously does not introduce any extra\nchecks and is only meant to improve readability of the call.\n\n**System-dependent:**\n\n======================  ======================  =======\nC name                  Standard Julia Alias    Julia Base Type\n======================  ======================  =======\n``char``                ``Cchar``               ``Int8`` (x86, x86_64)\n\n                                                ``UInt8`` (powerpc, arm)\n\n``long``                ``Clong``               ``Int`` (UNIX)\n\n                                                ``Int32`` (Windows)\n\n``unsigned long``       ``Culong``              ``UInt`` (UNIX)\n\n                                                ``UInt32`` (Windows)\n\n``wchar_t``             ``Cwchar_t``            ``Int32`` (UNIX)\n\n                                                ``UInt16`` (Windows)\n======================  ======================  =======\n\n.. note::\n\n    When calling a Fortran function, all inputs must be passed by reference, so\n    all type correspondences above should contain an additional ``Ptr{..}`` or\n    ``Ref{..}`` wrapper around their type specification.\n\n.. warning::\n\n    For string arguments (``char*``) the Julia type should be ``Cstring`` (if NUL-\n    terminated data is expected) or either ``Ptr{Cchar}`` or ``Ptr{UInt8}``\n    otherwise (these two pointer types have the same effect), as described above,\n    not ``String``. Similarly, for array arguments (``T[]`` or ``T*``), the\n    Julia type should again be ``Ptr{T}``, not ``Vector{T}``.\n\n.. warning::\n\n    Julia's ``Char`` type is 32 bits, which is not the same as the wide character\n    type (``wchar_t`` or ``wint_t``) on all platforms.\n\n.. warning::\n\n    A return type of ``Union{}`` means the function will not return\n    i.e. C++11 ``[[noreturn]]`` or C11 ``_Noreturn`` (e.g. ``jl_throw`` or\n    ``longjmp``). Do not use this for functions that return\n    no value (``void``) but do return.\n\n.. note::\n\n    For ``wchar_t*`` arguments, the Julia type should be ``Cwstring`` (if the C\n    routine expects a NUL-terminated string) or ``Ptr{Cwchar_t}`` otherwise. Note\n    also that UTF-8 string data in Julia is internally NUL-terminated, so it can\n    be passed to C functions expecting NUL-terminated data without making a copy\n    (but using the ``Cwstring`` type will cause an error to be thrown if the string\n    itself contains NUL characters).\n\n.. note::\n\n    C functions that take an argument of the type ``char**`` can be called by\n    using a ``Ptr{Ptr{UInt8}}`` type within Julia. For example, C functions of the\n    form::\n\n        int main(int argc, char **argv);\n\n    can be called via the following Julia code::\n\n        argv = [ \"a.out\", \"arg1\", \"arg2\" ]\n        ccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)\n\n.. note::\n\n    A C function declared to return ``Void`` will return the value ``nothing`` in\n    Julia.\n\nStruct Type correspondences\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nComposite types, aka ``struct`` in C or ``TYPE`` in Fortran90\n(or ``STRUCTURE`` / ``RECORD`` in some variants of F77),\ncan be mirrored in Julia by creating a ``type`` or ``immutable``\ndefinition with the same field layout.\n\nWhen used recursively, ``isbits`` types are stored inline.\nAll other types are stored as a pointer to the data.\nWhen mirroring a struct used by-value inside another struct in C,\nit is imperative that you do not attempt to manually copy the fields over,\nas this will not preserve the correct field alignment.\nInstead, declare an immutable ``isbits`` type and use that instead.\nUnnamed structs are not possible in the translation to Julia.\n\nPacked structs and union declarations are not supported by Julia.\n\nYou can get a near approximation of a ``union`` if you know, a priori,\nthe field that will have the greatest size (potentially including padding).\nWhen translating your fields to Julia, declare the Julia field to be only\nof that type.\n\nArrays of parameters must be expanded manually, currently\n(either inline, or in an immutable helper type). For example::\n\n    in C:\n    struct B {\n        int A[3];\n    };\n    b_a_2 = B.A[2];\n\n    in Julia:\n    immutable B_A\n        A_1::Cint\n        A_2::Cint\n        A_3::Cint\n    end\n    type B\n        A::B_A\n    end\n    b_a_2 = B.A.(2)\n\nArrays of unknown size are not supported.\n\nIn the future, some of these restrictions may be reduced or eliminated.\n\nSIMD Values\n~~~~~~~~~~~\n\nNote: This feature is currently implemented on 64-bit x86\nand AArch64 platforms only.\n\nIf a C/C++ routine has an argument or return value that is a native\nSIMD type, the corresponding Julia type is a homogeneous tuple\nof ``VecElement`` that naturally maps to the SIMD type.  Specifically:\n\n    - The tuple must be the same size as the SIMD type.\n      For example, a tuple representing an ``__m128`` on x86\n      must have a size of 16 bytes.\n\n    - The element type of the tuple must be an instance of ``VecElement{T}``\n      where ``T`` is a bitstype that is 1, 2, 4 or 8 bytes.\n\nFor instance, consider this C routine that uses AVX intrinsics::\n\n    #include <immintrin.h>\n\n    __m256 dist( __m256 a, __m256 b ) {\n        return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),\n                                            _mm256_mul_ps(b, b)));\n    }\n\nThe following Julia code calls ``dist`` using ``ccall``::\n\n    typealias m256 NTuple{8,VecElement{Float32}}\n\n    a = m256(ntuple(i->VecElement(sin(Float32(i))),8))\n    b = m256(ntuple(i->VecElement(cos(Float32(i))),8))\n\n    function call_dist(a::m256, b::m256)\n        ccall((:dist, \"libdist\"), m256, (m256, m256), a, b)\n    end\n\n    println(call_dist(a,b))\n\nThe host machine must have the requisite SIMD registers.  For example,\nthe code above will not work on hosts without AVX support.\n\nMemory Ownership\n~~~~~~~~~~~~~~~~\n\n**malloc/free**\n\nMemory allocation and deallocation of such objects must be\nhandled by calls to the appropriate cleanup routines in the libraries\nbeing used, just like in any C program. Do not try to free an object\nreceived from a C library with ``Libc.free`` in Julia, as this may result\nin the ``free`` function being called via the wrong ``libc`` library and\ncause Julia to crash. The reverse (passing an object allocated in Julia\nto be freed by an external library) is equally invalid.\n\nWhen to use T, Ptr{T} and Ref{T}\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn Julia code wrapping calls to external C routines, ordinary (non-pointer)\ndata should be declared to be of type ``T`` inside the :func:`ccall`, as they\nare passed by value.  For C code accepting pointers, ``Ref{T}`` should\ngenerally be used for the types of input arguments, allowing the use of\npointers to memory managed by either Julia or C through the implicit call to\n:func:`cconvert`.  In contrast, pointers returned by the C function called\nshould be declared to be of output type ``Ptr{T}``, reflecting that the memory\npointed to is managed by C only. Pointers contained in C structs should be\nrepresented as fields of type ``Ptr{T}`` within the corresponding Julia\nimmutable types designed to mimic the internal structure of corresponding C\nstructs.\n\nIn Julia code wrapping calls to external Fortran routines, all input arguments\nshould be declared as of type ``Ref{T}``, as Fortran passes all variables by\nreference. The return type should either be ``Void`` for Fortran subroutines,\nor a ``T`` for Fortran functions returning the type ``T``.\n\n\nMapping C Functions to Julia\n----------------------------\n\n``ccall``/``cfunction`` argument translation guide\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor translating a C argument list to Julia:\n\n* ``T``, where ``T`` is one of the primitive types:\n  ``char``, ``int``, ``long``, ``short``, ``float``, ``double``, ``complex``, ``enum``\n  or any of their ``typedef`` equivalents\n\n  + ``T``, where ``T`` is an equivalent Julia Bits Type (per the table above)\n  + if ``T`` is an ``enum``, the argument type should be equivalent to ``Cint`` or ``Cuint``\n  + argument value will be copied (passed by value)\n\n* ``struct T`` (including typedef to a struct)\n\n  + ``T``, where ``T`` is a Julia leaf type\n  + argument value will be copied (passed by value)\n\n* ``void*``\n\n  + depends on how this parameter is used, first translate this to the intended pointer type,\n    then determine the Julia equivalent using the remaining rules in this list\n  + this argument may be declared as ``Ptr{Void}``, if it really is just an unknown pointer\n\n* ``jl_value_t*``\n\n  + ``Any``\n  + argument value must be a valid Julia object\n  + currently unsupported by :func:`cfunction`\n\n* ``jl_value_t**``\n\n  + ``Ref{Any}``\n  + argument value must be a valid Julia object (or ``C_NULL``)\n  + currently unsupported by :func:`cfunction`\n\n* ``T*``\n\n  + ``Ref{T}``, where ``T`` is the Julia type corresponding to ``T``\n  + argument value will be copied if it is an ``isbits`` type\n    otherwise, the value must be a valid Julia object\n\n* ``(T*)(...)`` (e.g. a pointer to a function)\n\n  + ``Ptr{Void}`` (you may need to use :func:`cfunction` explicitly to create this pointer)\n\n* ``...`` (e.g. a vararg)\n\n  + ``T...``, where ``T`` is the Julia type\n\n* ``va_arg``\n\n  + not supported\n\n``ccall``/``cfunction`` return type translation guide\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor translating a C return type to Julia:\n\n* ``void``\n\n  + ``Void`` (this will return the singleton instance ``nothing::Void``)\n\n* ``T``, where ``T`` is one of the primitive types:\n  ``char``, ``int``, ``long``, ``short``, ``float``, ``double``, ``complex``, ``enum``\n  or any of their ``typedef`` equivalents\n\n  + ``T``, where ``T`` is an equivalent Julia Bits Type (per the table above)\n  + if ``T`` is an ``enum``, the argument type should be equivalent to ``Cint`` or ``Cuint``\n  + argument value will be copied (returned by-value)\n\n* ``struct T`` (including typedef to a struct)\n\n  + ``T``, where ``T`` is a Julia Leaf Type\n  + argument value will be copied (returned by-value)\n\n* ``void*``\n\n  + depends on how this parameter is used, first translate this to the intended pointer type,\n    then determine the Julia equivalent using the remaining rules in this list\n  + this argument may be declared as ``Ptr{Void}``, if it really is just an unknown pointer\n\n* ``jl_value_t*``\n\n  + ``Any``\n  + argument value must be a valid Julia object\n\n* ``jl_value_t**``\n\n  + ``Ref{Any}``\n  + argument value must be a valid Julia object (or ``C_NULL``)\n\n* ``T*``\n\n  + If the memory is already owned by Julia, or is an ``isbits`` type, and is known to be non-null:\n\n    + ``Ref{T}``, where ``T`` is the Julia type corresponding to ``T``\n    + a return type of ``Ref{Any}`` is invalid, it should either be ``Any``\n      (corresponding to ``jl_value_t*``) or ``Ptr{Any}`` (corresponding to ``Ptr{Any}``)\n    + C **MUST NOT** modify the memory returned via ``Ref{T}`` if ``T`` is an ``isbits`` type\n\n  + If the memory is owned by C:\n\n    + ``Ptr{T}``, where ``T`` is the Julia type corresponding to ``T``\n\n* ``(T*)(...)`` (e.g. a pointer to a function)\n\n  + ``Ptr{Void}`` (you may need to use :func:`cfunction` explicitly to create this pointer)\n\nPassing Pointers for Modifying Inputs\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBecause C doesn't support multiple return values,\noften C functions will take pointers to data that the function will modify.\nTo accomplish this within a :func:`ccall`,\nyou need to first encapsulate the value inside an ``Ref{T}`` of the appropriate type.\nWhen you pass this ``Ref`` object as an argument,\nJulia will automatically pass a C pointer to the encapsulated data::\n\n    width = Ref{Cint}(0)\n    range = Ref{Cfloat}(0)\n    ccall(:foo, Void, (Ref{Cint}, Ref{Cfloat}), width, range)\n\nUpon return, the contents of ``width`` and ``range`` can be retrieved\n(if they were changed by ``foo``) by ``width[]`` and ``range[]``; that is,\nthey act like zero-dimensional arrays.\n\nSpecial Reference Syntax for ccall (deprecated):\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``&`` syntax is deprecated, use the ``Ref{T}`` argument type instead.\n\nA prefix ``&`` is used on an argument to :func:`ccall` to indicate that a pointer\nto a scalar argument should be passed instead of the scalar value itself\n(required for all Fortran function arguments, as noted above). The following\nexample computes a dot product using a BLAS function.\n\n::\n\n    function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})\n      assert(length(DX) == length(DY))\n      n = length(DX)\n      incx = incy = 1\n      product = ccall((:ddot_, \"libLAPACK\"),\n                      Float64,\n                      (Ptr{Int32}, Ptr{Float64}, Ptr{Int32}, Ptr{Float64}, Ptr{Int32}),\n                      &n, DX, &incx, DY, &incy)\n      return product\n    end\n\nThe meaning of prefix ``&`` is not quite the same as in C. In\nparticular, any changes to the referenced variables will not be\nvisible in Julia unless the type is mutable (declared via\n``type``). However, even for immutable types it will not cause any\nharm for called functions to attempt such modifications (that is,\nwriting through the passed pointers). Moreover, ``&`` may be used with\nany expression, such as ``&0`` or ``&f(x)``.\n\nWhen a scalar value is passed with ``&`` as an argument of type\n``Ptr{T}``, the value will first be converted to type ``T``.\n\nSome Examples of C Wrappers\n---------------------------\n\nHere is a simple example of a C wrapper that returns a ``Ptr`` type::\n\n    type gsl_permutation\n    end\n\n    # The corresponding C signature is\n    #     gsl_permutation * gsl_permutation_alloc (size_t n);\n    function permutation_alloc(n::Integer)\n        output_ptr = ccall(\n            (:gsl_permutation_alloc, :libgsl), #name of C function and library\n            Ptr{gsl_permutation},              #output type\n            (Csize_t,),                        #tuple of input types\n            n                                  #name of Julia variable to pass in\n        )\n        if output_ptr==C_NULL # Could not allocate memory\n            throw(OutOfMemoryError())\n        end\n        return output_ptr\n    end\n\nThe `GNU Scientific Library <https://www.gnu.org/software/gsl/>`_ (here assumed\nto be accessible through ``:libgsl``) defines an opaque pointer,\n``gsl_permutation *``, as the return type of the C function\n``gsl_permutation_alloc()``. As user code never has to look inside the\n``gsl_permutation`` struct, the corresponding Julia wrapper simply needs a new\ntype declaration, ``gsl_permutation``, that has no internal fields and whose\nsole purpose is to be placed in the type parameter of a ``Ptr`` type.  The\nreturn type of the :func:`ccall` is declared as ``Ptr{gsl_permutation}``, since the\nmemory allocated and pointed to by ``output_ptr`` is controlled by C (and not\nJulia).\n\nThe input ``n`` is passed by value, and so the function's input signature is\nsimply declared as ``(Csize_t,)`` without any ``Ref`` or ``Ptr`` necessary.\n(If the wrapper was calling a Fortran function instead, the corresponding\nfunction input signature should instead be ``(Ref{Csize_t},)``, since Fortran\nvariables are passed by reference.) Furthermore, ``n`` can be any type that is\nconvertable to a ``Csize_t`` integer; the :func:`ccall` implicitly calls\n:func:`Base.cconvert(Csize_t, n) <cconvert>`.\n\n\nHere is a second example wrapping the corresponding destructor::\n\n    # The corresponding C signature is\n    #     void gsl_permutation_free (gsl_permutation * p);\n    function permutation_free(p::Ref{gsl_permutation})\n        ccall(\n            (:gsl_permutation_free, :libgsl), #name of C function and library\n            Void,                             #output type\n            (Ref{gsl_permutation},),          #tuple of input types\n            p                                 #name of Julia variable to pass in\n        )\n    end\n\nHere, the input ``p`` is declared to be of type ``Ref{gsl_permutation}``,\nmeaning that the memory that ``p`` points to may be managed by Julia or by C.\nA pointer to memory allocated by C should be of type ``Ptr{gsl_permutation}``,\nbut it is convertable using :func:`cconvert` and therefore can be used in the\nsame (covariant) context of the input argument to a :func:`ccall`. A pointer to\nmemory allocated by Julia must be of type ``Ref{gsl_permutation}``, to ensure\nthat the memory address pointed to is valid and that Julia's garbage collector\nmanages the chunk of memory pointed to correctly. Therefore, the\n``Ref{gsl_permutation}`` declaration allows pointers managed by C or Julia to\nbe used.\n\nIf the C wrapper never expects the user to pass pointers to memory managed by\nJulia, then using ``p::Ptr{gsl_permutation}`` for the method signature of the\nwrapper and similarly in the :func:`ccall` is also acceptable.\n\n\nHere is a third example passing Julia arrays::\n\n    # The corresponding C signature is\n    #    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,\n    #                                double result_array[])\n    function sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)\n        if nmax<nmin throw(DomainError()) end\n        result_array = Array{Cdouble}(nmax-nmin+1)\n        errorcode = ccall(\n            (:gsl_sf_bessel_Jn_array, :libgsl), #name of C function and library\n            Cint,                               #output type\n            (Cint, Cint, Cdouble, Ref{Cdouble}),#tuple of input types\n            nmin, nmax, x, result_array         #names of Julia variables to pass in\n        )\n        if errorcode!= 0 error(\"GSL error code $errorcode\") end\n        return result_array\n    end\n\nThe C function wrapped returns an integer error code; the results of the actual\nevaluation of the Bessel J function populate the Julia array ``result_array``.\nThis variable can only be used with corresponding input type declaration\n``Ref{Cdouble}``, since its memory is allocated and managed by\nJulia, not C. The implicit call to :func:`Base.cconvert(Ref{Cdouble},\nresult_array) <cconvert>` unpacks the Julia pointer to a Julia array data\nstructure into a form understandable by C.\n\nNote that for this code to work correctly, ``result_array`` must be declared to\nbe of type ``Ref{Cdouble}`` and not ``Ptr{Cdouble}``. The memory is managed by\nJulia and the ``Ref`` signature alerts Julia's garbage collector to keep\nmanaging the memory for ``result_array`` while the :func:`ccall` executes. If\n``Ptr{Cdouble}`` were used instead, the :func:`ccall` may still work, but\nJulia's garbage collector would not be aware that the memory declared for\n``result_array`` is being used by the external C function. As a result, the\ncode may produce a memory leak if ``result_array`` never gets freed by the\ngarbage collector, or if the garbage collector prematurely frees\n``result_array``, the C function may end up throwing an invalid memory access\nexception.\n\n\n\nGarbage Collection Safety\n-------------------------\nWhen passing data to a :func:`ccall`, it is best to avoid using the :func:`pointer`\nfunction. Instead define a convert method and pass the variables directly to\nthe :func:`ccall`. :func:`ccall` automatically arranges that all of its arguments will be\npreserved from garbage collection until the call returns. If a C API will\nstore a reference to memory allocated by Julia, after the :func:`ccall` returns, you\nmust arrange that the object remains visible to the garbage collector. The\nsuggested way to handle this is to make a global variable of type\n``Array{Ref,1}`` to hold these values, until the C library notifies you that\nit is finished with them.\n\nWhenever you have created a pointer to Julia data, you must ensure the original data\nexists until you are done with using the pointer. Many methods in Julia such as\n:func:`unsafe_load` and :func:`String` make copies of data instead of taking ownership\nof the buffer, so that it is safe to free (or alter) the original data without\naffecting Julia. A notable exception is :func:`unsafe_wrap` which, for performance\nreasons, shares (or can be told to take ownership of) the underlying buffer.\n\nThe garbage collector does not guarantee any order of finalization. That is, if ``a``\ncontained a reference to ``b`` and both ``a`` and ``b`` are due for garbage\ncollection, there is no guarantee that ``b`` would be finalized after ``a``. If\nproper finalization of ``a`` depends on ``b`` being valid, it must be handled in\nother ways.\n\n\nNon-constant Function Specifications\n------------------------------------\n\nA ``(name, library)`` function specification must be a constant expression.\nHowever, it is possible to use computed values as function names by staging\nthrough ``eval`` as follows::\n\n    @eval ccall(($(string(\"a\",\"b\")),\"lib\"), ...\n\nThis expression constructs a name using ``string``, then substitutes this\nname into a new :func:`ccall` expression, which is then evaluated. Keep in mind that\n``eval`` only operates at the top level, so within this expression local\nvariables will not be available (unless their values are substituted with\n``$``). For this reason, ``eval`` is typically only used to form top-level\ndefinitions, for example when wrapping libraries that contain many\nsimilar functions.\n\nIf your usage is more dynamic, use indirect calls as described in the next section.\n\n\nIndirect Calls\n--------------\n\nThe first argument to :func:`ccall` can also be an expression evaluated at run time.\nIn this case, the expression must evaluate to a ``Ptr``,\nwhich will be used as the address of the native function to call.\nThis behavior occurs when the first :func:`ccall` argument contains references to non-constants,\nsuch as local variables, function arguments, or non-constant globals.\n\nFor example, you might lookup the function via ``dlsym``,\nthen cache it in a global variable for that session. For example::\n\n    macro dlsym(func, lib)\n        z, zlocal = gensym(string(func)), gensym()\n        eval(current_module(),:(global $z = C_NULL))\n        z = esc(z)\n        quote\n            let $zlocal::Ptr{Void} = $z::Ptr{Void}\n                if $zlocal == C_NULL\n                   $zlocal = dlsym($(esc(lib))::Ptr{Void}, $(esc(func)))\n                   global $z = $zlocal\n                end\n                $zlocal\n            end\n        end\n    end\n\n    mylibvar = dlopen(\"mylib\")\n    ccall(@dlsym(\"myfunc\", mylibvar), Void, ())\n\n\nCalling Convention\n------------------\n\nThe second argument to :func:`ccall` can optionally be a calling convention\nspecifier (immediately preceding return type). Without any specifier,\nthe platform-default C calling convention is used. Other supported\nconventions are: ``stdcall``, ``cdecl``, ``fastcall``, and ``thiscall``.\nFor example (from ``base/libc.jl``) we see the same ``gethostname`` :func:`ccall` as above,\nbut with the correct signature for Windows::\n\n    hn = Array{UInt8}(256)\n    err = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))\n\nFor more information, please see the `LLVM Language Reference`_.\n\n.. _LLVM Language Reference: http://llvm.org/docs/LangRef.html#calling-conventions\n\n\nAccessing Global Variables\n--------------------------\n\nGlobal variables exported by native libraries can be accessed by name using the\n:func:`cglobal` function. The arguments to :func:`cglobal` are a symbol specification\nidentical to that used by :func:`ccall`, and a type describing the value stored in\nthe variable::\n\n    julia> cglobal((:errno,:libc), Int32)\n    Ptr{Int32} @0x00007f418d0816b8\n\nThe result is a pointer giving the address of the value. The value can be\nmanipulated through this pointer using :func:`unsafe_load` and :func:`unsafe_store!`.\n\n\nAccessing Data through a Pointer\n--------------------------------\nThe following methods are described as \"unsafe\" because a bad pointer\nor type declaration can cause Julia to terminate abruptly.\n\nGiven a ``Ptr{T}``, the contents of type ``T`` can generally be copied from\nthe referenced memory into a Julia object using ``unsafe_load(ptr, [index])``.\nThe index argument is optional (default is 1),\nand follows the Julia-convention of 1-based indexing.\nThis function is intentionally similar to the behavior of :func:`getindex` and :func:`setindex!`\n(e.g. ``[]`` access syntax).\n\nThe return value will be a new object initialized\nto contain a copy of the contents of the referenced memory.\nThe referenced memory can safely be freed or released.\n\nIf ``T`` is ``Any``, then the memory is assumed to contain a reference to\na Julia object (a ``jl_value_t*``), the result will be a reference to this object,\nand the object will not be copied. You must be careful in this case to ensure\nthat the object was always visible to the garbage collector (pointers do not\ncount, but the new reference does) to ensure the memory is not prematurely freed.\nNote that if the object was not originally allocated by Julia, the new object\nwill never be finalized by Julia's garbage collector.  If the ``Ptr`` itself\nis actually a ``jl_value_t*``, it can be converted back to a Julia object\nreference by :func:`unsafe_pointer_to_objref(ptr) <unsafe_pointer_to_objref>`.\n(Julia values ``v`` can be converted to ``jl_value_t*`` pointers, as\n``Ptr{Void}``, by calling :func:`pointer_from_objref(v)\n<pointer_from_objref>`.)\n\nThe reverse operation (writing data to a ``Ptr{T}``), can be performed using\n:func:`unsafe_store!(ptr, value, [index]) <unsafe_store!>`.  Currently, this is only supported\nfor bitstypes or other pointer-free (``isbits``) immutable types.\n\nAny operation that throws an error is probably currently unimplemented\nand should be posted as a bug so that it can be resolved.\n\nIf the pointer of interest is a plain-data array (bitstype or immutable), the\nfunction :func:`unsafe_wrap(Array, ptr,dims,[own]) <unsafe_wrap>` may be\nmore useful. The final parameter should be true if Julia should \"take\nownership\" of the underlying buffer and call ``free(ptr)`` when the returned\n``Array`` object is finalized.  If the ``own`` parameter is omitted or false,\nthe caller must ensure the buffer remains in existence until all access is\ncomplete.\n\nArithmetic on the ``Ptr`` type in Julia (e.g. using ``+``) does not behave the\nsame as C's pointer arithmetic. Adding an integer to a ``Ptr`` in Julia always\nmoves the pointer by some number of *bytes*, not elements. This way, the\naddress values obtained from pointer arithmetic do not depend on the\nelement types of pointers.\n\n\nThread-safety\n-------------\n\nSome C libraries execute their callbacks from a different thread, and\nsince Julia isn't thread-safe you'll need to take some extra\nprecautions. In particular, you'll need to set up a two-layered\nsystem: the C callback should only *schedule* (via Julia's event loop)\nthe execution of your \"real\" callback.\nTo do this, create a ``AsyncCondition`` object and wait on it::\n\n  cond = Base.AsyncCondition()\n  wait(cond)\n\nThe callback you pass to C should only execute a :func:`ccall` to\n``:uv_async_send``, passing ``cb.handle`` as the argument,\ntaking care to avoid any allocations or other interactions with the Julia runtime.\n\nNote that events may be coalesced, so multiple calls to uv_async_send\nmay result in a single wakeup notification to the condition.\n\nMore About Callbacks\n--------------------\n\nFor more details on how to pass callbacks to C libraries, see this\n`blog post <http://julialang.org/blog/2013/05/callback>`_.\n\nC++\n---\n\nLimited support for C++ is provided by the `Cpp <https://github.com/timholy/Cpp.jl>`_,\n`Clang <https://github.com/ihnorton/Clang.jl>`_, and `Cxx <https://github.com/Keno/Cxx.jl>`_ packages.\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/stdlib/libdl.html": "\n\n<!DOCTYPE html>\n<!--[if IE 8]><html class=\"no-js lt-ie9\" lang=\"en\" > <![endif]-->\n<!--[if gt IE 8]><!--> <html class=\"no-js\" lang=\"en\" > <!--<![endif]-->\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  \n  <title>Dynamic Linker &mdash; Julia Language 0.5.1 documentation</title>\n  \n\n  \n  \n\n  \n  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>\n\n  \n  \n    \n\n  \n\n  \n  \n    <link rel=\"stylesheet\" href=\"../_static/julia.css\" type=\"text/css\" />\n  \n\n  \n    <link rel=\"stylesheet\" href=\"../_static/julia.css\" type=\"text/css\" />\n  \n    <link rel=\"top\" title=\"Julia Language 0.5.1 documentation\" href=\"../index.html\"/>\n        <link rel=\"next\" title=\"Profiling\" href=\"profile.html\"/>\n        <link rel=\"prev\" title=\"C Standard Library\" href=\"libc.html\"/> \n\n  \n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js\"></script>\n\n</head>\n\n<body class=\"wy-body-for-nav\" role=\"document\">\n\n  <div class=\"wy-grid-for-nav\">\n\n    \n    <nav data-toggle=\"wy-nav-shift\" class=\"wy-nav-side\">\n      <div class=\"wy-side-nav-search\">\n        <a href=\"http://julialang.org/\"><img src=\"../_static/julia-logo.svg\" class=\"logo\"></a>\n        <!--\n        <a href=\"../index.html\" class=\"fa fa-home\"> Julia Language</a>\n        -->\n        <div role=\"search\">\n  <form id =\"rtd-search-form\" class=\"wy-form\" action=\"../search.html\" method=\"get\">\n    <input type=\"text\" name=\"q\" placeholder=\"Search docs\" />\n    <input type=\"hidden\" name=\"check_keywords\" value=\"yes\" />\n    <input type=\"hidden\" name=\"area\" value=\"default\" />\n  </form>\n</div>\n      </div>\n\n      <div class=\"wy-menu wy-menu-vertical\" data-spy=\"affix\" role=\"navigation\" aria-label=\"main navigation\">\n        \n        \n            <ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/introduction.html\">Introduction</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/getting-started.html\">Getting Started</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/getting-started.html#resources\">Resources</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/variables.html\">Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables.html#allowed-variable-names\">Allowed Variable Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables.html#stylistic-conventions\">Stylistic Conventions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html\">Integers and Floating-Point Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#integers\">Integers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#floating-point-numbers\">Floating-Point Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#arbitrary-precision-arithmetic\">Arbitrary Precision Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#numeric-literal-coefficients\">Numeric Literal Coefficients</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#literal-zero-and-one\">Literal zero and one</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html\">Mathematical Operations and Elementary Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#arithmetic-operators\">Arithmetic Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#bitwise-operators\">Bitwise Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#updating-operators\">Updating operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#numeric-comparisons\">Numeric Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#numerical-conversions\">Numerical Conversions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/complex-and-rational-numbers.html\">Complex and Rational Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/complex-and-rational-numbers.html#complex-numbers\">Complex Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/complex-and-rational-numbers.html#rational-numbers\">Rational Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/strings.html\">Strings</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#characters\">Characters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#string-basics\">String Basics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#unicode-and-utf-8\">Unicode and UTF-8</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#triple-quoted-string-literals\">Triple-Quoted String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#common-operations\">Common Operations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#regular-expressions\">Regular Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#id2\">Byte Array Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#version-number-literals\">Version Number Literals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/functions.html\">Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#argument-passing-behavior\">Argument Passing Behavior</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#the-return-keyword\">The <code class=\"docutils literal\"><span class=\"pre\">return</span></code> Keyword</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#operators-are-functions\">Operators Are Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#operators-with-special-names\">Operators With Special Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#anonymous-functions\">Anonymous Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#multiple-return-values\">Multiple Return Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#varargs-functions\">Varargs Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#optional-arguments\">Optional Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#keyword-arguments\">Keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#evaluation-scope-of-default-values\">Evaluation Scope of Default Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#do-block-syntax-for-function-arguments\">Do-Block Syntax for Function Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#dot-syntax-for-vectorizing-functions\">Dot Syntax for Vectorizing Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#further-reading\">Further Reading</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/control-flow.html\">Control Flow</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#compound-expressions\">Compound Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#conditional-evaluation\">Conditional Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#short-circuit-evaluation\">Short-Circuit Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#repeated-evaluation-loops\">Repeated Evaluation: Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#exception-handling\">Exception Handling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#tasks-aka-coroutines\">Tasks (aka Coroutines)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html\">Scope of Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html#global-scope\">Global Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html#local-scope\">Local Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html#constants\">Constants</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/types.html\">Types</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#type-declarations\">Type Declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#abstract-types\">Abstract Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#bits-types\">Bits Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#composite-types\">Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#immutable-composite-types\">Immutable Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#declared-types\">Declared Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#type-unions\">Type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#man-parametric-types\">Parametric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#type-aliases\">Type Aliases</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#operations-on-types\">Operations on Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#custom-pretty-printing\">Custom pretty-printing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#value-types\">&#8220;Value types&#8221;</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#nullable-types-representing-missing-values\">Nullable Types: Representing Missing Values</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/methods.html\">Methods</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#defining-methods\">Defining Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#method-ambiguities\">Method Ambiguities</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#parametric-methods\">Parametric Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#parametrically-constrained-varargs-methods\">Parametrically-constrained Varargs methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#note-on-optional-and-keyword-arguments\">Note on Optional and keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#function-like-objects\">Function-like objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#empty-generic-functions\">Empty generic functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/constructors.html\">Constructors</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#outer-constructor-methods\">Outer Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#inner-constructor-methods\">Inner Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#incomplete-initialization\">Incomplete Initialization</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#parametric-constructors\">Parametric Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#case-study-rational\">Case Study: Rational</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#constructors-and-conversion\">Constructors and Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#outer-only-constructors\">Outer-only constructors</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/conversion-and-promotion.html\">Conversion and Promotion</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/conversion-and-promotion.html#conversion\">Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/conversion-and-promotion.html#promotion\">Promotion</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/interfaces.html\">Interfaces</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interfaces.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interfaces.html#indexing\">Indexing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interfaces.html#abstract-arrays\">Abstract Arrays</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/modules.html\">Modules</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/modules.html#summary-of-module-usage\">Summary of module usage</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/documentation.html\">Documentation</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#accessing-documentation\">Accessing Documentation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#functions-methods\">Functions &amp; Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#advanced-usage\">Advanced Usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#syntax-guide\">Syntax Guide</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#markdown-syntax\">Markdown syntax</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#markdown-syntax-extensions\">Markdown Syntax Extensions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html\">Metaprogramming</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#program-representation\">Program representation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#expressions-and-evaluation\">Expressions and evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#macros\">Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#code-generation\">Code Generation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#generated-functions\">Generated functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/arrays.html\">Multi-dimensional Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/arrays.html#arrays\">Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/arrays.html#sparse-matrices\">Sparse Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/linear-algebra.html\">Linear algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/linear-algebra.html#matrix-factorizations\">Matrix factorizations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/linear-algebra.html#special-matrices\">Special matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html\">Networking and Streams</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#basic-stream-i-o\">Basic Stream I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#io-output-contextual-properties\">IO Output Contextual Properties</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#working-with-files\">Working with Files</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#a-simple-tcp-example\">A simple TCP example</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#resolving-ip-addresses\">Resolving IP Addresses</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html\">Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#code-availability-and-loading-packages\">Code Availability and Loading Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#data-movement\">Data Movement</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#parallel-map-and-loops\">Parallel Map and Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#synchronization-with-remote-references\">Synchronization With Remote References</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#scheduling\">Scheduling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#channels\">Channels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#remote-references-and-abstractchannels\">Remote references and AbstractChannels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#remote-references-and-distributed-garbage-collection\">Remote References and Distributed Garbage Collection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#id2\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#shared-arrays-and-distributed-garbage-collection\">Shared Arrays and Distributed Garbage Collection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#clustermanagers\">ClusterManagers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#cluster-managers-with-custom-transports\">Cluster Managers with custom transports</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#network-requirements-for-localmanager-and-sshmanager\">Network requirements for LocalManager and SSHManager</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#cluster-cookie\">Cluster cookie</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#specifying-network-topology-experimental\">Specifying network topology (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#multi-threading-experimental\">Multi-threading (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#threadcall-experimental\">&#64;threadcall (Experimental)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/dates.html\">Date and DateTime</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#durations-comparisons\">Durations/Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#accessor-functions\">Accessor Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#query-functions\">Query Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#timetype-period-arithmetic\">TimeType-Period Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#adjuster-functions\">Adjuster Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#period-types\">Period Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#rounding\">Rounding</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html\">Running External Programs</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html#quoting\">Quoting</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html#pipelines\">Pipelines</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html\">Calling C and Fortran Code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#creating-c-compatible-julia-function-pointers\">Creating C-Compatible Julia Function Pointers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#mapping-c-types-to-julia\">Mapping C Types to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#mapping-c-functions-to-julia\">Mapping C Functions to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#some-examples-of-c-wrappers\">Some Examples of C Wrappers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#garbage-collection-safety\">Garbage Collection Safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#non-constant-function-specifications\">Non-constant Function Specifications</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#indirect-calls\">Indirect Calls</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#calling-convention\">Calling Convention</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#accessing-global-variables\">Accessing Global Variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#accessing-data-through-a-pointer\">Accessing Data through a Pointer</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#thread-safety\">Thread-safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#more-about-callbacks\">More About Callbacks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#c\">C++</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/handling-operating-system-variation.html\">Handling Operating System Variation</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html\">Interacting With Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html#the-different-prompt-modes\">The different prompt modes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html#key-bindings\">Key bindings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html#tab-completion\">Tab completion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html#customizing-colors\">Customizing Colors</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/embedding.html\">Embedding Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#high-level-embedding\">High-Level Embedding</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#converting-types\">Converting Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#calling-julia-functions\">Calling Julia Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#memory-management\">Memory Management</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#working-with-arrays\">Working with Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#exceptions\">Exceptions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/packages.html\">Packages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#package-status\">Package Status</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#adding-and-removing-packages\">Adding and Removing Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#offline-installation-of-packages\">Offline Installation of Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#installing-unregistered-packages\">Installing Unregistered Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#updating-packages\">Updating Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#checkout-pin-and-free\">Checkout, Pin and Free</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#custom-metadata-repository\">Custom METADATA Repository</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/packages.html#package-development\">Package Development</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#initial-setup\">Initial Setup</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#making-changes-to-an-existing-package\">Making changes to an existing package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#creating-a-new-package\">Creating a new Package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#fixing-package-requirements\">Fixing Package Requirements</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#man-package-requirements\">Requirements Specification</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/profile.html\">Profiling</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#basic-usage\">Basic usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#accumulation-and-clearing\">Accumulation and clearing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#options-for-controlling-the-display-of-profile-results\">Options for controlling the display of profile results</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#configuration\">Configuration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/profile.html#memory-allocation-analysis\">Memory allocation analysis</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/stacktraces.html\">Stack Traces</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/stacktraces.html#viewing-a-stack-trace\">Viewing a stack trace</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/stacktraces.html#extracting-useful-information\">Extracting useful information</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/stacktraces.html#error-handling\">Error handling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/stacktraces.html#comparison-with-backtrace\">Comparison with <code class=\"docutils literal\"><span class=\"pre\">backtrace()</span></code></a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/performance-tips.html\">Performance Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-global-variables\">Avoid global variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#measure-performance-with-time-and-pay-attention-to-memory-allocation\">Measure performance with <code class=\"docutils literal\"><span class=\"pre\">&#64;time</span></code> and pay attention to memory allocation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#tools\">Tools</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-containers-with-abstract-type-parameters\">Avoid containers with abstract type parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#type-declarations\">Type declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#break-functions-into-multiple-definitions\">Break functions into multiple definitions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#write-type-stable-functions\">Write &#8220;type-stable&#8221; functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-changing-the-type-of-a-variable\">Avoid changing the type of a variable</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#separate-kernel-functions-aka-function-barriers\">Separate kernel functions (aka, function barriers)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#types-with-values-as-parameters\">Types with values-as-parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#the-dangers-of-abusing-multiple-dispatch-aka-more-on-types-with-values-as-parameters\">The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#access-arrays-in-memory-order-along-columns\">Access arrays in memory order, along columns</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#pre-allocating-outputs\">Pre-allocating outputs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-string-interpolation-for-i-o\">Avoid string interpolation for I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#optimize-network-i-o-during-parallel-execution\">Optimize network I/O during parallel execution</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#fix-deprecation-warnings\">Fix deprecation warnings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#tweaks\">Tweaks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#performance-annotations\">Performance Annotations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#treat-subnormal-numbers-as-zeros\">Treat Subnormal Numbers as Zeros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#code-warntype\"><code class=\"docutils literal\"><span class=\"pre\">&#64;code_warntype</span></code></a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/workflow-tips.html\">Workflow Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/workflow-tips.html#repl-based-workflow\">REPL-based workflow</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/workflow-tips.html#browser-based-workflow\">Browser-based workflow</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/style-guide.html\">Style Guide</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#write-functions-not-just-scripts\">Write functions, not just scripts</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-writing-overly-specific-types\">Avoid writing overly-specific types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#handle-excess-argument-diversity-in-the-caller\">Handle excess argument diversity in the caller</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#append-to-names-of-functions-that-modify-their-arguments\">Append <code class=\"docutils literal\"><span class=\"pre\">!</span></code> to names of functions that modify their arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-strange-type-unions\">Avoid strange type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-type-unions-in-fields\">Avoid type Unions in fields</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-elaborate-container-types\">Avoid elaborate container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#use-naming-conventions-consistent-with-julia-s-base\">Use naming conventions consistent with Julia&#8217;s <code class=\"docutils literal\"><span class=\"pre\">base/</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overuse-try-catch\">Don&#8217;t overuse try-catch</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-parenthesize-conditions\">Don&#8217;t parenthesize conditions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overuse\">Don&#8217;t overuse ...</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-use-unnecessary-static-parameters\">Don&#8217;t use unnecessary static parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-confusion-about-whether-something-is-an-instance-or-a-type\">Avoid confusion about whether something is an instance or a type</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overuse-macros\">Don&#8217;t overuse macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-expose-unsafe-operations-at-the-interface-level\">Don&#8217;t expose unsafe operations at the interface level</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overload-methods-of-base-container-types\">Don&#8217;t overload methods of base container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#be-careful-with-type-equality\">Be careful with type equality</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#do-not-write-x-f-x\">Do not write <code class=\"docutils literal\"><span class=\"pre\">x-&gt;f(x)</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible\">Avoid using floats for numeric literals in generic code when possible</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/faq.html\">Frequently Asked Questions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#sessions-and-the-repl\">Sessions and the REPL</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#functions\">Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#types-type-declarations-and-constructors\">Types, type declarations, and constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#packages-and-modules\">Packages and Modules</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#nothingness-and-missing-values\">Nothingness and missing values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#memory\">Memory</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#asynchronous-io-and-concurrent-synchronous-writes\">Asynchronous IO and concurrent synchronous writes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#julia-releases\">Julia Releases</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html\">Noteworthy Differences from other Languages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-matlab\">Noteworthy differences from MATLAB</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-r\">Noteworthy differences from R</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-python\">Noteworthy differences from Python</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-c-c\">Noteworthy differences from C/C++</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/unicode-input.html\">Unicode Input</a></li>\n</ul>\n<ul class=\"current\">\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"base.html\">Essentials</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#introduction\">Introduction</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#getting-around\">Getting Around</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#all-objects\">All Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#types\">Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#generic-functions\">Generic Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#syntax\">Syntax</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#nullables\">Nullables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#system\">System</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#errors\">Errors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#events\">Events</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#reflection\">Reflection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#internals\">Internals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"collections.html\">Collections and Data Structures</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#general-collections\">General Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#iterable-collections\">Iterable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#indexable-collections\">Indexable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#associative-collections\">Associative Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#set-like-collections\">Set-Like Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#dequeues\">Dequeues</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#priorityqueue\">PriorityQueue</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#heap-functions\">Heap Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"math.html\">Mathematics</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#mathematical-operators\">Mathematical Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#mathematical-functions\">Mathematical Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#statistics\">Statistics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#signal-processing\">Signal Processing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#numerical-integration\">Numerical Integration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"numbers.html\">Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#standard-numeric-types\">Standard Numeric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#data-formats\">Data Formats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#general-number-functions-and-constants\">General Number Functions and Constants</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#bigfloats\">BigFloats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#random-numbers\">Random Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"strings.html\">Strings</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"arrays.html\">Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#basic-functions\">Basic functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#mathematical-operators-and-functions\">Mathematical operators and functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#indexing-assignment-and-concatenation\">Indexing, Assignment, and Concatenation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#array-functions\">Array functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#combinatorics\">Combinatorics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#bitarrays\">BitArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#sparse-vectors-and-matrices\">Sparse Vectors and Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"parallel.html\">Tasks and Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#tasks\">Tasks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#general-parallel-computing-support\">General Parallel Computing Support</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#shared-arrays\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#multi-threading\">Multi-Threading</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#ccall-using-a-threadpool-experimental\">ccall using a threadpool (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#synchronization-primitives\">Synchronization Primitives</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#cluster-manager-interface\">Cluster Manager Interface</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"linalg.html\">Linear Algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linalg.html#module-Base.LinAlg\">Standard Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linalg.html#low-level-matrix-operations\">Low-level matrix operations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linalg.html#module-Base.LinAlg.BLAS\">BLAS Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linalg.html#module-Base.LinAlg.LAPACK\">LAPACK Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"constants.html\">Constants</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"file.html\">Filesystem</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"io-network.html\">I/O and Network</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#general-i-o\">General I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#multimedia-i-o\">Multimedia I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#memory-mapped-i-o\">Memory-mapped I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#network-i-o\">Network I/O</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"punctuation.html\">Punctuation</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"sort.html\">Sorting and Related Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sort.html#sorting-functions\">Sorting Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sort.html#order-related-functions\">Order-Related Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sort.html#sorting-algorithms\">Sorting Algorithms</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"pkg.html\">Package Manager Functions</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"dates.html\">Dates and Time</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#dates-and-time-types\">Dates and Time Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#dates-functions\">Dates Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"test.html\">Unit Testing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#testing-base-julia\">Testing Base Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#basic-unit-tests\">Basic Unit Tests</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#working-with-test-sets\">Working with Test Sets</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#other-test-macros\">Other Test Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#broken-tests\">Broken Tests</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#creating-custom-abstracttestset-types\">Creating Custom <code class=\"docutils literal\"><span class=\"pre\">AbstractTestSet</span></code> Types</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"c.html\">C Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"c.html#llvm-interface\">LLVM Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"libc.html\">C Standard Library</a></li>\n<li class=\"toctree-l1 current\"><a class=\"current reference internal\" href=\"#\">Dynamic Linker</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"profile.html\">Profiling</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stacktraces.html\">StackTraces</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"simd-types.html\">SIMD Support</a></li>\n</ul>\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/reflection.html\">Reflection and introspection</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/julia.html\">Documentation of Julia&#8217;s Internals</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/init.html\">Initialization of the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/eval.html\">Eval of Julia code</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/ast.html\">Julia ASTs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/types.html\">More about types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/object.html\">Memory layout of Julia Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/functions.html\">Julia Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/callconv.html\">Calling Conventions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/cartesian.html\">Base.Cartesian</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/meta.html\">Talking to the compiler (the <code class=\"docutils literal\"><span class=\"pre\">:meta</span></code> mechanism)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/subarrays.html\">SubArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/sysimg.html\">System Image Building</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/llvm.html\">Working with LLVM</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/stdio.html\">printf() and stdio in the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/boundscheck.html\">Bounds checking</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/locks.html\">Proper maintenance and care of multi-threading locks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/offset-arrays.html\">Arrays with custom indices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/C.html\">Developing/debugging Julia&#8217;s C code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/backtraces.html\">Reporting and analyzing crashes (segfaults)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/debuggingtips.html\">gdb debugging tips</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/valgrind.html\">Using Valgrind with Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/sanitizers.html\">Sanitizer support</a></li>\n</ul>\n</li>\n</ul>\n\n        \n      </div>\n      &nbsp;\n    </nav>\n\n    <section data-toggle=\"wy-nav-shift\" class=\"wy-nav-content-wrap\">\n\n      \n      <nav class=\"wy-nav-top\" role=\"navigation\" aria-label=\"top navigation\">\n        <i data-toggle=\"wy-nav-top\" class=\"fa fa-bars\"></i>\n        <a href=\"../index.html\">Julia Language</a>\n      </nav>\n\n\n      \n      <div class=\"wy-nav-content\">\n        <div class=\"rst-content\">\n          <div role=\"navigation\" aria-label=\"breadcrumbs navigation\">\n  <ul class=\"wy-breadcrumbs\">\n    <li><a href=\"../index.html\">Docs</a> &raquo;</li>\n      \n    <li>Dynamic Linker</li>\n      <li class=\"wy-breadcrumbs-aside\">\n        \n          <a href=\"../_sources/stdlib/libdl.txt\" rel=\"nofollow\"> View page source</a>\n        \n      </li>\n  </ul>\n  <hr/>\n</div>\n          <div role=\"main\" class=\"document\">\n            \n  <span class=\"target\" id=\"module-Libdl\"></span><div class=\"section\" id=\"dynamic-linker\">\n<h1>Dynamic Linker<a class=\"headerlink\" href=\"#dynamic-linker\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<p>The names in <code class=\"xref jl jl-mod docutils literal\"><span class=\"pre\">Base.Libdl</span></code> are not exported and need to be called e.g. as <code class=\"docutils literal\"><span class=\"pre\">Libdl.dlopen()</span></code>.</p>\n<dl class=\"function\">\n<dt id=\"Base.Libdl.dlopen\">\n<code class=\"descname\">dlopen</code><span class=\"sig-paren\">(</span><em>libfile::AbstractString</em><span class=\"optional\">[</span>, <em>flags::Integer</em><span class=\"optional\">]</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.Libdl.dlopen\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Load a shared library, returning an opaque handle.</p>\n<p>The optional flags argument is a bitwise-or of zero or more of <code class=\"docutils literal\"><span class=\"pre\">RTLD_LOCAL</span></code>, <code class=\"docutils literal\"><span class=\"pre\">RTLD_GLOBAL</span></code>, <code class=\"docutils literal\"><span class=\"pre\">RTLD_LAZY</span></code>, <code class=\"docutils literal\"><span class=\"pre\">RTLD_NOW</span></code>, <code class=\"docutils literal\"><span class=\"pre\">RTLD_NODELETE</span></code>, <code class=\"docutils literal\"><span class=\"pre\">RTLD_NOLOAD</span></code>, <code class=\"docutils literal\"><span class=\"pre\">RTLD_DEEPBIND</span></code>, and <code class=\"docutils literal\"><span class=\"pre\">RTLD_FIRST</span></code>. These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default <code class=\"docutils literal\"><span class=\"pre\">dlopen</span></code> flags are <code class=\"docutils literal\"><span class=\"pre\">RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL</span></code> while on other platforms the defaults are <code class=\"docutils literal\"><span class=\"pre\">RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL</span></code>. An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance <code class=\"docutils literal\"><span class=\"pre\">RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL</span></code> allows the library&#8217;s symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.Libdl.dlopen_e\">\n<code class=\"descname\">dlopen_e</code><span class=\"sig-paren\">(</span><em>libfile::AbstractString</em><span class=\"optional\">[</span>, <em>flags::Integer</em><span class=\"optional\">]</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.Libdl.dlopen_e\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Similar to <a class=\"reference internal\" href=\"#Base.Libdl.dlopen\" title=\"Base.Libdl.dlopen\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">dlopen()</span></code></a>, except returns a <code class=\"docutils literal\"><span class=\"pre\">NULL</span></code> pointer instead of raising errors.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Libdl.RTLD_DEEPBIND\">\n<code class=\"descname\">RTLD_DEEPBIND</code><a class=\"headerlink\" href=\"#Base.Libdl.RTLD_DEEPBIND\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dt id=\"Base.Libdl.RTLD_FIRST\">\n<code class=\"descname\">RTLD_FIRST</code><a class=\"headerlink\" href=\"#Base.Libdl.RTLD_FIRST\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dt id=\"Base.Libdl.RTLD_GLOBAL\">\n<code class=\"descname\">RTLD_GLOBAL</code><a class=\"headerlink\" href=\"#Base.Libdl.RTLD_GLOBAL\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dt id=\"Base.Libdl.RTLD_LAZY\">\n<code class=\"descname\">RTLD_LAZY</code><a class=\"headerlink\" href=\"#Base.Libdl.RTLD_LAZY\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dt id=\"Base.Libdl.RTLD_LOCAL\">\n<code class=\"descname\">RTLD_LOCAL</code><a class=\"headerlink\" href=\"#Base.Libdl.RTLD_LOCAL\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dt id=\"Base.Libdl.RTLD_NODELETE\">\n<code class=\"descname\">RTLD_NODELETE</code><a class=\"headerlink\" href=\"#Base.Libdl.RTLD_NODELETE\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dt id=\"Base.Libdl.RTLD_NOLOAD\">\n<code class=\"descname\">RTLD_NOLOAD</code><a class=\"headerlink\" href=\"#Base.Libdl.RTLD_NOLOAD\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dt id=\"Base.Libdl.RTLD_NOW\">\n<code class=\"descname\">RTLD_NOW</code><a class=\"headerlink\" href=\"#Base.Libdl.RTLD_NOW\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Enum constant for <a class=\"reference internal\" href=\"#Base.Libdl.dlopen\" title=\"Base.Libdl.dlopen\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">dlopen()</span></code></a>. See your platform man page for details, if applicable.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.Libdl.dlsym\">\n<code class=\"descname\">dlsym</code><span class=\"sig-paren\">(</span><em>handle</em>, <em>sym</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.Libdl.dlsym\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Look up a symbol from a shared library handle, return callable function pointer on success.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.Libdl.dlsym_e\">\n<code class=\"descname\">dlsym_e</code><span class=\"sig-paren\">(</span><em>handle</em>, <em>sym</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.Libdl.dlsym_e\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Look up a symbol from a shared library handle, silently return <code class=\"docutils literal\"><span class=\"pre\">NULL</span></code> pointer on lookup failure.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.Libdl.dlclose\">\n<code class=\"descname\">dlclose</code><span class=\"sig-paren\">(</span><em>handle</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.Libdl.dlclose\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Close shared library referenced by handle.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Libdl.dlext\">\n<code class=\"descname\">dlext</code><a class=\"headerlink\" href=\"#Base.Libdl.dlext\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>File extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.Libdl.find_library\">\n<code class=\"descname\">find_library</code><span class=\"sig-paren\">(</span><em>names</em>, <em>locations</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.Libdl.find_library\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Searches for the first library in <code class=\"docutils literal\"><span class=\"pre\">names</span></code> in the paths in the <code class=\"docutils literal\"><span class=\"pre\">locations</span></code> list, <code class=\"docutils literal\"><span class=\"pre\">DL_LOAD_PATH</span></code>, or system library paths (in that order) which can successfully be dlopen&#8217;d. On success, the return value will be one of the names (potentially prefixed by one of the paths in locations). This string can be assigned to a <code class=\"docutils literal\"><span class=\"pre\">global</span> <span class=\"pre\">const</span></code> and used as the library name in future <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code>&#8216;s. On failure, it returns the empty string.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Libdl.DL_LOAD_PATH\">\n<code class=\"descname\">DL_LOAD_PATH</code><a class=\"headerlink\" href=\"#Base.Libdl.DL_LOAD_PATH\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>When calling <a class=\"reference internal\" href=\"#Base.Libdl.dlopen\" title=\"Base.Libdl.dlopen\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">dlopen()</span></code></a>, the paths in this list will be searched first, in order, before searching the system locations for a valid library handle.</p>\n</dd></dl>\n\n</div>\n\n\n          </div>\n          <footer>\n  \n    <div class=\"rst-footer-buttons\" role=\"navigation\" aria-label=\"footer navigation\">\n      \n        <a href=\"profile.html\" class=\"btn btn-neutral float-right\" title=\"Profiling\">Next <span class=\"fa fa-arrow-circle-right\"></span></a>\n      \n      \n        <a href=\"libc.html\" class=\"btn btn-neutral\" title=\"C Standard Library\"><span class=\"fa fa-arrow-circle-left\"></span> Previous</a>\n      \n    </div>\n  \n\n  <hr/>\n\n  <div role=\"contentinfo\">\n    <p>\n    </p>\n  </div>\n\n  <a href=\"https://github.com/snide/sphinx_rtd_theme\">Sphinx theme</a> provided by <a href=\"https://readthedocs.org\">Read the Docs</a>\n</footer>\n        </div>\n      </div>\n\n    </section>\n\n  </div>\n  \n\n  \n\n    <script type=\"text/javascript\">\n        var DOCUMENTATION_OPTIONS = {\n            URL_ROOT:'../',\n            VERSION:'0.5.1',\n            COLLAPSE_INDEX:false,\n            FILE_SUFFIX:'.html',\n            HAS_SOURCE:  true\n        };\n    </script>\n      <script type=\"text/javascript\" src=\"../_static/jquery.js\"></script>\n      <script type=\"text/javascript\" src=\"../_static/underscore.js\"></script>\n      <script type=\"text/javascript\" src=\"../_static/doctools.js\"></script>\n      <script type=\"text/javascript\" src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>\n\n  \n\n  \n  \n    <script type=\"text/javascript\" src=\"../_static/js/theme.js\"></script>\n  \n\n  \n  \n  <script type=\"text/javascript\">\n      jQuery(function () {\n          SphinxRtdTheme.StickyNav.enable();\n      });\n  </script>\n   \n\n</body>\n</html>",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/stdlib/c.html": "\n\n<!DOCTYPE html>\n<!--[if IE 8]><html class=\"no-js lt-ie9\" lang=\"en\" > <![endif]-->\n<!--[if gt IE 8]><!--> <html class=\"no-js\" lang=\"en\" > <!--<![endif]-->\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  \n  <title>C Interface &mdash; Julia Language 0.5.1 documentation</title>\n  \n\n  \n  \n\n  \n  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>\n\n  \n  \n    \n\n  \n\n  \n  \n    <link rel=\"stylesheet\" href=\"../_static/julia.css\" type=\"text/css\" />\n  \n\n  \n    <link rel=\"stylesheet\" href=\"../_static/julia.css\" type=\"text/css\" />\n  \n    <link rel=\"top\" title=\"Julia Language 0.5.1 documentation\" href=\"../index.html\"/>\n        <link rel=\"next\" title=\"C Standard Library\" href=\"libc.html\"/>\n        <link rel=\"prev\" title=\"Unit Testing\" href=\"test.html\"/> \n\n  \n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js\"></script>\n\n</head>\n\n<body class=\"wy-body-for-nav\" role=\"document\">\n\n  <div class=\"wy-grid-for-nav\">\n\n    \n    <nav data-toggle=\"wy-nav-shift\" class=\"wy-nav-side\">\n      <div class=\"wy-side-nav-search\">\n        <a href=\"http://julialang.org/\"><img src=\"../_static/julia-logo.svg\" class=\"logo\"></a>\n        <!--\n        <a href=\"../index.html\" class=\"fa fa-home\"> Julia Language</a>\n        -->\n        <div role=\"search\">\n  <form id =\"rtd-search-form\" class=\"wy-form\" action=\"../search.html\" method=\"get\">\n    <input type=\"text\" name=\"q\" placeholder=\"Search docs\" />\n    <input type=\"hidden\" name=\"check_keywords\" value=\"yes\" />\n    <input type=\"hidden\" name=\"area\" value=\"default\" />\n  </form>\n</div>\n      </div>\n\n      <div class=\"wy-menu wy-menu-vertical\" data-spy=\"affix\" role=\"navigation\" aria-label=\"main navigation\">\n        \n        \n            <ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/introduction.html\">Introduction</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/getting-started.html\">Getting Started</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/getting-started.html#resources\">Resources</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/variables.html\">Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables.html#allowed-variable-names\">Allowed Variable Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables.html#stylistic-conventions\">Stylistic Conventions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html\">Integers and Floating-Point Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#integers\">Integers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#floating-point-numbers\">Floating-Point Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#arbitrary-precision-arithmetic\">Arbitrary Precision Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#numeric-literal-coefficients\">Numeric Literal Coefficients</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/integers-and-floating-point-numbers.html#literal-zero-and-one\">Literal zero and one</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html\">Mathematical Operations and Elementary Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#arithmetic-operators\">Arithmetic Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#bitwise-operators\">Bitwise Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#updating-operators\">Updating operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#numeric-comparisons\">Numeric Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/mathematical-operations.html#numerical-conversions\">Numerical Conversions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/complex-and-rational-numbers.html\">Complex and Rational Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/complex-and-rational-numbers.html#complex-numbers\">Complex Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/complex-and-rational-numbers.html#rational-numbers\">Rational Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/strings.html\">Strings</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#characters\">Characters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#string-basics\">String Basics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#unicode-and-utf-8\">Unicode and UTF-8</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#triple-quoted-string-literals\">Triple-Quoted String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#common-operations\">Common Operations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#regular-expressions\">Regular Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#id2\">Byte Array Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/strings.html#version-number-literals\">Version Number Literals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/functions.html\">Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#argument-passing-behavior\">Argument Passing Behavior</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#the-return-keyword\">The <code class=\"docutils literal\"><span class=\"pre\">return</span></code> Keyword</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#operators-are-functions\">Operators Are Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#operators-with-special-names\">Operators With Special Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#anonymous-functions\">Anonymous Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#multiple-return-values\">Multiple Return Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#varargs-functions\">Varargs Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#optional-arguments\">Optional Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#keyword-arguments\">Keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#evaluation-scope-of-default-values\">Evaluation Scope of Default Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#do-block-syntax-for-function-arguments\">Do-Block Syntax for Function Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#dot-syntax-for-vectorizing-functions\">Dot Syntax for Vectorizing Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/functions.html#further-reading\">Further Reading</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/control-flow.html\">Control Flow</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#compound-expressions\">Compound Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#conditional-evaluation\">Conditional Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#short-circuit-evaluation\">Short-Circuit Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#repeated-evaluation-loops\">Repeated Evaluation: Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#exception-handling\">Exception Handling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/control-flow.html#tasks-aka-coroutines\">Tasks (aka Coroutines)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html\">Scope of Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html#global-scope\">Global Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html#local-scope\">Local Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/variables-and-scoping.html#constants\">Constants</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/types.html\">Types</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#type-declarations\">Type Declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#abstract-types\">Abstract Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#bits-types\">Bits Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#composite-types\">Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#immutable-composite-types\">Immutable Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#declared-types\">Declared Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#type-unions\">Type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#man-parametric-types\">Parametric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#type-aliases\">Type Aliases</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#operations-on-types\">Operations on Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#custom-pretty-printing\">Custom pretty-printing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#value-types\">&#8220;Value types&#8221;</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/types.html#nullable-types-representing-missing-values\">Nullable Types: Representing Missing Values</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/methods.html\">Methods</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#defining-methods\">Defining Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#method-ambiguities\">Method Ambiguities</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#parametric-methods\">Parametric Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#parametrically-constrained-varargs-methods\">Parametrically-constrained Varargs methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#note-on-optional-and-keyword-arguments\">Note on Optional and keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#function-like-objects\">Function-like objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/methods.html#empty-generic-functions\">Empty generic functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/constructors.html\">Constructors</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#outer-constructor-methods\">Outer Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#inner-constructor-methods\">Inner Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#incomplete-initialization\">Incomplete Initialization</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#parametric-constructors\">Parametric Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#case-study-rational\">Case Study: Rational</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#constructors-and-conversion\">Constructors and Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/constructors.html#outer-only-constructors\">Outer-only constructors</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/conversion-and-promotion.html\">Conversion and Promotion</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/conversion-and-promotion.html#conversion\">Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/conversion-and-promotion.html#promotion\">Promotion</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/interfaces.html\">Interfaces</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interfaces.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interfaces.html#indexing\">Indexing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interfaces.html#abstract-arrays\">Abstract Arrays</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/modules.html\">Modules</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/modules.html#summary-of-module-usage\">Summary of module usage</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/documentation.html\">Documentation</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#accessing-documentation\">Accessing Documentation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#functions-methods\">Functions &amp; Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#advanced-usage\">Advanced Usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#syntax-guide\">Syntax Guide</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#markdown-syntax\">Markdown syntax</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/documentation.html#markdown-syntax-extensions\">Markdown Syntax Extensions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html\">Metaprogramming</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#program-representation\">Program representation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#expressions-and-evaluation\">Expressions and evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#macros\">Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#code-generation\">Code Generation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/metaprogramming.html#generated-functions\">Generated functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/arrays.html\">Multi-dimensional Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/arrays.html#arrays\">Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/arrays.html#sparse-matrices\">Sparse Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/linear-algebra.html\">Linear algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/linear-algebra.html#matrix-factorizations\">Matrix factorizations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/linear-algebra.html#special-matrices\">Special matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html\">Networking and Streams</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#basic-stream-i-o\">Basic Stream I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#io-output-contextual-properties\">IO Output Contextual Properties</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#working-with-files\">Working with Files</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#a-simple-tcp-example\">A simple TCP example</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/networking-and-streams.html#resolving-ip-addresses\">Resolving IP Addresses</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html\">Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#code-availability-and-loading-packages\">Code Availability and Loading Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#data-movement\">Data Movement</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#parallel-map-and-loops\">Parallel Map and Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#synchronization-with-remote-references\">Synchronization With Remote References</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#scheduling\">Scheduling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#channels\">Channels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#remote-references-and-abstractchannels\">Remote references and AbstractChannels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#remote-references-and-distributed-garbage-collection\">Remote References and Distributed Garbage Collection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#id2\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#shared-arrays-and-distributed-garbage-collection\">Shared Arrays and Distributed Garbage Collection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#clustermanagers\">ClusterManagers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#cluster-managers-with-custom-transports\">Cluster Managers with custom transports</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#network-requirements-for-localmanager-and-sshmanager\">Network requirements for LocalManager and SSHManager</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#cluster-cookie\">Cluster cookie</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#specifying-network-topology-experimental\">Specifying network topology (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#multi-threading-experimental\">Multi-threading (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/parallel-computing.html#threadcall-experimental\">&#64;threadcall (Experimental)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/dates.html\">Date and DateTime</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#durations-comparisons\">Durations/Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#accessor-functions\">Accessor Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#query-functions\">Query Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#timetype-period-arithmetic\">TimeType-Period Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#adjuster-functions\">Adjuster Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#period-types\">Period Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/dates.html#rounding\">Rounding</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html\">Running External Programs</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html#quoting\">Quoting</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/running-external-programs.html#pipelines\">Pipelines</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html\">Calling C and Fortran Code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#creating-c-compatible-julia-function-pointers\">Creating C-Compatible Julia Function Pointers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#mapping-c-types-to-julia\">Mapping C Types to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#mapping-c-functions-to-julia\">Mapping C Functions to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#some-examples-of-c-wrappers\">Some Examples of C Wrappers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#garbage-collection-safety\">Garbage Collection Safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#non-constant-function-specifications\">Non-constant Function Specifications</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#indirect-calls\">Indirect Calls</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#calling-convention\">Calling Convention</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#accessing-global-variables\">Accessing Global Variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#accessing-data-through-a-pointer\">Accessing Data through a Pointer</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#thread-safety\">Thread-safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#more-about-callbacks\">More About Callbacks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/calling-c-and-fortran-code.html#c\">C++</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/handling-operating-system-variation.html\">Handling Operating System Variation</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html\">Interacting With Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html#the-different-prompt-modes\">The different prompt modes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html#key-bindings\">Key bindings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html#tab-completion\">Tab completion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/interacting-with-julia.html#customizing-colors\">Customizing Colors</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/embedding.html\">Embedding Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#high-level-embedding\">High-Level Embedding</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#converting-types\">Converting Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#calling-julia-functions\">Calling Julia Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#memory-management\">Memory Management</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#working-with-arrays\">Working with Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/embedding.html#exceptions\">Exceptions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/packages.html\">Packages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#package-status\">Package Status</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#adding-and-removing-packages\">Adding and Removing Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#offline-installation-of-packages\">Offline Installation of Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#installing-unregistered-packages\">Installing Unregistered Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#updating-packages\">Updating Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#checkout-pin-and-free\">Checkout, Pin and Free</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#custom-metadata-repository\">Custom METADATA Repository</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/packages.html#package-development\">Package Development</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#initial-setup\">Initial Setup</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#making-changes-to-an-existing-package\">Making changes to an existing package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#creating-a-new-package\">Creating a new Package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#fixing-package-requirements\">Fixing Package Requirements</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/packages.html#man-package-requirements\">Requirements Specification</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/profile.html\">Profiling</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#basic-usage\">Basic usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#accumulation-and-clearing\">Accumulation and clearing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#options-for-controlling-the-display-of-profile-results\">Options for controlling the display of profile results</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/profile.html#configuration\">Configuration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/profile.html#memory-allocation-analysis\">Memory allocation analysis</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/stacktraces.html\">Stack Traces</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/stacktraces.html#viewing-a-stack-trace\">Viewing a stack trace</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/stacktraces.html#extracting-useful-information\">Extracting useful information</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/stacktraces.html#error-handling\">Error handling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/stacktraces.html#comparison-with-backtrace\">Comparison with <code class=\"docutils literal\"><span class=\"pre\">backtrace()</span></code></a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/performance-tips.html\">Performance Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-global-variables\">Avoid global variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#measure-performance-with-time-and-pay-attention-to-memory-allocation\">Measure performance with <code class=\"docutils literal\"><span class=\"pre\">&#64;time</span></code> and pay attention to memory allocation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#tools\">Tools</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-containers-with-abstract-type-parameters\">Avoid containers with abstract type parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#type-declarations\">Type declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#break-functions-into-multiple-definitions\">Break functions into multiple definitions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#write-type-stable-functions\">Write &#8220;type-stable&#8221; functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-changing-the-type-of-a-variable\">Avoid changing the type of a variable</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#separate-kernel-functions-aka-function-barriers\">Separate kernel functions (aka, function barriers)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#types-with-values-as-parameters\">Types with values-as-parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#the-dangers-of-abusing-multiple-dispatch-aka-more-on-types-with-values-as-parameters\">The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#access-arrays-in-memory-order-along-columns\">Access arrays in memory order, along columns</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#pre-allocating-outputs\">Pre-allocating outputs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#avoid-string-interpolation-for-i-o\">Avoid string interpolation for I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#optimize-network-i-o-during-parallel-execution\">Optimize network I/O during parallel execution</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#fix-deprecation-warnings\">Fix deprecation warnings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#tweaks\">Tweaks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#performance-annotations\">Performance Annotations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#treat-subnormal-numbers-as-zeros\">Treat Subnormal Numbers as Zeros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/performance-tips.html#code-warntype\"><code class=\"docutils literal\"><span class=\"pre\">&#64;code_warntype</span></code></a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/workflow-tips.html\">Workflow Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/workflow-tips.html#repl-based-workflow\">REPL-based workflow</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/workflow-tips.html#browser-based-workflow\">Browser-based workflow</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/style-guide.html\">Style Guide</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#write-functions-not-just-scripts\">Write functions, not just scripts</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-writing-overly-specific-types\">Avoid writing overly-specific types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#handle-excess-argument-diversity-in-the-caller\">Handle excess argument diversity in the caller</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#append-to-names-of-functions-that-modify-their-arguments\">Append <code class=\"docutils literal\"><span class=\"pre\">!</span></code> to names of functions that modify their arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-strange-type-unions\">Avoid strange type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-type-unions-in-fields\">Avoid type Unions in fields</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-elaborate-container-types\">Avoid elaborate container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#use-naming-conventions-consistent-with-julia-s-base\">Use naming conventions consistent with Julia&#8217;s <code class=\"docutils literal\"><span class=\"pre\">base/</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overuse-try-catch\">Don&#8217;t overuse try-catch</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-parenthesize-conditions\">Don&#8217;t parenthesize conditions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overuse\">Don&#8217;t overuse ...</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-use-unnecessary-static-parameters\">Don&#8217;t use unnecessary static parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-confusion-about-whether-something-is-an-instance-or-a-type\">Avoid confusion about whether something is an instance or a type</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overuse-macros\">Don&#8217;t overuse macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-expose-unsafe-operations-at-the-interface-level\">Don&#8217;t expose unsafe operations at the interface level</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#don-t-overload-methods-of-base-container-types\">Don&#8217;t overload methods of base container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#be-careful-with-type-equality\">Be careful with type equality</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#do-not-write-x-f-x\">Do not write <code class=\"docutils literal\"><span class=\"pre\">x-&gt;f(x)</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/style-guide.html#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible\">Avoid using floats for numeric literals in generic code when possible</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/faq.html\">Frequently Asked Questions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#sessions-and-the-repl\">Sessions and the REPL</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#functions\">Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#types-type-declarations-and-constructors\">Types, type declarations, and constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#packages-and-modules\">Packages and Modules</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#nothingness-and-missing-values\">Nothingness and missing values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#memory\">Memory</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#asynchronous-io-and-concurrent-synchronous-writes\">Asynchronous IO and concurrent synchronous writes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/faq.html#julia-releases\">Julia Releases</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html\">Noteworthy Differences from other Languages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-matlab\">Noteworthy differences from MATLAB</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-r\">Noteworthy differences from R</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-python\">Noteworthy differences from Python</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../manual/noteworthy-differences.html#noteworthy-differences-from-c-c\">Noteworthy differences from C/C++</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../manual/unicode-input.html\">Unicode Input</a></li>\n</ul>\n<ul class=\"current\">\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"base.html\">Essentials</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#introduction\">Introduction</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#getting-around\">Getting Around</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#all-objects\">All Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#types\">Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#generic-functions\">Generic Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#syntax\">Syntax</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#nullables\">Nullables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#system\">System</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#errors\">Errors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#events\">Events</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#reflection\">Reflection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"base.html#internals\">Internals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"collections.html\">Collections and Data Structures</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#general-collections\">General Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#iterable-collections\">Iterable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#indexable-collections\">Indexable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#associative-collections\">Associative Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#set-like-collections\">Set-Like Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#dequeues\">Dequeues</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#priorityqueue\">PriorityQueue</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"collections.html#heap-functions\">Heap Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"math.html\">Mathematics</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#mathematical-operators\">Mathematical Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#mathematical-functions\">Mathematical Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#statistics\">Statistics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#signal-processing\">Signal Processing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"math.html#numerical-integration\">Numerical Integration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"numbers.html\">Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#standard-numeric-types\">Standard Numeric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#data-formats\">Data Formats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#general-number-functions-and-constants\">General Number Functions and Constants</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#bigfloats\">BigFloats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"numbers.html#random-numbers\">Random Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"strings.html\">Strings</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"arrays.html\">Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#basic-functions\">Basic functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#mathematical-operators-and-functions\">Mathematical operators and functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#indexing-assignment-and-concatenation\">Indexing, Assignment, and Concatenation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#array-functions\">Array functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#combinatorics\">Combinatorics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#bitarrays\">BitArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#sparse-vectors-and-matrices\">Sparse Vectors and Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"parallel.html\">Tasks and Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#tasks\">Tasks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#general-parallel-computing-support\">General Parallel Computing Support</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#shared-arrays\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#multi-threading\">Multi-Threading</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#ccall-using-a-threadpool-experimental\">ccall using a threadpool (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#synchronization-primitives\">Synchronization Primitives</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel.html#cluster-manager-interface\">Cluster Manager Interface</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"linalg.html\">Linear Algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linalg.html#module-Base.LinAlg\">Standard Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linalg.html#low-level-matrix-operations\">Low-level matrix operations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linalg.html#module-Base.LinAlg.BLAS\">BLAS Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linalg.html#module-Base.LinAlg.LAPACK\">LAPACK Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"constants.html\">Constants</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"file.html\">Filesystem</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"io-network.html\">I/O and Network</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#general-i-o\">General I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#multimedia-i-o\">Multimedia I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#memory-mapped-i-o\">Memory-mapped I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"io-network.html#network-i-o\">Network I/O</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"punctuation.html\">Punctuation</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"sort.html\">Sorting and Related Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sort.html#sorting-functions\">Sorting Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sort.html#order-related-functions\">Order-Related Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"sort.html#sorting-algorithms\">Sorting Algorithms</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"pkg.html\">Package Manager Functions</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"dates.html\">Dates and Time</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#dates-and-time-types\">Dates and Time Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#dates-functions\">Dates Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"test.html\">Unit Testing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#testing-base-julia\">Testing Base Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#basic-unit-tests\">Basic Unit Tests</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#working-with-test-sets\">Working with Test Sets</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#other-test-macros\">Other Test Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#broken-tests\">Broken Tests</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"test.html#creating-custom-abstracttestset-types\">Creating Custom <code class=\"docutils literal\"><span class=\"pre\">AbstractTestSet</span></code> Types</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1 current\"><a class=\"current reference internal\" href=\"#\">C Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"#llvm-interface\">LLVM Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"libc.html\">C Standard Library</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"libdl.html\">Dynamic Linker</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"profile.html\">Profiling</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stacktraces.html\">StackTraces</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"simd-types.html\">SIMD Support</a></li>\n</ul>\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/reflection.html\">Reflection and introspection</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/julia.html\">Documentation of Julia&#8217;s Internals</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/init.html\">Initialization of the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/eval.html\">Eval of Julia code</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/ast.html\">Julia ASTs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/types.html\">More about types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/object.html\">Memory layout of Julia Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/functions.html\">Julia Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/callconv.html\">Calling Conventions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/cartesian.html\">Base.Cartesian</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/meta.html\">Talking to the compiler (the <code class=\"docutils literal\"><span class=\"pre\">:meta</span></code> mechanism)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/subarrays.html\">SubArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/sysimg.html\">System Image Building</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/llvm.html\">Working with LLVM</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/stdio.html\">printf() and stdio in the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/boundscheck.html\">Bounds checking</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/locks.html\">Proper maintenance and care of multi-threading locks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/offset-arrays.html\">Arrays with custom indices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/C.html\">Developing/debugging Julia&#8217;s C code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/backtraces.html\">Reporting and analyzing crashes (segfaults)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/debuggingtips.html\">gdb debugging tips</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/valgrind.html\">Using Valgrind with Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/sanitizers.html\">Sanitizer support</a></li>\n</ul>\n</li>\n</ul>\n\n        \n      </div>\n      &nbsp;\n    </nav>\n\n    <section data-toggle=\"wy-nav-shift\" class=\"wy-nav-content-wrap\">\n\n      \n      <nav class=\"wy-nav-top\" role=\"navigation\" aria-label=\"top navigation\">\n        <i data-toggle=\"wy-nav-top\" class=\"fa fa-bars\"></i>\n        <a href=\"../index.html\">Julia Language</a>\n      </nav>\n\n\n      \n      <div class=\"wy-nav-content\">\n        <div class=\"rst-content\">\n          <div role=\"navigation\" aria-label=\"breadcrumbs navigation\">\n  <ul class=\"wy-breadcrumbs\">\n    <li><a href=\"../index.html\">Docs</a> &raquo;</li>\n      \n    <li>C Interface</li>\n      <li class=\"wy-breadcrumbs-aside\">\n        \n          <a href=\"../_sources/stdlib/c.txt\" rel=\"nofollow\"> View page source</a>\n        \n      </li>\n  </ul>\n  <hr/>\n</div>\n          <div role=\"main\" class=\"document\">\n            \n  <div class=\"section\" id=\"c-interface\">\n<h1>C Interface<a class=\"headerlink\" href=\"#c-interface\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<dl class=\"function\">\n<dt id=\"Base.ccall\">\n<code class=\"descname\">ccall</code><span class=\"sig-paren\">(</span><em>(symbol</em>, <em>library) or function_pointer</em>, <em>ReturnType</em>, <em>(ArgumentType1</em>, <em>...)</em>, <em>ArgumentValue1</em>, <em>...</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.ccall\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Call function in C-exported shared library, specified by <code class=\"docutils literal\"><span class=\"pre\">(function</span> <span class=\"pre\">name,</span> <span class=\"pre\">library)</span></code> tuple, where each component is a string or symbol.</p>\n<p>Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression. Alternatively, <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code> may also be used to call a function pointer, such as one returned by <code class=\"docutils literal\"><span class=\"pre\">dlsym</span></code>.</p>\n<p>Each <code class=\"docutils literal\"><span class=\"pre\">ArgumentValue</span></code> to the <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code> will be converted to the corresponding <code class=\"docutils literal\"><span class=\"pre\">ArgumentType</span></code>, by automatic insertion of calls to <code class=\"docutils literal\"><span class=\"pre\">unsafe_convert(ArgumentType,</span> <span class=\"pre\">cconvert(ArgumentType,</span> <span class=\"pre\">ArgumentValue))</span></code>. (See also the documentation for each of these functions for further details.) In most cases, this simply results in a call to <code class=\"docutils literal\"><span class=\"pre\">convert(ArgumentType,</span> <span class=\"pre\">ArgumentValue)</span></code>.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.cglobal\">\n<code class=\"descname\">cglobal</code><span class=\"sig-paren\">(</span><em>(symbol</em>, <em>library)</em><span class=\"optional\">[</span>, <em>type=Void</em><span class=\"optional\">]</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.cglobal\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Obtain a pointer to a global variable in a C-exported shared library, specified exactly as in <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code>. Returns a <code class=\"docutils literal\"><span class=\"pre\">Ptr{Type}</span></code>, defaulting to <code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code> if no Type argument is supplied. The values can be read or written by <code class=\"docutils literal\"><span class=\"pre\">unsafe_load</span></code> or <code class=\"docutils literal\"><span class=\"pre\">unsafe_store!</span></code>, respectively.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.cfunction\">\n<code class=\"descname\">cfunction</code><span class=\"sig-paren\">(</span><em>function::Function</em>, <em>ReturnType::Type</em>, <em>(ArgumentTypes...)</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.cfunction\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Generate C-callable function pointer from Julia function. Type annotation of the return value in the callback function is a must for situations where Julia cannot infer the return type automatically.</p>\n<p>For example:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">function</span> <span class=\"n\">foo</span><span class=\"p\">()</span>\n    <span class=\"c\"># body</span>\n\n    <span class=\"n\">retval</span><span class=\"o\">::</span><span class=\"kt\">Float64</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">bar</span> <span class=\"o\">=</span> <span class=\"n\">cfunction</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"kt\">Float64</span><span class=\"p\">,</span> <span class=\"p\">())</span>\n</pre></div>\n</div>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.unsafe_convert\">\n<code class=\"descname\">unsafe_convert</code><span class=\"sig-paren\">(</span><em>T</em>, <em>x</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.unsafe_convert\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Convert <code class=\"docutils literal\"><span class=\"pre\">x</span></code> to a value of type <code class=\"docutils literal\"><span class=\"pre\">T</span></code></p>\n<p>In cases where <code class=\"docutils literal\"><span class=\"pre\">convert</span></code> would need to take a Julia object and turn it into a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code>, this function should be used to define and perform that conversion.</p>\n<p>Be careful to ensure that a Julia reference to <code class=\"docutils literal\"><span class=\"pre\">x</span></code> exists as long as the result of this function will be used. Accordingly, the argument <code class=\"docutils literal\"><span class=\"pre\">x</span></code> to this function should never be an expression, only a variable name or field reference. For example, <code class=\"docutils literal\"><span class=\"pre\">x=a.b.c</span></code> is acceptable, but <code class=\"docutils literal\"><span class=\"pre\">x=[a,b,c]</span></code> is not.</p>\n<p>The <code class=\"docutils literal\"><span class=\"pre\">unsafe</span></code> prefix on this function indicates that using the result of this function after the <code class=\"docutils literal\"><span class=\"pre\">x</span></code> argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.cconvert\">\n<code class=\"descname\">cconvert</code><span class=\"sig-paren\">(</span><em>T</em>, <em>x</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.cconvert\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Convert <code class=\"docutils literal\"><span class=\"pre\">x</span></code> to a value of type <code class=\"docutils literal\"><span class=\"pre\">T</span></code>, typically by calling <code class=\"docutils literal\"><span class=\"pre\">convert(T,x)</span></code></p>\n<p>In cases where <code class=\"docutils literal\"><span class=\"pre\">x</span></code> cannot be safely converted to <code class=\"docutils literal\"><span class=\"pre\">T</span></code>, unlike <code class=\"docutils literal\"><span class=\"pre\">convert</span></code>, <code class=\"docutils literal\"><span class=\"pre\">cconvert</span></code> may return an object of a type different from <code class=\"docutils literal\"><span class=\"pre\">T</span></code>, which however is suitable for <code class=\"docutils literal\"><span class=\"pre\">unsafe_convert</span></code> to handle.</p>\n<p>Neither <code class=\"docutils literal\"><span class=\"pre\">convert</span></code> nor <code class=\"docutils literal\"><span class=\"pre\">cconvert</span></code> should take a Julia object and turn it into a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code>.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.unsafe_load\">\n<code class=\"descname\">unsafe_load</code><span class=\"sig-paren\">(</span><em>p::Ptr{T}</em><span class=\"optional\">[</span>, <em>i::Integer=1</em><span class=\"optional\">]</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.unsafe_load\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Load a value of type <code class=\"docutils literal\"><span class=\"pre\">T</span></code> from the address of the ith element (1-indexed) starting at <code class=\"docutils literal\"><span class=\"pre\">p</span></code>. This is equivalent to the C expression <code class=\"docutils literal\"><span class=\"pre\">p[i-1]</span></code>.</p>\n<p>The <code class=\"docutils literal\"><span class=\"pre\">unsafe</span></code> prefix on this function indicates that no validation is performed on the pointer <code class=\"docutils literal\"><span class=\"pre\">p</span></code> to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.unsafe_store!\">\n<code class=\"descname\">unsafe_store!</code><span class=\"sig-paren\">(</span><em>p::Ptr{T}</em>, <em>x</em><span class=\"optional\">[</span>, <em>i::Integer=1</em><span class=\"optional\">]</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.unsafe_store!\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Store a value of type <code class=\"docutils literal\"><span class=\"pre\">T</span></code> to the address of the ith element (1-indexed) starting at <code class=\"docutils literal\"><span class=\"pre\">p</span></code>. This is equivalent to the C expression <code class=\"docutils literal\"><span class=\"pre\">p[i-1]</span> <span class=\"pre\">=</span> <span class=\"pre\">x</span></code>.</p>\n<p>The <code class=\"docutils literal\"><span class=\"pre\">unsafe</span></code> prefix on this function indicates that no validation is performed on the pointer <code class=\"docutils literal\"><span class=\"pre\">p</span></code> to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.unsafe_copy!\">\n<code class=\"descname\">unsafe_copy!</code><span class=\"sig-paren\">(</span><em>dest::Ptr{T}</em>, <em>src::Ptr{T}</em>, <em>N</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.unsafe_copy!\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Copy <code class=\"docutils literal\"><span class=\"pre\">N</span></code> elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.</p>\n<p>The <code class=\"docutils literal\"><span class=\"pre\">unsafe</span></code> prefix on this function indicates that no validation is performed on the pointers <code class=\"docutils literal\"><span class=\"pre\">dest</span></code> and <code class=\"docutils literal\"><span class=\"pre\">src</span></code> to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt>\n<code class=\"descname\">unsafe_copy!</code><span class=\"sig-paren\">(</span><em>dest::Array</em>, <em>do</em>, <em>src::Array</em>, <em>so</em>, <em>N</em><span class=\"sig-paren\">)</span></dt>\n<dd><p>Copy <code class=\"docutils literal\"><span class=\"pre\">N</span></code> elements from a source array to a destination, starting at offset <code class=\"docutils literal\"><span class=\"pre\">so</span></code> in the source and <code class=\"docutils literal\"><span class=\"pre\">do</span></code> in the destination (1-indexed).</p>\n<p>The <code class=\"docutils literal\"><span class=\"pre\">unsafe</span></code> prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.copy!\">\n<code class=\"descname\">copy!</code><span class=\"sig-paren\">(</span><em>dest</em>, <em>src</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.copy!\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Copy all elements from collection <code class=\"docutils literal\"><span class=\"pre\">src</span></code> to array <code class=\"docutils literal\"><span class=\"pre\">dest</span></code>. Returns <code class=\"docutils literal\"><span class=\"pre\">dest</span></code>.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt>\n<code class=\"descname\">copy!</code><span class=\"sig-paren\">(</span><em>dest</em>, <em>do</em>, <em>src</em>, <em>so</em>, <em>N</em><span class=\"sig-paren\">)</span></dt>\n<dd><p>Copy <code class=\"docutils literal\"><span class=\"pre\">N</span></code> elements from collection <code class=\"docutils literal\"><span class=\"pre\">src</span></code> starting at offset <code class=\"docutils literal\"><span class=\"pre\">so</span></code>, to array <code class=\"docutils literal\"><span class=\"pre\">dest</span></code> starting at offset <code class=\"docutils literal\"><span class=\"pre\">do</span></code>. Returns <code class=\"docutils literal\"><span class=\"pre\">dest</span></code>.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.pointer\">\n<code class=\"descname\">pointer</code><span class=\"sig-paren\">(</span><em>array</em><span class=\"optional\">[</span>, <em>index</em><span class=\"optional\">]</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.pointer\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Get the native address of an array or string element. Be careful to ensure that a Julia reference to <code class=\"docutils literal\"><span class=\"pre\">a</span></code> exists as long as this pointer will be used. This function is &#8220;unsafe&#8221; like <code class=\"docutils literal\"><span class=\"pre\">unsafe_convert</span></code>.</p>\n<p>Calling <code class=\"docutils literal\"><span class=\"pre\">Ref(array[,</span> <span class=\"pre\">index])</span></code> is generally preferable to this function.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.unsafe_wrap\">\n<code class=\"descname\">unsafe_wrap</code><span class=\"sig-paren\">(</span><em>Array</em>, <em>pointer::Ptr{T}</em>, <em>dims</em>, <em>own=false</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.unsafe_wrap\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Wrap a Julia <code class=\"docutils literal\"><span class=\"pre\">Array</span></code> object around the data at the address given by <code class=\"docutils literal\"><span class=\"pre\">pointer</span></code>, without making a copy.  The pointer element type <code class=\"docutils literal\"><span class=\"pre\">T</span></code> determines the array element type. <code class=\"docutils literal\"><span class=\"pre\">dims</span></code> is either an integer (for a 1d array) or a tuple of the array dimensions. <code class=\"docutils literal\"><span class=\"pre\">own</span></code> optionally specifies whether Julia should take ownership of the memory, calling <code class=\"docutils literal\"><span class=\"pre\">free</span></code> on the pointer when the array is no longer referenced.</p>\n<p>This function is labelled &#8220;unsafe&#8221; because it will crash if <code class=\"docutils literal\"><span class=\"pre\">pointer</span></code> is not a valid memory address to data of the requested length.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.pointer_from_objref\">\n<code class=\"descname\">pointer_from_objref</code><span class=\"sig-paren\">(</span><em>object_instance</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.pointer_from_objref\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Get the memory address of a Julia object as a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code>. The existence of the resulting <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> will be used.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.unsafe_pointer_to_objref\">\n<code class=\"descname\">unsafe_pointer_to_objref</code><span class=\"sig-paren\">(</span><em>p::Ptr</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.unsafe_pointer_to_objref\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Convert a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered &#8220;unsafe&#8221; and should be used with care.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.disable_sigint\">\n<code class=\"descname\">disable_sigint</code><span class=\"sig-paren\">(</span><em>f::Function</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.disable_sigint\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Disable Ctrl-C handler during execution of a function on the current task, for calling external code that may call julia code that is not interrupt safe. Intended to be called using <code class=\"docutils literal\"><span class=\"pre\">do</span></code> block syntax as follows:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">disable_sigint</span><span class=\"p\">()</span> <span class=\"k\">do</span>\n    <span class=\"c\"># interrupt-unsafe code</span>\n    <span class=\"o\">...</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n<p>This is not needed on worker threads (<code class=\"docutils literal\"><span class=\"pre\">Threads.threadid()</span> <span class=\"pre\">!=</span> <span class=\"pre\">1</span></code>) since the <code class=\"docutils literal\"><span class=\"pre\">InterruptException</span></code> will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.reenable_sigint\">\n<code class=\"descname\">reenable_sigint</code><span class=\"sig-paren\">(</span><em>f::Function</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.reenable_sigint\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Re-enable Ctrl-C handler during execution of a function. Temporarily reverses the effect of <code class=\"docutils literal\"><span class=\"pre\">disable_sigint</span></code>.</p>\n</dd></dl>\n\n<dl class=\"function\">\n<dt id=\"Base.systemerror\">\n<code class=\"descname\">systemerror</code><span class=\"sig-paren\">(</span><em>sysfunc</em>, <em>iftrue</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.systemerror\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Raises a <code class=\"docutils literal\"><span class=\"pre\">SystemError</span></code> for <code class=\"docutils literal\"><span class=\"pre\">errno</span></code> with the descriptive string <code class=\"docutils literal\"><span class=\"pre\">sysfunc</span></code> if <code class=\"docutils literal\"><span class=\"pre\">iftrue</span></code> is <code class=\"docutils literal\"><span class=\"pre\">true</span></code></p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Ptr{T}\">\n<code class=\"descname\">Ptr{T}</code><a class=\"headerlink\" href=\"#Base.Ptr{T}\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>A memory address referring to data of type <code class=\"docutils literal\"><span class=\"pre\">T</span></code>.  However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Ref{T}\">\n<code class=\"descname\">Ref{T}</code><a class=\"headerlink\" href=\"#Base.Ref{T}\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>An object that safely references data of type <code class=\"docutils literal\"><span class=\"pre\">T</span></code>. This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the <code class=\"docutils literal\"><span class=\"pre\">Ref</span></code> itself is referenced.</p>\n<p>When passed as a <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code> argument (either as a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> or <code class=\"docutils literal\"><span class=\"pre\">Ref</span></code> type), a <code class=\"docutils literal\"><span class=\"pre\">Ref</span></code> object will be converted to a native pointer to the data it references.</p>\n<p>There is no invalid (NULL) <code class=\"docutils literal\"><span class=\"pre\">Ref</span></code>.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cchar\">\n<code class=\"descname\">Cchar</code><a class=\"headerlink\" href=\"#Base.Cchar\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">char</span></code> c-type.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cuchar\">\n<code class=\"descname\">Cuchar</code><a class=\"headerlink\" href=\"#Base.Cuchar\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">char</span></code> c-type (<code class=\"docutils literal\"><span class=\"pre\">UInt8</span></code>).</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cshort\">\n<code class=\"descname\">Cshort</code><a class=\"headerlink\" href=\"#Base.Cshort\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">signed</span> <span class=\"pre\">short</span></code> c-type (<code class=\"docutils literal\"><span class=\"pre\">Int16</span></code>).</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cushort\">\n<code class=\"descname\">Cushort</code><a class=\"headerlink\" href=\"#Base.Cushort\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">short</span></code> c-type (<code class=\"docutils literal\"><span class=\"pre\">UInt16</span></code>).</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cint\">\n<code class=\"descname\">Cint</code><a class=\"headerlink\" href=\"#Base.Cint\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">signed</span> <span class=\"pre\">int</span></code> c-type (<code class=\"docutils literal\"><span class=\"pre\">Int32</span></code>).</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cuint\">\n<code class=\"descname\">Cuint</code><a class=\"headerlink\" href=\"#Base.Cuint\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">int</span></code> c-type (<code class=\"docutils literal\"><span class=\"pre\">UInt32</span></code>).</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Clong\">\n<code class=\"descname\">Clong</code><a class=\"headerlink\" href=\"#Base.Clong\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">signed</span> <span class=\"pre\">long</span></code> c-type.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Culong\">\n<code class=\"descname\">Culong</code><a class=\"headerlink\" href=\"#Base.Culong\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">long</span></code> c-type.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Clonglong\">\n<code class=\"descname\">Clonglong</code><a class=\"headerlink\" href=\"#Base.Clonglong\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">signed</span> <span class=\"pre\">long</span> <span class=\"pre\">long</span></code> c-type (<code class=\"docutils literal\"><span class=\"pre\">Int64</span></code>).</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Culonglong\">\n<code class=\"descname\">Culonglong</code><a class=\"headerlink\" href=\"#Base.Culonglong\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">long</span> <span class=\"pre\">long</span></code> c-type (<code class=\"docutils literal\"><span class=\"pre\">UInt64</span></code>).</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cintmax_t\">\n<code class=\"descname\">Cintmax_t</code><a class=\"headerlink\" href=\"#Base.Cintmax_t\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">intmax_t</span></code> c-type (<code class=\"docutils literal\"><span class=\"pre\">Int64</span></code>).</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cuintmax_t\">\n<code class=\"descname\">Cuintmax_t</code><a class=\"headerlink\" href=\"#Base.Cuintmax_t\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">uintmax_t</span></code> c-type (<code class=\"docutils literal\"><span class=\"pre\">UInt64</span></code>).</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Csize_t\">\n<code class=\"descname\">Csize_t</code><a class=\"headerlink\" href=\"#Base.Csize_t\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">size_t</span></code> c-type (<code class=\"docutils literal\"><span class=\"pre\">UInt</span></code>).</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cssize_t\">\n<code class=\"descname\">Cssize_t</code><a class=\"headerlink\" href=\"#Base.Cssize_t\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">ssize_t</span></code> c-type.</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cptrdiff_t\">\n<code class=\"descname\">Cptrdiff_t</code><a class=\"headerlink\" href=\"#Base.Cptrdiff_t\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">ptrdiff_t</span></code> c-type (<code class=\"docutils literal\"><span class=\"pre\">Int</span></code>).</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cwchar_t\">\n<code class=\"descname\">Cwchar_t</code><a class=\"headerlink\" href=\"#Base.Cwchar_t\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">wchar_t</span></code> c-type (<code class=\"docutils literal\"><span class=\"pre\">Int32</span></code>).</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cfloat\">\n<code class=\"descname\">Cfloat</code><a class=\"headerlink\" href=\"#Base.Cfloat\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">float</span></code> c-type (<code class=\"docutils literal\"><span class=\"pre\">Float32</span></code>).</p>\n</dd></dl>\n\n<dl class=\"data\">\n<dt id=\"Base.Cdouble\">\n<code class=\"descname\">Cdouble</code><a class=\"headerlink\" href=\"#Base.Cdouble\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Equivalent to the native <code class=\"docutils literal\"><span class=\"pre\">double</span></code> c-type (<code class=\"docutils literal\"><span class=\"pre\">Float64</span></code>).</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"llvm-interface\">\n<h1>LLVM Interface<a class=\"headerlink\" href=\"#llvm-interface\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<dl class=\"function\">\n<dt id=\"Base.llvmcall\">\n<code class=\"descname\">llvmcall</code><span class=\"sig-paren\">(</span><em>IR::String</em>, <em>ReturnType</em>, <em>(ArgumentType1</em>, <em>...)</em>, <em>ArgumentValue1</em>, <em>...</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#Base.llvmcall\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dt>\n<code class=\"descname\">llvmcall</code><span class=\"sig-paren\">(</span><em>(declarations::String</em>, <em>IR::String)</em>, <em>ReturnType</em>, <em>(ArgumentType1</em>, <em>...)</em>, <em>ArgumentValue1</em>, <em>...</em><span class=\"sig-paren\">)</span></dt>\n<dd><p>Call LLVM IR string in the first argument. Similar to an LLVM function <code class=\"docutils literal\"><span class=\"pre\">define</span></code> block, arguments are available as consecutive unnamed SSA variables (%0, %1, etc.).</p>\n<p>The optional declarations string contains external functions declarations that are necessary for llvm to compile the IR string. Multiple declarations can be passed in by separating them with line breaks.</p>\n<p>Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.</p>\n<p>Each <code class=\"docutils literal\"><span class=\"pre\">ArgumentValue</span></code> to <code class=\"docutils literal\"><span class=\"pre\">llvmcall</span></code> will be converted to the corresponding <code class=\"docutils literal\"><span class=\"pre\">ArgumentType</span></code>, by automatic insertion of calls to <code class=\"docutils literal\"><span class=\"pre\">unsafe_convert(ArgumentType,</span> <span class=\"pre\">cconvert(ArgumentType,</span> <span class=\"pre\">ArgumentValue))</span></code>. (see also the documentation for each of these functions for further details). In most cases, this simply results in a call to <code class=\"docutils literal\"><span class=\"pre\">convert(ArgumentType,</span> <span class=\"pre\">ArgumentValue)</span></code>.</p>\n<p>See <code class=\"docutils literal\"><span class=\"pre\">test/llvmcall.jl</span></code> for usage examples.</p>\n</dd></dl>\n\n</div>\n\n\n          </div>\n          <footer>\n  \n    <div class=\"rst-footer-buttons\" role=\"navigation\" aria-label=\"footer navigation\">\n      \n        <a href=\"libc.html\" class=\"btn btn-neutral float-right\" title=\"C Standard Library\">Next <span class=\"fa fa-arrow-circle-right\"></span></a>\n      \n      \n        <a href=\"test.html\" class=\"btn btn-neutral\" title=\"Unit Testing\"><span class=\"fa fa-arrow-circle-left\"></span> Previous</a>\n      \n    </div>\n  \n\n  <hr/>\n\n  <div role=\"contentinfo\">\n    <p>\n    </p>\n  </div>\n\n  <a href=\"https://github.com/snide/sphinx_rtd_theme\">Sphinx theme</a> provided by <a href=\"https://readthedocs.org\">Read the Docs</a>\n</footer>\n        </div>\n      </div>\n\n    </section>\n\n  </div>\n  \n\n  \n\n    <script type=\"text/javascript\">\n        var DOCUMENTATION_OPTIONS = {\n            URL_ROOT:'../',\n            VERSION:'0.5.1',\n            COLLAPSE_INDEX:false,\n            FILE_SUFFIX:'.html',\n            HAS_SOURCE:  true\n        };\n    </script>\n      <script type=\"text/javascript\" src=\"../_static/jquery.js\"></script>\n      <script type=\"text/javascript\" src=\"../_static/underscore.js\"></script>\n      <script type=\"text/javascript\" src=\"../_static/doctools.js\"></script>\n      <script type=\"text/javascript\" src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>\n\n  \n\n  \n  \n    <script type=\"text/javascript\" src=\"../_static/js/theme.js\"></script>\n  \n\n  \n  \n  <script type=\"text/javascript\">\n      jQuery(function () {\n          SphinxRtdTheme.StickyNav.enable();\n      });\n  </script>\n   \n\n</body>\n</html>",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/manual/calling-c-and-fortran-code.html": "\n\n<!DOCTYPE html>\n<!--[if IE 8]><html class=\"no-js lt-ie9\" lang=\"en\" > <![endif]-->\n<!--[if gt IE 8]><!--> <html class=\"no-js\" lang=\"en\" > <!--<![endif]-->\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  \n  <title>Calling C and Fortran Code &mdash; Julia Language 0.5.1 documentation</title>\n  \n\n  \n  \n\n  \n  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>\n\n  \n  \n    \n\n  \n\n  \n  \n    <link rel=\"stylesheet\" href=\"../_static/julia.css\" type=\"text/css\" />\n  \n\n  \n    <link rel=\"stylesheet\" href=\"../_static/julia.css\" type=\"text/css\" />\n  \n    <link rel=\"top\" title=\"Julia Language 0.5.1 documentation\" href=\"../index.html\"/>\n        <link rel=\"next\" title=\"Handling Operating System Variation\" href=\"handling-operating-system-variation.html\"/>\n        <link rel=\"prev\" title=\"Running External Programs\" href=\"running-external-programs.html\"/> \n\n  \n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js\"></script>\n\n</head>\n\n<body class=\"wy-body-for-nav\" role=\"document\">\n\n  <div class=\"wy-grid-for-nav\">\n\n    \n    <nav data-toggle=\"wy-nav-shift\" class=\"wy-nav-side\">\n      <div class=\"wy-side-nav-search\">\n        <a href=\"http://julialang.org/\"><img src=\"../_static/julia-logo.svg\" class=\"logo\"></a>\n        <!--\n        <a href=\"../index.html\" class=\"fa fa-home\"> Julia Language</a>\n        -->\n        <div role=\"search\">\n  <form id =\"rtd-search-form\" class=\"wy-form\" action=\"../search.html\" method=\"get\">\n    <input type=\"text\" name=\"q\" placeholder=\"Search docs\" />\n    <input type=\"hidden\" name=\"check_keywords\" value=\"yes\" />\n    <input type=\"hidden\" name=\"area\" value=\"default\" />\n  </form>\n</div>\n      </div>\n\n      <div class=\"wy-menu wy-menu-vertical\" data-spy=\"affix\" role=\"navigation\" aria-label=\"main navigation\">\n        \n        \n            <ul class=\"current\">\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"introduction.html\">Introduction</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"getting-started.html\">Getting Started</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"getting-started.html#resources\">Resources</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"variables.html\">Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"variables.html#allowed-variable-names\">Allowed Variable Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"variables.html#stylistic-conventions\">Stylistic Conventions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"integers-and-floating-point-numbers.html\">Integers and Floating-Point Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"integers-and-floating-point-numbers.html#integers\">Integers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"integers-and-floating-point-numbers.html#floating-point-numbers\">Floating-Point Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"integers-and-floating-point-numbers.html#arbitrary-precision-arithmetic\">Arbitrary Precision Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"integers-and-floating-point-numbers.html#numeric-literal-coefficients\">Numeric Literal Coefficients</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"integers-and-floating-point-numbers.html#literal-zero-and-one\">Literal zero and one</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"mathematical-operations.html\">Mathematical Operations and Elementary Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"mathematical-operations.html#arithmetic-operators\">Arithmetic Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"mathematical-operations.html#bitwise-operators\">Bitwise Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"mathematical-operations.html#updating-operators\">Updating operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"mathematical-operations.html#numeric-comparisons\">Numeric Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"mathematical-operations.html#numerical-conversions\">Numerical Conversions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"complex-and-rational-numbers.html\">Complex and Rational Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"complex-and-rational-numbers.html#complex-numbers\">Complex Numbers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"complex-and-rational-numbers.html#rational-numbers\">Rational Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"strings.html\">Strings</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#characters\">Characters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#string-basics\">String Basics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#unicode-and-utf-8\">Unicode and UTF-8</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#triple-quoted-string-literals\">Triple-Quoted String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#common-operations\">Common Operations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#regular-expressions\">Regular Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#id2\">Byte Array Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"strings.html#version-number-literals\">Version Number Literals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"functions.html\">Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#argument-passing-behavior\">Argument Passing Behavior</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#the-return-keyword\">The <code class=\"docutils literal\"><span class=\"pre\">return</span></code> Keyword</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#operators-are-functions\">Operators Are Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#operators-with-special-names\">Operators With Special Names</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#anonymous-functions\">Anonymous Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#multiple-return-values\">Multiple Return Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#varargs-functions\">Varargs Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#optional-arguments\">Optional Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#keyword-arguments\">Keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#evaluation-scope-of-default-values\">Evaluation Scope of Default Values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#do-block-syntax-for-function-arguments\">Do-Block Syntax for Function Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#dot-syntax-for-vectorizing-functions\">Dot Syntax for Vectorizing Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"functions.html#further-reading\">Further Reading</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"control-flow.html\">Control Flow</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"control-flow.html#compound-expressions\">Compound Expressions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"control-flow.html#conditional-evaluation\">Conditional Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"control-flow.html#short-circuit-evaluation\">Short-Circuit Evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"control-flow.html#repeated-evaluation-loops\">Repeated Evaluation: Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"control-flow.html#exception-handling\">Exception Handling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"control-flow.html#tasks-aka-coroutines\">Tasks (aka Coroutines)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"variables-and-scoping.html\">Scope of Variables</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"variables-and-scoping.html#global-scope\">Global Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"variables-and-scoping.html#local-scope\">Local Scope</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"variables-and-scoping.html#constants\">Constants</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"types.html\">Types</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#type-declarations\">Type Declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#abstract-types\">Abstract Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#bits-types\">Bits Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#composite-types\">Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#immutable-composite-types\">Immutable Composite Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#declared-types\">Declared Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#type-unions\">Type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#man-parametric-types\">Parametric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#type-aliases\">Type Aliases</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#operations-on-types\">Operations on Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#custom-pretty-printing\">Custom pretty-printing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#value-types\">&#8220;Value types&#8221;</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"types.html#nullable-types-representing-missing-values\">Nullable Types: Representing Missing Values</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"methods.html\">Methods</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#defining-methods\">Defining Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#method-ambiguities\">Method Ambiguities</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#parametric-methods\">Parametric Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#parametrically-constrained-varargs-methods\">Parametrically-constrained Varargs methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#note-on-optional-and-keyword-arguments\">Note on Optional and keyword Arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#function-like-objects\">Function-like objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"methods.html#empty-generic-functions\">Empty generic functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"constructors.html\">Constructors</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#outer-constructor-methods\">Outer Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#inner-constructor-methods\">Inner Constructor Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#incomplete-initialization\">Incomplete Initialization</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#parametric-constructors\">Parametric Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#case-study-rational\">Case Study: Rational</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#constructors-and-conversion\">Constructors and Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"constructors.html#outer-only-constructors\">Outer-only constructors</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"conversion-and-promotion.html\">Conversion and Promotion</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"conversion-and-promotion.html#conversion\">Conversion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"conversion-and-promotion.html#promotion\">Promotion</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"interfaces.html\">Interfaces</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interfaces.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interfaces.html#indexing\">Indexing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interfaces.html#abstract-arrays\">Abstract Arrays</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"modules.html\">Modules</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"modules.html#summary-of-module-usage\">Summary of module usage</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"documentation.html\">Documentation</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"documentation.html#accessing-documentation\">Accessing Documentation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"documentation.html#functions-methods\">Functions &amp; Methods</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"documentation.html#advanced-usage\">Advanced Usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"documentation.html#syntax-guide\">Syntax Guide</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"documentation.html#markdown-syntax\">Markdown syntax</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"documentation.html#markdown-syntax-extensions\">Markdown Syntax Extensions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"metaprogramming.html\">Metaprogramming</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"metaprogramming.html#program-representation\">Program representation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"metaprogramming.html#expressions-and-evaluation\">Expressions and evaluation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"metaprogramming.html#macros\">Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"metaprogramming.html#code-generation\">Code Generation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"metaprogramming.html#non-standard-string-literals\">Non-Standard String Literals</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"metaprogramming.html#generated-functions\">Generated functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"arrays.html\">Multi-dimensional Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#arrays\">Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"arrays.html#sparse-matrices\">Sparse Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"linear-algebra.html\">Linear algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linear-algebra.html#matrix-factorizations\">Matrix factorizations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"linear-algebra.html#special-matrices\">Special matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"networking-and-streams.html\">Networking and Streams</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"networking-and-streams.html#basic-stream-i-o\">Basic Stream I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"networking-and-streams.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"networking-and-streams.html#io-output-contextual-properties\">IO Output Contextual Properties</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"networking-and-streams.html#working-with-files\">Working with Files</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"networking-and-streams.html#a-simple-tcp-example\">A simple TCP example</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"networking-and-streams.html#resolving-ip-addresses\">Resolving IP Addresses</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"parallel-computing.html\">Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#code-availability-and-loading-packages\">Code Availability and Loading Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#data-movement\">Data Movement</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#parallel-map-and-loops\">Parallel Map and Loops</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#synchronization-with-remote-references\">Synchronization With Remote References</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#scheduling\">Scheduling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#channels\">Channels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#remote-references-and-abstractchannels\">Remote references and AbstractChannels</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#remote-references-and-distributed-garbage-collection\">Remote References and Distributed Garbage Collection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#id2\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#shared-arrays-and-distributed-garbage-collection\">Shared Arrays and Distributed Garbage Collection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#clustermanagers\">ClusterManagers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#cluster-managers-with-custom-transports\">Cluster Managers with custom transports</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#network-requirements-for-localmanager-and-sshmanager\">Network requirements for LocalManager and SSHManager</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#cluster-cookie\">Cluster cookie</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#specifying-network-topology-experimental\">Specifying network topology (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#multi-threading-experimental\">Multi-threading (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"parallel-computing.html#threadcall-experimental\">&#64;threadcall (Experimental)</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"dates.html\">Date and DateTime</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#durations-comparisons\">Durations/Comparisons</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#accessor-functions\">Accessor Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#query-functions\">Query Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#timetype-period-arithmetic\">TimeType-Period Arithmetic</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#adjuster-functions\">Adjuster Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#period-types\">Period Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"dates.html#rounding\">Rounding</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"running-external-programs.html\">Running External Programs</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"running-external-programs.html#interpolation\">Interpolation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"running-external-programs.html#quoting\">Quoting</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"running-external-programs.html#pipelines\">Pipelines</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1 current\"><a class=\"current reference internal\" href=\"#\">Calling C and Fortran Code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#creating-c-compatible-julia-function-pointers\">Creating C-Compatible Julia Function Pointers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#mapping-c-types-to-julia\">Mapping C Types to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#mapping-c-functions-to-julia\">Mapping C Functions to Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#some-examples-of-c-wrappers\">Some Examples of C Wrappers</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#garbage-collection-safety\">Garbage Collection Safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#non-constant-function-specifications\">Non-constant Function Specifications</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#indirect-calls\">Indirect Calls</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#calling-convention\">Calling Convention</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#accessing-global-variables\">Accessing Global Variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#accessing-data-through-a-pointer\">Accessing Data through a Pointer</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#thread-safety\">Thread-safety</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#more-about-callbacks\">More About Callbacks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"#c\">C++</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"handling-operating-system-variation.html\">Handling Operating System Variation</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"interacting-with-julia.html\">Interacting With Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interacting-with-julia.html#the-different-prompt-modes\">The different prompt modes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interacting-with-julia.html#key-bindings\">Key bindings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interacting-with-julia.html#tab-completion\">Tab completion</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"interacting-with-julia.html#customizing-colors\">Customizing Colors</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"embedding.html\">Embedding Julia</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"embedding.html#high-level-embedding\">High-Level Embedding</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"embedding.html#converting-types\">Converting Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"embedding.html#calling-julia-functions\">Calling Julia Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"embedding.html#memory-management\">Memory Management</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"embedding.html#working-with-arrays\">Working with Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"embedding.html#exceptions\">Exceptions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"packages.html\">Packages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#package-status\">Package Status</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#adding-and-removing-packages\">Adding and Removing Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#offline-installation-of-packages\">Offline Installation of Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#installing-unregistered-packages\">Installing Unregistered Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#updating-packages\">Updating Packages</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#checkout-pin-and-free\">Checkout, Pin and Free</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#custom-metadata-repository\">Custom METADATA Repository</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"packages.html#package-development\">Package Development</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#initial-setup\">Initial Setup</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#making-changes-to-an-existing-package\">Making changes to an existing package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#creating-a-new-package\">Creating a new Package</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#fixing-package-requirements\">Fixing Package Requirements</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"packages.html#man-package-requirements\">Requirements Specification</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"profile.html\">Profiling</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"profile.html#basic-usage\">Basic usage</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"profile.html#accumulation-and-clearing\">Accumulation and clearing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"profile.html#options-for-controlling-the-display-of-profile-results\">Options for controlling the display of profile results</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"profile.html#configuration\">Configuration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"profile.html#memory-allocation-analysis\">Memory allocation analysis</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"stacktraces.html\">Stack Traces</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stacktraces.html#viewing-a-stack-trace\">Viewing a stack trace</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stacktraces.html#extracting-useful-information\">Extracting useful information</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stacktraces.html#error-handling\">Error handling</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"stacktraces.html#comparison-with-backtrace\">Comparison with <code class=\"docutils literal\"><span class=\"pre\">backtrace()</span></code></a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"performance-tips.html\">Performance Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#avoid-global-variables\">Avoid global variables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#measure-performance-with-time-and-pay-attention-to-memory-allocation\">Measure performance with <code class=\"docutils literal\"><span class=\"pre\">&#64;time</span></code> and pay attention to memory allocation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#tools\">Tools</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#avoid-containers-with-abstract-type-parameters\">Avoid containers with abstract type parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#type-declarations\">Type declarations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#break-functions-into-multiple-definitions\">Break functions into multiple definitions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#write-type-stable-functions\">Write &#8220;type-stable&#8221; functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#avoid-changing-the-type-of-a-variable\">Avoid changing the type of a variable</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#separate-kernel-functions-aka-function-barriers\">Separate kernel functions (aka, function barriers)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#types-with-values-as-parameters\">Types with values-as-parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#the-dangers-of-abusing-multiple-dispatch-aka-more-on-types-with-values-as-parameters\">The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#access-arrays-in-memory-order-along-columns\">Access arrays in memory order, along columns</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#pre-allocating-outputs\">Pre-allocating outputs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#avoid-string-interpolation-for-i-o\">Avoid string interpolation for I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#optimize-network-i-o-during-parallel-execution\">Optimize network I/O during parallel execution</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#fix-deprecation-warnings\">Fix deprecation warnings</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#tweaks\">Tweaks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#performance-annotations\">Performance Annotations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#treat-subnormal-numbers-as-zeros\">Treat Subnormal Numbers as Zeros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"performance-tips.html#code-warntype\"><code class=\"docutils literal\"><span class=\"pre\">&#64;code_warntype</span></code></a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"workflow-tips.html\">Workflow Tips</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"workflow-tips.html#repl-based-workflow\">REPL-based workflow</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"workflow-tips.html#browser-based-workflow\">Browser-based workflow</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"style-guide.html\">Style Guide</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#write-functions-not-just-scripts\">Write functions, not just scripts</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#avoid-writing-overly-specific-types\">Avoid writing overly-specific types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#handle-excess-argument-diversity-in-the-caller\">Handle excess argument diversity in the caller</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#append-to-names-of-functions-that-modify-their-arguments\">Append <code class=\"docutils literal\"><span class=\"pre\">!</span></code> to names of functions that modify their arguments</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#avoid-strange-type-unions\">Avoid strange type Unions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#avoid-type-unions-in-fields\">Avoid type Unions in fields</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#avoid-elaborate-container-types\">Avoid elaborate container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#use-naming-conventions-consistent-with-julia-s-base\">Use naming conventions consistent with Julia&#8217;s <code class=\"docutils literal\"><span class=\"pre\">base/</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-overuse-try-catch\">Don&#8217;t overuse try-catch</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-parenthesize-conditions\">Don&#8217;t parenthesize conditions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-overuse\">Don&#8217;t overuse ...</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-use-unnecessary-static-parameters\">Don&#8217;t use unnecessary static parameters</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#avoid-confusion-about-whether-something-is-an-instance-or-a-type\">Avoid confusion about whether something is an instance or a type</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-overuse-macros\">Don&#8217;t overuse macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-expose-unsafe-operations-at-the-interface-level\">Don&#8217;t expose unsafe operations at the interface level</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#don-t-overload-methods-of-base-container-types\">Don&#8217;t overload methods of base container types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#be-careful-with-type-equality\">Be careful with type equality</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#do-not-write-x-f-x\">Do not write <code class=\"docutils literal\"><span class=\"pre\">x-&gt;f(x)</span></code></a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"style-guide.html#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible\">Avoid using floats for numeric literals in generic code when possible</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"faq.html\">Frequently Asked Questions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#sessions-and-the-repl\">Sessions and the REPL</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#functions\">Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#types-type-declarations-and-constructors\">Types, type declarations, and constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#packages-and-modules\">Packages and Modules</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#nothingness-and-missing-values\">Nothingness and missing values</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#memory\">Memory</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#asynchronous-io-and-concurrent-synchronous-writes\">Asynchronous IO and concurrent synchronous writes</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"faq.html#julia-releases\">Julia Releases</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"noteworthy-differences.html\">Noteworthy Differences from other Languages</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"noteworthy-differences.html#noteworthy-differences-from-matlab\">Noteworthy differences from MATLAB</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"noteworthy-differences.html#noteworthy-differences-from-r\">Noteworthy differences from R</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"noteworthy-differences.html#noteworthy-differences-from-python\">Noteworthy differences from Python</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"noteworthy-differences.html#noteworthy-differences-from-c-c\">Noteworthy differences from C/C++</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"unicode-input.html\">Unicode Input</a></li>\n</ul>\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/base.html\">Essentials</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#introduction\">Introduction</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#getting-around\">Getting Around</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#all-objects\">All Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#types\">Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#generic-functions\">Generic Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#syntax\">Syntax</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#nullables\">Nullables</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#system\">System</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#errors\">Errors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#events\">Events</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#reflection\">Reflection</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/base.html#internals\">Internals</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/collections.html\">Collections and Data Structures</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#iteration\">Iteration</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#general-collections\">General Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#iterable-collections\">Iterable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#indexable-collections\">Indexable Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#associative-collections\">Associative Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#set-like-collections\">Set-Like Collections</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#dequeues\">Dequeues</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#priorityqueue\">PriorityQueue</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/collections.html#heap-functions\">Heap Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/math.html\">Mathematics</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/math.html#mathematical-operators\">Mathematical Operators</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/math.html#mathematical-functions\">Mathematical Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/math.html#statistics\">Statistics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/math.html#signal-processing\">Signal Processing</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/math.html#numerical-integration\">Numerical Integration</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/numbers.html\">Numbers</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/numbers.html#standard-numeric-types\">Standard Numeric Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/numbers.html#data-formats\">Data Formats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/numbers.html#general-number-functions-and-constants\">General Number Functions and Constants</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/numbers.html#bigfloats\">BigFloats</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/numbers.html#random-numbers\">Random Numbers</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/strings.html\">Strings</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/arrays.html\">Arrays</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#basic-functions\">Basic functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#constructors\">Constructors</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#mathematical-operators-and-functions\">Mathematical operators and functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#indexing-assignment-and-concatenation\">Indexing, Assignment, and Concatenation</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#array-functions\">Array functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#combinatorics\">Combinatorics</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#bitarrays\">BitArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/arrays.html#sparse-vectors-and-matrices\">Sparse Vectors and Matrices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/parallel.html\">Tasks and Parallel Computing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/parallel.html#tasks\">Tasks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/parallel.html#general-parallel-computing-support\">General Parallel Computing Support</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/parallel.html#shared-arrays\">Shared Arrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/parallel.html#multi-threading\">Multi-Threading</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/parallel.html#ccall-using-a-threadpool-experimental\">ccall using a threadpool (Experimental)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/parallel.html#synchronization-primitives\">Synchronization Primitives</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/parallel.html#cluster-manager-interface\">Cluster Manager Interface</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/linalg.html\">Linear Algebra</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/linalg.html#module-Base.LinAlg\">Standard Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/linalg.html#low-level-matrix-operations\">Low-level matrix operations</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/linalg.html#module-Base.LinAlg.BLAS\">BLAS Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/linalg.html#module-Base.LinAlg.LAPACK\">LAPACK Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/constants.html\">Constants</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/file.html\">Filesystem</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/io-network.html\">I/O and Network</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/io-network.html#general-i-o\">General I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/io-network.html#text-i-o\">Text I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/io-network.html#multimedia-i-o\">Multimedia I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/io-network.html#memory-mapped-i-o\">Memory-mapped I/O</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/io-network.html#network-i-o\">Network I/O</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/punctuation.html\">Punctuation</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/sort.html\">Sorting and Related Functions</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/sort.html#sorting-functions\">Sorting Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/sort.html#order-related-functions\">Order-Related Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/sort.html#sorting-algorithms\">Sorting Algorithms</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/pkg.html\">Package Manager Functions</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/dates.html\">Dates and Time</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/dates.html#dates-and-time-types\">Dates and Time Types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/dates.html#dates-functions\">Dates Functions</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/test.html\">Unit Testing</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/test.html#testing-base-julia\">Testing Base Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/test.html#basic-unit-tests\">Basic Unit Tests</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/test.html#working-with-test-sets\">Working with Test Sets</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/test.html#other-test-macros\">Other Test Macros</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/test.html#broken-tests\">Broken Tests</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../stdlib/test.html#creating-custom-abstracttestset-types\">Creating Custom <code class=\"docutils literal\"><span class=\"pre\">AbstractTestSet</span></code> Types</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/c.html\">C Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/c.html#llvm-interface\">LLVM Interface</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/libc.html\">C Standard Library</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/libdl.html\">Dynamic Linker</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/profile.html\">Profiling</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/stacktraces.html\">StackTraces</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../stdlib/simd-types.html\">SIMD Support</a></li>\n</ul>\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/reflection.html\">Reflection and introspection</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/julia.html\">Documentation of Julia&#8217;s Internals</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/init.html\">Initialization of the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/eval.html\">Eval of Julia code</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/ast.html\">Julia ASTs</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/types.html\">More about types</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/object.html\">Memory layout of Julia Objects</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/functions.html\">Julia Functions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/callconv.html\">Calling Conventions</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/cartesian.html\">Base.Cartesian</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/meta.html\">Talking to the compiler (the <code class=\"docutils literal\"><span class=\"pre\">:meta</span></code> mechanism)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/subarrays.html\">SubArrays</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/sysimg.html\">System Image Building</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/llvm.html\">Working with LLVM</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/stdio.html\">printf() and stdio in the Julia runtime</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/boundscheck.html\">Bounds checking</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/locks.html\">Proper maintenance and care of multi-threading locks</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/offset-arrays.html\">Arrays with custom indices</a></li>\n</ul>\n</li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"../devdocs/C.html\">Developing/debugging Julia&#8217;s C code</a><ul>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/backtraces.html\">Reporting and analyzing crashes (segfaults)</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/debuggingtips.html\">gdb debugging tips</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/valgrind.html\">Using Valgrind with Julia</a></li>\n<li class=\"toctree-l2\"><a class=\"reference internal\" href=\"../devdocs/sanitizers.html\">Sanitizer support</a></li>\n</ul>\n</li>\n</ul>\n\n        \n      </div>\n      &nbsp;\n    </nav>\n\n    <section data-toggle=\"wy-nav-shift\" class=\"wy-nav-content-wrap\">\n\n      \n      <nav class=\"wy-nav-top\" role=\"navigation\" aria-label=\"top navigation\">\n        <i data-toggle=\"wy-nav-top\" class=\"fa fa-bars\"></i>\n        <a href=\"../index.html\">Julia Language</a>\n      </nav>\n\n\n      \n      <div class=\"wy-nav-content\">\n        <div class=\"rst-content\">\n          <div role=\"navigation\" aria-label=\"breadcrumbs navigation\">\n  <ul class=\"wy-breadcrumbs\">\n    <li><a href=\"../index.html\">Docs</a> &raquo;</li>\n      \n    <li>Calling C and Fortran Code</li>\n      <li class=\"wy-breadcrumbs-aside\">\n        \n          <a href=\"../_sources/manual/calling-c-and-fortran-code.txt\" rel=\"nofollow\"> View page source</a>\n        \n      </li>\n  </ul>\n  <hr/>\n</div>\n          <div role=\"main\" class=\"document\">\n            \n  <div class=\"section\" id=\"calling-c-and-fortran-code\">\n<span id=\"man-calling-c-and-fortran-code\"></span><h1>Calling C and Fortran Code<a class=\"headerlink\" href=\"#calling-c-and-fortran-code\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<p>Though most code can be written in Julia, there are many high-quality,\nmature libraries for numerical computing already written in C and\nFortran. To allow easy use of this existing code, Julia makes it simple\nand efficient to call C and Fortran functions. Julia has a &#8220;no\nboilerplate&#8221; philosophy: functions can be called directly from Julia\nwithout any &#8220;glue&#8221; code, code generation, or compilation \u2014 even from the\ninteractive prompt. This is accomplished just by making an appropriate call\nwith <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> syntax, which looks like an ordinary function call.</p>\n<p>The code to be called must be available as a shared library. Most C and\nFortran libraries ship compiled as shared libraries already, but if you\nare compiling the code yourself using GCC (or Clang), you will need to\nuse the <code class=\"docutils literal\"><span class=\"pre\">-shared</span></code> and <code class=\"docutils literal\"><span class=\"pre\">-fPIC</span></code> options. The machine instructions\ngenerated by Julia&#8217;s JIT are the same as a native C call would be, so\nthe resulting overhead is the same as calling a library function from C\ncode. (Non-library function calls in both C and Julia can be inlined and\nthus may have even less overhead than calls to shared library functions.\nWhen both libraries and executables are generated by LLVM, it is\npossible to perform whole-program optimizations that can even optimize\nacross this boundary, but Julia does not yet support that. In the\nfuture, however, it may do so, yielding even greater performance gains.)</p>\n<p>Shared libraries and functions are referenced by a tuple of the\nform <code class=\"docutils literal\"><span class=\"pre\">(:function,</span> <span class=\"pre\">&quot;library&quot;)</span></code> or <code class=\"docutils literal\"><span class=\"pre\">(&quot;function&quot;,</span> <span class=\"pre\">&quot;library&quot;)</span></code> where <code class=\"docutils literal\"><span class=\"pre\">function</span></code>\nis the C-exported function name. <code class=\"docutils literal\"><span class=\"pre\">library</span></code> refers to the shared library\nname: shared libraries available in the (platform-specific) load path\nwill be resolved by name, and if necessary a direct path may be specified.</p>\n<p>A function name may be used alone in place of the tuple (just\n<code class=\"docutils literal\"><span class=\"pre\">:function</span></code> or <code class=\"docutils literal\"><span class=\"pre\">&quot;function&quot;</span></code>). In this case the name is resolved within\nthe current process. This form can be used to call C library functions,\nfunctions in the Julia runtime, or functions in an application linked to\nJulia.</p>\n<p>By default, Fortran compilers <a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Name_mangling#Fortran\">generate mangled names</a>\n(for example, converting function names to lowercase or uppercase,\noften appending an underscore), and so to call a Fortran function via\n<a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> you must pass the mangled identifier corresponding to the rule\nfollowed by your Fortran compiler.  Also, when calling a Fortran\nfunction, all inputs must be passed by reference.</p>\n<p>Finally, you can use <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> to actually generate a call to the\nlibrary function. Arguments to <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> are as follows:</p>\n<ol class=\"arabic simple\">\n<li>(:function, &#8220;library&#8221;) pair (must be a constant, but see below).</li>\n<li>Return type (see below for mapping the declared C type to Julia)<ul>\n<li>This argument will be evaluated at compile-time.</li>\n</ul>\n</li>\n<li>A tuple of input types. The input types must be written as a literal tuple,\nnot a tuple-valued variable or expression.<ul>\n<li>This argument will be evaluated at compile-time.</li>\n</ul>\n</li>\n<li>The following arguments, if any, are the actual argument values\npassed to the function.</li>\n</ol>\n<p>As a complete but simple example, the following calls the <code class=\"docutils literal\"><span class=\"pre\">clock</span></code>\nfunction from the standard C library:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"k\">ccall</span><span class=\"p\">(</span> <span class=\"p\">(</span><span class=\"o\">:</span><span class=\"n\">clock</span><span class=\"p\">,</span> <span class=\"s\">&quot;libc&quot;</span><span class=\"p\">),</span> <span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"p\">())</span>\n<span class=\"mi\">2292761</span>\n\n<span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">t</span>\n<span class=\"mi\">2292761</span>\n\n<span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">typeof</span><span class=\"p\">(</span><span class=\"n\">ans</span><span class=\"p\">)</span>\n<span class=\"kt\">Int32</span>\n</pre></div>\n</div>\n<p><code class=\"docutils literal\"><span class=\"pre\">clock</span></code> takes no arguments and returns an <code class=\"docutils literal\"><span class=\"pre\">Int32</span></code>. One common gotcha\nis that a 1-tuple must be written with a trailing comma. For\nexample, to call the <code class=\"docutils literal\"><span class=\"pre\">getenv</span></code> function to get a pointer to the value\nof an environment variable, one makes a call like this:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span>julia&gt; path = ccall((:getenv, &quot;libc&quot;), Cstring, (Cstring,), &quot;SHELL&quot;)\nCstring(@0x00007fff5fbffc45)\n\njulia&gt; unsafe_string(path)\n&quot;/bin/bash&quot;\n</pre></div>\n</div>\n<p>Note that the argument type tuple must be written as <code class=\"docutils literal\"><span class=\"pre\">(Cstring,)</span></code>,\nrather than <code class=\"docutils literal\"><span class=\"pre\">(Cstring)</span></code>. This is because <code class=\"docutils literal\"><span class=\"pre\">(Cstring)</span></code> is just\nthe expression <code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> surrounded by parentheses, rather than\na 1-tuple containing <code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code>:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Cstring</span><span class=\"p\">)</span>\n<span class=\"kt\">Cstring</span>\n\n<span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"p\">(</span><span class=\"kt\">Cstring</span><span class=\"p\">,)</span>\n<span class=\"p\">(</span><span class=\"kt\">Cstring</span><span class=\"p\">,)</span>\n</pre></div>\n</div>\n<p>In practice, especially when providing reusable functionality, one\ngenerally wraps <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> uses in Julia functions that set up arguments\nand then check for errors in whatever manner the C or Fortran function\nindicates them, propagating to the Julia caller as exceptions. This is\nespecially important since C and Fortran APIs are notoriously\ninconsistent about how they indicate error conditions. For example, the\n<code class=\"docutils literal\"><span class=\"pre\">getenv</span></code> C library function is wrapped in the following Julia function,\nwhich is a simplified version of the actual definition from\n<a class=\"reference external\" href=\"https://github.com/JuliaLang/julia/blob/release-0.5/base/env.jl\">env.jl</a>:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">function</span> <span class=\"n\">getenv</span><span class=\"p\">(</span><span class=\"n\">var</span><span class=\"o\">::</span><span class=\"kt\">AbstractString</span><span class=\"p\">)</span>\n  <span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"k\">ccall</span><span class=\"p\">((</span><span class=\"o\">:</span><span class=\"n\">getenv</span><span class=\"p\">,</span> <span class=\"s\">&quot;libc&quot;</span><span class=\"p\">),</span>\n              <span class=\"kt\">Cstring</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Cstring</span><span class=\"p\">,),</span> <span class=\"n\">var</span><span class=\"p\">)</span>\n  <span class=\"k\">if</span> <span class=\"n\">val</span> <span class=\"o\">==</span> <span class=\"nb\">C_NULL</span>\n    <span class=\"n\">error</span><span class=\"p\">(</span><span class=\"s\">&quot;getenv: undefined variable: &quot;</span><span class=\"p\">,</span> <span class=\"n\">var</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n  <span class=\"n\">unsafe_string</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n<p>The C <code class=\"docutils literal\"><span class=\"pre\">getenv</span></code> function indicates an error by returning <code class=\"docutils literal\"><span class=\"pre\">NULL</span></code>, but\nother standard C functions indicate errors in various different ways,\nincluding by returning -1, 0, 1 and other special values. This wrapper\nthrows an exception clearly indicating the problem if the caller tries\nto get a non-existent environment variable:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">getenv</span><span class=\"p\">(</span><span class=\"s\">&quot;SHELL&quot;</span><span class=\"p\">)</span>\n<span class=\"s\">&quot;/bin/bash&quot;</span>\n\n<span class=\"n\">julia</span><span class=\"o\">&gt;</span> <span class=\"n\">getenv</span><span class=\"p\">(</span><span class=\"s\">&quot;FOOBAR&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">getenv</span><span class=\"o\">:</span> <span class=\"n\">undefined</span> <span class=\"n\">variable</span><span class=\"o\">:</span> <span class=\"n\">FOOBAR</span>\n</pre></div>\n</div>\n<p>Here is a slightly more complex example that discovers the local\nmachine&#8217;s hostname:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">function</span> <span class=\"n\">gethostname</span><span class=\"p\">()</span>\n  <span class=\"n\">hostname</span> <span class=\"o\">=</span> <span class=\"kt\">Array</span><span class=\"p\">{</span><span class=\"kt\">UInt8</span><span class=\"p\">}(</span><span class=\"mi\">128</span><span class=\"p\">)</span>\n  <span class=\"k\">ccall</span><span class=\"p\">((</span><span class=\"o\">:</span><span class=\"n\">gethostname</span><span class=\"p\">,</span> <span class=\"s\">&quot;libc&quot;</span><span class=\"p\">),</span> <span class=\"kt\">Int32</span><span class=\"p\">,</span>\n        <span class=\"p\">(</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">UInt8</span><span class=\"p\">},</span> <span class=\"kt\">Csize_t</span><span class=\"p\">),</span>\n        <span class=\"n\">hostname</span><span class=\"p\">,</span> <span class=\"n\">sizeof</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"p\">))</span>\n  <span class=\"n\">hostname</span><span class=\"p\">[</span><span class=\"k\">end</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"c\"># ensure null-termination</span>\n  <span class=\"k\">return</span> <span class=\"n\">unsafe_string</span><span class=\"p\">(</span><span class=\"n\">pointer</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"p\">))</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n<p>This example first allocates an array of bytes, then calls the C library\nfunction <code class=\"docutils literal\"><span class=\"pre\">gethostname</span></code> to fill the array in with the hostname, takes a\npointer to the hostname buffer, and converts the pointer to a Julia\nstring, assuming that it is a NUL-terminated C string. It is common for\nC libraries to use this pattern of requiring the caller to allocate\nmemory to be passed to the callee and filled in. Allocation of memory\nfrom Julia like this is generally accomplished by creating an\nuninitialized array and passing a pointer to its data to the C function.\nThis is why we don&#8217;t use the <code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> type here: as the array is\nuninitialized, it could contain NUL bytes. Converting to a <code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> as\npart of the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> checks for contained NUL bytes and could therefore\nthrow a conversion error.</p>\n<div class=\"section\" id=\"creating-c-compatible-julia-function-pointers\">\n<h2>Creating C-Compatible Julia Function Pointers<a class=\"headerlink\" href=\"#creating-c-compatible-julia-function-pointers\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>It is possible to pass Julia functions to native C functions that accept\nfunction pointer arguments. For example, to match C prototypes of the form:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">typedef</span> <span class=\"n\">returntype</span> <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">functiontype</span><span class=\"p\">)(</span><span class=\"n\">argumenttype</span><span class=\"p\">,</span><span class=\"o\">...</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>The function <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cfunction\" title=\"Base.cfunction\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cfunction()</span></code></a> generates the C-compatible function pointer for\na call to a Julia library function.\nArguments to <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cfunction\" title=\"Base.cfunction\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cfunction()</span></code></a> are as follows:</p>\n<ol class=\"arabic simple\">\n<li>A Julia Function</li>\n<li>Return type</li>\n<li>A tuple of input types</li>\n</ol>\n<p>A classic example is the standard C library <code class=\"docutils literal\"><span class=\"pre\">qsort</span></code> function,\ndeclared as:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">void</span> <span class=\"n\">qsort</span><span class=\"p\">(</span><span class=\"n\">void</span> <span class=\"o\">*</span><span class=\"n\">base</span><span class=\"p\">,</span> <span class=\"n\">size_t</span> <span class=\"n\">nmemb</span><span class=\"p\">,</span> <span class=\"n\">size_t</span> <span class=\"n\">size</span><span class=\"p\">,</span>\n           <span class=\"n\">int</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">compare</span><span class=\"p\">)(</span><span class=\"kd\">const</span> <span class=\"n\">void</span> <span class=\"o\">*</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"kd\">const</span> <span class=\"n\">void</span> <span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">));</span>\n</pre></div>\n</div>\n<p>The <code class=\"docutils literal\"><span class=\"pre\">base</span></code> argument is a pointer to an array of length <code class=\"docutils literal\"><span class=\"pre\">nmemb</span></code>, with elements of\n<code class=\"docutils literal\"><span class=\"pre\">size</span></code> bytes each. <code class=\"docutils literal\"><span class=\"pre\">compare</span></code> is a callback function which takes pointers to two\nelements <code class=\"docutils literal\"><span class=\"pre\">a</span></code> and <code class=\"docutils literal\"><span class=\"pre\">b</span></code> and returns an integer less/greater than zero if <code class=\"docutils literal\"><span class=\"pre\">a</span></code> should\nappear before/after <code class=\"docutils literal\"><span class=\"pre\">b</span></code> (or zero if any order is permitted). Now, suppose that we\nhave a 1d array <code class=\"docutils literal\"><span class=\"pre\">A</span></code> of values in Julia that we want to sort using the <code class=\"docutils literal\"><span class=\"pre\">qsort</span></code>\nfunction (rather than Julia&#8217;s built-in <code class=\"docutils literal\"><span class=\"pre\">sort</span></code> function). Before we worry about calling\n<code class=\"docutils literal\"><span class=\"pre\">qsort</span></code> and passing arguments, we need to write a comparison function that works for\nsome arbitrary type T:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">function</span> <span class=\"n\">mycompare</span><span class=\"p\">{</span><span class=\"n\">T</span><span class=\"p\">}(</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">::</span><span class=\"n\">T</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">convert</span><span class=\"p\">(</span><span class=\"kt\">Cint</span><span class=\"p\">,</span> <span class=\"n\">a</span> <span class=\"o\">&lt;</span> <span class=\"n\">b</span> <span class=\"o\">?</span> <span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"o\">&gt;</span> <span class=\"n\">b</span> <span class=\"o\">?</span> <span class=\"o\">+</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"o\">::</span><span class=\"kt\">Cint</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n<p>Notice that we have to be careful about the return type: <code class=\"docutils literal\"><span class=\"pre\">qsort</span></code> expects a function\nreturning a C <code class=\"docutils literal\"><span class=\"pre\">int</span></code>, so we must be sure to return <code class=\"docutils literal\"><span class=\"pre\">Cint</span></code> via a call to <code class=\"docutils literal\"><span class=\"pre\">convert</span></code>\nand a <code class=\"docutils literal\"><span class=\"pre\">typeassert</span></code>.</p>\n<p>In order to pass this function to C, we obtain its address using the function <code class=\"docutils literal\"><span class=\"pre\">cfunction</span></code>:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"kd\">const</span> <span class=\"n\">mycompare_c</span> <span class=\"o\">=</span> <span class=\"n\">cfunction</span><span class=\"p\">(</span><span class=\"n\">mycompare</span><span class=\"p\">,</span> <span class=\"kt\">Cint</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Ref</span><span class=\"p\">{</span><span class=\"kt\">Cdouble</span><span class=\"p\">},</span> <span class=\"kt\">Ref</span><span class=\"p\">{</span><span class=\"kt\">Cdouble</span><span class=\"p\">}))</span>\n</pre></div>\n</div>\n<p><a class=\"reference internal\" href=\"../stdlib/c.html#Base.cfunction\" title=\"Base.cfunction\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cfunction()</span></code></a> accepts three arguments: the Julia function (<code class=\"docutils literal\"><span class=\"pre\">mycompare</span></code>),\nthe return type (<code class=\"docutils literal\"><span class=\"pre\">Cint</span></code>), and a tuple of the argument types, in this case to\nsort an array of <code class=\"docutils literal\"><span class=\"pre\">Cdouble</span></code> (<code class=\"docutils literal\"><span class=\"pre\">Float64</span></code>) elements.</p>\n<p>The final call to <code class=\"docutils literal\"><span class=\"pre\">qsort</span></code> looks like this:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">1.3</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">2.7</span><span class=\"p\">,</span> <span class=\"mf\">4.4</span><span class=\"p\">,</span> <span class=\"mf\">3.1</span><span class=\"p\">]</span>\n<span class=\"k\">ccall</span><span class=\"p\">(</span><span class=\"o\">:</span><span class=\"n\">qsort</span><span class=\"p\">,</span> <span class=\"kt\">Void</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Cdouble</span><span class=\"p\">},</span> <span class=\"kt\">Csize_t</span><span class=\"p\">,</span> <span class=\"kt\">Csize_t</span><span class=\"p\">,</span> <span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Void</span><span class=\"p\">}),</span>\n      <span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">),</span> <span class=\"n\">sizeof</span><span class=\"p\">(</span><span class=\"n\">eltype</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)),</span> <span class=\"n\">mycompare_c</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>After this executes, <code class=\"docutils literal\"><span class=\"pre\">A</span></code> is changed to the sorted array <code class=\"docutils literal\"><span class=\"pre\">[-2.7,</span> <span class=\"pre\">1.3,</span> <span class=\"pre\">3.1,</span> <span class=\"pre\">4.4]</span></code>.\nNote that Julia knows how to convert an array into a <code class=\"docutils literal\"><span class=\"pre\">Ptr{Cdouble}</span></code>, how to compute\nthe size of a type in bytes (identical to C&#8217;s <code class=\"docutils literal\"><span class=\"pre\">sizeof</span></code> operator), and so on.\nFor fun, try inserting a <code class=\"docutils literal\"><span class=\"pre\">println(&quot;mycompare($a,$b)&quot;)</span></code> line into <code class=\"docutils literal\"><span class=\"pre\">mycompare</span></code>, which\nwill allow you to see the comparisons that <code class=\"docutils literal\"><span class=\"pre\">qsort</span></code> is performing (and to verify that\nit is really calling the Julia function that you passed to it).</p>\n</div>\n<div class=\"section\" id=\"mapping-c-types-to-julia\">\n<h2>Mapping C Types to Julia<a class=\"headerlink\" href=\"#mapping-c-types-to-julia\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>It is critical to exactly match the declared C type with its declaration\nin Julia. Inconsistencies can cause code that works correctly on one system\nto fail or produce indeterminate results on a different system.</p>\n<p>Note that no C header files are used anywhere in the process of calling C\nfunctions: you are responsible for making sure that your Julia types and\ncall signatures accurately reflect those in the C header file. (The <a class=\"reference external\" href=\"https://github.com/ihnorton/Clang.jl\">Clang\npackage</a> can be used to auto-generate\nJulia code from a C header file.)</p>\n<div class=\"section\" id=\"auto-conversion\">\n<h3>Auto-conversion:<a class=\"headerlink\" href=\"#auto-conversion\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>Julia automatically inserts calls to the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cconvert\" title=\"Base.cconvert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cconvert()</span></code></a> function to convert\neach argument to the specified type. For example, the following call:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">ccall</span><span class=\"p\">((</span><span class=\"o\">:</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"s\">&quot;libfoo&quot;</span><span class=\"p\">),</span> <span class=\"kt\">Void</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"kt\">Float64</span><span class=\"p\">),</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>will behave as if the following were written:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">ccall</span><span class=\"p\">((</span><span class=\"o\">:</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"s\">&quot;libfoo&quot;</span><span class=\"p\">),</span> <span class=\"kt\">Void</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"kt\">Float64</span><span class=\"p\">),</span>\n      <span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">unsafe_convert</span><span class=\"p\">(</span><span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">cconvert</span><span class=\"p\">(</span><span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">)),</span>\n      <span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">unsafe_convert</span><span class=\"p\">(</span><span class=\"kt\">Float64</span><span class=\"p\">,</span> <span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">cconvert</span><span class=\"p\">(</span><span class=\"kt\">Float64</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)))</span>\n</pre></div>\n</div>\n<p><a class=\"reference internal\" href=\"../stdlib/c.html#Base.cconvert\" title=\"Base.cconvert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cconvert()</span></code></a> normally just calls <a class=\"reference internal\" href=\"../stdlib/base.html#Base.convert\" title=\"Base.convert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">convert()</span></code></a>, but can be defined to return\nan arbitrary new object more appropriate for passing to C. For example,\nthis is used to convert an <code class=\"docutils literal\"><span class=\"pre\">Array</span></code> of objects (e.g. strings) to an\narray of pointers.</p>\n<p><a class=\"reference internal\" href=\"../stdlib/c.html#Base.unsafe_convert\" title=\"Base.unsafe_convert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">unsafe_convert()</span></code></a> handles conversion to <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> types. It is considered\nunsafe because converting an object to a native pointer can hide the object\nfrom the garbage collector, causing it to be freed prematurely.</p>\n</div>\n<div class=\"section\" id=\"type-correspondences\">\n<h3>Type Correspondences:<a class=\"headerlink\" href=\"#type-correspondences\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>First, a review of some relevant Julia type terminology:</p>\n<table border=\"1\" class=\"text-wrap docutils\">\n<colgroup>\n<col width=\"26%\" />\n<col width=\"26%\" />\n<col width=\"48%\" />\n</colgroup>\n<thead valign=\"bottom\">\n<tr class=\"row-odd\"><th class=\"head\">Syntax / Keyword</th>\n<th class=\"head\">Example</th>\n<th class=\"head\">Description</th>\n</tr>\n</thead>\n<tbody valign=\"top\">\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">type</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">String</span></code></td>\n<td>&#8220;Leaf Type&#8221; :: A group of related data that includes\na type-tag, is managed by the Julia GC, and\nis defined by object-identity.\nThe type parameters of a leaf type must be fully defined\n(no <code class=\"docutils literal\"><span class=\"pre\">TypeVars</span></code> are allowed)\nin order for the instance to be constructed.</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">abstract</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Any</span></code>,\n<code class=\"docutils literal\"><span class=\"pre\">AbstractArray{T,N}</span></code>,\n<code class=\"docutils literal\"><span class=\"pre\">Complex{T}</span></code></td>\n<td>&#8220;Super Type&#8221; :: A super-type (not a leaf-type)\nthat cannot be instantiated, but can be used to\ndescribe a group of types.</td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">{T}</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Vector{Int}</span></code></td>\n<td><p class=\"first\">&#8220;Type Parameter&#8221; :: A specialization of a type\n(typically used for dispatch or storage optimization).</p>\n<p class=\"last\">&#8220;TypeVar&#8221; :: The <code class=\"docutils literal\"><span class=\"pre\">T</span></code> in the type parameter declaration\nis referred to as a TypeVar (short for type variable).</p>\n</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">bitstype</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int</span></code>,\n<code class=\"docutils literal\"><span class=\"pre\">Float64</span></code></td>\n<td>&#8220;Bits Type&#8221; :: A type with no fields, but a size. It\nis stored and defined by-value.</td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">immutable</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">Pair{Int,Int}</span></code></p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">Complex128</span></code> (<code class=\"docutils literal\"><span class=\"pre\">isbits</span></code>)</p>\n</td>\n<td><p class=\"first\">&#8220;Immutable&#8221; :: A type with all fields defined to be\nconstant. It is defined by-value. And may be stored\nwith a type-tag.</p>\n<p class=\"last\">&#8220;Is-Bits&#8221; :: A <code class=\"docutils literal\"><span class=\"pre\">bitstype</span></code>, or an <code class=\"docutils literal\"><span class=\"pre\">immutable</span></code> type\nwhere all fields are other <code class=\"docutils literal\"><span class=\"pre\">isbits</span></code> types. It is\ndefined by-value, and is stored without a type-tag.</p>\n</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">type</span> <span class=\"pre\">...;</span> <span class=\"pre\">end</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">nothing</span></code></td>\n<td>&#8220;Singleton&#8221; :: a Leaf Type or Immutable with no fields.</td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">(...)</span></code> or <code class=\"docutils literal\"><span class=\"pre\">tuple(...)`</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">(1,2,3)</span></code></td>\n<td>&#8220;Tuple&#8221; :: an immutable data-structure similar to an\nanonymous immutable type, or a constant array.\nRepresented as either an array or a struct.</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">typealias</span></code></td>\n<td>Not applicable here</td>\n<td>Type aliases, and other similar mechanisms of\ndoing type indirection, are resolved to their base\ntype (this includes assigning a type to another name,\nor getting the type out of a function call).</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"bits-types\">\n<h3>Bits Types:<a class=\"headerlink\" href=\"#bits-types\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>There are several special types to be aware of, as no other type can be defined to behave the same:</p>\n<dl class=\"docutils\">\n<dt><code class=\"docutils literal\"><span class=\"pre\">Float32</span></code></dt>\n<dd>Exactly corresponds to the <code class=\"docutils literal\"><span class=\"pre\">float</span></code> type in C (or <code class=\"docutils literal\"><span class=\"pre\">REAL*4</span></code> in Fortran).</dd>\n<dt><code class=\"docutils literal\"><span class=\"pre\">Float64</span></code></dt>\n<dd>Exactly corresponds to the <code class=\"docutils literal\"><span class=\"pre\">double</span></code> type in C (or <code class=\"docutils literal\"><span class=\"pre\">REAL*8</span></code> in Fortran).</dd>\n<dt><code class=\"docutils literal\"><span class=\"pre\">Complex64</span></code></dt>\n<dd>Exactly corresponds to the <code class=\"docutils literal\"><span class=\"pre\">complex</span> <span class=\"pre\">float</span></code> type in C (or <code class=\"docutils literal\"><span class=\"pre\">COMPLEX*8</span></code> in Fortran).</dd>\n<dt><code class=\"docutils literal\"><span class=\"pre\">Complex128</span></code></dt>\n<dd>Exactly corresponds to the <code class=\"docutils literal\"><span class=\"pre\">complex</span> <span class=\"pre\">double</span></code> type in C (or <code class=\"docutils literal\"><span class=\"pre\">COMPLEX*16</span></code> in Fortran).</dd>\n<dt><code class=\"docutils literal\"><span class=\"pre\">Signed</span></code></dt>\n<dd>Exactly corresponds to the <code class=\"docutils literal\"><span class=\"pre\">signed</span></code> type annotation in C (or any <code class=\"docutils literal\"><span class=\"pre\">INTEGER</span></code> type in Fortran). Any Julia type that is not a subtype of <code class=\"docutils literal\"><span class=\"pre\">Signed</span></code> is assumed to be unsigned.</dd>\n<dt><code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code></dt>\n<dd>Behaves like a <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code> that owns its memory.</dd>\n<dt><code class=\"docutils literal\"><span class=\"pre\">Array{T,N}</span></code></dt>\n<dd><p class=\"first\">When an array is passed to C as a <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code> argument, it is\nnot reinterpret-cast: Julia requires that the element type of the\narray matches <code class=\"docutils literal\"><span class=\"pre\">T</span></code>, and the address of the first element is passed.</p>\n<p>Therefore, if an <code class=\"docutils literal\"><span class=\"pre\">Array</span></code> contains data in the wrong format, it will\nhave to be explicitly converted using a call such as <code class=\"docutils literal\"><span class=\"pre\">trunc(Int32,a)</span></code>.</p>\n<p>To pass an array <code class=\"docutils literal\"><span class=\"pre\">A</span></code> as a pointer of a different type <em>without</em>\nconverting the data beforehand (for example, to pass a <code class=\"docutils literal\"><span class=\"pre\">Float64</span></code> array\nto a function that operates on uninterpreted bytes), you can\ndeclare the argument as <code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code>.</p>\n<p class=\"last\">If an array of eltype <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code> is passed as a <code class=\"docutils literal\"><span class=\"pre\">Ptr{Ptr{T}}</span></code> argument,\n<a class=\"reference internal\" href=\"../stdlib/c.html#Base.cconvert\" title=\"Base.cconvert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">Base.cconvert()</span></code></a> will attempt to first make a null-terminated copy of the array with\neach element replaced by its <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cconvert\" title=\"Base.cconvert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cconvert()</span></code></a> version. This allows, for example, passing an <code class=\"docutils literal\"><span class=\"pre\">argv</span></code>\npointer array of type <code class=\"docutils literal\"><span class=\"pre\">Vector{String}</span></code> to an argument of type <code class=\"docutils literal\"><span class=\"pre\">Ptr{Ptr{Cchar}}</span></code>.</p>\n</dd>\n</dl>\n<p>On all systems we currently support, basic C/C++ value types may be\ntranslated to Julia types as follows. Every C type also has a corresponding\nJulia type with the same name, prefixed by C. This can help for writing portable code (and remembering that an <code class=\"docutils literal\"><span class=\"pre\">int</span></code> in C is not the same as an <code class=\"docutils literal\"><span class=\"pre\">Int</span></code> in Julia).</p>\n<p><strong>System Independent:</strong></p>\n<table border=\"1\" class=\"text-wrap docutils\">\n<colgroup>\n<col width=\"32%\" />\n<col width=\"16%\" />\n<col width=\"20%\" />\n<col width=\"32%\" />\n</colgroup>\n<thead valign=\"bottom\">\n<tr class=\"row-odd\"><th class=\"head\">C name</th>\n<th class=\"head\">Fortran name</th>\n<th class=\"head\">Standard Julia Alias</th>\n<th class=\"head\">Julia Base Type</th>\n</tr>\n</thead>\n<tbody valign=\"top\">\n<tr class=\"row-even\"><td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">char</span></code></p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">bool</span></code> (C++)</p>\n</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">CHARACTER</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cuchar</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">UInt8</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">short</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">INTEGER*2</span></code></p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">LOGICAL*2</span></code></p>\n</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cshort</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int16</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">short</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cushort</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">UInt16</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">int</span></code></p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">BOOL</span></code> (C, typical)</p>\n</td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">INTEGER*4</span></code></p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">LOGICAL*4</span></code></p>\n</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cint</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int32</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">int</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cuint</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">UInt32</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">long</span> <span class=\"pre\">long</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">INTEGER*8</span></code></p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">LOGICAL*8</span></code></p>\n</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Clonglong</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int64</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">long</span> <span class=\"pre\">long</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Culonglong</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">UInt64</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">intmax_t</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cintmax_t</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int64</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">uintmax_t</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cuintmax_t</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">UInt64</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">float</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">REAL*4i</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cfloat</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Float32</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">double</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">REAL*8</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cdouble</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Float64</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">complex</span> <span class=\"pre\">float</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">COMPLEX*8</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Complex64</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Complex{Float32}</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">complex</span> <span class=\"pre\">double</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">COMPLEX*16</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Complex128</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Complex{Float64}</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">ptrdiff_t</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cptrdiff_t</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">ssize_t</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cssize_t</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Int</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">size_t</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Csize_t</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">UInt</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">void</span></code></td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Void</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">void</span></code> and\n<code class=\"docutils literal\"><span class=\"pre\">[[noreturn]]</span></code> or <code class=\"docutils literal\"><span class=\"pre\">_Noreturn</span></code></td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Union{}</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">void*</span></code></td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">T*</span></code> (where T represents an\nappropriately defined type)</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">char*</span></code>\n(or <code class=\"docutils literal\"><span class=\"pre\">char[]</span></code>, e.g. a string)</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">CHARACTER*N</span></code></td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> if NUL-terminated, or\n<code class=\"docutils literal\"><span class=\"pre\">Ptr{UInt8}</span></code> if not</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">char**</span></code> (or <code class=\"docutils literal\"><span class=\"pre\">*char[]</span></code>)</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Ptr{Ptr{UInt8}}</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code>\n(any Julia Type)</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Any</span></code></td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">jl_value_t**</span></code>\n(a reference to a Julia Type)</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Ref{Any}</span></code></td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">va_arg</span></code></td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>Not supported</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">...</span></code>\n(variadic function specification)</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td><code class=\"docutils literal\"><span class=\"pre\">T...</span></code> (where <code class=\"docutils literal\"><span class=\"pre\">T</span></code>\nis one of the above types,\nvariadic functions of different\nargument types are not supported)</td>\n</tr>\n</tbody>\n</table>\n<p>The <code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> type is essentially a synonym for <code class=\"docutils literal\"><span class=\"pre\">Ptr{UInt8}</span></code>, except the conversion to <code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> throws an\nerror if the Julia string contains any embedded NUL characters (which would cause the string to be silently\ntruncated if the C routine treats NUL as the terminator).  If you are passing a <code class=\"docutils literal\"><span class=\"pre\">char*</span></code> to a C routine that\ndoes not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that\nyour Julia string does not contain NUL and want to skip the check, you can use <code class=\"docutils literal\"><span class=\"pre\">Ptr{UInt8}</span></code> as the argument type.\n<code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> can also be used as the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> return type, but in that case it obviously does not introduce any extra\nchecks and is only meant to improve readability of the call.</p>\n<p><strong>System-dependent:</strong></p>\n<table border=\"1\" class=\"docutils\">\n<colgroup>\n<col width=\"32%\" />\n<col width=\"32%\" />\n<col width=\"35%\" />\n</colgroup>\n<thead valign=\"bottom\">\n<tr class=\"row-odd\"><th class=\"head\">C name</th>\n<th class=\"head\">Standard Julia Alias</th>\n<th class=\"head\">Julia Base Type</th>\n</tr>\n</thead>\n<tbody valign=\"top\">\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">char</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cchar</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">Int8</span></code> (x86, x86_64)</p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">UInt8</span></code> (powerpc, arm)</p>\n</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">long</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Clong</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">Int</span></code> (UNIX)</p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">Int32</span></code> (Windows)</p>\n</td>\n</tr>\n<tr class=\"row-even\"><td><code class=\"docutils literal\"><span class=\"pre\">unsigned</span> <span class=\"pre\">long</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Culong</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">UInt</span></code> (UNIX)</p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">UInt32</span></code> (Windows)</p>\n</td>\n</tr>\n<tr class=\"row-odd\"><td><code class=\"docutils literal\"><span class=\"pre\">wchar_t</span></code></td>\n<td><code class=\"docutils literal\"><span class=\"pre\">Cwchar_t</span></code></td>\n<td><p class=\"first\"><code class=\"docutils literal\"><span class=\"pre\">Int32</span></code> (UNIX)</p>\n<p class=\"last\"><code class=\"docutils literal\"><span class=\"pre\">UInt16</span></code> (Windows)</p>\n</td>\n</tr>\n</tbody>\n</table>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">When calling a Fortran function, all inputs must be passed by reference, so\nall type correspondences above should contain an additional <code class=\"docutils literal\"><span class=\"pre\">Ptr{..}</span></code> or\n<code class=\"docutils literal\"><span class=\"pre\">Ref{..}</span></code> wrapper around their type specification.</p>\n</div>\n<div class=\"admonition warning\">\n<p class=\"first admonition-title\">Warning</p>\n<p class=\"last\">For string arguments (<code class=\"docutils literal\"><span class=\"pre\">char*</span></code>) the Julia type should be <code class=\"docutils literal\"><span class=\"pre\">Cstring</span></code> (if NUL-\nterminated data is expected) or either <code class=\"docutils literal\"><span class=\"pre\">Ptr{Cchar}</span></code> or <code class=\"docutils literal\"><span class=\"pre\">Ptr{UInt8}</span></code>\notherwise (these two pointer types have the same effect), as described above,\nnot <code class=\"docutils literal\"><span class=\"pre\">String</span></code>. Similarly, for array arguments (<code class=\"docutils literal\"><span class=\"pre\">T[]</span></code> or <code class=\"docutils literal\"><span class=\"pre\">T*</span></code>), the\nJulia type should again be <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code>, not <code class=\"docutils literal\"><span class=\"pre\">Vector{T}</span></code>.</p>\n</div>\n<div class=\"admonition warning\">\n<p class=\"first admonition-title\">Warning</p>\n<p class=\"last\">Julia&#8217;s <code class=\"docutils literal\"><span class=\"pre\">Char</span></code> type is 32 bits, which is not the same as the wide character\ntype (<code class=\"docutils literal\"><span class=\"pre\">wchar_t</span></code> or <code class=\"docutils literal\"><span class=\"pre\">wint_t</span></code>) on all platforms.</p>\n</div>\n<div class=\"admonition warning\">\n<p class=\"first admonition-title\">Warning</p>\n<p class=\"last\">A return type of <code class=\"docutils literal\"><span class=\"pre\">Union{}</span></code> means the function will not return\ni.e. C++11 <code class=\"docutils literal\"><span class=\"pre\">[[noreturn]]</span></code> or C11 <code class=\"docutils literal\"><span class=\"pre\">_Noreturn</span></code> (e.g. <code class=\"docutils literal\"><span class=\"pre\">jl_throw</span></code> or\n<code class=\"docutils literal\"><span class=\"pre\">longjmp</span></code>). Do not use this for functions that return\nno value (<code class=\"docutils literal\"><span class=\"pre\">void</span></code>) but do return.</p>\n</div>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">For <code class=\"docutils literal\"><span class=\"pre\">wchar_t*</span></code> arguments, the Julia type should be <code class=\"docutils literal\"><span class=\"pre\">Cwstring</span></code> (if the C\nroutine expects a NUL-terminated string) or <code class=\"docutils literal\"><span class=\"pre\">Ptr{Cwchar_t}</span></code> otherwise. Note\nalso that UTF-8 string data in Julia is internally NUL-terminated, so it can\nbe passed to C functions expecting NUL-terminated data without making a copy\n(but using the <code class=\"docutils literal\"><span class=\"pre\">Cwstring</span></code> type will cause an error to be thrown if the string\nitself contains NUL characters).</p>\n</div>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p>C functions that take an argument of the type <code class=\"docutils literal\"><span class=\"pre\">char**</span></code> can be called by\nusing a <code class=\"docutils literal\"><span class=\"pre\">Ptr{Ptr{UInt8}}</span></code> type within Julia. For example, C functions of the\nform:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">int</span> <span class=\"n\">main</span><span class=\"p\">(</span><span class=\"n\">int</span> <span class=\"n\">argc</span><span class=\"p\">,</span> <span class=\"n\">char</span> <span class=\"o\">**</span><span class=\"n\">argv</span><span class=\"p\">);</span>\n</pre></div>\n</div>\n<p>can be called via the following Julia code:</p>\n<div class=\"last highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">argv</span> <span class=\"o\">=</span> <span class=\"p\">[</span> <span class=\"s\">&quot;a.out&quot;</span><span class=\"p\">,</span> <span class=\"s\">&quot;arg1&quot;</span><span class=\"p\">,</span> <span class=\"s\">&quot;arg2&quot;</span> <span class=\"p\">]</span>\n<span class=\"k\">ccall</span><span class=\"p\">(</span><span class=\"o\">:</span><span class=\"n\">main</span><span class=\"p\">,</span> <span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">UInt8</span><span class=\"p\">}}),</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">argv</span><span class=\"p\">),</span> <span class=\"n\">argv</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</div>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">A C function declared to return <code class=\"docutils literal\"><span class=\"pre\">Void</span></code> will return the value <code class=\"docutils literal\"><span class=\"pre\">nothing</span></code> in\nJulia.</p>\n</div>\n</div>\n<div class=\"section\" id=\"struct-type-correspondences\">\n<h3>Struct Type correspondences<a class=\"headerlink\" href=\"#struct-type-correspondences\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>Composite types, aka <code class=\"docutils literal\"><span class=\"pre\">struct</span></code> in C or <code class=\"docutils literal\"><span class=\"pre\">TYPE</span></code> in Fortran90\n(or <code class=\"docutils literal\"><span class=\"pre\">STRUCTURE</span></code> / <code class=\"docutils literal\"><span class=\"pre\">RECORD</span></code> in some variants of F77),\ncan be mirrored in Julia by creating a <code class=\"docutils literal\"><span class=\"pre\">type</span></code> or <code class=\"docutils literal\"><span class=\"pre\">immutable</span></code>\ndefinition with the same field layout.</p>\n<p>When used recursively, <code class=\"docutils literal\"><span class=\"pre\">isbits</span></code> types are stored inline.\nAll other types are stored as a pointer to the data.\nWhen mirroring a struct used by-value inside another struct in C,\nit is imperative that you do not attempt to manually copy the fields over,\nas this will not preserve the correct field alignment.\nInstead, declare an immutable <code class=\"docutils literal\"><span class=\"pre\">isbits</span></code> type and use that instead.\nUnnamed structs are not possible in the translation to Julia.</p>\n<p>Packed structs and union declarations are not supported by Julia.</p>\n<p>You can get a near approximation of a <code class=\"docutils literal\"><span class=\"pre\">union</span></code> if you know, a priori,\nthe field that will have the greatest size (potentially including padding).\nWhen translating your fields to Julia, declare the Julia field to be only\nof that type.</p>\n<p>Arrays of parameters must be expanded manually, currently\n(either inline, or in an immutable helper type). For example:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"kp\">in</span> <span class=\"n\">C</span><span class=\"o\">:</span>\n<span class=\"n\">struct</span> <span class=\"n\">B</span> <span class=\"p\">{</span>\n    <span class=\"n\">int</span> <span class=\"n\">A</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">];</span>\n<span class=\"p\">};</span>\n<span class=\"n\">b_a_2</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"o\">.</span><span class=\"n\">A</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">];</span>\n\n<span class=\"kp\">in</span> <span class=\"n\">Julia</span><span class=\"o\">:</span>\n<span class=\"k\">immutable</span> <span class=\"n\">B_A</span>\n    <span class=\"n\">A_1</span><span class=\"o\">::</span><span class=\"kt\">Cint</span>\n    <span class=\"n\">A_2</span><span class=\"o\">::</span><span class=\"kt\">Cint</span>\n    <span class=\"n\">A_3</span><span class=\"o\">::</span><span class=\"kt\">Cint</span>\n<span class=\"k\">end</span>\n<span class=\"k\">type</span> <span class=\"n\">B</span>\n    <span class=\"n\">A</span><span class=\"o\">::</span><span class=\"n\">B_A</span>\n<span class=\"k\">end</span>\n<span class=\"n\">b_a_2</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"o\">.</span><span class=\"n\">A</span><span class=\"o\">.</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Arrays of unknown size are not supported.</p>\n<p>In the future, some of these restrictions may be reduced or eliminated.</p>\n</div>\n<div class=\"section\" id=\"simd-values\">\n<h3>SIMD Values<a class=\"headerlink\" href=\"#simd-values\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>Note: This feature is currently implemented on 64-bit x86\nand AArch64 platforms only.</p>\n<p>If a C/C++ routine has an argument or return value that is a native\nSIMD type, the corresponding Julia type is a homogeneous tuple\nof <code class=\"docutils literal\"><span class=\"pre\">VecElement</span></code> that naturally maps to the SIMD type.  Specifically:</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li>The tuple must be the same size as the SIMD type.\nFor example, a tuple representing an <code class=\"docutils literal\"><span class=\"pre\">__m128</span></code> on x86\nmust have a size of 16 bytes.</li>\n<li>The element type of the tuple must be an instance of <code class=\"docutils literal\"><span class=\"pre\">VecElement{T}</span></code>\nwhere <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is a bitstype that is 1, 2, 4 or 8 bytes.</li>\n</ul>\n</div></blockquote>\n<p>For instance, consider this C routine that uses AVX intrinsics:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"c\">#include &lt;immintrin.h&gt;</span>\n\n<span class=\"n\">__m256</span> <span class=\"n\">dist</span><span class=\"p\">(</span> <span class=\"n\">__m256</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">__m256</span> <span class=\"n\">b</span> <span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">_mm256_sqrt_ps</span><span class=\"p\">(</span><span class=\"n\">_mm256_add_ps</span><span class=\"p\">(</span><span class=\"n\">_mm256_mul_ps</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">),</span>\n                                        <span class=\"n\">_mm256_mul_ps</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">)));</span>\n<span class=\"p\">}</span>\n</pre></div>\n</div>\n<p>The following Julia code calls <code class=\"docutils literal\"><span class=\"pre\">dist</span></code> using <code class=\"docutils literal\"><span class=\"pre\">ccall</span></code>:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">typealias</span> <span class=\"n\">m256</span> <span class=\"kt\">NTuple</span><span class=\"p\">{</span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"n\">VecElement</span><span class=\"p\">{</span><span class=\"kt\">Float32</span><span class=\"p\">}}</span>\n\n<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">m256</span><span class=\"p\">(</span><span class=\"n\">ntuple</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">-&gt;</span><span class=\"n\">VecElement</span><span class=\"p\">(</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"kt\">Float32</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">))),</span><span class=\"mi\">8</span><span class=\"p\">))</span>\n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">m256</span><span class=\"p\">(</span><span class=\"n\">ntuple</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">-&gt;</span><span class=\"n\">VecElement</span><span class=\"p\">(</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"kt\">Float32</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">))),</span><span class=\"mi\">8</span><span class=\"p\">))</span>\n\n<span class=\"k\">function</span> <span class=\"n\">call_dist</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">m256</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">::</span><span class=\"n\">m256</span><span class=\"p\">)</span>\n    <span class=\"k\">ccall</span><span class=\"p\">((</span><span class=\"o\">:</span><span class=\"n\">dist</span><span class=\"p\">,</span> <span class=\"s\">&quot;libdist&quot;</span><span class=\"p\">),</span> <span class=\"n\">m256</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">m256</span><span class=\"p\">,</span> <span class=\"n\">m256</span><span class=\"p\">),</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">println</span><span class=\"p\">(</span><span class=\"n\">call_dist</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p>The host machine must have the requisite SIMD registers.  For example,\nthe code above will not work on hosts without AVX support.</p>\n</div>\n<div class=\"section\" id=\"memory-ownership\">\n<h3>Memory Ownership<a class=\"headerlink\" href=\"#memory-ownership\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p><strong>malloc/free</strong></p>\n<p>Memory allocation and deallocation of such objects must be\nhandled by calls to the appropriate cleanup routines in the libraries\nbeing used, just like in any C program. Do not try to free an object\nreceived from a C library with <code class=\"docutils literal\"><span class=\"pre\">Libc.free</span></code> in Julia, as this may result\nin the <code class=\"docutils literal\"><span class=\"pre\">free</span></code> function being called via the wrong <code class=\"docutils literal\"><span class=\"pre\">libc</span></code> library and\ncause Julia to crash. The reverse (passing an object allocated in Julia\nto be freed by an external library) is equally invalid.</p>\n</div>\n<div class=\"section\" id=\"when-to-use-t-ptr-t-and-ref-t\">\n<h3>When to use T, Ptr{T} and Ref{T}<a class=\"headerlink\" href=\"#when-to-use-t-ptr-t-and-ref-t\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>In Julia code wrapping calls to external C routines, ordinary (non-pointer)\ndata should be declared to be of type <code class=\"docutils literal\"><span class=\"pre\">T</span></code> inside the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a>, as they\nare passed by value.  For C code accepting pointers, <code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code> should\ngenerally be used for the types of input arguments, allowing the use of\npointers to memory managed by either Julia or C through the implicit call to\n<a class=\"reference internal\" href=\"../stdlib/c.html#Base.cconvert\" title=\"Base.cconvert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cconvert()</span></code></a>.  In contrast, pointers returned by the C function called\nshould be declared to be of output type <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code>, reflecting that the memory\npointed to is managed by C only. Pointers contained in C structs should be\nrepresented as fields of type <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code> within the corresponding Julia\nimmutable types designed to mimic the internal structure of corresponding C\nstructs.</p>\n<p>In Julia code wrapping calls to external Fortran routines, all input arguments\nshould be declared as of type <code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code>, as Fortran passes all variables by\nreference. The return type should either be <code class=\"docutils literal\"><span class=\"pre\">Void</span></code> for Fortran subroutines,\nor a <code class=\"docutils literal\"><span class=\"pre\">T</span></code> for Fortran functions returning the type <code class=\"docutils literal\"><span class=\"pre\">T</span></code>.</p>\n</div>\n</div>\n<div class=\"section\" id=\"mapping-c-functions-to-julia\">\n<h2>Mapping C Functions to Julia<a class=\"headerlink\" href=\"#mapping-c-functions-to-julia\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<div class=\"section\" id=\"ccall-cfunction-argument-translation-guide\">\n<h3><code class=\"docutils literal\"><span class=\"pre\">ccall</span></code>/<code class=\"docutils literal\"><span class=\"pre\">cfunction</span></code> argument translation guide<a class=\"headerlink\" href=\"#ccall-cfunction-argument-translation-guide\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>For translating a C argument list to Julia:</p>\n<ul class=\"simple\">\n<li><code class=\"docutils literal\"><span class=\"pre\">T</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is one of the primitive types:\n<code class=\"docutils literal\"><span class=\"pre\">char</span></code>, <code class=\"docutils literal\"><span class=\"pre\">int</span></code>, <code class=\"docutils literal\"><span class=\"pre\">long</span></code>, <code class=\"docutils literal\"><span class=\"pre\">short</span></code>, <code class=\"docutils literal\"><span class=\"pre\">float</span></code>, <code class=\"docutils literal\"><span class=\"pre\">double</span></code>, <code class=\"docutils literal\"><span class=\"pre\">complex</span></code>, <code class=\"docutils literal\"><span class=\"pre\">enum</span></code>\nor any of their <code class=\"docutils literal\"><span class=\"pre\">typedef</span></code> equivalents<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">T</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is an equivalent Julia Bits Type (per the table above)</li>\n<li>if <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is an <code class=\"docutils literal\"><span class=\"pre\">enum</span></code>, the argument type should be equivalent to <code class=\"docutils literal\"><span class=\"pre\">Cint</span></code> or <code class=\"docutils literal\"><span class=\"pre\">Cuint</span></code></li>\n<li>argument value will be copied (passed by value)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">struct</span> <span class=\"pre\">T</span></code> (including typedef to a struct)<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">T</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is a Julia leaf type</li>\n<li>argument value will be copied (passed by value)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">void*</span></code><ul>\n<li>depends on how this parameter is used, first translate this to the intended pointer type,\nthen determine the Julia equivalent using the remaining rules in this list</li>\n<li>this argument may be declared as <code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code>, if it really is just an unknown pointer</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code><ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Any</span></code></li>\n<li>argument value must be a valid Julia object</li>\n<li>currently unsupported by <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cfunction\" title=\"Base.cfunction\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cfunction()</span></code></a></li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">jl_value_t**</span></code><ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ref{Any}</span></code></li>\n<li>argument value must be a valid Julia object (or <code class=\"docutils literal\"><span class=\"pre\">C_NULL</span></code>)</li>\n<li>currently unsupported by <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cfunction\" title=\"Base.cfunction\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cfunction()</span></code></a></li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">T*</span></code><ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is the Julia type corresponding to <code class=\"docutils literal\"><span class=\"pre\">T</span></code></li>\n<li>argument value will be copied if it is an <code class=\"docutils literal\"><span class=\"pre\">isbits</span></code> type\notherwise, the value must be a valid Julia object</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">(T*)(...)</span></code> (e.g. a pointer to a function)<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code> (you may need to use <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cfunction\" title=\"Base.cfunction\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cfunction()</span></code></a> explicitly to create this pointer)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">...</span></code> (e.g. a vararg)<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">T...</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is the Julia type</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">va_arg</span></code><ul>\n<li>not supported</li>\n</ul>\n</li>\n</ul>\n</div>\n<div class=\"section\" id=\"ccall-cfunction-return-type-translation-guide\">\n<h3><code class=\"docutils literal\"><span class=\"pre\">ccall</span></code>/<code class=\"docutils literal\"><span class=\"pre\">cfunction</span></code> return type translation guide<a class=\"headerlink\" href=\"#ccall-cfunction-return-type-translation-guide\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>For translating a C return type to Julia:</p>\n<ul class=\"simple\">\n<li><code class=\"docutils literal\"><span class=\"pre\">void</span></code><ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Void</span></code> (this will return the singleton instance <code class=\"docutils literal\"><span class=\"pre\">nothing::Void</span></code>)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">T</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is one of the primitive types:\n<code class=\"docutils literal\"><span class=\"pre\">char</span></code>, <code class=\"docutils literal\"><span class=\"pre\">int</span></code>, <code class=\"docutils literal\"><span class=\"pre\">long</span></code>, <code class=\"docutils literal\"><span class=\"pre\">short</span></code>, <code class=\"docutils literal\"><span class=\"pre\">float</span></code>, <code class=\"docutils literal\"><span class=\"pre\">double</span></code>, <code class=\"docutils literal\"><span class=\"pre\">complex</span></code>, <code class=\"docutils literal\"><span class=\"pre\">enum</span></code>\nor any of their <code class=\"docutils literal\"><span class=\"pre\">typedef</span></code> equivalents<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">T</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is an equivalent Julia Bits Type (per the table above)</li>\n<li>if <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is an <code class=\"docutils literal\"><span class=\"pre\">enum</span></code>, the argument type should be equivalent to <code class=\"docutils literal\"><span class=\"pre\">Cint</span></code> or <code class=\"docutils literal\"><span class=\"pre\">Cuint</span></code></li>\n<li>argument value will be copied (returned by-value)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">struct</span> <span class=\"pre\">T</span></code> (including typedef to a struct)<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">T</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is a Julia Leaf Type</li>\n<li>argument value will be copied (returned by-value)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">void*</span></code><ul>\n<li>depends on how this parameter is used, first translate this to the intended pointer type,\nthen determine the Julia equivalent using the remaining rules in this list</li>\n<li>this argument may be declared as <code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code>, if it really is just an unknown pointer</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code><ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Any</span></code></li>\n<li>argument value must be a valid Julia object</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">jl_value_t**</span></code><ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ref{Any}</span></code></li>\n<li>argument value must be a valid Julia object (or <code class=\"docutils literal\"><span class=\"pre\">C_NULL</span></code>)</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">T*</span></code><ul>\n<li>If the memory is already owned by Julia, or is an <code class=\"docutils literal\"><span class=\"pre\">isbits</span></code> type, and is known to be non-null:<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is the Julia type corresponding to <code class=\"docutils literal\"><span class=\"pre\">T</span></code></li>\n<li>a return type of <code class=\"docutils literal\"><span class=\"pre\">Ref{Any}</span></code> is invalid, it should either be <code class=\"docutils literal\"><span class=\"pre\">Any</span></code>\n(corresponding to <code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code>) or <code class=\"docutils literal\"><span class=\"pre\">Ptr{Any}</span></code> (corresponding to <code class=\"docutils literal\"><span class=\"pre\">Ptr{Any}</span></code>)</li>\n<li>C <strong>MUST NOT</strong> modify the memory returned via <code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code> if <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is an <code class=\"docutils literal\"><span class=\"pre\">isbits</span></code> type</li>\n</ul>\n</li>\n<li>If the memory is owned by C:<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code>, where <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is the Julia type corresponding to <code class=\"docutils literal\"><span class=\"pre\">T</span></code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code class=\"docutils literal\"><span class=\"pre\">(T*)(...)</span></code> (e.g. a pointer to a function)<ul>\n<li><code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code> (you may need to use <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cfunction\" title=\"Base.cfunction\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cfunction()</span></code></a> explicitly to create this pointer)</li>\n</ul>\n</li>\n</ul>\n</div>\n<div class=\"section\" id=\"passing-pointers-for-modifying-inputs\">\n<h3>Passing Pointers for Modifying Inputs<a class=\"headerlink\" href=\"#passing-pointers-for-modifying-inputs\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>Because C doesn&#8217;t support multiple return values,\noften C functions will take pointers to data that the function will modify.\nTo accomplish this within a <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a>,\nyou need to first encapsulate the value inside an <code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code> of the appropriate type.\nWhen you pass this <code class=\"docutils literal\"><span class=\"pre\">Ref</span></code> object as an argument,\nJulia will automatically pass a C pointer to the encapsulated data:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">width</span> <span class=\"o\">=</span> <span class=\"kt\">Ref</span><span class=\"p\">{</span><span class=\"kt\">Cint</span><span class=\"p\">}(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">range</span> <span class=\"o\">=</span> <span class=\"kt\">Ref</span><span class=\"p\">{</span><span class=\"kt\">Cfloat</span><span class=\"p\">}(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"k\">ccall</span><span class=\"p\">(</span><span class=\"o\">:</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"kt\">Void</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Ref</span><span class=\"p\">{</span><span class=\"kt\">Cint</span><span class=\"p\">},</span> <span class=\"kt\">Ref</span><span class=\"p\">{</span><span class=\"kt\">Cfloat</span><span class=\"p\">}),</span> <span class=\"n\">width</span><span class=\"p\">,</span> <span class=\"n\">range</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Upon return, the contents of <code class=\"docutils literal\"><span class=\"pre\">width</span></code> and <code class=\"docutils literal\"><span class=\"pre\">range</span></code> can be retrieved\n(if they were changed by <code class=\"docutils literal\"><span class=\"pre\">foo</span></code>) by <code class=\"docutils literal\"><span class=\"pre\">width[]</span></code> and <code class=\"docutils literal\"><span class=\"pre\">range[]</span></code>; that is,\nthey act like zero-dimensional arrays.</p>\n</div>\n<div class=\"section\" id=\"special-reference-syntax-for-ccall-deprecated\">\n<h3>Special Reference Syntax for ccall (deprecated):<a class=\"headerlink\" href=\"#special-reference-syntax-for-ccall-deprecated\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<p>The <code class=\"docutils literal\"><span class=\"pre\">&amp;</span></code> syntax is deprecated, use the <code class=\"docutils literal\"><span class=\"pre\">Ref{T}</span></code> argument type instead.</p>\n<p>A prefix <code class=\"docutils literal\"><span class=\"pre\">&amp;</span></code> is used on an argument to <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> to indicate that a pointer\nto a scalar argument should be passed instead of the scalar value itself\n(required for all Fortran function arguments, as noted above). The following\nexample computes a dot product using a BLAS function.</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">function</span> <span class=\"n\">compute_dot</span><span class=\"p\">(</span><span class=\"n\">DX</span><span class=\"o\">::</span><span class=\"kt\">Vector</span><span class=\"p\">{</span><span class=\"kt\">Float64</span><span class=\"p\">},</span> <span class=\"n\">DY</span><span class=\"o\">::</span><span class=\"kt\">Vector</span><span class=\"p\">{</span><span class=\"kt\">Float64</span><span class=\"p\">})</span>\n  <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">DX</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">DY</span><span class=\"p\">))</span>\n  <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">DX</span><span class=\"p\">)</span>\n  <span class=\"n\">incx</span> <span class=\"o\">=</span> <span class=\"n\">incy</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n  <span class=\"n\">product</span> <span class=\"o\">=</span> <span class=\"k\">ccall</span><span class=\"p\">((</span><span class=\"o\">:</span><span class=\"n\">ddot_</span><span class=\"p\">,</span> <span class=\"s\">&quot;libLAPACK&quot;</span><span class=\"p\">),</span>\n                  <span class=\"kt\">Float64</span><span class=\"p\">,</span>\n                  <span class=\"p\">(</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Int32</span><span class=\"p\">},</span> <span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Float64</span><span class=\"p\">},</span> <span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Int32</span><span class=\"p\">},</span> <span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Float64</span><span class=\"p\">},</span> <span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Int32</span><span class=\"p\">}),</span>\n                  <span class=\"o\">&amp;</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">DX</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">incx</span><span class=\"p\">,</span> <span class=\"n\">DY</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">incy</span><span class=\"p\">)</span>\n  <span class=\"k\">return</span> <span class=\"n\">product</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n<p>The meaning of prefix <code class=\"docutils literal\"><span class=\"pre\">&amp;</span></code> is not quite the same as in C. In\nparticular, any changes to the referenced variables will not be\nvisible in Julia unless the type is mutable (declared via\n<code class=\"docutils literal\"><span class=\"pre\">type</span></code>). However, even for immutable types it will not cause any\nharm for called functions to attempt such modifications (that is,\nwriting through the passed pointers). Moreover, <code class=\"docutils literal\"><span class=\"pre\">&amp;</span></code> may be used with\nany expression, such as <code class=\"docutils literal\"><span class=\"pre\">&amp;0</span></code> or <code class=\"docutils literal\"><span class=\"pre\">&amp;f(x)</span></code>.</p>\n<p>When a scalar value is passed with <code class=\"docutils literal\"><span class=\"pre\">&amp;</span></code> as an argument of type\n<code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code>, the value will first be converted to type <code class=\"docutils literal\"><span class=\"pre\">T</span></code>.</p>\n</div>\n</div>\n<div class=\"section\" id=\"some-examples-of-c-wrappers\">\n<h2>Some Examples of C Wrappers<a class=\"headerlink\" href=\"#some-examples-of-c-wrappers\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Here is a simple example of a C wrapper that returns a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> type:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">type</span> <span class=\"n\">gsl_permutation</span>\n<span class=\"k\">end</span>\n\n<span class=\"c\"># The corresponding C signature is</span>\n<span class=\"c\">#     gsl_permutation * gsl_permutation_alloc (size_t n);</span>\n<span class=\"k\">function</span> <span class=\"n\">permutation_alloc</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">::</span><span class=\"kt\">Integer</span><span class=\"p\">)</span>\n    <span class=\"n\">output_ptr</span> <span class=\"o\">=</span> <span class=\"k\">ccall</span><span class=\"p\">(</span>\n        <span class=\"p\">(</span><span class=\"o\">:</span><span class=\"n\">gsl_permutation_alloc</span><span class=\"p\">,</span> <span class=\"o\">:</span><span class=\"n\">libgsl</span><span class=\"p\">),</span> <span class=\"c\">#name of C function and library</span>\n        <span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"n\">gsl_permutation</span><span class=\"p\">},</span>              <span class=\"c\">#output type</span>\n        <span class=\"p\">(</span><span class=\"kt\">Csize_t</span><span class=\"p\">,),</span>                        <span class=\"c\">#tuple of input types</span>\n        <span class=\"n\">n</span>                                  <span class=\"c\">#name of Julia variable to pass in</span>\n    <span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">output_ptr</span><span class=\"o\">==</span><span class=\"nb\">C_NULL</span> <span class=\"c\"># Could not allocate memory</span>\n        <span class=\"n\">throw</span><span class=\"p\">(</span><span class=\"kt\">OutOfMemoryError</span><span class=\"p\">())</span>\n    <span class=\"k\">end</span>\n    <span class=\"k\">return</span> <span class=\"n\">output_ptr</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n<p>The <a class=\"reference external\" href=\"https://www.gnu.org/software/gsl/\">GNU Scientific Library</a> (here assumed\nto be accessible through <code class=\"docutils literal\"><span class=\"pre\">:libgsl</span></code>) defines an opaque pointer,\n<code class=\"docutils literal\"><span class=\"pre\">gsl_permutation</span> <span class=\"pre\">*</span></code>, as the return type of the C function\n<code class=\"docutils literal\"><span class=\"pre\">gsl_permutation_alloc()</span></code>. As user code never has to look inside the\n<code class=\"docutils literal\"><span class=\"pre\">gsl_permutation</span></code> struct, the corresponding Julia wrapper simply needs a new\ntype declaration, <code class=\"docutils literal\"><span class=\"pre\">gsl_permutation</span></code>, that has no internal fields and whose\nsole purpose is to be placed in the type parameter of a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> type.  The\nreturn type of the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> is declared as <code class=\"docutils literal\"><span class=\"pre\">Ptr{gsl_permutation}</span></code>, since the\nmemory allocated and pointed to by <code class=\"docutils literal\"><span class=\"pre\">output_ptr</span></code> is controlled by C (and not\nJulia).</p>\n<p>The input <code class=\"docutils literal\"><span class=\"pre\">n</span></code> is passed by value, and so the function&#8217;s input signature is\nsimply declared as <code class=\"docutils literal\"><span class=\"pre\">(Csize_t,)</span></code> without any <code class=\"docutils literal\"><span class=\"pre\">Ref</span></code> or <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> necessary.\n(If the wrapper was calling a Fortran function instead, the corresponding\nfunction input signature should instead be <code class=\"docutils literal\"><span class=\"pre\">(Ref{Csize_t},)</span></code>, since Fortran\nvariables are passed by reference.) Furthermore, <code class=\"docutils literal\"><span class=\"pre\">n</span></code> can be any type that is\nconvertable to a <code class=\"docutils literal\"><span class=\"pre\">Csize_t</span></code> integer; the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> implicitly calls\n<a class=\"reference internal\" href=\"../stdlib/c.html#Base.cconvert\" title=\"Base.cconvert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">Base.cconvert(Csize_t,</span> <span class=\"pre\">n)</span></code></a>.</p>\n<p>Here is a second example wrapping the corresponding destructor:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"c\"># The corresponding C signature is</span>\n<span class=\"c\">#     void gsl_permutation_free (gsl_permutation * p);</span>\n<span class=\"k\">function</span> <span class=\"n\">permutation_free</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">::</span><span class=\"kt\">Ref</span><span class=\"p\">{</span><span class=\"n\">gsl_permutation</span><span class=\"p\">})</span>\n    <span class=\"k\">ccall</span><span class=\"p\">(</span>\n        <span class=\"p\">(</span><span class=\"o\">:</span><span class=\"n\">gsl_permutation_free</span><span class=\"p\">,</span> <span class=\"o\">:</span><span class=\"n\">libgsl</span><span class=\"p\">),</span> <span class=\"c\">#name of C function and library</span>\n        <span class=\"kt\">Void</span><span class=\"p\">,</span>                             <span class=\"c\">#output type</span>\n        <span class=\"p\">(</span><span class=\"kt\">Ref</span><span class=\"p\">{</span><span class=\"n\">gsl_permutation</span><span class=\"p\">},),</span>          <span class=\"c\">#tuple of input types</span>\n        <span class=\"n\">p</span>                                 <span class=\"c\">#name of Julia variable to pass in</span>\n    <span class=\"p\">)</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n<p>Here, the input <code class=\"docutils literal\"><span class=\"pre\">p</span></code> is declared to be of type <code class=\"docutils literal\"><span class=\"pre\">Ref{gsl_permutation}</span></code>,\nmeaning that the memory that <code class=\"docutils literal\"><span class=\"pre\">p</span></code> points to may be managed by Julia or by C.\nA pointer to memory allocated by C should be of type <code class=\"docutils literal\"><span class=\"pre\">Ptr{gsl_permutation}</span></code>,\nbut it is convertable using <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cconvert\" title=\"Base.cconvert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cconvert()</span></code></a> and therefore can be used in the\nsame (covariant) context of the input argument to a <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a>. A pointer to\nmemory allocated by Julia must be of type <code class=\"docutils literal\"><span class=\"pre\">Ref{gsl_permutation}</span></code>, to ensure\nthat the memory address pointed to is valid and that Julia&#8217;s garbage collector\nmanages the chunk of memory pointed to correctly. Therefore, the\n<code class=\"docutils literal\"><span class=\"pre\">Ref{gsl_permutation}</span></code> declaration allows pointers managed by C or Julia to\nbe used.</p>\n<p>If the C wrapper never expects the user to pass pointers to memory managed by\nJulia, then using <code class=\"docutils literal\"><span class=\"pre\">p::Ptr{gsl_permutation}</span></code> for the method signature of the\nwrapper and similarly in the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> is also acceptable.</p>\n<p>Here is a third example passing Julia arrays:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"c\"># The corresponding C signature is</span>\n<span class=\"c\">#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,</span>\n<span class=\"c\">#                                double result_array[])</span>\n<span class=\"k\">function</span> <span class=\"n\">sf_bessel_Jn_array</span><span class=\"p\">(</span><span class=\"n\">nmin</span><span class=\"o\">::</span><span class=\"kt\">Integer</span><span class=\"p\">,</span> <span class=\"n\">nmax</span><span class=\"o\">::</span><span class=\"kt\">Integer</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"o\">::</span><span class=\"kt\">Real</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">nmax</span><span class=\"o\">&lt;</span><span class=\"n\">nmin</span> <span class=\"n\">throw</span><span class=\"p\">(</span><span class=\"kt\">DomainError</span><span class=\"p\">())</span> <span class=\"k\">end</span>\n    <span class=\"n\">result_array</span> <span class=\"o\">=</span> <span class=\"kt\">Array</span><span class=\"p\">{</span><span class=\"kt\">Cdouble</span><span class=\"p\">}(</span><span class=\"n\">nmax</span><span class=\"o\">-</span><span class=\"n\">nmin</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">errorcode</span> <span class=\"o\">=</span> <span class=\"k\">ccall</span><span class=\"p\">(</span>\n        <span class=\"p\">(</span><span class=\"o\">:</span><span class=\"n\">gsl_sf_bessel_Jn_array</span><span class=\"p\">,</span> <span class=\"o\">:</span><span class=\"n\">libgsl</span><span class=\"p\">),</span> <span class=\"c\">#name of C function and library</span>\n        <span class=\"kt\">Cint</span><span class=\"p\">,</span>                               <span class=\"c\">#output type</span>\n        <span class=\"p\">(</span><span class=\"kt\">Cint</span><span class=\"p\">,</span> <span class=\"kt\">Cint</span><span class=\"p\">,</span> <span class=\"kt\">Cdouble</span><span class=\"p\">,</span> <span class=\"kt\">Ref</span><span class=\"p\">{</span><span class=\"kt\">Cdouble</span><span class=\"p\">}),</span><span class=\"c\">#tuple of input types</span>\n        <span class=\"n\">nmin</span><span class=\"p\">,</span> <span class=\"n\">nmax</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">result_array</span>         <span class=\"c\">#names of Julia variables to pass in</span>\n    <span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">errorcode!</span><span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"n\">error</span><span class=\"p\">(</span><span class=\"s\">&quot;GSL error code </span><span class=\"si\">$errorcode</span><span class=\"s\">&quot;</span><span class=\"p\">)</span> <span class=\"k\">end</span>\n    <span class=\"k\">return</span> <span class=\"n\">result_array</span>\n<span class=\"k\">end</span>\n</pre></div>\n</div>\n<p>The C function wrapped returns an integer error code; the results of the actual\nevaluation of the Bessel J function populate the Julia array <code class=\"docutils literal\"><span class=\"pre\">result_array</span></code>.\nThis variable can only be used with corresponding input type declaration\n<code class=\"docutils literal\"><span class=\"pre\">Ref{Cdouble}</span></code>, since its memory is allocated and managed by\nJulia, not C. The implicit call to <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cconvert\" title=\"Base.cconvert\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">Base.cconvert(Ref{Cdouble},</span>\n<span class=\"pre\">result_array)</span></code></a> unpacks the Julia pointer to a Julia array data\nstructure into a form understandable by C.</p>\n<p>Note that for this code to work correctly, <code class=\"docutils literal\"><span class=\"pre\">result_array</span></code> must be declared to\nbe of type <code class=\"docutils literal\"><span class=\"pre\">Ref{Cdouble}</span></code> and not <code class=\"docutils literal\"><span class=\"pre\">Ptr{Cdouble}</span></code>. The memory is managed by\nJulia and the <code class=\"docutils literal\"><span class=\"pre\">Ref</span></code> signature alerts Julia&#8217;s garbage collector to keep\nmanaging the memory for <code class=\"docutils literal\"><span class=\"pre\">result_array</span></code> while the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> executes. If\n<code class=\"docutils literal\"><span class=\"pre\">Ptr{Cdouble}</span></code> were used instead, the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> may still work, but\nJulia&#8217;s garbage collector would not be aware that the memory declared for\n<code class=\"docutils literal\"><span class=\"pre\">result_array</span></code> is being used by the external C function. As a result, the\ncode may produce a memory leak if <code class=\"docutils literal\"><span class=\"pre\">result_array</span></code> never gets freed by the\ngarbage collector, or if the garbage collector prematurely frees\n<code class=\"docutils literal\"><span class=\"pre\">result_array</span></code>, the C function may end up throwing an invalid memory access\nexception.</p>\n</div>\n<div class=\"section\" id=\"garbage-collection-safety\">\n<h2>Garbage Collection Safety<a class=\"headerlink\" href=\"#garbage-collection-safety\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>When passing data to a <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a>, it is best to avoid using the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.pointer\" title=\"Base.pointer\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">pointer()</span></code></a>\nfunction. Instead define a convert method and pass the variables directly to\nthe <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a>. <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> automatically arranges that all of its arguments will be\npreserved from garbage collection until the call returns. If a C API will\nstore a reference to memory allocated by Julia, after the <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> returns, you\nmust arrange that the object remains visible to the garbage collector. The\nsuggested way to handle this is to make a global variable of type\n<code class=\"docutils literal\"><span class=\"pre\">Array{Ref,1}</span></code> to hold these values, until the C library notifies you that\nit is finished with them.</p>\n<p>Whenever you have created a pointer to Julia data, you must ensure the original data\nexists until you are done with using the pointer. Many methods in Julia such as\n<a class=\"reference internal\" href=\"../stdlib/c.html#Base.unsafe_load\" title=\"Base.unsafe_load\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">unsafe_load()</span></code></a> and <a class=\"reference internal\" href=\"../stdlib/strings.html#Base.String\" title=\"Base.String\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">String()</span></code></a> make copies of data instead of taking ownership\nof the buffer, so that it is safe to free (or alter) the original data without\naffecting Julia. A notable exception is <a class=\"reference internal\" href=\"../stdlib/strings.html#Base.unsafe_wrap\" title=\"Base.unsafe_wrap\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">unsafe_wrap()</span></code></a> which, for performance\nreasons, shares (or can be told to take ownership of) the underlying buffer.</p>\n<p>The garbage collector does not guarantee any order of finalization. That is, if <code class=\"docutils literal\"><span class=\"pre\">a</span></code>\ncontained a reference to <code class=\"docutils literal\"><span class=\"pre\">b</span></code> and both <code class=\"docutils literal\"><span class=\"pre\">a</span></code> and <code class=\"docutils literal\"><span class=\"pre\">b</span></code> are due for garbage\ncollection, there is no guarantee that <code class=\"docutils literal\"><span class=\"pre\">b</span></code> would be finalized after <code class=\"docutils literal\"><span class=\"pre\">a</span></code>. If\nproper finalization of <code class=\"docutils literal\"><span class=\"pre\">a</span></code> depends on <code class=\"docutils literal\"><span class=\"pre\">b</span></code> being valid, it must be handled in\nother ways.</p>\n</div>\n<div class=\"section\" id=\"non-constant-function-specifications\">\n<h2>Non-constant Function Specifications<a class=\"headerlink\" href=\"#non-constant-function-specifications\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>A <code class=\"docutils literal\"><span class=\"pre\">(name,</span> <span class=\"pre\">library)</span></code> function specification must be a constant expression.\nHowever, it is possible to use computed values as function names by staging\nthrough <code class=\"docutils literal\"><span class=\"pre\">eval</span></code> as follows:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"nd\">@eval</span> <span class=\"k\">ccall</span><span class=\"p\">((</span><span class=\"o\">$</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">(</span><span class=\"s\">&quot;a&quot;</span><span class=\"p\">,</span><span class=\"s\">&quot;b&quot;</span><span class=\"p\">)),</span><span class=\"s\">&quot;lib&quot;</span><span class=\"p\">),</span> <span class=\"o\">...</span>\n</pre></div>\n</div>\n<p>This expression constructs a name using <code class=\"docutils literal\"><span class=\"pre\">string</span></code>, then substitutes this\nname into a new <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> expression, which is then evaluated. Keep in mind that\n<code class=\"docutils literal\"><span class=\"pre\">eval</span></code> only operates at the top level, so within this expression local\nvariables will not be available (unless their values are substituted with\n<code class=\"docutils literal\"><span class=\"pre\">$</span></code>). For this reason, <code class=\"docutils literal\"><span class=\"pre\">eval</span></code> is typically only used to form top-level\ndefinitions, for example when wrapping libraries that contain many\nsimilar functions.</p>\n<p>If your usage is more dynamic, use indirect calls as described in the next section.</p>\n</div>\n<div class=\"section\" id=\"indirect-calls\">\n<h2>Indirect Calls<a class=\"headerlink\" href=\"#indirect-calls\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>The first argument to <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> can also be an expression evaluated at run time.\nIn this case, the expression must evaluate to a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code>,\nwhich will be used as the address of the native function to call.\nThis behavior occurs when the first <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> argument contains references to non-constants,\nsuch as local variables, function arguments, or non-constant globals.</p>\n<p>For example, you might lookup the function via <code class=\"docutils literal\"><span class=\"pre\">dlsym</span></code>,\nthen cache it in a global variable for that session. For example:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"k\">macro</span> <span class=\"n\">dlsym</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"n\">lib</span><span class=\"p\">)</span>\n    <span class=\"n\">z</span><span class=\"p\">,</span> <span class=\"n\">zlocal</span> <span class=\"o\">=</span> <span class=\"n\">gensym</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">)),</span> <span class=\"n\">gensym</span><span class=\"p\">()</span>\n    <span class=\"n\">eval</span><span class=\"p\">(</span><span class=\"n\">current_module</span><span class=\"p\">(),</span><span class=\"o\">:</span><span class=\"p\">(</span><span class=\"kd\">global</span> <span class=\"o\">$</span><span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"nb\">C_NULL</span><span class=\"p\">))</span>\n    <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"n\">esc</span><span class=\"p\">(</span><span class=\"n\">z</span><span class=\"p\">)</span>\n    <span class=\"k\">quote</span>\n        <span class=\"k\">let</span> <span class=\"o\">$</span><span class=\"n\">zlocal</span><span class=\"o\">::</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Void</span><span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"o\">$</span><span class=\"n\">z</span><span class=\"o\">::</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Void</span><span class=\"p\">}</span>\n            <span class=\"k\">if</span> <span class=\"o\">$</span><span class=\"n\">zlocal</span> <span class=\"o\">==</span> <span class=\"nb\">C_NULL</span>\n               <span class=\"o\">$</span><span class=\"n\">zlocal</span> <span class=\"o\">=</span> <span class=\"n\">dlsym</span><span class=\"p\">(</span><span class=\"o\">$</span><span class=\"p\">(</span><span class=\"n\">esc</span><span class=\"p\">(</span><span class=\"n\">lib</span><span class=\"p\">))</span><span class=\"o\">::</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">Void</span><span class=\"p\">},</span> <span class=\"o\">$</span><span class=\"p\">(</span><span class=\"n\">esc</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">)))</span>\n               <span class=\"kd\">global</span> <span class=\"o\">$</span><span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"o\">$</span><span class=\"n\">zlocal</span>\n            <span class=\"k\">end</span>\n            <span class=\"o\">$</span><span class=\"n\">zlocal</span>\n        <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">mylibvar</span> <span class=\"o\">=</span> <span class=\"n\">dlopen</span><span class=\"p\">(</span><span class=\"s\">&quot;mylib&quot;</span><span class=\"p\">)</span>\n<span class=\"k\">ccall</span><span class=\"p\">(</span><span class=\"nd\">@dlsym</span><span class=\"p\">(</span><span class=\"s\">&quot;myfunc&quot;</span><span class=\"p\">,</span> <span class=\"n\">mylibvar</span><span class=\"p\">),</span> <span class=\"kt\">Void</span><span class=\"p\">,</span> <span class=\"p\">())</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"calling-convention\">\n<h2>Calling Convention<a class=\"headerlink\" href=\"#calling-convention\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>The second argument to <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> can optionally be a calling convention\nspecifier (immediately preceding return type). Without any specifier,\nthe platform-default C calling convention is used. Other supported\nconventions are: <code class=\"docutils literal\"><span class=\"pre\">stdcall</span></code>, <code class=\"docutils literal\"><span class=\"pre\">cdecl</span></code>, <code class=\"docutils literal\"><span class=\"pre\">fastcall</span></code>, and <code class=\"docutils literal\"><span class=\"pre\">thiscall</span></code>.\nFor example (from <code class=\"docutils literal\"><span class=\"pre\">base/libc.jl</span></code>) we see the same <code class=\"docutils literal\"><span class=\"pre\">gethostname</span></code> <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> as above,\nbut with the correct signature for Windows:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">hn</span> <span class=\"o\">=</span> <span class=\"kt\">Array</span><span class=\"p\">{</span><span class=\"kt\">UInt8</span><span class=\"p\">}(</span><span class=\"mi\">256</span><span class=\"p\">)</span>\n<span class=\"n\">err</span> <span class=\"o\">=</span> <span class=\"k\">ccall</span><span class=\"p\">(</span><span class=\"o\">:</span><span class=\"n\">gethostname</span><span class=\"p\">,</span> <span class=\"n\">stdcall</span><span class=\"p\">,</span> <span class=\"kt\">Int32</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">Ptr</span><span class=\"p\">{</span><span class=\"kt\">UInt8</span><span class=\"p\">},</span> <span class=\"kt\">UInt32</span><span class=\"p\">),</span> <span class=\"n\">hn</span><span class=\"p\">,</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">hn</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p>For more information, please see the <a class=\"reference external\" href=\"http://llvm.org/docs/LangRef.html#calling-conventions\">LLVM Language Reference</a>.</p>\n</div>\n<div class=\"section\" id=\"accessing-global-variables\">\n<h2>Accessing Global Variables<a class=\"headerlink\" href=\"#accessing-global-variables\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Global variables exported by native libraries can be accessed by name using the\n<a class=\"reference internal\" href=\"../stdlib/c.html#Base.cglobal\" title=\"Base.cglobal\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cglobal()</span></code></a> function. The arguments to <a class=\"reference internal\" href=\"../stdlib/c.html#Base.cglobal\" title=\"Base.cglobal\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">cglobal()</span></code></a> are a symbol specification\nidentical to that used by <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a>, and a type describing the value stored in\nthe variable:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span>julia&gt; cglobal((:errno,:libc), Int32)\nPtr{Int32} @0x00007f418d0816b8\n</pre></div>\n</div>\n<p>The result is a pointer giving the address of the value. The value can be\nmanipulated through this pointer using <a class=\"reference internal\" href=\"../stdlib/c.html#Base.unsafe_load\" title=\"Base.unsafe_load\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">unsafe_load()</span></code></a> and <a class=\"reference internal\" href=\"../stdlib/c.html#Base.unsafe_store!\" title=\"Base.unsafe_store!\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">unsafe_store!()</span></code></a>.</p>\n</div>\n<div class=\"section\" id=\"accessing-data-through-a-pointer\">\n<h2>Accessing Data through a Pointer<a class=\"headerlink\" href=\"#accessing-data-through-a-pointer\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>The following methods are described as &#8220;unsafe&#8221; because a bad pointer\nor type declaration can cause Julia to terminate abruptly.</p>\n<p>Given a <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code>, the contents of type <code class=\"docutils literal\"><span class=\"pre\">T</span></code> can generally be copied from\nthe referenced memory into a Julia object using <code class=\"docutils literal\"><span class=\"pre\">unsafe_load(ptr,</span> <span class=\"pre\">[index])</span></code>.\nThe index argument is optional (default is 1),\nand follows the Julia-convention of 1-based indexing.\nThis function is intentionally similar to the behavior of <a class=\"reference internal\" href=\"../stdlib/collections.html#Base.getindex\" title=\"Base.getindex\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">getindex()</span></code></a> and <a class=\"reference internal\" href=\"../stdlib/collections.html#Base.setindex!\" title=\"Base.setindex!\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">setindex!()</span></code></a>\n(e.g. <code class=\"docutils literal\"><span class=\"pre\">[]</span></code> access syntax).</p>\n<p>The return value will be a new object initialized\nto contain a copy of the contents of the referenced memory.\nThe referenced memory can safely be freed or released.</p>\n<p>If <code class=\"docutils literal\"><span class=\"pre\">T</span></code> is <code class=\"docutils literal\"><span class=\"pre\">Any</span></code>, then the memory is assumed to contain a reference to\na Julia object (a <code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code>), the result will be a reference to this object,\nand the object will not be copied. You must be careful in this case to ensure\nthat the object was always visible to the garbage collector (pointers do not\ncount, but the new reference does) to ensure the memory is not prematurely freed.\nNote that if the object was not originally allocated by Julia, the new object\nwill never be finalized by Julia&#8217;s garbage collector.  If the <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> itself\nis actually a <code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code>, it can be converted back to a Julia object\nreference by <a class=\"reference internal\" href=\"../stdlib/c.html#Base.unsafe_pointer_to_objref\" title=\"Base.unsafe_pointer_to_objref\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">unsafe_pointer_to_objref(ptr)</span></code></a>.\n(Julia values <code class=\"docutils literal\"><span class=\"pre\">v</span></code> can be converted to <code class=\"docutils literal\"><span class=\"pre\">jl_value_t*</span></code> pointers, as\n<code class=\"docutils literal\"><span class=\"pre\">Ptr{Void}</span></code>, by calling <a class=\"reference internal\" href=\"../stdlib/c.html#Base.pointer_from_objref\" title=\"Base.pointer_from_objref\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">pointer_from_objref(v)</span></code></a>.)</p>\n<p>The reverse operation (writing data to a <code class=\"docutils literal\"><span class=\"pre\">Ptr{T}</span></code>), can be performed using\n<a class=\"reference internal\" href=\"../stdlib/c.html#Base.unsafe_store!\" title=\"Base.unsafe_store!\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">unsafe_store!(ptr,</span> <span class=\"pre\">value,</span> <span class=\"pre\">[index])</span></code></a>.  Currently, this is only supported\nfor bitstypes or other pointer-free (<code class=\"docutils literal\"><span class=\"pre\">isbits</span></code>) immutable types.</p>\n<p>Any operation that throws an error is probably currently unimplemented\nand should be posted as a bug so that it can be resolved.</p>\n<p>If the pointer of interest is a plain-data array (bitstype or immutable), the\nfunction <a class=\"reference internal\" href=\"../stdlib/strings.html#Base.unsafe_wrap\" title=\"Base.unsafe_wrap\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">unsafe_wrap(Array,</span> <span class=\"pre\">ptr,dims,[own])</span></code></a> may be\nmore useful. The final parameter should be true if Julia should &#8220;take\nownership&#8221; of the underlying buffer and call <code class=\"docutils literal\"><span class=\"pre\">free(ptr)</span></code> when the returned\n<code class=\"docutils literal\"><span class=\"pre\">Array</span></code> object is finalized.  If the <code class=\"docutils literal\"><span class=\"pre\">own</span></code> parameter is omitted or false,\nthe caller must ensure the buffer remains in existence until all access is\ncomplete.</p>\n<p>Arithmetic on the <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> type in Julia (e.g. using <code class=\"docutils literal\"><span class=\"pre\">+</span></code>) does not behave the\nsame as C&#8217;s pointer arithmetic. Adding an integer to a <code class=\"docutils literal\"><span class=\"pre\">Ptr</span></code> in Julia always\nmoves the pointer by some number of <em>bytes</em>, not elements. This way, the\naddress values obtained from pointer arithmetic do not depend on the\nelement types of pointers.</p>\n</div>\n<div class=\"section\" id=\"thread-safety\">\n<h2>Thread-safety<a class=\"headerlink\" href=\"#thread-safety\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Some C libraries execute their callbacks from a different thread, and\nsince Julia isn&#8217;t thread-safe you&#8217;ll need to take some extra\nprecautions. In particular, you&#8217;ll need to set up a two-layered\nsystem: the C callback should only <em>schedule</em> (via Julia&#8217;s event loop)\nthe execution of your &#8220;real&#8221; callback.\nTo do this, create a <code class=\"docutils literal\"><span class=\"pre\">AsyncCondition</span></code> object and wait on it:</p>\n<div class=\"highlight-julia\"><div class=\"highlight\"><pre><span></span><span class=\"n\">cond</span> <span class=\"o\">=</span> <span class=\"n\">Base</span><span class=\"o\">.</span><span class=\"n\">AsyncCondition</span><span class=\"p\">()</span>\n<span class=\"n\">wait</span><span class=\"p\">(</span><span class=\"n\">cond</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>The callback you pass to C should only execute a <a class=\"reference internal\" href=\"../stdlib/c.html#Base.ccall\" title=\"Base.ccall\"><code class=\"xref jl jl-func docutils literal\"><span class=\"pre\">ccall()</span></code></a> to\n<code class=\"docutils literal\"><span class=\"pre\">:uv_async_send</span></code>, passing <code class=\"docutils literal\"><span class=\"pre\">cb.handle</span></code> as the argument,\ntaking care to avoid any allocations or other interactions with the Julia runtime.</p>\n<p>Note that events may be coalesced, so multiple calls to uv_async_send\nmay result in a single wakeup notification to the condition.</p>\n</div>\n<div class=\"section\" id=\"more-about-callbacks\">\n<h2>More About Callbacks<a class=\"headerlink\" href=\"#more-about-callbacks\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>For more details on how to pass callbacks to C libraries, see this\n<a class=\"reference external\" href=\"http://julialang.org/blog/2013/05/callback\">blog post</a>.</p>\n</div>\n<div class=\"section\" id=\"c\">\n<h2>C++<a class=\"headerlink\" href=\"#c\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Limited support for C++ is provided by the <a class=\"reference external\" href=\"https://github.com/timholy/Cpp.jl\">Cpp</a>,\n<a class=\"reference external\" href=\"https://github.com/ihnorton/Clang.jl\">Clang</a>, and <a class=\"reference external\" href=\"https://github.com/Keno/Cxx.jl\">Cxx</a> packages.</p>\n</div>\n</div>\n\n\n          </div>\n          <footer>\n  \n    <div class=\"rst-footer-buttons\" role=\"navigation\" aria-label=\"footer navigation\">\n      \n        <a href=\"handling-operating-system-variation.html\" class=\"btn btn-neutral float-right\" title=\"Handling Operating System Variation\">Next <span class=\"fa fa-arrow-circle-right\"></span></a>\n      \n      \n        <a href=\"running-external-programs.html\" class=\"btn btn-neutral\" title=\"Running External Programs\"><span class=\"fa fa-arrow-circle-left\"></span> Previous</a>\n      \n    </div>\n  \n\n  <hr/>\n\n  <div role=\"contentinfo\">\n    <p>\n    </p>\n  </div>\n\n  <a href=\"https://github.com/snide/sphinx_rtd_theme\">Sphinx theme</a> provided by <a href=\"https://readthedocs.org\">Read the Docs</a>\n</footer>\n        </div>\n      </div>\n\n    </section>\n\n  </div>\n  \n\n  \n\n    <script type=\"text/javascript\">\n        var DOCUMENTATION_OPTIONS = {\n            URL_ROOT:'../',\n            VERSION:'0.5.1',\n            COLLAPSE_INDEX:false,\n            FILE_SUFFIX:'.html',\n            HAS_SOURCE:  true\n        };\n    </script>\n      <script type=\"text/javascript\" src=\"../_static/jquery.js\"></script>\n      <script type=\"text/javascript\" src=\"../_static/underscore.js\"></script>\n      <script type=\"text/javascript\" src=\"../_static/doctools.js\"></script>\n      <script type=\"text/javascript\" src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>\n\n  \n\n  \n  \n    <script type=\"text/javascript\" src=\"../_static/js/theme.js\"></script>\n  \n\n  \n  \n  <script type=\"text/javascript\">\n      jQuery(function () {\n          SphinxRtdTheme.StickyNav.enable();\n      });\n  </script>\n   \n\n</body>\n</html>",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/stdlib/libdl.rst": ".. module:: Libdl\n\n****************\n Dynamic Linker\n****************\n\n.. currentmodule:: Base.Libdl\n\nThe names in :mod:`Base.Libdl` are not exported and need to be called e.g. as ``Libdl.dlopen()``.\n\n.. function:: dlopen(libfile::AbstractString [, flags::Integer])\n\n   .. Docstring generated from Julia source\n\n   Load a shared library, returning an opaque handle.\n\n   The optional flags argument is a bitwise-or of zero or more of ``RTLD_LOCAL``\\ , ``RTLD_GLOBAL``\\ , ``RTLD_LAZY``\\ , ``RTLD_NOW``\\ , ``RTLD_NODELETE``\\ , ``RTLD_NOLOAD``\\ , ``RTLD_DEEPBIND``\\ , and ``RTLD_FIRST``\\ . These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default ``dlopen`` flags are ``RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL`` while on other platforms the defaults are ``RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL``\\ . An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance ``RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL`` allows the library's symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.\n\n.. function:: dlopen_e(libfile::AbstractString [, flags::Integer])\n\n   .. Docstring generated from Julia source\n\n   Similar to :func:`dlopen`\\ , except returns a ``NULL`` pointer instead of raising errors.\n\n.. data:: RTLD_DEEPBIND\n          RTLD_FIRST\n          RTLD_GLOBAL\n          RTLD_LAZY\n          RTLD_LOCAL\n          RTLD_NODELETE\n          RTLD_NOLOAD\n          RTLD_NOW\n\n   .. Docstring generated from Julia source\n\n   Enum constant for :func:`dlopen`\\ . See your platform man page for details, if applicable.\n\n.. function:: dlsym(handle, sym)\n\n   .. Docstring generated from Julia source\n\n   Look up a symbol from a shared library handle, return callable function pointer on success.\n\n.. function:: dlsym_e(handle, sym)\n\n   .. Docstring generated from Julia source\n\n   Look up a symbol from a shared library handle, silently return ``NULL`` pointer on lookup failure.\n\n.. function:: dlclose(handle)\n\n   .. Docstring generated from Julia source\n\n   Close shared library referenced by handle.\n\n.. data:: dlext\n\n   .. Docstring generated from Julia source\n\n   File extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.\n\n.. function:: find_library(names, locations)\n\n   .. Docstring generated from Julia source\n\n   Searches for the first library in ``names`` in the paths in the ``locations`` list, ``DL_LOAD_PATH``\\ , or system library paths (in that order) which can successfully be dlopen'd. On success, the return value will be one of the names (potentially prefixed by one of the paths in locations). This string can be assigned to a ``global const`` and used as the library name in future ``ccall``\\ 's. On failure, it returns the empty string.\n\n.. data:: DL_LOAD_PATH\n\n   .. Docstring generated from Julia source\n\n   When calling :func:`dlopen`\\ , the paths in this list will be searched first, in order, before searching the system locations for a valid library handle.\n\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/stdlib/c.rst": ".. currentmodule:: Base\n\n*************\n C Interface\n*************\n\n.. function:: ccall((symbol, library) or function_pointer, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n\n   .. Docstring generated from Julia source\n\n   Call function in C-exported shared library, specified by ``(function name, library)`` tuple, where each component is a string or symbol.\n\n   Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression. Alternatively, ``ccall`` may also be used to call a function pointer, such as one returned by ``dlsym``\\ .\n\n   Each ``ArgumentValue`` to the ``ccall`` will be converted to the corresponding ``ArgumentType``\\ , by automatic insertion of calls to ``unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))``\\ . (See also the documentation for each of these functions for further details.) In most cases, this simply results in a call to ``convert(ArgumentType, ArgumentValue)``\\ .\n\n.. function:: cglobal((symbol, library) [, type=Void])\n\n   .. Docstring generated from Julia source\n\n   Obtain a pointer to a global variable in a C-exported shared library, specified exactly as in ``ccall``\\ . Returns a ``Ptr{Type}``\\ , defaulting to ``Ptr{Void}`` if no Type argument is supplied. The values can be read or written by ``unsafe_load`` or ``unsafe_store!``\\ , respectively.\n\n.. function:: cfunction(function::Function, ReturnType::Type, (ArgumentTypes...))\n\n   .. Docstring generated from Julia source\n\n   Generate C-callable function pointer from Julia function. Type annotation of the return value in the callback function is a must for situations where Julia cannot infer the return type automatically.\n\n   For example:\n\n   .. code-block:: julia\n\n       function foo()\n           # body\n\n           retval::Float64\n       end\n\n       bar = cfunction(foo, Float64, ())\n\n.. function:: unsafe_convert(T,x)\n\n   .. Docstring generated from Julia source\n\n   Convert ``x`` to a value of type ``T``\n\n   In cases where ``convert`` would need to take a Julia object and turn it into a ``Ptr``\\ , this function should be used to define and perform that conversion.\n\n   Be careful to ensure that a Julia reference to ``x`` exists as long as the result of this function will be used. Accordingly, the argument ``x`` to this function should never be an expression, only a variable name or field reference. For example, ``x=a.b.c`` is acceptable, but ``x=[a,b,c]`` is not.\n\n   The ``unsafe`` prefix on this function indicates that using the result of this function after the ``x`` argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.\n\n.. function:: cconvert(T,x)\n\n   .. Docstring generated from Julia source\n\n   Convert ``x`` to a value of type ``T``\\ , typically by calling ``convert(T,x)``\n\n   In cases where ``x`` cannot be safely converted to ``T``\\ , unlike ``convert``\\ , ``cconvert`` may return an object of a type different from ``T``\\ , which however is suitable for ``unsafe_convert`` to handle.\n\n   Neither ``convert`` nor ``cconvert`` should take a Julia object and turn it into a ``Ptr``\\ .\n\n.. function:: unsafe_load(p::Ptr{T}, [i::Integer=1])\n\n   .. Docstring generated from Julia source\n\n   Load a value of type ``T`` from the address of the ith element (1-indexed) starting at ``p``\\ . This is equivalent to the C expression ``p[i-1]``\\ .\n\n   The ``unsafe`` prefix on this function indicates that no validation is performed on the pointer ``p`` to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.\n\n.. function:: unsafe_store!(p::Ptr{T}, x, [i::Integer=1])\n\n   .. Docstring generated from Julia source\n\n   Store a value of type ``T`` to the address of the ith element (1-indexed) starting at ``p``\\ . This is equivalent to the C expression ``p[i-1] = x``\\ .\n\n   The ``unsafe`` prefix on this function indicates that no validation is performed on the pointer ``p`` to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n.. function:: unsafe_copy!(dest::Ptr{T}, src::Ptr{T}, N)\n\n   .. Docstring generated from Julia source\n\n   Copy ``N`` elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.\n\n   The ``unsafe`` prefix on this function indicates that no validation is performed on the pointers ``dest`` and ``src`` to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n.. function:: unsafe_copy!(dest::Array, do, src::Array, so, N)\n\n   .. Docstring generated from Julia source\n\n   Copy ``N`` elements from a source array to a destination, starting at offset ``so`` in the source and ``do`` in the destination (1-indexed).\n\n   The ``unsafe`` prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n.. function:: copy!(dest, src)\n\n   .. Docstring generated from Julia source\n\n   Copy all elements from collection ``src`` to array ``dest``\\ . Returns ``dest``\\ .\n\n.. function:: copy!(dest, do, src, so, N)\n\n   .. Docstring generated from Julia source\n\n   Copy ``N`` elements from collection ``src`` starting at offset ``so``\\ , to array ``dest`` starting at offset ``do``\\ . Returns ``dest``\\ .\n\n.. function:: pointer(array [, index])\n\n   .. Docstring generated from Julia source\n\n   Get the native address of an array or string element. Be careful to ensure that a Julia reference to ``a`` exists as long as this pointer will be used. This function is \"unsafe\" like ``unsafe_convert``\\ .\n\n   Calling ``Ref(array[, index])`` is generally preferable to this function.\n\n.. function:: unsafe_wrap(Array, pointer::Ptr{T}, dims, own=false)\n\n   .. Docstring generated from Julia source\n\n   Wrap a Julia ``Array`` object around the data at the address given by ``pointer``\\ , without making a copy.  The pointer element type ``T`` determines the array element type. ``dims`` is either an integer (for a 1d array) or a tuple of the array dimensions. ``own`` optionally specifies whether Julia should take ownership of the memory, calling ``free`` on the pointer when the array is no longer referenced.\n\n   This function is labelled \"unsafe\" because it will crash if ``pointer`` is not a valid memory address to data of the requested length.\n\n.. function:: pointer_from_objref(object_instance)\n\n   .. Docstring generated from Julia source\n\n   Get the memory address of a Julia object as a ``Ptr``\\ . The existence of the resulting ``Ptr`` will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the ``Ptr`` will be used.\n\n.. function:: unsafe_pointer_to_objref(p::Ptr)\n\n   .. Docstring generated from Julia source\n\n   Convert a ``Ptr`` to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered \"unsafe\" and should be used with care.\n\n.. function:: disable_sigint(f::Function)\n\n   .. Docstring generated from Julia source\n\n   Disable Ctrl-C handler during execution of a function on the current task, for calling external code that may call julia code that is not interrupt safe. Intended to be called using ``do`` block syntax as follows:\n\n   .. code-block:: julia\n\n       disable_sigint() do\n           # interrupt-unsafe code\n           ...\n       end\n\n   This is not needed on worker threads (``Threads.threadid() != 1``\\ ) since the ``InterruptException`` will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.\n\n.. function:: reenable_sigint(f::Function)\n\n   .. Docstring generated from Julia source\n\n   Re-enable Ctrl-C handler during execution of a function. Temporarily reverses the effect of ``disable_sigint``\\ .\n\n.. function:: systemerror(sysfunc, iftrue)\n\n   .. Docstring generated from Julia source\n\n   Raises a ``SystemError`` for ``errno`` with the descriptive string ``sysfunc`` if ``iftrue`` is ``true``\n\n.. data:: Ptr{T}\n\n   .. Docstring generated from Julia source\n\n   A memory address referring to data of type ``T``\\ .  However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.\n\n.. data:: Ref{T}\n\n   .. Docstring generated from Julia source\n\n   An object that safely references data of type ``T``\\ . This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the ``Ref`` itself is referenced.\n\n   When passed as a ``ccall`` argument (either as a ``Ptr`` or ``Ref`` type), a ``Ref`` object will be converted to a native pointer to the data it references.\n\n   There is no invalid (NULL) ``Ref``\\ .\n\n.. data:: Cchar\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``char`` c-type.\n\n.. data:: Cuchar\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``unsigned char`` c-type (``UInt8``\\ ).\n\n.. data:: Cshort\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``signed short`` c-type (``Int16``\\ ).\n\n.. data:: Cushort\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``unsigned short`` c-type (``UInt16``\\ ).\n\n.. data:: Cint\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``signed int`` c-type (``Int32``\\ ).\n\n.. data:: Cuint\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``unsigned int`` c-type (``UInt32``\\ ).\n\n.. data:: Clong\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``signed long`` c-type.\n\n.. data:: Culong\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``unsigned long`` c-type.\n\n.. data:: Clonglong\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``signed long long`` c-type (``Int64``\\ ).\n\n.. data:: Culonglong\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``unsigned long long`` c-type (``UInt64``\\ ).\n\n.. data:: Cintmax_t\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``intmax_t`` c-type (``Int64``\\ ).\n\n.. data:: Cuintmax_t\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``uintmax_t`` c-type (``UInt64``\\ ).\n\n.. data:: Csize_t\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``size_t`` c-type (``UInt``\\ ).\n\n.. data:: Cssize_t\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``ssize_t`` c-type.\n\n.. data:: Cptrdiff_t\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``ptrdiff_t`` c-type (``Int``\\ ).\n\n.. data:: Cwchar_t\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``wchar_t`` c-type (``Int32``\\ ).\n\n.. data:: Cfloat\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``float`` c-type (``Float32``\\ ).\n\n.. data:: Cdouble\n\n   .. Docstring generated from Julia source\n\n   Equivalent to the native ``double`` c-type (``Float64``\\ ).\n\n****************\n LLVM Interface\n****************\n\n.. function:: llvmcall(IR::String, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n              llvmcall((declarations::String, IR::String), ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n\n   .. Docstring generated from Julia source\n\n   Call LLVM IR string in the first argument. Similar to an LLVM function ``define`` block, arguments are available as consecutive unnamed SSA variables (%0, %1, etc.).\n\n   The optional declarations string contains external functions declarations that are necessary for llvm to compile the IR string. Multiple declarations can be passed in by separating them with line breaks.\n\n   Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.\n\n   Each ``ArgumentValue`` to ``llvmcall`` will be converted to the corresponding ``ArgumentType``\\ , by automatic insertion of calls to ``unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))``\\ . (see also the documentation for each of these functions for further details). In most cases, this simply results in a call to ``convert(ArgumentType, ArgumentValue)``\\ .\n\n   See ``test/llvmcall.jl`` for usage examples.\n\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/manual/calling-c-and-fortran-code.rst": ".. _man-calling-c-and-fortran-code:\n\n.. currentmodule:: Base\n\n****************************\n Calling C and Fortran Code\n****************************\n\nThough most code can be written in Julia, there are many high-quality,\nmature libraries for numerical computing already written in C and\nFortran. To allow easy use of this existing code, Julia makes it simple\nand efficient to call C and Fortran functions. Julia has a \"no\nboilerplate\" philosophy: functions can be called directly from Julia\nwithout any \"glue\" code, code generation, or compilation \u2014 even from the\ninteractive prompt. This is accomplished just by making an appropriate call\nwith :func:`ccall` syntax, which looks like an ordinary function call.\n\nThe code to be called must be available as a shared library. Most C and\nFortran libraries ship compiled as shared libraries already, but if you\nare compiling the code yourself using GCC (or Clang), you will need to\nuse the ``-shared`` and ``-fPIC`` options. The machine instructions\ngenerated by Julia's JIT are the same as a native C call would be, so\nthe resulting overhead is the same as calling a library function from C\ncode. (Non-library function calls in both C and Julia can be inlined and\nthus may have even less overhead than calls to shared library functions.\nWhen both libraries and executables are generated by LLVM, it is\npossible to perform whole-program optimizations that can even optimize\nacross this boundary, but Julia does not yet support that. In the\nfuture, however, it may do so, yielding even greater performance gains.)\n\nShared libraries and functions are referenced by a tuple of the\nform ``(:function, \"library\")`` or ``(\"function\", \"library\")`` where ``function``\nis the C-exported function name. ``library`` refers to the shared library\nname: shared libraries available in the (platform-specific) load path\nwill be resolved by name, and if necessary a direct path may be specified.\n\nA function name may be used alone in place of the tuple (just\n``:function`` or ``\"function\"``). In this case the name is resolved within\nthe current process. This form can be used to call C library functions,\nfunctions in the Julia runtime, or functions in an application linked to\nJulia.\n\nBy default, Fortran compilers `generate mangled names\n<https://en.wikipedia.org/wiki/Name_mangling#Fortran>`_\n(for example, converting function names to lowercase or uppercase,\noften appending an underscore), and so to call a Fortran function via\n:func:`ccall` you must pass the mangled identifier corresponding to the rule\nfollowed by your Fortran compiler.  Also, when calling a Fortran\nfunction, all inputs must be passed by reference.\n\nFinally, you can use :func:`ccall` to actually generate a call to the\nlibrary function. Arguments to :func:`ccall` are as follows:\n\n1. (:function, \"library\") pair (must be a constant, but see below).\n\n2. Return type (see below for mapping the declared C type to Julia)\n\n   - This argument will be evaluated at compile-time.\n\n3. A tuple of input types. The input types must be written as a literal tuple,\n   not a tuple-valued variable or expression.\n\n   - This argument will be evaluated at compile-time.\n\n4. The following arguments, if any, are the actual argument values\n   passed to the function.\n\nAs a complete but simple example, the following calls the ``clock``\nfunction from the standard C library::\n\n    julia> t = ccall( (:clock, \"libc\"), Int32, ())\n    2292761\n\n    julia> t\n    2292761\n\n    julia> typeof(ans)\n    Int32\n\n``clock`` takes no arguments and returns an ``Int32``. One common gotcha\nis that a 1-tuple must be written with a trailing comma. For\nexample, to call the ``getenv`` function to get a pointer to the value\nof an environment variable, one makes a call like this::\n\n    julia> path = ccall((:getenv, \"libc\"), Cstring, (Cstring,), \"SHELL\")\n    Cstring(@0x00007fff5fbffc45)\n\n    julia> unsafe_string(path)\n    \"/bin/bash\"\n\nNote that the argument type tuple must be written as ``(Cstring,)``,\nrather than ``(Cstring)``. This is because ``(Cstring)`` is just\nthe expression ``Cstring`` surrounded by parentheses, rather than\na 1-tuple containing ``Cstring``:\n\n.. doctest::\n\n    julia> (Cstring)\n    Cstring\n\n    julia> (Cstring,)\n    (Cstring,)\n\nIn practice, especially when providing reusable functionality, one\ngenerally wraps :func:`ccall` uses in Julia functions that set up arguments\nand then check for errors in whatever manner the C or Fortran function\nindicates them, propagating to the Julia caller as exceptions. This is\nespecially important since C and Fortran APIs are notoriously\ninconsistent about how they indicate error conditions. For example, the\n``getenv`` C library function is wrapped in the following Julia function,\nwhich is a simplified version of the actual definition from\n`env.jl <https://github.com/JuliaLang/julia/blob/release-0.5/base/env.jl>`_::\n\n    function getenv(var::AbstractString)\n      val = ccall((:getenv, \"libc\"),\n                  Cstring, (Cstring,), var)\n      if val == C_NULL\n        error(\"getenv: undefined variable: \", var)\n      end\n      unsafe_string(val)\n    end\n\nThe C ``getenv`` function indicates an error by returning ``NULL``, but\nother standard C functions indicate errors in various different ways,\nincluding by returning -1, 0, 1 and other special values. This wrapper\nthrows an exception clearly indicating the problem if the caller tries\nto get a non-existent environment variable::\n\n    julia> getenv(\"SHELL\")\n    \"/bin/bash\"\n\n    julia> getenv(\"FOOBAR\")\n    getenv: undefined variable: FOOBAR\n\nHere is a slightly more complex example that discovers the local\nmachine's hostname::\n\n    function gethostname()\n      hostname = Array{UInt8}(128)\n      ccall((:gethostname, \"libc\"), Int32,\n            (Ptr{UInt8}, Csize_t),\n            hostname, sizeof(hostname))\n      hostname[end] = 0; # ensure null-termination\n      return unsafe_string(pointer(hostname))\n    end\n\nThis example first allocates an array of bytes, then calls the C library\nfunction ``gethostname`` to fill the array in with the hostname, takes a\npointer to the hostname buffer, and converts the pointer to a Julia\nstring, assuming that it is a NUL-terminated C string. It is common for\nC libraries to use this pattern of requiring the caller to allocate\nmemory to be passed to the callee and filled in. Allocation of memory\nfrom Julia like this is generally accomplished by creating an\nuninitialized array and passing a pointer to its data to the C function.\nThis is why we don't use the ``Cstring`` type here: as the array is\nuninitialized, it could contain NUL bytes. Converting to a ``Cstring`` as\npart of the :func:`ccall` checks for contained NUL bytes and could therefore\nthrow a conversion error.\n\nCreating C-Compatible Julia Function Pointers\n---------------------------------------------\n\nIt is possible to pass Julia functions to native C functions that accept\nfunction pointer arguments. For example, to match C prototypes of the form::\n\n    typedef returntype (*functiontype)(argumenttype,...)\n\nThe function :func:`cfunction` generates the C-compatible function pointer for\na call to a Julia library function.\nArguments to :func:`cfunction` are as follows:\n\n1. A Julia Function\n\n2. Return type\n\n3. A tuple of input types\n\nA classic example is the standard C library ``qsort`` function,\ndeclared as::\n\n    void qsort(void *base, size_t nmemb, size_t size,\n               int(*compare)(const void *a, const void *b));\n\nThe ``base`` argument is a pointer to an array of length ``nmemb``, with elements of\n``size`` bytes each. ``compare`` is a callback function which takes pointers to two\nelements ``a`` and ``b`` and returns an integer less/greater than zero if ``a`` should\nappear before/after ``b`` (or zero if any order is permitted). Now, suppose that we\nhave a 1d array ``A`` of values in Julia that we want to sort using the ``qsort``\nfunction (rather than Julia's built-in ``sort`` function). Before we worry about calling\n``qsort`` and passing arguments, we need to write a comparison function that works for\nsome arbitrary type T::\n\n    function mycompare{T}(a::T, b::T)\n        return convert(Cint, a < b ? -1 : a > b ? +1 : 0)::Cint\n    end\n\nNotice that we have to be careful about the return type: ``qsort`` expects a function\nreturning a C ``int``, so we must be sure to return ``Cint`` via a call to ``convert``\nand a ``typeassert``.\n\nIn order to pass this function to C, we obtain its address using the function ``cfunction``::\n\n    const mycompare_c = cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}))\n\n:func:`cfunction` accepts three arguments: the Julia function (``mycompare``),\nthe return type (``Cint``), and a tuple of the argument types, in this case to\nsort an array of ``Cdouble`` (``Float64``) elements.\n\nThe final call to ``qsort`` looks like this::\n\n    A = [1.3, -2.7, 4.4, 3.1]\n    ccall(:qsort, Void, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Void}),\n          A, length(A), sizeof(eltype(A)), mycompare_c)\n\nAfter this executes, ``A`` is changed to the sorted array ``[-2.7, 1.3, 3.1, 4.4]``.\nNote that Julia knows how to convert an array into a ``Ptr{Cdouble}``, how to compute\nthe size of a type in bytes (identical to C's ``sizeof`` operator), and so on.\nFor fun, try inserting a ``println(\"mycompare($a,$b)\")`` line into ``mycompare``, which\nwill allow you to see the comparisons that ``qsort`` is performing (and to verify that\nit is really calling the Julia function that you passed to it).\n\n\nMapping C Types to Julia\n------------------------\n\nIt is critical to exactly match the declared C type with its declaration\nin Julia. Inconsistencies can cause code that works correctly on one system\nto fail or produce indeterminate results on a different system.\n\nNote that no C header files are used anywhere in the process of calling C\nfunctions: you are responsible for making sure that your Julia types and\ncall signatures accurately reflect those in the C header file. (The `Clang\npackage <https://github.com/ihnorton/Clang.jl>`_ can be used to auto-generate\nJulia code from a C header file.)\n\nAuto-conversion:\n~~~~~~~~~~~~~~~~\n\nJulia automatically inserts calls to the :func:`cconvert` function to convert\neach argument to the specified type. For example, the following call::\n\n    ccall((:foo, \"libfoo\"), Void, (Int32, Float64), x, y)\n\nwill behave as if the following were written::\n\n    ccall((:foo, \"libfoo\"), Void, (Int32, Float64),\n          Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),\n          Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))\n\n:func:`cconvert` normally just calls :func:`convert`, but can be defined to return\nan arbitrary new object more appropriate for passing to C. For example,\nthis is used to convert an ``Array`` of objects (e.g. strings) to an\narray of pointers.\n\n:func:`unsafe_convert` handles conversion to ``Ptr`` types. It is considered\nunsafe because converting an object to a native pointer can hide the object\nfrom the garbage collector, causing it to be freed prematurely.\n\nType Correspondences:\n~~~~~~~~~~~~~~~~~~~~~\n\nFirst, a review of some relevant Julia type terminology:\n\n.. rst-class:: text-wrap\n\n==============================  ==============================  ======================================================\nSyntax / Keyword                Example                         Description\n==============================  ==============================  ======================================================\n``type``                        ``String``                      \"Leaf Type\" :: A group of related data that includes\n                                                                a type-tag, is managed by the Julia GC, and\n                                                                is defined by object-identity.\n                                                                The type parameters of a leaf type must be fully defined\n                                                                (no ``TypeVars`` are allowed)\n                                                                in order for the instance to be constructed.\n\n``abstract``                    ``Any``,                        \"Super Type\" :: A super-type (not a leaf-type)\n                                ``AbstractArray{T,N}``,         that cannot be instantiated, but can be used to\n                                ``Complex{T}``                  describe a group of types.\n\n``{T}``                         ``Vector{Int}``                 \"Type Parameter\" :: A specialization of a type\n                                                                (typically used for dispatch or storage optimization).\n\n                                                                \"TypeVar\" :: The ``T`` in the type parameter declaration\n                                                                is referred to as a TypeVar (short for type variable).\n\n``bitstype``                    ``Int``,                        \"Bits Type\" :: A type with no fields, but a size. It\n                                ``Float64``                     is stored and defined by-value.\n\n``immutable``                   ``Pair{Int,Int}``               \"Immutable\" :: A type with all fields defined to be\n                                                                constant. It is defined by-value. And may be stored\n                                                                with a type-tag.\n\n                                ``Complex128`` (``isbits``)     \"Is-Bits\" :: A ``bitstype``, or an ``immutable`` type\n                                                                where all fields are other ``isbits`` types. It is\n                                                                defined by-value, and is stored without a type-tag.\n\n``type ...; end``               ``nothing``                     \"Singleton\" :: a Leaf Type or Immutable with no fields.\n\n``(...)`` or ``tuple(...)```    ``(1,2,3)``                     \"Tuple\" :: an immutable data-structure similar to an\n                                                                anonymous immutable type, or a constant array.\n                                                                Represented as either an array or a struct.\n\n``typealias``                   Not applicable here             Type aliases, and other similar mechanisms of\n                                                                doing type indirection, are resolved to their base\n                                                                type (this includes assigning a type to another name,\n                                                                or getting the type out of a function call).\n==============================  ==============================  ======================================================\n\nBits Types:\n~~~~~~~~~~~\n\nThere are several special types to be aware of, as no other type can be defined to behave the same:\n\n``Float32``\n    Exactly corresponds to the ``float`` type in C (or ``REAL*4`` in Fortran).\n\n``Float64``\n    Exactly corresponds to the ``double`` type in C (or ``REAL*8`` in Fortran).\n\n``Complex64``\n    Exactly corresponds to the ``complex float`` type in C (or ``COMPLEX*8`` in Fortran).\n\n``Complex128``\n    Exactly corresponds to the ``complex double`` type in C (or ``COMPLEX*16`` in Fortran).\n\n``Signed``\n    Exactly corresponds to the ``signed`` type annotation in C (or any ``INTEGER`` type in Fortran). Any Julia type that is not a subtype of ``Signed`` is assumed to be unsigned.\n\n``Ref{T}``\n    Behaves like a ``Ptr{T}`` that owns its memory.\n\n``Array{T,N}``\n    When an array is passed to C as a ``Ptr{T}`` argument, it is\n    not reinterpret-cast: Julia requires that the element type of the\n    array matches ``T``, and the address of the first element is passed.\n\n    Therefore, if an ``Array`` contains data in the wrong format, it will\n    have to be explicitly converted using a call such as ``trunc(Int32,a)``.\n\n    To pass an array ``A`` as a pointer of a different type *without*\n    converting the data beforehand (for example, to pass a ``Float64`` array\n    to a function that operates on uninterpreted bytes), you can\n    declare the argument as ``Ptr{Void}``.\n\n    If an array of eltype ``Ptr{T}`` is passed as a ``Ptr{Ptr{T}}`` argument,\n    :func:`Base.cconvert` will attempt to first make a null-terminated copy of the array with\n    each element replaced by its :func:`cconvert` version. This allows, for example, passing an ``argv``\n    pointer array of type ``Vector{String}`` to an argument of type ``Ptr{Ptr{Cchar}}``.\n\nOn all systems we currently support, basic C/C++ value types may be\ntranslated to Julia types as follows. Every C type also has a corresponding\nJulia type with the same name, prefixed by C. This can help for writing portable code (and remembering that an ``int`` in C is not the same as an ``Int`` in Julia).\n\n**System Independent:**\n\n.. rst-class:: text-wrap\n\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| C name                            | Fortran name    | Standard Julia Alias | Julia Base Type                   |\n+===================================+=================+======================+===================================+\n| ``unsigned char``                 | ``CHARACTER``   | ``Cuchar``           | ``UInt8``                         |\n|                                   |                 |                      |                                   |\n| ``bool`` (C++)                    |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``short``                         | ``INTEGER*2``   | ``Cshort``           | ``Int16``                         |\n|                                   |                 |                      |                                   |\n|                                   | ``LOGICAL*2``   |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``unsigned short``                |                 | ``Cushort``          | ``UInt16``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``int``                           | ``INTEGER*4``   | ``Cint``             | ``Int32``                         |\n|                                   |                 |                      |                                   |\n| ``BOOL`` (C, typical)             | ``LOGICAL*4``   |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``unsigned int``                  |                 | ``Cuint``            | ``UInt32``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``long long``                     | ``INTEGER*8``   | ``Clonglong``        | ``Int64``                         |\n|                                   |                 |                      |                                   |\n|                                   | ``LOGICAL*8``   |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``unsigned long long``            |                 | ``Culonglong``       | ``UInt64``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``intmax_t``                      |                 | ``Cintmax_t``        | ``Int64``                         |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``uintmax_t``                     |                 | ``Cuintmax_t``       | ``UInt64``                        |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``float``                         | ``REAL*4i``     | ``Cfloat``           | ``Float32``                       |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``double``                        | ``REAL*8``      | ``Cdouble``          | ``Float64``                       |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``complex float``                 | ``COMPLEX*8``   | ``Complex64``        | ``Complex{Float32}``              |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``complex double``                | ``COMPLEX*16``  | ``Complex128``       | ``Complex{Float64}``              |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``ptrdiff_t``                     |                 | ``Cptrdiff_t``       | ``Int``                           |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``ssize_t``                       |                 | ``Cssize_t``         | ``Int``                           |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``size_t``                        |                 | ``Csize_t``          | ``UInt``                          |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``void``                          |                 |                      | ``Void``                          |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``void`` and                      |                 |                      | ``Union{}``                       |\n| ``[[noreturn]]`` or ``_Noreturn`` |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``void*``                         |                 |                      | ``Ptr{Void}``                     |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``T*`` (where T represents an     |                 |                      | ``Ref{T}``                        |\n| appropriately defined type)       |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``char*``                         | ``CHARACTER*N`` |                      | ``Cstring`` if NUL-terminated, or |\n| (or ``char[]``, e.g. a string)    |                 |                      | ``Ptr{UInt8}`` if not             |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``char**`` (or ``*char[]``)       |                 |                      | ``Ptr{Ptr{UInt8}}``               |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``jl_value_t*``                   |                 |                      | ``Any``                           |\n| (any Julia Type)                  |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``jl_value_t**``                  |                 |                      | ``Ref{Any}``                      |\n| (a reference to a Julia Type)     |                 |                      |                                   |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``va_arg``                        |                 |                      | Not supported                     |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n| ``...``                           |                 |                      | ``T...`` (where ``T``             |\n| (variadic function specification) |                 |                      | is one of the above types,        |\n|                                   |                 |                      | variadic functions of different   |\n|                                   |                 |                      | argument types are not supported) |\n+-----------------------------------+-----------------+----------------------+-----------------------------------+\n\nThe ``Cstring`` type is essentially a synonym for ``Ptr{UInt8}``, except the conversion to ``Cstring`` throws an\nerror if the Julia string contains any embedded NUL characters (which would cause the string to be silently\ntruncated if the C routine treats NUL as the terminator).  If you are passing a ``char*`` to a C routine that\ndoes not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that\nyour Julia string does not contain NUL and want to skip the check, you can use ``Ptr{UInt8}`` as the argument type.\n``Cstring`` can also be used as the :func:`ccall` return type, but in that case it obviously does not introduce any extra\nchecks and is only meant to improve readability of the call.\n\n**System-dependent:**\n\n======================  ======================  =======\nC name                  Standard Julia Alias    Julia Base Type\n======================  ======================  =======\n``char``                ``Cchar``               ``Int8`` (x86, x86_64)\n\n                                                ``UInt8`` (powerpc, arm)\n\n``long``                ``Clong``               ``Int`` (UNIX)\n\n                                                ``Int32`` (Windows)\n\n``unsigned long``       ``Culong``              ``UInt`` (UNIX)\n\n                                                ``UInt32`` (Windows)\n\n``wchar_t``             ``Cwchar_t``            ``Int32`` (UNIX)\n\n                                                ``UInt16`` (Windows)\n======================  ======================  =======\n\n.. note::\n\n    When calling a Fortran function, all inputs must be passed by reference, so\n    all type correspondences above should contain an additional ``Ptr{..}`` or\n    ``Ref{..}`` wrapper around their type specification.\n\n.. warning::\n\n    For string arguments (``char*``) the Julia type should be ``Cstring`` (if NUL-\n    terminated data is expected) or either ``Ptr{Cchar}`` or ``Ptr{UInt8}``\n    otherwise (these two pointer types have the same effect), as described above,\n    not ``String``. Similarly, for array arguments (``T[]`` or ``T*``), the\n    Julia type should again be ``Ptr{T}``, not ``Vector{T}``.\n\n.. warning::\n\n    Julia's ``Char`` type is 32 bits, which is not the same as the wide character\n    type (``wchar_t`` or ``wint_t``) on all platforms.\n\n.. warning::\n\n    A return type of ``Union{}`` means the function will not return\n    i.e. C++11 ``[[noreturn]]`` or C11 ``_Noreturn`` (e.g. ``jl_throw`` or\n    ``longjmp``). Do not use this for functions that return\n    no value (``void``) but do return.\n\n.. note::\n\n    For ``wchar_t*`` arguments, the Julia type should be ``Cwstring`` (if the C\n    routine expects a NUL-terminated string) or ``Ptr{Cwchar_t}`` otherwise. Note\n    also that UTF-8 string data in Julia is internally NUL-terminated, so it can\n    be passed to C functions expecting NUL-terminated data without making a copy\n    (but using the ``Cwstring`` type will cause an error to be thrown if the string\n    itself contains NUL characters).\n\n.. note::\n\n    C functions that take an argument of the type ``char**`` can be called by\n    using a ``Ptr{Ptr{UInt8}}`` type within Julia. For example, C functions of the\n    form::\n\n        int main(int argc, char **argv);\n\n    can be called via the following Julia code::\n\n        argv = [ \"a.out\", \"arg1\", \"arg2\" ]\n        ccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)\n\n.. note::\n\n    A C function declared to return ``Void`` will return the value ``nothing`` in\n    Julia.\n\nStruct Type correspondences\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nComposite types, aka ``struct`` in C or ``TYPE`` in Fortran90\n(or ``STRUCTURE`` / ``RECORD`` in some variants of F77),\ncan be mirrored in Julia by creating a ``type`` or ``immutable``\ndefinition with the same field layout.\n\nWhen used recursively, ``isbits`` types are stored inline.\nAll other types are stored as a pointer to the data.\nWhen mirroring a struct used by-value inside another struct in C,\nit is imperative that you do not attempt to manually copy the fields over,\nas this will not preserve the correct field alignment.\nInstead, declare an immutable ``isbits`` type and use that instead.\nUnnamed structs are not possible in the translation to Julia.\n\nPacked structs and union declarations are not supported by Julia.\n\nYou can get a near approximation of a ``union`` if you know, a priori,\nthe field that will have the greatest size (potentially including padding).\nWhen translating your fields to Julia, declare the Julia field to be only\nof that type.\n\nArrays of parameters must be expanded manually, currently\n(either inline, or in an immutable helper type). For example::\n\n    in C:\n    struct B {\n        int A[3];\n    };\n    b_a_2 = B.A[2];\n\n    in Julia:\n    immutable B_A\n        A_1::Cint\n        A_2::Cint\n        A_3::Cint\n    end\n    type B\n        A::B_A\n    end\n    b_a_2 = B.A.(2)\n\nArrays of unknown size are not supported.\n\nIn the future, some of these restrictions may be reduced or eliminated.\n\nSIMD Values\n~~~~~~~~~~~\n\nNote: This feature is currently implemented on 64-bit x86\nand AArch64 platforms only.\n\nIf a C/C++ routine has an argument or return value that is a native\nSIMD type, the corresponding Julia type is a homogeneous tuple\nof ``VecElement`` that naturally maps to the SIMD type.  Specifically:\n\n    - The tuple must be the same size as the SIMD type.\n      For example, a tuple representing an ``__m128`` on x86\n      must have a size of 16 bytes.\n\n    - The element type of the tuple must be an instance of ``VecElement{T}``\n      where ``T`` is a bitstype that is 1, 2, 4 or 8 bytes.\n\nFor instance, consider this C routine that uses AVX intrinsics::\n\n    #include <immintrin.h>\n\n    __m256 dist( __m256 a, __m256 b ) {\n        return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),\n                                            _mm256_mul_ps(b, b)));\n    }\n\nThe following Julia code calls ``dist`` using ``ccall``::\n\n    typealias m256 NTuple{8,VecElement{Float32}}\n\n    a = m256(ntuple(i->VecElement(sin(Float32(i))),8))\n    b = m256(ntuple(i->VecElement(cos(Float32(i))),8))\n\n    function call_dist(a::m256, b::m256)\n        ccall((:dist, \"libdist\"), m256, (m256, m256), a, b)\n    end\n\n    println(call_dist(a,b))\n\nThe host machine must have the requisite SIMD registers.  For example,\nthe code above will not work on hosts without AVX support.\n\nMemory Ownership\n~~~~~~~~~~~~~~~~\n\n**malloc/free**\n\nMemory allocation and deallocation of such objects must be\nhandled by calls to the appropriate cleanup routines in the libraries\nbeing used, just like in any C program. Do not try to free an object\nreceived from a C library with ``Libc.free`` in Julia, as this may result\nin the ``free`` function being called via the wrong ``libc`` library and\ncause Julia to crash. The reverse (passing an object allocated in Julia\nto be freed by an external library) is equally invalid.\n\nWhen to use T, Ptr{T} and Ref{T}\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn Julia code wrapping calls to external C routines, ordinary (non-pointer)\ndata should be declared to be of type ``T`` inside the :func:`ccall`, as they\nare passed by value.  For C code accepting pointers, ``Ref{T}`` should\ngenerally be used for the types of input arguments, allowing the use of\npointers to memory managed by either Julia or C through the implicit call to\n:func:`cconvert`.  In contrast, pointers returned by the C function called\nshould be declared to be of output type ``Ptr{T}``, reflecting that the memory\npointed to is managed by C only. Pointers contained in C structs should be\nrepresented as fields of type ``Ptr{T}`` within the corresponding Julia\nimmutable types designed to mimic the internal structure of corresponding C\nstructs.\n\nIn Julia code wrapping calls to external Fortran routines, all input arguments\nshould be declared as of type ``Ref{T}``, as Fortran passes all variables by\nreference. The return type should either be ``Void`` for Fortran subroutines,\nor a ``T`` for Fortran functions returning the type ``T``.\n\n\nMapping C Functions to Julia\n----------------------------\n\n``ccall``/``cfunction`` argument translation guide\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor translating a C argument list to Julia:\n\n* ``T``, where ``T`` is one of the primitive types:\n  ``char``, ``int``, ``long``, ``short``, ``float``, ``double``, ``complex``, ``enum``\n  or any of their ``typedef`` equivalents\n\n  + ``T``, where ``T`` is an equivalent Julia Bits Type (per the table above)\n  + if ``T`` is an ``enum``, the argument type should be equivalent to ``Cint`` or ``Cuint``\n  + argument value will be copied (passed by value)\n\n* ``struct T`` (including typedef to a struct)\n\n  + ``T``, where ``T`` is a Julia leaf type\n  + argument value will be copied (passed by value)\n\n* ``void*``\n\n  + depends on how this parameter is used, first translate this to the intended pointer type,\n    then determine the Julia equivalent using the remaining rules in this list\n  + this argument may be declared as ``Ptr{Void}``, if it really is just an unknown pointer\n\n* ``jl_value_t*``\n\n  + ``Any``\n  + argument value must be a valid Julia object\n  + currently unsupported by :func:`cfunction`\n\n* ``jl_value_t**``\n\n  + ``Ref{Any}``\n  + argument value must be a valid Julia object (or ``C_NULL``)\n  + currently unsupported by :func:`cfunction`\n\n* ``T*``\n\n  + ``Ref{T}``, where ``T`` is the Julia type corresponding to ``T``\n  + argument value will be copied if it is an ``isbits`` type\n    otherwise, the value must be a valid Julia object\n\n* ``(T*)(...)`` (e.g. a pointer to a function)\n\n  + ``Ptr{Void}`` (you may need to use :func:`cfunction` explicitly to create this pointer)\n\n* ``...`` (e.g. a vararg)\n\n  + ``T...``, where ``T`` is the Julia type\n\n* ``va_arg``\n\n  + not supported\n\n``ccall``/``cfunction`` return type translation guide\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor translating a C return type to Julia:\n\n* ``void``\n\n  + ``Void`` (this will return the singleton instance ``nothing::Void``)\n\n* ``T``, where ``T`` is one of the primitive types:\n  ``char``, ``int``, ``long``, ``short``, ``float``, ``double``, ``complex``, ``enum``\n  or any of their ``typedef`` equivalents\n\n  + ``T``, where ``T`` is an equivalent Julia Bits Type (per the table above)\n  + if ``T`` is an ``enum``, the argument type should be equivalent to ``Cint`` or ``Cuint``\n  + argument value will be copied (returned by-value)\n\n* ``struct T`` (including typedef to a struct)\n\n  + ``T``, where ``T`` is a Julia Leaf Type\n  + argument value will be copied (returned by-value)\n\n* ``void*``\n\n  + depends on how this parameter is used, first translate this to the intended pointer type,\n    then determine the Julia equivalent using the remaining rules in this list\n  + this argument may be declared as ``Ptr{Void}``, if it really is just an unknown pointer\n\n* ``jl_value_t*``\n\n  + ``Any``\n  + argument value must be a valid Julia object\n\n* ``jl_value_t**``\n\n  + ``Ref{Any}``\n  + argument value must be a valid Julia object (or ``C_NULL``)\n\n* ``T*``\n\n  + If the memory is already owned by Julia, or is an ``isbits`` type, and is known to be non-null:\n\n    + ``Ref{T}``, where ``T`` is the Julia type corresponding to ``T``\n    + a return type of ``Ref{Any}`` is invalid, it should either be ``Any``\n      (corresponding to ``jl_value_t*``) or ``Ptr{Any}`` (corresponding to ``Ptr{Any}``)\n    + C **MUST NOT** modify the memory returned via ``Ref{T}`` if ``T`` is an ``isbits`` type\n\n  + If the memory is owned by C:\n\n    + ``Ptr{T}``, where ``T`` is the Julia type corresponding to ``T``\n\n* ``(T*)(...)`` (e.g. a pointer to a function)\n\n  + ``Ptr{Void}`` (you may need to use :func:`cfunction` explicitly to create this pointer)\n\nPassing Pointers for Modifying Inputs\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBecause C doesn't support multiple return values,\noften C functions will take pointers to data that the function will modify.\nTo accomplish this within a :func:`ccall`,\nyou need to first encapsulate the value inside an ``Ref{T}`` of the appropriate type.\nWhen you pass this ``Ref`` object as an argument,\nJulia will automatically pass a C pointer to the encapsulated data::\n\n    width = Ref{Cint}(0)\n    range = Ref{Cfloat}(0)\n    ccall(:foo, Void, (Ref{Cint}, Ref{Cfloat}), width, range)\n\nUpon return, the contents of ``width`` and ``range`` can be retrieved\n(if they were changed by ``foo``) by ``width[]`` and ``range[]``; that is,\nthey act like zero-dimensional arrays.\n\nSpecial Reference Syntax for ccall (deprecated):\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``&`` syntax is deprecated, use the ``Ref{T}`` argument type instead.\n\nA prefix ``&`` is used on an argument to :func:`ccall` to indicate that a pointer\nto a scalar argument should be passed instead of the scalar value itself\n(required for all Fortran function arguments, as noted above). The following\nexample computes a dot product using a BLAS function.\n\n::\n\n    function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})\n      assert(length(DX) == length(DY))\n      n = length(DX)\n      incx = incy = 1\n      product = ccall((:ddot_, \"libLAPACK\"),\n                      Float64,\n                      (Ptr{Int32}, Ptr{Float64}, Ptr{Int32}, Ptr{Float64}, Ptr{Int32}),\n                      &n, DX, &incx, DY, &incy)\n      return product\n    end\n\nThe meaning of prefix ``&`` is not quite the same as in C. In\nparticular, any changes to the referenced variables will not be\nvisible in Julia unless the type is mutable (declared via\n``type``). However, even for immutable types it will not cause any\nharm for called functions to attempt such modifications (that is,\nwriting through the passed pointers). Moreover, ``&`` may be used with\nany expression, such as ``&0`` or ``&f(x)``.\n\nWhen a scalar value is passed with ``&`` as an argument of type\n``Ptr{T}``, the value will first be converted to type ``T``.\n\nSome Examples of C Wrappers\n---------------------------\n\nHere is a simple example of a C wrapper that returns a ``Ptr`` type::\n\n    type gsl_permutation\n    end\n\n    # The corresponding C signature is\n    #     gsl_permutation * gsl_permutation_alloc (size_t n);\n    function permutation_alloc(n::Integer)\n        output_ptr = ccall(\n            (:gsl_permutation_alloc, :libgsl), #name of C function and library\n            Ptr{gsl_permutation},              #output type\n            (Csize_t,),                        #tuple of input types\n            n                                  #name of Julia variable to pass in\n        )\n        if output_ptr==C_NULL # Could not allocate memory\n            throw(OutOfMemoryError())\n        end\n        return output_ptr\n    end\n\nThe `GNU Scientific Library <https://www.gnu.org/software/gsl/>`_ (here assumed\nto be accessible through ``:libgsl``) defines an opaque pointer,\n``gsl_permutation *``, as the return type of the C function\n``gsl_permutation_alloc()``. As user code never has to look inside the\n``gsl_permutation`` struct, the corresponding Julia wrapper simply needs a new\ntype declaration, ``gsl_permutation``, that has no internal fields and whose\nsole purpose is to be placed in the type parameter of a ``Ptr`` type.  The\nreturn type of the :func:`ccall` is declared as ``Ptr{gsl_permutation}``, since the\nmemory allocated and pointed to by ``output_ptr`` is controlled by C (and not\nJulia).\n\nThe input ``n`` is passed by value, and so the function's input signature is\nsimply declared as ``(Csize_t,)`` without any ``Ref`` or ``Ptr`` necessary.\n(If the wrapper was calling a Fortran function instead, the corresponding\nfunction input signature should instead be ``(Ref{Csize_t},)``, since Fortran\nvariables are passed by reference.) Furthermore, ``n`` can be any type that is\nconvertable to a ``Csize_t`` integer; the :func:`ccall` implicitly calls\n:func:`Base.cconvert(Csize_t, n) <cconvert>`.\n\n\nHere is a second example wrapping the corresponding destructor::\n\n    # The corresponding C signature is\n    #     void gsl_permutation_free (gsl_permutation * p);\n    function permutation_free(p::Ref{gsl_permutation})\n        ccall(\n            (:gsl_permutation_free, :libgsl), #name of C function and library\n            Void,                             #output type\n            (Ref{gsl_permutation},),          #tuple of input types\n            p                                 #name of Julia variable to pass in\n        )\n    end\n\nHere, the input ``p`` is declared to be of type ``Ref{gsl_permutation}``,\nmeaning that the memory that ``p`` points to may be managed by Julia or by C.\nA pointer to memory allocated by C should be of type ``Ptr{gsl_permutation}``,\nbut it is convertable using :func:`cconvert` and therefore can be used in the\nsame (covariant) context of the input argument to a :func:`ccall`. A pointer to\nmemory allocated by Julia must be of type ``Ref{gsl_permutation}``, to ensure\nthat the memory address pointed to is valid and that Julia's garbage collector\nmanages the chunk of memory pointed to correctly. Therefore, the\n``Ref{gsl_permutation}`` declaration allows pointers managed by C or Julia to\nbe used.\n\nIf the C wrapper never expects the user to pass pointers to memory managed by\nJulia, then using ``p::Ptr{gsl_permutation}`` for the method signature of the\nwrapper and similarly in the :func:`ccall` is also acceptable.\n\n\nHere is a third example passing Julia arrays::\n\n    # The corresponding C signature is\n    #    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,\n    #                                double result_array[])\n    function sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)\n        if nmax<nmin throw(DomainError()) end\n        result_array = Array{Cdouble}(nmax-nmin+1)\n        errorcode = ccall(\n            (:gsl_sf_bessel_Jn_array, :libgsl), #name of C function and library\n            Cint,                               #output type\n            (Cint, Cint, Cdouble, Ref{Cdouble}),#tuple of input types\n            nmin, nmax, x, result_array         #names of Julia variables to pass in\n        )\n        if errorcode!= 0 error(\"GSL error code $errorcode\") end\n        return result_array\n    end\n\nThe C function wrapped returns an integer error code; the results of the actual\nevaluation of the Bessel J function populate the Julia array ``result_array``.\nThis variable can only be used with corresponding input type declaration\n``Ref{Cdouble}``, since its memory is allocated and managed by\nJulia, not C. The implicit call to :func:`Base.cconvert(Ref{Cdouble},\nresult_array) <cconvert>` unpacks the Julia pointer to a Julia array data\nstructure into a form understandable by C.\n\nNote that for this code to work correctly, ``result_array`` must be declared to\nbe of type ``Ref{Cdouble}`` and not ``Ptr{Cdouble}``. The memory is managed by\nJulia and the ``Ref`` signature alerts Julia's garbage collector to keep\nmanaging the memory for ``result_array`` while the :func:`ccall` executes. If\n``Ptr{Cdouble}`` were used instead, the :func:`ccall` may still work, but\nJulia's garbage collector would not be aware that the memory declared for\n``result_array`` is being used by the external C function. As a result, the\ncode may produce a memory leak if ``result_array`` never gets freed by the\ngarbage collector, or if the garbage collector prematurely frees\n``result_array``, the C function may end up throwing an invalid memory access\nexception.\n\n\n\nGarbage Collection Safety\n-------------------------\nWhen passing data to a :func:`ccall`, it is best to avoid using the :func:`pointer`\nfunction. Instead define a convert method and pass the variables directly to\nthe :func:`ccall`. :func:`ccall` automatically arranges that all of its arguments will be\npreserved from garbage collection until the call returns. If a C API will\nstore a reference to memory allocated by Julia, after the :func:`ccall` returns, you\nmust arrange that the object remains visible to the garbage collector. The\nsuggested way to handle this is to make a global variable of type\n``Array{Ref,1}`` to hold these values, until the C library notifies you that\nit is finished with them.\n\nWhenever you have created a pointer to Julia data, you must ensure the original data\nexists until you are done with using the pointer. Many methods in Julia such as\n:func:`unsafe_load` and :func:`String` make copies of data instead of taking ownership\nof the buffer, so that it is safe to free (or alter) the original data without\naffecting Julia. A notable exception is :func:`unsafe_wrap` which, for performance\nreasons, shares (or can be told to take ownership of) the underlying buffer.\n\nThe garbage collector does not guarantee any order of finalization. That is, if ``a``\ncontained a reference to ``b`` and both ``a`` and ``b`` are due for garbage\ncollection, there is no guarantee that ``b`` would be finalized after ``a``. If\nproper finalization of ``a`` depends on ``b`` being valid, it must be handled in\nother ways.\n\n\nNon-constant Function Specifications\n------------------------------------\n\nA ``(name, library)`` function specification must be a constant expression.\nHowever, it is possible to use computed values as function names by staging\nthrough ``eval`` as follows::\n\n    @eval ccall(($(string(\"a\",\"b\")),\"lib\"), ...\n\nThis expression constructs a name using ``string``, then substitutes this\nname into a new :func:`ccall` expression, which is then evaluated. Keep in mind that\n``eval`` only operates at the top level, so within this expression local\nvariables will not be available (unless their values are substituted with\n``$``). For this reason, ``eval`` is typically only used to form top-level\ndefinitions, for example when wrapping libraries that contain many\nsimilar functions.\n\nIf your usage is more dynamic, use indirect calls as described in the next section.\n\n\nIndirect Calls\n--------------\n\nThe first argument to :func:`ccall` can also be an expression evaluated at run time.\nIn this case, the expression must evaluate to a ``Ptr``,\nwhich will be used as the address of the native function to call.\nThis behavior occurs when the first :func:`ccall` argument contains references to non-constants,\nsuch as local variables, function arguments, or non-constant globals.\n\nFor example, you might lookup the function via ``dlsym``,\nthen cache it in a global variable for that session. For example::\n\n    macro dlsym(func, lib)\n        z, zlocal = gensym(string(func)), gensym()\n        eval(current_module(),:(global $z = C_NULL))\n        z = esc(z)\n        quote\n            let $zlocal::Ptr{Void} = $z::Ptr{Void}\n                if $zlocal == C_NULL\n                   $zlocal = dlsym($(esc(lib))::Ptr{Void}, $(esc(func)))\n                   global $z = $zlocal\n                end\n                $zlocal\n            end\n        end\n    end\n\n    mylibvar = dlopen(\"mylib\")\n    ccall(@dlsym(\"myfunc\", mylibvar), Void, ())\n\n\nCalling Convention\n------------------\n\nThe second argument to :func:`ccall` can optionally be a calling convention\nspecifier (immediately preceding return type). Without any specifier,\nthe platform-default C calling convention is used. Other supported\nconventions are: ``stdcall``, ``cdecl``, ``fastcall``, and ``thiscall``.\nFor example (from ``base/libc.jl``) we see the same ``gethostname`` :func:`ccall` as above,\nbut with the correct signature for Windows::\n\n    hn = Array{UInt8}(256)\n    err = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))\n\nFor more information, please see the `LLVM Language Reference`_.\n\n.. _LLVM Language Reference: http://llvm.org/docs/LangRef.html#calling-conventions\n\n\nAccessing Global Variables\n--------------------------\n\nGlobal variables exported by native libraries can be accessed by name using the\n:func:`cglobal` function. The arguments to :func:`cglobal` are a symbol specification\nidentical to that used by :func:`ccall`, and a type describing the value stored in\nthe variable::\n\n    julia> cglobal((:errno,:libc), Int32)\n    Ptr{Int32} @0x00007f418d0816b8\n\nThe result is a pointer giving the address of the value. The value can be\nmanipulated through this pointer using :func:`unsafe_load` and :func:`unsafe_store!`.\n\n\nAccessing Data through a Pointer\n--------------------------------\nThe following methods are described as \"unsafe\" because a bad pointer\nor type declaration can cause Julia to terminate abruptly.\n\nGiven a ``Ptr{T}``, the contents of type ``T`` can generally be copied from\nthe referenced memory into a Julia object using ``unsafe_load(ptr, [index])``.\nThe index argument is optional (default is 1),\nand follows the Julia-convention of 1-based indexing.\nThis function is intentionally similar to the behavior of :func:`getindex` and :func:`setindex!`\n(e.g. ``[]`` access syntax).\n\nThe return value will be a new object initialized\nto contain a copy of the contents of the referenced memory.\nThe referenced memory can safely be freed or released.\n\nIf ``T`` is ``Any``, then the memory is assumed to contain a reference to\na Julia object (a ``jl_value_t*``), the result will be a reference to this object,\nand the object will not be copied. You must be careful in this case to ensure\nthat the object was always visible to the garbage collector (pointers do not\ncount, but the new reference does) to ensure the memory is not prematurely freed.\nNote that if the object was not originally allocated by Julia, the new object\nwill never be finalized by Julia's garbage collector.  If the ``Ptr`` itself\nis actually a ``jl_value_t*``, it can be converted back to a Julia object\nreference by :func:`unsafe_pointer_to_objref(ptr) <unsafe_pointer_to_objref>`.\n(Julia values ``v`` can be converted to ``jl_value_t*`` pointers, as\n``Ptr{Void}``, by calling :func:`pointer_from_objref(v)\n<pointer_from_objref>`.)\n\nThe reverse operation (writing data to a ``Ptr{T}``), can be performed using\n:func:`unsafe_store!(ptr, value, [index]) <unsafe_store!>`.  Currently, this is only supported\nfor bitstypes or other pointer-free (``isbits``) immutable types.\n\nAny operation that throws an error is probably currently unimplemented\nand should be posted as a bug so that it can be resolved.\n\nIf the pointer of interest is a plain-data array (bitstype or immutable), the\nfunction :func:`unsafe_wrap(Array, ptr,dims,[own]) <unsafe_wrap>` may be\nmore useful. The final parameter should be true if Julia should \"take\nownership\" of the underlying buffer and call ``free(ptr)`` when the returned\n``Array`` object is finalized.  If the ``own`` parameter is omitted or false,\nthe caller must ensure the buffer remains in existence until all access is\ncomplete.\n\nArithmetic on the ``Ptr`` type in Julia (e.g. using ``+``) does not behave the\nsame as C's pointer arithmetic. Adding an integer to a ``Ptr`` in Julia always\nmoves the pointer by some number of *bytes*, not elements. This way, the\naddress values obtained from pointer arithmetic do not depend on the\nelement types of pointers.\n\n\nThread-safety\n-------------\n\nSome C libraries execute their callbacks from a different thread, and\nsince Julia isn't thread-safe you'll need to take some extra\nprecautions. In particular, you'll need to set up a two-layered\nsystem: the C callback should only *schedule* (via Julia's event loop)\nthe execution of your \"real\" callback.\nTo do this, create a ``AsyncCondition`` object and wait on it::\n\n  cond = Base.AsyncCondition()\n  wait(cond)\n\nThe callback you pass to C should only execute a :func:`ccall` to\n``:uv_async_send``, passing ``cb.handle`` as the argument,\ntaking care to avoid any allocations or other interactions with the Julia runtime.\n\nNote that events may be coalesced, so multiple calls to uv_async_send\nmay result in a single wakeup notification to the condition.\n\nMore About Callbacks\n--------------------\n\nFor more details on how to pass callbacks to C libraries, see this\n`blog post <http://julialang.org/blog/2013/05/callback>`_.\n\nC++\n---\n\nLimited support for C++ is provided by the `Cpp <https://github.com/timholy/Cpp.jl>`_,\n`Clang <https://github.com/ihnorton/Clang.jl>`_, and `Cxx <https://github.com/Keno/Cxx.jl>`_ packages.\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/base/libdl.jl": "# This file is a part of Julia. License is MIT: http://julialang.org/license\n\nmodule Libdl\n\nexport DL_LOAD_PATH, RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL,\n    RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW, dlclose, dlopen, dlopen_e, dlsym, dlsym_e,\n    dlpath, find_library, dlext, dllist\n\n\"\"\"\n    DL_LOAD_PATH\n\nWhen calling [`dlopen`](:func:`dlopen`), the paths in this list will be searched first, in\norder, before searching the system locations for a valid library handle.\n\"\"\"\nconst DL_LOAD_PATH = String[]\nif is_apple()\n    push!(DL_LOAD_PATH, \"@loader_path/julia\")\n    push!(DL_LOAD_PATH, \"@loader_path\")\nend\n\n# constants to match JL_RTLD_* in src/julia.h\nconst RTLD_LOCAL     = 0x00000001\nconst RTLD_GLOBAL    = 0x00000002\nconst RTLD_LAZY      = 0x00000004\nconst RTLD_NOW       = 0x00000008\nconst RTLD_NODELETE  = 0x00000010\nconst RTLD_NOLOAD    = 0x00000020\nconst RTLD_DEEPBIND  = 0x00000040\nconst RTLD_FIRST     = 0x00000080\n\n@doc \"\"\"\n    RTLD_DEEPBIND\n    RTLD_FIRST\n    RTLD_GLOBAL\n    RTLD_LAZY\n    RTLD_LOCAL\n    RTLD_NODELETE\n    RTLD_NOLOAD\n    RTLD_NOW\n\nEnum constant for [`dlopen`](:func:`dlopen`). See your platform man page for details, if\napplicable.\n\"\"\" ->\n(RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL, RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW)\n\n\n\"\"\"\n    dlsym(handle, sym)\n\nLook up a symbol from a shared library handle, return callable function pointer on success.\n\"\"\"\nfunction dlsym(hnd::Ptr, s::Union{Symbol,AbstractString})\n    hnd == C_NULL && throw(ArgumentError(\"NULL library handle\"))\n    ccall(:jl_dlsym, Ptr{Void}, (Ptr{Void}, Cstring), hnd, s)\nend\n\n\"\"\"\n    dlsym_e(handle, sym)\n\nLook up a symbol from a shared library handle, silently return `NULL` pointer on lookup failure.\n\"\"\"\nfunction dlsym_e(hnd::Ptr, s::Union{Symbol,AbstractString})\n    hnd == C_NULL && throw(ArgumentError(\"NULL library handle\"))\n    ccall(:jl_dlsym_e, Ptr{Void}, (Ptr{Void}, Cstring), hnd, s)\nend\n\n\"\"\"\n    dlopen(libfile::AbstractString [, flags::Integer])\n\nLoad a shared library, returning an opaque handle.\n\nThe optional flags argument is a bitwise-or of zero or more of `RTLD_LOCAL`, `RTLD_GLOBAL`,\n`RTLD_LAZY`, `RTLD_NOW`, `RTLD_NODELETE`, `RTLD_NOLOAD`, `RTLD_DEEPBIND`, and `RTLD_FIRST`.\nThese are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS)\ndlopen command, if possible, or are ignored if the specified functionality is not available\non the current platform. The default flags are platform specific. On MacOS the default\n`dlopen` flags are `RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL` while on other platforms the\ndefaults are `RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL`. An important usage of these flags is to\nspecify non default behavior for when the dynamic library loader binds library references to\nexported symbols and if the bound references are put into process local or global scope. For\ninstance `RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL` allows the library's symbols to be available\nfor usage in other shared libraries, addressing situations where there are dependencies\nbetween shared libraries.\n\"\"\"\nfunction dlopen end\n\ndlopen(s::Symbol, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND) =\n    dlopen(string(s), flags)\n\ndlopen(s::AbstractString, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND) =\n    ccall(:jl_load_dynamic_library, Ptr{Void}, (Cstring,UInt32), s, flags)\n\n\"\"\"\n    dlopen_e(libfile::AbstractString [, flags::Integer])\n\nSimilar to [`dlopen`](:func:`dlopen`), except returns a `NULL` pointer instead of raising errors.\n\"\"\"\nfunction dlopen_e end\n\ndlopen_e(s::Symbol, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND) =\n    dlopen_e(string(s), flags)\n\ndlopen_e(s::AbstractString, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND) =\n    ccall(:jl_load_dynamic_library_e, Ptr{Void}, (Cstring,UInt32), s, flags)\n\n\"\"\"\n    dlclose(handle)\n\nClose shared library referenced by handle.\n\"\"\"\nfunction dlclose(p::Ptr)\n    0 == ccall(:jl_dlclose, Cint, (Ptr{Void},), p)\nend\n\n\"\"\"\n    find_library(names, locations)\n\nSearches for the first library in `names` in the paths in the `locations` list,\n`DL_LOAD_PATH`, or system library paths (in that order) which can successfully be dlopen'd.\nOn success, the return value will be one of the names (potentially prefixed by one of the\npaths in locations). This string can be assigned to a `global const` and used as the library\nname in future `ccall`'s. On failure, it returns the empty string.\n\"\"\"\nfunction find_library(libnames, extrapaths=String[])\n    for lib in libnames\n        for path in extrapaths\n            l = joinpath(path, lib)\n            p = dlopen_e(l, RTLD_LAZY)\n            if p != C_NULL\n                dlclose(p)\n                return l\n            end\n        end\n        p = dlopen_e(lib, RTLD_LAZY)\n        if p != C_NULL\n            dlclose(p)\n            return lib\n        end\n    end\n    return \"\"\nend\nfind_library(libname::Union{Symbol,AbstractString}, extrapaths=String[]) =\n    find_library([string(libname)], extrapaths)\n\nfunction dlpath(handle::Ptr{Void})\n    p = ccall(:jl_pathname_for_handle, Cstring, (Ptr{Void},), handle)\n    s = unsafe_string(p)\n    is_windows() && Libc.free(p)\n    return s\nend\n\nfunction dlpath(libname::Union{AbstractString, Symbol})\n    handle = dlopen(libname)\n    path = dlpath(handle)\n    dlclose(handle)\n    return path\nend\n\nif is_apple()\n    const dlext = \"dylib\"\nelseif is_windows()\n    const dlext = \"dll\"\nelse\n    #assume is_linux, or similar\n    const dlext = \"so\"\nend\n\n\"\"\"\n    dlext\n\nFile extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.\n\"\"\"\ndlext\n\nif is_linux()\n    immutable dl_phdr_info\n        # Base address of object\n        addr::Cuint\n\n        # Null-terminated name of object\n        name::Ptr{UInt8}\n\n        # Pointer to array of ELF program headers for this object\n        phdr::Ptr{Void}\n\n        # Number of program headers for this object\n        phnum::Cshort\n    end\n\n    # This callback function called by dl_iterate_phdr() on Linux\n    function dl_phdr_info_callback(di::dl_phdr_info, size::Csize_t, dynamic_libraries::Array{AbstractString,1})\n        # Skip over objects without a path (as they represent this own object)\n        name = unsafe_string(di.name)\n        if !isempty(name)\n            push!(dynamic_libraries, name)\n        end\n        return convert(Cint, 0)::Cint\n    end\nend # linux-only\n\nfunction dllist()\n    dynamic_libraries = Array{AbstractString}(0)\n\n    @static if is_linux()\n        const callback = cfunction(dl_phdr_info_callback, Cint,\n                                   (Ref{dl_phdr_info}, Csize_t, Ref{Array{AbstractString,1}} ))\n        ccall(:dl_iterate_phdr, Cint, (Ptr{Void}, Ref{Array{AbstractString,1}}), callback, dynamic_libraries)\n    end\n\n    @static if is_apple()\n        numImages = ccall(:_dyld_image_count, Cint, (), )\n\n        # start at 1 instead of 0 to skip self\n        for i in 1:numImages-1\n            name = unsafe_string(ccall(:_dyld_get_image_name, Cstring, (UInt32,), i))\n            push!(dynamic_libraries, name)\n        end\n    end\n\n    @static if is_windows()\n        ccall(:jl_dllist, Cint, (Any,), dynamic_libraries)\n    end\n\n    return dynamic_libraries\nend\n\nend # module\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/base/sparse/cholmod.jl": "# This file is a part of Julia. License is MIT: http://julialang.org/license\n\nmodule CHOLMOD\n\nimport Base: (*), convert, copy, eltype, get, getindex, show, size,\n             linearindexing, LinearFast, LinearSlow, ctranspose\n\nimport Base.LinAlg: (\\), A_mul_Bc, A_mul_Bt, Ac_ldiv_B, Ac_mul_B, At_ldiv_B, At_mul_B,\n                 cholfact, cholfact!, det, diag, ishermitian, isposdef,\n                 issymmetric, ldltfact, ldltfact!, logdet\n\nimportall ..SparseArrays\n\nexport\n    Dense,\n    Factor,\n    Sparse\n\nimport ..SparseArrays: AbstractSparseMatrix, SparseMatrixCSC, increment, indtype\n\n#########\n# Setup #\n#########\n\ninclude(\"cholmod_h.jl\")\n\nconst CHOLMOD_MIN_VERSION = v\"2.1.1\"\n\n### These offsets are defined in SuiteSparse_wrapper.c\nconst common_size = ccall((:jl_cholmod_common_size,:libsuitesparse_wrapper),Int,())\n\nconst cholmod_com_offsets = Array{Csize_t}(19)\nccall((:jl_cholmod_common_offsets, :libsuitesparse_wrapper),\n    Void, (Ptr{Csize_t},), cholmod_com_offsets)\n\n## macro to generate the name of the C function according to the integer type\nmacro cholmod_name(nm,typ) string(\"cholmod_\", eval(typ) == SuiteSparse_long ? \"l_\" : \"\", nm) end\n\nfunction start(a::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"start\", SuiteSparse_long), :libcholmod),\n        Cint, (Ptr{UInt8},), a)\n    return a\nend\n\nfunction finish(a::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"finish\", SuiteSparse_long), :libcholmod),\n        Cint, (Ptr{UInt8},), a)\n    return a\nend\n\nfunction defaults(a::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"defaults\", SuiteSparse_long), :libcholmod),\n        Cint, (Ptr{UInt8},), a)\n    return a\nend\n\ncommon() = commonStruct\n\nconst build_version_array = Array{Cint}(3)\nccall((:jl_cholmod_version, :libsuitesparse_wrapper), Cint, (Ptr{Cint},), build_version_array)\nconst build_version = VersionNumber(build_version_array...)\n\nfunction __init__()\n    try\n        ### Check if the linked library is compatible with the Julia code\n        if Libdl.dlsym_e(Libdl.dlopen(\"libcholmod\"), :cholmod_version) != C_NULL\n            current_version_array = Array{Cint}(3)\n            ccall((:cholmod_version, :libcholmod), Cint, (Ptr{Cint},), current_version_array)\n            current_version = VersionNumber(current_version_array...)\n        else # CHOLMOD < 2.1.1 does not include cholmod_version()\n            current_version = v\"0.0.0\"\n        end\n\n\n        if current_version < CHOLMOD_MIN_VERSION\n            warn(\"\"\"\n\n                CHOLMOD version incompatibility\n\n                Julia was compiled with CHOLMOD version $build_version. It is\n                currently linked with a version older than\n                $(CHOLMOD_MIN_VERSION). This might cause Julia to\n                terminate when working with sparse matrix factorizations,\n                e.g. solving systems of equations with \\\\.\n\n                It is recommended that you use Julia with a recent version\n                of CHOLMOD, or download the generic binaries\n                from www.julialang.org, which ship with the correct\n                versions of all dependencies.\n            \"\"\")\n        elseif build_version_array[1] != current_version_array[1]\n            warn(\"\"\"\n\n                CHOLMOD version incompatibility\n\n                Julia was compiled with CHOLMOD version $build_version. It is\n                currently linked with version $current_version.\n                This might cause Julia to terminate when working with\n                sparse matrix factorizations, e.g. solving systems of\n                equations with \\\\.\n\n                It is recommended that you use Julia with the same major\n                version of CHOLMOD as the one used during the build, or\n                download the generic binaries from www.julialang.org,\n                which ship with the correct versions of all dependencies.\n            \"\"\")\n        end\n\n        intsize = Int(ccall((:jl_cholmod_sizeof_long,:libsuitesparse_wrapper),Csize_t,()))\n        if intsize != 4length(IndexTypes)\n            warn(\"\"\"\n\n                 CHOLMOD integer size incompatibility\n\n                 Julia was compiled with a version of CHOLMOD that\n                 supported $(32length(IndexTypes)) bit integers. It is\n                 currently linked with version that supports $(8intsize)\n                 integers. This might cause Julia to terminate when\n                 working with sparse matrix factorizations, e.g. solving\n                 systems of equations with \\\\.\n\n                 This problem can be fixed by modifying the Julia build\n                 configuration or by downloading the OS X or generic\n                 Linux binary from www.julialang.org, which include\n                 the correct versions of all dependencies.\n             \"\"\")\n        end\n\n        ### Initiate CHOLMOD\n        ### The common struct. Controls the type of factorization and keeps pointers\n        ### to temporary memory.\n        global const commonStruct = fill(0xff, common_size)\n\n        global const common_supernodal =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[4] + 1))\n        global const common_final_ll =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[7] + 1))\n        global const common_print =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[13] + 1))\n        global const common_itype =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[18] + 1))\n        global const common_dtype =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[19] + 1))\n        global const common_nmethods =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[15] + 1))\n        global const common_postorder =\n            convert(Ptr{Cint}, pointer(commonStruct, cholmod_com_offsets[17] + 1))\n\n        start(commonStruct)              # initializes CHOLMOD\n        set_print_level(commonStruct, 0) # no printing from CHOLMOD by default\n\n        # Register gc tracked allocator if CHOLMOD is new enough\n        if current_version >= v\"3.0.0\"\n            cnfg = cglobal((:SuiteSparse_config, :libsuitesparseconfig), Ptr{Void})\n            unsafe_store!(cnfg, cglobal(:jl_malloc, Ptr{Void}), 1)\n            unsafe_store!(cnfg, cglobal(:jl_calloc, Ptr{Void}), 2)\n            unsafe_store!(cnfg, cglobal(:jl_realloc, Ptr{Void}), 3)\n            unsafe_store!(cnfg, cglobal(:jl_free, Ptr{Void}), 4)\n        end\n\n    catch ex\n        Base.showerror_nostdio(ex,\n            \"WARNING: Error during initialization of module CHOLMOD\")\n    end\nend\n\nfunction set_print_level(cm::Array{UInt8}, lev::Integer)\n    global common_print\n    unsafe_store!(common_print, lev)\nend\n\n####################\n# Type definitions #\n####################\n\nabstract SuiteSparseStruct\n\n# The three core data types for CHOLMOD: Dense, Sparse and Factor.\n# CHOLMOD manages the memory, so the Julia versions only wrap a\n# pointer to a struct.  Therefore finalizers should be registered each\n# time a pointer is returned from CHOLMOD.\n\n# Dense\nimmutable C_Dense{T<:VTypes} <: SuiteSparseStruct\n    nrow::Csize_t\n    ncol::Csize_t\n    nzmax::Csize_t\n    d::Csize_t\n    x::Ptr{T}\n    z::Ptr{Void}\n    xtype::Cint\n    dtype::Cint\nend\n\ntype Dense{T<:VTypes} <: DenseMatrix{T}\n    p::Ptr{C_Dense{T}}\nend\n\n# Sparse\nimmutable C_Sparse{Tv<:VTypes} <: SuiteSparseStruct\n    nrow::Csize_t\n    ncol::Csize_t\n    nzmax::Csize_t\n    p::Ptr{SuiteSparse_long}\n    i::Ptr{SuiteSparse_long}\n    nz::Ptr{SuiteSparse_long}\n    x::Ptr{Tv}\n    z::Ptr{Void}\n    stype::Cint\n    itype::Cint\n    xtype::Cint\n    dtype::Cint\n    sorted::Cint\n    packed::Cint\nend\n\n# Corresponds to the exact definition of cholmod_sparse_struct in the library.\n# Useful when reading matrices of unknown type from files as in\n# cholmod_read_sparse\nimmutable C_SparseVoid <: SuiteSparseStruct\n    nrow::Csize_t\n    ncol::Csize_t\n    nzmax::Csize_t\n    p::Ptr{Void}\n    i::Ptr{Void}\n    nz::Ptr{Void}\n    x::Ptr{Void}\n    z::Ptr{Void}\n    stype::Cint\n    itype::Cint\n    xtype::Cint\n    dtype::Cint\n    sorted::Cint\n    packed::Cint\nend\n\ntype Sparse{Tv<:VTypes} <: AbstractSparseMatrix{Tv,SuiteSparse_long}\n    p::Ptr{C_Sparse{Tv}}\n    function Sparse(p::Ptr{C_Sparse{Tv}})\n        if p == C_NULL\n            throw(ArgumentError(\"sparse matrix construction failed for unknown reasons. Please submit a bug report.\"))\n        end\n        new(p)\n    end\nend\nSparse{Tv<:VTypes}(p::Ptr{C_Sparse{Tv}}) = Sparse{Tv}(p)\n\n# Factor\n\nif build_version >= v\"2.1.0\" # CHOLMOD version 2.1.0 or later\n    immutable C_Factor{Tv<:VTypes} <: SuiteSparseStruct\n        n::Csize_t\n        minor::Csize_t\n        Perm::Ptr{SuiteSparse_long}\n        ColCount::Ptr{SuiteSparse_long}\n        IPerm::Ptr{SuiteSparse_long}        # this pointer was added in verison 2.1.0\n        nzmax::Csize_t\n        p::Ptr{SuiteSparse_long}\n        i::Ptr{SuiteSparse_long}\n        x::Ptr{Tv}\n        z::Ptr{Void}\n        nz::Ptr{SuiteSparse_long}\n        next::Ptr{SuiteSparse_long}\n        prev::Ptr{SuiteSparse_long}\n        nsuper::Csize_t\n        ssize::Csize_t\n        xsize::Csize_t\n        maxcsize::Csize_t\n        maxesize::Csize_t\n        super::Ptr{SuiteSparse_long}\n        pi::Ptr{SuiteSparse_long}\n        px::Ptr{SuiteSparse_long}\n        s::Ptr{SuiteSparse_long}\n        ordering::Cint\n        is_ll::Cint\n        is_super::Cint\n        is_monotonic::Cint\n        itype::Cint\n        xtype::Cint\n        dtype::Cint\n    end\nelse\n    immutable C_Factor{Tv<:VTypes} <: SuiteSparseStruct\n        n::Csize_t\n        minor::Csize_t\n        Perm::Ptr{SuiteSparse_long}\n        ColCount::Ptr{SuiteSparse_long}\n        nzmax::Csize_t\n        p::Ptr{SuiteSparse_long}\n        i::Ptr{SuiteSparse_long}\n        x::Ptr{Tv}\n        z::Ptr{Void}\n        nz::Ptr{SuiteSparse_long}\n        next::Ptr{SuiteSparse_long}\n        prev::Ptr{SuiteSparse_long}\n        nsuper::Csize_t\n        ssize::Csize_t\n        xsize::Csize_t\n        maxcsize::Csize_t\n        maxesize::Csize_t\n        super::Ptr{SuiteSparse_long}\n        pi::Ptr{SuiteSparse_long}\n        px::Ptr{SuiteSparse_long}\n        s::Ptr{SuiteSparse_long}\n        ordering::Cint\n        is_ll::Cint\n        is_super::Cint\n        is_monotonic::Cint\n        itype::Cint\n        xtype::Cint\n        dtype::Cint\n    end\nend\n\ntype Factor{Tv} <: Factorization{Tv}\n    p::Ptr{C_Factor{Tv}}\n    function Factor(p::Ptr{C_Factor{Tv}})\n        if p == C_NULL\n            throw(ArgumentError(\"factorization construction failed for unknown reasons. Please submit a bug report.\"))\n        end\n        new(p)\n    end\nend\nFactor{Tv<:VTypes}(p::Ptr{C_Factor{Tv}}) = Factor{Tv}(p)\n\n# Define get similar to get(Nullable) to check pointers. All pointer loads should be wrapped in get to make sure\n# that SuiteSparse is not called with a C_NULL pointer which could cause a segfault. Pointers are set to null\n# when serialized so this can happen when mutiple processes are in use.\nfunction get{T<:SuiteSparseStruct}(p::Ptr{T})\n    if p == C_NULL\n        throw(ArgumentError(\"pointer to the $T object is null. This can happen if the object has been serialized.\"))\n    else\n        return p\n    end\nend\n\n# FactorComponent, for encoding particular factors from a factorization\ntype FactorComponent{Tv,S} <: AbstractMatrix{Tv}\n    F::Factor{Tv}\n\n    function FactorComponent(F::Factor{Tv})\n        s = unsafe_load(get(F.p))\n        if s.is_ll != 0\n            S == :L || S == :U || S == :PtL || S == :UP || throw(CHOLMODException(string(S, \" not supported for sparse LLt matrices; try :L, :U, :PtL, or :UP\")))\n        else\n            S == :L || S == :U || S == :PtL || S == :UP ||\n            S == :D || S == :LD || S == :DU || S == :PtLD || S == :DUP ||\n            throw(CHOLMODException(string(S, \" not supported for sparse LDLt matrices; try :L, :U, :PtL, :UP, :D, :LD, :DU, :PtLD, or :DUP\")))\n        end\n        new(F)\n    end\nend\nfunction FactorComponent{Tv}(F::Factor{Tv}, sym::Symbol)\n    FactorComponent{Tv,sym}(F)\nend\n\nFactor(FC::FactorComponent) = Factor(FC.F)\n\n#################\n# Thin wrappers #\n#################\n\n# Dense wrappers\n## Note! Integer type defaults to Cint, but this is actually not necessary, but\n## making this a choice would require another type parameter in the Dense type\n\n### cholmod_core_h ###\nfunction allocate_dense(nrow::Integer, ncol::Integer, d::Integer, ::Type{Float64})\n    d = Dense(ccall((:cholmod_l_allocate_dense, :libcholmod), Ptr{C_Dense{Float64}},\n        (Csize_t, Csize_t, Csize_t, Cint, Ptr{Void}),\n        nrow, ncol, d, REAL, common()))\n    finalizer(d, free!)\n    d\nend\nfunction allocate_dense(nrow::Integer, ncol::Integer, d::Integer, ::Type{Complex{Float64}})\n    d = Dense(ccall((:cholmod_l_allocate_dense, :libcholmod), Ptr{C_Dense{Complex{Float64}}},\n        (Csize_t, Csize_t, Csize_t, Cint, Ptr{Void}),\n        nrow, ncol, d, COMPLEX, common()))\n    finalizer(d, free!)\n    d\nend\n\nfree_dense!{T}(p::Ptr{C_Dense{T}}) = ccall((:cholmod_l_free_dense, :libcholmod), Cint, (Ref{Ptr{C_Dense{T}}}, Ptr{Void}), p, common())\n\nfunction zeros{T<:VTypes}(m::Integer, n::Integer, ::Type{T})\n    d = Dense(ccall((:cholmod_l_zeros, :libcholmod), Ptr{C_Dense{T}},\n        (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n         m, n, xtyp(T), common()))\n    finalizer(d, free!)\n    d\nend\nzeros(m::Integer, n::Integer) = zeros(m, n, Float64)\n\nfunction ones{T<:VTypes}(m::Integer, n::Integer, ::Type{T})\n    d = Dense(ccall((:cholmod_l_ones, :libcholmod), Ptr{C_Dense{T}},\n        (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n         m, n, xtyp(T), common()))\n    finalizer(d, free!)\n    d\nend\nones(m::Integer, n::Integer) = ones(m, n, Float64)\n\nfunction eye{T<:VTypes}(m::Integer, n::Integer, ::Type{T})\n    d = Dense(ccall((:cholmod_l_eye, :libcholmod), Ptr{C_Dense{T}},\n        (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n         m, n, xtyp(T), common()))\n    finalizer(d, free!)\n    d\nend\neye(m::Integer, n::Integer) = eye(m, n, Float64)\neye(n::Integer) = eye(n, n, Float64)\n\nfunction copy_dense{Tv<:VTypes}(A::Dense{Tv})\n    d = Dense(ccall((:cholmod_l_copy_dense, :libcholmod), Ptr{C_Dense{Tv}},\n        (Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n         get(A.p), common()))\n    finalizer(d, free!)\n    d\nend\n\n### cholmod_matrixops.h ###\nfunction norm_dense{Tv<:VTypes}(D::Dense{Tv}, p::Integer)\n    s = unsafe_load(get(D.p))\n    if p == 2\n        if s.ncol > 1\n            throw(ArgumentError(\"2 norm only supported when matrix has one column\"))\n        end\n    elseif p != 0 && p != 1\n        throw(ArgumentError(\"second argument must be either 0 (Inf norm), 1, or 2\"))\n    end\n    ccall((:cholmod_l_norm_dense, :libcholmod), Cdouble,\n        (Ptr{C_Dense{Tv}}, Cint, Ptr{UInt8}),\n          get(D.p), p, common())\nend\n\n### cholmod_check.h ###\nfunction check_dense{T<:VTypes}(A::Dense{T})\n    ccall((:cholmod_l_check_dense, :libcholmod), Cint,\n          (Ptr{C_Dense{T}}, Ptr{UInt8}),\n          A.p, common())!=0\nend\n\n# Non-Dense wrappers\n### cholmod_core.h ###\nfunction allocate_sparse(nrow::Integer, ncol::Integer, nzmax::Integer, sorted::Bool, packed::Bool, stype::Integer, ::Type{Float64})\n    s = Sparse(ccall((@cholmod_name(\"allocate_sparse\", SuiteSparse_long), :libcholmod), Ptr{C_Sparse{Float64}},\n            (Csize_t, Csize_t, Csize_t, Cint,\n                Cint, Cint, Cint, Ptr{Void}),\n            nrow, ncol, nzmax, sorted,\n                packed, stype, REAL, common()))\n    finalizer(s, free!)\n    s\nend\nfunction allocate_sparse(nrow::Integer, ncol::Integer, nzmax::Integer, sorted::Bool, packed::Bool, stype::Integer, ::Type{Complex{Float64}})\n    s = Sparse(ccall((@cholmod_name(\"allocate_sparse\", SuiteSparse_long), :libcholmod),\n            Ptr{C_Sparse{Complex{Float64}}},\n                (Csize_t, Csize_t, Csize_t, Cint,\n                 Cint, Cint, Cint, Ptr{Void}),\n                nrow, ncol, nzmax, sorted,\n                packed, stype, COMPLEX, common()))\n    finalizer(s, free!)\n    s\nend\nfunction free_sparse!{Tv<:VTypes}(ptr::Ptr{C_Sparse{Tv}})\n    @isok ccall((@cholmod_name(\"free_sparse\", SuiteSparse_long), :libcholmod), Cint,\n            (Ptr{Ptr{C_Sparse{Tv}}}, Ptr{UInt8}),\n                &ptr, common())\nend\n\nfunction free_sparse!(ptr::Ptr{C_SparseVoid})\n    @isok ccall((@cholmod_name(\"free_sparse\", SuiteSparse_long), :libcholmod), Cint,\n            (Ptr{Ptr{C_SparseVoid}}, Ptr{UInt8}),\n                &ptr, common())\nend\n\nfunction free_factor!{Tv<:VTypes}(ptr::Ptr{C_Factor{Tv}})\n    # Warning! Important that finalizer doesn't modify the global Common struct.\n    @isok ccall((@cholmod_name(\"free_factor\", SuiteSparse_long), :libcholmod), Cint,\n            (Ptr{Ptr{C_Factor{Tv}}}, Ptr{Void}),\n                &ptr, common())\nend\n\nfunction aat{Tv<:VRealTypes}(A::Sparse{Tv}, fset::Vector{SuiteSparse_long}, mode::Integer)\n    s = Sparse(ccall((@cholmod_name(\"aat\", SuiteSparse_long), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{SuiteSparse_long}, Csize_t, Cint, Ptr{UInt8}),\n                get(A.p), fset, length(fset), mode, common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction sparse_to_dense{Tv<:VTypes}(A::Sparse{Tv})\n    d = Dense(ccall((@cholmod_name(\"sparse_to_dense\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Dense{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                get(A.p), common()))\n    finalizer(d, free!)\n    d\nend\nfunction dense_to_sparse{Tv<:VTypes}(D::Dense{Tv}, ::Type{SuiteSparse_long})\n    s = Sparse(ccall((@cholmod_name(\"dense_to_sparse\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Dense{Tv}}, Cint, Ptr{UInt8}),\n                get(D.p), true, common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction factor_to_sparse!{Tv<:VTypes}(F::Factor{Tv})\n    ss = unsafe_load(F.p)\n    ss.xtype > PATTERN || throw(CHOLMODException(\"only numeric factors are supported\"))\n    s = Sparse(ccall((@cholmod_name(\"factor_to_sparse\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                get(F.p), common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction change_factor!{Tv<:VTypes}(::Type{Float64}, to_ll::Bool, to_super::Bool, to_packed::Bool, to_monotonic::Bool, F::Factor{Tv})\n    @isok ccall((@cholmod_name(\"change_factor\", SuiteSparse_long),:libcholmod), Cint,\n            (Cint, Cint, Cint, Cint, Cint, Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                REAL, to_ll, to_super, to_packed, to_monotonic, get(F.p), common())\n    Factor{Float64}(F.p)\nend\n\nfunction change_factor!{Tv<:VTypes}(::Type{Complex{Float64}}, to_ll::Bool, to_super::Bool, to_packed::Bool, to_monotonic::Bool, F::Factor{Tv})\n    @isok ccall((@cholmod_name(\"change_factor\", SuiteSparse_long),:libcholmod), Cint,\n            (Cint, Cint, Cint, Cint, Cint, Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                COMPLEX, to_ll, to_super, to_packed, to_monotonic, get(F.p), common())\n    Factor{Complex{Float64}}(F.p)\nend\n\nfunction check_sparse{Tv<:VTypes}(A::Sparse{Tv})\n    ccall((@cholmod_name(\"check_sparse\", SuiteSparse_long),:libcholmod), Cint,\n          (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n          get(A.p), common())!=0\nend\n\nfunction check_factor{Tv<:VTypes}(F::Factor{Tv})\n    ccall((@cholmod_name(\"check_factor\", SuiteSparse_long),:libcholmod), Cint,\n          (Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n          get(F.p), common())!=0\nend\n\nfunction nnz{Tv<:VTypes}(A::Sparse{Tv})\n    ccall((@cholmod_name(\"nnz\", SuiteSparse_long),:libcholmod), Int,\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                get(A.p), common())\nend\n\nfunction speye{Tv<:VTypes}(m::Integer, n::Integer, ::Type{Tv})\n    s = Sparse(ccall((@cholmod_name(\"speye\", SuiteSparse_long), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n                m, n, xtyp(Tv), common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction spzeros{Tv<:VTypes}(m::Integer, n::Integer, nzmax::Integer, ::Type{Tv})\n    s = Sparse(ccall((@cholmod_name(\"spzeros\", SuiteSparse_long), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Csize_t, Csize_t, Csize_t, Cint, Ptr{UInt8}),\n             m, n, nzmax, xtyp(Tv), common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction transpose_{Tv<:VTypes}(A::Sparse{Tv}, values::Integer)\n    s = Sparse(ccall((@cholmod_name(\"transpose\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n                get(A.p), values, common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction copy_factor{Tv<:VTypes}(F::Factor{Tv})\n    f = Factor(ccall((@cholmod_name(\"copy_factor\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Factor{Tv}},\n            (Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                get(F.p), common()))\n    finalizer(f, free!)\n    f\nend\nfunction copy_sparse{Tv<:VTypes}(A::Sparse{Tv})\n    s = Sparse(ccall((@cholmod_name(\"copy_sparse\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                get(A.p), common()))\n    finalizer(s, free!)\n    s\nend\nfunction copy{Tv<:VRealTypes}(A::Sparse{Tv}, stype::Integer, mode::Integer)\n    s = Sparse(ccall((@cholmod_name(\"copy\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Cint, Cint, Ptr{UInt8}),\n                get(A.p), stype, mode, common()))\n    finalizer(s, free!)\n    s\nend\n\n### cholmod_check.h ###\nfunction print_sparse{Tv<:VTypes}(A::Sparse{Tv}, name::String)\n    isascii(name) || error(\"non-ASCII name: $name\")\n    cm = common()\n    set_print_level(cm, 3)\n    @isok ccall((@cholmod_name(\"print_sparse\", SuiteSparse_long),:libcholmod), Cint,\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}, Ptr{UInt8}),\n                 get(A.p), name, cm)\n    nothing\nend\nfunction print_factor{Tv<:VTypes}(F::Factor{Tv}, name::String)\n    cm = common()\n    set_print_level(cm, 3)\n    @isok ccall((@cholmod_name(\"print_factor\", SuiteSparse_long),:libcholmod), Cint,\n            (Ptr{C_Factor{Tv}}, Ptr{UInt8}, Ptr{UInt8}),\n                get(F.p), name, cm)\n    nothing\nend\n\n### cholmod_matrixops.h ###\nfunction ssmult{Tv<:VRealTypes}(A::Sparse{Tv}, B::Sparse{Tv}, stype::Integer, values::Bool, sorted::Bool)\n    lA = unsafe_load(get(A.p))\n    lB = unsafe_load(get(B.p))\n    if lA.ncol != lB.nrow\n        throw(DimensionMismatch(\"inner matrix dimensions do not fit\"))\n    end\n    s = Sparse(ccall((@cholmod_name(\"ssmult\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{C_Sparse{Tv}}, Cint, Cint,\n                Cint, Ptr{UInt8}),\n             get(A.p), get(B.p), stype, values,\n                sorted, common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction norm_sparse{Tv<:VTypes}(A::Sparse{Tv}, norm::Integer)\n    if norm != 0 && norm != 1\n        throw(ArgumentError(\"norm argument must be either 0 or 1\"))\n    end\n    ccall((@cholmod_name(\"norm_sparse\", SuiteSparse_long), :libcholmod), Cdouble,\n            (Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n                get(A.p), norm, common())\nend\n\nfunction horzcat{Tv<:VRealTypes}(A::Sparse{Tv}, B::Sparse{Tv}, values::Bool)\n    s = Sparse(ccall((@cholmod_name(\"horzcat\", SuiteSparse_long), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n             get(A.p), get(B.p), values, common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction scale!{Tv<:VRealTypes}(S::Dense{Tv}, scale::Integer, A::Sparse{Tv})\n    sS = unsafe_load(get(S.p))\n    sA = unsafe_load(get(A.p))\n    sS.ncol == 1 || sS.nrow == 1 || throw(DimensionMismatch(\"first argument must be a vector\"))\n    if scale == SCALAR && sS.nrow != 1\n        throw(DimensionMismatch(\"scaling argument must have length one\"))\n    elseif scale == ROW && sS.nrow*sS.ncol != sA.nrow\n        throw(DimensionMismatch(\"scaling vector has length $(sS.nrow*sS.ncol), but matrix has $(sA.nrow) rows.\"))\n    elseif scale == COL && sS.nrow*sS.ncol != sA.ncol\n        throw(DimensionMismatch(\"scaling vector has length $(sS.nrow*sS.ncol), but matrix has $(sA.ncol) columns\"))\n    elseif scale == SYM\n        if sA.nrow != sA.ncol\n            throw(DimensionMismatch(\"matrix must be square\"))\n        elseif sS.nrow*sS.ncol != sA.nrow\n            throw(DimensionMismatch(\"scaling vector has length $(sS.nrow*sS.ncol), but matrix has $(sA.ncol) columns and rows\"))\n        end\n    end\n\n    sA = unsafe_load(get(A.p))\n    @isok ccall((@cholmod_name(\"scale\",SuiteSparse_long),:libcholmod), Cint,\n            (Ptr{C_Dense{Tv}}, Cint, Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                get(S.p), scale, get(A.p), common())\n    A\nend\n\nfunction sdmult!{Tv<:VTypes}(A::Sparse{Tv}, transpose::Bool, \u03b1::Number, \u03b2::Number, X::Dense{Tv}, Y::Dense{Tv})\n    m, n = size(A)\n    nc = transpose ? m : n\n    nr = transpose ? n : m\n    if nc != size(X, 1)\n        throw(DimensionMismatch(\"incompatible dimensions, $nc and $(size(X,1))\"))\n    end\n    @isok ccall((@cholmod_name(\"sdmult\", SuiteSparse_long),:libcholmod), Cint,\n            (Ptr{C_Sparse{Tv}}, Cint,\n             Ref{Complex128}, Ref{Complex128},\n             Ptr{C_Dense{Tv}}, Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n                get(A.p), transpose, \u03b1, \u03b2, get(X.p), get(Y.p), common())\n    Y\nend\n\nfunction vertcat{Tv<:VRealTypes}(A::Sparse{Tv}, B::Sparse{Tv}, values::Bool)\n    s = Sparse(ccall((@cholmod_name(\"vertcat\", SuiteSparse_long), :libcholmod), Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n                get(A.p), get(B.p), values, common()))\n    finalizer(s, free!)\n    s\nend\n\nfunction symmetry{Tv<:VTypes}(A::Sparse{Tv}, option::Integer)\n    xmatched = Array{SuiteSparse_long}(1)\n    pmatched = Array{SuiteSparse_long}(1)\n    nzoffdiag = Array{SuiteSparse_long}(1)\n    nzdiag = Array{SuiteSparse_long}(1)\n    rv = ccall((@cholmod_name(\"symmetry\", SuiteSparse_long), :libcholmod), Cint,\n            (Ptr{C_Sparse{Tv}}, Cint, Ptr{SuiteSparse_long}, Ptr{SuiteSparse_long},\n                Ptr{SuiteSparse_long}, Ptr{SuiteSparse_long}, Ptr{UInt8}),\n                    get(A.p), option, xmatched, pmatched,\n                        nzoffdiag, nzdiag, common())\n    rv, xmatched[1], pmatched[1], nzoffdiag[1], nzdiag[1]\nend\n\n# cholmod_cholesky.h\n# For analyze, analyze_p, and factorize_p!, the Common argument must be\n# supplied in order to control if the factorization is LLt or LDLt\nfunction analyze{Tv<:VTypes}(A::Sparse{Tv}, cmmn::Vector{UInt8})\n    f = Factor(ccall((@cholmod_name(\"analyze\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Factor{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                get(A.p), cmmn))\n    finalizer(f, free!)\n    f\nend\nfunction analyze_p{Tv<:VTypes}(A::Sparse{Tv}, perm::Vector{SuiteSparse_long},\n    cmmn::Vector{UInt8})\n    length(perm) != size(A,1) && throw(BoundsError())\n    f = Factor(ccall((@cholmod_name(\"analyze_p\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Factor{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{SuiteSparse_long}, Ptr{SuiteSparse_long}, Csize_t, Ptr{UInt8}),\n                get(A.p), perm, C_NULL, 0, cmmn))\n    finalizer(f, free!)\n    f\nend\nfunction factorize!{Tv<:VTypes}(A::Sparse{Tv}, F::Factor{Tv}, cmmn::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"factorize\", SuiteSparse_long),:libcholmod), Cint,\n        (Ptr{C_Sparse{Tv}}, Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n            get(A.p), get(F.p), cmmn)\n    F\nend\nfunction factorize_p!{Tv<:VTypes}(A::Sparse{Tv}, \u03b2::Real, F::Factor{Tv}, cmmn::Vector{UInt8})\n    # note that \u03b2 is passed as a complex number (double beta[2]),\n    # but the CHOLMOD manual says that only beta[0] (real part) is used\n    @isok ccall((@cholmod_name(\"factorize_p\", SuiteSparse_long),:libcholmod), Cint,\n        (Ptr{C_Sparse{Tv}}, Ref{Complex128}, Ptr{SuiteSparse_long}, Csize_t,\n         Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n            get(A.p), \u03b2, C_NULL, 0, get(F.p), cmmn)\n    F\nend\n\nfunction solve{Tv<:VTypes}(sys::Integer, F::Factor{Tv}, B::Dense{Tv})\n    if size(F,1) != size(B,1)\n        throw(DimensionMismatch(\"LHS and RHS should have the same number of rows. LHS has $(size(F,1)) rows, but RHS has $(size(B,1)) rows.\"))\n    end\n    d = Dense(ccall((@cholmod_name(\"solve\", SuiteSparse_long),:libcholmod), Ptr{C_Dense{Tv}},\n            (Cint, Ptr{C_Factor{Tv}}, Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n                sys, get(F.p), get(B.p), common()))\n    finalizer(d, free!)\n    d\nend\n\nfunction spsolve{Tv<:VTypes}(sys::Integer, F::Factor{Tv}, B::Sparse{Tv})\n    if size(F,1) != size(B,1)\n        throw(DimensionMismatch(\"LHS and RHS should have the same number of rows. LHS has $(size(F,1)) rows, but RHS has $(size(B,1)) rows.\"))\n    end\n    s = Sparse(ccall((@cholmod_name(\"spsolve\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Cint, Ptr{C_Factor{Tv}}, Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                sys, get(F.p), get(B.p), common()))\n    finalizer(s, free!)\n    s\nend\n\n# Autodetects the types\nfunction read_sparse(file::Libc.FILE, ::Type{SuiteSparse_long})\n    ptr = ccall((@cholmod_name(\"read_sparse\", SuiteSparse_long), :libcholmod),\n        Ptr{C_SparseVoid},\n            (Ptr{Void}, Ptr{UInt8}),\n                file.ptr, common())\n    if ptr == C_NULL\n        throw(ArgumentError(\"sparse matrix construction failed. Check that input file is valid.\"))\n    end\n    s = Sparse(ptr)\n    finalizer(s, free!)\n    s\nend\n\nfunction read_sparse(file::IO, T)\n    cfile = Libc.FILE(file)\n    try return read_sparse(cfile, T)\n    finally close(cfile)\n    end\nend\n\nfunction get_perm(F::Factor)\n    s = unsafe_load(get(F.p))\n    p = unsafe_wrap(Array, s.Perm, s.n, false)\n    p+1\nend\nget_perm(FC::FactorComponent) = get_perm(Factor(FC))\n\n#########################\n# High level interfaces #\n#########################\n\n# Convertion/construction\nfunction convert{T<:VTypes}(::Type{Dense{T}}, A::StridedVecOrMat)\n    d = allocate_dense(size(A, 1), size(A, 2), stride(A, 2), T)\n    s = unsafe_load(d.p)\n    for i in eachindex(A)\n        unsafe_store!(s.x, A[i], i)\n    end\n    d\nend\nfunction convert(::Type{Dense}, A::StridedVecOrMat)\n    T = promote_type(eltype(A), Float64)\n    return convert(Dense{T}, A)\nend\nconvert(::Type{Dense}, A::Sparse) = sparse_to_dense(A)\n\n# This constructior assumes zero based colptr and rowval\nfunction (::Type{Sparse}){Tv<:VTypes}(m::Integer, n::Integer,\n        colptr0::Vector{SuiteSparse_long}, rowval0::Vector{SuiteSparse_long},\n        nzval::Vector{Tv}, stype)\n    # checks\n    ## length of input\n    if length(colptr0) <= n\n        throw(ArgumentError(\"length of colptr0 must be at least n + 1 = $(n + 1) but was $(length(colptr0))\"))\n    end\n    if colptr0[n + 1] > length(rowval0)\n        throw(ArgumentError(\"length of rowval0 is $(length(rowval0)) but value of colptr0 requires length to be at least $(colptr0[n + 1])\"))\n    end\n    if colptr0[n + 1] > length(nzval)\n        throw(ArgumentError(\"length of nzval is $(length(nzval)) but value of colptr0 requires length to be at least $(colptr0[n + 1])\"))\n    end\n    ## columns are sorted\n    iss = true\n    for i = 2:length(colptr0)\n        if !issorted(view(rowval0, colptr0[i - 1] + 1:colptr0[i]))\n            iss = false\n            break\n        end\n    end\n\n    o = allocate_sparse(m, n, colptr0[n + 1], iss, true, stype, Tv)\n    s = unsafe_load(o.p)\n\n    unsafe_copy!(s.p, pointer(colptr0), n + 1)\n    unsafe_copy!(s.i, pointer(rowval0), colptr0[n + 1])\n    unsafe_copy!(s.x, pointer(nzval) , colptr0[n + 1])\n\n    @isok check_sparse(o)\n\n    return o\nend\n\nfunction (::Type{Sparse}){Tv<:VTypes}(m::Integer, n::Integer,\n        colptr0::Vector{SuiteSparse_long},\n        rowval0::Vector{SuiteSparse_long},\n        nzval::Vector{Tv})\n    o = Sparse(m, n, colptr0, rowval0, nzval, 0)\n\n    # check if array is symmetric and change stype if it is\n    if ishermitian(o)\n        change_stype!(o, -1)\n    end\n    o\nend\n\nfunction (::Type{Sparse}){Tv<:VTypes}(A::SparseMatrixCSC{Tv,SuiteSparse_long}, stype::Integer)\n    ## Check length of input. This should never fail but see #20024\n    if length(A.colptr) <= A.n\n        throw(ArgumentError(\"length of colptr must be at least size(A,2) + 1 = $(A.n + 1) but was $(length(A.colptr))\"))\n    end\n    if nnz(A) > length(A.rowval)\n        throw(ArgumentError(\"length of rowval is $(length(A.rowval)) but value of colptr requires length to be at least $(nnz(A))\"))\n    end\n    if nnz(A) > length(A.nzval)\n        throw(ArgumentError(\"length of nzval is $(length(A.nzval)) but value of colptr requires length to be at least $(nnz(A))\"))\n    end\n\n    o = allocate_sparse(A.m, A.n, nnz(A), true, true, stype, Tv)\n    s = unsafe_load(o.p)\n    for i = 1:(A.n + 1)\n        unsafe_store!(s.p, A.colptr[i] - 1, i)\n    end\n    for i = 1:nnz(A)\n        unsafe_store!(s.i, A.rowval[i] - 1, i)\n    end\n    unsafe_copy!(s.x, pointer(A.nzval), nnz(A))\n\n    @isok check_sparse(o)\n\n    return o\nend\n\n# convert SparseVectors into CHOLMOD Sparse types through a mx1 CSC matrix\nconvert{Tv<:VTypes}(::Type{Sparse}, A::SparseVector{Tv,SuiteSparse_long}) = convert(Sparse, convert(SparseMatrixCSC, A))\nfunction convert{Tv<:VTypes,Ti<:ITypes}(::Type{Sparse}, A::SparseMatrixCSC{Tv,Ti})\n    o = Sparse(A, 0)\n    # check if array is symmetric and change stype if it is\n    if ishermitian(o)\n        change_stype!(o, -1)\n    end\n    o\nend\nconvert{Ti<:ITypes}(::Type{Sparse}, A::SparseMatrixCSC{Complex{Float32},Ti}) = convert(Sparse, convert(SparseMatrixCSC{Complex{Float64},SuiteSparse_long}, A))\nconvert(::Type{Sparse}, A::Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}) = Sparse(A.data, A.uplo == 'L' ? -1 : 1)\nconvert{Tv<:VTypes}(::Type{Sparse}, A::Hermitian{Tv,SparseMatrixCSC{Tv,SuiteSparse_long}}) = Sparse(A.data, A.uplo == 'L' ? -1 : 1)\nfunction convert{Ti<:ITypes}(::Type{Sparse},\n    A::Union{SparseMatrixCSC{BigFloat,Ti},\n             Symmetric{BigFloat,SparseMatrixCSC{BigFloat,Ti}},\n             Hermitian{Complex{BigFloat},SparseMatrixCSC{Complex{BigFloat},Ti}}},\n    args...)\n    throw(MethodError(convert, (Sparse, A)))\nend\nfunction convert{T,Ti<:ITypes}(::Type{Sparse},\n    A::Union{SparseMatrixCSC{T,Ti},\n             Symmetric{T,SparseMatrixCSC{T,Ti}},\n             Hermitian{T,SparseMatrixCSC{T,Ti}}},\n    args...)\n    return Sparse(convert(AbstractMatrix{promote_type(Float64, T)}, A), args...)\nend\n\n# Useful when reading in files, but not type stable\nfunction convert(::Type{Sparse}, p::Ptr{C_SparseVoid})\n    if p == C_NULL\n        throw(ArgumentError(\"sparse matrix construction failed for unknown reasons. Please submit a bug report.\"))\n    end\n\n    s = unsafe_load(p)\n\n    # Check integer type\n    if s.itype == INT\n        free_sparse!(p)\n        throw(CHOLMODException(\"the value of itype was $s.itype. Only integer type of $SuiteSparse_long is supported.\"))\n    elseif s.itype == INTLONG\n        free_sparse!(p)\n        throw(CHOLMODException(\"the value of itype was $s.itype. This combination of integer types shouldn't happen. Please submit a bug report.\"))\n    elseif s.itype != LONG # must be s.itype == LONG\n        free_sparse!(p)\n        throw(CHOLMODException(\"illegal value of itype: $s.itype\"))\n    end\n\n    # Check for double or single precision\n    if s.dtype == DOUBLE\n        Tv = Float64\n    elseif s.dtype == SINGLE\n        # Tv = Float32 # this should be supported at some point\n        free_sparse!(p)\n        throw(CHOLMODException(\"single precision not supported yet\"))\n    else\n        free_sparse!(p)\n        throw(CHOLMODException(\"illegal value of dtype: $s.dtype\"))\n    end\n\n    # Check for real or complex\n    if s.xtype == COMPLEX\n        Tv = Complex{Tv}\n    elseif s.xtype != REAL\n        free_sparse!(p)\n        throw(CHOLMODException(\"illegal value of xtype: $s.xtype\"))\n    end\n\n    return Sparse(convert(Ptr{C_Sparse{Tv}}, p))\nend\n\nconvert(::Type{Sparse}, A::Dense) = dense_to_sparse(A, SuiteSparse_long)\nconvert(::Type{Sparse}, L::Factor) = factor_to_sparse!(copy(L))\nfunction (::Type{Sparse})(filename::String)\n    open(filename) do f\n        return read_sparse(f, SuiteSparse_long)\n    end\nend\n\n## convertion back to base Julia types\nfunction convert{T}(::Type{Matrix{T}}, D::Dense{T})\n    s = unsafe_load(D.p)\n    a = Array{T}(s.nrow, s.ncol)\n    copy!(a, D)\nend\n\nBase.copy!(dest::Base.PermutedDimsArrays.PermutedDimsArray, src::Dense) = _copy!(dest, src) # ambig\nBase.copy!(dest::AbstractArray, D::Dense) = _copy!(dest, D)\n\nfunction _copy!(dest::AbstractArray, D::Dense)\n    s = unsafe_load(D.p)\n    n = s.nrow*s.ncol\n    n <= length(dest) || throw(BoundsError(dest, n))\n    if s.d == s.nrow && isa(dest, Array)\n        unsafe_copy!(pointer(dest), s.x, s.d*s.ncol)\n    else\n        k = 0\n        for j = 1:s.ncol\n            for i = 1:s.nrow\n                dest[k+=1] = unsafe_load(s.x, i + (j - 1)*s.d)\n            end\n        end\n    end\n    dest\nend\nconvert{T}(::Type{Matrix}, D::Dense{T}) = convert(Matrix{T}, D)\nfunction convert{T}(::Type{Vector{T}}, D::Dense{T})\n    if size(D, 2) > 1\n        throw(DimensionMismatch(\"input must be a vector but had $(size(D, 2)) columns\"))\n    end\n    copy!(Array{T}(size(D, 1)), D)\nend\nconvert{T}(::Type{Vector}, D::Dense{T}) = convert(Vector{T}, D)\n\nfunction convert{Tv}(::Type{SparseMatrixCSC{Tv,SuiteSparse_long}}, A::Sparse{Tv})\n    s = unsafe_load(A.p)\n    if s.stype != 0\n        throw(ArgumentError(\"matrix has stype != 0. Convert to matrix with stype == 0 before converting to SparseMatrixCSC\"))\n    end\n    return SparseMatrixCSC(s.nrow, s.ncol, increment(unsafe_wrap(Array, s.p, (s.ncol + 1,), false)), increment(unsafe_wrap(Array, s.i, (s.nzmax,), false)), copy(unsafe_wrap(Array, s.x, (s.nzmax,), false)))\nend\nfunction convert(::Type{Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}}, A::Sparse{Float64})\n    s = unsafe_load(A.p)\n    if !issymmetric(A)\n        throw(ArgumentError(\"matrix is not symmetric\"))\n    end\n    return Symmetric(SparseMatrixCSC(s.nrow, s.ncol, increment(unsafe_wrap(Array, s.p, (s.ncol + 1,), false)), increment(unsafe_wrap(Array, s.i, (s.nzmax,), false)), copy(unsafe_wrap(Array, s.x, (s.nzmax,), false))), s.stype > 0 ? :U : :L)\nend\nfunction convert{Tv<:VTypes}(::Type{Hermitian{Tv,SparseMatrixCSC{Tv,SuiteSparse_long}}}, A::Sparse{Tv})\n    s = unsafe_load(A.p)\n    if !ishermitian(A)\n        throw(ArgumentError(\"matrix is not Hermitian\"))\n    end\n    return Hermitian(SparseMatrixCSC(s.nrow, s.ncol, increment(unsafe_wrap(Array, s.p, (s.ncol + 1,), false)), increment(unsafe_wrap(Array, s.i, (s.nzmax,), false)), copy(unsafe_wrap(Array, s.x, (s.nzmax,), false))), s.stype > 0 ? :U : :L)\nend\nfunction sparse(A::Sparse{Float64}) # Notice! Cannot be type stable because of stype\n    s = unsafe_load(A.p)\n    if s.stype == 0\n        return convert(SparseMatrixCSC{Float64,SuiteSparse_long}, A)\n    end\n    return convert(Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}, A)\nend\nfunction sparse(A::Sparse{Complex{Float64}}) # Notice! Cannot be type stable because of stype\n    s = unsafe_load(A.p)\n    if s.stype == 0\n        return convert(SparseMatrixCSC{Complex{Float64},SuiteSparse_long}, A)\n    end\n    return convert(Hermitian{Complex{Float64},SparseMatrixCSC{Complex{Float64},SuiteSparse_long}}, A)\nend\nfunction sparse(F::Factor)\n    s = unsafe_load(F.p)\n    if s.is_ll != 0\n        L = Sparse(F)\n        A = sparse(L*L')\n    else\n        LD = sparse(F[:LD])\n        L, d = getLd!(LD)\n        A = (L * Diagonal(d)) * L'\n    end\n    SparseArrays.sortSparseMatrixCSC!(A)\n    p = get_perm(F)\n    if p != [1:s.n;]\n        pinv = Array{Int}(length(p))\n        for k = 1:length(p)\n            pinv[p[k]] = k\n        end\n        A = A[pinv,pinv]\n    end\n    A\nend\n\nsparse(D::Dense) = sparse(Sparse(D))\n\nfunction sparse{Tv}(FC::FactorComponent{Tv,:L})\n    F = Factor(FC)\n    s = unsafe_load(F.p)\n    s.is_ll != 0 || throw(CHOLMODException(\"sparse: supported only for :LD on LDLt factorizations\"))\n    sparse(Sparse(F))\nend\nsparse{Tv}(FC::FactorComponent{Tv,:LD}) = sparse(Sparse(Factor(FC)))\n\n# Calculate the offset into the stype field of the cholmod_sparse_struct and\n# change the value\nlet offset = fieldoffset(C_Sparse{Float64}, findfirst(fieldnames(C_Sparse) .== :stype))\n    global change_stype!\n    function change_stype!(A::Sparse, i::Integer)\n        unsafe_store!(convert(Ptr{Cint}, A.p), i, div(offset, 4) + 1)\n        return A\n    end\nend\n\nfree!(A::Dense) = free_dense!(A.p)\nfree!(A::Sparse) = free_sparse!(A.p)\nfree!(F::Factor) = free_factor!(F.p)\n\neltype{T<:VTypes}(::Type{Dense{T}}) = T\neltype{T<:VTypes}(::Type{Factor{T}}) = T\neltype{T<:VTypes}(::Type{Sparse{T}}) = T\n\nnnz(F::Factor) = nnz(Sparse(F))\n\nfunction show(io::IO, F::Factor)\n    println(io, typeof(F))\n    showfactor(io, F)\nend\n\nfunction show(io::IO, FC::FactorComponent)\n    println(io, typeof(FC))\n    showfactor(io, Factor(FC))\nend\n\nfunction showfactor(io::IO, F::Factor)\n    s = unsafe_load(get(F.p))\n    @printf(io, \"type: %12s\\n\", s.is_ll!=0 ? \"LLt\" : \"LDLt\")\n    @printf(io, \"method: %10s\\n\", s.is_super!=0 ? \"supernodal\" : \"simplicial\")\n    @printf(io, \"maxnnz: %10d\\n\", Int(s.nzmax))\n    @printf(io, \"nnz: %13d\\n\", nnz(F))\nend\n\n# getindex not defined for these, so don't use the normal array printer\nshow(io::IO, ::MIME\"text/plain\", FC::FactorComponent) = show(io, FC)\nshow(io::IO, ::MIME\"text/plain\", F::Factor) = show(io, F)\n\nisvalid(A::Dense) = check_dense(A)\nisvalid(A::Sparse) = check_sparse(A)\nisvalid(A::Factor) = check_factor(A)\n\ncopy(A::Dense) = copy_dense(A)\ncopy(A::Sparse) = copy_sparse(A)\ncopy(A::Factor) = copy_factor(A)\n\nfunction size(A::Union{Dense,Sparse})\n    s = unsafe_load(get(A.p))\n    return (Int(s.nrow), Int(s.ncol))\nend\nfunction size(F::Factor, i::Integer)\n    if i < 1\n        throw(ArgumentError(\"dimension must be positive\"))\n    end\n    s = unsafe_load(get(F.p))\n    if i <= 2\n        return Int(s.n)\n    end\n    return 1\nend\nsize(F::Factor) = (size(F, 1), size(F, 2))\n\nlinearindexing(::Dense) = LinearFast()\n\nsize(FC::FactorComponent, i::Integer) = size(FC.F, i)\nsize(FC::FactorComponent) = size(FC.F)\n\nctranspose{Tv}(FC::FactorComponent{Tv,:L}) = FactorComponent{Tv,:U}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:U}) = FactorComponent{Tv,:L}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:PtL}) = FactorComponent{Tv,:UP}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:UP}) = FactorComponent{Tv,:PtL}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:D}) = FC\nctranspose{Tv}(FC::FactorComponent{Tv,:LD}) = FactorComponent{Tv,:DU}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:DU}) = FactorComponent{Tv,:LD}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:PtLD}) = FactorComponent{Tv,:DUP}(FC.F)\nctranspose{Tv}(FC::FactorComponent{Tv,:DUP}) = FactorComponent{Tv,:PtLD}(FC.F)\n\nfunction getindex(A::Dense, i::Integer)\n    s = unsafe_load(get(A.p))\n    0 < i <= s.nrow*s.ncol || throw(BoundsError())\n    unsafe_load(s.x, i)\nend\n\nlinearindexing(::Sparse) = LinearSlow()\nfunction getindex{T}(A::Sparse{T}, i0::Integer, i1::Integer)\n    s = unsafe_load(get(A.p))\n    !(1 <= i0 <= s.nrow && 1 <= i1 <= s.ncol) && throw(BoundsError())\n    s.stype < 0 && i0 < i1 && return conj(A[i1,i0])\n    s.stype > 0 && i0 > i1 && return conj(A[i1,i0])\n\n    r1 = Int(unsafe_load(s.p, i1) + 1)\n    r2 = Int(unsafe_load(s.p, i1 + 1))\n    (r1 > r2) && return zero(T)\n    r1 = Int(searchsortedfirst(unsafe_wrap(Array, s.i, (s.nzmax,), false), i0 - 1, r1, r2, Base.Order.Forward))\n    ((r1 > r2) || (unsafe_load(s.i, r1) + 1 != i0)) ? zero(T) : unsafe_load(s.x, r1)\nend\n\nfunction getindex(F::Factor, sym::Symbol)\n    sym == :p && return get_perm(F)\n    FactorComponent(F, sym)\nend\n\nfunction getLd!(S::SparseMatrixCSC)\n    d = Array{eltype(S)}(size(S, 1))\n    fill!(d, 0)\n    col = 1\n    for k = 1:nnz(S)\n        while k >= S.colptr[col+1]\n            col += 1\n        end\n        if S.rowval[k] == col\n            d[col] = S.nzval[k]\n            S.nzval[k] = 1\n        end\n    end\n    S, d\nend\n\n## Multiplication\n(*)(A::Sparse, B::Sparse) = ssmult(A, B, 0, true, true)\n(*)(A::Sparse, B::Dense) = sdmult!(A, false, 1., 0., B, zeros(size(A, 1), size(B, 2)))\n(*)(A::Sparse, B::VecOrMat) = (*)(A, Dense(B))\n\nfunction A_mul_Bc{Tv<:VRealTypes}(A::Sparse{Tv}, B::Sparse{Tv})\n    cm = common()\n\n    if !is(A,B)\n        aa1 = transpose_(B, 2)\n        ## result of ssmult will have stype==0, contain numerical values and be sorted\n        return ssmult(A, aa1, 0, true, true)\n    end\n\n    ## The A*A' case is handled by cholmod_aat. This routine requires\n    ## A->stype == 0 (storage of upper and lower parts). If neccesary\n    ## the matrix A is first converted to stype == 0\n    s = unsafe_load(A.p)\n    if s.stype != 0\n        aa1 = copy(A, 0, 1)\n        return aat(aa1, SuiteSparse_long[0:s.ncol-1;], 1)\n    else\n        return aat(A, SuiteSparse_long[0:s.ncol-1;], 1)\n    end\nend\n\nfunction Ac_mul_B(A::Sparse, B::Sparse)\n    aa1 = transpose_(A, 2)\n    if is(A,B)\n        return A_mul_Bc(aa1, aa1)\n    end\n    ## result of ssmult will have stype==0, contain numerical values and be sorted\n    return ssmult(aa1, B, 0, true, true)\nend\n\nAc_mul_B(A::Sparse, B::Dense) = sdmult!(A, true, 1., 0., B, zeros(size(A, 2), size(B, 2)))\nAc_mul_B(A::Sparse, B::VecOrMat) =  Ac_mul_B(A, Dense(B))\n\n\n## Factorization methods\n\n## Compute that symbolic factorization only\nfunction fact_{Tv<:VTypes}(A::Sparse{Tv}, cm::Array{UInt8};\n    perm::AbstractVector{SuiteSparse_long}=SuiteSparse_long[],\n    postorder::Bool=true, userperm_only::Bool=true)\n\n    sA = unsafe_load(get(A.p))\n    sA.stype == 0 && throw(ArgumentError(\"sparse matrix is not symmetric/Hermitian\"))\n\n    if !postorder\n        unsafe_store!(common_postorder, 0)\n    end\n\n    if isempty(perm)\n        F = analyze(A, cm)\n    else # user permutation provided\n        if userperm_only # use perm even if it is worse than AMD\n            unsafe_store!(common_nmethods, 1)\n        end\n        F = analyze_p(A, SuiteSparse_long[p-1 for p in perm], cm)\n    end\n\n    return F\nend\n\nfunction cholfact!{Tv}(F::Factor{Tv}, A::Sparse{Tv}; shift::Real=0.0)\n    cm = common()\n\n    # Makes it an LLt\n    unsafe_store!(common_final_ll, 1)\n\n    # Compute the numerical factorization\n    factorize_p!(A, shift, F, cm)\n\n    s = unsafe_load(get(F.p))\n    s.minor < size(A, 1) && throw(Base.LinAlg.PosDefException(s.minor))\n    return F\nend\n\n\"\"\"\n    cholfact!(F::Factor, A; shift = 0.0) -> CHOLMOD.Factor\n\nCompute the Cholesky (``LL'``) factorization of `A`, reusing the symbolic\nfactorization `F`. `A` must be a `SparseMatrixCSC`, `Symmetric{SparseMatrixCSC}`,\nor `Hermitian{SparseMatrixCSC}`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{Complex128}`\n    as appropriate.\n\"\"\"\ncholfact!{T<:Real}(F::Factor, A::Union{SparseMatrixCSC{T},\n        SparseMatrixCSC{Complex{T}},\n        Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n        Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n        Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n    shift = 0.0) =\n    cholfact!(F, Sparse(A); shift = shift)\n\nfunction cholfact(A::Sparse; shift::Real=0.0,\n    perm::AbstractVector{SuiteSparse_long}=SuiteSparse_long[])\n\n    cm = defaults(common())\n    set_print_level(cm, 0)\n\n    # Compute the symbolic factorization\n    F = fact_(A, cm; perm = perm)\n\n    # Compute the numerical factorization\n    cholfact!(F, A; shift = shift)\n\n    s = unsafe_load(get(F.p))\n    s.minor < size(A, 1) && throw(Base.LinAlg.PosDefException(s.minor))\n    return F\nend\n\n\"\"\"\n    cholfact(A; shift = 0.0, perm = Int[]) -> CHOLMOD.Factor\n\nCompute the Cholesky factorization of a sparse positive definite matrix `A`.\n`A` must be a `SparseMatrixCSC`, `Symmetric{SparseMatrixCSC}`, or\n`Hermitian{SparseMatrixCSC}`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\nA fill-reducing permutation is used.\n`F = cholfact(A)` is most frequently used to solve systems of equations with `F\\\\b`,\nbut also the methods `diag`, `det`, `logdet` are defined for `F`.\nYou can also extract individual factors from `F`, using `F[:L]`.\nHowever, since pivoting is on by default, the factorization is internally\nrepresented as `A == P'*L*L'*P` with a permutation matrix `P`;\nusing just `L` without accounting for `P` will give incorrect answers.\nTo include the effects of permutation,\nit's typically preferable to extact \"combined\" factors like `PtL = F[:PtL]`\n(the equivalent of `P'*L`) and `LtP = F[:UP]` (the equivalent of `L'*P`).\n\nSetting optional `shift` keyword argument computes the factorization of\n`A+shift*I` instead of `A`. If the `perm` argument is nonempty,\nit should be a permutation of `1:size(A,1)` giving the ordering to use\n(instead of CHOLMOD's default AMD ordering).\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{Complex128}`\n    as appropriate.\n\n    Many other functions from CHOLMOD are wrapped but not exported from the\n    `Base.SparseArrays.CHOLMOD` module.\n\"\"\"\ncholfact{T<:Real}(A::Union{SparseMatrixCSC{T}, SparseMatrixCSC{Complex{T}},\n    Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n    Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n    Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n    kws...) = cholfact(Sparse(A); kws...)\n\n\nfunction ldltfact!{Tv}(F::Factor{Tv}, A::Sparse{Tv}; shift::Real=0.0)\n    cm = common()\n\n    # Compute the numerical factorization\n    factorize_p!(A, shift, F, cm)\n\n    s = unsafe_load(get(F.p))\n    s.minor < size(A, 1) && throw(Base.LinAlg.ArgumentError(\"matrix has one or more zero pivots\"))\n    return F\nend\n\n\"\"\"\n    ldltfact!(F::Factor, A; shift = 0.0) -> CHOLMOD.Factor\n\nCompute the ``LDL'`` factorization of `A`, reusing the symbolic factorization `F`.\n`A` must be a `SparseMatrixCSC`, `Symmetric{SparseMatrixCSC}`, or\n`Hermitian{SparseMatrixCSC}`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{Complex128}`\n    as appropriate.\n\"\"\"\nldltfact!{T<:Real}(F::Factor, A::Union{SparseMatrixCSC{T},\n    SparseMatrixCSC{Complex{T}},\n    Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n    Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n    Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n    shift = 0.0) =\n    ldltfact!(F, Sparse(A), shift = shift)\n\nfunction ldltfact(A::Sparse; shift::Real=0.0,\n    perm::AbstractVector{SuiteSparse_long}=SuiteSparse_long[])\n\n    cm = defaults(common())\n    set_print_level(cm, 0)\n\n    # Makes it an LDLt\n    unsafe_store!(common_final_ll, 0)\n    # Really make sure it's an LDLt by avoiding supernodal factorisation\n    unsafe_store!(common_supernodal, 0)\n\n    # Compute the symbolic factorization\n    F = fact_(A, cm; perm = perm)\n\n    # Compute the numerical factorization\n    ldltfact!(F, A; shift = shift)\n\n    s = unsafe_load(get(F.p))\n    s.minor < size(A, 1) && throw(Base.LinAlg.ArgumentError(\"matrix has one or more zero pivots\"))\n    return F\nend\n\n\"\"\"\n    ldltfact(A; shift = 0.0, perm=Int[]) -> CHOLMOD.Factor\n\nCompute the ``LDL'`` factorization of a sparse matrix `A`.\n`A` must be a `SparseMatrixCSC`, `Symmetric{SparseMatrixCSC}`, or\n`Hermitian{SparseMatrixCSC}`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\nA fill-reducing permutation is used. `F = ldltfact(A)` is most frequently\nused to solve systems of equations `A*x = b` with `F\\\\b`. The returned\nfactorization object `F` also supports the methods `diag`,\n`det`, and `logdet`. You can extract individual factors from `F` using `F[:L]`.\nHowever, since pivoting is on by default, the factorization is internally\nrepresented as `A == P'*L*D*L'*P` with a permutation matrix `P`;\nusing just `L` without accounting for `P` will give incorrect answers.\nTo include the effects of permutation, it is typically preferable to extact\n\"combined\" factors like `PtL = F[:PtL]` (the equivalent of\n`P'*L`) and `LtP = F[:UP]` (the equivalent of `L'*P`).\nThe complete list of supported factors is `:L, :PtL, :D, :UP, :U, :LD, :DU, :PtLD, :DUP`.\n\nSetting optional `shift` keyword argument computes the factorization of\n`A+shift*I` instead of `A`. If the `perm` argument is nonempty,\nit should be a permutation of `1:size(A,1)` giving the ordering to use\n(instead of CHOLMOD's default AMD ordering).\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{Complex128}`\n    as appropriate.\n\n    Many other functions from CHOLMOD are wrapped but not exported from the\n    `Base.SparseArrays.CHOLMOD` module.\n\"\"\"\nldltfact{T<:Real}(A::Union{SparseMatrixCSC{T},SparseMatrixCSC{Complex{T}},\n    Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n    Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n    Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n    kws...) = ldltfact(Sparse(A); kws...)\n\n## Solvers\n\nfor (T, f) in ((:Dense, :solve), (:Sparse, :spsolve))\n    @eval begin\n        # Solve Lx = b and L'x=b where A = L*L'\n        function (\\){T}(L::FactorComponent{T,:L}, B::$T)\n            ($f)(CHOLMOD_L, Factor(L), B)\n        end\n        function (\\){T}(L::FactorComponent{T,:U}, B::$T)\n            ($f)(CHOLMOD_Lt, Factor(L), B)\n        end\n        # Solve PLx = b and L'P'x=b where A = P*L*L'*P'\n        function (\\){T}(L::FactorComponent{T,:PtL}, B::$T)\n            F = Factor(L)\n            ($f)(CHOLMOD_L, F, ($f)(CHOLMOD_P, F, B))  # Confusingly, CHOLMOD_P solves P'x = b\n        end\n        function (\\){T}(L::FactorComponent{T,:UP}, B::$T)\n            F = Factor(L)\n            ($f)(CHOLMOD_Pt, F, ($f)(CHOLMOD_Lt, F, B))\n        end\n        # Solve various equations for A = L*D*L' and A = P*L*D*L'*P'\n        function (\\){T}(L::FactorComponent{T,:D}, B::$T)\n            ($f)(CHOLMOD_D, Factor(L), B)\n        end\n        function (\\){T}(L::FactorComponent{T,:LD}, B::$T)\n            ($f)(CHOLMOD_LD, Factor(L), B)\n        end\n        function (\\){T}(L::FactorComponent{T,:DU}, B::$T)\n            ($f)(CHOLMOD_DLt, Factor(L), B)\n        end\n        function (\\){T}(L::FactorComponent{T,:PtLD}, B::$T)\n            F = Factor(L)\n            ($f)(CHOLMOD_LD, F, ($f)(CHOLMOD_P, F, B))\n        end\n        function (\\){T}(L::FactorComponent{T,:DUP}, B::$T)\n            F = Factor(L)\n            ($f)(CHOLMOD_Pt, F, ($f)(CHOLMOD_DLt, F, B))\n        end\n    end\nend\n\ntypealias SparseVecOrMat{Tv,Ti} Union{SparseVector{Tv,Ti}, SparseMatrixCSC{Tv,Ti}}\n\nfunction (\\)(L::FactorComponent, b::Vector)\n    reshape(convert(Matrix, L\\Dense(b)), length(b))\nend\nfunction (\\)(L::FactorComponent, B::Matrix)\n    convert(Matrix, L\\Dense(B))\nend\nfunction (\\)(L::FactorComponent, B::SparseVecOrMat)\n    sparse(L\\Sparse(B,0))\nend\n\nAc_ldiv_B(L::FactorComponent, B) = ctranspose(L)\\B\n\n(\\){T<:VTypes}(L::Factor{T}, B::Dense{T}) = solve(CHOLMOD_A, L, B)\n(\\)(L::Factor{Float64}, B::VecOrMat{Complex{Float64}}) = complex(L\\real(B), L\\imag(B))\n# First explicit TypeVars are necessary to avoid ambiguity errors with definition in\n# linalg/factorizations.jl\n(\\){T<:VTypes}(L::Factor{T}, b::StridedVector) = Vector(L\\convert(Dense{T}, b))\n(\\){T<:VTypes}(L::Factor{T}, B::StridedMatrix) = Matrix(L\\convert(Dense{T}, B))\n(\\)(L::Factor, B::Sparse) = spsolve(CHOLMOD_A, L, B)\n# When right hand side is sparse, we have to ensure that the rhs is not marked as symmetric.\n(\\)(L::Factor, B::SparseVecOrMat) = sparse(spsolve(CHOLMOD_A, L, Sparse(B, 0)))\n\nAc_ldiv_B(L::Factor, B::Dense) = solve(CHOLMOD_A, L, B)\nAc_ldiv_B(L::Factor, B::VecOrMat) = convert(Matrix, solve(CHOLMOD_A, L, Dense(B)))\nAc_ldiv_B(L::Factor, B::Sparse) = spsolve(CHOLMOD_A, L, B)\nAc_ldiv_B(L::Factor, B::SparseVecOrMat) = Ac_ldiv_B(L, Sparse(B))\n\nfor f in (:\\, :Ac_ldiv_B)\n    @eval function ($f)(A::Union{Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}},\n                          Hermitian{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}},\n                          Hermitian{Complex{Float64},SparseMatrixCSC{Complex{Float64},SuiteSparse_long}}}, B::StridedVecOrMat)\n        try\n            return ($f)(cholfact(A), B)\n        catch e\n            isa(e, LinAlg.PosDefException) || rethrow(e)\n            return ($f)(ldltfact(A) , B)\n        end\n    end\nend\n\n## Other convenience methods\nfunction diag{Tv}(F::Factor{Tv})\n    f = unsafe_load(get(F.p))\n    fsuper = f.super\n    fpi = f.pi\n    res = Base.zeros(Tv, Int(f.n))\n    xv  = f.x\n    if f.is_super!=0\n        px = f.px\n        pos = 1\n        for i in 1:f.nsuper\n            base = unsafe_load(px, i) + 1\n            res[pos] = unsafe_load(xv, base)\n            pos += 1\n            for j in 1:unsafe_load(fsuper, i + 1) - unsafe_load(fsuper, i) - 1\n                res[pos] = unsafe_load(xv, base + j*(unsafe_load(fpi, i + 1) - unsafe_load(fpi, i) + 1))\n                pos += 1\n            end\n        end\n    else\n        c0 = f.p\n        r0 = f.i\n        xv = f.x\n        for j in 1:f.n\n            jj = unsafe_load(c0, j) + 1\n            assert(unsafe_load(r0, jj) == j - 1)\n            res[j] = unsafe_load(xv, jj)\n        end\n    end\n    res\nend\n\nfunction logdet{Tv<:VTypes}(F::Factor{Tv})\n    f = unsafe_load(get(F.p))\n    res = zero(Tv)\n    for d in diag(F); res += log(abs(d)) end\n    f.is_ll!=0 ? 2res : res\nend\n\ndet(L::Factor) = exp(logdet(L))\n\nfunction isposdef{Tv<:VTypes}(A::SparseMatrixCSC{Tv,SuiteSparse_long})\n    if !ishermitian(A)\n        return false\n    end\n    try\n        f = cholfact(A)\n    catch e\n        isa(e, LinAlg.PosDefException) || rethrow(e)\n        return false\n    end\n    true\nend\n\nfunction issymmetric(A::Sparse)\n    s = unsafe_load(A.p)\n    if s.stype != 0\n        return isreal(A)\n    end\n    i = symmetry(A, 1)[1]\n    return i == MM_SYMMETRIC || i == MM_SYMMETRIC_POSDIAG\nend\n\nfunction ishermitian(A::Sparse{Float64})\n    s = unsafe_load(A.p)\n    if s.stype != 0\n        return true\n    else\n        i = symmetry(A, 1)[1]\n        return i == MM_SYMMETRIC || i == MM_SYMMETRIC_POSDIAG\n    end\nend\nfunction ishermitian(A::Sparse{Complex{Float64}})\n    s = unsafe_load(A.p)\n    if s.stype != 0\n        return true\n    else\n        i = symmetry(A, 1)[1]\n        return i == MM_HERMITIAN || i == MM_HERMITIAN_POSDIAG\n    end\nend\n\n(*){Ti}(A::Symmetric{Float64,SparseMatrixCSC{Float64,Ti}}, B::SparseVecOrMat{Float64,Ti}) = sparse(Sparse(A)*Sparse(B))\n(*){Ti}(A::Hermitian{Complex{Float64},SparseMatrixCSC{Complex{Float64},Ti}}, B::SparseVecOrMat{Complex{Float64},Ti}) = sparse(Sparse(A)*Sparse(B))\n(*){Ti}(A::Hermitian{Float64,SparseMatrixCSC{Float64,Ti}}, B::SparseVecOrMat{Float64,Ti}) = sparse(Sparse(A)*Sparse(B))\n\nend #module\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/base/docs/basedocs.jl": "# This file is a part of Julia. License is MIT: http://julialang.org/license\n\nmodule BaseDocs\n\nimmutable Keyword\n    name :: Symbol\nend\nmacro kw_str(text) Keyword(Symbol(text)) end\n\n\"Hello, Human.\"\nkw\"hello\", kw\"hi\"\n\n\"\"\"\n**Welcome to Julia $(string(VERSION)).** The full manual is available at\n\n    http://docs.julialang.org/\n\nas well many great tutorials and learning resources:\n\n    http://julialang.org/learning/\n\nFor help on a specific function or macro, type `?` followed\nby its name, e.g. `?fft`, or `?@time`, and press enter.\n\"\"\"\nkw\"help\", kw\"?\", kw\"julia\"\n\n\"\"\"\n`using` will load the given module or package and make some of its names available for\nuse (see also `export`). For example:\n\n    using Gadfly\n\nloads the plotting package, Gadfly, so that the `plot` function can be used.\n\nNames can be used via dot syntax, whether they are exported or not:\n\n    Gadfly.plot(...)\n\nIf you don't want to use the packages exports directly, see also `import`. If you're not\nsure, `using` is almost definitely what you want.\n\"\"\"\nkw\"using\"\n\n\"\"\"\n    import Gadfly\n\n`import`, like `using`, will load modules and packages for use. Unlike `using`, however,\nit will *not* make any `export`ed names available for use. To use Gadfly's `plot`\nfunction after importing it, for example, you have to write:\n\n    Gadfly.plot(...)\n\nImport can also be used with specific names, for example\n\n    import Gadfly: plot, render\n\nThis syntax is used when you want to extend the modules functions with new methods.\n\"\"\"\nkw\"import\"\n\n\"\"\"\n`export` is used within modules and packages to tell Julia which functions should be\nmade available to the user. For example:\n\n    module Test\n    export foo # foo is exported, but bar isn't\n    foo(x) = x\n    bar(y) = y\n    end\n\n    using Test\n    foo(1) # 1\n    bar(1) # Error: bar not defined\n    Test.bar(1) # 1\n\"\"\"\nkw\"export\"\n\n\"\"\"\n`abstract` declares a type that cannot be instantiated, and serves only as a node in the\ntype graph, thereby describing sets of related concrete types: those concrete types\nwhich are their descendants. Abstract types form the conceptual hierarchy which makes\nJulia\u2019s type system more than just a collection of object implementations. For example:\n\n    abstract Number\n    abstract Real <: Number\n\n`abstract Number` has no supertype, whereas `abstract Real` is an abstract subtype of `Number`.\n\"\"\"\nkw\"abstract\"\n\n\"\"\"\n`module` declares a Module, which is a separate global variable workspace.  Within a\nmodule, you can control which names from other modules are visible (via importing), and\nspecify which of your names are intended to be public (via exporting). For example:\n\n    module\n    import Base.show\n    export MyType, foo\n\n    type MyType\n        x\n    end\n\n    bar(x) = 2x\n    foo(a::MyType) = bar(a.x) + 1\n    show(io, a::MyType) = print(io, \"MyType \\$(a.x)\")\n    end\n\nModules allow you to create top-level definitions without worrying about name conflicts\nwhen your code is used together with somebody else\u2019s.\n\"\"\"\nkw\"module\"\n\n\"\"\"\n`baremodule` declares a module that does not contain `using Base`\nor a definition of `eval`.  It does still import `Core`.\n\"\"\"\nkw\"baremodule\"\n\n\"\"\"\n`bitstype` declares a concrete type whose data consists of plain old bits. Classic\nexamples of bits types are integers and floating-point values. Some example built-in\nbits type declarations:\n\n    bitstype 32 Char\n    bitstype 8  Bool <: Integer\n\nThe first parameter indicates how many bits of storage the type requires. Currently,\nonly sizes that are multiples of 8 bits are supported. The second parameter gives the\nname of the type.  The `Bool` declaration shows how a bits type can be optionally\ndeclared to be a subtype of some supertype.\n\"\"\"\nkw\"bitstype\"\n\n\"\"\"\n`macro` defines a method to include generated code in the final body of a program. A\nmacro maps a tuple of arguments to a returned expression, and the resulting expression\nis compiled directly rather than requiring a runtime `eval()` call. Macro arguments may\ninclude expressions, literal values, and symbols. For example:\n\n    macro sayhello(name)\n        return :( println(\"Hello, \", \\$name) )\n    end\n\nThis macro takes one argument: `name`. When `@sayhello` is encountered, the quoted\nexpression is expanded to interpolate the value of the argument into the final\nexpression.\n\"\"\"\nkw\"macro\"\n\n\"\"\"\n`importall` imports all names exported by the specified module, as if `import` were used\nindividually on all of them.  For example:\n\n    importall Distributions\n\nAs with `import`, functions imported by `importall` can be extended.\n\"\"\"\nkw\"importall\"\n\n\"\"\"\n`local` introduces a new local variable. For example:\n\n    function foo(n)\n        x = 0\n        for i = 1:n\n            local x\n            x = i\n        end\n        x\n    end\n\n    julia> foo(10)\n    0\n\nHere `local x` introduces a separate `x` inside the loop, so the function returns `0`.\n\"\"\"\nkw\"local\"\n\n\"\"\"\n`global x` makes `x` in the current scope and its inner scopes refer to the global\nvariable of that name.   In the example below, `global` is needed so the function can\nmodify the global variable `z`:\n\n    z=3\n    function foo()\n        global z=6\n    end\n\n    julia> foo()\n    6\n    julia> z\n    6\n\nWithout the `global` declaration in `foo()`, a new local variable would have been\ncreated inside foo(), and the `z` in the global scope would have remained equal to `3`.\n\"\"\"\nkw\"global\"\n\n\"\"\"\n`let` statements allocate new variable bindings each time they run. Whereas an\nassignment modifies an existing value location, `let` creates new locations. This\ndifference is only detectable in the case of variables that outlive their scope via\nclosures. The `let` syntax accepts a comma-separated series of assignments and variable\nnames:\n\n    let var1 = value1, var2, var3 = value3\n        code\n    end\n\nThe assignments are evaluated in order, with each right-hand side evaluated in the scope\nbefore the new variable on the left-hand side has been introduced. Therefore it makes\nsense to write something like `let x = x`, since the two `x` variables are distinct and\nhave separate storage.\n\"\"\"\nkw\"let\"\n\n\"\"\"\n`quote` creates multiple expression objects in a block without using the explicit `Expr`\nconstructor. For example:\n\n    ex = quote\n        x = 1\n        y = 2\n        x + y\n    end\n\nUnlike the other means of quoting, `:( ... )`, this form introduces `QuoteNode` elements\nto the expression tree, which must be considered when directly manipulating the tree.\nFor other purposes, `:( ... )` and `quote .. end` blocks are treated identically.\n\"\"\"\nkw\"quote\"\n\n\"\"\"\n`'` is the conjugate transposition operator:\n\n    julia> A = reshape(1:4, 2,2)\n    2\u00d72 Array{Int64,2}:\n     1  3\n     2  4\n\n    julia> A'\n    2\u00d72 Array{Int64,2}:\n     1  2\n     3  4\n\n    julia> B = A + im\n    2\u00d72 Array{Complex{Int64},2}:\n     1+1im  3+1im\n     2+1im  4+1im\n\n    julia> B'\n    2\u00d72 Array{Complex{Int64},2}:\n     1-1im  2-1im\n     3-1im  4-1im\n\n\"\"\"\nkw\"'\"\n\n\n\"\"\"\n`.'` is the transposition operator:\n\n    julia> A = reshape(1:4, 2,2)\n    2\u00d72 Array{Int64,2}:\n     1  3\n     2  4\n\n    julia> A.'\n    2\u00d72 Array{Int64,2}:\n     1  2\n     3  4\n\n    julia> B = A + im\n    2\u00d72 Array{Complex{Int64},2}:\n     1+1im  3+1im\n     2+1im  4+1im\n\n    julia> B.'\n    2\u00d72 Array{Complex{Int64},2}:\n     1+1im  2+1im\n     3+1im  4+1im\n\n\"\"\"\nkw\".'\"\n\n\"\"\"\n`const` is used to declare global variables which are also constant. In almost all code\n(and particularly performance sensitive code) global variables should be declared\nconstant in this way.\n\n    const x = 5\n\nNote that \"constant-ness\" is not enforced inside containers, so if `x` is an array or\ndictionary (for example) you can still add and remove elements.\n\nTechnically, you can even redefine `const` variables, although this will generate a\nwarning from the compiler. The only strict requirement is that the *type* of the\nvariable does not change, which is why `const` variables are much faster than regular\nglobals.\n\"\"\"\nkw\"const\"\n\n\"\"\"\nFunctions are defined with the `function` keyword:\n\n    function add(a, b)\n        return a + b\n    end\n\nOr the short form notation:\n\n    add(a, b) = a + b\n\nThe use of the `return` keyword is exactly the same as in other languages, but is often\noptional. When it's not used, the last expression in the function body will be returned\nby default:\n\n    function compare(a, b)\n        a == b && return \"equal to\"\n        a < b ? \"less than\" : \"greater than\"\n    end\n\"\"\"\nkw\"function\"\n\n\"\"\"\n`return` can be used function bodies to exit early and return a given value, e.g.\n\n    function compare(a, b)\n        a == b && return \"equal to\"\n        a < b ? \"less than\" : \"greater than\"\n    end\n\nIn general you can place a `return` statement anywhere within a function body, including\nwithin deeply nested loops or conditionals, but be careful with `do` blocks. For\nexample:\n\n    function test1(xs)\n        for x in xs\n            iseven(x) && return 2x\n        end\n    end\n\n    function test2(xs)\n        map(xs) do x\n            iseven(x) && return 2x\n            x\n        end\n    end\n\nIn the first example, the return breaks out of its enclosing function as soon as it hits\nan even number, so `test1([5,6,7])` returns `12`.\n\nYou might expect the second example to behave the same way, but in fact the `return`\nthere only breaks out of the *inner* function (inside the `do` block) and gives a value\nback to `map`. `test2([5,6,7])` then returns `[5,12,7]`.\n\"\"\"\nkw\"return\"\n\n\"\"\"\n`if`-`elseif`-`else` performs conditional evaluation, which allows portions of code to\nbe evaluated or not evaluated depending on the value of a boolean expression. Here is\nthe anatomy of the `if`-`elseif`-`else` conditional syntax:\n\n    if x < y\n        println(\"x is less than y\")\n    elseif x > y\n        println(\"x is greater than y\")\n    else\n        println(\"x is equal to y\")\n    end\n\nIf the condition expression `x < y` is true, then the corresponding block is evaluated;\notherwise the condition expression `x > y` is evaluated, and if it is true, the\ncorresponding block is evaluated; if neither expression is true, the `else` block is\nevaluated. The `elseif` and `else` blocks are optional, and as many `elseif` blocks as\ndesired can be used.\n\"\"\"\nkw\"if\", kw\"elseif\", kw\"else\"\n\n\"\"\"\n`for` loops repeatedly evaluate the body of the loop by iterating over a sequence of\nvalues. For example:\n\n    for i in [1,4,0]\n        println(i)\n    end\n\"\"\"\nkw\"for\"\n\n\"\"\"\n`while` loops repeatedly evaluate a conditional expression, and continues evaluating the\nbody of the while loop so long as the expression remains `true`. If the condition\nexpression is false when the while loop is first reached, the body is never evaluated.\nFor example:\n\n    while i <= 5\n        println(i)\n        i += 1\n    end\n\"\"\"\nkw\"while\"\n\n\"\"\"\n`end` marks the conclusion of a block of expressions. In the example below, `end` marks\nthe conclusion of a `function`.\n\n    function foo()\n        println(\"hello, world\")\n    end\n\n`end` marks the conclusion of all kinds of expression blocks: `module`, `type`, `begin`,\n`let`, `for`, etc.\n\nIn addition, `end` may be used when indexing into an array to represent the last index\nof each dimension:\n\n    x[1:end, 2:end-1]\n\"\"\"\nkw\"end\"\n\n\"\"\"\nA `try/catch` statement allows for `Exception`s to be tested for. For example, a\ncustomized square root function can be written to automatically call either the real or\ncomplex square root method on demand using `Exception`s:\n\n    f(x) = try\n        sqrt(x)\n    catch\n        sqrt(complex(x, 0))\n    end\n\n`try/catch` statements also allow the `Exception` to be saved in a variable, e.g. `catch y`.\n\nThe `catch` clause is not strictly necessary; when omitted, the default return value is\n`nothing`. The power of the `try/catch` construct lies in the ability to unwind a deeply\nnested computation immediately to a much higher level in the stack of calling functions.\n\"\"\"\nkw\"try\", kw\"catch\"\n\n\"\"\"\n`finally` provides a way to run some code when a given block of code exits, regardless\nof how it exits. For example, here is how we can guarantee that an opened file is\nclosed:\n\n    f = open(\"file\")\n    try\n        operate_on_file(f)\n    finally\n        close(f)\n    end\n\nWhen control leaves the `try` block (for example due to a `return`, or just finishing\nnormally), `close(f)` will be executed. If the `try` block exits due to an exception,\nthe exception will continue propagating. A `catch` block may be combined with `try` and\n`finally` as well. In this case the `finally` block will run after `catch` has handled\nthe error.\n\"\"\"\nkw\"finally\"\n\n\"\"\"\n`break` breaks out of a loop immediately. For example\n\n    i = 0\n    while true\n        i += 1\n        i > 10 && break\n        println(i)\n    end\n\nprints the numbers 1 to 10.\n\"\"\"\nkw\"break\"\n\n\"\"\"\n`continue` skips the rest of the current loop, then carries on looping. For example\n\n    for i = 1:10\n        iseven(i) && continue\n        println(i)\n    end\n\nprints the numbers 1, 3, 5..., skipping the even numbers.\n\"\"\"\nkw\"continue\"\n\n\"\"\"\nThe `do` keyword creates an anonymous function. For example\n\n    map(1:10) do x\n        2x\n    end\n\nis equivalent to `map(x->2x, 1:10)`.\n\nUse multiple arguments like so:\n\n    map(1:10, 11:20) do x, y\n        x + y\n    end\n\"\"\"\nkw\"do\"\n\n\"\"\"\nThe \"splat\" operator, `...`, represents a sequence of arguments. For example\n\n    add(xs...) = reduce(+, xs)\n\ncan take any number of arguments:\n\n    add(1, 2, 3, 4, 5)\n\n`...` can also be used to apply a function to a sequence of arguments like so:\n\n    add([1, 2, 3]...) # 6\n    add(7, 1:100..., 1000:1100...) # 111107\n\"\"\"\nkw\"...\"\n\n\"\"\"\n`;` has a similar role in Julia as in many C-like languages, and is used to delimit the\nend of the previous statement. `;` is not necessary after new lines, but can be used to\nseparate statements on a single line or to join statements into a single expression:\n\n    function foo()\n        println(\"Hello, \"); println(\"World!\")\n        return true\n    end\n\n    foo() = (println(\"Hello, World!\"); true)\n\n`;` is also used to suppress output in the REPL and similar interfaces.\n\"\"\"\nkw\";\"\n\n\"\"\"\n    x && y\n\nShort-circuiting boolean AND.\n\"\"\"\nkw\"&&\"\n\n\"\"\"\n    x || y\n\nShort-circuiting boolean OR.\n\"\"\"\nkw\"||\"\n\n\"\"\"\n    ccall((symbol, library) or function_pointer, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n\nCall function in C-exported shared library, specified by `(function name, library)`\ntuple, where each component is a string or symbol.\n\nNote that the argument type tuple must be a literal tuple, and not a tuple-valued\nvariable or expression. Alternatively, `ccall` may also be used to call a function\npointer, such as one returned by `dlsym`.\n\nEach `ArgumentValue` to the `ccall` will be converted to the corresponding\n`ArgumentType`, by automatic insertion of calls to `unsafe_convert(ArgumentType,\ncconvert(ArgumentType, ArgumentValue))`. (See also the documentation for each of these\nfunctions for further details.) In most cases, this simply results in a call to\n`convert(ArgumentType, ArgumentValue)`.\n\"\"\"\nkw\"ccall\"\n\n\"\"\"\n    llvmcall(IR::String, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n    llvmcall((declarations::String, IR::String), ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n\nCall LLVM IR string in the first argument. Similar to an LLVM function `define` block,\narguments are available as consecutive unnamed SSA variables (%0, %1, etc.).\n\nThe optional declarations string contains external functions declarations that are\nnecessary for llvm to compile the IR string. Multiple declarations can be passed in by\nseparating them with line breaks.\n\nNote that the argument type tuple must be a literal tuple, and not a tuple-valued\nvariable or expression.\n\nEach `ArgumentValue` to `llvmcall` will be converted to the corresponding\n`ArgumentType`, by automatic insertion of calls to `unsafe_convert(ArgumentType,\ncconvert(ArgumentType, ArgumentValue))`. (see also the documentation for each of these\nfunctions for further details). In most cases, this simply results in a call to\n`convert(ArgumentType, ArgumentValue)`.\n\nSee `test/llvmcall.jl` for usage examples.\n\"\"\"\nCore.Intrinsics.llvmcall\n\n\"\"\"\n`begin...end` denotes a block of code.\n\n    begin\n        println(\"Hello, \")\n        println(\"World!\")\n    end\n\nUsually `begin` will not be necessary, since keywords such as `function` and `let`\nimplicitly begin blocks of code. See also `;`.\n\"\"\"\nkw\"begin\"\n\n\"\"\"\nAt their most basic, Julia types are specified as a name and a set of fields.\n\n    type Point\n        x\n        y\n    end\n\nFields can have type restrictions, which may be parametrised:\n\n    type Point{X}\n        x::X\n        y::Float64\n    end\n\nType can also declare an abstract super type via `<:` syntax:\n\n    type Point <: AbstractPoint\n        ...\n\nSee the manual for more details, such as information on inner constructors.\n\"\"\"\nkw\"type\"\n\n\"\"\"\nIntroduce a new name for an already expressible type. For example, in `base/boot.jl`,\n`UInt` is type aliased to either `UInt64` or `UInt32` as appropriate for the size of\npointers on the system:\n\n    if is(Int,Int64)\n        typealias UInt UInt64\n    else\n        typealias UInt UInt32\n    end\n\nFor parametric types, `typealias` can be convenient for providing names in cases where\nsome parameter choices are fixed.  In `base` for example:\n\n    typealias Vector{T} Array{T,1}\n\"\"\"\nkw\"typealias\"\n\n\"\"\"\n`immutable` acts in the same way as `type`, but declares that the fields of the type may\nnot be set after construction. See `type` and the manual for more information.\n\"\"\"\nkw\"immutable\"\n\n\"\"\"\n    @__LINE__ -> Int\n\n`@__LINE__` expands to the line number of the call-site.\n\"\"\"\nkw\"@__LINE__\"\n\n\"\"\"\n    ans\n\nA variable referring to the last computed value, automatically set at the interactive prompt.\n\"\"\"\nkw\"ans\"\n\n\"\"\"\n    nothing\n\nThe singleton instance of type `Void`, used by convention when there is no value to return\n(as in a C `void` function). Can be converted to an empty `Nullable` value.\n\"\"\"\nnothing\n\n\"\"\"\n    ANY\n\nEquivalent to `Any` for dispatch purposes, but signals the compiler to skip code\ngeneration specialization for that field.\n\"\"\"\nANY\n\n\"\"\"\n    DevNull\n\nUsed in a stream redirect to discard all data written to it. Essentially equivalent to\n/dev/null on Unix or NUL on Windows. Usage:\n\n```julia\nrun(pipeline(`cat test.txt`, DevNull))\n```\n\"\"\"\nDevNull\n\nend\n"
    },
    "skipped": [
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/objects.inv",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/up.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/up-pressed.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/plus.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/minus.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/file.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/down.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/down-pressed.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/comment.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/comment-close.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/comment-bright.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/ajax-loader.gif",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/fonts/FontAwesome.otf",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/fonts/fontawesome-webfont.woff",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/fonts/fontawesome-webfont.ttf",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/_build/html/_static/fonts/fontawesome-webfont.eot",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/images/travis-icon.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/images/jltypes.ai",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/images/github_metadata_pullrequest.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/images/github_metadata_fork.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/doc/images/github_metadata_develbranch.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/virtualenv-15.0.0.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/utf8proc-e3a5ed7b8bb5d0c6bb313d3e1f4d072c04113c4b.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/SuiteSparse-4.4.5.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/pcre2-10.21.tar.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/patchelf-0.9.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/openspecfun-39699a1c1824bf88410cabb8a7438af91ea98f4c.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/openlibm-1581174c85f7b645b15ba1ac1c3a98fb601f0fe7.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/openblas-12ab1804b6ebcd38b26960d65d254314d8bc33d6.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/objconv.zip",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/mpfr-3.1.4.tar.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/mbedtls-2.3.0-gpl.tgz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/llvm-3.7.1.src.tar.xz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/libuv-8d5131b6c1595920dd30644cd1435b4f344b46c8.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/libunwind-1.1-julia2.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/libssh2-6d553a7bb94966466c4db0abf9a26660e786a275.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/libosxunwind-0.0.3.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/libgit2-428e18f8d4765b8ad6cf4022080a81ab16f6fdc4.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/lapack-3.5.0.tgz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/gmp-6.1.0.tar.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/fftw-3.3.4.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/dsfmt-2.2.3.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/curl-7.50.1.tar.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/deps/srccache/arpack-ng-3.3.0.tar.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/contrib/windows/julia.ico",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/contrib/windows/7zS.sfx",
        "/var/tmp/sochat1/spack-stage/spack-stage-julia-0.5.1-w3mz62lzcw7jess6ueapvzxsc2qucbtn/spack-src/contrib/mac/app/julia.icns"
    ],
    "total_files": 1186
}