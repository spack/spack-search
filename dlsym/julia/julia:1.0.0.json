{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/src/staticdata.c": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n/*\n  saving and restoring system images\n*/\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h> // printf\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"builtin_proto.h\"\n#include \"processor.h\"\n\n#ifndef _OS_WINDOWS_\n#include <dlfcn.h>\n#endif\n\n#ifndef _COMPILER_MICROSOFT_\n#include \"valgrind.h\"\n#else\n#define RUNNING_ON_VALGRIND 0\n#endif\n#include \"julia_assert.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// TODO: put WeakRefs on the weak_refs list during deserialization\n// TODO: handle finalizers\n\n// hash of definitions for predefined tagged object\nstatic htable_t sertag_table;\nstatic htable_t symbol_table;\nstatic uintptr_t nsym_tag;\n// array of definitions for the predefined tagged object types\n// (reverse of sertag_table and symbol_table)\nstatic arraylist_t deser_tag;\nstatic arraylist_t deser_sym;\n\n// table of all objects that are serialized\nstatic htable_t backref_table;\nstatic int backref_table_numel;\nstatic arraylist_t layout_table;\n\n// list of (size_t pos, (void *f)(jl_value_t*)) entries\n// for the serializer to mark values in need of rework by function f\n// during deserialization later\nstatic arraylist_t reinit_list;\n\n// list of modules being deserialized with __init__ methods\n// (not used in MODE_AST)\njl_array_t *jl_module_init_order;\n\n// hash of definitions for predefined function pointers\nstatic htable_t fptr_to_id;\n// array of definitions for the predefined function pointers\n// (reverse of fptr_to_id)\nstatic const jl_fptr_args_t id_to_fptrs[] = {\n    jl_f_throw, jl_f_is, jl_f_typeof, jl_f_issubtype, jl_f_isa,\n    jl_f_typeassert, jl_f__apply, jl_f__apply_pure, jl_f__apply_latest, jl_f_isdefined,\n    jl_f_tuple, jl_f_svec, jl_f_intrinsic_call, jl_f_invoke_kwsorter,\n    jl_f_getfield, jl_f_setfield, jl_f_fieldtype, jl_f_nfields,\n    jl_f_arrayref, jl_f_arrayset, jl_f_arraysize, jl_f_apply_type,\n    jl_f_applicable, jl_f_invoke, jl_f_sizeof, jl_f__expr, jl_f_ifelse,\n    NULL };\n\ntypedef enum _DUMP_MODES {\n    // not in the serializer at all, or\n    // something is seriously wrong\n    MODE_INVALID = 0,\n\n    // jl_restore_system_image\n    // restoring an entire system image from disk\n    MODE_SYSTEM_IMAGE,\n} DUMP_MODES;\n\ntypedef struct {\n    ios_t *s;\n    ios_t *const_data;\n    ios_t *symbols;\n    ios_t *relocs;\n    ios_t *gvar_record;\n    ios_t *fptr_record;\n    arraylist_t relocs_list;\n    arraylist_t gctags_list;\n    DUMP_MODES mode;\n    jl_ptls_t ptls;\n} jl_serializer_state;\n\nstatic jl_value_t *jl_idtable_type = NULL;\nstatic jl_typename_t *jl_idtable_typename = NULL;\nstatic jl_value_t *jl_bigint_type = NULL;\nstatic int gmp_limb_size = 0;\nstatic arraylist_t builtin_typenames;\n\nenum RefTags {\n    DataRef,\n    ConstDataRef,\n    TagRef,\n    SymbolRef,\n    BindingRef,\n    FunctionRef,\n    BuiltinFunctionRef\n};\n\n// calling conventions for internal entry points.\n// this is used to set the method-instance->invoke field\ntypedef enum {\n    JL_API_TRAMPOLINE,\n    JL_API_BOXED,\n    JL_API_CONST,\n    JL_API_WITH_PARAMETERS,\n    JL_API_INTERPRETED,\n    JL_API_BUILTIN,\n    JL_API_MAX\n} jl_callingconv_t;\n\n\n// this supports up to 1 GB images and 16 RefTags\n// if a larger size is required, will need to add support for writing larger relocations in many cases below\n#define RELOC_TAG_OFFSET 28\n\n\n/* read and write in host byte order */\n\n#define write_uint8(s, n) ios_putc((n), (s))\n#define read_uint8(s) ((uint8_t)ios_getc((s)))\n\nstatic void write_uint32(ios_t *s, uint32_t i)\n{\n    ios_write(s, (char*)&i, 4);\n}\n\nstatic uint32_t read_uint32(ios_t *s)\n{\n    uint32_t x = 0;\n    ios_read(s, (char*)&x, 4);\n    return x;\n}\n\n\n// --- Static Compile ---\n\nextern int globalUnique;\nstatic void *jl_sysimg_handle = NULL;\nstatic uint64_t sysimage_base = 0;\nstatic uintptr_t *sysimg_gvars_base = NULL;\nstatic const int32_t *sysimg_gvars_offsets = NULL;\nstatic jl_sysimg_fptrs_t sysimg_fptrs;\n\nstatic inline uintptr_t *sysimg_gvars(uintptr_t *base, size_t idx)\n{\n    return base + sysimg_gvars_offsets[idx] / sizeof(base[0]);\n}\n\nJL_DLLEXPORT int jl_running_on_valgrind(void)\n{\n    return RUNNING_ON_VALGRIND;\n}\n\nstatic void jl_load_sysimg_so(void)\n{\n    int imaging_mode = jl_generating_output() && !jl_options.incremental;\n    // in --build mode only use sysimg data, not precompiled native code\n    if (!imaging_mode && jl_options.use_sysimage_native_code==JL_OPTIONS_USE_SYSIMAGE_NATIVE_CODE_YES) {\n        sysimg_gvars_base = (uintptr_t*)jl_dlsym(jl_sysimg_handle, \"jl_sysimg_gvars_base\");\n        sysimg_gvars_offsets = (const int32_t*)jl_dlsym(jl_sysimg_handle,\n                                                        \"jl_sysimg_gvars_offsets\");\n        sysimg_gvars_offsets += 1;\n        assert(sysimg_fptrs.base);\n        globalUnique = *(size_t*)jl_dlsym(jl_sysimg_handle, \"jl_globalUnique\");\n#ifdef JULIA_ENABLE_THREADING\n        uintptr_t *tls_getter_slot = (uintptr_t*)jl_dlsym(jl_sysimg_handle,\n                                                          \"jl_get_ptls_states_slot\");\n        *tls_getter_slot = (uintptr_t)jl_get_ptls_states_getter();\n        size_t *tls_offset_idx = (size_t*)jl_dlsym(jl_sysimg_handle, \"jl_tls_offset\");\n        *tls_offset_idx = (uintptr_t)(jl_tls_offset == -1 ? 0 : jl_tls_offset);\n#endif\n\n#ifdef _OS_WINDOWS_\n        sysimage_base = (intptr_t)jl_sysimg_handle;\n#else\n        Dl_info dlinfo;\n        if (dladdr((void*)sysimg_gvars_base, &dlinfo) != 0) {\n            sysimage_base = (intptr_t)dlinfo.dli_fbase;\n        }\n        else {\n            sysimage_base = 0;\n        }\n#endif\n    }\n    else {\n        memset(&sysimg_fptrs, 0, sizeof(sysimg_fptrs));\n    }\n    const char *sysimg_data = (const char*)jl_dlsym(jl_sysimg_handle, \"jl_system_image_data\");\n    size_t len = *(size_t*)jl_dlsym(jl_sysimg_handle, \"jl_system_image_size\");\n    jl_restore_system_image_data(sysimg_data, len);\n}\n\n\n// --- serializer ---\n\nstatic uintptr_t jl_fptr_id(void *fptr)\n{\n    void **pbp = ptrhash_bp(&fptr_to_id, fptr);\n    if (*pbp == HT_NOTFOUND || fptr == NULL)\n        return 0;\n    else\n        return *(uintptr_t*)pbp;\n}\n\n#define jl_serialize_value(s, v) jl_serialize_value_(s,(jl_value_t*)(v))\nstatic void jl_serialize_value_(jl_serializer_state *s, jl_value_t *v);\n\n\nstatic void jl_serialize_module(jl_serializer_state *s, jl_module_t *m)\n{\n    jl_serialize_value(s, m->name);\n    jl_serialize_value(s, m->parent);\n    size_t i;\n    void **table = m->bindings.table;\n    for (i = 1; i < m->bindings.size; i += 2) {\n        if (table[i] != HT_NOTFOUND) {\n            jl_binding_t *b = (jl_binding_t*)table[i];\n            if (b->owner == m || m != jl_main_module) {\n                jl_serialize_value(s, b->name);\n                jl_serialize_value(s, b->value);\n                jl_serialize_value(s, b->globalref);\n                jl_serialize_value(s, b->owner);\n            }\n        }\n    }\n\n    if (m != jl_main_module) {\n        for (i = 0; i < m->usings.len; i++) {\n            jl_serialize_value(s, (jl_value_t*)m->usings.items[i]);\n        }\n    }\n}\n\n\nstatic void jl_serialize_value_(jl_serializer_state *s, jl_value_t *v)\n{\n    if (v == NULL || jl_is_symbol(v)) {\n        return;\n    }\n\n    void *builtin = ptrhash_get(&sertag_table, v);\n    if (builtin != HT_NOTFOUND) {\n        return;\n    }\n\n    void **bp = ptrhash_bp(&backref_table, v);\n    if (*bp != HT_NOTFOUND) {\n        return;\n    }\n\n    size_t item = ++backref_table_numel;\n    assert(item < ((uintptr_t)1 << RELOC_TAG_OFFSET) && \"too many items to serialize\");\n    char *pos = (char*)HT_NOTFOUND + item;\n    *bp = (void*)pos;\n\n    // some values have special representations\n    jl_datatype_t *t = (jl_datatype_t*)jl_typeof(v);\n    jl_serialize_value(s, t);\n\n    if (t->layout->npointers == 0) {\n        // skip it\n    }\n    else if (jl_is_svec(v)) {\n        size_t i, l = jl_svec_len(v);\n        jl_value_t **data = jl_svec_data(v);\n        for (i = 0; i < l; i++) {\n            jl_serialize_value(s, data[i]);\n        }\n    }\n    else if (jl_is_array(v)) {\n        jl_array_t *ar = (jl_array_t*)v;\n        jl_serialize_value(s, jl_typeof(ar));\n        if (ar->flags.ptrarray) {\n            size_t i, l = jl_array_len(ar);\n            for (i = 0; i < l; i++) {\n                jl_serialize_value(s, jl_array_ptr_ref(ar, i));\n            }\n        }\n    }\n    else if (jl_typeis(v, jl_module_type)) {\n        jl_serialize_module(s, (jl_module_t*)v);\n    }\n    else if (jl_typeis(v, jl_task_type)) {\n        jl_error(\"Task cannot be serialized\");\n    }\n    else {\n        char *data = (char*)jl_data_ptr(v);\n        size_t i, nf = jl_datatype_nfields(t);\n        for (i = 0; i < nf; i++) {\n            if (jl_field_isptr(t, i)) {\n                char *slot = data + jl_field_offset(t, i);\n                jl_value_t *fld = *(jl_value_t**)slot;\n                jl_serialize_value(s, fld);\n            }\n        }\n    }\n}\n\nstatic void ios_ensureroom(ios_t *s, size_t newsize)\n{\n    size_t prevsize = s->size;\n    if (prevsize < newsize) {\n        ios_trunc(s, newsize);\n        assert(s->size == newsize);\n        memset(&s->buf[prevsize], 0, newsize - prevsize);\n    }\n}\n\nstatic void record_gvar(jl_serializer_state *s, int gid, uintptr_t reloc_id)\n{\n    if (gid == 0)\n        return;\n    ios_ensureroom(s->gvar_record, gid * sizeof(uint32_t));\n    ios_seek(s->gvar_record, (gid - 1) * sizeof(uint32_t));\n    assert(reloc_id < UINT32_MAX);\n    write_uint32(s->gvar_record, reloc_id);\n}\n\n\nstatic void write_padding(ios_t *s, size_t nb)\n{\n    static const char zeros[16] = {0};\n    while (nb > 16) {\n        ios_write(s, zeros, 16);\n        nb -= 16;\n    }\n    if (nb != 0)\n        ios_write(s, zeros, nb);\n}\n\n\nstatic void write_pointer(ios_t *s)\n{\n    assert((ios_pos(s) & (sizeof(void*) - 1)) == 0 && \"stream misaligned for writing a word-sized value\");\n    write_padding(s, sizeof(void*));\n}\n\n\n#define backref_id(s, v) _backref_id(s, (jl_value_t*)(v))\nstatic uintptr_t _backref_id(jl_serializer_state *s, jl_value_t *v)\n{\n    assert(v != NULL && \"cannot get backref to NULL object\");\n    void *idx = HT_NOTFOUND;\n    if (jl_is_symbol(v)) {\n        void **pidx = ptrhash_bp(&symbol_table, v);\n        idx = *pidx;\n        if (idx == HT_NOTFOUND) {\n            size_t l = strlen(jl_symbol_name((jl_sym_t*)v));\n            write_uint32(s->symbols, l);\n            ios_write(s->symbols, jl_symbol_name((jl_sym_t*)v), l + 1);\n            size_t offset = ++nsym_tag;\n            assert(offset < ((uintptr_t)1 << RELOC_TAG_OFFSET) && \"too many symbols\");\n            idx = (void*)((char*)HT_NOTFOUND + ((uintptr_t)SymbolRef << RELOC_TAG_OFFSET) + offset);\n            *pidx = idx;\n        }\n    }\n    else {\n        idx = ptrhash_get(&sertag_table, v);\n    }\n    if (idx == HT_NOTFOUND) {\n        idx = ptrhash_get(&backref_table, v);\n        assert(idx != HT_NOTFOUND && \"object missed during jl_serialize_value pass\");\n    }\n    return (char*)idx - 1 - (char*)HT_NOTFOUND;\n}\n\n\nstatic void write_pointerfield(jl_serializer_state *s, jl_value_t *fld)\n{\n    if (fld != NULL) {\n        arraylist_push(&s->relocs_list, (void*)(uintptr_t)ios_pos(s->s));\n        arraylist_push(&s->relocs_list, (void*)backref_id(s, fld));\n    }\n    write_pointer(s->s);\n}\n\nstatic void write_gctaggedfield(jl_serializer_state *s, uintptr_t ref)\n{\n    arraylist_push(&s->gctags_list, (void*)(uintptr_t)ios_pos(s->s));\n    arraylist_push(&s->gctags_list, (void*)ref);\n    write_pointer(s->s);\n}\n\n\nstatic void jl_write_module(jl_serializer_state *s, uintptr_t item, jl_module_t *m)\n{\n    size_t reloc_offset = ios_pos(s->s);\n    size_t tot = sizeof(jl_module_t);\n    ios_write(s->s, (char*)m, tot);\n\n    jl_module_t *newm = (jl_module_t*)&s->s->buf[reloc_offset];\n    newm->name = NULL;\n    arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_module_t, name)));\n    arraylist_push(&s->relocs_list, (void*)backref_id(s, m->name));\n    newm->parent = NULL;\n    arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_module_t, parent)));\n    arraylist_push(&s->relocs_list, (void*)backref_id(s, m->parent));\n    newm->primary_world = jl_world_counter;\n\n    // write out the bindings table as a list\n    // immediately after jl_module_t\n    // (the ptrhash will need to be recreated on load)\n    size_t count = 0;\n    size_t i;\n    void **table = m->bindings.table;\n    for (i = 1; i < m->bindings.size; i += 2) {\n        if (table[i] != HT_NOTFOUND) {\n            jl_binding_t *b = (jl_binding_t*)table[i];\n            if (b->owner == m || m != jl_main_module) {\n                write_gctaggedfield(s, (uintptr_t)BindingRef << RELOC_TAG_OFFSET);\n                tot += sizeof(void*);\n                size_t binding_reloc_offset = ios_pos(s->s);\n                record_gvar(s, jl_get_llvm_gv((jl_value_t*)b), ((uintptr_t)DataRef << RELOC_TAG_OFFSET) + binding_reloc_offset);\n                write_pointerfield(s, (jl_value_t*)b->name);\n                write_pointerfield(s, b->value);\n                write_pointerfield(s, b->globalref);\n                write_pointerfield(s, (jl_value_t*)b->owner);\n                size_t flag_offset = offsetof(jl_binding_t, owner) + sizeof(b->owner);\n                ios_write(s->s, (char*)b + flag_offset, sizeof(*b) - flag_offset);\n                tot += sizeof(jl_binding_t);\n                count += 1;\n            }\n        }\n    }\n    assert(ios_pos(s->s) - reloc_offset == tot);\n    newm = (jl_module_t*)&s->s->buf[reloc_offset];\n    newm->bindings.size = count; // stash the count in newm->size\n    newm->bindings.table = NULL;\n    memset(&newm->bindings._space, 0, sizeof(newm->bindings._space));\n\n    // write out the usings list\n    memset(&newm->usings._space, 0, sizeof(newm->usings._space));\n    if (m == jl_main_module) {\n        newm->usings.len = 1;\n        newm->usings.max = AL_N_INLINE;\n        newm->usings.items = (void**)offsetof(jl_module_t, usings._space);\n        arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_module_t, usings.items)));\n        arraylist_push(&s->relocs_list, (void*)(((uintptr_t)DataRef << RELOC_TAG_OFFSET) + item));\n        arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_module_t, usings._space[0])));\n        arraylist_push(&s->relocs_list, (void*)backref_id(s, jl_core_module));\n    }\n    else {\n        if (newm->usings.items == &newm->usings._space[0]) {\n            m->usings.max = AL_N_INLINE;\n            newm->usings.items = (void**)offsetof(jl_module_t, usings._space);\n            arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_module_t, usings.items)));\n            arraylist_push(&s->relocs_list, (void*)(((uintptr_t)DataRef << RELOC_TAG_OFFSET) + item));\n            size_t i;\n            for (i = 0; i < m->usings.len; i++) {\n                arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_module_t, usings._space[i])));\n                arraylist_push(&s->relocs_list, (void*)backref_id(s, m->usings._space[i]));\n            }\n        }\n        else {\n            newm->usings.items = (void**)tot;\n            arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_module_t, usings.items)));\n            arraylist_push(&s->relocs_list, (void*)(((uintptr_t)DataRef << RELOC_TAG_OFFSET) + item));\n            size_t i;\n            for (i = 0; i < m->usings.len; i++) {\n                write_pointerfield(s, (jl_value_t*)m->usings.items[i]);\n                tot += sizeof(void*);\n            }\n            for (; i < m->usings.max; i++) {\n                write_pointer(s->s);\n                tot += sizeof(void*);\n            }\n            newm = (jl_module_t*)&s->s->buf[reloc_offset];\n        }\n    }\n}\n\n#if 0\nstatic size_t jl_sort_size(jl_datatype_t *dt)\n{\n    if (dt == jl_simplevector_type)\n        return SIZE_MAX - 5;\n    if (dt == jl_string_type)\n        return SIZE_MAX - 4;\n    if (dt->name == jl_array_typename)\n        return SIZE_MAX - 3;\n    if (dt == jl_datatype_type)\n        return SIZE_MAX - 2;\n    if (dt == jl_module_type)\n        return SIZE_MAX - 1;\n    return jl_datatype_size(dt);\n}\n#endif\n\nstatic int sysimg_sort_order(const void *pa, const void *pb)\n{\n    uintptr_t sa = ((uintptr_t*)pa)[1];\n    uintptr_t sb = ((uintptr_t*)pb)[1];\n    return (sa > sb ? 1 : (sa < sb ? -1 : 0));\n#if 0\n    jl_value_t *a = *(jl_value_t**)pa;\n    jl_datatype_t *tya = (jl_datatype_t*)jl_typeof(a);\n    size_t sa = jl_sort_size(tya);\n    jl_value_t *b = *(jl_value_t**)pb;\n    jl_datatype_t *tyb = (jl_datatype_t*)jl_typeof(b);\n    size_t sb = jl_sort_size(tyb);\n    if (sa == sb) {\n        sa = tya->uid;\n        sb = tyb->uid;\n    }\n    return (sa > sb ? 1 : (sa < sb ? -1 : 0));\n#endif\n}\n\njl_value_t *jl_find_ptr = NULL;\nstatic void jl_write_values(jl_serializer_state *s)\n{\n    arraylist_t objects_list;\n    arraylist_new(&objects_list, backref_table_numel * 2);\n\n    arraylist_new(&layout_table, 0);\n    arraylist_grow(&layout_table, backref_table_numel);\n    memset(layout_table.items, 0, backref_table_numel * sizeof(void*));\n\n    size_t i, len = backref_table.size;\n    void **p = backref_table.table;\n    for (i = 0; i < len; i += 2) {\n        char *reloc_id = (char*)p[i + 1];\n        if (reloc_id != HT_NOTFOUND) {\n            jl_value_t *v = (jl_value_t*)p[i];\n            uintptr_t item = reloc_id - 1 - (char*)HT_NOTFOUND;\n            objects_list.items[objects_list.len++] = (void*)v;\n            objects_list.items[objects_list.len++] = (void*)item;\n        }\n    }\n    assert(backref_table_numel * 2 == objects_list.len);\n    qsort(objects_list.items, backref_table_numel, sizeof(void*) * 2, sysimg_sort_order);\n\n    for (i = 0, len = backref_table_numel * 2; i < len; i += 2) {\n        jl_value_t *v = (jl_value_t*)objects_list.items[i];\n        uintptr_t item = (uintptr_t)objects_list.items[i + 1];\n        jl_datatype_t *t = (jl_datatype_t*)jl_typeof(v);\n        assert((t->instance == NULL || t->instance == v) && \"detected singleton construction corruption\");\n        // realign stream to expected gc alignment (16 bytes)\n        uintptr_t skip_header_pos = ios_pos(s->s) + sizeof(jl_taggedvalue_t);\n        write_padding(s->s, LLT_ALIGN(skip_header_pos, 16) - skip_header_pos);\n        // write header\n        write_gctaggedfield(s, backref_id(s, t));\n        size_t reloc_offset = ios_pos(s->s);\n        assert(item < layout_table.len && layout_table.items[item] == NULL);\n        layout_table.items[item] = (void*)reloc_offset;\n        record_gvar(s, jl_get_llvm_gv(v), ((uintptr_t)DataRef << RELOC_TAG_OFFSET) + reloc_offset);\n\n        // write data\n        if (jl_is_cpointer(v)) {\n            write_pointer(s->s);\n        }\n        else if (jl_is_array(v)) {\n#define JL_ARRAY_ALIGN(jl_value, nbytes) LLT_ALIGN(jl_value, nbytes)\n            jl_array_t *ar = (jl_array_t*)v;\n            int ndimwords = jl_array_ndimwords(ar->flags.ndims);\n            size_t tsz = JL_ARRAY_ALIGN(sizeof(jl_array_t) + ndimwords * sizeof(size_t), JL_CACHE_BYTE_ALIGNMENT);\n            // copy header\n            ios_write(s->s, (char*)v, tsz);\n            // make some header modifications in-place\n            jl_array_t *newa = (jl_array_t*)&s->s->buf[reloc_offset];\n            size_t alen = jl_array_len(ar);\n            size_t tot = alen * ar->elsize;\n            if (newa->flags.ndims == 1)\n                newa->maxsize = alen;\n            newa->offset = 0;\n            newa->flags.how = 0;\n            newa->flags.pooled = 0;\n            newa->flags.isshared = 0;\n\n            // write data\n            if (!ar->flags.ptrarray) {\n                uintptr_t data = LLT_ALIGN(ios_pos(s->const_data), 16);\n                // realign stream to max(data-align(array), sizeof(void*))\n                write_padding(s->const_data, data - ios_pos(s->const_data));\n                // write data and relocations\n                newa->data = NULL; // relocation offset\n                data /= sizeof(void*);\n                assert(data < ((uintptr_t)1 << RELOC_TAG_OFFSET) && \"offset to constant data too large\");\n                arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_array_t, data))); // relocation location\n                arraylist_push(&s->relocs_list, (void*)(((uintptr_t)ConstDataRef << RELOC_TAG_OFFSET) + data)); // relocation target\n                int isbitsunion = jl_array_isbitsunion(ar);\n                if (ar->elsize == 1 && !isbitsunion)\n                    tot += 1;\n                ios_write(s->const_data, (char*)jl_array_data(ar), tot);\n                if (isbitsunion)\n                    ios_write(s->const_data, jl_array_typetagdata(ar), alen);\n            }\n            else {\n                newa->data = (void*)tsz; // relocation offset\n                arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_array_t, data))); // relocation location\n                arraylist_push(&s->relocs_list, (void*)(((uintptr_t)DataRef << RELOC_TAG_OFFSET) + item)); // relocation target\n                size_t i;\n                for (i = 0; i < alen; i++) {\n                    write_pointerfield(s, jl_array_ptr_ref(v, i));\n                }\n            }\n        }\n        else if (jl_typeis(v, jl_module_type)) {\n            jl_write_module(s, item, (jl_module_t*)v);\n            // will need to recreate the binding table for this\n            arraylist_push(&reinit_list, (void*)item);\n            arraylist_push(&reinit_list, (void*)5);\n        }\n        else if (jl_typeis(v, jl_task_type)) {\n            jl_error(\"Task cannot be serialized\");\n        }\n        else if (jl_is_svec(v)) {\n            ios_write(s->s, (char*)v, sizeof(void*));\n            size_t i, l = jl_svec_len(v);\n            assert(l > 0);\n            for (i = 0; i < l; i++) {\n                write_pointerfield(s, jl_svecref(v, i));\n            }\n        }\n        else if (jl_is_string(v)) {\n            ios_write(s->s, (char*)v, sizeof(void*));\n            ios_write(s->s, jl_string_data(v), jl_string_len(v));\n            write_uint8(s->s, '\\0'); // null-terminated strings for easier C-compatibility\n        }\n        else if (jl_datatype_nfields(t) == 0) {\n            assert(t->layout->npointers == 0);\n            if (t->size > 0)\n                ios_write(s->s, (char*)v, t->size);\n        }\n        else if (jl_bigint_type && jl_typeis(v, jl_bigint_type)) {\n            jl_value_t *sizefield = jl_get_nth_field(v, 1);\n            int32_t sz = jl_unbox_int32(sizefield);\n            int32_t nw = (sz == 0 ? 1 : (sz < 0 ? -sz : sz));\n            size_t nb = nw * gmp_limb_size;\n            ios_write(s->s, (char*)&nw, sizeof(int32_t));\n            ios_write(s->s, (char*)&sz, sizeof(int32_t));\n            uintptr_t data = LLT_ALIGN(ios_pos(s->const_data), 8);\n            write_padding(s->const_data, data - ios_pos(s->const_data));\n            data /= sizeof(void*);\n            assert(data < ((uintptr_t)1 << RELOC_TAG_OFFSET) && \"offset to constant data too large\");\n            arraylist_push(&s->relocs_list, (void*)(reloc_offset + 8)); // relocation location\n            arraylist_push(&s->relocs_list, (void*)(((uintptr_t)ConstDataRef << RELOC_TAG_OFFSET) + data)); // relocation target\n            void *pdata = jl_unbox_voidpointer(jl_get_nth_field(v, 2));\n            ios_write(s->const_data, (char*)pdata, nb);\n            write_pointer(s->s);\n        }\n        else {\n            size_t i, nf = jl_datatype_nfields(t);\n            size_t tot = 0;\n            for (i = 0; i < nf; i++) {\n                size_t offset = jl_field_offset(t, i);\n                char *slot = (char*)v + offset;\n                write_padding(s->s, offset - tot);\n                tot = offset;\n                size_t fsz = jl_field_size(t, i);\n                if (jl_field_isptr(t, i) > 0) {\n                    write_pointerfield(s, *(jl_value_t**)slot);\n                }\n                else if (t->mutabl && jl_is_cpointer_type(jl_field_type(t, i))) {\n                    write_pointer(s->s);\n                }\n                else if (fsz > 0) {\n                    ios_write(s->s, slot, fsz);\n                }\n                tot += fsz;\n            }\n\n            if (jl_is_method(v)) {\n                write_padding(s->s, sizeof(jl_method_t) - tot);\n            }\n            else if (jl_is_method_instance(v)) {\n                jl_method_instance_t *m = (jl_method_instance_t*)v;\n                jl_method_instance_t *newm = (jl_method_instance_t*)&s->s->buf[reloc_offset];\n\n                newm->invoke = NULL;\n                newm->specptr.fptr = NULL;\n                newm->functionObjectsDecls.functionObject = NULL;\n                newm->functionObjectsDecls.specFunctionObject = NULL;\n                uintptr_t fptr_id = JL_API_TRAMPOLINE;\n                uintptr_t specfptr_id = 0;\n                if (m->invoke == jl_fptr_const_return) {\n                    fptr_id = JL_API_CONST;\n                }\n                else {\n                    if (jl_is_method(m->def.method)) {\n                        specfptr_id = jl_fptr_id(m->specptr.fptr);\n                        const char *fname = m->functionObjectsDecls.functionObject;\n                        if (specfptr_id) { // found in the table of builtins\n                            assert(specfptr_id >= 2);\n                            fptr_id = JL_API_BUILTIN;\n                        }\n                        else if (fname) {\n                            assert(reloc_offset < INT32_MAX);\n                            if (!strcmp(fname, \"jl_fptr_args\")) {\n                                fptr_id = JL_API_BOXED;\n                            }\n                            else if (!strcmp(fname, \"jl_fptr_sparam\")) {\n                                fptr_id = JL_API_WITH_PARAMETERS;\n                            }\n                            else {\n                                int func = jl_assign_functionID(fname);\n                                assert(func > 0);\n                                ios_ensureroom(s->fptr_record, func * sizeof(void*));\n                                ios_seek(s->fptr_record, (func - 1) * sizeof(void*));\n                                write_uint32(s->fptr_record, ~reloc_offset);\n#ifdef _P64\n                                write_padding(s->fptr_record, 4);\n#endif\n                            }\n                            fname = m->functionObjectsDecls.specFunctionObject;\n                            if (fname) {\n                                int cfunc = jl_assign_functionID(fname);\n                                assert(cfunc > 0);\n                                ios_ensureroom(s->fptr_record, cfunc * sizeof(void*));\n                                ios_seek(s->fptr_record, (cfunc - 1) * sizeof(void*));\n                                write_uint32(s->fptr_record, reloc_offset);\n#ifdef _P64\n                                write_padding(s->fptr_record, 4);\n#endif\n                            }\n                        }\n                    }\n                }\n                newm->invoke = NULL; // relocation offset\n                arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_method_instance_t, invoke))); // relocation location\n                arraylist_push(&s->relocs_list, (void*)(((uintptr_t)FunctionRef << RELOC_TAG_OFFSET) + fptr_id)); // relocation target\n                if (specfptr_id >= 2) {\n                    arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_method_instance_t, specptr.fptr))); // relocation location\n                    arraylist_push(&s->relocs_list, (void*)(((uintptr_t)BuiltinFunctionRef << RELOC_TAG_OFFSET) + specfptr_id - 2)); // relocation target\n                }\n            }\n            else if (jl_is_datatype(v)) {\n                jl_datatype_t *dt = (jl_datatype_t*)v;\n                jl_datatype_t *newdt = (jl_datatype_t*)&s->s->buf[reloc_offset];\n                newdt->struct_decl = NULL;\n                newdt->ditype = NULL;\n                if (dt->layout != NULL) {\n                    size_t nf = dt->layout->nfields;\n                    size_t fieldsize = jl_fielddesc_size(dt->layout->fielddesc_type);\n                    int has_padding = dt->layout->npointers && nf;\n                    char *flddesc = (char*)dt->layout;\n                    size_t fldsize = sizeof(jl_datatype_layout_t) + nf * fieldsize;\n                    uintptr_t layout_unaligned = LLT_ALIGN(ios_pos(s->const_data), sizeof(uint32_t));\n                    uintptr_t layout = LLT_ALIGN(ios_pos(s->const_data), sizeof(void*));\n                    if (has_padding) {\n                        if (layout == layout_unaligned) {\n                            layout += sizeof(void*);\n                            layout_unaligned = layout - sizeof(uint32_t);\n                        }\n                        flddesc -= sizeof(uint32_t);\n                        fldsize += sizeof(uint32_t);\n                        write_padding(s->const_data, layout_unaligned - ios_pos(s->const_data)); // realign stream\n                    }\n                    else {\n                        write_padding(s->const_data, layout - ios_pos(s->const_data)); // realign stream\n                    }\n                    newdt->layout = NULL; // relocation offset\n                    layout /= sizeof(void*);\n                    arraylist_push(&s->relocs_list, (void*)(reloc_offset + offsetof(jl_datatype_t, layout))); // relocation location\n                    arraylist_push(&s->relocs_list, (void*)(((uintptr_t)ConstDataRef << RELOC_TAG_OFFSET) + layout)); // relocation target\n                    ios_write(s->const_data, flddesc, fldsize);\n                }\n            }\n            else if (((jl_datatype_t*)(jl_typeof(v)))->name == jl_idtable_typename) {\n                // will need to rehash this, later (after types are fully constructed)\n                arraylist_push(&reinit_list, (void*)item);\n                arraylist_push(&reinit_list, (void*)1);\n            }\n            else {\n                write_padding(s->s, t->size - tot);\n            }\n        }\n    }\n}\n\n\nstatic void jl_write_gv_syms(jl_serializer_state *s, jl_sym_t *v)\n{\n    // since symbols are static, they might not have had a\n    // reference anywhere in the code image other than here\n    int32_t gv = jl_get_llvm_gv((jl_value_t*)v);\n    if (gv != 0) {\n        uintptr_t item = backref_id(s, v);\n        assert(item >> RELOC_TAG_OFFSET == SymbolRef);\n        record_gvar(s, gv, item);\n    }\n    if (v->left)\n        jl_write_gv_syms(s, v->left);\n    if (v->right)\n        jl_write_gv_syms(s, v->right);\n}\n\n\nstatic inline uint32_t load_uint32(uintptr_t *base)\n{\n    uint32_t v = **(uint32_t**)base;\n    *base += 4;\n    return v;\n}\n\n\nstatic void jl_read_symbols(jl_serializer_state *s)\n{\n    assert(deser_sym.len == nsym_tag);\n    uintptr_t base = (uintptr_t)&s->symbols->buf[0];\n    uintptr_t end = base + s->symbols->size;\n    while (base < end) {\n        uint32_t len = load_uint32(&base);\n        const char *str = (const char*)base;\n        base += len + 1;\n        //printf(\"symbol %3d: %s\\n\", len, str);\n        jl_sym_t *sym = jl_symbol_n(str, len);\n        arraylist_push(&deser_sym, (void*)sym);\n    }\n}\n\n\nstatic uintptr_t get_reloc_for_item(uintptr_t reloc_item, size_t reloc_offset)\n{\n    enum RefTags tag = (enum RefTags)(reloc_item >> RELOC_TAG_OFFSET);\n    if (tag == DataRef) {\n        // need to compute the final relocation offset via the layout table\n        assert(reloc_item < layout_table.len);\n        uintptr_t reloc_base = (uintptr_t)layout_table.items[reloc_item];\n        assert(reloc_base != 0 && \"layout offset missing for relocation item\");\n        // write reloc_offset into s->s at pos\n        return reloc_base + reloc_offset;\n    }\n    else {\n        // just write the item reloc_id directly\n#ifndef JL_NDEBUG\n        assert(reloc_offset == 0 && \"offsets for relocations to builtin objects should be precomposed in the reloc_item\");\n        size_t offset = (reloc_item & (((uintptr_t)1 << RELOC_TAG_OFFSET) - 1));\n        switch (tag) {\n        case ConstDataRef:\n            break;\n        case TagRef:\n            assert(offset >= 2 && offset < deser_tag.len && deser_tag.items[offset] && \"corrupt relocation item id\");\n            break;\n        case SymbolRef:\n            assert(offset < nsym_tag && \"corrupt relocation item id\");\n            break;\n        case BindingRef:\n            assert(offset == 0 && \"corrupt relocation offset\");\n            break;\n        case BuiltinFunctionRef:\n            assert(offset < sizeof(id_to_fptrs) / sizeof(*id_to_fptrs) && \"unknown function pointer id\");\n            break;\n        case FunctionRef:\n            assert(offset < JL_API_MAX && \"unknown function pointer id\");\n            break;\n        case DataRef:\n        default:\n            assert(\"corrupt relocation item id\");\n            abort();\n        }\n#endif\n        return reloc_item; // pre-composed relocation + offset\n    }\n}\n\n\nstatic inline uintptr_t get_item_for_reloc(jl_serializer_state *s, uintptr_t base, size_t size, uint32_t reloc_id)\n{\n    enum RefTags tag = (enum RefTags)(reloc_id >> RELOC_TAG_OFFSET);\n    size_t offset = (reloc_id & (((uintptr_t)1 << RELOC_TAG_OFFSET) - 1));\n    switch (tag) {\n    case DataRef:\n        assert(offset < size);\n        return base + offset;\n    case ConstDataRef:\n        return (uintptr_t)deser_tag.items[0] + (offset * sizeof(void*));\n    case TagRef:\n        assert(offset < deser_tag.len && deser_tag.items[offset] && \"corrupt relocation item id\");\n        return (uintptr_t)deser_tag.items[offset];\n    case SymbolRef:\n        assert(offset < deser_sym.len && deser_sym.items[offset] && \"corrupt relocation item id\");\n        return (uintptr_t)deser_sym.items[offset];\n    case BindingRef:\n        return jl_buff_tag | GC_OLD_MARKED;\n    case BuiltinFunctionRef:\n        assert(offset < sizeof(id_to_fptrs) / sizeof(*id_to_fptrs) && \"unknown function pointer ID\");\n        return (uintptr_t)id_to_fptrs[offset];\n    case FunctionRef:\n        switch ((jl_callingconv_t)offset) {\n        case JL_API_BOXED:\n            if (sysimg_fptrs.base)\n                return (uintptr_t)jl_fptr_args;\n            JL_FALLTHROUGH;\n        case JL_API_WITH_PARAMETERS:\n            if (sysimg_fptrs.base)\n                return (uintptr_t)jl_fptr_sparam;\n            JL_FALLTHROUGH;\n        case JL_API_TRAMPOLINE:\n            return (uintptr_t)jl_fptr_trampoline;\n        case JL_API_CONST:\n            return (uintptr_t)jl_fptr_const_return;\n        case JL_API_INTERPRETED:\n            return (uintptr_t)jl_fptr_interpret_call;\n        case JL_API_BUILTIN:\n            return (uintptr_t)jl_fptr_args;\n        case JL_API_MAX:\n        //default:\n            assert(\"corrupt relocation item id\");\n        }\n    }\n    abort();\n}\n\n\nstatic void jl_write_skiplist(ios_t *s, char *base, size_t size, arraylist_t *list)\n{\n    size_t i;\n    for (i = 0; i < list->len; i += 2) {\n        size_t pos = (size_t)list->items[i];\n        size_t item = (size_t)list->items[i + 1];\n        uintptr_t *pv = (uintptr_t*)(base + pos);\n        assert(pos < size && pos != 0);\n        *pv = get_reloc_for_item(item, *pv);\n        // record pos in relocations list\n        // TODO: save space by using delta-compression\n        assert(pos < UINT32_MAX);\n        write_uint32(s, pos);\n    }\n    write_uint32(s, 0);\n}\n\n\nstatic void jl_write_relocations(jl_serializer_state *s)\n{\n    char *base = &s->s->buf[0];\n    jl_write_skiplist(s->relocs, base, s->s->size, &s->gctags_list);\n    jl_write_skiplist(s->relocs, base, s->s->size, &s->relocs_list);\n}\n\n\nstatic void jl_read_relocations(jl_serializer_state *s, uint8_t bits)\n{\n    uintptr_t base = (uintptr_t)&s->s->buf[0];\n    size_t size = s->s->size;\n    while (1) {\n        uintptr_t val = (uintptr_t)&s->relocs->buf[s->relocs->bpos];\n        uint32_t offset = load_uint32(&val);\n        s->relocs->bpos += sizeof(uint32_t);\n        if (offset == 0)\n            break;\n        uintptr_t *pv = (uintptr_t*)(base + offset);\n        uintptr_t v = *pv;\n        v = get_item_for_reloc(s, base, size, v);\n        *pv = v | bits;\n    }\n}\n\nstatic char* sysimg_base;\nstatic char* sysimg_relocs;\nvoid gc_sweep_sysimg(void)\n{\n    uintptr_t base = (uintptr_t)sysimg_base;\n    uintptr_t relocs = (uintptr_t)sysimg_relocs;\n    if (relocs == 0)\n        return;\n    while (1) {\n        uint32_t offset = load_uint32(&relocs);\n        if (offset == 0)\n            break;\n        jl_taggedvalue_t *o = (jl_taggedvalue_t*)(base + offset);\n        o->bits.gc = GC_OLD;\n    }\n}\n\n#define jl_write_value(s, v) _jl_write_value((s), (jl_value_t*)(v))\nstatic void _jl_write_value(jl_serializer_state *s, jl_value_t *v)\n{\n    if (v == NULL) {\n        write_uint32(s->s, 0);\n        return;\n    }\n    uintptr_t item = backref_id(s, v);\n    uintptr_t reloc = get_reloc_for_item(item, 0);\n    assert(reloc < UINT32_MAX);\n    write_uint32(s->s, reloc);\n}\n\n\nstatic jl_value_t *jl_read_value(jl_serializer_state *s)\n{\n    uintptr_t base = (uintptr_t)&s->s->buf[0];\n    size_t size = s->s->size;\n    uintptr_t val = base + s->s->bpos;\n    uint32_t offset = load_uint32(&val);\n    s->s->bpos += sizeof(uint32_t);\n    if (offset == 0)\n        return NULL;\n    return (jl_value_t*)get_item_for_reloc(s, base, size, offset);\n}\n\n\nstatic void jl_update_all_fptrs(jl_serializer_state *s)\n{\n    jl_sysimg_fptrs_t fvars = sysimg_fptrs;\n    // make these NULL now so we skip trying to restore GlobalVariable pointers later\n    sysimg_gvars_base = NULL;\n    sysimg_fptrs.base = NULL;\n    if (fvars.base == NULL)\n        return;\n    int sysimg_fvars_max = s->fptr_record->size / sizeof(void*);\n    size_t i;\n    uintptr_t base = (uintptr_t)&s->s->buf[0];\n    jl_method_instance_t **linfos = (jl_method_instance_t**)&s->fptr_record->buf[0];\n    uint32_t clone_idx = 0;\n    for (i = 0; i < sysimg_fvars_max; i++) {\n        uintptr_t val = (uintptr_t)&linfos[i];\n        uint32_t offset = load_uint32(&val);\n        if (offset != 0) {\n            int specfunc = 1;\n            if (offset & ((uintptr_t)1 << (8 * sizeof(uint32_t) - 1))) {\n                // if high bit is set, this is the func wrapper, not the specfunc\n                specfunc = 0;\n                offset = ~offset;\n            }\n            jl_method_instance_t *li = (jl_method_instance_t*)(base + offset);\n            uintptr_t base = (uintptr_t)fvars.base;\n            assert(jl_is_method(li->def.method) && li->invoke != jl_fptr_const_return);\n            assert(specfunc ? li->invoke != jl_fptr_trampoline : li->invoke == jl_fptr_trampoline);\n            linfos[i] = li;\n            int32_t offset = fvars.offsets[i];\n            for (; clone_idx < fvars.nclones; clone_idx++) {\n                uint32_t idx = fvars.clone_idxs[clone_idx] & jl_sysimg_val_mask;\n                if (idx < i)\n                    continue;\n                if (idx == i)\n                    offset = fvars.clone_offsets[clone_idx];\n                break;\n            }\n            void *fptr = (void*)(base + offset);\n            if (specfunc)\n                li->specptr.fptr = fptr;\n            else\n                li->invoke = (jl_callptr_t)fptr;\n            jl_fptr_to_llvm(fptr, li, specfunc);\n        }\n    }\n    jl_register_fptrs(sysimage_base, &fvars, linfos, sysimg_fvars_max);\n}\n\n\nstatic void jl_update_all_gvars(jl_serializer_state *s)\n{\n    if (sysimg_gvars_base == NULL)\n        return;\n    size_t gvname_index = 0;\n    uintptr_t base = (uintptr_t)&s->s->buf[0];\n    size_t size = s->s->size;\n    uintptr_t gvars = (uintptr_t)&s->gvar_record->buf[0];\n    uintptr_t end = gvars + s->gvar_record->size;\n    while (gvars < end) {\n        uint32_t offset = load_uint32(&gvars);\n        if (offset) {\n            uintptr_t v = get_item_for_reloc(s, base, size, offset);\n            *sysimg_gvars(sysimg_gvars_base, gvname_index) = v;\n        }\n        gvname_index += 1;\n    }\n}\n\n\nstatic void jl_finalize_serializer(jl_serializer_state *s)\n{\n    size_t i, l;\n    // save module initialization order\n    if (jl_module_init_order != NULL) {\n        l = jl_array_len(jl_module_init_order);\n        for (i = 0; i < l; i++) {\n            // verify that all these modules were saved\n            assert(ptrhash_get(&backref_table, jl_array_ptr_ref(jl_module_init_order, i)) != HT_NOTFOUND);\n        }\n    }\n    jl_write_value(s, jl_module_init_order);\n\n    // record list of reinitialization functions\n    l = reinit_list.len;\n    for (i = 0; i < l; i += 2) {\n        size_t item = (size_t)reinit_list.items[i];\n        size_t reloc_offset = (size_t)layout_table.items[item];\n        assert(reloc_offset != 0);\n        write_uint32(s->s, (uint32_t)reloc_offset);\n        write_uint32(s->s, (uint32_t)((uintptr_t)reinit_list.items[i + 1]));\n    }\n    write_uint32(s->s, 0);\n}\n\n\nvoid jl_typemap_rehash(union jl_typemap_t ml, int8_t offs);\nstatic void jl_reinit_item(jl_value_t *v, int how, arraylist_t *tracee_list)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    JL_TRY {\n        switch (how) {\n            case 1: { // rehash IdDict\n                jl_array_t **a = (jl_array_t**)v;\n                assert(jl_is_array(*a));\n                // Assume *a don't need a write barrier\n                *a = jl_idtable_rehash(*a, jl_array_len(*a));\n                jl_gc_wb(v, *a);\n                break;\n            }\n            case 2: { // reinsert module v into parent (const)\n                jl_module_t *mod = (jl_module_t*)v;\n                assert(jl_is_module(mod));\n                jl_binding_t *b = jl_get_binding_wr(mod->parent, mod->name, 1);\n                jl_declare_constant(b); // this can throw\n                if (b->value != NULL) {\n                    if (!jl_is_module(b->value)) {\n                        jl_errorf(\"Invalid redefinition of constant %s.\",\n                                  jl_symbol_name(mod->name)); // this also throws\n                    }\n                    if (jl_generating_output() && jl_options.incremental) {\n                        jl_errorf(\"Cannot replace module %s during incremental precompile.\", jl_symbol_name(mod->name));\n                    }\n                    jl_printf(JL_STDERR, \"WARNING: replacing module %s.\\n\",\n                              jl_symbol_name(mod->name));\n                }\n                b->value = v;\n                jl_gc_wb_binding(b, v);\n                break;\n            }\n            case 3: { // rehash MethodTable\n                jl_methtable_t *mt = (jl_methtable_t*)v;\n                assert(jl_is_mtable(mt));\n                jl_typemap_rehash(mt->defs, 0);\n                // TODO: consider reverting this when we can split on Type{...} better\n                jl_typemap_rehash(mt->cache, 1); //(mt == jl_type_typename->mt) ? 0 : 1);\n                if (tracee_list)\n                    arraylist_push(tracee_list, mt);\n                break;\n            }\n            case 4: { // rehash specializations tfunc\n                jl_method_t *m = (jl_method_t*)v;\n                assert(jl_is_method(m));\n                jl_typemap_rehash(m->specializations, 0);\n                break;\n            }\n            case 5: { // rebuild the binding table for module v\n                jl_module_t *mod = (jl_module_t*)v;\n                assert(jl_is_module(mod));\n                size_t nbindings = mod->bindings.size;\n                htable_new(&mod->bindings, nbindings);\n                struct binding {\n                    uintptr_t tag;\n                    jl_binding_t b;\n                } *b;\n                b = (struct binding*)&mod[1];\n                while (nbindings > 0) {\n                    ptrhash_put(&mod->bindings, (char*)b->b.name, &b->b);\n                    b += 1;\n                    nbindings -= 1;\n                }\n                break;\n            }\n            default:\n                assert(0 && \"corrupt deserialization state\");\n                abort();\n        }\n    }\n    JL_CATCH {\n        jl_printf(JL_STDERR, \"WARNING: error while reinitializing value \");\n        jl_static_show(JL_STDERR, v);\n        jl_printf(JL_STDERR, \":\\n\");\n        jl_static_show(JL_STDERR, ptls->exception_in_transit);\n        jl_printf(JL_STDERR, \"\\n\");\n    }\n}\n\n\nstatic jl_array_t *jl_finalize_deserializer(jl_serializer_state *s, arraylist_t *tracee_list)\n{\n    jl_array_t *init_order = (jl_array_t*)jl_read_value(s);\n\n    // run reinitialization functions\n    uintptr_t base = (uintptr_t)&s->s->buf[0];\n    while (1) {\n        size_t offset = read_uint32(s->s);\n        if (offset == 0)\n            break;\n        jl_value_t *v = (jl_value_t*)(base + offset);\n        jl_reinit_item(v, read_uint32(s->s), tracee_list);\n    }\n    return init_order;\n}\n\n\n\n// --- helper functions ---\n\n// remove cached types not referenced in the stream\nstatic void jl_prune_type_cache(jl_svec_t *cache)\n{\n    size_t l = jl_svec_len(cache), ins = 0, i;\n    for (i = 0; i < l; i++) {\n        jl_value_t *ti = jl_svecref(cache, i);\n        if (ti == NULL)\n            break;\n        if (ptrhash_get(&backref_table, ti) != HT_NOTFOUND || jl_get_llvm_gv(ti) != 0)\n            jl_svecset(cache, ins++, ti);\n        else if (jl_is_datatype(ti)) {\n            jl_value_t *singleton = ((jl_datatype_t*)ti)->instance;\n            if (singleton && (ptrhash_get(&backref_table, singleton) != HT_NOTFOUND || jl_get_llvm_gv(singleton) != 0))\n                jl_svecset(cache, ins++, ti);\n        }\n    }\n    if (i > ins) {\n        memset(&jl_svec_data(cache)[ins], 0, (i - ins) * sizeof(jl_value_t*));\n    }\n}\n\n\n// --- entry points ---\n\nstatic void jl_init_serializer2(int);\nstatic void jl_cleanup_serializer2(void);\n\nstatic void jl_save_system_image_to_stream(ios_t *f)\n{\n    jl_gc_collect(1); // full\n    jl_gc_collect(0); // incremental (sweep finalizers)\n    JL_TIMING(SYSIMG_DUMP);\n    int en = jl_gc_enable(0);\n    jl_init_serializer2(1);\n    htable_reset(&backref_table, 250000);\n    arraylist_new(&reinit_list, 0);\n    backref_table_numel = 0;\n    ios_t sysimg, const_data, symbols, relocs, gvar_record, fptr_record;\n    ios_mem(&sysimg,     1000000);\n    ios_mem(&const_data,  100000);\n    ios_mem(&symbols,     100000);\n    ios_mem(&relocs,      100000);\n    ios_mem(&gvar_record, 100000);\n    ios_mem(&fptr_record, 100000);\n    jl_serializer_state s;\n    s.s = &sysimg;\n    s.const_data = &const_data;\n    s.symbols = &symbols;\n    s.relocs = &relocs;\n    s.gvar_record = &gvar_record;\n    s.fptr_record = &fptr_record;\n    s.mode = MODE_SYSTEM_IMAGE;\n    s.ptls = jl_get_ptls_states();\n    arraylist_new(&s.relocs_list, 0);\n    arraylist_new(&s.gctags_list, 0);\n\n    // empty!(Core.ARGS)\n    if (jl_core_module != NULL) {\n        jl_array_t *args = (jl_array_t*)jl_get_global(jl_core_module, jl_symbol(\"ARGS\"));\n        if (args != NULL) {\n            jl_array_del_end(args, jl_array_len(args));\n        }\n    }\n\n    jl_idtable_type = jl_base_module ? jl_get_global(jl_base_module, jl_symbol(\"IdDict\")) : NULL;\n    jl_idtable_typename = jl_base_module ? ((jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)jl_idtable_type))->name : NULL;\n    jl_bigint_type = jl_base_module ? jl_get_global(jl_base_module, jl_symbol(\"BigInt\")) : NULL;\n    if (jl_bigint_type) {\n        gmp_limb_size = jl_unbox_long(jl_get_global((jl_module_t*)jl_get_global(jl_base_module, jl_symbol(\"GMP\")),\n                                                    jl_symbol(\"BITS_PER_LIMB\"))) / 8;\n    }\n\n    { // step 1: record values (recursively) that need to go in the image\n        jl_serialize_value(&s, jl_core_module);\n        jl_serialize_value(&s, jl_main_module);\n        jl_serialize_value(&s, jl_top_module);\n        jl_serialize_value(&s, jl_typeinf_func);\n        jl_serialize_value(&s, jl_module_init_order);\n\n        // serialize method tables of builtin types\n        jl_serialize_value(&s, jl_type_typename->mt);\n        jl_serialize_value(&s, jl_intrinsic_type->name->mt);\n        jl_serialize_value(&s, jl_sym_type->name->mt);\n        jl_serialize_value(&s, jl_array_typename->mt);\n        jl_serialize_value(&s, jl_module_type->name->mt);\n\n        jl_prune_type_cache(jl_tuple_typename->cache);\n        jl_prune_type_cache(jl_tuple_typename->linearcache);\n        jl_prune_type_cache(jl_type_typename->cache);\n\n        uintptr_t i;\n        for (i = 0; i < builtin_typenames.len; i++) {\n            jl_serialize_value(&s, ((jl_typename_t*)builtin_typenames.items[i])->cache);\n            jl_serialize_value(&s, ((jl_typename_t*)builtin_typenames.items[i])->linearcache);\n        }\n    }\n\n    { // step 2: build all the sysimg sections\n        write_padding(&sysimg, sizeof(uint32_t));\n        jl_write_values(&s);\n        jl_write_relocations(&s);\n        jl_write_gv_syms(&s, jl_get_root_symbol());\n        // ensure everything in deser_tag are reassociated with their GlobalValue\n        uintptr_t i;\n        for (i = 0; i < deser_tag.len; i++) {\n            jl_value_t *v = (jl_value_t*)deser_tag.items[i];\n            record_gvar(&s, jl_get_llvm_gv(v), ((uintptr_t)TagRef << RELOC_TAG_OFFSET) + i);\n        }\n    }\n\n    // step 3: combine all of the sections into one file\n    write_uint32(f, sysimg.size - sizeof(uint32_t));\n    ios_seek(&sysimg, sizeof(uint32_t));\n    ios_copyall(f, &sysimg);\n    ios_close(&sysimg);\n\n    write_uint32(f, const_data.size);\n    // realign stream to max-alignment for data\n    write_padding(f, LLT_ALIGN(ios_pos(f), 16) - ios_pos(f));\n    ios_seek(&const_data, 0);\n    ios_copyall(f, &const_data);\n    ios_close(&const_data);\n\n    write_uint32(f, symbols.size);\n    ios_seek(&symbols, 0);\n    ios_copyall(f, &symbols);\n    ios_close(&symbols);\n\n    write_uint32(f, relocs.size);\n    ios_seek(&relocs, 0);\n    ios_copyall(f, &relocs);\n    ios_close(&relocs);\n\n    write_uint32(f, gvar_record.size);\n    ios_seek(&gvar_record, 0);\n    ios_copyall(f, &gvar_record);\n    ios_close(&gvar_record);\n\n    write_uint32(f, fptr_record.size);\n    ios_seek(&fptr_record, 0);\n    ios_copyall(f, &fptr_record);\n    ios_close(&fptr_record);\n\n    { // step 4: record locations of special roots\n        s.s = f;\n        jl_finalize_serializer(&s);\n        jl_write_value(&s, jl_main_module);\n        jl_write_value(&s, jl_top_module);\n        jl_write_value(&s, jl_typeinf_func);\n        write_uint32(f, jl_typeinf_world);\n        jl_write_value(&s, jl_type_typename->mt);\n        jl_write_value(&s, jl_intrinsic_type->name->mt);\n        jl_write_value(&s, jl_sym_type->name->mt);\n        jl_write_value(&s, jl_array_typename->mt);\n        jl_write_value(&s, jl_module_type->name->mt);\n        uintptr_t i;\n        for (i = 0; i < builtin_typenames.len; i++) {\n            jl_write_value(&s, ((jl_typename_t*)builtin_typenames.items[i])->cache);\n            jl_write_value(&s, ((jl_typename_t*)builtin_typenames.items[i])->linearcache);\n        }\n        write_uint32(f, jl_get_t_uid_ctr());\n        write_uint32(f, jl_get_gs_ctr());\n        write_uint32(f, jl_world_counter);\n    }\n\n    arraylist_free(&layout_table);\n    arraylist_free(&reinit_list);\n    arraylist_free(&s.relocs_list);\n    arraylist_free(&s.gctags_list);\n    jl_cleanup_serializer2();\n\n    jl_gc_enable(en);\n}\n\nJL_DLLEXPORT ios_t *jl_create_system_image(void)\n{\n    ios_t *f = (ios_t*)malloc(sizeof(ios_t));\n    ios_mem(f, 0);\n    jl_save_system_image_to_stream(f);\n    return f;\n}\n\nJL_DLLEXPORT size_t ios_write_direct(ios_t *dest, ios_t *src);\nJL_DLLEXPORT void jl_save_system_image(const char *fname)\n{\n    ios_t f;\n    if (ios_file(&f, fname, 1, 1, 1, 1) == NULL) {\n        jl_errorf(\"cannot open system image file \\\"%s\\\" for writing\", fname);\n    }\n    JL_SIGATOMIC_BEGIN();\n    jl_save_system_image_to_stream(&f);\n    ios_close(&f);\n    JL_SIGATOMIC_END();\n}\n\nextern void jl_get_builtins(void);\nextern void jl_get_builtin_hooks(void);\nextern void jl_gc_set_permalloc_region(void *start, void *end);\n\n// Takes in a path of the form \"usr/lib/julia/sys.so\" (jl_restore_system_image should be passed the same string)\nJL_DLLEXPORT void jl_preload_sysimg_so(const char *fname)\n{\n    if (jl_sysimg_handle)\n        return; // embedded target already called jl_set_sysimg_so\n\n    char *dot = (char*) strrchr(fname, '.');\n    int is_ji = (dot && !strcmp(dot, \".ji\"));\n\n    // Get handle to sys.so\n    if (!is_ji) // .ji extension => load .ji file only\n        jl_set_sysimg_so(jl_load_dynamic_library(fname, JL_RTLD_LOCAL | JL_RTLD_NOW));\n}\n\n// Allow passing in a module handle directly, rather than a path\nJL_DLLEXPORT void jl_set_sysimg_so(void *handle)\n{\n    void* *jl_RTLD_DEFAULT_handle_pointer = (void**)jl_dlsym_e(handle, \"jl_RTLD_DEFAULT_handle_pointer\");\n    if (!jl_RTLD_DEFAULT_handle_pointer || (void*)&jl_RTLD_DEFAULT_handle != *jl_RTLD_DEFAULT_handle_pointer)\n        jl_error(\"System image file failed consistency check: maybe opened the wrong version?\");\n    if (jl_options.cpu_target == NULL)\n        jl_options.cpu_target = \"native\";\n    jl_sysimg_handle = handle;\n    sysimg_fptrs = jl_init_processor_sysimg(handle);\n}\n\nstatic void jl_restore_system_image_from_stream(ios_t *f)\n{\n    JL_TIMING(SYSIMG_LOAD);\n    jl_ptls_t ptls = jl_get_ptls_states();\n    int en = jl_gc_enable(0);\n    jl_init_serializer2(0);\n    ios_t sysimg, const_data, symbols, relocs, gvar_record, fptr_record;\n    jl_serializer_state s;\n    s.s = &sysimg;\n    s.const_data = &const_data;\n    s.symbols = &symbols;\n    s.relocs = &relocs;\n    s.gvar_record = &gvar_record;\n    s.fptr_record = &fptr_record;\n    s.mode = MODE_SYSTEM_IMAGE;\n    s.ptls = jl_get_ptls_states();\n    arraylist_new(&s.relocs_list, 0);\n    arraylist_new(&s.gctags_list, 0);\n    jl_bigint_type = jl_base_module ? jl_get_global(jl_base_module, jl_symbol(\"BigInt\")) : NULL;\n    if (jl_bigint_type) {\n        gmp_limb_size = jl_unbox_long(jl_get_global((jl_module_t*)jl_get_global(jl_base_module, jl_symbol(\"GMP\")),\n                                                    jl_symbol(\"BITS_PER_LIMB\"))) / 8;\n    }\n\n    // step 1: read section map and apply relocations\n    assert(ios_pos(f) == 0 && f->bm == bm_mem);\n    size_t sizeof_sysimg = read_uint32(f);\n    ios_static_buffer(&sysimg, f->buf, sizeof_sysimg + sizeof(uint32_t));\n    ios_skip(f, sizeof_sysimg);\n\n    size_t sizeof_constdata = read_uint32(f);\n    // realign stream to max-alignment for data\n    ios_seek(f, LLT_ALIGN(ios_pos(f), 16));\n    ios_static_buffer(&const_data, f->buf + f->bpos, sizeof_constdata);\n    ios_skip(f, sizeof_constdata);\n\n    size_t sizeof_symbols = read_uint32(f);\n    ios_static_buffer(&symbols, f->buf + f->bpos, sizeof_symbols);\n    ios_skip(f, sizeof_symbols);\n\n    size_t sizeof_relocations = read_uint32(f);\n    assert(!ios_eof(f));\n    ios_static_buffer(&relocs, f->buf + f->bpos, sizeof_relocations);\n    ios_skip(f, sizeof_relocations);\n\n    size_t sizeof_gvar_record = read_uint32(f);\n    assert(!ios_eof(f));\n    ios_static_buffer(&gvar_record, f->buf + f->bpos, sizeof_gvar_record);\n    ios_skip(f, sizeof_gvar_record);\n\n    size_t sizeof_fptr_record = read_uint32(f);\n    assert(!ios_eof(f));\n    ios_static_buffer(&fptr_record, f->buf + f->bpos, sizeof_fptr_record);\n    ios_skip(f, sizeof_fptr_record);\n\n    assert(!ios_eof(f));\n    jl_read_symbols(&s);\n    ios_close(&symbols);\n\n    sysimg_base = &sysimg.buf[0];\n    sysimg_relocs = &relocs.buf[0];\n    jl_gc_set_permalloc_region((void*)sysimg_base, (void*)(sysimg_base + sysimg.size));\n\n    deser_tag.items[0] = (void*)const_data.buf;\n    jl_read_relocations(&s, GC_OLD_MARKED); // gctags\n    size_t sizeof_tags = ios_pos(&relocs);\n    jl_read_relocations(&s, 0); // general relocs\n    ios_close(&relocs);\n    ios_close(&const_data);\n    ios_close(&sysimg);\n\n    if (0) {\n        printf(\"sysimg size breakdown:\\n\"\n               \"     sys data: %8u\\n\"\n               \"  isbits data: %8u\\n\"\n               \"      symbols: %8u\\n\"\n               \"    tags list: %8u\\n\"\n               \"   reloc list: %8u\\n\"\n               \"    gvar list: %8u\\n\"\n               \"    fptr list: %8u\\n\",\n            (unsigned)sizeof_sysimg,\n            (unsigned)sizeof_constdata,\n            (unsigned)sizeof_symbols,\n            (unsigned)sizeof_tags,\n            (unsigned)(sizeof_relocations - sizeof_tags),\n            (unsigned)sizeof_gvar_record,\n            (unsigned)sizeof_fptr_record);\n    }\n\n    // step 2: get special values\n    s.s = f;\n    jl_module_init_order = jl_finalize_deserializer(&s, NULL);\n    jl_main_module = (jl_module_t*)jl_read_value(&s);\n    jl_top_module = (jl_module_t*)jl_read_value(&s);\n    jl_internal_main_module = jl_main_module;\n\n    jl_typeinf_func = (jl_function_t*)jl_read_value(&s);\n    jl_typeinf_world = read_uint32(f);\n    jl_type_type_mt = (jl_methtable_t*)jl_read_value(&s);\n    jl_type_typename->mt = jl_type_type_mt;\n    jl_unionall_type->name->mt = jl_type_type_mt;\n    jl_uniontype_type->name->mt = jl_type_type_mt;\n    jl_datatype_type->name->mt = jl_type_type_mt;\n    jl_intrinsic_type->name->mt = (jl_methtable_t*)jl_read_value(&s);\n    jl_sym_type->name->mt = (jl_methtable_t*)jl_read_value(&s);\n    jl_array_typename->mt = (jl_methtable_t*)jl_read_value(&s);\n    jl_module_type->name->mt = (jl_methtable_t*)jl_read_value(&s);\n\n    uintptr_t i;\n    for (i = 0; i < builtin_typenames.len; i++) {\n        jl_typename_t *tn = (jl_typename_t*)builtin_typenames.items[i];\n        tn->cache = (jl_svec_t*)jl_read_value(&s);\n        jl_gc_wb(tn, tn->cache);\n        tn->linearcache = (jl_svec_t*)jl_read_value(&s);\n        jl_gc_wb(tn, tn->linearcache);\n        jl_resort_type_cache(tn->cache);\n    }\n\n    jl_core_module = (jl_module_t*)jl_get_global(jl_main_module, jl_symbol(\"Core\"));\n    jl_base_module = (jl_module_t*)jl_get_global(jl_main_module, jl_symbol(\"Base\"));\n    ptls->current_module = jl_base_module; // run start_image in Base\n\n    uint32_t uid_ctr = read_uint32(f);\n    uint32_t gs_ctr = read_uint32(f);\n    jl_world_counter = read_uint32(f);\n\n    jl_set_t_uid_ctr(uid_ctr);\n    jl_set_gs_ctr(gs_ctr);\n\n    jl_get_builtins();\n    jl_get_builtin_hooks();\n    jl_init_box_caches();\n\n    jl_update_all_gvars(&s);\n    ios_close(&gvar_record);\n    jl_update_all_fptrs(&s);\n    ios_close(&fptr_record);\n\n    jl_gc_reset_alloc_count();\n    jl_gc_enable(en);\n    jl_cleanup_serializer2();\n}\n\n// TODO: need to enforce that the alignment of the buffer is suitable for vectors\nJL_DLLEXPORT void jl_restore_system_image(const char *fname)\n{\n#ifndef JL_NDEBUG\n    char *dot = fname ? (char*)strrchr(fname, '.') : NULL;\n    int is_ji = (dot && !strcmp(dot, \".ji\"));\n    assert((is_ji || jl_sysimg_handle) && \"System image file not preloaded\");\n#endif\n\n    if (jl_sysimg_handle) {\n        // load the pre-compiled sysimage from jl_sysimg_handle\n        jl_load_sysimg_so();\n    }\n    else {\n        ios_t f;\n        if (ios_file(&f, fname, 1, 0, 0, 0) == NULL)\n            jl_errorf(\"System image file \\\"%s\\\" not found.\", fname);\n        ios_bufmode(&f, bm_none);\n        JL_SIGATOMIC_BEGIN();\n        ios_seek_end(&f);\n        size_t len = ios_pos(&f);\n        char *sysimg = (char*)jl_gc_perm_alloc(len, 0, 64, 0);\n        ios_seek(&f, 0);\n        if (ios_readall(&f, sysimg, len) != len)\n            jl_errorf(\"Error reading system image file.\");\n        ios_close(&f);\n        ios_static_buffer(&f, sysimg, len);\n        jl_restore_system_image_from_stream(&f);\n        ios_close(&f);\n        JL_SIGATOMIC_END();\n    }\n}\n\nJL_DLLEXPORT void jl_restore_system_image_data(const char *buf, size_t len)\n{\n    ios_t f;\n    JL_SIGATOMIC_BEGIN();\n    ios_static_buffer(&f, (char*)buf, len);\n    jl_restore_system_image_from_stream(&f);\n    ios_close(&f);\n    JL_SIGATOMIC_END();\n}\n\n// --- init ---\n\nstatic void jl_init_serializer2(int for_serialize)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    arraylist_new(&builtin_typenames, 0);\n    if (for_serialize) {\n        htable_new(&sertag_table, 0);\n        htable_new(&symbol_table, 0);\n        htable_new(&fptr_to_id, sizeof(id_to_fptrs) / sizeof(*id_to_fptrs));\n        htable_new(&backref_table, 0);\n    }\n    else {\n        arraylist_new(&deser_tag, 0);\n        arraylist_new(&deser_sym, 0);\n    }\n    uintptr_t i;\n\n    void *tags[] = { ptls->root_task,\n                     jl_symbol_type, jl_ssavalue_type, jl_datatype_type, jl_slotnumber_type,\n                     jl_simplevector_type, jl_array_type, jl_typedslot_type,\n                     jl_expr_type, jl_globalref_type, jl_string_type,\n                     jl_module_type, jl_tvar_type, jl_method_instance_type, jl_method_type,\n                     jl_emptysvec, jl_emptytuple, jl_false, jl_true, jl_nothing, jl_any_type,\n                     call_sym, invoke_sym, goto_ifnot_sym, return_sym, jl_symbol(\"tuple\"),\n                     unreachable_sym,\n                     jl_linenumbernode_type, jl_lineinfonode_type,\n                     jl_gotonode_type, jl_quotenode_type,\n                     jl_pinode_type, jl_phinode_type, jl_phicnode_type, jl_upsilonnode_type,\n                     jl_type_type, jl_bottom_type, jl_ref_type, jl_pointer_type,\n                     jl_vararg_type, jl_abstractarray_type,\n                     jl_densearray_type, jl_void_type, jl_function_type, jl_typeofbottom_type,\n                     jl_unionall_type, jl_typename_type, jl_builtin_type, jl_code_info_type,\n                     jl_task_type, jl_uniontype_type, jl_typetype_type, jl_abstractstring_type,\n                     jl_array_any_type, jl_intrinsic_type, jl_abstractslot_type,\n                     jl_methtable_type, jl_typemap_level_type, jl_typemap_entry_type,\n                     jl_voidpointer_type, jl_newvarnode_type,\n                     jl_array_symbol_type, jl_anytuple_type, jl_tparam0(jl_anytuple_type),\n                     jl_emptytuple_type, jl_array_uint8_type, jl_array_int32_type,\n                     jl_symbol_type->name, jl_ssavalue_type->name, jl_tuple_typename,\n                     ((jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)jl_ref_type))->name,\n                     jl_pointer_typename, jl_simplevector_type->name,\n                     jl_datatype_type->name, jl_uniontype_type->name, jl_array_typename,\n                     jl_expr_type->name, jl_typename_type->name, jl_type_typename,\n                     jl_methtable_type->name, jl_typemap_level_type->name, jl_typemap_entry_type->name, jl_tvar_type->name,\n                     ((jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)jl_abstractarray_type))->name,\n                     ((jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)jl_densearray_type))->name,\n                     jl_vararg_typename, jl_void_type->name, jl_method_instance_type->name, jl_method_type->name,\n                     jl_module_type->name, jl_function_type->name, jl_typedslot_type->name,\n                     jl_abstractslot_type->name, jl_slotnumber_type->name,\n                     jl_unionall_type->name, jl_intrinsic_type->name, jl_task_type->name,\n                     jl_linenumbernode_type->name, jl_builtin_type->name,\n                     jl_gotonode_type->name, jl_quotenode_type->name, jl_lineinfonode_type->name,\n                     jl_pinode_type->name, jl_phinode_type->name,\n                     jl_phicnode_type->name, jl_upsilonnode_type->name,\n                     jl_globalref_type->name, jl_typeofbottom_type->name,\n                     jl_string_type->name, jl_abstractstring_type->name,\n                     jl_namedtuple_type, jl_namedtuple_typename,\n\n                     jl_int32_type, jl_int64_type, jl_bool_type, jl_uint8_type,\n                     jl_uint32_type, jl_uint64_type,\n\n                     // empirical list of very common symbols\n                     #include \"common_symbols1.inc\"\n\n                     NULL };\n\n    arraylist_push(&deser_tag, NULL);\n    arraylist_push(&deser_tag, NULL);\n    for (i = 0; tags[i] != NULL; i++) {\n        void *v = tags[i];\n        if (!for_serialize) {\n            // some builtins are only rooted through a type cache or Main.Core binding,\n            // but were allocated young, so we force the gc to change their tag here\n            jl_gc_force_mark_old(ptls, (jl_value_t*)v);\n        }\n        if (jl_is_symbol(v)) {\n            arraylist_push(&deser_sym, v);\n            if (for_serialize)\n                ptrhash_put(&symbol_table, v, (void*)((char*)HT_NOTFOUND + ((uintptr_t)SymbolRef << RELOC_TAG_OFFSET) + deser_sym.len));\n        }\n        else {\n            arraylist_push(&deser_tag, v);\n            if (for_serialize)\n                ptrhash_put(&sertag_table, v, (void*)((char*)HT_NOTFOUND + ((uintptr_t)TagRef << RELOC_TAG_OFFSET) + deser_tag.len));\n        }\n    }\n    assert(i + 1 == sizeof(tags) / sizeof(tags[0]));\n    assert(!for_serialize || ptrhash_get(&sertag_table, ptls->root_task) == (char*)HT_NOTFOUND + ((uintptr_t)TagRef << RELOC_TAG_OFFSET) + 3);\n    nsym_tag = deser_sym.len;\n\n    // this also ensures all objects referenced in the code have\n    // references in the system image to their global variable\n    // since codegen knows that some integer boxes are static,\n    // they might not have had a reference anywhere in the code\n    // image other than here\n#define NBOX_C 1024\n    for (i = 0; i < NBOX_C; i++) {\n        jl_value_t *v32 = jl_box_int32(i - NBOX_C / 2);\n        arraylist_push(&deser_tag, v32);\n        if (for_serialize)\n            ptrhash_put(&sertag_table, v32, (void*)((char*)HT_NOTFOUND + ((uintptr_t)TagRef << RELOC_TAG_OFFSET) + deser_tag.len));\n\n        jl_value_t *v64 = jl_box_int64(i - NBOX_C / 2);\n        arraylist_push(&deser_tag, v64);\n        if (for_serialize)\n            ptrhash_put(&sertag_table, v64, (void*)((char*)HT_NOTFOUND + ((uintptr_t)TagRef << RELOC_TAG_OFFSET) + deser_tag.len));\n    }\n    for (i = 0; i < 256; i++) {\n        jl_value_t *vu = jl_box_uint8(i);\n        arraylist_push(&deser_tag, vu);\n        if (for_serialize)\n            ptrhash_put(&sertag_table, vu, (void*)((char*)HT_NOTFOUND + ((uintptr_t)TagRef << RELOC_TAG_OFFSET) + deser_tag.len));\n    }\n\n    if (for_serialize) {\n        for (i = 0; id_to_fptrs[i] != NULL; i++) {\n            ptrhash_put(&fptr_to_id, (void*)(uintptr_t)id_to_fptrs[i], (void*)(i + 2));\n        }\n    }\n\n    arraylist_push(&builtin_typenames, jl_array_typename);\n    arraylist_push(&builtin_typenames, ((jl_datatype_t*)jl_ref_type->body)->name);\n    arraylist_push(&builtin_typenames, jl_pointer_typename);\n    arraylist_push(&builtin_typenames, jl_type_typename);\n    arraylist_push(&builtin_typenames, ((jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)jl_abstractarray_type))->name);\n    arraylist_push(&builtin_typenames, ((jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)jl_densearray_type))->name);\n    arraylist_push(&builtin_typenames, jl_tuple_typename);\n    arraylist_push(&builtin_typenames, jl_vararg_typename);\n    arraylist_push(&builtin_typenames, jl_namedtuple_typename);\n}\n\nstatic void jl_cleanup_serializer2(void)\n{\n    htable_reset(&sertag_table, 0);\n    htable_reset(&symbol_table, 0);\n    htable_reset(&fptr_to_id, 0);\n    htable_reset(&backref_table, 0);\n    arraylist_free(&deser_tag);\n    arraylist_free(&deser_sym);\n    arraylist_free(&builtin_typenames);\n    nsym_tag = 0;\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/src/signals-win.c": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n// Windows\n\n#define sig_stack_size 131072 // 128k reserved for SEGV handling\nstatic BOOL (*pSetThreadStackGuarantee)(PULONG);\n\n// Copied from MINGW_FLOAT_H which may not be found due to a collision with the builtin gcc float.h\n// eventually we can probably integrate this into OpenLibm.\n#if defined(_COMPILER_MINGW_)\nvoid __cdecl __MINGW_NOTHROW _fpreset (void);\nvoid __cdecl __MINGW_NOTHROW fpreset (void);\n#else\nvoid __cdecl _fpreset (void);\nvoid __cdecl fpreset (void);\n#endif\n#define _FPE_INVALID        0x81\n#define _FPE_DENORMAL       0x82\n#define _FPE_ZERODIVIDE     0x83\n#define _FPE_OVERFLOW       0x84\n#define _FPE_UNDERFLOW      0x85\n#define _FPE_INEXACT        0x86\n#define _FPE_UNEMULATED     0x87\n#define _FPE_SQRTNEG        0x88\n#define _FPE_STACKOVERFLOW  0x8a\n#define _FPE_STACKUNDERFLOW 0x8b\n#define _FPE_EXPLICITGEN    0x8c    /* raise( SIGFPE ); */\n\nstatic char *strsignal(int sig)\n{\n    switch (sig) {\n    case SIGINT:         return \"SIGINT\"; break;\n    case SIGILL:         return \"SIGILL\"; break;\n    case SIGABRT_COMPAT: return \"SIGABRT_COMPAT\"; break;\n    case SIGFPE:         return \"SIGFPE\"; break;\n    case SIGSEGV:        return \"SIGSEGV\"; break;\n    case SIGTERM:        return \"SIGTERM\"; break;\n    case SIGBREAK:       return \"SIGBREAK\"; break;\n    case SIGABRT:        return \"SIGABRT\"; break;\n    }\n    return \"?\";\n}\n\nstatic void jl_try_throw_sigint(void)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    jl_safepoint_enable_sigint();\n    jl_wake_libuv();\n    int force = jl_check_force_sigint();\n    if (force || (!ptls->defer_signal && ptls->io_wait)) {\n        jl_safepoint_consume_sigint();\n        if (force)\n            jl_safe_printf(\"WARNING: Force throwing a SIGINT\\n\");\n        // Force a throw\n        jl_clear_force_sigint();\n        jl_throw(jl_interrupt_exception);\n    }\n}\n\nvoid __cdecl crt_sig_handler(int sig, int num)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    CONTEXT Context;\n    switch (sig) {\n    case SIGFPE:\n        fpreset();\n        signal(SIGFPE, (void (__cdecl *)(int))crt_sig_handler);\n        switch(num) {\n        case _FPE_INVALID:\n        case _FPE_OVERFLOW:\n        case _FPE_UNDERFLOW:\n        default:\n            jl_errorf(\"Unexpected FPE Error 0x%X\", num);\n            break;\n        case _FPE_ZERODIVIDE:\n            jl_throw(jl_diverror_exception);\n            break;\n        }\n        break;\n    case SIGINT:\n        signal(SIGINT, (void (__cdecl *)(int))crt_sig_handler);\n        if (!jl_ignore_sigint()) {\n            if (exit_on_sigint)\n                jl_exit(130); // 128 + SIGINT\n            jl_try_throw_sigint();\n        }\n        break;\n    default: // SIGSEGV, (SSIGTERM, IGILL)\n        if (ptls->safe_restore)\n            jl_rethrow();\n        memset(&Context, 0, sizeof(Context));\n        RtlCaptureContext(&Context);\n        if (sig == SIGILL)\n            jl_show_sigill(&Context);\n        jl_critical_error(sig, &Context, ptls->bt_data, &ptls->bt_size);\n        raise(sig);\n    }\n}\n\nvoid restore_signals(void)\n{\n    // turn on ctrl-c handler\n    SetConsoleCtrlHandler(NULL, 0);\n    // see if SetThreadStackGuarantee exists\n    pSetThreadStackGuarantee = (BOOL (*)(PULONG)) jl_dlsym_e(jl_kernel32_handle,\n        \"SetThreadStackGuarantee\");\n}\n\nvoid jl_throw_in_ctx(jl_value_t *excpt, CONTEXT *ctxThread, int bt)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n#if defined(_CPU_X86_64_)\n    DWORD64 Rsp = (ctxThread->Rsp&(DWORD64)-16) - 8;\n#elif defined(_CPU_X86_)\n    DWORD32 Esp = (ctxThread->Esp&(DWORD32)-16) - 4;\n#else\n#error WIN16 not supported :P\n#endif\n    if (!ptls->safe_restore) {\n        assert(excpt != NULL);\n        ptls->bt_size = bt ? rec_backtrace_ctx(ptls->bt_data, JL_MAX_BT_SIZE,\n                                               ctxThread) : 0;\n        ptls->exception_in_transit = excpt;\n    }\n#if defined(_CPU_X86_64_)\n    *(DWORD64*)Rsp = 0;\n    ctxThread->Rsp = Rsp;\n    ctxThread->Rip = (DWORD64)&jl_rethrow;\n#elif defined(_CPU_X86_)\n    *(DWORD32*)Esp = 0;\n    ctxThread->Esp = Esp;\n    ctxThread->Eip = (DWORD)&jl_rethrow;\n#endif\n}\n\nHANDLE hMainThread = INVALID_HANDLE_VALUE;\n\n// Try to throw the exception in the master thread.\nstatic void jl_try_deliver_sigint(void)\n{\n    jl_ptls_t ptls2 = jl_all_tls_states[0];\n    jl_safepoint_enable_sigint();\n    jl_wake_libuv();\n    if ((DWORD)-1 == SuspendThread(hMainThread)) {\n        // error\n        jl_safe_printf(\"error: SuspendThread failed\\n\");\n        return;\n    }\n    int force = jl_check_force_sigint();\n    if (force || (!ptls2->defer_signal && ptls2->io_wait)) {\n        jl_safepoint_consume_sigint();\n        if (force)\n            jl_safe_printf(\"WARNING: Force throwing a SIGINT\\n\");\n        // Force a throw\n        jl_clear_force_sigint();\n        CONTEXT ctxThread;\n        memset(&ctxThread, 0, sizeof(CONTEXT));\n        ctxThread.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;\n        if (!GetThreadContext(hMainThread, &ctxThread)) {\n            // error\n            jl_safe_printf(\"error: GetThreadContext failed\\n\");\n            return;\n        }\n        jl_throw_in_ctx(jl_interrupt_exception, &ctxThread, 1);\n        ctxThread.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;\n        if (!SetThreadContext(hMainThread, &ctxThread)) {\n            jl_safe_printf(\"error: SetThreadContext failed\\n\");\n            // error\n            return;\n        }\n    }\n    if ((DWORD)-1 == ResumeThread(hMainThread)) {\n        jl_safe_printf(\"error: ResumeThread failed\\n\");\n        // error\n        return;\n    }\n}\n\nstatic BOOL WINAPI sigint_handler(DWORD wsig) //This needs winapi types to guarantee __stdcall\n{\n    int sig;\n    //windows signals use different numbers from unix (raise)\n    switch(wsig) {\n        case CTRL_C_EVENT: sig = SIGINT; break;\n        //case CTRL_BREAK_EVENT: sig = SIGTERM; break;\n        // etc.\n        default: sig = SIGTERM; break;\n    }\n    if (!jl_ignore_sigint()) {\n        if (exit_on_sigint)\n            jl_exit(128 + sig); // 128 + SIGINT\n        jl_try_deliver_sigint();\n    }\n    return 1;\n}\n\nstatic LONG WINAPI _exception_handler(struct _EXCEPTION_POINTERS *ExceptionInfo, int in_ctx)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    if (ExceptionInfo->ExceptionRecord->ExceptionFlags == 0) {\n        switch (ExceptionInfo->ExceptionRecord->ExceptionCode) {\n            case EXCEPTION_INT_DIVIDE_BY_ZERO:\n                fpreset();\n                jl_throw_in_ctx(jl_diverror_exception,\n                    ExceptionInfo->ContextRecord,in_ctx);\n                return EXCEPTION_CONTINUE_EXECUTION;\n            case EXCEPTION_STACK_OVERFLOW:\n                jl_throw_in_ctx(jl_stackovf_exception,\n                    ExceptionInfo->ContextRecord,in_ctx&&pSetThreadStackGuarantee);\n                return EXCEPTION_CONTINUE_EXECUTION;\n            case EXCEPTION_ACCESS_VIOLATION:\n                if (jl_addr_is_safepoint(ExceptionInfo->ExceptionRecord->ExceptionInformation[1])) {\n#ifdef JULIA_ENABLE_THREADING\n                    jl_set_gc_and_wait();\n                    // Do not raise sigint on worker thread\n                    if (ptls->tid != 0)\n                        return EXCEPTION_CONTINUE_EXECUTION;\n#endif\n                    if (ptls->defer_signal) {\n                        jl_safepoint_defer_sigint();\n                    }\n                    else if (jl_safepoint_consume_sigint()) {\n                        jl_clear_force_sigint();\n                        jl_throw_in_ctx(jl_interrupt_exception,\n                                        ExceptionInfo->ContextRecord, in_ctx);\n                    }\n                    return EXCEPTION_CONTINUE_EXECUTION;\n                }\n                if (ptls->safe_restore) {\n                    jl_throw_in_ctx(NULL, ExceptionInfo->ContextRecord, in_ctx);\n                    return EXCEPTION_CONTINUE_EXECUTION;\n                }\n                if (ExceptionInfo->ExceptionRecord->ExceptionInformation[0] == 1) { // writing to read-only memory (e.g. mmap)\n                    jl_throw_in_ctx(jl_readonlymemory_exception,\n                        ExceptionInfo->ContextRecord,in_ctx);\n                    return EXCEPTION_CONTINUE_EXECUTION;\n                }\n        }\n        if (ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_ILLEGAL_INSTRUCTION) {\n            jl_safe_printf(\"\\n\");\n            jl_show_sigill(ExceptionInfo->ContextRecord);\n        }\n        jl_safe_printf(\"\\nPlease submit a bug report with steps to reproduce this fault, and any error messages that follow (in their entirety). Thanks.\\nException: \");\n        switch (ExceptionInfo->ExceptionRecord->ExceptionCode) {\n            case EXCEPTION_ACCESS_VIOLATION:\n                jl_safe_printf(\"EXCEPTION_ACCESS_VIOLATION\"); break;\n            case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n                jl_safe_printf(\"EXCEPTION_ARRAY_BOUNDS_EXCEEDED\"); break;\n            case EXCEPTION_BREAKPOINT:\n                jl_safe_printf(\"EXCEPTION_BREAKPOINT\"); break;\n            case EXCEPTION_DATATYPE_MISALIGNMENT:\n                jl_safe_printf(\"EXCEPTION_DATATYPE_MISALIGNMENT\"); break;\n            case EXCEPTION_FLT_DENORMAL_OPERAND:\n                jl_safe_printf(\"EXCEPTION_FLT_DENORMAL_OPERAND\"); break;\n            case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n                jl_safe_printf(\"EXCEPTION_FLT_DIVIDE_BY_ZERO\"); break;\n            case EXCEPTION_FLT_INEXACT_RESULT:\n                jl_safe_printf(\"EXCEPTION_FLT_INEXACT_RESULT\"); break;\n            case EXCEPTION_FLT_INVALID_OPERATION:\n                jl_safe_printf(\"EXCEPTION_FLT_INVALID_OPERATION\"); break;\n            case EXCEPTION_FLT_OVERFLOW:\n                jl_safe_printf(\"EXCEPTION_FLT_OVERFLOW\"); break;\n            case EXCEPTION_FLT_STACK_CHECK:\n                jl_safe_printf(\"EXCEPTION_FLT_STACK_CHECK\"); break;\n            case EXCEPTION_FLT_UNDERFLOW:\n                jl_safe_printf(\"EXCEPTION_FLT_UNDERFLOW\"); break;\n            case EXCEPTION_ILLEGAL_INSTRUCTION:\n                jl_safe_printf(\"EXCEPTION_ILLEGAL_INSTRUCTION\"); break;\n            case EXCEPTION_IN_PAGE_ERROR:\n                jl_safe_printf(\"EXCEPTION_IN_PAGE_ERROR\"); break;\n            case EXCEPTION_INT_DIVIDE_BY_ZERO:\n                jl_safe_printf(\"EXCEPTION_INT_DIVIDE_BY_ZERO\"); break;\n            case EXCEPTION_INT_OVERFLOW:\n                jl_safe_printf(\"EXCEPTION_INT_OVERFLOW\"); break;\n            case EXCEPTION_INVALID_DISPOSITION:\n                jl_safe_printf(\"EXCEPTION_INVALID_DISPOSITION\"); break;\n            case EXCEPTION_NONCONTINUABLE_EXCEPTION:\n                jl_safe_printf(\"EXCEPTION_NONCONTINUABLE_EXCEPTION\"); break;\n            case EXCEPTION_PRIV_INSTRUCTION:\n                jl_safe_printf(\"EXCEPTION_PRIV_INSTRUCTION\"); break;\n            case EXCEPTION_SINGLE_STEP:\n                jl_safe_printf(\"EXCEPTION_SINGLE_STEP\"); break;\n            case EXCEPTION_STACK_OVERFLOW:\n                jl_safe_printf(\"EXCEPTION_STACK_OVERFLOW\"); break;\n            default:\n                jl_safe_printf(\"UNKNOWN\"); break;\n        }\n        jl_safe_printf(\" at 0x%Ix -- \", (size_t)ExceptionInfo->ExceptionRecord->ExceptionAddress);\n        jl_gdblookup((uintptr_t)ExceptionInfo->ExceptionRecord->ExceptionAddress);\n\n        jl_critical_error(0, ExceptionInfo->ContextRecord,\n                          ptls->bt_data, &ptls->bt_size);\n        static int recursion = 0;\n        if (recursion++)\n            exit(1);\n        else\n            jl_exit(1);\n    }\n    return EXCEPTION_CONTINUE_SEARCH;\n}\n\nstatic LONG WINAPI exception_handler(struct _EXCEPTION_POINTERS *ExceptionInfo)\n{\n    return _exception_handler(ExceptionInfo,1);\n}\n\n#if defined(_CPU_X86_64_)\nJL_DLLEXPORT EXCEPTION_DISPOSITION __julia_personality(\n        PEXCEPTION_RECORD ExceptionRecord,\n        void *EstablisherFrame,\n        PCONTEXT ContextRecord,\n        void *DispatcherContext)\n{\n    EXCEPTION_POINTERS ExceptionInfo;\n    ExceptionInfo.ExceptionRecord = ExceptionRecord;\n    ExceptionInfo.ContextRecord = ContextRecord;\n\n    EXCEPTION_DISPOSITION rval;\n    switch (_exception_handler(&ExceptionInfo,1)) {\n        case EXCEPTION_CONTINUE_EXECUTION:\n            rval = ExceptionContinueExecution; break;\n        case EXCEPTION_CONTINUE_SEARCH:\n            rval = ExceptionContinueSearch; break;\n#ifndef _MSC_VER\n        case EXCEPTION_EXECUTE_HANDLER:\n            rval = ExceptionExecuteHandler; break;\n#endif\n    }\n\n    return rval;\n}\n#endif\n\nJL_DLLEXPORT void jl_install_sigint_handler(void)\n{\n    SetConsoleCtrlHandler((PHANDLER_ROUTINE)sigint_handler,1);\n}\n\nvolatile HANDLE hBtThread = 0;\nstatic DWORD WINAPI profile_bt( LPVOID lparam )\n{\n    // Note: illegal to use jl_* functions from this thread\n\n    TIMECAPS tc;\n    if (MMSYSERR_NOERROR!=timeGetDevCaps(&tc, sizeof(tc))) {\n        fputs(\"failed to get timer resolution\",stderr);\n        hBtThread = 0;\n        return 0;\n    }\n    while (1) {\n        if (running && bt_size_cur < bt_size_max) {\n            DWORD timeout = nsecprof/GIGA;\n            timeout = min(max(timeout,tc.wPeriodMin*2),tc.wPeriodMax/2);\n            Sleep(timeout);\n            if ((DWORD)-1 == SuspendThread(hMainThread)) {\n                fputs(\"failed to suspend main thread. aborting profiling.\",stderr);\n                break;\n            }\n            CONTEXT ctxThread;\n            memset(&ctxThread, 0, sizeof(CONTEXT));\n            ctxThread.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;\n            if (!GetThreadContext(hMainThread, &ctxThread)) {\n                fputs(\"failed to get context from main thread. aborting profiling.\",stderr);\n                break;\n            }\n            // Get backtrace data\n            bt_size_cur += rec_backtrace_ctx((uintptr_t*)bt_data_prof + bt_size_cur,\n                bt_size_max - bt_size_cur - 1, &ctxThread);\n            // Mark the end of this block with 0\n            bt_data_prof[bt_size_cur] = 0;\n            bt_size_cur++;\n            if ((DWORD)-1 == ResumeThread(hMainThread)) {\n                fputs(\"failed to resume main thread! aborting.\",stderr);\n                gc_debug_critical_error();\n                abort();\n            }\n        }\n        else {\n            SuspendThread(GetCurrentThread());\n        }\n    }\n    hBtThread = 0;\n    return 0;\n}\n\nJL_DLLEXPORT int jl_profile_start_timer(void)\n{\n    running = 1;\n    if (hBtThread == 0) {\n        hBtThread = CreateThread(\n            NULL,                   // default security attributes\n            0,                      // use default stack size\n            profile_bt,            // thread function name\n            0,                      // argument to thread function\n            0,                      // use default creation flags\n            0);                     // returns the thread identifier\n        (void)SetThreadPriority(hBtThread,THREAD_PRIORITY_ABOVE_NORMAL);\n    }\n    else {\n        if ((DWORD)-1 == ResumeThread(hBtThread)) {\n            fputs(\"failed to resume profiling thread.\",stderr);\n            return -2;\n        }\n    }\n    return (hBtThread != NULL ? 0 : -1);\n}\nJL_DLLEXPORT void jl_profile_stop_timer(void)\n{\n    running = 0;\n}\n\nvoid jl_install_default_signal_handlers(void)\n{\n    if (signal(SIGFPE, (void (__cdecl *)(int))crt_sig_handler) == SIG_ERR) {\n        jl_error(\"fatal error: Couldn't set SIGFPE\");\n    }\n    if (signal(SIGILL, (void (__cdecl *)(int))crt_sig_handler) == SIG_ERR) {\n        jl_error(\"fatal error: Couldn't set SIGILL\");\n    }\n    if (signal(SIGINT, (void (__cdecl *)(int))crt_sig_handler) == SIG_ERR) {\n        jl_error(\"fatal error: Couldn't set SIGINT\");\n    }\n    if (signal(SIGSEGV, (void (__cdecl *)(int))crt_sig_handler) == SIG_ERR) {\n        jl_error(\"fatal error: Couldn't set SIGSEGV\");\n    }\n    if (signal(SIGTERM, (void (__cdecl *)(int))crt_sig_handler) == SIG_ERR) {\n        jl_error(\"fatal error: Couldn't set SIGTERM\");\n    }\n    if (signal(SIGABRT, (void (__cdecl *)(int))crt_sig_handler) == SIG_ERR) {\n        jl_error(\"fatal error: Couldn't set SIGABRT\");\n    }\n    SetUnhandledExceptionFilter(exception_handler);\n}\n\nvoid jl_install_thread_signal_handler(jl_ptls_t ptls)\n{\n    (void)ptls;\n    // Ensure the stack overflow handler has enough space to collect the backtrace\n    ULONG StackSizeInBytes = sig_stack_size;\n    if (pSetThreadStackGuarantee) {\n        if (!pSetThreadStackGuarantee(&StackSizeInBytes)) {\n            pSetThreadStackGuarantee = NULL;\n        }\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/src/signals-mach.c": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n#include <mach/clock.h>\n#include <mach/clock_types.h>\n#include <mach/clock_reply.h>\n#include <mach/mach_traps.h>\n#include <mach/task.h>\n#include <mach/mig_errors.h>\n#include <AvailabilityMacros.h>\n\n#ifdef MAC_OS_X_VERSION_10_9\n#include <sys/_types/_ucontext64.h>\n#else\n#define __need_ucontext64_t\n#include <sys/_structs.h>\n#endif\n\n#include \"julia_assert.h\"\n\nstatic void attach_exception_port(thread_port_t thread, int segv_only);\n\n#ifdef JULIA_ENABLE_THREADING\n// low 16 bits are the thread id, the next 8 bits are the original gc_state\nstatic arraylist_t suspended_threads;\nvoid jl_mach_gc_end(void)\n{\n    // Requires the safepoint lock to be held\n    for (size_t i = 0;i < suspended_threads.len;i++) {\n        uintptr_t item = (uintptr_t)suspended_threads.items[i];\n        int16_t tid = (int16_t)item;\n        int8_t gc_state = (int8_t)(item >> 8);\n        jl_ptls_t ptls2 = jl_all_tls_states[tid];\n        jl_atomic_store_release(&ptls2->gc_state, gc_state);\n        thread_resume(pthread_mach_thread_np(ptls2->system_id));\n    }\n    suspended_threads.len = 0;\n}\n\n// Suspend the thread and return `1` if the GC is running.\n// Otherwise return `0`\nstatic int jl_mach_gc_wait(jl_ptls_t ptls2,\n                           mach_port_t thread, int16_t tid)\n{\n    jl_mutex_lock_nogc(&safepoint_lock);\n    if (!jl_gc_running) {\n        // GC is done before we get the message or the safepoint is enabled\n        // for SIGINT.\n        jl_mutex_unlock_nogc(&safepoint_lock);\n        return 0;\n    }\n    // Otherwise, set the gc state of the thread, suspend and record it\n    int8_t gc_state = ptls2->gc_state;\n    jl_atomic_store_release(&ptls2->gc_state, JL_GC_STATE_WAITING);\n    uintptr_t item = tid | (((uintptr_t)gc_state) << 16);\n    arraylist_push(&suspended_threads, (void*)item);\n    thread_suspend(thread);\n    jl_mutex_unlock_nogc(&safepoint_lock);\n    return 1;\n}\n#endif\n\nstatic mach_port_t segv_port = 0;\n\nextern boolean_t exc_server(mach_msg_header_t *, mach_msg_header_t *);\n\n#define STR(x) #x\n#define XSTR(x) STR(x)\n#define HANDLE_MACH_ERROR(msg, retval) \\\n    if (retval != KERN_SUCCESS) { mach_error(msg XSTR(: __FILE__:__LINE__:), (retval)); jl_exit(1); }\n\nvoid *mach_segv_listener(void *arg)\n{\n    (void)arg;\n    while (1) {\n        int ret = mach_msg_server(exc_server, 2048, segv_port, MACH_MSG_TIMEOUT_NONE);\n        jl_safe_printf(\"mach_msg_server: %s\\n\", mach_error_string(ret));\n        jl_exit(128 + SIGSEGV);\n    }\n}\n\nstatic void allocate_segv_handler()\n{\n#ifdef JULIA_ENABLE_THREADING\n    arraylist_new(&suspended_threads, jl_n_threads);\n#endif\n    pthread_t thread;\n    pthread_attr_t attr;\n    kern_return_t ret;\n    mach_port_t self = mach_task_self();\n    ret = mach_port_allocate(self, MACH_PORT_RIGHT_RECEIVE, &segv_port);\n    HANDLE_MACH_ERROR(\"mach_port_allocate\",ret);\n    ret = mach_port_insert_right(self, segv_port, segv_port, MACH_MSG_TYPE_MAKE_SEND);\n    HANDLE_MACH_ERROR(\"mach_port_insert_right\",ret);\n    // Alright, create a thread to serve as the listener for exceptions\n    if (pthread_attr_init(&attr) != 0) {\n        jl_error(\"pthread_attr_init failed\");\n    }\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n    if (pthread_create(&thread, &attr, mach_segv_listener, NULL) != 0) {\n        jl_error(\"pthread_create failed\");\n    }\n    pthread_attr_destroy(&attr);\n    for (int16_t tid = 0;tid < jl_n_threads;tid++) {\n        attach_exception_port(pthread_mach_thread_np(jl_all_tls_states[tid]->system_id), 0);\n    }\n}\n\n#ifdef LIBOSXUNWIND\nvolatile mach_port_t mach_profiler_thread = 0;\nstatic kern_return_t profiler_segv_handler\n                (mach_port_t                          exception_port,\n                 mach_port_t                                  thread,\n                 mach_port_t                                    task,\n                 exception_type_t                          exception,\n                 exception_data_t                               code,\n                 mach_msg_type_number_t                   code_count);\n#endif\n\nenum x86_trap_flags {\n    USER_MODE = 0x4,\n    WRITE_FAULT = 0x2,\n    PAGE_PRESENT = 0x1\n};\n\nstatic void jl_call_in_state(jl_ptls_t ptls2, x86_thread_state64_t *state,\n                             void (*fptr)(void))\n{\n    uint64_t rsp = (uint64_t)ptls2->signal_stack + sig_stack_size;\n    assert(rsp % 16 == 0);\n\n    // push (null) $RIP onto the stack\n    rsp -= sizeof(void*);\n    *(void**)rsp = NULL;\n\n    state->__rsp = rsp; // set stack pointer\n    state->__rip = (uint64_t)fptr; // \"call\" the function\n}\n\nstatic void jl_throw_in_thread(int tid, mach_port_t thread, jl_value_t *exception)\n{\n    unsigned int count = MACHINE_THREAD_STATE_COUNT;\n    x86_thread_state64_t state;\n    kern_return_t ret = thread_get_state(thread, x86_THREAD_STATE64, (thread_state_t)&state, &count);\n    HANDLE_MACH_ERROR(\"thread_get_state\", ret);\n    jl_ptls_t ptls2 = jl_all_tls_states[tid];\n    if (!ptls2->safe_restore) {\n        assert(exception);\n        ptls2->bt_size = rec_backtrace_ctx(ptls2->bt_data, JL_MAX_BT_SIZE,\n                                           (bt_context_t*)&state);\n        ptls2->exception_in_transit = exception;\n    }\n    jl_call_in_state(ptls2, &state, &jl_rethrow);\n    ret = thread_set_state(thread, x86_THREAD_STATE64,\n                           (thread_state_t)&state, count);\n    HANDLE_MACH_ERROR(\"thread_set_state\",ret);\n}\n\n//exc_server uses dlsym to find symbol\nJL_DLLEXPORT\nkern_return_t catch_exception_raise(mach_port_t            exception_port,\n                                    mach_port_t            thread,\n                                    mach_port_t            task,\n                                    exception_type_t       exception,\n                                    exception_data_t       code,\n                                    mach_msg_type_number_t code_count)\n{\n    unsigned int count = MACHINE_THREAD_STATE_COUNT;\n    unsigned int exc_count = X86_EXCEPTION_STATE64_COUNT;\n    x86_exception_state64_t exc_state;\n    x86_thread_state64_t state;\n#ifdef LIBOSXUNWIND\n    if (thread == mach_profiler_thread) {\n        return profiler_segv_handler(exception_port, thread, task, exception, code, code_count);\n    }\n#endif\n    int16_t tid;\n#ifdef JULIA_ENABLE_THREADING\n    jl_ptls_t ptls2 = NULL;\n    for (tid = 0;tid < jl_n_threads;tid++) {\n        jl_ptls_t _ptls2 = jl_all_tls_states[tid];\n        if (pthread_mach_thread_np(_ptls2->system_id) == thread) {\n            ptls2 = _ptls2;\n            break;\n        }\n    }\n    if (!ptls2) {\n        // We don't know about this thread, let the kernel try another handler\n        // instead. This shouldn't actually happen since we only register the\n        // handler for the threads we know about.\n        jl_safe_printf(\"ERROR: Exception handler triggered on unmanaged thread.\\n\");\n        return KERN_INVALID_ARGUMENT;\n    }\n#else\n    jl_ptls_t ptls2 = &jl_tls_states;\n    tid = 0;\n#endif\n    if (exception == EXC_ARITHMETIC) {\n        jl_throw_in_thread(tid, thread, jl_diverror_exception);\n        return KERN_SUCCESS;\n    }\n    assert(exception == EXC_BAD_ACCESS);\n    kern_return_t ret = thread_get_state(thread, x86_EXCEPTION_STATE64, (thread_state_t)&exc_state, &exc_count);\n    HANDLE_MACH_ERROR(\"thread_get_state\", ret);\n    uint64_t fault_addr = exc_state.__faultvaddr;\n    if (jl_addr_is_safepoint(fault_addr)) {\n#ifdef JULIA_ENABLE_THREADING\n        if (jl_mach_gc_wait(ptls2, thread, tid))\n            return KERN_SUCCESS;\n        if (ptls2->tid != 0)\n            return KERN_SUCCESS;\n#endif\n        if (ptls2->defer_signal) {\n            jl_safepoint_defer_sigint();\n        }\n        else if (jl_safepoint_consume_sigint()) {\n            jl_clear_force_sigint();\n            jl_throw_in_thread(tid, thread, jl_interrupt_exception);\n        }\n        return KERN_SUCCESS;\n    }\n    if (ptls2->safe_restore) {\n        jl_throw_in_thread(tid, thread, jl_stackovf_exception);\n        return KERN_SUCCESS;\n    }\n#ifdef SEGV_EXCEPTION\n    if (1) {\n#else\n    if (msync((void*)(fault_addr & ~(jl_page_size - 1)), 1, MS_ASYNC) == 0) { // check if this was a valid address\n#endif\n        jl_value_t *excpt;\n        if (is_addr_on_stack(ptls2, (void*)fault_addr)) {\n            excpt = jl_stackovf_exception;\n        }\n#ifdef SEGV_EXCEPTION\n        else if (msync((void*)(fault_addr & ~(jl_page_size - 1)), 1, MS_ASYNC) != 0) {\n            // no page mapped at this address\n            excpt = jl_segv_exception;\n        }\n#endif\n        else {\n            if (!(exc_state.__err & WRITE_FAULT))\n                return KERN_INVALID_ARGUMENT; // rethrow the SEGV since it wasn't an error with writing to read-only memory\n            excpt = jl_readonlymemory_exception;\n        }\n        jl_throw_in_thread(tid, thread, excpt);\n\n        return KERN_SUCCESS;\n    }\n    else {\n        kern_return_t ret = thread_get_state(thread, x86_THREAD_STATE64, (thread_state_t)&state, &count);\n        HANDLE_MACH_ERROR(\"thread_get_state\", ret);\n        jl_critical_error(SIGSEGV, (unw_context_t*)&state,\n                          ptls2->bt_data, &ptls2->bt_size);\n        return KERN_INVALID_ARGUMENT;\n    }\n}\n\nstatic void attach_exception_port(thread_port_t thread, int segv_only)\n{\n    kern_return_t ret;\n    // http://www.opensource.apple.com/source/xnu/xnu-2782.1.97/osfmk/man/thread_set_exception_ports.html\n    exception_mask_t mask = EXC_MASK_BAD_ACCESS;\n    if (!segv_only)\n        mask |= EXC_MASK_ARITHMETIC;\n    ret = thread_set_exception_ports(thread, mask, segv_port, EXCEPTION_DEFAULT, MACHINE_THREAD_STATE);\n    HANDLE_MACH_ERROR(\"thread_set_exception_ports\", ret);\n}\n\nstatic void jl_thread_suspend_and_get_state(int tid, unw_context_t **ctx)\n{\n    jl_ptls_t ptls2 = jl_all_tls_states[tid];\n    mach_port_t tid_port = pthread_mach_thread_np(ptls2->system_id);\n\n    kern_return_t ret = thread_suspend(tid_port);\n    HANDLE_MACH_ERROR(\"thread_suspend\", ret);\n\n    // Do the actual sampling\n    unsigned int count = MACHINE_THREAD_STATE_COUNT;\n    static unw_context_t state;\n    memset(&state, 0, sizeof(unw_context_t));\n\n    // Get the state of the suspended thread\n    ret = thread_get_state(tid_port, x86_THREAD_STATE64, (thread_state_t)&state, &count);\n\n    // Initialize the unwind context with the suspend thread's state\n    *ctx = &state;\n}\n\nstatic void jl_thread_resume(int tid, int sig)\n{\n    jl_ptls_t ptls2 = jl_all_tls_states[tid];\n    mach_port_t thread = pthread_mach_thread_np(ptls2->system_id);\n    kern_return_t ret = thread_resume(thread);\n    HANDLE_MACH_ERROR(\"thread_resume\", ret);\n}\n\n// Throw jl_interrupt_exception if the master thread is in a signal async region\n// or if SIGINT happens too often.\nstatic void jl_try_deliver_sigint(void)\n{\n    jl_ptls_t ptls2 = jl_all_tls_states[0];\n    mach_port_t thread = pthread_mach_thread_np(ptls2->system_id);\n\n    kern_return_t ret = thread_suspend(thread);\n    HANDLE_MACH_ERROR(\"thread_suspend\", ret);\n\n    // This aborts `sleep` and other syscalls.\n    ret = thread_abort(thread);\n    HANDLE_MACH_ERROR(\"thread_abort\", ret);\n\n    jl_safepoint_enable_sigint();\n    int force = jl_check_force_sigint();\n    if (force || (!ptls2->defer_signal && ptls2->io_wait)) {\n        jl_safepoint_consume_sigint();\n        if (force)\n            jl_safe_printf(\"WARNING: Force throwing a SIGINT\\n\");\n        jl_clear_force_sigint();\n        jl_throw_in_thread(0, thread, jl_interrupt_exception);\n    }\n    else {\n        jl_wake_libuv();\n    }\n\n    ret = thread_resume(thread);\n    HANDLE_MACH_ERROR(\"thread_resume\", ret);\n}\n\nstatic void jl_exit_thread0(int exitstate)\n{\n    jl_ptls_t ptls2 = jl_all_tls_states[0];\n    mach_port_t thread = pthread_mach_thread_np(ptls2->system_id);\n    kern_return_t ret = thread_suspend(thread);\n    HANDLE_MACH_ERROR(\"thread_suspend\", ret);\n\n    // This aborts `sleep` and other syscalls.\n    ret = thread_abort(thread);\n    HANDLE_MACH_ERROR(\"thread_abort\", ret);\n\n    unsigned int count = MACHINE_THREAD_STATE_COUNT;\n    x86_thread_state64_t state;\n    ret = thread_get_state(thread, x86_THREAD_STATE64,\n                           (thread_state_t)&state, &count);\n\n    void (*exit_func)(int) = &_exit;\n    if (thread0_exit_count <= 1) {\n        exit_func = &jl_exit;\n    }\n    else if (thread0_exit_count == 2) {\n        exit_func = &exit;\n    }\n\n    // First integer argument. Not portable but good enough =)\n    state.__rdi = exitstate;\n    jl_call_in_state(ptls2, &state, (void (*)(void))exit_func);\n    ret = thread_set_state(thread, x86_THREAD_STATE64,\n                           (thread_state_t)&state, count);\n    HANDLE_MACH_ERROR(\"thread_set_state\",ret);\n\n    ret = thread_resume(thread);\n    HANDLE_MACH_ERROR(\"thread_resume\", ret);\n}\n\nstatic int profile_started = 0;\nmach_timespec_t timerprof;\nstatic pthread_t profiler_thread;\nclock_serv_t clk;\nstatic mach_port_t profile_port = 0;\n\n#ifdef LIBOSXUNWIND\nvolatile static int forceDwarf = -2;\nstatic unw_context_t profiler_uc;\n\nstatic kern_return_t profiler_segv_handler\n                (mach_port_t                          exception_port,\n                 mach_port_t                                  thread,\n                 mach_port_t                                    task,\n                 exception_type_t                          exception,\n                 exception_data_t                               code,\n                 mach_msg_type_number_t                   code_count)\n{\n    assert(thread == mach_profiler_thread);\n    x86_thread_state64_t state;\n\n    // Not currently unwinding. Raise regular segfault\n    if (forceDwarf == -2)\n        return KERN_INVALID_ARGUMENT;\n\n    if (forceDwarf == 0)\n        forceDwarf = 1;\n    else\n        forceDwarf = -1;\n\n    unsigned int count = MACHINE_THREAD_STATE_COUNT;\n\n    thread_get_state(thread, x86_THREAD_STATE64, (thread_state_t)&state, &count);\n\n    // don't change cs fs gs rflags\n    uint64_t cs = state.__cs;\n    uint64_t fs = state.__fs;\n    uint64_t gs = state.__gs;\n    uint64_t rflags = state.__rflags;\n\n    memcpy(&state, &profiler_uc, sizeof(x86_thread_state64_t));\n\n    state.__cs = cs;\n    state.__fs = fs;\n    state.__gs = gs;\n    state.__rflags = rflags;\n\n    kern_return_t ret = thread_set_state(thread, x86_THREAD_STATE64, (thread_state_t)&state, count);\n    HANDLE_MACH_ERROR(\"thread_set_state\", ret);\n\n    return KERN_SUCCESS;\n}\n#endif\n\nvoid *mach_profile_listener(void *arg)\n{\n    (void)arg;\n    int i;\n    const int max_size = 512;\n    attach_exception_port(mach_thread_self(), 1);\n#ifdef LIBOSXUNWIND\n    mach_profiler_thread = mach_thread_self();\n#endif\n    mig_reply_error_t *bufRequest = (mig_reply_error_t *) malloc(max_size);\n    while (1) {\n        kern_return_t ret = mach_msg(&bufRequest->Head, MACH_RCV_MSG,\n                                     0, max_size, profile_port,\n                                     MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);\n        HANDLE_MACH_ERROR(\"mach_msg\", ret);\n        // sample each thread, round-robin style in reverse order\n        // (so that thread zero gets notified last)\n        for (i = jl_n_threads; i-- > 0; ) {\n            // if there is no space left, break early\n            if (bt_size_cur >= bt_size_max - 1)\n                break;\n\n            unw_context_t *uc;\n            jl_thread_suspend_and_get_state(i, &uc);\n\n#ifdef LIBOSXUNWIND\n            /*\n             *  Unfortunately compact unwind info is incorrectly generated for quite a number of\n             *  libraries by quite a large number of compilers. We can fall back to DWARF unwind info\n             *  in some cases, but in quite a number of cases (especially libraries not compiled in debug\n             *  mode, only the compact unwind info may be available). Even more unfortunately, there is no\n             *  way to detect such bogus compact unwind info (other than noticing the resulting segfault).\n             *  What we do here is ugly, but necessary until the compact unwind info situation improves.\n             *  We try to use the compact unwind info and if that results in a segfault, we retry with DWARF info.\n             *  Note that in a small number of cases this may result in bogus stack traces, but at least the topmost\n             *  entry will always be correct, and the number of cases in which this is an issue is rather small.\n             *  Other than that, this implementation is not incorrect as the other thread is paused while we are profiling\n             *  and during stack unwinding we only ever read memory, but never write it.\n             */\n\n            forceDwarf = 0;\n            unw_getcontext(&profiler_uc); // will resume from this point if the next lines segfault at any point\n\n            if (forceDwarf == 0) {\n                // Save the backtrace\n                bt_size_cur += rec_backtrace_ctx((uintptr_t*)bt_data_prof + bt_size_cur, bt_size_max - bt_size_cur - 1, uc);\n            }\n            else if (forceDwarf == 1) {\n                bt_size_cur += rec_backtrace_ctx_dwarf((uintptr_t*)bt_data_prof + bt_size_cur, bt_size_max - bt_size_cur - 1, uc);\n            }\n            else if (forceDwarf == -1) {\n                jl_safe_printf(\"WARNING: profiler attempt to access an invalid memory location\\n\");\n            }\n\n            forceDwarf = -2;\n#else\n            bt_size_cur += rec_backtrace_ctx((uintptr_t*)bt_data_prof + bt_size_cur, bt_size_max - bt_size_cur - 1, uc);\n#endif\n\n            // Mark the end of this block with 0\n            bt_data_prof[bt_size_cur++] = 0;\n\n            // We're done! Resume the thread.\n            jl_thread_resume(i, 0);\n\n            if (running) {\n                // Reset the alarm\n                kern_return_t ret = clock_alarm(clk, TIME_RELATIVE, timerprof, profile_port);\n                HANDLE_MACH_ERROR(\"clock_alarm\", ret)\n            }\n        }\n    }\n}\n\nJL_DLLEXPORT int jl_profile_start_timer(void)\n{\n    kern_return_t ret;\n    if (!profile_started) {\n        mach_port_t self = mach_task_self();\n\n        ret = host_get_clock_service(mach_host_self(), SYSTEM_CLOCK, (clock_serv_t *)&clk);\n        HANDLE_MACH_ERROR(\"host_get_clock_service\", ret);\n\n        ret = mach_port_allocate(self, MACH_PORT_RIGHT_RECEIVE, &profile_port);\n        HANDLE_MACH_ERROR(\"mach_port_allocate\", ret);\n\n        // Alright, create a thread to serve as the listener for exceptions\n        pthread_attr_t attr;\n        if (pthread_attr_init(&attr) != 0) {\n            jl_error(\"pthread_attr_init failed\");\n        }\n        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n        if (pthread_create(&profiler_thread, &attr, mach_profile_listener, NULL) != 0) {\n            jl_error(\"pthread_create failed\");\n        }\n        pthread_attr_destroy(&attr);\n\n        profile_started = 1;\n    }\n\n    timerprof.tv_sec = nsecprof/GIGA;\n    timerprof.tv_nsec = nsecprof%GIGA;\n\n    running = 1;\n    ret = clock_alarm(clk, TIME_RELATIVE, timerprof, profile_port);\n    HANDLE_MACH_ERROR(\"clock_alarm\", ret);\n\n    return 0;\n}\n\nJL_DLLEXPORT void jl_profile_stop_timer(void)\n{\n    running = 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/src/sys.c": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n/*\n  sys.c\n  I/O and operating system utility functions\n*/\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <fcntl.h>\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n\n#ifdef _OS_WINDOWS_\n#include <psapi.h>\n#else\n#include <unistd.h>\n#if !defined(_SC_NPROCESSORS_ONLN) || defined(_OS_FREEBSD_) || defined(_OS_DARWIN_)\n// try secondary location for _SC_NPROCESSORS_ONLN, or for HW_AVAILCPU on BSDs\n#include <sys/sysctl.h>\n#endif\n#include <sys/wait.h>\n#include <sys/ptrace.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#endif\n\n#ifndef _OS_WINDOWS_\n// for getrusage\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#endif\n\n#ifdef __APPLE__\n#include <mach-o/dyld.h>\n#include <mach-o/nlist.h>\n#include <sys/types.h> // for jl_raise_debugger\n#elif !defined(_OS_WINDOWS_)\n#include <link.h>\n#endif\n\n#ifdef __SSE__\n#include <xmmintrin.h>\n#endif\n\n#if defined _MSC_VER\n#include <io.h>\n#include <intrin.h>\n#endif\n\n#ifdef JL_MSAN_ENABLED\n#include <sanitizer/msan_interface.h>\n#endif\n\n#include \"julia_assert.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(_OS_WINDOWS_) && !defined(_COMPILER_MINGW_)\nJL_DLLEXPORT char *dirname(char *);\n#else\n#include <libgen.h>\n#endif\n\nJL_DLLEXPORT uint32_t jl_getutf8(ios_t *s)\n{\n    uint32_t wc=0;\n    ios_getutf8(s, &wc);\n    return wc;\n}\n\nJL_DLLEXPORT int jl_sizeof_uv_mutex(void) { return sizeof(uv_mutex_t); }\nJL_DLLEXPORT int jl_sizeof_off_t(void) { return sizeof(off_t); }\n#ifndef _OS_WINDOWS_\nJL_DLLEXPORT int jl_sizeof_mode_t(void) { return sizeof(mode_t); }\nJL_DLLEXPORT int jl_ftruncate(int fd, int64_t length)\n{\n    return ftruncate(fd, (off_t)length);\n}\nJL_DLLEXPORT int64_t jl_lseek(int fd, int64_t offset, int whence)\n{\n    return lseek(fd, (off_t)offset, whence);\n}\nJL_DLLEXPORT ssize_t jl_pwrite(int fd, const void *buf, size_t count, int64_t offset)\n{\n    return pwrite(fd, buf, count, (off_t)offset);\n}\nJL_DLLEXPORT void *jl_mmap(void *addr, size_t length, int prot, int flags,\n                           int fd, int64_t offset)\n{\n    return mmap(addr, length, prot, flags, fd, (off_t)offset);\n}\n#else\nJL_DLLEXPORT int64_t jl_lseek(HANDLE fd, int64_t offset, int whence)\n{\n    LARGE_INTEGER tell;\n    tell.QuadPart = offset;\n    if (SetFilePointerEx(fd, tell, &tell, whence) == 0)\n        return -1;\n    return tell.QuadPart;\n}\n#endif\nJL_DLLEXPORT int jl_sizeof_ios_t(void) { return sizeof(ios_t); }\n\nJL_DLLEXPORT long jl_ios_fd(ios_t *s) { return s->fd; }\n\nJL_DLLEXPORT int32_t jl_nb_available(ios_t *s)\n{\n    return (int32_t)(s->size - s->bpos);\n}\n\n// --- dir/file stuff ---\n\nJL_DLLEXPORT int jl_sizeof_uv_fs_t(void) { return sizeof(uv_fs_t); }\nJL_DLLEXPORT void jl_uv_fs_req_cleanup(uv_fs_t *req) { uv_fs_req_cleanup(req); }\nJL_DLLEXPORT char *jl_uv_fs_t_ptr(uv_fs_t *req) { return (char*)req->ptr; }\nJL_DLLEXPORT ssize_t jl_uv_fs_result(uv_fs_t *f) { return f->result; }\n\n// --- stat ---\nJL_DLLEXPORT int jl_sizeof_stat(void) { return sizeof(uv_stat_t); }\n\nJL_DLLEXPORT int32_t jl_stat(const char *path, char *statbuf)\n{\n    uv_fs_t req;\n    int ret;\n\n    // Ideally one would use the statbuf for the storage in req, but\n    // it's not clear that this is possible using libuv\n    ret = uv_fs_stat(uv_default_loop(), &req, path, NULL);\n    if (ret == 0)\n        memcpy(statbuf, req.ptr, sizeof(uv_stat_t));\n    uv_fs_req_cleanup(&req);\n    return ret;\n}\n\nJL_DLLEXPORT int32_t jl_lstat(const char *path, char *statbuf)\n{\n    uv_fs_t req;\n    int ret;\n\n    ret = uv_fs_lstat(uv_default_loop(), &req, path, NULL);\n    if (ret == 0)\n        memcpy(statbuf, req.ptr, sizeof(uv_stat_t));\n    uv_fs_req_cleanup(&req);\n    return ret;\n}\n\nJL_DLLEXPORT int32_t jl_fstat(uv_os_fd_t fd, char *statbuf)\n{\n    uv_fs_t req;\n    int ret;\n\n    ret = uv_fs_fstat(uv_default_loop(), &req, fd, NULL);\n    if (ret == 0)\n        memcpy(statbuf, req.ptr, sizeof(uv_stat_t));\n    uv_fs_req_cleanup(&req);\n    return ret;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_dev(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_dev;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_ino(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_ino;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_mode(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_mode;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_nlink(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_nlink;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_uid(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_uid;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_gid(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_gid;\n}\n\nJL_DLLEXPORT unsigned int jl_stat_rdev(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_rdev;\n}\n\nJL_DLLEXPORT uint64_t jl_stat_size(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_size;\n}\n\nJL_DLLEXPORT uint64_t jl_stat_blksize(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_blksize;\n}\n\nJL_DLLEXPORT uint64_t jl_stat_blocks(char *statbuf)\n{\n    return ((uv_stat_t*)statbuf)->st_blocks;\n}\n\n/*\n// atime is stupid, let's not support it\nJL_DLLEXPORT double jl_stat_atime(char *statbuf)\n{\n  uv_stat_t *s;\n  s = (uv_stat_t*)statbuf;\n  return (double)s->st_atim.tv_sec + (double)s->st_atim.tv_nsec * 1e-9;\n}\n*/\n\nJL_DLLEXPORT double jl_stat_mtime(char *statbuf)\n{\n    uv_stat_t *s;\n    s = (uv_stat_t*)statbuf;\n    return (double)s->st_mtim.tv_sec + (double)s->st_mtim.tv_nsec * 1e-9;\n}\n\nJL_DLLEXPORT double jl_stat_ctime(char *statbuf)\n{\n    uv_stat_t *s;\n    s = (uv_stat_t*)statbuf;\n    return (double)s->st_ctim.tv_sec + (double)s->st_ctim.tv_nsec * 1e-9;\n}\n\n// --- buffer manipulation ---\n\nJL_DLLEXPORT jl_array_t *jl_take_buffer(ios_t *s)\n{\n    size_t n;\n    jl_array_t *a;\n    if (s->buf == &s->local[0]) {\n        // small data case. copies, but this can be avoided using the\n        // technique of jl_readuntil below.\n        a = jl_pchar_to_array(s->buf, s->size);\n        ios_trunc(s, 0);\n    }\n    else {\n        char *b = ios_take_buffer(s, &n);\n        a = jl_ptr_to_array_1d(jl_array_uint8_type, b, n-1, 1);\n    }\n    return a;\n}\n\n// str: if 1 return a string, otherwise return a Vector{UInt8}\n// chomp:\n//   0 - keep delimiter\n//   1 - remove 1 byte delimiter\n//   2 - remove 2 bytes \\r\\n if present\nJL_DLLEXPORT jl_value_t *jl_readuntil(ios_t *s, uint8_t delim, uint8_t str, uint8_t chomp)\n{\n    jl_array_t *a;\n    // manually inlined common case\n    char *pd = (char*)memchr(s->buf + s->bpos, delim, (size_t)(s->size - s->bpos));\n    if (pd) {\n        size_t n = pd - (s->buf + s->bpos) + 1;\n        size_t nchomp = 0;\n        if (chomp) {\n            nchomp = chomp == 2 ? ios_nchomp(s, n) : 1;\n        }\n        if (str) {\n            jl_value_t *str = jl_pchar_to_string(s->buf + s->bpos, n - nchomp);\n            s->bpos += n;\n            return str;\n        }\n        a = jl_alloc_array_1d(jl_array_uint8_type, n - nchomp);\n        memcpy(jl_array_data(a), s->buf + s->bpos, n - nchomp);\n        s->bpos += n;\n    }\n    else {\n        a = jl_alloc_array_1d(jl_array_uint8_type, 80);\n        ios_t dest;\n        ios_mem(&dest, 0);\n        ios_setbuf(&dest, (char*)a->data, 80, 0);\n        size_t n = ios_copyuntil(&dest, s, delim);\n        if (chomp && n > 0 && dest.buf[n - 1] == delim) {\n            n--;\n            if (chomp == 2 && n > 0 && dest.buf[n - 1] == '\\r') {\n                n--;\n            }\n            int truncret = ios_trunc(&dest, n); // it should always be possible to truncate dest\n            assert(truncret == 0);\n            (void)truncret; // ensure the variable is used to avoid warnings\n        }\n        if (dest.buf != a->data) {\n            a = jl_take_buffer(&dest);\n        }\n        else {\n#ifdef STORE_ARRAY_LEN\n            a->length = n;\n#endif\n            a->nrows = n;\n            ((char*)a->data)[n] = '\\0';\n        }\n        if (str) {\n            JL_GC_PUSH1(&a);\n            jl_value_t *st = jl_array_to_string(a);\n            JL_GC_POP();\n            return st;\n        }\n    }\n    return (jl_value_t*)a;\n}\n\nJL_DLLEXPORT uint64_t jl_ios_get_nbyte_int(ios_t *s, const size_t n)\n{\n    assert(n <= 8);\n    size_t space, ret;\n    do {\n        space = (size_t)(s->size - s->bpos);\n        ret = ios_readprep(s, n);\n        if (space == ret && ret < n)\n            jl_eof_error();\n    } while(ret < n);\n    uint64_t x = 0;\n    uint8_t *buf = (uint8_t*)&s->buf[s->bpos];\n    if (n == 8) {\n        // expecting loop unrolling optimization\n        for (size_t i = 0; i < 8; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n    }\n    else if (n >= 4) {\n        // expecting loop unrolling optimization\n        for (size_t i = 0; i < 4; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n        for (size_t i = 4; i < n; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n    }\n    else {\n        for (size_t i = 0; i < n; i++)\n            x |= (uint64_t)buf[i] << (i << 3);\n    }\n    s->bpos += n;\n    return x;\n}\n\n// -- syscall utilities --\n\nJL_DLLEXPORT int jl_errno(void) { return errno; }\nJL_DLLEXPORT void jl_set_errno(int e) { errno = e; }\n\n// -- get the number of CPU threads (logical cores) --\n\n#ifdef _OS_WINDOWS_\ntypedef DWORD (WINAPI *GAPC)(WORD);\n#ifndef ALL_PROCESSOR_GROUPS\n#define ALL_PROCESSOR_GROUPS 0xffff\n#endif\n#endif\n\nJL_DLLEXPORT int jl_cpu_threads(void)\n{\n#if defined(HW_AVAILCPU) && defined(HW_NCPU)\n    size_t len = 4;\n    int32_t count;\n    int nm[2] = {CTL_HW, HW_AVAILCPU};\n    sysctl(nm, 2, &count, &len, NULL, 0);\n    if (count < 1) {\n        nm[1] = HW_NCPU;\n        sysctl(nm, 2, &count, &len, NULL, 0);\n        if (count < 1) { count = 1; }\n    }\n    return count;\n#elif defined(_SC_NPROCESSORS_ONLN)\n    long count = sysconf(_SC_NPROCESSORS_ONLN);\n    if (count < 1)\n        return 1;\n    return count;\n#elif defined(_OS_WINDOWS_)\n    //Try to get WIN7 API method\n    GAPC gapc = (GAPC) jl_dlsym_e(\n        jl_kernel32_handle,\n        \"GetActiveProcessorCount\"\n    );\n\n    if (gapc) {\n        return gapc(ALL_PROCESSOR_GROUPS);\n    }\n    else { //fall back on GetSystemInfo\n        SYSTEM_INFO info;\n        GetSystemInfo(&info);\n        return info.dwNumberOfProcessors;\n    }\n#else\n#warning \"cpu core detection not defined for this platform\"\n    return 1;\n#endif\n}\n\n\n// -- high resolution timers --\n// Returns time in nanosec\nJL_DLLEXPORT uint64_t jl_hrtime(void)\n{\n    return uv_hrtime();\n}\n\n// -- iterating the environment --\n\n#ifdef __APPLE__\n#include <crt_externs.h>\n#else\n#if !defined(_OS_WINDOWS_) || defined(_COMPILER_MINGW_)\nextern char **environ;\n#endif\n#endif\n\nJL_DLLEXPORT jl_value_t *jl_environ(int i)\n{\n#ifdef __APPLE__\n    char **environ = *_NSGetEnviron();\n#endif\n    char *env = environ[i];\n    return env ? jl_pchar_to_string(env, strlen(env)) : jl_nothing;\n}\n\n// -- child process status --\n\n#if defined _MSC_VER || defined _OS_WINDOWS_\n/* Native Woe32 API.  */\n#include <process.h>\n#define waitpid(pid,statusp,options) _cwait (statusp, pid, WAIT_CHILD)\n#define WAIT_T int\n#define WTERMSIG(x) ((x) & 0xff) /* or: SIGABRT ?? */\n#define WCOREDUMP(x) 0\n#define WEXITSTATUS(x) (((x) >> 8) & 0xff) /* or: (x) ?? */\n#define WIFSIGNALED(x) (WTERMSIG (x) != 0) /* or: ((x) == 3) ?? */\n#define WIFEXITED(x) (WTERMSIG (x) == 0) /* or: ((x) != 3) ?? */\n#define WIFSTOPPED(x) 0\n#define WSTOPSIG(x) 0 //Is this correct?\n#endif\n\nint jl_process_exited(int status)      { return WIFEXITED(status); }\nint jl_process_signaled(int status)    { return WIFSIGNALED(status); }\nint jl_process_stopped(int status)     { return WIFSTOPPED(status); }\n\nint jl_process_exit_status(int status) { return WEXITSTATUS(status); }\nint jl_process_term_signal(int status) { return WTERMSIG(status); }\nint jl_process_stop_signal(int status) { return WSTOPSIG(status); }\n\n// -- access to std filehandles --\n\nJL_STREAM *JL_STDIN  = (JL_STREAM*)STDIN_FILENO;\nJL_STREAM *JL_STDOUT = (JL_STREAM*)STDOUT_FILENO;\nJL_STREAM *JL_STDERR = (JL_STREAM*)STDERR_FILENO;\n\nJL_DLLEXPORT JL_STREAM *jl_stdin_stream(void)  { return JL_STDIN; }\nJL_DLLEXPORT JL_STREAM *jl_stdout_stream(void) { return JL_STDOUT; }\nJL_DLLEXPORT JL_STREAM *jl_stderr_stream(void) { return JL_STDERR; }\n\n// -- processor native alignment information --\n\nJL_DLLEXPORT void jl_native_alignment(uint_t *int8align, uint_t *int16align, uint_t *int32align,\n                                      uint_t *int64align, uint_t *float32align, uint_t *float64align)\n{\n    *int8align = __alignof(uint8_t);\n    *int16align = __alignof(uint16_t);\n    *int32align = __alignof(uint32_t);\n    *int64align = __alignof(uint64_t);\n    *float32align = __alignof(float);\n    *float64align = __alignof(double);\n}\n\nJL_DLLEXPORT jl_value_t *jl_is_char_signed(void)\n{\n    return ((char)255) < 0 ? jl_true : jl_false;\n}\n\n// -- misc sysconf info --\n\n#ifdef _OS_WINDOWS_\nstatic long cachedPagesize = 0;\nJL_DLLEXPORT long jl_getpagesize(void)\n{\n    if (!cachedPagesize) {\n        SYSTEM_INFO systemInfo;\n        GetSystemInfo (&systemInfo);\n        cachedPagesize = systemInfo.dwPageSize;\n    }\n    return cachedPagesize;\n}\n#else\nJL_DLLEXPORT long jl_getpagesize(void)\n{\n    return sysconf(_SC_PAGESIZE);\n}\n#endif\n\n#ifdef _OS_WINDOWS_\nstatic long cachedAllocationGranularity = 0;\nJL_DLLEXPORT long jl_getallocationgranularity(void)\n{\n    if (!cachedAllocationGranularity) {\n        SYSTEM_INFO systemInfo;\n        GetSystemInfo (&systemInfo);\n        cachedAllocationGranularity = systemInfo.dwAllocationGranularity;\n    }\n    return cachedAllocationGranularity;\n}\n#else\nJL_DLLEXPORT long jl_getallocationgranularity(void)\n{\n    return jl_getpagesize();\n}\n#endif\n\nJL_DLLEXPORT long jl_SC_CLK_TCK(void)\n{\n#ifndef _OS_WINDOWS_\n    return sysconf(_SC_CLK_TCK);\n#else\n    return 0;\n#endif\n}\n\n// Takes a handle (as returned from dlopen()) and returns the absolute path to the image loaded\nJL_DLLEXPORT const char *jl_pathname_for_handle(void *handle)\n{\n    if (!handle)\n        return NULL;\n\n#ifdef __APPLE__\n    // Iterate through all images currently in memory\n    for (int32_t i = _dyld_image_count() - 1; i >= 0 ; i--) {\n        // dlopen() each image, check handle\n        const char *image_name = _dyld_get_image_name(i);\n        void *probe_lib = jl_load_dynamic_library(image_name, JL_RTLD_DEFAULT);\n        jl_dlclose(probe_lib);\n\n        // If the handle is the same as what was passed in (modulo mode bits), return this image name\n        if (((intptr_t)handle & (-4)) == ((intptr_t)probe_lib & (-4)))\n            return image_name;\n    }\n\n#elif defined(_OS_WINDOWS_)\n\n    wchar_t *pth16 = (wchar_t*)malloc(32768); // max long path length\n    DWORD n16 = GetModuleFileNameW((HMODULE)handle,pth16,32768);\n    if (n16 <= 0) {\n        free(pth16);\n        return NULL;\n    }\n    pth16[n16] = L'\\0';\n    DWORD n8 = WideCharToMultiByte(CP_UTF8, 0, pth16, -1, NULL, 0, NULL, NULL);\n    if (n8 == 0) {\n        free(pth16);\n        return NULL;\n    }\n    char *filepath = (char*)malloc(++n8);\n    if (!WideCharToMultiByte(CP_UTF8, 0, pth16, -1, filepath, n8, NULL, NULL)) {\n        free(pth16);\n        free(filepath);\n        return NULL;\n    }\n    free(pth16);\n    return filepath;\n\n#else // Linux, FreeBSD, ...\n\n    struct link_map *map;\n    dlinfo(handle, RTLD_DI_LINKMAP, &map);\n#ifdef JL_MSAN_ENABLED\n    __msan_unpoison(&map,sizeof(struct link_map*));\n    if (map) {\n        __msan_unpoison(map, sizeof(struct link_map));\n        __msan_unpoison_string(map->l_name);\n    }\n#endif\n    if (map)\n        return map->l_name;\n\n#endif\n    return NULL;\n}\n\n#ifdef _OS_WINDOWS_\nstatic BOOL CALLBACK jl_EnumerateLoadedModulesProc64(\n  _In_      PCTSTR ModuleName,\n  _In_      DWORD64 ModuleBase,\n  _In_      ULONG ModuleSize,\n  _In_opt_  PVOID a\n)\n{\n    jl_array_grow_end((jl_array_t*)a, 1);\n    //XXX: change to jl_arrayset if array storage allocation for Array{String,1} changes:\n    jl_value_t *v = jl_cstr_to_string(ModuleName);\n    jl_array_ptr_set(a, jl_array_dim0(a)-1, v);\n    return TRUE;\n}\n// Takes a handle (as returned from dlopen()) and returns the absolute path to the image loaded\nJL_DLLEXPORT int jl_dllist(jl_array_t *list)\n{\n    return EnumerateLoadedModules64(GetCurrentProcess(), jl_EnumerateLoadedModulesProc64, list);\n}\n#endif\n\nJL_DLLEXPORT void jl_raise_debugger(void)\n{\n#if defined(_OS_WINDOWS_)\n    if (IsDebuggerPresent() == 1)\n        DebugBreak();\n#else\n    raise(SIGTRAP);\n#endif // _OS_WINDOWS_\n}\n\nJL_DLLEXPORT jl_sym_t *jl_get_UNAME(void)\n{\n    return jl_symbol(JL_BUILD_UNAME);\n}\n\nJL_DLLEXPORT jl_sym_t *jl_get_ARCH(void)\n{\n    return jl_symbol(JL_BUILD_ARCH);\n}\n\nJL_DLLEXPORT size_t jl_maxrss(void)\n{\n#if defined(_OS_WINDOWS_)\n    PROCESS_MEMORY_COUNTERS counter;\n    GetProcessMemoryInfo( GetCurrentProcess( ), &counter, sizeof(counter) );\n    return (size_t)counter.PeakWorkingSetSize;\n\n// FIXME: `rusage` is available on OpenBSD, DragonFlyBSD and NetBSD as well.\n//        All of them return `ru_maxrss` in kilobytes.\n#elif defined(_OS_LINUX_) || defined(_OS_DARWIN_) || defined (_OS_FREEBSD_)\n    struct rusage rusage;\n    getrusage( RUSAGE_SELF, &rusage );\n\n#if defined(_OS_LINUX_) || defined(_OS_FREEBSD_)\n    return (size_t)(rusage.ru_maxrss * 1024);\n#else\n    return (size_t)rusage.ru_maxrss;\n#endif\n\n#else\n    return (size_t)0;\n#endif\n}\n\nJL_DLLEXPORT int jl_threading_enabled(void)\n{\n#ifdef JULIA_ENABLE_THREADING\n    return 1;\n#else\n    return 0;\n#endif\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/src/dlload.c": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n\n#include \"platform.h\"\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#ifdef _OS_WINDOWS_\n#include <windows.h>\n#include <direct.h>\n#else\n#include <unistd.h>\n#include <dlfcn.h>\n#endif\n#include \"julia_assert.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(__APPLE__)\nstatic char const *const extensions[] = { \"\", \".dylib\" };\n#elif defined(_OS_WINDOWS_)\nstatic char const *const extensions[] = { \"\", \".dll\" };\nextern int needsSymRefreshModuleList;\n#else\nstatic char const *const extensions[] = { \"\", \".so\" };\n#endif\n#define N_EXTENSIONS (sizeof(extensions) / sizeof(char*))\n\nstatic int endswith_extension(const char *path)\n{\n    if (!path)\n        return 0;\n    size_t len = strlen(path);\n    // Skip the first one since it is empty\n    for (size_t i = 1;i < N_EXTENSIONS;i++) {\n        const char *ext = extensions[i];\n        size_t extlen = strlen(ext);\n        if (len < extlen) return 0;\n        // Skip version extensions if present\n        size_t j = len-1;\n        while (j > 0) {\n            if (path[j] == '.' || (path[j] >= '0' && path[j] <= '9')) j--;\n            else break;\n        }\n        if ((j == len-1 || path[j+1] == '.') && memcmp(ext, path + j - extlen + 1, extlen) == 0) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n#define PATHBUF 512\n\nextern char *julia_bindir;\n\n#define JL_RTLD(flags, FLAG) (flags & JL_RTLD_ ## FLAG ? RTLD_ ## FLAG : 0)\n\nstatic void JL_NORETURN jl_dlerror(const char *fmt, const char *sym)\n{\n#ifdef _OS_WINDOWS_\n    CHAR reason[256];\n    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n            NULL, GetLastError(),\n            MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),\n            reason, sizeof(reason) / sizeof(reason[0]), NULL);\n#else\n    const char *reason = dlerror();\n#endif\n    jl_errorf(fmt, sym, reason);\n}\n\nJL_DLLEXPORT void *jl_dlopen(const char *filename, unsigned flags)\n{\n#if defined(_OS_WINDOWS_)\n    needsSymRefreshModuleList = 1;\n    size_t len = MultiByteToWideChar(CP_UTF8, 0, filename, -1, NULL, 0);\n    if (!len) return NULL;\n    WCHAR *wfilename = (WCHAR*)alloca(len * sizeof(WCHAR));\n    if (!MultiByteToWideChar(CP_UTF8, 0, filename, -1, wfilename, len)) return NULL;\n    return LoadLibraryExW(wfilename, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n#else\n    dlerror(); /* Reset error status. */\n    return dlopen(filename,\n                  (flags & JL_RTLD_NOW ? RTLD_NOW : RTLD_LAZY)\n                  | JL_RTLD(flags, LOCAL)\n                  | JL_RTLD(flags, GLOBAL)\n#ifdef RTLD_NODELETE\n                  | JL_RTLD(flags, NODELETE)\n#endif\n#ifdef RTLD_NOLOAD\n                  | JL_RTLD(flags, NOLOAD)\n#endif\n#if defined(RTLD_DEEPBIND) && !defined(JL_ASAN_ENABLED)\n                  | JL_RTLD(flags, DEEPBIND)\n#endif\n#ifdef RTLD_FIRST\n                  | JL_RTLD(flags, FIRST)\n#endif\n                  );\n#endif\n}\n\nJL_DLLEXPORT int jl_dlclose(void *handle)\n{\n#ifdef _OS_WINDOWS_\n    if (!handle) return -1;\n    return !FreeLibrary((HMODULE) handle);\n#else\n    dlerror(); /* Reset error status. */\n    if (!handle) return -1;\n    return dlclose(handle);\n#endif\n}\n\nstatic void *jl_load_dynamic_library_(const char *modname, unsigned flags, int throw_err)\n{\n    char path[PATHBUF];\n    int i;\n    uv_stat_t stbuf;\n    void *handle;\n    int abspath;\n    // number of extensions to try \u2014\u00a0if modname already ends with the\n    // standard extension, then we don't try adding additional extensions\n    int n_extensions = endswith_extension(modname) ? 1 : N_EXTENSIONS;\n\n    /*\n      this branch returns handle of libjulia\n    */\n    if (modname == NULL) {\n#ifdef _OS_WINDOWS_\n        if (!GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n                                (LPCWSTR)(uintptr_t)(&jl_load_dynamic_library),\n                                (HMODULE*)&handle)) {\n            jl_error(\"could not load base module\");\n        }\n#else\n        Dl_info info;\n        if (!dladdr((void*)(uintptr_t)&jl_load_dynamic_library, &info) || !info.dli_fname)\n            jl_error(\"could not load base module\");\n        handle = dlopen(info.dli_fname, RTLD_NOW);\n#endif\n        goto done;\n    }\n\n    abspath = isabspath(modname);\n\n    /*\n      this branch permutes all base paths in DL_LOAD_PATH with all extensions\n      note: skip when !jl_base_module to avoid UndefVarError(:DL_LOAD_PATH),\n            and also skip for absolute paths\n    */\n    if (!abspath && jl_base_module != NULL) {\n        jl_array_t *DL_LOAD_PATH = (jl_array_t*)jl_get_global(jl_base_module, jl_symbol(\"DL_LOAD_PATH\"));\n        if (DL_LOAD_PATH != NULL) {\n            size_t j;\n            for (j = 0; j < jl_array_len(DL_LOAD_PATH); j++) {\n                char *dl_path = jl_string_data(jl_array_ptr_data(DL_LOAD_PATH)[j]);\n                size_t len = strlen(dl_path);\n                if (len == 0)\n                    continue;\n                for (i=0; i < n_extensions; i++) {\n                    const char *ext = extensions[i];\n                    path[0] = '\\0';\n                    if (dl_path[len-1] == PATHSEPSTRING[0])\n                        snprintf(path, PATHBUF, \"%s%s%s\", dl_path, modname, ext);\n                    else\n                        snprintf(path, PATHBUF, \"%s\" PATHSEPSTRING \"%s%s\", dl_path, modname, ext);\n                    handle = jl_dlopen(path, flags);\n                    if (handle)\n                        goto done;\n                    // bail out and show the error if file actually exists\n                    if (jl_stat(path, (char*)&stbuf) == 0)\n                        goto notfound;\n                }\n            }\n        }\n    }\n\n    // now fall back and look in default library paths, for all extensions\n    for(i=0; i < n_extensions; i++) {\n        const char *ext = extensions[i];\n        path[0] = '\\0';\n        snprintf(path, PATHBUF, \"%s%s\", modname, ext);\n        handle = jl_dlopen(path, flags);\n        if (handle)\n            goto done;\n    }\n\nnotfound:\n    if (throw_err)\n        jl_dlerror(\"could not load library \\\"%s\\\"\\n%s\", modname);\n    return NULL;\n\ndone:\n    return handle;\n}\n\nJL_DLLEXPORT void *jl_load_dynamic_library_e(const char *modname, unsigned flags)\n{\n    return jl_load_dynamic_library_(modname, flags, 0);\n}\n\nJL_DLLEXPORT void *jl_load_dynamic_library(const char *modname, unsigned flags)\n{\n    return jl_load_dynamic_library_(modname, flags, 1);\n}\n\nJL_DLLEXPORT void *jl_dlsym_e(void *handle, const char *symbol)\n{\n#ifdef _OS_WINDOWS_\n    void *ptr = GetProcAddress((HMODULE) handle, symbol);\n#else\n    dlerror(); /* Reset error status. */\n    void *ptr = dlsym(handle, symbol);\n#endif\n    return ptr;\n}\n\nJL_DLLEXPORT void *jl_dlsym(void *handle, const char *symbol)\n{\n    void *ptr = jl_dlsym_e(handle, symbol);\n    if (!ptr)\n        jl_dlerror(\"could not load symbol \\\"%s\\\":\\n%s\", symbol);\n    return ptr;\n}\n\n#ifdef _OS_WINDOWS_\n//Look for symbols in win32 libraries\nconst char *jl_dlfind_win32(const char *f_name)\n{\n    if (jl_dlsym_e(jl_exe_handle, f_name))\n        return JL_EXE_LIBNAME;\n    if (jl_dlsym_e(jl_dl_handle, f_name))\n        return JL_DL_LIBNAME;\n    if (jl_dlsym_e(jl_kernel32_handle, f_name))\n        return \"kernel32\";\n    if (jl_dlsym_e(jl_ntdll_handle, f_name))\n        return \"ntdll\";\n    if (jl_dlsym_e(jl_crtdll_handle, f_name))\n#if defined(_MSC_VER)\n#if _MSC_VER == 1800\n        return \"msvcr120\";\n#else\n#error This version of MSVC has not been tested.\n#endif\n#else\n        return \"msvcrt\";\n#endif\n    if (jl_dlsym_e(jl_winsock_handle, f_name))\n        return \"ws2_32\";\n    // additional common libraries (libc?) could be added here, but in general,\n    // it is better to specify the library explicitly in the code. This exists\n    // mainly to ease compatibility with linux, and for libraries that don't\n    // have a name (julia.exe and libjulia.dll)\n    // We could also loop over all libraries that have been used so far, but, again,\n    // explicit is preferred over implicit\n    return NULL;\n    // oops, we didn't find it. NULL defaults to searching jl_RTLD_DEFAULT_handle,\n    // which defaults to jl_dl_handle, where we won't find it, and will throw the\n    // appropriate error.\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/src/runtime_intrinsics.c": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n// This is in implementation of the Julia intrinsic functions against boxed types\n// excluding the native function call interface (ccall, llvmcall)\n//\n// this file assumes a little-endian processor, although that isn't too hard to fix\n// it also assumes two's complement negative numbers, which might be a bit harder to fix\n//\n// TODO: add half-float support\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"APInt-C.h\"\n\nconst unsigned int host_char_bit = 8;\n\n// run time version of bitcast intrinsic\nJL_DLLEXPORT jl_value_t *jl_bitcast(jl_value_t *ty, jl_value_t *v)\n{\n    JL_TYPECHK(bitcast, datatype, ty);\n    if (!jl_is_concrete_type(ty) || !jl_is_primitivetype(ty))\n        jl_error(\"bitcast: target type not a leaf primitive type\");\n    if (!jl_is_primitivetype(jl_typeof(v)))\n        jl_error(\"bitcast: value not a primitive type\");\n    if (jl_datatype_size(jl_typeof(v)) != jl_datatype_size(ty))\n        jl_error(\"bitcast: argument size does not match size of target type\");\n    if (ty == jl_typeof(v))\n        return v;\n    if (ty == (jl_value_t*)jl_bool_type)\n        return *(uint8_t*)jl_data_ptr(v) & 1 ? jl_true : jl_false;\n    return jl_new_bits(ty, jl_data_ptr(v));\n}\n\n// run time version of pointerref intrinsic (warning: i is not rooted)\nJL_DLLEXPORT jl_value_t *jl_pointerref(jl_value_t *p, jl_value_t *i, jl_value_t *align)\n{\n    JL_TYPECHK(pointerref, pointer, p);\n    JL_TYPECHK(pointerref, long, i)\n    JL_TYPECHK(pointerref, long, align);\n    jl_value_t *ety = jl_tparam0(jl_typeof(p));\n    if (ety == (jl_value_t*)jl_any_type) {\n        jl_value_t **pp = (jl_value_t**)(jl_unbox_long(p) + (jl_unbox_long(i)-1)*sizeof(void*));\n        return *pp;\n    }\n    else {\n        if (!jl_is_datatype(ety))\n            jl_error(\"pointerref: invalid pointer\");\n        size_t nb = LLT_ALIGN(jl_datatype_size(ety), jl_datatype_align(ety));\n        char *pp = (char*)jl_unbox_long(p) + (jl_unbox_long(i)-1)*nb;\n        return jl_new_bits(ety, pp);\n    }\n}\n\n// run time version of pointerset intrinsic (warning: x is not gc-rooted)\nJL_DLLEXPORT jl_value_t *jl_pointerset(jl_value_t *p, jl_value_t *x, jl_value_t *i, jl_value_t *align)\n{\n    JL_TYPECHK(pointerset, pointer, p);\n    JL_TYPECHK(pointerset, long, i);\n    JL_TYPECHK(pointerref, long, align);\n    jl_value_t *ety = jl_tparam0(jl_typeof(p));\n    if (ety == (jl_value_t*)jl_any_type) {\n        jl_value_t **pp = (jl_value_t**)(jl_unbox_long(p) + (jl_unbox_long(i)-1)*sizeof(void*));\n        *pp = x;\n    }\n    else {\n        if (!jl_is_datatype(ety))\n            jl_error(\"pointerset: invalid pointer\");\n        size_t elsz = jl_datatype_size(ety);\n        size_t nb = LLT_ALIGN(elsz, jl_datatype_align(ety));\n        char *pp = (char*)jl_unbox_long(p) + (jl_unbox_long(i)-1)*nb;\n        if (jl_typeof(x) != ety)\n            jl_error(\"pointerset: type mismatch in assign\");\n        memcpy(pp, x, elsz);\n    }\n    return p;\n}\n\nJL_DLLEXPORT jl_value_t *jl_cglobal(jl_value_t *v, jl_value_t *ty)\n{\n    JL_TYPECHK(cglobal, type, ty);\n    jl_value_t *rt =\n        v == (jl_value_t*)jl_void_type ? (jl_value_t*)jl_voidpointer_type : // a common case\n            (jl_value_t*)jl_apply_type1((jl_value_t*)jl_pointer_type, ty);\n\n    if (!jl_is_concrete_type(rt))\n        jl_error(\"cglobal: type argument not concrete\");\n\n    if (jl_is_tuple(v) && jl_nfields(v) == 1)\n        v = jl_fieldref(v, 0);\n\n    if (jl_is_pointer(v))\n        return jl_bitcast(rt, v);\n\n    char *f_lib = NULL;\n    if (jl_is_tuple(v) && jl_nfields(v) > 1) {\n        jl_value_t *t1 = jl_fieldref(v, 1);\n        v = jl_fieldref(v, 0);\n        if (jl_is_symbol(t1))\n            f_lib = jl_symbol_name((jl_sym_t*)t1);\n        else if (jl_is_string(t1))\n            f_lib = jl_string_data(t1);\n        else\n            JL_TYPECHK(cglobal, symbol, t1)\n    }\n\n    char *f_name = NULL;\n    if (jl_is_symbol(v))\n        f_name = jl_symbol_name((jl_sym_t*)v);\n    else if (jl_is_string(v))\n        f_name = jl_string_data(v);\n    else\n        JL_TYPECHK(cglobal, symbol, v)\n\n#ifdef _OS_WINDOWS_\n    if (!f_lib)\n        f_lib = (char*)jl_dlfind_win32(f_name);\n#endif\n\n    void *ptr = jl_dlsym(jl_get_library(f_lib), f_name);\n    jl_value_t *jv = jl_gc_alloc_1w();\n    jl_set_typeof(jv, rt);\n    *(void**)jl_data_ptr(jv) = ptr;\n    return jv;\n}\n\nJL_DLLEXPORT jl_value_t *jl_cglobal_auto(jl_value_t *v) {\n    return jl_cglobal(v, (jl_value_t*)jl_void_type);\n}\n\nstatic inline char signbitbyte(void *a, unsigned bytes)\n{\n    // sign bit of an signed number of n bytes, as a byte\n    return (((signed char*)a)[bytes - 1] < 0) ? ~0 : 0;\n}\n\nstatic inline char usignbitbyte(void *a, unsigned bytes)\n{\n    // sign bit of an unsigned number\n    return 0;\n}\n\nstatic inline unsigned select_by_size(unsigned sz)\n{\n    /* choose the right sized function specialization */\n    switch (sz) {\n    default: return 0;\n    case  1: return 1;\n    case  2: return 2;\n    case  4: return 3;\n    case  8: return 4;\n    case 16: return 5;\n    }\n}\n\n#define SELECTOR_FUNC(intrinsic) \\\n    typedef intrinsic##_t select_##intrinsic##_t[6]; \\\n    static inline intrinsic##_t select_##intrinsic(unsigned sz, const select_##intrinsic##_t list) \\\n    { \\\n        intrinsic##_t thunk = list[select_by_size(sz)]; \\\n        if (!thunk) thunk = list[0]; \\\n        return thunk; \\\n    }\n\n#define fp_select(a, func) \\\n    sizeof(a) == sizeof(float) ? func##f((float)a) : func(a)\n#define fp_select2(a, b, func) \\\n    sizeof(a) == sizeof(float) ? func##f(a, b) : func(a, b)\n\n// fast-function generators //\n\n// integer input\n// OP::Function macro(input)\n// name::unique string\n// nbits::number of bits\n// c_type::c_type corresponding to nbits\n#define un_iintrinsic_ctype(OP, name, nbits, c_type) \\\nstatic inline void jl_##name##nbits(unsigned runtime_nbits, void *pa, void *pr) \\\n{ \\\n    c_type a = *(c_type*)pa; \\\n    *(c_type*)pr = OP(a); \\\n}\n\n// integer input, unsigned output\n// OP::Function macro(input)\n// name::unique string\n// nbits::number of bits\n// c_type::c_type corresponding to nbits\n#define uu_iintrinsic_ctype(OP, name, nbits, c_type) \\\nstatic inline unsigned jl_##name##nbits(unsigned runtime_nbits, void *pa) \\\n{ \\\n    c_type a = *(c_type*)pa; \\\n    return OP(a); \\\n}\n\n// floating point\n// OP::Function macro(output pointer, input)\n// name::unique string\n// nbits::number of bits in the *input*\n// c_type::c_type corresponding to nbits\n#define un_fintrinsic_ctype(OP, name, c_type) \\\nstatic inline void name(unsigned osize, void *pa, void *pr) \\\n{ \\\n    c_type a = *(c_type*)pa; \\\n    OP((c_type*)pr, a); \\\n}\n\n// float or integer inputs\n// OP::Function macro(inputa, inputb)\n// name::unique string\n// nbits::number of bits\n// c_type::c_type corresponding to nbits\n#define bi_intrinsic_ctype(OP, name, nbits, c_type) \\\nstatic void jl_##name##nbits(unsigned runtime_nbits, void *pa, void *pb, void *pr) \\\n{ \\\n    c_type a = *(c_type*)pa; \\\n    c_type b = *(c_type*)pb; \\\n    *(c_type*)pr = (c_type)OP(a, b); \\\n}\n\n// float or integer inputs, bool output\n// OP::Function macro(inputa, inputb)\n// name::unique string\n// nbits::number of bits\n// c_type::c_type corresponding to nbits\n#define bool_intrinsic_ctype(OP, name, nbits, c_type) \\\nstatic int jl_##name##nbits(unsigned runtime_nbits, void *pa, void *pb) \\\n{ \\\n    c_type a = *(c_type*)pa; \\\n    c_type b = *(c_type*)pb; \\\n    return OP(a, b); \\\n}\n\n// integer inputs, with precondition test\n// OP::Function macro(inputa, inputb)\n// name::unique string\n// nbits::number of bits\n// c_type::c_type corresponding to nbits\n#define checked_intrinsic_ctype(CHECK_OP, OP, name, nbits, c_type) \\\nstatic int jl_##name##nbits(unsigned runtime_nbits, void *pa, void *pb, void *pr) \\\n{ \\\n    c_type a = *(c_type*)pa; \\\n    c_type b = *(c_type*)pb; \\\n    if (CHECK_OP(a, b)) \\\n        return 1; \\\n    *(c_type*)pr = (c_type)OP(a, b); \\\n    return 0; \\\n}\n\n// float inputs\n// OP::Function macro(inputa, inputb, inputc)\n// name::unique string\n// nbits::number of bits\n// c_type::c_type corresponding to nbits\n#define ter_intrinsic_ctype(OP, name, nbits, c_type) \\\nstatic void jl_##name##nbits(unsigned runtime_nbits, void *pa, void *pb, void *pc, void *pr) \\\n{ \\\n    c_type a = *(c_type*)pa; \\\n    c_type b = *(c_type*)pb; \\\n    c_type c = *(c_type*)pc; \\\n    *(c_type*)pr = (c_type)OP(a, b, c); \\\n}\n\n\n// unary operator generator //\n\ntypedef void (*intrinsic_1_t)(unsigned, void*, void*);\nSELECTOR_FUNC(intrinsic_1)\n#define un_iintrinsic(name, u) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *a) \\\n{ \\\n    return jl_iintrinsic_1(jl_typeof(a), a, #name, u##signbitbyte, jl_intrinsiclambda_ty1, name##_list); \\\n}\n#define un_iintrinsic_fast(LLVMOP, OP, name, u) \\\nun_iintrinsic_ctype(OP, name, 8, u##int##8_t) \\\nun_iintrinsic_ctype(OP, name, 16, u##int##16_t) \\\nun_iintrinsic_ctype(OP, name, 32, u##int##32_t) \\\nun_iintrinsic_ctype(OP, name, 64, u##int##64_t) \\\nstatic const select_intrinsic_1_t name##_list = { \\\n    LLVMOP, \\\n    jl_##name##8, \\\n    jl_##name##16, \\\n    jl_##name##32, \\\n    jl_##name##64, \\\n}; \\\nun_iintrinsic(name, u)\n#define un_iintrinsic_slow(LLVMOP, name, u) \\\nstatic const select_intrinsic_1_t name##_list = { \\\n    LLVMOP \\\n}; \\\nun_iintrinsic(name, u)\n\ntypedef unsigned (*intrinsic_u1_t)(unsigned, void*);\nSELECTOR_FUNC(intrinsic_u1)\n#define uu_iintrinsic(name, u) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *a) \\\n{ \\\n    return jl_iintrinsic_1(jl_typeof(a), a, #name, u##signbitbyte, jl_intrinsiclambda_u1, name##_list); \\\n}\n#define uu_iintrinsic_fast(LLVMOP, OP, name, u) \\\nuu_iintrinsic_ctype(OP, name, 8, u##int##8_t) \\\nuu_iintrinsic_ctype(OP, name, 16, u##int##16_t) \\\nuu_iintrinsic_ctype(OP, name, 32, u##int##32_t) \\\nuu_iintrinsic_ctype(OP, name, 64, u##int##64_t) \\\nstatic const select_intrinsic_u1_t name##_list = { \\\n    LLVMOP, \\\n    jl_##name##8, \\\n    jl_##name##16, \\\n    jl_##name##32, \\\n    jl_##name##64, \\\n}; \\\nuu_iintrinsic(name, u)\n#define uu_iintrinsic_slow(LLVMOP, name, u) \\\nstatic const select_intrinsic_u1_t name##_list = { \\\n    LLVMOP \\\n}; \\\nuu_iintrinsic(name, u)\n\nstatic inline\njl_value_t *jl_iintrinsic_1(jl_value_t *ty, jl_value_t *a, const char *name,\n                            char (*getsign)(void*, unsigned),\n                            jl_value_t *(*lambda1)(jl_value_t*, void*, unsigned, unsigned, const void*), const void *list)\n{\n    if (!jl_is_primitivetype(jl_typeof(a)))\n        jl_errorf(\"%s: value is not a primitive type\", name);\n    if (!jl_is_primitivetype(ty))\n        jl_errorf(\"%s: type is not a primitive type\", name);\n    void *pa = jl_data_ptr(a);\n    unsigned isize = jl_datatype_size(jl_typeof(a));\n    unsigned isize2 = next_power_of_two(isize);\n    unsigned osize = jl_datatype_size(ty);\n    unsigned osize2 = next_power_of_two(osize);\n    if (isize2 > osize2)\n        osize2 = isize2;\n    if (osize2 > isize || isize2 > isize) {\n        /* if needed, round type up to a real c-type and set/clear the unused bits */\n        void *pa2;\n        pa2 = alloca(osize2);\n        /* TODO: this memcpy assumes little-endian,\n         * for big-endian, need to align the copy to the other end */ \\\n        memcpy(pa2, pa, isize);\n        memset((char*)pa2 + isize, getsign(pa, isize), osize2 - isize);\n        pa = pa2;\n    }\n    jl_value_t *newv = lambda1(ty, pa, osize, osize2, list);\n    if (ty == (jl_value_t*)jl_bool_type)\n        return *(uint8_t*)jl_data_ptr(newv) & 1 ? jl_true : jl_false;\n    return newv;\n}\n\nstatic inline jl_value_t *jl_intrinsiclambda_ty1(jl_value_t *ty, void *pa, unsigned osize, unsigned osize2, const void *voidlist)\n{\n    intrinsic_1_t op = select_intrinsic_1(osize2, (const intrinsic_1_t*)voidlist);\n    void *pr = alloca(osize2);\n    op(osize * host_char_bit, pa, pr);\n    return jl_new_bits(ty, pr);\n}\n\nstatic inline jl_value_t *jl_intrinsiclambda_u1(jl_value_t *ty, void *pa, unsigned osize, unsigned osize2, const void *voidlist)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    intrinsic_u1_t op = select_intrinsic_u1(osize2, (const intrinsic_u1_t*)voidlist);\n    uint64_t cnt = op(osize * host_char_bit, pa);\n    // TODO: the following assume little-endian\n    // for big-endian, need to copy from the other end of cnt\n    if (osize <= sizeof(cnt)) {\n        return jl_new_bits(ty, &cnt);\n    }\n    jl_value_t *newv = jl_gc_alloc(ptls, osize, ty);\n    // perform zext, if needed\n    memset((char*)jl_data_ptr(newv) + sizeof(cnt), 0, osize - sizeof(cnt));\n    memcpy(jl_data_ptr(newv), &cnt, sizeof(cnt));\n    return newv;\n}\n\n// conversion operator\n\ntypedef void (*intrinsic_cvt_t)(unsigned, void*, unsigned, void*);\ntypedef unsigned (*intrinsic_cvt_check_t)(unsigned, unsigned, void*);\n#define cvt_iintrinsic(LLVMOP, name) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *ty, jl_value_t *a) \\\n{ \\\n    return jl_intrinsic_cvt(ty, a, #name, LLVMOP); \\\n}\n\nstatic inline jl_value_t *jl_intrinsic_cvt(jl_value_t *ty, jl_value_t *a, const char *name, intrinsic_cvt_t op)\n{\n    jl_value_t *aty = jl_typeof(a);\n    if (!jl_is_primitivetype(aty))\n        jl_errorf(\"%s: value is not a primitive type\", name);\n    if (!jl_is_primitivetype(ty))\n        jl_errorf(\"%s: type is not a primitive type\", name);\n    void *pa = jl_data_ptr(a);\n    unsigned isize = jl_datatype_size(aty);\n    unsigned osize = jl_datatype_size(ty);\n    void *pr = alloca(osize);\n    unsigned isize_bits = isize * host_char_bit;\n    unsigned osize_bits = osize * host_char_bit;\n    if (aty == (jl_value_t*)jl_bool_type)\n       isize_bits = 1;\n    op(isize_bits, pa, osize_bits, pr);\n    return jl_new_bits(ty, pr);\n}\n\n// floating point\n\n#define un_fintrinsic_withtype(OP, name) \\\nun_fintrinsic_ctype(OP, jl_##name##32, float) \\\nun_fintrinsic_ctype(OP, jl_##name##64, double) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *ty, jl_value_t *a) \\\n{ \\\n    return jl_fintrinsic_1(ty, a, #name, jl_##name##32, jl_##name##64); \\\n}\n\n#define un_fintrinsic(OP, name) \\\nun_fintrinsic_withtype(OP, name##_withtype) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *a) \\\n{ \\\n    return jl_##name##_withtype(jl_typeof(a), a); \\\n}\n\ntypedef void (fintrinsic_op1)(unsigned, void*, void*);\n\nstatic inline jl_value_t *jl_fintrinsic_1(jl_value_t *ty, jl_value_t *a, const char *name, fintrinsic_op1 *floatop, fintrinsic_op1 *doubleop)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    if (!jl_is_primitivetype(jl_typeof(a)))\n        jl_errorf(\"%s: value is not a primitive type\", name);\n    if (!jl_is_primitivetype(ty))\n        jl_errorf(\"%s: type is not a primitive type\", name);\n    unsigned sz2 = jl_datatype_size(ty);\n    jl_value_t *newv = jl_gc_alloc(ptls, sz2, ty);\n    void *pa = jl_data_ptr(a), *pr = jl_data_ptr(newv);\n    unsigned sz = jl_datatype_size(jl_typeof(a));\n    switch (sz) {\n    /* choose the right size c-type operation based on the input */\n    case 4:\n        floatop(sz2 * host_char_bit, pa, pr);\n        break;\n    case 8:\n        doubleop(sz2 * host_char_bit, pa, pr);\n        break;\n    default:\n        jl_errorf(\"%s: runtime floating point intrinsics are not implemented for bit sizes other than 32 and 64\", name);\n    }\n    return newv;\n}\n\n// binary operator generator //\n\n// integer\n\ntypedef void (*intrinsic_2_t)(unsigned, void*, void*, void*);\nSELECTOR_FUNC(intrinsic_2)\n#define bi_iintrinsic(name, u, cvtb) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *a, jl_value_t *b) \\\n{ \\\n    return jl_iintrinsic_2(a, b, #name, u##signbitbyte, jl_intrinsiclambda_2, name##_list, cvtb); \\\n}\n#define bi_iintrinsic_cnvtb_fast(LLVMOP, OP, name, u, cvtb) \\\nbi_intrinsic_ctype(OP, name, 8, u##int##8_t) \\\nbi_intrinsic_ctype(OP, name, 16, u##int##16_t) \\\nbi_intrinsic_ctype(OP, name, 32, u##int##32_t) \\\nbi_intrinsic_ctype(OP, name, 64, u##int##64_t) \\\nstatic const select_intrinsic_2_t name##_list = { \\\n    LLVMOP, \\\n    jl_##name##8, \\\n    jl_##name##16, \\\n    jl_##name##32, \\\n    jl_##name##64, \\\n}; \\\nbi_iintrinsic(name, u, cvtb)\n#define bi_iintrinsic_fast(LLVMOP, OP, name, u) \\\n    bi_iintrinsic_cnvtb_fast(LLVMOP, OP, name, u, 0)\n\ntypedef int (*intrinsic_cmp_t)(unsigned, void*, void*);\nSELECTOR_FUNC(intrinsic_cmp)\n#define cmp_iintrinsic(name, u) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *a, jl_value_t *b) \\\n{ \\\n    return jl_iintrinsic_2(a, b, #name, u##signbitbyte, jl_intrinsiclambda_cmp, name##_list, 0); \\\n}\n#define bool_iintrinsic_fast(LLVMOP, OP, name, u) \\\nbool_intrinsic_ctype(OP, name, 8, u##int##8_t) \\\nbool_intrinsic_ctype(OP, name, 16, u##int##16_t) \\\nbool_intrinsic_ctype(OP, name, 32, u##int##32_t) \\\nbool_intrinsic_ctype(OP, name, 64, u##int##64_t) \\\nstatic const select_intrinsic_cmp_t name##_list = { \\\n    LLVMOP, \\\n    jl_##name##8, \\\n    jl_##name##16, \\\n    jl_##name##32, \\\n    jl_##name##64, \\\n}; \\\ncmp_iintrinsic(name, u)\n\ntypedef int (*intrinsic_checked_t)(unsigned, void*, void*, void*);\nSELECTOR_FUNC(intrinsic_checked)\n#define checked_iintrinsic(name, u, lambda_checked) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *a, jl_value_t *b) \\\n{ \\\n    return jl_iintrinsic_2(a, b, #name, u##signbitbyte, lambda_checked, name##_list, 0); \\\n}\n#define checked_iintrinsic_fast(LLVMOP, CHECK_OP, OP, name, u) \\\nchecked_intrinsic_ctype(CHECK_OP, OP, name, 8, u##int##8_t) \\\nchecked_intrinsic_ctype(CHECK_OP, OP, name, 16, u##int##16_t) \\\nchecked_intrinsic_ctype(CHECK_OP, OP, name, 32, u##int##32_t) \\\nchecked_intrinsic_ctype(CHECK_OP, OP, name, 64, u##int##64_t) \\\nstatic const select_intrinsic_checked_t name##_list = { \\\n    LLVMOP, \\\n    jl_##name##8, \\\n    jl_##name##16, \\\n    jl_##name##32, \\\n    jl_##name##64, \\\n}; \\\nchecked_iintrinsic(name, u, jl_intrinsiclambda_checked)\n#define checked_iintrinsic_slow(LLVMOP, name, u) \\\nstatic const select_intrinsic_checked_t name##_list = { \\\n    LLVMOP \\\n}; \\\nchecked_iintrinsic(name, u, jl_intrinsiclambda_checked)\n#define checked_iintrinsic_div(LLVMOP, name, u) \\\nstatic const select_intrinsic_checked_t name##_list = { \\\n    LLVMOP \\\n}; \\\nchecked_iintrinsic(name, u, jl_intrinsiclambda_checkeddiv)\n\nstatic inline\njl_value_t *jl_iintrinsic_2(jl_value_t *a, jl_value_t *b, const char *name,\n                            char (*getsign)(void*, unsigned),\n                            jl_value_t *(*lambda2)(jl_value_t*, void*, void*, unsigned, unsigned, const void*),\n                            const void *list, int cvtb)\n{\n    jl_value_t *ty = jl_typeof(a);\n    jl_value_t *tyb = jl_typeof(b);\n    if (tyb != ty) {\n        if (!cvtb)\n            jl_errorf(\"%s: types of a and b must match\", name);\n        if (!jl_is_primitivetype(tyb))\n            jl_errorf(\"%s: b is not a primitive type\", name);\n    }\n    if (!jl_is_primitivetype(ty))\n        jl_errorf(\"%s: a is not a primitive type\", name);\n    void *pa = jl_data_ptr(a), *pb = jl_data_ptr(b);\n    unsigned sz = jl_datatype_size(ty);\n    unsigned sz2 = next_power_of_two(sz);\n    unsigned szb = cvtb ? jl_datatype_size(tyb) : sz;\n    if (sz2 > sz) {\n        /* round type up to the appropriate c-type and set/clear the unused bits */\n        void *pa2 = alloca(sz2);\n        memcpy(pa2, pa, sz);\n        memset((char*)pa2 + sz, getsign(pa, sz), sz2 - sz);\n        pa = pa2;\n    }\n    if (sz2 > szb) {\n        /* round type up to the appropriate c-type and set/clear/truncate the unused bits\n         * (zero-extend if cvtb is set, since in that case b is unsigned while the sign of a comes from the op)\n         */\n        void *pb2 = alloca(sz2);\n        memcpy(pb2, pb, szb);\n        memset((char*)pb2 + szb, cvtb ? 0 : getsign(pb, szb), sz2 - szb);\n        pb = pb2;\n    }\n    jl_value_t *newv = lambda2(ty, pa, pb, sz, sz2, list);\n    return newv;\n}\n\nstatic inline jl_value_t *jl_intrinsiclambda_2(jl_value_t *ty, void *pa, void *pb, unsigned sz, unsigned sz2, const void *voidlist)\n{\n    void *pr = alloca(sz2);\n    intrinsic_2_t op = select_intrinsic_2(sz2, (const intrinsic_2_t*)voidlist);\n    op(sz * host_char_bit, pa, pb, pr);\n    return jl_new_bits(ty, pr);\n}\n\nstatic inline jl_value_t *jl_intrinsiclambda_cmp(jl_value_t *ty, void *pa, void *pb, unsigned sz, unsigned sz2, const void *voidlist)\n{\n    intrinsic_cmp_t op = select_intrinsic_cmp(sz2, (const intrinsic_cmp_t*)voidlist);\n    int cmp = op(sz * host_char_bit, pa, pb);\n    return cmp ? jl_true : jl_false;\n}\n\nstatic inline jl_value_t *jl_intrinsiclambda_checked(jl_value_t *ty, void *pa, void *pb, unsigned sz, unsigned sz2, const void *voidlist)\n{\n    jl_value_t *params[2];\n    params[0] = ty;\n    params[1] = (jl_value_t*)jl_bool_type;\n    jl_datatype_t *tuptyp = jl_apply_tuple_type_v(params, 2);\n    jl_ptls_t ptls = jl_get_ptls_states();\n    jl_value_t *newv = jl_gc_alloc(ptls, ((jl_datatype_t*)tuptyp)->size, tuptyp);\n\n    intrinsic_checked_t op = select_intrinsic_checked(sz2, (const intrinsic_checked_t*)voidlist);\n    int ovflw = op(sz * host_char_bit, pa, pb, jl_data_ptr(newv));\n\n    char *ao = (char*)jl_data_ptr(newv) + sz;\n    *ao = (char)ovflw;\n    return newv;\n}\nstatic inline jl_value_t *jl_intrinsiclambda_checkeddiv(jl_value_t *ty, void *pa, void *pb, unsigned sz, unsigned sz2, const void *voidlist)\n{\n    void *pr = alloca(sz2);\n    intrinsic_checked_t op = select_intrinsic_checked(sz2, (const intrinsic_checked_t*)voidlist);\n    int ovflw = op(sz * host_char_bit, pa, pb, pr);\n    if (ovflw)\n        jl_throw(jl_diverror_exception);\n    return jl_new_bits(ty, pr);\n}\n\n// floating point\n\n#define bi_fintrinsic(OP, name) \\\n    bi_intrinsic_ctype(OP, name, 32, float) \\\n    bi_intrinsic_ctype(OP, name, 64, double) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *a, jl_value_t *b) \\\n{ \\\n    jl_ptls_t ptls = jl_get_ptls_states();\\\n    jl_value_t *ty = jl_typeof(a); \\\n    if (jl_typeof(b) != ty) \\\n        jl_error(#name \": types of a and b must match\"); \\\n    if (!jl_is_primitivetype(ty)) \\\n        jl_error(#name \": values are not primitive types\"); \\\n    int sz = jl_datatype_size(ty); \\\n    jl_value_t *newv = jl_gc_alloc(ptls, sz, ty);          \\\n    void *pa = jl_data_ptr(a), *pb = jl_data_ptr(b), *pr = jl_data_ptr(newv); \\\n    switch (sz) { \\\n    /* choose the right size c-type operation */ \\\n    case 4: \\\n        jl_##name##32(32, pa, pb, pr); \\\n        break; \\\n    case 8: \\\n        jl_##name##64(64, pa, pb, pr); \\\n        break; \\\n    default: \\\n        jl_error(#name \": runtime floating point intrinsics are not implemented for bit sizes other than 32 and 64\"); \\\n    } \\\n    return newv; \\\n}\n\n#define bool_fintrinsic(OP, name) \\\n    bool_intrinsic_ctype(OP, name, 32, float) \\\n    bool_intrinsic_ctype(OP, name, 64, double) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *a, jl_value_t *b) \\\n{ \\\n    jl_value_t *ty = jl_typeof(a); \\\n    if (jl_typeof(b) != ty) \\\n        jl_error(#name \": types of a and b must match\"); \\\n    if (!jl_is_primitivetype(ty)) \\\n        jl_error(#name \": values are not primitive types\"); \\\n    void *pa = jl_data_ptr(a), *pb = jl_data_ptr(b); \\\n    int sz = jl_datatype_size(ty); \\\n    int cmp; \\\n    switch (sz) { \\\n    /* choose the right size c-type operation */ \\\n    case 4: \\\n        cmp = jl_##name##32(32, pa, pb); \\\n        break; \\\n    case 8: \\\n        cmp = jl_##name##64(64, pa, pb); \\\n        break; \\\n    default: \\\n        jl_error(#name \": runtime floating point intrinsics are not implemented for bit sizes other than 32 and 64\"); \\\n    } \\\n    return cmp ? jl_true : jl_false; \\\n}\n\n#define ter_fintrinsic(OP, name) \\\n    ter_intrinsic_ctype(OP, name, 32, float) \\\n    ter_intrinsic_ctype(OP, name, 64, double) \\\nJL_DLLEXPORT jl_value_t *jl_##name(jl_value_t *a, jl_value_t *b, jl_value_t *c) \\\n{ \\\n    jl_ptls_t ptls = jl_get_ptls_states();\\\n    jl_value_t *ty = jl_typeof(a); \\\n    if (jl_typeof(b) != ty || jl_typeof(c) != ty) \\\n        jl_error(#name \": types of a, b, and c must match\"); \\\n    if (!jl_is_primitivetype(ty)) \\\n        jl_error(#name \": values are not primitive types\"); \\\n    int sz = jl_datatype_size(ty);                                      \\\n    jl_value_t *newv = jl_gc_alloc(ptls, sz, ty);                       \\\n    void *pa = jl_data_ptr(a), *pb = jl_data_ptr(b), *pc = jl_data_ptr(c), *pr = jl_data_ptr(newv); \\\n    switch (sz) { \\\n    /* choose the right size c-type operation */ \\\n    case 4: \\\n        jl_##name##32(32, pa, pb, pc, pr); \\\n        break; \\\n    case 8: \\\n        jl_##name##64(64, pa, pb, pc, pr); \\\n        break; \\\n    default: \\\n        jl_error(#name \": runtime floating point intrinsics are not implemented for bit sizes other than 32 and 64\"); \\\n    } \\\n    return newv; \\\n}\n\n// arithmetic\n#define neg(a) -a\n#define neg_float(pr, a) *pr = -a\nun_iintrinsic_fast(LLVMNeg, neg, neg_int, u)\n#define add(a,b) a + b\nbi_iintrinsic_fast(LLVMAdd, add, add_int, u)\nbi_iintrinsic_fast(LLVMAdd, add, add_ptr, u)\n#define sub(a,b) a - b\nbi_iintrinsic_fast(LLVMSub, sub, sub_int, u)\nbi_iintrinsic_fast(LLVMSub, sub, sub_ptr, u)\n#define mul(a,b) a * b\nbi_iintrinsic_fast(LLVMMul, mul, mul_int, u)\n#define div(a,b) a / b\nbi_iintrinsic_fast(LLVMSDiv, div, sdiv_int,  )\nbi_iintrinsic_fast(LLVMUDiv, div, udiv_int, u)\n#define rem(a,b) a % b\nbi_iintrinsic_fast(LLVMSRem, rem, srem_int,  )\nbi_iintrinsic_fast(LLVMURem, rem, urem_int, u)\n#define smod(a,b) ((a < 0) == (b < 0)) ? a % b : (b + (a % b)) % b\nbi_iintrinsic_fast(jl_LLVMSMod, smod, smod_int,  )\n#define frem(a, b) \\\n    fp_select2(a, b, fmod)\n\nun_fintrinsic(neg_float,neg_float)\nbi_fintrinsic(add,add_float)\nbi_fintrinsic(sub,sub_float)\nbi_fintrinsic(mul,mul_float)\nbi_fintrinsic(div,div_float)\nbi_fintrinsic(frem,rem_float)\n\n// ternary operators //\n#define fma(a, b, c) \\\n    sizeof(a) == sizeof(float) ? fmaf(a, b, c) : fma(a, b, c)\n#define muladd(a, b, c) a * b + c\nter_fintrinsic(fma,fma_float)\nter_fintrinsic(muladd,muladd_float)\n\n// same-type comparisons\n#define eq(a,b) a == b\nbool_iintrinsic_fast(LLVMICmpEQ, eq, eq_int, u)\n#define ne(a,b) a != b\nbool_iintrinsic_fast(LLVMICmpNE, ne, ne_int, u)\n#define lt(a,b) a < b\nbool_iintrinsic_fast(LLVMICmpSLT, lt, slt_int,  )\nbool_iintrinsic_fast(LLVMICmpULT, lt, ult_int, u)\n#define le(a,b) a <= b\nbool_iintrinsic_fast(LLVMICmpSLE, le, sle_int,  )\nbool_iintrinsic_fast(LLVMICmpULE, le, ule_int, u)\n\ntypedef union {\n    float f;\n    int32_t d;\n    uint32_t ud;\n} bits32;\ntypedef union {\n    double f;\n    int64_t d;\n    uint64_t ud;\n} bits64;\n\n#define fpiseq_n(c_type, nbits) \\\nstatic inline int fpiseq##nbits(c_type a, c_type b) { \\\n    bits##nbits ua, ub; \\\n    ua.f = a; \\\n    ub.f = b; \\\n    return (isnan(a) && isnan(b)) || ua.d == ub.d; \\\n}\nfpiseq_n(float, 32)\nfpiseq_n(double, 64)\n#define fpiseq(a,b) \\\n    sizeof(a) == sizeof(float) ? fpiseq32(a, b) : fpiseq64(a, b)\n\n#define fpislt_n(c_type, nbits) \\\nstatic inline int fpislt##nbits(c_type a, c_type b) { \\\n    bits##nbits ua, ub; \\\n    ua.f = a; \\\n    ub.f = b; \\\n    if (!isnan(a) && isnan(b)) \\\n        return 1; \\\n    if (isnan(a) || isnan(b)) \\\n        return 0; \\\n    if (ua.d >= 0 && ua.d < ub.d) \\\n        return 1; \\\n    if (ua.d < 0 && ua.ud > ub.ud) \\\n        return 1; \\\n    return 0; \\\n}\nfpislt_n(float, 32)\nfpislt_n(double, 64)\n#define fpislt(a, b) \\\n    sizeof(a) == sizeof(float) ? fpislt32(a, b) : fpislt64(a, b)\n\nbool_fintrinsic(eq,eq_float)\nbool_fintrinsic(ne,ne_float)\nbool_fintrinsic(lt,lt_float)\nbool_fintrinsic(le,le_float)\nbool_fintrinsic(fpiseq,fpiseq)\nbool_fintrinsic(fpislt,fpislt)\n\n// bitwise operators\n#define and_op(a,b) a & b\nbi_iintrinsic_fast(LLVMAnd, and_op, and_int, u)\n#define or_op(a,b) a | b\nbi_iintrinsic_fast(LLVMOr, or_op, or_int, u)\n#define xor_op(a,b) a ^ b\nbi_iintrinsic_fast(LLVMXor, xor_op, xor_int, u)\n#define shl_op(a,b) b >= 8 * sizeof(a) ? 0 : a << b\nbi_iintrinsic_cnvtb_fast(LLVMShl, shl_op, shl_int, u, 1)\n#define lshr_op(a,b) (b >= 8 * sizeof(a)) ? 0 : a >> b\nbi_iintrinsic_cnvtb_fast(LLVMLShr, lshr_op, lshr_int, u, 1)\n#define ashr_op(a,b) ((b < 0 || b >= 8 * sizeof(a)) ? a >> (8*sizeof(a) - 1) : a >> b)\nbi_iintrinsic_cnvtb_fast(LLVMAShr, ashr_op, ashr_int, , 1)\n//#define bswap_op(a) __builtin_bswap(a)\n//un_iintrinsic_fast(LLVMByteSwap, bswap_op, bswap_int, u)\nun_iintrinsic_slow(LLVMByteSwap, bswap_int, u)\n//#define ctpop_op(a) __builtin_ctpop(a)\n//uu_iintrinsic_fast(LLVMCountPopulation, ctpop_op, ctpop_int, u)\nuu_iintrinsic_slow(LLVMCountPopulation, ctpop_int, u)\n//#define ctlz_op(a) __builtin_ctlz(a)\n//uu_iintrinsic_fast(LLVMCountLeadingZeros, ctlz_op, ctlz_int, u)\nuu_iintrinsic_slow(LLVMCountLeadingZeros, ctlz_int, u)\n//#define cttz_op(a) __builtin_cttz(a)\n//uu_iintrinsic_fast(LLVMCountTrailingZeros, cttz_op, cttz_int, u)\nuu_iintrinsic_slow(LLVMCountTrailingZeros, cttz_int, u)\n#define not_op(a) ~a\nun_iintrinsic_fast(LLVMFlipAllBits, not_op, not_int, u)\n\n// conversions\ncvt_iintrinsic(LLVMTrunc, trunc_int)\ncvt_iintrinsic(LLVMSExt, sext_int)\ncvt_iintrinsic(LLVMZExt, zext_int)\ncvt_iintrinsic(LLVMSItoFP, sitofp)\ncvt_iintrinsic(LLVMUItoFP, uitofp)\ncvt_iintrinsic(LLVMFPtoSI, fptosi)\ncvt_iintrinsic(LLVMFPtoUI, fptoui)\n\n#define fpcvt(pr, a) \\\n        if (osize == 32) \\\n            *(float*)pr = a; \\\n        else if (osize == 64) \\\n            *(double*)pr = a; \\\n        else \\\n            jl_error(\"fptrunc/fpext: runtime floating point intrinsics are not implemented for bit sizes other than 32 and 64\");\nun_fintrinsic_withtype(fpcvt,fptrunc)\nun_fintrinsic_withtype(fpcvt,fpext)\n\n// checked arithmetic\n#define check_sadd_int(a,b) \\\n        /* this test is a reduction of (b > 0) ? (a + b > typemax(a)) : (a + b < typemin(a)) ==> overflow \\\n         * where (a - a) == (typeof(a))0 */ \\\n        (b > 0) ? (a > ~((a - a + 1) << (8 * sizeof(a) - 1)) - b) : (a < ((a - a + 1) << (8 * sizeof(a) - 1)) - b)\nchecked_iintrinsic_fast(LLVMAdd_sov, check_sadd_int, add, checked_sadd_int,  )\n#define check_uadd_int(a,b) \\\n        /* this test checks for (a + b) > typemax(a) ==> overflow */ \\\n        a >= -b\nchecked_iintrinsic_fast(LLVMAdd_uov, check_uadd_int, add, checked_uadd_int, u)\n#define check_ssub_int(a,b) check_sadd_int(a,-b)\nchecked_iintrinsic_fast(LLVMSub_sov, check_ssub_int, sub, checked_ssub_int,  )\n#define check_usub_int(a,b) \\\n        /* this test checks for (a - b) < 0 ==> overflow */ \\\n        a < b\nchecked_iintrinsic_fast(LLVMSub_uov, check_usub_int, sub, checked_usub_int, u)\nchecked_iintrinsic_slow(LLVMMul_sov, checked_smul_int,  )\nchecked_iintrinsic_slow(LLVMMul_uov, checked_umul_int, u)\n\nchecked_iintrinsic_div(LLVMDiv_sov, checked_sdiv_int,  )\nchecked_iintrinsic_div(LLVMDiv_uov, checked_udiv_int, u)\nchecked_iintrinsic_div(LLVMRem_sov, checked_srem_int,  )\nchecked_iintrinsic_div(LLVMRem_uov, checked_urem_int, u)\n\n// functions\n#define flipsign(a, b) \\\n        (b >= 0) ? a : -a\nbi_iintrinsic_fast(jl_LLVMFlipSign, flipsign, flipsign_int,  )\n#define abs_float(pr, a) *pr = fp_select(a, fabs)\n#define ceil_float(pr, a) *pr = fp_select(a, ceil)\n#define floor_float(pr, a) *pr = fp_select(a, floor)\n#define trunc_float(pr, a) *pr = fp_select(a, trunc)\n#define rint_float(pr, a) *pr = fp_select(a, rint)\n#define sqrt_float(pr, a) \\\n        *pr = fp_select(a, sqrt)\n#define copysign_float(a, b) \\\n        fp_select2(a, b, copysign)\n\nun_fintrinsic(abs_float,abs_float)\nbi_fintrinsic(copysign_float,copysign_float)\nun_fintrinsic(ceil_float,ceil_llvm)\nun_fintrinsic(floor_float,floor_llvm)\nun_fintrinsic(trunc_float,trunc_llvm)\nun_fintrinsic(rint_float,rint_llvm)\nun_fintrinsic(sqrt_float,sqrt_llvm)\n\nJL_DLLEXPORT jl_value_t *jl_arraylen(jl_value_t *a)\n{\n    JL_TYPECHK(arraylen, array, a);\n    return jl_box_long(jl_array_len((jl_array_t*)a));\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/src/init.c": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n/*\n  init.c\n  system initialization and global state\n*/\n#include \"platform.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n\n#include <errno.h>\n\n#if !defined(_OS_WINDOWS_) || defined(_COMPILER_MINGW_)\n#include <getopt.h>\n#endif\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#define DEFINE_BUILTIN_GLOBALS\n#include \"builtin_proto.h\"\n#undef DEFINE_BUILTIN_GLOBALS\n#include \"threading.h\"\n#include \"julia_assert.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef _MSC_VER\nJL_DLLEXPORT char *dirname(char *);\n#else\n#include <libgen.h>\n#endif\n\n#ifdef _OS_WINDOWS_\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n#include <io.h>\nextern int needsSymRefreshModuleList;\nextern BOOL (WINAPI *hSymRefreshModuleList)(HANDLE);\n#else\n#include <sys/resource.h>\n#include <unistd.h>\n#endif\n\n#ifdef JL_ASAN_ENABLED\nJL_DLLEXPORT const char* __asan_default_options() {\n    return \"allow_user_segv_handler=1:detect_leaks=0\";\n    // FIXME: enable LSAN after fixing leaks & defining __lsan_default_suppressions(),\n    //        or defining __lsan_default_options = exitcode=0 once publicly available\n    //        (here and in flisp/flmain.c)\n}\n#endif\n\nsize_t jl_page_size;\n\nvoid jl_init_stack_limits(int ismaster)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n#ifdef _OS_WINDOWS_\n    (void)ismaster;\n#  ifdef _COMPILER_MICROSOFT_\n#    ifdef _P64\n    void **tib = (void**)__readgsqword(0x30);\n#    else\n    void **tib = (void**)__readfsdword(0x18);\n#    endif\n#  else\n    void **tib;\n#    ifdef _P64\n    __asm__(\"movq %%gs:0x30, %0\" : \"=r\" (tib) : : );\n#    else\n    __asm__(\"movl %%fs:0x18, %0\" : \"=r\" (tib) : : );\n#    endif\n#  endif\n    // https://en.wikipedia.org/wiki/Win32_Thread_Information_Block\n    ptls->stack_hi = (char*)tib[1]; // Stack Base / Bottom of stack (high address)\n    ptls->stack_lo = (char*)tib[2]; // Stack Limit / Ceiling of stack (low address)\n#else\n#  ifdef JULIA_ENABLE_THREADING\n    // Only use pthread_*_np functions to get stack address for non-master\n    // threads since it seems to return bogus values for master thread on Linux\n    // and possibly OSX.\n    if (!ismaster) {\n#    if defined(_OS_LINUX_)\n        pthread_attr_t attr;\n        pthread_getattr_np(pthread_self(), &attr);\n        void *stackaddr;\n        size_t stacksize;\n        pthread_attr_getstack(&attr, &stackaddr, &stacksize);\n        pthread_attr_destroy(&attr);\n        ptls->stack_lo = (char*)stackaddr;\n        ptls->stack_hi = (char*)stackaddr + stacksize;\n        return;\n#    elif defined(_OS_DARWIN_)\n        extern void *pthread_get_stackaddr_np(pthread_t thread);\n        extern size_t pthread_get_stacksize_np(pthread_t thread);\n        pthread_t thread = pthread_self();\n        void *stackaddr = pthread_get_stackaddr_np(thread);\n        size_t stacksize = pthread_get_stacksize_np(thread);\n        ptls->stack_lo = (char*)stackaddr;\n        ptls->stack_hi = (char*)stackaddr + stacksize;\n        return;\n#    elif defined(_OS_FREEBSD_)\n        pthread_attr_t attr;\n        pthread_attr_init(&attr);\n        pthread_attr_get_np(pthread_self(), &attr);\n        void *stackaddr;\n        size_t stacksize;\n        pthread_attr_getstack(&attr, &stackaddr, &stacksize);\n        pthread_attr_destroy(&attr);\n        ptls->stack_lo = (char*)stackaddr;\n        ptls->stack_hi = (char*)stackaddr + stacksize;\n        return;\n#    else\n#      warning \"Getting stack size for thread is not supported.\"\n#    endif\n    }\n#  else\n    (void)ismaster;\n#  endif\n    struct rlimit rl;\n    getrlimit(RLIMIT_STACK, &rl);\n    size_t stack_size = rl.rlim_cur;\n    ptls->stack_hi = (char*)&stack_size;\n    ptls->stack_lo = ptls->stack_hi - stack_size;\n#endif\n}\n\nstatic void jl_find_stack_bottom(void)\n{\n#if !defined(_OS_WINDOWS_)\n#if defined(JL_ASAN_ENABLED) || defined(JL_MSAN_ENABLED)\n    struct rlimit rl;\n\n    // When using the sanitizers, increase stack size because they bloat\n    // stack usage\n    const rlim_t kStackSize = 64 * 1024 * 1024;   // 64MiB stack\n    int result;\n\n    result = getrlimit(RLIMIT_STACK, &rl);\n    if (result == 0) {\n        if (rl.rlim_cur < kStackSize) {\n            rl.rlim_cur = kStackSize;\n            result = setrlimit(RLIMIT_STACK, &rl);\n            if (result != 0) {\n                fprintf(stderr, \"setrlimit returned result = %d\\n\", result);\n            }\n        }\n    }\n#endif\n#endif\n    jl_init_stack_limits(1);\n}\n\nstruct uv_shutdown_queue_item { uv_handle_t *h; struct uv_shutdown_queue_item *next; };\nstruct uv_shutdown_queue { struct uv_shutdown_queue_item *first; struct uv_shutdown_queue_item *last; };\n\nstatic void jl_uv_exitcleanup_add(uv_handle_t *handle, struct uv_shutdown_queue *queue)\n{\n    struct uv_shutdown_queue_item *item = (struct uv_shutdown_queue_item*)malloc(sizeof(struct uv_shutdown_queue_item));\n    item->h = handle;\n    item->next = NULL;\n    if (queue->last) queue->last->next = item;\n    if (!queue->first) queue->first = item;\n    queue->last = item;\n}\n\nstatic void jl_uv_exitcleanup_walk(uv_handle_t *handle, void *arg)\n{\n    jl_uv_exitcleanup_add(handle, (struct uv_shutdown_queue*)arg);\n}\n\nvoid jl_write_coverage_data(void);\nvoid jl_write_malloc_log(void);\nvoid jl_write_compiler_output(void);\n\nstatic struct uv_shutdown_queue_item *next_shutdown_queue_item(struct uv_shutdown_queue_item *item)\n{\n    struct uv_shutdown_queue_item *rv = item->next;\n    free(item);\n    return rv;\n}\n\nvoid jl_init_timing(void);\nvoid jl_destroy_timing(void);\nvoid jl_uv_call_close_callback(jl_value_t *val);\n\nstatic void jl_close_item_atexit(uv_handle_t *handle)\n{\n    if (handle->type != UV_FILE && uv_is_closing(handle))\n        return;\n    switch(handle->type) {\n    case UV_PROCESS:\n        // cause Julia to forget about the Process object\n        if (handle->data)\n            jl_uv_call_close_callback((jl_value_t*)handle->data);\n        // and make libuv think it is already dead\n        ((uv_process_t*)handle)->pid = 0;\n        // fall-through\n    case UV_TTY:\n    case UV_UDP:\n    case UV_TCP:\n    case UV_NAMED_PIPE:\n    case UV_POLL:\n    case UV_TIMER:\n    case UV_ASYNC:\n    case UV_FS_EVENT:\n    case UV_FS_POLL:\n    case UV_IDLE:\n    case UV_PREPARE:\n    case UV_CHECK:\n    case UV_SIGNAL:\n    case UV_FILE:\n        // These will be shutdown as appropriate by jl_close_uv\n        jl_close_uv(handle);\n        break;\n    case UV_HANDLE:\n    case UV_STREAM:\n    default:\n        assert(0 && \"not a valid libuv handle\");\n    }\n}\n\nJL_DLLEXPORT void jl_atexit_hook(int exitcode)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n\n    if (exitcode == 0)\n        jl_write_compiler_output();\n    jl_print_gc_stats(JL_STDERR);\n    if (jl_options.code_coverage)\n        jl_write_coverage_data();\n    if (jl_options.malloc_log)\n        jl_write_malloc_log();\n    if (jl_base_module) {\n        jl_value_t *f = jl_get_global(jl_base_module, jl_symbol(\"_atexit\"));\n        if (f != NULL) {\n            JL_TRY {\n                size_t last_age = ptls->world_age;\n                ptls->world_age = jl_get_world_counter();\n                jl_apply(&f, 1);\n                ptls->world_age = last_age;\n            }\n            JL_CATCH {\n                jl_printf(JL_STDERR, \"\\natexit hook threw an error: \");\n                jl_static_show(JL_STDERR, ptls->exception_in_transit);\n            }\n        }\n    }\n\n    // replace standard output streams with something that we can still print to\n    // after the finalizers from base/stream.jl close the TTY\n    JL_STDOUT = (uv_stream_t*) STDOUT_FILENO;\n    JL_STDERR = (uv_stream_t*) STDERR_FILENO;\n\n    jl_gc_run_all_finalizers(ptls);\n\n    uv_loop_t *loop = jl_global_event_loop();\n\n    if (loop == NULL) {\n        return;\n    }\n\n    struct uv_shutdown_queue queue = {NULL, NULL};\n    uv_walk(loop, jl_uv_exitcleanup_walk, &queue);\n    struct uv_shutdown_queue_item *item = queue.first;\n    if (ptls->current_task != NULL) {\n        while (item) {\n            JL_TRY {\n                while (item) {\n                    jl_close_item_atexit(item->h);\n                    item = next_shutdown_queue_item(item);\n                }\n            }\n            JL_CATCH {\n                //error handling -- continue cleanup, as much as possible\n                uv_unref(item->h);\n                jl_printf(JL_STDERR, \"error during exit cleanup: close: \");\n                jl_static_show(JL_STDERR, ptls->exception_in_transit);\n                item = next_shutdown_queue_item(item);\n            }\n        }\n    }\n    else {\n        while (item) {\n            jl_close_item_atexit(item->h);\n            item = next_shutdown_queue_item(item);\n        }\n    }\n\n    // force libuv to spin until everything has finished closing\n    loop->stop_flag = 0;\n    while (uv_run(loop, UV_RUN_DEFAULT)) { }\n\n    jl_destroy_timing();\n#ifdef ENABLE_TIMINGS\n    jl_print_timings();\n#endif\n}\n\nvoid jl_get_builtin_hooks(void);\nvoid jl_get_builtins(void);\n\nJL_DLLEXPORT void *jl_dl_handle;\nvoid *jl_RTLD_DEFAULT_handle;\nJL_DLLEXPORT void *jl_exe_handle;\n#ifdef _OS_WINDOWS_\nvoid *jl_ntdll_handle;\nvoid *jl_kernel32_handle;\nvoid *jl_crtdll_handle;\nvoid *jl_winsock_handle;\n#endif\n\nuv_loop_t *jl_io_loop;\n\n#ifndef _OS_WINDOWS_\n#define UV_STREAM_READABLE 0x20   /* The stream is readable */\n#define UV_STREAM_WRITABLE 0x40   /* The stream is writable */\n#endif\n\n#ifdef _OS_WINDOWS_\nint uv_dup(uv_os_fd_t fd, uv_os_fd_t* dupfd) {\n    HANDLE current_process;\n\n    if (fd == UV_STDIN_FD || fd == UV_STDOUT_FD || fd == UV_STDERR_FD)\n        fd = GetStdHandle((DWORD)(uintptr_t) fd);\n\n    /* _get_osfhandle will sometimes return -2 in case of an error. This seems */\n    /* to happen when fd <= 2 and the process' corresponding stdio handle is */\n    /* set to NULL. Unfortunately DuplicateHandle will happily duplicate */\n    /* (HANDLE) -2, so this situation goes unnoticed until someone tries to */\n    /* use the duplicate. Therefore we filter out known-invalid handles here. */\n    if (fd == INVALID_HANDLE_VALUE ||\n        fd == NULL ||\n        fd == (HANDLE) -2) {\n        *dupfd = INVALID_HANDLE_VALUE;\n        return ERROR_INVALID_HANDLE;\n    }\n\n    current_process = GetCurrentProcess();\n\n    if (!DuplicateHandle(current_process,\n                         fd,\n                         current_process,\n                         dupfd,\n                         0,\n                         TRUE,\n                         DUPLICATE_SAME_ACCESS)) {\n        *dupfd = INVALID_HANDLE_VALUE;\n        return GetLastError();\n    }\n\n    return 0;\n}\n#else\nint uv_dup(uv_os_fd_t fd, uv_os_fd_t* dupfd) {\n    if ((*dupfd = fcntl(fd, F_DUPFD_CLOEXEC, 3)) == -1)\n        return -errno;\n    return 0;\n}\n#endif\n\nstatic void *init_stdio_handle(const char *stdio, uv_os_fd_t fd, int readable)\n{\n    void *handle;\n    int err;\n    // Duplicate the file descriptor so we can later dup it over if we want to redirect\n    // STDIO without having to worry about closing the associated libuv object.\n    // This also helps limit the impact other libraries can cause on our file handle.\n    if ((err = uv_dup(fd, &fd)))\n        jl_errorf(\"error initializing %s in uv_dup: %s (%s %d)\", stdio, uv_strerror(err), uv_err_name(err), err);\n    switch(uv_guess_handle(fd)) {\n    case UV_TTY:\n        handle = malloc(sizeof(uv_tty_t));\n        if ((err = uv_tty_init(jl_io_loop, (uv_tty_t*)handle, fd, readable))) {\n            jl_errorf(\"error initializing %s in uv_tty_init: %s (%s %d)\", stdio, uv_strerror(err), uv_err_name(err), err);\n        }\n        ((uv_tty_t*)handle)->data = NULL;\n        uv_tty_set_mode((uv_tty_t*)handle, UV_TTY_MODE_NORMAL); // initialized cooked stdio\n        break;\n    default:\n        assert(0 && \"missing case for uv_guess_handle return handling\");\n        JL_FALLTHROUGH;\n    case UV_UDP:\n        JL_FALLTHROUGH;\n    case UV_UNKNOWN_HANDLE:\n        // dup the descriptor with a new one pointing at the bit bucket ...\n#if defined(_OS_WINDOWS_)\n        CloseHandle(fd);\n        fd = CreateFile(\"NUL\", readable ? FILE_GENERIC_READ : FILE_GENERIC_WRITE | FILE_READ_ATTRIBUTES,\n                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);\n#else\n        {\n            int nullfd;\n            nullfd = open(\"/dev/null\", O_RDWR, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH /* 0666 */);\n            dup2(nullfd, fd);\n            close(nullfd);\n        }\n#endif\n        // ...and continue on as in the UV_FILE case\n        JL_FALLTHROUGH;\n    case UV_FILE:\n        handle = malloc(sizeof(jl_uv_file_t));\n        {\n            jl_uv_file_t *file = (jl_uv_file_t*)handle;\n            file->loop = jl_io_loop;\n            file->type = UV_FILE;\n            file->file = fd;\n            file->data = NULL;\n        }\n        break;\n    case UV_NAMED_PIPE:\n        handle = malloc(sizeof(uv_pipe_t));\n        if ((err = uv_pipe_init(jl_io_loop, (uv_pipe_t*)handle, 0))) {\n            jl_errorf(\"error initializing %s in uv_pipe_init: %s (%s %d)\", stdio, uv_strerror(err), uv_err_name(err), err);\n        }\n        if ((err = uv_pipe_open((uv_pipe_t*)handle, fd))) {\n            jl_errorf(\"error initializing %s in uv_pipe_open: %s (%s %d)\", stdio, uv_strerror(err), uv_err_name(err), err);\n        }\n#ifndef _OS_WINDOWS_\n        // remove flags set erroneously by libuv:\n        if (readable)\n            ((uv_pipe_t*)handle)->flags &= ~UV_STREAM_WRITABLE;\n        else\n            ((uv_pipe_t*)handle)->flags &= ~UV_STREAM_READABLE;\n#endif\n        ((uv_pipe_t*)handle)->data = NULL;\n        break;\n    case UV_TCP:\n        handle = malloc(sizeof(uv_tcp_t));\n        if ((err = uv_tcp_init(jl_io_loop, (uv_tcp_t*)handle))) {\n            jl_errorf(\"error initializing %s in uv_tcp_init: %s (%s %d)\", stdio, uv_strerror(err), uv_err_name(err), err);\n        }\n        if ((err = uv_tcp_open((uv_tcp_t*)handle, (uv_os_sock_t)fd))) {\n            jl_errorf(\"error initializing %s in uv_tcp_open: %s (%s %d)\", stdio, uv_strerror(err), uv_err_name(err), err);\n        }\n        ((uv_tcp_t*)handle)->data = NULL;\n        break;\n    }\n    return handle;\n}\n\nvoid init_stdio(void)\n{\n    JL_STDIN  = (uv_stream_t*)init_stdio_handle(\"stdin\", UV_STDIN_FD, 1);\n    JL_STDOUT = (uv_stream_t*)init_stdio_handle(\"stdout\", UV_STDOUT_FD, 0);\n    JL_STDERR = (uv_stream_t*)init_stdio_handle(\"stderr\", UV_STDERR_FD, 0);\n    jl_flush_cstdio();\n}\n\n#ifdef JL_USE_INTEL_JITEVENTS\nchar jl_using_intel_jitevents; // Non-zero if running under Intel VTune Amplifier\n#endif\n\n#ifdef JL_USE_OPROFILE_JITEVENTS\nchar jl_using_oprofile_jitevents = 0; // Non-zero if running under OProfile\n#endif\n\n#ifdef JL_USE_PERF_JITEVENTS\nchar jl_using_perf_jitevents = 0;\n#endif\n\nint isabspath(const char *in)\n{\n#ifdef _OS_WINDOWS_\n    char c0 = in[0];\n    if (c0 == '/' || c0 == '\\\\') {\n        return 1; // absolute path relative to %CD% (current drive), or UNC\n    }\n    else if (c0 && in[1] == ':') {\n        char c2 = in[2];\n        return c2 == '/' || c2 == '\\\\'; // absolute path with drive name\n    }\n#else\n    if (in[0] == '/') return 1; // absolute path\n#endif\n    return 0; // relative path\n}\n\nstatic char *abspath(const char *in, int nprefix)\n{ // compute an absolute path location, so that chdir doesn't change the file reference\n  // ignores (copies directly over) nprefix characters at the start of abspath\n#ifndef _OS_WINDOWS_\n    char *out = realpath(in + nprefix, NULL);\n    if (out) {\n        if (nprefix > 0) {\n            size_t sz = strlen(out) + 1;\n            char *cpy = (char*)malloc(sz + nprefix);\n            if (!cpy)\n                jl_errorf(\"fatal error: failed to allocate memory: %s\", strerror(errno));\n            memcpy(cpy, in, nprefix);\n            memcpy(cpy + nprefix, out, sz);\n            free(out);\n            out = cpy;\n        }\n    }\n    else {\n        size_t sz = strlen(in + nprefix) + 1;\n        if (in[nprefix] == PATHSEPSTRING[0]) {\n            out = (char*)malloc(sz + nprefix);\n            if (!out)\n                jl_errorf(\"fatal error: failed to allocate memory: %s\", strerror(errno));\n            memcpy(out, in, sz + nprefix);\n        }\n        else {\n            size_t path_size = PATH_MAX;\n            char *path = (char*)malloc(PATH_MAX);\n            if (!path)\n                jl_errorf(\"fatal error: failed to allocate memory: %s\", strerror(errno));\n            if (uv_cwd(path, &path_size)) {\n                jl_error(\"fatal error: unexpected error while retrieving current working directory\");\n            }\n            out = (char*)malloc(path_size + 1 + sz + nprefix);\n            memcpy(out, in, nprefix);\n            memcpy(out + nprefix, path, path_size);\n            out[nprefix + path_size] = PATHSEPSTRING[0];\n            memcpy(out + nprefix + path_size + 1, in + nprefix, sz);\n            free(path);\n        }\n    }\n#else\n    DWORD n = GetFullPathName(in + nprefix, 0, NULL, NULL);\n    if (n <= 0) {\n        jl_error(\"fatal error: jl_options.image_file path too long or GetFullPathName failed\");\n    }\n    char *out = (char*)malloc(n + nprefix);\n    DWORD m = GetFullPathName(in + nprefix, n, out + nprefix, NULL);\n    if (n != m + 1) {\n        jl_error(\"fatal error: jl_options.image_file path too long or GetFullPathName failed\");\n    }\n    memcpy(out, in, nprefix);\n#endif\n    return out;\n}\n\nstatic void jl_resolve_sysimg_location(JL_IMAGE_SEARCH rel)\n{   // this function resolves the paths in jl_options to absolute file locations as needed\n    // and it replaces the pointers to `julia_bindir`, `julia_bin`, `image_file`, and output file paths\n    // it may fail, print an error, and exit(1) if any of these paths are longer than PATH_MAX\n    //\n    // note: if you care about lost memory, you should call the appropriate `free()` function\n    // on the original pointer for each `char*` you've inserted into `jl_options`, after\n    // calling `julia_init()`\n    char *free_path = (char*)malloc(PATH_MAX);\n    size_t path_size = PATH_MAX;\n    if (uv_exepath(free_path, &path_size)) {\n        jl_error(\"fatal error: unexpected error while retrieving exepath\");\n    }\n    if (path_size >= PATH_MAX) {\n        jl_error(\"fatal error: jl_options.julia_bin path too long\");\n    }\n    jl_options.julia_bin = (char*)malloc(path_size+1);\n    memcpy((char*)jl_options.julia_bin, free_path, path_size);\n    ((char*)jl_options.julia_bin)[path_size] = '\\0';\n    if (!jl_options.julia_bindir) {\n        jl_options.julia_bindir = getenv(\"JULIA_BINDIR\");\n        if (!jl_options.julia_bindir) {\n            jl_options.julia_bindir = dirname(free_path);\n        }\n    }\n    if (jl_options.julia_bindir)\n        jl_options.julia_bindir = abspath(jl_options.julia_bindir, 0);\n    free(free_path);\n    free_path = NULL;\n    if (jl_options.image_file) {\n        if (rel == JL_IMAGE_JULIA_HOME && !isabspath(jl_options.image_file)) {\n            // build time path, relative to JULIA_BINDIR\n            free_path = (char*)malloc(PATH_MAX);\n            int n = snprintf(free_path, PATH_MAX, \"%s\" PATHSEPSTRING \"%s\",\n                             jl_options.julia_bindir, jl_options.image_file);\n            if (n >= PATH_MAX || n < 0) {\n                jl_error(\"fatal error: jl_options.image_file path too long\");\n            }\n            jl_options.image_file = free_path;\n        }\n        if (jl_options.image_file)\n            jl_options.image_file = abspath(jl_options.image_file, 0);\n        if (free_path) {\n            free(free_path);\n            free_path = NULL;\n        }\n    }\n    if (jl_options.outputo)\n        jl_options.outputo = abspath(jl_options.outputo, 0);\n    if (jl_options.outputji)\n        jl_options.outputji = abspath(jl_options.outputji, 0);\n    if (jl_options.outputbc)\n        jl_options.outputbc = abspath(jl_options.outputbc, 0);\n    if (jl_options.machine_file)\n        jl_options.machine_file = abspath(jl_options.machine_file, 0);\n\n    const char **cmdp = jl_options.cmds;\n    if (cmdp) {\n        for (; *cmdp; cmdp++) {\n            const char *cmd = *cmdp;\n            if (cmd[0] == 'L') {\n                *cmdp = abspath(cmd, 1);\n            }\n        }\n    }\n}\n\nstatic void jl_set_io_wait(int v)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    ptls->io_wait = v;\n}\n\nvoid _julia_init(JL_IMAGE_SEARCH rel)\n{\n    jl_init_timing();\n#ifdef JULIA_ENABLE_THREADING\n    // Make sure we finalize the tls callback before starting any threads.\n    jl_get_ptls_states_getter();\n#endif\n    jl_ptls_t ptls = jl_get_ptls_states();\n    jl_safepoint_init();\n    libsupport_init();\n    ios_set_io_wait_func = jl_set_io_wait;\n    jl_io_loop = uv_default_loop(); // this loop will internal events (spawning process etc.),\n                                    // best to call this first, since it also initializes libuv\n    jl_init_signal_async();\n    restore_signals();\n\n    jl_resolve_sysimg_location(rel);\n    // loads sysimg if available, and conditionally sets jl_options.cpu_target\n    if (jl_options.image_file)\n        jl_preload_sysimg_so(jl_options.image_file);\n    if (jl_options.cpu_target == NULL)\n        jl_options.cpu_target = \"native\";\n\n    jl_page_size = jl_getpagesize();\n    uint64_t total_mem = uv_get_total_memory();\n    if (total_mem >= (size_t)-1) {\n        total_mem = (size_t)-1;\n    }\n    jl_arr_xtralloc_limit = total_mem / 100;  // Extra allocation limited to 1% of total RAM\n    jl_find_stack_bottom();\n    jl_dl_handle = jl_load_dynamic_library(NULL, JL_RTLD_DEFAULT);\n#ifdef _OS_WINDOWS_\n    jl_ntdll_handle = jl_dlopen(\"ntdll.dll\", 0); // bypass julia's pathchecking for system dlls\n    jl_kernel32_handle = jl_dlopen(\"kernel32.dll\", 0);\n#if defined(_MSC_VER) && _MSC_VER == 1800\n    jl_crtdll_handle = jl_dlopen(\"msvcr120.dll\", 0);\n#else\n    jl_crtdll_handle = jl_dlopen(\"msvcrt.dll\", 0);\n#endif\n    jl_winsock_handle = jl_dlopen(\"ws2_32.dll\", 0);\n    jl_exe_handle = GetModuleHandleA(NULL);\n    SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_LINES);\n    if (!SymInitialize(GetCurrentProcess(), NULL, 1)) {\n        jl_printf(JL_STDERR, \"WARNING: failed to initialize stack walk info\\n\");\n    }\n    needsSymRefreshModuleList = 0;\n    HMODULE jl_dbghelp = (HMODULE) jl_dlopen(\"dbghelp.dll\", 0);\n    if (jl_dbghelp)\n        hSymRefreshModuleList = (BOOL (WINAPI*)(HANDLE)) jl_dlsym(jl_dbghelp, \"SymRefreshModuleList\");\n#else\n    jl_exe_handle = jl_dlopen(NULL, JL_RTLD_NOW);\n#ifdef RTLD_DEFAULT\n    jl_RTLD_DEFAULT_handle = RTLD_DEFAULT;\n#else\n    jl_RTLD_DEFAULT_handle = jl_exe_handle;\n#endif\n#endif\n\n#if defined(JL_USE_INTEL_JITEVENTS)\n    const char *jit_profiling = getenv(\"ENABLE_JITPROFILING\");\n    if (jit_profiling && atoi(jit_profiling)) {\n        jl_using_intel_jitevents = 1;\n    }\n#endif\n\n#if defined(JL_USE_OPROFILE_JITEVENTS)\n    const char *jit_profiling = getenv(\"ENABLE_JITPROFILING\");\n    if (jit_profiling && atoi(jit_profiling)) {\n        jl_using_oprofile_jitevents = 1;\n    }\n#endif\n\n#if defined(JL_USE_PERF_JITEVENTS)\n    const char *jit_profiling = getenv(\"ENABLE_JITPROFILING\");\n    if (jit_profiling && atoi(jit_profiling)) {\n        jl_using_perf_jitevents= 1;\n    }\n#endif\n\n#if defined(__linux__)\n    int ncores = jl_cpu_threads();\n    if (ncores > 1) {\n        cpu_set_t cpumask;\n        CPU_ZERO(&cpumask);\n        for(int i=0; i < ncores; i++) {\n            CPU_SET(i, &cpumask);\n        }\n        sched_setaffinity(0, sizeof(cpu_set_t), &cpumask);\n    }\n#endif\n\n    jl_init_threading();\n\n    jl_gc_init();\n    jl_gc_enable(0);\n    jl_init_types();\n    jl_init_frontend();\n    jl_init_tasks();\n    jl_init_root_task(ptls->stack_lo, ptls->stack_hi-ptls->stack_lo);\n\n#ifdef ENABLE_TIMINGS\n    jl_root_task->timing_stack = jl_root_timing;\n#endif\n\n    init_stdio();\n    // libuv stdio cleanup depends on jl_init_tasks() because JL_TRY is used in jl_atexit_hook()\n\n    if ((jl_options.outputo || jl_options.outputbc) &&\n        (jl_options.code_coverage || jl_options.malloc_log)) {\n        jl_error(\"cannot generate code-coverage or track allocation information while generating a .o or .bc output file\");\n    }\n\n    jl_init_codegen();\n\n    jl_start_threads();\n\n    jl_an_empty_vec_any = (jl_value_t*)jl_alloc_vec_any(0);\n    jl_init_serializer();\n    jl_init_intrinsic_properties();\n\n    if (!jl_options.image_file) {\n        jl_core_module = jl_new_module(jl_symbol(\"Core\"));\n        jl_type_typename->mt->module = jl_core_module;\n        jl_top_module = jl_core_module;\n        ptls->current_module = jl_core_module;\n        jl_init_intrinsic_functions();\n        jl_init_primitives();\n        jl_get_builtins();\n\n        jl_new_main_module();\n        jl_internal_main_module = jl_main_module;\n\n        ptls->current_module = jl_core_module;\n        for (int t = 0; t < jl_n_threads; t++) {\n            jl_all_tls_states[t]->root_task->current_module = jl_core_module;\n        }\n\n        jl_load(jl_core_module, \"boot.jl\");\n        jl_get_builtin_hooks();\n        jl_init_box_caches();\n    }\n\n    if (jl_options.image_file) {\n        JL_TRY {\n            jl_restore_system_image(jl_options.image_file);\n        }\n        JL_CATCH {\n            jl_printf(JL_STDERR, \"error during init:\\n\");\n            jl_static_show(JL_STDERR, ptls->exception_in_transit);\n            jl_printf(JL_STDERR, \"\\n\");\n            jl_exit(1);\n        }\n    }\n\n    // set module field of primitive types\n    int i;\n    void **table = jl_core_module->bindings.table;\n    for(i=1; i < jl_core_module->bindings.size; i+=2) {\n        if (table[i] != HT_NOTFOUND) {\n            jl_binding_t *b = (jl_binding_t*)table[i];\n            jl_value_t *v = b->value;\n            if (v) {\n                if (jl_is_unionall(v))\n                    v = jl_unwrap_unionall(v);\n                if (jl_is_datatype(v)) {\n                    jl_datatype_t *tt = (jl_datatype_t*)v;\n                    tt->name->module = jl_core_module;\n                    if (tt->name->mt)\n                        tt->name->mt->module = jl_core_module;\n                }\n            }\n        }\n    }\n\n    // the Main module is the one which is always open, and set as the\n    // current module for bare (non-module-wrapped) toplevel expressions.\n    // it does \"using Base\" if Base is available.\n    if (jl_base_module != NULL) {\n        jl_add_standard_imports(jl_main_module);\n    }\n    ptls->current_module = jl_main_module;\n    for (int t = 0; t < jl_n_threads; t++) {\n        jl_all_tls_states[t]->root_task->current_module = jl_main_module;\n    }\n\n    // This needs to be after jl_start_threads\n    if (jl_options.handle_signals == JL_OPTIONS_HANDLE_SIGNALS_ON)\n        jl_install_default_signal_handlers();\n\n    jl_gc_enable(1);\n\n    if (jl_options.image_file && (!jl_generating_output() || jl_options.incremental) && jl_module_init_order) {\n        jl_array_t *init_order = jl_module_init_order;\n        JL_GC_PUSH1(&init_order);\n        jl_module_init_order = NULL;\n        int i, l = jl_array_len(init_order);\n        for (i = 0; i < l; i++) {\n            jl_value_t *mod = jl_array_ptr_ref(init_order, i);\n            jl_module_run_initializer((jl_module_t*)mod);\n        }\n        JL_GC_POP();\n    }\n\n    if (jl_options.handle_signals == JL_OPTIONS_HANDLE_SIGNALS_ON)\n        jl_install_sigint_handler();\n}\n\nstatic jl_value_t *core(const char *name)\n{\n    return jl_get_global(jl_core_module, jl_symbol(name));\n}\n\n// fetch references to things defined in boot.jl\nvoid jl_get_builtin_hooks(void)\n{\n    int t;\n    for (t = 0; t < jl_n_threads; t++) {\n        jl_ptls_t ptls2 = jl_all_tls_states[t];\n        ptls2->root_task->tls = jl_nothing;\n        ptls2->root_task->donenotify = jl_nothing;\n        ptls2->root_task->exception = jl_nothing;\n        ptls2->root_task->result = jl_nothing;\n    }\n\n    jl_char_type    = (jl_datatype_t*)core(\"Char\");\n    jl_int8_type    = (jl_datatype_t*)core(\"Int8\");\n    jl_int16_type   = (jl_datatype_t*)core(\"Int16\");\n    jl_uint16_type  = (jl_datatype_t*)core(\"UInt16\");\n\n    jl_float16_type = (jl_datatype_t*)core(\"Float16\");\n    jl_float32_type = (jl_datatype_t*)core(\"Float32\");\n    jl_float64_type = (jl_datatype_t*)core(\"Float64\");\n    jl_floatingpoint_type = (jl_datatype_t*)core(\"AbstractFloat\");\n    jl_number_type = (jl_datatype_t*)core(\"Number\");\n    jl_signed_type = (jl_datatype_t*)core(\"Signed\");\n    jl_datatype_t *jl_unsigned_type = (jl_datatype_t*)core(\"Unsigned\");\n    jl_datatype_t *jl_integer_type = (jl_datatype_t*)core(\"Integer\");\n    jl_bool_type->super = jl_integer_type;\n    jl_uint8_type->super = jl_unsigned_type;\n    jl_int32_type->super = jl_signed_type;\n    jl_int64_type->super = jl_signed_type;\n    jl_uint32_type->super = jl_unsigned_type;\n    jl_uint64_type->super = jl_unsigned_type;\n\n    jl_errorexception_type = (jl_datatype_t*)core(\"ErrorException\");\n    jl_stackovf_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"StackOverflowError\"));\n    jl_diverror_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"DivideError\"));\n    jl_undefref_exception  = jl_new_struct_uninit((jl_datatype_t*)core(\"UndefRefError\"));\n    jl_undefvarerror_type  = (jl_datatype_t*)core(\"UndefVarError\");\n    jl_interrupt_exception = jl_new_struct_uninit((jl_datatype_t*)core(\"InterruptException\"));\n    jl_boundserror_type    = (jl_datatype_t*)core(\"BoundsError\");\n    jl_memory_exception    = jl_new_struct_uninit((jl_datatype_t*)core(\"OutOfMemoryError\"));\n    jl_readonlymemory_exception = jl_new_struct_uninit((jl_datatype_t*)core(\"ReadOnlyMemoryError\"));\n    jl_typeerror_type = (jl_datatype_t*)core(\"TypeError\");\n\n#ifdef SEGV_EXCEPTION\n    jl_segv_exception      = jl_new_struct_uninit((jl_datatype_t*)core(\"SegmentationFault\"));\n#endif\n\n    jl_weakref_type = (jl_datatype_t*)core(\"WeakRef\");\n    jl_vecelement_typename = ((jl_datatype_t*)jl_unwrap_unionall(core(\"VecElement\")))->name;\n\n    jl_argumenterror_type = (jl_datatype_t*)core(\"ArgumentError\");\n    jl_methoderror_type = (jl_datatype_t*)core(\"MethodError\");\n    jl_loaderror_type = (jl_datatype_t*)core(\"LoadError\");\n    jl_initerror_type = (jl_datatype_t*)core(\"InitError\");\n}\n\nvoid jl_get_builtins(void)\n{\n    jl_builtin_throw = core(\"throw\");           jl_builtin_is = core(\"===\");\n    jl_builtin_typeof = core(\"typeof\");         jl_builtin_sizeof = core(\"sizeof\");\n    jl_builtin_issubtype = core(\"<:\");          jl_builtin_isa = core(\"isa\");\n    jl_builtin_typeassert = core(\"typeassert\"); jl_builtin__apply = core(\"_apply\");\n    jl_builtin_isdefined = core(\"isdefined\");   jl_builtin_nfields = core(\"nfields\");\n    jl_builtin_tuple = core(\"tuple\");           jl_builtin_svec = core(\"svec\");\n    jl_builtin_getfield = core(\"getfield\");     jl_builtin_setfield = core(\"setfield!\");\n    jl_builtin_fieldtype = core(\"fieldtype\");   jl_builtin_arrayref = core(\"arrayref\");\n    jl_builtin_arrayset = core(\"arrayset\");     jl_builtin_arraysize = core(\"arraysize\");\n    jl_builtin_apply_type = core(\"apply_type\"); jl_builtin_applicable = core(\"applicable\");\n    jl_builtin_invoke = core(\"invoke\");         jl_builtin__expr = core(\"_expr\");\n    jl_builtin_ifelse = core(\"ifelse\");\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/src/julia.h": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n#ifndef JULIA_H\n#define JULIA_H\n\n//** Configuration options that affect the Julia ABI **//\n// if this is not defined, only individual dimension sizes are\n// stored and not total length, to save space.\n#define STORE_ARRAY_LEN\n//** End Configuration options **//\n\n#include \"libsupport.h\"\n#include <stdint.h>\n#include <string.h>\n\n#include \"htable.h\"\n#include \"arraylist.h\"\n#include \"analyzer_annotations.h\"\n\n#include <setjmp.h>\n#ifndef _OS_WINDOWS_\n#  define jl_jmp_buf sigjmp_buf\n#  if defined(_CPU_ARM_) || defined(_CPU_PPC_)\n#    define MAX_ALIGN 8\n#  elif defined(_CPU_AARCH64_)\n// int128 is 16 bytes aligned on aarch64\n#    define MAX_ALIGN 16\n#  else\n#    define MAX_ALIGN sizeof(void*)\n#  endif\n#else\n#  define jl_jmp_buf jmp_buf\n#  include <malloc.h> //for _resetstkoflw\n#  define MAX_ALIGN 8\n#endif\n\n#ifdef _P64\n#define NWORDS(sz) (((sz)+7)>>3)\n#else\n#define NWORDS(sz) (((sz)+3)>>2)\n#endif\n\n#if defined(__GNUC__)\n#  define JL_NORETURN __attribute__ ((noreturn))\n#  define JL_CONST_FUNC __attribute__((const))\n#  define JL_USED_FUNC __attribute__((used))\n#  define JL_SECTION(name) __attribute__((section(name)))\n#elif defined(_COMPILER_MICROSOFT_)\n#  define JL_NORETURN __declspec(noreturn)\n// This is the closest I can find for __attribute__((const))\n#  define JL_CONST_FUNC __declspec(noalias)\n// Does MSVC have this?\n#  define JL_USED_FUNC\n// TODO: Figure out what to do on MSVC\n#  define JL_SECTION(x)\n#else\n#  define JL_NORETURN\n#  define JL_CONST_FUNC\n#  define JL_USED_FUNC\n#endif\n\n#define container_of(ptr, type, member) \\\n    ((type *) ((char *)(ptr) - offsetof(type, member)))\n\ntypedef struct _jl_taggedvalue_t jl_taggedvalue_t;\n\n#include \"atomics.h\"\n#include \"tls.h\"\n#include \"julia_threads.h\"\n#include \"julia_assert.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// core data types ------------------------------------------------------------\n\n// the common fields are hidden before the pointer, but the following macro is\n// used to indicate which types below are subtypes of jl_value_t\n#define JL_DATA_TYPE\n\ntypedef struct _jl_value_t jl_value_t;\n\nstruct _jl_taggedvalue_bits {\n    uintptr_t gc:2;\n};\n\nJL_EXTENSION struct _jl_taggedvalue_t {\n    union {\n        uintptr_t header;\n        jl_taggedvalue_t *next;\n        jl_value_t *type; // 16-byte aligned\n        struct _jl_taggedvalue_bits bits;\n    };\n    // jl_value_t value;\n};\n\n#ifdef __clang_analyzer__\nJL_DLLEXPORT jl_taggedvalue_t *jl_astaggedvalue(jl_value_t *v JL_PROPAGATES_ROOT) JL_NOTSAFEPOINT;\njl_value_t *jl_valueof(jl_taggedvalue_t *tv JL_PROPAGATES_ROOT) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_typeof(jl_value_t *v JL_PROPAGATES_ROOT) JL_NOTSAFEPOINT;\n#else\n#define jl_astaggedvalue(v)                                             \\\n    ((jl_taggedvalue_t*)((char*)(v) - sizeof(jl_taggedvalue_t)))\n#define jl_valueof(v)                                           \\\n    ((jl_value_t*)((char*)(v) + sizeof(jl_taggedvalue_t)))\n#define jl_typeof(v)                                                    \\\n    ((jl_value_t*)(jl_astaggedvalue(v)->header & ~(uintptr_t)15))\n#endif\nstatic inline void jl_set_typeof(void *v, void *t) JL_NOTSAFEPOINT\n{\n    // Do not call this on a value that is already initialized.\n    jl_taggedvalue_t *tag = jl_astaggedvalue(v);\n    tag->type = (jl_value_t*)t;\n}\n#define jl_typeis(v,t) (jl_typeof(v)==(jl_value_t*)(t))\n\n// Symbols are interned strings (hash-consed) stored as an invasive binary tree.\n// The string data is nul-terminated and hangs off the end of the struct.\ntypedef struct _jl_sym_t {\n    JL_DATA_TYPE\n    struct _jl_sym_t *left;\n    struct _jl_sym_t *right;\n    uintptr_t hash;    // precomputed hash value\n    // JL_ATTRIBUTE_ALIGN_PTRSIZE(char name[]);\n} jl_sym_t;\n\n// A numbered SSA value, for optimized code analysis and generation\n// the `id` is a unique, small number\ntypedef struct _jl_ssavalue_t {\n    JL_DATA_TYPE\n    ssize_t id;\n} jl_ssavalue_t;\n\n// A SimpleVector is an immutable pointer array\n// Data is stored at the end of this variable-length struct.\ntypedef struct {\n    JL_DATA_TYPE\n    size_t length;\n    // pointer size aligned\n    // jl_value_t *data[];\n} jl_svec_t;\n\ntypedef struct {\n    /*\n      how - allocation style\n      0 = data is inlined, or a foreign pointer we don't manage\n      1 = julia-allocated buffer that needs to be marked\n      2 = malloc-allocated pointer this array object manages\n      3 = has a pointer to the object that owns the data\n    */\n    uint16_t how:2;\n    uint16_t ndims:10;\n    uint16_t pooled:1;\n    uint16_t ptrarray:1;  // representation is pointer array\n    uint16_t isshared:1;  // data is shared by multiple Arrays\n    uint16_t isaligned:1; // data allocated with memalign\n} jl_array_flags_t;\n\nJL_EXTENSION typedef struct {\n    JL_DATA_TYPE\n    void *data;\n#ifdef STORE_ARRAY_LEN\n    size_t length;\n#endif\n    jl_array_flags_t flags;\n    uint16_t elsize;\n    uint32_t offset;  // for 1-d only. does not need to get big.\n    size_t nrows;\n    union {\n        // 1d\n        size_t maxsize;\n        // Nd\n        size_t ncols;\n    };\n    // other dim sizes go here for ndims > 2\n\n    // followed by alignment padding and inline data, or owner pointer\n} jl_array_t;\n\n// compute # of extra words needed to store dimensions\nSTATIC_INLINE int jl_array_ndimwords(uint32_t ndims) JL_NOTSAFEPOINT\n{\n    return (ndims < 3 ? 0 : ndims-2);\n}\n\ntypedef struct _jl_datatype_t jl_tupletype_t;\nstruct _jl_method_instance_t;\n\n// TypeMap is an implicitly defined type\n// that can consist of any of the following nodes:\n//   typedef TypeMap Union{TypeMapLevel, TypeMapEntry, Nothing}\n// it forms a roughly tree-shaped structure, consisting of nodes of TypeMapLevels\n// which split the tree when possible, for example based on the key into the tuple type at `offs`\n// when key is a leaftype, (but only when the tree has enough entries for this to be\n// more efficient than storing them sorted linearly)\n// otherwise the leaf entries are stored sorted, linearly\nunion jl_typemap_t {\n    struct _jl_typemap_level_t *node;\n    struct _jl_typemap_entry_t *leaf;\n    struct _jl_value_t *unknown; // nothing\n};\n\ntypedef jl_value_t *(jl_call_t)(struct _jl_method_instance_t*, jl_value_t**, uint32_t);\ntypedef jl_call_t *jl_callptr_t;\n\n// \"speccall\" calling convention signatures.\n// This describes some of the special ABI used by compiled julia functions.\nJL_DLLEXPORT extern jl_call_t jl_fptr_trampoline;\n\nJL_DLLEXPORT extern jl_call_t jl_fptr_args;\ntypedef jl_value_t *(*jl_fptr_args_t)(jl_value_t*, jl_value_t**, uint32_t);\n\nJL_DLLEXPORT extern jl_call_t jl_fptr_const_return;\n\nJL_DLLEXPORT extern jl_call_t jl_fptr_sparam;\ntypedef jl_value_t *(*jl_fptr_sparam_t)(jl_svec_t*, jl_value_t*, jl_value_t**, uint32_t);\n\nJL_DLLEXPORT extern jl_call_t jl_fptr_interpret_call;\ntypedef jl_value_t *(*jl_fptr_interpret_t)(struct _jl_method_instance_t*, jl_value_t*, jl_value_t**, uint32_t, jl_svec_t*);\n\nJL_EXTENSION typedef union {\n    void* fptr;\n    jl_fptr_args_t fptr1;\n    jl_fptr_sparam_t fptr3;\n    jl_fptr_interpret_t fptr4;\n} jl_generic_specptr_t;\n\ntypedef struct _jl_llvm_functions_t {\n    const char *functionObject;         // jl_callptr_t llvm Function name\n    const char *specFunctionObject;     // specialized llvm Function name (on sig+rettype)\n} jl_llvm_functions_t;\n\n// This type describes a single function body\ntypedef struct _jl_code_info_t {\n    jl_array_t *code;  // Any array of statements\n    jl_value_t *codelocs; // Int32 array of indicies into the line table\n    jl_value_t *method_for_inference_limit_heuristics; // optional method used during inference\n    jl_value_t *ssavaluetypes;  // types of ssa values (or count of them)\n    jl_value_t *linetable; // Table of locations\n    jl_array_t *ssaflags; // flags associated with each statement:\n        // 0 = inbounds\n        // 1,2 = <reserved> inlinehint,always-inline,noinline\n        // 3 = <reserved> strict-ieee (strictfp)\n        // 4-6 = <unused>\n        // 7 = has out-of-band info\n    jl_array_t *slotflags;  // local var bit flags\n    jl_array_t *slotnames; // names of local variables\n    uint8_t inferred;\n    uint8_t inlineable;\n    uint8_t propagate_inbounds;\n    uint8_t pure;\n} jl_code_info_t;\n\n// This type describes a single method definition, and stores data\n// shared by the specializations of a function.\ntypedef struct _jl_method_t {\n    JL_DATA_TYPE\n    jl_sym_t *name;  // for error reporting\n    struct _jl_module_t *module;\n    jl_sym_t *file;\n    int32_t line;\n\n    // method's type signature. redundant with TypeMapEntry->specTypes\n    jl_value_t *sig;\n    size_t min_world;\n\n    // list of potentially-ambiguous methods (nothing = none, Vector{Any} of Methods otherwise)\n    jl_value_t *ambig;\n\n    // table of all argument types for which we've inferred or compiled this code\n    union jl_typemap_t specializations;\n\n    jl_svec_t *sparam_syms;  // symbols giving static parameter names\n    jl_value_t *source;  // original code template (jl_code_info_t, but may be compressed), null for builtins\n    struct _jl_method_instance_t *unspecialized;  // unspecialized executable method instance, or null\n    jl_value_t *generator;  // executable code-generating function if available\n    jl_array_t *roots;  // pointers in generated code (shared to reduce memory), or null\n\n    // cache of specializations of this method for invoke(), i.e.\n    // cases where this method was called even though it was not necessarily\n    // the most specific for the argument types.\n    union jl_typemap_t invokes;\n\n    int32_t nargs;\n    int32_t called;        // bit flags: whether each of the first 8 arguments is called\n    int32_t nospecialize;  // bit flags: which arguments should not be specialized\n    uint8_t isva;\n    uint8_t pure;\n\n// hidden fields:\n    uint8_t traced;\n    // lock for modifications to the method\n    jl_mutex_t writelock;\n} jl_method_t;\n\n// This type caches the data for a specType signature specialization of a Method\ntypedef struct _jl_method_instance_t {\n    JL_DATA_TYPE\n    union {\n        jl_value_t *value; // generic accessor\n        struct _jl_module_t *module; // this is a toplevel thunk\n        jl_method_t *method; // method this is specialized from\n    } def; // context for this lambda definition\n    jl_value_t *specTypes;  // argument types this was specialized for\n    jl_value_t *rettype; // return type for fptr\n    jl_svec_t *sparam_vals; // static parameter values, indexed by def.method->sparam_syms\n    jl_array_t *backedges;\n    jl_value_t *inferred;  // inferred jl_code_info_t, or jl_nothing, or null\n    jl_value_t *inferred_const; // inferred constant return value, or null\n    size_t min_world;\n    size_t max_world;\n    uint8_t inInference; // flags to tell if inference is running on this function\n    uint8_t compile_traced; // if set will notify callback if this linfo is compiled\n    jl_callptr_t invoke; // jlcall entry point\n    jl_generic_specptr_t specptr;\n\n    // names of declarations in the JIT,\n    // suitable for referencing in LLVM IR\n    jl_llvm_functions_t functionObjectsDecls;\n} jl_method_instance_t;\n\n// all values are callable as Functions\ntypedef jl_value_t jl_function_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    jl_value_t *lb;   // lower bound\n    jl_value_t *ub;   // upper bound\n} jl_tvar_t;\n\n// UnionAll type (iterated union over all values of a variable in certain bounds)\n// written `body where lb<:var<:ub`\ntypedef struct {\n    JL_DATA_TYPE\n    jl_tvar_t *var;\n    jl_value_t *body;\n} jl_unionall_t;\n\n// represents the \"name\" part of a DataType, describing the syntactic structure\n// of a type and storing all data common to different instantiations of the type,\n// including a cache for hash-consed allocation of DataType objects.\ntypedef struct {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    struct _jl_module_t *module;\n    jl_svec_t *names;  // field names\n    // `wrapper` is either the only instantiation of the type (if no parameters)\n    // or a UnionAll accepting parameters to make an instantiation.\n    jl_value_t *wrapper;\n    jl_svec_t *cache;        // sorted array\n    jl_svec_t *linearcache;  // unsorted array\n    intptr_t hash;\n    struct _jl_methtable_t *mt;\n} jl_typename_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_value_t *a;\n    jl_value_t *b;\n} jl_uniontype_t;\n\n// in little-endian, isptr is always the first bit, avoiding the need for a branch in computing isptr\ntypedef struct {\n    uint8_t isptr:1;\n    uint8_t size:7;\n    uint8_t offset;   // offset relative to data start, excluding type tag\n} jl_fielddesc8_t;\n\ntypedef struct {\n    uint16_t isptr:1;\n    uint16_t size:15;\n    uint16_t offset;   // offset relative to data start, excluding type tag\n} jl_fielddesc16_t;\n\ntypedef struct {\n    uint32_t isptr:1;\n    uint32_t size:31;\n    uint32_t offset;   // offset relative to data start, excluding type tag\n} jl_fielddesc32_t;\n\ntypedef struct {\n    uint32_t nfields;\n    uint32_t alignment : 9; // strictest alignment over all fields\n    uint32_t haspadding : 1; // has internal undefined bytes\n    uint32_t npointers : 20; // number of pointer fields, top 4 bits are exponent (under-approximation)\n    uint32_t fielddesc_type : 2; // 0 -> 8, 1 -> 16, 2 -> 32\n    // union {\n    //     jl_fielddesc8_t field8[];\n    //     jl_fielddesc16_t field16[];\n    //     jl_fielddesc32_t field32[];\n    // };\n} jl_datatype_layout_t;\n\ntypedef struct _jl_datatype_t {\n    JL_DATA_TYPE\n    jl_typename_t *name;\n    struct _jl_datatype_t *super;\n    jl_svec_t *parameters;\n    jl_svec_t *types;\n    jl_svec_t *names;\n    jl_value_t *instance;  // for singletons\n    const jl_datatype_layout_t *layout;\n    int32_t size; // TODO: move to _jl_datatype_layout_t\n    int32_t ninitialized;\n    uint32_t uid;\n    uint8_t abstract;\n    uint8_t mutabl;\n    // memoized properties\n    uint8_t hasfreetypevars; // majority part of isconcrete computation\n    uint8_t isconcretetype; // whether this type can have instances\n    uint8_t isdispatchtuple; // aka isleaftupletype\n    uint8_t isbitstype; // relevant query for C-api and type-parameters\n    uint8_t zeroinit; // if one or more fields requires zero-initialization\n    uint8_t isinlinealloc; // if this is allocated inline\n    void *struct_decl;  //llvm::Type*\n    void *ditype; // llvm::MDNode* to be used as llvm::DIType(ditype)\n} jl_datatype_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_value_t *value;\n} jl_weakref_t;\n\ntypedef struct {\n    // not first-class\n    jl_sym_t *name;\n    jl_value_t *value;\n    jl_value_t *globalref;  // cached GlobalRef for this binding\n    struct _jl_module_t *owner;  // for individual imported bindings\n    uint8_t constp:1;\n    uint8_t exportp:1;\n    uint8_t imported:1;\n    uint8_t deprecated:2; // 0=not deprecated, 1=renamed, 2=moved to another package\n} jl_binding_t;\n\ntypedef struct {\n    uint64_t hi;\n    uint64_t lo;\n} jl_uuid_t;\n\ntypedef struct _jl_module_t {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    struct _jl_module_t *parent;\n    htable_t bindings;\n    arraylist_t usings;  // modules with all bindings potentially imported\n    uint64_t build_id;\n    jl_uuid_t uuid;\n    size_t primary_world;\n    uint32_t counter;\n    int32_t nospecialize;  // global bit flags: initialization for new methods\n    uint8_t istopmod;\n} jl_module_t;\n\n// one Type-to-Value entry\ntypedef struct _jl_typemap_entry_t {\n    JL_DATA_TYPE\n    struct _jl_typemap_entry_t *next; // invasive linked list\n    jl_tupletype_t *sig; // the type signature for this entry\n    jl_tupletype_t *simplesig; // a simple signature for fast rejection\n    jl_svec_t *guardsigs;\n    size_t min_world;\n    size_t max_world;\n    union {\n        jl_value_t *value; // generic accessor\n        jl_method_instance_t *linfo; // [nullable] for guard entries\n        jl_method_t *method;\n    } func;\n    // memoized properties of sig:\n    int8_t isleafsig; // isleaftype(sig) & !any(isType, sig) : unsorted and very fast\n    int8_t issimplesig; // all(isleaftype | isAny | isType | isVararg, sig) : sorted and fast\n    int8_t va; // isVararg(sig)\n} jl_typemap_entry_t;\n\n// one level in a TypeMap tree\n// indexed by key if it is a sublevel in an array\nstruct jl_ordereddict_t {\n    jl_array_t *indices; // Array{Int{8,16,32}}\n    jl_array_t *values; // Array{union jl_typemap_t}\n};\ntypedef struct _jl_typemap_level_t {\n    JL_DATA_TYPE\n    struct jl_ordereddict_t arg1;\n    struct jl_ordereddict_t targ;\n    jl_typemap_entry_t *linear; // union jl_typemap_t (but no more levels)\n    union jl_typemap_t any; // type at offs is Any\n    jl_value_t *key; // [nullable]\n} jl_typemap_level_t;\n\n// contains the TypeMap for one Type\ntypedef struct _jl_methtable_t {\n    JL_DATA_TYPE\n    jl_sym_t *name;\n    union jl_typemap_t defs;\n    union jl_typemap_t cache;\n    intptr_t max_args;  // max # of non-vararg arguments in a signature\n    jl_value_t *kwsorter;  // keyword argument sorter function\n    jl_module_t *module; // used for incremental serialization to locate original binding\n    jl_array_t *backedges;\n    jl_mutex_t writelock;\n} jl_methtable_t;\n\ntypedef struct {\n    JL_DATA_TYPE\n    jl_sym_t *head;\n    jl_array_t *args;\n} jl_expr_t;\n\n// constants and type objects -------------------------------------------------\n\n// kinds\nextern JL_DLLEXPORT jl_datatype_t *jl_typeofbottom_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_datatype_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_uniontype_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_unionall_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_tvar_type JL_GLOBALLY_ROOTED;\n\nextern JL_DLLEXPORT jl_datatype_t *jl_any_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_unionall_t *jl_type_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_unionall_t *jl_typetype_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_typename_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_typename_t *jl_type_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_sym_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_symbol_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_ssavalue_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_abstractslot_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_slotnumber_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_typedslot_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_simplevector_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_typename_t *jl_tuple_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_typename_t *jl_vecelement_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_anytuple_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_emptytuple_type JL_GLOBALLY_ROOTED;\n#define jl_tuple_type jl_anytuple_type\nextern JL_DLLEXPORT jl_unionall_t *jl_anytuple_type_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_unionall_t *jl_vararg_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_typename_t *jl_vararg_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_task_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_function_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_builtin_type JL_GLOBALLY_ROOTED;\n\nextern JL_DLLEXPORT jl_value_t *jl_bottom_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_method_instance_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_code_info_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_method_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_module_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_unionall_t *jl_abstractarray_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_unionall_t *jl_densearray_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_unionall_t *jl_array_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_typename_t *jl_array_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_weakref_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_abstractstring_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_string_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_errorexception_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_argumenterror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_loaderror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_initerror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_typeerror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_methoderror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_undefvarerror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_lineinfonode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_value_t *jl_stackovf_exception JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_value_t *jl_memory_exception JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_value_t *jl_readonlymemory_exception JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_value_t *jl_diverror_exception JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_value_t *jl_undefref_exception JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_value_t *jl_interrupt_exception JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_boundserror_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_value_t *jl_an_empty_vec_any JL_GLOBALLY_ROOTED;\n\nextern JL_DLLEXPORT jl_datatype_t *jl_bool_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_char_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_int8_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_uint8_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_int16_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_uint16_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_int32_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_uint32_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_int64_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_uint64_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_float16_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_float32_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_float64_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_floatingpoint_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_number_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_void_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_signed_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_voidpointer_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_unionall_t *jl_pointer_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_unionall_t *jl_ref_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_typename_t *jl_pointer_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_typename_t *jl_namedtuple_typename JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_unionall_t *jl_namedtuple_type JL_GLOBALLY_ROOTED;\n\nextern JL_DLLEXPORT jl_value_t *jl_array_uint8_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_value_t *jl_array_any_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_value_t *jl_array_symbol_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_value_t *jl_array_int32_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_expr_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_globalref_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_linenumbernode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_gotonode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_phinode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_pinode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_phicnode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_upsilonnode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_quotenode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_newvarnode_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_intrinsic_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_methtable_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_typemap_level_type JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_datatype_t *jl_typemap_entry_type JL_GLOBALLY_ROOTED;\n\nextern JL_DLLEXPORT jl_svec_t *jl_emptysvec JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_value_t *jl_emptytuple JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_value_t *jl_true JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_value_t *jl_false JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_value_t *jl_nothing JL_GLOBALLY_ROOTED;\n\n// some important symbols\nextern JL_DLLEXPORT jl_sym_t *jl_incomplete_sym;\n\n// gc -------------------------------------------------------------------------\n\ntypedef struct _jl_gcframe_t {\n    size_t nroots;\n    struct _jl_gcframe_t *prev;\n    // actual roots go here\n} jl_gcframe_t;\n\n// NOTE: it is the caller's responsibility to make sure arguments are\n// rooted such that the gc can see them on the stack.\n// `foo(f(), g())` is not safe,\n// since the result of `f()` is not rooted during the call to `g()`,\n// and the arguments to foo are not gc-protected during the call to foo.\n// foo can't do anything about it, so the caller must do:\n// jl_value_t *x=NULL, *y=NULL; JL_GC_PUSH2(&x, &y);\n// x = f(); y = g(); foo(x, y)\n\n#define jl_pgcstack (jl_get_ptls_states()->pgcstack)\n\n#ifdef __clang_analyzer__\n\n// When running with the analyzer make these real function calls, that are\n// easier to detect in the analyzer\nextern void JL_GC_PUSH1(void *) JL_NOTSAFEPOINT;\nextern void JL_GC_PUSH2(void *, void *) JL_NOTSAFEPOINT;\nextern void JL_GC_PUSH3(void *, void *, void *)  JL_NOTSAFEPOINT;\nextern void JL_GC_PUSH4(void *, void *, void *, void *)  JL_NOTSAFEPOINT;\nextern void JL_GC_PUSH5(void *, void *, void *, void *, void *)  JL_NOTSAFEPOINT;\nextern void _JL_GC_PUSHARGS(jl_value_t **, size_t) JL_NOTSAFEPOINT;\n// This is necessary, because otherwise the analyzer considers this undefined\n// behavior and terminates the exploration\n#define JL_GC_PUSHARGS(rts_var, n)     \\\n  rts_var = (jl_value_t **)alloca(sizeof(void*) * n); \\\n  memset(rts_var,0,sizeof(void*) * n); \\\n  _JL_GC_PUSHARGS(rts_var, n);\n\nextern void JL_GC_POP() JL_NOTSAFEPOINT;\n\n#else\n\n#define JL_GC_PUSH1(arg1)                                                 \\\n  void *__gc_stkf[] = {(void*)3, jl_pgcstack, arg1};                      \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH2(arg1, arg2)                                           \\\n  void *__gc_stkf[] = {(void*)5, jl_pgcstack, arg1, arg2};                \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH3(arg1, arg2, arg3)                                     \\\n  void *__gc_stkf[] = {(void*)7, jl_pgcstack, arg1, arg2, arg3};          \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH4(arg1, arg2, arg3, arg4)                               \\\n  void *__gc_stkf[] = {(void*)9, jl_pgcstack, arg1, arg2, arg3, arg4};    \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH5(arg1, arg2, arg3, arg4, arg5)                               \\\n  void *__gc_stkf[] = {(void*)11, jl_pgcstack, arg1, arg2, arg3, arg4, arg5};    \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSH6(arg1, arg2, arg3, arg4, arg5, arg6)                      \\\n  void *__gc_stkf[] = {(void*)13, jl_pgcstack, arg1, arg2, arg3, arg4, arg5, arg6}; \\\n  jl_pgcstack = (jl_gcframe_t*)__gc_stkf;\n\n#define JL_GC_PUSHARGS(rts_var,n)                               \\\n  rts_var = ((jl_value_t**)alloca(((n)+2)*sizeof(jl_value_t*)))+2;    \\\n  ((void**)rts_var)[-2] = (void*)(((size_t)(n))<<1);                  \\\n  ((void**)rts_var)[-1] = jl_pgcstack;                          \\\n  memset((void*)rts_var, 0, (n)*sizeof(jl_value_t*));           \\\n  jl_pgcstack = (jl_gcframe_t*)&(((void**)rts_var)[-2])\n\n#define JL_GC_POP() (jl_pgcstack = jl_pgcstack->prev)\n\n#endif\n\nJL_DLLEXPORT int jl_gc_enable(int on);\nJL_DLLEXPORT int jl_gc_is_enabled(void);\nJL_DLLEXPORT int64_t jl_gc_total_bytes(void);\nJL_DLLEXPORT uint64_t jl_gc_total_hrtime(void);\nJL_DLLEXPORT int64_t jl_gc_diff_total_bytes(void);\n\nJL_DLLEXPORT void jl_gc_collect(int);\n\nJL_DLLEXPORT void jl_gc_add_finalizer(jl_value_t *v, jl_function_t *f);\nJL_DLLEXPORT void jl_finalize(jl_value_t *o);\nJL_DLLEXPORT jl_weakref_t *jl_gc_new_weakref(jl_value_t *value);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_0w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_1w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_2w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_alloc_3w(void);\nJL_DLLEXPORT jl_value_t *jl_gc_allocobj(size_t sz);\nJL_DLLEXPORT void jl_gc_use(jl_value_t *a);\n\nJL_DLLEXPORT void jl_clear_malloc_data(void);\n\n// GC write barriers\nJL_DLLEXPORT void jl_gc_queue_root(jl_value_t *root) JL_NOTSAFEPOINT; // root isa jl_value_t*\n\nSTATIC_INLINE void jl_gc_wb(void *parent, void *ptr) JL_NOTSAFEPOINT\n{\n    // parent and ptr isa jl_value_t*\n    if (__unlikely(jl_astaggedvalue(parent)->bits.gc == 3 &&\n                   (jl_astaggedvalue(ptr)->bits.gc & 1) == 0))\n        jl_gc_queue_root((jl_value_t*)parent);\n}\n\nSTATIC_INLINE void jl_gc_wb_back(void *ptr) JL_NOTSAFEPOINT // ptr isa jl_value_t*\n{\n    // if ptr is old\n    if (__unlikely(jl_astaggedvalue(ptr)->bits.gc == 3)) {\n        jl_gc_queue_root((jl_value_t*)ptr);\n    }\n}\n\nJL_DLLEXPORT void *jl_gc_managed_malloc(size_t sz);\nJL_DLLEXPORT void *jl_gc_managed_realloc(void *d, size_t sz, size_t oldsz,\n                                         int isaligned, jl_value_t *owner);\n\n// object accessors -----------------------------------------------------------\n\n#define jl_svec_len(t)              (((jl_svec_t*)(t))->length)\n#define jl_svec_set_len_unsafe(t,n) (((jl_svec_t*)(t))->length=(n))\n#define jl_svec_data(t) ((jl_value_t**)((char*)(t) + sizeof(jl_svec_t)))\n\nSTATIC_INLINE jl_value_t *jl_svecref(void *t JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT\n{\n    assert(jl_typeis(t,jl_simplevector_type));\n    assert(i < jl_svec_len(t));\n    return jl_svec_data(t)[i];\n}\nSTATIC_INLINE jl_value_t *jl_svecset(\n    void *t JL_ROOTING_ARGUMENT JL_PROPAGATES_ROOT,\n    size_t i, void *x JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT\n{\n    assert(jl_typeis(t,jl_simplevector_type));\n    assert(i < jl_svec_len(t));\n    jl_svec_data(t)[i] = (jl_value_t*)x;\n    if (x) jl_gc_wb(t, x);\n    return (jl_value_t*)x;\n}\n\n#ifdef STORE_ARRAY_LEN\n#define jl_array_len(a)   (((jl_array_t*)(a))->length)\n#else\nJL_DLLEXPORT size_t jl_array_len_(jl_array_t *a);\n#define jl_array_len(a)   jl_array_len_((jl_array_t*)(a))\n#endif\n#define jl_array_data(a)  ((void*)((jl_array_t*)(a))->data)\n#define jl_array_dim(a,i) ((&((jl_array_t*)(a))->nrows)[i])\n#define jl_array_dim0(a)  (((jl_array_t*)(a))->nrows)\n#define jl_array_nrows(a) (((jl_array_t*)(a))->nrows)\n#define jl_array_ndims(a) ((int32_t)(((jl_array_t*)a)->flags.ndims))\n#define jl_array_data_owner_offset(ndims) (offsetof(jl_array_t,ncols) + sizeof(size_t)*(1+jl_array_ndimwords(ndims))) // in bytes\n#define jl_array_data_owner(a) (*((jl_value_t**)((char*)a + jl_array_data_owner_offset(jl_array_ndims(a)))))\n\nJL_DLLEXPORT char *jl_array_typetagdata(jl_array_t *a);\n\nSTATIC_INLINE jl_value_t *jl_array_ptr_ref(void *a, size_t i) JL_NOTSAFEPOINT\n{\n    assert(i < jl_array_len(a));\n    return ((jl_value_t**)(jl_array_data(a)))[i];\n}\nSTATIC_INLINE jl_value_t *jl_array_ptr_set(\n    void *a JL_ROOTING_ARGUMENT, size_t i,\n    void *x JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT\n{\n    assert(i < jl_array_len(a));\n    ((jl_value_t**)(jl_array_data(a)))[i] = (jl_value_t*)x;\n    if (x) {\n        if (((jl_array_t*)a)->flags.how == 3) {\n            a = jl_array_data_owner(a);\n        }\n        jl_gc_wb(a, x);\n    }\n    return (jl_value_t*)x;\n}\n\nSTATIC_INLINE uint8_t jl_array_uint8_ref(void *a, size_t i) JL_NOTSAFEPOINT\n{\n    assert(i < jl_array_len(a));\n    assert(jl_typeis(a, jl_array_uint8_type));\n    return ((uint8_t*)(jl_array_data(a)))[i];\n}\nSTATIC_INLINE void jl_array_uint8_set(void *a, size_t i, uint8_t x) JL_NOTSAFEPOINT\n{\n    assert(i < jl_array_len(a));\n    assert(jl_typeis(a, jl_array_uint8_type));\n    ((uint8_t*)(jl_array_data(a)))[i] = x;\n}\n\n#define jl_exprarg(e,n) (((jl_value_t**)jl_array_data(((jl_expr_t*)(e))->args))[n])\n#define jl_exprargset(e, n, v) jl_array_ptr_set(((jl_expr_t*)(e))->args, n, v)\n#define jl_expr_nargs(e) jl_array_len(((jl_expr_t*)(e))->args)\n\n#define jl_fieldref(s,i) jl_get_nth_field(((jl_value_t*)(s)),i)\n#define jl_fieldref_noalloc(s,i) jl_get_nth_field_noalloc(((jl_value_t*)(s)),i)\n#define jl_nfields(v)    jl_datatype_nfields(jl_typeof(v))\n\n// Not using jl_fieldref to avoid allocations\n#define jl_linenode_line(x) (((intptr_t*)(x))[0])\n#define jl_linenode_file(x) (((jl_value_t**)(x))[1])\n#define jl_slot_number(x) (((intptr_t*)(x))[0])\n#define jl_typedslot_get_type(x) (((jl_value_t**)(x))[1])\n#define jl_gotonode_label(x) (((intptr_t*)(x))[0])\n#define jl_globalref_mod(s) (*(jl_module_t**)(s))\n#define jl_globalref_name(s) (((jl_sym_t**)(s))[1])\n#define jl_quotenode_value(x) (((jl_value_t**)x)[0])\n\n#define jl_nparams(t)  jl_svec_len(((jl_datatype_t*)(t))->parameters)\n#define jl_tparam0(t)  jl_svecref(((jl_datatype_t*)(t))->parameters, 0)\n#define jl_tparam1(t)  jl_svecref(((jl_datatype_t*)(t))->parameters, 1)\n#define jl_tparam(t,i) jl_svecref(((jl_datatype_t*)(t))->parameters, i)\n\n// get a pointer to the data in a datatype\n#define jl_data_ptr(v)  ((jl_value_t**)v)\n\n#define jl_array_ptr_data(a)   ((jl_value_t**)((jl_array_t*)a)->data)\n#define jl_string_data(s) ((char*)s + sizeof(void*))\n#define jl_string_len(s)  (*(size_t*)s)\n\n#define jl_gf_mtable(f) (((jl_datatype_t*)jl_typeof(f))->name->mt)\n#define jl_gf_name(f)   (jl_gf_mtable(f)->name)\n\n// struct type info\nSTATIC_INLINE jl_svec_t *jl_field_names(jl_datatype_t *st) JL_NOTSAFEPOINT\n{\n    jl_svec_t *names = st->names;\n    if (!names)\n        names = st->name->names;\n    return names;\n}\nSTATIC_INLINE jl_sym_t *jl_field_name(jl_datatype_t *st, size_t i) JL_NOTSAFEPOINT\n{\n    return (jl_sym_t*)jl_svecref(jl_field_names(st), i);\n}\n#define jl_field_type(st,i)    jl_svecref(((jl_datatype_t*)st)->types, (i))\n#define jl_field_count(st)     jl_svec_len(((jl_datatype_t*)st)->types)\n#define jl_datatype_size(t)    (((jl_datatype_t*)t)->size)\n#define jl_datatype_align(t)   (((jl_datatype_t*)t)->layout->alignment)\n#define jl_datatype_nbits(t)   ((((jl_datatype_t*)t)->size)*8)\n#define jl_datatype_nfields(t) (((jl_datatype_t*)(t))->layout->nfields)\n\n// inline version with strong type check to detect typos in a `->name` chain\nSTATIC_INLINE char *jl_symbol_name_(jl_sym_t *s) JL_NOTSAFEPOINT\n{\n    return (char*)s + LLT_ALIGN(sizeof(jl_sym_t), sizeof(void*));\n}\n#define jl_symbol_name(s) jl_symbol_name_(s)\n\n#define jl_dt_layout_fields(d) ((const char*)(d) + sizeof(jl_datatype_layout_t))\n\n#define DEFINE_FIELD_ACCESSORS(f)                                             \\\n    static inline uint32_t jl_field_##f(jl_datatype_t *st,                    \\\n                                        int i) JL_NOTSAFEPOINT                \\\n    {                                                                         \\\n        const jl_datatype_layout_t *ly = st->layout;                          \\\n        assert(i >= 0 && (size_t)i < ly->nfields);                            \\\n        if (ly->fielddesc_type == 0) {                                        \\\n            return ((const jl_fielddesc8_t*)jl_dt_layout_fields(ly))[i].f;    \\\n        }                                                                     \\\n        else if (ly->fielddesc_type == 1) {                                   \\\n            return ((const jl_fielddesc16_t*)jl_dt_layout_fields(ly))[i].f;   \\\n        }                                                                     \\\n        else {                                                                \\\n            return ((const jl_fielddesc32_t*)jl_dt_layout_fields(ly))[i].f;   \\\n        }                                                                     \\\n    }                                                                         \\\n\nDEFINE_FIELD_ACCESSORS(offset)\nDEFINE_FIELD_ACCESSORS(size)\nstatic inline int jl_field_isptr(jl_datatype_t *st, int i) JL_NOTSAFEPOINT\n{\n    const jl_datatype_layout_t *ly = st->layout;\n    assert(i >= 0 && (size_t)i < ly->nfields);\n    return ((const jl_fielddesc8_t*)(jl_dt_layout_fields(ly) + (i << (ly->fielddesc_type + 1))))->isptr;\n}\n\nstatic inline uint32_t jl_fielddesc_size(int8_t fielddesc_type) JL_NOTSAFEPOINT\n{\n    if (fielddesc_type == 0) {\n        return sizeof(jl_fielddesc8_t);\n    }\n    else if (fielddesc_type == 1) {\n        return sizeof(jl_fielddesc16_t);\n    }\n    else {\n        return sizeof(jl_fielddesc32_t);\n    }\n}\n\n#undef DEFINE_FIELD_ACCESSORS\n\nstatic inline int jl_is_layout_opaque(const jl_datatype_layout_t *l) JL_NOTSAFEPOINT\n{\n    return l->nfields == 0 && l->npointers > 0;\n}\n\n// basic predicates -----------------------------------------------------------\n#define jl_is_nothing(v)     (((jl_value_t*)(v)) == ((jl_value_t*)jl_nothing))\n#define jl_is_tuple(v)       (((jl_datatype_t*)jl_typeof(v))->name == jl_tuple_typename)\n#define jl_is_svec(v)        jl_typeis(v,jl_simplevector_type)\n#define jl_is_simplevector(v) jl_is_svec(v)\n#define jl_is_datatype(v)    jl_typeis(v,jl_datatype_type)\n#define jl_is_mutable(t)     (((jl_datatype_t*)t)->mutabl)\n#define jl_is_mutable_datatype(t) (jl_is_datatype(t) && (((jl_datatype_t*)t)->mutabl))\n#define jl_is_immutable(t)   (!((jl_datatype_t*)t)->mutabl)\n#define jl_is_immutable_datatype(t) (jl_is_datatype(t) && (!((jl_datatype_t*)t)->mutabl))\n#define jl_is_uniontype(v)   jl_typeis(v,jl_uniontype_type)\n#define jl_is_typevar(v)     jl_typeis(v,jl_tvar_type)\n#define jl_is_unionall(v)    jl_typeis(v,jl_unionall_type)\n#define jl_is_typename(v)    jl_typeis(v,jl_typename_type)\n#define jl_is_int8(v)        jl_typeis(v,jl_int8_type)\n#define jl_is_int16(v)       jl_typeis(v,jl_int16_type)\n#define jl_is_int32(v)       jl_typeis(v,jl_int32_type)\n#define jl_is_int64(v)       jl_typeis(v,jl_int64_type)\n#define jl_is_uint8(v)       jl_typeis(v,jl_uint8_type)\n#define jl_is_uint16(v)      jl_typeis(v,jl_uint16_type)\n#define jl_is_uint32(v)      jl_typeis(v,jl_uint32_type)\n#define jl_is_uint64(v)      jl_typeis(v,jl_uint64_type)\n#define jl_is_bool(v)        jl_typeis(v,jl_bool_type)\n#define jl_is_symbol(v)      jl_typeis(v,jl_sym_type)\n#define jl_is_ssavalue(v)    jl_typeis(v,jl_ssavalue_type)\n#define jl_is_slot(v)        (jl_typeis(v,jl_slotnumber_type) || jl_typeis(v,jl_typedslot_type))\n#define jl_is_expr(v)        jl_typeis(v,jl_expr_type)\n#define jl_is_globalref(v)   jl_typeis(v,jl_globalref_type)\n#define jl_is_gotonode(v)    jl_typeis(v,jl_gotonode_type)\n#define jl_is_pinode(v)      jl_typeis(v,jl_pinode_type)\n#define jl_is_phinode(v)     jl_typeis(v,jl_phinode_type)\n#define jl_is_phicnode(v)    jl_typeis(v,jl_phicnode_type)\n#define jl_is_upsilonnode(v) jl_typeis(v,jl_upsilonnode_type)\n#define jl_is_quotenode(v)   jl_typeis(v,jl_quotenode_type)\n#define jl_is_newvarnode(v)  jl_typeis(v,jl_newvarnode_type)\n#define jl_is_linenode(v)    jl_typeis(v,jl_linenumbernode_type)\n#define jl_is_method_instance(v) jl_typeis(v,jl_method_instance_type)\n#define jl_is_code_info(v) jl_typeis(v,jl_code_info_type)\n#define jl_is_method(v)      jl_typeis(v,jl_method_type)\n#define jl_is_module(v)      jl_typeis(v,jl_module_type)\n#define jl_is_mtable(v)      jl_typeis(v,jl_methtable_type)\n#define jl_is_task(v)        jl_typeis(v,jl_task_type)\n#define jl_is_string(v)      jl_typeis(v,jl_string_type)\n#define jl_is_cpointer(v)    jl_is_cpointer_type(jl_typeof(v))\n#define jl_is_pointer(v)     jl_is_cpointer_type(jl_typeof(v))\n#define jl_is_intrinsic(v)   jl_typeis(v,jl_intrinsic_type)\n#define jl_array_isbitsunion(a) (!(((jl_array_t*)(a))->flags.ptrarray) && jl_is_uniontype(jl_tparam0(jl_typeof(a))))\n\nJL_DLLEXPORT int jl_subtype(jl_value_t *a, jl_value_t *b);\n\nSTATIC_INLINE int jl_is_kind(jl_value_t *v) JL_NOTSAFEPOINT\n{\n    return (v==(jl_value_t*)jl_uniontype_type || v==(jl_value_t*)jl_datatype_type ||\n            v==(jl_value_t*)jl_unionall_type || v==(jl_value_t*)jl_typeofbottom_type);\n}\n\nSTATIC_INLINE int jl_is_type(jl_value_t *v) JL_NOTSAFEPOINT\n{\n    return jl_is_kind(jl_typeof(v));\n}\n\nSTATIC_INLINE int jl_is_primitivetype(void *v) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(v) && jl_is_immutable(v) &&\n            ((jl_datatype_t*)(v))->layout &&\n            jl_datatype_nfields(v) == 0 &&\n            jl_datatype_size(v) > 0);\n}\n\nSTATIC_INLINE int jl_is_structtype(void *v) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(v) &&\n            !((jl_datatype_t*)(v))->abstract &&\n            !jl_is_primitivetype(v));\n}\n\nSTATIC_INLINE int jl_isbits(void *t) JL_NOTSAFEPOINT // corresponding to isbits() in julia\n{\n    return (jl_is_datatype(t) && ((jl_datatype_t*)t)->isbitstype);\n}\n\nSTATIC_INLINE int jl_is_datatype_singleton(jl_datatype_t *d) JL_NOTSAFEPOINT\n{\n    return (d->instance != NULL);\n}\n\nSTATIC_INLINE int jl_is_abstracttype(void *v) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(v) && ((jl_datatype_t*)(v))->abstract);\n}\n\nSTATIC_INLINE int jl_is_array_type(void *t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_array_typename);\n}\n\nSTATIC_INLINE int jl_is_array(void *v) JL_NOTSAFEPOINT\n{\n    jl_value_t *t = jl_typeof(v);\n    return jl_is_array_type(t);\n}\n\nSTATIC_INLINE int jl_is_cpointer_type(jl_value_t *t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == ((jl_datatype_t*)jl_pointer_type->body)->name);\n}\n\nSTATIC_INLINE int jl_is_abstract_ref_type(jl_value_t *t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == ((jl_datatype_t*)jl_ref_type->body)->name);\n}\n\nSTATIC_INLINE int jl_is_tuple_type(void *t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_tuple_typename);\n}\n\nSTATIC_INLINE int jl_is_namedtuple_type(void *t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_namedtuple_typename);\n}\n\nSTATIC_INLINE int jl_is_vecelement_type(jl_value_t* t) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(t) &&\n            ((jl_datatype_t*)(t))->name == jl_vecelement_typename);\n}\n\nSTATIC_INLINE int jl_is_type_type(jl_value_t *v) JL_NOTSAFEPOINT\n{\n    return (jl_is_datatype(v) &&\n            ((jl_datatype_t*)(v))->name == ((jl_datatype_t*)jl_type_type->body)->name);\n}\n\n// object identity\nJL_DLLEXPORT int jl_egal(jl_value_t *a, jl_value_t *b) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uintptr_t jl_object_id(jl_value_t *v) JL_NOTSAFEPOINT;\n\n// type predicates and basic operations\nJL_DLLEXPORT int jl_has_free_typevars(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_has_typevar(jl_value_t *t, jl_tvar_t *v);\nJL_DLLEXPORT int jl_has_typevar_from_unionall(jl_value_t *t, jl_unionall_t *ua);\nJL_DLLEXPORT int jl_subtype_env_size(jl_value_t *t);\nJL_DLLEXPORT int jl_subtype_env(jl_value_t *x, jl_value_t *y, jl_value_t **env, int envsz);\nJL_DLLEXPORT int jl_isa(jl_value_t *a, jl_value_t *t);\nJL_DLLEXPORT int jl_types_equal(jl_value_t *a, jl_value_t *b) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_is_not_broken_subtype(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_type_union(jl_value_t **ts, size_t n);\nJL_DLLEXPORT jl_value_t *jl_type_intersection(jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT int jl_has_empty_intersection(jl_value_t *x, jl_value_t *y);\nJL_DLLEXPORT jl_value_t *jl_type_unionall(jl_tvar_t *v, jl_value_t *body);\nJL_DLLEXPORT const char *jl_typename_str(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT const char *jl_typeof_str(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_type_morespecific(jl_value_t *a, jl_value_t *b);\njl_value_t *jl_unwrap_unionall(jl_value_t *v) JL_NOTSAFEPOINT;\njl_value_t *jl_rewrap_unionall(jl_value_t *t, jl_value_t *u);\n\nSTATIC_INLINE int jl_is_dispatch_tupletype(jl_value_t *v) JL_NOTSAFEPOINT\n{\n    return jl_is_datatype(v) && ((jl_datatype_t*)v)->isdispatchtuple;\n}\n\nSTATIC_INLINE int jl_is_concrete_type(jl_value_t *v) JL_NOTSAFEPOINT\n{\n    return jl_is_datatype(v) && ((jl_datatype_t*)v)->isconcretetype;\n}\n\n// type constructors\nJL_DLLEXPORT jl_typename_t *jl_new_typename_in(jl_sym_t *name, jl_module_t *inmodule);\nJL_DLLEXPORT jl_tvar_t *jl_new_typevar(jl_sym_t *name, jl_value_t *lb, jl_value_t *ub);\nJL_DLLEXPORT jl_value_t *jl_instantiate_unionall(jl_unionall_t *u, jl_value_t *p);\nJL_DLLEXPORT jl_value_t *jl_apply_type(jl_value_t *tc, jl_value_t **params, size_t n);\nJL_DLLEXPORT jl_value_t *jl_apply_type1(jl_value_t *tc, jl_value_t *p1);\nJL_DLLEXPORT jl_value_t *jl_apply_type2(jl_value_t *tc, jl_value_t *p1, jl_value_t *p2);\nJL_DLLEXPORT jl_tupletype_t *jl_apply_tuple_type(jl_svec_t *params);\nJL_DLLEXPORT jl_tupletype_t *jl_apply_tuple_type_v(jl_value_t **p, size_t np);\nJL_DLLEXPORT jl_datatype_t *jl_new_datatype(jl_sym_t *name,\n                                            jl_module_t *module,\n                                            jl_datatype_t *super,\n                                            jl_svec_t *parameters,\n                                            jl_svec_t *fnames, jl_svec_t *ftypes,\n                                            int abstract, int mutabl,\n                                            int ninitialized);\nJL_DLLEXPORT jl_datatype_t *jl_new_primitivetype(jl_value_t *name,\n                                                 jl_module_t *module,\n                                                 jl_datatype_t *super,\n                                                 jl_svec_t *parameters, size_t nbits);\njl_datatype_t *jl_new_abstracttype(jl_value_t *name, jl_module_t *module,\n                                   jl_datatype_t *super, jl_svec_t *parameters);\n\n// constructors\nJL_DLLEXPORT jl_value_t *jl_new_bits(jl_value_t *bt, void *data);\nJL_DLLEXPORT jl_value_t *jl_new_struct(jl_datatype_t *type, ...);\nJL_DLLEXPORT jl_value_t *jl_new_structv(jl_datatype_t *type, jl_value_t **args,\n                                        uint32_t na);\nJL_DLLEXPORT jl_value_t *jl_new_struct_uninit(jl_datatype_t *type);\nJL_DLLEXPORT jl_method_instance_t *jl_new_method_instance_uninit(void);\nJL_DLLEXPORT jl_svec_t *jl_svec(size_t n, ...) JL_MAYBE_UNROOTED;\nJL_DLLEXPORT jl_svec_t *jl_svec1(void *a);\nJL_DLLEXPORT jl_svec_t *jl_svec2(void *a, void *b);\nJL_DLLEXPORT jl_svec_t *jl_alloc_svec(size_t n);\nJL_DLLEXPORT jl_svec_t *jl_alloc_svec_uninit(size_t n);\nJL_DLLEXPORT jl_svec_t *jl_svec_copy(jl_svec_t *a);\nJL_DLLEXPORT jl_svec_t *jl_svec_fill(size_t n, jl_value_t *x);\nJL_DLLEXPORT jl_value_t *jl_tupletype_fill(size_t n, jl_value_t *v);\nJL_DLLEXPORT jl_sym_t *jl_symbol(const char *str) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_sym_t *jl_symbol_lookup(const char *str) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_sym_t *jl_symbol_n(const char *str, size_t len) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_sym_t *jl_gensym(void);\nJL_DLLEXPORT jl_sym_t *jl_tagged_gensym(const char *str, int32_t len);\nJL_DLLEXPORT jl_sym_t *jl_get_root_symbol(void);\nJL_DLLEXPORT jl_value_t *jl_generic_function_def(jl_sym_t *name,\n                                                 jl_module_t *module,\n                                                 jl_value_t **bp, jl_value_t *bp_owner,\n                                                 jl_binding_t *bnd);\nJL_DLLEXPORT void jl_method_def(jl_svec_t *argdata, jl_code_info_t *f, jl_module_t *module);\nJL_DLLEXPORT jl_code_info_t *jl_code_for_staged(jl_method_instance_t *linfo);\nJL_DLLEXPORT jl_code_info_t *jl_copy_code_info(jl_code_info_t *src);\nJL_DLLEXPORT size_t jl_get_world_counter(void);\nJL_DLLEXPORT jl_function_t *jl_get_kwsorter(jl_value_t *ty);\nJL_DLLEXPORT jl_value_t *jl_box_bool(int8_t x) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_box_int8(int8_t x) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_box_uint8(uint8_t x) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_box_int16(int16_t x);\nJL_DLLEXPORT jl_value_t *jl_box_uint16(uint16_t x);\nJL_DLLEXPORT jl_value_t *jl_box_int32(int32_t x);\nJL_DLLEXPORT jl_value_t *jl_box_uint32(uint32_t x);\nJL_DLLEXPORT jl_value_t *jl_box_char(uint32_t x);\nJL_DLLEXPORT jl_value_t *jl_box_int64(int64_t x);\nJL_DLLEXPORT jl_value_t *jl_box_uint64(uint64_t x);\nJL_DLLEXPORT jl_value_t *jl_box_float32(float x);\nJL_DLLEXPORT jl_value_t *jl_box_float64(double x);\nJL_DLLEXPORT jl_value_t *jl_box_voidpointer(void *x);\nJL_DLLEXPORT jl_value_t *jl_box_ssavalue(size_t x);\nJL_DLLEXPORT jl_value_t *jl_box_slotnumber(size_t x);\nJL_DLLEXPORT int8_t jl_unbox_bool(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int8_t jl_unbox_int8(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint8_t jl_unbox_uint8(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int16_t jl_unbox_int16(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint16_t jl_unbox_uint16(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int32_t jl_unbox_int32(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint32_t jl_unbox_uint32(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int64_t jl_unbox_int64(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT uint64_t jl_unbox_uint64(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT float jl_unbox_float32(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT double jl_unbox_float64(jl_value_t *v) JL_NOTSAFEPOINT;\nJL_DLLEXPORT void *jl_unbox_voidpointer(jl_value_t *v) JL_NOTSAFEPOINT;\n\nJL_DLLEXPORT int jl_get_size(jl_value_t *val, size_t *pnt);\n\n#ifdef _P64\n#define jl_box_long(x)   jl_box_int64(x)\n#define jl_box_ulong(x)  jl_box_uint64(x)\n#define jl_unbox_long(x) jl_unbox_int64(x)\n#define jl_is_long(x)    jl_is_int64(x)\n#define jl_long_type     jl_int64_type\n#define jl_ulong_type    jl_uint64_type\n#else\n#define jl_box_long(x)   jl_box_int32(x)\n#define jl_box_ulong(x)  jl_box_uint32(x)\n#define jl_unbox_long(x) jl_unbox_int32(x)\n#define jl_is_long(x)    jl_is_int32(x)\n#define jl_long_type     jl_int32_type\n#define jl_ulong_type    jl_uint32_type\n#endif\n\n// Each tuple can exist in one of 4 Vararg states:\n//   NONE: no vararg                            Tuple{Int,Float32}\n//   INT: vararg with integer length            Tuple{Int,Vararg{Float32,2}}\n//   BOUND: vararg with bound TypeVar length    Tuple{Int,Vararg{Float32,N}}\n//   UNBOUND: vararg with unbound length        Tuple{Int,Vararg{Float32}}\ntypedef enum {\n    JL_VARARG_NONE    = 0,\n    JL_VARARG_INT     = 1,\n    JL_VARARG_BOUND   = 2,\n    JL_VARARG_UNBOUND = 3\n} jl_vararg_kind_t;\n\nSTATIC_INLINE int jl_is_vararg_type(jl_value_t *v) JL_NOTSAFEPOINT\n{\n    v = jl_unwrap_unionall(v);\n    return (jl_is_datatype(v) &&\n            ((jl_datatype_t*)(v))->name == jl_vararg_typename);\n}\n\nSTATIC_INLINE jl_value_t *jl_unwrap_vararg(jl_value_t *v) JL_NOTSAFEPOINT\n{\n    return jl_tparam0(jl_unwrap_unionall(v));\n}\n\nSTATIC_INLINE jl_vararg_kind_t jl_vararg_kind(jl_value_t *v) JL_NOTSAFEPOINT\n{\n    if (!jl_is_vararg_type(v))\n        return JL_VARARG_NONE;\n    jl_tvar_t *v1=NULL, *v2=NULL;\n    if (jl_is_unionall(v)) {\n        v1 = ((jl_unionall_t*)v)->var;\n        v = ((jl_unionall_t*)v)->body;\n        if (jl_is_unionall(v)) {\n            v2 = ((jl_unionall_t*)v)->var;\n            v = ((jl_unionall_t*)v)->body;\n        }\n    }\n    assert(jl_is_datatype(v));\n    jl_value_t *lenv = jl_tparam1(v);\n    if (jl_is_long(lenv))\n        return JL_VARARG_INT;\n    if (jl_is_typevar(lenv) && lenv != (jl_value_t*)v1 && lenv != (jl_value_t*)v2)\n        return JL_VARARG_BOUND;\n    return JL_VARARG_UNBOUND;\n}\n\nSTATIC_INLINE int jl_is_va_tuple(jl_datatype_t *t)\n{\n    assert(jl_is_tuple_type(t));\n    size_t l = jl_svec_len(t->parameters);\n    return (l>0 && jl_is_vararg_type(jl_tparam(t,l-1)));\n}\n\nSTATIC_INLINE jl_vararg_kind_t jl_va_tuple_kind(jl_datatype_t *t) JL_NOTSAFEPOINT\n{\n    t = (jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)t);\n    assert(jl_is_tuple_type(t));\n    size_t l = jl_svec_len(t->parameters);\n    if (l == 0)\n        return JL_VARARG_NONE;\n    return jl_vararg_kind(jl_tparam(t,l-1));\n}\n\n// structs\nJL_DLLEXPORT int         jl_field_index(jl_datatype_t *t, jl_sym_t *fld, int err);\nJL_DLLEXPORT jl_value_t *jl_get_nth_field(jl_value_t *v, size_t i);\n// Like jl_get_nth_field above, but asserts if it needs to allocate\nJL_DLLEXPORT jl_value_t *jl_get_nth_field_noalloc(jl_value_t *v JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;\nJL_DLLEXPORT jl_value_t *jl_get_nth_field_checked(jl_value_t *v, size_t i);\nJL_DLLEXPORT void        jl_set_nth_field(jl_value_t *v, size_t i,\n                                          jl_value_t *rhs);\nJL_DLLEXPORT int         jl_field_isdefined(jl_value_t *v, size_t i);\nJL_DLLEXPORT jl_value_t *jl_get_field(jl_value_t *o, const char *fld);\nJL_DLLEXPORT jl_value_t *jl_value_ptr(jl_value_t *a);\nJL_DLLEXPORT int jl_islayout_inline(jl_value_t *eltype, size_t *fsz, size_t *al) JL_NOTSAFEPOINT;\n\n// arrays\nJL_DLLEXPORT jl_array_t *jl_new_array(jl_value_t *atype, jl_value_t *dims);\nJL_DLLEXPORT jl_array_t *jl_reshape_array(jl_value_t *atype, jl_array_t *data,\n                                          jl_value_t *dims);\nJL_DLLEXPORT jl_array_t *jl_ptr_to_array_1d(jl_value_t *atype, void *data,\n                                            size_t nel, int own_buffer);\nJL_DLLEXPORT jl_array_t *jl_ptr_to_array(jl_value_t *atype, void *data,\n                                         jl_value_t *dims, int own_buffer);\n\nJL_DLLEXPORT jl_array_t *jl_alloc_array_1d(jl_value_t *atype, size_t nr);\nJL_DLLEXPORT jl_array_t *jl_alloc_array_2d(jl_value_t *atype, size_t nr,\n                                           size_t nc);\nJL_DLLEXPORT jl_array_t *jl_alloc_array_3d(jl_value_t *atype, size_t nr,\n                                           size_t nc, size_t z);\nJL_DLLEXPORT jl_array_t *jl_pchar_to_array(const char *str, size_t len);\nJL_DLLEXPORT jl_value_t *jl_pchar_to_string(const char *str, size_t len);\nJL_DLLEXPORT jl_value_t *jl_cstr_to_string(const char *str);\nJL_DLLEXPORT jl_value_t *jl_alloc_string(size_t len);\nJL_DLLEXPORT jl_value_t *jl_array_to_string(jl_array_t *a);\nJL_DLLEXPORT jl_array_t *jl_alloc_vec_any(size_t n);\nJL_DLLEXPORT jl_value_t *jl_arrayref(jl_array_t *a, size_t i);  // 0-indexed\nJL_DLLEXPORT jl_value_t *jl_ptrarrayref(jl_array_t *a JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;  // 0-indexed\nJL_DLLEXPORT void jl_arrayset(jl_array_t *a, jl_value_t *v, size_t i);  // 0-indexed\nJL_DLLEXPORT void jl_arrayunset(jl_array_t *a, size_t i);  // 0-indexed\nJL_DLLEXPORT int jl_array_isassigned(jl_array_t *a, size_t i);  // 0-indexed\nJL_DLLEXPORT void jl_array_grow_end(jl_array_t *a, size_t inc);\nJL_DLLEXPORT void jl_array_del_end(jl_array_t *a, size_t dec);\nJL_DLLEXPORT void jl_array_grow_beg(jl_array_t *a, size_t inc);\nJL_DLLEXPORT void jl_array_del_beg(jl_array_t *a, size_t dec);\nJL_DLLEXPORT void jl_array_sizehint(jl_array_t *a, size_t sz);\nJL_DLLEXPORT void jl_array_ptr_1d_push(jl_array_t *a, jl_value_t *item);\nJL_DLLEXPORT void jl_array_ptr_1d_append(jl_array_t *a, jl_array_t *a2);\nJL_DLLEXPORT jl_value_t *jl_apply_array_type(jl_value_t *type, size_t dim);\n// property access\nJL_DLLEXPORT void *jl_array_ptr(jl_array_t *a);\nJL_DLLEXPORT void *jl_array_eltype(jl_value_t *a);\nJL_DLLEXPORT int jl_array_rank(jl_value_t *a);\nJL_DLLEXPORT size_t jl_array_size(jl_value_t *a, int d);\n\n// strings\nJL_DLLEXPORT const char *jl_string_ptr(jl_value_t *s);\n\n// modules and global variables\nextern JL_DLLEXPORT jl_module_t *jl_main_module JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_module_t *jl_internal_main_module JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_module_t *jl_core_module JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_module_t *jl_base_module JL_GLOBALLY_ROOTED;\nextern JL_DLLEXPORT jl_module_t *jl_top_module JL_GLOBALLY_ROOTED;\nJL_DLLEXPORT jl_module_t *jl_new_module(jl_sym_t *name);\nJL_DLLEXPORT void jl_set_module_nospecialize(jl_module_t *self, int on);\n// get binding for reading\nJL_DLLEXPORT jl_binding_t *jl_get_binding(jl_module_t *m JL_PROPAGATES_ROOT, jl_sym_t *var);\nJL_DLLEXPORT jl_binding_t *jl_get_binding_or_error(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT jl_value_t *jl_module_globalref(jl_module_t *m, jl_sym_t *var);\n// get binding for assignment\nJL_DLLEXPORT jl_binding_t *jl_get_binding_wr(jl_module_t *m JL_PROPAGATES_ROOT, jl_sym_t *var, int error);\nJL_DLLEXPORT jl_binding_t *jl_get_binding_for_method_def(jl_module_t *m JL_PROPAGATES_ROOT,\n                                                         jl_sym_t *var);\nJL_DLLEXPORT int jl_boundp(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT int jl_defines_or_exports_p(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT int jl_binding_resolved_p(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT int jl_is_const(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT jl_value_t *jl_get_global(jl_module_t *m JL_PROPAGATES_ROOT, jl_sym_t *var);\nJL_DLLEXPORT void jl_set_global(jl_module_t *m JL_ROOTING_ARGUMENT,\n                                jl_sym_t *var,\n                                jl_value_t *val JL_ROOTED_ARGUMENT);\nJL_DLLEXPORT void jl_set_const(jl_module_t *m JL_ROOTING_ARGUMENT,\n                               jl_sym_t *var,\n                               jl_value_t *val JL_ROOTED_ARGUMENT);\nJL_DLLEXPORT void jl_checked_assignment(jl_binding_t *b, jl_value_t *rhs);\nJL_DLLEXPORT void jl_declare_constant(jl_binding_t *b);\nJL_DLLEXPORT void jl_module_using(jl_module_t *to, jl_module_t *from);\nJL_DLLEXPORT void jl_module_use(jl_module_t *to, jl_module_t *from, jl_sym_t *s);\nJL_DLLEXPORT void jl_module_import(jl_module_t *to, jl_module_t *from,\n                                   jl_sym_t *s);\nJL_DLLEXPORT void jl_module_export(jl_module_t *from, jl_sym_t *s);\nJL_DLLEXPORT int jl_is_imported(jl_module_t *m, jl_sym_t *s);\nJL_DLLEXPORT int jl_module_exports_p(jl_module_t *m, jl_sym_t *var);\nJL_DLLEXPORT jl_module_t *jl_new_main_module(void);\nJL_DLLEXPORT void jl_add_standard_imports(jl_module_t *m);\nSTATIC_INLINE jl_function_t *jl_get_function(jl_module_t *m, const char *name)\n{\n    return (jl_function_t*)jl_get_global(m, jl_symbol(name));\n}\nint jl_is_submodule(jl_module_t *child, jl_module_t *parent);\n\n// eq hash tables\nJL_DLLEXPORT jl_array_t *jl_eqtable_put(jl_array_t *h, void *key, void *val, int *inserted);\nJL_DLLEXPORT jl_value_t *jl_eqtable_get(jl_array_t *h, void *key,\n                                        jl_value_t *deflt);\n\n// system information\nJL_DLLEXPORT int jl_errno(void);\nJL_DLLEXPORT void jl_set_errno(int e);\nJL_DLLEXPORT int32_t jl_stat(const char *path, char *statbuf);\nJL_DLLEXPORT int jl_cpu_threads(void);\nJL_DLLEXPORT long jl_getpagesize(void);\nJL_DLLEXPORT long jl_getallocationgranularity(void);\nJL_DLLEXPORT int jl_is_debugbuild(void);\nJL_DLLEXPORT jl_sym_t *jl_get_UNAME(void);\nJL_DLLEXPORT jl_sym_t *jl_get_ARCH(void);\n\n// environment entries\nJL_DLLEXPORT jl_value_t *jl_environ(int i);\n\n// throwing common exceptions\nJL_DLLEXPORT void JL_NORETURN jl_error(const char *str);\nJL_DLLEXPORT void JL_NORETURN jl_errorf(const char *fmt, ...);\nJL_DLLEXPORT void JL_NORETURN jl_exceptionf(jl_datatype_t *ty,\n                                            const char *fmt, ...);\nJL_DLLEXPORT void JL_NORETURN jl_too_few_args(const char *fname, int min);\nJL_DLLEXPORT void JL_NORETURN jl_too_many_args(const char *fname, int max);\nJL_DLLEXPORT void JL_NORETURN jl_type_error(const char *fname,\n                                            jl_value_t *expected,\n                                            jl_value_t *got JL_MAYBE_UNROOTED);\nJL_DLLEXPORT void JL_NORETURN jl_type_error_rt(const char *fname,\n                                               const char *context,\n                                               jl_value_t *ty,\n                                               jl_value_t *got JL_MAYBE_UNROOTED);\nJL_DLLEXPORT void JL_NORETURN jl_undefined_var_error(jl_sym_t *var);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error(jl_value_t *v,\n                                              jl_value_t *t JL_MAYBE_UNROOTED);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_v(jl_value_t *v,\n                                                jl_value_t **idxs, size_t nidxs);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_int(jl_value_t *v JL_MAYBE_UNROOTED,\n                                                  size_t i);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_tuple_int(jl_value_t **v,\n                                                        size_t nv, size_t i);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_unboxed_int(void *v, jl_value_t *vt, size_t i);\nJL_DLLEXPORT void JL_NORETURN jl_bounds_error_ints(jl_value_t *v, size_t *idxs, size_t nidxs);\nJL_DLLEXPORT void JL_NORETURN jl_eof_error(void);\nJL_DLLEXPORT jl_value_t *jl_exception_occurred(void);\nJL_DLLEXPORT void jl_exception_clear(void) JL_NOTSAFEPOINT;\n\n#define JL_NARGS(fname, min, max)                               \\\n    if (nargs < min) jl_too_few_args(#fname, min);              \\\n    else if (nargs > max) jl_too_many_args(#fname, max);\n\n#define JL_NARGSV(fname, min)                           \\\n    if (nargs < min) jl_too_few_args(#fname, min);\n\n#define JL_TYPECHK(fname, type, v)                                      \\\n    if (!jl_is_##type(v)) {                                             \\\n        jl_type_error(#fname, (jl_value_t*)jl_##type##_type, (v));      \\\n    }\n#define JL_TYPECHKS(fname, type, v)                                     \\\n    if (!jl_is_##type(v)) {                                             \\\n        jl_type_error(fname, (jl_value_t*)jl_##type##_type, (v));       \\\n    }\n\n// initialization functions\ntypedef enum {\n    JL_IMAGE_CWD = 0,\n    JL_IMAGE_JULIA_HOME = 1,\n    //JL_IMAGE_LIBJULIA = 2,\n} JL_IMAGE_SEARCH;\n#ifdef JULIA_ENABLE_THREADING\n// this helps turn threading compilation mismatches into linker errors\n#define julia_init julia_init__threading\n#define jl_init jl_init__threading\n#define jl_init_with_image jl_init_with_image__threading\n#endif\nJL_DLLEXPORT void julia_init(JL_IMAGE_SEARCH rel);\nJL_DLLEXPORT void jl_init(void);\nJL_DLLEXPORT void jl_init_with_image(const char *julia_bindir,\n                                     const char *image_relative_path);\nJL_DLLEXPORT const char *jl_get_default_sysimg_path(void);\nJL_DLLEXPORT int jl_is_initialized(void);\nJL_DLLEXPORT void jl_atexit_hook(int status);\nJL_DLLEXPORT void JL_NORETURN jl_exit(int status);\nJL_DLLEXPORT const char *jl_pathname_for_handle(void *handle);\n\nJL_DLLEXPORT int jl_deserialize_verify_header(ios_t *s);\nJL_DLLEXPORT void jl_preload_sysimg_so(const char *fname);\nJL_DLLEXPORT void jl_set_sysimg_so(void *handle);\nJL_DLLEXPORT ios_t *jl_create_system_image(void);\nJL_DLLEXPORT void jl_save_system_image(const char *fname);\nJL_DLLEXPORT void jl_restore_system_image(const char *fname);\nJL_DLLEXPORT void jl_restore_system_image_data(const char *buf, size_t len);\nJL_DLLEXPORT int jl_save_incremental(const char *fname, jl_array_t *worklist);\nJL_DLLEXPORT jl_value_t *jl_restore_incremental(const char *fname, jl_array_t *depmods);\nJL_DLLEXPORT jl_value_t *jl_restore_incremental_from_buf(const char *buf, size_t sz, jl_array_t *depmods);\n\n// front end interface\nJL_DLLEXPORT jl_value_t *jl_parse_input_line(const char *str, size_t len,\n                                             const char *filename, size_t filename_len);\nJL_DLLEXPORT jl_value_t *jl_parse_string(const char *str, size_t len,\n                                         int pos0, int greedy);\nJL_DLLEXPORT jl_value_t *jl_load_file_string(const char *text, size_t len,\n                                             char *filename, jl_module_t *inmodule);\nJL_DLLEXPORT jl_value_t *jl_expand(jl_value_t *expr, jl_module_t *inmodule);\nJL_DLLEXPORT jl_value_t *jl_expand_stmt(jl_value_t *expr, jl_module_t *inmodule);\nJL_DLLEXPORT jl_value_t *jl_eval_string(const char *str);\n\n// external libraries\nenum JL_RTLD_CONSTANT {\n     JL_RTLD_LOCAL=1U,\n     JL_RTLD_GLOBAL=2U,\n     JL_RTLD_LAZY=4U,\n     JL_RTLD_NOW=8U,\n     /* Linux/glibc and MacOS X: */\n     JL_RTLD_NODELETE=16U,\n     JL_RTLD_NOLOAD=32U,\n     /* Linux/glibc: */\n     JL_RTLD_DEEPBIND=64U,\n     /* MacOS X 10.5+: */\n     JL_RTLD_FIRST=128U\n};\n#define JL_RTLD_DEFAULT (JL_RTLD_LAZY | JL_RTLD_DEEPBIND)\n\ntypedef void *jl_uv_libhandle; // compatible with dlopen (void*) / LoadLibrary (HMODULE)\nJL_DLLEXPORT jl_uv_libhandle jl_load_dynamic_library(const char *fname, unsigned flags);\nJL_DLLEXPORT jl_uv_libhandle jl_load_dynamic_library_e(const char *fname, unsigned flags);\nJL_DLLEXPORT jl_uv_libhandle jl_dlopen(const char *filename, unsigned flags);\nJL_DLLEXPORT int jl_dlclose(jl_uv_libhandle handle);\nJL_DLLEXPORT void *jl_dlsym_e(jl_uv_libhandle handle, const char *symbol);\nJL_DLLEXPORT void *jl_dlsym(jl_uv_libhandle handle, const char *symbol);\n\n// compiler\nJL_DLLEXPORT jl_value_t *jl_toplevel_eval(jl_module_t *m, jl_value_t *v);\nJL_DLLEXPORT jl_value_t *jl_toplevel_eval_in(jl_module_t *m, jl_value_t *ex);\nJL_DLLEXPORT jl_value_t *jl_load(jl_module_t *module, const char *fname);\nJL_DLLEXPORT jl_module_t *jl_base_relative_to(jl_module_t *m JL_PROPAGATES_ROOT);\n\n// tracing\nJL_DLLEXPORT void jl_trace_method(jl_method_t *m);\nJL_DLLEXPORT void jl_untrace_method(jl_method_t *m);\nJL_DLLEXPORT void jl_trace_linfo(jl_method_instance_t *linfo);\nJL_DLLEXPORT void jl_untrace_linfo(jl_method_instance_t *linfo);\nJL_DLLEXPORT void jl_register_linfo_tracer(void (*callback)(jl_method_instance_t *tracee));\nJL_DLLEXPORT void jl_register_method_tracer(void (*callback)(jl_method_instance_t *tracee));\nJL_DLLEXPORT void jl_register_newmeth_tracer(void (*callback)(jl_method_t *tracee));\n\n// AST access\nJL_DLLEXPORT jl_value_t *jl_copy_ast(jl_value_t *expr JL_MAYBE_UNROOTED);\n\nJL_DLLEXPORT jl_array_t *jl_compress_ast(jl_method_t *m, jl_code_info_t *code);\nJL_DLLEXPORT jl_code_info_t *jl_uncompress_ast(jl_method_t *m, jl_array_t *data);\nJL_DLLEXPORT uint8_t jl_ast_flag_inferred(jl_array_t *data);\nJL_DLLEXPORT uint8_t jl_ast_flag_inlineable(jl_array_t *data);\nJL_DLLEXPORT uint8_t jl_ast_flag_pure(jl_array_t *data);\nJL_DLLEXPORT void jl_fill_argnames(jl_array_t *data, jl_array_t *names);\n\nJL_DLLEXPORT int jl_is_operator(char *sym);\nJL_DLLEXPORT int jl_is_unary_operator(char *sym);\nJL_DLLEXPORT int jl_is_unary_and_binary_operator(char *sym);\nJL_DLLEXPORT int jl_operator_precedence(char *sym);\n\nSTATIC_INLINE int jl_vinfo_sa(uint8_t vi)\n{\n    return (vi&16)!=0;\n}\n\nSTATIC_INLINE int jl_vinfo_usedundef(uint8_t vi)\n{\n    return (vi&32)!=0;\n}\n\n// calling into julia ---------------------------------------------------------\n\nJL_DLLEXPORT jl_value_t *jl_apply_generic(jl_value_t **args, uint32_t nargs);\nJL_DLLEXPORT jl_value_t *jl_invoke(jl_method_instance_t *meth, jl_value_t **args, uint32_t nargs);\nJL_DLLEXPORT int32_t jl_invoke_api(jl_method_instance_t *mi);\n\nSTATIC_INLINE\njl_value_t *jl_apply(jl_value_t **args, uint32_t nargs)\n{\n    return jl_apply_generic(args, nargs);\n}\n\nJL_DLLEXPORT jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs);\nJL_DLLEXPORT jl_value_t *jl_call0(jl_function_t *f);\nJL_DLLEXPORT jl_value_t *jl_call1(jl_function_t *f, jl_value_t *a);\nJL_DLLEXPORT jl_value_t *jl_call2(jl_function_t *f, jl_value_t *a, jl_value_t *b);\nJL_DLLEXPORT jl_value_t *jl_call3(jl_function_t *f, jl_value_t *a,\n                                  jl_value_t *b, jl_value_t *c);\n\n// interfacing with Task runtime\nJL_DLLEXPORT void jl_yield(void);\n\n// async signal handling ------------------------------------------------------\n\nJL_DLLEXPORT void jl_install_sigint_handler(void);\nJL_DLLEXPORT void jl_sigatomic_begin(void);\nJL_DLLEXPORT void jl_sigatomic_end(void);\n\n// tasks and exceptions -------------------------------------------------------\n\ntypedef struct _jl_timing_block_t jl_timing_block_t;\n// info describing an exception handler\ntypedef struct _jl_handler_t {\n    jl_jmp_buf eh_ctx;\n    jl_gcframe_t *gcstack;\n    struct _jl_handler_t *prev;\n    int8_t gc_state;\n#ifdef JULIA_ENABLE_THREADING\n    size_t locks_len;\n#endif\n    sig_atomic_t defer_signal;\n    int finalizers_inhibited;\n    jl_timing_block_t *timing_stack;\n    size_t world_age;\n} jl_handler_t;\n\ntypedef struct _jl_task_t {\n    JL_DATA_TYPE\n    struct _jl_task_t *parent;\n    jl_value_t *tls;\n    jl_sym_t *state;\n    jl_value_t *donenotify;\n    jl_value_t *result;\n    jl_value_t *exception;\n    jl_value_t *backtrace;\n    jl_value_t *logstate;\n    jl_function_t *start;\n    jl_jmp_buf ctx;\n    size_t bufsz;\n    void *stkbuf;\n\n// hidden fields:\n    size_t ssize;\n    size_t started:1;\n\n    // current exception handler\n    jl_handler_t *eh;\n    // saved gc stack top for context switches\n    jl_gcframe_t *gcstack;\n    // current module, or NULL if this task has not set one\n    jl_module_t *current_module;\n    // current world age\n    size_t world_age;\n\n    // id of owning thread\n    // does not need to be defined until the task runs\n    int16_t tid;\n#ifdef JULIA_ENABLE_THREADING\n    // This is statically initialized when the task is not holding any locks\n    arraylist_t locks;\n#endif\n    jl_timing_block_t *timing_stack;\n} jl_task_t;\n\nJL_DLLEXPORT jl_task_t *jl_new_task(jl_function_t *start, size_t ssize);\nJL_DLLEXPORT void jl_switchto(jl_task_t **pt);\nJL_DLLEXPORT void JL_NORETURN jl_throw(jl_value_t *e JL_MAYBE_UNROOTED);\nJL_DLLEXPORT void JL_NORETURN jl_rethrow(void);\nJL_DLLEXPORT void JL_NORETURN jl_rethrow_other(jl_value_t *e JL_MAYBE_UNROOTED);\nJL_DLLEXPORT void JL_NORETURN jl_no_exc_handler(jl_value_t *e);\n\n#include \"locks.h\"   // requires jl_task_t definition\n\nSTATIC_INLINE void jl_eh_restore_state(jl_handler_t *eh)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    jl_task_t *current_task = ptls->current_task;\n    // `eh` may not be `ptls->current_task->eh`. See `jl_pop_handler`\n    // This function should **NOT** have any safepoint before the ones at the\n    // end.\n    sig_atomic_t old_defer_signal = ptls->defer_signal;\n    int8_t old_gc_state = ptls->gc_state;\n    current_task->eh = eh->prev;\n    ptls->pgcstack = eh->gcstack;\n#ifdef JULIA_ENABLE_THREADING\n    arraylist_t *locks = &current_task->locks;\n    if (locks->len > eh->locks_len) {\n        for (size_t i = locks->len;i > eh->locks_len;i--)\n            jl_mutex_unlock_nogc((jl_mutex_t*)locks->items[i - 1]);\n        locks->len = eh->locks_len;\n    }\n#endif\n    ptls->world_age = eh->world_age;\n    ptls->defer_signal = eh->defer_signal;\n    ptls->gc_state = eh->gc_state;\n    ptls->finalizers_inhibited = eh->finalizers_inhibited;\n    if (old_gc_state && !eh->gc_state) {\n        jl_gc_safepoint_(ptls);\n    }\n    if (old_defer_signal && !eh->defer_signal) {\n        jl_sigint_safepoint(ptls);\n    }\n}\n\nJL_DLLEXPORT void jl_enter_handler(jl_handler_t *eh);\nJL_DLLEXPORT void jl_pop_handler(int n);\n\n#if defined(_OS_WINDOWS_)\n#if defined(_COMPILER_MINGW_)\nint __attribute__ ((__nothrow__,__returns_twice__)) (jl_setjmp)(jmp_buf _Buf);\n__declspec(noreturn) __attribute__ ((__nothrow__)) void (jl_longjmp)(jmp_buf _Buf, int _Value);\n#else\nint (jl_setjmp)(jmp_buf _Buf);\nvoid (jl_longjmp)(jmp_buf _Buf, int _Value);\n#endif\n#define jl_setjmp_f jl_setjmp\n#define jl_setjmp_name \"jl_setjmp\"\n#define jl_setjmp(a,b) jl_setjmp(a)\n#define jl_longjmp(a,b) jl_longjmp(a,b)\n#else\n// determine actual entry point name\n#if defined(sigsetjmp)\n#define jl_setjmp_f    __sigsetjmp\n#define jl_setjmp_name \"__sigsetjmp\"\n#else\n#define jl_setjmp_f    sigsetjmp\n#define jl_setjmp_name \"sigsetjmp\"\n#endif\n#define jl_setjmp(a,b) sigsetjmp(a,b)\n#define jl_longjmp(a,b) siglongjmp(a,b)\n#endif\n\n\n#ifdef __clang_analyzer__\n\n// This is hard. Ideally we'd teach the static analyzer about the extra control\n// flow edges. But for now, just hide this as best we can\nextern int had_exception;\n#define JL_TRY if (1)\n#define JL_CATCH if (had_exception)\n\n#else\n\n#define JL_TRY                                                    \\\n    int i__tr, i__ca; jl_handler_t __eh;                          \\\n    jl_enter_handler(&__eh);                                      \\\n    if (!jl_setjmp(__eh.eh_ctx,0))                                \\\n        for (i__tr=1; i__tr; i__tr=0, jl_eh_restore_state(&__eh))\n\n#define JL_EH_POP() jl_eh_restore_state(&__eh)\n\n#ifdef _OS_WINDOWS_\n#define JL_CATCH                                                \\\n    else                                                        \\\n        for (i__ca=1, jl_eh_restore_state(&__eh); i__ca; i__ca=0) \\\n            if (((jl_get_ptls_states()->exception_in_transit==jl_stackovf_exception) && _resetstkoflw()) || 1)\n#else\n#define JL_CATCH                                                \\\n    else                                                        \\\n        for (i__ca=1, jl_eh_restore_state(&__eh); i__ca; i__ca=0)\n#endif\n\n#endif\n\n// I/O system -----------------------------------------------------------------\n\n#define JL_STREAM uv_stream_t\n#define JL_STDOUT jl_uv_stdout\n#define JL_STDERR jl_uv_stderr\n#define JL_STDIN  jl_uv_stdin\n\nJL_DLLEXPORT void jl_run_event_loop(uv_loop_t *loop);\nJL_DLLEXPORT int jl_run_once(uv_loop_t *loop);\nJL_DLLEXPORT int jl_process_events(uv_loop_t *loop);\n\nJL_DLLEXPORT uv_loop_t *jl_global_event_loop(void);\n\nJL_DLLEXPORT void jl_close_uv(uv_handle_t *handle);\n\nJL_DLLEXPORT int jl_tcp_bind(uv_tcp_t *handle, uint16_t port, uint32_t host,\n                             unsigned int flags);\n\nJL_DLLEXPORT int jl_sizeof_ios_t(void);\n\nJL_DLLEXPORT jl_array_t *jl_take_buffer(ios_t *s);\n\ntypedef struct {\n    void *data;\n    uv_loop_t *loop;\n    uv_handle_type type;\n    uv_os_fd_t file;\n} jl_uv_file_t;\n\n#ifdef __GNUC__\n#define _JL_FORMAT_ATTR(type, str, arg) \\\n    __attribute__((format(type, str, arg)))\n#else\n#define _JL_FORMAT_ATTR(type, str, arg)\n#endif\n\nJL_DLLEXPORT void jl_uv_puts(uv_stream_t *stream, const char *str, size_t n) JL_NOTSAFEPOINT;\nJL_DLLEXPORT int jl_printf(uv_stream_t *s, const char *format, ...) JL_NOTSAFEPOINT\n    _JL_FORMAT_ATTR(printf, 2, 3);\nJL_DLLEXPORT int jl_vprintf(uv_stream_t *s, const char *format, va_list args) JL_NOTSAFEPOINT\n    _JL_FORMAT_ATTR(printf, 2, 0);\nJL_DLLEXPORT void jl_safe_printf(const char *str, ...) JL_NOTSAFEPOINT\n    _JL_FORMAT_ATTR(printf, 1, 2);\n\nextern JL_DLLEXPORT JL_STREAM *JL_STDIN;\nextern JL_DLLEXPORT JL_STREAM *JL_STDOUT;\nextern JL_DLLEXPORT JL_STREAM *JL_STDERR;\n\nJL_DLLEXPORT JL_STREAM *jl_stdout_stream(void);\nJL_DLLEXPORT JL_STREAM *jl_stdin_stream(void);\nJL_DLLEXPORT JL_STREAM *jl_stderr_stream(void);\n\n// showing and std streams\nJL_DLLEXPORT void jl_flush_cstdio(void);\nJL_DLLEXPORT jl_value_t *jl_stdout_obj(void);\nJL_DLLEXPORT jl_value_t *jl_stderr_obj(void);\nJL_DLLEXPORT size_t jl_static_show(JL_STREAM *out, jl_value_t *v);\nJL_DLLEXPORT size_t jl_static_show_func_sig(JL_STREAM *s, jl_value_t *type);\nJL_DLLEXPORT void jlbacktrace(void);\n// Mainly for debugging, use `void*` so that no type cast is needed in C++.\nJL_DLLEXPORT void jl_(void *jl_value);\n\n// julia options -----------------------------------------------------------\n// NOTE: This struct needs to be kept in sync with JLOptions type in base/options.jl\ntypedef struct {\n    int8_t quiet;\n    int8_t banner;\n    const char *julia_bindir;\n    const char *julia_bin;\n    const char **cmds;\n    const char *image_file;\n    const char *cpu_target;\n    int32_t nprocs;\n    const char *machine_file;\n    const char *project;\n    int8_t isinteractive;\n    int8_t color;\n    int8_t historyfile;\n    int8_t startupfile;\n    int8_t compile_enabled;\n    int8_t code_coverage;\n    int8_t malloc_log;\n    int8_t opt_level;\n    int8_t debug_level;\n    int8_t check_bounds;\n    int8_t depwarn;\n    int8_t warn_overwrite;\n    int8_t can_inline;\n    int8_t polly;\n    const char *trace_compile;\n    int8_t fast_math;\n    int8_t worker;\n    const char *cookie;\n    int8_t handle_signals;\n    int8_t use_sysimage_native_code;\n    int8_t use_compiled_modules;\n    const char *bindto;\n    const char *outputbc;\n    const char *outputunoptbc;\n    const char *outputjitbc;\n    const char *outputo;\n    const char *outputji;\n    int8_t incremental;\n    int8_t image_file_specified;\n} jl_options_t;\n\nextern JL_DLLEXPORT jl_options_t jl_options;\nJL_DLLEXPORT ssize_t jl_sizeof_jl_options(void);\n\n// Parse an argc/argv pair to extract general julia options, passing back out\n// any arguments that should be passed on to the script.\nJL_DLLEXPORT void jl_parse_opts(int *argcp, char ***argvp);\n\n// Set julia-level ARGS array according to the arguments provided in\n// argc/argv\nJL_DLLEXPORT void jl_set_ARGS(int argc, char **argv);\n\nJL_DLLEXPORT int jl_generating_output(void);\n\n// Settings for code_coverage and malloc_log\n// NOTE: if these numbers change, test/cmdlineargs.jl will have to be updated\n#define JL_LOG_NONE 0\n#define JL_LOG_USER 1\n#define JL_LOG_ALL  2\n\n#define JL_OPTIONS_CHECK_BOUNDS_DEFAULT 0\n#define JL_OPTIONS_CHECK_BOUNDS_ON 1\n#define JL_OPTIONS_CHECK_BOUNDS_OFF 2\n\n#define JL_OPTIONS_COMPILE_DEFAULT 1\n#define JL_OPTIONS_COMPILE_OFF 0\n#define JL_OPTIONS_COMPILE_ON  1\n#define JL_OPTIONS_COMPILE_ALL 2\n#define JL_OPTIONS_COMPILE_MIN 3\n\n#define JL_OPTIONS_COLOR_AUTO 0\n#define JL_OPTIONS_COLOR_ON 1\n#define JL_OPTIONS_COLOR_OFF 2\n\n#define JL_OPTIONS_HISTORYFILE_ON 1\n#define JL_OPTIONS_HISTORYFILE_OFF 0\n\n#define JL_OPTIONS_STARTUPFILE_ON 1\n#define JL_OPTIONS_STARTUPFILE_OFF 2\n\n#define JL_LOGLEVEL_BELOWMIN -1000001\n#define JL_LOGLEVEL_DEBUG    -1000\n#define JL_LOGLEVEL_INFO      0\n#define JL_LOGLEVEL_WARN      1000\n#define JL_LOGLEVEL_ERROR     2000\n#define JL_LOGLEVEL_ABOVEMAX  1000001\n\n#define JL_OPTIONS_DEPWARN_OFF 0\n#define JL_OPTIONS_DEPWARN_ON 1\n#define JL_OPTIONS_DEPWARN_ERROR 2\n\n#define JL_OPTIONS_WARN_OVERWRITE_OFF 0\n#define JL_OPTIONS_WARN_OVERWRITE_ON 1\n\n#define JL_OPTIONS_POLLY_ON 1\n#define JL_OPTIONS_POLLY_OFF 0\n\n#define JL_OPTIONS_FAST_MATH_ON 1\n#define JL_OPTIONS_FAST_MATH_OFF 2\n#define JL_OPTIONS_FAST_MATH_DEFAULT 0\n\n#define JL_OPTIONS_HANDLE_SIGNALS_ON 1\n#define JL_OPTIONS_HANDLE_SIGNALS_OFF 0\n\n#define JL_OPTIONS_USE_SYSIMAGE_NATIVE_CODE_YES 1\n#define JL_OPTIONS_USE_SYSIMAGE_NATIVE_CODE_NO 0\n\n#define JL_OPTIONS_USE_COMPILED_MODULES_YES 1\n#define JL_OPTIONS_USE_COMPILED_MODULES_NO 0\n\n// Version information\n#include \"julia_version.h\"\n\nJL_DLLEXPORT extern int jl_ver_major(void);\nJL_DLLEXPORT extern int jl_ver_minor(void);\nJL_DLLEXPORT extern int jl_ver_patch(void);\nJL_DLLEXPORT extern int jl_ver_is_release(void);\nJL_DLLEXPORT extern const char *jl_ver_string(void);\nJL_DLLEXPORT const char *jl_git_branch(void);\nJL_DLLEXPORT const char *jl_git_commit(void);\n\n// nullable struct representations\ntypedef struct {\n    uint8_t hasvalue;\n    double value;\n} jl_nullable_float64_t;\n\ntypedef struct {\n    uint8_t hasvalue;\n    float value;\n} jl_nullable_float32_t;\n\n#define jl_current_module (jl_get_ptls_states()->current_module)\n#define jl_current_task (jl_get_ptls_states()->current_task)\n#define jl_root_task (jl_get_ptls_states()->root_task)\n#define jl_exception_in_transit (jl_get_ptls_states()->exception_in_transit)\n\n\n// codegen interface ----------------------------------------------------------\n\ntypedef struct {\n    int cached;             // can the compiler use/populate the compilation cache?\n\n    int track_allocations;  // can we track allocations?\n    int code_coverage;      // can we measure coverage?\n    int static_alloc;       // is the compiler allowed to allocate statically?\n    int prefer_specsig;     // are specialized function signatures preferred?\n\n\n    // hooks\n\n    // module setup: prepare a module for code emission (data layout, DWARF version, ...)\n    // parameters: LLVMModuleRef as Ptr{Cvoid}\n    // return value: none\n    jl_value_t *module_setup;\n\n    // module activation: registers debug info, adds module to JIT\n    // parameters: LLVMModuleRef as Ptr{Cvoid}\n    // return value: none\n    jl_value_t *module_activation;\n\n    // exception raising: emit LLVM instructions to raise an exception\n    // parameters: LLVMBasicBlockRef as Ptr{Cvoid}, LLVMValueRef as Ptr{Cvoid}\n    // return value: none\n    jl_value_t *raise_exception;\n\n    // emit function: start emission of a new function\n    // parameters: MethodInstance, CodeInfo, world age as UInt\n    // return value: none\n    jl_value_t *emit_function;\n\n    // emitted function: end emission of a new function\n    // parameters: MethodInstance, CodeInfo, world age as UInt\n    // return value: none\n    jl_value_t *emitted_function;\n} jl_cgparams_t;\nextern JL_DLLEXPORT jl_cgparams_t jl_default_cgparams;\n\n#if defined(JULIA_ENABLE_THREADING) && !defined(_OS_DARWIN_) && !defined(_OS_WINDOWS_)\n#define JULIA_DEFINE_FAST_TLS()                                                             \\\nJL_DLLEXPORT JL_CONST_FUNC jl_ptls_t jl_get_ptls_states_static(void)                        \\\n{                                                                                           \\\n    static __attribute__((tls_model(\"local-exec\"))) __thread jl_tls_states_t tls_states;    \\\n    return &tls_states;                                                                     \\\n}                                                                                           \\\n__attribute__((constructor)) void jl_register_ptls_states_getter(void)                      \\\n{                                                                                           \\\n    /* We need to make sure this function is called before any reference to */              \\\n    /* TLS variables. */                                                                    \\\n    jl_set_ptls_states_getter(jl_get_ptls_states_static);                                   \\\n}\n#else\n#define JULIA_DEFINE_FAST_TLS()\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/src/processor_arm.cpp": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n// ARM (AArch32/AArch64) specific processor detection and dispatch\n\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <set>\n#include <sstream>\n#include <fstream>\n#include <algorithm>\n\n#if defined(_CPU_AARCH64_) || __GLIBC_PREREQ(2, 16)\n#  include <sys/auxv.h>\n#else\n#  define DYN_GETAUXVAL\n#endif\n\nnamespace ARM {\nenum class CPU : uint32_t {\n    generic = 0,\n\n    // Architecture targets\n    armv7_a,\n    armv7_m,\n    armv7e_m,\n    armv7_r,\n    armv8_a,\n    armv8_m_base,\n    armv8_m_main,\n    armv8_r,\n    armv8_1_a,\n    armv8_2_a,\n    armv8_3_a,\n    // armv8_4_a,\n\n    // ARM\n    // armv6l\n    arm_mpcore,\n    arm_1136jf_s,\n    arm_1156t2f_s,\n    arm_1176jzf_s,\n    arm_cortex_m0,\n    arm_cortex_m1,\n    // armv7ml\n    arm_cortex_m3,\n    arm_cortex_m4,\n    arm_cortex_m7,\n    // armv7l\n    arm_cortex_a5,\n    arm_cortex_a7,\n    arm_cortex_a8,\n    arm_cortex_a9,\n    arm_cortex_a12,\n    arm_cortex_a15,\n    arm_cortex_a17,\n    arm_cortex_r4,\n    arm_cortex_r5,\n    arm_cortex_r7,\n    arm_cortex_r8,\n    // armv8ml\n    arm_cortex_m23,\n    arm_cortex_m33,\n    // armv8l\n    arm_cortex_a32,\n    arm_cortex_r52,\n    // aarch64\n    arm_cortex_a35,\n    arm_cortex_a53,\n    arm_cortex_a55,\n    arm_cortex_a57,\n    arm_cortex_a72,\n    arm_cortex_a73,\n    arm_cortex_a75,\n\n    // Cavium\n    // aarch64\n    cavium_thunderx,\n    cavium_thunderx88,\n    cavium_thunderx88p1,\n    cavium_thunderx81,\n    cavium_thunderx83,\n    cavium_thunderx2t99,\n    cavium_thunderx2t99p1,\n\n    // NVIDIA\n    // aarch64\n    nvidia_denver1,\n    nvidia_denver2,\n\n    // AppliedMicro\n    // aarch64\n    apm_xgene1,\n    apm_xgene2,\n    apm_xgene3,\n\n    // Qualcomm\n    // armv7l\n    qualcomm_scorpion,\n    qualcomm_krait,\n    // aarch64\n    qualcomm_kyro,\n    qualcomm_falkor,\n    qualcomm_saphira,\n\n    // Samsung\n    // aarch64\n    samsung_exynos_m1,\n    samsung_exynos_m2,\n    samsung_exynos_m3,\n\n    // Apple\n    // armv7l\n    apple_swift,\n    // aarch64\n    apple_cyclone,\n    apple_typhoon,\n    apple_twister,\n    apple_hurricane,\n\n    // Marvell\n    // armv7l\n    marvell_pj4,\n\n    // Intel\n    // armv7l\n    intel_3735d,\n};\n\n#ifdef _CPU_AARCH64_\nstatic constexpr size_t feature_sz = 3;\nstatic constexpr FeatureName feature_names[] = {\n#define JL_FEATURE_DEF(name, bit, llvmver) {#name, bit, llvmver},\n#define JL_FEATURE_DEF_NAME(name, bit, llvmver, str) {str, bit, llvmver},\n#include \"features_aarch64.h\"\n#undef JL_FEATURE_DEF\n#undef JL_FEATURE_DEF_NAME\n};\nstatic constexpr uint32_t nfeature_names = sizeof(feature_names) / sizeof(FeatureName);\n\ntemplate<typename... Args>\nstatic inline constexpr FeatureList<feature_sz> get_feature_masks(Args... args)\n{\n    return ::get_feature_masks<feature_sz>(args...);\n}\n\n#define JL_FEATURE_DEF_NAME(name, bit, llvmver, str) JL_FEATURE_DEF(name, bit, llvmver)\nstatic constexpr auto feature_masks = get_feature_masks(\n#define JL_FEATURE_DEF(name, bit, llvmver) bit,\n#include \"features_aarch64.h\"\n#undef JL_FEATURE_DEF\n    -1);\nstatic const auto real_feature_masks =\n    feature_masks & FeatureList<feature_sz>{{(uint32_t)-1, (uint32_t)-1, 0}};\n\nnamespace Feature {\nenum : uint32_t {\n#define JL_FEATURE_DEF(name, bit, llvmver) name = bit,\n#include \"features_aarch64.h\"\n#undef JL_FEATURE_DEF\n};\n#undef JL_FEATURE_DEF_NAME\n// This does not cover all dependencies (e.g. the ones that depends on arm versions)\nstatic constexpr FeatureDep deps[] = {\n    {0, 0} // dummy\n};\n\nconstexpr auto generic = get_feature_masks();\nconstexpr auto armv8a_crc = get_feature_masks(crc);\nconstexpr auto armv8a_crc_crypto = armv8a_crc | get_feature_masks(crypto);\nconstexpr auto armv8_1a = armv8a_crc | get_feature_masks(v8_1a, lse, rdm); // lor, hpd\nconstexpr auto armv8_2a = armv8_1a | get_feature_masks(v8_2a); // ras\nconstexpr auto armv8_2a_crypto = armv8_2a | get_feature_masks(crypto);\nconstexpr auto armv8_3a = armv8_2a | get_feature_masks(v8_3a, rcpc);\nconstexpr auto armv8_3a_crypto = armv8_3a | get_feature_masks(crypto);\n\nconstexpr auto arm_cortex_a32 = generic; // TODO? (crc, crypto)\nconstexpr auto arm_cortex_a35 = generic; // TODO? (crc, crypto)\nconstexpr auto arm_cortex_a53 = armv8a_crc;\nconstexpr auto arm_cortex_a55 = armv8_2a_crypto | get_feature_masks(rcpc); // dotprod;\nconstexpr auto arm_cortex_a57 = armv8a_crc;\nconstexpr auto arm_cortex_a72 = armv8a_crc;\nconstexpr auto arm_cortex_a73 = armv8a_crc;\nconstexpr auto arm_cortex_a75 = armv8_2a_crypto | get_feature_masks(rcpc); // dotprod;\nconstexpr auto cavium_thunderx = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx88 = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx88p1 = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx81 = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx83 = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx2t99 = armv8a_crc_crypto | get_feature_masks(v8_1a);\nconstexpr auto cavium_thunderx2t99p1 = armv8a_crc_crypto | get_feature_masks(v8_1a);\nconstexpr auto nvidia_denver1 = generic; // TODO? (crc, crypto)\nconstexpr auto nvidia_denver2 = armv8a_crc_crypto;\nconstexpr auto apm_xgene1 = generic;\nconstexpr auto apm_xgene2 = generic; // TODO?\nconstexpr auto apm_xgene3 = generic; // TODO?\nconstexpr auto qualcomm_kyro = armv8a_crc_crypto;\nconstexpr auto qualcomm_falkor = armv8a_crc_crypto;\nconstexpr auto qualcomm_saphira = armv8_3a_crypto;\nconstexpr auto samsung_exynos_m1 = armv8a_crc_crypto;\nconstexpr auto samsung_exynos_m2 = armv8a_crc_crypto;\nconstexpr auto samsung_exynos_m3 = armv8a_crc_crypto;\nconstexpr auto apple_cyclone = armv8a_crc_crypto;\nconstexpr auto apple_typhoon = armv8a_crc_crypto;\nconstexpr auto apple_twister = armv8a_crc_crypto;\nconstexpr auto apple_hurricane = armv8a_crc_crypto;\n\n}\n\nstatic constexpr CPUSpec<CPU, feature_sz> cpus[] = {\n    {\"generic\", CPU::generic, CPU::generic, 0, Feature::generic},\n    {\"armv8.1-a\", CPU::armv8_1_a, CPU::generic, 0, Feature::armv8_1a},\n    {\"armv8.2-a\", CPU::armv8_2_a, CPU::generic, 0, Feature::armv8_2a},\n    {\"armv8.3_a\", CPU::armv8_3_a, CPU::generic, 0, Feature::armv8_3a},\n    {\"cortex-a35\", CPU::arm_cortex_a35, CPU::generic, 0, Feature::arm_cortex_a35},\n    {\"cortex-a53\", CPU::arm_cortex_a53, CPU::generic, 0, Feature::arm_cortex_a53},\n    {\"cortex-a55\", CPU::arm_cortex_a55, CPU::arm_cortex_a53, UINT32_MAX, Feature::arm_cortex_a55},\n    {\"cortex-a57\", CPU::arm_cortex_a57, CPU::generic, 0, Feature::arm_cortex_a57},\n    {\"cortex-a72\", CPU::arm_cortex_a72, CPU::generic, 0, Feature::arm_cortex_a72},\n    {\"cortex-a73\", CPU::arm_cortex_a73, CPU::generic, 0, Feature::arm_cortex_a73},\n    {\"cortex-a75\", CPU::arm_cortex_a75, CPU::arm_cortex_a73, UINT32_MAX, Feature::arm_cortex_a75},\n    {\"thunderx\", CPU::cavium_thunderx, CPU::generic, 50000, Feature::cavium_thunderx},\n    {\"thunderxt88\", CPU::cavium_thunderx88, CPU::generic, 50000, Feature::cavium_thunderx88},\n    {\"thunderxt88p1\", CPU::cavium_thunderx88p1, CPU::cavium_thunderx88, UINT32_MAX,\n     Feature::cavium_thunderx88p1},\n    {\"thunderxt81\", CPU::cavium_thunderx81, CPU::generic, 50000, Feature::cavium_thunderx81},\n    {\"thunderxt83\", CPU::cavium_thunderx83, CPU::generic, 50000, Feature::cavium_thunderx83},\n    {\"thunderx2t99\", CPU::cavium_thunderx2t99, CPU::generic, 50000,\n     Feature::cavium_thunderx2t99},\n    {\"thunderx2t99p1\", CPU::cavium_thunderx2t99p1, CPU::cavium_thunderx2t99, UINT32_MAX,\n     Feature::cavium_thunderx2t99p1},\n    {\"denver1\", CPU::nvidia_denver1, CPU::generic, UINT32_MAX, Feature::nvidia_denver1},\n    {\"denver2\", CPU::nvidia_denver2, CPU::generic, UINT32_MAX, Feature::nvidia_denver2},\n    {\"xgene1\", CPU::apm_xgene1, CPU::generic, UINT32_MAX, Feature::apm_xgene1},\n    {\"xgene2\", CPU::apm_xgene2, CPU::generic, UINT32_MAX, Feature::apm_xgene2},\n    {\"xgene3\", CPU::apm_xgene3, CPU::generic, UINT32_MAX, Feature::apm_xgene3},\n    {\"kyro\", CPU::qualcomm_kyro, CPU::generic, 0, Feature::qualcomm_kyro},\n    {\"falkor\", CPU::qualcomm_falkor, CPU::generic, 40000, Feature::qualcomm_falkor},\n    {\"saphira\", CPU::qualcomm_saphira, CPU::qualcomm_falkor, 60000, Feature::qualcomm_saphira},\n    {\"exynos-m1\", CPU::samsung_exynos_m1, CPU::generic, 0, Feature::samsung_exynos_m1},\n    {\"exynos-m2\", CPU::samsung_exynos_m2, CPU::samsung_exynos_m1, 40000,\n     Feature::samsung_exynos_m2},\n    {\"exynos-m3\", CPU::samsung_exynos_m3, CPU::samsung_exynos_m2, 40000,\n     Feature::samsung_exynos_m3},\n    {\"cyclone\", CPU::apple_cyclone, CPU::generic, 0, Feature::apple_cyclone},\n    {\"typhoon\", CPU::apple_typhoon, CPU::apple_cyclone, UINT32_MAX, Feature::apple_typhoon},\n    {\"twister\", CPU::apple_twister, CPU::apple_typhoon, UINT32_MAX, Feature::apple_twister},\n    {\"hurricane\", CPU::apple_hurricane, CPU::apple_twister, UINT32_MAX, Feature::apple_hurricane},\n};\n#else\nstatic constexpr size_t feature_sz = 3;\nstatic constexpr FeatureName feature_names[] = {\n#define JL_FEATURE_DEF(name, bit, llvmver) {#name, bit, llvmver},\n#define JL_FEATURE_DEF_NAME(name, bit, llvmver, str) {str, bit, llvmver},\n#include \"features_aarch32.h\"\n#undef JL_FEATURE_DEF\n#undef JL_FEATURE_DEF_NAME\n};\nstatic constexpr uint32_t nfeature_names = sizeof(feature_names) / sizeof(FeatureName);\n\ntemplate<typename... Args>\nstatic inline constexpr FeatureList<feature_sz> get_feature_masks(Args... args)\n{\n    return ::get_feature_masks<feature_sz>(args...);\n}\n\n#define JL_FEATURE_DEF_NAME(name, bit, llvmver, str) JL_FEATURE_DEF(name, bit, llvmver)\nstatic constexpr auto feature_masks = get_feature_masks(\n#define JL_FEATURE_DEF(name, bit, llvmver) bit,\n#include \"features_aarch32.h\"\n#undef JL_FEATURE_DEF\n    -1);\nstatic const auto real_feature_masks =\n    feature_masks & FeatureList<feature_sz>{{(uint32_t)-1, (uint32_t)-1, 0}};\n\nnamespace Feature {\nenum : uint32_t {\n#define JL_FEATURE_DEF(name, bit, llvmver) name = bit,\n#include \"features_aarch32.h\"\n#undef JL_FEATURE_DEF\n};\n#undef JL_FEATURE_DEF_NAME\n// This does not cover all dependencies (e.g. the ones that depends on arm versions)\nstatic constexpr FeatureDep deps[] = {\n    {neon, vfp3},\n    {vfp4, vfp3},\n    {crypto, neon},\n};\n\n// These are the real base requirements of the specific architectures\nconstexpr auto _armv7m = get_feature_masks(v7, mclass, hwdiv);\nconstexpr auto _armv7a = get_feature_masks(v7, aclass);\nconstexpr auto _armv7r = get_feature_masks(v7, rclass);\nconstexpr auto _armv8m = get_feature_masks(v7, v8, mclass, hwdiv);\nconstexpr auto _armv8a = get_feature_masks(v7, v8, aclass, neon, vfp3, vfp4, d32,\n                                           hwdiv, hwdiv_arm);\nconstexpr auto _armv8r = get_feature_masks(v7, v8, rclass, neon, vfp3, vfp4, d32,\n                                           hwdiv, hwdiv_arm);\n\n// Set `generic` to match the feature requirement of the `C` code.\n// we'll require at least these when compiling the sysimg.\n#if __ARM_ARCH >= 8\n#  if !defined(__ARM_ARCH_PROFILE)\nconstexpr auto generic = get_feature_masks(v7, v8, hwdiv);\n#  elif __ARM_ARCH_PROFILE == 'A'\nconstexpr auto generic = _armv8a;\n#  elif __ARM_ARCH_PROFILE == 'R'\nconstexpr auto generic = _armv8r;\n#  elif __ARM_ARCH_PROFILE == 'M'\nconstexpr auto generic = _armv8m;\n#  else\nconstexpr auto generic = get_feature_masks(v7, v8, hwdiv);\n#  endif\n#elif __ARM_ARCH == 7\n#  if !defined(__ARM_ARCH_PROFILE)\nconstexpr auto generic = get_feature_masks(v7);\n#  elif __ARM_ARCH_PROFILE == 'A'\nconstexpr auto generic = _armv7a;\n#  elif __ARM_ARCH_PROFILE == 'R'\nconstexpr auto generic = _armv7r;\n#  elif __ARM_ARCH_PROFILE == 'M'\nconstexpr auto generic = _armv7m;\n#  else\nconstexpr auto generic = get_feature_masks(v7);\n#  endif\n#else\nconstexpr auto generic = get_feature_masks();\n#endif\n\n// All feature sets below should use or be or'ed with one of these (or generic).\n// This makes sure that, for example, the `generic` target on `armv7-a` binary is equivalent\n// to the `armv7-a` target.\nconstexpr auto armv7m = generic | _armv7m;\nconstexpr auto armv7a = generic | _armv7a;\nconstexpr auto armv7r = generic | _armv7r;\nconstexpr auto armv8m = generic | _armv8m;\nconstexpr auto armv8a = generic | _armv8a;\nconstexpr auto armv8r = generic | _armv8r;\n\n// armv7l\nconstexpr auto arm_cortex_a5 = armv7a;\nconstexpr auto arm_cortex_a7 = armv7a | get_feature_masks(vfp3, vfp4, neon);\nconstexpr auto arm_cortex_a8 = armv7a | get_feature_masks(d32, vfp3, neon);\nconstexpr auto arm_cortex_a9 = armv7a;\nconstexpr auto arm_cortex_a12 = armv7a | get_feature_masks(d32, vfp3, vfp4, neon);\nconstexpr auto arm_cortex_a15 = armv7a | get_feature_masks(d32, vfp3, vfp4, neon);\nconstexpr auto arm_cortex_a17 = armv7a | get_feature_masks(d32, vfp3, vfp4, neon);\nconstexpr auto arm_cortex_r4 = armv7r | get_feature_masks(vfp3, hwdiv);\nconstexpr auto arm_cortex_r5 = armv7r | get_feature_masks(vfp3, hwdiv, hwdiv_arm);\nconstexpr auto arm_cortex_r7 = armv7r | get_feature_masks(vfp3, hwdiv, hwdiv_arm);\nconstexpr auto arm_cortex_r8 = armv7r | get_feature_masks(vfp3, hwdiv, hwdiv_arm);\nconstexpr auto qualcomm_scorpion = armv7a | get_feature_masks(v7, aclass, vfp3, neon);\nconstexpr auto qualcomm_krait = armv7a | get_feature_masks(vfp3, vfp4, neon, hwdiv, hwdiv_arm);\nconstexpr auto apple_swift = armv7a | get_feature_masks(d32, vfp3, vfp4, neon, hwdiv, hwdiv_arm);\nconstexpr auto marvell_pj4 = armv7a | get_feature_masks(vfp3);\nconstexpr auto intel_3735d = armv7a | get_feature_masks(vfp3, neon);\n// armv8ml\nconstexpr auto arm_cortex_m23 = armv8m; // unsupported\nconstexpr auto arm_cortex_m33 = armv8m | get_feature_masks(v8_m_main); // unsupported\n// armv8l\nconstexpr auto armv8a_crc = armv8a | get_feature_masks(crc);\nconstexpr auto armv8_1a = armv8a_crc | get_feature_masks(v8_1a);\nconstexpr auto armv8_2a = armv8_1a | get_feature_masks(v8_2a);\nconstexpr auto armv8a_crc_crypto = armv8a_crc | get_feature_masks(crypto);\nconstexpr auto armv8_2a_crypto = armv8_2a | get_feature_masks(crypto);\nconstexpr auto armv8_3a = armv8_2a | get_feature_masks(v8_3a);\nconstexpr auto armv8_3a_crypto = armv8_3a | get_feature_masks(crypto);\n\nconstexpr auto arm_cortex_a32 = armv8a; // TODO? (crc, crypto)\nconstexpr auto arm_cortex_r52 = armv8r; // TODO? (crc, crypto)\nconstexpr auto arm_cortex_a35 = armv8a; // TODO? (crc, crypto)\nconstexpr auto arm_cortex_a53 = armv8a_crc;\nconstexpr auto arm_cortex_a55 = armv8_2a_crypto;\nconstexpr auto arm_cortex_a57 = armv8a_crc;\nconstexpr auto arm_cortex_a72 = armv8a_crc;\nconstexpr auto arm_cortex_a73 = armv8a_crc;\nconstexpr auto arm_cortex_a75 = armv8_2a_crypto;\nconstexpr auto cavium_thunderx = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx88 = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx88p1 = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx81 = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx83 = armv8a_crc_crypto;\nconstexpr auto cavium_thunderx2t99 = armv8a_crc_crypto | get_feature_masks(v8_1a);\nconstexpr auto cavium_thunderx2t99p1 = armv8a_crc_crypto | get_feature_masks(v8_1a);\nconstexpr auto nvidia_denver1 = armv8a; // TODO? (crc, crypto)\nconstexpr auto nvidia_denver2 = armv8a_crc_crypto;\nconstexpr auto apm_xgene1 = armv8a;\nconstexpr auto apm_xgene2 = armv8a; // TODO?\nconstexpr auto apm_xgene3 = armv8a; // TODO?\nconstexpr auto qualcomm_kyro = armv8a_crc_crypto;\nconstexpr auto qualcomm_falkor = armv8a_crc_crypto;\nconstexpr auto qualcomm_saphira = armv8_3a_crypto;\nconstexpr auto samsung_exynos_m1 = armv8a_crc_crypto;\nconstexpr auto samsung_exynos_m2 = armv8a_crc_crypto;\nconstexpr auto samsung_exynos_m3 = armv8a_crc_crypto;\nconstexpr auto apple_cyclone = armv8a_crc_crypto;\nconstexpr auto apple_typhoon = armv8a_crc_crypto;\nconstexpr auto apple_twister = armv8a_crc_crypto;\nconstexpr auto apple_hurricane = armv8a_crc_crypto;\n\n}\n\nstatic constexpr CPUSpec<CPU, feature_sz> cpus[] = {\n    {\"generic\", CPU::generic, CPU::generic, 0, Feature::generic},\n    // armv6\n    {\"mpcore\", CPU::arm_mpcore, CPU::generic, 0, Feature::generic},\n    {\"arm1136jf-s\", CPU::arm_1136jf_s, CPU::generic, 0, Feature::generic},\n    {\"arm1156t2f-s\", CPU::arm_1156t2f_s, CPU::generic, 0, Feature::generic},\n    {\"arm1176jzf-s\", CPU::arm_1176jzf_s, CPU::generic, 0, Feature::generic},\n    {\"cortex-m0\", CPU::arm_cortex_m0, CPU::generic, 0, Feature::generic},\n    {\"cortex-m1\", CPU::arm_cortex_m1, CPU::generic, 0, Feature::generic},\n    // armv7ml\n    {\"armv7-m\", CPU::armv7_m, CPU::generic, 0, Feature::armv7m},\n    {\"armv7e-m\", CPU::armv7e_m, CPU::generic, 0, Feature::armv7m},\n    {\"cortex-m3\", CPU::arm_cortex_m3, CPU::generic, 0, Feature::armv7m},\n    {\"cortex-m4\", CPU::arm_cortex_m4, CPU::generic, 0, Feature::armv7m},\n    {\"cortex-m7\", CPU::arm_cortex_m7, CPU::generic, 0, Feature::armv7m},\n    // armv7l\n    {\"armv7-a\", CPU::armv7_a, CPU::generic, 0, Feature::armv7a},\n    {\"armv7-r\", CPU::armv7_r, CPU::generic, 0, Feature::armv7r},\n    {\"cortex-a5\", CPU::arm_cortex_a5, CPU::generic, 0, Feature::arm_cortex_a5},\n    {\"cortex-a7\", CPU::arm_cortex_a7, CPU::generic, 0, Feature::arm_cortex_a7},\n    {\"cortex-a8\", CPU::arm_cortex_a8, CPU::generic, 0, Feature::arm_cortex_a8},\n    {\"cortex-a9\", CPU::arm_cortex_a9, CPU::generic, 0, Feature::arm_cortex_a9},\n    {\"cortex-a12\", CPU::arm_cortex_a12, CPU::generic, 0, Feature::arm_cortex_a12},\n    {\"cortex-a15\", CPU::arm_cortex_a15, CPU::generic, 0, Feature::arm_cortex_a15},\n    {\"cortex-a17\", CPU::arm_cortex_a17, CPU::generic, 0, Feature::arm_cortex_a17},\n    {\"cortex-r4\", CPU::arm_cortex_r4, CPU::generic, 0, Feature::arm_cortex_r4},\n    {\"cortex-r5\", CPU::arm_cortex_r5, CPU::generic, 0, Feature::arm_cortex_r5},\n    {\"cortex-r7\", CPU::arm_cortex_r7, CPU::generic, 0, Feature::arm_cortex_r7},\n    {\"cortex-r8\", CPU::arm_cortex_r8, CPU::generic, 0, Feature::arm_cortex_r8},\n    {\"scorpion\", CPU::qualcomm_scorpion, CPU::armv7_a, UINT32_MAX, Feature::qualcomm_scorpion},\n    {\"krait\", CPU::qualcomm_krait, CPU::generic, 0, Feature::qualcomm_krait},\n    {\"swift\", CPU::apple_swift, CPU::generic, 0, Feature::apple_swift},\n    {\"pj4\", CPU::marvell_pj4, CPU::armv7_a, UINT32_MAX, Feature::marvell_pj4},\n    {\"3735d\", CPU::intel_3735d, CPU::armv7_a, UINT32_MAX, Feature::intel_3735d},\n\n    // armv8ml\n    {\"armv8-m.base\", CPU::armv8_m_base, CPU::generic, 0, Feature::armv8m},\n    {\"armv8-m.main\", CPU::armv8_m_main, CPU::generic, 0, Feature::armv8m},\n    {\"cortex-m23\", CPU::arm_cortex_m23, CPU::armv8_m_base, 50000, Feature::arm_cortex_m23},\n    {\"cortex-m33\", CPU::arm_cortex_m33, CPU::armv8_m_main, 50000, Feature::arm_cortex_m33},\n\n    // armv8l\n    {\"armv8-a\", CPU::armv8_a, CPU::generic, 0, Feature::armv8a},\n    {\"armv8-r\", CPU::armv8_r, CPU::generic, 0, Feature::armv8r},\n    {\"armv8.1-a\", CPU::armv8_1_a, CPU::generic, 0, Feature::armv8_1a},\n    {\"armv8.2-a\", CPU::armv8_2_a, CPU::generic, 0, Feature::armv8_2a},\n    {\"armv8.3-a\", CPU::armv8_3_a, CPU::generic, 0, Feature::armv8_3a},\n    {\"cortex-a32\", CPU::arm_cortex_a32, CPU::generic, 0, Feature::arm_cortex_a32},\n    {\"cortex-r52\", CPU::arm_cortex_r52, CPU::armv8_r, 40000, Feature::arm_cortex_r52},\n    {\"cortex-a35\", CPU::arm_cortex_a35, CPU::generic, 0, Feature::arm_cortex_a35},\n    {\"cortex-a53\", CPU::arm_cortex_a53, CPU::generic, 0, Feature::arm_cortex_a53},\n    {\"cortex-a55\", CPU::arm_cortex_a55, CPU::arm_cortex_a53, 60000, Feature::arm_cortex_a55},\n    {\"cortex-a57\", CPU::arm_cortex_a57, CPU::generic, 0, Feature::arm_cortex_a57},\n    {\"cortex-a72\", CPU::arm_cortex_a72, CPU::generic, 0, Feature::arm_cortex_a72},\n    {\"cortex-a73\", CPU::arm_cortex_a73, CPU::generic, 0, Feature::arm_cortex_a73},\n    {\"cortex-a75\", CPU::arm_cortex_a75, CPU::arm_cortex_a73, 60000, Feature::arm_cortex_a75},\n    {\"thunderx\", CPU::cavium_thunderx, CPU::armv8_a, UINT32_MAX, Feature::cavium_thunderx},\n    {\"thunderx88\", CPU::cavium_thunderx88, CPU::armv8_a, UINT32_MAX, Feature::cavium_thunderx88},\n    {\"thunderx88p1\", CPU::cavium_thunderx88p1, CPU::armv8_a, UINT32_MAX,\n     Feature::cavium_thunderx88p1},\n    {\"thunderx81\", CPU::cavium_thunderx81, CPU::armv8_a, UINT32_MAX,\n     Feature::cavium_thunderx81},\n    {\"thunderx83\", CPU::cavium_thunderx83, CPU::armv8_a, UINT32_MAX,\n     Feature::cavium_thunderx83},\n    {\"thunderx2t99\", CPU::cavium_thunderx2t99, CPU::armv8_a, UINT32_MAX,\n     Feature::cavium_thunderx2t99},\n    {\"thunderx2t99p1\", CPU::cavium_thunderx2t99p1, CPU::armv8_a, UINT32_MAX,\n     Feature::cavium_thunderx2t99p1},\n    {\"denver1\", CPU::nvidia_denver1, CPU::arm_cortex_a53, UINT32_MAX, Feature::nvidia_denver1},\n    {\"denver2\", CPU::nvidia_denver2, CPU::arm_cortex_a57, UINT32_MAX, Feature::nvidia_denver2},\n    {\"xgene1\", CPU::apm_xgene1, CPU::armv8_a, UINT32_MAX, Feature::apm_xgene1},\n    {\"xgene2\", CPU::apm_xgene2, CPU::armv8_a, UINT32_MAX, Feature::apm_xgene2},\n    {\"xgene3\", CPU::apm_xgene3, CPU::armv8_a, UINT32_MAX, Feature::apm_xgene3},\n    {\"kyro\", CPU::qualcomm_kyro, CPU::armv8_a, UINT32_MAX, Feature::qualcomm_kyro},\n    {\"falkor\", CPU::qualcomm_falkor, CPU::armv8_a, UINT32_MAX, Feature::qualcomm_falkor},\n    {\"saphira\", CPU::qualcomm_saphira, CPU::armv8_a, UINT32_MAX, Feature::qualcomm_saphira},\n    {\"exynos-m1\", CPU::samsung_exynos_m1, CPU::generic, 0, Feature::samsung_exynos_m1},\n    {\"exynos-m2\", CPU::samsung_exynos_m2, CPU::samsung_exynos_m1, 40000,\n     Feature::samsung_exynos_m2},\n    {\"exynos-m3\", CPU::samsung_exynos_m3, CPU::samsung_exynos_m2, 40000,\n     Feature::samsung_exynos_m3},\n    {\"cyclone\", CPU::apple_cyclone, CPU::generic, 0, Feature::apple_cyclone},\n    {\"typhoon\", CPU::apple_typhoon, CPU::apple_cyclone, UINT32_MAX, Feature::apple_typhoon},\n    {\"twister\", CPU::apple_twister, CPU::apple_typhoon, UINT32_MAX, Feature::apple_twister},\n    {\"hurricane\", CPU::apple_hurricane, CPU::apple_twister, UINT32_MAX, Feature::apple_hurricane},\n};\n#endif\nstatic constexpr size_t ncpu_names = sizeof(cpus) / sizeof(cpus[0]);\n\n// auxval reader\n\n#ifndef AT_HWCAP\n#  define AT_HWCAP 16\n#endif\n#ifndef AT_HWCAP2\n#  define AT_HWCAP2 26\n#endif\n\n#if defined(DYN_GETAUXVAL)\nstatic bool getauxval_dlsym(unsigned long type, unsigned long *val)\n{\n    static auto getauxval_p = (unsigned long (*)(unsigned long))\n        jl_dlsym_e(jl_dlopen(nullptr, JL_RTLD_LOCAL), \"getauxval\");\n    if (getauxval_p) {\n        *val = getauxval_p(type);\n        return true;\n    }\n    return false;\n}\n\nstatic unsigned long getauxval_procfs(unsigned long type)\n{\n    int fd = open(\"/proc/self/auxv\", O_RDONLY);\n    if (fd == -1)\n        return 0;\n    unsigned long val = 0;\n    unsigned long buff[2];\n    while (read(fd, buff, sizeof(buff)) == sizeof(buff)) {\n        if (buff[0] == 0)\n            break;\n        if (buff[0] == type) {\n            val = buff[1];\n            break;\n        }\n    }\n    close(fd);\n    return val;\n}\n\nstatic inline unsigned long jl_getauxval(unsigned long type)\n{\n    unsigned long val;\n    if (getauxval_dlsym(type, &val))\n        return val;\n    return getauxval_procfs(type);\n}\n#else\nstatic inline unsigned long jl_getauxval(unsigned long type)\n{\n    return getauxval(type);\n}\n#endif\n\nstruct CPUID {\n    uint8_t implementer;\n    uint8_t variant;\n    uint16_t part;\n    bool operator<(const CPUID &right) const\n    {\n        if (implementer < right.implementer)\n            return true;\n        if (implementer > right.implementer)\n            return false;\n        if (part < right.part)\n            return true;\n        if (part > right.part)\n            return false;\n        return variant < right.variant;\n    }\n};\n\n// /sys/devices/system/cpu/cpu<n>/regs/identification/midr_el1 reader\nstatic inline void get_cpuinfo_sysfs(std::set<CPUID> &res)\n{\n    // This only works on a 64bit 4.7+ kernel\n    auto dir = opendir(\"/sys/devices/system/cpu\");\n    if (!dir)\n        return;\n    while (auto entry = readdir(dir)) {\n        if (entry->d_type != DT_DIR)\n            continue;\n        if (strncmp(entry->d_name, \"cpu\", 3) != 0)\n            continue;\n        std::stringstream stm;\n        stm << \"/sys/devices/system/cpu/\" << entry->d_name << \"/regs/identification/midr_el1\";\n        std::ifstream file(stm.str());\n        if (!file)\n            continue;\n        uint64_t val = 0;\n        file >> std::hex >> val;\n        if (!file)\n            continue;\n        CPUID cpuid = {\n            uint8_t(val >> 24),\n            uint8_t((val >> 20) & 0xf),\n            uint16_t((val >> 4) & 0xfff)\n        };\n        res.insert(cpuid);\n    }\n    closedir(dir);\n}\n\n// Use an external template since lambda's can't be templated in C++11\ntemplate<typename T, typename F>\nstatic inline bool try_read_procfs_line(llvm::StringRef line, const char *prefix, T &out,\n                                        bool &flag, F &&reset)\n{\n    if (!line.startswith(prefix))\n        return false;\n    if (flag)\n        reset();\n    flag = line.substr(strlen(prefix)).ltrim(\"\\t :\").getAsInteger(0, out);\n    return true;\n}\n\n// /proc/cpuinfo reader\nstatic inline void get_cpuinfo_procfs(std::set<CPUID> &res)\n{\n    std::ifstream file(\"/proc/cpuinfo\");\n    CPUID cpuid = {0, 0, 0};\n    bool impl = false;\n    bool part = false;\n    bool var = false;\n    auto reset = [&] () {\n        if (impl && part)\n            res.insert(cpuid);\n        impl = false;\n        part = false;\n        var = false;\n        memset(&cpuid, 0, sizeof(cpuid));\n    };\n    for (std::string line; std::getline(file, line);) {\n        if (line.empty()) {\n            reset();\n            continue;\n        }\n        try_read_procfs_line(line, \"CPU implementer\", cpuid.implementer, impl, reset) ||\n            try_read_procfs_line(line, \"CPU variant\", cpuid.variant, var, reset) ||\n            try_read_procfs_line(line, \"CPU part\", cpuid.part, part, reset);\n    }\n    reset();\n}\n\nstatic std::set<CPUID> get_cpuinfo(void)\n{\n    std::set<CPUID> res;\n    get_cpuinfo_sysfs(res);\n    if (res.empty())\n        get_cpuinfo_procfs(res);\n    return res;\n}\n\nstatic CPU get_cpu_name(CPUID cpuid)\n{\n    switch (cpuid.implementer) {\n    case 0x41: // ARM\n        switch (cpuid.part) {\n        case 0xb02: return CPU::arm_mpcore;\n        case 0xb36: return CPU::arm_1136jf_s;\n        case 0xb56: return CPU::arm_1156t2f_s;\n        case 0xb76: return CPU::arm_1176jzf_s;\n        case 0xc20: return CPU::arm_cortex_m0;\n        case 0xc21: return CPU::arm_cortex_m1;\n        case 0xc23: return CPU::arm_cortex_m3;\n        case 0xc24: return CPU::arm_cortex_m4;\n        case 0xc27: return CPU::arm_cortex_m7;\n        case 0xd20: return CPU::arm_cortex_m23;\n        case 0xd21: return CPU::arm_cortex_m33;\n        case 0xc05: return CPU::arm_cortex_a5;\n        case 0xc07: return CPU::arm_cortex_a7;\n        case 0xc08: return CPU::arm_cortex_a8;\n        case 0xc09: return CPU::arm_cortex_a9;\n        case 0xc0d: return CPU::arm_cortex_a12;\n        case 0xc0f: return CPU::arm_cortex_a15;\n        case 0xc0e: return CPU::arm_cortex_a17;\n        case 0xc14: return CPU::arm_cortex_r4;\n        case 0xc15: return CPU::arm_cortex_r5;\n        case 0xc17: return CPU::arm_cortex_r7;\n        case 0xc18: return CPU::arm_cortex_r8;\n        case 0xd13: return CPU::arm_cortex_r52;\n        case 0xd01: return CPU::arm_cortex_a32;\n        case 0xd04: return CPU::arm_cortex_a35;\n        case 0xd03: return CPU::arm_cortex_a53;\n        case 0xd05: return CPU::arm_cortex_a55;\n        case 0xd07: return CPU::arm_cortex_a57;\n        case 0xd08: return CPU::arm_cortex_a72;\n        case 0xd09: return CPU::arm_cortex_a73;\n        case 0xd0a: return CPU::arm_cortex_a75;\n        default: return CPU::generic;\n        }\n    case 0x42: // Broadcom (Cavium)\n        switch (cpuid.part) {\n        case 0x516: return CPU::cavium_thunderx2t99p1;\n        default: return CPU::generic;\n        }\n    case 0x43: // Cavium\n        switch (cpuid.part) {\n        case 0xa0: return CPU::cavium_thunderx;\n        case 0xa1:\n            if (cpuid.variant == 0)\n                return CPU::cavium_thunderx88p1;\n            return CPU::cavium_thunderx88;\n        case 0xa2: return CPU::cavium_thunderx81;\n        case 0xa3: return CPU::cavium_thunderx83;\n        case 0xaf: return CPU::cavium_thunderx2t99;\n        default: return CPU::generic;\n        }\n    case 0x4e: // NVIDIA\n        switch (cpuid.part) {\n        case 0x000: return CPU::nvidia_denver1;\n        case 0x003: return CPU::nvidia_denver2;\n        default: return CPU::generic;\n        }\n    case 0x50: // AppliedMicro\n        // x-gene 2\n        // x-gene 3\n        switch (cpuid.part) {\n        case 0x000: return CPU::apm_xgene1;\n        default: return CPU::generic;\n        }\n    case 0x51: // Qualcomm\n        switch (cpuid.part) {\n        case 0x00f:\n        case 0x02d:\n            return CPU::qualcomm_scorpion;\n        case 0x04d:\n        case 0x06f:\n            return CPU::qualcomm_krait;\n        case 0x201:\n        case 0x205:\n        case 0x211:\n            return CPU::qualcomm_kyro;\n        case 0x800:\n        case 0x801:\n            return CPU::arm_cortex_a73; // second-generation Kryo\n        case 0xc00:\n            return CPU::qualcomm_falkor;\n        case 0xc01:\n            return CPU::qualcomm_saphira;\n        default: return CPU::generic;\n        }\n    case 0x53: // Samsung\n        // exynos-m2\n        // exynos-m3\n        switch (cpuid.part) {\n        case 0x001: return CPU::samsung_exynos_m1;\n        default: return CPU::generic;\n        }\n    case 0x56: // Marvell\n        switch (cpuid.part) {\n        case 0x581:\n        case 0x584:\n            return CPU::marvell_pj4;\n        default: return CPU::generic;\n        }\n    case 0x67: // Apple\n        // swift\n        // cyclone\n        // twister\n        // hurricane\n        switch (cpuid.part) {\n        case 0x072: return CPU::apple_typhoon;\n        default: return CPU::generic;\n        }\n    case 0x69: // Intel\n        switch (cpuid.part) {\n        case 0x001: return CPU::intel_3735d;\n        default: return CPU::generic;\n        }\n    default:\n        return CPU::generic;\n    }\n}\n\nstatic std::pair<int,char> get_elf_arch(void)\n{\n#ifdef _CPU_AARCH64_\n    return std::make_pair(8, 'A');\n#else\n    int ver = 0;\n    char profile = 0;\n    struct utsname name;\n    if (uname(&name) >= 0) {\n        // name.machine is the elf_platform in the kernel.\n        if (strcmp(name.machine, \"armv6l\") == 0) {\n            ver = 6;\n        }\n        else if (strcmp(name.machine, \"armv7l\") == 0) {\n            ver = 7;\n        }\n        else if (strcmp(name.machine, \"armv7ml\") == 0) {\n            ver = 7;\n            profile = 'M';\n        }\n        else if (strcmp(name.machine, \"armv8l\") == 0 || strcmp(name.machine, \"aarch64\") == 0) {\n            ver = 8;\n        }\n    }\n    if (__ARM_ARCH > ver)\n        ver = __ARM_ARCH;\n#  if __ARM_ARCH > 6 && defined(__ARM_ARCH_PROFILE)\n    profile = __ARM_ARCH_PROFILE;\n#  endif\n    return std::make_pair(ver, profile);\n#endif\n}\n\nstatic inline const CPUSpec<CPU,feature_sz> *find_cpu(uint32_t cpu)\n{\n    return ::find_cpu(cpu, cpus, ncpu_names);\n}\n\nstatic inline const CPUSpec<CPU,feature_sz> *find_cpu(llvm::StringRef name)\n{\n    return ::find_cpu(name, cpus, ncpu_names);\n}\n\nstatic inline const char *find_cpu_name(uint32_t cpu)\n{\n    return ::find_cpu_name(cpu, cpus, ncpu_names);\n}\n\nstatic std::pair<int,bool> feature_arch_version(const FeatureList<feature_sz> &feature)\n{\n#ifdef _CPU_AARCH64_\n    return std::make_pair(8, false);\n#else\n    if (test_nbit(feature, Feature::v8))\n        return std::make_pair(8, test_nbit(feature, Feature::mclass));\n    if (test_nbit(feature, Feature::v7))\n        return std::make_pair(7, test_nbit(feature, Feature::mclass));\n    return std::make_pair(6, false);\n#endif\n}\n\nstatic CPU generic_for_arch(std::pair<int,bool> arch)\n{\n#ifdef _CPU_AARCH64_\n    return CPU::generic;\n#else\n#  if defined(__ARM_ARCH_PROFILE)\n    char klass = __ARM_ARCH_PROFILE;\n#  else\n    char klass = arch.second ? 'M' : 'A';\n#  endif\n    if (arch.first >= 8) {\n        if (klass == 'M') {\n            return CPU::armv8_m_base;\n        }\n        else if (klass == 'R') {\n            return CPU::armv8_r;\n        }\n        else {\n            return CPU::armv8_a;\n        }\n    }\n    else if (arch.first == 7) {\n        if (klass == 'M') {\n            return CPU::armv7_m;\n        }\n        else if (klass == 'R') {\n            return CPU::armv7_r;\n        }\n        else {\n            return CPU::armv7_a;\n        }\n    }\n    return CPU::generic;\n#endif\n}\n\nstatic bool check_cpu_arch_ver(uint32_t cpu, std::pair<int,bool> arch)\n{\n    auto spec = find_cpu(cpu);\n    // This happens on AArch64 and indicates that the cpu name isn't a valid aarch64 CPU\n    if (!spec)\n        return false;\n    auto cpu_arch = feature_arch_version(spec->features);\n    if (arch.second != cpu_arch.second)\n        return false;\n    if (arch.first > cpu_arch.first)\n        return false;\n    return true;\n}\n\nstatic void shrink_big_little(std::vector<std::pair<uint32_t,CPUID>> &list,\n                              const CPU *cpus, uint32_t ncpu)\n{\n    auto find = [&] (uint32_t name) {\n        for (uint32_t i = 0; i < ncpu; i++) {\n            if (cpus[i] == CPU(name)) {\n                return (int)i;\n            }\n        }\n        return -1;\n    };\n    int maxidx = -1;\n    for (auto &ele: list) {\n        int idx = find(ele.first);\n        if (idx > maxidx) {\n            maxidx = idx;\n        }\n    }\n    if (maxidx >= 0) {\n        list.erase(std::remove_if(list.begin(), list.end(), [&] (std::pair<uint32_t,CPUID> &ele) {\n                    int idx = find(ele.first);\n                    return idx != -1 && idx < maxidx;\n                }), list.end());\n    }\n}\n\nstatic NOINLINE std::pair<uint32_t,FeatureList<feature_sz>> _get_host_cpu()\n{\n    FeatureList<feature_sz> features = {};\n    // Here we assume that only the lower 32bit are used on aarch64\n    // Change the cast here when that's not the case anymore (and when there's features in the\n    // high bits that we want to detect).\n    features[0] = (uint32_t)jl_getauxval(AT_HWCAP);\n    features[1] = (uint32_t)jl_getauxval(AT_HWCAP2);\n    auto cpuinfo = get_cpuinfo();\n    auto arch = get_elf_arch();\n#ifdef _CPU_ARM_\n    if (arch.first >= 7) {\n        if (arch.second == 'M') {\n            set_bit(features, Feature::mclass, true);\n        }\n        else if (arch.second == 'R') {\n            set_bit(features, Feature::rclass, true);\n        }\n        else if (arch.second == 'A') {\n            set_bit(features, Feature::aclass, true);\n        }\n    }\n    switch (arch.first) {\n    case 8:\n    set_bit(features, Feature::v8, true);\n    JL_FALLTHROUGH;\n    case 7:\n    set_bit(features, Feature::v7, true);\n    break;\n    default:\n    break;\n    }\n#endif\n\n    std::set<uint32_t> cpus;\n    std::vector<std::pair<uint32_t,CPUID>> list;\n    for (auto info: cpuinfo) {\n        auto name = (uint32_t)get_cpu_name(info);\n        if (name == 0)\n            continue;\n        if (!check_cpu_arch_ver(name, arch))\n            continue;\n        if (cpus.insert(name).second) {\n            features = features | find_cpu(name)->features;\n            list.emplace_back(name, info);\n        }\n    }\n    // Not all elements/pairs are valid\n    static constexpr CPU v8order[] = {\n        CPU::arm_cortex_a32,\n        CPU::arm_cortex_a35,\n        CPU::arm_cortex_a53,\n        CPU::arm_cortex_a55,\n        CPU::arm_cortex_a57,\n        CPU::arm_cortex_a72,\n        CPU::arm_cortex_a73,\n        CPU::arm_cortex_a75,\n        CPU::nvidia_denver2,\n        CPU::samsung_exynos_m1\n    };\n    shrink_big_little(list, v8order, sizeof(v8order) / sizeof(CPU));\n#ifdef _CPU_ARM_\n    // Not all elements/pairs are valid\n    static constexpr CPU v7order[] = {\n        CPU::arm_cortex_a5,\n        CPU::arm_cortex_a7,\n        CPU::arm_cortex_a8,\n        CPU::arm_cortex_a9,\n        CPU::arm_cortex_a12,\n        CPU::arm_cortex_a15,\n        CPU::arm_cortex_a17\n    };\n    shrink_big_little(list, v7order, sizeof(v7order) / sizeof(CPU));\n#endif\n    uint32_t cpu = 0;\n    if (list.empty()) {\n        cpu = (uint32_t)generic_for_arch(arch);\n    }\n    else {\n        // This also covers `list.size() > 1` case which means there's a unknown combination\n        // consists of CPU's we know. Unclear what else we could try so just randomly return\n        // one...\n        cpu = list[0].first;\n    }\n    // Ignore feature bits that we are not interested in.\n    mask_features(feature_masks, &features[0]);\n\n    return std::make_pair(cpu, features);\n}\n\nstatic inline const std::pair<uint32_t,FeatureList<feature_sz>> &get_host_cpu()\n{\n    static auto host_cpu = _get_host_cpu();\n    return host_cpu;\n}\n\nstatic bool is_generic_cpu_name(uint32_t cpu)\n{\n    switch ((CPU)cpu) {\n    case CPU::generic:\n    case CPU::armv7_a:\n    case CPU::armv7_m:\n    case CPU::armv7e_m:\n    case CPU::armv7_r:\n    case CPU::armv8_a:\n    case CPU::armv8_m_base:\n    case CPU::armv8_m_main:\n    case CPU::armv8_r:\n    case CPU::armv8_1_a:\n    case CPU::armv8_2_a:\n    case CPU::armv8_3_a:\n        return true;\n    default:\n        return false;\n    }\n}\n\nstatic inline const std::string &host_cpu_name()\n{\n    static std::string name = [] {\n        if (is_generic_cpu_name(get_host_cpu().first)) {\n            auto llvm_name = jl_get_cpu_name_llvm();\n            if (llvm_name != \"generic\") {\n                return llvm_name;\n            }\n        }\n        return std::string(find_cpu_name(get_host_cpu().first));\n    }();\n    return name;\n}\n\ntemplate<size_t n>\nstatic inline void enable_depends(FeatureList<n> &features)\n{\n    if (test_nbit(features, Feature::v8_3a))\n        set_bit(features, Feature::v8_2a, true);\n    if (test_nbit(features, Feature::v8_2a))\n        set_bit(features, Feature::v8_1a, true);\n    if (test_nbit(features, Feature::v8_1a))\n        set_bit(features, Feature::crc, true);\n#ifdef _CPU_ARM_\n    if (test_nbit(features, Feature::v8_1a)) {\n        set_bit(features, Feature::v8, true);\n        set_bit(features, Feature::aclass, true);\n    }\n    if (test_nbit(features, Feature::v8_m_main)) {\n        set_bit(features, Feature::v8, true);\n        set_bit(features, Feature::mclass, true);\n    }\n    if (test_nbit(features, Feature::v8)) {\n        set_bit(features, Feature::v7, true);\n        if (test_nbit(features, Feature::aclass)) {\n            set_bit(features, Feature::neon, true);\n            set_bit(features, Feature::vfp3, true);\n            set_bit(features, Feature::vfp4, true);\n            set_bit(features, Feature::hwdiv_arm, true);\n            set_bit(features, Feature::hwdiv, true);\n            set_bit(features, Feature::d32, true);\n        }\n    }\n    ::enable_depends(features, Feature::deps, sizeof(Feature::deps) / sizeof(FeatureDep));\n#else\n    if (test_nbit(features, Feature::v8_1a)) {\n        set_bit(features, Feature::lse, true);\n        set_bit(features, Feature::rdm, true);\n    }\n#endif\n}\n\ntemplate<size_t n>\nstatic inline void disable_depends(FeatureList<n> &features)\n{\n#ifdef _CPU_ARM_\n    ::disable_depends(features, Feature::deps, sizeof(Feature::deps) / sizeof(FeatureDep));\n#endif\n}\n\nstatic const std::vector<TargetData<feature_sz>> &get_cmdline_targets(void)\n{\n    auto feature_cb = [] (const char *str, size_t len, FeatureList<feature_sz> &list) {\n        auto fbit = find_feature_bit(feature_names, nfeature_names, str, len);\n        if (fbit == (uint32_t)-1)\n            return false;\n        set_bit(list, fbit, true);\n        return true;\n    };\n    return ::get_cmdline_targets<feature_sz>(feature_cb);\n}\n\nstatic std::vector<TargetData<feature_sz>> jit_targets;\n\nstatic TargetData<feature_sz> arg_target_data(const TargetData<feature_sz> &arg, bool require_host)\n{\n    TargetData<feature_sz> res = arg;\n    const FeatureList<feature_sz> *cpu_features = nullptr;\n    if (res.name == \"native\") {\n        res.name = host_cpu_name();\n        cpu_features = &get_host_cpu().second;\n    }\n    else if (auto spec = find_cpu(res.name)) {\n        cpu_features = &spec->features;\n    }\n    else {\n        res.en.flags |= JL_TARGET_UNKNOWN_NAME;\n    }\n    if (cpu_features) {\n        for (size_t i = 0; i < feature_sz; i++) {\n            res.en.features[i] |= (*cpu_features)[i];\n        }\n    }\n    enable_depends(res.en.features);\n    for (size_t i = 0; i < feature_sz; i++)\n        res.en.features[i] &= ~res.dis.features[i];\n    if (require_host) {\n        for (size_t i = 0; i < feature_sz; i++) {\n            res.en.features[i] &= get_host_cpu().second[i];\n        }\n    }\n    disable_depends(res.en.features);\n    if (cpu_features) {\n        // If the base feature if known, fill in the disable features\n        for (size_t i = 0; i < feature_sz; i++) {\n            res.dis.features[i] = feature_masks[i] & ~res.en.features[i];\n        }\n    }\n    return res;\n}\n\nstatic int max_vector_size(const FeatureList<feature_sz> &features)\n{\n#ifdef _CPU_ARM_\n    if (test_nbit(features, Feature::neon))\n        return 16;\n    return 8;\n#else\n    // TODO SVE\n    return 16;\n#endif\n}\n\nstatic uint32_t sysimg_init_cb(const void *id)\n{\n    // First see what target is requested for the JIT.\n    auto &cmdline = get_cmdline_targets();\n    TargetData<feature_sz> target = arg_target_data(cmdline[0], true);\n    // Then find the best match in the sysimg\n    auto sysimg = deserialize_target_data<feature_sz>((const uint8_t*)id);\n    auto match = match_sysimg_targets(sysimg, target, max_vector_size);\n    // Now we've decided on which sysimg version to use.\n    // Make sure the JIT target is compatible with it and save the JIT target.\n    if (match.vreg_size != max_vector_size(target.en.features) &&\n        (sysimg[match.best_idx].en.flags & JL_TARGET_VEC_CALL)) {\n#ifdef _CPU_ARM_\n        unset_bits(target.en.features, Feature::neon);\n#endif\n    }\n    jit_targets.push_back(std::move(target));\n    return match.best_idx;\n}\n\nstatic void ensure_jit_target(bool imaging)\n{\n    auto &cmdline = get_cmdline_targets();\n    check_cmdline(cmdline, imaging);\n    if (!jit_targets.empty())\n        return;\n    for (auto &arg: cmdline) {\n        auto data = arg_target_data(arg, jit_targets.empty());\n        jit_targets.push_back(std::move(data));\n    }\n    auto ntargets = jit_targets.size();\n    // Now decide the clone condition.\n    for (size_t i = 1; i < ntargets; i++) {\n        auto &t = jit_targets[i];\n        if (t.en.flags & JL_TARGET_CLONE_ALL)\n            continue;\n        // The most useful one in general...\n        t.en.flags |= JL_TARGET_CLONE_LOOP;\n#ifdef _CPU_ARM_\n        auto &features0 = jit_targets[t.base].en.features;\n        static constexpr uint32_t clone_math[] = {Feature::vfp3, Feature::vfp4, Feature::neon};\n        for (auto fe: clone_math) {\n            if (!test_nbit(features0, fe) && test_nbit(t.en.features, fe)) {\n                t.en.flags |= JL_TARGET_CLONE_MATH;\n                break;\n            }\n        }\n        static constexpr uint32_t clone_simd[] = {Feature::neon};\n        for (auto fe: clone_simd) {\n            if (!test_nbit(features0, fe) && test_nbit(t.en.features, fe)) {\n                t.en.flags |= JL_TARGET_CLONE_SIMD;\n                break;\n            }\n        }\n#endif\n    }\n}\n\nstatic std::pair<std::string,std::vector<std::string>>\nget_llvm_target_noext(const TargetData<feature_sz> &data)\n{\n    std::string name = data.name;\n    auto *spec = find_cpu(name);\n    while (spec) {\n        if (spec->llvmver <= JL_LLVM_VERSION)\n            break;\n        spec = find_cpu((uint32_t)spec->fallback);\n        name = spec->name;\n    }\n    auto features = data.en.features;\n    if (spec) {\n        if (is_generic_cpu_name((uint32_t)spec->cpu)) {\n            features = features | spec->features;\n            name = \"generic\";\n        }\n    }\n    std::vector<std::string> feature_strs;\n    for (auto &fename: feature_names) {\n        if (fename.llvmver > JL_LLVM_VERSION)\n            continue;\n        if (fename.bit >= 32 * 2)\n            break;\n        const char *fename_str = fename.name;\n        bool enable = test_nbit(features, fename.bit);\n        bool disable = test_nbit(data.dis.features, fename.bit);\n#ifdef _CPU_ARM_\n        if (fename.bit == Feature::d32) {\n            if (enable) {\n                feature_strs.push_back(\"-d16\");\n            }\n            else if (disable) {\n                feature_strs.push_back(\"+d16\");\n            }\n            continue;\n        }\n#endif\n        if (enable) {\n            feature_strs.insert(feature_strs.begin(), std::string(\"+\") + fename_str);\n        }\n        else if (disable) {\n            feature_strs.push_back(std::string(\"-\") + fename_str);\n        }\n    }\n    if (test_nbit(features, Feature::v8_2a))\n        feature_strs.push_back(\"+v8.2a\");\n    if (test_nbit(features, Feature::v8_1a))\n        feature_strs.push_back(\"+v8.1a\");\n#ifdef _CPU_ARM_\n    if (test_nbit(features, Feature::v8_m_main)) {\n        feature_strs.push_back(\"+v8m.main\");\n        feature_strs.push_back(\"+armv8-m.main\");\n    }\n    if (test_nbit(features, Feature::aclass))\n        feature_strs.push_back(\"+aclass\");\n    if (test_nbit(features, Feature::rclass))\n        feature_strs.push_back(\"+rclass\");\n    if (test_nbit(features, Feature::mclass))\n        feature_strs.push_back(\"+mclass\");\n    if (test_nbit(features, Feature::v8)) {\n        feature_strs.push_back(\"+v8\");\n        if (test_nbit(features, Feature::aclass))\n            feature_strs.push_back(\"+armv8-a\");\n        if (test_nbit(features, Feature::rclass))\n            feature_strs.push_back(\"+armv8-r\");\n        if (test_nbit(features, Feature::mclass)) {\n            feature_strs.push_back(\"+v8m\");\n            feature_strs.push_back(\"+armv8-m.base\");\n        }\n    }\n    if (test_nbit(features, Feature::v7)) {\n        feature_strs.push_back(\"+v7\");\n        if (test_nbit(features, Feature::aclass))\n            feature_strs.push_back(\"+armv7-a\");\n        if (test_nbit(features, Feature::rclass))\n            feature_strs.push_back(\"+armv7-r\");\n        if (test_nbit(features, Feature::mclass))\n            feature_strs.push_back(\"+armv7-m\");\n    }\n    feature_strs.push_back(\"+v6\");\n    feature_strs.push_back(\"+vfp2\");\n#else\n    feature_strs.push_back(\"+neon\");\n    feature_strs.push_back(\"+fp-armv8\");\n#endif\n    return std::make_pair(std::move(name), std::move(feature_strs));\n}\n\nstatic std::pair<std::string,std::vector<std::string>>\nget_llvm_target_vec(const TargetData<feature_sz> &data)\n{\n    auto res0 = get_llvm_target_noext(data);\n    append_ext_features(res0.second, data.ext_features);\n    return res0;\n}\n\nstatic std::pair<std::string,std::string>\nget_llvm_target_str(const TargetData<feature_sz> &data)\n{\n    auto res0 = get_llvm_target_noext(data);\n    auto features = join_feature_strs(res0.second);\n    append_ext_features(features, data.ext_features);\n    return std::make_pair(std::move(res0.first), std::move(features));\n}\n\nstatic FeatureList<feature_sz> get_max_feature(void)\n{\n#ifdef _CPU_ARM_\n    auto arch = get_elf_arch();\n    auto features = real_feature_masks;\n    if (arch.second == 0)\n        arch.second = 'A';\n    set_bit(features, Feature::v7, true);\n    set_bit(features, Feature::v8, true);\n    if (arch.second == 'M') {\n        set_bit(features, Feature::mclass, true);\n        set_bit(features, Feature::v8_m_main, true);\n    }\n    else if (arch.second == 'R') {\n        set_bit(features, Feature::rclass, true);\n    }\n    else if (arch.second == 'A') {\n        set_bit(features, Feature::aclass, true);\n        set_bit(features, Feature::v8_1a, true);\n        set_bit(features, Feature::v8_2a, true);\n    }\n    return features;\n#else\n    // There isn't currently any conflicting features on AArch64\n    return feature_masks;\n#endif\n}\n\n}\n\nusing namespace ARM;\n\nJL_DLLEXPORT void jl_dump_host_cpu(void)\n{\n    dump_cpu_spec(get_host_cpu().first, get_host_cpu().second, feature_names, nfeature_names,\n                  cpus, ncpu_names);\n}\n\nJL_DLLEXPORT jl_value_t *jl_get_cpu_name(void)\n{\n    return jl_cstr_to_string(host_cpu_name().c_str());\n}\n\njl_sysimg_fptrs_t jl_init_processor_sysimg(void *hdl)\n{\n    if (!jit_targets.empty())\n        jl_error(\"JIT targets already initialized\");\n    return parse_sysimg(hdl, sysimg_init_cb);\n}\n\nstd::pair<std::string,std::vector<std::string>> jl_get_llvm_target(bool imaging, uint32_t &flags)\n{\n    ensure_jit_target(imaging);\n    flags = jit_targets[0].en.flags;\n    return get_llvm_target_vec(jit_targets[0]);\n}\n\nconst std::pair<std::string,std::string> &jl_get_llvm_disasm_target(void)\n{\n    // RAS is not currently detectable AFAICT\n    auto max_feature = get_max_feature();\n    static const auto res = get_llvm_target_str(TargetData<feature_sz>{host_cpu_name(),\n                JL_LLVM_VERSION >= 60000 ? \"+dotprod,+ras\" : \"+ras\",\n                {max_feature, 0}, {feature_masks & ~max_feature, 0}, 0});\n    return res;\n}\n\nstd::vector<jl_target_spec_t> jl_get_llvm_clone_targets(void)\n{\n    if (jit_targets.empty())\n        jl_error(\"JIT targets not initialized\");\n    std::vector<jl_target_spec_t> res;\n    for (auto &target: jit_targets) {\n        auto features_en = target.en.features;\n        auto features_dis = target.dis.features;\n        for (auto &fename: feature_names) {\n            if (fename.llvmver > JL_LLVM_VERSION) {\n                unset_bits(features_en, fename.bit);\n                unset_bits(features_dis, fename.bit);\n            }\n        }\n        ARM::disable_depends(features_en);\n        jl_target_spec_t ele;\n        std::tie(ele.cpu_name, ele.cpu_features) = get_llvm_target_str(target);\n        ele.data = serialize_target_data(target.name, features_en, features_dis,\n                                         target.ext_features);\n        ele.flags = target.en.flags;\n        ele.base = target.base;\n        res.push_back(ele);\n    }\n    return res;\n}\n\nextern \"C\" int jl_test_cpu_feature(jl_cpu_feature_t feature)\n{\n    if (feature >= 32 * feature_sz)\n        return 0;\n    return test_nbit(&get_host_cpu().second[0], feature);\n}\n\n#ifdef _CPU_AARCH64_\n// FZ, bit [24]\nstatic constexpr uint32_t fpcr_fz_mask = 1 << 24;\n\nstatic inline uint32_t get_fpcr_aarch64(void)\n{\n    uint32_t fpcr;\n    asm volatile(\"mrs %0, fpcr\" : \"=r\"(fpcr));\n    return fpcr;\n}\n\nstatic inline void set_fpcr_aarch64(uint32_t fpcr)\n{\n    asm volatile(\"msr fpcr, %0\" :: \"r\"(fpcr));\n}\n\nextern \"C\" JL_DLLEXPORT int32_t jl_get_zero_subnormals(void)\n{\n    return (get_fpcr_aarch64() & fpcr_fz_mask) != 0;\n}\n\nextern \"C\" JL_DLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)\n{\n    uint32_t fpcr = get_fpcr_aarch64();\n    fpcr = isZero ? (fpcr | fpcr_fz_mask) : (fpcr & ~fpcr_fz_mask);\n    set_fpcr_aarch64(fpcr);\n    return 0;\n}\n#else\nextern \"C\" JL_DLLEXPORT int32_t jl_get_zero_subnormals(void)\n{\n    return 0;\n}\n\nextern \"C\" JL_DLLEXPORT int32_t jl_set_zero_subnormals(int8_t isZero)\n{\n    return isZero;\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/src/codegen.cpp": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n#include \"llvm-version.h\"\n#include \"platform.h\"\n#include \"options.h\"\n#if defined(_OS_WINDOWS_) && JL_LLVM_VERSION < 70000\n// trick llvm into skipping the generation of _chkstk calls\n//   since it has some codegen issues associated with them:\n//   (a) assumed to be within 32-bit offset\n//   (b) bad asm is generated for certain code patterns:\n//       see https://github.com/JuliaLang/julia/pull/11644#issuecomment-112276813\n// also, use ELF because RuntimeDyld COFF I686 support didn't exist\n// also, use ELF because RuntimeDyld COFF X86_64 doesn't seem to work (fails to generate function pointers)?\n#define FORCE_ELF\n#endif\n#if defined(_OS_WINDOWS_) || defined(_OS_FREEBSD_)\n#  define JL_DISABLE_FPO\n#endif\n#if defined(_CPU_X86_)\n#define JL_NEED_FLOATTEMP_VAR 1\n#endif\n\n#ifndef __STDC_LIMIT_MACROS\n#define __STDC_LIMIT_MACROS\n#define __STDC_CONSTANT_MACROS\n#endif\n\n#include <setjmp.h>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <map>\n#include <array>\n#include <vector>\n#include <set>\n#include <cstdio>\n#include <iostream>\n#include <functional>\n\n// target machine computation\n#if JL_LLVM_VERSION >= 60000\n#include <llvm/CodeGen/TargetSubtargetInfo.h>\n#else\n#include <llvm/Target/TargetSubtargetInfo.h>\n#endif\n#include <llvm/Support/TargetRegistry.h>\n#include <llvm/Target/TargetOptions.h>\n#include <llvm/Support/Host.h>\n#include <llvm/Support/TargetSelect.h>\n#include <llvm/Object/SymbolSize.h>\n\n// IR building\n#include <llvm/IR/IntrinsicInst.h>\n#include <llvm/Object/ObjectFile.h>\n#include <llvm/IR/DIBuilder.h>\n#include <llvm/AsmParser/Parser.h>\n#include <llvm/DebugInfo/DIContext.h>\n#include <llvm/IR/DerivedTypes.h>\n#include <llvm/IR/Intrinsics.h>\n#include <llvm/IR/Attributes.h>\n#include <llvm/IR/IRBuilder.h>\n#include <llvm/IR/MDBuilder.h>\n\n// support\n#include <llvm/ADT/SmallBitVector.h>\n#include <llvm/ADT/Optional.h>\n#include <llvm/Support/raw_ostream.h>\n#include <llvm/Support/FormattedStream.h>\n#include <llvm/Support/SourceMgr.h> // for llvmcall\n#include <llvm/Transforms/Utils/Cloning.h> // for llvmcall inlining\n#include <llvm/Transforms/Utils/BasicBlockUtils.h>\n#include <llvm/IR/Verifier.h> // for llvmcall validation\n#if JL_LLVM_VERSION >= 40000\n#  include <llvm/Bitcode/BitcodeWriter.h>\n#else\n#  include <llvm/Bitcode/ReaderWriter.h>\n#endif\n\n// C API\n#include <llvm-c/Types.h>\n\n// for configuration options\n#include <llvm/Support/PrettyStackTrace.h>\n#include <llvm/Support/CommandLine.h>\n\n#include <llvm/IR/InlineAsm.h>\n#if defined(_CPU_ARM_) || defined(_CPU_AARCH64_)\n#  include <sys/utsname.h>\n#endif\n#if defined(USE_POLLY)\n#include <polly/RegisterPasses.h>\n#include <polly/ScopDetection.h>\n#endif\n#include <llvm/ExecutionEngine/ExecutionEngine.h>\n\nusing namespace llvm;\nnamespace llvm {\n    extern bool annotateSimdLoop(BasicBlock *latch);\n}\n\n#if defined(_OS_WINDOWS_) && !defined(NOMINMAX)\n#define NOMINMAX\n#endif\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"jitlayers.h\"\n#include \"codegen_shared.h\"\n#include \"processor.h\"\n#include \"julia_assert.h\"\n\n// LLVM version compatibility macros\nlegacy::PassManager *jl_globalPM;\n\n#if JL_LLVM_VERSION >= 40000\n#define DIFlagZero (DINode::FlagZero)\n#else\n#define DIFlagZero (0)\n#endif\n\nextern \"C\" {\n\n#include \"builtin_proto.h\"\n\n#ifdef HAVE_SSP\nextern uintptr_t __stack_chk_guard;\nextern void __stack_chk_fail();\n#else\nJL_DLLEXPORT uintptr_t __stack_chk_guard = (uintptr_t)0xBAD57ACCBAD67ACC; // 0xBADSTACKBADSTACK\nJL_DLLEXPORT void __stack_chk_fail()\n{\n    /* put your panic function or similar in here */\n    fprintf(stderr, \"fatal error: stack corruption detected\\n\");\n    gc_debug_critical_error();\n    abort(); // end with abort, since the compiler destroyed the stack upon entry to this function, there's no going back now\n}\n#endif\n\n#ifdef _OS_WINDOWS_\n#if defined(_CPU_X86_64_)\n#if defined(_COMPILER_MINGW_)\nextern void ___chkstk_ms(void);\n#else\nextern void __chkstk(void);\n#endif\n#else\n#if defined(_COMPILER_MINGW_)\n#undef _alloca\nextern void _alloca(void);\n#else\nextern void _chkstk(void);\n#endif\n#endif\n//void *force_chkstk(void) {\n//    return alloca(40960);\n//}\n#endif\n}\n\n#if defined(_COMPILER_MICROSOFT_) && !defined(__alignof__)\n#define __alignof__ __alignof\n#endif\n\n#define DISABLE_FLOAT16\n\n// llvm state\nJL_DLLEXPORT LLVMContext jl_LLVMContext;\nTargetMachine *jl_TargetMachine;\n\nextern JITEventListener *CreateJuliaJITEventListener();\n\n// for image reloading\nbool imaging_mode = false;\n\nModule *shadow_output;\n#define jl_Module ctx.f->getParent()\n#define jl_builderModule(builder) (builder).GetInsertBlock()->getParent()->getParent()\n\nstatic DataLayout jl_data_layout(\"\");\n\n// types\nstatic Type *T_jlvalue;\nstatic Type *T_pjlvalue;\nstatic Type *T_prjlvalue;\nstatic Type *T_ppjlvalue;\nstatic Type *T_pprjlvalue;\nstatic Type *jl_array_llvmt;\nstatic Type *jl_parray_llvmt;\nstatic FunctionType *jl_func_sig;\nstatic FunctionType *jl_func_sig_sparams;\nstatic Type *T_pvoidfunc;\n\nstatic IntegerType *T_int1;\nstatic IntegerType *T_int8;\nstatic IntegerType *T_int16;\nstatic IntegerType *T_int32;\nstatic IntegerType *T_int64;\n\nstatic IntegerType *T_uint8;\nstatic IntegerType *T_uint16;\nstatic IntegerType *T_uint32;\nstatic IntegerType *T_uint64;\n\nstatic IntegerType *T_char;\nstatic IntegerType *T_size;\nstatic IntegerType *T_sigatomic;\n\nstatic Type *T_float16;\nstatic Type *T_float32;\nstatic Type *T_float64;\nstatic Type *T_float128;\n\nstatic Type *T_pint8;\nstatic Type *T_pint16;\nstatic Type *T_pint32;\nstatic Type *T_pint64;\nstatic Type *T_psize;\nstatic Type *T_pfloat32;\nstatic Type *T_pfloat64;\n\nstatic Type *T_ppint8;\nstatic Type *T_pppint8;\n\nstatic Type *T_void;\n\n// type-based alias analysis nodes.  Indentation of comments indicates hierarchy.\nstatic MDNode *tbaa_gcframe;    // GC frame\n// LLVM should have enough info for alias analysis of non-gcframe stack slot\n// this is mainly a place holder for `jl_cgval_t::tbaa`\nstatic MDNode *tbaa_stack;      // stack slot\nstatic MDNode *tbaa_data;       // Any user data that `pointerset/ref` are allowed to alias\nstatic MDNode *tbaa_binding;        // jl_binding_t::value\nstatic MDNode *tbaa_value;          // jl_value_t, that is not jl_array_t\nstatic MDNode *tbaa_mutab;              // mutable type\nstatic MDNode *tbaa_immut;              // immutable type\nstatic MDNode *tbaa_ptrarraybuf;    // Data in an array of boxed values\nstatic MDNode *tbaa_arraybuf;       // Data in an array of POD\nstatic MDNode *tbaa_unionselbyte;   // a selector byte in isbits Union struct fields\nstatic MDNode *tbaa_array;      // jl_array_t\nstatic MDNode *tbaa_arrayptr;       // The pointer inside a jl_array_t\nstatic MDNode *tbaa_arraysize;      // A size in a jl_array_t\nstatic MDNode *tbaa_arraylen;       // The len in a jl_array_t\nstatic MDNode *tbaa_arrayflags;     // The flags in a jl_array_t\nstatic MDNode *tbaa_arrayoffset;     // The offset in a jl_array_t\nstatic MDNode *tbaa_arrayselbyte;   // a selector byte in a isbits Union jl_array_t\nstatic MDNode *tbaa_const;      // Memory that is immutable by the time LLVM can see it\n\nstatic Attribute Thunk;\n\n// Basic DITypes\nstatic DICompositeType *jl_value_dillvmt;\nstatic DIDerivedType *jl_pvalue_dillvmt;\nstatic DIDerivedType *jl_ppvalue_dillvmt;\nstatic DISubroutineType *jl_di_func_sig;\nstatic DISubroutineType *jl_di_func_null_sig;\n\n\n// constants\nstatic Constant *V_null;\nextern \"C\" {\nJL_DLLEXPORT Type *julia_type_to_llvm(jl_value_t *jt, bool *isboxed=NULL);\n}\nstatic bool type_is_ghost(Type *ty)\n{\n    return (ty == T_void || ty->isEmptyTy());\n}\n\n// global vars\nstatic GlobalVariable *jlRTLD_DEFAULT_var;\n#ifdef _OS_WINDOWS_\nstatic GlobalVariable *jlexe_var;\nstatic GlobalVariable *jldll_var;\n#endif //_OS_WINDOWS_\n\nstatic Function *jltls_states_func;\n\n// important functions\nstatic Function *jlnew_func;\nstatic Function *jlthrow_func;\nstatic Function *jlerror_func;\nstatic Function *jltypeerror_func;\nstatic Function *jlundefvarerror_func;\nstatic Function *jlboundserror_func;\nstatic Function *jluboundserror_func;\nstatic Function *jlvboundserror_func;\nstatic Function *jlboundserrorv_func;\nstatic Function *jlcheckassign_func;\nstatic Function *jldeclareconst_func;\nstatic Function *jlgetbindingorerror_func;\nstatic Function *jlboundp_func;\nstatic Function *jltopeval_func;\nstatic Function *jlcopyast_func;\nstatic Function *jltuple_func;\nstatic Function *jlnsvec_func;\nstatic Function *jlapplygeneric_func;\nstatic Function *jlinvoke_func;\nstatic Function *jlapply2va_func;\nstatic Function *jlgetfield_func;\nstatic Function *jlmethod_func;\nstatic Function *jlgenericfunction_func;\nstatic Function *jlenter_func;\nstatic Function *jlleave_func;\nstatic Function *jlegal_func;\nstatic Function *jl_alloc_obj_func;\nstatic Function *jl_newbits_func;\nstatic Function *jl_typeof_func;\nstatic Function *jl_simdloop_marker_func;\nstatic Function *jl_simdivdep_marker_func;\nstatic Function *jl_write_barrier_func;\nstatic Function *jlisa_func;\nstatic Function *jlsubtype_func;\nstatic Function *jlapplytype_func;\nstatic Function *setjmp_func;\nstatic Function *memcmp_derived_func;\nstatic Function *box_int8_func;\nstatic Function *box_uint8_func;\nstatic Function *box_int16_func;\nstatic Function *box_uint16_func;\nstatic Function *box_int32_func;\nstatic Function *box_char_func;\nstatic Function *box_uint32_func;\nstatic Function *box_int64_func;\nstatic Function *box_uint64_func;\nstatic Function *box_float32_func;\nstatic Function *box_float64_func;\nstatic Function *box_ssavalue_func;\nstatic Function *expect_func;\nstatic Function *jldlsym_func;\nstatic Function *jltypeassert_func;\n//static Function *jlgetnthfield_func;\nstatic Function *jlgetnthfieldchecked_func;\n//static Function *jlsetnthfield_func;\nstatic Function *jlgetcfunctiontrampoline_func;\n#ifdef _OS_WINDOWS_\nstatic Function *resetstkoflw_func;\n#if defined(_CPU_X86_64_)\nFunction *juliapersonality_func;\n#endif\n#endif\nstatic Function *diff_gc_total_bytes_func;\nstatic Function *jlarray_data_owner_func;\nstatic GlobalVariable *jlgetworld_global;\n\n// placeholder functions\nstatic Function *gcroot_flush_func;\nstatic Function *gc_preserve_begin_func;\nstatic Function *gc_preserve_end_func;\nstatic Function *except_enter_func;\nstatic Function *pointer_from_objref_func;\n\nstatic std::vector<Type *> two_pvalue_llvmt;\nstatic std::vector<Type *> three_pvalue_llvmt;\nstatic std::vector<Type *> four_pvalue_llvmt;\n\nstatic std::map<jl_fptr_args_t, Function*> builtin_func_map;\n\n// --- code generation ---\nextern \"C\" {\n    int globalUnique = 0;\n}\n\ntemplate<typename T>\nstatic void add_return_attr(T *f, Attribute::AttrKind Kind)\n{\n#if JL_LLVM_VERSION >= 50000\n    f->addAttribute(AttributeList::ReturnIndex, Kind);\n#else\n    f->addAttribute(AttributeSet::ReturnIndex, Kind);\n#endif\n}\n\nstatic MDNode *best_tbaa(jl_value_t *jt) {\n    jt = jl_unwrap_unionall(jt);\n    if (!jl_is_datatype(jt))\n        return tbaa_value;\n    if (jl_is_abstracttype(jt))\n        return tbaa_value;\n    // If we're here, we know all subtypes are (im)mutable, even if we\n    // don't know what the exact type is\n    return jl_is_mutable(jt) ? tbaa_mutab : tbaa_immut;\n}\n\n// tracks whether codegen is currently able to simply stack-allocate this type\n// note that this is guaranteed to include jl_isbits\nstatic bool jl_justbits(jl_value_t* t)\n{\n    return jl_is_immutable_datatype(t) && ((jl_datatype_t*)t)->layout && ((jl_datatype_t*)t)->layout->npointers == 0;\n}\n\n// metadata tracking for a llvm Value* during codegen\nstruct jl_cgval_t {\n    Value *V; // may be of type T* or T, or set to NULL if ghost (or if the value has not been initialized yet, for a variable definition)\n    // For unions, we may need to keep a reference to the boxed part individually.\n    // If this is non-NULL, then, at runtime, we satisfy the invariant that (for the corresponding\n    // runtime values) if `(TIndex | 0x80) != 0`, then `Vboxed == V` (by value).\n    // For convenience, we also set this value of isboxed values, in which case\n    // it is equal (at compile time) to V.\n    Value *Vboxed;\n    Value *TIndex; // if `V` is an unboxed (tagged) Union described by `typ`, this gives the DataType index (1-based, small int) as an i8\n    jl_value_t *constant; // constant value (rooted in linfo.def.roots)\n    jl_value_t *typ; // the original type of V, never NULL\n    bool isboxed; // whether this value is a jl_value_t* allocated on the heap with the right type tag\n    bool isghost; // whether this value is \"ghost\"\n    MDNode *tbaa; // The related tbaa node. Non-NULL iff this holds an address.\n    bool ispointer() const\n    {\n        // whether this value is compatible with `data_pointer`\n        return tbaa != nullptr;\n    }\n    jl_cgval_t(Value *V, Value *gcroot, bool isboxed, jl_value_t *typ, Value *tindex) : // general constructor (with pointer type auto-detect)\n        V(V), // V is allowed to be NULL in a jl_varinfo_t context, but not during codegen contexts\n        Vboxed(isboxed ? V : nullptr),\n        TIndex(tindex),\n        constant(NULL),\n        typ(typ),\n        isboxed(isboxed),\n        isghost(false),\n        tbaa(isboxed ? best_tbaa(typ) : nullptr)\n    {\n        assert(gcroot == nullptr);\n        assert(!(isboxed && TIndex != NULL));\n        assert(TIndex == NULL || TIndex->getType() == T_int8);\n    }\n    explicit jl_cgval_t(jl_value_t *typ) : // ghost value constructor\n        // mark explicit to avoid being used implicitly for conversion from NULL (use jl_cgval_t() instead)\n        V(NULL),\n        Vboxed(NULL),\n        TIndex(NULL),\n        constant(((jl_datatype_t*)typ)->instance),\n        typ(typ),\n        isboxed(false),\n        isghost(true),\n        tbaa(nullptr)\n    {\n        assert(jl_is_datatype(typ));\n        assert(constant);\n    }\n    jl_cgval_t(const jl_cgval_t &v, jl_value_t *typ, Value *tindex) : // copy constructor with new type\n        V(v.V),\n        Vboxed(v.Vboxed),\n        TIndex(tindex),\n        constant(v.constant),\n        typ(typ),\n        isboxed(v.isboxed),\n        isghost(v.isghost),\n        tbaa(v.tbaa)\n    {\n        // this constructor expects we had a badly or equivalently typed version\n        // make sure we aren't discarding the actual type information\n        if (v.TIndex) {\n            assert((TIndex == NULL) == jl_is_concrete_type(typ));\n        }\n        else {\n            assert(isboxed || v.typ == typ || tindex);\n        }\n    }\n    jl_cgval_t() : // undef / unreachable / default constructor\n        V(UndefValue::get(T_void)),\n        Vboxed(NULL),\n        TIndex(NULL),\n        constant(NULL),\n        typ(jl_bottom_type),\n        isboxed(false),\n        isghost(true),\n        tbaa(nullptr)\n    {\n    }\n};\n\n// per-local-variable information\nstruct jl_varinfo_t {\n    Instruction *boxroot; // an address, if the var might be in a jl_value_t** stack slot (marked tbaa_const, if appropriate)\n    jl_cgval_t value; // a stack slot or constant value\n    Value *pTIndex; // i8* stack slot for the value.TIndex tag describing `value.V`\n    DILocalVariable *dinfo;\n    // if the variable might be used undefined and is not boxed\n    // this i1 flag is true when it is defined\n    Value *defFlag;\n    bool isSA; // whether all stores dominate all uses\n    bool isVolatile;\n    bool isArgument;\n    bool usedUndef;\n    bool used;\n\n    jl_varinfo_t() : boxroot(NULL),\n                     value(jl_cgval_t()),\n                     pTIndex(NULL),\n                     dinfo(NULL),\n                     defFlag(NULL),\n                     isSA(false),\n                     isVolatile(false),\n                     isArgument(false),\n                     usedUndef(false),\n                     used(false)\n    {\n    }\n};\n\nstruct jl_returninfo_t {\n    Function *decl;\n    enum CallingConv {\n        Boxed = 0,\n        Register,\n        SRet,\n        Union,\n        Ghosts\n    } cc;\n    size_t union_bytes;\n    size_t union_align;\n    size_t union_minalign;\n};\n\nstatic jl_returninfo_t get_specsig_function(Module *M, const std::string &name, jl_value_t *sig, jl_value_t *jlrettype);\n\n// information about the context of a piece of code: its enclosing\n// function and module, and visible local variables and labels.\nclass jl_codectx_t {\npublic:\n    IRBuilder<> builder;\n    Function *f = NULL;\n    // local var info. globals are not in here.\n    std::vector<jl_varinfo_t> slots;\n    std::map<int, jl_varinfo_t> phic_slots;\n    std::vector<jl_cgval_t> SAvalues;\n    std::vector<std::tuple<jl_cgval_t, BasicBlock *, AllocaInst *, PHINode *, jl_value_t *>> PhiNodes;\n    std::vector<bool> ssavalue_assigned;\n    jl_module_t *module = NULL;\n    jl_method_instance_t *linfo = NULL;\n    jl_code_info_t *source = NULL;\n    jl_array_t *code = NULL;\n    size_t world = 0;\n    jl_array_t *roots = NULL;\n    const char *name = NULL;\n    StringRef file{};\n    ssize_t *line = NULL;\n    Value *spvals_ptr = NULL;\n    Value *argArray = NULL;\n    Value *argCount = NULL;\n    std::string funcName;\n    int vaSlot = -1;        // name of vararg argument\n    bool has_sret = false;\n    int nReqArgs = 0;\n    int nargs = 0;\n    int nvargs = -1;\n\n    CallInst *ptlsStates = NULL;\n    Value *signalPage = NULL;\n    Value *world_age_field = NULL;\n\n    bool debug_enabled = false;\n    const jl_cgparams_t *params = NULL;\n\n    jl_codectx_t(LLVMContext &llvmctx)\n      : builder(llvmctx) { }\n\n    ~jl_codectx_t() {\n        assert(this->roots == NULL);\n    }\n};\n\nstatic jl_cgval_t emit_expr(jl_codectx_t &ctx, jl_value_t *expr, ssize_t ssaval = -1);\nstatic Value *global_binding_pointer(jl_codectx_t &ctx, jl_module_t *m, jl_sym_t *s,\n                                     jl_binding_t **pbnd, bool assign);\nstatic jl_cgval_t emit_checked_var(jl_codectx_t &ctx, Value *bp, jl_sym_t *name, bool isvol, MDNode *tbaa);\nstatic jl_cgval_t emit_sparam(jl_codectx_t &ctx, size_t i);\nstatic Value *emit_condition(jl_codectx_t &ctx, const jl_cgval_t &condV, const std::string &msg);\nstatic void allocate_gc_frame(jl_codectx_t &ctx, BasicBlock *b0);\nstatic void CreateTrap(IRBuilder<> &irbuilder);\nstatic Value *emit_jlcall(jl_codectx_t &ctx, Value *theFptr, Value *theF,\n                          jl_cgval_t *args, size_t nargs);\n\nstatic Value *literal_pointer_val(jl_codectx_t &ctx, jl_value_t *p);\nstatic GlobalVariable *prepare_global_in(Module *M, GlobalVariable *G);\n#define prepare_global(G) prepare_global_in(jl_Module, (G))\n\n// --- convenience functions for tagging llvm values with julia types ---\n\nstatic GlobalVariable *get_pointer_to_constant(Constant *val, StringRef name, Module &M)\n{\n    GlobalVariable *gv = new GlobalVariable(\n            M,\n            val->getType(),\n            true,\n            GlobalVariable::PrivateLinkage,\n            val,\n            name);\n    gv->setUnnamedAddr(GlobalValue::UnnamedAddr::Global);\n    return gv;\n}\n\nstatic AllocaInst *emit_static_alloca(jl_codectx_t &ctx, Type *lty, int arraysize=1)\n{\n    return new AllocaInst(lty,\n#if JL_LLVM_VERSION >= 50000\n            0,\n#endif\n            ConstantInt::get(T_int32, arraysize), \"\", /*InsertBefore=*/ctx.ptlsStates);\n}\n\nstatic inline jl_cgval_t ghostValue(jl_value_t *typ)\n{\n    if (typ == jl_bottom_type)\n        return jl_cgval_t(); // Undef{}\n    if (typ == (jl_value_t*)jl_typeofbottom_type) {\n        // normalize TypeofBottom to Type{Union{}}\n        typ = (jl_value_t*)jl_wrap_Type(jl_bottom_type);\n    }\n    if (jl_is_type_type(typ)) {\n        // replace T::Type{T} with T, by assuming that T must be a leaftype of some sort\n        jl_cgval_t constant(NULL, NULL, true, typ, NULL);\n        constant.constant = jl_tparam0(typ);\n        return constant;\n    }\n    return jl_cgval_t(typ);\n}\nstatic inline jl_cgval_t ghostValue(jl_datatype_t *typ)\n{\n    return ghostValue((jl_value_t*)typ);\n}\n\nstatic inline jl_cgval_t mark_julia_const(jl_value_t *jv)\n{\n    jl_value_t *typ;\n    if (jl_is_type(jv)) {\n        typ = (jl_value_t*)jl_wrap_Type(jv); // TODO: gc-root this?\n    }\n    else {\n        typ = jl_typeof(jv);\n        if (type_is_ghost(julia_type_to_llvm(typ))) {\n            return ghostValue(typ);\n        }\n    }\n    jl_cgval_t constant(NULL, NULL, true, typ, NULL);\n    constant.constant = jv;\n    return constant;\n}\n\n\nstatic inline jl_cgval_t mark_julia_slot(Value *v, jl_value_t *typ, Value *tindex, MDNode *tbaa)\n{\n    // this enables lazy-copying of immutable values and stack or argument slots\n    assert(tbaa);\n    jl_cgval_t tagval(v, NULL, false, typ, tindex);\n    tagval.tbaa = tbaa;\n    return tagval;\n}\n\nstatic inline jl_cgval_t value_to_pointer(jl_codectx_t &ctx, Value *v, jl_value_t *typ, Value *tindex)\n{\n    Value *loc;\n    if (Constant *cv = dyn_cast<Constant>(v)) {\n        loc = get_pointer_to_constant(cv, \"\", *jl_Module);\n    }\n    else {\n        loc = emit_static_alloca(ctx, v->getType());\n        ctx.builder.CreateStore(v, loc);\n    }\n    return mark_julia_slot(loc, typ, tindex, tbaa_stack);\n}\nstatic inline jl_cgval_t value_to_pointer(jl_codectx_t &ctx, const jl_cgval_t &v)\n{\n    if (v.ispointer())\n        return v;\n    return value_to_pointer(ctx, v.V, v.typ, v.TIndex);\n}\n\nstatic inline jl_cgval_t mark_julia_type(jl_codectx_t &ctx, Value *v, bool isboxed, jl_value_t *typ)\n{\n    if (jl_is_datatype(typ) && jl_is_datatype_singleton((jl_datatype_t*)typ)) {\n        // no need to explicitly load/store a constant/ghost value\n        return ghostValue(typ);\n    }\n    if (jl_is_type_type(typ)) {\n        jl_value_t *tp0 = jl_tparam0(typ);\n        if (jl_is_concrete_type(tp0) || tp0 == jl_bottom_type) {\n            // replace T::Type{T} with T\n            return ghostValue(typ);\n        }\n    }\n    Type *T = julia_type_to_llvm(typ);\n    if (type_is_ghost(T)) {\n        return ghostValue(typ);\n    }\n    if (v && !isboxed && v->getType()->isAggregateType()) {\n        // eagerly put this back onto the stack\n        // llvm mem2reg pass will remove this if unneeded\n        return value_to_pointer(ctx, v, typ, NULL);\n    }\n    return jl_cgval_t(v, NULL, isboxed, typ, NULL);\n}\n\nstatic inline jl_cgval_t mark_julia_type(jl_codectx_t &ctx, Value *v, bool isboxed, jl_datatype_t *typ)\n{\n    return mark_julia_type(ctx, v, isboxed, (jl_value_t*)typ);\n}\n\n// see if it might be profitable (and cheap) to change the type of v to typ\nstatic inline jl_cgval_t update_julia_type(jl_codectx_t &ctx, const jl_cgval_t &v, jl_value_t *typ)\n{\n    if (v.typ == typ || v.typ == jl_bottom_type || v.constant || typ == (jl_value_t*)jl_any_type || jl_egal(v.typ, typ))\n        return v; // fast-path\n    if (jl_is_concrete_type(v.typ) && !jl_is_kind(v.typ)) {\n        if (jl_is_concrete_type(typ) && !jl_is_kind(typ)) {\n            // type mismatch: changing from one leaftype to another\n            CreateTrap(ctx.builder);\n            return jl_cgval_t();\n        }\n        return v; // doesn't improve type info\n    }\n    if (v.TIndex) {\n        jl_value_t *utyp = jl_unwrap_unionall(typ);\n        if (jl_is_datatype(utyp)) {\n            bool alwaysboxed;\n            if (jl_is_concrete_type(utyp))\n                alwaysboxed = !jl_justbits(utyp);\n            else\n                alwaysboxed = !((jl_datatype_t*)utyp)->abstract && ((jl_datatype_t*)utyp)->mutabl;\n            if (alwaysboxed) {\n                // discovered that this union-split type must actually be isboxed\n                if (v.Vboxed) {\n                    return jl_cgval_t(v.Vboxed, nullptr, true, typ, NULL);\n                }\n                else {\n                    // type mismatch (there weren't any boxed values in the union)\n                    CreateTrap(ctx.builder);\n                    return jl_cgval_t();\n                }\n            }\n        }\n        if (!jl_is_concrete_type(typ))\n            return v; // not generally worth trying to change type info (which would require recomputing tindex)\n    }\n    Type *T = julia_type_to_llvm(typ);\n    if (type_is_ghost(T))\n        return ghostValue(typ);\n    return jl_cgval_t(v, typ, NULL);\n}\n\nstatic jl_cgval_t convert_julia_type(jl_codectx_t &ctx, const jl_cgval_t &v, jl_value_t *typ);\n\n// --- allocating local variables ---\n\nstatic jl_sym_t *slot_symbol(jl_codectx_t &ctx, int s)\n{\n    return (jl_sym_t*)jl_array_ptr_ref(ctx.source->slotnames, s);\n}\n\nstatic void store_def_flag(jl_codectx_t &ctx, const jl_varinfo_t &vi, bool val)\n{\n    assert((!vi.boxroot || vi.pTIndex) && \"undef check is null pointer for boxed things\");\n    assert(vi.usedUndef && vi.defFlag && \"undef flag codegen corrupted\");\n    ctx.builder.CreateStore(ConstantInt::get(T_int1, val), vi.defFlag, vi.isVolatile);\n}\n\nstatic void alloc_def_flag(jl_codectx_t &ctx, jl_varinfo_t& vi)\n{\n    assert((!vi.boxroot || vi.pTIndex) && \"undef check is null pointer for boxed things\");\n    if (vi.usedUndef) {\n        vi.defFlag = emit_static_alloca(ctx, T_int1);\n        store_def_flag(ctx, vi, false);\n    }\n}\n\n\n// --- utilities ---\n\nstatic void CreateTrap(IRBuilder<> &irbuilder)\n{\n    Function *f = irbuilder.GetInsertBlock()->getParent();\n    Function *trap_func = Intrinsic::getDeclaration(\n            f->getParent(),\n            Intrinsic::trap);\n    irbuilder.CreateCall(trap_func);\n    irbuilder.CreateUnreachable();\n    BasicBlock *newBB = BasicBlock::Create(irbuilder.getContext(), \"after_noret\", f);\n    irbuilder.SetInsertPoint(newBB);\n}\n\n#if 0 // this code is likely useful, but currently unused\n#ifndef JL_NDEBUG\nstatic void CreateConditionalAbort(IRBuilder<> &irbuilder, Value *test)\n{\n    Function *f = irbuilder.GetInsertBlock()->getParent();\n    BasicBlock *abortBB = BasicBlock::Create(jl_LLVMContext, \"debug_abort\", f);\n    BasicBlock *postBB = BasicBlock::Create(jl_LLVMContext, \"post_abort\", f);\n    irbuilder.CreateCondBr(test, abortBB, postBB);\n    irbuilder.SetInsertPoint(abortBB);\n    Function *trap_func = Intrinsic::getDeclaration(\n            f->getParent(),\n            Intrinsic::trap);\n    irbuilder.CreateCall(trap_func);\n    irbuilder.CreateUnreachable();\n    irbuilder.SetInsertPoint(postBB);\n}\n#endif\n#endif\n\nstatic void emit_write_barrier(jl_codectx_t&, Value*, Value*);\n\n#include \"cgutils.cpp\"\n\nstatic void jl_rethrow_with_add(const char *fmt, ...)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    if (jl_typeis(ptls->exception_in_transit, jl_errorexception_type)) {\n        char *str = jl_string_data(jl_fieldref(ptls->exception_in_transit,0));\n        char buf[1024];\n        va_list args;\n        va_start(args, fmt);\n        int nc = vsnprintf(buf, sizeof(buf), fmt, args);\n        va_end(args);\n        nc += snprintf(buf+nc, sizeof(buf)-nc, \": %s\", str);\n        jl_value_t *msg = jl_pchar_to_string(buf, nc);\n        JL_GC_PUSH1(&msg);\n        jl_throw(jl_new_struct(jl_errorexception_type, msg));\n    }\n    jl_rethrow();\n}\n\nstatic jl_cgval_t convert_julia_type_union(jl_codectx_t &ctx, const jl_cgval_t &v, jl_value_t *typ)\n{\n    // previous value was a split union, compute new index, or box\n    Value *new_tindex = ConstantInt::get(T_int8, 0x80);\n    SmallBitVector skip_box(1, true);\n    Value *tindex = ctx.builder.CreateAnd(v.TIndex, ConstantInt::get(T_int8, 0x7f));\n    if (jl_is_uniontype(typ)) {\n        // compute the TIndex mapping from v.typ -> typ\n        unsigned counter = 0;\n        for_each_uniontype_small(\n            // for each old union-split value\n            [&](unsigned idx, jl_datatype_t *jt) {\n                unsigned new_idx = get_box_tindex(jt, typ);\n                bool t;\n                if (new_idx) {\n                    // found a matching element,\n                    // match it against either the unboxed index\n                    Value *cmp = ctx.builder.CreateICmpEQ(tindex, ConstantInt::get(T_int8, idx));\n                    new_tindex = ctx.builder.CreateSelect(cmp, ConstantInt::get(T_int8, new_idx), new_tindex);\n                    t = true;\n                }\n                else if (!jl_subtype((jl_value_t*)jt, typ)) {\n                    // new value doesn't need to be boxed\n                    // since it isn't part of the new union\n                    t = true;\n                }\n                else {\n                    // will actually need to box this element\n                    // since it appeared as a leaftype in the original type\n                    // but not in the remark type\n                    t = false;\n                }\n                skip_box.resize(idx + 1, t);\n            },\n            v.typ,\n            counter);\n    }\n\n    // some of the values are still unboxed\n    if (!isa<Constant>(new_tindex)) {\n        Value *wasboxed = NULL;\n        // If the old value was boxed and unknown (type tag 0x80),\n        // it is possible that the tag was actually one of the types\n        // that are now explicitly represented. To find out, we need\n        // to compare typeof(v.Vboxed) (i.e. the type of the unknown\n        // value) against all the types that are now explicitly\n        // selected and select the appropriate one as our new tindex.\n        if (v.Vboxed) {\n            wasboxed = ctx.builder.CreateAnd(v.TIndex, ConstantInt::get(T_int8, 0x80));\n            new_tindex = ctx.builder.CreateOr(wasboxed, new_tindex);\n            wasboxed = ctx.builder.CreateICmpNE(wasboxed, ConstantInt::get(T_int8, 0));\n\n            BasicBlock *currBB = ctx.builder.GetInsertBlock();\n\n            // We lazily create a BB for this, once we decide that we\n            // actually need it.\n            Value *union_box_dt = NULL;\n            BasicBlock *union_isaBB = NULL;\n            auto maybe_setup_union_isa = [&]() {\n                if (!union_isaBB) {\n                    union_isaBB = BasicBlock::Create(jl_LLVMContext, \"union_isa\", ctx.f);\n                    ctx.builder.SetInsertPoint(union_isaBB);\n                    union_box_dt = emit_typeof(ctx, v.Vboxed);\n                }\n            };\n\n            // If we don't find a match. The type remains unknown\n            // (0x80). We could use `v.Tindex`, here, since we know\n            // it has to be 0x80, but it seems likely the backend\n            // will like the explicit constant better.\n            Value *union_box_tindex = ConstantInt::get(T_int8, 0x80);\n            unsigned counter = 0;\n            for_each_uniontype_small(\n                // for each new union-split value\n                [&](unsigned idx, jl_datatype_t *jt) {\n                    unsigned old_idx = get_box_tindex(jt, v.typ);\n                    if (old_idx == 0) {\n                        // didn't handle this item before, select its new union index\n                        maybe_setup_union_isa();\n                        Value *cmp = ctx.builder.CreateICmpEQ(maybe_decay_untracked(literal_pointer_val(ctx, (jl_value_t*)jt)), union_box_dt);\n                        union_box_tindex = ctx.builder.CreateSelect(cmp, ConstantInt::get(T_int8, 0x80 | idx), union_box_tindex);\n                    }\n                },\n                typ,\n                counter);\n            if (union_box_dt) {\n                BasicBlock *postBB = BasicBlock::Create(jl_LLVMContext, \"post_union_isa\", ctx.f);\n                ctx.builder.CreateBr(postBB);\n                ctx.builder.SetInsertPoint(currBB);\n                Value *wasunknown = ctx.builder.CreateICmpEQ(v.TIndex, ConstantInt::get(T_int8, 0x80));\n                ctx.builder.CreateCondBr(wasunknown, union_isaBB, postBB);\n                ctx.builder.SetInsertPoint(postBB);\n                PHINode *tindex_phi = ctx.builder.CreatePHI(T_int8, 2);\n                tindex_phi->addIncoming(new_tindex, currBB);\n                tindex_phi->addIncoming(union_box_tindex, union_isaBB);\n                new_tindex = tindex_phi;\n            }\n        }\n        if (!skip_box.all()) {\n            // some values weren't unboxed in the new union\n            // box them now (tindex above already selected 0x80 = box for them)\n            Value *boxv = box_union(ctx, v, skip_box);\n            if (v.Vboxed) {\n                // If the value is boxed both before and after, we don't need\n                // to touch it at all. Otherwise we're either transitioning\n                // unboxed->boxed, or leaving an unboxed value in place.\n                Value *isboxed = ctx.builder.CreateICmpNE(\n                    ctx.builder.CreateAnd(new_tindex, ConstantInt::get(T_int8, 0x80)),\n                    ConstantInt::get(T_int8, 0));\n                boxv = ctx.builder.CreateSelect(\n                    ctx.builder.CreateAnd(wasboxed, isboxed), v.Vboxed, boxv);\n            }\n            if (v.V == NULL) {\n                // v.V might be NULL if it was all ghost objects before\n                return jl_cgval_t(boxv, NULL, false, typ, new_tindex);\n            } else {\n                Value *isboxv = ctx.builder.CreateIsNotNull(boxv);\n                Value *slotv;\n                MDNode *tbaa;\n                if (v.ispointer()) {\n                    slotv = v.V;\n                    tbaa = v.tbaa;\n                }\n                else {\n                    slotv = emit_static_alloca(ctx, v.V->getType());\n                    ctx.builder.CreateStore(v.V, slotv);\n                    tbaa = tbaa_stack;\n                }\n                slotv = ctx.builder.CreateSelect(isboxv,\n                            decay_derived(boxv),\n                            decay_derived(emit_bitcast(ctx, slotv, boxv->getType())));\n                jl_cgval_t newv = jl_cgval_t(slotv, NULL, false, typ, new_tindex);\n                newv.Vboxed = boxv;\n                newv.tbaa = tbaa;\n                return newv;\n            }\n        }\n    }\n    else {\n        return jl_cgval_t(boxed(ctx, v), NULL, true, typ, NULL);\n    }\n    return jl_cgval_t(v, typ, new_tindex);\n}\n\n// given a value marked with type `v.typ`, compute the mapping and/or boxing to return a value of type `typ`\n// TODO: should this set TIndex when trivial (such as 0x80 or concrete types) ?\nstatic jl_cgval_t convert_julia_type(jl_codectx_t &ctx, const jl_cgval_t &v, jl_value_t *typ)\n{\n    if (typ == (jl_value_t*)jl_typeofbottom_type)\n        return ghostValue(typ); // normalize TypeofBottom to Type{Union{}}\n    if (v.typ == typ || v.typ == jl_bottom_type || jl_egal(v.typ, typ))\n        return v; // fast-path\n    Type *T = julia_type_to_llvm(typ);\n    if (type_is_ghost(T))\n        return ghostValue(typ);\n    Value *new_tindex = NULL;\n    if (jl_is_concrete_type(typ)) {\n        if (v.TIndex && !jl_justbits(typ)) {\n            // discovered that this union-split type must actually be isboxed\n            if (v.Vboxed) {\n                return jl_cgval_t(v.Vboxed, nullptr, true, typ, NULL);\n            }\n            else {\n                // type mismatch: there weren't any boxed values in the union\n                CreateTrap(ctx.builder);\n                return jl_cgval_t();\n            }\n        }\n        if (jl_is_concrete_type(v.typ) && !jl_is_kind(v.typ)) {\n            if (jl_is_concrete_type(typ) && !jl_is_kind(typ)) {\n                // type mismatch: changing from one leaftype to another\n                CreateTrap(ctx.builder);\n                return jl_cgval_t();\n            }\n        }\n    }\n    else {\n        bool makeboxed = false;\n        if (v.TIndex) {\n            return convert_julia_type_union(ctx, v, typ);\n        }\n        else if (!v.isboxed && jl_is_uniontype(typ)) {\n            // previous value was unboxed (leaftype), statically compute union tindex\n            assert(jl_is_concrete_type(v.typ));\n            unsigned new_idx = get_box_tindex((jl_datatype_t*)v.typ, typ);\n            if (new_idx) {\n                new_tindex = ConstantInt::get(T_int8, new_idx);\n                if (v.V && !v.ispointer()) {\n                    // TODO: remove this branch once all consumers of v.TIndex understand how to handle a non-ispointer value\n                    Value *slotv = emit_static_alloca(ctx, v.V->getType());\n                    ctx.builder.CreateStore(v.V, slotv);\n                    jl_cgval_t newv = jl_cgval_t(slotv, NULL, false, typ, new_tindex);\n                    newv.tbaa = tbaa_stack;\n                    return newv;\n                }\n            }\n            else if (jl_subtype(v.typ, typ)) {\n                makeboxed = true;\n            }\n            else {\n                // unreachable\n                CreateTrap(ctx.builder);\n                return jl_cgval_t();\n            }\n        }\n        else if (!v.isboxed) {\n            makeboxed = true;\n        }\n        if (makeboxed) {\n            // convert to a simple isboxed value\n            return jl_cgval_t(boxed(ctx, v), NULL, true, typ, NULL);\n        }\n    }\n    return jl_cgval_t(v, typ, new_tindex);\n}\n\n// Snooping on which functions are being compiled, and how long it takes\nstatic JL_STREAM *dump_compiles_stream = NULL;\nstatic bool nested_compile = false;\nstatic uint64_t last_time = 0;\nextern \"C\" JL_DLLEXPORT\nvoid jl_dump_compiles(void *s)\n{\n    dump_compiles_stream = (JL_STREAM*)s;\n}\n\n// --- entry point ---\n//static int n_emit=0;\nstatic std::unique_ptr<Module> emit_function(\n        jl_method_instance_t *lam,\n        jl_code_info_t *src,\n        size_t world,\n        jl_llvm_functions_t *declarations,\n        const jl_cgparams_t *params);\nvoid jl_add_linfo_in_flight(StringRef name, jl_method_instance_t *linfo, const DataLayout &DL);\n\nconst char *name_from_method_instance(jl_method_instance_t *li)\n{\n    return jl_is_method(li->def.method) ? jl_symbol_name(li->def.method->name) : \"top-level scope\";\n}\n\n// this generates llvm code for the lambda info\n// and adds the result to the jitlayers\n// (and the shadow module), but doesn't yet compile\n// or generate object code for it\nextern \"C\"\njl_llvm_functions_t jl_compile_linfo(jl_method_instance_t **pli, jl_code_info_t *src, size_t world, const jl_cgparams_t *params)\n{\n    // N.B.: `src` may have not been rooted by the caller.\n    JL_TIMING(CODEGEN);\n    jl_method_instance_t *li = *pli;\n    assert(jl_is_method_instance(li));\n    jl_llvm_functions_t decls = {};\n\n    if (params != &jl_default_cgparams /* fast path */ &&\n        !compare_cgparams(params, &jl_default_cgparams) && params->cached)\n        jl_error(\"functions compiled with custom codegen params mustn't be cached\");\n\n    // Fast path for the already-compiled case\n    if (jl_is_method(li->def.method)) {\n        decls = li->functionObjectsDecls;\n        bool already_compiled = params->cached && decls.functionObject != NULL;\n        if (!src) {\n            if ((already_compiled || li->invoke == jl_fptr_const_return) &&\n                    (li->min_world <= world && li->max_world >= world)) {\n                return decls;\n            }\n        } else if (already_compiled) {\n            return decls;\n        }\n    }\n\n    JL_GC_PUSH1(&src);\n    JL_LOCK(&codegen_lock);\n    decls = li->functionObjectsDecls;\n\n    // Codegen lock held in this block\n    {\n        // Step 1: Re-check if this was already compiled (it may have been while\n        // we waited at the lock).\n        if (!jl_is_method(li->def.method)) {\n            src = (jl_code_info_t*)li->inferred;\n            if (decls.functionObject != NULL || !src || !jl_is_code_info(src) || li->invoke == jl_fptr_const_return) {\n                goto locked_out;\n            }\n        }\n        else if (!src) {\n            // If the caller didn't provide the source,\n            // try to infer it for ourself, but first, re-check if it's already compiled.\n            assert(li->min_world <= world && li->max_world >= world);\n            if ((params->cached && decls.functionObject != NULL) || li->invoke == jl_fptr_const_return)\n                goto locked_out;\n\n            // see if it is inferred\n            src = (jl_code_info_t*)li->inferred;\n            if (src) {\n                if ((jl_value_t*)src != jl_nothing)\n                    src = jl_uncompress_ast(li->def.method, (jl_array_t*)src);\n                if (!jl_is_code_info(src)) {\n                    src = jl_type_infer(pli, world, 0);\n                    li = *pli;\n                }\n                if (!src || li->invoke == jl_fptr_const_return)\n                    goto locked_out;\n            }\n            else {\n                // declare a failure to compile\n                goto locked_out;\n            }\n        }\n        else if (params->cached && decls.functionObject != NULL) {\n            // similar to above, but never returns a NULL\n            // decl (unless compile fails), even if invoke == jl_fptr_const_return\n            goto locked_out;\n        }\n        else {\n            if ((jl_value_t*)src != jl_nothing)\n                src = jl_uncompress_ast(li->def.method, (jl_array_t*)src);\n        }\n        assert(jl_is_code_info(src));\n\n        // Step 2: setup global state\n        bool last_n_c = nested_compile;\n        if (!nested_compile && dump_compiles_stream != NULL)\n            last_time = jl_hrtime();\n        nested_compile = true;\n\n        // Step 3. actually do the work of emitting the function\n        std::unique_ptr<Module> m;\n        JL_TRY {\n            jl_llvm_functions_t *pdecls;\n            if (!params->cached)\n                pdecls = &decls;\n            else if (li->min_world <= world && li->max_world >= world)\n                pdecls = &li->functionObjectsDecls;\n            else if (!jl_is_method(li->def.method)) // toplevel thunk\n                pdecls = &li->functionObjectsDecls;\n            else\n                pdecls = &decls;\n            m = emit_function(li, src, world, pdecls, params);\n            if (params->cached && world)\n                decls = li->functionObjectsDecls;\n            //n_emit++;\n        }\n        JL_CATCH {\n            // something failed! this is very bad, since other WIP may be pointing to this function\n            // but there's not much we can do now. try to clear much of the WIP anyways.\n            li->functionObjectsDecls.functionObject = NULL;\n            li->functionObjectsDecls.specFunctionObject = NULL;\n            nested_compile = last_n_c;\n            JL_UNLOCK(&codegen_lock); // Might GC\n            const char *mname = name_from_method_instance(li);\n            jl_rethrow_with_add(\"error compiling %s\", mname);\n        }\n        const char *f = decls.functionObject;\n        const char *specf = decls.specFunctionObject;\n\n        if (JL_HOOK_TEST(params, module_activation)) {\n            JL_HOOK_CALL(params, module_activation, 1, jl_box_voidpointer(wrap(m.release())));\n        } else {\n            // Step 4. Prepare debug info to receive this function\n            // record that this function name came from this linfo,\n            // so we can build a reverse mapping for debug-info.\n            bool toplevel = !jl_is_method(li->def.method);\n            if (!toplevel) {\n                const DataLayout &DL = m->getDataLayout();\n                // but don't remember toplevel thunks because\n                // they may not be rooted in the gc for the life of the program,\n                // and the runtime doesn't notify us when the code becomes unreachable :(\n                if (specf)\n                    jl_add_linfo_in_flight(specf, li, DL);\n                if (strcmp(f, \"jl_fptr_args\") && strcmp(f, \"jl_fptr_sparam\"))\n                    jl_add_linfo_in_flight(f, li, DL);\n            }\n\n            // Step 5. Add the result to the execution engine now\n            jl_finalize_module(m.release(), !toplevel);\n        }\n\n        if (// don't alter `inferred` when the code is not directly being used\n            world &&\n            // don't change inferred state\n            li->inferred) {\n            if (// keep code when keeping everything\n                !(JL_DELETE_NON_INLINEABLE) ||\n                // keep code when debugging level >= 2\n                jl_options.debug_level > 1) {\n                // update the stored code\n                if (li->inferred != (jl_value_t*)src) {\n                    if (jl_is_method(li->def.method))\n                        src = (jl_code_info_t*)jl_compress_ast(li->def.method, src);\n                    li->inferred = (jl_value_t*)src;\n                    jl_gc_wb(li, src);\n                }\n            }\n            else if (// don't delete toplevel code\n                     jl_is_method(li->def.method) &&\n                     // and there is something to delete (test this before calling jl_ast_flag_inlineable)\n                     li->inferred != jl_nothing &&\n                     // don't delete inlineable code, unless it is constant\n                     (li->invoke == jl_fptr_const_return || !jl_ast_flag_inlineable((jl_array_t*)li->inferred)) &&\n                     // don't delete code when generating a precompile file\n                     !imaging_mode) {\n                // if not inlineable, code won't be needed again\n                li->inferred = jl_nothing;\n            }\n        }\n\n        // Step 6: Done compiling: Restore global state\n        nested_compile = last_n_c;\n    }\n\n    JL_UNLOCK(&codegen_lock); // Might GC\n\n    // If logging of the compilation stream is enabled then dump the function to the stream\n    // ... unless li->def isn't defined here meaning the function is a toplevel thunk and\n    // would have its CodeInfo printed in the stream, which might contain double-quotes that\n    // would not be properly escaped given the double-quotes added to the stream below.\n    if (dump_compiles_stream != NULL && jl_is_method(li->def.method)) {\n        uint64_t this_time = jl_hrtime();\n        jl_printf(dump_compiles_stream, \"%\" PRIu64 \"\\t\\\"\", this_time - last_time);\n        jl_static_show(dump_compiles_stream, li->specTypes);\n        jl_printf(dump_compiles_stream, \"\\\"\\n\");\n        last_time = this_time;\n    }\n    JL_GC_POP();\n    return decls;\n\nlocked_out:\n    JL_UNLOCK(&codegen_lock);\n    JL_GC_POP();\n    return decls;\n}\n\n#define getModuleFlag(m,str) m->getModuleFlag(str)\n\nstatic void jl_setup_module(Module *m, const jl_cgparams_t *params = &jl_default_cgparams)\n{\n    if (JL_HOOK_TEST(params, module_setup)) {\n        JL_HOOK_CALL(params, module_setup, 1, jl_box_voidpointer(wrap(m)));\n        return;\n    }\n\n    // Some linkers (*cough* OS X) don't understand DWARF v4, so we use v2 in\n    // imaging mode. The structure of v4 is slightly nicer for debugging JIT\n    // code.\n    if (!getModuleFlag(m,\"Dwarf Version\")) {\n        int dwarf_version = 4;\n#ifdef _OS_DARWIN_\n        if (imaging_mode)\n            dwarf_version = 2;\n#endif\n        m->addModuleFlag(llvm::Module::Warning, \"Dwarf Version\", dwarf_version);\n    }\n    if (!getModuleFlag(m,\"Debug Info Version\"))\n        m->addModuleFlag(llvm::Module::Error, \"Debug Info Version\",\n            llvm::DEBUG_METADATA_VERSION);\n#if JL_LLVM_VERSION >= 40000\n    m->setDataLayout(jl_data_layout);\n#else\n    m->setDataLayout(jl_ExecutionEngine->getDataLayout());\n#endif\n    m->setTargetTriple(jl_TargetMachine->getTargetTriple().str());\n\n}\n\n// this ensures that llvmf has been emitted to the execution engine,\n// returning the function pointer to it\nextern void jl_callback_triggered_linfos(void);\nstatic uint64_t getAddressForFunction(StringRef fname)\n{\n    JL_TIMING(LLVM_EMIT);\n    if (fname == \"jl_fptr_args\")\n        return (uintptr_t)&jl_fptr_args;\n    else if (fname == \"jl_fptr_sparam\")\n        return (uintptr_t)&jl_fptr_sparam;\n#ifdef JL_DEBUG_BUILD\n    llvm::raw_fd_ostream out(1, false);\n#endif\n    jl_finalize_function(fname);\n    uint64_t ret = jl_ExecutionEngine->getFunctionAddress(fname);\n    // delay executing trace callbacks until here to make sure there's no\n    // recursive compilation.\n    jl_callback_triggered_linfos();\n    return ret;\n}\n\n// convenience helper exported for usage from gdb\nextern \"C\" JL_DLLEXPORT\nuint64_t jl_get_llvm_fptr(void *function)\n{\n    Function *F = (Function*)function;\n    uint64_t addr = getAddressForFunction(F->getName());\n    if (!addr) {\n#if JL_LLVM_VERSION >= 50000\n        if (auto exp_addr = jl_ExecutionEngine->findUnmangledSymbol(F->getName()).getAddress()) {\n            addr = exp_addr.get();\n        }\n#else\n        addr = jl_ExecutionEngine->findUnmangledSymbol(F->getName()).getAddress();\n#endif\n    }\n    return addr;\n}\n\nstatic jl_method_instance_t *jl_get_unspecialized(jl_method_instance_t *method)\n{\n    // one unspecialized version of a function can be shared among all cached specializations\n    jl_method_t *def = method->def.method;\n    if (def->source == NULL) {\n        return method;\n    }\n    if (def->unspecialized == NULL) {\n        JL_LOCK(&def->writelock);\n        if (def->unspecialized == NULL) {\n            def->unspecialized = jl_get_specialized(def, def->sig, jl_emptysvec);\n            jl_gc_wb(def, def->unspecialized);\n        }\n        JL_UNLOCK(&def->writelock);\n    }\n    return def->unspecialized;\n}\n\n// this compiles li and emits fptr\nextern \"C\"\njl_callptr_t jl_generate_fptr(jl_method_instance_t **pli, jl_llvm_functions_t decls, size_t world)\n{\n    jl_method_instance_t *li = *pli;\n    jl_callptr_t fptr;\n    fptr = li->invoke;\n    if (fptr != jl_fptr_trampoline)\n        return fptr;\n\n    JL_LOCK(&codegen_lock);\n    fptr = li->invoke;\n    if (fptr != jl_fptr_trampoline) {\n        JL_UNLOCK(&codegen_lock);\n        return fptr;\n    }\n    jl_method_instance_t *unspec = NULL;\n    if (jl_is_method(li->def.method)) {\n        if (li->def.method->unspecialized) {\n            unspec = li->def.method->unspecialized;\n        }\n        const char *F = decls.functionObject;\n        const char *specF = decls.specFunctionObject;\n        if (!F || !jl_can_finalize_function(F) || (specF && !jl_can_finalize_function(specF))) {\n            // can't compile F in the JIT right now,\n            // so instead compile an unspecialized version\n            // and return its fptr instead\n            if (!unspec)\n                unspec = jl_get_unspecialized(li); // get-or-create the unspecialized version to cache the result\n            jl_code_info_t *src = (jl_code_info_t*)unspec->def.method->source;\n            if (src == NULL) {\n                assert(unspec->def.method->generator);\n                src = jl_code_for_staged(unspec);\n            }\n            fptr = unspec->invoke;\n            if (fptr != jl_fptr_trampoline) {\n                li->specptr = unspec->specptr;\n                li->inferred_const = unspec->inferred_const;\n                if (li->inferred_const)\n                    jl_gc_wb(li, li->inferred_const);\n                li->invoke = fptr;\n                JL_UNLOCK(&codegen_lock);\n                return fptr;\n            }\n            if (unspec == li) {\n                // discard decls so that this generated function will get compiled\n                // and cached permanently without optimizations\n                unspec->functionObjectsDecls.functionObject = NULL;\n                unspec->functionObjectsDecls.specFunctionObject = NULL;\n            }\n            assert(src);\n            decls = jl_compile_linfo(&unspec, src, unspec->min_world, &jl_default_cgparams); // this does not change unspec\n            li = unspec;\n        }\n    }\n\n    const char *F = decls.functionObject;\n    const char *specF = decls.specFunctionObject;\n    assert(F && jl_can_finalize_function(F));\n    assert(specF && jl_can_finalize_function(specF));\n    if (!strcmp(F, \"jl_fptr_args\"))\n        fptr = &jl_fptr_args;\n    else if (!strcmp(F, \"jl_fptr_sparam\"))\n        fptr = &jl_fptr_sparam;\n    else\n        fptr = (jl_callptr_t)(uintptr_t)getAddressForFunction(F);\n    assert(fptr != NULL);\n    void *specptr = (void*)(uintptr_t)getAddressForFunction(specF);\n    assert(specptr != NULL);\n    // the fptr should be cached somewhere also\n    if (li->invoke == jl_fptr_trampoline) {\n        // once set, don't change invoke-ptr, as that leads to race conditions\n        // with the (not) simultaneous updates to invoke and specptr\n        li->specptr.fptr = specptr;\n        li->invoke = fptr;\n    }\n    if (li != *pli) {\n        assert(unspec);\n        li = *pli;\n        li->specptr = unspec->specptr;\n        li->inferred_const = unspec->inferred_const;\n        if (li->inferred_const)\n            jl_gc_wb(li, li->inferred_const);\n        li->invoke = fptr;\n    }\n    JL_UNLOCK(&codegen_lock); // Might GC\n    return fptr;\n}\n\nstatic Function *jl_cfunction_object(jl_value_t *f, jl_value_t *declrt, jl_tupletype_t *argt);\n\n// get the address of a C-callable entry point for a function\nextern \"C\" JL_DLLEXPORT\nvoid *jl_function_ptr(jl_function_t *f, jl_value_t *rt, jl_value_t *argt)\n{\n    JL_LOCK(&codegen_lock);\n    Function *llvmf = jl_cfunction_object(f, rt, (jl_tupletype_t*)argt);\n    void *ptr = (void*)getAddressForFunction(llvmf->getName());\n    JL_UNLOCK(&codegen_lock);\n    return ptr;\n}\n\n\n// convenience function for debugging from gdb (pre-OrcJIT)\n// it generally helps to have define KEEP_BODIES if you plan on using this\nextern \"C\" JL_DLLEXPORT\nvoid *jl_function_ptr_by_llvm_name(char *name) {\n#ifdef JL_MSAN_ENABLED\n    __msan_unpoison_string(name);\n#endif\n    return (void*)jl_ExecutionEngine->FindFunctionNamed(name); // returns an llvm::Function*\n}\n\n// export a C-callable entry point for a function (dllexport'ed dlsym), with a given name\nextern \"C\" JL_DLLEXPORT\nvoid jl_extern_c(jl_function_t *f, jl_value_t *rt, jl_value_t *argt, char *name)\n{\n    JL_LOCK(&codegen_lock);\n    Function *llvmf = jl_cfunction_object(f, rt, (jl_tupletype_t*)argt);\n    // force eager emission of the function (llvm 3.3 gets confused otherwise and tries to do recursive compilation)\n    uint64_t Addr = getAddressForFunction(llvmf->getName());\n\n    if (imaging_mode)\n        llvmf = cast<Function>(shadow_output->getNamedValue(llvmf->getName()));\n\n    // make the alias to the shadow_module\n    GlobalAlias *GA =\n        GlobalAlias::create(llvmf->getType()->getElementType(), llvmf->getType()->getAddressSpace(),\n                            GlobalValue::ExternalLinkage, name, llvmf, shadow_output);\n\n    // make sure the alias name is valid for the current session\n    jl_ExecutionEngine->addGlobalMapping(GA, (void*)(uintptr_t)Addr);\n    JL_UNLOCK(&codegen_lock);\n}\n\n// --- native code info, and dump function to IR and ASM ---\n// Get pointer to llvm::Function instance, compiling if necessary\n// for use in reflection from Julia.\n// this is paired with jl_dump_function_ir and jl_dump_function_asm in particular ways:\n// misuse will leak memory or cause read-after-free\nextern \"C\" JL_DLLEXPORT\nvoid *jl_get_llvmf_defn(jl_method_instance_t *linfo, size_t world, bool getwrapper, bool optimize, const jl_cgparams_t params)\n{\n    if (jl_is_method(linfo->def.method) && linfo->def.method->source == NULL &&\n        linfo->def.method->generator == NULL) {\n        // not a generic function\n        return NULL;\n    }\n\n    jl_code_info_t *src = (jl_code_info_t*)linfo->inferred;\n    JL_GC_PUSH1(&src);\n    if (!src || (jl_value_t*)src == jl_nothing) {\n        src = jl_type_infer(&linfo, world, 0);\n        if (!src && jl_is_method(linfo->def.method))\n            src = linfo->def.method->generator ? jl_code_for_staged(linfo) : (jl_code_info_t*)linfo->def.method->source;\n    }\n    if ((jl_value_t*)src == jl_nothing)\n        src = NULL;\n    if (src && !jl_is_code_info(src) && jl_is_method(linfo->def.method))\n        src = jl_uncompress_ast(linfo->def.method, (jl_array_t*)src);\n    if (src && !jl_is_code_info(src))\n        src = NULL;\n    if (!src)\n        jl_error(\"source not found for function\");\n\n    // Backup the info for the nested compile\n    JL_LOCK(&codegen_lock);\n\n    // emit this function into a new module\n    jl_llvm_functions_t declarations;\n    std::unique_ptr<Module> m;\n    JL_TRY {\n        m = emit_function(linfo, src, world, &declarations, &params);\n    }\n    JL_CATCH {\n        // something failed!\n        m.reset();\n        JL_UNLOCK(&codegen_lock); // Might GC\n        const char *mname = name_from_method_instance(linfo);\n        jl_rethrow_with_add(\"error compiling %s\", mname);\n    }\n\n    if (optimize)\n        jl_globalPM->run(*m.get());\n\n    // swap declarations for definitions and destroy declarations\n    const char *fname = declarations.functionObject;\n    const char *specfname = declarations.specFunctionObject;\n    Function *f = NULL;\n    Function *specf = NULL;\n    if (specfname) {\n        specf = cast<Function>(m->getNamedValue(specfname));\n        free(const_cast<char*>(specfname));\n    }\n    f = cast_or_null<Function>(m->getNamedValue(fname));\n    if (f) // don't try to free sentinel names like \"jl_fptr_args\" and \"jl_fptr_sparam\"\n        free(const_cast<char*>(fname));\n    assert(specf || f);\n    // clone the name from the runtime linfo, if it exists\n    // to give the user a (false) sense of stability\n    specfname = linfo->functionObjectsDecls.specFunctionObject;\n    if (specfname && specf) {\n        specf->setName(specfname);\n    }\n    fname = linfo->functionObjectsDecls.functionObject;\n    if (fname && f && strcmp(fname, \"jl_fptr_args\") && strcmp(fname, \"jl_fptr_sparam\")) {\n        f->setName(fname);\n    }\n    m.release(); // the return object `llvmf` will be the owning pointer\n    JL_UNLOCK(&codegen_lock); // Might GC\n    JL_GC_POP();\n    if ((getwrapper && f) || !specf)\n        return f;\n    else\n        return specf;\n}\n\n\nextern \"C\" JL_DLLEXPORT\nvoid *jl_get_llvmf_decl(jl_method_instance_t *linfo, size_t world, bool getwrapper, const jl_cgparams_t params)\n{\n    if (jl_is_method(linfo->def.method) && linfo->def.method->source == NULL &&\n        linfo->def.method->generator == NULL) {\n        // not a generic function\n        return NULL;\n    }\n\n    // compile this normally\n    jl_code_info_t *src = NULL;\n    if (linfo->inferred == NULL)\n        src = jl_type_infer(&linfo, world, 0);\n    jl_llvm_functions_t decls = jl_compile_linfo(&linfo, src, world, &jl_default_cgparams);\n\n    if (decls.functionObject == NULL && linfo->invoke == jl_fptr_const_return && jl_is_method(linfo->def.method)) {\n        // normally we don't generate native code for these functions, so need an exception here\n        // This leaks a bit of memory to cache native code that we'll never actually need\n        JL_LOCK(&codegen_lock);\n        decls = linfo->functionObjectsDecls;\n        if (decls.functionObject == NULL) {\n            src = jl_type_infer(&linfo, world, 0);\n            if (!src) {\n                src = linfo->def.method->generator ? jl_code_for_staged(linfo) : (jl_code_info_t*)linfo->def.method->source;\n            }\n            decls = jl_compile_linfo(&linfo, src, world, &params);\n            linfo->functionObjectsDecls = decls;\n        }\n        JL_UNLOCK(&codegen_lock);\n    }\n\n    if (!getwrapper && decls.specFunctionObject) {\n        if (!strcmp(decls.functionObject, \"jl_fptr_args\")) {\n            auto f = Function::Create(jl_func_sig, GlobalVariable::ExternalLinkage, decls.specFunctionObject);\n            add_return_attr(f, Attribute::NonNull);\n            f->addFnAttr(Thunk);\n            return f;\n        }\n        else if (!strcmp(decls.functionObject, \"jl_fptr_sparam\")) {\n            auto f = Function::Create(jl_func_sig_sparams, GlobalVariable::ExternalLinkage, decls.specFunctionObject);\n            add_return_attr(f, Attribute::NonNull);\n            f->addFnAttr(Thunk);\n            return f;\n        }\n        else {\n            jl_returninfo_t returninfo = get_specsig_function(NULL, decls.specFunctionObject, linfo->specTypes, linfo->rettype);\n            return returninfo.decl;\n        }\n    }\n    auto f = Function::Create(jl_func_sig, GlobalVariable::ExternalLinkage, decls.functionObject);\n    add_return_attr(f, Attribute::NonNull);\n    f->addFnAttr(Thunk);\n    return f;\n}\n\n// get a native disassembly for f (an LLVM function)\n// warning: this takes ownership of, and destroys, f\nextern \"C\" JL_DLLEXPORT\nconst jl_value_t *jl_dump_function_asm(void *f, int raw_mc, const char* asm_variant)\n{\n    Function *llvmf = dyn_cast_or_null<Function>((Function*)f);\n    if (!llvmf)\n        jl_error(\"jl_dump_function_asm: Expected Function*\");\n    uint64_t fptr = getAddressForFunction(llvmf->getName());\n    // Look in the system image as well\n    if (fptr == 0)\n        fptr = (uintptr_t)jl_ExecutionEngine->getPointerToGlobalIfAvailable(llvmf);\n    delete llvmf;\n    return jl_dump_fptr_asm(fptr, raw_mc, asm_variant);\n}\n\n// Logging for code coverage and memory allocation\n\nconst int logdata_blocksize = 32; // target getting nearby lines in the same general cache area and reducing calls to malloc by chunking\ntypedef uint64_t logdata_block[logdata_blocksize];\ntypedef StringMap< std::vector<logdata_block*> > logdata_t;\n\nstatic void visitLine(jl_codectx_t &ctx, std::vector<logdata_block*> &vec, int line, Value *addend, const char* name)\n{\n    unsigned block = line / logdata_blocksize;\n    line = line % logdata_blocksize;\n    if (vec.size() <= block)\n        vec.resize(block + 1);\n    if (vec[block] == NULL) {\n        vec[block] = (logdata_block*)calloc(1, sizeof(logdata_block));\n    }\n    logdata_block &data = *vec[block];\n    if (data[line] == 0)\n        data[line] = 1;\n    Value *v = ConstantExpr::getIntToPtr(\n        ConstantInt::get(T_size, (uintptr_t)&data[line]),\n        T_pint64);\n    ctx.builder.CreateStore(ctx.builder.CreateAdd(ctx.builder.CreateLoad(v, true, name),\n                                          addend),\n                        v, true); // not atomic, so this might be an underestimate,\n                                  // but it's faster this way\n}\n\n// Code coverage\n\nstatic logdata_t coverageData;\n\nstatic void coverageVisitLine(jl_codectx_t &ctx, StringRef filename, int line)\n{\n    assert(!imaging_mode);\n    if (filename == \"\" || filename == \"none\" || filename == \"no file\" || filename == \"<missing>\" || line < 0)\n        return;\n    visitLine(ctx, coverageData[filename], line, ConstantInt::get(T_int64, 1), \"lcnt\");\n}\n\n// Memory allocation log (malloc_log)\n\nstatic logdata_t mallocData;\n\nstatic void mallocVisitLine(jl_codectx_t &ctx, StringRef filename, int line)\n{\n    assert(!imaging_mode);\n    if (filename == \"\" || filename == \"none\" || filename == \"no file\" || filename == \"<missing>\" || line < 0) {\n        jl_gc_sync_total_bytes();\n        return;\n    }\n    Value *addend = ctx.builder.CreateCall(prepare_call(diff_gc_total_bytes_func), {});\n    visitLine(ctx, mallocData[filename], line, addend, \"bytecnt\");\n}\n\n// Resets the malloc counts. Needed to avoid including memory usage\n// from JITting.\nextern \"C\" JL_DLLEXPORT void jl_clear_malloc_data(void)\n{\n    logdata_t::iterator it = mallocData.begin();\n    for (; it != mallocData.end(); it++) {\n        std::vector<logdata_block*> &bytes = (*it).second;\n        std::vector<logdata_block*>::iterator itb;\n        for (itb = bytes.begin(); itb != bytes.end(); itb++) {\n            if (*itb) {\n                logdata_block &data = **itb;\n                for (int i = 0; i < logdata_blocksize; i++) {\n                    if (data[i] > 0)\n                        data[i] = 1;\n                }\n            }\n        }\n    }\n    jl_gc_sync_total_bytes();\n}\n\nextern \"C\" int isabspath(const char *in);\n\nstatic void write_log_data(logdata_t &logData, const char *extension)\n{\n    std::string base = std::string(jl_options.julia_bindir);\n    base = base + \"/../share/julia/base/\";\n    logdata_t::iterator it = logData.begin();\n    for (; it != logData.end(); it++) {\n        std::string filename = it->first();\n        std::vector<logdata_block*> &values = it->second;\n        if (!values.empty()) {\n            if (!isabspath(filename.c_str()))\n                filename = base + filename;\n            std::ifstream inf(filename.c_str());\n            if (inf.is_open()) {\n                std::string outfile = filename + extension;\n                std::ofstream outf(outfile.c_str(), std::ofstream::trunc | std::ofstream::out);\n                char line[1024];\n                int l = 1;\n                unsigned block = 0;\n                while (!inf.eof()) {\n                    inf.getline(line, sizeof(line));\n                    if (inf.fail() && !inf.bad()) {\n                        // Read through lines longer than sizeof(line)\n                        inf.clear();\n                        inf.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n                    }\n                    logdata_block *data = NULL;\n                    if (block < values.size()) {\n                        data = values[block];\n                    }\n                    uint64_t value = data ? (*data)[l] : 0;\n                    if (++l >= logdata_blocksize) {\n                        l = 0;\n                        block++;\n                    }\n                    outf.width(9);\n                    if (value == 0)\n                        outf << '-';\n                    else\n                        outf << (value - 1);\n                    outf.width(0);\n                    outf << \" \" << line << std::endl;\n                }\n                outf.close();\n                inf.close();\n            }\n        }\n    }\n}\n\nextern \"C\" int jl_getpid();\nextern \"C\" void jl_write_coverage_data(void)\n{\n    std::ostringstream stm;\n    stm << jl_getpid();\n    std::string outf = \".\" + stm.str() + \".cov\";\n    write_log_data(coverageData, outf.c_str());\n}\n\nextern \"C\" void jl_write_malloc_log(void)\n{\n    write_log_data(mallocData, \".mem\");\n}\n\n// --- constant determination ---\n\nstatic void show_source_loc(jl_codectx_t &ctx, JL_STREAM *out)\n{\n    jl_printf(out, \"in %s at %s\", ctx.name, ctx.file.str().c_str());\n}\n\nextern \"C\" void jl_binding_deprecation_warning(jl_module_t *m, jl_binding_t *b);\n\nstatic void cg_bdw(jl_codectx_t &ctx, jl_binding_t *b)\n{\n    jl_binding_deprecation_warning(ctx.module, b);\n    if (b->deprecated == 1 && jl_options.depwarn) {\n        show_source_loc(ctx, JL_STDERR);\n        jl_printf(JL_STDERR, \"\\n\");\n    }\n}\n\nstatic jl_value_t *static_apply_type(jl_codectx_t &ctx, const jl_cgval_t *args, size_t nargs)\n{\n    jl_value_t **v = (jl_value_t**)alloca(sizeof(jl_value_t*) * nargs);\n    for (size_t i = 0; i < nargs; i++) {\n        if (!args[i].constant)\n            return NULL;\n        v[i] = args[i].constant;\n    }\n    assert(v[0] == jl_builtin_apply_type);\n    size_t last_age = jl_get_ptls_states()->world_age;\n    // call apply_type, but ignore errors. we know that will work in world 1.\n    jl_get_ptls_states()->world_age = 1;\n    jl_value_t *result = jl_apply_with_saved_exception_state(v, nargs, 1);\n    jl_get_ptls_states()->world_age = last_age;\n    return result;\n}\n\n// try to statically evaluate, NULL if not possible\nstatic jl_value_t *static_eval(jl_codectx_t &ctx, jl_value_t *ex, int sparams=true, int allow_alloc=true)\n{\n    if (!JL_FEAT_TEST(ctx, static_alloc)) allow_alloc = 0;\n    if (jl_is_symbol(ex)) {\n        jl_sym_t *sym = (jl_sym_t*)ex;\n        if (jl_is_const(ctx.module, sym))\n            return jl_get_global(ctx.module, sym);\n        return NULL;\n    }\n    if (jl_is_slot(ex))\n        return NULL;\n    if (jl_is_ssavalue(ex)) {\n        ssize_t idx = ((jl_ssavalue_t*)ex)->id - 1;\n        assert(idx >= 0);\n        if (ctx.ssavalue_assigned.at(idx)) {\n            return ctx.SAvalues.at(idx).constant;\n        }\n        return NULL;\n    }\n    if (jl_is_quotenode(ex))\n        return jl_fieldref(ex, 0);\n    if (jl_is_method_instance(ex))\n        return NULL;\n    jl_module_t *m = NULL;\n    jl_sym_t *s = NULL;\n    if (jl_is_globalref(ex)) {\n        s = jl_globalref_name(ex);\n        jl_binding_t *b = jl_get_binding(jl_globalref_mod(ex), s);\n        if (b && b->constp) {\n            if (b->deprecated)\n                cg_bdw(ctx, b);\n            return b->value;\n        }\n        return NULL;\n    }\n    if (jl_is_expr(ex)) {\n        jl_expr_t *e = (jl_expr_t*)ex;\n        if (e->head == call_sym) {\n            jl_value_t *f = static_eval(ctx, jl_exprarg(e, 0), sparams, allow_alloc);\n            if (f) {\n                if (jl_array_dim0(e->args) == 3 && f == jl_builtin_getfield) {\n                    m = (jl_module_t*)static_eval(ctx, jl_exprarg(e, 1), sparams, allow_alloc);\n                    // Check the tag before evaluating `s` so that a value of random\n                    // type won't be corrupted.\n                    if (!m || !jl_is_module(m))\n                        return NULL;\n                    // Assumes that the module is rooted somewhere.\n                    s = (jl_sym_t*)static_eval(ctx, jl_exprarg(e, 2), sparams, allow_alloc);\n                    if (s && jl_is_symbol(s)) {\n                        jl_binding_t *b = jl_get_binding(m, s);\n                        if (b && b->constp) {\n                            if (b->deprecated)\n                                cg_bdw(ctx, b);\n                            return b->value;\n                        }\n                    }\n                }\n                else if (f==jl_builtin_tuple || f==jl_builtin_apply_type) {\n                    size_t i;\n                    size_t n = jl_array_dim0(e->args)-1;\n                    if (n==0 && f==jl_builtin_tuple) return (jl_value_t*)jl_emptytuple;\n                    if (!allow_alloc)\n                        return NULL;\n                    jl_value_t **v;\n                    JL_GC_PUSHARGS(v, n+1);\n                    v[0] = f;\n                    for (i = 0; i < n; i++) {\n                        v[i+1] = static_eval(ctx, jl_exprarg(e, i+1), sparams, allow_alloc);\n                        if (v[i+1] == NULL) {\n                            JL_GC_POP();\n                            return NULL;\n                        }\n                    }\n                    size_t last_age = jl_get_ptls_states()->world_age;\n                    // here we know we're calling specific builtin functions that work in world 1.\n                    jl_get_ptls_states()->world_age = 1;\n                    jl_value_t *result = jl_apply_with_saved_exception_state(v, n+1, 1);\n                    jl_get_ptls_states()->world_age = last_age;\n                    JL_GC_POP();\n                    return result;\n                }\n            }\n        }\n        else if (e->head == static_parameter_sym) {\n            size_t idx = jl_unbox_long(jl_exprarg(e, 0));\n            if (idx <= jl_svec_len(ctx.linfo->sparam_vals)) {\n                jl_value_t *e = jl_svecref(ctx.linfo->sparam_vals, idx - 1);\n                if (jl_is_typevar(e))\n                    return NULL;\n                return e;\n            }\n        }\n        return NULL;\n    }\n    return ex;\n}\n\nstatic bool slot_eq(jl_value_t *e, int sl)\n{\n    return jl_is_slot(e) && jl_slot_number(e)-1 == sl;\n}\n\n// --- code gen for intrinsic functions ---\n\n#include \"intrinsics.cpp\"\n\n// --- find volatile variables ---\n\n// assigned in a try block and used outside that try block\n\nstatic bool local_var_occurs(jl_value_t *e, int sl)\n{\n    if (slot_eq(e, sl)) {\n        return true;\n    }\n    else if (jl_is_expr(e)) {\n        jl_expr_t *ex = (jl_expr_t*)e;\n        size_t alength = jl_array_dim0(ex->args);\n        for(int i=0; i < (int)alength; i++) {\n            if (local_var_occurs(jl_exprarg(ex,i),sl))\n                return true;\n        }\n    }\n    return false;\n}\n\nstatic std::set<int> assigned_in_try(jl_array_t *stmts, int s, long l)\n{\n    std::set<int> av;\n    for(int i=s; i <= l; i++) {\n        jl_value_t *st = jl_array_ptr_ref(stmts,i);\n        if (jl_is_expr(st)) {\n            if (((jl_expr_t*)st)->head == assign_sym) {\n                jl_value_t *ar = jl_exprarg(st, 0);\n                if (jl_is_slot(ar)) {\n                    av.insert(jl_slot_number(ar)-1);\n                }\n            }\n        }\n    }\n    return av;\n}\n\nstatic void mark_volatile_vars(jl_array_t *stmts, std::vector<jl_varinfo_t> &slots)\n{\n    size_t slength = jl_array_dim0(stmts);\n    for (int i = 0; i < (int)slength; i++) {\n        jl_value_t *st = jl_array_ptr_ref(stmts, i);\n        if (jl_is_expr(st)) {\n            if (((jl_expr_t*)st)->head == enter_sym) {\n                int last = jl_unbox_long(jl_exprarg(st, 0));\n                std::set<int> as = assigned_in_try(stmts, i + 1, last);\n                for (int j = 0; j < (int)slength; j++) {\n                    if (j < i || j > last) {\n                        std::set<int>::iterator it = as.begin();\n                        for (; it != as.end(); it++) {\n                            if (local_var_occurs(jl_array_ptr_ref(stmts, j), *it)) {\n                                jl_varinfo_t &vi = slots[*it];\n                                vi.isVolatile = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n// --- use analysis ---\n\n// a very simple, conservative use analysis\n// to eagerly remove slot assignments that are never read from\nstatic void simple_use_analysis(jl_codectx_t &ctx, jl_value_t *expr)\n{\n    if (jl_is_slot(expr)) {\n        int i = jl_slot_number(expr) - 1;\n        ctx.slots[i].used = true;\n    }\n    else if (jl_is_expr(expr)) {\n        jl_expr_t *e = (jl_expr_t*)expr;\n        if (e->head == method_sym) {\n            simple_use_analysis(ctx, jl_exprarg(e, 0));\n            if (jl_expr_nargs(e) > 1) {\n                simple_use_analysis(ctx, jl_exprarg(e, 1));\n                simple_use_analysis(ctx, jl_exprarg(e, 2));\n            }\n        }\n        else if (e->head == assign_sym) {\n            // don't consider assignment LHS as a variable \"use\"\n            simple_use_analysis(ctx, jl_exprarg(e, 1));\n        }\n        else {\n            size_t i, elen = jl_array_dim0(e->args);\n            for (i = 0; i < elen; i++) {\n                simple_use_analysis(ctx, jl_exprarg(e, i));\n            }\n        }\n    }\n    else if (jl_is_pinode(expr)) {\n        simple_use_analysis(ctx, jl_fieldref_noalloc(expr, 0));\n    }\n    else if (jl_is_upsilonnode(expr)) {\n        jl_value_t *val = jl_fieldref_noalloc(expr, 0);\n        if (val)\n            simple_use_analysis(ctx, val);\n    }\n    else if (jl_is_phicnode(expr)) {\n        jl_array_t *values = (jl_array_t*)jl_fieldref_noalloc(expr, 0);\n        size_t i, elen = jl_array_len(values);\n        for (i = 0; i < elen; i++) {\n            jl_value_t *v = jl_array_ptr_ref(values, i);\n            simple_use_analysis(ctx, v);\n        }\n    }\n    else if (jl_is_phinode(expr)) {\n        jl_array_t *values = (jl_array_t*)jl_fieldref_noalloc(expr, 1);\n        size_t i, elen = jl_array_len(values);\n        for (i = 0; i < elen; i++) {\n            jl_value_t *v = jl_array_ptr_ref(values, i);\n            if (v)\n                simple_use_analysis(ctx, v);\n        }\n    }\n}\n\n// --- gc root utils ---\n\n// ---- Get Element Pointer (GEP) instructions within the GC frame ----\n\nstatic void jl_add_method_root(jl_codectx_t &ctx, jl_value_t *val)\n{\n    if (jl_is_concrete_type(val) || jl_is_bool(val) || jl_is_symbol(val) || val == jl_nothing ||\n            val == (jl_value_t*)jl_any_type || val == (jl_value_t*)jl_bottom_type || val == (jl_value_t*)jl_core_module)\n        return;\n    JL_GC_PUSH1(&val);\n    if (ctx.roots == NULL) {\n        ctx.roots = jl_alloc_vec_any(1);\n        jl_array_ptr_set(ctx.roots, 0, val);\n    }\n    else {\n        size_t rlen = jl_array_dim0(ctx.roots);\n        for (size_t i = 0; i < rlen; i++) {\n            if (jl_array_ptr_ref(ctx.roots,i) == val) {\n                JL_GC_POP();\n                return;\n            }\n        }\n        jl_array_ptr_1d_push(ctx.roots, val);\n    }\n    JL_GC_POP();\n}\n\n// --- generating function calls ---\n\nstatic jl_cgval_t emit_globalref(jl_codectx_t &ctx, jl_module_t *mod, jl_sym_t *name)\n{\n    jl_binding_t *bnd = NULL;\n    Value *bp = global_binding_pointer(ctx, mod, name, &bnd, false);\n    // TODO: refactor. this partially duplicates code in emit_var\n    if (bnd && bnd->value != NULL) {\n        if (bnd->constp) {\n            return mark_julia_const(bnd->value);\n        }\n        return mark_julia_type(ctx, tbaa_decorate(tbaa_binding, ctx.builder.CreateLoad(bp)), true, (jl_value_t*)jl_any_type);\n    }\n    // todo: use type info to avoid undef check\n    return emit_checked_var(ctx, bp, name, false, tbaa_binding);\n}\n\nstatic jl_cgval_t emit_getfield(jl_codectx_t &ctx, const jl_cgval_t &strct, jl_sym_t *name)\n{\n    if (strct.constant && jl_is_module(strct.constant))\n        return emit_globalref(ctx, (jl_module_t*)strct.constant, name);\n\n    jl_datatype_t *sty = (jl_datatype_t*)strct.typ;\n    if (jl_is_type_type((jl_value_t*)sty) && jl_is_concrete_type(jl_tparam0(sty)))\n        sty = (jl_datatype_t*)jl_typeof(jl_tparam0(sty));\n    sty = (jl_datatype_t*)jl_unwrap_unionall((jl_value_t*)sty);\n    if (jl_is_structtype(sty) && sty != jl_module_type && sty->layout) {\n        unsigned idx = jl_field_index(sty, name, 0);\n        if (idx != (unsigned)-1) {\n            return emit_getfield_knownidx(ctx, strct, idx, sty);\n        }\n    }\n    // TODO: attempt better codegen for approximate types, if the types\n    // and offsets of some fields are independent of parameters.\n\n    // TODO: generic getfield func with more efficient calling convention\n    jl_cgval_t myargs_array[2] = {\n        strct,\n        mark_julia_const((jl_value_t*)name)\n    };\n    Value *result = emit_jlcall(ctx, jlgetfield_func, maybe_decay_untracked(V_null), myargs_array, 2);\n    return mark_julia_type(ctx, result, true, jl_any_type);\n}\n\nstatic Value *emit_bits_compare(jl_codectx_t &ctx, const jl_cgval_t &arg1, const jl_cgval_t &arg2);\n\nstatic Value *emit_bitsunion_compare(jl_codectx_t &ctx, const jl_cgval_t &arg1, const jl_cgval_t &arg2)\n{\n    assert(arg1.typ == arg2.typ && arg1.TIndex && arg2.TIndex && jl_is_uniontype(arg1.typ) && \"unimplemented\");\n    Value *tindex = arg1.TIndex;\n    BasicBlock *defaultBB = BasicBlock::Create(jl_LLVMContext, \"unionbits_is_boxed\", ctx.f);\n    SwitchInst *switchInst = ctx.builder.CreateSwitch(tindex, defaultBB);\n    BasicBlock *postBB = BasicBlock::Create(jl_LLVMContext, \"post_unionbits_is\", ctx.f);\n    ctx.builder.SetInsertPoint(postBB);\n    PHINode *phi = ctx.builder.CreatePHI(T_int1, 2);\n    unsigned counter = 0;\n    for_each_uniontype_small(\n        [&](unsigned idx, jl_datatype_t *jt) {\n            BasicBlock *tempBB = BasicBlock::Create(jl_LLVMContext, \"unionbits_is\", ctx.f);\n            ctx.builder.SetInsertPoint(tempBB);\n            switchInst->addCase(ConstantInt::get(T_int8, idx), tempBB);\n            jl_cgval_t sel_arg1(arg1, (jl_value_t*)jt, NULL);\n            jl_cgval_t sel_arg2(arg2, (jl_value_t*)jt, NULL);\n            phi->addIncoming(emit_bits_compare(ctx, sel_arg1, sel_arg2), tempBB);\n            ctx.builder.CreateBr(postBB);\n        },\n        arg1.typ,\n        counter);\n    ctx.builder.SetInsertPoint(defaultBB);\n    Function *trap_func = Intrinsic::getDeclaration(\n        ctx.f->getParent(),\n        Intrinsic::trap);\n    ctx.builder.CreateCall(trap_func);\n    ctx.builder.CreateUnreachable();\n    ctx.builder.SetInsertPoint(postBB);\n    return ctx.builder.CreateAnd(phi, ctx.builder.CreateICmpEQ(arg1.TIndex, arg2.TIndex));\n}\n\nstatic Value *emit_bits_compare(jl_codectx_t &ctx, const jl_cgval_t &arg1, const jl_cgval_t &arg2)\n{\n    bool isboxed;\n    Type *at = julia_type_to_llvm(arg1.typ, &isboxed);\n    assert(jl_is_datatype(arg1.typ) && arg1.typ == arg2.typ && !isboxed);\n\n    if (type_is_ghost(at))\n        return ConstantInt::get(T_int1, 1);\n\n    if (at->isIntegerTy() || at->isPointerTy() || at->isFloatingPointTy()) {\n        Type *at_int = INTT(at);\n        Value *varg1 = emit_unbox(ctx, at_int, arg1, arg1.typ);\n        Value *varg2 = emit_unbox(ctx, at_int, arg2, arg2.typ);\n        return ctx.builder.CreateICmpEQ(varg1, varg2);\n    }\n\n    if (at->isVectorTy()) {\n        jl_svec_t *types = ((jl_datatype_t*)arg1.typ)->types;\n        Value *answer = ConstantInt::get(T_int1, 1);\n        Value *varg1 = emit_unbox(ctx, at, arg1, arg1.typ);\n        Value *varg2 = emit_unbox(ctx, at, arg2, arg2.typ);\n        for (size_t i = 0, l = jl_svec_len(types); i < l; i++) {\n            jl_value_t *fldty = jl_svecref(types, i);\n            Value *subAns, *fld1, *fld2;\n            fld1 = ctx.builder.CreateExtractElement(varg1, ConstantInt::get(T_int32, i)),\n            fld2 = ctx.builder.CreateExtractElement(varg2, ConstantInt::get(T_int32, i)),\n            subAns = emit_bits_compare(ctx,\n                    mark_julia_type(ctx, fld1, false, fldty),\n                    mark_julia_type(ctx, fld2, false, fldty));\n            answer = ctx.builder.CreateAnd(answer, subAns);\n        }\n        return answer;\n    }\n\n    if (at->isAggregateType()) { // Struct or Array\n        assert(arg1.ispointer() && arg2.ispointer());\n        jl_datatype_t *sty = (jl_datatype_t*)arg1.typ;\n        size_t sz = jl_datatype_size(sty);\n        Value *varg1 = maybe_decay_tracked(data_pointer(ctx, arg1));\n        Value *varg2 = maybe_decay_tracked(data_pointer(ctx, arg2));\n        if (sz > 512 && !sty->layout->haspadding) {\n            varg1 = decay_derived(varg1);\n            varg2 = decay_derived(varg2);\n            Value *answer = ctx.builder.CreateCall(prepare_call(memcmp_derived_func), {\n                        maybe_bitcast(ctx, varg1, T_pint8),\n                        maybe_bitcast(ctx, varg2, T_pint8),\n                        ConstantInt::get(T_size, sz)\n                    });\n            return ctx.builder.CreateICmpEQ(answer, ConstantInt::get(T_int32, 0));\n        }\n        else {\n            Type *atp = at->getPointerTo();\n            if (cast<PointerType>(varg1->getType())->getAddressSpace() != cast<PointerType>(varg2->getType())->getAddressSpace()) {\n                varg1 = decay_derived(varg1);\n                varg2 = decay_derived(varg2);\n            }\n            varg1 = maybe_bitcast(ctx, varg1, atp);\n            varg2 = maybe_bitcast(ctx, varg2, atp);\n            jl_svec_t *types = sty->types;\n            Value *answer = ConstantInt::get(T_int1, 1);\n            for (size_t i = 0, l = jl_svec_len(types); i < l; i++) {\n                jl_value_t *fldty = jl_svecref(types, i);\n                if (type_is_ghost(julia_type_to_llvm(fldty)))\n                    continue;\n                unsigned byte_offset = jl_field_offset(sty, i);\n                Value *subAns, *fld1, *fld2;\n                if (isa<StructType>(at)) {\n                    fld1 = emit_struct_gep(ctx, at, varg1, byte_offset);\n                    fld2 = emit_struct_gep(ctx, at, varg2, byte_offset);\n                }\n                else {\n                    fld1 = ctx.builder.CreateConstInBoundsGEP2_32(at, varg1, 0, i);\n                    fld2 = ctx.builder.CreateConstInBoundsGEP2_32(at, varg2, 0, i);\n                }\n                if (jl_is_uniontype(fldty)) {\n                    unsigned tindex_offset = byte_offset + jl_field_size(sty, i) - 1;\n                    Value *ptindex1 = emit_struct_gep(ctx, at, varg1, tindex_offset);\n                    Value *ptindex2 = emit_struct_gep(ctx, at, varg2, tindex_offset);\n                    Value *tindex1 = ctx.builder.CreateNUWAdd(ConstantInt::get(T_int8, 1),\n                            ctx.builder.CreateLoad(T_int8, ptindex1));\n                    Value *tindex2 = ctx.builder.CreateNUWAdd(ConstantInt::get(T_int8, 1),\n                            ctx.builder.CreateLoad(T_int8, ptindex2));\n                    subAns = emit_bitsunion_compare(ctx,\n                            mark_julia_slot(fld1, fldty, tindex1, arg1.tbaa),\n                            mark_julia_slot(fld2, fldty, tindex2, arg2.tbaa));\n                }\n                else {\n                    assert(jl_is_concrete_type(fldty));\n                    subAns = emit_bits_compare(ctx,\n                            mark_julia_slot(fld1, fldty, NULL, arg1.tbaa),\n                            mark_julia_slot(fld2, fldty, NULL, arg2.tbaa));\n                }\n                answer = ctx.builder.CreateAnd(answer, subAns);\n            }\n            return answer;\n        }\n    }\n    assert(0 && \"what is this llvm type?\");\n    abort();\n}\n\n// emit code for is (===).\nstatic Value *emit_f_is(jl_codectx_t &ctx, const jl_cgval_t &arg1, const jl_cgval_t &arg2)\n{\n    jl_value_t *rt1 = arg1.typ;\n    jl_value_t *rt2 = arg2.typ;\n    if (jl_is_concrete_type(rt1) && jl_is_concrete_type(rt2) && !jl_is_kind(rt1) && !jl_is_kind(rt2) && rt1 != rt2) {\n        // disjoint concrete leaf types are never equal (quick test)\n        return ConstantInt::get(T_int1, 0);\n    }\n\n    if (arg1.isghost || arg2.isghost) {\n        // comparing to a singleton object\n        if (arg1.TIndex)\n            return emit_isa(ctx, arg1, rt2, NULL).first; // rt2 is a singleton type\n        if (arg2.TIndex)\n            return emit_isa(ctx, arg2, rt1, NULL).first; // rt1 is a singleton type\n        // rooting these values isn't needed since we won't load this pointer\n        // and we know at least one of them is a unique Singleton\n        // which is already enough to ensure pointer uniqueness for this test\n        // even if the other pointer managed to get garbage collected\n        return ctx.builder.CreateICmpEQ(\n            mark_callee_rooted(boxed(ctx, arg1)),\n            mark_callee_rooted(boxed(ctx, arg2)));\n    }\n\n    if (jl_type_intersection(rt1, rt2) == (jl_value_t*)jl_bottom_type) // types are disjoint (exhaustive test)\n        return ConstantInt::get(T_int1, 0);\n\n    bool justbits1 = jl_justbits(rt1);\n    bool justbits2 = jl_justbits(rt2);\n    if (justbits1 || justbits2) { // whether this type is unique'd by value\n        jl_value_t *typ = justbits1 ? rt1 : rt2;\n        if (rt1 == rt2)\n            return emit_bits_compare(ctx, arg1, arg2);\n        Value *same_type = (typ == rt2) ? emit_isa(ctx, arg1, typ, NULL).first : emit_isa(ctx, arg2, typ, NULL).first;\n        BasicBlock *currBB = ctx.builder.GetInsertBlock();\n        BasicBlock *isaBB = BasicBlock::Create(jl_LLVMContext, \"is\", ctx.f);\n        BasicBlock *postBB = BasicBlock::Create(jl_LLVMContext, \"post_is\", ctx.f);\n        ctx.builder.CreateCondBr(same_type, isaBB, postBB);\n        ctx.builder.SetInsertPoint(isaBB);\n        Value *bitcmp = emit_bits_compare(ctx,\n                jl_cgval_t(arg1, typ, NULL),\n                jl_cgval_t(arg2, typ, NULL));\n        ctx.builder.CreateBr(postBB);\n        ctx.builder.SetInsertPoint(postBB);\n        PHINode *cmp = ctx.builder.CreatePHI(T_int1, 2);\n        cmp->addIncoming(ConstantInt::get(T_int1, 0), currBB);\n        cmp->addIncoming(bitcmp, isaBB);\n        return cmp;\n    }\n\n    // if (arg1.tindex || arg2.tindex)\n    //   TODO: handle with emit_bitsunion_compare\n\n    int ptr_comparable = 0; // whether this type is unique'd by pointer\n    if (rt1 == (jl_value_t*)jl_sym_type || rt2 == (jl_value_t*)jl_sym_type)\n        ptr_comparable = 1;\n    if (jl_is_mutable_datatype(rt1) || jl_is_mutable_datatype(rt2)) // excludes abstract types\n        ptr_comparable = 1;\n    if (jl_subtype(rt1, (jl_value_t*)jl_type_type) ||\n        jl_subtype(rt2, (jl_value_t*)jl_type_type)) {\n        // need to use typeseq for most types\n        ptr_comparable = 0;\n        if ((jl_is_type_type(rt1) && jl_is_concrete_type(jl_tparam0(rt1))) ||\n            (jl_is_type_type(rt2) && jl_is_concrete_type(jl_tparam0(rt2)))) {\n            // but can compare some types by pointer\n            ptr_comparable = 1;\n        }\n    }\n    if ((rt1 == (jl_value_t*)jl_string_type && rt2 == (jl_value_t*)jl_string_type) ||\n        (rt1 == (jl_value_t*)jl_simplevector_type && rt2 == (jl_value_t*)jl_simplevector_type))\n        ptr_comparable = 0; // technically mutable, but compared by contents\n    if (ptr_comparable) {\n        Value *varg1 = arg1.constant ? literal_pointer_val(ctx, arg1.constant) : arg1.V;\n        Value *varg2 = arg2.constant ? literal_pointer_val(ctx, arg2.constant) : arg2.V;\n        assert(varg1 && varg2 && (arg1.isboxed || arg1.TIndex) && (arg2.isboxed || arg2.TIndex) &&\n                \"Only boxed types are valid for pointer comparison.\");\n        varg1 = maybe_decay_tracked(varg1);\n        varg2 = maybe_decay_tracked(varg2);\n        if (cast<PointerType>(varg1->getType())->getAddressSpace() != cast<PointerType>(varg2->getType())->getAddressSpace()) {\n            varg1 = decay_derived(varg1);\n            varg2 = decay_derived(varg2);\n        }\n        return ctx.builder.CreateICmpEQ(emit_bitcast(ctx, varg1, T_pint8),\n                                        emit_bitcast(ctx, varg2, T_pint8));\n    }\n\n    Value *varg1 = mark_callee_rooted(boxed(ctx, arg1));\n    Value *varg2 = mark_callee_rooted(boxed(ctx, arg2));\n    return ctx.builder.CreateTrunc(ctx.builder.CreateCall(prepare_call(jlegal_func), {varg1, varg2}), T_int1);\n}\n\nstatic bool emit_builtin_call(jl_codectx_t &ctx, jl_cgval_t *ret, jl_value_t *f,\n                              const jl_cgval_t *argv, size_t nargs, jl_value_t *rt,\n                              jl_expr_t *ex)\n// returns true if the call has been handled\n{\n    if (f == jl_builtin_is && nargs == 2) {\n        // emit values\n        const jl_cgval_t &v1 = argv[1];\n        const jl_cgval_t &v2 = argv[2];\n        // handle simple static expressions with no side-effects\n        if (v1.constant) {\n            if (v2.constant) {\n                *ret = mark_julia_type(ctx, ConstantInt::get(T_int8, jl_egal(v1.constant, v2.constant)), false, jl_bool_type);\n                return true;\n            }\n        }\n        // emit comparison test\n        Value *ans = emit_f_is(ctx, v1, v2);\n        *ret = mark_julia_type(ctx, ctx.builder.CreateZExt(ans, T_int8), false, jl_bool_type);\n        return true;\n    }\n\n    else if (f == jl_builtin_typeof && nargs == 1) {\n        *ret = emit_typeof(ctx, argv[1]);\n        return true;\n    }\n\n    else if (f == jl_builtin_typeassert && nargs == 2) {\n        const jl_cgval_t &arg = argv[1];\n        const jl_cgval_t &ty = argv[2];\n        if (jl_is_type_type(ty.typ) && !jl_has_free_typevars(ty.typ)) {\n            jl_value_t *tp0 = jl_tparam0(ty.typ);\n            emit_typecheck(ctx, arg, tp0, \"typeassert\");\n            *ret = arg;\n            return true;\n        }\n        if (jl_subtype(ty.typ, (jl_value_t*)jl_type_type)) {\n            Value *rt_arg = boxed(ctx, arg);\n            Value *rt_ty = boxed(ctx, ty);\n            ctx.builder.CreateCall(prepare_call(jltypeassert_func), {rt_arg, rt_ty});\n            *ret = arg;\n            return true;\n        }\n    }\n\n    else if (f == jl_builtin_isa && nargs == 2) {\n        const jl_cgval_t &arg = argv[1];\n        const jl_cgval_t &ty = argv[2];\n        if (jl_is_type_type(ty.typ) && !jl_has_free_typevars(ty.typ)) {\n            jl_value_t *tp0 = jl_tparam0(ty.typ);\n            Value *isa_result = emit_isa(ctx, arg, tp0, NULL).first;\n            if (isa_result->getType() == T_int1)\n                isa_result = ctx.builder.CreateZExt(isa_result, T_int8);\n            *ret = mark_julia_type(ctx, isa_result, false, jl_bool_type);\n            return true;\n        }\n    }\n\n    else if (f == jl_builtin_issubtype && nargs == 2) {\n        const jl_cgval_t &ta = argv[1];\n        const jl_cgval_t &tb = argv[2];\n        if (jl_is_type_type(ta.typ) && !jl_has_free_typevars(ta.typ) &&\n            jl_is_type_type(tb.typ) && !jl_has_free_typevars(tb.typ)) {\n            int issub = jl_subtype(jl_tparam0(ta.typ), jl_tparam0(tb.typ));\n            *ret = mark_julia_type(ctx, ConstantInt::get(T_int8, issub), false, jl_bool_type);\n            return true;\n        }\n    }\n\n    else if (f == jl_builtin__apply && nargs == 2 && ctx.vaSlot > 0) {\n        // turn Core._apply(f, Tuple) ==> f(Tuple...) using the jlcall calling convention if Tuple is the va allocation\n        if (LoadInst *load = dyn_cast_or_null<LoadInst>(argv[2].V)) {\n            if (load->getPointerOperand() == ctx.slots[ctx.vaSlot].boxroot && ctx.argArray) {\n                Value *theF = maybe_decay_untracked(boxed(ctx, argv[1]));\n                Value *nva = emit_n_varargs(ctx);\n#ifdef _P64\n                nva = ctx.builder.CreateTrunc(nva, T_int32);\n#endif\n                Value *theArgs = ctx.builder.CreateInBoundsGEP(ctx.argArray, ConstantInt::get(T_size, ctx.nReqArgs));\n                Value *r = ctx.builder.CreateCall(prepare_call(jlapply2va_func), { theF, theArgs, nva });\n                *ret = mark_julia_type(ctx, r, true, jl_any_type);\n                return true;\n            }\n        }\n    }\n\n    else if (f == jl_builtin_tuple) {\n        if (nargs == 0) {\n            *ret = ghostValue(jl_emptytuple_type);\n            return true;\n        }\n        if (jl_is_tuple_type(rt) && jl_is_concrete_type(rt) && nargs == jl_datatype_nfields(rt)) {\n            *ret = emit_new_struct(ctx, rt, nargs, &argv[1]);\n            return true;\n        }\n    }\n\n    else if (f == jl_builtin_throw && nargs == 1) {\n        Value *arg1 = boxed(ctx, argv[1]);\n        raise_exception(ctx, arg1);\n        *ret = jl_cgval_t();\n        return true;\n    }\n\n    else if (f == jl_builtin_arraysize && nargs == 2) {\n        const jl_cgval_t &ary = argv[1];\n        const jl_cgval_t &idx = argv[2];\n        jl_value_t *aty = jl_unwrap_unionall(ary.typ);\n        if (jl_is_array_type(aty) && idx.typ == (jl_value_t*)jl_long_type) {\n            jl_value_t *ndp = jl_tparam1(aty);\n            if (jl_is_long(ndp)) {\n                size_t ndims = jl_unbox_long(ndp);\n                if (idx.constant) {\n                    uint32_t idx_const = (uint32_t)jl_unbox_long(idx.constant);\n                    if (idx_const > 0 && idx_const <= ndims) {\n                        jl_value_t *ary_ex = jl_exprarg(ex, 1);\n                        *ret = mark_julia_type(ctx, emit_arraysize(ctx, ary, ary_ex, idx_const), false, jl_long_type);\n                        return true;\n                    }\n                    else if (idx_const > ndims) {\n                        *ret = mark_julia_type(ctx, ConstantInt::get(T_size, 1), false, jl_long_type);\n                        return true;\n                    }\n                }\n                else {\n                    Value *idx_dyn = emit_unbox(ctx, T_size, idx, (jl_value_t*)jl_long_type);\n                    error_unless(ctx, ctx.builder.CreateICmpSGT(idx_dyn, ConstantInt::get(T_size, 0)),\n                                 \"arraysize: dimension out of range\");\n                    BasicBlock *outBB = BasicBlock::Create(jl_LLVMContext, \"outofrange\", ctx.f);\n                    BasicBlock *inBB = BasicBlock::Create(jl_LLVMContext, \"inrange\");\n                    BasicBlock *ansBB = BasicBlock::Create(jl_LLVMContext, \"arraysize\");\n                    ctx.builder.CreateCondBr(ctx.builder.CreateICmpSLE(idx_dyn,\n                                ConstantInt::get(T_size, ndims)),\n                            inBB, outBB);\n                    ctx.builder.SetInsertPoint(outBB);\n                    Value *v_one = ConstantInt::get(T_size, 1);\n                    ctx.builder.CreateBr(ansBB);\n                    ctx.f->getBasicBlockList().push_back(inBB);\n                    ctx.builder.SetInsertPoint(inBB);\n                    Value *v_sz = emit_arraysize(ctx, ary, idx_dyn);\n                    ctx.builder.CreateBr(ansBB);\n                    ctx.f->getBasicBlockList().push_back(ansBB);\n                    ctx.builder.SetInsertPoint(ansBB);\n                    PHINode *result = ctx.builder.CreatePHI(T_size, 2);\n                    result->addIncoming(v_one, outBB);\n                    result->addIncoming(v_sz, inBB);\n                    *ret = mark_julia_type(ctx, result, false, jl_long_type);\n                    return true;\n                }\n            }\n        }\n    }\n\n    else if (f == jl_builtin_arrayref && nargs >= 3) {\n        const jl_cgval_t &ary = argv[2];\n        bool indices_ok = true;\n        for (size_t i = 3; i <= nargs; i++) {\n            if (argv[i].typ != (jl_value_t*)jl_long_type) {\n                indices_ok = false;\n                break;\n            }\n        }\n        jl_value_t *aty_dt = jl_unwrap_unionall(ary.typ);\n        if (jl_is_array_type(aty_dt) && indices_ok) {\n            jl_value_t *ety = jl_tparam0(aty_dt);\n            jl_value_t *ndp = jl_tparam1(aty_dt);\n            if (!jl_has_free_typevars(ety) && (jl_is_long(ndp) || nargs == 3)) {\n                jl_value_t *ary_ex = jl_exprarg(ex, 2);\n                size_t elsz = 0, al = 0;\n                int union_max = jl_islayout_inline(ety, &elsz, &al);\n                bool isboxed = (union_max == 0);\n                if (isboxed)\n                    ety = (jl_value_t*)jl_any_type;\n                ssize_t nd = jl_is_long(ndp) ? jl_unbox_long(ndp) : -1;\n                jl_value_t *boundscheck = argv[1].constant;\n                Value *idx = emit_array_nd_index(ctx, ary, ary_ex, nd, &argv[3], nargs - 2, boundscheck);\n                if (!isboxed && jl_is_datatype(ety) && jl_datatype_size(ety) == 0) {\n                    assert(((jl_datatype_t*)ety)->instance != NULL);\n                    *ret = ghostValue(ety);\n                }\n                else if (!isboxed && jl_is_uniontype(ety)) {\n                    Type *AT = ArrayType::get(IntegerType::get(jl_LLVMContext, 8 * al), (elsz + al - 1) / al);\n                    Value *data = emit_bitcast(ctx, emit_arrayptr(ctx, ary, ary_ex), AT->getPointerTo());\n                    // isbits union selector bytes are stored after a->maxsize\n                    Value *ndims = (nd == -1 ? emit_arrayndims(ctx, ary) : ConstantInt::get(T_int16, nd));\n                    Value *is_vector = ctx.builder.CreateICmpEQ(ndims, ConstantInt::get(T_int16, 1));\n                    Value *offset = emit_arrayoffset(ctx, ary, nd);\n                    Value *selidx_v = ctx.builder.CreateSub(emit_vectormaxsize(ctx, ary), ctx.builder.CreateZExt(offset, T_size));\n                    Value *selidx_m = emit_arraylen(ctx, ary);\n                    Value *selidx = ctx.builder.CreateSelect(is_vector, selidx_v, selidx_m);\n                    Value *ptindex = ctx.builder.CreateInBoundsGEP(AT, data, selidx);\n                    ptindex = emit_bitcast(ctx, ptindex, T_pint8);\n                    ptindex = ctx.builder.CreateInBoundsGEP(T_int8, ptindex, offset);\n                    ptindex = ctx.builder.CreateInBoundsGEP(T_int8, ptindex, idx);\n                    Instruction *tindex = tbaa_decorate(tbaa_arrayselbyte, ctx.builder.CreateLoad(T_int8, ptindex));\n                    tindex->setMetadata(LLVMContext::MD_range, MDNode::get(jl_LLVMContext, {\n                        ConstantAsMetadata::get(ConstantInt::get(T_int8, 0)),\n                        ConstantAsMetadata::get(ConstantInt::get(T_int8, union_max)) }));\n                    AllocaInst *lv = emit_static_alloca(ctx, AT);\n                    if (al > 1)\n                        lv->setAlignment(al);\n                    emit_memcpy(ctx, lv, tbaa_arraybuf, ctx.builder.CreateInBoundsGEP(AT, data, idx), tbaa_arraybuf, elsz, al, false);\n                    *ret = mark_julia_slot(lv, ety, ctx.builder.CreateNUWAdd(ConstantInt::get(T_int8, 1), tindex), tbaa_arraybuf);\n                }\n                else {\n                    *ret = typed_load(ctx,\n                            emit_arrayptr(ctx, ary, ary_ex),\n                            idx, ety,\n                            !isboxed ? tbaa_arraybuf : tbaa_ptrarraybuf);\n                }\n                return true;\n            }\n        }\n    }\n\n    else if (f == jl_builtin_arrayset && nargs >= 4) {\n        const jl_cgval_t &ary = argv[2];\n        const jl_cgval_t &val = argv[3];\n        bool indices_ok = true;\n        for (size_t i = 4; i <= nargs; i++) {\n            if (argv[i].typ != (jl_value_t*)jl_long_type) {\n                indices_ok = false;\n                break;\n            }\n        }\n        jl_value_t *aty_dt = jl_unwrap_unionall(ary.typ);\n        if (jl_is_array_type(aty_dt) && indices_ok) {\n            jl_value_t *ety = jl_tparam0(aty_dt);\n            jl_value_t *ndp = jl_tparam1(aty_dt);\n            if (!jl_has_free_typevars(ety) && (jl_is_long(ndp) || nargs == 4)) {\n                if (jl_subtype(val.typ, ety)) { // TODO: probably should just convert this to a type-assert\n                    size_t elsz = 0, al = 0;\n                    int union_max = jl_islayout_inline(ety, &elsz, &al);\n                    bool isboxed = (union_max == 0);\n                    if (isboxed)\n                        ety = (jl_value_t*)jl_any_type;\n                    jl_value_t *ary_ex = jl_exprarg(ex, 2);\n                    ssize_t nd = jl_is_long(ndp) ? jl_unbox_long(ndp) : -1;\n                    jl_value_t *boundscheck = argv[1].constant;\n                    Value *idx = emit_array_nd_index(ctx, ary, ary_ex, nd, &argv[4], nargs - 3, boundscheck);\n                    if (!isboxed && jl_is_datatype(ety) && jl_datatype_size(ety) == 0) {\n                        // no-op\n                    }\n                    else {\n                        PHINode *data_owner = NULL; // owner object against which the write barrier must check\n                        if (isboxed) { // if not boxed we don't need a write barrier\n                            assert(ary.isboxed);\n                            Value *aryv = maybe_decay_untracked(boxed(ctx, ary));\n                            Value *flags = emit_arrayflags(ctx, ary);\n                            // the owner of the data is ary itself except if ary->how == 3\n                            flags = ctx.builder.CreateAnd(flags, 3);\n                            Value *is_owned = ctx.builder.CreateICmpEQ(flags, ConstantInt::get(T_int16, 3));\n                            BasicBlock *curBB = ctx.builder.GetInsertBlock();\n                            BasicBlock *ownedBB = BasicBlock::Create(jl_LLVMContext, \"array_owned\", ctx.f);\n                            BasicBlock *mergeBB = BasicBlock::Create(jl_LLVMContext, \"merge_own\", ctx.f);\n                            ctx.builder.CreateCondBr(is_owned, ownedBB, mergeBB);\n                            ctx.builder.SetInsertPoint(ownedBB);\n                            // load owner pointer\n                            Instruction *own_ptr;\n                            if (jl_is_long(ndp)) {\n                                own_ptr = ctx.builder.CreateLoad(T_prjlvalue,\n                                        ctx.builder.CreateConstGEP1_32(T_prjlvalue,\n                                            emit_bitcast(ctx, decay_derived(aryv), T_pprjlvalue),\n                                            jl_array_data_owner_offset(nd) / sizeof(jl_value_t*)));\n                                tbaa_decorate(tbaa_const, maybe_mark_load_dereferenceable(own_ptr, false, (jl_value_t*)jl_array_any_type));\n                            }\n                            else {\n                                own_ptr = ctx.builder.CreateCall(\n                                    prepare_call(jlarray_data_owner_func),\n                                    {aryv});\n                            }\n                            ctx.builder.CreateBr(mergeBB);\n                            ctx.builder.SetInsertPoint(mergeBB);\n                            data_owner = ctx.builder.CreatePHI(T_prjlvalue, 2);\n                            data_owner->addIncoming(aryv, curBB);\n                            data_owner->addIncoming(own_ptr, ownedBB);\n                        }\n                        if (jl_is_uniontype(ety)) {\n                            Type *AT = ArrayType::get(IntegerType::get(jl_LLVMContext, 8 * al), (elsz + al - 1) / al);\n                            Value *data = emit_bitcast(ctx, emit_arrayptr(ctx, ary, ary_ex), AT->getPointerTo());\n                            // compute tindex from val\n                            jl_cgval_t rhs_union = convert_julia_type(ctx, val, ety);\n                            Value *tindex = compute_tindex_unboxed(ctx, rhs_union, ety);\n                            tindex = ctx.builder.CreateNUWSub(tindex, ConstantInt::get(T_int8, 1));\n                            Value *ndims = (nd == -1 ? emit_arrayndims(ctx, ary) : ConstantInt::get(T_int16, nd));\n                            Value *is_vector = ctx.builder.CreateICmpEQ(ndims, ConstantInt::get(T_int16, 1));\n                            Value *offset = emit_arrayoffset(ctx, ary, nd);\n                            Value *selidx_v = ctx.builder.CreateSub(emit_vectormaxsize(ctx, ary), ctx.builder.CreateZExt(offset, T_size));\n                            Value *selidx_m = emit_arraylen(ctx, ary);\n                            Value *selidx = ctx.builder.CreateSelect(is_vector, selidx_v, selidx_m);\n                            Value *ptindex = ctx.builder.CreateInBoundsGEP(AT, data, selidx);\n                            ptindex = emit_bitcast(ctx, ptindex, T_pint8);\n                            ptindex = ctx.builder.CreateInBoundsGEP(T_int8, ptindex, offset);\n                            ptindex = ctx.builder.CreateInBoundsGEP(T_int8, ptindex, idx);\n                            tbaa_decorate(tbaa_arrayselbyte, ctx.builder.CreateStore(tindex, ptindex));\n                            if (jl_is_datatype(val.typ) && jl_datatype_size(val.typ) == 0) {\n                                // no-op\n                            }\n                            else {\n                                // copy data\n                                Value *addr = ctx.builder.CreateInBoundsGEP(AT, data, idx);\n                                emit_unionmove(ctx, addr, tbaa_arraybuf, val, nullptr);\n                            }\n                        }\n                        else {\n                            typed_store(ctx,\n                                        emit_arrayptr(ctx, ary, ary_ex, isboxed),\n                                        idx, val, ety,\n                                        !isboxed ? tbaa_arraybuf : tbaa_ptrarraybuf,\n                                        data_owner, 0);\n                        }\n                    }\n                    *ret = ary;\n                    return true;\n                }\n            }\n        }\n    }\n\n    else if (f == jl_builtin_getfield && (nargs == 2 || nargs == 3)) {\n        const jl_cgval_t &obj = argv[1];\n        const jl_cgval_t &fld = argv[2];\n        if (fld.constant && fld.typ == (jl_value_t*)jl_symbol_type) {\n            *ret = emit_getfield(ctx, argv[1], (jl_sym_t*)fld.constant);\n            return true;\n        }\n\n        if (fld.typ == (jl_value_t*)jl_long_type) {\n            if (ctx.vaSlot > 0) {\n                // optimize VA tuple\n                if (LoadInst *load = dyn_cast_or_null<LoadInst>(obj.V)) {\n                    if (load->getPointerOperand() == ctx.slots[ctx.vaSlot].boxroot && ctx.argArray) {\n                        Value *valen = emit_n_varargs(ctx);\n                        jl_cgval_t va_ary( // fake instantiation of a cgval, in order to call emit_bounds_check\n                                ctx.builder.CreateInBoundsGEP(ctx.argArray, ConstantInt::get(T_size, ctx.nReqArgs)),\n                                NULL, false, NULL, NULL);\n                        Value *idx = emit_unbox(ctx, T_size, fld, (jl_value_t*)jl_long_type);\n                        jl_value_t *boundscheck = (nargs == 3 ? argv[3].constant : jl_true);\n                        idx = emit_bounds_check(ctx, va_ary, NULL, idx, valen, boundscheck);\n                        idx = ctx.builder.CreateAdd(idx, ConstantInt::get(T_size, ctx.nReqArgs));\n                        Instruction *v = ctx.builder.CreateLoad(ctx.builder.CreateInBoundsGEP(ctx.argArray, idx));\n                        // if we know the result type of this load, we will mark that information here too\n                        tbaa_decorate(tbaa_value, maybe_mark_load_dereferenceable(v, false, rt));\n                        *ret = mark_julia_type(ctx, v, /*boxed*/ true, rt);\n                        return true;\n                    }\n                }\n            }\n\n            jl_datatype_t *utt = (jl_datatype_t*)jl_unwrap_unionall(obj.typ);\n            if (jl_is_datatype(utt) && utt->layout) {\n                if ((jl_is_structtype(utt) || jl_is_tuple_type(utt)) && !jl_subtype((jl_value_t*)jl_module_type, obj.typ)) {\n                    size_t nfields = jl_datatype_nfields(utt);\n                    // integer index\n                    size_t idx;\n                    if (fld.constant && (idx = jl_unbox_long(fld.constant) - 1) < nfields) {\n                        // known index\n                        *ret = emit_getfield_knownidx(ctx, obj, idx, utt);\n                        return true;\n                    }\n                    else {\n                        // unknown index\n                        Value *vidx = emit_unbox(ctx, T_size, fld, (jl_value_t*)jl_long_type);\n                        jl_value_t *boundscheck = (nargs == 3 ? argv[3].constant : jl_true);\n                        if (emit_getfield_unknownidx(ctx, ret, obj, vidx, utt, boundscheck)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            else {\n                if (jl_is_tuple_type(utt) && is_tupletype_homogeneous(utt->types, true)) {\n                    // For tuples, we can emit code even if we don't know the exact\n                    // type (e.g. because we don't know the length). This is possible\n                    // as long as we know that all elements are of the same (leaf) type.\n                    if (obj.ispointer()) {\n                        // Determine which was the type that was homogenous\n                        jl_value_t *jt = jl_tparam0(utt);\n                        if (jl_is_vararg_type(jt))\n                            jt = jl_unwrap_vararg(jt);\n                        Value *vidx = emit_unbox(ctx, T_size, fld, (jl_value_t*)jl_long_type);\n                        // This is not necessary for correctness, but allows to omit\n                        // the extra code for getting the length of the tuple\n                        jl_value_t *boundscheck = (nargs == 3 ? argv[3].constant : jl_true);\n                        if (!bounds_check_enabled(ctx, boundscheck)) {\n                            vidx = ctx.builder.CreateSub(vidx, ConstantInt::get(T_size, 1));\n                        } else {\n                            vidx = emit_bounds_check(ctx, obj, (jl_value_t*)obj.typ, vidx,\n                                emit_datatype_nfields(ctx, emit_typeof_boxed(ctx, obj)),\n                                jl_true);\n                        }\n                        Value *ptr = maybe_decay_tracked(data_pointer(ctx, obj));\n                        *ret = typed_load(ctx, ptr, vidx, jt, obj.tbaa, false);\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n\n    else if (f == jl_builtin_setfield && nargs == 3) {\n        const jl_cgval_t &obj = argv[1];\n        const jl_cgval_t &fld = argv[2];\n        const jl_cgval_t &val = argv[3];\n\n        jl_datatype_t *uty = (jl_datatype_t*)jl_unwrap_unionall(obj.typ);\n        if (jl_is_structtype(uty) && uty != jl_module_type && uty->layout) {\n            size_t idx = (size_t)-1;\n            if (fld.constant && fld.typ == (jl_value_t*)jl_symbol_type) {\n                idx = jl_field_index(uty, (jl_sym_t*)fld.constant, 0);\n            }\n            else if (fld.constant && fld.typ == (jl_value_t*)jl_long_type) {\n                ssize_t i = jl_unbox_long(fld.constant);\n                if (i > 0 && i <= jl_datatype_nfields(uty))\n                    idx = i - 1;\n            }\n            if (idx != (size_t)-1) {\n                jl_value_t *ft = jl_svecref(uty->types, idx);\n                if (jl_subtype(val.typ, ft)) {\n                    // TODO: attempt better codegen for approximate types\n                    emit_setfield(ctx, uty, obj, idx, val, true, true);\n                    *ret = val;\n                    return true;\n                }\n            }\n        }\n    }\n\n    else if (f == jl_builtin_nfields && nargs == 1) {\n        const jl_cgval_t &obj = argv[1];\n        if (ctx.vaSlot > 0) {\n            // optimize VA tuple\n            if (LoadInst *load = dyn_cast_or_null<LoadInst>(obj.V)) {\n                if (load->getPointerOperand() == ctx.slots[ctx.vaSlot].boxroot) {\n                    *ret = mark_julia_type(ctx, emit_n_varargs(ctx), false, jl_long_type);\n                    return true;\n                }\n            }\n        }\n        if (jl_is_type_type(obj.typ)) {\n            jl_value_t *tp0 = jl_tparam0(obj.typ);\n            if (jl_is_concrete_type(tp0)) {\n                *ret = mark_julia_type(ctx, ConstantInt::get(T_size, jl_datatype_nfields(tp0)), false, jl_long_type);\n                return true;\n            }\n        }\n        else if (jl_is_concrete_type(obj.typ) || obj.constant) {\n            Value *sz;\n            if (obj.constant) {\n                if (jl_typeof(obj.constant) == (jl_value_t*)jl_datatype_type)\n                    sz = ConstantInt::get(T_size, jl_datatype_nfields(obj.constant));\n                else\n                    sz = ConstantInt::get(T_size, jl_datatype_nfields(obj.typ));\n            }\n            else if (obj.typ == (jl_value_t*)jl_datatype_type) {\n                sz = emit_datatype_nfields(ctx, boxed(ctx, obj));\n            }\n            else {\n                assert(jl_is_datatype(obj.typ));\n                sz = ConstantInt::get(T_size, jl_datatype_nfields(obj.typ));\n            }\n            *ret = mark_julia_type(ctx, sz, false, jl_long_type);\n            return true;\n        }\n    }\n\n    else if (f == jl_builtin_fieldtype && (nargs == 2 || nargs == 3)) {\n        const jl_cgval_t &typ = argv[1];\n        const jl_cgval_t &fld = argv[2];\n        if ((jl_is_type_type(typ.typ) && jl_is_concrete_type(jl_tparam0(typ.typ))) ||\n                (typ.constant && jl_is_concrete_type(typ.constant))) {\n            if (fld.typ == (jl_value_t*)jl_long_type) {\n                assert(typ.isboxed);\n                Value *tyv = boxed(ctx, typ);\n                Value *types_svec = emit_datatype_types(ctx, tyv);\n                Value *types_len = emit_datatype_nfields(ctx, tyv);\n                Value *idx = emit_unbox(ctx, T_size, fld, (jl_value_t*)jl_long_type);\n                jl_value_t *boundscheck = (nargs == 3 ? argv[3].constant : jl_true);\n                emit_bounds_check(ctx, typ, (jl_value_t*)jl_datatype_type, idx, types_len, boundscheck);\n                Value *fieldtyp_p = ctx.builder.CreateInBoundsGEP(decay_derived(emit_bitcast(ctx, types_svec, T_pprjlvalue)), idx);\n                Value *fieldtyp = tbaa_decorate(tbaa_const, ctx.builder.CreateLoad(fieldtyp_p));\n                *ret = mark_julia_type(ctx, fieldtyp, true, (jl_value_t*)jl_type_type);\n                return true;\n            }\n        }\n    }\n\n    else if (f == jl_builtin_sizeof && nargs == 1) {\n        const jl_cgval_t &obj = argv[1];\n        jl_datatype_t *sty = (jl_datatype_t*)jl_unwrap_unionall(obj.typ);\n        assert(jl_string_type->mutabl);\n        if (sty == jl_string_type || sty == jl_simplevector_type) {\n            // String and SimpleVector's length fields have the same layout\n            auto ptr = emit_bitcast(ctx, boxed(ctx, obj), T_psize);\n            Value *len = tbaa_decorate(tbaa_mutab, ctx.builder.CreateLoad(ptr));\n            if (sty == jl_simplevector_type) {\n                len = ctx.builder.CreateMul(len, ConstantInt::get(T_size, sizeof(void*)));\n                len = ctx.builder.CreateAdd(len, ConstantInt::get(T_size, sizeof(void*)));\n            }\n            *ret = mark_julia_type(ctx, len, false, jl_long_type);\n            return true;\n        }\n        else if (jl_is_datatype(sty) && sty->name == jl_array_typename) {\n            auto len = emit_arraylen(ctx, obj);\n            jl_value_t *ety = jl_tparam0(sty);\n            Value *elsize;\n            size_t elsz = 0, al = 0;\n            int union_max = jl_islayout_inline(ety, &elsz, &al);\n            bool isboxed = (union_max == 0);\n            if (!jl_has_free_typevars(ety)) {\n                if (isboxed) {\n                    elsize = ConstantInt::get(T_size, sizeof(void*));\n                }\n                else {\n                    elsize = ConstantInt::get(T_size, elsz);\n                }\n            }\n            else {\n                elsize = ctx.builder.CreateZExt(emit_arrayelsize(ctx, obj), T_size);\n            }\n            *ret = mark_julia_type(ctx, ctx.builder.CreateMul(len, elsize), false, jl_long_type);\n            return true;\n        }\n        if (jl_is_type_type((jl_value_t*)sty) && !jl_is_typevar(jl_tparam0(sty))) {\n            sty = (jl_datatype_t*)jl_tparam0(sty);\n        }\n        if (jl_is_datatype(sty) && sty != jl_symbol_type &&\n                sty->name != jl_array_typename &&\n                sty != jl_simplevector_type && sty != jl_string_type &&\n                // exclude DataType, since each DataType has its own size, not sizeof(DataType).\n                // this is issue #8798\n                sty != jl_datatype_type) {\n            if (jl_is_concrete_type((jl_value_t*)sty) ||\n                    (jl_field_names(sty) == jl_emptysvec && jl_datatype_size(sty) > 0)) {\n                *ret = mark_julia_type(ctx, ConstantInt::get(T_size, jl_datatype_size(sty)), false, jl_long_type);\n                return true;\n            }\n        }\n    }\n\n    else if (f == jl_builtin_apply_type && nargs > 0) {\n        if (jl_is_method(ctx.linfo->def.method)) {\n            // don't bother codegen constant-folding for toplevel.\n            jl_value_t *ty = static_apply_type(ctx, argv, nargs + 1);\n            if (ty != NULL) {\n                jl_add_method_root(ctx, ty);\n                *ret = mark_julia_const(ty);\n                return true;\n            }\n        }\n    }\n\n    else if (f == jl_builtin_isdefined && nargs == 2) {\n        const jl_cgval_t &obj = argv[1];\n        const jl_cgval_t &fld = argv[2];\n        jl_datatype_t *stt = (jl_datatype_t*)obj.typ;\n        if (jl_is_type_type((jl_value_t*)stt)) {\n            // the representation type of Type{T} is either typeof(T), or unknown\n            // TODO: could use `issingletontype` predicate here, providing better type knowledge\n            // than only handling DataType\n            if (jl_is_concrete_type(jl_tparam0(stt)))\n                stt = (jl_datatype_t*)jl_typeof(jl_tparam0(stt));\n            else\n                return false;\n        }\n        if (!jl_is_concrete_type((jl_value_t*)stt) || jl_is_array_type(stt) ||\n            stt == jl_module_type) { // TODO: use ->layout here instead of concrete_type\n            return false;\n        }\n        assert(jl_is_datatype(stt));\n\n        ssize_t fieldidx = -1;\n        if (fld.constant && fld.typ == (jl_value_t*)jl_symbol_type) {\n            jl_sym_t *sym = (jl_sym_t*)fld.constant;\n            fieldidx = jl_field_index(stt, sym, 0);\n        }\n        else if (fld.constant && fld.typ == (jl_value_t*)jl_long_type) {\n            fieldidx = jl_unbox_long(fld.constant) - 1;\n        }\n        else {\n            return false;\n        }\n        if (fieldidx < 0 || fieldidx >= jl_datatype_nfields(stt)) {\n            *ret = mark_julia_const(jl_false);\n        }\n        else if (!jl_field_isptr(stt, fieldidx) || fieldidx < stt->ninitialized) {\n            *ret = mark_julia_const(jl_true);\n        }\n        else {\n            size_t offs = jl_field_offset(stt, fieldidx);\n            Value *ptr = emit_bitcast(ctx, maybe_decay_tracked(data_pointer(ctx, obj)), T_pprjlvalue);\n            Value *llvm_idx = ConstantInt::get(T_size, offs / sizeof(void*));\n            Value *addr = ctx.builder.CreateInBoundsGEP(ptr, llvm_idx);\n            // emit this using the same type as emit_getfield_knownidx\n            // so that LLVM may be able to load-load forward them and fold the result\n            Value *fldv = tbaa_decorate(obj.tbaa, ctx.builder.CreateLoad(T_prjlvalue, addr));\n            Value *isdef = ctx.builder.CreateIsNotNull(fldv);\n            *ret = mark_julia_type(ctx, isdef, false, jl_bool_type);\n        }\n        return true;\n    }\n    return false;\n}\n\nstatic Value *emit_jlcall(jl_codectx_t &ctx, Value *theFptr, Value *theF,\n                          jl_cgval_t *argv, size_t nargs)\n{\n    // emit arguments\n    SmallVector<Value*, 3> theArgs;\n    if (theF)\n        theArgs.push_back(theF);\n    for (size_t i = 0; i < nargs; i++) {\n        Value *arg = maybe_decay_untracked(boxed(ctx, argv[i]));\n        theArgs.push_back(arg);\n    }\n    SmallVector<Type *, 3> argsT;\n    for (size_t i = 0; i < nargs + (theF != nullptr); i++) {\n        argsT.push_back(T_prjlvalue);\n    }\n    FunctionType *FTy = FunctionType::get(T_prjlvalue, argsT, false);\n    CallInst *result = ctx.builder.CreateCall(FTy,\n        ctx.builder.CreateBitCast(prepare_call(theFptr), FTy->getPointerTo()),\n        theArgs);\n    add_return_attr(result, Attribute::NonNull);\n    if (theF)\n        result->setCallingConv(JLCALL_F_CC);\n    else\n        result->setCallingConv(JLCALL_CC);\n    return result;\n}\n\n\nstatic jl_cgval_t emit_call_specfun_other(jl_codectx_t &ctx, jl_method_instance_t *li, StringRef specFunctionObject,\n                                          jl_cgval_t *argv, size_t nargs, jl_value_t *inferred_retty)\n{\n    // emit specialized call site\n    jl_value_t *jlretty = li->rettype;\n    jl_returninfo_t returninfo = get_specsig_function(jl_Module, specFunctionObject, li->specTypes, jlretty);\n    FunctionType *cft = returninfo.decl->getFunctionType();\n\n    size_t nfargs = cft->getNumParams();\n    Value **argvals = (Value**)alloca(nfargs * sizeof(Value*));\n    unsigned idx = 0;\n    AllocaInst *result;\n    switch (returninfo.cc) {\n    case jl_returninfo_t::Boxed:\n    case jl_returninfo_t::Register:\n    case jl_returninfo_t::Ghosts:\n        break;\n    case jl_returninfo_t::SRet:\n        result = emit_static_alloca(ctx, cft->getParamType(0)->getContainedType(0));\n        argvals[idx] = result;\n        idx++;\n        break;\n    case jl_returninfo_t::Union:\n        result = emit_static_alloca(ctx, ArrayType::get(T_int8, returninfo.union_bytes));\n        if (returninfo.union_align > 1)\n            result->setAlignment(returninfo.union_align);\n        argvals[idx] = result;\n        idx++;\n        break;\n    }\n\n    for (size_t i = 0; i < nargs; i++) {\n        jl_value_t *jt = jl_nth_slot_type(li->specTypes, i);\n        bool isboxed;\n        Type *et = julia_type_to_llvm(jt, &isboxed);\n        if (type_is_ghost(et))\n            continue;\n        assert(idx < nfargs);\n        Type *at = cft->getParamType(idx);\n        const jl_cgval_t &arg = argv[i];\n        if (isboxed) {\n            assert(at == T_prjlvalue && (et == T_pjlvalue || et == T_prjlvalue));\n            argvals[idx] = maybe_decay_untracked(boxed(ctx, arg));\n        }\n        else if (et->isAggregateType()) {\n            // can lazy load on demand, no copy needed\n            assert(at == PointerType::get(et, AddressSpace::Derived));\n            assert(arg.ispointer());\n            argvals[idx] = decay_derived(maybe_bitcast(ctx,\n                data_pointer(ctx, arg), at));\n        }\n        else {\n            assert(at == et);\n            argvals[idx] = emit_unbox(ctx, et, arg, jt);\n        }\n        idx++;\n    }\n    assert(idx == nfargs);\n    CallInst *call = ctx.builder.CreateCall(returninfo.decl, ArrayRef<Value*>(&argvals[0], nfargs));\n    call->setAttributes(returninfo.decl->getAttributes());\n\n    jl_cgval_t retval;\n    switch (returninfo.cc) {\n        case jl_returninfo_t::Boxed:\n            retval = mark_julia_type(ctx, call, true, inferred_retty);\n            break;\n        case jl_returninfo_t::Register:\n            retval = mark_julia_type(ctx, call, false, jlretty);\n            break;\n        case jl_returninfo_t::SRet:\n            retval = mark_julia_slot(result, jlretty, NULL, tbaa_stack);\n            break;\n        case jl_returninfo_t::Union: {\n            Value *box = ctx.builder.CreateExtractValue(call, 0);\n            Value *tindex = ctx.builder.CreateExtractValue(call, 1);\n            Value *derived = ctx.builder.CreateSelect(\n                ctx.builder.CreateICmpEQ(\n                        ctx.builder.CreateAnd(tindex, ConstantInt::get(T_int8, 0x80)),\n                        ConstantInt::get(T_int8, 0)),\n                decay_derived(ctx.builder.CreateBitCast(argvals[0], T_pjlvalue)),\n                decay_derived(box)\n            );\n            retval = mark_julia_slot(derived,\n                                     jlretty,\n                                     tindex,\n                                     tbaa_stack);\n            retval.Vboxed = box;\n            break;\n        }\n        case jl_returninfo_t::Ghosts:\n            retval = mark_julia_slot(NULL, jlretty, call, tbaa_stack);\n            break;\n    }\n    // see if inference has a different / better type for the call than the lambda\n    if (inferred_retty != retval.typ)\n        retval = update_julia_type(ctx, retval, inferred_retty);\n    return retval;\n}\n\nstatic jl_cgval_t emit_call_specfun_boxed(jl_codectx_t &ctx, jl_method_instance_t *li, StringRef specFunctionObject,\n                                          jl_cgval_t *argv, size_t nargs, jl_value_t *inferred_retty)\n{\n    auto theFptr = jl_Module->getOrInsertFunction(specFunctionObject, jl_func_sig);\n    if (auto F = dyn_cast<Function>(theFptr->stripPointerCasts())) {\n        add_return_attr(F, Attribute::NonNull);\n        F->addFnAttr(Thunk);\n    }\n    Value *ret = emit_jlcall(ctx, theFptr, boxed(ctx, argv[0]), &argv[1], nargs - 1);\n    return mark_julia_type(ctx, ret, true, inferred_retty);\n}\n\nstatic jl_cgval_t emit_invoke(jl_codectx_t &ctx, jl_expr_t *ex, jl_value_t *rt)\n{\n    jl_value_t **args = (jl_value_t**)jl_array_data(ex->args);\n    size_t arglen = jl_array_dim0(ex->args);\n    size_t nargs = arglen - 1;\n    assert(arglen >= 2);\n\n    jl_cgval_t lival = emit_expr(ctx, args[0]);\n    jl_cgval_t *argv = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * nargs);\n    for (size_t i = 0; i < nargs; ++i) {\n        argv[i] = emit_expr(ctx, args[i + 1]);\n        if (argv[i].typ == jl_bottom_type)\n            return jl_cgval_t();\n    }\n\n    bool handled = false;\n    jl_cgval_t result;\n    if (lival.constant) {\n        jl_method_instance_t *li = (jl_method_instance_t*)lival.constant;\n        assert(jl_is_method_instance(li));\n        jl_llvm_functions_t decls = jl_compile_linfo(&li, NULL, ctx.world, ctx.params);\n        if (li->invoke == jl_fptr_const_return) {\n            assert(li->inferred_const);\n            return mark_julia_const(li->inferred_const);\n        }\n        if (decls.functionObject) {\n            if (!strcmp(decls.functionObject, \"jl_fptr_args\")) {\n                result = emit_call_specfun_boxed(ctx, li, decls.specFunctionObject, argv, nargs, rt);\n                handled = true;\n            }\n            else if (!!strcmp(decls.functionObject, \"jl_fptr_sparam\")) {\n                result = emit_call_specfun_other(ctx, li, decls.specFunctionObject, argv, nargs, rt);\n                handled = true;\n            }\n        }\n    }\n    if (!handled) {\n        result = mark_julia_type(ctx,\n                emit_jlcall(\n                    ctx,\n                    prepare_call(jlinvoke_func),\n                    boxed(ctx, lival),\n                    argv, nargs),\n                true,\n                rt);\n    }\n    if (result.typ == jl_bottom_type)\n        CreateTrap(ctx.builder);\n    return result;\n}\n\nstatic jl_cgval_t emit_call(jl_codectx_t &ctx, jl_expr_t *ex, jl_value_t *rt)\n{\n    jl_value_t **args = (jl_value_t**)jl_array_data(ex->args);\n    size_t nargs = jl_array_dim0(ex->args);\n    assert(nargs >= 1);\n    jl_cgval_t f = emit_expr(ctx, args[0]);\n\n    if (f.constant && jl_typeis(f.constant, jl_intrinsic_type)) {\n        JL_I::intrinsic fi = (intrinsic)*(uint32_t*)jl_data_ptr(f.constant);\n        return emit_intrinsic(ctx, fi, args, nargs - 1);\n    }\n\n    jl_cgval_t *argv = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * nargs);\n    argv[0] = f;\n    for (size_t i = 1; i < nargs; ++i) {\n        argv[i] = emit_expr(ctx, args[i]);\n        if (argv[i].typ == jl_bottom_type)\n            return jl_cgval_t(); // anything past here is unreachable\n    }\n\n    if (f.constant && jl_isa(f.constant, (jl_value_t*)jl_builtin_type)) {\n        if (f.constant == jl_builtin_ifelse && nargs == 4)\n            return emit_ifelse(ctx, argv[1], argv[2], argv[3], rt);\n        jl_cgval_t result;\n        bool handled = emit_builtin_call(ctx, &result, f.constant, argv, nargs - 1, rt, ex);\n        if (handled) {\n            return result;\n        }\n\n        // special case for known builtin not handled by emit_builtin_call\n        std::map<jl_fptr_args_t, Function*>::iterator it = builtin_func_map.find(jl_get_builtin_fptr(f.constant));\n        if (it != builtin_func_map.end()) {\n            Value *theFptr = it->second;\n            Value *ret = emit_jlcall(ctx, theFptr, maybe_decay_untracked(V_null), &argv[1], nargs - 1);\n            return mark_julia_type(ctx, ret, true, rt);\n        }\n    }\n\n    // emit function and arguments\n    Value *callval = emit_jlcall(ctx, jlapplygeneric_func, nullptr, argv, nargs);\n    return mark_julia_type(ctx, callval, true, rt);\n}\n\n// --- accessing and assigning variables ---\n\nstatic void undef_var_error_ifnot(jl_codectx_t &ctx, Value *ok, jl_sym_t *name)\n{\n    BasicBlock *err = BasicBlock::Create(jl_LLVMContext, \"err\", ctx.f);\n    BasicBlock *ifok = BasicBlock::Create(jl_LLVMContext, \"ok\");\n    ctx.builder.CreateCondBr(ok, ifok, err);\n    ctx.builder.SetInsertPoint(err);\n    ctx.builder.CreateCall(prepare_call(jlundefvarerror_func),\n        mark_callee_rooted(literal_pointer_val(ctx, (jl_value_t*)name)));\n    ctx.builder.CreateUnreachable();\n    ctx.f->getBasicBlockList().push_back(ifok);\n    ctx.builder.SetInsertPoint(ifok);\n}\n\n// returns a jl_ppvalue_t location for the global variable m.s\n// if the reference currently bound or assign == true,\n//   pbnd will also be assigned with the binding address\nstatic Value *global_binding_pointer(jl_codectx_t &ctx, jl_module_t *m, jl_sym_t *s,\n                                     jl_binding_t **pbnd, bool assign)\n{\n    jl_binding_t *b = NULL;\n    if (assign) {\n        b = jl_get_binding_wr(m, s, 0);\n        assert(b != NULL);\n        if (b->owner != m) {\n            char *msg;\n            (void)asprintf(&msg, \"cannot assign variable %s.%s from module %s\",\n                    jl_symbol_name(b->owner->name), jl_symbol_name(s), jl_symbol_name(m->name));\n            emit_error(ctx, msg);\n            free(msg);\n        }\n    }\n    else {\n        b = jl_get_binding(m, s);\n        if (b == NULL) {\n            // var not found. switch to delayed lookup.\n            std::stringstream name;\n            name << \"delayedvar\" << globalUnique++;\n            Constant *initnul = V_null;\n            GlobalVariable *bindinggv = new GlobalVariable(*ctx.f->getParent(), T_pjlvalue,\n                    false, GlobalVariable::InternalLinkage,\n                    initnul, name.str());\n            Value *cachedval = ctx.builder.CreateLoad(bindinggv);\n            BasicBlock *have_val = BasicBlock::Create(jl_LLVMContext, \"found\"),\n                *not_found = BasicBlock::Create(jl_LLVMContext, \"notfound\");\n            BasicBlock *currentbb = ctx.builder.GetInsertBlock();\n            ctx.builder.CreateCondBr(ctx.builder.CreateICmpNE(cachedval, initnul), have_val, not_found);\n            ctx.f->getBasicBlockList().push_back(not_found);\n            ctx.builder.SetInsertPoint(not_found);\n            Value *bval = ctx.builder.CreateCall(prepare_call(jlgetbindingorerror_func),\n                    { literal_pointer_val(ctx, (jl_value_t*)m),\n                      literal_pointer_val(ctx, (jl_value_t*)s) });\n            ctx.builder.CreateStore(bval, bindinggv);\n            ctx.builder.CreateBr(have_val);\n            ctx.f->getBasicBlockList().push_back(have_val);\n            ctx.builder.SetInsertPoint(have_val);\n            PHINode *p = ctx.builder.CreatePHI(T_pjlvalue, 2);\n            p->addIncoming(cachedval, currentbb);\n            p->addIncoming(bval, not_found);\n            return julia_binding_gv(ctx, emit_bitcast(ctx, p, T_pprjlvalue));\n        }\n        if (b->deprecated)\n            cg_bdw(ctx, b);\n    }\n    if (pbnd)\n        *pbnd = b;\n    return julia_binding_gv(ctx, b);\n}\n\nstatic jl_cgval_t emit_checked_var(jl_codectx_t &ctx, Value *bp, jl_sym_t *name, bool isvol, MDNode *tbaa)\n{\n    assert(bp->getType() == T_pprjlvalue);\n    LoadInst *v = ctx.builder.CreateLoad(T_prjlvalue, bp);\n    if (isvol)\n        v->setVolatile(true);\n    if (tbaa)\n        tbaa_decorate(tbaa, v);\n    undef_var_error_ifnot(ctx, ctx.builder.CreateIsNotNull(v), name);\n    return mark_julia_type(ctx, v, true, jl_any_type);\n}\n\nstatic jl_cgval_t emit_sparam(jl_codectx_t &ctx, size_t i)\n{\n    if (jl_svec_len(ctx.linfo->sparam_vals) > 0) {\n        jl_value_t *e = jl_svecref(ctx.linfo->sparam_vals, i);\n        if (!jl_is_typevar(e)) {\n            return mark_julia_const(e);\n        }\n    }\n    assert(ctx.spvals_ptr != NULL);\n    Value *bp = ctx.builder.CreateConstInBoundsGEP1_32(\n            T_prjlvalue,\n            ctx.spvals_ptr,\n            i + sizeof(jl_svec_t) / sizeof(jl_value_t*));\n    Value *sp = tbaa_decorate(tbaa_const, ctx.builder.CreateLoad(bp));\n    Value *isnull = ctx.builder.CreateICmpNE(emit_typeof(ctx, sp),\n            maybe_decay_untracked(literal_pointer_val(ctx, (jl_value_t*)jl_tvar_type)));\n    jl_sym_t *name = (jl_sym_t*)jl_svecref(ctx.linfo->def.method->sparam_syms, i);\n    undef_var_error_ifnot(ctx, isnull, name);\n    return mark_julia_type(ctx, sp, true, jl_any_type);\n}\n\nstatic jl_cgval_t emit_global(jl_codectx_t &ctx, jl_sym_t *sym)\n{\n    jl_binding_t *jbp = NULL;\n    Value *bp = global_binding_pointer(ctx, ctx.module, sym, &jbp, false);\n    assert(bp != NULL);\n    if (jbp && jbp->value != NULL) {\n        if (jbp->constp)\n            return mark_julia_const(jbp->value);\n        // double-check that a global variable is actually defined. this\n        // can be a problem in parallel when a definition is missing on\n        // one machine.\n        return mark_julia_type(ctx, tbaa_decorate(tbaa_binding, ctx.builder.CreateLoad(bp)), true, jl_any_type);\n    }\n    return emit_checked_var(ctx, bp, sym, false, tbaa_binding);\n}\n\nstatic jl_cgval_t emit_isdefined(jl_codectx_t &ctx, jl_value_t *sym)\n{\n    Value *isnull;\n    if (jl_is_slot(sym)) {\n        size_t sl = jl_slot_number(sym) - 1;\n        jl_varinfo_t &vi = ctx.slots[sl];\n        if (!vi.usedUndef)\n            return mark_julia_const(jl_true);\n        if (vi.boxroot == NULL || vi.pTIndex != NULL) {\n            assert(vi.defFlag);\n            isnull = ctx.builder.CreateLoad(vi.defFlag, vi.isVolatile);\n        }\n        if (vi.boxroot != NULL) {\n            Value *boxed = ctx.builder.CreateLoad(vi.boxroot, vi.isVolatile);\n            Value *box_isnull = ctx.builder.CreateICmpNE(boxed, maybe_decay_untracked(V_null));\n            if (vi.pTIndex) {\n                // value is either boxed in the stack slot, or unboxed in value\n                // as indicated by testing (pTIndex & 0x80)\n                Value *tindex = ctx.builder.CreateLoad(vi.pTIndex, vi.isVolatile);\n                Value *load_unbox = ctx.builder.CreateICmpEQ(\n                            ctx.builder.CreateAnd(tindex, ConstantInt::get(T_int8, 0x80)),\n                            ConstantInt::get(T_int8, 0));\n                isnull = ctx.builder.CreateSelect(load_unbox, isnull, box_isnull);\n            }\n            else {\n                isnull = box_isnull;\n            }\n        }\n    }\n    else if (jl_is_expr(sym)) {\n        assert(((jl_expr_t*)sym)->head == static_parameter_sym && \"malformed isdefined expression\");\n        size_t i = jl_unbox_long(jl_exprarg(sym, 0)) - 1;\n        if (jl_svec_len(ctx.linfo->sparam_vals) > 0) {\n            jl_value_t *e = jl_svecref(ctx.linfo->sparam_vals, i);\n            if (!jl_is_typevar(e)) {\n                return mark_julia_const(jl_true);\n            }\n        }\n        assert(ctx.spvals_ptr != NULL);\n        Value *bp = ctx.builder.CreateConstInBoundsGEP1_32(\n                T_prjlvalue,\n                ctx.spvals_ptr,\n                i + sizeof(jl_svec_t) / sizeof(jl_value_t*));\n        Value *sp = tbaa_decorate(tbaa_const, ctx.builder.CreateLoad(bp));\n        isnull = ctx.builder.CreateICmpNE(emit_typeof(ctx, sp),\n            maybe_decay_untracked(literal_pointer_val(ctx, (jl_value_t*)jl_tvar_type)));\n    }\n    else {\n        jl_module_t *modu;\n        jl_sym_t *name;\n        if (jl_is_globalref(sym)) {\n            modu = jl_globalref_mod(sym);\n            name = jl_globalref_name(sym);\n        }\n        else {\n            assert(jl_is_symbol(sym) && \"malformed isdefined expression\");\n            modu = ctx.module;\n            name = (jl_sym_t*)sym;\n        }\n        jl_binding_t *bnd = jl_get_binding(modu, name);\n        if (bnd) {\n            if (bnd->value != NULL)\n                return mark_julia_const(jl_true);\n            Value *bp = julia_binding_gv(ctx, bnd);\n            Instruction *v = ctx.builder.CreateLoad(T_prjlvalue, bp);\n            tbaa_decorate(tbaa_binding, v);\n            isnull = ctx.builder.CreateICmpNE(v, maybe_decay_untracked(V_null));\n        }\n        else {\n            Value *v = ctx.builder.CreateCall(prepare_call(jlboundp_func), {\n                    literal_pointer_val(ctx, (jl_value_t*)modu),\n                    literal_pointer_val(ctx, (jl_value_t*)name)\n                });\n            isnull = ctx.builder.CreateICmpNE(v, ConstantInt::get(T_int32, 0));\n        }\n    }\n    return mark_julia_type(ctx, isnull, false, jl_bool_type);\n}\n\nstatic jl_cgval_t emit_varinfo(jl_codectx_t &ctx, jl_varinfo_t &vi, jl_sym_t *varname, jl_value_t *better_typ=NULL) {\n    jl_value_t *typ = better_typ ? better_typ : vi.value.typ;\n    jl_cgval_t v;\n    Value *isnull = NULL;\n    if (vi.boxroot == NULL || vi.pTIndex != NULL) {\n        if ((!vi.isVolatile && vi.isSA) || vi.isArgument || vi.value.constant || !vi.value.V) {\n            v = vi.value;\n            if (vi.pTIndex)\n                v.TIndex = ctx.builder.CreateLoad(T_int8, vi.pTIndex);\n        }\n        else {\n            // copy value to a non-mutable (non-volatile SSA) location\n            AllocaInst *varslot = cast<AllocaInst>(vi.value.V);\n            Type *T = varslot->getAllocatedType();\n            assert(!varslot->isArrayAllocation() && \"variables not expected to be VLA\");\n            AllocaInst *ssaslot = emit_static_alloca(ctx, T);\n            unsigned al = varslot->getAlignment();\n            if (al)\n                ssaslot->setAlignment(al);\n            if (vi.isVolatile) {\n                Value *unbox = ctx.builder.CreateLoad(vi.value.V, true);\n                ctx.builder.CreateStore(unbox, ssaslot);\n            }\n            else {\n#if JL_LLVM_VERSION >= 40000\n                const DataLayout &DL = jl_data_layout;\n#else\n                const DataLayout &DL = jl_ExecutionEngine->getDataLayout();\n#endif\n                uint64_t sz = DL.getTypeStoreSize(T);\n                emit_memcpy(ctx, ssaslot, tbaa_stack, vi.value, sz, al);\n            }\n            Value *tindex = NULL;\n            if (vi.pTIndex)\n                tindex = ctx.builder.CreateLoad(vi.pTIndex, vi.isVolatile);\n            v = mark_julia_slot(ssaslot, vi.value.typ, tindex, tbaa_stack);\n        }\n        if (vi.boxroot == NULL)\n            v = update_julia_type(ctx, v, typ);\n        if (vi.usedUndef) {\n            assert(vi.defFlag);\n            isnull = ctx.builder.CreateLoad(vi.defFlag, vi.isVolatile);\n        }\n    }\n    if (vi.boxroot != NULL) {\n        Instruction *boxed = ctx.builder.CreateLoad(vi.boxroot, vi.isVolatile);\n        Value *box_isnull;\n        if (vi.usedUndef)\n            box_isnull = ctx.builder.CreateICmpNE(boxed, maybe_decay_untracked(V_null));\n        maybe_mark_load_dereferenceable(boxed, vi.usedUndef || vi.pTIndex, typ);\n        if (vi.pTIndex) {\n            // value is either boxed in the stack slot, or unboxed in value\n            // as indicated by testing (pTIndex & 0x80)\n            Value *load_unbox = ctx.builder.CreateICmpEQ(\n                        ctx.builder.CreateAnd(v.TIndex, ConstantInt::get(T_int8, 0x80)),\n                        ConstantInt::get(T_int8, 0));\n            if (vi.usedUndef)\n                isnull = ctx.builder.CreateSelect(load_unbox, isnull, box_isnull);\n            if (v.V) { // v.V will be null if it is a union of all ghost values\n                v.V = ctx.builder.CreateSelect(load_unbox, emit_bitcast(ctx,\n                    decay_derived(v.V), boxed->getType()), decay_derived(boxed));\n            } else\n                v.V = boxed;\n            v.Vboxed = boxed;\n            v = update_julia_type(ctx, v, typ);\n        }\n        else {\n            v = mark_julia_type(ctx, boxed, true, typ);\n            if (vi.usedUndef)\n                isnull = box_isnull;\n        }\n    }\n    if (isnull)\n        undef_var_error_ifnot(ctx, isnull, varname);\n    return v;\n}\n\nstatic jl_cgval_t emit_local(jl_codectx_t &ctx, jl_value_t *slotload)\n{\n    size_t sl = jl_slot_number(slotload) - 1;\n    jl_varinfo_t &vi = ctx.slots[sl];\n    jl_sym_t *sym = slot_symbol(ctx, sl);\n    jl_value_t *typ = NULL;\n    if (jl_typeis(slotload, jl_typedslot_type)) {\n        // use the better type from inference for this load\n        typ = jl_typedslot_get_type(slotload);\n        if (jl_is_typevar(typ))\n            typ = ((jl_tvar_t*)typ)->ub;\n    }\n    return emit_varinfo(ctx, vi, sym, typ);\n}\n\nstatic void emit_vi_assignment_unboxed(jl_codectx_t &ctx, jl_varinfo_t &vi, Value *isboxed, jl_cgval_t rval_info)\n{\n    if (vi.usedUndef)\n        store_def_flag(ctx, vi, true);\n\n    if (!vi.value.constant) { // check that this is not a virtual store\n        assert(vi.value.ispointer() || (vi.pTIndex && vi.value.V == NULL));\n        // store value\n        if (vi.value.V == NULL) {\n            // all ghost values in destination - nothing to copy or store\n        }\n        else if (rval_info.constant || !rval_info.ispointer()) {\n            if (rval_info.isghost) {\n                // all ghost values in source - nothing to copy or store\n            }\n            else {\n                if (rval_info.typ != vi.value.typ && !vi.pTIndex && !rval_info.TIndex) {\n                    // isbits cast-on-assignment is invalid. this branch should be dead-code.\n                    CreateTrap(ctx.builder);\n                }\n                else {\n                    Value *dest = vi.value.V;\n                    if (vi.pTIndex)\n                        ctx.builder.CreateStore(UndefValue::get(cast<AllocaInst>(vi.value.V)->getAllocatedType()), vi.value.V);\n                    Type *store_ty = julia_type_to_llvm(rval_info.constant ? jl_typeof(rval_info.constant) : rval_info.typ);\n                    Type *dest_ty = store_ty->getPointerTo();\n                    if (dest_ty != dest->getType())\n                        dest = emit_bitcast(ctx, dest, dest_ty);\n                    tbaa_decorate(tbaa_stack, ctx.builder.CreateStore(\n                                      emit_unbox(ctx, store_ty, rval_info, rval_info.typ),\n                                      dest,\n                                      vi.isVolatile));\n                }\n            }\n        }\n        else {\n            if (vi.pTIndex == NULL) {\n                assert(jl_is_concrete_type(vi.value.typ));\n                // Sometimes we can get into situations where the LHS and RHS\n                // are the same slot. We're not allowed to memcpy in that case\n                // due to LLVM bugs.\n                // This check should probably mostly catch the relevant situations.\n                if (vi.value.V != rval_info.V) {\n                    Value *copy_bytes = ConstantInt::get(T_int32, jl_datatype_size(vi.value.typ));\n                    emit_memcpy(ctx, vi.value.V, tbaa_stack, rval_info, copy_bytes,\n                                jl_datatype_align(rval_info.typ), vi.isVolatile);\n                }\n            }\n            else {\n                emit_unionmove(ctx, vi.value.V, tbaa_stack, rval_info, isboxed, vi.isVolatile);\n            }\n        }\n    }\n    else {\n        assert(vi.pTIndex == NULL);\n    }\n}\n\nstatic void emit_phinode_assign(jl_codectx_t &ctx, ssize_t idx, jl_value_t *r)\n{\n    jl_value_t *ssavalue_types = (jl_value_t*)ctx.source->ssavaluetypes;\n    assert(jl_is_array(ssavalue_types));\n    jl_array_t *edges = (jl_array_t*)jl_fieldref_noalloc(r, 0);\n    jl_value_t *phiType = jl_array_ptr_ref(ssavalue_types, idx);\n    BasicBlock *BB = ctx.builder.GetInsertBlock();\n    auto InsertPt = BB->getFirstInsertionPt();\n    if (phiType == jl_bottom_type) {\n        return;\n    }\n    AllocaInst *dest = nullptr;\n    // N.B.: For any memory space, used as a phi,\n    // we need to emit space twice here. The reason for this is that\n    // phi nodes may be arguments of other phi nodes, so if we don't\n    // have two buffers, one may be overwritten before its value is\n    // used. Hopefully LLVM will be able to fold this back where legal.\n    if (jl_is_uniontype(phiType)) {\n        bool allunbox;\n        size_t min_align, nbytes;\n        dest = try_emit_union_alloca(ctx, ((jl_uniontype_t*)phiType), allunbox, min_align, nbytes);\n        Value *phi = try_emit_union_alloca(ctx, ((jl_uniontype_t*)phiType), allunbox, min_align, nbytes);\n        Value *ptr = NULL;\n        if (dest) {\n            PHINode *Tindex_phi = PHINode::Create(T_int8, jl_array_len(edges), \"tindex_phi\");\n            BB->getInstList().insert(InsertPt, Tindex_phi);\n            PHINode *ptr_phi = PHINode::Create(T_prjlvalue, jl_array_len(edges), \"ptr_phi\");\n            BB->getInstList().insert(InsertPt, ptr_phi);\n            Value *isboxed = ctx.builder.CreateICmpNE(\n                    ctx.builder.CreateAnd(Tindex_phi, ConstantInt::get(T_int8, 0x80)),\n                    ConstantInt::get(T_int8, 0));\n            ctx.builder.CreateMemCpy(phi, dest, nbytes, min_align, false);\n            ctx.builder.CreateLifetimeEnd(dest);\n            ptr = ctx.builder.CreateSelect(isboxed,\n                maybe_bitcast(ctx, decay_derived(ptr_phi), T_pint8),\n                maybe_bitcast(ctx, decay_derived(phi), T_pint8));\n            jl_cgval_t val = mark_julia_slot(ptr, phiType, Tindex_phi, tbaa_stack);\n            val.Vboxed = ptr_phi;\n            ctx.PhiNodes.push_back(std::make_tuple(val, BB, dest, ptr_phi, r));\n            ctx.SAvalues.at(idx) = val;\n            ctx.ssavalue_assigned.at(idx) = true;\n            return;\n        }\n        else if (allunbox) {\n            PHINode *Tindex_phi = PHINode::Create(T_int8, jl_array_len(edges), \"tindex_phi\");\n            BB->getInstList().insert(InsertPt, Tindex_phi);\n            jl_cgval_t val = mark_julia_slot(NULL, phiType, Tindex_phi, tbaa_stack);\n            ctx.PhiNodes.push_back(std::make_tuple(val, BB, dest, (PHINode*)NULL, r));\n            ctx.SAvalues.at(idx) = val;\n            ctx.ssavalue_assigned.at(idx) = true;\n            return;\n        }\n    }\n    bool isboxed;\n    Type *vtype = julia_type_to_llvm(phiType, &isboxed);\n    if (isboxed)\n        vtype = T_prjlvalue;\n    // The frontend should really not emit this, but we allow it\n    // for convenience.\n    if (type_is_ghost(vtype)) {\n        assert(jl_is_datatype(phiType) && ((jl_datatype_t*)phiType)->instance);\n        // Skip adding it to the PhiNodes list, since we didn't create one.\n        ctx.SAvalues.at(idx) = mark_julia_const(((jl_datatype_t*)phiType)->instance);\n        ctx.ssavalue_assigned.at(idx) = true;\n        return;\n    }\n    jl_cgval_t slot;\n    PHINode *value_phi = NULL;\n    if (vtype->isAggregateType()) {\n        dest = emit_static_alloca(ctx, vtype);\n        Value *phi = emit_static_alloca(ctx, vtype);\n        ctx.builder.CreateMemCpy(phi, dest, jl_datatype_size(phiType),\n            jl_datatype_align(phiType), false);\n        ctx.builder.CreateLifetimeEnd(dest);\n        slot = mark_julia_slot(phi, phiType, NULL, tbaa_stack);\n    }\n    else {\n        value_phi = PHINode::Create(vtype, jl_array_len(edges), \"value_phi\");\n        BB->getInstList().insert(InsertPt, value_phi);\n        slot = mark_julia_type(ctx, value_phi, isboxed, phiType);\n    }\n    ctx.PhiNodes.push_back(std::make_tuple(slot, BB, dest, value_phi, r));\n    ctx.SAvalues.at(idx) = slot;\n    ctx.ssavalue_assigned.at(idx) = true;\n    return;\n}\n\nstatic void emit_ssaval_assign(jl_codectx_t &ctx, ssize_t idx, jl_value_t *r)\n{\n    assert(!ctx.ssavalue_assigned.at(idx));\n    if (jl_is_phinode(r)) {\n        return emit_phinode_assign(ctx, idx, r);\n    }\n\n    jl_cgval_t slot;\n    if (jl_is_phicnode(r)) {\n        jl_varinfo_t &vi = ctx.phic_slots[idx];\n        slot = emit_varinfo(ctx, vi, jl_symbol(\"phic\"));\n    } else {\n        slot = emit_expr(ctx, r, idx); // slot could be a jl_value_t (unboxed) or jl_value_t* (ispointer)\n    }\n    if (slot.isboxed || slot.TIndex) {\n        // see if inference suggested a different type for the ssavalue than the expression\n        // e.g. sometimes the information is inconsistent after inlining getfield on a Tuple\n        jl_value_t *ssavalue_types = (jl_value_t*)ctx.source->ssavaluetypes;\n        if (jl_is_array(ssavalue_types)) {\n            jl_value_t *declType = jl_array_ptr_ref(ssavalue_types, idx);\n            if (declType != slot.typ) {\n                slot = update_julia_type(ctx, slot, declType);\n            }\n        }\n    }\n    ctx.SAvalues.at(idx) = slot; // now SAvalues[idx] contains the SAvalue\n    ctx.ssavalue_assigned.at(idx) = true;\n}\n\nstatic void emit_varinfo_assign(jl_codectx_t &ctx, jl_varinfo_t &vi, jl_cgval_t rval_info, jl_value_t *l=NULL) {\n    if (!vi.used)\n        return;\n\n    // convert rval-type to lval-type\n    jl_value_t *slot_type = vi.value.typ;\n    rval_info = convert_julia_type(ctx, rval_info, slot_type);\n    if (rval_info.typ == jl_bottom_type)\n        return;\n\n    // compute / store tindex info\n    if (vi.pTIndex) {\n        Value *tindex;\n        if (rval_info.TIndex) {\n            tindex = rval_info.TIndex;\n            if (!vi.boxroot)\n                tindex = ctx.builder.CreateAnd(tindex, ConstantInt::get(T_int8, 0x7f));\n        }\n        else {\n            assert(rval_info.isboxed || rval_info.constant);\n            tindex = compute_tindex_unboxed(ctx, rval_info, vi.value.typ);\n            if (vi.boxroot)\n                tindex = ctx.builder.CreateOr(tindex, ConstantInt::get(T_int8, 0x80));\n            else\n                rval_info.TIndex = tindex;\n        }\n        ctx.builder.CreateStore(tindex, vi.pTIndex, vi.isVolatile);\n    }\n\n    // store boxed variables\n    Value *isboxed = NULL;\n    if (vi.boxroot) {\n        Value *rval;\n        if (vi.pTIndex && rval_info.TIndex) {\n            ctx.builder.CreateStore(rval_info.TIndex, vi.pTIndex, vi.isVolatile);\n            isboxed = ctx.builder.CreateICmpNE(\n                    ctx.builder.CreateAnd(rval_info.TIndex, ConstantInt::get(T_int8, 0x80)),\n                    ConstantInt::get(T_int8, 0));\n            rval = maybe_decay_untracked(rval_info.Vboxed ? rval_info.Vboxed : V_null);\n            assert(!vi.value.constant);\n        }\n        else {\n            assert(!vi.pTIndex || rval_info.isboxed || rval_info.constant);\n            rval = maybe_decay_untracked(boxed(ctx, rval_info));\n        }\n        ctx.builder.CreateStore(maybe_decay_untracked(rval), vi.boxroot, vi.isVolatile);\n    }\n\n    // store unboxed variables\n    if (!vi.boxroot || (vi.pTIndex && rval_info.TIndex)) {\n        emit_vi_assignment_unboxed(ctx, vi, isboxed, rval_info);\n    }\n}\n\nstatic void emit_assignment(jl_codectx_t &ctx, jl_value_t *l, jl_value_t *r, ssize_t ssaval)\n{\n    assert(!jl_is_ssavalue(l));\n\n    jl_sym_t *s = NULL;\n    jl_binding_t *bnd = NULL;\n    Value *bp = NULL;\n    if (jl_is_symbol(l))\n        s = (jl_sym_t*)l;\n    else if (jl_is_globalref(l))\n        bp = global_binding_pointer(ctx, jl_globalref_mod(l), jl_globalref_name(l), &bnd, true); // now bp != NULL\n    else\n        assert(jl_is_slot(l));\n    if (bp == NULL && s != NULL)\n        bp = global_binding_pointer(ctx, ctx.module, s, &bnd, true);\n    if (bp != NULL) { // it's a global\n        assert(bnd);\n        Value *rval = mark_callee_rooted(boxed(ctx, emit_expr(ctx, r, ssaval)));\n        ctx.builder.CreateCall(prepare_call(jlcheckassign_func),\n                           { literal_pointer_val(ctx, bnd),\n                             rval });\n        // Global variable. Does not need debug info because the debugger knows about\n        // its memory location.\n        return;\n    }\n\n    int sl = jl_slot_number(l) - 1;\n    // it's a local variable\n    jl_varinfo_t &vi = ctx.slots[sl];\n    jl_cgval_t rval_info = emit_expr(ctx, r, ssaval);\n    emit_varinfo_assign(ctx, vi, rval_info, l);\n}\n\n// --- convert expression to code ---\n\nstatic jl_cgval_t emit_cfunction(jl_codectx_t &ctx, jl_value_t *output_type, const jl_cgval_t &fexpr, jl_value_t *rt, jl_svec_t *argt);\n\nstatic Value *emit_condition(jl_codectx_t &ctx, const jl_cgval_t &condV, const std::string &msg)\n{\n    bool isbool = (condV.typ == (jl_value_t*)jl_bool_type);\n    if (!isbool) {\n        if (condV.TIndex) {\n            // check whether this might be bool\n            isbool = jl_subtype((jl_value_t*)jl_bool_type, condV.typ);\n        }\n        emit_typecheck(ctx, condV, (jl_value_t*)jl_bool_type, msg);\n    }\n    if (isbool) {\n        Value *cond = emit_unbox(ctx, T_int8, condV, (jl_value_t*)jl_bool_type);\n        assert(cond->getType() == T_int8);\n        return ctx.builder.CreateXor(ctx.builder.CreateTrunc(cond, T_int1), ConstantInt::get(T_int1, 1));\n    }\n    if (condV.isboxed) {\n        return ctx.builder.CreateICmpEQ(boxed(ctx, condV),\n            maybe_decay_untracked(literal_pointer_val(ctx, jl_false)));\n    }\n    // not a boolean\n    return ConstantInt::get(T_int1, 0); // TODO: replace with Undef\n}\n\nstatic Value *emit_condition(jl_codectx_t &ctx, jl_value_t *cond, const std::string &msg)\n{\n    return emit_condition(ctx, emit_expr(ctx, cond), msg);\n}\n\nstatic void emit_stmtpos(jl_codectx_t &ctx, jl_value_t *expr, int ssaval_result)\n{\n    if (jl_is_ssavalue(expr) && ssaval_result == -1)\n        return; // value not used, no point in attempting codegen for it\n    if (jl_is_slot(expr) && ssaval_result == -1) {\n        size_t sl = jl_slot_number(expr) - 1;\n        jl_varinfo_t &vi = ctx.slots[sl];\n        if (vi.usedUndef)\n            (void)emit_expr(ctx, expr);\n        return;\n    }\n    if (jl_is_newvarnode(expr)) {\n        jl_value_t *var = jl_fieldref(expr, 0);\n        assert(jl_is_slot(var));\n        jl_varinfo_t &vi = ctx.slots[jl_slot_number(var)-1];\n        if (vi.usedUndef) {\n            // create a new uninitialized variable\n            Value *lv = vi.boxroot;\n            if (lv != NULL)\n                ctx.builder.CreateStore(maybe_decay_untracked(V_null), lv);\n            if (lv == NULL || vi.pTIndex != NULL)\n                store_def_flag(ctx, vi, false);\n        }\n        return;\n    }\n    if (!jl_is_expr(expr)) {\n        assert(ssaval_result != -1);\n        emit_ssaval_assign(ctx, ssaval_result, expr);\n        return;\n    }\n    jl_expr_t *ex = (jl_expr_t*)expr;\n    jl_value_t **args = (jl_value_t**)jl_array_data(ex->args);\n    jl_sym_t *head = ex->head;\n    if (head == meta_sym || head == inbounds_sym) {\n        // some expression types are metadata and can be ignored\n        // in statement position\n        return;\n    }\n    else if (head == leave_sym) {\n        assert(jl_is_long(args[0]));\n        ctx.builder.CreateCall(prepare_call(jlleave_func),\n                           ConstantInt::get(T_int32, jl_unbox_long(args[0])));\n    }\n    else {\n        if (!jl_is_method(ctx.linfo->def.method)) {\n            // TODO: inference is invalid if this has an effect\n            Value *world = ctx.builder.CreateLoad(prepare_global(jlgetworld_global));\n            ctx.builder.CreateStore(world, ctx.world_age_field);\n        }\n        assert(ssaval_result != -1);\n        emit_ssaval_assign(ctx, ssaval_result, expr);\n    }\n}\n\nstatic jl_cgval_t emit_expr(jl_codectx_t &ctx, jl_value_t *expr, ssize_t ssaval)\n{\n    if (jl_is_symbol(expr)) {\n        jl_sym_t *sym = (jl_sym_t*)expr;\n        return emit_global(ctx, sym);\n    }\n    if (jl_is_slot(expr)) {\n        return emit_local(ctx, expr);\n    }\n    if (jl_is_ssavalue(expr)) {\n        ssize_t idx = ((jl_ssavalue_t*)expr)->id - 1;\n        assert(idx >= 0);\n        if (!ctx.ssavalue_assigned.at(idx)) {\n            ctx.ssavalue_assigned.at(idx) = true; // (assignment, not comparison test)\n            return jl_cgval_t(); // dead code branch\n        }\n        else {\n            return ctx.SAvalues.at(idx); // at this point, SAvalues[idx] actually contains the SAvalue\n        }\n    }\n    if (jl_is_globalref(expr)) {\n        return emit_globalref(ctx, jl_globalref_mod(expr), jl_globalref_name(expr));\n    }\n    if (jl_is_linenode(expr)) {\n        jl_error(\"LineNumberNode in value position\");\n    }\n    if (jl_is_gotonode(expr)) {\n        jl_error(\"GotoNode in value position\");\n    }\n    if (jl_is_pinode(expr)) {\n        return convert_julia_type(ctx, emit_expr(ctx, jl_fieldref_noalloc(expr, 0)), jl_fieldref_noalloc(expr, 1));\n    }\n    if (!jl_is_expr(expr)) {\n        int needroot = true;\n        if (jl_is_quotenode(expr)) {\n            expr = jl_fieldref_noalloc(expr,0);\n        }\n        // numeric literals\n        if (jl_is_int32(expr)) {\n            int32_t val = jl_unbox_int32(expr);\n            if ((uint32_t)(val+512) < 1024) {\n                // this can be gotten from the box cache\n                needroot = false;\n                expr = jl_box_int32(val);\n            }\n        }\n        else if (jl_is_int64(expr)) {\n            uint64_t val = jl_unbox_uint64(expr);\n            if ((uint64_t)(val+512) < 1024) {\n                // this can be gotten from the box cache\n                needroot = false;\n                expr = jl_box_int64(val);\n            }\n        }\n        else if (jl_is_uint8(expr)) {\n            expr = jl_box_uint8(jl_unbox_uint8(expr));\n            needroot = false;\n        }\n        if (needroot && jl_is_method(ctx.linfo->def.method)) { // toplevel exprs and some integers are already rooted\n            jl_add_method_root(ctx, expr);\n        }\n        return mark_julia_const(expr);\n    }\n\n    jl_expr_t *ex = (jl_expr_t*)expr;\n    jl_value_t **args = (jl_value_t**)jl_array_data(ex->args);\n    jl_sym_t *head = ex->head;\n    // this is object-disoriented.\n    // however, this is a good way to do it because it should *not* be easy\n    // to add new node types.\n    if (head == isdefined_sym) {\n        return emit_isdefined(ctx, args[0]);\n    }\n    else if (head == throw_undef_if_not_sym) {\n        jl_sym_t *var = (jl_sym_t*)args[0];\n        Value *cond = ctx.builder.CreateTrunc(emit_unbox(ctx, T_int8, emit_expr(ctx, args[1]), (jl_value_t*)jl_bool_type), T_int1);\n        if (var == getfield_undefref_sym) {\n            raise_exception_unless(ctx, cond,\n                literal_pointer_val(ctx, jl_undefref_exception));\n        } else {\n            undef_var_error_ifnot(ctx, cond, var);\n        }\n        return ghostValue(jl_void_type);\n    }\n    else if (head == invoke_sym) {\n        assert(ssaval >= 0);\n        jl_value_t *expr_t = jl_is_long(ctx.source->ssavaluetypes) ? (jl_value_t*)jl_any_type :\n            jl_array_ptr_ref(ctx.source->ssavaluetypes, ssaval);\n        return emit_invoke(ctx, ex, expr_t);\n    }\n    else if (head == call_sym) {\n        jl_value_t *expr_t;\n        if (ssaval < 0)\n            // TODO: this case is needed for the call to emit_expr in emit_llvmcall\n            expr_t = (jl_value_t*)jl_any_type;\n        else\n            expr_t = jl_is_long(ctx.source->ssavaluetypes) ? (jl_value_t*)jl_any_type : jl_array_ptr_ref(ctx.source->ssavaluetypes, ssaval);\n        jl_cgval_t res = emit_call(ctx, ex, expr_t);\n        // some intrinsics (e.g. typeassert) can return a wider type\n        // than what's actually possible\n        res = update_julia_type(ctx, res, expr_t);\n        if (res.typ == jl_bottom_type || expr_t == jl_bottom_type) {\n            CreateTrap(ctx.builder);\n        }\n        return res;\n    }\n    else if (head == foreigncall_sym) {\n        return emit_ccall(ctx, args, jl_array_dim0(ex->args));\n    }\n    else if (head == cfunction_sym) {\n        jl_cgval_t fexpr_rt = emit_expr(ctx, args[1]);\n        return emit_cfunction(ctx, args[0], fexpr_rt, args[2], (jl_svec_t*)args[3]);\n    }\n    else if (head == assign_sym) {\n        emit_assignment(ctx, args[0], args[1], ssaval);\n        return ghostValue(jl_void_type);\n    }\n    else if (head == static_parameter_sym) {\n        return emit_sparam(ctx, jl_unbox_long(args[0]) - 1);\n    }\n    else if (head == method_sym) {\n        jl_value_t *mn = args[0];\n        assert(jl_expr_nargs(ex) != 1 || jl_is_symbol(mn) || jl_is_slot(mn));\n\n        Value *bp = NULL, *name, *bp_owner = V_null;\n        jl_binding_t *bnd = NULL;\n        bool issym = jl_is_symbol(mn);\n        bool isglobalref = !issym && jl_is_globalref(mn);\n        jl_module_t *mod = ctx.module;\n        if (issym || isglobalref) {\n            if (isglobalref) {\n                mod = jl_globalref_mod(mn);\n                mn = (jl_value_t*)jl_globalref_name(mn);\n            }\n            JL_TRY {\n                if (jl_symbol_name((jl_sym_t*)mn)[0] == '@')\n                    jl_errorf(\"macro definition not allowed inside a local scope\");\n                name = literal_pointer_val(ctx, mn);\n                bnd = jl_get_binding_for_method_def(mod, (jl_sym_t*)mn);\n            }\n            JL_CATCH {\n                jl_ptls_t ptls = jl_get_ptls_states();\n                jl_value_t *e = ptls->exception_in_transit;\n                // errors. boo. root it somehow :(\n                bnd = jl_get_binding_wr(ctx.module, (jl_sym_t*)jl_gensym(), 1);\n                bnd->value = e;\n                bnd->constp = 1;\n                raise_exception(ctx, literal_pointer_val(ctx, e));\n                return ghostValue(jl_void_type);\n            }\n            bp = julia_binding_gv(ctx, bnd);\n            bp_owner = literal_pointer_val(ctx, (jl_value_t*)mod);\n        }\n        else if (jl_is_slot(mn)) {\n            int sl = jl_slot_number(mn)-1;\n            jl_varinfo_t &vi = ctx.slots[sl];\n            bp = vi.boxroot;\n            name = literal_pointer_val(ctx, (jl_value_t*)slot_symbol(ctx, sl));\n        }\n        if (bp) {\n            Value *mdargs[5] = { name, literal_pointer_val(ctx, (jl_value_t*)mod), bp,\n                                 bp_owner, literal_pointer_val(ctx, bnd) };\n            jl_cgval_t gf = mark_julia_type(\n                    ctx,\n                    ctx.builder.CreateCall(prepare_call(jlgenericfunction_func), makeArrayRef(mdargs)),\n                    true,\n                    jl_function_type);\n            if (jl_expr_nargs(ex) == 1)\n                return gf;\n        }\n        Value *a1 = boxed(ctx, emit_expr(ctx, args[1]));\n        Value *a2 = boxed(ctx, emit_expr(ctx, args[2]));\n        Value *mdargs[3] = {\n            /*argdata*/a1,\n            /*code*/a2,\n            /*module*/literal_pointer_val(ctx, (jl_value_t*)ctx.module)\n        };\n        ctx.builder.CreateCall(prepare_call(jlmethod_func), makeArrayRef(mdargs));\n        return ghostValue(jl_void_type);\n    }\n    else if (head == const_sym) {\n        jl_sym_t *sym = (jl_sym_t*)args[0];\n        jl_module_t *mod = ctx.module;\n        if (jl_is_globalref(sym)) {\n            mod = jl_globalref_mod(sym);\n            sym = jl_globalref_name(sym);\n        }\n        if (jl_is_symbol(sym)) {\n            jl_binding_t *bnd = NULL;\n            (void)global_binding_pointer(ctx, mod, sym, &bnd, true); assert(bnd);\n            ctx.builder.CreateCall(prepare_call(jldeclareconst_func),\n                               literal_pointer_val(ctx, bnd));\n        }\n    }\n    else if (head == new_sym) {\n        size_t nargs = jl_array_len(ex->args);\n        jl_cgval_t *argv = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * nargs);\n        for (size_t i = 0; i < nargs; ++i) {\n            argv[i] = emit_expr(ctx, args[i]);\n        }\n        jl_value_t *ty = argv[0].typ;\n        if (jl_is_type_type(ty) &&\n                jl_is_datatype(jl_tparam0(ty)) &&\n                jl_is_concrete_type(jl_tparam0(ty))) {\n            assert(nargs <= jl_datatype_nfields(jl_tparam0(ty)) + 1);\n            return emit_new_struct(ctx, jl_tparam0(ty), nargs - 1, &argv[1]);\n        }\n        Value *typ = boxed(ctx, argv[0]);\n        Value *val = emit_jlcall(ctx, jlnew_func, typ, &argv[1], nargs - 1);\n        return mark_julia_type(ctx, val, true, ty);\n    }\n    else if (head == exc_sym) { // *ptls->exception_in_transit\n        return mark_julia_type(ctx,\n                ctx.builder.CreateLoad(emit_exc_in_transit(ctx), /*isvolatile*/true),\n                true, jl_any_type);\n    }\n    else if (head == copyast_sym) {\n        jl_cgval_t ast = emit_expr(ctx, args[0]);\n        if (ast.typ != (jl_value_t*)jl_expr_type && ast.typ != (jl_value_t*)jl_any_type) {\n            // elide call to jl_copy_ast when possible\n            return ast;\n        }\n        return mark_julia_type(ctx,\n                ctx.builder.CreateCall(prepare_call(jlcopyast_func),\n                    maybe_decay_untracked(boxed(ctx, ast))), true, jl_expr_type);\n    }\n    else if (head == simdloop_sym) {\n        jl_value_t *ivdep = args[0];\n        assert(jl_expr_nargs(ex) == 1 && jl_is_bool(ivdep));\n        if (ivdep == jl_false) {\n            ctx.builder.CreateCall(prepare_call(jl_simdloop_marker_func));\n        } else {\n            ctx.builder.CreateCall(prepare_call(jl_simdivdep_marker_func));\n        }\n        return jl_cgval_t();\n    }\n    else if (head == goto_ifnot_sym) {\n        jl_error(\"Expr(:goto_ifnot) in value position\");\n    }\n    else if (head == leave_sym) {\n        jl_error(\"Expr(:leave) in value position\");\n    }\n    else if (head == enter_sym) {\n        jl_error(\"Expr(:enter) in value position\");\n    }\n    else if (head == inbounds_sym) {\n        jl_error(\"Expr(:inbounds) in value position\");\n    }\n    else if (head == boundscheck_sym) {\n        return mark_julia_const(bounds_check_enabled(ctx, jl_true) ? jl_true : jl_false);\n    }\n    else if (head == gc_preserve_begin_sym) {\n        size_t nargs = jl_array_len(ex->args);\n        jl_cgval_t *argv = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * nargs);\n        for (size_t i = 0; i < nargs; ++i) {\n            argv[i] = emit_expr(ctx, args[i]);\n        }\n        size_t nargsboxed = 0;\n        Value **vals = (Value**)alloca(sizeof(Value *) * nargs);\n        for (size_t i = 0; i < nargs; ++i) {\n            if (!argv[i].isboxed) {\n                // This is intentionally not an error to allow writing\n                // generic code more easily.\n                continue;\n            } else if (argv[i].constant) {\n                continue;\n            }\n            vals[nargsboxed++] = argv[i].Vboxed;\n        }\n        Value *token = ctx.builder.CreateCall(prepare_call(gc_preserve_begin_func),\n            ArrayRef<Value*>(vals, nargsboxed));\n        jl_cgval_t tok(token, NULL, false, (jl_value_t*)jl_void_type, NULL);\n        return tok;\n    }\n    else if (head == gc_preserve_end_sym) {\n        // We only support ssa values as the argument. Everything else will\n        // fall back to the default behavior of preserving the argument value\n        // until the end of the scope, which is correct, but not optimal.\n        if (!jl_is_ssavalue(args[0])) {\n            return jl_cgval_t((jl_value_t*)jl_void_type);\n        }\n        jl_cgval_t token = emit_expr(ctx, args[0]);\n        assert(token.V->getType()->isTokenTy());\n        ctx.builder.CreateCall(prepare_call(gc_preserve_end_func), {token.V});\n        return jl_cgval_t((jl_value_t*)jl_void_type);\n    }\n    else {\n        if (jl_is_toplevel_only_expr(expr) &&\n            !jl_is_method(ctx.linfo->def.method)) {\n            // call interpreter to run a toplevel expr from inside a\n            // compiled toplevel thunk.\n            Value *args[2] = {\n                literal_pointer_val(ctx, (jl_value_t*)ctx.module),\n                literal_pointer_val(ctx, expr)\n            };\n            ctx.builder.CreateCall(prepare_call(jltopeval_func), args);\n            return ghostValue(jl_void_type);\n        }\n        if (head == abstracttype_sym || head == structtype_sym ||\n            head == primtype_sym) {\n            jl_errorf(\"type definition not allowed inside a local scope\");\n        }\n        else {\n            jl_errorf(\"unsupported or misplaced expression \\\"%s\\\" in function %s\",\n                      jl_symbol_name(head), ctx.name);\n        }\n    }\n    return jl_cgval_t();\n}\n\n// --- generate function bodies ---\n\n// gc frame emission\nstatic void allocate_gc_frame(jl_codectx_t &ctx, BasicBlock *b0)\n{\n    // TODO: requires the runtime, but is generated unconditionally\n\n    // allocate a placeholder gc instruction\n    ctx.ptlsStates = ctx.builder.CreateCall(prepare_call(jltls_states_func));\n    int nthfield = offsetof(jl_tls_states_t, safepoint) / sizeof(void*);\n    ctx.signalPage = emit_nthptr_recast(ctx, ctx.ptlsStates, nthfield, tbaa_const,\n                                        PointerType::get(T_psize, 0));\n}\n\nstatic void emit_last_age_field(jl_codectx_t &ctx)\n{\n    ctx.world_age_field = ctx.builder.CreateInBoundsGEP(\n            ctx.builder.CreateBitCast(ctx.ptlsStates, T_psize),\n            ConstantInt::get(T_size, offsetof(jl_tls_states_t, world_age) / sizeof(size_t)));\n}\n\nstatic void emit_cfunc_invalidate(\n        Function *gf_thunk, jl_returninfo_t::CallingConv cc,\n        jl_method_instance_t *lam, size_t nargs, size_t world)\n{\n    jl_codectx_t ctx(jl_LLVMContext);\n    ctx.f = gf_thunk;\n    ctx.world = world;\n    ctx.params = &jl_default_cgparams;\n\n    BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", gf_thunk);\n    ctx.builder.SetInsertPoint(b0);\n    DebugLoc noDbg;\n    ctx.builder.SetCurrentDebugLocation(noDbg);\n    allocate_gc_frame(ctx, b0);\n\n    Function::arg_iterator AI = gf_thunk->arg_begin();\n    jl_cgval_t *myargs = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * nargs);\n    if (cc == jl_returninfo_t::SRet || cc == jl_returninfo_t::Union)\n        ++AI;\n    for (size_t i = 0; i < nargs; i++) {\n        jl_value_t *jt = jl_nth_slot_type(lam->specTypes, i);\n        bool isboxed;\n        Type *et = julia_type_to_llvm(jt, &isboxed);\n        if (type_is_ghost(et)) {\n            assert(jl_is_datatype(jt) && ((jl_datatype_t*)jt)->instance);\n            myargs[i] = mark_julia_const(((jl_datatype_t*)jt)->instance);\n        }\n        else {\n            Value *arg_v = &*AI;\n            ++AI;\n            Type *at = arg_v->getType();\n            if (isboxed) {\n                assert(at == T_prjlvalue && et == T_pjlvalue);\n                myargs[i] = mark_julia_type(ctx, arg_v, true, jt);\n            }\n            else if (et->isAggregateType()) {\n                myargs[i] = mark_julia_slot(arg_v, jt, NULL, tbaa_const);\n            }\n            else {\n                assert(at == et);\n                myargs[i] = mark_julia_type(ctx, arg_v, false, jt);\n            }\n            (void)at;\n        }\n    }\n    assert(AI == gf_thunk->arg_end());\n    Value *gf_ret = emit_jlcall(ctx, jlapplygeneric_func, NULL, myargs, nargs);\n    jl_cgval_t gf_retbox = mark_julia_type(ctx, gf_ret, true, jl_any_type);\n    jl_value_t *astrt = lam->rettype;\n    if (cc != jl_returninfo_t::Boxed) {\n        emit_typecheck(ctx, gf_retbox, astrt, \"cfunction\");\n    }\n\n    switch (cc) {\n    case jl_returninfo_t::Boxed:\n        ctx.builder.CreateRet(gf_ret);\n        break;\n    case jl_returninfo_t::Register: {\n        Type *gfrt = gf_thunk->getReturnType();\n        if (gfrt->isVoidTy()) {\n            ctx.builder.CreateRetVoid();\n        }\n        else {\n            gf_ret = emit_bitcast(ctx, gf_ret, gfrt->getPointerTo());\n            ctx.builder.CreateRet(ctx.builder.CreateAlignedLoad(gf_ret, julia_alignment(astrt)));\n        }\n        break;\n    }\n    case jl_returninfo_t::SRet: {\n        emit_memcpy(ctx, &*gf_thunk->arg_begin(), nullptr, gf_ret, nullptr, jl_datatype_size(astrt), julia_alignment(astrt));\n        ctx.builder.CreateRetVoid();\n        break;\n    }\n    case jl_returninfo_t::Union: {\n        Type *retty = gf_thunk->getReturnType();\n        Value *gf_retval = UndefValue::get(retty);\n        Value *tindex = compute_box_tindex(ctx, gf_ret, (jl_value_t*)jl_any_type, astrt);\n        tindex = ctx.builder.CreateOr(tindex, ConstantInt::get(T_int8, 0x80));\n        gf_retval = ctx.builder.CreateInsertValue(gf_retval, gf_ret, 0);\n        gf_retval = ctx.builder.CreateInsertValue(gf_retval, tindex, 1);\n        ctx.builder.CreateRet(gf_retval);\n        break;\n    }\n    case jl_returninfo_t::Ghosts: {\n        Value *gf_retval = compute_tindex_unboxed(ctx, gf_retbox, astrt);\n        ctx.builder.CreateRet(gf_retval);\n        break;\n    }\n    }\n}\n\nstatic Function* gen_cfun_wrapper(\n    Module *into,\n    const function_sig_t &sig, jl_value_t *ff,\n    jl_typemap_entry_t *sf, jl_value_t *declrt, jl_tupletype_t *sigt,\n    jl_unionall_t *unionall_env, jl_svec_t *sparam_vals, jl_array_t **closure_types)\n{\n    // Generate a c-callable wrapper\n    size_t nargs = sig.nargs;\n    const char *name = \"cfunction\";\n    size_t world = jl_world_counter;\n    bool nest = (!ff || unionall_env);\n    // try to look up this function for direct invoking\n    jl_method_instance_t *lam = sigt ? jl_get_specialization1((jl_tupletype_t*)sigt, world, 1) : NULL;\n    jl_value_t *astrt = (jl_value_t*)jl_any_type;\n    // infer it first, if necessary\n    if (lam) {\n        name = jl_symbol_name(lam->def.method->name);\n        jl_code_info_t *src = NULL;\n        if (!into && !lam->inferred) // TODO: this isn't ideal to be unconditionally calling type inference from here\n            src = jl_type_infer(&lam, world, 0);\n        jl_compile_linfo(&lam, src, world, &jl_default_cgparams);\n        if (lam->functionObjectsDecls.specFunctionObject == NULL ||\n                !strcmp(lam->functionObjectsDecls.specFunctionObject, \"jl_fptr_sparam\")) {\n            lam = NULL; // TODO: use emit_invoke framework to dispatch these\n        }\n        if (lam) {\n            astrt = lam->rettype;\n            if (astrt != (jl_value_t*)jl_bottom_type &&\n                jl_type_intersection(astrt, declrt) == jl_bottom_type) {\n                // Do not warn if the function does not return since it is\n                // occasionally required by the C API (typically error callbacks)\n                // and doesn't capture the majority of the case when a function\n                // may throw.\n                jl_printf(JL_STDERR, \"WARNING: cfunction: return type of %s does not match\\n\", name);\n            }\n        }\n    }\n\n    std::stringstream funcName;\n    funcName << \"jlcapi_\" << name << \"_\" << globalUnique++;\n\n    Module *M = into;\n    if (!M) {\n        M = new Module(name, jl_LLVMContext);\n        jl_setup_module(M);\n    }\n#if JL_LLVM_VERSION >= 50000\n    AttributeList attributes = sig.attributes;\n#else\n    AttributeSet attributes = sig.attributes;\n#endif\n    FunctionType *functype;\n    if (nest) {\n        // add nest parameter (pointer to jl_value_t* data array) after sret arg\n        assert(closure_types);\n        std::vector<Type*> fargt_sig(sig.fargt_sig);\n        fargt_sig.insert(fargt_sig.begin() + sig.sret, T_pprjlvalue);\n        functype = FunctionType::get(sig.sret ? T_void : sig.prt, fargt_sig, sig.isVa);\n        attributes = attributes.addAttribute(jl_LLVMContext, 1 + sig.sret, Attribute::Nest);\n    }\n    else {\n        functype = sig.functype();\n    }\n    Function *cw = Function::Create(functype,\n            GlobalVariable::ExternalLinkage,\n            funcName.str(), M);\n    jl_init_function(cw);\n    cw->setAttributes(attributes);\n#ifdef JL_DISABLE_FPO\n    cw->addFnAttr(\"no-frame-pointer-elim\", \"true\");\n#endif\n    Function *cw_proto = into ? cw : function_proto(cw);\n    // Save the Function object reference\n    if (sf) {\n        jl_value_t *oldsf = sf->func.value;\n        size_t i, oldlen = jl_svec_len(oldsf);\n        jl_value_t *newsf = (jl_value_t*)jl_alloc_svec(oldlen + 2);\n        JL_GC_PUSH1(&newsf);\n        jl_svecset(newsf, 0, sig.rt);\n        jl_svecset(newsf, 1, jl_box_voidpointer((void*)cw_proto));\n        for (i = 0; i < oldlen; i++)\n            jl_svecset(newsf, i + 2, jl_svecref(oldsf, i));\n        sf->func.value = newsf;\n        jl_gc_wb(sf, sf->func.value);\n        JL_GC_POP();\n    }\n\n    jl_codectx_t ctx(jl_LLVMContext);\n    ctx.f = cw;\n    ctx.linfo = lam;\n    ctx.world = world;\n    ctx.params = &jl_default_cgparams;\n    ctx.name = name;\n    ctx.funcName = name;\n\n    BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", cw);\n    ctx.builder.SetInsertPoint(b0);\n    DebugLoc noDbg;\n    ctx.builder.SetCurrentDebugLocation(noDbg);\n    allocate_gc_frame(ctx, b0);\n    emit_last_age_field(ctx);\n\n    Value *dummy_world = ctx.builder.CreateAlloca(T_size);\n    Value *have_tls = ctx.builder.CreateIsNotNull(ctx.ptlsStates);\n    // TODO: in the future, try to initialize a full TLS context here\n    // for now, just use a dummy field to avoid a branch in this function\n    ctx.world_age_field = ctx.builder.CreateSelect(have_tls, ctx.world_age_field, dummy_world);\n    Value *last_age = tbaa_decorate(tbaa_gcframe, ctx.builder.CreateLoad(ctx.world_age_field));\n    have_tls = ctx.builder.CreateAnd(have_tls, ctx.builder.CreateIsNotNull(last_age));\n    Value *world_v = ctx.builder.CreateLoad(prepare_global(jlgetworld_global));\n\n    Value *age_ok = NULL;\n    if (lam) {\n        Value *lam_max = ctx.builder.CreateLoad(\n                T_size,\n                ctx.builder.CreateConstInBoundsGEP1_32(\n                    T_size,\n                    emit_bitcast(ctx, literal_pointer_val(ctx, (jl_value_t*)lam), T_psize),\n                    offsetof(jl_method_instance_t, max_world) / sizeof(size_t)));\n        // XXX: age is always OK if we don't have a TLS. This is a hack required due to `@threadcall` abuse.\n        // and adds quite a bit of complexity here, even though it's still wrong\n        // (anything that tries to interact with the runtime will fault)\n        age_ok = ctx.builder.CreateICmpUGE(lam_max, world_v);\n        world_v = ctx.builder.CreateSelect(ctx.builder.CreateOr(have_tls, age_ok), world_v, lam_max);\n        age_ok = ctx.builder.CreateOr(ctx.builder.CreateNot(have_tls), age_ok);\n    }\n    ctx.builder.CreateStore(world_v, ctx.world_age_field);\n\n    // first emit code to record the arguments\n    Function::arg_iterator AI = cw->arg_begin();\n    Value *sretPtr = sig.sret ? &*AI++ : NULL;\n    Value *nestPtr = nest ? &*AI++ : NULL;\n    jl_cgval_t *inputargs = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * (nargs + 1));\n    if (ff) {\n        // we need to pass the function object even if (even though) it is a singleton\n        inputargs[0] = mark_julia_const(ff);\n    }\n    else {\n        assert(nest && nestPtr);\n        Value *ff = ctx.builder.CreateLoad(T_prjlvalue, nestPtr);\n        inputargs[0] = mark_julia_type(ctx, ff, true, jl_any_type);\n    }\n    // XXX: these values may need to be rooted until the end of the function\n    jl_value_t *rt1 = NULL;\n    jl_value_t *rt2 = NULL;\n    JL_GC_PUSH2(&rt1, &rt2);\n    for (size_t i = 0; i < nargs; ++i, ++AI) {\n        // figure out how to unpack this argument type\n        Value *val = &*AI;\n        assert(sig.fargt_sig.at(i + sig.sret) == val->getType());\n        jl_cgval_t &inputarg = inputargs[i + 1];\n        jl_value_t *jargty = jl_svecref(sig.at, i);\n        bool aref = jl_is_abstract_ref_type(jargty);\n        if (aref) // a pointer to a value\n            jargty = jl_tparam0(jargty);\n\n        // if we know the outer function sparams, try to fill those in now\n        // so that the julia_to_native type checks are more likely to be doable (e.g. concrete types) at compile-time\n        jl_value_t *jargty_proper = jargty;\n        bool static_at = !(unionall_env && jl_has_typevar_from_unionall(jargty, unionall_env));\n        if (!static_at) {\n            if (sparam_vals) {\n                jargty_proper = rt1 = jl_instantiate_type_in_env(jargty, unionall_env, jl_svec_data(sparam_vals));\n                assert(jargty_proper != jargty);\n                jargty = jargty_proper;\n                static_at = true;\n            }\n            else {\n                jargty_proper = rt1 = jl_rewrap_unionall(jargty, (jl_value_t*)unionall_env);\n            }\n        }\n\n        if (aref) {\n            if (jargty == (jl_value_t*)jl_any_type) {\n                inputarg = mark_julia_type(ctx,\n                        ctx.builder.CreateLoad(emit_bitcast(ctx, val, T_pprjlvalue)),\n                        true, jl_any_type);\n            }\n            else if (static_at && jl_justbits(jargty)) { // anything that can be stored unboxed\n                bool isboxed;\n                Type *T = julia_type_to_llvm(jargty, &isboxed);\n                assert(!isboxed);\n                // a T* (of unknown origin)\n                if (type_is_ghost(T)) {\n                    inputarg = ghostValue(jargty);\n                }\n                else {\n                    val = emit_bitcast(ctx, val, T->getPointerTo());\n                    val = ctx.builder.CreateAlignedLoad(val, 1); // make no alignment assumption about pointer from C\n                    inputarg = mark_julia_type(ctx, val, false, jargty);\n                }\n            }\n            else if (static_at || (!jl_is_typevar(jargty) && !jl_is_immutable_datatype(jargty))) {\n                // must be a jl_value_t* (because it's mutable or contains gc roots)\n                inputarg = mark_julia_type(ctx, maybe_decay_untracked(emit_bitcast(ctx, val, T_prjlvalue)), true, jargty_proper);\n            }\n            else {\n                // allocate val into a new box, if it might not be boxed\n                // otherwise preserve / reuse the existing box identity\n                // TODO: could inspect `jargty` and eliminate some of these cases\n                if (!*closure_types)\n                    *closure_types = jl_alloc_vec_any(0);\n                jl_array_ptr_1d_push(*closure_types, jargty);\n                Value *runtime_dt = ctx.builder.CreateLoad(T_prjlvalue,\n                        ctx.builder.CreateConstGEP1_32(T_prjlvalue, nestPtr, jl_array_len(*closure_types)));\n                BasicBlock *boxedBB = BasicBlock::Create(jl_LLVMContext, \"isboxed\", cw);\n                BasicBlock *loadBB = BasicBlock::Create(jl_LLVMContext, \"need-load\", cw);\n                BasicBlock *unboxedBB = BasicBlock::Create(jl_LLVMContext, \"maybe-unboxed\", cw);\n                BasicBlock *isanyBB = BasicBlock::Create(jl_LLVMContext, \"any\", cw);\n                BasicBlock *afterBB = BasicBlock::Create(jl_LLVMContext, \"after\", cw);\n                Value *isrtboxed = ctx.builder.CreateIsNull(val);\n                ctx.builder.CreateCondBr(isrtboxed, boxedBB, loadBB);\n                ctx.builder.SetInsertPoint(boxedBB);\n                Value *p1 = ctx.builder.CreateBitCast(val, T_pjlvalue);\n                p1 = maybe_decay_untracked(p1);\n                ctx.builder.CreateBr(afterBB);\n                ctx.builder.SetInsertPoint(loadBB);\n                Value *isrtany = ctx.builder.CreateICmpEQ(\n                        literal_pointer_val(ctx, (jl_value_t*)jl_any_type),\n                        ctx.builder.CreateBitCast(val, T_pjlvalue));\n                ctx.builder.CreateCondBr(isrtany, isanyBB, unboxedBB);\n                ctx.builder.SetInsertPoint(isanyBB);\n                Value *p2 = ctx.builder.CreateLoad(T_prjlvalue, ctx.builder.CreateBitCast(val, T_pprjlvalue));\n                ctx.builder.CreateBr(afterBB);\n                ctx.builder.SetInsertPoint(unboxedBB);\n                Value *p3 = emit_new_bits(ctx, runtime_dt, val);\n                ctx.builder.CreateBr(afterBB);\n                ctx.builder.SetInsertPoint(afterBB);\n                PHINode *p = ctx.builder.CreatePHI(T_prjlvalue, 3);\n                p->addIncoming(p1, boxedBB);\n                p->addIncoming(p2, isanyBB);\n                p->addIncoming(p3, unboxedBB);\n                inputarg = mark_julia_type(ctx, p, true, jargty_proper);\n            }\n        }\n        else {\n            bool argboxed = sig.fargt_isboxed.at(i);\n            if (argboxed) {\n                // a jl_value_t*, even when represented as a struct\n                inputarg = mark_julia_type(ctx, val, true, jargty_proper);\n            }\n            else {\n                // something of type T\n                // undo whatever we might have done to this poor argument\n                assert(jl_is_datatype(jargty));\n                if (sig.byRefList.at(i)) {\n                    assert(cast<PointerType>(val->getType())->getElementType() == sig.fargt[i]);\n                    val = ctx.builder.CreateAlignedLoad(val, 1); // unknown alignment from C\n                }\n                else {\n                    bool issigned = jl_signed_type && jl_subtype(jargty_proper, (jl_value_t*)jl_signed_type);\n                    val = llvm_type_rewrite(ctx, val, sig.fargt[i], issigned);\n                }\n                // passed an unboxed T, but may need something boxed (not valid to be unboxed)\n                if (static_at) {\n                    bool isboxed;\n                    assert(jargty == jargty_proper);\n                    (void)julia_type_to_llvm(jargty, &isboxed);\n                    if (isboxed)\n                        inputarg = mark_julia_type(ctx,\n                                box_ccall_result(ctx, val, literal_pointer_val(ctx, jargty), jargty),\n                                true, jargty_proper);\n                    else\n                        inputarg = mark_julia_type(ctx, val, false, jargty);\n                }\n                else {\n                    if (!*closure_types)\n                        *closure_types = jl_alloc_vec_any(0);\n                    jl_array_ptr_1d_push(*closure_types, jargty);\n                    Value *runtime_dt = ctx.builder.CreateLoad(T_prjlvalue,\n                            ctx.builder.CreateConstGEP1_32(T_prjlvalue, nestPtr, jl_array_len(*closure_types)));\n                    Value *strct = box_ccall_result(ctx, val, runtime_dt, jargty);\n                    inputarg = mark_julia_type(ctx, strct, true, jargty_proper);\n                }\n            }\n        }\n    }\n    JL_GC_POP();\n    assert(AI == cw->arg_end());\n\n    // Create the call\n    bool jlfunc_sret;\n    jl_cgval_t retval;\n    if (lam && lam->invoke == jl_fptr_const_return) {\n        nargs = 0; // arguments not needed -- TODO: not really true, should emit an age_ok test and jlcall\n        jlfunc_sret = false;\n        retval = mark_julia_const(lam->inferred_const);\n    }\n    else if (!lam || !lam->functionObjectsDecls.functionObject ||\n            !strcmp(lam->functionObjectsDecls.functionObject, \"jl_fptr_args\") ||\n            !strcmp(lam->functionObjectsDecls.functionObject, \"jl_fptr_sparam\")) {\n        // emit a jlcall\n        jlfunc_sret = false;\n        Function *theFptr = NULL;\n        if (lam && lam->functionObjectsDecls.functionObject) {\n            if (!strcmp(lam->functionObjectsDecls.functionObject, \"jl_fptr_args\")) {\n                const char *fname = lam->functionObjectsDecls.specFunctionObject;\n                theFptr = cast_or_null<Function>(jl_Module->getNamedValue(fname));\n                if (!theFptr) {\n                    theFptr = Function::Create(jl_func_sig, GlobalVariable::ExternalLinkage,\n                                               fname, jl_Module);\n                }\n                else {\n                    assert(theFptr->getFunctionType() == jl_func_sig);\n                }\n                add_return_attr(theFptr, Attribute::NonNull);\n                theFptr->addFnAttr(Thunk);\n            }\n        }\n        BasicBlock *b_generic, *b_jlcall, *b_after;\n        Value *ret_jlcall;\n        if (age_ok) {\n            assert(theFptr);\n            b_generic = BasicBlock::Create(jl_LLVMContext, \"generic\", cw);\n            b_jlcall = BasicBlock::Create(jl_LLVMContext, \"apply\", cw);\n            b_after = BasicBlock::Create(jl_LLVMContext, \"after\", cw);\n            ctx.builder.CreateCondBr(age_ok, b_jlcall, b_generic);\n            ctx.builder.SetInsertPoint(b_jlcall);\n            // for jlcall, we need to pass the function object even if it is a ghost.\n            Value *theF = boxed(ctx, inputargs[0]);\n            assert(theF);\n            ret_jlcall = emit_jlcall(ctx, theFptr, theF, &inputargs[1], nargs);\n            ctx.builder.CreateBr(b_after);\n            ctx.builder.SetInsertPoint(b_generic);\n        }\n        Value *ret = emit_jlcall(ctx, prepare_call(jlapplygeneric_func), NULL, inputargs, nargs + 1);\n        if (age_ok) {\n            ctx.builder.CreateBr(b_after);\n            ctx.builder.SetInsertPoint(b_after);\n            PHINode *retphi = ctx.builder.CreatePHI(T_prjlvalue, 2);\n            retphi->addIncoming(ret_jlcall, b_jlcall);\n            retphi->addIncoming(ret, b_generic);\n            ret = retphi;\n        }\n        retval = mark_julia_type(ctx, ret, true, astrt);\n    }\n    else {\n        // emit a specsig call\n        const char *protoname = lam->functionObjectsDecls.specFunctionObject;\n        jl_returninfo_t returninfo = get_specsig_function(M, protoname, lam->specTypes, lam->rettype);\n        FunctionType *cft = returninfo.decl->getFunctionType();\n        jlfunc_sret = (returninfo.cc == jl_returninfo_t::SRet);\n\n        std::vector<Value*> args;\n        Value *result;\n        if (jlfunc_sret || returninfo.cc == jl_returninfo_t::Union) {\n            // fuse the two sret together, or emit an alloca to hold it\n            if (sig.sret && jlfunc_sret)\n                result = emit_bitcast(ctx, sretPtr, cft->getParamType(0));\n            else\n                result = emit_static_alloca(ctx, cft->getParamType(0)->getContainedType(0));\n            args.push_back(result);\n        }\n        for (size_t i = 0; i < nargs + 1; i++) {\n            // figure out how to repack the arguments\n            const jl_cgval_t &inputarg = inputargs[i];\n            Value *arg;\n            jl_value_t *spect = jl_nth_slot_type(lam->specTypes, i);\n            bool isboxed;\n            Type *T = julia_type_to_llvm(spect, &isboxed);\n            if (isboxed) {\n                arg = boxed(ctx, inputarg);\n            }\n            else if (type_is_ghost(T)) {\n                continue; // ghost types are skipped by the specsig method signature\n            }\n            else if (T->isAggregateType()) {\n                // aggregate types are passed by pointer\n                arg = maybe_bitcast(ctx, decay_derived(data_pointer(ctx, inputarg)),\n                    T->getPointerTo());\n            }\n            else {\n                arg = emit_unbox(ctx, T, inputarg, spect);\n                assert(!isa<UndefValue>(arg));\n            }\n\n            // add to argument list\n            args.push_back(arg);\n        }\n        Value *theFptr = returninfo.decl;\n        assert(theFptr);\n        if (age_ok) {\n            funcName << \"_gfthunk\";\n            Function *gf_thunk = Function::Create(returninfo.decl->getFunctionType(),\n                    GlobalVariable::InternalLinkage, funcName.str(), M);\n            jl_init_function(gf_thunk);\n            gf_thunk->setAttributes(returninfo.decl->getAttributes());\n#ifdef JL_DISABLE_FPO\n            gf_thunk->addFnAttr(\"no-frame-pointer-elim\", \"true\");\n#endif\n            // build a  specsig -> jl_apply_generic converter thunk\n            // this builds a method that calls jl_apply_generic (as a closure over a singleton function pointer),\n            // but which has the signature of a specsig\n            emit_cfunc_invalidate(gf_thunk, returninfo.cc, lam, nargs + 1, world);\n            theFptr = ctx.builder.CreateSelect(age_ok, theFptr, gf_thunk);\n        }\n        CallInst *call = ctx.builder.CreateCall(theFptr, ArrayRef<Value*>(args));\n        call->setAttributes(returninfo.decl->getAttributes());\n        switch (returninfo.cc) {\n            case jl_returninfo_t::Boxed:\n                retval = mark_julia_type(ctx, call, true, astrt);\n                break;\n            case jl_returninfo_t::Register:\n                retval = mark_julia_type(ctx, call, false, astrt);\n                break;\n            case jl_returninfo_t::SRet:\n                retval = mark_julia_slot(result, astrt, NULL, tbaa_stack);\n                break;\n            case jl_returninfo_t::Union:\n                retval = mark_julia_slot(ctx.builder.CreateExtractValue(call, 0),\n                                         astrt,\n                                         ctx.builder.CreateExtractValue(call, 1),\n                                         tbaa_stack);\n                // note that the value may not be rooted here (on the return path)\n                break;\n            case jl_returninfo_t::Ghosts:\n                retval = mark_julia_slot(NULL, astrt, call, tbaa_stack);\n                break;\n        }\n    }\n\n    // inline a call to typeassert here, if required\n    emit_typecheck(ctx, retval, declrt, \"cfunction\");\n    retval = update_julia_type(ctx, retval, declrt);\n\n    // Prepare the return value\n    Value *r;\n    if (sig.retboxed) {\n        assert(!sig.sret);\n        // return a jl_value_t*\n        r = boxed(ctx, retval);\n    }\n    else if (sig.sret && jlfunc_sret) {\n        // nothing to do\n        r = NULL;\n    }\n    else if (!type_is_ghost(sig.lrt)) {\n        Type *prt = sig.prt;\n        if (sig.sret)\n            prt = sig.fargt_sig[0]->getContainedType(0); // sret is a PointerType\n        bool issigned = jl_signed_type && jl_subtype(declrt, (jl_value_t*)jl_signed_type);\n        Value *v = emit_unbox(ctx, sig.lrt, retval, retval.typ);\n        r = llvm_type_rewrite(ctx, v, prt, issigned);\n        if (sig.sret) {\n            ctx.builder.CreateStore(r, sretPtr);\n            r = NULL;\n        }\n    }\n    else {\n        r = NULL;\n    }\n\n    ctx.builder.CreateStore(last_age, ctx.world_age_field);\n    ctx.builder.CreateRet(r);\n\n    ctx.builder.SetCurrentDebugLocation(noDbg);\n    ctx.builder.ClearInsertionPoint();\n\n    if (nest) {\n        funcName << \"make\";\n        Function *cw_make = Function::Create(\n                FunctionType::get(T_pint8, { T_pint8, T_ppjlvalue }, false),\n                GlobalVariable::ExternalLinkage,\n                funcName.str(), M);\n        jl_init_function(cw_make);\n#ifdef JL_DISABLE_FPO\n        cw_make->addFnAttr(\"no-frame-pointer-elim\", \"true\");\n#endif\n        BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", cw_make);\n        IRBuilder<> cwbuilder(b0);\n        Function::arg_iterator AI = cw_make->arg_begin();\n        Argument *Tramp = &*AI; ++AI;\n        Argument *NVal = &*AI; ++AI;\n        Function *init_trampoline = Intrinsic::getDeclaration(cw_make->getParent(), Intrinsic::init_trampoline);\n        Function *adjust_trampoline = Intrinsic::getDeclaration(cw_make->getParent(), Intrinsic::adjust_trampoline);\n        cwbuilder.CreateCall(init_trampoline, {\n                Tramp,\n                cwbuilder.CreateBitCast(cw, T_pint8),\n                cwbuilder.CreateBitCast(NVal, T_pint8)\n            });\n        cwbuilder.CreateRet(cwbuilder.CreateCall(adjust_trampoline, { Tramp }));\n        cw_proto = into ? cw_make : function_proto(cw_make);\n    }\n\n    if (!into)\n        jl_finalize_module(M, true);\n\n    return cw_proto;\n}\n\n// Get the LLVM Function* for the C-callable entry point for a certain function\n// and argument types.\n// here argt does not include the leading function type argument\nstatic jl_cgval_t emit_cfunction(jl_codectx_t &ctx, jl_value_t *output_type, const jl_cgval_t &fexpr_rt, jl_value_t *declrt, jl_svec_t *argt)\n{\n    jl_unionall_t *unionall_env = (jl_is_method(ctx.linfo->def.method) && jl_is_unionall(ctx.linfo->def.method->sig))\n        ? (jl_unionall_t*)ctx.linfo->def.method->sig\n        : NULL;\n    jl_svec_t *sparam_vals = NULL;\n    if (ctx.spvals_ptr == NULL && jl_svec_len(ctx.linfo->sparam_vals) > 0)\n        sparam_vals = ctx.linfo->sparam_vals;\n\n    jl_value_t *rt = declrt;\n    if (jl_is_abstract_ref_type(declrt)) {\n        declrt = jl_tparam0(declrt);\n        if (!verify_ref_type(ctx, declrt, unionall_env, 0, \"cfunction\")) {\n            return jl_cgval_t();\n        }\n        if (unionall_env)\n            declrt = jl_rewrap_unionall(declrt, (jl_value_t*)unionall_env);\n        rt = (jl_value_t*)jl_any_type; // convert return type to jl_value_t*\n    }\n\n    // some sanity checking and check whether there's a vararg\n    jl_array_t *closure_types = NULL;\n    jl_value_t *sigt = NULL; // dispatch-sig = type signature with Ref{} annotations removed and applied to the env\n    JL_GC_PUSH4(&declrt, &sigt, &rt, &closure_types);\n    bool isVa;\n    size_t nargt;\n    Type *lrt;\n    bool retboxed;\n    bool static_rt;\n    const std::string err = verify_ccall_sig(\n            /* inputs:  */\n            0, rt, (jl_value_t*)argt, unionall_env,\n            sparam_vals,\n            \"cfunction\",\n            /* outputs: */\n            nargt, isVa, lrt, retboxed, static_rt);\n    if (!err.empty()) {\n        emit_error(ctx, \"cfunction \" + err);\n        JL_GC_POP();\n        return jl_cgval_t();\n    }\n    if (rt != declrt && rt != (jl_value_t*)jl_any_type)\n        jl_add_method_root(ctx, rt);\n\n    function_sig_t sig(\"cfunction\", lrt, rt, retboxed, argt, unionall_env, nargt, isVa, CallingConv::C, false);\n    if (sig.err_msg.empty() && (sig.isVa || sig.fargt.size() + sig.sret != sig.fargt_sig.size()))\n        sig.err_msg = \"cfunction: Vararg syntax not allowed for argument list\";\n    if (!sig.err_msg.empty()) {\n        emit_error(ctx, sig.err_msg);\n        JL_GC_POP();\n        return jl_cgval_t();\n    }\n\n    // compute+verify the dispatch signature, and see if it depends on the environment sparams\n    bool approx = false;\n    sigt = (jl_value_t*)jl_alloc_svec(nargt + 1);\n    jl_svecset(sigt, 0, fexpr_rt.typ);\n    if (!fexpr_rt.constant && (!jl_is_concrete_type(fexpr_rt.typ) || jl_is_kind(fexpr_rt.typ)))\n        approx = true;\n    for (size_t i = 0; i < nargt; i++) {\n        jl_value_t *jargty = jl_svecref(argt, i);\n        if (jl_is_abstract_ref_type(jargty)) {\n            jargty = jl_tparam0(jargty);\n            if (!verify_ref_type(ctx, jargty, unionall_env, i + 1, \"cfunction\")) {\n                JL_GC_POP();\n                return jl_cgval_t();\n            }\n        }\n        if (unionall_env && jl_has_typevar_from_unionall(jargty, unionall_env)) {\n            if (sparam_vals)\n                jargty = jl_instantiate_type_in_env(jargty, unionall_env, jl_svec_data(sparam_vals));\n            else\n                approx = true;\n        }\n        jl_svecset(sigt, i + 1, jargty);\n    }\n    if (approx) {\n        sigt = NULL;\n    }\n    else {\n        sigt = (jl_value_t*)jl_apply_tuple_type((jl_svec_t*)sigt);\n    }\n    if (sigt && !(unionall_env && jl_has_typevar_from_unionall(rt, unionall_env))) {\n        unionall_env = NULL;\n    }\n\n    bool nest = (!fexpr_rt.constant || unionall_env);\n    Value *F = gen_cfun_wrapper(\n            jl_Module,\n            sig, fexpr_rt.constant,\n            NULL, declrt, (jl_tupletype_t*)sigt,\n            unionall_env, sparam_vals, &closure_types);\n    bool outboxed;\n    if (nest) {\n        // F is actually an init_trampoline function that returns the real address\n        // Now fill in the nest parameters\n        Value *fobj = boxed(ctx, fexpr_rt);\n        jl_svec_t *fill = jl_emptysvec;\n        if (closure_types) {\n            assert(ctx.spvals_ptr);\n            size_t n = jl_array_len(closure_types);\n            jl_svec_t *fill = jl_alloc_svec_uninit(n);\n            for (size_t i = 0; i < n; i++) {\n                jl_svecset(fill, i, jl_array_ptr_ref(closure_types, i));\n            }\n            jl_add_method_root(ctx, (jl_value_t*)fill);\n        }\n        std::stringstream cname;\n        cname << \"trampolines\" << globalUnique++;\n        Type *T_htable = ArrayType::get(T_size, sizeof(htable_t) / sizeof(void*));\n        Value *cache = new GlobalVariable(*jl_Module, T_htable, false,\n                               GlobalVariable::InternalLinkage,\n                               ConstantAggregateZero::get(T_htable),\n                               cname.str());\n        F = ctx.builder.CreateCall(prepare_call(jlgetcfunctiontrampoline_func), {\n                 fobj,\n                 literal_pointer_val(ctx, output_type),\n                 ctx.builder.CreateBitCast(cache, T_pint8),\n                 literal_pointer_val(ctx, (jl_value_t*)fill),\n                 F,\n                 closure_types ? literal_pointer_val(ctx, (jl_value_t*)unionall_env) : V_null,\n                 closure_types ? ctx.spvals_ptr : ConstantPointerNull::get(cast<PointerType>(T_pprjlvalue))\n             });\n        outboxed = true;\n    }\n    else {\n        F = ctx.builder.CreatePtrToInt(F, T_size);\n        outboxed = (output_type != (jl_value_t*)jl_voidpointer_type);\n        if (outboxed) {\n            assert(jl_datatype_size(output_type) == sizeof(void*) * 4);\n            Value *strct = emit_allocobj(ctx, jl_datatype_size(output_type),\n                                         literal_pointer_val(ctx, (jl_value_t*)output_type));\n            Value *derived_strct = emit_bitcast(ctx, decay_derived(strct), T_psize);\n            MDNode *tbaa = best_tbaa(output_type);\n            tbaa_decorate(tbaa, ctx.builder.CreateStore(F, derived_strct));\n            tbaa_decorate(tbaa, ctx.builder.CreateStore(\n                ctx.builder.CreatePtrToInt(literal_pointer_val(ctx, fexpr_rt.constant), T_size),\n                ctx.builder.CreateConstGEP1_32(T_size, derived_strct, 1)));\n            Value *zero = ConstantInt::get(T_size, 0);\n            tbaa_decorate(tbaa, ctx.builder.CreateStore(zero,\n                    ctx.builder.CreateConstGEP1_32(T_size, derived_strct, 2)));\n            tbaa_decorate(tbaa, ctx.builder.CreateStore(zero,\n                    ctx.builder.CreateConstGEP1_32(T_size, derived_strct, 3)));\n            F = strct;\n        }\n    }\n    JL_GC_POP();\n    return mark_julia_type(ctx, F, outboxed, output_type);\n}\n\nconst struct jl_typemap_info cfunction_cache = {\n    1, (jl_datatype_t**)&jl_array_any_type\n};\n\njl_array_t *jl_cfunction_list;\n\nstatic Function *jl_cfunction_object(jl_value_t *ff, jl_value_t *declrt, jl_tupletype_t *argt)\n{\n    // Assumes the codegen lock is acquired. The caller is responsible for that.\n    jl_ptls_t ptls = jl_get_ptls_states();\n    if (ptls->in_pure_callback)\n        jl_error(\"cfunction cannot be used in a generated function\");\n\n    // validate and unpack the arguments\n    JL_TYPECHK(cfunction, type, declrt);\n    if (!jl_is_tuple_type(argt)) // the C API requires that argt Tuple type actually be an svec\n        jl_type_error(\"cfunction\", (jl_value_t*)jl_anytuple_type_type, (jl_value_t*)argt);\n    // trampolines are not supported here:\n    // check that f is a guaranteed singleton type\n    jl_value_t *ft = jl_typeof(ff);\n    if (((jl_datatype_t*)ft)->instance != ff)\n        jl_error(\"cfunction: use `@cfunction` to make closures\");\n\n    // check the cache structure\n    // this has three levels (for the 3 parameters above)\n    // first split on `ft` using a simple eqtable\n    // then use the typemap to split on argt\n    // and finally, pick declrt from the pair-list\n    union jl_typemap_t cache_l2 = { NULL };\n    // cache_l2.unknown = NULL;\n    jl_typemap_entry_t *cache_l3 = NULL;\n    if (!jl_cfunction_list) {\n        jl_cfunction_list = jl_alloc_vec_any(16);\n    }\n    else {\n        cache_l2.unknown = jl_eqtable_get(jl_cfunction_list, ft, NULL);\n        if (cache_l2.unknown) {\n            cache_l3 = jl_typemap_assoc_by_type(cache_l2, (jl_value_t*)argt, NULL,\n                /*subtype*/0, /*offs*/0, /*world*/1, /*max_world_mask*/0);\n            if (cache_l3) {\n                jl_svec_t *sf = (jl_svec_t*)cache_l3->func.value;\n                size_t i, l = jl_svec_len(sf);\n                for (i = 0; i < l; i += 2) {\n                    jl_value_t *ti = jl_svecref(sf, i);\n                    if (jl_egal(ti, declrt)) {\n                        return (Function*)jl_unbox_voidpointer(jl_svecref(sf, i + 1));\n                    }\n                }\n            }\n        }\n    }\n\n    if (cache_l3 == NULL) {\n        union jl_typemap_t insert = cache_l2;\n        if (!insert.unknown)\n            insert.unknown = jl_nothing;\n        cache_l3 = jl_typemap_insert(&insert, (jl_value_t*)insert.unknown, (jl_tupletype_t*)argt,\n            NULL, jl_emptysvec, (jl_value_t*)jl_emptysvec, /*offs*/0, &cfunction_cache, 1, ~(size_t)0, NULL);\n        if (insert.unknown != cache_l2.unknown)\n            jl_cfunction_list = jl_eqtable_put(jl_cfunction_list, ft, insert.unknown, NULL);\n    }\n\n    // compute / validate return type\n    jl_value_t *crt = declrt;\n    if (jl_is_abstract_ref_type(declrt)) {\n        declrt = jl_tparam0(declrt);\n        if (jl_is_typevar(declrt))\n            jl_error(\"cfunction: return type Ref should have an element type, not Ref{<:T}\");\n        if (declrt == (jl_value_t*)jl_any_type)\n            jl_error(\"cfunction: return type Ref{Any} is invalid. Use Any or Ptr{Any} instead.\");\n        crt = (jl_value_t*)jl_any_type;\n    }\n    bool toboxed;\n    Type *lcrt = julia_struct_to_llvm(crt, NULL, &toboxed);\n    if (lcrt == NULL)\n        jl_error(\"cfunction: return type doesn't correspond to a C type\");\n    else if (toboxed)\n        lcrt = T_prjlvalue;\n\n    // compute / validate method signature\n    jl_value_t *sigt = NULL; // dispatch sig: type signature (argt) with Ref{} annotations removed and ft added\n    JL_GC_PUSH1(&sigt);\n    size_t i, nargs = jl_nparams(argt);\n    sigt = (jl_value_t*)jl_alloc_svec(nargs + 1);\n    jl_svecset(sigt, 0, ft);\n    for (i = 0; i < nargs; i++) {\n        jl_value_t *ati = jl_tparam(argt, i);\n        if (jl_is_abstract_ref_type(ati)) {\n            ati = jl_tparam0(ati);\n            if (jl_is_typevar(ati))\n                jl_error(\"cfunction: argument type Ref should have an element type, not Ref{<:T}\");\n        }\n        if (jl_is_pointer(ati) && jl_is_typevar(jl_tparam0(ati)))\n            jl_error(\"cfunction: argument type Ptr should have an element type, Ptr{<:T}\");\n        jl_svecset(sigt, i + 1, ati);\n    }\n    sigt = (jl_value_t*)jl_apply_tuple_type((jl_svec_t*)sigt);\n\n    // emit cfunction (trampoline)\n    jl_value_t *err;\n    { // scope block for sig\n        function_sig_t sig(\"cfunction\", lcrt, crt, toboxed,\n                           argt->parameters, NULL, nargs, false, CallingConv::C, false);\n        if (!sig.err_msg.empty()) {\n            err = jl_get_exceptionf(jl_errorexception_type, \"%s\", sig.err_msg.c_str());\n        }\n        else if (sig.isVa || sig.fargt.size() + sig.sret != sig.fargt_sig.size()) {\n            err = NULL;\n        }\n        else {\n            Function *F = gen_cfun_wrapper(NULL, sig, ff, cache_l3, declrt, (jl_tupletype_t*)sigt, NULL, NULL, NULL);\n            JL_GC_POP();\n            return F;\n        }\n    }\n    if (err)\n        jl_throw(err);\n    jl_error(\"cfunction: Vararg syntax not allowed for cfunction argument list\");\n}\n\n// generate a julia-callable function that calls f (AKA lam)\nstatic Function *gen_invoke_wrapper(jl_method_instance_t *lam, const jl_returninfo_t &f, StringRef funcName, Module *M)\n{\n    Function *w = Function::Create(jl_func_sig, GlobalVariable::ExternalLinkage, funcName, M);\n    add_return_attr(w, Attribute::NonNull);\n    w->addFnAttr(Thunk);\n    jl_init_function(w);\n#ifdef JL_DISABLE_FPO\n    w->addFnAttr(\"no-frame-pointer-elim\", \"true\");\n#endif\n    Function::arg_iterator AI = w->arg_begin();\n    Value *methodArg = &*AI++; (void)methodArg;\n    Value *argArray = &*AI++;\n    Value *argCount = &*AI++; (void)argCount;\n    assert(AI == w->arg_end());\n\n    jl_codectx_t ctx(jl_LLVMContext);\n    ctx.f = w;\n    ctx.linfo = lam;\n    ctx.world = 0;\n    ctx.params = &jl_default_cgparams;\n\n    BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", w);\n    ctx.builder.SetInsertPoint(b0);\n    DebugLoc noDbg;\n    ctx.builder.SetCurrentDebugLocation(noDbg);\n    allocate_gc_frame(ctx, b0);\n\n    FunctionType *ftype = f.decl->getFunctionType();\n    size_t nfargs = ftype->getNumParams();\n    Value **args = (Value**) alloca(nfargs*sizeof(Value*));\n    unsigned idx = 0;\n    AllocaInst *result;\n    switch (f.cc) {\n    case jl_returninfo_t::Boxed:\n    case jl_returninfo_t::Register:\n    case jl_returninfo_t::Ghosts:\n        break;\n    case jl_returninfo_t::SRet:\n        result = ctx.builder.CreateAlloca(ftype->getParamType(0)->getContainedType(0));\n        args[idx] = result;\n        idx++;\n        break;\n    case jl_returninfo_t::Union:\n        result = ctx.builder.CreateAlloca(ArrayType::get(T_int8, f.union_bytes));\n        if (f.union_align > 1)\n            result->setAlignment(f.union_align);\n        args[idx] = result;\n        idx++;\n        break;\n    }\n    for (size_t i = 0; i < jl_nparams(lam->specTypes) && idx < nfargs; ++i) {\n        jl_value_t *ty = jl_nth_slot_type(lam->specTypes, i);\n        bool isboxed;\n        Type *lty = julia_type_to_llvm(ty, &isboxed);\n        if (lty != NULL && type_is_ghost(lty))\n            continue;\n        Value *argPtr = ctx.builder.CreateInBoundsGEP(argArray, ConstantInt::get(T_size, i));\n        Value *theArg = maybe_mark_load_dereferenceable(ctx.builder.CreateLoad(argPtr), false, ty);\n        if (lty != NULL && !isboxed) {\n            theArg = decay_derived(emit_bitcast(ctx, theArg, PointerType::get(lty, 0)));\n            if (!lty->isAggregateType()) // keep \"aggregate\" type values in place as pointers\n                theArg = ctx.builder.CreateAlignedLoad(theArg, julia_alignment(ty));\n        }\n        assert(dyn_cast<UndefValue>(theArg) == NULL);\n        args[idx] = theArg;\n        idx++;\n    }\n    CallInst *call = ctx.builder.CreateCall(f.decl, ArrayRef<Value*>(&args[0], nfargs));\n    call->setAttributes(f.decl->getAttributes());\n\n    jl_value_t *jlretty = lam->rettype;\n    jl_cgval_t retval;\n    switch (f.cc) {\n    case jl_returninfo_t::Boxed:\n        retval = mark_julia_type(ctx, call, true, jlretty);\n        break;\n    case jl_returninfo_t::Register:\n        retval = mark_julia_type(ctx, call, false, jlretty);\n        break;\n    case jl_returninfo_t::SRet:\n        retval = mark_julia_slot(result, jlretty, NULL, tbaa_stack);\n        break;\n    case jl_returninfo_t::Union:\n        // result is technically not right here, but we only need to look at it\n        // for the unboxed values, so it's ok.\n        retval = mark_julia_slot(result,\n                                 jlretty,\n                                 ctx.builder.CreateExtractValue(call, 1),\n                                 tbaa_stack);\n        retval.Vboxed = ctx.builder.CreateExtractValue(call, 0);\n        break;\n    case jl_returninfo_t::Ghosts:\n        retval = mark_julia_slot(NULL, jlretty, call, tbaa_stack);\n        break;\n    }\n    ctx.builder.CreateRet(boxed(ctx, retval));\n    assert(!ctx.roots);\n    return w;\n}\n\nstatic bool uses_specsig(jl_value_t *sig, size_t nreq, jl_value_t *rettype, bool needsparam, bool va, jl_code_info_t *src, bool prefer_specsig)\n{\n    if (needsparam)\n        return false;\n    if (!src || !jl_ast_flag_inferred((jl_array_t*)src))\n        return false;\n    if (sig == (jl_value_t*)jl_anytuple_type)\n        return false;\n    if (!jl_is_datatype(sig))\n        return false;\n    if (jl_nparams(sig) == 0)\n        return false;\n    if (va) {\n        if (jl_is_vararg_type(jl_tparam(sig, jl_nparams(sig)-1)))\n            return false;\n    }\n    // not invalid, consider if specialized signature is worthwhile\n    if (prefer_specsig)\n        return true;\n    if (jl_justbits(rettype) && !jl_is_datatype_singleton((jl_datatype_t*)rettype))\n        return true;\n    if (jl_is_uniontype(rettype)) {\n        bool allunbox;\n        size_t nbytes, align, min_align;\n        union_alloca_type((jl_uniontype_t*)rettype, allunbox, nbytes, align, min_align);\n        if (nbytes > 0)\n            return true; // some elements of the union could be returned unboxed avoiding allocation\n    }\n    for (size_t i = 0; i < jl_nparams(sig); i++) {\n        jl_value_t *sigt = jl_tparam(sig, i);\n        if (jl_justbits(sigt) && !jl_is_datatype_singleton((jl_datatype_t*)sigt)) {\n            return true;\n        }\n    }\n    return false; // jlcall sig won't require any box allocations\n}\n\nstatic jl_returninfo_t get_specsig_function(Module *M, const std::string &name, jl_value_t *sig, jl_value_t *jlrettype)\n{\n    jl_returninfo_t props = {};\n    SmallVector<Type*, 8> fsig;\n    Type *rt;\n    if (jl_is_structtype(jlrettype) && jl_is_datatype_singleton((jl_datatype_t*)jlrettype)) {\n        rt = T_void;\n        props.cc = jl_returninfo_t::Register;\n    }\n    else if (jl_is_uniontype(jlrettype)) {\n        bool allunbox;\n        union_alloca_type((jl_uniontype_t*)jlrettype, allunbox, props.union_bytes, props.union_align, props.union_minalign);\n        if (props.union_bytes) {\n            props.cc = jl_returninfo_t::Union;\n            Type *AT = ArrayType::get(T_int8, props.union_bytes);\n            fsig.push_back(AT->getPointerTo());\n            Type *pair[] = { T_prjlvalue, T_int8 };\n            rt = StructType::get(jl_LLVMContext, makeArrayRef(pair));\n        }\n        else if (allunbox) {\n            props.cc = jl_returninfo_t::Ghosts;\n            rt = T_int8;\n        }\n        else {\n            rt = T_prjlvalue;\n        }\n    }\n    else {\n        bool retboxed;\n        rt = julia_type_to_llvm(jlrettype, &retboxed);\n        if (!retboxed) {\n            if (rt != T_void && deserves_sret(jlrettype, rt)) {\n                props.cc = jl_returninfo_t::SRet;\n                fsig.push_back(rt->getPointerTo());\n                rt = T_void;\n            }\n            else {\n                props.cc = jl_returninfo_t::Register;\n            }\n        } else {\n            rt = T_prjlvalue;\n        }\n    }\n#if JL_LLVM_VERSION >= 50000\n    AttributeList attributes; // function declaration attributes\n#else\n    AttributeSet attributes; // function declaration attributes\n#endif\n    if (props.cc == jl_returninfo_t::SRet) {\n        attributes = attributes.addAttribute(jl_LLVMContext, 1, Attribute::StructRet);\n        attributes = attributes.addAttribute(jl_LLVMContext, 1, Attribute::NoAlias);\n        attributes = attributes.addAttribute(jl_LLVMContext, 1, Attribute::NoCapture);\n    }\n    if (props.cc == jl_returninfo_t::Union) {\n        attributes = attributes.addAttribute(jl_LLVMContext, 1, Attribute::NoAlias);\n        attributes = attributes.addAttribute(jl_LLVMContext, 1, Attribute::NoCapture);\n    }\n    for (size_t i = 0; i < jl_nparams(sig); i++) {\n        jl_value_t *jt = jl_tparam(sig, i);\n        bool isboxed;\n        Type *ty = julia_type_to_llvm(jt, &isboxed);\n        if (type_is_ghost(ty))\n            continue;\n        unsigned argno = fsig.size();\n        if (ty->isAggregateType()) { // aggregate types are passed by pointer\n            attributes = attributes.addParamAttribute(jl_LLVMContext, argno, Attribute::NoCapture);\n            attributes = attributes.addParamAttribute(jl_LLVMContext, argno, Attribute::ReadOnly);\n            ty = PointerType::get(ty, AddressSpace::Derived);\n        }\n        if (isboxed)\n            ty = PointerType::get(cast<PointerType>(ty)->getElementType(), AddressSpace::Tracked);\n        fsig.push_back(ty);\n    }\n    FunctionType *ftype = FunctionType::get(rt, fsig, false);\n    Function *f = M ? cast_or_null<Function>(M->getNamedValue(name)) : NULL;\n    if (f == NULL) {\n        f = Function::Create(ftype, GlobalVariable::ExternalLinkage, name, M);\n        f->setAttributes(attributes);\n    }\n    else {\n        assert(f->getFunctionType() == ftype);\n    }\n    if (rt == T_prjlvalue)\n        add_return_attr(f, Attribute::NonNull);\n    props.decl = f;\n    return props;\n}\n\nstatic DISubroutineType *\nget_specsig_di(jl_value_t *rt, jl_value_t *sig, DIFile *topfile, DIBuilder &dbuilder)\n{\n    std::vector<Metadata*> ditypes(0);\n    Type *ty = julia_type_to_llvm(rt);\n    if (type_is_ghost(ty))\n        ditypes.push_back(nullptr);\n    else\n        ditypes.push_back(julia_type_to_di(rt, &dbuilder, false));\n    for (size_t i = 0; i < jl_nparams(sig); i++) {\n        jl_value_t *jt = jl_tparam(sig, i);\n        Type *ty = julia_type_to_llvm(jt);\n        if (type_is_ghost(ty))\n            continue;\n        ditypes.push_back(julia_type_to_di(jt, &dbuilder, false));\n    }\n    return dbuilder.createSubroutineType(dbuilder.getOrCreateTypeArray(ditypes));\n}\n\nstatic jl_datatype_t *compute_va_type(jl_method_instance_t *lam, size_t nreq)\n{\n    size_t nvargs = jl_nparams(lam->specTypes)-nreq;\n    jl_svec_t *tupargs = jl_alloc_svec(nvargs);\n    JL_GC_PUSH1(&tupargs);\n    for (size_t i = nreq; i < jl_nparams(lam->specTypes); ++i) {\n        jl_value_t *argType = jl_nth_slot_type(lam->specTypes, i);\n        jl_svecset(tupargs, i-nreq, argType);\n    }\n    jl_datatype_t *typ = jl_apply_tuple_type(tupargs);\n    JL_GC_POP();\n    return typ;\n}\n\n// Compile to LLVM IR, using a specialized signature if applicable.\nstatic std::unique_ptr<Module> emit_function(\n        jl_method_instance_t *lam,\n        jl_code_info_t *src,\n        size_t world,\n        jl_llvm_functions_t *declarations,\n        const jl_cgparams_t *params)\n{\n    assert(declarations && \"Capturing declarations is always required\");\n\n    // step 1. unpack AST and allocate codegen context for this function\n    jl_codectx_t ctx(jl_LLVMContext);\n    JL_GC_PUSH2(&ctx.code, &ctx.roots);\n    ctx.code = (jl_array_t*)src->code;\n\n    //jl_static_show(JL_STDOUT, (jl_value_t*)ast);\n    //jl_printf(JL_STDOUT, \"\\n\");\n    std::map<int, BasicBlock*> labels;\n    ctx.module = jl_is_method(lam->def.method) ? lam->def.method->module : lam->def.module;\n    ctx.linfo = lam;\n    ctx.source = src;\n    ctx.world = world;\n    ctx.name = name_from_method_instance(lam);\n    ctx.funcName = ctx.name;\n    ctx.params = params;\n    ctx.spvals_ptr = NULL;\n    ctx.nargs = jl_is_method(lam->def.method) ? lam->def.method->nargs : 0;\n    bool toplevel = !jl_is_method(lam->def.method);\n    jl_array_t *stmts = ctx.code;\n    size_t stmtslen = jl_array_dim0(stmts);\n\n    if (JL_HOOK_TEST(ctx.params, emit_function)) {\n        JL_HOOK_CALL(ctx.params, emit_function, 3, (jl_value_t*)ctx.linfo,\n                     (jl_value_t*)ctx.source, jl_box_ulong(world));\n    }\n\n    // step 1b. unpack debug information\n    int coverage_mode = jl_options.code_coverage;\n    int malloc_log_mode = jl_options.malloc_log;\n    StringRef filename = \"<missing>\";\n    StringRef dbgFuncName = ctx.name;\n    int toplineno = -1;\n    if (jl_is_method(lam->def.method)) {\n        toplineno = lam->def.method->line;\n        if (lam->def.method->file != empty_sym)\n            filename = jl_symbol_name(lam->def.method->file);\n    }\n    else if (jl_array_len(src->linetable) > 0) {\n        jl_value_t *locinfo = jl_array_ptr_ref(src->linetable, 0);\n        filename = jl_symbol_name((jl_sym_t*)jl_fieldref_noalloc(locinfo, 2));\n        toplineno = jl_unbox_long(jl_fieldref(locinfo, 3));\n    }\n    ctx.file = filename;\n    // jl_printf(JL_STDERR, \"\\n*** compiling %s at %s:%d\\n\\n\",\n    //           jl_symbol_name(ctx.name), filename.str().c_str(), toplineno);\n\n    ctx.debug_enabled = true;\n    if (dbgFuncName.empty()) {\n        // special value: if function name is empty, disable debug info\n        coverage_mode = JL_LOG_NONE;\n        malloc_log_mode = JL_LOG_NONE;\n        //dbgFuncName = filename; // for testing, uncomment this line\n        ctx.debug_enabled = !dbgFuncName.empty();\n    }\n    if (jl_options.debug_level == 0)\n        ctx.debug_enabled = 0;\n\n    // step 2. process var-info lists to see what vars need boxing\n    int n_ssavalues = jl_is_long(src->ssavaluetypes) ? jl_unbox_long(src->ssavaluetypes) : jl_array_len(src->ssavaluetypes);\n    size_t vinfoslen = jl_array_dim0(src->slotnames);\n    ctx.slots.resize(vinfoslen);\n    size_t nreq = ctx.nargs;\n    int va = 0;\n\n    assert(lam->specTypes); // the specTypes field should always be assigned\n\n    if (nreq > 0 && lam->def.method->isva) {\n        nreq--;\n        va = 1;\n        jl_sym_t *vn = (jl_sym_t*)jl_array_ptr_ref(src->slotnames, ctx.nargs - 1);\n        if (vn != unused_sym)\n            ctx.vaSlot = ctx.nargs - 1;\n    }\n    ctx.nReqArgs = nreq;\n\n    // create SAvalue locations for SSAValue objects\n    ctx.ssavalue_assigned.assign(n_ssavalues, false);\n    ctx.SAvalues.assign(n_ssavalues, jl_cgval_t());\n\n    bool needsparams = false;\n    if (jl_is_method(lam->def.method)) {\n        if (jl_svec_len(lam->def.method->sparam_syms) != jl_svec_len(lam->sparam_vals))\n            needsparams = true;\n        for (size_t i = 0; i < jl_svec_len(lam->sparam_vals); ++i) {\n            if (jl_is_typevar(jl_svecref(lam->sparam_vals, i)))\n                needsparams = true;\n        }\n    }\n\n    jl_value_t *jlrettype = lam->rettype;\n    bool specsig = uses_specsig(lam->specTypes, nreq, jlrettype, needsparams, va, src, params->prefer_specsig);\n\n    // step 3. some variable analysis\n    size_t i;\n    for (i = 0; i < nreq; i++) {\n        jl_varinfo_t &varinfo = ctx.slots[i];\n        varinfo.isArgument = true;\n        jl_sym_t *argname = (jl_sym_t*)jl_array_ptr_ref(src->slotnames, i);\n        if (argname == unused_sym)\n            continue;\n        jl_value_t *ty = jl_nth_slot_type(lam->specTypes, i);\n        varinfo.value = mark_julia_type(ctx, (Value*)NULL, false, ty);\n    }\n    if (va && ctx.vaSlot != -1) {\n        jl_varinfo_t &varinfo = ctx.slots[ctx.vaSlot];\n        varinfo.isArgument = true;\n        jl_datatype_t *vatyp = specsig ? compute_va_type(lam, nreq) : (jl_tuple_type);\n        varinfo.value = mark_julia_type(ctx, (Value*)NULL, false, vatyp);\n    }\n\n    for (i = 0; i < vinfoslen; i++) {\n        jl_varinfo_t &varinfo = ctx.slots[i];\n        uint8_t flags = jl_array_uint8_ref(src->slotflags, i);\n        varinfo.isSA = (jl_vinfo_sa(flags) != 0) || varinfo.isArgument;\n        varinfo.usedUndef = (jl_vinfo_usedundef(flags) != 0) || (!varinfo.isArgument && !src->inferred);\n        if (!varinfo.isArgument) {\n            varinfo.value = mark_julia_type(ctx, (Value*)NULL, false, (jl_value_t*)jl_any_type);\n        }\n    }\n\n    // finish recording variable use info\n    for (i = 0; i < stmtslen; i++)\n        simple_use_analysis(ctx, jl_array_ptr_ref(stmts, i));\n\n    // determine which vars need to be volatile\n    mark_volatile_vars(stmts, ctx.slots);\n\n    // step 4. determine function signature\n    if (!specsig)\n        ctx.nReqArgs--;  // function not part of argArray in jlcall\n\n    std::stringstream funcName;\n    // try to avoid conflicts in the global symbol table\n    if (specsig)\n        funcName << \"julia_\"; // api 5\n    else if (needsparams)\n        funcName << \"japi3_\";\n    else\n        funcName << \"japi1_\";\n    const char* unadorned_name = ctx.name;\n#if defined(_OS_LINUX_)\n    if (unadorned_name[0] == '@')\n        unadorned_name++;\n#endif\n    funcName << unadorned_name << \"_\" << globalUnique++;\n\n    // allocate Function declarations and wrapper objects\n    Module *M = new Module(ctx.name, jl_LLVMContext);\n    jl_setup_module(M, params);\n    jl_returninfo_t returninfo = {};\n    Function *f = NULL;\n    if (specsig) { // assumes !va and !needsparams\n        returninfo = get_specsig_function(M, funcName.str(), lam->specTypes, jlrettype);\n        f = returninfo.decl;\n        ctx.has_sret = (returninfo.cc == jl_returninfo_t::SRet || returninfo.cc == jl_returninfo_t::Union);\n        jl_init_function(f);\n\n        std::stringstream wrapName;\n        wrapName << \"jfptr_\" << unadorned_name << \"_\" << globalUnique;\n        Function *fwrap = gen_invoke_wrapper(lam, returninfo, wrapName.str(), M);\n        declarations->functionObject = strdup(fwrap->getName().str().c_str());\n    }\n    else {\n        f = Function::Create(needsparams ? jl_func_sig_sparams : jl_func_sig,\n                             GlobalVariable::ExternalLinkage,\n                             funcName.str(), M);\n        add_return_attr(f, Attribute::NonNull);\n        f->addFnAttr(Thunk);\n        // TODO: (if needsparams) add attributes: dereferenceable<sizeof(void*) * length(sp)>, readonly, nocapture\n        // TODO: add attributes: dereferenceable<sizeof(ft)>, readonly, nocapture - e.g. maybe_mark_argument_dereferenceable(Arg, argType);\n        // TODO: add attributes: dereferenceable<sizeof(void*) * nreq>, readonly, nocapture\n        returninfo.decl = f;\n        jl_init_function(f);\n        declarations->functionObject = needsparams ? \"jl_fptr_sparam\" : \"jl_fptr_args\";\n    }\n    declarations->specFunctionObject = strdup(f->getName().str().c_str());\n\n#ifdef JL_DISABLE_FPO\n    f->addFnAttr(\"no-frame-pointer-elim\", \"true\");\n#endif\n    if (jlrettype == (jl_value_t*)jl_bottom_type)\n        f->setDoesNotReturn();\n#if defined(_OS_WINDOWS_) && !defined(_CPU_X86_64_)\n    // tell Win32 to realign the stack to the next 16-byte boundary\n    // upon entry to any function. This achieves compatibility\n    // with both MinGW-GCC (which assumes an 16-byte-aligned stack) and\n    // i686 Windows (which uses a 4-byte-aligned stack)\n    AttrBuilder *attr = new AttrBuilder();\n    attr->addStackAlignmentAttr(16);\n#if JL_LLVM_VERSION >= 50000\n    f->addAttributes(AttributeList::FunctionIndex, *attr);\n#else\n    f->addAttributes(AttributeSet::FunctionIndex,\n        AttributeSet::get(f->getContext(),\n            AttributeSet::FunctionIndex, *attr));\n#endif\n#endif\n#if defined(_OS_WINDOWS_) && defined(_CPU_X86_64_)\n    f->setHasUWTable(); // force NeedsWinEH\n#endif\n\n#ifdef USE_POLLY\n    if (!jl_has_meta(stmts, polly_sym) || jl_options.polly == JL_OPTIONS_POLLY_OFF) {\n        f->addFnAttr(polly::PollySkipFnAttr);\n    }\n#endif\n\n    if (jl_has_meta(stmts, noinline_sym)) {\n        f->addFnAttr(Attribute::NoInline);\n    }\n\n    if (returninfo.cc == jl_returninfo_t::Union) {\n        f->addAttribute(1, Attribute::getWithDereferenceableBytes(jl_LLVMContext, returninfo.union_bytes));\n        f->addAttribute(1, Attribute::getWithAlignment(jl_LLVMContext, returninfo.union_align));\n    }\n\n#ifdef JL_DEBUG_BUILD\n    f->addFnAttr(Attribute::StackProtectStrong);\n#endif\n    ctx.f = f;\n\n    // Step 4b. determine debug info signature and other type info for locals\n    DIBuilder dbuilder(*M);\n    DIFile *topfile = NULL;\n    DISubprogram *SP = NULL;\n    DebugLoc noDbg, topdebugloc;\n    if (ctx.debug_enabled) {\n        // TODO: Fix when moving to new LLVM version\n        topfile = dbuilder.createFile(filename, \".\");\n#if JL_LLVM_VERSION >= 40000\n        DICompileUnit *CU = dbuilder.createCompileUnit(0x01, topfile, \"julia\", true, \"\", 0);\n#else\n        DICompileUnit *CU = dbuilder.createCompileUnit(0x01, filename, \".\", \"julia\", true, \"\", 0);\n#endif\n\n        DISubroutineType *subrty;\n        if (jl_options.debug_level <= 1) {\n            subrty = jl_di_func_null_sig;\n        }\n        else if (!specsig) {\n            subrty = jl_di_func_sig;\n        }\n        else {\n            subrty = get_specsig_di(lam->rettype, lam->specTypes, topfile, dbuilder);\n        }\n        SP = dbuilder.createFunction(CU,\n                                     dbgFuncName,      // Name\n                                     f->getName(),     // LinkageName\n                                     topfile,          // File\n                                     toplineno,        // LineNo\n                                     subrty,           // Ty\n                                     false,            // isLocalToUnit\n                                     true,             // isDefinition\n                                     toplineno,        // ScopeLine\n                                     DIFlagZero,       // Flags\n                                     true,             // isOptimized\n                                     nullptr);         // Template Parameters\n        topdebugloc = DebugLoc::get(toplineno, 0, SP, NULL);\n        f->setSubprogram(SP);\n        if (jl_options.debug_level >= 2) {\n            const bool AlwaysPreserve = true;\n            // Go over all arguments and local variables and initialize their debug information\n            for (i = 0; i < nreq; i++) {\n                jl_sym_t *argname = (jl_sym_t*)jl_array_ptr_ref(src->slotnames, i);\n                if (argname == unused_sym)\n                    continue;\n                jl_varinfo_t &varinfo = ctx.slots[i];\n                varinfo.dinfo = dbuilder.createParameterVariable(\n                    SP,                                 // Scope (current function will be fill in later)\n                    jl_symbol_name(argname),            // Variable name\n                    ctx.has_sret + i + 1,               // Argument number (1-based)\n                    topfile,                            // File\n                    toplineno == -1 ? 0 : toplineno,    // Line\n                    // Variable type\n                    julia_type_to_di(varinfo.value.typ, &dbuilder, false),\n                    AlwaysPreserve,                     // May be deleted if optimized out\n                    DIFlagZero);                        // Flags (TODO: Do we need any)\n            }\n            if (va && ctx.vaSlot != -1) {\n                ctx.slots[ctx.vaSlot].dinfo = dbuilder.createParameterVariable(\n                    SP,                                 // Scope (current function will be fill in later)\n                    std::string(jl_symbol_name(slot_symbol(ctx, ctx.vaSlot))) + \"...\",  // Variable name\n                    ctx.has_sret + nreq + 1,            // Argument number (1-based)\n                    topfile,                            // File\n                    toplineno == -1 ? 0 : toplineno,    // Line (for now, use lineno of the function)\n                    julia_type_to_di(ctx.slots[ctx.vaSlot].value.typ, &dbuilder, false),\n                    AlwaysPreserve,                     // May be deleted if optimized out\n                    DIFlagZero);                        // Flags (TODO: Do we need any)\n            }\n            for (i = 0; i < vinfoslen; i++) {\n                jl_sym_t *s = (jl_sym_t*)jl_array_ptr_ref(src->slotnames, i);\n                jl_varinfo_t &varinfo = ctx.slots[i];\n                if (varinfo.isArgument || s == compiler_temp_sym || s == unused_sym)\n                    continue;\n                // LLVM 4.0: Assume the variable has default alignment\n                varinfo.dinfo = dbuilder.createAutoVariable(\n                    SP,                     // Scope (current function will be fill in later)\n                    jl_symbol_name(s),       // Variable name\n                    topfile,                 // File\n                    toplineno == -1 ? 0 : toplineno, // Line (for now, use lineno of the function)\n                    julia_type_to_di(varinfo.value.typ, &dbuilder, false), // Variable type\n                    AlwaysPreserve,          // May be deleted if optimized out\n                    DIFlagZero               // Flags (TODO: Do we need any)\n                    );\n            }\n        }\n    }\n\n    // step 5. create first basic block\n    BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", f);\n    ctx.builder.SetInsertPoint(b0);\n    ctx.builder.SetCurrentDebugLocation(noDbg);\n\n    // spill arguments into stack slots\n    // so it is more likely to be possible to find them when debugging\n    Value *fArg=NULL, *argArray=NULL, *pargArray=NULL, *argCount=NULL;\n    if (!specsig) {\n        Function::arg_iterator AI = f->arg_begin();\n        if (needsparams) {\n            ctx.spvals_ptr = &*AI;\n            ++AI;\n        }\n        fArg = &*AI++;\n        argArray = &*AI++;\n        pargArray = ctx.builder.CreateAlloca(argArray->getType());\n        ctx.builder.CreateStore(argArray, pargArray, true/*volatile store to prevent removal of this alloca*/);\n        argCount = &*AI++;\n        ctx.argArray = argArray;\n        ctx.argCount = argCount;\n    }\n\n    /*\n    // step 6. (optional) check for stack overflow (the slower way)\n    Value *cur_sp =\n        ctx.builder.CreateCall(Intrinsic::getDeclaration(M,\n                                                     Intrinsic::frameaddress),\n                           ConstantInt::get(T_int32, 0));\n    Value *sp_ok =\n        ctx.builder.CreateICmpUGT(cur_sp,\n                              ConstantInt::get(T_size,\n                                               (uptrint_t)jl_stack_lo));\n    error_unless(ctx, sp_ok, \"stack overflow\");\n    */\n\n    // step 7. set up GC frame\n    allocate_gc_frame(ctx, b0);\n    Value *last_age = NULL;\n    if (toplevel) {\n        emit_last_age_field(ctx);\n        last_age = tbaa_decorate(tbaa_gcframe, ctx.builder.CreateLoad(ctx.world_age_field));\n    }\n\n    // step 8. allocate local variables slots\n    // must be in the first basic block for the llvm mem2reg pass to work\n    auto allocate_local = [&](jl_varinfo_t &varinfo, jl_sym_t *s) {\n        jl_value_t *jt = varinfo.value.typ;\n        assert(!varinfo.boxroot); // variables shouldn't have memory locs already\n        if (varinfo.value.constant) {\n            // no need to explicitly load/store a constant/ghost value\n            alloc_def_flag(ctx, varinfo);\n            return;\n        }\n        else if (varinfo.isArgument && !(specsig && i == (size_t)ctx.vaSlot)) {\n            // if we can unbox it, just use the input pointer\n            if (i != (size_t)ctx.vaSlot && jl_justbits(jt))\n                return;\n        }\n        else if (jl_is_uniontype(jt)) {\n            bool allunbox;\n            size_t align, nbytes;\n            Value *lv = try_emit_union_alloca(ctx, (jl_uniontype_t*)jt, allunbox, align, nbytes);\n            if (lv) {\n                lv->setName(jl_symbol_name(s));\n                varinfo.value = mark_julia_slot(lv, jt, NULL, tbaa_stack);\n                varinfo.pTIndex = emit_static_alloca(ctx, T_int8);\n            }\n            else if (allunbox) {\n                // all ghost values just need a selector allocated\n                AllocaInst *lv = emit_static_alloca(ctx, T_int8);\n                lv->setName(jl_symbol_name(s));\n                varinfo.pTIndex = lv;\n                varinfo.value.tbaa = NULL;\n                varinfo.value.isboxed = false;\n            }\n            if (lv || allunbox)\n                alloc_def_flag(ctx, varinfo);\n            if (allunbox)\n                return;\n        }\n        else if (jl_justbits(jt)) {\n            bool isboxed;\n            Type *vtype = julia_type_to_llvm(jt, &isboxed);\n            assert(!isboxed);\n            assert(!type_is_ghost(vtype) && \"constants should already be handled\");\n            // CreateAlloca is OK during prologue setup\n            Value *lv = ctx.builder.CreateAlloca(vtype, NULL, jl_symbol_name(s));\n            varinfo.value = mark_julia_slot(lv, jt, NULL, tbaa_stack);\n            alloc_def_flag(ctx, varinfo);\n            if (ctx.debug_enabled && varinfo.dinfo) {\n                assert((Metadata*)varinfo.dinfo->getType() != jl_pvalue_dillvmt);\n                dbuilder.insertDeclare(lv, varinfo.dinfo, dbuilder.createExpression(),\n                                       topdebugloc,\n                                       ctx.builder.GetInsertBlock());\n            }\n            return;\n        }\n        if (!varinfo.isArgument || // always need a slot if the variable is assigned\n            specsig || // for arguments, give them stack slots if they aren't in `argArray` (otherwise, will use that pointer)\n            (va && (int)i == ctx.vaSlot) || // or it's the va arg tuple\n            i == 0) { // or it is the first argument (which isn't in `argArray`)\n#if JL_LLVM_VERSION >= 50000\n            AllocaInst *av = new AllocaInst(T_prjlvalue, 0,\n#else\n            AllocaInst *av = new AllocaInst(T_prjlvalue,\n#endif\n                jl_symbol_name(s), /*InsertBefore*/ctx.ptlsStates);\n            StoreInst *SI = new StoreInst(\n                ConstantPointerNull::get(cast<PointerType>(T_prjlvalue)), av,\n                false);\n            SI->insertAfter(ctx.ptlsStates);\n            varinfo.boxroot = av;\n            if (ctx.debug_enabled && varinfo.dinfo) {\n                DIExpression *expr;\n                if ((Metadata*)varinfo.dinfo->getType() == jl_pvalue_dillvmt) {\n                    expr = dbuilder.createExpression();\n                }\n                else {\n                    SmallVector<uint64_t, 8> addr;\n                    addr.push_back(llvm::dwarf::DW_OP_deref);\n                    expr = dbuilder.createExpression(addr);\n                }\n                dbuilder.insertDeclare(av, varinfo.dinfo, expr,\n                                            topdebugloc,\n                                ctx.builder.GetInsertBlock());\n            }\n        }\n    };\n\n    // get pointers for locals stored in the gc frame array (argTemp)\n    for (i = 0; i < vinfoslen; i++) {\n        jl_sym_t *s = slot_symbol(ctx, i);\n        if (s == unused_sym)\n            continue;\n        jl_varinfo_t &varinfo = ctx.slots[i];\n        if (!varinfo.used) {\n            varinfo.usedUndef = false;\n            continue;\n        }\n        allocate_local(varinfo, s);\n    }\n\n    std::map<int, int> upsilon_to_phic;\n\n    // Scan for PhiC nodes, emit their slots and record which upsilon nodes\n    // yield to them.\n    {\n        for (size_t i = 0; i < jl_array_len(stmts); ++i) {\n            jl_value_t *stmt = jl_array_ptr_ref(stmts, i);\n            if (jl_is_phicnode(stmt)) {\n                jl_array_t *values = (jl_array_t*)jl_fieldref_noalloc(stmt, 0);\n                for (size_t j = 0; j < jl_array_len(values); ++j) {\n                    jl_value_t *val = jl_array_ptr_ref(values, j);\n                    assert(jl_is_ssavalue(val));\n                    upsilon_to_phic[((jl_ssavalue_t*)val)->id] = i;\n                }\n                ctx.phic_slots[i] = jl_varinfo_t{};\n                jl_varinfo_t &vi = ctx.phic_slots[i];\n                jl_value_t *typ = jl_array_ptr_ref(src->ssavaluetypes, i);\n                vi.used = true;\n                vi.isVolatile = true;\n                vi.value = mark_julia_type(ctx, (Value*)NULL, false, typ);\n                allocate_local(vi, jl_symbol(\"phic\"));\n            }\n        }\n    }\n\n    // step 9. move args into local variables\n    Function::arg_iterator AI = f->arg_begin();\n\n    auto get_specsig_arg = [&](jl_value_t *argType, Type *llvmArgType, bool isboxed) {\n        jl_cgval_t theArg;\n        if (type_is_ghost(llvmArgType)) { // this argument is not actually passed\n            theArg = ghostValue(argType);\n        }\n        else if (llvmArgType->isAggregateType()) {\n            Argument *Arg = &*AI; ++AI;\n            maybe_mark_argument_dereferenceable(Arg, argType);\n            theArg = mark_julia_slot(Arg, argType, NULL, tbaa_const); // this argument is by-pointer\n        }\n        else {\n            Argument *Arg = &*AI; ++AI;\n            if (isboxed) // e.g. is-pointer\n                maybe_mark_argument_dereferenceable(Arg, argType);\n            theArg = mark_julia_type(ctx, Arg, isboxed, argType);\n        }\n        return theArg;\n    };\n\n    if (ctx.has_sret)\n        AI++; // skip sret slot\n    for (i = 0; i < nreq; i++) {\n        jl_sym_t *s = (jl_sym_t*)jl_array_ptr_ref(src->slotnames, i);\n        jl_value_t *argType = jl_nth_slot_type(lam->specTypes, i);\n        bool isboxed;\n        Type *llvmArgType = julia_type_to_llvm(argType, &isboxed);\n        if (s == unused_sym) {\n            if (specsig && !type_is_ghost(llvmArgType))\n                ++AI;\n            continue;\n        }\n        jl_varinfo_t &vi = ctx.slots[i];\n        jl_cgval_t theArg;\n        if (s == unused_sym || vi.value.constant) {\n            assert(vi.boxroot == NULL);\n            if (specsig && !type_is_ghost(llvmArgType))\n                ++AI;\n        }\n        else {\n            if (specsig) {\n                theArg = get_specsig_arg(argType, llvmArgType, isboxed);\n            }\n            else {\n                if (i == 0) {\n                    // first (function) arg is separate in jlcall\n                    theArg = mark_julia_type(ctx, fArg, true, vi.value.typ);\n                }\n                else {\n                    Value *argPtr = ctx.builder.CreateInBoundsGEP(argArray, ConstantInt::get(T_size, i-1));\n                    auto load = maybe_mark_load_dereferenceable(ctx.builder.CreateLoad(argPtr),\n                                                                false, vi.value.typ);\n                    theArg = mark_julia_type(ctx, load, true, vi.value.typ);\n                    if (ctx.debug_enabled && vi.dinfo && !vi.boxroot && !vi.value.V) {\n                        SmallVector<uint64_t, 8> addr;\n                        addr.push_back(llvm::dwarf::DW_OP_deref);\n#if JL_LLVM_VERSION >= 50000\n                        addr.push_back(llvm::dwarf::DW_OP_plus_uconst);\n#else\n                        addr.push_back(llvm::dwarf::DW_OP_plus);\n#endif\n                        addr.push_back((i - 1) * sizeof(void*));\n                        if ((Metadata*)vi.dinfo->getType() != jl_pvalue_dillvmt)\n                            addr.push_back(llvm::dwarf::DW_OP_deref);\n                        dbuilder.insertDeclare(pargArray, vi.dinfo, dbuilder.createExpression(addr),\n                                        topdebugloc,\n                                        ctx.builder.GetInsertBlock());\n                    }\n                }\n            }\n\n            if (vi.boxroot == NULL) {\n                assert(vi.value.V == NULL && \"unexpected variable slot created for argument\");\n                // keep track of original (possibly boxed) value to avoid re-boxing or moving\n                vi.value = theArg;\n                if (specsig && theArg.V && ctx.debug_enabled && vi.dinfo) {\n                    SmallVector<uint64_t, 8> addr;\n                    if ((Metadata*)vi.dinfo->getType() != jl_pvalue_dillvmt && theArg.ispointer())\n                        addr.push_back(llvm::dwarf::DW_OP_deref);\n                    AllocaInst *parg = dyn_cast<AllocaInst>(theArg.V);\n                    if (!parg) {\n                        parg = ctx.builder.CreateAlloca(theArg.V->getType(), NULL, jl_symbol_name(s));\n                        ctx.builder.CreateStore(theArg.V, parg);\n                    }\n                    dbuilder.insertDeclare(parg, vi.dinfo, dbuilder.createExpression(addr),\n                                                topdebugloc,\n                                                ctx.builder.GetInsertBlock());\n                }\n            }\n            else {\n                Value *argp = boxed(ctx, theArg);\n                ctx.builder.CreateStore(argp, vi.boxroot);\n            }\n        }\n    }\n\n    // step 10. allocate rest argument\n    CallInst *restTuple = NULL;\n    if (va && ctx.vaSlot != -1) {\n        jl_varinfo_t &vi = ctx.slots[ctx.vaSlot];\n        if (vi.value.constant || !vi.used) {\n            assert(vi.boxroot == NULL);\n        }\n        else if (specsig) {\n            ctx.nvargs = jl_nparams(lam->specTypes) - nreq;\n            jl_cgval_t *vargs = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * ctx.nvargs);\n            for (size_t i = nreq; i < jl_nparams(lam->specTypes); ++i) {\n                jl_value_t *argType = jl_nth_slot_type(lam->specTypes, i);\n                bool isboxed;\n                Type *llvmArgType = julia_type_to_llvm(argType, &isboxed);\n                vargs[i - nreq] = get_specsig_arg(argType, llvmArgType, isboxed);\n            }\n            if (jl_is_concrete_type(vi.value.typ)) {\n                jl_cgval_t tuple = emit_new_struct(ctx, vi.value.typ, ctx.nvargs, vargs);\n                // FIXME: this may assert since the type of vi might not be isbits here\n                emit_varinfo_assign(ctx, vi, tuple);\n            } else {\n                jl_cgval_t tuple = mark_julia_type(ctx, emit_jlcall(ctx, prepare_call(jltuple_func), maybe_decay_untracked(V_null),\n                    vargs, ctx.nvargs), true, vi.value.typ);\n                emit_varinfo_assign(ctx, vi, tuple);\n            }\n        }\n        else {\n            // restarg = jl_f_tuple(NULL, &args[nreq], nargs - nreq)\n            restTuple =\n                ctx.builder.CreateCall(prepare_call(jltuple_func),\n                        { maybe_decay_untracked(V_null),\n                          ctx.builder.CreateInBoundsGEP(argArray,\n                                  ConstantInt::get(T_size, nreq - 1)),\n                          ctx.builder.CreateSub(argCount,\n                                  ConstantInt::get(T_int32, nreq - 1)) });\n            restTuple->setAttributes(jltuple_func->getAttributes());\n            ctx.builder.CreateStore(restTuple, vi.boxroot);\n        }\n    }\n\n    // step 11. Compute properties for each statements\n    //     This needs to be computed by iterating in the IR order\n    //     instead of control flow order.\n    auto in_user_mod = [] (jl_module_t *mod) {\n        return (!jl_is_submodule(mod, jl_base_module) &&\n                !jl_is_submodule(mod, jl_core_module));\n    };\n    bool mod_is_user_mod = in_user_mod(ctx.module);\n    struct StmtProp {\n        DebugLoc loc;\n        StringRef file;\n        ssize_t line;\n        bool loc_changed;\n        bool is_poploc;\n        bool in_user_code;\n    };\n    std::vector<StmtProp> stmtprops(stmtslen);\n    { // if new style IR\n        std::vector<DebugLoc> linetable;\n        size_t nlocs = jl_array_len(src->linetable);\n        if (ctx.debug_enabled) {\n            std::map<std::tuple<StringRef, StringRef>, DISubprogram*> subprograms;\n            linetable.resize(nlocs + 1);\n            linetable[0] = noDbg;\n            for (size_t i = 0; i < nlocs; i++) {\n                // LineInfoNode(mod::Module, method::Symbol, file::Symbol, line::Int, inlined_at::Int)\n                jl_value_t *locinfo = jl_array_ptr_ref(src->linetable, i);\n                int inlined_at, line;\n                jl_sym_t *file;\n                StringRef filename = ctx.file;\n                StringRef fname;\n                assert(jl_typeis(locinfo, jl_lineinfonode_type));\n                {\n                    jl_sym_t *method = (jl_sym_t*)jl_fieldref_noalloc(locinfo, 1);\n                    file = (jl_sym_t*)jl_fieldref_noalloc(locinfo, 2);\n                    line = jl_unbox_long(jl_fieldref(locinfo, 3));\n                    inlined_at = jl_unbox_long(jl_fieldref(locinfo, 4));\n                    assert((size_t)inlined_at <= i);\n                    filename = jl_symbol_name(file);\n                    if (filename.empty())\n                        filename = \"<missing>\";\n                    fname = jl_symbol_name(method);\n                    if (fname.empty())\n                        fname = \"macro expansion\";\n                }\n                if (inlined_at == 0 && filename == ctx.file) { // if everything matches, emit a toplevel line number\n                    linetable[i + 1] = DebugLoc::get(line, 0, SP, NULL);\n                }\n                else { // otherwise, describe this as an inlining frame\n                    DISubprogram *&inl_SP = subprograms[std::make_tuple(fname, filename)];\n                    if (inl_SP == NULL) {\n                        DIFile *difile = dbuilder.createFile(filename, \".\");\n                        inl_SP = dbuilder.createFunction(\n                                difile, std::string(fname) + \";\",\n                                fname, difile, 0, jl_di_func_null_sig,\n                                false, true, 0, DIFlagZero, true, nullptr);\n                    }\n                    DebugLoc inl_loc = (inlined_at == 0) ? DebugLoc::get(0, 0, SP, NULL) : linetable.at(inlined_at);\n                    linetable[i + 1] = DebugLoc::get(line, 0, inl_SP, inl_loc);\n                }\n            }\n        }\n        size_t prev_loc = 0;\n        for (i = 0; i < stmtslen; i++) {\n            size_t loc = ((int32_t*)jl_array_data(src->codelocs))[i];\n            StmtProp &cur_prop = stmtprops[i];\n            cur_prop.is_poploc = false;\n            if (loc > 0) {\n                jl_value_t *locinfo = jl_array_ptr_ref(src->linetable, loc - 1);\n                if (ctx.debug_enabled)\n                    cur_prop.loc = linetable.at(loc);\n                else\n                    cur_prop.loc = noDbg;\n                assert(jl_typeis(locinfo, jl_lineinfonode_type));\n                {\n                    jl_module_t *module = (jl_module_t*)jl_fieldref_noalloc(locinfo, 0);\n                    cur_prop.file = jl_symbol_name((jl_sym_t*)jl_fieldref_noalloc(locinfo, 2));\n                    cur_prop.line = jl_unbox_long(jl_fieldref(locinfo, 3));\n                    if (module == ctx.module)\n                        cur_prop.in_user_code = mod_is_user_mod;\n                    else\n                        cur_prop.in_user_code = in_user_mod(module);\n                }\n                cur_prop.loc_changed = (loc != prev_loc); // for code-coverage\n                prev_loc = loc;\n            }\n            else {\n                cur_prop.loc = noDbg;\n                cur_prop.file = \"\";\n                cur_prop.line = -1;\n                cur_prop.loc_changed = false;\n                cur_prop.in_user_code = false;\n            }\n        }\n    }\n    Instruction &prologue_end = ctx.builder.GetInsertBlock()->back();\n\n\n    // step 12. Do codegen in control flow order\n    std::vector<int> workstack;\n    std::map<int, BasicBlock*> BB;\n    std::map<size_t, BasicBlock*> come_from_bb;\n    int cursor = 0;\n    // Whether we are doing codegen in statement order.\n    // We need to update debug location if this is false even if\n    // `loc_changed` is false.\n    auto find_next_stmt = [&] (int seq_next) {\n        // new style ir is always in dominance order, but frontend IR might not be\n        // `seq_next` is the next statement we want to emit\n        // i.e. if it exists, it's the next one following control flow and\n        // should be emitted into the current insert point.\n        if (seq_next >= 0 && (unsigned)seq_next < stmtslen) {\n            workstack.push_back(seq_next);\n        }\n        else if (!ctx.builder.GetInsertBlock()->getTerminator()) {\n            ctx.builder.CreateUnreachable();\n        }\n        while (!workstack.empty()) {\n            int item = workstack.back();\n            workstack.pop_back();\n            auto nextbb = BB.find(item + 1);\n            if (nextbb == BB.end()) {\n                cursor = item;\n                return;\n            }\n            if (seq_next != -1 && !ctx.builder.GetInsertBlock()->getTerminator()) {\n                come_from_bb[cursor + 1] = ctx.builder.GetInsertBlock();\n                ctx.builder.CreateBr(nextbb->second);\n            }\n            seq_next = -1;\n            // if this BB is non-empty, we've visited it before so skip it\n            if (!nextbb->second->getTerminator()) {\n                ctx.builder.SetInsertPoint(nextbb->second);\n                cursor = item;\n                return;\n            }\n        }\n        cursor = -1;\n    };\n\n    auto do_coverage = [&] (bool in_user_code) {\n        if (!JL_FEAT_TEST(ctx, code_coverage)) return false;\n        return (coverage_mode == JL_LOG_ALL ||\n                (coverage_mode == JL_LOG_USER && in_user_code));\n    };\n    auto do_malloc_log = [&] (bool in_user_code) {\n        if (!JL_FEAT_TEST(ctx, track_allocations)) return false;\n        return (malloc_log_mode == JL_LOG_ALL ||\n                (malloc_log_mode == JL_LOG_USER && in_user_code));\n    };\n\n    come_from_bb[0] = ctx.builder.GetInsertBlock();\n\n    // First go through and collect all branch targets, so we know where to\n    // split basic blocks.\n    std::set<int> branch_targets;\n    {\n        for (size_t i = 0; i < stmtslen; ++i) {\n            jl_value_t *stmt = jl_array_ptr_ref(stmts, i);\n            if (jl_is_expr(stmt)) {\n                if (((jl_expr_t*)stmt)->head == goto_ifnot_sym) {\n                    int dest = jl_unbox_long(jl_array_ptr_ref(((jl_expr_t*)stmt)->args, 1));\n                    branch_targets.insert(dest);\n                    // The next 1-indexed statement\n                    branch_targets.insert(i + 2);\n                } else if (((jl_expr_t*)stmt)->head == return_sym) {\n                    // We don't do dead branch elimination before codegen\n                    // so we need to make sure to start a BB after any\n                    // return node, even if they aren't otherwise branch\n                    // targets.\n                    if (i + 2 <= stmtslen)\n                        branch_targets.insert(i + 2);\n                } else if (((jl_expr_t*)stmt)->head == unreachable_sym) {\n                    if (i + 2 <= stmtslen)\n                        branch_targets.insert(i + 2);\n                } else if (((jl_expr_t*)stmt)->head == enter_sym) {\n                    branch_targets.insert(i + 1);\n                    if (i + 2 <= stmtslen)\n                        branch_targets.insert(i + 2);\n                    int dest = jl_unbox_long(jl_array_ptr_ref(((jl_expr_t*)stmt)->args, 0));\n                    branch_targets.insert(dest);\n                }\n            } else if (jl_is_gotonode(stmt)) {\n                int dest = jl_gotonode_label(stmt);\n                branch_targets.insert(dest);\n                if (i + 2 <= stmtslen)\n                    branch_targets.insert(i + 2);\n            }\n        }\n    }\n\n    for (int label : branch_targets) {\n        BasicBlock *bb = BasicBlock::Create(jl_LLVMContext,\n            \"L\" + std::to_string(label), f);\n        BB[label] = bb;\n    }\n\n    if (coverage_mode != JL_LOG_NONE && do_coverage(in_user_mod(ctx.module)))\n        coverageVisitLine(ctx, filename, toplineno);\n    find_next_stmt(0);\n    while (cursor != -1) {\n        auto &props = stmtprops[cursor];\n        if (ctx.debug_enabled)\n            ctx.builder.SetCurrentDebugLocation(props.loc);\n        jl_value_t *stmt = jl_array_ptr_ref(stmts, cursor);\n        jl_expr_t *expr = jl_is_expr(stmt) ? (jl_expr_t*)stmt : nullptr;\n        // Legacy IR: disables coverage for pop_loc since it doesn't start a new expression\n        if (props.loc_changed && do_coverage(props.in_user_code) && !props.is_poploc) {\n            coverageVisitLine(ctx, props.file, props.line);\n        }\n        if (expr && expr->head == unreachable_sym) {\n            ctx.builder.CreateUnreachable();\n            find_next_stmt(-1);\n            continue;\n        }\n        if (expr && expr->head == return_sym) {\n            // this is basically a copy of emit_assignment,\n            // but where the assignment slot is the retval\n            jl_cgval_t retvalinfo = emit_expr(ctx, jl_exprarg(expr, 0));\n            retvalinfo = convert_julia_type(ctx, retvalinfo, jlrettype);\n            if (retvalinfo.typ == jl_bottom_type) {\n                ctx.builder.CreateUnreachable();\n                find_next_stmt(-1);\n                continue;\n            }\n\n            Value *isboxed_union = NULL;\n            Value *retval;\n            Value *sret = ctx.has_sret ? &*f->arg_begin() : NULL;\n            Type *retty = f->getReturnType();\n            switch (returninfo.cc) {\n            case jl_returninfo_t::Boxed:\n                retval = boxed(ctx, retvalinfo); // skip the gcroot on the return path\n                break;\n            case jl_returninfo_t::Register:\n                if (type_is_ghost(retty))\n                    retval = NULL;\n                else\n                    retval = emit_unbox(ctx, retty, retvalinfo, jlrettype);\n                break;\n            case jl_returninfo_t::SRet:\n                retval = NULL;\n                break;\n            case jl_returninfo_t::Union: {\n                Value *data, *tindex;\n                if (retvalinfo.TIndex) {\n                    tindex = retvalinfo.TIndex;\n                    if (retvalinfo.V == NULL) {\n                        // treat this as a simple Ghosts\n                        data = maybe_decay_untracked(V_null);\n                        sret = NULL;\n                    }\n                    else {\n                        data = maybe_decay_untracked(V_null);\n                        if (retvalinfo.Vboxed) {\n                            // also need to account for the possibility the return object is boxed\n                            // and avoid / skip copying it to the stack\n                            isboxed_union = ctx.builder.CreateICmpNE(\n                                    ctx.builder.CreateAnd(tindex, ConstantInt::get(T_int8, 0x80)),\n                                    ConstantInt::get(T_int8, 0));\n                            data = ctx.builder.CreateSelect(isboxed_union, retvalinfo.Vboxed, data);\n                        }\n                    }\n                }\n                else {\n                    // treat this as a simple boxed returninfo\n                    //assert(retvalinfo.isboxed);\n                    tindex = compute_tindex_unboxed(ctx, retvalinfo, jlrettype);\n                    tindex = ctx.builder.CreateOr(tindex, ConstantInt::get(T_int8, 0x80));\n                    data = maybe_decay_untracked(boxed(ctx, retvalinfo));\n                    sret = NULL;\n                }\n                retval = UndefValue::get(retty);\n                retval = ctx.builder.CreateInsertValue(retval, data, 0);\n                retval = ctx.builder.CreateInsertValue(retval, tindex, 1);\n                break;\n            }\n            case jl_returninfo_t::Ghosts:\n                retval = compute_tindex_unboxed(ctx, retvalinfo, jlrettype);\n                break;\n            }\n            if (sret) {\n                if (retvalinfo.ispointer()) {\n                    if (returninfo.cc == jl_returninfo_t::SRet) {\n                        assert(jl_is_concrete_type(jlrettype));\n                        emit_memcpy(ctx, sret, nullptr, retvalinfo, jl_datatype_size(jlrettype),\n                                    julia_alignment(jlrettype));\n                    }\n                    else { // must be jl_returninfo_t::Union\n                        emit_unionmove(ctx, sret, nullptr, retvalinfo, /*skip*/isboxed_union);\n                    }\n                }\n                else {\n                    Type *store_ty = julia_type_to_llvm(retvalinfo.typ);\n                    Type *dest_ty = store_ty->getPointerTo();\n                    if (dest_ty != sret->getType())\n                        sret = emit_bitcast(ctx, sret, dest_ty);\n                    ctx.builder.CreateStore(emit_unbox(ctx, store_ty, retvalinfo, retvalinfo.typ), sret);\n                }\n            }\n\n            if (do_malloc_log(props.in_user_code) && props.line != -1)\n                mallocVisitLine(ctx, props.file, props.line);\n            if (toplevel)\n                ctx.builder.CreateStore(last_age, ctx.world_age_field);\n            assert(type_is_ghost(retty) || returninfo.cc == jl_returninfo_t::SRet ||\n                retval->getType() == ctx.f->getReturnType());\n            ctx.builder.CreateRet(retval);\n            find_next_stmt(-1);\n            continue;\n        }\n        if (jl_is_gotonode(stmt)) {\n            int lname = jl_gotonode_label(stmt);\n            come_from_bb[cursor+1] = ctx.builder.GetInsertBlock();\n            ctx.builder.CreateBr(BB[lname]);\n            find_next_stmt(lname - 1);\n            continue;\n        }\n        if (jl_is_upsilonnode(stmt)) {\n            jl_value_t *val = jl_fieldref_noalloc(stmt, 0);\n            // If the val is null, we can ignore the store.\n            // The middle end guarantees that the value from this\n            // upsilon node is not dynamically observed.\n            if (val) {\n                jl_cgval_t rval_info = emit_expr(ctx, val);\n                jl_varinfo_t &vi = ctx.phic_slots[upsilon_to_phic[cursor+1]];\n                emit_varinfo_assign(ctx, vi, rval_info);\n            }\n            find_next_stmt(cursor + 1);\n            continue;\n        }\n        if (expr && expr->head == goto_ifnot_sym) {\n            jl_value_t **args = (jl_value_t**)jl_array_data(expr->args);\n            jl_value_t *cond = args[0];\n            int lname = jl_unbox_long(args[1]);\n            Value *isfalse = emit_condition(ctx, cond, \"if\");\n            if (do_malloc_log(props.in_user_code) && props.line != -1)\n                mallocVisitLine(ctx, props.file, props.line);\n            come_from_bb[cursor+1] = ctx.builder.GetInsertBlock();\n            workstack.push_back(lname - 1);\n            BasicBlock *ifnot = BB[lname];\n            BasicBlock *ifso = BB[cursor+2];\n            if (ifnot == ifso)\n                ctx.builder.CreateBr(ifnot);\n            else\n                ctx.builder.CreateCondBr(isfalse, ifnot, ifso);\n            find_next_stmt(cursor + 1);\n            continue;\n        }\n        else if (expr && expr->head == enter_sym) {\n            jl_value_t **args = (jl_value_t**)jl_array_data(expr->args);\n\n            assert(jl_is_long(args[0]));\n            int lname = jl_unbox_long(args[0]);\n            CallInst *sj = ctx.builder.CreateCall(prepare_call(except_enter_func));\n            // We need to mark this on the call site as well. See issue #6757\n            sj->setCanReturnTwice();\n            Value *isz = ctx.builder.CreateICmpEQ(sj, ConstantInt::get(T_int32, 0));\n            BasicBlock *tryblk = BasicBlock::Create(jl_LLVMContext, \"try\", f);\n            BasicBlock *handlr = NULL;\n            handlr = BB[lname];\n            workstack.push_back(lname - 1);\n            come_from_bb[cursor + 1] = ctx.builder.GetInsertBlock();\n#ifdef _OS_WINDOWS_\n            BasicBlock *cond_resetstkoflw_blk = BasicBlock::Create(jl_LLVMContext, \"cond_resetstkoflw\", f);\n            BasicBlock *resetstkoflw_blk = BasicBlock::Create(jl_LLVMContext, \"resetstkoflw\", f);\n            ctx.builder.CreateCondBr(isz, tryblk, cond_resetstkoflw_blk);\n            ctx.builder.SetInsertPoint(cond_resetstkoflw_blk);\n            ctx.builder.CreateCondBr(ctx.builder.CreateICmpEQ(\n                                     maybe_decay_untracked(literal_pointer_val(ctx, jl_stackovf_exception)),\n                                     ctx.builder.CreateLoad(emit_exc_in_transit(ctx), /*isvolatile*/true)),\n                                 resetstkoflw_blk, handlr);\n            ctx.builder.SetInsertPoint(resetstkoflw_blk);\n            ctx.builder.CreateCall(prepare_call(resetstkoflw_func), {});\n            ctx.builder.CreateBr(handlr);\n#else\n            ctx.builder.CreateCondBr(isz, tryblk, handlr);\n#endif\n            ctx.builder.SetInsertPoint(tryblk);\n        }\n        else {\n            emit_stmtpos(ctx, stmt, cursor);\n            if (do_malloc_log(props.in_user_code) && props.line != -1) {\n                mallocVisitLine(ctx, props.file, props.line);\n            }\n        }\n        find_next_stmt(cursor + 1);\n    }\n\n    // Delete any unreachable blocks\n    for (auto &item : BB) {\n        if (!item.second->getTerminator())\n            item.second->eraseFromParent();\n    }\n\n    ctx.builder.SetCurrentDebugLocation(noDbg);\n    ctx.builder.ClearInsertionPoint();\n\n    auto undef_value_for_type = [&](jl_value_t *phiType, Type *UndefType) {\n        Value *VNUndef;\n        if (UndefType == T_prjlvalue) {\n            VNUndef =  (llvm::Value*)ConstantPointerNull::get(cast<PointerType>(T_prjlvalue));\n        } else {\n            VNUndef = (llvm::Value*)UndefValue::get(UndefType);\n        }\n        return VNUndef;\n    };\n\n    // Codegen Phi nodes\n    std::map<std::pair<BasicBlock *, BasicBlock*>, BasicBlock*> BB_rewrite_map;\n    std::vector<llvm::PHINode*> ToDelete;\n    for (auto &tup : ctx.PhiNodes) {\n        jl_cgval_t phi_result;\n        PHINode *VN;\n        jl_value_t *r;\n        AllocaInst *dest;\n        BasicBlock *PhiBB;\n        std::tie(phi_result, PhiBB, dest, VN, r) = tup;\n        jl_value_t *phiType = phi_result.typ;\n        jl_array_t *edges = (jl_array_t*)jl_fieldref_noalloc(r, 0);\n        jl_array_t *values = (jl_array_t*)jl_fieldref_noalloc(r, 1);\n        PHINode *TindexN = cast_or_null<PHINode>(phi_result.TIndex);\n        for (size_t i = 0; i < jl_array_len(edges); ++i) {\n            size_t edge = jl_unbox_long(jl_array_ptr_ref(edges, i));\n            jl_value_t *value = jl_array_ptr_ref(values, i);\n            Value *V = NULL;\n            BasicBlock *IncomingBB = come_from_bb[edge];\n            BasicBlock *FromBB = IncomingBB;\n            std::pair<BasicBlock *, BasicBlock*> LookupKey(IncomingBB, PhiBB);\n            if (BB_rewrite_map.count(LookupKey)) {\n                FromBB = BB_rewrite_map[LookupKey];\n            }\n            // This edge was statically unreachable. Don't codegen it.\n            if (!FromBB)\n                continue;\n            // We folded this branch to an unconditional branch, only codegen it once\n            if (cast<BranchInst>(FromBB->getTerminator())->isUnconditional()) {\n                bool found = false;\n                for (size_t j = 0; j < i; ++j) {\n                    size_t j_edge = jl_unbox_long(jl_array_ptr_ref(edges, j));\n                    if (j_edge == edge) {\n                        found = true;\n                        assert(jl_egal(value, jl_array_ptr_ref(values, j)));\n                    }\n                }\n                if (found)\n                    continue;\n            }\n#ifndef JL_NDEBUG\n            if (FromBB) {\n                bool found_pred = false;\n                for (BasicBlock *pred : predecessors(PhiBB)) {\n                    found_pred = pred == FromBB;\n                    if (found_pred)\n                        break;\n                }\n                assert(found_pred);\n            }\n#endif\n            ctx.builder.SetInsertPoint(FromBB->getTerminator());\n            if (dest)\n                ctx.builder.CreateLifetimeStart(dest);\n            jl_cgval_t val;\n            if (!value || jl_is_ssavalue(value)) {\n                ssize_t idx = value ? ((jl_ssavalue_t*)value)->id : 0;\n                idx -= 1;\n                if (!value || !ctx.ssavalue_assigned.at(idx)) {\n                    Value *RTindex = TindexN ? UndefValue::get(T_int8) : NULL;\n                    if (VN) { // otherwise, it's all-unboxed\n                        Value *undef;\n                        if (isa<PointerType>(VN->getType())) {\n                            bool isboxed;\n                            Type *lphity = julia_type_to_llvm(phiType, &isboxed);\n                            if (!isboxed) {\n                                // the emit_phinode_assign emitted a memcpy in this case,\n                                // so this needs to ensure the pointer is valid, while the contents are undef\n                                undef = decay_derived(emit_static_alloca(ctx, lphity));\n                            }\n                            else {\n                                // but make sure gc pointers (including ptr_phi of union-split) are NULL\n                                undef = ConstantPointerNull::get(cast<PointerType>(VN->getType()));\n                                if (TindexN) // let the runtime / optimizer know this is unknown / boxed / null, so that it won't try to union_move / copy it later\n                                    RTindex = ConstantInt::get(T_int8, 0x80);\n                            }\n                        }\n                        else {\n                            undef = undef_value_for_type(phiType, VN->getType());\n                        }\n                        VN->addIncoming(undef, FromBB);\n                    }\n                    if (TindexN)\n                        TindexN->addIncoming(RTindex, FromBB);\n                    continue;\n                }\n                val = ctx.SAvalues.at(idx);\n            }\n            else {\n                val = emit_expr(ctx, value);\n            }\n            if (val.constant)\n                val = mark_julia_const(val.constant); // be over-conservative at making sure `.typ` is set concretely, not tindex\n            TerminatorInst *terminator = FromBB->getTerminator();\n            if (!isa<BranchInst>(terminator) ||\n                (cast<BranchInst>(terminator)->isConditional() &&\n                 !(terminator->getSuccessor(0) == terminator->getSuccessor(1)))) {\n                bool found = false;\n                for (size_t i = 0; i < terminator->getNumSuccessors(); ++i) {\n                    if (terminator->getSuccessor(i) == PhiBB) {\n                        // Can't use `llvm::SplitCriticalEdge` here because\n                        // we may have invalid phi nodes in the destination.\n                        BasicBlock *NewBB = BasicBlock::Create(terminator->getContext(),\n                           FromBB->getName() + \".\" + PhiBB->getName() + \"_crit_edge\");\n                        terminator->setSuccessor(i, NewBB);\n                        Function::iterator FBBI = FromBB->getIterator();\n                        ctx.f->getBasicBlockList().insert(++FBBI, NewBB);\n                        ctx.builder.SetInsertPoint(NewBB);\n                        terminator = BranchInst::Create(PhiBB);\n                        found = true;\n                        break;\n                    }\n                }\n                assert(found);\n            }\n            else {\n                terminator->removeFromParent();\n                ctx.builder.SetInsertPoint(FromBB);\n            }\n            if (!jl_is_uniontype(phiType) || !TindexN) {\n                if (VN) {\n                    // XXX: this code assumes that `val` is of type `phiType` statically,\n                    // that must be true dynamically, but we have not propagated that information here,\n                    // and thus this might generate invalid code\n                    if (val.typ == (jl_value_t*)jl_bottom_type) {\n                        V = undef_value_for_type(phiType, VN->getType());\n                    }\n                    else if (VN && VN->getType() == T_prjlvalue) {\n                        // Includes the jl_is_uniontype(phiType) && !TindexN case\n                        V = boxed(ctx, val);\n                    }\n                    else {\n                        V = emit_unbox(ctx, VN->getType(), val, phiType);\n                    }\n                    VN->addIncoming(V, ctx.builder.GetInsertBlock());\n                    assert(!TindexN);\n                } else if (dest && val.typ != (jl_value_t*)jl_bottom_type) {\n                    ctx.builder.CreateMemCpy(maybe_decay_tracked(dest),\n                        maybe_decay_tracked(data_pointer(ctx, val)),\n                        jl_datatype_size(phiType),\n                        jl_datatype_align(phiType),\n                        false);\n                }\n            }\n            else {\n                Value *RTindex = NULL;\n                if (val.typ == (jl_value_t*)jl_bottom_type) {\n                    V = undef_value_for_type(phiType, VN->getType());\n                    RTindex = UndefValue::get(T_int8);\n                }\n                else if (jl_is_concrete_type(val.typ) || val.constant) {\n                    size_t tindex = get_box_tindex((jl_datatype_t*)val.typ, phiType);\n                    if (tindex == 0) {\n                        V = boxed(ctx, val);\n                        RTindex = ConstantInt::get(T_int8, 0x80);\n                    }\n                    else {\n                        V = ConstantPointerNull::get(cast<PointerType>(T_prjlvalue));\n                        Type *lty = julia_type_to_llvm(val.typ);\n                        if (dest && !type_is_ghost(lty)) // basically, if !ghost union\n                            emit_unbox(ctx, lty, val, val.typ, dest);\n                        RTindex = ConstantInt::get(T_int8, tindex);\n                    }\n                }\n                else {\n                    jl_cgval_t new_union = convert_julia_type(ctx, val, phiType);\n                    RTindex = new_union.TIndex;\n                    if (!RTindex) {\n                        assert(new_union.isboxed && new_union.Vboxed && \"convert_julia_type failed\");\n                        RTindex = compute_tindex_unboxed(ctx, new_union, phiType);\n                        if (dest) {\n                            // If dest is not set, this is a ghost union, the recipient of which\n                            // is often not prepared to handle a boxed representation of the ghost.\n                            RTindex = ctx.builder.CreateOr(RTindex, ConstantInt::get(T_int8, 0x80));\n                        }\n                        new_union.TIndex = RTindex;\n                    }\n                    V = new_union.Vboxed ? new_union.Vboxed : ConstantPointerNull::get(cast<PointerType>(T_prjlvalue));\n                    if (dest) { // basically, if !ghost union\n                        Value *skip = NULL;\n                        if (new_union.Vboxed != nullptr)\n                            skip = ctx.builder.CreateICmpNE( // if 0x80 is set, we won't select this slot anyways\n                                    ctx.builder.CreateAnd(RTindex, ConstantInt::get(T_int8, 0x80)),\n                                    ConstantInt::get(T_int8, 0));\n                        emit_unionmove(ctx, dest, tbaa_arraybuf, new_union, skip);\n                    }\n                }\n                if (VN)\n                    VN->addIncoming(V, ctx.builder.GetInsertBlock());\n                if (TindexN)\n                    TindexN->addIncoming(RTindex, ctx.builder.GetInsertBlock());\n            }\n            ctx.builder.Insert(terminator);\n            // Check any phi nodes in the Phi block to see if by splitting the edges,\n            // we made things inconsistent\n            if (FromBB != ctx.builder.GetInsertBlock()) {\n                BB_rewrite_map[LookupKey] = ctx.builder.GetInsertBlock();\n                for (BasicBlock::iterator I = PhiBB->begin(); isa<PHINode>(I); ++I) {\n                    PHINode *PN = cast<PHINode>(I);\n                    ssize_t BBIdx = PN->getBasicBlockIndex(FromBB);\n                    if (BBIdx == -1)\n                        continue;\n                    PN->setIncomingBlock(BBIdx, ctx.builder.GetInsertBlock());\n                }\n            }\n        }\n        // In LLVM IR it is illegal to have phi nodes without incoming values, even if\n        // there are no operands, so delete any such phi nodes\n        if (pred_begin(PhiBB) == pred_end(PhiBB))\n        {\n            if (VN)\n                ToDelete.push_back(VN);\n            if (TindexN)\n                ToDelete.push_back(TindexN);\n            continue;\n        }\n        // Julia PHINodes may be incomplete with respect to predecessors, LLVM's may not\n        Value *VNUndef = nullptr;\n        if (VN || TindexN) {\n            for (auto *pred : predecessors(PhiBB)) {\n                PHINode *PhiN = VN ? VN : TindexN;\n                bool found = false;\n                for (size_t i = 0; i < PhiN->getNumIncomingValues(); ++i) {\n                    found = pred == PhiN->getIncomingBlock(i);\n                    if (found)\n                        break;\n                }\n                if (!found) {\n                    if (VN) {\n                        if (!VNUndef) {\n                            VNUndef = undef_value_for_type(phiType, VN->getType());\n                        }\n                        VN->addIncoming(VNUndef, pred);\n                    }\n                    if (TindexN) {\n                        TindexN->addIncoming(UndefValue::get(TindexN->getType()), pred);\n                    }\n                }\n            }\n        }\n    }\n\n    for (PHINode *PN : ToDelete) {\n        PN->replaceAllUsesWith(UndefValue::get(PN->getType()));\n        PN->eraseFromParent();\n    }\n\n    // step 13. Perform any delayed instantiations\n    if (ctx.debug_enabled) {\n        bool in_prologue = true;\n        for (auto &BB : *ctx.f) {\n            for (auto &I : BB) {\n                CallSite call(&I);\n                if (call && !I.getDebugLoc()) {\n                    // LLVM Verifier: inlinable function call in a function with debug info must have a !dbg location\n                    // make sure that anything we attempt to call has some inlining info, just in case optimization messed up\n                    // (except if we know that it is an intrinsic used in our prologue, which should never have its own debug subprogram)\n                    Function *F = call.getCalledFunction();\n                    if (!in_prologue || !F || !(F->isIntrinsic() || F->getName().startswith(\"julia.\") || &I == restTuple)) {\n                        I.setDebugLoc(topdebugloc);\n                    }\n                }\n                if (&I == &prologue_end)\n                    in_prologue = false;\n            }\n        }\n        dbuilder.finalize();\n    }\n\n    if (ctx.vaSlot > 0) {\n        // remove VA allocation if we never referenced it\n        Instruction *root = cast_or_null<Instruction>(ctx.slots[ctx.vaSlot].boxroot);\n        if (root) {\n            Instruction *store_value = NULL;\n            bool have_real_use = false;\n            for (Use &U : root->uses()) {\n                User *RU = U.getUser();\n                if (StoreInst *SRU = dyn_cast<StoreInst>(RU)) {\n                    if (!store_value)\n                        store_value = dyn_cast<Instruction>(SRU->getValueOperand());\n                }\n                else if (isa<DbgInfoIntrinsic>(RU)) {\n                }\n                else if (isa<LoadInst>(RU) && RU->use_empty()) {\n                }\n                else {\n                    have_real_use = true;\n                    break;\n                }\n            }\n            if (!have_real_use) {\n                Instruction *use = NULL;\n                for (Use &U : root->uses()) {\n                    if (use) // erase after the iterator moves on\n                        use->eraseFromParent();\n                    User *RU = U.getUser();\n                    use = cast<Instruction>(RU);\n                }\n                if (use)\n                    use->eraseFromParent();\n                root->eraseFromParent();\n                assert(!store_value || store_value == restTuple);\n                restTuple->eraseFromParent();\n            }\n        }\n    }\n\n    // copy ctx.roots into m->roots\n    // if we created any new roots during codegen\n    if (ctx.roots) {\n        jl_method_t *m = lam->def.method;\n        JL_LOCK(&m->writelock);\n        if (m->roots == NULL) {\n            m->roots = ctx.roots;\n            jl_gc_wb(m, m->roots);\n        }\n        else {\n            size_t i, ilen = jl_array_dim0(ctx.roots);\n            size_t j, jlen = jl_array_dim0(m->roots);\n            for (i = 0; i < ilen; i++) {\n                jl_value_t *ival = jl_array_ptr_ref(ctx.roots, i);\n                for (j = 0; j < jlen; j++) {\n                    jl_value_t *jval = jl_array_ptr_ref(m->roots, j);\n                    if (ival == jval)\n                        break;\n                }\n                if (j == jlen) // not found - add to array\n                    jl_array_ptr_1d_push(m->roots, ival);\n            }\n        }\n        ctx.roots = NULL;\n        JL_UNLOCK(&m->writelock);\n    }\n\n    if (JL_HOOK_TEST(ctx.params, emitted_function)) {\n        JL_HOOK_CALL(ctx.params, emitted_function, 3, (jl_value_t*)ctx.linfo,\n                     (jl_value_t*)ctx.source, jl_box_ulong(world));\n    }\n\n    JL_GC_POP();\n    return std::unique_ptr<Module>(M);\n}\n\n// --- initialization ---\n\nstd::pair<MDNode*,MDNode*> tbaa_make_child(const char *name, MDNode *parent=nullptr, bool isConstant=false)\n{\n    static MDBuilder *mbuilder = new MDBuilder(jl_LLVMContext);\n    static MDNode *tbaa_root = mbuilder->createTBAARoot(\"jtbaa\");\n    if (!parent)\n        parent = tbaa_root;\n    MDNode *scalar = mbuilder->createTBAAScalarTypeNode(name, parent);\n    MDNode *n = mbuilder->createTBAAStructTagNode(scalar, scalar, 0, isConstant);\n    return std::make_pair(n, scalar);\n}\n\nstatic GlobalVariable *global_to_llvm(const std::string &cname, void *addr, Module *m)\n{\n    GlobalVariable *gv =\n        new GlobalVariable(*m, T_pjlvalue, true,\n                           GlobalVariable::ExternalLinkage, NULL, cname);\n    add_named_global(gv, addr);\n    return gv;\n}\nllvm::SmallVector<std::pair<jl_value_t**, GlobalVariable*>, 16> gv_for_global;\nstatic GlobalVariable *global_jlvalue_to_llvm(const std::string &cname, jl_value_t **addr, Module *m)\n{\n    GlobalVariable *gv = global_to_llvm(cname, (void*)addr, m);\n    gv_for_global.push_back(std::make_pair(addr, gv));\n    return gv;\n}\nstatic GlobalVariable *julia_const_gv(jl_value_t *val)\n{\n    for (auto& kv : gv_for_global) {\n        if (*kv.first == val)\n            return kv.second;\n    }\n    return nullptr;\n}\n\n// TODO: do this lazily\nextern \"C\" void jl_fptr_to_llvm(void *fptr, jl_method_instance_t *lam, int specsig)\n{\n    if (!imaging_mode) { // in imaging mode, it's fine to use the fptr, but we don't want it in the shadow_module\n        // this assigns a function pointer (from loading the system image), to the function object\n        std::stringstream funcName;\n        if (!specsig)\n            funcName << \"jsys_\"; // the invoke implementation wrapper\n        else if (lam->invoke == jl_fptr_args)\n            funcName << \"jsys1_\";\n        else if (lam->invoke == jl_fptr_sparam)\n            funcName << \"jsys3_\";\n        else\n            funcName << \"julia_\"; // it's a specsig call\n        const char* unadorned_name = jl_symbol_name(lam->def.method->name);\n        funcName << unadorned_name << \"_\" << globalUnique++;\n        Function *f = Function::Create(jl_func_sig, Function::ExternalLinkage, funcName.str());\n        add_named_global(f, fptr);\n        const char **fdecl;\n        if (specsig) {\n            fdecl = &lam->functionObjectsDecls.specFunctionObject;\n            if (lam->invoke == jl_fptr_args)\n                lam->functionObjectsDecls.functionObject = \"jl_fptr_args\";\n            else if (lam->invoke == jl_fptr_sparam)\n                lam->functionObjectsDecls.functionObject = \"jl_fptr_sparam\";\n        }\n        else {\n            fdecl = &lam->functionObjectsDecls.functionObject;\n        }\n        assert(!*fdecl);\n        *fdecl = strdup(f->getName().str().c_str());\n        delete f;\n    }\n}\n\nstatic void init_julia_llvm_meta(void)\n{\n    tbaa_gcframe = tbaa_make_child(\"jtbaa_gcframe\").first;\n    tbaa_stack = tbaa_make_child(\"jtbaa_stack\").first;\n    MDNode *tbaa_data_scalar;\n    std::tie(tbaa_data, tbaa_data_scalar) = tbaa_make_child(\"jtbaa_data\");\n    tbaa_binding = tbaa_make_child(\"jtbaa_binding\", tbaa_data_scalar).first;\n    MDNode *tbaa_value_scalar;\n    std::tie(tbaa_value, tbaa_value_scalar) =\n        tbaa_make_child(\"jtbaa_value\", tbaa_data_scalar);\n    tbaa_mutab = tbaa_make_child(\"jtbaa_mutab\", tbaa_value_scalar).first;\n    tbaa_immut = tbaa_make_child(\"jtbaa_immut\", tbaa_value_scalar).first;\n    tbaa_arraybuf = tbaa_make_child(\"jtbaa_arraybuf\", tbaa_data_scalar).first;\n    tbaa_ptrarraybuf = tbaa_make_child(\"jtbaa_ptrarraybuf\", tbaa_data_scalar).first;\n    MDNode *tbaa_array_scalar;\n    std::tie(tbaa_array, tbaa_array_scalar) = tbaa_make_child(\"jtbaa_array\");\n    tbaa_arrayptr = tbaa_make_child(\"jtbaa_arrayptr\", tbaa_array_scalar).first;\n    tbaa_arraysize = tbaa_make_child(\"jtbaa_arraysize\", tbaa_array_scalar).first;\n    tbaa_arraylen = tbaa_make_child(\"jtbaa_arraylen\", tbaa_array_scalar).first;\n    tbaa_arrayflags = tbaa_make_child(\"jtbaa_arrayflags\", tbaa_array_scalar).first;\n    tbaa_arrayoffset = tbaa_make_child(\"jtbaa_arrayoffset\", tbaa_array_scalar).first;\n    tbaa_const = tbaa_make_child(\"jtbaa_const\", nullptr, true).first;\n    tbaa_arrayselbyte = tbaa_make_child(\"jtbaa_arrayselbyte\", tbaa_array_scalar).first;\n    tbaa_unionselbyte = tbaa_make_child(\"jtbaa_unionselbyte\", tbaa_data_scalar).first;\n\n    Thunk = Attribute::get(jl_LLVMContext, \"thunk\");\n}\n\nstatic Function *jlcall_func_to_llvm(const std::string &cname, jl_fptr_args_t addr, Module *m)\n{\n    Function *f = Function::Create(jl_func_sig, Function::ExternalLinkage, cname, m);\n    add_return_attr(f, Attribute::NonNull);\n    f->addFnAttr(Thunk);\n    add_named_global(f, addr);\n    return f;\n}\n\nstatic void init_julia_llvm_env(Module *m)\n{\n    // every variable or function mapped in this function must be\n    // exported from libjulia, to support static compilation\n    T_int1  = Type::getInt1Ty(jl_LLVMContext);\n    T_int8  = Type::getInt8Ty(jl_LLVMContext);\n    T_pint8 = PointerType::get(T_int8, 0);\n    T_ppint8 = PointerType::get(T_pint8, 0);\n    T_pppint8 = PointerType::get(T_ppint8, 0);\n    T_int16 = Type::getInt16Ty(jl_LLVMContext);\n    T_pint16 = PointerType::get(T_int16, 0);\n    T_int32 = Type::getInt32Ty(jl_LLVMContext);\n    T_char = Type::getInt32Ty(jl_LLVMContext);\n    T_pint32 = PointerType::get(T_int32, 0);\n    T_int64 = Type::getInt64Ty(jl_LLVMContext);\n    T_pint64 = PointerType::get(T_int64, 0);\n    T_uint8 = T_int8;   T_uint16 = T_int16;\n    T_uint32 = T_int32; T_uint64 = T_int64;\n    if (sizeof(size_t) == 8)\n        T_size = T_uint64;\n    else\n        T_size = T_uint32;\n    T_sigatomic = Type::getIntNTy(jl_LLVMContext, sizeof(sig_atomic_t) * 8);\n    T_psize = PointerType::get(T_size, 0);\n    T_float16 = Type::getHalfTy(jl_LLVMContext);\n    T_float32 = Type::getFloatTy(jl_LLVMContext);\n    T_pfloat32 = PointerType::get(T_float32, 0);\n    T_float64 = Type::getDoubleTy(jl_LLVMContext);\n    T_pfloat64 = PointerType::get(T_float64, 0);\n    T_float128 = Type::getFP128Ty(jl_LLVMContext);\n    T_void = Type::getVoidTy(jl_LLVMContext);\n    T_pvoidfunc = FunctionType::get(T_void, /*isVarArg*/false)->getPointerTo();\n\n    auto T_pint8_derived = PointerType::get(T_int8, AddressSpace::Derived);\n\n    // add needed base debugging definitions to our LLVM environment\n    DIBuilder dbuilder(*m);\n    DIFile *julia_h = dbuilder.createFile(\"julia.h\",\"\");\n    jl_value_dillvmt = dbuilder.createStructType(nullptr,\n        \"jl_value_t\",\n        julia_h,\n        71, // At the time of this writing. Not sure if it's worth it to keep this in sync\n        0 * 8, // sizeof(jl_value_t) * 8,\n        __alignof__(void*) * 8, // __alignof__(jl_value_t) * 8,\n        DIFlagZero, // Flags\n        nullptr,    // Derived from\n        nullptr);  // Elements - will be corrected later\n\n    jl_pvalue_dillvmt = dbuilder.createPointerType(jl_value_dillvmt, sizeof(jl_value_t*) * 8,\n                                                   __alignof__(jl_value_t*) * 8);\n\n    SmallVector<llvm::Metadata *, 1> Elts;\n    std::vector<Metadata*> diargs(0);\n    Elts.push_back(jl_pvalue_dillvmt);\n    dbuilder.replaceArrays(jl_value_dillvmt,\n       dbuilder.getOrCreateArray(Elts));\n\n    jl_ppvalue_dillvmt = dbuilder.createPointerType(jl_pvalue_dillvmt,sizeof(jl_value_t**)*8,\n                                                    __alignof__(jl_value_t**)*8);\n\n    diargs.push_back(jl_pvalue_dillvmt);    // Return Type (ret value)\n    diargs.push_back(jl_pvalue_dillvmt);    // First Argument (function)\n    diargs.push_back(jl_ppvalue_dillvmt);   // Second Argument (argv)\n    // Third argument (length(argv))\n    diargs.push_back(julia_type_to_di((jl_value_t*)jl_int32_type,&dbuilder,false));\n\n    jl_di_func_sig = dbuilder.createSubroutineType(\n        dbuilder.getOrCreateTypeArray(diargs));\n    jl_di_func_null_sig = dbuilder.createSubroutineType(\n        dbuilder.getOrCreateTypeArray(None));\n\n    T_jlvalue = StructType::create(jl_LLVMContext, \"jl_value_t\");\n    T_pjlvalue = PointerType::get(T_jlvalue, 0);\n    T_prjlvalue = PointerType::get(T_jlvalue, AddressSpace::Tracked);\n    T_ppjlvalue = PointerType::get(T_pjlvalue, 0);\n    T_pprjlvalue = PointerType::get(T_prjlvalue, 0);\n    two_pvalue_llvmt.push_back(T_pjlvalue);\n    two_pvalue_llvmt.push_back(T_pjlvalue);\n    three_pvalue_llvmt.push_back(T_pjlvalue);\n    three_pvalue_llvmt.push_back(T_pjlvalue);\n    three_pvalue_llvmt.push_back(T_pjlvalue);\n    four_pvalue_llvmt.push_back(T_pjlvalue);\n    four_pvalue_llvmt.push_back(T_pjlvalue);\n    four_pvalue_llvmt.push_back(T_pjlvalue);\n    four_pvalue_llvmt.push_back(T_pjlvalue);\n    V_null = Constant::getNullValue(T_pjlvalue);\n    jl_init_jit(T_pjlvalue);\n\n    std::vector<Type*> ftargs(0);\n    ftargs.push_back(T_pprjlvalue);  // linfo->sparam_vals\n    ftargs.push_back(T_prjlvalue);  // function\n    ftargs.push_back(T_pprjlvalue); // args[]\n    ftargs.push_back(T_int32);      // nargs\n    jl_func_sig_sparams = FunctionType::get(T_prjlvalue, ftargs, false);\n    assert(jl_func_sig_sparams != NULL);\n    ftargs.erase(ftargs.begin());  // drop linfo->sparams_vals argument\n    jl_func_sig = FunctionType::get(T_prjlvalue, ftargs, false);\n    assert(jl_func_sig != NULL);\n\n    Type *vaelts[] = {PointerType::get(T_int8, AddressSpace::Loaded)\n#ifdef STORE_ARRAY_LEN\n                      , T_size\n#endif\n                      , T_int16\n                      , T_int16\n                      , T_int32\n    };\n    static_assert(sizeof(jl_array_flags_t) == sizeof(int16_t),\n                  \"Size of jl_array_flags_t is not the same as int16_t\");\n    jl_array_llvmt =\n        StructType::create(jl_LLVMContext, makeArrayRef(vaelts), \"jl_array_t\");\n    jl_parray_llvmt = PointerType::get(jl_array_llvmt, 0);\n\n    global_to_llvm(\"__stack_chk_guard\", (void*)&__stack_chk_guard, m);\n    Function *jl__stack_chk_fail =\n        Function::Create(FunctionType::get(T_void, false),\n                         Function::ExternalLinkage,\n                         \"__stack_chk_fail\", m);\n    jl__stack_chk_fail->setDoesNotReturn();\n    add_named_global(jl__stack_chk_fail, &__stack_chk_fail);\n\n    global_jlvalue_to_llvm(\"jl_true\", &jl_true, m);\n    global_jlvalue_to_llvm(\"jl_false\", &jl_false, m);\n    global_jlvalue_to_llvm(\"jl_emptysvec\", (jl_value_t**)&jl_emptysvec, m);\n    global_jlvalue_to_llvm(\"jl_emptytuple\", &jl_emptytuple, m);\n    global_jlvalue_to_llvm(\"jl_diverror_exception\", &jl_diverror_exception, m);\n    global_jlvalue_to_llvm(\"jl_undefref_exception\", &jl_undefref_exception, m);\n\n    jlRTLD_DEFAULT_var =\n        new GlobalVariable(*m, T_pint8,\n                           true, GlobalVariable::ExternalLinkage,\n                           NULL, \"jl_RTLD_DEFAULT_handle\");\n    add_named_global(jlRTLD_DEFAULT_var, &jl_RTLD_DEFAULT_handle);\n#ifdef _OS_WINDOWS_\n    jlexe_var =\n        new GlobalVariable(*m, T_pint8,\n                           true, GlobalVariable::ExternalLinkage,\n                           NULL, \"jl_exe_handle\");\n    add_named_global(jlexe_var, &jl_exe_handle);\n    jldll_var =\n        new GlobalVariable(*m, T_pint8,\n                           true, GlobalVariable::ExternalLinkage,\n                           NULL, \"jl_dl_handle\");\n    add_named_global(jldll_var, &jl_dl_handle);\n#endif\n\n    jltls_states_func = Function::Create(FunctionType::get(PointerType::get(T_ppjlvalue, 0), false),\n                                         Function::ExternalLinkage, \"julia.ptls_states\");\n    add_named_global(jltls_states_func, (void*)NULL, /*dllimport*/false);\n\n    std::vector<Type*> args1(0);\n    args1.push_back(T_pint8);\n    jlerror_func =\n        Function::Create(FunctionType::get(T_void, args1, false),\n                         Function::ExternalLinkage,\n                         \"jl_error\", m);\n    jlerror_func->setDoesNotReturn();\n    add_named_global(jlerror_func, &jl_error);\n\n    std::vector<Type*> args1_(0);\n    args1_.push_back(PointerType::get(T_jlvalue, AddressSpace::CalleeRooted));\n    jlthrow_func =\n        Function::Create(FunctionType::get(T_void, args1_, false),\n                         Function::ExternalLinkage,\n                         \"jl_throw\", m);\n    jlthrow_func->setDoesNotReturn();\n    add_named_global(jlthrow_func, &jl_throw);\n\n    // Symbols are not gc-tracked, but we'll treat them as callee rooted anyway,\n    // because they may come from a gc-rooted location\n    jlundefvarerror_func =\n        Function::Create(FunctionType::get(T_void, args1_, false),\n                         Function::ExternalLinkage,\n                         \"jl_undefined_var_error\", m);\n    jlundefvarerror_func->setDoesNotReturn();\n    add_named_global(jlundefvarerror_func, &jl_undefined_var_error);\n\n    std::vector<Type*> args2_boundserrorv(0);\n    args2_boundserrorv.push_back(PointerType::get(T_jlvalue, AddressSpace::CalleeRooted));\n    args2_boundserrorv.push_back(T_psize);\n    args2_boundserrorv.push_back(T_size);\n    jlboundserrorv_func =\n        Function::Create(FunctionType::get(T_void, args2_boundserrorv, false),\n                         Function::ExternalLinkage,\n                         \"jl_bounds_error_ints\", m);\n    jlboundserrorv_func->setDoesNotReturn();\n    add_named_global(jlboundserrorv_func, &jl_bounds_error_ints);\n\n    std::vector<Type*> args2_boundserror(0);\n    args2_boundserror.push_back(PointerType::get(T_jlvalue, AddressSpace::CalleeRooted));\n    args2_boundserror.push_back(T_size);\n    jlboundserror_func =\n        Function::Create(FunctionType::get(T_void, args2_boundserror, false),\n                         Function::ExternalLinkage,\n                         \"jl_bounds_error_int\", m);\n    jlboundserror_func->setDoesNotReturn();\n    add_named_global(jlboundserror_func, &jl_bounds_error_int);\n\n    std::vector<Type*> args3_vboundserror(0);\n    args3_vboundserror.push_back(T_pprjlvalue);\n    args3_vboundserror.push_back(T_size);\n    args3_vboundserror.push_back(T_size);\n    jlvboundserror_func =\n        Function::Create(FunctionType::get(T_void, args3_vboundserror, false),\n                         Function::ExternalLinkage,\n                         \"jl_bounds_error_tuple_int\", m);\n    jlvboundserror_func->setDoesNotReturn();\n    add_named_global(jlvboundserror_func, &jl_bounds_error_tuple_int);\n\n    std::vector<Type*> args3_uboundserror(0);\n    args3_uboundserror.push_back(T_pint8_derived);\n    args3_uboundserror.push_back(T_pjlvalue);\n    args3_uboundserror.push_back(T_size);\n    jluboundserror_func =\n        Function::Create(FunctionType::get(T_void, args3_uboundserror, false),\n                         Function::ExternalLinkage,\n                         \"jl_bounds_error_unboxed_int\", m);\n    jluboundserror_func->setDoesNotReturn();\n    add_named_global(jluboundserror_func, &jl_bounds_error_unboxed_int);\n\n    jlnew_func =\n        Function::Create(jl_func_sig, Function::ExternalLinkage,\n                         \"jl_new_structv\", m);\n    add_return_attr(jlnew_func, Attribute::NonNull);\n    jlnew_func->addFnAttr(Thunk);\n    add_named_global(jlnew_func, &jl_new_structv);\n\n    std::vector<Type*> args2(0);\n    args2.push_back(T_pint8);\n#ifndef _OS_WINDOWS_\n    args2.push_back(T_int32);\n#endif\n    setjmp_func =\n        Function::Create(FunctionType::get(T_int32, args2, false),\n                         Function::ExternalLinkage, jl_setjmp_name, m);\n    setjmp_func->addFnAttr(Attribute::ReturnsTwice);\n    add_named_global(setjmp_func, &jl_setjmp_f);\n\n    std::vector<Type*> args_memcmp(0);\n    args_memcmp.push_back(T_pint8_derived);\n    args_memcmp.push_back(T_pint8_derived);\n    args_memcmp.push_back(T_size);\n    memcmp_derived_func =\n        Function::Create(FunctionType::get(T_int32, args_memcmp, false),\n                         Function::ExternalLinkage, \"memcmp\", m);\n    memcmp_derived_func->addFnAttr(Attribute::ReadOnly);\n    memcmp_derived_func->addFnAttr(Attribute::NoUnwind);\n    memcmp_derived_func->addFnAttr(Attribute::ArgMemOnly);\n    add_named_global(memcmp_derived_func, &memcmp);\n\n    std::vector<Type*> te_args(0);\n    te_args.push_back(T_pint8);\n    te_args.push_back(T_pint8);\n    te_args.push_back(T_prjlvalue);\n    te_args.push_back(PointerType::get(T_jlvalue, AddressSpace::CalleeRooted));\n    jltypeerror_func =\n        Function::Create(FunctionType::get(T_void, te_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_type_error_rt\", m);\n    jltypeerror_func->setDoesNotReturn();\n    add_named_global(jltypeerror_func, &jl_type_error_rt);\n\n    std::vector<Type *> args_2ptrs(0);\n    args_2ptrs.push_back(T_pjlvalue);\n    args_2ptrs.push_back(PointerType::get(T_jlvalue, AddressSpace::CalleeRooted));\n    jlcheckassign_func =\n        Function::Create(FunctionType::get(T_void, args_2ptrs, false),\n                         Function::ExternalLinkage,\n                         \"jl_checked_assignment\", m);\n    add_named_global(jlcheckassign_func, &jl_checked_assignment);\n\n    std::vector<Type *> args_1binding(0);\n    args_1binding.push_back(T_pjlvalue);\n    jldeclareconst_func =\n        Function::Create(FunctionType::get(T_void, args_1binding, false),\n                         Function::ExternalLinkage,\n                         \"jl_declare_constant\", m);\n    add_named_global(jldeclareconst_func, &jl_declare_constant);\n\n    std::vector<Type *> args_2ptrs_(0);\n    args_2ptrs_.push_back(T_pjlvalue);\n    args_2ptrs_.push_back(T_pjlvalue);\n    jlgetbindingorerror_func =\n        Function::Create(FunctionType::get(T_pjlvalue, args_2ptrs_, false),\n                         Function::ExternalLinkage,\n                         \"jl_get_binding_or_error\", m);\n    add_named_global(jlgetbindingorerror_func, &jl_get_binding_or_error);\n\n    jlboundp_func =\n        Function::Create(FunctionType::get(T_int32, args_2ptrs_, false),\n                         Function::ExternalLinkage,\n                         \"jl_boundp\", m);\n    add_named_global(jlboundp_func, &jl_boundp);\n\n    builtin_func_map[jl_f_is] = jlcall_func_to_llvm(\"jl_f_is\", &jl_f_is, m);\n    builtin_func_map[jl_f_typeof] = jlcall_func_to_llvm(\"jl_f_typeof\", &jl_f_typeof, m);\n    builtin_func_map[jl_f_sizeof] = jlcall_func_to_llvm(\"jl_f_sizeof\", &jl_f_sizeof, m);\n    builtin_func_map[jl_f_issubtype] = jlcall_func_to_llvm(\"jl_f_issubtype\", &jl_f_issubtype, m);\n    builtin_func_map[jl_f_isa] = jlcall_func_to_llvm(\"jl_f_isa\", &jl_f_isa, m);\n    builtin_func_map[jl_f_typeassert] = jlcall_func_to_llvm(\"jl_f_typeassert\", &jl_f_typeassert, m);\n    builtin_func_map[jl_f_ifelse] = jlcall_func_to_llvm(\"jl_f_ifelse\", &jl_f_ifelse, m);\n    builtin_func_map[jl_f__apply] = jlcall_func_to_llvm(\"jl_f__apply\", &jl_f__apply, m);\n    builtin_func_map[jl_f__apply_pure] = jlcall_func_to_llvm(\"jl_f__apply_pure\", &jl_f__apply_pure, m);\n    builtin_func_map[jl_f__apply_latest] = jlcall_func_to_llvm(\"jl_f__apply_latest\", &jl_f__apply_latest, m);\n    builtin_func_map[jl_f_throw] = jlcall_func_to_llvm(\"jl_f_throw\", &jl_f_throw, m);\n    builtin_func_map[jl_f_tuple] = jlcall_func_to_llvm(\"jl_f_tuple\", &jl_f_tuple, m);\n    builtin_func_map[jl_f_svec] = jlcall_func_to_llvm(\"jl_f_svec\", &jl_f_svec, m);\n    builtin_func_map[jl_f_applicable] = jlcall_func_to_llvm(\"jl_f_applicable\", &jl_f_applicable, m);\n    builtin_func_map[jl_f_invoke] = jlcall_func_to_llvm(\"jl_f_invoke\", &jl_f_invoke, m);\n    builtin_func_map[jl_f_invoke_kwsorter] = jlcall_func_to_llvm(\"jl_f_invoke_kwsorter\", &jl_f_invoke_kwsorter, m);\n    builtin_func_map[jl_f_isdefined] = jlcall_func_to_llvm(\"jl_f_isdefined\", &jl_f_isdefined, m);\n    builtin_func_map[jl_f_getfield] = jlcall_func_to_llvm(\"jl_f_getfield\", &jl_f_getfield, m);\n    builtin_func_map[jl_f_setfield] = jlcall_func_to_llvm(\"jl_f_setfield\", &jl_f_setfield, m);\n    builtin_func_map[jl_f_fieldtype] = jlcall_func_to_llvm(\"jl_f_fieldtype\", &jl_f_fieldtype, m);\n    builtin_func_map[jl_f_nfields] = jlcall_func_to_llvm(\"jl_f_nfields\", &jl_f_nfields, m);\n    builtin_func_map[jl_f__expr] = jlcall_func_to_llvm(\"jl_f__expr\", &jl_f__expr, m);\n    builtin_func_map[jl_f_arrayref] = jlcall_func_to_llvm(\"jl_f_arrayref\", &jl_f_arrayref, m);\n    builtin_func_map[jl_f_arrayset] = jlcall_func_to_llvm(\"jl_f_arrayset\", &jl_f_arrayset, m);\n    builtin_func_map[jl_f_arraysize] = jlcall_func_to_llvm(\"jl_f_arraysize\", &jl_f_arraysize, m);\n    builtin_func_map[jl_f_apply_type] = jlcall_func_to_llvm(\"jl_f_apply_type\", &jl_f_apply_type, m);\n    jltuple_func = builtin_func_map[jl_f_tuple];\n    jlgetfield_func = builtin_func_map[jl_f_getfield];\n\n    jlapply2va_func = jlcall_func_to_llvm(\"jl_apply_2va\", &jl_apply_2va, m);\n\n    std::vector<Type *> agargs(0);\n    agargs.push_back(T_pprjlvalue);\n    agargs.push_back(T_uint32);\n    jlapplygeneric_func = Function::Create(FunctionType::get(T_prjlvalue, agargs, false),\n                                           Function::ExternalLinkage,\n                                           \"jl_apply_generic\", m);\n    add_return_attr(jlapplygeneric_func, Attribute::NonNull);\n    jlapplygeneric_func->addFnAttr(Thunk);\n    add_named_global(jlapplygeneric_func, &jl_apply_generic);\n\n    std::vector<Type *> invokeargs(0);\n    invokeargs.push_back(T_prjlvalue);\n    invokeargs.push_back(T_pprjlvalue);\n    invokeargs.push_back(T_uint32);\n    jlinvoke_func = Function::Create(FunctionType::get(T_prjlvalue, invokeargs, false),\n                                     Function::ExternalLinkage,\n                                     \"jl_invoke\", m);\n    add_return_attr(jlinvoke_func, Attribute::NonNull);\n    add_named_global(jlinvoke_func, &jl_invoke);\n\n    std::vector<Type *> exp_args(0);\n    exp_args.push_back(T_int1);\n    expect_func = Intrinsic::getDeclaration(m, Intrinsic::expect, exp_args);\n\n    std::vector<Type*> args_topeval(0);\n    args_topeval.push_back(T_pjlvalue);\n    args_topeval.push_back(T_pjlvalue);\n    jltopeval_func =\n        Function::Create(FunctionType::get(T_pjlvalue, args_topeval, false),\n                         Function::ExternalLinkage,\n                         \"jl_toplevel_eval\", m);\n    add_return_attr(jltopeval_func, Attribute::NonNull);\n    add_named_global(jltopeval_func, &jl_toplevel_eval);\n\n    std::vector<Type*> args_copyast(0);\n    args_copyast.push_back(T_prjlvalue);\n    jlcopyast_func =\n        Function::Create(FunctionType::get(T_prjlvalue, args_copyast, false),\n                         Function::ExternalLinkage,\n                         \"jl_copy_ast\", m);\n    add_return_attr(jlcopyast_func, Attribute::NonNull);\n    add_named_global(jlcopyast_func, &jl_copy_ast);\n\n    std::vector<Type*> args5(0);\n    args5.push_back(T_size);\n    jlnsvec_func =\n        Function::Create(FunctionType::get(T_pjlvalue, args5, true),\n                         Function::ExternalLinkage,\n                         \"jl_svec\", m);\n    add_return_attr(jlnsvec_func, Attribute::NonNull);\n    add_named_global(jlnsvec_func, &jl_svec);\n\n    std::vector<Type*> mdargs(0);\n    mdargs.push_back(T_prjlvalue);\n    mdargs.push_back(T_prjlvalue);\n    mdargs.push_back(T_pjlvalue);\n    jlmethod_func =\n        Function::Create(FunctionType::get(T_void, mdargs, false),\n                         Function::ExternalLinkage,\n                         \"jl_method_def\", m);\n    add_named_global(jlmethod_func, &jl_method_def);\n\n    std::vector<Type*> funcdefargs(0);\n    funcdefargs.push_back(T_pjlvalue);\n    funcdefargs.push_back(T_pjlvalue);\n    funcdefargs.push_back(T_pprjlvalue);\n    funcdefargs.push_back(T_pjlvalue);\n    funcdefargs.push_back(T_pjlvalue);\n    jlgenericfunction_func =\n        Function::Create(FunctionType::get(T_prjlvalue, funcdefargs, false),\n                         Function::ExternalLinkage,\n                         \"jl_generic_function_def\", m);\n    add_named_global(jlgenericfunction_func, &jl_generic_function_def);\n\n    std::vector<Type*> ehargs(0);\n    ehargs.push_back(T_pint8);\n    jlenter_func =\n        Function::Create(FunctionType::get(T_void, ehargs, false),\n                         Function::ExternalLinkage,\n                         \"jl_enter_handler\", m);\n    add_named_global(jlenter_func, &jl_enter_handler);\n\n#ifdef _OS_WINDOWS_\n    resetstkoflw_func = Function::Create(FunctionType::get(T_int32, false),\n            Function::ExternalLinkage, \"_resetstkoflw\", m);\n    add_named_global(resetstkoflw_func, &_resetstkoflw);\n#if defined(_CPU_X86_64_)\n    juliapersonality_func = Function::Create(FunctionType::get(T_int32, true),\n            Function::ExternalLinkage, \"__julia_personality\", m);\n    add_named_global(juliapersonality_func, &__julia_personality);\n#endif\n#ifndef FORCE_ELF\n#if defined(_CPU_X86_64_)\n#if defined(_COMPILER_MINGW_)\n    Function *chkstk_func = Function::Create(FunctionType::get(T_void, false),\n            Function::ExternalLinkage, \"___chkstk_ms\", m);\n    add_named_global(chkstk_func, &___chkstk_ms, /*dllimport*/false);\n#else\n    Function *chkstk_func = Function::Create(FunctionType::get(T_void, false),\n            Function::ExternalLinkage, \"__chkstk\", m);\n    add_named_global(chkstk_func, &__chkstk, /*dllimport*/false);\n#endif\n#else\n#if defined(_COMPILER_MINGW_)\n    Function *chkstk_func = Function::Create(FunctionType::get(T_void, false),\n            Function::ExternalLinkage, \"_alloca\", m);\n    add_named_global(chkstk_func, &_alloca, /*dllimport*/false);\n#else\n    Function *chkstk_func = Function::Create(FunctionType::get(T_void, false),\n            Function::ExternalLinkage, \"_chkstk\", m);\n    add_named_global(chkstk_func, &_chkstk, /*dllimport*/false);\n#endif\n#endif\n#endif\n#endif\n\n    std::vector<Type*> lhargs(0);\n    lhargs.push_back(T_int32);\n    jlleave_func =\n        Function::Create(FunctionType::get(T_void, lhargs, false),\n                         Function::ExternalLinkage,\n                         \"jl_pop_handler\", m);\n    add_named_global(jlleave_func, &jl_pop_handler);\n\n    std::vector<Type *> args_2vals_callee_rooted(0);\n    args_2vals_callee_rooted.push_back(PointerType::get(T_jlvalue, AddressSpace::CalleeRooted));\n    args_2vals_callee_rooted.push_back(PointerType::get(T_jlvalue, AddressSpace::CalleeRooted));\n    jlegal_func =\n        Function::Create(FunctionType::get(T_int32, args_2vals_callee_rooted, false),\n                         Function::ExternalLinkage,\n                         \"jl_egal\", m);\n    add_named_global(jlegal_func, &jl_egal);\n\n    std::vector<Type *> args_2vals_tracked(0);\n    args_2vals_tracked.push_back(T_prjlvalue);\n    args_2vals_tracked.push_back(T_prjlvalue);\n    jlisa_func =\n        Function::Create(FunctionType::get(T_int32, args_2vals_tracked, false),\n                         Function::ExternalLinkage,\n                         \"jl_isa\", m);\n    add_named_global(jlisa_func, &jl_isa);\n\n    jlsubtype_func =\n        Function::Create(FunctionType::get(T_int32, args_2vals_tracked, false),\n                         Function::ExternalLinkage,\n                         \"jl_subtype\", m);\n    add_named_global(jlsubtype_func, &jl_subtype);\n\n    jltypeassert_func = Function::Create(FunctionType::get(T_void, args_2vals_tracked, false),\n                                        Function::ExternalLinkage,\n                                        \"jl_typeassert\", m);\n    add_named_global(jltypeassert_func, &jl_typeassert);\n\n    std::vector<Type *> applytype_args(0);\n    applytype_args.push_back(T_pjlvalue);\n    applytype_args.push_back(T_pjlvalue);\n    applytype_args.push_back(T_pprjlvalue);\n    jlapplytype_func =\n        Function::Create(FunctionType::get(T_prjlvalue, applytype_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_instantiate_type_in_env\", m);\n    add_return_attr(jlapplytype_func, Attribute::NonNull);\n    add_named_global(jlapplytype_func, &jl_instantiate_type_in_env);\n\n    std::vector<Type*> gc_alloc_args(0);\n    gc_alloc_args.push_back(T_pint8);\n    gc_alloc_args.push_back(T_size);\n    gc_alloc_args.push_back(T_prjlvalue);\n    jl_alloc_obj_func = Function::Create(FunctionType::get(T_prjlvalue, gc_alloc_args, false),\n                                         Function::ExternalLinkage,\n                                         \"julia.gc_alloc_obj\");\n    add_return_attr(jl_alloc_obj_func, Attribute::NoAlias);\n    add_return_attr(jl_alloc_obj_func, Attribute::NonNull);\n    jl_alloc_obj_func->addFnAttr(Attribute::getWithAllocSizeArgs(jl_LLVMContext, 1, None)); // returns %1 bytes\n    add_named_global(jl_alloc_obj_func, (void*)NULL, /*dllimport*/false);\n\n    std::vector<Type*> newbits_args(0);\n    newbits_args.push_back(T_prjlvalue);\n    newbits_args.push_back(T_pint8);\n    jl_newbits_func = Function::Create(FunctionType::get(T_prjlvalue, newbits_args, false),\n                                         Function::ExternalLinkage,\n                                         \"jl_new_bits\");\n    add_return_attr(jl_newbits_func, Attribute::NoAlias);\n    add_return_attr(jl_newbits_func, Attribute::NonNull);\n    add_named_global(jl_newbits_func, (void*)jl_new_bits);\n\n    jl_simdloop_marker_func = Function::Create(FunctionType::get(T_void, {}, false),\n                                               Function::ExternalLinkage,\n                                               \"julia.simdloop_marker\");\n    jl_simdloop_marker_func->addFnAttr(Attribute::NoUnwind);\n    jl_simdloop_marker_func->addFnAttr(Attribute::NoRecurse);\n    jl_simdloop_marker_func->addFnAttr(Attribute::InaccessibleMemOnly);\n\n    jl_simdivdep_marker_func = Function::Create(FunctionType::get(T_void, {}, false),\n                                               Function::ExternalLinkage,\n                                               \"julia.simdivdep_marker\");\n    jl_simdivdep_marker_func->addFnAttr(Attribute::NoUnwind);\n    jl_simdivdep_marker_func->addFnAttr(Attribute::NoRecurse);\n    jl_simdivdep_marker_func->addFnAttr(Attribute::InaccessibleMemOnly);\n\n    jl_typeof_func = Function::Create(FunctionType::get(T_prjlvalue, {T_prjlvalue}, false),\n                                      Function::ExternalLinkage,\n                                      \"julia.typeof\");\n    jl_typeof_func->addFnAttr(Attribute::ReadOnly);\n    jl_typeof_func->addFnAttr(Attribute::NoUnwind);\n    jl_typeof_func->addFnAttr(Attribute::ArgMemOnly);\n    jl_typeof_func->addFnAttr(Attribute::NoRecurse);\n    add_return_attr(jl_typeof_func, Attribute::NonNull);\n    add_named_global(jl_typeof_func, (void*)NULL, /*dllimport*/false);\n\n    jl_write_barrier_func = Function::Create(FunctionType::get(T_void,\n                                                               {T_prjlvalue, T_prjlvalue}, false),\n                                             Function::ExternalLinkage,\n                                             \"julia.write_barrier\");\n    jl_write_barrier_func->addFnAttr(Attribute::InaccessibleMemOnly);\n    jl_write_barrier_func->addFnAttr(Attribute::NoUnwind);\n    jl_write_barrier_func->addFnAttr(Attribute::NoRecurse);\n    add_named_global(jl_write_barrier_func, (void*)NULL, /*dllimport*/false);\n\n    std::vector<Type *> dlsym_args(0);\n    dlsym_args.push_back(T_pint8);\n    dlsym_args.push_back(T_pint8);\n    dlsym_args.push_back(PointerType::get(T_pint8,0));\n    jldlsym_func =\n        Function::Create(FunctionType::get(T_pvoidfunc, dlsym_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_load_and_lookup\", m);\n    add_named_global(jldlsym_func, &jl_load_and_lookup);\n\n    std::vector<Type *> getcfunctiontrampoline_args(0);\n    getcfunctiontrampoline_args.push_back(T_prjlvalue); // f (object)\n    getcfunctiontrampoline_args.push_back(T_pjlvalue); // result\n    getcfunctiontrampoline_args.push_back(T_pint8); // cache\n    getcfunctiontrampoline_args.push_back(T_pjlvalue); // fill\n    getcfunctiontrampoline_args.push_back(FunctionType::get(T_pint8, { T_pint8, T_ppjlvalue }, false)->getPointerTo()); // trampoline\n    getcfunctiontrampoline_args.push_back(T_pjlvalue); // env\n    getcfunctiontrampoline_args.push_back(T_pprjlvalue); // vals\n    jlgetcfunctiontrampoline_func =\n        Function::Create(FunctionType::get(T_prjlvalue, getcfunctiontrampoline_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_get_cfunction_trampoline\", m);\n    add_return_attr(jlgetcfunctiontrampoline_func, Attribute::NonNull);\n    add_named_global(jlgetcfunctiontrampoline_func, &jl_get_cfunction_trampoline);\n\n    std::vector<Type *> getnthfld_args(0);\n    getnthfld_args.push_back(T_prjlvalue);\n    getnthfld_args.push_back(T_size);\n    jlgetnthfieldchecked_func =\n        Function::Create(FunctionType::get(T_prjlvalue, getnthfld_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_get_nth_field_checked\", m);\n    add_return_attr(jlgetnthfieldchecked_func, Attribute::NonNull);\n    add_named_global(jlgetnthfieldchecked_func, &jl_get_nth_field_checked);\n\n    diff_gc_total_bytes_func =\n        Function::Create(FunctionType::get(T_int64, false),\n                         Function::ExternalLinkage,\n                         \"jl_gc_diff_total_bytes\", m);\n    add_named_global(diff_gc_total_bytes_func, &jl_gc_diff_total_bytes);\n\n    std::vector<Type*> array_owner_args(0);\n    array_owner_args.push_back(T_prjlvalue);\n    jlarray_data_owner_func =\n        Function::Create(FunctionType::get(T_prjlvalue, array_owner_args, false),\n                         Function::ExternalLinkage,\n                         \"jl_array_data_owner\", m);\n    jlarray_data_owner_func->addFnAttr(Attribute::ReadOnly);\n    jlarray_data_owner_func->addFnAttr(Attribute::NoUnwind);\n    add_return_attr(jlarray_data_owner_func, Attribute::NonNull);\n    add_named_global(jlarray_data_owner_func, &jl_array_data_owner);\n\n    gcroot_flush_func = Function::Create(FunctionType::get(T_void, false),\n                                         Function::ExternalLinkage,\n                                         \"julia.gcroot_flush\");\n    add_named_global(gcroot_flush_func, (void*)NULL, /*dllimport*/false);\n\n    gc_preserve_begin_func = Function::Create(FunctionType::get(Type::getTokenTy(jl_LLVMContext),\n                                         ArrayRef<Type*>(), true),\n                                         Function::ExternalLinkage,\n                                         \"llvm.julia.gc_preserve_begin\");\n    add_named_global(gc_preserve_begin_func, (void*)NULL, /*dllimport*/false);\n\n    gc_preserve_end_func = Function::Create(FunctionType::get(T_void,\n                                        ArrayRef<Type*>(Type::getTokenTy(jl_LLVMContext)), false),\n                                        Function::ExternalLinkage,\n                                        \"llvm.julia.gc_preserve_end\");\n    add_named_global(gc_preserve_end_func, (void*)NULL, /*dllimport*/false);\n\n    pointer_from_objref_func = Function::Create(FunctionType::get(T_pjlvalue,\n                                         ArrayRef<Type*>(PointerType::get(T_jlvalue, AddressSpace::Derived)), false),\n                                         Function::ExternalLinkage,\n                                         \"julia.pointer_from_objref\");\n    pointer_from_objref_func->addFnAttr(Attribute::ReadNone);\n    pointer_from_objref_func->addFnAttr(Attribute::NoUnwind);\n    add_named_global(pointer_from_objref_func, (void*)NULL, /*dllimport*/false);\n\n    except_enter_func = Function::Create(FunctionType::get(T_int32, false),\n                                         Function::ExternalLinkage,\n                                         \"julia.except_enter\");\n    except_enter_func->addFnAttr(Attribute::ReturnsTwice);\n    add_named_global(except_enter_func, (void*)NULL, /*dllimport*/false);\n\n    jlgetworld_global =\n        new GlobalVariable(*m, T_size,\n                           false, GlobalVariable::ExternalLinkage,\n                           NULL, \"jl_world_counter\");\n    add_named_global(jlgetworld_global, &jl_world_counter);\n\n    jl_globalPM = new legacy::PassManager();\n    addTargetPasses(jl_globalPM, jl_TargetMachine);\n    addOptimizationPasses(jl_globalPM, jl_options.opt_level);\n}\n\nextern \"C\" void *jl_init_llvm(void)\n{\n    const char *const argv_tailmerge[] = {\"\", \"-enable-tail-merge=0\"}; // NOO TOUCHIE; NO TOUCH! See #922\n    cl::ParseCommandLineOptions(sizeof(argv_tailmerge)/sizeof(argv_tailmerge[0]), argv_tailmerge, \"disable-tail-merge\\n\");\n#if defined(_OS_WINDOWS_) && defined(_CPU_X86_64_)\n    const char *const argv_copyprop[] = {\"\", \"-disable-copyprop\"}; // llvm bug 21743\n    cl::ParseCommandLineOptions(sizeof(argv_copyprop)/sizeof(argv_copyprop[0]), argv_copyprop, \"disable-copyprop\\n\");\n#endif\n    cl::ParseEnvironmentOptions(\"Julia\", \"JULIA_LLVM_ARGS\");\n\n    jl_page_size = jl_getpagesize();\n    imaging_mode = jl_generating_output();\n    jl_init_debuginfo();\n\n#ifdef USE_POLLY\n    PassRegistry &Registry = *PassRegistry::getPassRegistry();\n    polly::initializePollyPasses(Registry);\n    initializeAnalysis(Registry);\n#endif\n\n    InitializeNativeTarget();\n    InitializeNativeTargetAsmPrinter();\n    InitializeNativeTargetAsmParser();\n    InitializeNativeTargetDisassembler();\n\n    Module *m, *engine_module;\n    engine_module = new Module(\"julia\", jl_LLVMContext);\n    m = new Module(\"julia\", jl_LLVMContext);\n    shadow_output = m;\n\n    TargetOptions options = TargetOptions();\n    //options.PrintMachineCode = true; //Print machine code produced during JIT compiling\n#if defined(_OS_WINDOWS_) && !defined(_CPU_X86_64_)\n    // tell Win32 to assume the stack is always 16-byte aligned,\n    // and to ensure that it is 16-byte aligned for out-going calls,\n    // to ensure compatibility with GCC codes\n    options.StackAlignmentOverride = 16;\n#endif\n    EngineBuilder eb((std::unique_ptr<Module>(engine_module)));\n    std::string ErrorStr;\n    eb  .setEngineKind(EngineKind::JIT)\n        .setTargetOptions(options)\n        // Generate simpler code for JIT\n        .setRelocationModel(Reloc::Static)\n#ifdef _P64\n        // Make sure we are using the large code model on 64bit\n        // Let LLVM pick a default suitable for jitting on 32bit\n        .setCodeModel(CodeModel::Large)\n#elif JL_LLVM_VERSION < 60000\n        .setCodeModel(CodeModel::JITDefault)\n#endif\n#ifdef DISABLE_OPT\n        .setOptLevel(CodeGenOpt::None)\n#else\n        .setOptLevel(jl_options.opt_level == 0 ? CodeGenOpt::None : CodeGenOpt::Aggressive)\n#endif\n    ;\n    Triple TheTriple(sys::getProcessTriple());\n#if defined(FORCE_ELF)\n    TheTriple.setObjectFormat(Triple::ELF);\n#endif\n    uint32_t target_flags = 0;\n    auto target = jl_get_llvm_target(imaging_mode, target_flags);\n    auto &TheCPU = target.first;\n    SmallVector<std::string, 10> targetFeatures(target.second.begin(), target.second.end());\n    if (jl_processor_print_help || (target_flags & JL_TARGET_UNKNOWN_NAME)) {\n        std::string errorstr;\n        const Target *target = TargetRegistry::lookupTarget(\"\", TheTriple, errorstr);\n        assert(target);\n        std::unique_ptr<MCSubtargetInfo> MSTI(\n            target->createMCSubtargetInfo(TheTriple.str(), \"\", \"\"));\n        if (!MSTI->isCPUStringValid(TheCPU))\n            jl_errorf(\"Invalid CPU name %s.\", TheCPU.c_str());\n        if (jl_processor_print_help) {\n            // This is the only way I can find to print the help message once.\n            // It'll be nice if we can iterate through the features and print our own help\n            // message...\n            MSTI->setDefaultFeatures(\"help\", \"\");\n        }\n    }\n    jl_TargetMachine = eb.selectTarget(\n            TheTriple,\n            \"\",\n            TheCPU,\n            targetFeatures);\n    assert(jl_TargetMachine && \"Failed to select target machine -\"\n                               \" Is the LLVM backend for this CPU enabled?\");\n    #if (!defined(_CPU_ARM_) && !defined(_CPU_PPC64_))\n    // FastISel seems to be buggy for ARM. Ref #13321\n    if (jl_options.opt_level < 2)\n        jl_TargetMachine->setFastISel(true);\n    #endif\n\n    init_julia_llvm_meta();\n    jl_ExecutionEngine = new JuliaOJIT(*jl_TargetMachine);\n\n// Mark our address spaces as non-integral\n#if JL_LLVM_VERSION >= 40000\n    jl_data_layout = jl_ExecutionEngine->getDataLayout();\n    std::string DL = jl_data_layout.getStringRepresentation() + \"-ni:10:11:12:13\";\n    jl_data_layout.reset(DL);\n#endif\n\n#ifdef JL_USE_INTEL_JITEVENTS\n    if (jl_using_intel_jitevents)\n        jl_ExecutionEngine->RegisterJITEventListener(JITEventListener::createIntelJITEventListener());\n#endif\n\n#ifdef JL_USE_OPROFILE_JITEVENTS\n    if (jl_using_oprofile_jitevents)\n        jl_ExecutionEngine->RegisterJITEventListener(JITEventListener::createOProfileJITEventListener());\n#endif\n\n#ifdef JL_USE_PERF_JITEVENTS\n    if (jl_using_perf_jitevents) {\n        jl_ExecutionEngine->RegisterJITEventListener(JITEventListener::createPerfJITEventListener());\n    }\n#endif\n\n    // Now that the execution engine exists, initialize all modules\n    jl_setup_module(engine_module);\n    jl_setup_module(m);\n    return (void*)m;\n}\n\nextern \"C\" void jl_init_codegen(void)\n{\n    Module *m = (Module *)jl_init_llvm();\n    init_julia_llvm_env(m);\n\n    SBOX_F_PERM(int8,int8); UBOX_F_PERM(uint8,uint8);\n    SBOX_F(int16,int16); UBOX_F(uint16,uint16);\n    SBOX_F(int32,int32); UBOX_F(uint32,uint32);\n    SBOX_F(int64,int64); UBOX_F(uint64,uint64);\n    BOX_F(float32,float32,T_prjlvalue); BOX_F(float64,float64,T_prjlvalue);\n    UBOX_F(char,char);\n    UBOX_F(ssavalue,size);\n\n    jl_init_intrinsic_functions_codegen(m);\n}\n\n// for debugging from gdb\nextern \"C\" void jl_dump_llvm_value(void *v)\n{\n    llvm_dump((Value*)v);\n}\n\nextern \"C\" void jl_dump_llvm_inst_function(void *v)\n{\n    llvm_dump(cast<Instruction>(((Value*)v))->getParent()->getParent());\n}\n\nextern \"C\" void jl_dump_llvm_type(void *v)\n{\n    llvm_dump((Type*)v);\n}\n\nextern \"C\" void jl_dump_llvm_module(void *v)\n{\n    llvm_dump((Module*)v);\n}\n\nextern \"C\" void jl_dump_llvm_metadata(void *v)\n{\n    llvm_dump((Metadata*)v);\n}\n\nextern \"C\" void jl_dump_llvm_debugloc(void *v)\n{\n    llvm_dump((DebugLoc*)v);\n}\n\nextern void jl_write_bitcode_func(void *F, char *fname) {\n    std::error_code EC;\n    raw_fd_ostream OS(fname, EC, sys::fs::F_None);\n    llvm::WriteBitcodeToFile(((llvm::Function*)F)->getParent(), OS);\n}\n\nextern void jl_write_bitcode_module(void *M, char *fname) {\n    std::error_code EC;\n    raw_fd_ostream OS(fname, EC, sys::fs::F_None);\n    llvm::WriteBitcodeToFile((llvm::Module*)M, OS);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/src/debuginfo.cpp": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n#include \"platform.h\"\n\n#include \"llvm-version.h\"\n#include <llvm/ExecutionEngine/ExecutionEngine.h>\n#include <llvm/ExecutionEngine/JITEventListener.h>\n#include <llvm/DebugInfo/DIContext.h>\n#include <llvm/DebugInfo/DWARF/DWARFContext.h>\n#include <llvm/Object/SymbolSize.h>\n#include <llvm/Support/MemoryBuffer.h>\n#include <llvm/IR/Function.h>\n#include <llvm/ADT/StringRef.h>\n#include <llvm/ADT/StringMap.h>\n#include <llvm/IR/DebugInfo.h>\n#include <llvm/IR/DataLayout.h>\n#include <llvm/IR/Mangler.h>\n#include <llvm/ExecutionEngine/RuntimeDyld.h>\n#if JL_LLVM_VERSION >= 50000\n#include <llvm/BinaryFormat/Magic.h>\n#endif\n#include <llvm/Object/MachO.h>\n#include <llvm/Object/COFF.h>\n#include <llvm/Object/ELFObjectFile.h>\n\nusing namespace llvm;\n\n#if JL_LLVM_VERSION >= 50000\nusing llvm_file_magic = file_magic;\n#else\nusing llvm_file_magic = sys::fs::file_magic;\n#endif\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"debuginfo.h\"\n#if defined(_OS_LINUX_)\n#  include <link.h>\n#endif\n#include \"processor.h\"\n\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <map>\n#include <vector>\n#include <set>\n#include <cstdio>\n#include \"julia_assert.h\"\n\ntypedef object::SymbolRef SymRef;\n\n// Any function that acquires this lock must be either a unmanaged thread\n// or in the GC safe region and must NOT allocate anything through the GC\n// while holding this lock.\n// Certain functions in this file might be called from an unmanaged thread\n// and cannot have any interaction with the julia runtime\nstatic uv_rwlock_t threadsafe;\n\nextern \"C\" void jl_init_debuginfo()\n{\n    uv_rwlock_init(&threadsafe);\n}\n\n// --- storing and accessing source location metadata ---\n\nstruct ObjectInfo {\n    const object::ObjectFile *object;\n    size_t SectionSize;\n    ptrdiff_t slide;\n    DIContext *context;\n};\n\n// Maintain a mapping of unrealized function names -> linfo objects\n// so that when we see it get emitted, we can add a link back to the linfo\n// that it came from (providing name, type signature, file info, etc.)\nstatic StringMap<jl_method_instance_t*> linfo_in_flight;\nstatic std::string mangle(const std::string &Name, const DataLayout &DL)\n{\n    std::string MangledName;\n    {\n        raw_string_ostream MangledNameStream(MangledName);\n        Mangler::getNameWithPrefix(MangledNameStream, Name, DL);\n    }\n    return MangledName;\n}\nvoid jl_add_linfo_in_flight(StringRef name, jl_method_instance_t *linfo, const DataLayout &DL)\n{\n    linfo_in_flight[mangle(name, DL)] = linfo;\n}\n\n\n#ifdef _OS_WINDOWS_\n#if defined(_CPU_X86_64_)\nvoid *lookupWriteAddressFor(RTDyldMemoryManager *memmgr, void *rt_addr);\n#endif\n#endif\n\n#if defined(_OS_WINDOWS_)\nstatic void create_PRUNTIME_FUNCTION(uint8_t *Code, size_t Size, StringRef fnname,\n                                     uint8_t *Section, size_t Allocated, uint8_t *UnwindData)\n{\n    // GC safe\n    DWORD mod_size = 0;\n#if defined(_CPU_X86_64_)\n    PRUNTIME_FUNCTION tbl = (PRUNTIME_FUNCTION)malloc(sizeof(RUNTIME_FUNCTION));\n    tbl->BeginAddress = (DWORD)(Code - Section);\n    tbl->EndAddress = (DWORD)(Code - Section + Size);\n    tbl->UnwindData = (DWORD)(UnwindData - Section);\n#else // defined(_CPU_X86_64_)\n    Section += (uintptr_t)Code;\n    mod_size = Size;\n#endif\n    if (0) {\n        assert(!jl_in_stackwalk);\n        jl_in_stackwalk = 1;\n        if (mod_size && !SymLoadModuleEx(GetCurrentProcess(), NULL, NULL, NULL, (DWORD64)Section, mod_size, NULL, SLMFLAG_VIRTUAL)) {\n            static int warned = 0;\n            if (!warned) {\n                jl_printf(JL_STDERR, \"WARNING: failed to insert module info for backtrace: %lu\\n\", GetLastError());\n                warned = 1;\n            }\n        }\n        else {\n            size_t len = fnname.size()+1;\n            if (len > MAX_SYM_NAME)\n                len = MAX_SYM_NAME;\n            char *name = (char*)alloca(len);\n            memcpy(name, fnname.data(), len-1);\n            name[len-1] = 0;\n            if (!SymAddSymbol(GetCurrentProcess(), (ULONG64)Section, name,\n                        (DWORD64)Code, (DWORD)Size, 0)) {\n                jl_printf(JL_STDERR, \"WARNING: failed to insert function name %s into debug info: %lu\\n\", name, GetLastError());\n            }\n        }\n        jl_in_stackwalk = 0;\n    }\n#if defined(_CPU_X86_64_)\n    if (!RtlAddFunctionTable(tbl, 1, (DWORD64)Section)) {\n        static int warned = 0;\n        if (!warned) {\n            jl_printf(JL_STDERR, \"WARNING: failed to insert function stack unwind info: %lu\\n\", GetLastError());\n            warned = 1;\n        }\n    }\n#endif\n}\n#endif\n\nstruct revcomp {\n    bool operator() (const size_t& lhs, const size_t& rhs) const\n    { return lhs>rhs; }\n};\n\nstruct strrefcomp {\n    bool operator() (const StringRef& lhs, const StringRef& rhs) const\n    {\n        return lhs.compare(rhs) > 0;\n    }\n};\n\nextern \"C\" tracer_cb jl_linfo_tracer;\nstatic std::vector<jl_method_instance_t*> triggered_linfos;\nvoid jl_callback_triggered_linfos(void)\n{\n    if (triggered_linfos.empty())\n        return;\n    if (jl_linfo_tracer) {\n        std::vector<jl_method_instance_t*> to_process(std::move(triggered_linfos));\n        for (jl_method_instance_t *linfo : to_process)\n            jl_call_tracer(jl_linfo_tracer, (jl_value_t*)linfo);\n    }\n}\n\nclass JuliaJITEventListener: public JITEventListener\n{\n    std::map<size_t, ObjectInfo, revcomp> objectmap;\n    std::map<size_t, std::pair<size_t, jl_method_instance_t *>, revcomp> linfomap;\n\npublic:\n    JuliaJITEventListener(){}\n    virtual ~JuliaJITEventListener() {}\n\n    jl_method_instance_t *lookupLinfo(size_t pointer)\n    {\n        auto linfo = linfomap.lower_bound(pointer);\n        if (linfo != linfomap.end() && pointer < linfo->first + linfo->second.first)\n            return linfo->second.second;\n        else\n            return NULL;\n    }\n\n    virtual void NotifyObjectEmitted(const object::ObjectFile &obj,\n                                     const RuntimeDyld::LoadedObjectInfo &L)\n    {\n        return _NotifyObjectEmitted(obj,obj,L,nullptr);\n    }\n\n    virtual void _NotifyObjectEmitted(const object::ObjectFile &obj,\n                                      const object::ObjectFile &debugObj,\n                                      const RuntimeDyld::LoadedObjectInfo &L,\n                                      RTDyldMemoryManager *memmgr)\n    {\n        jl_ptls_t ptls = jl_get_ptls_states();\n        // This function modify linfo->fptr in GC safe region.\n        // This should be fine since the GC won't scan this field.\n        int8_t gc_state = jl_gc_safe_enter(ptls);\n        uv_rwlock_wrlock(&threadsafe);\n        object::section_iterator Section = debugObj.section_begin();\n        object::section_iterator EndSection = debugObj.section_end();\n\n        std::map<StringRef,object::SectionRef,strrefcomp> loadedSections;\n        for (const object::SectionRef &lSection: obj.sections()) {\n            StringRef sName;\n            if (!lSection.getName(sName)) {\n                loadedSections[sName] = lSection;\n            }\n        }\n        auto getLoadAddress = [&] (const StringRef &sName) -> uint64_t {\n            auto search = loadedSections.find(sName);\n            if (search == loadedSections.end())\n                return 0;\n            return L.getSectionLoadAddress(search->second);\n        };\n\n#ifdef _CPU_ARM_\n        // ARM does not have/use .eh_frame\n        uint64_t arm_exidx_addr = 0;\n        size_t arm_exidx_len = 0;\n        uint64_t arm_text_addr = 0;\n        size_t arm_text_len = 0;\n        for (auto &section: obj.sections()) {\n            bool istext = false;\n            if (section.isText()) {\n                istext = true;\n            }\n            else {\n                StringRef sName;\n                if (section.getName(sName))\n                    continue;\n                if (sName != \".ARM.exidx\") {\n                    continue;\n                }\n            }\n            uint64_t loadaddr = L.getSectionLoadAddress(section);\n            size_t seclen = section.getSize();\n            if (istext) {\n                arm_text_addr = loadaddr;\n                arm_text_len = seclen;\n                if (!arm_exidx_addr) {\n                    continue;\n                }\n            }\n            else {\n                arm_exidx_addr = loadaddr;\n                arm_exidx_len = seclen;\n                if (!arm_text_addr) {\n                    continue;\n                }\n            }\n            unw_dyn_info_t *di = new unw_dyn_info_t;\n            di->gp = 0;\n            di->format = UNW_INFO_FORMAT_ARM_EXIDX;\n            di->start_ip = (uintptr_t)arm_text_addr;\n            di->end_ip = (uintptr_t)(arm_text_addr + arm_text_len);\n            di->u.rti.name_ptr = 0;\n            di->u.rti.table_data = arm_exidx_addr;\n            di->u.rti.table_len = arm_exidx_len;\n            _U_dyn_register(di);\n            break;\n        }\n#endif\n\n#if defined(_OS_WINDOWS_)\n        uint64_t SectionAddrCheck = 0; // assert that all of the Sections are at the same location\n        uint8_t *UnwindData = NULL;\n#if defined(_CPU_X86_64_)\n        uint64_t SectionLoadOffset = 1; // The real offset shouldn't be 1.\n        uint8_t *catchjmp = NULL;\n        for (const object::SymbolRef &sym_iter : debugObj.symbols()) {\n            StringRef sName;\n            auto sNameOrError = sym_iter.getName();\n            assert(sNameOrError);\n            sName = sNameOrError.get();\n            uint8_t **pAddr = NULL;\n            if (sName.equals(\"__UnwindData\")) {\n                pAddr = &UnwindData;\n            }\n            else if (sName.equals(\"__catchjmp\")) {\n                pAddr = &catchjmp;\n            }\n            if (pAddr) {\n                uint64_t Addr, SectionAddr, SectionLoadAddr;\n                auto AddrOrError = sym_iter.getAddress();\n                assert(AddrOrError);\n                Addr = AddrOrError.get();\n                auto SectionOrError = sym_iter.getSection();\n                assert(SectionOrError);\n                Section = SectionOrError.get();\n                assert(Section != EndSection && Section->isText());\n                SectionAddr = Section->getAddress();\n                Section->getName(sName);\n                SectionLoadAddr = getLoadAddress(sName);\n                Addr -= SectionAddr - SectionLoadAddr;\n                *pAddr = (uint8_t*)Addr;\n                if (SectionAddrCheck)\n                    assert(SectionAddrCheck == SectionLoadAddr);\n                else\n                    SectionAddrCheck = SectionLoadAddr;\n                if (memmgr)\n                    SectionAddr =\n                        (uintptr_t)lookupWriteAddressFor(memmgr,\n                                                         (void*)SectionLoadAddr);\n                if (SectionLoadOffset != 1)\n                    assert(SectionLoadOffset == SectionAddr - SectionLoadAddr);\n                else\n                    SectionLoadOffset = SectionAddr - SectionLoadAddr;\n            }\n        }\n        assert(catchjmp);\n        assert(UnwindData);\n        assert(SectionAddrCheck);\n        assert(SectionLoadOffset != 1);\n        catchjmp[SectionLoadOffset] = 0x48;\n        catchjmp[SectionLoadOffset + 1] = 0xb8; // mov RAX, QWORD PTR [&__julia_personality]\n        *(uint64_t*)(&catchjmp[SectionLoadOffset + 2]) =\n            (uint64_t)&__julia_personality;\n        catchjmp[SectionLoadOffset + 10] = 0xff;\n        catchjmp[SectionLoadOffset + 11] = 0xe0; // jmp RAX\n        UnwindData[SectionLoadOffset] = 0x09; // version info, UNW_FLAG_EHANDLER\n        UnwindData[SectionLoadOffset + 1] = 4;    // size of prolog (bytes)\n        UnwindData[SectionLoadOffset + 2] = 2;    // count of unwind codes (slots)\n        UnwindData[SectionLoadOffset + 3] = 0x05; // frame register (rbp) = rsp\n        UnwindData[SectionLoadOffset + 4] = 4;    // second instruction\n        UnwindData[SectionLoadOffset + 5] = 0x03; // mov RBP, RSP\n        UnwindData[SectionLoadOffset + 6] = 1;    // first instruction\n        UnwindData[SectionLoadOffset + 7] = 0x50; // push RBP\n        *(DWORD*)&UnwindData[SectionLoadOffset + 8] = (DWORD)(catchjmp - (uint8_t*)SectionAddrCheck); // relative location of catchjmp\n#endif // defined(_OS_X86_64_)\n#endif // defined(_OS_WINDOWS_)\n\n        std::vector<std::pair<jl_method_instance_t*, uintptr_t>> def_spec;\n        std::vector<std::pair<jl_method_instance_t*, uintptr_t>> def_invoke;\n        auto symbols = object::computeSymbolSizes(debugObj);\n        bool first = true;\n        for (const auto &sym_size : symbols) {\n            const object::SymbolRef &sym_iter = sym_size.first;\n            auto SymbolTypeOrError = sym_iter.getType();\n            assert(SymbolTypeOrError);\n            object::SymbolRef::Type SymbolType = SymbolTypeOrError.get();\n            if (SymbolType != object::SymbolRef::ST_Function) continue;\n            auto AddrOrError = sym_iter.getAddress();\n            assert(AddrOrError);\n            uint64_t Addr = AddrOrError.get();\n            auto SectionOrError = sym_iter.getSection();\n            assert(SectionOrError);\n            Section = SectionOrError.get();\n            if (Section == EndSection) continue;\n            if (!Section->isText()) continue;\n            uint64_t SectionAddr = Section->getAddress();\n            StringRef secName;\n            Section->getName(secName);\n            uint64_t SectionLoadAddr = getLoadAddress(secName);\n            Addr -= SectionAddr - SectionLoadAddr;\n            auto sNameOrError = sym_iter.getName();\n            assert(sNameOrError);\n            StringRef sName = sNameOrError.get();\n            uint64_t SectionSize = Section->getSize();\n            size_t Size = sym_size.second;\n#if defined(_OS_WINDOWS_)\n            if (SectionAddrCheck)\n                assert(SectionAddrCheck == SectionLoadAddr);\n            else\n                SectionAddrCheck = SectionLoadAddr;\n            create_PRUNTIME_FUNCTION(\n                   (uint8_t*)(uintptr_t)Addr, (size_t)Size, sName,\n                   (uint8_t*)(uintptr_t)SectionLoadAddr, (size_t)SectionSize, UnwindData);\n#endif\n            StringMap<jl_method_instance_t*>::iterator linfo_it = linfo_in_flight.find(sName);\n            jl_method_instance_t *linfo = NULL;\n            if (linfo_it != linfo_in_flight.end()) {\n                linfo = linfo_it->second;\n                if (linfo->compile_traced)\n                    triggered_linfos.push_back(linfo);\n                linfo_in_flight.erase(linfo_it);\n                const char *F = linfo->functionObjectsDecls.functionObject;\n                const char *specF = linfo->functionObjectsDecls.specFunctionObject;\n                if (linfo->invoke == jl_fptr_trampoline) {\n                    if (specF && sName.equals(specF)) {\n                        def_spec.push_back({linfo, Addr});\n                        if (!strcmp(F, \"jl_fptr_args\"))\n                            def_invoke.push_back({linfo, (uintptr_t)&jl_fptr_args});\n                        else if (!strcmp(F, \"jl_fptr_sparam\"))\n                            def_invoke.push_back({linfo, (uintptr_t)&jl_fptr_sparam});\n                    }\n                    else if (sName.equals(F)) {\n                        def_invoke.push_back({linfo, Addr});\n                    }\n                }\n            }\n            if (linfo)\n                linfomap[Addr] = std::make_pair(Size, linfo);\n            if (first) {\n                ObjectInfo tmp = {&debugObj,\n                    (size_t)SectionSize,\n                    (ptrdiff_t)(SectionAddr - SectionLoadAddr),\n#if JL_LLVM_VERSION >= 60000\n                    DWARFContext::create(debugObj, &L).release(),\n#else\n                    new DWARFContextInMemory(debugObj, &L),\n#endif\n                    };\n                objectmap[SectionLoadAddr] = tmp;\n                first = false;\n           }\n           // now process these in order, so we ensure the closure values are updated before removing the trampoline\n           for (auto &def : def_spec)\n               def.first->specptr.fptr = (void*)def.second;\n           for (auto &def : def_invoke)\n               def.first->invoke = (jl_callptr_t)def.second;\n        }\n        uv_rwlock_wrunlock(&threadsafe);\n        jl_gc_safe_leave(ptls, gc_state);\n    }\n\n    // must implement if we ever start freeing code\n    // virtual void NotifyFreeingObject(const ObjectImage &obj) {}\n    // virtual void NotifyFreeingObject(const object::ObjectFile &Obj) {}\n\n    std::map<size_t, ObjectInfo, revcomp>& getObjectMap()\n    {\n        uv_rwlock_rdlock(&threadsafe);\n        return objectmap;\n    }\n};\n\nJL_DLLEXPORT void ORCNotifyObjectEmitted(JITEventListener *Listener,\n                                         const object::ObjectFile &obj,\n                                         const object::ObjectFile &debugObj,\n                                         const RuntimeDyld::LoadedObjectInfo &L,\n                                         RTDyldMemoryManager *memmgr)\n{\n    ((JuliaJITEventListener*)Listener)->_NotifyObjectEmitted(obj,debugObj,L,memmgr);\n}\n\nstatic std::pair<char *, bool> jl_demangle(const char *name)\n{\n    // This function is not allowed to reference any TLS variables since\n    // it can be called from an unmanaged thread on OSX.\n    const char *start = name + 6;\n    const char *end = name + strlen(name);\n    char *ret;\n    if (end <= start)\n        goto done;\n    if (strncmp(name, \"japi1_\", 6) &&\n        strncmp(name, \"japi3_\", 6) &&\n        strncmp(name, \"julia_\", 6) &&\n        strncmp(name, \"jsys1_\", 6) &&\n        strncmp(name, \"jlsys_\", 6))\n        goto done;\n    if (*start == '\\0')\n        goto done;\n    while (*(--end) != '_') {\n        char c = *end;\n        if (c < '0' || c > '9')\n            goto done;\n    }\n    if (end <= start)\n        goto done;\n    ret = (char*)malloc(end - start + 1);\n    memcpy(ret, start, end - start);\n    ret[end - start] = '\\0';\n    return std::make_pair(ret, true);\ndone:\n    return std::make_pair(strdup(name), false);\n}\n\nstatic JuliaJITEventListener *jl_jit_events;\nJITEventListener *CreateJuliaJITEventListener()\n{\n    jl_jit_events = new JuliaJITEventListener();\n    return jl_jit_events;\n}\n\n// *frames is a one element array containing whatever we could come up\n// with for the current frame. here we'll try to expand it using debug info\n// func_name and file_name are either NULL or malloc'd pointers\nstatic int lookup_pointer(DIContext *context, jl_frame_t **frames,\n                          size_t pointer, int demangle, int noInline)\n{\n    // This function is not allowed to reference any TLS variables\n    // since it can be called from an unmanaged thread on OSX.\n    if (!context) {\n        if (demangle) {\n            char *oldname = (*frames)[0].func_name;\n            if (oldname != NULL) {\n                std::pair<char *, bool> demangled = jl_demangle(oldname);\n                (*frames)[0].func_name = demangled.first;\n                (*frames)[0].fromC = !demangled.second;\n                free(oldname);\n            }\n            else {\n                // We do this to hide the jlcall wrappers when getting julia backtraces,\n                // but it is still good to have them for regular lookup of C frames.\n                // Technically not true, but we don't want them\n                // in julia backtraces, so close enough\n                (*frames)[0].fromC = 1;\n            }\n        }\n        return 1;\n    }\n    jl_mutex_lock_maybe_nogc(&codegen_lock);\n    DILineInfoSpecifier infoSpec(DILineInfoSpecifier::FileLineInfoKind::AbsoluteFilePath,\n                                 DILineInfoSpecifier::FunctionNameKind::ShortName);\n\n    auto inlineInfo = context->getInliningInfoForAddress(pointer, infoSpec);\n\n    int fromC = (*frames)[0].fromC;\n    int n_frames = inlineInfo.getNumberOfFrames();\n    if (n_frames == 0) {\n        jl_mutex_unlock_maybe_nogc(&codegen_lock);\n        // no line number info available in the context, return without the context\n        return lookup_pointer(NULL, frames, pointer, demangle, noInline);\n    }\n    if (noInline)\n        n_frames = 1;\n    if (n_frames > 1) {\n        jl_frame_t *new_frames = (jl_frame_t*)calloc(sizeof(jl_frame_t), n_frames);\n        memcpy(&new_frames[n_frames - 1], *frames, sizeof(jl_frame_t));\n        free(*frames);\n        *frames = new_frames;\n    }\n    for (int i = 0; i < n_frames; i++) {\n        bool inlined_frame = i != n_frames - 1;\n        DILineInfo info;\n        if (!noInline) {\n            info = inlineInfo.getFrame(i);\n        }\n        else {\n            info = context->getLineInfoForAddress(pointer, infoSpec);\n        }\n\n        jl_frame_t *frame = &(*frames)[i];\n        std::string func_name(info.FunctionName);\n\n        if (inlined_frame) {\n            frame->inlined = 1;\n            frame->fromC = fromC;\n            if (!fromC) {\n                std::size_t semi_pos = func_name.find(';');\n                if (semi_pos != std::string::npos) {\n                    func_name = func_name.substr(0, semi_pos);\n                    frame->linfo = NULL; // TODO: if (new_frames[n_frames - 1].linfo) frame->linfo = lookup(func_name in linfo)?\n                }\n            }\n        }\n\n        if (func_name == \"<invalid>\")\n            frame->func_name = NULL;\n        else\n            jl_copy_str(&frame->func_name, func_name.c_str());\n        if (!frame->func_name)\n            frame->fromC = 1;\n\n        frame->line = info.Line;\n        std::string file_name(info.FileName);\n\n        if (file_name == \"<invalid>\")\n            frame->file_name = NULL;\n        else\n            jl_copy_str(&frame->file_name, file_name.c_str());\n    }\n    jl_mutex_unlock_maybe_nogc(&codegen_lock);\n    return n_frames;\n}\n\n#ifdef _OS_DARWIN_\n#include <mach-o/dyld.h>\n#else\n#define LC_UUID 0\n#endif\n#ifndef _OS_WINDOWS_\n#include <dlfcn.h>\n#endif\ntypedef struct {\n    const llvm::object::ObjectFile *obj;\n    DIContext *ctx;\n    int64_t slide;\n    int64_t section_slide;\n} objfileentry_t;\ntypedef std::map<uint64_t, objfileentry_t, revcomp> obfiletype;\nstatic obfiletype objfilemap;\n\nstatic bool getObjUUID(llvm::object::MachOObjectFile *obj, uint8_t uuid[16])\n{\n    for (auto Load : obj->load_commands())\n    {\n        if (Load.C.cmd == LC_UUID) {\n            memcpy(uuid, ((const MachO::uuid_command*)Load.Ptr)->uuid, 16);\n            return true;\n        }\n    }\n    return false;\n}\n\nstruct debug_link_info {\n    StringRef filename;\n    uint32_t crc32;\n};\nstatic debug_link_info getDebuglink(const object::ObjectFile &Obj)\n{\n    debug_link_info info = {};\n    for (const object::SectionRef &Section: Obj.sections()) {\n        StringRef sName;\n        if (!Section.getName(sName) && sName == \".gnu_debuglink\") {\n            StringRef Contents;\n            if (!Section.getContents(Contents)) {\n                size_t length = Contents.find('\\0');\n                info.filename = Contents.substr(0, length);\n                info.crc32 = *(const uint32_t*)Contents.substr(LLT_ALIGN(length + 1, 4), 4).data();\n                break;\n            }\n        }\n    }\n    return info;\n}\n/*\n * crc function from http://svnweb.freebsd.org/base/head/sys/libkern/crc32.c (and lldb)\n *\n *   COPYRIGHT (C) 1986 Gary S. Brown. You may use this program, or\n *   code or tables extracted from it, as desired without restriction.\n */\nstatic uint32_t\ncalc_gnu_debuglink_crc32(const void *buf, size_t size)\n{\n    static const uint32_t g_crc32_tab[] =\n    {\n        0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,\n        0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\n        0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,\n        0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n        0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n        0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,\n        0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,\n        0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n        0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,\n        0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n        0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,\n        0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n        0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,\n        0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,\n        0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n        0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n        0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,\n        0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,\n        0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,\n        0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n        0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,\n        0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,\n        0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,\n        0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n        0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n        0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,\n        0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,\n        0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n        0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,\n        0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n        0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,\n        0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n        0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,\n        0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,\n        0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n        0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n        0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,\n        0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,\n        0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,\n        0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n        0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,\n        0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,\n        0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\n    };\n    const uint8_t *p = (const uint8_t *)buf;\n    uint32_t crc;\n\n    crc = ~0U;\n    while (size--)\n        crc = g_crc32_tab[(crc ^ *p++) & 0xFF] ^ (crc >> 8);\n    return crc ^ ~0U;\n}\n\nstatic Expected<object::OwningBinary<object::ObjectFile>>\nopenDebugInfo(StringRef debuginfopath, const debug_link_info &info)\n{\n    auto SplitFile = MemoryBuffer::getFile(debuginfopath);\n    if (std::error_code EC = SplitFile.getError()) {\n        return errorCodeToError(EC);\n    }\n\n    uint32_t crc32 = calc_gnu_debuglink_crc32(\n            SplitFile.get()->getBufferStart(),\n            SplitFile.get()->getBufferSize());\n    if (crc32 != info.crc32) {\n        return errorCodeToError(object::object_error::arch_not_found);\n    }\n\n    auto error_splitobj = object::ObjectFile::createObjectFile(\n            SplitFile.get().get()->getMemBufferRef(),\n            llvm_file_magic::unknown);\n    if (!error_splitobj) {\n        return error_splitobj.takeError();\n    }\n\n    // successfully validated and loaded split debug info file\n    return object::OwningBinary<object::ObjectFile>(\n            std::move(error_splitobj.get()),\n            std::move(SplitFile.get()));\n}\n\nstatic uint64_t jl_sysimage_base;\nstatic jl_sysimg_fptrs_t sysimg_fptrs;\nstatic jl_method_instance_t **sysimg_fvars_linfo;\nstatic size_t sysimg_fvars_n;\nvoid jl_register_fptrs(uint64_t sysimage_base, const jl_sysimg_fptrs_t *fptrs,\n                       jl_method_instance_t **linfos, size_t n)\n{\n    jl_sysimage_base = (uintptr_t)sysimage_base;\n    sysimg_fptrs = *fptrs;\n    sysimg_fvars_linfo = linfos;\n    sysimg_fvars_n = n;\n}\n\ntemplate<typename T>\nstatic inline void ignoreError(T &err)\n{\n#if !defined(NDEBUG)\n    // Needed only with LLVM assertion build\n    consumeError(err.takeError());\n#endif\n}\n\nstatic void get_function_name_and_base(const object::ObjectFile *object, bool insysimage,\n                                       void **saddr, char **name, size_t pointer,\n                                       int64_t slide, bool untrusted_dladdr)\n{\n    // Assume we only need base address for sysimg for now\n    if (!insysimage || !sysimg_fptrs.base)\n        saddr = nullptr;\n    bool needs_saddr = saddr && (!*saddr || untrusted_dladdr);\n    bool needs_name = name && (!*name || untrusted_dladdr);\n    // Try platform specific methods first since they are usually faster\n    if (needs_saddr) {\n#if (defined(_OS_LINUX_) || defined(_OS_FREEBSD_)) && !defined(JL_DISABLE_LIBUNWIND)\n        unw_proc_info_t pip;\n        // Seems that libunwind may return NULL IP depending on what info it finds...\n        if (unw_get_proc_info_by_ip(unw_local_addr_space, pointer,\n                                    &pip, NULL) == 0 && pip.start_ip) {\n            *saddr = (void*)pip.start_ip;\n            needs_saddr = false;\n        }\n#endif\n#if defined(_OS_WINDOWS_) && defined(_CPU_X86_64_)\n        DWORD64 ImageBase;\n        PRUNTIME_FUNCTION fn = RtlLookupFunctionEntry(pointer, &ImageBase, NULL);\n        if (fn) {\n            *saddr = (void*)(ImageBase + fn->BeginAddress);\n            needs_saddr = false;\n        }\n#endif\n    }\n    if (object && (needs_saddr || needs_name)) {\n        size_t distance = (size_t)-1;\n        SymRef sym_found;\n        for (auto sym: object->symbols()) {\n            auto addr = sym.getAddress();\n            if (!addr)\n                continue;\n            size_t symptr = addr.get();\n            if (symptr > pointer + slide)\n                continue;\n            size_t new_dist = pointer + slide - symptr;\n            if (new_dist > distance)\n                continue;\n            distance = new_dist;\n            sym_found = sym;\n        }\n        if (distance != (size_t)-1) {\n            if (needs_saddr) {\n                auto addr = sym_found.getAddress();\n                assert(addr);\n                *saddr = (void*)(uintptr_t)(addr.get() - slide);\n                needs_saddr = false;\n            }\n            if (needs_name) {\n                if (auto name_or_err = sym_found.getName()) {\n                    auto nameref = name_or_err.get();\n                    size_t len = nameref.size();\n                    *name = (char*)realloc(*name, len + 1);\n                    (*name)[len] = 0;\n                    memcpy(*name, nameref.data(), len);\n                    needs_name = false;\n                }\n            }\n        }\n    }\n#ifdef _OS_WINDOWS_\n    // For ntdll and msvcrt since we are currently only parsing DWARF debug info through LLVM\n    if (!insysimage && needs_name) {\n        static char frame_info_func[\n            sizeof(SYMBOL_INFO) +\n            MAX_SYM_NAME * sizeof(TCHAR)];\n        DWORD64 dwDisplacement64 = 0;\n        DWORD64 dwAddress = pointer;\n        PSYMBOL_INFO pSymbol = (PSYMBOL_INFO)frame_info_func;\n        pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);\n        pSymbol->MaxNameLen = MAX_SYM_NAME;\n        jl_in_stackwalk = 1;\n        if (SymFromAddr(GetCurrentProcess(), dwAddress, &dwDisplacement64, pSymbol)) {\n            // errors are ignored\n            jl_copy_str(name, pSymbol->Name);\n        }\n        jl_in_stackwalk = 0;\n    }\n#endif\n}\n\nstatic objfileentry_t &find_object_file(uint64_t fbase, StringRef fname)\n{\n    int isdarwin = 0, islinux = 0, iswindows = 0;\n#if defined(_OS_DARWIN_)\n    isdarwin = 1;\n#elif defined(_OS_LINUX_) || defined(_OS_FREEBSD_)\n    islinux = 1;\n#elif defined(_OS_WINDOWS_)\n    iswindows = 1;\n#endif\n    (void)iswindows;\n\n// GOAL: Read debuginfo from file\n    // TODO: need read/write lock here for objfilemap synchronization\n    obfiletype::iterator it = objfilemap.find(fbase);\n    if (it != objfilemap.end())\n        // Return cached value\n        return it->second;\n    auto &entry = objfilemap[fbase]; // default initialized\n\n// GOAL: Assign errorobj\n    StringRef objpath;\n    std::string debuginfopath;\n    uint8_t uuid[16], uuid2[16];\n    if (isdarwin) {\n        size_t msize = (size_t)(((uint64_t)-1) - fbase);\n        std::unique_ptr<MemoryBuffer> membuf = MemoryBuffer::getMemBuffer(\n                StringRef((const char *)fbase, msize), \"\", false);\n        auto origerrorobj = llvm::object::ObjectFile::createObjectFile(\n            membuf->getMemBufferRef(), llvm_file_magic::unknown);\n        if (!origerrorobj)\n            return entry;\n\n        llvm::object::MachOObjectFile *morigobj = (llvm::object::MachOObjectFile*)\n            origerrorobj.get().get();\n\n        // First find the uuid of the object file (we'll use this to make sure we find the\n        // correct debug symbol file).\n        if (!getObjUUID(morigobj, uuid))\n            return entry;\n\n        // On OS X debug symbols are not contained in the dynamic library.\n        // For now we only support .dSYM files in the same directory\n        // as the shared library. In the future we may use DBGCopyFullDSYMURLForUUID from CoreFoundation to make\n        // use of spotlight to find the .dSYM file.\n        size_t sep = fname.rfind('/');\n        debuginfopath = fname;\n        debuginfopath += \".dSYM/Contents/Resources/DWARF/\";\n        debuginfopath += fname.substr(sep + 1);\n        objpath = debuginfopath;\n    }\n    else {\n        // On Linux systems we need to mmap another copy because of the permissions on the mmap'ed shared library.\n        // On Windows we need to mmap another copy since reading the in-memory copy seems to return object_error:unexpected_eof\n        objpath = fname;\n    }\n    auto errorobj = llvm::object::ObjectFile::createObjectFile(objpath);\n\n// GOAL: Find obj, context, slide (if above succeeded)\n    if (errorobj) {\n        auto *debugobj = errorobj->getBinary();\n\n        if (islinux) {\n            // if the file has a .gnu_debuglink section,\n            // try to load its companion file instead\n            // in the expected locations\n            // for now, we don't support the build-id method\n            debug_link_info info = getDebuglink(*debugobj);\n            if (!info.filename.empty()) {\n                size_t sep = fname.rfind('/');\n                Expected<object::OwningBinary<object::ObjectFile>>\n                    DebugInfo(errorCodeToError(std::make_error_code(std::errc::no_such_file_or_directory)));\n                // Can't find a way to construct an empty Expected object\n                // that can be ignored.\n                ignoreError(DebugInfo);\n                if (fname.substr(sep + 1) != info.filename) {\n                    debuginfopath = fname.substr(0, sep + 1);\n                    debuginfopath += info.filename;\n                    DebugInfo = openDebugInfo(debuginfopath, info);\n                }\n                if (!DebugInfo) {\n                    debuginfopath = fname.substr(0, sep + 1);\n                    debuginfopath += \".debug/\";\n                    debuginfopath += info.filename;\n                    ignoreError(DebugInfo);\n                    DebugInfo = openDebugInfo(debuginfopath, info);\n                }\n                if (!DebugInfo) {\n                    debuginfopath = \"/usr/lib/debug/\";\n                    debuginfopath += fname.substr(0, sep + 1);\n                    debuginfopath += info.filename;\n                    ignoreError(DebugInfo);\n                    DebugInfo = openDebugInfo(debuginfopath, info);\n                }\n                if (DebugInfo) {\n                    errorobj = std::move(DebugInfo);\n                    // Yes, we've checked, and yes LLVM want us to check again.\n                    assert(errorobj);\n                    debugobj = errorobj->getBinary();\n                }\n                else {\n                    ignoreError(DebugInfo);\n                }\n            }\n        }\n\n        if (isdarwin) {\n            // verify the UUID matches\n            if (!getObjUUID((llvm::object::MachOObjectFile*)debugobj, uuid2) ||\n                    memcmp(uuid, uuid2, sizeof(uuid)) != 0) {\n                return entry;\n            }\n        }\n\n        int64_t slide = 0;\n        int64_t section_slide = 0;\n        if (auto *OF = dyn_cast<const object::COFFObjectFile>(debugobj)) {\n            assert(iswindows);\n            slide = OF->getImageBase() - fbase;\n            section_slide = 0; // Since LLVM 3.8+ addresses are adjusted correctly\n        }\n        else {\n            slide = -(int64_t)fbase;\n        }\n\n#if JL_LLVM_VERSION >= 60000\n        auto context = DWARFContext::create(*debugobj).release();\n#else\n        auto context = new DWARFContextInMemory(*debugobj);\n#endif\n        auto binary = errorobj->takeBinary();\n        binary.first.release();\n        binary.second.release();\n        // update cache\n        entry = {debugobj, context, slide, section_slide};\n    }\n    else {\n        // TODO: report the error instead of silently consuming it?\n        //       jl_error might run into the same error again...\n        ignoreError(errorobj);\n    }\n    return entry;\n}\n\nextern \"C\" void jl_refresh_dbg_module_list(void);\nbool jl_dylib_DI_for_fptr(size_t pointer, const llvm::object::ObjectFile **obj, llvm::DIContext **context, int64_t *slide, int64_t *section_slide,\n    bool onlySysImg, bool *isSysImg, void **saddr, char **name, char **filename)\n{\n    *obj = NULL;\n    *context = NULL;\n    *slide = 0;\n    *section_slide = 0;\n    // On Windows and FreeBSD, `dladdr` (or its equivalent) returns the closest exported symbol\n    // without checking the size.\n    // This causes the lookup to return incorrect non-NULL result for local functions\n    // when better result is available through other methods.\n    // macOS's `dladdr` returns local symbols and Linux's `dladdr`\n    // checks the symbol size so they do not have this problem.\n    // On systems with an untrusted dladdr, the result cannot be used for sysimg\n    // (it's always wrong) and should in general be used only as the last fallback.\n#if defined(_OS_FREEBSD_) || defined(_OS_WINDOWS_)\n    bool untrusted_dladdr = true;\n#else\n    bool untrusted_dladdr = false;\n#endif\n\n// GOAL: Determine containing Library\n// Assigning fname, fbase\n#ifdef _OS_WINDOWS_\n    IMAGEHLP_MODULE64 ModuleInfo;\n    ModuleInfo.SizeOfStruct = sizeof(IMAGEHLP_MODULE64);\n    jl_refresh_dbg_module_list();\n    jl_in_stackwalk = 1;\n    bool isvalid = SymGetModuleInfo64(GetCurrentProcess(), (DWORD64)pointer, &ModuleInfo);\n    jl_in_stackwalk = 0;\n    if (!isvalid) return false;\n\n    StringRef fname = ModuleInfo.LoadedImageName;\n    if (fname.empty()) // empirically, LoadedImageName might be missing\n        fname = ModuleInfo.ImageName;\n    DWORD64 fbase = ModuleInfo.BaseOfImage;\n    bool insysimage = (fbase == jl_sysimage_base);\n    if (isSysImg)\n        *isSysImg = insysimage;\n    if (onlySysImg && !insysimage)\n        return false;\n    // If we didn't find the filename before in the debug\n    // info, use the dll name\n    if (filename && !*filename)\n        jl_copy_str(filename, fname.data());\n    if (saddr)\n        *saddr = NULL;\n\n#else // ifdef _OS_WINDOWS_\n    Dl_info dlinfo;\n    int dladdr_success;\n    uint64_t fbase;\n#ifdef __GLIBC__\n    struct link_map *extra_info;\n    dladdr_success = dladdr1((void*)pointer, &dlinfo, (void**)&extra_info, RTLD_DL_LINKMAP) != 0;\n#else\n    dladdr_success = dladdr((void*)pointer, &dlinfo) != 0;\n#endif\n    if (!dladdr_success || !dlinfo.dli_fname)\n        return false;\n\n#ifdef __GLIBC__\n    // dlinfo.dli_fbase is not the right value for the main executable on linux\n    fbase = (uintptr_t)extra_info->l_addr;\n#else\n    fbase = (uintptr_t)dlinfo.dli_fbase;\n#endif\n    StringRef fname;\n    bool insysimage = (fbase == jl_sysimage_base);\n    if (saddr && !(insysimage && untrusted_dladdr))\n        *saddr = dlinfo.dli_saddr;\n    if (isSysImg)\n        *isSysImg = insysimage;\n    if (onlySysImg && !insysimage)\n        return false;\n    // In case we fail with the debug info lookup, we at least still\n    // have the function name, even if we don't have line numbers\n    if (name && !(insysimage && untrusted_dladdr))\n        jl_copy_str(name, dlinfo.dli_sname);\n    if (filename)\n        jl_copy_str(filename, dlinfo.dli_fname);\n    fname = dlinfo.dli_fname;\n#endif // ifdef _OS_WINDOWS_\n    auto &entry = find_object_file(fbase, fname);\n    *obj = entry.obj;\n    *context = entry.ctx;\n    *slide = entry.slide;\n    *section_slide = entry.section_slide;\n    get_function_name_and_base(entry.obj, insysimage, saddr, name, pointer, entry.slide,\n                               untrusted_dladdr);\n    return true;\n}\n\n// *name and *filename should be either NULL or malloc'd pointer\nstatic int jl_getDylibFunctionInfo(jl_frame_t **frames, size_t pointer, int skipC, int noInline)\n{\n    // This function is not allowed to reference any TLS variables if noInline\n    // since it can be called from an unmanaged thread on OSX.\n    jl_frame_t *frame0 = *frames;\n#ifdef _OS_WINDOWS_\n    static IMAGEHLP_LINE64 frame_info_line;\n    DWORD dwDisplacement = 0;\n    if (jl_in_stackwalk) {\n        frame0->fromC = 1;\n        return 1;\n    }\n    jl_in_stackwalk = 1;\n    DWORD64 dwAddress = pointer;\n    frame_info_line.SizeOfStruct = sizeof(IMAGEHLP_LINE64);\n    if (SymGetLineFromAddr64(GetCurrentProcess(), dwAddress, &dwDisplacement, &frame_info_line)) {\n        // SymGetLineFromAddr64 returned success\n        // record source file name and line number\n        if (frame_info_line.FileName)\n            jl_copy_str(&frame0->file_name, frame_info_line.FileName);\n        frame0->line = frame_info_line.LineNumber;\n    }\n    jl_in_stackwalk = 0;\n#endif\n    const object::ObjectFile *object;\n    llvm::DIContext *context = NULL;\n    bool isSysImg;\n    void *saddr;\n    int64_t slide, section_slide;\n    if (!jl_dylib_DI_for_fptr(pointer, &object, &context, &slide, &section_slide, skipC, &isSysImg, &saddr, &frame0->func_name, &frame0->file_name)) {\n        frame0->fromC = 1;\n        return 1;\n    }\n    frame0->fromC = !isSysImg;\n    if (isSysImg && sysimg_fptrs.base && saddr) {\n        intptr_t diff = (uintptr_t)saddr - (uintptr_t)sysimg_fptrs.base;\n        for (size_t i = 0; i < sysimg_fptrs.nclones; i++) {\n            if (diff == sysimg_fptrs.clone_offsets[i]) {\n                uint32_t idx = sysimg_fptrs.clone_idxs[i] & jl_sysimg_val_mask;\n                frame0->linfo = sysimg_fvars_linfo[idx];\n                break;\n            }\n        }\n        for (size_t i = 0; i < sysimg_fvars_n; i++) {\n            if (diff == sysimg_fptrs.offsets[i]) {\n                frame0->linfo = sysimg_fvars_linfo[i];\n                break;\n            }\n        }\n    }\n    return lookup_pointer(context, frames, pointer + slide, isSysImg, noInline);\n}\n\nint jl_DI_for_fptr(uint64_t fptr, uint64_t *symsize, int64_t *slide, int64_t *section_slide,\n                      const object::ObjectFile **object,\n                      llvm::DIContext **context\n                      )\n{\n    int found = 0;\n    *slide = 0;\n    std::map<size_t, ObjectInfo, revcomp> &objmap = jl_jit_events->getObjectMap();\n    std::map<size_t, ObjectInfo, revcomp>::iterator fit = objmap.lower_bound(fptr);\n\n    if (fit != objmap.end() && fptr < fit->first + fit->second.SectionSize) {\n        if (symsize)\n            *symsize = 0;\n        if (section_slide)\n            *section_slide = fit->second.slide;\n        *object = fit->second.object;\n        if (context) {\n            *context = fit->second.context;\n        }\n        found = 1;\n    }\n    uv_rwlock_rdunlock(&threadsafe);\n    return found;\n}\n\nextern \"C\"\nJL_DLLEXPORT jl_value_t *jl_get_dobj_data(uint64_t fptr)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    // Used by Gallium.jl\n    const object::ObjectFile *object = NULL;\n    DIContext *context;\n    int64_t slide, section_slide;\n    int8_t gc_state = jl_gc_safe_enter(ptls);\n    if (!jl_DI_for_fptr(fptr, NULL, &slide, NULL, &object, NULL))\n        if (!jl_dylib_DI_for_fptr(fptr, &object, &context, &slide, &section_slide, false, NULL, NULL, NULL, NULL)) {\n            jl_gc_safe_leave(ptls, gc_state);\n            return jl_nothing;\n        }\n    jl_gc_safe_leave(ptls, gc_state);\n    if (object == NULL)\n        return jl_nothing;\n    return (jl_value_t*)jl_ptr_to_array_1d((jl_value_t*)jl_array_uint8_type,\n        const_cast<char*>(object->getData().data()),\n        object->getData().size(), false);\n}\n\nextern \"C\"\nJL_DLLEXPORT uint64_t jl_get_section_start(uint64_t fptr)\n{\n    jl_ptls_t ptls = jl_get_ptls_states();\n    // Used by Gallium.jl\n    int8_t gc_state = jl_gc_safe_enter(ptls);\n    std::map<size_t, ObjectInfo, revcomp> &objmap = jl_jit_events->getObjectMap();\n    std::map<size_t, ObjectInfo, revcomp>::iterator fit = objmap.lower_bound(fptr);\n\n    uint64_t ret = 0;\n    if (fit != objmap.end() && fptr < fit->first + fit->second.SectionSize) {\n        ret = fit->first;\n    }\n    else {\n       obfiletype::iterator objit = objfilemap.lower_bound(fptr);\n       // Ideally we'd have a containment check here, but we can't really\n       // get the shared library size easily.\n       if (objit != objfilemap.end()) {\n           ret = objit->first;\n       }\n    }\n    uv_rwlock_rdunlock(&threadsafe);\n    jl_gc_safe_leave(ptls, gc_state);\n    return ret;\n}\n\n// Set *name and *filename to either NULL or malloc'd string\nint jl_getFunctionInfo(jl_frame_t **frames_out, size_t pointer, int skipC, int noInline)\n{\n    // This function is not allowed to reference any TLS variables if noInline\n    // since it can be called from an unmanaged thread on OSX.\n\n    jl_frame_t *frames = (jl_frame_t*)calloc(sizeof(jl_frame_t), 1);\n    frames[0].line = -1;\n    *frames_out = frames;\n\n    llvm::DIContext *context;\n    const llvm::object::ObjectFile *object;\n    uint64_t symsize;\n    int64_t slide = 0;\n    if (jl_DI_for_fptr(pointer, &symsize, &slide, NULL, &object, &context)) {\n        frames[0].linfo = jl_jit_events->lookupLinfo(pointer);\n        int nf = lookup_pointer(context, frames_out, pointer+slide, 1, noInline);\n        return nf;\n    }\n    return jl_getDylibFunctionInfo(frames_out, pointer, skipC, noInline);\n}\n\nextern \"C\" jl_method_instance_t *jl_gdblookuplinfo(void *p)\n{\n    return jl_jit_events->lookupLinfo((size_t)p);\n}\n\n#if (defined(_OS_LINUX_) || (defined(_OS_DARWIN_) && defined(LLVM_SHLIB)))\nextern \"C\" void __register_frame(void*);\nextern \"C\" void __deregister_frame(void*);\n\ntemplate <typename callback>\nstatic void processFDEs(const char *EHFrameAddr, size_t EHFrameSize, callback f)\n{\n    const char *P = EHFrameAddr;\n    const char *End = P + EHFrameSize;\n    do {\n        const char *Entry = P;\n        P += 4;\n        assert(P <= End);\n        uint32_t Length = *(const uint32_t*)Entry;\n        // Length == 0: Terminator\n        if (Length == 0)\n            break;\n        assert(P + Length <= End);\n        uint32_t Offset = *(const uint32_t*)P;\n        // Offset == 0: CIE\n        if (Offset != 0)\n            f(Entry);\n        P += Length;\n    } while (P != End);\n}\n#endif\n\n#if defined(_OS_DARWIN_) && defined(LLVM_SHLIB)\n\n/*\n * We use a custom unwinder, so we need to make sure that when registering dynamic\n * frames, we do so with our unwinder rather than with the system one. If LLVM is\n * statically linked everything works out fine, but if it's dynamically linked\n * it would usually pick up the system one, so we need to do the registration\n * ourselves to ensure the right one gets picked.\n */\n\nstatic void (*libc_register_frame)(void*)   = NULL;\nstatic void (*libc_deregister_frame)(void*) = NULL;\n\n// This implementation handles frame registration for local targets.\nvoid register_eh_frames(uint8_t *Addr, size_t Size)\n{\n  // On OS X OS X __register_frame takes a single FDE as an argument.\n  // See http://lists.cs.uiuc.edu/pipermail/llvmdev/2013-April/061768.html\n  processFDEs((char*)Addr, Size, [](const char *Entry) {\n        if (!libc_register_frame) {\n          libc_register_frame = (void(*)(void*))dlsym(RTLD_NEXT,\"__register_frame\");\n        }\n        assert(libc_register_frame);\n        libc_register_frame(const_cast<char *>(Entry));\n        __register_frame(const_cast<char *>(Entry));\n    });\n}\n\nvoid deregister_eh_frames(uint8_t *Addr, size_t Size)\n{\n   processFDEs((char*)Addr, Size, [](const char *Entry) {\n        if (!libc_deregister_frame) {\n          libc_deregister_frame = (void(*)(void*))dlsym(RTLD_NEXT,\"__deregister_frame\");\n        }\n        assert(libc_deregister_frame);\n        libc_deregister_frame(const_cast<char *>(Entry));\n        __deregister_frame(const_cast<char *>(Entry));\n    });\n}\n\n#elif defined(_OS_LINUX_) && \\\n    defined(JL_UNW_HAS_FORMAT_IP) && !defined(_CPU_ARM_)\n#include <type_traits>\n\nstruct unw_table_entry\n{\n    int32_t start_ip_offset;\n    int32_t fde_offset;\n};\n\n// Skip over an arbitrary long LEB128 encoding.\n// Return the pointer to the first unprocessed byte.\nstatic const uint8_t *consume_leb128(const uint8_t *Addr, const uint8_t *End)\n{\n    const uint8_t *P = Addr;\n    while ((*P >> 7) != 0 && P < End)\n        ++P;\n    return P + 1;\n}\n\n// Parse a LEB128 encoding to a type T. Truncate the result if there's more\n// bytes than what there are more bytes than what the type can store.\n// Adjust the pointer to the first unprocessed byte.\ntemplate<typename T> static T parse_leb128(const uint8_t *&Addr,\n                                           const uint8_t *End)\n{\n    typedef typename std::make_unsigned<T>::type uT;\n    uT v = 0;\n    for (unsigned i = 0;i < ((sizeof(T) * 8 - 1) / 7 + 1);i++) {\n        uint8_t a = *Addr;\n        Addr++;\n        v |= uT(a & 0x7f) << (i * 7);\n        if ((a & 0x80) == 0 || Addr >= End) {\n            if (a & 0x40 && std::is_signed<T>::value) {\n                int valid_bits = (i + 1) * 7;\n                if (valid_bits < 64) {\n                    v |= -(uT(1) << valid_bits);\n                }\n            }\n            return T(v);\n        }\n    }\n    Addr = consume_leb128(Addr, End);\n    return T(v);\n}\n\ntemplate <typename U, typename T>\nstatic U safe_trunc(T t)\n{\n    assert((t >= static_cast<T>(std::numeric_limits<U>::min()))\n           && (t <= static_cast<T>(std::numeric_limits<U>::max())));\n    return static_cast<U>(t);\n}\n\n// How the address and size in the FDE are encoded.\nenum DW_EH_PE : uint8_t {\n    DW_EH_PE_absptr = 0x00, /* An absolute pointer. The size is determined by\n                             * whether this is a 32-bit or 64-bit address space,\n                             * and will be 32 or 64 bits */\n    DW_EH_PE_omit = 0xff, // The value is omitted\n    DW_EH_PE_uleb128 = 0x01, // The value is an unsigned LEB128\n    DW_EH_PE_udata2 = 0x02,\n    DW_EH_PE_udata4 = 0x03,\n    DW_EH_PE_udata8 = 0x04, /* The value is stored as unsigned data with the\n                             * specified number of bytes. */\n    DW_EH_PE_signed = 0x08, /* A signed number. The size is determined by\n                             * whether this is a 32-bit or 64-bit address space */\n    DW_EH_PE_sleb128 = 0x09, /* A signed LEB128. */\n    DW_EH_PE_sdata2 = 0x0a,\n    DW_EH_PE_sdata4 = 0x0b,\n    DW_EH_PE_sdata8 = 0x0c, /* The value is stored as signed data with the\n                             * specified number of bytes. */\n\n    // In addition the above basic encodings, there are modifiers.\n\n    DW_EH_PE_pcrel = 0x10, // Value is PC relative.\n\n    // We currently don't support the following once.\n    DW_EH_PE_textrel = 0x20, // Value is text relative.\n    DW_EH_PE_datarel = 0x30, // Value is data relative.\n    DW_EH_PE_funcrel = 0x40, // Value is relative to start of function.\n    DW_EH_PE_aligned = 0x50, /* Value is aligned: padding bytes are inserted as\n                              * required to make value be naturally aligned. */\n    DW_EH_PE_indirect = 0x80 /* This is actually the address of the real value. */\n};\n\n// Parse the CIE and return the type of encoding used by FDE\nstatic DW_EH_PE parseCIE(const uint8_t *Addr, const uint8_t *End)\n{\n    // http://www.airs.com/blog/archives/460\n    // Length (4 bytes)\n    uint32_t cie_size = *(const uint32_t*)Addr;\n    const uint8_t *cie_addr = Addr + 4;\n    const uint8_t *p = cie_addr;\n    const uint8_t *cie_end = cie_addr + cie_size;\n    assert(cie_end <= End);\n    // Check this is an CIE record (CIE ID: 4 bytes)\n    assert(*(const uint32_t*)cie_addr == 0);\n    p += 4;\n    // Check CIE version (1 byte)\n    uint8_t cie_version = *p;\n    assert(cie_version == 1 || cie_version == 3);\n    p++;\n    // Augmentation String (NUL terminate)\n    const char *augmentation = (const char*)p;\n    size_t augmentation_len = strlen(augmentation);\n    // Assume there's no EH Data field, which exist when the augmentation\n    // string has \"eh\" in it.\n    p += augmentation_len + 1;\n    // Code Alignment Factor (1 byte)\n    // should always be 1 on x86, 4 on PPC, etc.\n    // (used for DW_CFA_advance_loc / not used here)\n    //assert(*p == 1);\n    p++;\n    // Data Alignment Factor (LEB128)\n    assert(cie_end >= p);\n    p = consume_leb128(p, cie_end);\n    // return address register\n    if (cie_version == 1) {\n        p++;\n    }\n    else {\n        p = consume_leb128(p, cie_end);\n    }\n    // Now it's the augmentation data. which may have the information we\n    // are interested in...\n    for (const char *augp = augmentation;;augp++) {\n        switch (*augp) {\n        case 'z':\n            // Augmentation Length\n            p = consume_leb128(p, cie_end);\n            break;\n        case 'L':\n            // LSDA encoding\n            p++;\n            break;\n        case 'R':\n            // .... the only one we care about ....\n            return static_cast<DW_EH_PE>(*p);\n        case 'P': {\n            // Personality data\n            // Encoding\n            auto encoding = static_cast<DW_EH_PE>(*p);\n            p++;\n            // Personality function\n            switch (encoding & 0xf) {\n            case DW_EH_PE_uleb128:\n            case DW_EH_PE_sleb128:\n                p = consume_leb128(p, cie_end);\n                break;\n            case DW_EH_PE_udata2:\n            case DW_EH_PE_sdata2:\n                p += 2;\n                break;\n            case DW_EH_PE_udata4:\n            case DW_EH_PE_sdata4:\n                p += 4;\n                break;\n            case DW_EH_PE_udata8:\n            case DW_EH_PE_sdata8:\n                p += 8;\n                break;\n            case DW_EH_PE_signed:\n                p += sizeof(void*);\n                break;\n            default:\n                if (encoding == DW_EH_PE_absptr || encoding == DW_EH_PE_omit) {\n                    p += sizeof(void*);\n                }\n                else {\n                    assert(0 && \"Invalid personality encoding.\");\n                }\n                break;\n            }\n        }\n            break;\n        default:\n            continue;\n        }\n        assert(cie_end >= p);\n    }\n    return DW_EH_PE_absptr;\n}\n\nvoid register_eh_frames(uint8_t *Addr, size_t Size)\n{\n    // System unwinder\n    __register_frame(Addr);\n    // Our unwinder\n    unw_dyn_info_t *di = new unw_dyn_info_t;\n    // In a shared library, this is set to the address of the PLT.\n    // For us, just put 0 to emulate a static library. This field does\n    // not seem to be used on our supported architectures.\n    di->gp = 0;\n    // I'm not a great fan of the naming of this constant, but it means the\n    // right thing, which is a table of FDEs and ips.\n    di->format = UNW_INFO_FORMAT_IP_OFFSET;\n    di->u.rti.name_ptr = 0;\n    di->u.rti.segbase = (unw_word_t)Addr;\n    // Now first count the number of FDEs\n    size_t nentries = 0;\n    processFDEs((char*)Addr, Size, [&](const char*){ nentries++; });\n\n    uintptr_t start_ip = (uintptr_t)-1;\n    uintptr_t end_ip = 0;\n\n    // Then allocate a table and fill in the information\n    // While we're at it, also record the start_ip and size,\n    // which we fill in the table\n    unw_table_entry *table = new unw_table_entry[nentries];\n    std::vector<uintptr_t> start_ips(nentries);\n    size_t cur_entry = 0;\n    // Cache the previously parsed CIE entry so that we can support multiple\n    // CIE's (may not happen) without parsing it every time.\n    const uint8_t *cur_cie = nullptr;\n    DW_EH_PE encoding = DW_EH_PE_omit;\n    processFDEs((char*)Addr, Size, [&](const char *Entry) {\n            // Skip Length (4bytes) and CIE offset (4bytes)\n            uint32_t fde_size = *(const uint32_t*)Entry;\n            uint32_t cie_id = ((const uint32_t*)Entry)[1];\n            const uint8_t *cie_addr = (const uint8_t*)(Entry + 4 - cie_id);\n            if (cie_addr != cur_cie)\n                encoding = parseCIE(cie_addr, Addr + Size);\n            const uint8_t *fde_end = (const uint8_t*)(Entry + 4 + fde_size);\n            const uint8_t *EntryPtr = (const uint8_t*)(Entry + 8);\n            uintptr_t start = 0;\n            uintptr_t size = 0;\n            // The next two fields are address and size of the PC range\n            // covered by this FDE.\n            if (encoding == DW_EH_PE_absptr || encoding == DW_EH_PE_omit) {\n                assert(fde_size >= 2 * sizeof(void*) + 4);\n                start = *(const uintptr_t*)EntryPtr;\n                size = *(const uintptr_t*)(EntryPtr + sizeof(void*));\n            }\n            else {\n                uintptr_t baseptr = (uintptr_t)EntryPtr;\n                // Only support pcrel for now...\n                assert((encoding & 0xf0) == 0x10 &&\n                       \"Only pcrel mode is supported\");\n                switch (encoding & 0xf) {\n                case DW_EH_PE_uleb128:\n                    start = baseptr + parse_leb128<uintptr_t>(EntryPtr, fde_end);\n                    size = parse_leb128<uintptr_t>(EntryPtr, fde_end);\n                    break;\n                case DW_EH_PE_udata2:\n                    assert(fde_size >= 2 * 2 + 4);\n                    start = baseptr + ((const uint16_t*)EntryPtr)[0];\n                    size = ((const uint16_t*)EntryPtr)[1];\n                    break;\n                case DW_EH_PE_udata4:\n                    assert(fde_size >= 2 * 4 + 4);\n                    start = baseptr + ((const uint32_t*)EntryPtr)[0];\n                    size = ((const uint32_t*)EntryPtr)[1];\n                    break;\n                case DW_EH_PE_udata8:\n                    assert(fde_size >= 2 * 8 + 4);\n                    start = uintptr_t(baseptr + ((const uint64_t*)EntryPtr)[0]);\n                    size = uintptr_t(((const uint64_t*)EntryPtr)[1]);\n                    break;\n                case DW_EH_PE_signed:\n                    assert(fde_size >= 2 * sizeof(void*) + 4);\n                    start = baseptr + ((const intptr_t*)EntryPtr)[0];\n                    size = ((const intptr_t*)EntryPtr)[1];\n                    break;\n                case DW_EH_PE_sleb128:\n                    start = baseptr + parse_leb128<intptr_t>(EntryPtr, fde_end);\n                    size = parse_leb128<intptr_t>(EntryPtr, fde_end);\n                    break;\n                case DW_EH_PE_sdata2:\n                    assert(fde_size >= 2 * 2 + 4);\n                    start = baseptr + ((const int16_t*)EntryPtr)[0];\n                    size = ((const int16_t*)EntryPtr)[1];\n                    break;\n                case DW_EH_PE_sdata4:\n                    assert(fde_size >= 2 * 4 + 4);\n                    start = baseptr + ((const int32_t*)EntryPtr)[0];\n                    size = ((const int32_t*)EntryPtr)[1];\n                    break;\n                case DW_EH_PE_sdata8:\n                    assert(fde_size >= 2 * 8 + 4);\n                    start = uintptr_t(baseptr + ((const int64_t*)EntryPtr)[0]);\n                    size = uintptr_t(((const int64_t*)EntryPtr)[1]);\n                    break;\n                default:\n                    assert(0 && \"Invalid FDE encoding.\");\n                    break;\n                }\n            }\n\n            if (start < start_ip)\n                start_ip = start;\n            if (end_ip < (start + size))\n                end_ip = start + size;\n            table[cur_entry].fde_offset =\n                safe_trunc<int32_t>((intptr_t)Entry - (intptr_t)Addr);\n            start_ips[cur_entry] = start;\n            cur_entry++;\n        });\n    for (size_t i = 0;i < nentries;i++) {\n        table[i].start_ip_offset =\n            safe_trunc<int32_t>((intptr_t)start_ips[i] - (intptr_t)start_ip);\n    }\n    assert(end_ip != 0);\n\n    di->u.rti.table_len = nentries * sizeof(*table) / sizeof(unw_word_t);\n    di->u.rti.table_data = (unw_word_t)table;\n    di->start_ip = start_ip;\n    di->end_ip = end_ip;\n\n    _U_dyn_register(di);\n}\n\nvoid deregister_eh_frames(uint8_t *Addr, size_t Size)\n{\n    __deregister_frame(Addr);\n    // Deregistering with our unwinder requires a lookup table to find the\n    // the allocated entry above (or we could look in libunwind's internal\n    // data structures).\n}\n\n#elif defined(_CPU_ARM_)\n\nvoid register_eh_frames(uint8_t *Addr, size_t Size)\n{\n}\n\nvoid deregister_eh_frames(uint8_t *Addr, size_t Size)\n{\n}\n\n#else\n\nvoid register_eh_frames(uint8_t *Addr, size_t Size)\n{\n}\n\nvoid deregister_eh_frames(uint8_t *Addr, size_t Size)\n{\n}\n\n#endif\n\nextern \"C\"\nuint64_t jl_getUnwindInfo(uint64_t dwAddr)\n{\n    // Might be called from unmanaged thread\n    std::map<size_t, ObjectInfo, revcomp> &objmap = jl_jit_events->getObjectMap();\n    std::map<size_t, ObjectInfo, revcomp>::iterator it = objmap.lower_bound(dwAddr);\n    uint64_t ipstart = 0; // ip of the start of the section (if found)\n    if (it != objmap.end() && dwAddr < it->first + it->second.SectionSize) {\n        ipstart = (uint64_t)(uintptr_t)(*it).first;\n    }\n    uv_rwlock_rdunlock(&threadsafe);\n    return ipstart;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/src/ccall.cpp": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n// --- the ccall, cglobal, and llvm intrinsics ---\n\n// Map from symbol name (in a certain library) to its GV in sysimg and the\n// DL handle address in the current session.\ntypedef StringMap<std::pair<GlobalVariable*,void*>> SymMapGV;\nstatic StringMap<std::pair<GlobalVariable*,SymMapGV>> libMapGV;\n#ifdef _OS_WINDOWS_\nstatic SymMapGV symMapExe;\nstatic SymMapGV symMapDl;\n#endif\nstatic SymMapGV symMapDefault;\n\ntemplate<typename Func>\nstruct LazyModule {\n    Func func;\n    Module *m;\n    template<typename Func2>\n    LazyModule(Func2 &&func)\n        : func(std::forward<Func2>(func)),\n          m(nullptr)\n    {}\n    Module *get()\n    {\n        if (!m)\n            m = func();\n        return m;\n    }\n    Module &operator*()\n    {\n        return *get();\n    }\n};\n\ntemplate<typename Func>\nstatic LazyModule<typename std::remove_reference<Func>::type>\nlazyModule(Func &&func)\n{\n    return LazyModule<typename std::remove_reference<Func>::type>(\n        std::forward<Func>(func));\n}\n\n// Find or create the GVs for the library and symbol lookup.\n// Return `runtime_lib` (whether the library name is a string)\n// Optionally return the symbol address in the current session\n// when `symaddr != nullptr`.\n// The `lib` and `sym` GV returned may not be in the current module.\ntemplate<typename MT>\nstatic bool runtime_sym_gvs(const char *f_lib, const char *f_name, MT &&M,\n                            GlobalVariable *&lib, GlobalVariable *&sym,\n                            void **symaddr=nullptr)\n{\n    void *libsym = NULL;\n    bool runtime_lib = false;\n    GlobalVariable *libptrgv;\n    SymMapGV *symMap;\n#ifdef _OS_WINDOWS_\n    if ((intptr_t)f_lib == 1) {\n        libptrgv = jlexe_var;\n        libsym = jl_exe_handle;\n        symMap = &symMapExe;\n    }\n    else if ((intptr_t)f_lib == 2) {\n        libptrgv = jldll_var;\n        libsym = jl_dl_handle;\n        symMap = &symMapDl;\n    }\n    else\n#endif\n    if (f_lib == NULL) {\n        libptrgv = jlRTLD_DEFAULT_var;\n        libsym = jl_RTLD_DEFAULT_handle;\n        symMap = &symMapDefault;\n    }\n    else {\n        std::string name = \"ccalllib_\";\n        name += f_lib;\n        runtime_lib = true;\n        auto iter = libMapGV.find(f_lib);\n        if (iter == libMapGV.end()) {\n            libptrgv = new GlobalVariable(*M, T_pint8, false,\n                                          GlobalVariable::ExternalLinkage,\n                                          NULL, name);\n            auto &libgv = libMapGV[f_lib];\n            libgv = std::make_pair(global_proto(libptrgv), SymMapGV());\n            symMap = &libgv.second;\n            libsym = jl_get_library(f_lib);\n            assert(libsym != NULL);\n            *(void**)jl_emit_and_add_to_shadow(libptrgv) = libsym;\n        }\n        else {\n            libptrgv = iter->second.first;\n            symMap = &iter->second.second;\n        }\n    }\n    if (libsym == NULL) {\n        libsym = *(void**)jl_get_globalvar(libptrgv);\n    }\n    assert(libsym != NULL);\n\n    GlobalVariable *llvmgv;\n    auto sym_iter = symMap->find(f_name);\n    if (sym_iter == symMap->end()) {\n        // MCJIT forces this to have external linkage eventually, so we would clobber\n        // the symbol of the actual function.\n        std::string name = \"ccall_\";\n        name += f_name;\n        name += \"_\";\n        name += std::to_string(globalUnique++);\n        llvmgv = new GlobalVariable(*M, T_pvoidfunc, false,\n                                    GlobalVariable::ExternalLinkage, NULL, name);\n        llvmgv = global_proto(llvmgv);\n        void *addr = jl_dlsym_e(libsym, f_name);\n        (*symMap)[f_name] = std::make_pair(llvmgv, addr);\n        if (symaddr)\n            *symaddr = addr;\n        *(void**)jl_emit_and_add_to_shadow(llvmgv) = addr;\n    }\n    else {\n        if (symaddr)\n            *symaddr = sym_iter->second.second;\n        llvmgv = sym_iter->second.first;\n    }\n\n    lib = libptrgv;\n    sym = llvmgv;\n    return runtime_lib;\n}\n\nstatic Value *runtime_sym_lookup(\n        IRBuilder<> &irbuilder,\n        PointerType *funcptype, const char *f_lib,\n        const char *f_name, Function *f,\n        GlobalVariable *libptrgv,\n        GlobalVariable *llvmgv, bool runtime_lib)\n{\n    // in pseudo-code, this function emits the following:\n    //   global HMODULE *libptrgv\n    //   global void **llvmgv\n    //   if (*llvmgv == NULL) {\n    //       *llvmgv = jl_load_and_lookup(f_lib, f_name, libptrgv);\n    //   }\n    //   return (*llvmgv)\n    BasicBlock *enter_bb = irbuilder.GetInsertBlock();\n    BasicBlock *dlsym_lookup = BasicBlock::Create(jl_LLVMContext, \"dlsym\");\n    BasicBlock *ccall_bb = BasicBlock::Create(jl_LLVMContext, \"ccall\");\n    Constant *initnul = ConstantPointerNull::get((PointerType*)T_pvoidfunc);\n    LoadInst *llvmf_orig = irbuilder.CreateAlignedLoad(llvmgv, sizeof(void*));\n    // This in principle needs a consume ordering so that load from\n    // this pointer sees a valid value. However, this is not supported by\n    // LLVM (or agreed on in the C/C++ standard FWIW) and should be\n    // almost impossible to happen on every platform we support since this\n    // ordering is enforced by the hardware and LLVM has to speculate an\n    // invalid load from the `cglobal` but doesn't depend on the `cglobal`\n    // value for this to happen.\n    // llvmf_orig->setAtomic(AtomicOrdering::Consume);\n    irbuilder.CreateCondBr(\n            irbuilder.CreateICmpNE(llvmf_orig, initnul),\n            ccall_bb,\n            dlsym_lookup);\n\n    assert(f->getParent() != NULL);\n    f->getBasicBlockList().push_back(dlsym_lookup);\n    irbuilder.SetInsertPoint(dlsym_lookup);\n    Value *libname;\n    if (runtime_lib) {\n        libname = stringConstPtr(irbuilder, f_lib);\n    }\n    else {\n        // f_lib is actually one of the special sentinel values\n        libname = ConstantExpr::getIntToPtr(ConstantInt::get(T_size, (uintptr_t)f_lib), T_pint8);\n    }\n    Value *llvmf = irbuilder.CreateCall(prepare_call_in(jl_builderModule(irbuilder), jldlsym_func),\n            { libname, stringConstPtr(irbuilder, f_name), libptrgv });\n    auto store = irbuilder.CreateAlignedStore(llvmf, llvmgv, sizeof(void*));\n    store->setAtomic(AtomicOrdering::Release);\n    irbuilder.CreateBr(ccall_bb);\n\n    f->getBasicBlockList().push_back(ccall_bb);\n    irbuilder.SetInsertPoint(ccall_bb);\n    PHINode *p = irbuilder.CreatePHI(T_pvoidfunc, 2);\n    p->addIncoming(llvmf_orig, enter_bb);\n    p->addIncoming(llvmf, dlsym_lookup);\n    return irbuilder.CreateBitCast(p, funcptype);\n}\n\nstatic Value *runtime_sym_lookup(\n        jl_codectx_t &ctx,\n        PointerType *funcptype, const char *f_lib,\n        const char *f_name, Function *f)\n{\n    GlobalVariable *libptrgv;\n    GlobalVariable *llvmgv;\n    bool runtime_lib = runtime_sym_gvs(f_lib, f_name, f->getParent(),\n                                       libptrgv, llvmgv);\n    libptrgv = prepare_global(libptrgv);\n    llvmgv = prepare_global(llvmgv);\n    return runtime_sym_lookup(ctx.builder, funcptype, f_lib, f_name, f, libptrgv, llvmgv,\n                              runtime_lib);\n}\n\n// Map from distinct callee's to its GOT entry.\n// In principle the attribute, function type and calling convention\n// don't need to be part of the key but it seems impossible to forward\n// all the arguments without writing assembly directly.\n// This doesn't matter too much in reality since a single function is usually\n// not called with multiple signatures.\n#if JL_LLVM_VERSION >= 50000\nstatic DenseMap<AttributeList,\n#else\nstatic DenseMap<AttributeSet,\n#endif\n                std::map<std::tuple<GlobalVariable*,FunctionType*,\n                                    CallingConv::ID>,GlobalVariable*>> allPltMap;\n\n// Emit a \"PLT\" entry that will be lazily initialized\n// when being called the first time.\nstatic GlobalVariable *emit_plt_thunk(\n        Module *M, FunctionType *functype,\n#if JL_LLVM_VERSION >= 50000\n        const AttributeList &attrs,\n#else\n        const AttributeSet &attrs,\n#endif\n        CallingConv::ID cc, const char *f_lib, const char *f_name,\n        GlobalVariable *libptrgv, GlobalVariable *llvmgv,\n        void *symaddr, bool runtime_lib)\n{\n    PointerType *funcptype = PointerType::get(functype, 0);\n    libptrgv = prepare_global_in(M, libptrgv);\n    llvmgv = prepare_global_in(M, llvmgv);\n    std::stringstream funcName;\n    funcName << \"jlplt_\" << f_name << \"_\" << globalUnique++;\n    auto fname = funcName.str();\n    Function *plt = Function::Create(functype,\n                                     GlobalVariable::ExternalLinkage,\n                                     fname, M);\n    jl_init_function(plt);\n    plt->setAttributes(attrs);\n    if (cc != CallingConv::C)\n        plt->setCallingConv(cc);\n    funcName << \"_got\";\n    auto gname = funcName.str();\n    GlobalVariable *got = new GlobalVariable(*M, T_pvoidfunc, false,\n                                             GlobalVariable::ExternalLinkage,\n                                             nullptr, gname);\n    *(void**)jl_emit_and_add_to_shadow(got) = symaddr;\n    BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, \"top\", plt);\n    IRBuilder<> irbuilder(b0);\n    Value *ptr = runtime_sym_lookup(irbuilder, funcptype, f_lib, f_name, plt, libptrgv,\n                                    llvmgv, runtime_lib);\n    auto store = irbuilder.CreateAlignedStore(irbuilder.CreateBitCast(ptr, T_pvoidfunc), got, sizeof(void*));\n    store->setAtomic(AtomicOrdering::Release);\n    SmallVector<Value*, 16> args;\n    for (Function::arg_iterator arg = plt->arg_begin(), arg_e = plt->arg_end(); arg != arg_e; ++arg)\n        args.push_back(&*arg);\n    CallInst *ret = irbuilder.CreateCall(ptr, ArrayRef<Value*>(args));\n    ret->setAttributes(attrs);\n    if (cc != CallingConv::C)\n        ret->setCallingConv(cc);\n    // NoReturn function can trigger LLVM verifier error when declared as\n    // MustTail since other passes might replace the `ret` with\n    // `unreachable` (LLVM should probably accept `unreachable`).\n#if JL_LLVM_VERSION >= 50000\n    if (attrs.hasAttribute(AttributeList::FunctionIndex,\n#else\n    if (attrs.hasAttribute(AttributeSet::FunctionIndex,\n#endif\n                           Attribute::NoReturn)) {\n        irbuilder.CreateUnreachable();\n    }\n    else {\n        // musttail support is very bad on ARM, PPC, PPC64 (as of LLVM 3.9)\n        // Known failures includes vararg (not needed here) and sret.\n#if (defined(_CPU_X86_) || defined(_CPU_X86_64_) || \\\n                        defined(_CPU_AARCH64_))\n        ret->setTailCallKind(CallInst::TCK_MustTail);\n#endif\n        if (functype->getReturnType() == T_void) {\n            irbuilder.CreateRetVoid();\n        }\n        else {\n            irbuilder.CreateRet(ret);\n        }\n    }\n    irbuilder.ClearInsertionPoint();\n    got = global_proto(got); // exchange got for the permanent global before jl_finalize_module destroys it\n    jl_finalize_module(M, true);\n\n    auto shadowgot =\n        cast<GlobalVariable>(shadow_output->getNamedValue(gname));\n    auto shadowplt = cast<Function>(shadow_output->getNamedValue(fname));\n    shadowgot->setInitializer(ConstantExpr::getBitCast(shadowplt,\n                                                       T_pvoidfunc));\n    return got;\n}\n\nstatic Value *emit_plt(\n        jl_codectx_t &ctx,\n        FunctionType *functype,\n#if JL_LLVM_VERSION >= 50000\n       const AttributeList &attrs,\n#else\n       const AttributeSet &attrs,\n#endif\n       CallingConv::ID cc, const char *f_lib, const char *f_name)\n{\n    assert(imaging_mode);\n    // Don't do this for vararg functions so that the `musttail` is only\n    // an optimization and is not required to function correctly.\n    assert(!functype->isVarArg());\n    GlobalVariable *libptrgv;\n    GlobalVariable *llvmgv;\n    void *symaddr;\n    auto LM = lazyModule([&] {\n            Module *m = new Module(f_name, jl_LLVMContext);\n            jl_setup_module(m);\n            return m;\n        });\n    bool runtime_lib = runtime_sym_gvs(f_lib, f_name, LM,\n                                       libptrgv, llvmgv, &symaddr);\n    PointerType *funcptype = PointerType::get(functype, 0);\n\n    auto &pltMap = allPltMap[attrs];\n    auto key = std::make_tuple(llvmgv, functype, cc);\n    GlobalVariable *&shadowgot = pltMap[key];\n    if (!shadowgot) {\n        shadowgot = emit_plt_thunk(LM.get(), functype, attrs, cc, f_lib, f_name, libptrgv, llvmgv, symaddr, runtime_lib);\n    }\n    else {\n        // `runtime_sym_gvs` shouldn't have created anything in a new module\n        // if it returns a GV that already exists.\n        assert(!LM.m);\n    }\n    GlobalVariable *got = prepare_global(shadowgot);\n    LoadInst *got_val = ctx.builder.CreateAlignedLoad(got, sizeof(void*));\n    // See comment in `runtime_sym_lookup` above. This in principle needs a\n    // consume ordering too. This is even less likely to cause issues though\n    // since the only thing we do to this loaded pointer is to call it\n    // immediately.\n    // got_val->setAtomic(AtomicOrdering::Consume);\n    return ctx.builder.CreateBitCast(got_val, funcptype);\n}\n\n// --- ABI Implementations ---\n// Partially based on the LDC ABI implementations licensed under the BSD 3-clause license\n\nclass AbiLayout {\npublic:\n    virtual ~AbiLayout() {}\n    virtual bool use_sret(jl_datatype_t *ty) = 0;\n    virtual bool needPassByRef(jl_datatype_t *ty, AttrBuilder&) = 0;\n    virtual Type *preferred_llvm_type(jl_datatype_t *ty, bool isret) const = 0;\n};\n\n// Determine if object of bitstype ty maps to a native x86 SIMD type (__m128, __m256, or __m512) in C\nstatic bool is_native_simd_type(jl_datatype_t *dt) {\n    size_t size = jl_datatype_size(dt);\n    if (size != 16 && size != 32 && size != 64)\n        // Wrong size for xmm, ymm, or zmm register.\n        return false;\n    uint32_t n = jl_datatype_nfields(dt);\n    if (n<2)\n        // Not mapped to SIMD register.\n        return false;\n    jl_value_t *ft0 = jl_field_type(dt, 0);\n    for (uint32_t i = 1; i < n; ++i)\n        if (jl_field_type(dt, i) != ft0)\n            // Not homogeneous\n            return false;\n    // Type is homogeneous.  Check if it maps to LLVM vector.\n    return jl_special_vector_alignment(n, ft0) != 0;\n}\n\n#include \"abi_llvm.cpp\"\n\n#include \"abi_arm.cpp\"\n#include \"abi_aarch64.cpp\"\n#include \"abi_ppc64le.cpp\"\n#include \"abi_win32.cpp\"\n#include \"abi_win64.cpp\"\n#include \"abi_x86_64.cpp\"\n#include \"abi_x86.cpp\"\n\n#if defined ABI_LLVM\n  typedef ABI_LLVMLayout DefaultAbiState;\n#elif defined _CPU_X86_64_\n#  if defined _OS_WINDOWS_\n     typedef ABI_Win64Layout DefaultAbiState;\n#  else\n     typedef ABI_x86_64Layout DefaultAbiState;\n#  endif\n#elif defined _CPU_X86_\n#  if defined _OS_WINDOWS_\n     typedef ABI_Win32Layout DefaultAbiState;\n#  else\n     typedef ABI_x86Layout DefaultAbiState;\n#  endif\n#elif defined _CPU_ARM_\n  typedef ABI_ARMLayout DefaultAbiState;\n#elif defined _CPU_AARCH64_\n  typedef ABI_AArch64Layout DefaultAbiState;\n#elif defined _CPU_PPC64_\n  typedef ABI_PPC64leLayout DefaultAbiState;\n#else\n#  warning \"ccall is defaulting to llvm ABI, since no platform ABI has been defined for this CPU/OS combination\"\n  typedef ABI_LLVMLayout DefaultAbiState;\n#endif\n\n// basic type widening and cast conversions\nstatic Value *llvm_type_rewrite(\n        jl_codectx_t &ctx,\n        Value *v, Type *target_type,\n        bool issigned) /* determines whether an integer value should be zero or sign extended */\n{\n    Type *from_type = v->getType();\n    if (target_type == from_type)\n        return v;\n\n    if (from_type == T_void || isa<UndefValue>(v))\n        return UndefValue::get(target_type); // convert undef (unreachable) -> undef (target_type)\n\n    assert(from_type->isPointerTy() == target_type->isPointerTy()); // expect that all ABIs consider all pointers to be equivalent\n    if (target_type->isPointerTy())\n        return emit_bitcast(ctx, v, target_type);\n\n    // simple integer and float widening & conversion cases\n    if (from_type->getPrimitiveSizeInBits() > 0 &&\n            target_type->getPrimitiveSizeInBits() == from_type->getPrimitiveSizeInBits())\n        return emit_bitcast(ctx, v, target_type);\n\n    if (target_type->isFloatingPointTy() && from_type->isFloatingPointTy()) {\n        if (target_type->getPrimitiveSizeInBits() > from_type->getPrimitiveSizeInBits())\n            return ctx.builder.CreateFPExt(v, target_type);\n        else if (target_type->getPrimitiveSizeInBits() < from_type->getPrimitiveSizeInBits())\n            return ctx.builder.CreateFPTrunc(v, target_type);\n        else\n            return v;\n    }\n\n    if (target_type->isIntegerTy() && from_type->isIntegerTy()) {\n        if (issigned)\n            return ctx.builder.CreateSExtOrTrunc(v, target_type);\n        else\n            return ctx.builder.CreateZExtOrTrunc(v, target_type);\n    }\n\n    // one or both of from_type and target_type is a VectorType or AggregateType\n    // LLVM doesn't allow us to cast these values directly, so\n    // we need to use this alloca copy trick instead\n    // On ARM and AArch64, the ABI requires casting through memory to different\n    // sizes.\n    Value *from;\n    Value *to;\n#if JL_LLVM_VERSION >= 40000\n    const DataLayout &DL = jl_data_layout;\n#else\n    const DataLayout &DL = jl_ExecutionEngine->getDataLayout();\n#endif\n    if (DL.getTypeAllocSize(target_type) >= DL.getTypeAllocSize(from_type)) {\n        to = emit_static_alloca(ctx, target_type);\n        from = emit_bitcast(ctx, to, from_type->getPointerTo());\n    }\n    else {\n        from = emit_static_alloca(ctx, from_type);\n        to = emit_bitcast(ctx, from, target_type->getPointerTo());\n    }\n    ctx.builder.CreateStore(v, from);\n    return ctx.builder.CreateLoad(to);\n}\n\n// --- argument passing and scratch space utilities ---\n\nstatic Value *runtime_apply_type_env(jl_codectx_t &ctx, jl_value_t *ty)\n{\n    // box if concrete type was not statically known\n    Value *args[] = {\n        literal_pointer_val(ctx, ty),\n        literal_pointer_val(ctx, (jl_value_t*)ctx.linfo->def.method->sig),\n        ctx.builder.CreateInBoundsGEP(\n                T_prjlvalue,\n                ctx.spvals_ptr,\n                ConstantInt::get(T_size, sizeof(jl_svec_t) / sizeof(jl_value_t*)))\n    };\n    return ctx.builder.CreateCall(prepare_call(jlapplytype_func), makeArrayRef(args));\n}\n\nstatic const std::string make_errmsg(const char *fname, int n, const char *err)\n{\n    std::stringstream msg;\n    msg << fname;\n    if (n > 0)\n        msg << \" argument \" << n;\n    else\n        msg << \" return\";\n    msg << err;\n    return msg.str();\n}\n\nstatic void typeassert_input(jl_codectx_t &ctx, const jl_cgval_t &jvinfo, jl_value_t *jlto, jl_unionall_t *jlto_env, int argn, bool addressOf)\n{\n    if (jlto != (jl_value_t*)jl_any_type && !jl_subtype(jvinfo.typ, jlto)) {\n        if (!addressOf && jlto == (jl_value_t*)jl_voidpointer_type) {\n            // allow a bit more flexibility for what can be passed to (void*) due to Ref{T} conversion behavior in input\n            if (!jl_is_cpointer_type(jvinfo.typ)) {\n                // emit a typecheck, if not statically known to be correct\n                emit_cpointercheck(ctx, jvinfo, make_errmsg(\"ccall\", argn + 1, \"\"));\n            }\n        }\n        else {\n            // emit a typecheck, if not statically known to be correct\n            std::string msg = make_errmsg(\"ccall\", argn + 1, \"\");\n            if (!jlto_env || !jl_has_typevar_from_unionall(jlto, jlto_env)) {\n                emit_typecheck(ctx, jvinfo, jlto, msg);\n            }\n            else {\n                jl_cgval_t jlto_runtime = mark_julia_type(ctx, runtime_apply_type_env(ctx, jlto), true, jl_any_type);\n                Value *vx = boxed(ctx, jvinfo);\n                Value *istype = ctx.builder.CreateICmpNE(\n                        ctx.builder.CreateCall(prepare_call(jlisa_func), { vx, boxed(ctx, jlto_runtime) }),\n                        ConstantInt::get(T_int32, 0));\n                BasicBlock *failBB = BasicBlock::Create(jl_LLVMContext, \"fail\", ctx.f);\n                BasicBlock *passBB = BasicBlock::Create(jl_LLVMContext, \"pass\", ctx.f);\n                ctx.builder.CreateCondBr(istype, passBB, failBB);\n\n                ctx.builder.SetInsertPoint(failBB);\n                emit_type_error(ctx, mark_julia_type(ctx, vx, true, jl_any_type), boxed(ctx, jlto_runtime), msg);\n                ctx.builder.CreateUnreachable();\n                ctx.builder.SetInsertPoint(passBB);\n            }\n        }\n    }\n}\n\nstatic Value *julia_to_address(\n        jl_codectx_t &ctx,\n        Type *to, jl_value_t *jlto, jl_unionall_t *jlto_env,\n        const jl_cgval_t &jvinfo,\n        int argn, bool *needStackRestore)\n{\n    assert(jl_is_datatype(jlto) && julia_struct_has_layout((jl_datatype_t*)jlto, jlto_env));\n\n    if (!jl_is_cpointer_type(jlto) || to != T_size) {\n        emit_error(ctx, \"ccall: & on argument was not matched by Ptr{T} argument type\");\n        return UndefValue::get(to);\n    }\n\n    jl_value_t *ety;\n    if (jlto == (jl_value_t*)jl_voidpointer_type) {\n        ety = jvinfo.typ; // skip the type-check\n    }\n    else {\n        ety = jl_tparam0(jlto);\n        typeassert_input(ctx, jvinfo, ety, jlto_env, argn, true);\n    }\n\n    if (jvinfo.isboxed) {\n        if (!jl_is_abstracttype(ety)) {\n            if (jl_is_mutable_datatype(ety)) {\n                // no copy, just reference the data field\n                return ctx.builder.CreateBitCast(emit_pointer_from_objref(ctx, data_pointer(ctx, jvinfo)), to);\n            }\n            else if (jl_is_immutable_datatype(ety) && jlto != (jl_value_t*)jl_voidpointer_type) { // anything declared `struct`, except Ptr{Cvoid}\n                // yes copy\n                Value *nbytes;\n                AllocaInst *ai;\n                if (((jl_datatype_t*)ety)->layout) {\n                    int nb = jl_datatype_size(ety);\n                    nbytes = ConstantInt::get(T_int32, nb);\n                    ai = emit_static_alloca(ctx, T_int8, nb);\n                }\n                else {\n                    nbytes = emit_datatype_size(ctx, emit_typeof_boxed(ctx, jvinfo));\n                    ai = ctx.builder.CreateAlloca(T_int8, nbytes);\n                    *needStackRestore = true;\n                }\n                ai->setAlignment(16);\n                // minimum gc-alignment in julia is pointer size\n                emit_memcpy(ctx, ai, jvinfo.tbaa, jvinfo, nbytes, sizeof(void*));\n                return ctx.builder.CreatePtrToInt(ai, to);\n            }\n        }\n        // emit maybe copy\n        *needStackRestore = true;\n        Value *jvt = emit_typeof_boxed(ctx, jvinfo);\n        BasicBlock *mutableBB = BasicBlock::Create(jl_LLVMContext, \"is-mutable\", ctx.f);\n        BasicBlock *immutableBB = BasicBlock::Create(jl_LLVMContext, \"is-immutable\", ctx.f);\n        BasicBlock *afterBB = BasicBlock::Create(jl_LLVMContext, \"after\", ctx.f);\n        Value *ismutable = emit_datatype_mutabl(ctx, jvt);\n        ctx.builder.CreateCondBr(ismutable, mutableBB, immutableBB);\n        ctx.builder.SetInsertPoint(mutableBB);\n        Value *p1 = ctx.builder.CreateBitCast(emit_pointer_from_objref(ctx, data_pointer(ctx, jvinfo)), to);\n        ctx.builder.CreateBr(afterBB);\n        ctx.builder.SetInsertPoint(immutableBB);\n        Value *nbytes = emit_datatype_size(ctx, jvt);\n        AllocaInst *ai = ctx.builder.CreateAlloca(T_int8, nbytes);\n        ai->setAlignment(16);\n        emit_memcpy(ctx, ai, jvinfo.tbaa, jvinfo, nbytes, sizeof(void*)); // minimum gc-alignment in julia is pointer size\n        Value *p2 = ctx.builder.CreatePtrToInt(ai, to);\n        ctx.builder.CreateBr(afterBB);\n        ctx.builder.SetInsertPoint(afterBB);\n        PHINode *p = ctx.builder.CreatePHI(to, 2);\n        p->addIncoming(p1, mutableBB);\n        p->addIncoming(p2, immutableBB);\n        return p;\n    }\n\n    Type *slottype = julia_struct_to_llvm(jvinfo.typ, NULL, NULL);\n    // pass the address of an alloca'd thing, not a box\n    // since those are immutable.\n    Value *slot = emit_static_alloca(ctx, slottype);\n    if (!jvinfo.ispointer()) {\n        tbaa_decorate(jvinfo.tbaa, ctx.builder.CreateStore(emit_unbox(ctx, slottype, jvinfo, ety), slot));\n    }\n    else {\n        emit_memcpy(ctx, slot, jvinfo.tbaa, jvinfo, jl_datatype_size(ety), jl_datatype_align(ety));\n    }\n    return ctx.builder.CreatePtrToInt(slot, to);\n}\n\n\n// Emit code to convert argument to form expected by C ABI\n// to = desired LLVM type\n// jlto = Julia type of formal argument\n// jvinfo = value of actual argument\nstatic Value *julia_to_native(\n        jl_codectx_t &ctx,\n        Type *to, bool toboxed, jl_value_t *jlto, jl_unionall_t *jlto_env,\n        const jl_cgval_t &jvinfo,\n        bool byRef, int argn,\n        bool *needStackRestore)\n{\n    // We're passing Any\n    if (toboxed) {\n        assert(!byRef); // don't expect any ABI to pass pointers by pointer\n        return maybe_decay_untracked(boxed(ctx, jvinfo));\n    }\n    assert(jl_is_datatype(jlto) && julia_struct_has_layout((jl_datatype_t*)jlto, jlto_env));\n\n    typeassert_input(ctx, jvinfo, jlto, jlto_env, argn, false);\n    if (!byRef)\n        return emit_unbox(ctx, to, jvinfo, jlto);\n\n    // pass the address of an alloca'd thing, not a box\n    // since those are immutable.\n    Value *slot = emit_static_alloca(ctx, to);\n    if (!jvinfo.ispointer()) {\n        tbaa_decorate(jvinfo.tbaa, ctx.builder.CreateStore(emit_unbox(ctx, to, jvinfo, jlto), slot));\n    }\n    else {\n        emit_memcpy(ctx, slot, jvinfo.tbaa, jvinfo, jl_datatype_size(jlto), jl_datatype_align(jlto));\n    }\n    return slot;\n}\n\ntypedef struct {\n    Value *jl_ptr;  // if the argument is a run-time computed pointer\n    void (*fptr)(void);     // if the argument is a constant pointer\n    const char *f_name;   // if the symbol name is known\n    const char *f_lib;    // if a library name is specified\n    jl_value_t *gcroot;\n} native_sym_arg_t;\n\n// --- parse :sym or (:sym, :lib) argument into address info ---\nstatic void interpret_symbol_arg(jl_codectx_t &ctx, native_sym_arg_t &out, jl_value_t *arg, const char *fname, bool llvmcall)\n{\n    Value *&jl_ptr = out.jl_ptr;\n    void (*&fptr)(void) = out.fptr;\n    const char *&f_name = out.f_name;\n    const char *&f_lib = out.f_lib;\n\n    jl_value_t *ptr = static_eval(ctx, arg, true);\n    if (ptr == NULL) {\n        jl_cgval_t arg1 = emit_expr(ctx, arg);\n        jl_value_t *ptr_ty = arg1.typ;\n        if (!jl_is_cpointer_type(ptr_ty)) {\n           const char *errmsg = !strcmp(fname, \"ccall\") ?\n               \"ccall: first argument not a pointer or valid constant expression\" :\n               \"cglobal: first argument not a pointer or valid constant expression\";\n            emit_cpointercheck(ctx, arg1, errmsg);\n        }\n        arg1 = update_julia_type(ctx, arg1, (jl_value_t*)jl_voidpointer_type);\n        jl_ptr = emit_unbox(ctx, T_size, arg1, (jl_value_t*)jl_voidpointer_type);\n    }\n    else {\n        out.gcroot = ptr;\n        if (jl_is_tuple(ptr) && jl_nfields(ptr) == 1) {\n            ptr = jl_fieldref(ptr, 0);\n        }\n\n        if (jl_is_symbol(ptr))\n            f_name = jl_symbol_name((jl_sym_t*)ptr);\n        else if (jl_is_string(ptr))\n            f_name = jl_string_data(ptr);\n\n        if (f_name != NULL) {\n            // just symbol, default to JuliaDLHandle\n            // will look in process symbol table\n#ifdef _OS_WINDOWS_\n            if (!llvmcall)\n                f_lib = jl_dlfind_win32(f_name);\n#endif\n        }\n        else if (jl_is_cpointer_type(jl_typeof(ptr))) {\n            fptr = *(void(**)(void))jl_data_ptr(ptr);\n        }\n        else if (jl_is_tuple(ptr) && jl_nfields(ptr) > 1) {\n            jl_value_t *t0 = jl_fieldref(ptr, 0);\n            if (jl_is_symbol(t0))\n                f_name = jl_symbol_name((jl_sym_t*)t0);\n            else if (jl_is_string(t0))\n                f_name = jl_string_data(t0);\n            else\n                JL_TYPECHKS(fname, symbol, t0);\n\n            jl_value_t *t1 = jl_fieldref(ptr, 1);\n            if (jl_is_symbol(t1))\n                f_lib = jl_symbol_name((jl_sym_t*)t1);\n            else if (jl_is_string(t1))\n                f_lib = jl_string_data(t1);\n            else\n                JL_TYPECHKS(fname, symbol, t1);\n        }\n        else {\n            JL_TYPECHKS(fname, pointer, ptr);\n        }\n    }\n}\n\n\nstatic jl_value_t* try_eval(jl_codectx_t &ctx, jl_value_t *ex, const char *failure)\n{\n    jl_value_t *constant = static_eval(ctx, ex, true, true);\n    if (jl_is_ssavalue(ex) && !constant)\n        jl_error(failure);\n    else if (constant)\n        return constant;\n\n    JL_TRY {\n        size_t last_age = jl_get_ptls_states()->world_age;\n        jl_get_ptls_states()->world_age = ctx.world;\n        constant = jl_interpret_toplevel_expr_in(ctx.module, ex, ctx.source, ctx.linfo->sparam_vals);\n        jl_get_ptls_states()->world_age = last_age;\n    }\n    JL_CATCH {\n        jl_rethrow_with_add(failure);\n    }\n\n    return constant;\n}\n\n// --- code generator for cglobal ---\n\nstatic jl_cgval_t emit_runtime_call(jl_codectx_t &ctx, JL_I::intrinsic f, const jl_cgval_t *argv, size_t nargs);\n\nstatic jl_cgval_t emit_cglobal(jl_codectx_t &ctx, jl_value_t **args, size_t nargs)\n{\n    JL_NARGS(cglobal, 1, 2);\n    jl_value_t *rt = NULL;\n    Value *res;\n    native_sym_arg_t sym = {};\n    JL_GC_PUSH2(&rt, &sym.gcroot);\n\n    if (nargs == 2) {\n        rt = static_eval(ctx, args[2], true, true);\n        if (rt == NULL) {\n            JL_GC_POP();\n            jl_cgval_t argv[2];\n            argv[0] = emit_expr(ctx, args[1]);\n            argv[1] = emit_expr(ctx, args[2]);\n            return emit_runtime_call(ctx, JL_I::cglobal, argv, nargs);\n        }\n\n        JL_TYPECHK(cglobal, type, rt);\n        rt = (jl_value_t*)jl_apply_type1((jl_value_t*)jl_pointer_type, rt);\n    }\n    else {\n        rt = (jl_value_t*)jl_voidpointer_type;\n    }\n    Type *lrt = julia_type_to_llvm(rt);\n\n    interpret_symbol_arg(ctx, sym, args[1], \"cglobal\", false);\n\n    if (sym.jl_ptr != NULL) {\n        res = ctx.builder.CreateBitCast(sym.jl_ptr, lrt);\n    }\n    else if (sym.fptr != NULL) {\n        res = ConstantInt::get(lrt, (uint64_t)sym.fptr);\n        if (imaging_mode)\n            jl_printf(JL_STDERR,\"WARNING: literal address used in cglobal for %s; code cannot be statically compiled\\n\", sym.f_name);\n    }\n    else {\n        if (imaging_mode) {\n            res = runtime_sym_lookup(ctx, cast<PointerType>(T_pint8), sym.f_lib, sym.f_name, ctx.f);\n            res = ctx.builder.CreatePtrToInt(res, lrt);\n        }\n        else {\n            void *symaddr = jl_dlsym_e(jl_get_library(sym.f_lib), sym.f_name);\n            if (symaddr == NULL) {\n                std::stringstream msg;\n                msg << \"cglobal: could not find symbol \";\n                msg << sym.f_name;\n                if (sym.f_lib != NULL) {\n#ifdef _OS_WINDOWS_\n                    assert(sym.f_lib != JL_EXE_LIBNAME && sym.f_lib != JL_DL_LIBNAME);\n#endif\n                    msg << \" in library \";\n                    msg << sym.f_lib;\n                }\n                emit_error(ctx, msg.str());\n            }\n            // since we aren't saving this code, there's no sense in\n            // putting anything complicated here: just JIT the address of the cglobal\n            res = ConstantInt::get(lrt, (uint64_t)symaddr);\n        }\n    }\n\n    JL_GC_POP();\n    return mark_julia_type(ctx, res, false, rt);\n}\n\nclass FunctionMover final : public ValueMaterializer\n{\npublic:\n    FunctionMover(llvm::Module *dest,llvm::Module *src) :\n        ValueMaterializer(), VMap(), destModule(dest), srcModule(src),\n        LazyFunctions(0)\n    {\n    }\n    ValueToValueMapTy VMap;\n    llvm::Module *destModule;\n    llvm::Module *srcModule;\n    std::vector<Function *> LazyFunctions;\n\n    Function *CloneFunctionProto(Function *F)\n    {\n        assert(!F->isDeclaration());\n        Function *NewF = Function::Create(F->getFunctionType(),\n                                          Function::ExternalLinkage,\n                                          F->getName(),\n                                          destModule);\n        LazyFunctions.push_back(F);\n        VMap[F] = NewF;\n        return NewF;\n    }\n\n    void CloneFunctionBody(Function *F)\n    {\n        Function *NewF = (Function*)(Value*)VMap[F];\n        assert(NewF != NULL);\n\n        Function::arg_iterator DestI = NewF->arg_begin();\n        for (Function::const_arg_iterator I = F->arg_begin(), E = F->arg_end(); I != E; ++I) {\n            DestI->setName(I->getName());    // Copy the name over...\n            VMap[&*I] = &*(DestI++);        // Add mapping to VMap\n        }\n\n        SmallVector<ReturnInst*, 8> Returns;\n        llvm::CloneFunctionInto(NewF,F,VMap,true,Returns,\"\",NULL,NULL,this);\n        NewF->setComdat(nullptr);\n        NewF->setSection(\"\");\n    }\n\n    Function *CloneFunction(Function *F)\n    {\n        Function *NewF = (llvm::Function*)MapValue(F,VMap,RF_None,NULL,this);\n        ResolveLazyFunctions();\n        return NewF;\n    }\n\n    void ResolveLazyFunctions()\n    {\n        while (!LazyFunctions.empty()) {\n            Function *F = LazyFunctions.back();\n            LazyFunctions.pop_back();\n\n            CloneFunctionBody(F);\n        }\n    }\n\n    Value *InjectFunctionProto(Function *F)\n    {\n        Function *NewF = destModule->getFunction(F->getName());\n        if (!NewF) {\n            NewF = function_proto(F);\n            NewF->setComdat(nullptr);\n            destModule->getFunctionList().push_back(NewF);\n        }\n        return NewF;\n    }\n\n    Value *materialize(Value *V) override\n    {\n        Function *F = dyn_cast<Function>(V);\n        if (F) {\n            if (isIntrinsicFunction(F)) {\n                return destModule->getOrInsertFunction(F->getName(),F->getFunctionType());\n            }\n            if (F->isDeclaration() || F->getParent() != destModule) {\n                if (F->getName().empty())\n                    return CloneFunctionProto(F);\n                Function *shadow = srcModule->getFunction(F->getName());\n                if (shadow != NULL && !shadow->isDeclaration()) {\n                    Function *oldF = destModule->getFunction(F->getName());\n                    if (oldF)\n                        return oldF;\n                    if (jl_ExecutionEngine->findSymbol(F->getName(), false))\n                        return InjectFunctionProto(F);\n                    return CloneFunctionProto(shadow);\n                }\n                else if (!F->isDeclaration()) {\n                    return CloneFunctionProto(F);\n                }\n            }\n            // Still a declaration and still in a different module\n            if (F->isDeclaration() && F->getParent() != destModule) {\n                // Create forward declaration in current module\n                return InjectFunctionProto(F);\n            }\n        }\n        else if (isa<GlobalVariable>(V)) {\n            GlobalVariable *GV = cast<GlobalVariable>(V);\n            assert(GV != NULL);\n            GlobalVariable *oldGV = destModule->getGlobalVariable(GV->getName());\n            if (oldGV != NULL)\n                return oldGV;\n            GlobalVariable *newGV = new GlobalVariable(*destModule,\n                GV->getType()->getElementType(),\n                GV->isConstant(),\n                GlobalVariable::ExternalLinkage,\n                NULL,\n                GV->getName(),\n                NULL,\n                GV->getThreadLocalMode(),\n                GV->getType()->getPointerAddressSpace());\n            newGV->copyAttributesFrom(GV);\n            newGV->setComdat(nullptr);\n            if (GV->isDeclaration())\n                return newGV;\n            if (!GV->getName().empty()) {\n                uint64_t addr = jl_ExecutionEngine->getGlobalValueAddress(GV->getName());\n                if (addr != 0) {\n                    newGV->setExternallyInitialized(true);\n                    return newGV;\n                }\n            }\n            if (GV->hasInitializer()) {\n                Value *C = MapValue(GV->getInitializer(),VMap,RF_None,NULL,this);\n                newGV->setInitializer(cast<Constant>(C));\n            }\n            return newGV;\n        }\n        return NULL;\n    };\n};\n\n// llvmcall(ir, (rettypes...), (argtypes...), args...)\nstatic jl_cgval_t emit_llvmcall(jl_codectx_t &ctx, jl_value_t **args, size_t nargs)\n{\n    JL_NARGSV(llvmcall, 3);\n    jl_value_t *rt = NULL, *at = NULL, *ir = NULL, *decl = NULL;\n    jl_value_t *ir_arg = args[1];\n    JL_GC_PUSH4(&ir, &rt, &at, &decl);\n    if (jl_is_ssavalue(ir_arg))\n        ir_arg = jl_arrayref((jl_array_t*)ctx.source->code, ((jl_ssavalue_t*)ir_arg)->id - 1);\n    ir = try_eval(ctx, ir_arg, \"error statically evaluating llvm IR argument\");\n    if (jl_is_ssavalue(args[2])) {\n        jl_value_t *rtt = jl_arrayref((jl_array_t*)ctx.source->ssavaluetypes, ((jl_ssavalue_t*)args[2])->id - 1);\n        if (jl_is_type_type(rtt))\n            rt = jl_tparam0(rtt);\n    }\n    if (rt == NULL)\n        rt = try_eval(ctx, args[2], \"error statically evaluating llvmcall return type\");\n    if (jl_is_ssavalue(args[3])) {\n        jl_value_t *att = jl_arrayref((jl_array_t*)ctx.source->ssavaluetypes, ((jl_ssavalue_t*)args[3])->id - 1);\n        if (jl_is_type_type(att))\n            at = jl_tparam0(att);\n    }\n    if (at == NULL)\n        at = try_eval(ctx, args[3], \"error statically evaluating llvmcall argument tuple\");\n    int i = 1;\n    if (jl_is_tuple(ir)) {\n        // if the IR is a tuple, we expect (declarations, ir)\n        if (jl_nfields(ir) != 2)\n            jl_error(\"Tuple as first argument to llvmcall must have exactly two children\");\n        decl = jl_fieldref(ir,0);\n        ir = jl_fieldref(ir,1);\n        if (!jl_is_string(decl))\n            jl_error(\"Declarations passed to llvmcall must be a string\");\n    }\n    bool isString = jl_is_string(ir);\n    bool isPtr = jl_is_cpointer(ir);\n    if (!isString && !isPtr) {\n        jl_error(\"IR passed to llvmcall must be a string or pointer to an LLVM Function\");\n    }\n\n    JL_TYPECHK(llvmcall, type, rt);\n    JL_TYPECHK(llvmcall, type, at);\n\n    std::stringstream ir_stream;\n\n    // Generate arguments\n    std::string arguments;\n    llvm::raw_string_ostream argstream(arguments);\n    jl_svec_t *tt = ((jl_datatype_t*)at)->parameters;\n    jl_value_t *rtt = rt;\n    size_t nargt = jl_svec_len(tt);\n\n    /*\n     * Semantics for arguments are as follows:\n     * If the argument type is immutable (including bitstype), we pass the loaded llvm value\n     * type. Otherwise we pass a pointer to a jl_value_t.\n     */\n    std::vector<llvm::Type*> argtypes;\n    Value **argvals = (Value**)alloca(nargt * sizeof(Value*));\n    for (size_t i = 0; i < nargt; ++i) {\n        jl_value_t *tti = jl_svecref(tt,i);\n        bool toboxed;\n        Type *t = julia_type_to_llvm(tti, &toboxed);\n        argtypes.push_back(t);\n        if (4 + i > nargs) {\n            jl_error(\"Missing arguments to llvmcall!\");\n        }\n        jl_value_t *argi = args[4 + i];\n        jl_cgval_t arg = emit_expr(ctx, argi);\n\n        Value *v = julia_to_native(ctx, t, toboxed, tti, NULL, arg, false, i, NULL);\n        bool issigned = jl_signed_type && jl_subtype(tti, (jl_value_t*)jl_signed_type);\n        argvals[i] = llvm_type_rewrite(ctx, v, t, issigned);\n    }\n\n    Function *f;\n    bool retboxed;\n    Type *rettype = julia_type_to_llvm(rtt, &retboxed);\n    if (isString) {\n        // Make sure to find a unique name\n        std::string ir_name;\n        while(true) {\n            std::stringstream name;\n            name << (ctx.f->getName().str()) << \"u\" << i++;\n            ir_name = name.str();\n            if (jl_Module->getFunction(ir_name) == NULL)\n                break;\n        }\n\n        bool first = true;\n        for (std::vector<Type *>::iterator it = argtypes.begin(); it != argtypes.end(); ++it) {\n            if (!first)\n                argstream << \",\";\n            else\n                first = false;\n            (*it)->print(argstream);\n            argstream << \" \";\n        }\n\n        std::string rstring;\n        llvm::raw_string_ostream rtypename(rstring);\n        rettype->print(rtypename);\n        std::map<uint64_t,std::string> localDecls;\n\n        if (decl != NULL) {\n            std::stringstream declarations(jl_string_data(decl));\n\n            // parse string line by line\n            std::string declstr;\n            while (std::getline(declarations, declstr, '\\n')) {\n                // Find name of declaration by searching for '@'\n                std::string::size_type atpos = declstr.find('@') + 1;\n                // Find end of declaration by searching for '('\n                std::string::size_type bracepos = declstr.find('(', atpos);\n                // Declaration name is the string between @ and (\n                std::string declname = declstr.substr(atpos, bracepos - atpos);\n\n                // Check if declaration already present in module\n                if(jl_Module->getNamedValue(declname) == NULL) {\n                    ir_stream << \"; Declarations\\n\" << declstr << \"\\n\";\n                }\n            }\n        }\n        ir_stream << \"; Number of arguments: \" << nargt << \"\\n\"\n        << \"define \"<<rtypename.str()<<\" @\\\"\" << ir_name << \"\\\"(\"<<argstream.str()<<\") {\\n\"\n        << jl_string_data(ir) << \"\\n}\";\n        SMDiagnostic Err = SMDiagnostic();\n        std::string ir_string = ir_stream.str();\n#if JL_LLVM_VERSION >= 60000\n        // Do not enable update debug info since it runs the verifier on the whole module\n        // and will error on the function we are currently emitting.\n        bool failed = parseAssemblyInto(llvm::MemoryBufferRef(ir_string, \"llvmcall\"),\n                                        *jl_Module, Err, nullptr, /* UpdateDebugInfo */ false);\n#else\n        bool failed = parseAssemblyInto(llvm::MemoryBufferRef(ir_string, \"llvmcall\"),\n                                        *jl_Module, Err);\n#endif\n        if (failed) {\n            std::string message = \"Failed to parse LLVM Assembly: \\n\";\n            llvm::raw_string_ostream stream(message);\n            Err.print(\"julia\",stream,true);\n            jl_error(stream.str().c_str());\n        }\n        f = jl_Module->getFunction(ir_name);\n    }\n    else {\n        assert(isPtr);\n        // Create Function skeleton\n        f = (llvm::Function*)jl_unbox_voidpointer(ir);\n        assert(!f->isDeclaration());\n        assert(f->getReturnType() == rettype);\n        int i = 0;\n        for (std::vector<Type *>::iterator it = argtypes.begin();\n            it != argtypes.end(); ++it, ++i)\n            assert(*it == f->getFunctionType()->getParamType(i));\n\n        if (f->getParent() != jl_Module) {\n            FunctionMover mover(jl_Module, f->getParent());\n            f = mover.CloneFunction(f);\n        }\n\n        //f->dump();\n        llvm::raw_fd_ostream out(1,false);\n        if (verifyFunction(*f,&out)) {\n            llvm_dump(f);\n            jl_error(\"Malformed LLVM Function\");\n        }\n    }\n\n    // Since we dumped all of f's dependencies into the active module,\n    // we cannot reasonably inline it, so leave it there and just emit\n    // a regular call\n    if (!isString) {\n        static int llvmcallnumbering = 0;\n        std::stringstream name;\n        name << \"jl_llvmcall\" << llvmcallnumbering++;\n        f->setName(name.str());\n        jl_init_function(f);\n        f = cast<Function>(prepare_call(function_proto(f)));\n    }\n    else {\n        jl_init_function(f);\n        f->setLinkage(GlobalValue::LinkOnceODRLinkage);\n    }\n\n    CallInst *inst = ctx.builder.CreateCall(f, ArrayRef<Value*>(&argvals[0], nargt));\n    if (isString) {\n        f->addFnAttr(Attribute::AlwaysInline);\n        inst->setAttributes(f->getAttributes());\n    }\n\n    JL_GC_POP();\n\n    if (inst->getType() != rettype) {\n        jl_error(\"Return type of llvmcall'ed function does not match declared return type\");\n    }\n\n    return mark_julia_type(ctx, inst, retboxed, rtt);\n}\n\n// --- code generator for ccall itself ---\n\nstatic Value *box_ccall_result(jl_codectx_t &ctx, Value *result, Value *runtime_dt, jl_value_t *rt)\n{\n    // XXX: need to handle parameterized zero-byte types (singleton)\n#if JL_LLVM_VERSION >= 40000\n    const DataLayout &DL = jl_data_layout;\n#else\n    const DataLayout &DL = jl_ExecutionEngine->getDataLayout();\n#endif\n    unsigned nb = DL.getTypeStoreSize(result->getType());\n    MDNode *tbaa = jl_is_mutable(rt) ? tbaa_mutab : tbaa_immut;\n    Value *strct = emit_allocobj(ctx, nb, runtime_dt);\n    init_bits_value(ctx, strct, result, tbaa);\n    return strct;\n}\n\nstatic jl_cgval_t mark_or_box_ccall_result(jl_codectx_t &ctx, Value *result, bool isboxed, jl_value_t *rt, jl_unionall_t *unionall, bool static_rt)\n{\n    if (!static_rt) {\n        assert(!isboxed && jl_is_datatype(rt) && ctx.spvals_ptr && unionall);\n        Value *runtime_dt = runtime_apply_type_env(ctx, rt);\n        // TODO: skip this check if rt is not a Tuple\n        emit_concretecheck(ctx, runtime_dt, \"ccall: return type must be a concrete DataType\");\n        Value *strct = box_ccall_result(ctx, result, runtime_dt, rt);\n        return mark_julia_type(ctx, strct, true, rt); // TODO: jl_rewrap_unionall(rt, unionall)\n    }\n    return mark_julia_type(ctx, result, isboxed, rt);\n}\n\nclass function_sig_t {\npublic:\n    std::vector<Type*> fargt; // vector of llvm output types (julia_struct_to_llvm) for arguments (vararg is the last item, if applicable)\n    std::vector<Type*> fargt_sig; // vector of ABI coercion types for call signature\n    std::vector<bool> fargt_isboxed; // vector of whether the llvm output type is a Julia-box for each argument (vararg is the last item, if applicable)\n    Type *fargt_vasig = NULL; // ABI coercion type for vararg list\n    std::vector<bool> byRefList; // vector of \"byref\" parameters (vararg is the last item, if applicable)\n#if JL_LLVM_VERSION >= 50000\n    AttributeList attributes; // vector of function call site attributes (vararg is the last item, if applicable)\n#else\n    AttributeSet attributes; // vector of function call site attributes (vararg is the last item, if applicable)\n#endif\n    Type *lrt; // input parameter of the llvm return type (from julia_struct_to_llvm)\n    bool retboxed; // input parameter indicating whether lrt is jl_value_t*\n    Type *prt; // out parameter of the llvm return type for the function signature\n    int sret; // out parameter for indicating whether return value has been moved to the first argument position\n    std::string err_msg;\n    CallingConv::ID cc; // calling convention ABI\n    bool llvmcall;\n    jl_svec_t *at; // svec of julia argument types\n    jl_value_t *rt; // julia return type\n    jl_unionall_t *unionall_env; // UnionAll environment for `at` and `rt`\n    size_t nargs; // number of actual arguments (can be different from the size of at when varargs)\n    size_t isVa;\n\n    function_sig_t(const char *fname, Type *lrt, jl_value_t *rt, bool retboxed, jl_svec_t *at, jl_unionall_t *unionall_env, size_t nargs, size_t isVa, CallingConv::ID cc, bool llvmcall)\n      : fargt_vasig(NULL), lrt(lrt), retboxed(retboxed),\n        prt(NULL), sret(0), cc(cc), llvmcall(llvmcall),\n        at(at), rt(rt), unionall_env(unionall_env),\n        nargs(nargs), isVa(isVa)\n    {\n        err_msg = generate_func_sig(fname);\n    }\n\n    FunctionType *functype() const {\n        assert(err_msg.empty());\n        return FunctionType::get(sret ? T_void : prt, fargt_sig, isVa);\n    }\n\n    jl_cgval_t emit_a_ccall(\n            jl_codectx_t &ctx,\n            const native_sym_arg_t &symarg,\n            size_t nargt,\n            std::vector<bool> &addressOf,\n            jl_cgval_t *argv,\n            SmallVector<Value*, 16> &gc_uses,\n            bool static_rt) const;\n\nprivate:\nstd::string generate_func_sig(const char *fname)\n{\n    size_t nargt = jl_svec_len(at);\n    assert(rt && !jl_is_abstract_ref_type(rt));\n\n#if JL_LLVM_VERSION >= 50000\n    std::vector<AttrBuilder> paramattrs;\n#else\n    std::vector<AttributeSet> paramattrs;\n#endif\n    std::unique_ptr<AbiLayout> abi;\n    if (llvmcall)\n        abi.reset(new ABI_LLVMLayout());\n    else\n        abi.reset(new DefaultAbiState());\n    sret = 0;\n\n    if (type_is_ghost(lrt)) {\n        prt = lrt = T_void;\n        abi->use_sret(jl_void_type);\n    }\n    else {\n        if (!jl_is_datatype(rt) || ((jl_datatype_t*)rt)->layout == NULL || jl_is_cpointer_type(rt) || jl_is_array_type(rt) || retboxed) {\n            prt = lrt; // passed as pointer\n            abi->use_sret(jl_voidpointer_type);\n        }\n        else if (abi->use_sret((jl_datatype_t*)rt)) {\n            AttrBuilder retattrs = AttrBuilder();\n#if !defined(_OS_WINDOWS_) // llvm used to use the old mingw ABI, skipping this marking works around that difference\n            retattrs.addAttribute(Attribute::StructRet);\n#endif\n            retattrs.addAttribute(Attribute::NoAlias);\n#if JL_LLVM_VERSION >= 50000\n            paramattrs.push_back(std::move(retattrs));\n#else\n            paramattrs.push_back(AttributeSet::get(jl_LLVMContext, 1, retattrs));\n#endif\n            fargt_sig.push_back(PointerType::get(lrt, 0));\n            sret = 1;\n            prt = lrt;\n        }\n        else {\n            prt = abi->preferred_llvm_type((jl_datatype_t*)rt, true);\n            if (prt == NULL)\n                prt = lrt;\n        }\n    }\n\n    size_t i;\n    bool current_isVa = false;\n    for (i = 0; i < nargt; ) {\n        AttrBuilder ab;\n        jl_value_t *tti = jl_svecref(at, i);\n        if (jl_is_vararg_type(tti)) {\n            current_isVa = true;\n            tti = jl_unwrap_vararg(tti);\n        }\n        Type *t = NULL;\n        bool isboxed;\n        if (jl_is_abstract_ref_type(tti)) {\n            tti = (jl_value_t*)jl_voidpointer_type;\n            t = T_pint8;\n            isboxed = false;\n        }\n        else {\n            if (jl_is_primitivetype(tti)) {\n                // see pull req #978. need to annotate signext/zeroext for\n                // small integer arguments.\n                jl_datatype_t *bt = (jl_datatype_t*)tti;\n                if (jl_datatype_size(bt) < 4) {\n                    if (jl_signed_type && jl_subtype(tti, (jl_value_t*)jl_signed_type))\n                        ab.addAttribute(Attribute::SExt);\n                    else\n                        ab.addAttribute(Attribute::ZExt);\n                }\n            }\n\n            t = julia_struct_to_llvm(tti, unionall_env, &isboxed);\n            if (isboxed)\n                t = T_prjlvalue;\n            if (t == NULL || t == T_void) {\n                return make_errmsg(fname, i + 1, \" doesn't correspond to a C type\");\n            }\n        }\n\n        Type *pat;\n        if (!jl_is_datatype(tti) || ((jl_datatype_t*)tti)->layout == NULL || jl_is_array_type(tti))\n            tti = (jl_value_t*)jl_voidpointer_type; // passed as pointer\n\n        // Whether or not LLVM wants us to emit a pointer to the data\n        bool byRef = abi->needPassByRef((jl_datatype_t*)tti, ab);\n\n        if (jl_is_cpointer_type(tti)) {\n            pat = t;\n        }\n        else if (byRef) {\n            pat = PointerType::get(t, AddressSpace::Derived);\n        }\n        else {\n            pat = abi->preferred_llvm_type((jl_datatype_t*)tti, false);\n            if (pat == NULL)\n                pat = t;\n        }\n\n        byRefList.push_back(byRef);\n        fargt.push_back(t);\n        fargt_isboxed.push_back(isboxed);\n        if (!current_isVa)\n            fargt_sig.push_back(pat);\n        else\n            fargt_vasig = pat;\n\n        do { // for each arg for which this type applies, add the appropriate LLVM parameter attributes\n            if (i < nargs) { // if vararg, the last declared arg type may not have a corresponding arg value\n#if JL_LLVM_VERSION >= 50000\n                AttributeSet params = AttributeSet::get(jl_LLVMContext, ab);\n#else\n                AttributeSet params = AttributeSet::get(jl_LLVMContext, i + sret + 1, ab);\n#endif\n                paramattrs.push_back(params);\n            }\n            i++;\n        } while (current_isVa && i < nargs); // if is this is the vararg, loop to the end\n    }\n\n    for (i = 0; i < nargs + sret; ++i) {\n        const auto &as = paramattrs.at(i);\n#if JL_LLVM_VERSION >= 50000\n        if (!as.hasAttributes())\n            continue;\n#else\n        if (as.isEmpty())\n            continue;\n#endif\n        attributes = attributes.addAttributes(jl_LLVMContext, i + 1, as);\n    }\n    if (rt == jl_bottom_type) {\n        attributes = attributes.addAttribute(jl_LLVMContext,\n#if JL_LLVM_VERSION >= 50000\n                                             AttributeList::FunctionIndex,\n#else\n                                             AttributeSet::FunctionIndex,\n#endif\n                                             Attribute::NoReturn);\n    }\n    return \"\";\n}\n};\n\nstatic std::pair<CallingConv::ID, bool> convert_cconv(jl_sym_t *lhd)\n{\n    // check for calling convention specifier\n    if (lhd == jl_symbol(\"stdcall\")) {\n        return std::make_pair(CallingConv::X86_StdCall, false);\n    }\n    else if (lhd == jl_symbol(\"cdecl\") || lhd == jl_symbol(\"ccall\")) {\n        // `ccall` calling convention is a placeholder for when there isn't one provided\n        // it is not by itself a valid calling convention name to be specified in the surface\n        // syntax.\n        return std::make_pair(CallingConv::C, false);\n    }\n    else if (lhd == jl_symbol(\"fastcall\")) {\n        return std::make_pair(CallingConv::X86_FastCall, false);\n    }\n    else if (lhd == jl_symbol(\"thiscall\")) {\n        return std::make_pair(CallingConv::X86_ThisCall, false);\n    }\n    else if (lhd == jl_symbol(\"llvmcall\")) {\n        return std::make_pair(CallingConv::C, true);\n    }\n    jl_errorf(\"ccall: invalid calling convention %s\", jl_symbol_name(lhd));\n}\n\nstatic bool verify_ref_type(jl_codectx_t &ctx, jl_value_t* ref, jl_unionall_t *unionall_env, int n, const char *fname)\n{\n    // emit verification that the tparam for Ref isn't Any or a TypeVar\n    const char rt_err_msg_notany[] = \" type Ref{Any} is invalid. Use Any or Ptr{Any} instead.\";\n    if (ref == (jl_value_t*)jl_any_type && n == 0) {\n        emit_error(ctx, make_errmsg(fname, n, rt_err_msg_notany));\n        return false;\n    }\n    else if (jl_is_typevar(ref)) {\n        bool always_error = true;\n        if (unionall_env) {\n            int i;\n            jl_unionall_t *ua = unionall_env;\n            for (i = 0; jl_is_unionall(ua); i++) {\n                if (ua->var == (jl_tvar_t*)ref) {\n                    jl_cgval_t runtime_sp = emit_sparam(ctx, i);\n                    if (n > 0) {\n                        always_error = false;\n                    }\n                    else if (runtime_sp.constant) {\n                        if (runtime_sp.constant != (jl_value_t*)jl_any_type)\n                            always_error = false;\n                    }\n                    else {\n                        Value *notany = ctx.builder.CreateICmpNE(\n                                boxed(ctx, runtime_sp),\n                                maybe_decay_untracked(literal_pointer_val(ctx, (jl_value_t*)jl_any_type)));\n                        error_unless(ctx, notany, make_errmsg(fname, n, rt_err_msg_notany));\n                        always_error = false;\n                    }\n                    break;\n                }\n                ua = (jl_unionall_t*)ua->body;\n            }\n        }\n        if (always_error) {\n            emit_error(ctx, make_errmsg(fname, n, \" type Ref should have an element type, not Ref{<:T}.\"));\n            return false;\n        }\n    }\n    return true;\n}\n\nstatic const std::string verify_ccall_sig(size_t nccallargs, jl_value_t *&rt, jl_value_t *at,\n                                          jl_unionall_t *unionall_env, jl_svec_t *sparam_vals, const char *fname,\n                                          size_t &nargt, bool &isVa, Type *&lrt, bool &retboxed, bool &static_rt)\n{\n    JL_TYPECHK(ccall, type, rt);\n    JL_TYPECHK(ccall, simplevector, at);\n\n    if (jl_is_array_type(rt)) {\n        // `Array` used as return type just returns a julia object reference\n        rt = (jl_value_t*)jl_any_type;\n    }\n\n    lrt = julia_struct_to_llvm(rt, unionall_env, &retboxed);\n    if (lrt == NULL)\n        return \"return type doesn't correspond to a C type\";\n    else if (retboxed)\n        lrt = T_prjlvalue;\n\n    // is return type fully statically known?\n    if (unionall_env == NULL) {\n        static_rt = true;\n    }\n    else {\n        static_rt = retboxed || !jl_has_typevar_from_unionall(rt, unionall_env);\n        if (!static_rt && sparam_vals != NULL && jl_svec_len(sparam_vals) > 0) {\n            rt = jl_instantiate_type_in_env(rt, unionall_env, jl_svec_data(sparam_vals));\n            // `rt` is gc-rooted by the caller\n            static_rt = true;\n        }\n    }\n\n    nargt = jl_svec_len(at);\n    isVa = (nargt > 0 && jl_is_vararg_type(jl_svecref(at, nargt - 1)));\n    if (!strcmp(fname, \"ccall\")) {\n        if (!retboxed && static_rt) {\n            if (!jl_is_concrete_type(rt)) {\n                if (jl_is_cpointer_type(rt))\n                    return \"return type Ptr should have an element type (not Ptr{<:T})\";\n                else if (rt != jl_bottom_type)\n                    return \"return type must be a concrete DataType\";\n            }\n        }\n\n        if (isVa ? (nccallargs < nargt - 1) :\n                   (nccallargs != nargt)) {\n            return \"wrong number of arguments to ccall function\";\n        }\n    }\n\n    return \"\";\n}\n\n// Expr(:foreigncall, pointer, rettype, (argtypes...), args...)\nstatic jl_cgval_t emit_ccall(jl_codectx_t &ctx, jl_value_t **args, size_t nargs)\n{\n    JL_NARGSV(ccall, 5);\n    args -= 1;\n    jl_value_t *rt = args[2];\n    jl_value_t *at = args[3];\n    assert(jl_is_quotenode(args[4]));\n    jl_sym_t *cc_sym = *(jl_sym_t**)args[4];\n    size_t nccallargs = jl_unbox_long(args[5]);\n    assert(jl_is_symbol(cc_sym));\n    native_sym_arg_t symarg = {};\n    JL_GC_PUSH3(&rt, &at, &symarg.gcroot);\n\n    CallingConv::ID cc = CallingConv::C;\n    bool llvmcall = false;\n    std::tie(cc, llvmcall) = convert_cconv(cc_sym);\n\n    interpret_symbol_arg(ctx, symarg, args[1], \"ccall\", llvmcall);\n    Value *&jl_ptr = symarg.jl_ptr;\n    void (*&fptr)(void) = symarg.fptr;\n    const char *&f_name = symarg.f_name;\n    const char *&f_lib = symarg.f_lib;\n\n    if (f_name == NULL && fptr == NULL && jl_ptr == NULL) {\n        emit_error(ctx, \"ccall: null function pointer\");\n        JL_GC_POP();\n        return jl_cgval_t();\n    }\n\n    auto ccallarg = [=] (size_t i) {\n        assert(i < nccallargs);\n        return args[6 + i];\n    };\n\n    auto _is_libjulia_func = [&] (uintptr_t ptr, const char *name) {\n        if ((uintptr_t)fptr == ptr)\n            return true;\n        return (!f_lib || f_lib == JL_DL_LIBNAME) && f_name && !strcmp(f_name, name);\n    };\n#define is_libjulia_func(name) _is_libjulia_func((uintptr_t)&(name), #name)\n\n#ifdef _OS_LINUX_\n    // directly accessing the address of an ifunc can cause linker issue on\n    // some configurations (e.g. AArch64 + -Bsymbolic-functions).\n    static const auto ptls_getter = jl_dlsym_e(jl_dlopen(nullptr, 0),\n                                               \"jl_get_ptls_states\");\n#else\n    static const auto ptls_getter = &jl_get_ptls_states;\n#endif\n\n    // emit arguments\n    jl_cgval_t *argv = (jl_cgval_t*)alloca(sizeof(jl_cgval_t) * nccallargs);\n    std::vector<bool> addressOf(0);\n    for (size_t i = 0; i < nccallargs; i++) {\n        // Julia (expression) value of current parameter\n        jl_value_t *argi = ccallarg(i);\n\n        addressOf.push_back(false);\n\n        argv[i] = emit_expr(ctx, argi);\n    }\n\n    // emit roots\n    SmallVector<Value*, 16> gc_uses;\n    for (size_t i = nccallargs + 6; i <= nargs; i++) {\n        // Julia (expression) value of current parameter gcroot\n        jl_value_t *argi_root = args[i];\n        if (jl_is_long(argi_root))\n            continue;\n        jl_cgval_t arg_root = emit_expr(ctx, argi_root);\n        if (arg_root.Vboxed || arg_root.V) {\n            gc_uses.push_back(arg_root.Vboxed ? arg_root.Vboxed : arg_root.V);\n        }\n    }\n\n    jl_unionall_t *unionall = (jl_is_method(ctx.linfo->def.method) && jl_is_unionall(ctx.linfo->def.method->sig))\n        ? (jl_unionall_t*)ctx.linfo->def.method->sig\n        : NULL;\n\n    if (jl_is_abstract_ref_type(rt)) {\n        if (!verify_ref_type(ctx, jl_tparam0(rt), unionall, 0, \"ccall\")) {\n            JL_GC_POP();\n            return jl_cgval_t();\n        }\n        rt = (jl_value_t*)jl_any_type; // convert return type to jl_value_t*\n    }\n\n    // some sanity checking and check whether there's a vararg\n    bool isVa;\n    size_t nargt;\n    Type *lrt;\n    bool retboxed;\n    bool static_rt;\n    const std::string err = verify_ccall_sig(\n            /* inputs:  */\n            nccallargs, rt, at, unionall,\n            ctx.spvals_ptr == NULL ? ctx.linfo->sparam_vals : NULL,\n            \"ccall\",\n            /* outputs: */\n            nargt, isVa, lrt, retboxed, static_rt);\n    if (!err.empty()) {\n        emit_error(ctx, \"ccall \" + err);\n        JL_GC_POP();\n        return jl_cgval_t();\n    }\n    if (rt != args[2] && rt != (jl_value_t*)jl_any_type)\n        jl_add_method_root(ctx, rt);\n    function_sig_t sig(\"ccall\", lrt, rt, retboxed,\n                       (jl_svec_t*)at, unionall, nccallargs,\n                       isVa, cc, llvmcall);\n    for (size_t i = 0; i < nargt; i++) {\n        jl_value_t *tti = jl_svecref(at, i);\n        if (jl_is_vararg_type(tti))\n            tti = jl_unwrap_vararg(tti);\n        if (jl_is_abstract_ref_type(tti)) {\n            if (!verify_ref_type(ctx, jl_tparam0(tti), unionall, i + 1, \"ccall\")) {\n                JL_GC_POP();\n                return jl_cgval_t();\n            }\n        }\n    }\n\n    // some special functions\n    if (is_libjulia_func(jl_array_ptr)) {\n        assert(lrt == T_size);\n        assert(!isVa && !llvmcall && nargt == 1);\n        assert(!addressOf.at(0));\n        const jl_cgval_t &ary = argv[0];\n        JL_GC_POP();\n        return mark_or_box_ccall_result(ctx, ctx.builder.CreatePtrToInt(emit_unsafe_arrayptr(ctx, ary), lrt),\n                                        retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_value_ptr)) {\n        assert(retboxed ? lrt == T_prjlvalue : lrt == T_size);\n        assert(!isVa && !llvmcall && nargt == 1);\n        jl_value_t *tti = jl_svecref(at, 0);\n        Value *ary;\n        Type *largty;\n        bool isboxed;\n        if (addressOf.at(0)) {\n            largty = T_pjlvalue;\n            isboxed = true;\n        }\n        else if (jl_is_abstract_ref_type(tti)) {\n            tti = (jl_value_t*)jl_voidpointer_type;\n            largty = T_size;\n            isboxed = false;\n        }\n        else {\n            largty = julia_struct_to_llvm(tti, unionall, &isboxed);\n        }\n        if (isboxed) {\n            ary = boxed(ctx, argv[0]);\n        }\n        else {\n            ary = emit_unbox(ctx, largty, argv[0], tti);\n        }\n        JL_GC_POP();\n        if (!retboxed) {\n            return mark_or_box_ccall_result(\n                    ctx,\n                    emit_pointer_from_objref(ctx,\n                        emit_bitcast(ctx, ary, T_prjlvalue)),\n                    retboxed, rt, unionall, static_rt);\n        }\n        else {\n            return mark_or_box_ccall_result(\n                    ctx,\n                    ctx.builder.CreateAddrSpaceCast(\n                        ctx.builder.CreateIntToPtr(ary, T_pjlvalue),\n                        T_prjlvalue), // TODO: this addrspace cast is invalid (implies that the value is rooted elsewhere)\n                    retboxed, rt, unionall, static_rt);\n        }\n    }\n    else if (is_libjulia_func(jl_cpu_pause)) {\n        // Keep in sync with the julia_threads.h version\n        assert(lrt == T_void);\n        assert(!isVa && !llvmcall && nargt == 0);\n#ifdef __MIC__\n        // TODO\n#elif defined(_CPU_X86_64_) || defined(_CPU_X86_)  /* !__MIC__ */\n        static auto pauseinst = InlineAsm::get(FunctionType::get(T_void, false), \"pause\",\n                                               \"~{memory}\", true);\n        ctx.builder.CreateCall(pauseinst);\n        JL_GC_POP();\n        return ghostValue(jl_void_type);\n#elif defined(_CPU_AARCH64_) || (defined(_CPU_ARM_) && __ARM_ARCH >= 7)\n        static auto wfeinst = InlineAsm::get(FunctionType::get(T_void, false), \"wfe\",\n                                             \"~{memory}\", true);\n        ctx.builder.CreateCall(wfeinst);\n        JL_GC_POP();\n        return ghostValue(jl_void_type);\n#else\n        JL_GC_POP();\n        return ghostValue(jl_void_type);\n#endif\n    }\n    else if (is_libjulia_func(jl_cpu_wake)) {\n        // Keep in sync with the julia_threads.h version\n        assert(lrt == T_void);\n        assert(!isVa && !llvmcall && nargt == 0);\n#if JL_CPU_WAKE_NOOP == 1\n        JL_GC_POP();\n        return ghostValue(jl_void_type);\n#elif defined(_CPU_AARCH64_) || (defined(_CPU_ARM_) && __ARM_ARCH >= 7)\n        static auto sevinst = InlineAsm::get(FunctionType::get(T_void, false), \"sev\",\n                                             \"~{memory}\", true);\n        ctx.builder.CreateCall(sevinst);\n        JL_GC_POP();\n        return ghostValue(jl_void_type);\n#endif\n    }\n    else if (is_libjulia_func(jl_gc_safepoint)) {\n        assert(lrt == T_void);\n        assert(!isVa && !llvmcall && nargt == 0);\n        JL_GC_POP();\n        ctx.builder.CreateCall(prepare_call(gcroot_flush_func));\n        emit_signal_fence(ctx);\n        ctx.builder.CreateLoad(ctx.signalPage, true);\n        emit_signal_fence(ctx);\n        return ghostValue(jl_void_type);\n    }\n    else if (_is_libjulia_func((uintptr_t)ptls_getter, \"jl_get_ptls_states\")) {\n        assert(lrt == T_size);\n        assert(!isVa && !llvmcall && nargt == 0);\n        JL_GC_POP();\n        return mark_or_box_ccall_result(ctx,\n            ctx.builder.CreatePtrToInt(ctx.ptlsStates, lrt),\n            retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_threadid)) {\n        assert(lrt == T_int16);\n        assert(!isVa && !llvmcall && nargt == 0);\n        JL_GC_POP();\n        Value *ptls_i16 = emit_bitcast(ctx, ctx.ptlsStates, T_pint16);\n        const int tid_offset = offsetof(jl_tls_states_t, tid);\n        Value *ptid = ctx.builder.CreateGEP(ptls_i16, ConstantInt::get(T_size, tid_offset / 2));\n        return mark_or_box_ccall_result(ctx,\n            tbaa_decorate(tbaa_const, ctx.builder.CreateLoad(ptid)),\n            retboxed, rt, unionall, static_rt);\n    }\n    else if (is_libjulia_func(jl_sigatomic_begin)) {\n        assert(lrt == T_void);\n        assert(!isVa && !llvmcall && nargt == 0);\n        JL_GC_POP();\n        ctx.builder.CreateCall(prepare_call(gcroot_flush_func));\n        Value *pdefer_sig = emit_defer_signal(ctx);\n        Value *defer_sig = ctx.builder.CreateLoad(pdefer_sig);\n        defer_sig = ctx.builder.CreateAdd(defer_sig,\n                                      ConstantInt::get(T_sigatomic, 1));\n        ctx.builder.CreateStore(defer_sig, pdefer_sig);\n        emit_signal_fence(ctx);\n        return ghostValue(jl_void_type);\n    }\n    else if (is_libjulia_func(jl_sigatomic_end)) {\n        assert(lrt == T_void);\n        assert(!isVa && !llvmcall && nargt == 0);\n        JL_GC_POP();\n        ctx.builder.CreateCall(prepare_call(gcroot_flush_func));\n        Value *pdefer_sig = emit_defer_signal(ctx);\n        Value *defer_sig = ctx.builder.CreateLoad(pdefer_sig);\n        emit_signal_fence(ctx);\n        error_unless(ctx,\n                ctx.builder.CreateICmpNE(defer_sig, ConstantInt::get(T_sigatomic, 0)),\n                \"sigatomic_end called in non-sigatomic region\");\n        defer_sig = ctx.builder.CreateSub(\n                defer_sig,\n                ConstantInt::get(T_sigatomic, 1));\n        ctx.builder.CreateStore(defer_sig, pdefer_sig);\n        BasicBlock *checkBB = BasicBlock::Create(jl_LLVMContext, \"check\",\n                                                 ctx.f);\n        BasicBlock *contBB = BasicBlock::Create(jl_LLVMContext, \"cont\");\n        ctx.builder.CreateCondBr(\n                ctx.builder.CreateICmpEQ(defer_sig, ConstantInt::get(T_sigatomic, 0)),\n                checkBB, contBB);\n        ctx.builder.SetInsertPoint(checkBB);\n        ctx.builder.CreateLoad(\n                ctx.builder.CreateConstGEP1_32(ctx.signalPage, -1),\n                true);\n        ctx.builder.CreateBr(contBB);\n        ctx.f->getBasicBlockList().push_back(contBB);\n        ctx.builder.SetInsertPoint(contBB);\n        return ghostValue(jl_void_type);\n    }\n    else if (is_libjulia_func(jl_array_isassigned) &&\n             argv[1].typ == (jl_value_t*)jl_ulong_type) {\n        assert(!isVa && !llvmcall && nargt == 2 && !addressOf.at(0) && !addressOf.at(1));\n        jl_value_t *aryex = ccallarg(0);\n        const jl_cgval_t &aryv = argv[0];\n        const jl_cgval_t &idxv = argv[1];\n        jl_datatype_t *arydt = (jl_datatype_t*)jl_unwrap_unionall(aryv.typ);\n        if (jl_is_array_type(arydt)) {\n            jl_value_t *ety = jl_tparam0(arydt);\n            if (jl_array_store_unboxed(ety)) {\n                JL_GC_POP();\n                return mark_or_box_ccall_result(ctx, ConstantInt::get(T_int32, 1),\n                                                false, rt, unionall, static_rt);\n            }\n            else if (!jl_has_free_typevars(ety)) {\n                Value *idx = emit_unbox(ctx, T_size, idxv, (jl_value_t*)jl_ulong_type);\n                Value *arrayptr = emit_bitcast(ctx, emit_arrayptr(ctx, aryv, aryex), T_ppjlvalue);\n                Value *slot_addr = ctx.builder.CreateGEP(arrayptr, idx);\n                Value *load = tbaa_decorate(tbaa_arraybuf, ctx.builder.CreateLoad(slot_addr));\n                Value *res = ctx.builder.CreateZExt(ctx.builder.CreateICmpNE(load, V_null), T_int32);\n                JL_GC_POP();\n                return mark_or_box_ccall_result(ctx, res, retboxed, rt, unionall, static_rt);\n            }\n        }\n    }\n    else if (is_libjulia_func(jl_string_ptr)) {\n        assert(lrt == T_size);\n        assert(!isVa && !llvmcall && nargt == 1 && !addressOf.at(0));\n        Value *obj = emit_pointer_from_objref(ctx, boxed(ctx, argv[0]));\n        Value *strp = ctx.builder.CreateAdd(obj, ConstantInt::get(T_size, sizeof(void*)));\n        JL_GC_POP();\n        return mark_or_box_ccall_result(ctx, strp, retboxed, rt, unionall, static_rt);\n    }\n\n    jl_cgval_t retval = sig.emit_a_ccall(\n            ctx,\n            symarg,\n            nargt,\n            addressOf,\n            argv,\n            gc_uses,\n            static_rt);\n    JL_GC_POP();\n    return retval;\n}\n\njl_cgval_t function_sig_t::emit_a_ccall(\n        jl_codectx_t &ctx,\n        const native_sym_arg_t &symarg,\n        size_t nargt,\n        std::vector<bool> &addressOf,\n        jl_cgval_t *argv,\n        SmallVector<Value*, 16> &gc_uses,\n        bool static_rt) const\n{\n    if (!err_msg.empty()) {\n        emit_error(ctx, err_msg);\n        return jl_cgval_t();\n    }\n\n    FunctionType *functype = this->functype();\n\n    // save place before arguments, for possible insertion of temp arg area saving code.\n    BasicBlock::InstListType &instList = ctx.builder.GetInsertBlock()->getInstList();\n    Instruction *savespot = instList.empty() ? NULL : &instList.back();\n\n    bool needStackRestore = false;\n    Value **argvals = (Value**) alloca((nargs + sret) * sizeof(Value*));\n    for (size_t ai = 0; ai < nargs; ai++) {\n        // Current C function parameter\n        Type *largty; // LLVM type of the current parameter\n        bool toboxed;\n        jl_value_t *jargty; // Julia type of the current parameter\n        bool byRef; // Argument attributes\n        if (isVa && ai >= nargt - 1) {\n            largty = fargt.at(nargt - 1);\n            toboxed = fargt_isboxed.at(nargt - 1);\n            jargty = jl_unwrap_vararg(jl_svecref(at, nargt - 1));\n            byRef = byRefList.at(nargt - 1);\n        }\n        else {\n            largty = fargt.at(ai);\n            toboxed = fargt_isboxed.at(ai);\n            jargty = jl_svecref(at, ai);\n            byRef = byRefList.at(ai);\n        }\n        Type *pargty = ai + sret < fargt_sig.size() ? fargt_sig.at(ai + sret) : fargt_vasig;\n        jl_cgval_t &arg = argv[ai];\n\n        // if we know the function sparams, try to fill those in now\n        // so that the julia_to_native type checks are more likely to be doable (e.g. concrete types) at compile-time\n        jl_value_t *jargty_in_env = jargty;\n        if (ctx.spvals_ptr == NULL && !toboxed && unionall_env && jl_has_typevar_from_unionall(jargty, unionall_env) &&\n                jl_svec_len(ctx.linfo->sparam_vals) > 0) {\n            jargty_in_env = jl_instantiate_type_in_env(jargty_in_env, unionall_env, jl_svec_data(ctx.linfo->sparam_vals));\n            if (jargty_in_env != jargty)\n                jl_add_method_root(ctx, jargty_in_env);\n        }\n\n        Value *v;\n        if (!addressOf.at(ai)) {\n            if (jl_is_abstract_ref_type(jargty)) {\n                if (!jl_is_cpointer_type(arg.typ)) {\n                    emit_cpointercheck(ctx, arg, \"ccall: argument to Ref{T} is not a pointer\");\n                    arg.typ = (jl_value_t*)jl_voidpointer_type;\n                    arg.isboxed = false;\n                }\n                jargty_in_env = (jl_value_t*)jl_voidpointer_type;\n            }\n\n            v = julia_to_native(ctx, largty, toboxed, jargty_in_env, unionall_env, arg, byRef,\n                                ai, &needStackRestore);\n            bool issigned = jl_signed_type && jl_subtype(jargty, (jl_value_t*)jl_signed_type);\n            if (byRef) {\n                v = decay_derived(v);\n                // julia_to_native should already have done the alloca and store\n                assert(v->getType() == pargty);\n            }\n            else {\n                v = llvm_type_rewrite(ctx, v, pargty, issigned);\n            }\n        }\n        else {\n            if (jl_is_abstract_ref_type(jargty)) {\n                emit_error(ctx, \"ccall: & on a Ref{T} argument is invalid\");\n                return jl_cgval_t();\n            }\n            v = julia_to_address(ctx, largty, jargty_in_env, unionall_env, arg,\n                                 ai, &needStackRestore);\n            if (isa<UndefValue>(v)) {\n                return jl_cgval_t();\n            }\n            assert((!toboxed && !byRef) || isa<UndefValue>(v));\n        }\n\n        if (isa<UndefValue>(v)) {\n            return jl_cgval_t();\n        }\n        assert(v->getType() == pargty);\n        argvals[ai + sret] = v;\n    }\n\n    Value *result = NULL;\n    // First, if the ABI requires us to provide the space for the return\n    // argument, allocate the box and store that as the first argument type\n    bool sretboxed = false;\n    if (sret) {\n        assert(!retboxed && jl_is_datatype(rt) && \"sret return type invalid\");\n        if (jl_justbits(rt)) {\n            result = emit_static_alloca(ctx, lrt);\n            argvals[0] = ctx.builder.CreateBitCast(result, fargt_sig.at(0));\n        }\n        else {\n            // XXX: result needs to be zero'd and given a GC root here\n            assert(jl_datatype_size(rt) > 0 && \"sret shouldn't be a singleton instance\");\n            result = emit_allocobj(ctx, jl_datatype_size(rt),\n                                   literal_pointer_val(ctx, (jl_value_t*)rt));\n            sretboxed = true;\n            gc_uses.push_back(result);\n            argvals[0] = ctx.builder.CreateIntToPtr(emit_pointer_from_objref(ctx, result), fargt_sig.at(0));\n        }\n    }\n\n    Instruction *stacksave = NULL;\n    if (needStackRestore) {\n        stacksave = CallInst::Create(Intrinsic::getDeclaration(jl_Module,\n                                                               Intrinsic::stacksave));\n        if (savespot) {\n            instList.insertAfter(savespot->getIterator(), stacksave);\n        }\n        else {\n            instList.push_front(stacksave);\n        }\n    }\n\n    // make LLVM function object for the target\n    // keep this close to the function call, so that the compiler can\n    // optimize the global pointer load in the common case\n    Value *llvmf;\n    if (llvmcall) {\n        if (symarg.jl_ptr != NULL) {\n            jl_error(\"llvmcall doesn't support dynamic pointers\");\n        }\n        else if (symarg.fptr != NULL) {\n            jl_error(\"llvmcall doesn't support static pointers\");\n        }\n        else if (symarg.f_lib != NULL) {\n            jl_error(\"llvmcall doesn't support dynamic libraries\");\n        }\n        else {\n            assert(symarg.f_name != NULL);\n            llvmf = jl_Module->getOrInsertFunction(symarg.f_name, functype);\n            if (!isa<Function>(llvmf) || cast<Function>(llvmf)->getIntrinsicID() == Intrinsic::not_intrinsic)\n                jl_error(\"llvmcall only supports intrinsic calls\");\n        }\n    }\n    else if (symarg.jl_ptr != NULL) {\n        null_pointer_check(ctx, symarg.jl_ptr);\n        Type *funcptype = PointerType::get(functype, 0);\n        llvmf = ctx.builder.CreateIntToPtr(symarg.jl_ptr, funcptype);\n    }\n    else if (symarg.fptr != NULL) {\n        Type *funcptype = PointerType::get(functype, 0);\n        llvmf = literal_static_pointer_val(ctx, (void*)(uintptr_t)symarg.fptr, funcptype);\n        if (imaging_mode)\n            jl_printf(JL_STDERR,\"WARNING: literal address used in ccall for %s; code cannot be statically compiled\\n\", symarg.f_name);\n    }\n    else {\n        assert(symarg.f_name != NULL);\n\n        PointerType *funcptype = PointerType::get(functype, 0);\n        if (imaging_mode) {\n            // vararg requires musttail,\n            // but musttail is incompatible with noreturn.\n            if (functype->isVarArg())\n                llvmf = runtime_sym_lookup(ctx, funcptype, symarg.f_lib, symarg.f_name, ctx.f);\n            else\n                llvmf = emit_plt(ctx, functype, attributes, cc, symarg.f_lib, symarg.f_name);\n        }\n        else {\n            void *symaddr = jl_dlsym_e(jl_get_library(symarg.f_lib), symarg.f_name);\n            if (symaddr == NULL) {\n                std::stringstream msg;\n                msg << \"ccall: could not find function \";\n                msg << symarg.f_name;\n                if (symarg.f_lib != NULL) {\n#ifdef _OS_WINDOWS_\n                    assert(symarg.f_lib != JL_EXE_LIBNAME && symarg.f_lib != JL_DL_LIBNAME);\n#endif\n                    msg << \" in library \";\n                    msg << symarg.f_lib;\n                }\n                emit_error(ctx, msg.str());\n                return jl_cgval_t();\n            }\n            // since we aren't saving this code, there's no sense in\n            // putting anything complicated here: just JIT the function address\n            llvmf = literal_static_pointer_val(ctx, symaddr, funcptype);\n        }\n    }\n\n    OperandBundleDef OpBundle(\"jl_roots\", gc_uses);\n    // the actual call\n    Value *ret = ctx.builder.CreateCall(prepare_call(llvmf),\n                                    ArrayRef<Value*>(&argvals[0], nargs + sret),\n                                    ArrayRef<OperandBundleDef>(&OpBundle, gc_uses.empty() ? 0 : 1));\n    ((CallInst*)ret)->setAttributes(attributes);\n\n    if (cc != CallingConv::C)\n        ((CallInst*)ret)->setCallingConv(cc);\n    if (!sret)\n        result = ret;\n    if (needStackRestore) {\n        assert(stacksave != NULL);\n        ctx.builder.CreateCall(Intrinsic::getDeclaration(jl_Module, Intrinsic::stackrestore), stacksave);\n    }\n    if (0) { // Enable this to turn on SSPREQ (-fstack-protector) on the function containing this ccall\n        ctx.f->addFnAttr(Attribute::StackProtectReq);\n    }\n\n    if (rt == jl_bottom_type) {\n        CreateTrap(ctx.builder);\n        return jl_cgval_t();\n    }\n\n    // Finally we need to box the result into julia type\n    // However, if we have already created a box for the return\n    // type because the ABI required us to pass a pointer (sret),\n    // then we do not need to do this.\n    bool jlretboxed;\n    if (retboxed) {\n        assert(!sret);\n        jlretboxed = true;\n    }\n    else if (sret) {\n        jlretboxed = sretboxed;\n        if (!jlretboxed) {\n            // something alloca'd above is SSA\n            if (static_rt)\n                return mark_julia_slot(result, rt, NULL, tbaa_stack);\n            result = ctx.builder.CreateLoad(result);\n        }\n    }\n    else {\n        Type *jlrt = julia_type_to_llvm(rt, &jlretboxed); // compute the real \"julian\" return type and compute whether it is boxed\n        if (jlretboxed) {\n            jlrt = T_prjlvalue;\n        }\n        if (type_is_ghost(jlrt)) {\n            return ghostValue(rt);\n        }\n        else if (jl_is_datatype(rt) && jl_is_datatype_singleton((jl_datatype_t*)rt)) {\n            return mark_julia_const(((jl_datatype_t*)rt)->instance);\n        }\n        else if (jlretboxed && !retboxed) {\n            assert(jl_is_datatype(rt));\n            if (static_rt) {\n                Value *runtime_bt = literal_pointer_val(ctx, rt);\n                size_t rtsz = jl_datatype_size(rt);\n                assert(rtsz > 0);\n                Value *strct = emit_allocobj(ctx, rtsz, runtime_bt);\n                MDNode *tbaa = jl_is_mutable(rt) ? tbaa_mutab : tbaa_immut;\n                int boxalign = jl_datatype_align(rt);\n                // copy the data from the return value to the new struct\n#if JL_LLVM_VERSION >= 40000\n                const DataLayout &DL = jl_data_layout;\n#else\n                const DataLayout &DL = jl_ExecutionEngine->getDataLayout();\n#endif\n                auto resultTy = result->getType();\n                if (DL.getTypeStoreSize(resultTy) > rtsz) {\n                    // ARM and AArch64 can use a LLVM type larger than the julia type.\n                    // When this happens, cast through memory.\n                    auto slot = emit_static_alloca(ctx, resultTy);\n                    slot->setAlignment(boxalign);\n                    ctx.builder.CreateAlignedStore(result, slot, boxalign);\n                    emit_memcpy(ctx, strct, tbaa, slot, tbaa, rtsz, boxalign, tbaa);\n                }\n                else {\n                    init_bits_value(ctx, strct, result, tbaa, boxalign);\n                }\n                return mark_julia_type(ctx, strct, true, rt);\n            }\n            jlretboxed = false; // trigger mark_or_box_ccall_result to build the runtime box\n        }\n        else if (lrt != prt) {\n            assert(jlrt == lrt || !lrt->isStructTy()); // julia_type_to_llvm and julia_struct_to_llvm should be returning the same StructType\n            result = llvm_type_rewrite(ctx, result, lrt, false);\n        }\n    }\n\n    return mark_or_box_ccall_result(ctx, result, jlretboxed, rt, unionall_env, static_rt);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/src/jitlayers.cpp": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n#include \"llvm-version.h\"\n#include \"platform.h\"\n#include \"options.h\"\n#include <iostream>\n#include <sstream>\n\n// analysis passes\n#include <llvm/Analysis/Passes.h>\n#include <llvm/Analysis/BasicAliasAnalysis.h>\n#include <llvm/Analysis/TypeBasedAliasAnalysis.h>\n#include <llvm/Analysis/TargetTransformInfo.h>\n#include <llvm/Analysis/TargetLibraryInfo.h>\n#include <llvm/IR/Verifier.h>\n#if defined(USE_POLLY)\n#include <polly/RegisterPasses.h>\n#include <polly/LinkAllPasses.h>\n#include <polly/CodeGen/CodegenCleanup.h>\n#if defined(USE_POLLY_ACC)\n#include <polly/Support/LinkGPURuntime.h>\n#endif\n#endif\n\n#include <llvm/Transforms/IPO.h>\n#include <llvm/Transforms/Scalar.h>\n#include <llvm/Transforms/Utils/BasicBlockUtils.h>\n#include <llvm/Transforms/Instrumentation.h>\n#include <llvm/Transforms/Vectorize.h>\n#include <llvm/Transforms/Scalar/GVN.h>\n#if JL_LLVM_VERSION >= 40000\n#include <llvm/Transforms/IPO/AlwaysInliner.h>\n#endif\n\nnamespace llvm {\n    extern Pass *createLowerSimdLoopPass();\n}\n\n#if JL_LLVM_VERSION >= 40000\n#  include <llvm/Bitcode/BitcodeWriter.h>\n#else\n#  include <llvm/Bitcode/ReaderWriter.h>\n#endif\n#include <llvm/Bitcode/BitcodeWriterPass.h>\n\n#include <llvm/IR/LegacyPassManagers.h>\n#include <llvm/IR/IRPrintingPasses.h>\n#include <llvm/Transforms/Utils/Cloning.h>\n#include \"llvm/Object/ArchiveWriter.h\"\n\n// target support\n#include <llvm/ADT/Triple.h>\n#include <llvm/Support/TargetRegistry.h>\n#include <llvm/IR/DataLayout.h>\n#include <llvm/Support/DynamicLibrary.h>\n\n\n#include <llvm/Support/raw_ostream.h>\n#include <llvm/Support/FormattedStream.h>\n#include <llvm/ADT/StringMap.h>\n#include <llvm/ADT/StringSet.h>\n#include <llvm/ADT/SmallSet.h>\n#include \"codegen_shared.h\"\n\nusing namespace llvm;\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"jitlayers.h\"\n#include \"julia_assert.h\"\n\nRTDyldMemoryManager* createRTDyldMemoryManager(void);\n\nstatic IntegerType *T_uint32;\nstatic IntegerType *T_uint64;\nstatic IntegerType *T_size;\nstatic Type *T_psize;\nstatic Type *T_pjlvalue;\nvoid jl_init_jit(Type *T_pjlvalue_)\n{\n    T_uint32 = Type::getInt32Ty(jl_LLVMContext);\n    T_uint64 = Type::getInt64Ty(jl_LLVMContext);\n    if (sizeof(size_t) == 8)\n        T_size = T_uint64;\n    else\n        T_size = T_uint32;\n    T_psize = PointerType::get(T_size, 0);\n    T_pjlvalue = T_pjlvalue_;\n}\n\n// Except for parts of this file which were copied from LLVM, under the UIUC license (marked below).\n\nvoid addTargetPasses(legacy::PassManagerBase *PM, TargetMachine *TM)\n{\n    PM->add(new TargetLibraryInfoWrapperPass(Triple(TM->getTargetTriple())));\n    PM->add(createTargetTransformInfoWrapperPass(TM->getTargetIRAnalysis()));\n}\n\n// this defines the set of optimization passes defined for Julia at various optimization levels.\n// it assumes that the TLI and TTI wrapper passes have already been added.\nvoid addOptimizationPasses(legacy::PassManagerBase *PM, int opt_level, bool dump_native)\n{\n#ifdef JL_DEBUG_BUILD\n    PM->add(createGCInvariantVerifierPass(true));\n    PM->add(createVerifierPass());\n#endif\n\n#if defined(JL_ASAN_ENABLED)\n    PM->add(createAddressSanitizerFunctionPass());\n#endif\n#if defined(JL_MSAN_ENABLED)\n    PM->add(llvm::createMemorySanitizerPass(true));\n#endif\n    if (opt_level < 2) {\n        PM->add(createCFGSimplificationPass()); // Clean up disgusting code\n        if (opt_level == 1) {\n            PM->add(createSROAPass());                 // Break up aggregate allocas\n            PM->add(createInstructionCombiningPass()); // Cleanup for scalarrepl.\n            PM->add(createEarlyCSEPass());\n        }\n#if JL_LLVM_VERSION < 50000\n        PM->add(createBarrierNoopPass());\n        PM->add(createLowerExcHandlersPass());\n        PM->add(createGCInvariantVerifierPass(false));\n        PM->add(createLateLowerGCFramePass());\n        PM->add(createLowerPTLSPass(dump_native));\n        PM->add(createBarrierNoopPass());\n#endif\n        PM->add(createMemCpyOptPass()); // Remove memcpy / form memset\n#if JL_LLVM_VERSION >= 40000\n        PM->add(createAlwaysInlinerLegacyPass()); // Respect always_inline\n#else\n        PM->add(createAlwaysInlinerPass()); // Respect always_inline\n#endif\n#if JL_LLVM_VERSION >= 50000\n        PM->add(createBarrierNoopPass());\n        PM->add(createLowerExcHandlersPass());\n        PM->add(createGCInvariantVerifierPass(false));\n        PM->add(createLateLowerGCFramePass());\n        PM->add(createLowerPTLSPass(dump_native));\n#endif\n        PM->add(createLowerSimdLoopPass());        // Annotate loop marked with \"simdloop\" as LLVM parallel loop\n        if (dump_native)\n            PM->add(createMultiVersioningPass());\n        return;\n    }\n    PM->add(createPropagateJuliaAddrspaces());\n    PM->add(createTypeBasedAAWrapperPass());\n    if (opt_level >= 3) {\n        PM->add(createBasicAAWrapperPass());\n    }\n    // list of passes from vmkit\n    PM->add(createCFGSimplificationPass()); // Clean up disgusting code\n    PM->add(createDeadCodeEliminationPass());\n    PM->add(createSROAPass()); // Kill useless allocas\n\n    // Due to bugs and missing features LLVM < 5.0, does not properly propagate\n    // our invariants. We need to do GC rooting here. This reduces the\n    // effectiveness of the optimization, but should retain correctness.\n#if JL_LLVM_VERSION < 50000\n    PM->add(createLowerExcHandlersPass());\n    PM->add(createAllocOptPass());\n    PM->add(createLateLowerGCFramePass());\n    // Remove dead use of ptls\n    PM->add(createDeadCodeEliminationPass());\n    PM->add(createLowerPTLSPass(dump_native));\n#endif\n\n    PM->add(createMemCpyOptPass());\n\n#if JL_LLVM_VERSION >= 40000\n    PM->add(createAlwaysInlinerLegacyPass()); // Respect always_inline\n#else\n    PM->add(createAlwaysInlinerPass()); // Respect always_inline\n#endif\n\n#if JL_LLVM_VERSION >= 50000\n    // Running `memcpyopt` between this and `sroa` seems to give `sroa` a hard time\n    // merging the `alloca` for the unboxed data and the `alloca` created by the `alloc_opt`\n    // pass.\n    PM->add(createAllocOptPass());\n#endif\n    PM->add(createInstructionCombiningPass()); // Cleanup for scalarrepl.\n    // Now that SROA has cleaned up for front-end mess, a lot of control flow should\n    // be more evident - try to clean it up.\n    PM->add(createCFGSimplificationPass());    // Merge & remove BBs\n    if (dump_native)\n        PM->add(createMultiVersioningPass());\n    PM->add(createSROAPass());                 // Break up aggregate allocas\n    PM->add(createInstructionCombiningPass()); // Cleanup for scalarrepl.\n    PM->add(createJumpThreadingPass());        // Thread jumps.\n    PM->add(createInstructionCombiningPass()); // Combine silly seq's\n\n    //PM->add(createCFGSimplificationPass());    // Merge & remove BBs\n    PM->add(createReassociatePass());          // Reassociate expressions\n\n    // this has the potential to make some things a bit slower\n    //PM->add(createBBVectorizePass());\n\n    PM->add(createEarlyCSEPass()); //// ****\n\n#if JL_LLVM_VERSION >= 50000\n    // Load forwarding above can expose allocations that aren't actually used\n    // remove those before optimizing loops.\n    PM->add(createAllocOptPass());\n#endif\n    PM->add(createLoopIdiomPass()); //// ****\n    PM->add(createLoopRotatePass());           // Rotate loops.\n#ifdef USE_POLLY\n    // LCSSA (which has already run at this point due to the dependencies of the\n    // above passes) introduces redundant phis that hinder Polly. Therefore we\n    // run InstCombine here to remove them.\n    PM->add(createInstructionCombiningPass());\n    PM->add(polly::createCodePreparationPass());\n    polly::registerPollyPasses(*PM);\n    PM->add(polly::createCodegenCleanupPass());\n#endif\n    // LoopRotate strips metadata from terminator, so run LowerSIMD afterwards\n    PM->add(createLowerSimdLoopPass());        // Annotate loop marked with \"simdloop\" as LLVM parallel loop\n    PM->add(createLICMPass());                 // Hoist loop invariants\n    PM->add(createLoopUnswitchPass());         // Unswitch loops.\n    // Subsequent passes not stripping metadata from terminator\n    PM->add(createInstructionCombiningPass());\n    PM->add(createIndVarSimplifyPass());       // Canonicalize indvars\n    PM->add(createLoopDeletionPass());         // Delete dead loops\n    PM->add(createSimpleLoopUnrollPass());     // Unroll small loops\n    //PM->add(createLoopStrengthReducePass());   // (jwb added)\n\n#if JL_LLVM_VERSION >= 50000\n    // Run our own SROA on heap objects before LLVM's\n    PM->add(createAllocOptPass());\n#endif\n    // Re-run SROA after loop-unrolling (useful for small loops that operate,\n    // over the structure of an aggregate)\n    PM->add(createSROAPass());                 // Break up aggregate allocas\n    PM->add(createInstructionCombiningPass()); // Clean up after the unroller\n    PM->add(createGVNPass());                  // Remove redundancies\n    PM->add(createMemCpyOptPass());            // Remove memcpy / form memset\n    PM->add(createSCCPPass());                 // Constant prop with SCCP\n\n    // Run instcombine after redundancy elimination to exploit opportunities\n    // opened up by them.\n    PM->add(createSinkingPass()); ////////////// ****\n    PM->add(createInstructionSimplifierPass());///////// ****\n    PM->add(createInstructionCombiningPass());\n    PM->add(createJumpThreadingPass());         // Thread jumps\n    PM->add(createDeadStoreEliminationPass());  // Delete dead stores\n\n#if JL_LLVM_VERSION >= 50000\n    // More dead allocation (store) deletion before loop optimization\n    PM->add(createAllocOptPass());\n#endif\n    // see if all of the constant folding has exposed more loops\n    // to simplification and deletion\n    // this helps significantly with cleaning up iteration\n    PM->add(createCFGSimplificationPass());     // Merge & remove BBs\n    PM->add(createLoopIdiomPass());\n    PM->add(createLoopDeletionPass());          // Delete dead loops\n    PM->add(createJumpThreadingPass());         // Thread jumps\n    PM->add(createSLPVectorizerPass());         // Vectorize straight-line code\n    PM->add(createAggressiveDCEPass());         // Delete dead instructions\n    PM->add(createInstructionCombiningPass());  // Clean up after SLP loop vectorizer\n    PM->add(createLoopVectorizePass());         // Vectorize loops\n    PM->add(createInstructionCombiningPass());  // Clean up after loop vectorizer\n    // LowerPTLS removes an indirect call. As a result, it is likely to trigger\n    // LLVM's devirtualization heuristics, which would result in the entire\n    // pass pipeline being re-exectuted. Prevent this by inserting a barrier.\n#if JL_LLVM_VERSION >= 50000\n    PM->add(createBarrierNoopPass());\n    PM->add(createLowerExcHandlersPass());\n    PM->add(createGCInvariantVerifierPass(false));\n    PM->add(createLateLowerGCFramePass());\n    // Remove dead use of ptls\n    PM->add(createDeadCodeEliminationPass());\n    PM->add(createLowerPTLSPass(dump_native));\n    // Clean up write barrier and ptls lowering\n    PM->add(createCFGSimplificationPass());\n#endif\n    PM->add(createCombineMulAddPass());\n}\n\nextern \"C\" JL_DLLEXPORT\nvoid jl_add_optimization_passes(LLVMPassManagerRef PM, int opt_level) {\n    addOptimizationPasses(unwrap(PM), opt_level);\n}\n\n// ------------------------ TEMPORARILY COPIED FROM LLVM -----------------\n// This must be kept in sync with gdb/gdb/jit.h .\nextern \"C\" {\n\n  typedef enum {\n    JIT_NOACTION = 0,\n    JIT_REGISTER_FN,\n    JIT_UNREGISTER_FN\n  } jit_actions_t;\n\n  struct jit_code_entry {\n    struct jit_code_entry *next_entry;\n    struct jit_code_entry *prev_entry;\n    const char *symfile_addr;\n    uint64_t symfile_size;\n  };\n\n  struct jit_descriptor {\n    uint32_t version;\n    // This should be jit_actions_t, but we want to be specific about the\n    // bit-width.\n    uint32_t action_flag;\n    struct jit_code_entry *relevant_entry;\n    struct jit_code_entry *first_entry;\n  };\n\n  // We put information about the JITed function in this global, which the\n  // debugger reads.  Make sure to specify the version statically, because the\n  // debugger checks the version before we can set it during runtime.\n  extern struct jit_descriptor __jit_debug_descriptor;\n\n  LLVM_ATTRIBUTE_NOINLINE extern void __jit_debug_register_code();\n}\n\nnamespace {\n\n// Use a local variable to hold the addresses to avoid generating a PLT\n// on the function call.\n// It messes up the GDB lookup logic with dynamically linked LLVM.\n// (Ref https://sourceware.org/bugzilla/show_bug.cgi?id=20633)\n// Use `volatile` to make sure the call always loads this slot.\nvoid (*volatile jit_debug_register_code)() = __jit_debug_register_code;\n\nusing namespace llvm;\nusing namespace llvm::object;\nusing namespace llvm::orc;\n\n/// Do the registration.\nvoid NotifyDebugger(jit_code_entry *JITCodeEntry)\n{\n    __jit_debug_descriptor.action_flag = JIT_REGISTER_FN;\n\n    // Insert this entry at the head of the list.\n    JITCodeEntry->prev_entry = nullptr;\n    jit_code_entry *NextEntry = __jit_debug_descriptor.first_entry;\n    JITCodeEntry->next_entry = NextEntry;\n    if (NextEntry) {\n        NextEntry->prev_entry = JITCodeEntry;\n    }\n    __jit_debug_descriptor.first_entry = JITCodeEntry;\n    __jit_debug_descriptor.relevant_entry = JITCodeEntry;\n    jit_debug_register_code();\n}\n}\n// ------------------------ END OF TEMPORARY COPY FROM LLVM -----------------\n\n#if defined(_OS_LINUX_) || defined(_OS_WINDOWS_) || defined(_OS_FREEBSD_)\n// Resolve non-lock free atomic functions in the libatomic1 library.\n// This is the library that provides support for c11/c++11 atomic operations.\nstatic uint64_t resolve_atomic(const char *name)\n{\n#if defined(_OS_LINUX_) || defined(_OS_FREEBSD_)\n    static const char *const libatomic = \"libatomic.so.1\";\n#elif defined(_OS_WINDOWS_)\n    static const char *const libatomic = \"libatomic-1.dll\";\n#endif\n    static void *atomic_hdl = jl_load_dynamic_library_e(libatomic,\n                                                        JL_RTLD_LOCAL);\n    static const char *const atomic_prefix = \"__atomic_\";\n    if (!atomic_hdl)\n        return 0;\n    if (strncmp(name, atomic_prefix, strlen(atomic_prefix)) != 0)\n        return 0;\n    return (uintptr_t)jl_dlsym_e(atomic_hdl, name);\n}\n#endif\n\n// Custom object emission notification handler for the JuliaOJIT\nextern JITEventListener *CreateJuliaJITEventListener();\nJuliaOJIT::DebugObjectRegistrar::DebugObjectRegistrar(JuliaOJIT &JIT)\n    : JuliaListener(CreateJuliaJITEventListener()),\n      JIT(JIT) {}\n\nJL_DLLEXPORT void ORCNotifyObjectEmitted(JITEventListener *Listener,\n                                         const object::ObjectFile &obj,\n                                         const object::ObjectFile &debugObj,\n                                         const RuntimeDyld::LoadedObjectInfo &L,\n                                         RTDyldMemoryManager *memmgr);\n\ntemplate <typename ObjT, typename LoadResult>\nvoid JuliaOJIT::DebugObjectRegistrar::registerObject(RTDyldObjHandleT H, const ObjT &Object,\n                                                     const LoadResult &LO)\n{\n    OwningBinary<object::ObjectFile> SavedObject = LO->getObjectForDebug(*Object);\n\n    // If the debug object is unavailable, save (a copy of) the original object\n    // for our backtraces\n    if (!SavedObject.getBinary()) {\n        // This is unfortunate, but there doesn't seem to be a way to take\n        // ownership of the original buffer\n        auto NewBuffer = MemoryBuffer::getMemBufferCopy(Object->getData(),\n                                                        Object->getFileName());\n        auto NewObj = ObjectFile::createObjectFile(NewBuffer->getMemBufferRef());\n        assert(NewObj);\n        SavedObject = OwningBinary<object::ObjectFile>(std::move(*NewObj),\n                                                       std::move(NewBuffer));\n    }\n    else {\n        NotifyGDB(SavedObject);\n    }\n\n    JIT.NotifyFinalizer(*Object, *LO);\n    SavedObjects.push_back(std::move(SavedObject));\n\n    ORCNotifyObjectEmitted(JuliaListener.get(), *Object,\n                           *SavedObjects.back().getBinary(),\n                           *LO, JIT.MemMgr.get());\n\n    // record all of the exported symbols defined in this object\n    // in the primary hash table for the enclosing JIT\n    for (auto &Symbol : Object->symbols()) {\n        auto Flags = Symbol.getFlags();\n        if (Flags & object::BasicSymbolRef::SF_Undefined)\n            continue;\n        if (!(Flags & object::BasicSymbolRef::SF_Exported))\n            continue;\n        auto NameOrError = Symbol.getName();\n        assert(NameOrError);\n        auto Name = NameOrError.get();\n        auto Sym = JIT.CompileLayer.findSymbolIn(H, Name, true);\n        assert(Sym);\n        // note: calling getAddress here eagerly finalizes H\n        // as an alternative, we could store the JITSymbol instead\n        // (which would present a lazy-initializer functor interface instead)\n#if JL_LLVM_VERSION >= 50000\n        JIT.LocalSymbolTable[Name] = (void*)(uintptr_t)cantFail(Sym.getAddress());\n#else\n        JIT.LocalSymbolTable[Name] = (void*)(uintptr_t)Sym.getAddress();\n#endif\n    }\n}\n\n// TODO: hook up RegisterJITEventListener, instead of hard-coding the GDB and JuliaListener targets\ntemplate <typename ObjSetT, typename LoadResult>\nvoid JuliaOJIT::DebugObjectRegistrar::operator()(RTDyldObjHandleT H,\n                const ObjSetT &Objects, const LoadResult &LOS)\n{\n#if JL_LLVM_VERSION >= 50000\n    registerObject(H, Objects->getBinary(),\n                   static_cast<const RuntimeDyld::LoadedObjectInfo*>(&LOS));\n#else\n    auto oit = Objects.begin();\n    auto lit = LOS.begin();\n    for (; oit != Objects.end(); ++oit, ++lit) {\n        const auto &Object = (*oit)->getBinary();\n        auto &LO = *lit;\n\n        registerObject(H, Object, LO);\n    }\n#endif\n}\n\nvoid JuliaOJIT::DebugObjectRegistrar::NotifyGDB(OwningBinary<object::ObjectFile> &DebugObj)\n{\n    const char *Buffer = DebugObj.getBinary()->getMemoryBufferRef().getBufferStart();\n    size_t      Size = DebugObj.getBinary()->getMemoryBufferRef().getBufferSize();\n\n    assert(Buffer && \"Attempt to register a null object with a debugger.\");\n    jit_code_entry *JITCodeEntry = new jit_code_entry();\n\n    if (!JITCodeEntry) {\n        jl_printf(JL_STDERR, \"WARNING: Allocation failed when registering a JIT entry!\\n\");\n    }\n    else {\n        JITCodeEntry->symfile_addr = Buffer;\n        JITCodeEntry->symfile_size = Size;\n\n        NotifyDebugger(JITCodeEntry);\n    }\n}\n\nobject::OwningBinary<object::ObjectFile> JuliaOJIT::CompilerT::operator()(Module &M)\n{\n    JL_TIMING(LLVM_OPT);\n    jit.PM.run(M);\n    std::unique_ptr<MemoryBuffer> ObjBuffer(\n        new ObjectMemoryBuffer(std::move(jit.ObjBufferSV)));\n    auto Obj = object::ObjectFile::createObjectFile(ObjBuffer->getMemBufferRef());\n\n    if (!Obj) {\n        llvm_dump(&M);\n        std::string Buf;\n        raw_string_ostream OS(Buf);\n        logAllUnhandledErrors(Obj.takeError(), OS, \"\");\n        OS.flush();\n        llvm::report_fatal_error(\"FATAL: Unable to compile LLVM Module: '\" + Buf + \"'\\n\"\n                                 \"The module's content was printed above. Please file a bug report\");\n    }\n\n    return OwningObj(std::move(*Obj), std::move(ObjBuffer));\n}\n\nJuliaOJIT::JuliaOJIT(TargetMachine &TM)\n  : TM(TM),\n    DL(TM.createDataLayout()),\n    ObjStream(ObjBufferSV),\n    MemMgr(createRTDyldMemoryManager()),\n    registrar(*this),\n    ObjectLayer(\n#if JL_LLVM_VERSION >= 50000\n        [&] { return MemMgr; },\n#endif\n        std::ref(registrar)\n        ),\n    CompileLayer(\n            ObjectLayer,\n            CompilerT(this)\n        )\n{\n    addTargetPasses(&PM, &TM);\n    addOptimizationPasses(&PM, jl_generating_output() ? 0 : jl_options.opt_level);\n    if (TM.addPassesToEmitMC(PM, Ctx, ObjStream))\n        llvm_unreachable(\"Target does not support MC emission.\");\n\n    // Make sure SectionMemoryManager::getSymbolAddressInProcess can resolve\n    // symbols in the program as well. The nullptr argument to the function\n    // tells DynamicLibrary to load the program, not a library.\n    std::string *ErrorStr = nullptr;\n    if (sys::DynamicLibrary::LoadLibraryPermanently(nullptr, ErrorStr))\n        report_fatal_error(\"FATAL: unable to dlopen self\\n\" + *ErrorStr);\n}\n\nvoid JuliaOJIT::addGlobalMapping(StringRef Name, uint64_t Addr)\n{\n    bool successful = GlobalSymbolTable.insert(std::make_pair(Name, (void*)Addr)).second;\n    (void)successful;\n    assert(successful);\n}\n\nvoid JuliaOJIT::addGlobalMapping(const GlobalValue *GV, void *Addr)\n{\n    addGlobalMapping(getMangledName(GV), (uintptr_t)Addr);\n}\n\nvoid *JuliaOJIT::getPointerToGlobalIfAvailable(StringRef S)\n{\n    SymbolTableT::const_iterator pos = GlobalSymbolTable.find(S);\n    if (pos != GlobalSymbolTable.end())\n        return pos->second;\n    return nullptr;\n}\n\nvoid *JuliaOJIT::getPointerToGlobalIfAvailable(const GlobalValue *GV)\n{\n    return getPointerToGlobalIfAvailable(getMangledName(GV));\n}\n\n\nvoid JuliaOJIT::addModule(std::unique_ptr<Module> M)\n{\n#ifndef JL_NDEBUG\n    // validate the relocations for M\n    for (Module::iterator I = M->begin(), E = M->end(); I != E; ) {\n        Function *F = &*I;\n        ++I;\n        if (F->isDeclaration()) {\n            if (F->use_empty())\n                F->eraseFromParent();\n            else if (!(isIntrinsicFunction(F) ||\n                       findUnmangledSymbol(F->getName()) ||\n                       SectionMemoryManager::getSymbolAddressInProcess(\n                           getMangledName(F->getName())))) {\n                std::cerr << \"FATAL ERROR: \"\n                          << \"Symbol \\\"\" << F->getName().str() << \"\\\"\"\n                          << \"not found\";\n                abort();\n            }\n        }\n    }\n#endif\n    JL_TIMING(LLVM_MODULE_FINISH);\n    // We need a memory manager to allocate memory and resolve symbols for this\n    // new module. Create one that resolves symbols by looking back into the JIT.\n    auto Resolver = orc::createLambdaResolver(\n                      [&](const std::string &Name) {\n                        // TODO: consider moving the FunctionMover resolver here\n                        // Step 0: ObjectLinkingLayer has checked whether it is in the current module\n                        // Step 1: See if it's something known to the ExecutionEngine\n                        if (auto Sym = findSymbol(Name, true)) {\n#if JL_LLVM_VERSION >= 40000\n                            // `findSymbol` already eagerly resolved the address\n                            // return it directly.\n                            return Sym;\n#else\n                            return RuntimeDyld::SymbolInfo(Sym.getAddress(),\n                                                           Sym.getFlags());\n#endif\n                        }\n                        // Step 2: Search the program symbols\n                        if (uint64_t addr = SectionMemoryManager::getSymbolAddressInProcess(Name))\n                            return JL_SymbolInfo(addr, JITSymbolFlags::Exported);\n#if defined(_OS_LINUX_) || defined(_OS_WINDOWS_) || defined(_OS_FREEBSD_)\n                        if (uint64_t addr = resolve_atomic(Name.c_str()))\n                            return JL_SymbolInfo(addr, JITSymbolFlags::Exported);\n#endif\n                        // Return failure code\n                        return JL_SymbolInfo(nullptr);\n                      },\n                      [](const std::string &S) { return nullptr; }\n                    );\n#if JL_LLVM_VERSION >= 50000\n    auto modset = cantFail(CompileLayer.addModule(std::move(M), std::move(Resolver)));\n#else\n    SmallVector<std::unique_ptr<Module>,1> Ms;\n    Ms.push_back(std::move(M));\n    auto modset = CompileLayer.addModuleSet(std::move(Ms), MemMgr.get(),\n                                            std::move(Resolver));\n#endif\n    // Force LLVM to emit the module so that we can register the symbols\n    // in our lookup table.\n#if JL_LLVM_VERSION >= 50000\n    auto Err = CompileLayer.emitAndFinalize(modset);\n    // Check for errors to prevent LLVM from crashing the program.\n    assert(!Err);\n#else\n    CompileLayer.emitAndFinalize(modset);\n#endif\n}\n\nvoid JuliaOJIT::removeModule(ModuleHandleT H)\n{\n#if JL_LLVM_VERSION >= 50000\n    (void)CompileLayer.removeModule(H);\n#else\n    (void)CompileLayer.removeModuleSet(H);\n#endif\n}\n\nJL_JITSymbol JuliaOJIT::findSymbol(const std::string &Name, bool ExportedSymbolsOnly)\n{\n    void *Addr = nullptr;\n    if (ExportedSymbolsOnly) {\n        // Step 1: Check against list of known external globals\n        Addr = getPointerToGlobalIfAvailable(Name);\n    }\n    // Step 2: Search all previously emitted symbols\n    if (Addr == nullptr)\n        Addr = LocalSymbolTable[Name];\n    return JL_JITSymbol((uintptr_t)Addr, JITSymbolFlags::Exported);\n}\n\nJL_JITSymbol JuliaOJIT::findUnmangledSymbol(const std::string Name)\n{\n    return findSymbol(getMangledName(Name), true);\n}\n\nuint64_t JuliaOJIT::getGlobalValueAddress(const std::string &Name)\n{\n#if JL_LLVM_VERSION >= 50000\n    auto addr = findSymbol(getMangledName(Name), false).getAddress();\n    return addr ? addr.get() : 0;\n#else\n    return findSymbol(getMangledName(Name), false).getAddress();\n#endif\n}\n\nuint64_t JuliaOJIT::getFunctionAddress(const std::string &Name)\n{\n#if JL_LLVM_VERSION >= 50000\n    auto addr = findSymbol(getMangledName(Name), false).getAddress();\n    return addr ? addr.get() : 0;\n#else\n    return findSymbol(getMangledName(Name), false).getAddress();\n#endif\n}\n\nFunction *JuliaOJIT::FindFunctionNamed(const std::string &Name)\n{\n    return shadow_output->getFunction(Name);\n}\n\nvoid JuliaOJIT::RegisterJITEventListener(JITEventListener *L)\n{\n    if (!L)\n        return;\n    EventListeners.push_back(L);\n}\n\nvoid JuliaOJIT::NotifyFinalizer(const object::ObjectFile &Obj,\n                                const RuntimeDyld::LoadedObjectInfo &LoadedObjectInfo)\n{\n    for (auto &Listener : EventListeners)\n        Listener->NotifyObjectEmitted(Obj, LoadedObjectInfo);\n}\n\nconst DataLayout& JuliaOJIT::getDataLayout() const\n{\n    return DL;\n}\n\nconst Triple& JuliaOJIT::getTargetTriple() const\n{\n    return TM.getTargetTriple();\n}\n\nstd::string JuliaOJIT::getMangledName(const std::string &Name)\n{\n    SmallString<128> FullName;\n    Mangler::getNameWithPrefix(FullName, Name, DL);\n    return FullName.str();\n}\n\nstd::string JuliaOJIT::getMangledName(const GlobalValue *GV)\n{\n    return getMangledName(GV->getName());\n}\n\nJuliaOJIT *jl_ExecutionEngine;\n\n// MSVC's link.exe requires each function declaration to have a Comdat section\n// So rather than litter the code with conditionals,\n// all global values that get emitted call this function\n// and it decides whether the definition needs a Comdat section and adds the appropriate declaration\n// TODO: consider moving this into jl_add_to_shadow or jl_dump_shadow? the JIT doesn't care, so most calls are now no-ops\ntemplate<class T> // for GlobalObject's\nstatic T *addComdat(T *G)\n{\n#if defined(_OS_WINDOWS_)\n    if (imaging_mode && !G->isDeclaration()) {\n        // Add comdat information to make MSVC link.exe happy\n        // it's valid to emit this for ld.exe too,\n        // but makes it very slow to link for no benefit\n        if (G->getParent() == shadow_output) {\n#if defined(_COMPILER_MICROSOFT_)\n            Comdat *jl_Comdat = G->getParent()->getOrInsertComdat(G->getName());\n            // ELF only supports Comdat::Any\n            jl_Comdat->setSelectionKind(Comdat::NoDuplicates);\n            G->setComdat(jl_Comdat);\n#endif\n#if defined(_CPU_X86_64_)\n            // Add unwind exception personalities to functions to handle async exceptions\n            assert(!juliapersonality_func || juliapersonality_func->getParent() == shadow_output);\n            if (Function *F = dyn_cast<Function>(G))\n                F->setPersonalityFn(juliapersonality_func);\n#endif\n        }\n        // add __declspec(dllexport) to everything marked for export\n        if (G->getLinkage() == GlobalValue::ExternalLinkage)\n            G->setDLLStorageClass(GlobalValue::DLLExportStorageClass);\n        else\n            G->setDLLStorageClass(GlobalValue::DefaultStorageClass);\n    }\n#endif\n    return G;\n}\n\n// destructively move the contents of src into dest\n// this assumes that the targets of the two modules are the same\n// including the DataLayout and ModuleFlags (for example)\n// and that there is no module-level assembly\nstatic void jl_merge_module(Module *dest, std::unique_ptr<Module> src)\n{\n    assert(dest != src.get());\n    for (Module::global_iterator I = src->global_begin(), E = src->global_end(); I != E;) {\n        GlobalVariable *sG = &*I;\n        GlobalValue *dG = dest->getNamedValue(sG->getName());\n        ++I;\n        // Replace a declaration with the definition:\n        if (dG) {\n            if (sG->isDeclaration()) {\n                sG->replaceAllUsesWith(dG);\n                sG->eraseFromParent();\n                continue;\n            }\n            else {\n                dG->replaceAllUsesWith(sG);\n                dG->eraseFromParent();\n            }\n        }\n        // Reparent the global variable:\n        sG->removeFromParent();\n        dest->getGlobalList().push_back(sG);\n        // Comdat is owned by the Module, recreate it in the new parent:\n        addComdat(sG);\n    }\n\n    for (Module::iterator I = src->begin(), E = src->end(); I != E;) {\n        Function *sG = &*I;\n        GlobalValue *dG = dest->getNamedValue(sG->getName());\n        ++I;\n        // Replace a declaration with the definition:\n        if (dG) {\n            if (sG->isDeclaration()) {\n                sG->replaceAllUsesWith(dG);\n                sG->eraseFromParent();\n                continue;\n            }\n            else {\n                dG->replaceAllUsesWith(sG);\n                dG->eraseFromParent();\n            }\n        }\n        // Reparent the global variable:\n        sG->removeFromParent();\n        dest->getFunctionList().push_back(sG);\n        // Comdat is owned by the Module, recreate it in the new parent:\n        addComdat(sG);\n    }\n\n    for (Module::alias_iterator I = src->alias_begin(), E = src->alias_end(); I != E;) {\n        GlobalAlias *sG = &*I;\n        GlobalValue *dG = dest->getNamedValue(sG->getName());\n        ++I;\n        if (dG) {\n            if (!dG->isDeclaration()) { // aliases are always definitions, so this test is reversed from the above two\n                sG->replaceAllUsesWith(dG);\n                sG->eraseFromParent();\n                continue;\n            }\n            else {\n                dG->replaceAllUsesWith(sG);\n                dG->eraseFromParent();\n            }\n        }\n        sG->removeFromParent();\n        dest->getAliasList().push_back(sG);\n    }\n\n    // metadata nodes need to be explicitly merged not just copied\n    // so there are special passes here for each known type of metadata\n    NamedMDNode *sNMD = src->getNamedMetadata(\"llvm.dbg.cu\");\n    if (sNMD) {\n        NamedMDNode *dNMD = dest->getOrInsertNamedMetadata(\"llvm.dbg.cu\");\n        for (NamedMDNode::op_iterator I = sNMD->op_begin(), E = sNMD->op_end(); I != E; ++I) {\n            dNMD->addOperand(*I);\n        }\n    }\n}\n\n// to finalize a function, look up its name in the `module_for_fname` map of\n// unfinalized functions and merge it, plus any other modules it depends upon,\n// into `collector` then add `collector` to the execution engine\nstatic StringMap<Module*> module_for_fname;\nstatic void jl_merge_recursive(Module *m, Module *collector);\n\nstatic void jl_add_to_ee(std::unique_ptr<Module> m)\n{\n#if defined(_CPU_X86_64_) && defined(_OS_WINDOWS_)\n    // Add special values used by debuginfo to build the UnwindData table registration for Win64\n    ArrayType *atype = ArrayType::get(T_uint32, 3); // want 4-byte alignment of 12-bytes of data\n    (new GlobalVariable(*m, atype,\n        false, GlobalVariable::InternalLinkage,\n        ConstantAggregateZero::get(atype), \"__UnwindData\"))->setSection(\".text\");\n    (new GlobalVariable(*m, atype,\n        false, GlobalVariable::InternalLinkage,\n        ConstantAggregateZero::get(atype), \"__catchjmp\"))->setSection(\".text\");\n#endif\n    assert(jl_ExecutionEngine);\n    jl_ExecutionEngine->addModule(std::move(m));\n}\n\nvoid jl_finalize_function(StringRef F)\n{\n    std::unique_ptr<Module> m(module_for_fname.lookup(F));\n    if (m) {\n        jl_merge_recursive(m.get(), m.get());\n        jl_add_to_ee(std::move(m));\n    }\n}\n\nstatic void jl_finalize_function(const std::string &F, Module *collector)\n{\n    std::unique_ptr<Module> m(module_for_fname.lookup(F));\n    if (m) {\n        jl_merge_recursive(m.get(), collector);\n        jl_merge_module(collector, std::move(m));\n    }\n}\n\nstatic void jl_merge_recursive(Module *m, Module *collector)\n{\n    // probably not many unresolved declarations, but be sure to iterate over their Names,\n    // since the declarations may get destroyed by the jl_merge_module call.\n    // this is also why we copy the Name string, rather than save a StringRef\n    SmallVector<std::string, 8> to_finalize;\n    for (Module::iterator I = m->begin(), E = m->end(); I != E; ++I) {\n        Function *F = &*I;\n        if (!F->isDeclaration()) {\n            module_for_fname.erase(F->getName());\n        }\n        else if (!isIntrinsicFunction(F)) {\n            to_finalize.push_back(F->getName().str());\n        }\n    }\n\n    for (const auto F : to_finalize) {\n        jl_finalize_function(F, collector);\n    }\n}\n\n// see if any of the functions needed by F are still WIP\nstatic StringSet<> incomplete_fname;\nstatic bool can_finalize_function(StringRef F, SmallSet<Module*, 16> &known)\n{\n    if (incomplete_fname.find(F) != incomplete_fname.end())\n        return false;\n    Module *M = module_for_fname.lookup(F);\n    if (M && known.insert(M).second) {\n        for (Module::iterator I = M->begin(), E = M->end(); I != E; ++I) {\n            Function *F = &*I;\n            if (F->isDeclaration() && !isIntrinsicFunction(F)) {\n                if (!can_finalize_function(F->getName(), known))\n                    return false;\n            }\n        }\n    }\n    return true;\n}\nbool jl_can_finalize_function(StringRef F)\n{\n    SmallSet<Module*, 16> known;\n    return can_finalize_function(F, known);\n}\n\n// let the JIT know this function is a WIP\nvoid jl_init_function(Function *F)\n{\n    incomplete_fname.insert(F->getName());\n}\n\n// this takes ownership of a module after code emission is complete\n// and will add it to the execution engine when required (by jl_finalize_function)\nvoid jl_finalize_module(Module *m, bool shadow)\n{\n    // record the function names that are part of this Module\n    // so it can be added to the JIT when needed\n    for (Module::iterator I = m->begin(), E = m->end(); I != E; ++I) {\n        Function *F = &*I;\n        if (!F->isDeclaration()) {\n            bool known = incomplete_fname.erase(F->getName());\n            (void)known; // TODO: assert(known); // llvmcall gets this wrong\n            module_for_fname[F->getName()] = m;\n        }\n    }\n    // in the newer JITs, the shadow module is separate from the execution module\n    if (shadow)\n        jl_add_to_shadow(m);\n}\n\n// helper function for adding a DLLImport (dlsym) address to the execution engine\n// (for values created locally or in the sysimage, jl_emit_and_add_to_shadow is generally preferable)\nvoid add_named_global(GlobalObject *gv, void *addr, bool dllimport)\n{\n#ifdef _OS_WINDOWS_\n    // setting JL_DLLEXPORT correctly only matters when building a binary\n    // (global_proto will strip this from the JIT)\n    if (dllimport && imaging_mode) {\n        assert(gv->getLinkage() == GlobalValue::ExternalLinkage);\n        // add the __declspec(dllimport) attribute\n        gv->setDLLStorageClass(GlobalValue::DLLImportStorageClass);\n    }\n#endif // _OS_WINDOWS_\n\n    jl_ExecutionEngine->addGlobalMapping(gv, addr);\n}\n\nstatic std::vector<GlobalValue*> jl_sysimg_gvars;\nstatic std::vector<GlobalValue*> jl_sysimg_fvars;\nstatic std::map<void*, jl_value_llvm> jl_value_to_llvm;\n\n// global variables to pointers are pretty common,\n// so this method is available as a convenience for emitting them.\n// for other types, the formula for implementation is straightforward:\n// (see stringConstPtr, for an alternative example to the code below)\n//\n// if in imaging_mode, emit a GlobalVariable with the same name and an initializer to the shadow_module\n// making it valid for emission and reloading in the sysimage\n//\n// then add a global mapping to the current value (usually from calloc'd space)\n// to the execution engine to make it valid for the current session (with the current value)\nvoid* jl_emit_and_add_to_shadow(GlobalVariable *gv, void *gvarinit)\n{\n    PointerType *T = cast<PointerType>(gv->getType()->getElementType()); // pointer is the only supported type here\n\n    GlobalVariable *shadowvar = NULL;\n    if (imaging_mode)\n        shadowvar = global_proto(gv, shadow_output);\n\n    if (shadowvar) {\n        shadowvar->setInitializer(ConstantPointerNull::get(T));\n        shadowvar->setLinkage(GlobalVariable::InternalLinkage);\n        addComdat(shadowvar);\n        if (imaging_mode && gvarinit) {\n            // make the pointer valid for future sessions\n            jl_sysimg_gvars.push_back(shadowvar);\n            jl_value_llvm gv_struct;\n            gv_struct.gv = global_proto(gv);\n            gv_struct.index = jl_sysimg_gvars.size();\n            jl_value_to_llvm[gvarinit] = gv_struct;\n        }\n    }\n\n    // make the pointer valid for this session\n    void *slot = calloc(1, sizeof(void*));\n    jl_ExecutionEngine->addGlobalMapping(gv, slot);\n    return slot;\n}\n\nvoid* jl_get_globalvar(GlobalVariable *gv)\n{\n    void *p = (void*)(intptr_t)jl_ExecutionEngine->getPointerToGlobalIfAvailable(gv);\n    assert(p);\n    return p;\n}\n\n// clones the contents of the module `m` to the shadow_output collector\nvoid jl_add_to_shadow(Module *m)\n{\n#ifndef KEEP_BODIES\n    if (!imaging_mode && !jl_options.outputjitbc)\n        return;\n#endif\n    ValueToValueMapTy VMap;\n    std::unique_ptr<Module> clone(CloneModule(m, VMap));\n    for (Module::iterator I = clone->begin(), E = clone->end(); I != E; ++I) {\n        Function *F = &*I;\n        if (!F->isDeclaration()) {\n            F->setLinkage(Function::InternalLinkage);\n            addComdat(F);\n        }\n    }\n    jl_merge_module(shadow_output, std::move(clone));\n}\n\nstatic void emit_offset_table(Module *mod, const std::vector<GlobalValue*> &vars, StringRef name)\n{\n    // Emit a global variable with all the variable addresses.\n    // The cloning pass will convert them into offsets.\n    assert(!vars.empty());\n    size_t nvars = vars.size();\n    std::vector<Constant*> addrs(nvars);\n    for (size_t i = 0; i < nvars; i++)\n        addrs[i] = ConstantExpr::getBitCast(vars[i], T_psize);\n    ArrayType *vars_type = ArrayType::get(T_psize, nvars);\n    new GlobalVariable(*mod, vars_type, true,\n                       GlobalVariable::ExternalLinkage,\n                       ConstantArray::get(vars_type, addrs),\n                       name);\n}\n\nstatic void emit_result(std::vector<NewArchiveMember> &Archive, SmallVectorImpl<char> &OS,\n        StringRef Name, std::vector<std::string> &outputs)\n{\n    outputs.push_back({ OS.data(), OS.size() });\n    Archive.push_back(NewArchiveMember(MemoryBufferRef(outputs.back(), Name)));\n    OS.clear();\n}\n\nstatic object::Archive::Kind getDefaultForHost(Triple &triple) {\n      if (triple.isOSDarwin())\n#if JL_LLVM_VERSION >= 50000\n          return object::Archive::K_DARWIN;\n#else\n          return object::Archive::K_BSD;\n#endif\n      return object::Archive::K_GNU;\n}\n\n#if JL_LLVM_VERSION >= 60000\ntypedef Error ArchiveWriterError;\n#else\ntypedef std::pair<StringRef, std::error_code> ArchiveWriterError;\ntemplate<typename HandlerT>\nstatic void handleAllErrors(ArchiveWriterError E, HandlerT Handler) {\n    if (E.second)\n        Handler(E);\n}\n#endif\n#if JL_LLVM_VERSION >= 60000\nstatic void reportWriterError(const ErrorInfoBase &E) {\n    std::string err = E.message();\n    jl_safe_printf(\"ERROR: failed to emit output file %s\\n\", err.c_str());\n}\n#else\nstatic void reportWriterError(ArchiveWriterError E) {\n    std::string ContextStr = E.first.str();\n    std::string err;\n    if (!ContextStr.empty())\n        err += ContextStr + \": \";\n    err += E.second.message();\n    jl_safe_printf(\"ERROR: failed to emit output file %s\\n\", err.c_str());\n}\n#endif\n\n// takes the running content that has collected in the shadow module and dump it to disk\n// this builds the object file portion of the sysimage files for fast startup\nextern \"C\"\nvoid jl_dump_native(const char *bc_fname, const char *unopt_bc_fname, const char *obj_fname, const char *sysimg_data, size_t sysimg_len)\n{\n    JL_TIMING(NATIVE_DUMP);\n    // We don't want to use MCJIT's target machine because\n    // it uses the large code model and we may potentially\n    // want less optimizations there.\n    Triple TheTriple = Triple(jl_TargetMachine->getTargetTriple());\n    // make sure to emit the native object format, even if FORCE_ELF was set in codegen\n#if defined(_OS_WINDOWS_)\n    TheTriple.setObjectFormat(Triple::COFF);\n#elif defined(_OS_DARWIN_)\n    TheTriple.setObjectFormat(Triple::MachO);\n    TheTriple.setOS(llvm::Triple::MacOSX);\n#endif\n    std::unique_ptr<TargetMachine>\n    TM(jl_TargetMachine->getTarget().createTargetMachine(\n        TheTriple.getTriple(),\n        jl_TargetMachine->getTargetCPU(),\n        jl_TargetMachine->getTargetFeatureString(),\n        jl_TargetMachine->Options,\n#if defined(_OS_LINUX_) || defined(_OS_FREEBSD_)\n        Reloc::PIC_,\n#else\n        Optional<Reloc::Model>(),\n#endif\n#if defined(_CPU_PPC_) || defined(_CPU_PPC64_)\n        // On PPC the small model is limited to 16bit offsets\n        CodeModel::Medium,\n#else\n        // Use small model so that we can use signed 32bits offset in the function and GV tables\n        CodeModel::Small,\n#endif\n        CodeGenOpt::Aggressive // -O3 TODO: respect command -O0 flag?\n        ));\n\n    legacy::PassManager PM;\n    addTargetPasses(&PM, TM.get());\n\n    // set up optimization passes\n    SmallVector<char, 128> bc_Buffer;\n    SmallVector<char, 128> obj_Buffer;\n    SmallVector<char, 128> unopt_bc_Buffer;\n    raw_svector_ostream bc_OS(bc_Buffer);\n    raw_svector_ostream obj_OS(obj_Buffer);\n    raw_svector_ostream unopt_bc_OS(unopt_bc_Buffer);\n    std::vector<NewArchiveMember> bc_Archive;\n    std::vector<NewArchiveMember> obj_Archive;\n    std::vector<NewArchiveMember> unopt_bc_Archive;\n    std::vector<std::string> outputs;\n\n    if (unopt_bc_fname)\n        PM.add(createBitcodeWriterPass(unopt_bc_OS));\n    if (bc_fname || obj_fname)\n        addOptimizationPasses(&PM, jl_options.opt_level, true);\n    if (bc_fname)\n        PM.add(createBitcodeWriterPass(bc_OS));\n    if (obj_fname)\n        if (TM->addPassesToEmitFile(PM, obj_OS, TargetMachine::CGFT_ObjectFile, false))\n            jl_safe_printf(\"ERROR: target does not support generation of object files\\n\");\n\n    // Reset the target triple to make sure it matches the new target machine\n    shadow_output->setTargetTriple(TM->getTargetTriple().str());\n#if JL_LLVM_VERSION >= 40000\n    DataLayout DL = TM->createDataLayout();\n    DL.reset(DL.getStringRepresentation() + \"-ni:10:11:12:13\");\n    shadow_output->setDataLayout(DL);\n#else\n    shadow_output->setDataLayout(TM->createDataLayout());\n#endif\n\n    // add metadata information\n    if (imaging_mode) {\n        emit_offset_table(shadow_output, jl_sysimg_gvars, \"jl_sysimg_gvars\");\n        emit_offset_table(shadow_output, jl_sysimg_fvars, \"jl_sysimg_fvars\");\n\n        // reflect the address of the jl_RTLD_DEFAULT_handle variable\n        // back to the caller, so that we can check for consistency issues\n        GlobalValue *jlRTLD_DEFAULT_var = shadow_output->getNamedValue(\"jl_RTLD_DEFAULT_handle\");\n        addComdat(new GlobalVariable(*shadow_output,\n                                     jlRTLD_DEFAULT_var->getType(),\n                                     true,\n                                     GlobalVariable::ExternalLinkage,\n                                     jlRTLD_DEFAULT_var,\n                                     \"jl_RTLD_DEFAULT_handle_pointer\"));\n    }\n\n    // do the actual work\n    auto add_output = [&] (Module &M, StringRef unopt_bc_Name, StringRef bc_Name, StringRef obj_Name) {\n        PM.run(M);\n        if (unopt_bc_fname)\n            emit_result(unopt_bc_Archive, unopt_bc_Buffer, unopt_bc_Name, outputs);\n        if (bc_fname)\n            emit_result(bc_Archive, bc_Buffer, bc_Name, outputs);\n        if (obj_fname)\n            emit_result(obj_Archive, obj_Buffer, obj_Name, outputs);\n    };\n\n    add_output(*shadow_output, \"unopt.bc\", \"text.bc\", \"text.o\");\n    // save some memory, by deleting all of the function bodies\n    for (auto &F : shadow_output->functions()) {\n        if (!F.isDeclaration())\n            F.deleteBody();\n    }\n\n    LLVMContext &Context = shadow_output->getContext();\n    std::unique_ptr<Module> sysimage(new Module(\"sysimage\", Context));\n    sysimage->setTargetTriple(shadow_output->getTargetTriple());\n    sysimage->setDataLayout(shadow_output->getDataLayout());\n\n    addComdat(new GlobalVariable(*sysimage,\n                                 T_size,\n                                 true,\n                                 GlobalVariable::ExternalLinkage,\n                                 ConstantInt::get(T_size, globalUnique + 1),\n                                 \"jl_globalUnique\"));\n\n    if (sysimg_data) {\n        Constant *data = ConstantDataArray::get(Context,\n            ArrayRef<uint8_t>((const unsigned char*)sysimg_data, sysimg_len));\n        addComdat(new GlobalVariable(*sysimage, data->getType(), false,\n                                     GlobalVariable::ExternalLinkage,\n                                     data, \"jl_system_image_data\"))->setAlignment(64);\n        Constant *len = ConstantInt::get(T_size, sysimg_len);\n        addComdat(new GlobalVariable(*sysimage, len->getType(), true,\n                                     GlobalVariable::ExternalLinkage,\n                                     len, \"jl_system_image_size\"));\n    }\n    add_output(*sysimage, \"data.bc\", \"data.bc\", \"data.o\");\n\n    object::Archive::Kind Kind = getDefaultForHost(TheTriple);\n    if (unopt_bc_fname)\n        handleAllErrors(writeArchive(unopt_bc_fname, unopt_bc_Archive, true,\n                    Kind, true, false), reportWriterError);\n    if (bc_fname)\n        handleAllErrors(writeArchive(bc_fname, bc_Archive, true,\n                    Kind, true, false), reportWriterError);\n    if (obj_fname)\n        handleAllErrors(writeArchive(obj_fname, obj_Archive, true,\n                    Kind, true, false), reportWriterError);\n\n    imaging_mode = false;\n}\n\nextern \"C\" int32_t jl_assign_functionID(const char *fname)\n{\n    // give the function an index in the constant lookup table\n    assert(imaging_mode);\n    if (fname == NULL)\n        return 0;\n    jl_sysimg_fvars.push_back(shadow_output->getNamedValue(fname));\n    return jl_sysimg_fvars.size();\n}\n\nextern \"C\" int32_t jl_get_llvm_gv(jl_value_t *p)\n{\n    // map a jl_value_t memory location to a GlobalVariable\n    std::map<void*, jl_value_llvm>::iterator it;\n    it = jl_value_to_llvm.find(p);\n    if (it == jl_value_to_llvm.end())\n        return 0;\n    return it->second.index;\n}\n\nGlobalVariable *jl_get_global_for(const char *cname, void *addr, Module *M)\n{\n    // emit a GlobalVariable for a jl_value_t named \"cname\"\n    std::map<void*, jl_value_llvm>::iterator it;\n    // first see if there already is a GlobalVariable for this address\n    it = jl_value_to_llvm.find(addr);\n    if (it != jl_value_to_llvm.end())\n        return prepare_global_in(M, (llvm::GlobalVariable*)it->second.gv);\n\n    std::stringstream gvname;\n    gvname << cname << globalUnique++;\n    // no existing GlobalVariable, create one and store it\n    GlobalVariable *gv = new GlobalVariable(*M, T_pjlvalue,\n                           false, GlobalVariable::ExternalLinkage,\n                           NULL, gvname.str());\n    *(void**)jl_emit_and_add_to_shadow(gv, addr) = addr;\n    return gv;\n}\n\n// An LLVM module pass that just runs all julia passes in order. Useful for\n// debugging\nextern \"C\" void jl_init_codegen(void);\ntemplate <int OptLevel>\nclass JuliaPipeline : public Pass {\npublic:\n    static char ID;\n    // A bit of a hack, but works\n    struct TPMAdapter : public PassManagerBase {\n        PMTopLevelManager *TPM;\n        TPMAdapter(PMTopLevelManager *TPM) : TPM(TPM) {}\n        void add(Pass *P) { TPM->schedulePass(P); }\n    };\n    void preparePassManager(PMStack &Stack) override {\n        (void)jl_init_llvm();\n        PMTopLevelManager *TPM = Stack.top()->getTopLevelManager();\n        TPMAdapter Adapter(TPM);\n        addTargetPasses(&Adapter, jl_TargetMachine);\n        addOptimizationPasses(&Adapter, OptLevel);\n    }\n    JuliaPipeline() : Pass(PT_PassManager, ID) {}\n    Pass *createPrinterPass(raw_ostream &O, const std::string &Banner) const override {\n        return createPrintModulePass(O, Banner);\n    }\n};\ntemplate<> char JuliaPipeline<0>::ID = 0;\ntemplate<> char JuliaPipeline<2>::ID = 0;\ntemplate<> char JuliaPipeline<3>::ID = 0;\nstatic RegisterPass<JuliaPipeline<0>> X(\"juliaO0\", \"Runs the entire julia pipeline (at -O0)\", false, false);\nstatic RegisterPass<JuliaPipeline<2>> Y(\"julia\", \"Runs the entire julia pipeline (at -O2)\", false, false);\nstatic RegisterPass<JuliaPipeline<3>> Z(\"juliaO3\", \"Runs the entire julia pipeline (at -O3)\", false, false);\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/src/processor.cpp": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n// Processor feature detection\n\n#include \"processor.h\"\n\n#include \"julia.h\"\n#include \"julia_internal.h\"\n\n#include <map>\n#include <algorithm>\n\n#include \"llvm-version.h\"\n#include <llvm/ADT/StringRef.h>\n#include <llvm/Support/MathExtras.h>\n\n#include \"julia_assert.h\"\n\n// CPU target string is a list of strings separated by `;` each string starts with a CPU\n// or architecture name and followed by an optional list of features separated by `,`.\n// A \"generic\" or empty CPU name means the basic required feature set of the target ISA\n// which is at least the architecture the C/C++ runtime is compiled with.\n\n// CPU dispatch needs to determine the version to be used by the sysimg as well as\n// the target and feature used by the JIT. Currently the only limitation on JIT target\n// and feature is matching register size between the sysimg and JIT so that SIMD vectors\n// can be passed correctly. This means disabling AVX and AVX2 if AVX was not enabled\n// in sysimg and disabling AVX512 if it was not enabled in sysimg.\n// This also possibly means that SVE needs to be disabled on AArch64 if sysimg doesn't have it\n// enabled.\n\n// CPU dispatch starts by first deciding the max feature set and CPU requested for JIT.\n// This is the host or the target specified on the command line with features unavailable\n// on the host disabled. All sysimg targets that require features not available in this set\n// will be ignored.\n\n// The next step is matching CPU name.\n// If exact name match with compatible feature set exists, all versions without name match\n// are ignored.\n// This step will query LLVM first so it can accept CPU names that is recognized by LLVM but\n// not by us (yet) when LLVM is enabled.\n\n// If there are still more than one candidates, a feature match is performed.\n// The ones with the largest register size will be used\n// (i.e. AVX512 > AVX2/AVX > SSE, SVE > ASIMD). If there's a tie, the one with the most features\n// enabled will be used. If there's still a tie the one that appears later in the list will be\n// used. (i.e. the order in the version list is significant in this case).\n\n// Features that are not recognized will be passed to LLVM directly during codegen\n// but ignored otherwise.\n\n// A few special features are supported:\n// 1. `clone_all`\n//\n//     This forces the target to have all functions in sysimg cloned.\n//     When used in negative form (i.e. `-clone_all`), this disables full clone that's\n//     enabled by default for certain targets.\n//\n// 2. `base([0-9]*)`\n//\n//     This specifies the (0-based) base target index. The base target is the target\n//     that the current target is based on, i.e. the functions that are not being cloned\n//     will use the version in the base target. This option causes the base target to be\n//     fully cloned (as if `clone_all` is specified for it) if it is not the default target (0).\n//     The index can only be smaller than the current index.\n//\n// 3. `opt_size`\n//\n//     Optimize for size with minimum performance impact. Clang/GCC's `-Os`.\n//\n// 4. `min_size`\n//\n//     Optimize only for size. Clang's `-Oz`.\n\nbool jl_processor_print_help = false;\n\nnamespace {\n\n// Helper functions to test/set feature bits\n\ntemplate<typename T1, typename T2, typename T3>\nstatic inline bool test_bits(T1 v, T2 mask, T3 test)\n{\n    return T3(v & mask) == test;\n}\n\ntemplate<typename T1, typename T2>\nstatic inline bool test_all_bits(T1 v, T2 mask)\n{\n    return test_bits(v, mask, mask);\n}\n\ntemplate<typename T1, typename T2>\nstatic inline bool test_nbit(const T1 &bits, T2 _bitidx)\n{\n    auto bitidx = static_cast<uint32_t>(_bitidx);\n    auto u32idx = bitidx / 32;\n    auto bit = bitidx % 32;\n    return (bits[u32idx] & (1 << bit)) != 0;\n}\n\ntemplate<typename T>\nstatic inline void unset_bits(T &bits)\n{\n    (void)bits;\n}\n\ntemplate<typename T, typename T1, typename... Rest>\nstatic inline void unset_bits(T &bits, T1 _bitidx, Rest... rest)\n{\n    auto bitidx = static_cast<uint32_t>(_bitidx);\n    auto u32idx = bitidx / 32;\n    auto bit = bitidx % 32;\n    bits[u32idx] = bits[u32idx] & ~uint32_t(1 << bit);\n    unset_bits(bits, rest...);\n}\n\ntemplate<typename T, typename T1>\nstatic inline void set_bit(T &bits, T1 _bitidx, bool val)\n{\n    auto bitidx = static_cast<uint32_t>(_bitidx);\n    auto u32idx = bitidx / 32;\n    auto bit = bitidx % 32;\n    if (val) {\n        bits[u32idx] = bits[u32idx] | uint32_t(1 << bit);\n    }\n    else {\n        bits[u32idx] = bits[u32idx] & ~uint32_t(1 << bit);\n    }\n}\n\n// Helper functions to create feature masks\n\n// This can be `std::array<uint32_t,n>` on C++14\ntemplate<size_t n>\nstruct FeatureList {\n    uint32_t eles[n];\n    uint32_t &operator[](size_t pos)\n    {\n        return eles[pos];\n    }\n    constexpr const uint32_t &operator[](size_t pos) const\n    {\n        return eles[pos];\n    }\n    inline int nbits() const\n    {\n        int cnt = 0;\n        for (size_t i = 0; i < n; i++)\n            cnt += llvm::countPopulation(eles[i]);\n        return cnt;\n    }\n    inline bool empty() const\n    {\n        for (size_t i = 0; i < n; i++) {\n            if (eles[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nstatic inline constexpr uint32_t add_feature_mask_u32(uint32_t mask, uint32_t u32idx)\n{\n    return mask;\n}\n\ntemplate<typename T, typename... Rest>\nstatic inline constexpr uint32_t add_feature_mask_u32(uint32_t mask, uint32_t u32idx,\n                                                      T bit, Rest... args)\n{\n    return add_feature_mask_u32(mask | ((int(bit) >= 0 && int(bit) / 32 == (int)u32idx) ?\n                                        (1 << (int(bit) % 32)) : 0),\n                                u32idx, args...);\n}\n\ntemplate<typename... Args>\nstatic inline constexpr uint32_t get_feature_mask_u32(uint32_t u32idx, Args... args)\n{\n    return add_feature_mask_u32(uint32_t(0), u32idx, args...);\n}\n\ntemplate<uint32_t... Is> struct seq{};\ntemplate<uint32_t N, uint32_t... Is>\nstruct gen_seq : gen_seq<N-1, N-1, Is...>{};\ntemplate<uint32_t... Is>\nstruct gen_seq<0, Is...> : seq<Is...>{};\n\ntemplate<size_t n, uint32_t... I, typename... Args>\nstatic inline constexpr FeatureList<n>\n_get_feature_mask(seq<I...>, Args... args)\n{\n    return FeatureList<n>{{get_feature_mask_u32(I, args...)...}};\n}\n\ntemplate<size_t n, typename... Args>\nstatic inline constexpr FeatureList<n> get_feature_masks(Args... args)\n{\n    return _get_feature_mask<n>(gen_seq<n>(), args...);\n}\n\ntemplate<size_t n, uint32_t... I>\nstatic inline constexpr FeatureList<n>\n_feature_mask_or(seq<I...>, const FeatureList<n> &a, const FeatureList<n> &b)\n{\n    return FeatureList<n>{{(a[I] | b[I])...}};\n}\n\ntemplate<size_t n>\nstatic inline constexpr FeatureList<n> operator|(const FeatureList<n> &a, const FeatureList<n> &b)\n{\n    return _feature_mask_or<n>(gen_seq<n>(), a, b);\n}\n\ntemplate<size_t n, uint32_t... I>\nstatic inline constexpr FeatureList<n>\n_feature_mask_and(seq<I...>, const FeatureList<n> &a, const FeatureList<n> &b)\n{\n    return FeatureList<n>{{(a[I] & b[I])...}};\n}\n\ntemplate<size_t n>\nstatic inline constexpr FeatureList<n> operator&(const FeatureList<n> &a, const FeatureList<n> &b)\n{\n    return _feature_mask_and<n>(gen_seq<n>(), a, b);\n}\n\ntemplate<size_t n, uint32_t... I>\nstatic inline constexpr FeatureList<n>\n_feature_mask_not(seq<I...>, const FeatureList<n> &a)\n{\n    return FeatureList<n>{{(~a[I])...}};\n}\n\ntemplate<size_t n>\nstatic inline constexpr FeatureList<n> operator~(const FeatureList<n> &a)\n{\n    return _feature_mask_not<n>(gen_seq<n>(), a);\n}\n\ntemplate<size_t n>\nstatic inline void mask_features(const FeatureList<n> masks, uint32_t *features)\n{\n    for (size_t i = 0; i < n; i++) {\n        features[i] = features[i] & masks[i];\n    }\n}\n\n// Turn feature list to a string the LLVM accept\nstatic inline std::string join_feature_strs(const std::vector<std::string> &strs)\n{\n    size_t nstr = strs.size();\n    if (!nstr)\n        return std::string(\"\");\n    std::string str = strs[0];\n    for (size_t i = 1; i < nstr; i++)\n        str += ',' + strs[i];\n    return str;\n}\n\nstatic inline void append_ext_features(std::string &features, const std::string &ext_features)\n{\n    if (ext_features.empty())\n        return;\n    if (!features.empty())\n        features.push_back(',');\n    features.append(ext_features);\n}\n\nstatic inline void append_ext_features(std::vector<std::string> &features,\n                                       const std::string &ext_features)\n{\n    if (ext_features.empty())\n        return;\n    const char *start = ext_features.c_str();\n    const char *p = start;\n    for (; *p; p++) {\n        if (*p == ',') {\n            features.emplace_back(start, p - start);\n            start = p + 1;\n        }\n    }\n    if (p > start) {\n        features.emplace_back(start, p - start);\n    }\n}\n\n/**\n * Target specific type/constant definitions, always enable.\n */\n\nstruct FeatureName {\n    const char *name;\n    uint32_t bit; // bit index into a `uint32_t` array;\n    uint32_t llvmver; // 0 if it is available on the oldest LLVM version we support\n};\n\ntemplate<typename CPU, size_t n>\nstruct CPUSpec {\n    const char *name;\n    CPU cpu;\n    CPU fallback;\n    uint32_t llvmver;\n    FeatureList<n> features;\n};\n\nstruct FeatureDep {\n    uint32_t feature;\n    uint32_t dep;\n};\n\n// Recursively enable all features that the current feature set depends on.\ntemplate<size_t n>\nstatic inline void enable_depends(FeatureList<n> &features, const FeatureDep *deps, size_t ndeps)\n{\n    bool changed = true;\n    while (changed) {\n        changed = false;\n        for (ssize_t i = ndeps - 1; i >= 0; i--) {\n            auto &dep = deps[i];\n            if (!test_nbit(features, dep.feature) || test_nbit(features, dep.dep))\n                continue;\n            set_bit(features, dep.dep, true);\n            changed = true;\n        }\n    }\n}\n\n// Recursively disable all features that the current feature set does not provide.\ntemplate<size_t n>\nstatic inline void disable_depends(FeatureList<n> &features, const FeatureDep *deps, size_t ndeps)\n{\n    bool changed = true;\n    while (changed) {\n        changed = false;\n        for (ssize_t i = ndeps - 1; i >= 0; i--) {\n            auto &dep = deps[i];\n            if (!test_nbit(features, dep.feature) || test_nbit(features, dep.dep))\n                continue;\n            unset_bits(features, dep.feature);\n            changed = true;\n        }\n    }\n}\n\ntemplate<typename CPU, size_t n>\nstatic const CPUSpec<CPU,n> *find_cpu(uint32_t cpu, const CPUSpec<CPU,n> *cpus, uint32_t ncpus)\n{\n    for (uint32_t i = 0; i < ncpus; i++) {\n        if (cpu == uint32_t(cpus[i].cpu)) {\n            return &cpus[i];\n        }\n    }\n    return nullptr;\n}\n\ntemplate<typename CPU, size_t n>\nstatic const CPUSpec<CPU,n> *find_cpu(llvm::StringRef name, const CPUSpec<CPU,n> *cpus,\n                                      uint32_t ncpus)\n{\n    for (uint32_t i = 0; i < ncpus; i++) {\n        if (name == cpus[i].name) {\n            return &cpus[i];\n        }\n    }\n    return nullptr;\n}\n\ntemplate<typename CPU, size_t n>\nstatic const char *find_cpu_name(uint32_t cpu, const CPUSpec<CPU,n> *cpus, uint32_t ncpus)\n{\n    if (auto *spec = find_cpu(cpu, cpus, ncpus))\n        return spec->name;\n    return \"generic\";\n}\n\nJL_UNUSED static uint32_t find_feature_bit(const FeatureName *features, size_t nfeatures,\n                                           const char *str, size_t len)\n{\n    for (size_t i = 0; i < nfeatures; i++) {\n        auto &feature = features[i];\n        if (strncmp(feature.name, str, len) == 0 && feature.name[len] == 0) {\n            return feature.bit;\n        }\n    }\n    return (uint32_t)-1;\n}\n\n// This is how we save the target identification.\n// CPU name is saved as string instead of binary data like features because\n// 1. CPU ID is less stable (they are not bound to hardware/OS API)\n// 2. We need to support CPU names that are not recognized by us and therefore doesn't have an ID\n// 3. CPU name is trivial to parse\nstatic inline std::vector<uint8_t> serialize_target_data(llvm::StringRef name,\n                                                         uint32_t nfeature,\n                                                         const uint32_t *features_en,\n                                                         const uint32_t *features_dis,\n                                                         llvm::StringRef ext_features)\n{\n    std::vector<uint8_t> res;\n    auto add_data = [&] (const void *data, size_t sz) {\n        size_t old_sz = res.size();\n        res.resize(old_sz + sz);\n        memcpy(&res[old_sz], data, sz);\n    };\n    add_data(&nfeature, 4);\n    add_data(features_en, 4 * nfeature);\n    add_data(features_dis, 4 * nfeature);\n    uint32_t namelen = name.size();\n    add_data(&namelen, 4);\n    add_data(name.data(), namelen);\n    uint32_t ext_features_len = ext_features.size();\n    add_data(&ext_features_len, 4);\n    add_data(ext_features.data(), ext_features_len);\n    return res;\n}\n\ntemplate<size_t n>\nstatic inline std::vector<uint8_t> serialize_target_data(llvm::StringRef name,\n                                                         const FeatureList<n> &features_en,\n                                                         const FeatureList<n> &features_dis,\n                                                         llvm::StringRef ext_features)\n{\n    return serialize_target_data(name, n, &features_en[0], &features_dis[0], ext_features);\n}\n\ntemplate<size_t n>\nstruct TargetData {\n    std::string name;\n    std::string ext_features;\n    struct {\n        FeatureList<n> features;\n        uint32_t flags;\n    } en, dis;\n    int base;\n};\n\n// In addition to the serialized data, the first `uint32_t` gives the number of targets saved\n// and each target has a `uint32_t` flag before the serialized target data.\ntemplate<size_t n>\nstatic inline std::vector<TargetData<n>> deserialize_target_data(const uint8_t *data)\n{\n    auto load_data = [&] (void *dest, size_t sz) {\n        memcpy(dest, data, sz);\n        data += sz;\n    };\n    auto load_string = [&] () {\n        uint32_t len;\n        load_data(&len, 4);\n        std::string res((const char*)data, len);\n        data += len;\n        return res;\n    };\n    uint32_t ntarget;\n    load_data(&ntarget, 4);\n    std::vector<TargetData<n>> res(ntarget);\n    for (uint32_t i = 0; i < ntarget; i++) {\n        auto &target = res[i];\n        load_data(&target.en.flags, 4);\n        target.dis.flags = 0;\n        // Starting serialized target data\n        uint32_t nfeature;\n        load_data(&nfeature, 4);\n        assert(nfeature == n);\n        load_data(&target.en.features[0], 4 * n);\n        load_data(&target.dis.features[0], 4 * n);\n        target.name = load_string();\n        target.ext_features = load_string();\n        target.base = 0;\n    }\n    return res;\n}\n\n// Try getting clone base argument. Return 1-based index. Return 0 if match failed.\nstatic inline int get_clone_base(const char *start, const char *end)\n{\n    const char *prefix = \"base(\";\n    const int prefix_len = strlen(prefix);\n    if (end - start <= prefix_len)\n        return 0;\n    if (memcmp(start, prefix, prefix_len) != 0)\n        return 0;\n    start += prefix_len;\n    if (*start > '9' || *start < '0')\n        return 0;\n    char *digit_end;\n    auto idx = strtol(start, &digit_end, 10);\n    if (idx < 0)\n        return 0;\n    if (*digit_end != ')' || digit_end + 1 != end)\n        return 0;\n    return (int)idx + 1;\n}\n\n// Parse cmdline string. This handles `clone_all` and `base` special features.\n// Other feature names will be passed to `feature_cb` for target dependent parsing.\ntemplate<size_t n, typename F>\nstatic inline std::vector<TargetData<n>>\nparse_cmdline(const char *option, F &&feature_cb)\n{\n    if (!option)\n        option = \"native\";\n    std::vector<TargetData<n>> res;\n    TargetData<n> arg{};\n    auto reset_arg = [&] {\n        res.push_back(arg);\n        arg.name.clear();\n        arg.ext_features.clear();\n        memset(&arg.en.features[0], 0, 4 * n);\n        memset(&arg.dis.features[0], 0, 4 * n);\n        arg.en.flags = 0;\n        arg.dis.flags = 0;\n    };\n    const char *start = option;\n    for (const char *p = option; ; p++) {\n        switch (*p) {\n        case ',':\n        case ';':\n        case '\\0': {\n            bool done = *p == '\\0';\n            bool next_target = *p == ';' || done;\n            if (arg.name.empty()) {\n                if (p == start)\n                    jl_error(\"Invalid target option: empty CPU name\");\n                arg.name.append(start, p - start);\n                if (arg.name == \"help\") {\n                    arg.name = \"native\";\n                    jl_processor_print_help = true;\n                }\n                start = p + 1;\n                if (next_target)\n                    reset_arg();\n                if (done)\n                    return res;\n                continue;\n            }\n            bool disable = false;\n            const char *full = start;\n            const char *fname = full;\n            start = p + 1;\n            if (*full == '-') {\n                disable = true;\n                fname++;\n            }\n            else if (*full == '+') {\n                fname++;\n            }\n            if (llvm::StringRef(fname, p - fname) == \"clone_all\") {\n                if (!disable) {\n                    arg.en.flags |= JL_TARGET_CLONE_ALL;\n                    arg.dis.flags &= ~JL_TARGET_CLONE_ALL;\n                }\n                else {\n                    arg.dis.flags |= JL_TARGET_CLONE_ALL;\n                    arg.en.flags &= ~JL_TARGET_CLONE_ALL;\n                }\n            }\n            else if (llvm::StringRef(fname, p - fname) == \"opt_size\") {\n                if (disable)\n                    jl_error(\"Invalid target option: disabled opt_size.\");\n                if (arg.en.flags & JL_TARGET_MINSIZE)\n                    jl_error(\"Conflicting target option: both opt_size and min_size are specified.\");\n                arg.en.flags |= JL_TARGET_OPTSIZE;\n            }\n            else if (llvm::StringRef(fname, p - fname) == \"min_size\") {\n                if (disable)\n                    jl_error(\"Invalid target option: disabled min_size.\");\n                if (arg.en.flags & JL_TARGET_OPTSIZE)\n                    jl_error(\"Conflicting target option: both opt_size and min_size are specified.\");\n                arg.en.flags |= JL_TARGET_MINSIZE;\n            }\n            else if (int base = get_clone_base(fname, p)) {\n                if (disable)\n                    jl_error(\"Invalid target option: disabled base index.\");\n                base -= 1;\n                if (base >= (int)res.size())\n                    jl_error(\"Invalid target option: base index must refer to a previous target.\");\n                if (res[base].dis.flags & JL_TARGET_CLONE_ALL ||\n                    !(res[base].en.flags & JL_TARGET_CLONE_ALL))\n                    jl_error(\"Invalid target option: base target must be clone_all.\");\n                arg.base = base;\n            }\n            else if (llvm::StringRef(fname, p - fname) == \"help\") {\n                jl_processor_print_help = true;\n            }\n            else {\n                FeatureList<n> &list = disable ? arg.dis.features : arg.en.features;\n                if (!feature_cb(fname, p - fname, list)) {\n                    if (!arg.ext_features.empty())\n                        arg.ext_features += ',';\n                    arg.ext_features += disable ? '-' : '+';\n                    arg.ext_features.append(fname, p - fname);\n                }\n            }\n            if (next_target)\n                reset_arg();\n            if (done) {\n                return res;\n            }\n        }\n            JL_FALLTHROUGH;\n        default:\n            continue;\n        }\n    }\n}\n\n// Cached version of command line parsing\ntemplate<size_t n, typename F>\nstatic inline std::vector<TargetData<n>> &get_cmdline_targets(F &&feature_cb)\n{\n    static std::vector<TargetData<n>> targets =\n        parse_cmdline<n>(jl_options.cpu_target, std::forward<F>(feature_cb));\n    return targets;\n}\n\n// Load sysimg, use the `callback` for dispatch and perform all relocations\n// for the selected target.\ntemplate<typename F>\nstatic inline jl_sysimg_fptrs_t parse_sysimg(void *hdl, F &&callback)\n{\n    jl_sysimg_fptrs_t res = {nullptr, 0, nullptr, 0, nullptr, nullptr};\n    // .data base\n    auto data_base = (char*)jl_dlsym(hdl, \"jl_sysimg_gvars_base\");\n    // .text base\n    res.base = (const char*)jl_dlsym(hdl, \"jl_sysimg_fvars_base\");\n    auto offsets = ((const int32_t*)jl_dlsym(hdl, \"jl_sysimg_fvars_offsets\")) + 1;\n    uint32_t nfunc = ((const uint32_t*)offsets)[-1];\n    res.offsets = offsets;\n\n    void *ids = jl_dlsym(hdl, \"jl_dispatch_target_ids\");\n    uint32_t target_idx = callback(ids);\n\n    auto reloc_slots = ((const int32_t*)jl_dlsym(hdl, \"jl_dispatch_reloc_slots\")) + 1;\n    auto nreloc = ((const uint32_t*)reloc_slots)[-1];\n    auto clone_idxs = (const uint32_t*)jl_dlsym(hdl, \"jl_dispatch_fvars_idxs\");\n    auto clone_offsets = (const int32_t*)jl_dlsym(hdl, \"jl_dispatch_fvars_offsets\");\n    uint32_t tag_len = clone_idxs[0];\n    clone_idxs += 1;\n    assert(tag_len & jl_sysimg_tag_mask);\n    std::vector<const int32_t*> base_offsets = {res.offsets};\n    // Find target\n    for (uint32_t i = 0;i < target_idx;i++) {\n        uint32_t len = jl_sysimg_val_mask & tag_len;\n        if (jl_sysimg_tag_mask & tag_len) {\n            if (i != 0)\n                clone_offsets += nfunc;\n            clone_idxs += len + 1;\n        }\n        else {\n            clone_offsets += len;\n            clone_idxs += len + 2;\n        }\n        tag_len = clone_idxs[-1];\n        base_offsets.push_back(tag_len & jl_sysimg_tag_mask ? clone_offsets : nullptr);\n    }\n\n    bool clone_all = (tag_len & jl_sysimg_tag_mask) != 0;\n    // Fill in return value\n    if (clone_all) {\n        // clone_all\n        if (target_idx != 0) {\n            res.offsets = clone_offsets;\n        }\n    }\n    else {\n        uint32_t base_idx = clone_idxs[0];\n        assert(base_idx < target_idx);\n        if (target_idx != 0) {\n            res.offsets = base_offsets[base_idx];\n            assert(res.offsets);\n        }\n        clone_idxs++;\n        res.nclones = tag_len;\n        res.clone_offsets = clone_offsets;\n        res.clone_idxs = clone_idxs;\n    }\n    // Do relocation\n    uint32_t reloc_i = 0;\n    uint32_t len = jl_sysimg_val_mask & tag_len;\n    for (uint32_t i = 0; i < len; i++) {\n        uint32_t idx = clone_idxs[i];\n        int32_t offset;\n        if (clone_all) {\n            offset = res.offsets[idx];\n        }\n        else if (idx & jl_sysimg_tag_mask) {\n            idx = idx & jl_sysimg_val_mask;\n            offset = clone_offsets[i];\n        }\n        else {\n            continue;\n        }\n        bool found = false;\n        for (; reloc_i < nreloc; reloc_i++) {\n            auto reloc_idx = ((const uint32_t*)reloc_slots)[reloc_i * 2];\n            if (reloc_idx == idx) {\n                found = true;\n                auto slot = (const void**)(data_base + reloc_slots[reloc_i * 2 + 1]);\n                *slot = offset + res.base;\n            }\n            else if (reloc_idx > idx) {\n                break;\n            }\n        }\n        assert(found && \"Cannot find GOT entry for cloned function.\");\n        (void)found;\n    }\n\n    return res;\n}\n\ntemplate<typename T>\nstatic inline void check_cmdline(T &&cmdline, bool imaging)\n{\n    assert(cmdline.size() > 0);\n    // It's unclear what does specifying multiple target when not generating\n    // sysimg means. Make it an error for now.\n    if (!imaging) {\n        if (cmdline.size() > 1) {\n            jl_error(\"More than one command line CPU targets specified \"\n                     \"without a `--output-` flag specified\");\n        }\n        if (cmdline[0].en.flags & JL_TARGET_CLONE_ALL) {\n            jl_error(\"\\\"clone_all\\\" feature specified \"\n                     \"without a `--output-` flag specified\");\n        }\n        if (cmdline[0].en.flags & JL_TARGET_OPTSIZE) {\n            jl_error(\"\\\"opt_size\\\" feature specified \"\n                     \"without a `--output-` flag specified\");\n        }\n        if (cmdline[0].en.flags & JL_TARGET_MINSIZE) {\n            jl_error(\"\\\"min_size\\\" feature specified \"\n                     \"without a `--output-` flag specified\");\n        }\n    }\n}\n\nstruct SysimgMatch {\n    uint32_t best_idx{(uint32_t)-1};\n    int vreg_size{0};\n};\n\n// Find the best match in the sysimg.\n// Select the best one based on the largest vector register and largest compatible feature set.\ntemplate<typename S, typename T, typename F>\nstatic inline SysimgMatch match_sysimg_targets(S &&sysimg, T &&target, F &&max_vector_size)\n{\n    SysimgMatch match;\n    bool match_name = false;\n    int feature_size = 0;\n    for (uint32_t i = 0; i < sysimg.size(); i++) {\n        auto &imgt = sysimg[i];\n        if (!(imgt.en.features & target.dis.features).empty()) {\n            // Check sysimg enabled features against runtime disabled features\n            // This is valid (and all what we can do)\n            // even if one or both of the targets are unknown.\n            continue;\n        }\n        if (imgt.name == target.name) {\n            if (!match_name) {\n                match_name = true;\n                match.vreg_size = 0;\n                feature_size = 0;\n            }\n        }\n        else if (match_name) {\n            continue;\n        }\n        int new_vsz = max_vector_size(imgt.en.features);\n        if (match.vreg_size > new_vsz)\n            continue;\n        int new_feature_size = imgt.en.features.nbits();\n        if (match.vreg_size < new_vsz) {\n            match.best_idx = i;\n            match.vreg_size = new_vsz;\n            feature_size = new_feature_size;\n            continue;\n        }\n        if (new_feature_size < feature_size)\n            continue;\n        match.best_idx = i;\n        feature_size = new_feature_size;\n    }\n    if (match.best_idx == (uint32_t)-1)\n        jl_error(\"Unable to find compatible target in system image.\");\n    return match;\n}\n\n// Debug helper\n\ntemplate<typename CPU, size_t n>\nstatic inline void dump_cpu_spec(uint32_t cpu, const FeatureList<n> &features,\n                                 const FeatureName *feature_names, uint32_t nfeature_names,\n                                 const CPUSpec<CPU,n> *cpus, uint32_t ncpus)\n{\n    bool cpu_found = false;\n    for (uint32_t i = 0;i < ncpus;i++) {\n        if (cpu == uint32_t(cpus[i].cpu)) {\n            cpu_found = true;\n            jl_safe_printf(\"CPU: %s\\n\", cpus[i].name);\n            break;\n        }\n    }\n    if (!cpu_found)\n        jl_safe_printf(\"CPU: generic\\n\");\n    jl_safe_printf(\"Features:\");\n    bool first = true;\n    for (uint32_t i = 0;i < nfeature_names;i++) {\n        if (test_nbit(&features[0], feature_names[i].bit)) {\n            if (first) {\n                jl_safe_printf(\" %s\", feature_names[i].name);\n                first = false;\n            }\n            else {\n                jl_safe_printf(\", %s\", feature_names[i].name);\n            }\n        }\n    }\n    jl_safe_printf(\"\\n\");\n}\n\n}\n\n#if defined(_CPU_X86_) || defined(_CPU_X86_64_)\n\n#include \"processor_x86.cpp\"\n\n#elif defined(_CPU_AARCH64_) || defined(_CPU_ARM_)\n\n#include \"processor_arm.cpp\"\n\n#else\n\n#include \"processor_fallback.cpp\"\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/src/runtime_ccall.cpp": "// This file is a part of Julia. License is MIT: https://julialang.org/license\n\n#include \"llvm-version.h\"\n#include <map>\n#include <string>\n#include <cstdio>\n#include <llvm/Support/Host.h>\n#include \"julia.h\"\n#include \"julia_internal.h\"\n#include \"processor.h\"\n#include \"julia_assert.h\"\n\n#ifndef _OS_WINDOWS_\n#include <sys/mman.h>\n#if defined(_OS_DARWIN_) && !defined(MAP_ANONYMOUS)\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n#endif\n\nusing namespace llvm;\n\n// --- library symbol lookup ---\n\n// map from user-specified lib names to handles\nstatic std::map<std::string, void*> libMap;\nstatic jl_mutex_t libmap_lock;\nextern \"C\"\nvoid *jl_get_library(const char *f_lib)\n{\n    void *hnd;\n#ifdef _OS_WINDOWS_\n    if (f_lib == JL_EXE_LIBNAME)\n        return jl_exe_handle;\n    if (f_lib == JL_DL_LIBNAME)\n        return jl_dl_handle;\n#endif\n    if (f_lib == NULL)\n        return jl_RTLD_DEFAULT_handle;\n    JL_LOCK_NOGC(&libmap_lock);\n    // This is the only operation we do on the map, which doesn't invalidate\n    // any references or iterators.\n    void **map_slot = &libMap[f_lib];\n    JL_UNLOCK_NOGC(&libmap_lock);\n    hnd = jl_atomic_load_acquire(map_slot);\n    if (hnd != NULL)\n        return hnd;\n    // We might run this concurrently on two threads but it doesn't matter.\n    hnd = jl_load_dynamic_library(f_lib, JL_RTLD_DEFAULT);\n    if (hnd != NULL)\n        jl_atomic_store_release(map_slot, hnd);\n    return hnd;\n}\n\nextern \"C\" JL_DLLEXPORT\nvoid *jl_load_and_lookup(const char *f_lib, const char *f_name, void **hnd)\n{\n    void *handle = jl_atomic_load_acquire(hnd);\n    if (!handle)\n        jl_atomic_store_release(hnd, (handle = jl_get_library(f_lib)));\n    return jl_dlsym(handle, f_name);\n}\n\n// miscellany\nstd::string jl_get_cpu_name_llvm(void)\n{\n    return llvm::sys::getHostCPUName().str();\n}\n\nstd::string jl_get_cpu_features_llvm(void)\n{\n    StringMap<bool> HostFeatures;\n    llvm::sys::getHostCPUFeatures(HostFeatures);\n    std::string attr;\n    for (auto &ele: HostFeatures) {\n        if (ele.getValue()) {\n            if (!attr.empty()) {\n                attr.append(\",+\");\n            }\n            else {\n                attr.append(\"+\");\n            }\n            attr.append(ele.getKey().str());\n        }\n    }\n    // Explicitly disabled features need to be added at the end so that\n    // they are not re-enabled by other features that implies them by default.\n    for (auto &ele: HostFeatures) {\n        if (!ele.getValue()) {\n            if (!attr.empty()) {\n                attr.append(\",-\");\n            }\n            else {\n                attr.append(\"-\");\n            }\n            attr.append(ele.getKey().str());\n        }\n    }\n    return attr;\n}\n\nextern \"C\" JL_DLLEXPORT\njl_value_t *jl_get_JIT(void)\n{\n    const std::string& HostJITName = \"ORCJIT\";\n    return jl_pchar_to_string(HostJITName.data(), HostJITName.size());\n}\n\n\nstatic void *trampoline_freelist;\n\nstatic void *trampoline_alloc()\n{\n    const int sz = 64; // oversized for most platforms. todo: use precise value?\n    if (!trampoline_freelist) {\n#ifdef _OS_WINDOWS_\n        void *mem = VirtualAlloc(NULL, jl_page_size,\n                MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n#else\n        void *mem = mmap(0, jl_page_size, PROT_READ | PROT_WRITE | PROT_EXEC,\n                MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n#endif\n        void *next = NULL;\n        for (size_t i = 0; i + sz <= jl_page_size; i += sz) {\n            void **curr = (void**)((char*)mem + i);\n            *curr = next;\n            next = (void*)curr;\n        }\n        trampoline_freelist = next;\n    }\n    void *tramp = trampoline_freelist;\n    trampoline_freelist = *(void**)tramp;\n    return tramp;\n}\n\nstatic void trampoline_free(void *tramp)\n{\n    *(void**)tramp = trampoline_freelist;\n    trampoline_freelist = tramp;\n}\n\nstatic void trampoline_deleter(void **f)\n{\n    void *tramp = f[0];\n    void *fobj = f[1];\n    void *cache = f[2];\n    void *nval = f[3];\n    f[0] = NULL;\n    f[2] = NULL;\n    f[3] = NULL;\n    if (tramp)\n        trampoline_free(tramp);\n    if (fobj && cache)\n        ptrhash_remove((htable_t*)cache, fobj);\n    if (nval)\n        free(nval);\n}\n\n// TODO: need a thread lock around the cache access parts of this function\nextern \"C\" JL_DLLEXPORT\njl_value_t *jl_get_cfunction_trampoline(\n    // dynamic inputs:\n    jl_value_t *fobj,\n    jl_datatype_t *result_type,\n    // call-site constants:\n    htable_t *cache, // weakref htable indexed by (fobj, vals)\n    jl_svec_t *fill,\n    void *(*init_trampoline)(void *tramp, void **nval),\n    jl_unionall_t *env,\n    jl_value_t **vals)\n{\n    // lookup (fobj, vals) in cache\n    if (!cache->table)\n        htable_new(cache, 1);\n    if (fill != jl_emptysvec) {\n        htable_t **cache2 = (htable_t**)ptrhash_bp(cache, (void*)vals);\n        cache = *cache2;\n        if (cache == HT_NOTFOUND) {\n            cache = htable_new((htable_t*)malloc(sizeof(htable_t)), 1);\n            *cache2 = cache;\n        }\n    }\n    void *tramp = ptrhash_get(cache, (void*)fobj);\n    if (tramp != HT_NOTFOUND) {\n        assert((jl_datatype_t*)jl_typeof(tramp) == result_type);\n        return (jl_value_t*)tramp;\n    }\n\n    // not found, allocate a new one\n    size_t n = jl_svec_len(fill);\n    void **nval = (void**)malloc(sizeof(void**) * (n + 1));\n    nval[0] = (void*)fobj;\n    jl_value_t *result;\n    JL_TRY {\n        for (size_t i = 0; i < n; i++) {\n            jl_value_t *sparam_val = jl_instantiate_type_in_env(jl_svecref(fill, i), env, vals);\n            if (sparam_val != (jl_value_t*)jl_any_type)\n                if (!jl_is_concrete_type(sparam_val) || !jl_is_immutable(sparam_val))\n                    sparam_val = NULL;\n            nval[i + 1] = (void*)sparam_val;\n        }\n        int permanent =\n            (result_type == jl_voidpointer_type) ||\n            jl_is_concrete_type(fobj) ||\n            (((jl_datatype_t*)jl_typeof(fobj))->instance == fobj);\n        if (jl_is_unionall(fobj)) {\n            jl_value_t *uw = jl_unwrap_unionall(fobj);\n            if (jl_is_datatype(uw) && ((jl_datatype_t*)uw)->name->wrapper == fobj)\n                permanent = true;\n        }\n        if (permanent) {\n            result = jl_gc_permobj(sizeof(jl_taggedvalue_t) + jl_datatype_size(result_type), result_type);\n            memset(result, 0, jl_datatype_size(result_type));\n        }\n        else {\n            result = jl_new_struct_uninit(result_type);\n        }\n        if (result_type != jl_voidpointer_type) {\n            assert(jl_datatype_size(result_type) == sizeof(void*) * 4);\n            ((void**)result)[1] = (void*)fobj;\n        }\n        if (!permanent) {\n            void *ptr_finalizer[2] = {\n                    (void*)jl_voidpointer_type,\n                    (void*)&trampoline_deleter\n                };\n            jl_gc_add_finalizer(result, (jl_value_t*)&ptr_finalizer[1]);\n            ((void**)result)[2] = (void*)cache;\n            ((void**)result)[3] = (void*)nval;\n        }\n    }\n    JL_CATCH {\n        free(nval);\n        jl_rethrow();\n    }\n    tramp = trampoline_alloc();\n    ((void**)result)[0] = tramp;\n    tramp = init_trampoline(tramp, nval);\n    ptrhash_put(cache, (void*)fobj, result);\n    return result;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/src/flisp/print.c": "extern void *memrchr(const void *s, int c, size_t n);\n\nstatic void outc(fl_context_t *fl_ctx, char c, ios_t *f)\n{\n    ios_putc(c, f);\n    if (c == '\\n')\n        fl_ctx->HPOS = 0;\n    else\n        fl_ctx->HPOS++;\n}\nstatic void outs(fl_context_t *fl_ctx, const char *s, ios_t *f)\n{\n    ios_puts(s, f);\n    fl_ctx->HPOS += u8_strwidth(s);\n}\nstatic void outsn(fl_context_t *fl_ctx, const char *s, ios_t *f, size_t n)\n{\n    ios_write(f, s, n);\n    fl_ctx->HPOS += u8_strwidth(s);\n}\nstatic int outindent(fl_context_t *fl_ctx, int n, ios_t *f)\n{\n    // move back to left margin if we get too indented\n    if (n > fl_ctx->SCR_WIDTH-12)\n        n = 2;\n    int n0 = n;\n    ios_putc('\\n', f);\n    fl_ctx->VPOS++;\n    fl_ctx->HPOS = n;\n    while (n >= 8) {\n        ios_putc('\\t', f);\n        n -= 8;\n    }\n    while (n) {\n        ios_putc(' ', f);\n        n--;\n    }\n    return n0;\n}\n\nvoid fl_print_chr(fl_context_t *fl_ctx, char c, ios_t *f)\n{\n    outc(fl_ctx, c, f);\n}\n\nvoid fl_print_str(fl_context_t *fl_ctx, const char *s, ios_t *f)\n{\n    outs(fl_ctx, s, f);\n}\n\nvoid print_traverse(fl_context_t *fl_ctx, value_t v)\n{\n    value_t *bp;\n    while (iscons(v)) {\n        if (ismarked(fl_ctx, v)) {\n            bp = (value_t*)ptrhash_bp(&fl_ctx->printconses, (void*)v);\n            if (*bp == (value_t)HT_NOTFOUND)\n                *bp = fixnum(fl_ctx->printlabel++);\n            return;\n        }\n        mark_cons(fl_ctx, v);\n        print_traverse(fl_ctx, car_(v));\n        v = cdr_(v);\n    }\n    if (!ismanaged(fl_ctx, v) || issymbol(v))\n        return;\n    if (ismarked(fl_ctx, v)) {\n        bp = (value_t*)ptrhash_bp(&fl_ctx->printconses, (void*)v);\n        if (*bp == (value_t)HT_NOTFOUND)\n            *bp = fixnum(fl_ctx->printlabel++);\n        return;\n    }\n    if (isvector(v)) {\n        if (vector_size(v) > 0)\n            mark_cons(fl_ctx, v);\n        unsigned int i;\n        for(i=0; i < vector_size(v); i++)\n            print_traverse(fl_ctx, vector_elt(v,i));\n    }\n    else if (iscprim(v)) {\n        mark_cons(fl_ctx, v);\n    }\n    else if (isclosure(v)) {\n        mark_cons(fl_ctx, v);\n        function_t *f = (function_t*)ptr(v);\n        print_traverse(fl_ctx, f->bcode);\n        print_traverse(fl_ctx, f->vals);\n        print_traverse(fl_ctx, f->env);\n    }\n    else {\n        assert(iscvalue(v));\n        cvalue_t *cv = (cvalue_t*)ptr(v);\n        // don't consider shared references to \"\"\n        if (!cv_isstr(fl_ctx, cv) || cv_len(cv)!=0)\n            mark_cons(fl_ctx, v);\n        fltype_t *t = cv_class(cv);\n        if (t->vtable != NULL && t->vtable->print_traverse != NULL)\n            t->vtable->print_traverse(fl_ctx, v);\n    }\n}\n\nstatic void print_symbol_name(fl_context_t *fl_ctx, ios_t *f, char *name)\n{\n    int i, escape=0, charescape=0;\n\n    if ((name[0] == '\\0') ||\n        (name[0] == '.' && name[1] == '\\0') ||\n        (name[0] == '#') ||\n        isnumtok(fl_ctx, name, NULL))\n        escape = 1;\n    i=0;\n    while (name[i]) {\n        if (!symchar(name[i])) {\n            escape = 1;\n            if (name[i]=='|' || name[i]=='\\\\') {\n                charescape = 1;\n                break;\n            }\n        }\n        i++;\n    }\n    if (escape) {\n        if (charescape) {\n            outc(fl_ctx, '|', f);\n            i=0;\n            while (name[i]) {\n                if (name[i]=='|' || name[i]=='\\\\')\n                    outc(fl_ctx, '\\\\', f);\n                outc(fl_ctx, name[i], f);\n                i++;\n            }\n            outc(fl_ctx, '|', f);\n        }\n        else {\n            outc(fl_ctx, '|', f);\n            outs(fl_ctx, name, f);\n            outc(fl_ctx, '|', f);\n        }\n    }\n    else {\n        outs(fl_ctx, name, f);\n    }\n}\n\n/*\n  The following implements a simple pretty-printing algorithm. This is\n  an unlimited-width approach that doesn't require an extra pass.\n  It uses some heuristics to guess whether an expression is \"small\",\n  and avoids wrapping symbols across lines. The result is high\n  performance and nice output for typical code. Quality is poor for\n  pathological or deeply-nested expressions, but those are difficult\n  to print anyway.\n*/\n#define SMALL_STR_LEN 20\nstatic inline int tinyp(fl_context_t *fl_ctx, value_t v)\n{\n    if (issymbol(v))\n        return (u8_strwidth(symbol_name(fl_ctx, v)) < SMALL_STR_LEN);\n    if (fl_isstring(fl_ctx, v))\n        return (cv_len((cvalue_t*)ptr(v)) < SMALL_STR_LEN);\n    return (isfixnum(v) || isbuiltin(v) || v==fl_ctx->F || v==fl_ctx->T || v==fl_ctx->NIL ||\n            v == fl_ctx->FL_EOF);\n}\n\nstatic int smallp(fl_context_t *fl_ctx, value_t v)\n{\n    if (tinyp(fl_ctx, v)) return 1;\n    if (fl_isnumber(fl_ctx, v)) return 1;\n    if (iscons(v)) {\n        if (tinyp(fl_ctx, car_(v)) && (tinyp(fl_ctx, cdr_(v)) ||\n                               (iscons(cdr_(v)) && tinyp(fl_ctx, car_(cdr_(v))) &&\n                                cdr_(cdr_(v))==fl_ctx->NIL)))\n            return 1;\n        return 0;\n    }\n    if (isvector(v)) {\n        size_t s = vector_size(v);\n        return (s == 0 || (tinyp(fl_ctx, vector_elt(v,0)) &&\n                           (s == 1 || (s == 2 &&\n                                       tinyp(fl_ctx, vector_elt(v,1))))));\n    }\n    return 0;\n}\n\nstatic int specialindent(fl_context_t *fl_ctx, value_t head)\n{\n    // indent these forms 2 spaces, not lined up with the first argument\n    if (head == fl_ctx->LAMBDA || head == fl_ctx->TRYCATCH || head == fl_ctx->definesym ||\n        head == fl_ctx->defmacrosym || head == fl_ctx->forsym)\n        return 2;\n    return -1;\n}\n\nstatic int lengthestimate(fl_context_t *fl_ctx, value_t v)\n{\n    // get the width of an expression if we can do so cheaply\n    if (issymbol(v))\n        return u8_strwidth(symbol_name(fl_ctx, v));\n    return -1;\n}\n\nstatic int allsmallp(fl_context_t *fl_ctx, value_t v)\n{\n    int n = 1;\n    while (iscons(v)) {\n        if (!smallp(fl_ctx, car_(v)))\n            return 0;\n        v = cdr_(v);\n        n++;\n        if (n > 25)\n            return n;\n    }\n    return n;\n}\n\nstatic int indentafter3(fl_context_t *fl_ctx, value_t head, value_t v)\n{\n    // for certain X always indent (X a b c) after b\n    return ((head == fl_ctx->forsym) && !allsmallp(fl_ctx, cdr_(v)));\n}\n\nstatic int indentafter2(fl_context_t *fl_ctx, value_t head, value_t v)\n{\n    // for certain X always indent (X a b) after a\n    return ((head == fl_ctx->definesym || head == fl_ctx->defmacrosym) &&\n            !allsmallp(fl_ctx, cdr_(v)));\n}\n\nstatic int indentevery(fl_context_t *fl_ctx, value_t v)\n{\n    // indent before every subform of a special form, unless every\n    // subform is \"small\"\n    value_t c = car_(v);\n    if (c == fl_ctx->LAMBDA || c == fl_ctx->setqsym)\n        return 0;\n    if (c == fl_ctx->IF) // TODO: others\n        return !allsmallp(fl_ctx, cdr_(v));\n    return 0;\n}\n\nstatic int blockindent(fl_context_t *fl_ctx, value_t v)\n{\n    // in this case we switch to block indent mode, where the head\n    // is no longer considered special:\n    // (a b c d e\n    //  f g h i j)\n    return (allsmallp(fl_ctx, v) > 9);\n}\n\nstatic void print_pair(fl_context_t *fl_ctx, ios_t *f, value_t v)\n{\n    value_t cd;\n    char *op = NULL;\n    if (iscons(cdr_(v)) && cdr_(cdr_(v)) == fl_ctx->NIL &&\n        !ptrhash_has(&fl_ctx->printconses, (void*)cdr_(v)) &&\n        (((car_(v) == fl_ctx->QUOTE)     && (op = \"'\"))  ||\n         ((car_(v) == fl_ctx->BACKQUOTE) && (op = \"`\"))  ||\n         ((car_(v) == fl_ctx->COMMA)     && (op = \",\"))  ||\n         ((car_(v) == fl_ctx->COMMAAT)   && (op = \",@\")) ||\n         ((car_(v) == fl_ctx->COMMADOT)  && (op = \",.\")))) {\n        // special prefix syntax\n        unmark_cons(fl_ctx, v);\n        unmark_cons(fl_ctx, cdr_(v));\n        outs(fl_ctx, op, f);\n        fl_print_child(fl_ctx, f, car_(cdr_(v)));\n        return;\n    }\n    int startpos = fl_ctx->HPOS;\n    outc(fl_ctx, '(', f);\n    int newindent=fl_ctx->HPOS, blk=blockindent(fl_ctx, v);\n    int lastv, n=0, si, ind=0, est, always=0, nextsmall, thistiny;\n    if (!blk) always = indentevery(fl_ctx, v);\n    value_t head = car_(v);\n    int after3 = indentafter3(fl_ctx, head, v);\n    int after2 = indentafter2(fl_ctx, head, v);\n    int n_unindented = 1;\n    while (1) {\n        cd = cdr_(v);\n        if (fl_ctx->print_length >= 0 && n >= fl_ctx->print_length && cd!=fl_ctx->NIL) {\n            outsn(fl_ctx, \"...)\", f, 4);\n            break;\n        }\n        lastv = fl_ctx->VPOS;\n        unmark_cons(fl_ctx, v);\n        fl_print_child(fl_ctx, f, car_(v));\n        if (!iscons(cd) || ptrhash_has(&fl_ctx->printconses, (void*)cd)) {\n            if (cd != fl_ctx->NIL) {\n                outsn(fl_ctx, \" . \", f, 3);\n                fl_print_child(fl_ctx, f, cd);\n            }\n            outc(fl_ctx, ')', f);\n            break;\n        }\n\n        if (!fl_ctx->print_pretty ||\n            ((head == fl_ctx->LAMBDA) && n == 0)) {\n            // never break line before lambda-list\n            ind = 0;\n        }\n        else {\n            est = lengthestimate(fl_ctx, car_(cd));\n            nextsmall = smallp(fl_ctx, car_(cd));\n            thistiny = tinyp(fl_ctx, car_(v));\n            ind = (((fl_ctx->VPOS > lastv) ||\n                    (fl_ctx->HPOS>fl_ctx->SCR_WIDTH/2 && !nextsmall && !thistiny && n>0)) ||\n\n                   (fl_ctx->HPOS > fl_ctx->SCR_WIDTH-4) ||\n\n                   (est!=-1 && (fl_ctx->HPOS+est > fl_ctx->SCR_WIDTH-2)) ||\n\n                   ((head == fl_ctx->LAMBDA) && !nextsmall) ||\n\n                   (n > 0 && always) ||\n\n                   (n == 2 && after3) ||\n                   (n == 1 && after2) ||\n\n                   (n_unindented >= 3 && !nextsmall) ||\n\n                   (n == 0 && !smallp(fl_ctx, head)));\n        }\n\n        if (ind) {\n            newindent = outindent(fl_ctx, newindent, f);\n            n_unindented = 1;\n        }\n        else {\n            n_unindented++;\n            outc(fl_ctx, ' ', f);\n            if (n==0) {\n                // set indent level after printing head\n                si = specialindent(fl_ctx, head);\n                if (si != -1)\n                    newindent = startpos + si;\n                else if (!blk)\n                    newindent = fl_ctx->HPOS;\n            }\n        }\n        n++;\n        v = cd;\n    }\n}\n\nstatic void cvalue_print(fl_context_t *fl_ctx, ios_t *f, value_t v);\n\nstatic int print_circle_prefix(fl_context_t *fl_ctx, ios_t *f, value_t v)\n{\n    value_t label;\n    char buf[64];\n    char *str;\n    if ((label=(value_t)ptrhash_get(&fl_ctx->printconses, (void*)v)) !=\n        (value_t)HT_NOTFOUND) {\n        if (!ismarked(fl_ctx, v)) {\n            //fl_ctx->HPOS+=ios_printf(f, \"#%ld#\", numval(label));\n            outc(fl_ctx, '#', f);\n            str = uint2str(buf, sizeof(buf)-1, numval(label), 10);\n            outs(fl_ctx, str, f);\n            outc(fl_ctx, '#', f);\n            return 1;\n        }\n        //fl_ctx->HPOS+=ios_printf(f, \"#%ld=\", numval(label));\n        outc(fl_ctx, '#', f);\n        str = uint2str(buf, sizeof(buf)-1, numval(label), 10);\n        outs(fl_ctx, str, f);\n        outc(fl_ctx, '=', f);\n    }\n    if (ismanaged(fl_ctx, v))\n        unmark_cons(fl_ctx, v);\n    return 0;\n}\n\nvoid fl_print_child(fl_context_t *fl_ctx, ios_t *f, value_t v)\n{\n    char *name, *str;\n    char buf[64];\n    if (fl_ctx->print_level >= 0 && fl_ctx->P_LEVEL >= fl_ctx->print_level &&\n        (iscons(v) || isvector(v) || isclosure(v))) {\n        outc(fl_ctx, '#', f);\n        return;\n    }\n    fl_ctx->P_LEVEL++;\n\n    switch (tag(v)) {\n    case TAG_NUM :\n    case TAG_NUM1: //fl_ctx->HPOS+=ios_printf(f, \"%ld\", numval(v)); break;\n        str = uint2str(&buf[1], sizeof(buf)-1, labs(numval(v)), 10);\n        if (numval(v)<0)\n            *(--str) = '-';\n        outs(fl_ctx, str, f);\n        break;\n    case TAG_SYM:\n        name = symbol_name(fl_ctx, v);\n        if (fl_ctx->print_princ)\n            outs(fl_ctx, name, f);\n        else if (ismanaged(fl_ctx, v)) {\n            outsn(fl_ctx, \"#:\", f, 2);\n            outs(fl_ctx, name, f);\n        }\n        else\n            print_symbol_name(fl_ctx, f, name);\n        break;\n    case TAG_FUNCTION:\n        if (v == fl_ctx->T) {\n            outsn(fl_ctx, \"#t\", f, 2);\n        }\n        else if (v == fl_ctx->F) {\n            outsn(fl_ctx, \"#f\", f, 2);\n        }\n        else if (v == fl_ctx->NIL) {\n            outsn(fl_ctx, \"()\", f, 2);\n        }\n        else if (v == fl_ctx->FL_EOF) {\n            outsn(fl_ctx, \"#<eof>\", f, 6);\n        }\n        else if (isbuiltin(v)) {\n            if (!fl_ctx->print_princ)\n                outsn(fl_ctx, \"#.\", f, 2);\n            outs(fl_ctx, builtin_names[uintval(v)], f);\n        }\n        else {\n            assert(isclosure(v));\n            if (!fl_ctx->print_princ) {\n                if (print_circle_prefix(fl_ctx, f, v)) break;\n                function_t *fn = (function_t*)ptr(v);\n                outs(fl_ctx, \"#fn(\", f);\n                char *data = (char*)cvalue_data(fn->bcode);\n                size_t i, sz = cvalue_len(fn->bcode);\n                for(i=0; i < sz; i++) data[i] += 48;\n                fl_print_child(fl_ctx, f, fn->bcode);\n                for(i=0; i < sz; i++) data[i] -= 48;\n                outc(fl_ctx, ' ', f);\n                fl_print_child(fl_ctx, f, fn->vals);\n                if (fn->env != fl_ctx->NIL) {\n                    outc(fl_ctx, ' ', f);\n                    fl_print_child(fl_ctx, f, fn->env);\n                }\n                if (fn->name != fl_ctx->LAMBDA) {\n                    outc(fl_ctx, ' ', f);\n                    fl_print_child(fl_ctx, f, fn->name);\n                }\n                outc(fl_ctx, ')', f);\n            }\n            else {\n                outs(fl_ctx, \"#<function>\", f);\n            }\n        }\n        break;\n    case TAG_CVALUE:\n    case TAG_CPRIM:\n        if (v == UNBOUND) { outs(fl_ctx, \"#<undefined>\", f); break; }\n        JL_FALLTHROUGH;\n    case TAG_VECTOR:\n    case TAG_CONS:\n        if (print_circle_prefix(fl_ctx, f, v)) break;\n        if (isvector(v)) {\n            outc(fl_ctx, '[', f);\n            int newindent = fl_ctx->HPOS, est;\n            int i, sz = vector_size(v);\n            for(i=0; i < sz; i++) {\n                if (fl_ctx->print_length >= 0 && i >= fl_ctx->print_length && i < sz-1) {\n                    outsn(fl_ctx, \"...\", f, 3);\n                    break;\n                }\n                fl_print_child(fl_ctx, f, vector_elt(v,i));\n                if (i < sz-1) {\n                    if (!fl_ctx->print_pretty) {\n                        outc(fl_ctx, ' ', f);\n                    }\n                    else {\n                        est = lengthestimate(fl_ctx, vector_elt(v,i+1));\n                        if (fl_ctx->HPOS > fl_ctx->SCR_WIDTH-4 ||\n                            (est!=-1 && (fl_ctx->HPOS+est > fl_ctx->SCR_WIDTH-2)) ||\n                            (fl_ctx->HPOS > fl_ctx->SCR_WIDTH/2 &&\n                             !smallp(fl_ctx, vector_elt(v,i+1)) &&\n                             !tinyp(fl_ctx, vector_elt(v,i))))\n                            newindent = outindent(fl_ctx, newindent, f);\n                        else\n                            outc(fl_ctx, ' ', f);\n                    }\n                }\n            }\n            outc(fl_ctx, ']', f);\n            break;\n        }\n        if (iscvalue(v) || iscprim(v))\n            cvalue_print(fl_ctx, f, v);\n        else\n            print_pair(fl_ctx, f, v);\n        break;\n    }\n    fl_ctx->P_LEVEL--;\n}\n\nstatic void print_string(fl_context_t *fl_ctx, ios_t *f, char *str, size_t sz)\n{\n    char buf[512];\n    size_t i = 0;\n    uint8_t c;\n    static const char hexdig[] = \"0123456789abcdef\";\n\n    outc(fl_ctx, '\"', f);\n    if (!u8_isvalid(str, sz)) {\n        // alternate print algorithm that preserves data if it's not UTF-8\n        for(i=0; i < sz; i++) {\n            c = str[i];\n            if (c == '\\\\')\n                outsn(fl_ctx, \"\\\\\\\\\", f, 2);\n            else if (c == '\"')\n                outsn(fl_ctx, \"\\\\\\\"\", f, 2);\n            else if (c >= 32 && c < 0x7f)\n                outc(fl_ctx, c, f);\n            else {\n                outsn(fl_ctx, \"\\\\x\", f, 2);\n                outc(fl_ctx, hexdig[c>>4], f);\n                outc(fl_ctx, hexdig[c&0xf], f);\n            }\n        }\n    }\n    else {\n        while (i < sz) {\n            size_t n = u8_escape(buf, sizeof(buf), str, &i, sz, 1, 0);\n            outsn(fl_ctx, buf, f, n-1);\n        }\n    }\n    outc(fl_ctx, '\"', f);\n}\n\nstatic numerictype_t sym_to_numtype(fl_context_t *fl_ctx, value_t type);\n#ifndef _OS_WINDOWS_\n#define __USE_GNU\n#include <dlfcn.h>\n#undef __USE_GNU\n#endif\n\n#define sign_bit(r) ((*(int64_t*)&(r)) & BIT63)\n#define DFINITE(d) (((*(int64_t*)&(d))&0x7ff0000000000000LL)!=0x7ff0000000000000LL)\n\n// 'weak' means we don't need to accurately reproduce the type, so\n// for example #int32(0) can be printed as just 0. this is used\n// printing in a context where a type is already implied, e.g. inside\n// an array.\nstatic void cvalue_printdata(fl_context_t *fl_ctx, ios_t *f, void *data,\n                             size_t len, value_t type, int weak)\n{\n    if (type == fl_ctx->bytesym) {\n        unsigned char ch = *(unsigned char*)data;\n        if (fl_ctx->print_princ)\n            outc(fl_ctx, ch, f);\n        else if (weak)\n            fl_ctx->HPOS+=ios_printf(f, \"0x%hhx\", ch);\n        else\n            fl_ctx->HPOS+=ios_printf(f, \"#byte(0x%hhx)\", ch);\n    }\n    else if (type == fl_ctx->wcharsym) {\n        uint32_t wc = *(uint32_t*)data;\n        char seq[8];\n        size_t nb = u8_toutf8(seq, sizeof(seq), &wc, 1);\n        seq[nb] = '\\0';\n        if (fl_ctx->print_princ) {\n            // TODO: better multibyte handling\n            outs(fl_ctx, seq, f);\n        }\n        else {\n            outsn(fl_ctx, \"#\\\\\", f, 2);\n            if      (wc == 0x00) outsn(fl_ctx, \"nul\", f, 3);\n            else if (wc == 0x07) outsn(fl_ctx, \"alarm\", f, 5);\n            else if (wc == 0x08) outsn(fl_ctx, \"backspace\", f, 9);\n            else if (wc == 0x09) outsn(fl_ctx, \"tab\", f, 3);\n            else if (wc == 0x0A) outsn(fl_ctx, \"linefeed\", f, 8);\n            //else if (wc == 0x0A) outsn(fl_ctx, \"newline\", f, 7);\n            else if (wc == 0x0B) outsn(fl_ctx, \"vtab\", f, 4);\n            else if (wc == 0x0C) outsn(fl_ctx, \"page\", f, 4);\n            else if (wc == 0x0D) outsn(fl_ctx, \"return\", f, 6);\n            else if (wc == 0x1B) outsn(fl_ctx, \"esc\", f, 3);\n            else if (wc == 0x20) outsn(fl_ctx, \"space\", f, 5);\n            else if (wc == 0x7F) outsn(fl_ctx, \"delete\", f, 6);\n            else if (iswprint(wc)) outs(fl_ctx, seq, f);\n            else fl_ctx->HPOS+=ios_printf(f, \"x%04x\", (int)wc);\n        }\n    }\n    else if (type == fl_ctx->floatsym || type == fl_ctx->doublesym) {\n        char buf[64];\n        double d;\n        if (type == fl_ctx->floatsym) { d = (double)*(float*)data; }\n        else { d = *(double*)data; }\n        if (!DFINITE(d)) {\n            char *rep;\n            if (d != d)\n                rep = (char*)(sign_bit(d) ? \"-nan.0\" : \"+nan.0\");\n            else\n                rep = (char*)(sign_bit(d) ? \"-inf.0\" : \"+inf.0\");\n            if (type == fl_ctx->floatsym && !fl_ctx->print_princ && !weak)\n                fl_ctx->HPOS+=ios_printf(f, \"#%s(%s)\", symbol_name(fl_ctx, type), rep);\n            else\n                outs(fl_ctx, rep, f);\n        }\n        else if (d == 0) {\n            if (sign_bit(d))\n                outsn(fl_ctx, \"-0.0\", f, 4);\n            else\n                outsn(fl_ctx, \"0.0\", f, 3);\n            if (type == fl_ctx->floatsym && !fl_ctx->print_princ && !weak)\n                outc(fl_ctx, 'f', f);\n        }\n        else {\n            double ad = d < 0 ? -d : d;\n            if ((long)d == d && ad < 1e6 && ad >= 1e-4) {\n                snprintf(buf, sizeof(buf), \"%g\", d);\n            }\n            else {\n                if (type == fl_ctx->floatsym)\n                    snprintf(buf, sizeof(buf), \"%.8g\", d);\n                else\n                    snprintf(buf, sizeof(buf), \"%.16g\", d);\n            }\n            int hasdec = (strpbrk(buf, \".eE\") != NULL);\n            outs(fl_ctx, buf, f);\n            if (!hasdec) outsn(fl_ctx, \".0\", f, 2);\n            if (type == fl_ctx->floatsym && !fl_ctx->print_princ && !weak)\n                outc(fl_ctx, 'f', f);\n        }\n    }\n    else if (type == fl_ctx->uint64sym\n#ifdef _P64\n             || type == fl_ctx->sizesym\n#endif\n             ) {\n        uint64_t ui64 = *(uint64_t*)data;\n        if (weak || fl_ctx->print_princ)\n            fl_ctx->HPOS += ios_printf(f, \"%llu\", ui64);\n        else\n            fl_ctx->HPOS += ios_printf(f, \"#%s(%llu)\", symbol_name(fl_ctx, type), ui64);\n    }\n    else if (issymbol(type)) {\n        // handle other integer prims. we know it's smaller than uint64\n        // at this point, so int64 is big enough to capture everything.\n        numerictype_t nt = sym_to_numtype(fl_ctx, type);\n        if (nt == N_NUMTYPES) {\n            // These states should be context independent.\n            static size_t (*volatile jl_static_print)(ios_t*, void*) = NULL;\n            static volatile int init = 0;\n            if (init == 0) {\n#if defined(RTLD_SELF)\n                jl_static_print = (size_t (*)(ios_t*, void*))\n                    (uintptr_t)dlsym(RTLD_SELF, \"jl_static_show\");\n#elif defined(RTLD_DEFAULT)\n                jl_static_print = (size_t (*)(ios_t*, void*))\n                    (uintptr_t)dlsym(RTLD_DEFAULT, \"jl_static_show\");\n#elif defined(_OS_WINDOWS_)\n                HMODULE handle;\n                if (GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |\n                                       GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n                                       (LPCWSTR)(&cvalue_printdata),\n                                       &handle)) {\n                    jl_static_print = (size_t (*)(ios_t*, void*))\n                        (uintptr_t)GetProcAddress(handle, \"jl_static_show\");\n                }\n#endif\n                init = 1;\n            }\n            if (jl_static_print != NULL && fl_ctx->jl_sym == type) {\n                fl_ctx->HPOS += ios_printf(f, \"#<julia: \");\n                fl_ctx->HPOS += jl_static_print(f, *(void**)data);\n                fl_ctx->HPOS += ios_printf(f, \">\");\n            }\n            else\n                fl_ctx->HPOS += ios_printf(f, \"#<%s>\", symbol_name(fl_ctx, type));\n        }\n        else {\n            int64_t i64 = conv_to_int64(data, nt);\n            if (weak || fl_ctx->print_princ)\n                fl_ctx->HPOS += ios_printf(f, \"%lld\", i64);\n            else\n                fl_ctx->HPOS += ios_printf(f, \"#%s(%lld)\", symbol_name(fl_ctx, type), i64);\n        }\n    }\n    else if (iscons(type)) {\n        if (car_(type) == fl_ctx->arraysym) {\n            value_t eltype = car(fl_ctx, cdr_(type));\n            size_t cnt, elsize;\n            if (iscons(cdr_(cdr_(type)))) {\n                cnt = tosize(fl_ctx, car_(cdr_(cdr_(type))), \"length\");\n                elsize = cnt ? len/cnt : 0;\n            }\n            else {\n                // incomplete array type\n                int junk;\n                elsize = ctype_sizeof(fl_ctx, eltype, &junk);\n                cnt = elsize ? len/elsize : 0;\n            }\n            if (eltype == fl_ctx->bytesym) {\n                if (fl_ctx->print_princ) {\n                    ios_write(f, (char*)data, len);\n                    /*\n                    char *nl = memrchr(data, '\\n', len);\n                    if (nl)\n                        fl_ctx->HPOS = u8_strwidth(nl+1);\n                    else\n                        fl_ctx->HPOS += u8_strwidth(data);\n                    */\n                }\n                else {\n                    print_string(fl_ctx, f, (char*)data, len);\n                }\n                return;\n            }\n            else if (eltype == fl_ctx->wcharsym) {\n                // TODO wchar\n            }\n            else {\n            }\n            size_t i;\n            if (!weak) {\n                if (eltype == fl_ctx->uint8sym) {\n                    outsn(fl_ctx, \"#vu8(\", f, 5);\n                }\n                else {\n                    outsn(fl_ctx, \"#array(\", f, 7);\n                    fl_print_child(fl_ctx, f, eltype);\n                    if (cnt > 0)\n                        outc(fl_ctx, ' ', f);\n                }\n            }\n            else {\n                outc(fl_ctx, '[', f);\n            }\n            for(i=0; i < cnt; i++) {\n                if (i > 0)\n                    outc(fl_ctx, ' ', f);\n                cvalue_printdata(fl_ctx, f, data, elsize, eltype, 1);\n                data = (char *)data + elsize;\n            }\n            if (!weak)\n                outc(fl_ctx, ')', f);\n            else\n                outc(fl_ctx, ']', f);\n        }\n    }\n}\n\nstatic void cvalue_print(fl_context_t *fl_ctx, ios_t *f, value_t v)\n{\n    cvalue_t *cv = (cvalue_t*)ptr(v);\n    void *data = cptr(v);\n    value_t label;\n\n    if (cv_class(cv) == fl_ctx->builtintype) {\n        void *fptr = *(void**)data;\n        label = (value_t)ptrhash_get(&fl_ctx->reverse_dlsym_lookup_table, cv);\n        if (label == (value_t)HT_NOTFOUND) {\n            fl_ctx->HPOS += ios_printf(f, \"#<builtin @0x%08zx>\", (size_t)fptr);\n        }\n        else {\n            if (fl_ctx->print_princ) {\n                outs(fl_ctx, symbol_name(fl_ctx, label), f);\n            }\n            else {\n                outsn(fl_ctx, \"#fn(\", f, 4);\n                outs(fl_ctx, symbol_name(fl_ctx, label), f);\n                outc(fl_ctx, ')', f);\n            }\n        }\n    }\n    else if (cv_class(cv)->vtable != NULL &&\n             cv_class(cv)->vtable->print != NULL) {\n        cv_class(cv)->vtable->print(fl_ctx, v, f);\n    }\n    else {\n        value_t type = cv_type(cv);\n        size_t len = iscprim(v) ? cv_class(cv)->size : cv_len(cv);\n        cvalue_printdata(fl_ctx, f, data, len, type, 0);\n    }\n}\n\nstatic void set_print_width(fl_context_t *fl_ctx)\n{\n    value_t pw = symbol_value(fl_ctx->printwidthsym);\n    if (!isfixnum(pw)) return;\n    fl_ctx->SCR_WIDTH = numval(pw);\n}\n\nvoid fl_print(fl_context_t *fl_ctx, ios_t *f, value_t v)\n{\n    fl_ctx->print_pretty = (symbol_value(fl_ctx->printprettysym) != fl_ctx->F);\n    if (fl_ctx->print_pretty)\n        set_print_width(fl_ctx);\n    fl_ctx->print_princ = (symbol_value(fl_ctx->printreadablysym) == fl_ctx->F);\n\n    value_t pl = symbol_value(fl_ctx->printlengthsym);\n    if (isfixnum(pl)) fl_ctx->print_length = numval(pl);\n    else fl_ctx->print_length = -1;\n    pl = symbol_value(fl_ctx->printlevelsym);\n    if (isfixnum(pl)) fl_ctx->print_level = numval(pl);\n    else fl_ctx->print_level = -1;\n    fl_ctx->P_LEVEL = 0;\n\n    fl_ctx->printlabel = 0;\n    print_traverse(fl_ctx, v);\n    fl_ctx->HPOS = fl_ctx->VPOS = 0;\n\n    fl_print_child(fl_ctx, f, v);\n\n    if (fl_ctx->print_level >= 0 || fl_ctx->print_length >= 0) {\n        memset(fl_ctx->consflags, 0, 4*bitvector_nwords(fl_ctx->heapsize/sizeof(cons_t)));\n    }\n\n    if ((iscons(v) || isvector(v) || isfunction(v) || iscvalue(v)) &&\n        !fl_isstring(fl_ctx, v) && v!=fl_ctx->T && v!=fl_ctx->F && v!=fl_ctx->NIL) {\n        htable_reset(&fl_ctx->printconses, 32);\n    }\n}\n\nvoid fl_print_init(fl_context_t *fl_ctx)\n{\n    htable_new(&fl_ctx->printconses, 32);\n    fl_ctx->SCR_WIDTH = 80;\n    fl_ctx->HPOS = 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/src/flisp/flisp.h": "#ifndef FLISP_H\n#define FLISP_H\n\n#include <setjmp.h>\n#include <stdint.h>\n\n#include \"platform.h\"\n#include \"libsupport.h\"\n#include \"uv.h\"\n\n//#define MEMDEBUG\n//#define MEMDEBUG2\n\ntypedef uintptr_t value_t;\ntypedef int_t fixnum_t;\n#if NBITS==64\n#define T_FIXNUM T_INT64\n#define labs llabs\n#else\n#define T_FIXNUM T_INT32\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\ntypedef struct _fl_context_t fl_context_t;\ntypedef struct {\n    value_t car;\n    value_t cdr;\n} cons_t;\n\ntypedef struct _symbol_t {\n    uintptr_t flags;\n    value_t binding;   // global value binding\n    struct _fltype_t *type;\n    uint32_t hash;\n    void *dlcache;     // dlsym address\n    // below fields are private\n    struct _symbol_t *left;\n    struct _symbol_t *right;\n    JL_ATTRIBUTE_ALIGN_PTRSIZE(char name[]);\n} symbol_t;\n\ntypedef struct {\n    value_t isconst;\n    value_t binding;   // global value binding\n    struct _fltype_t *type;\n    uint32_t id;\n} gensym_t;\n\n#define TAG_NUM      0x0\n#define TAG_CPRIM    0x1\n#define TAG_FUNCTION 0x2\n#define TAG_VECTOR   0x3\n#define TAG_NUM1     0x4\n#define TAG_CVALUE   0x5\n#define TAG_SYM      0x6\n#define TAG_CONS     0x7\n#define UNBOUND      ((value_t)0x1) // an invalid value\n#define TAG_FWD      UNBOUND\n#define tag(x) ((x)&0x7)\n#define ptr(x) ((void*)((x)&(~(value_t)0x7)))\n#define tagptr(p,t) (((value_t)(p)) | (t))\n#define fixnum(x) ((value_t)(((uintptr_t)(x))<<2))\n#define numval(x)  (((fixnum_t)(x))>>2)\n#if NBITS==64\n#define fits_fixnum(x) (((x)>>61) == 0 || (~((x)>>61)) == 0)\n#else\n#define fits_fixnum(x) (((x)>>29) == 0 || (~((x)>>29)) == 0)\n#endif\n#define fits_bits(x,b) (((x)>>(b-1)) == 0 || (~((x)>>(b-1))) == 0)\n#define uintval(x)  (((unsigned int)(x))>>3)\n#define builtin(n) tagptr((((int)n)<<3), TAG_FUNCTION)\n#define iscons(x)    (tag(x) == TAG_CONS)\n#define issymbol(x)  (tag(x) == TAG_SYM)\n#define isfixnum(x)  (((x)&3) == TAG_NUM)\n#define bothfixnums(x,y) ((((x)|(y))&3) == TAG_NUM)\n#define isbuiltin(x) ((tag(x) == TAG_FUNCTION) && uintval(x) <= OP_ASET)\n#define isvector(x) (tag(x) == TAG_VECTOR)\n#define iscvalue(x) (tag(x) == TAG_CVALUE)\n#define iscprim(x)  (tag(x) == TAG_CPRIM)\n#define selfevaluating(x) (tag(x)<6)\n// comparable with ==\n#define eq_comparable(a,b) (!(((a)|(b))&1))\n#define eq_comparablep(a) (!((a)&1))\n// doesn't lead to other values\n#define leafp(a) (((a)&3) != 3)\n\n#define isforwarded(v) (((value_t*)ptr(v))[0] == TAG_FWD)\n#define forwardloc(v)  (((value_t*)ptr(v))[1])\n#define forward(v,to) do { (((value_t*)ptr(v))[0] = TAG_FWD); \\\n                           (((value_t*)ptr(v))[1] = to); } while (0)\n\n#define vector_size(v) (((size_t*)ptr(v))[0]>>2)\n#define vector_setsize(v,n) (((size_t*)ptr(v))[0] = ((n)<<2))\n#define vector_elt(v,i) (((value_t*)ptr(v))[1+(i)])\n#define vector_grow_amt(x) ((x)<8 ? 5 : 6*((x)>>3))\n// functions ending in _ are unsafe, faster versions\n#define car_(v) (((cons_t*)ptr(v))->car)\n#define cdr_(v) (((cons_t*)ptr(v))->cdr)\n#define car(fl_ctx, v)  (tocons(fl_ctx, (v),\"car\")->car)\n#define cdr(fl_ctx, v)  (tocons(fl_ctx, (v),\"cdr\")->cdr)\n#define fn_bcode(f) (((value_t*)ptr(f))[0])\n#define fn_vals(f) (((value_t*)ptr(f))[1])\n#define fn_env(f) (((value_t*)ptr(f))[2])\n#define fn_name(f) (((value_t*)ptr(f))[3])\n\n#define set(s, v)  (((symbol_t*)ptr(s))->binding = (v))\n#define setc(s, v) do { ((symbol_t*)ptr(s))->flags |= 1; \\\n                        ((symbol_t*)ptr(s))->binding = (v); } while (0)\n#define isconstant(s) ((s)->flags&0x1)\n#define iskeyword(s) ((s)->flags&0x2)\n#define symbol_value(s) (((symbol_t*)ptr(s))->binding)\n#ifdef MEMDEBUG2\n#define ismanaged(ctx, v) (!issymbol(v) && !isfixnum(v) && ((v)>(N_OPCODES<<3)) && !iscbuiltin(ctx, v))\n#else\n#define ismanaged(ctx, v) ((((unsigned char*)ptr(v)) >= ctx->fromspace) && \\\n                           (((unsigned char*)ptr(v)) < ctx->fromspace + ctx->heapsize))\n#endif\n#define isgensym(ctx, x)  (issymbol(x) && ismanaged(ctx, x))\n\n#define isfunction(x) (tag(x) == TAG_FUNCTION && (x) > (N_BUILTINS<<3))\n#define isclosure(x) isfunction(x)\n#define iscbuiltin(ctx, x) (iscvalue(x) && (cv_class((cvalue_t*)ptr(x))==ctx->builtintype))\n\nvoid fl_gc_handle(fl_context_t *fl_ctx, value_t *pv);\nvoid fl_free_gc_handles(fl_context_t *fl_ctx, uint32_t n);\n\n#include \"opcodes.h\"\n\n// utility for iterating over all arguments in a builtin\n// i=index, i0=start index, arg = var for each arg, args = arg array\n// assumes \"nargs\" is the argument count\n#define FOR_ARGS(i, i0, arg, args)     \\\n    for(i=i0; ((size_t)i)<nargs && ((arg=args[i]) || 1); i++)\n\n#define N_BUILTINS ((int)N_OPCODES)\n\n#define FL_UNSPECIFIED(fl_ctx) fl_ctx->T\n\n/* read, eval, print main entry points */\nvalue_t fl_read_sexpr(fl_context_t *fl_ctx, value_t f);\nvoid fl_print(fl_context_t *fl_ctx, ios_t *f, value_t v);\nvalue_t fl_toplevel_eval(fl_context_t *fl_ctx, value_t expr);\nvalue_t fl_apply(fl_context_t *fl_ctx, value_t f, value_t l);\nvalue_t fl_applyn(fl_context_t *fl_ctx, uint32_t n, value_t f, ...);\n\n/* object model manipulation */\nvalue_t fl_cons(fl_context_t *fl_ctx, value_t a, value_t b);\nvalue_t fl_list2(fl_context_t *fl_ctx, value_t a, value_t b);\nvalue_t fl_listn(fl_context_t *fl_ctx, size_t n, ...);\nvalue_t symbol(fl_context_t *fl_ctx, const char *str);\nchar *symbol_name(fl_context_t *fl_ctx, value_t v);\nint fl_is_keyword_name(const char *str, size_t len);\nvalue_t alloc_vector(fl_context_t *fl_ctx, size_t n, int init);\nsize_t llength(value_t v);\nvalue_t fl_compare(fl_context_t *fl_ctx, value_t a, value_t b);  // -1, 0, or 1\nvalue_t fl_equal(fl_context_t *fl_ctx, value_t a, value_t b);    // T or nil\nint equal_lispvalue(fl_context_t *fl_ctx, value_t a, value_t b);\nuintptr_t hash_lispvalue(fl_context_t *fl_ctx, value_t a);\nint isnumtok_base(fl_context_t *fl_ctx, char *tok, value_t *pval, int base);\n\n/* safe casts */\ncons_t *tocons(fl_context_t *fl_ctx, value_t v, const char *fname);\nsymbol_t *tosymbol(fl_context_t *fl_ctx, value_t v, const char *fname);\nfixnum_t tofixnum(fl_context_t *fl_ctx, value_t v, const char *fname);\nchar *tostring(fl_context_t *fl_ctx, value_t v, const char *fname);\n\n/* error handling */\n#if defined(_OS_WINDOWS_)\n#define fl_jmp_buf jmp_buf\n#if defined(_COMPILER_MINGW_)\nint __attribute__ ((__nothrow__,__returns_twice__)) (jl_setjmp)(jmp_buf _Buf);\n__declspec(noreturn) __attribute__ ((__nothrow__)) void (jl_longjmp)(jmp_buf _Buf, int _Value);\n#else\nint (jl_setjmp)(jmp_buf _Buf);\nvoid (jl_longjmp)(jmp_buf _Buf, int _Value);\n#endif\n#define fl_setjmp(a) (jl_setjmp)((a))\n#define fl_longjmp(a, b) (jl_longjmp)((a), (b))\n#else // !_OS_WINDOWS_\n#define fl_jmp_buf sigjmp_buf\n#define fl_setjmp(a) sigsetjmp((a), 0)\n#define fl_longjmp(a, b) siglongjmp((a), (b))\n#endif\n\ntypedef struct _ectx_t {\n    fl_jmp_buf buf;\n    uint32_t sp;\n    uint32_t frame;\n    uint32_t ngchnd;\n    void *rdst;\n    struct _ectx_t *prev;\n} fl_exception_context_t;\n\n#define FL_TRY_EXTERN(fl_ctx)                                           \\\n  fl_exception_context_t _ctx; int l__tr, l__ca;                        \\\n  fl_savestate(fl_ctx, &_ctx); fl_ctx->exc_ctx = &_ctx;                      \\\n  if (!fl_setjmp(_ctx.buf))                                                \\\n      for (l__tr=1; l__tr; l__tr=0, (void)(fl_ctx->exc_ctx=fl_ctx->exc_ctx->prev))\n\n#define FL_CATCH_EXTERN(fl_ctx)                                         \\\n    else                                                                \\\n        for(l__ca=1; l__ca; l__ca=0, fl_restorestate(fl_ctx, &_ctx))\n\n#if defined(_OS_WINDOWS_)\n__declspec(noreturn) void lerrorf(fl_context_t *fl_ctx, value_t e, const char *format, ...);\n__declspec(noreturn) void lerror(fl_context_t *fl_ctx, value_t e, const char *msg);\n__declspec(noreturn) void fl_raise(fl_context_t *fl_ctx, value_t e);\n__declspec(noreturn) void type_error(fl_context_t *fl_ctx, const char *fname, const char *expected, value_t got);\n__declspec(noreturn) void bounds_error(fl_context_t *fl_ctx, const char *fname, value_t arr, value_t ind);\n#else\nvoid lerrorf(fl_context_t *fl_ctx, value_t e, const char *format, ...) __attribute__ ((__noreturn__));\nvoid lerror(fl_context_t *fl_ctx, value_t e, const char *msg) __attribute__ ((__noreturn__));\nvoid fl_raise(fl_context_t *fl_ctx, value_t e) __attribute__ ((__noreturn__));\nvoid type_error(fl_context_t *fl_ctx, const char *fname, const char *expected, value_t got) __attribute__ ((__noreturn__));\nvoid bounds_error(fl_context_t *fl_ctx, const char *fname, value_t arr, value_t ind) __attribute__ ((__noreturn__));\n#endif\n\nvoid fl_savestate(fl_context_t *fl_ctx, fl_exception_context_t *_ctx);\nvoid fl_restorestate(fl_context_t *fl_ctx, fl_exception_context_t *_ctx);\n\ntypedef struct {\n    void (*print)(fl_context_t *fl_ctx, value_t self, ios_t *f);\n    void (*relocate)(fl_context_t *fl_ctx, value_t oldv, value_t newv);\n    void (*finalize)(fl_context_t *fl_ctx, value_t self);\n    void (*print_traverse)(fl_context_t *fl_ctx, value_t self);\n} cvtable_t;\n\n/* functions needed to implement the value interface (cvtable_t) */\nvalue_t relocate_lispvalue(fl_context_t *fl_ctx, value_t v);\nvoid print_traverse(fl_context_t *fl_ctx, value_t v);\nvoid fl_print_chr(fl_context_t *fl_ctx, char c, ios_t *f);\nvoid fl_print_str(fl_context_t *fl_ctx, const char *s, ios_t *f);\nvoid fl_print_child(fl_context_t *fl_ctx, ios_t *f, value_t v);\n\ntypedef int (*cvinitfunc_t)(fl_context_t *fl_ctx, struct _fltype_t*, value_t, void*);\n\ntypedef struct _fltype_t {\n    value_t type;\n    numerictype_t numtype;\n    size_t size;\n    size_t elsz;\n    const cvtable_t *vtable;\n    struct _fltype_t *eltype;  // for arrays\n    struct _fltype_t *artype;  // (array this)\n    int marked;\n    cvinitfunc_t init;\n} fltype_t;\n\nJL_EXTENSION typedef struct {\n    fltype_t *type;\n    void *data;\n    size_t len;            // length of *data in bytes\n    union {\n        value_t parent;    // optional\n        char _space[1];    // variable size\n    };\n} cvalue_t;\n\n#define CVALUE_NWORDS 4\n\ntypedef struct {\n    fltype_t *type;\n    char _space[1];\n} cprim_t;\n\ntypedef struct {\n    value_t bcode;\n    value_t vals;\n    value_t env;\n    value_t name;\n} function_t;\n\n#define CPRIM_NWORDS 2\n#define MAX_INL_SIZE 384\n\n#define CV_OWNED_BIT  0x1\n#define CV_PARENT_BIT 0x2\n#define owned(cv)      ((uintptr_t)(cv)->type & CV_OWNED_BIT)\n#define hasparent(cv)  ((uintptr_t)(cv)->type & CV_PARENT_BIT)\n#define isinlined(cv)  ((cv)->data == &(cv)->_space[0])\n#define cv_class(cv)   ((fltype_t*)(((uintptr_t)(cv)->type)&~3))\n#define cv_len(cv)     ((cv)->len)\n#define cv_type(cv)    (cv_class(cv)->type)\n#define cv_data(cv)    ((cv)->data)\n#define cv_isstr(fl_ctx, cv)   (cv_class(cv)->eltype == fl_ctx->bytetype)\n#define cv_isPOD(cv)   (cv_class(cv)->init != NULL)\n\n#define cvalue_data(v) cv_data((cvalue_t*)ptr(v))\n#define cvalue_len(v) cv_len((cvalue_t*)ptr(v))\n#define value2c(type, v) ((type)cv_data((cvalue_t*)ptr(v)))\n\n#define valid_numtype(v) ((v) < N_NUMTYPES)\n#define cp_class(cp)   ((cp)->type)\n#define cp_type(cp)    (cp_class(cp)->type)\n#define cp_numtype(cp) (cp_class(cp)->numtype)\n#define cp_data(cp)    (&(cp)->_space[0])\n\n// WARNING: multiple evaluation!\n#define cptr(v) \\\n    (iscprim(v) ? cp_data((cprim_t*)ptr(v)) : cv_data((cvalue_t*)ptr(v)))\n\n/* C type names corresponding to cvalues type names */\ntypedef int8_t   fl_int8_t;\ntypedef uint8_t  fl_uint8_t;\ntypedef int16_t  fl_int16_t;\ntypedef uint16_t fl_uint16_t;\ntypedef int32_t  fl_int32_t;\ntypedef uint32_t fl_uint32_t;\ntypedef int64_t  fl_int64_t;\ntypedef uint64_t fl_uint64_t;\ntypedef char     fl_char_t;\ntypedef char     char_t;\ntypedef ptrdiff_t fl_ptrdiff_t;\ntypedef size_t   fl_size_t;\ntypedef double   fl_double_t;\ntypedef float    fl_float_t;\n\ntypedef value_t (*builtin_t)(fl_context_t*, value_t*, uint32_t);\n\nvalue_t cvalue(fl_context_t *fl_ctx, fltype_t *type, size_t sz);\nvoid add_finalizer(fl_context_t *fl_ctx, cvalue_t *cv);\nvoid cv_autorelease(fl_context_t *fl_ctx, cvalue_t *cv);\nvoid cv_pin(fl_context_t *fl_ctx, cvalue_t *cv);\nsize_t ctype_sizeof(fl_context_t *fl_ctx, value_t type, int *palign);\nvalue_t cvalue_copy(fl_context_t *fl_ctx, value_t v);\nvalue_t cvalue_from_data(fl_context_t *fl_ctx, fltype_t *type, void *data, size_t sz);\nvalue_t cvalue_from_ref(fl_context_t *fl_ctx, fltype_t *type, void *ptr, size_t sz, value_t parent);\nvalue_t cbuiltin(fl_context_t *fl_ctx, const char *name, builtin_t f);\nsize_t cvalue_arraylen(value_t v);\nvalue_t size_wrap(fl_context_t *fl_ctx, size_t sz);\nsize_t tosize(fl_context_t *fl_ctx, value_t n, const char *fname);\nvalue_t cvalue_string(fl_context_t *fl_ctx, size_t sz);\nvalue_t cvalue_static_cstrn(fl_context_t *fl_ctx, const char *str, size_t n);\nvalue_t cvalue_static_cstring(fl_context_t *fl_ctx, const char *str);\nvalue_t string_from_cstr(fl_context_t *fl_ctx, char *str);\nvalue_t string_from_cstrn(fl_context_t *fl_ctx, char *str, size_t n);\nint fl_isstring(fl_context_t *fl_ctx, value_t v);\nint fl_isnumber(fl_context_t *fl_ctx, value_t v);\nint fl_isgensym(fl_context_t *fl_ctx, value_t v);\nint fl_isiostream(fl_context_t *fl_ctx, value_t v);\nios_t *fl_toiostream(fl_context_t *fl_ctx, value_t v, const char *fname);\nvalue_t cvalue_compare(value_t a, value_t b);\nint numeric_compare(fl_context_t *fl_ctx, value_t a, value_t b, int eq, int eqnans, char *fname);\n\nvoid to_sized_ptr(fl_context_t *fl_ctx, value_t v, const char *fname, char **pdata, size_t *psz);\n\nfltype_t *get_type(fl_context_t *fl_ctx, value_t t);\nfltype_t *get_array_type(fl_context_t *fl_ctx, value_t eltype);\nfltype_t *define_opaque_type(value_t sym, size_t sz, const cvtable_t *vtab,\n                             cvinitfunc_t init);\n\nvalue_t mk_double(fl_context_t *fl_ctx, fl_double_t n);\nvalue_t mk_float(fl_context_t *fl_ctx, fl_float_t n);\nvalue_t mk_uint32(fl_context_t *fl_ctx, uint32_t n);\nvalue_t mk_uint64(fl_context_t *fl_ctx, uint64_t n);\nvalue_t mk_wchar(fl_context_t *fl_ctx, int32_t n);\nvalue_t return_from_uint64(fl_context_t *fl_ctx, uint64_t Uaccum);\nvalue_t return_from_int64(fl_context_t *fl_ctx, int64_t Saccum);\n\ntypedef struct {\n    const char *name;\n    builtin_t fptr;\n} builtinspec_t;\n\nvoid assign_global_builtins(fl_context_t *fl_ctx, const builtinspec_t *b);\n\n/* builtins */\nvalue_t fl_hash(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nvalue_t cvalue_byte(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nvalue_t cvalue_wchar(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\n\nvoid fl_init(fl_context_t *fl_ctx, size_t initial_heapsize);\nint fl_load_system_image(fl_context_t *fl_ctx, value_t ios);\nint fl_load_system_image_str(fl_context_t *fl_ctx, char* str, size_t len);\n\n/* julia extensions */\nJL_DLLEXPORT int jl_id_char(uint32_t wc);\nJL_DLLEXPORT int jl_id_start_char(uint32_t wc);\nJL_DLLEXPORT int jl_op_suffix_char(uint32_t wc);\n\nstruct _fl_context_t {\n    symbol_t *symtab;\n    value_t NIL, T, F, FL_EOF, QUOTE;\n    value_t int8sym, uint8sym, int16sym, uint16sym, int32sym, uint32sym;\n    value_t int64sym, uint64sym;\n\n    value_t ptrdiffsym, sizesym, bytesym, wcharsym;\n    value_t floatsym, doublesym;\n    value_t stringtypesym, wcstringtypesym;\n    value_t emptystringsym;\n\n    value_t arraysym, cfunctionsym, voidsym, pointersym;\n\n    htable_t TypeTable;\n    htable_t reverse_dlsym_lookup_table;\n\n    fltype_t *int8type, *uint8type;\n    fltype_t *int16type, *uint16type;\n    fltype_t *int32type, *uint32type;\n    fltype_t *int64type, *uint64type;\n    fltype_t *ptrdifftype, *sizetype;\n    fltype_t *floattype, *doubletype;\n    fltype_t *bytetype, *wchartype;\n    fltype_t *stringtype, *wcstringtype;\n    fltype_t *builtintype;\n\n    htable_t equal_eq_hashtable;\n\n    value_t tablesym;\n    fltype_t *tabletype;\n    cvtable_t table_vtable;\n\n    uint32_t readtoktype;\n    value_t readtokval;\n    char readbuf[256];\n\n    htable_t printconses;\n    uint32_t printlabel;\n    int print_pretty;\n    int print_princ;\n    fixnum_t print_length;\n    fixnum_t print_level;\n    fixnum_t P_LEVEL;\n    int SCR_WIDTH;\n    int HPOS, VPOS;\n\n    value_t iostreamsym, rdsym, wrsym, apsym, crsym, truncsym;\n    value_t instrsym, outstrsym;\n    fltype_t *iostreamtype;\n\n    size_t malloc_pressure;\n    cvalue_t **Finalizers;\n    size_t nfinalizers;\n    size_t maxfinalizers;\n\n    uint32_t N_STACK;\n    value_t *Stack;\n    uint32_t SP;\n    uint32_t curr_frame;\n\n#define FL_N_GC_HANDLES 8192\n    value_t *GCHandleStack[FL_N_GC_HANDLES];\n    uint32_t N_GCHND;\n\n    value_t IOError, ParseError, TypeError, ArgError, UnboundError, KeyError;\n    value_t OutOfMemoryError, DivideError, BoundsError, EnumerationError;\n    value_t printwidthsym, printreadablysym, printprettysym, printlengthsym;\n    value_t printlevelsym, builtins_table_sym;\n\n    value_t LAMBDA, IF, TRYCATCH;\n    value_t BACKQUOTE, COMMA, COMMAAT, COMMADOT, FUNCTION;\n\n    value_t pairsym, symbolsym, fixnumsym, vectorsym, builtinsym, vu8sym;\n    value_t definesym, defmacrosym, forsym, setqsym;\n    value_t tsym, Tsym, fsym, Fsym, booleansym, nullsym, evalsym, fnsym;\n    // for reading characters\n    value_t nulsym, alarmsym, backspacesym, tabsym, linefeedsym, newlinesym;\n    value_t vtabsym, pagesym, returnsym, escsym, spacesym, deletesym;\n\n    struct _fl_readstate_t *readstate;\n\n    unsigned char *fromspace;\n    unsigned char *tospace;\n    unsigned char *curheap;\n    unsigned char *lim;\n    uint32_t heapsize;//bytes\n    uint32_t *consflags;\n\n    // error utilities --------------------------------------------------\n\n    // saved execution state for an unwind target\n    fl_exception_context_t *exc_ctx;\n    uint32_t throwing_frame;  // active frame when exception was thrown\n    value_t lasterror;\n\n    uint32_t gensym_ctr;\n    // two static buffers for gensym printing so there can be two\n    // gensym names available at a time, mostly for compare()\n    char gsname[2][16];\n    int gsnameno;\n\n    void *tochain;\n    long long n_allocd;\n\n    value_t the_empty_vector;\n    value_t memory_exception_value;\n\n    int gc_grew;\n    cons_t *apply_c;\n    value_t *apply_pv;\n    int64_t apply_accum;\n    value_t apply_func, apply_v, apply_e;\n\n    value_t jl_sym;\n    // persistent buffer (avoid repeated malloc/free)\n    // for julia_extensions.c: normalize\n    size_t jlbuflen;\n    void *jlbuf;\n};\n\nstatic inline void argcount(fl_context_t *fl_ctx, const char *fname, uint32_t nargs, uint32_t c)\n{\n    if (__unlikely(nargs != c))\n        lerrorf(fl_ctx, fl_ctx->ArgError,\"%s: too %s arguments\", fname, nargs<c ? \"few\":\"many\");\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/src/flisp/cvalues.c": "#ifdef _P64\n#define NWORDS(sz) (((sz)+7)>>3)\n#else\n#define NWORDS(sz) (((sz)+3)>>2)\n#endif\n\nstruct prim_int16{ char a; int16_t i; };\nstruct prim_int32{ char a; int32_t i; };\nstruct prim_int64{ char a; int64_t i; };\nstruct prim_ptr{ char a;  void   *i; };\n\n// compute struct field alignment required for primitives\nstatic const int ALIGN2   = sizeof(struct prim_int16) - 2;\nstatic const int ALIGN4   = sizeof(struct prim_int32) - 4;\nstatic const int ALIGN8   = sizeof(struct prim_int64) - 8;\nstatic const int ALIGNPTR = sizeof(struct prim_ptr) - sizeof(void*);\n\nstatic void cvalue_init(fl_context_t *fl_ctx, fltype_t *type, value_t v, void *dest);\n\n// cvalues-specific builtins\nvalue_t cvalue_new(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nvalue_t cvalue_sizeof(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nvalue_t cvalue_typeof(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\n\n// trigger unconditional GC after this many bytes are allocated\n#define ALLOC_LIMIT_TRIGGER 67108864\n\nvoid add_finalizer(fl_context_t *fl_ctx, cvalue_t *cv)\n{\n    if (fl_ctx->nfinalizers == fl_ctx->maxfinalizers) {\n        size_t nn = (fl_ctx->maxfinalizers==0 ? 256 : fl_ctx->maxfinalizers*2);\n        cvalue_t **temp = (cvalue_t**)realloc(fl_ctx->Finalizers, nn*sizeof(value_t));\n        if (temp == NULL)\n            lerror(fl_ctx, fl_ctx->OutOfMemoryError, \"out of memory\");\n        fl_ctx->Finalizers = temp;\n        fl_ctx->maxfinalizers = nn;\n    }\n    fl_ctx->Finalizers[fl_ctx->nfinalizers++] = cv;\n}\n\n// remove dead objects from finalization list in-place\nstatic void sweep_finalizers(fl_context_t *fl_ctx)\n{\n    cvalue_t **lst = fl_ctx->Finalizers;\n    size_t n=0, ndel=0, l=fl_ctx->nfinalizers;\n    cvalue_t *tmp;\n#define SWAP_sf(a,b) (tmp=a,a=b,b=tmp,1)\n    if (l == 0)\n        return;\n    do {\n        tmp = lst[n];\n        if (isforwarded((value_t)tmp)) {\n            // object is alive\n            lst[n] = (cvalue_t*)ptr(forwardloc((value_t)tmp));\n            n++;\n        }\n        else {\n            fltype_t *t = cv_class(tmp);\n            if (t->vtable != NULL && t->vtable->finalize != NULL) {\n                t->vtable->finalize(fl_ctx, tagptr(tmp, TAG_CVALUE));\n            }\n            if (!isinlined(tmp) && owned(tmp)) {\n#ifdef DEBUG\n                memset(cv_data(tmp), 0xbb, cv_len(tmp));\n#endif\n                free(cv_data(tmp));\n            }\n            ndel++;\n        }\n    } while ((n < l-ndel) && SWAP_sf(lst[n],lst[n+ndel]));\n\n    fl_ctx->nfinalizers -= ndel;\n#ifdef VERBOSEGC\n    if (ndel > 0)\n        printf(\"GC: finalized %d objects\\n\", ndel);\n#endif\n\n    fl_ctx->malloc_pressure = 0;\n}\n\n// compute the size of the metadata object for a cvalue\nstatic size_t cv_nwords(fl_context_t *fl_ctx, cvalue_t *cv)\n{\n    if (isinlined(cv)) {\n        size_t n = cv_len(cv);\n        if (n==0 || cv_isstr(fl_ctx, cv))\n            n++;\n        return CVALUE_NWORDS - 1 + NWORDS(n);\n    }\n    return CVALUE_NWORDS;\n}\n\nstatic void autorelease(fl_context_t *fl_ctx, cvalue_t *cv)\n{\n    cv->type = (fltype_t*)(((uintptr_t)cv->type) | CV_OWNED_BIT);\n    add_finalizer(fl_ctx, cv);\n}\n\nvoid cv_autorelease(fl_context_t *fl_ctx, cvalue_t *cv)\n{\n    autorelease(fl_ctx, cv);\n}\n\nstatic value_t cprim(fl_context_t *fl_ctx, fltype_t *type, size_t sz)\n{\n    cprim_t *pcp = (cprim_t*)alloc_words(fl_ctx, CPRIM_NWORDS-1+NWORDS(sz));\n    pcp->type = type;\n    return tagptr(pcp, TAG_CPRIM);\n}\n\nvalue_t cvalue(fl_context_t *fl_ctx, fltype_t *type, size_t sz)\n{\n    cvalue_t *pcv;\n    int str=0;\n\n    if (valid_numtype(type->numtype)) {\n        return cprim(fl_ctx, type, sz);\n    }\n    if (type->eltype == fl_ctx->bytetype) {\n        if (sz == 0)\n            return symbol_value(fl_ctx->emptystringsym);\n        sz++;\n        str=1;\n    }\n    if (sz <= MAX_INL_SIZE) {\n        size_t nw = CVALUE_NWORDS - 1 + NWORDS(sz) + (sz==0 ? 1 : 0);\n        pcv = (cvalue_t*)alloc_words(fl_ctx, nw);\n        pcv->type = type;\n        pcv->data = &pcv->_space[0];\n        if (type->vtable != NULL && type->vtable->finalize != NULL)\n            add_finalizer(fl_ctx, pcv);\n    }\n    else {\n        if (fl_ctx->malloc_pressure > ALLOC_LIMIT_TRIGGER)\n            gc(fl_ctx, 0);\n        pcv = (cvalue_t*)alloc_words(fl_ctx, CVALUE_NWORDS);\n        pcv->type = type;\n        pcv->data = malloc(sz);\n        autorelease(fl_ctx, pcv);\n        fl_ctx->malloc_pressure += sz;\n    }\n    if (str) {\n        sz--;\n        ((char*)pcv->data)[sz] = '\\0';\n    }\n    pcv->len = sz;\n    return tagptr(pcv, TAG_CVALUE);\n}\n\nvalue_t cvalue_from_data(fl_context_t *fl_ctx, fltype_t *type, void *data, size_t sz)\n{\n    value_t cv;\n    cv = cvalue(fl_ctx, type, sz);\n    memcpy(cptr(cv), data, sz);\n    return cv;\n}\n\n// this effectively dereferences a pointer\n// just like *p in C, it only removes a level of indirection from the type,\n// it doesn't copy any data.\n// this method of creating a cvalue only allocates metadata.\n// ptr is user-managed; we don't autorelease it unless the\n// user explicitly calls (autorelease ) on the result of this function.\n// 'parent' is an optional cvalue that this pointer is known to point\n// into; fl_ctx->NIL if none.\nvalue_t cvalue_from_ref(fl_context_t *fl_ctx, fltype_t *type, void *ptr, size_t sz, value_t parent)\n{\n    cvalue_t *pcv;\n    value_t cv;\n\n    pcv = (cvalue_t*)alloc_words(fl_ctx, CVALUE_NWORDS);\n    pcv->data = ptr;\n    pcv->len = sz;\n    pcv->type = type;\n    if (parent != fl_ctx->NIL) {\n        pcv->type = (fltype_t*)(((uintptr_t)pcv->type) | CV_PARENT_BIT);\n        pcv->parent = parent;\n    }\n    cv = tagptr(pcv, TAG_CVALUE);\n    return cv;\n}\n\nvalue_t cvalue_string(fl_context_t *fl_ctx, size_t sz)\n{\n    return cvalue(fl_ctx, fl_ctx->stringtype, sz);\n}\n\nvalue_t cvalue_static_cstrn(fl_context_t *fl_ctx, const char *str, size_t n)\n{\n    return cvalue_from_ref(fl_ctx, fl_ctx->stringtype, (char*)str, n, fl_ctx->NIL);\n}\n\nvalue_t cvalue_static_cstring(fl_context_t *fl_ctx, const char *str)\n{\n    return cvalue_static_cstrn(fl_ctx, str, strlen(str));\n}\n\nvalue_t string_from_cstrn(fl_context_t *fl_ctx, char *str, size_t n)\n{\n    value_t v = cvalue_string(fl_ctx, n);\n    memcpy(cvalue_data(v), str, n);\n    return v;\n}\n\nvalue_t string_from_cstr(fl_context_t *fl_ctx, char *str)\n{\n    return string_from_cstrn(fl_ctx, str, strlen(str));\n}\n\nint fl_isstring(fl_context_t *fl_ctx, value_t v)\n{\n    return (iscvalue(v) && cv_isstr(fl_ctx, (cvalue_t*)ptr(v)));\n}\n\n// convert to malloc representation (fixed address)\nvoid cv_pin(fl_context_t *fl_ctx, cvalue_t *cv)\n{\n    if (!isinlined(cv))\n        return;\n    size_t sz = cv_len(cv);\n    if (cv_isstr(fl_ctx, cv)) sz++;\n    void *data = malloc(sz);\n    memcpy(data, cv_data(cv), sz);\n    cv->data = data;\n    autorelease(fl_ctx, cv);\n}\n\n#define num_init(ctype, cnvt, tag)                                     \\\nstatic int cvalue_##ctype##_init(fl_context_t *fl_ctx, fltype_t *type, \\\n                                 value_t arg, void *dest)              \\\n{                                                                      \\\n    fl_##ctype##_t n=0;                                                \\\n    (void)type;                                                        \\\n    if (isfixnum(arg)) {                                               \\\n        n = numval(arg);                                               \\\n    }                                                                  \\\n    else if (iscprim(arg)) {                                           \\\n        cprim_t *cp = (cprim_t*)ptr(arg);                              \\\n        void *p = cp_data(cp);                                         \\\n        n = (fl_##ctype##_t)conv_to_##cnvt(p, cp_numtype(cp));         \\\n    }                                                                  \\\n    else {                                                             \\\n        return 1;                                                      \\\n    }                                                                  \\\n    *((fl_##ctype##_t*)dest) = n;                                      \\\n    return 0;                                                          \\\n}\nnum_init(int8, int32, T_INT8)\nnum_init(uint8, uint32, T_UINT8)\nnum_init(int16, int32, T_INT16)\nnum_init(uint16, uint32, T_UINT16)\nnum_init(int32, int32, T_INT32)\nnum_init(uint32, uint32, T_UINT32)\nnum_init(int64, int64, T_INT64)\nnum_init(uint64, uint64, T_UINT64)\nnum_init(float, double, T_FLOAT)\nnum_init(double, double, T_DOUBLE)\n\n#define num_ctor_init(typenam, ctype, tag)                              \\\nvalue_t cvalue_##typenam(fl_context_t *fl_ctx, value_t *args, uint32_t nargs) \\\n{                                                                       \\\n    if (nargs==0) { PUSH(fl_ctx, fixnum(0)); args = &fl_ctx->Stack[fl_ctx->SP-1]; } \\\n    value_t cp = cprim(fl_ctx, fl_ctx->typenam##type, sizeof(fl_##ctype##_t)); \\\n    if (cvalue_##ctype##_init(fl_ctx, fl_ctx->typenam##type,            \\\n                              args[0], cp_data((cprim_t*)ptr(cp))))     \\\n        type_error(fl_ctx, #typenam, \"number\", args[0]);                \\\n    return cp;                                                          \\\n}\n\n#define num_ctor_ctor(typenam, ctype, tag)                              \\\nvalue_t mk_##typenam(fl_context_t *fl_ctx, fl_##ctype##_t n)            \\\n{                                                                       \\\n    value_t cp = cprim(fl_ctx, fl_ctx->typenam##type, sizeof(fl_##ctype##_t)); \\\n    *(fl_##ctype##_t*)cp_data((cprim_t*)ptr(cp)) = n;                   \\\n    return cp;                                                          \\\n}\n\n#define num_ctor(typenam, ctype, tag)  \\\n    num_ctor_init(typenam, ctype, tag) \\\n    num_ctor_ctor(typenam, ctype, tag)\n\nnum_ctor(int8, int8, T_INT8)\nnum_ctor(uint8, uint8, T_UINT8)\nnum_ctor(int16, int16, T_INT16)\nnum_ctor(uint16, uint16, T_UINT16)\nnum_ctor(int32, int32, T_INT32)\nnum_ctor(uint32, uint32, T_UINT32)\nnum_ctor(int64, int64, T_INT64)\nnum_ctor(uint64, uint64, T_UINT64)\nnum_ctor(byte,  uint8, T_UINT8)\nnum_ctor(wchar, int32, T_INT32)\n#ifdef _P64\nnum_ctor(ptrdiff, int64, T_INT64)\nnum_ctor(size, uint64, T_UINT64)\n#else\nnum_ctor(ptrdiff, int32, T_INT32)\nnum_ctor(size, uint32, T_UINT32)\n#endif\nnum_ctor(float, float, T_FLOAT)\nnum_ctor(double, double, T_DOUBLE)\n\nvalue_t size_wrap(fl_context_t *fl_ctx, size_t sz)\n{\n    if (fits_fixnum(sz))\n        return fixnum(sz);\n    assert(sizeof(void*) == sizeof(size_t));\n    return mk_size(fl_ctx, sz);\n}\n\nsize_t tosize(fl_context_t *fl_ctx, value_t n, const char *fname)\n{\n    if (isfixnum(n))\n        return numval(n);\n    if (iscprim(n)) {\n        cprim_t *cp = (cprim_t*)ptr(n);\n        return conv_to_size(cp_data(cp), cp_numtype(cp));\n    }\n    type_error(fl_ctx, fname, \"number\", n);\n    return 0;\n}\n\nstatic int isarray(value_t v)\n{\n    return iscvalue(v) && cv_class((cvalue_t*)ptr(v))->eltype != NULL;\n}\n\nstatic size_t predict_arraylen(fl_context_t *fl_ctx, value_t arg)\n{\n    if (isvector(arg))\n        return vector_size(arg);\n    else if (iscons(arg))\n        return llength(arg);\n    else if (arg == fl_ctx->NIL)\n        return 0;\n    if (isarray(arg))\n        return cvalue_arraylen(arg);\n    return 1;\n}\n\nstatic int cvalue_array_init(fl_context_t *fl_ctx, fltype_t *ft, value_t arg, void *dest)\n{\n    value_t type = ft->type;\n    size_t elsize, i, cnt, sz;\n    fltype_t *eltype = ft->eltype;\n\n    elsize = ft->elsz;\n    cnt = predict_arraylen(fl_ctx, arg);\n\n    if (iscons(cdr_(cdr_(type)))) {\n        size_t tc = tosize(fl_ctx, car_(cdr_(cdr_(type))), \"array\");\n        if (tc != cnt)\n            lerror(fl_ctx, fl_ctx->ArgError, \"array: size mismatch\");\n    }\n\n    sz = elsize * cnt;\n\n    if (isvector(arg)) {\n        for(i=0; i < cnt; i++) {\n            cvalue_init(fl_ctx, eltype, vector_elt(arg,i), dest);\n            dest = (char *)dest + elsize;\n        }\n        return 0;\n    }\n    else if (iscons(arg) || arg==fl_ctx->NIL) {\n        i = 0;\n        while (iscons(arg)) {\n            if (i == cnt) { i++; break; } // trigger error\n            cvalue_init(fl_ctx, eltype, car_(arg), dest);\n            i++;\n            dest = (char *)dest + elsize;\n            arg = cdr_(arg);\n        }\n        if (i != cnt)\n            lerror(fl_ctx, fl_ctx->ArgError, \"array: size mismatch\");\n        return 0;\n    }\n    else if (iscvalue(arg)) {\n        cvalue_t *cv = (cvalue_t*)ptr(arg);\n        if (isarray(arg)) {\n            fltype_t *aet = cv_class(cv)->eltype;\n            if (aet == eltype) {\n                if (cv_len(cv) == sz)\n                    memcpy(dest, cv_data(cv), sz);\n                else\n                    lerror(fl_ctx, fl_ctx->ArgError, \"array: size mismatch\");\n                return 0;\n            }\n            else {\n                // TODO: initialize array from different type elements\n                lerror(fl_ctx, fl_ctx->ArgError, \"array: element type mismatch\");\n            }\n        }\n    }\n    if (cnt == 1)\n        cvalue_init(fl_ctx, eltype, arg, dest);\n    else\n        type_error(fl_ctx, \"array\", \"sequence\", arg);\n    return 0;\n}\n\nvalue_t cvalue_array(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    size_t elsize, cnt, sz, i;\n    value_t arg;\n\n    if (nargs < 1)\n        argcount(fl_ctx, \"array\", nargs, 1);\n\n    cnt = nargs - 1;\n    fltype_t *type = get_array_type(fl_ctx, args[0]);\n    elsize = type->elsz;\n    sz = elsize * cnt;\n\n    value_t cv = cvalue(fl_ctx, type, sz);\n    char *dest = (char*)cv_data((cvalue_t*)ptr(cv));\n    FOR_ARGS(i,1,arg,args) {\n        cvalue_init(fl_ctx, type->eltype, arg, dest);\n        dest += elsize;\n    }\n    return cv;\n}\n\n// NOTE: v must be an array\nsize_t cvalue_arraylen(value_t v)\n{\n    cvalue_t *cv = (cvalue_t*)ptr(v);\n    return cv_len(cv)/(cv_class(cv)->elsz);\n}\n\n// *palign is an output argument giving the alignment required by type\nsize_t ctype_sizeof(fl_context_t *fl_ctx, value_t type, int *palign)\n{\n    if (type == fl_ctx->int8sym || type == fl_ctx->uint8sym || type == fl_ctx->bytesym) {\n        *palign = 1;\n        return 1;\n    }\n    if (type == fl_ctx->int16sym || type == fl_ctx->uint16sym) {\n        *palign = ALIGN2;\n        return 2;\n    }\n    if (type == fl_ctx->int32sym || type == fl_ctx->uint32sym || type == fl_ctx->wcharsym ||\n        type == fl_ctx->floatsym) {\n        *palign = ALIGN4;\n        return 4;\n    }\n    if (type == fl_ctx->int64sym || type == fl_ctx->uint64sym || type == fl_ctx->doublesym) {\n        *palign = ALIGN8;\n        return 8;\n    }\n    if (type == fl_ctx->ptrdiffsym || type == fl_ctx->sizesym) {\n#ifdef _P64\n        *palign = ALIGN8;\n        return 8;\n#else\n        *palign = ALIGN4;\n        return 4;\n#endif\n    }\n    if (iscons(type)) {\n        value_t hed = car_(type);\n        if (hed == fl_ctx->pointersym || hed == fl_ctx->cfunctionsym) {\n            *palign = ALIGNPTR;\n            return sizeof(void*);\n        }\n        if (hed == fl_ctx->arraysym) {\n            value_t t = car(fl_ctx, cdr_(type));\n            if (!iscons(cdr_(cdr_(type))))\n                lerror(fl_ctx, fl_ctx->ArgError, \"sizeof: incomplete type\");\n            value_t n = car_(cdr_(cdr_(type)));\n            size_t sz = tosize(fl_ctx, n, \"sizeof\");\n            return sz * ctype_sizeof(fl_ctx, t, palign);\n        }\n    }\n    lerror(fl_ctx, fl_ctx->ArgError, \"sizeof: invalid c type\");\n    return 0;\n}\n\n// get pointer and size for any plain-old-data value\nvoid to_sized_ptr(fl_context_t *fl_ctx, value_t v, const char *fname, char **pdata, size_t *psz)\n{\n    if (iscvalue(v)) {\n        cvalue_t *pcv = (cvalue_t*)ptr(v);\n        ios_t *x = value2c(ios_t*,v);\n        if (cv_class(pcv) == fl_ctx->iostreamtype && (x->bm == bm_mem)) {\n            *pdata = x->buf;\n            *psz = (size_t)x->size;\n            return;\n        }\n        else if (cv_isPOD(pcv)) {\n            *pdata = (char*)cv_data(pcv);\n            *psz = cv_len(pcv);\n            return;\n        }\n    }\n    else if (iscprim(v)) {\n        cprim_t *pcp = (cprim_t*)ptr(v);\n        *pdata = cp_data(pcp);\n        *psz = cp_class(pcp)->size;\n        return;\n    }\n    type_error(fl_ctx, fname, \"plain-old-data\", v);\n}\n\nvalue_t cvalue_sizeof(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    argcount(fl_ctx, \"sizeof\", nargs, 1);\n    if (issymbol(args[0]) || iscons(args[0])) {\n        int a;\n        return size_wrap(fl_ctx, ctype_sizeof(fl_ctx, args[0], &a));\n    }\n    size_t n; char *data;\n    to_sized_ptr(fl_ctx, args[0], \"sizeof\", &data, &n);\n    return size_wrap(fl_ctx, n);\n}\n\nvalue_t cvalue_typeof(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    argcount(fl_ctx, \"typeof\", nargs, 1);\n    switch(tag(args[0])) {\n    case TAG_CONS: return fl_ctx->pairsym;\n    case TAG_NUM1:\n    case TAG_NUM:  return fl_ctx->fixnumsym;\n    case TAG_SYM:  return fl_ctx->symbolsym;\n    case TAG_VECTOR: return fl_ctx->vectorsym;\n    case TAG_FUNCTION:\n        if (args[0] == fl_ctx->T || args[0] == fl_ctx->F)\n            return fl_ctx->booleansym;\n        if (args[0] == fl_ctx->NIL)\n            return fl_ctx->nullsym;\n        if (args[0] == fl_ctx->FL_EOF)\n            return symbol(fl_ctx, \"eof-object\");\n        if (isbuiltin(args[0]))\n            return fl_ctx->builtinsym;\n        return fl_ctx->FUNCTION;\n    }\n    return cv_type((cvalue_t*)ptr(args[0]));\n}\n\nstatic value_t cvalue_relocate(fl_context_t *fl_ctx, value_t v)\n{\n    size_t nw;\n    cvalue_t *cv = (cvalue_t*)ptr(v);\n    cvalue_t *nv;\n    value_t ncv;\n\n    nw = cv_nwords(fl_ctx, cv);\n    nv = (cvalue_t*)alloc_words(fl_ctx, nw);\n    memcpy(nv, cv, nw*sizeof(value_t));\n    if (isinlined(cv))\n        nv->data = &nv->_space[0];\n    ncv = tagptr(nv, TAG_CVALUE);\n    fltype_t *t = cv_class(cv);\n    if (t->vtable != NULL && t->vtable->relocate != NULL)\n        t->vtable->relocate(fl_ctx, v, ncv);\n    forward(v, ncv);\n    return ncv;\n}\n\nvalue_t cvalue_copy(fl_context_t *fl_ctx, value_t v)\n{\n    assert(iscvalue(v));\n    PUSH(fl_ctx, v);\n    cvalue_t *cv = (cvalue_t*)ptr(v);\n    size_t nw = cv_nwords(fl_ctx, cv);\n    cvalue_t *ncv = (cvalue_t*)alloc_words(fl_ctx, nw);\n    v = POP(fl_ctx); cv = (cvalue_t*)ptr(v);\n    memcpy(ncv, cv, nw * sizeof(value_t));\n    if (!isinlined(cv)) {\n        size_t len = cv_len(cv);\n        if (cv_isstr(fl_ctx, cv)) len++;\n        ncv->data = malloc(len);\n        memcpy(ncv->data, cv_data(cv), len);\n        autorelease(fl_ctx, ncv);\n        if (hasparent(cv)) {\n            ncv->type = (fltype_t*)(((uintptr_t)ncv->type) & ~CV_PARENT_BIT);\n            ncv->parent = fl_ctx->NIL;\n        }\n    }\n    else {\n        ncv->data = &ncv->_space[0];\n    }\n\n    return tagptr(ncv, TAG_CVALUE);\n}\n\nvalue_t fl_copy(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    argcount(fl_ctx, \"copy\", nargs, 1);\n    if (iscons(args[0]) || isvector(args[0]))\n        lerror(fl_ctx, fl_ctx->ArgError, \"copy: argument must be a leaf atom\");\n    if (!iscvalue(args[0]))\n        return args[0];\n    if (!cv_isPOD((cvalue_t*)ptr(args[0])))\n        lerror(fl_ctx, fl_ctx->ArgError, \"copy: argument must be a plain-old-data type\");\n    return cvalue_copy(fl_ctx, args[0]);\n}\n\nvalue_t fl_podp(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    argcount(fl_ctx, \"plain-old-data?\", nargs, 1);\n    return (iscprim(args[0]) ||\n            (iscvalue(args[0]) && cv_isPOD((cvalue_t*)ptr(args[0])))) ?\n        fl_ctx->T : fl_ctx->F;\n}\n\nstatic void cvalue_init(fl_context_t *fl_ctx, fltype_t *type, value_t v, void *dest)\n{\n    cvinitfunc_t f=type->init;\n\n    if (f == NULL)\n        lerror(fl_ctx, fl_ctx->ArgError, \"c-value: invalid c type\");\n\n    f(fl_ctx, type, v, dest);\n}\n\nstatic numerictype_t sym_to_numtype(fl_context_t *fl_ctx, value_t type)\n{\n    if (type == fl_ctx->int8sym)\n        return T_INT8;\n    else if (type == fl_ctx->uint8sym || type == fl_ctx->bytesym)\n        return T_UINT8;\n    else if (type == fl_ctx->int16sym)\n        return T_INT16;\n    else if (type == fl_ctx->uint16sym)\n        return T_UINT16;\n#ifdef _P64\n    else if (type == fl_ctx->int32sym || type == fl_ctx->wcharsym)\n#else\n    else if (type == fl_ctx->int32sym || type == fl_ctx->wcharsym || type == fl_ctx->ptrdiffsym)\n#endif\n        return T_INT32;\n#ifdef _P64\n    else if (type == fl_ctx->uint32sym)\n#else\n    else if (type == fl_ctx->uint32sym || type == fl_ctx->sizesym)\n#endif\n        return T_UINT32;\n#ifdef _P64\n    else if (type == fl_ctx->int64sym || type == fl_ctx->ptrdiffsym)\n#else\n    else if (type == fl_ctx->int64sym)\n#endif\n        return T_INT64;\n#ifdef _P64\n    else if (type == fl_ctx->uint64sym || type == fl_ctx->sizesym)\n#else\n    else if (type == fl_ctx->uint64sym)\n#endif\n        return T_UINT64;\n    else if (type == fl_ctx->floatsym)\n        return T_FLOAT;\n    else if (type == fl_ctx->doublesym)\n        return T_DOUBLE;\n    return (numerictype_t)N_NUMTYPES;\n}\n\n// (new type . args)\n// this provides (1) a way to allocate values with a shared type for\n// efficiency, (2) a uniform interface for allocating cvalues of any\n// type, including user-defined.\nvalue_t cvalue_new(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    if (nargs < 1 || nargs > 2)\n        argcount(fl_ctx, \"c-value\", nargs, 2);\n    value_t type = args[0];\n    fltype_t *ft = get_type(fl_ctx, type);\n    value_t cv;\n    if (ft->eltype != NULL) {\n        // special case to handle incomplete array types bla[]\n        size_t elsz = ft->elsz;\n        size_t cnt;\n\n        if (iscons(cdr_(cdr_(type))))\n            cnt = tosize(fl_ctx, car_(cdr_(cdr_(type))), \"array\");\n        else if (nargs == 2)\n            cnt = predict_arraylen(fl_ctx, args[1]);\n        else\n            cnt = 0;\n        cv = cvalue(fl_ctx, ft, elsz * cnt);\n        if (nargs == 2)\n            cvalue_array_init(fl_ctx, ft, args[1], cv_data((cvalue_t*)ptr(cv)));\n    }\n    else {\n        cv = cvalue(fl_ctx, ft, ft->size);\n        if (nargs == 2)\n            cvalue_init(fl_ctx, ft, args[1], cptr(cv));\n    }\n    return cv;\n}\n\n// NOTE: this only compares lexicographically; it ignores numeric formats\nvalue_t cvalue_compare(value_t a, value_t b)\n{\n    cvalue_t *ca = (cvalue_t*)ptr(a);\n    cvalue_t *cb = (cvalue_t*)ptr(b);\n    char *adata = (char*)cv_data(ca);\n    char *bdata = (char*)cv_data(cb);\n    size_t asz = cv_len(ca);\n    size_t bsz = cv_len(cb);\n    size_t minsz = asz < bsz ? asz : bsz;\n    int diff = memcmp(adata, bdata, minsz);\n    if (diff == 0) {\n        if (asz > bsz)\n            return fixnum(1);\n        else if (asz < bsz)\n            return fixnum(-1);\n    }\n    return fixnum(diff);\n}\n\nstatic void check_addr_args(fl_context_t *fl_ctx, const char *fname, value_t arr,\n                            value_t ind, char **data, size_t *index)\n{\n    size_t numel;\n    cvalue_t *cv = (cvalue_t*)ptr(arr);\n    *data = (char*)cv_data(cv);\n    numel = cv_len(cv)/(cv_class(cv)->elsz);\n    *index = tosize(fl_ctx, ind, fname);\n    if (*index >= numel)\n        bounds_error(fl_ctx, fname, arr, ind);\n}\n\nstatic value_t cvalue_array_aref(fl_context_t *fl_ctx, value_t *args)\n{\n    char *data; size_t index;\n    fltype_t *eltype = cv_class((cvalue_t*)ptr(args[0]))->eltype;\n    value_t el = 0;\n    numerictype_t nt = eltype->numtype;\n    if (nt >= T_INT32)\n        el = cvalue(fl_ctx, eltype, eltype->size);\n    check_addr_args(fl_ctx, \"aref\", args[0], args[1], &data, &index);\n    if (nt < T_INT32) {\n        if (nt == T_INT8)\n            return fixnum((int8_t)data[index]);\n        else if (nt == T_UINT8)\n            return fixnum((uint8_t)data[index]);\n        else if (nt == T_INT16)\n            return fixnum(((int16_t*)data)[index]);\n        return fixnum(((uint16_t*)data)[index]);\n    }\n    char *dest = (char*)cptr(el);\n    size_t sz = eltype->size;\n    if (sz == 1)\n        *dest = data[index];\n    else if (sz == 2)\n        *(int16_t*)dest = ((int16_t*)data)[index];\n    else if (sz == 4)\n        *(int32_t*)dest = ((int32_t*)data)[index];\n    else if (sz == 8)\n        *(int64_t*)dest = ((int64_t*)data)[index];\n    else\n        memcpy(dest, data + index*sz, sz);\n    return el;\n}\n\nstatic value_t cvalue_array_aset(fl_context_t *fl_ctx, value_t *args)\n{\n    char *data; size_t index;\n    fltype_t *eltype = cv_class((cvalue_t*)ptr(args[0]))->eltype;\n    check_addr_args(fl_ctx, \"aset!\", args[0], args[1], &data, &index);\n    char *dest = data + index*eltype->size;\n    cvalue_init(fl_ctx, eltype, args[2], dest);\n    return args[2];\n}\n\nvalue_t fl_builtin(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    argcount(fl_ctx, \"builtin\", nargs, 1);\n    symbol_t *name = tosymbol(fl_ctx, args[0], \"builtin\");\n    cvalue_t *cv;\n    if (ismanaged(fl_ctx, args[0]) || (cv=(cvalue_t*)name->dlcache) == NULL) {\n        lerrorf(fl_ctx, fl_ctx->ArgError, \"builtin: function %s not found\", name->name);\n    }\n    return tagptr(cv, TAG_CVALUE);\n}\n\nvalue_t cbuiltin(fl_context_t *fl_ctx, const char *name, builtin_t f)\n{\n    cvalue_t *cv = (cvalue_t*)malloc(CVALUE_NWORDS * sizeof(value_t));\n    cv->type = fl_ctx->builtintype;\n    cv->data = &cv->_space[0];\n    cv->len = sizeof(value_t);\n    *(void**)cv->data = (void*)(uintptr_t)f;\n\n    value_t sym = symbol(fl_ctx, name);\n    ((symbol_t*)ptr(sym))->dlcache = cv;\n    ptrhash_put(&fl_ctx->reverse_dlsym_lookup_table, cv, (void*)sym);\n\n    return tagptr(cv, TAG_CVALUE);\n}\n\nstatic value_t fl_logand(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nstatic value_t fl_logior(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nstatic value_t fl_logxor(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nstatic value_t fl_lognot(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\nstatic value_t fl_ash(fl_context_t *fl_ctx, value_t *args, uint32_t nargs);\n\nstatic const builtinspec_t cvalues_builtin_info[] = {\n    { \"c-value\", cvalue_new },\n    { \"typeof\", cvalue_typeof },\n    { \"sizeof\", cvalue_sizeof },\n    { \"builtin\", fl_builtin },\n    { \"copy\", fl_copy },\n    { \"plain-old-data?\", fl_podp },\n\n    { \"logand\", fl_logand },\n    { \"logior\", fl_logior },\n    { \"logxor\", fl_logxor },\n    { \"lognot\", fl_lognot },\n    { \"ash\", fl_ash },\n    // todo: autorelease\n    { NULL, NULL }\n};\n\n#define cv_intern(fl_ctx, tok) fl_ctx->tok##sym = symbol(fl_ctx, #tok)\n#define ctor_cv_intern(fl_ctx, tok)                             \\\n    cv_intern(fl_ctx, tok);                                     \\\n    set(fl_ctx->tok##sym, cbuiltin(fl_ctx, #tok, cvalue_##tok))\n\n#define mk_primtype(fl_ctx, name)                               \\\n    fl_ctx->name##type = get_type(fl_ctx, fl_ctx->name##sym);   \\\n    fl_ctx->name##type->init = &cvalue_##name##_init\n\n#define mk_primtype_(fl_ctx, name, ctype)                       \\\n    fl_ctx->name##type = get_type(fl_ctx, fl_ctx->name##sym);   \\\n    fl_ctx->name##type->init = &cvalue_##ctype##_init\n\nstatic void cvalues_init(fl_context_t *fl_ctx)\n{\n    fl_ctx->malloc_pressure = 0;\n    fl_ctx->Finalizers = NULL;\n    fl_ctx->nfinalizers = 0;\n    fl_ctx->maxfinalizers = 0;\n\n    htable_new(&fl_ctx->TypeTable, 256);\n    htable_new(&fl_ctx->reverse_dlsym_lookup_table, 256);\n\n    fl_ctx->builtintype = define_opaque_type(fl_ctx->builtinsym, sizeof(builtin_t), NULL, NULL);\n\n    ctor_cv_intern(fl_ctx, int8);\n    ctor_cv_intern(fl_ctx, uint8);\n    ctor_cv_intern(fl_ctx, int16);\n    ctor_cv_intern(fl_ctx, uint16);\n    ctor_cv_intern(fl_ctx, int32);\n    ctor_cv_intern(fl_ctx, uint32);\n    ctor_cv_intern(fl_ctx, int64);\n    ctor_cv_intern(fl_ctx, uint64);\n    ctor_cv_intern(fl_ctx, byte);\n    ctor_cv_intern(fl_ctx, wchar);\n    ctor_cv_intern(fl_ctx, ptrdiff);\n    ctor_cv_intern(fl_ctx, size);\n    ctor_cv_intern(fl_ctx, float);\n    ctor_cv_intern(fl_ctx, double);\n\n    ctor_cv_intern(fl_ctx, array);\n    cv_intern(fl_ctx, pointer);\n    cv_intern(fl_ctx, void);\n    fl_ctx->cfunctionsym = symbol(fl_ctx, \"c-function\");\n\n    assign_global_builtins(fl_ctx, cvalues_builtin_info);\n\n    fl_ctx->stringtypesym = symbol(fl_ctx, \"*string-type*\");\n    setc(fl_ctx->stringtypesym, fl_list2(fl_ctx, fl_ctx->arraysym, fl_ctx->bytesym));\n\n    fl_ctx->wcstringtypesym = symbol(fl_ctx, \"*wcstring-type*\");\n    setc(fl_ctx->wcstringtypesym, fl_list2(fl_ctx, fl_ctx->arraysym, fl_ctx->wcharsym));\n\n    mk_primtype(fl_ctx, int8);\n    mk_primtype(fl_ctx, uint8);\n    mk_primtype(fl_ctx, int16);\n    mk_primtype(fl_ctx, uint16);\n    mk_primtype(fl_ctx, int32);\n    mk_primtype(fl_ctx, uint32);\n    mk_primtype(fl_ctx, int64);\n    mk_primtype(fl_ctx, uint64);\n#ifdef _P64\n    mk_primtype_(fl_ctx, ptrdiff, int64);\n    mk_primtype_(fl_ctx, size, uint64);\n#else\n    mk_primtype_(fl_ctx, ptrdiff, int32);\n    mk_primtype_(fl_ctx, size, uint32);\n#endif\n    mk_primtype_(fl_ctx, byte, uint8);\n    mk_primtype_(fl_ctx, wchar, int32);\n    mk_primtype(fl_ctx, float);\n    mk_primtype(fl_ctx, double);\n\n    fl_ctx->stringtype = get_type(fl_ctx, symbol_value(fl_ctx->stringtypesym));\n    fl_ctx->wcstringtype = get_type(fl_ctx, symbol_value(fl_ctx->wcstringtypesym));\n\n    fl_ctx->emptystringsym = symbol(fl_ctx, \"*empty-string*\");\n    setc(fl_ctx->emptystringsym, cvalue_static_cstring(fl_ctx, \"\"));\n}\n\n#define RETURN_NUM_AS(fl_ctx, var, type) return(mk_##type(fl_ctx, (fl_##type##_t)var))\n\nvalue_t return_from_uint64(fl_context_t *fl_ctx, uint64_t Uaccum)\n{\n    if (fits_fixnum(Uaccum)) {\n        return fixnum((fixnum_t)Uaccum);\n    }\n    if (Uaccum > (uint64_t)S64_MAX) {\n        RETURN_NUM_AS(fl_ctx, Uaccum, uint64);\n    }\n    else if (Uaccum > (uint64_t)INT_MAX) {\n        RETURN_NUM_AS(fl_ctx, Uaccum, int64);\n    }\n    RETURN_NUM_AS(fl_ctx, Uaccum, int32);\n}\n\nvalue_t return_from_int64(fl_context_t *fl_ctx, int64_t Saccum)\n{\n    if (fits_fixnum(Saccum)) {\n        return fixnum((fixnum_t)Saccum);\n    }\n    if (Saccum > (int64_t)INT_MAX || Saccum < (int64_t)INT_MIN) {\n        RETURN_NUM_AS(fl_ctx, Saccum, int64);\n    }\n    RETURN_NUM_AS(fl_ctx, Saccum, int32);\n}\n\nstatic value_t fl_add_any(fl_context_t *fl_ctx, value_t *args, uint32_t nargs, fixnum_t carryIn)\n{\n    uint64_t Uaccum=0;\n    int64_t Saccum = carryIn;\n    double Faccum=0;\n    uint32_t i;\n    value_t arg=fl_ctx->NIL;\n\n    FOR_ARGS(i,0,arg,args) {\n        if (isfixnum(arg)) {\n            Saccum += numval(arg);\n            continue;\n        }\n        else if (iscprim(arg)) {\n            cprim_t *cp = (cprim_t*)ptr(arg);\n            void *a = cp_data(cp);\n            int64_t i64;\n            switch(cp_numtype(cp)) {\n            case T_INT8:   Saccum += *(int8_t*)a; break;\n            case T_UINT8:  Saccum += *(uint8_t*)a; break;\n            case T_INT16:  Saccum += *(int16_t*)a; break;\n            case T_UINT16: Saccum += *(uint16_t*)a; break;\n            case T_INT32:  Saccum += *(int32_t*)a; break;\n            case T_UINT32: Saccum += *(uint32_t*)a; break;\n            case T_INT64:\n                i64 = *(int64_t*)a;\n                if (i64 > 0)\n                    Uaccum += (uint64_t)i64;\n                else\n                    Saccum += i64;\n                break;\n            case T_UINT64: Uaccum += *(uint64_t*)a; break;\n            case T_FLOAT:  Faccum += *(float*)a; break;\n            case T_DOUBLE: Faccum += *(double*)a; break;\n            default:\n                goto add_type_error;\n            }\n            continue;\n        }\n    add_type_error:\n        type_error(fl_ctx, \"+\", \"number\", arg);\n    }\n    if (Faccum != 0) {\n        Faccum += Uaccum;\n        Faccum += Saccum;\n        return mk_double(fl_ctx, Faccum);\n    }\n    else if (Saccum < 0) {\n        uint64_t negpart = (uint64_t)(-Saccum);\n        if (negpart > Uaccum) {\n            Saccum += (int64_t)Uaccum;\n            // return value in Saccum\n            if (Saccum >= INT_MIN) {\n                if (fits_fixnum(Saccum)) {\n                    return fixnum((fixnum_t)Saccum);\n                }\n                RETURN_NUM_AS(fl_ctx, Saccum, int32);\n            }\n            RETURN_NUM_AS(fl_ctx, Saccum, int64);\n        }\n        Uaccum -= negpart;\n    }\n    else {\n        Uaccum += (uint64_t)Saccum;\n    }\n    // return value in Uaccum\n    return return_from_uint64(fl_ctx, Uaccum);\n}\n\nstatic value_t fl_neg(fl_context_t *fl_ctx, value_t n)\n{\n    if (isfixnum(n)) {\n        return fixnum(-numval(n));\n    }\n    else if (iscprim(n)) {\n        cprim_t *cp = (cprim_t*)ptr(n);\n        void *a = cp_data(cp);\n        uint32_t ui32;\n        int32_t i32;\n        int64_t i64;\n        switch(cp_numtype(cp)) {\n        case T_INT8:   return fixnum(-(int32_t)*(int8_t*)a);\n        case T_UINT8:  return fixnum(-(int32_t)*(uint8_t*)a);\n        case T_INT16:  return fixnum(-(int32_t)*(int16_t*)a);\n        case T_UINT16: return fixnum(-(int32_t)*(uint16_t*)a);\n        case T_INT32:\n            i32 = *(int32_t*)a;\n            if (i32 == (int32_t)BIT31)\n                return mk_uint32(fl_ctx, (uint32_t)BIT31);\n            return mk_int32(fl_ctx, -i32);\n        case T_UINT32:\n            ui32 = *(uint32_t*)a;\n            if (ui32 <= ((uint32_t)INT_MAX)+1) return mk_int32(fl_ctx, -(int32_t)ui32);\n            return mk_int64(fl_ctx, -(int64_t)ui32);\n        case T_INT64:\n            i64 = *(int64_t*)a;\n            if (i64 == (int64_t)BIT63)\n                return mk_uint64(fl_ctx, (uint64_t)BIT63);\n            return mk_int64(fl_ctx, -i64);\n        case T_UINT64: return mk_int64(fl_ctx, -(int64_t)*(uint64_t*)a);\n        case T_FLOAT:  return mk_float(fl_ctx, -*(float*)a);\n        case T_DOUBLE: return mk_double(fl_ctx, -*(double*)a);\n            break;\n        }\n    }\n    type_error(fl_ctx, \"-\", \"number\", n);\n}\n\nstatic value_t fl_mul_any(fl_context_t *fl_ctx, value_t *args, uint32_t nargs, int64_t Saccum)\n{\n    uint64_t Uaccum=1;\n    double Faccum=1;\n    uint32_t i;\n    value_t arg=fl_ctx->NIL;\n\n    FOR_ARGS(i,0,arg,args) {\n        if (isfixnum(arg)) {\n            Saccum *= numval(arg);\n            continue;\n        }\n        else if (iscprim(arg)) {\n            cprim_t *cp = (cprim_t*)ptr(arg);\n            void *a = cp_data(cp);\n            int64_t i64;\n            switch(cp_numtype(cp)) {\n            case T_INT8:   Saccum *= *(int8_t*)a; break;\n            case T_UINT8:  Saccum *= *(uint8_t*)a; break;\n            case T_INT16:  Saccum *= *(int16_t*)a; break;\n            case T_UINT16: Saccum *= *(uint16_t*)a; break;\n            case T_INT32:  Saccum *= *(int32_t*)a; break;\n            case T_UINT32: Saccum *= *(uint32_t*)a; break;\n            case T_INT64:\n                i64 = *(int64_t*)a;\n                if (i64 > 0)\n                    Uaccum *= (uint64_t)i64;\n                else\n                    Saccum *= i64;\n                break;\n            case T_UINT64: Uaccum *= *(uint64_t*)a; break;\n            case T_FLOAT:  Faccum *= *(float*)a; break;\n            case T_DOUBLE: Faccum *= *(double*)a; break;\n            default:\n                goto mul_type_error;\n            }\n            continue;\n        }\n    mul_type_error:\n        type_error(fl_ctx, \"*\", \"number\", arg);\n    }\n    if (Faccum != 1) {\n        Faccum *= Uaccum;\n        Faccum *= Saccum;\n        return mk_double(fl_ctx, Faccum);\n    }\n    else if (Saccum < 0) {\n        Saccum *= (int64_t)Uaccum;\n        if (Saccum >= INT_MIN) {\n            if (fits_fixnum(Saccum)) {\n                return fixnum((fixnum_t)Saccum);\n            }\n            RETURN_NUM_AS(fl_ctx, Saccum, int32);\n        }\n        RETURN_NUM_AS(fl_ctx, Saccum, int64);\n    }\n    else {\n        Uaccum *= (uint64_t)Saccum;\n    }\n    return return_from_uint64(fl_ctx, Uaccum);\n}\n\nstatic int num_to_ptr(value_t a, fixnum_t *pi, numerictype_t *pt, void **pp)\n{\n    cprim_t *cp;\n    if (isfixnum(a)) {\n        *pi = numval(a);\n        *pp = pi;\n        *pt = T_FIXNUM;\n    }\n    else if (iscprim(a)) {\n        cp = (cprim_t*)ptr(a);\n        *pp = cp_data(cp);\n        *pt = cp_numtype(cp);\n    }\n    else {\n        return 0;\n    }\n    return 1;\n}\n\n/*\n  returns -1, 0, or 1 based on ordering of a and b\n  eq: consider equality only, returning 0 or nonzero\n  eqnans: NaNs considered equal to each other\n          -0.0 not considered equal to 0.0\n          inexact not considered equal to exact\n  fname: if not NULL, throws type errors, else returns 2 for type errors\n*/\nint numeric_compare(fl_context_t *fl_ctx, value_t a, value_t b, int eq, int eqnans, char *fname)\n{\n    int_t ai, bi;\n    numerictype_t ta, tb;\n    void *aptr, *bptr;\n\n    if (bothfixnums(a,b)) {\n        if (a==b) return 0;\n        if (numval(a) < numval(b)) return -1;\n        return 1;\n    }\n    if (!num_to_ptr(a, &ai, &ta, &aptr)) {\n        if (fname) type_error(fl_ctx, fname, \"number\", a); else return 2;\n    }\n    if (!num_to_ptr(b, &bi, &tb, &bptr)) {\n        if (fname) type_error(fl_ctx, fname, \"number\", b); else return 2;\n    }\n    if (eq && eqnans && ((ta >= T_FLOAT) != (tb >= T_FLOAT)))\n        return 1;\n    if (cmp_eq(aptr, ta, bptr, tb, eqnans))\n        return 0;\n    if (eq) return 1;\n    if (cmp_lt(aptr, ta, bptr, tb))\n        return -1;\n    return 1;\n}\n\n#if defined(_OS_WINDOWS_)\n__declspec(noreturn) static void DivideByZeroError(fl_context_t *fl_ctx);\n#else\nstatic void DivideByZeroError(fl_context_t *fl_ctx) __attribute__ ((__noreturn__));\n#endif\n\nstatic void DivideByZeroError(fl_context_t *fl_ctx)\n{\n    lerror(fl_ctx, fl_ctx->DivideError, \"/: division by zero\");\n}\n\nstatic value_t fl_div2(fl_context_t *fl_ctx, value_t a, value_t b)\n{\n    double da, db;\n    int_t ai, bi;\n    numerictype_t ta, tb;\n    void *aptr, *bptr;\n\n    if (!num_to_ptr(a, &ai, &ta, &aptr))\n        type_error(fl_ctx, \"/\", \"number\", a);\n    if (!num_to_ptr(b, &bi, &tb, &bptr))\n        type_error(fl_ctx, \"/\", \"number\", b);\n\n    da = conv_to_double(aptr, ta);\n    db = conv_to_double(bptr, tb);\n\n    if (db == 0 && tb < T_FLOAT)  // exact 0\n        DivideByZeroError(fl_ctx);\n\n    da = da/db;\n\n    if (ta < T_FLOAT && tb < T_FLOAT && (double)(int64_t)da == da)\n        return return_from_int64(fl_ctx, (int64_t)da);\n    return mk_double(fl_ctx, da);\n}\n\nstatic value_t fl_idiv2(fl_context_t *fl_ctx, value_t a, value_t b)\n{\n    int_t ai, bi;\n    numerictype_t ta, tb;\n    void *aptr, *bptr;\n    int64_t a64, b64;\n\n    if (!num_to_ptr(a, &ai, &ta, &aptr))\n        type_error(fl_ctx, \"div0\", \"number\", a);\n    if (!num_to_ptr(b, &bi, &tb, &bptr))\n        type_error(fl_ctx, \"div0\", \"number\", b);\n\n    if (ta == T_UINT64) {\n        if (tb == T_UINT64) {\n            if (*(uint64_t*)bptr == 0) goto div_error;\n            return return_from_uint64(fl_ctx, *(uint64_t*)aptr / *(uint64_t*)bptr);\n        }\n        b64 = conv_to_int64(bptr, tb);\n        if (b64 < 0) {\n            return return_from_int64(fl_ctx, -(int64_t)(*(uint64_t*)aptr /\n                                                        (uint64_t)(-b64)));\n        }\n        if (b64 == 0)\n            goto div_error;\n        return return_from_uint64(fl_ctx, *(uint64_t*)aptr / (uint64_t)b64);\n    }\n    if (tb == T_UINT64) {\n        if (*(uint64_t*)bptr == 0) goto div_error;\n        a64 = conv_to_int64(aptr, ta);\n        if (a64 < 0) {\n            return return_from_int64(fl_ctx, -((int64_t)((uint64_t)(-a64) /\n                                                         *(uint64_t*)bptr)));\n        }\n        return return_from_uint64(fl_ctx, (uint64_t)a64 / *(uint64_t*)bptr);\n    }\n\n    b64 = conv_to_int64(bptr, tb);\n    if (b64 == 0) goto div_error;\n\n    return return_from_int64(fl_ctx, conv_to_int64(aptr, ta) / b64);\n div_error:\n    DivideByZeroError(fl_ctx);\n}\n\nstatic value_t fl_bitwise_op(fl_context_t *fl_ctx, value_t a, value_t b, int opcode, char *fname)\n{\n    int_t ai, bi;\n    numerictype_t ta, tb, itmp;\n    void *aptr=NULL, *bptr=NULL, *ptmp;\n    int64_t b64;\n\n    if (!num_to_ptr(a, &ai, &ta, &aptr) || ta >= T_FLOAT)\n        type_error(fl_ctx, fname, \"integer\", a);\n    if (!num_to_ptr(b, &bi, &tb, &bptr) || tb >= T_FLOAT)\n        type_error(fl_ctx, fname, \"integer\", b);\n\n    if (ta < tb) {\n        itmp = ta; ta = tb; tb = itmp;\n        ptmp = aptr; aptr = bptr; bptr = ptmp;\n    }\n    // now a's type is larger than or same as b's\n    b64 = conv_to_int64(bptr, tb);\n    switch (opcode) {\n    case 0:\n    switch (ta) {\n    case T_INT8:   return fixnum(   *(int8_t *)aptr  & (int8_t  )b64);\n    case T_UINT8:  return fixnum(   *(uint8_t *)aptr & (uint8_t )b64);\n    case T_INT16:  return fixnum(   *(int16_t*)aptr  & (int16_t )b64);\n    case T_UINT16: return fixnum(   *(uint16_t*)aptr & (uint16_t)b64);\n    case T_INT32:  return mk_int32(fl_ctx,  *(int32_t*)aptr  & (int32_t )b64);\n    case T_UINT32: return mk_uint32(fl_ctx, *(uint32_t*)aptr & (uint32_t)b64);\n    case T_INT64:  return mk_int64(fl_ctx,  *(int64_t*)aptr  & (int64_t )b64);\n    case T_UINT64: return mk_uint64(fl_ctx, *(uint64_t*)aptr & (uint64_t)b64);\n    case T_FLOAT:\n    case T_DOUBLE: assert(0);\n    }\n    break;\n    case 1:\n    switch (ta) {\n    case T_INT8:   return fixnum(   *(int8_t *)aptr  | (int8_t  )b64);\n    case T_UINT8:  return fixnum(   *(uint8_t *)aptr | (uint8_t )b64);\n    case T_INT16:  return fixnum(   *(int16_t*)aptr  | (int16_t )b64);\n    case T_UINT16: return fixnum(   *(uint16_t*)aptr | (uint16_t)b64);\n    case T_INT32:  return mk_int32(fl_ctx,  *(int32_t*)aptr  | (int32_t )b64);\n    case T_UINT32: return mk_uint32(fl_ctx, *(uint32_t*)aptr | (uint32_t)b64);\n    case T_INT64:  return mk_int64(fl_ctx,  *(int64_t*)aptr  | (int64_t )b64);\n    case T_UINT64: return mk_uint64(fl_ctx, *(uint64_t*)aptr | (uint64_t)b64);\n    case T_FLOAT:\n    case T_DOUBLE: assert(0);\n    }\n    break;\n    case 2:\n    switch (ta) {\n    case T_INT8:   return fixnum(   *(int8_t *)aptr  ^ (int8_t  )b64);\n    case T_UINT8:  return fixnum(   *(uint8_t *)aptr ^ (uint8_t )b64);\n    case T_INT16:  return fixnum(   *(int16_t*)aptr  ^ (int16_t )b64);\n    case T_UINT16: return fixnum(   *(uint16_t*)aptr ^ (uint16_t)b64);\n    case T_INT32:  return mk_int32(fl_ctx,  *(int32_t*)aptr  ^ (int32_t )b64);\n    case T_UINT32: return mk_uint32(fl_ctx, *(uint32_t*)aptr ^ (uint32_t)b64);\n    case T_INT64:  return mk_int64(fl_ctx,  *(int64_t*)aptr  ^ (int64_t )b64);\n    case T_UINT64: return mk_uint64(fl_ctx, *(uint64_t*)aptr ^ (uint64_t)b64);\n    case T_FLOAT:\n    case T_DOUBLE: assert(0);\n    }\n    }\n    assert(0);\n    return fl_ctx->NIL;\n}\n\nstatic value_t fl_logand(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    value_t v, e;\n    int i;\n    if (nargs == 0)\n        return fixnum(-1);\n    v = args[0];\n    FOR_ARGS(i,1,e,args) {\n        if (bothfixnums(v, e))\n            v = v & e;\n        else\n            v = fl_bitwise_op(fl_ctx, v, e, 0, \"logand\");\n    }\n    return v;\n}\n\nstatic value_t fl_logior(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    value_t v, e;\n    int i;\n    if (nargs == 0)\n        return fixnum(0);\n    v = args[0];\n    FOR_ARGS(i,1,e,args) {\n        if (bothfixnums(v, e))\n            v = v | e;\n        else\n            v = fl_bitwise_op(fl_ctx, v, e, 1, \"logior\");\n    }\n    return v;\n}\n\nstatic value_t fl_logxor(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    value_t v, e;\n    int i;\n    if (nargs == 0)\n        return fixnum(0);\n    v = args[0];\n    FOR_ARGS(i,1,e,args) {\n        if (bothfixnums(v, e))\n            v = fixnum(numval(v) ^ numval(e));\n        else\n            v = fl_bitwise_op(fl_ctx, v, e, 2, \"logxor\");\n    }\n    return v;\n}\n\nstatic value_t fl_lognot(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    argcount(fl_ctx, \"lognot\", nargs, 1);\n    value_t a = args[0];\n    if (isfixnum(a))\n        return fixnum(~numval(a));\n    cprim_t *cp;\n    int ta;\n    void *aptr;\n\n    if (iscprim(a)) {\n        cp = (cprim_t*)ptr(a);\n        ta = cp_numtype(cp);\n        aptr = cp_data(cp);\n        switch (ta) {\n        case T_INT8:   return fixnum(~*(int8_t *)aptr);\n        case T_UINT8:  return fixnum(~*(uint8_t *)aptr);\n        case T_INT16:  return fixnum(~*(int16_t *)aptr);\n        case T_UINT16: return fixnum(~*(uint16_t*)aptr);\n        case T_INT32:  return mk_int32(fl_ctx, ~*(int32_t *)aptr);\n        case T_UINT32: return mk_uint32(fl_ctx, ~*(uint32_t*)aptr);\n        case T_INT64:  return mk_int64(fl_ctx, ~*(int64_t *)aptr);\n        case T_UINT64: return mk_uint64(fl_ctx, ~*(uint64_t*)aptr);\n        }\n    }\n    type_error(fl_ctx, \"lognot\", \"integer\", a);\n}\n\nstatic value_t fl_ash(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)\n{\n    fixnum_t n;\n    int64_t accum;\n    argcount(fl_ctx, \"ash\", nargs, 2);\n    value_t a = args[0];\n    n = tofixnum(fl_ctx, args[1], \"ash\");\n    if (isfixnum(a)) {\n        if (n <= 0)\n            return fixnum(numval(a)>>(-n));\n        accum = ((int64_t)numval(a))<<n;\n        if (fits_fixnum(accum))\n            return fixnum(accum);\n        else\n            return return_from_int64(fl_ctx, accum);\n    }\n    cprim_t *cp;\n    int ta;\n    void *aptr;\n    if (iscprim(a)) {\n        if (n == 0) return a;\n        cp = (cprim_t*)ptr(a);\n        ta = cp_numtype(cp);\n        aptr = cp_data(cp);\n        if (n < 0) {\n            n = -n;\n            switch (ta) {\n            case T_INT8:   return fixnum((*(int8_t *)aptr) >> n);\n            case T_UINT8:  return fixnum((*(uint8_t *)aptr) >> n);\n            case T_INT16:  return fixnum((*(int16_t *)aptr) >> n);\n            case T_UINT16: return fixnum((*(uint16_t*)aptr) >> n);\n            case T_INT32:  return mk_int32(fl_ctx, (*(int32_t *)aptr) >> n);\n            case T_UINT32: return mk_uint32(fl_ctx, (*(uint32_t*)aptr) >> n);\n            case T_INT64:  return mk_int64(fl_ctx, (*(int64_t *)aptr) >> n);\n            case T_UINT64: return mk_uint64(fl_ctx, (*(uint64_t*)aptr) >> n);\n            }\n        }\n        else {\n            if (ta == T_UINT64)\n                return return_from_uint64(fl_ctx, (*(uint64_t*)aptr)<<n);\n            else if (ta < T_FLOAT) {\n                int64_t i64 = conv_to_int64(aptr, (numerictype_t)ta);\n                return return_from_int64(fl_ctx, i64<<n);\n            }\n        }\n    }\n    type_error(fl_ctx, \"ash\", \"integer\", a);\n    return fl_ctx->NIL;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/base/docs/basedocs.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nmodule BaseDocs\n\n@nospecialize # don't specialize on any arguments of the methods declared herein\n\nstruct Keyword\n    name::Symbol\nend\nmacro kw_str(text)\n    return Keyword(Symbol(text))\nend\n\n\"\"\"\n**Welcome to Julia $(string(VERSION)).** The full manual is available at\n\n    https://docs.julialang.org/\n\nas well as many great tutorials and learning resources:\n\n    https://julialang.org/learning/\n\nFor help on a specific function or macro, type `?` followed\nby its name, e.g. `?cos`, or `?@time`, and press enter.\nType `;` to enter shell mode, `]` to enter package mode.\n\"\"\"\nkw\"help\", kw\"?\", kw\"julia\", kw\"\"\n\n\"\"\"\n    using\n\n`using Foo` will load the module or package `Foo` and make its [`export`](@ref)ed names\navailable for direct use. Names can also be used via dot syntax (e.g. `Foo.foo` to access\nthe name `foo`), whether they are `export`ed or not.\nSee the [manual section about modules](@ref modules) for details.\n\"\"\"\nkw\"using\"\n\n\"\"\"\n    import\n\n`import Foo` will load the module or package `Foo`.\nNames from the imported `Foo` module can be accessed with dot syntax\n(e.g. `Foo.foo` to access the name `foo`).\nSee the [manual section about modules](@ref modules) for details.\n\"\"\"\nkw\"import\"\n\n\"\"\"\n    export\n\n`export` is used within modules to tell Julia which functions should be\nmade available to the user. For example: `export foo` makes the name\n`foo` available when [`using`](@ref) the module.\nSee the [manual section about modules](@ref modules) for details.\n\"\"\"\nkw\"export\"\n\n\"\"\"\n    abstract type\n\n`abstract type` declares a type that cannot be instantiated, and serves only as a node in the\ntype graph, thereby describing sets of related concrete types: those concrete types\nwhich are their descendants. Abstract types form the conceptual hierarchy which makes\nJulia\u2019s type system more than just a collection of object implementations. For example:\n\n```julia\nabstract type Number end\nabstract type Real <: Number end\n```\n[`Number`](@ref) has no supertype, whereas [`Real`](@ref) is an abstract subtype of `Number`.\n\"\"\"\nkw\"abstract type\"\n\n\"\"\"\n    module\n\n`module` declares a `Module`, which is a separate global variable workspace. Within a\nmodule, you can control which names from other modules are visible (via importing), and\nspecify which of your names are intended to be public (via exporting).\nModules allow you to create top-level definitions without worrying about name conflicts\nwhen your code is used together with somebody else\u2019s.\nSee the [manual section about modules](@ref modules) for more details.\n\n# Examples\n```julia\nmodule Foo\nimport Base.show\nexport MyType, foo\n\nstruct MyType\n    x\nend\n\nbar(x) = 2x\nfoo(a::MyType) = bar(a.x) + 1\nshow(io::IO, a::MyType) = print(io, \"MyType \\$(a.x)\")\nend\n```\n\"\"\"\nkw\"module\"\n\n\"\"\"\n    baremodule\n\n`baremodule` declares a module that does not contain `using Base`\nor a definition of `eval`. It does still import `Core`.\n\"\"\"\nkw\"baremodule\"\n\n\"\"\"\n    primitive type\n\n`primitive type` declares a concrete type whose data consists only of a series of bits. Classic\nexamples of primitive types are integers and floating-point values. Some example built-in\nprimitive type declarations:\n\n```julia\nprimitive type Char 32 end\nprimitive type Bool <: Integer 8 end\n```\nThe number after the name indicates how many bits of storage the type requires. Currently,\nonly sizes that are multiples of 8 bits are supported.\nThe [`Bool`](@ref) declaration shows how a primitive type can be optionally\ndeclared to be a subtype of some supertype.\n\"\"\"\nkw\"primitive type\"\n\n\"\"\"\n    macro\n\n`macro` defines a method to include generated code in the final body of a program. A\nmacro maps a tuple of arguments to a returned expression, and the resulting expression\nis compiled directly rather than requiring a runtime `eval` call. Macro arguments may\ninclude expressions, literal values, and symbols. For example:\n\n# Examples\n```jldoctest\njulia> macro sayhello(name)\n           return :( println(\"Hello, \", \\$name, \"!\") )\n       end\n@sayhello (macro with 1 method)\n\njulia> @sayhello \"Charlie\"\nHello, Charlie!\n```\n\"\"\"\nkw\"macro\"\n\n\"\"\"\n    local\n\n`local` introduces a new local variable.\nSee the [manual section on variable scoping](@ref scope-of-variables) for more information.\n\n# Examples\n```jldoctest\njulia> function foo(n)\n           x = 0\n           for i = 1:n\n               local x # introduce a loop-local x\n               x = i\n           end\n           x\n       end\nfoo (generic function with 1 method)\n\njulia> foo(10)\n0\n```\n\"\"\"\nkw\"local\"\n\n\"\"\"\n    global\n\n`global x` makes `x` in the current scope and its inner scopes refer to the global\nvariable of that name.\nSee the [manual section on variable scoping](@ref scope-of-variables) for more information.\n\n# Examples\n```jldoctest\njulia> z = 3\n3\n\njulia> function foo()\n           global z = 6 # use the z variable defined outside foo\n       end\nfoo (generic function with 1 method)\n\njulia> foo()\n6\n\njulia> z\n6\n```\n\"\"\"\nkw\"global\"\n\n\"\"\"\n    let\n\n`let` statements allocate new variable bindings each time they run. Whereas an\nassignment modifies an existing value location, `let` creates new locations. This\ndifference is only detectable in the case of variables that outlive their scope via\nclosures. The `let` syntax accepts a comma-separated series of assignments and variable\nnames:\n\n```julia\nlet var1 = value1, var2, var3 = value3\n    code\nend\n```\nThe assignments are evaluated in order, with each right-hand side evaluated in the scope\nbefore the new variable on the left-hand side has been introduced. Therefore it makes\nsense to write something like `let x = x`, since the two `x` variables are distinct and\nhave separate storage.\n\"\"\"\nkw\"let\"\n\n\"\"\"\n    quote\n\n`quote` creates multiple expression objects in a block without using the explicit `Expr`\nconstructor. For example:\n\n```julia\nex = quote\n    x = 1\n    y = 2\n    x + y\nend\n```\nUnlike the other means of quoting, `:( ... )`, this form introduces `QuoteNode` elements\nto the expression tree, which must be considered when directly manipulating the tree.\nFor other purposes, `:( ... )` and `quote .. end` blocks are treated identically.\n\"\"\"\nkw\"quote\"\n\n\"\"\"\n    '\n\nThe conjugate transposition operator, see [`adjoint`](@ref).\n\n# Examples\n```jldoctest\njulia> A = [1.0 -2.0im; 4.0im 2.0]\n2\u00d72 Array{Complex{Float64},2}:\n 1.0+0.0im  -0.0-2.0im\n 0.0+4.0im   2.0+0.0im\n\njulia> A'\n2\u00d72 Array{Complex{Float64},2}:\n  1.0-0.0im  0.0-4.0im\n -0.0+2.0im  2.0-0.0im\n```\n\"\"\"\nkw\"'\"\n\n\"\"\"\n    const\n\n`const` is used to declare global variables which are also constant. In almost all code\n(and particularly performance sensitive code) global variables should be declared\nconstant in this way.\n\n```julia\nconst x = 5\n```\n\nMultiple variables can be declared within a single `const`:\n```julia\nconst y, z = 7, 11\n```\n\nNote that `const` only applies to one `=` operation, therefore `const x = y = 1`\ndeclares `x` to be constant but not `y`. On the other hand, `const x = const y = 1`\ndeclares both `x` and `y` as constants.\n\nNote that \"constant-ness\" is not enforced inside containers, so if `x` is an array or\ndictionary (for example) you can still add and remove elements.\n\nTechnically, you can even redefine `const` variables, although this will generate a\nwarning from the compiler. The only strict requirement is that the *type* of the\nvariable does not change, which is why `const` variables are much faster than regular\nglobals.\n\"\"\"\nkw\"const\"\n\n\"\"\"\n    function\n\nFunctions are defined with the `function` keyword:\n\n```julia\nfunction add(a, b)\n    return a + b\nend\n```\nOr the short form notation:\n\n```julia\nadd(a, b) = a + b\n```\n\nThe use of the [`return`](@ref) keyword is exactly the same as in other languages,\nbut is often optional. A function without an explicit `return` statement will return\nthe last expression in the function body.\n\"\"\"\nkw\"function\"\n\n\"\"\"\n    return\n\n`return` can be used in function bodies to exit early and return a given value, e.g.\n\n```julia\nfunction compare(a, b)\n    a == b && return \"equal to\"\n    a < b ? \"less than\" : \"greater than\"\nend\n```\nIn general you can place a `return` statement anywhere within a function body, including\nwithin deeply nested loops or conditionals, but be careful with `do` blocks. For\nexample:\n\n```julia\nfunction test1(xs)\n    for x in xs\n        iseven(x) && return 2x\n    end\nend\n\nfunction test2(xs)\n    map(xs) do x\n        iseven(x) && return 2x\n        x\n    end\nend\n```\nIn the first example, the return breaks out of its enclosing function as soon as it hits\nan even number, so `test1([5,6,7])` returns `12`.\n\nYou might expect the second example to behave the same way, but in fact the `return`\nthere only breaks out of the *inner* function (inside the `do` block) and gives a value\nback to `map`. `test2([5,6,7])` then returns `[5,12,7]`.\n\"\"\"\nkw\"return\"\n\n\"\"\"\n    if/elseif/else\n\n`if`/`elseif`/`else` performs conditional evaluation, which allows portions of code to\nbe evaluated or not evaluated depending on the value of a boolean expression. Here is\nthe anatomy of the `if`/`elseif`/`else` conditional syntax:\n\n```julia\nif x < y\n    println(\"x is less than y\")\nelseif x > y\n    println(\"x is greater than y\")\nelse\n    println(\"x is equal to y\")\nend\n```\nIf the condition expression `x < y` is true, then the corresponding block is evaluated;\notherwise the condition expression `x > y` is evaluated, and if it is true, the\ncorresponding block is evaluated; if neither expression is true, the `else` block is\nevaluated. The `elseif` and `else` blocks are optional, and as many `elseif` blocks as\ndesired can be used.\n\"\"\"\nkw\"if\", kw\"elseif\", kw\"else\"\n\n\"\"\"\n    for\n\n`for` loops repeatedly evaluate the body of the loop by\niterating over a sequence of values.\n\n# Examples\n```jldoctest\njulia> for i in [1, 4, 0]\n           println(i)\n       end\n1\n4\n0\n```\n\"\"\"\nkw\"for\"\n\n\"\"\"\n    while\n\n`while` loops repeatedly evaluate a conditional expression, and continues evaluating the\nbody of the while loop so long as the expression remains `true`. If the condition\nexpression is false when the while loop is first reached, the body is never evaluated.\n\n# Examples\n```jldoctest\njulia> i = 1\n1\n\njulia> while i < 5\n           println(i)\n           global i += 1\n       end\n1\n2\n3\n4\n```\n\"\"\"\nkw\"while\"\n\n\"\"\"\n    end\n\n`end` marks the conclusion of a block of expressions, for example\n[`module`](@ref), [`struct`](@ref), [`mutable struct`](@ref),\n[`begin`](@ref), [`let`](@ref), [`for`](@ref) etc.\n`end` may also be used when indexing into an array to represent\nthe last index of a dimension.\n\n# Examples\n```jldoctest\njulia> A = [1 2; 3 4]\n2\u00d72 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> A[end, :]\n2-element Array{Int64,1}:\n 3\n 4\n```\n\"\"\"\nkw\"end\"\n\n\"\"\"\n    try/catch\n\nA `try`/`catch` statement allows for `Exception`s to be tested for. For example, a\ncustomized square root function can be written to automatically call either the real or\ncomplex square root method on demand using `Exception`s:\n\n```julia\nf(x) = try\n    sqrt(x)\ncatch\n    sqrt(complex(x, 0))\nend\n```\n\n`try`/`catch` statements also allow the `Exception` to be saved in a variable, e.g. `catch y`.\n\nThe power of the `try`/`catch` construct lies in the ability to unwind a deeply\nnested computation immediately to a much higher level in the stack of calling functions.\n\"\"\"\nkw\"try\", kw\"catch\"\n\n\"\"\"\n    finally\n\nRun some code when a given block of code exits, regardless\nof how it exits. For example, here is how we can guarantee that an opened file is\nclosed:\n\n```julia\nf = open(\"file\")\ntry\n    operate_on_file(f)\nfinally\n    close(f)\nend\n```\n\nWhen control leaves the [`try`](@ref) block (for example, due to a [`return`](@ref), or just finishing\nnormally), [`close(f)`](@ref) will be executed. If the `try` block exits due to an exception,\nthe exception will continue propagating. A `catch` block may be combined with `try` and\n`finally` as well. In this case the `finally` block will run after `catch` has handled\nthe error.\n\"\"\"\nkw\"finally\"\n\n\"\"\"\n    break\n\nBreak out of a loop immediately.\n\n# Examples\n```jldoctest\njulia> i = 0\n0\n\njulia> while true\n           global i += 1\n           i > 5 && break\n           println(i)\n       end\n1\n2\n3\n4\n5\n```\n\"\"\"\nkw\"break\"\n\n\"\"\"\n    continue\n\nSkip the rest of the current loop iteration.\n\n# Examples\n```jldoctest\njulia> for i = 1:6\n           iseven(i) && continue\n           println(i)\n       end\n1\n3\n5\n```\n\"\"\"\nkw\"continue\"\n\n\"\"\"\n    do\n\nCreate an anonymous function. For example:\n\n```julia\nmap(1:10) do x\n    2x\nend\n```\n\nis equivalent to `map(x->2x, 1:10)`.\n\nUse multiple arguments like so:\n\n```julia\nmap(1:10, 11:20) do x, y\n    x + y\nend\n```\n\"\"\"\nkw\"do\"\n\n\"\"\"\n    ...\n\nThe \"splat\" operator, `...`, represents a sequence of arguments.\n`...` can be used in function definitions, to indicate that the function\naccepts an arbitrary number of arguments.\n`...` can also be used to apply a function to a sequence of arguments.\n\n# Examples\n```jldoctest\njulia> add(xs...) = reduce(+, xs)\nadd (generic function with 1 method)\n\njulia> add(1, 2, 3, 4, 5)\n15\n\njulia> add([1, 2, 3]...)\n6\n\njulia> add(7, 1:100..., 1000:1100...)\n111107\n```\n\"\"\"\nkw\"...\"\n\n\"\"\"\n    ;\n\n`;` has a similar role in Julia as in many C-like languages, and is used to delimit the\nend of the previous statement. `;` is not necessary after new lines, but can be used to\nseparate statements on a single line or to join statements into a single expression.\n`;` is also used to suppress output printing in the REPL and similar interfaces.\n\n# Examples\n```julia\njulia> function foo()\n           x = \"Hello, \"; x *= \"World!\"\n           return x\n       end\nfoo (generic function with 1 method)\n\njulia> bar() = (x = \"Hello, Mars!\"; return x)\nbar (generic function with 1 method)\n\njulia> foo();\n\njulia> bar()\n\"Hello, Mars!\"\n```\n\"\"\"\nkw\";\"\n\n\"\"\"\n    x && y\n\nShort-circuiting boolean AND.\n\"\"\"\nkw\"&&\"\n\n\"\"\"\n    x || y\n\nShort-circuiting boolean OR.\n\"\"\"\nkw\"||\"\n\n\"\"\"\n    ccall((function_name, library), returntype, (argtype1, ...), argvalue1, ...)\n    ccall(function_pointer, returntype, (argtype1, ...), argvalue1, ...)\n\nCall a function in a C-exported shared library, specified by the tuple `(function_name, library)`,\nwhere each component is either a string or symbol. Alternatively, `ccall` may\nalso be used to call a function pointer `function_pointer`, such as one returned by `dlsym`.\n\nNote that the argument type tuple must be a literal tuple, and not a tuple-valued\nvariable or expression.\n\nEach `argvalue` to the `ccall` will be converted to the corresponding\n`argtype`, by automatic insertion of calls to `unsafe_convert(argtype,\ncconvert(argtype, argvalue))`. (See also the documentation for\n[`unsafe_convert`](@ref Base.unsafe_convert) and [`cconvert`](@ref Base.cconvert) for further details.)\nIn most cases, this simply results in a call to `convert(argtype, argvalue)`.\n\"\"\"\nkw\"ccall\"\n\n\"\"\"\n    llvmcall(IR::String, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n    llvmcall((declarations::String, IR::String), ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n\nCall LLVM IR string in the first argument. Similar to an LLVM function `define` block,\narguments are available as consecutive unnamed SSA variables (%0, %1, etc.).\n\nThe optional declarations string contains external functions declarations that are\nnecessary for llvm to compile the IR string. Multiple declarations can be passed in by\nseparating them with line breaks.\n\nNote that the argument type tuple must be a literal tuple, and not a tuple-valued\nvariable or expression.\n\nEach `ArgumentValue` to `llvmcall` will be converted to the corresponding\n`ArgumentType`, by automatic insertion of calls to `unsafe_convert(ArgumentType,\ncconvert(ArgumentType, ArgumentValue))`. (See also the documentation for\n[`unsafe_convert`](@ref Base.unsafe_convert) and [`cconvert`](@ref Base.cconvert) for further details.)\nIn most cases, this simply results in a call to `convert(ArgumentType, ArgumentValue)`.\n\nSee `test/llvmcall.jl` for usage examples.\n\"\"\"\nCore.Intrinsics.llvmcall\n\n\"\"\"\n    begin\n\n`begin...end` denotes a block of code.\n\n```julia\nbegin\n    println(\"Hello, \")\n    println(\"World!\")\nend\n```\n\nUsually `begin` will not be necessary, since keywords such as [`function`](@ref) and [`let`](@ref)\nimplicitly begin blocks of code. See also [`;`](@ref).\n\"\"\"\nkw\"begin\"\n\n\"\"\"\n    struct\n\nThe most commonly used kind of type in Julia is a struct, specified as a name and a\nset of fields.\n\n```julia\nstruct Point\n    x\n    y\nend\n```\n\nFields can have type restrictions, which may be parameterized:\n\n```julia\n    struct Point{X}\n        x::X\n        y::Float64\n    end\n```\n\nA struct can also declare an abstract super type via `<:` syntax:\n\n```julia\nstruct Point <: AbstractPoint\n    x\n    y\nend\n```\n\n`struct`s are immutable by default; an instance of one of these types cannot\nbe modified after construction. Use [`mutable struct`](@ref) instead to declare a\ntype whose instances can be modified.\n\nSee the manual section on [Composite Types](@ref) for more details,\nsuch as how to define constructors.\n\"\"\"\nkw\"struct\"\n\n\"\"\"\n    mutable struct\n\n`mutable struct` is similar to [`struct`](@ref), but additionally allows the\nfields of the type to be set after construction. See the manual section on\n[Composite Types](@ref) for more information.\n\"\"\"\nkw\"mutable struct\"\n\n\"\"\"\n    new\n\nSpecial function available to inner constructors which created a new object\nof the type.\nSee the manual section on [Inner Constructor Methods](@ref) for more information.\n\"\"\"\nkw\"new\"\n\n\"\"\"\n    where\n\nThe `where` keyword creates a type that is an iterated union of other types, over all\nvalues of some variable. For example `Vector{T} where T<:Real` includes all [`Vector`](@ref)s\nwhere the element type is some kind of `Real` number.\n\nThe variable bound defaults to `Any` if it is omitted:\n\n```julia\nVector{T} where T    # short for `where T<:Any`\n```\nVariables can also have lower bounds:\n\n```julia\nVector{T} where T>:Int\nVector{T} where Int<:T<:Real\n```\nThere is also a concise syntax for nested `where` expressions. For example, this:\n\n```julia\nPair{T, S} where S<:Array{T} where T<:Number\n```\ncan be shortened to:\n\n```julia\nPair{T, S} where {T<:Number, S<:Array{T}}\n```\nThis form is often found on method signatures.\n\nNote that in this form, the variables are listed outermost-first. This matches the\norder in which variables are substituted when a type is \"applied\" to parameter values\nusing the syntax `T{p1, p2, ...}`.\n\"\"\"\nkw\"where\"\n\n\"\"\"\n    ans\n\nA variable referring to the last computed value, automatically set at the interactive prompt.\n\"\"\"\nkw\"ans\"\n\n\"\"\"\n    devnull\n\nUsed in a stream redirect to discard all data written to it. Essentially equivalent to\n/dev/null on Unix or NUL on Windows. Usage:\n\n```julia\nrun(pipeline(`cat test.txt`, devnull))\n```\n\"\"\"\ndevnull\n\n# doc strings for code in boot.jl and built-ins\n\n\"\"\"\n    Nothing\n\nA type with no fields that is the type [`nothing`](@ref).\n\"\"\"\nNothing\n\n\"\"\"\n    nothing\n\nThe singleton instance of type [`Nothing`](@ref), used by convention when there is no value to return\n(as in a C `void` function) or when a variable or field holds no value.\n\"\"\"\nnothing\n\n\"\"\"\n    Core.TypeofBottom\n\nThe singleton type containing only the value `Union{}`.\n\"\"\"\nCore.TypeofBottom\n\n\"\"\"\n    Function\n\nAbstract type of all functions.\n\n```jldoctest\njulia> isa(+, Function)\ntrue\n\njulia> typeof(sin)\ntypeof(sin)\n\njulia> ans <: Function\ntrue\n```\n\"\"\"\nFunction\n\n\"\"\"\n    ReadOnlyMemoryError()\n\nAn operation tried to write to memory that is read-only.\n\"\"\"\nReadOnlyMemoryError\n\n\"\"\"\n    ErrorException(msg)\n\nGeneric error type. The error message, in the `.msg` field, may provide more specific details.\n\n# Example\n```jldoctest\njulia> ex = ErrorException(\"I've done a bad thing\");\n\njulia> ex.msg\n\"I've done a bad thing\"\n```\n\"\"\"\nErrorException\n\n\"\"\"\n    WrappedException(msg)\n\nGeneric type for `Exception`s wrapping another `Exception`, such as `LoadError` and\n`InitError`. Those exceptions contain information about the the root cause of an\nexception. Subtypes define a field `error` containing the causing `Exception`.\n\"\"\"\nCore.WrappedException\n\n\"\"\"\n    UndefRefError()\n\nThe item or field is not defined for the given object.\n\"\"\"\nUndefRefError\n\n\"\"\"\n    Float32(x [, mode::RoundingMode])\n\nCreate a `Float32` from `x`. If `x` is not exactly representable then `mode` determines how\n`x` is rounded.\n\n# Examples\n```jldoctest\njulia> Float32(1/3, RoundDown)\n0.3333333f0\n\njulia> Float32(1/3, RoundUp)\n0.33333334f0\n```\n\nSee [`RoundingMode`](@ref) for available rounding modes.\n\"\"\"\nFloat32(x)\n\n\"\"\"\n    Float64(x [, mode::RoundingMode])\n\nCreate a `Float64` from `x`. If `x` is not exactly representable then `mode` determines how\n`x` is rounded.\n\n# Examples\n```jldoctest\njulia> Float64(pi, RoundDown)\n3.141592653589793\n\njulia> Float64(pi, RoundUp)\n3.1415926535897936\n```\n\nSee [`RoundingMode`](@ref) for available rounding modes.\n\"\"\"\nFloat64(x)\n\n\"\"\"\n    OutOfMemoryError()\n\nAn operation allocated too much memory for either the system or the garbage collector to\nhandle properly.\n\"\"\"\nOutOfMemoryError\n\n\"\"\"\n    BoundsError([a],[i])\n\nAn indexing operation into an array, `a`, tried to access an out-of-bounds element at index `i`.\n\n# Examples\n```jldoctest; filter = r\"Stacktrace:(\\\\n \\\\[[0-9]+\\\\].*)*\"\njulia> A = fill(1.0, 7);\n\njulia> A[8]\nERROR: BoundsError: attempt to access 7-element Array{Float64,1} at index [8]\nStacktrace:\n [1] getindex(::Array{Float64,1}, ::Int64) at ./array.jl:660\n [2] top-level scope\n\njulia> B = fill(1.0, (2,3));\n\njulia> B[2, 4]\nERROR: BoundsError: attempt to access 2\u00d73 Array{Float64,2} at index [2, 4]\nStacktrace:\n [1] getindex(::Array{Float64,2}, ::Int64, ::Int64) at ./array.jl:661\n [2] top-level scope\n\njulia> B[9]\nERROR: BoundsError: attempt to access 2\u00d73 Array{Float64,2} at index [9]\nStacktrace:\n [1] getindex(::Array{Float64,2}, ::Int64) at ./array.jl:660\n [2] top-level scope\n```\n\"\"\"\nBoundsError\n\n\"\"\"\n    InexactError(name::Symbol, T, val)\n\nCannot exactly convert `val` to type `T` in a method of function `name`.\n\n# Examples\n```jldoctest\njulia> convert(Float64, 1+2im)\nERROR: InexactError: Float64(Float64, 1 + 2im)\nStacktrace:\n[...]\n```\n\"\"\"\nInexactError\n\n\"\"\"\n    DomainError(val)\n    DomainError(val, msg)\n\nThe argument `val` to a function or constructor is outside the valid domain.\n\n# Examples\n```jldoctest\njulia> sqrt(-1)\nERROR: DomainError with -1.0:\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]\n```\n\"\"\"\nDomainError\n\n\"\"\"\n    Task(func)\n\nCreate a `Task` (i.e. coroutine) to execute the given function `func` (which must be\ncallable with no arguments). The task exits when this function returns.\n\n# Examples\n```jldoctest\njulia> a() = sum(i for i in 1:1000);\n\njulia> b = Task(a);\n```\n\nIn this example, `b` is a runnable `Task` that hasn't started yet.\n\"\"\"\nTask\n\n\"\"\"\n    StackOverflowError()\n\nThe function call grew beyond the size of the call stack. This usually happens when a call\nrecurses infinitely.\n\"\"\"\nStackOverflowError\n\n\"\"\"\n    nfields(x) -> Int\n\nGet the number of fields in the given object.\n\n# Examples\n```jldoctest\njulia> a = 1//2;\n\njulia> nfields(a)\n2\n\njulia> b = 1\n1\n\njulia> nfields(b)\n0\n\njulia> ex = ErrorException(\"I've done a bad thing\");\n\njulia> nfields(ex)\n1\n```\n\nIn these examples, `a` is a [`Rational`](@ref), which has two fields.\n`b` is an `Int`, which is a primitive bitstype with no fields at all.\n`ex` is an [`ErrorException`](@ref), which has one field.\n\"\"\"\nnfields\n\n\"\"\"\n    UndefVarError(var::Symbol)\n\nA symbol in the current scope is not defined.\n\n# Examples\n```jldoctest\njulia> a\nERROR: UndefVarError: a not defined\n\njulia> a = 1;\n\njulia> a\n1\n```\n\"\"\"\nUndefVarError\n\n\"\"\"\n    UndefKeywordError(var::Symbol)\n\nThe required keyword argument `var` was not assigned in a function call.\n\"\"\"\nUndefKeywordError\n\n\"\"\"\n    OverflowError(msg)\n\nThe result of an expression is too large for the specified type and will cause a wraparound.\n\"\"\"\nOverflowError\n\n\"\"\"\n    TypeError(func::Symbol, context::AbstractString, expected::Type, got)\n\nA type assertion failure, or calling an intrinsic function with an incorrect argument type.\n\"\"\"\nTypeError\n\n\"\"\"\n    InterruptException()\n\nThe process was stopped by a terminal interrupt (CTRL+C).\n\"\"\"\nInterruptException\n\n\"\"\"\n    applicable(f, args...) -> Bool\n\nDetermine whether the given generic function has a method applicable to the given arguments.\n\n# Examples\n```jldoctest\njulia> function f(x, y)\n           x + y\n       end;\n\njulia> applicable(f, 1)\nfalse\n\njulia> applicable(f, 1, 2)\ntrue\n```\n\"\"\"\napplicable\n\n\"\"\"\n    invoke(f, argtypes::Type, args...; kwargs...)\n\nInvoke a method for the given generic function `f` matching the specified types `argtypes` on the\nspecified arguments `args` and passing the keyword arguments `kwargs`. The arguments `args` must\nconform with the specified types in `argtypes`, i.e. conversion is not automatically performed.\nThis method allows invoking a method other than the most specific matching method, which is useful\nwhen the behavior of a more general definition is explicitly needed (often as part of the\nimplementation of a more specific method of the same function).\n\n# Examples\n```jldoctest\njulia> f(x::Real) = x^2;\n\njulia> f(x::Integer) = 1 + invoke(f, Tuple{Real}, x);\n\njulia> f(2)\n5\n```\n\"\"\"\ninvoke\n\n\"\"\"\n    isa(x, type) -> Bool\n\nDetermine whether `x` is of the given `type`. Can also be used as an infix operator, e.g.\n`x isa type`.\n\n# Examples\n```jldoctest\njulia> isa(1, Int)\ntrue\n\njulia> isa(1, Matrix)\nfalse\n\njulia> isa(1, Char)\nfalse\n\njulia> isa(1, Number)\ntrue\n\njulia> 1 isa Number\ntrue\n```\n\"\"\"\nisa\n\n\"\"\"\n    DivideError()\n\nInteger division was attempted with a denominator value of 0.\n\n# Examples\n```jldoctest\njulia> 2/0\nInf\n\njulia> div(2, 0)\nERROR: DivideError: integer division error\nStacktrace:\n[...]\n```\n\"\"\"\nDivideError\n\n\"\"\"\n    Number\n\nAbstract supertype for all number types.\n\"\"\"\nNumber\n\n\"\"\"\n    Real <: Number\n\nAbstract supertype for all real numbers.\n\"\"\"\nReal\n\n\"\"\"\n    AbstractFloat <: Real\n\nAbstract supertype for all floating point numbers.\n\"\"\"\nAbstractFloat\n\n\"\"\"\n    Integer <: Real\n\nAbstract supertype for all integers.\n\"\"\"\nInteger\n\n\"\"\"\n    Signed <: Integer\n\nAbstract supertype for all signed integers.\n\"\"\"\nSigned\n\n\"\"\"\n    Unsigned <: Integer\n\nAbstract supertype for all unsigned integers.\n\"\"\"\nUnsigned\n\n\"\"\"\n    Bool <: Integer\n\nBoolean type.\n\"\"\"\nBool\n\nfor bit in (16, 32, 64)\n    @eval begin\n        \"\"\"\n            Float$($bit) <: AbstractFloat\n\n        $($bit)-bit floating point number type.\n        \"\"\"\n        $(Symbol(\"Float\", bit))\n    end\nend\n\nfor bit in (8, 16, 32, 64, 128)\n    @eval begin\n        \"\"\"\n            Int$($bit) <: Signed\n\n        $($bit)-bit signed integer type.\n        \"\"\"\n        $(Symbol(\"Int\", bit))\n\n        \"\"\"\n            UInt$($bit) <: Unsigned\n\n        $($bit)-bit unsigned integer type.\n        \"\"\"\n        $(Symbol(\"UInt\", bit))\n    end\nend\n\n\"\"\"\n    Symbol(x...) -> Symbol\n\nCreate a `Symbol` by concatenating the string representations of the arguments together.\n\n# Examples\n```jldoctest\njulia> Symbol(\"my\", \"name\")\n:myname\n\njulia> Symbol(\"day\", 4)\n:day4\n```\n\"\"\"\nSymbol\n\n\"\"\"\n    tuple(xs...)\n\nConstruct a tuple of the given objects.\n\n# Examples\n```jldoctest\njulia> tuple(1, 'a', pi)\n(1, 'a', \u03c0 = 3.1415926535897...)\n```\n\"\"\"\ntuple\n\n\"\"\"\n    getfield(value, name::Symbol)\n\nExtract a named field from a `value` of composite type.\nSee also [`getproperty`](@ref Base.getproperty).\n\n# Examples\n```jldoctest\njulia> a = 1//2\n1//2\n\njulia> getfield(a, :num)\n1\n\njulia> a.num\n1\n```\n\"\"\"\ngetfield\n\n\"\"\"\n    setfield!(value, name::Symbol, x)\n\nAssign `x` to a named field in `value` of composite type.\nThe `value` must be mutable and `x` must be a subtype of `fieldtype(typeof(value), name)`.\nSee also [`setproperty!`](@ref Base.setproperty!).\n\n# Examples\n```jldoctest\njulia> mutable struct MyMutableStruct\n           field::Int\n       end\n\njulia> a = MyMutableStruct(1);\n\njulia> setfield!(a, :field, 2);\n\njulia> getfield(a, :field)\n2\n\njulia> a = 1//2\n1//2\n\njulia> setfield!(a, :num, 3);\nERROR: type Rational is immutable\n```\n\"\"\"\nsetfield!\n\n\"\"\"\n    typeof(x)\n\nGet the concrete type of `x`.\n\n# Examples\n```jldoctest\njulia> a = 1//2;\n\njulia> typeof(a)\nRational{Int64}\n\njulia> M = [1 2; 3.5 4];\n\njulia> typeof(M)\nArray{Float64,2}\n```\n\"\"\"\ntypeof\n\n\"\"\"\n    isdefined(m::Module, s::Symbol)\n    isdefined(object, s::Symbol)\n    isdefined(object, index::Int)\n\nTests whether an assignable location is defined. The arguments can be a module and a symbol\nor a composite object and field name (as a symbol) or index.\n\n# Examples\n```jldoctest\njulia> isdefined(Base, :sum)\ntrue\n\njulia> isdefined(Base, :NonExistentMethod)\nfalse\n\njulia> a = 1//2;\n\njulia> isdefined(a, 2)\ntrue\n\njulia> isdefined(a, 3)\nfalse\n\njulia> isdefined(a, :num)\ntrue\n\njulia> isdefined(a, :numerator)\nfalse\n```\n\"\"\"\nisdefined\n\n\n\"\"\"\n    Vector{T}(undef, n)\n\nConstruct an uninitialized [`Vector{T}`](@ref) of length `n`. See [`undef`](@ref).\n\n# Examples\n```julia-repl\njulia> Vector{Float64}(undef, 3)\n3-element Array{Float64,1}:\n 6.90966e-310\n 6.90966e-310\n 6.90966e-310\n```\n\"\"\"\nVector{T}(::UndefInitializer, n)\n\n\"\"\"\n    Vector{T}(nothing, m)\n\nConstruct a [`Vector{T}`](@ref) of length `m`, initialized with\n[`nothing`](@ref) entries. Element type `T` must be able to hold\nthese values, i.e. `Nothing <: T`.\n\n# Examples\n```jldoctest\njulia> Vector{Union{Nothing, String}}(nothing, 2)\n2-element Array{Union{Nothing, String},1}:\n nothing\n nothing\n```\n\"\"\"\nVector{T}(::Nothing, n)\n\n\"\"\"\n    Vector{T}(missing, m)\n\nConstruct a [`Vector{T}`](@ref) of length `m`, initialized with\n[`missing`](@ref) entries. Element type `T` must be able to hold\nthese values, i.e. `Missing <: T`.\n\n# Examples\n```jldoctest\njulia> Vector{Union{Missing, String}}(missing, 2)\n2-element Array{Union{Missing, String},1}:\n missing\n missing\n```\n\"\"\"\nVector{T}(::Missing, n)\n\n\"\"\"\n    Matrix{T}(undef, m, n)\n\nConstruct an uninitialized [`Matrix{T}`](@ref) of size `m`\u00d7`n`. See [`undef`](@ref).\n\n# Examples\n```julia-repl\njulia> Matrix{Float64}(undef, 2, 3)\n2\u00d73 Array{Float64,2}:\n 6.93517e-310  6.93517e-310  6.93517e-310\n 6.93517e-310  6.93517e-310  1.29396e-320\n```\n\"\"\"\nMatrix{T}(::UndefInitializer, m, n)\n\n\"\"\"\n    Matrix{T}(nothing, m, n)\n\nConstruct a [`Matrix{T}`](@ref) of size `m`\u00d7`n`, initialized with\n[`nothing`](@ref) entries. Element type `T` must be able to hold\nthese values, i.e. `Nothing <: T`.\n\n# Examples\n```jldoctest\njulia> Matrix{Union{Nothing, String}}(nothing, 2, 3)\n2\u00d73 Array{Union{Nothing, String},2}:\n nothing  nothing  nothing\n nothing  nothing  nothing\n```\n\"\"\"\nMatrix{T}(::Nothing, m, n)\n\n\"\"\"\n    Matrix{T}(missing, m, n)\n\nConstruct a [`Matrix{T}`](@ref) of size `m`\u00d7`n`, initialized with\n[`missing`](@ref) entries. Element type `T` must be able to hold\nthese values, i.e. `Missing <: T`.\n\n# Examples\n```jldoctest\njulia> Matrix{Union{Missing, String}}(missing, 2, 3)\n2\u00d73 Array{Union{Missing, String},2}:\n missing  missing  missing\n missing  missing  missing\n```\n\"\"\"\nMatrix{T}(::Missing, m, n)\n\n\"\"\"\n    Array{T}(undef, dims)\n    Array{T,N}(undef, dims)\n\nConstruct an uninitialized `N`-dimensional [`Array`](@ref)\ncontaining elements of type `T`. `N` can either be supplied explicitly,\nas in `Array{T,N}(undef, dims)`, or be determined by the length or number of `dims`.\n`dims` may be a tuple or a series of integer arguments corresponding to the lengths\nin each dimension. If the rank `N` is supplied explicitly, then it must\nmatch the length or number of `dims`. See [`undef`](@ref).\n\n# Examples\n```julia-repl\njulia> A = Array{Float64,2}(undef, 2, 3) # N given explicitly\n2\u00d73 Array{Float64,2}:\n 6.90198e-310  6.90198e-310  6.90198e-310\n 6.90198e-310  6.90198e-310  0.0\n\njulia> B = Array{Float64}(undef, 2) # N determined by the input\n2-element Array{Float64,1}:\n 1.87103e-320\n 0.0\n```\n\"\"\"\nArray{T,N}(::UndefInitializer, dims)\n\n\"\"\"\n    Array{T}(nothing, dims)\n    Array{T,N}(nothing, dims)\n\nConstruct an `N`-dimensional [`Array`](@ref) containing elements of type `T`,\ninitialized with [`nothing`](@ref) entries. Element type `T` must be able\nto hold these values, i.e. `Nothing <: T`.\n\n# Examples\n```jldoctest\njulia> Array{Union{Nothing, String}}(nothing, 2)\n2-element Array{Union{Nothing, String},1}:\n nothing\n nothing\n\njulia> Array{Union{Nothing, Int}}(nothing, 2, 3)\n2\u00d73 Array{Union{Nothing, Int64},2}:\n nothing  nothing  nothing\n nothing  nothing  nothing\n```\n\"\"\"\nArray{T,N}(::Nothing, dims)\n\n\n\"\"\"\n    Array{T}(missing, dims)\n    Array{T,N}(missing, dims)\n\nConstruct an `N`-dimensional [`Array`](@ref) containing elements of type `T`,\ninitialized with [`missing`](@ref) entries. Element type `T` must be able\nto hold these values, i.e. `Missing <: T`.\n\n# Examples\n```jldoctest\njulia> Array{Union{Missing, String}}(missing, 2)\n2-element Array{Union{Missing, String},1}:\n missing\n missing\n\njulia> Array{Union{Missing, Int}}(missing, 2, 3)\n2\u00d73 Array{Union{Missing, Int64},2}:\n missing  missing  missing\n missing  missing  missing\n```\n\"\"\"\nArray{T,N}(::Missing, dims)\n\n\"\"\"\n    UndefInitializer\n\nSingleton type used in array initialization, indicating the array-constructor-caller\nwould like an uninitialized array. See also [`undef`](@ref),\nan alias for `UndefInitializer()`.\n\n# Examples\n```julia-repl\njulia> Array{Float64,1}(UndefInitializer(), 3)\n3-element Array{Float64,1}:\n 2.2752528595e-314\n 2.202942107e-314\n 2.275252907e-314\n```\n\"\"\"\nUndefInitializer\n\n\"\"\"\n    undef\n\nAlias for `UndefInitializer()`, which constructs an instance of the singleton type\n[`UndefInitializer`](@ref), used in array initialization to indicate the\narray-constructor-caller would like an uninitialized array.\n\n# Examples\n```julia-repl\njulia> Array{Float64,1}(undef, 3)\n3-element Array{Float64,1}:\n 2.2752528595e-314\n 2.202942107e-314\n 2.275252907e-314\n```\n\"\"\"\nundef\n\n\"\"\"\n    +(x, y...)\n\nAddition operator. `x+y+z+...` calls this function with all arguments, i.e. `+(x, y, z, ...)`.\n\n# Examples\n```jldoctest\njulia> 1 + 20 + 4\n25\n\njulia> +(1, 20, 4)\n25\n```\n\"\"\"\n(+)(x, y...)\n\n\"\"\"\n    -(x)\n\nUnary minus operator.\n\n# Examples\n```jldoctest\njulia> -1\n-1\n\njulia> -(2)\n-2\n\njulia> -[1 2; 3 4]\n2\u00d72 Array{Int64,2}:\n -1  -2\n -3  -4\n```\n\"\"\"\n-(x)\n\n\"\"\"\n    -(x, y)\n\nSubtraction operator.\n\n# Examples\n```jldoctest\njulia> 2 - 3\n-1\n\njulia> -(2, 4.5)\n-2.5\n```\n\"\"\"\n-(x, y)\n\n\"\"\"\n    *(x, y...)\n\nMultiplication operator. `x*y*z*...` calls this function with all arguments, i.e. `*(x, y, z, ...)`.\n\n# Examples\n```jldoctest\njulia> 2 * 7 * 8\n112\n\njulia> *(2, 7, 8)\n112\n```\n\"\"\"\n(*)(x, y...)\n\n\"\"\"\n    /(x, y)\n\nRight division operator: multiplication of `x` by the inverse of `y` on the right. Gives\nfloating-point results for integer arguments.\n\n# Examples\n```jldoctest\njulia> 1/2\n0.5\n\njulia> 4/2\n2.0\n\njulia> 4.5/2\n2.25\n```\n\"\"\"\n/(x, y)\n\n\"\"\"\n    ArgumentError(msg)\n\nThe parameters to a function call do not match a valid signature. Argument `msg` is a\ndescriptive error string.\n\"\"\"\nArgumentError\n\n\"\"\"\n    MethodError(f, args)\n\nA method with the required type signature does not exist in the given generic function.\nAlternatively, there is no unique most-specific method.\n\"\"\"\nMethodError\n\n\"\"\"\n    AssertionError([msg])\n\nThe asserted condition did not evaluate to `true`.\nOptional argument `msg` is a descriptive error string.\n\n# Examples\n```jldoctest\njulia> @assert false \"this is not true\"\nERROR: AssertionError: this is not true\n```\n\n`AssertionError` is usually thrown from [`@assert`](@ref).\n\"\"\"\nAssertionError\n\n\"\"\"\n    LoadError(file::AbstractString, line::Int, error)\n\nAn error occurred while `include`ing, `require`ing, or [`using`](@ref) a file. The error specifics\nshould be available in the `.error` field.\n\"\"\"\nLoadError\n\n\"\"\"\n    InitError(mod::Symbol, error)\n\nAn error occurred when running a module's `__init__` function. The actual error thrown is\navailable in the `.error` field.\n\"\"\"\nInitError\n\n\"\"\"\n    Any::DataType\n\n`Any` is the union of all types. It has the defining property `isa(x, Any) == true` for any `x`. `Any` therefore\ndescribes the entire universe of possible values. For example `Integer` is a subset of `Any` that includes `Int`,\n`Int8`, and other integer types.\n\"\"\"\nAny\n\n\"\"\"\n    Union{}\n\n`Union{}`, the empty [`Union`](@ref) of types, is the type that has no values. That is, it has the defining\nproperty `isa(x, Union{}) == false` for any `x`. `Base.Bottom` is defined as its alias and the type of `Union{}`\nis `Core.TypeofBottom`.\n\n# Examples\n```jldoctest\njulia> isa(nothing, Union{})\nfalse\n```\n\"\"\"\nkw\"Union{}\", Base.Bottom\n\n\"\"\"\n    Union{Types...}\n\nA type union is an abstract type which includes all instances of any of its argument types. The empty\nunion [`Union{}`](@ref) is the bottom type of Julia.\n\n# Examples\n```jldoctest\njulia> IntOrString = Union{Int,AbstractString}\nUnion{Int64, AbstractString}\n\njulia> 1 :: IntOrString\n1\n\njulia> \"Hello!\" :: IntOrString\n\"Hello!\"\n\njulia> 1.0 :: IntOrString\nERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got Float64\n```\n\"\"\"\nUnion\n\n\n\"\"\"\n    UnionAll\n\nA union of types over all values of a type parameter. `UnionAll` is used to describe parametric types\nwhere the values of some parameters are not known.\n\n# Examples\n```jldoctest\njulia> typeof(Vector)\nUnionAll\n\njulia> typeof(Vector{Int})\nDataType\n```\n\"\"\"\nUnionAll\n\n\"\"\"\n    ::\n\nWith the `::`-operator type annotations are attached to expressions and variables in programs.\nSee the manual section on [Type Declarations](@ref).\n\nOutside of declarations `::` is used to assert that expressions and variables in programs have a given type.\n\n# Examples\n```jldoctest\njulia> (1+2)::AbstractFloat\nERROR: TypeError: typeassert: expected AbstractFloat, got Int64\n\njulia> (1+2)::Int\n3\n```\n\"\"\"\nkw\"::\"\n\n\"\"\"\n    Vararg{T,N}\n\nThe last parameter of a tuple type [`Tuple`](@ref) can be the special type `Vararg`, which denotes any\nnumber of trailing elements. The type `Vararg{T,N}` corresponds to exactly `N` elements of type `T`.\n`Vararg{T}` corresponds to zero or more elements of type `T`. `Vararg` tuple types are used to represent the\narguments accepted by varargs methods (see the section on [Varargs Functions](@ref) in the manual.)\n\n# Examples\n```jldoctest\njulia> mytupletype = Tuple{AbstractString,Vararg{Int}}\nTuple{AbstractString,Vararg{Int64,N} where N}\n\njulia> isa((\"1\",), mytupletype)\ntrue\n\njulia> isa((\"1\",1), mytupletype)\ntrue\n\njulia> isa((\"1\",1,2), mytupletype)\ntrue\n\njulia> isa((\"1\",1,2,3.0), mytupletype)\nfalse\n```\n\"\"\"\nVararg\n\n\"\"\"\n    Tuple{Types...}\n\nTuples are an abstraction of the arguments of a function \u2013 without the function itself. The salient aspects of\na function's arguments are their order and their types. Therefore a tuple type is similar to a parameterized\nimmutable type where each parameter is the type of one field. Tuple types may have any number of parameters.\n\nTuple types are covariant in their parameters: `Tuple{Int}` is a subtype of `Tuple{Any}`. Therefore `Tuple{Any}`\nis considered an abstract type, and tuple types are only concrete if their parameters are. Tuples do not have\nfield names; fields are only accessed by index.\n\nSee the manual section on [Tuple Types](@ref).\n\"\"\"\nTuple\n\n\"\"\"\nThe base library of Julia.\n\"\"\"\nkw\"Base\"\n\n\"\"\"\n    typeassert(x, type)\n\nThrow a TypeError unless `x isa type`.\nThe syntax `x::type` calls this function.\n\"\"\"\ntypeassert\n\n\"\"\"\n    getproperty(value, name::Symbol)\n\nThe syntax `a.b` calls `getproperty(a, :b)`.\n\"\"\"\nBase.getproperty\n\n\"\"\"\n    setproperty!(value, name::Symbol, x)\n\nThe syntax `a.b = c` calls `setproperty!(a, :b, c)`.\n\"\"\"\nBase.setproperty!\n\n\"\"\"\n    StridedArray{T, N}\n\nAn `N` dimensional *strided* array with elements of type `T`. These arrays follow\nthe [strided array interface](@ref man-interface-strided-arrays). If `A` is a\n`StridedArray`, then its elements are stored in memory with offsets, which may\nvary between dimensions but are constant within a dimension. For example, `A` could\nhave stride 2 in dimension 1, and stride 3 in dimension 2. Incrementing `A` along\ndimension `d` jumps in memory by [`strides(A, d)`] slots. Strided arrays are\nparticularly important and useful because they can sometimes be passed directly\nas pointers to foreign language libraries like BLAS.\n\"\"\"\nStridedArray\n\n\"\"\"\n    StridedVector{T}\n\nOne dimensional [`StridedArray`](@ref) with elements of type `T`.\n\"\"\"\nStridedVector\n\n\"\"\"\n    StridedMatrix{T}\n\nTwo dimensional [`StridedArray`](@ref) with elements of type `T`.\n\"\"\"\nStridedMatrix\n\n\"\"\"\n    StridedVecOrMat{T}\n\nUnion type of [`StridedVector`](@ref) and [`StridedMatrix`](@ref) with elements of type `T`.\n\"\"\"\nStridedVecOrMat\n\nend\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/stdlib/LinearAlgebra/src/blas.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nmodule BLAS\n@doc \"\"\"\nInterface to BLAS subroutines.\n\"\"\" BLAS\n\nimport ..axpy!, ..axpby!\nimport Base: copyto!\nusing Base: has_offset_axes\n\nexport\n# Level 1\n    asum,\n    axpy!,\n    axpby!,\n    blascopy!,\n    dot,\n    dotc,\n    dotu,\n    scal!,\n    scal,\n    nrm2,\n    iamax,\n# Level 2\n    gbmv!,\n    gbmv,\n    gemv!,\n    gemv,\n    hemv!,\n    hemv,\n    sbmv!,\n    sbmv,\n    symv!,\n    symv,\n    trsv!,\n    trsv,\n    trmv!,\n    trmv,\n    ger!,\n    syr!,\n    her!,\n# Level 3\n    herk!,\n    herk,\n    her2k!,\n    her2k,\n    gemm!,\n    gemm,\n    symm!,\n    symm,\n    hemm!,\n    hemm,\n    syrk!,\n    syrk,\n    syr2k!,\n    syr2k,\n    trmm!,\n    trmm,\n    trsm!,\n    trsm\n\n\nconst libblas = Base.libblas_name\nconst liblapack = Base.liblapack_name\n\nimport LinearAlgebra\nimport LinearAlgebra: BlasReal, BlasComplex, BlasFloat, BlasInt, DimensionMismatch, checksquare, stride1, chkstride1, axpy!\n\nimport Libdl\n\n# utility routines\nlet lib = C_NULL\nglobal function determine_vendor()\n    lib == C_NULL && (lib = Libdl.dlopen_e(Base.libblas_name))\n    vend = :unknown\n    if lib != C_NULL\n        if Libdl.dlsym_e(lib, :openblas_set_num_threads) != C_NULL\n            vend = :openblas\n        elseif Libdl.dlsym_e(lib, :openblas_set_num_threads64_) != C_NULL\n            vend = :openblas64\n        elseif Libdl.dlsym_e(lib, :MKL_Set_Num_Threads) != C_NULL\n            vend = :mkl\n        end\n    end\n    return vend\nend\nend\n\nconst _vendor = determine_vendor()\nvendor() = _vendor\n\nif vendor() == :openblas64\n    macro blasfunc(x)\n        return Expr(:quote, Symbol(x, \"64_\"))\n    end\nelse\n    macro blasfunc(x)\n        return Expr(:quote, x)\n    end\nend\n\nopenblas_get_config() = strip(unsafe_string(ccall((@blasfunc(openblas_get_config), Base.libblas_name), Ptr{UInt8}, () )))\n\n\"\"\"\n    set_num_threads(n)\n\nSet the number of threads the BLAS library should use.\n\"\"\"\nfunction set_num_threads(n::Integer)\n    blas = vendor()\n    if blas == :openblas\n        return ccall((:openblas_set_num_threads, Base.libblas_name), Cvoid, (Int32,), n)\n    elseif blas == :openblas64\n        return ccall((:openblas_set_num_threads64_, Base.libblas_name), Cvoid, (Int32,), n)\n    elseif blas == :mkl\n        # MKL may let us set the number of threads in several ways\n        return ccall((:MKL_Set_Num_Threads, Base.libblas_name), Cvoid, (Cint,), n)\n    end\n\n    # OSX BLAS looks at an environment variable\n    @static if Sys.isapple()\n        ENV[\"VECLIB_MAXIMUM_THREADS\"] = n\n    end\n\n    return nothing\nend\n\nconst _testmat = [1.0 0.0; 0.0 -1.0]\nfunction check()\n    blas = vendor()\n    if blas == :openblas || blas == :openblas64\n        openblas_config = openblas_get_config()\n        openblas64 = occursin(r\".*USE64BITINT.*\", openblas_config)\n        if Base.USE_BLAS64 != openblas64\n            if !openblas64\n                @error \"\"\"\n                    OpenBLAS was not built with 64bit integer support.\n                    You're seeing this error because Julia was built with USE_BLAS64=1.\n                    Please rebuild Julia with USE_BLAS64=0\"\"\"\n            else\n                @error \"\"\"\n                    Julia was not built with support for OpenBLAS with 64bit integer support.\n                    You're seeing this error because Julia was built with USE_BLAS64=0.\n                    Please rebuild Julia with USE_BLAS64=1\"\"\"\n            end\n            println(\"Quitting.\")\n            exit()\n        end\n    elseif blas == :mkl\n        if Base.USE_BLAS64\n            ENV[\"MKL_INTERFACE_LAYER\"] = \"ILP64\"\n        end\n    end\n\n    #\n    # Check if BlasInt is the expected bitsize, by triggering an error\n    #\n    (_, info) = LinearAlgebra.LAPACK.potrf!('U', _testmat)\n    if info != 2 # mangled info code\n        if info == 2^33\n            error(\"BLAS and LAPACK are compiled with 32-bit integer support, but Julia expects 64-bit integers. Please build Julia with USE_BLAS64=0.\")\n        elseif info == 0\n            error(\"BLAS and LAPACK are compiled with 64-bit integer support but Julia expects 32-bit integers. Please build Julia with USE_BLAS64=1.\")\n        else\n            error(\"The LAPACK library produced an undefined error code. Please verify the installation of BLAS and LAPACK.\")\n        end\n    end\n\nend\n\n\n# Level 1\n## copy\n\n\"\"\"\n    blascopy!(n, X, incx, Y, incy)\n\nCopy `n` elements of array `X` with stride `incx` to array `Y` with stride `incy`. Returns `Y`.\n\"\"\"\nfunction blascopy! end\n\nfor (fname, elty) in ((:dcopy_,:Float64),\n                      (:scopy_,:Float32),\n                      (:zcopy_,:ComplexF64),\n                      (:ccopy_,:ComplexF32))\n    @eval begin\n        # SUBROUTINE DCOPY(N,DX,INCX,DY,INCY)\n        function blascopy!(n::Integer, DX::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer, DY::Union{Ptr{$elty},AbstractArray{$elty}}, incy::Integer)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 n, DX, incx, DY, incy)\n            DY\n        end\n    end\nend\n\n## scal\n\n\"\"\"\n    scal!(n, a, X, incx)\n\nOverwrite `X` with `a*X` for the first `n` elements of array `X` with stride `incx`. Returns `X`.\n\"\"\"\nfunction scal! end\n\n\"\"\"\n    scal(n, a, X, incx)\n\nReturn `X` scaled by `a` for the first `n` elements of array `X` with stride `incx`.\n\"\"\"\nfunction scal end\n\nfor (fname, elty) in ((:dscal_,:Float64),\n                      (:sscal_,:Float32),\n                      (:zscal_,:ComplexF64),\n                      (:cscal_,:ComplexF32))\n    @eval begin\n        # SUBROUTINE DSCAL(N,DA,DX,INCX)\n        function scal!(n::Integer, DA::$elty, DX::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                  (Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt}),\n                  n, DA, DX, incx)\n            DX\n        end\n    end\nend\nscal(n, DA, DX, incx) = scal!(n, DA, copy(DX), incx)\n\n## dot\n\n\"\"\"\n    dot(n, X, incx, Y, incy)\n\nDot product of two vectors consisting of `n` elements of array `X` with stride `incx` and\n`n` elements of array `Y` with stride `incy`.\n\n# Examples\n```jldoctest\njulia> dot(10, fill(1.0, 10), 1, fill(1.0, 20), 2)\n10.0\n```\n\"\"\"\nfunction dot end\n\n\"\"\"\n    dotc(n, X, incx, U, incy)\n\nDot function for two complex vectors, consisting of `n` elements of array `X`\nwith stride `incx` and `n` elements of array `U` with stride `incy`,\nconjugating the first vector.\n\n# Examples\n```jldoctest\njulia> BLAS.dotc(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)\n10.0 - 10.0im\n```\n\"\"\"\nfunction dotc end\n\n\"\"\"\n    dotu(n, X, incx, Y, incy)\n\nDot function for two complex vectors consisting of `n` elements of array `X`\nwith stride `incx` and `n` elements of array `Y` with stride `incy`.\n\n# Examples\n```jldoctest\njulia> BLAS.dotu(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)\n-10.0 + 10.0im\n```\n\"\"\"\nfunction dotu end\n\nfor (fname, elty) in ((:ddot_,:Float64),\n                      (:sdot_,:Float32))\n    @eval begin\n                #       DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY)\n                # *     .. Scalar Arguments ..\n                #       INTEGER INCX,INCY,N\n                # *     ..\n                # *     .. Array Arguments ..\n                #       DOUBLE PRECISION DX(*),DY(*)\n        function dot(n::Integer, DX::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer, DY::Union{Ptr{$elty},AbstractArray{$elty}}, incy::Integer)\n            ccall((@blasfunc($fname), libblas), $elty,\n                (Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 n, DX, incx, DY, incy)\n        end\n    end\nend\nfor (fname, elty) in ((:cblas_zdotc_sub,:ComplexF64),\n                      (:cblas_cdotc_sub,:ComplexF32))\n    @eval begin\n                #       DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY)\n                # *     .. Scalar Arguments ..\n                #       INTEGER INCX,INCY,N\n                # *     ..\n                # *     .. Array Arguments ..\n                #       DOUBLE PRECISION DX(*),DY(*)\n        function dotc(n::Integer, DX::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer, DY::Union{Ptr{$elty},AbstractArray{$elty}}, incy::Integer)\n            result = Ref{$elty}()\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (BlasInt, Ptr{$elty}, BlasInt, Ptr{$elty}, BlasInt, Ptr{$elty}),\n                 n, DX, incx, DY, incy, result)\n            result[]\n        end\n    end\nend\nfor (fname, elty) in ((:cblas_zdotu_sub,:ComplexF64),\n                      (:cblas_cdotu_sub,:ComplexF32))\n    @eval begin\n                #       DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY)\n                # *     .. Scalar Arguments ..\n                #       INTEGER INCX,INCY,N\n                # *     ..\n                # *     .. Array Arguments ..\n                #       DOUBLE PRECISION DX(*),DY(*)\n        function dotu(n::Integer, DX::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer, DY::Union{Ptr{$elty},AbstractArray{$elty}}, incy::Integer)\n            result = Ref{$elty}()\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (BlasInt, Ptr{$elty}, BlasInt, Ptr{$elty}, BlasInt, Ptr{$elty}),\n                 n, DX, incx, DY, incy, result)\n            result[]\n        end\n    end\nend\n\nfunction dot(DX::Union{DenseArray{T},AbstractVector{T}}, DY::Union{DenseArray{T},AbstractVector{T}}) where T<:BlasReal\n    @assert !has_offset_axes(DX, DY)\n    n = length(DX)\n    if n != length(DY)\n        throw(DimensionMismatch(\"dot product arguments have lengths $(length(DX)) and $(length(DY))\"))\n    end\n    GC.@preserve DX DY dot(n, pointer(DX), stride(DX, 1), pointer(DY), stride(DY, 1))\nend\nfunction dotc(DX::Union{DenseArray{T},AbstractVector{T}}, DY::Union{DenseArray{T},AbstractVector{T}}) where T<:BlasComplex\n    @assert !has_offset_axes(DX, DY)\n    n = length(DX)\n    if n != length(DY)\n        throw(DimensionMismatch(\"dot product arguments have lengths $(length(DX)) and $(length(DY))\"))\n    end\n    GC.@preserve DX DY dotc(n, pointer(DX), stride(DX, 1), pointer(DY), stride(DY, 1))\nend\nfunction dotu(DX::Union{DenseArray{T},AbstractVector{T}}, DY::Union{DenseArray{T},AbstractVector{T}}) where T<:BlasComplex\n    @assert !has_offset_axes(DX, DY)\n    n = length(DX)\n    if n != length(DY)\n        throw(DimensionMismatch(\"dot product arguments have lengths $(length(DX)) and $(length(DY))\"))\n    end\n    GC.@preserve DX DY dotu(n, pointer(DX), stride(DX, 1), pointer(DY), stride(DY, 1))\nend\n\n## nrm2\n\n\"\"\"\n    nrm2(n, X, incx)\n\n2-norm of a vector consisting of `n` elements of array `X` with stride `incx`.\n\n# Examples\n```jldoctest\njulia> BLAS.nrm2(4, fill(1.0, 8), 2)\n2.0\n\njulia> BLAS.nrm2(1, fill(1.0, 8), 2)\n1.0\n```\n\"\"\"\nfunction nrm2 end\n\nfor (fname, elty, ret_type) in ((:dnrm2_,:Float64,:Float64),\n                                (:snrm2_,:Float32,:Float32),\n                                (:dznrm2_,:ComplexF64,:Float64),\n                                (:scnrm2_,:ComplexF32,:Float32))\n    @eval begin\n        # SUBROUTINE DNRM2(N,X,INCX)\n        function nrm2(n::Integer, X::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer)\n            ccall((@blasfunc($fname), libblas), $ret_type,\n                (Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 n, X, incx)\n        end\n    end\nend\nnrm2(x::Union{AbstractVector,DenseArray}) = GC.@preserve x nrm2(length(x), pointer(x), stride1(x))\n\n## asum\n\n\"\"\"\n    asum(n, X, incx)\n\nSum of the absolute values of the first `n` elements of array `X` with stride `incx`.\n\n# Examples\n```jldoctest\njulia> BLAS.asum(5, fill(1.0im, 10), 2)\n5.0\n\njulia> BLAS.asum(2, fill(1.0im, 10), 5)\n2.0\n```\n\"\"\"\nfunction asum end\n\nfor (fname, elty, ret_type) in ((:dasum_,:Float64,:Float64),\n                                (:sasum_,:Float32,:Float32),\n                                (:dzasum_,:ComplexF64,:Float64),\n                                (:scasum_,:ComplexF32,:Float32))\n    @eval begin\n        # SUBROUTINE ASUM(N, X, INCX)\n        function asum(n::Integer, X::Union{Ptr{$elty},AbstractArray{$elty}}, incx::Integer)\n            ccall((@blasfunc($fname), libblas), $ret_type,\n                (Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 n, X, incx)\n        end\n    end\nend\nasum(x::Union{AbstractVector,DenseArray}) = GC.@preserve x asum(length(x), pointer(x), stride1(x))\n\n## axpy\n\n\"\"\"\n    axpy!(a, X, Y)\n\nOverwrite `Y` with `a*X + Y`, where `a` is a scalar. Return `Y`.\n\n# Examples\n```jldoctest\njulia> x = [1; 2; 3];\n\njulia> y = [4; 5; 6];\n\njulia> BLAS.axpy!(2, x, y)\n3-element Array{Int64,1}:\n  6\n  9\n 12\n```\n\"\"\"\nfunction axpy! end\n\nfor (fname, elty) in ((:daxpy_,:Float64),\n                      (:saxpy_,:Float32),\n                      (:zaxpy_,:ComplexF64),\n                      (:caxpy_,:ComplexF32))\n    @eval begin\n                # SUBROUTINE DAXPY(N,DA,DX,INCX,DY,INCY)\n                # DY <- DA*DX + DY\n                #*     .. Scalar Arguments ..\n                #      DOUBLE PRECISION DA\n                #      INTEGER INCX,INCY,N\n                #*     .. Array Arguments ..\n                #      DOUBLE PRECISION DX(*),DY(*)\n        function axpy!(n::Integer, alpha::($elty), dx::Union{Ptr{$elty}, AbstractArray{$elty}}, incx::Integer, dy::Union{Ptr{$elty}, AbstractArray{$elty}}, incy::Integer)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 n, alpha, dx, incx, dy, incy)\n            dy\n        end\n    end\nend\nfunction axpy!(alpha::Number, x::Union{DenseArray{T},StridedVector{T}}, y::Union{DenseArray{T},StridedVector{T}}) where T<:BlasFloat\n    if length(x) != length(y)\n        throw(DimensionMismatch(\"x has length $(length(x)), but y has length $(length(y))\"))\n    end\n    GC.@preserve x y axpy!(length(x), convert(T,alpha), pointer(x), stride(x, 1), pointer(y), stride(y, 1))\n    y\nend\n\nfunction axpy!(alpha::Number, x::Array{T}, rx::Union{UnitRange{Ti},AbstractRange{Ti}},\n               y::Array{T}, ry::Union{UnitRange{Ti},AbstractRange{Ti}}) where {T<:BlasFloat,Ti<:Integer}\n    if length(rx) != length(ry)\n        throw(DimensionMismatch(\"ranges of differing lengths\"))\n    end\n    if minimum(rx) < 1 || maximum(rx) > length(x)\n        throw(ArgumentError(\"range out of bounds for x, of length $(length(x))\"))\n    end\n    if minimum(ry) < 1 || maximum(ry) > length(y)\n        throw(ArgumentError(\"range out of bounds for y, of length $(length(y))\"))\n    end\n    GC.@preserve x y axpy!(length(rx), convert(T, alpha), pointer(x)+(first(rx)-1)*sizeof(T), step(rx), pointer(y)+(first(ry)-1)*sizeof(T), step(ry))\n    y\nend\n\n\"\"\"\n    axpby!(a, X, b, Y)\n\nOverwrite `Y` with `X*a + Y*b`, where `a` and `b` are scalars. Return `Y`.\n\n# Examples\n```jldoctest\njulia> x = [1., 2, 3];\n\njulia> y = [4., 5, 6];\n\njulia> BLAS.axpby!(2., x, 3., y)\n3-element Array{Float64,1}:\n14.0\n19.0\n24.0\n```\n\"\"\"\nfunction axpby! end\n\nfor (fname, elty) in ((:daxpby_,:Float64), (:saxpby_,:Float32),\n                      (:zaxpby_,:ComplexF64), (:caxpby_,:ComplexF32))\n    @eval begin\n        # SUBROUTINE DAXPBY(N,DA,DX,INCX,DB,DY,INCY)\n        # DY <- DA*DX + DB*DY\n        #*     .. Scalar Arguments ..\n        #      DOUBLE PRECISION DA,DB\n        #      INTEGER INCX,INCY,N\n        #*     .. Array Arguments ..\n        #      DOUBLE PRECISION DX(*),DY(*)\n        function axpby!(n::Integer, alpha::($elty), dx::Union{Ptr{$elty},\n                        AbstractArray{$elty}}, incx::Integer, beta::($elty),\n                        dy::Union{Ptr{$elty}, AbstractArray{$elty}}, incy::Integer)\n            ccall((@blasfunc($fname), libblas), Cvoid, (Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt}),\n                n, alpha, dx, incx, beta, dy, incy)\n            dy\n        end\n    end\nend\n\nfunction axpby!(alpha::Number, x::Union{DenseArray{T},AbstractVector{T}}, beta::Number, y::Union{DenseArray{T},AbstractVector{T}}) where T<:BlasFloat\n    @assert !has_offset_axes(x, y)\n    if length(x) != length(y)\n        throw(DimensionMismatch(\"x has length $(length(x)), but y has length $(length(y))\"))\n    end\n    GC.@preserve x y axpby!(length(x), convert(T,alpha), pointer(x), stride(x, 1), convert(T,beta), pointer(y), stride(y, 1))\n    y\nend\n\n## iamax\nfor (fname, elty) in ((:idamax_,:Float64),\n                      (:isamax_,:Float32),\n                      (:izamax_,:ComplexF64),\n                      (:icamax_,:ComplexF32))\n    @eval begin\n        function iamax(n::Integer, dx::Union{Ptr{$elty}, AbstractArray{$elty}}, incx::Integer)\n            ccall((@blasfunc($fname), libblas),BlasInt,\n                (Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                n, dx, incx)\n        end\n    end\nend\niamax(dx::Union{AbstractVector,DenseArray}) = GC.@preserve dx iamax(length(dx), pointer(dx), stride1(dx))\n\n# Level 2\n## mv\n### gemv\nfor (fname, elty) in ((:dgemv_,:Float64),\n                      (:sgemv_,:Float32),\n                      (:zgemv_,:ComplexF64),\n                      (:cgemv_,:ComplexF32))\n    @eval begin\n             #SUBROUTINE DGEMV(TRANS,M,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)\n             #*     .. Scalar Arguments ..\n             #      DOUBLE PRECISION ALPHA,BETA\n             #      INTEGER INCX,INCY,LDA,M,N\n             #      CHARACTER TRANS\n             #*     .. Array Arguments ..\n             #      DOUBLE PRECISION A(LDA,*),X(*),Y(*)\n        function gemv!(trans::AbstractChar, alpha::($elty), A::AbstractVecOrMat{$elty}, X::AbstractVector{$elty}, beta::($elty), Y::AbstractVector{$elty})\n            @assert !has_offset_axes(A, X, Y)\n            m,n = size(A,1),size(A,2)\n            if trans == 'N' && (length(X) != n || length(Y) != m)\n                throw(DimensionMismatch(\"A has dimensions $(size(A)), X has length $(length(X)) and Y has length $(length(Y))\"))\n            elseif trans == 'C' && (length(X) != m || length(Y) != n)\n                throw(DimensionMismatch(\"the adjoint of A has dimensions $n, $m, X has length $(length(X)) and Y has length $(length(Y))\"))\n            elseif trans == 'T' && (length(X) != m || length(Y) != n)\n                throw(DimensionMismatch(\"the transpose of A has dimensions $n, $m, X has length $(length(X)) and Y has length $(length(Y))\"))\n            end\n            chkstride1(A)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt}, Ref{$elty},\n                 Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt},\n                 Ref{$elty}, Ptr{$elty}, Ref{BlasInt}),\n                 trans, size(A,1), size(A,2), alpha,\n                 A, max(1,stride(A,2)), X, stride(X,1),\n                 beta, Y, stride(Y,1))\n            Y\n        end\n        function gemv(trans::AbstractChar, alpha::($elty), A::AbstractMatrix{$elty}, X::AbstractVector{$elty})\n            gemv!(trans, alpha, A, X, zero($elty), similar(X, $elty, size(A, (trans == 'N' ? 1 : 2))))\n        end\n        function gemv(trans::AbstractChar, A::AbstractMatrix{$elty}, X::AbstractVector{$elty})\n            gemv!(trans, one($elty), A, X, zero($elty), similar(X, $elty, size(A, (trans == 'N' ? 1 : 2))))\n        end\n    end\nend\n\n\"\"\"\n    gemv!(tA, alpha, A, x, beta, y)\n\nUpdate the vector `y` as `alpha*A*x + beta*y` or `alpha*A'x + beta*y`\naccording to [`tA`](@ref stdlib-blas-trans).\n`alpha` and `beta` are scalars. Return the updated `y`.\n\"\"\"\ngemv!\n\n\"\"\"\n    gemv(tA, alpha, A, x)\n\nReturn `alpha*A*x` or `alpha*A'x` according to [`tA`](@ref stdlib-blas-trans).\n`alpha` is a scalar.\n\"\"\"\ngemv(tA, alpha, A, x)\n\n\"\"\"\n    gemv(tA, A, x)\n\nReturn `A*x` or `A'x` according to [`tA`](@ref stdlib-blas-trans).\n\"\"\"\ngemv(tA, A, x)\n\n### (GB) general banded matrix-vector multiplication\n\n\"\"\"\n    gbmv!(trans, m, kl, ku, alpha, A, x, beta, y)\n\nUpdate vector `y` as `alpha*A*x + beta*y` or `alpha*A'*x + beta*y` according to [`trans`](@ref stdlib-blas-trans).\nThe matrix `A` is a general band matrix of dimension `m` by `size(A,2)` with `kl`\nsub-diagonals and `ku` super-diagonals. `alpha` and `beta` are scalars. Return the updated `y`.\n\"\"\"\nfunction gbmv! end\n\n\"\"\"\n    gbmv(trans, m, kl, ku, alpha, A, x)\n\nReturn `alpha*A*x` or `alpha*A'*x` according to [`trans`](@ref stdlib-blas-trans).\nThe matrix `A` is a general band matrix of dimension `m` by `size(A,2)` with `kl` sub-diagonals and `ku`\nsuper-diagonals, and `alpha` is a scalar.\n\"\"\"\nfunction gbmv end\n\nfor (fname, elty) in ((:dgbmv_,:Float64),\n                      (:sgbmv_,:Float32),\n                      (:zgbmv_,:ComplexF64),\n                      (:cgbmv_,:ComplexF32))\n    @eval begin\n             # SUBROUTINE DGBMV(TRANS,M,N,KL,KU,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)\n             # *     .. Scalar Arguments ..\n             #       DOUBLE PRECISION ALPHA,BETA\n             #       INTEGER INCX,INCY,KL,KU,LDA,M,N\n             #       CHARACTER TRANS\n             # *     .. Array Arguments ..\n             #       DOUBLE PRECISION A(LDA,*),X(*),Y(*)\n        function gbmv!(trans::AbstractChar, m::Integer, kl::Integer, ku::Integer, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty}, beta::($elty), y::AbstractVector{$elty})\n            @assert !has_offset_axes(A, x, y)\n            chkstride1(A)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt}, Ref{BlasInt},\n                 Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt},\n                 Ptr{$elty}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}),\n                 trans, m, size(A,2), kl,\n                 ku, alpha, A, max(1,stride(A,2)),\n                 x, stride(x,1), beta, y, stride(y,1))\n            y\n        end\n        function gbmv(trans::AbstractChar, m::Integer, kl::Integer, ku::Integer, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            n = size(A,2)\n            leny = trans == 'N' ? m : n\n            gbmv!(trans, m, kl, ku, alpha, A, x, zero($elty), similar(x, $elty, leny))\n        end\n        function gbmv(trans::AbstractChar, m::Integer, kl::Integer, ku::Integer, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            gbmv(trans, m, kl, ku, one($elty), A, x)\n        end\n    end\nend\n\n### symv\n\n\"\"\"\n    symv!(ul, alpha, A, x, beta, y)\n\nUpdate the vector `y` as `alpha*A*x + beta*y`. `A` is assumed to be symmetric.\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n`alpha` and `beta` are scalars. Return the updated `y`.\n\"\"\"\nfunction symv! end\n\nfor (fname, elty, lib) in ((:dsymv_,:Float64,libblas),\n                           (:ssymv_,:Float32,libblas),\n                           (:zsymv_,:ComplexF64,liblapack),\n                           (:csymv_,:ComplexF32,liblapack))\n    # Note that the complex symv are not BLAS but auiliary functions in LAPACK\n    @eval begin\n             #      SUBROUTINE DSYMV(UPLO,N,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)\n             #     .. Scalar Arguments ..\n             #      DOUBLE PRECISION ALPHA,BETA\n             #      INTEGER INCX,INCY,LDA,N\n             #      CHARACTER UPLO\n             #     .. Array Arguments ..\n             #      DOUBLE PRECISION A(LDA,*),X(*),Y(*)\n        function symv!(uplo::AbstractChar, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty}, beta::($elty), y::AbstractVector{$elty})\n            @assert !has_offset_axes(A, x, y)\n            m, n = size(A)\n            if m != n\n                throw(DimensionMismatch(\"matrix A is $m by $n but must be square\"))\n            end\n            if n != length(x)\n                throw(DimensionMismatch(\"A has size $(size(A)), and x has length $(length(x))\"))\n            end\n            if m != length(y)\n                throw(DimensionMismatch(\"A has size $(size(A)), and y has length $(length(y))\"))\n            end\n            chkstride1(A)\n            ccall((@blasfunc($fname), $lib), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ref{$elty},\n                 Ptr{$elty}, Ref{BlasInt}),\n                 uplo, n, alpha, A,\n                 max(1,stride(A,2)), x, stride(x,1), beta,\n                 y, stride(y,1))\n            y\n        end\n        function symv(uplo::AbstractChar, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n                symv!(uplo, alpha, A, x, zero($elty), similar(x))\n        end\n        function symv(uplo::AbstractChar, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            symv(uplo, one($elty), A, x)\n        end\n    end\nend\n\n\"\"\"\n    symv(ul, alpha, A, x)\n\nReturn `alpha*A*x`. `A` is assumed to be symmetric.\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n`alpha` is a scalar.\n\"\"\"\nsymv(ul, alpha, A, x)\n\n\"\"\"\n    symv(ul, A, x)\n\nReturn `A*x`. `A` is assumed to be symmetric.\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n\"\"\"\nsymv(ul, A, x)\n\n### hemv\nfor (fname, elty) in ((:zhemv_,:ComplexF64),\n                      (:chemv_,:ComplexF32))\n    @eval begin\n        function hemv!(uplo::AbstractChar, \u03b1::$elty, A::AbstractMatrix{$elty}, x::AbstractVector{$elty}, \u03b2::$elty, y::AbstractVector{$elty})\n            @assert !has_offset_axes(A, x, y)\n            m, n = size(A)\n            if m != n\n                throw(DimensionMismatch(\"matrix A is $m by $n but must be square\"))\n            end\n            if n != length(x)\n                throw(DimensionMismatch(\"A has size $(size(A)), and x has length $(length(x))\"))\n            end\n            if m != length(y)\n                throw(DimensionMismatch(\"A has size $(size(A)), and y has length $(length(y))\"))\n            end\n            chkstride1(A)\n            lda = max(1, stride(A, 2))\n            incx = stride(x, 1)\n            incy = stride(y, 1)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ref{$elty},\n                 Ptr{$elty}, Ref{BlasInt}),\n                uplo, n, \u03b1, A,\n                lda, x, incx, \u03b2,\n                y, incy)\n            y\n        end\n        function hemv(uplo::AbstractChar, \u03b1::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            hemv!(uplo, \u03b1, A, x, zero($elty), similar(x))\n        end\n        function hemv(uplo::AbstractChar, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            hemv(uplo, one($elty), A, x)\n        end\n    end\nend\n\n### sbmv, (SB) symmetric banded matrix-vector multiplication\nfor (fname, elty) in ((:dsbmv_,:Float64),\n                      (:ssbmv_,:Float32))\n    @eval begin\n             #       SUBROUTINE DSBMV(UPLO,N,K,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)\n             # *     .. Scalar Arguments ..\n             #       DOUBLE PRECISION ALPHA,BETA\n             #       INTEGER INCX,INCY,K,LDA,N\n             #       CHARACTER UPLO\n             # *     .. Array Arguments ..\n             #       DOUBLE PRECISION A(LDA,*),X(*),Y(*)\n        function sbmv!(uplo::AbstractChar, k::Integer, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty}, beta::($elty), y::AbstractVector{$elty})\n            @assert !has_offset_axes(A, x, y)\n            chkstride1(A)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt}, Ref{$elty},\n                 Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt},\n                 Ref{$elty}, Ptr{$elty}, Ref{BlasInt}),\n                 uplo, size(A,2), k, alpha,\n                 A, max(1,stride(A,2)), x, stride(x,1),\n                 beta, y, stride(y,1))\n            y\n        end\n        function sbmv(uplo::AbstractChar, k::Integer, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            n = size(A,2)\n            sbmv!(uplo, k, alpha, A, x, zero($elty), similar(x, $elty, n))\n        end\n        function sbmv(uplo::AbstractChar, k::Integer, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            sbmv(uplo, k, one($elty), A, x)\n        end\n    end\nend\n\n\"\"\"\n    sbmv(uplo, k, alpha, A, x)\n\nReturn `alpha*A*x` where `A` is a symmetric band matrix of order `size(A,2)` with `k`\nsuper-diagonals stored in the argument `A`.\nOnly the [`uplo`](@ref stdlib-blas-uplo) triangle of `A` is used.\n\"\"\"\nsbmv(uplo, k, alpha, A, x)\n\n\"\"\"\n    sbmv(uplo, k, A, x)\n\nReturn `A*x` where `A` is a symmetric band matrix of order `size(A,2)` with `k`\nsuper-diagonals stored in the argument `A`.\nOnly the [`uplo`](@ref stdlib-blas-uplo) triangle of `A` is used.\n\"\"\"\nsbmv(uplo, k, A, x)\n\n\"\"\"\n    sbmv!(uplo, k, alpha, A, x, beta, y)\n\nUpdate vector `y` as `alpha*A*x + beta*y` where `A` is a a symmetric band matrix of order\n`size(A,2)` with `k` super-diagonals stored in the argument `A`. The storage layout for `A`\nis described the reference BLAS module, level-2 BLAS at\n<http://www.netlib.org/lapack/explore-html/>.\nOnly the [`uplo`](@ref stdlib-blas-uplo) triangle of `A` is used.\n\nReturn the updated `y`.\n\"\"\"\nsbmv!\n\n### hbmv, (HB) Hermitian banded matrix-vector multiplication\nfor (fname, elty) in ((:zhbmv_,:ComplexF64),\n                      (:chbmv_,:ComplexF32))\n    @eval begin\n             #       SUBROUTINE ZHBMV(UPLO,N,K,ALPHA,A,LDA,X,INCX,BETA,Y,INCY)\n             # *     .. Scalar Arguments ..\n             #       DOUBLE PRECISION ALPHA,BETA\n             #       INTEGER INCX,INCY,K,LDA,N\n             #       CHARACTER UPLO\n             # *     .. Array Arguments ..\n             #       DOUBLE PRECISION A(LDA,*),X(*),Y(*)\n        function hbmv!(uplo::AbstractChar, k::Integer, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty}, beta::($elty), y::AbstractVector{$elty})\n            @assert !has_offset_axes(A, x, y)\n            chkstride1(A)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt}, Ref{$elty},\n                 Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt},\n                 Ref{$elty}, Ptr{$elty}, Ref{BlasInt}),\n                 uplo, size(A,2), k, alpha,\n                 A, max(1,stride(A,2)), x, stride(x,1),\n                 beta, y, stride(y,1))\n            y\n        end\n        function hbmv(uplo::AbstractChar, k::Integer, alpha::($elty), A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            n = size(A,2)\n            hbmv!(uplo, k, alpha, A, x, zero($elty), similar(x, $elty, n))\n        end\n        function hbmv(uplo::AbstractChar, k::Integer, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            hbmv(uplo, k, one($elty), A, x)\n        end\n    end\nend\n\n### trmv, Triangular matrix-vector multiplication\n\n\"\"\"\n    trmv(ul, tA, dA, A, b)\n\nReturn `op(A)*b`, where `op` is determined by [`tA`](@ref stdlib-blas-trans).\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\n\"\"\"\nfunction trmv end\n\n\"\"\"\n    trmv!(ul, tA, dA, A, b)\n\nReturn `op(A)*b`, where `op` is determined by [`tA`](@ref stdlib-blas-trans).\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\nThe multiplication occurs in-place on `b`.\n\"\"\"\nfunction trmv! end\n\nfor (fname, elty) in ((:dtrmv_,:Float64),\n                        (:strmv_,:Float32),\n                        (:ztrmv_,:ComplexF64),\n                        (:ctrmv_,:ComplexF32))\n    @eval begin\n                #       SUBROUTINE DTRMV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX)\n                # *     .. Scalar Arguments ..\n                #       INTEGER INCX,LDA,N\n                #       CHARACTER DIAG,TRANS,UPLO\n                # *     .. Array Arguments ..\n                #       DOUBLE PRECISION A(LDA,*),X(*)\n        function trmv!(uplo::AbstractChar, trans::AbstractChar, diag::AbstractChar, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            @assert !has_offset_axes(A, x)\n            n = checksquare(A)\n            if n != length(x)\n                throw(DimensionMismatch(\"A has size ($n,$n), x has length $(length(x))\"))\n            end\n            chkstride1(A)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{UInt8}, Ref{BlasInt},\n                 Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 uplo, trans, diag, n,\n                 A, max(1,stride(A,2)), x, max(1,stride(x, 1)))\n            x\n        end\n        function trmv(uplo::AbstractChar, trans::AbstractChar, diag::AbstractChar, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            trmv!(uplo, trans, diag, A, copy(x))\n        end\n    end\nend\n\n### trsv, Triangular matrix-vector solve\n\n\"\"\"\n    trsv!(ul, tA, dA, A, b)\n\nOverwrite `b` with the solution to `A*x = b` or one of the other two variants determined by\n[`tA`](@ref stdlib-blas-trans) and [`ul`](@ref stdlib-blas-uplo).\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\nReturn the updated `b`.\n\"\"\"\nfunction trsv! end\n\n\"\"\"\n    trsv(ul, tA, dA, A, b)\n\nReturn the solution to `A*x = b` or one of the other two variants determined by\n[`tA`](@ref stdlib-blas-trans) and [`ul`](@ref stdlib-blas-uplo).\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\n\"\"\"\nfunction trsv end\n\nfor (fname, elty) in ((:dtrsv_,:Float64),\n                        (:strsv_,:Float32),\n                        (:ztrsv_,:ComplexF64),\n                        (:ctrsv_,:ComplexF32))\n    @eval begin\n                #       SUBROUTINE DTRSV(UPLO,TRANS,DIAG,N,A,LDA,X,INCX)\n                #       .. Scalar Arguments ..\n                #       INTEGER INCX,LDA,N\n                #       CHARACTER DIAG,TRANS,UPLO\n                #       .. Array Arguments ..\n                #       DOUBLE PRECISION A(LDA,*),X(*)\n        function trsv!(uplo::AbstractChar, trans::AbstractChar, diag::AbstractChar, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            @assert !has_offset_axes(A, x)\n            n = checksquare(A)\n            if n != length(x)\n                throw(DimensionMismatch(\"size of A is $n != length(x) = $(length(x))\"))\n            end\n            chkstride1(A)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{UInt8}, Ref{BlasInt},\n                 Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 uplo, trans, diag, n,\n                 A, max(1,stride(A,2)), x, stride(x, 1))\n            x\n        end\n        function trsv(uplo::AbstractChar, trans::AbstractChar, diag::AbstractChar, A::AbstractMatrix{$elty}, x::AbstractVector{$elty})\n            trsv!(uplo, trans, diag, A, copy(x))\n        end\n    end\nend\n\n### ger\n\n\"\"\"\n    ger!(alpha, x, y, A)\n\nRank-1 update of the matrix `A` with vectors `x` and `y` as `alpha*x*y' + A`.\n\"\"\"\nfunction ger! end\n\nfor (fname, elty) in ((:dger_,:Float64),\n                      (:sger_,:Float32),\n                      (:zgerc_,:ComplexF64),\n                      (:cgerc_,:ComplexF32))\n    @eval begin\n        function ger!(\u03b1::$elty, x::AbstractVector{$elty}, y::AbstractVector{$elty}, A::AbstractMatrix{$elty})\n            @assert !has_offset_axes(A, x, y)\n            m, n = size(A)\n            if m != length(x) || n != length(y)\n                throw(DimensionMismatch(\"A has size ($m,$n), x has length $(length(x)), y has length $(length(y))\"))\n            end\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{BlasInt}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty},\n                 Ref{BlasInt}),\n                 m, n, \u03b1, x,\n                 stride(x, 1), y, stride(y, 1), A,\n                 max(1,stride(A,2)))\n            A\n        end\n    end\nend\n\n### syr\n\n\"\"\"\n    syr!(uplo, alpha, x, A)\n\nRank-1 update of the symmetric matrix `A` with vector `x` as `alpha*x*transpose(x) + A`.\n[`uplo`](@ref stdlib-blas-uplo) controls which triangle of `A` is updated. Returns `A`.\n\"\"\"\nfunction syr! end\n\nfor (fname, elty, lib) in ((:dsyr_,:Float64,libblas),\n                           (:ssyr_,:Float32,libblas),\n                           (:zsyr_,:ComplexF64,liblapack),\n                           (:csyr_,:ComplexF32,liblapack))\n    @eval begin\n        function syr!(uplo::AbstractChar, \u03b1::$elty, x::AbstractVector{$elty}, A::AbstractMatrix{$elty})\n            @assert !has_offset_axes(A, x)\n            n = checksquare(A)\n            if length(x) != n\n                throw(DimensionMismatch(\"A has size ($n,$n), x has length $(length(x))\"))\n            end\n            ccall((@blasfunc($fname), $lib), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 uplo, n, \u03b1, x,\n                 stride(x, 1), A, max(1,stride(A, 2)))\n            A\n        end\n    end\nend\n\n### her\n\n\"\"\"\n    her!(uplo, alpha, x, A)\n\nMethods for complex arrays only. Rank-1 update of the Hermitian matrix `A` with vector `x`\nas `alpha*x*x' + A`.\n[`uplo`](@ref stdlib-blas-uplo) controls which triangle of `A` is updated. Returns `A`.\n\"\"\"\nfunction her! end\n\nfor (fname, elty, relty) in ((:zher_,:ComplexF64, :Float64),\n                             (:cher_,:ComplexF32, :Float32))\n    @eval begin\n        function her!(uplo::AbstractChar, \u03b1::$relty, x::AbstractVector{$elty}, A::AbstractMatrix{$elty})\n            @assert !has_offset_axes(A, x)\n            n = checksquare(A)\n            if length(x) != n\n                throw(DimensionMismatch(\"A has size ($n,$n), x has length $(length(x))\"))\n            end\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{BlasInt}, Ref{$relty}, Ptr{$elty},\n                 Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 uplo, n, \u03b1, x,\n                 stride(x, 1), A, max(1,stride(A,2)))\n            A\n        end\n    end\nend\n\n# Level 3\n## (GE) general matrix-matrix multiplication\n\n\"\"\"\n    gemm!(tA, tB, alpha, A, B, beta, C)\n\nUpdate `C` as `alpha*A*B + beta*C` or the other three variants according to\n[`tA`](@ref stdlib-blas-trans) and `tB`. Return the updated `C`.\n\"\"\"\nfunction gemm! end\n\nfor (gemm, elty) in\n        ((:dgemm_,:Float64),\n         (:sgemm_,:Float32),\n         (:zgemm_,:ComplexF64),\n         (:cgemm_,:ComplexF32))\n    @eval begin\n             # SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n             # *     .. Scalar Arguments ..\n             #       DOUBLE PRECISION ALPHA,BETA\n             #       INTEGER K,LDA,LDB,LDC,M,N\n             #       CHARACTER TRANSA,TRANSB\n             # *     .. Array Arguments ..\n             #       DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)\n        function gemm!(transA::AbstractChar, transB::AbstractChar, alpha::($elty), A::AbstractVecOrMat{$elty}, B::AbstractVecOrMat{$elty}, beta::($elty), C::AbstractVecOrMat{$elty})\n#           if any([stride(A,1), stride(B,1), stride(C,1)] .!= 1)\n#               error(\"gemm!: BLAS module requires contiguous matrix columns\")\n#           end  # should this be checked on every call?\n            @assert !has_offset_axes(A, B, C)\n            m = size(A, transA == 'N' ? 1 : 2)\n            ka = size(A, transA == 'N' ? 2 : 1)\n            kb = size(B, transB == 'N' ? 1 : 2)\n            n = size(B, transB == 'N' ? 2 : 1)\n            if ka != kb || m != size(C,1) || n != size(C,2)\n                throw(DimensionMismatch(\"A has size ($m,$ka), B has size ($kb,$n), C has size $(size(C))\"))\n            end\n            chkstride1(A)\n            chkstride1(B)\n            chkstride1(C)\n            ccall((@blasfunc($gemm), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                 Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt},\n                 Ptr{$elty}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}),\n                 transA, transB, m, n,\n                 ka, alpha, A, max(1,stride(A,2)),\n                 B, max(1,stride(B,2)), beta, C,\n                 max(1,stride(C,2)))\n            C\n        end\n        function gemm(transA::AbstractChar, transB::AbstractChar, alpha::($elty), A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            gemm!(transA, transB, alpha, A, B, zero($elty), similar(B, $elty, (size(A, transA == 'N' ? 1 : 2), size(B, transB == 'N' ? 2 : 1))))\n        end\n        function gemm(transA::AbstractChar, transB::AbstractChar, A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            gemm(transA, transB, one($elty), A, B)\n        end\n    end\nend\n\n\"\"\"\n    gemm(tA, tB, alpha, A, B)\n\nReturn `alpha*A*B` or the other three variants according to [`tA`](@ref stdlib-blas-trans) and `tB`.\n\"\"\"\ngemm(tA, tB, alpha, A, B)\n\n\"\"\"\n    gemm(tA, tB, A, B)\n\nReturn `A*B` or the other three variants according to [`tA`](@ref stdlib-blas-trans) and `tB`.\n\"\"\"\ngemm(tA, tB, A, B)\n\n\n## (SY) symmetric matrix-matrix and matrix-vector multiplication\nfor (mfname, elty) in ((:dsymm_,:Float64),\n                       (:ssymm_,:Float32),\n                       (:zsymm_,:ComplexF64),\n                       (:csymm_,:ComplexF32))\n    @eval begin\n             #     SUBROUTINE DSYMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n             #     .. Scalar Arguments ..\n             #     DOUBLE PRECISION ALPHA,BETA\n             #     INTEGER LDA,LDB,LDC,M,N\n             #     CHARACTER SIDE,UPLO\n             #     .. Array Arguments ..\n             #     DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)\n        function symm!(side::AbstractChar, uplo::AbstractChar, alpha::($elty), A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty}, beta::($elty), C::AbstractMatrix{$elty})\n            @assert !has_offset_axes(A, B, C)\n            m, n = size(C)\n            j = checksquare(A)\n            if j != (side == 'L' ? m : n)\n                throw(DimensionMismatch(\"A has size $(size(A)), C has size ($m,$n)\"))\n            end\n            if size(B,2) != n\n                throw(DimensionMismatch(\"B has second dimension $(size(B,2)) but needs to match second dimension of C, $n\"))\n            end\n            chkstride1(A)\n            chkstride1(B)\n            chkstride1(C)\n            ccall((@blasfunc($mfname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                 Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty},\n                 Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt}),\n                 side, uplo, m, n,\n                 alpha, A, max(1,stride(A,2)), B,\n                 max(1,stride(B,2)), beta, C, max(1,stride(C,2)))\n            C\n        end\n        function symm(side::AbstractChar, uplo::AbstractChar, alpha::($elty), A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            symm!(side, uplo, alpha, A, B, zero($elty), similar(B))\n        end\n        function symm(side::AbstractChar, uplo::AbstractChar, A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            symm(side, uplo, one($elty), A, B)\n        end\n    end\nend\n\n\"\"\"\n    symm(side, ul, alpha, A, B)\n\nReturn `alpha*A*B` or `alpha*B*A` according to [`side`](@ref stdlib-blas-side).\n`A` is assumed to be symmetric. Only\nthe [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n\"\"\"\nsymm(side, ul, alpha, A, B)\n\n\"\"\"\n    symm(side, ul, A, B)\n\nReturn `A*B` or `B*A` according to [`side`](@ref stdlib-blas-side).\n`A` is assumed to be symmetric. Only the [`ul`](@ref stdlib-blas-uplo)\ntriangle of `A` is used.\n\"\"\"\nsymm(side, ul, A, B)\n\n\"\"\"\n    symm!(side, ul, alpha, A, B, beta, C)\n\nUpdate `C` as `alpha*A*B + beta*C` or `alpha*B*A + beta*C` according to [`side`](@ref stdlib-blas-side).\n`A` is assumed to be symmetric. Only the [`ul`](@ref stdlib-blas-uplo) triangle of\n`A` is used. Return the updated `C`.\n\"\"\"\nsymm!\n\n## (HE) Hermitian matrix-matrix and matrix-vector multiplication\nfor (mfname, elty) in ((:zhemm_,:ComplexF64),\n                       (:chemm_,:ComplexF32))\n    @eval begin\n             #     SUBROUTINE DHEMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n             #     .. Scalar Arguments ..\n             #     DOUBLE PRECISION ALPHA,BETA\n             #     INTEGER LDA,LDB,LDC,M,N\n             #     CHARACTER SIDE,UPLO\n             #     .. Array Arguments ..\n             #     DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)\n        function hemm!(side::AbstractChar, uplo::AbstractChar, alpha::($elty), A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty}, beta::($elty), C::AbstractMatrix{$elty})\n            @assert !has_offset_axes(A, B, C)\n            m, n = size(C)\n            j = checksquare(A)\n            if j != (side == 'L' ? m : n)\n                throw(DimensionMismatch(\"A has size $(size(A)), C has size ($m,$n)\"))\n            end\n            if size(B,2) != n\n                throw(DimensionMismatch(\"B has second dimension $(size(B,2)) but needs to match second dimension of C, $n\"))\n            end\n            chkstride1(A)\n            chkstride1(B)\n            chkstride1(C)\n            ccall((@blasfunc($mfname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                 Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty},\n                 Ref{BlasInt}, Ref{$elty}, Ptr{$elty}, Ref{BlasInt}),\n                 side, uplo, m, n,\n                 alpha, A, max(1,stride(A,2)), B,\n                 max(1,stride(B,2)), beta, C, max(1,stride(C,2)))\n            C\n        end\n        function hemm(side::AbstractChar, uplo::AbstractChar, alpha::($elty), A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            hemm!(side, uplo, alpha, A, B, zero($elty), similar(B))\n        end\n        function hemm(side::AbstractChar, uplo::AbstractChar, A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            hemm(side, uplo, one($elty), A, B)\n        end\n    end\nend\n\n## syrk\n\n\"\"\"\n    syrk!(uplo, trans, alpha, A, beta, C)\n\nRank-k update of the symmetric matrix `C` as `alpha*A*transpose(A) + beta*C` or `alpha*transpose(A)*A +\nbeta*C` according to [`trans`](@ref stdlib-blas-trans).\nOnly the [`uplo`](@ref stdlib-blas-uplo) triangle of `C` is used. Returns `C`.\n\"\"\"\nfunction syrk! end\n\n\"\"\"\n    syrk(uplo, trans, alpha, A)\n\nReturns either the upper triangle or the lower triangle of `A`,\naccording to [`uplo`](@ref stdlib-blas-uplo),\nof `alpha*A*transpose(A)` or `alpha*transpose(A)*A`,\naccording to [`trans`](@ref stdlib-blas-trans).\n\"\"\"\nfunction syrk end\n\nfor (fname, elty) in ((:dsyrk_,:Float64),\n                      (:ssyrk_,:Float32),\n                      (:zsyrk_,:ComplexF64),\n                      (:csyrk_,:ComplexF32))\n   @eval begin\n       # SUBROUTINE DSYRK(UPLO,TRANS,N,K,ALPHA,A,LDA,BETA,C,LDC)\n       # *     .. Scalar Arguments ..\n       #       REAL ALPHA,BETA\n       #       INTEGER K,LDA,LDC,N\n       #       CHARACTER TRANS,UPLO\n       # *     .. Array Arguments ..\n       #       REAL A(LDA,*),C(LDC,*)\n       function syrk!(uplo::AbstractChar, trans::AbstractChar,\n                      alpha::($elty), A::AbstractVecOrMat{$elty},\n                      beta::($elty), C::AbstractMatrix{$elty})\n           @assert !has_offset_axes(A, C)\n           n = checksquare(C)\n           nn = size(A, trans == 'N' ? 1 : 2)\n           if nn != n throw(DimensionMismatch(\"C has size ($n,$n), corresponding dimension of A is $nn\")) end\n           k  = size(A, trans == 'N' ? 2 : 1)\n           chkstride1(A)\n           chkstride1(C)\n           ccall((@blasfunc($fname), libblas), Cvoid,\n                 (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                  Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Ref{$elty},\n                  Ptr{$elty}, Ref{BlasInt}),\n                 uplo, trans, n, k,\n                 alpha, A, max(1,stride(A,2)), beta,\n                 C, max(1,stride(C,2)))\n            C\n        end\n    end\nend\nfunction syrk(uplo::AbstractChar, trans::AbstractChar, alpha::Number, A::AbstractVecOrMat)\n    T = eltype(A)\n    n = size(A, trans == 'N' ? 1 : 2)\n    syrk!(uplo, trans, convert(T,alpha), A, zero(T), similar(A, T, (n, n)))\nend\nsyrk(uplo::AbstractChar, trans::AbstractChar, A::AbstractVecOrMat) = syrk(uplo, trans, one(eltype(A)), A)\n\n\"\"\"\n    herk!(uplo, trans, alpha, A, beta, C)\n\nMethods for complex arrays only. Rank-k update of the Hermitian matrix `C` as `alpha*A*A' +\nbeta*C` or `alpha*A'*A + beta*C` according to [`trans`](@ref stdlib-blas-trans).\nOnly the [`uplo`](@ref stdlib-blas-uplo) triangle of `C` is updated.\nReturns `C`.\n\"\"\"\nfunction herk! end\n\n\"\"\"\n    herk(uplo, trans, alpha, A)\n\nMethods for complex arrays only.\nReturns the [`uplo`](@ref stdlib-blas-uplo) triangle of `alpha*A*A'` or `alpha*A'*A`,\naccording to [`trans`](@ref stdlib-blas-trans).\n\"\"\"\nfunction herk end\n\nfor (fname, elty, relty) in ((:zherk_, :ComplexF64, :Float64),\n                             (:cherk_, :ComplexF32, :Float32))\n   @eval begin\n       # SUBROUTINE CHERK(UPLO,TRANS,N,K,ALPHA,A,LDA,BETA,C,LDC)\n       # *     .. Scalar Arguments ..\n       #       REAL ALPHA,BETA\n       #       INTEGER K,LDA,LDC,N\n       #       CHARACTER TRANS,UPLO\n       # *     ..\n       # *     .. Array Arguments ..\n       #       COMPLEX A(LDA,*),C(LDC,*)\n       function herk!(uplo::AbstractChar, trans::AbstractChar, \u03b1::$relty, A::AbstractVecOrMat{$elty},\n                      \u03b2::$relty, C::AbstractMatrix{$elty})\n           @assert !has_offset_axes(A, C)\n           n = checksquare(C)\n           nn = size(A, trans == 'N' ? 1 : 2)\n           if nn != n\n               throw(DimensionMismatch(\"the matrix to update has dimension $n but the implied dimension of the update is $(size(A, trans == 'N' ? 1 : 2))\"))\n           end\n           chkstride1(A)\n           chkstride1(C)\n           k  = size(A, trans == 'N' ? 2 : 1)\n           ccall((@blasfunc($fname), libblas), Cvoid,\n                 (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                  Ref{$relty}, Ptr{$elty}, Ref{BlasInt}, Ref{$relty},\n                  Ptr{$elty}, Ref{BlasInt}),\n                 uplo, trans, n, k,\n                 \u03b1, A, max(1,stride(A,2)), \u03b2,\n                 C, max(1,stride(C,2)))\n           C\n       end\n       function herk(uplo::AbstractChar, trans::AbstractChar, \u03b1::$relty, A::AbstractVecOrMat{$elty})\n           n = size(A, trans == 'N' ? 1 : 2)\n           herk!(uplo, trans, \u03b1, A, zero($relty), similar(A, (n,n)))\n       end\n       herk(uplo::AbstractChar, trans::AbstractChar, A::AbstractVecOrMat{$elty}) = herk(uplo, trans, one($relty), A)\n   end\nend\n\n## syr2k\nfor (fname, elty) in ((:dsyr2k_,:Float64),\n                      (:ssyr2k_,:Float32),\n                      (:zsyr2k_,:ComplexF64),\n                      (:csyr2k_,:ComplexF32))\n    @eval begin\n             #       SUBROUTINE DSYR2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n             #\n             #       .. Scalar Arguments ..\n             #       REAL PRECISION ALPHA,BETA\n             #       INTEGER K,LDA,LDB,LDC,N\n             #       CHARACTER TRANS,UPLO\n             #       ..\n             #       .. Array Arguments ..\n             #       REAL PRECISION A(LDA,*),B(LDB,*),C(LDC,*)\n        function syr2k!(uplo::AbstractChar, trans::AbstractChar,\n                        alpha::($elty), A::AbstractVecOrMat{$elty}, B::AbstractVecOrMat{$elty},\n                        beta::($elty), C::AbstractMatrix{$elty})\n            @assert !has_offset_axes(A, B, C)\n            n = checksquare(C)\n            nn = size(A, trans == 'N' ? 1 : 2)\n            if nn != n throw(DimensionMismatch(\"C has size ($n,$n), corresponding dimension of A is $nn\")) end\n            k  = size(A, trans == 'N' ? 2 : 1)\n            chkstride1(A)\n            chkstride1(B)\n            chkstride1(C)\n            ccall((@blasfunc($fname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                 Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}, Ref{$elty},\n                 Ptr{$elty}, Ref{BlasInt}),\n                 uplo, trans, n, k,\n                 alpha, A, max(1,stride(A,2)), B, max(1,stride(B,2)), beta,\n                 C, max(1,stride(C,2)))\n            C\n        end\n    end\nend\nfunction syr2k(uplo::AbstractChar, trans::AbstractChar, alpha::Number, A::AbstractVecOrMat, B::AbstractVecOrMat)\n    T = eltype(A)\n    n = size(A, trans == 'N' ? 1 : 2)\n    syr2k!(uplo, trans, convert(T,alpha), A, B, zero(T), similar(A, T, (n, n)))\nend\nsyr2k(uplo::AbstractChar, trans::AbstractChar, A::AbstractVecOrMat, B::AbstractVecOrMat) = syr2k(uplo, trans, one(eltype(A)), A, B)\n\nfor (fname, elty1, elty2) in ((:zher2k_,:ComplexF64,:Float64), (:cher2k_,:ComplexF32,:Float32))\n   @eval begin\n       # SUBROUTINE CHER2K(UPLO,TRANS,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n       #\n       #       .. Scalar Arguments ..\n       #       COMPLEX ALPHA\n       #       REAL BETA\n       #       INTEGER K,LDA,LDB,LDC,N\n       #       CHARACTER TRANS,UPLO\n       #       ..\n       #       .. Array Arguments ..\n       #       COMPLEX A(LDA,*),B(LDB,*),C(LDC,*)\n       function her2k!(uplo::AbstractChar, trans::AbstractChar, alpha::($elty1),\n                       A::AbstractVecOrMat{$elty1}, B::AbstractVecOrMat{$elty1},\n                       beta::($elty2), C::AbstractMatrix{$elty1})\n           @assert !has_offset_axes(A, B, C)\n           n = checksquare(C)\n           nn = size(A, trans == 'N' ? 1 : 2)\n           if nn != n throw(DimensionMismatch(\"C has size ($n,$n), corresponding dimension of A is $nn\")) end\n           chkstride1(A)\n           chkstride1(B)\n           chkstride1(C)\n           k  = size(A, trans == 'N' ? 2 : 1)\n           ccall((@blasfunc($fname), libblas), Cvoid,\n                 (Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                  Ref{$elty1}, Ptr{$elty1}, Ref{BlasInt}, Ptr{$elty1}, Ref{BlasInt},\n                  Ref{$elty2},  Ptr{$elty1}, Ref{BlasInt}),\n                 uplo, trans, n, k,\n                 alpha, A, max(1,stride(A,2)), B, max(1,stride(B,2)),\n                 beta, C, max(1,stride(C,2)))\n           C\n       end\n       function her2k(uplo::AbstractChar, trans::AbstractChar, alpha::($elty1), A::AbstractVecOrMat{$elty1}, B::AbstractVecOrMat{$elty1})\n           n = size(A, trans == 'N' ? 1 : 2)\n           her2k!(uplo, trans, alpha, A, B, zero($elty2), similar(A, $elty1, (n,n)))\n       end\n       her2k(uplo::AbstractChar, trans::AbstractChar, A::AbstractVecOrMat{$elty1}, B::AbstractVecOrMat{$elty1}) = her2k(uplo, trans, one($elty1), A, B)\n   end\nend\n\n## (TR) Triangular matrix and vector multiplication and solution\n\n\"\"\"\n    trmm!(side, ul, tA, dA, alpha, A, B)\n\nUpdate `B` as `alpha*A*B` or one of the other three variants determined by\n[`side`](@ref stdlib-blas-side) and [`tA`](@ref stdlib-blas-trans).\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\nReturns the updated `B`.\n\"\"\"\nfunction trmm! end\n\n\"\"\"\n    trmm(side, ul, tA, dA, alpha, A, B)\n\nReturns `alpha*A*B` or one of the other three variants determined by\n[`side`](@ref stdlib-blas-side) and [`tA`](@ref stdlib-blas-trans).\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\n\"\"\"\nfunction trmm end\n\n\"\"\"\n    trsm!(side, ul, tA, dA, alpha, A, B)\n\nOverwrite `B` with the solution to `A*X = alpha*B` or one of the other three variants\ndetermined by [`side`](@ref stdlib-blas-side) and [`tA`](@ref stdlib-blas-trans).\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\nReturns the updated `B`.\n\"\"\"\nfunction trsm! end\n\n\"\"\"\n    trsm(side, ul, tA, dA, alpha, A, B)\n\nReturn the solution to `A*X = alpha*B` or one of the other three variants determined by\ndetermined by [`side`](@ref stdlib-blas-side) and [`tA`](@ref stdlib-blas-trans).\nOnly the [`ul`](@ref stdlib-blas-uplo) triangle of `A` is used.\n[`dA`](@ref stdlib-blas-diag) determines if the diagonal values are read or\nare assumed to be all ones.\n\"\"\"\nfunction trsm end\n\nfor (mmname, smname, elty) in\n        ((:dtrmm_,:dtrsm_,:Float64),\n         (:strmm_,:strsm_,:Float32),\n         (:ztrmm_,:ztrsm_,:ComplexF64),\n         (:ctrmm_,:ctrsm_,:ComplexF32))\n    @eval begin\n        #       SUBROUTINE DTRMM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB)\n        # *     .. Scalar Arguments ..\n        #       DOUBLE PRECISION ALPHA\n        #       INTEGER LDA,LDB,M,N\n        #       CHARACTER DIAG,SIDE,TRANSA,UPLO\n        # *     .. Array Arguments ..\n        #       DOUBLE PRECISION A(LDA,*),B(LDB,*)\n        function trmm!(side::AbstractChar, uplo::AbstractChar, transa::AbstractChar, diag::AbstractChar, alpha::Number,\n                       A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            @assert !has_offset_axes(A, B)\n            m, n = size(B)\n            nA = checksquare(A)\n            if nA != (side == 'L' ? m : n)\n                throw(DimensionMismatch(\"size of A, $(size(A)), doesn't match $side size of B with dims, $(size(B))\"))\n            end\n            chkstride1(A)\n            chkstride1(B)\n            ccall((@blasfunc($mmname), libblas), Cvoid,\n                  (Ref{UInt8}, Ref{UInt8}, Ref{UInt8}, Ref{UInt8}, Ref{BlasInt}, Ref{BlasInt},\n                   Ref{$elty}, Ptr{$elty}, Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                  side, uplo, transa, diag, m, n,\n                  alpha, A, max(1,stride(A,2)), B, max(1,stride(B,2)))\n            B\n        end\n        function trmm(side::AbstractChar, uplo::AbstractChar, transa::AbstractChar, diag::AbstractChar,\n                      alpha::$elty, A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            trmm!(side, uplo, transa, diag, alpha, A, copy(B))\n        end\n        #       SUBROUTINE DTRSM(SIDE,UPLO,TRANSA,DIAG,M,N,ALPHA,A,LDA,B,LDB)\n        # *     .. Scalar Arguments ..\n        #       DOUBLE PRECISION ALPHA\n        #       INTEGER LDA,LDB,M,N\n        #       CHARACTER DIAG,SIDE,TRANSA,UPLO\n        # *     .. Array Arguments ..\n        #       DOUBLE PRECISION A(LDA,*),B(LDB,*)\n        function trsm!(side::AbstractChar, uplo::AbstractChar, transa::AbstractChar, diag::AbstractChar,\n                       alpha::$elty, A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            @assert !has_offset_axes(A, B)\n            m, n = size(B)\n            k = checksquare(A)\n            if k != (side == 'L' ? m : n)\n                throw(DimensionMismatch(\"size of A is ($k,$k), size of B is ($m,$n), side is $side, and transa='$transa'\"))\n            end\n            chkstride1(A)\n            chkstride1(B)\n            ccall((@blasfunc($smname), libblas), Cvoid,\n                (Ref{UInt8}, Ref{UInt8}, Ref{UInt8}, Ref{UInt8},\n                 Ref{BlasInt}, Ref{BlasInt}, Ref{$elty}, Ptr{$elty},\n                 Ref{BlasInt}, Ptr{$elty}, Ref{BlasInt}),\n                 side, uplo, transa, diag,\n                 m, n, alpha, A,\n                 max(1,stride(A,2)), B, max(1,stride(B,2)))\n            B\n        end\n        function trsm(side::AbstractChar, uplo::AbstractChar, transa::AbstractChar, diag::AbstractChar, alpha::$elty, A::AbstractMatrix{$elty}, B::AbstractMatrix{$elty})\n            trsm!(side, uplo, transa, diag, alpha, A, copy(B))\n        end\n    end\nend\n\nend # module\n\nfunction copyto!(dest::Array{T}, rdest::Union{UnitRange{Ti},AbstractRange{Ti}},\n                 src::Array{T}, rsrc::Union{UnitRange{Ti},AbstractRange{Ti}}) where {T<:BlasFloat,Ti<:Integer}\n    if minimum(rdest) < 1 || maximum(rdest) > length(dest)\n        throw(ArgumentError(\"range out of bounds for dest, of length $(length(dest))\"))\n    end\n    if minimum(rsrc) < 1 || maximum(rsrc) > length(src)\n        throw(ArgumentError(\"range out of bounds for src, of length $(length(src))\"))\n    end\n    if length(rdest) != length(rsrc)\n        throw(DimensionMismatch(\"ranges must be of the same length\"))\n    end\n    GC.@preserve src dest BLAS.blascopy!(length(rsrc),\n                                              pointer(src) + (first(rsrc) - 1) * sizeof(T),\n                                              step(rsrc),\n                                              pointer(dest) + (first(rdest) - 1) * sizeof(T),\n                                              step(rdest))\n    dest\nend\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/stdlib/Libdl/src/Libdl.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nmodule Libdl\n@doc \"\"\"\nInterface to libdl. Provides dynamic linking support.\n\"\"\" Libdl\n\nimport Base.DL_LOAD_PATH\n\nexport DL_LOAD_PATH, RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL,\n    RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW, dlclose, dlopen, dlopen_e, dlsym, dlsym_e,\n    dlpath, find_library, dlext, dllist\n\n\"\"\"\n    DL_LOAD_PATH\n\nWhen calling [`dlopen`](@ref), the paths in this list will be searched first, in\norder, before searching the system locations for a valid library handle.\n\"\"\"\nDL_LOAD_PATH\n\n# note: constants to match JL_RTLD_* in src/julia.h, translated\n#       to system-specific values by JL_RTLD macro in src/dlload.c\nconst RTLD_LOCAL     = 0x00000001\nconst RTLD_GLOBAL    = 0x00000002\nconst RTLD_LAZY      = 0x00000004\nconst RTLD_NOW       = 0x00000008\nconst RTLD_NODELETE  = 0x00000010\nconst RTLD_NOLOAD    = 0x00000020\nconst RTLD_DEEPBIND  = 0x00000040\nconst RTLD_FIRST     = 0x00000080\n\n\"\"\"\n    RTLD_DEEPBIND\n    RTLD_FIRST\n    RTLD_GLOBAL\n    RTLD_LAZY\n    RTLD_LOCAL\n    RTLD_NODELETE\n    RTLD_NOLOAD\n    RTLD_NOW\n\nEnum constant for [`dlopen`](@ref). See your platform man page for details, if\napplicable.\n\"\"\"\n(RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL, RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW)\n\n\"\"\"\n    dlsym(handle, sym)\n\nLook up a symbol from a shared library handle, return callable function pointer on success.\n\"\"\"\nfunction dlsym(hnd::Ptr, s::Union{Symbol,AbstractString})\n    hnd == C_NULL && throw(ArgumentError(\"NULL library handle\"))\n    ccall(:jl_dlsym, Ptr{Cvoid}, (Ptr{Cvoid}, Cstring), hnd, s)\nend\n\n\"\"\"\n    dlsym_e(handle, sym)\n\nLook up a symbol from a shared library handle, silently return `NULL` pointer on lookup failure.\n\"\"\"\nfunction dlsym_e(hnd::Ptr, s::Union{Symbol,AbstractString})\n    hnd == C_NULL && throw(ArgumentError(\"NULL library handle\"))\n    ccall(:jl_dlsym_e, Ptr{Cvoid}, (Ptr{Cvoid}, Cstring), hnd, s)\nend\n\n\"\"\"\n    dlopen(libfile::AbstractString [, flags::Integer])\n\nLoad a shared library, returning an opaque handle.\n\nThe extension given by the constant `dlext` (`.so`, `.dll`, or `.dylib`)\ncan be omitted from the `libfile` string, as it is automatically appended\nif needed.   If `libfile` is not an absolute path name, then the paths\nin the array `DL_LOAD_PATH` are searched for `libfile`, followed by the\nsystem load path.\n\nThe optional flags argument is a bitwise-or of zero or more of `RTLD_LOCAL`, `RTLD_GLOBAL`,\n`RTLD_LAZY`, `RTLD_NOW`, `RTLD_NODELETE`, `RTLD_NOLOAD`, `RTLD_DEEPBIND`, and `RTLD_FIRST`.\nThese are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS)\ndlopen command, if possible, or are ignored if the specified functionality is not available\non the current platform. The default flags are platform specific. On MacOS the default\n`dlopen` flags are `RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL` while on other platforms the\ndefaults are `RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL`. An important usage of these flags is to\nspecify non default behavior for when the dynamic library loader binds library references to\nexported symbols and if the bound references are put into process local or global scope. For\ninstance `RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL` allows the library's symbols to be available\nfor usage in other shared libraries, addressing situations where there are dependencies\nbetween shared libraries.\n\"\"\"\nfunction dlopen end\n\ndlopen(s::Symbol, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND) =\n    dlopen(string(s), flags)\n\ndlopen(s::AbstractString, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND) =\n    ccall(:jl_load_dynamic_library, Ptr{Cvoid}, (Cstring,UInt32), s, flags)\n\n\"\"\"\n    dlopen_e(libfile::AbstractString [, flags::Integer])\n\nSimilar to [`dlopen`](@ref), except returns a `NULL` pointer instead of raising errors.\n\"\"\"\nfunction dlopen_e end\n\ndlopen_e(s::Symbol, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND) =\n    dlopen_e(string(s), flags)\n\ndlopen_e(s::AbstractString, flags::Integer = RTLD_LAZY | RTLD_DEEPBIND) =\n    ccall(:jl_load_dynamic_library_e, Ptr{Cvoid}, (Cstring,UInt32), s, flags)\n\n\"\"\"\n    dlclose(handle)\n\nClose shared library referenced by handle.\n\"\"\"\nfunction dlclose(p::Ptr)\n    0 == ccall(:jl_dlclose, Cint, (Ptr{Cvoid},), p)\nend\n\n\"\"\"\n    find_library(names, locations)\n\nSearches for the first library in `names` in the paths in the `locations` list,\n`DL_LOAD_PATH`, or system library paths (in that order) which can successfully be dlopen'd.\nOn success, the return value will be one of the names (potentially prefixed by one of the\npaths in locations). This string can be assigned to a `global const` and used as the library\nname in future `ccall`'s. On failure, it returns the empty string.\n\"\"\"\nfunction find_library(libnames, extrapaths=String[])\n    for lib in libnames\n        for path in extrapaths\n            l = joinpath(path, lib)\n            p = dlopen_e(l, RTLD_LAZY)\n            if p != C_NULL\n                dlclose(p)\n                return l\n            end\n        end\n        p = dlopen_e(lib, RTLD_LAZY)\n        if p != C_NULL\n            dlclose(p)\n            return lib\n        end\n    end\n    return \"\"\nend\nfind_library(libname::Union{Symbol,AbstractString}, extrapaths=String[]) =\n    find_library([string(libname)], extrapaths)\n\nfunction dlpath(handle::Ptr{Cvoid})\n    p = ccall(:jl_pathname_for_handle, Cstring, (Ptr{Cvoid},), handle)\n    s = unsafe_string(p)\n    Sys.iswindows() && Libc.free(p)\n    return s\nend\n\nfunction dlpath(libname::Union{AbstractString, Symbol})\n    handle = dlopen(libname)\n    path = dlpath(handle)\n    dlclose(handle)\n    return path\nend\n\nif Sys.isapple()\n    const dlext = \"dylib\"\nelseif Sys.iswindows()\n    const dlext = \"dll\"\nelse\n    #assume Sys.islinux, or similar\n    const dlext = \"so\"\nend\n\n\"\"\"\n    dlext\n\nFile extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.\n\"\"\"\ndlext\n\nif Sys.islinux()\n    struct dl_phdr_info\n        # Base address of object\n        addr::Cuint\n\n        # Null-terminated name of object\n        name::Ptr{UInt8}\n\n        # Pointer to array of ELF program headers for this object\n        phdr::Ptr{Cvoid}\n\n        # Number of program headers for this object\n        phnum::Cshort\n    end\n\n    # This callback function called by dl_iterate_phdr() on Linux\n    function dl_phdr_info_callback(di::dl_phdr_info, size::Csize_t, dynamic_libraries::Array{AbstractString,1})\n        # Skip over objects without a path (as they represent this own object)\n        name = unsafe_string(di.name)\n        if !isempty(name)\n            push!(dynamic_libraries, name)\n        end\n        return convert(Cint, 0)::Cint\n    end\nend # linux-only\n\nif Sys.isbsd() && !Sys.isapple()\n    # DL_ITERATE_PHDR(3) on freebsd\n    struct dl_phdr_info\n        # Base address of object\n        addr::Cuint\n\n        # Null-terminated name of object\n        name::Ptr{UInt8}\n\n        # Pointer to array of ELF program headers for this object\n        phdr::Ptr{Cvoid}\n\n        # Number of program headers for this object\n        phnum::Cshort\n    end\n\n    function dl_phdr_info_callback(di::dl_phdr_info, size::Csize_t, dy_libs::Vector{AbstractString})\n        name = unsafe_string(di.name)\n        if !isempty(name)\n            push!(dy_libs, name)\n        end\n        return convert(Cint, 0)::Cint\n    end\nend # bsd family\n\nfunction dllist()\n    dynamic_libraries = Vector{AbstractString}()\n\n    @static if Sys.islinux()\n        callback = @cfunction(dl_phdr_info_callback, Cint,\n                              (Ref{dl_phdr_info}, Csize_t, Ref{Vector{AbstractString}}))\n        ccall(:dl_iterate_phdr, Cint, (Ptr{Cvoid}, Ref{Vector{AbstractString}}), callback, dynamic_libraries)\n    end\n\n    @static if Sys.isapple()\n        numImages = ccall(:_dyld_image_count, Cint, ())\n\n        # start at 1 instead of 0 to skip self\n        for i in 1:numImages-1\n            name = unsafe_string(ccall(:_dyld_get_image_name, Cstring, (UInt32,), i))\n            push!(dynamic_libraries, name)\n        end\n    end\n\n    @static if Sys.iswindows()\n        ccall(:jl_dllist, Cint, (Any,), dynamic_libraries)\n    end\n\n    @static if Sys.isbsd() && !Sys.isapple()\n        callback = @cfunction(dl_phdr_info_callback, Cint,\n                              (Ref{dl_phdr_info}, Csize_t, Ref{Vector{AbstractString}}))\n        ccall(:dl_iterate_phdr, Cint, (Ptr{Cvoid}, Ref{Vector{AbstractString}}), callback, dynamic_libraries)\n        popfirst!(dynamic_libraries)\n    end\n\n    return dynamic_libraries\nend\n\nend # module\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/stdlib/Libdl/test/runtests.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nusing Test\nimport Libdl\n\n# these could fail on an embedded installation\n# but for now, we don't handle that case\ndlls = Libdl.dllist()\n@test !isempty(dlls)\n@test length(dlls) > 3 # at a bare minimum, probably have some version of libstdc, libgcc, libjulia, ...\nif !Sys.iswindows() || Sys.windows_version() >= Sys.WINDOWS_VISTA_VER\n    for dl in dlls\n        if isfile(dl) && (Libdl.dlopen_e(dl) != C_NULL)\n            @test Base.samefile(Libdl.dlpath(dl), dl)\n        end\n    end\nend\n@test length(filter(dlls) do dl\n        return occursin(Regex(\"^libjulia(?:.*)\\\\.$(Libdl.dlext)(?:\\\\..+)?\\$\"), basename(dl))\n    end) == 1 # look for something libjulia-like (but only one)\n\n# library handle pointer must not be NULL\n@test_throws ArgumentError Libdl.dlsym(C_NULL, :foo)\n@test_throws ArgumentError Libdl.dlsym_e(C_NULL, :foo)\n\ncd(dirname(@__FILE__)) do\n\n# Find the library directory by finding the path of libjulia (or libjulia-debug, as the case may be)\n# and then adding on /julia to that directory path to get the private library directory, if we need\n# to (where \"need to\" is defined as private_libdir/julia/libccalltest.dlext exists\nprivate_libdir = if ccall(:jl_is_debugbuild, Cint, ()) != 0\n    dirname(abspath(Libdl.dlpath(\"libjulia-debug\")))\nelse\n    dirname(abspath(Libdl.dlpath(\"libjulia\")))\nend\n\nif isfile(joinpath(private_libdir,\"julia\",\"libccalltest.\"*Libdl.dlext))\n    private_libdir = joinpath(private_libdir, \"julia\")\nend\n\n@test !isempty(Libdl.find_library([\"libccalltest\"], [private_libdir]))\n@test !isempty(Libdl.find_library(\"libccalltest\", [private_libdir]))\n@test !isempty(Libdl.find_library(:libccalltest, [private_libdir]))\n\n# dlopen should be able to handle absolute and relative paths, with and without dlext\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(abspath(joinpath(private_libdir, \"libccalltest\")))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(abspath(joinpath(private_libdir, \"libccalltest.$(Libdl.dlext)\")))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(relpath(joinpath(private_libdir, \"libccalltest\")))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(relpath(joinpath(private_libdir, \"libccalltest.$(Libdl.dlext)\")))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(\"./foo\")\n        @test dl == C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# unqualified names present in DL_LOAD_PATH\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(\"libccalltest\")\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen_e(string(\"libccalltest\",\".\",Libdl.dlext))\n        @test dl != C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# path with dlopen-able file first in load path\n#=\nlet dl = C_NULL,\n    tmpdir = mktempdir(),\n    fpath = joinpath(tmpdir,\"libccalltest\")\n    try\n        write(open(fpath,\"w\"))\n        push!(Libdl.DL_LOAD_PATH, dirname(@__FILE__))\n        push!(Libdl.DL_LOAD_PATH, dirname(fpath))\n        dl = Libdl.dlopen_e(\"libccalltest\")\n        @test dl != C_NULL\n    finally\n        pop!(Libdl.DL_LOAD_PATH)\n        pop!(Libdl.DL_LOAD_PATH)\n        rm(tmpdir, recursive=true)\n    end\nend\n=#\n\n# path with dlopen-able file second in load path\n#=\nlet dl = C_NULL,\n    tmpdir = mktempdir(),\n    fpath = joinpath(tmpdir,\"libccalltest\")\n    try\n        write(open(fpath,\"w\"))\n        push!(Libdl.DL_LOAD_PATH, dirname(fpath))\n        push!(Libdl.DL_LOAD_PATH, dirname(@__FILE__))\n        dl = Libdl.dlopen_e(\"libccalltest\")\n        @test dl != C_NULL\n    finally\n        pop!(Libdl.DL_LOAD_PATH)\n        pop!(Libdl.DL_LOAD_PATH)\n        rm(tmpdir, recursive=true)\n    end\nend\n=#\n\n# test dlpath\nlet dl = C_NULL\n    try\n        path = abspath(joinpath(private_libdir, \"libccalltest\"))\n        dl = Libdl.dlopen(path)\n        @test dl != C_NULL\n        @test Base.samefile(abspath(Libdl.dlpath(dl)),\n                            abspath(Libdl.dlpath(path)))\n        @test Base.samefile(abspath(Libdl.dlpath(dl)),\n                            string(path,\".\",Libdl.dlext))\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# opening a library that does not exist throws an ErrorException\n@test_throws ErrorException Libdl.dlopen(\"./foo\")\n\n# opening a versioned library that does not exist does not result in adding extension twice\nerr = @test_throws ErrorException Libdl.dlopen(\"./foo.$(Libdl.dlext).0\")\n@test !occursin(\"foo.$(Libdl.dlext).0.$(Libdl.dlext)\", err.value.msg)\nerr = @test_throws ErrorException Libdl.dlopen(\"./foo.$(Libdl.dlext).0.22.1\")\n@test !occursin(\"foo.$(Libdl.dlext).0.22.1.$(Libdl.dlext)\", err.value.msg)\n\n# test dlsym\nlet dl = C_NULL\n    try\n        dl = Libdl.dlopen(abspath(joinpath(private_libdir, \"libccalltest\")))\n        fptr = Libdl.dlsym(dl, :set_verbose)\n        @test fptr != C_NULL\n        @test_throws ErrorException Libdl.dlsym(dl, :foo)\n\n        fptr = Libdl.dlsym_e(dl, :set_verbose)\n        @test fptr != C_NULL\n        fptr = Libdl.dlsym_e(dl, :foo)\n        @test fptr == C_NULL\n    finally\n        Libdl.dlclose(dl)\n    end\nend\n\n# test dlclose\n# If dl is NULL, jl_dlclose should return -1 and dlclose should return false\n# dlclose should return true on success and false on failure\nlet dl = C_NULL\n    @test -1 == ccall(:jl_dlclose, Cint, (Ptr{Cvoid},), dl)\n    @test !Libdl.dlclose(dl)\n\n    dl = Libdl.dlopen_e(\"libccalltest\")\n    @test dl != C_NULL\n\n    @test Libdl.dlclose(dl)\n    @test_skip !Libdl.dlclose(dl)   # Syscall doesn't fail on Win32\nend\n\nend\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/stdlib/Libdl/docs/src/index.md": "# Dynamic Linker\n\n```@docs\nLibdl.dlopen\nLibdl.dlopen_e\nLibdl.RTLD_NOW\nLibdl.dlsym\nLibdl.dlsym_e\nLibdl.dlclose\nLibdl.dlext\nLibdl.find_library\nLibdl.DL_LOAD_PATH\n```\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/stdlib/SuiteSparse/src/cholmod.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nmodule CHOLMOD\n\nimport Base: (*), convert, copy, eltype, getindex, getproperty, show, size,\n             IndexStyle, IndexLinear, IndexCartesian, adjoint, axes\nusing Base: has_offset_axes\n\nusing LinearAlgebra\nimport LinearAlgebra: (\\),\n                 cholesky, cholesky!, det, diag, ishermitian, isposdef,\n                 issuccess, issymmetric, ldlt, ldlt!, logdet\n\nusing SparseArrays\nimport Libdl\n\nexport\n    Dense,\n    Factor,\n    Sparse\n\nimport SparseArrays: AbstractSparseMatrix, SparseMatrixCSC, indtype, sparse, spzeros, nnz\n\nimport ..increment, ..increment!, ..decrement, ..decrement!\n\n#########\n# Setup #\n#########\n\ninclude(\"cholmod_h.jl\")\n\nconst CHOLMOD_MIN_VERSION = v\"2.1.1\"\n\nconst common_struct = Vector{UInt8}()\n\nconst common_supernodal = Ref{Ptr{Cint}}()\nconst common_final_ll = Ref{Ptr{Cint}}()\nconst common_print = Ref{Ptr{Cint}}()\nconst common_itype = Ref{Ptr{Cint}}()\nconst common_dtype = Ref{Ptr{Cint}}()\nconst common_nmethods = Ref{Ptr{Cint}}()\nconst common_postorder = Ref{Ptr{Cint}}()\n\n### These offsets are defined in SuiteSparse_wrapper.c\nconst common_size = ccall((:jl_cholmod_common_size,:libsuitesparse_wrapper),Int,())\n\nconst cholmod_com_offsets = Vector{Csize_t}(undef, 19)\nccall((:jl_cholmod_common_offsets, :libsuitesparse_wrapper),\n    Nothing, (Ptr{Csize_t},), cholmod_com_offsets)\n\n## macro to generate the name of the C function according to the integer type\nmacro cholmod_name(nm, typ)\n    string(\"cholmod_\", eval(typ) == SuiteSparse_long ? \"l_\" : \"\", nm)\nend\n\nfunction start(a::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"start\", SuiteSparse_long), :libcholmod),\n        Cint, (Ptr{UInt8},), a)\n    return a\nend\n\nfunction finish(a::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"finish\", SuiteSparse_long), :libcholmod),\n        Cint, (Ptr{UInt8},), a)\n    return a\nend\n\nfunction defaults(a::Vector{UInt8})\n    @isok ccall((@cholmod_name(\"defaults\", SuiteSparse_long), :libcholmod),\n        Cint, (Ptr{UInt8},), a)\n    return a\nend\n\nconst build_version_array = Vector{Cint}(undef, 3)\nccall((:jl_cholmod_version, :libsuitesparse_wrapper), Cint, (Ptr{Cint},), build_version_array)\nconst build_version = VersionNumber(build_version_array...)\n\nfunction __init__()\n    try\n        ### Check if the linked library is compatible with the Julia code\n        if Libdl.dlsym_e(Libdl.dlopen(\"libcholmod\"), :cholmod_version) != C_NULL\n            current_version_array = Vector{Cint}(undef, 3)\n            ccall((:cholmod_version, :libcholmod), Cint, (Ptr{Cint},), current_version_array)\n            current_version = VersionNumber(current_version_array...)\n        else # CHOLMOD < 2.1.1 does not include cholmod_version()\n            current_version = v\"0.0.0\"\n        end\n\n\n        if current_version < CHOLMOD_MIN_VERSION\n            @warn \"\"\"\n                CHOLMOD version incompatibility\n\n                Julia was compiled with CHOLMOD version $build_version. It is\n                currently linked with a version older than\n                $(CHOLMOD_MIN_VERSION). This might cause Julia to\n                terminate when working with sparse matrix factorizations,\n                e.g. solving systems of equations with \\\\.\n\n                It is recommended that you use Julia with a recent version\n                of CHOLMOD, or download the generic binaries\n                from www.julialang.org, which ship with the correct\n                versions of all dependencies.\n                \"\"\"\n        elseif build_version_array[1] != current_version_array[1]\n            @warn \"\"\"\n                CHOLMOD version incompatibility\n\n                Julia was compiled with CHOLMOD version $build_version. It is\n                currently linked with version $current_version.\n                This might cause Julia to terminate when working with\n                sparse matrix factorizations, e.g. solving systems of\n                equations with \\\\.\n\n                It is recommended that you use Julia with the same major\n                version of CHOLMOD as the one used during the build, or\n                download the generic binaries from www.julialang.org,\n                which ship with the correct versions of all dependencies.\n                \"\"\"\n        end\n\n        intsize = Int(ccall((:jl_cholmod_sizeof_long,:libsuitesparse_wrapper),Csize_t,()))\n        if intsize != 4length(IndexTypes)\n            @error \"\"\"\n                 CHOLMOD integer size incompatibility\n\n                 Julia was compiled with a version of CHOLMOD that\n                 supported $(32length(IndexTypes)) bit integers. It is\n                 currently linked with version that supports $(8intsize)\n                 integers. This might cause Julia to terminate when\n                 working with sparse matrix factorizations, e.g. solving\n                 systems of equations with \\\\.\n\n                 This problem can be fixed by modifying the Julia build\n                 configuration or by downloading the OS X or generic\n                 Linux binary from www.julialang.org, which include\n                 the correct versions of all dependencies.\n                 \"\"\"\n        end\n\n        ### Initiate CHOLMOD\n        ### common_struct controls the type of factorization and keeps pointers\n        ### to temporary memory.\n        resize!(common_struct, common_size)\n        fill!(common_struct, 0xff)\n\n        common_supernodal[] = pointer(common_struct, cholmod_com_offsets[4] + 1)\n        common_final_ll[] = pointer(common_struct, cholmod_com_offsets[7] + 1)\n        common_print[] = pointer(common_struct, cholmod_com_offsets[13] + 1)\n        common_itype[] = pointer(common_struct, cholmod_com_offsets[18] + 1)\n        common_dtype[] = pointer(common_struct, cholmod_com_offsets[19] + 1)\n        common_nmethods[] = pointer(common_struct, cholmod_com_offsets[15] + 1)\n        common_postorder[] = pointer(common_struct, cholmod_com_offsets[17] + 1)\n\n        start(common_struct)              # initializes CHOLMOD\n        set_print_level(common_struct, 0) # no printing from CHOLMOD by default\n\n        # Register gc tracked allocator if CHOLMOD is new enough\n        if current_version >= v\"3.0.0\"\n            cnfg = cglobal((:SuiteSparse_config, :libsuitesparseconfig), Ptr{Cvoid})\n            unsafe_store!(cnfg, cglobal(:jl_malloc, Ptr{Cvoid}), 1)\n            unsafe_store!(cnfg, cglobal(:jl_calloc, Ptr{Cvoid}), 2)\n            unsafe_store!(cnfg, cglobal(:jl_realloc, Ptr{Cvoid}), 3)\n            unsafe_store!(cnfg, cglobal(:jl_free, Ptr{Cvoid}), 4)\n        end\n\n    catch ex\n        @error \"Error during initialization of module CHOLMOD\" exception=ex,catch_backtrace()\n    end\nend\n\nfunction set_print_level(cm::Vector{UInt8}, lev::Integer)\n    unsafe_store!(common_print[], lev)\nend\n\n####################\n# Type definitions #\n####################\n\nabstract type SuiteSparseStruct end\n\n# The three core data types for CHOLMOD: Dense, Sparse and Factor.\n# CHOLMOD manages the memory, so the Julia versions only wrap a\n# pointer to a struct.  Therefore finalizers should be registered each\n# time a pointer is returned from CHOLMOD.\n\n# Dense\nstruct C_Dense{T<:VTypes} <: SuiteSparseStruct\n    nrow::Csize_t\n    ncol::Csize_t\n    nzmax::Csize_t\n    d::Csize_t\n    x::Ptr{T}\n    z::Ptr{Cvoid}\n    xtype::Cint\n    dtype::Cint\nend\n\nmutable struct Dense{T<:VTypes} <: DenseMatrix{T}\n    ptr::Ptr{C_Dense{T}}\n    function Dense{Tv}(ptr::Ptr{C_Dense{Tv}}) where Tv<:VTypes\n        if ptr == C_NULL\n            throw(ArgumentError(\"dense matrix construction failed for \" *\n                \"unknown reasons. Please submit a bug report.\"))\n        end\n        A = new(ptr)\n        finalizer(free!, A)\n        return A\n    end\nend\nDense(p::Ptr{C_Dense{Tv}}) where {Tv<:VTypes} = Dense{Tv}(p)\n\n# Sparse\nstruct C_Sparse{Tv<:VTypes} <: SuiteSparseStruct\n    nrow::Csize_t\n    ncol::Csize_t\n    nzmax::Csize_t\n    p::Ptr{SuiteSparse_long}\n    i::Ptr{SuiteSparse_long}\n    nz::Ptr{SuiteSparse_long}\n    x::Ptr{Tv}\n    z::Ptr{Cvoid}\n    stype::Cint\n    itype::Cint\n    xtype::Cint\n    dtype::Cint\n    sorted::Cint\n    packed::Cint\nend\n\n# Corresponds to the exact definition of cholmod_sparse_struct in the library.\n# Useful when reading matrices of unknown type from files as in\n# cholmod_read_sparse\nstruct C_SparseVoid <: SuiteSparseStruct\n    nrow::Csize_t\n    ncol::Csize_t\n    nzmax::Csize_t\n    p::Ptr{Cvoid}\n    i::Ptr{Cvoid}\n    nz::Ptr{Cvoid}\n    x::Ptr{Cvoid}\n    z::Ptr{Cvoid}\n    stype::Cint\n    itype::Cint\n    xtype::Cint\n    dtype::Cint\n    sorted::Cint\n    packed::Cint\nend\n\nmutable struct Sparse{Tv<:VTypes} <: AbstractSparseMatrix{Tv,SuiteSparse_long}\n    ptr::Ptr{C_Sparse{Tv}}\n    function Sparse{Tv}(ptr::Ptr{C_Sparse{Tv}}) where Tv<:VTypes\n        if ptr == C_NULL\n            throw(ArgumentError(\"sparse matrix construction failed for \" *\n                \"unknown reasons. Please submit a bug report.\"))\n        end\n        A = new(ptr)\n        finalizer(free!, A)\n        return A\n    end\nend\nSparse(p::Ptr{C_Sparse{Tv}}) where {Tv<:VTypes} = Sparse{Tv}(p)\n\nBase.unsafe_convert(::Type{Ptr{Tv}}, A::Sparse{Tv}) where {Tv} = getfield(A, :ptr)\n\n# Factor\n\nif build_version >= v\"2.1.0\" # CHOLMOD version 2.1.0 or later\n    struct C_Factor{Tv<:VTypes} <: SuiteSparseStruct\n        n::Csize_t\n        minor::Csize_t\n        Perm::Ptr{SuiteSparse_long}\n        ColCount::Ptr{SuiteSparse_long}\n        IPerm::Ptr{SuiteSparse_long}        # this pointer was added in version 2.1.0\n        nzmax::Csize_t\n        p::Ptr{SuiteSparse_long}\n        i::Ptr{SuiteSparse_long}\n        x::Ptr{Tv}\n        z::Ptr{Cvoid}\n        nz::Ptr{SuiteSparse_long}\n        next::Ptr{SuiteSparse_long}\n        prev::Ptr{SuiteSparse_long}\n        nsuper::Csize_t\n        ssize::Csize_t\n        xsize::Csize_t\n        maxcsize::Csize_t\n        maxesize::Csize_t\n        super::Ptr{SuiteSparse_long}\n        pi::Ptr{SuiteSparse_long}\n        px::Ptr{SuiteSparse_long}\n        s::Ptr{SuiteSparse_long}\n        ordering::Cint\n        is_ll::Cint\n        is_super::Cint\n        is_monotonic::Cint\n        itype::Cint\n        xtype::Cint\n        dtype::Cint\n    end\nelse\n    struct C_Factor{Tv<:VTypes} <: SuiteSparseStruct\n        n::Csize_t\n        minor::Csize_t\n        Perm::Ptr{SuiteSparse_long}\n        ColCount::Ptr{SuiteSparse_long}\n        nzmax::Csize_t\n        p::Ptr{SuiteSparse_long}\n        i::Ptr{SuiteSparse_long}\n        x::Ptr{Tv}\n        z::Ptr{Cvoid}\n        nz::Ptr{SuiteSparse_long}\n        next::Ptr{SuiteSparse_long}\n        prev::Ptr{SuiteSparse_long}\n        nsuper::Csize_t\n        ssize::Csize_t\n        xsize::Csize_t\n        maxcsize::Csize_t\n        maxesize::Csize_t\n        super::Ptr{SuiteSparse_long}\n        pi::Ptr{SuiteSparse_long}\n        px::Ptr{SuiteSparse_long}\n        s::Ptr{SuiteSparse_long}\n        ordering::Cint\n        is_ll::Cint\n        is_super::Cint\n        is_monotonic::Cint\n        itype::Cint\n        xtype::Cint\n        dtype::Cint\n    end\nend\n\nmutable struct Factor{Tv} <: Factorization{Tv}\n    ptr::Ptr{C_Factor{Tv}}\n    function Factor{Tv}(ptr::Ptr{C_Factor{Tv}}, register_finalizer = true) where Tv\n        if ptr == C_NULL\n            throw(ArgumentError(\"factorization construction failed for \" *\n                \"unknown reasons. Please submit a bug report.\"))\n        end\n        F = new(ptr)\n        if register_finalizer\n            finalizer(free!, F)\n        end\n        return F\n    end\nend\nFactor(ptr::Ptr{C_Factor{Tv}}) where {Tv<:VTypes} = Factor{Tv}(ptr)\nFactor(x::Factor) = x\n\nBase.adjoint(F::Factor) = Adjoint(F)\nBase.transpose(F::Factor) = Transpose(F)\n\n# All pointer loads should be checked to make sure that SuiteSparse is not called with\n# a C_NULL pointer which could cause a segfault. Pointers are set to null\n# when serialized so this can happen when multiple processes are in use.\nfunction Base.unsafe_convert(::Type{Ptr{T}}, x::Union{Dense,Sparse,Factor}) where T<:SuiteSparseStruct\n    xp = getfield(x, :ptr)\n    if xp == C_NULL\n        throw(ArgumentError(\"pointer to the $T object is null. This can \" *\n            \"happen if the object has been serialized.\"))\n    else\n        return xp\n    end\nend\nBase.pointer(x::Dense{Tv}) where {Tv}  = Base.unsafe_convert(Ptr{C_Dense{Tv}}, x)\nBase.pointer(x::Sparse{Tv}) where {Tv} = Base.unsafe_convert(Ptr{C_Sparse{Tv}}, x)\nBase.pointer(x::Factor{Tv}) where {Tv} = Base.unsafe_convert(Ptr{C_Factor{Tv}}, x)\n\n# FactorComponent, for encoding particular factors from a factorization\nmutable struct FactorComponent{Tv,S} <: AbstractMatrix{Tv}\n    F::Factor{Tv}\n\n    function FactorComponent{Tv,S}(F::Factor{Tv}) where {Tv,S}\n        s = unsafe_load(pointer(F))\n        if s.is_ll != 0\n            if !(S == :L || S == :U || S == :PtL || S == :UP)\n                throw(CHOLMODException(string(S, \" not supported for sparse \",\n                    \"LLt matrices; try :L, :U, :PtL, or :UP\")))\n            end\n        elseif !(S == :L || S == :U || S == :PtL || S == :UP ||\n                S == :D || S == :LD || S == :DU || S == :PtLD || S == :DUP)\n            throw(CHOLMODException(string(S, \" not supported for sparse LDLt \",\n                \"matrices; try :L, :U, :PtL, :UP, :D, :LD, :DU, :PtLD, or :DUP\")))\n        end\n        new(F)\n    end\nend\nfunction FactorComponent(F::Factor{Tv}, sym::Symbol) where Tv\n    FactorComponent{Tv,sym}(F)\nend\n\nFactor(FC::FactorComponent) = Factor(FC.F)\n\n#################\n# Thin wrappers #\n#################\n\n# Dense wrappers\n## Note! Integer type defaults to Cint, but this is actually not necessary, but\n## making this a choice would require another type parameter in the Dense type\n\n### cholmod_core_h ###\nfunction allocate_dense(nrow::Integer, ncol::Integer, d::Integer, ::Type{Float64})\n    Dense(ccall((:cholmod_l_allocate_dense, :libcholmod), Ptr{C_Dense{Float64}},\n        (Csize_t, Csize_t, Csize_t, Cint, Ptr{Cvoid}),\n        nrow, ncol, d, REAL, common_struct))\nend\nfunction allocate_dense(nrow::Integer, ncol::Integer, d::Integer, ::Type{Complex{Float64}})\n    Dense(ccall((:cholmod_l_allocate_dense, :libcholmod), Ptr{C_Dense{Complex{Float64}}},\n        (Csize_t, Csize_t, Csize_t, Cint, Ptr{Cvoid}),\n        nrow, ncol, d, COMPLEX, common_struct))\nend\n\nfree_dense!(p::Ptr{C_Dense{T}}) where {T} = ccall((:cholmod_l_free_dense, :libcholmod),\n    Cint, (Ref{Ptr{C_Dense{T}}}, Ptr{Cvoid}), p, common_struct)\n\nfunction zeros(m::Integer, n::Integer, ::Type{T}) where T<:VTypes\n    Dense(ccall((:cholmod_l_zeros, :libcholmod), Ptr{C_Dense{T}},\n        (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n         m, n, xtyp(T), common_struct))\nend\nzeros(m::Integer, n::Integer) = zeros(m, n, Float64)\n\nfunction ones(m::Integer, n::Integer, ::Type{T}) where T<:VTypes\n    Dense(ccall((:cholmod_l_ones, :libcholmod), Ptr{C_Dense{T}},\n        (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n         m, n, xtyp(T), common_struct))\nend\nones(m::Integer, n::Integer) = ones(m, n, Float64)\n\nfunction eye(m::Integer, n::Integer, ::Type{T}) where T<:VTypes\n    Dense(ccall((:cholmod_l_eye, :libcholmod), Ptr{C_Dense{T}},\n        (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n         m, n, xtyp(T), common_struct))\nend\neye(m::Integer, n::Integer) = eye(m, n, Float64)\neye(n::Integer) = eye(n, n, Float64)\n\nfunction copy_dense(A::Dense{Tv}) where Tv<:VTypes\n    Dense(ccall((:cholmod_l_copy_dense, :libcholmod), Ptr{C_Dense{Tv}},\n        (Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n         A, common_struct))\nend\n\nfunction sort!(S::Sparse{Tv}) where Tv<:VTypes\n    @isok ccall((:cholmod_l_sort, :libcholmod), SuiteSparse_long,\n        (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n         S, common_struct)\n    return S\nend\n\n### cholmod_matrixops.h ###\nfunction norm_dense(D::Dense{Tv}, p::Integer) where Tv<:VTypes\n    s = unsafe_load(pointer(D))\n    if p == 2\n        if s.ncol > 1\n            throw(ArgumentError(\"2 norm only supported when matrix has one column\"))\n        end\n    elseif p != 0 && p != 1\n        throw(ArgumentError(\"second argument must be either 0 (Inf norm), 1, or 2\"))\n    end\n    ccall((:cholmod_l_norm_dense, :libcholmod), Cdouble,\n        (Ptr{C_Dense{Tv}}, Cint, Ptr{UInt8}),\n          D, p, common_struct)\nend\n\n### cholmod_check.h ###\nfunction check_dense(A::Dense{T}) where T<:VTypes\n    ccall((:cholmod_l_check_dense, :libcholmod), Cint,\n          (Ptr{C_Dense{T}}, Ptr{UInt8}),\n          pointer(A), common_struct) != 0\nend\n\n# Non-Dense wrappers\n### cholmod_core.h ###\nfunction allocate_sparse(nrow::Integer, ncol::Integer, nzmax::Integer,\n        sorted::Bool, packed::Bool, stype::Integer, ::Type{Float64})\n    Sparse(ccall((@cholmod_name(\"allocate_sparse\", SuiteSparse_long), :libcholmod),\n            Ptr{C_Sparse{Float64}},\n                (Csize_t, Csize_t, Csize_t, Cint,\n                 Cint, Cint, Cint, Ptr{Cvoid}),\n                nrow, ncol, nzmax, sorted,\n                packed, stype, REAL, common_struct))\nend\nfunction allocate_sparse(nrow::Integer, ncol::Integer, nzmax::Integer,\n        sorted::Bool, packed::Bool, stype::Integer, ::Type{Complex{Float64}})\n    Sparse(ccall((@cholmod_name(\"allocate_sparse\", SuiteSparse_long), :libcholmod),\n            Ptr{C_Sparse{Complex{Float64}}},\n                (Csize_t, Csize_t, Csize_t, Cint,\n                 Cint, Cint, Cint, Ptr{Cvoid}),\n                nrow, ncol, nzmax, sorted,\n                packed, stype, COMPLEX, common_struct))\nend\nfunction free_sparse!(ptr::Ptr{C_Sparse{Tv}}) where Tv<:VTypes\n    @isok ccall((@cholmod_name(\"free_sparse\", SuiteSparse_long), :libcholmod), Cint,\n            (Ref{Ptr{C_Sparse{Tv}}}, Ptr{UInt8}),\n                ptr, common_struct)\nend\n\nfunction free_sparse!(ptr::Ptr{C_SparseVoid})\n    @isok ccall((@cholmod_name(\"free_sparse\", SuiteSparse_long), :libcholmod), Cint,\n            (Ref{Ptr{C_SparseVoid}}, Ptr{UInt8}),\n                ptr, common_struct)\nend\n\nfunction free_factor!(ptr::Ptr{C_Factor{Tv}}) where Tv<:VTypes\n    # Warning! Important that finalizer doesn't modify the global Common struct.\n    @isok ccall((@cholmod_name(\"free_factor\", SuiteSparse_long), :libcholmod), Cint,\n            (Ref{Ptr{C_Factor{Tv}}}, Ptr{Cvoid}),\n                ptr, common_struct)\nend\n\nfunction aat(A::Sparse{Tv}, fset::Vector{SuiteSparse_long}, mode::Integer) where Tv<:VRealTypes\n    Sparse(ccall((@cholmod_name(\"aat\", SuiteSparse_long), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{SuiteSparse_long}, Csize_t, Cint, Ptr{UInt8}),\n                A, fset, length(fset), mode, common_struct))\nend\n\nfunction sparse_to_dense(A::Sparse{Tv}) where Tv<:VTypes\n    Dense(ccall((@cholmod_name(\"sparse_to_dense\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Dense{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                A, common_struct))\nend\nfunction dense_to_sparse(D::Dense{Tv}, ::Type{SuiteSparse_long}) where Tv<:VTypes\n    Sparse(ccall((@cholmod_name(\"dense_to_sparse\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Dense{Tv}}, Cint, Ptr{UInt8}),\n                D, true, common_struct))\nend\n\nfunction factor_to_sparse!(F::Factor{Tv}) where Tv<:VTypes\n    ss = unsafe_load(pointer(F))\n    ss.xtype > PATTERN || throw(CHOLMODException(\"only numeric factors are supported\"))\n    Sparse(ccall((@cholmod_name(\"factor_to_sparse\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                F, common_struct))\nend\n\nfunction change_factor!(::Type{Float64}, to_ll::Bool,\n        to_super::Bool, to_packed::Bool, to_monotonic::Bool, F::Factor{Tv}) where Tv<:VTypes\n    @isok ccall((@cholmod_name(\"change_factor\", SuiteSparse_long),:libcholmod), Cint,\n            (Cint, Cint, Cint, Cint, Cint, Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                REAL, to_ll, to_super, to_packed, to_monotonic, F, common_struct)\n    # don't register finalizer since we reuse object\n    Factor{Float64}(pointer(F), false)\nend\n\nfunction change_factor!(::Type{Complex{Float64}}, to_ll::Bool,\n        to_super::Bool, to_packed::Bool, to_monotonic::Bool, F::Factor{Tv}) where Tv<:VTypes\n    @isok ccall((@cholmod_name(\"change_factor\", SuiteSparse_long),:libcholmod), Cint,\n            (Cint, Cint, Cint, Cint, Cint, Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                COMPLEX, to_ll, to_super, to_packed, to_monotonic, F, common_struct)\n    # don't register finalizer since we reuse object\n    Factor{Complex{Float64}}(pointer(F), false)\nend\n\nfunction check_sparse(A::Sparse{Tv}) where Tv<:VTypes\n    ccall((@cholmod_name(\"check_sparse\", SuiteSparse_long),:libcholmod), Cint,\n          (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n           A, common_struct) != 0\nend\n\nfunction check_factor(F::Factor{Tv}) where Tv<:VTypes\n    ccall((@cholmod_name(\"check_factor\", SuiteSparse_long),:libcholmod), Cint,\n          (Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n           F, common_struct) != 0\nend\n\nfunction nnz(A::Sparse{Tv}) where Tv<:VTypes\n    ccall((@cholmod_name(\"nnz\", SuiteSparse_long),:libcholmod), Int,\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                A, common_struct)\nend\n\nfunction speye(m::Integer, n::Integer, ::Type{Tv}) where Tv<:VTypes\n    Sparse(ccall((@cholmod_name(\"speye\", SuiteSparse_long), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Csize_t, Csize_t, Cint, Ptr{UInt8}),\n                m, n, xtyp(Tv), common_struct))\nend\n\nfunction spzeros(m::Integer, n::Integer, nzmax::Integer, ::Type{Tv}) where Tv<:VTypes\n    Sparse(ccall((@cholmod_name(\"spzeros\", SuiteSparse_long), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Csize_t, Csize_t, Csize_t, Cint, Ptr{UInt8}),\n             m, n, nzmax, xtyp(Tv), common_struct))\nend\n\nfunction transpose_(A::Sparse{Tv}, values::Integer) where Tv<:VTypes\n    Sparse(ccall((@cholmod_name(\"transpose\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n                A, values, common_struct))\nend\n\nfunction copy_factor(F::Factor{Tv}) where Tv<:VTypes\n    Factor(ccall((@cholmod_name(\"copy_factor\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Factor{Tv}},\n            (Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n                F, common_struct))\nend\nfunction copy_sparse(A::Sparse{Tv}) where Tv<:VTypes\n    Sparse(ccall((@cholmod_name(\"copy_sparse\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                A, common_struct))\nend\nfunction copy(A::Sparse{Tv}, stype::Integer, mode::Integer) where Tv<:VRealTypes\n    Sparse(ccall((@cholmod_name(\"copy\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Cint, Cint, Ptr{UInt8}),\n                A, stype, mode, common_struct))\nend\n\n### cholmod_check.h ###\nfunction print_sparse(A::Sparse{Tv}, name::String) where Tv<:VTypes\n    isascii(name) || error(\"non-ASCII name: $name\")\n    set_print_level(common_struct, 3)\n    @isok ccall((@cholmod_name(\"print_sparse\", SuiteSparse_long),:libcholmod), Cint,\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}, Ptr{UInt8}),\n                 A, name, common_struct)\n    nothing\nend\nfunction print_factor(F::Factor{Tv}, name::String) where Tv<:VTypes\n    set_print_level(common_struct, 3)\n    @isok ccall((@cholmod_name(\"print_factor\", SuiteSparse_long),:libcholmod), Cint,\n            (Ptr{C_Factor{Tv}}, Ptr{UInt8}, Ptr{UInt8}),\n                F, name, common_struct)\n    nothing\nend\n\n### cholmod_matrixops.h ###\nfunction ssmult(A::Sparse{Tv}, B::Sparse{Tv}, stype::Integer,\n        values::Bool, sorted::Bool) where Tv<:VRealTypes\n    lA = unsafe_load(pointer(A))\n    lB = unsafe_load(pointer(B))\n    if lA.ncol != lB.nrow\n        throw(DimensionMismatch(\"inner matrix dimensions do not fit\"))\n    end\n    Sparse(ccall((@cholmod_name(\"ssmult\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{C_Sparse{Tv}}, Cint, Cint,\n                Cint, Ptr{UInt8}),\n             A, B, stype, values,\n                sorted, common_struct))\nend\n\nfunction norm_sparse(A::Sparse{Tv}, norm::Integer) where Tv<:VTypes\n    if norm != 0 && norm != 1\n        throw(ArgumentError(\"norm argument must be either 0 or 1\"))\n    end\n    ccall((@cholmod_name(\"norm_sparse\", SuiteSparse_long), :libcholmod), Cdouble,\n            (Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n                A, norm, common_struct)\nend\n\nfunction horzcat(A::Sparse{Tv}, B::Sparse{Tv}, values::Bool) where Tv<:VRealTypes\n    Sparse(ccall((@cholmod_name(\"horzcat\", SuiteSparse_long), :libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n             A, B, values, common_struct))\nend\n\nfunction scale!(S::Dense{Tv}, scale::Integer, A::Sparse{Tv}) where Tv<:VRealTypes\n    sS = unsafe_load(pointer(S))\n    sA = unsafe_load(pointer(A))\n    if sS.ncol != 1 && sS.nrow != 1\n        throw(DimensionMismatch(\"first argument must be a vector\"))\n    end\n    if scale == SCALAR && sS.nrow != 1\n        throw(DimensionMismatch(\"scaling argument must have length one\"))\n    elseif scale == ROW && sS.nrow*sS.ncol != sA.nrow\n        throw(DimensionMismatch(\"scaling vector has length $(sS.nrow*sS.ncol), \" *\n            \"but matrix has $(sA.nrow) rows.\"))\n    elseif scale == COL && sS.nrow*sS.ncol != sA.ncol\n        throw(DimensionMismatch(\"scaling vector has length $(sS.nrow*sS.ncol), \" *\n            \"but matrix has $(sA.ncol) columns\"))\n    elseif scale == SYM\n        if sA.nrow != sA.ncol\n            throw(DimensionMismatch(\"matrix must be square\"))\n        elseif sS.nrow*sS.ncol != sA.nrow\n            throw(DimensionMismatch(\"scaling vector has length $(sS.nrow*sS.ncol), \" *\n                \"but matrix has $(sA.ncol) columns and rows\"))\n        end\n    end\n\n    sA = unsafe_load(pointer(A))\n    @isok ccall((@cholmod_name(\"scale\",SuiteSparse_long),:libcholmod), Cint,\n            (Ptr{C_Dense{Tv}}, Cint, Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                S, scale, A, common_struct)\n    A\nend\n\nfunction sdmult!(A::Sparse{Tv}, transpose::Bool,\n        \u03b1::Number, \u03b2::Number, X::Dense{Tv}, Y::Dense{Tv}) where Tv<:VTypes\n    m, n = size(A)\n    nc = transpose ? m : n\n    nr = transpose ? n : m\n    if nc != size(X, 1)\n        throw(DimensionMismatch(\"incompatible dimensions, $nc and $(size(X,1))\"))\n    end\n    @isok ccall((@cholmod_name(\"sdmult\", SuiteSparse_long),:libcholmod), Cint,\n            (Ptr{C_Sparse{Tv}}, Cint,\n             Ref{ComplexF64}, Ref{ComplexF64},\n             Ptr{C_Dense{Tv}}, Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n                A, transpose, \u03b1, \u03b2, X, Y, common_struct)\n    Y\nend\n\nfunction vertcat(A::Sparse{Tv}, B::Sparse{Tv}, values::Bool) where Tv<:VRealTypes\n    Sparse(ccall((@cholmod_name(\"vertcat\", SuiteSparse_long), :libcholmod),\n            Ptr{C_Sparse{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{C_Sparse{Tv}}, Cint, Ptr{UInt8}),\n                A, B, values, common_struct))\nend\n\nfunction symmetry(A::Sparse{Tv}, option::Integer) where Tv<:VTypes\n    xmatched = Ref{SuiteSparse_long}()\n    pmatched = Ref{SuiteSparse_long}()\n    nzoffdiag = Ref{SuiteSparse_long}()\n    nzdiag = Ref{SuiteSparse_long}()\n    rv = ccall((@cholmod_name(\"symmetry\", SuiteSparse_long), :libcholmod), Cint,\n            (Ptr{C_Sparse{Tv}}, Cint, Ptr{SuiteSparse_long}, Ptr{SuiteSparse_long},\n                Ptr{SuiteSparse_long}, Ptr{SuiteSparse_long}, Ptr{UInt8}),\n                    A, option, xmatched, pmatched,\n                        nzoffdiag, nzdiag, common_struct)\n    rv, xmatched[], pmatched[], nzoffdiag[], nzdiag[]\nend\n\n# cholmod_cholesky.h\n# For analyze, analyze_p, and factorize_p!, the Common argument must be\n# supplied in order to control if the factorization is LLt or LDLt\nfunction analyze(A::Sparse{Tv}, cmmn::Vector{UInt8}) where Tv<:VTypes\n    Factor(ccall((@cholmod_name(\"analyze\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Factor{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                A, cmmn))\nend\nfunction analyze_p(A::Sparse{Tv}, perm::Vector{SuiteSparse_long},\n                   cmmn::Vector{UInt8}) where Tv<:VTypes\n    length(perm) != size(A,1) && throw(BoundsError())\n    Factor(ccall((@cholmod_name(\"analyze_p\", SuiteSparse_long),:libcholmod),\n            Ptr{C_Factor{Tv}},\n            (Ptr{C_Sparse{Tv}}, Ptr{SuiteSparse_long}, Ptr{SuiteSparse_long},\n                Csize_t, Ptr{UInt8}),\n                A, perm, C_NULL, 0, cmmn))\nend\nfunction factorize!(A::Sparse{Tv}, F::Factor{Tv}, cmmn::Vector{UInt8}) where Tv<:VTypes\n    @isok ccall((@cholmod_name(\"factorize\", SuiteSparse_long),:libcholmod), Cint,\n        (Ptr{C_Sparse{Tv}}, Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n            A, F, cmmn)\n    F\nend\nfunction factorize_p!(A::Sparse{Tv}, \u03b2::Real, F::Factor{Tv}, cmmn::Vector{UInt8}) where Tv<:VTypes\n    # note that \u03b2 is passed as a complex number (double beta[2]),\n    # but the CHOLMOD manual says that only beta[0] (real part) is used\n    @isok ccall((@cholmod_name(\"factorize_p\", SuiteSparse_long),:libcholmod), Cint,\n        (Ptr{C_Sparse{Tv}}, Ref{ComplexF64}, Ptr{SuiteSparse_long}, Csize_t,\n         Ptr{C_Factor{Tv}}, Ptr{UInt8}),\n            A, \u03b2, C_NULL, 0, F, cmmn)\n    F\nend\n\nfunction solve(sys::Integer, F::Factor{Tv}, B::Dense{Tv}) where Tv<:VTypes\n    if size(F,1) != size(B,1)\n        throw(DimensionMismatch(\"LHS and RHS should have the same number of rows. \" *\n            \"LHS has $(size(F,1)) rows, but RHS has $(size(B,1)) rows.\"))\n    end\n    if !issuccess(F)\n        s = unsafe_load(pointer(F))\n        if s.is_ll == 1\n            throw(LinearAlgebra.PosDefException(s.minor))\n        else\n            throw(ArgumentError(\"factorized matrix has one or more zero pivots. Try using `lu` instead.\"))\n        end\n    end\n    Dense(ccall((@cholmod_name(\"solve\", SuiteSparse_long),:libcholmod), Ptr{C_Dense{Tv}},\n            (Cint, Ptr{C_Factor{Tv}}, Ptr{C_Dense{Tv}}, Ptr{UInt8}),\n                sys, F, B, common_struct))\nend\n\nfunction spsolve(sys::Integer, F::Factor{Tv}, B::Sparse{Tv}) where Tv<:VTypes\n    if size(F,1) != size(B,1)\n        throw(DimensionMismatch(\"LHS and RHS should have the same number of rows. \" *\n            \"LHS has $(size(F,1)) rows, but RHS has $(size(B,1)) rows.\"))\n    end\n    Sparse(ccall((@cholmod_name(\"spsolve\", SuiteSparse_long),:libcholmod),\n        Ptr{C_Sparse{Tv}},\n            (Cint, Ptr{C_Factor{Tv}}, Ptr{C_Sparse{Tv}}, Ptr{UInt8}),\n                sys, F, B, common_struct))\nend\n\n# Autodetects the types\nfunction read_sparse(file::Libc.FILE, ::Type{SuiteSparse_long})\n    ptr = ccall((@cholmod_name(\"read_sparse\", SuiteSparse_long), :libcholmod),\n        Ptr{C_SparseVoid},\n            (Ptr{Cvoid}, Ptr{UInt8}),\n                file.ptr, common_struct)\n    if ptr == C_NULL\n        throw(ArgumentError(\"sparse matrix construction failed. Check that input file is valid.\"))\n    end\n    Sparse(ptr)\nend\n\nfunction read_sparse(file::IO, T)\n    cfile = Libc.FILE(file)\n    try return read_sparse(cfile, T)\n    finally close(cfile)\n    end\nend\n\nfunction get_perm(F::Factor)\n    s = unsafe_load(pointer(F))\n    p = unsafe_wrap(Array, s.Perm, s.n, own = false)\n    p .+ 1\nend\nget_perm(FC::FactorComponent) = get_perm(Factor(FC))\n\n#########################\n# High level interfaces #\n#########################\n\n# Conversion/construction\nfunction Dense{T}(A::StridedVecOrMat) where T<:VTypes\n    d = allocate_dense(size(A, 1), size(A, 2), stride(A, 2), T)\n    s = unsafe_load(pointer(d))\n    for i in eachindex(A)\n        unsafe_store!(s.x, A[i], i)\n    end\n    d\nend\nfunction Dense(A::StridedVecOrMat)\n    T = promote_type(eltype(A), Float64)\n    return Dense{T}(A)\nend\nDense(A::Sparse) = sparse_to_dense(A)\n\n# This constructior assumes zero based colptr and rowval\nfunction Sparse(m::Integer, n::Integer,\n        colptr0::Vector{SuiteSparse_long}, rowval0::Vector{SuiteSparse_long},\n        nzval::Vector{Tv}, stype) where Tv<:VTypes\n    # checks\n    ## length of input\n    if length(colptr0) <= n\n        throw(ArgumentError(\"length of colptr0 must be at least n + 1 = $(n + 1) but was $(length(colptr0))\"))\n    end\n    if colptr0[n + 1] > length(rowval0)\n        throw(ArgumentError(\"length of rowval0 is $(length(rowval0)) but value of colptr0 requires length to be at least $(colptr0[n + 1])\"))\n    end\n    if colptr0[n + 1] > length(nzval)\n        throw(ArgumentError(\"length of nzval is $(length(nzval)) but value of colptr0 requires length to be at least $(colptr0[n + 1])\"))\n    end\n    ## columns are sorted\n    iss = true\n    for i = 2:length(colptr0)\n        if !issorted(view(rowval0, colptr0[i - 1] + 1:colptr0[i]))\n            iss = false\n            break\n        end\n    end\n\n    o = allocate_sparse(m, n, colptr0[n + 1], iss, true, stype, Tv)\n    s = unsafe_load(pointer(o))\n\n    unsafe_copyto!(s.p, pointer(colptr0), n + 1)\n    unsafe_copyto!(s.i, pointer(rowval0), colptr0[n + 1])\n    unsafe_copyto!(s.x, pointer(nzval) , colptr0[n + 1])\n\n    @isok check_sparse(o)\n\n    return o\nend\n\nfunction Sparse(m::Integer, n::Integer,\n        colptr0::Vector{SuiteSparse_long},\n        rowval0::Vector{SuiteSparse_long},\n        nzval::Vector{<:VTypes})\n    o = Sparse(m, n, colptr0, rowval0, nzval, 0)\n\n    # sort indices\n    sort!(o)\n\n    # check if array is symmetric and change stype if it is\n    if ishermitian(o)\n        change_stype!(o, -1)\n    end\n    o\nend\n\nfunction Sparse(A::SparseMatrixCSC{Tv,SuiteSparse_long}, stype::Integer) where Tv<:VTypes\n    ## Check length of input. This should never fail but see #20024\n    if length(A.colptr) <= A.n\n        throw(ArgumentError(\"length of colptr must be at least size(A,2) + 1 = $(A.n + 1) but was $(length(A.colptr))\"))\n    end\n    if nnz(A) > length(A.rowval)\n        throw(ArgumentError(\"length of rowval is $(length(A.rowval)) but value of colptr requires length to be at least $(nnz(A))\"))\n    end\n    if nnz(A) > length(A.nzval)\n        throw(ArgumentError(\"length of nzval is $(length(A.nzval)) but value of colptr requires length to be at least $(nnz(A))\"))\n    end\n\n    o = allocate_sparse(A.m, A.n, nnz(A), true, true, stype, Tv)\n    s = unsafe_load(pointer(o))\n    for i = 1:(A.n + 1)\n        unsafe_store!(s.p, A.colptr[i] - 1, i)\n    end\n    for i = 1:nnz(A)\n        unsafe_store!(s.i, A.rowval[i] - 1, i)\n    end\n    unsafe_copyto!(s.x, pointer(A.nzval), nnz(A))\n\n    @isok check_sparse(o)\n\n    return o\nend\n\n# convert SparseVectors into CHOLMOD Sparse types through a mx1 CSC matrix\nSparse(A::SparseVector{<:VTypes,SuiteSparse_long}) = Sparse(SparseMatrixCSC(A))\nfunction Sparse(A::SparseMatrixCSC{<:VTypes,<:ITypes})\n    o = Sparse(A, 0)\n    # check if array is symmetric and change stype if it is\n    if ishermitian(o)\n        change_stype!(o, -1)\n    end\n    o\nend\nSparse(A::SparseMatrixCSC{Complex{Float32},<:ITypes}) =\n    Sparse(SparseMatrixCSC{Complex{Float64},SuiteSparse_long}(A))\nSparse(A::Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}) =\n    Sparse(A.data, A.uplo == 'L' ? -1 : 1)\n# The convert method for Hermitian is very similar to the general convert method, but we need to\n# remove any non real elements in the diagonal because, in contrast to BLAS/LAPACK these are not\n# ignored by CHOLMOD. If even tiny imaginary parts are present CHOLMOD will fail with a non-positive\n# definite/zero pivot error.\nfunction Sparse(AH::Hermitian{Tv,SparseMatrixCSC{Tv,SuiteSparse_long}}) where {Tv<:VTypes}\n    A = AH.data\n\n    # Here we allocate a Symmetric/Hermitian CHOLMOD.Sparse matrix so we only need to copy\n    # a single triangle of AH\n    o = allocate_sparse(A.m, A.n, length(A.nzval), true, true, AH.uplo == 'L' ? -1 : 1, Tv)\n    s = unsafe_load(pointer(o))\n    for i = 1:length(A.colptr)\n        unsafe_store!(s.p, A.colptr[i] - 1, i)\n    end\n    for i = 1:length(A.rowval)\n        unsafe_store!(s.i, A.rowval[i] - 1, i)\n    end\n    for j = 1:A.n\n        for ip = A.colptr[j]:A.colptr[j + 1] - 1\n            v = A.nzval[ip]\n            unsafe_store!(s.x, ifelse(A.rowval[ip] == j, real(v), v), ip)\n        end\n    end\n\n    @isok check_sparse(o)\n\n    return o\nend\nfunction Sparse(A::Union{SparseMatrixCSC{BigFloat,Ti},\n                         Symmetric{BigFloat,SparseMatrixCSC{BigFloat,Ti}},\n                         Hermitian{Complex{BigFloat},SparseMatrixCSC{Complex{BigFloat},Ti}}},\n                args...) where Ti<:ITypes\n    throw(MethodError(Sparse, (A,)))\nend\nfunction Sparse(A::Union{SparseMatrixCSC{T,Ti},\n                         Symmetric{T,SparseMatrixCSC{T,Ti}},\n                         Hermitian{T,SparseMatrixCSC{T,Ti}}},\n                args...) where T where Ti<:ITypes\n    return Sparse(AbstractMatrix{promote_type(Float64, T)}(A), args...)\nend\n\n# Useful when reading in files, but not type stable\nfunction Sparse(p::Ptr{C_SparseVoid})\n    if p == C_NULL\n        throw(ArgumentError(\"sparse matrix construction failed for \" *\n            \"unknown reasons. Please submit a bug report.\"))\n    end\n\n    s = unsafe_load(p)\n\n    # Check integer type\n    if s.itype == INT\n        free_sparse!(p)\n        throw(CHOLMODException(\"the value of itype was $s.itype. \" *\n            \"Only integer type of $SuiteSparse_long is supported.\"))\n    elseif s.itype == INTLONG\n        free_sparse!(p)\n        throw(CHOLMODException(\"the value of itype was $s.itype. This combination \" *\n            \"of integer types shouldn't happen. Please submit a bug report.\"))\n    elseif s.itype != LONG # must be s.itype == LONG\n        free_sparse!(p)\n        throw(CHOLMODException(\"illegal value of itype: $s.itype\"))\n    end\n\n    # Check for double or single precision\n    if s.dtype == DOUBLE\n        Tv = Float64\n    elseif s.dtype == SINGLE\n        # Tv = Float32 # this should be supported at some point\n        free_sparse!(p)\n        throw(CHOLMODException(\"single precision not supported yet\"))\n    else\n        free_sparse!(p)\n        throw(CHOLMODException(\"illegal value of dtype: $s.dtype\"))\n    end\n\n    # Check for real or complex\n    if s.xtype == COMPLEX\n        Tv = Complex{Tv}\n    elseif s.xtype != REAL\n        free_sparse!(p)\n        throw(CHOLMODException(\"illegal value of xtype: $s.xtype\"))\n    end\n\n    return Sparse(convert(Ptr{C_Sparse{Tv}}, p))\nend\n\nSparse(A::Dense) = dense_to_sparse(A, SuiteSparse_long)\nSparse(L::Factor) = factor_to_sparse!(copy(L))\nfunction Sparse(filename::String)\n    open(filename) do f\n        return read_sparse(f, SuiteSparse_long)\n    end\nend\n\n## conversion back to base Julia types\nfunction Matrix{T}(D::Dense{T}) where T\n    s = unsafe_load(pointer(D))\n    a = Matrix{T}(undef, s.nrow, s.ncol)\n    copyto!(a, D)\nend\n\nBase.copyto!(dest::Base.PermutedDimsArrays.PermutedDimsArray, src::Dense) = _copy!(dest, src) # ambig\nBase.copyto!(dest::Dense{T}, D::Dense{T}) where {T<:VTypes} = _copy!(dest, D)\nBase.copyto!(dest::AbstractArray{T}, D::Dense{T}) where {T<:VTypes} = _copy!(dest, D)\nBase.copyto!(dest::AbstractArray{T,2}, D::Dense{T}) where {T<:VTypes} = _copy!(dest, D)\nBase.copyto!(dest::AbstractArray, D::Dense) = _copy!(dest, D)\n\nfunction _copy!(dest::AbstractArray, D::Dense)\n    @assert !has_offset_axes(dest)\n    s = unsafe_load(pointer(D))\n    n = s.nrow*s.ncol\n    n <= length(dest) || throw(BoundsError(dest, n))\n    if s.d == s.nrow && isa(dest, Array)\n        unsafe_copyto!(pointer(dest), s.x, s.d*s.ncol)\n    else\n        k = 0\n        for j = 1:s.ncol\n            for i = 1:s.nrow\n                dest[k+=1] = unsafe_load(s.x, i + (j - 1)*s.d)\n            end\n        end\n    end\n    dest\nend\nMatrix(D::Dense{T}) where {T} = Matrix{T}(D)\nfunction Vector{T}(D::Dense{T}) where T\n    if size(D, 2) > 1\n        throw(DimensionMismatch(\"input must be a vector but had $(size(D, 2)) columns\"))\n    end\n    copyto!(Vector{T}(undef, size(D, 1)), D)\nend\nVector(D::Dense{T}) where {T} = Vector{T}(D)\n\nfunction SparseMatrixCSC{Tv,SuiteSparse_long}(A::Sparse{Tv}) where Tv\n    s = unsafe_load(pointer(A))\n    if s.stype != 0\n        throw(ArgumentError(\"matrix has stype != 0. Convert to matrix \" *\n            \"with stype == 0 before converting to SparseMatrixCSC\"))\n    end\n\n    B = SparseMatrixCSC(s.nrow, s.ncol,\n        increment(unsafe_wrap(Array, s.p, (s.ncol + 1,), own = false)),\n        increment(unsafe_wrap(Array, s.i, (s.nzmax,), own = false)),\n        copy(unsafe_wrap(Array, s.x, (s.nzmax,), own = false)))\n\n    if s.sorted == 0\n        return SparseArrays.sortSparseMatrixCSC!(B)\n    else\n        return B\n    end\nend\n\nfunction (::Type{Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}})(A::Sparse{Float64})\n    s = unsafe_load(pointer(A))\n    if !issymmetric(A)\n        throw(ArgumentError(\"matrix is not symmetric\"))\n    end\n\n    B = Symmetric(SparseMatrixCSC(s.nrow, s.ncol,\n        increment(unsafe_wrap(Array, s.p, (s.ncol + 1,), own = false)),\n        increment(unsafe_wrap(Array, s.i, (s.nzmax,), own = false)),\n        copy(unsafe_wrap(Array, s.x, (s.nzmax,), own = false))), s.stype > 0 ? :U : :L)\n\n    if s.sorted == 0\n        return SparseArrays.sortSparseMatrixCSC!(B.data)\n    else\n        return B\n    end\nend\nconvert(T::Type{Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}}, A::Sparse{Float64}) = T(A)\n\nfunction Hermitian{Tv,SparseMatrixCSC{Tv,SuiteSparse_long}}(A::Sparse{Tv}) where Tv<:VTypes\n    s = unsafe_load(pointer(A))\n    if !ishermitian(A)\n        throw(ArgumentError(\"matrix is not Hermitian\"))\n    end\n\n    B = Hermitian(SparseMatrixCSC(s.nrow, s.ncol,\n        increment(unsafe_wrap(Array, s.p, (s.ncol + 1,), own = false)),\n        increment(unsafe_wrap(Array, s.i, (s.nzmax,), own = false)),\n        copy(unsafe_wrap(Array, s.x, (s.nzmax,), own = false))), s.stype > 0 ? :U : :L)\n\n    if s.sorted == 0\n        return SparseArrays.sortSparseMatrixCSC!(B.data)\n    else\n        return B\n    end\nend\nconvert(T::Type{Hermitian{Tv,SparseMatrixCSC{Tv,SuiteSparse_long}}}, A::Sparse{Tv}) where {Tv<:VTypes} = T(A)\n\nfunction sparse(A::Sparse{Float64}) # Notice! Cannot be type stable because of stype\n    s = unsafe_load(pointer(A))\n    if s.stype == 0\n        return SparseMatrixCSC{Float64,SuiteSparse_long}(A)\n    end\n    return Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}}(A)\nend\nfunction sparse(A::Sparse{Complex{Float64}}) # Notice! Cannot be type stable because of stype\n    s = unsafe_load(pointer(A))\n    if s.stype == 0\n        return SparseMatrixCSC{Complex{Float64},SuiteSparse_long}(A)\n    end\n    return Hermitian{Complex{Float64},SparseMatrixCSC{Complex{Float64},SuiteSparse_long}}(A)\nend\nfunction sparse(F::Factor)\n    s = unsafe_load(pointer(F))\n    if s.is_ll != 0\n        L = Sparse(F)\n        A = sparse(L*L')\n    else\n        LD = sparse(F.LD)\n        L, d = getLd!(LD)\n        A = (L * Diagonal(d)) * L'\n    end\n    SparseArrays.sortSparseMatrixCSC!(A)\n    p = get_perm(F)\n    if p != [1:s.n;]\n        pinv = Vector{Int}(undef, length(p))\n        for k = 1:length(p)\n            pinv[p[k]] = k\n        end\n        A = A[pinv,pinv]\n    end\n    A\nend\n\nsparse(D::Dense) = sparse(Sparse(D))\n\nfunction sparse(FC::FactorComponent{Tv,:L}) where Tv\n    F = Factor(FC)\n    s = unsafe_load(pointer(F))\n    if s.is_ll == 0\n        throw(CHOLMODException(\"sparse: supported only for :LD on LDLt factorizations\"))\n    end\n    sparse(Sparse(F))\nend\nsparse(FC::FactorComponent{Tv,:LD}) where {Tv} = sparse(Sparse(Factor(FC)))\n\n# Calculate the offset into the stype field of the cholmod_sparse_struct and\n# change the value\nlet offset = fieldoffset(C_Sparse{Float64}, findfirst(name -> name === :stype, fieldnames(C_Sparse{Float64}))::Int)\n    global change_stype!\n    function change_stype!(A::Sparse, i::Integer)\n        unsafe_store!(convert(Ptr{Cint}, pointer(A)), i, div(offset, 4) + 1)\n        return A\n    end\nend\n\nfree!(A::Dense)  = free_dense!( pointer(A))\nfree!(A::Sparse) = free_sparse!(pointer(A))\nfree!(F::Factor) = free_factor!(pointer(F))\n\neltype(::Type{Dense{T}}) where {T<:VTypes} = T\neltype(::Type{Factor{T}}) where {T<:VTypes} = T\neltype(::Type{Sparse{T}}) where {T<:VTypes} = T\n\nnnz(F::Factor) = nnz(Sparse(F))\n\nfunction show(io::IO, F::Factor)\n    println(io, typeof(F))\n    showfactor(io, F)\nend\n\nfunction show(io::IO, FC::FactorComponent)\n    println(io, typeof(FC))\n    showfactor(io, Factor(FC))\nend\n\nfunction showfactor(io::IO, F::Factor)\n    s = unsafe_load(pointer(F))\n    print(io, \"\"\"\n        type:    $(s.is_ll!=0 ? \"LLt\" : \"LDLt\")\n        method:  $(s.is_super!=0 ? \"supernodal\" : \"simplicial\")\n        maxnnz:  $(Int(s.nzmax))\n        nnz:     $(nnz(F))\n        success: $(s.minor == size(F, 1))\n        \"\"\")\nend\n\n# getindex not defined for these, so don't use the normal array printer\nshow(io::IO, ::MIME\"text/plain\", FC::FactorComponent) = show(io, FC)\nshow(io::IO, ::MIME\"text/plain\", F::Factor) = show(io, F)\n\nisvalid(A::Dense) = check_dense(A)\nisvalid(A::Sparse) = check_sparse(A)\nisvalid(A::Factor) = check_factor(A)\n\ncopy(A::Dense) = copy_dense(A)\ncopy(A::Sparse) = copy_sparse(A)\ncopy(A::Factor) = copy_factor(A)\n\nfunction size(A::Union{Dense,Sparse})\n    s = unsafe_load(pointer(A))\n    return (Int(s.nrow), Int(s.ncol))\nend\nfunction size(F::Factor, i::Integer)\n    if i < 1\n        throw(ArgumentError(\"dimension must be positive\"))\n    end\n    s = unsafe_load(pointer(F))\n    if i <= 2\n        return Int(s.n)\n    end\n    return 1\nend\nsize(F::Factor) = (size(F, 1), size(F, 2))\naxes(A::Union{Dense,Sparse,Factor}) = map(Base.OneTo, size(A))\n\nIndexStyle(::Dense) = IndexLinear()\n\nsize(FC::FactorComponent, i::Integer) = size(FC.F, i)\nsize(FC::FactorComponent) = size(FC.F)\n\nadjoint(FC::FactorComponent{Tv,:L}) where {Tv} = FactorComponent{Tv,:U}(FC.F)\nadjoint(FC::FactorComponent{Tv,:U}) where {Tv} = FactorComponent{Tv,:L}(FC.F)\nadjoint(FC::FactorComponent{Tv,:PtL}) where {Tv} = FactorComponent{Tv,:UP}(FC.F)\nadjoint(FC::FactorComponent{Tv,:UP}) where {Tv} = FactorComponent{Tv,:PtL}(FC.F)\nadjoint(FC::FactorComponent{Tv,:D}) where {Tv} = FC\nadjoint(FC::FactorComponent{Tv,:LD}) where {Tv} = FactorComponent{Tv,:DU}(FC.F)\nadjoint(FC::FactorComponent{Tv,:DU}) where {Tv} = FactorComponent{Tv,:LD}(FC.F)\nadjoint(FC::FactorComponent{Tv,:PtLD}) where {Tv} = FactorComponent{Tv,:DUP}(FC.F)\nadjoint(FC::FactorComponent{Tv,:DUP}) where {Tv} = FactorComponent{Tv,:PtLD}(FC.F)\n\nfunction getindex(A::Dense, i::Integer)\n    s = unsafe_load(pointer(A))\n    0 < i <= s.nrow*s.ncol || throw(BoundsError())\n    unsafe_load(s.x, i)\nend\n\nIndexStyle(::Sparse) = IndexCartesian()\nfunction getindex(A::Sparse{T}, i0::Integer, i1::Integer) where T\n    s = unsafe_load(pointer(A))\n    !(1 <= i0 <= s.nrow && 1 <= i1 <= s.ncol) && throw(BoundsError())\n    s.stype < 0 && i0 < i1 && return conj(A[i1,i0])\n    s.stype > 0 && i0 > i1 && return conj(A[i1,i0])\n\n    r1 = Int(unsafe_load(s.p, i1) + 1)\n    r2 = Int(unsafe_load(s.p, i1 + 1))\n    (r1 > r2) && return zero(T)\n    r1 = Int(searchsortedfirst(unsafe_wrap(Array, s.i, (s.nzmax,), own = false),\n        i0 - 1, r1, r2, Base.Order.Forward))\n    ((r1 > r2) || (unsafe_load(s.i, r1) + 1 != i0)) ? zero(T) : unsafe_load(s.x, r1)\nend\n\n@inline function getproperty(F::Factor, sym::Symbol)\n    if sym == :p\n        return get_perm(F)\n    elseif sym == :ptr\n        return getfield(F, :ptr)\n    else\n        return FactorComponent(F, sym)\n    end\nend\n\nfunction getLd!(S::SparseMatrixCSC)\n    d = Vector{eltype(S)}(undef, size(S, 1))\n    fill!(d, 0)\n    col = 1\n    for k = 1:nnz(S)\n        while k >= S.colptr[col+1]\n            col += 1\n        end\n        if S.rowval[k] == col\n            d[col] = S.nzval[k]\n            S.nzval[k] = 1\n        end\n    end\n    S, d\nend\n\n## Multiplication\n(*)(A::Sparse, B::Sparse) = ssmult(A, B, 0, true, true)\n(*)(A::Sparse, B::Dense) = sdmult!(A, false, 1., 0., B, zeros(size(A, 1), size(B, 2)))\n(*)(A::Sparse, B::VecOrMat) = (*)(A, Dense(B))\n\nfunction *(A::Sparse{Tv}, adjB::Adjoint{Tv,Sparse{Tv}}) where Tv<:VRealTypes\n    B = adjB.parent\n    if A !== B\n        aa1 = transpose_(B, 2)\n        ## result of ssmult will have stype==0, contain numerical values and be sorted\n        return ssmult(A, aa1, 0, true, true)\n    end\n\n    ## The A*A' case is handled by cholmod_aat. This routine requires\n    ## A->stype == 0 (storage of upper and lower parts). If necessary\n    ## the matrix A is first converted to stype == 0\n    s = unsafe_load(pointer(A))\n    if s.stype != 0\n        aa1 = copy(A, 0, 1)\n        return aat(aa1, SuiteSparse_long[0:s.ncol-1;], 1)\n    else\n        return aat(A, SuiteSparse_long[0:s.ncol-1;], 1)\n    end\nend\n\nfunction *(adjA::Adjoint{<:Any,<:Sparse}, B::Sparse)\n    A = adjA.parent\n    aa1 = transpose_(A, 2)\n    if A === B\n        return *(aa1, adjoint(aa1))\n    end\n    ## result of ssmult will have stype==0, contain numerical values and be sorted\n    return ssmult(aa1, B, 0, true, true)\nend\n\n*(adjA::Adjoint{<:Any,<:Sparse}, B::Dense) =\n    (A = adjA.parent; sdmult!(A, true, 1., 0., B, zeros(size(A, 2), size(B, 2))))\n*(adjA::Adjoint{<:Any,<:Sparse}, B::VecOrMat) =\n    (A = adjA.parent; *(adjoint(A), Dense(B)))\n\n\n## Factorization methods\n\n## Compute that symbolic factorization only\nfunction fact_(A::Sparse{<:VTypes}, cm::Array{UInt8};\n    perm::AbstractVector{SuiteSparse_long}=SuiteSparse_long[],\n    postorder::Bool=true, userperm_only::Bool=true)\n\n    sA = unsafe_load(pointer(A))\n    sA.stype == 0 && throw(ArgumentError(\"sparse matrix is not symmetric/Hermitian\"))\n\n    if !postorder\n        unsafe_store!(common_postorder[], 0)\n    end\n\n    if isempty(perm)\n        F = analyze(A, cm)\n    else # user permutation provided\n        if userperm_only # use perm even if it is worse than AMD\n            unsafe_store!(common_nmethods[], 1)\n        end\n        F = analyze_p(A, SuiteSparse_long[p-1 for p in perm], cm)\n    end\n\n    return F\nend\n\nfunction cholesky!(F::Factor{Tv}, A::Sparse{Tv};\n                   shift::Real=0.0, check::Bool = true) where Tv\n    # Makes it an LLt\n    unsafe_store!(common_final_ll[], 1)\n\n    # Compute the numerical factorization\n    factorize_p!(A, shift, F, common_struct)\n\n    check && (issuccess(F) || throw(LinearAlgebra.PosDefException(1)))\n    return F\nend\n\n\"\"\"\n    cholesky!(F::Factor, A; shift = 0.0, check = true) -> CHOLMOD.Factor\n\nCompute the Cholesky (``LL'``) factorization of `A`, reusing the symbolic\nfactorization `F`. `A` must be a [`SparseMatrixCSC`](@ref) or a [`Symmetric`](@ref)/\n[`Hermitian`](@ref) view of a `SparseMatrixCSC`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\n\nSee also [`cholesky`](@ref).\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{ComplexF64}`\n    as appropriate.\n\"\"\"\ncholesky!(F::Factor, A::Union{SparseMatrixCSC{T},\n          SparseMatrixCSC{Complex{T}},\n          Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n          Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n          Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n          shift = 0.0, check::Bool = true) where {T<:Real} =\n    cholesky!(F, Sparse(A); shift = shift, check = check)\n\nfunction cholesky(A::Sparse; shift::Real=0.0, check::Bool = true,\n    perm::AbstractVector{SuiteSparse_long}=SuiteSparse_long[])\n\n    cm = defaults(common_struct)\n    set_print_level(cm, 0)\n\n    # Compute the symbolic factorization\n    F = fact_(A, cm; perm = perm)\n\n    # Compute the numerical factorization\n    cholesky!(F, A; shift = shift, check = check)\n\n    return F\nend\n\n\"\"\"\n    cholesky(A; shift = 0.0, check = true, perm = Int[]) -> CHOLMOD.Factor\n\nCompute the Cholesky factorization of a sparse positive definite matrix `A`.\n`A` must be a [`SparseMatrixCSC`](@ref) or a [`Symmetric`](@ref)/[`Hermitian`](@ref)\nview of a `SparseMatrixCSC`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\nA fill-reducing permutation is used.\n`F = cholesky(A)` is most frequently used to solve systems of equations with `F\\\\b`,\nbut also the methods [`diag`](@ref), [`det`](@ref), and\n[`logdet`](@ref) are defined for `F`.\nYou can also extract individual factors from `F`, using `F.L`.\nHowever, since pivoting is on by default, the factorization is internally\nrepresented as `A == P'*L*L'*P` with a permutation matrix `P`;\nusing just `L` without accounting for `P` will give incorrect answers.\nTo include the effects of permutation,\nit's typically preferable to extract \"combined\" factors like `PtL = F.PtL`\n(the equivalent of `P'*L`) and `LtP = F.UP` (the equivalent of `L'*P`).\n\nWhen `check = true`, an error is thrown if the decomposition fails.\nWhen `check = false`, responsibility for checking the decomposition's\nvalidity (via [`issuccess`](@ref)) lies with the user.\n\nSetting the optional `shift` keyword argument computes the factorization of\n`A+shift*I` instead of `A`. If the `perm` argument is nonempty,\nit should be a permutation of `1:size(A,1)` giving the ordering to use\n(instead of CHOLMOD's default AMD ordering).\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{ComplexF64}`\n    as appropriate.\n\n    Many other functions from CHOLMOD are wrapped but not exported from the\n    `Base.SparseArrays.CHOLMOD` module.\n\"\"\"\ncholesky(A::Union{SparseMatrixCSC{T}, SparseMatrixCSC{Complex{T}},\n    Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n    Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n    Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n    kws...) where {T<:Real} = cholesky(Sparse(A); kws...)\n\n\nfunction ldlt!(F::Factor{Tv}, A::Sparse{Tv};\n               shift::Real=0.0, check::Bool = true) where Tv\n    cm = defaults(common_struct)\n    set_print_level(cm, 0)\n\n    # Makes it an LDLt\n    change_factor!(eltype(F), false, false, true, false, F)\n\n    # Compute the numerical factorization\n    factorize_p!(A, shift, F, cm)\n\n    check && (issuccess(F) || throw(LinearAlgebra.PosDefException(1)))\n    return F\nend\n\n\"\"\"\n    ldlt!(F::Factor, A; shift = 0.0, check = true) -> CHOLMOD.Factor\n\nCompute the ``LDL'`` factorization of `A`, reusing the symbolic factorization `F`.\n`A` must be a [`SparseMatrixCSC`](@ref) or a [`Symmetric`](@ref)/[`Hermitian`](@ref)\nview of a `SparseMatrixCSC`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\n\nSee also [`ldlt`](@ref).\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{ComplexF64}`\n    as appropriate.\n\"\"\"\nldlt!(F::Factor, A::Union{SparseMatrixCSC{T},\n    SparseMatrixCSC{Complex{T}},\n    Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n    Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n    Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n    shift = 0.0, check::Bool = true) where {T<:Real} =\n    ldlt!(F, Sparse(A), shift = shift, check = check)\n\nfunction ldlt(A::Sparse; shift::Real=0.0, check::Bool = true,\n    perm::AbstractVector{SuiteSparse_long}=SuiteSparse_long[])\n\n    cm = defaults(common_struct)\n    set_print_level(cm, 0)\n\n    # Makes it an LDLt\n    unsafe_store!(common_final_ll[], 0)\n    # Really make sure it's an LDLt by avoiding supernodal factorization\n    unsafe_store!(common_supernodal[], 0)\n\n    # Compute the symbolic factorization\n    F = fact_(A, cm; perm = perm)\n\n    # Compute the numerical factorization\n    ldlt!(F, A; shift = shift, check = check)\n\n    return F\nend\n\n\"\"\"\n    ldlt(A; shift = 0.0, check = true, perm=Int[]) -> CHOLMOD.Factor\n\nCompute the ``LDL'`` factorization of a sparse matrix `A`.\n`A` must be a [`SparseMatrixCSC`](@ref) or a [`Symmetric`](@ref)/[`Hermitian`](@ref)\nview of a `SparseMatrixCSC`. Note that even if `A` doesn't\nhave the type tag, it must still be symmetric or Hermitian.\nA fill-reducing permutation is used. `F = ldlt(A)` is most frequently\nused to solve systems of equations `A*x = b` with `F\\\\b`. The returned\nfactorization object `F` also supports the methods [`diag`](@ref),\n[`det`](@ref), [`logdet`](@ref), and [`inv`](@ref).\nYou can extract individual factors from `F` using `F.L`.\nHowever, since pivoting is on by default, the factorization is internally\nrepresented as `A == P'*L*D*L'*P` with a permutation matrix `P`;\nusing just `L` without accounting for `P` will give incorrect answers.\nTo include the effects of permutation, it is typically preferable to extract\n\"combined\" factors like `PtL = F.PtL` (the equivalent of\n`P'*L`) and `LtP = F.UP` (the equivalent of `L'*P`).\nThe complete list of supported factors is `:L, :PtL, :D, :UP, :U, :LD, :DU, :PtLD, :DUP`.\n\nWhen `check = true`, an error is thrown if the decomposition fails.\nWhen `check = false`, responsibility for checking the decomposition's\nvalidity (via [`issuccess`](@ref)) lies with the user.\n\nSetting the optional `shift` keyword argument computes the factorization of\n`A+shift*I` instead of `A`. If the `perm` argument is nonempty,\nit should be a permutation of `1:size(A,1)` giving the ordering to use\n(instead of CHOLMOD's default AMD ordering).\n\n!!! note\n    This method uses the CHOLMOD library from SuiteSparse, which only supports\n    doubles or complex doubles. Input matrices not of those element types will\n    be converted to `SparseMatrixCSC{Float64}` or `SparseMatrixCSC{ComplexF64}`\n    as appropriate.\n\n    Many other functions from CHOLMOD are wrapped but not exported from the\n    `Base.SparseArrays.CHOLMOD` module.\n\"\"\"\nldlt(A::Union{SparseMatrixCSC{T},SparseMatrixCSC{Complex{T}},\n    Symmetric{T,SparseMatrixCSC{T,SuiteSparse_long}},\n    Hermitian{Complex{T},SparseMatrixCSC{Complex{T},SuiteSparse_long}},\n    Hermitian{T,SparseMatrixCSC{T,SuiteSparse_long}}};\n    kws...) where {T<:Real} = ldlt(Sparse(A); kws...)\n\n## Rank updates\n\n\"\"\"\n    lowrankupdowndate!(F::Factor, C::Sparse, update::Cint)\n\nUpdate an `LDLt` or `LLt` Factorization `F` of `A` to a factorization of `A \u00b1 C*C'`.\n\nIf sparsity preserving factorization is used, i.e. `L*L' == P*A*P'` then the new\nfactor will be `L*L' == P*A*P' + C'*C`\n\nupdate: `Cint(1)` for `A + CC'`, `Cint(0)` for `A - CC'`\n\"\"\"\nfunction lowrankupdowndate!(F::Factor{Tv}, C::Sparse{Tv}, update::Cint) where Tv<:VTypes\n    lF = unsafe_load(pointer(F))\n    lC = unsafe_load(pointer(C))\n    if lF.n != lC.nrow\n        throw(DimensionMismatch(\"matrix dimensions do not fit\"))\n    end\n    @isok ccall((:cholmod_l_updown, :libcholmod), Cint,\n        (Cint, Ptr{C_Sparse{Tv}}, Ptr{C_Factor{Tv}}, Ptr{Cvoid}),\n        update, C, F, common_struct)\n    F\nend\n\n#Helper functions for rank updates\nlowrank_reorder(V::AbstractArray,p) = Sparse(sparse(V[p,:]))\nlowrank_reorder(V::AbstractSparseArray,p) = Sparse(V[p,:])\n\n\"\"\"\n    lowrankupdate!(F::Factor, C)\n\nUpdate an `LDLt` or `LLt` Factorization `F` of `A` to a factorization of `A + C*C'`.\n\n`LLt` factorizations are converted to `LDLt`.\n\nSee also [`lowrankupdate`](@ref), [`lowrankdowndate`](@ref), [`lowrankdowndate!`](@ref).\n\"\"\"\nfunction lowrankupdate!(F::Factor{Tv}, V::AbstractArray{Tv}) where Tv<:VTypes\n    #Reorder and copy V to account for permutation\n    C = lowrank_reorder(V, get_perm(F))\n    lowrankupdowndate!(F, C, Cint(1))\nend\n\n\"\"\"\n    lowrankdowndate!(F::Factor, C)\n\nUpdate an `LDLt` or `LLt` Factorization `F` of `A` to a factorization of `A - C*C'`.\n\n`LLt` factorizations are converted to `LDLt`.\n\nSee also [`lowrankdowndate`](@ref), [`lowrankupdate`](@ref), [`lowrankupdate!`](@ref).\n\"\"\"\nfunction lowrankdowndate!(F::Factor{Tv}, V::AbstractArray{Tv}) where Tv<:VTypes\n    #Reorder and copy V to account for permutation\n    C = lowrank_reorder(V, get_perm(F))\n    lowrankupdowndate!(F, C, Cint(0))\nend\n\n\"\"\"\n    lowrankupdate(F::Factor, C) -> FF::Factor\n\nGet an `LDLt` Factorization of `A + C*C'` given an `LDLt` or `LLt` factorization `F` of `A`.\n\nThe returned factor is always an `LDLt` factorization.\n\nSee also [`lowrankupdate!`](@ref), [`lowrankdowndate`](@ref), [`lowrankdowndate!`](@ref).\n\"\"\"\nlowrankupdate(F::Factor{Tv}, V::AbstractArray{Tv}) where {Tv<:VTypes} =\n    lowrankupdate!(copy(F), V)\n\n\"\"\"\n    lowrankupdate(F::Factor, C) -> FF::Factor\n\nGet an `LDLt` Factorization of `A + C*C'` given an `LDLt` or `LLt` factorization `F` of `A`.\n\nThe returned factor is always an `LDLt` factorization.\n\nSee also [`lowrankdowndate!`](@ref), [`lowrankupdate`](@ref), [`lowrankupdate!`](@ref).\n\"\"\"\nlowrankdowndate(F::Factor{Tv}, V::AbstractArray{Tv}) where {Tv<:VTypes} =\n    lowrankdowndate!(copy(F), V)\n\n## Solvers\n\nfor (T, f) in ((:Dense, :solve), (:Sparse, :spsolve))\n    @eval begin\n        # Solve Lx = b and L'x=b where A = L*L'\n        function (\\)(L::FactorComponent{T,:L}, B::$T) where T\n            ($f)(CHOLMOD_L, Factor(L), B)\n        end\n        function (\\)(L::FactorComponent{T,:U}, B::$T) where T\n            ($f)(CHOLMOD_Lt, Factor(L), B)\n        end\n        # Solve PLx = b and L'P'x=b where A = P*L*L'*P'\n        function (\\)(L::FactorComponent{T,:PtL}, B::$T) where T\n            F = Factor(L)\n            ($f)(CHOLMOD_L, F, ($f)(CHOLMOD_P, F, B)) # Confusingly, CHOLMOD_P solves P'x = b\n        end\n        function (\\)(L::FactorComponent{T,:UP}, B::$T) where T\n            F = Factor(L)\n            ($f)(CHOLMOD_Pt, F, ($f)(CHOLMOD_Lt, F, B))\n        end\n        # Solve various equations for A = L*D*L' and A = P*L*D*L'*P'\n        function (\\)(L::FactorComponent{T,:D}, B::$T) where T\n            ($f)(CHOLMOD_D, Factor(L), B)\n        end\n        function (\\)(L::FactorComponent{T,:LD}, B::$T) where T\n            ($f)(CHOLMOD_LD, Factor(L), B)\n        end\n        function (\\)(L::FactorComponent{T,:DU}, B::$T) where T\n            ($f)(CHOLMOD_DLt, Factor(L), B)\n        end\n        function (\\)(L::FactorComponent{T,:PtLD}, B::$T) where T\n            F = Factor(L)\n            ($f)(CHOLMOD_LD, F, ($f)(CHOLMOD_P, F, B))\n        end\n        function (\\)(L::FactorComponent{T,:DUP}, B::$T) where T\n            F = Factor(L)\n            ($f)(CHOLMOD_Pt, F, ($f)(CHOLMOD_DLt, F, B))\n        end\n    end\nend\n\nSparseVecOrMat{Tv,Ti} = Union{SparseVector{Tv,Ti}, SparseMatrixCSC{Tv,Ti}}\n\nfunction (\\)(L::FactorComponent, b::Vector)\n    reshape(Matrix(L\\Dense(b)), length(b))\nend\nfunction (\\)(L::FactorComponent, B::Matrix)\n    Matrix(L\\Dense(B))\nend\nfunction (\\)(L::FactorComponent, B::SparseVecOrMat)\n    sparse(L\\Sparse(B,0))\nend\n\n\\(adjL::Adjoint{<:Any,<:FactorComponent}, B::Union{VecOrMat,SparseVecOrMat}) = (L = adjL.parent; adjoint(L)\\B)\n\n(\\)(L::Factor{T}, B::Dense{T}) where {T<:VTypes} = solve(CHOLMOD_A, L, B)\n# Explicit typevars are necessary to avoid ambiguities with defs in linalg/factorizations.jl\n# Likewise the two following explicit Vector and Matrix defs (rather than a single VecOrMat)\n(\\)(L::Factor{T}, B::Vector{Complex{T}}) where {T<:Float64} = complex.(L\\real(B), L\\imag(B))\n(\\)(L::Factor{T}, B::Matrix{Complex{T}}) where {T<:Float64} = complex.(L\\real(B), L\\imag(B))\n(\\)(L::Factor{T}, b::StridedVector) where {T<:VTypes} = Vector(L\\Dense{T}(b))\n(\\)(L::Factor{T}, B::StridedMatrix) where {T<:VTypes} = Matrix(L\\Dense{T}(B))\n(\\)(L::Factor, B::Sparse) = spsolve(CHOLMOD_A, L, B)\n# When right hand side is sparse, we have to ensure that the rhs is not marked as symmetric.\n(\\)(L::Factor, B::SparseVecOrMat) = sparse(spsolve(CHOLMOD_A, L, Sparse(B, 0)))\n\n\\(adjL::Adjoint{<:Any,<:Factor}, B::Dense) = (L = adjL.parent; solve(CHOLMOD_A, L, B))\n\\(adjL::Adjoint{<:Any,<:Factor}, B::VecOrMat) = (L = adjL.parent; Matrix(solve(CHOLMOD_A, L, Dense(B))))\n\\(adjL::Adjoint{<:Any,<:Factor}, B::Sparse) = (L = adjL.parent; spsolve(CHOLMOD_A, L, B))\n\\(adjL::Adjoint{<:Any,<:Factor}, B::SparseVecOrMat) = (L = adjL.parent; \\(adjoint(L), Sparse(B)))\n\nconst RealHermSymComplexHermF64SSL = Union{\n    Symmetric{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}},\n    Hermitian{Float64,SparseMatrixCSC{Float64,SuiteSparse_long}},\n    Hermitian{Complex{Float64},SparseMatrixCSC{Complex{Float64},SuiteSparse_long}}}\nfunction \\(A::RealHermSymComplexHermF64SSL, B::StridedVecOrMat)\n    F = cholesky(A; check = false)\n    if issuccess(F)\n        return \\(F, B)\n    else\n        ldlt!(F, A; check = false)\n        if issuccess(F)\n            return \\(F, B)\n        else\n            return \\(lu(SparseMatrixCSC{eltype(A), SuiteSparse_long}(A)), B)\n        end\n    end\nend\nfunction \\(adjA::Adjoint{<:Any,<:RealHermSymComplexHermF64SSL}, B::StridedVecOrMat)\n    A = adjA.parent\n    F = cholesky(A; check = false)\n    if issuccess(F)\n        return \\(adjoint(F), B)\n    else\n        ldlt!(F, A; check = false)\n        if issuccess(F)\n            return \\(adjoint(F), B)\n        else\n            return \\(adjoint(lu(SparseMatrixCSC{eltype(A), SuiteSparse_long}(A))), B)\n        end\n    end\nend\n\n## Other convenience methods\nfunction diag(F::Factor{Tv}) where Tv\n    f = unsafe_load(pointer(F))\n    fsuper = f.super\n    fpi = f.pi\n    res = Base.zeros(Tv, Int(f.n))\n    xv  = f.x\n    if f.is_super!=0\n        px = f.px\n        pos = 1\n        for i in 1:f.nsuper\n            base = unsafe_load(px, i) + 1\n            res[pos] = unsafe_load(xv, base)\n            pos += 1\n            for j in 1:unsafe_load(fsuper, i + 1) - unsafe_load(fsuper, i) - 1\n                res[pos] = unsafe_load(xv, base + j*(unsafe_load(fpi, i + 1) -\n                    unsafe_load(fpi, i) + 1))\n                pos += 1\n            end\n        end\n    else\n        c0 = f.p\n        r0 = f.i\n        xv = f.x\n        for j in 1:f.n\n            jj = unsafe_load(c0, j) + 1\n            @assert(unsafe_load(r0, jj) == j - 1)\n            res[j] = unsafe_load(xv, jj)\n        end\n    end\n    res\nend\n\nfunction logdet(F::Factor{Tv}) where Tv<:VTypes\n    f = unsafe_load(pointer(F))\n    res = zero(Tv)\n    for d in diag(F); res += log(abs(d)) end\n    f.is_ll != 0 ? 2res : res\nend\n\ndet(L::Factor) = exp(logdet(L))\n\nfunction issuccess(F::Factor)\n    s = unsafe_load(pointer(F))\n    return s.minor == size(F, 1)\nend\n\nfunction isposdef(F::Factor)\n    if issuccess(F)\n        s = unsafe_load(pointer(F))\n        if s.is_ll == 1\n            return true\n        else\n            # try conversion to LLt\n            change_factor!(eltype(F), true, s.is_super, true, s.is_monotonic, F)\n            b = issuccess(F)\n            # convert back\n            change_factor!(eltype(F), false, s.is_super, true, s.is_monotonic, F)\n            return b\n        end\n    else\n        return false\n    end\nend\n\nfunction ishermitian(A::Sparse{Float64})\n    s = unsafe_load(pointer(A))\n    if s.stype != 0\n        return true\n    else\n        i = symmetry(A, 1)[1]\n        if i < 0\n            throw(CHOLMODException(\"negative value returned from CHOLMOD's symmetry function. This\n                is either because the indices are not sorted or because of a memory error\"))\n        end\n        return i == MM_SYMMETRIC || i == MM_SYMMETRIC_POSDIAG\n    end\nend\nfunction ishermitian(A::Sparse{Complex{Float64}})\n    s = unsafe_load(pointer(A))\n    if s.stype != 0\n        return true\n    else\n        i = symmetry(A, 1)[1]\n        if i < 0\n            throw(CHOLMODException(\"negative value returned from CHOLMOD's symmetry function. This\n                is either because the indices are not sorted or because of a memory error\"))\n        end\n        return i == MM_HERMITIAN || i == MM_HERMITIAN_POSDIAG\n    end\nend\n\n(*)(A::Symmetric{Float64,SparseMatrixCSC{Float64,Ti}},\n    B::SparseVecOrMat{Float64,Ti}) where {Ti} = sparse(Sparse(A)*Sparse(B))\n(*)(A::Hermitian{Complex{Float64},SparseMatrixCSC{Complex{Float64},Ti}},\n    B::SparseVecOrMat{Complex{Float64},Ti}) where {Ti} = sparse(Sparse(A)*Sparse(B))\n(*)(A::Hermitian{Float64,SparseMatrixCSC{Float64,Ti}},\n    B::SparseVecOrMat{Float64,Ti}) where {Ti} = sparse(Sparse(A)*Sparse(B))\n\n(*)(A::SparseVecOrMat{Float64,Ti},\n    B::Symmetric{Float64,SparseMatrixCSC{Float64,Ti}}) where {Ti} = sparse(Sparse(A)*Sparse(B))\n(*)(A::SparseVecOrMat{Complex{Float64},Ti},\n    B::Hermitian{Complex{Float64},SparseMatrixCSC{Complex{Float64},Ti}}) where {Ti} = sparse(Sparse(A)*Sparse(B))\n(*)(A::SparseVecOrMat{Float64,Ti},\n    B::Hermitian{Float64,SparseMatrixCSC{Float64,Ti}}) where {Ti} = sparse(Sparse(A)*Sparse(B))\n\nend #module\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/test/ccall.jl": "# This file is a part of Julia. License is MIT: https://julialang.org/license\n\nimport Base.copy, Base.==\nusing Random\nusing InteractiveUtils: code_llvm\n\nimport Libdl\n\nconst libccalltest = \"libccalltest\"\n\nconst verbose = false\nccall((:set_verbose, libccalltest), Cvoid, (Int32,), verbose)\n\n\n# Test for proper argument register truncation\nccall_test_func(x) = ccall((:testUcharX, libccalltest), Int32, (UInt8,), x % UInt8)\n@test ccall_test_func(3) == 1\n@test ccall_test_func(259) == 1\n\n\n# Test for proper round-trip of Ref{T} type\nfunction gen_ccall_echo(x, T, U, ret=nothing)\n    # Construct a noninline function to do all the work, this is necessary\n    # to make sure object x is still valid (rooted as argument)\n    # when loading the pointer.\n    # This works as long as we still keep the argument\n    # rooted but might fail if we are smarter about eliminating dead root.\n\n    # `eval` in global scope to make sure the function is not a closure\n    func_ex = :(ccall((:test_echo_p, libccalltest), $T, ($U,), x))\n    # It is not allowed to allocate after the ccall returns\n    # and before calling `ret`.\n    if ret !== nothing\n        func_ex = :($ret($func_ex))\n    end\n    @gensym func_name\n    @eval @noinline $func_name(x) = $func_ex\n    :($func_name($(esc(x))))\nend\n\nmacro ccall_echo_func(x, T, U)\n    gen_ccall_echo(x, T, U)\nend\nmacro ccall_echo_load(x, T, U)\n    gen_ccall_echo(x, T, U, :unsafe_load)\nend\nmacro ccall_echo_objref(x, T, U)\n    gen_ccall_echo(x, :(Ptr{$T}), U, :unsafe_pointer_to_objref)\nend\n\nmutable struct IntLike\n    x::Int\nend\n@test @ccall_echo_load(132, Ptr{Int}, Ref{Int}) === 132\n@test @ccall_echo_load(Ref(921), Ptr{Int}, Ref{Int}) === 921\n@test @ccall_echo_load(IntLike(993), Ptr{Int}, Ref{IntLike}) === 993\n@test @ccall_echo_load(IntLike(881), Ptr{IntLike}, Ref{IntLike}).x === 881\n@test @ccall_echo_func(532, Int, Int) === 532\nif Sys.WORD_SIZE == 64\n    # this test is valid only for x86_64 and win64\n    @test @ccall_echo_func(164, IntLike, Int).x === 164\nend\n@test @ccall_echo_func(IntLike(828), Int, IntLike) === 828\n@test @ccall_echo_func(913, Any, Any) === 913\n@test @ccall_echo_objref(553, Ptr{Any}, Any) === 553\n@test @ccall_echo_func(124, Ref{Int}, Any) === 124\n@test @ccall_echo_load(422, Ptr{Any}, Ref{Any}) === 422\n@test @ccall_echo_load([383], Ptr{Int}, Ref{Int}) === 383\n@test @ccall_echo_load(Ref([144,172],2), Ptr{Int}, Ref{Int}) === 172\n# @test @ccall_echo_load(Ref([8],1,1), Ptr{Int}, Ref{Int}) === 8\n\n\n## Tests for passing and returning structs\n\nlet a, ci_ary, x\n    a = 20 + 51im\n\n    x = ccall((:ctest, libccalltest), Complex{Int}, (Complex{Int},), a)\n\n    @test x == a + 1 - 2im\n\n    ci_ary = [a] # Make sure the array is alive during unsafe_load\n    x = unsafe_load(ccall((:cptest, libccalltest), Ptr{Complex{Int}},\n                          (Ptr{Complex{Int}},), ci_ary))\n\n    @test x == a + 1 - 2im\n    @test a == 20 + 51im\n\n    x = ccall((:cptest_static, libccalltest), Ptr{Complex{Int}}, (Ref{Complex{Int}},), a)\n    @test unsafe_load(x) == a\n    Libc.free(convert(Ptr{Cvoid}, x))\nend\n\nlet a, b, x\n    a = 2.84 + 5.2im\n\n    x = ccall((:cgtest, libccalltest), ComplexF64, (ComplexF64,), a)\n\n    @test x == a + 1 - 2im\n\n    b = [a] # Make sure the array is alive during unsafe_load\n    x = unsafe_load(ccall((:cgptest, libccalltest), Ptr{ComplexF64}, (Ptr{ComplexF64},), b))\n\n    @test x == a + 1 - 2im\n    @test a == 2.84 + 5.2im\nend\n\nlet a, b, x\n    a = 3.34f0 + 53.2f0im\n\n    x = ccall((:cftest, libccalltest), ComplexF32, (ComplexF32,), a)\n\n    @test x == a + 1 - 2im\n\n    b = [a] # Make sure the array is alive during unsafe_load\n    x = unsafe_load(ccall((:cfptest, libccalltest), Ptr{ComplexF32}, (Ptr{ComplexF32},), b))\n\n    @test x == a + 1 - 2im\n    @test a == 3.34f0 + 53.2f0im\nend\n\n\n## Tests for native Julia data types\n\nlet a\n    a = 2.84 + 5.2im\n\n    @test_throws MethodError ccall((:cptest, libccalltest), Ptr{Complex{Int}}, (Ptr{Complex{Int}},), a)\nend\n\n\n## Tests for various sized data types (ByVal)\n\nmutable struct Struct1\n    x::Float32\n    y::Float64\nend\nstruct Struct1I\n    x::Float32\n    y::Float64\nend\ncopy(a::Struct1) = Struct1(a.x, a.y)\ncopy(a::Struct1I) = a\n\nfunction test_struct1(::Type{Struct}) where {Struct}\n    a = Struct(352.39422f23, 19.287577)\n    b = Float32(123.456)\n\n    a2 = copy(a)\n    if Struct === Struct1\n        x = ccall((:test_1, libccalltest), Struct1, (Struct1, Float32), a2, b)\n    else\n        x = ccall((:test_1, libccalltest), Struct1I, (Struct1I, Float32), a2, b)\n    end\n\n    @test a2.x == a.x && a2.y == a.y\n    @test !(a2 === x)\n\n    @test x.x \u2248 a.x + 1*b\n    @test x.y \u2248 a.y - 2*b\nend\ntest_struct1(Struct1)\ntest_struct1(Struct1I)\n\nlet a, b, x\n    a = Struct1(352.39422f23, 19.287577)\n    b = Float32(123.456)\n    a2 = copy(a)\n\n    x = ccall((:test_1long_a, libccalltest), Struct1, (Int, Int, Int, Struct1, Float32), 2, 3, 4, a2, b)\n    @test a2.x == a.x && a2.y == a.y\n    @test !(a2 === x)\n    @test x.x \u2248 a.x + b + 9\n    @test x.y \u2248 a.y - 2*b\n\n    x = ccall((:test_1long_b, libccalltest), Struct1, (Int, Float64, Int, Struct1, Float32), 2, 3, 4, a2, b)\n    @test a2.x == a.x && a2.y == a.y\n    @test !(a2 === x)\n    @test x.x \u2248 a.x + b + 9\n    @test x.y \u2248 a.y - 2*b\n\n    x = ccall((:test_1long_c, libccalltest), Struct1, (Int, Float64, Int, Int, Struct1, Float32), 2, 3, 4, 5, a2, b)\n    @test a2.x == a.x && a2.y == a.y\n    @test !(a2 === x)\n    @test x.x \u2248 a.x + b + 14\n    @test x.y \u2248 a.y - 2*b\nend\n\nlet a, b, x, y\n    a = Complex{Int32}(Int32(10),Int32(31))\n    b = Int32(42)\n\n    x = ccall((:test_2a, libccalltest), Complex{Int32}, (Complex{Int32}, Int32), a, b)\n    y = ccall((:test_2b, libccalltest), Complex{Int32}, (Complex{Int32},Int32), a, b)\n\n    @test a == Complex{Int32}(Int32(10),Int32(31))\n\n    @test x == y\n    @test x == a + b*1 - b*2im\nend\n\nlet a, b, x, y, z\n    a = Complex{Int64}(Int64(20),Int64(51))\n    b = Int64(42)\n\n    x = ccall((:test_3a, libccalltest), Complex{Int64}, (Complex{Int64}, Int64), a, b)\n    y = ccall((:test_3b, libccalltest), Complex{Int64}, (Complex{Int64}, Int64), a, b)\n    z = ccall((:test_128, libccalltest), Complex{Int64}, (Complex{Int64}, Int64), a, b)\n\n    @test a == Complex{Int64}(Int64(20),Int64(51))\n\n    @test x == y\n    @test x == a + b*1 - b*2im\n\n    @test z == a + 1*b\nend\n\nmutable struct Struct4\n    x::Int32\n    y::Int32\n    z::Int32\nend\nstruct Struct4I\n    x::Int32\n    y::Int32\n    z::Int32\nend\n\nfunction test_struct4(::Type{Struct}) where {Struct}\n    a = Struct(-512275808,882558299,-2133022131)\n    b = Int32(42)\n\n    if Struct === Struct4\n        x = ccall((:test_4, libccalltest), Struct4, (Struct4, Int32), a, b)\n    else\n        x = ccall((:test_4, libccalltest), Struct4I, (Struct4I, Int32), a, b)\n    end\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\nend\ntest_struct4(Struct4)\ntest_struct4(Struct4I)\n\nmutable struct Struct5\n    x::Int32\n    y::Int32\n    z::Int32\n    a::Int32\nend\nstruct Struct5I\n    x::Int32\n    y::Int32\n    z::Int32\n    a::Int32\nend\n\nfunction test_struct5(::Type{Struct}) where {Struct}\n    a = Struct(1771319039, 406394736, -1269509787, -745020976)\n    b = Int32(42)\n\n    if Struct === Struct5\n        x = ccall((:test_5, libccalltest), Struct5, (Struct5, Int32), a, b)\n    else\n        x = ccall((:test_5, libccalltest), Struct5I, (Struct5I, Int32), a, b)\n    end\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\n    @test x.a == a.a-b*4\nend\ntest_struct5(Struct5)\ntest_struct5(Struct5I)\n\nmutable struct Struct6\n    x::Int64\n    y::Int64\n    z::Int64\nend\nstruct Struct6I\n    x::Int64\n    y::Int64\n    z::Int64\nend\n\nfunction test_struct6(::Type{Struct}) where {Struct}\n    a = Struct(-654017936452753226, -5573248801240918230, -983717165097205098)\n    b = Int64(42)\n\n    if Struct === Struct6\n        x = ccall((:test_6, libccalltest), Struct6, (Struct6, Int64), a, b)\n    else\n        x = ccall((:test_6, libccalltest), Struct6I, (Struct6I, Int64), a, b)\n    end\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\nend\ntest_struct6(Struct6)\ntest_struct6(Struct6I)\n\nmutable struct Struct7\n    x::Int64\n    y::Cchar\nend\nstruct Struct7I\n    x::Int64\n    y::Cchar\nend\n\nfunction test_struct7(::Type{Struct}) where {Struct}\n    a = Struct(-384082741977533896, 'h')\n    b = Int8(42)\n\n    if Struct === Struct7\n        x = ccall((:test_7, libccalltest), Struct7, (Struct7, Int8), a, b)\n    else\n        x = ccall((:test_7, libccalltest), Struct7I, (Struct7I, Int8), a, b)\n    end\n\n    @test x.x == a.x+Int(b)*1\n    @test x.y == a.y-Int(b)*2\nend\ntest_struct7(Struct7)\ntest_struct7(Struct7I)\n\nmutable struct Struct8\n    x::Int32\n    y::Cchar\nend\nstruct Struct8I\n    x::Int32\n    y::Cchar\nend\n\nfunction test_struct8(::Type{Struct}) where {Struct}\n    a = Struct(-384082896, 'h')\n    b = Int8(42)\n\n    if Struct === Struct8\n        r8 = ccall((:test_8, libccalltest), Struct8, (Struct8, Int8), a, b)\n    else\n        r8 = ccall((:test_8, libccalltest), Struct8I, (Struct8I, Int8), a, b)\n    end\n\n    @test r8.x == a.x+b*1\n    @test r8.y == a.y-b*2\nend\ntest_struct8(Struct8)\ntest_struct8(Struct8I)\n\nmutable struct Struct9\n    x::Int32\n    y::Int16\nend\nstruct Struct9I\n    x::Int32\n    y::Int16\nend\n\nfunction test_struct9(::Type{Struct}) where {Struct}\n    a = Struct(-394092996, -3840)\n    b = Int16(42)\n\n    if Struct === Struct9\n        x = ccall((:test_9, libccalltest), Struct9, (Struct9, Int16), a, b)\n    else\n        x = ccall((:test_9, libccalltest), Struct9I, (Struct9I, Int16), a, b)\n    end\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\nend\ntest_struct9(Struct9)\ntest_struct9(Struct9I)\n\nmutable struct Struct10\n    x::Cchar\n    y::Cchar\n    z::Cchar\n    a::Cchar\nend\nstruct Struct10I\n    x::Cchar\n    y::Cchar\n    z::Cchar\n    a::Cchar\nend\n\nfunction test_struct10(::Type{Struct}) where {Struct}\n    a = Struct('0', '1', '2', '3')\n    b = Int8(2)\n\n    if Struct === Struct10\n        x = ccall((:test_10, libccalltest), Struct10, (Struct10, Int8), a, b)\n    else\n        x = ccall((:test_10, libccalltest), Struct10I, (Struct10I, Int8), a, b)\n    end\n\n    @test x.x == a.x+b*1\n    @test x.y == a.y-b*2\n    @test x.z == a.z+b*3\n    @test x.a == a.a-b*4\nend\ntest_struct10(Struct10)\ntest_struct10(Struct10I)\n\nmutable struct Struct11\n    x::ComplexF32\nend\nstruct Struct11I\n    x::ComplexF32\nend\n\nfunction test_struct11(::Type{Struct}) where {Struct}\n    a = Struct(0.8877077f0 + 0.4591081f0im)\n    b = Float32(42)\n\n    if Struct === Struct11\n        x = ccall((:test_11, libccalltest), Struct11, (Struct11, Float32), a, b)\n    else\n        x = ccall((:test_11, libccalltest), Struct11I, (Struct11I, Float32), a, b)\n    end\n\n    @test x.x \u2248 a.x + b*1 - b*2im\nend\ntest_struct11(Struct11)\ntest_struct11(Struct11I)\n\nmutable struct Struct12\n    x::ComplexF32\n    y::ComplexF32\nend\nstruct Struct12I\n    x::ComplexF32\n    y::ComplexF32\nend\n\nfunction test_struct12(::Type{Struct}) where {Struct}\n    a = Struct(0.8877077f5 + 0.4591081f2im, 0.0004842868f0 - 6982.3265f3im)\n    b = Float32(42)\n\n    if Struct === Struct12\n        x = ccall((:test_12, libccalltest), Struct12, (Struct12, Float32), a, b)\n    else\n        x = ccall((:test_12, libccalltest), Struct12I, (Struct12I, Float32), a, b)\n    end\n\n    @test x.x \u2248 a.x + b*1 - b*2im\n    @test x.y \u2248 a.y + b*3 - b*4im\nend\ntest_struct12(Struct12)\ntest_struct12(Struct12I)\n\nmutable struct Struct13\n    x::ComplexF64\nend\nstruct Struct13I\n    x::ComplexF64\nend\n\nfunction test_struct13(::Type{Struct}) where {Struct}\n    a = Struct(42968.97560380495 - 803.0576845153616im)\n    b = Float64(42)\n\n    if Struct === Struct13\n        x = ccall((:test_13, libccalltest), Struct13, (Struct13, Float64), a, b)\n    else\n        x = ccall((:test_13, libccalltest), Struct13I, (Struct13I, Float64), a, b)\n    end\n\n    @test x.x \u2248 a.x + b*1 - b*2im\nend\ntest_struct13(Struct13)\ntest_struct13(Struct13I)\n\nmutable struct Struct14\n    x::Float32\n    y::Float32\nend\nstruct Struct14I\n    x::Float32\n    y::Float32\nend\n\nfunction test_struct14(::Type{Struct}) where {Struct}\n    a = Struct(0.024138331f0, 0.89759064f32)\n    b = Float32(42)\n\n    if Struct === Struct14\n        x = ccall((:test_14, libccalltest), Struct14, (Struct14, Float32), a, b)\n    else\n        x = ccall((:test_14, libccalltest), Struct14I, (Struct14I, Float32), a, b)\n    end\n\n    @test x.x \u2248 a.x + b*1\n    @test x.y \u2248 a.y - b*2\nend\ntest_struct14(Struct14)\ntest_struct14(Struct14I)\n\nmutable struct Struct15\n    x::Float64\n    y::Float64\nend\nstruct Struct15I\n    x::Float64\n    y::Float64\nend\n\nfunction test_struct15(::Type{Struct}) where {Struct}\n    a = Struct(4.180997967273657, -0.404218594294923)\n    b = Float64(42)\n\n    if Struct === Struct15\n        x = ccall((:test_15, libccalltest), Struct15, (Struct15, Float64), a, b)\n    else\n        x = ccall((:test_15, libccalltest), Struct15I, (Struct15I, Float64), a, b)\n    end\n\n    @test x.x \u2248 a.x + b*1\n    @test x.y \u2248 a.y - b*2\nend\ntest_struct15(Struct15)\ntest_struct15(Struct15I)\n\nmutable struct Struct16\n    x::Float32\n    y::Float32\n    z::Float32\n    a::Float64\n    b::Float64\n    c::Float64\nend\nstruct Struct16I\n    x::Float32\n    y::Float32\n    z::Float32\n    a::Float64\n    b::Float64\n    c::Float64\nend\n\nfunction test_struct16(::Type{Struct}) where {Struct}\n    a = Struct(0.1604656f0, 0.6297606f0, 0.83588994f0,\n               0.6460273620993535, 0.9472692581106656, 0.47328535437352093)\n    b = Float32(42)\n\n    if Struct === Struct16\n        x = ccall((:test_16, libccalltest), Struct16, (Struct16, Float32), a, b)\n    else\n        x = ccall((:test_16, libccalltest), Struct16I, (Struct16I, Float32), a, b)\n    end\n\n    @test x.x \u2248 a.x + b*1\n    @test x.y \u2248 a.y - b*2\n    @test x.z \u2248 a.z + b*3\n    @test x.a \u2248 a.a - b*4\n    @test x.b \u2248 a.b + b*5\n    @test x.c \u2248 a.c - b*6\nend\ntest_struct16(Struct16)\ntest_struct16(Struct16I)\n\nmutable struct Struct17\n    a::Int8\n    b::Int16\nend\nstruct Struct17I\n    a::Int8\n    b::Int16\nend\n\nfunction test_struct17(::Type{Struct}) where {Struct}\n    a = Struct(2, 10)\n    b = Int8(2)\n\n    if Struct === Struct17\n        x = ccall((:test_17, libccalltest), Struct17, (Struct17, Int8), a, b)\n    else\n        x = ccall((:test_17, libccalltest), Struct17I, (Struct17I, Int8), a, b)\n    end\n\n    @test x.a == a.a + b * 1\n    @test x.b == a.b - b * 2\nend\ntest_struct17(Struct17)\ntest_struct17(Struct17I)\n\nmutable struct Struct18\n    a::Int8\n    b::Int8\n    c::Int8\nend\nstruct Struct18I\n    a::Int8\n    b::Int8\n    c::Int8\nend\n\nfunction test_struct18(::Type{Struct}) where {Struct}\n    a = Struct(2, 10, -3)\n    b = Int8(2)\n\n    if Struct === Struct18\n        x = ccall((:test_18, libccalltest), Struct18, (Struct18, Int8), a, b)\n    else\n        x = ccall((:test_18, libccalltest), Struct18I, (Struct18I, Int8), a, b)\n    end\n\n    @test x.a == a.a + b * 1\n    @test x.b == a.b - b * 2\n    @test x.c == a.c + b * 3\nend\ntest_struct18(Struct18)\ntest_struct18(Struct18I)\n\nlet a, b, x\n    a = Int128(0x7f00123456789abc)<<64 + typemax(UInt64)\n    b = Int64(1)\n\n    x = ccall((:test_128, libccalltest), Int128, (Int128, Int64), a, b)\n\n    @test x == a + b*1\n    @test a == Int128(0x7f00123456789abc)<<64 + typemax(UInt64)\nend\n\nmutable struct Struct_Big\n    x::Int\n    y::Int\n    z::Int8\nend\nstruct Struct_BigI\n    x::Int\n    y::Int\n    z::Int8\nend\ncopy(a::Struct_Big) = Struct_Big(a.x, a.y, a.z)\ncopy(a::Struct_BigI) = a\n\nfunction test_struct_big(::Type{Struct}) where {Struct}\n    a = Struct(424,-5,Int8('Z'))\n    a2 = copy(a)\n\n    if Struct == Struct_Big\n        x = ccall((:test_big, libccalltest), Struct_Big, (Struct_Big,), a2)\n    else\n        x = ccall((:test_big, libccalltest), Struct_BigI, (Struct_BigI,), a2)\n    end\n\n    @test a2.x == a.x && a2.y == a.y && a2.z == a.z\n    @test x.x == a.x + 1\n    @test x.y == a.y - 2\n    @test x.z == a.z - Int('A')\nend\ntest_struct_big(Struct_Big)\ntest_struct_big(Struct_BigI)\n\nlet a, a2, x\n    a = Struct_Big(424,-5,Int8('Z'))\n    a2 = copy(a)\n    x = ccall((:test_big_long, libccalltest), Struct_Big, (Int, Int, Int, Struct_Big,), 2, 3, 4, a2)\n    @test a2.x == a.x && a2.y == a.y && a2.z == a.z\n    @test x.x == a.x + 10\n    @test x.y == a.y - 2\n    @test x.z == a.z - Int('A')\nend\n\nconst Struct_huge1a = NTuple{8, Int64}\nconst Struct_huge1b = NTuple{9, Int64}\nconst Struct_huge2a = NTuple{8, Cdouble}\nconst Struct_huge2b = NTuple{9, Cdouble}\nmutable struct Struct_huge3a\n    cf::NTuple{3, Complex{Cfloat}}\n    f7::Cfloat\n    f8::Cfloat\nend\nmutable struct Struct_huge3b\n    cf::NTuple{7, Complex{Cfloat}}\n    r8a::Cfloat\n    r8b::Cfloat\nend\nmutable struct Struct_huge3c\n    cf::NTuple{7, Complex{Cfloat}}\n    r8a::Cfloat\n    r8b::Cfloat\n    r9::Cfloat\nend\nmutable struct Struct_huge4a\n    r12::Complex{Cdouble}\n    r34::Complex{Cdouble}\n    r5::Complex{Cfloat}\n    r67::Complex{Cdouble}\n    r8::Cdouble\nend\nmutable struct Struct_huge4b\n    r12::Complex{Cdouble}\n    r34::Complex{Cdouble}\n    r5::Complex{Cfloat}\n    r67::Complex{Cdouble}\n    r89::Complex{Cdouble}\nend\nconst Struct_huge5a = NTuple{8, Complex{Cint}}\nconst Struct_huge5b = NTuple{9, Complex{Cint}}\n\nfunction verify_huge(init, a, b)\n    @test typeof(init) === typeof(a) === typeof(b)\n    verbose && @show (a, b)\n    # make sure a was unmodified\n    for i = 1:nfields(a)\n        @test getfield(init, i) === getfield(a, i)\n    end\n    # make sure b was modified as expected\n    a1, b1 = getfield(a, 1), getfield(b, 1)\n    while isa(a1, Tuple)\n        @test a1[2:end] === b1[2:end]\n        a1 = a1[1]\n        b1 = b1[1]\n    end\n    if isa(a1, VecElement)\n        a1 = a1.value\n        b1 = b1.value\n    end\n    @test oftype(a1, a1 * 39) === b1\n    for i = 2:nfields(a)\n        @test getfield(a, i) === getfield(b, i)\n    end\nend\nmacro test_huge(i, b, init)\n    f = QuoteNode(Symbol(\"test_huge\", i, b))\n    ty = Symbol(\"Struct_huge\", i, b)\n    return quote\n        let a = $ty($(esc(init))...), f\n            f(b) = ccall(($f, libccalltest), $ty, (Cchar, $ty, Cchar), '0' + $i, a, $b[1])\n            #code_llvm(f, typeof((a,)))\n            verify_huge($ty($(esc(init))...), a, f(a))\n        end\n    end\nend\n@test_huge 1 'a' ((1, 2, 3, 4, 5, 6, 7, 8),)\n@test_huge 1 'b' ((1, 2, 3, 4, 5, 6, 7, 8, 9),)\n@test_huge 2 'a' ((1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0),)\n@test_huge 2 'b' ((1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0),)\n@test_huge 3 'a' ((1.0 + 2.0im, 3.0 + 4.0im, 5.0 + 6.0im), 7.0, 8.0)\n@test_huge 3 'b' ((1.0 + 2.0im, 3.0 + 4.0im, 5.0 + 6.0im, 7.0 + 8.0im, 9.0 + 10.0im, 11.0 + 12.0im, 13.0 + 14.0im), 7.0, 8.0)\n@test_huge 3 'c' ((1.0 + 2.0im, 3.0 + 4.0im, 5.0 + 6.0im, 7.0 + 8.0im, 9.0 + 10.0im, 11.0 + 12.0im, 13.0 + 14.0im), 7.0, 8.0, 9.0)\n@test_huge 4 'a' (1.0 + 2.0im, 3.0 + 4.0im, 5.0f0 + 6.0f0im, 7.0 + 8.0im, 9.0)\n@test_huge 4 'b' (1.0 + 2.0im, 3.0 + 4.0im, 5.0f0 + 6.0f0im, 7.0 + 8.0im, 9.0 + 10.0im)\n@test_huge 5 'a' ((1 + 2im, 3 + 4im, 5 + 6im, 7 + 8im, 9 + 10im, 11 + 12im, 13 + 14im, 15 + 16im),)\n@test_huge 5 'b' ((1 + 2im, 3 + 4im, 5 + 6im, 7 + 8im, 9 + 10im, 11 + 12im, 13 + 14im, 15 + 16im, 17 + 17im),)\n\n## cfunction roundtrip\n\nverbose && Libc.flush_cstdio()\nverbose && println(\"Testing cfunction closures: \")\n\n# helper Type for testing that constructors work\n# with cfucntion and that object identity is preserved\nmutable struct IdentityTestKV{K, V}\n    (T::Type{<:IdentityTestKV})(S) = (@test T === S; T)\nend\n\n@noinline function testclosure(f, a::T, permanent::Bool=false, tt::Type{S}=Any) where {T, S}\n    @nospecialize(f, a, tt)\n    # generic API 1\n    cf = @cfunction $f Ref{T} (Ref{T},)\n    GC.gc()\n    @test cf.ptr != C_NULL\n    @test cf.f === f\n    @test (cf._1 == C_NULL) == permanent\n    @test (cf._2 == C_NULL) == permanent\n    @assert cf === Base.cconvert(Ptr{Cvoid}, cf)\n    GC.@preserve cf begin\n        fptr = Base.unsafe_convert(Ptr{Cvoid}, cf)\n        b = ccall(fptr, Ref{T}, (Ref{T},), a)\n    end\n    # generic API 2\n    cf2 = @cfunction $f Any (Ref{S},)\n    GC.gc()\n    @test cf2.ptr != C_NULL\n    @test cf2.f === f\n    @test (cf2._1 == C_NULL) == permanent\n    @test (cf2._2 == C_NULL) == permanent\n    @assert cf2 === Base.cconvert(Ptr{Cvoid}, cf2)\n    GC.@preserve cf2 begin\n        fptr = Base.unsafe_convert(Ptr{Cvoid}, cf2)\n        b = ccall(fptr, Any, (Ref{S},), a)\n    end\n    return b\nend\n\n# We can't (currently) execute some of these signatures (without compile-all),\n# but we can at least look at some of the generated code\nfunction check_code_trampoline(f, t, n::Int)\n    @nospecialize(f, t)\n    @test Base.return_types(f, t) == Any[Any]\n    llvm = sprint(code_llvm, f, t)\n    @test count(x -> true, eachmatch(r\"@jl_get_cfunction_trampoline\\(\", llvm)) == n\nend\ncheck_code_trampoline(testclosure, (Any, Any, Bool, Type), 2)\ncheck_code_trampoline(testclosure, (Any, Int, Bool, Type{Int}), 2)\ncheck_code_trampoline(testclosure, (Any, String, Bool, Type{String}), 2)\ncheck_code_trampoline(testclosure, (typeof(identity), Any, Bool, Type), 2)\ncheck_code_trampoline(testclosure, (typeof(identity), Int, Bool, Type{Int}), 0)\ncheck_code_trampoline(testclosure, (typeof(identity), String, Bool, Type{String}), 0)\n\nfunction g(i)\n    x = -332210 + i\n    y = \"foo\"\n    a(z) = x\n    b(z) = y\n    c(z) = (y = z)\n    IdentityTestVK{V, K} = IdentityTestKV{K, V}\n    @test IdentityTestVK !== IdentityTestKV\n    @test IdentityTestVK == IdentityTestKV\n    for _ = 1:5\n        @test testclosure(a, 23) == -332210 + i\n        @test testclosure(b, \"bar\") == \"foo\"\n        @test testclosure(c, \"bar\") == \"bar\"\n        @test testclosure(b, \"foo\") == \"bar\"\n        @test testclosure(c, \"foo\") == \"foo\"\n        @test testclosure(identity, IdentityTestKV, true) === IdentityTestKV\n        @test testclosure(identity, IdentityTestVK, true) === IdentityTestVK\n        @test testclosure(IdentityTestKV, IdentityTestKV, true) === IdentityTestKV\n        @test testclosure(IdentityTestVK, IdentityTestVK, false) === IdentityTestVK\n    end\nend\ng(1)\ng(2)\ng(3)\n\nverbose && println(\"Testing cfunction roundtrip: \")\n\ncf64 = 2.84+5.2im\ncf32 = 3.34f0+53.2f0im\nci32 = Complex{Int32}(Int32(10), Int32(31))\nci64 = Complex{Int64}(Int64(20), Int64(51))\ns1 = Struct1(352.39422f23, 19.287577)\n==(a::Struct1, b::Struct1) = (a.x == b.x && a.y == b.y)\n\nfor (t, v) in ((Complex{Int32}, :ci32), (Complex{Int64}, :ci64),\n              (ComplexF32, :cf32), (ComplexF64, :cf64), (Struct1, :s1))\n    fname = Symbol(\"foo\", v)\n    fname1 = Symbol(\"foo1\", v)\n    a = copy(@eval $v)\n    verbose && println(t)\n    verbose && println(\"A: \", a)\n    @eval begin\n        global function $fname1(s::$t)\n            verbose && println(\"B: \", s)\n            @test s == $v\n            @test s === $a\n            global c = s\n            return s\n        end\n        global function $fname1(s)\n            @assert false\n        end\n        global function $fname(s::$t)\n            verbose && println(\"B: \", s)\n            @test s == $v\n            if($(t).mutable)\n                @test !(s === $a)\n            end\n            global c = s\n            return s\n        end\n        global function $fname(s)\n            @assert false\n        end\n    end\n    @eval let a = $a, b\n        b = testclosure($fname1, a, true)\n        verbose && println(\"C: \", b)\n        @test b == $v\n        @test b === a\n        @test b === c\n        let cf = @cfunction($fname1, Ref{$t}, (Ref{$t},))\n            b = ccall(cf, Ref{$t}, (Ref{$t},), a)\n        end\n        verbose && println(\"C: \", b)\n        @test b == $v\n        @test b === a\n        @test b === c\n        let cf = @cfunction($fname, $t, ($t,))\n            b = ccall(cf, $t, ($t,), a)\n        end\n        verbose && println(\"C: \",b)\n        @test b == $v\n        if ($(t).mutable)\n            @test !(b === c)\n            @test !(b === a)\n        end\n        let cf = @cfunction($fname1, $t, (Ref{$t},))\n            b = ccall(cf, $t, (Ref{$t},), a)\n        end\n        verbose && println(\"C: \",b)\n        @test b == $v\n        if ($(t).mutable)\n            @test !(b === c)\n            @test !(b === a)\n        end\n        let cf = @cfunction($fname, Ref{$t}, ($t,))\n            b = ccall(cf, Ref{$t}, ($t,), a)\n        end\n        verbose && println(\"C: \",b)\n        @test b == $v\n        @test b === c\n        if ($(t).mutable)\n            @test !(b === a)\n        end\n        let cf = @cfunction($fname, Any, (Ref{$t},))\n            b = ccall(cf, Any, (Ref{$t},), $v)\n        end\n        verbose && println(\"C: \",b)\n        @test b == $v\n        @test b === c\n        if ($(t).mutable)\n            @test !(b === a)\n        end\n        let cf = @cfunction($fname, Any, (Ref{Any},))\n            b = ccall(cf, Any, (Ref{Any},), $v)\n        end\n        @test b == $v\n        @test b === c\n        if ($(t).mutable)\n            @test !(b === a)\n        end\n        let cf = @cfunction($fname, Ref{AbstractString}, (Ref{Any},))\n            @test_throws TypeError ccall(cf, Any, (Ref{Any},), $v)\n        end\n        let cf = @cfunction($fname, AbstractString, (Ref{Any},))\n            @test_throws TypeError ccall(cf, Any, (Ref{Any},), $v)\n        end\n    end\nend\n\n# issue 13031\nfoo13031(x) = Cint(1)\nfoo13031p = @cfunction(foo13031, Cint, (Ref{Tuple{}},))\nccall(foo13031p, Cint, (Ref{Tuple{}},), ())\n\nfoo13031(x,y,z) = z\nfoo13031p = @cfunction(foo13031, Cint, (Ref{Tuple{}}, Ref{Tuple{}}, Cint))\nccall(foo13031p, Cint, (Ref{Tuple{}},Ref{Tuple{}},Cint), (), (), 8)\n\n# issue 17219\nfunction ccall_reassigned_ptr(ptr::Ptr{Cvoid})\n    ptr = Libdl.dlsym(Libdl.dlopen(libccalltest), \"test_echo_p\")\n    ccall(ptr, Any, (Any,), \"foo\")\nend\n@test ccall_reassigned_ptr(C_NULL) == \"foo\"\n\n# @threadcall functionality\nthreadcall_test_func(x) =\n    @threadcall((:testUcharX, libccalltest), Int32, (UInt8,), x % UInt8)\n\n@test threadcall_test_func(3) == 1\n@test threadcall_test_func(259) == 1\n\n# issue 17819\n# NOTE: can't use cfunction or reuse ccalltest Struct methods, as those call into the runtime\n@test @threadcall((:threadcall_args, libccalltest), Cint, (Cint, Cint), 1, 2) == 3\n\nlet n=3\n    tids = Culong[]\n    @sync for i in 1:10^n\n        @async push!(tids, @threadcall(:uv_thread_self, Culong, ()))\n    end\n\n    # The work should not be done on the master thread\n    t0 = ccall(:uv_thread_self, Culong, ())\n    @test length(tids) == 10^n\n    for t in tids\n        @test t != t0\n    end\nend\n\n@test ccall(:jl_getpagesize, Clong, ()) == @threadcall(:jl_getpagesize, Clong, ())\n\n# Pointer finalizer (issue #15408)\nlet A = [1]\n    ccall((:set_c_int, libccalltest), Cvoid, (Cint,), 1)\n    @test ccall((:get_c_int, libccalltest), Cint, ()) == 1\n    finalizer(cglobal((:finalizer_cptr, libccalltest), Cvoid), A)\n    finalize(A)\n    @test ccall((:get_c_int, libccalltest), Cint, ()) == -1\nend\n\n# Pointer finalizer at exit (PR #19911)\nlet result = read(`$(Base.julia_cmd()) --startup-file=no -e \"A = Ref{Cint}(42); finalizer(cglobal((:c_exit_finalizer, \\\"$libccalltest\\\"), Cvoid), A)\"`, String)\n    @test result == \"c_exit_finalizer: 42, 0\"\nend\n\n# SIMD Registers\n\nconst VecReg{N,T} = NTuple{N,VecElement{T}}\nconst V2xF32 = VecReg{2,Float32}\nconst V4xF32 = VecReg{4,Float32}\nconst V2xF64 = VecReg{2,Float64}\nconst V2xI32 = VecReg{2,Int32}\nconst V4xI32 = VecReg{4,Int32}\n\nstruct Struct_AA64_1\n    v1::Int32\n    v2::Int128\nend\nstruct Struct_AA64_2\n    v1::Float16\n    v2::Float64\nend\n\n# This is a homogenious short vector aggregate\nstruct Struct_AA64_3\n    v1::VecReg{8,Int8}\n    v2::VecReg{2,Float32}\nend\n# This is NOT a homogenious short vector aggregate\nstruct Struct_AA64_4\n    v2::VecReg{2,Float32}\n    v1::VecReg{8,Int16}\nend\n\nmutable struct Struct_huge1_ppc64\n    m::Int64\n    v::V4xF32\nend\n\nmutable struct Struct_huge2_ppc64\n    v1::V4xF32\n    v2::V2xI32\nend\n\nmutable struct Struct_huge3_ppc64\n    v1::V4xF32\n    f::NTuple{4,Float32}\nend\n\nmutable struct Struct_huge4_ppc64\n    v1::V2xF32\n    v2::V2xF64\nend\n\nmutable struct Struct_huge5_ppc64\n    v1::NTuple{9,V4xF32}\nend\n\nmutable struct Struct_huge6_ppc64\n    v1::NTuple{8,V4xF32}\n    v2::V4xF32\nend\n\nmutable struct Struct_huge7_ppc64\n    v1::VecReg{3,Int32}\n    v2::VecReg{3,Int32}\nend\n\nmutable struct Struct_huge1_ppc64_hva\n    v1::NTuple{8,V4xF32}\nend\n\nmutable struct Struct_huge2_ppc64_hva\n    v1::NTuple{2,NTuple{2,V4xF32}}\nend\n\nmutable struct Struct_huge3_ppc64_hva\n    vf1::V4xF32\n    vf2::Tuple{NTuple{2,V4xF32}}\nend\n\nmutable struct Struct_huge4_ppc64_hva\n    v1::V4xI32\n    v2::V4xF32\nend\n\nmutable struct Struct_huge5_ppc64_hva\n    v1::V4xI32\n    v2::V2xF64\nend\n\nif Sys.ARCH === :x86_64\n    function test_sse(a1::V4xF32, a2::V4xF32, a3::V4xF32, a4::V4xF32)\n        ccall((:test_m128, libccalltest), V4xF32, (V4xF32, V4xF32, V4xF32, V4xF32), a1, a2, a3, a4)\n    end\n\n    function test_sse(a1::V4xI32, a2::V4xI32, a3::V4xI32, a4::V4xI32)\n        ccall((:test_m128i, libccalltest), V4xI32, (V4xI32, V4xI32, V4xI32, V4xI32), a1, a2, a3, a4)\n    end\n\n    foo_ams(a1, a2, a3, a4) = VecReg(ntuple(i -> VecElement(a1[i].value + a2[i].value * (a3[i].value - a4[i].value)), 4))\n\n    for s in [Float32, Int32]\n        T = NTuple{4, VecElement{s}}\n        @eval function rt_sse(a1::$T, a2::$T, a3::$T, a4::$T)\n            return ccall(\n                @cfunction(foo_ams, $T, ($T, $T, $T, $T)),\n                $T, ($T, $T, $T, $T),\n                     a1, a2, a3, a4)\n        end\n\n        a1 = VecReg(ntuple(i -> VecElement(s(1i)), 4))\n        a2 = VecReg(ntuple(i -> VecElement(s(2i)), 4))\n        a3 = VecReg(ntuple(i -> VecElement(s(3i)), 4))\n        a4 = VecReg(ntuple(i -> VecElement(s(4i)), 4))\n        r = VecReg(ntuple(i -> VecElement(s(1i + 2i * (3i - 4i))), 4))\n        @test test_sse(a1, a2, a3, a4) == r\n\n        # cfunction round-trip\n        @test rt_sse(a1, a2, a3, a4) == r\n    end\n\nelseif Sys.ARCH === :aarch64\n    for v1 in 1:99:1000, v2 in -100:-1999:-20000\n        @test ccall((:test_aa64_i128_1, libccalltest), Int128,\n                    (Int64, Int128), v1, v2) == v1 * 2 - v2\n    end\n    for v1 in 1:4, v2 in -4:-1, v3_1 in 3:5, v3_2 in 7:9\n        res = ccall((:test_aa64_i128_2, libccalltest), Struct_AA64_1,\n                    (Int64, Int128, Struct_AA64_1),\n                    v1, v2, Struct_AA64_1(v3_1, v3_2))\n        expected = Struct_AA64_1(v1 \u00f7 2 + 1 - v3_1, v2 * 2 - 1 - v3_2)\n        @test res === expected\n    end\n    for v1 in 1:4, v2 in -4:-1, v3 in 3:5, v4 in -(1:3)\n        res = ccall((:test_aa64_fp16_1, libccalltest), Float16,\n                    (Cint, Float32, Float64, Float16),\n                    v1, v2, v3, v4)\n        expected = Float16(v1 + v2 * 2 + v3 * 3 + v4 * 4)\n        @test res === expected\n\n        res = ccall((:test_aa64_fp16_2, libccalltest), Struct_AA64_2,\n                    (Cint, Float32, Float64, Float16),\n                    v1, v2, v3, v4)\n        expected = Struct_AA64_2(v4 / 2 + 1, v1 * 2 + v2 * 4 - v3)\n        @test res === expected\n    end\n    for v1_1 in 1:4, v1_2 in -2:2, v2 in -4:-1, v3_1 in 3:5, v3_2 in 6:8\n        res = ccall((:test_aa64_vec_1, libccalltest),\n                    VecReg{2,Int64},\n                    (VecReg{2,Int32}, Float32, VecReg{2,Int32}),\n                    (VecElement(Int32(v1_1)), VecElement(Int32(v1_2))),\n                    v2, (VecElement(Int32(v3_1)), VecElement(Int32(v3_2))))\n        expected = (VecElement(v1_1 * v2 + v3_1), VecElement(v1_2 * v2 + v3_2))\n        @test res === expected\n    end\n    for v1_11 in 1:4, v1_12 in -2:2, v1_21 in 1:4, v1_22 in -2:2,\n        v2_11 in 1:4, v2_12 in -2:2, v2_21 in 1:4, v2_22 in -2:2\n        v1 = Struct_AA64_3((VecElement(Int8(v1_11)), VecElement(Int8(v1_12)),\n                            VecElement(Int8(0)), VecElement(Int8(0)),\n                            VecElement(Int8(0)), VecElement(Int8(0)),\n                            VecElement(Int8(0)), VecElement(Int8(0))),\n                           (VecElement(Float32(v1_21)),\n                            VecElement(Float32(v1_22))))\n        v2 = Struct_AA64_4((VecElement(Float32(v2_21)),\n                            VecElement(Float32(v2_22))),\n                           (VecElement(Int16(v2_11)), VecElement(Int16(v2_12)),\n                            VecElement(Int16(0)), VecElement(Int16(0)),\n                            VecElement(Int16(0)), VecElement(Int16(0)),\n                            VecElement(Int16(0)), VecElement(Int16(0))))\n        res = ccall((:test_aa64_vec_2, libccalltest),\n                    Struct_AA64_3, (Struct_AA64_3, Struct_AA64_4), v1, v2)\n        expected = Struct_AA64_3((VecElement(Int8(v1_11 + v2_11)),\n                                  VecElement(Int8(v1_12 + v2_12)),\n                                  VecElement(Int8(0)), VecElement(Int8(0)),\n                                  VecElement(Int8(0)), VecElement(Int8(0)),\n                                  VecElement(Int8(0)), VecElement(Int8(0))),\n                                 (VecElement(Float32(v1_21 - v2_21)),\n                                  VecElement(Float32(v1_22 - v2_22))))\n        @test res === expected\n    end\n\nelseif Sys.ARCH === :powerpc64le || Sys.ARCH === :ppc64le\n@test_huge 1 \"_ppc64\" (1, (2.0, 3.0, 4.0, 5.0),)\n@test_huge 2 \"_ppc64\" ((1.0, 2.0, 3.0, 4.0), (11, 12))\n@test_huge 3 \"_ppc64\" ((1, 2, 3, 4), (11.0, 12.0, 13.0, 14.0))\n@test_huge 4 \"_ppc64\" ((1, 2), (11.0, 12.0))\n@test_huge 5 \"_ppc64\" ((((1.0, 2.0, 3.0, 4.0),\n                         (5.0, 6.0, 7.0, 8.0),\n                         (11.0, 12.0, 13.0, 14.0),\n                         (15.0, 16.0, 17.0, 18.0),\n                         (21.0, 22.0, 23.0, 24.0),\n                         (25.0, 26.0, 27.0, 28.0),\n                         (31.0, 32.0, 33.0, 34.0),\n                         (35.0, 36.0, 37.0, 38.0),\n                         (41.0, 42.0, 43.0, 44.0)),))\n@test_huge 6 \"_ppc64\" ((((1.0, 2.0, 3.0, 4.0),\n                         (5.0, 6.0, 7.0, 8.0),\n                         (11.0, 12.0, 13.0, 14.0),\n                         (15.0, 16.0, 17.0, 18.0),\n                         (21.0, 22.0, 23.0, 24.0),\n                         (25.0, 26.0, 27.0, 28.0),\n                         (31.0, 32.0, 33.0, 34.0),\n                         (35.0, 36.0, 37.0, 38.0)),\n                        (41.0, 42.0, 43.0, 44.0)))\n@test_huge 1 \"_ppc64_hva\" ((((1.0, 2.0, 3.0, 4.0),\n                             (5.0, 6.0, 7.0, 8.0),\n                             (11.0, 12.0, 13.0, 14.0),\n                             (15.0, 16.0, 17.0, 18.0),\n                             (21.0, 22.0, 23.0, 24.0),\n                             (25.0, 26.0, 27.0, 28.0),\n                             (31.0, 32.0, 33.0, 34.0),\n                             (35.0, 36.0, 37.0, 38.0)),))\n@test_huge 2 \"_ppc64_hva\" (((((1.0, 2.0, 3.0, 4.0),\n                              (5.0, 6.0, 7.0, 8.0)),\n                             ((11.0, 12.0, 13.0, 14.0),\n                              (15.0, 16.0, 17.0, 18.0))),))\n@test_huge 3 \"_ppc64_hva\" (((1.0, 2.0, 3.0, 4.0),\n                            (((11.0, 12.0, 13.0, 14.0),\n                              (15.0, 16.0, 17.0, 18.0)),)))\n@test_huge 4 \"_ppc64_hva\" (((1, 2, 3, 4),\n                            (11.0, 12.0, 13.0, 14.0)))\n@test_huge 5 \"_ppc64_hva\" (((1, 2, 3, 4),\n                            (11.0, 12.0)))\n\n@test 18451 == ccall((:test_ppc64_vec1long, libccalltest), Int64,\n    (Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Struct_huge1_ppc64),\n    1, 2, 3, 4, 5, 6, 7, 8, 9, Struct_huge1_ppc64(18000, (100, 101, 102, 103)))\n\n@test 941 == ccall((:test_ppc64_vec1long_vec, libccalltest), Int64,\n    (Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, Int64, V4xF32),\n    11, 12, 13, 14, 15, 16, 17, 18, 19, (200, 201, 202, 203))\n\n@test V4xF32((614232, 614218, 614204, 614190)) ==\n     ccall((:test_ppc64_vec2, libccalltest), V4xF32,\n    (Int64, V4xF32, V4xF32, V4xF32, V4xF32,\n     V4xF32, V4xF32, V4xF32, V4xF32, V4xF32,\n     V4xF32, V4xF32, V4xF32, V4xF32, V4xF32),\n    600000, (4, 3, 2, 1), (5, 4, 3, 2), (6, 5, 4, 3), (7, 6, 5, 4),\n    (14, 13, 12, 11), (15, 14, 13, 12), (16, 15, 14, 13), (17, 16, 15, 14), (18, 17, 16, 15),\n    (1024, 1023, 1022, 1021), (1025, 1024, 1023, 1022), (1026, 1025, 1024, 1023), (1027, 1026, 1025, 1024), (10028, 10027, 10026, 10025))\n\nelseif Sys.ARCH !== :i686 && Sys.ARCH !== :arm # TODO\n@warn \"ccall: no VecReg tests run for this platform\"\n\nend\n\n# Special calling convention for `Array`\nfunction f17204(a)\n    b = similar(a)\n    for i in eachindex(a)\n        b[i] = a[i] + 10\n    end\n    return b\nend\n@test ccall(@cfunction(f17204, Vector{Any}, (Vector{Any},)),\n            Vector{Any}, (Vector{Any},), Any[1:10;]) == Any[11:20;]\n\n# This used to trigger incorrect ccall callee inlining.\n# Not sure if there's a more reliable way to test this.\n# Do not put these in a function.\n@noinline g17413() = rand()\n@inline f17413() = (g17413(); g17413())\nccall((:test_echo_p, libccalltest), Ptr{Cvoid}, (Any,), f17413())\nfor i in 1:3\n    ccall((:test_echo_p, libccalltest), Ptr{Cvoid}, (Any,), f17413())\nend\n\nstruct SpillPint\n    a::Ptr{Cint}\n    b::Ptr{Cint}\nend\nBase.cconvert(::Type{SpillPint}, v::NTuple{2,Cint}) =\n    Base.cconvert(Ref{NTuple{2,Cint}}, v)\nfunction Base.unsafe_convert(::Type{SpillPint}, vr)\n    ptr = Base.unsafe_convert(Ref{NTuple{2,Cint}}, vr)\n    return SpillPint(ptr, ptr + 4)\nend\n\nmacro test_spill_n(n::Int, intargs, floatargs)\n    fname_int = Symbol(:test_spill_int, n)\n    fname_float = Symbol(:test_spill_float, n)\n    quote\n        local ints = $(esc(intargs))\n        local floats = $(esc(intargs))\n        @test ccall(($(QuoteNode(fname_int)), libccalltest), Cint,\n                    ($((:(Ref{Cint}) for j in 1:n)...), SpillPint),\n                    $((:(ints[$j]) for j in 1:n)...),\n                    (ints[$n + 1], ints[$n + 2])) == sum(ints[1:($n + 2)])\n        @test ccall(($(QuoteNode(fname_float)), libccalltest), Float32,\n                    ($((:Float32 for j in 1:n)...), NTuple{2,Float32}),\n                    $((:(floats[$j]) for j in 1:n)...),\n                    (floats[$n + 1], floats[$n + 2])) == sum(floats[1:($n + 2)])\n    end\nend\n\nfor i in 1:100\n    local intargs = rand(1:10000, 14)\n    local int32args = Int32.(intargs)\n    local intsum = sum(intargs)\n    local floatargs = rand(14)\n    local float32args = Float32.(floatargs)\n    local float32sum = sum(float32args)\n    local float64sum = sum(floatargs)\n    @test ccall((:test_long_args_intp, libccalltest), Cint,\n                (Ref{Cint}, Ref{Cint}, Ref{Cint}, Ref{Cint},\n                 Ref{Cint}, Ref{Cint}, Ref{Cint}, Ref{Cint},\n                 Ref{Cint}, Ref{Cint}, Ref{Cint}, Ref{Cint},\n                 Ref{Cint}, Ref{Cint}),\n                intargs[1], intargs[2], intargs[3], intargs[4],\n                intargs[5], intargs[6], intargs[7], intargs[8],\n                intargs[9], intargs[10], intargs[11], intargs[12],\n                intargs[13], intargs[14]) == intsum\n    @test ccall((:test_long_args_int, libccalltest), Cint,\n                (Cint, Cint, Cint, Cint, Cint, Cint, Cint, Cint,\n                 Cint, Cint, Cint, Cint, Cint, Cint),\n                intargs[1], intargs[2], intargs[3], intargs[4],\n                intargs[5], intargs[6], intargs[7], intargs[8],\n                intargs[9], intargs[10], intargs[11], intargs[12],\n                intargs[13], intargs[14]) == intsum\n    @test ccall((:test_long_args_float, libccalltest), Float32,\n                (Float32, Float32, Float32, Float32, Float32, Float32,\n                 Float32, Float32, Float32, Float32, Float32, Float32,\n                 Float32, Float32),\n                floatargs[1], floatargs[2], floatargs[3], floatargs[4],\n                floatargs[5], floatargs[6], floatargs[7], floatargs[8],\n                floatargs[9], floatargs[10], floatargs[11], floatargs[12],\n                floatargs[13], floatargs[14]) \u2248 float32sum\n    @test ccall((:test_long_args_double, libccalltest), Float64,\n                (Float64, Float64, Float64, Float64, Float64, Float64,\n                 Float64, Float64, Float64, Float64, Float64, Float64,\n                 Float64, Float64),\n                floatargs[1], floatargs[2], floatargs[3], floatargs[4],\n                floatargs[5], floatargs[6], floatargs[7], floatargs[8],\n                floatargs[9], floatargs[10], floatargs[11], floatargs[12],\n                floatargs[13], floatargs[14]) \u2248 float64sum\n\n    @test_spill_n 1 int32args float32args\n    @test_spill_n 2 int32args float32args\n    @test_spill_n 3 int32args float32args\n    @test_spill_n 4 int32args float32args\n    @test_spill_n 5 int32args float32args\n    @test_spill_n 6 int32args float32args\n    @test_spill_n 7 int32args float32args\n    @test_spill_n 8 int32args float32args\n    @test_spill_n 9 int32args float32args\n    @test_spill_n 10 int32args float32args\nend\n\n# issue #20835\n@test_throws(ErrorException(\"could not evaluate ccall argument type (it might depend on a local variable)\"),\n             eval(:(f20835(x) = ccall(:fn, Cvoid, (Ptr{typeof(x)},), x))))\n@test_throws(UndefVarError(:Something_not_defined_20835),\n             eval(:(f20835(x) = ccall(:fn, Something_not_defined_20835, (Ptr{typeof(x)},), x))))\n\n@noinline f21104at(::Type{T}) where {T} = ccall(:fn, Cvoid, (Some{T},), Some(0))\n@noinline f21104rt(::Type{T}) where {T} = ccall(:fn, Some{T}, ())\n@test code_llvm(devnull, f21104at, (Type{Float64},)) === nothing\n@test code_llvm(devnull, f21104rt, (Type{Float64},)) === nothing\n@test_throws(ErrorException(\"ccall argument 1 doesn't correspond to a C type\"),\n             f21104at(Float64))\n@test_throws(ErrorException(\"ccall return type doesn't correspond to a C type\"),\n             f21104rt(Float64))\n\n# test for malformed syntax errors\n@test Expr(:error, \"more arguments than types for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (), x)))\n@test Expr(:error, \"more arguments than types for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B,), x, y)))\n@test Expr(:error, \"more arguments than types for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B,), x, y, z)))\n@test Expr(:error, \"more arguments than types for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B,), x, y)))\n@test Expr(:error, \"more arguments than types for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B,), x, y, z)))\n@test Expr(:error, \"more arguments than types for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B, C), x, y, z)))\n@test Expr(:error, \"more types than arguments for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B,),)))\n@test Expr(:error, \"more types than arguments for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B, C), )))\n@test Expr(:error, \"more types than arguments for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B..., C...), )))\n@test Expr(:error, \"only the trailing ccall argument type should have \\\"...\\\"\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B..., C...), x)))\n@test Expr(:error, \"only the trailing ccall argument type should have \\\"...\\\"\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B..., C...), x, y, z)))\n@test Expr(:error, \"more types than arguments for ccall\") == Meta.lower(@__MODULE__, :(ccall(:fn, A, (B, C...), )))\n\n# cfunction on non-function singleton\nstruct CallableSingleton\nend\n(::CallableSingleton)(x, y) = x + y\n@test ccall(@cfunction(CallableSingleton(), Int, (Int, Int)),\n            Int, (Int, Int), 1, 2) === 3\n\n# 19805\nmutable struct callinfos_19805{FUNC_FT<:Function}\n    f :: FUNC_FT\nend\n\nevalf_callback_19805(ci::callinfos_19805{FUNC_FT}) where {FUNC_FT} = ci.f(0.5)::Float64\n\nevalf_callback_c_19805(ci::callinfos_19805{FUNC_FT}) where {FUNC_FT} = @cfunction(\n    evalf_callback_19805, Float64, (callinfos_19805{FUNC_FT},))\n\n@test_throws(ErrorException(\"cfunction argument 1 doesn't correspond to a C type\"),\n             evalf_callback_c_19805( callinfos_19805(sin) ))\n@test_throws(ErrorException(\"cfunction argument 2 doesn't correspond to a C type\"),\n             @cfunction(+, Int, (Int, Nothing)))\n@test_throws(ErrorException(\"cfunction: Vararg syntax not allowed for argument list\"),\n             @cfunction(+, Int, (Vararg{Int},)))\n@test_throws(ErrorException(\"could not evaluate cfunction argument type (it might depend on a local variable)\"),\n             @eval () -> @cfunction(+, Int, (Ref{T}, Ref{T})) where T)\n@test_throws(ErrorException(\"could not evaluate cfunction return type (it might depend on a local variable)\"),\n             @eval () -> @cfunction(+, Ref{T}, (Int, Int)) where T)\n@test_throws(ErrorException(\"cfunction return type Ref{Any} is invalid. Use Any or Ptr{Any} instead.\"),\n             @cfunction(+, Ref{Any}, (Int, Int)))\n\n# test Ref{abstract_type} calling parameter passes a heap box\nabstract type Abstract22734 end\nstruct Bits22734 <: Abstract22734\n    x::Int\n    y::Float64\nend\nfunction cb22734(ptr::Ptr{Cvoid})\n    GC.gc()\n    obj = unsafe_pointer_to_objref(ptr)::Bits22734\n    obj.x + obj.y\nend\nptr22734 = @cfunction(cb22734, Float64, (Ptr{Cvoid},))\nfunction caller22734(ptr)\n    obj = Bits22734(12, 20)\n    ccall(ptr, Float64, (Ref{Abstract22734},), obj)\nend\n@test caller22734(ptr22734) === 32.0\n\n# 26297#issuecomment-371165725\n#   test that the first argument to cglobal is recognized as a tuple literal even through\n#   macro expansion\nmacro cglobal26297(sym)\n    :(cglobal(($(esc(sym)), libccalltest), Cint))\nend\ncglobal26297() = @cglobal26297(:global_var)\n@test cglobal26297() != C_NULL\n\n# issue #26607\nnoop_func_26607 = () -> nothing\nfunction callthis_26607(args)\n    @cfunction(noop_func_26607, Cvoid, ())\n    return nothing\nend\n@test callthis_26607(Int64(0)) === nothing\n@test callthis_26607(Int32(0)) === nothing\n\n# issue #27178 (cfunction special case in inlining)\nmutable struct CallThisFunc27178{FCN_TYPE}\n    fcn::FCN_TYPE\nend\n\ncallback27178(cb::CTF) where CTF<:CallThisFunc27178 = nothing\n@inline make_cfunc27178(cbi::CI) where CI = @cfunction(callback27178, Cvoid, (Ref{CI},))\nget_c_func(fcn::FCN_TYPE) where {FCN_TYPE<:Function} = return make_cfunc27178(CallThisFunc27178(fcn))\n@test isa(get_c_func(sin), Ptr)\n\n# issue #27215\nfunction once_removed()\n    function mycompare(a, b)::Cint\n        return (a < b) ? -1 : ((a > b) ? +1 : 0)\n    end\n    mycompare_c = @cfunction($mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}))\nend\n@test isa(once_removed(), Base.CFunction)\n\n# issue #27478\nfunction ccall27478()\n    module_lib = Libdl.dlopen(\"libjulia\")\n    ccall(Libdl.dlsym(module_lib, \"getpid\"), Cint, ())\nend\n@test code_typed(ccall27478, ()) isa Array\n\n# issue #27477\n@eval module Pkg27477\nconst libccalltest = $libccalltest\nend\n\nmodule Test27477\nusing ..Pkg27477\ntest27477() = ccall((:ctest, Pkg27477.libccalltest), Complex{Int}, (Complex{Int},), 1 + 2im)\nend\n\n@test Test27477.test27477() == 2 + 0im\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/doc/src/manual/calling-c-and-fortran-code.md": "# Calling C and Fortran Code\n\nThough most code can be written in Julia, there are many high-quality, mature libraries for numerical\ncomputing already written in C and Fortran. To allow easy use of this existing code, Julia makes\nit simple and efficient to call C and Fortran functions. Julia has a \"no boilerplate\" philosophy:\nfunctions can be called directly from Julia without any \"glue\" code, code generation, or compilation\n-- even from the interactive prompt. This is accomplished just by making an appropriate call with\n[`ccall`](@ref) syntax, which looks like an ordinary function call.\n\nThe code to be called must be available as a shared library. Most C and Fortran libraries ship\ncompiled as shared libraries already, but if you are compiling the code yourself using GCC (or\nClang), you will need to use the `-shared` and `-fPIC` options. The machine instructions generated\nby Julia's JIT are the same as a native C call would be, so the resulting overhead is the same\nas calling a library function from C code. (Non-library function calls in both C and Julia can\nbe inlined and thus may have even less overhead than calls to shared library functions. When both\nlibraries and executables are generated by LLVM, it is possible to perform whole-program optimizations\nthat can even optimize across this boundary, but Julia does not yet support that. In the future,\nhowever, it may do so, yielding even greater performance gains.)\n\nShared libraries and functions are referenced by a tuple of the form `(:function, \"library\")`\nor `(\"function\", \"library\")` where `function` is the C-exported function name. `library` refers\nto the shared library name: shared libraries available in the (platform-specific) load path will\nbe resolved by name, and if necessary a direct path may be specified.\n\nA function name may be used alone in place of the tuple (just `:function` or `\"function\"`). In\nthis case the name is resolved within the current process. This form can be used to call C library\nfunctions, functions in the Julia runtime, or functions in an application linked to Julia.\n\nBy default, Fortran compilers [generate mangled\nnames](https://en.wikipedia.org/wiki/Name_mangling#Fortran) (for example,\nconverting function names to lowercase or uppercase, often appending an\nunderscore), and so to call a Fortran function via [`ccall`](@ref) you must pass\nthe mangled identifier corresponding to the rule followed by your Fortran\ncompiler.  Also, when calling a Fortran function, all inputs must be passed as\npointers to allocated values on the heap or stack. This applies not only to\narrays and other mutable objects which are normally heap-allocated, but also to\nscalar values such as integers and floats which are normally stack-allocated and\ncommonly passed in registers when using C or Julia calling conventions.\n\nFinally, you can use [`ccall`](@ref) to actually generate a call to the library function. Arguments\nto [`ccall`](@ref) are as follows:\n\n1. A `(:function, \"library\")` pair, which must be written as a literal constant,\n\n   OR\n\n   a function pointer (for example, from `dlsym`).\n\n2. Return type (see below for mapping the declared C type to Julia)\n\n     * This argument will be evaluated at compile-time, when the containing method is defined.\n\n3. A tuple of input types. The input types must be written as a literal tuple, not a tuple-valued\n   variable or expression.\n\n     * This argument will be evaluated at compile-time, when the containing method is defined.\n\n4. The following arguments, if any, are the actual argument values passed to the function.\n\nAs a complete but simple example, the following calls the `clock` function from the standard C\nlibrary:\n\n```julia-repl\njulia> t = ccall((:clock, \"libc\"), Int32, ())\n2292761\n\njulia> t\n2292761\n\njulia> typeof(ans)\nInt32\n```\n\n`clock` takes no arguments and returns an [`Int32`](@ref). One common gotcha is that a 1-tuple must be\nwritten with a trailing comma. For example, to call the `getenv` function to get a pointer to\nthe value of an environment variable, one makes a call like this:\n\n```julia-repl\njulia> path = ccall((:getenv, \"libc\"), Cstring, (Cstring,), \"SHELL\")\nCstring(@0x00007fff5fbffc45)\n\njulia> unsafe_string(path)\n\"/bin/bash\"\n```\n\nNote that the argument type tuple must be written as `(Cstring,)`, rather than `(Cstring)`. This\nis because `(Cstring)` is just the expression `Cstring` surrounded by parentheses, rather than\na 1-tuple containing `Cstring`:\n\n```jldoctest\njulia> (Cstring)\nCstring\n\njulia> (Cstring,)\n(Cstring,)\n```\n\nIn practice, especially when providing reusable functionality, one generally wraps [`ccall`](@ref)\nuses in Julia functions that set up arguments and then check for errors in whatever manner the\nC or Fortran function indicates them, propagating to the Julia caller as exceptions. This is especially\nimportant since C and Fortran APIs are notoriously inconsistent about how they indicate error\nconditions. For example, the `getenv` C library function is wrapped in the following Julia function,\nwhich is a simplified version of the actual definition from [`env.jl`](https://github.com/JuliaLang/julia/blob/master/base/env.jl):\n\n```julia\nfunction getenv(var::AbstractString)\n    val = ccall((:getenv, \"libc\"),\n                Cstring, (Cstring,), var)\n    if val == C_NULL\n        error(\"getenv: undefined variable: \", var)\n    end\n    unsafe_string(val)\nend\n```\n\nThe C `getenv` function indicates an error by returning `NULL`, but other standard C functions\nindicate errors in various different ways, including by returning -1, 0, 1 and other special values.\nThis wrapper throws an exception clearly indicating the problem if the caller tries to get a non-existent\nenvironment variable:\n\n```julia-repl\njulia> getenv(\"SHELL\")\n\"/bin/bash\"\n\njulia> getenv(\"FOOBAR\")\ngetenv: undefined variable: FOOBAR\n```\n\nHere is a slightly more complex example that discovers the local machine's hostname:\n\n```julia\nfunction gethostname()\n    hostname = Vector{UInt8}(128)\n    ccall((:gethostname, \"libc\"), Int32,\n          (Ptr{UInt8}, Csize_t),\n          hostname, sizeof(hostname))\n    hostname[end] = 0; # ensure null-termination\n    return unsafe_string(pointer(hostname))\nend\n```\n\nThis example first allocates an array of bytes, then calls the C library function `gethostname`\nto fill the array in with the hostname, takes a pointer to the hostname buffer, and converts the\npointer to a Julia string, assuming that it is a NUL-terminated C string. It is common for C libraries\nto use this pattern of requiring the caller to allocate memory to be passed to the callee and\nfilled in. Allocation of memory from Julia like this is generally accomplished by creating an\nuninitialized array and passing a pointer to its data to the C function. This is why we don't\nuse the `Cstring` type here: as the array is uninitialized, it could contain NUL bytes. Converting\nto a `Cstring` as part of the [`ccall`](@ref) checks for contained NUL bytes and could therefore\nthrow a conversion error.\n\n## Creating C-Compatible Julia Function Pointers\n\nIt is possible to pass Julia functions to native C functions that accept function pointer arguments.\nFor example, to match C prototypes of the form:\n\n```c\ntypedef returntype (*functiontype)(argumenttype, ...)\n```\n\nThe macro [`@cfunction`](@ref) generates the C-compatible function pointer for a call to a\nJulia function. Arguments to [`@cfunction`](@ref) are as follows:\n\n1. A Julia Function\n2. Return type\n3. A literal tuple of input types\n\nLike ccall, all of these arguments will be evaluated at compile-time, when the containing method is defined.\n\nCurrently, only the platform-default C calling convention is supported. This means that\n`@cfunction`-generated pointers cannot be used in calls where WINAPI expects `stdcall`\nfunction on 32-bit windows, but can be used on WIN64 (where `stdcall` is unified with the\nC calling convention).\n\nA classic example is the standard C library `qsort` function, declared as:\n\n```c\nvoid qsort(void *base, size_t nmemb, size_t size,\n           int (*compare)(const void*, const void*));\n```\n\nThe `base` argument is a pointer to an array of length `nmemb`, with elements of `size` bytes\neach. `compare` is a callback function which takes pointers to two elements `a` and `b` and returns\nan integer less/greater than zero if `a` should appear before/after `b` (or zero if any order\nis permitted). Now, suppose that we have a 1d array `A` of values in Julia that we want to sort\nusing the `qsort` function (rather than Julia's built-in `sort` function). Before we worry about\ncalling `qsort` and passing arguments, we need to write a comparison function that works for some\narbitrary objects (which define `<`):\n\n```jldoctest mycompare\njulia> function mycompare(a, b)::Cint\n           return (a < b) ? -1 : ((a > b) ? +1 : 0)\n       end\nmycompare (generic function with 1 method)\n```\n\nNotice that we have to be careful about the return type: `qsort` expects a function returning\na C `int`, so we annotate the return type of the function to be sure it returns a `Cint`.\n\nIn order to pass this function to C, we obtain its address using the macro `@cfunction`:\n\n```jldoctest mycompare\njulia> mycompare_c = @cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));\n```\n\n[`@cfunction`](@ref) requires three arguments: the Julia function (`mycompare`), the return type\n(`Cint`), and a literal tuple of the input argument types, in this case to sort an array of `Cdouble`\n([`Float64`](@ref)) elements.\n\nThe final call to `qsort` looks like this:\n\n```jldoctest mycompare\njulia> A = [1.3, -2.7, 4.4, 3.1]\n4-element Array{Float64,1}:\n  1.3\n -2.7\n  4.4\n  3.1\n\njulia> ccall(:qsort, Cvoid, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Cvoid}),\n             A, length(A), sizeof(eltype(A)), mycompare_c)\n\njulia> A\n4-element Array{Float64,1}:\n -2.7\n  1.3\n  3.1\n  4.4\n```\n\nAs can be seen, `A` is changed to the sorted array `[-2.7, 1.3, 3.1, 4.4]`. Note that Julia\nknows how to convert an array into a `Ptr{Cdouble}`, how to compute the size of a type in bytes\n(identical to C's `sizeof` operator), and so on. For fun, try inserting a `println(\"mycompare($a, $b)\")`\nline into `mycompare`, which will allow you to see the comparisons that `qsort` is performing\n(and to verify that it is really calling the Julia function that you passed to it).\n\n## Mapping C Types to Julia\n\nIt is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies\ncan cause code that works correctly on one system to fail or produce indeterminate results on\na different system.\n\nNote that no C header files are used anywhere in the process of calling C functions: you are responsible\nfor making sure that your Julia types and call signatures accurately reflect those in the C header\nfile. (The [Clang package](https://github.com/ihnorton/Clang.jl) can be used to auto-generate\nJulia code from a C header file.)\n\n### Auto-conversion:\n\nJulia automatically inserts calls to the [`Base.cconvert`](@ref) function to convert each argument\nto the specified type. For example, the following call:\n\n```julia\nccall((:foo, \"libfoo\"), Cvoid, (Int32, Float64), x, y)\n```\n\nwill behave as if the following were written:\n\n```julia\nccall((:foo, \"libfoo\"), Cvoid, (Int32, Float64),\n      Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),\n      Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))\n```\n\n[`Base.cconvert`](@ref) normally just calls [`convert`](@ref), but can be defined to return an\narbitrary new object more appropriate for passing to C.\nThis should be used to perform all allocations of memory that will be accessed by the C code.\nFor example, this is used to convert an `Array` of objects (e.g. strings) to an array of pointers.\n\n[`Base.unsafe_convert`](@ref) handles conversion to [`Ptr`](@ref) types. It is considered unsafe because\nconverting an object to a native pointer can hide the object from the garbage collector, causing\nit to be freed prematurely.\n\n### Type Correspondences:\n\nFirst, a review of some relevant Julia type terminology:\n\n| Syntax / Keyword              | Example                                     | Description                                                                                                                                                                                                                                                                    |\n|:----------------------------- |:------------------------------------------- |:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `mutable struct`              | `String`                                    | \"Leaf Type\" :: A group of related data that includes a type-tag, is managed by the Julia GC, and is defined by object-identity. The type parameters of a leaf type must be fully defined (no `TypeVars` are allowed) in order for the instance to be constructed.              |\n| `abstract type`               | `Any`, `AbstractArray{T, N}`, `Complex{T}`  | \"Super Type\" :: A super-type (not a leaf-type) that cannot be instantiated, but can be used to describe a group of types.                                                                                                                                                      |\n| `T{A}`                        | `Vector{Int}`                               | \"Type Parameter\" :: A specialization of a type (typically used for dispatch or storage optimization).                                                                                                                                                                          |\n|                               |                                             | \"TypeVar\" :: The `T` in the type parameter declaration is referred to as a TypeVar (short for type variable).                                                                                                                                                                  |\n| `primitive type`              | `Int`, `Float64`                            | \"Primitive Type\" :: A type with no fields, but a size. It is stored and defined by-value.                                                                                                                                                                                           |\n| `struct`                      | `Pair{Int, Int}`                            | \"Struct\" :: A type with all fields defined to be constant. It is defined by-value, and may be stored with a type-tag.                                                                                                                                                       |\n|                               | `ComplexF64` (`isbits`)                     | \"Is-Bits\"   :: A `primitive type`, or a `struct` type where all fields are other `isbits` types. It is defined by-value, and is stored without a type-tag.                                                                                                                       |\n| `struct ...; end`             | `nothing`                                   | \"Singleton\" :: a Leaf Type or Struct with no fields.                                                                                                                                                                                                                        |\n| `(...)` or `tuple(...)`       | `(1, 2, 3)`                                 | \"Tuple\" :: an immutable data-structure similar to an anonymous struct type, or a constant array. Represented as either an array or a struct.                                                                                                                                |\n\n### [Bits Types](@id man-bits-types)\n\nThere are several special types to be aware of, as no other type can be defined to behave the\nsame:\n\n  * `Float32`\n\n    Exactly corresponds to the `float` type in C (or `REAL*4` in Fortran).\n\n  * `Float64`\n\n    Exactly corresponds to the `double` type in C (or `REAL*8` in Fortran).\n\n  * `ComplexF32`\n\n    Exactly corresponds to the `complex float` type in C (or `COMPLEX*8` in Fortran).\n\n  * `ComplexF64`\n\n    Exactly corresponds to the `complex double` type in C (or `COMPLEX*16` in Fortran).\n\n  * `Signed`\n\n    Exactly corresponds to the `signed` type annotation in C (or any `INTEGER` type in Fortran).\n    Any Julia type that is not a subtype of [`Signed`](@ref) is assumed to be unsigned.\n\n\n  * `Ref{T}`\n\n    Behaves like a `Ptr{T}` that can manage its memory via the Julia GC.\n\n\n  * `Array{T,N}`\n\n    When an array is passed to C as a `Ptr{T}` argument, it is not reinterpret-cast: Julia requires\n    that the element type of the array matches `T`, and the address of the first element is passed.\n\n    Therefore, if an `Array` contains data in the wrong format, it will have to be explicitly converted\n    using a call such as `trunc(Int32, a)`.\n\n    To pass an array `A` as a pointer of a different type *without* converting the data beforehand\n    (for example, to pass a `Float64` array to a function that operates on uninterpreted bytes), you\n    can declare the argument as `Ptr{Cvoid}`.\n\n    If an array of eltype `Ptr{T}` is passed as a `Ptr{Ptr{T}}` argument, [`Base.cconvert`](@ref)\n    will attempt to first make a null-terminated copy of the array with each element replaced by its\n    [`Base.cconvert`](@ref) version. This allows, for example, passing an `argv` pointer array of type\n    `Vector{String}` to an argument of type `Ptr{Ptr{Cchar}}`.\n\nOn all systems we currently support, basic C/C++ value types may be translated to Julia types\nas follows. Every C type also has a corresponding Julia type with the same name, prefixed by C.\nThis can help for writing portable code (and remembering that an `int` in C is not the same as\nan `Int` in Julia).\n\n\n**System Independent:**\n\n| C name                                                  | Fortran name             | Standard Julia Alias | Julia Base Type                                                                                                |\n|:------------------------------------------------------- |:------------------------ |:-------------------- |:-------------------------------------------------------------------------------------------------------------- |\n| `unsigned char`                                         | `CHARACTER`              | `Cuchar`             | `UInt8`                                                                                                        |\n| `bool` (only in C++)                                    |                          | `Cuchar`             | `UInt8`                                                                                                        |\n| `short`                                                 | `INTEGER*2`, `LOGICAL*2` | `Cshort`             | `Int16`                                                                                                        |\n| `unsigned short`                                        | \u00a0                        | `Cushort`            | `UInt16`                                                                                                       |\n| `int`, `BOOL` (C, typical)                              | `INTEGER*4`, `LOGICAL*4` | `Cint`               | `Int32`                                                                                                        |\n| `unsigned int`                                          | \u00a0                        | `Cuint`              | `UInt32`                                                                                                       |\n| `long long`                                             | `INTEGER*8`, `LOGICAL*8` | `Clonglong`          | `Int64`                                                                                                        |\n| `unsigned long long`                                    | \u00a0                        | `Culonglong`         | `UInt64`                                                                                                       |\n| `intmax_t`                                              | \u00a0                        | `Cintmax_t`          | `Int64`                                                                                                        |\n| `uintmax_t`                                             | \u00a0                        | `Cuintmax_t`         | `UInt64`                                                                                                       |\n| `float`                                                 | `REAL*4i`                | `Cfloat`             | `Float32`                                                                                                      |\n| `double`                                                | `REAL*8`                 | `Cdouble`            | `Float64`                                                                                                      |\n| `complex float`                                         | `COMPLEX*8`              | `ComplexF32`          | `Complex{Float32}`                                                                                             |\n| `complex double`                                        | `COMPLEX*16`             | `ComplexF64`         | `Complex{Float64}`                                                                                             |\n| `ptrdiff_t`                                             | \u00a0                        | `Cptrdiff_t`         | `Int`                                                                                                          |\n| `ssize_t`                                               | \u00a0                        | `Cssize_t`           | `Int`                                                                                                          |\n| `size_t`                                                | \u00a0                        | `Csize_t`            | `UInt`                                                                                                         |\n| `void`                                                  | \u00a0                        | \u00a0                    | `Cvoid`                                                                                                         |\n| `void` and `[[noreturn]]` or `_Noreturn`                | \u00a0                        | \u00a0                    | `Union{}`                                                                                                      |\n| `void*`                                                 | \u00a0                        | \u00a0                    | `Ptr{Cvoid}`                                                                                                    |\n| `T*` (where T represents an appropriately defined type) | \u00a0                        | \u00a0                    | `Ref{T}`                                                                                                       |\n| `char*` (or `char[]`, e.g. a string)                    | `CHARACTER*N`            | \u00a0                    | `Cstring` if NUL-terminated, or `Ptr{UInt8}` if not                                                            |\n| `char**` (or `*char[]`)                                 | \u00a0                        | \u00a0                    | `Ptr{Ptr{UInt8}}`                                                                                              |\n| `jl_value_t*` (any Julia Type)                          | \u00a0                        | \u00a0                    | `Any`                                                                                                          |\n| `jl_value_t**` (a reference to a Julia Type)            | \u00a0                        | \u00a0                    | `Ref{Any}`                                                                                                     |\n| `va_arg`                                                | \u00a0                        | \u00a0                    | Not supported                                                                                                  |\n| `...` (variadic function specification)                 | \u00a0                        | \u00a0                    | `T...` (where `T` is one of the above types, variadic functions of different argument types are not supported) |\n\nThe [`Cstring`](@ref) type is essentially a synonym for `Ptr{UInt8}`, except the conversion to `Cstring`\nthrows an error if the Julia string contains any embedded NUL characters (which would cause the\nstring to be silently truncated if the C routine treats NUL as the terminator).  If you are passing\na `char*` to a C routine that does not assume NUL termination (e.g. because you pass an explicit\nstring length), or if you know for certain that your Julia string does not contain NUL and want\nto skip the check, you can use `Ptr{UInt8}` as the argument type. `Cstring` can also be used as\nthe [`ccall`](@ref) return type, but in that case it obviously does not introduce any extra\nchecks and is only meant to improve readability of the call.\n\n**System-dependent:**\n\n| C name          | Standard Julia Alias | Julia Base Type                              |\n|:--------------- |:-------------------- |:-------------------------------------------- |\n| `char`          | `Cchar`              | `Int8` (x86, x86_64), `UInt8` (powerpc, arm) |\n| `long`          | `Clong`              | `Int` (UNIX), `Int32` (Windows)              |\n| `unsigned long` | `Culong`             | `UInt` (UNIX), `UInt32` (Windows)            |\n| `wchar_t`       | `Cwchar_t`           | `Int32` (UNIX), `UInt16` (Windows)           |\n\n!!! note\n    When calling Fortran, all inputs must be passed by pointers to heap- or stack-allocated\n    values, so all type correspondences above should contain an additional `Ptr{..}` or\n    `Ref{..}` wrapper around their type specification.\n\n!!! warning\n    For string arguments (`char*`) the Julia type should be `Cstring` (if NUL- terminated data is\n    expected) or either `Ptr{Cchar}` or `Ptr{UInt8}` otherwise (these two pointer types have the same\n    effect), as described above, not `String`. Similarly, for array arguments (`T[]` or `T*`), the\n    Julia type should again be `Ptr{T}`, not `Vector{T}`.\n\n!!! warning\n    Julia's `Char` type is 32 bits, which is not the same as the wide character type (`wchar_t` or\n    `wint_t`) on all platforms.\n\n!!! warning\n    A return type of `Union{}` means the function will not return i.e. C++11 `[[noreturn]]` or C11\n    `_Noreturn` (e.g. `jl_throw` or `longjmp`). Do not use this for functions that return no value\n    (`void`) but do return, use `Cvoid` instead.\n\n!!! note\n    For `wchar_t*` arguments, the Julia type should be [`Cwstring`](@ref) (if the C routine expects a NUL-terminated\n    string) or `Ptr{Cwchar_t}` otherwise. Note also that UTF-8 string data in Julia is internally\n    NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making\n    a copy (but using the `Cwstring` type will cause an error to be thrown if the string itself contains\n    NUL characters).\n\n!!! note\n    C functions that take an argument of the type `char**` can be called by using a `Ptr{Ptr{UInt8}}`\n    type within Julia. For example, C functions of the form:\n\n    ```c\n    int main(int argc, char **argv);\n    ```\n\n    can be called via the following Julia code:\n\n    ```julia\n    argv = [ \"a.out\", \"arg1\", \"arg2\" ]\n    ccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)\n    ```\n\n!!! note\n    For Fortran functions taking variable length strings of type `character(len=*)` the string lengths\n    are provided as *hidden arguments*. Type and position of these arguments in the list are compiler\n    specific, where compiler vendors usually default to using `Csize_t` as type and append the hidden\n    arguments at the end of the argument list. While this behaviour is fixed for some compilers (GNU),\n    others *optionally* permit placing hidden arguments directly after the character argument (Intel,PGI).\n    For example, Fortran subroutines of the form\n\n    ```fortran\n    subroutine test(str1, str2)\n    character(len=*) :: str1,str2\n    ```\n\n    can be called via the following Julia code, where the lengths are appended\n\n    ```julia\n    str1 = \"foo\"\n    str2 = \"bar\"\n    ccall(:test, Void, (Ptr{UInt8}, Ptr{UInt8}, Csize_t, Csize_t),\n                        str1, str2, sizeof(str1), sizeof(str2))\n    ```\n\n!!! warning\n    Fortran compilers *may* also add other hidden arguments for pointers, assumed-shape (`:`)\n    and assumed-size (`*`) arrays. Such behaviour can be avoided by using `ISO_C_BINDING` and\n    including `bind(c)` in the definition of the subroutine, which is strongly recommended for\n    interoperable code. In this case there will be no hidden arguments, at the cost of some\n    language features (e.g. only `character(len=1)` will be permitted to pass strings).\n\n!!! note\n    A C function declared to return `Cvoid` will return the value `nothing` in Julia.\n\n### Struct Type correspondences\n\nComposite types, aka `struct` in C or `TYPE` in Fortran90 (or `STRUCTURE` / `RECORD` in some variants\nof F77), can be mirrored in Julia by creating a `struct` definition with the same\nfield layout.\n\nWhen used recursively, `isbits` types are stored inline. All other types are stored as a pointer\nto the data. When mirroring a struct used by-value inside another struct in C, it is imperative\nthat you do not attempt to manually copy the fields over, as this will not preserve the correct\nfield alignment. Instead, declare an `isbits` struct type and use that instead. Unnamed structs\nare not possible in the translation to Julia.\n\nPacked structs and union declarations are not supported by Julia.\n\nYou can get a near approximation of a `union` if you know, a priori, the field that will have\nthe greatest size (potentially including padding). When translating your fields to Julia, declare\nthe Julia field to be only of that type.\n\nArrays of parameters can be expressed with `NTuple`:\n\n```\nin C:\nstruct B {\n    int A[3];\n};\nb_a_2 = B.A[2];\n\nin Julia:\nstruct B\n    A::NTuple{3, CInt}\nend\nb_a_2 = B.A[3]  # note the difference in indexing (1-based in Julia, 0-based in C)\n```\n\nArrays of unknown size (C99-compliant variable length structs specified by `[]` or `[0]`) are not directly supported.\nOften the best way to deal with these is to deal with the byte offsets directly.\nFor example, if a C library declared a proper string type and returned a pointer to it:\n\n```c\nstruct String {\n    int strlen;\n    char data[];\n};\n```\n\nIn Julia, we can access the parts independently to make a copy of that string:\n\n```julia\nstr = from_c::Ptr{Cvoid}\nlen = unsafe_load(Ptr{Cint}(str))\nunsafe_string(str + Core.sizeof(Cint), len)\n```\n\n### Type Parameters\n\nThe type arguments to `ccall` and `@cfunction` are evaluated statically,\nwhen the method containing the usage is defined.\nThey therefore must take the form of a literal tuple, not a variable,\nand cannot reference local variables.\n\nThis may sound like a strange restriction,\nbut remember that since C is not a dynamic language like Julia,\nits functions can only accept argument types with a statically-known, fixed signature.\n\nHowever, while the type layout must be known statically to compute the intended C ABI,\nthe static parameters of the function are considered to be part of this static environment.\nThe static parameters of the function may be used as type parameters in the call signature,\nas long as they don't affect the layout of the type.\nFor example, `f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)`\nis valid, since `Ptr` is always a word-size primitive type.\nBut, `g(x::T) where {T} = ccall(:notvalid, T, (T,), x)`\nis not valid, since the type layout of `T` is not known statically.\n\n### SIMD Values\n\nNote: This feature is currently implemented on 64-bit x86 and AArch64 platforms only.\n\nIf a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding\nJulia type is a homogeneous tuple of `VecElement` that naturally maps to the SIMD type.  Specifically:\n\n>   * The tuple must be the same size as the SIMD type. For example, a tuple representing an `__m128`\n>     on x86 must have a size of 16 bytes.\n>   * The element type of the tuple must be an instance of `VecElement{T}` where `T` is a primitive type that\n>     is 1, 2, 4 or 8 bytes.\n\nFor instance, consider this C routine that uses AVX intrinsics:\n\n```c\n#include <immintrin.h>\n\n__m256 dist( __m256 a, __m256 b ) {\n    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),\n                                        _mm256_mul_ps(b, b)));\n}\n```\n\nThe following Julia code calls `dist` using `ccall`:\n\n```julia\nconst m256 = NTuple{8, VecElement{Float32}}\n\na = m256(ntuple(i -> VecElement(sin(Float32(i))), 8))\nb = m256(ntuple(i -> VecElement(cos(Float32(i))), 8))\n\nfunction call_dist(a::m256, b::m256)\n    ccall((:dist, \"libdist\"), m256, (m256, m256), a, b)\nend\n\nprintln(call_dist(a,b))\n```\n\nThe host machine must have the requisite SIMD registers.  For example, the code above will not\nwork on hosts without AVX support.\n\n### Memory Ownership\n\n**malloc/free**\n\nMemory allocation and deallocation of such objects must be handled by calls to the appropriate\ncleanup routines in the libraries being used, just like in any C program. Do not try to free an\nobject received from a C library with [`Libc.free`](@ref) in Julia, as this may result in the `free` function\nbeing called via the wrong `libc` library and cause Julia to crash. The reverse (passing an object\nallocated in Julia to be freed by an external library) is equally invalid.\n\n### When to use T, Ptr{T} and Ref{T}\n\nIn Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared\nto be of type `T` inside the [`ccall`](@ref), as they are passed by value.  For C code accepting\npointers, [`Ref{T}`](@ref) should generally be used for the types of input arguments, allowing the use\nof pointers to memory managed by either Julia or C through the implicit call to [`Base.cconvert`](@ref).\n In contrast, pointers returned by the C function called should be declared to be of output type\n[`Ptr{T}`](@ref), reflecting that the memory pointed to is managed by C only. Pointers contained in C\nstructs should be represented as fields of type `Ptr{T}` within the corresponding Julia struct\ntypes designed to mimic the internal structure of corresponding C structs.\n\nIn Julia code wrapping calls to external Fortran routines, all input arguments\nshould be declared as of type `Ref{T}`, as Fortran passes all variables by\npointers to memory locations. The return type should either be `Cvoid` for\nFortran subroutines, or a `T` for Fortran functions returning the type `T`.\n\n## Mapping C Functions to Julia\n\n### `ccall` / `@cfunction` argument translation guide\n\nFor translating a C argument list to Julia:\n\n  * `T`, where `T` is one of the primitive types: `char`, `int`, `long`, `short`, `float`, `double`,\n    `complex`, `enum` or any of their `typedef` equivalents\n\n      * `T`, where `T` is an equivalent Julia Bits Type (per the table above)\n      * if `T` is an `enum`, the argument type should be equivalent to `Cint` or `Cuint`\n      * argument value will be copied (passed by value)\n  * `struct T` (including typedef to a struct)\n\n      * `T`, where `T` is a Julia leaf type\n      * argument value will be copied (passed by value)\n  * `void*`\n\n      * depends on how this parameter is used, first translate this to the intended pointer type, then\n        determine the Julia equivalent using the remaining rules in this list\n      * this argument may be declared as `Ptr{Cvoid}`, if it really is just an unknown pointer\n  * `jl_value_t*`\n\n      * `Any`\n      * argument value must be a valid Julia object\n  * `jl_value_t**`\n\n      * `Ref{Any}`\n      * argument value must be a valid Julia object (or `C_NULL`)\n  * `T*`\n\n      * `Ref{T}`, where `T` is the Julia type corresponding to `T`\n      * argument value will be copied if it is an `isbits` type otherwise, the value must be a valid Julia\n        object\n  * `T (*)(...)` (e.g. a pointer to a function)\n\n      * `Ptr{Cvoid}` (you may need to use [`@cfunction`](@ref) explicitly to create this pointer)\n  * `...` (e.g. a vararg)\n\n      * `T...`, where `T` is the Julia type\n      * currently unsupported by `@cfunction`\n  * `va_arg`\n\n      * not supported by `ccall` or `@cfunction`\n\n### `ccall` / `@cfunction` return type translation guide\n\nFor translating a C return type to Julia:\n\n  * `void`\n\n      * `Cvoid` (this will return the singleton instance `nothing::Cvoid`)\n  * `T`, where `T` is one of the primitive types: `char`, `int`, `long`, `short`, `float`, `double`,\n    `complex`, `enum` or any of their `typedef` equivalents\n\n      * `T`, where `T` is an equivalent Julia Bits Type (per the table above)\n      * if `T` is an `enum`, the argument type should be equivalent to `Cint` or `Cuint`\n      * argument value will be copied (returned by-value)\n  * `struct T` (including typedef to a struct)\n\n      * `T`, where `T` is a Julia Leaf Type\n      * argument value will be copied (returned by-value)\n  * `void*`\n\n      * depends on how this parameter is used, first translate this to the intended pointer type, then\n        determine the Julia equivalent using the remaining rules in this list\n      * this argument may be declared as `Ptr{Cvoid}`, if it really is just an unknown pointer\n  * `jl_value_t*`\n\n      * `Any`\n      * argument value must be a valid Julia object\n  * `jl_value_t**`\n\n      * `Ptr{Any}` (`Ref{Any}` is invalid as a return type)\n      * argument value must be a valid Julia object (or `C_NULL`)\n  * `T*`\n\n      * If the memory is already owned by Julia, or is an `isbits` type, and is known to be non-null:\n\n          * `Ref{T}`, where `T` is the Julia type corresponding to `T`\n          * a return type of `Ref{Any}` is invalid, it should either be `Any` (corresponding to `jl_value_t*`)\n            or `Ptr{Any}` (corresponding to `jl_value_t**`)\n          * C **MUST NOT** modify the memory returned via `Ref{T}` if `T` is an `isbits` type\n      * If the memory is owned by C:\n\n          * `Ptr{T}`, where `T` is the Julia type corresponding to `T`\n  * `T (*)(...)` (e.g. a pointer to a function)\n\n      * `Ptr{Cvoid}` (you may need to use [`@cfunction`](@ref) explicitly to create this pointer)\n\n### Passing Pointers for Modifying Inputs\n\nBecause C doesn't support multiple return values, often C functions will take pointers to data\nthat the function will modify. To accomplish this within a [`ccall`](@ref), you need to first\nencapsulate the value inside a [`Ref{T}`](@ref) of the appropriate type. When you pass this `Ref` object\nas an argument, Julia will automatically pass a C pointer to the encapsulated data:\n\n```julia\nwidth = Ref{Cint}(0)\nrange = Ref{Cfloat}(0)\nccall(:foo, Cvoid, (Ref{Cint}, Ref{Cfloat}), width, range)\n```\n\nUpon return, the contents of `width` and `range` can be retrieved (if they were changed by `foo`)\nby `width[]` and `range[]`; that is, they act like zero-dimensional arrays.\n\n### Special Reference Syntax for ccall (deprecated):\n\nThe `&` syntax is deprecated, use the `Ref{T}` argument type instead.\n\nA prefix `&` is used on an argument to [`ccall`](@ref) to indicate that a pointer to a scalar\nargument should be passed instead of the scalar value itself (required for all Fortran function\narguments, as noted above). The following example computes a dot product using a BLAS function.\n\n```julia\nfunction compute_dot(DX::Vector{Float64}, DY::Vector{Float64})\n    @assert length(DX) == length(DY)\n    n = length(DX)\n    incx = incy = 1\n    product = ccall((:ddot_, \"libLAPACK\"),\n                    Float64,\n                    (Ref{Int32}, Ptr{Float64}, Ref{Int32}, Ptr{Float64}, Ref{Int32}),\n                    n, DX, incx, DY, incy)\n    return product\nend\n```\n\nThe meaning of prefix `&` is not quite the same as in C. In particular, any changes to the referenced\nvariables will not be visible in Julia unless the type is mutable (declared via `mutable struct`). However,\neven for immutable structs it will not cause any harm for called functions to attempt such modifications\n(that is, writing through the passed pointers). Moreover, `&` may be used with any expression,\nsuch as `&0` or `&f(x)`.\n\nWhen a scalar value is passed with `&` as an argument of type `Ptr{T}`, the value will first be\nconverted to type `T`.\n\n## Some Examples of C Wrappers\n\nHere is a simple example of a C wrapper that returns a `Ptr` type:\n\n```julia\nmutable struct gsl_permutation\nend\n\n# The corresponding C signature is\n#     gsl_permutation * gsl_permutation_alloc (size_t n);\nfunction permutation_alloc(n::Integer)\n    output_ptr = ccall(\n        (:gsl_permutation_alloc, :libgsl), # name of C function and library\n        Ptr{gsl_permutation},              # output type\n        (Csize_t,),                        # tuple of input types\n        n                                  # name of Julia variable to pass in\n    )\n    if output_ptr == C_NULL # Could not allocate memory\n        throw(OutOfMemoryError())\n    end\n    return output_ptr\nend\n```\n\nThe [GNU Scientific Library](https://www.gnu.org/software/gsl/) (here assumed to be accessible\nthrough `:libgsl`) defines an opaque pointer, `gsl_permutation *`, as the return type of the C\nfunction `gsl_permutation_alloc`. As user code never has to look inside the `gsl_permutation`\nstruct, the corresponding Julia wrapper simply needs a new type declaration, `gsl_permutation`,\nthat has no internal fields and whose sole purpose is to be placed in the type parameter of a\n`Ptr` type.  The return type of the [`ccall`](@ref) is declared as `Ptr{gsl_permutation}`, since\nthe memory allocated and pointed to by `output_ptr` is controlled by C (and not Julia).\n\nThe input `n` is passed by value, and so the function's input signature is\nsimply declared as `(Csize_t,)` without any `Ref` or `Ptr` necessary. (If the\nwrapper was calling a Fortran function instead, the corresponding function input\nsignature should instead be `(Ref{Csize_t},)`, since Fortran variables are\npassed by pointers.) Furthermore, `n` can be any type that is convertible to a\n`Csize_t` integer; the [`ccall`](@ref) implicitly calls [`Base.cconvert(Csize_t,\nn)`](@ref).\n\nHere is a second example wrapping the corresponding destructor:\n\n```julia\n# The corresponding C signature is\n#     void gsl_permutation_free (gsl_permutation * p);\nfunction permutation_free(p::Ref{gsl_permutation})\n    ccall(\n        (:gsl_permutation_free, :libgsl), # name of C function and library\n        Cvoid,                             # output type\n        (Ref{gsl_permutation},),          # tuple of input types\n        p                                 # name of Julia variable to pass in\n    )\nend\n```\n\nHere, the input `p` is declared to be of type `Ref{gsl_permutation}`, meaning that the memory\nthat `p` points to may be managed by Julia or by C. A pointer to memory allocated by C should\nbe of type `Ptr{gsl_permutation}`, but it is convertible using [`Base.cconvert`](@ref) and therefore\ncan be used in the same (covariant) context of the input argument to a [`ccall`](@ref). A pointer\nto memory allocated by Julia must be of type `Ref{gsl_permutation}`, to ensure that the memory\naddress pointed to is valid and that Julia's garbage collector manages the chunk of memory pointed\nto correctly. Therefore, the `Ref{gsl_permutation}` declaration allows pointers managed by C or\nJulia to be used.\n\nIf the C wrapper never expects the user to pass pointers to memory managed by Julia, then using\n`p::Ptr{gsl_permutation}` for the method signature of the wrapper and similarly in the [`ccall`](@ref)\nis also acceptable.\n\nHere is a third example passing Julia arrays:\n\n```julia\n# The corresponding C signature is\n#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,\n#                                double result_array[])\nfunction sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)\n    if nmax < nmin\n        throw(DomainError())\n    end\n    result_array = Vector{Cdouble}(nmax - nmin + 1)\n    errorcode = ccall(\n        (:gsl_sf_bessel_Jn_array, :libgsl), # name of C function and library\n        Cint,                               # output type\n        (Cint, Cint, Cdouble, Ref{Cdouble}),# tuple of input types\n        nmin, nmax, x, result_array         # names of Julia variables to pass in\n    )\n    if errorcode != 0\n        error(\"GSL error code $errorcode\")\n    end\n    return result_array\nend\n```\n\nThe C function wrapped returns an integer error code; the results of the actual evaluation of\nthe Bessel J function populate the Julia array `result_array`. This variable can only be used\nwith corresponding input type declaration `Ref{Cdouble}`, since its memory is allocated and managed\nby Julia, not C. The implicit call to [`Base.cconvert(Ref{Cdouble}, result_array)`](@ref) unpacks\nthe Julia pointer to a Julia array data structure into a form understandable by C.\n\nNote that for this code to work correctly, `result_array` must be declared to be of type `Ref{Cdouble}`\nand not `Ptr{Cdouble}`. The memory is managed by Julia and the `Ref` signature alerts Julia's\ngarbage collector to keep managing the memory for `result_array` while the [`ccall`](@ref) executes.\nIf `Ptr{Cdouble}` were used instead, the [`ccall`](@ref) may still work, but Julia's garbage\ncollector would not be aware that the memory declared for `result_array` is being used by the\nexternal C function. As a result, the code may produce a memory leak if `result_array` never gets\nfreed by the garbage collector, or if the garbage collector prematurely frees `result_array`,\nthe C function may end up throwing an invalid memory access exception.\n\n## Garbage Collection Safety\n\nWhen passing data to a [`ccall`](@ref), it is best to avoid using the [`pointer`](@ref) function.\nInstead define a convert method and pass the variables directly to the [`ccall`](@ref). [`ccall`](@ref)\nautomatically arranges that all of its arguments will be preserved from garbage collection until\nthe call returns. If a C API will store a reference to memory allocated by Julia, after the [`ccall`](@ref)\nreturns, you must arrange that the object remains visible to the garbage collector. The suggested\nway to handle this is to make a global variable of type `Array{Ref,1}` to hold these values, until\nthe C library notifies you that it is finished with them.\n\nWhenever you have created a pointer to Julia data, you must ensure the original data exists until\nyou are done with using the pointer. Many methods in Julia such as [`unsafe_load`](@ref) and\n[`String`](@ref) make copies of data instead of taking ownership of the buffer, so that it is\nsafe to free (or alter) the original data without affecting Julia. A notable exception is [`unsafe_wrap`](@ref)\nwhich, for performance reasons, shares (or can be told to take ownership of) the underlying buffer.\n\nThe garbage collector does not guarantee any order of finalization. That is, if `a` contained\na reference to `b` and both `a` and `b` are due for garbage collection, there is no guarantee\nthat `b` would be finalized after `a`. If proper finalization of `a` depends on `b` being valid,\nit must be handled in other ways.\n\n## Non-constant Function Specifications\n\nA `(name, library)` function specification must be a constant expression. However, it is possible\nto use computed values as function names by staging through [`eval`](@ref) as follows:\n\n```\n@eval ccall(($(string(\"a\", \"b\")), \"lib\"), ...\n```\n\nThis expression constructs a name using `string`, then substitutes this name into a new [`ccall`](@ref)\nexpression, which is then evaluated. Keep in mind that `eval` only operates at the top level,\nso within this expression local variables will not be available (unless their values are substituted\nwith `$`). For this reason, `eval` is typically only used to form top-level definitions, for example\nwhen wrapping libraries that contain many similar functions.\nA similar example can be constructed for [`@cfunction`](@ref).\n\nHowever, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading.\nThe next section discusses how to use indirect calls to efficiently accomplish a similar effect.\n\n## Indirect Calls\n\nThe first argument to [`ccall`](@ref) can also be an expression evaluated at run time. In this\ncase, the expression must evaluate to a `Ptr`, which will be used as the address of the native\nfunction to call. This behavior occurs when the first [`ccall`](@ref) argument contains references\nto non-constants, such as local variables, function arguments, or non-constant globals.\n\nFor example, you might look up the function via `dlsym`,\nthen cache it in a shared reference for that session. For example:\n\n```julia\nmacro dlsym(func, lib)\n    z = Ref{Ptr{Cvoid}}(C_NULL)\n    quote\n        let zlocal = $z[]\n            if zlocal == C_NULL\n                zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}\n                $z[] = $zlocal\n            end\n            zlocal\n        end\n    end\nend\n\nmylibvar = Libdl.dlopen(\"mylib\")\nccall(@dlsym(\"myfunc\", mylibvar), Cvoid, ())\n```\n\n## Closure cfunctions\n\nThe first argument to [`@cfunction`](@ref) can be marked with a `$`, in which case\nthe return value will instead be a `struct CFunction` which closes over the argument.\nYou must ensure that this return object is kept alive until all uses of it are done.\nThe contents and code at the cfunction pointer will be erased via a [`finalizer`](@ref)\nwhen this reference is dropped and atexit. This is not usually needed, since this\nfunctionality is not present in C, but can be useful for dealing with ill-designed APIs\nwhich don't provide a separate closure environment parameter.\n\n```julia\nfunction qsort(a::Vector{T}, cmp) where T\n    isbits(T) || throw(ArgumentError(\"this method can only qsort isbits arrays\"))\n    callback = @cfunction $cmp Cint (Ref{T}, Ref{T})\n    # Here, `callback` isa Base.CFunction, which will be converted to Ptr{Cvoid}\n    # (and protected against finalization) by the ccall\n    ccall(:qsort, Cvoid, (Ptr{T}, Csize_t, Csize_t, Ptr{Cvoid}),\n        a, length(a), Base.elsize(a), callback)\n    # We could instead use:\n    #    GC.@preserve callback begin\n    #        use(Base.unsafe_convert(Ptr{Cvoid}, callback))\n    #    end\n    # if we needed to use it outside of a `ccall`\n    return a\nend\n```\n\n\n## Closing a Library\n\nIt is sometimes useful to close (unload) a library so that it can be reloaded.\nFor instance, when developing C code for use with Julia, one may need to compile,\ncall the C code from Julia, then close the library, make an edit, recompile,\nand load in the new changes. One can either restart Julia or use the\n`Libdl` functions to manage the library explicitly, such as:\n\n```julia\nlib = Libdl.dlopen(\"./my_lib.so\") # Open the library explicitly.\nsym = Libdl.dlsym(lib, :my_fcn)   # Get a symbol for the function to call.\nccall(sym, ...) # Use the pointer `sym` instead of the (symbol, library) tuple (remaining arguments are the same).\nLibdl.dlclose(lib) # Close the library explicitly.\n```\n\nNote that when using `ccall` with the tuple input\n(e.g., `ccall((:my_fcn, \"./my_lib.so\"), ...)`), the library is opened implicitly\nand it may not be explicitly closed.\n\n## Calling Convention\n\nThe second argument to [`ccall`](@ref) can optionally be a calling convention specifier (immediately\npreceding return type). Without any specifier, the platform-default C calling convention is used.\nOther supported conventions are: `stdcall`, `cdecl`, `fastcall`, and `thiscall` (no-op on 64-bit Windows). For example (from\n`base/libc.jl`) we see the same `gethostname`[`ccall`](@ref) as above, but with the correct\nsignature for Windows:\n\n```julia\nhn = Vector{UInt8}(256)\nerr = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))\n```\n\nFor more information, please see the [LLVM Language Reference](http://llvm.org/docs/LangRef.html#calling-conventions).\n\nThere is one additional special calling convention [`llvmcall`](@ref Base.llvmcall),\nwhich allows inserting calls to LLVM intrinsics directly.\nThis can be especially useful when targeting unusual platforms such as GPGPUs.\nFor example, for [CUDA](http://llvm.org/docs/NVPTXUsage.html), we need to be able to read the thread index:\n\n```julia\nccall(\"llvm.nvvm.read.ptx.sreg.tid.x\", llvmcall, Int32, ())\n```\n\nAs with any `ccall`, it is essential to get the argument signature exactly correct.\nAlso, note that there is no compatibility layer that ensures the intrinsic makes\nsense and works on the current target,\nunlike the equivalent Julia functions exposed by `Core.Intrinsics`.\n\n## Accessing Global Variables\n\nGlobal variables exported by native libraries can be accessed by name using the [`cglobal`](@ref)\nfunction. The arguments to [`cglobal`](@ref) are a symbol specification identical to that used\nby [`ccall`](@ref), and a type describing the value stored in the variable:\n\n```julia-repl\njulia> cglobal((:errno, :libc), Int32)\nPtr{Int32} @0x00007f418d0816b8\n```\n\nThe result is a pointer giving the address of the value. The value can be manipulated through\nthis pointer using [`unsafe_load`](@ref) and [`unsafe_store!`](@ref).\n\n## Accessing Data through a Pointer\n\nThe following methods are described as \"unsafe\" because a bad pointer or type declaration can\ncause Julia to terminate abruptly.\n\nGiven a `Ptr{T}`, the contents of type `T` can generally be copied from the referenced memory\ninto a Julia object using `unsafe_load(ptr, [index])`. The index argument is optional (default\nis 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar\nto the behavior of [`getindex`](@ref) and [`setindex!`](@ref) (e.g. `[]` access syntax).\n\nThe return value will be a new object initialized to contain a copy of the contents of the referenced\nmemory. The referenced memory can safely be freed or released.\n\nIf `T` is `Any`, then the memory is assumed to contain a reference to a Julia object (a `jl_value_t*`),\nthe result will be a reference to this object, and the object will not be copied. You must be\ncareful in this case to ensure that the object was always visible to the garbage collector (pointers\ndo not count, but the new reference does) to ensure the memory is not prematurely freed. Note\nthat if the object was not originally allocated by Julia, the new object will never be finalized\nby Julia's garbage collector.  If the `Ptr` itself is actually a `jl_value_t*`, it can be converted\nback to a Julia object reference by [`unsafe_pointer_to_objref(ptr)`](@ref). (Julia values `v`\ncan be converted to `jl_value_t*` pointers, as `Ptr{Cvoid}`, by calling [`pointer_from_objref(v)`](@ref).)\n\nThe reverse operation (writing data to a `Ptr{T}`), can be performed using [`unsafe_store!(ptr, value, [index])`](@ref).\nCurrently, this is only supported for primitive types or other pointer-free (`isbits`) immutable struct types.\n\nAny operation that throws an error is probably currently unimplemented and should be posted as\na bug so that it can be resolved.\n\nIf the pointer of interest is a plain-data array (primitive type or immutable struct), the function [`unsafe_wrap(Array, ptr,dims, own = false)`](@ref)\nmay be more useful. The final parameter should be true if Julia should \"take ownership\" of the\nunderlying buffer and call `free(ptr)` when the returned `Array` object is finalized.  If the\n`own` parameter is omitted or false, the caller must ensure the buffer remains in existence until\nall access is complete.\n\nArithmetic on the `Ptr` type in Julia (e.g. using `+`) does not behave the same as C's pointer\narithmetic. Adding an integer to a `Ptr` in Julia always moves the pointer by some number of\n*bytes*, not elements. This way, the address values obtained from pointer arithmetic do not depend\non the element types of pointers.\n\n## Thread-safety\n\nSome C libraries execute their callbacks from a different thread, and since Julia isn't thread-safe\nyou'll need to take some extra precautions. In particular, you'll need to set up a two-layered\nsystem: the C callback should only *schedule* (via Julia's event loop) the execution of your \"real\"\ncallback. To do this, create an [`AsyncCondition`](@ref Base.AsyncCondition) object and [`wait`](@ref) on it:\n\n```julia\ncond = Base.AsyncCondition()\nwait(cond)\n```\n\nThe callback you pass to C should only execute a [`ccall`](@ref) to `:uv_async_send`, passing\n`cond.handle` as the argument, taking care to avoid any allocations or other interactions with the\nJulia runtime.\n\nNote that events may be coalesced, so multiple calls to `uv_async_send` may result in a single wakeup\nnotification to the condition.\n\n## More About Callbacks\n\nFor more details on how to pass callbacks to C libraries, see this [blog post](https://julialang.org/blog/2013/05/callback).\n\n## C++\n\nFor direct C++ interfacing, see the [Cxx](https://github.com/Keno/Cxx.jl) package. For tools to create C++\nbindings, see the [CxxWrap](https://github.com/JuliaInterop/CxxWrap.jl) package.\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/doc/_build/html/en/search_index.js": "var documenterSearchIndex = {\"docs\": [\n\n{\n    \"location\": \"index.html#\",\n    \"page\": \"Home\",\n    \"title\": \"Home\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"index.html#Julia-0.7-Documentation-1\",\n    \"page\": \"Home\",\n    \"title\": \"Julia 0.7 Documentation\",\n    \"category\": \"section\",\n    \"text\": \"Welcome to the documentation for Julia 0.7.Please read the release notes to see what has changed since the last release.\"\n},\n\n{\n    \"location\": \"index.html#man-introduction-1\",\n    \"page\": \"Home\",\n    \"title\": \"Introduction\",\n    \"category\": \"section\",\n    \"text\": \"Scientific computing has traditionally required the highest performance, yet domain experts have largely moved to slower dynamic languages for daily work. We believe there are many good reasons to prefer dynamic languages for these applications, and we do not expect their use to diminish. Fortunately, modern language design and compiler techniques make it possible to mostly eliminate the performance trade-off and provide a single environment productive enough for prototyping and efficient enough for deploying performance-intensive applications. The Julia programming language fills this role: it is a flexible dynamic language, appropriate for scientific and numerical computing, with performance comparable to traditional statically-typed languages.Because Julia\\'s compiler is different from the interpreters used for languages like Python or R, you may find that Julia\\'s performance is unintuitive at first. If you find that something is slow, we highly recommend reading through the Performance Tips section before trying anything else. Once you understand how Julia works, it\\'s easy to write code that\\'s nearly as fast as C.Julia features optional typing, multiple dispatch, and good performance, achieved using type inference and just-in-time (JIT) compilation, implemented using LLVM. It is multi-paradigm, combining features of imperative, functional, and object-oriented programming. Julia provides ease and expressiveness for high-level numerical computing, in the same way as languages such as R, MATLAB, and Python, but also supports general programming. To achieve this, Julia builds upon the lineage of mathematical programming languages, but also borrows much from popular dynamic languages, including Lisp, Perl, Python, Lua, and Ruby.The most significant departures of Julia from typical dynamic languages are:The core language imposes very little; Julia Base and the standard library is written in Julia itself, including primitive operations like integer arithmetic\\nA rich language of types for constructing and describing objects, that can also optionally be used to make type declarations\\nThe ability to define function behavior across many combinations of argument types via multiple dispatch\\nAutomatic generation of efficient, specialized code for different argument types\\nGood performance, approaching that of statically-compiled languages like CAlthough one sometimes speaks of dynamic languages as being \\\"typeless\\\", they are definitely not: every object, whether primitive or user-defined, has a type. The lack of type declarations in most dynamic languages, however, means that one cannot instruct the compiler about the types of values, and often cannot explicitly talk about types at all. In static languages, on the other hand, while one can \u2013 and usually must \u2013 annotate types for the compiler, types exist only at compile time and cannot be manipulated or expressed at run time. In Julia, types are themselves run-time objects, and can also be used to convey information to the compiler.While the casual programmer need not explicitly use types or multiple dispatch, they are the core unifying features of Julia: functions are defined on different combinations of argument types, and applied by dispatching to the most specific matching definition. This model is a good fit for mathematical programming, where it is unnatural for the first argument to \\\"own\\\" an operation as in traditional object-oriented dispatch. Operators are just functions with special notation \u2013 to extend addition to new user-defined data types, you define new methods for the + function. Existing code then seamlessly applies to the new data types.Partly because of run-time type inference (augmented by optional type annotations), and partly because of a strong focus on performance from the inception of the project, Julia\\'s computational efficiency exceeds that of other dynamic languages, and even rivals that of statically-compiled languages. For large scale numerical problems, speed always has been, continues to be, and probably always will be crucial: the amount of data being processed has easily kept pace with Moore\\'s Law over the past decades.Julia aims to create an unprecedented combination of ease-of-use, power, and efficiency in a single language. In addition to the above, some advantages of Julia over comparable systems include:Free and open source (MIT licensed)\\nUser-defined types are as fast and compact as built-ins\\nNo need to vectorize code for performance; devectorized code is fast\\nDesigned for parallelism and distributed computation\\nLightweight \\\"green\\\" threading (coroutines)\\nUnobtrusive yet powerful type system\\nElegant and extensible conversions and promotions for numeric and other types\\nEfficient support for Unicode, including but not limited to UTF-8\\nCall C functions directly (no wrappers or special APIs needed)\\nPowerful shell-like capabilities for managing other processes\\nLisp-like macros and other metaprogramming facilities\"\n},\n\n{\n    \"location\": \"NEWS.html#\",\n    \"page\": \"Julia v1.0.0 Release Notes\",\n    \"title\": \"Julia v1.0.0 Release Notes\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"NEWS.html#Julia-v1.0.0-Release-Notes-1\",\n    \"page\": \"Julia v1.0.0 Release Notes\",\n    \"title\": \"Julia v1.0.0 Release Notes\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"NEWS.html#New-language-features-1\",\n    \"page\": \"Julia v1.0.0 Release Notes\",\n    \"title\": \"New language features\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"NEWS.html#Language-changes-1\",\n    \"page\": \"Julia v1.0.0 Release Notes\",\n    \"title\": \"Language changes\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"NEWS.html#Breaking-changes-1\",\n    \"page\": \"Julia v1.0.0 Release Notes\",\n    \"title\": \"Breaking changes\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"NEWS.html#Library-improvements-1\",\n    \"page\": \"Julia v1.0.0 Release Notes\",\n    \"title\": \"Library improvements\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"NEWS.html#Compiler/Runtime-improvements-1\",\n    \"page\": \"Julia v1.0.0 Release Notes\",\n    \"title\": \"Compiler/Runtime improvements\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"NEWS.html#Deprecated-or-removed-1\",\n    \"page\": \"Julia v1.0.0 Release Notes\",\n    \"title\": \"Deprecated or removed\",\n    \"category\": \"section\",\n    \"text\": \"The old package manager (now called OldPkg) has been moved to a separate repository at https://github.com/JuliaArchive/OldPkg.jl (#27930)\"\n},\n\n{\n    \"location\": \"NEWS.html#Command-line-option-changes-1\",\n    \"page\": \"Julia v1.0.0 Release Notes\",\n    \"title\": \"Command-line option changes\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/getting-started.html#\",\n    \"page\": \"Getting Started\",\n    \"title\": \"Getting Started\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/getting-started.html#man-getting-started-1\",\n    \"page\": \"Getting Started\",\n    \"title\": \"Getting Started\",\n    \"category\": \"section\",\n    \"text\": \"Julia installation is straightforward, whether using precompiled binaries or compiling from source. Download and install Julia by following the instructions at https://julialang.org/downloads/.The easiest way to learn and experiment with Julia is by starting an interactive session (also known as a read-eval-print loop or \\\"REPL\\\") by double-clicking the Julia executable or running julia from the command line:io = IOBuffer()\\nBase.banner(io)\\nbanner = String(take!(io))\\nimport Markdown\\nMarkdown.parse(\\\"```\\\\n\\\\$ julia\\\\n\\\\n$(banner)\\\\njulia> 1 + 2\\\\n3\\\\n\\\\njulia> ans\\\\n3\\\\n```\\\")To exit the interactive session, type CTRL-D (press the Control/^ key together with the d key), or type exit(). When run in interactive mode, julia displays a banner and prompts the user for input. Once the user has entered a complete expression, such as 1 + 2, and hits enter, the interactive session evaluates the expression and shows its value. If an expression is entered into an interactive session with a trailing semicolon, its value is not shown. The variable ans is bound to the value of the last evaluated expression whether it is shown or not. The ans variable is only bound in interactive sessions, not when Julia code is run in other ways.To evaluate expressions written in a source file file.jl, write include(\\\"file.jl\\\").To run code in a file non-interactively, you can give it as the first argument to the julia command:$ julia script.jl arg1 arg2...As the example implies, the following command-line arguments to julia are interpreted as command-line arguments to the program script.jl, passed in the global constant ARGS. The name of the script itself is passed in as the global PROGRAM_FILE. Note that ARGS is also set when a Julia expression is given using the -e option on the command line (see the julia help output below) but PROGRAM_FILE will be empty. For example, to just print the arguments given to a script, you could do this:$ julia -e \\'println(PROGRAM_FILE); for x in ARGS; println(x); end\\' foo bar\\n\\nfoo\\nbarOr you could put that code into a script and run it:$ echo \\'println(PROGRAM_FILE); for x in ARGS; println(x); end\\' > script.jl\\n$ julia script.jl foo bar\\nscript.jl\\nfoo\\nbarThe -- delimiter can be used to separate command-line arguments intended for the script file from arguments intended for Julia:$ julia --color=yes -O -- foo.jl arg1 arg2..Julia can be started in parallel mode with either the -p or the --machine-file options. -p n will launch an additional n worker processes, while --machine-file file will launch a worker for each line in file file. The machines defined in file must be accessible via a password-less ssh login, with Julia installed at the same location as the current host. Each machine definition takes the form [count*][user@]host[:port] [bind_addr[:port]]. user defaults to current user, port to the standard ssh port. count is the number of workers to spawn on the node, and defaults to 1. The optional bind-to bind_addr[:port] specifies the IP address and port that other workers should use to connect to this worker.If you have code that you want executed whenever Julia is run, you can put it in ~/.julia/config/startup.jl:$ echo \\'println(\\\"Greetings! \u4f60\u597d! \uc548\ub155\ud558\uc138\uc694?\\\")\\' > ~/.julia/config/startup.jl\\n$ julia\\nGreetings! \u4f60\u597d! \uc548\ub155\ud558\uc138\uc694?\\n\\n...There are various ways to run Julia code and provide options, similar to those available for the perl and ruby programs:julia [switches] -- [programfile] [args...]Switch Description\\n-v, --version Display version information\\n-h, --help Print this message\\n-J, --sysimage <file> Start up with the given system image file\\n-H, --home <dir> Set location of julia executable\\n--startup-file={yes|no} Load ~/.julia/config/startup.jl\\n--handle-signals={yes|no} Enable or disable Julia\\'s default signal handlers\\n--sysimage-native-code={yes|no} Use native code from system image if available\\n--compiled-modules={yes|no} Enable or disable incremental precompilation of modules\\n-e, --eval <expr> Evaluate <expr>\\n-E, --print <expr> Evaluate <expr> and display the result\\n-L, --load <file> Load <file> immediately on all processors\\n-p, --procs {N|auto} Integer value N launches N additional local worker processes; auto launches as many workers as the number of local CPU threads (logical cores)\\n--machine-file <file> Run processes on hosts listed in <file>\\n-i Interactive mode; REPL runs and isinteractive() is true\\n-q, --quiet Quiet startup: no banner, suppress REPL warnings\\n--banner={yes|no|auto} Enable or disable startup banner\\n--color={yes|no|auto} Enable or disable color text\\n--history-file={yes|no} Load or save history\\n--depwarn={yes|no|error} Enable or disable syntax and method deprecation warnings (error turns warnings into errors)\\n--warn-overwrite={yes|no} Enable or disable method overwrite warnings\\n-C, --cpu-target <target> Limit usage of cpu features up to <target>; set to help to see the available options\\n-O, --optimize={0,1,2,3} Set the optimization level (default level is 2 if unspecified or 3 if used without a level)\\n-g, -g <level> Enable / Set the level of debug info generation (default level is 1 if unspecified or 2 if used without a level)\\n--inline={yes|no} Control whether inlining is permitted, including overriding @inline declarations\\n--check-bounds={yes|no} Emit bounds checks always or never (ignoring declarations)\\n--math-mode={ieee,fast} Disallow or enable unsafe floating point optimizations (overrides @fastmath declaration)\\n--code-coverage={none|user|all} Count executions of source lines\\n--code-coverage equivalent to --code-coverage=user\\n--track-allocation={none|user|all} Count bytes allocated by each source line\\n--track-allocation equivalent to --track-allocation=user\"\n},\n\n{\n    \"location\": \"manual/getting-started.html#Resources-1\",\n    \"page\": \"Getting Started\",\n    \"title\": \"Resources\",\n    \"category\": \"section\",\n    \"text\": \"A curated list of useful learning resources to help new users get started can be found on the learning page of the main Julia web site.\"\n},\n\n{\n    \"location\": \"manual/variables.html#\",\n    \"page\": \"Variables\",\n    \"title\": \"Variables\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/variables.html#Variables-1\",\n    \"page\": \"Variables\",\n    \"title\": \"Variables\",\n    \"category\": \"section\",\n    \"text\": \"A variable, in Julia, is a name associated (or bound) to a value. It\\'s useful when you want to store a value (that you obtained after some math, for example) for later use. For example:# Assign the value 10 to the variable x\\njulia> x = 10\\n10\\n\\n# Doing math with x\\'s value\\njulia> x + 1\\n11\\n\\n# Reassign x\\'s value\\njulia> x = 1 + 1\\n2\\n\\n# You can assign values of other types, like strings of text\\njulia> x = \\\"Hello World!\\\"\\n\\\"Hello World!\\\"Julia provides an extremely flexible system for naming variables. Variable names are case-sensitive, and have no semantic meaning (that is, the language will not treat variables differently based on their names).julia> x = 1.0\\n1.0\\n\\njulia> y = -3\\n-3\\n\\njulia> Z = \\\"My string\\\"\\n\\\"My string\\\"\\n\\njulia> customary_phrase = \\\"Hello world!\\\"\\n\\\"Hello world!\\\"\\n\\njulia> UniversalDeclarationOfHumanRightsStart = \\\"\u4eba\u4eba\u751f\u800c\u81ea\u7531\uff0c\u5728\u5c0a\u4e25\u548c\u6743\u5229\u4e0a\u4e00\u5f8b\u5e73\u7b49\u3002\\\"\\n\\\"\u4eba\u4eba\u751f\u800c\u81ea\u7531\uff0c\u5728\u5c0a\u4e25\u548c\u6743\u5229\u4e0a\u4e00\u5f8b\u5e73\u7b49\u3002\\\"Unicode names (in UTF-8 encoding) are allowed:julia> \u03b4 = 0.00001\\n1.0e-5\\n\\njulia> \uc548\ub155\ud558\uc138\uc694 = \\\"Hello\\\"\\n\\\"Hello\\\"In the Julia REPL and several other Julia editing environments, you can type many Unicode math symbols by typing the backslashed LaTeX symbol name followed by tab. For example, the variable name \u03b4 can be entered by typing \\\\delta-tab, or even \u03b1\u0302\u2082 by \\\\alpha-tab-\\\\hat- tab-\\\\_2-tab. (If you find a symbol somewhere, e.g. in someone else\\'s code, that you don\\'t know how to type, the REPL help will tell you: just type ? and then paste the symbol.)Julia will even let you redefine built-in constants and functions if needed (although this is not recommended to avoid potential confusions):julia> pi = 3\\n3\\n\\njulia> pi\\n3\\n\\njulia> sqrt = 4\\n4However, if you try to redefine a built-in constant or function already in use, Julia will give you an error:julia> pi\\n\u03c0 = 3.1415926535897...\\n\\njulia> pi = 3\\nERROR: cannot assign variable MathConstants.pi from module Main\\n\\njulia> sqrt(100)\\n10.0\\n\\njulia> sqrt = 4\\nERROR: cannot assign variable Base.sqrt from module Main\"\n},\n\n{\n    \"location\": \"manual/variables.html#Allowed-Variable-Names-1\",\n    \"page\": \"Variables\",\n    \"title\": \"Allowed Variable Names\",\n    \"category\": \"section\",\n    \"text\": \"Variable names must begin with a letter (A-Z or a-z), underscore, or a subset of Unicode code points greater than 00A0; in particular, Unicode character categories Lu/Ll/Lt/Lm/Lo/Nl (letters), Sc/So (currency and other symbols), and a few other letter-like characters (e.g. a subset of the Sm math symbols) are allowed. Subsequent characters may also include ! and digits (0-9 and other characters in categories Nd/No), as well as other Unicode code points: diacritics and other modifying marks (categories Mn/Mc/Me/Sk), some punctuation connectors (category Pc), primes, and a few other characters.Operators like + are also valid identifiers, but are parsed specially. In some contexts, operators can be used just like variables; for example (+) refers to the addition function, and (+) = f will reassign it. Most of the Unicode infix operators (in category Sm), such as \u2295, are parsed as infix operators and are available for user-defined methods (e.g. you can use const \u2297 = kron to define \u2297 as an infix Kronecker product).  Operators can also be suffixed with modifying marks, primes, and sub/superscripts, e.g. +\u0302\u2090\u2033 is parsed as an infix operator with the same precedence as +.The only explicitly disallowed names for variables are the names of built-in statements:julia> else = false\\nERROR: syntax: unexpected \\\"else\\\"\\n\\njulia> try = \\\"No\\\"\\nERROR: syntax: unexpected \\\"=\\\"Some Unicode characters are considered to be equivalent in identifiers. Different ways of entering Unicode combining characters (e.g., accents) are treated as equivalent (specifically, Julia identifiers are NFC-normalized). The Unicode characters \u025b (U+025B: Latin small letter open e) and \u00b5 (U+00B5: micro sign) are treated as equivalent to the corresponding Greek letters, because the former are easily accessible via some input methods.\"\n},\n\n{\n    \"location\": \"manual/variables.html#Stylistic-Conventions-1\",\n    \"page\": \"Variables\",\n    \"title\": \"Stylistic Conventions\",\n    \"category\": \"section\",\n    \"text\": \"While Julia imposes few restrictions on valid names, it has become useful to adopt the following conventions:Names of variables are in lower case.\\nWord separation can be indicated by underscores (\\'_\\'), but use of underscores is discouraged unless the name would be hard to read otherwise.\\nNames of Types and Modules begin with a capital letter and word separation is shown with upper camel case instead of underscores.\\nNames of functions and macros are in lower case, without underscores.\\nFunctions that write to their arguments have names that end in !. These are sometimes called \\\"mutating\\\" or \\\"in-place\\\" functions because they are intended to produce changes in their arguments after the function is called, not just return a value.For more information about stylistic conventions, see the Style Guide.\"\n},\n\n{\n    \"location\": \"manual/integers-and-floating-point-numbers.html#\",\n    \"page\": \"Integers and Floating-Point Numbers\",\n    \"title\": \"Integers and Floating-Point Numbers\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/integers-and-floating-point-numbers.html#Integers-and-Floating-Point-Numbers-1\",\n    \"page\": \"Integers and Floating-Point Numbers\",\n    \"title\": \"Integers and Floating-Point Numbers\",\n    \"category\": \"section\",\n    \"text\": \"Integers and floating-point values are the basic building blocks of arithmetic and computation. Built-in representations of such values are called numeric primitives, while representations of integers and floating-point numbers as immediate values in code are known as numeric literals. For example, 1 is an integer literal, while 1.0 is a floating-point literal; their binary in-memory representations as objects are numeric primitives.Julia provides a broad range of primitive numeric types, and a full complement of arithmetic and bitwise operators as well as standard mathematical functions are defined over them. These map directly onto numeric types and operations that are natively supported on modern computers, thus allowing Julia to take full advantage of computational resources. Additionally, Julia provides software support for Arbitrary Precision Arithmetic, which can handle operations on numeric values that cannot be represented effectively in native hardware representations, but at the cost of relatively slower performance.The following are Julia\\'s primitive numeric types:Integer types:Type Signed? Number of bits Smallest value Largest value\\nInt8 \u2713 8 -2^7 2^7 - 1\\nUInt8  8 0 2^8 - 1\\nInt16 \u2713 16 -2^15 2^15 - 1\\nUInt16  16 0 2^16 - 1\\nInt32 \u2713 32 -2^31 2^31 - 1\\nUInt32  32 0 2^32 - 1\\nInt64 \u2713 64 -2^63 2^63 - 1\\nUInt64  64 0 2^64 - 1\\nInt128 \u2713 128 -2^127 2^127 - 1\\nUInt128  128 0 2^128 - 1\\nBool N/A 8 false (0) true (1)Floating-point types:Type Precision Number of bits\\nFloat16 half 16\\nFloat32 single 32\\nFloat64 double 64Additionally, full support for Complex and Rational Numbers is built on top of these primitive numeric types. All numeric types interoperate naturally without explicit casting, thanks to a flexible, user-extensible type promotion system.\"\n},\n\n{\n    \"location\": \"manual/integers-and-floating-point-numbers.html#Integers-1\",\n    \"page\": \"Integers and Floating-Point Numbers\",\n    \"title\": \"Integers\",\n    \"category\": \"section\",\n    \"text\": \"Literal integers are represented in the standard manner:julia> 1\\n1\\n\\njulia> 1234\\n1234The default type for an integer literal depends on whether the target system has a 32-bit architecture or a 64-bit architecture:# 32-bit system:\\njulia> typeof(1)\\nInt32\\n\\n# 64-bit system:\\njulia> typeof(1)\\nInt64The Julia internal variable Sys.WORD_SIZE indicates whether the target system is 32-bit or 64-bit:# 32-bit system:\\njulia> Sys.WORD_SIZE\\n32\\n\\n# 64-bit system:\\njulia> Sys.WORD_SIZE\\n64Julia also defines the types Int and UInt, which are aliases for the system\\'s signed and unsigned native integer types respectively:# 32-bit system:\\njulia> Int\\nInt32\\njulia> UInt\\nUInt32\\n\\n# 64-bit system:\\njulia> Int\\nInt64\\njulia> UInt\\nUInt64Larger integer literals that cannot be represented using only 32 bits but can be represented in 64 bits always create 64-bit integers, regardless of the system type:# 32-bit or 64-bit system:\\njulia> typeof(3000000000)\\nInt64Unsigned integers are input and output using the 0x prefix and hexadecimal (base 16) digits 0-9a-f (the capitalized digits A-F also work for input). The size of the unsigned value is determined by the number of hex digits used:julia> 0x1\\n0x01\\n\\njulia> typeof(ans)\\nUInt8\\n\\njulia> 0x123\\n0x0123\\n\\njulia> typeof(ans)\\nUInt16\\n\\njulia> 0x1234567\\n0x01234567\\n\\njulia> typeof(ans)\\nUInt32\\n\\njulia> 0x123456789abcdef\\n0x0123456789abcdef\\n\\njulia> typeof(ans)\\nUInt64\\n\\njulia> 0x11112222333344445555666677778888\\n0x11112222333344445555666677778888\\n\\njulia> typeof(ans)\\nUInt128This behavior is based on the observation that when one uses unsigned hex literals for integer values, one typically is using them to represent a fixed numeric byte sequence, rather than just an integer value.Recall that the variable ans is set to the value of the last expression evaluated in an interactive session. This does not occur when Julia code is run in other ways.Binary and octal literals are also supported:julia> 0b10\\n0x02\\n\\njulia> typeof(ans)\\nUInt8\\n\\njulia> 0o010\\n0x08\\n\\njulia> typeof(ans)\\nUInt8\\n\\njulia> 0x00000000000000001111222233334444\\n0x00000000000000001111222233334444\\n\\njulia> typeof(ans)\\nUInt128As for hexadecimal literals, binary and octal literals produce unsigned integer types. The size of the binary data item is the minimal needed size, if the leading digit of the literal is not 0. In the case of leading zeros, the size is determined by the minimal needed size for a literal, which has the same length but leading digit 1. That allows the user to control the size. Values, which cannot be stored in UInt128 cannot be written as such literals.Binary, octal, and hexadecimal literals may be signed by a - immediately preceding the unsigned literal. They produce an unsigned integer of the same size as the unsigned literal would do, with the two\\'s complement of the value:julia> -0x2\\n0xfe\\n\\njulia> -0x0002\\n0xfffeThe minimum and maximum representable values of primitive numeric types such as integers are given by the typemin and typemax functions:julia> (typemin(Int32), typemax(Int32))\\n(-2147483648, 2147483647)\\n\\njulia> for T in [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]\\n           println(\\\"$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]\\\")\\n       end\\n   Int8: [-128,127]\\n  Int16: [-32768,32767]\\n  Int32: [-2147483648,2147483647]\\n  Int64: [-9223372036854775808,9223372036854775807]\\n Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]\\n  UInt8: [0,255]\\n UInt16: [0,65535]\\n UInt32: [0,4294967295]\\n UInt64: [0,18446744073709551615]\\nUInt128: [0,340282366920938463463374607431768211455]The values returned by typemin and typemax are always of the given argument type. (The above expression uses several features we have yet to introduce, including for loops, Strings, and Interpolation, but should be easy enough to understand for users with some existing programming experience.)\"\n},\n\n{\n    \"location\": \"manual/integers-and-floating-point-numbers.html#Overflow-behavior-1\",\n    \"page\": \"Integers and Floating-Point Numbers\",\n    \"title\": \"Overflow behavior\",\n    \"category\": \"section\",\n    \"text\": \"In Julia, exceeding the maximum representable value of a given type results in a wraparound behavior:julia> x = typemax(Int64)\\n9223372036854775807\\n\\njulia> x + 1\\n-9223372036854775808\\n\\njulia> x + 1 == typemin(Int64)\\ntrueThus, arithmetic with Julia integers is actually a form of modular arithmetic. This reflects the characteristics of the underlying arithmetic of integers as implemented on modern computers. In applications where overflow is possible, explicit checking for wraparound produced by overflow is essential; otherwise, the BigInt type in Arbitrary Precision Arithmetic is recommended instead.\"\n},\n\n{\n    \"location\": \"manual/integers-and-floating-point-numbers.html#Division-errors-1\",\n    \"page\": \"Integers and Floating-Point Numbers\",\n    \"title\": \"Division errors\",\n    \"category\": \"section\",\n    \"text\": \"Integer division (the div function) has two exceptional cases: dividing by zero, and dividing the lowest negative number (typemin) by -1. Both of these cases throw a DivideError. The remainder and modulus functions (rem and mod) throw a DivideError when their second argument is zero.\"\n},\n\n{\n    \"location\": \"manual/integers-and-floating-point-numbers.html#Floating-Point-Numbers-1\",\n    \"page\": \"Integers and Floating-Point Numbers\",\n    \"title\": \"Floating-Point Numbers\",\n    \"category\": \"section\",\n    \"text\": \"Literal floating-point numbers are represented in the standard formats, using E-notation when necessary:julia> 1.0\\n1.0\\n\\njulia> 1.\\n1.0\\n\\njulia> 0.5\\n0.5\\n\\njulia> .5\\n0.5\\n\\njulia> -1.23\\n-1.23\\n\\njulia> 1e10\\n1.0e10\\n\\njulia> 2.5e-4\\n0.00025The above results are all Float64 values. Literal Float32 values can be entered by writing an f in place of e:julia> 0.5f0\\n0.5f0\\n\\njulia> typeof(ans)\\nFloat32\\n\\njulia> 2.5f-4\\n0.00025f0Values can be converted to Float32 easily:julia> Float32(-1.5)\\n-1.5f0\\n\\njulia> typeof(ans)\\nFloat32Hexadecimal floating-point literals are also valid, but only as Float64 values, with p preceding the base-2 exponent:julia> 0x1p0\\n1.0\\n\\njulia> 0x1.8p3\\n12.0\\n\\njulia> 0x.4p-1\\n0.125\\n\\njulia> typeof(ans)\\nFloat64Half-precision floating-point numbers are also supported (Float16), but they are implemented in software and use Float32 for calculations.julia> sizeof(Float16(4.))\\n2\\n\\njulia> 2*Float16(4.)\\nFloat16(8.0)The underscore _ can be used as digit separator:julia> 10_000, 0.000_000_005, 0xdead_beef, 0b1011_0010\\n(10000, 5.0e-9, 0xdeadbeef, 0xb2)\"\n},\n\n{\n    \"location\": \"manual/integers-and-floating-point-numbers.html#Floating-point-zero-1\",\n    \"page\": \"Integers and Floating-Point Numbers\",\n    \"title\": \"Floating-point zero\",\n    \"category\": \"section\",\n    \"text\": \"Floating-point numbers have two zeros, positive zero and negative zero. They are equal to each other but have different binary representations, as can be seen using the bitstring function:julia> 0.0 == -0.0\\ntrue\\n\\njulia> bitstring(0.0)\\n\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\n\\njulia> bitstring(-0.0)\\n\\\"1000000000000000000000000000000000000000000000000000000000000000\\\"\"\n},\n\n{\n    \"location\": \"manual/integers-and-floating-point-numbers.html#Special-floating-point-values-1\",\n    \"page\": \"Integers and Floating-Point Numbers\",\n    \"title\": \"Special floating-point values\",\n    \"category\": \"section\",\n    \"text\": \"There are three specified standard floating-point values that do not correspond to any point on the real number line:Float16 Float32 Float64 Name Description\\nInf16 Inf32 Inf positive infinity a value greater than all finite floating-point values\\n-Inf16 -Inf32 -Inf negative infinity a value less than all finite floating-point values\\nNaN16 NaN32 NaN not a number a value not == to any floating-point value (including itself)For further discussion of how these non-finite floating-point values are ordered with respect to each other and other floats, see Numeric Comparisons. By the IEEE 754 standard, these floating-point values are the results of certain arithmetic operations:julia> 1/Inf\\n0.0\\n\\njulia> 1/0\\nInf\\n\\njulia> -5/0\\n-Inf\\n\\njulia> 0.000001/0\\nInf\\n\\njulia> 0/0\\nNaN\\n\\njulia> 500 + Inf\\nInf\\n\\njulia> 500 - Inf\\n-Inf\\n\\njulia> Inf + Inf\\nInf\\n\\njulia> Inf - Inf\\nNaN\\n\\njulia> Inf * Inf\\nInf\\n\\njulia> Inf / Inf\\nNaN\\n\\njulia> 0 * Inf\\nNaNThe typemin and typemax functions also apply to floating-point types:julia> (typemin(Float16),typemax(Float16))\\n(-Inf16, Inf16)\\n\\njulia> (typemin(Float32),typemax(Float32))\\n(-Inf32, Inf32)\\n\\njulia> (typemin(Float64),typemax(Float64))\\n(-Inf, Inf)\"\n},\n\n{\n    \"location\": \"manual/integers-and-floating-point-numbers.html#Machine-epsilon-1\",\n    \"page\": \"Integers and Floating-Point Numbers\",\n    \"title\": \"Machine epsilon\",\n    \"category\": \"section\",\n    \"text\": \"Most real numbers cannot be represented exactly with floating-point numbers, and so for many purposes it is important to know the distance between two adjacent representable floating-point numbers, which is often known as machine epsilon.Julia provides eps, which gives the distance between 1.0 and the next larger representable floating-point value:julia> eps(Float32)\\n1.1920929f-7\\n\\njulia> eps(Float64)\\n2.220446049250313e-16\\n\\njulia> eps() # same as eps(Float64)\\n2.220446049250313e-16These values are 2.0^-23 and 2.0^-52 as Float32 and Float64 values, respectively. The eps function can also take a floating-point value as an argument, and gives the absolute difference between that value and the next representable floating point value. That is, eps(x) yields a value of the same type as x such that x + eps(x) is the next representable floating-point value larger than x:julia> eps(1.0)\\n2.220446049250313e-16\\n\\njulia> eps(1000.)\\n1.1368683772161603e-13\\n\\njulia> eps(1e-27)\\n1.793662034335766e-43\\n\\njulia> eps(0.0)\\n5.0e-324The distance between two adjacent representable floating-point numbers is not constant, but is smaller for smaller values and larger for larger values. In other words, the representable floating-point numbers are densest in the real number line near zero, and grow sparser exponentially as one moves farther away from zero. By definition, eps(1.0) is the same as eps(Float64) since 1.0 is a 64-bit floating-point value.Julia also provides the nextfloat and prevfloat functions which return the next largest or smallest representable floating-point number to the argument respectively:julia> x = 1.25f0\\n1.25f0\\n\\njulia> nextfloat(x)\\n1.2500001f0\\n\\njulia> prevfloat(x)\\n1.2499999f0\\n\\njulia> bitstring(prevfloat(x))\\n\\\"00111111100111111111111111111111\\\"\\n\\njulia> bitstring(x)\\n\\\"00111111101000000000000000000000\\\"\\n\\njulia> bitstring(nextfloat(x))\\n\\\"00111111101000000000000000000001\\\"This example highlights the general principle that the adjacent representable floating-point numbers also have adjacent binary integer representations.\"\n},\n\n{\n    \"location\": \"manual/integers-and-floating-point-numbers.html#Rounding-modes-1\",\n    \"page\": \"Integers and Floating-Point Numbers\",\n    \"title\": \"Rounding modes\",\n    \"category\": \"section\",\n    \"text\": \"If a number doesn\\'t have an exact floating-point representation, it must be rounded to an appropriate representable value. However, the manner in which this rounding is done can be changed if required according to the rounding modes presented in the IEEE 754 standard.The default mode used is always RoundNearest, which rounds to the nearest representable value, with ties rounded towards the nearest value with an even least significant bit.\"\n},\n\n{\n    \"location\": \"manual/integers-and-floating-point-numbers.html#Background-and-References-1\",\n    \"page\": \"Integers and Floating-Point Numbers\",\n    \"title\": \"Background and References\",\n    \"category\": \"section\",\n    \"text\": \"Floating-point arithmetic entails many subtleties which can be surprising to users who are unfamiliar with the low-level implementation details. However, these subtleties are described in detail in most books on scientific computation, and also in the following references:The definitive guide to floating point arithmetic is the IEEE 754-2008 Standard; however, it is not available for free online.\\nFor a brief but lucid presentation of how floating-point numbers are represented, see John D. Cook\\'s article on the subject as well as his introduction to some of the issues arising from how this representation differs in behavior from the idealized abstraction of real numbers.\\nAlso recommended is Bruce Dawson\\'s series of blog posts on floating-point numbers.\\nFor an excellent, in-depth discussion of floating-point numbers and issues of numerical accuracy encountered when computing with them, see David Goldberg\\'s paper What Every Computer Scientist Should Know About Floating-Point Arithmetic.\\nFor even more extensive documentation of the history of, rationale for, and issues with floating-point numbers, as well as discussion of many other topics in numerical computing, see the collected writings of William Kahan, commonly known as the \\\"Father of Floating-Point\\\". Of particular interest may be An Interview with the Old Man of Floating-Point.\"\n},\n\n{\n    \"location\": \"manual/integers-and-floating-point-numbers.html#Arbitrary-Precision-Arithmetic-1\",\n    \"page\": \"Integers and Floating-Point Numbers\",\n    \"title\": \"Arbitrary Precision Arithmetic\",\n    \"category\": \"section\",\n    \"text\": \"To allow computations with arbitrary-precision integers and floating point numbers, Julia wraps the GNU Multiple Precision Arithmetic Library (GMP) and the GNU MPFR Library, respectively. The BigInt and BigFloat types are available in Julia for arbitrary precision integer and floating point numbers respectively.Constructors exist to create these types from primitive numerical types, and parse can be used to construct them from AbstractStrings.  Once created, they participate in arithmetic with all other numeric types thanks to Julia\\'s type promotion and conversion mechanism:julia> BigInt(typemax(Int64)) + 1\\n9223372036854775808\\n\\njulia> parse(BigInt, \\\"123456789012345678901234567890\\\") + 1\\n123456789012345678901234567891\\n\\njulia> parse(BigFloat, \\\"1.23456789012345678901\\\")\\n1.234567890123456789010000000000000000000000000000000000000000000000000000000004\\n\\njulia> BigFloat(2.0^66) / 3\\n2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19\\n\\njulia> factorial(BigInt(40))\\n815915283247897734345611269596115894272000000000However, type promotion between the primitive types above and BigInt/BigFloat is not automatic and must be explicitly stated.julia> x = typemin(Int64)\\n-9223372036854775808\\n\\njulia> x = x - 1\\n9223372036854775807\\n\\njulia> typeof(x)\\nInt64\\n\\njulia> y = BigInt(typemin(Int64))\\n-9223372036854775808\\n\\njulia> y = y - 1\\n-9223372036854775809\\n\\njulia> typeof(y)\\nBigIntThe default precision (in number of bits of the significand) and rounding mode of BigFloat operations can be changed globally by calling setprecision and setrounding, and all further calculations will take these changes in account.  Alternatively, the precision or the rounding can be changed only within the execution of a particular block of code by using the same functions with a do block:julia> setrounding(BigFloat, RoundUp) do\\n           BigFloat(1) + parse(BigFloat, \\\"0.1\\\")\\n       end\\n1.100000000000000000000000000000000000000000000000000000000000000000000000000003\\n\\njulia> setrounding(BigFloat, RoundDown) do\\n           BigFloat(1) + parse(BigFloat, \\\"0.1\\\")\\n       end\\n1.099999999999999999999999999999999999999999999999999999999999999999999999999986\\n\\njulia> setprecision(40) do\\n           BigFloat(1) + parse(BigFloat, \\\"0.1\\\")\\n       end\\n1.1000000000004\"\n},\n\n{\n    \"location\": \"manual/integers-and-floating-point-numbers.html#man-numeric-literal-coefficients-1\",\n    \"page\": \"Integers and Floating-Point Numbers\",\n    \"title\": \"Numeric Literal Coefficients\",\n    \"category\": \"section\",\n    \"text\": \"To make common numeric formulae and expressions clearer, Julia allows variables to be immediately preceded by a numeric literal, implying multiplication. This makes writing polynomial expressions much cleaner:julia> x = 3\\n3\\n\\njulia> 2x^2 - 3x + 1\\n10\\n\\njulia> 1.5x^2 - .5x + 1\\n13.0It also makes writing exponential functions more elegant:julia> 2^2x\\n64The precedence of numeric literal coefficients is slightly lower than that of unary operators such as negation. So -2x is parsed as (-2) * x and \u221a2x is parsed as (\u221a2) * x. However, numeric literal coefficients parse similarly to unary operators when combined with exponentiation. For example 2^3x is parsed as 2^(3x), and 2x^3 is parsed as 2*(x^3).Numeric literals also work as coefficients to parenthesized expressions:julia> 2(x-1)^2 - 3(x-1) + 1\\n3note: Note\\nThe precedence of numeric literal coefficients used for implicit multiplication is higher than other binary operators such as multiplication (*), and division (/, \\\\, and //).  This means, for example, that 1 / 2im equals -0.5im and 6 // 2(2 + 1) equals 1 // 1.Additionally, parenthesized expressions can be used as coefficients to variables, implying multiplication of the expression by the variable:julia> (x-1)x\\n6Neither juxtaposition of two parenthesized expressions, nor placing a variable before a parenthesized expression, however, can be used to imply multiplication:julia> (x-1)(x+1)\\nERROR: MethodError: objects of type Int64 are not callable\\n\\njulia> x(x+1)\\nERROR: MethodError: objects of type Int64 are not callableBoth expressions are interpreted as function application: any expression that is not a numeric literal, when immediately followed by a parenthetical, is interpreted as a function applied to the values in parentheses (see Functions for more about functions). Thus, in both of these cases, an error occurs since the left-hand value is not a function.The above syntactic enhancements significantly reduce the visual noise incurred when writing common mathematical formulae. Note that no whitespace may come between a numeric literal coefficient and the identifier or parenthesized expression which it multiplies.\"\n},\n\n{\n    \"location\": \"manual/integers-and-floating-point-numbers.html#Syntax-Conflicts-1\",\n    \"page\": \"Integers and Floating-Point Numbers\",\n    \"title\": \"Syntax Conflicts\",\n    \"category\": \"section\",\n    \"text\": \"Juxtaposed literal coefficient syntax may conflict with two numeric literal syntaxes: hexadecimal integer literals and engineering notation for floating-point literals. Here are some situations where syntactic conflicts arise:The hexadecimal integer literal expression 0xff could be interpreted as the numeric literal 0 multiplied by the variable xff.\\nThe floating-point literal expression 1e10 could be interpreted as the numeric literal 1 multiplied by the variable e10, and similarly with the equivalent E form.\\nThe 32-bit floating-point literal expression 1.5f22 could be interpreted as the numeric literal 1.5 multiplied by the variable f22.In all cases, we resolve the ambiguity in favor of interpretation as numeric literals:Expressions starting with 0x are always hexadecimal literals.\\nExpressions starting with a numeric literal followed by e or E are always floating-point literals.\\nExpressions starting with a numeric literal followed by f are always 32-bit floating-point literals.Unlike E, which is equivalent to e in numeric literals for historical reasons, F is just another letter and does not behave like f in numeric literals. Hence, expressions starting with a numeric literal followed by F are interpreted as the numerical literal multiplied by a variable, which means that, for example, 1.5F22 is equal to 1.5 * F22.\"\n},\n\n{\n    \"location\": \"manual/integers-and-floating-point-numbers.html#Literal-zero-and-one-1\",\n    \"page\": \"Integers and Floating-Point Numbers\",\n    \"title\": \"Literal zero and one\",\n    \"category\": \"section\",\n    \"text\": \"Julia provides functions which return literal 0 and 1 corresponding to a specified type or the type of a given variable.Function Description\\nzero(x) Literal zero of type x or type of variable x\\none(x) Literal one of type x or type of variable xThese functions are useful in Numeric Comparisons to avoid overhead from unnecessary type conversion.Examples:julia> zero(Float32)\\n0.0f0\\n\\njulia> zero(1.0)\\n0.0\\n\\njulia> one(Int32)\\n1\\n\\njulia> one(BigFloat)\\n1.0\"\n},\n\n{\n    \"location\": \"manual/mathematical-operations.html#\",\n    \"page\": \"Mathematical Operations and Elementary Functions\",\n    \"title\": \"Mathematical Operations and Elementary Functions\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/mathematical-operations.html#Mathematical-Operations-and-Elementary-Functions-1\",\n    \"page\": \"Mathematical Operations and Elementary Functions\",\n    \"title\": \"Mathematical Operations and Elementary Functions\",\n    \"category\": \"section\",\n    \"text\": \"Julia provides a complete collection of basic arithmetic and bitwise operators across all of its numeric primitive types, as well as providing portable, efficient implementations of a comprehensive collection of standard mathematical functions.\"\n},\n\n{\n    \"location\": \"manual/mathematical-operations.html#Arithmetic-Operators-1\",\n    \"page\": \"Mathematical Operations and Elementary Functions\",\n    \"title\": \"Arithmetic Operators\",\n    \"category\": \"section\",\n    \"text\": \"The following arithmetic operators are supported on all primitive numeric types:Expression Name Description\\n+x unary plus the identity operation\\n-x unary minus maps values to their additive inverses\\nx + y binary plus performs addition\\nx - y binary minus performs subtraction\\nx * y times performs multiplication\\nx / y divide performs division\\nx \u00f7 y integer divide x / y, truncated to an integer\\nx \\\\ y inverse divide equivalent to y / x\\nx ^ y power raises x to the yth power\\nx % y remainder equivalent to rem(x,y)as well as the negation on Bool types:Expression Name Description\\n!x negation changes true to false and vice versaJulia\\'s promotion system makes arithmetic operations on mixtures of argument types \\\"just work\\\" naturally and automatically. See Conversion and Promotion for details of the promotion system.Here are some simple examples using arithmetic operators:julia> 1 + 2 + 3\\n6\\n\\njulia> 1 - 2\\n-1\\n\\njulia> 3*2/12\\n0.5(By convention, we tend to space operators more tightly if they get applied before other nearby operators. For instance, we would generally write -x + 2 to reflect that first x gets negated, and then 2 is added to that result.)\"\n},\n\n{\n    \"location\": \"manual/mathematical-operations.html#Bitwise-Operators-1\",\n    \"page\": \"Mathematical Operations and Elementary Functions\",\n    \"title\": \"Bitwise Operators\",\n    \"category\": \"section\",\n    \"text\": \"The following bitwise operators are supported on all primitive integer types:Expression Name\\n~x bitwise not\\nx & y bitwise and\\nx | y bitwise or\\nx \u22bb y bitwise xor (exclusive or)\\nx >>> y logical shift right\\nx >> y arithmetic shift right\\nx << y logical/arithmetic shift leftHere are some examples with bitwise operators:julia> ~123\\n-124\\n\\njulia> 123 & 234\\n106\\n\\njulia> 123 | 234\\n251\\n\\njulia> 123 \u22bb 234\\n145\\n\\njulia> xor(123, 234)\\n145\\n\\njulia> ~UInt32(123)\\n0xffffff84\\n\\njulia> ~UInt8(123)\\n0x84\"\n},\n\n{\n    \"location\": \"manual/mathematical-operations.html#Updating-operators-1\",\n    \"page\": \"Mathematical Operations and Elementary Functions\",\n    \"title\": \"Updating operators\",\n    \"category\": \"section\",\n    \"text\": \"Every binary arithmetic and bitwise operator also has an updating version that assigns the result of the operation back into its left operand. The updating version of the binary operator is formed by placing a = immediately after the operator. For example, writing x += 3 is equivalent to writing x = x + 3:julia> x = 1\\n1\\n\\njulia> x += 3\\n4\\n\\njulia> x\\n4The updating versions of all the binary arithmetic and bitwise operators are:+=  -=  *=  /=  \\\\=  \u00f7=  %=  ^=  &=  |=  \u22bb=  >>>=  >>=  <<=note: Note\\nAn updating operator rebinds the variable on the left-hand side. As a result, the type of the variable may change.julia> x = 0x01; typeof(x)\\nUInt8\\n\\njulia> x *= 2 # Same as x = x * 2\\n2\\n\\njulia> typeof(x)\\nInt64\"\n},\n\n{\n    \"location\": \"manual/mathematical-operations.html#man-dot-operators-1\",\n    \"page\": \"Mathematical Operations and Elementary Functions\",\n    \"title\": \"Vectorized \\\"dot\\\" operators\",\n    \"category\": \"section\",\n    \"text\": \"For every binary operation like ^, there is a corresponding \\\"dot\\\" operation .^ that is automatically defined to perform ^ element-by-element on arrays. For example, [1,2,3] ^ 3 is not defined, since there is no standard mathematical meaning to \\\"cubing\\\" a (non-square) array, but [1,2,3] .^ 3 is defined as computing the elementwise (or \\\"vectorized\\\") result [1^3, 2^3, 3^3].  Similarly for unary operators like ! or \u221a, there is a corresponding .\u221a that applies the operator elementwise.julia> [1,2,3] .^ 3\\n3-element Array{Int64,1}:\\n  1\\n  8\\n 27More specifically, a .^ b is parsed as the \\\"dot\\\" call (^).(a,b), which performs a broadcast operation: it can combine arrays and scalars, arrays of the same size (performing the operation elementwise), and even arrays of different shapes (e.g. combining row and column vectors to produce a matrix). Moreover, like all vectorized \\\"dot calls,\\\" these \\\"dot operators\\\" are fusing. For example, if you compute 2 .* A.^2 .+ sin.(A) (or equivalently @. 2A^2 + sin(A), using the @. macro) for an array A, it performs a single loop over A, computing 2a^2 + sin(a) for each element of A. In particular, nested dot calls like f.(g.(x)) are fused, and \\\"adjacent\\\" binary operators like x .+ 3 .* x.^2 are equivalent to nested dot calls (+).(x, (*).(3, (^).(x, 2))).Furthermore, \\\"dotted\\\" updating operators like a .+= b (or @. a += b) are parsed as a .= a .+ b, where .= is a fused in-place assignment operation (see the dot syntax documentation).Note the dot syntax is also applicable to user-defined operators. For example, if you define \u2297(A,B) = kron(A,B) to give a convenient infix syntax A \u2297 B for Kronecker products (kron), then [A,B] .\u2297 [C,D] will compute [A\u2297C, B\u2297D] with no additional coding.Combining dot operators with numeric literals can be ambiguous. For example, it is not clear whether 1.+x means 1. + x or 1 .+ x. Therefore this syntax is disallowed, and spaces must be used around the operator in such cases.\"\n},\n\n{\n    \"location\": \"manual/mathematical-operations.html#Numeric-Comparisons-1\",\n    \"page\": \"Mathematical Operations and Elementary Functions\",\n    \"title\": \"Numeric Comparisons\",\n    \"category\": \"section\",\n    \"text\": \"Standard comparison operations are defined for all the primitive numeric types:Operator Name\\n== equality\\n!=, \u2260 inequality\\n< less than\\n<=, \u2264 less than or equal to\\n> greater than\\n>=, \u2265 greater than or equal toHere are some simple examples:julia> 1 == 1\\ntrue\\n\\njulia> 1 == 2\\nfalse\\n\\njulia> 1 != 2\\ntrue\\n\\njulia> 1 == 1.0\\ntrue\\n\\njulia> 1 < 2\\ntrue\\n\\njulia> 1.0 > 3\\nfalse\\n\\njulia> 1 >= 1.0\\ntrue\\n\\njulia> -1 <= 1\\ntrue\\n\\njulia> -1 <= -1\\ntrue\\n\\njulia> -1 <= -2\\nfalse\\n\\njulia> 3 < -0.5\\nfalseIntegers are compared in the standard manner \u2013 by comparison of bits. Floating-point numbers are compared according to the IEEE 754 standard:Finite numbers are ordered in the usual manner.\\nPositive zero is equal but not greater than negative zero.\\nInf is equal to itself and greater than everything else except NaN.\\n-Inf is equal to itself and less then everything else except NaN.\\nNaN is not equal to, not less than, and not greater than anything, including itself.The last point is potentially surprising and thus worth noting:julia> NaN == NaN\\nfalse\\n\\njulia> NaN != NaN\\ntrue\\n\\njulia> NaN < NaN\\nfalse\\n\\njulia> NaN > NaN\\nfalseand can cause especial headaches with arrays:julia> [1 NaN] == [1 NaN]\\nfalseJulia provides additional functions to test numbers for special values, which can be useful in situations like hash key comparisons:Function Tests if\\nisequal(x, y) x and y are identical\\nisfinite(x) x is a finite number\\nisinf(x) x is infinite\\nisnan(x) x is not a numberisequal considers NaNs equal to each other:julia> isequal(NaN, NaN)\\ntrue\\n\\njulia> isequal([1 NaN], [1 NaN])\\ntrue\\n\\njulia> isequal(NaN, NaN32)\\ntrueisequal can also be used to distinguish signed zeros:julia> -0.0 == 0.0\\ntrue\\n\\njulia> isequal(-0.0, 0.0)\\nfalseMixed-type comparisons between signed integers, unsigned integers, and floats can be tricky. A great deal of care has been taken to ensure that Julia does them correctly.For other types, isequal defaults to calling ==, so if you want to define equality for your own types then you only need to add a == method.  If you define your own equality function, you should probably define a corresponding hash method to ensure that isequal(x,y) implies hash(x) == hash(y).\"\n},\n\n{\n    \"location\": \"manual/mathematical-operations.html#Chaining-comparisons-1\",\n    \"page\": \"Mathematical Operations and Elementary Functions\",\n    \"title\": \"Chaining comparisons\",\n    \"category\": \"section\",\n    \"text\": \"Unlike most languages, with the notable exception of Python, comparisons can be arbitrarily chained:julia> 1 < 2 <= 2 < 3 == 3 > 2 >= 1 == 1 < 3 != 5\\ntrueChaining comparisons is often quite convenient in numerical code. Chained comparisons use the && operator for scalar comparisons, and the & operator for elementwise comparisons, which allows them to work on arrays. For example, 0 .< A .< 1 gives a boolean array whose entries are true where the corresponding elements of A are between 0 and 1.Note the evaluation behavior of chained comparisons:julia> v(x) = (println(x); x)\\nv (generic function with 1 method)\\n\\njulia> v(1) < v(2) <= v(3)\\n2\\n1\\n3\\ntrue\\n\\njulia> v(1) > v(2) <= v(3)\\n2\\n1\\nfalseThe middle expression is only evaluated once, rather than twice as it would be if the expression were written as v(1) < v(2) && v(2) <= v(3). However, the order of evaluations in a chained comparison is undefined. It is strongly recommended not to use expressions with side effects (such as printing) in chained comparisons. If side effects are required, the short-circuit && operator should be used explicitly (see Short-Circuit Evaluation).\"\n},\n\n{\n    \"location\": \"manual/mathematical-operations.html#Elementary-Functions-1\",\n    \"page\": \"Mathematical Operations and Elementary Functions\",\n    \"title\": \"Elementary Functions\",\n    \"category\": \"section\",\n    \"text\": \"Julia provides a comprehensive collection of mathematical functions and operators. These mathematical operations are defined over as broad a class of numerical values as permit sensible definitions, including integers, floating-point numbers, rationals, and complex numbers, wherever such definitions make sense.Moreover, these functions (like any Julia function) can be applied in \\\"vectorized\\\" fashion to arrays and other collections with the dot syntax f.(A), e.g. sin.(A) will compute the sine of each element of an array A.\"\n},\n\n{\n    \"location\": \"manual/mathematical-operations.html#Operator-Precedence-and-Associativity-1\",\n    \"page\": \"Mathematical Operations and Elementary Functions\",\n    \"title\": \"Operator Precedence and Associativity\",\n    \"category\": \"section\",\n    \"text\": \"Julia applies the following order and associativity of operations, from highest precedence to lowest:Category Operators Associativity\\nSyntax . followed by :: Left\\nExponentiation ^ Right\\nUnary + - \u221a Right[1]\\nBitshifts << >> >>> Left\\nFractions // Left\\nMultiplication * / % & \\\\ \u00f7 Left[2]\\nAddition + - | \u22bb Left[2]\\nSyntax : .. Left\\nSyntax |> Left\\nSyntax <| Right\\nComparisons > < >= <= == === != !== <: Non-associative\\nControl flow && followed by || followed by ? Right\\nPair => Right\\nAssignments = += -= *= /= //= \\\\= ^= \u00f7= %= |= &= \u22bb= <<= >>= >>>= Right[1]: The unary operators + and - require explicit parentheses around their argument to disambiguate them from the operator ++, etc. Other compositions of unary operators are parsed with right-associativity, e. g., \u221a\u221a-a as \u221a(\u221a(-a)).[2]: The operators +, ++ and * are non-associative. a + b + c is parsed as +(a, b, c) not +(+(a, b), c). However, the fallback methods for +(a, b, c, d...) and *(a, b, c, d...) both default to left-associative evaluation.For a complete list of every Julia operator\\'s precedence, see the top of this file: src/julia-parser.scmYou can also find the numerical precedence for any given operator via the built-in function Base.operator_precedence, where higher numbers take precedence:julia> Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)\\n(11, 13, 17)\\n\\njulia> Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (Note the necessary parens on `:(=)`)\\n(0, 1, 1)A symbol representing the operator associativity can also be found by calling the built-in function Base.operator_associativity:julia> Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)\\n(:left, :none, :right)\\n\\njulia> Base.operator_associativity(:\u2297), Base.operator_associativity(:sin), Base.operator_associativity(:\u2192)\\n(:left, :none, :right)Note that symbols such as :sin return precedence 0. This value represents invalid operators and not operators of lowest precedence. Similarly, such operators are assigned associativity :none.\"\n},\n\n{\n    \"location\": \"manual/mathematical-operations.html#Numerical-Conversions-1\",\n    \"page\": \"Mathematical Operations and Elementary Functions\",\n    \"title\": \"Numerical Conversions\",\n    \"category\": \"section\",\n    \"text\": \"Julia supports three forms of numerical conversion, which differ in their handling of inexact conversions.The notation T(x) or convert(T,x) converts x to a value of type T.\\nIf T is a floating-point type, the result is the nearest representable value, which could be positive or negative infinity.\\nIf T is an integer type, an InexactError is raised if x is not representable by T.\\nx % T converts an integer x to a value of integer type T congruent to x modulo 2^n, where n is the number of bits in T. In other words, the binary representation is truncated to fit.\\nThe Rounding functions take a type T as an optional argument. For example, round(Int,x) is a shorthand for Int(round(x)).The following examples show the different forms.julia> Int8(127)\\n127\\n\\njulia> Int8(128)\\nERROR: InexactError: trunc(Int8, 128)\\nStacktrace:\\n[...]\\n\\njulia> Int8(127.0)\\n127\\n\\njulia> Int8(3.14)\\nERROR: InexactError: Int8(Int8, 3.14)\\nStacktrace:\\n[...]\\n\\njulia> Int8(128.0)\\nERROR: InexactError: Int8(Int8, 128.0)\\nStacktrace:\\n[...]\\n\\njulia> 127 % Int8\\n127\\n\\njulia> 128 % Int8\\n-128\\n\\njulia> round(Int8,127.4)\\n127\\n\\njulia> round(Int8,127.6)\\nERROR: InexactError: trunc(Int8, 128.0)\\nStacktrace:\\n[...]See Conversion and Promotion for how to define your own conversions and promotions.\"\n},\n\n{\n    \"location\": \"manual/mathematical-operations.html#Rounding-functions-1\",\n    \"page\": \"Mathematical Operations and Elementary Functions\",\n    \"title\": \"Rounding functions\",\n    \"category\": \"section\",\n    \"text\": \"Function Description Return type\\nround(x) round x to the nearest integer typeof(x)\\nround(T, x) round x to the nearest integer T\\nfloor(x) round x towards -Inf typeof(x)\\nfloor(T, x) round x towards -Inf T\\nceil(x) round x towards +Inf typeof(x)\\nceil(T, x) round x towards +Inf T\\ntrunc(x) round x towards zero typeof(x)\\ntrunc(T, x) round x towards zero T\"\n},\n\n{\n    \"location\": \"manual/mathematical-operations.html#Division-functions-1\",\n    \"page\": \"Mathematical Operations and Elementary Functions\",\n    \"title\": \"Division functions\",\n    \"category\": \"section\",\n    \"text\": \"Function Description\\ndiv(x,y), x\u00f7y truncated division; quotient rounded towards zero\\nfld(x,y) floored division; quotient rounded towards -Inf\\ncld(x,y) ceiling division; quotient rounded towards +Inf\\nrem(x,y) remainder; satisfies x == div(x,y)*y + rem(x,y); sign matches x\\nmod(x,y) modulus; satisfies x == fld(x,y)*y + mod(x,y); sign matches y\\nmod1(x,y) mod with offset 1; returns r\u2208(0,y] for y>0 or r\u2208[y,0) for y<0, where mod(r, y) == mod(x, y)\\nmod2pi(x) modulus with respect to 2pi;  0 <= mod2pi(x) \u00a0  < 2pi\\ndivrem(x,y) returns (div(x,y),rem(x,y))\\nfldmod(x,y) returns (fld(x,y),mod(x,y))\\ngcd(x,y...) greatest positive common divisor of x, y,...\\nlcm(x,y...) least positive common multiple of x, y,...\"\n},\n\n{\n    \"location\": \"manual/mathematical-operations.html#Sign-and-absolute-value-functions-1\",\n    \"page\": \"Mathematical Operations and Elementary Functions\",\n    \"title\": \"Sign and absolute value functions\",\n    \"category\": \"section\",\n    \"text\": \"Function Description\\nabs(x) a positive value with the magnitude of x\\nabs2(x) the squared magnitude of x\\nsign(x) indicates the sign of x, returning -1, 0, or +1\\nsignbit(x) indicates whether the sign bit is on (true) or off (false)\\ncopysign(x,y) a value with the magnitude of x and the sign of y\\nflipsign(x,y) a value with the magnitude of x and the sign of x*y\"\n},\n\n{\n    \"location\": \"manual/mathematical-operations.html#Powers,-logs-and-roots-1\",\n    \"page\": \"Mathematical Operations and Elementary Functions\",\n    \"title\": \"Powers, logs and roots\",\n    \"category\": \"section\",\n    \"text\": \"Function Description\\nsqrt(x), \u221ax square root of x\\ncbrt(x), \u221bx cube root of x\\nhypot(x,y) hypotenuse of right-angled triangle with other sides of length x and y\\nexp(x) natural exponential function at x\\nexpm1(x) accurate exp(x)-1 for x near zero\\nldexp(x,n) x*2^n computed efficiently for integer values of n\\nlog(x) natural logarithm of x\\nlog(b,x) base b logarithm of x\\nlog2(x) base 2 logarithm of x\\nlog10(x) base 10 logarithm of x\\nlog1p(x) accurate log(1+x) for x near zero\\nexponent(x) binary exponent of x\\nsignificand(x) binary significand (a.k.a. mantissa) of a floating-point number xFor an overview of why functions like hypot, expm1, and log1p are necessary and useful, see John D. Cook\\'s excellent pair of blog posts on the subject: expm1, log1p, erfc, and hypot.\"\n},\n\n{\n    \"location\": \"manual/mathematical-operations.html#Trigonometric-and-hyperbolic-functions-1\",\n    \"page\": \"Mathematical Operations and Elementary Functions\",\n    \"title\": \"Trigonometric and hyperbolic functions\",\n    \"category\": \"section\",\n    \"text\": \"All the standard trigonometric and hyperbolic functions are also defined:sin    cos    tan    cot    sec    csc\\nsinh   cosh   tanh   coth   sech   csch\\nasin   acos   atan   acot   asec   acsc\\nasinh  acosh  atanh  acoth  asech  acsch\\nsinc   coscThese are all single-argument functions, with atan also accepting two arguments corresponding to a traditional atan2 function.Additionally, sinpi(x) and cospi(x) are provided for more accurate computations of sin(pi*x) and cos(pi*x) respectively.In order to compute trigonometric functions with degrees instead of radians, suffix the function with d. For example, sind(x) computes the sine of x where x is specified in degrees. The complete list of trigonometric functions with degree variants is:sind   cosd   tand   cotd   secd   cscd\\nasind  acosd  atand  acotd  asecd  acscd\"\n},\n\n{\n    \"location\": \"manual/mathematical-operations.html#Special-functions-1\",\n    \"page\": \"Mathematical Operations and Elementary Functions\",\n    \"title\": \"Special functions\",\n    \"category\": \"section\",\n    \"text\": \"Many other special mathematical functions are provided by the package SpecialFunctions.jl.\"\n},\n\n{\n    \"location\": \"manual/complex-and-rational-numbers.html#\",\n    \"page\": \"Complex and Rational Numbers\",\n    \"title\": \"Complex and Rational Numbers\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/complex-and-rational-numbers.html#Complex-and-Rational-Numbers-1\",\n    \"page\": \"Complex and Rational Numbers\",\n    \"title\": \"Complex and Rational Numbers\",\n    \"category\": \"section\",\n    \"text\": \"Julia ships with predefined types representing both complex and rational numbers, and supports all standard Mathematical Operations and Elementary Functions on them. Conversion and Promotion are defined so that operations on any combination of predefined numeric types, whether primitive or composite, behave as expected.\"\n},\n\n{\n    \"location\": \"manual/complex-and-rational-numbers.html#Complex-Numbers-1\",\n    \"page\": \"Complex and Rational Numbers\",\n    \"title\": \"Complex Numbers\",\n    \"category\": \"section\",\n    \"text\": \"The global constant im is bound to the complex number i, representing the principal square root of -1. It was deemed harmful to co-opt the name i for a global constant, since it is such a popular index variable name. Since Julia allows numeric literals to be juxtaposed with identifiers as coefficients, this binding suffices to provide convenient syntax for complex numbers, similar to the traditional mathematical notation:julia> 1 + 2im\\n1 + 2imYou can perform all the standard arithmetic operations with complex numbers:julia> (1 + 2im)*(2 - 3im)\\n8 + 1im\\n\\njulia> (1 + 2im)/(1 - 2im)\\n-0.6 + 0.8im\\n\\njulia> (1 + 2im) + (1 - 2im)\\n2 + 0im\\n\\njulia> (-3 + 2im) - (5 - 1im)\\n-8 + 3im\\n\\njulia> (-1 + 2im)^2\\n-3 - 4im\\n\\njulia> (-1 + 2im)^2.5\\n2.729624464784009 - 6.9606644595719im\\n\\njulia> (-1 + 2im)^(1 + 1im)\\n-0.27910381075826657 + 0.08708053414102428im\\n\\njulia> 3(2 - 5im)\\n6 - 15im\\n\\njulia> 3(2 - 5im)^2\\n-63 - 60im\\n\\njulia> 3(2 - 5im)^-1.0\\n0.20689655172413796 + 0.5172413793103449imThe promotion mechanism ensures that combinations of operands of different types just work:julia> 2(1 - 1im)\\n2 - 2im\\n\\njulia> (2 + 3im) - 1\\n1 + 3im\\n\\njulia> (1 + 2im) + 0.5\\n1.5 + 2.0im\\n\\njulia> (2 + 3im) - 0.5im\\n2.0 + 2.5im\\n\\njulia> 0.75(1 + 2im)\\n0.75 + 1.5im\\n\\njulia> (2 + 3im) / 2\\n1.0 + 1.5im\\n\\njulia> (1 - 3im) / (2 + 2im)\\n-0.5 - 1.0im\\n\\njulia> 2im^2\\n-2 + 0im\\n\\njulia> 1 + 3/4im\\n1.0 - 0.75imNote that 3/4im == 3/(4*im) == -(3/4*im), since a literal coefficient binds more tightly than division.Standard functions to manipulate complex values are provided:julia> z = 1 + 2im\\n1 + 2im\\n\\njulia> real(1 + 2im) # real part of z\\n1\\n\\njulia> imag(1 + 2im) # imaginary part of z\\n2\\n\\njulia> conj(1 + 2im) # complex conjugate of z\\n1 - 2im\\n\\njulia> abs(1 + 2im) # absolute value of z\\n2.23606797749979\\n\\njulia> abs2(1 + 2im) # squared absolute value\\n5\\n\\njulia> angle(1 + 2im) # phase angle in radians\\n1.1071487177940904As usual, the absolute value (abs) of a complex number is its distance from zero. abs2 gives the square of the absolute value, and is of particular use for complex numbers where it avoids taking a square root. angle returns the phase angle in radians (also known as the argument or arg function). The full gamut of other Elementary Functions is also defined for complex numbers:julia> sqrt(1im)\\n0.7071067811865476 + 0.7071067811865475im\\n\\njulia> sqrt(1 + 2im)\\n1.272019649514069 + 0.7861513777574233im\\n\\njulia> cos(1 + 2im)\\n2.0327230070196656 - 3.0518977991518im\\n\\njulia> exp(1 + 2im)\\n-1.1312043837568135 + 2.4717266720048188im\\n\\njulia> sinh(1 + 2im)\\n-0.4890562590412937 + 1.4031192506220405imNote that mathematical functions typically return real values when applied to real numbers and complex values when applied to complex numbers. For example, sqrt behaves differently when applied to -1 versus -1 + 0im even though -1 == -1 + 0im:julia> sqrt(-1)\\nERROR: DomainError with -1.0:\\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\\nStacktrace:\\n[...]\\n\\njulia> sqrt(-1 + 0im)\\n0.0 + 1.0imThe literal numeric coefficient notation does not work when constructing a complex number from variables. Instead, the multiplication must be explicitly written out:julia> a = 1; b = 2; a + b*im\\n1 + 2imHowever, this is not recommended; Use the complex function instead to construct a complex value directly from its real and imaginary parts:julia> a = 1; b = 2; complex(a, b)\\n1 + 2imThis construction avoids the multiplication and addition operations.Inf and NaN propagate through complex numbers in the real and imaginary parts of a complex number as described in the Special floating-point values section:julia> 1 + Inf*im\\n1.0 + Inf*im\\n\\njulia> 1 + NaN*im\\n1.0 + NaN*im\"\n},\n\n{\n    \"location\": \"manual/complex-and-rational-numbers.html#Rational-Numbers-1\",\n    \"page\": \"Complex and Rational Numbers\",\n    \"title\": \"Rational Numbers\",\n    \"category\": \"section\",\n    \"text\": \"Julia has a rational number type to represent exact ratios of integers. Rationals are constructed using the // operator:julia> 2//3\\n2//3If the numerator and denominator of a rational have common factors, they are reduced to lowest terms such that the denominator is non-negative:julia> 6//9\\n2//3\\n\\njulia> -4//8\\n-1//2\\n\\njulia> 5//-15\\n-1//3\\n\\njulia> -4//-12\\n1//3This normalized form for a ratio of integers is unique, so equality of rational values can be tested by checking for equality of the numerator and denominator. The standardized numerator and denominator of a rational value can be extracted using the numerator and denominator functions:julia> numerator(2//3)\\n2\\n\\njulia> denominator(2//3)\\n3Direct comparison of the numerator and denominator is generally not necessary, since the standard arithmetic and comparison operations are defined for rational values:julia> 2//3 == 6//9\\ntrue\\n\\njulia> 2//3 == 9//27\\nfalse\\n\\njulia> 3//7 < 1//2\\ntrue\\n\\njulia> 3//4 > 2//3\\ntrue\\n\\njulia> 2//4 + 1//6\\n2//3\\n\\njulia> 5//12 - 1//4\\n1//6\\n\\njulia> 5//8 * 3//12\\n5//32\\n\\njulia> 6//5 / 10//7\\n21//25Rationals can be easily converted to floating-point numbers:julia> float(3//4)\\n0.75Conversion from rational to floating-point respects the following identity for any integral values of a and b, with the exception of the case a == 0 and b == 0:julia> a = 1; b = 2;\\n\\njulia> isequal(float(a//b), a/b)\\ntrueConstructing infinite rational values is acceptable:julia> 5//0\\n1//0\\n\\njulia> -3//0\\n-1//0\\n\\njulia> typeof(ans)\\nRational{Int64}Trying to construct a NaN rational value, however, is not:julia> 0//0\\nERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)\\nStacktrace:\\n[...]As usual, the promotion system makes interactions with other numeric types effortless:julia> 3//5 + 1\\n8//5\\n\\njulia> 3//5 - 0.5\\n0.09999999999999998\\n\\njulia> 2//7 * (1 + 2im)\\n2//7 + 4//7*im\\n\\njulia> 2//7 * (1.5 + 2im)\\n0.42857142857142855 + 0.5714285714285714im\\n\\njulia> 3//2 / (1 + 2im)\\n3//10 - 3//5*im\\n\\njulia> 1//2 + 2im\\n1//2 + 2//1*im\\n\\njulia> 1 + 2//3im\\n1//1 - 2//3*im\\n\\njulia> 0.5 == 1//2\\ntrue\\n\\njulia> 0.33 == 1//3\\nfalse\\n\\njulia> 0.33 < 1//3\\ntrue\\n\\njulia> 1//3 - 0.33\\n0.0033333333333332993\"\n},\n\n{\n    \"location\": \"manual/strings.html#\",\n    \"page\": \"Strings\",\n    \"title\": \"Strings\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/strings.html#man-strings-1\",\n    \"page\": \"Strings\",\n    \"title\": \"Strings\",\n    \"category\": \"section\",\n    \"text\": \"Strings are finite sequences of characters. Of course, the real trouble comes when one asks what a character is. The characters that English speakers are familiar with are the letters A, B, C, etc., together with numerals and common punctuation symbols. These characters are standardized together with a mapping to integer values between 0 and 127 by the ASCII standard. There are, of course, many other characters used in non-English languages, including variants of the ASCII characters with accents and other modifications, related scripts such as Cyrillic and Greek, and scripts completely unrelated to ASCII and English, including Arabic, Chinese, Hebrew, Hindi, Japanese, and Korean. The Unicode standard tackles the complexities of what exactly a character is, and is generally accepted as the definitive standard addressing this problem. Depending on your needs, you can either ignore these complexities entirely and just pretend that only ASCII characters exist, or you can write code that can handle any of the characters or encodings that one may encounter when handling non-ASCII text. Julia makes dealing with plain ASCII text simple and efficient, and handling Unicode is as simple and efficient as possible. In particular, you can write C-style string code to process ASCII strings, and they will work as expected, both in terms of performance and semantics. If such code encounters non-ASCII text, it will gracefully fail with a clear error message, rather than silently introducing corrupt results. When this happens, modifying the code to handle non-ASCII data is straightforward.There are a few noteworthy high-level features about Julia\\'s strings:The built-in concrete type used for strings (and string literals) in Julia is String. This supports the full range of Unicode characters via the UTF-8 encoding. (A transcode function is provided to convert to/from other Unicode encodings.)\\nAll string types are subtypes of the abstract type AbstractString, and external packages define additional AbstractString subtypes (e.g. for other encodings).  If you define a function expecting a string argument, you should declare the type as AbstractString in order to accept any string type.\\nLike C and Java, but unlike most dynamic languages, Julia has a first-class type for representing a single character, called AbstractChar. The built-in Char subtype of AbstractChar is a 32-bit primitive type that can represent any Unicode character (and which is based on the UTF-8 encoding).\\nAs in Java, strings are immutable: the value of an AbstractString object cannot be changed. To construct a different string value, you construct a new string from parts of other strings.\\nConceptually, a string is a partial function from indices to characters: for some index values, no character value is returned, and instead an exception is thrown. This allows for efficient indexing into strings by the byte index of an encoded representation rather than by a character index, which cannot be implemented both efficiently and simply for variable-width encodings of Unicode strings.\"\n},\n\n{\n    \"location\": \"manual/strings.html#man-characters-1\",\n    \"page\": \"Strings\",\n    \"title\": \"Characters\",\n    \"category\": \"section\",\n    \"text\": \"A Char value represents a single character: it is just a 32-bit primitive type with a special literal representation and appropriate arithmetic behaviors, and which can be converted to a numeric value representing a Unicode code point.  (Julia packages may define other subtypes of AbstractChar, e.g. to optimize operations for other text encodings.) Here is how Char values are input and shown:julia> \\'x\\'\\n\\'x\\': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\\n\\njulia> typeof(ans)\\nCharYou can easily convert a Char to its integer value, i.e. code point:julia> Int(\\'x\\')\\n120\\n\\njulia> typeof(ans)\\nInt64On 32-bit architectures, typeof(ans) will be Int32. You can convert an integer value back to a Char just as easily:julia> Char(120)\\n\\'x\\': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)Not all integer values are valid Unicode code points, but for performance, the Char conversion does not check that every character value is valid. If you want to check that each converted value is a valid code point, use the isvalid function:julia> Char(0x110000)\\n\\'\\\\U110000\\': Unicode U+110000 (category In: Invalid, too high)\\n\\njulia> isvalid(Char, 0x110000)\\nfalseAs of this writing, the valid Unicode code points are U+00 through U+d7ff and U+e000 through U+10ffff. These have not all been assigned intelligible meanings yet, nor are they necessarily interpretable by applications, but all of these values are considered to be valid Unicode characters.You can input any Unicode character in single quotes using \\\\u followed by up to four hexadecimal digits or \\\\U followed by up to eight hexadecimal digits (the longest valid value only requires six):julia> \\'\\\\u0\\'\\n\\'\\\\0\\': ASCII/Unicode U+0000 (category Cc: Other, control)\\n\\njulia> \\'\\\\u78\\'\\n\\'x\\': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\\n\\njulia> \\'\\\\u2200\\'\\n\\'\u2200\\': Unicode U+2200 (category Sm: Symbol, math)\\n\\njulia> \\'\\\\U10ffff\\'\\n\\'\\\\U10ffff\\': Unicode U+10ffff (category Cn: Other, not assigned)Julia uses your system\\'s locale and language settings to determine which characters can be printed as-is and which must be output using the generic, escaped \\\\u or \\\\U input forms. In addition to these Unicode escape forms, all of C\\'s traditional escaped input forms can also be used:julia> Int(\\'\\\\0\\')\\n0\\n\\njulia> Int(\\'\\\\t\\')\\n9\\n\\njulia> Int(\\'\\\\n\\')\\n10\\n\\njulia> Int(\\'\\\\e\\')\\n27\\n\\njulia> Int(\\'\\\\x7f\\')\\n127\\n\\njulia> Int(\\'\\\\177\\')\\n127You can do comparisons and a limited amount of arithmetic with Char values:julia> \\'A\\' < \\'a\\'\\ntrue\\n\\njulia> \\'A\\' <= \\'a\\' <= \\'Z\\'\\nfalse\\n\\njulia> \\'A\\' <= \\'X\\' <= \\'Z\\'\\ntrue\\n\\njulia> \\'x\\' - \\'a\\'\\n23\\n\\njulia> \\'A\\' + 1\\n\\'B\\': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)\"\n},\n\n{\n    \"location\": \"manual/strings.html#String-Basics-1\",\n    \"page\": \"Strings\",\n    \"title\": \"String Basics\",\n    \"category\": \"section\",\n    \"text\": \"String literals are delimited by double quotes or triple double quotes:julia> str = \\\"Hello, world.\\\\n\\\"\\n\\\"Hello, world.\\\\n\\\"\\n\\njulia> \\\"\\\"\\\"Contains \\\"quote\\\" characters\\\"\\\"\\\"\\n\\\"Contains \\\\\\\"quote\\\\\\\" characters\\\"If you want to extract a character from a string, you index into it:julia> str[1]\\n\\'H\\': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\\n\\njulia> str[6]\\n\\',\\': ASCII/Unicode U+002c (category Po: Punctuation, other)\\n\\njulia> str[end]\\n\\'\\\\n\\': ASCII/Unicode U+000a (category Cc: Other, control)Many Julia objects, including strings, can be indexed with integers. The index of the first element is returned by firstindex(str), and the index of the last element with lastindex(str). The keyword end can be used inside an indexing operation as shorthand for the last index along the given dimension. Most indexing in Julia is 1-based: the first element of many integer-indexed objects is found at index 1. (As we will see below, this does not necessarily mean that the last element is found at index n, where n is the length of the string.)You can perform arithmetic and other operations with end, just like a normal value:julia> str[end-1]\\n\\'.\\': ASCII/Unicode U+002e (category Po: Punctuation, other)\\n\\njulia> str[end\u00f72]\\n\\' \\': ASCII/Unicode U+0020 (category Zs: Separator, space)Using an index less than 1 or greater than end raises an error:julia> str[0]\\nERROR: BoundsError: attempt to access \\\"Hello, world.\\\\n\\\"\\n  at index [0]\\n[...]\\n\\njulia> str[end+1]\\nERROR: BoundsError: attempt to access \\\"Hello, world.\\\\n\\\"\\n  at index [15]\\nStacktrace:\\n[...]You can also extract a substring using range indexing:julia> str[4:9]\\n\\\"lo, wo\\\"Notice that the expressions str[k] and str[k:k] do not give the same result:julia> str[6]\\n\\',\\': ASCII/Unicode U+002c (category Po: Punctuation, other)\\n\\njulia> str[6:6]\\n\\\",\\\"The former is a single character value of type Char, while the latter is a string value that happens to contain only a single character. In Julia these are very different things.Range indexing makes a copy of the selected part of the original string. Alternatively, it is possible to create a view into a string using the type SubString, for example:julia> str = \\\"long string\\\"\\n\\\"long string\\\"\\n\\njulia> substr = SubString(str, 1, 4)\\n\\\"long\\\"\\n\\njulia> typeof(substr)\\nSubString{String}Several standard functions like chop, chomp or strip return a SubString.\"\n},\n\n{\n    \"location\": \"manual/strings.html#Unicode-and-UTF-8-1\",\n    \"page\": \"Strings\",\n    \"title\": \"Unicode and UTF-8\",\n    \"category\": \"section\",\n    \"text\": \"Julia fully supports Unicode characters and strings. As discussed above, in character literals, Unicode code points can be represented using Unicode \\\\u and \\\\U escape sequences, as well as all the standard C escape sequences. These can likewise be used to write string literals:julia> s = \\\"\\\\u2200 x \\\\u2203 y\\\"\\n\\\"\u2200 x \u2203 y\\\"Whether these Unicode characters are displayed as escapes or shown as special characters depends on your terminal\\'s locale settings and its support for Unicode. String literals are encoded using the UTF-8 encoding. UTF-8 is a variable-width encoding, meaning that not all characters are encoded in the same number of bytes. In UTF-8, ASCII characters \u2013 i.e. those with code points less than 0x80 (128) \u2013 are encoded as they are in ASCII, using a single byte, while code points 0x80 and above are encoded using multiple bytes \u2013 up to four per character. This means that not every byte index into a UTF-8 string is necessarily a valid index for a character. If you index into a string at such an invalid byte index, an error is thrown:julia> s[1]\\n\\'\u2200\\': Unicode U+2200 (category Sm: Symbol, math)\\n\\njulia> s[2]\\nERROR: StringIndexError(\\\"\u2200 x \u2203 y\\\", 2)\\n[...]\\n\\njulia> s[3]\\nERROR: StringIndexError(\\\"\u2200 x \u2203 y\\\", 3)\\nStacktrace:\\n[...]\\n\\njulia> s[4]\\n\\' \\': ASCII/Unicode U+0020 (category Zs: Separator, space)In this case, the character \u2200 is a three-byte character, so the indices 2 and 3 are invalid and the next character\\'s index is 4; this next valid index can be computed by nextind(s,1), and the next index after that by nextind(s,4) and so on.Extraction of a substring using range indexing also expects valid byte indices or an error is thrown:julia> s[1:1]\\n\\\"\u2200\\\"\\n\\njulia> s[1:2]\\nERROR: StringIndexError(\\\"\u2200 x \u2203 y\\\", 2)\\nStacktrace:\\n[...]\\n\\njulia> s[1:4]\\n\\\"\u2200 \\\"Because of variable-length encodings, the number of characters in a string (given by length(s)) is not always the same as the last index. If you iterate through the indices 1 through lastindex(s) and index into s, the sequence of characters returned when errors aren\\'t thrown is the sequence of characters comprising the string s. Thus we have the identity that length(s) <= lastindex(s), since each character in a string must have its own index. The following is an inefficient and verbose way to iterate through the characters of s:julia> for i = firstindex(s):lastindex(s)\\n           try\\n               println(s[i])\\n           catch\\n               # ignore the index error\\n           end\\n       end\\n\u2200\\n\\nx\\n\\n\u2203\\n\\nyThe blank lines actually have spaces on them. Fortunately, the above awkward idiom is unnecessary for iterating through the characters in a string, since you can just use the string as an iterable object, no exception handling required:julia> for c in s\\n           println(c)\\n       end\\n\u2200\\n\\nx\\n\\n\u2203\\n\\nyStrings in Julia can contain invalid UTF-8 code unit sequences. This convention allows to treat any byte sequence as a String. In such situations a rule is that when parsing a sequence of code units from left to right characters are formed by the longest sequence of 8-bit code units that matches the start of one of the following bit patterns (each x can be 0 or 1):0xxxxxxx;\\n110xxxxx 10xxxxxx;\\n1110xxxx 10xxxxxx 10xxxxxx;\\n11110xxx 10xxxxxx 10xxxxxx 10xxxxxx;\\n10xxxxxx;\\n11111xxx.In particular this implies that overlong and too high code unit sequences are accepted. This rule is best explained by an example:julia> s = \\\"\\\\xc0\\\\xa0\\\\xe2\\\\x88\\\\xe2|\\\"\\n\\\"\\\\xc0\\\\xa0\\\\xe2\\\\x88\\\\xe2|\\\"\\n\\njulia> foreach(display, s)\\n\\'\\\\xc0\\\\xa0\\': [overlong] ASCII/Unicode U+0020 (category Zs: Separator, space)\\n\\'\\\\xe2\\\\x88\\': Malformed UTF-8 (category Ma: Malformed, bad data)\\n\\'\\\\xe2\\': Malformed UTF-8 (category Ma: Malformed, bad data)\\n\\'|\\': ASCII/Unicode U+007c (category Sm: Symbol, math)\\n\\njulia> isvalid.(collect(s))\\n4-element BitArray{1}:\\n false\\n false\\n false\\n  true\\n\\njulia> s2 = \\\"\\\\xf7\\\\xbf\\\\xbf\\\\xbf\\\"\\n\\\"\\\\U1fffff\\\"\\n\\njulia> foreach(display, s2)\\n\\'\\\\U1fffff\\': Unicode U+1fffff (category In: Invalid, too high)We can see that the first two code units in the string s form an overlong encoding of space character. It is invalid, but is accepted in a string as a single character. The next two code units form a valid start of a three-byte UTF-8 sequence. However, the fifth code unit \\\\xe2 is not its valid continuation. Therefore code units 3 and 4 are also interpreted as malformed characters in this string. Similarly code unit 5 forms a malformed character because | is not a valid continuation to it. Finally the string s2 contains one too high code point.Julia uses the UTF-8 encoding by default, and support for new encodings can be added by packages. For example, the LegacyStrings.jl package implements UTF16String and UTF32String types. Additional discussion of other encodings and how to implement support for them is beyond the scope of this document for the time being. For further discussion of UTF-8 encoding issues, see the section below on byte array literals. The transcode function is provided to convert data between the various UTF-xx encodings, primarily for working with external data and libraries.\"\n},\n\n{\n    \"location\": \"manual/strings.html#Concatenation-1\",\n    \"page\": \"Strings\",\n    \"title\": \"Concatenation\",\n    \"category\": \"section\",\n    \"text\": \"One of the most common and useful string operations is concatenation:julia> greet = \\\"Hello\\\"\\n\\\"Hello\\\"\\n\\njulia> whom = \\\"world\\\"\\n\\\"world\\\"\\n\\njulia> string(greet, \\\", \\\", whom, \\\".\\\\n\\\")\\n\\\"Hello, world.\\\\n\\\"It\\'s important to be aware of potentially dangerous situations such as concatenation of invalid UTF-8 strings. The resulting string may contain different characters than the input strings, and its number of characters may be lower than sum of numbers of characters of the concatenated strings, e.g.:julia> a, b = \\\"\\\\xe2\\\\x88\\\", \\\"\\\\x80\\\"\\n(\\\"\\\\xe2\\\\x88\\\", \\\"\\\\x80\\\")\\n\\njulia> c = a*b\\n\\\"\u2200\\\"\\n\\njulia> collect.([a, b, c])\\n3-element Array{Array{Char,1},1}:\\n [\\'\\\\xe2\\\\x88\\']\\n [\\'\\\\x80\\']\\n [\\'\u2200\\']\\n\\njulia> length.([a, b, c])\\n3-element Array{Int64,1}:\\n 1\\n 1\\n 1This situation can happen only for invalid UTF-8 strings. For valid UTF-8 strings concatenation preserves all characters in strings and additivity of string lengths.Julia also provides * for string concatenation:julia> greet * \\\", \\\" * whom * \\\".\\\\n\\\"\\n\\\"Hello, world.\\\\n\\\"While * may seem like a surprising choice to users of languages that provide + for string concatenation, this use of * has precedent in mathematics, particularly in abstract algebra.In mathematics, + usually denotes a commutative operation, where the order of the operands does not matter. An example of this is matrix addition, where A + B == B + A for any matrices A and B that have the same shape. In contrast, * typically denotes a noncommutative operation, where the order of the operands does matter. An example of this is matrix multiplication, where in general A * B != B * A. As with matrix multiplication, string concatenation is noncommutative: greet * whom != whom * greet. As such, * is a more natural choice for an infix string concatenation operator, consistent with common mathematical use.More precisely, the set of all finite-length strings S together with the string concatenation operator * forms a free monoid (S, *). The identity element of this set is the empty string, \\\"\\\". Whenever a free monoid is not commutative, the operation is typically represented as \\\\cdot, *, or a similar symbol, rather than +, which as stated usually implies commutativity.\"\n},\n\n{\n    \"location\": \"manual/strings.html#string-interpolation-1\",\n    \"page\": \"Strings\",\n    \"title\": \"Interpolation\",\n    \"category\": \"section\",\n    \"text\": \"Constructing strings using concatenation can become a bit cumbersome, however. To reduce the need for these verbose calls to string or repeated multiplications, Julia allows interpolation into string literals using $, as in Perl:julia> \\\"$greet, $whom.\\\\n\\\"\\n\\\"Hello, world.\\\\n\\\"This is more readable and convenient and equivalent to the above string concatenation \u2013 the system rewrites this apparent single string literal into a concatenation of string literals with variables.The shortest complete expression after the $ is taken as the expression whose value is to be interpolated into the string. Thus, you can interpolate any expression into a string using parentheses:julia> \\\"1 + 2 = $(1 + 2)\\\"\\n\\\"1 + 2 = 3\\\"Both concatenation and string interpolation call string to convert objects into string form. Most non-AbstractString objects are converted to strings closely corresponding to how they are entered as literal expressions:julia> v = [1,2,3]\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n\\njulia> \\\"v: $v\\\"\\n\\\"v: [1, 2, 3]\\\"string is the identity for AbstractString and AbstractChar values, so these are interpolated into strings as themselves, unquoted and unescaped:julia> c = \\'x\\'\\n\\'x\\': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\\n\\njulia> \\\"hi, $c\\\"\\n\\\"hi, x\\\"To include a literal $ in a string literal, escape it with a backslash:julia> print(\\\"I have \\\\$100 in my account.\\\\n\\\")\\nI have $100 in my account.\"\n},\n\n{\n    \"location\": \"manual/strings.html#Triple-Quoted-String-Literals-1\",\n    \"page\": \"Strings\",\n    \"title\": \"Triple-Quoted String Literals\",\n    \"category\": \"section\",\n    \"text\": \"When strings are created using triple-quotes (\\\"\\\"\\\"...\\\"\\\"\\\") they have some special behavior that can be useful for creating longer blocks of text.First, triple-quoted strings are also dedented to the level of the least-indented line. This is useful for defining strings within code that is indented. For example:julia> str = \\\"\\\"\\\"\\n           Hello,\\n           world.\\n         \\\"\\\"\\\"\\n\\\"  Hello,\\\\n  world.\\\\n\\\"In this case the final (empty) line before the closing \\\"\\\"\\\" sets the indentation level.The dedentation level is determined as the longest common starting sequence of spaces or tabs in all lines, excluding the line following the opening \\\"\\\"\\\" and lines containing only spaces or tabs (the line containing the closing \\\"\\\"\\\" is always included). Then for all lines, excluding the text following the opening \\\"\\\"\\\", the common starting sequence is removed (including lines containing only spaces and tabs if they start with this sequence), e.g.:julia> \\\"\\\"\\\"    This\\n         is\\n           a test\\\"\\\"\\\"\\n\\\"    This\\\\nis\\\\n  a test\\\"Next, if the opening \\\"\\\"\\\" is followed by a newline, the newline is stripped from the resulting string.\\\"\\\"\\\"hello\\\"\\\"\\\"is equivalent to\\\"\\\"\\\"\\nhello\\\"\\\"\\\"but\\\"\\\"\\\"\\n\\nhello\\\"\\\"\\\"will contain a literal newline at the beginning.Stripping of the newline is performed after the dedentation. For example:julia> \\\"\\\"\\\"\\n         Hello,\\n         world.\\\"\\\"\\\"\\n\\\"Hello,\\\\nworld.\\\"Trailing whitespace is left unaltered.Triple-quoted string literals can contain \\\" symbols without escaping.Note that line breaks in literal strings, whether single- or triple-quoted, result in a newline (LF) character \\\\n in the string, even if your editor uses a carriage return \\\\r (CR) or CRLF combination to end lines. To include a CR in a string, use an explicit escape \\\\r; for example, you can enter the literal string \\\"a CRLF line ending\\\\r\\\\n\\\".\"\n},\n\n{\n    \"location\": \"manual/strings.html#Common-Operations-1\",\n    \"page\": \"Strings\",\n    \"title\": \"Common Operations\",\n    \"category\": \"section\",\n    \"text\": \"You can lexicographically compare strings using the standard comparison operators:julia> \\\"abracadabra\\\" < \\\"xylophone\\\"\\ntrue\\n\\njulia> \\\"abracadabra\\\" == \\\"xylophone\\\"\\nfalse\\n\\njulia> \\\"Hello, world.\\\" != \\\"Goodbye, world.\\\"\\ntrue\\n\\njulia> \\\"1 + 2 = 3\\\" == \\\"1 + 2 = $(1 + 2)\\\"\\ntrueYou can search for the index of a particular character using the findfirst function:julia> findfirst(isequal(\\'x\\'), \\\"xylophone\\\")\\n1\\n\\njulia> findfirst(isequal(\\'p\\'), \\\"xylophone\\\")\\n5\\n\\njulia> findfirst(isequal(\\'z\\'), \\\"xylophone\\\")You can start the search for a character at a given offset by using findnext with a third argument:julia> findnext(isequal(\\'o\\'), \\\"xylophone\\\", 1)\\n4\\n\\njulia> findnext(isequal(\\'o\\'), \\\"xylophone\\\", 5)\\n7\\n\\njulia> findnext(isequal(\\'o\\'), \\\"xylophone\\\", 8)You can use the occursin function to check if a substring is found within a string:julia> occursin(\\\"world\\\", \\\"Hello, world.\\\")\\ntrue\\n\\njulia> occursin(\\\"o\\\", \\\"Xylophon\\\")\\ntrue\\n\\njulia> occursin(\\\"a\\\", \\\"Xylophon\\\")\\nfalse\\n\\njulia> occursin(\\'o\\', \\\"Xylophon\\\")\\ntrueThe last example shows that occursin can also look for a character literal.Two other handy string functions are repeat and join:julia> repeat(\\\".:Z:.\\\", 10)\\n\\\".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:.\\\"\\n\\njulia> join([\\\"apples\\\", \\\"bananas\\\", \\\"pineapples\\\"], \\\", \\\", \\\" and \\\")\\n\\\"apples, bananas and pineapples\\\"Some other useful functions include:firstindex(str) gives the minimal (byte) index that can be used to index into str (always 1 for strings, not necessarily true for other containers).\\nlastindex(str) gives the maximal (byte) index that can be used to index into str.\\nlength(str) the number of characters in str.\\nlength(str, i, j) the number of valid character indices in str from i to j.\\nncodeunits(str) number of code units in a string.\\ncodeunit(str, i) gives the code unit value in the string str at index i.\\nthisind(str, i) given an arbitrary index into a string find the first index of the character into which the index points.\\nnextind(str, i, n=1) find the start of the nth character starting after index i.\\nprevind(str, i, n=1) find the start of the nth character starting before index i.\"\n},\n\n{\n    \"location\": \"manual/strings.html#non-standard-string-literals-1\",\n    \"page\": \"Strings\",\n    \"title\": \"Non-Standard String Literals\",\n    \"category\": \"section\",\n    \"text\": \"There are situations when you want to construct a string or use string semantics, but the behavior of the standard string construct is not quite what is needed. For these kinds of situations, Julia provides non-standard string literals. A non-standard string literal looks like a regular double-quoted string literal, but is immediately prefixed by an identifier, and doesn\\'t behave quite like a normal string literal.  Regular expressions, byte array literals and version number literals, as described below, are some examples of non-standard string literals. Other examples are given in the Metaprogramming section.\"\n},\n\n{\n    \"location\": \"manual/strings.html#Regular-Expressions-1\",\n    \"page\": \"Strings\",\n    \"title\": \"Regular Expressions\",\n    \"category\": \"section\",\n    \"text\": \"Julia has Perl-compatible regular expressions (regexes), as provided by the PCRE library. Regular expressions are related to strings in two ways: the obvious connection is that regular expressions are used to find regular patterns in strings; the other connection is that regular expressions are themselves input as strings, which are parsed into a state machine that can be used to efficiently search for patterns in strings. In Julia, regular expressions are input using non-standard string literals prefixed with various identifiers beginning with r. The most basic regular expression literal without any options turned on just uses r\\\"...\\\":julia> r\\\"^\\\\s*(?:#|$)\\\"\\nr\\\"^\\\\s*(?:#|$)\\\"\\n\\njulia> typeof(ans)\\nRegexTo check if a regex matches a string, use occursin:julia> occursin(r\\\"^\\\\s*(?:#|$)\\\", \\\"not a comment\\\")\\nfalse\\n\\njulia> occursin(r\\\"^\\\\s*(?:#|$)\\\", \\\"# a comment\\\")\\ntrueAs one can see here, occursin simply returns true or false, indicating whether a match for the given regex occurs in the string. Commonly, however, one wants to know not just whether a string matched, but also how it matched. To capture this information about a match, use the match function instead:julia> match(r\\\"^\\\\s*(?:#|$)\\\", \\\"not a comment\\\")\\n\\njulia> match(r\\\"^\\\\s*(?:#|$)\\\", \\\"# a comment\\\")\\nRegexMatch(\\\"#\\\")If the regular expression does not match the given string, match returns nothing \u2013 a special value that does not print anything at the interactive prompt. Other than not printing, it is a completely normal value and you can test for it programmatically:m = match(r\\\"^\\\\s*(?:#|$)\\\", line)\\nif m === nothing\\n    println(\\\"not a comment\\\")\\nelse\\n    println(\\\"blank or comment\\\")\\nendIf a regular expression does match, the value returned by match is a RegexMatch object. These objects record how the expression matches, including the substring that the pattern matches and any captured substrings, if there are any. This example only captures the portion of the substring that matches, but perhaps we want to capture any non-blank text after the comment character. We could do the following:julia> m = match(r\\\"^\\\\s*(?:#\\\\s*(.*?)\\\\s*$|$)\\\", \\\"# a comment \\\")\\nRegexMatch(\\\"# a comment \\\", 1=\\\"a comment\\\")When calling match, you have the option to specify an index at which to start the search. For example:julia> m = match(r\\\"[0-9]\\\",\\\"aaaa1aaaa2aaaa3\\\",1)\\nRegexMatch(\\\"1\\\")\\n\\njulia> m = match(r\\\"[0-9]\\\",\\\"aaaa1aaaa2aaaa3\\\",6)\\nRegexMatch(\\\"2\\\")\\n\\njulia> m = match(r\\\"[0-9]\\\",\\\"aaaa1aaaa2aaaa3\\\",11)\\nRegexMatch(\\\"3\\\")You can extract the following info from a RegexMatch object:the entire substring matched: m.match\\nthe captured substrings as an array of strings: m.captures\\nthe offset at which the whole match begins: m.offset\\nthe offsets of the captured substrings as a vector: m.offsetsFor when a capture doesn\\'t match, instead of a substring, m.captures contains nothing in that position, and m.offsets has a zero offset (recall that indices in Julia are 1-based, so a zero offset into a string is invalid). Here is a pair of somewhat contrived examples:julia> m = match(r\\\"(a|b)(c)?(d)\\\", \\\"acd\\\")\\nRegexMatch(\\\"acd\\\", 1=\\\"a\\\", 2=\\\"c\\\", 3=\\\"d\\\")\\n\\njulia> m.match\\n\\\"acd\\\"\\n\\njulia> m.captures\\n3-element Array{Union{Nothing, SubString{String}},1}:\\n \\\"a\\\"\\n \\\"c\\\"\\n \\\"d\\\"\\n\\njulia> m.offset\\n1\\n\\njulia> m.offsets\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n\\njulia> m = match(r\\\"(a|b)(c)?(d)\\\", \\\"ad\\\")\\nRegexMatch(\\\"ad\\\", 1=\\\"a\\\", 2=nothing, 3=\\\"d\\\")\\n\\njulia> m.match\\n\\\"ad\\\"\\n\\njulia> m.captures\\n3-element Array{Union{Nothing, SubString{String}},1}:\\n \\\"a\\\"\\n nothing\\n \\\"d\\\"\\n\\njulia> m.offset\\n1\\n\\njulia> m.offsets\\n3-element Array{Int64,1}:\\n 1\\n 0\\n 2It is convenient to have captures returned as an array so that one can use destructuring syntax to bind them to local variables:julia> first, second, third = m.captures; first\\n\\\"a\\\"Captures can also be accessed by indexing the RegexMatch object with the number or name of the capture group:julia> m=match(r\\\"(?<hour>\\\\d+):(?<minute>\\\\d+)\\\",\\\"12:45\\\")\\nRegexMatch(\\\"12:45\\\", hour=\\\"12\\\", minute=\\\"45\\\")\\n\\njulia> m[:minute]\\n\\\"45\\\"\\n\\njulia> m[2]\\n\\\"45\\\"Captures can be referenced in a substitution string when using replace by using \\\\n to refer to the nth capture group and prefixing the substitution string with s. Capture group 0 refers to the entire match object. Named capture groups can be referenced in the substitution with g<groupname>. For example:julia> replace(\\\"first second\\\", r\\\"(\\\\w+) (?<agroup>\\\\w+)\\\" => s\\\"\\\\g<agroup> \\\\1\\\")\\n\\\"second first\\\"Numbered capture groups can also be referenced as \\\\g<n> for disambiguation, as in:julia> replace(\\\"a\\\", r\\\".\\\" => s\\\"\\\\g<0>1\\\")\\n\\\"a1\\\"You can modify the behavior of regular expressions by some combination of the flags i, m, s, and x after the closing double quote mark. These flags have the same meaning as they do in Perl, as explained in this excerpt from the perlre manpage:i   Do case-insensitive pattern matching.\\n\\n    If locale matching rules are in effect, the case map is taken\\n    from the current locale for code points less than 255, and\\n    from Unicode rules for larger code points. However, matches\\n    that would cross the Unicode rules/non-Unicode rules boundary\\n    (ords 255/256) will not succeed.\\n\\nm   Treat string as multiple lines.  That is, change \\\"^\\\" and \\\"$\\\"\\n    from matching the start or end of the string to matching the\\n    start or end of any line anywhere within the string.\\n\\ns   Treat string as single line.  That is, change \\\".\\\" to match any\\n    character whatsoever, even a newline, which normally it would\\n    not match.\\n\\n    Used together, as r\\\"\\\"ms, they let the \\\".\\\" match any character\\n    whatsoever, while still allowing \\\"^\\\" and \\\"$\\\" to match,\\n    respectively, just after and just before newlines within the\\n    string.\\n\\nx   Tells the regular expression parser to ignore most whitespace\\n    that is neither backslashed nor within a character class. You\\n    can use this to break up your regular expression into\\n    (slightly) more readable parts. The \\'#\\' character is also\\n    treated as a metacharacter introducing a comment, just as in\\n    ordinary code.For example, the following regex has all three flags turned on:julia> r\\\"a+.*b+.*?d$\\\"ism\\nr\\\"a+.*b+.*?d$\\\"ims\\n\\njulia> match(r\\\"a+.*b+.*?d$\\\"ism, \\\"Goodbye,\\\\nOh, angry,\\\\nBad world\\\\n\\\")\\nRegexMatch(\\\"angry,\\\\nBad world\\\")The r\\\"...\\\" literal is constructed without interpolation and unescaping (except for quotation mark \\\" which still has to be escaped). Here is an example showing the difference from standard string literals:julia> x = 10\\n10\\n\\njulia> r\\\"$x\\\"\\nr\\\"$x\\\"\\n\\njulia> \\\"$x\\\"\\n\\\"10\\\"\\n\\njulia> r\\\"\\\\x\\\"\\nr\\\"\\\\x\\\"\\n\\njulia> \\\"\\\\x\\\"\\nERROR: syntax: invalid escape sequenceTriple-quoted regex strings, of the form r\\\"\\\"\\\"...\\\"\\\"\\\", are also supported (and may be convenient for regular expressions containing quotation marks or newlines).\"\n},\n\n{\n    \"location\": \"manual/strings.html#man-byte-array-literals-1\",\n    \"page\": \"Strings\",\n    \"title\": \"Byte Array Literals\",\n    \"category\": \"section\",\n    \"text\": \"Another useful non-standard string literal is the byte-array string literal: b\\\"...\\\". This form lets you use string notation to express read only literal byte arrays \u2013 i.e. arrays of UInt8 values. The type of those objects is CodeUnits{UInt8, String}. The rules for byte array literals are the following:ASCII characters and ASCII escapes produce a single byte.\\n\\\\x and octal escape sequences produce the byte corresponding to the escape value.\\nUnicode escape sequences produce a sequence of bytes encoding that code point in UTF-8.There is some overlap between these rules since the behavior of \\\\x and octal escapes less than 0x80 (128) are covered by both of the first two rules, but here these rules agree. Together, these rules allow one to easily use ASCII characters, arbitrary byte values, and UTF-8 sequences to produce arrays of bytes. Here is an example using all three:julia> b\\\"DATA\\\\xff\\\\u2200\\\"\\n8-element Base.CodeUnits{UInt8,String}:\\n 0x44\\n 0x41\\n 0x54\\n 0x41\\n 0xff\\n 0xe2\\n 0x88\\n 0x80The ASCII string \\\"DATA\\\" corresponds to the bytes 68, 65, 84, 65. \\\\xff produces the single byte 255. The Unicode escape \\\\u2200 is encoded in UTF-8 as the three bytes 226, 136, 128. Note that the resulting byte array does not correspond to a valid UTF-8 string:julia> isvalid(\\\"DATA\\\\xff\\\\u2200\\\")\\nfalseAs it was mentioned CodeUnits{UInt8,String} type behaves like read only array of UInt8 and if you need a standard vector you can convert it using Vector{UInt8}:julia> x = b\\\"123\\\"\\n3-element Base.CodeUnits{UInt8,String}:\\n 0x31\\n 0x32\\n 0x33\\n\\njulia> x[1]\\n0x31\\n\\njulia> x[1] = 0x32\\nERROR: setindex! not defined for Base.CodeUnits{UInt8,String}\\n[...]\\n\\njulia> Vector{UInt8}(x)\\n3-element Array{UInt8,1}:\\n 0x31\\n 0x32\\n 0x33Also observe the significant distinction between \\\\xff and \\\\uff: the former escape sequence encodes the byte 255, whereas the latter escape sequence represents the code point 255, which is encoded as two bytes in UTF-8:julia> b\\\"\\\\xff\\\"\\n1-element Base.CodeUnits{UInt8,String}:\\n 0xff\\n\\njulia> b\\\"\\\\uff\\\"\\n2-element Base.CodeUnits{UInt8,String}:\\n 0xc3\\n 0xbfCharacter literals use the same behavior.For code points less than \\\\u80, it happens that the UTF-8 encoding of each code point is just the single byte produced by the corresponding \\\\x escape, so the distinction can safely be ignored. For the escapes \\\\x80 through \\\\xff as compared to \\\\u80 through \\\\uff, however, there is a major difference: the former escapes all encode single bytes, which \u2013 unless followed by very specific continuation bytes \u2013 do not form valid UTF-8 data, whereas the latter escapes all represent Unicode code points with two-byte encodings.If this is all extremely confusing, try reading \\\"The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets\\\". It\\'s an excellent introduction to Unicode and UTF-8, and may help alleviate some confusion regarding the matter.\"\n},\n\n{\n    \"location\": \"manual/strings.html#man-version-number-literals-1\",\n    \"page\": \"Strings\",\n    \"title\": \"Version Number Literals\",\n    \"category\": \"section\",\n    \"text\": \"Version numbers can easily be expressed with non-standard string literals of the form v\\\"...\\\". Version number literals create VersionNumber objects which follow the specifications of semantic versioning, and therefore are composed of major, minor and patch numeric values, followed by pre-release and build alpha-numeric annotations. For example, v\\\"0.2.1-rc1+win64\\\" is broken into major version 0, minor version 2, patch version 1, pre-release rc1 and build win64. When entering a version literal, everything except the major version number is optional, therefore e.g.  v\\\"0.2\\\" is equivalent to v\\\"0.2.0\\\" (with empty pre-release/build annotations), v\\\"2\\\" is equivalent to v\\\"2.0.0\\\", and so on.VersionNumber objects are mostly useful to easily and correctly compare two (or more) versions. For example, the constant VERSION holds Julia version number as a VersionNumber object, and therefore one can define some version-specific behavior using simple statements as:if v\\\"0.2\\\" <= VERSION < v\\\"0.3-\\\"\\n    # do something specific to 0.2 release series\\nendNote that in the above example the non-standard version number v\\\"0.3-\\\" is used, with a trailing -: this notation is a Julia extension of the standard, and it\\'s used to indicate a version which is lower than any 0.3 release, including all of its pre-releases. So in the above example the code would only run with stable 0.2 versions, and exclude such versions as v\\\"0.3.0-rc1\\\". In order to also allow for unstable (i.e. pre-release) 0.2 versions, the lower bound check should be modified like this: v\\\"0.2-\\\" <= VERSION.Another non-standard version specification extension allows one to use a trailing + to express an upper limit on build versions, e.g.  VERSION > v\\\"0.2-rc1+\\\" can be used to mean any version above 0.2-rc1 and any of its builds: it will return false for version v\\\"0.2-rc1+win64\\\" and true for v\\\"0.2-rc2\\\".It is good practice to use such special versions in comparisons (particularly, the trailing - should always be used on upper bounds unless there\\'s a good reason not to), but they must not be used as the actual version number of anything, as they are invalid in the semantic versioning scheme.Besides being used for the VERSION constant, VersionNumber objects are widely used in the Pkg module, to specify packages versions and their dependencies.\"\n},\n\n{\n    \"location\": \"manual/strings.html#man-raw-string-literals-1\",\n    \"page\": \"Strings\",\n    \"title\": \"Raw String Literals\",\n    \"category\": \"section\",\n    \"text\": \"Raw strings without interpolation or unescaping can be expressed with non-standard string literals of the form raw\\\"...\\\". Raw string literals create ordinary String objects which contain the enclosed contents exactly as entered with no interpolation or unescaping. This is useful for strings which contain code or markup in other languages which use $ or \\\\ as special characters.The exception is that quotation marks still must be escaped, e.g. raw\\\"\\\\\\\"\\\" is equivalent to \\\"\\\\\\\"\\\". To make it possible to express all strings, backslashes then also must be escaped, but only when appearing right before a quote character:julia> println(raw\\\"\\\\\\\\ \\\\\\\\\\\\\\\"\\\")\\n\\\\\\\\ \\\\\\\"Notice that the first two backslashes appear verbatim in the output, since they do not precede a quote character. However, the next backslash character escapes the backslash that follows it, and the last backslash escapes a quote, since these backslashes appear before a quote.\"\n},\n\n{\n    \"location\": \"manual/functions.html#\",\n    \"page\": \"Functions\",\n    \"title\": \"Functions\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/functions.html#man-functions-1\",\n    \"page\": \"Functions\",\n    \"title\": \"Functions\",\n    \"category\": \"section\",\n    \"text\": \"In Julia, a function is an object that maps a tuple of argument values to a return value. Julia functions are not pure mathematical functions, in the sense that functions can alter and be affected by the global state of the program. The basic syntax for defining functions in Julia is:julia> function f(x,y)\\n           x + y\\n       end\\nf (generic function with 1 method)There is a second, more terse syntax for defining a function in Julia. The traditional function declaration syntax demonstrated above is equivalent to the following compact \\\"assignment form\\\":julia> f(x,y) = x + y\\nf (generic function with 1 method)In the assignment form, the body of the function must be a single expression, although it can be a compound expression (see Compound Expressions). Short, simple function definitions are common in Julia. The short function syntax is accordingly quite idiomatic, considerably reducing both typing and visual noise.A function is called using the traditional parenthesis syntax:julia> f(2,3)\\n5Without parentheses, the expression f refers to the function object, and can be passed around like any value:julia> g = f;\\n\\njulia> g(2,3)\\n5As with variables, Unicode can also be used for function names:julia> \u2211(x,y) = x + y\\n\u2211 (generic function with 1 method)\\n\\njulia> \u2211(2, 3)\\n5\"\n},\n\n{\n    \"location\": \"manual/functions.html#Argument-Passing-Behavior-1\",\n    \"page\": \"Functions\",\n    \"title\": \"Argument Passing Behavior\",\n    \"category\": \"section\",\n    \"text\": \"Julia function arguments follow a convention sometimes called \\\"pass-by-sharing\\\", which means that values are not copied when they are passed to functions. Function arguments themselves act as new variable bindings (new locations that can refer to values), but the values they refer to are identical to the passed values. Modifications to mutable values (such as Arrays) made within a function will be visible to the caller. This is the same behavior found in Scheme, most Lisps, Python, Ruby and Perl, among other dynamic languages.\"\n},\n\n{\n    \"location\": \"manual/functions.html#The-return-Keyword-1\",\n    \"page\": \"Functions\",\n    \"title\": \"The return Keyword\",\n    \"category\": \"section\",\n    \"text\": \"The value returned by a function is the value of the last expression evaluated, which, by default, is the last expression in the body of the function definition. In the example function, f, from the previous section this is the value of the expression x + y. As in C and most other imperative or functional languages, the return keyword causes a function to return immediately, providing an expression whose value is returned:function g(x,y)\\n    return x * y\\n    x + y\\nendSince function definitions can be entered into interactive sessions, it is easy to compare these definitions:julia> f(x,y) = x + y\\nf (generic function with 1 method)\\n\\njulia> function g(x,y)\\n           return x * y\\n           x + y\\n       end\\ng (generic function with 1 method)\\n\\njulia> f(2,3)\\n5\\n\\njulia> g(2,3)\\n6Of course, in a purely linear function body like g, the usage of return is pointless since the expression x + y is never evaluated and we could simply make x * y the last expression in the function and omit the return. In conjunction with other control flow, however, return is of real use. Here, for example, is a function that computes the hypotenuse length of a right triangle with sides of length x and y, avoiding overflow:julia> function hypot(x,y)\\n           x = abs(x)\\n           y = abs(y)\\n           if x > y\\n               r = y/x\\n               return x*sqrt(1+r*r)\\n           end\\n           if y == 0\\n               return zero(x)\\n           end\\n           r = x/y\\n           return y*sqrt(1+r*r)\\n       end\\nhypot (generic function with 1 method)\\n\\njulia> hypot(3, 4)\\n5.0There are three possible points of return from this function, returning the values of three different expressions, depending on the values of x and y. The return on the last line could be omitted since it is the last expression.A return type can also be specified in the function declaration using the :: operator. This converts the return value to the specified type.julia> function g(x, y)::Int8\\n           return x * y\\n       end;\\n\\njulia> typeof(g(1, 2))\\nInt8This function will always return an Int8 regardless of the types of x and y. See Type Declarations for more on return types.\"\n},\n\n{\n    \"location\": \"manual/functions.html#Operators-Are-Functions-1\",\n    \"page\": \"Functions\",\n    \"title\": \"Operators Are Functions\",\n    \"category\": \"section\",\n    \"text\": \"In Julia, most operators are just functions with support for special syntax. (The exceptions are operators with special evaluation semantics like && and ||. These operators cannot be functions since Short-Circuit Evaluation requires that their operands are not evaluated before evaluation of the operator.) Accordingly, you can also apply them using parenthesized argument lists, just as you would any other function:julia> 1 + 2 + 3\\n6\\n\\njulia> +(1,2,3)\\n6The infix form is exactly equivalent to the function application form \u2013 in fact the former is parsed to produce the function call internally. This also means that you can assign and pass around operators such as + and * just like you would with other function values:julia> f = +;\\n\\njulia> f(1,2,3)\\n6Under the name f, the function does not support infix notation, however.\"\n},\n\n{\n    \"location\": \"manual/functions.html#Operators-With-Special-Names-1\",\n    \"page\": \"Functions\",\n    \"title\": \"Operators With Special Names\",\n    \"category\": \"section\",\n    \"text\": \"A few special expressions correspond to calls to functions with non-obvious names. These are:Expression Calls\\n[A B C ...] hcat\\n[A; B; C; ...] vcat\\n[A B; C D; ...] hvcat\\nA\\' adjoint\\nA[i] getindex\\nA[i] = x setindex!\\nA.n getproperty\\nA.n = x setproperty!\"\n},\n\n{\n    \"location\": \"manual/functions.html#man-anonymous-functions-1\",\n    \"page\": \"Functions\",\n    \"title\": \"Anonymous Functions\",\n    \"category\": \"section\",\n    \"text\": \"Functions in Julia are first-class objects: they can be assigned to variables, and called using the standard function call syntax from the variable they have been assigned to. They can be used as arguments, and they can be returned as values. They can also be created anonymously, without being given a name, using either of these syntaxes:julia> x -> x^2 + 2x - 1\\n#1 (generic function with 1 method)\\n\\njulia> function (x)\\n           x^2 + 2x - 1\\n       end\\n#3 (generic function with 1 method)This creates a function taking one argument x and returning the value of the polynomial x^2 + 2x - 1 at that value. Notice that the result is a generic function, but with a compiler-generated name based on consecutive numbering.The primary use for anonymous functions is passing them to functions which take other functions as arguments. A classic example is map, which applies a function to each value of an array and returns a new array containing the resulting values:julia> map(round, [1.2,3.5,1.7])\\n3-element Array{Float64,1}:\\n 1.0\\n 4.0\\n 2.0This is fine if a named function effecting the transform already exists to pass as the first argument to map. Often, however, a ready-to-use, named function does not exist. In these situations, the anonymous function construct allows easy creation of a single-use function object without needing a name:julia> map(x -> x^2 + 2x - 1, [1,3,-1])\\n3-element Array{Int64,1}:\\n  2\\n 14\\n -2An anonymous function accepting multiple arguments can be written using the syntax (x,y,z)->2x+y-z. A zero-argument anonymous function is written as ()->3. The idea of a function with no arguments may seem strange, but is useful for \\\"delaying\\\" a computation. In this usage, a block of code is wrapped in a zero-argument function, which is later invoked by calling it as f.\"\n},\n\n{\n    \"location\": \"manual/functions.html#Tuples-1\",\n    \"page\": \"Functions\",\n    \"title\": \"Tuples\",\n    \"category\": \"section\",\n    \"text\": \"Julia has a built-in data structure called a tuple that is closely related to function arguments and return values. A tuple is a fixed-length container that can hold any values, but cannot be modified (it is immutable). Tuples are constructed with commas and parentheses, and can be accessed via indexing:julia> (1, 1+1)\\n(1, 2)\\n\\njulia> (1,)\\n(1,)\\n\\njulia> x = (0.0, \\\"hello\\\", 6*7)\\n(0.0, \\\"hello\\\", 42)\\n\\njulia> x[2]\\n\\\"hello\\\"Notice that a length-1 tuple must be written with a comma, (1,), since (1) would just be a parenthesized value. () represents the empty (length-0) tuple.\"\n},\n\n{\n    \"location\": \"manual/functions.html#Named-Tuples-1\",\n    \"page\": \"Functions\",\n    \"title\": \"Named Tuples\",\n    \"category\": \"section\",\n    \"text\": \"The components of tuples can optionally be named, in which case a named tuple is constructed:julia> x = (a=1, b=1+1)\\n(a = 1, b = 2)\\n\\njulia> x.a\\n1Named tuples are very similar to tuples, except that fields can additionally be accessed by name using dot syntax (x.a).\"\n},\n\n{\n    \"location\": \"manual/functions.html#Multiple-Return-Values-1\",\n    \"page\": \"Functions\",\n    \"title\": \"Multiple Return Values\",\n    \"category\": \"section\",\n    \"text\": \"In Julia, one returns a tuple of values to simulate returning multiple values. However, tuples can be created and destructured without needing parentheses, thereby providing an illusion that multiple values are being returned, rather than a single tuple value. For example, the following function returns a pair of values:julia> function foo(a,b)\\n           a+b, a*b\\n       end\\nfoo (generic function with 1 method)If you call it in an interactive session without assigning the return value anywhere, you will see the tuple returned:julia> foo(2,3)\\n(5, 6)A typical usage of such a pair of return values, however, extracts each value into a variable. Julia supports simple tuple \\\"destructuring\\\" that facilitates this:julia> x, y = foo(2,3)\\n(5, 6)\\n\\njulia> x\\n5\\n\\njulia> y\\n6You can also return multiple values via an explicit usage of the return keyword:function foo(a,b)\\n    return a+b, a*b\\nendThis has the exact same effect as the previous definition of foo.\"\n},\n\n{\n    \"location\": \"manual/functions.html#Argument-destructuring-1\",\n    \"page\": \"Functions\",\n    \"title\": \"Argument destructuring\",\n    \"category\": \"section\",\n    \"text\": \"The destructuring feature can also be used within a function argument. If a function argument name is written as a tuple (e.g. (x, y)) instead of just a symbol, then an assignment (x, y) = argument will be inserted for you:julia> minmax(x, y) = (y < x) ? (y, x) : (x, y)\\n\\njulia> range((min, max)) = max - min\\n\\njulia> range(minmax(10, 2))\\n8Notice the extra set of parentheses in the definition of range. Without those, range would be a two-argument function, and this example would not work.\"\n},\n\n{\n    \"location\": \"manual/functions.html#Varargs-Functions-1\",\n    \"page\": \"Functions\",\n    \"title\": \"Varargs Functions\",\n    \"category\": \"section\",\n    \"text\": \"It is often convenient to be able to write functions taking an arbitrary number of arguments. Such functions are traditionally known as \\\"varargs\\\" functions, which is short for \\\"variable number of arguments\\\". You can define a varargs function by following the last argument with an ellipsis:julia> bar(a,b,x...) = (a,b,x)\\nbar (generic function with 1 method)The variables a and b are bound to the first two argument values as usual, and the variable x is bound to an iterable collection of the zero or more values passed to bar after its first two arguments:julia> bar(1,2)\\n(1, 2, ())\\n\\njulia> bar(1,2,3)\\n(1, 2, (3,))\\n\\njulia> bar(1, 2, 3, 4)\\n(1, 2, (3, 4))\\n\\njulia> bar(1,2,3,4,5,6)\\n(1, 2, (3, 4, 5, 6))In all these cases, x is bound to a tuple of the trailing values passed to bar.It is possible to constrain the number of values passed as a variable argument; this will be discussed later in Parametrically-constrained Varargs methods.On the flip side, it is often handy to \\\"splat\\\" the values contained in an iterable collection into a function call as individual arguments. To do this, one also uses ... but in the function call instead:julia> x = (3, 4)\\n(3, 4)\\n\\njulia> bar(1,2,x...)\\n(1, 2, (3, 4))In this case a tuple of values is spliced into a varargs call precisely where the variable number of arguments go. This need not be the case, however:julia> x = (2, 3, 4)\\n(2, 3, 4)\\n\\njulia> bar(1,x...)\\n(1, 2, (3, 4))\\n\\njulia> x = (1, 2, 3, 4)\\n(1, 2, 3, 4)\\n\\njulia> bar(x...)\\n(1, 2, (3, 4))Furthermore, the iterable object splatted into a function call need not be a tuple:julia> x = [3,4]\\n2-element Array{Int64,1}:\\n 3\\n 4\\n\\njulia> bar(1,2,x...)\\n(1, 2, (3, 4))\\n\\njulia> x = [1,2,3,4]\\n4-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n 4\\n\\njulia> bar(x...)\\n(1, 2, (3, 4))Also, the function that arguments are splatted into need not be a varargs function (although it often is):julia> baz(a,b) = a + b;\\n\\njulia> args = [1,2]\\n2-element Array{Int64,1}:\\n 1\\n 2\\n\\njulia> baz(args...)\\n3\\n\\njulia> args = [1,2,3]\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n\\njulia> baz(args...)\\nERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)\\nClosest candidates are:\\n  baz(::Any, ::Any) at none:1As you can see, if the wrong number of elements are in the splatted container, then the function call will fail, just as it would if too many arguments were given explicitly.\"\n},\n\n{\n    \"location\": \"manual/functions.html#Optional-Arguments-1\",\n    \"page\": \"Functions\",\n    \"title\": \"Optional Arguments\",\n    \"category\": \"section\",\n    \"text\": \"In many cases, function arguments have sensible default values and therefore might not need to be passed explicitly in every call. For example, the function Date(y, [m, d]) from Dates module constructs a Date type for a given year y, month m and day d. However, m and d arguments are optional and their default value is 1. This behavior can be expressed concisely as:function Date(y::Int64, m::Int64=1, d::Int64=1)\\n    err = validargs(Date, y, m, d)\\n    err === nothing || throw(err)\\n    return Date(UTD(totaldays(y, m, d)))\\nendObserve, that this definition calls another method of Date function that takes one argument of UTInstant{Day} type.With this definition, the function can be called with either one, two or three arguments, and 1 is automatically passed when any of the arguments is not specified:julia> using Dates\\n\\njulia> Date(2000, 12, 12)\\n2000-12-12\\n\\njulia> Date(2000, 12)\\n2000-12-01\\n\\njulia> Date(2000)\\n2000-01-01Optional arguments are actually just a convenient syntax for writing multiple method definitions with different numbers of arguments (see Note on Optional and keyword Arguments). This can be checked for our Date function example by calling methods function.\"\n},\n\n{\n    \"location\": \"manual/functions.html#Keyword-Arguments-1\",\n    \"page\": \"Functions\",\n    \"title\": \"Keyword Arguments\",\n    \"category\": \"section\",\n    \"text\": \"Some functions need a large number of arguments, or have a large number of behaviors. Remembering how to call such functions can be difficult. Keyword arguments can make these complex interfaces easier to use and extend by allowing arguments to be identified by name instead of only by position.For example, consider a function plot that plots a line. This function might have many options, for controlling line style, width, color, and so on. If it accepts keyword arguments, a possible call might look like plot(x, y, width=2), where we have chosen to specify only line width. Notice that this serves two purposes. The call is easier to read, since we can label an argument with its meaning. It also becomes possible to pass any subset of a large number of arguments, in any order.Functions with keyword arguments are defined using a semicolon in the signature:function plot(x, y; style=\\\"solid\\\", width=1, color=\\\"black\\\")\\n    ###\\nendWhen the function is called, the semicolon is optional: one can either call plot(x, y, width=2) or plot(x, y; width=2), but the former style is more common. An explicit semicolon is required only for passing varargs or computed keywords as described below.Keyword argument default values are evaluated only when necessary (when a corresponding keyword argument is not passed), and in left-to-right order. Therefore default expressions may refer to prior keyword arguments.The types of keyword arguments can be made explicit as follows:function f(;x::Int=1)\\n    ###\\nendExtra keyword arguments can be collected using ..., as in varargs functions:function f(x; y=0, kwargs...)\\n    ###\\nendIf a keyword argument is not assigned a default value in the method definition, then it is required: an UndefKeywordError exception will be thrown if the caller does not assign it a value:function f(x; y)\\n    ###\\nend\\nf(3, y=5) # ok, y is assigned\\nf(3)      # throws UndefKeywordError(:y)Inside f, kwargs will be a named tuple. Named tuples (as well as dictionaries) can be passed as keyword arguments using a semicolon in a call, e.g. f(x, z=1; kwargs...).One can also pass key => value expressions after a semicolon. For example, plot(x, y; :width => 2) is equivalent to plot(x, y, width=2). This is useful in situations where the keyword name is computed at runtime.The nature of keyword arguments makes it possible to specify the same argument more than once. For example, in the call plot(x, y; options..., width=2) it is possible that the options structure also contains a value for width. In such a case the rightmost occurrence takes precedence; in this example, width is certain to have the value 2. However, explicitly specifying the same keyword argument multiple times, for example plot(x, y, width=2, width=3), is not allowed and results in a syntax error.\"\n},\n\n{\n    \"location\": \"manual/functions.html#Evaluation-Scope-of-Default-Values-1\",\n    \"page\": \"Functions\",\n    \"title\": \"Evaluation Scope of Default Values\",\n    \"category\": \"section\",\n    \"text\": \"When optional and keyword argument default expressions are evaluated, only previous arguments are in scope. For example, given this definition:function f(x, a=b, b=1)\\n    ###\\nendthe b in a=b refers to a b in an outer scope, not the subsequent argument b.\"\n},\n\n{\n    \"location\": \"manual/functions.html#Do-Block-Syntax-for-Function-Arguments-1\",\n    \"page\": \"Functions\",\n    \"title\": \"Do-Block Syntax for Function Arguments\",\n    \"category\": \"section\",\n    \"text\": \"Passing functions as arguments to other functions is a powerful technique, but the syntax for it is not always convenient. Such calls are especially awkward to write when the function argument requires multiple lines. As an example, consider calling map on a function with several cases:map(x->begin\\n           if x < 0 && iseven(x)\\n               return 0\\n           elseif x == 0\\n               return 1\\n           else\\n               return x\\n           end\\n       end,\\n    [A, B, C])Julia provides a reserved word do for rewriting this code more clearly:map([A, B, C]) do x\\n    if x < 0 && iseven(x)\\n        return 0\\n    elseif x == 0\\n        return 1\\n    else\\n        return x\\n    end\\nendThe do x syntax creates an anonymous function with argument x and passes it as the first argument to map. Similarly, do a,b would create a two-argument anonymous function, and a plain do would declare that what follows is an anonymous function of the form () -> ....How these arguments are initialized depends on the \\\"outer\\\" function; here, map will sequentially set x to A, B, C, calling the anonymous function on each, just as would happen in the syntax map(func, [A, B, C]).This syntax makes it easier to use functions to effectively extend the language, since calls look like normal code blocks. There are many possible uses quite different from map, such as managing system state. For example, there is a version of open that runs code ensuring that the opened file is eventually closed:open(\\\"outfile\\\", \\\"w\\\") do io\\n    write(io, data)\\nendThis is accomplished by the following definition:function open(f::Function, args...)\\n    io = open(args...)\\n    try\\n        f(io)\\n    finally\\n        close(io)\\n    end\\nendHere, open first opens the file for writing and then passes the resulting output stream to the anonymous function you defined in the do ... end block. After your function exits, open will make sure that the stream is properly closed, regardless of whether your function exited normally or threw an exception. (The try/finally construct will be described in Control Flow.)With the do block syntax, it helps to check the documentation or implementation to know how the arguments of the user function are initialized.A do block, like any other inner function, can \\\"capture\\\" variables from its enclosing scope. For example, the variable data in the above example of open...do is captured from the outer scope. Captured variables can create performance challenges as discussed in performance tips.\"\n},\n\n{\n    \"location\": \"manual/functions.html#man-vectorized-1\",\n    \"page\": \"Functions\",\n    \"title\": \"Dot Syntax for Vectorizing Functions\",\n    \"category\": \"section\",\n    \"text\": \"In technical-computing languages, it is common to have \\\"vectorized\\\" versions of functions, which simply apply a given function f(x) to each element of an array A to yield a new array via f(A). This kind of syntax is convenient for data processing, but in other languages vectorization is also often required for performance: if loops are slow, the \\\"vectorized\\\" version of a function can call fast library code written in a low-level language. In Julia, vectorized functions are not required for performance, and indeed it is often beneficial to write your own loops (see Performance Tips), but they can still be convenient. Therefore, any Julia function f can be applied elementwise to any array (or other collection) with the syntax f.(A). For example sin can be applied to all elements in the vector A, like so:julia> A = [1.0, 2.0, 3.0]\\n3-element Array{Float64,1}:\\n 1.0\\n 2.0\\n 3.0\\n\\njulia> sin.(A)\\n3-element Array{Float64,1}:\\n 0.8414709848078965\\n 0.9092974268256817\\n 0.1411200080598672Of course, you can omit the dot if you write a specialized \\\"vector\\\" method of f, e.g. via f(A::AbstractArray) = map(f, A), and this is just as efficient as f.(A). But that approach requires you to decide in advance which functions you want to vectorize.More generally, f.(args...) is actually equivalent to broadcast(f, args...), which allows you to operate on multiple arrays (even of different shapes), or a mix of arrays and scalars (see Broadcasting). For example, if you have f(x,y) = 3x + 4y, then f.(pi,A) will return a new array consisting of f(pi,a) for each a in A, and f.(vector1,vector2) will return a new vector consisting of f(vector1[i],vector2[i]) for each index i (throwing an exception if the vectors have different length).julia> f(x,y) = 3x + 4y;\\n\\njulia> A = [1.0, 2.0, 3.0];\\n\\njulia> B = [4.0, 5.0, 6.0];\\n\\njulia> f.(pi, A)\\n3-element Array{Float64,1}:\\n 13.42477796076938\\n 17.42477796076938\\n 21.42477796076938\\n\\njulia> f.(A, B)\\n3-element Array{Float64,1}:\\n 19.0\\n 26.0\\n 33.0Moreover, nested f.(args...) calls are fused into a single broadcast loop. For example, sin.(cos.(X)) is equivalent to broadcast(x -> sin(cos(x)), X), similar to [sin(cos(x)) for x in X]: there is only a single loop over X, and a single array is allocated for the result. [In contrast, sin(cos(X)) in a typical \\\"vectorized\\\" language would first allocate one temporary array for tmp=cos(X), and then compute sin(tmp) in a separate loop, allocating a second array.] This loop fusion is not a compiler optimization that may or may not occur, it is a syntactic guarantee whenever nested f.(args...) calls are encountered. Technically, the fusion stops as soon as a \\\"non-dot\\\" function call is encountered; for example, in sin.(sort(cos.(X))) the sin and cos loops cannot be merged because of the intervening sort function.Finally, the maximum efficiency is typically achieved when the output array of a vectorized operation is pre-allocated, so that repeated calls do not allocate new arrays over and over again for the results (see Pre-allocating outputs). A convenient syntax for this is X .= ..., which is equivalent to broadcast!(identity, X, ...) except that, as above, the broadcast! loop is fused with any nested \\\"dot\\\" calls. For example, X .= sin.(Y) is equivalent to broadcast!(sin, X, Y), overwriting X with sin.(Y) in-place. If the left-hand side is an array-indexing expression, e.g. X[2:end] .= sin.(Y), then it translates to broadcast! on a view, e.g. broadcast!(sin, view(X, 2:lastindex(X)), Y), so that the left-hand side is updated in-place.Since adding dots to many operations and function calls in an expression can be tedious and lead to code that is difficult to read, the macro @. is provided to convert every function call, operation, and assignment in an expression into the \\\"dotted\\\" version.julia> Y = [1.0, 2.0, 3.0, 4.0];\\n\\njulia> X = similar(Y); # pre-allocate output array\\n\\njulia> @. X = sin(cos(Y)) # equivalent to X .= sin.(cos.(Y))\\n4-element Array{Float64,1}:\\n  0.5143952585235492\\n -0.4042391538522658\\n -0.8360218615377305\\n -0.6080830096407656Binary (or unary) operators like .+ are handled with the same mechanism: they are equivalent to broadcast calls and are fused with other nested \\\"dot\\\" calls.  X .+= Y etcetera is equivalent to X .= X .+ Y and results in a fused in-place assignment;  see also dot operators.You can also combine dot operations with function chaining using |>, as in this example:julia> [1:5;] .|> [x->x^2, inv, x->2*x, -, isodd]\\n5-element Array{Real,1}:\\n    1\\n    0.5\\n    6\\n   -4\\n true\"\n},\n\n{\n    \"location\": \"manual/functions.html#Further-Reading-1\",\n    \"page\": \"Functions\",\n    \"title\": \"Further Reading\",\n    \"category\": \"section\",\n    \"text\": \"We should mention here that this is far from a complete picture of defining functions. Julia has a sophisticated type system and allows multiple dispatch on argument types. None of the examples given here provide any type annotations on their arguments, meaning that they are applicable to all types of arguments. The type system is described in Types and defining a function in terms of methods chosen by multiple dispatch on run-time argument types is described in Methods.\"\n},\n\n{\n    \"location\": \"manual/control-flow.html#\",\n    \"page\": \"Control Flow\",\n    \"title\": \"Control Flow\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/control-flow.html#Control-Flow-1\",\n    \"page\": \"Control Flow\",\n    \"title\": \"Control Flow\",\n    \"category\": \"section\",\n    \"text\": \"Julia provides a variety of control flow constructs:Compound Expressions: begin and (;).\\nConditional Evaluation: if-elseif-else and ?: (ternary operator).\\nShort-Circuit Evaluation: &&, || and chained comparisons.\\nRepeated Evaluation: Loops: while and for.\\nException Handling: try-catch, error and throw.\\nTasks (aka Coroutines): yieldto.The first five control flow mechanisms are standard to high-level programming languages. Tasks are not so standard: they provide non-local control flow, making it possible to switch between temporarily-suspended computations. This is a powerful construct: both exception handling and cooperative multitasking are implemented in Julia using tasks. Everyday programming requires no direct usage of tasks, but certain problems can be solved much more easily by using tasks.\"\n},\n\n{\n    \"location\": \"manual/control-flow.html#man-compound-expressions-1\",\n    \"page\": \"Control Flow\",\n    \"title\": \"Compound Expressions\",\n    \"category\": \"section\",\n    \"text\": \"Sometimes it is convenient to have a single expression which evaluates several subexpressions in order, returning the value of the last subexpression as its value. There are two Julia constructs that accomplish this: begin blocks and (;) chains. The value of both compound expression constructs is that of the last subexpression. Here\\'s an example of a begin block:julia> z = begin\\n           x = 1\\n           y = 2\\n           x + y\\n       end\\n3Since these are fairly small, simple expressions, they could easily be placed onto a single line, which is where the (;) chain syntax comes in handy:julia> z = (x = 1; y = 2; x + y)\\n3This syntax is particularly useful with the terse single-line function definition form introduced in Functions. Although it is typical, there is no requirement that begin blocks be multiline or that (;) chains be single-line:julia> begin x = 1; y = 2; x + y end\\n3\\n\\njulia> (x = 1;\\n        y = 2;\\n        x + y)\\n3\"\n},\n\n{\n    \"location\": \"manual/control-flow.html#man-conditional-evaluation-1\",\n    \"page\": \"Control Flow\",\n    \"title\": \"Conditional Evaluation\",\n    \"category\": \"section\",\n    \"text\": \"Conditional evaluation allows portions of code to be evaluated or not evaluated depending on the value of a boolean expression. Here is the anatomy of the if-elseif-else conditional syntax:if x < y\\n    println(\\\"x is less than y\\\")\\nelseif x > y\\n    println(\\\"x is greater than y\\\")\\nelse\\n    println(\\\"x is equal to y\\\")\\nendIf the condition expression x < y is true, then the corresponding block is evaluated; otherwise the condition expression x > y is evaluated, and if it is true, the corresponding block is evaluated; if neither expression is true, the else block is evaluated. Here it is in action:julia> function test(x, y)\\n           if x < y\\n               println(\\\"x is less than y\\\")\\n           elseif x > y\\n               println(\\\"x is greater than y\\\")\\n           else\\n               println(\\\"x is equal to y\\\")\\n           end\\n       end\\ntest (generic function with 1 method)\\n\\njulia> test(1, 2)\\nx is less than y\\n\\njulia> test(2, 1)\\nx is greater than y\\n\\njulia> test(1, 1)\\nx is equal to yThe elseif and else blocks are optional, and as many elseif blocks as desired can be used. The condition expressions in the if-elseif-else construct are evaluated until the first one evaluates to true, after which the associated block is evaluated, and no further condition expressions or blocks are evaluated.if blocks are \\\"leaky\\\", i.e. they do not introduce a local scope. This means that new variables defined inside the if clauses can be used after the if block, even if they weren\\'t defined before. So, we could have defined the test function above asjulia> function test(x,y)\\n           if x < y\\n               relation = \\\"less than\\\"\\n           elseif x == y\\n               relation = \\\"equal to\\\"\\n           else\\n               relation = \\\"greater than\\\"\\n           end\\n           println(\\\"x is \\\", relation, \\\" y.\\\")\\n       end\\ntest (generic function with 1 method)\\n\\njulia> test(2, 1)\\nx is greater than y.The variable relation is declared inside the if block, but used outside. However, when depending on this behavior, make sure all possible code paths define a value for the variable. The following change to the above function results in a runtime errorjulia> function test(x,y)\\n           if x < y\\n               relation = \\\"less than\\\"\\n           elseif x == y\\n               relation = \\\"equal to\\\"\\n           end\\n           println(\\\"x is \\\", relation, \\\" y.\\\")\\n       end\\ntest (generic function with 1 method)\\n\\njulia> test(1,2)\\nx is less than y.\\n\\njulia> test(2,1)\\nERROR: UndefVarError: relation not defined\\nStacktrace:\\n [1] test(::Int64, ::Int64) at ./none:7if blocks also return a value, which may seem unintuitive to users coming from many other languages. This value is simply the return value of the last executed statement in the branch that was chosen, sojulia> x = 3\\n3\\n\\njulia> if x > 0\\n           \\\"positive!\\\"\\n       else\\n           \\\"negative...\\\"\\n       end\\n\\\"positive!\\\"Note that very short conditional statements (one-liners) are frequently expressed using Short-Circuit Evaluation in Julia, as outlined in the next section.Unlike C, MATLAB, Perl, Python, and Ruby \u2013 but like Java, and a few other stricter, typed languages \u2013 it is an error if the value of a conditional expression is anything but true or false:julia> if 1\\n           println(\\\"true\\\")\\n       end\\nERROR: TypeError: non-boolean (Int64) used in boolean contextThis error indicates that the conditional was of the wrong type: Int64 rather than the required Bool.The so-called \\\"ternary operator\\\", ?:, is closely related to the if-elseif-else syntax, but is used where a conditional choice between single expression values is required, as opposed to conditional execution of longer blocks of code. It gets its name from being the only operator in most languages taking three operands:a ? b : cThe expression a, before the ?, is a condition expression, and the ternary operation evaluates the expression b, before the :, if the condition a is true or the expression c, after the :, if it is false. Note that the spaces around ? and : are mandatory: an expression like a?b:c is not a valid ternary expression (but a newline is acceptable after both the ? and the :).The easiest way to understand this behavior is to see an example. In the previous example, the println call is shared by all three branches: the only real choice is which literal string to print. This could be written more concisely using the ternary operator. For the sake of clarity, let\\'s try a two-way version first:julia> x = 1; y = 2;\\n\\njulia> println(x < y ? \\\"less than\\\" : \\\"not less than\\\")\\nless than\\n\\njulia> x = 1; y = 0;\\n\\njulia> println(x < y ? \\\"less than\\\" : \\\"not less than\\\")\\nnot less thanIf the expression x < y is true, the entire ternary operator expression evaluates to the string \\\"less than\\\" and otherwise it evaluates to the string \\\"not less than\\\". The original three-way example requires chaining multiple uses of the ternary operator together:julia> test(x, y) = println(x < y ? \\\"x is less than y\\\"    :\\n                            x > y ? \\\"x is greater than y\\\" : \\\"x is equal to y\\\")\\ntest (generic function with 1 method)\\n\\njulia> test(1, 2)\\nx is less than y\\n\\njulia> test(2, 1)\\nx is greater than y\\n\\njulia> test(1, 1)\\nx is equal to yTo facilitate chaining, the operator associates from right to left.It is significant that like if-elseif-else, the expressions before and after the : are only evaluated if the condition expression evaluates to true or false, respectively:julia> v(x) = (println(x); x)\\nv (generic function with 1 method)\\n\\njulia> 1 < 2 ? v(\\\"yes\\\") : v(\\\"no\\\")\\nyes\\n\\\"yes\\\"\\n\\njulia> 1 > 2 ? v(\\\"yes\\\") : v(\\\"no\\\")\\nno\\n\\\"no\\\"\"\n},\n\n{\n    \"location\": \"manual/control-flow.html#Short-Circuit-Evaluation-1\",\n    \"page\": \"Control Flow\",\n    \"title\": \"Short-Circuit Evaluation\",\n    \"category\": \"section\",\n    \"text\": \"Short-circuit evaluation is quite similar to conditional evaluation. The behavior is found in most imperative programming languages having the && and || boolean operators: in a series of boolean expressions connected by these operators, only the minimum number of expressions are evaluated as are necessary to determine the final boolean value of the entire chain. Explicitly, this means that:In the expression a && b, the subexpression b is only evaluated if a evaluates to true.\\nIn the expression a || b, the subexpression b is only evaluated if a evaluates to false.The reasoning is that a && b must be false if a is false, regardless of the value of b, and likewise, the value of a || b must be true if a is true, regardless of the value of b. Both && and || associate to the right, but && has higher precedence than || does. It\\'s easy to experiment with this behavior:julia> t(x) = (println(x); true)\\nt (generic function with 1 method)\\n\\njulia> f(x) = (println(x); false)\\nf (generic function with 1 method)\\n\\njulia> t(1) && t(2)\\n1\\n2\\ntrue\\n\\njulia> t(1) && f(2)\\n1\\n2\\nfalse\\n\\njulia> f(1) && t(2)\\n1\\nfalse\\n\\njulia> f(1) && f(2)\\n1\\nfalse\\n\\njulia> t(1) || t(2)\\n1\\ntrue\\n\\njulia> t(1) || f(2)\\n1\\ntrue\\n\\njulia> f(1) || t(2)\\n1\\n2\\ntrue\\n\\njulia> f(1) || f(2)\\n1\\n2\\nfalseYou can easily experiment in the same way with the associativity and precedence of various combinations of && and || operators.This behavior is frequently used in Julia to form an alternative to very short if statements. Instead of if <cond> <statement> end, one can write <cond> && <statement> (which could be read as: <cond> and then <statement>). Similarly, instead of if ! <cond> <statement> end, one can write <cond> || <statement> (which could be read as: <cond> or else <statement>).For example, a recursive factorial routine could be defined like this:julia> function fact(n::Int)\\n           n >= 0 || error(\\\"n must be non-negative\\\")\\n           n == 0 && return 1\\n           n * fact(n-1)\\n       end\\nfact (generic function with 1 method)\\n\\njulia> fact(5)\\n120\\n\\njulia> fact(0)\\n1\\n\\njulia> fact(-1)\\nERROR: n must be non-negative\\nStacktrace:\\n [1] error at ./error.jl:33 [inlined]\\n [2] fact(::Int64) at ./none:2\\n [3] top-level scopeBoolean operations without short-circuit evaluation can be done with the bitwise boolean operators introduced in Mathematical Operations and Elementary Functions: & and |. These are normal functions, which happen to support infix operator syntax, but always evaluate their arguments:julia> f(1) & t(2)\\n1\\n2\\nfalse\\n\\njulia> t(1) | t(2)\\n1\\n2\\ntrueJust like condition expressions used in if, elseif or the ternary operator, the operands of && or || must be boolean values (true or false). Using a non-boolean value anywhere except for the last entry in a conditional chain is an error:julia> 1 && true\\nERROR: TypeError: non-boolean (Int64) used in boolean contextOn the other hand, any type of expression can be used at the end of a conditional chain. It will be evaluated and returned depending on the preceding conditionals:julia> true && (x = (1, 2, 3))\\n(1, 2, 3)\\n\\njulia> false && (x = (1, 2, 3))\\nfalse\"\n},\n\n{\n    \"location\": \"manual/control-flow.html#man-loops-1\",\n    \"page\": \"Control Flow\",\n    \"title\": \"Repeated Evaluation: Loops\",\n    \"category\": \"section\",\n    \"text\": \"There are two constructs for repeated evaluation of expressions: the while loop and the for loop. Here is an example of a while loop:julia> i = 1;\\n\\njulia> while i <= 5\\n           println(i)\\n           global i += 1\\n       end\\n1\\n2\\n3\\n4\\n5The while loop evaluates the condition expression (i <= 5 in this case), and as long it remains true, keeps also evaluating the body of the while loop. If the condition expression is false when the while loop is first reached, the body is never evaluated.The for loop makes common repeated evaluation idioms easier to write. Since counting up and down like the above while loop does is so common, it can be expressed more concisely with a for loop:julia> for i = 1:5\\n           println(i)\\n       end\\n1\\n2\\n3\\n4\\n5Here the 1:5 is a range object, representing the sequence of numbers 1, 2, 3, 4, 5. The for loop iterates through these values, assigning each one in turn to the variable i. One rather important distinction between the previous while loop form and the for loop form is the scope during which the variable is visible. If the variable i has not been introduced in another scope, in the for loop form, it is visible only inside of the for loop, and not outside/afterwards. You\\'ll either need a new interactive session instance or a different variable name to test this:julia> for j = 1:5\\n           println(j)\\n       end\\n1\\n2\\n3\\n4\\n5\\n\\njulia> j\\nERROR: UndefVarError: j not definedSee Scope of Variables for a detailed explanation of variable scope and how it works in Julia.In general, the for loop construct can iterate over any container. In these cases, the alternative (but fully equivalent) keyword in or \u2208 is typically used instead of =, since it makes the code read more clearly:julia> for i in [1,4,0]\\n           println(i)\\n       end\\n1\\n4\\n0\\n\\njulia> for s \u2208 [\\\"foo\\\",\\\"bar\\\",\\\"baz\\\"]\\n           println(s)\\n       end\\nfoo\\nbar\\nbazVarious types of iterable containers will be introduced and discussed in later sections of the manual (see, e.g., Multi-dimensional Arrays).It is sometimes convenient to terminate the repetition of a while before the test condition is falsified or stop iterating in a for loop before the end of the iterable object is reached. This can be accomplished with the break keyword:julia> i = 1;\\n\\njulia> while true\\n           println(i)\\n           if i >= 5\\n               break\\n           end\\n           global i += 1\\n       end\\n1\\n2\\n3\\n4\\n5\\n\\njulia> for j = 1:1000\\n           println(j)\\n           if j >= 5\\n               break\\n           end\\n       end\\n1\\n2\\n3\\n4\\n5Without the break keyword, the above while loop would never terminate on its own, and the for loop would iterate up to 1000. These loops are both exited early by using break.In other circumstances, it is handy to be able to stop an iteration and move on to the next one immediately. The continue keyword accomplishes this:julia> for i = 1:10\\n           if i % 3 != 0\\n               continue\\n           end\\n           println(i)\\n       end\\n3\\n6\\n9This is a somewhat contrived example since we could produce the same behavior more clearly by negating the condition and placing the println call inside the if block. In realistic usage there is more code to be evaluated after the continue, and often there are multiple points from which one calls continue.Multiple nested for loops can be combined into a single outer loop, forming the cartesian product of its iterables:julia> for i = 1:2, j = 3:4\\n           println((i, j))\\n       end\\n(1, 3)\\n(1, 4)\\n(2, 3)\\n(2, 4)With this syntax, iterables may still refer to outer loop variables; e.g. for i = 1:n, j = 1:i is valid. However a break statement inside such a loop exits the entire nest of loops, not just the inner one. Both variables (i and j) are set to their current iteration values each time the inner loop runs. Therefore, assignments to i will not be visible to subsequent iterations:julia> for i = 1:2, j = 3:4\\n           println((i, j))\\n           i = 0\\n       end\\n(1, 3)\\n(1, 4)\\n(2, 3)\\n(2, 4)If this example were rewritten to use a for keyword for each variable, then the output would be different: the second and fourth values would contain 0.\"\n},\n\n{\n    \"location\": \"manual/control-flow.html#Exception-Handling-1\",\n    \"page\": \"Control Flow\",\n    \"title\": \"Exception Handling\",\n    \"category\": \"section\",\n    \"text\": \"When an unexpected condition occurs, a function may be unable to return a reasonable value to its caller. In such cases, it may be best for the exceptional condition to either terminate the program while printing a diagnostic error message, or if the programmer has provided code to handle such exceptional circumstances then allow that code to take the appropriate action.\"\n},\n\n{\n    \"location\": \"manual/control-flow.html#Built-in-Exceptions-1\",\n    \"page\": \"Control Flow\",\n    \"title\": \"Built-in Exceptions\",\n    \"category\": \"section\",\n    \"text\": \"Exceptions are thrown when an unexpected condition has occurred. The built-in Exceptions listed below all interrupt the normal flow of control.Exception\\nArgumentError\\nBoundsError\\nCompositeException\\nDivideError\\nDomainError\\nEOFError\\nErrorException\\nInexactError\\nInitError\\nInterruptException\\nInvalidStateException\\nKeyError\\nLoadError\\nOutOfMemoryError\\nReadOnlyMemoryError\\nRemoteException\\nMethodError\\nOverflowError\\nMeta.ParseError\\nSystemError\\nTypeError\\nUndefRefError\\nUndefVarError\\nStringIndexErrorFor example, the sqrt function throws a DomainError if applied to a negative real value:julia> sqrt(-1)\\nERROR: DomainError with -1.0:\\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\\nStacktrace:\\n[...]You may define your own exceptions in the following way:julia> struct MyCustomException <: Exception end\"\n},\n\n{\n    \"location\": \"manual/control-flow.html#The-[throw](@ref)-function-1\",\n    \"page\": \"Control Flow\",\n    \"title\": \"The throw function\",\n    \"category\": \"section\",\n    \"text\": \"Exceptions can be created explicitly with throw. For example, a function defined only for nonnegative numbers could be written to throw a DomainError if the argument is negative:julia> f(x) = x>=0 ? exp(-x) : throw(DomainError(x, \\\"argument must be nonnegative\\\"))\\nf (generic function with 1 method)\\n\\njulia> f(1)\\n0.36787944117144233\\n\\njulia> f(-1)\\nERROR: DomainError with -1:\\nargument must be nonnegative\\nStacktrace:\\n [1] f(::Int64) at ./none:1Note that DomainError without parentheses is not an exception, but a type of exception. It needs to be called to obtain an Exception object:julia> typeof(DomainError(nothing)) <: Exception\\ntrue\\n\\njulia> typeof(DomainError) <: Exception\\nfalseAdditionally, some exception types take one or more arguments that are used for error reporting:julia> throw(UndefVarError(:x))\\nERROR: UndefVarError: x not definedThis mechanism can be implemented easily by custom exception types following the way UndefVarError is written:julia> struct MyUndefVarError <: Exception\\n           var::Symbol\\n       end\\n\\njulia> Base.showerror(io::IO, e::MyUndefVarError) = print(io, e.var, \\\" not defined\\\")note: Note\\nWhen writing an error message, it is preferred to make the first word lowercase. For example, size(A) == size(B) || throw(DimensionMismatch(\\\"size of A not equal to size of B\\\"))is preferred oversize(A) == size(B) || throw(DimensionMismatch(\\\"Size of A not equal to size of B\\\")).However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument to a function is a capital letter: size(A,1) == size(B,2) || throw(DimensionMismatch(\\\"A has first dimension...\\\")).\"\n},\n\n{\n    \"location\": \"manual/control-flow.html#Errors-1\",\n    \"page\": \"Control Flow\",\n    \"title\": \"Errors\",\n    \"category\": \"section\",\n    \"text\": \"The error function is used to produce an ErrorException that interrupts the normal flow of control.Suppose we want to stop execution immediately if the square root of a negative number is taken. To do this, we can define a fussy version of the sqrt function that raises an error if its argument is negative:julia> fussy_sqrt(x) = x >= 0 ? sqrt(x) : error(\\\"negative x not allowed\\\")\\nfussy_sqrt (generic function with 1 method)\\n\\njulia> fussy_sqrt(2)\\n1.4142135623730951\\n\\njulia> fussy_sqrt(-1)\\nERROR: negative x not allowed\\nStacktrace:\\n [1] error at ./error.jl:33 [inlined]\\n [2] fussy_sqrt(::Int64) at ./none:1\\n [3] top-level scopeIf fussy_sqrt is called with a negative value from another function, instead of trying to continue execution of the calling function, it returns immediately, displaying the error message in the interactive session:julia> function verbose_fussy_sqrt(x)\\n           println(\\\"before fussy_sqrt\\\")\\n           r = fussy_sqrt(x)\\n           println(\\\"after fussy_sqrt\\\")\\n           return r\\n       end\\nverbose_fussy_sqrt (generic function with 1 method)\\n\\njulia> verbose_fussy_sqrt(2)\\nbefore fussy_sqrt\\nafter fussy_sqrt\\n1.4142135623730951\\n\\njulia> verbose_fussy_sqrt(-1)\\nbefore fussy_sqrt\\nERROR: negative x not allowed\\nStacktrace:\\n [1] error at ./error.jl:33 [inlined]\\n [2] fussy_sqrt at ./none:1 [inlined]\\n [3] verbose_fussy_sqrt(::Int64) at ./none:3\\n [4] top-level scope\"\n},\n\n{\n    \"location\": \"manual/control-flow.html#The-try/catch-statement-1\",\n    \"page\": \"Control Flow\",\n    \"title\": \"The try/catch statement\",\n    \"category\": \"section\",\n    \"text\": \"The try/catch statement allows for Exceptions to be tested for. For example, a customized square root function can be written to automatically call either the real or complex square root method on demand using Exceptions :julia> f(x) = try\\n           sqrt(x)\\n       catch\\n           sqrt(complex(x, 0))\\n       end\\nf (generic function with 1 method)\\n\\njulia> f(1)\\n1.0\\n\\njulia> f(-1)\\n0.0 + 1.0imIt is important to note that in real code computing this function, one would compare x to zero instead of catching an exception. The exception is much slower than simply comparing and branching.try/catch statements also allow the Exception to be saved in a variable. The following contrived example calculates the square root of the second element of x if x is indexable, otherwise assumes x is a real number and returns its square root:julia> sqrt_second(x) = try\\n           sqrt(x[2])\\n       catch y\\n           if isa(y, DomainError)\\n               sqrt(complex(x[2], 0))\\n           elseif isa(y, BoundsError)\\n               sqrt(x)\\n           end\\n       end\\nsqrt_second (generic function with 1 method)\\n\\njulia> sqrt_second([1 4])\\n2.0\\n\\njulia> sqrt_second([1 -4])\\n0.0 + 2.0im\\n\\njulia> sqrt_second(9)\\n3.0\\n\\njulia> sqrt_second(-9)\\nERROR: DomainError with -9.0:\\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\\nStacktrace:\\n[...]Note that the symbol following catch will always be interpreted as a name for the exception, so care is needed when writing try/catch expressions on a single line. The following code will not work to return the value of x in case of an error:try bad() catch x endInstead, use a semicolon or insert a line break after catch:try bad() catch; x end\\n\\ntry bad()\\ncatch\\n    x\\nendThe power of the try/catch construct lies in the ability to unwind a deeply nested computation immediately to a much higher level in the stack of calling functions. There are situations where no error has occurred, but the ability to unwind the stack and pass a value to a higher level is desirable. Julia provides the rethrow, backtrace and catch_backtrace functions for more advanced error handling.\"\n},\n\n{\n    \"location\": \"manual/control-flow.html#finally-Clauses-1\",\n    \"page\": \"Control Flow\",\n    \"title\": \"finally Clauses\",\n    \"category\": \"section\",\n    \"text\": \"In code that performs state changes or uses resources like files, there is typically clean-up work (such as closing files) that needs to be done when the code is finished. Exceptions potentially complicate this task, since they can cause a block of code to exit before reaching its normal end. The finally keyword provides a way to run some code when a given block of code exits, regardless of how it exits.For example, here is how we can guarantee that an opened file is closed:f = open(\\\"file\\\")\\ntry\\n    # operate on file f\\nfinally\\n    close(f)\\nendWhen control leaves the try block (for example due to a return, or just finishing normally), close(f) will be executed. If the try block exits due to an exception, the exception will continue propagating. A catch block may be combined with try and finally as well. In this case the finally block will run after catch has handled the error.\"\n},\n\n{\n    \"location\": \"manual/control-flow.html#man-tasks-1\",\n    \"page\": \"Control Flow\",\n    \"title\": \"Tasks (aka Coroutines)\",\n    \"category\": \"section\",\n    \"text\": \"Tasks are a control flow feature that allows computations to be suspended and resumed in a flexible manner. This feature is sometimes called by other names, such as symmetric coroutines, lightweight threads, cooperative multitasking, or one-shot continuations.When a piece of computing work (in practice, executing a particular function) is designated as a Task, it becomes possible to interrupt it by switching to another Task. The original Task can later be resumed, at which point it will pick up right where it left off. At first, this may seem similar to a function call. However there are two key differences. First, switching tasks does not use any space, so any number of task switches can occur without consuming the call stack. Second, switching among tasks can occur in any order, unlike function calls, where the called function must finish executing before control returns to the calling function.This kind of control flow can make it much easier to solve certain problems. In some problems, the various pieces of required work are not naturally related by function calls; there is no obvious \\\"caller\\\" or \\\"callee\\\" among the jobs that need to be done. An example is the producer-consumer problem, where one complex procedure is generating values and another complex procedure is consuming them. The consumer cannot simply call a producer function to get a value, because the producer may have more values to generate and so might not yet be ready to return. With tasks, the producer and consumer can both run as long as they need to, passing values back and forth as necessary.Julia provides a Channel mechanism for solving this problem. A Channel is a waitable first-in first-out queue which can have multiple tasks reading from and writing to it.Let\\'s define a producer task, which produces values via the put! call. To consume values, we need to schedule the producer to run in a new task. A special Channel constructor which accepts a 1-arg function as an argument can be used to run a task bound to a channel. We can then take! values repeatedly from the channel object:julia> function producer(c::Channel)\\n           put!(c, \\\"start\\\")\\n           for n=1:4\\n               put!(c, 2n)\\n           end\\n           put!(c, \\\"stop\\\")\\n       end;\\n\\njulia> chnl = Channel(producer);\\n\\njulia> take!(chnl)\\n\\\"start\\\"\\n\\njulia> take!(chnl)\\n2\\n\\njulia> take!(chnl)\\n4\\n\\njulia> take!(chnl)\\n6\\n\\njulia> take!(chnl)\\n8\\n\\njulia> take!(chnl)\\n\\\"stop\\\"One way to think of this behavior is that producer was able to return multiple times. Between calls to put!, the producer\\'s execution is suspended and the consumer has control.The returned Channel can be used as an iterable object in a for loop, in which case the loop variable takes on all the produced values. The loop is terminated when the channel is closed.julia> for x in Channel(producer)\\n           println(x)\\n       end\\nstart\\n2\\n4\\n6\\n8\\nstopNote that we did not have to explicitly close the channel in the producer. This is because the act of binding a Channel to a Task associates the open lifetime of a channel with that of the bound task. The channel object is closed automatically when the task terminates. Multiple channels can be bound to a task, and vice-versa.While the Task constructor expects a 0-argument function, the Channel method which creates a channel bound task expects a function that accepts a single argument of type Channel. A common pattern is for the producer to be parameterized, in which case a partial function application is needed to create a 0 or 1 argument anonymous function.For Task objects this can be done either directly or by use of a convenience macro:function mytask(myarg)\\n    ...\\nend\\n\\ntaskHdl = Task(() -> mytask(7))\\n# or, equivalently\\ntaskHdl = @task mytask(7)To orchestrate more advanced work distribution patterns, bind and schedule can be used in conjunction with Task and Channel constructors to explicitly link a set of channels with a set of producer/consumer tasks.Note that currently Julia tasks are not scheduled to run on separate CPU cores. True kernel threads are discussed under the topic of Parallel Computing.\"\n},\n\n{\n    \"location\": \"manual/control-flow.html#Core-task-operations-1\",\n    \"page\": \"Control Flow\",\n    \"title\": \"Core task operations\",\n    \"category\": \"section\",\n    \"text\": \"Let us explore the low level construct yieldto to understand how task switching works. yieldto(task,value) suspends the current task, switches to the specified task, and causes that task\\'s last yieldto call to return the specified value. Notice that yieldto is the only operation required to use task-style control flow; instead of calling and returning we are always just switching to a different task. This is why this feature is also called \\\"symmetric coroutines\\\"; each task is switched to and from using the same mechanism.yieldto is powerful, but most uses of tasks do not invoke it directly. Consider why this might be. If you switch away from the current task, you will probably want to switch back to it at some point, but knowing when to switch back, and knowing which task has the responsibility of switching back, can require considerable coordination. For example, put! and take! are blocking operations, which, when used in the context of channels maintain state to remember who the consumers are. Not needing to manually keep track of the consuming task is what makes put! easier to use than the low-level yieldto.In addition to yieldto, a few other basic functions are needed to use tasks effectively.current_task gets a reference to the currently-running task.\\nistaskdone queries whether a task has exited.\\nistaskstarted queries whether a task has run yet.\\ntask_local_storage manipulates a key-value store specific to the current task.\"\n},\n\n{\n    \"location\": \"manual/control-flow.html#Tasks-and-events-1\",\n    \"page\": \"Control Flow\",\n    \"title\": \"Tasks and events\",\n    \"category\": \"section\",\n    \"text\": \"Most task switches occur as a result of waiting for events such as I/O requests, and are performed by a scheduler included in Julia Base. The scheduler maintains a queue of runnable tasks, and executes an event loop that restarts tasks based on external events such as message arrival.The basic function for waiting for an event is wait. Several objects implement wait; for example, given a Process object, wait will wait for it to exit. wait is often implicit; for example, a wait can happen inside a call to read to wait for data to be available.In all of these cases, wait ultimately operates on a Condition object, which is in charge of queueing and restarting tasks. When a task calls wait on a Condition, the task is marked as non-runnable, added to the condition\\'s queue, and switches to the scheduler. The scheduler will then pick another task to run, or block waiting for external events. If all goes well, eventually an event handler will call notify on the condition, which causes tasks waiting for that condition to become runnable again.A task created explicitly by calling Task is initially not known to the scheduler. This allows you to manage tasks manually using yieldto if you wish. However, when such a task waits for an event, it still gets restarted automatically when the event happens, as you would expect. It is also possible to make the scheduler run a task whenever it can, without necessarily waiting for any events. This is done by calling schedule, or using the @async macro (see Parallel Computing for more details).\"\n},\n\n{\n    \"location\": \"manual/control-flow.html#Task-states-1\",\n    \"page\": \"Control Flow\",\n    \"title\": \"Task states\",\n    \"category\": \"section\",\n    \"text\": \"Tasks have a state field that describes their execution status. A Task state is one of the following symbols:Symbol Meaning\\n:runnable Currently running, or available to be switched to\\n:waiting Blocked waiting for a specific event\\n:queued In the scheduler\\'s run queue about to be restarted\\n:done Successfully finished executing\\n:failed Finished with an uncaught exception\"\n},\n\n{\n    \"location\": \"manual/variables-and-scoping.html#\",\n    \"page\": \"Scope of Variables\",\n    \"title\": \"Scope of Variables\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/variables-and-scoping.html#scope-of-variables-1\",\n    \"page\": \"Scope of Variables\",\n    \"title\": \"Scope of Variables\",\n    \"category\": \"section\",\n    \"text\": \"The scope of a variable is the region of code within which a variable is visible. Variable scoping helps avoid variable naming conflicts. The concept is intuitive: two functions can both have arguments called x without the two x\\'s referring to the same thing. Similarly there are many other cases where different blocks of code can use the same name without referring to the same thing. The rules for when the same variable name does or doesn\\'t refer to the same thing are called scope rules; this section spells them out in detail.Certain constructs in the language introduce scope blocks, which are regions of code that are eligible to be the scope of some set of variables. The scope of a variable cannot be an arbitrary set of source lines; instead, it will always line up with one of these blocks. There are two main types of scopes in Julia, global scope and local scope, the latter can be nested. The constructs introducing scope blocks are:\"\n},\n\n{\n    \"location\": \"manual/variables-and-scoping.html#man-scope-table-1\",\n    \"page\": \"Scope of Variables\",\n    \"title\": \"\",\n    \"category\": \"section\",\n    \"text\": \"Scope blocks that may nest only in other global scope blocks:\\nglobal scope\\nmodule, baremodule\\nat interactive prompt (REPL)\\nlocal scope (don\\'t allow nesting)\\n(mutable) struct, macro\\nScope blocks which may nest anywhere (in global or local scope):\\nlocal scope\\nfor, while, try-catch-finally, let\\nfunctions (either syntax, anonymous & do-blocks)\\ncomprehensions, broadcast-fusingNotably missing from this table are begin blocks and if blocks which do not introduce new scope blocks. Both types of scopes follow somewhat different rules which will be explained below.Julia uses lexical scoping, meaning that a function\\'s scope does not inherit from its caller\\'s scope, but from the scope in which the function was defined. For example, in the following code the x inside foo refers to the x in the global scope of its module Bar:julia> module Bar\\n           x = 1\\n           foo() = x\\n       end;and not a x in the scope where foo is used:julia> import .Bar\\n\\njulia> x = -1;\\n\\njulia> Bar.foo()\\n1Thus lexical scope means that the scope of variables can be inferred from the source code alone.\"\n},\n\n{\n    \"location\": \"manual/variables-and-scoping.html#Global-Scope-1\",\n    \"page\": \"Scope of Variables\",\n    \"title\": \"Global Scope\",\n    \"category\": \"section\",\n    \"text\": \"Each module introduces a new global scope, separate from the global scope of all other modules; there is no all-encompassing global scope. Modules can introduce variables of other modules into their scope through the using or import statements or through qualified access using the dot-notation, i.e. each module is a so-called namespace. Note that variable bindings can only be changed within their global scope and not from an outside module.julia> module A\\n           a = 1 # a global in A\\'s scope\\n       end;\\n\\njulia> module B\\n           module C\\n               c = 2\\n           end\\n           b = C.c    # can access the namespace of a nested global scope\\n                      # through a qualified access\\n           import ..A # makes module A available\\n           d = A.a\\n       end;\\n\\njulia> module D\\n           b = a # errors as D\\'s global scope is separate from A\\'s\\n       end;\\nERROR: UndefVarError: a not defined\\n\\njulia> module E\\n           import ..A # make module A available\\n           A.a = 2    # throws below error\\n       end;\\nERROR: cannot assign variables in other modulesNote that the interactive prompt (aka REPL) is in the global scope of the module Main.\"\n},\n\n{\n    \"location\": \"manual/variables-and-scoping.html#Local-Scope-1\",\n    \"page\": \"Scope of Variables\",\n    \"title\": \"Local Scope\",\n    \"category\": \"section\",\n    \"text\": \"A new local scope is introduced by most code blocks (see above table for a complete list). A local scope inherits all the variables from a parent local scope, both for reading and writing. Additionally, the local scope inherits all globals that are assigned to in its parent global scope block (if it is surrounded by a global if or begin scope). Unlike global scopes, local scopes are not namespaces, thus variables in an inner scope cannot be retrieved from the parent scope through some sort of qualified access.The following rules and examples pertain to local scopes. A newly introduced variable in a local scope does not back-propagate to its parent scope. For example, here the z is not introduced into the top-level scope:julia> for i = 1:10\\n           z = i\\n       end\\n\\njulia> z\\nERROR: UndefVarError: z not defined(Note, in this and all following examples it is assumed that their top-level is a global scope with a clean workspace, for instance a newly started REPL.)Inside a local scope a variable can be forced to be a new local variable using the local keyword:julia> x = 0;\\n\\njulia> for i = 1:10\\n           local x # this is also the default\\n           x = i + 1\\n       end\\n\\njulia> x\\n0Inside a local scope a global variable can be assigned to by using the keyword global:julia> for i = 1:10\\n           global z\\n           z = i\\n       end\\n\\njulia> z\\n10The location of both the local and global keywords within the scope block is irrelevant. The following is equivalent to the last example (although stylistically worse):julia> for i = 1:10\\n           z = i\\n           global z\\n       end\\n\\njulia> z\\n10The local and global keywords can also be applied to destructuring assignments, e.g. local x, y = 1, 2. In this case the keyword affects all listed variables.Local scopes are introduced by most block keywords, with notable exceptions of begin and if.In a local scope, all variables are inherited from its parent global scope block unless:an assignment would result in a modified global variable, or\\na variable is specifically marked with the keyword local.Thus global variables are only inherited for reading but not for writing:julia> x, y = 1, 2;\\n\\njulia> function foo()\\n           x = 2        # assignment introduces a new local\\n           return x + y # y refers to the global\\n       end;\\n\\njulia> foo()\\n4\\n\\njulia> x\\n1An explicit global is needed to assign to a global variable:sidebar: Avoiding globals\\nAvoiding changing the value of global variables is considered by many to be a programming best-practice. One reason for this is that remotely changing the state of global variables in other modules should be done with care as it makes the local behavior of the program hard to reason about. This is why the scope blocks that introduce local scope require the global keyword to declare the intent to modify a global variable.julia> x = 1;\\n\\njulia> function foobar()\\n           global x = 2\\n       end;\\n\\njulia> foobar();\\n\\njulia> x\\n2Note that nested functions can modify their parent scope\\'s local variables:julia> x, y = 1, 2;\\n\\njulia> function baz()\\n           x = 2 # introduces a new local\\n           function bar()\\n               x = 10       # modifies the parent\\'s x\\n               return x + y # y is global\\n           end\\n           return bar() + x # 12 + 10 (x is modified in call of bar())\\n       end;\\n\\njulia> baz()\\n22\\n\\njulia> x, y # verify that global x and y are unchanged\\n(1, 2)The reason to allow modifying local variables of parent scopes in nested functions is to allow constructing closures which have a private state, for instance the state variable in the following example:julia> let state = 0\\n           global counter() = (state += 1)\\n       end;\\n\\njulia> counter()\\n1\\n\\njulia> counter()\\n2See also the closures in the examples in the next two sections. A variable such as x in the first example and state in the second that is inherited from the enclosing scope by the inner function is sometimes called a captured variable. Captured variables can present performance challenges discussed in performance tips.The distinction between inheriting global scope and nesting local scope can lead to some slight differences between functions defined in local vs. global scopes for variable assignments. Consider the modification of the last example by moving bar to the global scope:julia> x, y = 1, 2;\\n\\njulia> function bar()\\n           x = 10 # local, no longer a closure variable\\n           return x + y\\n       end;\\n\\njulia> function quz()\\n           x = 2 # local\\n           return bar() + x # 12 + 2 (x is not modified)\\n       end;\\n\\njulia> quz()\\n14\\n\\njulia> x, y # verify that global x and y are unchanged\\n(1, 2)Note that the above nesting rules do not pertain to type and macro definitions as they can only appear at the global scope. There are special scoping rules concerning the evaluation of default and keyword function arguments which are described in the Function section.An assignment introducing a variable used inside a function, type or macro definition need not come before its inner usage:julia> f = y -> y + a;\\n\\njulia> f(3)\\nERROR: UndefVarError: a not defined\\nStacktrace:\\n[...]\\n\\njulia> a = 1\\n1\\n\\njulia> f(3)\\n4This behavior may seem slightly odd for a normal variable, but allows for named functions \u2013 which are just normal variables holding function objects \u2013 to be used before they are defined. This allows functions to be defined in whatever order is intuitive and convenient, rather than forcing bottom up ordering or requiring forward declarations, as long as they are defined by the time they are actually called. As an example, here is an inefficient, mutually recursive way to test if positive integers are even or odd:julia> even(n) = (n == 0) ? true : odd(n - 1);\\n\\njulia> odd(n) = (n == 0) ? false : even(n - 1);\\n\\njulia> even(3)\\nfalse\\n\\njulia> odd(3)\\ntrueJulia provides built-in, efficient functions to test for oddness and evenness called iseven and isodd so the above definitions should only be considered to be examples of scope, not efficient design.\"\n},\n\n{\n    \"location\": \"manual/variables-and-scoping.html#Let-Blocks-1\",\n    \"page\": \"Scope of Variables\",\n    \"title\": \"Let Blocks\",\n    \"category\": \"section\",\n    \"text\": \"Unlike assignments to local variables, let statements allocate new variable bindings each time they run. An assignment modifies an existing value location, and let creates new locations. This difference is usually not important, and is only detectable in the case of variables that outlive their scope via closures. The let syntax accepts a comma-separated series of assignments and variable names:julia> x, y, z = -1, -1, -1;\\n\\njulia> let x = 1, z\\n           println(\\\"x: $x, y: $y\\\") # x is local variable, y the global\\n           println(\\\"z: $z\\\") # errors as z has not been assigned yet but is local\\n       end\\nx: 1, y: -1\\nERROR: UndefVarError: z not definedThe assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like let x = x since the two x variables are distinct and have separate storage. Here is an example where the behavior of let is needed:julia> Fs = Vector{Any}(undef, 2); i = 1;\\n\\njulia> while i <= 2\\n           Fs[i] = ()->i\\n           global i += 1\\n       end\\n\\njulia> Fs[1]()\\n3\\n\\njulia> Fs[2]()\\n3Here we create and store two closures that return variable i. However, it is always the same variable i, so the two closures behave identically. We can use let to create a new binding for i:julia> Fs = Vector{Any}(undef, 2); i = 1;\\n\\njulia> while i <= 2\\n           let i = i\\n               Fs[i] = ()->i\\n           end\\n           global i += 1\\n       end\\n\\njulia> Fs[1]()\\n1\\n\\njulia> Fs[2]()\\n2Since the begin construct does not introduce a new scope, it can be useful to use a zero-argument let to just introduce a new scope block without creating any new bindings:julia> let\\n           local x = 1\\n           let\\n               local x = 2\\n           end\\n           x\\n       end\\n1Since let introduces a new scope block, the inner local x is a different variable than the outer local x.\"\n},\n\n{\n    \"location\": \"manual/variables-and-scoping.html#For-Loops-and-Comprehensions-1\",\n    \"page\": \"Scope of Variables\",\n    \"title\": \"For Loops and Comprehensions\",\n    \"category\": \"section\",\n    \"text\": \"for loops, while loops, and Comprehensions have the following behavior: any new variables introduced in their body scopes are freshly allocated for each loop iteration, as if the loop body were surrounded by a let block:julia> Fs = Vector{Any}(undef, 2);\\n\\njulia> for j = 1:2\\n           Fs[j] = ()->j\\n       end\\n\\njulia> Fs[1]()\\n1\\n\\njulia> Fs[2]()\\n2A for loop or comprehension iteration variable is always a new variable:julia> function f()\\n           i = 0\\n           for i = 1:3\\n           end\\n           return i\\n       end;\\n\\njulia> f()\\n0However, it is occasionally useful to reuse an existing variable as the iteration variable. This can be done conveniently by adding the keyword outer:julia> function f()\\n           i = 0\\n           for outer i = 1:3\\n           end\\n           return i\\n       end;\\n\\njulia> f()\\n3\"\n},\n\n{\n    \"location\": \"manual/variables-and-scoping.html#Constants-1\",\n    \"page\": \"Scope of Variables\",\n    \"title\": \"Constants\",\n    \"category\": \"section\",\n    \"text\": \"A common use of variables is giving names to specific, unchanging values. Such variables are only assigned once. This intent can be conveyed to the compiler using the const keyword:julia> const e  = 2.71828182845904523536;\\n\\njulia> const pi = 3.14159265358979323846;Multiple variables can be declared in a single const statement:julia> const a, b = 1, 2\\n(1, 2)The const declaration should only be used in global scope on globals. It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. If a global variable will not change, adding a const declaration solves this performance problem.Local constants are quite different. The compiler is able to determine automatically when a local variable is constant, so local constant declarations are not necessary, and in fact are currently not supported.Special top-level assignments, such as those performed by the function and struct keywords, are constant by default.Note that const only affects the variable binding; the variable may be bound to a mutable object (such as an array), and that object may still be modified. Additionally when one tries to assign a value a variable that is declared constant the following scenarios are possible:if a new value has a different type than the type of the constant then an error is thrown:julia> const x = 1.0\\n1.0\\n\\njulia> x = 1\\nERROR: invalid redefinition of constant xif a new value has the same type as the constant then a warning is printed:julia> const y = 1.0\\n1.0\\n\\njulia> y = 2.0\\nWARNING: redefining constant y\\n2.0if an assignment would not result in the change of variable value no message is given:julia> const z = 100\\n100\\n\\njulia> z = 100\\n100The last rule applies for immutable objects even if the vairable binding would change, e.g.:julia> const s1 = \\\"1\\\"\\n\\\"1\\\"\\n\\njulia> s2 = \\\"1\\\"\\n\\\"1\\\"\\n\\njulia> pointer.([s1, s2], 1)\\n2-element Array{Ptr{UInt8},1}:\\n Ptr{UInt8} @0x00000000132c9638\\n Ptr{UInt8} @0x0000000013dd3d18\\n\\njulia> s1 = s2\\n\\\"1\\\"\\n\\njulia> pointer.([s1, s2], 1)\\n2-element Array{Ptr{UInt8},1}:\\n Ptr{UInt8} @0x0000000013dd3d18\\n Ptr{UInt8} @0x0000000013dd3d18However, for mutable objects the warning is printed as expected:julia> const a = [1]\\n1-element Array{Int64,1}:\\n 1\\n\\njulia> a = [1]\\nWARNING: redefining constant a\\n1-element Array{Int64,1}:\\n 1Note that although possible, changing the value of a variable that is declared as constant is strongly discouraged. For instance, if a method references a constant and is already compiled before the constant is changed then it might keep using the old value:julia> const x = 1\\n1\\n\\njulia> f() = x\\nf (generic function with 1 method)\\n\\njulia> f()\\n1\\n\\njulia> x = 2\\nWARNING: redefining constant x\\n2\\n\\njulia> f()\\n1\"\n},\n\n{\n    \"location\": \"manual/types.html#\",\n    \"page\": \"Types\",\n    \"title\": \"Types\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/types.html#man-types-1\",\n    \"page\": \"Types\",\n    \"title\": \"Types\",\n    \"category\": \"section\",\n    \"text\": \"Type systems have traditionally fallen into two quite different camps: static type systems, where every program expression must have a type computable before the execution of the program, and dynamic type systems, where nothing is known about types until run time, when the actual values manipulated by the program are available. Object orientation allows some flexibility in statically typed languages by letting code be written without the precise types of values being known at compile time. The ability to write code that can operate on different types is called polymorphism. All code in classic dynamically typed languages is polymorphic: only by explicitly checking types, or when objects fail to support operations at run-time, are the types of any values ever restricted.Julia\\'s type system is dynamic, but gains some of the advantages of static type systems by making it possible to indicate that certain values are of specific types. This can be of great assistance in generating efficient code, but even more significantly, it allows method dispatch on the types of function arguments to be deeply integrated with the language. Method dispatch is explored in detail in Methods, but is rooted in the type system presented here.The default behavior in Julia when types are omitted is to allow values to be of any type. Thus, one can write many useful Julia functions without ever explicitly using types. When additional expressiveness is needed, however, it is easy to gradually introduce explicit type annotations into previously \\\"untyped\\\" code. Adding annotations serves three primary purposes: to take advantage of Julia\\'s powerful multiple-dispatch mechanism,  to improve human readability, and to catch programmer errors.Describing Julia in the lingo of type systems, it is: dynamic, nominative and parametric. Generic types can be parameterized, and the hierarchical relationships between types are explicitly declared, rather than implied by compatible structure. One particularly distinctive feature of Julia\\'s type system is that concrete types may not subtype each other: all concrete types are final and may only have abstract types as their supertypes. While this might at first seem unduly restrictive, it has many beneficial consequences with surprisingly few drawbacks. It turns out that being able to inherit behavior is much more important than being able to inherit structure, and inheriting both causes significant difficulties in traditional object-oriented languages. Other high-level aspects of Julia\\'s type system that should be mentioned up front are:There is no division between object and non-object values: all values in Julia are true objects having a type that belongs to a single, fully connected type graph, all nodes of which are equally first-class as types.\\nThere is no meaningful concept of a \\\"compile-time type\\\": the only type a value has is its actual type when the program is running. This is called a \\\"run-time type\\\" in object-oriented languages where the combination of static compilation with polymorphism makes this distinction significant.\\nOnly values, not variables, have types \u2013 variables are simply names bound to values.\\nBoth abstract and concrete types can be parameterized by other types. They can also be parameterized by symbols, by values of any type for which isbits returns true (essentially, things like numbers and bools that are stored like C types or structs with no pointers to other objects), and also by tuples thereof. Type parameters may be omitted when they do not need to be referenced or restricted.Julia\\'s type system is designed to be powerful and expressive, yet clear, intuitive and unobtrusive. Many Julia programmers may never feel the need to write code that explicitly uses types. Some kinds of programming, however, become clearer, simpler, faster and more robust with declared types.\"\n},\n\n{\n    \"location\": \"manual/types.html#Type-Declarations-1\",\n    \"page\": \"Types\",\n    \"title\": \"Type Declarations\",\n    \"category\": \"section\",\n    \"text\": \"The :: operator can be used to attach type annotations to expressions and variables in programs. There are two primary reasons to do this:As an assertion to help confirm that your program works the way you expect,\\nTo provide extra type information to the compiler, which can then improve performance in some casesWhen appended to an expression computing a value, the :: operator is read as \\\"is an instance of\\\". It can be used anywhere to assert that the value of the expression on the left is an instance of the type on the right. When the type on the right is concrete, the value on the left must have that type as its implementation \u2013 recall that all concrete types are final, so no implementation is a subtype of any other. When the type is abstract, it suffices for the value to be implemented by a concrete type that is a subtype of the abstract type. If the type assertion is not true, an exception is thrown, otherwise, the left-hand value is returned:julia> (1+2)::AbstractFloat\\nERROR: TypeError: in typeassert, expected AbstractFloat, got Int64\\n\\njulia> (1+2)::Int\\n3This allows a type assertion to be attached to any expression in-place.When appended to a variable on the left-hand side of an assignment, or as part of a local declaration, the :: operator means something a bit different: it declares the variable to always have the specified type, like a type declaration in a statically-typed language such as C. Every value assigned to the variable will be converted to the declared type using convert:julia> function foo()\\n           x::Int8 = 100\\n           x\\n       end\\nfoo (generic function with 1 method)\\n\\njulia> foo()\\n100\\n\\njulia> typeof(ans)\\nInt8This feature is useful for avoiding performance \\\"gotchas\\\" that could occur if one of the assignments to a variable changed its type unexpectedly.This \\\"declaration\\\" behavior only occurs in specific contexts:local x::Int8  # in a local declaration\\nx::Int8 = 10   # as the left-hand side of an assignmentand applies to the whole current scope, even before the declaration. Currently, type declarations cannot be used in global scope, e.g. in the REPL, since Julia does not yet have constant-type globals.Declarations can also be attached to function definitions:function sinc(x)::Float64\\n    if x == 0\\n        return 1\\n    end\\n    return sin(pi*x)/(pi*x)\\nendReturning from this function behaves just like an assignment to a variable with a declared type: the value is always converted to Float64.\"\n},\n\n{\n    \"location\": \"manual/types.html#Abstract-Types-1\",\n    \"page\": \"Types\",\n    \"title\": \"Abstract Types\",\n    \"category\": \"section\",\n    \"text\": \"Abstract types cannot be instantiated, and serve only as nodes in the type graph, thereby describing sets of related concrete types: those concrete types which are their descendants. We begin with abstract types even though they have no instantiation because they are the backbone of the type system: they form the conceptual hierarchy which makes Julia\\'s type system more than just a collection of object implementations.Recall that in Integers and Floating-Point Numbers, we introduced a variety of concrete types of numeric values: Int8, UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64, Int128, UInt128, Float16, Float32, and Float64. Although they have different representation sizes, Int8, Int16, Int32, Int64 and Int128 all have in common that they are signed integer types. Likewise UInt8, UInt16, UInt32, UInt64 and UInt128 are all unsigned integer types, while Float16, Float32 and Float64 are distinct in being floating-point types rather than integers. It is common for a piece of code to make sense, for example, only if its arguments are some kind of integer, but not really depend on what particular kind of integer. For example, the greatest common denominator algorithm works for all kinds of integers, but will not work for floating-point numbers. Abstract types allow the construction of a hierarchy of types, providing a context into which concrete types can fit. This allows you, for example, to easily program to any type that is an integer, without restricting an algorithm to a specific type of integer.Abstract types are declared using the abstract type keyword. The general syntaxes for declaring an abstract type are:abstract type \u00abname\u00bb end\\nabstract type \u00abname\u00bb <: \u00absupertype\u00bb endThe abstract type keyword introduces a new abstract type, whose name is given by \u00abname\u00bb. This name can be optionally followed by <: and an already-existing type, indicating that the newly declared abstract type is a subtype of this \\\"parent\\\" type.When no supertype is given, the default supertype is Any \u2013 a predefined abstract type that all objects are instances of and all types are subtypes of. In type theory, Any is commonly called \\\"top\\\" because it is at the apex of the type graph. Julia also has a predefined abstract \\\"bottom\\\" type, at the nadir of the type graph, which is written as Union{}. It is the exact opposite of Any: no object is an instance of Union{} and all types are supertypes of Union{}.Let\\'s consider some of the abstract types that make up Julia\\'s numerical hierarchy:abstract type Number end\\nabstract type Real     <: Number end\\nabstract type AbstractFloat <: Real end\\nabstract type Integer  <: Real end\\nabstract type Signed   <: Integer end\\nabstract type Unsigned <: Integer endThe Number type is a direct child type of Any, and Real is its child. In turn, Real has two children (it has more, but only two are shown here; we\\'ll get to the others later): Integer and AbstractFloat, separating the world into representations of integers and representations of real numbers. Representations of real numbers include, of course, floating-point types, but also include other types, such as rationals. Hence, AbstractFloat is a proper subtype of Real, including only floating-point representations of real numbers. Integers are further subdivided into Signed and Unsigned varieties.The <: operator in general means \\\"is a subtype of\\\", and, used in declarations like this, declares the right-hand type to be an immediate supertype of the newly declared type. It can also be used in expressions as a subtype operator which returns true when its left operand is a subtype of its right operand:julia> Integer <: Number\\ntrue\\n\\njulia> Integer <: AbstractFloat\\nfalseAn important use of abstract types is to provide default implementations for concrete types. To give a simple example, consider:function myplus(x,y)\\n    x+y\\nendThe first thing to note is that the above argument declarations are equivalent to x::Any and y::Any. When this function is invoked, say as myplus(2,5), the dispatcher chooses the most specific method named myplus that matches the given arguments. (See Methods for more information on multiple dispatch.)Assuming no method more specific than the above is found, Julia next internally defines and compiles a method called myplus specifically for two Int arguments based on the generic function given above, i.e., it implicitly defines and compiles:function myplus(x::Int,y::Int)\\n    x+y\\nendand finally, it invokes this specific method.Thus, abstract types allow programmers to write generic functions that can later be used as the default method by many combinations of concrete types. Thanks to multiple dispatch, the programmer has full control over whether the default or more specific method is used.An important point to note is that there is no loss in performance if the programmer relies on a function whose arguments are abstract types, because it is recompiled for each tuple of argument concrete types with which it is invoked. (There may be a performance issue, however, in the case of function arguments that are containers of abstract types; see Performance Tips.)\"\n},\n\n{\n    \"location\": \"manual/types.html#Primitive-Types-1\",\n    \"page\": \"Types\",\n    \"title\": \"Primitive Types\",\n    \"category\": \"section\",\n    \"text\": \"A primitive type is a concrete type whose data consists of plain old bits. Classic examples of primitive types are integers and floating-point values. Unlike most languages, Julia lets you declare your own primitive types, rather than providing only a fixed set of built-in ones. In fact, the standard primitive types are all defined in the language itself:primitive type Float16 <: AbstractFloat 16 end\\nprimitive type Float32 <: AbstractFloat 32 end\\nprimitive type Float64 <: AbstractFloat 64 end\\n\\nprimitive type Bool <: Integer 8 end\\nprimitive type Char <: AbstractChar 32 end\\n\\nprimitive type Int8    <: Signed   8 end\\nprimitive type UInt8   <: Unsigned 8 end\\nprimitive type Int16   <: Signed   16 end\\nprimitive type UInt16  <: Unsigned 16 end\\nprimitive type Int32   <: Signed   32 end\\nprimitive type UInt32  <: Unsigned 32 end\\nprimitive type Int64   <: Signed   64 end\\nprimitive type UInt64  <: Unsigned 64 end\\nprimitive type Int128  <: Signed   128 end\\nprimitive type UInt128 <: Unsigned 128 endThe general syntaxes for declaring a primitive type are:primitive type \u00abname\u00bb \u00abbits\u00bb end\\nprimitive type \u00abname\u00bb <: \u00absupertype\u00bb \u00abbits\u00bb endThe number of bits indicates how much storage the type requires and the name gives the new type a name. A primitive type can optionally be declared to be a subtype of some supertype. If a supertype is omitted, then the type defaults to having Any as its immediate supertype. The declaration of Bool above therefore means that a boolean value takes eight bits to store, and has Integer as its immediate supertype. Currently, only sizes that are multiples of 8 bits are supported. Therefore, boolean values, although they really need just a single bit, cannot be declared to be any smaller than eight bits.The types Bool, Int8 and UInt8 all have identical representations: they are eight-bit chunks of memory. Since Julia\\'s type system is nominative, however, they are not interchangeable despite having identical structure. A fundamental difference between them is that they have different supertypes: Bool\\'s direct supertype is Integer, Int8\\'s is Signed, and UInt8\\'s is Unsigned. All other differences between Bool, Int8, and UInt8 are matters of behavior \u2013 the way functions are defined to act when given objects of these types as arguments. This is why a nominative type system is necessary: if structure determined type, which in turn dictates behavior, then it would be impossible to make Bool behave any differently than Int8 or UInt8.\"\n},\n\n{\n    \"location\": \"manual/types.html#Composite-Types-1\",\n    \"page\": \"Types\",\n    \"title\": \"Composite Types\",\n    \"category\": \"section\",\n    \"text\": \"Composite types are called records, structs, or objects in various languages. A composite type is a collection of named fields, an instance of which can be treated as a single value. In many languages, composite types are the only kind of user-definable type, and they are by far the most commonly used user-defined type in Julia as well.In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also have named functions associated with them, and the combination is called an \\\"object\\\". In purer object-oriented languages, such as Ruby or Smalltalk, all values are objects whether they are composites or not. In less pure object oriented languages, including C++ and Java, some values, such as integers and floating-point values, are not objects, while instances of user-defined composite types are true objects with associated methods. In Julia, all values are objects, but functions are not bundled with the objects they operate on. This is necessary since Julia chooses which method of a function to use by multiple dispatch, meaning that the types of all of a function\\'s arguments are considered when selecting a method, rather than just the first one (see Methods for more information on methods and dispatch). Thus, it would be inappropriate for functions to \\\"belong\\\" to only their first argument. Organizing methods into function objects rather than having named bags of methods \\\"inside\\\" each object ends up being a highly beneficial aspect of the language design.Composite types are introduced with the struct keyword followed by a block of field names, optionally annotated with types using the :: operator:julia> struct Foo\\n           bar\\n           baz::Int\\n           qux::Float64\\n       endFields with no type annotation default to Any, and can accordingly hold any type of value.New objects of type Foo are created by applying the Foo type object like a function to values for its fields:julia> foo = Foo(\\\"Hello, world.\\\", 23, 1.5)\\nFoo(\\\"Hello, world.\\\", 23, 1.5)\\n\\njulia> typeof(foo)\\nFooWhen a type is applied like a function it is called a constructor. Two constructors are generated automatically (these are called default constructors). One accepts any arguments and calls convert to convert them to the types of the fields, and the other accepts arguments that match the field types exactly. The reason both of these are generated is that this makes it easier to add new definitions without inadvertently replacing a default constructor.Since the bar field is unconstrained in type, any value will do. However, the value for baz must be convertible to Int:julia> Foo((), 23.5, 1)\\nERROR: InexactError: Int64(Int64, 23.5)\\nStacktrace:\\n[...]You may find a list of field names using the fieldnames function.julia> fieldnames(Foo)\\n(:bar, :baz, :qux)You can access the field values of a composite object using the traditional foo.bar notation:julia> foo.bar\\n\\\"Hello, world.\\\"\\n\\njulia> foo.baz\\n23\\n\\njulia> foo.qux\\n1.5Composite objects declared with struct are immutable; they cannot be modified after construction. This may seem odd at first, but it has several advantages:It can be more efficient. Some structs can be packed efficiently into arrays, and in some cases the compiler is able to avoid allocating immutable objects entirely.\\nIt is not possible to violate the invariants provided by the type\\'s constructors.\\nCode using immutable objects can be easier to reason about.An immutable object might contain mutable objects, such as arrays, as fields. Those contained objects will remain mutable; only the fields of the immutable object itself cannot be changed to point to different objects.Where required, mutable composite objects can be declared with the keyword mutable struct, to be discussed in the next section.Immutable composite types with no fields are singletons; there can be only one instance of such types:julia> struct NoFields\\n       end\\n\\njulia> NoFields() === NoFields()\\ntrueThe === function confirms that the \\\"two\\\" constructed instances of NoFields are actually one and the same. Singleton types are described in further detail below.There is much more to say about how instances of composite types are created, but that discussion depends on both Parametric Types and on Methods, and is sufficiently important to be addressed in its own section: Constructors.\"\n},\n\n{\n    \"location\": \"manual/types.html#Mutable-Composite-Types-1\",\n    \"page\": \"Types\",\n    \"title\": \"Mutable Composite Types\",\n    \"category\": \"section\",\n    \"text\": \"If a composite type is declared with mutable struct instead of struct, then instances of it can be modified:julia> mutable struct Bar\\n           baz\\n           qux::Float64\\n       end\\n\\njulia> bar = Bar(\\\"Hello\\\", 1.5);\\n\\njulia> bar.qux = 2.0\\n2.0\\n\\njulia> bar.baz = 1//2\\n1//2In order to support mutation, such objects are generally allocated on the heap, and have stable memory addresses. A mutable object is like a little container that might hold different values over time, and so can only be reliably identified with its address. In contrast, an instance of an immutable type is associated with specific field values \u2013- the field values alone tell you everything about the object. In deciding whether to make a type mutable, ask whether two instances with the same field values would be considered identical, or if they might need to change independently over time. If they would be considered identical, the type should probably be immutable.To recap, two essential properties define immutability in Julia:It is not permitted to modify the value of an immutable type.\\nFor bits types this means that the bit pattern of a value once set will never change and that value is the identity of a bits type.\\nFor composite  types, this means that the identity of the values of its fields will never change. When the fields are bits types, that means their bits will never change, for fields whose values are mutable types like arrays, that means the fields will always refer to the same mutable value even though that mutable value\\'s content may itself be modified.\\nAn object with an immutable type may be copied freely by the compiler since its immutability makes it impossible to programmatically distinguish between the original object and a copy.\\nIn particular, this means that small enough immutable values like integers and floats are typically passed to functions in registers (or stack allocated).\\nMutable values, on the other hand are heap-allocated and passed to functions as pointers to heap-allocated values except in cases where the compiler is sure that there\\'s no way to tell that this is not what is happening.\"\n},\n\n{\n    \"location\": \"manual/types.html#Declared-Types-1\",\n    \"page\": \"Types\",\n    \"title\": \"Declared Types\",\n    \"category\": \"section\",\n    \"text\": \"The three kinds of types (abstract, primitive, composite) discussed in the previous sections are actually all closely related. They share the same key properties:They are explicitly declared.\\nThey have names.\\nThey have explicitly declared supertypes.\\nThey may have parameters.Because of these shared properties, these types are internally represented as instances of the same concept, DataType, which is the type of any of these types:julia> typeof(Real)\\nDataType\\n\\njulia> typeof(Int)\\nDataTypeA DataType may be abstract or concrete. If it is concrete, it has a specified size, storage layout, and (optionally) field names. Thus a primitive type is a DataType with nonzero size, but no field names. A composite type is a DataType that has field names or is empty (zero size).Every concrete value in the system is an instance of some DataType.\"\n},\n\n{\n    \"location\": \"manual/types.html#Type-Unions-1\",\n    \"page\": \"Types\",\n    \"title\": \"Type Unions\",\n    \"category\": \"section\",\n    \"text\": \"A type union is a special abstract type which includes as objects all instances of any of its argument types, constructed using the special Union keyword:julia> IntOrString = Union{Int,AbstractString}\\nUnion{Int64, AbstractString}\\n\\njulia> 1 :: IntOrString\\n1\\n\\njulia> \\\"Hello!\\\" :: IntOrString\\n\\\"Hello!\\\"\\n\\njulia> 1.0 :: IntOrString\\nERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got Float64The compilers for many languages have an internal union construct for reasoning about types; Julia simply exposes it to the programmer. The Julia compiler is able to generate efficient code in the presence of Union types with a small number of types [1], by generating specialized code in separate branches for each possible type.A particularly useful case of a Union type is Union{T, Nothing}, where T can be any type and Nothing is the singleton type whose only instance is the object nothing. This pattern is the Julia equivalent of Nullable, Option or Maybe types in other languages. Declaring a function argument or a field as Union{T, Nothing} allows setting it either to a value of type T, or to nothing to indicate that there is no value. See this FAQ entry for more information.\"\n},\n\n{\n    \"location\": \"manual/types.html#Parametric-Types-1\",\n    \"page\": \"Types\",\n    \"title\": \"Parametric Types\",\n    \"category\": \"section\",\n    \"text\": \"An important and powerful feature of Julia\\'s type system is that it is parametric: types can take parameters, so that type declarations actually introduce a whole family of new types \u2013 one for each possible combination of parameter values. There are many languages that support some version of generic programming, wherein data structures and algorithms to manipulate them may be specified without specifying the exact types involved. For example, some form of generic programming exists in ML, Haskell, Ada, Eiffel, C++, Java, C#, F#, and Scala, just to name a few. Some of these languages support true parametric polymorphism (e.g. ML, Haskell, Scala), while others support ad-hoc, template-based styles of generic programming (e.g. C++, Java). With so many different varieties of generic programming and parametric types in various languages, we won\\'t even attempt to compare Julia\\'s parametric types to other languages, but will instead focus on explaining Julia\\'s system in its own right. We will note, however, that because Julia is a dynamically typed language and doesn\\'t need to make all type decisions at compile time, many traditional difficulties encountered in static parametric type systems can be relatively easily handled.All declared types (the DataType variety) can be parameterized, with the same syntax in each case. We will discuss them in the following order: first, parametric composite types, then parametric abstract types, and finally parametric primitive types.\"\n},\n\n{\n    \"location\": \"manual/types.html#Parametric-Composite-Types-1\",\n    \"page\": \"Types\",\n    \"title\": \"Parametric Composite Types\",\n    \"category\": \"section\",\n    \"text\": \"Type parameters are introduced immediately after the type name, surrounded by curly braces:julia> struct Point{T}\\n           x::T\\n           y::T\\n       endThis declaration defines a new parametric type, Point{T}, holding two \\\"coordinates\\\" of type T. What, one may ask, is T? Well, that\\'s precisely the point of parametric types: it can be any type at all (or a value of any bits type, actually, although here it\\'s clearly used as a type). Point{Float64} is a concrete type equivalent to the type defined by replacing T in the definition of Point with Float64. Thus, this single declaration actually declares an unlimited number of types: Point{Float64}, Point{AbstractString}, Point{Int64}, etc. Each of these is now a usable concrete type:julia> Point{Float64}\\nPoint{Float64}\\n\\njulia> Point{AbstractString}\\nPoint{AbstractString}The type Point{Float64} is a point whose coordinates are 64-bit floating-point values, while the type Point{AbstractString} is a \\\"point\\\" whose \\\"coordinates\\\" are string objects (see Strings).Point itself is also a valid type object, containing all instances Point{Float64}, Point{AbstractString}, etc. as subtypes:julia> Point{Float64} <: Point\\ntrue\\n\\njulia> Point{AbstractString} <: Point\\ntrueOther types, of course, are not subtypes of it:julia> Float64 <: Point\\nfalse\\n\\njulia> AbstractString <: Point\\nfalseConcrete Point types with different values of T are never subtypes of each other:julia> Point{Float64} <: Point{Int64}\\nfalse\\n\\njulia> Point{Float64} <: Point{Real}\\nfalsewarning: Warning\\nThis last point is very important: even though Float64 <: Real we DO NOT have Point{Float64} <: Point{Real}.In other words, in the parlance of type theory, Julia\\'s type parameters are invariant, rather than being covariant (or even contravariant). This is for practical reasons: while any instance of Point{Float64} may conceptually be like an instance of Point{Real} as well, the two types have different representations in memory:An instance of Point{Float64} can be represented compactly and efficiently as an immediate pair of 64-bit values;\\nAn instance of Point{Real} must be able to hold any pair of instances of Real. Since objects that are instances of Real can be of arbitrary size and structure, in practice an instance of Point{Real} must be represented as a pair of pointers to individually allocated Real objects.The efficiency gained by being able to store Point{Float64} objects with immediate values is magnified enormously in the case of arrays: an Array{Float64} can be stored as a contiguous memory block of 64-bit floating-point values, whereas an Array{Real} must be an array of pointers to individually allocated Real objects \u2013 which may well be boxed 64-bit floating-point values, but also might be arbitrarily large, complex objects, which are declared to be implementations of the Real abstract type.Since Point{Float64} is not a subtype of Point{Real}, the following method can\\'t be applied to arguments of type Point{Float64}:function norm(p::Point{Real})\\n    sqrt(p.x^2 + p.y^2)\\nendA correct way to define a method that accepts all arguments of type Point{T} where T is a subtype of Real is:function norm(p::Point{<:Real})\\n    sqrt(p.x^2 + p.y^2)\\nend(Equivalently, one could define function norm(p::Point{T} where T<:Real) or function norm(p::Point{T}) where T<:Real; see UnionAll Types.)More examples will be discussed later in Methods.How does one construct a Point object? It is possible to define custom constructors for composite types, which will be discussed in detail in Constructors, but in the absence of any special constructor declarations, there are two default ways of creating new composite objects, one in which the type parameters are explicitly given and the other in which they are implied by the arguments to the object constructor.Since the type Point{Float64} is a concrete type equivalent to Point declared with Float64 in place of T, it can be applied as a constructor accordingly:julia> Point{Float64}(1.0, 2.0)\\nPoint{Float64}(1.0, 2.0)\\n\\njulia> typeof(ans)\\nPoint{Float64}For the default constructor, exactly one argument must be supplied for each field:julia> Point{Float64}(1.0)\\nERROR: MethodError: no method matching Point{Float64}(::Float64)\\n[...]\\n\\njulia> Point{Float64}(1.0,2.0,3.0)\\nERROR: MethodError: no method matching Point{Float64}(::Float64, ::Float64, ::Float64)\\n[...]Only one default constructor is generated for parametric types, since overriding it is not possible. This constructor accepts any arguments and converts them to the field types.In many cases, it is redundant to provide the type of Point object one wants to construct, since the types of arguments to the constructor call already implicitly provide type information. For that reason, you can also apply Point itself as a constructor, provided that the implied value of the parameter type T is unambiguous:julia> Point(1.0,2.0)\\nPoint{Float64}(1.0, 2.0)\\n\\njulia> typeof(ans)\\nPoint{Float64}\\n\\njulia> Point(1,2)\\nPoint{Int64}(1, 2)\\n\\njulia> typeof(ans)\\nPoint{Int64}In the case of Point, the type of T is unambiguously implied if and only if the two arguments to Point have the same type. When this isn\\'t the case, the constructor will fail with a MethodError:julia> Point(1,2.5)\\nERROR: MethodError: no method matching Point(::Int64, ::Float64)\\nClosest candidates are:\\n  Point(::T, !Matched::T) where T at none:2Constructor methods to appropriately handle such mixed cases can be defined, but that will not be discussed until later on in Constructors.\"\n},\n\n{\n    \"location\": \"manual/types.html#Parametric-Abstract-Types-1\",\n    \"page\": \"Types\",\n    \"title\": \"Parametric Abstract Types\",\n    \"category\": \"section\",\n    \"text\": \"Parametric abstract type declarations declare a collection of abstract types, in much the same way:julia> abstract type Pointy{T} endWith this declaration, Pointy{T} is a distinct abstract type for each type or integer value of T. As with parametric composite types, each such instance is a subtype of Pointy:julia> Pointy{Int64} <: Pointy\\ntrue\\n\\njulia> Pointy{1} <: Pointy\\ntrueParametric abstract types are invariant, much as parametric composite types are:julia> Pointy{Float64} <: Pointy{Real}\\nfalse\\n\\njulia> Pointy{Real} <: Pointy{Float64}\\nfalseThe notation Pointy{<:Real} can be used to express the Julia analogue of a covariant type, while Pointy{>:Int} the analogue of a contravariant type, but technically these represent sets of types (see UnionAll Types).julia> Pointy{Float64} <: Pointy{<:Real}\\ntrue\\n\\njulia> Pointy{Real} <: Pointy{>:Int}\\ntrueMuch as plain old abstract types serve to create a useful hierarchy of types over concrete types, parametric abstract types serve the same purpose with respect to parametric composite types. We could, for example, have declared Point{T} to be a subtype of Pointy{T} as follows:julia> struct Point{T} <: Pointy{T}\\n           x::T\\n           y::T\\n       endGiven such a declaration, for each choice of T, we have Point{T} as a subtype of Pointy{T}:julia> Point{Float64} <: Pointy{Float64}\\ntrue\\n\\njulia> Point{Real} <: Pointy{Real}\\ntrue\\n\\njulia> Point{AbstractString} <: Pointy{AbstractString}\\ntrueThis relationship is also invariant:julia> Point{Float64} <: Pointy{Real}\\nfalse\\n\\njulia> Point{Float64} <: Pointy{<:Real}\\ntrueWhat purpose do parametric abstract types like Pointy serve? Consider if we create a point-like implementation that only requires a single coordinate because the point is on the diagonal line x = y:julia> struct DiagPoint{T} <: Pointy{T}\\n           x::T\\n       endNow both Point{Float64} and DiagPoint{Float64} are implementations of the Pointy{Float64} abstraction, and similarly for every other possible choice of type T. This allows programming to a common interface shared by all Pointy objects, implemented for both Point and DiagPoint. This cannot be fully demonstrated, however, until we have introduced methods and dispatch in the next section, Methods.There are situations where it may not make sense for type parameters to range freely over all possible types. In such situations, one can constrain the range of T like so:julia> abstract type Pointy{T<:Real} endWith such a declaration, it is acceptable to use any type that is a subtype of Real in place of T, but not types that are not subtypes of Real:julia> Pointy{Float64}\\nPointy{Float64}\\n\\njulia> Pointy{Real}\\nPointy{Real}\\n\\njulia> Pointy{AbstractString}\\nERROR: TypeError: in Pointy, in T, expected T<:Real, got Type{AbstractString}\\n\\njulia> Pointy{1}\\nERROR: TypeError: in Pointy, in T, expected T<:Real, got Int64Type parameters for parametric composite types can be restricted in the same manner:struct Point{T<:Real} <: Pointy{T}\\n    x::T\\n    y::T\\nendTo give a real-world example of how all this parametric type machinery can be useful, here is the actual definition of Julia\\'s Rational immutable type (except that we omit the constructor here for simplicity), representing an exact ratio of integers:struct Rational{T<:Integer} <: Real\\n    num::T\\n    den::T\\nendIt only makes sense to take ratios of integer values, so the parameter type T is restricted to being a subtype of Integer, and a ratio of integers represents a value on the real number line, so any Rational is an instance of the Real abstraction.\"\n},\n\n{\n    \"location\": \"manual/types.html#Tuple-Types-1\",\n    \"page\": \"Types\",\n    \"title\": \"Tuple Types\",\n    \"category\": \"section\",\n    \"text\": \"Tuples are an abstraction of the arguments of a function \u2013 without the function itself. The salient aspects of a function\\'s arguments are their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one field. For example, a 2-element tuple type resembles the following immutable type:struct Tuple2{A,B}\\n    a::A\\n    b::B\\nendHowever, there are three key differences:Tuple types may have any number of parameters.\\nTuple types are covariant in their parameters: Tuple{Int} is a subtype of Tuple{Any}. Therefore Tuple{Any} is considered an abstract type, and tuple types are only concrete if their parameters are.\\nTuples do not have field names; fields are only accessed by index.Tuple values are written with parentheses and commas. When a tuple is constructed, an appropriate tuple type is generated on demand:julia> typeof((1,\\\"foo\\\",2.5))\\nTuple{Int64,String,Float64}Note the implications of covariance:julia> Tuple{Int,AbstractString} <: Tuple{Real,Any}\\ntrue\\n\\njulia> Tuple{Int,AbstractString} <: Tuple{Real,Real}\\nfalse\\n\\njulia> Tuple{Int,AbstractString} <: Tuple{Real,}\\nfalseIntuitively, this corresponds to the type of a function\\'s arguments being a subtype of the function\\'s signature (when the signature matches).\"\n},\n\n{\n    \"location\": \"manual/types.html#Vararg-Tuple-Types-1\",\n    \"page\": \"Types\",\n    \"title\": \"Vararg Tuple Types\",\n    \"category\": \"section\",\n    \"text\": \"The last parameter of a tuple type can be the special type Vararg, which denotes any number of trailing elements:julia> mytupletype = Tuple{AbstractString,Vararg{Int}}\\nTuple{AbstractString,Vararg{Int64,N} where N}\\n\\njulia> isa((\\\"1\\\",), mytupletype)\\ntrue\\n\\njulia> isa((\\\"1\\\",1), mytupletype)\\ntrue\\n\\njulia> isa((\\\"1\\\",1,2), mytupletype)\\ntrue\\n\\njulia> isa((\\\"1\\\",1,2,3.0), mytupletype)\\nfalseNotice that Vararg{T} corresponds to zero or more elements of type T. Vararg tuple types are used to represent the arguments accepted by varargs methods (see Varargs Functions).The type Vararg{T,N} corresponds to exactly N elements of type T.  NTuple{N,T} is a convenient alias for Tuple{Vararg{T,N}}, i.e. a tuple type containing exactly N elements of type T.\"\n},\n\n{\n    \"location\": \"manual/types.html#Named-Tuple-Types-1\",\n    \"page\": \"Types\",\n    \"title\": \"Named Tuple Types\",\n    \"category\": \"section\",\n    \"text\": \"Named tuples are instances of the NamedTuple type, which has two parameters: a tuple of symbols giving the field names, and a tuple type giving the field types.julia> typeof((a=1,b=\\\"hello\\\"))\\nNamedTuple{(:a, :b),Tuple{Int64,String}}A NamedTuple type can be used as a constructor, accepting a single tuple argument. The constructed NamedTuple type can be either a concrete type, with both parameters specified, or a type that specifies only field names:julia> NamedTuple{(:a, :b),Tuple{Float32, String}}((1,\\\"\\\"))\\n(a = 1.0f0, b = \\\"\\\")\\n\\njulia> NamedTuple{(:a, :b)}((1,\\\"\\\"))\\n(a = 1, b = \\\"\\\")If field types are specified, the arguments are converted. Otherwise the types of the arguments are used directly.\"\n},\n\n{\n    \"location\": \"manual/types.html#man-singleton-types-1\",\n    \"page\": \"Types\",\n    \"title\": \"Singleton Types\",\n    \"category\": \"section\",\n    \"text\": \"There is a special kind of abstract parametric type that must be mentioned here: singleton types. For each type, T, the \\\"singleton type\\\" Type{T} is an abstract type whose only instance is the object T. Since the definition is a little difficult to parse, let\\'s look at some examples:julia> isa(Float64, Type{Float64})\\ntrue\\n\\njulia> isa(Real, Type{Float64})\\nfalse\\n\\njulia> isa(Real, Type{Real})\\ntrue\\n\\njulia> isa(Float64, Type{Real})\\nfalseIn other words, isa(A,Type{B}) is true if and only if A and B are the same object and that object is a type. Without the parameter, Type is simply an abstract type which has all type objects as its instances, including, of course, singleton types:julia> isa(Type{Float64}, Type)\\ntrue\\n\\njulia> isa(Float64, Type)\\ntrue\\n\\njulia> isa(Real, Type)\\ntrueAny object that is not a type is not an instance of Type:julia> isa(1, Type)\\nfalse\\n\\njulia> isa(\\\"foo\\\", Type)\\nfalseUntil we discuss Parametric Methods and conversions, it is difficult to explain the utility of the singleton type construct, but in short, it allows one to specialize function behavior on specific type values. This is useful for writing methods (especially parametric ones) whose behavior depends on a type that is given as an explicit argument rather than implied by the type of one of its arguments.A few popular languages have singleton types, including Haskell, Scala and Ruby. In general usage, the term \\\"singleton type\\\" refers to a type whose only instance is a single value. This meaning applies to Julia\\'s singleton types, but with that caveat that only type objects have singleton types.\"\n},\n\n{\n    \"location\": \"manual/types.html#Parametric-Primitive-Types-1\",\n    \"page\": \"Types\",\n    \"title\": \"Parametric Primitive Types\",\n    \"category\": \"section\",\n    \"text\": \"Primitive types can also be declared parametrically. For example, pointers are represented as primitive types which would be declared in Julia like this:# 32-bit system:\\nprimitive type Ptr{T} 32 end\\n\\n# 64-bit system:\\nprimitive type Ptr{T} 64 endThe slightly odd feature of these declarations as compared to typical parametric composite types, is that the type parameter T is not used in the definition of the type itself \u2013 it is just an abstract tag, essentially defining an entire family of types with identical structure, differentiated only by their type parameter. Thus, Ptr{Float64} and Ptr{Int64} are distinct types, even though they have identical representations. And of course, all specific pointer types are subtypes of the umbrella Ptr type:julia> Ptr{Float64} <: Ptr\\ntrue\\n\\njulia> Ptr{Int64} <: Ptr\\ntrue\"\n},\n\n{\n    \"location\": \"manual/types.html#UnionAll-Types-1\",\n    \"page\": \"Types\",\n    \"title\": \"UnionAll Types\",\n    \"category\": \"section\",\n    \"text\": \"We have said that a parametric type like Ptr acts as a supertype of all its instances (Ptr{Int64} etc.). How does this work? Ptr itself cannot be a normal data type, since without knowing the type of the referenced data the type clearly cannot be used for memory operations. The answer is that Ptr (or other parametric types like Array) is a different kind of type called a UnionAll type. Such a type expresses the iterated union of types for all values of some parameter.UnionAll types are usually written using the keyword where. For example Ptr could be more accurately written as Ptr{T} where T, meaning all values whose type is Ptr{T} for some value of T. In this context, the parameter T is also often called a \\\"type variable\\\" since it is like a variable that ranges over types. Each where introduces a single type variable, so these expressions are nested for types with multiple parameters, for example Array{T,N} where N where T.The type application syntax A{B,C} requires A to be a UnionAll type, and first substitutes B for the outermost type variable in A. The result is expected to be another UnionAll type, into which C is then substituted. So A{B,C} is equivalent to A{B}{C}. This explains why it is possible to partially instantiate a type, as in Array{Float64}: the first parameter value has been fixed, but the second still ranges over all possible values. Using explicit where syntax, any subset of parameters can be fixed. For example, the type of all 1-dimensional arrays can be written as Array{T,1} where T.Type variables can be restricted with subtype relations. Array{T} where T<:Integer refers to all arrays whose element type is some kind of Integer. The syntax Array{<:Integer} is a convenient shorthand for Array{T} where T<:Integer. Type variables can have both lower and upper bounds. Array{T} where Int<:T<:Number refers to all arrays of Numbers that are able to contain Ints (since T must be at least as big as Int). The syntax where T>:Int also works to specify only the lower bound of a type variable, and Array{>:Int} is equivalent to Array{T} where T>:Int.Since where expressions nest, type variable bounds can refer to outer type variables. For example Tuple{T,Array{S}} where S<:AbstractArray{T} where T<:Real refers to 2-tuples whose first element is some Real, and whose second element is an Array of any kind of array whose element type contains the type of the first tuple element.The where keyword itself can be nested inside a more complex declaration. For example, consider the two types created by the following declarations:julia> const T1 = Array{Array{T,1} where T, 1}\\nArray{Array{T,1} where T,1}\\n\\njulia> const T2 = Array{Array{T,1}, 1} where T\\nArray{Array{T,1},1} where TType T1 defines a 1-dimensional array of 1-dimensional arrays; each of the inner arrays consists of objects of the same type, but this type may vary from one inner array to the next. On the other hand, type T2 defines a 1-dimensional array of 1-dimensional arrays all of whose inner arrays must have the same type.  Note that T2 is an abstract type, e.g., Array{Array{Int,1},1} <: T2, whereas T1 is a concrete type. As a consequence, T1 can be constructed with a zero-argument constructor a=T1() but T2 cannot.There is a convenient syntax for naming such types, similar to the short form of function definition syntax:Vector{T} = Array{T,1}This is equivalent to const Vector = Array{T,1} where T. Writing Vector{Float64} is equivalent to writing Array{Float64,1}, and the umbrella type Vector has as instances all Array objects where the second parameter \u2013 the number of array dimensions \u2013 is 1, regardless of what the element type is. In languages where parametric types must always be specified in full, this is not especially helpful, but in Julia, this allows one to write just Vector for the abstract type including all one-dimensional dense arrays of any element type.\"\n},\n\n{\n    \"location\": \"manual/types.html#Type-Aliases-1\",\n    \"page\": \"Types\",\n    \"title\": \"Type Aliases\",\n    \"category\": \"section\",\n    \"text\": \"Sometimes it is convenient to introduce a new name for an already expressible type. This can be done with a simple assignment statement. For example, UInt is aliased to either UInt32 or UInt64 as is appropriate for the size of pointers on the system:# 32-bit system:\\njulia> UInt\\nUInt32\\n\\n# 64-bit system:\\njulia> UInt\\nUInt64This is accomplished via the following code in base/boot.jl:if Int === Int64\\n    const UInt = UInt64\\nelse\\n    const UInt = UInt32\\nendOf course, this depends on what Int is aliased to \u2013 but that is predefined to be the correct type \u2013 either Int32 or Int64.(Note that unlike Int, Float does not exist as a type alias for a specific sized AbstractFloat. Unlike with integer registers, the floating point register sizes are specified by the IEEE-754 standard. Whereas the size of Int reflects the size of a native pointer on that machine.)\"\n},\n\n{\n    \"location\": \"manual/types.html#Operations-on-Types-1\",\n    \"page\": \"Types\",\n    \"title\": \"Operations on Types\",\n    \"category\": \"section\",\n    \"text\": \"Since types in Julia are themselves objects, ordinary functions can operate on them. Some functions that are particularly useful for working with or exploring types have already been introduced, such as the <: operator, which indicates whether its left hand operand is a subtype of its right hand operand.The isa function tests if an object is of a given type and returns true or false:julia> isa(1, Int)\\ntrue\\n\\njulia> isa(1, AbstractFloat)\\nfalseThe typeof function, already used throughout the manual in examples, returns the type of its argument. Since, as noted above, types are objects, they also have types, and we can ask what their types are:julia> typeof(Rational{Int})\\nDataType\\n\\njulia> typeof(Union{Real,Float64,Rational})\\nDataType\\n\\njulia> typeof(Union{Real,String})\\nUnionWhat if we repeat the process? What is the type of a type of a type? As it happens, types are all composite values and thus all have a type of DataType:julia> typeof(DataType)\\nDataType\\n\\njulia> typeof(Union)\\nDataTypeDataType is its own type.Another operation that applies to some types is supertype, which reveals a type\\'s supertype. Only declared types (DataType) have unambiguous supertypes:julia> supertype(Float64)\\nAbstractFloat\\n\\njulia> supertype(Number)\\nAny\\n\\njulia> supertype(AbstractString)\\nAny\\n\\njulia> supertype(Any)\\nAnyIf you apply supertype to other type objects (or non-type objects), a MethodError is raised:julia> supertype(Union{Float64,Int64})\\nERROR: MethodError: no method matching supertype(::Type{Union{Float64, Int64}})\\nClosest candidates are:\\n  supertype(!Matched::DataType) at operators.jl:42\\n  supertype(!Matched::UnionAll) at operators.jl:47\"\n},\n\n{\n    \"location\": \"manual/types.html#man-custom-pretty-printing-1\",\n    \"page\": \"Types\",\n    \"title\": \"Custom pretty-printing\",\n    \"category\": \"section\",\n    \"text\": \"Often, one wants to customize how instances of a type are displayed.  This is accomplished by overloading the show function.  For example, suppose we define a type to represent complex numbers in polar form:julia> struct Polar{T<:Real} <: Number\\n           r::T\\n           \u0398::T\\n       end\\n\\njulia> Polar(r::Real,\u0398::Real) = Polar(promote(r,\u0398)...)\\nPolarHere, we\\'ve added a custom constructor function so that it can take arguments of different Real types and promote them to a common type (see Constructors and Conversion and Promotion). (Of course, we would have to define lots of other methods, too, to make it act like a Number, e.g. +, *, one, zero, promotion rules and so on.) By default, instances of this type display rather simply, with information about the type name and the field values, as e.g. Polar{Float64}(3.0,4.0).If we want it to display instead as 3.0 * exp(4.0im), we would define the following method to print the object to a given output object io (representing a file, terminal, buffer, etcetera; see Networking and Streams):julia> Base.show(io::IO, z::Polar) = print(io, z.r, \\\" * exp(\\\", z.\u0398, \\\"im)\\\")More fine-grained control over display of Polar objects is possible. In particular, sometimes one wants both a verbose multi-line printing format, used for displaying a single object in the REPL and other interactive environments, and also a more compact single-line format used for print or for displaying the object as part of another object (e.g. in an array). Although by default the show(io, z) function is called in both cases, you can define a different multi-line format for displaying an object by overloading a three-argument form of show that takes the text/plain MIME type as its second argument (see Multimedia I/O), for example:julia> Base.show(io::IO, ::MIME\\\"text/plain\\\", z::Polar{T}) where{T} =\\n           print(io, \\\"Polar{$T} complex number:\\\\n   \\\", z)(Note that print(..., z) here will call the 2-argument show(io, z) method.) This results in:julia> Polar(3, 4.0)\\nPolar{Float64} complex number:\\n   3.0 * exp(4.0im)\\n\\njulia> [Polar(3, 4.0), Polar(4.0,5.3)]\\n2-element Array{Polar{Float64},1}:\\n 3.0 * exp(4.0im)\\n 4.0 * exp(5.3im)where the single-line show(io, z) form is still used for an array of Polar values.   Technically, the REPL calls display(z) to display the result of executing a line, which defaults to show(stdout, MIME(\\\"text/plain\\\"), z), which in turn defaults to show(stdout, z), but you should not define new display methods unless you are defining a new multimedia display handler (see Multimedia I/O).Moreover, you can also define show methods for other MIME types in order to enable richer display (HTML, images, etcetera) of objects in environments that support this (e.g. IJulia).   For example, we can define formatted HTML display of Polar objects, with superscripts and italics, via:julia> Base.show(io::IO, ::MIME\\\"text/html\\\", z::Polar{T}) where {T} =\\n           println(io, \\\"<code>Polar{$T}</code> complex number: \\\",\\n                   z.r, \\\" <i>e</i><sup>\\\", z.\u0398, \\\" <i>i</i></sup>\\\")A Polar object will then display automatically using HTML in an environment that supports HTML display, but you can call show manually to get HTML output if you want:julia> show(stdout, \\\"text/html\\\", Polar(3.0,4.0))\\n<code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup><p>An HTML renderer would display this as: <code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup></p>As a rule of thumb, the single-line show method should print a valid Julia expression for creating the shown object.  When this show method contains infix operators, such as the multiplication operator (*) in our single-line show method for Polar above, it may not parse correctly when printed as part of another object.  To see this, consider the expression object (see Program representation) which takes the square of a specific instance of our Polar type:julia> a = Polar(3, 4.0)\\nPolar{Float64} complex number:\\n   3.0 * exp(4.0im)\\n\\njulia> print(:($a^2))\\n3.0 * exp(4.0im) ^ 2Because the operator ^ has higher precedence than * (see Operator Precedence and Associativity), this output does not faithfully represent the expression a ^ 2 which should be equal to (3.0 * exp(4.0im)) ^ 2.  To solve this issue, we must make a custom method for Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int), which is called internally by the expression object when printing:julia> function Base.show_unquoted(io::IO, z::Polar, ::Int, precedence::Int)\\n           if Base.operator_precedence(:*) <= precedence\\n               print(io, \\\"(\\\")\\n               show(io, z)\\n               print(io, \\\")\\\")\\n           else\\n               show(io, z)\\n           end\\n       end\\n\\njulia> :($a^2)\\n:((3.0 * exp(4.0im)) ^ 2)The method defined above adds parentheses around the call to show when the precedence of the calling operator is higher than or equal to the precedence of multiplication.  This check allows expressions which parse correctly without the parentheses (such as :($a + 2) and :($a == 2)) to omit them when printing:julia> :($a + 2)\\n:(3.0 * exp(4.0im) + 2)\\n\\njulia> :($a == 2)\\n:(3.0 * exp(4.0im) == 2)In some cases, it is useful to adjust the behavior of show methods depending on the context. This can be achieved via the IOContext type, which allows passing contextual properties together with a wrapped IO stream. For example, we can build a shorter representation in our show method when the :compact property is set to true, falling back to the long representation if the property is false or absent:julia> function Base.show(io::IO, z::Polar)\\n           if get(io, :compact, false)\\n               print(io, z.r, \\\"\u212f\\\", z.\u0398, \\\"im\\\")\\n           else\\n               print(io, z.r, \\\" * exp(\\\", z.\u0398, \\\"im)\\\")\\n           end\\n       endThis new compact representation will be used when the passed IO stream is an IOContext object with the :compact property set. In particular, this is the case when printing arrays with multiple columns (where horizontal space is limited):julia> show(IOContext(stdout, :compact=>true), Polar(3, 4.0))\\n3.0\u212f4.0im\\n\\njulia> [Polar(3, 4.0) Polar(4.0,5.3)]\\n1\u00d72 Array{Polar{Float64},2}:\\n 3.0\u212f4.0im  4.0\u212f5.3imSee the IOContext documentation for a list of common properties which can be used to adjust printing.\"\n},\n\n{\n    \"location\": \"manual/types.html#\\\"Value-types\\\"-1\",\n    \"page\": \"Types\",\n    \"title\": \"\\\"Value types\\\"\",\n    \"category\": \"section\",\n    \"text\": \"In Julia, you can\\'t dispatch on a value such as true or false. However, you can dispatch on parametric types, and Julia allows you to include \\\"plain bits\\\" values (Types, Symbols, Integers, floating-point numbers, tuples, etc.) as type parameters.  A common example is the dimensionality parameter in Array{T,N}, where T is a type (e.g., Float64) but N is just an Int.You can create your own custom types that take values as parameters, and use them to control dispatch of custom types. By way of illustration of this idea, let\\'s introduce a parametric type, Val{x}, and a constructor Val(x) = Val{x}(), which serves as a customary way to exploit this technique for cases where you don\\'t need a more elaborate hierarchy.Val is defined as:julia> struct Val{x}\\n       end\\n\\njulia> Val(x) = Val{x}()\\nValThere is no more to the implementation of Val than this.  Some functions in Julia\\'s standard library accept Val instances as arguments, and you can also use it to write your own functions.  For example:julia> firstlast(::Val{true}) = \\\"First\\\"\\nfirstlast (generic function with 1 method)\\n\\njulia> firstlast(::Val{false}) = \\\"Last\\\"\\nfirstlast (generic function with 2 methods)\\n\\njulia> firstlast(Val(true))\\n\\\"First\\\"\\n\\njulia> firstlast(Val(false))\\n\\\"Last\\\"For consistency across Julia, the call site should always pass a Valinstance rather than using a type, i.e., use foo(Val(:bar)) rather than foo(Val{:bar}).It\\'s worth noting that it\\'s extremely easy to mis-use parametric \\\"value\\\" types, including Val; in unfavorable cases, you can easily end up making the performance of your code much worse.  In particular, you would never want to write actual code as illustrated above.  For more information about the proper (and improper) uses of Val, please read the more extensive discussion in the performance tips.[1]: \\\"Small\\\" is defined by the MAX_UNION_SPLITTING constant, which is currently set to 4.\"\n},\n\n{\n    \"location\": \"manual/methods.html#\",\n    \"page\": \"Methods\",\n    \"title\": \"Methods\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/methods.html#Methods-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Methods\",\n    \"category\": \"section\",\n    \"text\": \"Recall from Functions that a function is an object that maps a tuple of arguments to a return value, or throws an exception if no appropriate value can be returned. It is common for the same conceptual function or operation to be implemented quite differently for different types of arguments: adding two integers is very different from adding two floating-point numbers, both of which are distinct from adding an integer to a floating-point number. Despite their implementation differences, these operations all fall under the general concept of \\\"addition\\\". Accordingly, in Julia, these behaviors all belong to a single object: the + function.To facilitate using many different implementations of the same concept smoothly, functions need not be defined all at once, but can rather be defined piecewise by providing specific behaviors for certain combinations of argument types and counts. A definition of one possible behavior for a function is called a method. Thus far, we have presented only examples of functions defined with a single method, applicable to all types of arguments. However, the signatures of method definitions can be annotated to indicate the types of arguments in addition to their number, and more than a single method definition may be provided. When a function is applied to a particular tuple of arguments, the most specific method applicable to those arguments is applied. Thus, the overall behavior of a function is a patchwork of the behaviors of its various method definitions. If the patchwork is well designed, even though the implementations of the methods may be quite different, the outward behavior of the function will appear seamless and consistent.The choice of which method to execute when a function is applied is called dispatch. Julia allows the dispatch process to choose which of a function\\'s methods to call based on the number of arguments given, and on the types of all of the function\\'s arguments. This is different than traditional object-oriented languages, where dispatch occurs based only on the first argument, which often has a special argument syntax, and is sometimes implied rather than explicitly written as an argument. [1] Using all of a function\\'s arguments to choose which method should be invoked, rather than just the first, is known as multiple dispatch. Multiple dispatch is particularly useful for mathematical code, where it makes little sense to artificially deem the operations to \\\"belong\\\" to one argument more than any of the others: does the addition operation in x + y belong to x any more than it does to y? The implementation of a mathematical operator generally depends on the types of all of its arguments. Even beyond mathematical operations, however, multiple dispatch ends up being a powerful and convenient paradigm for structuring and organizing programs.[1]: In C++ or Java, for example, in a method call like obj.meth(arg1,arg2), the object obj \\\"receives\\\" the method call and is implicitly passed to the method via the this keyword, rather than as an explicit method argument. When the current this object is the receiver of a method call, it can be omitted altogether, writing just meth(arg1,arg2), with this implied as the receiving object.\"\n},\n\n{\n    \"location\": \"manual/methods.html#Defining-Methods-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Defining Methods\",\n    \"category\": \"section\",\n    \"text\": \"Until now, we have, in our examples, defined only functions with a single method having unconstrained argument types. Such functions behave just like they would in traditional dynamically typed languages. Nevertheless, we have used multiple dispatch and methods almost continually without being aware of it: all of Julia\\'s standard functions and operators, like the aforementioned + function, have many methods defining their behavior over various possible combinations of argument type and count.When defining a function, one can optionally constrain the types of parameters it is applicable to, using the :: type-assertion operator, introduced in the section on Composite Types:julia> f(x::Float64, y::Float64) = 2x + y\\nf (generic function with 1 method)This function definition applies only to calls where x and y are both values of type Float64:julia> f(2.0, 3.0)\\n7.0Applying it to any other types of arguments will result in a MethodError:julia> f(2.0, 3)\\nERROR: MethodError: no method matching f(::Float64, ::Int64)\\nClosest candidates are:\\n  f(::Float64, !Matched::Float64) at none:1\\n\\njulia> f(Float32(2.0), 3.0)\\nERROR: MethodError: no method matching f(::Float32, ::Float64)\\nClosest candidates are:\\n  f(!Matched::Float64, ::Float64) at none:1\\n\\njulia> f(2.0, \\\"3.0\\\")\\nERROR: MethodError: no method matching f(::Float64, ::String)\\nClosest candidates are:\\n  f(::Float64, !Matched::Float64) at none:1\\n\\njulia> f(\\\"2.0\\\", \\\"3.0\\\")\\nERROR: MethodError: no method matching f(::String, ::String)As you can see, the arguments must be precisely of type Float64. Other numeric types, such as integers or 32-bit floating-point values, are not automatically converted to 64-bit floating-point, nor are strings parsed as numbers. Because Float64 is a concrete type and concrete types cannot be subclassed in Julia, such a definition can only be applied to arguments that are exactly of type Float64. It may often be useful, however, to write more general methods where the declared parameter types are abstract:julia> f(x::Number, y::Number) = 2x - y\\nf (generic function with 2 methods)\\n\\njulia> f(2.0, 3)\\n1.0This method definition applies to any pair of arguments that are instances of Number. They need not be of the same type, so long as they are each numeric values. The problem of handling disparate numeric types is delegated to the arithmetic operations in the expression 2x - y.To define a function with multiple methods, one simply defines the function multiple times, with different numbers and types of arguments. The first method definition for a function creates the function object, and subsequent method definitions add new methods to the existing function object. The most specific method definition matching the number and types of the arguments will be executed when the function is applied. Thus, the two method definitions above, taken together, define the behavior for f over all pairs of instances of the abstract type Number \u2013 but with a different behavior specific to pairs of Float64 values. If one of the arguments is a 64-bit float but the other one is not, then the f(Float64,Float64) method cannot be called and the more general f(Number,Number) method must be used:julia> f(2.0, 3.0)\\n7.0\\n\\njulia> f(2, 3.0)\\n1.0\\n\\njulia> f(2.0, 3)\\n1.0\\n\\njulia> f(2, 3)\\n1The 2x + y definition is only used in the first case, while the 2x - y definition is used in the others. No automatic casting or conversion of function arguments is ever performed: all conversion in Julia is non-magical and completely explicit. Conversion and Promotion, however, shows how clever application of sufficiently advanced technology can be indistinguishable from magic. [Clarke61]For non-numeric values, and for fewer or more than two arguments, the function f remains undefined, and applying it will still result in a MethodError:julia> f(\\\"foo\\\", 3)\\nERROR: MethodError: no method matching f(::String, ::Int64)\\nClosest candidates are:\\n  f(!Matched::Number, ::Number) at none:1\\n\\njulia> f()\\nERROR: MethodError: no method matching f()\\nClosest candidates are:\\n  f(!Matched::Float64, !Matched::Float64) at none:1\\n  f(!Matched::Number, !Matched::Number) at none:1You can easily see which methods exist for a function by entering the function object itself in an interactive session:julia> f\\nf (generic function with 2 methods)This output tells us that f is a function object with two methods. To find out what the signatures of those methods are, use the methods function:julia> methods(f)\\n# 2 methods for generic function \\\"f\\\":\\n[1] f(x::Float64, y::Float64) in Main at none:1\\n[2] f(x::Number, y::Number) in Main at none:1which shows that f has two methods, one taking two Float64 arguments and one taking arguments of type Number. It also indicates the file and line number where the methods were defined: because these methods were defined at the REPL, we get the apparent line number none:1.In the absence of a type declaration with ::, the type of a method parameter is Any by default, meaning that it is unconstrained since all values in Julia are instances of the abstract type Any. Thus, we can define a catch-all method for f like so:julia> f(x,y) = println(\\\"Whoa there, Nelly.\\\")\\nf (generic function with 3 methods)\\n\\njulia> f(\\\"foo\\\", 1)\\nWhoa there, Nelly.This catch-all is less specific than any other possible method definition for a pair of parameter values, so it will only be called on pairs of arguments to which no other method definition applies.Although it seems a simple concept, multiple dispatch on the types of values is perhaps the single most powerful and central feature of the Julia language. Core operations typically have dozens of methods:julia> methods(+)\\n# 180 methods for generic function \\\"+\\\":\\n[1] +(x::Bool, z::Complex{Bool}) in Base at complex.jl:227\\n[2] +(x::Bool, y::Bool) in Base at bool.jl:89\\n[3] +(x::Bool) in Base at bool.jl:86\\n[4] +(x::Bool, y::T) where T<:AbstractFloat in Base at bool.jl:96\\n[5] +(x::Bool, z::Complex) in Base at complex.jl:234\\n[6] +(a::Float16, b::Float16) in Base at float.jl:373\\n[7] +(x::Float32, y::Float32) in Base at float.jl:375\\n[8] +(x::Float64, y::Float64) in Base at float.jl:376\\n[9] +(z::Complex{Bool}, x::Bool) in Base at complex.jl:228\\n[10] +(z::Complex{Bool}, x::Real) in Base at complex.jl:242\\n[11] +(x::Char, y::Integer) in Base at char.jl:40\\n[12] +(c::BigInt, x::BigFloat) in Base.MPFR at mpfr.jl:307\\n[13] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt, e::BigInt) in Base.GMP at gmp.jl:392\\n[14] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt) in Base.GMP at gmp.jl:391\\n[15] +(a::BigInt, b::BigInt, c::BigInt) in Base.GMP at gmp.jl:390\\n[16] +(x::BigInt, y::BigInt) in Base.GMP at gmp.jl:361\\n[17] +(x::BigInt, c::Union{UInt16, UInt32, UInt64, UInt8}) in Base.GMP at gmp.jl:398\\n...\\n[180] +(a, b, c, xs...) in Base at operators.jl:424Multiple dispatch together with the flexible parametric type system give Julia its ability to abstractly express high-level algorithms decoupled from implementation details, yet generate efficient, specialized code to handle each case at run time.\"\n},\n\n{\n    \"location\": \"manual/methods.html#man-ambiguities-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Method Ambiguities\",\n    \"category\": \"section\",\n    \"text\": \"It is possible to define a set of function methods such that there is no unique most specific method applicable to some combinations of arguments:julia> g(x::Float64, y) = 2x + y\\ng (generic function with 1 method)\\n\\njulia> g(x, y::Float64) = x + 2y\\ng (generic function with 2 methods)\\n\\njulia> g(2.0, 3)\\n7.0\\n\\njulia> g(2, 3.0)\\n8.0\\n\\njulia> g(2.0, 3.0)\\nERROR: MethodError: g(::Float64, ::Float64) is ambiguous. Candidates:\\n  g(x, y::Float64) in Main at none:1\\n  g(x::Float64, y) in Main at none:1\\nPossible fix, define\\n  g(::Float64, ::Float64)Here the call g(2.0, 3.0) could be handled by either the g(Float64, Any) or the g(Any, Float64) method, and neither is more specific than the other. In such cases, Julia raises a MethodError rather than arbitrarily picking a method. You can avoid method ambiguities by specifying an appropriate method for the intersection case:julia> g(x::Float64, y::Float64) = 2x + 2y\\ng (generic function with 3 methods)\\n\\njulia> g(2.0, 3)\\n7.0\\n\\njulia> g(2, 3.0)\\n8.0\\n\\njulia> g(2.0, 3.0)\\n10.0It is recommended that the disambiguating method be defined first, since otherwise the ambiguity exists, if transiently, until the more specific method is defined.In more complex cases, resolving method ambiguities involves a certain element of design; this topic is explored further below.\"\n},\n\n{\n    \"location\": \"manual/methods.html#Parametric-Methods-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Parametric Methods\",\n    \"category\": \"section\",\n    \"text\": \"Method definitions can optionally have type parameters qualifying the signature:julia> same_type(x::T, y::T) where {T} = true\\nsame_type (generic function with 1 method)\\n\\njulia> same_type(x,y) = false\\nsame_type (generic function with 2 methods)The first method applies whenever both arguments are of the same concrete type, regardless of what type that is, while the second method acts as a catch-all, covering all other cases. Thus, overall, this defines a boolean function that checks whether its two arguments are of the same type:julia> same_type(1, 2)\\ntrue\\n\\njulia> same_type(1, 2.0)\\nfalse\\n\\njulia> same_type(1.0, 2.0)\\ntrue\\n\\njulia> same_type(\\\"foo\\\", 2.0)\\nfalse\\n\\njulia> same_type(\\\"foo\\\", \\\"bar\\\")\\ntrue\\n\\njulia> same_type(Int32(1), Int64(2))\\nfalseSuch definitions correspond to methods whose type signatures are UnionAll types (see UnionAll Types).This kind of definition of function behavior by dispatch is quite common \u2013 idiomatic, even \u2013 in Julia. Method type parameters are not restricted to being used as the types of arguments: they can be used anywhere a value would be in the signature of the function or body of the function. Here\\'s an example where the method type parameter T is used as the type parameter to the parametric type Vector{T} in the method signature:julia> myappend(v::Vector{T}, x::T) where {T} = [v..., x]\\nmyappend (generic function with 1 method)\\n\\njulia> myappend([1,2,3],4)\\n4-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n 4\\n\\njulia> myappend([1,2,3],2.5)\\nERROR: MethodError: no method matching myappend(::Array{Int64,1}, ::Float64)\\nClosest candidates are:\\n  myappend(::Array{T,1}, !Matched::T) where T at none:1\\n\\njulia> myappend([1.0,2.0,3.0],4.0)\\n4-element Array{Float64,1}:\\n 1.0\\n 2.0\\n 3.0\\n 4.0\\n\\njulia> myappend([1.0,2.0,3.0],4)\\nERROR: MethodError: no method matching myappend(::Array{Float64,1}, ::Int64)\\nClosest candidates are:\\n  myappend(::Array{T,1}, !Matched::T) where T at none:1As you can see, the type of the appended element must match the element type of the vector it is appended to, or else a MethodError is raised. In the following example, the method type parameter T is used as the return value:julia> mytypeof(x::T) where {T} = T\\nmytypeof (generic function with 1 method)\\n\\njulia> mytypeof(1)\\nInt64\\n\\njulia> mytypeof(1.0)\\nFloat64Just as you can put subtype constraints on type parameters in type declarations (see Parametric Types), you can also constrain type parameters of methods:julia> same_type_numeric(x::T, y::T) where {T<:Number} = true\\nsame_type_numeric (generic function with 1 method)\\n\\njulia> same_type_numeric(x::Number, y::Number) = false\\nsame_type_numeric (generic function with 2 methods)\\n\\njulia> same_type_numeric(1, 2)\\ntrue\\n\\njulia> same_type_numeric(1, 2.0)\\nfalse\\n\\njulia> same_type_numeric(1.0, 2.0)\\ntrue\\n\\njulia> same_type_numeric(\\\"foo\\\", 2.0)\\nERROR: MethodError: no method matching same_type_numeric(::String, ::Float64)\\nClosest candidates are:\\n  same_type_numeric(!Matched::T<:Number, ::T<:Number) where T<:Number at none:1\\n  same_type_numeric(!Matched::Number, ::Number) at none:1\\n\\njulia> same_type_numeric(\\\"foo\\\", \\\"bar\\\")\\nERROR: MethodError: no method matching same_type_numeric(::String, ::String)\\n\\njulia> same_type_numeric(Int32(1), Int64(2))\\nfalseThe same_type_numeric function behaves much like the same_type function defined above, but is only defined for pairs of numbers.Parametric methods allow the same syntax as where expressions used to write types (see UnionAll Types). If there is only a single parameter, the enclosing curly braces (in where {T}) can be omitted, but are often preferred for clarity. Multiple parameters can be separated with commas, e.g. where {T, S<:Real}, or written using nested where, e.g. where S<:Real where T.\"\n},\n\n{\n    \"location\": \"manual/methods.html#Redefining-Methods-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Redefining Methods\",\n    \"category\": \"section\",\n    \"text\": \"When redefining a method or adding new methods, it is important to realize that these changes don\\'t take effect immediately. This is key to Julia\\'s ability to statically infer and compile code to run fast, without the usual JIT tricks and overhead. Indeed, any new method definition won\\'t be visible to the current runtime environment, including Tasks and Threads (and any previously defined @generated functions). Let\\'s start with an example to see what this means:julia> function tryeval()\\n           @eval newfun() = 1\\n           newfun()\\n       end\\ntryeval (generic function with 1 method)\\n\\njulia> tryeval()\\nERROR: MethodError: no method matching newfun()\\nThe applicable method may be too new: running in world age xxxx1, while current world is xxxx2.\\nClosest candidates are:\\n  newfun() at none:1 (method too new to be called from this world context.)\\n in tryeval() at none:1\\n ...\\n\\njulia> newfun()\\n1In this example, observe that the new definition for newfun has been created, but can\\'t be immediately called. The new global is immediately visible to the tryeval function, so you could write return newfun (without parentheses). But neither you, nor any of your callers, nor the functions they call, or etc. can call this new method definition!But there\\'s an exception: future calls to newfun from the REPL work as expected, being able to both see and call the new definition of newfun.However, future calls to tryeval will continue to see the definition of newfun as it was at the previous statement at the REPL, and thus before that call to tryeval.You may want to try this for yourself to see how it works.The implementation of this behavior is a \\\"world age counter\\\". This monotonically increasing value tracks each method definition operation. This allows describing \\\"the set of method definitions visible to a given runtime environment\\\" as a single number, or \\\"world age\\\". It also allows comparing the methods available in two worlds just by comparing their ordinal value. In the example above, we see that the \\\"current world\\\" (in which the method newfun exists), is one greater than the task-local \\\"runtime world\\\" that was fixed when the execution of tryeval started.Sometimes it is necessary to get around this (for example, if you are implementing the above REPL). Fortunately, there is an easy solution: call the function using Base.invokelatest:julia> function tryeval2()\\n           @eval newfun2() = 2\\n           Base.invokelatest(newfun2)\\n       end\\ntryeval2 (generic function with 1 method)\\n\\njulia> tryeval2()\\n2Finally, let\\'s take a look at some more complex examples where this rule comes into play. Define a function f(x), which initially has one method:julia> f(x) = \\\"original definition\\\"\\nf (generic function with 1 method)Start some other operations that use f(x):julia> g(x) = f(x)\\ng (generic function with 1 method)\\n\\njulia> t = @async f(wait()); yield();Now we add some new methods to f(x):julia> f(x::Int) = \\\"definition for Int\\\"\\nf (generic function with 2 methods)\\n\\njulia> f(x::Type{Int}) = \\\"definition for Type{Int}\\\"\\nf (generic function with 3 methods)Compare how these results differ:julia> f(1)\\n\\\"definition for Int\\\"\\n\\njulia> g(1)\\n\\\"definition for Int\\\"\\n\\njulia> fetch(schedule(t, 1))\\n\\\"original definition\\\"\\n\\njulia> t = @async f(wait()); yield();\\n\\njulia> fetch(schedule(t, 1))\\n\\\"definition for Int\\\"\"\n},\n\n{\n    \"location\": \"manual/methods.html#Design-Patterns-with-Parametric-Methods-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Design Patterns with Parametric Methods\",\n    \"category\": \"section\",\n    \"text\": \"While complex dispatch logic is not required for performance or usability, sometimes it can be the best way to express some algorithm. Here are a few common design patterns that come up sometimes when using dispatch in this way.\"\n},\n\n{\n    \"location\": \"manual/methods.html#Extracting-the-type-parameter-from-a-super-type-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Extracting the type parameter from a super-type\",\n    \"category\": \"section\",\n    \"text\": \"Here is the correct code template for returning the element-type T of any arbitrary subtype of AbstractArray:abstract type AbstractArray{T, N} end\\neltype(::Type{<:AbstractArray{T}}) where {T} = Tusing so-called triangular dispatch.  Note that if T is a UnionAll type, as e.g. eltype(Array{T} where T <: Integer), then Any is returned (as does the the version of eltype in Base).Another way, which used to be the only correct way before the advent of triangular dispatch in Julia v0.6, is:abstract type AbstractArray{T, N} end\\neltype(::Type{AbstractArray}) = Any\\neltype(::Type{AbstractArray{T}}) where {T} = T\\neltype(::Type{AbstractArray{T, N}}) where {T, N} = T\\neltype(::Type{A}) where {A<:AbstractArray} = eltype(supertype(A))Another possibility is the following, which could useful to adapt to cases where the parameter T would need to be matched more narrowly:eltype(::Type{AbstractArray{T, N} where {T<:S, N<:M}}) where {M, S} = Any\\neltype(::Type{AbstractArray{T, N} where {T<:S}}) where {N, S} = Any\\neltype(::Type{AbstractArray{T, N} where {N<:M}}) where {M, T} = T\\neltype(::Type{AbstractArray{T, N}}) where {T, N} = T\\neltype(::Type{A}) where {A <: AbstractArray} = eltype(supertype(A))One common mistake is to try and get the element-type by using introspection:eltype_wrong(::Type{A}) where {A<:AbstractArray} = A.parameters[1]However, it is not hard to construct cases where this will fail:struct BitVector <: AbstractArray{Bool, 1}; endHere we have created a type BitVector which has no parameters, but where the element-type is still fully specified, with T equal to Bool!\"\n},\n\n{\n    \"location\": \"manual/methods.html#Building-a-similar-type-with-a-different-type-parameter-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Building a similar type with a different type parameter\",\n    \"category\": \"section\",\n    \"text\": \"When building generic code, there is often a need for constructing a similar object with some change made to the layout of the type, also necessitating a change of the type parameters. For instance, you might have some sort of abstract array with an arbitrary element type and want to write your computation on it with a specific element type. We must implement a method for each AbstractArray{T} subtype that describes how to compute this type transform. There is no general transform of one subtype into another subtype with a different parameter. (Quick review: do you see why this is?)The subtypes of AbstractArray typically implement two methods to achieve this: A method to convert the input array to a subtype of a specific AbstractArray{T, N} abstract type; and a method to make a new uninitialized array with a specific element type. Sample implementations of these can be found in Julia Base. Here is a basic example usage of them, guaranteeing that input and output are of the same type:input = convert(AbstractArray{Eltype}, input)\\noutput = similar(input, Eltype)As an extension of this, in cases where the algorithm needs a copy of the input array, convert is insufficient as the return value may alias the original input. Combining similar (to make the output array) and copyto! (to fill it with the input data) is a generic way to express the requirement for a mutable copy of the input argument:copy_with_eltype(input, Eltype) = copyto!(similar(input, Eltype), input)\"\n},\n\n{\n    \"location\": \"manual/methods.html#Iterated-dispatch-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Iterated dispatch\",\n    \"category\": \"section\",\n    \"text\": \"In order to dispatch a multi-level parametric argument list, often it is best to separate each level of dispatch into distinct functions. This may sound similar in approach to single-dispatch, but as we shall see below, it is still more flexible.For example, trying to dispatch on the element-type of an array will often run into ambiguous situations. Instead, commonly code will dispatch first on the container type, then recurse down to a more specific method based on eltype. In most cases, the algorithms lend themselves conveniently to this hierarchical approach, while in other cases, this rigor must be resolved manually. This dispatching branching can be observed, for example, in the logic to sum two matrices:# First dispatch selects the map algorithm for element-wise summation.\\n+(a::Matrix, b::Matrix) = map(+, a, b)\\n# Then dispatch handles each element and selects the appropriate\\n# common element type for the computation.\\n+(a, b) = +(promote(a, b)...)\\n# Once the elements have the same type, they can be added.\\n# For example, via primitive operations exposed by the processor.\\n+(a::Float64, b::Float64) = Core.add(a, b)\"\n},\n\n{\n    \"location\": \"manual/methods.html#Trait-based-dispatch-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Trait-based dispatch\",\n    \"category\": \"section\",\n    \"text\": \"A natural extension to the iterated dispatch above is to add a layer to method selection that allows to dispatch on sets of types which are independent from the sets defined by the type hierarchy. We could construct such a set by writing out a Union of the types in question, but then this set would not be extensible as Union-types cannot be altered after creation. However, such an extensible set can be programmed with a design pattern often referred to as a \\\"Holy-trait\\\".This pattern is implemented by defining a generic function which computes a different singleton value (or type) for each trait-set to which the function arguments may belong to.  If this function is pure there is no impact on performance compared to normal dispatch.The example in the previous section glossed over the implementation details of map and promote, which both operate in terms of these traits. When iterating over a matrix, such as in the implementation of map, one important question is what order to use to traverse the data. When AbstractArray subtypes implement the Base.IndexStyle trait, other functions such as map can dispatch on this information to pick the best algorithm (see Abstract Array Interface). This means that each subtype does not need to implement a custom version of map, since the generic definitions + trait classes will enable the system to select the fastest version. Here a toy implementation of map illustrating the trait-based dispatch:map(f, a::AbstractArray, b::AbstractArray) = map(Base.IndexStyle(a, b), f, a, b)\\n# generic implementation:\\nmap(::Base.IndexCartesian, f, a::AbstractArray, b::AbstractArray) = ...\\n# linear-indexing implementation (faster)\\nmap(::Base.IndexLinear, f, a::AbstractArray, b::AbstractArray) = ...This trait-based approach is also present in the promote mechanism employed by the scalar +. It uses promote_type, which returns the optimal common type to compute the operation given the two types of the operands. This makes it possible to reduce the problem of implementing every function for every pair of possible type arguments, to the much smaller problem of implementing a conversion operation from each type to a common type, plus a table of preferred pair-wise promotion rules.\"\n},\n\n{\n    \"location\": \"manual/methods.html#Output-type-computation-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Output-type computation\",\n    \"category\": \"section\",\n    \"text\": \"The discussion of trait-based promotion provides a transition into our next design pattern: computing the output element type for a matrix operation.For implementing primitive operations, such as addition, we use the promote_type function to compute the desired output type. (As before, we saw this at work in the promote call in the call to +).For more complex functions on matrices, it may be necessary to compute the expected return type for a more complex sequence of operations. This is often performed by the following steps:Write a small function op that expresses the set of operations performed by the kernel of the algorithm.\\nCompute the element type R of the result matrix as promote_op(op, argument_types...), where argument_types is computed from eltype applied to each input array.\\nBuild the output matrix as similar(R, dims), where dims are the desired dimensions of the output array.For a more specific example, a generic square-matrix multiply pseudo-code might look like:function matmul(a::AbstractMatrix, b::AbstractMatrix)\\n    op = (ai, bi) -> ai * bi + ai * bi\\n\\n    ## this is insufficient because it assumes `one(eltype(a))` is constructable:\\n    # R = typeof(op(one(eltype(a)), one(eltype(b))))\\n\\n    ## this fails because it assumes `a[1]` exists and is representative of all elements of the array\\n    # R = typeof(op(a[1], b[1]))\\n\\n    ## this is incorrect because it assumes that `+` calls `promote_type`\\n    ## but this is not true for some types, such as Bool:\\n    # R = promote_type(ai, bi)\\n\\n    # this is wrong, since depending on the return value\\n    # of type-inference is very brittle (as well as not being optimizable):\\n    # R = Base.return_types(op, (eltype(a), eltype(b)))\\n\\n    ## but, finally, this works:\\n    R = promote_op(op, eltype(a), eltype(b))\\n    ## although sometimes it may give a larger type than desired\\n    ## it will always give a correct type\\n\\n    output = similar(b, R, (size(a, 1), size(b, 2)))\\n    if size(a, 2) > 0\\n        for j in 1:size(b, 2)\\n            for i in 1:size(b, 1)\\n                ## here we don\\'t use `ab = zero(R)`,\\n                ## since `R` might be `Any` and `zero(Any)` is not defined\\n                ## we also must declare `ab::R` to make the type of `ab` constant in the loop,\\n                ## since it is possible that typeof(a * b) != typeof(a * b + a * b) == R\\n                ab::R = a[i, 1] * b[1, j]\\n                for k in 2:size(a, 2)\\n                    ab += a[i, k] * b[k, j]\\n                end\\n                output[i, j] = ab\\n            end\\n        end\\n    end\\n    return output\\nend\"\n},\n\n{\n    \"location\": \"manual/methods.html#Separate-convert-and-kernel-logic-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Separate convert and kernel logic\",\n    \"category\": \"section\",\n    \"text\": \"One way to significantly cut down on compile-times and testing complexity is to isolate the logic for converting to the desired type and the computation. This lets the compiler specialize and inline the conversion logic independent from the rest of the body of the larger kernel.This is a common pattern seen when converting from a larger class of types to the one specific argument type that is actually supported by the algorithm:complexfunction(arg::Int) = ...\\ncomplexfunction(arg::Any) = complexfunction(convert(Int, arg))\\n\\nmatmul(a::T, b::T) = ...\\nmatmul(a, b) = matmul(promote(a, b)...)\"\n},\n\n{\n    \"location\": \"manual/methods.html#Parametrically-constrained-Varargs-methods-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Parametrically-constrained Varargs methods\",\n    \"category\": \"section\",\n    \"text\": \"Function parameters can also be used to constrain the number of arguments that may be supplied to a \\\"varargs\\\" function (Varargs Functions).  The notation Vararg{T,N} is used to indicate such a constraint.  For example:julia> bar(a,b,x::Vararg{Any,2}) = (a,b,x)\\nbar (generic function with 1 method)\\n\\njulia> bar(1,2,3)\\nERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64)\\nClosest candidates are:\\n  bar(::Any, ::Any, ::Any, !Matched::Any) at none:1\\n\\njulia> bar(1,2,3,4)\\n(1, 2, (3, 4))\\n\\njulia> bar(1,2,3,4,5)\\nERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64, ::Int64, ::Int64)\\nClosest candidates are:\\n  bar(::Any, ::Any, ::Any, ::Any) at none:1More usefully, it is possible to constrain varargs methods by a parameter. For example:function getindex(A::AbstractArray{T,N}, indices::Vararg{Number,N}) where {T,N}would be called only when the number of indices matches the dimensionality of the array.When only the type of supplied arguments needs to be constrained Vararg{T} can be equivalently written as T.... For instance f(x::Int...) = x is a shorthand for f(x::Vararg{Int}) = x.\"\n},\n\n{\n    \"location\": \"manual/methods.html#Note-on-Optional-and-keyword-Arguments-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Note on Optional and keyword Arguments\",\n    \"category\": \"section\",\n    \"text\": \"As mentioned briefly in Functions, optional arguments are implemented as syntax for multiple method definitions. For example, this definition:f(a=1,b=2) = a+2btranslates to the following three methods:f(a,b) = a+2b\\nf(a) = f(a,2)\\nf() = f(1,2)This means that calling f() is equivalent to calling f(1,2). In this case the result is 5, because f(1,2) invokes the first method of f above. However, this need not always be the case. If you define a fourth method that is more specialized for integers:f(a::Int,b::Int) = a-2bthen the result of both f() and f(1,2) is -3. In other words, optional arguments are tied to a function, not to any specific method of that function. It depends on the types of the optional arguments which method is invoked. When optional arguments are defined in terms of a global variable, the type of the optional argument may even change at run-time.Keyword arguments behave quite differently from ordinary positional arguments. In particular, they do not participate in method dispatch. Methods are dispatched based only on positional arguments, with keyword arguments processed after the matching method is identified.\"\n},\n\n{\n    \"location\": \"manual/methods.html#Function-like-objects-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Function-like objects\",\n    \"category\": \"section\",\n    \"text\": \"Methods are associated with types, so it is possible to make any arbitrary Julia object \\\"callable\\\" by adding methods to its type. (Such \\\"callable\\\" objects are sometimes called \\\"functors.\\\")For example, you can define a type that stores the coefficients of a polynomial, but behaves like a function evaluating the polynomial:julia> struct Polynomial{R}\\n           coeffs::Vector{R}\\n       end\\n\\njulia> function (p::Polynomial)(x)\\n           v = p.coeffs[end]\\n           for i = (length(p.coeffs)-1):-1:1\\n               v = v*x + p.coeffs[i]\\n           end\\n           return v\\n       end\\n\\njulia> (p::Polynomial)() = p(5)Notice that the function is specified by type instead of by name. As with normal functions there is a terse syntax form. In the function body, p will refer to the object that was called. A Polynomial can be used as follows:julia> p = Polynomial([1,10,100])\\nPolynomial{Int64}([1, 10, 100])\\n\\njulia> p(3)\\n931\\n\\njulia> p()\\n2551This mechanism is also the key to how type constructors and closures (inner functions that refer to their surrounding environment) work in Julia.\"\n},\n\n{\n    \"location\": \"manual/methods.html#Empty-generic-functions-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Empty generic functions\",\n    \"category\": \"section\",\n    \"text\": \"Occasionally it is useful to introduce a generic function without yet adding methods. This can be used to separate interface definitions from implementations. It might also be done for the purpose of documentation or code readability. The syntax for this is an empty function block without a tuple of arguments:function emptyfunc\\nend\"\n},\n\n{\n    \"location\": \"manual/methods.html#man-method-design-ambiguities-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Method design and the avoidance of ambiguities\",\n    \"category\": \"section\",\n    \"text\": \"Julia\\'s method polymorphism is one of its most powerful features, yet exploiting this power can pose design challenges.  In particular, in more complex method hierarchies it is not uncommon for ambiguities to arise.Above, it was pointed out that one can resolve ambiguities likef(x, y::Int) = 1\\nf(x::Int, y) = 2by defining a methodf(x::Int, y::Int) = 3This is often the right strategy; however, there are circumstances where following this advice blindly can be counterproductive. In particular, the more methods a generic function has, the more possibilities there are for ambiguities. When your method hierarchies get more complicated than this simple example, it can be worth your while to think carefully about alternative strategies.Below we discuss particular challenges and some alternative ways to resolve such issues.\"\n},\n\n{\n    \"location\": \"manual/methods.html#Tuple-and-NTuple-arguments-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Tuple and NTuple arguments\",\n    \"category\": \"section\",\n    \"text\": \"Tuple (and NTuple) arguments present special challenges. For example,f(x::NTuple{N,Int}) where {N} = 1\\nf(x::NTuple{N,Float64}) where {N} = 2are ambiguous because of the possibility that N == 0: there are no elements to determine whether the Int or Float64 variant should be called. To resolve the ambiguity, one approach is define a method for the empty tuple:f(x::Tuple{}) = 3Alternatively, for all methods but one you can insist that there is at least one element in the tuple:f(x::NTuple{N,Int}) where {N} = 1           # this is the fallback\\nf(x::Tuple{Float64, Vararg{Float64}}) = 2   # this requires at least one Float64\"\n},\n\n{\n    \"location\": \"manual/methods.html#man-methods-orthogonalize-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Orthogonalize your design\",\n    \"category\": \"section\",\n    \"text\": \"When you might be tempted to dispatch on two or more arguments, consider whether a \\\"wrapper\\\" function might make for a simpler design. For example, instead of writing multiple variants:f(x::A, y::A) = ...\\nf(x::A, y::B) = ...\\nf(x::B, y::A) = ...\\nf(x::B, y::B) = ...you might consider definingf(x::A, y::A) = ...\\nf(x, y) = f(g(x), g(y))where g converts the argument to type A. This is a very specific example of the more general principle of orthogonal design, in which separate concepts are assigned to separate methods. Here, g will most likely need a fallback definitiong(x::A) = xA related strategy exploits promote to bring x and y to a common type:f(x::T, y::T) where {T} = ...\\nf(x, y) = f(promote(x, y)...)One risk with this design is the possibility that if there is no suitable promotion method converting x and y to the same type, the second method will recurse on itself infinitely and trigger a stack overflow. The non-exported function Base.promote_noncircular can be used as an alternative; when promotion fails it will still throw an error, but one that fails faster with a more specific error message.\"\n},\n\n{\n    \"location\": \"manual/methods.html#Dispatch-on-one-argument-at-a-time-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Dispatch on one argument at a time\",\n    \"category\": \"section\",\n    \"text\": \"If you need to dispatch on multiple arguments, and there are many fallbacks with too many combinations to make it practical to define all possible variants, then consider introducing a \\\"name cascade\\\" where (for example) you dispatch on the first argument and then call an internal method:f(x::A, y) = _fA(x, y)\\nf(x::B, y) = _fB(x, y)Then the internal methods _fA and _fB can dispatch on y without concern about ambiguities with each other with respect to x.Be aware that this strategy has at least one major disadvantage: in many cases, it is not possible for users to further customize the behavior of f by defining further specializations of your exported function f. Instead, they have to define specializations for your internal methods _fA and _fB, and this blurs the lines between exported and internal methods.\"\n},\n\n{\n    \"location\": \"manual/methods.html#Abstract-containers-and-element-types-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Abstract containers and element types\",\n    \"category\": \"section\",\n    \"text\": \"Where possible, try to avoid defining methods that dispatch on specific element types of abstract containers. For example,-(A::AbstractArray{T}, b::Date) where {T<:Date}generates ambiguities for anyone who defines a method-(A::MyArrayType{T}, b::T) where {T}The best approach is to avoid defining either of these methods: instead, rely on a generic method -(A::AbstractArray, b) and make sure this method is implemented with generic calls (like similar and -) that do the right thing for each container type and element type separately. This is just a more complex variant of the advice to orthogonalize your methods.When this approach is not possible, it may be worth starting a discussion with other developers about resolving the ambiguity; just because one method was defined first does not necessarily mean that it can\\'t be modified or eliminated.  As a last resort, one developer can define the \\\"band-aid\\\" method-(A::MyArrayType{T}, b::Date) where {T<:Date} = ...that resolves the ambiguity by brute force.\"\n},\n\n{\n    \"location\": \"manual/methods.html#Complex-method-\\\"cascades\\\"-with-default-arguments-1\",\n    \"page\": \"Methods\",\n    \"title\": \"Complex method \\\"cascades\\\" with default arguments\",\n    \"category\": \"section\",\n    \"text\": \"If you are defining a method \\\"cascade\\\" that supplies defaults, be careful about dropping any arguments that correspond to potential defaults. For example, suppose you\\'re writing a digital filtering algorithm and you have a method that handles the edges of the signal by applying padding:function myfilter(A, kernel, ::Replicate)\\n    Apadded = replicate_edges(A, size(kernel))\\n    myfilter(Apadded, kernel)  # now perform the \\\"real\\\" computation\\nendThis will run afoul of a method that supplies default padding:myfilter(A, kernel) = myfilter(A, kernel, Replicate()) # replicate the edge by defaultTogether, these two methods generate an infinite recursion with A constantly growing bigger.The better design would be to define your call hierarchy like this:struct NoPad end  # indicate that no padding is desired, or that it\\'s already applied\\n\\nmyfilter(A, kernel) = myfilter(A, kernel, Replicate())  # default boundary conditions\\n\\nfunction myfilter(A, kernel, ::Replicate)\\n    Apadded = replicate_edges(A, size(kernel))\\n    myfilter(Apadded, kernel, NoPad())  # indicate the new boundary conditions\\nend\\n\\n# other padding methods go here\\n\\nfunction myfilter(A, kernel, ::NoPad)\\n    # Here\\'s the \\\"real\\\" implementation of the core computation\\nendNoPad is supplied in the same argument position as any other kind of padding, so it keeps the dispatch hierarchy well organized and with reduced likelihood of ambiguities. Moreover, it extends the \\\"public\\\" myfilter interface: a user who wants to control the padding explicitly can call the NoPad variant directly.[Clarke61]: Arthur C. Clarke, Profiles of the Future (1961): Clarke\\'s Third Law.\"\n},\n\n{\n    \"location\": \"manual/constructors.html#\",\n    \"page\": \"Constructors\",\n    \"title\": \"Constructors\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/constructors.html#man-constructors-1\",\n    \"page\": \"Constructors\",\n    \"title\": \"Constructors\",\n    \"category\": \"section\",\n    \"text\": \"Constructors [1] are functions that create new objects \u2013 specifically, instances of Composite Types. In Julia, type objects also serve as constructor functions: they create new instances of themselves when applied to an argument tuple as a function. This much was already mentioned briefly when composite types were introduced. For example:julia> struct Foo\\n           bar\\n           baz\\n       end\\n\\njulia> foo = Foo(1, 2)\\nFoo(1, 2)\\n\\njulia> foo.bar\\n1\\n\\njulia> foo.baz\\n2For many types, forming new objects by binding their field values together is all that is ever needed to create instances. There are, however, cases where more functionality is required when creating composite objects. Sometimes invariants must be enforced, either by checking arguments or by transforming them. Recursive data structures, especially those that may be self-referential, often cannot be constructed cleanly without first being created in an incomplete state and then altered programmatically to be made whole, as a separate step from object creation. Sometimes, it\\'s just convenient to be able to construct objects with fewer or different types of parameters than they have fields. Julia\\'s system for object construction addresses all of these cases and more.[1]: Nomenclature: while the term \\\"constructor\\\" generally refers to the entire function which constructs objects of a type, it is common to abuse terminology slightly and refer to specific constructor methods as \\\"constructors\\\". In such situations, it is generally clear from context that the term is used to mean \\\"constructor method\\\" rather than \\\"constructor function\\\", especially as it is often used in the sense of singling out a particular method of the constructor from all of the others.\"\n},\n\n{\n    \"location\": \"manual/constructors.html#Outer-Constructor-Methods-1\",\n    \"page\": \"Constructors\",\n    \"title\": \"Outer Constructor Methods\",\n    \"category\": \"section\",\n    \"text\": \"A constructor is just like any other function in Julia in that its overall behavior is defined by the combined behavior of its methods. Accordingly, you can add functionality to a constructor by simply defining new methods. For example, let\\'s say you want to add a constructor method for Foo objects that takes only one argument and uses the given value for both the bar and baz fields. This is simple:julia> Foo(x) = Foo(x,x)\\nFoo\\n\\njulia> Foo(1)\\nFoo(1, 1)You could also add a zero-argument Foo constructor method that supplies default values for both of the bar and baz fields:julia> Foo() = Foo(0)\\nFoo\\n\\njulia> Foo()\\nFoo(0, 0)Here the zero-argument constructor method calls the single-argument constructor method, which in turn calls the automatically provided two-argument constructor method. For reasons that will become clear very shortly, additional constructor methods declared as normal methods like this are called outer constructor methods. Outer constructor methods can only ever create a new instance by calling another constructor method, such as the automatically provided default ones.\"\n},\n\n{\n    \"location\": \"manual/constructors.html#Inner-Constructor-Methods-1\",\n    \"page\": \"Constructors\",\n    \"title\": \"Inner Constructor Methods\",\n    \"category\": \"section\",\n    \"text\": \"While outer constructor methods succeed in addressing the problem of providing additional convenience methods for constructing objects, they fail to address the other two use cases mentioned in the introduction of this chapter: enforcing invariants, and allowing construction of self-referential objects. For these problems, one needs inner constructor methods. An inner constructor method is much like an outer constructor method, with two differences:It is declared inside the block of a type declaration, rather than outside of it like normal methods.\\nIt has access to a special locally existent function called new that creates objects of the block\\'s type.For example, suppose one wants to declare a type that holds a pair of real numbers, subject to the constraint that the first number is not greater than the second one. One could declare it like this:julia> struct OrderedPair\\n           x::Real\\n           y::Real\\n           OrderedPair(x,y) = x > y ? error(\\\"out of order\\\") : new(x,y)\\n       endNow OrderedPair objects can only be constructed such that x <= y:julia> OrderedPair(1, 2)\\nOrderedPair(1, 2)\\n\\njulia> OrderedPair(2,1)\\nERROR: out of order\\nStacktrace:\\n [1] error at ./error.jl:33 [inlined]\\n [2] OrderedPair(::Int64, ::Int64) at ./none:4\\n [3] top-level scopeIf the type were declared mutable, you could reach in and directly change the field values to violate this invariant, but messing around with an object\\'s internals uninvited is considered poor form. You (or someone else) can also provide additional outer constructor methods at any later point, but once a type is declared, there is no way to add more inner constructor methods. Since outer constructor methods can only create objects by calling other constructor methods, ultimately, some inner constructor must be called to create an object. This guarantees that all objects of the declared type must come into existence by a call to one of the inner constructor methods provided with the type, thereby giving some degree of enforcement of a type\\'s invariants.If any inner constructor method is defined, no default constructor method is provided: it is presumed that you have supplied yourself with all the inner constructors you need. The default constructor is equivalent to writing your own inner constructor method that takes all of the object\\'s fields as parameters (constrained to be of the correct type, if the corresponding field has a type), and passes them to new, returning the resulting object:julia> struct Foo\\n           bar\\n           baz\\n           Foo(bar,baz) = new(bar,baz)\\n       end\\nThis declaration has the same effect as the earlier definition of the Foo type without an explicit inner constructor method. The following two types are equivalent \u2013 one with a default constructor, the other with an explicit constructor:julia> struct T1\\n           x::Int64\\n       end\\n\\njulia> struct T2\\n           x::Int64\\n           T2(x) = new(x)\\n       end\\n\\njulia> T1(1)\\nT1(1)\\n\\njulia> T2(1)\\nT2(1)\\n\\njulia> T1(1.0)\\nT1(1)\\n\\njulia> T2(1.0)\\nT2(1)It is considered good form to provide as few inner constructor methods as possible: only those taking all arguments explicitly and enforcing essential error checking and transformation. Additional convenience constructor methods, supplying default values or auxiliary transformations, should be provided as outer constructors that call the inner constructors to do the heavy lifting. This separation is typically quite natural.\"\n},\n\n{\n    \"location\": \"manual/constructors.html#Incomplete-Initialization-1\",\n    \"page\": \"Constructors\",\n    \"title\": \"Incomplete Initialization\",\n    \"category\": \"section\",\n    \"text\": \"The final problem which has still not been addressed is construction of self-referential objects, or more generally, recursive data structures. Since the fundamental difficulty may not be immediately obvious, let us briefly explain it. Consider the following recursive type declaration:julia> mutable struct SelfReferential\\n           obj::SelfReferential\\n       end\\nThis type may appear innocuous enough, until one considers how to construct an instance of it. If a is an instance of SelfReferential, then a second instance can be created by the call:julia> b = SelfReferential(a)But how does one construct the first instance when no instance exists to provide as a valid value for its obj field? The only solution is to allow creating an incompletely initialized instance of SelfReferential with an unassigned obj field, and using that incomplete instance as a valid value for the obj field of another instance, such as, for example, itself.To allow for the creation of incompletely initialized objects, Julia allows the new function to be called with fewer than the number of fields that the type has, returning an object with the unspecified fields uninitialized. The inner constructor method can then use the incomplete object, finishing its initialization before returning it. Here, for example, we take another crack at defining the SelfReferential type, with a zero-argument inner constructor returning instances having obj fields pointing to themselves:julia> mutable struct SelfReferential\\n           obj::SelfReferential\\n           SelfReferential() = (x = new(); x.obj = x)\\n       end\\nWe can verify that this constructor works and constructs objects that are, in fact, self-referential:julia> x = SelfReferential();\\n\\njulia> x === x\\ntrue\\n\\njulia> x === x.obj\\ntrue\\n\\njulia> x === x.obj.obj\\ntrueAlthough it is generally a good idea to return a fully initialized object from an inner constructor, incompletely initialized objects can be returned:julia> mutable struct Incomplete\\n           xx\\n           Incomplete() = new()\\n       end\\n\\njulia> z = Incomplete();While you are allowed to create objects with uninitialized fields, any access to an uninitialized reference is an immediate error:julia> z.xx\\nERROR: UndefRefError: access to undefined referenceThis avoids the need to continually check for null values. However, not all object fields are references. Julia considers some types to be \\\"plain data\\\", meaning all of their data is self-contained and does not reference other objects. The plain data types consist of primitive types (e.g. Int) and immutable structs of other plain data types. The initial contents of a plain data type is undefined:julia> struct HasPlain\\n           n::Int\\n           HasPlain() = new()\\n       end\\n\\njulia> HasPlain()\\nHasPlain(438103441441)Arrays of plain data types exhibit the same behavior.You can pass incomplete objects to other functions from inner constructors to delegate their completion:julia> mutable struct Lazy\\n           xx\\n           Lazy(v) = complete_me(new(), v)\\n       endAs with incomplete objects returned from constructors, if complete_me or any of its callees try to access the xx field of the Lazy object before it has been initialized, an error will be thrown immediately.\"\n},\n\n{\n    \"location\": \"manual/constructors.html#Parametric-Constructors-1\",\n    \"page\": \"Constructors\",\n    \"title\": \"Parametric Constructors\",\n    \"category\": \"section\",\n    \"text\": \"Parametric types add a few wrinkles to the constructor story. Recall from Parametric Types that, by default, instances of parametric composite types can be constructed either with explicitly given type parameters or with type parameters implied by the types of the arguments given to the constructor. Here are some examples:julia> struct Point{T<:Real}\\n           x::T\\n           y::T\\n       end\\n\\njulia> Point(1,2) ## implicit T ##\\nPoint{Int64}(1, 2)\\n\\njulia> Point(1.0,2.5) ## implicit T ##\\nPoint{Float64}(1.0, 2.5)\\n\\njulia> Point(1,2.5) ## implicit T ##\\nERROR: MethodError: no method matching Point(::Int64, ::Float64)\\nClosest candidates are:\\n  Point(::T<:Real, ::T<:Real) where T<:Real at none:2\\n\\njulia> Point{Int64}(1, 2) ## explicit T ##\\nPoint{Int64}(1, 2)\\n\\njulia> Point{Int64}(1.0,2.5) ## explicit T ##\\nERROR: InexactError: Int64(Int64, 2.5)\\nStacktrace:\\n[...]\\n\\njulia> Point{Float64}(1.0, 2.5) ## explicit T ##\\nPoint{Float64}(1.0, 2.5)\\n\\njulia> Point{Float64}(1,2) ## explicit T ##\\nPoint{Float64}(1.0, 2.0)As you can see, for constructor calls with explicit type parameters, the arguments are converted to the implied field types: Point{Int64}(1,2) works, but Point{Int64}(1.0,2.5) raises an InexactError when converting 2.5 to Int64. When the type is implied by the arguments to the constructor call, as in Point(1,2), then the types of the arguments must agree \u2013 otherwise the T cannot be determined \u2013 but any pair of real arguments with matching type may be given to the generic Point constructor.What\\'s really going on here is that Point, Point{Float64} and Point{Int64} are all different constructor functions. In fact, Point{T} is a distinct constructor function for each type T. Without any explicitly provided inner constructors, the declaration of the composite type Point{T<:Real} automatically provides an inner constructor, Point{T}, for each possible type T<:Real, that behaves just like non-parametric default inner constructors do. It also provides a single general outer Point constructor that takes pairs of real arguments, which must be of the same type. This automatic provision of constructors is equivalent to the following explicit declaration:julia> struct Point{T<:Real}\\n           x::T\\n           y::T\\n           Point{T}(x,y) where {T<:Real} = new(x,y)\\n       end\\n\\njulia> Point(x::T, y::T) where {T<:Real} = Point{T}(x,y);Notice that each definition looks like the form of constructor call that it handles. The call Point{Int64}(1,2) will invoke the definition Point{T}(x,y) inside the struct block. The outer constructor declaration, on the other hand, defines a method for the general Point constructor which only applies to pairs of values of the same real type. This declaration makes constructor calls without explicit type parameters, like Point(1,2) and Point(1.0,2.5), work. Since the method declaration restricts the arguments to being of the same type, calls like Point(1,2.5), with arguments of different types, result in \\\"no method\\\" errors.Suppose we wanted to make the constructor call Point(1,2.5) work by \\\"promoting\\\" the integer value 1 to the floating-point value 1.0. The simplest way to achieve this is to define the following additional outer constructor method:julia> Point(x::Int64, y::Float64) = Point(convert(Float64,x),y);This method uses the convert function to explicitly convert x to Float64 and then delegates construction to the general constructor for the case where both arguments are Float64. With this method definition what was previously a MethodError now successfully creates a point of type Point{Float64}:julia> Point(1,2.5)\\nPoint{Float64}(1.0, 2.5)\\n\\njulia> typeof(ans)\\nPoint{Float64}However, other similar calls still don\\'t work:julia> Point(1.5,2)\\nERROR: MethodError: no method matching Point(::Float64, ::Int64)\\nClosest candidates are:\\n  Point(::T<:Real, !Matched::T<:Real) where T<:Real at none:1For a more general way to make all such calls work sensibly, see Conversion and Promotion. At the risk of spoiling the suspense, we can reveal here that all it takes is the following outer method definition to make all calls to the general Point constructor work as one would expect:julia> Point(x::Real, y::Real) = Point(promote(x,y)...);The promote function converts all its arguments to a common type \u2013 in this case Float64. With this method definition, the Point constructor promotes its arguments the same way that numeric operators like + do, and works for all kinds of real numbers:julia> Point(1.5,2)\\nPoint{Float64}(1.5, 2.0)\\n\\njulia> Point(1,1//2)\\nPoint{Rational{Int64}}(1//1, 1//2)\\n\\njulia> Point(1.0,1//2)\\nPoint{Float64}(1.0, 0.5)Thus, while the implicit type parameter constructors provided by default in Julia are fairly strict, it is possible to make them behave in a more relaxed but sensible manner quite easily. Moreover, since constructors can leverage all of the power of the type system, methods, and multiple dispatch, defining sophisticated behavior is typically quite simple.\"\n},\n\n{\n    \"location\": \"manual/constructors.html#Case-Study:-Rational-1\",\n    \"page\": \"Constructors\",\n    \"title\": \"Case Study: Rational\",\n    \"category\": \"section\",\n    \"text\": \"Perhaps the best way to tie all these pieces together is to present a real world example of a parametric composite type and its constructor methods. To that end, we implement our own rational number type OurRational, similar to Julia\\'s built-in Rational type, defined in rational.jl:julia> struct OurRational{T<:Integer} <: Real\\n           num::T\\n           den::T\\n           function OurRational{T}(num::T, den::T) where T<:Integer\\n               if num == 0 && den == 0\\n                    error(\\\"invalid rational: 0//0\\\")\\n               end\\n               g = gcd(den, num)\\n               num = div(num, g)\\n               den = div(den, g)\\n               new(num, den)\\n           end\\n       end\\n\\njulia> OurRational(n::T, d::T) where {T<:Integer} = OurRational{T}(n,d)\\nOurRational\\n\\njulia> OurRational(n::Integer, d::Integer) = OurRational(promote(n,d)...)\\nOurRational\\n\\njulia> OurRational(n::Integer) = OurRational(n,one(n))\\nOurRational\\n\\njulia> \u2298(n::Integer, d::Integer) = OurRational(n,d)\\n\u2298 (generic function with 1 method)\\n\\njulia> \u2298(x::OurRational, y::Integer) = x.num \u2298 (x.den*y)\\n\u2298 (generic function with 2 methods)\\n\\njulia> \u2298(x::Integer, y::OurRational) = (x*y.den) \u2298 y.num\\n\u2298 (generic function with 3 methods)\\n\\njulia> \u2298(x::Complex, y::Real) = complex(real(x) \u2298 y, imag(x) \u2298 y)\\n\u2298 (generic function with 4 methods)\\n\\njulia> \u2298(x::Real, y::Complex) = (x*y\\') \u2298 real(y*y\\')\\n\u2298 (generic function with 5 methods)\\n\\njulia> function \u2298(x::Complex, y::Complex)\\n           xy = x*y\\'\\n           yy = real(y*y\\')\\n           complex(real(xy) \u2298 yy, imag(xy) \u2298 yy)\\n       end\\n\u2298 (generic function with 6 methods)The first line \u2013 struct OurRational{T<:Integer} <: Real \u2013 declares that OurRational takes one type parameter of an integer type, and is itself a real type. The field declarations num::T and den::T indicate that the data held in a OurRational{T} object are a pair of integers of type T, one representing the rational value\\'s numerator and the other representing its denominator.Now things get interesting. OurRational has a single inner constructor method which checks that both of num and den aren\\'t zero and ensures that every rational is constructed in \\\"lowest terms\\\" with a non-negative denominator. This is accomplished by dividing the given numerator and denominator values by their greatest common divisor, computed using the gcd function. Since gcd returns the greatest common divisor of its arguments with sign matching the first argument (den here), after this division the new value of den is guaranteed to be non-negative. Because this is the only inner constructor for OurRational, we can be certain that OurRational objects are always constructed in this normalized form.OurRational also provides several outer constructor methods for convenience. The first is the \\\"standard\\\" general constructor that infers the type parameter T from the type of the numerator and denominator when they have the same type. The second applies when the given numerator and denominator values have different types: it promotes them to a common type and then delegates construction to the outer constructor for arguments of matching type. The third outer constructor turns integer values into rationals by supplying a value of 1 as the denominator.Following the outer constructor definitions, we defined a number of methods for the \u2298 operator, which provides a syntax for writing rationals (e.g. 1 \u2298 2). Julia\\'s Rational type uses the // operator for this purpose. Before these definitions, \u2298 is a completely undefined operator with only syntax and no meaning. Afterwards, it behaves just as described in Rational Numbers \u2013 its entire behavior is defined in these few lines. The first and most basic definition just makes a \u2298 b construct a OurRational by applying the OurRational constructor to a and b when they are integers. When one of the operands of \u2298 is already a rational number, we construct a new rational for the resulting ratio slightly differently; this behavior is actually identical to division of a rational with an integer. Finally, applying \u2298 to complex integral values creates an instance of Complex{OurRational} \u2013 a complex number whose real and imaginary parts are rationals:julia> z = (1 + 2im) \u2298 (1 - 2im);\\n\\njulia> typeof(z)\\nComplex{OurRational{Int64}}\\n\\njulia> typeof(z) <: Complex{OurRational}\\nfalseThus, although the \u2298 operator usually returns an instance of OurRational, if either of its arguments are complex integers, it will return an instance of Complex{OurRational} instead. The interested reader should consider perusing the rest of rational.jl: it is short, self-contained, and implements an entire basic Julia type.\"\n},\n\n{\n    \"location\": \"manual/constructors.html#Outer-only-constructors-1\",\n    \"page\": \"Constructors\",\n    \"title\": \"Outer-only constructors\",\n    \"category\": \"section\",\n    \"text\": \"As we have seen, a typical parametric type has inner constructors that are called when type parameters are known; e.g. they apply to Point{Int} but not to Point. Optionally, outer constructors that determine type parameters automatically can be added, for example constructing a Point{Int} from the call Point(1,2). Outer constructors call inner constructors to do the core work of making an instance. However, in some cases one would rather not provide inner constructors, so that specific type parameters cannot be requested manually.For example, say we define a type that stores a vector along with an accurate representation of its sum:julia> struct SummedArray{T<:Number,S<:Number}\\n           data::Vector{T}\\n           sum::S\\n       end\\n\\njulia> SummedArray(Int32[1; 2; 3], Int32(6))\\nSummedArray{Int32,Int32}(Int32[1, 2, 3], 6)The problem is that we want S to be a larger type than T, so that we can sum many elements with less information loss. For example, when T is Int32, we would like S to be Int64. Therefore we want to avoid an interface that allows the user to construct instances of the type SummedArray{Int32,Int32}. One way to do this is to provide a constructor only for SummedArray, but inside the struct definition block to suppress generation of default constructors:julia> struct SummedArray{T<:Number,S<:Number}\\n           data::Vector{T}\\n           sum::S\\n           function SummedArray(a::Vector{T}) where T\\n               S = widen(T)\\n               new{T,S}(a, sum(S, a))\\n           end\\n       end\\n\\njulia> SummedArray(Int32[1; 2; 3], Int32(6))\\nERROR: MethodError: no method matching SummedArray(::Array{Int32,1}, ::Int32)\\nClosest candidates are:\\n  SummedArray(::Array{T,1}) where T at none:5This constructor will be invoked by the syntax SummedArray(a). The syntax new{T,S} allows specifying parameters for the type to be constructed, i.e. this call will return a SummedArray{T,S}. new{T,S} can be used in any constructor definition, but for convenience the parameters to new{} are automatically derived from the type being constructed when possible.\"\n},\n\n{\n    \"location\": \"manual/conversion-and-promotion.html#\",\n    \"page\": \"Conversion and Promotion\",\n    \"title\": \"Conversion and Promotion\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/conversion-and-promotion.html#conversion-and-promotion-1\",\n    \"page\": \"Conversion and Promotion\",\n    \"title\": \"Conversion and Promotion\",\n    \"category\": \"section\",\n    \"text\": \"Julia has a system for promoting arguments of mathematical operators to a common type, which has been mentioned in various other sections, including Integers and Floating-Point Numbers, Mathematical Operations and Elementary Functions, Types, and Methods. In this section, we explain how this promotion system works, as well as how to extend it to new types and apply it to functions besides built-in mathematical operators. Traditionally, programming languages fall into two camps with respect to promotion of arithmetic arguments:Automatic promotion for built-in arithmetic types and operators. In most languages, built-in numeric types, when used as operands to arithmetic operators with infix syntax, such as +, -, *, and /, are automatically promoted to a common type to produce the expected results. C, Java, Perl, and Python, to name a few, all correctly compute the sum 1 + 1.5 as the floating-point value 2.5, even though one of the operands to + is an integer. These systems are convenient and designed carefully enough that they are generally all-but-invisible to the programmer: hardly anyone consciously thinks of this promotion taking place when writing such an expression, but compilers and interpreters must perform conversion before addition since integers and floating-point values cannot be added as-is. Complex rules for such automatic conversions are thus inevitably part of specifications and implementations for such languages.\\nNo automatic promotion. This camp includes Ada and ML \u2013 very \\\"strict\\\" statically typed languages. In these languages, every conversion must be explicitly specified by the programmer. Thus, the example expression 1 + 1.5 would be a compilation error in both Ada and ML. Instead one must write real(1) + 1.5, explicitly converting the integer 1 to a floating-point value before performing addition. Explicit conversion everywhere is so inconvenient, however, that even Ada has some degree of automatic conversion: integer literals are promoted to the expected integer type automatically, and floating-point literals are similarly promoted to appropriate floating-point types.In a sense, Julia falls into the \\\"no automatic promotion\\\" category: mathematical operators are just functions with special syntax, and the arguments of functions are never automatically converted. However, one may observe that applying mathematical operations to a wide variety of mixed argument types is just an extreme case of polymorphic multiple dispatch \u2013 something which Julia\\'s dispatch and type systems are particularly well-suited to handle. \\\"Automatic\\\" promotion of mathematical operands simply emerges as a special application: Julia comes with pre-defined catch-all dispatch rules for mathematical operators, invoked when no specific implementation exists for some combination of operand types. These catch-all rules first promote all operands to a common type using user-definable promotion rules, and then invoke a specialized implementation of the operator in question for the resulting values, now of the same type. User-defined types can easily participate in this promotion system by defining methods for conversion to and from other types, and providing a handful of promotion rules defining what types they should promote to when mixed with other types.\"\n},\n\n{\n    \"location\": \"manual/conversion-and-promotion.html#Conversion-1\",\n    \"page\": \"Conversion and Promotion\",\n    \"title\": \"Conversion\",\n    \"category\": \"section\",\n    \"text\": \"The standard way to obtain a value of a certain type T is to call the type\\'s constructor, T(x). However, there are cases where it\\'s convenient to convert a value from one type to another without the programmer asking for it explicitly. One example is assigning a value into an array: if A is a Vector{Float64}, the expression A[1] = 2 should work by automatically converting the 2 from Int to Float64, and storing the result in the array. This is done via the convert function.The convert function generally takes two arguments: the first is a type object and the second is a value to convert to that type. The returned value is the value converted to an instance of given type. The simplest way to understand this function is to see it in action:julia> x = 12\\n12\\n\\njulia> typeof(x)\\nInt64\\n\\njulia> convert(UInt8, x)\\n0x0c\\n\\njulia> typeof(ans)\\nUInt8\\n\\njulia> convert(AbstractFloat, x)\\n12.0\\n\\njulia> typeof(ans)\\nFloat64\\n\\njulia> a = Any[1 2 3; 4 5 6]\\n2\u00d73 Array{Any,2}:\\n 1  2  3\\n 4  5  6\\n\\njulia> convert(Array{Float64}, a)\\n2\u00d73 Array{Float64,2}:\\n 1.0  2.0  3.0\\n 4.0  5.0  6.0Conversion isn\\'t always possible, in which case a no method error is thrown indicating that convert doesn\\'t know how to perform the requested conversion:julia> convert(AbstractFloat, \\\"foo\\\")\\nERROR: MethodError: Cannot `convert` an object of type String to an object of type AbstractFloat\\n[...]Some languages consider parsing strings as numbers or formatting numbers as strings to be conversions (many dynamic languages will even perform conversion for you automatically), however Julia does not: even though some strings can be parsed as numbers, most strings are not valid representations of numbers, and only a very limited subset of them are. Therefore in Julia the dedicated parse function must be used to perform this operation, making it more explicit.\"\n},\n\n{\n    \"location\": \"manual/conversion-and-promotion.html#When-is-convert-called?-1\",\n    \"page\": \"Conversion and Promotion\",\n    \"title\": \"When is convert called?\",\n    \"category\": \"section\",\n    \"text\": \"The following language constructs call convert:Assigning to an array converts to the array\\'s element type.\\nAssigning to a field of an object converts to the declared type of the field.\\nConstructing an object with new converts to the object\\'s declared field types.\\nAssigning to a variable with a declared type (e.g. local x::T) converts to that type.\\nA function with a declared return type converts its return value to that type.\\nPassing a value to ccall converts it to the corresponding argument type.\"\n},\n\n{\n    \"location\": \"manual/conversion-and-promotion.html#Conversion-vs.-Construction-1\",\n    \"page\": \"Conversion and Promotion\",\n    \"title\": \"Conversion vs. Construction\",\n    \"category\": \"section\",\n    \"text\": \"Note that the behavior of convert(T, x) appears to be nearly identical to T(x). Indeed, it usually is. However, there is a key semantic difference: since convert can be called implicitly, its methods are restricted to cases that are considered \\\"safe\\\" or \\\"unsurprising\\\". convert will only convert between types that represent the same basic kind of thing (e.g. different representations of numbers, or different string encodings). It is also usually lossless; converting a value to a different type and back again should result in the exact same value.There are four general kinds of cases where constructors differ from convert:\"\n},\n\n{\n    \"location\": \"manual/conversion-and-promotion.html#Constructors-for-types-unrelated-to-their-arguments-1\",\n    \"page\": \"Conversion and Promotion\",\n    \"title\": \"Constructors for types unrelated to their arguments\",\n    \"category\": \"section\",\n    \"text\": \"Some constructors don\\'t implement the concept of \\\"conversion\\\". For example, Timer(2) creates a 2-second timer, which is not really a \\\"conversion\\\" from an integer to a timer.\"\n},\n\n{\n    \"location\": \"manual/conversion-and-promotion.html#Mutable-collections-1\",\n    \"page\": \"Conversion and Promotion\",\n    \"title\": \"Mutable collections\",\n    \"category\": \"section\",\n    \"text\": \"convert(T, x) is expected to return the original x if x is already of type T. In contrast, if T is a mutable collection type then T(x) should always make a new collection (copying elements from x).\"\n},\n\n{\n    \"location\": \"manual/conversion-and-promotion.html#Wrapper-types-1\",\n    \"page\": \"Conversion and Promotion\",\n    \"title\": \"Wrapper types\",\n    \"category\": \"section\",\n    \"text\": \"For some types which \\\"wrap\\\" other values, the constructor may wrap its argument inside a new object even if it is already of the requested type. For example Some(x) wraps x to indicate that a value is present (in a context where the result might be a Some or nothing). However, x itself might be the object Some(y), in which case the result is Some(Some(y)), with two levels of wrapping. convert(Some, x), on the other hand, would just return x since it is already a Some.\"\n},\n\n{\n    \"location\": \"manual/conversion-and-promotion.html#Constructors-that-don\\'t-return-instances-of-their-own-type-1\",\n    \"page\": \"Conversion and Promotion\",\n    \"title\": \"Constructors that don\\'t return instances of their own type\",\n    \"category\": \"section\",\n    \"text\": \"In very rare cases it might make sense for the constructor T(x) to return an object not of type T. This could happen if a wrapper type is its own inverse (e.g. Flip(Flip(x)) === x), or to support an old calling syntax for backwards compatibility when a library is restructured. But convert(T, x) should always return a value of type T.\"\n},\n\n{\n    \"location\": \"manual/conversion-and-promotion.html#Defining-New-Conversions-1\",\n    \"page\": \"Conversion and Promotion\",\n    \"title\": \"Defining New Conversions\",\n    \"category\": \"section\",\n    \"text\": \"When defining a new type, initially all ways of creating it should be defined as constructors. If it becomes clear that implicit conversion would be useful, and that some constructors meet the above \\\"safety\\\" criteria, then convert methods can be added. These methods are typically quite simple, as they only need to call the appropriate constructor. Such a definition might look like this:convert(::Type{MyType}, x) = MyType(x)The type of the first argument of this method is a singleton type, Type{MyType}, the only instance of which is MyType. Thus, this method is only invoked when the first argument is the type value MyType. Notice the syntax used for the first argument: the argument name is omitted prior to the :: symbol, and only the type is given. This is the syntax in Julia for a function argument whose type is specified but whose value does not need to be referenced by name. In this example, since the type is a singleton, we already know its value without referring to an argument name.All instances of some abstract types are by default considered \\\"sufficiently similar\\\" that a universal convert definition is provided in Julia Base. For example, this definition states that it\\'s valid to convert any Number type to any other by calling a 1-argument constructor:convert(::Type{T}, x::Number) where {T<:Number} = T(x)This means that new Number types only need to define constructors, since this definition will handle convert for them. An identity conversion is also provided to handle the case where the argument is already of the requested type:convert(::Type{T}, x::T) where {T<:Number} = xSimilar definitions exist for AbstractString, AbstractArray, and AbstractDict.\"\n},\n\n{\n    \"location\": \"manual/conversion-and-promotion.html#Promotion-1\",\n    \"page\": \"Conversion and Promotion\",\n    \"title\": \"Promotion\",\n    \"category\": \"section\",\n    \"text\": \"Promotion refers to converting values of mixed types to a single common type. Although it is not strictly necessary, it is generally implied that the common type to which the values are converted can faithfully represent all of the original values. In this sense, the term \\\"promotion\\\" is appropriate since the values are converted to a \\\"greater\\\" type \u2013 i.e. one which can represent all of the input values in a single common type. It is important, however, not to confuse this with object-oriented (structural) super-typing, or Julia\\'s notion of abstract super-types: promotion has nothing to do with the type hierarchy, and everything to do with converting between alternate representations. For instance, although every Int32 value can also be represented as a Float64 value, Int32 is not a subtype of Float64.Promotion to a common \\\"greater\\\" type is performed in Julia by the promote function, which takes any number of arguments, and returns a tuple of the same number of values, converted to a common type, or throws an exception if promotion is not possible. The most common use case for promotion is to convert numeric arguments to a common type:julia> promote(1, 2.5)\\n(1.0, 2.5)\\n\\njulia> promote(1, 2.5, 3)\\n(1.0, 2.5, 3.0)\\n\\njulia> promote(2, 3//4)\\n(2//1, 3//4)\\n\\njulia> promote(1, 2.5, 3, 3//4)\\n(1.0, 2.5, 3.0, 0.75)\\n\\njulia> promote(1.5, im)\\n(1.5 + 0.0im, 0.0 + 1.0im)\\n\\njulia> promote(1 + 2im, 3//4)\\n(1//1 + 2//1*im, 3//4 + 0//1*im)Floating-point values are promoted to the largest of the floating-point argument types. Integer values are promoted to the larger of either the native machine word size or the largest integer argument type. Mixtures of integers and floating-point values are promoted to a floating-point type big enough to hold all the values. Integers mixed with rationals are promoted to rationals. Rationals mixed with floats are promoted to floats. Complex values mixed with real values are promoted to the appropriate kind of complex value.That is really all there is to using promotions. The rest is just a matter of clever application, the most typical \\\"clever\\\" application being the definition of catch-all methods for numeric operations like the arithmetic operators +, -, * and /. Here are some of the catch-all method definitions given in promotion.jl:+(x::Number, y::Number) = +(promote(x,y)...)\\n-(x::Number, y::Number) = -(promote(x,y)...)\\n*(x::Number, y::Number) = *(promote(x,y)...)\\n/(x::Number, y::Number) = /(promote(x,y)...)These method definitions say that in the absence of more specific rules for adding, subtracting, multiplying and dividing pairs of numeric values, promote the values to a common type and then try again. That\\'s all there is to it: nowhere else does one ever need to worry about promotion to a common numeric type for arithmetic operations \u2013 it just happens automatically. There are definitions of catch-all promotion methods for a number of other arithmetic and mathematical functions in promotion.jl, but beyond that, there are hardly any calls to promote required in Julia Base. The most common usages of promote occur in outer constructors methods, provided for convenience, to allow constructor calls with mixed types to delegate to an inner type with fields promoted to an appropriate common type. For example, recall that rational.jl provides the following outer constructor method:Rational(n::Integer, d::Integer) = Rational(promote(n,d)...)This allows calls like the following to work:julia> Rational(Int8(15),Int32(-5))\\n-3//1\\n\\njulia> typeof(ans)\\nRational{Int32}For most user-defined types, it is better practice to require programmers to supply the expected types to constructor functions explicitly, but sometimes, especially for numeric problems, it can be convenient to do promotion automatically.\"\n},\n\n{\n    \"location\": \"manual/conversion-and-promotion.html#Defining-Promotion-Rules-1\",\n    \"page\": \"Conversion and Promotion\",\n    \"title\": \"Defining Promotion Rules\",\n    \"category\": \"section\",\n    \"text\": \"Although one could, in principle, define methods for the promote function directly, this would require many redundant definitions for all possible permutations of argument types. Instead, the behavior of promote is defined in terms of an auxiliary function called promote_rule, which one can provide methods for. The promote_rule function takes a pair of type objects and returns another type object, such that instances of the argument types will be promoted to the returned type. Thus, by defining the rule:promote_rule(::Type{Float64}, ::Type{Float32}) = Float64one declares that when 64-bit and 32-bit floating-point values are promoted together, they should be promoted to 64-bit floating-point. The promotion type does not need to be one of the argument types, however; the following promotion rules both occur in Julia Base:promote_rule(::Type{UInt8}, ::Type{Int8}) = Int\\npromote_rule(::Type{BigInt}, ::Type{Int8}) = BigIntIn the latter case, the result type is BigInt since BigInt is the only type large enough to hold integers for arbitrary-precision integer arithmetic. Also note that one does not need to define both promote_rule(::Type{A}, ::Type{B}) and promote_rule(::Type{B}, ::Type{A}) \u2013 the symmetry is implied by the way promote_rule is used in the promotion process.The promote_rule function is used as a building block to define a second function called promote_type, which, given any number of type objects, returns the common type to which those values, as arguments to promote should be promoted. Thus, if one wants to know, in absence of actual values, what type a collection of values of certain types would promote to, one can use promote_type:julia> promote_type(Int8, Int64)\\nInt64Internally, promote_type is used inside of promote to determine what type argument values should be converted to for promotion. It can, however, be useful in its own right. The curious reader can read the code in promotion.jl, which defines the complete promotion mechanism in about 35 lines.\"\n},\n\n{\n    \"location\": \"manual/conversion-and-promotion.html#Case-Study:-Rational-Promotions-1\",\n    \"page\": \"Conversion and Promotion\",\n    \"title\": \"Case Study: Rational Promotions\",\n    \"category\": \"section\",\n    \"text\": \"Finally, we finish off our ongoing case study of Julia\\'s rational number type, which makes relatively sophisticated use of the promotion mechanism with the following promotion rules:promote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}\\npromote_rule(::Type{Rational{T}}, ::Type{Rational{S}}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}\\npromote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:AbstractFloat} = promote_type(T,S)The first rule says that promoting a rational number with any other integer type promotes to a rational type whose numerator/denominator type is the result of promotion of its numerator/denominator type with the other integer type. The second rule applies the same logic to two different types of rational numbers, resulting in a rational of the promotion of their respective numerator/denominator types. The third and final rule dictates that promoting a rational with a float results in the same type as promoting the numerator/denominator type with the float.This small handful of promotion rules, together with the type\\'s constructors and the default convert method for numbers, are sufficient to make rational numbers interoperate completely naturally with all of Julia\\'s other numeric types \u2013 integers, floating-point numbers, and complex numbers. By providing appropriate conversion methods and promotion rules in the same manner, any user-defined numeric type can interoperate just as naturally with Julia\\'s predefined numerics.\"\n},\n\n{\n    \"location\": \"manual/interfaces.html#\",\n    \"page\": \"Interfaces\",\n    \"title\": \"Interfaces\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/interfaces.html#Interfaces-1\",\n    \"page\": \"Interfaces\",\n    \"title\": \"Interfaces\",\n    \"category\": \"section\",\n    \"text\": \"A lot of the power and extensibility in Julia comes from a collection of informal interfaces.  By extending a few specific methods to work for a custom type, objects of that type not only receive those functionalities, but they are also able to be used in other methods that are written to generically build upon those behaviors.\"\n},\n\n{\n    \"location\": \"manual/interfaces.html#man-interface-iteration-1\",\n    \"page\": \"Interfaces\",\n    \"title\": \"Iteration\",\n    \"category\": \"section\",\n    \"text\": \"Required methods  Brief description\\niterate(iter)  Returns either a tuple of the first item and initial state or nothing if empty\\niterate(iter, state)  Returns either a tuple of the next item and next state or nothing if no items remain\\nImportant optional methods Default definition Brief description\\nIteratorSize(IterType) HasLength() One of HasLength(), HasShape{N}(), IsInfinite(), or SizeUnknown() as appropriate\\nIteratorEltype(IterType) HasEltype() Either EltypeUnknown() or HasEltype() as appropriate\\neltype(IterType) Any The type of the first entry of the tuple returned by iterate()\\nlength(iter) (undefined) The number of items, if known\\nsize(iter, [dim...]) (undefined) The number of items in each dimension, if knownValue returned by IteratorSize(IterType) Required Methods\\nHasLength() length(iter)\\nHasShape{N}() length(iter)  and size(iter, [dim...])\\nIsInfinite() (none)\\nSizeUnknown() (none)Value returned by IteratorEltype(IterType) Required Methods\\nHasEltype() eltype(IterType)\\nEltypeUnknown() (none)Sequential iteration is implemented by the iterate function. Instead of mutating objects as they are iterated over, Julia iterators may keep track of the iteration state externally from the object. The return value from iterate is always either a tuple of a value and a state, or nothing if no elements remain. The state object will be passed back to the iterate function on the next iteration and is generally considered an implementation detail private to the iterable object.Any object that defines this function is iterable and can be used in the many functions that rely upon iteration. It can also be used directly in a for loop since the syntax:for i in iter   # or  \\\"for i = iter\\\"\\n    # body\\nendis translated into:next = iterate(iter)\\nwhile next !== nothing\\n    (i, state) = next\\n    # body\\n    next = iterate(iter, state)\\nendA simple example is an iterable sequence of square numbers with a defined length:julia> struct Squares\\n           count::Int\\n       end\\n\\njulia> Base.iterate(S::Squares, state=1) = state > S.count ? nothing : (state*state, state+1)With only iterate definition, the Squares type is already pretty powerful. We can iterate over all the elements:julia> for i in Squares(7)\\n           println(i)\\n       end\\n1\\n4\\n9\\n16\\n25\\n36\\n49We can use many of the builtin methods that work with iterables, like in, or mean and std from the Statistics standard library module:julia> 25 in Squares(10)\\ntrue\\n\\njulia> using Statistics\\n\\njulia> mean(Squares(100))\\n3383.5\\n\\njulia> std(Squares(100))\\n3024.355854282583There are a few more methods we can extend to give Julia more information about this iterable collection.  We know that the elements in a Squares sequence will always be Int. By extending the eltype method, we can give that information to Julia and help it make more specialized code in the more complicated methods. We also know the number of elements in our sequence, so we can extend length, too:julia> Base.eltype(::Type{Squares}) = Int # Note that this is defined for the type\\n\\njulia> Base.length(S::Squares) = S.countNow, when we ask Julia to collect all the elements into an array it can preallocate a Vector{Int} of the right size instead of blindly push!ing each element into a Vector{Any}:julia> collect(Squares(4))\\n4-element Array{Int64,1}:\\n  1\\n  4\\n  9\\n 16While we can rely upon generic implementations, we can also extend specific methods where we know there is a simpler algorithm. For example, there\\'s a formula to compute the sum of squares, so we can override the generic iterative version with a more performant solution:julia> Base.sum(S::Squares) = (n = S.count; return n*(n+1)*(2n+1)\u00f76)\\n\\njulia> sum(Squares(1803))\\n1955361914This is a very common pattern throughout Julia Base: a small set of required methods define an informal interface that enable many fancier behaviors. In some cases, types will want to additionally specialize those extra behaviors when they know a more efficient algorithm can be used in their specific case.It is also often useful to allow iteration over a collection in reverse order by iterating over Iterators.reverse(iterator).  To actually support reverse-order iteration, however, an iterator type T needs to implement iterate for Iterators.Reverse{T}. (Given r::Iterators.Reverse{T}, the underling iterator of type T is r.itr.) In our Squares example, we would implement Iterators.Reverse{Squares} methods:julia> Base.iterate(rS::Iterators.Reverse{Squares}, state=rS.itr.count) = state < 1 ? nothing : (state*state, state-1)\\n\\njulia> collect(Iterators.reverse(Squares(4)))\\n4-element Array{Int64,1}:\\n 16\\n  9\\n  4\\n  1\"\n},\n\n{\n    \"location\": \"manual/interfaces.html#Indexing-1\",\n    \"page\": \"Interfaces\",\n    \"title\": \"Indexing\",\n    \"category\": \"section\",\n    \"text\": \"Methods to implement Brief description\\ngetindex(X, i) X[i], indexed element access\\nsetindex!(X, v, i) X[i] = v, indexed assignment\\nfirstindex(X) The first index\\nlastindex(X) The last index, used in X[end]For the Squares iterable above, we can easily compute the ith element of the sequence by squaring it.  We can expose this as an indexing expression S[i]. To opt into this behavior, Squares simply needs to define getindex:julia> function Base.getindex(S::Squares, i::Int)\\n           1 <= i <= S.count || throw(BoundsError(S, i))\\n           return i*i\\n       end\\n\\njulia> Squares(100)[23]\\n529Additionally, to support the syntax S[end], we must define lastindex to specify the last valid index. It is recommended to also define firstindex to specify the first valid index:julia> Base.firstindex(S::Squares) = 1\\n\\njulia> Base.lastindex(S::Squares) = length(S)\\n\\njulia> Squares(23)[end]\\n529Note, though, that the above only defines getindex with one integer index. Indexing with anything other than an Int will throw a MethodError saying that there was no matching method. In order to support indexing with ranges or vectors of Ints, separate methods must be written:julia> Base.getindex(S::Squares, i::Number) = S[convert(Int, i)]\\n\\njulia> Base.getindex(S::Squares, I) = [S[i] for i in I]\\n\\njulia> Squares(10)[[3,4.,5]]\\n3-element Array{Int64,1}:\\n  9\\n 16\\n 25While this is starting to support more of the indexing operations supported by some of the builtin types, there\\'s still quite a number of behaviors missing. This Squares sequence is starting to look more and more like a vector as we\\'ve added behaviors to it. Instead of defining all these behaviors ourselves, we can officially define it as a subtype of an AbstractArray.\"\n},\n\n{\n    \"location\": \"manual/interfaces.html#man-interface-array-1\",\n    \"page\": \"Interfaces\",\n    \"title\": \"Abstract Arrays\",\n    \"category\": \"section\",\n    \"text\": \"Methods to implement  Brief description\\nsize(A)  Returns a tuple containing the dimensions of A\\ngetindex(A, i::Int)  (if IndexLinear) Linear scalar indexing\\ngetindex(A, I::Vararg{Int, N})  (if IndexCartesian, where N = ndims(A)) N-dimensional scalar indexing\\nsetindex!(A, v, i::Int)  (if IndexLinear) Scalar indexed assignment\\nsetindex!(A, v, I::Vararg{Int, N})  (if IndexCartesian, where N = ndims(A)) N-dimensional scalar indexed assignment\\nOptional methods Default definition Brief description\\nIndexStyle(::Type) IndexCartesian() Returns either IndexLinear() or IndexCartesian(). See the description below.\\ngetindex(A, I...) defined in terms of scalar getindex Multidimensional and nonscalar indexing\\nsetindex!(A, I...) defined in terms of scalar setindex! Multidimensional and nonscalar indexed assignment\\niterate defined in terms of scalar getindex Iteration\\nlength(A) prod(size(A)) Number of elements\\nsimilar(A) similar(A, eltype(A), size(A)) Return a mutable array with the same shape and element type\\nsimilar(A, ::Type{S}) similar(A, S, size(A)) Return a mutable array with the same shape and the specified element type\\nsimilar(A, dims::NTuple{Int}) similar(A, eltype(A), dims) Return a mutable array with the same element type and size dims\\nsimilar(A, ::Type{S}, dims::NTuple{Int}) Array{S}(undef, dims) Return a mutable array with the specified element type and size\\nNon-traditional indices Default definition Brief description\\naxes(A) map(OneTo, size(A)) Return the AbstractUnitRange of valid indices\\nBase.similar(A, ::Type{S}, inds::NTuple{Ind}) similar(A, S, Base.to_shape(inds)) Return a mutable array with the specified indices inds (see below)\\nBase.similar(T::Union{Type,Function}, inds) T(Base.to_shape(inds)) Return an array similar to T with the specified indices inds (see below)If a type is defined as a subtype of AbstractArray, it inherits a very large set of rich behaviors including iteration and multidimensional indexing built on top of single-element access.  See the arrays manual page and the Julia Base section for more supported methods.A key part in defining an AbstractArray subtype is IndexStyle. Since indexing is such an important part of an array and often occurs in hot loops, it\\'s important to make both indexing and indexed assignment as efficient as possible.  Array data structures are typically defined in one of two ways: either it most efficiently accesses its elements using just one index (linear indexing) or it intrinsically accesses the elements with indices specified for every dimension.  These two modalities are identified by Julia as IndexLinear() and IndexCartesian().  Converting a linear index to multiple indexing subscripts is typically very expensive, so this provides a traits-based mechanism to enable efficient generic code for all array types.This distinction determines which scalar indexing methods the type must define. IndexLinear() arrays are simple: just define getindex(A::ArrayType, i::Int).  When the array is subsequently indexed with a multidimensional set of indices, the fallback getindex(A::AbstractArray, I...)() efficiently converts the indices into one linear index and then calls the above method. IndexCartesian() arrays, on the other hand, require methods to be defined for each supported dimensionality with ndims(A) Int indices. For example, SparseMatrixCSC from the SparseArrays standard library module, only supports two dimensions, so it just defines getindex(A::SparseMatrixCSC, i::Int, j::Int). The same holds for setindex!.Returning to the sequence of squares from above, we could instead define it as a subtype of an AbstractArray{Int, 1}:julia> struct SquaresVector <: AbstractArray{Int, 1}\\n           count::Int\\n       end\\n\\njulia> Base.size(S::SquaresVector) = (S.count,)\\n\\njulia> Base.IndexStyle(::Type{<:SquaresVector}) = IndexLinear()\\n\\njulia> Base.getindex(S::SquaresVector, i::Int) = i*iNote that it\\'s very important to specify the two parameters of the AbstractArray; the first defines the eltype, and the second defines the ndims. That supertype and those three methods are all it takes for SquaresVector to be an iterable, indexable, and completely functional array:julia> s = SquaresVector(4)\\n4-element SquaresVector:\\n  1\\n  4\\n  9\\n 16\\n\\njulia> s[s .> 8]\\n2-element Array{Int64,1}:\\n  9\\n 16\\n\\njulia> s + s\\n4-element Array{Int64,1}:\\n  2\\n  8\\n 18\\n 32\\n\\njulia> sin.(s)\\n4-element Array{Float64,1}:\\n  0.8414709848078965\\n -0.7568024953079282\\n  0.4121184852417566\\n -0.2879033166650653As a more complicated example, let\\'s define our own toy N-dimensional sparse-like array type built on top of Dict:julia> struct SparseArray{T,N} <: AbstractArray{T,N}\\n           data::Dict{NTuple{N,Int}, T}\\n           dims::NTuple{N,Int}\\n       end\\n\\njulia> SparseArray(::Type{T}, dims::Int...) where {T} = SparseArray(T, dims);\\n\\njulia> SparseArray(::Type{T}, dims::NTuple{N,Int}) where {T,N} = SparseArray{T,N}(Dict{NTuple{N,Int}, T}(), dims);\\n\\njulia> Base.size(A::SparseArray) = A.dims\\n\\njulia> Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where {T} = SparseArray(T, dims)\\n\\njulia> Base.getindex(A::SparseArray{T,N}, I::Vararg{Int,N}) where {T,N} = get(A.data, I, zero(T))\\n\\njulia> Base.setindex!(A::SparseArray{T,N}, v, I::Vararg{Int,N}) where {T,N} = (A.data[I] = v)Notice that this is an IndexCartesian array, so we must manually define getindex and setindex! at the dimensionality of the array. Unlike the SquaresVector, we are able to define setindex!, and so we can mutate the array:julia> A = SparseArray(Float64, 3, 3)\\n3\u00d73 SparseArray{Float64,2}:\\n 0.0  0.0  0.0\\n 0.0  0.0  0.0\\n 0.0  0.0  0.0\\n\\njulia> fill!(A, 2)\\n3\u00d73 SparseArray{Float64,2}:\\n 2.0  2.0  2.0\\n 2.0  2.0  2.0\\n 2.0  2.0  2.0\\n\\njulia> A[:] = 1:length(A); A\\n3\u00d73 SparseArray{Float64,2}:\\n 1.0  4.0  7.0\\n 2.0  5.0  8.0\\n 3.0  6.0  9.0The result of indexing an AbstractArray can itself be an array (for instance when indexing by an AbstractRange). The AbstractArray fallback methods use similar to allocate an Array of the appropriate size and element type, which is filled in using the basic indexing method described above. However, when implementing an array wrapper you often want the result to be wrapped as well:julia> A[1:2,:]\\n2\u00d73 SparseArray{Float64,2}:\\n 1.0  4.0  7.0\\n 2.0  5.0  8.0In this example it is accomplished by defining Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims) to create the appropriate wrapped array. (Note that while similar supports 1- and 2-argument forms, in most case you only need to specialize the 3-argument form.) For this to work it\\'s important that SparseArray is mutable (supports setindex!). Defining similar, getindex and setindex! for SparseArray also makes it possible to copy the array:julia> copy(A)\\n3\u00d73 SparseArray{Float64,2}:\\n 1.0  4.0  7.0\\n 2.0  5.0  8.0\\n 3.0  6.0  9.0In addition to all the iterable and indexable methods from above, these types can also interact with each other and use most of the methods defined in Julia Base for AbstractArrays:julia> A[SquaresVector(3)]\\n3-element SparseArray{Float64,1}:\\n 1.0\\n 4.0\\n 9.0\\n\\njulia> sum(A)\\n45.0If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize axes. You should also specialize similar so that the dims argument (ordinarily a Dims size-tuple) can accept AbstractUnitRange objects, perhaps range-types Ind of your own design. For more information, see Arrays with custom indices.\"\n},\n\n{\n    \"location\": \"manual/interfaces.html#man-interface-strided-arrays-1\",\n    \"page\": \"Interfaces\",\n    \"title\": \"Strided Arrays\",\n    \"category\": \"section\",\n    \"text\": \"Methods to implement  Brief description\\nstrides(A)  Return the distance in memory (in number of elements) between adjacent elements in each dimension as a tuple. If A is an AbstractArray{T,0}, this should return an empty tuple.\\nBase.unsafe_convert(::Type{Ptr{T}}, A)  Return the native address of an array.\\nOptional methods Default definition Brief description\\nstride(A, i::Int) strides(A)[i] Return the distance in memory (in number of elements) between adjacent elements in dimension k.A strided array is a subtype of AbstractArray whose entries are stored in memory with fixed strides. Provided the element type of the array is compatible with BLAS, a strided array can utilize BLAS and LAPACK routines for more efficient linear algebra routines.  A typical example of a user-defined strided array is one that wraps a standard Array with additional structure.Warning: do not implement these methods if the underlying storage is not actually strided, as it may lead to incorrect results or segmentation faults.Here are some examples to demonstrate which type of arrays are strided and which are not:1:5   # not strided (there is no storage associated with this array.)\\nVector(1:5)  # is strided with strides (1,)\\nA = [1 5; 2 6; 3 7; 4 8]  # is strided with strides (1,4)\\nV = view(A, 1:2, :)   # is strided with strides (1,4)\\nV = view(A, 1:2:3, 1:2)   # is strided with strides (2,4)\\nV = view(A, [1,2,4], :)   # is not strided, as the spacing between rows is not fixed.\"\n},\n\n{\n    \"location\": \"manual/interfaces.html#man-interfaces-broadcasting-1\",\n    \"page\": \"Interfaces\",\n    \"title\": \"Customizing broadcasting\",\n    \"category\": \"section\",\n    \"text\": \"Methods to implement Brief description\\nBase.BroadcastStyle(::Type{SrcType}) = SrcStyle() Broadcasting behavior of SrcType\\nBase.similar(bc::Broadcasted{DestStyle}, ::Type{ElType}) Allocation of output container\\nOptional methods \\nBase.BroadcastStyle(::Style1, ::Style2) = Style12() Precedence rules for mixing styles\\nBase.broadcast_axes(x) Declaration of the indices of x for broadcasting purposes (defaults to axes(x))\\nBase.broadcastable(x) Convert x to an object that has axes and supports indexing\\nBypassing default machinery \\nBase.copy(bc::Broadcasted{DestStyle}) Custom implementation of broadcast\\nBase.copyto!(dest, bc::Broadcasted{DestStyle}) Custom implementation of broadcast!, specializing on DestStyle\\nBase.copyto!(dest::DestType, bc::Broadcasted{Nothing}) Custom implementation of broadcast!, specializing on DestType\\nBase.Broadcast.broadcasted(f, args...) Override the default lazy behavior within a fused expression\\nBase.Broadcast.instantiate(bc::Broadcasted{DestStyle}) Override the computation of the lazy broadcast\\'s axesBroadcasting is triggered by an explicit call to broadcast or broadcast!, or implicitly by \\\"dot\\\" operations like A .+ b or f.(x, y). Any object that has axes and supports indexing can participate as an argument in broadcasting, and by default the result is stored in an Array. This basic framework is extensible in three major ways:Ensuring that all arguments support broadcast\\nSelecting an appropriate output array for the given set of arguments\\nSelecting an efficient implementation for the given set of argumentsNot all types support axes and indexing, but many are convenient to allow in broadcast. The Base.broadcastable function is called on each argument to broadcast, allowing it to return something different that supports axes and indexing. By default, this is the identity function for all AbstractArrays and Numbers \u2014 they already support axes and indexing. For a handful of other types (including but not limited to types themselves, functions, special singletons like missing and nothing, and dates), Base.broadcastable returns the argument wrapped in a Ref to act as a 0-dimensional \\\"scalar\\\" for the purposes of broadcasting. Custom types can similarly specialize Base.broadcastable to define their shape, but they should follow the convention that collect(Base.broadcastable(x)) == collect(x). A notable exception is AbstractString; strings are special-cased to behave as scalars for the purposes of broadcast even though they are iterable collections of their characters (see Strings for more).The next two steps (selecting the output array and implementation) are dependent upon determining a single answer for a given set of arguments. Broadcast must take all the varied types of its arguments and collapse them down to just one output array and one implementation. Broadcast calls this single answer a \\\"style.\\\" Every broadcastable object each has its own preferred style, and a promotion-like system is used to combine these styles into a single answer \u2014 the \\\"destination style\\\".\"\n},\n\n{\n    \"location\": \"manual/interfaces.html#Broadcast-Styles-1\",\n    \"page\": \"Interfaces\",\n    \"title\": \"Broadcast Styles\",\n    \"category\": \"section\",\n    \"text\": \"Base.BroadcastStyle is the abstract type from which all broadcast styles are derived. When used as a function it has two possible forms, unary (single-argument) and binary. The unary variant states that you intend to implement specific broadcasting behavior and/or output type, and do not wish to rely on the default fallback Broadcast.DefaultArrayStyle.To override these defaults, you can define a custom BroadcastStyle for your object:struct MyStyle <: Broadcast.BroadcastStyle end\\nBase.BroadcastStyle(::Type{<:MyType}) = MyStyle()In some cases it might be convenient not to have to define MyStyle, in which case you can leverage one of the general broadcast wrappers:Base.BroadcastStyle(::Type{<:MyType}) = Broadcast.Style{MyType}() can be used for arbitrary types.\\nBase.BroadcastStyle(::Type{<:MyType}) = Broadcast.ArrayStyle{MyType}() is preferred if MyType is an AbstractArray.\\nFor AbstractArrays that only support a certain dimensionality, create a subtype of Broadcast.AbstractArrayStyle{N} (see below).When your broadcast operation involves several arguments, individual argument styles get combined to determine a single DestStyle that controls the type of the output container. For more details, see below.\"\n},\n\n{\n    \"location\": \"manual/interfaces.html#Selecting-an-appropriate-output-array-1\",\n    \"page\": \"Interfaces\",\n    \"title\": \"Selecting an appropriate output array\",\n    \"category\": \"section\",\n    \"text\": \"The broadcast style is computed for every broadcasting operation to allow for dispatch and specialization. The actual allocation of the result array is handled by similar, using the Broadcasted object as its first argument.Base.similar(bc::Broadcasted{DestStyle}, ::Type{ElType})The fallback definition issimilar(bc::Broadcasted{DefaultArrayStyle{N}}, ::Type{ElType}) where {N,ElType} =\\n    similar(Array{ElType}, axes(bc))However, if needed you can specialize on any or all of these arguments. The final argument bc is a lazy representation of a (potentially fused) broadcast operation, a Broadcasted object.  For these purposes, the most important fields of the wrapper are f and args, describing the function and argument list, respectively.  Note that the argument list can \u2014 and often does \u2014 include other nested Broadcasted wrappers.For a complete example, let\\'s say you have created a type, ArrayAndChar, that stores an array and a single character:struct ArrayAndChar{T,N} <: AbstractArray{T,N}\\n    data::Array{T,N}\\n    char::Char\\nend\\nBase.size(A::ArrayAndChar) = size(A.data)\\nBase.getindex(A::ArrayAndChar{T,N}, inds::Vararg{Int,N}) where {T,N} = A.data[inds...]\\nBase.setindex!(A::ArrayAndChar{T,N}, val, inds::Vararg{Int,N}) where {T,N} = A.data[inds...] = val\\nBase.showarg(io::IO, A::ArrayAndChar, toplevel) = print(io, typeof(A), \\\" with char \\'\\\", A.char, \\\"\\'\\\")You might want broadcasting to preserve the char \\\"metadata.\\\" First we defineBase.BroadcastStyle(::Type{<:ArrayAndChar}) = Broadcast.ArrayStyle{ArrayAndChar}()This means we must also define a corresponding similar method:function Base.similar(bc::Broadcast.Broadcasted{Broadcast.ArrayStyle{ArrayAndChar}}, ::Type{ElType}) where ElType\\n    # Scan the inputs for the ArrayAndChar:\\n    A = find_aac(bc)\\n    # Use the char field of A to create the output\\n    ArrayAndChar(similar(Array{ElType}, axes(bc)), A.char)\\nend\\n\\n\\\"`A = find_aac(As)` returns the first ArrayAndChar among the arguments.\\\"\\nfind_aac(bc::Base.Broadcast.Broadcasted) = find_aac(bc.args)\\nfind_aac(args::Tuple) = find_aac(find_aac(args[1]), Base.tail(args))\\nfind_aac(x) = x\\nfind_aac(a::ArrayAndChar, rest) = a\\nfind_aac(::Any, rest) = find_aac(rest)From these definitions, one obtains the following behavior:julia> a = ArrayAndChar([1 2; 3 4], \\'x\\')\\n2\u00d72 ArrayAndChar{Int64,2} with char \\'x\\':\\n 1  2\\n 3  4\\n\\njulia> a .+ 1\\n2\u00d72 ArrayAndChar{Int64,2} with char \\'x\\':\\n 2  3\\n 4  5\\n\\njulia> a .+ [5,10]\\n2\u00d72 ArrayAndChar{Int64,2} with char \\'x\\':\\n  6   7\\n 13  14\"\n},\n\n{\n    \"location\": \"manual/interfaces.html#extending-in-place-broadcast-1\",\n    \"page\": \"Interfaces\",\n    \"title\": \"Extending broadcast with custom implementations\",\n    \"category\": \"section\",\n    \"text\": \"In general, a broadcast operation is represented by a lazy Broadcasted container that holds onto the function to be applied alongside its arguments. Those arguments may themselves be more nested Broadcasted containers, forming a large expression tree to be evaluated. A nested tree of Broadcasted containers is directly constructed by the implicit dot syntax; 5 .+ 2.*x is transiently represented by Broadcasted(+, 5, Broadcasted(*, 2, x)), for example. This is invisible to users as it is immediately realized through a call to copy, but it is this container that provides the basis for broadcast\\'s extensibility for authors of custom types. The built-in broadcast machinery will then determine the result type and size based upon the arguments, allocate it, and then finally copy the realization of the Broadcasted object into it with a default copyto!(::AbstractArray, ::Broadcasted) method. The built-in fallback broadcast and broadcast! methods similarly construct a transient Broadcasted representation of the operation so they can follow the same codepath. This allows custom array implementations to provide their own copyto! specialization to customize and optimize broadcasting. This is again determined by the computed broadcast style. This is such an important part of the operation that it is stored as the first type parameter of the Broadcasted type, allowing for dispatch and specialization.For some types, the machinery to \\\"fuse\\\" operations across nested levels of broadcasting is not available or could be done more efficiently incrementally. In such cases, you may need or want to evaluate x .* (x .+ 1) as if it had been written broadcast(*, x, broadcast(+, x, 1)), where the inner operation is evaluated before tackling the outer operation. This sort of eager operation is directly supported by a bit of indirection; instead of directly constructing Broadcasted objects, Julia lowers the fused expression x .* (x .+ 1) to Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1)). Now, by default, broadcasted just calls the Broadcasted constructor to create the lazy representation of the fused expression tree, but you can choose to override it for a particular combination of function and arguments.As an example, the builtin AbstractRange objects use this machinery to optimize pieces of broadcasted expressions that can be eagerly evaluated purely in terms of the start, step, and length (or stop) instead of computing every single element. Just like all the other machinery, broadcasted also computes and exposes the combined broadcast style of its arguments, so instead of specializing on broadcasted(f, args...), you can specialize on broadcasted(::DestStyle, f, args...) for any combination of style, function, and arguments.For example, the following definition supports the negation of ranges:broadcasted(::DefaultArrayStyle{1}, ::typeof(-), r::OrdinalRange) = range(-first(r), step=-step(r), length=length(r))\"\n},\n\n{\n    \"location\": \"manual/interfaces.html#extending-in-place-broadcast-2\",\n    \"page\": \"Interfaces\",\n    \"title\": \"Extending in-place broadcasting\",\n    \"category\": \"section\",\n    \"text\": \"In-place broadcasting can be supported by defining the appropriate copyto!(dest, bc::Broadcasted) method. Because you might want to specialize either on dest or the specific subtype of bc, to avoid ambiguities between packages we recommend the following convention.If you wish to specialize on a particular style DestStyle, define a method forcopyto!(dest, bc::Broadcasted{DestStyle})Optionally, with this form you can also specialize on the type of dest.If instead you want to specialize on the destination type DestType without specializing on DestStyle, then you should define a method with the following signature:copyto!(dest::DestType, bc::Broadcasted{Nothing})This leverages a fallback implementation of copyto! that converts the wrapper into a Broadcasted{Nothing}. Consequently, specializing on DestType has lower precedence than methods that specialize on DestStyle.Similarly, you can completely override out-of-place broadcasting with a copy(::Broadcasted) method.\"\n},\n\n{\n    \"location\": \"manual/interfaces.html#Working-with-Broadcasted-objects-1\",\n    \"page\": \"Interfaces\",\n    \"title\": \"Working with Broadcasted objects\",\n    \"category\": \"section\",\n    \"text\": \"In order to implement such a copy or copyto!, method, of course, you must work with the Broadcasted wrapper to compute each element. There are two main ways of doing so:Broadcast.flatten recomputes the potentially nested operation into a single function and flat list of arguments. You are responsible for implementing the broadcasting shape rules yourself, but this may be helpful in limited situations.\\nIterating over the CartesianIndices of the axes(::Broadcasted) and using indexing with the resulting CartesianIndex object to compute the result.\"\n},\n\n{\n    \"location\": \"manual/interfaces.html#writing-binary-broadcasting-rules-1\",\n    \"page\": \"Interfaces\",\n    \"title\": \"Writing binary broadcasting rules\",\n    \"category\": \"section\",\n    \"text\": \"The precedence rules are defined by binary BroadcastStyle calls:Base.BroadcastStyle(::Style1, ::Style2) = Style12()where Style12 is the BroadcastStyle you want to choose for outputs involving arguments of Style1 and Style2. For example,Base.BroadcastStyle(::Broadcast.Style{Tuple}, ::Broadcast.AbstractArrayStyle{0}) = Broadcast.Style{Tuple}()indicates that Tuple \\\"wins\\\" over zero-dimensional arrays (the output container will be a tuple). It is worth noting that you do not need to (and should not) define both argument orders of this call; defining one is sufficient no matter what order the user supplies the arguments in.For AbstractArray types, defining a BroadcastStyle supersedes the fallback choice, Broadcast.DefaultArrayStyle. DefaultArrayStyle and the abstract supertype, AbstractArrayStyle, store the dimensionality as a type parameter to support specialized array types that have fixed dimensionality requirements.DefaultArrayStyle \\\"loses\\\" to any other AbstractArrayStyle that has been defined because of the following methods:BroadcastStyle(a::AbstractArrayStyle{Any}, ::DefaultArrayStyle) = a\\nBroadcastStyle(a::AbstractArrayStyle{N}, ::DefaultArrayStyle{N}) where N = a\\nBroadcastStyle(a::AbstractArrayStyle{M}, ::DefaultArrayStyle{N}) where {M,N} =\\n    typeof(a)(_max(Val(M),Val(N)))You do not need to write binary BroadcastStyle rules unless you want to establish precedence for two or more non-DefaultArrayStyle types.If your array type does have fixed dimensionality requirements, then you should subtype AbstractArrayStyle. For example, the sparse array code has the following definitions:struct SparseVecStyle <: Broadcast.AbstractArrayStyle{1} end\\nstruct SparseMatStyle <: Broadcast.AbstractArrayStyle{2} end\\nBase.BroadcastStyle(::Type{<:SparseVector}) = SparseVecStyle()\\nBase.BroadcastStyle(::Type{<:SparseMatrixCSC}) = SparseMatStyle()Whenever you subtype AbstractArrayStyle, you also need to define rules for combining dimensionalities, by creating a constructor for your style that takes a Val(N) argument. For example:SparseVecStyle(::Val{0}) = SparseVecStyle()\\nSparseVecStyle(::Val{1}) = SparseVecStyle()\\nSparseVecStyle(::Val{2}) = SparseMatStyle()\\nSparseVecStyle(::Val{N}) where N = Broadcast.DefaultArrayStyle{N}()These rules indicate that the combination of a SparseVecStyle with 0- or 1-dimensional arrays yields another SparseVecStyle, that its combination with a 2-dimensional array yields a SparseMatStyle, and anything of higher dimensionality falls back to the dense arbitrary-dimensional framework. These rules allow broadcasting to keep the sparse representation for operations that result in one or two dimensional outputs, but produce an Array for any other dimensionality.\"\n},\n\n{\n    \"location\": \"manual/modules.html#\",\n    \"page\": \"Modules\",\n    \"title\": \"Modules\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/modules.html#modules-1\",\n    \"page\": \"Modules\",\n    \"title\": \"Modules\",\n    \"category\": \"section\",\n    \"text\": \"Modules in Julia are separate variable workspaces, i.e. they introduce a new global scope. They are delimited syntactically, inside module Name ... end. Modules allow you to create top-level definitions (aka global variables) without worrying about name conflicts when your code is used together with somebody else\\'s. Within a module, you can control which names from other modules are visible (via importing), and specify which of your names are intended to be public (via exporting).The following example demonstrates the major features of modules. It is not meant to be run, but is shown for illustrative purposes:module MyModule\\nusing Lib\\n\\nusing BigLib: thing1, thing2\\n\\nimport Base.show\\n\\nexport MyType, foo\\n\\nstruct MyType\\n    x\\nend\\n\\nbar(x) = 2x\\nfoo(a::MyType) = bar(a.x) + 1\\n\\nshow(io::IO, a::MyType) = print(io, \\\"MyType $(a.x)\\\")\\nendNote that the style is not to indent the body of the module, since that would typically lead to whole files being indented.This module defines a type MyType, and two functions. Function foo and type MyType are exported, and so will be available for importing into other modules.  Function bar is private to MyModule.The statement using Lib means that a module called Lib will be available for resolving names as needed. When a global variable is encountered that has no definition in the current module, the system will search for it among variables exported by Lib and import it if it is found there. This means that all uses of that global within the current module will resolve to the definition of that variable in Lib.The statement using BigLib: thing1, thing2 brings just the identifiers thing1 and thing2 into scope from module BigLib. If these names refer to functions, adding methods to them will not be allowed (you may only \\\"use\\\" them, not extend them).The import keyword supports the same syntax as using, but only operates on a single name at a time. It does not add modules to be searched the way using does. import also differs from using in that functions imported using import can be extended with new methods.In MyModule above we wanted to add a method to the standard show function, so we had to write import Base.show. Functions whose names are only visible via using cannot be extended.Once a variable is made visible via using or import, a module may not create its own variable with the same name. Imported variables are read-only; assigning to a global variable always affects a variable owned by the current module, or else raises an error.\"\n},\n\n{\n    \"location\": \"manual/modules.html#Summary-of-module-usage-1\",\n    \"page\": \"Modules\",\n    \"title\": \"Summary of module usage\",\n    \"category\": \"section\",\n    \"text\": \"To load a module, two main keywords can be used: using and import. To understand their differences, consider the following example:module MyModule\\n\\nexport x, y\\n\\nx() = \\\"x\\\"\\ny() = \\\"y\\\"\\np() = \\\"p\\\"\\n\\nendIn this module we export the x and y functions (with the keyword export), and also have the non-exported function p. There are several different ways to load the Module and its inner functions into the current workspace:Import Command What is brought into scope Available for method extension\\nusing MyModule All exported names (x and y), MyModule.x, MyModule.y and MyModule.p MyModule.x, MyModule.y and MyModule.p\\nusing MyModule: x, p x and p \\nimport MyModule MyModule.x, MyModule.y and MyModule.p MyModule.x, MyModule.y and MyModule.p\\nimport MyModule.x, MyModule.p x and p x and p\\nimport MyModule: x, p x and p x and p\"\n},\n\n{\n    \"location\": \"manual/modules.html#Modules-and-files-1\",\n    \"page\": \"Modules\",\n    \"title\": \"Modules and files\",\n    \"category\": \"section\",\n    \"text\": \"Files and file names are mostly unrelated to modules; modules are associated only with module expressions. One can have multiple files per module, and multiple modules per file:module Foo\\n\\ninclude(\\\"file1.jl\\\")\\ninclude(\\\"file2.jl\\\")\\n\\nendIncluding the same code in different modules provides mixin-like behavior. One could use this to run the same code with different base definitions, for example testing code by running it with \\\"safe\\\" versions of some operators:module Normal\\ninclude(\\\"mycode.jl\\\")\\nend\\n\\nmodule Testing\\ninclude(\\\"safe_operators.jl\\\")\\ninclude(\\\"mycode.jl\\\")\\nend\"\n},\n\n{\n    \"location\": \"manual/modules.html#Standard-modules-1\",\n    \"page\": \"Modules\",\n    \"title\": \"Standard modules\",\n    \"category\": \"section\",\n    \"text\": \"There are three important standard modules: Main, Core, and Base.Main is the top-level module, and Julia starts with Main set as the current module.  Variables defined at the prompt go in Main, and varinfo() lists variables in Main.Core contains all identifiers considered \\\"built in\\\" to the language, i.e. part of the core language and not libraries. Every module implicitly specifies using Core, since you can\\'t do anything without those definitions.Base is a module that contains basic functionality (the contents of base/). All modules implicitly contain using Base, since this is needed in the vast majority of cases.\"\n},\n\n{\n    \"location\": \"manual/modules.html#Default-top-level-definitions-and-bare-modules-1\",\n    \"page\": \"Modules\",\n    \"title\": \"Default top-level definitions and bare modules\",\n    \"category\": \"section\",\n    \"text\": \"In addition to using Base, modules also automatically contain definitions of the eval and include functions, which evaluate expressions/files within the global scope of that module.If these default definitions are not wanted, modules can be defined using the keyword baremodule instead (note: Core is still imported, as per above). In terms of baremodule, a standard module looks like this:baremodule Mod\\n\\nusing Base\\n\\neval(x) = Core.eval(Mod, x)\\ninclude(p) = Base.include(Mod, p)\\n\\n...\\n\\nend\"\n},\n\n{\n    \"location\": \"manual/modules.html#Relative-and-absolute-module-paths-1\",\n    \"page\": \"Modules\",\n    \"title\": \"Relative and absolute module paths\",\n    \"category\": \"section\",\n    \"text\": \"Given the statement using Foo, the system consults an internal table of top-level modules to look for one named Foo. If the module does not exist, the system attempts to require(:Foo), which typically results in loading code from an installed package.However, some modules contain submodules, which means you sometimes need to access a non-top-level module. There are two ways to do this. The first is to use an absolute path, for example using Base.Sort. The second is to use a relative path, which makes it easier to import submodules of the current module or any of its enclosing modules:module Parent\\n\\nmodule Utils\\n...\\nend\\n\\nusing .Utils\\n\\n...\\nendHere module Parent contains a submodule Utils, and code in Parent wants the contents of Utils to be visible. This is done by starting the using path with a period. Adding more leading periods moves up additional levels in the module hierarchy. For example using ..Utils would look for Utils in Parent\\'s enclosing module rather than in Parent itself.Note that relative-import qualifiers are only valid in using and import statements.\"\n},\n\n{\n    \"location\": \"manual/modules.html#Module-file-paths-1\",\n    \"page\": \"Modules\",\n    \"title\": \"Module file paths\",\n    \"category\": \"section\",\n    \"text\": \"The global variable LOAD_PATH contains the directories Julia searches for modules when calling require. It can be extended using push!:push!(LOAD_PATH, \\\"/Path/To/My/Module/\\\")Putting this statement in the file ~/.julia/config/startup.jl will extend LOAD_PATH on every Julia startup. Alternatively, the module load path can be extended by defining the environment variable JULIA_LOAD_PATH.\"\n},\n\n{\n    \"location\": \"manual/modules.html#Namespace-miscellanea-1\",\n    \"page\": \"Modules\",\n    \"title\": \"Namespace miscellanea\",\n    \"category\": \"section\",\n    \"text\": \"If a name is qualified (e.g. Base.sin), then it can be accessed even if it is not exported. This is often useful when debugging. It can also have methods added to it by using the qualified name as the function name. However, due to syntactic ambiguities that arise, if you wish to add methods to a function in a different module whose name contains only symbols, such as an operator, Base.+ for example, you must use Base.:+ to refer to it. If the operator is more than one character in length you must surround it in brackets, such as: Base.:(==).Macro names are written with @ in import and export statements, e.g. import Mod.@mac. Macros in other modules can be invoked as Mod.@mac or @Mod.mac.The syntax M.x = y does not work to assign a global in another module; global assignment is always module-local.A variable name can be \\\"reserved\\\" without assigning to it by declaring it as global x. This prevents name conflicts for globals initialized after load time.\"\n},\n\n{\n    \"location\": \"manual/modules.html#Module-initialization-and-precompilation-1\",\n    \"page\": \"Modules\",\n    \"title\": \"Module initialization and precompilation\",\n    \"category\": \"section\",\n    \"text\": \"Large modules can take several seconds to load because executing all of the statements in a module often involves compiling a large amount of code. Julia creates precompiled caches of the module to reduce this time.The incremental precompiled module file are created and used automatically when using import or using to load a module.  This will cause it to be automatically compiled the first time it is imported. Alternatively, you can manually call Base.compilecache(modulename). The resulting cache files will be stored in DEPOT_PATH[1]/compiled/. Subsequently, the module is automatically recompiled upon using or import whenever any of its dependencies change; dependencies are modules it imports, the Julia build, files it includes, or explicit dependencies declared by include_dependency(path) in the module file(s).For file dependencies, a change is determined by examining whether the modification time (mtime) of each file loaded by include or added explicitly by include_dependency is unchanged, or equal to the modification time truncated to the nearest second (to accommodate systems that can\\'t copy mtime with sub-second accuracy). It also takes into account whether the path to the file chosen by the search logic in require matches the path that had created the precompile file.It also takes into account the set of dependencies already loaded into the current process and won\\'t recompile those modules, even if their files change or disappear, in order to avoid creating incompatibilities between the running system and the precompile cache. If you want to have changes to the source reflected in the running system, you should call reload(\\\"Module\\\") on the module you changed, and any module that depended on it in which you want to see the change reflected.If you know that a module is not safe to precompile your module (for example, for one of the reasons described below), you should put __precompile__(false) in the module file (typically placed at the top). This will cause Base.compilecache to throw an error, and will cause using / import to load it directly into the current process and skip the precompile and caching. This also thereby prevents the module from being imported by any other precompiled module.You may need to be aware of certain behaviors inherent in the creation of incremental shared libraries which may require care when writing your module. For example, external state is not preserved. To accommodate this, explicitly separate any initialization steps that must occur at runtime from steps that can occur at compile time. For this purpose, Julia allows you to define an __init__() function in your module that executes any initialization steps that must occur at runtime. This function will not be called during compilation (--output-*). Effectively, you can assume it will be run exactly once in the lifetime of the code. You may, of course, call it manually if necessary, but the default is to assume this function deals with computing state for the local machine, which does not need to be \u2013 or even should not be \u2013 captured in the compiled image. It will be called after the module is loaded into a process, including if it is being loaded into an incremental compile (--output-incremental=yes), but not if it is being loaded into a full-compilation process.In particular, if you define a function __init__() in a module, then Julia will call __init__() immediately after the module is loaded (e.g., by import, using, or require) at runtime for the first time (i.e., __init__ is only called once, and only after all statements in the module have been executed). Because it is called after the module is fully imported, any submodules or other imported modules have their __init__ functions called before the __init__ of the enclosing module.Two typical uses of __init__ are calling runtime initialization functions of external C libraries and initializing global constants that involve pointers returned by external libraries.  For example, suppose that we are calling a C library libfoo that requires us to call a foo_init() initialization function at runtime. Suppose that we also want to define a global constant foo_data_ptr that holds the return value of a void *foo_data() function defined by libfoo \u2013 this constant must be initialized at runtime (not at compile time) because the pointer address will change from run to run.  You could accomplish this by defining the following __init__ function in your module:const foo_data_ptr = Ref{Ptr{Cvoid}}(0)\\nfunction __init__()\\n    ccall((:foo_init, :libfoo), Cvoid, ())\\n    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Cvoid}, ())\\n    nothing\\nendNotice that it is perfectly possible to define a global inside a function like __init__; this is one of the advantages of using a dynamic language. But by making it a constant at global scope, we can ensure that the type is known to the compiler and allow it to generate better optimized code. Obviously, any other globals in your module that depends on foo_data_ptr would also have to be initialized in __init__.Constants involving most Julia objects that are not produced by ccall do not need to be placed in __init__: their definitions can be precompiled and loaded from the cached module image. This includes complicated heap-allocated objects like arrays. However, any routine that returns a raw pointer value must be called at runtime for precompilation to work (Ptr objects will turn into null pointers unless they are hidden inside an isbits object). This includes the return values of the Julia functions cfunction and pointer.Dictionary and set types, or in general anything that depends on the output of a hash(key) method, are a trickier case.  In the common case where the keys are numbers, strings, symbols, ranges, Expr, or compositions of these types (via arrays, tuples, sets, pairs, etc.) they are safe to precompile.  However, for a few other key types, such as Function or DataType and generic user-defined types where you haven\\'t defined a hash method, the fallback hash method depends on the memory address of the object (via its objectid) and hence may change from run to run. If you have one of these key types, or if you aren\\'t sure, to be safe you can initialize this dictionary from within your __init__ function. Alternatively, you can use the IdDict dictionary type, which is specially handled by precompilation so that it is safe to initialize at compile-time.When using precompilation, it is important to keep a clear sense of the distinction between the compilation phase and the execution phase. In this mode, it will often be much more clearly apparent that Julia is a compiler which allows execution of arbitrary Julia code, not a standalone interpreter that also generates compiled code.Other known potential failure scenarios include:Global counters (for example, for attempting to uniquely identify objects) Consider the following code snippet:\\nmutable struct UniquedById\\n    myid::Int\\n    let counter = 0\\n        UniquedById() = new(counter += 1)\\n    end\\nend\\nwhile the intent of this code was to give every instance a unique id, the counter value is recorded at the end of compilation. All subsequent usages of this incrementally compiled module will start from that same counter value.\\nNote that objectid (which works by hashing the memory pointer) has similar issues (see notes on Dict usage below).\\nOne alternative is to use a macro to capture @__MODULE__ and store it alone with the current counter value, however, it may be better to redesign the code to not depend on this global state.\\nAssociative collections (such as Dict and Set) need to be re-hashed in __init__. (In the future, a mechanism may be provided to register an initializer function.)\\nDepending on compile-time side-effects persisting through load-time. Example include: modifying arrays or other variables in other Julia modules; maintaining handles to open files or devices; storing pointers to other system resources (including memory);\\nCreating accidental \\\"copies\\\" of global state from another module, by referencing it directly instead of via its lookup path. For example, (in global scope):\\n#mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#\\n# instead use accessor functions:\\ngetstdout() = Base.stdout #= best option =#\\n# or move the assignment into the runtime:\\n__init__() = global mystdout = Base.stdout #= also works =#Several additional restrictions are placed on the operations that can be done while precompiling code to help the user avoid other wrong-behavior situations:Calling eval to cause a side-effect in another module. This will also cause a warning to be emitted when the incremental precompile flag is set.\\nglobal const statements from local scope after __init__() has been started (see issue #12010 for plans to add an error for this)\\nReplacing a module is a runtime error while doing an incremental precompile.A few other points to be aware of:No code reload / cache invalidation is performed after changes are made to the source files themselves, (including by [Pkg.update], and no cleanup is done after [Pkg.rm]\\nThe memory sharing behavior of a reshaped array is disregarded by precompilation (each view gets its own copy)\\nExpecting the filesystem to be unchanged between compile-time and runtime e.g. @__FILE__/source_path() to find resources at runtime, or the BinDeps @checked_lib macro. Sometimes this is unavoidable. However, when possible, it can be good practice to copy resources into the module at compile-time so they won\\'t need to be found at runtime.\\nWeakRef objects and finalizers are not currently handled properly by the serializer (this will be fixed in an upcoming release).\\nIt is usually best to avoid capturing references to instances of internal metadata objects such as Method, MethodInstance, MethodTable, TypeMapLevel, TypeMapEntry and fields of those objects, as this can confuse the serializer and may not lead to the outcome you desire. It is not necessarily an error to do this, but you simply need to be prepared that the system will try to copy some of these and to create a single unique instance of others.It is sometimes helpful during module development to turn off incremental precompilation. The command line flag --compiled-modules={yes|no} enables you to toggle module precompilation on and off. When Julia is started with --compiled-modules=no the serialized modules in the compile cache are ignored when loading modules and module dependencies. Base.compilecache can still be called manually. The state of this command line flag is passed to Pkg.build to disable automatic precompilation triggering when installing, updating, and explicitly building packages.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#\",\n    \"page\": \"Documentation\",\n    \"title\": \"Documentation\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Documentation-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Documentation\",\n    \"category\": \"section\",\n    \"text\": \"Julia enables package developers and users to document functions, types and other objects easily via a built-in documentation system since Julia 0.4.The basic syntax is simple: any string appearing at the top-level right before an object (function, macro, type or instance) will be interpreted as documenting it (these are called docstrings). Note that no blank lines or comments may intervene between a docstring and the documented object. Here is a basic example:\\\"Tell whether there are too foo items in the array.\\\"\\nfoo(xs::Array) = ...Documentation is interpreted as Markdown, so you can use indentation and code fences to delimit code examples from text. Technically, any object can be associated with any other as metadata; Markdown happens to be the default, but one can construct other string macros and pass them to the @doc macro just as well.Here is a more complex example, still using Markdown:\\\"\\\"\\\"\\n    bar(x[, y])\\n\\nCompute the Bar index between `x` and `y`. If `y` is missing, compute\\nthe Bar index between all pairs of columns of `x`.\\n\\n# Examples\\n```julia-repl\\njulia> bar([1, 2], [1, 2])\\n1\\n```\\n\\\"\\\"\\\"\\nfunction bar(x, y) ...As in the example above, we recommend following some simple conventions when writing documentation:Always show the signature of a function at the top of the documentation, with a four-space indent so that it is printed as Julia code.\\nThis can be identical to the signature present in the Julia code (like mean(x::AbstractArray)), or a simplified form. Optional arguments should be represented with their default values (i.e. f(x, y=1)) when possible, following the actual Julia syntax. Optional arguments which do not have a default value should be put in brackets (i.e. f(x[, y]) and f(x[, y[, z]])). An alternative solution is to use several lines: one without optional arguments, the other(s) with them. This solution can also be used to document several related methods of a given function. When a function accepts many keyword arguments, only include a <keyword arguments> placeholder in the signature (i.e. f(x; <keyword arguments>)), and give the complete list under an # Arguments section (see point 4 below).\\nInclude a single one-line sentence describing what the function does or what the object represents after the simplified signature block. If needed, provide more details in a second paragraph, after a blank line.\\nThe one-line sentence should use the imperative form (\\\"Do this\\\", \\\"Return that\\\") instead of the third person (do not write \\\"Returns the length...\\\") when documenting functions. It should end with a period. If the meaning of a function cannot be summarized easily, splitting it into separate composable parts could be beneficial (this should not be taken as an absolute requirement for every single case though).\\nDo not repeat yourself.\\nSince the function name is given by the signature, there is no need to start the documentation with \\\"The function bar...\\\": go straight to the point. Similarly, if the signature specifies the types of the arguments, mentioning them in the description is redundant.\\nOnly provide an argument list when really necessary.\\nFor simple functions, it is often clearer to mention the role of the arguments directly in the description of the function\\'s purpose. An argument list would only repeat information already provided elsewhere. However, providing an argument list can be a good idea for complex functions with many arguments (in particular keyword arguments). In that case, insert it after the general description of the function, under an # Arguments header, with one - bullet for each argument. The list should mention the types and default values (if any) of the arguments:\\n\\\"\\\"\\\"\\n...\\n# Arguments\\n- `n::Integer`: the number of elements to compute.\\n- `dim::Integer=1`: the dimensions along which to perform the computation.\\n...\\n\\\"\\\"\\\"\\nProvide hints to related functions.\\nSometimes there are functions of related functionality. To increase discoverability please provide a short list of these in a See also: paragraph.\\nSee also: [`bar!`](@ref), [`baz`](@ref), [`baaz`](@ref)\\nInclude any code examples in an # Examples section.\\nExamples should, whenever possible, be written as doctests. A doctest is a fenced code block (see Code blocks) starting with ```jldoctest and contains any number of julia> prompts together with inputs and expected outputs that mimic the Julia REPL.\\nFor example in the following docstring a variable a is defined and the expected result, as printed in a Julia REPL, appears afterwards:\\n\\\"\\\"\\\"\\nSome nice documentation here.\\n\\n# Examples\\n```jldoctest\\njulia> a = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n```\\n\\\"\\\"\\\"\\nwarning: Warning\\nCalling rand and other RNG-related functions should be avoided in doctests since they will not produce consistent outputs during different Julia sessions. If you would like to show some random number generation related functionality, one option is to explicitly construct and seed your own MersenneTwister (or other pseudorandom number generator) and pass it to the functions you are doctesting.Operating system word size (Int32 or Int64) as well as path separator differences (/ or \\\\) will also affect the reproducibility of some doctests.Note that whitespace in your doctest is significant! The doctest will fail if you misalign the output of pretty-printing an array, for example.\\nYou can then run make -C doc doctest=true to run all the doctests in the Julia Manual and API documentation, which will ensure that your example works.\\nTo indicate that the output result is truncated, you may write [...] at the line where checking should stop. This is useful to hide a stacktrace (which contains non-permanent references to lines of julia code) when the doctest shows that an exception is thrown, for example:\\n```jldoctest\\njulia> div(1, 0)\\nERROR: DivideError: integer division error\\n[...]\\n```\\nExamples that are untestable should be written within fenced code blocks starting with ```julia so that they are highlighted correctly in the generated documentation.\\ntip: Tip\\nWherever possible examples should be self-contained and runnable so that readers are able to try them out without having to include any dependencies.\\nUse backticks to identify code and equations.\\nJulia identifiers and code excerpts should always appear between backticks ` to enable highlighting. Equations in the LaTeX syntax can be inserted between double backticks ``. Use Unicode characters rather than their LaTeX escape sequence, i.e. ``\u03b1 = 1`` rather than ``\\\\\\\\alpha = 1``.\\nPlace the starting and ending \\\"\\\"\\\" characters on lines by themselves.\\nThat is, write:\\n\\\"\\\"\\\"\\n...\\n\\n...\\n\\\"\\\"\\\"\\nf(x, y) = ...\\nrather than:\\n\\\"\\\"\\\"...\\n\\n...\\\"\\\"\\\"\\nf(x, y) = ...\\nThis makes it more clear where docstrings start and end.\\nRespect the line length limit used in the surrounding code.\\nDocstrings are edited using the same tools as code. Therefore, the same conventions should apply. It it advised to add line breaks after 92 characters.\\nProvide information allowing custom types to implement the function in an # Implementation section. These implementation details intended for developers rather than users, explaining e.g. which functions should be overridden and which functions automatically use appropriate fallbacks, are better kept separate from the main description of the function\\'s behavior.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Accessing-Documentation-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Accessing Documentation\",\n    \"category\": \"section\",\n    \"text\": \"Documentation can be accessed at the REPL or in IJulia by typing ? followed by the name of a function or macro, and pressing Enter. For example,?cos\\n?@time\\n?r\\\"\\\"will bring up docs for the relevant function, macro or string macro respectively. In Juno using Ctrl-J, Ctrl-D will bring up documentation for the object under the cursor.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Functions-and-Methods-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Functions & Methods\",\n    \"category\": \"section\",\n    \"text\": \"Functions in Julia may have multiple implementations, known as methods. While it\\'s good practice for generic functions to have a single purpose, Julia allows methods to be documented individually if necessary. In general, only the most generic method should be documented, or even the function itself (i.e. the object created without any methods by function bar end). Specific methods should only be documented if their behaviour differs from the more generic ones. In any case, they should not repeat the information provided elsewhere. For example:\\\"\\\"\\\"\\n    *(x, y, z...)\\n\\nMultiplication operator. `x * y * z *...` calls this function with multiple\\narguments, i.e. `*(x, y, z...)`.\\n\\\"\\\"\\\"\\nfunction *(x, y, z...)\\n    # ... [implementation sold separately] ...\\nend\\n\\n\\\"\\\"\\\"\\n    *(x::AbstractString, y::AbstractString, z::AbstractString...)\\n\\nWhen applied to strings, concatenates them.\\n\\\"\\\"\\\"\\nfunction *(x::AbstractString, y::AbstractString, z::AbstractString...)\\n    # ... [insert secret sauce here] ...\\nend\\n\\nhelp?> *\\nsearch: * .*\\n\\n  *(x, y, z...)\\n\\n  Multiplication operator. x * y * z *... calls this function with multiple\\n  arguments, i.e. *(x,y,z...).\\n\\n  *(x::AbstractString, y::AbstractString, z::AbstractString...)\\n\\n  When applied to strings, concatenates them.When retrieving documentation for a generic function, the metadata for each method is concatenated with the catdoc function, which can of course be overridden for custom types.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Advanced-Usage-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Advanced Usage\",\n    \"category\": \"section\",\n    \"text\": \"The @doc macro associates its first argument with its second in a per-module dictionary called META. By default, documentation is expected to be written in Markdown, and the doc\\\"\\\" string macro simply creates an object representing the Markdown content. In the future it is likely to do more advanced things such as allowing for relative image or link paths.To make it easier to write documentation, the parser treats the macro name @doc specially: if a call to @doc has one argument, but another expression appears after a single line break, then that additional expression is added as an argument to the macro. Therefore the following syntax is parsed as a 2-argument call to @doc:@doc raw\\\"\\\"\\\"\\n...\\n\\\"\\\"\\\"\\nf(x) = xThis makes it easy to use an arbitrary object (here a raw string) as a docstring.When used for retrieving documentation, the @doc macro (or equally, the doc function) will search all META dictionaries for metadata relevant to the given object and return it. The returned object (some Markdown content, for example) will by default display itself intelligently. This design also makes it easy to use the doc system in a programmatic way; for example, to re-use documentation between different versions of a function:@doc \\\"...\\\" foo!\\n@doc (@doc foo!) fooOr for use with Julia\\'s metaprogramming functionality:for (f, op) in ((:add, :+), (:subtract, :-), (:multiply, :*), (:divide, :/))\\n    @eval begin\\n        $f(a,b) = $op(a,b)\\n    end\\nend\\n@doc \\\"`add(a,b)` adds `a` and `b` together\\\" add\\n@doc \\\"`subtract(a,b)` subtracts `b` from `a`\\\" subtractDocumentation written in non-toplevel blocks, such as begin, if, for, and let, is added to the documentation system as blocks are evaluated. For example:if condition()\\n    \\\"...\\\"\\n    f(x) = x\\nendwill add documentation to f(x) when condition() is true. Note that even if f(x) goes out of scope at the end of the block, its documentation will remain.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Dynamic-documentation-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Dynamic documentation\",\n    \"category\": \"section\",\n    \"text\": \"Sometimes the appropriate documentation for an instance of a type depends on the field values of that instance, rather than just on the type itself. In these cases, you can add a method to Docs.getdoc for your custom type that returns the documentation on a per-instance basis. For instance,struct MyType\\n    value::String\\nend\\n\\nDocs.getdoc(t::MyType) = \\\"Documentation for MyType with value $(t.value)\\\"\\n\\nx = MyType(\\\"x\\\")\\ny = MyType(\\\"y\\\")?x will display \\\"Documentation for MyType with value x\\\" while ?y will display \\\"Documentation for MyType with value y\\\".\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Syntax-Guide-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Syntax Guide\",\n    \"category\": \"section\",\n    \"text\": \"A comprehensive overview of all documentable Julia syntax.In the following examples \\\"...\\\" is used to illustrate an arbitrary docstring.doc\\\"\\\" should only be used when the docstring contains $ or \\\\ characters that should not be parsed by Julia such as LaTeX syntax or Julia source code examples containing interpolation.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Functions-and-Methods-2\",\n    \"page\": \"Documentation\",\n    \"title\": \"Functions and Methods\",\n    \"category\": \"section\",\n    \"text\": \"\\\"...\\\"\\nfunction f end\\n\\n\\\"...\\\"\\nfAdds docstring \\\"...\\\" to the function f. The first version is the preferred syntax, however both are equivalent.\\\"...\\\"\\nf(x) = x\\n\\n\\\"...\\\"\\nfunction f(x)\\n    x\\nend\\n\\n\\\"...\\\"\\nf(x)Adds docstring \\\"...\\\" to the method f(::Any).\\\"...\\\"\\nf(x, y = 1) = x + yAdds docstring \\\"...\\\" to two Methods, namely f(::Any) and f(::Any, ::Any).\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Macros-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Macros\",\n    \"category\": \"section\",\n    \"text\": \"\\\"...\\\"\\nmacro m(x) endAdds docstring \\\"...\\\" to the @m(::Any) macro definition.\\\"...\\\"\\n:(@m)Adds docstring \\\"...\\\" to the macro named @m.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Types-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Types\",\n    \"category\": \"section\",\n    \"text\": \"\\\"...\\\"\\nabstract type T1 end\\n\\n\\\"...\\\"\\nmutable struct T2\\n    ...\\nend\\n\\n\\\"...\\\"\\nstruct T3\\n    ...\\nendAdds the docstring \\\"...\\\" to types T1, T2, and T3.\\\"...\\\"\\nstruct T\\n    \\\"x\\\"\\n    x\\n    \\\"y\\\"\\n    y\\nendAdds docstring \\\"...\\\" to type T, \\\"x\\\" to field T.x and \\\"y\\\" to field T.y. Also applicable to mutable struct types.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Modules-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Modules\",\n    \"category\": \"section\",\n    \"text\": \"\\\"...\\\"\\nmodule M end\\n\\nmodule M\\n\\n\\\"...\\\"\\nM\\n\\nendAdds docstring \\\"...\\\" to the ModuleM. Adding the docstring above the Module is the preferred syntax, however both are equivalent.\\\"...\\\"\\nbaremodule M\\n# ...\\nend\\n\\nbaremodule M\\n\\nimport Base: @doc\\n\\n\\\"...\\\"\\nf(x) = x\\n\\nendDocumenting a baremodule by placing a docstring above the expression automatically imports @doc into the module. These imports must be done manually when the module expression is not documented. Empty baremodules cannot be documented.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Global-Variables-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Global Variables\",\n    \"category\": \"section\",\n    \"text\": \"\\\"...\\\"\\nconst a = 1\\n\\n\\\"...\\\"\\nb = 2\\n\\n\\\"...\\\"\\nglobal c = 3Adds docstring \\\"...\\\" to the Bindings a, b, and c.Bindings are used to store a reference to a particular Symbol in a Module without storing the referenced value itself.note: Note\\nWhen a const definition is only used to define an alias of another definition, such as is the case with the function div and its alias \u00f7 in Base, do not document the alias and instead document the actual function.If the alias is documented and not the real definition then the docsystem (? mode) will not return the docstring attached to the alias when the real definition is searched for.For example you should write\\\"...\\\"\\nf(x) = x + 1\\nconst alias = frather thanf(x) = x + 1\\n\\\"...\\\"\\nconst alias = f\\\"...\\\"\\nsymAdds docstring \\\"...\\\" to the value associated with sym. Users should prefer documenting sym at its definition.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Multiple-Objects-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Multiple Objects\",\n    \"category\": \"section\",\n    \"text\": \"\\\"...\\\"\\na, bAdds docstring \\\"...\\\" to a and b each of which should be a documentable expression. This syntax is equivalent to\\\"...\\\"\\na\\n\\n\\\"...\\\"\\nbAny number of expressions many be documented together in this way. This syntax can be useful when two functions are related, such as non-mutating and mutating versions f and f!.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Core.@__doc__\",\n    \"page\": \"Documentation\",\n    \"title\": \"Core.@__doc__\",\n    \"category\": \"macro\",\n    \"text\": \"@__doc__(ex)\\n\\nLow-level macro used to mark expressions returned by a macro that should be documented. If more than one expression is marked then the same docstring is applied to each expression.\\n\\nmacro example(f)\\n    quote\\n        $(f)() = 0\\n        @__doc__ $(f)(x) = 1\\n        $(f)(x, y) = 2\\n    end |> esc\\nend\\n\\n@__doc__ has no effect when a macro that uses it is not documented.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Macro-generated-code-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Macro-generated code\",\n    \"category\": \"section\",\n    \"text\": \"\\\"...\\\"\\n@m expressionAdds docstring \\\"...\\\" to expression generated by expanding @m expression. This allows for expressions decorated with @inline, @noinline, @generated, or any other macro to be documented in the same way as undecorated expressions.Macro authors should take note that only macros that generate a single expression will automatically support docstrings. If a macro returns a block containing multiple subexpressions then the subexpression that should be documented must be marked using the @__doc__ macro.The @enum macro makes use of @__doc__ to allow for documenting Enums. Examining its definition should serve as an example of how to use @__doc__ correctly.Core.@__doc__\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Markdown-syntax-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Markdown syntax\",\n    \"category\": \"section\",\n    \"text\": \"The following markdown syntax is supported in Julia.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Inline-elements-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Inline elements\",\n    \"category\": \"section\",\n    \"text\": \"Here \\\"inline\\\" refers to elements that can be found within blocks of text, i.e. paragraphs. These include the following elements.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Bold-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Bold\",\n    \"category\": \"section\",\n    \"text\": \"Surround words with two asterisks, **, to display the enclosed text in boldface.A paragraph containing a **bold** word.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Italics-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Italics\",\n    \"category\": \"section\",\n    \"text\": \"Surround words with one asterisk, *, to display the enclosed text in italics.A paragraph containing an *emphasised* word.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Literals-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Literals\",\n    \"category\": \"section\",\n    \"text\": \"Surround text that should be displayed exactly as written with single backticks, ` .A paragraph containing a `literal` word.Literals should be used when writing text that refers to names of variables, functions, or other parts of a Julia program.tip: Tip\\nTo include a backtick character within literal text use three backticks rather than one to enclose the text.A paragraph containing a ``` `backtick` character ```.By extension any odd number of backticks may be used to enclose a lesser number of backticks.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#\\\\LaTeX-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"LaTeX\",\n    \"category\": \"section\",\n    \"text\": \"Surround text that should be displayed as mathematics using LaTeX syntax with double backticks, `` .A paragraph containing some ``\\\\LaTeX`` markup.tip: Tip\\nAs with literals in the previous section, if literal backticks need to be written within double backticks use an even number greater than two. Note that if a single literal backtick needs to be included within LaTeX markup then two enclosing backticks is sufficient.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Links-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Links\",\n    \"category\": \"section\",\n    \"text\": \"Links to either external or internal addresses can be written using the following syntax, where the text enclosed in square brackets, [ ], is the name of the link and the text enclosed in parentheses, ( ), is the URL.A paragraph containing a link to [Julia](http://www.julialang.org).It\\'s also possible to add cross-references to other documented functions/methods/variables within the Julia documentation itself. For example:\\\"\\\"\\\"\\n    accumulate!(op, y, x)\\n\\nCumulative operation `op` on a vector `x`, storing the result in `y`. See also [`accumulate`](@ref).\\n\\\"\\\"\\\"This will create a link in the generated docs to the accumulate documentation (which has more information about what this function actually does). It\\'s good to include cross references to mutating/non-mutating versions of a function, or to highlight a difference between two similar-seeming functions.note: Note\\nThe above cross referencing is not a Markdown feature, and relies on Documenter.jl, which is used to build base Julia\\'s documentation.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Footnote-references-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Footnote references\",\n    \"category\": \"section\",\n    \"text\": \"Named and numbered footnote references can be written using the following syntax. A footnote name must be a single alphanumeric word containing no punctuation.A paragraph containing a numbered footnote [^1] and a named one [^named].note: Note\\nThe text associated with a footnote can be written anywhere within the same page as the footnote reference. The syntax used to define the footnote text is discussed in the Footnotes section below.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Toplevel-elements-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Toplevel elements\",\n    \"category\": \"section\",\n    \"text\": \"The following elements can be written either at the \\\"toplevel\\\" of a document or within another \\\"toplevel\\\" element.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Paragraphs-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Paragraphs\",\n    \"category\": \"section\",\n    \"text\": \"A paragraph is a block of plain text, possibly containing any number of inline elements defined in the Inline elements section above, with one or more blank lines above and below it.This is a paragraph.\\n\\nAnd this is *another* one containing some emphasised text.\\nA new line, but still part of the same paragraph.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Headers-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Headers\",\n    \"category\": \"section\",\n    \"text\": \"A document can be split up into different sections using headers. Headers use the following syntax:# Level One\\n## Level Two\\n### Level Three\\n#### Level Four\\n##### Level Five\\n###### Level SixA header line can contain any inline syntax in the same way as a paragraph can.tip: Tip\\nTry to avoid using too many levels of header within a single document. A heavily nested document may be indicative of a need to restructure it or split it into several pages covering separate topics.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Code-blocks-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Code blocks\",\n    \"category\": \"section\",\n    \"text\": \"Source code can be displayed as a literal block using an indent of four spaces as shown in the following example.This is a paragraph.\\n\\n    function func(x)\\n        # ...\\n    end\\n\\nAnother paragraph.Additionally, code blocks can be enclosed using triple backticks with an optional \\\"language\\\" to specify how a block of code should be highlighted.A code block without a \\\"language\\\":\\n\\n```\\nfunction func(x)\\n    # ...\\nend\\n```\\n\\nand another one with the \\\"language\\\" specified as `julia`:\\n\\n```julia\\nfunction func(x)\\n    # ...\\nend\\n```note: Note\\n\\\"Fenced\\\" code blocks, as shown in the last example, should be preferred over indented code blocks since there is no way to specify what language an indented code block is written in.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Block-quotes-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Block quotes\",\n    \"category\": \"section\",\n    \"text\": \"Text from external sources, such as quotations from books or websites, can be quoted using > characters prepended to each line of the quote as follows.Here\\'s a quote:\\n\\n> Julia is a high-level, high-performance dynamic programming language for\\n> technical computing, with syntax that is familiar to users of other\\n> technical computing environments.Note that a single space must appear after the > character on each line. Quoted blocks may themselves contain other toplevel or inline elements.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Images-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Images\",\n    \"category\": \"section\",\n    \"text\": \"The syntax for images is similar to the link syntax mentioned above. Prepending a ! character to a link will display an image from the specified URL rather than a link to it.![alternative text](link/to/image.png)\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Lists-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Lists\",\n    \"category\": \"section\",\n    \"text\": \"Unordered lists can be written by prepending each item in a list with either *, +, or -.A list of items:\\n\\n  * item one\\n  * item two\\n  * item threeNote the two spaces before each * and the single space after each one.Lists can contain other nested toplevel elements such as lists, code blocks, or quoteblocks. A blank line should be left between each list item when including any toplevel elements within a list.Another list:\\n\\n  * item one\\n\\n  * item two\\n\\n    ```\\n    f(x) = x\\n    ```\\n\\n  * And a sublist:\\n\\n      + sub-item one\\n      + sub-item twonote: Note\\nThe contents of each item in the list must line up with the first line of the item. In the above example the fenced code block must be indented by four spaces to align with the i in item two.Ordered lists are written by replacing the \\\"bullet\\\" character, either *, +, or -, with a positive integer followed by either . or ).Two ordered lists:\\n\\n 1. item one\\n 2. item two\\n 3. item three\\n\\n 5) item five\\n 6) item six\\n 7) item sevenAn ordered list may start from a number other than one, as in the second list of the above example, where it is numbered from five. As with unordered lists, ordered lists can contain nested toplevel elements.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Display-equations-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Display equations\",\n    \"category\": \"section\",\n    \"text\": \"Large LaTeX equations that do not fit inline within a paragraph may be written as display equations using a fenced code block with the \\\"language\\\" math as in the example below.```math\\nf(a) = \\\\frac{1}{2\\\\pi}\\\\int_{0}^{2\\\\pi} (\\\\alpha+R\\\\cos(\\\\theta))d\\\\theta\\n```\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Footnotes-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Footnotes\",\n    \"category\": \"section\",\n    \"text\": \"This syntax is paired with the inline syntax for Footnote references. Make sure to read that section as well.Footnote text is defined using the following syntax, which is similar to footnote reference syntax, aside from the : character that is appended to the footnote label.[^1]: Numbered footnote text.\\n\\n[^note]:\\n\\n    Named footnote text containing several toplevel elements.\\n\\n      * item one\\n      * item two\\n      * item three\\n\\n    ```julia\\n    function func(x)\\n        # ...\\n    end\\n    ```note: Note\\nNo checks are done during parsing to make sure that all footnote references have matching footnotes.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Horizontal-rules-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Horizontal rules\",\n    \"category\": \"section\",\n    \"text\": \"The equivalent of an <hr> HTML tag can be written using the following syntax:Text above the line.\\n\\n---\\n\\nAnd text below the line.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Tables-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Tables\",\n    \"category\": \"section\",\n    \"text\": \"Basic tables can be written using the syntax described below. Note that markdown tables have limited features and cannot contain nested toplevel elements unlike other elements discussed above \u2013 only inline elements are allowed. Tables must always contain a header row with column names. Cells cannot span multiple rows or columns of the table.| Column One | Column Two | Column Three |\\n|:---------- | ---------- |:------------:|\\n| Row `1`    | Column `2` |              |\\n| *Row* 2    | **Row** 2  | Column ``3`` |note: Note\\nAs illustrated in the above example each column of | characters must be aligned vertically.A : character on either end of a column\\'s header separator (the row containing - characters) specifies whether the row is left-aligned, right-aligned, or (when : appears on both ends) center-aligned. Providing no : characters will default to right-aligning the column.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Admonitions-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Admonitions\",\n    \"category\": \"section\",\n    \"text\": \"Specially formatted blocks, known as admonitions, can be used to highlight particular remarks. They can be defined using the following !!! syntax:!!! note\\n\\n    This is the content of the note.\\n\\n!!! warning \\\"Beware!\\\"\\n\\n    And this is another one.\\n\\n    This warning admonition has a custom title: `\\\"Beware!\\\"`.The type of the admonition can be any word, but some types produce special styling, namely (in order of decreasing severity): danger, warning, info/note, and tip.A custom title for the box can be provided as a string (in double quotes) after the admonition type. If no title text is specified after the admonition type, then the title used will be the type of the block, i.e. \\\"Note\\\" in the case of the note admonition.Admonitions, like most other toplevel elements, can contain other toplevel elements.\"\n},\n\n{\n    \"location\": \"manual/documentation.html#Markdown-Syntax-Extensions-1\",\n    \"page\": \"Documentation\",\n    \"title\": \"Markdown Syntax Extensions\",\n    \"category\": \"section\",\n    \"text\": \"Julia\\'s markdown supports interpolation in a very similar way to basic string literals, with the difference that it will store the object itself in the Markdown tree (as opposed to converting it to a string). When the Markdown content is rendered the usual show methods will be called, and these can be overridden as usual. This design allows the Markdown to be extended with arbitrarily complex features (such as references) without cluttering the basic syntax.In principle, the Markdown parser itself can also be arbitrarily extended by packages, or an entirely custom flavour of Markdown can be used, but this should generally be unnecessary.\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Metaprogramming\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#Metaprogramming-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Metaprogramming\",\n    \"category\": \"section\",\n    \"text\": \"The strongest legacy of Lisp in the Julia language is its metaprogramming support. Like Lisp, Julia represents its own code as a data structure of the language itself. Since code is represented by objects that can be created and manipulated from within the language, it is possible for a program to transform and generate its own code. This allows sophisticated code generation without extra build steps, and also allows true Lisp-style macros operating at the level of abstract syntax trees. In contrast, preprocessor \\\"macro\\\" systems, like that of C and C++, perform textual manipulation and substitution before any actual parsing or interpretation occurs. Because all data types and code in Julia are represented by Julia data structures, powerful reflection capabilities are available to explore the internals of a program and its types just like any other data.\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#Program-representation-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Program representation\",\n    \"category\": \"section\",\n    \"text\": \"Every Julia program starts life as a string:julia> prog = \\\"1 + 1\\\"\\n\\\"1 + 1\\\"What happens next?The next step is to parse each string into an object called an expression, represented by the Julia type Expr:julia> ex1 = Meta.parse(prog)\\n:(1 + 1)\\n\\njulia> typeof(ex1)\\nExprExpr objects contain two parts:a Symbol identifying the kind of expression. A symbol is an interned string identifier (more discussion below).julia> ex1.head\\n:callthe expression arguments, which may be symbols, other expressions, or literal values:julia> ex1.args\\n3-element Array{Any,1}:\\n  :+\\n 1\\n 1Expressions may also be constructed directly in prefix notation:julia> ex2 = Expr(:call, :+, 1, 1)\\n:(1 + 1)The two expressions constructed above \u2013 by parsing and by direct construction \u2013 are equivalent:julia> ex1 == ex2\\ntrueThe key point here is that Julia code is internally represented as a data structure that is accessible from the language itself.The dump function provides indented and annotated display of Expr objects:julia> dump(ex2)\\nExpr\\n  head: Symbol call\\n  args: Array{Any}((3,))\\n    1: Symbol +\\n    2: Int64 1\\n    3: Int64 1Expr objects may also be nested:julia> ex3 = Meta.parse(\\\"(4 + 4) / 2\\\")\\n:((4 + 4) / 2)Another way to view expressions is with Meta.show_sexpr, which displays the S-expression form of a given Expr, which may look very familiar to users of Lisp. Here\\'s an example illustrating the display on a nested Expr:julia> Meta.show_sexpr(ex3)\\n(:call, :/, (:call, :+, 4, 4), 2)\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#Symbols-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Symbols\",\n    \"category\": \"section\",\n    \"text\": \"The : character has two syntactic purposes in Julia. The first form creates a Symbol, an interned string used as one building-block of expressions:julia> :foo\\n:foo\\n\\njulia> typeof(ans)\\nSymbolThe Symbol constructor takes any number of arguments and creates a new symbol by concatenating their string representations together:julia> :foo == Symbol(\\\"foo\\\")\\ntrue\\n\\njulia> Symbol(\\\"func\\\",10)\\n:func10\\n\\njulia> Symbol(:var,\\'_\\',\\\"sym\\\")\\n:var_symIn the context of an expression, symbols are used to indicate access to variables; when an expression is evaluated, a symbol is replaced with the value bound to that symbol in the appropriate scope.Sometimes extra parentheses around the argument to : are needed to avoid ambiguity in parsing.:julia> :(:)\\n:(:)\\n\\njulia> :(::)\\n:(::)\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#Expressions-and-evaluation-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Expressions and evaluation\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#Quoting-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Quoting\",\n    \"category\": \"section\",\n    \"text\": \"The second syntactic purpose of the : character is to create expression objects without using the explicit Expr constructor. This is referred to as quoting. The : character, followed by paired parentheses around a single statement of Julia code, produces an Expr object based on the enclosed code. Here is example of the short form used to quote an arithmetic expression:julia> ex = :(a+b*c+1)\\n:(a + b * c + 1)\\n\\njulia> typeof(ex)\\nExpr(to view the structure of this expression, try ex.head and ex.args, or use dump as above or Meta.@dump)Note that equivalent expressions may be constructed using Meta.parse or the direct Expr form:julia>      :(a + b*c + 1)       ==\\n       Meta.parse(\\\"a + b*c + 1\\\") ==\\n       Expr(:call, :+, :a, Expr(:call, :*, :b, :c), 1)\\ntrueExpressions provided by the parser generally only have symbols, other expressions, and literal values as their args, whereas expressions constructed by Julia code can have arbitrary run-time values without literal forms as args. In this specific example, + and a are symbols, *(b,c) is a subexpression, and 1 is a literal 64-bit signed integer.There is a second syntactic form of quoting for multiple expressions: blocks of code enclosed in quote ... end.julia> ex = quote\\n           x = 1\\n           y = 2\\n           x + y\\n       end\\nquote\\n    #= none:2 =#\\n    x = 1\\n    #= none:3 =#\\n    y = 2\\n    #= none:4 =#\\n    x + y\\nend\\n\\njulia> typeof(ex)\\nExpr\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#Interpolation-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Interpolation\",\n    \"category\": \"section\",\n    \"text\": \"Direct construction of Expr objects with value arguments is powerful, but Expr constructors can be tedious compared to \\\"normal\\\" Julia syntax. As an alternative, Julia allows interpolation of literals or expressions into quoted expressions. Interpolation is indicated by a prefix $.In this example, the value of variable a is interpolated:julia> a = 1;\\n\\njulia> ex = :($a + b)\\n:(1 + b)Interpolating into an unquoted expression is not supported and will cause a compile-time error:julia> $a + b\\nERROR: syntax: \\\"$\\\" expression outside quoteIn this example, the tuple (1,2,3) is interpolated as an expression into a conditional test:julia> ex = :(a in $:((1,2,3)) )\\n:(a in (1, 2, 3))The use of $ for expression interpolation is intentionally reminiscent of string interpolation and command interpolation. Expression interpolation allows convenient, readable programmatic construction of complex Julia expressions.\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#Splatting-interpolation-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Splatting interpolation\",\n    \"category\": \"section\",\n    \"text\": \"Notice that the $ interpolation syntax allows inserting only a single expression into an enclosing expression. Occasionally, you have an array of expressions and need them all to become arguments of the surrounding expression. This can be done with the syntax $(xs...). For example, the following code generates a function call where the number of arguments is determined programmatically:julia> args = [:x, :y, :z];\\n\\njulia> :(f(1, $(args...)))\\n:(f(1, x, y, z))\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#Nested-quote-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Nested quote\",\n    \"category\": \"section\",\n    \"text\": \"Naturally, it is possible for quote expressions to contain other quote expressions. Understanding how interpolation works in these cases can be a bit tricky. Consider this example:julia> x = :(1 + 2);\\n\\njulia> e = quote quote $x end end\\nquote\\n    #= none:1 =#\\n    $(Expr(:quote, quote\\n    #= none:1 =#\\n    $(Expr(:$, :x))\\nend))\\nendNotice that the result contains Expr(:$, :x), which means that x has not been evaluated yet. In other words, the $ expression \\\"belongs to\\\" the inner quote expression, and so its argument is only evaluated when the inner quote expression is:julia> eval(e)\\nquote\\n    #= none:1 =#\\n    1 + 2\\nendHowever, the outer quote expression is able to interpolate values inside the $ in the inner quote. This is done with multiple $s:julia> e = quote quote $$x end end\\nquote\\n    #= none:1 =#\\n    $(Expr(:quote, quote\\n    #= none:1 =#\\n    $(Expr(:$, :(1 + 2)))\\nend))\\nendNotice that :(1 + 2) now appears in the result instead of the symbol :x. Evaluating this expression yields an interpolated 3:julia> eval(e)\\nquote\\n    #= none:1 =#\\n    3\\nendThe intuition behind this behavior is that x is evaluated once for each $: one $ works similarly to eval(:x), giving x\\'s value, while two $s do the equivalent of eval(eval(:x)).\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#QuoteNode-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"QuoteNode\",\n    \"category\": \"section\",\n    \"text\": \"The usual representation of a quote form in an AST is an Expr with head :quote:julia> dump(Meta.parse(\\\":(1+2)\\\"))\\nExpr\\n  head: Symbol quote\\n  args: Array{Any}((1,))\\n    1: Expr\\n      head: Symbol call\\n      args: Array{Any}((3,))\\n        1: Symbol +\\n        2: Int64 1\\n        3: Int64 2As we have seen, such expressions support interpolation with $. However, in some situations it is necessary to quote code without performing interpolation. This kind of quoting does not yet have syntax, but is represented internally as an object of type QuoteNode. The parser yields QuoteNodes for simple quoted items like symbols:julia> dump(Meta.parse(\\\":x\\\"))\\nQuoteNode\\n  value: Symbol xQuoteNode can also be used for certain advanced metaprogramming tasks.\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#[eval](@ref)-and-effects-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"eval and effects\",\n    \"category\": \"section\",\n    \"text\": \"Given an expression object, one can cause Julia to evaluate (execute) it at global scope using eval:julia> :(1 + 2)\\n:(1 + 2)\\n\\njulia> eval(ans)\\n3\\n\\njulia> ex = :(a + b)\\n:(a + b)\\n\\njulia> eval(ex)\\nERROR: UndefVarError: b not defined\\n[...]\\n\\njulia> a = 1; b = 2;\\n\\njulia> eval(ex)\\n3Every module has its own eval function that evaluates expressions in its global scope. Expressions passed to eval are not limited to returning values \u2013 they can also have side-effects that alter the state of the enclosing module\\'s environment:julia> ex = :(x = 1)\\n:(x = 1)\\n\\njulia> x\\nERROR: UndefVarError: x not defined\\n\\njulia> eval(ex)\\n1\\n\\njulia> x\\n1Here, the evaluation of an expression object causes a value to be assigned to the global variable x.Since expressions are just Expr objects which can be constructed programmatically and then evaluated, it is possible to dynamically generate arbitrary code which can then be run using eval. Here is a simple example:julia> a = 1;\\n\\njulia> ex = Expr(:call, :+, a, :b)\\n:(1 + b)\\n\\njulia> a = 0; b = 2;\\n\\njulia> eval(ex)\\n3The value of a is used to construct the expression ex which applies the + function to the value 1 and the variable b. Note the important distinction between the way a and b are used:The value of the variable a at expression construction time is used as an immediate value in the expression. Thus, the value of a when the expression is evaluated no longer matters: the value in the expression is already 1, independent of whatever the value of a might be.\\nOn the other hand, the symbol :b is used in the expression construction, so the value of the variable b at that time is irrelevant \u2013 :b is just a symbol and the variable b need not even be defined. At expression evaluation time, however, the value of the symbol :b is resolved by looking up the value of the variable b.\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#Functions-on-Expressions-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Functions on Expressions\",\n    \"category\": \"section\",\n    \"text\": \"As hinted above, one extremely useful feature of Julia is the capability to generate and manipulate Julia code within Julia itself. We have already seen one example of a function returning Expr objects: the parse function, which takes a string of Julia code and returns the corresponding Expr. A function can also take one or more Expr objects as arguments, and return another Expr. Here is a simple, motivating example:julia> function math_expr(op, op1, op2)\\n           expr = Expr(:call, op, op1, op2)\\n           return expr\\n       end\\nmath_expr (generic function with 1 method)\\n\\njulia>  ex = math_expr(:+, 1, Expr(:call, :*, 4, 5))\\n:(1 + 4 * 5)\\n\\njulia> eval(ex)\\n21As another example, here is a function that doubles any numeric argument, but leaves expressions alone:julia> function make_expr2(op, opr1, opr2)\\n           opr1f, opr2f = map(x -> isa(x, Number) ? 2*x : x, (opr1, opr2))\\n           retexpr = Expr(:call, op, opr1f, opr2f)\\n           return retexpr\\n       end\\nmake_expr2 (generic function with 1 method)\\n\\njulia> make_expr2(:+, 1, 2)\\n:(2 + 4)\\n\\njulia> ex = make_expr2(:+, 1, Expr(:call, :*, 5, 8))\\n:(2 + 5 * 8)\\n\\njulia> eval(ex)\\n42\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#man-macros-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Macros\",\n    \"category\": \"section\",\n    \"text\": \"Macros provide a method to include generated code in the final body of a program. A macro maps a tuple of arguments to a returned expression, and the resulting expression is compiled directly rather than requiring a runtime eval call. Macro arguments may include expressions, literal values, and symbols.\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#Basics-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Basics\",\n    \"category\": \"section\",\n    \"text\": \"Here is an extraordinarily simple macro:julia> macro sayhello()\\n           return :( println(\\\"Hello, world!\\\") )\\n       end\\n@sayhello (macro with 1 method)Macros have a dedicated character in Julia\\'s syntax: the @ (at-sign), followed by the unique name declared in a macro NAME ... end block. In this example, the compiler will replace all instances of @sayhello with::( println(\\\"Hello, world!\\\") )When @sayhello is entered in the REPL, the expression executes immediately, thus we only see the evaluation result:julia> @sayhello()\\nHello, world!Now, consider a slightly more complex macro:julia> macro sayhello(name)\\n           return :( println(\\\"Hello, \\\", $name) )\\n       end\\n@sayhello (macro with 1 method)This macro takes one argument: name. When @sayhello is encountered, the quoted expression is expanded to interpolate the value of the argument into the final expression:julia> @sayhello(\\\"human\\\")\\nHello, humanWe can view the quoted return expression using the function macroexpand (important note: this is an extremely useful tool for debugging macros):julia> ex = macroexpand(Main, :(@sayhello(\\\"human\\\")) )\\n:((Main.println)(\\\"Hello, \\\", \\\"human\\\"))\\n\\njulia> typeof(ex)\\nExprWe can see that the \\\"human\\\" literal has been interpolated into the expression.There also exists a macro @macroexpand that is perhaps a bit more convenient than the macroexpand function:julia> @macroexpand @sayhello \\\"human\\\"\\n:((println)(\\\"Hello, \\\", \\\"human\\\"))\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#Hold-up:-why-macros?-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Hold up: why macros?\",\n    \"category\": \"section\",\n    \"text\": \"We have already seen a function f(::Expr...) -> Expr in a previous section. In fact, macroexpand is also such a function. So, why do macros exist?Macros are necessary because they execute when code is parsed, therefore, macros allow the programmer to generate and include fragments of customized code before the full program is run. To illustrate the difference, consider the following example:julia> macro twostep(arg)\\n           println(\\\"I execute at parse time. The argument is: \\\", arg)\\n           return :(println(\\\"I execute at runtime. The argument is: \\\", $arg))\\n       end\\n@twostep (macro with 1 method)\\n\\njulia> ex = macroexpand(Main, :(@twostep :(1, 2, 3)) );\\nI execute at parse time. The argument is: $(Expr(:quote, :((1, 2, 3))))The first call to println is executed when macroexpand is called. The resulting expression contains only the second println:julia> typeof(ex)\\nExpr\\n\\njulia> ex\\n:((println)(\\\"I execute at runtime. The argument is: \\\", $(Expr(:copyast, :($(QuoteNode(:((1, 2, 3)))))))))\\n\\njulia> eval(ex)\\nI execute at runtime. The argument is: (1, 2, 3)\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#Macro-invocation-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Macro invocation\",\n    \"category\": \"section\",\n    \"text\": \"Macros are invoked with the following general syntax:@name expr1 expr2 ...\\n@name(expr1, expr2, ...)Note the distinguishing @ before the macro name and the lack of commas between the argument expressions in the first form, and the lack of whitespace after @name in the second form. The two styles should not be mixed. For example, the following syntax is different from the examples above; it passes the tuple (expr1, expr2, ...) as one argument to the macro:@name (expr1, expr2, ...)An alternative way to invoke a macro over an array literal (or comprehension) is to juxtapose both without using parentheses. In this case, the array will be the only expression fed to the macro. The following syntax is equivalent (and different from @name [a b] * v):@name[a b] * v\\n@name([a b]) * vIt is important to emphasize that macros receive their arguments as expressions, literals, or symbols. One way to explore macro arguments is to call the show function within the macro body:julia> macro showarg(x)\\n           show(x)\\n           # ... remainder of macro, returning an expression\\n       end\\n@showarg (macro with 1 method)\\n\\njulia> @showarg(a)\\n:a\\n\\njulia> @showarg(1+1)\\n:(1 + 1)\\n\\njulia> @showarg(println(\\\"Yo!\\\"))\\n:(println(\\\"Yo!\\\"))In addition to the given argument list, every macro is passed extra arguments named __source__ and __module__.The argument __source__ provides information (in the form of a LineNumberNode object) about the parser location of the @ sign from the macro invocation. This allows macros to include better error diagnostic information, and is commonly used by logging, string-parser macros, and docs, for example, as well as to implement the @__LINE__, @__FILE__, and @__DIR__ macros.The location information can be accessed by referencing __source__.line and __source__.file:julia> macro __LOCATION__(); return QuoteNode(__source__); end\\n@__LOCATION__ (macro with 1 method)\\n\\njulia> dump(\\n            @__LOCATION__(\\n       ))\\nLineNumberNode\\n  line: Int64 2\\n  file: Symbol noneThe argument __module__ provides information (in the form of a Module object) about the expansion context of the macro invocation. This allows macros to look up contextual information, such as existing bindings, or to insert the value as an extra argument to a runtime function call doing self-reflection in the current module.\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#Building-an-advanced-macro-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Building an advanced macro\",\n    \"category\": \"section\",\n    \"text\": \"Here is a simplified definition of Julia\\'s @assert macro:julia> macro assert(ex)\\n           return :( $ex ? nothing : throw(AssertionError($(string(ex)))) )\\n       end\\n@assert (macro with 1 method)This macro can be used like this:julia> @assert 1 == 1.0\\n\\njulia> @assert 1 == 0\\nERROR: AssertionError: 1 == 0In place of the written syntax, the macro call is expanded at parse time to its returned result. This is equivalent to writing:1 == 1.0 ? nothing : throw(AssertionError(\\\"1 == 1.0\\\"))\\n1 == 0 ? nothing : throw(AssertionError(\\\"1 == 0\\\"))That is, in the first call, the expression :(1 == 1.0) is spliced into the test condition slot, while the value of string(:(1 == 1.0)) is spliced into the assertion message slot. The entire expression, thus constructed, is placed into the syntax tree where the @assert macro call occurs. Then at execution time, if the test expression evaluates to true, then nothing is returned, whereas if the test is false, an error is raised indicating the asserted expression that was false. Notice that it would not be possible to write this as a function, since only the value of the condition is available and it would be impossible to display the expression that computed it in the error message.The actual definition of @assert in Julia Base is more complicated. It allows the user to optionally specify their own error message, instead of just printing the failed expression. Just like in functions with a variable number of arguments, this is specified with an ellipses following the last argument:julia> macro assert(ex, msgs...)\\n           msg_body = isempty(msgs) ? ex : msgs[1]\\n           msg = string(msg_body)\\n           return :($ex ? nothing : throw(AssertionError($msg)))\\n       end\\n@assert (macro with 1 method)Now @assert has two modes of operation, depending upon the number of arguments it receives! If there\\'s only one argument, the tuple of expressions captured by msgs will be empty and it will behave the same as the simpler definition above. But now if the user specifies a second argument, it is printed in the message body instead of the failing expression. You can inspect the result of a macro expansion with the aptly named @macroexpand macro:julia> @macroexpand @assert a == b\\n:(if Main.a == Main.b\\n        Main.nothing\\n    else\\n        (Main.throw)((Main.AssertionError)(\\\"a == b\\\"))\\n    end)\\n\\njulia> @macroexpand @assert a==b \\\"a should equal b!\\\"\\n:(if Main.a == Main.b\\n        Main.nothing\\n    else\\n        (Main.throw)((Main.AssertionError)(\\\"a should equal b!\\\"))\\n    end)There is yet another case that the actual @assert macro handles: what if, in addition to printing \\\"a should equal b,\\\" we wanted to print their values? One might naively try to use string interpolation in the custom message, e.g., @assert a==b \\\"a ($a) should equal b ($b)!\\\", but this won\\'t work as expected with the above macro. Can you see why? Recall from string interpolation that an interpolated string is rewritten to a call to string. Compare:julia> typeof(:(\\\"a should equal b\\\"))\\nString\\n\\njulia> typeof(:(\\\"a ($a) should equal b ($b)!\\\"))\\nExpr\\n\\njulia> dump(:(\\\"a ($a) should equal b ($b)!\\\"))\\nExpr\\n  head: Symbol string\\n  args: Array{Any}((5,))\\n    1: String \\\"a (\\\"\\n    2: Symbol a\\n    3: String \\\") should equal b (\\\"\\n    4: Symbol b\\n    5: String \\\")!\\\"So now instead of getting a plain string in msg_body, the macro is receiving a full expression that will need to be evaluated in order to display as expected. This can be spliced directly into the returned expression as an argument to the string call; see error.jl for the complete implementation.The @assert macro makes great use of splicing into quoted expressions to simplify the manipulation of expressions inside the macro body.\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#Hygiene-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Hygiene\",\n    \"category\": \"section\",\n    \"text\": \"An issue that arises in more complex macros is that of hygiene. In short, macros must ensure that the variables they introduce in their returned expressions do not accidentally clash with existing variables in the surrounding code they expand into. Conversely, the expressions that are passed into a macro as arguments are often expected to evaluate in the context of the surrounding code, interacting with and modifying the existing variables. Another concern arises from the fact that a macro may be called in a different module from where it was defined. In this case we need to ensure that all global variables are resolved to the correct module. Julia already has a major advantage over languages with textual macro expansion (like C) in that it only needs to consider the returned expression. All the other variables (such as msg in @assert above) follow the normal scoping block behavior.To demonstrate these issues, let us consider writing a @time macro that takes an expression as its argument, records the time, evaluates the expression, records the time again, prints the difference between the before and after times, and then has the value of the expression as its final value. The macro might look like this:macro time(ex)\\n    return quote\\n        local t0 = time()\\n        local val = $ex\\n        local t1 = time()\\n        println(\\\"elapsed time: \\\", t1-t0, \\\" seconds\\\")\\n        val\\n    end\\nendHere, we want t0, t1, and val to be private temporary variables, and we want time to refer to the time function in Julia Base, not to any time variable the user might have (the same applies to println). Imagine the problems that could occur if the user expression ex also contained assignments to a variable called t0, or defined its own time variable. We might get errors, or mysteriously incorrect behavior.Julia\\'s macro expander solves these problems in the following way. First, variables within a macro result are classified as either local or global. A variable is considered local if it is assigned to (and not declared global), declared local, or used as a function argument name. Otherwise, it is considered global. Local variables are then renamed to be unique (using the gensym function, which generates new symbols), and global variables are resolved within the macro definition environment. Therefore both of the above concerns are handled; the macro\\'s locals will not conflict with any user variables, and time and println will refer to the Julia Base definitions.One problem remains however. Consider the following use of this macro:module MyModule\\nimport Base.@time\\n\\ntime() = ... # compute something\\n\\n@time time()\\nendHere the user expression ex is a call to time, but not the same time function that the macro uses. It clearly refers to MyModule.time. Therefore we must arrange for the code in ex to be resolved in the macro call environment. This is done by \\\"escaping\\\" the expression with esc:macro time(ex)\\n    ...\\n    local val = $(esc(ex))\\n    ...\\nendAn expression wrapped in this manner is left alone by the macro expander and simply pasted into the output verbatim. Therefore it will be resolved in the macro call environment.This escaping mechanism can be used to \\\"violate\\\" hygiene when necessary, in order to introduce or manipulate user variables. For example, the following macro sets x to zero in the call environment:julia> macro zerox()\\n           return esc(:(x = 0))\\n       end\\n@zerox (macro with 1 method)\\n\\njulia> function foo()\\n           x = 1\\n           @zerox\\n           return x # is zero\\n       end\\nfoo (generic function with 1 method)\\n\\njulia> foo()\\n0This kind of manipulation of variables should be used judiciously, but is occasionally quite handy.Getting the hygiene rules correct can be a formidable challenge. Before using a macro, you might want to consider whether a function closure would be sufficient. Another useful strategy is to defer as much work as possible to runtime. For example, many macros simply wrap their arguments in a QuoteNode or other similar Expr. Some examples of this include @task body which simply returns schedule(Task(() -> $body)), and @eval expr, which simply returns eval(QuoteNode(expr)).To demonstrate, we might rewrite the @time example above as:macro time(expr)\\n    return :(timeit(() -> $(esc(expr))))\\nend\\nfunction timeit(f)\\n    t0 = time()\\n    val = f()\\n    t1 = time()\\n    println(\\\"elapsed time: \\\", t1-t0, \\\" seconds\\\")\\n    return val\\nendHowever, we don\\'t do this for a good reason: wrapping the expr in a new scope block (the anonymous function) also slightly changes the meaning of the expression (the scope of any variables in it), while we want @time to be usable with minimum impact on the wrapped code.\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#Macros-and-dispatch-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Macros and dispatch\",\n    \"category\": \"section\",\n    \"text\": \"Macros, just like Julia functions, are generic. This means they can also have multiple method definitions, thanks to multiple dispatch:julia> macro m end\\n@m (macro with 0 methods)\\n\\njulia> macro m(args...)\\n           println(\\\"$(length(args)) arguments\\\")\\n       end\\n@m (macro with 1 method)\\n\\njulia> macro m(x,y)\\n           println(\\\"Two arguments\\\")\\n       end\\n@m (macro with 2 methods)\\n\\njulia> @m \\\"asd\\\"\\n1 arguments\\n\\njulia> @m 1 2\\nTwo argumentsHowever one should keep in mind, that macro dispatch is based on the types of AST that are handed to the macro, not the types that the AST evaluates to at runtime:julia> macro m(::Int)\\n           println(\\\"An Integer\\\")\\n       end\\n@m (macro with 3 methods)\\n\\njulia> @m 2\\nAn Integer\\n\\njulia> x = 2\\n2\\n\\njulia> @m x\\n1 arguments\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#Code-Generation-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Code Generation\",\n    \"category\": \"section\",\n    \"text\": \"When a significant amount of repetitive boilerplate code is required, it is common to generate it programmatically to avoid redundancy. In most languages, this requires an extra build step, and a separate program to generate the repetitive code. In Julia, expression interpolation and eval allow such code generation to take place in the normal course of program execution. For example, consider the following custom typestruct MyNumber\\n    x::Float64\\nend\\n# output\\nfor which we want to add a number of methods to. We can do this programmatically in the following loop:for op = (:sin, :cos, :tan, :log, :exp)\\n    eval(quote\\n        Base.$op(a::MyNumber) = MyNumber($op(a.x))\\n    end)\\nend\\n# output\\nand we can now use those functions with our custom type:julia> x = MyNumber(\u03c0)\\nMyNumber(3.141592653589793)\\n\\njulia> sin(x)\\nMyNumber(1.2246467991473532e-16)\\n\\njulia> cos(x)\\nMyNumber(-1.0)In this manner, Julia acts as its own preprocessor, and allows code generation from inside the language. The above code could be written slightly more tersely using the : prefix quoting form:for op = (:sin, :cos, :tan, :log, :exp)\\n    eval(:(Base.$op(a::MyNumber) = MyNumber($op(a.x))))\\nendThis sort of in-language code generation, however, using the eval(quote(...)) pattern, is common enough that Julia comes with a macro to abbreviate this pattern:for op = (:sin, :cos, :tan, :log, :exp)\\n    @eval Base.$op(a::MyNumber) = MyNumber($op(a.x))\\nendThe @eval macro rewrites this call to be precisely equivalent to the above longer versions. For longer blocks of generated code, the expression argument given to @eval can be a block:@eval begin\\n    # multiple lines\\nend\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#Non-Standard-String-Literals-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Non-Standard String Literals\",\n    \"category\": \"section\",\n    \"text\": \"Recall from Strings that string literals prefixed by an identifier are called non-standard string literals, and can have different semantics than un-prefixed string literals. For example:r\\\"^\\\\s*(?:#|$)\\\" produces a regular expression object rather than a string\\nb\\\"DATA\\\\xff\\\\u2200\\\" is a byte array literal for [68,65,84,65,255,226,136,128].Perhaps surprisingly, these behaviors are not hard-coded into the Julia parser or compiler. Instead, they are custom behaviors provided by a general mechanism that anyone can use: prefixed string literals are parsed as calls to specially-named macros. For example, the regular expression macro is just the following:macro r_str(p)\\n    Regex(p)\\nendThat\\'s all. This macro says that the literal contents of the string literal r\\\"^\\\\s*(?:#|$)\\\" should be passed to the @r_str macro and the result of that expansion should be placed in the syntax tree where the string literal occurs. In other words, the expression r\\\"^\\\\s*(?:#|$)\\\" is equivalent to placing the following object directly into the syntax tree:Regex(\\\"^\\\\\\\\s*(?:#|\\\\$)\\\")Not only is the string literal form shorter and far more convenient, but it is also more efficient: since the regular expression is compiled and the Regex object is actually created when the code is compiled, the compilation occurs only once, rather than every time the code is executed. Consider if the regular expression occurs in a loop:for line = lines\\n    m = match(r\\\"^\\\\s*(?:#|$)\\\", line)\\n    if m === nothing\\n        # non-comment\\n    else\\n        # comment\\n    end\\nendSince the regular expression r\\\"^\\\\s*(?:#|$)\\\" is compiled and inserted into the syntax tree when this code is parsed, the expression is only compiled once instead of each time the loop is executed. In order to accomplish this without macros, one would have to write this loop like this:re = Regex(\\\"^\\\\\\\\s*(?:#|\\\\$)\\\")\\nfor line = lines\\n    m = match(re, line)\\n    if m === nothing\\n        # non-comment\\n    else\\n        # comment\\n    end\\nendMoreover, if the compiler could not determine that the regex object was constant over all loops, certain optimizations might not be possible, making this version still less efficient than the more convenient literal form above. Of course, there are still situations where the non-literal form is more convenient: if one needs to interpolate a variable into the regular expression, one must take this more verbose approach; in cases where the regular expression pattern itself is dynamic, potentially changing upon each loop iteration, a new regular expression object must be constructed on each iteration. In the vast majority of use cases, however, regular expressions are not constructed based on run-time data. In this majority of cases, the ability to write regular expressions as compile-time values is invaluable.Like non-standard string literals, non-standard command literals exist using a prefixed variant of the command literal syntax. The command literal custom`literal` is parsed as @custom_cmd \\\"literal\\\". Julia itself does not contain any non-standard command literals, but packages can make use of this syntax. Aside from the different syntax and the _cmd suffix instead of the _str suffix, non-standard command literals behave exactly like non-standard string literals.In the event that two modules provide non-standard string or command literals with the same name, it is possible to qualify the string or command literal with a module name. For instance, if both Foo and Bar provide non-standard string literal @x_str, then one can write Foo.x\\\"literal\\\" or Bar.x\\\"literal\\\" to disambiguate between the two.The mechanism for user-defined string literals is deeply, profoundly powerful. Not only are Julia\\'s non-standard literals implemented using it, but also the command literal syntax (`echo \\\"Hello, $person\\\"`) is implemented with the following innocuous-looking macro:macro cmd(str)\\n    :(cmd_gen($(shell_parse(str)[1])))\\nendOf course, a large amount of complexity is hidden in the functions used in this macro definition, but they are just functions, written entirely in Julia. You can read their source and see precisely what they do \u2013 and all they do is construct expression objects to be inserted into your program\\'s syntax tree.\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#Generated-functions-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Generated functions\",\n    \"category\": \"section\",\n    \"text\": \"A very special macro is @generated, which allows you to define so-called generated functions. These have the capability to generate specialized code depending on the types of their arguments with more flexibility and/or less code than what can be achieved with multiple dispatch. While macros work with expressions at parse time and cannot access the types of their inputs, a generated function gets expanded at a time when the types of the arguments are known, but the function is not yet compiled.Instead of performing some calculation or action, a generated function declaration returns a quoted expression which then forms the body for the method corresponding to the types of the arguments. When a generated function is called, the expression it returns is compiled and then run. To make this efficient, the result is usually cached. And to make this inferable, only a limited subset of the language is usable. Thus, generated functions provide a flexible way to move work from run time to compile time, at the expense of greater restrictions on allowed constructs.When defining generated functions, there are four main differences to ordinary functions:You annotate the function declaration with the @generated macro. This adds some information to the AST that lets the compiler know that this is a generated function.\\nIn the body of the generated function you only have access to the types of the arguments \u2013 not their values \u2013 and any function that was defined before the definition of the generated function.\\nInstead of calculating something or performing some action, you return a quoted expression which, when evaluated, does what you want.\\nGenerated functions must not mutate or observe any non-constant global state (including, for example, IO, locks, non-local dictionaries, or using hasmethod). This means they can only read global constants, and cannot have any side effects. In other words, they must be completely pure. Due to an implementation limitation, this also means that they currently cannot define a closure or generator.It\\'s easiest to illustrate this with an example. We can declare a generated function foo asjulia> @generated function foo(x)\\n           Core.println(x)\\n           return :(x * x)\\n       end\\nfoo (generic function with 1 method)Note that the body returns a quoted expression, namely :(x * x), rather than just the value of x * x.From the caller\\'s perspective, this is identical to a regular function; in fact, you don\\'t have to know whether you\\'re calling a regular or generated function. Let\\'s see how foo behaves:julia> x = foo(2); # note: output is from println() statement in the body\\nInt64\\n\\njulia> x           # now we print x\\n4\\n\\njulia> y = foo(\\\"bar\\\");\\nString\\n\\njulia> y\\n\\\"barbar\\\"So, we see that in the body of the generated function, x is the type of the passed argument, and the value returned by the generated function, is the result of evaluating the quoted expression we returned from the definition, now with the value of x.What happens if we evaluate foo again with a type that we have already used?julia> foo(4)\\n16Note that there is no printout of Int64. We can see that the body of the generated function was only executed once here, for the specific set of argument types, and the result was cached. After that, for this example, the expression returned from the generated function on the first invocation was re-used as the method body. However, the actual caching behavior is an implementation-defined performance optimization, so it is invalid to depend too closely on this behavior.The number of times a generated function is generated might be only once, but it might also be more often, or appear to not happen at all. As a consequence, you should never write a generated function with side effects - when, and how often, the side effects occur is undefined. (This is true for macros too - and just like for macros, the use of eval in a generated function is a sign that you\\'re doing something the wrong way.) However, unlike macros, the runtime system cannot correctly handle a call to eval, so it is disallowed.It is also important to see how @generated functions interact with method redefinition. Following the principle that a correct @generated function must not observe any mutable state or cause any mutation of global state, we see the following behavior. Observe that the generated function cannot call any method that was not defined prior to the definition of the generated function itself.Initially f(x) has one definitionjulia> f(x) = \\\"original definition\\\";Define other operations that use f(x):julia> g(x) = f(x);\\n\\njulia> @generated gen1(x) = f(x);\\n\\njulia> @generated gen2(x) = :(f(x));We now add some new definitions for f(x):julia> f(x::Int) = \\\"definition for Int\\\";\\n\\njulia> f(x::Type{Int}) = \\\"definition for Type{Int}\\\";and compare how these results differ:julia> f(1)\\n\\\"definition for Int\\\"\\n\\njulia> g(1)\\n\\\"definition for Int\\\"\\n\\njulia> gen1(1)\\n\\\"original definition\\\"\\n\\njulia> gen2(1)\\n\\\"definition for Int\\\"Each method of a generated function has its own view of defined functions:julia> @generated gen1(x::Real) = f(x);\\n\\njulia> gen1(1)\\n\\\"definition for Type{Int}\\\"The example generated function foo above did not do anything a normal function foo(x) = x * x could not do (except printing the type on the first invocation, and incurring higher overhead). However, the power of a generated function lies in its ability to compute different quoted expressions depending on the types passed to it:julia> @generated function bar(x)\\n           if x <: Integer\\n               return :(x ^ 2)\\n           else\\n               return :(x)\\n           end\\n       end\\nbar (generic function with 1 method)\\n\\njulia> bar(4)\\n16\\n\\njulia> bar(\\\"baz\\\")\\n\\\"baz\\\"(although of course this contrived example would be more easily implemented using multiple dispatch...)Abusing this will corrupt the runtime system and cause undefined behavior:julia> @generated function baz(x)\\n           if rand() < .9\\n               return :(x^2)\\n           else\\n               return :(\\\"boo!\\\")\\n           end\\n       end\\nbaz (generic function with 1 method)Since the body of the generated function is non-deterministic, its behavior, and the behavior of all subsequent code is undefined.Don\\'t copy these examples!These examples are hopefully helpful to illustrate how generated functions work, both in the definition end and at the call site; however, don\\'t copy them, for the following reasons:the foo function has side-effects (the call to Core.println), and it is undefined exactly when, how often or how many times these side-effects will occur\\nthe bar function solves a problem that is better solved with multiple dispatch - defining bar(x) = x and bar(x::Integer) = x ^ 2 will do the same thing, but it is both simpler and faster.\\nthe baz function is pathologicalNote that the set of operations that should not be attempted in a generated function is unbounded, and the runtime system can currently only detect a subset of the invalid operations. There are many other operations that will simply corrupt the runtime system without notification, usually in subtle ways not obviously connected to the bad definition. Because the function generator is run during inference, it must respect all of the limitations of that code.Some operations that should not be attempted include:Caching of native pointers.\\nInteracting with the contents or methods of Core.Compiler in any way.\\nObserving any mutable state.\\nInference on the generated function may be run at any time, including while your code is attempting to observe or mutate this state.\\nTaking any locks: C code you call out to may use locks internally, (for example, it is not problematic to call malloc, even though most implementations require locks internally) but don\\'t attempt to hold or acquire any while executing Julia code.\\nCalling any function that is defined after the body of the generated function. This condition is relaxed for incrementally-loaded precompiled modules to allow calling any function in the module.Alright, now that we have a better understanding of how generated functions work, let\\'s use them to build some more advanced (and valid) functionality...\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#An-advanced-example-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"An advanced example\",\n    \"category\": \"section\",\n    \"text\": \"Julia\\'s base library has a an internal sub2ind function to calculate a linear index into an n-dimensional array, based on a set of n multilinear indices - in other words, to calculate the index i that can be used to index into an array A using A[i], instead of A[x,y,z,...]. One possible implementation is the following:julia> function sub2ind_loop(dims::NTuple{N}, I::Integer...) where N\\n           ind = I[N] - 1\\n           for i = N-1:-1:1\\n               ind = I[i]-1 + dims[i]*ind\\n           end\\n           return ind + 1\\n       end\\nsub2ind_loop (generic function with 1 method)\\n\\njulia> sub2ind_loop((3, 5), 1, 2)\\n4The same thing can be done using recursion:julia> sub2ind_rec(dims::Tuple{}) = 1;\\n\\njulia> sub2ind_rec(dims::Tuple{}, i1::Integer, I::Integer...) =\\n           i1 == 1 ? sub2ind_rec(dims, I...) : throw(BoundsError());\\n\\njulia> sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer) = i1;\\n\\njulia> sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer, I::Integer...) =\\n           i1 + dims[1] * (sub2ind_rec(Base.tail(dims), I...) - 1);\\n\\njulia> sub2ind_rec((3, 5), 1, 2)\\n4Both these implementations, although different, do essentially the same thing: a runtime loop over the dimensions of the array, collecting the offset in each dimension into the final index.However, all the information we need for the loop is embedded in the type information of the arguments. Thus, we can utilize generated functions to move the iteration to compile-time; in compiler parlance, we use generated functions to manually unroll the loop. The body becomes almost identical, but instead of calculating the linear index, we build up an expression that calculates the index:julia> @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N\\n           ex = :(I[$N] - 1)\\n           for i = (N - 1):-1:1\\n               ex = :(I[$i] - 1 + dims[$i] * $ex)\\n           end\\n           return :($ex + 1)\\n       end\\nsub2ind_gen (generic function with 1 method)\\n\\njulia> sub2ind_gen((3, 5), 1, 2)\\n4What code will this generate?An easy way to find out is to extract the body into another (regular) function:julia> @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N\\n           return sub2ind_gen_impl(dims, I...)\\n       end\\nsub2ind_gen (generic function with 1 method)\\n\\njulia> function sub2ind_gen_impl(dims::Type{T}, I...) where T <: NTuple{N,Any} where N\\n           length(I) == N || return :(error(\\\"partial indexing is unsupported\\\"))\\n           ex = :(I[$N] - 1)\\n           for i = (N - 1):-1:1\\n               ex = :(I[$i] - 1 + dims[$i] * $ex)\\n           end\\n           return :($ex + 1)\\n       end\\nsub2ind_gen_impl (generic function with 1 method)We can now execute sub2ind_gen_impl and examine the expression it returns:julia> sub2ind_gen_impl(Tuple{Int,Int}, Int, Int)\\n:(((I[1] - 1) + dims[1] * (I[2] - 1)) + 1)So, the method body that will be used here doesn\\'t include a loop at all - just indexing into the two tuples, multiplication and addition/subtraction. All the looping is performed compile-time, and we avoid looping during execution entirely. Thus, we only loop once per type, in this case once per N (except in edge cases where the function is generated more than once - see disclaimer above).\"\n},\n\n{\n    \"location\": \"manual/metaprogramming.html#Optionally-generated-functions-1\",\n    \"page\": \"Metaprogramming\",\n    \"title\": \"Optionally-generated functions\",\n    \"category\": \"section\",\n    \"text\": \"Generated functions can achieve high efficiency at run time, but come with a compile time cost: a new function body must be generated for every combination of concrete argument types. Typically, Julia is able to compile \\\"generic\\\" versions of functions that will work for any arguments, but with generated functions this is impossible. This means that programs making heavy use of generated functions might be impossible to statically compile.To solve this problem, the language provides syntax for writing normal, non-generated alternative implementations of generated functions. Applied to the sub2ind example above, it would look like this:function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N\\n    if N != length(I)\\n        throw(ArgumentError(\\\"Number of dimensions must match number of indices.\\\"))\\n    end\\n    if @generated\\n        ex = :(I[$N] - 1)\\n        for i = (N - 1):-1:1\\n            ex = :(I[$i] - 1 + dims[$i] * $ex)\\n        end\\n        return :($ex + 1)\\n    else\\n        ind = I[N] - 1\\n        for i = (N - 1):-1:1\\n            ind = I[i] - 1 + dims[i]*ind\\n        end\\n        return ind + 1\\n    end\\nendInternally, this code creates two implementations of the function: a generated one where the first block in if @generated is used, and a normal one where the else block is used. Inside the then part of the if @generated block, code has the same semantics as other generated functions: argument names refer to types, and the code should return an expression. Multiple if @generated blocks may occur, in which case the generated implementation uses all of the then blocks and the alternate implementation uses all of the else blocks.Notice that we added an error check to the top of the function. This code will be common to both versions, and is run-time code in both versions (it will be quoted and returned as an expression from the generated version). That means that the values and types of local variables are not available at code generation time \u2013- the code-generation code can only see the types of arguments.In this style of definition, the code generation feature is essentially an optional optimization. The compiler will use it if convenient, but otherwise may choose to use the normal implementation instead. This style is preferred, since it allows the compiler to make more decisions and compile programs in more ways, and since normal code is more readable than code-generating code. However, which implementation is used depends on compiler implementation details, so it is essential for the two implementations to behave identically.\"\n},\n\n{\n    \"location\": \"manual/arrays.html#\",\n    \"page\": \"Multi-dimensional Arrays\",\n    \"title\": \"Multi-dimensional Arrays\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/arrays.html#man-multi-dim-arrays-1\",\n    \"page\": \"Multi-dimensional Arrays\",\n    \"title\": \"Multi-dimensional Arrays\",\n    \"category\": \"section\",\n    \"text\": \"Julia, like most technical computing languages, provides a first-class array implementation. Most technical computing languages pay a lot of attention to their array implementation at the expense of other containers. Julia does not treat arrays in any special way. The array library is implemented almost completely in Julia itself, and derives its performance from the compiler, just like any other code written in Julia. As such, it\\'s also possible to define custom array types by inheriting from AbstractArray. See the manual section on the AbstractArray interface for more details on implementing a custom array type.An array is a collection of objects stored in a multi-dimensional grid. In the most general case, an array may contain objects of type Any. For most computational purposes, arrays should contain objects of a more specific type, such as Float64 or Int32.In general, unlike many other technical computing languages, Julia does not expect programs to be written in a vectorized style for performance. Julia\\'s compiler uses type inference and generates optimized code for scalar array indexing, allowing programs to be written in a style that is convenient and readable, without sacrificing performance, and using less memory at times.In Julia, all arguments to functions are passed by sharing (i.e. by pointers). Some technical computing languages pass arrays by value, and while this prevents accidental modification by callees of a value in the caller, it makes avoiding unwanted copying of arrays difficult. By convention, a function name ending with a ! indicates that it will mutate or destroy the value of one or more of its arguments (see, for example, sort and sort!. Callees must make explicit copies to ensure that they don\\'t modify inputs that they don\\'t intend to change. Many non- mutating functions are implemented by calling a function of the same name with an added ! at the end on an explicit copy of the input, and returning that copy.\"\n},\n\n{\n    \"location\": \"manual/arrays.html#Basic-Functions-1\",\n    \"page\": \"Multi-dimensional Arrays\",\n    \"title\": \"Basic Functions\",\n    \"category\": \"section\",\n    \"text\": \"Function Description\\neltype(A) the type of the elements contained in A\\nlength(A) the number of elements in A\\nndims(A) the number of dimensions of A\\nsize(A) a tuple containing the dimensions of A\\nsize(A,n) the size of A along dimension n\\naxes(A) a tuple containing the valid indices of A\\naxes(A,n) a range expressing the valid indices along dimension n\\neachindex(A) an efficient iterator for visiting each position in A\\nstride(A,k) the stride (linear index distance between adjacent elements) along dimension k\\nstrides(A) a tuple of the strides in each dimension\"\n},\n\n{\n    \"location\": \"manual/arrays.html#Construction-and-Initialization-1\",\n    \"page\": \"Multi-dimensional Arrays\",\n    \"title\": \"Construction and Initialization\",\n    \"category\": \"section\",\n    \"text\": \"Many functions for constructing and initializing arrays are provided. In the following list of such functions, calls with a dims... argument can either take a single tuple of dimension sizes or a series of dimension sizes passed as a variable number of arguments. Most of these functions also accept a first input T, which is the element type of the array. If the type T is omitted it will default to Float64.Function Description\\nArray{T}(undef, dims...) an uninitialized dense Array\\nzeros(T, dims...) an Array of all zeros\\nones(T, dims...) an Array of all ones\\ntrues(dims...) a BitArray with all values true\\nfalses(dims...) a BitArray with all values false\\nreshape(A, dims...) an array containing the same data as A, but with different dimensions\\ncopy(A) copy A\\ndeepcopy(A) copy A, recursively copying its elements\\nsimilar(A, T, dims...) an uninitialized array of the same type as A (dense, sparse, etc.), but with the specified element type and dimensions. The second and third arguments are both optional, defaulting to the element type and dimensions of A if omitted.\\nreinterpret(T, A) an array with the same binary data as A, but with element type T\\nrand(T, dims...) an Array with random, iid [1] and uniformly distributed values in the half-open interval 0 1)\\nrandn(T, dims...) an Array with random, iid and standard normally distributed values\\nMatrix{T}(I, m, n) m-by-n identity matrix\\nrange(start, stop=stop, length=n) range of n linearly spaced elements from start to stop\\nfill!(A, x) fill the array A with the value x\\nfill(x, dims...) an Array filled with the value x[1]: iid, independently and identically distributed.The syntax [A, B, C, ...] constructs a 1-d array (vector) of its arguments. If all arguments have a common promotion type then they get converted to that type using convert.To see the various ways we can pass dimensions to these constructors, consider the following examples:julia> zeros(Int8, 2, 2)\\n2\u00d72 Array{Int8,2}:\\n 0  0\\n 0  0\\n\\njulia> zeros(Int8, (2, 2))\\n2\u00d72 Array{Int8,2}:\\n 0  0\\n 0  0\\n\\njulia> zeros((2, 2))\\n2\u00d72 Array{Float64,2}:\\n 0.0  0.0\\n 0.0  0.0Here, (2, 2) is a Tuple.\"\n},\n\n{\n    \"location\": \"manual/arrays.html#Concatenation-1\",\n    \"page\": \"Multi-dimensional Arrays\",\n    \"title\": \"Concatenation\",\n    \"category\": \"section\",\n    \"text\": \"Arrays can be constructed and also concatenated using the following functions:Function Description\\ncat(A...; dims=k) concatenate input arrays along dimension(s) k\\nvcat(A...) shorthand for cat(A...; dims=1)\\nhcat(A...) shorthand for cat(A...; dims=2)Scalar values passed to these functions are treated as 1-element arrays. For example,julia> vcat([1, 2], 3)\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n\\njulia> hcat([1 2], 3)\\n1\u00d73 Array{Int64,2}:\\n 1  2  3The concatenation functions are used so often that they have special syntax:Expression Calls\\n[A; B; C; ...] vcat\\n[A B C ...] hcat\\n[A B; C D; ...] hvcathvcat concatenates in both dimension 1 (with semicolons) and dimension 2 (with spaces). Consider these examples of this syntax:julia> [[1; 2]; [3, 4]]\\n4-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n 4\\n\\njulia> [[1 2] [3 4]]\\n1\u00d74 Array{Int64,2}:\\n 1  2  3  4\\n\\njulia> [[1 2]; [3 4]]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\"\n},\n\n{\n    \"location\": \"manual/arrays.html#Typed-array-initializers-1\",\n    \"page\": \"Multi-dimensional Arrays\",\n    \"title\": \"Typed array initializers\",\n    \"category\": \"section\",\n    \"text\": \"An array with a specific element type can be constructed using the syntax T[A, B, C, ...]. This will construct a 1-d array with element type T, initialized to contain elements A, B, C, etc. For example, Any[x, y, z] constructs a heterogeneous array that can contain any values.Concatenation syntax can similarly be prefixed with a type to specify the element type of the result.julia> [[1 2] [3 4]]\\n1\u00d74 Array{Int64,2}:\\n 1  2  3  4\\n\\njulia> Int8[[1 2] [3 4]]\\n1\u00d74 Array{Int8,2}:\\n 1  2  3  4\"\n},\n\n{\n    \"location\": \"manual/arrays.html#Comprehensions-1\",\n    \"page\": \"Multi-dimensional Arrays\",\n    \"title\": \"Comprehensions\",\n    \"category\": \"section\",\n    \"text\": \"Comprehensions provide a general and powerful way to construct arrays. Comprehension syntax is similar to set construction notation in mathematics:A = [ F(x,y,...) for x=rx, y=ry, ... ]The meaning of this form is that F(x,y,...) is evaluated with the variables x, y, etc. taking on each value in their given list of values. Values can be specified as any iterable object, but will commonly be ranges like 1:n or 2:(n-1), or explicit arrays of values like [1.2, 3.4, 5.7]. The result is an N-d dense array with dimensions that are the concatenation of the dimensions of the variable ranges rx, ry, etc. and each F(x,y,...) evaluation returns a scalar.The following example computes a weighted average of the current element and its left and right neighbor along a 1-d grid. :julia> x = rand(8)\\n8-element Array{Float64,1}:\\n 0.843025\\n 0.869052\\n 0.365105\\n 0.699456\\n 0.977653\\n 0.994953\\n 0.41084\\n 0.809411\\n\\njulia> [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]\\n6-element Array{Float64,1}:\\n 0.736559\\n 0.57468\\n 0.685417\\n 0.912429\\n 0.8446\\n 0.656511The resulting array type depends on the types of the computed elements. In order to control the type explicitly, a type can be prepended to the comprehension. For example, we could have requested the result in single precision by writing:Float32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]\"\n},\n\n{\n    \"location\": \"manual/arrays.html#Generator-Expressions-1\",\n    \"page\": \"Multi-dimensional Arrays\",\n    \"title\": \"Generator Expressions\",\n    \"category\": \"section\",\n    \"text\": \"Comprehensions can also be written without the enclosing square brackets, producing an object known as a generator. This object can be iterated to produce values on demand, instead of allocating an array and storing them in advance (see Iteration). For example, the following expression sums a series without allocating memory:julia> sum(1/n^2 for n=1:1000)\\n1.6439345666815615When writing a generator expression with multiple dimensions inside an argument list, parentheses are needed to separate the generator from subsequent arguments:julia> map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])\\nERROR: syntax: invalid iteration specificationAll comma-separated expressions after for are interpreted as ranges. Adding parentheses lets us add a third argument to map:julia> map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])\\n2\u00d72 Array{Tuple{Float64,Int64},2}:\\n (0.5, 1)       (0.333333, 3)\\n (0.333333, 2)  (0.25, 4)Generators are implemented via inner functions. As in other cases of inner functions in the language, variables from the enclosing scope can be \\\"captured\\\" in the inner function.  For example, sum(p[i] - q[i] for i=1:n) captures the three variables p, q and n from the enclosing scope. Captured variables can present performance challenges described in performance tips.Ranges in generators and comprehensions can depend on previous ranges by writing multiple for keywords:julia> [(i,j) for i=1:3 for j=1:i]\\n6-element Array{Tuple{Int64,Int64},1}:\\n (1, 1)\\n (2, 1)\\n (2, 2)\\n (3, 1)\\n (3, 2)\\n (3, 3)In such cases, the result is always 1-d.Generated values can be filtered using the if keyword:julia> [(i,j) for i=1:3 for j=1:i if i+j == 4]\\n2-element Array{Tuple{Int64,Int64},1}:\\n (2, 2)\\n (3, 1)\"\n},\n\n{\n    \"location\": \"manual/arrays.html#man-array-indexing-1\",\n    \"page\": \"Multi-dimensional Arrays\",\n    \"title\": \"Indexing\",\n    \"category\": \"section\",\n    \"text\": \"The general syntax for indexing into an n-dimensional array A is:X = A[I_1, I_2, ..., I_n]where each I_k may be a scalar integer, an array of integers, or any other supported index. This includes Colon (:) to select all indices within the entire dimension, ranges of the form a:c or a:b:c to select contiguous or strided subsections, and arrays of booleans to select elements at their true indices.If all the indices are scalars, then the result X is a single element from the array A. Otherwise, X is an array with the same number of dimensions as the sum of the dimensionalities of all the indices.If all indices are vectors, for example, then the shape of X would be (length(I_1), length(I_2), ..., length(I_n)), with location (i_1, i_2, ..., i_n) of X containing the value A[I_1[i_1], I_2[i_2], ..., I_n[i_n]].Example:julia> A = reshape(collect(1:16), (2, 2, 2, 2))\\n2\u00d72\u00d72\u00d72 Array{Int64,4}:\\n[:, :, 1, 1] =\\n 1  3\\n 2  4\\n\\n[:, :, 2, 1] =\\n 5  7\\n 6  8\\n\\n[:, :, 1, 2] =\\n  9  11\\n 10  12\\n\\n[:, :, 2, 2] =\\n 13  15\\n 14  16\\n\\njulia> A[1, 2, 1, 1] # all scalar indices\\n3\\n\\njulia> A[[1, 2], [1], [1, 2], [1]] # all vector indices\\n2\u00d71\u00d72\u00d71 Array{Int64,4}:\\n[:, :, 1, 1] =\\n 1\\n 2\\n\\n[:, :, 2, 1] =\\n 5\\n 6\\n\\njulia> A[[1, 2], [1], [1, 2], 1] # a mix of index types\\n2\u00d71\u00d72 Array{Int64,3}:\\n[:, :, 1] =\\n 1\\n 2\\n\\n[:, :, 2] =\\n 5\\n 6Note how the size of the resulting array is different in the last two cases.If I_1 is changed to a two-dimensional matrix, then X becomes an n+1-dimensional array of shape (size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n)). The matrix adds a dimension.Example:julia> A = reshape(collect(1:16), (2, 2, 2, 2));\\n\\njulia> A[[1 2; 1 2]]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 1  2\\n\\njulia> A[[1 2; 1 2], 1, 2, 1]\\n2\u00d72 Array{Int64,2}:\\n 5  6\\n 5  6The location (i_1, i_2, i_3, ..., i_{n+1}) contains the value at A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]. All dimensions indexed with scalars are dropped. For example, the result of A[2, I, 3] is an array with size size(I). Its ith element is populated by A[2, I[i], 3].As a special part of this syntax, the end keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the innermost array being indexed. Indexing syntax without the end keyword is equivalent to a call to getindex:X = getindex(A, I_1, I_2, ..., I_n)Example:julia> x = reshape(1:16, 4, 4)\\n4\u00d74 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:\\n 1  5   9  13\\n 2  6  10  14\\n 3  7  11  15\\n 4  8  12  16\\n\\njulia> x[2:3, 2:end-1]\\n2\u00d72 Array{Int64,2}:\\n 6  10\\n 7  11\\n\\njulia> x[1, [2 3; 4 1]]\\n2\u00d72 Array{Int64,2}:\\n  5  9\\n 13  1Empty ranges of the form n:n-1 are sometimes used to indicate the inter-index location between n-1 and n. For example, the searchsorted function uses this convention to indicate the insertion point of a value not found in a sorted array:julia> a = [1,2,5,6,7];\\n\\njulia> searchsorted(a, 3)\\n3:2\"\n},\n\n{\n    \"location\": \"manual/arrays.html#Assignment-1\",\n    \"page\": \"Multi-dimensional Arrays\",\n    \"title\": \"Assignment\",\n    \"category\": \"section\",\n    \"text\": \"The general syntax for assigning values in an n-dimensional array A is:A[I_1, I_2, ..., I_n] = Xwhere each I_k may be a scalar integer, an array of integers, or any other supported index. This includes Colon (:) to select all indices within the entire dimension, ranges of the form a:c or a:b:c to select contiguous or strided subsections, and arrays of booleans to select elements at their true indices.If X is an array, it must have the same number of elements as the product of the lengths of the indices: prod(length(I_1), length(I_2), ..., length(I_n)). The value in location I_1[i_1], I_2[i_2], ..., I_n[i_n] of A is overwritten with the value X[i_1, i_2, ..., i_n]. If X is not an array, its value is written to all referenced locations of A.Just as in Indexing, the end keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the array being assigned into. Indexed assignment syntax without the end keyword is equivalent to a call to setindex!:setindex!(A, X, I_1, I_2, ..., I_n)Example:julia> x = collect(reshape(1:9, 3, 3))\\n3\u00d73 Array{Int64,2}:\\n 1  4  7\\n 2  5  8\\n 3  6  9\\n\\njulia> x[3, 3] = -9;\\n\\njulia> x[1:2, 1:2] = [-1 -4; -2 -5];\\n\\njulia> x\\n3\u00d73 Array{Int64,2}:\\n -1  -4   7\\n -2  -5   8\\n  3   6  -9\"\n},\n\n{\n    \"location\": \"manual/arrays.html#man-supported-index-types-1\",\n    \"page\": \"Multi-dimensional Arrays\",\n    \"title\": \"Supported index types\",\n    \"category\": \"section\",\n    \"text\": \"In the expression A[I_1, I_2, ..., I_n], each I_k may be a scalar index, an array of scalar indices, or an object that represents an array of scalar indices and can be converted to such by to_indices:A scalar index. By default this includes:\\nNon-boolean integers\\nCartesianIndex{N}s, which behave like an N-tuple of integers spanning multiple dimensions (see below for more details)\\nAn array of scalar indices. This includes:\\nVectors and multidimensional arrays of integers\\nEmpty arrays like [], which select no elements\\nRanges like a:c or a:b:c, which select contiguous or strided subsections from a to c (inclusive)\\nAny custom array of scalar indices that is a subtype of AbstractArray\\nArrays of CartesianIndex{N} (see below for more details)\\nAn object that represents an array of scalar indices and can be converted to such by to_indices. By default this includes:\\nColon() (:), which represents all indices within an entire dimension or across the entire array\\nArrays of booleans, which select elements at their true indices (see below for more details)Some examples:julia> A = reshape(collect(1:2:18), (3, 3))\\n3\u00d73 Array{Int64,2}:\\n 1   7  13\\n 3   9  15\\n 5  11  17\\n\\njulia> A[4]\\n7\\n\\njulia> A[[2, 5, 8]]\\n3-element Array{Int64,1}:\\n  3\\n  9\\n 15\\n\\njulia> A[[1 4; 3 8]]\\n2\u00d72 Array{Int64,2}:\\n 1   7\\n 5  15\\n\\njulia> A[[]]\\n0-element Array{Int64,1}\\n\\njulia> A[1:2:5]\\n3-element Array{Int64,1}:\\n 1\\n 5\\n 9\\n\\njulia> A[2, :]\\n3-element Array{Int64,1}:\\n  3\\n  9\\n 15\\n\\njulia> A[:, 3]\\n3-element Array{Int64,1}:\\n 13\\n 15\\n 17\"\n},\n\n{\n    \"location\": \"manual/arrays.html#Cartesian-indices-1\",\n    \"page\": \"Multi-dimensional Arrays\",\n    \"title\": \"Cartesian indices\",\n    \"category\": \"section\",\n    \"text\": \"The special CartesianIndex{N} object represents a scalar index that behaves like an N-tuple of integers spanning multiple dimensions.  For example:julia> A = reshape(1:32, 4, 4, 2);\\n\\njulia> A[3, 2, 1]\\n7\\n\\njulia> A[CartesianIndex(3, 2, 1)] == A[3, 2, 1] == 7\\ntrueConsidered alone, this may seem relatively trivial; CartesianIndex simply gathers multiple integers together into one object that represents a single multidimensional index. When combined with other indexing forms and iterators that yield CartesianIndexes, however, this can lead directly to very elegant and efficient code. See Iteration below, and for some more advanced examples, see this blog post on multidimensional algorithms and iteration.Arrays of CartesianIndex{N} are also supported. They represent a collection of scalar indices that each span N dimensions, enabling a form of indexing that is sometimes referred to as pointwise indexing. For example, it enables accessing the diagonal elements from the first \\\"page\\\" of A from above:julia> page = A[:,:,1]\\n4\u00d74 Array{Int64,2}:\\n 1  5   9  13\\n 2  6  10  14\\n 3  7  11  15\\n 4  8  12  16\\n\\njulia> page[[CartesianIndex(1,1),\\n             CartesianIndex(2,2),\\n             CartesianIndex(3,3),\\n             CartesianIndex(4,4)]]\\n4-element Array{Int64,1}:\\n  1\\n  6\\n 11\\n 16This can be expressed much more simply with dot broadcasting and by combining it with a normal integer index (instead of extracting the first page from A as a separate step). It can even be combined with a : to extract both diagonals from the two pages at the same time:julia> A[CartesianIndex.(axes(A, 1), axes(A, 2)), 1]\\n4-element Array{Int64,1}:\\n  1\\n  6\\n 11\\n 16\\n\\njulia> A[CartesianIndex.(axes(A, 1), axes(A, 2)), :]\\n4\u00d72 Array{Int64,2}:\\n  1  17\\n  6  22\\n 11  27\\n 16  32warning: Warning\\nCartesianIndex and arrays of CartesianIndex are not compatible with the end keyword to represent the last index of a dimension. Do not use end in indexing expressions that may contain either CartesianIndex or arrays thereof.\"\n},\n\n{\n    \"location\": \"manual/arrays.html#Logical-indexing-1\",\n    \"page\": \"Multi-dimensional Arrays\",\n    \"title\": \"Logical indexing\",\n    \"category\": \"section\",\n    \"text\": \"Often referred to as logical indexing or indexing with a logical mask, indexing by a boolean array selects elements at the indices where its values are true. Indexing by a boolean vector B is effectively the same as indexing by the vector of integers that is returned by findall(B). Similarly, indexing by a N-dimensional boolean array is effectively the same as indexing by the vector of CartesianIndex{N}s where its values are true. A logical index must be a vector of the same length as the dimension it indexes into, or it must be the only index provided and match the size and dimensionality of the array it indexes into. It is generally more efficient to use boolean arrays as indices directly instead of first calling findall.julia> x = reshape(1:16, 4, 4)\\n4\u00d74 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:\\n 1  5   9  13\\n 2  6  10  14\\n 3  7  11  15\\n 4  8  12  16\\n\\njulia> x[[false, true, true, false], :]\\n2\u00d74 Array{Int64,2}:\\n 2  6  10  14\\n 3  7  11  15\\n\\njulia> mask = map(ispow2, x)\\n4\u00d74 Array{Bool,2}:\\n  true  false  false  false\\n  true  false  false  false\\n false  false  false  false\\n  true   true  false   true\\n\\njulia> x[mask]\\n5-element Array{Int64,1}:\\n  1\\n  2\\n  4\\n  8\\n 16\"\n},\n\n{\n    \"location\": \"manual/arrays.html#Iteration-1\",\n    \"page\": \"Multi-dimensional Arrays\",\n    \"title\": \"Iteration\",\n    \"category\": \"section\",\n    \"text\": \"The recommended ways to iterate over a whole array arefor a in A\\n    # Do something with the element a\\nend\\n\\nfor i in eachindex(A)\\n    # Do something with i and/or A[i]\\nendThe first construct is used when you need the value, but not index, of each element. In the second construct, i will be an Int if A is an array type with fast linear indexing; otherwise, it will be a CartesianIndex:julia> A = rand(4,3);\\n\\njulia> B = view(A, 1:3, 2:3);\\n\\njulia> for i in eachindex(B)\\n           @show i\\n       end\\ni = CartesianIndex(1, 1)\\ni = CartesianIndex(2, 1)\\ni = CartesianIndex(3, 1)\\ni = CartesianIndex(1, 2)\\ni = CartesianIndex(2, 2)\\ni = CartesianIndex(3, 2)In contrast with for i = 1:length(A), iterating with eachindex provides an efficient way to iterate over any array type.\"\n},\n\n{\n    \"location\": \"manual/arrays.html#Array-traits-1\",\n    \"page\": \"Multi-dimensional Arrays\",\n    \"title\": \"Array traits\",\n    \"category\": \"section\",\n    \"text\": \"If you write a custom AbstractArray type, you can specify that it has fast linear indexing usingBase.IndexStyle(::Type{<:MyArray}) = IndexLinear()This setting will cause eachindex iteration over a MyArray to use integers. If you don\\'t specify this trait, the default value IndexCartesian() is used.\"\n},\n\n{\n    \"location\": \"manual/arrays.html#Array-and-Vectorized-Operators-and-Functions-1\",\n    \"page\": \"Multi-dimensional Arrays\",\n    \"title\": \"Array and Vectorized Operators and Functions\",\n    \"category\": \"section\",\n    \"text\": \"The following operators are supported for arrays:Unary arithmetic \u2013 -, +\\nBinary arithmetic \u2013 -, +, *, /, \\\\, ^\\nComparison \u2013 ==, !=, \u2248 (isapprox), \u2249Most of the binary arithmetic operators listed above also operate elementwise when one argument is scalar: -, +, and * when either argument is scalar, and / and \\\\ when the denominator is scalar. For example, [1, 2] + 3 == [4, 5] and [6, 4] / 2 == [3, 2].Additionally, to enable convenient vectorization of mathematical and other operations, Julia provides the dot syntax f.(args...), e.g. sin.(x) or min.(x,y), for elementwise operations over arrays or mixtures of arrays and scalars (a Broadcasting operation); these have the additional advantage of \\\"fusing\\\" into a single loop when combined with other dot calls, e.g. sin.(cos.(x)).Also, every binary operator supports a dot version that can be applied to arrays (and combinations of arrays and scalars) in such fused broadcasting operations, e.g. z .== sin.(x .* y).Note that comparisons such as == operate on whole arrays, giving a single boolean answer. Use dot operators like .== for elementwise comparisons. (For comparison operations like <, only the elementwise .< version is applicable to arrays.)Also notice the difference between max.(a,b), which broadcasts max elementwise over a and b, and maximum(a), which finds the largest value within a. The same relationship holds for min.(a,b) and minimum(a).\"\n},\n\n{\n    \"location\": \"manual/arrays.html#Broadcasting-1\",\n    \"page\": \"Multi-dimensional Arrays\",\n    \"title\": \"Broadcasting\",\n    \"category\": \"section\",\n    \"text\": \"It is sometimes useful to perform element-by-element binary operations on arrays of different sizes, such as adding a vector to each column of a matrix. An inefficient way to do this would be to replicate the vector to the size of the matrix:julia> a = rand(2,1); A = rand(2,3);\\n\\njulia> repeat(a,1,3)+A\\n2\u00d73 Array{Float64,2}:\\n 1.20813  1.82068  1.25387\\n 1.56851  1.86401  1.67846This is wasteful when dimensions get large, so Julia offers broadcast, which expands singleton dimensions in array arguments to match the corresponding dimension in the other array without using extra memory, and applies the given function elementwise:julia> broadcast(+, a, A)\\n2\u00d73 Array{Float64,2}:\\n 1.20813  1.82068  1.25387\\n 1.56851  1.86401  1.67846\\n\\njulia> b = rand(1,2)\\n1\u00d72 Array{Float64,2}:\\n 0.867535  0.00457906\\n\\njulia> broadcast(+, a, b)\\n2\u00d72 Array{Float64,2}:\\n 1.71056  0.847604\\n 1.73659  0.873631Dotted operators such as .+ and .* are equivalent to broadcast calls (except that they fuse, as described below). There is also a broadcast! function to specify an explicit destination (which can also be accessed in a fusing fashion by .= assignment). Moreover, f.(args...) is equivalent to broadcast(f, args...), providing a convenient syntax to broadcast any function (dot syntax). Nested \\\"dot calls\\\" f.(...) (including calls to .+ etcetera) automatically fuse into a single broadcast call.Additionally, broadcast is not limited to arrays (see the function documentation), it also handles tuples and treats any argument that is not an array, tuple or Ref (except for Ptr) as a \\\"scalar\\\".julia> convert.(Float32, [1, 2])\\n2-element Array{Float32,1}:\\n 1.0\\n 2.0\\n\\njulia> ceil.((UInt8,), [1.2 3.4; 5.6 6.7])\\n2\u00d72 Array{UInt8,2}:\\n 0x02  0x04\\n 0x06  0x07\\n\\njulia> string.(1:3, \\\". \\\", [\\\"First\\\", \\\"Second\\\", \\\"Third\\\"])\\n3-element Array{String,1}:\\n \\\"1. First\\\"\\n \\\"2. Second\\\"\\n \\\"3. Third\\\"\"\n},\n\n{\n    \"location\": \"manual/arrays.html#Implementation-1\",\n    \"page\": \"Multi-dimensional Arrays\",\n    \"title\": \"Implementation\",\n    \"category\": \"section\",\n    \"text\": \"The base array type in Julia is the abstract type AbstractArray{T,N}. It is parametrized by the number of dimensions N and the element type T. AbstractVector and AbstractMatrix are aliases for the 1-d and 2-d cases. Operations on AbstractArray objects are defined using higher level operators and functions, in a way that is independent of the underlying storage. These operations generally work correctly as a fallback for any specific array implementation.The AbstractArray type includes anything vaguely array-like, and implementations of it might be quite different from conventional arrays. For example, elements might be computed on request rather than stored. However, any concrete AbstractArray{T,N} type should generally implement at least size(A) (returning an Int tuple), getindex(A,i) and getindex(A,i1,...,iN); mutable arrays should also implement setindex!. It is recommended that these operations have nearly constant time complexity, or technically \u00d5(1) complexity, as otherwise some array functions may be unexpectedly slow. Concrete types should also typically provide a similar(A,T=eltype(A),dims=size(A)) method, which is used to allocate a similar array for copy and other out-of-place operations. No matter how an AbstractArray{T,N} is represented internally, T is the type of object returned by integer indexing (A[1, ..., 1], when A is not empty) and N should be the length of the tuple returned by size. For more details on defining custom AbstractArray implementations, see the array interface guide in the interfaces chapter.DenseArray is an abstract subtype of AbstractArray intended to include all arrays where elements are stored contiguously in column-major order (see additional notes in Performance Tips). The Array type is a specific instance of DenseArray  Vector and Matrix are aliases for the 1-d and 2-d cases. Very few operations are implemented specifically for Array beyond those that are required for all AbstractArrayss; much of the array library is implemented in a generic manner that allows all custom arrays to behave similarly.SubArray is a specialization of AbstractArray that performs indexing by sharing memory with the original array rather than by copying it. A SubArray is created with the view function, which is called the same way as getindex (with an array and a series of index arguments). The result of view looks the same as the result of getindex, except the data is left in place. view stores the input index vectors in a SubArray object, which can later be used to index the original array indirectly.  By putting the @views macro in front of an expression or block of code, any array[...] slice in that expression will be converted to create a SubArray view instead.BitArrays are space-efficient \\\"packed\\\" boolean arrays, which store one bit per boolean value. They can be used similarly to Array{Bool} arrays (which store one byte per boolean value), and can be converted to/from the latter via Array(bitarray) and BitArray(array), respectively.A \\\"strided\\\" array is stored in memory with elements laid out in regular offsets such that an instance with a supported isbits element type can be passed to external C and Fortran functions that expect this memory layout. Strided arrays must define a strides(A) method that returns a tuple of \\\"strides\\\" for each dimension; a provided stride(A,k) method accesses the kth element within this tuple. Increasing the index of dimension k by 1 should increase the index i of getindex(A,i) by stride(A,k). If a pointer conversion method Base.unsafe_convert(Ptr{T}, A) is provided, the memory layout must correspond in the same way to these strides. DenseArray is a very specific example of a strided array where the elements are arranged contiguously, thus it provides its subtypes with the approporiate definition of strides. More concrete examples can be found within the interface guide for strided arrays. StridedVector and StridedMatrix are convenient aliases for many of the builtin array types that are considered strided arrays, allowing them to dispatch to select specialized implementations that call highly tuned and optimized BLAS and LAPACK functions using just the pointer and strides.The following example computes the QR decomposition of a small section of a larger array, without creating any temporaries, and by calling the appropriate LAPACK function with the right leading dimension size and stride parameters.julia> a = rand(10, 10)\\n10\u00d710 Array{Float64,2}:\\n 0.517515  0.0348206  0.749042   0.0979679  \u2026  0.75984     0.950481   0.579513\\n 0.901092  0.873479   0.134533   0.0697848     0.0586695   0.193254   0.726898\\n 0.976808  0.0901881  0.208332   0.920358      0.288535    0.705941   0.337137\\n 0.657127  0.0317896  0.772837   0.534457      0.0966037   0.700694   0.675999\\n 0.471777  0.144969   0.0718405  0.0827916     0.527233    0.173132   0.694304\\n 0.160872  0.455168   0.489254   0.827851   \u2026  0.62226     0.0995456  0.946522\\n 0.291857  0.769492   0.68043    0.629461      0.727558    0.910796   0.834837\\n 0.775774  0.700731   0.700177   0.0126213     0.00822304  0.327502   0.955181\\n 0.9715    0.64354    0.848441   0.241474      0.591611    0.792573   0.194357\\n 0.646596  0.575456   0.0995212  0.038517      0.709233    0.477657   0.0507231\\n\\njulia> b = view(a, 2:2:8,2:2:4)\\n4\u00d72 view(::Array{Float64,2}, 2:2:8, 2:2:4) with eltype Float64:\\n 0.873479   0.0697848\\n 0.0317896  0.534457\\n 0.455168   0.827851\\n 0.700731   0.0126213\\n\\njulia> (q, r) = qr(b);\\n\\njulia> q\\n4\u00d74 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:\\n -0.722358    0.227524  -0.247784    -0.604181\\n -0.0262896  -0.575919  -0.804227     0.144377\\n -0.376419   -0.75072    0.540177    -0.0541979\\n -0.579497    0.230151  -0.00552346   0.781782\\n\\njulia> r\\n2\u00d72 Array{Float64,2}:\\n -1.20921  -0.383393\\n  0.0      -0.910506\"\n},\n\n{\n    \"location\": \"manual/missing.html#\",\n    \"page\": \"Missing Values\",\n    \"title\": \"Missing Values\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/missing.html#missing-1\",\n    \"page\": \"Missing Values\",\n    \"title\": \"Missing Values\",\n    \"category\": \"section\",\n    \"text\": \"Julia provides support for representing missing values in the statistical sense, that is for situations where no value is available for a variable in an observation, but a valid value theoretically exists. Missing values are represented via the missing object, which is the singleton instance of the type Missing. missing is equivalent to NULL in SQL and NA in R, and behaves like them in most situations.\"\n},\n\n{\n    \"location\": \"manual/missing.html#Propagation-of-Missing-Values-1\",\n    \"page\": \"Missing Values\",\n    \"title\": \"Propagation of Missing Values\",\n    \"category\": \"section\",\n    \"text\": \"The behavior of missing values follows one basic rule: missing values propagate automatically when passed to standard operators and functions, in particular mathematical functions. Uncertainty about the value of one of the operands induces uncertainty about the result. In practice, this means an operation involving a missing value generally returns missingjulia> missing + 1\\nmissing\\n\\njulia> \\\"a\\\" * missing\\nmissing\\n\\njulia> abs(missing)\\nmissingAs missing is a normal Julia object, this propagation rule only works for functions which have opted in to implement this behavior. This can be achieved either via a specific method defined for arguments of type Missing, or simply by accepting arguments of this type, and passing them to functions which propagate them (like standard operators). Packages should consider whether it makes sense to propagate missing values when defining new functions, and define methods appropriately if that is the case. Passing a missing value to a function for which no method accepting arguments of type Missing is defined throws a MethodError, just like for any other type.\"\n},\n\n{\n    \"location\": \"manual/missing.html#Equality-and-Comparison-Operators-1\",\n    \"page\": \"Missing Values\",\n    \"title\": \"Equality and Comparison Operators\",\n    \"category\": \"section\",\n    \"text\": \"Standard equality and comparison operators follow the propagation rule presented above: if any of the operands is missing, the result is missing. Here are a few examplesjulia> missing == 1\\nmissing\\n\\njulia> missing == missing\\nmissing\\n\\njulia> missing < 1\\nmissing\\n\\njulia> 2 >= missing\\nmissingIn particular, note that missing == missing returns missing, so == cannot be used to test whether a value is missing. To test whether x is missing, use ismissing(x).Special comparison operators isequal and === are exceptions to the propagation rule: they always return a Bool value, even in the presence of missing values, considering missing as equal to missing and as different from any other value. They can therefore be used to test whether a value is missingjulia> missing === 1\\nfalse\\n\\njulia> isequal(missing, 1)\\nfalse\\n\\njulia> missing === missing\\ntrue\\n\\njulia> isequal(missing, missing)\\ntrueThe isless operator is another exception: missing is considered as greater than any other value. This operator is used by sort, which therefore places missing values after all other values.julia> isless(1, missing)\\ntrue\\n\\njulia> isless(missing, Inf)\\nfalse\\n\\njulia> isless(missing, missing)\\nfalse\"\n},\n\n{\n    \"location\": \"manual/missing.html#Logical-operators-1\",\n    \"page\": \"Missing Values\",\n    \"title\": \"Logical operators\",\n    \"category\": \"section\",\n    \"text\": \"Logical (or boolean) operators |, & and xor are another special case, as they only propagate missing values when it is logically required. For these operators, whether or not the result is uncertain depends on the particular operation, following the well-established rules of three-valued logic which are also implemented by NULL in SQL and NA in R. This abstract definition actually corresponds to a relatively natural behavior which is best explained via concrete examples.Let us illustrate this principle with the logical \\\"or\\\" operator |. Following the rules of boolean logic, if one of the operands is true, the value of the other operand does not have an influence on the result, which will always be truejulia> true | true\\ntrue\\n\\njulia> true | false\\ntrue\\n\\njulia> false | true\\ntrueBased on this observation, we can conclude that if one of the operands is true and the other missing, we know that the result is true in spite of the uncertainty about the actual value of one of the operands. If we had been able to observe the actual value of the second operand, it could only be true or false, and in both cases the result would be true. Therefore, in this particular case, missingness does not propagatejulia> true | missing\\ntrue\\n\\njulia> missing | true\\ntrueOn the contrary, if one of the operands is false, the result could be either true or false depending on the value of the other operand. Therefore, if that operand is missing, the result has to be missing toojulia> false | true\\ntrue\\n\\njulia> true | false\\ntrue\\n\\njulia> false | false\\nfalse\\n\\njulia> false | missing\\nmissing\\n\\njulia> missing | false\\nmissingThe behavior of the logical \\\"and\\\" operator & is similar to that of the | operator, with the difference that missingness does not propagate when one of the operands is false. For example, when that is the case of the first operandjulia> false & false\\nfalse\\n\\njulia> false & true\\nfalse\\n\\njulia> false & missing\\nfalseOn the other hand, missingness propagates when one of the operands is true, for example the first onejulia> true & true\\ntrue\\n\\njulia> true & false\\nfalse\\n\\njulia> true & missing\\nmissingFinally, the \\\"exclusive or\\\" logical operator xor always propagates missing values, since both operands always have an effect on the result. Also note that the negation operator ! returns missing when the operand is missing just like other unary operators.\"\n},\n\n{\n    \"location\": \"manual/missing.html#Control-Flow-and-Short-Circuiting-Operators-1\",\n    \"page\": \"Missing Values\",\n    \"title\": \"Control Flow and Short-Circuiting Operators\",\n    \"category\": \"section\",\n    \"text\": \"Control flow operators including if, while and the ternary operator x ? y : z do not allow for missing values. This is because of the uncertainty about whether the actual value would be true or false if we could observe it, which implies that we do not know how the program should behave. A TypeError is thrown as soon as a missing value is encountered in this contextjulia> if missing\\n           println(\\\"here\\\")\\n       end\\nERROR: TypeError: non-boolean (Missing) used in boolean contextFor the same reason, contrary to logical operators presented above, the short-circuiting boolean operators && and || do not allow for missing values in situations where the value of the operand determines whether the next operand is evaluated or not. For examplejulia> missing || false\\nERROR: TypeError: non-boolean (Missing) used in boolean context\\n\\njulia> missing && false\\nERROR: TypeError: non-boolean (Missing) used in boolean context\\n\\njulia> true && missing && false\\nERROR: TypeError: non-boolean (Missing) used in boolean contextOn the other hand, no error is thrown when the result can be determined without the missing values. This is the case when the code short-circuits before evaluating the missing operand, and when the missing operand is the last onejulia> true && missing\\nmissing\\n\\njulia> false && missing\\nfalse\"\n},\n\n{\n    \"location\": \"manual/missing.html#Arrays-With-Missing-Values-1\",\n    \"page\": \"Missing Values\",\n    \"title\": \"Arrays With Missing Values\",\n    \"category\": \"section\",\n    \"text\": \"Arrays containing missing values can be created like other arraysjulia> [1, missing]\\n2-element Array{Union{Missing, Int64},1}:\\n 1\\n  missingAs this example shows, the element type of such arrays is Union{Missing, T}, with T the type of the non-missing values. This simply reflects the fact that array entries can be either of type T (here, Int64) or of type Missing. This kind of array uses an efficient memory storage equivalent to an Array{T} holding the actual values combined with an Array{UInt8} indicating the type of the entry (i.e. whether it is Missing or T).Arrays allowing for missing values can be constructed with the standard syntax. Use Array{Union{Missing, T}}(missing, dims) to create arrays filled with missing values:julia> Array{Union{Missing, String}}(missing, 2, 3)\\n2\u00d73 Array{Union{Missing, String},2}:\\n missing  missing  missing\\n missing  missing  missingAn array allowing for missing values but which does not contain any such value can be converted back to an array which does not allow for missing values using convert. If the array contains missing values, a MethodError is thrown during conversionjulia> x = Union{Missing, String}[\\\"a\\\", \\\"b\\\"]\\n2-element Array{Union{Missing, String},1}:\\n \\\"a\\\"\\n \\\"b\\\"\\n\\njulia> convert(Array{String}, x)\\n2-element Array{String,1}:\\n \\\"a\\\"\\n \\\"b\\\"\\n\\njulia> y = Union{Missing, String}[missing, \\\"b\\\"]\\n2-element Array{Union{Missing, String},1}:\\n missing\\n \\\"b\\\"\\n\\njulia> convert(Array{String}, y)\\nERROR: MethodError: Cannot `convert` an object of type Missing to an object of type String\"\n},\n\n{\n    \"location\": \"manual/missing.html#Skipping-Missing-Values-1\",\n    \"page\": \"Missing Values\",\n    \"title\": \"Skipping Missing Values\",\n    \"category\": \"section\",\n    \"text\": \"Since missing values propagate with standard mathematical operators, reduction functions return missing when called on arrays which contain missing valuesjulia> sum([1, missing])\\nmissingIn this situation, use the skipmissing function to skip missing valuesjulia> sum(skipmissing([1, missing]))\\n1This convenience function returns an iterator which filters out missing values efficiently. It can therefore be used with any function which supports iteratorsjulia> maximum(skipmissing([3, missing, 2, 1]))\\n3\\n\\njulia> mean(skipmissing([3, missing, 2, 1]))\\n2.0\\n\\njulia> mapreduce(sqrt, +, skipmissing([3, missing, 2, 1]))\\n4.146264369941973Use collect to extract non-missing values and store them in an arrayjulia> collect(skipmissing([3, missing, 2, 1]))\\n3-element Array{Int64,1}:\\n 3\\n 2\\n 1\"\n},\n\n{\n    \"location\": \"manual/missing.html#Logical-Operations-on-Arrays-1\",\n    \"page\": \"Missing Values\",\n    \"title\": \"Logical Operations on Arrays\",\n    \"category\": \"section\",\n    \"text\": \"The three-valued logic described above for logical operators is also used by logical functions applied to arrays. Thus, array equality tests using the == operator return missing whenever the result cannot be determined without knowing the actual value of the missing entry. In practice, this means that missing is returned if all non-missing values of the compared arrays are equal, but one or both arrays contain missing values (possibly at different positions)julia> [1, missing] == [2, missing]\\nfalse\\n\\njulia> [1, missing] == [1, missing]\\nmissing\\n\\njulia> [1, 2, missing] == [1, missing, 2]\\nmissingAs for single values, use isequal to treat missing values as equal to other missing values but different from non-missing valuesjulia> isequal([1, missing], [1, missing])\\ntrue\\n\\njulia> isequal([1, 2, missing], [1, missing, 2])\\nfalseFunctions any and all also follow the rules of three-valued logic, returning missing when the result cannot be determinedjulia> all([true, missing])\\nmissing\\n\\njulia> all([false, missing])\\nfalse\\n\\njulia> any([true, missing])\\ntrue\\n\\njulia> any([false, missing])\\nmissing\"\n},\n\n{\n    \"location\": \"manual/networking-and-streams.html#\",\n    \"page\": \"Networking and Streams\",\n    \"title\": \"Networking and Streams\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/networking-and-streams.html#Networking-and-Streams-1\",\n    \"page\": \"Networking and Streams\",\n    \"title\": \"Networking and Streams\",\n    \"category\": \"section\",\n    \"text\": \"Julia provides a rich interface to deal with streaming I/O objects such as terminals, pipes and TCP sockets. This interface, though asynchronous at the system level, is presented in a synchronous manner to the programmer and it is usually unnecessary to think about the underlying asynchronous operation. This is achieved by making heavy use of Julia cooperative threading (coroutine) functionality.\"\n},\n\n{\n    \"location\": \"manual/networking-and-streams.html#Basic-Stream-I/O-1\",\n    \"page\": \"Networking and Streams\",\n    \"title\": \"Basic Stream I/O\",\n    \"category\": \"section\",\n    \"text\": \"All Julia streams expose at least a read and a write method, taking the stream as their first argument, e.g.:julia> write(stdout, \\\"Hello World\\\");  # suppress return value 11 with ;\\nHello World\\njulia> read(stdin, Char)\\n\\n\\'\\\\n\\': ASCII/Unicode U+000a (category Cc: Other, control)Note that write returns 11, the number of bytes (in \\\"Hello World\\\") written to stdout, but this return value is suppressed with the ;.Here Enter was pressed again so that Julia would read the newline. Now, as you can see from this example, write takes the data to write as its second argument, while read takes the type of the data to be read as the second argument.For example, to read a simple byte array, we could do:julia> x = zeros(UInt8, 4)\\n4-element Array{UInt8,1}:\\n 0x00\\n 0x00\\n 0x00\\n 0x00\\n\\njulia> read!(stdin, x)\\nabcd\\n4-element Array{UInt8,1}:\\n 0x61\\n 0x62\\n 0x63\\n 0x64However, since this is slightly cumbersome, there are several convenience methods provided. For example, we could have written the above as:julia> read(stdin, 4)\\nabcd\\n4-element Array{UInt8,1}:\\n 0x61\\n 0x62\\n 0x63\\n 0x64or if we had wanted to read the entire line instead:julia> readline(stdin)\\nabcd\\n\\\"abcd\\\"Note that depending on your terminal settings, your TTY may be line buffered and might thus require an additional enter before the data is sent to Julia.To read every line from stdin you can use eachline:for line in eachline(stdin)\\n    print(\\\"Found $line\\\")\\nendor read if you wanted to read by character instead:while !eof(stdin)\\n    x = read(stdin, Char)\\n    println(\\\"Found: $x\\\")\\nend\"\n},\n\n{\n    \"location\": \"manual/networking-and-streams.html#Text-I/O-1\",\n    \"page\": \"Networking and Streams\",\n    \"title\": \"Text I/O\",\n    \"category\": \"section\",\n    \"text\": \"Note that the write method mentioned above operates on binary streams. In particular, values do not get converted to any canonical text representation but are written out as is:julia> write(stdout, 0x61);  # suppress return value 1 with ;\\naNote that a is written to stdout by the write function and that the returned value is 1 (since 0x61 is one byte).For text I/O, use the print or show methods, depending on your needs (see the documentation for these two methods for a detailed discussion of the difference between them):julia> print(stdout, 0x61)\\n97See Custom pretty-printing for more information on how to implement display methods for custom types.\"\n},\n\n{\n    \"location\": \"manual/networking-and-streams.html#IO-Output-Contextual-Properties-1\",\n    \"page\": \"Networking and Streams\",\n    \"title\": \"IO Output Contextual Properties\",\n    \"category\": \"section\",\n    \"text\": \"Sometimes IO output can benefit from the ability to pass contextual information into show methods. The IOContext object provides this framework for associating arbitrary metadata with an IO object. For example, :compact => true adds a hinting parameter to the IO object that the invoked show method should print a shorter output (if applicable). See the IOContext documentation for a list of common properties.\"\n},\n\n{\n    \"location\": \"manual/networking-and-streams.html#Working-with-Files-1\",\n    \"page\": \"Networking and Streams\",\n    \"title\": \"Working with Files\",\n    \"category\": \"section\",\n    \"text\": \"Like many other environments, Julia has an open function, which takes a filename and returns an IOStream object that you can use to read and write things from the file. For example, if we have a file, hello.txt, whose contents are Hello, World!:julia> f = open(\\\"hello.txt\\\")\\nIOStream(<file hello.txt>)\\n\\njulia> readlines(f)\\n1-element Array{String,1}:\\n \\\"Hello, World!\\\"If you want to write to a file, you can open it with the write (\\\"w\\\") flag:julia> f = open(\\\"hello.txt\\\",\\\"w\\\")\\nIOStream(<file hello.txt>)\\n\\njulia> write(f,\\\"Hello again.\\\")\\n12If you examine the contents of hello.txt at this point, you will notice that it is empty; nothing has actually been written to disk yet. This is because the IOStream must be closed before the write is actually flushed to disk:julia> close(f)Examining hello.txt again will show its contents have been changed.Opening a file, doing something to its contents, and closing it again is a very common pattern. To make this easier, there exists another invocation of open which takes a function as its first argument and filename as its second, opens the file, calls the function with the file as an argument, and then closes it again. For example, given a function:function read_and_capitalize(f::IOStream)\\n    return uppercase(read(f, String))\\nendYou can call:julia> open(read_and_capitalize, \\\"hello.txt\\\")\\n\\\"HELLO AGAIN.\\\"to open hello.txt, call read_and_capitalize on it, close hello.txt and return the capitalized contents.To avoid even having to define a named function, you can use the do syntax, which creates an anonymous function on the fly:julia> open(\\\"hello.txt\\\") do f\\n           uppercase(read(f, String))\\n       end\\n\\\"HELLO AGAIN.\\\"\"\n},\n\n{\n    \"location\": \"manual/networking-and-streams.html#A-simple-TCP-example-1\",\n    \"page\": \"Networking and Streams\",\n    \"title\": \"A simple TCP example\",\n    \"category\": \"section\",\n    \"text\": \"Let\\'s jump right in with a simple example involving TCP sockets. This functionality is in a standard library package called Sockets. Let\\'s first create a simple server:julia> using Sockets\\n\\njulia> @async begin\\n           server = listen(2000)\\n           while true\\n               sock = accept(server)\\n               println(\\\"Hello World\\\\n\\\")\\n           end\\n       end\\nTask (runnable) @0x00007fd31dc11ae0To those familiar with the Unix socket API, the method names will feel familiar, though their usage is somewhat simpler than the raw Unix socket API. The first call to listen will create a server waiting for incoming connections on the specified port (2000) in this case. The same function may also be used to create various other kinds of servers:julia> listen(2000) # Listens on localhost:2000 (IPv4)\\nBase.TCPServer(active)\\n\\njulia> listen(ip\\\"127.0.0.1\\\",2000) # Equivalent to the first\\nBase.TCPServer(active)\\n\\njulia> listen(ip\\\"::1\\\",2000) # Listens on localhost:2000 (IPv6)\\nBase.TCPServer(active)\\n\\njulia> listen(IPv4(0),2001) # Listens on port 2001 on all IPv4 interfaces\\nBase.TCPServer(active)\\n\\njulia> listen(IPv6(0),2001) # Listens on port 2001 on all IPv6 interfaces\\nBase.TCPServer(active)\\n\\njulia> listen(\\\"testsocket\\\") # Listens on a UNIX domain socket\\nBase.PipeServer(active)\\n\\njulia> listen(\\\"\\\\\\\\\\\\\\\\.\\\\\\\\pipe\\\\\\\\testsocket\\\") # Listens on a Windows named pipe\\nBase.PipeServer(active)Note that the return type of the last invocation is different. This is because this server does not listen on TCP, but rather on a named pipe (Windows) or UNIX domain socket. Also note that Windows named pipe format has to be a specific pattern such that the name prefix (\\\\\\\\.\\\\pipe\\\\) uniquely identifies the file type. The difference between TCP and named pipes or UNIX domain sockets is subtle and has to do with the accept and connect methods. The accept method retrieves a connection to the client that is connecting on the server we just created, while the connect function connects to a server using the specified method. The connect function takes the same arguments as listen, so, assuming the environment (i.e. host, cwd, etc.) is the same you should be able to pass the same arguments to connect as you did to listen to establish the connection. So let\\'s try that out (after having created the server above):julia> connect(2000)\\nTCPSocket(open, 0 bytes waiting)\\n\\njulia> Hello WorldAs expected we saw \\\"Hello World\\\" printed. So, let\\'s actually analyze what happened behind the scenes. When we called connect, we connect to the server we had just created. Meanwhile, the accept function returns a server-side connection to the newly created socket and prints \\\"Hello World\\\" to indicate that the connection was successful.A great strength of Julia is that since the API is exposed synchronously even though the I/O is actually happening asynchronously, we didn\\'t have to worry about callbacks or even making sure that the server gets to run. When we called connect the current task waited for the connection to be established and only continued executing after that was done. In this pause, the server task resumed execution (because a connection request was now available), accepted the connection, printed the message and waited for the next client. Reading and writing works in the same way. To see this, consider the following simple echo server:julia> @async begin\\n           server = listen(2001)\\n           while true\\n               sock = accept(server)\\n               @async while isopen(sock)\\n                   write(sock, readline(sock, keep=true))\\n               end\\n           end\\n       end\\nTask (runnable) @0x00007fd31dc12e60\\n\\njulia> clientside = connect(2001)\\nTCPSocket(RawFD(28) open, 0 bytes waiting)\\n\\njulia> @async while isopen(clientside)\\n           write(stdout, readline(clientside, keep=true))\\n       end\\nTask (runnable) @0x00007fd31dc11870\\n\\njulia> println(clientside,\\\"Hello World from the Echo Server\\\")\\nHello World from the Echo ServerAs with other streams, use close to disconnect the socket:julia> close(clientside)\"\n},\n\n{\n    \"location\": \"manual/networking-and-streams.html#Resolving-IP-Addresses-1\",\n    \"page\": \"Networking and Streams\",\n    \"title\": \"Resolving IP Addresses\",\n    \"category\": \"section\",\n    \"text\": \"One of the connect methods that does not follow the listen methods is connect(host::String,port), which will attempt to connect to the host given by the host parameter on the port given by the port parameter. It allows you to do things like:julia> connect(\\\"google.com\\\", 80)\\nTCPSocket(RawFD(30) open, 0 bytes waiting)At the base of this functionality is getaddrinfo, which will do the appropriate address resolution:julia> getaddrinfo(\\\"google.com\\\")\\nip\\\"74.125.226.225\\\"\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Parallel Computing\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Parallel-Computing-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Parallel Computing\",\n    \"category\": \"section\",\n    \"text\": \"For newcomers to multi-threading and parallel computing it can be useful to first appreciate the different levels of parallelism offered by Julia. We can divide them in three main categories :Julia Coroutines (Green Threading)\\nMulti-Threading\\nMulti-Core or Distributed ProcessingWe will first consider Julia Tasks (aka Coroutines) and other modules that rely on the Julia runtime library, that allow to suspend and resume computations with full control of inter-Tasks communication without having to manually interface with the operative system\\'s scheduler. Julia also allows to communicate between Tasks through operations like wait and fetch. Communication and data synchronization is managed through Channels, which are the conduit that allows inter-Tasks communication.Julia also supports experimental multi-threading, where execution is forked and an anonymous function is run across all threads. Described as a fork-join approach, parallel threads are branched off and they all have to join the Julia main thread to make serial execution continue. Multi-threading is supported using the Base.Threads module that is still considered experimental, as Julia is not fully thread-safe yet. In particular segfaults seem to emerge for I\\\\O operations and task switching. As an un up-to-date reference, keep an eye on the issue tracker. Multi-Threading should only be used if you take into consideration global variables, locks and atomics, so we will explain it later.In the end we will present Julia\\'s way to distributed and parallel computing. With scientific computing in mind, Julia natively implements interfaces to distribute a process through multiple cores or machines. Also we will mention useful external packages for distributed programming like MPI.jl and DistributedArrays.jl.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Coroutines-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Coroutines\",\n    \"category\": \"section\",\n    \"text\": \"Julia\\'s parallel programming platform uses Tasks (aka Coroutines) to switch among multiple computations. To express an order of execution between lightweight threads communication primitives are necessary. Julia offers Channel(func::Function, ctype=Any, csize=0, taskref=nothing) that creates a new task from func, binds it to a new channel of type ctype and size csize and schedule the task. Channels can serve as a way to communicate between tasks, as Channel{T}(sz::Int) creates a buffered channel of type T and size sz. Whenever code performs a communication operation like fetch or wait, the current task is suspended and a scheduler picks another task to run. A task is restarted when the event it is waiting for completes.For many problems, it is not necessary to think about tasks directly. However, they can be used to wait for multiple events at the same time, which provides for dynamic scheduling. In dynamic scheduling, a program decides what to compute or where to compute it based on when other jobs finish. This is needed for unpredictable or unbalanced workloads, where we want to assign more work to processes only when they finish their current tasks.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Channels-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Channels\",\n    \"category\": \"section\",\n    \"text\": \"The section on Tasks in Control Flow discussed the execution of multiple functions in a co-operative manner. Channels can be quite useful to pass data between running tasks, particularly those involving I/O operations.Examples of operations involving I/O include reading/writing to files, accessing web services, executing external programs, etc. In all these cases, overall execution time can be improved if other tasks can be run while a file is being read, or while waiting for an external service/program to complete.A channel can be visualized as a pipe, i.e., it has a write end and a read end :Multiple writers in different tasks can write to the same channel concurrently via put! calls.\\nMultiple readers in different tasks can read data concurrently via take! calls.\\nAs an example:\\n# Given Channels c1 and c2,\\nc1 = Channel(32)\\nc2 = Channel(32)\\n\\n# and a function `foo` which reads items from from c1, processes the item read\\n# and writes a result to c2,\\nfunction foo()\\n    while true\\n        data = take!(c1)\\n        [...]               # process data\\n        put!(c2, result)    # write out result\\n    end\\nend\\n\\n# we can schedule `n` instances of `foo` to be active concurrently.\\nfor _ in 1:n\\n    @schedule foo()\\nend\\nChannels are created via the Channel{T}(sz) constructor. The channel will only hold objectsof type T. If the type is not specified, the channel can hold objects of any type. sz refers   to the maximum number of elements that can be held in the channel at any time. For example, Channel(32)   creates a channel that can hold a maximum of 32 objects of any type. A Channel{MyType}(64) can   hold up to 64 objects of MyType at any time.If a Channel is empty, readers (on a take! call) will block until data is available.\\nIf a Channel is full, writers (on a put! call) will block until space becomes available.\\nisready tests for the presence of any object in the channel, while wait waits for an object to become available.\\nA Channel is in an open state initially. This means that it can be read from and written to freely via take! and put! calls. close closes a Channel. On a closed Channel, put! will fail. For example:julia> c = Channel(2);\\n\\njulia> put!(c, 1) # `put!` on an open channel succeeds\\n1\\n\\njulia> close(c);\\n\\njulia> put!(c, 2) # `put!` on a closed channel throws an exception.\\nERROR: InvalidStateException(\\\"Channel is closed.\\\",:closed)\\nStacktrace:\\n[...]take! and fetch (which retrieves but does not remove the value) on a closed channel successfully return any existing values until it is emptied. Continuing the above example:julia> fetch(c) # Any number of `fetch` calls succeed.\\n1\\n\\njulia> fetch(c)\\n1\\n\\njulia> take!(c) # The first `take!` removes the value.\\n1\\n\\njulia> take!(c) # No more data available on a closed channel.\\nERROR: InvalidStateException(\\\"Channel is closed.\\\",:closed)\\nStacktrace:\\n[...]A Channel can be used as an iterable object in a for loop, in which case the loop runs as long as the Channel has data or is open. The loop variable takes on all values added to the Channel. The for loop is terminated once the Channel is closed and emptied.For example, the following would cause the for loop to wait for more data:julia> c = Channel{Int}(10);\\n\\njulia> foreach(i->put!(c, i), 1:3) # add a few entries\\n\\njulia> data = [i for i in c]while this will return after reading all data:julia> c = Channel{Int}(10);\\n\\njulia> foreach(i->put!(c, i), 1:3); # add a few entries\\n\\njulia> close(c);                    # `for` loops can exit\\n\\njulia> data = [i for i in c]\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3Consider a simple example using channels for inter-task communication. We start 4 tasks to process data from a single jobs channel. Jobs, identified by an id (job_id), are written to the channel. Each task in this simulation reads a job_id, waits for a random amout of time and writes back a tuple of job_id and the simulated time to the results channel. Finally all the results are printed out.julia> const jobs = Channel{Int}(32);\\n\\njulia> const results = Channel{Tuple}(32);\\n\\njulia> function do_work()\\n           for job_id in jobs\\n               exec_time = rand()\\n               sleep(exec_time)                # simulates elapsed time doing actual work\\n                                               # typically performed externally.\\n               put!(results, (job_id, exec_time))\\n           end\\n       end;\\n\\njulia> function make_jobs(n)\\n           for i in 1:n\\n               put!(jobs, i)\\n           end\\n       end;\\n\\njulia> n = 12;\\n\\njulia> @schedule make_jobs(n); # feed the jobs channel with \\\"n\\\" jobs\\n\\njulia> for i in 1:4 # start 4 tasks to process requests in parallel\\n           @schedule do_work()\\n       end\\n\\njulia> @elapsed while n > 0 # print out results\\n           job_id, exec_time = take!(results)\\n           println(\\\"$job_id finished in $(round(exec_time,2)) seconds\\\")\\n           n = n - 1\\n       end\\n4 finished in 0.22 seconds\\n3 finished in 0.45 seconds\\n1 finished in 0.5 seconds\\n7 finished in 0.14 seconds\\n2 finished in 0.78 seconds\\n5 finished in 0.9 seconds\\n9 finished in 0.36 seconds\\n6 finished in 0.87 seconds\\n8 finished in 0.79 seconds\\n10 finished in 0.64 seconds\\n12 finished in 0.5 seconds\\n11 finished in 0.97 seconds\\n0.029772311The current version of Julia multiplexes all tasks onto a single OS thread. Thus, while tasks involving I/O operations benefit from parallel execution, compute bound tasks are effectively executed sequentially on a single OS thread. Future versions of Julia may support scheduling of tasks on multiple threads, in which case compute bound tasks will see benefits of parallel execution too.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Multi-Threading-(Experimental)-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Multi-Threading (Experimental)\",\n    \"category\": \"section\",\n    \"text\": \"In addition to tasks Julia forwards natively supports multi-threading. Note that this section is experimental and the interfaces may change in the future.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Setup-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Setup\",\n    \"category\": \"section\",\n    \"text\": \"By default, Julia starts up with a single thread of execution. This can be verified by using the command Threads.nthreads():julia> Threads.nthreads()\\n1The number of threads Julia starts up with is controlled by an environment variable called JULIA_NUM_THREADS. Now, let\\'s start up Julia with 4 threads:export JULIA_NUM_THREADS=4(The above command works on bourne shells on Linux and OSX. Note that if you\\'re using a C shell on these platforms, you should use the keyword set instead of export. If you\\'re on Windows, start up the command line in the location of julia.exe and use set instead of export.)Let\\'s verify there are 4 threads at our disposal.julia> Threads.nthreads()\\n4But we are currently on the master thread. To check, we use the function Threads.threadidjulia> Threads.threadid()\\n1\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#The-@threads-Macro-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"The @threads Macro\",\n    \"category\": \"section\",\n    \"text\": \"Let\\'s work a simple example using our native threads. Let us create an array of zeros:julia> a = zeros(10)\\n10-element Array{Float64,1}:\\n 0.0\\n 0.0\\n 0.0\\n 0.0\\n 0.0\\n 0.0\\n 0.0\\n 0.0\\n 0.0\\n 0.0Let us operate on this array simultaneously using 4 threads. We\\'ll have each thread write its thread ID into each location.Julia supports parallel loops using the Threads.@threads macro. This macro is affixed in front of a for loop to indicate to Julia that the loop is a multi-threaded region:julia> Threads.@threads for i = 1:10\\n           a[i] = Threads.threadid()\\n       endThe iteration space is split amongst the threads, after which each thread writes its thread ID to its assigned locations:julia> a\\n10-element Array{Float64,1}:\\n 1.0\\n 1.0\\n 1.0\\n 2.0\\n 2.0\\n 2.0\\n 3.0\\n 3.0\\n 4.0\\n 4.0Note that Threads.@threads does not have an optional reduction parameter like @distributed.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Atomic-Operations-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Atomic Operations\",\n    \"category\": \"section\",\n    \"text\": \"Julia supports accessing and modifying values atomically, that is, in a thread-safe way to avoid race conditions. A value (which must be of a primitive type) can be wrapped as Threads.Atomic to indicate it must be accessed in this way. Here we can see an example:julia> i = Threads.Atomic{Int}(0);\\n\\njulia> ids = zeros(4);\\n\\njulia> old_is = zeros(4);\\n\\njulia> Threads.@threads for id in 1:4\\n           old_is[id] = Threads.atomic_add!(i, id)\\n           ids[id] = id\\n       end\\n\\njulia> old_is\\n4-element Array{Float64,1}:\\n 0.0\\n 1.0\\n 7.0\\n 3.0\\n\\njulia> ids\\n4-element Array{Float64,1}:\\n 1.0\\n 2.0\\n 3.0\\n 4.0Had we tried to do the addition without the atomic tag, we might have gotten the wrong answer due to a race condition. An example of what would happen if we didn\\'t avoid the race:julia> using Base.Threads\\n\\njulia> nthreads()\\n4\\n\\njulia> acc = Ref(0)\\nBase.RefValue{Int64}(0)\\n\\njulia> @threads for i in 1:1000\\n          acc[] += 1\\n       end\\n\\njulia> acc[]\\n926\\n\\njulia> acc = Atomic{Int64}(0)\\nAtomic{Int64}(0)\\n\\njulia> @threads for i in 1:1000\\n          atomic_add!(acc, 1)\\n       end\\n\\njulia> acc[]\\n1000note: Note\\nNot all primitive types can be wrapped in an Atomic tag. Supported types are Int8, Int16, Int32, Int64, Int128, UInt8, UInt16, UInt32, UInt64, UInt128, Float16, Float32, and Float64. Additionally, Int128 and UInt128 are not supported on AAarch32 and ppc64le.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Side-effects-and-mutable-function-arguments-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Side effects and mutable function arguments\",\n    \"category\": \"section\",\n    \"text\": \"When using multi-threading we have to be careful when using functions that are not pure as we might get a wrong answer. For instance functions that have their name ending with ! by convention modify their arguments and thus are not pure. However, there are functions that have side effects and their name does not end with !. For instance findfirst(regex, str) mutates its regex argument or rand() changes Base.GLOBAL_RNG :julia> using Base.Threads\\n\\njulia> nthreads()\\n4\\n\\njulia> function f()\\n           s = repeat([\\\"123\\\", \\\"213\\\", \\\"231\\\"], outer=1000)\\n           x = similar(s, Int)\\n           rx = r\\\"1\\\"\\n           @threads for i in 1:3000\\n               x[i] = findfirst(rx, s[i]).start\\n           end\\n           count(v -> v == 1, x)\\n       end\\nf (generic function with 1 method)\\n\\njulia> f() # the correct result is 1000\\n1017\\n\\njulia> function g()\\n           a = zeros(1000)\\n           @threads for i in 1:1000\\n               a[i] = rand()\\n           end\\n           length(unique(a))\\n       end\\ng (generic function with 1 method)\\n\\njulia> Random.seed!(1); g() # the result for a single thread is 1000\\n781In such cases one should redesign the code to avoid the possibility of a race condition or use synchronization primitives.For example in order to fix findfirst example above one needs to have a separate copy of rx variable for each thread:julia> function f_fix()\\n             s = repeat([\\\"123\\\", \\\"213\\\", \\\"231\\\"], outer=1000)\\n             x = similar(s, Int)\\n             rx = [Regex(\\\"1\\\") for i in 1:nthreads()]\\n             @threads for i in 1:3000\\n                 x[i] = findfirst(rx[threadid()], s[i]).start\\n             end\\n             count(v -> v == 1, x)\\n         end\\nf_fix (generic function with 1 method)\\n\\njulia> f_fix()\\n1000We now use Regex(\\\"1\\\") instead of r\\\"1\\\" to make sure that Julia creates separate instances of Regex object for each entry of rx vector.The case of rand is a bit more complex as we have to ensure that each thread uses non-overlapping pseudorandom number sequences. This can be simply ensured by using Future.randjump function:julia> using Random; import Future\\n\\njulia> function g_fix(r)\\n           a = zeros(1000)\\n           @threads for i in 1:1000\\n               a[i] = rand(r[threadid()])\\n           end\\n           length(unique(a))\\n       end\\ng_fix (generic function with 1 method)\\n\\njulia>  r = let m = MersenneTwister(1)\\n                [m; accumulate(Future.randjump, m, fill(big(10)^20, nthreads()-1))]\\n            end;\\n\\njulia> g_fix(r)\\n1000We pass the r vector to g_fix as generating several RGNs is an expensive operation so we do not want to repeat it every time we run the function.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#@threadcall-(Experimental)-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"@threadcall (Experimental)\",\n    \"category\": \"section\",\n    \"text\": \"All I/O tasks, timers, REPL commands, etc are multiplexed onto a single OS thread via an event loop. A patched version of libuv (http://docs.libuv.org/en/v1.x/) provides this functionality. Yield points provide for co-operatively scheduling multiple tasks onto the same OS thread. I/O tasks and timers yield implicitly while waiting for the event to occur. Calling yield explicitly allows for other tasks to be scheduled.Thus, a task executing a ccall effectively prevents the Julia scheduler from executing any other tasks till the call returns. This is true for all calls into external libraries. Exceptions are calls into custom C code that call back into Julia (which may then yield) or C code that calls jl_yield() (C equivalent of yield).Note that while Julia code runs on a single thread (by default), libraries used by Julia may launch their own internal threads. For example, the BLAS library may start as many threads as there are cores on a machine.The @threadcall macro addresses scenarios where we do not want a ccall to block the main Julia event loop. It schedules a C function for execution in a separate thread. A threadpool with a default size of 4 is used for this. The size of the threadpool is controlled via environment variable UV_THREADPOOL_SIZE. While waiting for a free thread, and during function execution once a thread is available, the requesting task (on the main Julia event loop) yields to other tasks. Note that @threadcall does not return till the execution is complete. From a user point of view, it is therefore a blocking call like other Julia APIs.It is very important that the called function does not call back into Julia, as it will segfault.@threadcall may be removed/changed in future versions of Julia.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Multi-Core-or-Distributed-Processing-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Multi-Core or Distributed Processing\",\n    \"category\": \"section\",\n    \"text\": \"An implementation of distributed memory parallel computing is provided by module Distributed as part of the standard library shipped with Julia.Most modern computers possess more than one CPU, and several computers can be combined together in a cluster. Harnessing the power of these multiple CPUs allows many computations to be completed more quickly. There are two major factors that influence performance: the speed of the CPUs themselves, and the speed of their access to memory. In a cluster, it\\'s fairly obvious that a given CPU will have fastest access to the RAM within the same computer (node). Perhaps more surprisingly, similar issues are relevant on a typical multicore laptop, due to differences in the speed of main memory and the cache. Consequently, a good multiprocessing environment should allow control over the \\\"ownership\\\" of a chunk of memory by a particular CPU. Julia provides a multiprocessing environment based on message passing to allow programs to run on multiple processes in separate memory domains at once.Julia\\'s implementation of message passing is different from other environments such as MPI [1]. Communication in Julia is generally \\\"one-sided\\\", meaning that the programmer needs to explicitly manage only one process in a two-process operation. Furthermore, these operations typically do not look like \\\"message send\\\" and \\\"message receive\\\" but rather resemble higher-level operations like calls to user functions.Distributed programming in Julia is built on two primitives: remote references and remote calls. A remote reference is an object that can be used from any process to refer to an object stored on a particular process. A remote call is a request by one process to call a certain function on certain arguments on another (possibly the same) process.Remote references come in two flavors: Future and RemoteChannel.A remote call returns a Future to its result. Remote calls return immediately; the process that made the call proceeds to its next operation while the remote call happens somewhere else. You can wait for a remote call to finish by calling wait on the returned Future, and you can obtain the full value of the result using fetch.On the other hand, RemoteChannel s are rewritable. For example, multiple processes can co-ordinate their processing by referencing the same remote Channel.Each process has an associated identifier. The process providing the interactive Julia prompt always has an id equal to 1. The processes used by default for parallel operations are referred to as \\\"workers\\\". When there is only one process, process 1 is considered a worker. Otherwise, workers are considered to be all processes other than process 1.Let\\'s try this out. Starting with julia -p n provides n worker processes on the local machine. Generally it makes sense for n to equal the number of CPU threads (logical cores) on the machine. Note that the -p argument implicitly loads module Distributed.$ ./julia -p 2\\n\\njulia> r = remotecall(rand, 2, 2, 2)\\nFuture(2, 1, 4, nothing)\\n\\njulia> s = @spawnat 2 1 .+ fetch(r)\\nFuture(2, 1, 5, nothing)\\n\\njulia> fetch(s)\\n2\u00d72 Array{Float64,2}:\\n 1.18526  1.50912\\n 1.16296  1.60607The first argument to remotecall is the function to call. Most parallel programming in Julia does not reference specific processes or the number of processes available, but remotecall is considered a low-level interface providing finer control. The second argument to remotecall is the id of the process that will do the work, and the remaining arguments will be passed to the function being called.As you can see, in the first line we asked process 2 to construct a 2-by-2 random matrix, and in the second line we asked it to add 1 to it. The result of both calculations is available in the two futures, r and s. The @spawnat macro evaluates the expression in the second argument on the process specified by the first argument.Occasionally you might want a remotely-computed value immediately. This typically happens when you read from a remote object to obtain data needed by the next local operation. The function remotecall_fetch exists for this purpose. It is equivalent to fetch(remotecall(...)) but is more efficient.julia> remotecall_fetch(getindex, 2, r, 1, 1)\\n0.18526337335308085Remember that getindex(r,1,1) is equivalent to r[1,1], so this call fetches the first element of the future r.The syntax of remotecall is not especially convenient. The macro @spawn makes things easier. It operates on an expression rather than a function, and picks where to do the operation for you:julia> r = @spawn rand(2,2)\\nFuture(2, 1, 4, nothing)\\n\\njulia> s = @spawn 1 .+ fetch(r)\\nFuture(3, 1, 5, nothing)\\n\\njulia> fetch(s)\\n2\u00d72 Array{Float64,2}:\\n 1.38854  1.9098\\n 1.20939  1.57158Note that we used 1 .+ fetch(r) instead of 1 .+ r. This is because we do not know where the code will run, so in general a fetch might be required to move r to the process doing the addition. In this case, @spawn is smart enough to perform the computation on the process that owns r, so the fetch will be a no-op (no work is done).(It is worth noting that @spawn is not built-in but defined in Julia as a macro. It is possible to define your own such constructs.)An important thing to remember is that, once fetched, a Future will cache its value locally. Further fetch calls do not entail a network hop. Once all referencing Futures have fetched, the remote stored value is deleted.@async is similar to @spawn, but only runs tasks on the local process. We use it to create a \\\"feeder\\\" task for each process. Each task picks the next index that needs to be computed, then waits for its process to finish, then repeats until we run out of indices. Note that the feeder tasks do not begin to execute until the main task reaches the end of the @sync block, at which point it surrenders control and waits for all the local tasks to complete before returning from the function. As for v0.7 and beyond, the feeder tasks are able to share state via nextidx because they all run on the same process. Even if Tasks are scheduled cooperatively, locking may still be required in some contexts, as in asynchronous I\\\\O. This means context switches only occur at well-defined points: in this case, when remotecall_fetch is called. This is the current state of implementation (dev v0.7) and it may change for future Julia versions, as it is intended to make it possible to run up to N Tasks on M Process, aka M:N Threading. Then a lock acquiring\\\\releasing model for nextidx will be needed, as it is not safe to let multiple processes read-write a resource at the same time.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Code-Availability-and-Loading-Packages-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Code Availability and Loading Packages\",\n    \"category\": \"section\",\n    \"text\": \"Your code must be available on any process that runs it. For example, type the following into the Julia prompt:julia> function rand2(dims...)\\n           return 2*rand(dims...)\\n       end\\n\\njulia> rand2(2,2)\\n2\u00d72 Array{Float64,2}:\\n 0.153756  0.368514\\n 1.15119   0.918912\\n\\njulia> fetch(@spawn rand2(2,2))\\nERROR: RemoteException(2, CapturedException(UndefVarError(Symbol(\\\"#rand2\\\"))\\nStacktrace:\\n[...]Process 1 knew about the function rand2, but process 2 did not.Most commonly you\\'ll be loading code from files or packages, and you have a considerable amount of flexibility in controlling which processes load code. Consider a file, DummyModule.jl, containing the following code:module DummyModule\\n\\nexport MyType, f\\n\\nmutable struct MyType\\n    a::Int\\nend\\n\\nf(x) = x^2+1\\n\\nprintln(\\\"loaded\\\")\\n\\nendIn order to refer to MyType across all processes, DummyModule.jl needs to be loaded on every process.  Calling include(\\\"DummyModule.jl\\\") loads it only on a single process.  To load it on every process, use the @everywhere macro (starting Julia with julia -p 2):julia> @everywhere include(\\\"DummyModule.jl\\\")\\nloaded\\n      From worker 3:    loaded\\n      From worker 2:    loadedAs usual, this does not bring DummyModule into scope on any of the process, which requires using or import.  Moreover, when DummyModule is brought into scope on one process, it is not on any other:julia> using .DummyModule\\n\\njulia> MyType(7)\\nMyType(7)\\n\\njulia> fetch(@spawnat 2 MyType(7))\\nERROR: On worker 2:\\nUndefVarError: MyType not defined\\n\u22ee\\n\\njulia> fetch(@spawnat 2 DummyModule.MyType(7))\\nMyType(7)However, it\\'s still possible, for instance, to send a MyType to a process which has loaded DummyModule even if it\\'s not in scope:julia> put!(RemoteChannel(2), MyType(7))\\nRemoteChannel{Channel{Any}}(2, 1, 13)A file can also be preloaded on multiple processes at startup with the -L flag, and a driver script can be used to drive the computation:julia -p <n> -L file1.jl -L file2.jl driver.jlThe Julia process running the driver script in the example above has an id equal to 1, just like a process providing an interactive prompt.Finally, if DummyModule.jl is not a standalone file but a package, then using DummyModule will load DummyModule.jl on all processes, but only bring it into scope on the process where using was called.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Starting-and-managing-worker-processes-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Starting and managing worker processes\",\n    \"category\": \"section\",\n    \"text\": \"The base Julia installation has in-built support for two types of clusters:A local cluster specified with the -p option as shown above.\\nA cluster spanning machines using the --machine-file option. This uses a passwordless ssh login to start Julia worker processes (from the same path as the current host) on the specified machines.Functions addprocs, rmprocs, workers, and others are available as a programmatic means of adding, removing and querying the processes in a cluster.julia> using Distributed\\n\\njulia> addprocs(2)\\n2-element Array{Int64,1}:\\n 2\\n 3Module Distributed must be explicitly loaded on the master process before invoking addprocs. It is automatically made available on the worker processes.Note that workers do not run a ~/.julia/config/startup.jl startup script, nor do they synchronize their global state (such as global variables, new method definitions, and loaded modules) with any of the other running processes.Other types of clusters can be supported by writing your own custom ClusterManager, as described below in the ClusterManagers section.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Data-Movement-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Data Movement\",\n    \"category\": \"section\",\n    \"text\": \"Sending messages and moving data constitute most of the overhead in a distributed program. Reducing the number of messages and the amount of data sent is critical to achieving performance and scalability. To this end, it is important to understand the data movement performed by Julia\\'s various distributed programming constructs.fetch can be considered an explicit data movement operation, since it directly asks that an object be moved to the local machine. @spawn (and a few related constructs) also moves data, but this is not as obvious, hence it can be called an implicit data movement operation. Consider these two approaches to constructing and squaring a random matrix:Method 1:julia> A = rand(1000,1000);\\n\\njulia> Bref = @spawn A^2;\\n\\n[...]\\n\\njulia> fetch(Bref);Method 2:julia> Bref = @spawn rand(1000,1000)^2;\\n\\n[...]\\n\\njulia> fetch(Bref);The difference seems trivial, but in fact is quite significant due to the behavior of @spawn. In the first method, a random matrix is constructed locally, then sent to another process where it is squared. In the second method, a random matrix is both constructed and squared on another process. Therefore the second method sends much less data than the first.In this toy example, the two methods are easy to distinguish and choose from. However, in a real program designing data movement might require more thought and likely some measurement. For example, if the first process needs matrix A then the first method might be better. Or, if computing A is expensive and only the current process has it, then moving it to another process might be unavoidable. Or, if the current process has very little to do between the @spawn and fetch(Bref), it might be better to eliminate the parallelism altogether. Or imagine rand(1000,1000) is replaced with a more expensive operation. Then it might make sense to add another @spawn statement just for this step.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Global-variables-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Global variables\",\n    \"category\": \"section\",\n    \"text\": \"Expressions executed remotely via @spawn, or closures specified for remote execution using remotecall may refer to global variables. Global bindings under module Main are treated a little differently compared to global bindings in other modules. Consider the following code snippet:A = rand(10,10)\\nremotecall_fetch(()->sum(A), 2)In this case sum MUST be defined in the remote process. Note that A is a global variable defined in the local workspace. Worker 2 does not have a variable called A under Main. The act of shipping the closure ()->sum(A) to worker 2 results in Main.A being defined on 2. Main.A continues to exist on worker 2 even after the call remotecall_fetch returns. Remote calls with embedded global references (under Main module only) manage globals as follows:New global bindings are created on destination workers if they are referenced as part of a remote call.\\nGlobal constants are declared as constants on remote nodes too.\\nGlobals are re-sent to a destination worker only in the context of a remote call, and then only if its value has changed. Also, the cluster does not synchronize global bindings across nodes. For example:\\nA = rand(10,10)\\nremotecall_fetch(()->sum(A), 2) # worker 2\\nA = rand(10,10)\\nremotecall_fetch(()->sum(A), 3) # worker 3\\nA = nothing\\nExecuting the above snippet results in Main.A on worker 2 having a different value from Main.A on worker 3, while the value of Main.A on node 1 is set to nothing.As you may have realized, while memory associated with globals may be collected when they are reassigned on the master, no such action is taken on the workers as the bindings continue to be valid. clear! can be used to manually reassign specific globals on remote nodes to nothing once they are no longer required. This will release any memory associated with them as part of a regular garbage collection cycle.Thus programs should be careful referencing globals in remote calls. In fact, it is preferable to avoid them altogether if possible. If you must reference globals, consider using let blocks to localize global variables.For example:julia> A = rand(10,10);\\n\\njulia> remotecall_fetch(()->A, 2);\\n\\njulia> B = rand(10,10);\\n\\njulia> let B = B\\n           remotecall_fetch(()->B, 2)\\n       end;\\n\\njulia> @fetchfrom 2 varinfo()\\nname           size summary\\n\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013 \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013 \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\\nA         800 bytes 10\u00d710 Array{Float64,2}\\nBase                Module\\nCore                Module\\nMain                ModuleAs can be seen, global variable A is defined on worker 2, but B is captured as a local variable and hence a binding for B does not exist on worker 2.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Parallel-Map-and-Loops-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Parallel Map and Loops\",\n    \"category\": \"section\",\n    \"text\": \"Fortunately, many useful parallel computations do not require data movement. A common example is a Monte Carlo simulation, where multiple processes can handle independent simulation trials simultaneously. We can use @spawn to flip coins on two processes. First, write the following function in count_heads.jl:function count_heads(n)\\n    c::Int = 0\\n    for i = 1:n\\n        c += rand(Bool)\\n    end\\n    c\\nendThe function count_heads simply adds together n random bits. Here is how we can perform some trials on two machines, and add together the results:julia> @everywhere include_string(Main, $(read(\\\"count_heads.jl\\\", String)), \\\"count_heads.jl\\\")\\n\\njulia> a = @spawn count_heads(100000000)\\nFuture(2, 1, 6, nothing)\\n\\njulia> b = @spawn count_heads(100000000)\\nFuture(3, 1, 7, nothing)\\n\\njulia> fetch(a)+fetch(b)\\n100001564This example demonstrates a powerful and often-used parallel programming pattern. Many iterations run independently over several processes, and then their results are combined using some function. The combination process is called a reduction, since it is generally tensor-rank-reducing: a vector of numbers is reduced to a single number, or a matrix is reduced to a single row or column, etc. In code, this typically looks like the pattern x = f(x,v[i]), where x is the accumulator, f is the reduction function, and the v[i] are the elements being reduced. It is desirable for f to be associative, so that it does not matter what order the operations are performed in.Notice that our use of this pattern with count_heads can be generalized. We used two explicit @spawn statements, which limits the parallelism to two processes. To run on any number of processes, we can use a parallel for loop, running in distributed memory, which can be written in Julia using @distributed like this:nheads = @distributed (+) for i = 1:200000000\\n    Int(rand(Bool))\\nendThis construct implements the pattern of assigning iterations to multiple processes, and combining them with a specified reduction (in this case (+)). The result of each iteration is taken as the value of the last expression inside the loop. The whole parallel loop expression itself evaluates to the final answer.Note that although parallel for loops look like serial for loops, their behavior is dramatically different. In particular, the iterations do not happen in a specified order, and writes to variables or arrays will not be globally visible since iterations run on different processes. Any variables used inside the parallel loop will be copied and broadcast to each process.For example, the following code will not work as intended:a = zeros(100000)\\n@distributed for i = 1:100000\\n    a[i] = i\\nendThis code will not initialize all of a, since each process will have a separate copy of it. Parallel for loops like these must be avoided. Fortunately, Shared Arrays can be used to get around this limitation:using SharedArrays\\n\\na = SharedArray{Float64}(10)\\n@distributed for i = 1:10\\n    a[i] = i\\nendUsing \\\"outside\\\" variables in parallel loops is perfectly reasonable if the variables are read-only:a = randn(1000)\\n@distributed (+) for i = 1:100000\\n    f(a[rand(1:end)])\\nendHere each iteration applies f to a randomly-chosen sample from a vector a shared by all processes.As you could see, the reduction operator can be omitted if it is not needed. In that case, the loop executes asynchronously, i.e. it spawns independent tasks on all available workers and returns an array of Future immediately without waiting for completion. The caller can wait for the Future completions at a later point by calling fetch on them, or wait for completion at the end of the loop by prefixing it with @sync, like @sync @distributed for.In some cases no reduction operator is needed, and we merely wish to apply a function to all integers in some range (or, more generally, to all elements in some collection). This is another useful operation called parallel map, implemented in Julia as the pmap function. For example, we could compute the singular values of several large random matrices in parallel as follows:julia> M = Matrix{Float64}[rand(1000,1000) for i = 1:10];\\n\\njulia> pmap(svdvals, M);Julia\\'s pmap is designed for the case where each function call does a large amount of work. In contrast, @distributed for can handle situations where each iteration is tiny, perhaps merely summing two numbers. Only worker processes are used by both pmap and @distributed for for the parallel computation. In case of @distributed for, the final reduction is done on the calling process.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Remote-References-and-AbstractChannels-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Remote References and AbstractChannels\",\n    \"category\": \"section\",\n    \"text\": \"Remote references always refer to an implementation of an AbstractChannel.A concrete implementation of an AbstractChannel (like Channel), is required to implement put!, take!, fetch, isready and wait. The remote object referred to by a Future is stored in a Channel{Any}(1), i.e., a Channel of size 1 capable of holding objects of Any type.RemoteChannel, which is rewritable, can point to any type and size of channels, or any other implementation of an AbstractChannel.The constructor RemoteChannel(f::Function, pid)() allows us to construct references to channels holding more than one value of a specific type. f is a function executed on pid and it must return an AbstractChannel.For example, RemoteChannel(()->Channel{Int}(10), pid), will return a reference to a channel of type Int and size 10. The channel exists on worker pid.Methods put!, take!, fetch, isready and wait on a RemoteChannel are proxied onto the backing store on the remote process.RemoteChannel can thus be used to refer to user implemented AbstractChannel objects. A simple example of this is provided in dictchannel.jl in the Examples repository, which uses a dictionary as its remote store.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Channels-and-RemoteChannels-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Channels and RemoteChannels\",\n    \"category\": \"section\",\n    \"text\": \"A Channel is local to a process. Worker 2 cannot directly refer to a Channel on worker 3 and vice-versa. A RemoteChannel, however, can put and take values across workers.\\nA RemoteChannel can be thought of as a handle to a Channel.\\nThe process id, pid, associated with a RemoteChannel identifies the process where the backing store, i.e., the backing Channel exists.\\nAny process with a reference to a RemoteChannel can put and take items from the channel. Data is automatically sent to (or retrieved from) the process a RemoteChannel is associated with.\\nSerializing  a Channel also serializes any data present in the channel. Deserializing it therefore effectively makes a copy of the original object.\\nOn the other hand, serializing a RemoteChannel only involves the serialization of an identifier that identifies the location and instance of Channel referred to by the handle. A deserialized RemoteChannel object (on any worker), therefore also points to the same backing store as the original.The channels example from above can be modified for interprocess communication, as shown below.We start 4 workers to process a single jobs remote channel. Jobs, identified by an id (job_id), are written to the channel. Each remotely executing task in this simulation reads a job_id, waits for a random amount of time and writes back a tuple of job_id, time taken and its own pid to the results channel. Finally all the results are printed out on the master process.julia> addprocs(4); # add worker processes\\n\\njulia> const jobs = RemoteChannel(()->Channel{Int}(32));\\n\\njulia> const results = RemoteChannel(()->Channel{Tuple}(32));\\n\\njulia> @everywhere function do_work(jobs, results) # define work function everywhere\\n           while true\\n               job_id = take!(jobs)\\n               exec_time = rand()\\n               sleep(exec_time) # simulates elapsed time doing actual work\\n               put!(results, (job_id, exec_time, myid()))\\n           end\\n       end\\n\\njulia> function make_jobs(n)\\n           for i in 1:n\\n               put!(jobs, i)\\n           end\\n       end;\\n\\njulia> n = 12;\\n\\njulia> @async make_jobs(n); # feed the jobs channel with \\\"n\\\" jobs\\n\\njulia> for p in workers() # start tasks on the workers to process requests in parallel\\n           remote_do(do_work, p, jobs, results)\\n       end\\n\\njulia> @elapsed while n > 0 # print out results\\n           job_id, exec_time, where = take!(results)\\n           println(\\\"$job_id finished in $(round(exec_time,2)) seconds on worker $where\\\")\\n           n = n - 1\\n       end\\n1 finished in 0.18 seconds on worker 4\\n2 finished in 0.26 seconds on worker 5\\n6 finished in 0.12 seconds on worker 4\\n7 finished in 0.18 seconds on worker 4\\n5 finished in 0.35 seconds on worker 5\\n4 finished in 0.68 seconds on worker 2\\n3 finished in 0.73 seconds on worker 3\\n11 finished in 0.01 seconds on worker 3\\n12 finished in 0.02 seconds on worker 3\\n9 finished in 0.26 seconds on worker 5\\n8 finished in 0.57 seconds on worker 4\\n10 finished in 0.58 seconds on worker 2\\n0.055971741\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Remote-References-and-Distributed-Garbage-Collection-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Remote References and Distributed Garbage Collection\",\n    \"category\": \"section\",\n    \"text\": \"Objects referred to by remote references can be freed only when all held references in the cluster are deleted.The node where the value is stored keeps track of which of the workers have a reference to it. Every time a RemoteChannel or a (unfetched) Future is serialized to a worker, the node pointed to by the reference is notified. And every time a RemoteChannel or a (unfetched) Future is garbage collected locally, the node owning the value is again notified. This is implemented in an internal cluster aware serializer. Remote references are only valid in the context of a running cluster. Serializing and deserializing references to and from regular IO objects is not supported.The notifications are done via sending of \\\"tracking\\\" messages\u2013an \\\"add reference\\\" message when a reference is serialized to a different process and a \\\"delete reference\\\" message when a reference is locally garbage collected.Since Futures are write-once and cached locally, the act of fetching a Future also updates reference tracking information on the node owning the value.The node which owns the value frees it once all references to it are cleared.With Futures, serializing an already fetched Future to a different node also sends the value since the original remote store may have collected the value by this time.It is important to note that when an object is locally garbage collected depends on the size of the object and the current memory pressure in the system.In case of remote references, the size of the local reference object is quite small, while the value stored on the remote node may be quite large. Since the local object may not be collected immediately, it is a good practice to explicitly call finalize on local instances of a RemoteChannel, or on unfetched Futures. Since calling fetch on a Future also removes its reference from the remote store, this is not required on fetched Futures. Explicitly calling finalize results in an immediate message sent to the remote node to go ahead and remove its reference to the value.Once finalized, a reference becomes invalid and cannot be used in any further calls.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#man-shared-arrays-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Shared Arrays\",\n    \"category\": \"section\",\n    \"text\": \"Shared Arrays use system shared memory to map the same array across many processes. While there are some similarities to a DArray, the behavior of a SharedArray is quite different. In a DArray, each process has local access to just a chunk of the data, and no two processes share the same chunk; in contrast, in a SharedArray each \\\"participating\\\" process has access to the entire array.  A SharedArray is a good choice when you want to have a large amount of data jointly accessible to two or more processes on the same machine.Shared Array support is available via module SharedArrays which must be explicitly loaded on all participating workers.SharedArray indexing (assignment and accessing values) works just as with regular arrays, and is efficient because the underlying memory is available to the local process. Therefore, most algorithms work naturally on SharedArrays, albeit in single-process mode. In cases where an algorithm insists on an Array input, the underlying array can be retrieved from a SharedArray by calling sdata. For other AbstractArray types, sdata just returns the object itself, so it\\'s safe to use sdata on any Array-type object.The constructor for a shared array is of the form:SharedArray{T,N}(dims::NTuple; init=false, pids=Int[])which creates an N-dimensional shared array of a bits type T and size dims across the processes specified by pids. Unlike distributed arrays, a shared array is accessible only from those participating workers specified by the pids named argument (and the creating process too, if it is on the same host).If an init function, of signature initfn(S::SharedArray), is specified, it is called on all the participating workers. You can specify that each worker runs the init function on a distinct portion of the array, thereby parallelizing initialization.Here\\'s a brief example:julia> using Distributed\\n\\njulia> addprocs(3)\\n3-element Array{Int64,1}:\\n 2\\n 3\\n 4\\n\\njulia> @everywhere using SharedArrays\\n\\njulia> S = SharedArray{Int,2}((3,4), init = S -> S[localindices(S)] = myid())\\n3\u00d74 SharedArray{Int64,2}:\\n 2  2  3  4\\n 2  3  3  4\\n 2  3  4  4\\n\\njulia> S[3,2] = 7\\n7\\n\\njulia> S\\n3\u00d74 SharedArray{Int64,2}:\\n 2  2  3  4\\n 2  3  3  4\\n 2  7  4  4SharedArrays.localindices provides disjoint one-dimensional ranges of indices, and is sometimes convenient for splitting up tasks among processes. You can, of course, divide the work any way you wish:julia> S = SharedArray{Int,2}((3,4), init = S -> S[indexpids(S):length(procs(S)):length(S)] = myid())\\n3\u00d74 SharedArray{Int64,2}:\\n 2  2  2  2\\n 3  3  3  3\\n 4  4  4  4Since all processes have access to the underlying data, you do have to be careful not to set up conflicts. For example:@sync begin\\n    for p in procs(S)\\n        @async begin\\n            remotecall_wait(fill!, p, S, p)\\n        end\\n    end\\nendwould result in undefined behavior. Because each process fills the entire array with its own pid, whichever process is the last to execute (for any particular element of S) will have its pid retained.As a more extended and complex example, consider running the following \\\"kernel\\\" in parallel:q[i,j,t+1] = q[i,j,t] + u[i,j,t]In this case, if we try to split up the work using a one-dimensional index, we are likely to run into trouble: if q[i,j,t] is near the end of the block assigned to one worker and q[i,j,t+1] is near the beginning of the block assigned to another, it\\'s very likely that q[i,j,t] will not be ready at the time it\\'s needed for computing q[i,j,t+1]. In such cases, one is better off chunking the array manually. Let\\'s split along the second dimension. Define a function that returns the (irange, jrange) indices assigned to this worker:julia> @everywhere function myrange(q::SharedArray)\\n           idx = indexpids(q)\\n           if idx == 0 # This worker is not assigned a piece\\n               return 1:0, 1:0\\n           end\\n           nchunks = length(procs(q))\\n           splits = [round(Int, s) for s in range(0, stop=size(q,2), length=nchunks+1)]\\n           1:size(q,1), splits[idx]+1:splits[idx+1]\\n       endNext, define the kernel:julia> @everywhere function advection_chunk!(q, u, irange, jrange, trange)\\n           @show (irange, jrange, trange)  # display so we can see what\\'s happening\\n           for t in trange, j in jrange, i in irange\\n               q[i,j,t+1] = q[i,j,t] + u[i,j,t]\\n           end\\n           q\\n       endWe also define a convenience wrapper for a SharedArray implementationjulia> @everywhere advection_shared_chunk!(q, u) =\\n           advection_chunk!(q, u, myrange(q)..., 1:size(q,3)-1)Now let\\'s compare three different versions, one that runs in a single process:julia> advection_serial!(q, u) = advection_chunk!(q, u, 1:size(q,1), 1:size(q,2), 1:size(q,3)-1);one that uses @distributed:julia> function advection_parallel!(q, u)\\n           for t = 1:size(q,3)-1\\n               @sync @distributed for j = 1:size(q,2)\\n                   for i = 1:size(q,1)\\n                       q[i,j,t+1]= q[i,j,t] + u[i,j,t]\\n                   end\\n               end\\n           end\\n           q\\n       end;and one that delegates in chunks:julia> function advection_shared!(q, u)\\n           @sync begin\\n               for p in procs(q)\\n                   @async remotecall_wait(advection_shared_chunk!, p, q, u)\\n               end\\n           end\\n           q\\n       end;If we create SharedArrays and time these functions, we get the following results (with julia -p 4):julia> q = SharedArray{Float64,3}((500,500,500));\\n\\njulia> u = SharedArray{Float64,3}((500,500,500));Run the functions once to JIT-compile and @time them on the second run:julia> @time advection_serial!(q, u);\\n(irange,jrange,trange) = (1:500,1:500,1:499)\\n 830.220 milliseconds (216 allocations: 13820 bytes)\\n\\njulia> @time advection_parallel!(q, u);\\n   2.495 seconds      (3999 k allocations: 289 MB, 2.09% gc time)\\n\\njulia> @time advection_shared!(q,u);\\n        From worker 2:       (irange,jrange,trange) = (1:500,1:125,1:499)\\n        From worker 4:       (irange,jrange,trange) = (1:500,251:375,1:499)\\n        From worker 3:       (irange,jrange,trange) = (1:500,126:250,1:499)\\n        From worker 5:       (irange,jrange,trange) = (1:500,376:500,1:499)\\n 238.119 milliseconds (2264 allocations: 169 KB)The biggest advantage of advection_shared! is that it minimizes traffic among the workers, allowing each to compute for an extended time on the assigned piece.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Shared-Arrays-and-Distributed-Garbage-Collection-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Shared Arrays and Distributed Garbage Collection\",\n    \"category\": \"section\",\n    \"text\": \"Like remote references, shared arrays are also dependent on garbage collection on the creating node to release references from all participating workers. Code which creates many short lived shared array objects would benefit from explicitly finalizing these objects as soon as possible. This results in both memory and file handles mapping the shared segment being released sooner.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#ClusterManagers-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"ClusterManagers\",\n    \"category\": \"section\",\n    \"text\": \"The launching, management and networking of Julia processes into a logical cluster is done via cluster managers. A ClusterManager is responsible forlaunching worker processes in a cluster environment\\nmanaging events during the lifetime of each worker\\noptionally, providing data transportA Julia cluster has the following characteristics:The initial Julia process, also called the master, is special and has an id of 1.\\nOnly the master process can add or remove worker processes.\\nAll processes can directly communicate with each other.Connections between workers (using the in-built TCP/IP transport) is established in the following manner:addprocs is called on the master process with a ClusterManager object.\\naddprocs calls the appropriate launch method which spawns required number of worker processes on appropriate machines.\\nEach worker starts listening on a free port and writes out its host and port information to stdout.\\nThe cluster manager captures the stdout of each worker and makes it available to the master process.\\nThe master process parses this information and sets up TCP/IP connections to each worker.\\nEvery worker is also notified of other workers in the cluster.\\nEach worker connects to all workers whose id is less than the worker\\'s own id.\\nIn this way a mesh network is established, wherein every worker is directly connected with every other worker.While the default transport layer uses plain TCPSocket, it is possible for a Julia cluster to provide its own transport.Julia provides two in-built cluster managers:LocalManager, used when addprocs() or addprocs(np::Integer) are called\\nSSHManager, used when addprocs(hostnames::Array) is called with a list of hostnamesLocalManager is used to launch additional workers on the same host, thereby leveraging multi-core and multi-processor hardware.Thus, a minimal cluster manager would need to:be a subtype of the abstract ClusterManager\\nimplement launch, a method responsible for launching new workers\\nimplement manage, which is called at various events during a worker\\'s lifetime (for example, sending an interrupt signal)addprocs(manager::FooManager) requires FooManager to implement:function launch(manager::FooManager, params::Dict, launched::Array, c::Condition)\\n    [...]\\nend\\n\\nfunction manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)\\n    [...]\\nendAs an example let us see how the LocalManager, the manager responsible for starting workers on the same host, is implemented:struct LocalManager <: ClusterManager\\n    np::Integer\\nend\\n\\nfunction launch(manager::LocalManager, params::Dict, launched::Array, c::Condition)\\n    [...]\\nend\\n\\nfunction manage(manager::LocalManager, id::Integer, config::WorkerConfig, op::Symbol)\\n    [...]\\nendThe launch method takes the following arguments:manager::ClusterManager: the cluster manager that addprocs is called with\\nparams::Dict: all the keyword arguments passed to addprocs\\nlaunched::Array: the array to append one or more WorkerConfig objects to\\nc::Condition: the condition variable to be notified as and when workers are launchedThe launch method is called asynchronously in a separate task. The termination of this task signals that all requested workers have been launched. Hence the launch function MUST exit as soon as all the requested workers have been launched.Newly launched workers are connected to each other and the master process in an all-to-all manner. Specifying the command line argument --worker[=<cookie>] results in the launched processes initializing themselves as workers and connections being set up via TCP/IP sockets.All workers in a cluster share the same cookie as the master. When the cookie is unspecified, i.e, with the --worker option, the worker tries to read it from its standard input.  LocalManager and SSHManager both pass the cookie to newly launched workers via their  standard inputs.By default a worker will listen on a free port at the address returned by a call to getipaddr(). A specific address to listen on may be specified by optional argument --bind-to bind_addr[:port]. This is useful for multi-homed hosts.As an example of a non-TCP/IP transport, an implementation may choose to use MPI, in which case --worker must NOT be specified. Instead, newly launched workers should call init_worker(cookie) before using any of the parallel constructs.For every worker launched, the launch method must add a WorkerConfig object (with appropriate fields initialized) to launchedmutable struct WorkerConfig\\n    # Common fields relevant to all cluster managers\\n    io::Union{IO, Nothing}\\n    host::Union{AbstractString, Nothing}\\n    port::Union{Integer, Nothing}\\n\\n    # Used when launching additional workers at a host\\n    count::Union{Int, Symbol, Nothing}\\n    exename::Union{AbstractString, Cmd, Nothing}\\n    exeflags::Union{Cmd, Nothing}\\n\\n    # External cluster managers can use this to store information at a per-worker level\\n    # Can be a dict if multiple fields need to be stored.\\n    userdata::Any\\n\\n    # SSHManager / SSH tunnel connections to workers\\n    tunnel::Union{Bool, Nothing}\\n    bind_addr::Union{AbstractString, Nothing}\\n    sshflags::Union{Cmd, Nothing}\\n    max_parallel::Union{Integer, Nothing}\\n\\n    # Used by Local/SSH managers\\n    connect_at::Any\\n\\n    [...]\\nendMost of the fields in WorkerConfig are used by the inbuilt managers. Custom cluster managers would typically specify only io or host / port:If io is specified, it is used to read host/port information. A Julia worker prints out its bind address and port at startup. This allows Julia workers to listen on any free port available instead of requiring worker ports to be configured manually.\\nIf io is not specified, host and port are used to connect.\\ncount, exename and exeflags are relevant for launching additional workers from a worker. For example, a cluster manager may launch a single worker per node, and use that to launch additional workers.\\ncount with an integer value n will launch a total of n workers.\\ncount with a value of :auto will launch as many workers as the number of CPU threads (logical cores) on that machine.\\nexename is the name of the julia executable including the full path.\\nexeflags should be set to the required command line arguments for new workers.\\ntunnel, bind_addr, sshflags and max_parallel are used when a ssh tunnel is required to connect to the workers from the master process.\\nuserdata is provided for custom cluster managers to store their own worker-specific information.manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol) is called at different times during the worker\\'s lifetime with appropriate op values:with :register/:deregister when a worker is added / removed from the Julia worker pool.\\nwith :interrupt when interrupt(workers) is called. The ClusterManager should signal the appropriate worker with an interrupt signal.\\nwith :finalize for cleanup purposes.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Cluster-Managers-with-Custom-Transports-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Cluster Managers with Custom Transports\",\n    \"category\": \"section\",\n    \"text\": \"Replacing the default TCP/IP all-to-all socket connections with a custom transport layer is a little more involved. Each Julia process has as many communication tasks as the workers it is connected to. For example, consider a Julia cluster of 32 processes in an all-to-all mesh network:Each Julia process thus has 31 communication tasks.\\nEach task handles all incoming messages from a single remote worker in a message-processing loop.\\nThe message-processing loop waits on an IO object (for example, a TCPSocket in the default implementation), reads an entire message, processes it and waits for the next one.\\nSending messages to a process is done directly from any Julia task\u2013not just communication tasks\u2013again, via the appropriate IO object.Replacing the default transport requires the new implementation to set up connections to remote workers and to provide appropriate IO objects that the message-processing loops can wait on. The manager-specific callbacks to be implemented are:connect(manager::FooManager, pid::Integer, config::WorkerConfig)\\nkill(manager::FooManager, pid::Int, config::WorkerConfig)The default implementation (which uses TCP/IP sockets) is implemented as connect(manager::ClusterManager, pid::Integer, config::WorkerConfig).connect should return a pair of IO objects, one for reading data sent from worker pid, and the other to write data that needs to be sent to worker pid. Custom cluster managers can use an in-memory BufferStream as the plumbing to proxy data between the custom, possibly non-IO transport and Julia\\'s in-built parallel infrastructure.A BufferStream is an in-memory IOBuffer which behaves like an IO\u2013it is a stream which can be handled asynchronously.The folder clustermanager/0mq in the Examples repository contains an example of using ZeroMQ to connect Julia workers in a star topology with a 0MQ broker in the middle. Note: The Julia processes are still all logically connected to each other\u2013any worker can message any other worker directly without any awareness of 0MQ being used as the transport layer.When using custom transports:Julia workers must NOT be started with --worker. Starting with --worker will result in the newly launched workers defaulting to the TCP/IP socket transport implementation.\\nFor every incoming logical connection with a worker, Base.process_messages(rd::IO, wr::IO)() must be called. This launches a new task that handles reading and writing of messages from/to the worker represented by the IO objects.\\ninit_worker(cookie, manager::FooManager) must be called as part of worker process initialization.\\nField connect_at::Any in WorkerConfig can be set by the cluster manager when launch is called. The value of this field is passed in in all connect callbacks. Typically, it carries information on how to connect to a worker. For example, the TCP/IP socket transport uses this field to specify the (host, port) tuple at which to connect to a worker.kill(manager, pid, config) is called to remove a worker from the cluster. On the master process, the corresponding IO objects must be closed by the implementation to ensure proper cleanup. The default implementation simply executes an exit() call on the specified remote worker.The Examples folder clustermanager/simple is an example that shows a simple implementation using UNIX domain sockets for cluster setup.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Network-Requirements-for-LocalManager-and-SSHManager-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Network Requirements for LocalManager and SSHManager\",\n    \"category\": \"section\",\n    \"text\": \"Julia clusters are designed to be executed on already secured environments on infrastructure such as local laptops, departmental clusters, or even the cloud. This section covers network security requirements for the inbuilt LocalManager and SSHManager:The master process does not listen on any port. It only connects out to the workers.\\nEach worker binds to only one of the local interfaces and listens on an ephemeral port number assigned by the OS.\\nLocalManager, used by addprocs(N), by default binds only to the loopback interface. This means that workers started later on remote hosts (or by anyone with malicious intentions) are unable to connect to the cluster. An addprocs(4) followed by an addprocs([\\\"remote_host\\\"]) will fail. Some users may need to create a cluster comprising their local system and a few remote systems. This can be done by explicitly requesting LocalManager to bind to an external network interface via the restrict keyword argument: addprocs(4; restrict=false).\\nSSHManager, used by addprocs(list_of_remote_hosts), launches workers on remote hosts via SSH. By default SSH is only used to launch Julia workers. Subsequent master-worker and worker-worker connections use plain, unencrypted TCP/IP sockets. The remote hosts must have passwordless login enabled. Additional SSH flags or credentials may be specified via keyword argument sshflags.\\naddprocs(list_of_remote_hosts; tunnel=true, sshflags=<ssh keys and other flags>) is useful when we wish to use SSH connections for master-worker too. A typical scenario for this is a local laptop running the Julia REPL (i.e., the master) with the rest of the cluster on the cloud, say on Amazon EC2. In this case only port 22 needs to be opened at the remote cluster coupled with SSH client authenticated via public key infrastructure (PKI). Authentication credentials can be supplied via sshflags, for example sshflags=`-e <keyfile>`.\\nIn an all-to-all topology (the default), all workers connect to each other via plain TCP sockets. The security policy on the cluster nodes must thus ensure free connectivity between workers for the ephemeral port range (varies by OS).\\nSecuring and encrypting all worker-worker traffic (via SSH) or encrypting individual messages can be done via a custom ClusterManager.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#man-cluster-cookie-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Cluster Cookie\",\n    \"category\": \"section\",\n    \"text\": \"All processes in a cluster share the same cookie which, by default, is a randomly generated string on the master process:cluster_cookie() returns the cookie, while cluster_cookie(cookie)() sets it and returns the new cookie.\\nAll connections are authenticated on both sides to ensure that only workers started by the master are allowed to connect to each other.\\nThe cookie may be passed to the workers at startup via argument --worker=<cookie>. If argument --worker is specified without the cookie, the worker tries to read the cookie from its standard input (stdin). The stdin is closed immediately after the cookie is retrieved.\\nClusterManagers can retrieve the cookie on the master by calling cluster_cookie(). Cluster managers not using the default TCP/IP transport (and hence not specifying --worker) must call init_worker(cookie, manager) with the same cookie as on the master.Note that environments requiring higher levels of security can implement this via a custom ClusterManager. For example, cookies can be pre-shared and hence not specified as a startup argument.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Specifying-Network-Topology-(Experimental)-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Specifying Network Topology (Experimental)\",\n    \"category\": \"section\",\n    \"text\": \"The keyword argument topology passed to addprocs is used to specify how the workers must be connected to each other::all_to_all, the default: all workers are connected to each other.\\n:master_worker: only the driver process, i.e. pid 1, has connections to the workers.\\n:custom: the launch method of the cluster manager specifies the connection topology via the fields ident and connect_idents in WorkerConfig. A worker with a cluster-manager-provided identity ident will connect to all workers specified in connect_idents.Keyword argument lazy=true|false only affects topology option :all_to_all. If true, the cluster starts off with the master connected to all workers. Specific worker-worker connections are established at the first remote invocation between two workers. This helps in reducing initial resources allocated for intra-cluster communication. Connections are setup depending on the runtime requirements of a parallel program. Default value for lazy is true.Currently, sending a message between unconnected workers results in an error. This behaviour, as with the functionality and interface, should be considered experimental in nature and may change in future releases.\"\n},\n\n{\n    \"location\": \"manual/parallel-computing.html#Noteworthy-external-packages-1\",\n    \"page\": \"Parallel Computing\",\n    \"title\": \"Noteworthy external packages\",\n    \"category\": \"section\",\n    \"text\": \"Outside of Julia parallelism there are plenty of external packages that should be mentioned. For example MPI.jl is a Julia wrapper for the MPI protocol, or DistributedArrays.jl, as presented in Shared Arrays. A mention must be done to the Julia\\'s GPU programming ecosystem, which includes :Low-level (C kernel) based operations OpenCL.jl and CUDAdrv.jl which are respectively an OpenCL interface and a CUDA wrapper.\\nLow-level (Julia Kernel) interfaces like CUDAnative.jl which is a Julia native CUDA implementation.\\nHigh-level vendor specific abstractions like CuArrays.jl and CLArrays.jl\\nHigh-level libraries like ArrayFire.jl and GPUArrays.jlIn the following example we will use both DistributedArrays.jl and CuArrays.jl to distribute an array across multiple processes by first casting it through distribute() and CuArray().Remember when importing DistributedArrays.jl to import it across all processes using @everywhere$ ./julia -p 4\\n\\njulia> addprocs()\\n\\njulia> @everywhere using DistributedArrays\\n\\njulia> using CuArrays\\n\\njulia> B = ones(10_000) ./ 2;\\n\\njulia> A = ones(10_000) .* \u03c0;\\n\\njulia> C = 2 .* A ./ B;\\n\\njulia> all(C .\u2248 4*\u03c0)\\ntrue\\n\\njulia> typeof(C)\\nArray{Float64,1}\\n\\njulia> dB = distribute(B);\\n\\njulia> dA = distribute(A);\\n\\njulia> dC = 2 .* dA ./ dB;\\n\\njulia> all(dC .\u2248 4*\u03c0)\\ntrue\\n\\njulia> typeof(dC)\\nDistributedArrays.DArray{Float64,1,Array{Float64,1}}\\n\\njulia> cuB = CuArray(B);\\n\\njulia> cuA = CuArray(A);\\n\\njulia> cuC = 2 .* cuA ./ cuB;\\n\\njulia> all(cuC .\u2248 4*\u03c0);\\ntrue\\n\\njulia> typeof(cuC)\\nCuArray{Float64,1}Keep in mind that some Julia features are not currently supported by CUDAnative.jl [2] , especially some functions like sin will need to be replaced with CUDAnative.sin(cc: @maleadt).In the following example we will use both DistributedArrays.jl and CuArrays.jl to distribute an array across multiple processes and call a generic function on it.function power_method(M, v)\\n    for i in 1:100\\n        v = M*v\\n        v /= norm(v)\\n    end\\n\\n    return v, norm(M*v) / norm(v)  # or  (M*v) ./ v\\nendpower_method repeteavely creates a new vector and normalizes it. We have not specified any type signature in function declaration, let\\'s see if it works with the aforementioned datatypes:julia> M = [2. 1; 1 1];\\n\\njulia> v = rand(2)\\n2-element Array{Float64,1}:\\n0.40395\\n0.445877\\n\\njulia> power_method(M,v)\\n([0.850651, 0.525731], 2.618033988749895)\\n\\njulia> cuM = CuArray(M);\\n\\njulia> cuv = CuArray(v);\\n\\njulia> curesult = power_method(cuM, cuv);\\n\\njulia> typeof(curesult)\\nCuArray{Float64,1}\\n\\njulia> dM = distribute(M);\\n\\njulia> dv = distribute(v);\\n\\njulia> dC = power_method(dM, dv);\\n\\njulia> typeof(dC)\\nTuple{DistributedArrays.DArray{Float64,1,Array{Float64,1}},Float64}To end this short exposure to external packages, we can consider MPI.jl, a Julia wrapper of the MPI protocol. As it would take too long to consider every inner function, it would be better to simply appreciate the approach used to implement the protocol.Consider this toy script which simply calls each subprocess, instantiate its rank and when the master process is reached, performs the ranks\\' sumimport MPI\\n\\nMPI.Init()\\n\\ncomm = MPI.COMM_WORLD\\nMPI.Barrier(comm)\\n\\nroot = 0\\nr = MPI.Comm_rank(comm)\\n\\nsr = MPI.Reduce(r, MPI.SUM, root, comm)\\n\\nif(MPI.Comm_rank(comm) == root)\\n   @printf(\\\"sum of ranks: %s\\\\n\\\", sr)\\nend\\n\\nMPI.Finalize()mpirun -np 4 ./julia example.jl[1]: in this context, mpi refers to the mpi-1 standard. beginning with mpi-2, the mpi standards committee introduced a new set of communication mechanisms, collectively referred to as remote memory access (rma). the motivation for adding rma to the mpi standard was to facilitate one-sided communication patterns. for additional information on the latest mpi standard, see http://mpi-forum.org/docs.[2]: Julia GPU man pages\"\n},\n\n{\n    \"location\": \"manual/running-external-programs.html#\",\n    \"page\": \"Running External Programs\",\n    \"title\": \"Running External Programs\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/running-external-programs.html#Running-External-Programs-1\",\n    \"page\": \"Running External Programs\",\n    \"title\": \"Running External Programs\",\n    \"category\": \"section\",\n    \"text\": \"Julia borrows backtick notation for commands from the shell, Perl, and Ruby. However, in Julia, writingjulia> `echo hello`\\n`echo hello`differs in several aspects from the behavior in various shells, Perl, or Ruby:Instead of immediately running the command, backticks create a Cmd object to represent the command. You can use this object to connect the command to others via pipes, run it, and read or write to it.\\nWhen the command is run, Julia does not capture its output unless you specifically arrange for it to. Instead, the output of the command by default goes to stdout as it would using libc\\'s system call.\\nThe command is never run with a shell. Instead, Julia parses the command syntax directly, appropriately interpolating variables and splitting on words as the shell would, respecting shell quoting syntax. The command is run as julia\\'s immediate child process, using fork and exec calls.Here\\'s a simple example of running an external program:julia> mycommand = `echo hello`\\n`echo hello`\\n\\njulia> typeof(mycommand)\\nCmd\\n\\njulia> run(mycommand);\\nhelloThe hello is the output of the echo command, sent to stdout. The run method itself returns nothing, and throws an ErrorException if the external command fails to run successfully.If you want to read the output of the external command, read can be used instead:julia> a = read(`echo hello`, String)\\n\\\"hello\\\\n\\\"\\n\\njulia> chomp(a) == \\\"hello\\\"\\ntrueMore generally, you can use open to read from or write to an external command.julia> open(`less`, \\\"w\\\", stdout) do io\\n           for i = 1:3\\n               println(io, i)\\n           end\\n       end\\n1\\n2\\n3The program name and the individual arguments in a command can be accessed and iterated over as if the command were an array of strings:julia> collect(`echo \\\"foo bar\\\"`)\\n2-element Array{String,1}:\\n \\\"echo\\\"\\n \\\"foo bar\\\"\\n\\njulia> `echo \\\"foo bar\\\"`[2]\\n\\\"foo bar\\\"\"\n},\n\n{\n    \"location\": \"manual/running-external-programs.html#command-interpolation-1\",\n    \"page\": \"Running External Programs\",\n    \"title\": \"Interpolation\",\n    \"category\": \"section\",\n    \"text\": \"Suppose you want to do something a bit more complicated and use the name of a file in the variable file as an argument to a command. You can use $ for interpolation much as you would in a string literal (see Strings):julia> file = \\\"/etc/passwd\\\"\\n\\\"/etc/passwd\\\"\\n\\njulia> `sort $file`\\n`sort /etc/passwd`A common pitfall when running external programs via a shell is that if a file name contains characters that are special to the shell, they may cause undesirable behavior. Suppose, for example, rather than /etc/passwd, we wanted to sort the contents of the file /Volumes/External HD/data.csv. Let\\'s try it:julia> file = \\\"/Volumes/External HD/data.csv\\\"\\n\\\"/Volumes/External HD/data.csv\\\"\\n\\njulia> `sort $file`\\n`sort \\'/Volumes/External HD/data.csv\\'`How did the file name get quoted? Julia knows that file is meant to be interpolated as a single argument, so it quotes the word for you. Actually, that is not quite accurate: the value of file is never interpreted by a shell, so there\\'s no need for actual quoting; the quotes are inserted only for presentation to the user. This will even work if you interpolate a value as part of a shell word:julia> path = \\\"/Volumes/External HD\\\"\\n\\\"/Volumes/External HD\\\"\\n\\njulia> name = \\\"data\\\"\\n\\\"data\\\"\\n\\njulia> ext = \\\"csv\\\"\\n\\\"csv\\\"\\n\\njulia> `sort $path/$name.$ext`\\n`sort \\'/Volumes/External HD/data.csv\\'`As you can see, the space in the path variable is appropriately escaped. But what if you want to interpolate multiple words? In that case, just use an array (or any other iterable container):julia> files = [\\\"/etc/passwd\\\",\\\"/Volumes/External HD/data.csv\\\"]\\n2-element Array{String,1}:\\n \\\"/etc/passwd\\\"\\n \\\"/Volumes/External HD/data.csv\\\"\\n\\njulia> `grep foo $files`\\n`grep foo /etc/passwd \\'/Volumes/External HD/data.csv\\'`If you interpolate an array as part of a shell word, Julia emulates the shell\\'s {a,b,c} argument generation:julia> names = [\\\"foo\\\",\\\"bar\\\",\\\"baz\\\"]\\n3-element Array{String,1}:\\n \\\"foo\\\"\\n \\\"bar\\\"\\n \\\"baz\\\"\\n\\njulia> `grep xylophone $names.txt`\\n`grep xylophone foo.txt bar.txt baz.txt`Moreover, if you interpolate multiple arrays into the same word, the shell\\'s Cartesian product generation behavior is emulated:julia> names = [\\\"foo\\\",\\\"bar\\\",\\\"baz\\\"]\\n3-element Array{String,1}:\\n \\\"foo\\\"\\n \\\"bar\\\"\\n \\\"baz\\\"\\n\\njulia> exts = [\\\"aux\\\",\\\"log\\\"]\\n2-element Array{String,1}:\\n \\\"aux\\\"\\n \\\"log\\\"\\n\\njulia> `rm -f $names.$exts`\\n`rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`Since you can interpolate literal arrays, you can use this generative functionality without needing to create temporary array objects first:julia> `rm -rf $[\\\"foo\\\",\\\"bar\\\",\\\"baz\\\",\\\"qux\\\"].$[\\\"aux\\\",\\\"log\\\",\\\"pdf\\\"]`\\n`rm -rf foo.aux foo.log foo.pdf bar.aux bar.log bar.pdf baz.aux baz.log baz.pdf qux.aux qux.log qux.pdf`\"\n},\n\n{\n    \"location\": \"manual/running-external-programs.html#Quoting-1\",\n    \"page\": \"Running External Programs\",\n    \"title\": \"Quoting\",\n    \"category\": \"section\",\n    \"text\": \"Inevitably, one wants to write commands that aren\\'t quite so simple, and it becomes necessary to use quotes. Here\\'s a simple example of a Perl one-liner at a shell prompt:sh$ perl -le \\'$|=1; for (0..3) { print }\\'\\n0\\n1\\n2\\n3The Perl expression needs to be in single quotes for two reasons: so that spaces don\\'t break the expression into multiple shell words, and so that uses of Perl variables like $| (yes, that\\'s the name of a variable in Perl), don\\'t cause interpolation. In other instances, you may want to use double quotes so that interpolation does occur:sh$ first=\\\"A\\\"\\nsh$ second=\\\"B\\\"\\nsh$ perl -le \\'$|=1; print for @ARGV\\' \\\"1: $first\\\" \\\"2: $second\\\"\\n1: A\\n2: BIn general, the Julia backtick syntax is carefully designed so that you can just cut-and-paste shell commands as is into backticks and they will work: the escaping, quoting, and interpolation behaviors are the same as the shell\\'s. The only difference is that the interpolation is integrated and aware of Julia\\'s notion of what is a single string value, and what is a container for multiple values. Let\\'s try the above two examples in Julia:julia> A = `perl -le \\'$|=1; for (0..3) { print }\\'`\\n`perl -le \\'$|=1; for (0..3) { print }\\'`\\n\\njulia> run(A);\\n0\\n1\\n2\\n3\\n\\njulia> first = \\\"A\\\"; second = \\\"B\\\";\\n\\njulia> B = `perl -le \\'print for @ARGV\\' \\\"1: $first\\\" \\\"2: $second\\\"`\\n`perl -le \\'print for @ARGV\\' \\'1: A\\' \\'2: B\\'`\\n\\njulia> run(B);\\n1: A\\n2: BThe results are identical, and Julia\\'s interpolation behavior mimics the shell\\'s with some improvements due to the fact that Julia supports first-class iterable objects while most shells use strings split on spaces for this, which introduces ambiguities. When trying to port shell commands to Julia, try cut and pasting first. Since Julia shows commands to you before running them, you can easily and safely just examine its interpretation without doing any damage.\"\n},\n\n{\n    \"location\": \"manual/running-external-programs.html#Pipelines-1\",\n    \"page\": \"Running External Programs\",\n    \"title\": \"Pipelines\",\n    \"category\": \"section\",\n    \"text\": \"Shell metacharacters, such as |, &, and >, need to be quoted (or escaped) inside of Julia\\'s backticks:julia> run(`echo hello \\'|\\' sort`);\\nhello | sort\\n\\njulia> run(`echo hello \\\\| sort`);\\nhello | sortThis expression invokes the echo command with three words as arguments: hello, |, and sort. The result is that a single line is printed: hello | sort. How, then, does one construct a pipeline? Instead of using \\'|\\' inside of backticks, one uses pipeline:julia> run(pipeline(`echo hello`, `sort`));\\nhelloThis pipes the output of the echo command to the sort command. Of course, this isn\\'t terribly interesting since there\\'s only one line to sort, but we can certainly do much more interesting things:julia> run(pipeline(`cut -d: -f3 /etc/passwd`, `sort -n`, `tail -n5`))\\n210\\n211\\n212\\n213\\n214This prints the highest five user IDs on a UNIX system. The cut, sort and tail commands are all spawned as immediate children of the current julia process, with no intervening shell process. Julia itself does the work to setup pipes and connect file descriptors that is normally done by the shell. Since Julia does this itself, it retains better control and can do some things that shells cannot.Julia can run multiple commands in parallel:julia> run(`echo hello` & `echo world`);\\nworld\\nhelloThe order of the output here is non-deterministic because the two echo processes are started nearly simultaneously, and race to make the first write to the stdout descriptor they share with each other and the julia parent process. Julia lets you pipe the output from both of these processes to another program:julia> run(pipeline(`echo world` & `echo hello`, `sort`));\\nhello\\nworldIn terms of UNIX plumbing, what\\'s happening here is that a single UNIX pipe object is created and written to by both echo processes, and the other end of the pipe is read from by the sort command.IO redirection can be accomplished by passing keyword arguments stdin, stdout, and stderr to the pipeline function:pipeline(`do_work`, stdout=pipeline(`sort`, \\\"out.txt\\\"), stderr=\\\"errs.txt\\\")\"\n},\n\n{\n    \"location\": \"manual/running-external-programs.html#Avoiding-Deadlock-in-Pipelines-1\",\n    \"page\": \"Running External Programs\",\n    \"title\": \"Avoiding Deadlock in Pipelines\",\n    \"category\": \"section\",\n    \"text\": \"When reading and writing to both ends of a pipeline from a single process, it is important to avoid forcing the kernel to buffer all of the data.For example, when reading all of the output from a command, call read(out, String), not wait(process), since the former will actively consume all of the data written by the process, whereas the latter will attempt to store the data in the kernel\\'s buffers while waiting for a reader to be connected.Another common solution is to separate the reader and writer of the pipeline into separate Tasks:writer = @async write(process, \\\"data\\\")\\nreader = @async do_compute(read(process, String))\\nwait(process)\\nfetch(reader)\"\n},\n\n{\n    \"location\": \"manual/running-external-programs.html#Complex-Example-1\",\n    \"page\": \"Running External Programs\",\n    \"title\": \"Complex Example\",\n    \"category\": \"section\",\n    \"text\": \"The combination of a high-level programming language, a first-class command abstraction, and automatic setup of pipes between processes is a powerful one. To give some sense of the complex pipelines that can be created easily, here are some more sophisticated examples, with apologies for the excessive use of Perl one-liners:julia> prefixer(prefix, sleep) = `perl -nle \\'$|=1; print \\\"\\'$prefix\\' \\\", $_; sleep \\'$sleep\\';\\'`;\\n\\njulia> run(pipeline(`perl -le \\'$|=1; for(0..5){ print; sleep 1 }\\'`, prefixer(\\\"A\\\",2) & prefixer(\\\"B\\\",2)));\\nB 0\\nA 1\\nB 2\\nA 3\\nB 4\\nA 5This is a classic example of a single producer feeding two concurrent consumers: one perl process generates lines with the numbers 0 through 5 on them, while two parallel processes consume that output, one prefixing lines with the letter \\\"A\\\", the other with the letter \\\"B\\\". Which consumer gets the first line is non-deterministic, but once that race has been won, the lines are consumed alternately by one process and then the other. (Setting $|=1 in Perl causes each print statement to flush the stdout handle, which is necessary for this example to work. Otherwise all the output is buffered and printed to the pipe at once, to be read by just one consumer process.)Here is an even more complex multi-stage producer-consumer example:julia> run(pipeline(`perl -le \\'$|=1; for(0..5){ print; sleep 1 }\\'`,\\n           prefixer(\\\"X\\\",3) & prefixer(\\\"Y\\\",3) & prefixer(\\\"Z\\\",3),\\n           prefixer(\\\"A\\\",2) & prefixer(\\\"B\\\",2)));\\nA X 0\\nB Y 1\\nA Z 2\\nB X 3\\nA Y 4\\nB Z 5This example is similar to the previous one, except there are two stages of consumers, and the stages have different latency so they use a different number of parallel workers, to maintain saturated throughput.We strongly encourage you to try all these examples to see how they work.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Calling C and Fortran Code\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Calling-C-and-Fortran-Code-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Calling C and Fortran Code\",\n    \"category\": \"section\",\n    \"text\": \"Though most code can be written in Julia, there are many high-quality, mature libraries for numerical computing already written in C and Fortran. To allow easy use of this existing code, Julia makes it simple and efficient to call C and Fortran functions. Julia has a \\\"no boilerplate\\\" philosophy: functions can be called directly from Julia without any \\\"glue\\\" code, code generation, or compilation \u2013 even from the interactive prompt. This is accomplished just by making an appropriate call with ccall syntax, which looks like an ordinary function call.The code to be called must be available as a shared library. Most C and Fortran libraries ship compiled as shared libraries already, but if you are compiling the code yourself using GCC (or Clang), you will need to use the -shared and -fPIC options. The machine instructions generated by Julia\\'s JIT are the same as a native C call would be, so the resulting overhead is the same as calling a library function from C code. (Non-library function calls in both C and Julia can be inlined and thus may have even less overhead than calls to shared library functions. When both libraries and executables are generated by LLVM, it is possible to perform whole-program optimizations that can even optimize across this boundary, but Julia does not yet support that. In the future, however, it may do so, yielding even greater performance gains.)Shared libraries and functions are referenced by a tuple of the form (:function, \\\"library\\\") or (\\\"function\\\", \\\"library\\\") where function is the C-exported function name. library refers to the shared library name: shared libraries available in the (platform-specific) load path will be resolved by name, and if necessary a direct path may be specified.A function name may be used alone in place of the tuple (just :function or \\\"function\\\"). In this case the name is resolved within the current process. This form can be used to call C library functions, functions in the Julia runtime, or functions in an application linked to Julia.By default, Fortran compilers generate mangled names (for example, converting function names to lowercase or uppercase, often appending an underscore), and so to call a Fortran function via ccall you must pass the mangled identifier corresponding to the rule followed by your Fortran compiler.  Also, when calling a Fortran function, all inputs must be passed as pointers to allocated values on the heap or stack. This applies not only to arrays and other mutable objects which are normally heap-allocated, but also to scalar values such as integers and floats which are normally stack-allocated and commonly passed in registers when using C or Julia calling conventions.Finally, you can use ccall to actually generate a call to the library function. Arguments to ccall are as follows:A (:function, \\\"library\\\") pair, which must be written as a literal constant,\\nOR\\na function pointer (for example, from dlsym).\\nReturn type (see below for mapping the declared C type to Julia)\\nThis argument will be evaluated at compile-time, when the containing method is defined.\\nA tuple of input types. The input types must be written as a literal tuple, not a tuple-valued variable or expression.\\nThis argument will be evaluated at compile-time, when the containing method is defined.\\nThe following arguments, if any, are the actual argument values passed to the function.As a complete but simple example, the following calls the clock function from the standard C library:julia> t = ccall((:clock, \\\"libc\\\"), Int32, ())\\n2292761\\n\\njulia> t\\n2292761\\n\\njulia> typeof(ans)\\nInt32clock takes no arguments and returns an Int32. One common gotcha is that a 1-tuple must be written with a trailing comma. For example, to call the getenv function to get a pointer to the value of an environment variable, one makes a call like this:julia> path = ccall((:getenv, \\\"libc\\\"), Cstring, (Cstring,), \\\"SHELL\\\")\\nCstring(@0x00007fff5fbffc45)\\n\\njulia> unsafe_string(path)\\n\\\"/bin/bash\\\"Note that the argument type tuple must be written as (Cstring,), rather than (Cstring). This is because (Cstring) is just the expression Cstring surrounded by parentheses, rather than a 1-tuple containing Cstring:julia> (Cstring)\\nCstring\\n\\njulia> (Cstring,)\\n(Cstring,)In practice, especially when providing reusable functionality, one generally wraps ccall uses in Julia functions that set up arguments and then check for errors in whatever manner the C or Fortran function indicates them, propagating to the Julia caller as exceptions. This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. For example, the getenv C library function is wrapped in the following Julia function, which is a simplified version of the actual definition from env.jl:function getenv(var::AbstractString)\\n    val = ccall((:getenv, \\\"libc\\\"),\\n                Cstring, (Cstring,), var)\\n    if val == C_NULL\\n        error(\\\"getenv: undefined variable: \\\", var)\\n    end\\n    unsafe_string(val)\\nendThe C getenv function indicates an error by returning NULL, but other standard C functions indicate errors in various different ways, including by returning -1, 0, 1 and other special values. This wrapper throws an exception clearly indicating the problem if the caller tries to get a non-existent environment variable:julia> getenv(\\\"SHELL\\\")\\n\\\"/bin/bash\\\"\\n\\njulia> getenv(\\\"FOOBAR\\\")\\ngetenv: undefined variable: FOOBARHere is a slightly more complex example that discovers the local machine\\'s hostname:function gethostname()\\n    hostname = Vector{UInt8}(128)\\n    ccall((:gethostname, \\\"libc\\\"), Int32,\\n          (Ptr{UInt8}, Csize_t),\\n          hostname, sizeof(hostname))\\n    hostname[end] = 0; # ensure null-termination\\n    return unsafe_string(pointer(hostname))\\nendThis example first allocates an array of bytes, then calls the C library function gethostname to fill the array in with the hostname, takes a pointer to the hostname buffer, and converts the pointer to a Julia string, assuming that it is a NUL-terminated C string. It is common for C libraries to use this pattern of requiring the caller to allocate memory to be passed to the callee and filled in. Allocation of memory from Julia like this is generally accomplished by creating an uninitialized array and passing a pointer to its data to the C function. This is why we don\\'t use the Cstring type here: as the array is uninitialized, it could contain NUL bytes. Converting to a Cstring as part of the ccall checks for contained NUL bytes and could therefore throw a conversion error.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Creating-C-Compatible-Julia-Function-Pointers-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Creating C-Compatible Julia Function Pointers\",\n    \"category\": \"section\",\n    \"text\": \"It is possible to pass Julia functions to native C functions that accept function pointer arguments. For example, to match C prototypes of the form:typedef returntype (*functiontype)(argumenttype, ...)The macro @cfunction generates the C-compatible function pointer for a call to a Julia function. Arguments to @cfunction are as follows:A Julia Function\\nReturn type\\nA literal tuple of input typesLike ccall, all of these arguments will be evaluated at compile-time, when the containing method is defined.Currently, only the platform-default C calling convention is supported. This means that @cfunction-generated pointers cannot be used in calls where WINAPI expects stdcall function on 32-bit windows, but can be used on WIN64 (where stdcall is unified with the C calling convention).A classic example is the standard C library qsort function, declared as:void qsort(void *base, size_t nmemb, size_t size,\\n           int (*compare)(const void*, const void*));The base argument is a pointer to an array of length nmemb, with elements of size bytes each. compare is a callback function which takes pointers to two elements a and b and returns an integer less/greater than zero if a should appear before/after b (or zero if any order is permitted). Now, suppose that we have a 1d array A of values in Julia that we want to sort using the qsort function (rather than Julia\\'s built-in sort function). Before we worry about calling qsort and passing arguments, we need to write a comparison function that works for some arbitrary objects (which define <):julia> function mycompare(a, b)::Cint\\n           return (a < b) ? -1 : ((a > b) ? +1 : 0)\\n       end\\nmycompare (generic function with 1 method)Notice that we have to be careful about the return type: qsort expects a function returning a C int, so we annotate the return type of the function to be sure it returns a Cint.In order to pass this function to C, we obtain its address using the macro @cfunction:julia> mycompare_c = @cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));@cfunction requires three arguments: the Julia function (mycompare), the return type (Cint), and a literal tuple of the input argument types, in this case to sort an array of Cdouble (Float64) elements.The final call to qsort looks like this:julia> A = [1.3, -2.7, 4.4, 3.1]\\n4-element Array{Float64,1}:\\n  1.3\\n -2.7\\n  4.4\\n  3.1\\n\\njulia> ccall(:qsort, Cvoid, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Cvoid}),\\n             A, length(A), sizeof(eltype(A)), mycompare_c)\\n\\njulia> A\\n4-element Array{Float64,1}:\\n -2.7\\n  1.3\\n  3.1\\n  4.4As can be seen, A is changed to the sorted array [-2.7, 1.3, 3.1, 4.4]. Note that Julia knows how to convert an array into a Ptr{Cdouble}, how to compute the size of a type in bytes (identical to C\\'s sizeof operator), and so on. For fun, try inserting a println(\\\"mycompare($a, $b)\\\") line into mycompare, which will allow you to see the comparisons that qsort is performing (and to verify that it is really calling the Julia function that you passed to it).\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Mapping-C-Types-to-Julia-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Mapping C Types to Julia\",\n    \"category\": \"section\",\n    \"text\": \"It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies can cause code that works correctly on one system to fail or produce indeterminate results on a different system.Note that no C header files are used anywhere in the process of calling C functions: you are responsible for making sure that your Julia types and call signatures accurately reflect those in the C header file. (The Clang package can be used to auto-generate Julia code from a C header file.)\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Auto-conversion:-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Auto-conversion:\",\n    \"category\": \"section\",\n    \"text\": \"Julia automatically inserts calls to the Base.cconvert function to convert each argument to the specified type. For example, the following call:ccall((:foo, \\\"libfoo\\\"), Cvoid, (Int32, Float64), x, y)will behave as if the following were written:ccall((:foo, \\\"libfoo\\\"), Cvoid, (Int32, Float64),\\n      Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),\\n      Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))Base.cconvert normally just calls convert, but can be defined to return an arbitrary new object more appropriate for passing to C. This should be used to perform all allocations of memory that will be accessed by the C code. For example, this is used to convert an Array of objects (e.g. strings) to an array of pointers.Base.unsafe_convert handles conversion to Ptr types. It is considered unsafe because converting an object to a native pointer can hide the object from the garbage collector, causing it to be freed prematurely.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Type-Correspondences:-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Type Correspondences:\",\n    \"category\": \"section\",\n    \"text\": \"First, a review of some relevant Julia type terminology:Syntax / Keyword Example Description\\nmutable struct String \\\"Leaf Type\\\" :: A group of related data that includes a type-tag, is managed by the Julia GC, and is defined by object-identity. The type parameters of a leaf type must be fully defined (no TypeVars are allowed) in order for the instance to be constructed.\\nabstract type Any, AbstractArray{T, N}, Complex{T} \\\"Super Type\\\" :: A super-type (not a leaf-type) that cannot be instantiated, but can be used to describe a group of types.\\nT{A} Vector{Int} \\\"Type Parameter\\\" :: A specialization of a type (typically used for dispatch or storage optimization).\\n  \\\"TypeVar\\\" :: The T in the type parameter declaration is referred to as a TypeVar (short for type variable).\\nprimitive type Int, Float64 \\\"Primitive Type\\\" :: A type with no fields, but a size. It is stored and defined by-value.\\nstruct Pair{Int, Int} \\\"Struct\\\" :: A type with all fields defined to be constant. It is defined by-value, and may be stored with a type-tag.\\n ComplexF64 (isbits) \\\"Is-Bits\\\"   :: A primitive type, or a struct type where all fields are other isbits types. It is defined by-value, and is stored without a type-tag.\\nstruct ...; end nothing \\\"Singleton\\\" :: a Leaf Type or Struct with no fields.\\n(...) or tuple(...) (1, 2, 3) \\\"Tuple\\\" :: an immutable data-structure similar to an anonymous struct type, or a constant array. Represented as either an array or a struct.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#man-bits-types-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Bits Types\",\n    \"category\": \"section\",\n    \"text\": \"There are several special types to be aware of, as no other type can be defined to behave the same:Float32\\nExactly corresponds to the float type in C (or REAL*4 in Fortran).\\nFloat64\\nExactly corresponds to the double type in C (or REAL*8 in Fortran).\\nComplexF32\\nExactly corresponds to the complex float type in C (or COMPLEX*8 in Fortran).\\nComplexF64\\nExactly corresponds to the complex double type in C (or COMPLEX*16 in Fortran).\\nSigned\\nExactly corresponds to the signed type annotation in C (or any INTEGER type in Fortran). Any Julia type that is not a subtype of Signed is assumed to be unsigned.Ref{T}\\nBehaves like a Ptr{T} that can manage its memory via the Julia GC.Array{T,N}\\nWhen an array is passed to C as a Ptr{T} argument, it is not reinterpret-cast: Julia requires that the element type of the array matches T, and the address of the first element is passed.\\nTherefore, if an Array contains data in the wrong format, it will have to be explicitly converted using a call such as trunc(Int32, a).\\nTo pass an array A as a pointer of a different type without converting the data beforehand (for example, to pass a Float64 array to a function that operates on uninterpreted bytes), you can declare the argument as Ptr{Cvoid}.\\nIf an array of eltype Ptr{T} is passed as a Ptr{Ptr{T}} argument, Base.cconvert will attempt to first make a null-terminated copy of the array with each element replaced by its Base.cconvert version. This allows, for example, passing an argv pointer array of type Vector{String} to an argument of type Ptr{Ptr{Cchar}}.On all systems we currently support, basic C/C++ value types may be translated to Julia types as follows. Every C type also has a corresponding Julia type with the same name, prefixed by C. This can help for writing portable code (and remembering that an int in C is not the same as an Int in Julia).System Independent:C name Fortran name Standard Julia Alias Julia Base Type\\nunsigned char CHARACTER Cuchar UInt8\\nbool (only in C++)  Cuchar UInt8\\nshort INTEGER*2, LOGICAL*2 Cshort Int16\\nunsigned short  Cushort UInt16\\nint, BOOL (C, typical) INTEGER*4, LOGICAL*4 Cint Int32\\nunsigned int  Cuint UInt32\\nlong long INTEGER*8, LOGICAL*8 Clonglong Int64\\nunsigned long long  Culonglong UInt64\\nintmax_t  Cintmax_t Int64\\nuintmax_t  Cuintmax_t UInt64\\nfloat REAL*4i Cfloat Float32\\ndouble REAL*8 Cdouble Float64\\ncomplex float COMPLEX*8 ComplexF32 Complex{Float32}\\ncomplex double COMPLEX*16 ComplexF64 Complex{Float64}\\nptrdiff_t  Cptrdiff_t Int\\nssize_t  Cssize_t Int\\nsize_t  Csize_t UInt\\nvoid   Cvoid\\nvoid and [[noreturn]] or _Noreturn   Union{}\\nvoid*   Ptr{Cvoid}\\nT* (where T represents an appropriately defined type)   Ref{T}\\nchar* (or char[], e.g. a string) CHARACTER*N  Cstring if NUL-terminated, or Ptr{UInt8} if not\\nchar** (or *char[])   Ptr{Ptr{UInt8}}\\njl_value_t* (any Julia Type)   Any\\njl_value_t** (a reference to a Julia Type)   Ref{Any}\\nva_arg   Not supported\\n... (variadic function specification)   T... (where T is one of the above types, variadic functions of different argument types are not supported)The Cstring type is essentially a synonym for Ptr{UInt8}, except the conversion to Cstring throws an error if the Julia string contains any embedded NUL characters (which would cause the string to be silently truncated if the C routine treats NUL as the terminator).  If you are passing a char* to a C routine that does not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that your Julia string does not contain NUL and want to skip the check, you can use Ptr{UInt8} as the argument type. Cstring can also be used as the ccall return type, but in that case it obviously does not introduce any extra checks and is only meant to improve readability of the call.System-dependent:C name Standard Julia Alias Julia Base Type\\nchar Cchar Int8 (x86, x86_64), UInt8 (powerpc, arm)\\nlong Clong Int (UNIX), Int32 (Windows)\\nunsigned long Culong UInt (UNIX), UInt32 (Windows)\\nwchar_t Cwchar_t Int32 (UNIX), UInt16 (Windows)note: Note\\nWhen calling Fortran, all inputs must be passed by pointers to heap- or stack-allocated values, so all type correspondences above should contain an additional Ptr{..} or Ref{..} wrapper around their type specification.warning: Warning\\nFor string arguments (char*) the Julia type should be Cstring (if NUL- terminated data is expected) or either Ptr{Cchar} or Ptr{UInt8} otherwise (these two pointer types have the same effect), as described above, not String. Similarly, for array arguments (T[] or T*), the Julia type should again be Ptr{T}, not Vector{T}.warning: Warning\\nJulia\\'s Char type is 32 bits, which is not the same as the wide character type (wchar_t or wint_t) on all platforms.warning: Warning\\nA return type of Union{} means the function will not return i.e. C++11 [[noreturn]] or C11 _Noreturn (e.g. jl_throw or longjmp). Do not use this for functions that return no value (void) but do return, use Cvoid instead.note: Note\\nFor wchar_t* arguments, the Julia type should be Cwstring (if the C routine expects a NUL-terminated string) or Ptr{Cwchar_t} otherwise. Note also that UTF-8 string data in Julia is internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making a copy (but using the Cwstring type will cause an error to be thrown if the string itself contains NUL characters).note: Note\\nC functions that take an argument of the type char** can be called by using a Ptr{Ptr{UInt8}} type within Julia. For example, C functions of the form:int main(int argc, char **argv);can be called via the following Julia code:argv = [ \\\"a.out\\\", \\\"arg1\\\", \\\"arg2\\\" ]\\nccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)note: Note\\nFor Fortran functions taking variable length strings of type character(len=*) the string lengths are provided as hidden arguments. Type and position of these arguments in the list are compiler specific, where compiler vendors usually default to using Csize_t as type and append the hidden arguments at the end of the argument list. While this behaviour is fixed for some compilers (GNU), others optionally permit placing hidden arguments directly after the character argument (Intel,PGI). For example, Fortran subroutines of the formsubroutine test(str1, str2)\\ncharacter(len=*) :: str1,str2can be called via the following Julia code, where the lengths are appendedstr1 = \\\"foo\\\"\\nstr2 = \\\"bar\\\"\\nccall(:test, Void, (Ptr{UInt8}, Ptr{UInt8}, Csize_t, Csize_t),\\n                    str1, str2, sizeof(str1), sizeof(str2))warning: Warning\\nFortran compilers may also add other hidden arguments for pointers, assumed-shape (:) and assumed-size (*) arrays. Such behaviour can be avoided by using ISO_C_BINDING and including bind(c) in the definition of the subroutine, which is strongly recommended for interoperable code. In this case there will be no hidden arguments, at the cost of some language features (e.g. only character(len=1) will be permitted to pass strings).note: Note\\nA C function declared to return Cvoid will return the value nothing in Julia.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Struct-Type-correspondences-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Struct Type correspondences\",\n    \"category\": \"section\",\n    \"text\": \"Composite types, aka struct in C or TYPE in Fortran90 (or STRUCTURE / RECORD in some variants of F77), can be mirrored in Julia by creating a struct definition with the same field layout.When used recursively, isbits types are stored inline. All other types are stored as a pointer to the data. When mirroring a struct used by-value inside another struct in C, it is imperative that you do not attempt to manually copy the fields over, as this will not preserve the correct field alignment. Instead, declare an isbits struct type and use that instead. Unnamed structs are not possible in the translation to Julia.Packed structs and union declarations are not supported by Julia.You can get a near approximation of a union if you know, a priori, the field that will have the greatest size (potentially including padding). When translating your fields to Julia, declare the Julia field to be only of that type.Arrays of parameters can be expressed with NTuple:in C:\\nstruct B {\\n    int A[3];\\n};\\nb_a_2 = B.A[2];\\n\\nin Julia:\\nstruct B\\n    A::NTuple{3, CInt}\\nend\\nb_a_2 = B.A[3]  # note the difference in indexing (1-based in Julia, 0-based in C)Arrays of unknown size (C99-compliant variable length structs specified by [] or [0]) are not directly supported. Often the best way to deal with these is to deal with the byte offsets directly. For example, if a C library declared a proper string type and returned a pointer to it:struct String {\\n    int strlen;\\n    char data[];\\n};In Julia, we can access the parts independently to make a copy of that string:str = from_c::Ptr{Cvoid}\\nlen = unsafe_load(Ptr{Cint}(str))\\nunsafe_string(str + Core.sizeof(Cint), len)\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Type-Parameters-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Type Parameters\",\n    \"category\": \"section\",\n    \"text\": \"The type arguments to ccall and @cfunction are evaluated statically, when the method containing the usage is defined. They therefore must take the form of a literal tuple, not a variable, and cannot reference local variables.This may sound like a strange restriction, but remember that since C is not a dynamic language like Julia, its functions can only accept argument types with a statically-known, fixed signature.However, while the type layout must be known statically to compute the intended C ABI, the static parameters of the function are considered to be part of this static environment. The static parameters of the function may be used as type parameters in the call signature, as long as they don\\'t affect the layout of the type. For example, f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x) is valid, since Ptr is always a word-size primitive type. But, g(x::T) where {T} = ccall(:notvalid, T, (T,), x) is not valid, since the type layout of T is not known statically.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#SIMD-Values-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"SIMD Values\",\n    \"category\": \"section\",\n    \"text\": \"Note: This feature is currently implemented on 64-bit x86 and AArch64 platforms only.If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of VecElement that naturally maps to the SIMD type.  Specifically:The tuple must be the same size as the SIMD type. For example, a tuple representing an __m128 on x86 must have a size of 16 bytes.\\nThe element type of the tuple must be an instance of VecElement{T} where T is a primitive type that is 1, 2, 4 or 8 bytes.For instance, consider this C routine that uses AVX intrinsics:#include <immintrin.h>\\n\\n__m256 dist( __m256 a, __m256 b ) {\\n    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),\\n                                        _mm256_mul_ps(b, b)));\\n}The following Julia code calls dist using ccall:const m256 = NTuple{8, VecElement{Float32}}\\n\\na = m256(ntuple(i -> VecElement(sin(Float32(i))), 8))\\nb = m256(ntuple(i -> VecElement(cos(Float32(i))), 8))\\n\\nfunction call_dist(a::m256, b::m256)\\n    ccall((:dist, \\\"libdist\\\"), m256, (m256, m256), a, b)\\nend\\n\\nprintln(call_dist(a,b))The host machine must have the requisite SIMD registers.  For example, the code above will not work on hosts without AVX support.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Memory-Ownership-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Memory Ownership\",\n    \"category\": \"section\",\n    \"text\": \"malloc/freeMemory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, just like in any C program. Do not try to free an object received from a C library with Libc.free in Julia, as this may result in the free function being called via the wrong libc library and cause Julia to crash. The reverse (passing an object allocated in Julia to be freed by an external library) is equally invalid.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#When-to-use-T,-Ptr{T}-and-Ref{T}-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"When to use T, Ptr{T} and Ref{T}\",\n    \"category\": \"section\",\n    \"text\": \"In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type T inside the ccall, as they are passed by value.  For C code accepting pointers, Ref{T} should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to Base.cconvert.  In contrast, pointers returned by the C function called should be declared to be of output type Ptr{T}, reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type Ptr{T} within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type Ref{T}, as Fortran passes all variables by pointers to memory locations. The return type should either be Cvoid for Fortran subroutines, or a T for Fortran functions returning the type T.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Mapping-C-Functions-to-Julia-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Mapping C Functions to Julia\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#ccall-/-@cfunction-argument-translation-guide-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"ccall / @cfunction argument translation guide\",\n    \"category\": \"section\",\n    \"text\": \"For translating a C argument list to Julia:T, where T is one of the primitive types: char, int, long, short, float, double, complex, enum or any of their typedef equivalents\\nT, where T is an equivalent Julia Bits Type (per the table above)\\nif T is an enum, the argument type should be equivalent to Cint or Cuint\\nargument value will be copied (passed by value)\\nstruct T (including typedef to a struct)\\nT, where T is a Julia leaf type\\nargument value will be copied (passed by value)\\nvoid*\\ndepends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list\\nthis argument may be declared as Ptr{Cvoid}, if it really is just an unknown pointer\\njl_value_t*\\nAny\\nargument value must be a valid Julia object\\njl_value_t**\\nRef{Any}\\nargument value must be a valid Julia object (or C_NULL)\\nT*\\nRef{T}, where T is the Julia type corresponding to T\\nargument value will be copied if it is an isbits type otherwise, the value must be a valid Julia object\\nT (*)(...) (e.g. a pointer to a function)\\nPtr{Cvoid} (you may need to use @cfunction explicitly to create this pointer)\\n... (e.g. a vararg)\\nT..., where T is the Julia type\\ncurrently unsupported by @cfunction\\nva_arg\\nnot supported by ccall or @cfunction\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#ccall-/-@cfunction-return-type-translation-guide-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"ccall / @cfunction return type translation guide\",\n    \"category\": \"section\",\n    \"text\": \"For translating a C return type to Julia:void\\nCvoid (this will return the singleton instance nothing::Cvoid)\\nT, where T is one of the primitive types: char, int, long, short, float, double, complex, enum or any of their typedef equivalents\\nT, where T is an equivalent Julia Bits Type (per the table above)\\nif T is an enum, the argument type should be equivalent to Cint or Cuint\\nargument value will be copied (returned by-value)\\nstruct T (including typedef to a struct)\\nT, where T is a Julia Leaf Type\\nargument value will be copied (returned by-value)\\nvoid*\\ndepends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list\\nthis argument may be declared as Ptr{Cvoid}, if it really is just an unknown pointer\\njl_value_t*\\nAny\\nargument value must be a valid Julia object\\njl_value_t**\\nPtr{Any} (Ref{Any} is invalid as a return type)\\nargument value must be a valid Julia object (or C_NULL)\\nT*\\nIf the memory is already owned by Julia, or is an isbits type, and is known to be non-null:\\nRef{T}, where T is the Julia type corresponding to T\\na return type of Ref{Any} is invalid, it should either be Any (corresponding to jl_value_t*) or Ptr{Any} (corresponding to jl_value_t**)\\nC MUST NOT modify the memory returned via Ref{T} if T is an isbits type\\nIf the memory is owned by C:\\nPtr{T}, where T is the Julia type corresponding to T\\nT (*)(...) (e.g. a pointer to a function)\\nPtr{Cvoid} (you may need to use @cfunction explicitly to create this pointer)\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Passing-Pointers-for-Modifying-Inputs-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Passing Pointers for Modifying Inputs\",\n    \"category\": \"section\",\n    \"text\": \"Because C doesn\\'t support multiple return values, often C functions will take pointers to data that the function will modify. To accomplish this within a ccall, you need to first encapsulate the value inside a Ref{T} of the appropriate type. When you pass this Ref object as an argument, Julia will automatically pass a C pointer to the encapsulated data:width = Ref{Cint}(0)\\nrange = Ref{Cfloat}(0)\\nccall(:foo, Cvoid, (Ref{Cint}, Ref{Cfloat}), width, range)Upon return, the contents of width and range can be retrieved (if they were changed by foo) by width[] and range[]; that is, they act like zero-dimensional arrays.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Special-Reference-Syntax-for-ccall-(deprecated):-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Special Reference Syntax for ccall (deprecated):\",\n    \"category\": \"section\",\n    \"text\": \"The & syntax is deprecated, use the Ref{T} argument type instead.A prefix & is used on an argument to ccall to indicate that a pointer to a scalar argument should be passed instead of the scalar value itself (required for all Fortran function arguments, as noted above). The following example computes a dot product using a BLAS function.function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})\\n    @assert length(DX) == length(DY)\\n    n = length(DX)\\n    incx = incy = 1\\n    product = ccall((:ddot_, \\\"libLAPACK\\\"),\\n                    Float64,\\n                    (Ref{Int32}, Ptr{Float64}, Ref{Int32}, Ptr{Float64}, Ref{Int32}),\\n                    n, DX, incx, DY, incy)\\n    return product\\nendThe meaning of prefix & is not quite the same as in C. In particular, any changes to the referenced variables will not be visible in Julia unless the type is mutable (declared via mutable struct). However, even for immutable structs it will not cause any harm for called functions to attempt such modifications (that is, writing through the passed pointers). Moreover, & may be used with any expression, such as &0 or &f(x).When a scalar value is passed with & as an argument of type Ptr{T}, the value will first be converted to type T.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Some-Examples-of-C-Wrappers-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Some Examples of C Wrappers\",\n    \"category\": \"section\",\n    \"text\": \"Here is a simple example of a C wrapper that returns a Ptr type:mutable struct gsl_permutation\\nend\\n\\n# The corresponding C signature is\\n#     gsl_permutation * gsl_permutation_alloc (size_t n);\\nfunction permutation_alloc(n::Integer)\\n    output_ptr = ccall(\\n        (:gsl_permutation_alloc, :libgsl), # name of C function and library\\n        Ptr{gsl_permutation},              # output type\\n        (Csize_t,),                        # tuple of input types\\n        n                                  # name of Julia variable to pass in\\n    )\\n    if output_ptr == C_NULL # Could not allocate memory\\n        throw(OutOfMemoryError())\\n    end\\n    return output_ptr\\nendThe GNU Scientific Library (here assumed to be accessible through :libgsl) defines an opaque pointer, gsl_permutation *, as the return type of the C function gsl_permutation_alloc. As user code never has to look inside the gsl_permutation struct, the corresponding Julia wrapper simply needs a new type declaration, gsl_permutation, that has no internal fields and whose sole purpose is to be placed in the type parameter of a Ptr type.  The return type of the ccall is declared as Ptr{gsl_permutation}, since the memory allocated and pointed to by output_ptr is controlled by C (and not Julia).The input n is passed by value, and so the function\\'s input signature is simply declared as (Csize_t,) without any Ref or Ptr necessary. (If the wrapper was calling a Fortran function instead, the corresponding function input signature should instead be (Ref{Csize_t},), since Fortran variables are passed by pointers.) Furthermore, n can be any type that is convertible to a Csize_t integer; the ccall implicitly calls Base.cconvert(Csize_t, n).Here is a second example wrapping the corresponding destructor:# The corresponding C signature is\\n#     void gsl_permutation_free (gsl_permutation * p);\\nfunction permutation_free(p::Ref{gsl_permutation})\\n    ccall(\\n        (:gsl_permutation_free, :libgsl), # name of C function and library\\n        Cvoid,                             # output type\\n        (Ref{gsl_permutation},),          # tuple of input types\\n        p                                 # name of Julia variable to pass in\\n    )\\nendHere, the input p is declared to be of type Ref{gsl_permutation}, meaning that the memory that p points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type Ptr{gsl_permutation}, but it is convertible using Base.cconvert and therefore can be used in the same (covariant) context of the input argument to a ccall. A pointer to memory allocated by Julia must be of type Ref{gsl_permutation}, to ensure that the memory address pointed to is valid and that Julia\\'s garbage collector manages the chunk of memory pointed to correctly. Therefore, the Ref{gsl_permutation} declaration allows pointers managed by C or Julia to be used.If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using p::Ptr{gsl_permutation} for the method signature of the wrapper and similarly in the ccall is also acceptable.Here is a third example passing Julia arrays:# The corresponding C signature is\\n#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,\\n#                                double result_array[])\\nfunction sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)\\n    if nmax < nmin\\n        throw(DomainError())\\n    end\\n    result_array = Vector{Cdouble}(nmax - nmin + 1)\\n    errorcode = ccall(\\n        (:gsl_sf_bessel_Jn_array, :libgsl), # name of C function and library\\n        Cint,                               # output type\\n        (Cint, Cint, Cdouble, Ref{Cdouble}),# tuple of input types\\n        nmin, nmax, x, result_array         # names of Julia variables to pass in\\n    )\\n    if errorcode != 0\\n        error(\\\"GSL error code $errorcode\\\")\\n    end\\n    return result_array\\nendThe C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array result_array. This variable can only be used with corresponding input type declaration Ref{Cdouble}, since its memory is allocated and managed by Julia, not C. The implicit call to Base.cconvert(Ref{Cdouble}, result_array) unpacks the Julia pointer to a Julia array data structure into a form understandable by C.Note that for this code to work correctly, result_array must be declared to be of type Ref{Cdouble} and not Ptr{Cdouble}. The memory is managed by Julia and the Ref signature alerts Julia\\'s garbage collector to keep managing the memory for result_array while the ccall executes. If Ptr{Cdouble} were used instead, the ccall may still work, but Julia\\'s garbage collector would not be aware that the memory declared for result_array is being used by the external C function. As a result, the code may produce a memory leak if result_array never gets freed by the garbage collector, or if the garbage collector prematurely frees result_array, the C function may end up throwing an invalid memory access exception.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Garbage-Collection-Safety-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Garbage Collection Safety\",\n    \"category\": \"section\",\n    \"text\": \"When passing data to a ccall, it is best to avoid using the pointer function. Instead define a convert method and pass the variables directly to the ccall. ccall automatically arranges that all of its arguments will be preserved from garbage collection until the call returns. If a C API will store a reference to memory allocated by Julia, after the ccall returns, you must arrange that the object remains visible to the garbage collector. The suggested way to handle this is to make a global variable of type Array{Ref,1} to hold these values, until the C library notifies you that it is finished with them.Whenever you have created a pointer to Julia data, you must ensure the original data exists until you are done with using the pointer. Many methods in Julia such as unsafe_load and String make copies of data instead of taking ownership of the buffer, so that it is safe to free (or alter) the original data without affecting Julia. A notable exception is unsafe_wrap which, for performance reasons, shares (or can be told to take ownership of) the underlying buffer.The garbage collector does not guarantee any order of finalization. That is, if a contained a reference to b and both a and b are due for garbage collection, there is no guarantee that b would be finalized after a. If proper finalization of a depends on b being valid, it must be handled in other ways.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Non-constant-Function-Specifications-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Non-constant Function Specifications\",\n    \"category\": \"section\",\n    \"text\": \"A (name, library) function specification must be a constant expression. However, it is possible to use computed values as function names by staging through eval as follows:@eval ccall(($(string(\\\"a\\\", \\\"b\\\")), \\\"lib\\\"), ...This expression constructs a name using string, then substitutes this name into a new ccall expression, which is then evaluated. Keep in mind that eval only operates at the top level, so within this expression local variables will not be available (unless their values are substituted with $). For this reason, eval is typically only used to form top-level definitions, for example when wrapping libraries that contain many similar functions. A similar example can be constructed for @cfunction.However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading. The next section discusses how to use indirect calls to efficiently accomplish a similar effect.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Indirect-Calls-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Indirect Calls\",\n    \"category\": \"section\",\n    \"text\": \"The first argument to ccall can also be an expression evaluated at run time. In this case, the expression must evaluate to a Ptr, which will be used as the address of the native function to call. This behavior occurs when the first ccall argument contains references to non-constants, such as local variables, function arguments, or non-constant globals.For example, you might look up the function via dlsym, then cache it in a shared reference for that session. For example:macro dlsym(func, lib)\\n    z = Ref{Ptr{Cvoid}}(C_NULL)\\n    quote\\n        let zlocal = $z[]\\n            if zlocal == C_NULL\\n                zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}\\n                $z[] = $zlocal\\n            end\\n            zlocal\\n        end\\n    end\\nend\\n\\nmylibvar = Libdl.dlopen(\\\"mylib\\\")\\nccall(@dlsym(\\\"myfunc\\\", mylibvar), Cvoid, ())\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Closure-cfunctions-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Closure cfunctions\",\n    \"category\": \"section\",\n    \"text\": \"The first argument to @cfunction can be marked with a $, in which case the return value will instead be a struct CFunction which closes over the argument. You must ensure that this return object is kept alive until all uses of it are done. The contents and code at the cfunction pointer will be erased via a finalizer when this reference is dropped and atexit. This is not usually needed, since this functionality is not present in C, but can be useful for dealing with ill-designed APIs which don\\'t provide a separate closure environment parameter.function qsort(a::Vector{T}, cmp) where T\\n    isbits(T) || throw(ArgumentError(\\\"this method can only qsort isbits arrays\\\"))\\n    callback = @cfunction $cmp Cint (Ref{T}, Ref{T})\\n    # Here, `callback` isa Base.CFunction, which will be converted to Ptr{Cvoid}\\n    # (and protected against finalization) by the ccall\\n    ccall(:qsort, Cvoid, (Ptr{T}, Csize_t, Csize_t, Ptr{Cvoid}),\\n        a, length(a), Base.elsize(a), callback)\\n    # We could instead use:\\n    #    GC.@preserve callback begin\\n    #        use(Base.unsafe_convert(Ptr{Cvoid}, callback))\\n    #    end\\n    # if we needed to use it outside of a `ccall`\\n    return a\\nend\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Closing-a-Library-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Closing a Library\",\n    \"category\": \"section\",\n    \"text\": \"It is sometimes useful to close (unload) a library so that it can be reloaded. For instance, when developing C code for use with Julia, one may need to compile, call the C code from Julia, then close the library, make an edit, recompile, and load in the new changes. One can either restart Julia or use the Libdl functions to manage the library explicitly, such as:lib = Libdl.dlopen(\\\"./my_lib.so\\\") # Open the library explicitly.\\nsym = Libdl.dlsym(lib, :my_fcn)   # Get a symbol for the function to call.\\nccall(sym, ...) # Use the pointer `sym` instead of the (symbol, library) tuple (remaining arguments are the same).\\nLibdl.dlclose(lib) # Close the library explicitly.Note that when using ccall with the tuple input (e.g., ccall((:my_fcn, \\\"./my_lib.so\\\"), ...)), the library is opened implicitly and it may not be explicitly closed.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Calling-Convention-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Calling Convention\",\n    \"category\": \"section\",\n    \"text\": \"The second argument to ccall can optionally be a calling convention specifier (immediately preceding return type). Without any specifier, the platform-default C calling convention is used. Other supported conventions are: stdcall, cdecl, fastcall, and thiscall (no-op on 64-bit Windows). For example (from base/libc.jl) we see the same gethostnameccall as above, but with the correct signature for Windows:hn = Vector{UInt8}(256)\\nerr = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))For more information, please see the LLVM Language Reference.There is one additional special calling convention llvmcall, which allows inserting calls to LLVM intrinsics directly. This can be especially useful when targeting unusual platforms such as GPGPUs. For example, for CUDA, we need to be able to read the thread index:ccall(\\\"llvm.nvvm.read.ptx.sreg.tid.x\\\", llvmcall, Int32, ())As with any ccall, it is essential to get the argument signature exactly correct. Also, note that there is no compatibility layer that ensures the intrinsic makes sense and works on the current target, unlike the equivalent Julia functions exposed by Core.Intrinsics.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Accessing-Global-Variables-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Accessing Global Variables\",\n    \"category\": \"section\",\n    \"text\": \"Global variables exported by native libraries can be accessed by name using the cglobal function. The arguments to cglobal are a symbol specification identical to that used by ccall, and a type describing the value stored in the variable:julia> cglobal((:errno, :libc), Int32)\\nPtr{Int32} @0x00007f418d0816b8The result is a pointer giving the address of the value. The value can be manipulated through this pointer using unsafe_load and unsafe_store!.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Accessing-Data-through-a-Pointer-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Accessing Data through a Pointer\",\n    \"category\": \"section\",\n    \"text\": \"The following methods are described as \\\"unsafe\\\" because a bad pointer or type declaration can cause Julia to terminate abruptly.Given a Ptr{T}, the contents of type T can generally be copied from the referenced memory into a Julia object using unsafe_load(ptr, [index]). The index argument is optional (default is 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar to the behavior of getindex and setindex! (e.g. [] access syntax).The return value will be a new object initialized to contain a copy of the contents of the referenced memory. The referenced memory can safely be freed or released.If T is Any, then the memory is assumed to contain a reference to a Julia object (a jl_value_t*), the result will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia\\'s garbage collector.  If the Ptr itself is actually a jl_value_t*, it can be converted back to a Julia object reference by unsafe_pointer_to_objref(ptr). (Julia values v can be converted to jl_value_t* pointers, as Ptr{Cvoid}, by calling pointer_from_objref(v).)The reverse operation (writing data to a Ptr{T}), can be performed using unsafe_store!(ptr, value, [index]). Currently, this is only supported for primitive types or other pointer-free (isbits) immutable struct types.Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved.If the pointer of interest is a plain-data array (primitive type or immutable struct), the function unsafe_wrap(Array, ptr,dims, own = false) may be more useful. The final parameter should be true if Julia should \\\"take ownership\\\" of the underlying buffer and call free(ptr) when the returned Array object is finalized.  If the own parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.Arithmetic on the Ptr type in Julia (e.g. using +) does not behave the same as C\\'s pointer arithmetic. Adding an integer to a Ptr in Julia always moves the pointer by some number of bytes, not elements. This way, the address values obtained from pointer arithmetic do not depend on the element types of pointers.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#Thread-safety-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"Thread-safety\",\n    \"category\": \"section\",\n    \"text\": \"Some C libraries execute their callbacks from a different thread, and since Julia isn\\'t thread-safe you\\'ll need to take some extra precautions. In particular, you\\'ll need to set up a two-layered system: the C callback should only schedule (via Julia\\'s event loop) the execution of your \\\"real\\\" callback. To do this, create an AsyncCondition object and wait on it:cond = Base.AsyncCondition()\\nwait(cond)The callback you pass to C should only execute a ccall to :uv_async_send, passing cond.handle as the argument, taking care to avoid any allocations or other interactions with the Julia runtime.Note that events may be coalesced, so multiple calls to uv_async_send may result in a single wakeup notification to the condition.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#More-About-Callbacks-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"More About Callbacks\",\n    \"category\": \"section\",\n    \"text\": \"For more details on how to pass callbacks to C libraries, see this blog post.\"\n},\n\n{\n    \"location\": \"manual/calling-c-and-fortran-code.html#C-1\",\n    \"page\": \"Calling C and Fortran Code\",\n    \"title\": \"C++\",\n    \"category\": \"section\",\n    \"text\": \"For direct C++ interfacing, see the Cxx package. For tools to create C++ bindings, see the CxxWrap package.\"\n},\n\n{\n    \"location\": \"manual/handling-operating-system-variation.html#\",\n    \"page\": \"Handling Operating System Variation\",\n    \"title\": \"Handling Operating System Variation\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/handling-operating-system-variation.html#Handling-Operating-System-Variation-1\",\n    \"page\": \"Handling Operating System Variation\",\n    \"title\": \"Handling Operating System Variation\",\n    \"category\": \"section\",\n    \"text\": \"When dealing with platform libraries, it is often necessary to provide special cases for various platforms. The variable Sys.KERNEL can be used to write these special cases. There are several functions in the Sys module intended to make this easier: isunix, islinux, isapple, isbsd, and iswindows. These may be used as follows:if Sys.iswindows()\\n    some_complicated_thing(a)\\nendNote that islinux and isapple are mutually exclusive subsets of isunix. Additionally, there is a macro @static which makes it possible to use these functions to conditionally hide invalid code, as demonstrated in the following examples.Simple blocks:ccall((@static Sys.iswindows() ? :_fopen : :fopen), ...)Complex blocks:@static if Sys.islinux()\\n    some_complicated_thing(a)\\nelse\\n    some_different_thing(a)\\nendWhen chaining conditionals (including if/elseif/end), the @static must be repeated for each level (parentheses optional, but recommended for readability):@static Sys.iswindows() ? :a : (@static Sys.isapple() ? :b : :c)\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"Environment Variables\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#Environment-Variables-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"Environment Variables\",\n    \"category\": \"section\",\n    \"text\": \"Julia may be configured with a number of environment variables, either in the usual way of the operating system, or in a portable way from within Julia. Suppose you want to set the environment variable JULIA_EDITOR to vim, then either type ENV[\\\"JULIA_EDITOR\\\"] = \\\"vim\\\" for instance in the REPL to make this change on a case by case basis, or add the same to the user configuration file ~/.julia/config/startup.jl in the user\\'s home directory to have a permanent effect. The current value of the same environment variable is determined by evaluating ENV[\\\"JULIA_EDITOR\\\"].The environment variables that Julia uses generally start with JULIA. If InteractiveUtils.versioninfo is called with verbose equal to true, then the output will list defined environment variables relevant for Julia, including those for which JULIA appears in the name.\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#File-locations-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"File locations\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_BINDIR-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_BINDIR\",\n    \"category\": \"section\",\n    \"text\": \"The absolute path of the directory containing the Julia executable, which sets the global variable Sys.BINDIR. If $JULIA_BINDIR is not set, then Julia determines the value Sys.BINDIR at run-time.The executable itself is one of$JULIA_BINDIR/julia\\n$JULIA_BINDIR/julia-debugby default.The global variable Base.DATAROOTDIR determines a relative path from Sys.BINDIR to the data directory associated with Julia. Then the path$JULIA_BINDIR/$DATAROOTDIR/julia/basedetermines the directory in which Julia initially searches for source files (via Base.find_source_file()).Likewise, the global variable Base.SYSCONFDIR determines a relative path to the configuration file directory. Then Julia searches for a startup.jl file at$JULIA_BINDIR/$SYSCONFDIR/julia/startup.jl\\n$JULIA_BINDIR/../etc/julia/startup.jlby default (via Base.load_julia_startup()).For example, a Linux installation with a Julia executable located at /bin/julia, a DATAROOTDIR of ../share, and a SYSCONFDIR of ../etc will have JULIA_BINDIR set to /bin, a source-file search path of/share/julia/baseand a global configuration search path of/etc/julia/startup.jl\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_LOAD_PATH-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_LOAD_PATH\",\n    \"category\": \"section\",\n    \"text\": \"A separated list of absolute paths that are to be appended to the variable LOAD_PATH. (In Unix-like systems, the path separator is :; in Windows systems, the path separator is ;.) The LOAD_PATH variable is where Base.require and Base.load_in_path() look for code; it defaults to the absolute path $JULIA_HOME/../share/julia/stdlib/v$(VERSION.major).$(VERSION.minor) so that, e.g., version 0.7 of Julia on a Linux system with a Julia executable at /bin/julia will have a default LOAD_PATH of /share/julia/stdlib/v0.7.\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_HISTORY-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_HISTORY\",\n    \"category\": \"section\",\n    \"text\": \"The absolute path REPL.find_hist_file() of the REPL\\'s history file. If $JULIA_HISTORY is not set, then REPL.find_hist_file() defaults to$HOME/.julia/logs/repl_history.jl\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_PKGRESOLVE_ACCURACY-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_PKGRESOLVE_ACCURACY\",\n    \"category\": \"section\",\n    \"text\": \"A positive Int that determines how much time the max-sum subroutine MaxSum.maxsum() of the package dependency resolver will devote to attempting satisfying constraints before giving up: this value is by default 1, and larger values correspond to larger amounts of time.Suppose the value of $JULIA_PKGRESOLVE_ACCURACY is n. Thenthe number of pre-decimation iterations is 20*n,\\nthe number of iterations between decimation steps is 10*n, and\\nat decimation steps, at most one in every 20*n packages is decimated.\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#External-applications-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"External applications\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_SHELL-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_SHELL\",\n    \"category\": \"section\",\n    \"text\": \"The absolute path of the shell with which Julia should execute external commands (via Base.repl_cmd()). Defaults to the environment variable $SHELL, and falls back to /bin/sh if $SHELL is unset.note: Note\\nOn Windows, this environment variable is ignored, and external commands are executed directly.\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_EDITOR-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_EDITOR\",\n    \"category\": \"section\",\n    \"text\": \"The editor returned by InteractiveUtils.editor() and used in, e.g., InteractiveUtils.edit, referring to the command of the preferred editor, for instance vim.$JULIA_EDITOR takes precedence over $VISUAL, which in turn takes precedence over $EDITOR. If none of these environment variables is set, then the editor is taken to be open on Windows and OS X, or /etc/alternatives/editor if it exists, or emacs otherwise.\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#Parallelization-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"Parallelization\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_CPU_THREADS-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_CPU_THREADS\",\n    \"category\": \"section\",\n    \"text\": \"Overrides the global variable Base.Sys.CPU_THREADS, the number of logical CPU cores available.\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_WORKER_TIMEOUT-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_WORKER_TIMEOUT\",\n    \"category\": \"section\",\n    \"text\": \"A Float64 that sets the value of Base.worker_timeout() (default: 60.0). This function gives the number of seconds a worker process will wait for a master process to establish a connection before dying.\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_NUM_THREADS-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_NUM_THREADS\",\n    \"category\": \"section\",\n    \"text\": \"An unsigned 64-bit integer (uint64_t) that sets the maximum number of threads available to Julia. If $JULIA_NUM_THREADS exceeds the number of available physical CPU cores, then the number of threads is set to the number of cores. If $JULIA_NUM_THREADS is not positive or is not set, or if the number of CPU cores cannot be determined through system calls, then the number of threads is set to 1.\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_THREAD_SLEEP_THRESHOLD-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_THREAD_SLEEP_THRESHOLD\",\n    \"category\": \"section\",\n    \"text\": \"If set to a string that starts with the case-insensitive substring \\\"infinite\\\", then spinning threads never sleep. Otherwise, $JULIA_THREAD_SLEEP_THRESHOLD is interpreted as an unsigned 64-bit integer (uint64_t) and gives, in nanoseconds, the amount of time after which spinning threads should sleep.\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_EXCLUSIVE-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_EXCLUSIVE\",\n    \"category\": \"section\",\n    \"text\": \"If set to anything besides 0, then Julia\\'s thread policy is consistent with running on a dedicated machine: the master thread is on proc 0, and threads are affinitized. Otherwise, Julia lets the operating system handle thread policy.\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#REPL-formatting-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"REPL formatting\",\n    \"category\": \"section\",\n    \"text\": \"Environment variables that determine how REPL output should be formatted at the terminal. Generally, these variables should be set to ANSI terminal escape sequences. Julia provides a high-level interface with much of the same functionality: see the section on The Julia REPL.\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_ERROR_COLOR-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_ERROR_COLOR\",\n    \"category\": \"section\",\n    \"text\": \"The formatting Base.error_color() (default: light red, \\\"\\\\033[91m\\\") that errors should have at the terminal.\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_WARN_COLOR-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_WARN_COLOR\",\n    \"category\": \"section\",\n    \"text\": \"The formatting Base.warn_color() (default: yellow, \\\"\\\\033[93m\\\") that warnings should have at the terminal.\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_INFO_COLOR-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_INFO_COLOR\",\n    \"category\": \"section\",\n    \"text\": \"The formatting Base.info_color() (default: cyan, \\\"\\\\033[36m\\\") that info should have at the terminal.\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_INPUT_COLOR-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_INPUT_COLOR\",\n    \"category\": \"section\",\n    \"text\": \"The formatting Base.input_color() (default: normal, \\\"\\\\033[0m\\\") that input should have at the terminal.\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_ANSWER_COLOR-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_ANSWER_COLOR\",\n    \"category\": \"section\",\n    \"text\": \"The formatting Base.answer_color() (default: normal, \\\"\\\\033[0m\\\") that output should have at the terminal.\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_STACKFRAME_LINEINFO_COLOR-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_STACKFRAME_LINEINFO_COLOR\",\n    \"category\": \"section\",\n    \"text\": \"The formatting Base.stackframe_lineinfo_color() (default: bold, \\\"\\\\033[1m\\\") that line info should have during a stack trace at the terminal.\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_STACKFRAME_FUNCTION_COLOR-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_STACKFRAME_FUNCTION_COLOR\",\n    \"category\": \"section\",\n    \"text\": \"The formatting Base.stackframe_function_color() (default: bold, \\\"\\\\033[1m\\\") that function calls should have during a stack trace at the terminal.\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#Debugging-and-profiling-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"Debugging and profiling\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_GC_ALLOC_POOL,-JULIA_GC_ALLOC_OTHER,-JULIA_GC_ALLOC_PRINT-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_GC_ALLOC_POOL, JULIA_GC_ALLOC_OTHER, JULIA_GC_ALLOC_PRINT\",\n    \"category\": \"section\",\n    \"text\": \"If set, these environment variables take strings that optionally start with the character \\'r\\', followed by a string interpolation of a colon-separated list of three signed 64-bit integers (int64_t). This triple of integers a:b:c represents the arithmetic sequence a, a + b, a + 2*b, ... c.If it\\'s the nth time that jl_gc_pool_alloc() has been called, and n   belongs to the arithmetic sequence represented by $JULIA_GC_ALLOC_POOL,   then garbage collection is forced.\\nIf it\\'s the nth time that maybe_collect() has been called, and n belongs   to the arithmetic sequence represented by $JULIA_GC_ALLOC_OTHER, then garbage   collection is forced.\\nIf it\\'s the nth time that jl_gc_collect() has been called, and n belongs   to the arithmetic sequence represented by $JULIA_GC_ALLOC_PRINT, then counts   for the number of calls to jl_gc_pool_alloc() and maybe_collect() are   printed.If the value of the environment variable begins with the character \\'r\\', then the interval between garbage collection events is randomized.note: Note\\nThese environment variables only have an effect if Julia was compiled with garbage-collection debugging (that is, if WITH_GC_DEBUG_ENV is set to 1 in the build configuration).\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_GC_NO_GENERATIONAL-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_GC_NO_GENERATIONAL\",\n    \"category\": \"section\",\n    \"text\": \"If set to anything besides 0, then the Julia garbage collector never performs \\\"quick sweeps\\\" of memory.note: Note\\nThis environment variable only has an effect if Julia was compiled with garbage-collection debugging (that is, if WITH_GC_DEBUG_ENV is set to 1 in the build configuration).\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_GC_WAIT_FOR_DEBUGGER-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_GC_WAIT_FOR_DEBUGGER\",\n    \"category\": \"section\",\n    \"text\": \"If set to anything besides 0, then the Julia garbage collector will wait for a debugger to attach instead of aborting whenever there\\'s a critical error.note: Note\\nThis environment variable only has an effect if Julia was compiled with garbage-collection debugging (that is, if WITH_GC_DEBUG_ENV is set to 1 in the build configuration).\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#ENABLE_JITPROFILING-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"ENABLE_JITPROFILING\",\n    \"category\": \"section\",\n    \"text\": \"If set to anything besides 0, then the compiler will create and register an event listener for just-in-time (JIT) profiling.note: Note\\nThis environment variable only has an effect if Julia was compiled with JIT profiling support, using eitherIntel\\'s VTune\u2122 Amplifier   (USE_INTEL_JITEVENTS set to 1 in the build configuration), or\\nOProfile (USE_OPROFILE_JITEVENTS set to 1   in the build configuration).\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_LLVM_ARGS-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_LLVM_ARGS\",\n    \"category\": \"section\",\n    \"text\": \"Arguments to be passed to the LLVM backend.\"\n},\n\n{\n    \"location\": \"manual/environment-variables.html#JULIA_DEBUG_LOADING-1\",\n    \"page\": \"Environment Variables\",\n    \"title\": \"JULIA_DEBUG_LOADING\",\n    \"category\": \"section\",\n    \"text\": \"If set, then Julia prints detailed information about the cache in the loading process of Base.require.\"\n},\n\n{\n    \"location\": \"manual/embedding.html#\",\n    \"page\": \"Embedding Julia\",\n    \"title\": \"Embedding Julia\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/embedding.html#Embedding-Julia-1\",\n    \"page\": \"Embedding Julia\",\n    \"title\": \"Embedding Julia\",\n    \"category\": \"section\",\n    \"text\": \"As we have seen in Calling C and Fortran Code, Julia has a simple and efficient way to call functions written in C. But there are situations where the opposite is needed: calling Julia function from C code. This can be used to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C#).\"\n},\n\n{\n    \"location\": \"manual/embedding.html#High-Level-Embedding-1\",\n    \"page\": \"Embedding Julia\",\n    \"title\": \"High-Level Embedding\",\n    \"category\": \"section\",\n    \"text\": \"We start with a simple C program that initializes Julia and calls some Julia code:#include <julia.h>\\nJULIA_DEFINE_FAST_TLS() // only define this once, in an executable (not in a shared library) if you want fast code.\\n\\nint main(int argc, char *argv[])\\n{\\n    /* required: setup the Julia context */\\n    jl_init();\\n\\n    /* run Julia commands */\\n    jl_eval_string(\\\"print(sqrt(2.0))\\\");\\n\\n    /* strongly recommended: notify Julia that the\\n         program is about to terminate. this allows\\n         Julia time to cleanup pending write requests\\n         and run all finalizers\\n    */\\n    jl_atexit_hook(0);\\n    return 0;\\n}In order to build this program you have to put the path to the Julia header into the include path and link against libjulia. For instance, when Julia is installed to $JULIA_DIR, one can compile the above test program test.c with gcc using:gcc -o test -fPIC -I$JULIA_DIR/include/julia -L$JULIA_DIR/lib test.c -ljulia $JULIA_DIR/lib/julia/libstdc++.so.6Then if the environment variable JULIA_BINDIR is set to $JULIA_DIR/bin, the output test program can be executed.Alternatively, look at the embedding.c program in the Julia source tree in the test/embedding/ folder. The file ui/repl.c program is another simple example of how to set jl_options options while linking against libjulia.The first thing that has to be done before calling any other Julia C function is to initialize Julia. This is done by calling jl_init, which tries to automatically determine Julia\\'s install location. If you need to specify a custom location, or specify which system image to load, use jl_init_with_image instead.The second statement in the test program evaluates a Julia statement using a call to jl_eval_string.Before the program terminates, it is strongly recommended to call jl_atexit_hook.  The above example program calls this before returning from main.note: Note\\nCurrently, dynamically linking with the libjulia shared library requires passing the RTLD_GLOBAL option. In Python, this looks like:>>> julia=CDLL(\\'./libjulia.dylib\\',RTLD_GLOBAL)\\n>>> julia.jl_init.argtypes = []\\n>>> julia.jl_init()\\n250593296note: Note\\nIf the julia program needs to access symbols from the main executable, it may be necessary to add -Wl,--export-dynamic linker flag at compile time on Linux in addition to the ones generated by julia-config.jl described below. This is not necessary when compiling a shared library.\"\n},\n\n{\n    \"location\": \"manual/embedding.html#Using-julia-config-to-automatically-determine-build-parameters-1\",\n    \"page\": \"Embedding Julia\",\n    \"title\": \"Using julia-config to automatically determine build parameters\",\n    \"category\": \"section\",\n    \"text\": \"The script julia-config.jl was created to aid in determining what build parameters are required by a program that uses embedded Julia.  This script uses the build parameters and system configuration of the particular Julia distribution it is invoked by to export the necessary compiler flags for an embedding program to interact with that distribution.  This script is located in the Julia shared data directory.\"\n},\n\n{\n    \"location\": \"manual/embedding.html#Example-1\",\n    \"page\": \"Embedding Julia\",\n    \"title\": \"Example\",\n    \"category\": \"section\",\n    \"text\": \"#include <julia.h>\\n\\nint main(int argc, char *argv[])\\n{\\n    jl_init();\\n    (void)jl_eval_string(\\\"println(sqrt(2.0))\\\");\\n    jl_atexit_hook(0);\\n    return 0;\\n}\"\n},\n\n{\n    \"location\": \"manual/embedding.html#On-the-command-line-1\",\n    \"page\": \"Embedding Julia\",\n    \"title\": \"On the command line\",\n    \"category\": \"section\",\n    \"text\": \"A simple use of this script is from the command line.  Assuming that julia-config.jl is located in /usr/local/julia/share/julia, it can be invoked on the command line directly and takes any combination of 3 flags:/usr/local/julia/share/julia/julia-config.jl\\nUsage: julia-config [--cflags|--ldflags|--ldlibs]If the above example source is saved in the file embed_example.c, then the following command will compile it into a running program on Linux and Windows (MSYS2 environment), or if on OS/X, then substitute clang for gcc.:/usr/local/julia/share/julia/julia-config.jl --cflags --ldflags --ldlibs | xargs gcc embed_example.c\"\n},\n\n{\n    \"location\": \"manual/embedding.html#Use-in-Makefiles-1\",\n    \"page\": \"Embedding Julia\",\n    \"title\": \"Use in Makefiles\",\n    \"category\": \"section\",\n    \"text\": \"But in general, embedding projects will be more complicated than the above, and so the following allows general makefile support as well \u2013 assuming GNU make because of the use of the shell macro expansions.  Additionally, though many times julia-config.jl may be found in the directory /usr/local, this is not necessarily the case, but Julia can be used to locate julia-config.jl too, and the makefile can be used to take advantage of that.  The above example is extended to use a Makefile:JL_SHARE = $(shell julia -e \\'print(joinpath(Sys.BINDIR, Base.DATAROOTDIR, \\\"julia\\\"))\\')\\nCFLAGS   += $(shell $(JL_SHARE)/julia-config.jl --cflags)\\nCXXFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)\\nLDFLAGS  += $(shell $(JL_SHARE)/julia-config.jl --ldflags)\\nLDLIBS   += $(shell $(JL_SHARE)/julia-config.jl --ldlibs)\\n\\nall: embed_exampleNow the build command is simply make.\"\n},\n\n{\n    \"location\": \"manual/embedding.html#Converting-Types-1\",\n    \"page\": \"Embedding Julia\",\n    \"title\": \"Converting Types\",\n    \"category\": \"section\",\n    \"text\": \"Real applications will not just need to execute expressions, but also return their values to the host program. jl_eval_string returns a jl_value_t*, which is a pointer to a heap-allocated Julia object. Storing simple data types like Float64 in this way is called boxing, and extracting the stored primitive data is called unboxing. Our improved sample program that calculates the square root of 2 in Julia and reads back the result in C looks as follows:jl_value_t *ret = jl_eval_string(\\\"sqrt(2.0)\\\");\\n\\nif (jl_typeis(ret, jl_float64_type)) {\\n    double ret_unboxed = jl_unbox_float64(ret);\\n    printf(\\\"sqrt(2.0) in C: %e \\\\n\\\", ret_unboxed);\\n}\\nelse {\\n    printf(\\\"ERROR: unexpected return type from sqrt(::Float64)\\\\n\\\");\\n}In order to check whether ret is of a specific Julia type, we can use the jl_isa, jl_typeis, or jl_is_... functions. By typing typeof(sqrt(2.0)) into the Julia shell we can see that the return type is Float64 (double in C). To convert the boxed Julia value into a C double the jl_unbox_float64 function is used in the above code snippet.Corresponding jl_box_... functions are used to convert the other way:jl_value_t *a = jl_box_float64(3.0);\\njl_value_t *b = jl_box_float32(3.0f);\\njl_value_t *c = jl_box_int32(3);As we will see next, boxing is required to call Julia functions with specific arguments.\"\n},\n\n{\n    \"location\": \"manual/embedding.html#Calling-Julia-Functions-1\",\n    \"page\": \"Embedding Julia\",\n    \"title\": \"Calling Julia Functions\",\n    \"category\": \"section\",\n    \"text\": \"While jl_eval_string allows C to obtain the result of a Julia expression, it does not allow passing arguments computed in C to Julia. For this you will need to invoke Julia functions directly, using jl_call:jl_function_t *func = jl_get_function(jl_base_module, \\\"sqrt\\\");\\njl_value_t *argument = jl_box_float64(2.0);\\njl_value_t *ret = jl_call1(func, argument);In the first step, a handle to the Julia function sqrt is retrieved by calling jl_get_function. The first argument passed to jl_get_function is a pointer to the Base module in which sqrt is defined. Then, the double value is boxed using jl_box_float64. Finally, in the last step, the function is called using jl_call1. jl_call0, jl_call2, and jl_call3 functions also exist, to conveniently handle different numbers of arguments. To pass more arguments, use jl_call:jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs)Its second argument args is an array of jl_value_t* arguments and nargs is the number of arguments.\"\n},\n\n{\n    \"location\": \"manual/embedding.html#Memory-Management-1\",\n    \"page\": \"Embedding Julia\",\n    \"title\": \"Memory Management\",\n    \"category\": \"section\",\n    \"text\": \"As we have seen, Julia objects are represented in C as pointers. This raises the question of who is responsible for freeing these objects.Typically, Julia objects are freed by a garbage collector (GC), but the GC does not automatically know that we are holding a reference to a Julia value from C. This means the GC can free objects out from under you, rendering pointers invalid.The GC can only run when Julia objects are allocated. Calls like jl_box_float64 perform allocation, and allocation might also happen at any point in running Julia code. However, it is generally safe to use pointers in between jl_... calls. But in order to make sure that values can survive jl_... calls, we have to tell Julia that we hold a reference to a Julia value. This can be done using the JL_GC_PUSH macros:jl_value_t *ret = jl_eval_string(\\\"sqrt(2.0)\\\");\\nJL_GC_PUSH1(&ret);\\n// Do something with ret\\nJL_GC_POP();The JL_GC_POP call releases the references established by the previous JL_GC_PUSH. Note that JL_GC_PUSH  is working on the stack, so it must be exactly paired with a JL_GC_POP before the stack frame is destroyed.Several Julia values can be pushed at once using the JL_GC_PUSH2 , JL_GC_PUSH3 , and JL_GC_PUSH4 macros. To push an array of Julia values one can use the  JL_GC_PUSHARGS macro, which can be used as follows:jl_value_t **args;\\nJL_GC_PUSHARGS(args, 2); // args can now hold 2 `jl_value_t*` objects\\nargs[0] = some_value;\\nargs[1] = some_other_value;\\n// Do something with args (e.g. call jl_... functions)\\nJL_GC_POP();The garbage collector also operates under the assumption that it is aware of every old-generation object pointing to a young-generation one. Any time a pointer is updated breaking that assumption, it must be signaled to the collector with the jl_gc_wb (write barrier) function like so:jl_value_t *parent = some_old_value, *child = some_young_value;\\n((some_specific_type*)parent)->field = child;\\njl_gc_wb(parent, child);It is in general impossible to predict which values will be old at runtime, so the write barrier must be inserted after all explicit stores. One notable exception is if the parent object was just allocated and garbage collection was not run since then. Remember that most jl_... functions can sometimes invoke garbage collection.The write barrier is also necessary for arrays of pointers when updating their data directly. For example:jl_array_t *some_array = ...; // e.g. a Vector{Any}\\nvoid **data = (void**)jl_array_data(some_array);\\njl_value_t *some_value = ...;\\ndata[0] = some_value;\\njl_gc_wb(some_array, some_value);\"\n},\n\n{\n    \"location\": \"manual/embedding.html#Manipulating-the-Garbage-Collector-1\",\n    \"page\": \"Embedding Julia\",\n    \"title\": \"Manipulating the Garbage Collector\",\n    \"category\": \"section\",\n    \"text\": \"There are some functions to control the GC. In normal use cases, these should not be necessary.Function Description\\njl_gc_collect() Force a GC run\\njl_gc_enable(0) Disable the GC, return previous state as int\\njl_gc_enable(1) Enable the GC,  return previous state as int\\njl_gc_is_enabled() Return current state as int\"\n},\n\n{\n    \"location\": \"manual/embedding.html#Working-with-Arrays-1\",\n    \"page\": \"Embedding Julia\",\n    \"title\": \"Working with Arrays\",\n    \"category\": \"section\",\n    \"text\": \"Julia and C can share array data without copying. The next example will show how this works.Julia arrays are represented in C by the datatype jl_array_t*. Basically, jl_array_t is a struct that contains:Information about the datatype\\nA pointer to the data block\\nInformation about the sizes of the arrayTo keep things simple, we start with a 1D array. Creating an array containing Float64 elements of length 10 is done by:jl_value_t* array_type = jl_apply_array_type((jl_value_t*)jl_float64_type, 1);\\njl_array_t* x          = jl_alloc_array_1d(array_type, 10);Alternatively, if you have already allocated the array you can generate a thin wrapper around its data:double *existingArray = (double*)malloc(sizeof(double)*10);\\njl_array_t *x = jl_ptr_to_array_1d(array_type, existingArray, 10, 0);The last argument is a boolean indicating whether Julia should take ownership of the data. If this argument is non-zero, the GC will call free on the data pointer when the array is no longer referenced.In order to access the data of x, we can use jl_array_data:double *xData = (double*)jl_array_data(x);Now we can fill the array:for(size_t i=0; i<jl_array_len(x); i++)\\n    xData[i] = i;Now let us call a Julia function that performs an in-place operation on x:jl_function_t *func = jl_get_function(jl_base_module, \\\"reverse!\\\");\\njl_call1(func, (jl_value_t*)x);By printing the array, one can verify that the elements of x are now reversed.\"\n},\n\n{\n    \"location\": \"manual/embedding.html#Accessing-Returned-Arrays-1\",\n    \"page\": \"Embedding Julia\",\n    \"title\": \"Accessing Returned Arrays\",\n    \"category\": \"section\",\n    \"text\": \"If a Julia function returns an array, the return value of jl_eval_string and jl_call can be cast to a jl_array_t*:jl_function_t *func  = jl_get_function(jl_base_module, \\\"reverse\\\");\\njl_array_t *y = (jl_array_t*)jl_call1(func, (jl_value_t*)x);Now the content of y can be accessed as before using jl_array_data. As always, be sure to keep a reference to the array while it is in use.\"\n},\n\n{\n    \"location\": \"manual/embedding.html#Multidimensional-Arrays-1\",\n    \"page\": \"Embedding Julia\",\n    \"title\": \"Multidimensional Arrays\",\n    \"category\": \"section\",\n    \"text\": \"Julia\\'s multidimensional arrays are stored in memory in column-major order. Here is some code that creates a 2D array and accesses its properties:// Create 2D array of float64 type\\njl_value_t *array_type = jl_apply_array_type(jl_float64_type, 2);\\njl_array_t *x  = jl_alloc_array_2d(array_type, 10, 5);\\n\\n// Get array pointer\\ndouble *p = (double*)jl_array_data(x);\\n// Get number of dimensions\\nint ndims = jl_array_ndims(x);\\n// Get the size of the i-th dim\\nsize_t size0 = jl_array_dim(x,0);\\nsize_t size1 = jl_array_dim(x,1);\\n\\n// Fill array with data\\nfor(size_t i=0; i<size1; i++)\\n    for(size_t j=0; j<size0; j++)\\n        p[j + size0*i] = i + j;Notice that while Julia arrays use 1-based indexing, the C API uses 0-based indexing (for example in calling jl_array_dim) in order to read as idiomatic C code.\"\n},\n\n{\n    \"location\": \"manual/embedding.html#Exceptions-1\",\n    \"page\": \"Embedding Julia\",\n    \"title\": \"Exceptions\",\n    \"category\": \"section\",\n    \"text\": \"Julia code can throw exceptions. For example, consider:jl_eval_string(\\\"this_function_does_not_exist()\\\");This call will appear to do nothing. However, it is possible to check whether an exception was thrown:if (jl_exception_occurred())\\n    printf(\\\"%s \\\\n\\\", jl_typeof_str(jl_exception_occurred()));If you are using the Julia C API from a language that supports exceptions (e.g. Python, C#, C++), it makes sense to wrap each call into libjulia with a function that checks whether an exception was thrown, and then rethrows the exception in the host language.\"\n},\n\n{\n    \"location\": \"manual/embedding.html#Throwing-Julia-Exceptions-1\",\n    \"page\": \"Embedding Julia\",\n    \"title\": \"Throwing Julia Exceptions\",\n    \"category\": \"section\",\n    \"text\": \"When writing Julia callable functions, it might be necessary to validate arguments and throw exceptions to indicate errors. A typical type check looks like:if (!jl_typeis(val, jl_float64_type)) {\\n    jl_type_error(function_name, (jl_value_t*)jl_float64_type, val);\\n}General exceptions can be raised using the functions:void jl_error(const char *str);\\nvoid jl_errorf(const char *fmt, ...);jl_error takes a C string, and jl_errorf is called like printf:jl_errorf(\\\"argument x = %d is too large\\\", x);where in this example x is assumed to be an integer.\"\n},\n\n{\n    \"location\": \"manual/code-loading.html#\",\n    \"page\": \"Code Loading\",\n    \"title\": \"Code Loading\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/code-loading.html#Code-Loading-1\",\n    \"page\": \"Code Loading\",\n    \"title\": \"Code Loading\",\n    \"category\": \"section\",\n    \"text\": \"Julia has two mechanisms for loading code:Code inclusion: e.g. include(\\\"source.jl\\\"). Inclusion allows you to split a single program across multiple source files. The expression include(\\\"source.jl\\\") causes the contents of the file source.jl to be evaluated in the global scope of the module where the include call occurs. If include(\\\"source.jl\\\") is called multiple times, source.jl is evaluated multiple times. The included path, source.jl, is interpreted relative to the file where the include call occurs. This makes it simple to relocate a subtree of source files. In the REPL, included paths are interpreted relative to the current working directory, pwd().\\nPackage loading: e.g. import X or using X. The import mechanism allows you to load a package\u2014i.e. an independent, reusable collection of Julia code, wrapped in a module\u2014and makes the resulting module available by the name X inside of the importing module. If the same X package is imported multiple times in the same Julia session, it is only loaded the first time\u2014on subsequent imports, the importing module gets a reference to the same module. It should be noted, however, that import X can load different packages in different contexts: X can refer to one package named X in the main project but potentially different packages named X in each dependency. More on this below.Code inclusion is quite straightforward: it simply parses and evaluates a source file in the context of the caller. Package loading is built on top of code inclusion and is quite a bit more complex. The rest of this chapter, therefore, focuses on the behavior and mechanics of package loading.note: Note\\nYou only need to read this chapter if you want to understand the technical details of package loading in Julia. If you just want to install and use packages, simply use Julia\\'s built-in package manager to add packages to your environment and write import X or using X in your code to load packages that you\\'ve added.A package is a source tree with a standard layout providing functionality that can be reused by other Julia projects. A package is loaded by import X or  using X statements. These statements also make the module named X, which results from loading the package code, available within the module where the import statement occurs. The meaning of X in import X is context-dependent: which X package is loaded depends on what code the statement occurs in. The effect of import X depends on two questions:What package is X in this context?\\nWhere can that X package be found?Understanding how Julia answers these questions is key to understanding package loading.\"\n},\n\n{\n    \"location\": \"manual/code-loading.html#Federation-of-packages-1\",\n    \"page\": \"Code Loading\",\n    \"title\": \"Federation of packages\",\n    \"category\": \"section\",\n    \"text\": \"Julia supports federated management of packages. This means that multiple independent parties can maintain both public and private packages and registries of them, and that projects can depend on a mix of public and private packages from different registries. Packages from various registries are installed and managed using a common set of tools and workflows. The Pkg package manager ships with Julia 0.7/1.0 and lets you install and manage dependencies of your projects, by creating and manipulating project files, which describe what your project depends on, and manifest files that snapshot exact versions of your project\\'s complete dependency graph.One consequence of federation is that there cannot be a central authority for package naming. Different entities may use the same name to refer to unrelated packages. This possibility is unavoidable since these entities do not coordinate and may not even know about each other. Because of the lack of a central naming authority, a single project can quite possibly end up depending on different packages with the same name. Julia\\'s package loading mechanism handles this by not requiring package names to be globally unique, even within the dependency graph of a single project. Instead, packages are identified by universally unique identifiers (UUIDs) which are assigned to them before they are registered. The question \\\"what is X?\\\" is answered by determining the UUID of X.Since the decentralized naming problem is somewhat abstract, it may help to walk through a concrete scenario to understand the issue. Suppose you\\'re developing an application called App, which uses two packages: Pub and  Priv. Priv is a private package that you created, whereas Pub is a public package that you use but don\\'t control. When you created Priv, there was no public package by that name. Subsequently, however, an unrelated package also named Priv has been published and become popular. In fact, the Pub package has started to use it. Therefore, when you next upgrade Pub to get the latest bug fixes and features, App will end up\u2014through no action of yours other than upgrading\u2014depending on two different packages named Priv. App has a direct dependency on your private Priv package, and an indirect dependency, through Pub, on the new public Priv package. Since these two Priv packages are different but both required for App to continue working correctly, the expression import Priv must refer to different Priv packages depending on whether it occurs in App\\'s code or in Pub\\'s code. Julia\\'s package loading mechanism allows this by distinguishing the two Priv packages by context and UUID. How this distinction works is determined by environments, as explained in the following sections.\"\n},\n\n{\n    \"location\": \"manual/code-loading.html#Environments-1\",\n    \"page\": \"Code Loading\",\n    \"title\": \"Environments\",\n    \"category\": \"section\",\n    \"text\": \"An environment determines what import X and using X mean in various code contexts and what files these statements cause to be loaded. Julia understands three kinds of environments:A project environment is a directory with a project file and an optional manifest file. The project file determines what the names and identities of the direct dependencies of a project are. The manifest file, if present, gives a complete dependency graph, including all direct and indirect dependencies, exact versions of each dependency, and sufficient information to locate and load the correct version.\\nA package directory is a directory containing the source trees of a set of packages as subdirectories. This kind of environment was the only kind that existed in Julia 0.6 and earlier. If X is a subdirectory of a package directory and X/src/X.jl exists, then the package X is available in the package directory environment and X/src/X.jl is the source file by which it is loaded.\\nA stacked environment is an ordered set of project environments and package directories, overlaid to make a single composite environment in which all the packages available in its constituent environments are available. Julia\\'s load path is a stacked environment, for example.These three kinds of environment each serve a different purpose:Project environments provide reproducibility. By checking a project environment into version control\u2014e.g. a git repository\u2014along with the rest of the project\\'s source code, you can reproduce the exact state of the project and all of its dependencies since the manifest file captures the exact version of every dependency and can be rematerialized easily.\\nPackage directories provide low-overhead convenience when a project environment would be overkill: are handy when you have a set of packages and just want to put them somewhere and use them as they are without having to create and maintain a project environment for them.\\nStacked environments allow for augmentation of the primary environment with additional tools. You can push an environment including development tools onto the stack and they will be available from the REPL and scripts but not from inside of packages.As an abstraction, an environment provides three maps: roots, graph and paths. When resolving the meaning of import X, roots and graph are used to determine the identity of X and answer the question \\\"what is X?\\\", while the paths map is used to locate the source code of X and answer the question \\\"where is X?\\\" The specific roles of the three maps are:roots: name::Symbol \u27f6 uuid::UUID\\nAn environment\\'s roots map assigns package names to UUIDs for all the top-level dependencies that the environment makes available to the main project (i.e. the ones that can be loaded in Main). When Julia encounters import X in the main project, it looks up the identity of X as roots[:X].\\ngraph: context::UUID \u27f6 name::Symbol \u27f6 uuid::UUID\\nAn environment\\'s graph is a multilevel map which assigns, for each context UUID, a map from names to UUIDs, similar to the roots map but specific to that context. When Julia sees import X in the code of the package whose UUID is context, it looks up the identity of X as graph[context][:X]. In particular, this means that import X can refer to different packages depending on context.\\npaths: uuid::UUID \u00d7 name::Symbol \u27f6 path::String\\nThe paths map assigns to each package UUID-name pair, the location of the entry-point source file of that package. After the identity of X in import X has been resolved to a UUID via roots or graph (depending on whether it is loaded from the main project or an dependency), Julia determines what file to load to acquire X by looking up paths[uuid,:X] in the environment. Including this file should create a module named X. After the first time this package is loaded, any import resolving to the same uuid will simply create a new binding to the same already-loaded package module.Each kind of environment defines these three maps differently, as detailed in the following sections.note: Note\\nFor clarity of exposition, the examples throughout this chapter include fully materialized data structures for roots, graph and paths. However, these maps are really only abstractions\u2014for efficiency, Julia\\'s package loading code does not actually materialize them. Instead, it queries them through internal APIs and lazily computes only as much of each structure as is necessary to load a given package.\"\n},\n\n{\n    \"location\": \"manual/code-loading.html#Project-environments-1\",\n    \"page\": \"Code Loading\",\n    \"title\": \"Project environments\",\n    \"category\": \"section\",\n    \"text\": \"A project environment is determined by a directory containing a project file, Project.toml, and optionally a manifest file, Manifest.toml. These files can also be named JuliaProject.toml and JuliaManifest.toml, in which case Project.toml and Manifest.toml are ignored; this allows for coexistence with other tools that might consider files named Project.toml and Manifest.toml significant. For pure Julia projects, however, the names Project.toml and Manifest.toml should be preferred. The roots, graph and paths maps of a project environment are defined as follows.The roots map of the environment is determined by the contents of the project file, specifically, its top-level name and uuid entries and its [deps] section (all optional). Consider the following example project file for the hypothetical application, App, as described above:name = \\\"App\\\"\\nuuid = \\\"8f986787-14fe-4607-ba5d-fbff2944afa9\\\"\\n\\n[deps]\\nPriv = \\\"ba13f791-ae1d-465a-978b-69c3ad90f72b\\\"\\nPub  = \\\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\\\"This project file implies the following roots map, if it were materialized as a Julia dictionary:roots = Dict(\\n    :App  => UUID(\\\"8f986787-14fe-4607-ba5d-fbff2944afa9\\\"),\\n    :Priv => UUID(\\\"ba13f791-ae1d-465a-978b-69c3ad90f72b\\\"),\\n    :Pub  => UUID(\\\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\\\"),\\n)Given this roots map, in the code of App the statement import Priv will cause Julia to look up roots[:Priv], which yields ba13f791-ae1d-465a-978b-69c3ad90f72b, the UUID of the Priv package that is to be loaded in that context. This UUID identifies which Priv package to load and use when the main application evaluates import Priv.The dependency graph of a project environment is determined by the contents of the manifest file, if present, or if there is no manifest file, graph is empty. A manifest file contains a stanza for each direct or indirect dependency of a project, including for each one, its UUID and a source tree hash or an explicit path to the source code. Consider the following example manifest file for App:[[Priv]] # the private one\\ndeps = [\\\"Pub\\\", \\\"Zebra\\\"]\\nuuid = \\\"ba13f791-ae1d-465a-978b-69c3ad90f72b\\\"\\npath = \\\"deps/Priv\\\"\\n\\n[[Priv]] # the public one\\nuuid = \\\"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\\\"\\ngit-tree-sha1 = \\\"1bf63d3be994fe83456a03b874b409cfd59a6373\\\"\\nversion = \\\"0.1.5\\\"\\n\\n[[Pub]]\\nuuid = \\\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\\\"\\ngit-tree-sha1 = \\\"9ebd50e2b0dd1e110e842df3b433cb5869b0dd38\\\"\\nversion = \\\"2.1.4\\\"\\n\\n  [Pub.deps]\\n  Priv = \\\"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\\\"\\n  Zebra = \\\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\\\"\\n\\n[[Zebra]]\\nuuid = \\\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\\\"\\ngit-tree-sha1 = \\\"e808e36a5d7173974b90a15a353b564f3494092f\\\"\\nversion = \\\"3.4.2\\\"This manifest file describes a possible complete dependency graph for the App project:There are two different Priv packages that the application needs\u2014a private one which is a direct dependency and a public one which is an indirect dependency through Pub:\\nThe private Priv depends on the Pub and Zebra packages.\\nThe public Priv has no dependencies.\\nThe application also depends on the Pub package, which in turn depends on the public Priv and the same Zebra package which the private Priv package depends on.A materialized representation of this dependency graph looks like this:graph = Dict{UUID,Dict{Symbol,UUID}}(\\n    # Priv \u2013 the private one:\\n    UUID(\\\"ba13f791-ae1d-465a-978b-69c3ad90f72b\\\") => Dict{Symbol,UUID}(\\n        :Pub   => UUID(\\\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\\\"),\\n        :Zebra => UUID(\\\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\\\"),\\n    ),\\n    # Priv \u2013 the public one:\\n    UUID(\\\"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\\\") => Dict{Symbol,UUID}(),\\n    # Pub:\\n    UUID(\\\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\\\") => Dict{Symbol,UUID}(\\n        :Priv  => UUID(\\\"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\\\"),\\n        :Zebra => UUID(\\\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\\\"),\\n    ),\\n    # Zebra:\\n    UUID(\\\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\\\") => Dict{Symbol,UUID}(),\\n)Given this dependency graph, when Julia sees import Priv in the Pub package\u2014which has UUID c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\u2014it looks up:graph[UUID(\\\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\\\")][:Priv]and gets 2d15fe94-a1f7-436c-a4d8-07a9a496e01c , which indicates that in the context of the Pub package,  import Priv refers to the public Priv package, rather than the private one which the app depends on directly. This is how the name Priv can refer to different packages in the main project than it does in one of the packages dependencies, which allows for name collisions in the package ecosystem.What happens if import Zebra is evaluated in the main App code base? Since Zebra does not appear in the project file, the import will fail even though Zebra does appear in the manifest file. Moreover, if import Zebra occurs in the public Priv package\u2014the one with UUID 2d15fe94-a1f7-436c-a4d8-07a9a496e01c\u2014then that would also fail since that Priv package has no declared dependencies in the manifest file and therefore cannot load any packages. The Zebra package can only be loaded by packages for which it appear as an explicit dependency in the manifest file: the  Pub package and one of the Priv packages.The paths map of a project environment is also determined by the manifest file if present and is empty if there is no manifest. The path of a package uuid named X is determined by these two rules:If the manifest stanza matching uuid has a path entry, use that path relative to the manifest file.\\nOtherwise, if the manifest stanza matching uuid has a git-tree-sha1 entry, compute a deterministic hash function of uuid and git-tree-sha1\u2014call it slug\u2014and look for packages/X/$slug in each directory in the Julia DEPOT_PATH global array. Use the first such directory that exists.If applying these rules doesn\\'t find a loadable path, the package should be considered not installed and the system should raise an error or prompt the user to install the appropriate package version.In the example manifest file above, to find the path of the first Priv package\u2014the one with UUID ba13f791-ae1d-465a-978b-69c3ad90f72b\u2014Julia looks for its stanza in the manifest file, sees that it has a path entry, looks at deps/Priv relative to the App project directory\u2014let\\'s suppose the App code lives in /home/me/projects/App\u2014sees that /home/me/projects/App/deps/Priv exists and therefore loads Priv from there.If, on the other hand, Julia was loading the other Priv package\u2014the one with UUID 2d15fe94-a1f7-436c-a4d8-07a9a496e01c\u2014it finds its stanza in the manifest, see that it does not have a path entry, but that it does have a git-tree-sha1 entry. It then computes the slug for this UUID/SHA-1 pair, which is HDkr (the exact details of this computation aren\\'t important, but it is consistent and deterministic). This means that the path to this Priv package will be packages/Priv/HDkr/src/Priv.jl in one of the package depots. Suppose the contents of DEPOT_PATH is [\\\"/users/me/.julia\\\", \\\"/usr/local/julia\\\"]; then Julia will look at the following paths to see if they exist:/home/me/.julia/packages/Priv/HDkr/src/Priv.jl\\n/usr/local/julia/packages/Priv/HDkr/src/Priv.jlJulia uses the first of these that exists to load the public Priv package.Here is a materialized paths map for the App project environment:paths = Dict{Tuple{UUID,Symbol},String}(\\n    # Priv \u2013 the private one:\\n    (UUID(\\\"ba13f791-ae1d-465a-978b-69c3ad90f72b\\\"), :Priv) =>\\n        # relative entry-point inside `App` repo:\\n        \\\"/home/me/projects/App/deps/Priv/src/Priv.jl\\\",\\n    # Priv \u2013 the public one:\\n    (UUID(\\\"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\\\"), :Priv) =>\\n        # package installed in the system depot:\\n        \\\"/usr/local/julia/packages/Priv/HDkr/src/Priv.jl\\\",\\n    # Pub:\\n    (UUID(\\\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\\\"), :Pub) =>\\n        # package installed in the user depot:\\n        \\\"/home/me/.julia/packages/Pub/oKpw/src/Pub.jl\\\",\\n    # Zebra:\\n    (UUID(\\\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\\\"), :Zebra) =>\\n        # package installed in the system depot:\\n        \\\"/usr/local/julia/packages/Zebra/me9k/src/Zebra.jl\\\",\\n)This example map includes three different kinds of package locations:The private Priv package is \\\"vendored\\\" inside of App repository.\\nThe public Priv and Zebra packages are in the system depot, where packages installed and managed by the system administrator live. These are available to all users on the system.\\nThe Pub package is in the user depot, where packages installed by the user live. These are only available to the user who installed them.\"\n},\n\n{\n    \"location\": \"manual/code-loading.html#Package-directories-1\",\n    \"page\": \"Code Loading\",\n    \"title\": \"Package directories\",\n    \"category\": \"section\",\n    \"text\": \"Package directories provide a kind of environment that approximates package loading in Julia 0.6 and earlier, and which resembles package loading in many other dynamic languages. The set of packages available in a package directory corresponds to the set of subdirectories it contains that look like packages: if X/src/X.jl is a file in a package directory, then X is considered to be a package and X/src/X.jl is the file you load to get X. Which packages can \\\"see\\\" each other as dependencies depends on whether they contain project files or not and what appears in the [deps] sections of those project files.The roots map is determined by the subdirectories X of a package directory for which X/src/X.jl exists and whether X/Project.toml exists and has a top-level uuid entry. Specifically :X => uuid goes in roots for each such X where uuid is defined as:If X/Project.toml exists and has a uuid entry, then uuid is that value.\\nIf X/Project.toml exists and but does not have a top-level UUID entry, uuid is a dummy UUID generated by hashing the canonical path of X/Project.toml.\\nIf X/Project.toml does not exist, then uuid is the all-zero nil UUID.The dependency graph of a project directory is determined by the presence and contents of project files in the subdirectory of each package. The rules are:If a package subdirectory has no project file, then it is omitted from graph and import statements in its code are treated as top-level, the same as the main project and REPL.\\nIf a package subdirectory has a project file, then the graph entry for its UUID is the [deps] map of the project file, which is considered to be empty if the section is absent.As an example, suppose a package directory has the following structure and content:Aardvark/\\n    src/Aardvark.jl:\\n        import Bobcat\\n        import Cobra\\n\\nBobcat/\\n    Project.toml:\\n        [deps]\\n        Cobra = \\\"4725e24d-f727-424b-bca0-c4307a3456fa\\\"\\n        Dingo = \\\"7a7925be-828c-4418-bbeb-bac8dfc843bc\\\"\\n\\n    src/Bobcat.jl:\\n        import Cobra\\n        import Dingo\\n\\nCobra/\\n    Project.toml:\\n        uuid = \\\"4725e24d-f727-424b-bca0-c4307a3456fa\\\"\\n        [deps]\\n        Dingo = \\\"7a7925be-828c-4418-bbeb-bac8dfc843bc\\\"\\n\\n    src/Cobra.jl:\\n        import Dingo\\n\\nDingo/\\n    Project.toml:\\n        uuid = \\\"7a7925be-828c-4418-bbeb-bac8dfc843bc\\\"\\n\\n    src/Dingo.jl:\\n        # no importsHere is a corresponding roots structure, materialized as a dictionary:roots = Dict{Symbol,UUID}(\\n    :Aardvark => UUID(\\\"00000000-0000-0000-0000-000000000000\\\"), # no project file, nil UUID\\n    :Bobcat   => UUID(\\\"85ad11c7-31f6-5d08-84db-0a4914d4cadf\\\"), # dummy UUID based on path\\n    :Cobra    => UUID(\\\"4725e24d-f727-424b-bca0-c4307a3456fa\\\"), # UUID from project file\\n    :Dingo    => UUID(\\\"7a7925be-828c-4418-bbeb-bac8dfc843bc\\\"), # UUID from project file\\n)Here is the corresponding graph structure, materialized as a dictionary:graph = Dict{UUID,Dict{Symbol,UUID}}(\\n    # Bobcat:\\n    UUID(\\\"85ad11c7-31f6-5d08-84db-0a4914d4cadf\\\") => Dict{Symbol,UUID}(\\n        :Cobra => UUID(\\\"4725e24d-f727-424b-bca0-c4307a3456fa\\\"),\\n        :Dingo => UUID(\\\"7a7925be-828c-4418-bbeb-bac8dfc843bc\\\"),\\n    ),\\n    # Cobra:\\n    UUID(\\\"4725e24d-f727-424b-bca0-c4307a3456fa\\\") => Dict{Symbol,UUID}(\\n        :Dingo => UUID(\\\"7a7925be-828c-4418-bbeb-bac8dfc843bc\\\"),\\n    ),\\n    # Dingo:\\n    UUID(\\\"7a7925be-828c-4418-bbeb-bac8dfc843bc\\\") => Dict{Symbol,UUID}(),\\n)A few general rules to note:A package without a project file can depend on any top-level dependency, and since every package in a package directory is available at the top-level, it can import all packages in the environment.\\nA package with a project file cannot depend on one without a project file since packages with project files can only load packages in graph and packages without project files do not appear in graph.\\nA package with a project file but no explicit UUID can only be depended on by packages without project files since dummy UUIDs assigned to these packages are strictly internal.Observe the following specific instances of these rules in our example:Aardvark can import on any of Bobcat, Cobra or Dingo; it does import Bobcat and Cobra.\\nBobcat can and does import both Cobra and Dingo, which both have project files with UUIDs and are declared as dependencies in Bobcat\\'s [deps] section.\\nBobcat cannot possibly depend on Aardvark since Aardvark does not have a project file.\\nCobra can and does import Dingo, which has a project file and UUID, and is declared as a dependency in Cobra\\'s  [deps] section.\\nCobra cannot depend on Aardvark or Bobcat since neither have real UUIDs.\\nDingo cannot import anything because it has a project file without a [deps] section.The paths map in a package directory is simple: it maps subdirectory names to their corresponding entry-point paths. In other words, if the path to our example project directory is /home/me/animals then the paths map would be materialized as this dictionary:paths = Dict{Tuple{UUID,Symbol},String}(\\n    (UUID(\\\"00000000-0000-0000-0000-000000000000\\\"), :Aardvark) =>\\n        \\\"/home/me/AnimalPackages/Aardvark/src/Aardvark.jl\\\",\\n    (UUID(\\\"85ad11c7-31f6-5d08-84db-0a4914d4cadf\\\"), :Bobcat) =>\\n        \\\"/home/me/AnimalPackages/Bobcat/src/Bobcat.jl\\\",\\n    (UUID(\\\"4725e24d-f727-424b-bca0-c4307a3456fa\\\"), :Cobra) =>\\n        \\\"/home/me/AnimalPackages/Cobra/src/Cobra.jl\\\",\\n    (UUID(\\\"7a7925be-828c-4418-bbeb-bac8dfc843bc\\\"), :Dingo) =>\\n        \\\"/home/me/AnimalPackages/Dingo/src/Dingo.jl\\\",\\n)Since all packages in a package directory environment are, by definition, subdirectories with the expected entry-point files, their paths map entries always have this form.\"\n},\n\n{\n    \"location\": \"manual/code-loading.html#Environment-stacks-1\",\n    \"page\": \"Code Loading\",\n    \"title\": \"Environment stacks\",\n    \"category\": \"section\",\n    \"text\": \"The third and final kind of environment is one that combines other environments by overlaying several of them, making the packages in each available in a single composite environment. These composite environments are called environment stacks. The Julia LOAD_PATH global defines an environment stack\u2014the environment in which the Julia process operates. If you want your Julia process to have access only to the packages in one project or package directory, make it the only entry in LOAD_PATH. It is often quite useful, however, to have access to some of your favorite tools\u2014standard libraries, profilers, debuggers, personal utilities, etc.\u2014even if they are not dependencies of the project you\\'re working on. By pushing an environment containing these tools onto the load path, you immediately have access to them in top-level code without needing to add them to your project.The mechanism for combining the roots, graph and paths data structures of the components of an environment stack is simple: they are simply merged as dictionaries, favoring earlier entries over later ones in the case of key collisions. In other words, if we have stack = [env\u2081, env\u2082, \u2026] then we have:roots = reduce(merge, reverse([roots\u2081, roots\u2082, \u2026]))\\ngraph = reduce(merge, reverse([graph\u2081, graph\u2082, \u2026]))\\npaths = reduce(merge, reverse([paths\u2081, paths\u2082, \u2026]))The subscripted roots\u1d62, graph\u1d62 and paths\u1d62 variables correspond to the subscripted environments, env\u1d62, contained stack. The reverse is present because merge favors the last argument rather than first when there are collisions between keys in its argument dictionaries. That\\'s all there is to stacked environments. There are a couple of noteworthy features of this design:The primary environment\u2014i.e.the first environment in a stack\u2014is faithfully embedded in a stacked environment. The full dependency graph of the first environment in a stack is guaranteed to be included intact in the stacked environment including the same versions of all dependencies.\\nPackages in non-primary environments can end up using incompatible versions of their dependencies even if their own environments are entirely compatible. This can happen when one of their dependencies is shadowed by a version in an earlier environment in the stack.Since the primary environment is typically the environment of a project you\\'re working on, while environments later in the stack contain additional tools, this is the right tradeoff: it\\'s better to break your dev tools but keep the project working. When such incompatibilities occur, you\\'ll typically want to upgrade your dev tools to versions that are compatible with the main project.\"\n},\n\n{\n    \"location\": \"manual/code-loading.html#Conclusion-1\",\n    \"page\": \"Code Loading\",\n    \"title\": \"Conclusion\",\n    \"category\": \"section\",\n    \"text\": \"Federated package management and precise software reproducibility are difficult but worthy goals in a package system. In combination, these goals lead to a more complex package loading mechanism than most dynamic languages have, but it also yields scalability and reproducibility that is more commonly associated with static languages. Fortunately, most Julia users can remain oblivious to the technical details of code loading and simply use the built-in package manager to add a package X to the appropriate project and manifest files and then write import X to load X without a further thought.\"\n},\n\n{\n    \"location\": \"manual/profile.html#\",\n    \"page\": \"Profiling\",\n    \"title\": \"Profiling\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/profile.html#Profiling-1\",\n    \"page\": \"Profiling\",\n    \"title\": \"Profiling\",\n    \"category\": \"section\",\n    \"text\": \"The Profile module provides tools to help developers improve the performance of their code. When used, it takes measurements on running code, and produces output that helps you understand how much time is spent on individual line(s). The most common usage is to identify \\\"bottlenecks\\\" as targets for optimization.Profile implements what is known as a \\\"sampling\\\" or statistical profiler.  It works by periodically taking a backtrace during the execution of any task. Each backtrace captures the currently-running function and line number, plus the complete chain of function calls that led to this line, and hence is a \\\"snapshot\\\" of the current state of execution.If much of your run time is spent executing a particular line of code, this line will show up frequently in the set of all backtraces. In other words, the \\\"cost\\\" of a given line\u2013or really, the cost of the sequence of function calls up to and including this line\u2013is proportional to how often it appears in the set of all backtraces.A sampling profiler does not provide complete line-by-line coverage, because the backtraces occur at intervals (by default, 1 ms on Unix systems and 10 ms on Windows, although the actual scheduling is subject to operating system load). Moreover, as discussed further below, because samples are collected at a sparse subset of all execution points, the data collected by a sampling profiler is subject to statistical noise.Despite these limitations, sampling profilers have substantial strengths:You do not have to make any modifications to your code to take timing measurements (in contrast to the alternative instrumenting profiler).\\nIt can profile into Julia\\'s core code and even (optionally) into C and Fortran libraries.\\nBy running \\\"infrequently\\\" there is very little performance overhead; while profiling, your code can run at nearly native speed.For these reasons, it\\'s recommended that you try using the built-in sampling profiler before considering any alternatives.\"\n},\n\n{\n    \"location\": \"manual/profile.html#Basic-usage-1\",\n    \"page\": \"Profiling\",\n    \"title\": \"Basic usage\",\n    \"category\": \"section\",\n    \"text\": \"Let\\'s work with a simple test case:julia> function myfunc()\\n           A = rand(200, 200, 400)\\n           maximum(A)\\n       endIt\\'s a good idea to first run the code you intend to profile at least once (unless you want to profile Julia\\'s JIT-compiler):julia> myfunc() # run once to force compilationNow we\\'re ready to profile this function:julia> using Profile\\n\\njulia> @profile myfunc()To see the profiling results, there is a graphical browser available, but here we\\'ll use the text-based display that comes with the standard library:julia> Profile.print()\\n80 ./event.jl:73; (::Base.REPL.##1#2{Base.REPL.REPLBackend})()\\n 80 ./REPL.jl:97; macro expansion\\n  80 ./REPL.jl:66; eval_user_input(::Any, ::Base.REPL.REPLBackend)\\n   80 ./boot.jl:235; eval(::Module, ::Any)\\n    80 ./<missing>:?; anonymous\\n     80 ./profile.jl:23; macro expansion\\n      52 ./REPL[1]:2; myfunc()\\n       38 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type{B...\\n        38 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr{F...\\n       14 ./random.jl:278; rand\\n        14 ./random.jl:277; rand\\n         14 ./random.jl:366; rand\\n          14 ./random.jl:369; rand\\n      28 ./REPL[1]:3; myfunc()\\n       28 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinear,...\\n        3  ./reduce.jl:426; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...\\n        25 ./reduce.jl:428; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...Each line of this display represents a particular spot (line number) in the code. Indentation is used to indicate the nested sequence of function calls, with more-indented lines being deeper in the sequence of calls. In each line, the first \\\"field\\\" is the number of backtraces (samples) taken at this line or in any functions executed by this line. The second field is the file name and line number and the third field is the function name. Note that the specific line numbers may change as Julia\\'s code changes; if you want to follow along, it\\'s best to run this example yourself.In this example, we can see that the top level function called is in the file event.jl. This is the function that runs the REPL when you launch Julia. If you examine line 97 of REPL.jl, you\\'ll see this is where the function eval_user_input() is called. This is the function that evaluates what you type at the REPL, and since we\\'re working interactively these functions were invoked when we entered @profile myfunc(). The next line reflects actions taken in the @profile macro.The first line shows that 80 backtraces were taken at line 73 of event.jl, but it\\'s not that this line was \\\"expensive\\\" on its own: the third line reveals that all 80 of these backtraces were actually triggered inside its call to eval_user_input, and so on. To find out which operations are actually taking the time, we need to look deeper in the call chain.The first \\\"important\\\" line in this output is this one:52 ./REPL[1]:2; myfunc()REPL refers to the fact that we defined myfunc in the REPL, rather than putting it in a file; if we had used a file, this would show the file name. The [1] shows that the function myfunc was the first expression evaluated in this REPL session. Line 2 of myfunc() contains the call to rand, and there were 52 (out of 80) backtraces that occurred at this line. Below that, you can see a call to dsfmt_fill_array_close_open! inside dSFMT.jl.A little further down, you see:28 ./REPL[1]:3; myfunc()Line 3 of myfunc contains the call to maximum, and there were 28 (out of 80) backtraces taken here. Below that, you can see the specific places in base/reduce.jl that carry out the time-consuming operations in the maximum function for this type of input data.Overall, we can tentatively conclude that generating the random numbers is approximately twice as expensive as finding the maximum element. We could increase our confidence in this result by collecting more samples:julia> @profile (for i = 1:100; myfunc(); end)\\n\\njulia> Profile.print()\\n[....]\\n 3821 ./REPL[1]:2; myfunc()\\n  3511 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type...\\n   3511 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr...\\n  310  ./random.jl:278; rand\\n   [....]\\n 2893 ./REPL[1]:3; myfunc()\\n  2893 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinea...\\n   [....]In general, if you have N samples collected at a line, you can expect an uncertainty on the order of sqrt(N) (barring other sources of noise, like how busy the computer is with other tasks). The major exception to this rule is garbage collection, which runs infrequently but tends to be quite expensive. (Since Julia\\'s garbage collector is written in C, such events can be detected using the C=true output mode described below, or by using ProfileView.jl.)This illustrates the default \\\"tree\\\" dump; an alternative is the \\\"flat\\\" dump, which accumulates counts independent of their nesting:julia> Profile.print(format=:flat)\\n Count File          Line Function\\n  6714 ./<missing>     -1 anonymous\\n  6714 ./REPL.jl       66 eval_user_input(::Any, ::Base.REPL.REPLBackend)\\n  6714 ./REPL.jl       97 macro expansion\\n  3821 ./REPL[1]        2 myfunc()\\n  2893 ./REPL[1]        3 myfunc()\\n  6714 ./REPL[7]        1 macro expansion\\n  6714 ./boot.jl      235 eval(::Module, ::Any)\\n  3511 ./dSFMT.jl      84 dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_s...\\n  6714 ./event.jl      73 (::Base.REPL.##1#2{Base.REPL.REPLBackend})()\\n  6714 ./profile.jl    23 macro expansion\\n  3511 ./random.jl    431 rand!(::MersenneTwister, ::Array{Float64,3}, ::In...\\n   310 ./random.jl    277 rand\\n   310 ./random.jl    278 rand\\n   310 ./random.jl    366 rand\\n   310 ./random.jl    369 rand\\n  2893 ./reduce.jl    270 _mapreduce(::Base.#identity, ::Base.#scalarmax, :...\\n     5 ./reduce.jl    420 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\\n   253 ./reduce.jl    426 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\\n  2592 ./reduce.jl    428 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\\n    43 ./reduce.jl    429 mapreduce_impl(::Base.#identity, ::Base.#scalarma...If your code has recursion, one potentially-confusing point is that a line in a \\\"child\\\" function can accumulate more counts than there are total backtraces. Consider the following function definitions:dumbsum(n::Integer) = n == 1 ? 1 : 1 + dumbsum(n-1)\\ndumbsum3() = dumbsum(3)If you were to profile dumbsum3, and a backtrace was taken while it was executing dumbsum(1), the backtrace would look like this:dumbsum3\\n    dumbsum(3)\\n        dumbsum(2)\\n            dumbsum(1)Consequently, this child function gets 3 counts, even though the parent only gets one. The \\\"tree\\\" representation makes this much clearer, and for this reason (among others) is probably the most useful way to view the results.\"\n},\n\n{\n    \"location\": \"manual/profile.html#Accumulation-and-clearing-1\",\n    \"page\": \"Profiling\",\n    \"title\": \"Accumulation and clearing\",\n    \"category\": \"section\",\n    \"text\": \"Results from @profile accumulate in a buffer; if you run multiple pieces of code under @profile, then Profile.print() will show you the combined results. This can be very useful, but sometimes you want to start fresh; you can do so with Profile.clear().\"\n},\n\n{\n    \"location\": \"manual/profile.html#Options-for-controlling-the-display-of-profile-results-1\",\n    \"page\": \"Profiling\",\n    \"title\": \"Options for controlling the display of profile results\",\n    \"category\": \"section\",\n    \"text\": \"Profile.print has more options than we\\'ve described so far. Let\\'s see the full declaration:function print(io::IO = stdout, data = fetch(); kwargs...)Let\\'s first discuss the two positional arguments, and later the keyword arguments:io \u2013 Allows you to save the results to a buffer, e.g. a file, but the default is to print to stdout (the console).\\ndata \u2013 Contains the data you want to analyze; by default that is obtained from Profile.fetch(), which pulls out the backtraces from a pre-allocated buffer. For example, if you want to profile the profiler, you could say:\\ndata = copy(Profile.fetch())\\nProfile.clear()\\n@profile Profile.print(stdout, data) # Prints the previous results\\nProfile.print()                      # Prints results from Profile.print()The keyword arguments can be any combination of:format \u2013 Introduced above, determines whether backtraces are printed  with (default, :tree) or without (:flat) indentation indicating tree  structure.\\nC \u2013 If true, backtraces from C and Fortran code are shown (normally they are excluded). Try running the introductory example with Profile.print(C = true). This can be extremely helpful in deciding whether it\\'s Julia code or C code that is causing a bottleneck; setting C = true also improves the interpretability of the nesting, at the cost of longer profile dumps.\\ncombine \u2013 Some lines of code contain multiple operations; for example, s += A[i] contains both an array reference (A[i]) and a sum operation. These correspond to different lines in the generated machine code, and hence there may be two or more different addresses captured during backtraces on this line. combine = true lumps them together, and is probably what you typically want, but you can generate an output separately for each unique instruction pointer with combine = false.\\nmaxdepth \u2013 Limits frames at a depth higher than maxdepth in the :tree format.\\nsortedby \u2013 Controls the order in :flat format. :filefuncline (default) sorts by the source line, whereas :count sorts in order of number of collected samples.\\nnoisefloor \u2013 Limits frames that are below the heuristic noise floor of the sample (only applies to format :tree). A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which n <= noisefloor * \u221aN, where n is the number of samples on this line, and N is the number of samples for the callee.\\nmincount \u2013 Limits frames with less than mincount occurrences.File/function names are sometimes truncated (with ...), and indentation is truncated with a +n at the beginning, where n is the number of extra spaces that would have been inserted, had there been room. If you want a complete profile of deeply-nested code, often a good idea is to save to a file using a wide displaysize in an IOContext:open(\\\"/tmp/prof.txt\\\", \\\"w\\\") do s\\n    Profile.print(IOContext(s, :displaysize => (24, 500)))\\nend\"\n},\n\n{\n    \"location\": \"manual/profile.html#Configuration-1\",\n    \"page\": \"Profiling\",\n    \"title\": \"Configuration\",\n    \"category\": \"section\",\n    \"text\": \"@profile just accumulates backtraces, and the analysis happens when you call Profile.print(). For a long-running computation, it\\'s entirely possible that the pre-allocated buffer for storing backtraces will be filled. If that happens, the backtraces stop but your computation continues. As a consequence, you may miss some important profiling data (you will get a warning when that happens).You can obtain and configure the relevant parameters this way:Profile.init() # returns the current settings\\nProfile.init(n = 10^7, delay = 0.01)n is the total number of instruction pointers you can store, with a default value of 10^6. If your typical backtrace is 20 instruction pointers, then you can collect 50000 backtraces, which suggests a statistical uncertainty of less than 1%. This may be good enough for most applications.Consequently, you are more likely to need to modify delay, expressed in seconds, which sets the amount of time that Julia gets between snapshots to perform the requested computations. A very long-running job might not need frequent backtraces. The default setting is delay = 0.001. Of course, you can decrease the delay as well as increase it; however, the overhead of profiling grows once the delay becomes similar to the amount of time needed to take a backtrace (~30 microseconds on the author\\'s laptop).\"\n},\n\n{\n    \"location\": \"manual/profile.html#Memory-allocation-analysis-1\",\n    \"page\": \"Profiling\",\n    \"title\": \"Memory allocation analysis\",\n    \"category\": \"section\",\n    \"text\": \"One of the most common techniques to improve performance is to reduce memory allocation. The total amount of allocation can be measured with @time and @allocated, and specific lines triggering allocation can often be inferred from profiling via the cost of garbage collection that these lines incur. However, sometimes it is more efficient to directly measure the amount of memory allocated by each line of code.To measure allocation line-by-line, start Julia with the --track-allocation=<setting> command-line option, for which you can choose none (the default, do not measure allocation), user (measure memory allocation everywhere except Julia\\'s core code), or all (measure memory allocation at each line of Julia code). Allocation gets measured for each line of compiled code. When you quit Julia, the cumulative results are written to text files with .mem appended after the file name, residing in the same directory as the source file. Each line lists the total number of bytes allocated. The Coverage package contains some elementary analysis tools, for example to sort the lines in order of number of bytes allocated.In interpreting the results, there are a few important details. Under the user setting, the first line of any function directly called from the REPL will exhibit allocation due to events that happen in the REPL code itself. More significantly, JIT-compilation also adds to allocation counts, because much of Julia\\'s compiler is written in Julia (and compilation usually requires memory allocation). The recommended procedure is to force compilation by executing all the commands you want to analyze, then call Profile.clear_malloc_data() to reset all allocation counters.  Finally, execute the desired commands and quit Julia to trigger the generation of the .mem files.\"\n},\n\n{\n    \"location\": \"manual/stacktraces.html#\",\n    \"page\": \"Stack Traces\",\n    \"title\": \"Stack Traces\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/stacktraces.html#Stack-Traces-1\",\n    \"page\": \"Stack Traces\",\n    \"title\": \"Stack Traces\",\n    \"category\": \"section\",\n    \"text\": \"The StackTraces module provides simple stack traces that are both human readable and easy to use programmatically.\"\n},\n\n{\n    \"location\": \"manual/stacktraces.html#Viewing-a-stack-trace-1\",\n    \"page\": \"Stack Traces\",\n    \"title\": \"Viewing a stack trace\",\n    \"category\": \"section\",\n    \"text\": \"The primary function used to obtain a stack trace is stacktrace:6-element Array{Base.StackTraces.StackFrame,1}:\\n top-level scope\\n eval at boot.jl:317 [inlined]\\n eval(::Module, ::Expr) at REPL.jl:5\\n eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\\n macro expansion at REPL.jl:116 [inlined]\\n (::getfield(REPL, Symbol(\\\"##28#29\\\")){REPL.REPLBackend})() at event.jl:92Calling stacktrace() returns a vector of StackTraces.StackFrame s. For ease of use, the alias StackTraces.StackTrace can be used in place of Vector{StackFrame}. (Examples with [...] indicate that output may vary depending on how the code is run.)julia> example() = stacktrace()\\nexample (generic function with 1 method)\\n\\njulia> example()\\n7-element Array{Base.StackTraces.StackFrame,1}:\\n example() at REPL[1]:1\\n top-level scope\\n eval at boot.jl:317 [inlined]\\n[...]\\n\\njulia> @noinline child() = stacktrace()\\nchild (generic function with 1 method)\\n\\njulia> @noinline parent() = child()\\nparent (generic function with 1 method)\\n\\njulia> grandparent() = parent()\\ngrandparent (generic function with 1 method)\\n\\njulia> grandparent()\\n9-element Array{Base.StackTraces.StackFrame,1}:\\n child() at REPL[3]:1\\n parent() at REPL[4]:1\\n grandparent() at REPL[5]:1\\n[...]Note that when calling stacktrace() you\\'ll typically see a frame with eval at boot.jl. When calling stacktrace() from the REPL you\\'ll also have a few extra frames in the stack from REPL.jl, usually looking something like this:julia> example() = stacktrace()\\nexample (generic function with 1 method)\\n\\njulia> example()\\n7-element Array{Base.StackTraces.StackFrame,1}:\\n example() at REPL[1]:1\\n top-level scope\\n eval at boot.jl:317 [inlined]\\n eval(::Module, ::Expr) at REPL.jl:5\\n eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\\n macro expansion at REPL.jl:116 [inlined]\\n (::getfield(REPL, Symbol(\\\"##28#29\\\")){REPL.REPLBackend})() at event.jl:92\"\n},\n\n{\n    \"location\": \"manual/stacktraces.html#Extracting-useful-information-1\",\n    \"page\": \"Stack Traces\",\n    \"title\": \"Extracting useful information\",\n    \"category\": \"section\",\n    \"text\": \"Each StackTraces.StackFrame contains the function name, file name, line number, lambda info, a flag indicating whether the frame has been inlined, a flag indicating whether it is a C function (by default C functions do not appear in the stack trace), and an integer representation of the pointer returned by backtrace:julia> frame = stacktrace()[3]\\neval(::Module, ::Expr) at REPL.jl:5\\n\\njulia> frame.func\\n:eval\\n\\njulia> frame.file\\nSymbol(\\\"~/julia/usr/share/julia/stdlib/v0.7/REPL/src/REPL.jl\\\")\\n\\njulia> frame.line\\n5\\n\\njulia> top_frame.linfo\\nMethodInstance for eval(::Module, ::Expr)\\n\\njulia> top_frame.inlined\\nfalse\\n\\njulia> top_frame.from_c\\nfalsejulia> top_frame.pointer\\n0x00007f92d6293171This makes stack trace information available programmatically for logging, error handling, and more.\"\n},\n\n{\n    \"location\": \"manual/stacktraces.html#Error-handling-1\",\n    \"page\": \"Stack Traces\",\n    \"title\": \"Error handling\",\n    \"category\": \"section\",\n    \"text\": \"While having easy access to information about the current state of the callstack can be helpful in many places, the most obvious application is in error handling and debugging.julia> @noinline bad_function() = undeclared_variable\\nbad_function (generic function with 1 method)\\n\\njulia> @noinline example() = try\\n           bad_function()\\n       catch\\n           stacktrace()\\n       end\\nexample (generic function with 1 method)\\n\\njulia> example()\\n7-element Array{Base.StackTraces.StackFrame,1}:\\n example() at REPL[2]:4\\n top-level scope\\n eval at boot.jl:317 [inlined]\\n[...]You may notice that in the example above the first stack frame points points at line 4, where stacktrace is called, rather than line 2, where bad_function is called, and bad_function\\'s frame is missing entirely. This is understandable, given that stacktrace is called from the context of the catch. While in this example it\\'s fairly easy to find the actual source of the error, in complex cases tracking down the source of the error becomes nontrivial.This can be remedied by passing the result of catch_backtrace to stacktrace. Instead of returning callstack information for the current context, catch_backtrace returns stack information for the context of the most recent exception:julia> @noinline bad_function() = undeclared_variable\\nbad_function (generic function with 1 method)\\n\\njulia> @noinline example() = try\\n           bad_function()\\n       catch\\n           stacktrace(catch_backtrace())\\n       end\\nexample (generic function with 1 method)\\n\\njulia> example()\\n8-element Array{Base.StackTraces.StackFrame,1}:\\n bad_function() at REPL[1]:1\\n example() at REPL[2]:2\\n[...]Notice that the stack trace now indicates the appropriate line number and the missing frame.julia> @noinline child() = error(\\\"Whoops!\\\")\\nchild (generic function with 1 method)\\n\\njulia> @noinline parent() = child()\\nparent (generic function with 1 method)\\n\\njulia> @noinline function grandparent()\\n           try\\n               parent()\\n           catch err\\n               println(\\\"ERROR: \\\", err.msg)\\n               stacktrace(catch_backtrace())\\n           end\\n       end\\ngrandparent (generic function with 1 method)\\n\\njulia> grandparent()\\nERROR: Whoops!\\n10-element Array{Base.StackTraces.StackFrame,1}:\\n error at error.jl:33 [inlined]\\n child() at REPL[1]:1\\n parent() at REPL[2]:1\\n grandparent() at REPL[3]:3\\n[...]\"\n},\n\n{\n    \"location\": \"manual/stacktraces.html#Comparison-with-[backtrace](@ref)-1\",\n    \"page\": \"Stack Traces\",\n    \"title\": \"Comparison with backtrace\",\n    \"category\": \"section\",\n    \"text\": \"A call to backtrace returns a vector of Union{Ptr{Nothing}, Base.InterpreterIP}, which may then be passed into stacktrace for translation:julia> trace = backtrace()\\n18-element Array{Union{Ptr{Nothing}, Base.InterpreterIP},1}:\\n Ptr{Nothing} @0x00007fd8734c6209\\n Ptr{Nothing} @0x00007fd87362b342\\n Ptr{Nothing} @0x00007fd87362c136\\n Ptr{Nothing} @0x00007fd87362c986\\n Ptr{Nothing} @0x00007fd87362d089\\n Base.InterpreterIP(CodeInfo(:(begin\\n      Core.SSAValue(0) = backtrace()\\n      trace = Core.SSAValue(0)\\n      return Core.SSAValue(0)\\n  end)), 0x0000000000000000)\\n Ptr{Nothing} @0x00007fd87362e4cf\\n[...]\\n\\njulia> stacktrace(trace)\\n6-element Array{Base.StackTraces.StackFrame,1}:\\n top-level scope\\n eval at boot.jl:317 [inlined]\\n eval(::Module, ::Expr) at REPL.jl:5\\n eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\\n macro expansion at REPL.jl:116 [inlined]\\n (::getfield(REPL, Symbol(\\\"##28#29\\\")){REPL.REPLBackend})() at event.jl:92Notice that the vector returned by backtrace had 18 elements, while the vector returned by stacktrace only has 6. This is because, by default, stacktrace removes any lower-level C functions from the stack. If you want to include stack frames from C calls, you can do it like this:julia> stacktrace(trace, true)\\n21-element Array{Base.StackTraces.StackFrame,1}:\\n jl_apply_generic at gf.c:2167\\n do_call at interpreter.c:324\\n eval_value at interpreter.c:416\\n eval_body at interpreter.c:559\\n jl_interpret_toplevel_thunk_callback at interpreter.c:798\\n top-level scope\\n jl_interpret_toplevel_thunk at interpreter.c:807\\n jl_toplevel_eval_flex at toplevel.c:856\\n jl_toplevel_eval_in at builtins.c:624\\n eval at boot.jl:317 [inlined]\\n eval(::Module, ::Expr) at REPL.jl:5\\n jl_apply_generic at gf.c:2167\\n eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\\n jl_apply_generic at gf.c:2167\\n macro expansion at REPL.jl:116 [inlined]\\n (::getfield(REPL, Symbol(\\\"##28#29\\\")){REPL.REPLBackend})() at event.jl:92\\n jl_fptr_trampoline at gf.c:1838\\n jl_apply_generic at gf.c:2167\\n jl_apply at julia.h:1540 [inlined]\\n start_task at task.c:268\\n ip:0xffffffffffffffffIndividual pointers returned by backtrace can be translated into StackTraces.StackFrame s by passing them into StackTraces.lookup:julia> pointer = backtrace()[1];\\n\\njulia> frame = StackTraces.lookup(pointer)\\n1-element Array{Base.StackTraces.StackFrame,1}:\\n jl_apply_generic at gf.c:2167\\n\\njulia> println(\\\"The top frame is from $(frame[1].func)!\\\")\\nThe top frame is from jl_apply_generic!\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Performance Tips\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#man-performance-tips-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Performance Tips\",\n    \"category\": \"section\",\n    \"text\": \"In the following sections, we briefly go through a few techniques that can help make your Julia code run as fast as possible.\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Avoid-global-variables-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Avoid global variables\",\n    \"category\": \"section\",\n    \"text\": \"A global variable might have its value, and therefore its type, change at any point. This makes it difficult for the compiler to optimize code using global variables. Variables should be local, or passed as arguments to functions, whenever possible.Any code that is performance critical or being benchmarked should be inside a function.We find that global names are frequently constants, and declaring them as such greatly improves performance:const DEFAULT_VAL = 0Uses of non-constant globals can be optimized by annotating their types at the point of use:global x = rand(1000)\\n\\nfunction loop_over_global()\\n    s = 0.0\\n    for i in x::Vector{Float64}\\n        s += i\\n    end\\n    return s\\nendPassing arguments to functions is better style. It leads to more reusable code and clarifies what the inputs and outputs are.note: Note\\nAll code in the REPL is evaluated in global scope, so a variable defined and assigned at toplevel will be a global variable. Variables defined in at top level scope inside modules are also global.In the following REPL session:julia> x = 1.0is equivalent to:julia> global x = 1.0so all the performance issues discussed previously apply.\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Measure-performance-with-[@time](@ref)-and-pay-attention-to-memory-allocation-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Measure performance with @time and pay attention to memory allocation\",\n    \"category\": \"section\",\n    \"text\": \"A useful tool for measuring performance is the @time macro. We here repeat the example with the global variable above, but this time with the type annotation removed:julia> x = rand(1000);\\n\\njulia> function sum_global()\\n           s = 0.0\\n           for i in x\\n               s += i\\n           end\\n           return s\\n       end;\\n\\njulia> @time sum_global()\\n  0.017705 seconds (15.28 k allocations: 694.484 KiB)\\n496.84883432553846\\n\\njulia> @time sum_global()\\n  0.000140 seconds (3.49 k allocations: 70.313 KiB)\\n496.84883432553846On the first call (@time sum_global()) the function gets compiled. (If you\\'ve not yet used @time in this session, it will also compile functions needed for timing.)  You should not take the results of this run seriously. For the second run, note that in addition to reporting the time, it also indicated that a significant amount of memory was allocated. We are here just computing a sum over all elements in a vector of 64-bit floats so there should be no need to allocate memory (at least not on the heap which is what @time reports).Unexpected memory allocation is almost always a sign of some problem with your code, usually a problem with type-stability or creating many small temporary arrays. Consequently, in addition to the allocation itself, it\\'s very likely that the code generated for your function is far from optimal. Take such indications seriously and follow the advice below.If we instead pass x as an argument to the function it no longer allocates memory (the allocation reported below is due to running the @time macro in global scope) and is significantly faster after the first call:julia> x = rand(1000);\\n\\njulia> function sum_arg(x)\\n           s = 0.0\\n           for i in x\\n               s += i\\n           end\\n           return s\\n       end;\\n\\njulia> @time sum_arg(x)\\n  0.007701 seconds (821 allocations: 43.059 KiB)\\n496.84883432553846\\n\\njulia> @time sum_arg(x)\\n  0.000006 seconds (5 allocations: 176 bytes)\\n496.84883432553846The 5 allocations seen are from running the @time macro itself in global scope. If we instead run the timing in a function, we can see that indeed no allocations are performed:julia> time_sum(x) = @time sum_arg(x);\\n\\njulia> time_sum(x)\\n  0.000001 seconds\\n496.84883432553846In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In such cases, consider using one of the tools below to diagnose problems, or write a version of your function that separates allocation from its algorithmic aspects (see Pre-allocating outputs).note: Note\\nFor more serious benchmarking, consider the BenchmarkTools.jl package which among other things evaluates the function multiple times in order to reduce noise.\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#tools-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Tools\",\n    \"category\": \"section\",\n    \"text\": \"Julia and its package ecosystem includes tools that may help you diagnose problems and improve the performance of your code:Profiling allows you to measure the performance of your running code and identify lines that serve as bottlenecks. For complex projects, the ProfileView package can help you visualize your profiling results.\\nThe Traceur package can help you find common performance problems in your code.\\nUnexpectedly-large memory allocations\u2013as reported by @time, @allocated, or the profiler (through calls to the garbage-collection routines)\u2013hint that there might be issues with your code. If you don\\'t see another reason for the allocations, suspect a type problem.  You can also start Julia with the --track-allocation=user option and examine the resulting *.mem files to see information about where those allocations occur. See Memory allocation analysis.\\n@code_warntype generates a representation of your code that can be helpful in finding expressions that result in type uncertainty. See @code_warntype below.\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Avoid-containers-with-abstract-type-parameters-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Avoid containers with abstract type parameters\",\n    \"category\": \"section\",\n    \"text\": \"When working with parameterized types, including arrays, it is best to avoid parameterizing with abstract types where possible.Consider the following:julia> a = Real[]\\n0-element Array{Real,1}\\n\\njulia> push!(a, 1); push!(a, 2.0); push!(a, \u03c0)\\n3-element Array{Real,1}:\\n  1\\n  2.0\\n \u03c0 = 3.1415926535897...Because a is a an array of abstract type Real, it must be able to hold any Real value. Since Real objects can be of arbitrary size and structure, a must be represented as an array of pointers to individually allocated Real objects. However, if we instead only allow numbers of the same type, e.g. Float64, to be stored in a these can be stored more efficiently:julia> a = Float64[]\\n0-element Array{Float64,1}\\n\\njulia> push!(a, 1); push!(a, 2.0); push!(a,  \u03c0)\\n3-element Array{Float64,1}:\\n 1.0\\n 2.0\\n 3.141592653589793Assigning numbers into a will now convert them to Float64 and a will be stored as a contiguous block of 64-bit floating-point values that can be manipulated efficiently.See also the discussion under Parametric Types.\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Type-declarations-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Type declarations\",\n    \"category\": \"section\",\n    \"text\": \"In many languages with optional type declarations, adding declarations is the principal way to make code run faster. This is not the case in Julia. In Julia, the compiler generally knows the types of all function arguments, local variables, and expressions. However, there are a few specific instances where declarations are helpful.\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Avoid-fields-with-abstract-type-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Avoid fields with abstract type\",\n    \"category\": \"section\",\n    \"text\": \"Types can be declared without specifying the types of their fields:julia> struct MyAmbiguousType\\n           a\\n       endThis allows a to be of any type. This can often be useful, but it does have a downside: for objects of type MyAmbiguousType, the compiler will not be able to generate high-performance code. The reason is that the compiler uses the types of objects, not their values, to determine how to build code. Unfortunately, very little can be inferred about an object of type MyAmbiguousType:julia> b = MyAmbiguousType(\\\"Hello\\\")\\nMyAmbiguousType(\\\"Hello\\\")\\n\\njulia> c = MyAmbiguousType(17)\\nMyAmbiguousType(17)\\n\\njulia> typeof(b)\\nMyAmbiguousType\\n\\njulia> typeof(c)\\nMyAmbiguousTypeThe values of b and c have the same type, yet their underlying representation of data in memory is very different. Even if you stored just numeric values in field a, the fact that the memory representation of a UInt8 differs from a Float64 also means that the CPU needs to handle them using two different kinds of instructions. Since the required information is not available in the type, such decisions have to be made at run-time. This slows performance.You can do better by declaring the type of a. Here, we are focused on the case where a might be any one of several types, in which case the natural solution is to use parameters. For example:julia> mutable struct MyType{T<:AbstractFloat}\\n           a::T\\n       endThis is a better choice thanjulia> mutable struct MyStillAmbiguousType\\n           a::AbstractFloat\\n       endbecause the first version specifies the type of a from the type of the wrapper object. For example:julia> m = MyType(3.2)\\nMyType{Float64}(3.2)\\n\\njulia> t = MyStillAmbiguousType(3.2)\\nMyStillAmbiguousType(3.2)\\n\\njulia> typeof(m)\\nMyType{Float64}\\n\\njulia> typeof(t)\\nMyStillAmbiguousTypeThe type of field a can be readily determined from the type of m, but not from the type of t. Indeed, in t it\\'s possible to change the type of the field a:julia> typeof(t.a)\\nFloat64\\n\\njulia> t.a = 4.5f0\\n4.5f0\\n\\njulia> typeof(t.a)\\nFloat32In contrast, once m is constructed, the type of m.a cannot change:julia> m.a = 4.5f0\\n4.5f0\\n\\njulia> typeof(m.a)\\nFloat64The fact that the type of m.a is known from m\\'s type\u2014coupled with the fact that its type cannot change mid-function\u2014allows the compiler to generate highly-optimized code for objects like m but not for objects like t.Of course, all of this is true only if we construct m with a concrete type. We can break this by explicitly constructing it with an abstract type:julia> m = MyType{AbstractFloat}(3.2)\\nMyType{AbstractFloat}(3.2)\\n\\njulia> typeof(m.a)\\nFloat64\\n\\njulia> m.a = 4.5f0\\n4.5f0\\n\\njulia> typeof(m.a)\\nFloat32For all practical purposes, such objects behave identically to those of MyStillAmbiguousType.It\\'s quite instructive to compare the sheer amount code generated for a simple functionfunc(m::MyType) = m.a+1usingcode_llvm(func, Tuple{MyType{Float64}})\\ncode_llvm(func, Tuple{MyType{AbstractFloat}})For reasons of length the results are not shown here, but you may wish to try this yourself. Because the type is fully-specified in the first case, the compiler doesn\\'t need to generate any code to resolve the type at run-time. This results in shorter and faster code.\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Avoid-fields-with-abstract-containers-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Avoid fields with abstract containers\",\n    \"category\": \"section\",\n    \"text\": \"The same best practices also work for container types:julia> struct MySimpleContainer{A<:AbstractVector}\\n           a::A\\n       end\\n\\njulia> struct MyAmbiguousContainer{T}\\n           a::AbstractVector{T}\\n       endFor example:julia> c = MySimpleContainer(1:3);\\n\\njulia> typeof(c)\\nMySimpleContainer{UnitRange{Int64}}\\n\\njulia> c = MySimpleContainer([1:3;]);\\n\\njulia> typeof(c)\\nMySimpleContainer{Array{Int64,1}}\\n\\njulia> b = MyAmbiguousContainer(1:3);\\n\\njulia> typeof(b)\\nMyAmbiguousContainer{Int64}\\n\\njulia> b = MyAmbiguousContainer([1:3;]);\\n\\njulia> typeof(b)\\nMyAmbiguousContainer{Int64}For MySimpleContainer, the object is fully-specified by its type and parameters, so the compiler can generate optimized functions. In most instances, this will probably suffice.While the compiler can now do its job perfectly well, there are cases where you might wish that your code could do different things depending on the element type of a. Usually the best way to achieve this is to wrap your specific operation (here, foo) in a separate function:julia> function sumfoo(c::MySimpleContainer)\\n           s = 0\\n           for x in c.a\\n               s += foo(x)\\n           end\\n           s\\n       end\\nsumfoo (generic function with 1 method)\\n\\njulia> foo(x::Integer) = x\\nfoo (generic function with 1 method)\\n\\njulia> foo(x::AbstractFloat) = round(x)\\nfoo (generic function with 2 methods)This keeps things simple, while allowing the compiler to generate optimized code in all cases.However, there are cases where you may need to declare different versions of the outer function for different element types or types of the AbstractVector of the field a in MySimpleContainer. You could do it like this:julia> function myfunc(c::MySimpleContainer{<:AbstractArray{<:Integer}})\\n           return c.a[1]+1\\n       end\\nmyfunc (generic function with 1 method)\\n\\njulia> function myfunc(c::MySimpleContainer{<:AbstractArray{<:AbstractFloat}})\\n           return c.a[1]+2\\n       end\\nmyfunc (generic function with 2 methods)\\n\\njulia> function myfunc(c::MySimpleContainer{Vector{T}}) where T <: Integer\\n           return c.a[1]+3\\n       end\\nmyfunc (generic function with 3 methods)julia> myfunc(MySimpleContainer(1:3))\\n2\\n\\njulia> myfunc(MySimpleContainer(1.0:3))\\n3.0\\n\\njulia> myfunc(MySimpleContainer([1:3;]))\\n4\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Annotate-values-taken-from-untyped-locations-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Annotate values taken from untyped locations\",\n    \"category\": \"section\",\n    \"text\": \"It is often convenient to work with data structures that may contain values of any type (arrays of type Array{Any}). But, if you\\'re using one of these structures and happen to know the type of an element, it helps to share this knowledge with the compiler:function foo(a::Array{Any,1})\\n    x = a[1]::Int32\\n    b = x+1\\n    ...\\nendHere, we happened to know that the first element of a would be an Int32. Making an annotation like this has the added benefit that it will raise a run-time error if the value is not of the expected type, potentially catching certain bugs earlier.In the case that the type of a[1] is not known precisely, x can be declared via x = convert(Int32, a[1])::Int32. The use of the convert function allows a[1] to be any object convertible to an Int32 (such as UInt8), thus increasing the genericity of the code by loosening the type requirement. Notice that convert itself needs a type annotation in this context in order to achieve type stability. This is because the compiler cannot deduce the type of the return value of a function, even convert, unless the types of all the function\\'s arguments are known.Type annotation will not enhance (and can actually hinder) performance if the type is constructed at run-time. This is because the compiler cannot use the annotation to specialize the subsequent code, and the type-check itself takes time. For example, in the code:function nr(a, prec)\\n    ctype = prec == 32 ? Float32 : Float64\\n    b = Complex{ctype}(a)\\n    c = (b + 1.0f0)::Complex{ctype}\\n    abs(c)\\nendthe annotation of c harms performance. To write performant code involving types constructed at run-time, use the function-barrier technique discussed below, and ensure that the constructed type appears among the argument types of the kernel function so that the kernel operations are properly specialized by the compiler. For example, in the above snippet, as soon as b is constructed, it can be passed to another function k, the kernel. If, for example, function k declares b as an argument of type Complex{T}, where T is a type parameter, then a type annotation appearing in an assignment statement within k of the form:c = (b + 1.0f0)::Complex{T}does not hinder performance (but does not help either) since the compiler can determine the type of c at the time k is compiled.\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Declare-types-of-keyword-arguments-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Declare types of keyword arguments\",\n    \"category\": \"section\",\n    \"text\": \"Keyword arguments can have declared types:function with_keyword(x; name::Int = 1)\\n    ...\\nendFunctions are specialized on the types of keyword arguments, so these declarations will not affect performance of code inside the function. However, they will reduce the overhead of calls to the function that include keyword arguments.Functions with keyword arguments have near-zero overhead for call sites that pass only positional arguments.Passing dynamic lists of keyword arguments, as in f(x; keywords...), can be slow and should be avoided in performance-sensitive code.\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Break-functions-into-multiple-definitions-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Break functions into multiple definitions\",\n    \"category\": \"section\",\n    \"text\": \"Writing a function as many small definitions allows the compiler to directly call the most applicable code, or even inline it.Here is an example of a \\\"compound function\\\" that should really be written as multiple definitions:using LinearAlgebra\\n\\nfunction mynorm(A)\\n    if isa(A, Vector)\\n        return sqrt(real(dot(A,A)))\\n    elseif isa(A, Matrix)\\n        return maximum(svdvals(A))\\n    else\\n        error(\\\"mynorm: invalid argument\\\")\\n    end\\nendThis can be written more concisely and efficiently as:norm(x::Vector) = sqrt(real(dot(x, x)))\\nnorm(A::Matrix) = maximum(svdvals(A))It should however be noted that the compiler is quite efficient at optimizing away the dead branches in code written as the mynorm example.\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Write-\\\"type-stable\\\"-functions-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Write \\\"type-stable\\\" functions\",\n    \"category\": \"section\",\n    \"text\": \"When possible, it helps to ensure that a function always returns a value of the same type. Consider the following definition:pos(x) = x < 0 ? 0 : xAlthough this seems innocent enough, the problem is that 0 is an integer (of type Int) and x might be of any type. Thus, depending on the value of x, this function might return a value of either of two types. This behavior is allowed, and may be desirable in some cases. But it can easily be fixed as follows:pos(x) = x < 0 ? zero(x) : xThere is also a oneunit function, and a more general oftype(x, y) function, which returns y converted to the type of x.\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Avoid-changing-the-type-of-a-variable-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Avoid changing the type of a variable\",\n    \"category\": \"section\",\n    \"text\": \"An analogous \\\"type-stability\\\" problem exists for variables used repeatedly within a function:function foo()\\n    x = 1\\n    for i = 1:10\\n        x /= rand()\\n    end\\n    return x\\nendLocal variable x starts as an integer, and after one loop iteration becomes a floating-point number (the result of / operator). This makes it more difficult for the compiler to optimize the body of the loop. There are several possible fixes:Initialize x with x = 1.0\\nDeclare the type of x: x::Float64 = 1\\nUse an explicit conversion: x = oneunit(Float64)\\nInitialize with the first loop iteration, to x = 1 / rand(), then loop for i = 2:10\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#kernal-functions-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Separate kernel functions (aka, function barriers)\",\n    \"category\": \"section\",\n    \"text\": \"Many functions follow a pattern of performing some set-up work, and then running many iterations to perform a core computation. Where possible, it is a good idea to put these core computations in separate functions. For example, the following contrived function returns an array of a randomly-chosen type:julia> function strange_twos(n)\\n           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)\\n           for i = 1:n\\n               a[i] = 2\\n           end\\n           return a\\n       end;\\n\\njulia> strange_twos(3)\\n3-element Array{Float64,1}:\\n 2.0\\n 2.0\\n 2.0This should be written as:julia> function fill_twos!(a)\\n           for i = eachindex(a)\\n               a[i] = 2\\n           end\\n       end;\\n\\njulia> function strange_twos(n)\\n           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)\\n           fill_twos!(a)\\n           return a\\n       end;\\n\\njulia> strange_twos(3)\\n3-element Array{Float64,1}:\\n 2.0\\n 2.0\\n 2.0Julia\\'s compiler specializes code for argument types at function boundaries, so in the original implementation it does not know the type of a during the loop (since it is chosen randomly). Therefore the second version is generally faster since the inner loop can be recompiled as part of fill_twos! for different types of a.The second form is also often better style and can lead to more code reuse.This pattern is used in several places in Julia Base. For example, see vcat and hcat in abstractarray.jl, or the fill! function, which we could have used instead of writing our own fill_twos!.Functions like strange_twos occur when dealing with data of uncertain type, for example data loaded from an input file that might contain either integers, floats, strings, or something else.\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Types-with-values-as-parameters-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Types with values-as-parameters\",\n    \"category\": \"section\",\n    \"text\": \"Let\\'s say you want to create an N-dimensional array that has size 3 along each axis. Such arrays can be created like this:julia> A = fill(5.0, (3, 3))\\n3\u00d73 Array{Float64,2}:\\n 5.0  5.0  5.0\\n 5.0  5.0  5.0\\n 5.0  5.0  5.0This approach works very well: the compiler can figure out that A is an Array{Float64,2} because it knows the type of the fill value (5.0::Float64) and the dimensionality ((3, 3)::NTuple{2,Int}). This implies that the compiler can generate very efficient code for any future usage of A in the same function.But now let\\'s say you want to write a function that creates a 3\u00d73\u00d7... array in arbitrary dimensions; you might be tempted to write a functionjulia> function array3(fillval, N)\\n           fill(fillval, ntuple(d->3, N))\\n       end\\narray3 (generic function with 1 method)\\n\\njulia> array3(5.0, 2)\\n3\u00d73 Array{Float64,2}:\\n 5.0  5.0  5.0\\n 5.0  5.0  5.0\\n 5.0  5.0  5.0This works, but (as you can verify for yourself using @code_warntype array3(5.0, 2)) the problem is that the output type cannot be inferred: the argument N is a value of type Int, and type-inference does not (and cannot) predict its value in advance. This means that code using the output of this function has to be conservative, checking the type on each access of A; such code will be very slow.Now, one very good way to solve such problems is by using the function-barrier technique. However, in some cases you might want to eliminate the type-instability altogether. In such cases, one approach is to pass the dimensionality as a parameter, for example through Val{T}() (see \\\"Value types\\\"):julia> function array3(fillval, ::Val{N}) where N\\n           fill(fillval, ntuple(d->3, Val(N)))\\n       end\\narray3 (generic function with 1 method)\\n\\njulia> array3(5.0, Val(2))\\n3\u00d73 Array{Float64,2}:\\n 5.0  5.0  5.0\\n 5.0  5.0  5.0\\n 5.0  5.0  5.0Julia has a specialized version of ntuple that accepts a Val{::Int} instance as the second parameter; by passing N as a type-parameter, you make its \\\"value\\\" known to the compiler. Consequently, this version of array3 allows the compiler to predict the return type.However, making use of such techniques can be surprisingly subtle. For example, it would be of no help if you called array3 from a function like this:function call_array3(fillval, n)\\n    A = array3(fillval, Val(n))\\nendHere, you\\'ve created the same problem all over again: the compiler can\\'t guess what n is, so it doesn\\'t know the type of Val(n). Attempting to use Val, but doing so incorrectly, can easily make performance worse in many situations. (Only in situations where you\\'re effectively combining Val with the function-barrier trick, to make the kernel function more efficient, should code like the above be used.)An example of correct usage of Val would be:function filter3(A::AbstractArray{T,N}) where {T,N}\\n    kernel = array3(1, Val(N))\\n    filter(A, kernel)\\nendIn this example, N is passed as a parameter, so its \\\"value\\\" is known to the compiler. Essentially, Val(T) works only when T is either hard-coded/literal (Val(3)) or already specified in the type-domain.\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#The-dangers-of-abusing-multiple-dispatch-(aka,-more-on-types-with-values-as-parameters)-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)\",\n    \"category\": \"section\",\n    \"text\": \"Once one learns to appreciate multiple dispatch, there\\'s an understandable tendency to go crazy and try to use it for everything. For example, you might imagine using it to store information, e.g.struct Car{Make, Model}\\n    year::Int\\n    ...more fields...\\nendand then dispatch on objects like Car{:Honda,:Accord}(year, args...).This might be worthwhile when either of the following are true:You require CPU-intensive processing on each Car, and it becomes vastly more efficient if you know the Make and Model at compile time and the total number of different Make or Model that will be used is not too large.\\nYou have homogenous lists of the same type of Car to process, so that you can store them all in an Array{Car{:Honda,:Accord},N}.When the latter holds, a function processing such a homogenous array can be productively specialized: Julia knows the type of each element in advance (all objects in the container have the same concrete type), so Julia can \\\"look up\\\" the correct method calls when the function is being compiled (obviating the need to check at run-time) and thereby emit efficient code for processing the whole list.When these do not hold, then it\\'s likely that you\\'ll get no benefit; worse, the resulting \\\"combinatorial explosion of types\\\" will be counterproductive. If items[i+1] has a different type than item[i], Julia has to look up the type at run-time, search for the appropriate method in method tables, decide (via type intersection) which one matches, determine whether it has been JIT-compiled yet (and do so if not), and then make the call. In essence, you\\'re asking the full type- system and JIT-compilation machinery to basically execute the equivalent of a switch statement or dictionary lookup in your own code.Some run-time benchmarks comparing (1) type dispatch, (2) dictionary lookup, and (3) a \\\"switch\\\" statement can be found on the mailing list.Perhaps even worse than the run-time impact is the compile-time impact: Julia will compile specialized functions for each different Car{Make, Model}; if you have hundreds or thousands of such types, then every function that accepts such an object as a parameter (from a custom get_year function you might write yourself, to the generic push! function in Julia Base) will have hundreds or thousands of variants compiled for it. Each of these increases the size of the cache of compiled code, the length of internal lists of methods, etc. Excess enthusiasm for values-as-parameters can easily waste enormous resources.\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Access-arrays-in-memory-order,-along-columns-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Access arrays in memory order, along columns\",\n    \"category\": \"section\",\n    \"text\": \"Multidimensional arrays in Julia are stored in column-major order. This means that arrays are stacked one column at a time. This can be verified using the vec function or the syntax [:] as shown below (notice that the array is ordered [1 3 2 4], not [1 2 3 4]):julia> x = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> x[:]\\n4-element Array{Int64,1}:\\n 1\\n 3\\n 2\\n 4This convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to name a few). The alternative to column-major ordering is row-major ordering, which is the convention adopted by C and Python (numpy) among other languages. Remembering the ordering of arrays can have significant performance effects when looping over arrays. A rule of thumb to keep in mind is that with column-major arrays, the first index changes most rapidly. Essentially this means that looping will be faster if the inner-most loop index is the first to appear in a slice expression.Consider the following contrived example. Imagine we wanted to write a function that accepts a Vector and returns a square Matrix with either the rows or the columns filled with copies of the input vector. Assume that it is not important whether rows or columns are filled with these copies (perhaps the rest of the code can be easily adapted accordingly). We could conceivably do this in at least four ways (in addition to the recommended call to the built-in repeat):function copy_cols(x::Vector{T}) where T\\n    inds = axes(x, 1)\\n    out = similar(Array{T}, inds, inds)\\n    for i = inds\\n        out[:, i] = x\\n    end\\n    return out\\nend\\n\\nfunction copy_rows(x::Vector{T}) where T\\n    inds = axes(x, 1)\\n    out = similar(Array{T}, inds, inds)\\n    for i = inds\\n        out[i, :] = x\\n    end\\n    return out\\nend\\n\\nfunction copy_col_row(x::Vector{T}) where T\\n    inds = axes(x, 1)\\n    out = similar(Array{T}, inds, inds)\\n    for col = inds, row = inds\\n        out[row, col] = x[row]\\n    end\\n    return out\\nend\\n\\nfunction copy_row_col(x::Vector{T}) where T\\n    inds = axes(x, 1)\\n    out = similar(Array{T}, inds, inds)\\n    for row = inds, col = inds\\n        out[row, col] = x[col]\\n    end\\n    return out\\nendNow we will time each of these functions using the same random 10000 by 1 input vector:julia> x = randn(10000);\\n\\njulia> fmt(f) = println(rpad(string(f)*\\\": \\\", 14, \\' \\'), @elapsed f(x))\\n\\njulia> map(fmt, Any[copy_cols, copy_rows, copy_col_row, copy_row_col]);\\ncopy_cols:    0.331706323\\ncopy_rows:    1.799009911\\ncopy_col_row: 0.415630047\\ncopy_row_col: 1.721531501Notice that copy_cols is much faster than copy_rows. This is expected because copy_cols respects the column-based memory layout of the Matrix and fills it one column at a time. Additionally, copy_col_row is much faster than copy_row_col because it follows our rule of thumb that the first element to appear in a slice expression should be coupled with the inner-most loop.\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Pre-allocating-outputs-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Pre-allocating outputs\",\n    \"category\": \"section\",\n    \"text\": \"If your function returns an Array or some other complex type, it may have to allocate memory. Unfortunately, oftentimes allocation and its converse, garbage collection, are substantial bottlenecks.Sometimes you can circumvent the need to allocate memory on each function call by preallocating the output. As a trivial example, comparejulia> function xinc(x)\\n           return [x, x+1, x+2]\\n       end;\\n\\njulia> function loopinc()\\n           y = 0\\n           for i = 1:10^7\\n               ret = xinc(i)\\n               y += ret[2]\\n           end\\n           return y\\n       end;withjulia> function xinc!(ret::AbstractVector{T}, x::T) where T\\n           ret[1] = x\\n           ret[2] = x+1\\n           ret[3] = x+2\\n           nothing\\n       end;\\n\\njulia> function loopinc_prealloc()\\n           ret = Vector{Int}(undef, 3)\\n           y = 0\\n           for i = 1:10^7\\n               xinc!(ret, i)\\n               y += ret[2]\\n           end\\n           return y\\n       end;Timing results:julia> @time loopinc()\\n  0.529894 seconds (40.00 M allocations: 1.490 GiB, 12.14% gc time)\\n50000015000000\\n\\njulia> @time loopinc_prealloc()\\n  0.030850 seconds (6 allocations: 288 bytes)\\n50000015000000Preallocation has other advantages, for example by allowing the caller to control the \\\"output\\\" type from an algorithm. In the example above, we could have passed a SubArray rather than an Array, had we so desired.Taken to its extreme, pre-allocation can make your code uglier, so performance measurements and some judgment may be required. However, for \\\"vectorized\\\" (element-wise) functions, the convenient syntax x .= f.(y) can be used for in-place operations with fused loops and no temporary arrays (see the dot syntax for vectorizing functions).\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#More-dots:-Fuse-vectorized-operations-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"More dots: Fuse vectorized operations\",\n    \"category\": \"section\",\n    \"text\": \"Julia has a special dot syntax that converts any scalar function into a \\\"vectorized\\\" function call, and any operator into a \\\"vectorized\\\" operator, with the special property that nested \\\"dot calls\\\" are fusing: they are combined at the syntax level into a single loop, without allocating temporary arrays. If you use .= and similar assignment operators, the result can also be stored in-place in a pre-allocated array (see above).In a linear-algebra context, this means that even though operations like vector + vector and vector * scalar are defined, it can be advantageous to instead use vector .+ vector and vector .* scalar because the resulting loops can be fused with surrounding computations. For example, consider the two functions:julia> f(x) = 3x.^2 + 4x + 7x.^3;\\n\\njulia> fdot(x) = @. 3x^2 + 4x + 7x^3 # equivalent to 3 .* x.^2 .+ 4 .* x .+ 7 .* x.^3;Both f and fdot compute the same thing. However, fdot (defined with the help of the @. macro) is significantly faster when applied to an array:julia> x = rand(10^6);\\n\\njulia> @time f(x);\\n  0.019049 seconds (16 allocations: 45.777 MiB, 18.59% gc time)\\n\\njulia> @time fdot(x);\\n  0.002790 seconds (6 allocations: 7.630 MiB)\\n\\njulia> @time f.(x);\\n  0.002626 seconds (8 allocations: 7.630 MiB)That is, fdot(x) is ten times faster and allocates 1/6 the memory of f(x), because each * and + operation in f(x) allocates a new temporary array and executes in a separate loop. (Of course, if you just do f.(x) then it is as fast as fdot(x) in this example, but in many contexts it is more convenient to just sprinkle some dots in your expressions rather than defining a separate function for each vectorized operation.)\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Consider-using-views-for-slices-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Consider using views for slices\",\n    \"category\": \"section\",\n    \"text\": \"In Julia, an array \\\"slice\\\" expression like array[1:5, :] creates a copy of that data (except on the left-hand side of an assignment, where array[1:5, :] = ... assigns in-place to that portion of array). If you are doing many operations on the slice, this can be good for performance because it is more efficient to work with a smaller contiguous copy than it would be to index into the original array. On the other hand, if you are just doing a few simple operations on the slice, the cost of the allocation and copy operations can be substantial.An alternative is to create a \\\"view\\\" of the array, which is an array object (a SubArray) that actually references the data of the original array in-place, without making a copy. (If you write to a view, it modifies the original array\\'s data as well.) This can be done for individual slices by calling view, or more simply for a whole expression or block of code by putting @views in front of that expression. For example:julia> fcopy(x) = sum(x[2:end-1]);\\n\\njulia> @views fview(x) = sum(x[2:end-1]);\\n\\njulia> x = rand(10^6);\\n\\njulia> @time fcopy(x);\\n  0.003051 seconds (7 allocations: 7.630 MB)\\n\\njulia> @time fview(x);\\n  0.001020 seconds (6 allocations: 224 bytes)Notice both the 3\u00d7 speedup and the decreased memory allocation of the fview version of the function.\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Copying-data-is-not-always-bad-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Copying data is not always bad\",\n    \"category\": \"section\",\n    \"text\": \"Arrays are stored contiguously in memory, lending themselves to CPU vectorization and fewer memory accesses due to caching. These are the same reasons that it is recommended to access arrays in column-major order (see above). Irregular access patterns and non-contiguous views can drastically slow down computations on arrays because of non-sequential memory access.Copying irregularly-accessed data into a contiguous array before operating on it can result in a large speedup, such as in the example below. Here, a matrix and a vector are being accessed at 800,000 of their randomly-shuffled indices before being multiplied. Copying the views into plain arrays speeds up the multiplication even with the cost of the copying operation.julia> using Random\\n\\njulia> x = randn(1_000_000);\\n\\njulia> inds = shuffle(1:1_000_000)[1:800000];\\n\\njulia> A = randn(50, 1_000_000);\\n\\njulia> xtmp = zeros(800_000);\\n\\njulia> Atmp = zeros(50, 800_000);\\n\\njulia> @time sum(view(A, :, inds) * view(x, inds))\\n  0.412156 seconds (14 allocations: 960 bytes)\\n-4256.759568345458\\n\\njulia> @time begin\\n           copyto!(xtmp, view(x, inds))\\n           copyto!(Atmp, view(A, :, inds))\\n           sum(Atmp * xtmp)\\n       end\\n  0.285923 seconds (14 allocations: 960 bytes)\\n-4256.759568345134Provided there is enough memory for the copies, the cost of copying the view to an array is far outweighed by the speed boost from doing the matrix multiplication on a contiguous array.\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Avoid-string-interpolation-for-I/O-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Avoid string interpolation for I/O\",\n    \"category\": \"section\",\n    \"text\": \"When writing data to a file (or other I/O device), forming extra intermediate strings is a source of overhead. Instead of:println(file, \\\"$a $b\\\")use:println(file, a, \\\" \\\", b)The first version of the code forms a string, then writes it to the file, while the second version writes values directly to the file. Also notice that in some cases string interpolation can be harder to read. Consider:println(file, \\\"$(f(a))$(f(b))\\\")versus:println(file, f(a), f(b))\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Optimize-network-I/O-during-parallel-execution-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Optimize network I/O during parallel execution\",\n    \"category\": \"section\",\n    \"text\": \"When executing a remote function in parallel:using Distributed\\n\\nresponses = Vector{Any}(undef, nworkers())\\n@sync begin\\n    for (idx, pid) in enumerate(workers())\\n        @async responses[idx] = remotecall_fetch(pid, foo, args...)\\n    end\\nendis faster than:using Distributed\\n\\nrefs = Vector{Any}(undef, nworkers())\\nfor (idx, pid) in enumerate(workers())\\n    refs[idx] = @spawnat pid foo(args...)\\nend\\nresponses = [fetch(r) for r in refs]The former results in a single network round-trip to every worker, while the latter results in two network calls - first by the @spawnat and the second due to the fetch (or even a wait). The fetch/wait is also being executed serially resulting in an overall poorer performance.\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Fix-deprecation-warnings-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Fix deprecation warnings\",\n    \"category\": \"section\",\n    \"text\": \"A deprecated function internally performs a lookup in order to print a relevant warning only once. This extra lookup can cause a significant slowdown, so all uses of deprecated functions should be modified as suggested by the warnings.\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Tweaks-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Tweaks\",\n    \"category\": \"section\",\n    \"text\": \"These are some minor points that might help in tight inner loops.Avoid unnecessary arrays. For example, instead of sum([x,y,z]) use x+y+z.\\nUse abs2(z) instead of abs(z)^2 for complex z. In general, try to rewrite code to use abs2 instead of abs for complex arguments.\\nUse div(x,y) for truncating division of integers instead of trunc(x/y), fld(x,y) instead of floor(x/y), and cld(x,y) instead of ceil(x/y).\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#man-performance-annotations-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Performance Annotations\",\n    \"category\": \"section\",\n    \"text\": \"Sometimes you can enable better optimization by promising certain program properties.Use @inbounds to eliminate array bounds checking within expressions. Be certain before doing this. If the subscripts are ever out of bounds, you may suffer crashes or silent corruption.\\nUse @fastmath to allow floating point optimizations that are correct for real numbers, but lead to differences for IEEE numbers. Be careful when doing this, as this may change numerical results. This corresponds to the -ffast-math option of clang.\\nWrite @simd in front of for loops to promise that the iterations are independent and may be reordered.  Note that in many cases, Julia can automatically vectorize code without the @simd macro; it is only beneficial in cases where such a transformation would otherwise be illegal, including cases like allowing floating-point re-associativity and ignoring dependent memory accesses (@simd ivdep). Again, be very careful when asserting @simd as erroneously annotating a loop with dependent iterations may result in unexpected results. In particular, note that setindex! on some AbstractArray subtypes is inherently dependent upon iteration order. This feature is experimental and could change or disappear in future versions of Julia.The common idiom of using 1:n to index into an AbstractArray is not safe if the Array uses unconventional indexing, and may cause a segmentation fault if bounds checking is turned off. Use LinearIndices(x) or eachindex(x) instead (see also offset-arrays).!!!note     While @simd needs to be placed directly in front of an innermost for loop, both @inbounds and @fastmath     can be applied to either single expressions or all the expressions that appear within nested blocks of code, e.g.,     using @inbounds begin or @inbounds for ....Here is an example with both @inbounds and @simd markup (we here use @noinline to prevent the optimizer from trying to be too clever and defeat our benchmark):@noinline function inner(x, y)\\n    s = zero(eltype(x))\\n    for i=eachindex(x)\\n        @inbounds s += x[i]*y[i]\\n    end\\n    return s\\nend\\n\\n@noinline function innersimd(x, y)\\n    s = zero(eltype(x))\\n    @simd for i = eachindex(x)\\n        @inbounds s += x[i] * y[i]\\n    end\\n    return s\\nend\\n\\nfunction timeit(n, reps)\\n    x = rand(Float32, n)\\n    y = rand(Float32, n)\\n    s = zero(Float64)\\n    time = @elapsed for j in 1:reps\\n        s += inner(x, y)\\n    end\\n    println(\\\"GFlop/sec        = \\\", 2n*reps / time*1E-9)\\n    time = @elapsed for j in 1:reps\\n        s += innersimd(x, y)\\n    end\\n    println(\\\"GFlop/sec (SIMD) = \\\", 2n*reps / time*1E-9)\\nend\\n\\ntimeit(1000, 1000)On a computer with a 2.4GHz Intel Core i5 processor, this produces:GFlop/sec        = 1.9467069505224963\\nGFlop/sec (SIMD) = 17.578554163920018(GFlop/sec measures the performance, and larger numbers are better.)Here is an example with all three kinds of markup. This program first calculates the finite difference of a one-dimensional array, and then evaluates the L2-norm of the result:function init!(u::Vector)\\n    n = length(u)\\n    dx = 1.0 / (n-1)\\n    @fastmath @inbounds @simd for i in 1:n #by asserting that `u` is a `Vector` we can assume it has 1-based indexing\\n        u[i] = sin(2pi*dx*i)\\n    end\\nend\\n\\nfunction deriv!(u::Vector, du)\\n    n = length(u)\\n    dx = 1.0 / (n-1)\\n    @fastmath @inbounds du[1] = (u[2] - u[1]) / dx\\n    @fastmath @inbounds @simd for i in 2:n-1\\n        du[i] = (u[i+1] - u[i-1]) / (2*dx)\\n    end\\n    @fastmath @inbounds du[n] = (u[n] - u[n-1]) / dx\\nend\\n\\nfunction mynorm(u::Vector)\\n    n = length(u)\\n    T = eltype(u)\\n    s = zero(T)\\n    @fastmath @inbounds @simd for i in 1:n\\n        s += u[i]^2\\n    end\\n    @fastmath @inbounds return sqrt(s/n)\\nend\\n\\nfunction main()\\n    n = 2000\\n    u = Vector{Float64}(undef, n)\\n    init!(u)\\n    du = similar(u)\\n\\n    deriv!(u, du)\\n    nu = mynorm(du)\\n\\n    @time for i in 1:10^6\\n        deriv!(u, du)\\n        nu = mynorm(du)\\n    end\\n\\n    println(nu)\\nend\\n\\nmain()On a computer with a 2.7 GHz Intel Core i7 processor, this produces:$ julia wave.jl;\\n  1.207814709 seconds\\n4.443986180758249\\n\\n$ julia --math-mode=ieee wave.jl;\\n  4.487083643 seconds\\n4.443986180758249Here, the option --math-mode=ieee disables the @fastmath macro, so that we can compare results.In this case, the speedup due to @fastmath is a factor of about 3.7. This is unusually large \u2013 in general, the speedup will be smaller. (In this particular example, the working set of the benchmark is small enough to fit into the L1 cache of the processor, so that memory access latency does not play a role, and computing time is dominated by CPU usage. In many real world programs this is not the case.) Also, in this case this optimization does not change the result \u2013 in general, the result will be slightly different. In some cases, especially for numerically unstable algorithms, the result can be very different.The annotation @fastmath re-arranges floating point expressions, e.g. changing the order of evaluation, or assuming that certain special cases (inf, nan) cannot occur. In this case (and on this particular computer), the main difference is that the expression 1 / (2*dx) in the function deriv is hoisted out of the loop (i.e. calculated outside the loop), as if one had written idx = 1 / (2*dx). In the loop, the expression ... / (2*dx) then becomes ... * idx, which is much faster to evaluate. Of course, both the actual optimization that is applied by the compiler as well as the resulting speedup depend very much on the hardware. You can examine the change in generated code by using Julia\\'s code_native function.Note that @fastmath also assumes that NaNs will not occur during the computation, which can lead to surprising behavior:julia> f(x) = isnan(x);\\n\\njulia> f(NaN)\\ntrue\\n\\njulia> f_fast(x) = @fastmath isnan(x);\\n\\njulia> f_fast(NaN)\\nfalse\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#Treat-Subnormal-Numbers-as-Zeros-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Treat Subnormal Numbers as Zeros\",\n    \"category\": \"section\",\n    \"text\": \"Subnormal numbers, formerly called denormal numbers, are useful in many contexts, but incur a performance penalty on some hardware. A call set_zero_subnormals(true) grants permission for floating-point operations to treat subnormal inputs or outputs as zeros, which may improve performance on some hardware. A call set_zero_subnormals(false) enforces strict IEEE behavior for subnormal numbers.Below is an example where subnormals noticeably impact performance on some hardware:function timestep(b::Vector{T}, a::Vector{T}, \u0394t::T) where T\\n    @assert length(a)==length(b)\\n    n = length(b)\\n    b[1] = 1                            # Boundary condition\\n    for i=2:n-1\\n        b[i] = a[i] + (a[i-1] - T(2)*a[i] + a[i+1]) * \u0394t\\n    end\\n    b[n] = 0                            # Boundary condition\\nend\\n\\nfunction heatflow(a::Vector{T}, nstep::Integer) where T\\n    b = similar(a)\\n    for t=1:div(nstep,2)                # Assume nstep is even\\n        timestep(b,a,T(0.1))\\n        timestep(a,b,T(0.1))\\n    end\\nend\\n\\nheatflow(zeros(Float32,10),2)           # Force compilation\\nfor trial=1:6\\n    a = zeros(Float32,1000)\\n    set_zero_subnormals(iseven(trial))  # Odd trials use strict IEEE arithmetic\\n    @time heatflow(a,1000)\\nendThis gives an output similar to  0.002202 seconds (1 allocation: 4.063 KiB)\\n  0.001502 seconds (1 allocation: 4.063 KiB)\\n  0.002139 seconds (1 allocation: 4.063 KiB)\\n  0.001454 seconds (1 allocation: 4.063 KiB)\\n  0.002115 seconds (1 allocation: 4.063 KiB)\\n  0.001455 seconds (1 allocation: 4.063 KiB)Note how each even iteration is significantly faster.This example generates many subnormal numbers because the values in a become an exponentially decreasing curve, which slowly flattens out over time.Treating subnormals as zeros should be used with caution, because doing so breaks some identities, such as x-y == 0 implies x == y:julia> x = 3f-38; y = 2f-38;\\n\\njulia> set_zero_subnormals(true); (x - y, x == y)\\n(0.0f0, false)\\n\\njulia> set_zero_subnormals(false); (x - y, x == y)\\n(1.0000001f-38, false)In some applications, an alternative to zeroing subnormal numbers is to inject a tiny bit of noise.  For example, instead of initializing a with zeros, initialize it with:a = rand(Float32,1000) * 1.f-9\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#man-code-warntype-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"@code_warntype\",\n    \"category\": \"section\",\n    \"text\": \"The macro @code_warntype (or its function variant code_warntype) can sometimes be helpful in diagnosing type-related problems. Here\\'s an example:julia> @noinline pos(x) = x < 0 ? 0 : x;\\n\\njulia> function f(x)\\n           y = pos(x)\\n           sin(y*x + 1)\\n       end;\\n\\njulia> @code_warntype f(3.2)\\nBody::Float64\\n2 1 \u2500 %1  = invoke Main.pos(%%x::Float64)::UNION{FLOAT64, INT64}\\n3 \u2502   %2  = isa(%1, Float64)::Bool\\n  \u2514\u2500\u2500       goto 3 if not %2\\n  2 \u2500 %4  = \u03c0 (%1, Float64)\\n  \u2502   %5  = Base.mul_float(%4, %%x)::Float64\\n  \u2514\u2500\u2500       goto 6\\n  3 \u2500 %7  = isa(%1, Int64)::Bool\\n  \u2514\u2500\u2500       goto 5 if not %7\\n  4 \u2500 %9  = \u03c0 (%1, Int64)\\n  \u2502   %10 = Base.sitofp(Float64, %9)::Float64\\n  \u2502   %11 = Base.mul_float(%10, %%x)::Float64\\n  \u2514\u2500\u2500       goto 6\\n  5 \u2500       Base.error(\\\"fatal error in type inference (type bound)\\\")\\n  \u2514\u2500\u2500       unreachable\\n  6 \u2504 %15 = \u03c6 (2 => %5, 4 => %11)::Float64\\n  \u2502   %16 = Base.add_float(%15, 1.0)::Float64\\n  \u2502   %17 = invoke Main.sin(%16::Float64)::Float64\\n  \u2514\u2500\u2500       return %17Interpreting the output of @code_warntype, like that of its cousins @code_lowered, @code_typed, @code_llvm, and @code_native, takes a little practice. Your code is being presented in form that has been heavily digested on its way to generating compiled machine code. Most of the expressions are annotated by a type, indicated by the ::T (where T might be Float64, for example). The most important characteristic of @code_warntype is that non-concrete types are displayed in red; in the above example, such output is shown in uppercase.At the top, the inferred return type of the function is shown as Body::Float64. The next lines represent the body of f in Julia\\'s SSA IR form. The numbered boxes are labels and represent targets for jumps (via goto) in your code. Looking at the body, you can see that the first thing that happens is that pos is called and the return value has been inferred as the Union type UNION{FLOAT64, INT64} shown in uppercase since it is a non-concrete type. This means that we cannot know the exact return type of pos based on the input types. However, the result of y*xis a Float64 no matter if y is a Float64 or Int64 The net result is that f(x::Float64) will not be type-unstable in its output, even if some of the intermediate computations are type-unstable.How you use this information is up to you. Obviously, it would be far and away best to fix pos to be type-stable: if you did so, all of the variables in f would be concrete, and its performance would be optimal. However, there are circumstances where this kind of ephemeral type instability might not matter too much: for example, if pos is never used in isolation, the fact that f\\'s output is type-stable (for Float64 inputs) will shield later code from the propagating effects of type instability. This is particularly relevant in cases where fixing the type instability is difficult or impossible. In such cases, the tips above (e.g., adding type annotations and/or breaking up functions) are your best tools to contain the \\\"damage\\\" from type instability. Also, note that even Julia Base has functions that are type unstable. For example, the function findfirst returns the index into an array where a key is found, or nothing if it is not found, a clear type instability. In order to make it easier to find the type instabilities that are likely to be important, Unions containing either missing or nothing are color highlighted in yellow, instead of red.The following examples may help you interpret expressions marked as containing non-leaf types:Function body starting with Body::UNION{T1,T2})\\nInterpretation: function with unstable return type\\nSuggestion: make the return value type-stable, even if you have to annotate it\\ninvoke Main.g(%%x::Int64)::UNION{FLOAT64, INT64}\\nInterpretation: call to a type-unstable function g.\\nSuggestion: fix the function, or if necessary annotate the return value\\ninvoke Base.getindex(%%x::Array{Any,1}, 1::Int64)::ANY\\nInterpretation: accessing elements of poorly-typed arrays\\nSuggestion: use arrays with better-defined types, or if necessary annotate the type of individual element accesses\\nBase.getfield(%%x, :(:data))::ARRAY{FLOAT64,N} WHERE N\\nInterpretation: getting a field that is of non-leaf type. In this case, ArrayContainer had a field data::Array{T}. But Array needs the dimension N, too, to be a concrete type.\\nSuggestion: use concrete types like Array{T,3} or Array{T,N}, where N is now a parameter of ArrayContainer\"\n},\n\n{\n    \"location\": \"manual/performance-tips.html#man-performance-captured-1\",\n    \"page\": \"Performance Tips\",\n    \"title\": \"Performance of captured variable\",\n    \"category\": \"section\",\n    \"text\": \"Consider the following example that defines an inner function:function abmult(r::Int)\\n    if r < 0\\n        r = -r\\n    end\\n    f = x -> x * r\\n    return f\\nendFunction abmult returns a function f that multiplies its argument by the absolute value of r. The inner function assigned to f is called a \\\"closure\\\". Inner functions are also used by the language for do-blocks and for generator expressions.This style of code presents performance challenges for the language. The parser, when translating it into lower-level instructions, substantially reorganizes the above code by extracting the inner function to a separate code block.  \\\"Captured\\\" variables such as r that are shared by inner functions and their enclosing scope are also extracted into a heap-allocated \\\"box\\\" accessible to both inner and outer functions because the language specifies that r in the inner scope must be identical to r in the outer scope even after the outer scope (or another inner function) modifies r.The discussion in the preceding paragraph referred to the \\\"parser\\\", that is, the phase of compilation that takes place when the module containing abmult is first loaded, as opposed to the later phase when it is first invoked. The parser does not \\\"know\\\" that Int is a fixed type, or that the statement r = -r transforms an Int to another Int. The magic of type inference takes place in the later phase of compilation.Thus, the parser does not know that r has a fixed type (Int). nor that r does not change value once the inner function is created (so that the box is unneeded).  Therefore, the parser emits code for box that holds an object with an abstract type such as Any, which requires run-time type dispatch for each occurrence of r.  This can be verified by applying @code_warntype to the above function.  Both the boxing and the run-time type dispatch can cause loss of performance.If captured variables are used in a performance-critical section of the code, then the following tips help ensure that their use is performant. First, if it is known that a captured variable does not change its type, then this can be declared explicitly with a type annotation (on the variable, not the right-hand side):function abmult2(r0::Int)\\n    r::Int = r0\\n    if r < 0\\n        r = -r\\n    end\\n    f = x -> x * r\\n    return f\\nendThe type annotation partially recovers lost performance due to capturing because the parser can associate a concrete type to the object in the box. Going further, if the captured variable does not need to be boxed at all (because it will not be reassigned after the closure is created), this can be indicated with let blocks as follows.function abmult3(r::Int)\\n    if r < 0\\n        r = -r\\n    end\\n    f = let r = r\\n            x -> x * r\\n    end\\n    return f\\nendThe let block creates a new variable r whose scope is only the inner function. The second technique recovers full language performance in the presence of captured variables. Note that this is a rapidly evolving aspect of the compiler, and it is likely that future releases will not require this degree of programmer annotation to attain performance. In the mean time, some user-contributed packages like FastClosures automate the insertion of let statements as in abmult3.\"\n},\n\n{\n    \"location\": \"manual/workflow-tips.html#\",\n    \"page\": \"Workflow Tips\",\n    \"title\": \"Workflow Tips\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/workflow-tips.html#man-workflow-tips-1\",\n    \"page\": \"Workflow Tips\",\n    \"title\": \"Workflow Tips\",\n    \"category\": \"section\",\n    \"text\": \"Here are some tips for working with Julia efficiently.\"\n},\n\n{\n    \"location\": \"manual/workflow-tips.html#REPL-based-workflow-1\",\n    \"page\": \"Workflow Tips\",\n    \"title\": \"REPL-based workflow\",\n    \"category\": \"section\",\n    \"text\": \"As already elaborated in The Julia REPL, Julia\\'s REPL provides rich functionality that facilitates an efficient interactive workflow. Here are some tips that might further enhance your experience at the command line.\"\n},\n\n{\n    \"location\": \"manual/workflow-tips.html#A-basic-editor/REPL-workflow-1\",\n    \"page\": \"Workflow Tips\",\n    \"title\": \"A basic editor/REPL workflow\",\n    \"category\": \"section\",\n    \"text\": \"The most basic Julia workflows involve using a text editor in conjunction with the julia command line. A common pattern includes the following elements:Put code under development in a temporary module. Create a file, say Tmp.jl, and include within it\\nmodule Tmp\\n\\n<your definitions here>\\n\\nend\\nPut your test code in another file. Create another file, say tst.jl, which begins with\\nimport Tmp\\nand includes tests for the contents of Tmp. Alternatively, you can wrap the contents of your test file in a module, as\\nmodule Tst\\n    using Tmp\\n\\n    <scratch work>\\n\\nend\\nThe advantage is that you can now do using Tmp in your test code and can therefore avoid prepending Tmp. everywhere. The disadvantage is that code can no longer be selectively copied to the REPL without some tweaking.\\nLather. Rinse. Repeat. Explore ideas at the julia command prompt. Save good ideas in tst.jl.\"\n},\n\n{\n    \"location\": \"manual/workflow-tips.html#Simplify-initialization-1\",\n    \"page\": \"Workflow Tips\",\n    \"title\": \"Simplify initialization\",\n    \"category\": \"section\",\n    \"text\": \"To simplify restarting the REPL, put project-specific initialization code in a file, say _init.jl, which you can run on startup by issuing the command:julia -L _init.jlIf you further add the following to your ~/.julia/config/startup.jl fileisfile(\\\"_init.jl\\\") && include(joinpath(pwd(), \\\"_init.jl\\\"))then calling julia from that directory will run the initialization code without the additional command line argument.\"\n},\n\n{\n    \"location\": \"manual/workflow-tips.html#Browser-based-workflow-1\",\n    \"page\": \"Workflow Tips\",\n    \"title\": \"Browser-based workflow\",\n    \"category\": \"section\",\n    \"text\": \"It is also possible to interact with a Julia REPL in the browser via IJulia. See the package home for details.\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Style Guide\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Style-Guide-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Style Guide\",\n    \"category\": \"section\",\n    \"text\": \"The following sections explain a few aspects of idiomatic Julia coding style. None of these rules are absolute; they are only suggestions to help familiarize you with the language and to help you choose among alternative designs.\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Write-functions,-not-just-scripts-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Write functions, not just scripts\",\n    \"category\": \"section\",\n    \"text\": \"Writing code as a series of steps at the top level is a quick way to get started solving a problem, but you should try to divide a program into functions as soon as possible. Functions are more reusable and testable, and clarify what steps are being done and what their inputs and outputs are. Furthermore, code inside functions tends to run much faster than top level code, due to how Julia\\'s compiler works.It is also worth emphasizing that functions should take arguments, instead of operating directly on global variables (aside from constants like pi).\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Avoid-writing-overly-specific-types-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Avoid writing overly-specific types\",\n    \"category\": \"section\",\n    \"text\": \"Code should be as generic as possible. Instead of writing:Complex{Float64}(x)it\\'s better to use available generic functions:complex(float(x))The second version will convert x to an appropriate type, instead of always the same type.This style point is especially relevant to function arguments. For example, don\\'t declare an argument to be of type Int or Int32 if it really could be any integer, expressed with the abstract type Integer. In fact, in many cases you can omit the argument type altogether, unless it is needed to disambiguate from other method definitions, since a MethodError will be thrown anyway if a type is passed that does not support any of the requisite operations. (This is known as duck typing.)For example, consider the following definitions of a function addone that returns one plus its argument:addone(x::Int) = x + 1                 # works only for Int\\naddone(x::Integer) = x + oneunit(x)    # any integer type\\naddone(x::Number) = x + oneunit(x)     # any numeric type\\naddone(x) = x + oneunit(x)             # any type supporting + and oneunitThe last definition of addone handles any type supporting oneunit (which returns 1 in the same type as x, which avoids unwanted type promotion) and the + function with those arguments. The key thing to realize is that there is no performance penalty to defining only the general addone(x) = x + oneunit(x), because Julia will automatically compile specialized versions as needed. For example, the first time you call addone(12), Julia will automatically compile a specialized addone function for x::Int arguments, with the call to oneunit replaced by its inlined value 1. Therefore, the first three definitions of addone above are completely redundant with the fourth definition.\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Handle-excess-argument-diversity-in-the-caller-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Handle excess argument diversity in the caller\",\n    \"category\": \"section\",\n    \"text\": \"Instead of:function foo(x, y)\\n    x = Int(x); y = Int(y)\\n    ...\\nend\\nfoo(x, y)use:function foo(x::Int, y::Int)\\n    ...\\nend\\nfoo(Int(x), Int(y))This is better style because foo does not really accept numbers of all types; it really needs Int s.One issue here is that if a function inherently requires integers, it might be better to force the caller to decide how non-integers should be converted (e.g. floor or ceiling). Another issue is that declaring more specific types leaves more \\\"space\\\" for future method definitions.\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Append-!-to-names-of-functions-that-modify-their-arguments-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Append ! to names of functions that modify their arguments\",\n    \"category\": \"section\",\n    \"text\": \"Instead of:function double(a::AbstractArray{<:Number})\\n    for i = firstindex(a):lastindex(a)\\n        a[i] *= 2\\n    end\\n    return a\\nenduse:function double!(a::AbstractArray{<:Number})\\n    for i = firstindex(a):lastindex(a)\\n        a[i] *= 2\\n    end\\n    return a\\nendJulia Base uses this convention throughout and contains examples of functions with both copying and modifying forms (e.g., sort and sort!), and others which are just modifying (e.g., push!, pop!, splice!).  It is typical for such functions to also return the modified array for convenience.\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Avoid-strange-type-Unions-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Avoid strange type Unions\",\n    \"category\": \"section\",\n    \"text\": \"Types such as Union{Function,AbstractString} are often a sign that some design could be cleaner.\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Avoid-elaborate-container-types-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Avoid elaborate container types\",\n    \"category\": \"section\",\n    \"text\": \"It is usually not much help to construct arrays like the following:a = Vector{Union{Int,AbstractString,Tuple,Array}}(undef, n)In this case Vector{Any}(undef, n) is better. It is also more helpful to the compiler to annotate specific uses (e.g. a[i]::Int) than to try to pack many alternatives into one type.\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Use-naming-conventions-consistent-with-Julia\\'s-base/-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Use naming conventions consistent with Julia\\'s base/\",\n    \"category\": \"section\",\n    \"text\": \"modules and type names use capitalization and camel case: module SparseArrays, struct UnitRange.\\nfunctions are lowercase (maximum, convert) and, when readable, with multiple words squashed together (isequal, haskey). When necessary, use underscores as word separators. Underscores are also used to indicate a combination of concepts (remotecall_fetch as a more efficient implementation of fetch(remotecall(...))) or as modifiers.\\nconciseness is valued, but avoid abbreviation (indexin rather than indxin) as it becomes difficult to remember whether and how particular words are abbreviated.If a function name requires multiple words, consider whether it might represent more than one concept and might be better split into pieces.\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Write-functions-with-argument-ordering-similar-to-Julia\\'s-Base-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Write functions with argument ordering similar to Julia\\'s Base\",\n    \"category\": \"section\",\n    \"text\": \"As a general rule, the Base library uses the following order of arguments to functions, as applicable:Function argument. Putting a function argument first permits the use of do blocks for passing multiline anonymous functions.\\nI/O stream. Specifying the IO object first permits passing the function to functions such as sprint, e.g. sprint(show, x).\\nInput being mutated. For example, in fill!(x, v), x is the object being mutated and it appears before the value to be inserted into x.\\nType. Passing a type typically means that the output will have the given type. In parse(Int, \\\"1\\\"), the type comes before the string to parse. There are many such examples where the type appears first, but it\\'s useful to note that in read(io, String), the IO argument appears before the type, which is in keeping with the order outlined here.\\nInput not being mutated. In fill!(x, v), v is not being mutated and it comes after x.\\nKey. For associative collections, this is the key of the key-value pair(s). For other indexed collections, this is the index.\\nValue. For associative collections, this is the value of the key-value pair(s). In cases like fill!(x, v), this is v.\\nEverything else. Any other arguments.\\nVarargs. This refers to arguments that can be listed indefinitely at the end of a function call. For example, in Matrix{T}(undef, dims), the dimensions can be given as a Tuple, e.g. Matrix{T}(undef, (1,2)), or as Varargs, e.g. Matrix{T}(undef, 1, 2).\\nKeyword arguments. In Julia keyword arguments have to come last anyway in function definitions; they\\'re listed here for the sake of completeness.The vast majority of functions will not take every kind of argument listed above; the numbers merely denote the precedence that should be used for any applicable arguments to a function.There are of course a few exceptions. For example, in convert, the type should always come first. In setindex!, the value comes before the indices so that the indices can be provided as varargs.When designing APIs, adhering to this general order as much as possible is likely to give users of your functions a more consistent experience.\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Don\\'t-overuse-try-catch-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Don\\'t overuse try-catch\",\n    \"category\": \"section\",\n    \"text\": \"It is better to avoid errors than to rely on catching them.\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Don\\'t-parenthesize-conditions-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Don\\'t parenthesize conditions\",\n    \"category\": \"section\",\n    \"text\": \"Julia doesn\\'t require parens around conditions in if and while. Write:if a == binstead of:if (a == b)\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Don\\'t-overuse-...-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Don\\'t overuse ...\",\n    \"category\": \"section\",\n    \"text\": \"Splicing function arguments can be addictive. Instead of [a..., b...], use simply [a; b], which already concatenates arrays. collect(a) is better than [a...], but since a is already iterable it is often even better to leave it alone, and not convert it to an array.\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Don\\'t-use-unnecessary-static-parameters-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Don\\'t use unnecessary static parameters\",\n    \"category\": \"section\",\n    \"text\": \"A function signature:foo(x::T) where {T<:Real} = ...should be written as:foo(x::Real) = ...instead, especially if T is not used in the function body. Even if T is used, it can be replaced with typeof(x) if convenient. There is no performance difference. Note that this is not a general caution against static parameters, just against uses where they are not needed.Note also that container types, specifically may need type parameters in function calls. See the FAQ Avoid fields with abstract containers for more information.\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Avoid-confusion-about-whether-something-is-an-instance-or-a-type-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Avoid confusion about whether something is an instance or a type\",\n    \"category\": \"section\",\n    \"text\": \"Sets of definitions like the following are confusing:foo(::Type{MyType}) = ...\\nfoo(::MyType) = foo(MyType)Decide whether the concept in question will be written as MyType or MyType(), and stick to it.The preferred style is to use instances by default, and only add methods involving Type{MyType} later if they become necessary to solve some problem.If a type is effectively an enumeration, it should be defined as a single (ideally immutable struct or primitive) type, with the enumeration values being instances of it. Constructors and conversions can check whether values are valid. This design is preferred over making the enumeration an abstract type, with the \\\"values\\\" as subtypes.\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Don\\'t-overuse-macros-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Don\\'t overuse macros\",\n    \"category\": \"section\",\n    \"text\": \"Be aware of when a macro could really be a function instead.Calling eval inside a macro is a particularly dangerous warning sign; it means the macro will only work when called at the top level. If such a macro is written as a function instead, it will naturally have access to the run-time values it needs.\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Don\\'t-expose-unsafe-operations-at-the-interface-level-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Don\\'t expose unsafe operations at the interface level\",\n    \"category\": \"section\",\n    \"text\": \"If you have a type that uses a native pointer:mutable struct NativeType\\n    p::Ptr{UInt8}\\n    ...\\nenddon\\'t write definitions like the following:getindex(x::NativeType, i) = unsafe_load(x.p, i)The problem is that users of this type can write x[i] without realizing that the operation is unsafe, and then be susceptible to memory bugs.Such a function should either check the operation to ensure it is safe, or have unsafe somewhere in its name to alert callers.\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Don\\'t-overload-methods-of-base-container-types-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Don\\'t overload methods of base container types\",\n    \"category\": \"section\",\n    \"text\": \"It is possible to write definitions like the following:show(io::IO, v::Vector{MyType}) = ...This would provide custom showing of vectors with a specific new element type. While tempting, this should be avoided. The trouble is that users will expect a well-known type like Vector() to behave in a certain way, and overly customizing its behavior can make it harder to work with.\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Avoid-type-piracy-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Avoid type piracy\",\n    \"category\": \"section\",\n    \"text\": \"\\\"Type piracy\\\" refers to the practice of extending or redefining methods in Base or other packages on types that you have not defined. In some cases, you can get away with type piracy with little ill effect. In extreme cases, however, you can even crash Julia (e.g. if your method extension or redefinition causes invalid input to be passed to a ccall). Type piracy can complicate reasoning about code, and may introduce incompatibilities that are hard to predict and diagnose.As an example, suppose you wanted to define multiplication on symbols in a module:module A\\nimport Base.*\\n*(x::Symbol, y::Symbol) = Symbol(x,y)\\nendThe problem is that now any other module that uses Base.* will also see this definition. Since Symbol is defined in Base and is used by other modules, this can change the behavior of unrelated code unexpectedly. There are several alternatives here, including using a different function name, or wrapping the Symbols in another type that you define.Sometimes, coupled packages may engage in type piracy to separate features from definitions, especially when the packages were designed by collaborating authors, and when the definitions are reusable. For example, one package might provide some types useful for working with colors; another package could define methods for those types that enable conversions between color spaces. Another example might be a package that acts as a thin wrapper for some C code, which another package might then pirate to implement a higher-level, Julia-friendly API.\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Be-careful-with-type-equality-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Be careful with type equality\",\n    \"category\": \"section\",\n    \"text\": \"You generally want to use isa and <: for testing types, not ==. Checking types for exact equality typically only makes sense when comparing to a known concrete type (e.g. T == Float64), or if you really, really know what you\\'re doing.\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Do-not-write-x-f(x)-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Do not write x->f(x)\",\n    \"category\": \"section\",\n    \"text\": \"Since higher-order functions are often called with anonymous functions, it is easy to conclude that this is desirable or even necessary. But any function can be passed directly, without being \\\"wrapped\\\" in an anonymous function. Instead of writing map(x->f(x), a), write map(f, a).\"\n},\n\n{\n    \"location\": \"manual/style-guide.html#Avoid-using-floats-for-numeric-literals-in-generic-code-when-possible-1\",\n    \"page\": \"Style Guide\",\n    \"title\": \"Avoid using floats for numeric literals in generic code when possible\",\n    \"category\": \"section\",\n    \"text\": \"If you write generic code which handles numbers, and which can be expected to run with many different numeric type arguments, try using literals of a numeric type that will affect the arguments as little as possible through promotion.For example,julia> f(x) = 2.0 * x\\nf (generic function with 1 method)\\n\\njulia> f(1//2)\\n1.0\\n\\njulia> f(1/2)\\n1.0\\n\\njulia> f(1)\\n2.0whilejulia> g(x) = 2 * x\\ng (generic function with 1 method)\\n\\njulia> g(1//2)\\n1//1\\n\\njulia> g(1/2)\\n1.0\\n\\njulia> g(1)\\n2As you can see, the second version, where we used an Int literal, preserved the type of the input argument, while the first didn\\'t. This is because e.g. promote_type(Int, Float64) == Float64, and promotion happens with the multiplication. Similarly, Rational literals are less type disruptive than Float64 literals, but more disruptive than Ints:julia> h(x) = 2//1 * x\\nh (generic function with 1 method)\\n\\njulia> h(1//2)\\n1//1\\n\\njulia> h(1/2)\\n1.0\\n\\njulia> h(1)\\n2//1Thus, use Int literals when possible, with Rational{Int} for literal non-integer numbers, in order to make it easier to use your code.\"\n},\n\n{\n    \"location\": \"manual/faq.html#\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"Frequently Asked Questions\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/faq.html#Frequently-Asked-Questions-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"Frequently Asked Questions\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/faq.html#Sessions-and-the-REPL-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"Sessions and the REPL\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/faq.html#How-do-I-delete-an-object-in-memory?-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"How do I delete an object in memory?\",\n    \"category\": \"section\",\n    \"text\": \"Julia does not have an analog of MATLAB\\'s clear function; once a name is defined in a Julia session (technically, in module Main), it is always present.If memory usage is your concern, you can always replace objects with ones that consume less memory.  For example, if A is a gigabyte-sized array that you no longer need, you can free the memory with A = nothing.  The memory will be released the next time the garbage collector runs; you can force this to happen with gc(). Moreover, an attempt to use A will likely result in an error, because most methods are not defined on type Nothing.\"\n},\n\n{\n    \"location\": \"manual/faq.html#How-can-I-modify-the-declaration-of-a-type-in-my-session?-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"How can I modify the declaration of a type in my session?\",\n    \"category\": \"section\",\n    \"text\": \"Perhaps you\\'ve defined a type and then realize you need to add a new field.  If you try this at the REPL, you get the error:ERROR: invalid redefinition of constant MyTypeTypes in module Main cannot be redefined.While this can be inconvenient when you are developing new code, there\\'s an excellent workaround.  Modules can be replaced by redefining them, and so if you wrap all your new code inside a module you can redefine types and constants.  You can\\'t import the type names into Main and then expect to be able to redefine them there, but you can use the module name to resolve the scope.  In other words, while developing you might use a workflow something like this:include(\\\"mynewcode.jl\\\")              # this defines a module MyModule\\nobj1 = MyModule.ObjConstructor(a, b)\\nobj2 = MyModule.somefunction(obj1)\\n# Got an error. Change something in \\\"mynewcode.jl\\\"\\ninclude(\\\"mynewcode.jl\\\")              # reload the module\\nobj1 = MyModule.ObjConstructor(a, b) # old objects are no longer valid, must reconstruct\\nobj2 = MyModule.somefunction(obj1)   # this time it worked!\\nobj3 = MyModule.someotherfunction(obj2, c)\\n...\"\n},\n\n{\n    \"location\": \"manual/faq.html#Functions-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"Functions\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/faq.html#I-passed-an-argument-x-to-a-function,-modified-it-inside-that-function,-but-on-the-outside,-the-variable-x-is-still-unchanged.-Why?-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"I passed an argument x to a function, modified it inside that function, but on the outside, the variable x is still unchanged. Why?\",\n    \"category\": \"section\",\n    \"text\": \"Suppose you call a function like this:julia> x = 10\\n10\\n\\njulia> function change_value!(y)\\n           y = 17\\n       end\\nchange_value! (generic function with 1 method)\\n\\njulia> change_value!(x)\\n17\\n\\njulia> x # x is unchanged!\\n10In Julia, the binding of a variable x cannot be changed by passing x as an argument to a function. When calling change_value!(x) in the above example, y is a newly created variable, bound initially to the value of x, i.e. 10; then y is rebound to the constant 17, while the variable x of the outer scope is left untouched.But here is a thing you should pay attention to: suppose x is bound to an object of type Array (or any other mutable type). From within the function, you cannot \\\"unbind\\\" x from this Array, but you can change its content. For example:julia> x = [1,2,3]\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n\\njulia> function change_array!(A)\\n           A[1] = 5\\n       end\\nchange_array! (generic function with 1 method)\\n\\njulia> change_array!(x)\\n5\\n\\njulia> x\\n3-element Array{Int64,1}:\\n 5\\n 2\\n 3Here we created a function change_array!, that assigns 5 to the first element of the passed array (bound to x at the call site, and bound to A within the function). Notice that, after the function call, x is still bound to the same array, but the content of that array changed: the variables A and x were distinct bindings referring to the same mutable Array object.\"\n},\n\n{\n    \"location\": \"manual/faq.html#Can-I-use-using-or-import-inside-a-function?-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"Can I use using or import inside a function?\",\n    \"category\": \"section\",\n    \"text\": \"No, you are not allowed to have a using or import statement inside a function.  If you want to import a module but only use its symbols inside a specific function or set of functions, you have two options:Use import:\\nimport Foo\\nfunction bar(...)\\n    # ... refer to Foo symbols via Foo.baz ...\\nend\\nThis loads the module Foo and defines a variable Foo that refers to the module, but does not import any of the other symbols from the module into the current namespace.  You refer to the Foo symbols by their qualified names Foo.bar etc.\\nWrap your function in a module:\\nmodule Bar\\nexport bar\\nusing Foo\\nfunction bar(...)\\n    # ... refer to Foo.baz as simply baz ....\\nend\\nend\\nusing Bar\\nThis imports all the symbols from Foo, but only inside the module Bar.\"\n},\n\n{\n    \"location\": \"manual/faq.html#What-does-the-...-operator-do?-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"What does the ... operator do?\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/faq.html#The-two-uses-of-the-...-operator:-slurping-and-splatting-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"The two uses of the ... operator: slurping and splatting\",\n    \"category\": \"section\",\n    \"text\": \"Many newcomers to Julia find the use of ... operator confusing. Part of what makes the ... operator confusing is that it means two different things depending on context.\"\n},\n\n{\n    \"location\": \"manual/faq.html#...-combines-many-arguments-into-one-argument-in-function-definitions-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"... combines many arguments into one argument in function definitions\",\n    \"category\": \"section\",\n    \"text\": \"In the context of function definitions, the ... operator is used to combine many different arguments into a single argument. This use of ... for combining many different arguments into a single argument is called slurping:julia> function printargs(args...)\\n           println(typeof(args))\\n           for (i, arg) in enumerate(args)\\n               println(\\\"Arg #$i = $arg\\\")\\n           end\\n       end\\nprintargs (generic function with 1 method)\\n\\njulia> printargs(1, 2, 3)\\nTuple{Int64,Int64,Int64}\\nArg #1 = 1\\nArg #2 = 2\\nArg #3 = 3If Julia were a language that made more liberal use of ASCII characters, the slurping operator might have been written as <-... instead of ....\"\n},\n\n{\n    \"location\": \"manual/faq.html#...-splits-one-argument-into-many-different-arguments-in-function-calls-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"... splits one argument into many different arguments in function calls\",\n    \"category\": \"section\",\n    \"text\": \"In contrast to the use of the ... operator to denote slurping many different arguments into one argument when defining a function, the ... operator is also used to cause a single function argument to be split apart into many different arguments when used in the context of a function call. This use of ... is called splatting:julia> function threeargs(a, b, c)\\n           println(\\\"a = $a::$(typeof(a))\\\")\\n           println(\\\"b = $b::$(typeof(b))\\\")\\n           println(\\\"c = $c::$(typeof(c))\\\")\\n       end\\nthreeargs (generic function with 1 method)\\n\\njulia> x = [1, 2, 3]\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n\\njulia> threeargs(x...)\\na = 1::Int64\\nb = 2::Int64\\nc = 3::Int64If Julia were a language that made more liberal use of ASCII characters, the splatting operator might have been written as ...-> instead of ....\"\n},\n\n{\n    \"location\": \"manual/faq.html#What-is-the-return-value-of-an-assignment?-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"What is the return value of an assignment?\",\n    \"category\": \"section\",\n    \"text\": \"The operator = always returns the right-hand side, therefore:julia> function threeint()\\n           x::Int = 3.0\\n           x # returns variable x\\n       end\\nthreeint (generic function with 1 method)\\n\\njulia> function threefloat()\\n           x::Int = 3.0 # returns 3.0\\n       end\\nthreefloat (generic function with 1 method)\\n\\njulia> threeint()\\n3\\n\\njulia> threefloat()\\n3.0and similarly:julia> function threetup()\\n           x, y = [3, 3]\\n           x, y # returns a tuple\\n       end\\nthreetup (generic function with 1 method)\\n\\njulia> function threearr()\\n           x, y = [3, 3] # returns an array\\n       end\\nthreearr (generic function with 1 method)\\n\\njulia> threetup()\\n(3, 3)\\n\\njulia> threearr()\\n2-element Array{Int64,1}:\\n 3\\n 3\"\n},\n\n{\n    \"location\": \"manual/faq.html#Types,-type-declarations,-and-constructors-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"Types, type declarations, and constructors\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/faq.html#man-type-stability-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"What does \\\"type-stable\\\" mean?\",\n    \"category\": \"section\",\n    \"text\": \"It means that the type of the output is predictable from the types of the inputs.  In particular, it means that the type of the output cannot vary depending on the values of the inputs. The following code is not type-stable:julia> function unstable(flag::Bool)\\n           if flag\\n               return 1\\n           else\\n               return 1.0\\n           end\\n       end\\nunstable (generic function with 1 method)It returns either an Int or a Float64 depending on the value of its argument. Since Julia can\\'t predict the return type of this function at compile-time, any computation that uses it will have to guard against both types possibly occurring, making generation of fast machine code difficult.\"\n},\n\n{\n    \"location\": \"manual/faq.html#faq-domain-errors-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"Why does Julia give a DomainError for certain seemingly-sensible operations?\",\n    \"category\": \"section\",\n    \"text\": \"Certain operations make mathematical sense but result in errors:julia> sqrt(-2.0)\\nERROR: DomainError with -2.0:\\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\\nStacktrace:\\n[...]This behavior is an inconvenient consequence of the requirement for type-stability.  In the case of sqrt, most users want sqrt(2.0) to give a real number, and would be unhappy if it produced the complex number 1.4142135623730951 + 0.0im.  One could write the sqrt function to switch to a complex-valued output only when passed a negative number (which is what sqrt does in some other languages), but then the result would not be type-stable and the sqrt function would have poor performance.In these and other cases, you can get the result you want by choosing an input type that conveys your willingness to accept an output type in which the result can be represented:julia> sqrt(-2.0+0im)\\n0.0 + 1.4142135623730951im\"\n},\n\n{\n    \"location\": \"manual/faq.html#Why-does-Julia-use-native-machine-integer-arithmetic?-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"Why does Julia use native machine integer arithmetic?\",\n    \"category\": \"section\",\n    \"text\": \"Julia uses machine arithmetic for integer computations. This means that the range of Int values is bounded and wraps around at either end so that adding, subtracting and multiplying integers can overflow or underflow, leading to some results that can be unsettling at first:julia> typemax(Int)\\n9223372036854775807\\n\\njulia> ans+1\\n-9223372036854775808\\n\\njulia> -ans\\n-9223372036854775808\\n\\njulia> 2*ans\\n0Clearly, this is far from the way mathematical integers behave, and you might think it less than ideal for a high-level programming language to expose this to the user. For numerical work where efficiency and transparency are at a premium, however, the alternatives are worse.One alternative to consider would be to check each integer operation for overflow and promote results to bigger integer types such as Int128 or BigInt in the case of overflow. Unfortunately, this introduces major overhead on every integer operation (think incrementing a loop counter) \u2013 it requires emitting code to perform run-time overflow checks after arithmetic instructions and branches to handle potential overflows. Worse still, this would cause every computation involving integers to be type-unstable. As we mentioned above, type-stability is crucial for effective generation of efficient code. If you can\\'t count on the results of integer operations being integers, it\\'s impossible to generate fast, simple code the way C and Fortran compilers do.A variation on this approach, which avoids the appearance of type instability is to merge the Int and BigInt types into a single hybrid integer type, that internally changes representation when a result no longer fits into the size of a machine integer. While this superficially avoids type-instability at the level of Julia code, it just sweeps the problem under the rug by foisting all of the same difficulties onto the C code implementing this hybrid integer type. This approach can be made to work and can even be made quite fast in many cases, but has several drawbacks. One problem is that the in-memory representation of integers and arrays of integers no longer match the natural representation used by C, Fortran and other languages with native machine integers. Thus, to interoperate with those languages, we would ultimately need to introduce native integer types anyway. Any unbounded representation of integers cannot have a fixed number of bits, and thus cannot be stored inline in an array with fixed-size slots \u2013 large integer values will always require separate heap-allocated storage. And of course, no matter how clever a hybrid integer implementation one uses, there are always performance traps \u2013 situations where performance degrades unexpectedly. Complex representation, lack of interoperability with C and Fortran, the inability to represent integer arrays without additional heap storage, and unpredictable performance characteristics make even the cleverest hybrid integer implementations a poor choice for high-performance numerical work.An alternative to using hybrid integers or promoting to BigInts is to use saturating integer arithmetic, where adding to the largest integer value leaves it unchanged and likewise for subtracting from the smallest integer value. This is precisely what Matlab\u2122 does:>> int64(9223372036854775807)\\n\\nans =\\n\\n  9223372036854775807\\n\\n>> int64(9223372036854775807) + 1\\n\\nans =\\n\\n  9223372036854775807\\n\\n>> int64(-9223372036854775808)\\n\\nans =\\n\\n -9223372036854775808\\n\\n>> int64(-9223372036854775808) - 1\\n\\nans =\\n\\n -9223372036854775808At first blush, this seems reasonable enough since 9223372036854775807 is much closer to 9223372036854775808 than -9223372036854775808 is and integers are still represented with a fixed size in a natural way that is compatible with C and Fortran. Saturated integer arithmetic, however, is deeply problematic. The first and most obvious issue is that this is not the way machine integer arithmetic works, so implementing saturated operations requires emitting instructions after each machine integer operation to check for underflow or overflow and replace the result with typemin(Int) or typemax(Int) as appropriate. This alone expands each integer operation from a single, fast instruction into half a dozen instructions, probably including branches. Ouch. But it gets worse \u2013 saturating integer arithmetic isn\\'t associative. Consider this Matlab computation:>> n = int64(2)^62\\n4611686018427387904\\n\\n>> n + (n - 1)\\n9223372036854775807\\n\\n>> (n + n) - 1\\n9223372036854775806This makes it hard to write many basic integer algorithms since a lot of common techniques depend on the fact that machine addition with overflow is associative. Consider finding the midpoint between integer values lo and hi in Julia using the expression (lo + hi) >>> 1:julia> n = 2^62\\n4611686018427387904\\n\\njulia> (n + 2n) >>> 1\\n6917529027641081856See? No problem. That\\'s the correct midpoint between 2^62 and 2^63, despite the fact that n + 2n is -4611686018427387904. Now try it in Matlab:>> (n + 2*n)/2\\n\\nans =\\n\\n  4611686018427387904Oops. Adding a >>> operator to Matlab wouldn\\'t help, because saturation that occurs when adding n and 2n has already destroyed the information necessary to compute the correct midpoint.Not only is lack of associativity unfortunate for programmers who cannot rely it for techniques like this, but it also defeats almost anything compilers might want to do to optimize integer arithmetic. For example, since Julia integers use normal machine integer arithmetic, LLVM is free to aggressively optimize simple little functions like f(k) = 5k-1. The machine code for this function is just this:julia> code_native(f, Tuple{Int})\\n  .text\\nFilename: none\\n  pushq %rbp\\n  movq  %rsp, %rbp\\nSource line: 1\\n  leaq  -1(%rdi,%rdi,4), %rax\\n  popq  %rbp\\n  retq\\n  nopl  (%rax,%rax)The actual body of the function is a single leaq instruction, which computes the integer multiply and add at once. This is even more beneficial when f gets inlined into another function:julia> function g(k, n)\\n           for i = 1:n\\n               k = f(k)\\n           end\\n           return k\\n       end\\ng (generic function with 1 methods)\\n\\njulia> code_native(g, Tuple{Int,Int})\\n  .text\\nFilename: none\\n  pushq %rbp\\n  movq  %rsp, %rbp\\nSource line: 2\\n  testq %rsi, %rsi\\n  jle L26\\n  nopl  (%rax)\\nSource line: 3\\nL16:\\n  leaq  -1(%rdi,%rdi,4), %rdi\\nSource line: 2\\n  decq  %rsi\\n  jne L16\\nSource line: 5\\nL26:\\n  movq  %rdi, %rax\\n  popq  %rbp\\n  retq\\n  nopSince the call to f gets inlined, the loop body ends up being just a single leaq instruction. Next, consider what happens if we make the number of loop iterations fixed:julia> function g(k)\\n           for i = 1:10\\n               k = f(k)\\n           end\\n           return k\\n       end\\ng (generic function with 2 methods)\\n\\njulia> code_native(g,(Int,))\\n  .text\\nFilename: none\\n  pushq %rbp\\n  movq  %rsp, %rbp\\nSource line: 3\\n  imulq $9765625, %rdi, %rax    # imm = 0x9502F9\\n  addq  $-2441406, %rax         # imm = 0xFFDABF42\\nSource line: 5\\n  popq  %rbp\\n  retq\\n  nopw  %cs:(%rax,%rax)Because the compiler knows that integer addition and multiplication are associative and that multiplication distributes over addition \u2013 neither of which is true of saturating arithmetic \u2013 it can optimize the entire loop down to just a multiply and an add. Saturated arithmetic completely defeats this kind of optimization since associativity and distributivity can fail at each loop iteration, causing different outcomes depending on which iteration the failure occurs in. The compiler can unroll the loop, but it cannot algebraically reduce multiple operations into fewer equivalent operations.The most reasonable alternative to having integer arithmetic silently overflow is to do checked arithmetic everywhere, raising errors when adds, subtracts, and multiplies overflow, producing values that are not value-correct. In this blog post, Dan Luu analyzes this and finds that rather than the trivial cost that this approach should in theory have, it ends up having a substantial cost due to compilers (LLVM and GCC) not gracefully optimizing around the added overflow checks. If this improves in the future, we could consider defaulting to checked integer arithmetic in Julia, but for now, we have to live with the possibility of overflow.\"\n},\n\n{\n    \"location\": \"manual/faq.html#What-are-the-possible-causes-of-an-UndefVarError-during-remote-execution?-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"What are the possible causes of an UndefVarError during remote execution?\",\n    \"category\": \"section\",\n    \"text\": \"As the error states, an immediate cause of an UndefVarError on a remote node is that a binding by that name does not exist. Let us explore some of the possible causes.julia> module Foo\\n           foo() = remotecall_fetch(x->x, 2, \\\"Hello\\\")\\n       end\\n\\njulia> Foo.foo()\\nERROR: On worker 2:\\nUndefVarError: Foo not defined\\nStacktrace:\\n[...]The closure x->x carries a reference to Foo, and since Foo is unavailable on node 2, an UndefVarError is thrown.Globals under modules other than Main are not serialized by value to the remote node. Only a reference is sent. Functions which create global bindings (except under Main) may cause an UndefVarError to be thrown later.julia> @everywhere module Foo\\n           function foo()\\n               global gvar = \\\"Hello\\\"\\n               remotecall_fetch(()->gvar, 2)\\n           end\\n       end\\n\\njulia> Foo.foo()\\nERROR: On worker 2:\\nUndefVarError: gvar not defined\\nStacktrace:\\n[...]In the above example, @everywhere module Foo defined Foo on all nodes. However the call to Foo.foo() created a new global binding gvar on the local node, but this was not found on node 2 resulting in an UndefVarError error.Note that this does not apply to globals created under module Main. Globals under module Main are serialized and new bindings created under Main on the remote node.julia> gvar_self = \\\"Node1\\\"\\n\\\"Node1\\\"\\n\\njulia> remotecall_fetch(()->gvar_self, 2)\\n\\\"Node1\\\"\\n\\njulia> remotecall_fetch(varinfo, 2)\\nname          size summary\\n\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013 \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013 \u2013\u2013\u2013\u2013\u2013\u2013\u2013\\nBase               Module\\nCore               Module\\nMain               Module\\ngvar_self 13 bytes StringThis does not apply to function or struct declarations. However, anonymous functions bound to global variables are serialized as can be seen below.julia> bar() = 1\\nbar (generic function with 1 method)\\n\\njulia> remotecall_fetch(bar, 2)\\nERROR: On worker 2:\\nUndefVarError: #bar not defined\\n[...]\\n\\njulia> anon_bar  = ()->1\\n(::#21) (generic function with 1 method)\\n\\njulia> remotecall_fetch(anon_bar, 2)\\n1\"\n},\n\n{\n    \"location\": \"manual/faq.html#Packages-and-Modules-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"Packages and Modules\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/faq.html#What-is-the-difference-between-\\\"using\\\"-and-\\\"import\\\"?-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"What is the difference between \\\"using\\\" and \\\"import\\\"?\",\n    \"category\": \"section\",\n    \"text\": \"There is only one difference, and on the surface (syntax-wise) it may seem very minor. The difference between using and import is that with using you need to say function Foo.bar(.. to extend module Foo\\'s function bar with a new method, but with import Foo.bar, you only need to say function bar(... and it automatically extends module Foo\\'s function bar.The reason this is important enough to have been given separate syntax is that you don\\'t want to accidentally extend a function that you didn\\'t know existed, because that could easily cause a bug. This is most likely to happen with a method that takes a common type like a string or integer, because both you and the other module could define a method to handle such a common type. If you use import, then you\\'ll replace the other module\\'s implementation of bar(s::AbstractString) with your new implementation, which could easily do something completely different (and break all/many future usages of the other functions in module Foo that depend on calling bar).\"\n},\n\n{\n    \"location\": \"manual/faq.html#Nothingness-and-missing-values-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"Nothingness and missing values\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/faq.html#faq-nothing-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"How does \\\"null\\\", \\\"nothingness\\\" or \\\"missingness\\\" work in Julia?\",\n    \"category\": \"section\",\n    \"text\": \"Unlike many languages (for example, C and Java), Julia objects cannot be \\\"null\\\" by default. When a reference (variable, object field, or array element) is uninitialized, accessing it will immediately throw an error. This situation can be detected using the isdefined or isassigned functions.Some functions are used only for their side effects, and do not need to return a value. In these cases, the convention is to return the value nothing, which is just a singleton object of type Nothing. This is an ordinary type with no fields; there is nothing special about it except for this convention, and that the REPL does not print anything for it. Some language constructs that would not otherwise have a value also yield nothing, for example if false; end.For situations where a value x of type T exists only sometimes, the Union{T, Nothing} type can be used for function arguments, object fields and array element types as the equivalent of Nullable, Option or Maybe in other languages. If the value itself can be nothing (notably, when T is Any), the Union{Some{T}, Nothing} type is more appropriate since x == nothing then indicates the absence of a value, and x == Some(nothing) indicates the presence of a value equal to nothing. The something function allows unwrapping Some objects and using a default value instead of nothing arguments. Note that the compiler is able to generate efficient code when working with Union{T, Nothing} arguments or fields.To represent missing data in the statistical sense (NA in R or NULL in SQL), use the missing object. See the Missing Values section for more details.The empty tuple (()) is another form of nothingness. But, it should not really be thought of as nothing but rather a tuple of zero values.The empty (or \\\"bottom\\\") type, written as Union{} (an empty union type), is a type with no values and no subtypes (except itself). You will generally not need to use this type.\"\n},\n\n{\n    \"location\": \"manual/faq.html#How-do-I-check-if-the-current-file-is-being-run-as-the-main-script?-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"How do I check if the current file is being run as the main script?\",\n    \"category\": \"section\",\n    \"text\": \"When a file is run as the main script using julia file.jl one might want to activate extra functionality like command line argument handling. A way to determine that a file is run in this fashion is to check if abspath(PROGRAM_FILE) == @__FILE__ is true.\"\n},\n\n{\n    \"location\": \"manual/faq.html#Memory-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"Memory\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/faq.html#Why-does-x-y-allocate-memory-when-x-and-y-are-arrays?-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"Why does x += y allocate memory when x and y are arrays?\",\n    \"category\": \"section\",\n    \"text\": \"In Julia, x += y gets replaced during parsing by x = x + y. For arrays, this has the consequence that, rather than storing the result in the same location in memory as x, it allocates a new array to store the result.While this behavior might surprise some, the choice is deliberate. The main reason is the presence of immutable objects within Julia, which cannot change their value once created.  Indeed, a number is an immutable object; the statements x = 5; x += 1 do not modify the meaning of 5, they modify the value bound to x. For an immutable, the only way to change the value is to reassign it.To amplify a bit further, consider the following function:function power_by_squaring(x, n::Int)\\n    ispow2(n) || error(\\\"This implementation only works for powers of 2\\\")\\n    while n >= 2\\n        x *= x\\n        n >>= 1\\n    end\\n    x\\nendAfter a call like x = 5; y = power_by_squaring(x, 4), you would get the expected result: x == 5 && y == 625.  However, now suppose that *=, when used with matrices, instead mutated the left hand side.  There would be two problems:For general square matrices, A = A*B cannot be implemented without temporary storage: A[1,1] gets computed and stored on the left hand side before you\\'re done using it on the right hand side.\\nSuppose you were willing to allocate a temporary for the computation (which would eliminate most of the point of making *= work in-place); if you took advantage of the mutability of x, then this function would behave differently for mutable vs. immutable inputs. In particular, for immutable x, after the call you\\'d have (in general) y != x, but for mutable x you\\'d have y == x.Because supporting generic programming is deemed more important than potential performance optimizations that can be achieved by other means (e.g., using explicit loops), operators like += and *= work by rebinding new values.\"\n},\n\n{\n    \"location\": \"manual/faq.html#Asynchronous-IO-and-concurrent-synchronous-writes-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"Asynchronous IO and concurrent synchronous writes\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/faq.html#Why-do-concurrent-writes-to-the-same-stream-result-in-inter-mixed-output?-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"Why do concurrent writes to the same stream result in inter-mixed output?\",\n    \"category\": \"section\",\n    \"text\": \"While the streaming I/O API is synchronous, the underlying implementation is fully asynchronous.Consider the printed output from the following:julia> @sync for i in 1:3\\n           @async write(stdout, string(i), \\\" Foo \\\", \\\" Bar \\\")\\n       end\\n123 Foo  Foo  Foo  Bar  Bar  BarThis is happening because, while the write call is synchronous, the writing of each argument yields to other tasks while waiting for that part of the I/O to complete.print and println \\\"lock\\\" the stream during a call. Consequently changing write to println in the above example results in:julia> @sync for i in 1:3\\n           @async println(stdout, string(i), \\\" Foo \\\", \\\" Bar \\\")\\n       end\\n1 Foo  Bar\\n2 Foo  Bar\\n3 Foo  BarYou can lock your writes with a ReentrantLock like this:julia> l = ReentrantLock()\\nReentrantLock(nothing, Condition(Any[]), 0)\\n\\njulia> @sync for i in 1:3\\n           @async begin\\n               lock(l)\\n               try\\n                   write(stdout, string(i), \\\" Foo \\\", \\\" Bar \\\")\\n               finally\\n                   unlock(l)\\n               end\\n           end\\n       end\\n1 Foo  Bar 2 Foo  Bar 3 Foo  Bar\"\n},\n\n{\n    \"location\": \"manual/faq.html#Arrays-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"Arrays\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/faq.html#What-are-the-differences-between-zero-dimensional-arrays-and-scalars?-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"What are the differences between zero-dimensional arrays and scalars?\",\n    \"category\": \"section\",\n    \"text\": \"Zero-dimensional arrays are arrays of the form Array{T,0}. They behave similar to scalars, but there are important differences. They deserve a special mention because they are a special case which makes logical sense given the generic definition of arrays, but might be a bit unintuitive at first. The following line defines a zero-dimensional array:julia> A = zeros()\\n0-dimensional Array{Float64,0}:\\n0.0In this example, A is a mutable container that contains one element, which can be set by A[] = 1.0 and retrieved with A[]. All zero-dimensional arrays have the same size (size(A) == ()), and length (length(A) == 1). In particular, zero-dimensional arrays are not empty. If you find this unintuitive, here are some ideas that might help to understand Julia\\'s definition.Zero-dimensional arrays are the \\\"point\\\" to vector\\'s \\\"line\\\" and matrix\\'s \\\"plane\\\". Just as a line has no area (but still represents a set of things), a point has no length or any dimensions at all (but still represents a thing).\\nWe define prod(()) to be 1, and the total number of elements in an array is the product of the size. The size of a zero-dimensional array is (), and therefore its length is 1.\\nZero-dimensional arrays don\\'t natively have any dimensions into which you index \u2013 they\u2019re just A[]. We can apply the same \\\"trailing one\\\" rule for them as for all other array dimensionalities, so you can indeed index them as A[1], A[1,1], etc.It is also important to understand the differences to ordinary scalars. Scalars are not mutable containers (even though they are iterable and define things like length, getindex, e.g. 1[] == 1). In particular, if x = 0.0 is defined as a scalar, it is an error to attempt to change its value via x[] = 1.0. A scalar x can be converted into a zero-dimensional array containing it via fill(x), and conversely, a zero-dimensional array a can be converted to the contained scalar via a[]. Another difference is that a scalar can participate in linear algebra operations such as 2 * rand(2,2), but the analogous operation with a zero-dimensional array fill(2) * rand(2,2) is an error.\"\n},\n\n{\n    \"location\": \"manual/faq.html#Julia-Releases-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"Julia Releases\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/faq.html#Do-I-want-to-use-a-release,-beta,-or-nightly-version-of-Julia?-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"Do I want to use a release, beta, or nightly version of Julia?\",\n    \"category\": \"section\",\n    \"text\": \"You may prefer the release version of Julia if you are looking for a stable code base. Releases generally occur every 6 months, giving you a stable platform for writing code.You may prefer the beta version of Julia if you don\\'t mind being slightly behind the latest bugfixes and changes, but find the slightly faster rate of changes more appealing. Additionally, these binaries are tested before they are published to ensure they are fully functional.You may prefer the nightly version of Julia if you want to take advantage of the latest updates to the language, and don\\'t mind if the version available today occasionally doesn\\'t actually work.Finally, you may also consider building Julia from source for yourself. This option is mainly for those individuals who are comfortable at the command line, or interested in learning. If this describes you, you may also be interested in reading our guidelines for contributing.Links to each of these download types can be found on the download page at https://julialang.org/downloads/. Note that not all versions of Julia are available for all platforms.\"\n},\n\n{\n    \"location\": \"manual/faq.html#When-are-deprecated-functions-removed?-1\",\n    \"page\": \"Frequently Asked Questions\",\n    \"title\": \"When are deprecated functions removed?\",\n    \"category\": \"section\",\n    \"text\": \"Deprecated functions are removed after the subsequent release. For example, functions marked as deprecated in the 0.1 release will not be available starting with the 0.2 release.\"\n},\n\n{\n    \"location\": \"manual/noteworthy-differences.html#\",\n    \"page\": \"Noteworthy Differences from other Languages\",\n    \"title\": \"Noteworthy Differences from other Languages\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/noteworthy-differences.html#Noteworthy-Differences-from-other-Languages-1\",\n    \"page\": \"Noteworthy Differences from other Languages\",\n    \"title\": \"Noteworthy Differences from other Languages\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/noteworthy-differences.html#Noteworthy-differences-from-MATLAB-1\",\n    \"page\": \"Noteworthy Differences from other Languages\",\n    \"title\": \"Noteworthy differences from MATLAB\",\n    \"category\": \"section\",\n    \"text\": \"Although MATLAB users may find Julia\\'s syntax familiar, Julia is not a MATLAB clone. There are major syntactic and functional differences. The following are some noteworthy differences that may trip up Julia users accustomed to MATLAB:Julia arrays are indexed with square brackets, A[i,j].\\nJulia arrays are not copied when assigned to another variable. After A = B, changing elements of B will modify A as well.\\nJulia values are not copied when passed to a function. If a function modifies an array, the changes will be visible in the caller.\\nJulia does not automatically grow arrays in an assignment statement. Whereas in MATLAB a(4) = 3.2 can create the array a = [0 0 0 3.2] and a(5) = 7 can grow it into a = [0 0 0 3.2 7], the corresponding Julia statement a[5] = 7 throws an error if the length of a is less than 5 or if this statement is the first use of the identifier a. Julia has push! and append!, which grow Vectors much more efficiently than MATLAB\\'s a(end+1) = val.\\nThe imaginary unit sqrt(-1) is represented in Julia as im, not i or j as in MATLAB.\\nIn Julia, literal numbers without a decimal point (such as 42) create integers instead of floating point numbers. Arbitrarily large integer literals are supported. As a result, some operations such as 2^-1 will throw a domain error as the result is not an integer (see the FAQ entry on domain errors for details).\\nIn Julia, multiple values are returned and assigned as tuples, e.g. (a, b) = (1, 2) or a, b = 1, 2. MATLAB\\'s nargout, which is often used in MATLAB to do optional work based on the number of returned values, does not exist in Julia. Instead, users can use optional and keyword arguments to achieve similar capabilities.\\nJulia has true one-dimensional arrays. Column vectors are of size N, not Nx1. For example, rand(N) makes a 1-dimensional array.\\nIn Julia, [x,y,z] will always construct a 3-element array containing x, y and z.\\nTo concatenate in the first (\\\"vertical\\\") dimension use either vcat(x,y,z) or separate with semicolons ([x; y; z]).\\nTo concatenate in the second (\\\"horizontal\\\") dimension use either hcat(x,y,z) or separate with spaces ([x y z]).\\nTo construct block matrices (concatenating in the first two dimensions), use either hvcat or combine spaces and semicolons ([a b; c d]).\\nIn Julia, a:b and a:b:c construct AbstractRange objects. To construct a full vector like in MATLAB, use collect(a:b). Generally, there is no need to call collect though. An AbstractRange object will act like a normal array in most cases but is more efficient because it lazily computes its values. This pattern of creating specialized objects instead of full arrays is used frequently, and is also seen in functions such as range, or with iterators such as enumerate, and zip. The special objects can mostly be used as if they were normal arrays.\\nFunctions in Julia return values from their last expression or the return keyword instead of listing the names of variables to return in the function definition (see The return Keyword for details).\\nA Julia script may contain any number of functions, and all definitions will be externally visible when the file is loaded. Function definitions can be loaded from files outside the current working directory.\\nIn Julia, reductions such as sum, prod, and max are performed over every element of an array when called with a single argument, as in sum(A), even if A has more than one dimension.\\nIn Julia, parentheses must be used to call a function with zero arguments, like in rand().\\nJulia discourages the used of semicolons to end statements. The results of statements are not automatically printed (except at the interactive prompt), and lines of code do not need to end with semicolons. println or @printf can be used to print specific output.\\nIn Julia, if A and B are arrays, logical comparison operations like A == B do not return an array of booleans. Instead, use A .== B, and similarly for the other boolean operators like <, > and =.\\nIn Julia, the operators &, |, and \u22bb (xor) perform the bitwise operations equivalent to and, or, and xor respectively in MATLAB, and have precedence similar to Python\\'s bitwise operators (unlike C). They can operate on scalars or element-wise across arrays and can be used to combine logical arrays, but note the difference in order of operations: parentheses may be required (e.g., to select elements of A equal to 1 or 2 use (A .== 1) .| (A .== 2)).\\nIn Julia, the elements of a collection can be passed as arguments to a function using the splat operator ..., as in xs=[1,2]; f(xs...).\\nJulia\\'s svd returns singular values as a vector instead of as a dense diagonal matrix.\\nIn Julia, ... is not used to continue lines of code. Instead, incomplete expressions automatically continue onto the next line.\\nIn both Julia and MATLAB, the variable ans is set to the value of the last expression issued in an interactive session. In Julia, unlike MATLAB, ans is not set when Julia code is run in non-interactive mode.\\nJulia\\'s structs do not support dynamically adding fields at runtime, unlike MATLAB\\'s classes. Instead, use a Dict.\\nIn Julia each module has its own global scope/namespace, whereas in MATLAB there is just one global scope.\\nIn MATLAB, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression x(x>3) or in the statement x(x>3) = [] to modify x in-place. In contrast, Julia provides the higher order functions filter and filter!, allowing users to write filter(z->z>3, x) and filter!(z->z>3, x) as alternatives to the corresponding transliterations x[x.>3] and x = x[x.>3]. Using filter! reduces the use of temporary arrays.\\nThe analogue of extracting (or \\\"dereferencing\\\") all elements of a cell array, e.g. in vertcat(A{:}) in MATLAB, is written using the splat operator in Julia, e.g. as vcat(A...).\"\n},\n\n{\n    \"location\": \"manual/noteworthy-differences.html#Noteworthy-differences-from-R-1\",\n    \"page\": \"Noteworthy Differences from other Languages\",\n    \"title\": \"Noteworthy differences from R\",\n    \"category\": \"section\",\n    \"text\": \"One of Julia\\'s goals is to provide an effective language for data analysis and statistical programming. For users coming to Julia from R, these are some noteworthy differences:Julia\\'s single quotes enclose characters, not strings.\\nJulia can create substrings by indexing into strings. In R, strings must be converted into character vectors before creating substrings.\\nIn Julia, like Python but unlike R, strings can be created with triple quotes \\\"\\\"\\\" ... \\\"\\\"\\\". This syntax is convenient for constructing strings that contain line breaks.\\nIn Julia, varargs are specified using the splat operator ..., which always follows the name of a specific variable, unlike R, for which ... can occur in isolation.\\nIn Julia, modulus is mod(a, b), not a %% b. % in Julia is the remainder operator.\\nIn Julia, not all data structures support logical indexing. Furthermore, logical indexing in Julia is supported only with vectors of length equal to the object being indexed. For example:\\nIn R, c(1, 2, 3, 4)[c(TRUE, FALSE)] is equivalent to c(1, 3).\\nIn R, c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)] is equivalent to c(1, 3).\\nIn Julia, [1, 2, 3, 4][[true, false]] throws a BoundsError.\\nIn Julia, [1, 2, 3, 4][[true, false, true, false]] produces [1, 3].\\nLike many languages, Julia does not always allow operations on vectors of different lengths, unlike R where the vectors only need to share a common index range.  For example, c(1, 2, 3, 4) + c(1, 2) is valid R but the equivalent [1, 2, 3, 4] + [1, 2] will throw an error in Julia.\\nJulia allows an optional trailing comma when that comma does not change the meaning of code. This can cause confusion among R users when indexing into arrays. For example, x[1,] in R would return the first row of a matrix; in Julia, however, the comma is ignored, so x[1,] == x[1], and will return the first element. To extract a row, be sure to use :, as in x[1,:].\\nJulia\\'s map takes the function first, then its arguments, unlike lapply(<structure>, function, ...) in R. Similarly Julia\\'s equivalent of apply(X, MARGIN, FUN, ...) in R is mapslices where the function is the first argument.\\nMultivariate apply in R, e.g. mapply(choose, 11:13, 1:3), can be written as broadcast(binomial, 11:13, 1:3) in Julia. Equivalently Julia offers a shorter dot syntax for vectorizing functions binomial.(11:13, 1:3).\\nJulia uses end to denote the end of conditional blocks, like if, loop blocks, like while/ for, and functions. In lieu of the one-line if ( cond ) statement, Julia allows statements of the form if cond; statement; end, cond && statement and !cond || statement. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. cond && (x = value).\\nIn Julia, <-, <<- and -> are not assignment operators.\\nJulia\\'s -> creates an anonymous function.\\nJulia constructs vectors using brackets. Julia\\'s [1, 2, 3] is the equivalent of R\\'s c(1, 2, 3).\\nJulia\\'s * operator can perform matrix multiplication, unlike in R. If A and B are matrices, then A * B denotes a matrix multiplication in Julia, equivalent to R\\'s A %*% B. In R, this same notation would perform an element-wise (Hadamard) product. To get the element-wise multiplication operation, you need to write A .* B in Julia.\\nJulia performs matrix transposition using the transpose function and conjugated transposition using the \\' operator or the adjoint function. Julia\\'s transpose(A) is therefore equivalent to R\\'s t(A). Additionally a non-recursive transpose in Julia is provided by the permutedims function.\\nJulia does not require parentheses when writing if statements or for/while loops: use for i in [1, 2, 3] instead of for (i in c(1, 2, 3)) and if i == 1 instead of if (i == 1).\\nJulia does not treat the numbers 0 and 1 as Booleans. You cannot write if (1) in Julia, because if statements accept only booleans. Instead, you can write if true, if Bool(1), or if 1==1.\\nJulia does not provide nrow and ncol. Instead, use size(M, 1) for nrow(M) and size(M, 2) for ncol(M).\\nJulia is careful to distinguish scalars, vectors and matrices.  In R, 1 and c(1) are the same. In Julia, they cannot be used interchangeably.\\nJulia\\'s diag and diagm are not like R\\'s.\\nJulia cannot assign to the results of function calls on the left hand side of an assignment operation: you cannot write diag(M) = fill(1, n).\\nJulia discourages populating the main namespace with functions. Most statistical functionality for Julia is found in packages under the JuliaStats organization. For example:\\nFunctions pertaining to probability distributions are provided by the Distributions package.\\nThe DataFrames package provides data frames.\\nGeneralized linear models are provided by the GLM package.\\nJulia provides tuples and real hash tables, but not R-style lists. When returning multiple items, you should typically use a tuple or a named tuple: instead of list(a = 1, b = 2), use (1, 2) or (a=1, b=2).\\nJulia encourages users to write their own types, which are easier to use than S3 or S4 objects in R. Julia\\'s multiple dispatch system means that table(x::TypeA) and table(x::TypeB) act like R\\'s table.TypeA(x) and table.TypeB(x).\\nIn Julia, values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller. This is very different from R and allows new functions to operate on large data structures much more efficiently.\\nIn Julia, vectors and matrices are concatenated using hcat, vcat and hvcat, not c, rbind and cbind like in R.\\nIn Julia, a range like a:b is not shorthand for a vector like in R, but is a specialized AbstractRange object that is used for iteration without high memory overhead. To convert a range into a vector, use collect(a:b).\\nJulia\\'s max and min are the equivalent of pmax and pmin respectively in R, but both arguments need to have the same dimensions.  While maximum and minimum replace max and min in R, there are important differences.\\nJulia\\'s sum, prod, maximum, and minimum are different from their counterparts in R. They all accept one or two arguments. The first argument is an iterable collection such as an array.  If there is a second argument, then this argument indicates the dimensions, over which the operation is carried out.  For instance, let A = [1 2; 3 4] in Julia and B <- rbind(c(1,2),c(3,4)) be the same matrix in R.  Then sum(A) gives the same result as sum(B), but sum(A, dims=1) is a row vector containing the sum over each column and sum(A, dims=2) is a column vector containing the sum over each row. This contrasts to the behavior of R, where separate colSums(B) and rowSums(B) functions provide these functionalities. If the dims keyword argument is a vector, then it specifies all the dimensions over which the sum is performed, while retaining the dimensions of the summed array, e.g. sum(A, dims=(1,2)) == hcat(10). It should be noted that there is no error checking regarding the second argument.\\nJulia has several functions that can mutate their arguments. For example, it has both sort and sort!.\\nIn R, performance requires vectorization. In Julia, almost the opposite is true: the best performing code is often achieved by using devectorized loops.\\nJulia is eagerly evaluated and does not support R-style lazy evaluation. For most users, this means that there are very few unquoted expressions or column names.\\nJulia does not support the NULL type. The closest equivalent is nothing, but it behaves like a scalar value rather than like a list. Use x == nothing instead of is.null(x).\\nIn Julia, missing values are represented by the missing object rather than by NA. Use ismissing(x) instead of isna(x). The skipmissing function is generally used instead of na.rm=TRUE (though in some particular cases functions take a skipmissing argument).\\nJulia lacks the equivalent of R\\'s assign or get.\\nIn Julia, return does not require parentheses.\\nIn R, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression x[x>3] or in the statement x = x[x>3] to modify x in-place. In contrast, Julia provides the higher order functions filter and filter!, allowing users to write filter(z->z>3, x) and filter!(z->z>3, x) as alternatives to the corresponding transliterations x[x.>3] and x = x[x.>3]. Using filter! reduces the use of temporary arrays.\"\n},\n\n{\n    \"location\": \"manual/noteworthy-differences.html#Noteworthy-differences-from-Python-1\",\n    \"page\": \"Noteworthy Differences from other Languages\",\n    \"title\": \"Noteworthy differences from Python\",\n    \"category\": \"section\",\n    \"text\": \"Julia requires end to end a block. Unlike Python, Julia has no pass keyword.\\nIn Julia, indexing of arrays, strings, etc. is 1-based not 0-based.\\nJulia\\'s slice indexing includes the last element, unlike in Python. a[2:3] in Julia is a[1:3] in Python.\\nJulia does not support negative indices. In particular, the last element of a list or array is indexed with end in Julia, not -1 as in Python.\\nJulia\\'s for, if, while, etc. blocks are terminated by the end keyword. Indentation level is not significant as it is in Python.\\nJulia has no line continuation syntax: if, at the end of a line, the input so far is a complete expression, it is considered done; otherwise the input continues. One way to force an expression to continue is to wrap it in parentheses.\\nJulia arrays are column major (Fortran ordered) whereas NumPy arrays are row major (C-ordered) by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to NumPy (see relevant section of Performance Tips).\\nJulia\\'s updating operators (e.g. +=, -=, ...) are not in-place whereas NumPy\\'s are. This means A = [1, 1]; B = A; B += [3, 3] doesn\\'t change values in A, it rather rebinds the name B to the result of the right-hand side B = B + 3, which is a new array. For in-place operation, use B .+= 3 (see also dot operators), explicit loops, or InplaceOps.jl.\\nJulia evaluates default values of function arguments every time the method is invoked, unlike in Python where the default values are evaluated only once when the function is defined. For example, the function f(x=rand()) = x returns a new random number every time it is invoked without argument. On the other hand, the function g(x=[1,2]) = push!(x,3) returns [1,2,3] every time it is called as g().\\nIn Julia % is the remainder operator, whereas in Python it is the modulus.\"\n},\n\n{\n    \"location\": \"manual/noteworthy-differences.html#Noteworthy-differences-from-C/C-1\",\n    \"page\": \"Noteworthy Differences from other Languages\",\n    \"title\": \"Noteworthy differences from C/C++\",\n    \"category\": \"section\",\n    \"text\": \"Julia arrays are indexed with square brackets, and can have more than one dimension A[i,j]. This syntax is not just syntactic sugar for a reference to a pointer or address as in C/C++. See the Julia documentation for the syntax for array construction (it has changed between versions).\\nIn Julia, indexing of arrays, strings, etc. is 1-based not 0-based.\\nJulia arrays are not copied when assigned to another variable. After A = B, changing elements of B will modify A as well. Updating operators like += do not operate in-place, they are equivalent to A = A + B which rebinds the left-hand side to the result of the right-hand side expression.\\nJulia arrays are column major (Fortran ordered) whereas C/C++ arrays are row major ordered by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to C/C++ (see relevant section of Performance Tips).\\nJulia values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller.\\nIn Julia, whitespace is significant, unlike C/C++, so care must be taken when adding/removing whitespace from a Julia program.\\nIn Julia, literal numbers without a decimal point (such as 42) create signed integers, of type Int, but literals too large to fit in the machine word size will automatically be promoted to a larger size type, such as Int64 (if Int is Int32), Int128, or the arbitrarily large BigInt type. There are no numeric literal suffixes, such as L, LL, U, UL, ULL to indicate unsigned and/or signed vs. unsigned. Decimal literals are always signed, and hexadecimal literals (which start with 0x like C/C++), are unsigned. Hexadecimal literals also, unlike C/C++/Java and unlike decimal literals in Julia, have a type based on the length of the literal, including leading 0s. For example, 0x0 and 0x00 have type UInt8, 0x000 and 0x0000 have type UInt16, then literals with 5 to 8 hex digits have type UInt32, 9 to 16 hex digits type UInt64 and 17 to 32 hex digits type UInt128. This needs to be taken into account when defining hexadecimal masks, for example ~0xf == 0xf0 is very different from ~0x000f == 0xfff0. 64 bit Float64 and 32 bit Float32 bit literals are expressed as 1.0 and 1.0f0 respectively. Floating point literals are rounded (and not promoted to the BigFloat type) if they can not be exactly represented.  Floating point literals are closer in behavior to C/C++. Octal (prefixed with 0o) and binary (prefixed with 0b) literals are also treated as unsigned.\\nString literals can be delimited with either \\\"  or \\\"\\\"\\\", \\\"\\\"\\\" delimited literals can contain \\\" characters without quoting it like \\\"\\\\\\\"\\\" String literals can have values of other variables or expressions interpolated into them, indicated by $variablename or $(expression), which evaluates the variable name or the expression in the context of the function.\\n// indicates a Rational number, and not a single-line comment (which is # in Julia)\\n#= indicates the start of a multiline comment, and =# ends it.\\nFunctions in Julia return values from their last expression(s) or the return keyword.  Multiple values can be returned from functions and assigned as tuples, e.g. (a, b) = myfunction() or a, b = myfunction(), instead of having to pass pointers to values as one would have to do in C/C++ (i.e. a = myfunction(&b).\\nJulia does not require the use of semicolons to end statements. The results of expressions are not automatically printed (except at the interactive prompt, i.e. the REPL), and lines of code do not need to end with semicolons. println or @printf can be used to print specific output. In the REPL, ; can be used to suppress output. ; also has a different meaning within [ ], something to watch out for. ; can be used to separate expressions on a single line, but are not strictly necessary in many cases, and are more an aid to readability.\\nIn Julia, the operator \u22bb (xor) performs the bitwise XOR operation, i.e. ^ in C/C++.  Also, the bitwise operators do not have the same precedence as C/++, so parenthesis may be required.\\nJulia\\'s ^ is exponentiation (pow), not bitwise XOR as in C/C++ (use \u22bb, or xor, in Julia)\\nJulia has two right-shift operators, >> and >>>.  >>> performs an arithmetic shift, >> always performs a logical shift, unlike C/C++, where the meaning of >> depends on the type of the value being shifted.\\nJulia\\'s -> creates an anonymous function, it does not access a member via a pointer.\\nJulia does not require parentheses when writing if statements or for/while loops: use for i in [1, 2, 3] instead of for (int i=1; i <= 3; i++) and if i == 1 instead of if (i == 1).\\nJulia does not treat the numbers 0 and 1 as Booleans. You cannot write if (1) in Julia, because if statements accept only booleans. Instead, you can write if true, if Bool(1), or if 1==1.\\nJulia uses end to denote the end of conditional blocks, like if, loop blocks, like while/ for, and functions. In lieu of the one-line if ( cond ) statement, Julia allows statements of the form if cond; statement; end, cond && statement and !cond || statement. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. cond && (x = value), because of the operator precedence.\\nJulia has no line continuation syntax: if, at the end of a line, the input so far is a complete expression, it is considered done; otherwise the input continues. One way to force an expression to continue is to wrap it in parentheses.\\nJulia macros operate on parsed expressions, rather than the text of the program, which allows them to perform sophisticated transformations of Julia code. Macro names start with the @ character, and have both a function-like syntax, @mymacro(arg1, arg2, arg3), and a statement-like syntax, @mymacro arg1 arg2 arg3. The forms are interchangeable; the function-like form is particularly useful if the macro appears within another expression, and is often clearest. The statement-like form is often used to annotate blocks, as in the distributed for construct: @distributed for i in 1:n; #= body =#; end. Where the end of the macro construct may be unclear, use the function-like form.\\nJulia now has an enumeration type, expressed using the macro @enum(name, value1, value2, ...) For example: @enum(Fruit, banana=1, apple, pear)\\nBy convention, functions that modify their arguments have a ! at the end of the name, for example push!.\\nIn C++, by default, you have static dispatch, i.e. you need to annotate a function as virtual, in order to have dynamic dispatch. On the other hand, in Julia every method is \\\"virtual\\\" (although it\\'s more general than that since methods are dispatched on every argument type, not only this, using the most-specific-declaration rule).\"\n},\n\n{\n    \"location\": \"manual/unicode-input.html#\",\n    \"page\": \"Unicode Input\",\n    \"title\": \"Unicode Input\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"manual/unicode-input.html#Unicode-Input-1\",\n    \"page\": \"Unicode Input\",\n    \"title\": \"Unicode Input\",\n    \"category\": \"section\",\n    \"text\": \"The following table lists Unicode characters that can be entered via tab completion of LaTeX-like abbreviations in the Julia REPL (and in various other editing environments).  You can also get information on how to type a symbol by entering it in the REPL help, i.e. by typing ? and then entering the symbol in the REPL (e.g., by copy-paste from somewhere you saw the symbol).warning: Warning\\nThis table may appear to contain missing characters in the second column, or even show characters that are inconsistent with the characters as they are rendered in the Julia REPL. In these cases, users are strongly advised to check their choice of fonts in their browser and REPL environment, as there are known issues with glyphs in many fonts.#\\n# Generate a table containing all LaTeX and Emoji tab completions available in the REPL.\\n#\\nimport REPL, Markdown\\nconst NBSP = \\'\\\\u00A0\\'\\n\\nfunction tab_completions(symbols...)\\n    completions = Dict{String, Vector{String}}()\\n    for each in symbols, (k, v) in each\\n        completions[v] = push!(get!(completions, v, String[]), k)\\n    end\\n    return completions\\nend\\n\\nfunction unicode_data()\\n    file = normpath(Sys.BINDIR, \\\"..\\\", \\\"..\\\", \\\"doc\\\", \\\"UnicodeData.txt\\\")\\n    names = Dict{UInt32, String}()\\n    open(file) do unidata\\n        for line in readlines(unidata)\\n            id, name, desc = split(line, \\\";\\\")[[1, 2, 11]]\\n            codepoint = parse(UInt32, \\\"0x$id\\\")\\n            names[codepoint] = titlecase(lowercase(\\n                name == \\\"\\\" ? desc : desc == \\\"\\\" ? name : \\\"$name / $desc\\\"))\\n        end\\n    end\\n    return names\\nend\\n\\n# Surround combining characters with no-break spaces (i.e \\'\\\\u00A0\\'). Follows the same format\\n# for how unicode is displayed on the unicode.org website:\\n# http://unicode.org/cldr/utility/character.jsp?a=0300\\nfunction fix_combining_chars(char)\\n    cat = Base.Unicode.category_code(char)\\n    return cat == 6 || cat == 8 ? \\\"$NBSP$char$NBSP\\\" : \\\"$char\\\"\\nend\\n\\n\\nfunction table_entries(completions, unicode_dict)\\n    entries = [[\\n        \\\"Code point(s)\\\", \\\"Character(s)\\\",\\n        \\\"Tab completion sequence(s)\\\", \\\"Unicode name(s)\\\"\\n    ]]\\n    for (chars, inputs) in sort!(collect(completions), by = first)\\n        code_points, unicode_names, characters = String[], String[], String[]\\n        for char in chars\\n            push!(code_points, \\\"U+$(uppercase(string(UInt32(char), base = 16, pad = 5)))\\\")\\n            push!(unicode_names, get(unicode_dict, UInt32(char), \\\"(No Unicode name)\\\"))\\n            push!(characters, isempty(characters) ? fix_combining_chars(char) : \\\"$char\\\")\\n        end\\n        push!(entries, [\\n            join(code_points, \\\" + \\\"), join(characters),\\n            join(inputs, \\\", \\\"), join(unicode_names, \\\" + \\\")\\n        ])\\n    end\\n    return Markdown.Table(entries, [:l, :l, :l, :l])\\nend\\n\\ntable_entries(\\n    tab_completions(\\n        REPL.REPLCompletions.latex_symbols,\\n        REPL.REPLCompletions.emoji_symbols\\n    ),\\n    unicode_data()\\n)\"\n},\n\n{\n    \"location\": \"base/base.html#\",\n    \"page\": \"Essentials\",\n    \"title\": \"Essentials\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/base.html#Essentials-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Essentials\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/base.html#Introduction-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Introduction\",\n    \"category\": \"section\",\n    \"text\": \"Julia Base contains a range of functions and macros appropriate for performing scientific and numerical computing, but is also as broad as those of many general purpose programming languages.  Additional functionality is available from a growing collection of available packages. Functions are grouped by topic below.Some general notes:To use module functions, use import Module to import the module, and Module.fn(x) to use the functions.\\nAlternatively, using Module will import all exported Module functions into the current namespace.\\nBy convention, function names ending with an exclamation point (!) modify their arguments. Some functions have both modifying (e.g., sort!) and non-modifying (sort) versions.\"\n},\n\n{\n    \"location\": \"base/base.html#Base.exit\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.exit\",\n    \"category\": \"function\",\n    \"text\": \"exit(code=0)\\n\\nStop the program with an exit code. The default exit code is zero, indicating that the program completed successfully. In an interactive session, exit() can be called with the keyboard shortcut ^D.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.atexit\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.atexit\",\n    \"category\": \"function\",\n    \"text\": \"atexit(f)\\n\\nRegister a zero-argument function f() to be called at process exit. atexit() hooks are called in last in first out (LIFO) order and run before object finalizers.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.isinteractive\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.isinteractive\",\n    \"category\": \"function\",\n    \"text\": \"isinteractive() -> Bool\\n\\nDetermine whether Julia is running an interactive session.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.summarysize\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.summarysize\",\n    \"category\": \"function\",\n    \"text\": \"Base.summarysize(obj; exclude=Union{...}, chargeall=Union{...}) -> Int\\n\\nCompute the amount of memory used by all unique objects reachable from the argument.\\n\\nKeyword Arguments\\n\\nexclude: specifies the types of objects to exclude from the traversal.\\nchargeall: specifies the types of objects to always charge the size of all of their fields, even if those fields would normally be excluded.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.require\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.require\",\n    \"category\": \"function\",\n    \"text\": \"require(module::Symbol)\\n\\nThis function is part of the implementation of using / import, if a module is not already defined in Main. It can also be called directly to force reloading a module, regardless of whether it has been loaded before (for example, when interactively developing libraries).\\n\\nLoads a source file, in the context of the Main module, on every active node, searching standard locations for files. require is considered a top-level operation, so it sets the current include path but does not use it to search for files (see help for include). This function is typically used to load library code, and is implicitly called by using to load packages.\\n\\nWhen searching for files, require first looks for package code in the global array LOAD_PATH. require is case-sensitive on all platforms, including those with case-insensitive filesystems like macOS and Windows.\\n\\nFor more details regarding code loading, see the manual.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.compilecache\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.compilecache\",\n    \"category\": \"function\",\n    \"text\": \"Base.compilecache(module::PkgId)\\n\\nCreates a precompiled cache file for a module and all of its dependencies. This can be used to reduce package load times. Cache files are stored in DEPOT_PATH[1]/compiled. See Module initialization and precompilation for important notes.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.__precompile__\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.__precompile__\",\n    \"category\": \"function\",\n    \"text\": \"__precompile__(isprecompilable::Bool)\\n\\nSpecify whether the file calling this function is precompilable, defaulting to true. If a module or file is not safely precompilable, it should call __precompile__(false) in order to throw an error if Julia attempts to precompile it.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.include\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.include\",\n    \"category\": \"function\",\n    \"text\": \"Base.include([m::Module,] path::AbstractString)\\n\\nEvaluate the contents of the input source file in the global scope of module m. Every module (except those defined with baremodule) has its own 1-argument definition of include, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to include will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.MainInclude.include\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.MainInclude.include\",\n    \"category\": \"function\",\n    \"text\": \"include(path::AbstractString)\\n\\nEvaluate the contents of the input source file in the global scope of the containing module. Every module (except those defined with baremodule) has its own 1-argument definition of include, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to include will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.\\n\\nUse Base.include to evaluate a file into another module.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.include_string\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.include_string\",\n    \"category\": \"function\",\n    \"text\": \"include_string(m::Module, code::AbstractString, filename::AbstractString=\\\"string\\\")\\n\\nLike include, except reads code from the given string rather than from a file.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.include_dependency\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.include_dependency\",\n    \"category\": \"function\",\n    \"text\": \"include_dependency(path::AbstractString)\\n\\nIn a module, declare that the file specified by path (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.\\n\\nThis is only needed if your module depends on a file that is not used via include. It has no effect outside of compilation.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.which-Tuple{Any,Any}\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.which\",\n    \"category\": \"method\",\n    \"text\": \"which(f, types)\\n\\nReturns the method of f (a Method object) that would be called for arguments of the given types.\\n\\nIf types is an abstract type, then the method that would be called by invoke is returned.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.methods\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.methods\",\n    \"category\": \"function\",\n    \"text\": \"methods(f, [types])\\n\\nReturns the method table for f.\\n\\nIf types is specified, returns an array of methods whose types match.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@show\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@show\",\n    \"category\": \"macro\",\n    \"text\": \"@show\\n\\nShow an expression and result, returning the result.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#ans\",\n    \"page\": \"Essentials\",\n    \"title\": \"ans\",\n    \"category\": \"keyword\",\n    \"text\": \"ans\\n\\nA variable referring to the last computed value, automatically set at the interactive prompt.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Getting-Around-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Getting Around\",\n    \"category\": \"section\",\n    \"text\": \"Base.exit\\nBase.atexit\\nBase.isinteractive\\nBase.summarysize\\nBase.require\\nBase.compilecache\\nBase.__precompile__\\nBase.include\\nBase.MainInclude.include\\nBase.include_string\\nBase.include_dependency\\nBase.which(::Any, ::Any)\\nBase.methods\\nBase.@show\\nans\"\n},\n\n{\n    \"location\": \"base/base.html#module\",\n    \"page\": \"Essentials\",\n    \"title\": \"module\",\n    \"category\": \"keyword\",\n    \"text\": \"module\\n\\nmodule declares a Module, which is a separate global variable workspace. Within a module, you can control which names from other modules are visible (via importing), and specify which of your names are intended to be public (via exporting). Modules allow you to create top-level definitions without worrying about name conflicts when your code is used together with somebody else\u2019s. See the manual section about modules for more details.\\n\\nExamples\\n\\nmodule Foo\\nimport Base.show\\nexport MyType, foo\\n\\nstruct MyType\\n    x\\nend\\n\\nbar(x) = 2x\\nfoo(a::MyType) = bar(a.x) + 1\\nshow(io::IO, a::MyType) = print(io, \\\"MyType $(a.x)\\\")\\nend\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#export\",\n    \"page\": \"Essentials\",\n    \"title\": \"export\",\n    \"category\": \"keyword\",\n    \"text\": \"export\\n\\nexport is used within modules to tell Julia which functions should be made available to the user. For example: export foo makes the name foo available when using the module. See the manual section about modules for details.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#import\",\n    \"page\": \"Essentials\",\n    \"title\": \"import\",\n    \"category\": \"keyword\",\n    \"text\": \"import\\n\\nimport Foo will load the module or package Foo. Names from the imported Foo module can be accessed with dot syntax (e.g. Foo.foo to access the name foo). See the manual section about modules for details.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#using\",\n    \"page\": \"Essentials\",\n    \"title\": \"using\",\n    \"category\": \"keyword\",\n    \"text\": \"using\\n\\nusing Foo will load the module or package Foo and make its exported names available for direct use. Names can also be used via dot syntax (e.g. Foo.foo to access the name foo), whether they are exported or not. See the manual section about modules for details.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#baremodule\",\n    \"page\": \"Essentials\",\n    \"title\": \"baremodule\",\n    \"category\": \"keyword\",\n    \"text\": \"baremodule\\n\\nbaremodule declares a module that does not contain using Base or a definition of eval. It does still import Core.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#function\",\n    \"page\": \"Essentials\",\n    \"title\": \"function\",\n    \"category\": \"keyword\",\n    \"text\": \"function\\n\\nFunctions are defined with the function keyword:\\n\\nfunction add(a, b)\\n    return a + b\\nend\\n\\nOr the short form notation:\\n\\nadd(a, b) = a + b\\n\\nThe use of the return keyword is exactly the same as in other languages, but is often optional. A function without an explicit return statement will return the last expression in the function body.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#macro\",\n    \"page\": \"Essentials\",\n    \"title\": \"macro\",\n    \"category\": \"keyword\",\n    \"text\": \"macro\\n\\nmacro defines a method to include generated code in the final body of a program. A macro maps a tuple of arguments to a returned expression, and the resulting expression is compiled directly rather than requiring a runtime eval call. Macro arguments may include expressions, literal values, and symbols. For example:\\n\\nExamples\\n\\njulia> macro sayhello(name)\\n           return :( println(\\\"Hello, \\\", $name, \\\"!\\\") )\\n       end\\n@sayhello (macro with 1 method)\\n\\njulia> @sayhello \\\"Charlie\\\"\\nHello, Charlie!\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#return\",\n    \"page\": \"Essentials\",\n    \"title\": \"return\",\n    \"category\": \"keyword\",\n    \"text\": \"return\\n\\nreturn can be used in function bodies to exit early and return a given value, e.g.\\n\\nfunction compare(a, b)\\n    a == b && return \\\"equal to\\\"\\n    a < b ? \\\"less than\\\" : \\\"greater than\\\"\\nend\\n\\nIn general you can place a return statement anywhere within a function body, including within deeply nested loops or conditionals, but be careful with do blocks. For example:\\n\\nfunction test1(xs)\\n    for x in xs\\n        iseven(x) && return 2x\\n    end\\nend\\n\\nfunction test2(xs)\\n    map(xs) do x\\n        iseven(x) && return 2x\\n        x\\n    end\\nend\\n\\nIn the first example, the return breaks out of its enclosing function as soon as it hits an even number, so test1([5,6,7]) returns 12.\\n\\nYou might expect the second example to behave the same way, but in fact the return there only breaks out of the inner function (inside the do block) and gives a value back to map. test2([5,6,7]) then returns [5,12,7].\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#do\",\n    \"page\": \"Essentials\",\n    \"title\": \"do\",\n    \"category\": \"keyword\",\n    \"text\": \"do\\n\\nCreate an anonymous function. For example:\\n\\nmap(1:10) do x\\n    2x\\nend\\n\\nis equivalent to map(x->2x, 1:10).\\n\\nUse multiple arguments like so:\\n\\nmap(1:10, 11:20) do x, y\\n    x + y\\nend\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#begin\",\n    \"page\": \"Essentials\",\n    \"title\": \"begin\",\n    \"category\": \"keyword\",\n    \"text\": \"begin\\n\\nbegin...end denotes a block of code.\\n\\nbegin\\n    println(\\\"Hello, \\\")\\n    println(\\\"World!\\\")\\nend\\n\\nUsually begin will not be necessary, since keywords such as function and let implicitly begin blocks of code. See also ;.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#end\",\n    \"page\": \"Essentials\",\n    \"title\": \"end\",\n    \"category\": \"keyword\",\n    \"text\": \"end\\n\\nend marks the conclusion of a block of expressions, for example module, struct, mutable struct, begin, let, for etc. end may also be used when indexing into an array to represent the last index of a dimension.\\n\\nExamples\\n\\njulia> A = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> A[end, :]\\n2-element Array{Int64,1}:\\n 3\\n 4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#let\",\n    \"page\": \"Essentials\",\n    \"title\": \"let\",\n    \"category\": \"keyword\",\n    \"text\": \"let\\n\\nlet statements allocate new variable bindings each time they run. Whereas an assignment modifies an existing value location, let creates new locations. This difference is only detectable in the case of variables that outlive their scope via closures. The let syntax accepts a comma-separated series of assignments and variable names:\\n\\nlet var1 = value1, var2, var3 = value3\\n    code\\nend\\n\\nThe assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like let x = x, since the two x variables are distinct and have separate storage.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#if\",\n    \"page\": \"Essentials\",\n    \"title\": \"if\",\n    \"category\": \"keyword\",\n    \"text\": \"if/elseif/else\\n\\nif/elseif/else performs conditional evaluation, which allows portions of code to be evaluated or not evaluated depending on the value of a boolean expression. Here is the anatomy of the if/elseif/else conditional syntax:\\n\\nif x < y\\n    println(\\\"x is less than y\\\")\\nelseif x > y\\n    println(\\\"x is greater than y\\\")\\nelse\\n    println(\\\"x is equal to y\\\")\\nend\\n\\nIf the condition expression x < y is true, then the corresponding block is evaluated; otherwise the condition expression x > y is evaluated, and if it is true, the corresponding block is evaluated; if neither expression is true, the else block is evaluated. The elseif and else blocks are optional, and as many elseif blocks as desired can be used.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#for\",\n    \"page\": \"Essentials\",\n    \"title\": \"for\",\n    \"category\": \"keyword\",\n    \"text\": \"for\\n\\nfor loops repeatedly evaluate the body of the loop by iterating over a sequence of values.\\n\\nExamples\\n\\njulia> for i in [1, 4, 0]\\n           println(i)\\n       end\\n1\\n4\\n0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#while\",\n    \"page\": \"Essentials\",\n    \"title\": \"while\",\n    \"category\": \"keyword\",\n    \"text\": \"while\\n\\nwhile loops repeatedly evaluate a conditional expression, and continues evaluating the body of the while loop so long as the expression remains true. If the condition expression is false when the while loop is first reached, the body is never evaluated.\\n\\nExamples\\n\\njulia> i = 1\\n1\\n\\njulia> while i < 5\\n           println(i)\\n           global i += 1\\n       end\\n1\\n2\\n3\\n4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#break\",\n    \"page\": \"Essentials\",\n    \"title\": \"break\",\n    \"category\": \"keyword\",\n    \"text\": \"break\\n\\nBreak out of a loop immediately.\\n\\nExamples\\n\\njulia> i = 0\\n0\\n\\njulia> while true\\n           global i += 1\\n           i > 5 && break\\n           println(i)\\n       end\\n1\\n2\\n3\\n4\\n5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#continue\",\n    \"page\": \"Essentials\",\n    \"title\": \"continue\",\n    \"category\": \"keyword\",\n    \"text\": \"continue\\n\\nSkip the rest of the current loop iteration.\\n\\nExamples\\n\\njulia> for i = 1:6\\n           iseven(i) && continue\\n           println(i)\\n       end\\n1\\n3\\n5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#try\",\n    \"page\": \"Essentials\",\n    \"title\": \"try\",\n    \"category\": \"keyword\",\n    \"text\": \"try/catch\\n\\nA try/catch statement allows for Exceptions to be tested for. For example, a customized square root function can be written to automatically call either the real or complex square root method on demand using Exceptions:\\n\\nf(x) = try\\n    sqrt(x)\\ncatch\\n    sqrt(complex(x, 0))\\nend\\n\\ntry/catch statements also allow the Exception to be saved in a variable, e.g. catch y.\\n\\nThe power of the try/catch construct lies in the ability to unwind a deeply nested computation immediately to a much higher level in the stack of calling functions.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#finally\",\n    \"page\": \"Essentials\",\n    \"title\": \"finally\",\n    \"category\": \"keyword\",\n    \"text\": \"finally\\n\\nRun some code when a given block of code exits, regardless of how it exits. For example, here is how we can guarantee that an opened file is closed:\\n\\nf = open(\\\"file\\\")\\ntry\\n    operate_on_file(f)\\nfinally\\n    close(f)\\nend\\n\\nWhen control leaves the try block (for example, due to a return, or just finishing normally), close(f) will be executed. If the try block exits due to an exception, the exception will continue propagating. A catch block may be combined with try and finally as well. In this case the finally block will run after catch has handled the error.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#quote\",\n    \"page\": \"Essentials\",\n    \"title\": \"quote\",\n    \"category\": \"keyword\",\n    \"text\": \"quote\\n\\nquote creates multiple expression objects in a block without using the explicit Expr constructor. For example:\\n\\nex = quote\\n    x = 1\\n    y = 2\\n    x + y\\nend\\n\\nUnlike the other means of quoting, :( ... ), this form introduces QuoteNode elements to the expression tree, which must be considered when directly manipulating the tree. For other purposes, :( ... ) and quote .. end blocks are treated identically.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#local\",\n    \"page\": \"Essentials\",\n    \"title\": \"local\",\n    \"category\": \"keyword\",\n    \"text\": \"local\\n\\nlocal introduces a new local variable. See the manual section on variable scoping for more information.\\n\\nExamples\\n\\njulia> function foo(n)\\n           x = 0\\n           for i = 1:n\\n               local x # introduce a loop-local x\\n               x = i\\n           end\\n           x\\n       end\\nfoo (generic function with 1 method)\\n\\njulia> foo(10)\\n0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#global\",\n    \"page\": \"Essentials\",\n    \"title\": \"global\",\n    \"category\": \"keyword\",\n    \"text\": \"global\\n\\nglobal x makes x in the current scope and its inner scopes refer to the global variable of that name. See the manual section on variable scoping for more information.\\n\\nExamples\\n\\njulia> z = 3\\n3\\n\\njulia> function foo()\\n           global z = 6 # use the z variable defined outside foo\\n       end\\nfoo (generic function with 1 method)\\n\\njulia> foo()\\n6\\n\\njulia> z\\n6\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#const\",\n    \"page\": \"Essentials\",\n    \"title\": \"const\",\n    \"category\": \"keyword\",\n    \"text\": \"const\\n\\nconst is used to declare global variables which are also constant. In almost all code (and particularly performance sensitive code) global variables should be declared constant in this way.\\n\\nconst x = 5\\n\\nMultiple variables can be declared within a single const:\\n\\nconst y, z = 7, 11\\n\\nNote that const only applies to one = operation, therefore const x = y = 1 declares x to be constant but not y. On the other hand, const x = const y = 1 declares both x and y as constants.\\n\\nNote that \\\"constant-ness\\\" is not enforced inside containers, so if x is an array or dictionary (for example) you can still add and remove elements.\\n\\nTechnically, you can even redefine const variables, although this will generate a warning from the compiler. The only strict requirement is that the type of the variable does not change, which is why const variables are much faster than regular globals.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#struct\",\n    \"page\": \"Essentials\",\n    \"title\": \"struct\",\n    \"category\": \"keyword\",\n    \"text\": \"struct\\n\\nThe most commonly used kind of type in Julia is a struct, specified as a name and a set of fields.\\n\\nstruct Point\\n    x\\n    y\\nend\\n\\nFields can have type restrictions, which may be parameterized:\\n\\n    struct Point{X}\\n        x::X\\n        y::Float64\\n    end\\n\\nA struct can also declare an abstract super type via <: syntax:\\n\\nstruct Point <: AbstractPoint\\n    x\\n    y\\nend\\n\\nstructs are immutable by default; an instance of one of these types cannot be modified after construction. Use mutable struct instead to declare a type whose instances can be modified.\\n\\nSee the manual section on Composite Types for more details, such as how to define constructors.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#mutable struct\",\n    \"page\": \"Essentials\",\n    \"title\": \"mutable struct\",\n    \"category\": \"keyword\",\n    \"text\": \"mutable struct\\n\\nmutable struct is similar to struct, but additionally allows the fields of the type to be set after construction. See the manual section on Composite Types for more information.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#abstract type\",\n    \"page\": \"Essentials\",\n    \"title\": \"abstract type\",\n    \"category\": \"keyword\",\n    \"text\": \"abstract type\\n\\nabstract type declares a type that cannot be instantiated, and serves only as a node in the type graph, thereby describing sets of related concrete types: those concrete types which are their descendants. Abstract types form the conceptual hierarchy which makes Julia\u2019s type system more than just a collection of object implementations. For example:\\n\\nabstract type Number end\\nabstract type Real <: Number end\\n\\nNumber has no supertype, whereas Real is an abstract subtype of Number.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#primitive type\",\n    \"page\": \"Essentials\",\n    \"title\": \"primitive type\",\n    \"category\": \"keyword\",\n    \"text\": \"primitive type\\n\\nprimitive type declares a concrete type whose data consists only of a series of bits. Classic examples of primitive types are integers and floating-point values. Some example built-in primitive type declarations:\\n\\nprimitive type Char 32 end\\nprimitive type Bool <: Integer 8 end\\n\\nThe number after the name indicates how many bits of storage the type requires. Currently, only sizes that are multiples of 8 bits are supported. The Bool declaration shows how a primitive type can be optionally declared to be a subtype of some supertype.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#...\",\n    \"page\": \"Essentials\",\n    \"title\": \"...\",\n    \"category\": \"keyword\",\n    \"text\": \"...\\n\\nThe \\\"splat\\\" operator, ..., represents a sequence of arguments. ... can be used in function definitions, to indicate that the function accepts an arbitrary number of arguments. ... can also be used to apply a function to a sequence of arguments.\\n\\nExamples\\n\\njulia> add(xs...) = reduce(+, xs)\\nadd (generic function with 1 method)\\n\\njulia> add(1, 2, 3, 4, 5)\\n15\\n\\njulia> add([1, 2, 3]...)\\n6\\n\\njulia> add(7, 1:100..., 1000:1100...)\\n111107\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#;\",\n    \"page\": \"Essentials\",\n    \"title\": \";\",\n    \"category\": \"keyword\",\n    \"text\": \";\\n\\n; has a similar role in Julia as in many C-like languages, and is used to delimit the end of the previous statement. ; is not necessary after new lines, but can be used to separate statements on a single line or to join statements into a single expression. ; is also used to suppress output printing in the REPL and similar interfaces.\\n\\nExamples\\n\\njulia> function foo()\\n           x = \\\"Hello, \\\"; x *= \\\"World!\\\"\\n           return x\\n       end\\nfoo (generic function with 1 method)\\n\\njulia> bar() = (x = \\\"Hello, Mars!\\\"; return x)\\nbar (generic function with 1 method)\\n\\njulia> foo();\\n\\njulia> bar()\\n\\\"Hello, Mars!\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Keywords-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Keywords\",\n    \"category\": \"section\",\n    \"text\": \"module\\nexport\\nimport\\nusing\\nbaremodule\\nfunction\\nmacro\\nreturn\\ndo\\nbegin\\nend\\nlet\\nif\\nfor\\nwhile\\nbreak\\ncontinue\\ntry\\nfinally\\nquote\\nlocal\\nglobal\\nconst\\nstruct\\nmutable struct\\nabstract type\\nprimitive type\\n...\\n;\"\n},\n\n{\n    \"location\": \"base/base.html#Base\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base\",\n    \"category\": \"keyword\",\n    \"text\": \"The base library of Julia.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Broadcast\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Broadcast\",\n    \"category\": \"module\",\n    \"text\": \"Base.Broadcast\\n\\nModule containing the broadcasting implementation.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Docs\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Docs\",\n    \"category\": \"module\",\n    \"text\": \"Docs\\n\\nThe Docs module provides the @doc macro which can be used to set and retrieve documentation metadata for Julia objects.\\n\\nPlease see the manual section on documentation for more information.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Iterators\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Iterators\",\n    \"category\": \"module\",\n    \"text\": \"Methods for working with Iterators.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Libc\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Libc\",\n    \"category\": \"module\",\n    \"text\": \"Interface to libc, the C standard library.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Meta\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Meta\",\n    \"category\": \"module\",\n    \"text\": \"Convenience functions for metaprogramming.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.StackTraces\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.StackTraces\",\n    \"category\": \"module\",\n    \"text\": \"Tools for collecting and manipulating stack traces. Mainly used for building errors.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Sys\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Sys\",\n    \"category\": \"module\",\n    \"text\": \"Provide methods for retrieving information about hardware and the operating system.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Threads\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Threads\",\n    \"category\": \"module\",\n    \"text\": \"Experimental multithreading support.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.GC\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.GC\",\n    \"category\": \"module\",\n    \"text\": \"Base.GC\\n\\nModule with garbage collection utilities.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base-Modules-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base Modules\",\n    \"category\": \"section\",\n    \"text\": \"Base.Base\\nBase.Broadcast\\nBase.Docs\\nBase.Iterators\\nBase.Libc\\nBase.Meta\\nBase.StackTraces\\nBase.Sys\\nBase.Threads\\nBase.GC\"\n},\n\n{\n    \"location\": \"base/base.html#Core.:===\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.:===\",\n    \"category\": \"function\",\n    \"text\": \"===(x,y) -> Bool\\n\u2261(x,y) -> Bool\\n\\nDetermine whether x and y are identical, in the sense that no program could distinguish them. First the types of x and y are compared. If those are identical, mutable objects are compared by address in memory and immutable objects (such as numbers) are compared by contents at the bit level. This function is sometimes called \\\"egal\\\". It always returns a Bool value.\\n\\nExamples\\n\\njulia> a = [1, 2]; b = [1, 2];\\n\\njulia> a == b\\ntrue\\n\\njulia> a === b\\nfalse\\n\\njulia> a === a\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.isa\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.isa\",\n    \"category\": \"function\",\n    \"text\": \"isa(x, type) -> Bool\\n\\nDetermine whether x is of the given type. Can also be used as an infix operator, e.g. x isa type.\\n\\nExamples\\n\\njulia> isa(1, Int)\\ntrue\\n\\njulia> isa(1, Matrix)\\nfalse\\n\\njulia> isa(1, Char)\\nfalse\\n\\njulia> isa(1, Number)\\ntrue\\n\\njulia> 1 isa Number\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.isequal\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.isequal\",\n    \"category\": \"function\",\n    \"text\": \"isequal(x, y)\\n\\nSimilar to ==, except for the treatment of floating point numbers and of missing values. isequal treats all floating-point NaN values as equal to each other, treats -0.0 as unequal to 0.0, and missing as equal to missing. Always returns a Bool value.\\n\\nImplementation\\n\\nThe default implementation of isequal calls ==, so a type that does not involve floating-point values generally only needs to define ==.\\n\\nisequal is the comparison function used by hash tables (Dict). isequal(x,y) must imply that hash(x) == hash(y).\\n\\nThis typically means that types for which a custom == or isequal method exists must implement a corresponding hash method (and vice versa). Collections typically implement isequal by calling isequal recursively on all contents.\\n\\nScalar types generally do not need to implement isequal separate from ==, unless they represent floating-point numbers amenable to a more efficient implementation than that provided as a generic fallback (based on isnan, signbit, and ==).\\n\\nExamples\\n\\njulia> isequal([1., NaN], [1., NaN])\\ntrue\\n\\njulia> [1., NaN] == [1., NaN]\\nfalse\\n\\njulia> 0.0 == -0.0\\ntrue\\n\\njulia> isequal(0.0, -0.0)\\nfalse\\n\\n\\n\\n\\n\\nisequal(x)\\n\\nCreate a function that compares its argument to x using isequal, i.e. a function equivalent to y -> isequal(y, x).\\n\\nThe returned function is of type Base.Fix2{typeof(isequal)}, which can be used to implement specialized methods.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.isless\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.isless\",\n    \"category\": \"function\",\n    \"text\": \"isless(x, y)\\n\\nTest whether x is less than y, according to a canonical total order. Values that are normally unordered, such as NaN, are ordered in an arbitrary but consistent fashion. missing values are ordered last.\\n\\nThis is the default comparison used by sort.\\n\\nImplementation\\n\\nNon-numeric types with a canonical total order should implement this function. Numeric types only need to implement it if they have special values such as NaN. Types with a canonical partial order should implement <.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.ifelse\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.ifelse\",\n    \"category\": \"function\",\n    \"text\": \"ifelse(condition::Bool, x, y)\\n\\nReturn x if condition is true, otherwise return y. This differs from ? or if in that it is an ordinary function, so all the arguments are evaluated first. In some cases, using ifelse instead of an if statement can eliminate the branch in generated code and provide higher performance in tight loops.\\n\\nExamples\\n\\njulia> ifelse(1 > 2, 1, 2)\\n2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.typeassert\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.typeassert\",\n    \"category\": \"function\",\n    \"text\": \"typeassert(x, type)\\n\\nThrow a TypeError unless x isa type. The syntax x::type calls this function.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.typeof\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.typeof\",\n    \"category\": \"function\",\n    \"text\": \"typeof(x)\\n\\nGet the concrete type of x.\\n\\nExamples\\n\\njulia> a = 1//2;\\n\\njulia> typeof(a)\\nRational{Int64}\\n\\njulia> M = [1 2; 3.5 4];\\n\\njulia> typeof(M)\\nArray{Float64,2}\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.tuple\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.tuple\",\n    \"category\": \"function\",\n    \"text\": \"tuple(xs...)\\n\\nConstruct a tuple of the given objects.\\n\\nExamples\\n\\njulia> tuple(1, \\'a\\', pi)\\n(1, \\'a\\', \u03c0 = 3.1415926535897...)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.ntuple\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.ntuple\",\n    \"category\": \"function\",\n    \"text\": \"ntuple(f::Function, n::Integer)\\n\\nCreate a tuple of length n, computing each element as f(i), where i is the index of the element.\\n\\nExamples\\n\\njulia> ntuple(i -> 2*i, 4)\\n(2, 4, 6, 8)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.objectid\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.objectid\",\n    \"category\": \"function\",\n    \"text\": \"objectid(x)\\n\\nGet a hash value for x based on object identity. objectid(x)==objectid(y) if x === y.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.hash\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.hash\",\n    \"category\": \"function\",\n    \"text\": \"hash(x[, h::UInt])\\n\\nCompute an integer hash code such that isequal(x,y) implies hash(x)==hash(y). The optional second argument h is a hash code to be mixed with the result.\\n\\nNew types should implement the 2-argument form, typically by calling the 2-argument hash method recursively in order to mix hashes of the contents with each other (and with h). Typically, any type that implements hash should also implement its own == (hence isequal) to guarantee the property mentioned above. Types supporting subtraction (operator -) should also implement widen, which is required to hash values inside heterogeneous arrays.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.finalizer\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.finalizer\",\n    \"category\": \"function\",\n    \"text\": \"finalizer(f, x)\\n\\nRegister a function f(x) to be called when there are no program-accessible references to x, and return x. The type of x must be a mutable struct, otherwise the behavior of this function is unpredictable.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.finalize\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.finalize\",\n    \"category\": \"function\",\n    \"text\": \"finalize(x)\\n\\nImmediately run finalizers registered for object x.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.copy\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.copy\",\n    \"category\": \"function\",\n    \"text\": \"copy(x)\\n\\nCreate a shallow copy of x: the outer structure is copied, but not all internal values. For example, copying an array produces a new array with identically-same elements as the original.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.deepcopy\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.deepcopy\",\n    \"category\": \"function\",\n    \"text\": \"deepcopy(x)\\n\\nCreate a deep copy of x: everything is copied recursively, resulting in a fully independent object. For example, deep-copying an array produces a new array whose elements are deep copies of the original elements. Calling deepcopy on an object should generally have the same effect as serializing and then deserializing it.\\n\\nAs a special case, functions can only be actually deep-copied if they are anonymous, otherwise they are just copied. The difference is only relevant in the case of closures, i.e. functions which may contain hidden internal references.\\n\\nWhile it isn\\'t normally necessary, user-defined types can override the default deepcopy behavior by defining a specialized version of the function deepcopy_internal(x::T, dict::IdDict) (which shouldn\\'t otherwise be used), where T is the type to be specialized for, and dict keeps track of objects copied so far within the recursion. Within the definition, deepcopy_internal should be used in place of deepcopy, and the dict variable should be updated as appropriate before returning.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.getproperty\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.getproperty\",\n    \"category\": \"function\",\n    \"text\": \"getproperty(value, name::Symbol)\\n\\nThe syntax a.b calls getproperty(a, :b).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.setproperty!\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.setproperty!\",\n    \"category\": \"function\",\n    \"text\": \"setproperty!(value, name::Symbol, x)\\n\\nThe syntax a.b = c calls setproperty!(a, :b, c).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.propertynames\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.propertynames\",\n    \"category\": \"function\",\n    \"text\": \"propertynames(x, private=false)\\n\\nGet a tuple or a vector of the properties (x.property) of an object x. This is typically the same as fieldnames(typeof(x)), but types that overload getproperty should generally overload propertynames as well to get the properties of an instance of the type.\\n\\npropertynames(x) may return only \\\"public\\\" property names that are part of the documented interface of x.   If you want it to also return \\\"private\\\" fieldnames intended for internal use, pass true for the optional second argument. REPL tab completion on x. shows only the private=false properties.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.getfield\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.getfield\",\n    \"category\": \"function\",\n    \"text\": \"getfield(value, name::Symbol)\\n\\nExtract a named field from a value of composite type. See also getproperty.\\n\\nExamples\\n\\njulia> a = 1//2\\n1//2\\n\\njulia> getfield(a, :num)\\n1\\n\\njulia> a.num\\n1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.setfield!\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.setfield!\",\n    \"category\": \"function\",\n    \"text\": \"setfield!(value, name::Symbol, x)\\n\\nAssign x to a named field in value of composite type. The value must be mutable and x must be a subtype of fieldtype(typeof(value), name). See also setproperty!.\\n\\nExamples\\n\\njulia> mutable struct MyMutableStruct\\n           field::Int\\n       end\\n\\njulia> a = MyMutableStruct(1);\\n\\njulia> setfield!(a, :field, 2);\\n\\njulia> getfield(a, :field)\\n2\\n\\njulia> a = 1//2\\n1//2\\n\\njulia> setfield!(a, :num, 3);\\nERROR: type Rational is immutable\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.isdefined\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.isdefined\",\n    \"category\": \"function\",\n    \"text\": \"isdefined(m::Module, s::Symbol)\\nisdefined(object, s::Symbol)\\nisdefined(object, index::Int)\\n\\nTests whether an assignable location is defined. The arguments can be a module and a symbol or a composite object and field name (as a symbol) or index.\\n\\nExamples\\n\\njulia> isdefined(Base, :sum)\\ntrue\\n\\njulia> isdefined(Base, :NonExistentMethod)\\nfalse\\n\\njulia> a = 1//2;\\n\\njulia> isdefined(a, 2)\\ntrue\\n\\njulia> isdefined(a, 3)\\nfalse\\n\\njulia> isdefined(a, :num)\\ntrue\\n\\njulia> isdefined(a, :numerator)\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@isdefined\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@isdefined\",\n    \"category\": \"macro\",\n    \"text\": \"@isdefined s -> Bool\\n\\nTests whether variable s is defined in the current scope.\\n\\nExamples\\n\\njulia> function f()\\n           println(@isdefined x)\\n           x = 3\\n           println(@isdefined x)\\n       end\\nf (generic function with 1 method)\\n\\njulia> f()\\nfalse\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.convert\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.convert\",\n    \"category\": \"function\",\n    \"text\": \"convert(T, x)\\n\\nConvert x to a value of type T.\\n\\nIf T is an Integer type, an InexactError will be raised if x is not representable by T, for example if x is not integer-valued, or is outside the range supported by T.\\n\\nExamples\\n\\njulia> convert(Int, 3.0)\\n3\\n\\njulia> convert(Int, 3.5)\\nERROR: InexactError: Int64(Int64, 3.5)\\nStacktrace:\\n[...]\\n\\nIf T is a AbstractFloat or Rational type, then it will return the closest value to x representable by T.\\n\\njulia> x = 1/3\\n0.3333333333333333\\n\\njulia> convert(Float32, x)\\n0.33333334f0\\n\\njulia> convert(Rational{Int32}, x)\\n1//3\\n\\njulia> convert(Rational{Int64}, x)\\n6004799503160661//18014398509481984\\n\\nIf T is a collection type and x a collection, the result of convert(T, x) may alias all or part of x.\\n\\njulia> x = Int[1, 2, 3];\\n\\njulia> y = convert(Vector{Int}, x);\\n\\njulia> y === x\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.promote\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.promote\",\n    \"category\": \"function\",\n    \"text\": \"promote(xs...)\\n\\nConvert all arguments to a common type, and return them all (as a tuple). If no arguments can be converted, an error is raised.\\n\\nExamples\\n\\njulia> promote(Int8(1), Float16(4.5), Float32(4.1))\\n(1.0f0, 4.5f0, 4.1f0)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.oftype\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.oftype\",\n    \"category\": \"function\",\n    \"text\": \"oftype(x, y)\\n\\nConvert y to the type of x (convert(typeof(x), y)).\\n\\nExamples\\n\\njulia> x = 4;\\n\\njulia> y = 3.;\\n\\njulia> oftype(x, y)\\n3\\n\\njulia> oftype(y, x)\\n4.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.widen\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.widen\",\n    \"category\": \"function\",\n    \"text\": \"widen(x)\\n\\nIf x is a type, return a \\\"larger\\\" type, defined so that arithmetic operations + and - are guaranteed not to overflow nor lose precision for any combination of values that type x can hold.\\n\\nFor fixed-size integer types less than 128 bits, widen will return a type with twice the number of bits.\\n\\nIf x is a value, it is converted to widen(typeof(x)).\\n\\nExamples\\n\\njulia> widen(Int32)\\nInt64\\n\\njulia> widen(1.5f0)\\n1.5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.identity\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.identity\",\n    \"category\": \"function\",\n    \"text\": \"identity(x)\\n\\nThe identity function. Returns its argument.\\n\\nExamples\\n\\njulia> identity(\\\"Well, what did you expect?\\\")\\n\\\"Well, what did you expect?\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#All-Objects-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"All Objects\",\n    \"category\": \"section\",\n    \"text\": \"Core.:(===)\\nCore.isa\\nBase.isequal\\nBase.isless\\nBase.ifelse\\nCore.typeassert\\nCore.typeof\\nCore.tuple\\nBase.ntuple\\nBase.objectid\\nBase.hash\\nBase.finalizer\\nBase.finalize\\nBase.copy\\nBase.deepcopy\\nBase.getproperty\\nBase.setproperty!\\nBase.propertynames\\nCore.getfield\\nCore.setfield!\\nCore.isdefined\\nBase.@isdefined\\nBase.convert\\nBase.promote\\nBase.oftype\\nBase.widen\\nBase.identity\"\n},\n\n{\n    \"location\": \"base/base.html#Properties-of-Types-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Properties of Types\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/base.html#Base.supertype\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.supertype\",\n    \"category\": \"function\",\n    \"text\": \"supertype(T::DataType)\\n\\nReturn the supertype of DataType T.\\n\\nExamples\\n\\njulia> supertype(Int32)\\nSigned\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.:<:\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.:<:\",\n    \"category\": \"function\",\n    \"text\": \"<:(T1, T2)\\n\\nSubtype operator: returns true if and only if all values of type T1 are also of type T2.\\n\\nExamples\\n\\njulia> Float64 <: AbstractFloat\\ntrue\\n\\njulia> Vector{Int} <: AbstractArray\\ntrue\\n\\njulia> Matrix{Float64} <: Matrix{AbstractFloat}\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.:>:\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.:>:\",\n    \"category\": \"function\",\n    \"text\": \">:(T1, T2)\\n\\nSupertype operator, equivalent to T2 <: T1.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.typejoin\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.typejoin\",\n    \"category\": \"function\",\n    \"text\": \"typejoin(T, S)\\n\\nReturn the closest common ancestor of T and S, i.e. the narrowest type from which they both inherit.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.typeintersect\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.typeintersect\",\n    \"category\": \"function\",\n    \"text\": \"typeintersect(T, S)\\n\\nCompute a type that contains the intersection of T and S. Usually this will be the smallest such type or one close to it.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.promote_type\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.promote_type\",\n    \"category\": \"function\",\n    \"text\": \"promote_type(type1, type2)\\n\\nPromotion refers to converting values of mixed types to a single common type. promote_type represents the default promotion behavior in Julia when operators (usually mathematical) are given arguments of differing types. promote_type generally tries to return a type which can at least approximate most values of either input type without excessively widening.  Some loss is tolerated; for example, promote_type(Int64, Float64) returns Float64 even though strictly, not all Int64 values can be represented exactly as Float64 values.\\n\\njulia> promote_type(Int64, Float64)\\nFloat64\\n\\njulia> promote_type(Int32, Int64)\\nInt64\\n\\njulia> promote_type(Float32, BigInt)\\nBigFloat\\n\\njulia> promote_type(Int16, Float16)\\nFloat16\\n\\njulia> promote_type(Int64, Float16)\\nFloat16\\n\\njulia> promote_type(Int8, UInt16)\\nUInt16\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.promote_rule\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.promote_rule\",\n    \"category\": \"function\",\n    \"text\": \"promote_rule(type1, type2)\\n\\nSpecifies what type should be used by promote when given values of types type1 and type2. This function should not be called directly, but should have definitions added to it for new types as appropriate.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.isdispatchtuple\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.isdispatchtuple\",\n    \"category\": \"function\",\n    \"text\": \"isdispatchtuple(T)\\n\\nDetermine whether type T is a tuple \\\"leaf type\\\", meaning it could appear as a type signature in dispatch and has no subtypes (or supertypes) which could appear in a call.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Type-relations-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Type relations\",\n    \"category\": \"section\",\n    \"text\": \"Base.supertype\\nCore.:(<:)\\nBase.:(>:)\\nBase.typejoin\\nBase.typeintersect\\nBase.promote_type\\nBase.promote_rule\\nBase.isdispatchtuple\"\n},\n\n{\n    \"location\": \"base/base.html#Base.isimmutable\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.isimmutable\",\n    \"category\": \"function\",\n    \"text\": \"isimmutable(v) -> Bool\\n\\nReturn true iff value v is immutable.  See Mutable Composite Types for a discussion of immutability. Note that this function works on values, so if you give it a type, it will tell you that a value of DataType is mutable.\\n\\nExamples\\n\\njulia> isimmutable(1)\\ntrue\\n\\njulia> isimmutable([1,2])\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.isabstracttype\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.isabstracttype\",\n    \"category\": \"function\",\n    \"text\": \"Base.isabstracttype(T)\\n\\nDetermine whether type T was declared as an abstract type (i.e. using the abstract keyword).\\n\\nExamples\\n\\njulia> Base.isabstracttype(AbstractArray)\\ntrue\\n\\njulia> Base.isabstracttype(Vector)\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.isprimitivetype\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.isprimitivetype\",\n    \"category\": \"function\",\n    \"text\": \"Base.isprimitivetype(T) -> Bool\\n\\nDetermine whether type T was declared as a primitive type (i.e. using the primitive keyword).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.isstructtype\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.isstructtype\",\n    \"category\": \"function\",\n    \"text\": \"Base.isstructtype(T) -> Bool\\n\\nDetermine whether type T was declared as a struct type (i.e. using the struct or mutable struct keyword).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.nameof-Tuple{DataType}\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.nameof\",\n    \"category\": \"method\",\n    \"text\": \"nameof(t::DataType) -> Symbol\\n\\nGet the name of a (potentially UnionAll-wrapped) DataType (without its parent module) as a symbol.\\n\\nExamples\\n\\njulia> module Foo\\n           struct S{T}\\n           end\\n       end\\nFoo\\n\\njulia> nameof(Foo.S{T} where T)\\n:S\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.fieldnames\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.fieldnames\",\n    \"category\": \"function\",\n    \"text\": \"fieldnames(x::DataType)\\n\\nGet a tuple with the names of the fields of a DataType.\\n\\nExamples\\n\\njulia> fieldnames(Rational)\\n(:num, :den)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.fieldname\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.fieldname\",\n    \"category\": \"function\",\n    \"text\": \"fieldname(x::DataType, i::Integer)\\n\\nGet the name of field i of a DataType.\\n\\nExamples\\n\\njulia> fieldname(Rational, 1)\\n:num\\n\\njulia> fieldname(Rational, 2)\\n:den\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Declared-structure-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Declared structure\",\n    \"category\": \"section\",\n    \"text\": \"Base.isimmutable\\nBase.isabstracttype\\nBase.isprimitivetype\\nBase.isstructtype\\nBase.nameof(::DataType)\\nBase.fieldnames\\nBase.fieldname\"\n},\n\n{\n    \"location\": \"base/base.html#Base.sizeof-Tuple{Type}\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.sizeof\",\n    \"category\": \"method\",\n    \"text\": \"sizeof(T::DataType)\\nsizeof(obj)\\n\\nSize, in bytes, of the canonical binary representation of the given DataType T, if any. Size, in bytes, of object obj if it is not DataType.\\n\\nExamples\\n\\njulia> sizeof(Float32)\\n4\\n\\njulia> sizeof(ComplexF64)\\n16\\n\\njulia> sizeof(1.0)\\n8\\n\\njulia> sizeof([1.0:10.0;])\\n80\\n\\nIf DataType T does not have a specific size, an error is thrown.\\n\\njulia> sizeof(AbstractArray)\\nERROR: argument is an abstract type; size is indeterminate\\nStacktrace:\\n[...]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.isconcretetype\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.isconcretetype\",\n    \"category\": \"function\",\n    \"text\": \"isconcretetype(T)\\n\\nDetermine whether type T is a concrete type, meaning it could have direct instances (values x such that typeof(x) === T).\\n\\nExamples\\n\\njulia> isconcretetype(Complex)\\nfalse\\n\\njulia> isconcretetype(Complex{Float32})\\ntrue\\n\\njulia> isconcretetype(Vector{Complex})\\ntrue\\n\\njulia> isconcretetype(Vector{Complex{Float32}})\\ntrue\\n\\njulia> isconcretetype(Union{})\\nfalse\\n\\njulia> isconcretetype(Union{Int,String})\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.isbits\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.isbits\",\n    \"category\": \"function\",\n    \"text\": \"isbits(x)\\n\\nReturn true if x is an instance of an isbitstype type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.isbitstype\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.isbitstype\",\n    \"category\": \"function\",\n    \"text\": \"isbitstype(T)\\n\\nReturn true if type T is a \\\"plain data\\\" type, meaning it is immutable and contains no references to other values, only primitive types and other isbitstype types. Typical examples are numeric types such as UInt8, Float64, and Complex{Float64}. This category of types is significant since they are valid as type parameters, may not track isdefined / isassigned status, and have a defined layout that is compatible with C.\\n\\nExamples\\n\\njulia> isbitstype(Complex{Float64})\\ntrue\\n\\njulia> isbitstype(Complex)\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.fieldtype\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.fieldtype\",\n    \"category\": \"function\",\n    \"text\": \"fieldtype(T, name::Symbol | index::Int)\\n\\nDetermine the declared type of a field (specified by name or index) in a composite DataType T.\\n\\nExamples\\n\\njulia> struct Foo\\n           x::Int64\\n           y::String\\n       end\\n\\njulia> fieldtype(Foo, :x)\\nInt64\\n\\njulia> fieldtype(Foo, 2)\\nString\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.fieldcount\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.fieldcount\",\n    \"category\": \"function\",\n    \"text\": \"fieldcount(t::Type)\\n\\nGet the number of fields that an instance of the given type would have. An error is thrown if the type is too abstract to determine this.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.fieldoffset\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.fieldoffset\",\n    \"category\": \"function\",\n    \"text\": \"fieldoffset(type, i)\\n\\nThe byte offset of field i of a type relative to the data start. For example, we could use it in the following manner to summarize information about a struct:\\n\\njulia> structinfo(T) = [(fieldoffset(T,i), fieldname(T,i), fieldtype(T,i)) for i = 1:fieldcount(T)];\\n\\njulia> structinfo(Base.Filesystem.StatStruct)\\n12-element Array{Tuple{UInt64,Symbol,DataType},1}:\\n (0x0000000000000000, :device, UInt64)\\n (0x0000000000000008, :inode, UInt64)\\n (0x0000000000000010, :mode, UInt64)\\n (0x0000000000000018, :nlink, Int64)\\n (0x0000000000000020, :uid, UInt64)\\n (0x0000000000000028, :gid, UInt64)\\n (0x0000000000000030, :rdev, UInt64)\\n (0x0000000000000038, :size, Int64)\\n (0x0000000000000040, :blksize, Int64)\\n (0x0000000000000048, :blocks, Int64)\\n (0x0000000000000050, :mtime, Float64)\\n (0x0000000000000058, :ctime, Float64)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.datatype_alignment\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.datatype_alignment\",\n    \"category\": \"function\",\n    \"text\": \"Base.datatype_alignment(dt::DataType) -> Int\\n\\nMemory allocation minimum alignment for instances of this type. Can be called on any isconcretetype.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.datatype_haspadding\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.datatype_haspadding\",\n    \"category\": \"function\",\n    \"text\": \"Base.datatype_haspadding(dt::DataType) -> Bool\\n\\nReturn whether the fields of instances of this type are packed in memory, with no intervening padding bytes. Can be called on any isconcretetype.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.datatype_pointerfree\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.datatype_pointerfree\",\n    \"category\": \"function\",\n    \"text\": \"Base.datatype_pointerfree(dt::DataType) -> Bool\\n\\nReturn whether instances of this type can contain references to gc-managed memory. Can be called on any isconcretetype.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Memory-layout-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Memory layout\",\n    \"category\": \"section\",\n    \"text\": \"Base.sizeof(::Type)\\nBase.isconcretetype\\nBase.isbits\\nBase.isbitstype\\nCore.fieldtype\\nBase.fieldcount\\nBase.fieldoffset\\nBase.datatype_alignment\\nBase.datatype_haspadding\\nBase.datatype_pointerfree\"\n},\n\n{\n    \"location\": \"base/base.html#Base.typemin\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.typemin\",\n    \"category\": \"function\",\n    \"text\": \"typemin(T)\\n\\nThe lowest value representable by the given (real) numeric DataType T.\\n\\nExamples\\n\\njulia> typemin(Float16)\\n-Inf16\\n\\njulia> typemin(Float32)\\n-Inf32\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.typemax\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.typemax\",\n    \"category\": \"function\",\n    \"text\": \"typemax(T)\\n\\nThe highest value representable by the given (real) numeric DataType.\\n\\nExamples\\n\\njulia> typemax(Int8)\\n127\\n\\njulia> typemax(UInt32)\\n0xffffffff\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.floatmin\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.floatmin\",\n    \"category\": \"function\",\n    \"text\": \"floatmin(T)\\n\\nThe smallest in absolute value non-subnormal value representable by the given floating-point DataType T.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.floatmax\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.floatmax\",\n    \"category\": \"function\",\n    \"text\": \"floatmax(T)\\n\\nThe highest finite value representable by the given floating-point DataType T.\\n\\nExamples\\n\\njulia> floatmax(Float16)\\nFloat16(6.55e4)\\n\\njulia> floatmax(Float32)\\n3.4028235f38\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.maxintfloat\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.maxintfloat\",\n    \"category\": \"function\",\n    \"text\": \"maxintfloat(T=Float64)\\n\\nThe largest consecutive integer that is exactly represented in the given floating-point type T (which defaults to Float64).\\n\\nThat is, maxintfloat returns the smallest positive integer n such that n+1 is not exactly representable in the type T.\\n\\n\\n\\n\\n\\nmaxintfloat(T, S)\\n\\nThe largest consecutive integer representable in the given floating-point type T that also does not exceed the maximum integer representable by the integer type S.  Equivalently, it is the minimum of maxintfloat(T) and typemax(S).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.eps-Tuple{Type{#s37} where #s37<:AbstractFloat}\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.eps\",\n    \"category\": \"method\",\n    \"text\": \"eps(::Type{T}) where T<:AbstractFloat\\neps()\\n\\nReturn the machine epsilon of the floating point type T (T = Float64 by default). This is defined as the gap between 1 and the next largest value representable by typeof(one(T)), and is equivalent to eps(one(T)).  (Since eps(T) is a bound on the relative error of T, it is a \\\"dimensionless\\\" quantity like one.)\\n\\nExamples\\n\\njulia> eps()\\n2.220446049250313e-16\\n\\njulia> eps(Float32)\\n1.1920929f-7\\n\\njulia> 1.0 + eps()\\n1.0000000000000002\\n\\njulia> 1.0 + eps()/2\\n1.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.eps-Tuple{AbstractFloat}\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.eps\",\n    \"category\": \"method\",\n    \"text\": \"eps(x::AbstractFloat)\\n\\nReturn the unit in last place (ulp) of x. This is the distance between consecutive representable floating point values at x. In most cases, if the distance on either side of x is different, then the larger of the two is taken, that is\\n\\neps(x) == max(x-prevfloat(x), nextfloat(x)-x)\\n\\nThe exceptions to this rule are the smallest and largest finite values (e.g. nextfloat(-Inf) and prevfloat(Inf) for Float64), which round to the smaller of the values.\\n\\nThe rationale for this behavior is that eps bounds the floating point rounding error. Under the default RoundNearest rounding mode, if y is a real number and x is the nearest floating point number to y, then\\n\\ny-x leq operatornameeps(x)2\\n\\nExamples\\n\\njulia> eps(1.0)\\n2.220446049250313e-16\\n\\njulia> eps(prevfloat(2.0))\\n2.220446049250313e-16\\n\\njulia> eps(2.0)\\n4.440892098500626e-16\\n\\njulia> x = prevfloat(Inf)      # largest finite Float64\\n1.7976931348623157e308\\n\\njulia> x + eps(x)/2            # rounds up\\nInf\\n\\njulia> x + prevfloat(eps(x)/2) # rounds down\\n1.7976931348623157e308\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.instances\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.instances\",\n    \"category\": \"function\",\n    \"text\": \"instances(T::Type)\\n\\nReturn a collection of all instances of the given type, if applicable. Mostly used for enumerated types (see @enum).\\n\\nExample\\n\\njulia> @enum Color red blue green\\n\\njulia> instances(Color)\\n(red::Color = 0, blue::Color = 1, green::Color = 2)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Special-values-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Special values\",\n    \"category\": \"section\",\n    \"text\": \"Base.typemin\\nBase.typemax\\nBase.floatmin\\nBase.floatmax\\nBase.maxintfloat\\nBase.eps(::Type{<:AbstractFloat})\\nBase.eps(::AbstractFloat)\\nBase.instances\"\n},\n\n{\n    \"location\": \"base/base.html#Core.Any\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.Any\",\n    \"category\": \"type\",\n    \"text\": \"Any::DataType\\n\\nAny is the union of all types. It has the defining property isa(x, Any) == true for any x. Any therefore describes the entire universe of possible values. For example Integer is a subset of Any that includes Int, Int8, and other integer types.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.Union\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.Union\",\n    \"category\": \"type\",\n    \"text\": \"Union{Types...}\\n\\nA type union is an abstract type which includes all instances of any of its argument types. The empty union Union{} is the bottom type of Julia.\\n\\nExamples\\n\\njulia> IntOrString = Union{Int,AbstractString}\\nUnion{Int64, AbstractString}\\n\\njulia> 1 :: IntOrString\\n1\\n\\njulia> \\\"Hello!\\\" :: IntOrString\\n\\\"Hello!\\\"\\n\\njulia> 1.0 :: IntOrString\\nERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got Float64\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Union{}\",\n    \"page\": \"Essentials\",\n    \"title\": \"Union{}\",\n    \"category\": \"keyword\",\n    \"text\": \"Union{}\\n\\nUnion{}, the empty Union of types, is the type that has no values. That is, it has the defining property isa(x, Union{}) == false for any x. Base.Bottom is defined as its alias and the type of Union{} is Core.TypeofBottom.\\n\\nExamples\\n\\njulia> isa(nothing, Union{})\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.UnionAll\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.UnionAll\",\n    \"category\": \"type\",\n    \"text\": \"UnionAll\\n\\nA union of types over all values of a type parameter. UnionAll is used to describe parametric types where the values of some parameters are not known.\\n\\nExamples\\n\\njulia> typeof(Vector)\\nUnionAll\\n\\njulia> typeof(Vector{Int})\\nDataType\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.Tuple\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.Tuple\",\n    \"category\": \"type\",\n    \"text\": \"Tuple{Types...}\\n\\nTuples are an abstraction of the arguments of a function \u2013 without the function itself. The salient aspects of a function\\'s arguments are their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one field. Tuple types may have any number of parameters.\\n\\nTuple types are covariant in their parameters: Tuple{Int} is a subtype of Tuple{Any}. Therefore Tuple{Any} is considered an abstract type, and tuple types are only concrete if their parameters are. Tuples do not have field names; fields are only accessed by index.\\n\\nSee the manual section on Tuple Types.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.NamedTuple\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.NamedTuple\",\n    \"category\": \"type\",\n    \"text\": \"NamedTuple\\n\\nNamedTuples are, as their name suggests, named Tuples. That is, they\\'re a tuple-like collection of values, where each entry has a unique name, represented as a Symbol. Like Tuples, NamedTuples are immutable; neither the names nor the values can be modified in place after construction.\\n\\nAccessing the value associated with a name in a named tuple can be done using field access syntax, e.g. x.a, or using getindex, e.g. x[:a]. A tuple of the names can be obtained using keys, and a tuple of the values can be obtained using values.\\n\\nnote: Note\\nIteration over NamedTuples produces the values without the names. (See example below.) To iterate over the name-value pairs, use the pairs function.\\n\\nExamples\\n\\njulia> x = (a=1, b=2)\\n(a = 1, b = 2)\\n\\njulia> x.a\\n1\\n\\njulia> x[:a]\\n1\\n\\njulia> keys(x)\\n(:a, :b)\\n\\njulia> values(x)\\n(1, 2)\\n\\njulia> collect(x)\\n2-element Array{Int64,1}:\\n 1\\n 2\\n\\njulia> collect(pairs(x))\\n2-element Array{Pair{Symbol,Int64},1}:\\n :a => 1\\n :b => 2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Val\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Val\",\n    \"category\": \"type\",\n    \"text\": \"Val(c)\\n\\nReturn Val{c}(), which contains no run-time data. Types like this can be used to pass the information between functions through the value c, which must be an isbits value. The intent of this construct is to be able to dispatch on constants directly (at compile time) without having to test the value of the constant at run time.\\n\\nExamples\\n\\njulia> f(::Val{true}) = \\\"Good\\\"\\nf (generic function with 1 method)\\n\\njulia> f(::Val{false}) = \\\"Bad\\\"\\nf (generic function with 2 methods)\\n\\njulia> f(Val(true))\\n\\\"Good\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.Vararg\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.Vararg\",\n    \"category\": \"type\",\n    \"text\": \"Vararg{T,N}\\n\\nThe last parameter of a tuple type Tuple can be the special type Vararg, which denotes any number of trailing elements. The type Vararg{T,N} corresponds to exactly N elements of type T. Vararg{T} corresponds to zero or more elements of type T. Vararg tuple types are used to represent the arguments accepted by varargs methods (see the section on Varargs Functions in the manual.)\\n\\nExamples\\n\\njulia> mytupletype = Tuple{AbstractString,Vararg{Int}}\\nTuple{AbstractString,Vararg{Int64,N} where N}\\n\\njulia> isa((\\\"1\\\",), mytupletype)\\ntrue\\n\\njulia> isa((\\\"1\\\",1), mytupletype)\\ntrue\\n\\njulia> isa((\\\"1\\\",1,2), mytupletype)\\ntrue\\n\\njulia> isa((\\\"1\\\",1,2,3.0), mytupletype)\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.Nothing\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.Nothing\",\n    \"category\": \"type\",\n    \"text\": \"Nothing\\n\\nA type with no fields that is the type nothing.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Some\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Some\",\n    \"category\": \"type\",\n    \"text\": \"Some{T}\\n\\nA wrapper type used in Union{Some{T}, Nothing} to distinguish between the absence of a value (nothing) and the presence of a nothing value (i.e. Some(nothing)).\\n\\nUse something to access the value wrapped by a Some object.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.something\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.something\",\n    \"category\": \"function\",\n    \"text\": \"something(x, y...)\\n\\nReturn the first value in the arguments which is not equal to nothing, if any. Otherwise throw an error. Arguments of type Some are unwrapped.\\n\\nExamples\\n\\njulia> something(nothing, 1)\\n1\\n\\njulia> something(Some(1), nothing)\\n1\\n\\njulia> something(missing, nothing)\\nmissing\\n\\njulia> something(nothing, nothing)\\nERROR: ArgumentError: No value arguments present\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Enums.@enum\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Enums.@enum\",\n    \"category\": \"macro\",\n    \"text\": \"@enum EnumName[::BaseType] value1[=x] value2[=y]\\n\\nCreate an Enum{BaseType} subtype with name EnumName and enum member values of value1 and value2 with optional assigned values of x and y, respectively. EnumName can be used just like other types and enum member values as regular values, such as\\n\\nExamples\\n\\njulia> @enum Fruit apple=1 orange=2 kiwi=3\\n\\njulia> f(x::Fruit) = \\\"I\\'m a Fruit with value: $(Int(x))\\\"\\nf (generic function with 1 method)\\n\\njulia> f(apple)\\n\\\"I\\'m a Fruit with value: 1\\\"\\n\\nValues can also be specified inside a begin block, e.g.\\n\\n@enum EnumName begin\\n    value1\\n    value2\\nend\\n\\nBaseType, which defaults to Int32, must be a primitive subtype of Integer. Member values can be converted between the enum type and BaseType. read and write perform these conversions automatically.\\n\\nTo list all the instances of an enum use instances, e.g.\\n\\njulia> instances(Fruit)\\n(apple::Fruit = 1, orange::Fruit = 2, kiwi::Fruit = 3)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Special-Types-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Special Types\",\n    \"category\": \"section\",\n    \"text\": \"Core.Any\\nCore.Union\\nUnion{}\\nCore.UnionAll\\nCore.Tuple\\nCore.NamedTuple\\nBase.Val\\nCore.Vararg\\nCore.Nothing\\nBase.Some\\nBase.something\\nBase.Enums.@enum\"\n},\n\n{\n    \"location\": \"base/base.html#Core.Function\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.Function\",\n    \"category\": \"type\",\n    \"text\": \"Function\\n\\nAbstract type of all functions.\\n\\njulia> isa(+, Function)\\ntrue\\n\\njulia> typeof(sin)\\ntypeof(sin)\\n\\njulia> ans <: Function\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.hasmethod\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.hasmethod\",\n    \"category\": \"function\",\n    \"text\": \"hasmethod(f, Tuple type; world = typemax(UInt)) -> Bool\\n\\nDetermine whether the given generic function has a method matching the given Tuple of argument types with the upper bound of world age given by world.\\n\\nExamples\\n\\njulia> hasmethod(length, Tuple{Array})\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.applicable\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.applicable\",\n    \"category\": \"function\",\n    \"text\": \"applicable(f, args...) -> Bool\\n\\nDetermine whether the given generic function has a method applicable to the given arguments.\\n\\nExamples\\n\\njulia> function f(x, y)\\n           x + y\\n       end;\\n\\njulia> applicable(f, 1)\\nfalse\\n\\njulia> applicable(f, 1, 2)\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.invoke\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.invoke\",\n    \"category\": \"function\",\n    \"text\": \"invoke(f, argtypes::Type, args...; kwargs...)\\n\\nInvoke a method for the given generic function f matching the specified types argtypes on the specified arguments args and passing the keyword arguments kwargs. The arguments args must conform with the specified types in argtypes, i.e. conversion is not automatically performed. This method allows invoking a method other than the most specific matching method, which is useful when the behavior of a more general definition is explicitly needed (often as part of the implementation of a more specific method of the same function).\\n\\nExamples\\n\\njulia> f(x::Real) = x^2;\\n\\njulia> f(x::Integer) = 1 + invoke(f, Tuple{Real}, x);\\n\\njulia> f(2)\\n5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.invokelatest\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.invokelatest\",\n    \"category\": \"function\",\n    \"text\": \"invokelatest(f, args...; kwargs...)\\n\\nCalls f(args...; kwargs...), but guarantees that the most recent method of f will be executed.   This is useful in specialized circumstances, e.g. long-running event loops or callback functions that may call obsolete versions of a function f. (The drawback is that invokelatest is somewhat slower than calling f directly, and the type of the result cannot be inferred by the compiler.)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#new\",\n    \"page\": \"Essentials\",\n    \"title\": \"new\",\n    \"category\": \"keyword\",\n    \"text\": \"new\\n\\nSpecial function available to inner constructors which created a new object of the type. See the manual section on Inner Constructor Methods for more information.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.:|>\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.:|>\",\n    \"category\": \"function\",\n    \"text\": \"|>(x, f)\\n\\nApplies a function to the preceding argument. This allows for easy function chaining.\\n\\nExamples\\n\\njulia> [1:5;] |> x->x.^2 |> sum |> inv\\n0.01818181818181818\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.:\u2218\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.:\u2218\",\n    \"category\": \"function\",\n    \"text\": \"f \u2218 g\\n\\nCompose functions: i.e. (f \u2218 g)(args...) means f(g(args...)). The \u2218 symbol can be entered in the Julia REPL (and most editors, appropriately configured) by typing \\\\circ<tab>.\\n\\nExamples\\n\\njulia> map(uppercase\u2218first, [\\\"apple\\\", \\\"banana\\\", \\\"carrot\\\"])\\n3-element Array{Char,1}:\\n \\'A\\'\\n \\'B\\'\\n \\'C\\'\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Generic-Functions-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Generic Functions\",\n    \"category\": \"section\",\n    \"text\": \"Core.Function\\nBase.hasmethod\\nCore.applicable\\nCore.invoke\\nBase.invokelatest\\nnew\\nBase.:(|>)\\nBase.:(\u2218)\"\n},\n\n{\n    \"location\": \"base/base.html#Core.eval\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.eval\",\n    \"category\": \"function\",\n    \"text\": \"Core.eval(m::Module, expr)\\n\\nEvaluate an expression in the given module and return the result.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.MainInclude.eval\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.MainInclude.eval\",\n    \"category\": \"function\",\n    \"text\": \"eval(expr)\\n\\nEvaluate an expression in the global scope of the containing module. Every Module (except those defined with baremodule) has its own 1-argument definition of eval, which evaluates expressions in that module.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@eval\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@eval\",\n    \"category\": \"macro\",\n    \"text\": \"@eval [mod,] ex\\n\\nEvaluate an expression with values interpolated into it using eval. If two arguments are provided, the first is the module to evaluate in.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.evalfile\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.evalfile\",\n    \"category\": \"function\",\n    \"text\": \"evalfile(path::AbstractString, args::Vector{String}=String[])\\n\\nLoad the file using Base.include, evaluate all expressions, and return the value of the last one.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.esc\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.esc\",\n    \"category\": \"function\",\n    \"text\": \"esc(e)\\n\\nOnly valid in the context of an Expr returned from a macro. Prevents the macro hygiene pass from turning embedded variables into gensym variables. See the Macros section of the Metaprogramming chapter of the manual for more details and examples.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@inbounds\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@inbounds\",\n    \"category\": \"macro\",\n    \"text\": \"@inbounds(blk)\\n\\nEliminates array bounds checking within expressions.\\n\\nIn the example below the in-range check for referencing element i of array A is skipped to improve performance.\\n\\nfunction sum(A::AbstractArray)\\n    r = zero(eltype(A))\\n    for i = 1:length(A)\\n        @inbounds r += A[i]\\n    end\\n    return r\\nend\\n\\nwarning: Warning\\nUsing @inbounds may return incorrect results/crashes/corruption for out-of-bounds indices. The user is responsible for checking it manually. Only use @inbounds when it is certain from the information locally available that all accesses are in bounds.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@boundscheck\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@boundscheck\",\n    \"category\": \"macro\",\n    \"text\": \"@boundscheck(blk)\\n\\nAnnotates the expression blk as a bounds checking block, allowing it to be elided by @inbounds.\\n\\nnote: Note\\nThe function in which @boundscheck is written must be inlined into its caller in order for @inbounds to have effect.\\n\\nExamples\\n\\njulia> @inline function g(A, i)\\n           @boundscheck checkbounds(A, i)\\n           return \\\"accessing ($A)[$i]\\\"\\n       end;\\n\\njulia> f1() = return g(1:2, -1);\\n\\njulia> f2() = @inbounds return g(1:2, -1);\\n\\njulia> f1()\\nERROR: BoundsError: attempt to access 2-element UnitRange{Int64} at index [-1]\\nStacktrace:\\n [1] throw_boundserror(::UnitRange{Int64}, ::Tuple{Int64}) at ./abstractarray.jl:455\\n [2] checkbounds at ./abstractarray.jl:420 [inlined]\\n [3] g at ./none:2 [inlined]\\n [4] f1() at ./none:1\\n [5] top-level scope\\n\\njulia> f2()\\n\\\"accessing (1:2)[-1]\\\"\\n\\nwarning: Warning\\nThe @boundscheck annotation allows you, as a library writer, to opt-in to allowing other code to remove your bounds checks with @inbounds. As noted there, the caller must verify\u2014using information they can access\u2014that their accesses are valid before using @inbounds. For indexing into your AbstractArray subclasses, for example, this involves checking the indices against its size. Therefore, @boundscheck annotations should only be added to a getindex or setindex! implementation after you are certain its behavior is correct.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@inline\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@inline\",\n    \"category\": \"macro\",\n    \"text\": \"@inline\\n\\nGive a hint to the compiler that this function is worth inlining.\\n\\nSmall functions typically do not need the @inline annotation, as the compiler does it automatically. By using @inline on bigger functions, an extra nudge can be given to the compiler to inline it. This is shown in the following example:\\n\\n@inline function bigfunction(x)\\n    #=\\n        Function Definition\\n    =#\\nend\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@noinline\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@noinline\",\n    \"category\": \"macro\",\n    \"text\": \"@noinline\\n\\nPrevents the compiler from inlining a function.\\n\\nSmall functions are typically inlined automatically. By using @noinline on small functions, auto-inlining can be prevented. This is shown in the following example:\\n\\n@noinline function smallfunction(x)\\n    #=\\n        Function Definition\\n    =#\\nend\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@nospecialize\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@nospecialize\",\n    \"category\": \"macro\",\n    \"text\": \"@nospecialize\\n\\nApplied to a function argument name, hints to the compiler that the method should not be specialized for different types of that argument, but instead to use precisely the declared type for each argument. This is only a hint for avoiding excess code generation. Can be applied to an argument within a formal argument list, or in the function body. When applied to an argument, the macro must wrap the entire argument expression. When used in a function body, the macro must occur in statement position and before any code.\\n\\nWhen used without arguments, it applies to all arguments of the parent scope. In local scope, this means all arguments of the containing function. In global (top-level) scope, this means all methods subsequently defined in the current module.\\n\\nSpecialization can reset back to the default by using @specialize.\\n\\nfunction example_function(@nospecialize x)\\n    ...\\nend\\n\\nfunction example_function(@nospecialize(x = 1), y)\\n    ...\\nend\\n\\nfunction example_function(x, y, z)\\n    @nospecialize x y\\n    ...\\nend\\n\\n@nospecialize\\nf(y) = [x for x in y]\\n@specialize\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@specialize\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@specialize\",\n    \"category\": \"macro\",\n    \"text\": \"@specialize\\n\\nReset the specialization hint for an argument back to the default. For details, see @specialize.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.gensym\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.gensym\",\n    \"category\": \"function\",\n    \"text\": \"gensym([tag])\\n\\nGenerates a symbol which will not conflict with other variable names.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@gensym\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@gensym\",\n    \"category\": \"macro\",\n    \"text\": \"@gensym\\n\\nGenerates a gensym symbol for a variable. For example, @gensym x y is transformed into x = gensym(\\\"x\\\"); y = gensym(\\\"y\\\").\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@goto\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@goto\",\n    \"category\": \"macro\",\n    \"text\": \"@goto name\\n\\n@goto name unconditionally jumps to the statement at the location @label name.\\n\\n@label and @goto cannot create jumps to different top-level statements. Attempts cause an error. To still use @goto, enclose the @label and @goto in a block.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@label\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@label\",\n    \"category\": \"macro\",\n    \"text\": \"@label name\\n\\nLabels a statement with the symbolic label name. The label marks the end-point of an unconditional jump with @goto name.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.SimdLoop.@simd\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.SimdLoop.@simd\",\n    \"category\": \"macro\",\n    \"text\": \"@simd\\n\\nAnnotate a for loop to allow the compiler to take extra liberties to allow loop re-ordering\\n\\nwarning: Warning\\nThis feature is experimental and could change or disappear in future versions of Julia. Incorrect use of the @simd macro may cause unexpected results.\\n\\nThe object iterated over in a @simd for loop should be a one-dimensional range. By using @simd, you are asserting several properties of the loop:\\n\\n* It is safe to execute iterations in arbitrary or overlapping order, with special consideration for reduction variables.\\n* Floating-point operations on reduction variables can be reordered, possibly causing different results than without `@simd`.\\n\\nIn many cases, Julia is able to automatically vectorize inner for loops without the use of @simd. Using @simd gives the compiler a little extra leeway to make it possible in more situations. In either case, your inner loop should have the following properties to allow vectorization:\\n\\n* The loop must be an innermost loop\\n* The loop body must be straight-line code. Therefore, [`@inbounds`](@ref) is\\n  currently needed for all array accesses. The compiler can sometimes turn\\n  short `&&`, `||`, and `?:` expressions into straight-line code if it is safe\\n  to evaluate all operands unconditionally. Consider using the [`ifelse`](@ref)\\n  function instead of `?:` in the loop if it is safe to do so.\\n* Accesses must have a stride pattern and cannot be \\\"gathers\\\" (random-index\\n  reads) or \\\"scatters\\\" (random-index writes).\\n* The stride should be unit stride.\\n\\nnote: Note\\nThe @simd does not assert by default that the loop is completely free of loop-carried memory dependencies, which is an assumption that can easily be violated in generic code. If you are writing non-generic code, you can use @simd ivdep for ... end to also assert that:* There exists no loop-carried memory dependencies\\n* No iteration ever waits on a previous iteration to make forward progress.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@polly\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@polly\",\n    \"category\": \"macro\",\n    \"text\": \"@polly\\n\\nTells the compiler to apply the polyhedral optimizer Polly to a function.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@generated\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@generated\",\n    \"category\": \"macro\",\n    \"text\": \"@generated f\\n@generated(f)\\n\\n@generated is used to annotate a function which will be generated. In the body of the generated function, only types of arguments can be read (not the values). The function returns a quoted expression evaluated when the function is called. The @generated macro should not be used on functions mutating the global scope or depending on mutable elements.\\n\\nSee Metaprogramming for further details.\\n\\nExample:\\n\\njulia> @generated function bar(x)\\n           if x <: Integer\\n               return :(x ^ 2)\\n           else\\n               return :(x)\\n           end\\n       end\\nbar (generic function with 1 method)\\n\\njulia> bar(4)\\n16\\n\\njulia> bar(\\\"baz\\\")\\n\\\"baz\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@pure\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@pure\",\n    \"category\": \"macro\",\n    \"text\": \"@pure ex\\n@pure(ex)\\n\\n@pure gives the compiler a hint for the definition of a pure function, helping for type inference.\\n\\nA pure function can only depend on immutable information. This also means a @pure function cannot use any global mutable state, including generic functions. Calls to generic functions depend on method tables which are mutable global state. Use with caution, incorrect @pure annotation of a function may introduce hard to identify bugs. Double check for calls to generic functions.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Syntax-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Syntax\",\n    \"category\": \"section\",\n    \"text\": \"Core.eval\\nBase.MainInclude.eval\\nBase.@eval\\nBase.evalfile\\nBase.esc\\nBase.@inbounds\\nBase.@boundscheck\\nBase.@inline\\nBase.@noinline\\nBase.@nospecialize\\nBase.@specialize\\nBase.gensym\\nBase.@gensym\\nBase.@goto\\nBase.@label\\nBase.@simd\\nBase.@polly\\nBase.@generated\\nBase.@pure\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Missing\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Missing\",\n    \"category\": \"type\",\n    \"text\": \"Missing\\n\\nA type with no fields whose singleton instance missing is used to represent missing values.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.missing\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.missing\",\n    \"category\": \"constant\",\n    \"text\": \"missing\\n\\nThe singleton instance of type Missing representing a missing value.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.coalesce\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.coalesce\",\n    \"category\": \"function\",\n    \"text\": \"coalesce(x, y...)\\n\\nReturn the first value in the arguments which is not equal to missing, if any. Otherwise return missing.\\n\\nExamples\\n\\njulia> coalesce(missing, 1)\\n1\\n\\njulia> coalesce(1, missing)\\n1\\n\\njulia> coalesce(nothing, 1)  # returns `nothing`\\n\\njulia> coalesce(missing, missing)\\nmissing\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.ismissing\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.ismissing\",\n    \"category\": \"function\",\n    \"text\": \"ismissing(x)\\n\\nIndicate whether x is missing.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.skipmissing\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.skipmissing\",\n    \"category\": \"function\",\n    \"text\": \"skipmissing(itr)\\n\\nReturn an iterator over the elements in itr skipping missing values.\\n\\nUse collect to obtain an Array containing the non-missing values in itr. Note that even if itr is a multidimensional array, the result will always be a Vector since it is not possible to remove missings while preserving dimensions of the input.\\n\\nExamples\\n\\njulia> sum(skipmissing([1, missing, 2]))\\n3\\n\\njulia> collect(skipmissing([1, missing, 2]))\\n2-element Array{Int64,1}:\\n 1\\n 2\\n\\njulia> collect(skipmissing([1 missing; 2 missing]))\\n2-element Array{Int64,1}:\\n 1\\n 2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Missing-Values-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Missing Values\",\n    \"category\": \"section\",\n    \"text\": \"Base.Missing\\nBase.missing\\nBase.coalesce\\nBase.ismissing\\nBase.skipmissing\"\n},\n\n{\n    \"location\": \"base/base.html#Base.run\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.run\",\n    \"category\": \"function\",\n    \"text\": \"run(command, args...; wait::Bool = true)\\n\\nRun a command object, constructed with backticks. Throws an error if anything goes wrong, including the process exiting with a non-zero status (when wait is true).\\n\\nIf wait is false, the process runs asynchronously. You can later wait for it and check its exit status by calling success on the returned process object.\\n\\nWhen wait is false, the process\\' I/O streams are directed to devnull. When wait is true, I/O streams are shared with the parent process. Use pipeline to control I/O redirection.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.devnull\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.devnull\",\n    \"category\": \"constant\",\n    \"text\": \"devnull\\n\\nUsed in a stream redirect to discard all data written to it. Essentially equivalent to /dev/null on Unix or NUL on Windows. Usage:\\n\\nrun(pipeline(`cat test.txt`, devnull))\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.success\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.success\",\n    \"category\": \"function\",\n    \"text\": \"success(command)\\n\\nRun a command object, constructed with backticks, and tell whether it was successful (exited with a code of 0). An exception is raised if the process cannot be started.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.process_running\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.process_running\",\n    \"category\": \"function\",\n    \"text\": \"process_running(p::Process)\\n\\nDetermine whether a process is currently running.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.process_exited\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.process_exited\",\n    \"category\": \"function\",\n    \"text\": \"process_exited(p::Process)\\n\\nDetermine whether a process has exited.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.kill-Tuple{Base.Process,Integer}\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.kill\",\n    \"category\": \"method\",\n    \"text\": \"kill(p::Process, signum=SIGTERM)\\n\\nSend a signal to a process. The default is to terminate the process. Returns successfully if the process has already exited, but throws an error if killing the process failed for other reasons (e.g. insufficient permissions).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Sys.set_process_title\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Sys.set_process_title\",\n    \"category\": \"function\",\n    \"text\": \"Sys.set_process_title(title::AbstractString)\\n\\nSet the process title. No-op on some operating systems.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Sys.get_process_title\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Sys.get_process_title\",\n    \"category\": \"function\",\n    \"text\": \"Sys.get_process_title()\\n\\nGet the process title. On some systems, will always return an empty string.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.ignorestatus\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.ignorestatus\",\n    \"category\": \"function\",\n    \"text\": \"ignorestatus(command)\\n\\nMark a command object so that running it will not throw an error if the result code is non-zero.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.detach\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.detach\",\n    \"category\": \"function\",\n    \"text\": \"detach(command)\\n\\nMark a command object so that it will be run in a new process group, allowing it to outlive the julia process, and not have Ctrl-C interrupts passed to it.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Cmd\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Cmd\",\n    \"category\": \"type\",\n    \"text\": \"Cmd(cmd::Cmd; ignorestatus, detach, windows_verbatim, windows_hide, env, dir)\\n\\nConstruct a new Cmd object, representing an external program and arguments, from cmd, while changing the settings of the optional keyword arguments:\\n\\nignorestatus::Bool: If true (defaults to false), then the Cmd will not throw an error if the return code is nonzero.\\ndetach::Bool: If true (defaults to false), then the Cmd will be run in a new process group, allowing it to outlive the julia process and not have Ctrl-C passed to it.\\nwindows_verbatim::Bool: If true (defaults to false), then on Windows the Cmd will send a command-line string to the process with no quoting or escaping of arguments, even arguments containing spaces. (On Windows, arguments are sent to a program as a single \\\"command-line\\\" string, and programs are responsible for parsing it into arguments. By default, empty arguments and arguments with spaces or tabs are quoted with double quotes \\\" in the command line, and \\\\ or \\\" are preceded by backslashes. windows_verbatim=true is useful for launching programs that parse their command line in nonstandard ways.) Has no effect on non-Windows systems.\\nwindows_hide::Bool: If true (defaults to false), then on Windows no new console window is displayed when the Cmd is executed. This has no effect if a console is already open or on non-Windows systems.\\nenv: Set environment variables to use when running the Cmd. env is either a dictionary mapping strings to strings, an array of strings of the form \\\"var=val\\\", an array or tuple of \\\"var\\\"=>val pairs, or nothing. In order to modify (rather than replace) the existing environment, create env by copy(ENV) and then set env[\\\"var\\\"]=val as desired.\\ndir::AbstractString: Specify a working directory for the command (instead of the current directory).\\n\\nFor any keywords that are not specified, the current settings from cmd are used. Normally, to create a Cmd object in the first place, one uses backticks, e.g.\\n\\nCmd(`echo \\\"Hello world\\\"`, ignorestatus=true, detach=false)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.setenv\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.setenv\",\n    \"category\": \"function\",\n    \"text\": \"setenv(command::Cmd, env; dir=\\\"\\\")\\n\\nSet environment variables to use when running the given command. env is either a dictionary mapping strings to strings, an array of strings of the form \\\"var=val\\\", or zero or more \\\"var\\\"=>val pair arguments. In order to modify (rather than replace) the existing environment, create env by copy(ENV) and then setting env[\\\"var\\\"]=val as desired, or use withenv.\\n\\nThe dir keyword argument can be used to specify a working directory for the command.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.withenv\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.withenv\",\n    \"category\": \"function\",\n    \"text\": \"withenv(f::Function, kv::Pair...)\\n\\nExecute f in an environment that is temporarily modified (not replaced as in setenv) by zero or more \\\"var\\\"=>val arguments kv. withenv is generally used via the withenv(kv...) do ... end syntax. A value of nothing can be used to temporarily unset an environment variable (if it is set). When withenv returns, the original environment has been restored.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.pipeline-Tuple{Any,Any,Any,Vararg{Any,N} where N}\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.pipeline\",\n    \"category\": \"method\",\n    \"text\": \"pipeline(from, to, ...)\\n\\nCreate a pipeline from a data source to a destination. The source and destination can be commands, I/O streams, strings, or results of other pipeline calls. At least one argument must be a command. Strings refer to filenames. When called with more than two arguments, they are chained together from left to right. For example, pipeline(a,b,c) is equivalent to pipeline(pipeline(a,b),c). This provides a more concise way to specify multi-stage pipelines.\\n\\nExamples:\\n\\nrun(pipeline(`ls`, `grep xyz`))\\nrun(pipeline(`ls`, \\\"out.txt\\\"))\\nrun(pipeline(\\\"out.txt\\\", `grep xyz`))\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.pipeline-Tuple{Base.AbstractCmd}\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.pipeline\",\n    \"category\": \"method\",\n    \"text\": \"pipeline(command; stdin, stdout, stderr, append=false)\\n\\nRedirect I/O to or from the given command. Keyword arguments specify which of the command\\'s streams should be redirected. append controls whether file output appends to the file. This is a more general version of the 2-argument pipeline function. pipeline(from, to) is equivalent to pipeline(from, stdout=to) when from is a command, and to pipeline(to, stdin=from) when from is another kind of data source.\\n\\nExamples:\\n\\nrun(pipeline(`dothings`, stdout=\\\"out.txt\\\", stderr=\\\"errs.txt\\\"))\\nrun(pipeline(`update`, stdout=\\\"log.txt\\\", append=true))\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Libc.gethostname\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Libc.gethostname\",\n    \"category\": \"function\",\n    \"text\": \"gethostname() -> AbstractString\\n\\nGet the local machine\\'s host name.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Libc.getpid\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Libc.getpid\",\n    \"category\": \"function\",\n    \"text\": \"getpid() -> Int32\\n\\nGet Julia\\'s process ID.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Libc.time-Tuple{}\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Libc.time\",\n    \"category\": \"method\",\n    \"text\": \"time()\\n\\nGet the system time in seconds since the epoch, with fairly high (typically, microsecond) resolution.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.time_ns\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.time_ns\",\n    \"category\": \"function\",\n    \"text\": \"time_ns()\\n\\nGet the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@time\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@time\",\n    \"category\": \"macro\",\n    \"text\": \"@time\\n\\nA macro to execute an expression, printing the time it took to execute, the number of allocations, and the total number of bytes its execution caused to be allocated, before returning the value of the expression.\\n\\nSee also @timev, @timed, @elapsed, and @allocated.\\n\\njulia> @time rand(10^6);\\n  0.001525 seconds (7 allocations: 7.630 MiB)\\n\\njulia> @time begin\\n           sleep(0.3)\\n           1+1\\n       end\\n  0.301395 seconds (8 allocations: 336 bytes)\\n2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@timev\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@timev\",\n    \"category\": \"macro\",\n    \"text\": \"@timev\\n\\nThis is a verbose version of the @time macro. It first prints the same information as @time, then any non-zero memory allocation counters, and then returns the value of the expression.\\n\\nSee also @time, @timed, @elapsed, and @allocated.\\n\\njulia> @timev rand(10^6);\\n  0.001006 seconds (7 allocations: 7.630 MiB)\\nelapsed time (ns): 1005567\\nbytes allocated:   8000256\\npool allocs:       6\\nmalloc() calls:    1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@timed\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@timed\",\n    \"category\": \"macro\",\n    \"text\": \"@timed\\n\\nA macro to execute an expression, and return the value of the expression, elapsed time, total bytes allocated, garbage collection time, and an object with various memory allocation counters.\\n\\nSee also @time, @timev, @elapsed, and @allocated.\\n\\njulia> val, t, bytes, gctime, memallocs = @timed rand(10^6);\\n\\njulia> t\\n0.006634834\\n\\njulia> bytes\\n8000256\\n\\njulia> gctime\\n0.0055765\\n\\njulia> fieldnames(typeof(memallocs))\\n(:allocd, :malloc, :realloc, :poolalloc, :bigalloc, :freecall, :total_time, :pause, :full_sweep)\\n\\njulia> memallocs.total_time\\n5576500\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@elapsed\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@elapsed\",\n    \"category\": \"macro\",\n    \"text\": \"@elapsed\\n\\nA macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute as a floating-point number.\\n\\nSee also @time, @timev, @timed, and @allocated.\\n\\njulia> @elapsed sleep(0.3)\\n0.301391426\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@allocated\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@allocated\",\n    \"category\": \"macro\",\n    \"text\": \"@allocated\\n\\nA macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression. Note: the expression is evaluated inside a local function, instead of the current context, in order to eliminate the effects of compilation, however, there still may be some allocations due to JIT compilation. This also makes the results inconsistent with the @time macros, which do not try to adjust for the effects of compilation.\\n\\nSee also @time, @timev, @timed, and @elapsed.\\n\\njulia> @allocated rand(10^6)\\n8000080\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.EnvDict\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.EnvDict\",\n    \"category\": \"type\",\n    \"text\": \"EnvDict() -> EnvDict\\n\\nA singleton of this type provides a hash table interface to environment variables.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.ENV\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.ENV\",\n    \"category\": \"constant\",\n    \"text\": \"ENV\\n\\nReference to the singleton EnvDict, providing a dictionary interface to system environment variables.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Sys.isunix\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Sys.isunix\",\n    \"category\": \"function\",\n    \"text\": \"Sys.isunix([os])\\n\\nPredicate for testing if the OS provides a Unix-like interface. See documentation in Handling Operating System Variation.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Sys.isapple\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Sys.isapple\",\n    \"category\": \"function\",\n    \"text\": \"Sys.isapple([os])\\n\\nPredicate for testing if the OS is a derivative of Apple Macintosh OS X or Darwin. See documentation in Handling Operating System Variation.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Sys.islinux\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Sys.islinux\",\n    \"category\": \"function\",\n    \"text\": \"Sys.islinux([os])\\n\\nPredicate for testing if the OS is a derivative of Linux. See documentation in Handling Operating System Variation.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Sys.isbsd\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Sys.isbsd\",\n    \"category\": \"function\",\n    \"text\": \"Sys.isbsd([os])\\n\\nPredicate for testing if the OS is a derivative of BSD. See documentation in Handling Operating System Variation.\\n\\nnote: Note\\nThe Darwin kernel descends from BSD, which means that Sys.isbsd() is true on macOS systems. To exclude macOS from a predicate, use Sys.isbsd() && !Sys.isapple().\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Sys.iswindows\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Sys.iswindows\",\n    \"category\": \"function\",\n    \"text\": \"Sys.iswindows([os])\\n\\nPredicate for testing if the OS is a derivative of Microsoft Windows NT. See documentation in Handling Operating System Variation.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Sys.windows_version\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Sys.windows_version\",\n    \"category\": \"function\",\n    \"text\": \"Sys.windows_version()\\n\\nReturn the version number for the Windows NT Kernel as a VersionNumber, i.e. v\\\"major.minor.build\\\", or v\\\"0.0.0\\\" if this is not running on Windows.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@static\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@static\",\n    \"category\": \"macro\",\n    \"text\": \"@static\\n\\nPartially evaluate an expression at parse time.\\n\\nFor example, @static Sys.iswindows() ? foo : bar will evaluate Sys.iswindows() and insert either foo or bar into the expression. This is useful in cases where a construct would be invalid on other platforms, such as a ccall to a non-existent function. @static if Sys.isapple() foo end and @static foo <&&,||> bar are also valid syntax.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#System-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"System\",\n    \"category\": \"section\",\n    \"text\": \"Base.run\\nBase.devnull\\nBase.success\\nBase.process_running\\nBase.process_exited\\nBase.kill(::Base.Process, ::Integer)\\nBase.Sys.set_process_title\\nBase.Sys.get_process_title\\nBase.ignorestatus\\nBase.detach\\nBase.Cmd\\nBase.setenv\\nBase.withenv\\nBase.pipeline(::Any, ::Any, ::Any, ::Any...)\\nBase.pipeline(::Base.AbstractCmd)\\nBase.Libc.gethostname\\nBase.Libc.getpid\\nBase.Libc.time()\\nBase.time_ns\\nBase.@time\\nBase.@timev\\nBase.@timed\\nBase.@elapsed\\nBase.@allocated\\nBase.EnvDict\\nBase.ENV\\nBase.Sys.isunix\\nBase.Sys.isapple\\nBase.Sys.islinux\\nBase.Sys.isbsd\\nBase.Sys.iswindows\\nBase.Sys.windows_version\\nBase.@static\"\n},\n\n{\n    \"location\": \"base/base.html#Base.VersionNumber\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.VersionNumber\",\n    \"category\": \"type\",\n    \"text\": \"VersionNumber\\n\\nVersion number type which follow the specifications of semantic versioning, composed of major, minor and patch numeric values, followed by pre-release and build alpha-numeric annotations. See also @v_str.\\n\\nExamples\\n\\njulia> VersionNumber(\\\"1.2.3\\\")\\nv\\\"1.2.3\\\"\\n\\njulia> VersionNumber(\\\"2.0.1-rc1\\\")\\nv\\\"2.0.1-rc1\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@v_str\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@v_str\",\n    \"category\": \"macro\",\n    \"text\": \"@v_str\\n\\nString macro used to parse a string to a VersionNumber.\\n\\nExamples\\n\\njulia> v\\\"1.2.3\\\"\\nv\\\"1.2.3\\\"\\n\\njulia> v\\\"2.0.1-rc1\\\"\\nv\\\"2.0.1-rc1\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Versioning-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Versioning\",\n    \"category\": \"section\",\n    \"text\": \"Base.VersionNumber\\nBase.@v_str\"\n},\n\n{\n    \"location\": \"base/base.html#Base.error\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.error\",\n    \"category\": \"function\",\n    \"text\": \"error(message::AbstractString)\\n\\nRaise an ErrorException with the given message.\\n\\n\\n\\n\\n\\nerror(msg...)\\n\\nRaise an ErrorException with the given message.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.throw\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.throw\",\n    \"category\": \"function\",\n    \"text\": \"throw(e)\\n\\nThrow an object as an exception.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.rethrow\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.rethrow\",\n    \"category\": \"function\",\n    \"text\": \"rethrow([e])\\n\\nThrow an object without changing the current exception backtrace. The default argument is the current exception (if called within a catch block).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.backtrace\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.backtrace\",\n    \"category\": \"function\",\n    \"text\": \"backtrace()\\n\\nGet a backtrace object for the current program point.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.catch_backtrace\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.catch_backtrace\",\n    \"category\": \"function\",\n    \"text\": \"catch_backtrace()\\n\\nGet the backtrace of the current exception, for use within catch blocks.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@assert\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@assert\",\n    \"category\": \"macro\",\n    \"text\": \"@assert cond [text]\\n\\nThrow an AssertionError if cond is false. Preferred syntax for writing assertions. Message text is optionally displayed upon assertion failure.\\n\\nwarning: Warning\\nAn assert might be disabled at various optimization levels. Assert should therefore only be used as a debugging tool and not used for authentication verification (e.g., verifying passwords), nor should side effects needed for the function to work correctly be used inside of asserts.\\n\\nExamples\\n\\njulia> @assert iseven(3) \\\"3 is an odd number!\\\"\\nERROR: AssertionError: 3 is an odd number!\\n\\njulia> @assert isodd(3) \\\"What even are numbers?\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.ArgumentError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.ArgumentError\",\n    \"category\": \"type\",\n    \"text\": \"ArgumentError(msg)\\n\\nThe parameters to a function call do not match a valid signature. Argument msg is a descriptive error string.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.AssertionError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.AssertionError\",\n    \"category\": \"type\",\n    \"text\": \"AssertionError([msg])\\n\\nThe asserted condition did not evaluate to true. Optional argument msg is a descriptive error string.\\n\\nExamples\\n\\njulia> @assert false \\\"this is not true\\\"\\nERROR: AssertionError: this is not true\\n\\nAssertionError is usually thrown from @assert.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.BoundsError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.BoundsError\",\n    \"category\": \"type\",\n    \"text\": \"BoundsError([a],[i])\\n\\nAn indexing operation into an array, a, tried to access an out-of-bounds element at index i.\\n\\nExamples\\n\\njulia> A = fill(1.0, 7);\\n\\njulia> A[8]\\nERROR: BoundsError: attempt to access 7-element Array{Float64,1} at index [8]\\nStacktrace:\\n [1] getindex(::Array{Float64,1}, ::Int64) at ./array.jl:660\\n [2] top-level scope\\n\\njulia> B = fill(1.0, (2,3));\\n\\njulia> B[2, 4]\\nERROR: BoundsError: attempt to access 2\u00d73 Array{Float64,2} at index [2, 4]\\nStacktrace:\\n [1] getindex(::Array{Float64,2}, ::Int64, ::Int64) at ./array.jl:661\\n [2] top-level scope\\n\\njulia> B[9]\\nERROR: BoundsError: attempt to access 2\u00d73 Array{Float64,2} at index [9]\\nStacktrace:\\n [1] getindex(::Array{Float64,2}, ::Int64) at ./array.jl:660\\n [2] top-level scope\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.CompositeException\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.CompositeException\",\n    \"category\": \"type\",\n    \"text\": \"CompositeException\\n\\nWrap a Vector of exceptions thrown by a Task (e.g. generated from a remote worker over a channel or an asynchronously executing local I/O write or a remote worker under pmap) with information about the series of exceptions. For example, if a group of workers are executing several tasks, and multiple workers fail, the resulting CompositeException will contain a \\\"bundle\\\" of information from each worker indicating where and why the exception(s) occurred.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.DimensionMismatch\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.DimensionMismatch\",\n    \"category\": \"type\",\n    \"text\": \"DimensionMismatch([msg])\\n\\nThe objects called do not have matching dimensionality. Optional argument msg is a descriptive error string.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.DivideError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.DivideError\",\n    \"category\": \"type\",\n    \"text\": \"DivideError()\\n\\nInteger division was attempted with a denominator value of 0.\\n\\nExamples\\n\\njulia> 2/0\\nInf\\n\\njulia> div(2, 0)\\nERROR: DivideError: integer division error\\nStacktrace:\\n[...]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.DomainError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.DomainError\",\n    \"category\": \"type\",\n    \"text\": \"DomainError(val)\\nDomainError(val, msg)\\n\\nThe argument val to a function or constructor is outside the valid domain.\\n\\nExamples\\n\\njulia> sqrt(-1)\\nERROR: DomainError with -1.0:\\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\\nStacktrace:\\n[...]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.EOFError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.EOFError\",\n    \"category\": \"type\",\n    \"text\": \"EOFError()\\n\\nNo more data was available to read from a file or stream.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.ErrorException\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.ErrorException\",\n    \"category\": \"type\",\n    \"text\": \"ErrorException(msg)\\n\\nGeneric error type. The error message, in the .msg field, may provide more specific details.\\n\\nExample\\n\\njulia> ex = ErrorException(\\\"I\\'ve done a bad thing\\\");\\n\\njulia> ex.msg\\n\\\"I\\'ve done a bad thing\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.InexactError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.InexactError\",\n    \"category\": \"type\",\n    \"text\": \"InexactError(name::Symbol, T, val)\\n\\nCannot exactly convert val to type T in a method of function name.\\n\\nExamples\\n\\njulia> convert(Float64, 1+2im)\\nERROR: InexactError: Float64(Float64, 1 + 2im)\\nStacktrace:\\n[...]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.InterruptException\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.InterruptException\",\n    \"category\": \"type\",\n    \"text\": \"InterruptException()\\n\\nThe process was stopped by a terminal interrupt (CTRL+C).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.KeyError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.KeyError\",\n    \"category\": \"type\",\n    \"text\": \"KeyError(key)\\n\\nAn indexing operation into an AbstractDict (Dict) or Set like object tried to access or delete a non-existent element.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.LoadError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.LoadError\",\n    \"category\": \"type\",\n    \"text\": \"LoadError(file::AbstractString, line::Int, error)\\n\\nAn error occurred while includeing, requireing, or using a file. The error specifics should be available in the .error field.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.MethodError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.MethodError\",\n    \"category\": \"type\",\n    \"text\": \"MethodError(f, args)\\n\\nA method with the required type signature does not exist in the given generic function. Alternatively, there is no unique most-specific method.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.MissingException\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.MissingException\",\n    \"category\": \"type\",\n    \"text\": \"MissingException(msg)\\n\\nException thrown when a missing value is encountered in a situation where it is not supported. The error message, in the msg field may provide more specific details.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.OutOfMemoryError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.OutOfMemoryError\",\n    \"category\": \"type\",\n    \"text\": \"OutOfMemoryError()\\n\\nAn operation allocated too much memory for either the system or the garbage collector to handle properly.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.ReadOnlyMemoryError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.ReadOnlyMemoryError\",\n    \"category\": \"type\",\n    \"text\": \"ReadOnlyMemoryError()\\n\\nAn operation tried to write to memory that is read-only.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.OverflowError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.OverflowError\",\n    \"category\": \"type\",\n    \"text\": \"OverflowError(msg)\\n\\nThe result of an expression is too large for the specified type and will cause a wraparound.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.StackOverflowError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.StackOverflowError\",\n    \"category\": \"type\",\n    \"text\": \"StackOverflowError()\\n\\nThe function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.SystemError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.SystemError\",\n    \"category\": \"type\",\n    \"text\": \"SystemError(prefix::AbstractString, [errno::Int32])\\n\\nA system call failed with an error code (in the errno global variable).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.TypeError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.TypeError\",\n    \"category\": \"type\",\n    \"text\": \"TypeError(func::Symbol, context::AbstractString, expected::Type, got)\\n\\nA type assertion failure, or calling an intrinsic function with an incorrect argument type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.UndefKeywordError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.UndefKeywordError\",\n    \"category\": \"type\",\n    \"text\": \"UndefKeywordError(var::Symbol)\\n\\nThe required keyword argument var was not assigned in a function call.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.UndefRefError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.UndefRefError\",\n    \"category\": \"type\",\n    \"text\": \"UndefRefError()\\n\\nThe item or field is not defined for the given object.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.UndefVarError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.UndefVarError\",\n    \"category\": \"type\",\n    \"text\": \"UndefVarError(var::Symbol)\\n\\nA symbol in the current scope is not defined.\\n\\nExamples\\n\\njulia> a\\nERROR: UndefVarError: a not defined\\n\\njulia> a = 1;\\n\\njulia> a\\n1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.StringIndexError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.StringIndexError\",\n    \"category\": \"type\",\n    \"text\": \"StringIndexError(str, i)\\n\\nAn error occurred when trying to access str at index i that is not valid.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.InitError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.InitError\",\n    \"category\": \"type\",\n    \"text\": \"InitError(mod::Symbol, error)\\n\\nAn error occurred when running a module\\'s __init__ function. The actual error thrown is available in the .error field.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.retry\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.retry\",\n    \"category\": \"function\",\n    \"text\": \"retry(f::Function;  delays=ExponentialBackOff(), check=nothing) -> Function\\n\\nReturn an anonymous function that calls function f.  If an exception arises, f is repeatedly called again, each time check returns true, after waiting the number of seconds specified in delays.  check should input delays\\'s current state and the Exception.\\n\\nExamples\\n\\nretry(f, delays=fill(5.0, 3))\\nretry(f, delays=rand(5:10, 2))\\nretry(f, delays=Base.ExponentialBackOff(n=3, first_delay=5, max_delay=1000))\\nretry(http_get, check=(s,e)->e.status == \\\"503\\\")(url)\\nretry(read, check=(s,e)->isa(e, IOError))(io, 128; all=false)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.ExponentialBackOff\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.ExponentialBackOff\",\n    \"category\": \"type\",\n    \"text\": \"ExponentialBackOff(; n=1, first_delay=0.05, max_delay=10.0, factor=5.0, jitter=0.1)\\n\\nA Float64 iterator of length n whose elements exponentially increase at a rate in the interval factor * (1 \u00b1 jitter).  The first element is first_delay and all elements are clamped to max_delay.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Errors-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Errors\",\n    \"category\": \"section\",\n    \"text\": \"Base.error\\nCore.throw\\nBase.rethrow\\nBase.backtrace\\nBase.catch_backtrace\\nBase.@assert\\nBase.ArgumentError\\nBase.AssertionError\\nCore.BoundsError\\nBase.CompositeException\\nBase.DimensionMismatch\\nCore.DivideError\\nCore.DomainError\\nBase.EOFError\\nCore.ErrorException\\nCore.InexactError\\nCore.InterruptException\\nBase.KeyError\\nBase.LoadError\\nBase.MethodError\\nBase.MissingException\\nCore.OutOfMemoryError\\nCore.ReadOnlyMemoryError\\nCore.OverflowError\\nCore.StackOverflowError\\nBase.SystemError\\nCore.TypeError\\nCore.UndefKeywordError\\nCore.UndefRefError\\nCore.UndefVarError\\nBase.StringIndexError\\nBase.InitError\\nBase.retry\\nBase.ExponentialBackOff\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Timer-Tuple{Function,Real}\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Timer\",\n    \"category\": \"method\",\n    \"text\": \"Timer(callback::Function, delay; interval = 0)\\n\\nCreate a timer that wakes up tasks waiting for it (by calling wait on the timer object) and calls the function callback.\\n\\nWaiting tasks are woken and the function callback is called after an initial delay of delay seconds, and then repeating with the given interval in seconds. If interval is equal to 0, the timer is only triggered once. The function callback is called with a single argument, the timer itself. When the timer is closed (by close waiting tasks are woken with an error. Use isopen to check whether a timer is still active.\\n\\nExamples\\n\\nHere the first number is printed after a delay of two seconds, then the following numbers are printed quickly.\\n\\njulia> begin\\n           i = 0\\n           cb(timer) = (global i += 1; println(i))\\n           t = Timer(cb, 2, interval = 0.2)\\n           wait(t)\\n           sleep(0.5)\\n           close(t)\\n       end\\n1\\n2\\n3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Timer\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Timer\",\n    \"category\": \"type\",\n    \"text\": \"Timer(delay; interval = 0)\\n\\nCreate a timer that wakes up tasks waiting for it (by calling wait on the timer object).\\n\\nWaiting tasks are woken after an initial delay of delay seconds, and then repeating with the given interval in seconds. If interval is equal to 0, the timer is only triggered once. When the timer is closed (by close waiting tasks are woken with an error. Use isopen to check whether a timer is still active.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.AsyncCondition\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.AsyncCondition\",\n    \"category\": \"type\",\n    \"text\": \"AsyncCondition()\\n\\nCreate a async condition that wakes up tasks waiting for it (by calling wait on the object) when notified from C by a call to uv_async_send. Waiting tasks are woken with an error when the object is closed (by close. Use isopen to check whether it is still active.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.AsyncCondition-Tuple{Function}\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.AsyncCondition\",\n    \"category\": \"method\",\n    \"text\": \"AsyncCondition(callback::Function)\\n\\nCreate a async condition that calls the given callback function. The callback is passed one argument, the async condition object itself.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Events-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Events\",\n    \"category\": \"section\",\n    \"text\": \"Base.Timer(::Function, ::Real)\\nBase.Timer\\nBase.AsyncCondition\\nBase.AsyncCondition(::Function)\"\n},\n\n{\n    \"location\": \"base/base.html#Base.nameof-Tuple{Module}\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.nameof\",\n    \"category\": \"method\",\n    \"text\": \"nameof(m::Module) -> Symbol\\n\\nGet the name of a Module as a Symbol.\\n\\nExamples\\n\\njulia> nameof(Base.Broadcast)\\n:Broadcast\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.parentmodule\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.parentmodule\",\n    \"category\": \"function\",\n    \"text\": \"parentmodule(m::Module) -> Module\\n\\nGet a module\\'s enclosing Module. Main is its own parent.\\n\\nExamples\\n\\njulia> parentmodule(Main)\\nMain\\n\\njulia> parentmodule(Base.Broadcast)\\nBase\\n\\n\\n\\n\\n\\nparentmodule(t::DataType) -> Module\\n\\nDetermine the module containing the definition of a (potentially UnionAll-wrapped) DataType.\\n\\nExamples\\n\\njulia> module Foo\\n           struct Int end\\n       end\\nFoo\\n\\njulia> parentmodule(Int)\\nCore\\n\\njulia> parentmodule(Foo.Int)\\nFoo\\n\\n\\n\\n\\n\\nparentmodule(f::Function) -> Module\\n\\nDetermine the module containing the (first) definition of a generic function.\\n\\n\\n\\n\\n\\nparentmodule(f::Function, types) -> Module\\n\\nDetermine the module containing a given definition of a generic function.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.pathof-Tuple{Module}\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.pathof\",\n    \"category\": \"method\",\n    \"text\": \"pathof(m::Module)\\n\\nReturn the path of m.jl file that was used to import module m, or nothing if m was not imported from a package.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.moduleroot\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.moduleroot\",\n    \"category\": \"function\",\n    \"text\": \"moduleroot(m::Module) -> Module\\n\\nFind the root module of a given module. This is the first module in the chain of parent modules of m which is either a registered root module or which is its own parent module.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@__MODULE__\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@__MODULE__\",\n    \"category\": \"macro\",\n    \"text\": \"@__MODULE__ -> Module\\n\\nGet the Module of the toplevel eval, which is the Module code is currently being read from.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.fullname\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.fullname\",\n    \"category\": \"function\",\n    \"text\": \"fullname(m::Module)\\n\\nGet the fully-qualified name of a module as a tuple of symbols. For example,\\n\\nExamples\\n\\njulia> fullname(Base.Iterators)\\n(:Base, :Iterators)\\n\\njulia> fullname(Main)\\n(:Main,)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.names\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.names\",\n    \"category\": \"function\",\n    \"text\": \"names(x::Module; all::Bool = false, imported::Bool = false)\\n\\nGet an array of the names exported by a Module, excluding deprecated names. If all is true, then the list also includes non-exported names defined in the module, deprecated names, and compiler-generated names. If imported is true, then names explicitly imported from other modules are also included.\\n\\nAs a special case, all names defined in Main are considered \\\"exported\\\", since it is not idiomatic to explicitly export names from Main.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Core.nfields\",\n    \"page\": \"Essentials\",\n    \"title\": \"Core.nfields\",\n    \"category\": \"function\",\n    \"text\": \"nfields(x) -> Int\\n\\nGet the number of fields in the given object.\\n\\nExamples\\n\\njulia> a = 1//2;\\n\\njulia> nfields(a)\\n2\\n\\njulia> b = 1\\n1\\n\\njulia> nfields(b)\\n0\\n\\njulia> ex = ErrorException(\\\"I\\'ve done a bad thing\\\");\\n\\njulia> nfields(ex)\\n1\\n\\nIn these examples, a is a Rational, which has two fields. b is an Int, which is a primitive bitstype with no fields at all. ex is an ErrorException, which has one field.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.isconst\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.isconst\",\n    \"category\": \"function\",\n    \"text\": \"isconst(m::Module, s::Symbol) -> Bool\\n\\nDetermine whether a global is declared const in a given Module.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.nameof-Tuple{Function}\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.nameof\",\n    \"category\": \"method\",\n    \"text\": \"nameof(f::Function) -> Symbol\\n\\nGet the name of a generic Function as a symbol, or :anonymous.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.functionloc-Tuple{Any,Any}\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.functionloc\",\n    \"category\": \"method\",\n    \"text\": \"functionloc(f::Function, types)\\n\\nReturns a tuple (filename,line) giving the location of a generic Function definition.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.functionloc-Tuple{Method}\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.functionloc\",\n    \"category\": \"method\",\n    \"text\": \"functionloc(m::Method)\\n\\nReturns a tuple (filename,line) giving the location of a Method definition.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Reflection-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Reflection\",\n    \"category\": \"section\",\n    \"text\": \"Base.nameof(::Module)\\nBase.parentmodule\\nBase.pathof(::Module)\\nBase.moduleroot\\nBase.@__MODULE__\\nBase.fullname\\nBase.names\\nCore.nfields\\nBase.isconst\\nBase.nameof(::Function)\\nBase.functionloc(::Any, ::Any)\\nBase.functionloc(::Method)\"\n},\n\n{\n    \"location\": \"base/base.html#Base.GC.gc\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.GC.gc\",\n    \"category\": \"function\",\n    \"text\": \"GC.gc()\\n\\nPerform garbage collection.\\n\\nwarning: Warning\\nExcessive use will likely lead to poor performance.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.GC.enable\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.GC.enable\",\n    \"category\": \"function\",\n    \"text\": \"GC.enable(on::Bool)\\n\\nControl whether garbage collection is enabled using a boolean argument (true for enabled, false for disabled). Return previous GC state.\\n\\nwarning: Warning\\nDisabling garbage collection should be used only with caution, as it can cause memory use to grow without bound.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.GC.@preserve\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.GC.@preserve\",\n    \"category\": \"macro\",\n    \"text\": \"GC.@preserve x1 x2 ... xn expr\\n\\nTemporarily protect the given objects from being garbage collected, even if they would otherwise be unreferenced.\\n\\nThe last argument is the expression during which the object(s) will be preserved. The previous arguments are the objects to preserve.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Meta.lower\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Meta.lower\",\n    \"category\": \"function\",\n    \"text\": \"lower(m, x)\\n\\nTakes the expression x and returns an equivalent expression in lowered form for executing in module m. See also code_lowered.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Meta.@lower\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Meta.@lower\",\n    \"category\": \"macro\",\n    \"text\": \"@lower [m] x\\n\\nReturn lowered form of the expression x in module m. By default m is the module in which the macro is called. See also lower.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Meta.parse-Tuple{AbstractString,Int64}\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Meta.parse\",\n    \"category\": \"method\",\n    \"text\": \"parse(str, start; greedy=true, raise=true, depwarn=true)\\n\\nParse the expression string and return an expression (which could later be passed to eval for execution). start is the index of the first character to start parsing. If greedy is true (default), parse will try to consume as much input as it can; otherwise, it will stop as soon as it has parsed a valid expression. Incomplete but otherwise syntactically valid expressions will return Expr(:incomplete, \\\"(error message)\\\"). If raise is true (default), syntax errors other than incomplete expressions will raise an error. If raise is false, parse will return an expression that will raise an error upon evaluation. If depwarn is false, deprecation warnings will be suppressed.\\n\\njulia> Meta.parse(\\\"x = 3, y = 5\\\", 7)\\n(:(y = 5), 13)\\n\\njulia> Meta.parse(\\\"x = 3, y = 5\\\", 5)\\n(:((3, y) = 5), 13)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Meta.parse-Tuple{AbstractString}\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Meta.parse\",\n    \"category\": \"method\",\n    \"text\": \"parse(str; raise=true, depwarn=true)\\n\\nParse the expression string greedily, returning a single expression. An error is thrown if there are additional characters after the first expression. If raise is true (default), syntax errors will raise an error; otherwise, parse will return an expression that will raise an error upon evaluation.  If depwarn is false, deprecation warnings will be suppressed.\\n\\njulia> Meta.parse(\\\"x = 3\\\")\\n:(x = 3)\\n\\njulia> Meta.parse(\\\"x = \\\")\\n:($(Expr(:incomplete, \\\"incomplete: premature end of input\\\")))\\n\\njulia> Meta.parse(\\\"1.0.2\\\")\\nERROR: Base.Meta.ParseError(\\\"invalid numeric constant \\\\\\\"1.0.\\\\\\\"\\\")\\nStacktrace:\\n[...]\\n\\njulia> Meta.parse(\\\"1.0.2\\\"; raise = false)\\n:($(Expr(:error, \\\"invalid numeric constant \\\\\\\"1.0.\\\\\\\"\\\")))\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.Meta.ParseError\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.Meta.ParseError\",\n    \"category\": \"type\",\n    \"text\": \"ParseError(msg)\\n\\nThe expression passed to the parse function could not be interpreted as a valid Julia expression.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.macroexpand\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.macroexpand\",\n    \"category\": \"function\",\n    \"text\": \"macroexpand(m::Module, x; recursive=true)\\n\\nTake the expression x and return an equivalent expression with all macros removed (expanded) for executing in module m. The recursive keyword controls whether deeper levels of nested macros are also expanded. This is demonstrated in the example below:\\n\\njulia> module M\\n           macro m1()\\n               42\\n           end\\n           macro m2()\\n               :(@m1())\\n           end\\n       end\\nM\\n\\njulia> macroexpand(M, :(@m2()), recursive=true)\\n42\\n\\njulia> macroexpand(M, :(@m2()), recursive=false)\\n:(#= REPL[16]:6 =# M.@m1)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@macroexpand\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@macroexpand\",\n    \"category\": \"macro\",\n    \"text\": \"@macroexpand\\n\\nReturn equivalent expression with all macros removed (expanded).\\n\\nThere are differences between @macroexpand and macroexpand.\\n\\nWhile macroexpand takes a keyword argument recursive, @macroexpand\\n\\nis always recursive. For a non recursive macro version, see @macroexpand1.\\n\\nWhile macroexpand has an explicit module argument, @macroexpand always\\n\\nexpands with respect to the module in which it is called. This is best seen in the following example:\\n\\njulia> module M\\n           macro m()\\n               1\\n           end\\n           function f()\\n               (@macroexpand(@m),\\n                macroexpand(M, :(@m)),\\n                macroexpand(Main, :(@m))\\n               )\\n           end\\n       end\\nM\\n\\njulia> macro m()\\n           2\\n       end\\n@m (macro with 1 method)\\n\\njulia> M.f()\\n(1, 1, 2)\\n\\nWith @macroexpand the expression expands where @macroexpand appears in the code (module M in the example). With macroexpand the expression expands in the module given as the first argument.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.@macroexpand1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.@macroexpand1\",\n    \"category\": \"macro\",\n    \"text\": \"@macroexpand1\\n\\nNon recursive version of @macroexpand.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.code_lowered\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.code_lowered\",\n    \"category\": \"function\",\n    \"text\": \"code_lowered(f, types; generated = true)\\n\\nReturn an array of the lowered forms (IR) for the methods matching the given generic function and type signature.\\n\\nIf generated is false, the returned CodeInfo instances will correspond to fallback implementations. An error is thrown if no fallback implementation exists. If generated is true, these CodeInfo instances will correspond to the method bodies yielded by expanding the generators.\\n\\nNote that an error will be thrown if types are not leaf types when generated is true and the corresponding method is a @generated method.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.code_typed\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.code_typed\",\n    \"category\": \"function\",\n    \"text\": \"code_typed(f, types; optimize=true)\\n\\nReturns an array of type-inferred lowered form (IR) for the methods matching the given generic function and type signature. The keyword argument optimize controls whether additional optimizations, such as inlining, are also applied.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Base.precompile\",\n    \"page\": \"Essentials\",\n    \"title\": \"Base.precompile\",\n    \"category\": \"function\",\n    \"text\": \"precompile(f, args::Tuple{Vararg{Any}})\\n\\nCompile the given function f for the argument tuple (of types) args, but do not execute it.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/base.html#Internals-1\",\n    \"page\": \"Essentials\",\n    \"title\": \"Internals\",\n    \"category\": \"section\",\n    \"text\": \"Base.GC.gc\\nBase.GC.enable\\nBase.GC.@preserve\\nMeta.lower\\nMeta.@lower\\nMeta.parse(::AbstractString, ::Int)\\nMeta.parse(::AbstractString)\\nMeta.ParseError\\nBase.macroexpand\\nBase.@macroexpand\\nBase.@macroexpand1\\nBase.code_lowered\\nBase.code_typed\\nBase.precompile\"\n},\n\n{\n    \"location\": \"base/collections.html#\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Collections and Data Structures\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/collections.html#Collections-and-Data-Structures-1\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Collections and Data Structures\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.iterate\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.iterate\",\n    \"category\": \"function\",\n    \"text\": \"iterate(iter [, state]) -> Union{Nothing, Tuple{Any, Any}}\\n\\nAdvance the iterator to obtain the next element. If no elements remain, nothing should be returned. Otherwise, a 2-tuple of the next element and the new iteration state should be returned.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.IteratorSize\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.IteratorSize\",\n    \"category\": \"type\",\n    \"text\": \"IteratorSize(itertype::Type) -> IteratorSize\\n\\nGiven the type of an iterator, return one of the following values:\\n\\nSizeUnknown() if the length (number of elements) cannot be determined in advance.\\nHasLength() if there is a fixed, finite length.\\nHasShape{N}() if there is a known length plus a notion of multidimensional shape (as for an array).  In this case N should give the number of dimensions, and the axes function is valid  for the iterator.\\nIsInfinite() if the iterator yields values forever.\\n\\nThe default value (for iterators that do not define this function) is HasLength(). This means that most iterators are assumed to implement length.\\n\\nThis trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.\\n\\njulia> Base.IteratorSize(1:5)\\nBase.HasShape{1}()\\n\\njulia> Base.IteratorSize((2,3))\\nBase.HasLength()\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.IteratorEltype\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.IteratorEltype\",\n    \"category\": \"type\",\n    \"text\": \"IteratorEltype(itertype::Type) -> IteratorEltype\\n\\nGiven the type of an iterator, return one of the following values:\\n\\nEltypeUnknown() if the type of elements yielded by the iterator is not known in advance.\\nHasEltype() if the element type is known, and eltype would return a meaningful value.\\n\\nHasEltype() is the default, since iterators are assumed to implement eltype.\\n\\nThis trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.\\n\\njulia> Base.IteratorEltype(1:5)\\nBase.HasEltype()\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#lib-collections-iteration-1\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Iteration\",\n    \"category\": \"section\",\n    \"text\": \"Sequential iteration is implemented by the iterate function. The general for loop:for i in iter   # or  \\\"for i = iter\\\"\\n    # body\\nendis translated into:next = iterate(iter)\\nwhile next !== nothing\\n    (i, state) = next\\n    # body\\n    next = iterate(iter, state)\\nendThe state object may be anything, and should be chosen appropriately for each iterable type. See the manual section on the iteration interface for more details about defining a custom iterable type.Base.iterate\\nBase.IteratorSize\\nBase.IteratorEltypeFully implemented by:AbstractRange\\nUnitRange\\nTuple\\nNumber\\nAbstractArray\\nBitSet\\nIdDict\\nDict\\nWeakKeyDict\\nEachLine\\nAbstractString\\nSet\\nPair\\nNamedTuple\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.AbstractRange\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.AbstractRange\",\n    \"category\": \"type\",\n    \"text\": \"AbstractRange{T}\\n\\nSupertype for ranges with elements of type T. UnitRange and other types are subtypes of this.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.OrdinalRange\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.OrdinalRange\",\n    \"category\": \"type\",\n    \"text\": \"OrdinalRange{T, S} <: AbstractRange{T}\\n\\nSupertype for ordinal ranges with elements of type T with spacing(s) of type S. The steps should be always-exact multiples of oneunit, and T should be a \\\"discrete\\\" type, which cannot have values smaller than oneunit. For example, Integer or Date types would qualify, whereas Float64 would not (since this type can represent values smaller than oneunit(Float64). UnitRange, StepRange, and other types are subtypes of this.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.AbstractUnitRange\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.AbstractUnitRange\",\n    \"category\": \"type\",\n    \"text\": \"AbstractUnitRange{T} <: OrdinalRange{T, T}\\n\\nSupertype for ranges with a step size of oneunit(T) with elements of type T. UnitRange and other types are subtypes of this.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.StepRange\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.StepRange\",\n    \"category\": \"type\",\n    \"text\": \"StepRange{T, S} <: OrdinalRange{T, S}\\n\\nRanges with elements of type T with spacing of type S. The step between each element is constant, and the range is defined in terms of a start and stop of type T and a step of type S. Neither T nor S should be floating point types. The syntax a:b:c with b > 1 and a, b, and c all integers creates a StepRange.\\n\\nExamples\\n\\njulia> collect(StepRange(1, Int8(2), 10))\\n5-element Array{Int64,1}:\\n 1\\n 3\\n 5\\n 7\\n 9\\n\\njulia> typeof(StepRange(1, Int8(2), 10))\\nStepRange{Int64,Int8}\\n\\njulia> typeof(1:3:6)\\nStepRange{Int64,Int64}\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.UnitRange\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.UnitRange\",\n    \"category\": \"type\",\n    \"text\": \"UnitRange{T<:Real}\\n\\nA range parameterized by a start and stop of type T, filled with elements spaced by 1 from start until stop is exceeded. The syntax a:b with a and b both Integers creates a UnitRange.\\n\\nExamples\\n\\njulia> collect(UnitRange(2.3, 5.2))\\n3-element Array{Float64,1}:\\n 2.3\\n 3.3\\n 4.3\\n\\njulia> typeof(1:10)\\nUnitRange{Int64}\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.LinRange\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.LinRange\",\n    \"category\": \"type\",\n    \"text\": \"LinRange{T}\\n\\nA range with len linearly spaced elements between its start and stop. The size of the spacing is controlled by len, which must be an Int.\\n\\nExamples\\n\\njulia> LinRange(1.5, 5.5, 9)\\n9-element LinRange{Float64}:\\n 1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Constructors-and-Types-1\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Constructors and Types\",\n    \"category\": \"section\",\n    \"text\": \"Base.AbstractRange\\nBase.OrdinalRange\\nBase.AbstractUnitRange\\nBase.StepRange\\nBase.UnitRange\\nBase.LinRange\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.isempty\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.isempty\",\n    \"category\": \"function\",\n    \"text\": \"isempty(collection) -> Bool\\n\\nDetermine whether a collection is empty (has no elements).\\n\\nExamples\\n\\njulia> isempty([])\\ntrue\\n\\njulia> isempty([1 2 3])\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.empty!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.empty!\",\n    \"category\": \"function\",\n    \"text\": \"empty!(collection) -> collection\\n\\nRemove all elements from a collection.\\n\\nExamples\\n\\njulia> A = Dict(\\\"a\\\" => 1, \\\"b\\\" => 2)\\nDict{String,Int64} with 2 entries:\\n  \\\"b\\\" => 2\\n  \\\"a\\\" => 1\\n\\njulia> empty!(A);\\n\\njulia> A\\nDict{String,Int64} with 0 entries\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.length\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.length\",\n    \"category\": \"function\",\n    \"text\": \"length(collection) -> Integer\\n\\nReturn the number of elements in the collection.\\n\\nUse lastindex to get the last valid index of an indexable collection.\\n\\nExamples\\n\\njulia> length(1:5)\\n5\\n\\njulia> length([1, 2, 3, 4])\\n4\\n\\njulia> length([1 2; 3 4])\\n4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#General-Collections-1\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"General Collections\",\n    \"category\": \"section\",\n    \"text\": \"Base.isempty\\nBase.empty!\\nBase.lengthFully implemented by:AbstractRange\\nUnitRange\\nTuple\\nNumber\\nAbstractArray\\nBitSet\\nIdDict\\nDict\\nWeakKeyDict\\nAbstractString\\nSet\\nNamedTuple\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.in\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.in\",\n    \"category\": \"function\",\n    \"text\": \"in(item, collection) -> Bool\\n\u2208(item, collection) -> Bool\\n\u220b(collection, item) -> Bool\\n\\nDetermine whether an item is in the given collection, in the sense that it is == to one of the values generated by iterating over the collection. Returns a Bool value, except if item is missing or collection contains missing but not item, in which case missing is returned (three-valued logic, matching the behavior of any and ==).\\n\\nSome collections follow a slightly different definition. For example, Sets check whether the item isequal to one of the elements. Dicts look for key=>value pairs, and the key is compared using isequal. To test for the presence of a key in a dictionary, use haskey or k in keys(dict). For these collections, the result is always a Bool and never missing.\\n\\nExamples\\n\\njulia> a = 1:3:20\\n1:3:19\\n\\njulia> 4 in a\\ntrue\\n\\njulia> 5 in a\\nfalse\\n\\njulia> missing in [1, 2]\\nmissing\\n\\njulia> 1 in [2, missing]\\nmissing\\n\\njulia> 1 in [1, missing]\\ntrue\\n\\njulia> missing in Set([1, 2])\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.:\u2209\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.:\u2209\",\n    \"category\": \"function\",\n    \"text\": \"\u2209(item, collection) -> Bool\\n\u220c(collection, item) -> Bool\\n\\nNegation of \u2208 and \u220b, i.e. checks that item is not in collection.\\n\\nExamples\\n\\njulia> 1 \u2209 2:4\\ntrue\\n\\njulia> 1 \u2209 1:3\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.eltype\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.eltype\",\n    \"category\": \"function\",\n    \"text\": \"eltype(type)\\n\\nDetermine the type of the elements generated by iterating a collection of the given type. For dictionary types, this will be a Pair{KeyType,ValType}. The definition eltype(x) = eltype(typeof(x)) is provided for convenience so that instances can be passed instead of types. However the form that accepts a type argument should be defined for new types.\\n\\nExamples\\n\\njulia> eltype(fill(1f0, (2,2)))\\nFloat32\\n\\njulia> eltype(fill(0x1, (2,2)))\\nUInt8\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.indexin\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.indexin\",\n    \"category\": \"function\",\n    \"text\": \"indexin(a, b)\\n\\nReturn an array containing the first index in b for each value in a that is a member of b. The output array contains nothing wherever a is not a member of b.\\n\\nExamples\\n\\njulia> a = [\\'a\\', \\'b\\', \\'c\\', \\'b\\', \\'d\\', \\'a\\'];\\n\\njulia> b = [\\'a\\', \\'b\\', \\'c\\'];\\n\\njulia> indexin(a, b)\\n6-element Array{Union{Nothing, Int64},1}:\\n 1\\n 2\\n 3\\n 2\\n  nothing\\n 1\\n\\njulia> indexin(b, a)\\n3-element Array{Union{Nothing, Int64},1}:\\n 1\\n 2\\n 3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.unique\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.unique\",\n    \"category\": \"function\",\n    \"text\": \"unique(itr)\\n\\nReturn an array containing only the unique elements of collection itr, as determined by isequal, in the order that the first of each set of equivalent elements originally appears. The element type of the input is preserved.\\n\\nExamples\\n\\njulia> unique([1, 2, 6, 2])\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 6\\n\\njulia> unique(Real[1, 1.0, 2])\\n2-element Array{Real,1}:\\n 1\\n 2\\n\\n\\n\\n\\n\\nunique(f, itr)\\n\\nReturns an array containing one value from itr for each unique value produced by f applied to elements of itr.\\n\\nExamples\\n\\njulia> unique(x -> x^2, [1, -1, 3, -3, 4])\\n3-element Array{Int64,1}:\\n 1\\n 3\\n 4\\n\\n\\n\\n\\n\\nunique(A::AbstractArray; dims::Int)\\n\\nReturn unique regions of A along dimension dims.\\n\\nExamples\\n\\njulia> A = map(isodd, reshape(Vector(1:8), (2,2,2)))\\n2\u00d72\u00d72 Array{Bool,3}:\\n[:, :, 1] =\\n  true   true\\n false  false\\n\\n[:, :, 2] =\\n  true   true\\n false  false\\n\\njulia> unique(A)\\n2-element Array{Bool,1}:\\n  true\\n false\\n\\njulia> unique(A, dims=2)\\n2\u00d71\u00d72 Array{Bool,3}:\\n[:, :, 1] =\\n  true\\n false\\n\\n[:, :, 2] =\\n  true\\n false\\n\\njulia> unique(A, dims=3)\\n2\u00d72\u00d71 Array{Bool,3}:\\n[:, :, 1] =\\n  true   true\\n false  false\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.unique!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.unique!\",\n    \"category\": \"function\",\n    \"text\": \"unique!(A::AbstractVector)\\n\\nRemove duplicate items as determined by isequal, then return the modified A. unique! will return the elements of A in the order that they occur. If you do not care about the order of the returned data, then calling (sort!(A); unique!(A)) will be much more efficient as long as the elements of A can be sorted.\\n\\nExamples\\n\\njulia> unique!([1, 1, 1])\\n1-element Array{Int64,1}:\\n 1\\n\\njulia> A = [7, 3, 2, 3, 7, 5];\\n\\njulia> unique!(A)\\n4-element Array{Int64,1}:\\n 7\\n 3\\n 2\\n 5\\n\\njulia> B = [7, 6, 42, 6, 7, 42];\\n\\njulia> sort!(B);  # unique! is able to process sorted data much more efficiently.\\n\\njulia> unique!(B)\\n3-element Array{Int64,1}:\\n  6\\n  7\\n 42\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.allunique\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.allunique\",\n    \"category\": \"function\",\n    \"text\": \"allunique(itr) -> Bool\\n\\nReturn true if all values from itr are distinct when compared with isequal.\\n\\nExamples\\n\\njulia> a = [1; 2; 3]\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n\\njulia> allunique([a, a])\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.reduce-Tuple{Any,Any}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.reduce\",\n    \"category\": \"method\",\n    \"text\": \"reduce(op, itr; [init])\\n\\nReduce the given collection itr with the given binary operator op. If provided, the initial value init must be a neutral element for op that will be returned for empty collections. It is unspecified whether init is used for non-empty collections.\\n\\nFor empty collections, providing init will be necessary, except for some special cases (e.g. when op is one of +, *, max, min, &, |) when Julia can determine the neutral element of op.\\n\\nReductions for certain commonly-used operators may have special implementations, and should be used instead: maximum(itr), minimum(itr), sum(itr), prod(itr),  any(itr), all(itr).\\n\\nThe associativity of the reduction is implementation dependent. This means that you can\\'t use non-associative operations like - because it is undefined whether reduce(-,[1,2,3]) should be evaluated as (1-2)-3 or 1-(2-3). Use foldl or foldr instead for guaranteed left or right associativity.\\n\\nSome operations accumulate error. Parallelism will be easier if the reduction can be executed in groups. Future versions of Julia might change the algorithm. Note that the elements are not reordered if you use an ordered collection.\\n\\nExamples\\n\\njulia> reduce(*, [2; 3; 4])\\n24\\n\\njulia> reduce(*, [2; 3; 4]; init=-1)\\n-24\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.foldl-Tuple{Any,Any}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.foldl\",\n    \"category\": \"method\",\n    \"text\": \"foldl(op, itr; [init])\\n\\nLike reduce, but with guaranteed left associativity. If provided, the keyword argument init will be used exactly once. In general, it will be necessary to provide init to work with empty collections.\\n\\nExamples\\n\\njulia> foldl(=>, 1:4)\\n((1=>2)=>3) => 4\\n\\njulia> foldl(=>, 1:4; init=0)\\n(((0=>1)=>2)=>3) => 4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.foldr-Tuple{Any,Any}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.foldr\",\n    \"category\": \"method\",\n    \"text\": \"foldr(op, itr; [init])\\n\\nLike reduce, but with guaranteed right associativity. If provided, the keyword argument init will be used exactly once. In general, it will be necessary to provide init to work with empty collections.\\n\\nExamples\\n\\njulia> foldr(=>, 1:4)\\n1 => (2=>(3=>4))\\n\\njulia> foldr(=>, 1:4; init=0)\\n1 => (2=>(3=>(4=>0)))\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.maximum\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.maximum\",\n    \"category\": \"function\",\n    \"text\": \"maximum(itr)\\n\\nReturns the largest element in a collection.\\n\\nExamples\\n\\njulia> maximum(-20.5:10)\\n9.5\\n\\njulia> maximum([1,2,3])\\n3\\n\\n\\n\\n\\n\\nmaximum(A::AbstractArray; dims)\\n\\nCompute the maximum value of an array over the given dimensions. See also the max(a,b) function to take the maximum of two or more arguments, which can be applied elementwise to arrays via max.(a,b).\\n\\nExamples\\n\\njulia> A = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> maximum(A, dims=1)\\n1\u00d72 Array{Int64,2}:\\n 3  4\\n\\njulia> maximum(A, dims=2)\\n2\u00d71 Array{Int64,2}:\\n 2\\n 4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.maximum!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.maximum!\",\n    \"category\": \"function\",\n    \"text\": \"maximum!(r, A)\\n\\nCompute the maximum value of A over the singleton dimensions of r, and write results to r.\\n\\nExamples\\n\\njulia> A = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> maximum!([1; 1], A)\\n2-element Array{Int64,1}:\\n 2\\n 4\\n\\njulia> maximum!([1 1], A)\\n1\u00d72 Array{Int64,2}:\\n 3  4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.minimum\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.minimum\",\n    \"category\": \"function\",\n    \"text\": \"minimum(itr)\\n\\nReturns the smallest element in a collection.\\n\\nExamples\\n\\njulia> minimum(-20.5:10)\\n-20.5\\n\\njulia> minimum([1,2,3])\\n1\\n\\n\\n\\n\\n\\nminimum(A::AbstractArray; dims)\\n\\nCompute the minimum value of an array over the given dimensions. See also the min(a,b) function to take the minimum of two or more arguments, which can be applied elementwise to arrays via min.(a,b).\\n\\nExamples\\n\\njulia> A = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> minimum(A, dims=1)\\n1\u00d72 Array{Int64,2}:\\n 1  2\\n\\njulia> minimum(A, dims=2)\\n2\u00d71 Array{Int64,2}:\\n 1\\n 3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.minimum!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.minimum!\",\n    \"category\": \"function\",\n    \"text\": \"minimum!(r, A)\\n\\nCompute the minimum value of A over the singleton dimensions of r, and write results to r.\\n\\nExamples\\n\\njulia> A = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> minimum!([1; 1], A)\\n2-element Array{Int64,1}:\\n 1\\n 3\\n\\njulia> minimum!([1 1], A)\\n1\u00d72 Array{Int64,2}:\\n 1  2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.extrema\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.extrema\",\n    \"category\": \"function\",\n    \"text\": \"extrema(itr) -> Tuple\\n\\nCompute both the minimum and maximum element in a single pass, and return them as a 2-tuple.\\n\\nExamples\\n\\njulia> extrema(2:10)\\n(2, 10)\\n\\njulia> extrema([9,pi,4.5])\\n(3.141592653589793, 9.0)\\n\\n\\n\\n\\n\\nextrema(A::AbstractArray; dims) -> Array{Tuple}\\n\\nCompute the minimum and maximum elements of an array over the given dimensions.\\n\\nExamples\\n\\njulia> A = reshape(Vector(1:2:16), (2,2,2))\\n2\u00d72\u00d72 Array{Int64,3}:\\n[:, :, 1] =\\n 1  5\\n 3  7\\n\\n[:, :, 2] =\\n  9  13\\n 11  15\\n\\njulia> extrema(A, dims = (1,2))\\n1\u00d71\u00d72 Array{Tuple{Int64,Int64},3}:\\n[:, :, 1] =\\n (1, 7)\\n\\n[:, :, 2] =\\n (9, 15)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.argmax\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.argmax\",\n    \"category\": \"function\",\n    \"text\": \"argmax(itr) -> Integer\\n\\nReturn the index of the maximum element in a collection. If there are multiple maximal elements, then the first one will be returned.\\n\\nThe collection must not be empty.\\n\\nExamples\\n\\njulia> argmax([8,0.1,-9,pi])\\n1\\n\\njulia> argmax([1,7,7,6])\\n2\\n\\njulia> argmax([1,7,7,NaN])\\n4\\n\\n\\n\\n\\n\\nargmax(A; dims) -> indices\\n\\nFor an array input, return the indices of the maximum elements over the given dimensions. NaN is treated as greater than all other values.\\n\\nExamples\\n\\njulia> A = [1.0 2; 3 4]\\n2\u00d72 Array{Float64,2}:\\n 1.0  2.0\\n 3.0  4.0\\n\\njulia> argmax(A, dims=1)\\n1\u00d72 Array{CartesianIndex{2},2}:\\n CartesianIndex(2, 1)  CartesianIndex(2, 2)\\n\\njulia> argmax(A, dims=2)\\n2\u00d71 Array{CartesianIndex{2},2}:\\n CartesianIndex(1, 2)\\n CartesianIndex(2, 2)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.argmin\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.argmin\",\n    \"category\": \"function\",\n    \"text\": \"argmin(itr) -> Integer\\n\\nReturn the index of the minimum element in a collection. If there are multiple minimal elements, then the first one will be returned.\\n\\nThe collection must not be empty.\\n\\nExamples\\n\\njulia> argmin([8,0.1,-9,pi])\\n3\\n\\njulia> argmin([7,1,1,6])\\n2\\n\\njulia> argmin([7,1,1,NaN])\\n4\\n\\n\\n\\n\\n\\nargmin(A; dims) -> indices\\n\\nFor an array input, return the indices of the minimum elements over the given dimensions. NaN is treated as less than all other values.\\n\\nExamples\\n\\njulia> A = [1.0 2; 3 4]\\n2\u00d72 Array{Float64,2}:\\n 1.0  2.0\\n 3.0  4.0\\n\\njulia> argmin(A, dims=1)\\n1\u00d72 Array{CartesianIndex{2},2}:\\n CartesianIndex(1, 1)  CartesianIndex(1, 2)\\n\\njulia> argmin(A, dims=2)\\n2\u00d71 Array{CartesianIndex{2},2}:\\n CartesianIndex(1, 1)\\n CartesianIndex(2, 1)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.findmax\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.findmax\",\n    \"category\": \"function\",\n    \"text\": \"findmax(itr) -> (x, index)\\n\\nReturn the maximum element of the collection itr and its index. If there are multiple maximal elements, then the first one will be returned. If any data element is NaN, this element is returned. The result is in line with max.\\n\\nThe collection must not be empty.\\n\\nExamples\\n\\njulia> findmax([8,0.1,-9,pi])\\n(8.0, 1)\\n\\njulia> findmax([1,7,7,6])\\n(7, 2)\\n\\njulia> findmax([1,7,7,NaN])\\n(NaN, 4)\\n\\n\\n\\n\\n\\nfindmax(A; dims) -> (maxval, index)\\n\\nFor an array input, returns the value and index of the maximum over the given dimensions. NaN is treated as greater than all other values.\\n\\nExamples\\n\\njulia> A = [1.0 2; 3 4]\\n2\u00d72 Array{Float64,2}:\\n 1.0  2.0\\n 3.0  4.0\\n\\njulia> findmax(A, dims=1)\\n([3.0 4.0], CartesianIndex{2}[CartesianIndex(2, 1) CartesianIndex(2, 2)])\\n\\njulia> findmax(A, dims=2)\\n([2.0; 4.0], CartesianIndex{2}[CartesianIndex(1, 2); CartesianIndex(2, 2)])\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.findmin\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.findmin\",\n    \"category\": \"function\",\n    \"text\": \"findmin(itr) -> (x, index)\\n\\nReturn the minimum element of the collection itr and its index. If there are multiple minimal elements, then the first one will be returned. If any data element is NaN, this element is returned. The result is in line with min.\\n\\nThe collection must not be empty.\\n\\nExamples\\n\\njulia> findmin([8,0.1,-9,pi])\\n(-9.0, 3)\\n\\njulia> findmin([7,1,1,6])\\n(1, 2)\\n\\njulia> findmin([7,1,1,NaN])\\n(NaN, 4)\\n\\n\\n\\n\\n\\nfindmin(A; dims) -> (minval, index)\\n\\nFor an array input, returns the value and index of the minimum over the given dimensions. NaN is treated as less than all other values.\\n\\nExamples\\n\\njulia> A = [1.0 2; 3 4]\\n2\u00d72 Array{Float64,2}:\\n 1.0  2.0\\n 3.0  4.0\\n\\njulia> findmin(A, dims=1)\\n([1.0 2.0], CartesianIndex{2}[CartesianIndex(1, 1) CartesianIndex(1, 2)])\\n\\njulia> findmin(A, dims=2)\\n([1.0; 3.0], CartesianIndex{2}[CartesianIndex(1, 1); CartesianIndex(2, 1)])\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.findmax!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.findmax!\",\n    \"category\": \"function\",\n    \"text\": \"findmax!(rval, rind, A) -> (maxval, index)\\n\\nFind the maximum of A and the corresponding linear index along singleton dimensions of rval and rind, and store the results in rval and rind. NaN is treated as greater than all other values.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.findmin!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.findmin!\",\n    \"category\": \"function\",\n    \"text\": \"findmin!(rval, rind, A) -> (minval, index)\\n\\nFind the minimum of A and the corresponding linear index along singleton dimensions of rval and rind, and store the results in rval and rind. NaN is treated as less than all other values.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.sum\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.sum\",\n    \"category\": \"function\",\n    \"text\": \"sum(f, itr)\\n\\nSum the results of calling function f on each element of itr.\\n\\nThe return type is Int for signed integers of less than system word size, and UInt for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.\\n\\nExamples\\n\\njulia> sum(abs2, [2; 3; 4])\\n29\\n\\nNote the important difference between sum(A) and reduce(+, A) for arrays with small integer eltype:\\n\\njulia> sum(Int8[100, 28])\\n128\\n\\njulia> reduce(+, Int8[100, 28])\\n-128\\n\\nIn the former case, the integers are widened to system word size and therefore the result is 128. In the latter case, no such widening happens and integer overflow results in -128.\\n\\n\\n\\n\\n\\nsum(itr)\\n\\nReturns the sum of all elements in a collection.\\n\\nThe return type is Int for signed integers of less than system word size, and UInt for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.\\n\\nExamples\\n\\njulia> sum(1:20)\\n210\\n\\n\\n\\n\\n\\nsum(A::AbstractArray; dims)\\n\\nSum elements of an array over the given dimensions.\\n\\nExamples\\n\\njulia> A = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> sum(A, dims=1)\\n1\u00d72 Array{Int64,2}:\\n 4  6\\n\\njulia> sum(A, dims=2)\\n2\u00d71 Array{Int64,2}:\\n 3\\n 7\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.sum!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.sum!\",\n    \"category\": \"function\",\n    \"text\": \"sum!(r, A)\\n\\nSum elements of A over the singleton dimensions of r, and write results to r.\\n\\nExamples\\n\\njulia> A = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> sum!([1; 1], A)\\n2-element Array{Int64,1}:\\n 3\\n 7\\n\\njulia> sum!([1 1], A)\\n1\u00d72 Array{Int64,2}:\\n 4  6\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.prod\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.prod\",\n    \"category\": \"function\",\n    \"text\": \"prod(f, itr)\\n\\nReturns the product of f applied to each element of itr.\\n\\nThe return type is Int for signed integers of less than system word size, and UInt for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.\\n\\nExamples\\n\\njulia> prod(abs2, [2; 3; 4])\\n576\\n\\n\\n\\n\\n\\nprod(itr)\\n\\nReturns the product of all elements of a collection.\\n\\nThe return type is Int for signed integers of less than system word size, and UInt for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.\\n\\nExamples\\n\\njulia> prod(1:20)\\n2432902008176640000\\n\\n\\n\\n\\n\\nprod(A::AbstractArray; dims)\\n\\nMultiply elements of an array over the given dimensions.\\n\\nExamples\\n\\njulia> A = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> prod(A, dims=1)\\n1\u00d72 Array{Int64,2}:\\n 3  8\\n\\njulia> prod(A, dims=2)\\n2\u00d71 Array{Int64,2}:\\n  2\\n 12\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.prod!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.prod!\",\n    \"category\": \"function\",\n    \"text\": \"prod!(r, A)\\n\\nMultiply elements of A over the singleton dimensions of r, and write results to r.\\n\\nExamples\\n\\njulia> A = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> prod!([1; 1], A)\\n2-element Array{Int64,1}:\\n  2\\n 12\\n\\njulia> prod!([1 1], A)\\n1\u00d72 Array{Int64,2}:\\n 3  8\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.any-Tuple{Any}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.any\",\n    \"category\": \"method\",\n    \"text\": \"any(itr) -> Bool\\n\\nTest whether any elements of a boolean collection are true, returning true as soon as the first true value in itr is encountered (short-circuiting).\\n\\nIf the input contains missing values, return missing if all non-missing values are false (or equivalently, if the input contains no true value), following three-valued logic.\\n\\nExamples\\n\\njulia> a = [true,false,false,true]\\n4-element Array{Bool,1}:\\n  true\\n false\\n false\\n  true\\n\\njulia> any(a)\\ntrue\\n\\njulia> any((println(i); v) for (i, v) in enumerate(a))\\n1\\ntrue\\n\\njulia> any([missing, true])\\ntrue\\n\\njulia> any([false, missing])\\nmissing\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.any-Tuple{AbstractArray,Any}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.any\",\n    \"category\": \"method\",\n    \"text\": \"any(p, itr) -> Bool\\n\\nDetermine whether predicate p returns true for any elements of itr, returning true as soon as the first item in itr for which p returns true is encountered (short-circuiting).\\n\\nIf the input contains missing values, return missing if all non-missing values are false (or equivalently, if the input contains no true value), following three-valued logic.\\n\\nExamples\\n\\njulia> any(i->(4<=i<=6), [3,5,7])\\ntrue\\n\\njulia> any(i -> (println(i); i > 3), 1:10)\\n1\\n2\\n3\\n4\\ntrue\\n\\njulia> any(i -> i > 0, [1, missing])\\ntrue\\n\\njulia> any(i -> i > 0, [-1, missing])\\nmissing\\n\\njulia> any(i -> i > 0, [-1, 0])\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.any!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.any!\",\n    \"category\": \"function\",\n    \"text\": \"any!(r, A)\\n\\nTest whether any values in A along the singleton dimensions of r are true, and write results to r.\\n\\nExamples\\n\\njulia> A = [true false; true false]\\n2\u00d72 Array{Bool,2}:\\n true  false\\n true  false\\n\\njulia> any!([1; 1], A)\\n2-element Array{Int64,1}:\\n 1\\n 1\\n\\njulia> any!([1 1], A)\\n1\u00d72 Array{Int64,2}:\\n 1  0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.all-Tuple{Any}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.all\",\n    \"category\": \"method\",\n    \"text\": \"all(itr) -> Bool\\n\\nTest whether all elements of a boolean collection are true, returning false as soon as the first false value in itr is encountered (short-circuiting).\\n\\nIf the input contains missing values, return missing if all non-missing values are true (or equivalently, if the input contains no false value), following three-valued logic.\\n\\nExamples\\n\\njulia> a = [true,false,false,true]\\n4-element Array{Bool,1}:\\n  true\\n false\\n false\\n  true\\n\\njulia> all(a)\\nfalse\\n\\njulia> all((println(i); v) for (i, v) in enumerate(a))\\n1\\n2\\nfalse\\n\\njulia> all([missing, false])\\nfalse\\n\\njulia> all([true, missing])\\nmissing\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.all-Tuple{AbstractArray,Any}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.all\",\n    \"category\": \"method\",\n    \"text\": \"all(p, itr) -> Bool\\n\\nDetermine whether predicate p returns true for all elements of itr, returning false as soon as the first item in itr for which p returns false is encountered (short-circuiting).\\n\\nIf the input contains missing values, return missing if all non-missing values are true (or equivalently, if the input contains no false value), following three-valued logic.\\n\\nExamples\\n\\njulia> all(i->(4<=i<=6), [4,5,6])\\ntrue\\n\\njulia> all(i -> (println(i); i < 3), 1:10)\\n1\\n2\\n3\\nfalse\\n\\njulia> all(i -> i > 0, [1, missing])\\nmissing\\n\\njulia> all(i -> i > 0, [-1, missing])\\nfalse\\n\\njulia> all(i -> i > 0, [1, 2])\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.all!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.all!\",\n    \"category\": \"function\",\n    \"text\": \"all!(r, A)\\n\\nTest whether all values in A along the singleton dimensions of r are true, and write results to r.\\n\\nExamples\\n\\njulia> A = [true false; true false]\\n2\u00d72 Array{Bool,2}:\\n true  false\\n true  false\\n\\njulia> all!([1; 1], A)\\n2-element Array{Int64,1}:\\n 0\\n 0\\n\\njulia> all!([1 1], A)\\n1\u00d72 Array{Int64,2}:\\n 1  0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.count\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.count\",\n    \"category\": \"function\",\n    \"text\": \"count(p, itr) -> Integer\\ncount(itr) -> Integer\\n\\nCount the number of elements in itr for which predicate p returns true. If p is omitted, counts the number of true elements in itr (which should be a collection of boolean values).\\n\\nExamples\\n\\njulia> count(i->(4<=i<=6), [2,3,4,5,6])\\n3\\n\\njulia> count([true, false, true, true])\\n3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.any-Tuple{Any,Any}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.any\",\n    \"category\": \"method\",\n    \"text\": \"any(p, itr) -> Bool\\n\\nDetermine whether predicate p returns true for any elements of itr, returning true as soon as the first item in itr for which p returns true is encountered (short-circuiting).\\n\\nIf the input contains missing values, return missing if all non-missing values are false (or equivalently, if the input contains no true value), following three-valued logic.\\n\\nExamples\\n\\njulia> any(i->(4<=i<=6), [3,5,7])\\ntrue\\n\\njulia> any(i -> (println(i); i > 3), 1:10)\\n1\\n2\\n3\\n4\\ntrue\\n\\njulia> any(i -> i > 0, [1, missing])\\ntrue\\n\\njulia> any(i -> i > 0, [-1, missing])\\nmissing\\n\\njulia> any(i -> i > 0, [-1, 0])\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.all-Tuple{Any,Any}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.all\",\n    \"category\": \"method\",\n    \"text\": \"all(p, itr) -> Bool\\n\\nDetermine whether predicate p returns true for all elements of itr, returning false as soon as the first item in itr for which p returns false is encountered (short-circuiting).\\n\\nIf the input contains missing values, return missing if all non-missing values are true (or equivalently, if the input contains no false value), following three-valued logic.\\n\\nExamples\\n\\njulia> all(i->(4<=i<=6), [4,5,6])\\ntrue\\n\\njulia> all(i -> (println(i); i < 3), 1:10)\\n1\\n2\\n3\\nfalse\\n\\njulia> all(i -> i > 0, [1, missing])\\nmissing\\n\\njulia> all(i -> i > 0, [-1, missing])\\nfalse\\n\\njulia> all(i -> i > 0, [1, 2])\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.foreach\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.foreach\",\n    \"category\": \"function\",\n    \"text\": \"foreach(f, c...) -> Nothing\\n\\nCall function f on each element of iterable c. For multiple iterable arguments, f is called elementwise. foreach should be used instead of map when the results of f are not needed, for example in foreach(println, array).\\n\\nExamples\\n\\njulia> a = 1:3:7;\\n\\njulia> foreach(x -> println(x^2), a)\\n1\\n16\\n49\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.map\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.map\",\n    \"category\": \"function\",\n    \"text\": \"map(f, c...) -> collection\\n\\nTransform collection c by applying f to each element. For multiple collection arguments, apply f elementwise.\\n\\nSee also: mapslices\\n\\nExamples\\n\\njulia> map(x -> x * 2, [1, 2, 3])\\n3-element Array{Int64,1}:\\n 2\\n 4\\n 6\\n\\njulia> map(+, [1, 2, 3], [10, 20, 30])\\n3-element Array{Int64,1}:\\n 11\\n 22\\n 33\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.map!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.map!\",\n    \"category\": \"function\",\n    \"text\": \"map!(function, destination, collection...)\\n\\nLike map, but stores the result in destination rather than a new collection. destination must be at least as large as the first collection.\\n\\nExamples\\n\\njulia> x = zeros(3);\\n\\njulia> map!(x -> x * 2, x, [1, 2, 3]);\\n\\njulia> x\\n3-element Array{Float64,1}:\\n 2.0\\n 4.0\\n 6.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.mapreduce-Tuple{Any,Any,Any}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.mapreduce\",\n    \"category\": \"method\",\n    \"text\": \"mapreduce(f, op, itr; [init])\\n\\nApply function f to each element in itr, and then reduce the result using the binary function op. If provided, init must be a neutral element for op that will be returne for empty collections. It is unspecified whether init is used for non-empty collections. In general, it will be necessary to provide init to work with empty collections.\\n\\nmapreduce is functionally equivalent to calling reduce(op, map(f, itr); init=init), but will in general execute faster since no intermediate collection needs to be created. See documentation for reduce and map.\\n\\nExamples\\n\\njulia> mapreduce(x->x^2, +, [1:3;]) # == 1 + 4 + 9\\n14\\n\\nThe associativity of the reduction is implementation-dependent. Additionally, some implementations may reuse the return value of f for elements that appear multiple times in itr. Use mapfoldl or mapfoldr instead for guaranteed left or right associativity and invocation of f for every value.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.mapfoldl-Tuple{Any,Any,Any}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.mapfoldl\",\n    \"category\": \"method\",\n    \"text\": \"mapfoldl(f, op, itr; [init])\\n\\nLike mapreduce, but with guaranteed left associativity, as in foldl. If provided, the keyword argument init will be used exactly once. In general, it will be necessary to provide init to work with empty collections.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.mapfoldr-Tuple{Any,Any,Any}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.mapfoldr\",\n    \"category\": \"method\",\n    \"text\": \"mapfoldr(f, op, itr; [init])\\n\\nLike mapreduce, but with guaranteed right associativity, as in foldr. If provided, the keyword argument init will be used exactly once. In general, it will be necessary to provide init to work with empty collections.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.first\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.first\",\n    \"category\": \"function\",\n    \"text\": \"first(coll)\\n\\nGet the first element of an iterable collection. Return the start point of an AbstractRange even if it is empty.\\n\\nExamples\\n\\njulia> first(2:2:10)\\n2\\n\\njulia> first([1; 2; 3; 4])\\n1\\n\\n\\n\\n\\n\\nfirst(s::AbstractString, n::Integer)\\n\\nGet a string consisting of the first n characters of s.\\n\\njulia> first(\\\"\u2200\u03f5\u22600: \u03f5\u00b2>0\\\", 0)\\n\\\"\\\"\\n\\njulia> first(\\\"\u2200\u03f5\u22600: \u03f5\u00b2>0\\\", 1)\\n\\\"\u2200\\\"\\n\\njulia> first(\\\"\u2200\u03f5\u22600: \u03f5\u00b2>0\\\", 3)\\n\\\"\u2200\u03f5\u2260\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.last\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.last\",\n    \"category\": \"function\",\n    \"text\": \"last(coll)\\n\\nGet the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling lastindex to get the last index. Return the end point of an AbstractRange even if it is empty.\\n\\nExamples\\n\\njulia> last(1:2:10)\\n9\\n\\njulia> last([1; 2; 3; 4])\\n4\\n\\n\\n\\n\\n\\nlast(s::AbstractString, n::Integer)\\n\\nGet a string consisting of the last n characters of s.\\n\\njulia> last(\\\"\u2200\u03f5\u22600: \u03f5\u00b2>0\\\", 0)\\n\\\"\\\"\\n\\njulia> last(\\\"\u2200\u03f5\u22600: \u03f5\u00b2>0\\\", 1)\\n\\\"0\\\"\\n\\njulia> last(\\\"\u2200\u03f5\u22600: \u03f5\u00b2>0\\\", 3)\\n\\\"\u00b2>0\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.step\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.step\",\n    \"category\": \"function\",\n    \"text\": \"step(r)\\n\\nGet the step size of an AbstractRange object.\\n\\nExamples\\n\\njulia> step(1:10)\\n1\\n\\njulia> step(1:2:10)\\n2\\n\\njulia> step(2.5:0.3:10.9)\\n0.3\\n\\njulia> step(range(2.5, stop=10.9, length=85))\\n0.1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.collect-Tuple{Any}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.collect\",\n    \"category\": \"method\",\n    \"text\": \"collect(collection)\\n\\nReturn an Array of all items in a collection or iterator. For dictionaries, returns Pair{KeyType, ValType}. If the argument is array-like or is an iterator with the HasShape trait, the result will have the same shape and number of dimensions as the argument.\\n\\nExamples\\n\\njulia> collect(1:2:13)\\n7-element Array{Int64,1}:\\n  1\\n  3\\n  5\\n  7\\n  9\\n 11\\n 13\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.collect-Tuple{Type,Any}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.collect\",\n    \"category\": \"method\",\n    \"text\": \"collect(element_type, collection)\\n\\nReturn an Array with the given element type of all items in a collection or iterable. The result has the same shape and number of dimensions as collection.\\n\\nExamples\\n\\njulia> collect(Float64, 1:2:5)\\n3-element Array{Float64,1}:\\n 1.0\\n 3.0\\n 5.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.filter\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.filter\",\n    \"category\": \"function\",\n    \"text\": \"filter(f, a::AbstractArray)\\n\\nReturn a copy of a, removing elements for which f is false. The function f is passed one argument.\\n\\nExamples\\n\\njulia> a = 1:10\\n1:10\\n\\njulia> filter(isodd, a)\\n5-element Array{Int64,1}:\\n 1\\n 3\\n 5\\n 7\\n 9\\n\\n\\n\\n\\n\\nfilter(f, d::AbstractDict)\\n\\nReturn a copy of d, removing elements for which f is false. The function f is passed key=>value pairs.\\n\\nExamples\\n\\njulia> d = Dict(1=>\\\"a\\\", 2=>\\\"b\\\")\\nDict{Int64,String} with 2 entries:\\n  2 => \\\"b\\\"\\n  1 => \\\"a\\\"\\n\\njulia> filter(p->isodd(p.first), d)\\nDict{Int64,String} with 1 entry:\\n  1 => \\\"a\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.filter!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.filter!\",\n    \"category\": \"function\",\n    \"text\": \"filter!(f, a::AbstractVector)\\n\\nUpdate a, removing elements for which f is false. The function f is passed one argument.\\n\\nExamples\\n\\njulia> filter!(isodd, Vector(1:10))\\n5-element Array{Int64,1}:\\n 1\\n 3\\n 5\\n 7\\n 9\\n\\n\\n\\n\\n\\nfilter!(f, d::AbstractDict)\\n\\nUpdate d, removing elements for which f is false. The function f is passed key=>value pairs.\\n\\nExample\\n\\njulia> d = Dict(1=>\\\"a\\\", 2=>\\\"b\\\", 3=>\\\"c\\\")\\nDict{Int64,String} with 3 entries:\\n  2 => \\\"b\\\"\\n  3 => \\\"c\\\"\\n  1 => \\\"a\\\"\\n\\njulia> filter!(p->isodd(p.first), d)\\nDict{Int64,String} with 2 entries:\\n  3 => \\\"c\\\"\\n  1 => \\\"a\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.replace-Tuple{Any,Vararg{Pair,N} where N}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.replace\",\n    \"category\": \"method\",\n    \"text\": \"replace(A, old_new::Pair...; [count::Integer])\\n\\nReturn a copy of collection A where, for each pair old=>new in old_new, all occurrences of old are replaced by new. Equality is determined using isequal. If count is specified, then replace at most count occurrences in total.\\n\\nThe element type of the result is chosen using promotion (see promote_type) based on the element type of A and on the types of the new values in pairs. If count is omitted and the element type of A is a Union, the element type of the result will not include singleton types which are replaced with values of a different type: for example, Union{T,Missing} will become T if missing is replaced.\\n\\nSee also replace!.\\n\\nExamples\\n\\njulia> replace([1, 2, 1, 3], 1=>0, 2=>4, count=2)\\n4-element Array{Int64,1}:\\n 0\\n 4\\n 1\\n 3\\n\\njulia> replace([1, missing], missing=>0)\\n2-element Array{Int64,1}:\\n 1\\n 0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.replace-Tuple{Union{Function, Type},Any}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.replace\",\n    \"category\": \"method\",\n    \"text\": \"replace(new::Function, A; [count::Integer])\\n\\nReturn a copy of A where each value x in A is replaced by new(x) If count is specified, then replace at most count values in total (replacements being defined as new(x) !== x).\\n\\nExamples\\n\\njulia> replace(x -> isodd(x) ? 2x : x, [1, 2, 3, 4])\\n4-element Array{Int64,1}:\\n 2\\n 2\\n 6\\n 4\\n\\njulia> replace(Dict(1=>2, 3=>4)) do kv\\n           first(kv) < 3 ? first(kv)=>3 : kv\\n       end\\nDict{Int64,Int64} with 2 entries:\\n  3 => 4\\n  1 => 3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.replace!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.replace!\",\n    \"category\": \"function\",\n    \"text\": \"replace!(A, old_new::Pair...; [count::Integer])\\n\\nFor each pair old=>new in old_new, replace all occurrences of old in collection A by new. Equality is determined using isequal. If count is specified, then replace at most count occurrences in total. See also replace.\\n\\nExamples\\n\\njulia> replace!([1, 2, 1, 3], 1=>0, 2=>4, count=2)\\n4-element Array{Int64,1}:\\n 0\\n 4\\n 1\\n 3\\n\\njulia> replace!(Set([1, 2, 3]), 1=>0)\\nSet([0, 2, 3])\\n\\n\\n\\n\\n\\nreplace!(new::Function, A; [count::Integer])\\n\\nReplace each element x in collection A by new(x). If count is specified, then replace at most count values in total (replacements being defined as new(x) !== x).\\n\\nExamples\\n\\njulia> replace!(x -> isodd(x) ? 2x : x, [1, 2, 3, 4])\\n4-element Array{Int64,1}:\\n 2\\n 2\\n 6\\n 4\\n\\njulia> replace!(Dict(1=>2, 3=>4)) do kv\\n           first(kv) < 3 ? first(kv)=>3 : kv\\n       end\\nDict{Int64,Int64} with 2 entries:\\n  3 => 4\\n  1 => 3\\n\\njulia> replace!(x->2x, Set([3, 6]))\\nSet([6, 12])\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Iterable-Collections-1\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Iterable Collections\",\n    \"category\": \"section\",\n    \"text\": \"Base.in\\nBase.:\u2209\\nBase.eltype\\nBase.indexin\\nBase.unique\\nBase.unique!\\nBase.allunique\\nBase.reduce(::Any, ::Any)\\nBase.foldl(::Any, ::Any)\\nBase.foldr(::Any, ::Any)\\nBase.maximum\\nBase.maximum!\\nBase.minimum\\nBase.minimum!\\nBase.extrema\\nBase.argmax\\nBase.argmin\\nBase.findmax\\nBase.findmin\\nBase.findmax!\\nBase.findmin!\\nBase.sum\\nBase.sum!\\nBase.prod\\nBase.prod!\\nBase.any(::Any)\\nBase.any(::AbstractArray, ::Any)\\nBase.any!\\nBase.all(::Any)\\nBase.all(::AbstractArray, ::Any)\\nBase.all!\\nBase.count\\nBase.any(::Any, ::Any)\\nBase.all(::Any, ::Any)\\nBase.foreach\\nBase.map\\nBase.map!\\nBase.mapreduce(::Any, ::Any, ::Any)\\nBase.mapfoldl(::Any, ::Any, ::Any)\\nBase.mapfoldr(::Any, ::Any, ::Any)\\nBase.first\\nBase.last\\nBase.step\\nBase.collect(::Any)\\nBase.collect(::Type, ::Any)\\nBase.filter\\nBase.filter!\\nBase.replace(::Any, ::Pair...)\\nBase.replace(::Base.Callable, ::Any)\\nBase.replace!\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.getindex\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.getindex\",\n    \"category\": \"function\",\n    \"text\": \"getindex(collection, key...)\\n\\nRetrieve the value(s) stored at the given key or index within a collection. The syntax a[i,j,...] is converted by the compiler to getindex(a, i, j, ...).\\n\\nExamples\\n\\njulia> A = Dict(\\\"a\\\" => 1, \\\"b\\\" => 2)\\nDict{String,Int64} with 2 entries:\\n  \\\"b\\\" => 2\\n  \\\"a\\\" => 1\\n\\njulia> getindex(A, \\\"a\\\")\\n1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.setindex!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.setindex!\",\n    \"category\": \"function\",\n    \"text\": \"setindex!(collection, value, key...)\\n\\nStore the given value at the given key or index within a collection. The syntax a[i,j,...] = x is converted by the compiler to (setindex!(a, x, i, j, ...); x).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.firstindex\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.firstindex\",\n    \"category\": \"function\",\n    \"text\": \"firstindex(collection) -> Integer\\nfirstindex(collection, d) -> Integer\\n\\nReturn the first index of collection. If d is given, return the first index of collection along dimension d.\\n\\nExamples\\n\\njulia> firstindex([1,2,4])\\n1\\n\\njulia> firstindex(rand(3,4,5), 2)\\n1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.lastindex\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.lastindex\",\n    \"category\": \"function\",\n    \"text\": \"lastindex(collection) -> Integer\\nlastindex(collection, d) -> Integer\\n\\nReturn the last index of collection. If d is given, return the last index of collection along dimension d.\\n\\nThe syntaxes A[end] and A[end, end] lower to A[lastindex(A)] and A[lastindex(A, 1), lastindex(A, 2)], respectively.\\n\\nExamples\\n\\njulia> lastindex([1,2,4])\\n3\\n\\njulia> lastindex(rand(3,4,5), 2)\\n4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Indexable-Collections-1\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Indexable Collections\",\n    \"category\": \"section\",\n    \"text\": \"Base.getindex\\nBase.setindex!\\nBase.firstindex\\nBase.lastindexFully implemented by:Array\\nBitArray\\nAbstractArray\\nSubArrayPartially implemented by:AbstractRange\\nUnitRange\\nTuple\\nAbstractString\\nDict\\nIdDict\\nWeakKeyDict\\nNamedTuple\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.Dict\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.Dict\",\n    \"category\": \"type\",\n    \"text\": \"Dict([itr])\\n\\nDict{K,V}() constructs a hash table with keys of type K and values of type V. Keys are compared with isequal and hashed with hash.\\n\\nGiven a single iterable argument, constructs a Dict whose key-value pairs are taken from 2-tuples (key,value) generated by the argument.\\n\\nExamples\\n\\njulia> Dict([(\\\"A\\\", 1), (\\\"B\\\", 2)])\\nDict{String,Int64} with 2 entries:\\n  \\\"B\\\" => 2\\n  \\\"A\\\" => 1\\n\\nAlternatively, a sequence of pair arguments may be passed.\\n\\njulia> Dict(\\\"A\\\"=>1, \\\"B\\\"=>2)\\nDict{String,Int64} with 2 entries:\\n  \\\"B\\\" => 2\\n  \\\"A\\\" => 1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.IdDict\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.IdDict\",\n    \"category\": \"type\",\n    \"text\": \"IdDict([itr])\\n\\nIdDict{K,V}() constructs a hash table using object-id as hash and === as equality with keys of type K and values of type V.\\n\\nSee Dict for further help.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.WeakKeyDict\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.WeakKeyDict\",\n    \"category\": \"type\",\n    \"text\": \"WeakKeyDict([itr])\\n\\nWeakKeyDict() constructs a hash table where the keys are weak references to objects, and thus may be garbage collected even when referenced in a hash table.\\n\\nSee Dict for further help.  Note, unlike Dict, WeakKeyDict does not convert keys on insertion.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.ImmutableDict\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.ImmutableDict\",\n    \"category\": \"type\",\n    \"text\": \"ImmutableDict\\n\\nImmutableDict is a Dictionary implemented as an immutable linked list, which is optimal for small dictionaries that are constructed over many individual insertions Note that it is not possible to remove a value, although it can be partially overridden and hidden by inserting a new value with the same key\\n\\nImmutableDict(KV::Pair)\\n\\nCreate a new entry in the Immutable Dictionary for the key => value pair\\n\\nuse (key => value) in dict to see if this particular combination is in the properties set\\nuse get(dict, key, default) to retrieve the most recent value for a particular key\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.haskey\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.haskey\",\n    \"category\": \"function\",\n    \"text\": \"haskey(collection, key) -> Bool\\n\\nDetermine whether a collection has a mapping for a given key.\\n\\nExamples\\n\\njulia> D = Dict(\\'a\\'=>2, \\'b\\'=>3)\\nDict{Char,Int64} with 2 entries:\\n  \\'a\\' => 2\\n  \\'b\\' => 3\\n\\njulia> haskey(D, \\'a\\')\\ntrue\\n\\njulia> haskey(D, \\'c\\')\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.get-Tuple{Any,Any,Any}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.get\",\n    \"category\": \"method\",\n    \"text\": \"get(collection, key, default)\\n\\nReturn the value stored for the given key, or the given default value if no mapping for the key is present.\\n\\nExamples\\n\\njulia> d = Dict(\\\"a\\\"=>1, \\\"b\\\"=>2);\\n\\njulia> get(d, \\\"a\\\", 3)\\n1\\n\\njulia> get(d, \\\"c\\\", 3)\\n3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.get\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.get\",\n    \"category\": \"function\",\n    \"text\": \"get(collection, key, default)\\n\\nReturn the value stored for the given key, or the given default value if no mapping for the key is present.\\n\\nExamples\\n\\njulia> d = Dict(\\\"a\\\"=>1, \\\"b\\\"=>2);\\n\\njulia> get(d, \\\"a\\\", 3)\\n1\\n\\njulia> get(d, \\\"c\\\", 3)\\n3\\n\\n\\n\\n\\n\\nget(f::Function, collection, key)\\n\\nReturn the value stored for the given key, or if no mapping for the key is present, return f().  Use get! to also store the default value in the dictionary.\\n\\nThis is intended to be called using do block syntax\\n\\nget(dict, key) do\\n    # default value calculated here\\n    time()\\nend\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.get!-Tuple{Any,Any,Any}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.get!\",\n    \"category\": \"method\",\n    \"text\": \"get!(collection, key, default)\\n\\nReturn the value stored for the given key, or if no mapping for the key is present, store key => default, and return default.\\n\\nExamples\\n\\njulia> d = Dict(\\\"a\\\"=>1, \\\"b\\\"=>2, \\\"c\\\"=>3);\\n\\njulia> get!(d, \\\"a\\\", 5)\\n1\\n\\njulia> get!(d, \\\"d\\\", 4)\\n4\\n\\njulia> d\\nDict{String,Int64} with 4 entries:\\n  \\\"c\\\" => 3\\n  \\\"b\\\" => 2\\n  \\\"a\\\" => 1\\n  \\\"d\\\" => 4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.get!-Tuple{Function,Any,Any}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.get!\",\n    \"category\": \"method\",\n    \"text\": \"get!(f::Function, collection, key)\\n\\nReturn the value stored for the given key, or if no mapping for the key is present, store key => f(), and return f().\\n\\nThis is intended to be called using do block syntax:\\n\\nget!(dict, key) do\\n    # default value calculated here\\n    time()\\nend\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.getkey\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.getkey\",\n    \"category\": \"function\",\n    \"text\": \"getkey(collection, key, default)\\n\\nReturn the key matching argument key if one exists in collection, otherwise return default.\\n\\nExamples\\n\\njulia> D = Dict(\\'a\\'=>2, \\'b\\'=>3)\\nDict{Char,Int64} with 2 entries:\\n  \\'a\\' => 2\\n  \\'b\\' => 3\\n\\njulia> getkey(D, \\'a\\', 1)\\n\\'a\\': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\\n\\njulia> getkey(D, \\'d\\', \\'a\\')\\n\\'a\\': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.delete!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.delete!\",\n    \"category\": \"function\",\n    \"text\": \"delete!(collection, key)\\n\\nDelete the mapping for the given key in a collection, and return the collection.\\n\\nExamples\\n\\njulia> d = Dict(\\\"a\\\"=>1, \\\"b\\\"=>2)\\nDict{String,Int64} with 2 entries:\\n  \\\"b\\\" => 2\\n  \\\"a\\\" => 1\\n\\njulia> delete!(d, \\\"b\\\")\\nDict{String,Int64} with 1 entry:\\n  \\\"a\\\" => 1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.pop!-Tuple{Any,Any,Any}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.pop!\",\n    \"category\": \"method\",\n    \"text\": \"pop!(collection, key[, default])\\n\\nDelete and return the mapping for key if it exists in collection, otherwise return default, or throw an error if default is not specified.\\n\\nExamples\\n\\njulia> d = Dict(\\\"a\\\"=>1, \\\"b\\\"=>2, \\\"c\\\"=>3);\\n\\njulia> pop!(d, \\\"a\\\")\\n1\\n\\njulia> pop!(d, \\\"d\\\")\\nERROR: KeyError: key \\\"d\\\" not found\\nStacktrace:\\n[...]\\n\\njulia> pop!(d, \\\"e\\\", 4)\\n4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.keys\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.keys\",\n    \"category\": \"function\",\n    \"text\": \"keys(iterator)\\n\\nFor an iterator or collection that has keys and values (e.g. arrays and dictionaries), return an iterator over the keys.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.values\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.values\",\n    \"category\": \"function\",\n    \"text\": \"values(iterator)\\n\\nFor an iterator or collection that has keys and values, return an iterator over the values. This function simply returns its argument by default, since the elements of a general iterator are normally considered its \\\"values\\\".\\n\\nExamples\\n\\njulia> d = Dict(\\\"a\\\"=>1, \\\"b\\\"=>2);\\n\\njulia> values(d)\\nBase.ValueIterator for a Dict{String,Int64} with 2 entries. Values:\\n  2\\n  1\\n\\njulia> values([2])\\n1-element Array{Int64,1}:\\n 2\\n\\n\\n\\n\\n\\nvalues(a::AbstractDict)\\n\\nReturn an iterator over all values in a collection. collect(values(a)) returns an array of values. Since the values are stored internally in a hash table, the order in which they are returned may vary. But keys(a) and values(a) both iterate a and return the elements in the same order.\\n\\nExamples\\n\\njulia> D = Dict(\\'a\\'=>2, \\'b\\'=>3)\\nDict{Char,Int64} with 2 entries:\\n  \\'a\\' => 2\\n  \\'b\\' => 3\\n\\njulia> collect(values(D))\\n2-element Array{Int64,1}:\\n 2\\n 3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.pairs\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.pairs\",\n    \"category\": \"function\",\n    \"text\": \"pairs(IndexLinear(), A)\\npairs(IndexCartesian(), A)\\npairs(IndexStyle(A), A)\\n\\nAn iterator that accesses each element of the array A, returning i => x, where i is the index for the element and x = A[i]. Identical to pairs(A), except that the style of index can be selected. Also similar to enumerate(A), except i will be a valid index for A, while enumerate always counts from 1 regardless of the indices of A.\\n\\nSpecifying IndexLinear() ensures that i will be an integer; specifying IndexCartesian() ensures that i will be a CartesianIndex; specifying IndexStyle(A) chooses whichever has been defined as the native indexing style for array A.\\n\\nMutation of the bounds of the underlying array will invalidate this iterator.\\n\\nExamples\\n\\njulia> A = [\\\"a\\\" \\\"d\\\"; \\\"b\\\" \\\"e\\\"; \\\"c\\\" \\\"f\\\"];\\n\\njulia> for (index, value) in pairs(IndexStyle(A), A)\\n           println(\\\"$index $value\\\")\\n       end\\n1 a\\n2 b\\n3 c\\n4 d\\n5 e\\n6 f\\n\\njulia> S = view(A, 1:2, :);\\n\\njulia> for (index, value) in pairs(IndexStyle(S), S)\\n           println(\\\"$index $value\\\")\\n       end\\nCartesianIndex(1, 1) a\\nCartesianIndex(2, 1) b\\nCartesianIndex(1, 2) d\\nCartesianIndex(2, 2) e\\n\\nSee also: IndexStyle, axes.\\n\\n\\n\\n\\n\\npairs(collection)\\n\\nReturn an iterator over key => value pairs for any collection that maps a set of keys to a set of values. This includes arrays, where the keys are the array indices.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.merge\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.merge\",\n    \"category\": \"function\",\n    \"text\": \"merge(d::AbstractDict, others::AbstractDict...)\\n\\nConstruct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. If the same key is present in another collection, the value for that key will be the value it has in the last collection listed.\\n\\nExamples\\n\\njulia> a = Dict(\\\"foo\\\" => 0.0, \\\"bar\\\" => 42.0)\\nDict{String,Float64} with 2 entries:\\n  \\\"bar\\\" => 42.0\\n  \\\"foo\\\" => 0.0\\n\\njulia> b = Dict(\\\"baz\\\" => 17, \\\"bar\\\" => 4711)\\nDict{String,Int64} with 2 entries:\\n  \\\"bar\\\" => 4711\\n  \\\"baz\\\" => 17\\n\\njulia> merge(a, b)\\nDict{String,Float64} with 3 entries:\\n  \\\"bar\\\" => 4711.0\\n  \\\"baz\\\" => 17.0\\n  \\\"foo\\\" => 0.0\\n\\njulia> merge(b, a)\\nDict{String,Float64} with 3 entries:\\n  \\\"bar\\\" => 42.0\\n  \\\"baz\\\" => 17.0\\n  \\\"foo\\\" => 0.0\\n\\n\\n\\n\\n\\nmerge(combine, d::AbstractDict, others::AbstractDict...)\\n\\nConstruct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. Values with the same key will be combined using the combiner function.\\n\\nExamples\\n\\njulia> a = Dict(\\\"foo\\\" => 0.0, \\\"bar\\\" => 42.0)\\nDict{String,Float64} with 2 entries:\\n  \\\"bar\\\" => 42.0\\n  \\\"foo\\\" => 0.0\\n\\njulia> b = Dict(\\\"baz\\\" => 17, \\\"bar\\\" => 4711)\\nDict{String,Int64} with 2 entries:\\n  \\\"bar\\\" => 4711\\n  \\\"baz\\\" => 17\\n\\njulia> merge(+, a, b)\\nDict{String,Float64} with 3 entries:\\n  \\\"bar\\\" => 4753.0\\n  \\\"baz\\\" => 17.0\\n  \\\"foo\\\" => 0.0\\n\\n\\n\\n\\n\\nmerge(a::NamedTuple, b::NamedTuple)\\n\\nConstruct a new named tuple by merging two existing ones. The order of fields in a is preserved, but values are taken from matching fields in b. Fields present only in b are appended at the end.\\n\\njulia> merge((a=1, b=2, c=3), (b=4, d=5))\\n(a = 1, b = 4, c = 3, d = 5)\\n\\n\\n\\n\\n\\nmerge(a::NamedTuple, iterable)\\n\\nInterpret an iterable of key-value pairs as a named tuple, and perform a merge.\\n\\njulia> merge((a=1, b=2, c=3), [:b=>4, :d=>5])\\n(a = 1, b = 4, c = 3, d = 5)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.merge!-Tuple{AbstractDict,Vararg{AbstractDict,N} where N}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.merge!\",\n    \"category\": \"method\",\n    \"text\": \"merge!(d::AbstractDict, others::AbstractDict...)\\n\\nUpdate collection with pairs from the other collections. See also merge.\\n\\nExamples\\n\\njulia> d1 = Dict(1 => 2, 3 => 4);\\n\\njulia> d2 = Dict(1 => 4, 4 => 5);\\n\\njulia> merge!(d1, d2);\\n\\njulia> d1\\nDict{Int64,Int64} with 3 entries:\\n  4 => 5\\n  3 => 4\\n  1 => 4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.merge!-Tuple{Function,AbstractDict,Vararg{AbstractDict,N} where N}\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.merge!\",\n    \"category\": \"method\",\n    \"text\": \"merge!(combine, d::AbstractDict, others::AbstractDict...)\\n\\nUpdate collection with pairs from the other collections. Values with the same key will be combined using the combiner function.\\n\\nExamples\\n\\njulia> d1 = Dict(1 => 2, 3 => 4);\\n\\njulia> d2 = Dict(1 => 4, 4 => 5);\\n\\njulia> merge!(+, d1, d2);\\n\\njulia> d1\\nDict{Int64,Int64} with 3 entries:\\n  4 => 5\\n  3 => 4\\n  1 => 6\\n\\njulia> merge!(-, d1, d1);\\n\\njulia> d1\\nDict{Int64,Int64} with 3 entries:\\n  4 => 0\\n  3 => 0\\n  1 => 0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.sizehint!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.sizehint!\",\n    \"category\": \"function\",\n    \"text\": \"sizehint!(s, n)\\n\\nSuggest that collection s reserve capacity for at least n elements. This can improve performance.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.keytype\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.keytype\",\n    \"category\": \"function\",\n    \"text\": \"keytype(type)\\n\\nGet the key type of an dictionary type. Behaves similarly to eltype.\\n\\nExamples\\n\\njulia> keytype(Dict(Int32(1) => \\\"foo\\\"))\\nInt32\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.valtype\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.valtype\",\n    \"category\": \"function\",\n    \"text\": \"valtype(type)\\n\\nGet the value type of an dictionary type. Behaves similarly to eltype.\\n\\nExamples\\n\\njulia> valtype(Dict(Int32(1) => \\\"foo\\\"))\\nString\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Dictionaries-1\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Dictionaries\",\n    \"category\": \"section\",\n    \"text\": \"Dict is the standard dictionary. Its implementation uses hash as the hashing function for the key, and isequal to determine equality. Define these two functions for custom types to override how they are stored in a hash table.IdDict is a special hash table where the keys are always object identities.WeakKeyDict is a hash table implementation where the keys are weak references to objects, and thus may be garbage collected even when referenced in a hash table. Like Dict it uses hash for hashing and isequal for equality, unlike Dict it does not convert keys on insertion.Dicts can be created by passing pair objects constructed with => to a Dict constructor: Dict(\\\"A\\\"=>1, \\\"B\\\"=>2). This call will attempt to infer type information from the keys and values (i.e. this example creates a Dict{String, Int64}). To explicitly specify types use the syntax Dict{KeyType,ValueType}(...). For example, Dict{String,Int32}(\\\"A\\\"=>1, \\\"B\\\"=>2).Dictionaries may also be created with generators. For example, Dict(i => f(i) for i = 1:10).Given a dictionary D, the syntax D[x] returns the value of key x (if it exists) or throws an error, and D[x] = y stores the key-value pair x => y in D (replacing any existing value for the key x).  Multiple arguments to D[...] are converted to tuples; for example, the syntax D[x,y]  is equivalent to D[(x,y)], i.e. it refers to the value keyed by the tuple (x,y).Base.Dict\\nBase.IdDict\\nBase.WeakKeyDict\\nBase.ImmutableDict\\nBase.haskey\\nBase.get(::Any, ::Any, ::Any)\\nBase.get\\nBase.get!(::Any, ::Any, ::Any)\\nBase.get!(::Function, ::Any, ::Any)\\nBase.getkey\\nBase.delete!\\nBase.pop!(::Any, ::Any, ::Any)\\nBase.keys\\nBase.values\\nBase.pairs\\nBase.merge\\nBase.merge!(::AbstractDict, ::AbstractDict...)\\nBase.merge!(::Function, ::AbstractDict, ::AbstractDict...)\\nBase.sizehint!\\nBase.keytype\\nBase.valtypeFully implemented by:IdDict\\nDict\\nWeakKeyDictPartially implemented by:BitSet\\nSet\\nEnvDict\\nArray\\nBitArray\\nImmutableDict\\nIterators.Pairs\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.Set\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.Set\",\n    \"category\": \"type\",\n    \"text\": \"Set([itr])\\n\\nConstruct a Set of the values generated by the given iterable object, or an empty set. Should be used instead of BitSet for sparse integer sets, or for sets of arbitrary objects.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.BitSet\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.BitSet\",\n    \"category\": \"type\",\n    \"text\": \"BitSet([itr])\\n\\nConstruct a sorted set of Ints generated by the given iterable object, or an empty set. Implemented as a bit string, and therefore designed for dense integer sets. If the set will be sparse (for example, holding a few very large integers), use Set instead.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.union\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.union\",\n    \"category\": \"function\",\n    \"text\": \"union(s, itrs...)\\n\u222a(s, itrs...)\\n\\nConstruct the union of sets. Maintain order with arrays.\\n\\nExamples\\n\\njulia> union([1, 2], [3, 4])\\n4-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n 4\\n\\njulia> union([1, 2], [2, 4])\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 4\\n\\njulia> union([4, 2], 1:2)\\n3-element Array{Int64,1}:\\n 4\\n 2\\n 1\\n\\njulia> union(Set([1, 2]), 2:3)\\nSet([2, 3, 1])\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.union!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.union!\",\n    \"category\": \"function\",\n    \"text\": \"union!(s::Union{AbstractSet,AbstractVector}, itrs...)\\n\\nConstruct the union of passed in sets and overwrite s with the result. Maintain order with arrays.\\n\\nExamples\\n\\njulia> a = Set([1, 3, 4, 5]);\\n\\njulia> union!(a, 1:2:8);\\n\\njulia> a\\nSet([7, 4, 3, 5, 1])\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.intersect\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.intersect\",\n    \"category\": \"function\",\n    \"text\": \"intersect(s, itrs...)\\n\u2229(s, itrs...)\\n\\nConstruct the intersection of sets. Maintain order with arrays.\\n\\nExamples\\n\\njulia> intersect([1, 2, 3], [3, 4, 5])\\n1-element Array{Int64,1}:\\n 3\\n\\njulia> intersect([1, 4, 4, 5, 6], [4, 6, 6, 7, 8])\\n2-element Array{Int64,1}:\\n 4\\n 6\\n\\njulia> intersect(Set([1, 2]), BitSet([2, 3]))\\nSet([2])\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.setdiff\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.setdiff\",\n    \"category\": \"function\",\n    \"text\": \"setdiff(s, itrs...)\\n\\nConstruct the set of elements in s but not in any of the iterables in itrs. Maintain order with arrays.\\n\\nExamples\\n\\njulia> setdiff([1,2,3], [3,4,5])\\n2-element Array{Int64,1}:\\n 1\\n 2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.setdiff!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.setdiff!\",\n    \"category\": \"function\",\n    \"text\": \"setdiff!(s, itrs...)\\n\\nRemove from set s (in-place) each element of each iterable from itrs. Maintain order with arrays.\\n\\nExamples\\n\\njulia> a = Set([1, 3, 4, 5]);\\n\\njulia> setdiff!(a, 1:2:6);\\n\\njulia> a\\nSet([4])\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.symdiff\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.symdiff\",\n    \"category\": \"function\",\n    \"text\": \"symdiff(s, itrs...)\\n\\nConstruct the symmetric difference of elements in the passed in sets. When s is not an AbstractSet, the order is maintained. Note that in this case the multiplicity of elements matters.\\n\\nExamples\\n\\njulia> symdiff([1,2,3], [3,4,5], [4,5,6])\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 6\\n\\njulia> symdiff([1,2,1], [2, 1, 2])\\n2-element Array{Int64,1}:\\n 1\\n 2\\n\\njulia> symdiff(unique([1,2,1]), unique([2, 1, 2]))\\n0-element Array{Int64,1}\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.symdiff!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.symdiff!\",\n    \"category\": \"function\",\n    \"text\": \"symdiff!(s::Union{AbstractSet,AbstractVector}, itrs...)\\n\\nConstruct the symmetric difference of the passed in sets, and overwrite s with the result. When s is an array, the order is maintained. Note that in this case the multiplicity of elements matters.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.intersect!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.intersect!\",\n    \"category\": \"function\",\n    \"text\": \"intersect!(s::Union{AbstractSet,AbstractVector}, itrs...)\\n\\nIntersect all passed in sets and overwrite s with the result. Maintain order with arrays.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.issubset\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.issubset\",\n    \"category\": \"function\",\n    \"text\": \"issubset(a, b)\\n\u2286(a,b)  -> Bool\\n\u2287(b, a) -> Bool\\n\\nDetermine whether every element of a is also in b, using in.\\n\\nExamples\\n\\njulia> issubset([1, 2], [1, 2, 3])\\ntrue\\n\\njulia> [1, 2, 3] \u2286 [1, 2]\\nfalse\\n\\njulia> [1, 2, 3] \u2287 [1, 2]\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.:\u2288\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.:\u2288\",\n    \"category\": \"function\",\n    \"text\": \"\u2288(a, b)\\n\u2289(b, a)\\n\\nNegation of \u2286 and \u2287, i.e. checks that a is not a subset of b.\\n\\nExamples\\n\\njulia> (1, 2) \u2288 (2, 3)\\ntrue\\n\\njulia> (1, 2) \u2288 (1, 2, 3)\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.:\u228a\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.:\u228a\",\n    \"category\": \"function\",\n    \"text\": \"\u228a(a, b)\\n\u228b(b, a)\\n\\nDetermines if a is a subset of, but not equal to, b.\\n\\nExamples\\n\\njulia> (1, 2) \u228a (1, 2, 3)\\ntrue\\n\\njulia> (1, 2) \u228a (1, 2)\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.issetequal\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.issetequal\",\n    \"category\": \"function\",\n    \"text\": \"issetequal(a, b)\\n\\nDetermine whether a and b have the same elements. Equivalent to a \u2286 b && b \u2286 a.\\n\\nExamples\\n\\njulia> issetequal([1, 2], [1, 2, 3])\\nfalse\\n\\njulia> issetequal([1, 2], [2, 1])\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Set-Like-Collections-1\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Set-Like Collections\",\n    \"category\": \"section\",\n    \"text\": \"Base.Set\\nBase.BitSet\\nBase.union\\nBase.union!\\nBase.intersect\\nBase.setdiff\\nBase.setdiff!\\nBase.symdiff\\nBase.symdiff!\\nBase.intersect!\\nBase.issubset\\nBase.:\u2288\\nBase.:\u228a\\nBase.issetequalFully implemented by:BitSet\\nSetPartially implemented by:Array\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.push!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.push!\",\n    \"category\": \"function\",\n    \"text\": \"push!(collection, items...) -> collection\\n\\nInsert one or more items at the end of collection.\\n\\nExamples\\n\\njulia> push!([1, 2, 3], 4, 5, 6)\\n6-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n 4\\n 5\\n 6\\n\\nUse append! to add all the elements of another collection to collection. The result of the preceding example is equivalent to append!([1, 2, 3], [4, 5, 6]).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.pop!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.pop!\",\n    \"category\": \"function\",\n    \"text\": \"pop!(collection) -> item\\n\\nRemove an item in collection and return it. If collection is an ordered container, the last item is returned.\\n\\nExamples\\n\\njulia> A=[1, 2, 3]\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n\\njulia> pop!(A)\\n3\\n\\njulia> A\\n2-element Array{Int64,1}:\\n 1\\n 2\\n\\njulia> S = Set([1, 2])\\nSet([2, 1])\\n\\njulia> pop!(S)\\n2\\n\\njulia> S\\nSet([1])\\n\\njulia> pop!(Dict(1=>2))\\n1 => 2\\n\\n\\n\\n\\n\\npop!(collection, key[, default])\\n\\nDelete and return the mapping for key if it exists in collection, otherwise return default, or throw an error if default is not specified.\\n\\nExamples\\n\\njulia> d = Dict(\\\"a\\\"=>1, \\\"b\\\"=>2, \\\"c\\\"=>3);\\n\\njulia> pop!(d, \\\"a\\\")\\n1\\n\\njulia> pop!(d, \\\"d\\\")\\nERROR: KeyError: key \\\"d\\\" not found\\nStacktrace:\\n[...]\\n\\njulia> pop!(d, \\\"e\\\", 4)\\n4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.pushfirst!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.pushfirst!\",\n    \"category\": \"function\",\n    \"text\": \"pushfirst!(collection, items...) -> collection\\n\\nInsert one or more items at the beginning of collection.\\n\\nExamples\\n\\njulia> pushfirst!([1, 2, 3, 4], 5, 6)\\n6-element Array{Int64,1}:\\n 5\\n 6\\n 1\\n 2\\n 3\\n 4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.popfirst!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.popfirst!\",\n    \"category\": \"function\",\n    \"text\": \"popfirst!(collection) -> item\\n\\nRemove the first item from collection.\\n\\nExamples\\n\\njulia> A = [1, 2, 3, 4, 5, 6]\\n6-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n 4\\n 5\\n 6\\n\\njulia> popfirst!(A)\\n1\\n\\njulia> A\\n5-element Array{Int64,1}:\\n 2\\n 3\\n 4\\n 5\\n 6\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.insert!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.insert!\",\n    \"category\": \"function\",\n    \"text\": \"insert!(a::Vector, index::Integer, item)\\n\\nInsert an item into a at the given index. index is the index of item in the resulting a.\\n\\nExamples\\n\\njulia> insert!([6, 5, 4, 2, 1], 4, 3)\\n6-element Array{Int64,1}:\\n 6\\n 5\\n 4\\n 3\\n 2\\n 1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.deleteat!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.deleteat!\",\n    \"category\": \"function\",\n    \"text\": \"deleteat!(a::Vector, i::Integer)\\n\\nRemove the item at the given i and return the modified a. Subsequent items are shifted to fill the resulting gap.\\n\\nExamples\\n\\njulia> deleteat!([6, 5, 4, 3, 2, 1], 2)\\n5-element Array{Int64,1}:\\n 6\\n 4\\n 3\\n 2\\n 1\\n\\n\\n\\n\\n\\ndeleteat!(a::Vector, inds)\\n\\nRemove the items at the indices given by inds, and return the modified a. Subsequent items are shifted to fill the resulting gap.\\n\\ninds can be either an iterator or a collection of sorted and unique integer indices, or a boolean vector of the same length as a with true indicating entries to delete.\\n\\nExamples\\n\\njulia> deleteat!([6, 5, 4, 3, 2, 1], 1:2:5)\\n3-element Array{Int64,1}:\\n 5\\n 3\\n 1\\n\\njulia> deleteat!([6, 5, 4, 3, 2, 1], [true, false, true, false, true, false])\\n3-element Array{Int64,1}:\\n 5\\n 3\\n 1\\n\\njulia> deleteat!([6, 5, 4, 3, 2, 1], (2, 2))\\nERROR: ArgumentError: indices must be unique and sorted\\nStacktrace:\\n[...]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.splice!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.splice!\",\n    \"category\": \"function\",\n    \"text\": \"splice!(a::Vector, index::Integer, [replacement]) -> item\\n\\nRemove the item at the given index, and return the removed item. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed item.\\n\\nExamples\\n\\njulia> A = [6, 5, 4, 3, 2, 1]; splice!(A, 5)\\n2\\n\\njulia> A\\n5-element Array{Int64,1}:\\n 6\\n 5\\n 4\\n 3\\n 1\\n\\njulia> splice!(A, 5, -1)\\n1\\n\\njulia> A\\n5-element Array{Int64,1}:\\n  6\\n  5\\n  4\\n  3\\n -1\\n\\njulia> splice!(A, 1, [-1, -2, -3])\\n6\\n\\njulia> A\\n7-element Array{Int64,1}:\\n -1\\n -2\\n -3\\n  5\\n  4\\n  3\\n -1\\n\\nTo insert replacement before an index n without removing any items, use splice!(collection, n:n-1, replacement).\\n\\n\\n\\n\\n\\nsplice!(a::Vector, range, [replacement]) -> items\\n\\nRemove items in the specified index range, and return a collection containing the removed items. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed items.\\n\\nTo insert replacement before an index n without removing any items, use splice!(collection, n:n-1, replacement).\\n\\nExamples\\n\\njulia> splice!(A, 4:3, 2)\\n0-element Array{Int64,1}\\n\\njulia> A\\n8-element Array{Int64,1}:\\n -1\\n -2\\n -3\\n  2\\n  5\\n  4\\n  3\\n -1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.resize!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.resize!\",\n    \"category\": \"function\",\n    \"text\": \"resize!(a::Vector, n::Integer) -> Vector\\n\\nResize a to contain n elements. If n is smaller than the current collection length, the first n elements will be retained. If n is larger, the new elements are not guaranteed to be initialized.\\n\\nExamples\\n\\njulia> resize!([6, 5, 4, 3, 2, 1], 3)\\n3-element Array{Int64,1}:\\n 6\\n 5\\n 4\\n\\njulia> a = resize!([6, 5, 4, 3, 2, 1], 8);\\n\\njulia> length(a)\\n8\\n\\njulia> a[1:6]\\n6-element Array{Int64,1}:\\n 6\\n 5\\n 4\\n 3\\n 2\\n 1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.append!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.append!\",\n    \"category\": \"function\",\n    \"text\": \"append!(collection, collection2) -> collection.\\n\\nAdd the elements of collection2 to the end of collection.\\n\\nExamples\\n\\njulia> append!([1],[2,3])\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n\\njulia> append!([1, 2, 3], [4, 5, 6])\\n6-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n 4\\n 5\\n 6\\n\\nUse push! to add individual items to collection which are not already themselves in another collection. The result is of the preceding example is equivalent to push!([1, 2, 3], 4, 5, 6).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.prepend!\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.prepend!\",\n    \"category\": \"function\",\n    \"text\": \"prepend!(a::Vector, items) -> collection\\n\\nInsert the elements of items to the beginning of a.\\n\\nExamples\\n\\njulia> prepend!([3],[1,2])\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Dequeues-1\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Dequeues\",\n    \"category\": \"section\",\n    \"text\": \"Base.push!\\nBase.pop!\\nBase.pushfirst!\\nBase.popfirst!\\nBase.insert!\\nBase.deleteat!\\nBase.splice!\\nBase.resize!\\nBase.append!\\nBase.prepend!Fully implemented by:Vector (a.k.a. 1-dimensional Array)\\nBitVector (a.k.a. 1-dimensional BitArray)\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.Pair\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.Pair\",\n    \"category\": \"type\",\n    \"text\": \"Pair(x, y)\\nx => y\\n\\nConstruct a Pair object with type Pair{typeof(x), typeof(y)}. The elements are stored in the fields first and second. They can also be accessed via iteration.\\n\\nSee also: Dict\\n\\nExamples\\n\\njulia> p = \\\"foo\\\" => 7\\n\\\"foo\\\" => 7\\n\\njulia> typeof(p)\\nPair{String,Int64}\\n\\njulia> p.first\\n\\\"foo\\\"\\n\\njulia> for x in p\\n           println(x)\\n       end\\nfoo\\n7\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Base.Iterators.Pairs\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Base.Iterators.Pairs\",\n    \"category\": \"type\",\n    \"text\": \"Iterators.Pairs(values, keys) <: AbstractDict{eltype(keys), eltype(values)}\\n\\nTransforms an indexable container into an Dictionary-view of the same data. Modifying the key-space of the underlying data may invalidate this object.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/collections.html#Utility-Collections-1\",\n    \"page\": \"Collections and Data Structures\",\n    \"title\": \"Utility Collections\",\n    \"category\": \"section\",\n    \"text\": \"Base.Pair\\nIterators.Pairs\"\n},\n\n{\n    \"location\": \"base/math.html#\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Mathematics\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/math.html#Mathematics-1\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Mathematics\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:--Tuple{Any}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:-\",\n    \"category\": \"method\",\n    \"text\": \"-(x)\\n\\nUnary minus operator.\\n\\nExamples\\n\\njulia> -1\\n-1\\n\\njulia> -(2)\\n-2\\n\\njulia> -[1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n -1  -2\\n -3  -4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:+\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:+\",\n    \"category\": \"function\",\n    \"text\": \"dt::Date + t::Time -> DateTime\\n\\nThe addition of a Date with a Time produces a DateTime. The hour, minute, second, and millisecond parts of the Time are used along with the year, month, and day of the Date to create the new DateTime. Non-zero microseconds or nanoseconds in the Time type will result in an InexactError being thrown.\\n\\n\\n\\n\\n\\n+(x, y...)\\n\\nAddition operator. x+y+z+... calls this function with all arguments, i.e. +(x, y, z, ...).\\n\\nExamples\\n\\njulia> 1 + 20 + 4\\n25\\n\\njulia> +(1, 20, 4)\\n25\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:--Tuple{Any,Any}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:-\",\n    \"category\": \"method\",\n    \"text\": \"-(x, y)\\n\\nSubtraction operator.\\n\\nExamples\\n\\njulia> 2 - 3\\n-1\\n\\njulia> -(2, 4.5)\\n-2.5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:*-Tuple{Any,Vararg{Any,N} where N}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:*\",\n    \"category\": \"method\",\n    \"text\": \"*(x, y...)\\n\\nMultiplication operator. x*y*z*... calls this function with all arguments, i.e. *(x, y, z, ...).\\n\\nExamples\\n\\njulia> 2 * 7 * 8\\n112\\n\\njulia> *(2, 7, 8)\\n112\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:/\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:/\",\n    \"category\": \"function\",\n    \"text\": \"/(x, y)\\n\\nRight division operator: multiplication of x by the inverse of y on the right. Gives floating-point results for integer arguments.\\n\\nExamples\\n\\njulia> 1/2\\n0.5\\n\\njulia> 4/2\\n2.0\\n\\njulia> 4.5/2\\n2.25\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:\\\\-Tuple{Any,Any}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:\\\\\",\n    \"category\": \"method\",\n    \"text\": \"\\\\(x, y)\\n\\nLeft division operator: multiplication of y by the inverse of x on the left. Gives floating-point results for integer arguments.\\n\\nExamples\\n\\njulia> 3 \\\\ 6\\n2.0\\n\\njulia> inv(3) * 6\\n2.0\\n\\njulia> A = [1 2; 3 4]; x = [5, 6];\\n\\njulia> A \\\\ x\\n2-element Array{Float64,1}:\\n -4.0\\n  4.5\\n\\njulia> inv(A) * x\\n2-element Array{Float64,1}:\\n -4.0\\n  4.5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:^-Tuple{Number,Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:^\",\n    \"category\": \"method\",\n    \"text\": \"^(x, y)\\n\\nExponentiation operator. If x is a matrix, computes matrix exponentiation.\\n\\nIf y is an Int literal (e.g. 2 in x^2 or -3 in x^-3), the Julia code x^y is transformed by the compiler to Base.literal_pow(^, x, Val(y)), to enable compile-time specialization on the value of the exponent. (As a default fallback we have Base.literal_pow(^, x, Val(y)) = ^(x,y), where usually ^ == Base.^ unless ^ has been defined in the calling namespace.)\\n\\njulia> 3^5\\n243\\n\\njulia> A = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> A^3\\n2\u00d72 Array{Int64,2}:\\n 37   54\\n 81  118\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.fma\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.fma\",\n    \"category\": \"function\",\n    \"text\": \"fma(x, y, z)\\n\\nComputes x*y+z without rounding the intermediate result x*y. On some systems this is significantly more expensive than x*y+z. fma is used to improve accuracy in certain algorithms. See muladd.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.muladd\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.muladd\",\n    \"category\": \"function\",\n    \"text\": \"muladd(x, y, z)\\n\\nCombined multiply-add: computes x*y+z, but allowing the add and multiply to be merged with each other or with surrounding operations for performance. For example, this may be implemented as an fma if the hardware supports it efficiently. The result can be different on different machines and can also be different on the same machine due to constant propagation or other optimizations. See fma.\\n\\nExamples\\n\\njulia> muladd(3, 2, 1)\\n7\\n\\njulia> 3 * 2 + 1\\n7\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.inv-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.inv\",\n    \"category\": \"method\",\n    \"text\": \"inv(x)\\n\\nReturn the multiplicative inverse of x, such that x*inv(x) or inv(x)*x yields one(x) (the multiplicative identity) up to roundoff errors.\\n\\nIf x is a number, this is essentially the same as one(x)/x, but for some types inv(x) may be slightly more efficient.\\n\\nExamples\\n\\njulia> inv(2)\\n0.5\\n\\njulia> inv(1 + 2im)\\n0.2 - 0.4im\\n\\njulia> inv(1 + 2im) * (1 + 2im)\\n1.0 + 0.0im\\n\\njulia> inv(2//3)\\n3//2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.div\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.div\",\n    \"category\": \"function\",\n    \"text\": \"div(x, y)\\n\u00f7(x, y)\\n\\nThe quotient from Euclidean division. Computes x/y, truncated to an integer.\\n\\nExamples\\n\\njulia> 9 \u00f7 4\\n2\\n\\njulia> -5 \u00f7 3\\n-1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.fld\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.fld\",\n    \"category\": \"function\",\n    \"text\": \"fld(x, y)\\n\\nLargest integer less than or equal to x/y.\\n\\nExamples\\n\\njulia> fld(7.3,5.5)\\n1.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.cld\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.cld\",\n    \"category\": \"function\",\n    \"text\": \"cld(x, y)\\n\\nSmallest integer larger than or equal to x/y.\\n\\nExamples\\n\\njulia> cld(5.5,2.2)\\n3.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.mod\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.mod\",\n    \"category\": \"function\",\n    \"text\": \"mod(x, y)\\nrem(x, y, RoundDown)\\n\\nThe reduction of x modulo y, or equivalently, the remainder of x after floored division by y, i.e.\\n\\nx - y*fld(x,y)\\n\\nif computed without intermediate rounding.\\n\\nThe result will have the same sign as y, and magnitude less than abs(y) (with some exceptions, see note below).\\n\\nnote: Note\\nWhen used with floating point values, the exact result may not be representable by the type, and so rounding error may occur. In particular, if the exact result is very close to y, then it may be rounded to y.\\n\\njulia> mod(8, 3)\\n2\\n\\njulia> mod(9, 3)\\n0\\n\\njulia> mod(8.9, 3)\\n2.9000000000000004\\n\\njulia> mod(eps(), 3)\\n2.220446049250313e-16\\n\\njulia> mod(-eps(), 3)\\n3.0\\n\\n\\n\\n\\n\\nrem(x::Integer, T::Type{<:Integer}) -> T\\nmod(x::Integer, T::Type{<:Integer}) -> T\\n%(x::Integer, T::Type{<:Integer}) -> T\\n\\nFind y::T such that x \u2261 y (mod n), where n is the number of integers representable in T, and y is an integer in [typemin(T),typemax(T)]. If T can represent any integer (e.g. T == BigInt), then this operation corresponds to a conversion to T.\\n\\nExamples\\n\\njulia> 129 % Int8\\n-127\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.rem\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.rem\",\n    \"category\": \"function\",\n    \"text\": \"rem(x, y)\\n%(x, y)\\n\\nRemainder from Euclidean division, returning a value of the same sign as x, and smaller in magnitude than y. This value is always exact.\\n\\nExamples\\n\\njulia> x = 15; y = 4;\\n\\njulia> x % y\\n3\\n\\njulia> x == div(x, y) * y + rem(x, y)\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.rem2pi\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.rem2pi\",\n    \"category\": \"function\",\n    \"text\": \"rem2pi(x, r::RoundingMode)\\n\\nCompute the remainder of x after integer division by 2\u03c0, with the quotient rounded according to the rounding mode r. In other words, the quantity\\n\\nx - 2\u03c0*round(x/(2\u03c0),r)\\n\\nwithout any intermediate rounding. This internally uses a high precision approximation of 2\u03c0, and so will give a more accurate result than rem(x,2\u03c0,r)\\n\\nif r == RoundNearest, then the result is in the interval -\u03c0 \u03c0. This will generally be the most accurate result.\\nif r == RoundToZero, then the result is in the interval 0 2\u03c0 if x is positive,. or -2\u03c0 0 otherwise.\\nif r == RoundDown, then the result is in the interval 0 2\u03c0.\\nif r == RoundUp, then the result is in the interval -2\u03c0 0.\\n\\nExamples\\n\\njulia> rem2pi(7pi/4, RoundNearest)\\n-0.7853981633974485\\n\\njulia> rem2pi(7pi/4, RoundDown)\\n5.497787143782138\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.mod2pi\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.mod2pi\",\n    \"category\": \"function\",\n    \"text\": \"mod2pi(x)\\n\\nModulus after division by 2\u03c0, returning in the range 02\u03c0).\\n\\nThis function computes a floating point representation of the modulus after division by numerically exact 2\u03c0, and is therefore not exactly the same as mod(x,2\u03c0), which would compute the modulus of x relative to division by the floating-point number 2\u03c0.\\n\\nExamples\\n\\njulia> mod2pi(9*pi/4)\\n0.7853981633974481\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.divrem\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.divrem\",\n    \"category\": \"function\",\n    \"text\": \"divrem(x, y)\\n\\nThe quotient and remainder from Euclidean division. Equivalent to (div(x,y), rem(x,y)) or (x\u00f7y, x%y).\\n\\nExamples\\n\\njulia> divrem(3,7)\\n(0, 3)\\n\\njulia> divrem(7,3)\\n(2, 1)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.fldmod\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.fldmod\",\n    \"category\": \"function\",\n    \"text\": \"fldmod(x, y)\\n\\nThe floored quotient and modulus after division. Equivalent to (fld(x,y), mod(x,y)).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.fld1\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.fld1\",\n    \"category\": \"function\",\n    \"text\": \"fld1(x, y)\\n\\nFlooring division, returning a value consistent with mod1(x,y)\\n\\nSee also: mod1, fldmod1.\\n\\nExamples\\n\\njulia> x = 15; y = 4;\\n\\njulia> fld1(x, y)\\n4\\n\\njulia> x == fld(x, y) * y + mod(x, y)\\ntrue\\n\\njulia> x == (fld1(x, y) - 1) * y + mod1(x, y)\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.mod1\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.mod1\",\n    \"category\": \"function\",\n    \"text\": \"mod1(x, y)\\n\\nModulus after flooring division, returning a value r such that mod(r, y) == mod(x, y) in the range (0 y for positive y and in the range y0) for negative y.\\n\\nSee also: fld1, fldmod1.\\n\\nExamples\\n\\njulia> mod1(4, 2)\\n2\\n\\njulia> mod1(4, 3)\\n1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.fldmod1\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.fldmod1\",\n    \"category\": \"function\",\n    \"text\": \"fldmod1(x, y)\\n\\nReturn (fld1(x,y), mod1(x,y)).\\n\\nSee also: fld1, mod1.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.://\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.://\",\n    \"category\": \"function\",\n    \"text\": \"//(num, den)\\n\\nDivide two integers or rational numbers, giving a Rational result.\\n\\nExamples\\n\\njulia> 3 // 5\\n3//5\\n\\njulia> (3 // 5) // (2 // 1)\\n3//10\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.rationalize\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.rationalize\",\n    \"category\": \"function\",\n    \"text\": \"rationalize([T<:Integer=Int,] x; tol::Real=eps(x))\\n\\nApproximate floating point number x as a Rational number with components of the given integer type. The result will differ from x by no more than tol.\\n\\nExamples\\n\\njulia> rationalize(5.6)\\n28//5\\n\\njulia> a = rationalize(BigInt, 10.3)\\n103//10\\n\\njulia> typeof(numerator(a))\\nBigInt\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.numerator\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.numerator\",\n    \"category\": \"function\",\n    \"text\": \"numerator(x)\\n\\nNumerator of the rational representation of x.\\n\\nExamples\\n\\njulia> numerator(2//3)\\n2\\n\\njulia> numerator(4)\\n4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.denominator\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.denominator\",\n    \"category\": \"function\",\n    \"text\": \"denominator(x)\\n\\nDenominator of the rational representation of x.\\n\\nExamples\\n\\njulia> denominator(2//3)\\n3\\n\\njulia> denominator(4)\\n1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:<<\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:<<\",\n    \"category\": \"function\",\n    \"text\": \"<<(x, n)\\n\\nLeft bit shift operator, x << n. For n >= 0, the result is x shifted left by n bits, filling with 0s. This is equivalent to x * 2^n. For n < 0, this is equivalent to x >> -n.\\n\\nExamples\\n\\njulia> Int8(3) << 2\\n12\\n\\njulia> bitstring(Int8(3))\\n\\\"00000011\\\"\\n\\njulia> bitstring(Int8(12))\\n\\\"00001100\\\"\\n\\nSee also >>, >>>.\\n\\n\\n\\n\\n\\n<<(B::BitVector, n) -> BitVector\\n\\nLeft bit shift operator, B << n. For n >= 0, the result is B with elements shifted n positions backwards, filling with false values. If n < 0, elements are shifted forwards. Equivalent to B >> -n.\\n\\nExamples\\n\\njulia> B = BitVector([true, false, true, false, false])\\n5-element BitArray{1}:\\n  true\\n false\\n  true\\n false\\n false\\n\\njulia> B << 1\\n5-element BitArray{1}:\\n false\\n  true\\n false\\n false\\n false\\n\\njulia> B << -1\\n5-element BitArray{1}:\\n false\\n  true\\n false\\n  true\\n false\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:>>\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:>>\",\n    \"category\": \"function\",\n    \"text\": \">>(x, n)\\n\\nRight bit shift operator, x >> n. For n >= 0, the result is x shifted right by n bits, where n >= 0, filling with 0s if x >= 0, 1s if x < 0, preserving the sign of x. This is equivalent to fld(x, 2^n). For n < 0, this is equivalent to x << -n.\\n\\nExamples\\n\\njulia> Int8(13) >> 2\\n3\\n\\njulia> bitstring(Int8(13))\\n\\\"00001101\\\"\\n\\njulia> bitstring(Int8(3))\\n\\\"00000011\\\"\\n\\njulia> Int8(-14) >> 2\\n-4\\n\\njulia> bitstring(Int8(-14))\\n\\\"11110010\\\"\\n\\njulia> bitstring(Int8(-4))\\n\\\"11111100\\\"\\n\\nSee also >>>, <<.\\n\\n\\n\\n\\n\\n>>(B::BitVector, n) -> BitVector\\n\\nRight bit shift operator, B >> n. For n >= 0, the result is B with elements shifted n positions forward, filling with false values. If n < 0, elements are shifted backwards. Equivalent to B << -n.\\n\\nExamples\\n\\njulia> B = BitVector([true, false, true, false, false])\\n5-element BitArray{1}:\\n  true\\n false\\n  true\\n false\\n false\\n\\njulia> B >> 1\\n5-element BitArray{1}:\\n false\\n  true\\n false\\n  true\\n false\\n\\njulia> B >> -1\\n5-element BitArray{1}:\\n false\\n  true\\n false\\n false\\n false\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:>>>\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:>>>\",\n    \"category\": \"function\",\n    \"text\": \">>>(x, n)\\n\\nUnsigned right bit shift operator, x >>> n. For n >= 0, the result is x shifted right by n bits, where n >= 0, filling with 0s. For n < 0, this is equivalent to x << -n.\\n\\nFor Unsigned integer types, this is equivalent to >>. For Signed integer types, this is equivalent to signed(unsigned(x) >> n).\\n\\nExamples\\n\\njulia> Int8(-14) >>> 2\\n60\\n\\njulia> bitstring(Int8(-14))\\n\\\"11110010\\\"\\n\\njulia> bitstring(Int8(60))\\n\\\"00111100\\\"\\n\\nBigInts are treated as if having infinite size, so no filling is required and this is equivalent to >>.\\n\\nSee also >>, <<.\\n\\n\\n\\n\\n\\n>>>(B::BitVector, n) -> BitVector\\n\\nUnsigned right bitshift operator, B >>> n. Equivalent to B >> n. See >> for details and examples.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.::\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.::\",\n    \"category\": \"function\",\n    \"text\": \"(:)(start, [step], stop)\\n\\nRange operator. a:b constructs a range from a to b with a step size of 1 (a UnitRange) , and a:s:b is similar but uses a step size of s (a StepRange).\\n\\n: is also used in indexing to select whole dimensions.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.range\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.range\",\n    \"category\": \"function\",\n    \"text\": \"range(start; length, stop, step=1)\\n\\nGiven a starting value, construct a range either by length or from start to stop, optionally with a given step (defaults to 1, a UnitRange). One of length or stop is required.  If length, stop, and step are all specified, they must agree.\\n\\nIf length and stop are provided and step is not, the step size will be computed automatically such that there are length linearly spaced elements in the range (a LinRange).\\n\\nIf step and stop are provided and length is not, the overall range length will be computed automatically such that the elements are step spaced (a StepRange).\\n\\nExamples\\n\\njulia> range(1, length=100)\\n1:100\\n\\njulia> range(1, stop=100)\\n1:100\\n\\njulia> range(1, step=5, length=100)\\n1:5:496\\n\\njulia> range(1, step=5, stop=100)\\n1:5:96\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.OneTo\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.OneTo\",\n    \"category\": \"type\",\n    \"text\": \"Base.OneTo(n)\\n\\nDefine an AbstractUnitRange that behaves like 1:n, with the added distinction that the lower limit is guaranteed (by the type system) to be 1.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.StepRangeLen\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.StepRangeLen\",\n    \"category\": \"type\",\n    \"text\": \"StepRangeLen{T,R,S}(ref::R, step::S, len, [offset=1]) where {T,R,S}\\nStepRangeLen(       ref::R, step::S, len, [offset=1]) where {  R,S}\\n\\nA range r where r[i] produces values of type T (in the second form, T is deduced automatically), parameterized by a reference value, a step, and the length. By default ref is the starting value r[1], but alternatively you can supply it as the value of r[offset] for some other index 1 <= offset <= len. In conjunction with TwicePrecision this can be used to implement ranges that are free of roundoff error.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:==\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:==\",\n    \"category\": \"function\",\n    \"text\": \"==(x, y)\\n\\nGeneric equality operator. Falls back to ===. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding. For collections, == is generally called recursively on all contents, though other properties (like the shape for arrays) may also be taken into account.\\n\\nThis operator follows IEEE semantics for floating-point numbers: 0.0 == -0.0 and NaN != NaN.\\n\\nThe result is of type Bool, except when one of the operands is missing, in which case missing is returned (three-valued logic). For collections, missing is returned if at least one of the operands contains a missing value and all non-missing values are equal. Use isequal or === to always get a Bool result.\\n\\nImplementation\\n\\nNew numeric types should implement this function for two arguments of the new type, and handle comparison to other types via promotion rules where possible.\\n\\nisequal falls back to ==, so new methods of == will be used by the Dict type to compare keys. If your type will be used as a dictionary key, it should therefore also implement hash.\\n\\n\\n\\n\\n\\n==(x)\\n\\nCreate a function that compares its argument to x using ==, i.e. a function equivalent to y -> y == x.\\n\\nThe returned function is of type Base.Fix2{typeof(==)}, which can be used to implement specialized methods.\\n\\n\\n\\n\\n\\n==(a::AbstractString, b::AbstractString) -> Bool\\n\\nTest whether two strings are equal character by character (technically, Unicode code point by code point).\\n\\nExamples\\n\\njulia> \\\"abc\\\" == \\\"abc\\\"\\ntrue\\n\\njulia> \\\"abc\\\" == \\\"\u03b1\u03b2\u03b3\\\"\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:!=\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:!=\",\n    \"category\": \"function\",\n    \"text\": \"!=(x, y)\\n\u2260(x,y)\\n\\nNot-equals comparison operator. Always gives the opposite answer as ==.\\n\\nImplementation\\n\\nNew types should generally not implement this, and rely on the fallback definition !=(x,y) = !(x==y) instead.\\n\\nExamples\\n\\njulia> 3 != 2\\ntrue\\n\\njulia> \\\"foo\\\" \u2260 \\\"foo\\\"\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:!==\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:!==\",\n    \"category\": \"function\",\n    \"text\": \"!==(x, y)\\n\u2262(x,y)\\n\\nAlways gives the opposite answer as ===.\\n\\nExamples\\n\\njulia> a = [1, 2]; b = [1, 2];\\n\\njulia> a \u2262 b\\ntrue\\n\\njulia> a \u2262 a\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:<\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:<\",\n    \"category\": \"function\",\n    \"text\": \"<(x, y)\\n\\nLess-than comparison operator. Falls back to isless. Because of the behavior of floating-point NaN values, this operator implements a partial order.\\n\\nImplementation\\n\\nNew numeric types with a canonical partial order should implement this function for two arguments of the new type. Types with a canonical total order should implement isless instead. (x < y) | (x == y)\\n\\nExamples\\n\\njulia> \\'a\\' < \\'b\\'\\ntrue\\n\\njulia> \\\"abc\\\" < \\\"abd\\\"\\ntrue\\n\\njulia> 5 < 3\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:<=\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:<=\",\n    \"category\": \"function\",\n    \"text\": \"<=(x, y)\\n\u2264(x,y)\\n\\nLess-than-or-equals comparison operator. Falls back to (x < y) | (x == y).\\n\\nExamples\\n\\njulia> \\'a\\' <= \\'b\\'\\ntrue\\n\\njulia> 7 \u2264 7 \u2264 9\\ntrue\\n\\njulia> \\\"abc\\\" \u2264 \\\"abc\\\"\\ntrue\\n\\njulia> 5 <= 3\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:>\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:>\",\n    \"category\": \"function\",\n    \"text\": \">(x, y)\\n\\nGreater-than comparison operator. Falls back to y < x.\\n\\nImplementation\\n\\nGenerally, new types should implement < instead of this function, and rely on the fallback definition >(x, y) = y < x.\\n\\nExamples\\n\\njulia> \\'a\\' > \\'b\\'\\nfalse\\n\\njulia> 7 > 3 > 1\\ntrue\\n\\njulia> \\\"abc\\\" > \\\"abd\\\"\\nfalse\\n\\njulia> 5 > 3\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:>=\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:>=\",\n    \"category\": \"function\",\n    \"text\": \">=(x, y)\\n\u2265(x,y)\\n\\nGreater-than-or-equals comparison operator. Falls back to y <= x.\\n\\nExamples\\n\\njulia> \\'a\\' >= \\'b\\'\\nfalse\\n\\njulia> 7 \u2265 7 \u2265 3\\ntrue\\n\\njulia> \\\"abc\\\" \u2265 \\\"abc\\\"\\ntrue\\n\\njulia> 5 >= 3\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.cmp\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.cmp\",\n    \"category\": \"function\",\n    \"text\": \"cmp(x,y)\\n\\nReturn -1, 0, or 1 depending on whether x is less than, equal to, or greater than y, respectively. Uses the total order implemented by isless.\\n\\nExamples\\n\\njulia> cmp(1, 2)\\n-1\\n\\njulia> cmp(2, 1)\\n1\\n\\njulia> cmp(2+im, 3-im)\\nERROR: MethodError: no method matching isless(::Complex{Int64}, ::Complex{Int64})\\n[...]\\n\\n\\n\\n\\n\\ncmp(<, x, y)\\n\\nReturn -1, 0, or 1 depending on whether x is less than, equal to, or greater than y, respectively. The first argument specifies a less-than comparison function to use.\\n\\n\\n\\n\\n\\ncmp(a::AbstractString, b::AbstractString) -> Int\\n\\nCompare two strings. Return 0 if both strings have the same length and the character at each index is the same in both strings. Return -1 if a is a prefix of b, or if a comes before b in alphabetical order. Return 1 if b is a prefix of a, or if b comes before a in alphabetical order (technically, lexicographical order by Unicode code points).\\n\\nExamples\\n\\njulia> cmp(\\\"abc\\\", \\\"abc\\\")\\n0\\n\\njulia> cmp(\\\"ab\\\", \\\"abc\\\")\\n-1\\n\\njulia> cmp(\\\"abc\\\", \\\"ab\\\")\\n1\\n\\njulia> cmp(\\\"ab\\\", \\\"ac\\\")\\n-1\\n\\njulia> cmp(\\\"ac\\\", \\\"ab\\\")\\n1\\n\\njulia> cmp(\\\"\u03b1\\\", \\\"a\\\")\\n1\\n\\njulia> cmp(\\\"b\\\", \\\"\u03b2\\\")\\n-1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:~\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:~\",\n    \"category\": \"function\",\n    \"text\": \"~(x)\\n\\nBitwise not.\\n\\nExamples\\n\\njulia> ~4\\n-5\\n\\njulia> ~10\\n-11\\n\\njulia> ~true\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:&\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:&\",\n    \"category\": \"function\",\n    \"text\": \"&(x, y)\\n\\nBitwise and. Implements three-valued logic, returning missing if one operand is missing and the other is true.\\n\\nExamples\\n\\njulia> 4 & 10\\n0\\n\\njulia> 4 & 12\\n4\\n\\njulia> true & missing\\nmissing\\n\\njulia> false & missing\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:|\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:|\",\n    \"category\": \"function\",\n    \"text\": \"|(x, y)\\n\\nBitwise or. Implements three-valued logic, returning missing if one operand is missing and the other is false.\\n\\nExamples\\n\\njulia> 4 | 10\\n14\\n\\njulia> 4 | 1\\n5\\n\\njulia> true | missing\\ntrue\\n\\njulia> false | missing\\nmissing\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.xor\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.xor\",\n    \"category\": \"function\",\n    \"text\": \"xor(x, y)\\n\u22bb(x, y)\\n\\nBitwise exclusive or of x and y. Implements three-valued logic, returning missing if one of the arguments is missing.\\n\\nThe infix operation a \u22bb b is a synonym for xor(a,b), and \u22bb can be typed by tab-completing \\\\xor or \\\\veebar in the Julia REPL.\\n\\nExamples\\n\\njulia> xor(true, false)\\ntrue\\n\\njulia> xor(true, true)\\nfalse\\n\\njulia> xor(true, missing)\\nmissing\\n\\njulia> false \u22bb false\\nfalse\\n\\njulia> [true; true; false] .\u22bb [true; false; false]\\n3-element BitArray{1}:\\n false\\n  true\\n false\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.:!\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.:!\",\n    \"category\": \"function\",\n    \"text\": \"!(x)\\n\\nBoolean not. Implements three-valued logic, returning missing if x is missing.\\n\\nExamples\\n\\njulia> !true\\nfalse\\n\\njulia> !false\\ntrue\\n\\njulia> !missing\\nmissing\\n\\njulia> .![true false true]\\n1\u00d73 BitArray{2}:\\n false  true  false\\n\\n\\n\\n\\n\\n!f::Function\\n\\nPredicate function negation: when the argument of ! is a function, it returns a function which computes the boolean negation of f.\\n\\nExamples\\n\\njulia> str = \\\"\u2200 \u03b5 > 0, \u2203 \u03b4 > 0: |x-y| < \u03b4 \u21d2 |f(x)-f(y)| < \u03b5\\\"\\n\\\"\u2200 \u03b5 > 0, \u2203 \u03b4 > 0: |x-y| < \u03b4 \u21d2 |f(x)-f(y)| < \u03b5\\\"\\n\\njulia> filter(isletter, str)\\n\\\"\u03b5\u03b4xy\u03b4fxfy\u03b5\\\"\\n\\njulia> filter(!isletter, str)\\n\\\"\u2200  > 0, \u2203  > 0: |-| <  \u21d2 |()-()| < \\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#&&\",\n    \"page\": \"Mathematics\",\n    \"title\": \"&&\",\n    \"category\": \"keyword\",\n    \"text\": \"x && y\\n\\nShort-circuiting boolean AND.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#||\",\n    \"page\": \"Mathematics\",\n    \"title\": \"||\",\n    \"category\": \"keyword\",\n    \"text\": \"x || y\\n\\nShort-circuiting boolean OR.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#math-ops-1\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Mathematical Operators\",\n    \"category\": \"section\",\n    \"text\": \"Base.:-(::Any)\\nBase.:(+)\\nBase.:-(::Any, ::Any)\\nBase.:*(::Any, ::Any...)\\nBase.:(/)\\nBase.:\\\\(::Any, ::Any)\\nBase.:^(::Number, ::Number)\\nBase.fma\\nBase.muladd\\nBase.inv(::Number)\\nBase.div\\nBase.fld\\nBase.cld\\nBase.mod\\nBase.rem\\nBase.rem2pi\\nBase.Math.mod2pi\\nBase.divrem\\nBase.fldmod\\nBase.fld1\\nBase.mod1\\nBase.fldmod1\\nBase.:(//)\\nBase.rationalize\\nBase.numerator\\nBase.denominator\\nBase.:(<<)\\nBase.:(>>)\\nBase.:(>>>)\\nBase.:(:)\\nBase.range\\nBase.OneTo\\nBase.StepRangeLen\\nBase.:(==)\\nBase.:(!=)\\nBase.:(!==)\\nBase.:(<)\\nBase.:(<=)\\nBase.:(>)\\nBase.:(>=)\\nBase.cmp\\nBase.:(~)\\nBase.:(&)\\nBase.:(|)\\nBase.xor\\nBase.:(!)\\n&&\\n||\"\n},\n\n{\n    \"location\": \"base/math.html#Base.isapprox\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.isapprox\",\n    \"category\": \"function\",\n    \"text\": \"isapprox(x, y; rtol::Real=atol>0 ? 0 : \u221aeps, atol::Real=0, nans::Bool=false, norm::Function)\\n\\nInexact equality comparison: true if norm(x-y) <= max(atol, rtol*max(norm(x), norm(y))). The default atol is zero and the default rtol depends on the types of x and y. The keyword argument nans determines whether or not NaN values are considered equal (defaults to false).\\n\\nFor real or complex floating-point values, if an atol > 0 is not specified, rtol defaults to the square root of eps of the type of x or y, whichever is bigger (least precise). This corresponds to requiring equality of about half of the significand digits. Otherwise, e.g. for integer arguments or if an atol > 0 is supplied, rtol defaults to zero.\\n\\nx and y may also be arrays of numbers, in which case norm defaults to vecnorm but may be changed by passing a norm::Function keyword argument. (For numbers, norm is the same thing as abs.) When x and y are arrays, if norm(x-y) is not finite (i.e. \u00b1Inf or NaN), the comparison falls back to checking whether all elements of x and y are approximately equal component-wise.\\n\\nThe binary operator \u2248 is equivalent to isapprox with the default arguments, and x \u2249 y is equivalent to !isapprox(x,y).\\n\\nNote that x \u2248 0 (i.e., comparing to zero with the default tolerances) is equivalent to x == 0 since the default atol is 0.  In such cases, you should either supply an appropriate atol (or use norm(x) \u2264 atol) or rearrange your code (e.g. use x \u2248 y rather than x - y \u2248 0).   It is not possible to pick a nonzero atol automatically because it depends on the overall scaling (the \\\"units\\\") of your problem: for example, in x - y \u2248 0, atol=1e-9 is an absurdly small tolerance if x is the radius of the Earth in meters, but an absurdly large tolerance if x is the radius of a Hydrogen atom in meters.\\n\\nExamples\\n\\njulia> 0.1 \u2248 (0.1 - 1e-10)\\ntrue\\n\\njulia> isapprox(10, 11; atol = 2)\\ntrue\\n\\njulia> isapprox([10.0^9, 1.0], [10.0^9, 2.0])\\ntrue\\n\\njulia> 1e-10 \u2248 0\\nfalse\\n\\njulia> isapprox(1e-10, 0, atol=1e-8)\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.sin-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.sin\",\n    \"category\": \"method\",\n    \"text\": \"sin(x)\\n\\nCompute sine of x, where x is in radians.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.cos-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.cos\",\n    \"category\": \"method\",\n    \"text\": \"cos(x)\\n\\nCompute cosine of x, where x is in radians.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.sincos-Tuple{Float64}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.sincos\",\n    \"category\": \"method\",\n    \"text\": \"sincos(x)\\n\\nSimultaneously compute the sine and cosine of x, where the x is in radians.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.tan-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.tan\",\n    \"category\": \"method\",\n    \"text\": \"tan(x)\\n\\nCompute tangent of x, where x is in radians.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.sind\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.sind\",\n    \"category\": \"function\",\n    \"text\": \"sind(x)\\n\\nCompute sine of x, where x is in degrees. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.cosd\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.cosd\",\n    \"category\": \"function\",\n    \"text\": \"cosd(x)\\n\\nCompute cosine of x, where x is in degrees. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.tand\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.tand\",\n    \"category\": \"function\",\n    \"text\": \"tand(x)\\n\\nCompute tangent of x, where x is in degrees. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.sinpi\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.sinpi\",\n    \"category\": \"function\",\n    \"text\": \"sinpi(x)\\n\\nCompute sin(pi x) more accurately than sin(pi*x), especially for large x.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.cospi\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.cospi\",\n    \"category\": \"function\",\n    \"text\": \"cospi(x)\\n\\nCompute cos(pi x) more accurately than cos(pi*x), especially for large x.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.sinh-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.sinh\",\n    \"category\": \"method\",\n    \"text\": \"sinh(x)\\n\\nCompute hyperbolic sine of x.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.cosh-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.cosh\",\n    \"category\": \"method\",\n    \"text\": \"cosh(x)\\n\\nCompute hyperbolic cosine of x.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.tanh-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.tanh\",\n    \"category\": \"method\",\n    \"text\": \"tanh(x)\\n\\nCompute hyperbolic tangent of x.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.asin-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.asin\",\n    \"category\": \"method\",\n    \"text\": \"asin(x)\\n\\nCompute the inverse sine of x, where the output is in radians.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.acos-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.acos\",\n    \"category\": \"method\",\n    \"text\": \"acos(x)\\n\\nCompute the inverse cosine of x, where the output is in radians\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.atan-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.atan\",\n    \"category\": \"method\",\n    \"text\": \"atan(y)\\natan(y, x)\\n\\nCompute the inverse tangent of y or y/x, respectively.\\n\\nFor one argument, this is the angle in radians between the positive x-axis and the point (1, y), returning a value in the interval -pi2 pi2.\\n\\nFor two arguments, this is the angle in radians between the positive x-axis and the point (x, y), returning a value in the interval -pi pi. This corresponds to a standard atan2 function.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.asind\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.asind\",\n    \"category\": \"function\",\n    \"text\": \"asind(x)\\n\\nCompute the inverse sine of x, where the output is in degrees. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.acosd\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.acosd\",\n    \"category\": \"function\",\n    \"text\": \"acosd(x)\\n\\nCompute the inverse cosine of x, where the output is in degrees. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.atand\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.atand\",\n    \"category\": \"function\",\n    \"text\": \"atand(y)\\natand(y,x)\\n\\nCompute the inverse tangent of y or y/x, respectively, where the output is in degrees.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.sec-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.sec\",\n    \"category\": \"method\",\n    \"text\": \"sec(x)\\n\\nCompute the secant of x, where x is in radians.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.csc-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.csc\",\n    \"category\": \"method\",\n    \"text\": \"csc(x)\\n\\nCompute the cosecant of x, where x is in radians.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.cot-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.cot\",\n    \"category\": \"method\",\n    \"text\": \"cot(x)\\n\\nCompute the cotangent of x, where x is in radians.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.secd\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.secd\",\n    \"category\": \"function\",\n    \"text\": \"secd(x)\\n\\nCompute the secant of x, where x is in degrees.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.cscd\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.cscd\",\n    \"category\": \"function\",\n    \"text\": \"cscd(x)\\n\\nCompute the cosecant of x, where x is in degrees.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.cotd\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.cotd\",\n    \"category\": \"function\",\n    \"text\": \"cotd(x)\\n\\nCompute the cotangent of x, where x is in degrees.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.asec-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.asec\",\n    \"category\": \"method\",\n    \"text\": \"asec(x)\\n\\nCompute the inverse secant of x, where the output is in radians. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.acsc-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.acsc\",\n    \"category\": \"method\",\n    \"text\": \"acsc(x)\\n\\nCompute the inverse cosecant of x, where the output is in radians. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.acot-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.acot\",\n    \"category\": \"method\",\n    \"text\": \"acot(x)\\n\\nCompute the inverse cotangent of x, where the output is in radians. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.asecd\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.asecd\",\n    \"category\": \"function\",\n    \"text\": \"asecd(x)\\n\\nCompute the inverse secant of x, where the output is in degrees. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.acscd\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.acscd\",\n    \"category\": \"function\",\n    \"text\": \"acscd(x)\\n\\nCompute the inverse cosecant of x, where the output is in degrees. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.acotd\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.acotd\",\n    \"category\": \"function\",\n    \"text\": \"acotd(x)\\n\\nCompute the inverse cotangent of x, where the output is in degrees. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.sech-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.sech\",\n    \"category\": \"method\",\n    \"text\": \"sech(x)\\n\\nCompute the hyperbolic secant of x.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.csch-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.csch\",\n    \"category\": \"method\",\n    \"text\": \"csch(x)\\n\\nCompute the hyperbolic cosecant of x.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.coth-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.coth\",\n    \"category\": \"method\",\n    \"text\": \"coth(x)\\n\\nCompute the hyperbolic cotangent of x.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.asinh-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.asinh\",\n    \"category\": \"method\",\n    \"text\": \"asinh(x)\\n\\nCompute the inverse hyperbolic sine of x.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.acosh-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.acosh\",\n    \"category\": \"method\",\n    \"text\": \"acosh(x)\\n\\nCompute the inverse hyperbolic cosine of x.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.atanh-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.atanh\",\n    \"category\": \"method\",\n    \"text\": \"atanh(x)\\n\\nCompute the inverse hyperbolic tangent of x.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.asech-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.asech\",\n    \"category\": \"method\",\n    \"text\": \"asech(x)\\n\\nCompute the inverse hyperbolic secant of x. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.acsch-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.acsch\",\n    \"category\": \"method\",\n    \"text\": \"acsch(x)\\n\\nCompute the inverse hyperbolic cosecant of x. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.acoth-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.acoth\",\n    \"category\": \"method\",\n    \"text\": \"acoth(x)\\n\\nCompute the inverse hyperbolic cotangent of x. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.sinc\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.sinc\",\n    \"category\": \"function\",\n    \"text\": \"sinc(x)\\n\\nCompute sin(pi x)  (pi x) if x neq 0, and 1 if x = 0.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.cosc\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.cosc\",\n    \"category\": \"function\",\n    \"text\": \"cosc(x)\\n\\nCompute cos(pi x)  x - sin(pi x)  (pi x^2) if x neq 0, and 0 if x = 0. This is the derivative of sinc(x).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.deg2rad\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.deg2rad\",\n    \"category\": \"function\",\n    \"text\": \"deg2rad(x)\\n\\nConvert x from degrees to radians.\\n\\nExamples\\n\\njulia> deg2rad(90)\\n1.5707963267948966\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.rad2deg\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.rad2deg\",\n    \"category\": \"function\",\n    \"text\": \"rad2deg(x)\\n\\nConvert x from radians to degrees.\\n\\nExamples\\n\\njulia> rad2deg(pi)\\n180.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.hypot\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.hypot\",\n    \"category\": \"function\",\n    \"text\": \"hypot(x, y)\\n\\nCompute the hypotenuse sqrtx^2+y^2 avoiding overflow and underflow.\\n\\nExamples\\n\\njulia> a = 10^10;\\n\\njulia> hypot(a, a)\\n1.4142135623730951e10\\n\\njulia> \u221a(a^2 + a^2) # a^2 overflows\\nERROR: DomainError with -2.914184810805068e18:\\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\\nStacktrace:\\n[...]\\n\\n\\n\\n\\n\\nhypot(x...)\\n\\nCompute the hypotenuse sqrtsum x_i^2 avoiding overflow and underflow.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.log-Tuple{Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.log\",\n    \"category\": \"method\",\n    \"text\": \"log(x)\\n\\nCompute the natural logarithm of x. Throws DomainError for negative Real arguments. Use complex negative arguments to obtain complex results.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.log-Tuple{Number,Number}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.log\",\n    \"category\": \"method\",\n    \"text\": \"log(b,x)\\n\\nCompute the base b logarithm of x. Throws DomainError for negative Real arguments.\\n\\nExamples\\n\\njulia> log(4,8)\\n1.5\\n\\njulia> log(4,2)\\n0.5\\n\\njulia> log(-2, 3)\\nERROR: DomainError with log:\\n-2.0 will only return a complex result if called with a complex argument. Try -2.0(Complex(x)).\\nStacktrace:\\n [1] throw_complex_domainerror(::Float64, ::Symbol) at ./math.jl:31\\n[...]\\n\\njulia> log(2, -3)\\nERROR: DomainError with log:\\n-3.0 will only return a complex result if called with a complex argument. Try -3.0(Complex(x)).\\nStacktrace:\\n [1] throw_complex_domainerror(::Float64, ::Symbol) at ./math.jl:31\\n[...]\\n\\nnote: Note\\nIf b is a power of 2 or 10, log2 or log10 should be used, as these will typically be faster and more accurate. For example,julia> log(100,1000000)\\n2.9999999999999996\\n\\njulia> log10(1000000)/2\\n3.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.log2\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.log2\",\n    \"category\": \"function\",\n    \"text\": \"log2(x)\\n\\nCompute the logarithm of x to base 2. Throws DomainError for negative Real arguments.\\n\\nExamples\\n\\njulia> log2(4)\\n2.0\\n\\njulia> log2(10)\\n3.321928094887362\\n\\njulia> log2(-2)\\nERROR: DomainError with -2.0:\\nNaN result for non-NaN input.\\nStacktrace:\\n [1] nan_dom_err at ./math.jl:325 [inlined]\\n[...]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.log10\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.log10\",\n    \"category\": \"function\",\n    \"text\": \"log10(x)\\n\\nCompute the logarithm of x to base 10. Throws DomainError for negative Real arguments.\\n\\nExamples\\n\\njulia> log10(100)\\n2.0\\n\\njulia> log10(2)\\n0.3010299956639812\\n\\njulia> log10(-2)\\nERROR: DomainError with -2.0:\\nNaN result for non-NaN input.\\nStacktrace:\\n [1] nan_dom_err at ./math.jl:325 [inlined]\\n[...]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.log1p\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.log1p\",\n    \"category\": \"function\",\n    \"text\": \"log1p(x)\\n\\nAccurate natural logarithm of 1+x. Throws DomainError for Real arguments less than -1.\\n\\nExamples\\n\\njulia> log1p(-0.5)\\n-0.6931471805599453\\n\\njulia> log1p(0)\\n0.0\\n\\njulia> log1p(-2)\\nERROR: DomainError with log1p:\\n-2.0 will only return a complex result if called with a complex argument. Try -2.0(Complex(x)).\\nStacktrace:\\n [1] throw_complex_domainerror(::Float64, ::Symbol) at ./math.jl:31\\n[...]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.frexp\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.frexp\",\n    \"category\": \"function\",\n    \"text\": \"frexp(val)\\n\\nReturn (x,exp) such that x has a magnitude in the interval 12 1) or 0, and val is equal to x times 2^exp.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.exp-Tuple{Float64}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.exp\",\n    \"category\": \"method\",\n    \"text\": \"exp(x)\\n\\nCompute the natural base exponential of x, in other words e^x.\\n\\nExamples\\n\\njulia> exp(1.0)\\n2.718281828459045\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.exp2\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.exp2\",\n    \"category\": \"function\",\n    \"text\": \"exp2(x)\\n\\nCompute the base 2 exponential of x, in other words 2^x.\\n\\nExamples\\n\\njulia> exp2(5)\\n32.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.exp10\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.exp10\",\n    \"category\": \"function\",\n    \"text\": \"exp10(x)\\n\\nCompute the base 10 exponential of x, in other words 10^x.\\n\\nExamples\\n\\njulia> exp10(2)\\n100.0\\n\\n\\n\\n\\n\\nexp10(x)\\n\\nCompute 10^x.\\n\\nExamples\\n\\njulia> exp10(2)\\n100.0\\n\\njulia> exp10(0.2)\\n1.5848931924611136\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.ldexp\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.ldexp\",\n    \"category\": \"function\",\n    \"text\": \"ldexp(x, n)\\n\\nCompute x times 2^n.\\n\\nExamples\\n\\njulia> ldexp(5., 2)\\n20.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.modf\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.modf\",\n    \"category\": \"function\",\n    \"text\": \"modf(x)\\n\\nReturn a tuple (fpart, ipart) of the fractional and integral parts of a number. Both parts have the same sign as the argument.\\n\\nExamples\\n\\njulia> modf(3.5)\\n(0.5, 3.0)\\n\\njulia> modf(-3.5)\\n(-0.5, -3.0)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.expm1\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.expm1\",\n    \"category\": \"function\",\n    \"text\": \"expm1(x)\\n\\nAccurately compute e^x-1.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.round-Tuple{Type,Any}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.round\",\n    \"category\": \"method\",\n    \"text\": \"round([T,] x, [r::RoundingMode])\\nround(x, [r::RoundingMode]; digits::Integer=0, base = 10)\\nround(x, [r::RoundingMode]; sigdigits::Integer, base = 10)\\n\\nRounds the number x.\\n\\nWithout keyword arguments, x is rounded to an integer value, returning a value of type T, or of the same type of x if no T is provided. An InexactError will be thrown if the value is not representable by T, similar to convert.\\n\\nIf the digits keyword argument is provided, it rounds to the specified number of digits after the decimal place (or before if negative), in base base.\\n\\nIf the sigdigits keyword argument is provided, it rounds to the specified number of significant digits, in base base.\\n\\nThe RoundingMode r controls the direction of the rounding; the default is RoundNearest, which rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer. Note that round may give incorrect results if the global rounding mode is changed (see rounding).\\n\\nExamples\\n\\njulia> round(1.7)\\n2.0\\n\\njulia> round(Int, 1.7)\\n2\\n\\njulia> round(1.5)\\n2.0\\n\\njulia> round(2.5)\\n2.0\\n\\njulia> round(pi; digits=2)\\n3.14\\n\\njulia> round(pi; digits=3, base=2)\\n3.125\\n\\njulia> round(123.456; sigdigits=2)\\n120.0\\n\\njulia> round(357.913; sigdigits=4, base=2)\\n352.0\\n\\nnote: Note\\nRounding to specified digits in bases other than 2 can be inexact when operating on binary floating point numbers. For example, the Float64 value represented by 1.15 is actually less than 1.15, yet will be rounded to 1.2.Examplesjulia> x = 1.15\\n1.15\\n\\njulia> @sprintf \\\"%.20f\\\" x\\n\\\"1.14999999999999991118\\\"\\n\\njulia> x < 115//100\\ntrue\\n\\njulia> round(x, digits=1)\\n1.2\\n\\nExtensions\\n\\nTo extend round to new numeric types, it is typically sufficient to define Base.round(x::NewType, r::RoundingMode).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Rounding.RoundingMode\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Rounding.RoundingMode\",\n    \"category\": \"type\",\n    \"text\": \"RoundingMode\\n\\nA type used for controlling the rounding mode of floating point operations (via rounding/setrounding functions), or as optional arguments for rounding to the nearest integer (via the round function).\\n\\nCurrently supported rounding modes are:\\n\\nRoundNearest (default)\\nRoundNearestTiesAway\\nRoundNearestTiesUp\\nRoundToZero\\nRoundFromZero (BigFloat only)\\nRoundUp\\nRoundDown\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Rounding.RoundNearest\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Rounding.RoundNearest\",\n    \"category\": \"constant\",\n    \"text\": \"RoundNearest\\n\\nThe default rounding mode. Rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Rounding.RoundNearestTiesAway\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Rounding.RoundNearestTiesAway\",\n    \"category\": \"constant\",\n    \"text\": \"RoundNearestTiesAway\\n\\nRounds to nearest integer, with ties rounded away from zero (C/C++ round behaviour).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Rounding.RoundNearestTiesUp\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Rounding.RoundNearestTiesUp\",\n    \"category\": \"constant\",\n    \"text\": \"RoundNearestTiesUp\\n\\nRounds to nearest integer, with ties rounded toward positive infinity (Java/JavaScript round behaviour).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Rounding.RoundToZero\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Rounding.RoundToZero\",\n    \"category\": \"constant\",\n    \"text\": \"RoundToZero\\n\\nround using this rounding mode is an alias for trunc.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Rounding.RoundFromZero\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Rounding.RoundFromZero\",\n    \"category\": \"constant\",\n    \"text\": \"RoundFromZero\\n\\nRounds away from zero. This rounding mode may only be used with T == BigFloat inputs to round.\\n\\nExamples\\n\\njulia> BigFloat(\\\"1.0000000000000001\\\", 5, RoundFromZero)\\n1.06\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Rounding.RoundUp\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Rounding.RoundUp\",\n    \"category\": \"constant\",\n    \"text\": \"RoundUp\\n\\nround using this rounding mode is an alias for ceil.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Rounding.RoundDown\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Rounding.RoundDown\",\n    \"category\": \"constant\",\n    \"text\": \"RoundDown\\n\\nround using this rounding mode is an alias for floor.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.round-Tuple{Complex{#s37} where #s37<:AbstractFloat,RoundingMode,RoundingMode}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.round\",\n    \"category\": \"method\",\n    \"text\": \"round(z::Complex[, RoundingModeReal, [RoundingModeImaginary]])\\nround(z::Complex[, RoundingModeReal, [RoundingModeImaginary]]; digits=, base=10)\\nround(z::Complex[, RoundingModeReal, [RoundingModeImaginary]]; sigdigits=, base=10)\\n\\nReturn the nearest integral value of the same type as the complex-valued z to z, breaking ties using the specified RoundingModes. The first RoundingMode is used for rounding the real components while the second is used for rounding the imaginary components.\\n\\nExample\\n\\njulia> round(3.14 + 4.5im)\\n3.0 + 4.0im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.ceil\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.ceil\",\n    \"category\": \"function\",\n    \"text\": \"ceil([T,] x)\\nceil(x; digits::Integer= [, base = 10])\\nceil(x; sigdigits::Integer= [, base = 10])\\n\\nceil(x) returns the nearest integral value of the same type as x that is greater than or equal to x.\\n\\nceil(T, x) converts the result to type T, throwing an InexactError if the value is not representable.\\n\\ndigits, sigdigits and base work as for round.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.floor\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.floor\",\n    \"category\": \"function\",\n    \"text\": \"floor([T,] x)\\nfloor(x; digits::Integer= [, base = 10])\\nfloor(x; sigdigits::Integer= [, base = 10])\\n\\nfloor(x) returns the nearest integral value of the same type as x that is less than or equal to x.\\n\\nfloor(T, x) converts the result to type T, throwing an InexactError if the value is not representable.\\n\\ndigits, sigdigits and base work as for round.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.trunc\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.trunc\",\n    \"category\": \"function\",\n    \"text\": \"trunc([T,] x)\\ntrunc(x; digits::Integer= [, base = 10])\\ntrunc(x; sigdigits::Integer= [, base = 10])\\n\\ntrunc(x) returns the nearest integral value of the same type as x whose absolute value is less than or equal to x.\\n\\ntrunc(T, x) converts the result to type T, throwing an InexactError if the value is not representable.\\n\\ndigits, sigdigits and base work as for round.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.unsafe_trunc\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.unsafe_trunc\",\n    \"category\": \"function\",\n    \"text\": \"unsafe_trunc(T, x)\\n\\nReturn the nearest integral value of type T whose absolute value is less than or equal to x. If the value is not representable by T, an arbitrary value will be returned.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.min\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.min\",\n    \"category\": \"function\",\n    \"text\": \"min(x, y, ...)\\n\\nReturn the minimum of the arguments. See also the minimum function to take the minimum element from a collection.\\n\\nExamples\\n\\njulia> min(2, 5, 1)\\n1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.max\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.max\",\n    \"category\": \"function\",\n    \"text\": \"max(x, y, ...)\\n\\nReturn the maximum of the arguments. See also the maximum function to take the maximum element from a collection.\\n\\nExamples\\n\\njulia> max(2, 5, 1)\\n5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.minmax\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.minmax\",\n    \"category\": \"function\",\n    \"text\": \"minmax(x, y)\\n\\nReturn (min(x,y), max(x,y)). See also: extrema that returns (minimum(x), maximum(x)).\\n\\nExamples\\n\\njulia> minmax(\\'c\\',\\'b\\')\\n(\\'b\\', \\'c\\')\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.clamp\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.clamp\",\n    \"category\": \"function\",\n    \"text\": \"clamp(x, lo, hi)\\n\\nReturn x if lo <= x <= hi. If x > hi, return hi. If x < lo, return lo. Arguments are promoted to a common type.\\n\\nExamples\\n\\njulia> clamp.([pi, 1.0, big(10.)], 2., 9.)\\n3-element Array{BigFloat,1}:\\n 3.141592653589793238462643383279502884197169399375105820974944592307816406286198\\n 2.0\\n 9.0\\n\\njulia> clamp.([11,8,5],10,6) # an example where lo > hi\\n3-element Array{Int64,1}:\\n  6\\n  6\\n 10\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.clamp!\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.clamp!\",\n    \"category\": \"function\",\n    \"text\": \"clamp!(array::AbstractArray, lo, hi)\\n\\nRestrict values in array to the specified range, in-place. See also clamp.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.abs\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.abs\",\n    \"category\": \"function\",\n    \"text\": \"abs(x)\\n\\nThe absolute value of x.\\n\\nWhen abs is applied to signed integers, overflow may occur, resulting in the return of a negative value. This overflow occurs only when abs is applied to the minimum representable value of a signed integer. That is, when x == typemin(typeof(x)), abs(x) == x < 0, not -x as might be expected.\\n\\nExamples\\n\\njulia> abs(-3)\\n3\\n\\njulia> abs(1 + im)\\n1.4142135623730951\\n\\njulia> abs(typemin(Int64))\\n-9223372036854775808\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Checked.checked_abs\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Checked.checked_abs\",\n    \"category\": \"function\",\n    \"text\": \"Base.checked_abs(x)\\n\\nCalculates abs(x), checking for overflow errors where applicable. For example, standard two\\'s complement signed integers (e.g. Int) cannot represent abs(typemin(Int)), thus leading to an overflow.\\n\\nThe overflow protection may impose a perceptible performance penalty.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Checked.checked_neg\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Checked.checked_neg\",\n    \"category\": \"function\",\n    \"text\": \"Base.checked_neg(x)\\n\\nCalculates -x, checking for overflow errors where applicable. For example, standard two\\'s complement signed integers (e.g. Int) cannot represent -typemin(Int), thus leading to an overflow.\\n\\nThe overflow protection may impose a perceptible performance penalty.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Checked.checked_add\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Checked.checked_add\",\n    \"category\": \"function\",\n    \"text\": \"Base.checked_add(x, y)\\n\\nCalculates x+y, checking for overflow errors where applicable.\\n\\nThe overflow protection may impose a perceptible performance penalty.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Checked.checked_sub\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Checked.checked_sub\",\n    \"category\": \"function\",\n    \"text\": \"Base.checked_sub(x, y)\\n\\nCalculates x-y, checking for overflow errors where applicable.\\n\\nThe overflow protection may impose a perceptible performance penalty.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Checked.checked_mul\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Checked.checked_mul\",\n    \"category\": \"function\",\n    \"text\": \"Base.checked_mul(x, y)\\n\\nCalculates x*y, checking for overflow errors where applicable.\\n\\nThe overflow protection may impose a perceptible performance penalty.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Checked.checked_div\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Checked.checked_div\",\n    \"category\": \"function\",\n    \"text\": \"Base.checked_div(x, y)\\n\\nCalculates div(x,y), checking for overflow errors where applicable.\\n\\nThe overflow protection may impose a perceptible performance penalty.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Checked.checked_rem\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Checked.checked_rem\",\n    \"category\": \"function\",\n    \"text\": \"Base.checked_rem(x, y)\\n\\nCalculates x%y, checking for overflow errors where applicable.\\n\\nThe overflow protection may impose a perceptible performance penalty.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Checked.checked_fld\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Checked.checked_fld\",\n    \"category\": \"function\",\n    \"text\": \"Base.checked_fld(x, y)\\n\\nCalculates fld(x,y), checking for overflow errors where applicable.\\n\\nThe overflow protection may impose a perceptible performance penalty.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Checked.checked_mod\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Checked.checked_mod\",\n    \"category\": \"function\",\n    \"text\": \"Base.checked_mod(x, y)\\n\\nCalculates mod(x,y), checking for overflow errors where applicable.\\n\\nThe overflow protection may impose a perceptible performance penalty.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Checked.checked_cld\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Checked.checked_cld\",\n    \"category\": \"function\",\n    \"text\": \"Base.checked_cld(x, y)\\n\\nCalculates cld(x,y), checking for overflow errors where applicable.\\n\\nThe overflow protection may impose a perceptible performance penalty.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Checked.add_with_overflow\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Checked.add_with_overflow\",\n    \"category\": \"function\",\n    \"text\": \"Base.add_with_overflow(x, y) -> (r, f)\\n\\nCalculates r = x+y, with the flag f indicating whether overflow has occurred.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Checked.sub_with_overflow\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Checked.sub_with_overflow\",\n    \"category\": \"function\",\n    \"text\": \"Base.sub_with_overflow(x, y) -> (r, f)\\n\\nCalculates r = x-y, with the flag f indicating whether overflow has occurred.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Checked.mul_with_overflow\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Checked.mul_with_overflow\",\n    \"category\": \"function\",\n    \"text\": \"Base.mul_with_overflow(x, y) -> (r, f)\\n\\nCalculates r = x*y, with the flag f indicating whether overflow has occurred.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.abs2\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.abs2\",\n    \"category\": \"function\",\n    \"text\": \"abs2(x)\\n\\nSquared absolute value of x.\\n\\nExamples\\n\\njulia> abs2(-3)\\n9\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.copysign\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.copysign\",\n    \"category\": \"function\",\n    \"text\": \"copysign(x, y) -> z\\n\\nReturn z which has the magnitude of x and the same sign as y.\\n\\nExamples\\n\\njulia> copysign(1, -2)\\n-1\\n\\njulia> copysign(-1, 2)\\n1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.sign\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.sign\",\n    \"category\": \"function\",\n    \"text\": \"sign(x)\\n\\nReturn zero if x==0 and xx otherwise (i.e., \u00b11 for real x).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.signbit\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.signbit\",\n    \"category\": \"function\",\n    \"text\": \"signbit(x)\\n\\nReturns true if the value of the sign of x is negative, otherwise false.\\n\\nExamples\\n\\njulia> signbit(-4)\\ntrue\\n\\njulia> signbit(5)\\nfalse\\n\\njulia> signbit(5.5)\\nfalse\\n\\njulia> signbit(-4.1)\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.flipsign\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.flipsign\",\n    \"category\": \"function\",\n    \"text\": \"flipsign(x, y)\\n\\nReturn x with its sign flipped if y is negative. For example abs(x) = flipsign(x,x).\\n\\nExamples\\n\\njulia> flipsign(5, 3)\\n5\\n\\njulia> flipsign(5, -3)\\n-5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.sqrt-Tuple{Real}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.sqrt\",\n    \"category\": \"method\",\n    \"text\": \"sqrt(x)\\n\\nReturn sqrtx. Throws DomainError for negative Real arguments. Use complex negative arguments instead. The prefix operator \u221a is equivalent to sqrt.\\n\\nExamples\\n\\njulia> sqrt(big(81))\\n9.0\\n\\njulia> sqrt(big(-81))\\nERROR: DomainError with -8.1e+01:\\nNaN result for non-NaN input.\\nStacktrace:\\n [1] sqrt(::BigFloat) at ./mpfr.jl:501\\n[...]\\n\\njulia> sqrt(big(complex(-81)))\\n0.0 + 9.0im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.isqrt\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.isqrt\",\n    \"category\": \"function\",\n    \"text\": \"isqrt(n::Integer)\\n\\nInteger square root: the largest integer m such that m*m <= n.\\n\\njulia> isqrt(5)\\n2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.cbrt\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.cbrt\",\n    \"category\": \"function\",\n    \"text\": \"cbrt(x::Real)\\n\\nReturn the cube root of x, i.e. x^13. Negative values are accepted (returning the negative real root when x  0).\\n\\nThe prefix operator \u221b is equivalent to cbrt.\\n\\nExamples\\n\\njulia> cbrt(big(27))\\n3.0\\n\\njulia> cbrt(big(-27))\\n-3.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.real-Tuple{Complex}\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.real\",\n    \"category\": \"method\",\n    \"text\": \"real(z)\\n\\nReturn the real part of the complex number z.\\n\\nExamples\\n\\njulia> real(1 + 3im)\\n1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.imag\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.imag\",\n    \"category\": \"function\",\n    \"text\": \"imag(z)\\n\\nReturn the imaginary part of the complex number z.\\n\\nExamples\\n\\njulia> imag(1 + 3im)\\n3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.reim\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.reim\",\n    \"category\": \"function\",\n    \"text\": \"reim(z)\\n\\nReturn both the real and imaginary parts of the complex number z.\\n\\nExamples\\n\\njulia> reim(1 + 3im)\\n(1, 3)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.conj\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.conj\",\n    \"category\": \"function\",\n    \"text\": \"conj(z)\\n\\nCompute the complex conjugate of a complex number z.\\n\\nExamples\\n\\njulia> conj(1 + 3im)\\n1 - 3im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.angle\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.angle\",\n    \"category\": \"function\",\n    \"text\": \"angle(z)\\n\\nCompute the phase angle in radians of a complex number z.\\n\\nExamples\\n\\njulia> rad2deg(angle(1 + im))\\n45.0\\n\\njulia> rad2deg(angle(1 - im))\\n-45.0\\n\\njulia> rad2deg(angle(-1 - im))\\n-135.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.cis\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.cis\",\n    \"category\": \"function\",\n    \"text\": \"cis(z)\\n\\nReturn exp(iz).\\n\\nExamples\\n\\njulia> cis(\u03c0) \u2248 -1\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.binomial\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.binomial\",\n    \"category\": \"function\",\n    \"text\": \"binomial(n::Integer, k::Integer)\\n\\nThe binomial coefficient inomnk, being the coefficient of the kth term in the polynomial expansion of (1+x)^n.\\n\\nIf n is non-negative, then it is the number of ways to choose k out of n items:\\n\\ninomnk = \fracnk (n-k)\\n\\nwhere n is the factorial function.\\n\\nIf n is negative, then it is defined in terms of the identity\\n\\ninomnk = (-1)^k inomk-n-1k\\n\\nExamples\\n\\njulia> binomial(5, 3)\\n10\\n\\njulia> factorial(5) \u00f7 (factorial(5-3) * factorial(3))\\n10\\n\\njulia> binomial(-5, 3)\\n-35\\n\\nSee also\\n\\nfactorial\\n\\nExternal links\\n\\nBinomial coeffient on Wikipedia.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.factorial\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.factorial\",\n    \"category\": \"function\",\n    \"text\": \"factorial(n::Integer)\\n\\nFactorial of n. If n is an Integer, the factorial is computed as an integer (promoted to at least 64 bits). Note that this may overflow if n is not small, but you can use factorial(big(n)) to compute the result exactly in arbitrary precision.\\n\\nExamples\\n\\njulia> factorial(6)\\n720\\n\\njulia> factorial(21)\\nERROR: OverflowError: 21 is too large to look up in the table\\nStacktrace:\\n[...]\\n\\njulia> factorial(big(21))\\n51090942171709440000\\n\\nSee also\\n\\nbinomial\\n\\nExternal links\\n\\nFactorial on Wikipedia.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.gcd\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.gcd\",\n    \"category\": \"function\",\n    \"text\": \"gcd(x,y)\\n\\nGreatest common (positive) divisor (or zero if x and y are both zero).\\n\\nExamples\\n\\njulia> gcd(6,9)\\n3\\n\\njulia> gcd(6,-9)\\n3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.lcm\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.lcm\",\n    \"category\": \"function\",\n    \"text\": \"lcm(x,y)\\n\\nLeast common (non-negative) multiple.\\n\\nExamples\\n\\njulia> lcm(2,3)\\n6\\n\\njulia> lcm(-2,3)\\n6\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.gcdx\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.gcdx\",\n    \"category\": \"function\",\n    \"text\": \"gcdx(x,y)\\n\\nComputes the greatest common (positive) divisor of x and y and their B\u00e9zout coefficients, i.e. the integer coefficients u and v that satisfy ux+vy = d = gcd(xy). gcdx(xy) returns (duv).\\n\\nExamples\\n\\njulia> gcdx(12, 42)\\n(6, -3, 1)\\n\\njulia> gcdx(240, 46)\\n(2, -9, 47)\\n\\nnote: Note\\nB\u00e9zout coefficients are not uniquely defined. gcdx returns the minimal B\u00e9zout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients u and v are minimal in the sense that u  yd and v  xd. Furthermore, the signs of u and v are chosen so that d is positive. For unsigned integers, the coefficients u and v might be near their typemax, and the identity then holds only via the unsigned integers\\' modulo arithmetic.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.ispow2\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.ispow2\",\n    \"category\": \"function\",\n    \"text\": \"ispow2(n::Integer) -> Bool\\n\\nTest whether n is a power of two.\\n\\nExamples\\n\\njulia> ispow2(4)\\ntrue\\n\\njulia> ispow2(5)\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.nextpow\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.nextpow\",\n    \"category\": \"function\",\n    \"text\": \"nextpow(a, x)\\n\\nThe smallest a^n not less than x, where n is a non-negative integer. a must be greater than 1, and x must be greater than 0.\\n\\nExamples\\n\\njulia> nextpow(2, 7)\\n8\\n\\njulia> nextpow(2, 9)\\n16\\n\\njulia> nextpow(5, 20)\\n25\\n\\njulia> nextpow(4, 16)\\n16\\n\\nSee also prevpow.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.prevpow\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.prevpow\",\n    \"category\": \"function\",\n    \"text\": \"prevpow(a, x)\\n\\nThe largest a^n not greater than x, where n is a non-negative integer. a must be greater than 1, and x must not be less than 1.\\n\\nExamples\\n\\njulia> prevpow(2, 7)\\n4\\n\\njulia> prevpow(2, 9)\\n8\\n\\njulia> prevpow(5, 20)\\n5\\n\\njulia> prevpow(4, 16)\\n16\\n\\nSee also nextpow.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.nextprod\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.nextprod\",\n    \"category\": \"function\",\n    \"text\": \"nextprod([k_1, k_2,...], n)\\n\\nNext integer greater than or equal to n that can be written as prod k_i^p_i for integers p_1, p_2, etc.\\n\\nExamples\\n\\njulia> nextprod([2, 3], 105)\\n108\\n\\njulia> 2^2 * 3^3\\n108\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.invmod\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.invmod\",\n    \"category\": \"function\",\n    \"text\": \"invmod(x,m)\\n\\nTake the inverse of x modulo m: y such that x y = 1 pmod m, with div(xy) = 0. This is undefined for m = 0, or if gcd(xm) neq 1.\\n\\nExamples\\n\\njulia> invmod(2,5)\\n3\\n\\njulia> invmod(2,3)\\n2\\n\\njulia> invmod(5,6)\\n5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.powermod\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.powermod\",\n    \"category\": \"function\",\n    \"text\": \"powermod(x::Integer, p::Integer, m)\\n\\nCompute x^p pmod m.\\n\\nExamples\\n\\njulia> powermod(2, 6, 5)\\n4\\n\\njulia> mod(2^6, 5)\\n4\\n\\njulia> powermod(5, 2, 20)\\n5\\n\\njulia> powermod(5, 2, 19)\\n6\\n\\njulia> powermod(5, 3, 19)\\n11\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.ndigits\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.ndigits\",\n    \"category\": \"function\",\n    \"text\": \"ndigits(n::Integer; base::Integer=10, pad::Integer=1)\\n\\nCompute the number of digits in integer n written in base base (base must not be in [-1, 0, 1]), optionally padded with zeros to a specified size (the result will never be less than pad).\\n\\nExamples\\n\\njulia> ndigits(12345)\\n5\\n\\njulia> ndigits(1022, base=16)\\n3\\n\\njulia> string(1022, base=16)\\n\\\"3fe\\\"\\n\\njulia> ndigits(123, pad=5)\\n5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.widemul\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.widemul\",\n    \"category\": \"function\",\n    \"text\": \"widemul(x, y)\\n\\nMultiply x and y, giving the result as a larger type.\\n\\nExamples\\n\\njulia> widemul(Float32(3.), 4.)\\n1.2e+01\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.Math.@evalpoly\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.Math.@evalpoly\",\n    \"category\": \"macro\",\n    \"text\": \"@evalpoly(z, c...)\\n\\nEvaluate the polynomial sum_k ck z^k-1 for the coefficients c[1], c[2], ...; that is, the coefficients are given in ascending order by power of z.  This macro expands to efficient inline code that uses either Horner\\'s method or, for complex z, a more efficient Goertzel-like algorithm.\\n\\nExamples\\n\\njulia> @evalpoly(3, 1, 0, 1)\\n10\\n\\njulia> @evalpoly(2, 1, 0, 1)\\n5\\n\\njulia> @evalpoly(2, 1, 1, 1)\\n7\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Base.FastMath.@fastmath\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Base.FastMath.@fastmath\",\n    \"category\": \"macro\",\n    \"text\": \"@fastmath expr\\n\\nExecute a transformed version of the expression, which calls functions that may violate strict IEEE semantics. This allows the fastest possible operation, but results are undefined \u2013 be careful when doing this, as it may change numerical results.\\n\\nThis sets the LLVM Fast-Math flags, and corresponds to the -ffast-math option in clang. See the notes on performance annotations for more details.\\n\\nExamples\\n\\njulia> @fastmath 1+2\\n3\\n\\njulia> @fastmath(sin(3))\\n0.1411200080598672\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/math.html#Mathematical-Functions-1\",\n    \"page\": \"Mathematics\",\n    \"title\": \"Mathematical Functions\",\n    \"category\": \"section\",\n    \"text\": \"Base.isapprox\\nBase.sin(::Number)\\nBase.cos(::Number)\\nBase.sincos(::Float64)\\nBase.tan(::Number)\\nBase.Math.sind\\nBase.Math.cosd\\nBase.Math.tand\\nBase.Math.sinpi\\nBase.Math.cospi\\nBase.sinh(::Number)\\nBase.cosh(::Number)\\nBase.tanh(::Number)\\nBase.asin(::Number)\\nBase.acos(::Number)\\nBase.atan(::Number)\\nBase.Math.asind\\nBase.Math.acosd\\nBase.Math.atand\\nBase.Math.sec(::Number)\\nBase.Math.csc(::Number)\\nBase.Math.cot(::Number)\\nBase.Math.secd\\nBase.Math.cscd\\nBase.Math.cotd\\nBase.Math.asec(::Number)\\nBase.Math.acsc(::Number)\\nBase.Math.acot(::Number)\\nBase.Math.asecd\\nBase.Math.acscd\\nBase.Math.acotd\\nBase.Math.sech(::Number)\\nBase.Math.csch(::Number)\\nBase.Math.coth(::Number)\\nBase.asinh(::Number)\\nBase.acosh(::Number)\\nBase.atanh(::Number)\\nBase.Math.asech(::Number)\\nBase.Math.acsch(::Number)\\nBase.Math.acoth(::Number)\\nBase.Math.sinc\\nBase.Math.cosc\\nBase.Math.deg2rad\\nBase.Math.rad2deg\\nBase.Math.hypot\\nBase.log(::Number)\\nBase.log(::Number, ::Number)\\nBase.log2\\nBase.log10\\nBase.log1p\\nBase.Math.frexp\\nBase.exp(::Float64)\\nBase.exp2\\nBase.exp10\\nBase.Math.ldexp\\nBase.Math.modf\\nBase.expm1\\nBase.round(::Type, ::Any)\\nBase.Rounding.RoundingMode\\nBase.Rounding.RoundNearest\\nBase.Rounding.RoundNearestTiesAway\\nBase.Rounding.RoundNearestTiesUp\\nBase.Rounding.RoundToZero\\nBase.Rounding.RoundFromZero\\nBase.Rounding.RoundUp\\nBase.Rounding.RoundDown\\nBase.round(::Complex{<: AbstractFloat}, ::RoundingMode, ::RoundingMode)\\nBase.ceil\\nBase.floor\\nBase.trunc\\nBase.unsafe_trunc\\nBase.min\\nBase.max\\nBase.minmax\\nBase.Math.clamp\\nBase.Math.clamp!\\nBase.abs\\nBase.Checked.checked_abs\\nBase.Checked.checked_neg\\nBase.Checked.checked_add\\nBase.Checked.checked_sub\\nBase.Checked.checked_mul\\nBase.Checked.checked_div\\nBase.Checked.checked_rem\\nBase.Checked.checked_fld\\nBase.Checked.checked_mod\\nBase.Checked.checked_cld\\nBase.Checked.add_with_overflow\\nBase.Checked.sub_with_overflow\\nBase.Checked.mul_with_overflow\\nBase.abs2\\nBase.copysign\\nBase.sign\\nBase.signbit\\nBase.flipsign\\nBase.sqrt(::Real)\\nBase.isqrt\\nBase.Math.cbrt\\nBase.real(::Complex)\\nBase.imag\\nBase.reim\\nBase.conj\\nBase.angle\\nBase.cis\\nBase.binomial\\nBase.factorial\\nBase.gcd\\nBase.lcm\\nBase.gcdx\\nBase.ispow2\\nBase.nextpow\\nBase.prevpow\\nBase.nextprod\\nBase.invmod\\nBase.powermod\\nBase.ndigits\\nBase.widemul\\nBase.Math.@evalpoly\\nBase.FastMath.@fastmath\"\n},\n\n{\n    \"location\": \"base/numbers.html#\",\n    \"page\": \"Numbers\",\n    \"title\": \"Numbers\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/numbers.html#lib-numbers-1\",\n    \"page\": \"Numbers\",\n    \"title\": \"Numbers\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/numbers.html#Standard-Numeric-Types-1\",\n    \"page\": \"Numbers\",\n    \"title\": \"Standard Numeric Types\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.Number\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.Number\",\n    \"category\": \"type\",\n    \"text\": \"Number\\n\\nAbstract supertype for all number types.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.Real\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.Real\",\n    \"category\": \"type\",\n    \"text\": \"Real <: Number\\n\\nAbstract supertype for all real numbers.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.AbstractFloat\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.AbstractFloat\",\n    \"category\": \"type\",\n    \"text\": \"AbstractFloat <: Real\\n\\nAbstract supertype for all floating point numbers.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.Integer\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.Integer\",\n    \"category\": \"type\",\n    \"text\": \"Integer <: Real\\n\\nAbstract supertype for all integers.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.Signed\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.Signed\",\n    \"category\": \"type\",\n    \"text\": \"Signed <: Integer\\n\\nAbstract supertype for all signed integers.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.Unsigned\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.Unsigned\",\n    \"category\": \"type\",\n    \"text\": \"Unsigned <: Integer\\n\\nAbstract supertype for all unsigned integers.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.AbstractIrrational\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.AbstractIrrational\",\n    \"category\": \"type\",\n    \"text\": \"AbstractIrrational <: Real\\n\\nNumber type representing an exact irrational value.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Abstract-number-types-1\",\n    \"page\": \"Numbers\",\n    \"title\": \"Abstract number types\",\n    \"category\": \"section\",\n    \"text\": \"Core.Number\\nCore.Real\\nCore.AbstractFloat\\nCore.Integer\\nCore.Signed\\nCore.Unsigned\\nBase.AbstractIrrational\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.Float16\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.Float16\",\n    \"category\": \"type\",\n    \"text\": \"Float16 <: AbstractFloat\\n\\n16-bit floating point number type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.Float32\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.Float32\",\n    \"category\": \"type\",\n    \"text\": \"Float32 <: AbstractFloat\\n\\n32-bit floating point number type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.Float64\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.Float64\",\n    \"category\": \"type\",\n    \"text\": \"Float64 <: AbstractFloat\\n\\n64-bit floating point number type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.MPFR.BigFloat\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.MPFR.BigFloat\",\n    \"category\": \"type\",\n    \"text\": \"BigFloat <: AbstractFloat\\n\\nArbitrary precision floating point number type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.Bool\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.Bool\",\n    \"category\": \"type\",\n    \"text\": \"Bool <: Integer\\n\\nBoolean type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.Int8\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.Int8\",\n    \"category\": \"type\",\n    \"text\": \"Int8 <: Signed\\n\\n8-bit signed integer type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.UInt8\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.UInt8\",\n    \"category\": \"type\",\n    \"text\": \"UInt8 <: Unsigned\\n\\n8-bit unsigned integer type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.Int16\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.Int16\",\n    \"category\": \"type\",\n    \"text\": \"Int16 <: Signed\\n\\n16-bit signed integer type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.UInt16\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.UInt16\",\n    \"category\": \"type\",\n    \"text\": \"UInt16 <: Unsigned\\n\\n16-bit unsigned integer type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.Int32\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.Int32\",\n    \"category\": \"type\",\n    \"text\": \"Int32 <: Signed\\n\\n32-bit signed integer type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.UInt32\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.UInt32\",\n    \"category\": \"type\",\n    \"text\": \"UInt32 <: Unsigned\\n\\n32-bit unsigned integer type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.Int64\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.Int64\",\n    \"category\": \"type\",\n    \"text\": \"Int64 <: Signed\\n\\n64-bit signed integer type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.UInt64\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.UInt64\",\n    \"category\": \"type\",\n    \"text\": \"UInt64 <: Unsigned\\n\\n64-bit unsigned integer type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.Int128\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.Int128\",\n    \"category\": \"type\",\n    \"text\": \"Int128 <: Signed\\n\\n128-bit signed integer type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.UInt128\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.UInt128\",\n    \"category\": \"type\",\n    \"text\": \"UInt128 <: Unsigned\\n\\n128-bit unsigned integer type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.GMP.BigInt\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.GMP.BigInt\",\n    \"category\": \"type\",\n    \"text\": \"BigInt <: Signed\\n\\nArbitrary precision integer type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.Complex\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.Complex\",\n    \"category\": \"type\",\n    \"text\": \"Complex{T<:Real} <: Number\\n\\nComplex number type with real and imaginary part of type T.\\n\\nComplexF16, ComplexF32 and ComplexF64 are aliases for Complex{Float16}, Complex{Float32} and Complex{Float64} respectively.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.Rational\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.Rational\",\n    \"category\": \"type\",\n    \"text\": \"Rational{T<:Integer} <: Real\\n\\nRational number type, with numerator and denominator of type T.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.Irrational\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.Irrational\",\n    \"category\": \"type\",\n    \"text\": \"Irrational{sym} <: AbstractIrrational\\n\\nNumber type representing an exact irrational value denoted by the symbol sym.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Concrete-number-types-1\",\n    \"page\": \"Numbers\",\n    \"title\": \"Concrete number types\",\n    \"category\": \"section\",\n    \"text\": \"Core.Float16\\nCore.Float32\\nCore.Float64\\nBase.BigFloat\\nCore.Bool\\nCore.Int8\\nCore.UInt8\\nCore.Int16\\nCore.UInt16\\nCore.Int32\\nCore.UInt32\\nCore.Int64\\nCore.UInt64\\nCore.Int128\\nCore.UInt128\\nBase.BigInt\\nBase.Complex\\nBase.Rational\\nBase.Irrational\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.digits\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.digits\",\n    \"category\": \"function\",\n    \"text\": \"digits([T<:Integer], n::Integer; base::T = 10, pad::Integer = 1)\\n\\nReturn an array with element type T (default Int) of the digits of n in the given base, optionally padded with zeros to a specified size. More significant digits are at higher indices, such that n == sum([digits[k]*base^(k-1) for k=1:length(digits)]).\\n\\nExamples\\n\\njulia> digits(10, base = 10)\\n2-element Array{Int64,1}:\\n 0\\n 1\\n\\njulia> digits(10, base = 2)\\n4-element Array{Int64,1}:\\n 0\\n 1\\n 0\\n 1\\n\\njulia> digits(10, base = 2, pad = 6)\\n6-element Array{Int64,1}:\\n 0\\n 1\\n 0\\n 1\\n 0\\n 0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.digits!\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.digits!\",\n    \"category\": \"function\",\n    \"text\": \"digits!(array, n::Integer; base::Integer = 10)\\n\\nFills an array of the digits of n in the given base. More significant digits are at higher indices. If the array length is insufficient, the least significant digits are filled up to the array length. If the array length is excessive, the excess portion is filled with zeros.\\n\\nExamples\\n\\njulia> digits!([2,2,2,2], 10, base = 2)\\n4-element Array{Int64,1}:\\n 0\\n 1\\n 0\\n 1\\n\\njulia> digits!([2,2,2,2,2,2], 10, base = 2)\\n6-element Array{Int64,1}:\\n 0\\n 1\\n 0\\n 1\\n 0\\n 0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.bitstring\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.bitstring\",\n    \"category\": \"function\",\n    \"text\": \"bitstring(n)\\n\\nA string giving the literal bit representation of a number.\\n\\nExamples\\n\\njulia> bitstring(4)\\n\\\"0000000000000000000000000000000000000000000000000000000000000100\\\"\\n\\njulia> bitstring(2.2)\\n\\\"0100000000000001100110011001100110011001100110011001100110011010\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.parse\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.parse\",\n    \"category\": \"function\",\n    \"text\": \"parse(type, str; base)\\n\\nParse a string as a number. For Integer types, a base can be specified (the default is 10). For floating-point types, the string is parsed as a decimal floating-point number.  Complex types are parsed from decimal strings of the form \\\"R\u00b1Iim\\\" as a Complex(R,I) of the requested type; \\\"i\\\" or \\\"j\\\" can also be used instead of \\\"im\\\", and \\\"R\\\" or \\\"Iim\\\" are also permitted. If the string does not contain a valid number, an error is raised.\\n\\nExamples\\n\\njulia> parse(Int, \\\"1234\\\")\\n1234\\n\\njulia> parse(Int, \\\"1234\\\", base = 5)\\n194\\n\\njulia> parse(Int, \\\"afc\\\", base = 16)\\n2812\\n\\njulia> parse(Float64, \\\"1.2e-3\\\")\\n0.0012\\n\\njulia> parse(Complex{Float64}, \\\"3.2e-1 + 4.5im\\\")\\n0.32 + 4.5im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.tryparse\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.tryparse\",\n    \"category\": \"function\",\n    \"text\": \"tryparse(type, str; base)\\n\\nLike parse, but returns either a value of the requested type, or nothing if the string does not contain a valid number.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.big\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.big\",\n    \"category\": \"function\",\n    \"text\": \"big(x)\\n\\nConvert a number to a maximum precision representation (typically BigInt or BigFloat). See BigFloat for information about some pitfalls with floating-point numbers.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.signed\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.signed\",\n    \"category\": \"function\",\n    \"text\": \"signed(x)\\n\\nConvert a number to a signed integer. If the argument is unsigned, it is reinterpreted as signed without checking for overflow.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.unsigned\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.unsigned\",\n    \"category\": \"function\",\n    \"text\": \"unsigned(x) -> Unsigned\\n\\nConvert a number to an unsigned integer. If the argument is signed, it is reinterpreted as unsigned without checking for negative values.\\n\\nExamples\\n\\njulia> unsigned(-2)\\n0xfffffffffffffffe\\n\\njulia> unsigned(2)\\n0x0000000000000002\\n\\njulia> signed(unsigned(-2))\\n-2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.float-Tuple{Any}\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.float\",\n    \"category\": \"method\",\n    \"text\": \"float(x)\\n\\nConvert a number or array to a floating point data type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.Math.significand\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.Math.significand\",\n    \"category\": \"function\",\n    \"text\": \"significand(x)\\n\\nExtract the significand(s) (a.k.a. mantissa), in binary representation, of a floating-point number. If x is a non-zero finite number, then the result will be a number of the same type on the interval 12). Otherwise x is returned.\\n\\nExamples\\n\\njulia> significand(15.2)/15.2\\n0.125\\n\\njulia> significand(15.2)*8\\n15.2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.Math.exponent\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.Math.exponent\",\n    \"category\": \"function\",\n    \"text\": \"exponent(x) -> Int\\n\\nGet the exponent of a normalized floating-point number.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.complex-Tuple{Complex}\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.complex\",\n    \"category\": \"method\",\n    \"text\": \"complex(r, [i])\\n\\nConvert real numbers or arrays to complex. i defaults to zero.\\n\\nExamples\\n\\njulia> complex(7)\\n7 + 0im\\n\\njulia> complex([1, 2, 3])\\n3-element Array{Complex{Int64},1}:\\n 1 + 0im\\n 2 + 0im\\n 3 + 0im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.bswap\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.bswap\",\n    \"category\": \"function\",\n    \"text\": \"bswap(n)\\n\\nReverse the byte order of n.\\n\\nExamples\\n\\njulia> a = bswap(0x10203040)\\n0x40302010\\n\\njulia> bswap(a)\\n0x10203040\\n\\njulia> string(1, base = 2)\\n\\\"1\\\"\\n\\njulia> string(bswap(1), base = 2)\\n\\\"100000000000000000000000000000000000000000000000000000000\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.hex2bytes\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.hex2bytes\",\n    \"category\": \"function\",\n    \"text\": \"hex2bytes(s::Union{AbstractString,AbstractVector{UInt8}})\\n\\nGiven a string or array s of ASCII codes for a sequence of hexadecimal digits, returns a Vector{UInt8} of bytes  corresponding to the binary representation: each successive pair of hexadecimal digits in s gives the value of one byte in the return vector.\\n\\nThe length of s must be even, and the returned array has half of the length of s. See also hex2bytes! for an in-place version, and bytes2hex for the inverse.\\n\\nExamples\\n\\njulia> s = string(12345, base = 16)\\n\\\"3039\\\"\\n\\njulia> hex2bytes(s)\\n2-element Array{UInt8,1}:\\n 0x30\\n 0x39\\n\\njulia> a = b\\\"01abEF\\\"\\n6-element Base.CodeUnits{UInt8,String}:\\n 0x30\\n 0x31\\n 0x61\\n 0x62\\n 0x45\\n 0x46\\n\\njulia> hex2bytes(a)\\n3-element Array{UInt8,1}:\\n 0x01\\n 0xab\\n 0xef\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.hex2bytes!\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.hex2bytes!\",\n    \"category\": \"function\",\n    \"text\": \"hex2bytes!(d::AbstractVector{UInt8}, s::Union{String,AbstractVector{UInt8}})\\n\\nConvert an array s of bytes representing a hexadecimal string to its binary representation, similar to hex2bytes except that the output is written in-place in d.   The length of s must be exactly twice the length of d.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.bytes2hex\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.bytes2hex\",\n    \"category\": \"function\",\n    \"text\": \"bytes2hex(a::AbstractArray{UInt8}) -> String\\nbytes2hex(io::IO, a::AbstractArray{UInt8})\\n\\nConvert an array a of bytes to its hexadecimal string representation, either returning a String via bytes2hex(a) or writing the string to an io stream via bytes2hex(io, a).  The hexadecimal characters are all lowercase.\\n\\nExamples\\n\\njulia> a = string(12345, base = 16)\\n\\\"3039\\\"\\n\\njulia> b = hex2bytes(a)\\n2-element Array{UInt8,1}:\\n 0x30\\n 0x39\\n\\njulia> bytes2hex(b)\\n\\\"3039\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Data-Formats-1\",\n    \"page\": \"Numbers\",\n    \"title\": \"Data Formats\",\n    \"category\": \"section\",\n    \"text\": \"Base.digits\\nBase.digits!\\nBase.bitstring\\nBase.parse\\nBase.tryparse\\nBase.big\\nBase.signed\\nBase.unsigned\\nBase.float(::Any)\\nBase.Math.significand\\nBase.Math.exponent\\nBase.complex(::Complex)\\nBase.bswap\\nBase.hex2bytes\\nBase.hex2bytes!\\nBase.bytes2hex\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.one\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.one\",\n    \"category\": \"function\",\n    \"text\": \"one(x)\\none(T::type)\\n\\nReturn a multiplicative identity for x: a value such that one(x)*x == x*one(x) == x.  Alternatively one(T) can take a type T, in which case one returns a multiplicative identity for any x of type T.\\n\\nIf possible, one(x) returns a value of the same type as x, and one(T) returns a value of type T.  However, this may not be the case for types representing dimensionful quantities (e.g. time in days), since the multiplicative identity must be dimensionless.  In that case, one(x) should return an identity value of the same precision (and shape, for matrices) as x.\\n\\nIf you want a quantity that is of the same type as x, or of type T, even if x is dimensionful, use oneunit instead.\\n\\nExamples\\n\\njulia> one(3.7)\\n1.0\\n\\njulia> one(Int)\\n1\\n\\njulia> import Dates; one(Dates.Day(1))\\n1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.oneunit\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.oneunit\",\n    \"category\": \"function\",\n    \"text\": \"oneunit(x::T)\\noneunit(T::Type)\\n\\nReturns T(one(x)), where T is either the type of the argument or (if a type is passed) the argument.  This differs from one for dimensionful quantities: one is dimensionless (a multiplicative identity) while oneunit is dimensionful (of the same type as x, or of type T).\\n\\nExamples\\n\\njulia> oneunit(3.7)\\n1.0\\n\\njulia> import Dates; oneunit(Dates.Day)\\n1 day\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.zero\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.zero\",\n    \"category\": \"function\",\n    \"text\": \"zero(x)\\n\\nGet the additive identity element for the type of x (x can also specify the type itself).\\n\\nExamples\\n\\njulia> zero(1)\\n0\\n\\njulia> zero(big\\\"2.0\\\")\\n0.0\\n\\njulia> zero(rand(2,2))\\n2\u00d72 Array{Float64,2}:\\n 0.0  0.0\\n 0.0  0.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.im\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.im\",\n    \"category\": \"constant\",\n    \"text\": \"im\\n\\nThe imaginary unit.\\n\\nExamples\\n\\njulia> im * im\\n-1 + 0im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.MathConstants.pi\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.MathConstants.pi\",\n    \"category\": \"constant\",\n    \"text\": \"\u03c0\\npi\\n\\nThe constant pi.\\n\\nExamples\\n\\njulia> pi\\n\u03c0 = 3.1415926535897...\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.MathConstants.\u212f\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.MathConstants.\u212f\",\n    \"category\": \"constant\",\n    \"text\": \"\u212f\\ne\\n\\nThe constant \u212f.\\n\\nExamples\\n\\njulia> \u212f\\n\u212f = 2.7182818284590...\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.MathConstants.catalan\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.MathConstants.catalan\",\n    \"category\": \"constant\",\n    \"text\": \"catalan\\n\\nCatalan\\'s constant.\\n\\nExamples\\n\\njulia> Base.MathConstants.catalan\\ncatalan = 0.9159655941772...\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.MathConstants.eulergamma\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.MathConstants.eulergamma\",\n    \"category\": \"constant\",\n    \"text\": \"\u03b3\\neulergamma\\n\\nEuler\\'s constant.\\n\\nExamples\\n\\njulia> Base.MathConstants.eulergamma\\n\u03b3 = 0.5772156649015...\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.MathConstants.golden\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.MathConstants.golden\",\n    \"category\": \"constant\",\n    \"text\": \"\u03c6\\ngolden\\n\\nThe golden ratio.\\n\\nExamples\\n\\njulia> Base.MathConstants.golden\\n\u03c6 = 1.6180339887498...\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.Inf\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.Inf\",\n    \"category\": \"constant\",\n    \"text\": \"Inf, Inf64\\n\\nPositive infinity of type Float64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.Inf32\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.Inf32\",\n    \"category\": \"constant\",\n    \"text\": \"Inf32\\n\\nPositive infinity of type Float32.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.Inf16\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.Inf16\",\n    \"category\": \"constant\",\n    \"text\": \"Inf16\\n\\nPositive infinity of type Float16.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.NaN\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.NaN\",\n    \"category\": \"constant\",\n    \"text\": \"NaN, NaN64\\n\\nA not-a-number value of type Float64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.NaN32\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.NaN32\",\n    \"category\": \"constant\",\n    \"text\": \"NaN32\\n\\nA not-a-number value of type Float32.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.NaN16\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.NaN16\",\n    \"category\": \"constant\",\n    \"text\": \"NaN16\\n\\nA not-a-number value of type Float16.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.issubnormal\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.issubnormal\",\n    \"category\": \"function\",\n    \"text\": \"issubnormal(f) -> Bool\\n\\nTest whether a floating point number is subnormal.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.isfinite\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.isfinite\",\n    \"category\": \"function\",\n    \"text\": \"isfinite(f) -> Bool\\n\\nTest whether a number is finite.\\n\\nExamples\\n\\njulia> isfinite(5)\\ntrue\\n\\njulia> isfinite(NaN32)\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.isinf\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.isinf\",\n    \"category\": \"function\",\n    \"text\": \"isinf(f) -> Bool\\n\\nTest whether a number is infinite.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.isnan\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.isnan\",\n    \"category\": \"function\",\n    \"text\": \"isnan(f) -> Bool\\n\\nTest whether a floating point number is not a number (NaN).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.iszero\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.iszero\",\n    \"category\": \"function\",\n    \"text\": \"iszero(x)\\n\\nReturn true if x == zero(x); if x is an array, this checks whether all of the elements of x are zero.\\n\\nExamples\\n\\njulia> iszero(0.0)\\ntrue\\n\\njulia> iszero([1, 9, 0])\\nfalse\\n\\njulia> iszero([false, 0, 0])\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.isone\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.isone\",\n    \"category\": \"function\",\n    \"text\": \"isone(x)\\n\\nReturn true if x == one(x); if x is an array, this checks whether x is an identity matrix.\\n\\nExamples\\n\\njulia> isone(1.0)\\ntrue\\n\\njulia> isone([1 0; 0 2])\\nfalse\\n\\njulia> isone([1 0; 0 true])\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.nextfloat\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.nextfloat\",\n    \"category\": \"function\",\n    \"text\": \"nextfloat(x::IEEEFloat, n::Integer)\\n\\nThe result of n iterative applications of nextfloat to x if n >= 0, or -n applications of prevfloat if n < 0.\\n\\n\\n\\n\\n\\nnextfloat(x::AbstractFloat)\\n\\nReturn the smallest floating point number y of the same type as x such x < y. If no such y exists (e.g. if x is Inf or NaN), then return x.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.prevfloat\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.prevfloat\",\n    \"category\": \"function\",\n    \"text\": \"prevfloat(x::AbstractFloat, n::Integer)\\n\\nThe result of n iterative applications of prevfloat to x if n >= 0, or -n applications of nextfloat if n < 0.\\n\\n\\n\\n\\n\\nprevfloat(x::AbstractFloat)\\n\\nReturn the largest floating point number y of the same type as x such y < x. If no such y exists (e.g. if x is -Inf or NaN), then return x.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.isinteger\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.isinteger\",\n    \"category\": \"function\",\n    \"text\": \"isinteger(x) -> Bool\\n\\nTest whether x is numerically equal to some integer.\\n\\nExamples\\n\\njulia> isinteger(4.0)\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.isreal\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.isreal\",\n    \"category\": \"function\",\n    \"text\": \"isreal(x) -> Bool\\n\\nTest whether x or all its elements are numerically equal to some real number including infinities and NaNs. isreal(x) is true if isequal(x, real(x)) is true.\\n\\nExamples\\n\\njulia> isreal(5.)\\ntrue\\n\\njulia> isreal(Inf + 0im)\\ntrue\\n\\njulia> isreal([4.; complex(0,1)])\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.Float32-Tuple{Any}\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.Float32\",\n    \"category\": \"method\",\n    \"text\": \"Float32(x [, mode::RoundingMode])\\n\\nCreate a Float32 from x. If x is not exactly representable then mode determines how x is rounded.\\n\\nExamples\\n\\njulia> Float32(1/3, RoundDown)\\n0.3333333f0\\n\\njulia> Float32(1/3, RoundUp)\\n0.33333334f0\\n\\nSee RoundingMode for available rounding modes.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Core.Float64-Tuple{Any}\",\n    \"page\": \"Numbers\",\n    \"title\": \"Core.Float64\",\n    \"category\": \"method\",\n    \"text\": \"Float64(x [, mode::RoundingMode])\\n\\nCreate a Float64 from x. If x is not exactly representable then mode determines how x is rounded.\\n\\nExamples\\n\\njulia> Float64(pi, RoundDown)\\n3.141592653589793\\n\\njulia> Float64(pi, RoundUp)\\n3.1415926535897936\\n\\nSee RoundingMode for available rounding modes.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.GMP.BigInt-Tuple{Any}\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.GMP.BigInt\",\n    \"category\": \"method\",\n    \"text\": \"BigInt(x)\\n\\nCreate an arbitrary precision integer. x may be an Int (or anything that can be converted to an Int). The usual mathematical operators are defined for this type, and results are promoted to a BigInt.\\n\\nInstances can be constructed from strings via parse, or using the big string literal.\\n\\nExamples\\n\\njulia> parse(BigInt, \\\"42\\\")\\n42\\n\\njulia> big\\\"313\\\"\\n313\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.MPFR.BigFloat-Tuple{Any}\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.MPFR.BigFloat\",\n    \"category\": \"method\",\n    \"text\": \"BigFloat(x)\\n\\nCreate an arbitrary precision floating point number. x may be an Integer, a Float64 or a BigInt. The usual mathematical operators are defined for this type, and results are promoted to a BigFloat.\\n\\nNote that because decimal literals are converted to floating point numbers when parsed, BigFloat(2.1) may not yield what you expect. You may instead prefer to initialize constants from strings via parse, or using the big string literal.\\n\\njulia> BigFloat(2.1)\\n2.100000000000000088817841970012523233890533447265625\\n\\njulia> big\\\"2.1\\\"\\n2.099999999999999999999999999999999999999999999999999999999999999999999999999986\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.Rounding.rounding\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.Rounding.rounding\",\n    \"category\": \"function\",\n    \"text\": \"rounding(T)\\n\\nGet the current floating point rounding mode for type T, controlling the rounding of basic arithmetic functions (+, -, *, / and sqrt) and type conversion.\\n\\nSee RoundingMode for available modes.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.Rounding.setrounding-Tuple{Type,Any}\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.Rounding.setrounding\",\n    \"category\": \"method\",\n    \"text\": \"setrounding(T, mode)\\n\\nSet the rounding mode of floating point type T, controlling the rounding of basic arithmetic functions (+, -, *, / and sqrt) and type conversion. Other numerical functions may give incorrect or invalid values when using rounding modes other than the default RoundNearest.\\n\\nNote that this is currently only supported for T == BigFloat.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.Rounding.setrounding-Tuple{Function,Type,RoundingMode}\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.Rounding.setrounding\",\n    \"category\": \"method\",\n    \"text\": \"setrounding(f::Function, T, mode)\\n\\nChange the rounding mode of floating point type T for the duration of f. It is logically equivalent to:\\n\\nold = rounding(T)\\nsetrounding(T, mode)\\nf()\\nsetrounding(T, old)\\n\\nSee RoundingMode for available rounding modes.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.Rounding.get_zero_subnormals\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.Rounding.get_zero_subnormals\",\n    \"category\": \"function\",\n    \"text\": \"get_zero_subnormals() -> Bool\\n\\nReturn false if operations on subnormal floating-point values (\\\"denormals\\\") obey rules for IEEE arithmetic, and true if they might be converted to zeros.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.Rounding.set_zero_subnormals\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.Rounding.set_zero_subnormals\",\n    \"category\": \"function\",\n    \"text\": \"set_zero_subnormals(yes::Bool) -> Bool\\n\\nIf yes is false, subsequent floating-point operations follow rules for IEEE arithmetic on subnormal values (\\\"denormals\\\"). Otherwise, floating-point operations are permitted (but not required) to convert subnormal inputs or outputs to zero. Returns true unless yes==true but the hardware does not support zeroing of subnormal numbers.\\n\\nset_zero_subnormals(true) can speed up some computations on some hardware. However, it can break identities such as (x-y==0) == (x==y).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#General-Number-Functions-and-Constants-1\",\n    \"page\": \"Numbers\",\n    \"title\": \"General Number Functions and Constants\",\n    \"category\": \"section\",\n    \"text\": \"Base.one\\nBase.oneunit\\nBase.zero\\nBase.im\\nBase.MathConstants.pi\\nBase.MathConstants.\u212f\\nBase.MathConstants.catalan\\nBase.MathConstants.eulergamma\\nBase.MathConstants.golden\\nBase.Inf\\nBase.Inf32\\nBase.Inf16\\nBase.NaN\\nBase.NaN32\\nBase.NaN16\\nBase.issubnormal\\nBase.isfinite\\nBase.isinf\\nBase.isnan\\nBase.iszero\\nBase.isone\\nBase.nextfloat\\nBase.prevfloat\\nBase.isinteger\\nBase.isreal\\nCore.Float32(::Any)\\nCore.Float64(::Any)\\nBase.GMP.BigInt(::Any)\\nBase.MPFR.BigFloat(::Any)\\nBase.Rounding.rounding\\nBase.Rounding.setrounding(::Type, ::Any)\\nBase.Rounding.setrounding(::Function, ::Type, ::RoundingMode)\\nBase.Rounding.get_zero_subnormals\\nBase.Rounding.set_zero_subnormals\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.count_ones\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.count_ones\",\n    \"category\": \"function\",\n    \"text\": \"count_ones(x::Integer) -> Integer\\n\\nNumber of ones in the binary representation of x.\\n\\nExamples\\n\\njulia> count_ones(7)\\n3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.count_zeros\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.count_zeros\",\n    \"category\": \"function\",\n    \"text\": \"count_zeros(x::Integer) -> Integer\\n\\nNumber of zeros in the binary representation of x.\\n\\nExamples\\n\\njulia> count_zeros(Int32(2 ^ 16 - 1))\\n16\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.leading_zeros\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.leading_zeros\",\n    \"category\": \"function\",\n    \"text\": \"leading_zeros(x::Integer) -> Integer\\n\\nNumber of zeros leading the binary representation of x.\\n\\nExamples\\n\\njulia> leading_zeros(Int32(1))\\n31\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.leading_ones\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.leading_ones\",\n    \"category\": \"function\",\n    \"text\": \"leading_ones(x::Integer) -> Integer\\n\\nNumber of ones leading the binary representation of x.\\n\\nExamples\\n\\njulia> leading_ones(UInt32(2 ^ 32 - 2))\\n31\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.trailing_zeros\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.trailing_zeros\",\n    \"category\": \"function\",\n    \"text\": \"trailing_zeros(x::Integer) -> Integer\\n\\nNumber of zeros trailing the binary representation of x.\\n\\nExamples\\n\\njulia> trailing_zeros(2)\\n1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.trailing_ones\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.trailing_ones\",\n    \"category\": \"function\",\n    \"text\": \"trailing_ones(x::Integer) -> Integer\\n\\nNumber of ones trailing the binary representation of x.\\n\\nExamples\\n\\njulia> trailing_ones(3)\\n2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.isodd\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.isodd\",\n    \"category\": \"function\",\n    \"text\": \"isodd(x::Integer) -> Bool\\n\\nReturn true if x is odd (that is, not divisible by 2), and false otherwise.\\n\\nExamples\\n\\njulia> isodd(9)\\ntrue\\n\\njulia> isodd(10)\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.iseven\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.iseven\",\n    \"category\": \"function\",\n    \"text\": \"iseven(x::Integer) -> Bool\\n\\nReturn true is x is even (that is, divisible by 2), and false otherwise.\\n\\nExamples\\n\\njulia> iseven(9)\\nfalse\\n\\njulia> iseven(10)\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.@int128_str\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.@int128_str\",\n    \"category\": \"macro\",\n    \"text\": \"@int128_str str\\n@int128_str(str)\\n\\n@int128_str parses a string into a Int128 Throws an ArgumentError if the string is not a valid integer\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.@uint128_str\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.@uint128_str\",\n    \"category\": \"macro\",\n    \"text\": \"@uint128_str str\\n@uint128_str(str)\\n\\n@uint128_str parses a string into a UInt128 Throws an ArgumentError if the string is not a valid integer\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Integers-1\",\n    \"page\": \"Numbers\",\n    \"title\": \"Integers\",\n    \"category\": \"section\",\n    \"text\": \"Base.count_ones\\nBase.count_zeros\\nBase.leading_zeros\\nBase.leading_ones\\nBase.trailing_zeros\\nBase.trailing_ones\\nBase.isodd\\nBase.iseven\\nBase.@int128_str\\nBase.@uint128_str\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.precision\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.precision\",\n    \"category\": \"function\",\n    \"text\": \"precision(num::AbstractFloat)\\n\\nGet the precision of a floating point number, as defined by the effective number of bits in the mantissa.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.precision-Tuple{Type{BigFloat}}\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.precision\",\n    \"category\": \"method\",\n    \"text\": \"precision(BigFloat)\\n\\nGet the precision (in bits) currently used for BigFloat arithmetic.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.MPFR.setprecision\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.MPFR.setprecision\",\n    \"category\": \"function\",\n    \"text\": \"setprecision([T=BigFloat,] precision::Int)\\n\\nSet the precision (in bits) to be used for T arithmetic.\\n\\n\\n\\n\\n\\nsetprecision(f::Function, [T=BigFloat,] precision::Integer)\\n\\nChange the T arithmetic precision (in bits) for the duration of f. It is logically equivalent to:\\n\\nold = precision(BigFloat)\\nsetprecision(BigFloat, precision)\\nf()\\nsetprecision(BigFloat, old)\\n\\nOften used as setprecision(T, precision) do ... end\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.MPFR.BigFloat-Tuple{Any,Int64}\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.MPFR.BigFloat\",\n    \"category\": \"method\",\n    \"text\": \"BigFloat(x, prec::Int)\\n\\nCreate a representation of x as a BigFloat with precision prec.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.MPFR.BigFloat-Tuple{Union{AbstractFloat, Integer, String},RoundingMode}\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.MPFR.BigFloat\",\n    \"category\": \"method\",\n    \"text\": \"BigFloat(x, rounding::RoundingMode)\\n\\nCreate a representation of x as a BigFloat with the current global precision and Rounding Mode rounding.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.MPFR.BigFloat-Tuple{Any,Int64,RoundingMode}\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.MPFR.BigFloat\",\n    \"category\": \"method\",\n    \"text\": \"BigFloat(x, prec::Int, rounding::RoundingMode)\\n\\nCreate a representation of x as a BigFloat with precision prec and Rounding Mode rounding.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.MPFR.BigFloat-Tuple{String}\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.MPFR.BigFloat\",\n    \"category\": \"method\",\n    \"text\": \"BigFloat(x)\\n\\nCreate an arbitrary precision floating point number. x may be an Integer, a Float64 or a BigInt. The usual mathematical operators are defined for this type, and results are promoted to a BigFloat.\\n\\nNote that because decimal literals are converted to floating point numbers when parsed, BigFloat(2.1) may not yield what you expect. You may instead prefer to initialize constants from strings via parse, or using the big string literal.\\n\\njulia> BigFloat(2.1)\\n2.100000000000000088817841970012523233890533447265625\\n\\njulia> big\\\"2.1\\\"\\n2.099999999999999999999999999999999999999999999999999999999999999999999999999986\\n\\n\\n\\n\\n\\nBigFloat(x::String)\\n\\nCreate a representation of the string x as a BigFloat.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#Base.@big_str\",\n    \"page\": \"Numbers\",\n    \"title\": \"Base.@big_str\",\n    \"category\": \"macro\",\n    \"text\": \"@big_str str\\n@big_str(str)\\n\\n@big_str parses a string into a BigInt Throws an ArgumentError if the string is not a valid integer Removes all underscores _ from the string\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/numbers.html#BigFloats-1\",\n    \"page\": \"Numbers\",\n    \"title\": \"BigFloats\",\n    \"category\": \"section\",\n    \"text\": \"The BigFloat type implements arbitrary-precision floating-point arithmetic using the GNU MPFR library.Base.precision\\nBase.MPFR.precision(::Type{BigFloat})\\nBase.MPFR.setprecision\\nBase.MPFR.BigFloat(x, prec::Int)\\nBigFloat(x::Union{Integer, AbstractFloat, String}, rounding::RoundingMode)\\nBase.MPFR.BigFloat(x, prec::Int, rounding::RoundingMode)\\nBase.MPFR.BigFloat(x::String)\\nBase.@big_str\"\n},\n\n{\n    \"location\": \"base/strings.html#\",\n    \"page\": \"Strings\",\n    \"title\": \"Strings\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/strings.html#Core.AbstractChar\",\n    \"page\": \"Strings\",\n    \"title\": \"Core.AbstractChar\",\n    \"category\": \"type\",\n    \"text\": \"The AbstractChar type is the supertype of all character implementations in Julia.   A character represents a Unicode code point, and can be converted to an integer via the codepoint function in order to obtain the numerical value of the code point, or constructed from the same integer. These numerical values determine how characters are compared with < and ==, for example.  New T <: AbstractChar types should define a codepoint(::T) method and a T(::UInt32) constructor, at minimum.\\n\\nA given AbstractChar subtype may be capable of representing only a subset of Unicode, in which case conversion from an unsupported UInt32 value may throw an error.  Conversely, the built-in Char type represents a superset of Unicode (in order to losslessly encode invalid byte streams), in which case conversion of a non-Unicode value to UInt32 throws an error. The isvalid function can be used to check which codepoints are representable in a given AbstractChar type.\\n\\nInternally, an AbstractChar type may use a variety of encodings.  Conversion via codepoint(char) will not reveal this encoding because it always returns the Unicode value of the character. print(io, c) of any c::AbstractChar produces an encoding determined by io (UTF-8 for all built-in IO types), via conversion to Char if necessary.\\n\\nwrite(io, c), in contrast, may emit an encoding depending on typeof(c), and read(io, typeof(c)) should read the same encoding as write. New AbstractChar types must provide their own implementations of write and read.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Core.Char\",\n    \"page\": \"Strings\",\n    \"title\": \"Core.Char\",\n    \"category\": \"type\",\n    \"text\": \"Char(c::Union{Number,AbstractChar})\\n\\nChar is a 32-bit AbstractChar type that is the default representation of characters in Julia.  Char is the type used for character literals like \\'x\\' and it is also the element type of String.\\n\\nIn order to losslessly represent arbitrary byte streams stored in a String, a Char value may store information that cannot be converted to a Unicode codepoint \u2014 converting such a Char to UInt32 will throw an error. The isvalid(c::Char) function can be used to query whether c represents a valid Unicode character.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.codepoint\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.codepoint\",\n    \"category\": \"function\",\n    \"text\": \"codepoint(c::AbstractChar)\\n\\nReturn the Unicode codepoint (an unsigned integer) corresponding to the character c (or throw an exception if c does not represent a valid character).   For Char, this is a UInt32 value, but AbstractChar types that represent only a subset of Unicode may return a different-sized integer (e.g. UInt8).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.length-Tuple{AbstractString}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.length\",\n    \"category\": \"method\",\n    \"text\": \"length(s::AbstractString) -> Int\\nlength(s::AbstractString, i::Integer, j::Integer) -> Int\\n\\nThe number of characters in string s from indices i through j. This is computed as the number of code unit indices from i to j which are valid character indices. Without only a single string argument, this computes the number of characters in the entire string. With i and j arguments it computes the number of indices between i and j inclusive that are valid indices in the string s. In addition to in-bounds values, i may take the out-of-bounds value ncodeunits(s) + 1 and j may take the out-of-bounds value 0.\\n\\nSee also: isvalid, ncodeunits, lastindex, thisind, nextind, prevind\\n\\nExamples\\n\\njulia> length(\\\"j\u03bc\u039bI\u03b1\\\")\\n5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.sizeof-Tuple{AbstractString}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.sizeof\",\n    \"category\": \"method\",\n    \"text\": \"sizeof(str::AbstractString)\\n\\nSize, in bytes, of the string s. Equal to the number of code units in s multiplied by the size, in bytes, of one code unit in s.\\n\\nExamples\\n\\njulia> sizeof(\\\"\\\")\\n0\\n\\njulia> sizeof(\\\"\u2200\\\")\\n3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.:*-Tuple{Union{AbstractChar, AbstractString},Vararg{Union{AbstractChar, AbstractString},N} where N}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.:*\",\n    \"category\": \"method\",\n    \"text\": \"*(s::Union{AbstractString, AbstractChar}, t::Union{AbstractString, AbstractChar}...) -> AbstractString\\n\\nConcatenate strings and/or characters, producing a String. This is equivalent to calling the string function on the arguments. Concatenation of built-in string types always produces a value of type String but other string types may choose to return a string of a different type as appropriate.\\n\\nExamples\\n\\njulia> \\\"Hello \\\" * \\\"world\\\"\\n\\\"Hello world\\\"\\n\\njulia> \\'j\\' * \\\"ulia\\\"\\n\\\"julia\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.:^-Tuple{AbstractString,Integer}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.:^\",\n    \"category\": \"method\",\n    \"text\": \"^(s::Union{AbstractString,AbstractChar}, n::Integer)\\n\\nRepeat a string or character n times. This can also be written as repeat(s, n).\\n\\nSee also: repeat\\n\\nExamples\\n\\njulia> \\\"Test \\\"^3\\n\\\"Test Test Test \\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.string\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.string\",\n    \"category\": \"function\",\n    \"text\": \"string(n::Integer; base::Integer = 10, pad::Integer = 1)\\n\\nConvert an integer n to a string in the given base, optionally specifying a number of digits to pad to.\\n\\njulia> string(5, base = 13, pad = 4)\\n\\\"0005\\\"\\n\\njulia> string(13, base = 5, pad = 4)\\n\\\"0023\\\"\\n\\n\\n\\n\\n\\nstring(xs...)\\n\\nCreate a string from any values using the print function.\\n\\nExamples\\n\\njulia> string(\\\"a\\\", 1, true)\\n\\\"a1true\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.repeat-Tuple{AbstractString,Integer}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.repeat\",\n    \"category\": \"method\",\n    \"text\": \"repeat(s::AbstractString, r::Integer)\\n\\nRepeat a string r times. This can be written as s^r.\\n\\nSee also: ^\\n\\nExamples\\n\\njulia> repeat(\\\"ha\\\", 3)\\n\\\"hahaha\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.repeat-Tuple{AbstractChar,Integer}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.repeat\",\n    \"category\": \"method\",\n    \"text\": \"repeat(c::AbstractChar, r::Integer) -> String\\n\\nRepeat a character r times. This can equivalently be accomplished by calling c^r.\\n\\nExamples\\n\\njulia> repeat(\\'A\\', 3)\\n\\\"AAA\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.repr-Tuple{Any}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.repr\",\n    \"category\": \"method\",\n    \"text\": \"repr(x; context=nothing)\\n\\nCreate a string from any value using the show function.\\n\\nThe optional keyword argument context can be set to an IO or IOContext object whose attributes are used for the I/O stream passed to show.\\n\\nNote that repr(x) is usually similar to how the value of x would be entered in Julia.  See also repr(MIME(\\\"text/plain\\\"), x) to instead return a \\\"pretty-printed\\\" version of x designed more for human consumption, equivalent to the REPL display of x.\\n\\nExamples\\n\\njulia> repr(1)\\n\\\"1\\\"\\n\\njulia> repr(zeros(3))\\n\\\"[0.0, 0.0, 0.0]\\\"\\n\\njulia> repr(big(1/3))\\n\\\"3.33333333333333314829616256247390992939472198486328125e-01\\\"\\n\\njulia> repr(big(1/3), context=:compact => true)\\n\\\"3.33333e-01\\\"\\n\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Core.String-Tuple{AbstractString}\",\n    \"page\": \"Strings\",\n    \"title\": \"Core.String\",\n    \"category\": \"method\",\n    \"text\": \"String(s::AbstractString)\\n\\nConvert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.SubString\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.SubString\",\n    \"category\": \"type\",\n    \"text\": \"SubString(s::AbstractString, i::Integer, j::Integer=lastindex(s))\\nSubString(s::AbstractString, r::UnitRange{<:Integer})\\n\\nLike getindex, but returns a view into the parent string s within range i:j or r respectively instead of making a copy.\\n\\nExamples\\n\\njulia> SubString(\\\"abc\\\", 1, 2)\\n\\\"ab\\\"\\n\\njulia> SubString(\\\"abc\\\", 1:2)\\n\\\"ab\\\"\\n\\njulia> SubString(\\\"abc\\\", 2)\\n\\\"bc\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.transcode\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.transcode\",\n    \"category\": \"function\",\n    \"text\": \"transcode(T, src)\\n\\nConvert string data between Unicode encodings. src is either a String or a Vector{UIntXX} of UTF-XX code units, where XX is 8, 16, or 32. T indicates the encoding of the return value: String to return a (UTF-8 encoded) String or UIntXX to return a Vector{UIntXX} of UTF-XX data. (The alias Cwchar_t can also be used as the integer type, for converting wchar_t* strings used by external C libraries.)\\n\\nThe transcode function succeeds as long as the input data can be reasonably represented in the target encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.\\n\\nOnly conversion to/from UTF-8 is currently supported.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.unsafe_string\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.unsafe_string\",\n    \"category\": \"function\",\n    \"text\": \"unsafe_string(p::Ptr{UInt8}, [length::Integer])\\n\\nCopy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8. (The pointer can be safely freed afterwards.) If length is specified (the length of the data in bytes), the string does not have to be NUL-terminated.\\n\\nThis function is labeled \\\"unsafe\\\" because it will crash if p is not a valid memory address to data of the requested length.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.ncodeunits-Tuple{AbstractString}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.ncodeunits\",\n    \"category\": \"method\",\n    \"text\": \"ncodeunits(s::AbstractString) -> Int\\n\\nReturn the number of code units in a string. Indices that are in bounds to access this string must satisfy 1 \u2264 i \u2264\u00a0ncodeunits(s). Not all such indices are valid \u2013\u00a0they may not be the start of a character, but they will return a code unit value when calling codeunit(s,i).\\n\\nSee also: codeunit, checkbounds, sizeof, length, lastindex\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.codeunit\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.codeunit\",\n    \"category\": \"function\",\n    \"text\": \"codeunit(s::AbstractString) -> Type{<:Union{UInt8, UInt16, UInt32}}\\n\\nReturn the code unit type of the given string object. For ASCII, Latin-1, or UTF-8 encoded strings, this would be UInt8; for UCS-2 and UTF-16 it would be UInt16; for UTF-32 it would be UInt32. The unit code type need not be limited to these three types, but it\\'s hard to think of widely used string encodings that don\\'t use one of these units. codeunit(s) is the same as typeof(codeunit(s,1)) when s is a non-empty string.\\n\\nSee also: ncodeunits\\n\\n\\n\\n\\n\\ncodeunit(s::AbstractString, i::Integer) -> Union{UInt8, UInt16, UInt32}\\n\\nReturn the code unit value in the string s at index i. Note that\\n\\ncodeunit(s, i) :: codeunit(s)\\n\\nI.e. the value returned by codeunit(s, i) is of the type returned by codeunit(s).\\n\\nSee also: ncodeunits, checkbounds\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.codeunits\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.codeunits\",\n    \"category\": \"function\",\n    \"text\": \"codeunits(s::AbstractString)\\n\\nObtain a vector-like object containing the code units of a string. Returns a CodeUnits wrapper by default, but codeunits may optionally be defined for new string types if necessary.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.ascii\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.ascii\",\n    \"category\": \"function\",\n    \"text\": \"ascii(s::AbstractString)\\n\\nConvert a string to String type and check that it contains only ASCII data, otherwise throwing an ArgumentError indicating the position of the first non-ASCII byte.\\n\\nExamples\\n\\njulia> ascii(\\\"abcde\u03b3fgh\\\")\\nERROR: ArgumentError: invalid ASCII at index 6 in \\\"abcde\u03b3fgh\\\"\\nStacktrace:\\n[...]\\n\\njulia> ascii(\\\"abcdefgh\\\")\\n\\\"abcdefgh\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.@r_str\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.@r_str\",\n    \"category\": \"macro\",\n    \"text\": \"@r_str -> Regex\\n\\nConstruct a regex, such as r\\\"^[a-z]*$\\\", without interpolation and unescaping (except for quotation mark \\\" which still has to be escaped). The regex also accepts one or more flags, listed after the ending quote, to change its behaviour:\\n\\ni enables case-insensitive matching\\nm treats the ^ and $ tokens as matching the start and end of individual lines, as opposed to the whole string.\\ns allows the . modifier to match newlines.\\nx enables \\\"comment mode\\\": whitespace is enabled except when escaped with \\\\, and # is treated as starting a comment.\\na disables UCP mode (enables ASCII mode). By default \\\\B, \\\\b, \\\\D, \\\\d, \\\\S, \\\\s, \\\\W, \\\\w, etc. match based on Unicode character properties. With this option, these sequences only match ASCII characters.\\n\\nExamples\\n\\njulia> match(r\\\"a+.*b+.*?d$\\\"ism, \\\"Goodbye,\\\\nOh, angry,\\\\nBad world\\\\n\\\")\\nRegexMatch(\\\"angry,\\\\nBad world\\\")\\n\\nThis regex has the first three flags enabled.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.SubstitutionString\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.SubstitutionString\",\n    \"category\": \"type\",\n    \"text\": \"SubstitutionString(substr)\\n\\nStores the given string substr as a SubstitutionString, for use in regular expression substitutions. Most commonly constructed using the @s_str macro.\\n\\njulia> SubstitutionString(\\\"Hello \\\\\\\\g<name>, it\\'s \\\\\\\\1\\\")\\ns\\\"Hello \\\\\\\\g<name>, it\\'s \\\\\\\\1\\\"\\n\\njulia> subst = s\\\"Hello \\\\g<name>, it\\'s \\\\1\\\"\\ns\\\"Hello \\\\\\\\g<name>, it\\'s \\\\\\\\1\\\"\\n\\njulia> typeof(subst)\\nSubstitutionString{String}\\n\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.@s_str\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.@s_str\",\n    \"category\": \"macro\",\n    \"text\": \"@s_str -> SubstitutionString\\n\\nConstruct a substitution string, used for regular expression substitutions.  Within the string, sequences of the form \\\\N refer to the Nth capture group in the regex, and \\\\g<groupname> refers to a named capture group with name groupname.\\n\\njulia> msg = \\\"#Hello# from Julia\\\";\\n\\njulia> replace(msg, r\\\"#(.+)# from (?<from>\\\\w+)\\\" => s\\\"FROM: \\\\g<from>; MESSAGE: \\\\1\\\")\\n\\\"FROM: Julia; MESSAGE: Hello\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.@raw_str\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.@raw_str\",\n    \"category\": \"macro\",\n    \"text\": \"@raw_str -> String\\n\\nCreate a raw string without interpolation and unescaping. The exception is that quotation marks still must be escaped. Backslashes escape both quotation marks and other backslashes, but only when a sequence of backslashes precedes a quote character. Thus, 2n backslashes followed by a quote encodes n backslashes and the end of the literal while 2n+1 backslashes followed by a quote encodes n backslashes followed by a quote character.\\n\\nExamples\\n\\njulia> println(raw\\\"\\\\ $x\\\")\\n\\\\ $x\\n\\njulia> println(raw\\\"\\\\\\\"\\\")\\n\\\"\\n\\njulia> println(raw\\\"\\\\\\\\\\\\\\\"\\\")\\n\\\\\\\"\\n\\njulia> println(raw\\\"\\\\\\\\x \\\\\\\\\\\\\\\"\\\")\\n\\\\\\\\x \\\\\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.Docs.@html_str\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.Docs.@html_str\",\n    \"category\": \"macro\",\n    \"text\": \"@html_str -> Docs.HTML\\n\\nCreate an HTML object from a literal string.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.Docs.@text_str\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.Docs.@text_str\",\n    \"category\": \"macro\",\n    \"text\": \"@text_str -> Docs.Text\\n\\nCreate a Text object from a literal string.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.isvalid-Tuple{Any}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.isvalid\",\n    \"category\": \"method\",\n    \"text\": \"isvalid(value) -> Bool\\n\\nReturns true if the given value is valid for its type, which currently can be either AbstractChar or String.\\n\\nExamples\\n\\njulia> isvalid(Char(0xd800))\\nfalse\\n\\njulia> isvalid(Char(0xd799))\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.isvalid-Tuple{Any,Any}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.isvalid\",\n    \"category\": \"method\",\n    \"text\": \"isvalid(T, value) -> Bool\\n\\nReturns true if the given value is valid for that type. Types currently can be either AbstractChar or String. Values for AbstractChar can be of type AbstractChar or UInt32. Values for String can be of that type, or Vector{UInt8}.\\n\\nExamples\\n\\njulia> isvalid(Char, 0xd800)\\nfalse\\n\\njulia> isvalid(Char, 0xd799)\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.isvalid-Tuple{AbstractString,Integer}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.isvalid\",\n    \"category\": \"method\",\n    \"text\": \"isvalid(s::AbstractString, i::Integer) -> Bool\\n\\nPredicate indicating whether the given index is the start of the encoding of a character in s or not. If isvalid(s, i) is true then s[i] will return the character whose encoding starts at that index, if it\\'s false, then s[i] will raise an invalid index error or a bounds error depending on if i is in bounds. In order for isvalid(s, i) to be an O(1) function, the encoding of s must be self-synchronizing this is a basic assumption of Julia\\'s generic string support.\\n\\nSee also: getindex, iterate, thisind, nextind, prevind, length\\n\\nExamples\\n\\njulia> str = \\\"\u03b1\u03b2\u03b3def\\\";\\n\\njulia> isvalid(str, 1)\\ntrue\\n\\njulia> str[1]\\n\\'\u03b1\\': Unicode U+03b1 (category Ll: Letter, lowercase)\\n\\njulia> isvalid(str, 2)\\nfalse\\n\\njulia> str[2]\\nERROR: StringIndexError(\\\"\u03b1\u03b2\u03b3def\\\", 2)\\nStacktrace:\\n[...]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.match\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.match\",\n    \"category\": \"function\",\n    \"text\": \"match(r::Regex, s::AbstractString[, idx::Integer[, addopts]])\\n\\nSearch for the first match of the regular expression r in s and return a RegexMatch object containing the match, or nothing if the match failed. The matching substring can be retrieved by accessing m.match and the captured sequences can be retrieved by accessing m.captures The optional idx argument specifies an index at which to start the search.\\n\\nExamples\\n\\njulia> rx = r\\\"a(.)a\\\"\\nr\\\"a(.)a\\\"\\n\\njulia> m = match(rx, \\\"cabac\\\")\\nRegexMatch(\\\"aba\\\", 1=\\\"b\\\")\\n\\njulia> m.captures\\n1-element Array{Union{Nothing, SubString{String}},1}:\\n \\\"b\\\"\\n\\njulia> m.match\\n\\\"aba\\\"\\n\\njulia> match(rx, \\\"cabac\\\", 3) === nothing\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.eachmatch\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.eachmatch\",\n    \"category\": \"function\",\n    \"text\": \"eachmatch(r::Regex, s::AbstractString; overlap::Bool=false])\\n\\nSearch for all matches of a the regular expression r in s and return a iterator over the matches. If overlap is true, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from distinct character ranges.\\n\\nExamples\\n\\njulia> rx = r\\\"a.a\\\"\\nr\\\"a.a\\\"\\n\\njulia> m = eachmatch(rx, \\\"a1a2a3a\\\")\\nBase.RegexMatchIterator(r\\\"a.a\\\", \\\"a1a2a3a\\\", false)\\n\\njulia> collect(m)\\n2-element Array{RegexMatch,1}:\\n RegexMatch(\\\"a1a\\\")\\n RegexMatch(\\\"a3a\\\")\\n\\njulia> collect(eachmatch(rx, \\\"a1a2a3a\\\", overlap = true))\\n3-element Array{RegexMatch,1}:\\n RegexMatch(\\\"a1a\\\")\\n RegexMatch(\\\"a2a\\\")\\n RegexMatch(\\\"a3a\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.isless-Tuple{AbstractString,AbstractString}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.isless\",\n    \"category\": \"method\",\n    \"text\": \"isless(a::AbstractString, b::AbstractString) -> Bool\\n\\nTest whether string a comes before string b in alphabetical order (technically, in lexicographical order by Unicode code points).\\n\\nExamples\\n\\njulia> isless(\\\"a\\\", \\\"b\\\")\\ntrue\\n\\njulia> isless(\\\"\u03b2\\\", \\\"\u03b1\\\")\\nfalse\\n\\njulia> isless(\\\"a\\\", \\\"a\\\")\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.:==-Tuple{AbstractString,AbstractString}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.:==\",\n    \"category\": \"method\",\n    \"text\": \"==(a::AbstractString, b::AbstractString) -> Bool\\n\\nTest whether two strings are equal character by character (technically, Unicode code point by code point).\\n\\nExamples\\n\\njulia> \\\"abc\\\" == \\\"abc\\\"\\ntrue\\n\\njulia> \\\"abc\\\" == \\\"\u03b1\u03b2\u03b3\\\"\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.cmp-Tuple{AbstractString,AbstractString}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.cmp\",\n    \"category\": \"method\",\n    \"text\": \"cmp(a::AbstractString, b::AbstractString) -> Int\\n\\nCompare two strings. Return 0 if both strings have the same length and the character at each index is the same in both strings. Return -1 if a is a prefix of b, or if a comes before b in alphabetical order. Return 1 if b is a prefix of a, or if b comes before a in alphabetical order (technically, lexicographical order by Unicode code points).\\n\\nExamples\\n\\njulia> cmp(\\\"abc\\\", \\\"abc\\\")\\n0\\n\\njulia> cmp(\\\"ab\\\", \\\"abc\\\")\\n-1\\n\\njulia> cmp(\\\"abc\\\", \\\"ab\\\")\\n1\\n\\njulia> cmp(\\\"ab\\\", \\\"ac\\\")\\n-1\\n\\njulia> cmp(\\\"ac\\\", \\\"ab\\\")\\n1\\n\\njulia> cmp(\\\"\u03b1\\\", \\\"a\\\")\\n1\\n\\njulia> cmp(\\\"b\\\", \\\"\u03b2\\\")\\n-1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.lpad\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.lpad\",\n    \"category\": \"function\",\n    \"text\": \"lpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=\\' \\') -> String\\n\\nStringify s and pad the resulting string on the left with p to make it n characters (code points) long. If s is already n characters long, an equal string is returned. Pad with spaces by default.\\n\\nExamples\\n\\njulia> lpad(\\\"March\\\", 10)\\n\\\"     March\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.rpad\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.rpad\",\n    \"category\": \"function\",\n    \"text\": \"rpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=\\' \\') -> String\\n\\nStringify s and pad the resulting string on the right with p to make it n characters (code points) long. If s is already n characters long, an equal string is returned. Pad with spaces by default.\\n\\nExamples\\n\\njulia> rpad(\\\"March\\\", 20)\\n\\\"March               \\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.findfirst-Tuple{AbstractString,AbstractString}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.findfirst\",\n    \"category\": \"method\",\n    \"text\": \"findfirst(pattern::AbstractString, string::AbstractString)\\nfindfirst(pattern::Regex, string::String)\\n\\nFind the first occurrence of pattern in string. Equivalent to findnext(pattern, string, firstindex(s)).\\n\\nExamples\\n\\njulia> findfirst(\\\"z\\\", \\\"Hello to the world\\\") # returns nothing, but not printed in the REPL\\n\\njulia> findfirst(\\\"Julia\\\", \\\"JuliaLang\\\")\\n1:5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.findnext-Tuple{AbstractString,AbstractString,Integer}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.findnext\",\n    \"category\": \"method\",\n    \"text\": \"findnext(pattern::AbstractString, string::AbstractString, start::Integer)\\nfindnext(pattern::Regex, string::String, start::Integer)\\n\\nFind the next occurrence of pattern in string starting at position start. pattern can be either a string, or a regular expression, in which case string must be of type String.\\n\\nThe return value is a range of indices where the matching sequence is found, such that s[findnext(x, s, i)] == x:\\n\\nfindnext(\\\"substring\\\", string, i) = start:end such that string[start:end] == \\\"substring\\\", or nothing if unmatched.\\n\\nExamples\\n\\njulia> findnext(\\\"z\\\", \\\"Hello to the world\\\", 1) === nothing\\ntrue\\n\\njulia> findnext(\\\"o\\\", \\\"Hello to the world\\\", 6)\\n8:8\\n\\njulia> findnext(\\\"Lang\\\", \\\"JuliaLang\\\", 2)\\n6:9\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.findlast-Tuple{AbstractString,AbstractString}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.findlast\",\n    \"category\": \"method\",\n    \"text\": \"findlast(pattern::AbstractString, string::AbstractString)\\nfindlast(pattern::Regex, string::String)\\n\\nFind the last occurrence of pattern in string. Equivalent to findlast(pattern, string, lastindex(s)).\\n\\nExamples\\n\\njulia> findlast(\\\"o\\\", \\\"Hello to the world\\\")\\n15:15\\n\\njulia> findfirst(\\\"Julia\\\", \\\"JuliaLang\\\")\\n1:5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.findprev-Tuple{AbstractString,AbstractString,Integer}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.findprev\",\n    \"category\": \"method\",\n    \"text\": \"findprev(pattern::AbstractString, string::AbstractString, start::Integer)\\nfindprev(pattern::Regex, string::String, start::Integer)\\n\\nFind the previous occurrence of pattern in string starting at position start. pattern can be either a string, or a regular expression, in which case string must be of type String.\\n\\nThe return value is a range of indices where the matching sequence is found, such that s[findprev(x, s, i)] == x:\\n\\nfindprev(\\\"substring\\\", string, i) = start:end such that string[start:end] == \\\"substring\\\", or nothing if unmatched.\\n\\nExamples\\n\\njulia> findprev(\\\"z\\\", \\\"Hello to the world\\\", 18) === nothing\\ntrue\\n\\njulia> findprev(\\\"o\\\", \\\"Hello to the world\\\", 18)\\n15:15\\n\\njulia> findprev(\\\"Julia\\\", \\\"JuliaLang\\\", 6)\\n1:5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.occursin\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.occursin\",\n    \"category\": \"function\",\n    \"text\": \"occursin(needle::Union{AbstractString,Regex,AbstractChar}, haystack::AbstractString)\\n\\nDetermine whether the first argument is a substring of the second. If needle is a regular expression, checks whether haystack contains a match.\\n\\nExamples\\n\\njulia> occursin(\\\"Julia\\\", \\\"JuliaLang is pretty cool!\\\")\\ntrue\\n\\njulia> occursin(\\'a\\', \\\"JuliaLang is pretty cool!\\\")\\ntrue\\n\\njulia> occursin(r\\\"a.a\\\", \\\"aba\\\")\\ntrue\\n\\njulia> occursin(r\\\"a.a\\\", \\\"abba\\\")\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.reverse-Tuple{Union{SubString{String}, String}}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.reverse\",\n    \"category\": \"method\",\n    \"text\": \"reverse(s::AbstractString) -> AbstractString\\n\\nReverses a string. Technically, this function reverses the codepoints in a string and its main utility is for reversed-order string processing, especially for reversed regular-expression searches. See also reverseind to convert indices in s to indices in reverse(s) and vice-versa, and graphemes from module Unicode to operate on user-visible \\\"characters\\\" (graphemes) rather than codepoints. See also Iterators.reverse for reverse-order iteration without making a copy. Custom string types must implement the reverse function themselves and should typically return a string with the same type and encoding. If they return a string with a different encoding, they must also override reverseind for that string type to satisfy s[reverseind(s,i)] == reverse(s)[i].\\n\\nExamples\\n\\njulia> reverse(\\\"JuliaLang\\\")\\n\\\"gnaLailuJ\\\"\\n\\njulia> reverse(\\\"ax\u0302e\\\") # combining characters can lead to surprising results\\n\\\"e\u0302xa\\\"\\n\\njulia> using Unicode\\n\\njulia> join(reverse(collect(graphemes(\\\"ax\u0302e\\\")))) # reverses graphemes\\n\\\"ex\u0302a\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.replace-Tuple{AbstractString,Pair}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.replace\",\n    \"category\": \"method\",\n    \"text\": \"replace(s::AbstractString, pat=>r; [count::Integer])\\n\\nSearch for the given pattern pat in s, and replace each occurrence with r. If count is provided, replace at most count occurrences. pat may be a single character, a vector or a set of characters, a string, or a regular expression. If r is a function, each occurrence is replaced with r(s) where s is the matched substring (when patis a Regex or AbstractString) or character (when pat is an AbstractChar or a collection of AbstractChar). If pat is a regular expression and r is a SubstitutionString, then capture group references in r are replaced with the corresponding matched text. To remove instances of pat from string, set r to the empty String (\\\"\\\").\\n\\nExamples\\n\\njulia> replace(\\\"Python is a programming language.\\\", \\\"Python\\\" => \\\"Julia\\\")\\n\\\"Julia is a programming language.\\\"\\n\\njulia> replace(\\\"The quick foxes run quickly.\\\", \\\"quick\\\" => \\\"slow\\\", count=1)\\n\\\"The slow foxes run quickly.\\\"\\n\\njulia> replace(\\\"The quick foxes run quickly.\\\", \\\"quick\\\" => \\\"\\\", count=1)\\n\\\"The  foxes run quickly.\\\"\\n\\njulia> replace(\\\"The quick foxes run quickly.\\\", r\\\"fox(es)?\\\" => s\\\"bus\\\\1\\\")\\n\\\"The quick buses run quickly.\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.split\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.split\",\n    \"category\": \"function\",\n    \"text\": \"split(str::AbstractString, dlm; limit::Integer=0, keepempty::Bool=true)\\nsplit(str::AbstractString; limit::Integer=0, keepempty::Bool=false)\\n\\nSplit str into an array of substrings on occurrences of the delimiter(s) dlm.  dlm can be any of the formats allowed by findnext\\'s first argument (i.e. as a string, regular expression or a function), or as a single character or collection of characters.\\n\\nIf dlm is omitted, it defaults to isspace.\\n\\nThe optional keyword arguments are:\\n\\nlimit: the maximum size of the result. limit=0 implies no maximum (default)\\nkeepempty: whether empty fields should be kept in the result. Default is false without a dlm argument, true with a dlm argument.\\n\\nSee also rsplit.\\n\\nExamples\\n\\njulia> a = \\\"Ma.rch\\\"\\n\\\"Ma.rch\\\"\\n\\njulia> split(a,\\\".\\\")\\n2-element Array{SubString{String},1}:\\n \\\"Ma\\\"\\n \\\"rch\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.rsplit\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.rsplit\",\n    \"category\": \"function\",\n    \"text\": \"rsplit(s::AbstractString; limit::Integer=0, keepempty::Bool=false)\\nrsplit(s::AbstractString, chars; limit::Integer=0, keepempty::Bool=true)\\n\\nSimilar to split, but starting from the end of the string.\\n\\nExamples\\n\\njulia> a = \\\"M.a.r.c.h\\\"\\n\\\"M.a.r.c.h\\\"\\n\\njulia> rsplit(a,\\\".\\\")\\n5-element Array{SubString{String},1}:\\n \\\"M\\\"\\n \\\"a\\\"\\n \\\"r\\\"\\n \\\"c\\\"\\n \\\"h\\\"\\n\\njulia> rsplit(a,\\\".\\\";limit=1)\\n1-element Array{SubString{String},1}:\\n \\\"M.a.r.c.h\\\"\\n\\njulia> rsplit(a,\\\".\\\";limit=2)\\n2-element Array{SubString{String},1}:\\n \\\"M.a.r.c\\\"\\n \\\"h\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.strip\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.strip\",\n    \"category\": \"function\",\n    \"text\": \"strip(str::AbstractString, [chars])\\n\\nRemove leading and trailing characters from str.\\n\\nThe default behaviour is to remove leading whitespace and delimiters: see isspace for precise details.\\n\\nThe optional chars argument specifies which characters to remove: it can be a single character, vector or set of characters, or a predicate function.\\n\\nExamples\\n\\njulia> strip(\\\"{3, 5}\\\\n\\\", [\\'{\\', \\'}\\', \\'\\\\n\\'])\\n\\\"3, 5\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.lstrip\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.lstrip\",\n    \"category\": \"function\",\n    \"text\": \"lstrip([pred=isspace,] str::AbstractString)\\nlstrip(str::AbstractString, chars)\\n\\nRemove leading characters from str, either those specified by chars or those for which the function pred returns true.\\n\\nThe default behaviour is to remove leading whitespace and delimiters: see isspace for precise details.\\n\\nThe optional chars argument specifies which characters to remove: it can be a single character, or a vector or set of characters.\\n\\nExamples\\n\\njulia> a = lpad(\\\"March\\\", 20)\\n\\\"               March\\\"\\n\\njulia> lstrip(a)\\n\\\"March\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.rstrip\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.rstrip\",\n    \"category\": \"function\",\n    \"text\": \"rstrip([pred=isspace,] str::AbstractString)\\nrstrip(str::AbstractString, chars)\\n\\nRemove trailing characters from str, either those specified by chars or those for which the function pred returns true.\\n\\nThe default behaviour is to remove leading whitespace and delimiters: see isspace for precise details.\\n\\nThe optional chars argument specifies which characters to remove: it can be a single character, or a vector or set of characters.\\n\\nExamples\\n\\njulia> a = rpad(\\\"March\\\", 20)\\n\\\"March               \\\"\\n\\njulia> rstrip(a)\\n\\\"March\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.startswith\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.startswith\",\n    \"category\": \"function\",\n    \"text\": \"startswith(s::AbstractString, prefix::AbstractString)\\n\\nReturn true if s starts with prefix. If prefix is a vector or set of characters, test whether the first character of s belongs to that set.\\n\\nSee also endswith.\\n\\nExamples\\n\\njulia> startswith(\\\"JuliaLang\\\", \\\"Julia\\\")\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.endswith\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.endswith\",\n    \"category\": \"function\",\n    \"text\": \"endswith(s::AbstractString, suffix::AbstractString)\\n\\nReturn true if s ends with suffix. If suffix is a vector or set of characters, test whether the last character of s belongs to that set.\\n\\nSee also startswith.\\n\\nExamples\\n\\njulia> endswith(\\\"Sunday\\\", \\\"day\\\")\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.first-Tuple{AbstractString,Integer}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.first\",\n    \"category\": \"method\",\n    \"text\": \"first(s::AbstractString, n::Integer)\\n\\nGet a string consisting of the first n characters of s.\\n\\njulia> first(\\\"\u2200\u03f5\u22600: \u03f5\u00b2>0\\\", 0)\\n\\\"\\\"\\n\\njulia> first(\\\"\u2200\u03f5\u22600: \u03f5\u00b2>0\\\", 1)\\n\\\"\u2200\\\"\\n\\njulia> first(\\\"\u2200\u03f5\u22600: \u03f5\u00b2>0\\\", 3)\\n\\\"\u2200\u03f5\u2260\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.last-Tuple{AbstractString,Integer}\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.last\",\n    \"category\": \"method\",\n    \"text\": \"last(s::AbstractString, n::Integer)\\n\\nGet a string consisting of the last n characters of s.\\n\\njulia> last(\\\"\u2200\u03f5\u22600: \u03f5\u00b2>0\\\", 0)\\n\\\"\\\"\\n\\njulia> last(\\\"\u2200\u03f5\u22600: \u03f5\u00b2>0\\\", 1)\\n\\\"0\\\"\\n\\njulia> last(\\\"\u2200\u03f5\u22600: \u03f5\u00b2>0\\\", 3)\\n\\\"\u00b2>0\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.Unicode.uppercase\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.Unicode.uppercase\",\n    \"category\": \"function\",\n    \"text\": \"uppercase(s::AbstractString)\\n\\nReturn s with all characters converted to uppercase.\\n\\nExamples\\n\\njulia> uppercase(\\\"Julia\\\")\\n\\\"JULIA\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.Unicode.lowercase\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.Unicode.lowercase\",\n    \"category\": \"function\",\n    \"text\": \"lowercase(s::AbstractString)\\n\\nReturn s with all characters converted to lowercase.\\n\\nExamples\\n\\njulia> lowercase(\\\"STRINGS AND THINGS\\\")\\n\\\"strings and things\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.Unicode.titlecase\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.Unicode.titlecase\",\n    \"category\": \"function\",\n    \"text\": \"titlecase(s::AbstractString; [wordsep::Function], strict::Bool=true) -> String\\n\\nCapitalize the first character of each word in s; if strict is true, every other character is converted to lowercase, otherwise they are left unchanged. By default, all non-letters are considered as word separators; a predicate can be passed as the wordsep keyword to determine which characters should be considered as word separators. See also uppercasefirst to capitalize only the first character in s.\\n\\nExamples\\n\\njulia> titlecase(\\\"the JULIA programming language\\\")\\n\\\"The Julia Programming Language\\\"\\n\\njulia> titlecase(\\\"ISS - international space station\\\", strict=false)\\n\\\"ISS - International Space Station\\\"\\n\\njulia> titlecase(\\\"a-a b-b\\\", wordsep = c->c==\\' \\')\\n\\\"A-a B-b\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.Unicode.uppercasefirst\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.Unicode.uppercasefirst\",\n    \"category\": \"function\",\n    \"text\": \"uppercasefirst(s::AbstractString) -> String\\n\\nReturn s with the first character converted to uppercase (technically \\\"title case\\\" for Unicode). See also titlecase to capitalize the first character of every word in s.\\n\\nSee also: lowercasefirst, uppercase, lowercase, titlecase\\n\\nExamples\\n\\njulia> uppercasefirst(\\\"python\\\")\\n\\\"Python\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.Unicode.lowercasefirst\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.Unicode.lowercasefirst\",\n    \"category\": \"function\",\n    \"text\": \"lowercasefirst(s::AbstractString)\\n\\nReturn s with the first character converted to lowercase.\\n\\nSee also: uppercasefirst, uppercase, lowercase, titlecase\\n\\nExamples\\n\\njulia> lowercasefirst(\\\"Julia\\\")\\n\\\"julia\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.join\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.join\",\n    \"category\": \"function\",\n    \"text\": \"join([io::IO,] strings, delim, [last])\\n\\nJoin an array of strings into a single string, inserting the given delimiter between adjacent strings. If last is given, it will be used instead of delim between the last two strings. If io is given, the result is written to io rather than returned as as a String.  For example,\\n\\nExamples\\n\\njulia> join([\\\"apples\\\", \\\"bananas\\\", \\\"pineapples\\\"], \\\", \\\", \\\" and \\\")\\n\\\"apples, bananas and pineapples\\\"\\n\\nstrings can be any iterable over elements x which are convertible to strings via print(io::IOBuffer, x). strings will be printed to io.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.chop\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.chop\",\n    \"category\": \"function\",\n    \"text\": \"chop(s::AbstractString; head::Integer = 0, tail::Integer = 1)\\n\\nRemove the first head and the last tail characters from s. The call chop(s) removes the last character from s. If it is requested to remove more characters than length(s) then an empty string is returned.\\n\\nExamples\\n\\njulia> a = \\\"March\\\"\\n\\\"March\\\"\\n\\njulia> chop(a)\\n\\\"Marc\\\"\\n\\njulia> chop(a, head = 1, tail = 2)\\n\\\"ar\\\"\\n\\njulia> chop(a, head = 5, tail = 5)\\n\\\"\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.chomp\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.chomp\",\n    \"category\": \"function\",\n    \"text\": \"chomp(s::AbstractString)\\n\\nRemove a single trailing newline from a string.\\n\\nExamples\\n\\njulia> chomp(\\\"Hello\\\\n\\\")\\n\\\"Hello\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.thisind\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.thisind\",\n    \"category\": \"function\",\n    \"text\": \"thisind(s::AbstractString, i::Integer) -> Int\\n\\nIf i is in bounds in s return the index of the start of the character whose encoding code unit i is part of. In other words, if i is the start of a character, return i; if i is not the start of a character, rewind until the start of a character and return that index. If i is equal to 0 or ncodeunits(s)+1 return i. In all other cases throw BoundsError.\\n\\nExamples\\n\\njulia> thisind(\\\"\u03b1\\\", 0)\\n0\\n\\njulia> thisind(\\\"\u03b1\\\", 1)\\n1\\n\\njulia> thisind(\\\"\u03b1\\\", 2)\\n1\\n\\njulia> thisind(\\\"\u03b1\\\", 3)\\n3\\n\\njulia> thisind(\\\"\u03b1\\\", 4)\\nERROR: BoundsError: attempt to access \\\"\u03b1\\\"\\n  at index [4]\\n[...]\\n\\njulia> thisind(\\\"\u03b1\\\", -1)\\nERROR: BoundsError: attempt to access \\\"\u03b1\\\"\\n  at index [-1]\\n[...]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.nextind\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.nextind\",\n    \"category\": \"function\",\n    \"text\": \"nextind(str::AbstractString, i::Integer, n::Integer=1) -> Int\\n\\nCase n == 1\\nIf i is in bounds in s return the index of the start of the character whose encoding starts after index i. In other words, if i is the start of a character, return the start of the next character; if i is not the start of a character, move forward until the start of a character and return that index. If i is equal to 0 return 1. If i is in bounds but greater or equal to lastindex(str) return ncodeunits(str)+1. Otherwise throw BoundsError.\\nCase n > 1\\nBehaves like applying n times nextind for n==1. The only difference is that if n is so large that applying nextind would reach ncodeunits(str)+1 then each remaining iteration increases the returned value by 1. This means that in this case nextind can return a value greater than ncodeunits(str)+1.\\nCase n == 0\\nReturn i only if i is a valid index in s or is equal to 0. Otherwise StringIndexError or BoundsError is thrown.\\n\\nExamples\\n\\njulia> nextind(\\\"\u03b1\\\", 0)\\n1\\n\\njulia> nextind(\\\"\u03b1\\\", 1)\\n3\\n\\njulia> nextind(\\\"\u03b1\\\", 3)\\nERROR: BoundsError: attempt to access \\\"\u03b1\\\"\\n  at index [3]\\n[...]\\n\\njulia> nextind(\\\"\u03b1\\\", 0, 2)\\n3\\n\\njulia> nextind(\\\"\u03b1\\\", 1, 2)\\n4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.prevind\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.prevind\",\n    \"category\": \"function\",\n    \"text\": \"prevind(str::AbstractString, i::Integer, n::Integer=1) -> Int\\n\\nCase n == 1\\nIf i is in bounds in s return the index of the start of the character whose encoding starts before index i. In other words, if i is the start of a character, return the start of the previous character; if i is not the start of a character, rewind until the start of a character and return that index. If i is equal to 1 return 0. If i is equal to ncodeunits(str)+1 return lastindex(str). Otherwise throw BoundsError.\\nCase n > 1\\nBehaves like applying n times prevind for n==1. The only difference is that if n is so large that applying prevind would reach 0 then each remaining iteration decreases the returned value by 1. This means that in this case prevind can return a negative value.\\nCase n == 0\\nReturn i only if i is a valid index in str or is equal to ncodeunits(str)+1. Otherwise StringIndexError or BoundsError is thrown.\\n\\nExamples\\n\\njulia> prevind(\\\"\u03b1\\\", 3)\\n1\\n\\njulia> prevind(\\\"\u03b1\\\", 1)\\n0\\n\\njulia> prevind(\\\"\u03b1\\\", 0)\\nERROR: BoundsError: attempt to access \\\"\u03b1\\\"\\n  at index [0]\\n[...]\\n\\njulia> prevind(\\\"\u03b1\\\", 2, 2)\\n0\\n\\njulia> prevind(\\\"\u03b1\\\", 2, 3)\\n-1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.Unicode.textwidth\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.Unicode.textwidth\",\n    \"category\": \"function\",\n    \"text\": \"textwidth(c)\\n\\nGive the number of columns needed to print a character.\\n\\nExamples\\n\\njulia> textwidth(\\'\u03b1\\')\\n1\\n\\njulia> textwidth(\\'\u2764\\')\\n2\\n\\n\\n\\n\\n\\ntextwidth(s::AbstractString)\\n\\nGive the number of columns needed to print a string.\\n\\nExamples\\n\\njulia> textwidth(\\\"March\\\")\\n5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.isascii\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.isascii\",\n    \"category\": \"function\",\n    \"text\": \"isascii(c::Union{AbstractChar,AbstractString}) -> Bool\\n\\nTest whether a character belongs to the ASCII character set, or whether this is true for all elements of a string.\\n\\nExamples\\n\\njulia> isascii(\\'a\\')\\ntrue\\n\\njulia> isascii(\\'\u03b1\\')\\nfalse\\n\\njulia> isascii(\\\"abc\\\")\\ntrue\\n\\njulia> isascii(\\\"\u03b1\u03b2\u03b3\\\")\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.Unicode.iscntrl\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.Unicode.iscntrl\",\n    \"category\": \"function\",\n    \"text\": \"iscntrl(c::AbstractChar) -> Bool\\n\\nTests whether a character is a control character. Control characters are the non-printing characters of the Latin-1 subset of Unicode.\\n\\nExamples\\n\\njulia> iscntrl(\\'\\\\x01\\')\\ntrue\\n\\njulia> iscntrl(\\'a\\')\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.Unicode.isdigit\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.Unicode.isdigit\",\n    \"category\": \"function\",\n    \"text\": \"isdigit(c::AbstractChar) -> Bool\\n\\nTests whether a character is a decimal digit (0-9).\\n\\nExamples\\n\\njulia> isdigit(\\'\u2764\\')\\nfalse\\n\\njulia> isdigit(\\'9\\')\\ntrue\\n\\njulia> isdigit(\\'\u03b1\\')\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.Unicode.isletter\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.Unicode.isletter\",\n    \"category\": \"function\",\n    \"text\": \"isletter(c::AbstractChar) -> Bool\\n\\nTest whether a character is a letter. A character is classified as a letter if it belongs to the Unicode general category Letter, i.e. a character whose category code begins with \\'L\\'.\\n\\nExamples\\n\\njulia> isletter(\\'\u2764\\')\\nfalse\\n\\njulia> isletter(\\'\u03b1\\')\\ntrue\\n\\njulia> isletter(\\'9\\')\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.Unicode.islowercase\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.Unicode.islowercase\",\n    \"category\": \"function\",\n    \"text\": \"islowercase(c::AbstractChar) -> Bool\\n\\nTests whether a character is a lowercase letter. A character is classified as lowercase if it belongs to Unicode category Ll, Letter: Lowercase.\\n\\nExamples\\n\\njulia> islowercase(\\'\u03b1\\')\\ntrue\\n\\njulia> islowercase(\\'\u0393\\')\\nfalse\\n\\njulia> islowercase(\\'\u2764\\')\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.Unicode.isnumeric\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.Unicode.isnumeric\",\n    \"category\": \"function\",\n    \"text\": \"isnumeric(c::AbstractChar) -> Bool\\n\\nTests whether a character is numeric. A character is classified as numeric if it belongs to the Unicode general category Number, i.e. a character whose category code begins with \\'N\\'.\\n\\nNote that this broad category includes characters such as \u00be and \u0bf0. Use isdigit to check whether a character a decimal digit between 0 and 9.\\n\\nExamples\\n\\njulia> isnumeric(\\'\u0bf0\\')\\ntrue\\n\\njulia> isnumeric(\\'9\\')\\ntrue\\n\\njulia> isnumeric(\\'\u03b1\\')\\nfalse\\n\\njulia> isnumeric(\\'\u2764\\')\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.Unicode.isprint\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.Unicode.isprint\",\n    \"category\": \"function\",\n    \"text\": \"isprint(c::AbstractChar) -> Bool\\n\\nTests whether a character is printable, including spaces, but not a control character.\\n\\nExamples\\n\\njulia> isprint(\\'\\\\x01\\')\\nfalse\\n\\njulia> isprint(\\'A\\')\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.Unicode.ispunct\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.Unicode.ispunct\",\n    \"category\": \"function\",\n    \"text\": \"ispunct(c::AbstractChar) -> Bool\\n\\nTests whether a character belongs to the Unicode general category Punctuation, i.e. a character whose category code begins with \\'P\\'.\\n\\nExamples\\n\\njulia> ispunct(\\'\u03b1\\')\\nfalse\\n\\njulia> ispunct(\\'/\\')\\ntrue\\n\\njulia> ispunct(\\';\\')\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.Unicode.isspace\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.Unicode.isspace\",\n    \"category\": \"function\",\n    \"text\": \"isspace(c::AbstractChar) -> Bool\\n\\nTests whether a character is any whitespace character. Includes ASCII characters \\'\\\\t\\', \\'\\\\n\\', \\'\\\\v\\', \\'\\\\f\\', \\'\\\\r\\', and \\' \\', Latin-1 character U+0085, and characters in Unicode category Zs.\\n\\nExamples\\n\\njulia> isspace(\\'\\\\n\\')\\ntrue\\n\\njulia> isspace(\\'\\\\r\\')\\ntrue\\n\\njulia> isspace(\\' \\')\\ntrue\\n\\njulia> isspace(\\'\\\\x20\\')\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.Unicode.isuppercase\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.Unicode.isuppercase\",\n    \"category\": \"function\",\n    \"text\": \"isuppercase(c::AbstractChar) -> Bool\\n\\nTests whether a character is an uppercase letter. A character is classified as uppercase if it belongs to Unicode category Lu, Letter: Uppercase, or Lt, Letter: Titlecase.\\n\\nExamples\\n\\njulia> isuppercase(\\'\u03b3\\')\\nfalse\\n\\njulia> isuppercase(\\'\u0393\\')\\ntrue\\n\\njulia> isuppercase(\\'\u2764\\')\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.Unicode.isxdigit\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.Unicode.isxdigit\",\n    \"category\": \"function\",\n    \"text\": \"isxdigit(c::AbstractChar) -> Bool\\n\\nTest whether a character is a valid hexadecimal digit. Note that this does not include x (as in the standard 0x prefix).\\n\\nExamples\\n\\njulia> isxdigit(\\'a\\')\\ntrue\\n\\njulia> isxdigit(\\'x\\')\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Core.Symbol\",\n    \"page\": \"Strings\",\n    \"title\": \"Core.Symbol\",\n    \"category\": \"type\",\n    \"text\": \"Symbol(x...) -> Symbol\\n\\nCreate a Symbol by concatenating the string representations of the arguments together.\\n\\nExamples\\n\\njulia> Symbol(\\\"my\\\", \\\"name\\\")\\n:myname\\n\\njulia> Symbol(\\\"day\\\", 4)\\n:day4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.escape_string\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.escape_string\",\n    \"category\": \"function\",\n    \"text\": \"escape_string(str::AbstractString[, esc])::AbstractString\\nescape_string(io, str::AbstractString[, esc::])::Nothing\\n\\nGeneral escaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to io.\\n\\nBackslashes (\\\\) are escaped with a double-backslash (\\\"\\\\\\\\\\\"). Non-printable characters are escaped either with their standard C escape codes, \\\"\\\\0\\\" for NUL (if unambiguous), unicode code point (\\\"\\\\u\\\" prefix) or hex (\\\"\\\\x\\\" prefix).\\n\\nThe optional esc argument specifies any additional characters that should also be escaped by a prepending backslash (\\\" is also escaped by default in the first form).\\n\\nExamples\\n\\njulia> escape_string(\\\"aaa\\\\nbbb\\\")\\n\\\"aaa\\\\\\\\nbbb\\\"\\n\\njulia> escape_string(\\\"\\\\xfe\\\\xff\\\") # invalid utf-8\\n\\\"\\\\\\\\xfe\\\\\\\\xff\\\"\\n\\njulia> escape_string(string(\\'\\\\u2135\\',\\'\\\\0\\')) # unambiguous\\n\\\"\u2135\\\\\\\\0\\\"\\n\\njulia> escape_string(string(\\'\\\\u2135\\',\\'\\\\0\\',\\'0\\')) # \\\\0 would be ambiguous\\n\\\"\u2135\\\\\\\\x000\\\"\\n\\nSee also\\n\\nunescape_string for the reverse operation.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#Base.unescape_string\",\n    \"page\": \"Strings\",\n    \"title\": \"Base.unescape_string\",\n    \"category\": \"function\",\n    \"text\": \"unescape_string(str::AbstractString)::AbstractString\\nunescape_string(io, str::AbstractString)::Nothing\\n\\nGeneral unescaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to io.\\n\\nThe following escape sequences are recognised:\\n\\nEscaped backslash (\\\\\\\\)\\nEscaped double-quote (\\\\\\\")\\nStandard C escape sequences (\\\\a, \\\\b, \\\\t, \\\\n, \\\\v, \\\\f, \\\\r, \\\\e)\\nUnicode code points (\\\\u or \\\\U prefixes with 1-4 trailing hex digits)\\nHex bytes (\\\\x with 1-2 trailing hex digits)\\nOctal bytes (\\\\ with 1-3 trailing octal digits)\\n\\nExamples\\n\\njulia> unescape_string(\\\"aaa\\\\\\\\nbbb\\\") # C escape sequence\\n\\\"aaa\\\\nbbb\\\"\\n\\njulia> unescape_string(\\\"\\\\\\\\u03c0\\\") # unicode\\n\\\"\u03c0\\\"\\n\\njulia> unescape_string(\\\"\\\\\\\\101\\\") # octal\\n\\\"A\\\"\\n\\nSee also\\n\\nescape_string.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/strings.html#lib-strings-1\",\n    \"page\": \"Strings\",\n    \"title\": \"Strings\",\n    \"category\": \"section\",\n    \"text\": \"Core.AbstractChar\\nCore.Char\\nBase.codepoint\\nBase.length(::AbstractString)\\nBase.sizeof(::AbstractString)\\nBase.:*(::Union{AbstractChar, AbstractString}, ::Union{AbstractChar, AbstractString}...)\\nBase.:^(::AbstractString, ::Integer)\\nBase.string\\nBase.repeat(::AbstractString, ::Integer)\\nBase.repeat(::AbstractChar, ::Integer)\\nBase.repr(::Any)\\nCore.String(::AbstractString)\\nBase.SubString\\nBase.transcode\\nBase.unsafe_string\\nBase.ncodeunits(::AbstractString)\\nBase.codeunit\\nBase.codeunits\\nBase.ascii\\nBase.@r_str\\nBase.SubstitutionString\\nBase.@s_str\\nBase.@raw_str\\nBase.Docs.@html_str\\nBase.Docs.@text_str\\nBase.isvalid(::Any)\\nBase.isvalid(::Any, ::Any)\\nBase.isvalid(::AbstractString, ::Integer)\\nBase.match\\nBase.eachmatch\\nBase.isless(::AbstractString, ::AbstractString)\\nBase.:(==)(::AbstractString, ::AbstractString)\\nBase.cmp(::AbstractString, ::AbstractString)\\nBase.lpad\\nBase.rpad\\nBase.findfirst(::AbstractString, ::AbstractString)\\nBase.findnext(::AbstractString, ::AbstractString, ::Integer)\\nBase.findlast(::AbstractString, ::AbstractString)\\nBase.findprev(::AbstractString, ::AbstractString, ::Integer)\\nBase.occursin\\nBase.reverse(::Union{String,SubString{String}})\\nBase.replace(s::AbstractString, ::Pair)\\nBase.split\\nBase.rsplit\\nBase.strip\\nBase.lstrip\\nBase.rstrip\\nBase.startswith\\nBase.endswith\\nBase.first(::AbstractString, ::Integer)\\nBase.last(::AbstractString, ::Integer)\\nBase.uppercase\\nBase.lowercase\\nBase.titlecase\\nBase.uppercasefirst\\nBase.lowercasefirst\\nBase.join\\nBase.chop\\nBase.chomp\\nBase.thisind\\nBase.nextind\\nBase.prevind\\nBase.textwidth\\nBase.isascii\\nBase.iscntrl\\nBase.isdigit\\nBase.isletter\\nBase.islowercase\\nBase.isnumeric\\nBase.isprint\\nBase.ispunct\\nBase.isspace\\nBase.isuppercase\\nBase.isxdigit\\nCore.Symbol\\nBase.escape_string\\nBase.unescape_string\"\n},\n\n{\n    \"location\": \"base/arrays.html#\",\n    \"page\": \"Arrays\",\n    \"title\": \"Arrays\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/arrays.html#lib-arrays-1\",\n    \"page\": \"Arrays\",\n    \"title\": \"Arrays\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/arrays.html#Core.AbstractArray\",\n    \"page\": \"Arrays\",\n    \"title\": \"Core.AbstractArray\",\n    \"category\": \"type\",\n    \"text\": \"AbstractArray{T,N}\\n\\nSupertype for N-dimensional arrays (or array-like types) with elements of type T. Array and other types are subtypes of this. See the manual section on the AbstractArray interface.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.AbstractVector\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.AbstractVector\",\n    \"category\": \"type\",\n    \"text\": \"AbstractVector{T}\\n\\nSupertype for one-dimensional arrays (or array-like types) with elements of type T. Alias for AbstractArray{T,1}.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.AbstractMatrix\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.AbstractMatrix\",\n    \"category\": \"type\",\n    \"text\": \"AbstractMatrix{T}\\n\\nSupertype for two-dimensional arrays (or array-like types) with elements of type T. Alias for AbstractArray{T,2}.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.AbstractVecOrMat\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.AbstractVecOrMat\",\n    \"category\": \"constant\",\n    \"text\": \"AbstractVecOrMat{T}\\n\\nUnion type of AbstractVector{T} and AbstractMatrix{T}.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Core.Array\",\n    \"page\": \"Arrays\",\n    \"title\": \"Core.Array\",\n    \"category\": \"type\",\n    \"text\": \"Array{T,N} <: AbstractArray{T,N}\\n\\nN-dimensional dense array with elements of type T.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Core.Array-Tuple{UndefInitializer,Any}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Core.Array\",\n    \"category\": \"method\",\n    \"text\": \"Array{T}(undef, dims)\\nArray{T,N}(undef, dims)\\n\\nConstruct an uninitialized N-dimensional Array containing elements of type T. N can either be supplied explicitly, as in Array{T,N}(undef, dims), or be determined by the length or number of dims. dims may be a tuple or a series of integer arguments corresponding to the lengths in each dimension. If the rank N is supplied explicitly, then it must match the length or number of dims. See undef.\\n\\nExamples\\n\\njulia> A = Array{Float64,2}(undef, 2, 3) # N given explicitly\\n2\u00d73 Array{Float64,2}:\\n 6.90198e-310  6.90198e-310  6.90198e-310\\n 6.90198e-310  6.90198e-310  0.0\\n\\njulia> B = Array{Float64}(undef, 2) # N determined by the input\\n2-element Array{Float64,1}:\\n 1.87103e-320\\n 0.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Core.Array-Tuple{Nothing,Any}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Core.Array\",\n    \"category\": \"method\",\n    \"text\": \"Array{T}(nothing, dims)\\nArray{T,N}(nothing, dims)\\n\\nConstruct an N-dimensional Array containing elements of type T, initialized with nothing entries. Element type T must be able to hold these values, i.e. Nothing <: T.\\n\\nExamples\\n\\njulia> Array{Union{Nothing, String}}(nothing, 2)\\n2-element Array{Union{Nothing, String},1}:\\n nothing\\n nothing\\n\\njulia> Array{Union{Nothing, Int}}(nothing, 2, 3)\\n2\u00d73 Array{Union{Nothing, Int64},2}:\\n nothing  nothing  nothing\\n nothing  nothing  nothing\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Core.Array-Tuple{Missing,Any}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Core.Array\",\n    \"category\": \"method\",\n    \"text\": \"Array{T}(missing, dims)\\nArray{T,N}(missing, dims)\\n\\nConstruct an N-dimensional Array containing elements of type T, initialized with missing entries. Element type T must be able to hold these values, i.e. Missing <: T.\\n\\nExamples\\n\\njulia> Array{Union{Missing, String}}(missing, 2)\\n2-element Array{Union{Missing, String},1}:\\n missing\\n missing\\n\\njulia> Array{Union{Missing, Int}}(missing, 2, 3)\\n2\u00d73 Array{Union{Missing, Int64},2}:\\n missing  missing  missing\\n missing  missing  missing\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Core.UndefInitializer\",\n    \"page\": \"Arrays\",\n    \"title\": \"Core.UndefInitializer\",\n    \"category\": \"type\",\n    \"text\": \"UndefInitializer\\n\\nSingleton type used in array initialization, indicating the array-constructor-caller would like an uninitialized array. See also undef, an alias for UndefInitializer().\\n\\nExamples\\n\\njulia> Array{Float64,1}(UndefInitializer(), 3)\\n3-element Array{Float64,1}:\\n 2.2752528595e-314\\n 2.202942107e-314\\n 2.275252907e-314\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Core.undef\",\n    \"page\": \"Arrays\",\n    \"title\": \"Core.undef\",\n    \"category\": \"constant\",\n    \"text\": \"undef\\n\\nAlias for UndefInitializer(), which constructs an instance of the singleton type UndefInitializer, used in array initialization to indicate the array-constructor-caller would like an uninitialized array.\\n\\nExamples\\n\\njulia> Array{Float64,1}(undef, 3)\\n3-element Array{Float64,1}:\\n 2.2752528595e-314\\n 2.202942107e-314\\n 2.275252907e-314\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.Vector\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.Vector\",\n    \"category\": \"type\",\n    \"text\": \"Vector{T} <: AbstractVector{T}\\n\\nOne-dimensional dense array with elements of type T, often used to represent a mathematical vector. Alias for Array{T,1}.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.Vector-Tuple{UndefInitializer,Any}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.Vector\",\n    \"category\": \"method\",\n    \"text\": \"Vector{T}(undef, n)\\n\\nConstruct an uninitialized Vector{T} of length n. See undef.\\n\\nExamples\\n\\njulia> Vector{Float64}(undef, 3)\\n3-element Array{Float64,1}:\\n 6.90966e-310\\n 6.90966e-310\\n 6.90966e-310\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.Vector-Tuple{Nothing,Any}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.Vector\",\n    \"category\": \"method\",\n    \"text\": \"Vector{T}(nothing, m)\\n\\nConstruct a Vector{T} of length m, initialized with nothing entries. Element type T must be able to hold these values, i.e. Nothing <: T.\\n\\nExamples\\n\\njulia> Vector{Union{Nothing, String}}(nothing, 2)\\n2-element Array{Union{Nothing, String},1}:\\n nothing\\n nothing\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.Vector-Tuple{Missing,Any}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.Vector\",\n    \"category\": \"method\",\n    \"text\": \"Vector{T}(missing, m)\\n\\nConstruct a Vector{T} of length m, initialized with missing entries. Element type T must be able to hold these values, i.e. Missing <: T.\\n\\nExamples\\n\\njulia> Vector{Union{Missing, String}}(missing, 2)\\n2-element Array{Union{Missing, String},1}:\\n missing\\n missing\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.Matrix\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.Matrix\",\n    \"category\": \"type\",\n    \"text\": \"Matrix{T} <: AbstractMatrix{T}\\n\\nTwo-dimensional dense array with elements of type T, often used to represent a mathematical matrix. Alias for Array{T,2}.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.Matrix-Tuple{UndefInitializer,Any,Any}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.Matrix\",\n    \"category\": \"method\",\n    \"text\": \"Matrix{T}(undef, m, n)\\n\\nConstruct an uninitialized Matrix{T} of size m\u00d7n. See undef.\\n\\nExamples\\n\\njulia> Matrix{Float64}(undef, 2, 3)\\n2\u00d73 Array{Float64,2}:\\n 6.93517e-310  6.93517e-310  6.93517e-310\\n 6.93517e-310  6.93517e-310  1.29396e-320\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.Matrix-Tuple{Nothing,Any,Any}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.Matrix\",\n    \"category\": \"method\",\n    \"text\": \"Matrix{T}(nothing, m, n)\\n\\nConstruct a Matrix{T} of size m\u00d7n, initialized with nothing entries. Element type T must be able to hold these values, i.e. Nothing <: T.\\n\\nExamples\\n\\njulia> Matrix{Union{Nothing, String}}(nothing, 2, 3)\\n2\u00d73 Array{Union{Nothing, String},2}:\\n nothing  nothing  nothing\\n nothing  nothing  nothing\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.Matrix-Tuple{Missing,Any,Any}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.Matrix\",\n    \"category\": \"method\",\n    \"text\": \"Matrix{T}(missing, m, n)\\n\\nConstruct a Matrix{T} of size m\u00d7n, initialized with missing entries. Element type T must be able to hold these values, i.e. Missing <: T.\\n\\nExamples\\n\\njulia> Matrix{Union{Missing, String}}(missing, 2, 3)\\n2\u00d73 Array{Union{Missing, String},2}:\\n missing  missing  missing\\n missing  missing  missing\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.VecOrMat\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.VecOrMat\",\n    \"category\": \"constant\",\n    \"text\": \"VecOrMat{T}\\n\\nUnion type of Vector{T} and Matrix{T}.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Core.DenseArray\",\n    \"page\": \"Arrays\",\n    \"title\": \"Core.DenseArray\",\n    \"category\": \"type\",\n    \"text\": \"DenseArray{T, N} <: AbstractArray{T,N}\\n\\nN-dimensional dense array with elements of type T. The elements of a dense array are stored contiguously in memory.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.DenseVector\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.DenseVector\",\n    \"category\": \"type\",\n    \"text\": \"DenseVector{T}\\n\\nOne-dimensional DenseArray with elements of type T. Alias for DenseArray{T,1}.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.DenseMatrix\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.DenseMatrix\",\n    \"category\": \"type\",\n    \"text\": \"DenseMatrix{T}\\n\\nTwo-dimensional DenseArray with elements of type T. Alias for DenseArray{T,2}.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.DenseVecOrMat\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.DenseVecOrMat\",\n    \"category\": \"constant\",\n    \"text\": \"DenseVecOrMat{T}\\n\\nUnion type of DenseVector{T} and DenseMatrix{T}.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.StridedArray\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.StridedArray\",\n    \"category\": \"constant\",\n    \"text\": \"StridedArray{T, N}\\n\\nAn N dimensional strided array with elements of type T. These arrays follow the strided array interface. If A is a StridedArray, then its elements are stored in memory with offsets, which may vary between dimensions but are constant within a dimension. For example, A could have stride 2 in dimension 1, and stride 3 in dimension 2. Incrementing A along dimension d jumps in memory by [strides(A, d)] slots. Strided arrays are particularly important and useful because they can sometimes be passed directly as pointers to foreign language libraries like BLAS.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.StridedVector\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.StridedVector\",\n    \"category\": \"constant\",\n    \"text\": \"StridedVector{T}\\n\\nOne dimensional StridedArray with elements of type T.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.StridedMatrix\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.StridedMatrix\",\n    \"category\": \"constant\",\n    \"text\": \"StridedMatrix{T}\\n\\nTwo dimensional StridedArray with elements of type T.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.StridedVecOrMat\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.StridedVecOrMat\",\n    \"category\": \"constant\",\n    \"text\": \"StridedVecOrMat{T}\\n\\nUnion type of StridedVector and StridedMatrix with elements of type T.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.getindex-Tuple{Type,Vararg{Any,N} where N}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.getindex\",\n    \"category\": \"method\",\n    \"text\": \"getindex(type[, elements...])\\n\\nConstruct a 1-d array of the specified type. This is usually called with the syntax Type[]. Element values can be specified using Type[a,b,c,...].\\n\\nExamples\\n\\njulia> Int8[1, 2, 3]\\n3-element Array{Int8,1}:\\n 1\\n 2\\n 3\\n\\njulia> getindex(Int8, 1, 2, 3)\\n3-element Array{Int8,1}:\\n 1\\n 2\\n 3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.zeros\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.zeros\",\n    \"category\": \"function\",\n    \"text\": \"zeros([T=Float64,] dims...)\\n\\nCreate an Array, with element type T, of all zeros with size specified by dims. See also fill, ones.\\n\\nExamples\\n\\njulia> zeros(1)\\n1-element Array{Float64,1}:\\n 0.0\\n\\njulia> zeros(Int8, 2, 3)\\n2\u00d73 Array{Int8,2}:\\n 0  0  0\\n 0  0  0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.ones\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.ones\",\n    \"category\": \"function\",\n    \"text\": \"ones([T=Float64,] dims...)\\n\\nCreate an Array, with element type T, of all ones with size specified by dims. See also: fill, zeros.\\n\\nExamples\\n\\njulia> ones(1,2)\\n1\u00d72 Array{Float64,2}:\\n 1.0  1.0\\n\\njulia> ones(ComplexF64, 2, 3)\\n2\u00d73 Array{Complex{Float64},2}:\\n 1.0+0.0im  1.0+0.0im  1.0+0.0im\\n 1.0+0.0im  1.0+0.0im  1.0+0.0im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.BitArray\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.BitArray\",\n    \"category\": \"type\",\n    \"text\": \"BitArray{N} <: DenseArray{Bool, N}\\n\\nSpace-efficient N-dimensional boolean array, which stores one bit per boolean value.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.BitArray-Tuple{UndefInitializer,Vararg{Integer,N} where N}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.BitArray\",\n    \"category\": \"method\",\n    \"text\": \"BitArray(undef, dims::Integer...)\\nBitArray{N}(undef, dims::NTuple{N,Int})\\n\\nConstruct an undef BitArray with the given dimensions. Behaves identically to the Array constructor. See undef.\\n\\nExamples\\n\\njulia> BitArray(undef, 2, 2)\\n2\u00d72 BitArray{2}:\\n false  false\\n false  true\\n\\njulia> BitArray(undef, (3, 1))\\n3\u00d71 BitArray{2}:\\n false\\n true\\n false\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.BitArray-Tuple{Any}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.BitArray\",\n    \"category\": \"method\",\n    \"text\": \"BitArray(itr)\\n\\nConstruct a BitArray generated by the given iterable object. The shape is inferred from the itr object.\\n\\nExamples\\n\\njulia> BitArray([1 0; 0 1])\\n2\u00d72 BitArray{2}:\\n  true  false\\n false   true\\n\\njulia> BitArray(x+y == 3 for x = 1:2, y = 1:3)\\n2\u00d73 BitArray{2}:\\n false   true  false\\n  true  false  false\\n\\njulia> BitArray(x+y == 3 for x = 1:2 for y = 1:3)\\n6-element BitArray{1}:\\n false\\n  true\\n false\\n  true\\n false\\n false\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.trues\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.trues\",\n    \"category\": \"function\",\n    \"text\": \"trues(dims)\\n\\nCreate a BitArray with all values set to true.\\n\\nExamples\\n\\njulia> trues(2,3)\\n2\u00d73 BitArray{2}:\\n true  true  true\\n true  true  true\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.falses\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.falses\",\n    \"category\": \"function\",\n    \"text\": \"falses(dims)\\n\\nCreate a BitArray with all values set to false.\\n\\nExamples\\n\\njulia> falses(2,3)\\n2\u00d73 BitArray{2}:\\n false  false  false\\n false  false  false\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.fill\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.fill\",\n    \"category\": \"function\",\n    \"text\": \"fill(x, dims)\\n\\nCreate an array filled with the value x. For example, fill(1.0, (5,5)) returns a 5\u00d75 array of floats, with each element initialized to 1.0.\\n\\nExamples\\n\\njulia> fill(1.0, (5,5))\\n5\u00d75 Array{Float64,2}:\\n 1.0  1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0  1.0\\n\\nIf x is an object reference, all elements will refer to the same object. fill(Foo(), dims) will return an array filled with the result of evaluating Foo() once.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.fill!\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.fill!\",\n    \"category\": \"function\",\n    \"text\": \"fill!(A, x)\\n\\nFill array A with the value x. If x is an object reference, all elements will refer to the same object. fill!(A, Foo()) will return A filled with the result of evaluating Foo() once.\\n\\nExamples\\n\\njulia> A = zeros(2,3)\\n2\u00d73 Array{Float64,2}:\\n 0.0  0.0  0.0\\n 0.0  0.0  0.0\\n\\njulia> fill!(A, 2.)\\n2\u00d73 Array{Float64,2}:\\n 2.0  2.0  2.0\\n 2.0  2.0  2.0\\n\\njulia> a = [1, 1, 1]; A = fill!(Vector{Vector{Int}}(undef, 3), a); a[1] = 2; A\\n3-element Array{Array{Int64,1},1}:\\n [2, 1, 1]\\n [2, 1, 1]\\n [2, 1, 1]\\n\\njulia> x = 0; f() = (global x += 1; x); fill!(Vector{Int}(undef, 3), f())\\n3-element Array{Int64,1}:\\n 1\\n 1\\n 1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.similar\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.similar\",\n    \"category\": \"function\",\n    \"text\": \"similar(array, [element_type=eltype(array)], [dims=size(array)])\\n\\nCreate an uninitialized mutable array with the given element type and size, based upon the given source array. The second and third arguments are both optional, defaulting to the given array\\'s eltype and size. The dimensions may be specified either as a single tuple argument or as a series of integer arguments.\\n\\nCustom AbstractArray subtypes may choose which specific array type is best-suited to return for the given element type and dimensionality. If they do not specialize this method, the default is an Array{element_type}(undef, dims...).\\n\\nFor example, similar(1:10, 1, 4) returns an uninitialized Array{Int,2} since ranges are neither mutable nor support 2 dimensions:\\n\\njulia> similar(1:10, 1, 4)\\n1\u00d74 Array{Int64,2}:\\n 4419743872  4374413872  4419743888  0\\n\\nConversely, similar(trues(10,10), 2) returns an uninitialized BitVector with two elements since BitArrays are both mutable and can support 1-dimensional arrays:\\n\\njulia> similar(trues(10,10), 2)\\n2-element BitArray{1}:\\n false\\n false\\n\\nSince BitArrays can only store elements of type Bool, however, if you request a different element type it will create a regular Array instead:\\n\\njulia> similar(falses(10), Float64, 2, 4)\\n2\u00d74 Array{Float64,2}:\\n 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314\\n 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314\\n\\n\\n\\n\\n\\nsimilar(storagetype, axes)\\n\\nCreate an uninitialized mutable array analogous to that specified by storagetype, but with axes specified by the last argument. storagetype might be a type or a function.\\n\\nExamples:\\n\\nsimilar(Array{Int}, axes(A))\\n\\ncreates an array that \\\"acts like\\\" an Array{Int} (and might indeed be backed by one), but which is indexed identically to A. If A has conventional indexing, this will be identical to Array{Int}(undef, size(A)), but if A has unconventional indexing then the indices of the result will match A.\\n\\nsimilar(BitArray, (axes(A, 2),))\\n\\nwould create a 1-dimensional logical array whose indices match those of the columns of A.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Constructors-and-Types-1\",\n    \"page\": \"Arrays\",\n    \"title\": \"Constructors and Types\",\n    \"category\": \"section\",\n    \"text\": \"Core.AbstractArray\\nBase.AbstractVector\\nBase.AbstractMatrix\\nBase.AbstractVecOrMat\\nCore.Array\\nCore.Array(::UndefInitializer, ::Any)\\nCore.Array(::Nothing, ::Any)\\nCore.Array(::Missing, ::Any)\\nCore.UndefInitializer\\nCore.undef\\nBase.Vector\\nBase.Vector(::UndefInitializer, ::Any)\\nBase.Vector(::Nothing, ::Any)\\nBase.Vector(::Missing, ::Any)\\nBase.Matrix\\nBase.Matrix(::UndefInitializer, ::Any, ::Any)\\nBase.Matrix(::Nothing, ::Any, ::Any)\\nBase.Matrix(::Missing, ::Any, ::Any)\\nBase.VecOrMat\\nCore.DenseArray\\nBase.DenseVector\\nBase.DenseMatrix\\nBase.DenseVecOrMat\\nBase.StridedArray\\nBase.StridedVector\\nBase.StridedMatrix\\nBase.StridedVecOrMat\\nBase.getindex(::Type, ::Any...)\\nBase.zeros\\nBase.ones\\nBase.BitArray\\nBase.BitArray(::UndefInitializer, ::Integer...)\\nBase.BitArray(::Any)\\nBase.trues\\nBase.falses\\nBase.fill\\nBase.fill!\\nBase.similar\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.ndims\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.ndims\",\n    \"category\": \"function\",\n    \"text\": \"ndims(A::AbstractArray) -> Integer\\n\\nReturn the number of dimensions of A.\\n\\nExamples\\n\\njulia> A = fill(1, (3,4,5));\\n\\njulia> ndims(A)\\n3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.size\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.size\",\n    \"category\": \"function\",\n    \"text\": \"size(A::AbstractArray, [dim])\\n\\nReturn a tuple containing the dimensions of A. Optionally you can specify a dimension to just get the length of that dimension.\\n\\nNote that size may not be defined for arrays with non-standard indices, in which case axes may be useful. See the manual chapter on arrays with custom indices.\\n\\nExamples\\n\\njulia> A = fill(1, (2,3,4));\\n\\njulia> size(A)\\n(2, 3, 4)\\n\\njulia> size(A, 2)\\n3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.axes-Tuple{Any}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.axes\",\n    \"category\": \"method\",\n    \"text\": \"axes(A)\\n\\nReturn the tuple of valid indices for array A.\\n\\nExamples\\n\\njulia> A = fill(1, (5,6,7));\\n\\njulia> axes(A)\\n(Base.OneTo(5), Base.OneTo(6), Base.OneTo(7))\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.axes-Tuple{AbstractArray,Any}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.axes\",\n    \"category\": \"method\",\n    \"text\": \"axes(A, d)\\n\\nReturn the valid range of indices for array A along dimension d.\\n\\nSee also size, and the manual chapter on arrays with custom indices.\\n\\nExamples\\n\\njulia> A = fill(1, (5,6,7));\\n\\njulia> axes(A, 2)\\nBase.OneTo(6)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.length-Tuple{AbstractArray}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.length\",\n    \"category\": \"method\",\n    \"text\": \"length(A::AbstractArray)\\n\\nReturn the number of elements in the array, defaults to prod(size(A)).\\n\\nExamples\\n\\njulia> length([1, 2, 3, 4])\\n4\\n\\njulia> length([1 2; 3 4])\\n4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.eachindex\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.eachindex\",\n    \"category\": \"function\",\n    \"text\": \"eachindex(A...)\\n\\nCreate an iterable object for visiting each index of an AbstractArray A in an efficient manner. For array types that have opted into fast linear indexing (like Array), this is simply the range 1:length(A). For other array types, return a specialized Cartesian range to efficiently index into the array with indices specified for every dimension. For other iterables, including strings and dictionaries, return an iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).\\n\\nIf you supply more than one AbstractArray argument, eachindex will create an iterable object that is fast for all arguments (a UnitRange if all inputs have fast linear indexing, a CartesianIndices otherwise). If the arrays have different sizes and/or dimensionalities, eachindex will return an iterable that spans the largest range along each dimension.\\n\\nExamples\\n\\njulia> A = [1 2; 3 4];\\n\\njulia> for i in eachindex(A) # linear indexing\\n           println(i)\\n       end\\n1\\n2\\n3\\n4\\n\\njulia> for i in eachindex(view(A, 1:2, 1:1)) # Cartesian indexing\\n           println(i)\\n       end\\nCartesianIndex(1, 1)\\nCartesianIndex(2, 1)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.IndexStyle\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.IndexStyle\",\n    \"category\": \"type\",\n    \"text\": \"IndexStyle(A)\\nIndexStyle(typeof(A))\\n\\nIndexStyle specifies the \\\"native indexing style\\\" for array A. When you define a new AbstractArray type, you can choose to implement either linear indexing or cartesian indexing.  If you decide to implement linear indexing, then you must set this trait for your array type:\\n\\nBase.IndexStyle(::Type{<:MyArray}) = IndexLinear()\\n\\nThe default is IndexCartesian().\\n\\nJulia\\'s internal indexing machinery will automatically (and invisibly) convert all indexing operations into the preferred style. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.\\n\\nIf you define both styles of indexing for your AbstractArray, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, eachindex creates an iterator whose type depends on the setting of this trait.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.conj!\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.conj!\",\n    \"category\": \"function\",\n    \"text\": \"conj!(A)\\n\\nTransform an array to its complex conjugate in-place.\\n\\nSee also conj.\\n\\nExamples\\n\\njulia> A = [1+im 2-im; 2+2im 3+im]\\n2\u00d72 Array{Complex{Int64},2}:\\n 1+1im  2-1im\\n 2+2im  3+1im\\n\\njulia> conj!(A);\\n\\njulia> A\\n2\u00d72 Array{Complex{Int64},2}:\\n 1-1im  2+1im\\n 2-2im  3-1im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.stride\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.stride\",\n    \"category\": \"function\",\n    \"text\": \"stride(A, k::Integer)\\n\\nReturn the distance in memory (in number of elements) between adjacent elements in dimension k.\\n\\nExamples\\n\\njulia> A = fill(1, (3,4,5));\\n\\njulia> stride(A,2)\\n3\\n\\njulia> stride(A,3)\\n12\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.strides\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.strides\",\n    \"category\": \"function\",\n    \"text\": \"strides(A)\\n\\nReturn a tuple of the memory strides in each dimension.\\n\\nExamples\\n\\njulia> A = fill(1, (3,4,5));\\n\\njulia> strides(A)\\n(1, 3, 12)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Basic-functions-1\",\n    \"page\": \"Arrays\",\n    \"title\": \"Basic functions\",\n    \"category\": \"section\",\n    \"text\": \"Base.ndims\\nBase.size\\nBase.axes(::Any)\\nBase.axes(::AbstractArray, ::Any)\\nBase.length(::AbstractArray)\\nBase.eachindex\\nBase.IndexStyle\\nBase.conj!\\nBase.stride\\nBase.strides\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.Broadcast.broadcast\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.Broadcast.broadcast\",\n    \"category\": \"function\",\n    \"text\": \"broadcast(f, As...)\\n\\nBroadcast the function f over the arrays, tuples, collections, Refs and/or scalars As.\\n\\nBroadcasting applies the function f over the elements of the container arguments and the scalars themselves in As. Singleton and missing dimensions are expanded to match the extents of the other arguments by virtually repeating the value. By default, only a limited number of types are considered scalars, including Numbers, Strings, Symbols, Types, Functions and some common singletons like missing and nothing. All other arguments are iterated over or indexed into elementwise.\\n\\nThe resulting container type is established by the following rules:\\n\\nIf all the arguments are scalars or zero-dimensional arrays, it returns an unwrapped scalar.\\nIf at least one argument is a tuple and all others are scalars or zero-dimensional arrays, it returns a tuple.\\nAll other combinations of arguments default to returning an Array, but custom container types can define their own implementation and promotion-like rules to customize the result when they appear as arguments.\\n\\nA special syntax exists for broadcasting: f.(args...) is equivalent to broadcast(f, args...), and nested f.(g.(args...)) calls are fused into a single broadcast loop.\\n\\nExamples\\n\\njulia> A = [1, 2, 3, 4, 5]\\n5-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n 4\\n 5\\n\\njulia> B = [1 2; 3 4; 5 6; 7 8; 9 10]\\n5\u00d72 Array{Int64,2}:\\n 1   2\\n 3   4\\n 5   6\\n 7   8\\n 9  10\\n\\njulia> broadcast(+, A, B)\\n5\u00d72 Array{Int64,2}:\\n  2   3\\n  5   6\\n  8   9\\n 11  12\\n 14  15\\n\\njulia> parse.(Int, [\\\"1\\\", \\\"2\\\"])\\n2-element Array{Int64,1}:\\n 1\\n 2\\n\\njulia> abs.((1, -2))\\n(1, 2)\\n\\njulia> broadcast(+, 1.0, (0, -2.0))\\n(1.0, -1.0)\\n\\njulia> (+).([[0,2], [1,3]], Ref{Vector{Int}}([1,-1]))\\n2-element Array{Array{Int64,1},1}:\\n [1, 1]\\n [2, 2]\\n\\njulia> string.((\\\"one\\\",\\\"two\\\",\\\"three\\\",\\\"four\\\"), \\\": \\\", 1:4)\\n4-element Array{String,1}:\\n \\\"one: 1\\\"\\n \\\"two: 2\\\"\\n \\\"three: 3\\\"\\n \\\"four: 4\\\"\\n\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.Broadcast.broadcast!\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.Broadcast.broadcast!\",\n    \"category\": \"function\",\n    \"text\": \"broadcast!(f, dest, As...)\\n\\nLike broadcast, but store the result of broadcast(f, As...) in the dest array. Note that dest is only used to store the result, and does not supply arguments to f unless it is also listed in the As, as in broadcast!(f, A, A, B) to perform A[:] = broadcast(f, A, B).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.Broadcast.@__dot__\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.Broadcast.@__dot__\",\n    \"category\": \"macro\",\n    \"text\": \"@. expr\\n\\nConvert every function call or operator in expr into a \\\"dot call\\\" (e.g. convert f(x) to f.(x)), and convert every assignment in expr to a \\\"dot assignment\\\" (e.g. convert += to .+=).\\n\\nIf you want to avoid adding dots for selected function calls in expr, splice those function calls in with $.  For example, @. sqrt(abs($sort(x))) is equivalent to sqrt.(abs.(sort(x))) (no dot for sort).\\n\\n(@. is equivalent to a call to @__dot__.)\\n\\nExamples\\n\\njulia> x = 1.0:3.0; y = similar(x);\\n\\njulia> @. y = x + 3 * sin(x)\\n3-element Array{Float64,1}:\\n 3.5244129544236893\\n 4.727892280477045\\n 3.4233600241796016\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.Broadcast.BroadcastStyle\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.Broadcast.BroadcastStyle\",\n    \"category\": \"type\",\n    \"text\": \"BroadcastStyle is an abstract type and trait-function used to determine behavior of objects under broadcasting. BroadcastStyle(typeof(x)) returns the style associated with x. To customize the broadcasting behavior of a type, one can declare a style by defining a type/method pair\\n\\nstruct MyContainerStyle <: BroadcastStyle end\\nBase.BroadcastStyle(::Type{<:MyContainer}) = MyContainerStyle()\\n\\nOne then writes method(s) (at least similar) operating on Broadcasted{MyContainerStyle}. There are also several pre-defined subtypes of BroadcastStyle that you may be able to leverage; see the Interfaces chapter for more information.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.Broadcast.broadcast_axes\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.Broadcast.broadcast_axes\",\n    \"category\": \"function\",\n    \"text\": \"Base.broadcast_axes(A)\\n\\nCompute the axes for A.\\n\\nThis should only be specialized for objects that do not define axes but want to participate in broadcasting.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.Broadcast.AbstractArrayStyle\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.Broadcast.AbstractArrayStyle\",\n    \"category\": \"type\",\n    \"text\": \"Broadcast.AbstractArrayStyle{N} <: BroadcastStyle is the abstract supertype for any style associated with an AbstractArray type. The N parameter is the dimensionality, which can be handy for AbstractArray types that only support specific dimensionalities:\\n\\nstruct SparseMatrixStyle <: Broadcast.AbstractArrayStyle{2} end\\nBase.BroadcastStyle(::Type{<:SparseMatrixCSC}) = SparseMatrixStyle()\\n\\nFor AbstractArray types that support arbitrary dimensionality, N can be set to Any:\\n\\nstruct MyArrayStyle <: Broadcast.AbstractArrayStyle{Any} end\\nBase.BroadcastStyle(::Type{<:MyArray}) = MyArrayStyle()\\n\\nIn cases where you want to be able to mix multiple AbstractArrayStyles and keep track of dimensionality, your style needs to support a Val constructor:\\n\\nstruct MyArrayStyleDim{N} <: Broadcast.AbstractArrayStyle{N} end\\n(::Type{<:MyArrayStyleDim})(::Val{N}) where N = MyArrayStyleDim{N}()\\n\\nNote that if two or more AbstractArrayStyle subtypes conflict, broadcasting machinery will fall back to producing Arrays. If this is undesirable, you may need to define binary BroadcastStyle rules to control the output type.\\n\\nSee also Broadcast.DefaultArrayStyle.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.Broadcast.ArrayStyle\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.Broadcast.ArrayStyle\",\n    \"category\": \"type\",\n    \"text\": \"Broadcast.ArrayStyle{MyArrayType}() is a BroadcastStyle indicating that an object behaves as an array for broadcasting. It presents a simple way to construct Broadcast.AbstractArrayStyles for specific AbstractArray container types. Broadcast styles created this way lose track of dimensionality; if keeping track is important for your type, you should create your own custom Broadcast.AbstractArrayStyle.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.Broadcast.DefaultArrayStyle\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.Broadcast.DefaultArrayStyle\",\n    \"category\": \"type\",\n    \"text\": \"Broadcast.DefaultArrayStyle{N}() is a BroadcastStyle indicating that an object behaves as an N-dimensional array for broadcasting. Specifically, DefaultArrayStyle is used for any AbstractArray type that hasn\\'t defined a specialized style, and in the absence of overrides from other broadcast arguments the resulting output type is Array. When there are multiple inputs to broadcast, DefaultArrayStyle \\\"loses\\\" to any other Broadcast.ArrayStyle.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.Broadcast.broadcastable\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.Broadcast.broadcastable\",\n    \"category\": \"function\",\n    \"text\": \"Broadcast.broadcastable(x)\\n\\nReturn either x or an object like x such that it supports axes, indexing, and its type supports ndims.\\n\\nIf x supports iteration, the returned value should have the same axes and indexing behaviors as collect(x).\\n\\nIf x is not an AbstractArray but it supports axes, indexing, and its type supports ndims, then broadcastable(::typeof(x)) may be implemented to just return itself. Further, if x defines its own BroadcastStyle, then it must define its broadcastable method to return itself for the custom style to have any effect.\\n\\nExamples\\n\\njulia> Broadcast.broadcastable([1,2,3]) # like `identity` since arrays already support axes and indexing\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n\\njulia> Broadcast.broadcastable(Int) # Types don\\'t support axes, indexing, or iteration but are commonly used as scalars\\nBase.RefValue{Type{Int64}}(Int64)\\n\\njulia> Broadcast.broadcastable(\\\"hello\\\") # Strings break convention of matching iteration and act like a scalar instead\\nBase.RefValue{String}(\\\"hello\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Broadcast-and-vectorization-1\",\n    \"page\": \"Arrays\",\n    \"title\": \"Broadcast and vectorization\",\n    \"category\": \"section\",\n    \"text\": \"See also the dot syntax for vectorizing functions; for example, f.(args...) implicitly calls broadcast(f, args...). Rather than relying on \\\"vectorized\\\" methods of functions like sin to operate on arrays, you should use sin.(a) to vectorize via broadcast.Base.broadcast\\nBase.Broadcast.broadcast!\\nBase.@__dot__For specializing broadcast on custom types, seeBase.BroadcastStyle\\nBase.broadcast_axes\\nBase.Broadcast.AbstractArrayStyle\\nBase.Broadcast.ArrayStyle\\nBase.Broadcast.DefaultArrayStyle\\nBase.Broadcast.broadcastable\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.getindex-Tuple{AbstractArray,Vararg{Any,N} where N}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.getindex\",\n    \"category\": \"method\",\n    \"text\": \"getindex(A, inds...)\\n\\nReturn a subset of array A as specified by inds, where each ind may be an Int, an AbstractRange, or a Vector. See the manual section on array indexing for details.\\n\\nExamples\\n\\njulia> A = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> getindex(A, 1)\\n1\\n\\njulia> getindex(A, [2, 1])\\n2-element Array{Int64,1}:\\n 3\\n 1\\n\\njulia> getindex(A, 2:4)\\n3-element Array{Int64,1}:\\n 3\\n 2\\n 4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.setindex!-Tuple{AbstractArray,Any,Vararg{Any,N} where N}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.setindex!\",\n    \"category\": \"method\",\n    \"text\": \"setindex!(A, X, inds...)\\nA[inds...] = X\\n\\nStore values from array X within some subset of A as specified by inds. The syntax A[inds...] = X is equivalent to setindex!(A, X, inds...).\\n\\nExamples\\n\\njulia> A = zeros(2,2);\\n\\njulia> setindex!(A, [10, 20], [1, 2]);\\n\\njulia> A[[3, 4]] = [30, 40];\\n\\njulia> A\\n2\u00d72 Array{Float64,2}:\\n 10.0  30.0\\n 20.0  40.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.copyto!-Tuple{AbstractArray,CartesianIndices,AbstractArray,CartesianIndices}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.copyto!\",\n    \"category\": \"method\",\n    \"text\": \"copyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices) -> dest\\n\\nCopy the block of src in the range of Rsrc to the block of dest in the range of Rdest. The sizes of the two regions must match.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.isassigned\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.isassigned\",\n    \"category\": \"function\",\n    \"text\": \"isassigned(array, i) -> Bool\\n\\nTest whether the given array has a value associated with index i. Return false if the index is out of bounds, or has an undefined reference.\\n\\nExamples\\n\\njulia> isassigned(rand(3, 3), 5)\\ntrue\\n\\njulia> isassigned(rand(3, 3), 3 * 3 + 1)\\nfalse\\n\\njulia> mutable struct Foo end\\n\\njulia> v = similar(rand(3), Foo)\\n3-element Array{Foo,1}:\\n #undef\\n #undef\\n #undef\\n\\njulia> isassigned(v, 1)\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.Colon\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.Colon\",\n    \"category\": \"type\",\n    \"text\": \"Colon()\\n\\nColons (:) are used to signify indexing entire objects or dimensions at once.\\n\\nVery few operations are defined on Colons directly; instead they are converted by to_indices to an internal vector type (Base.Slice) to represent the collection of indices they span before being used.\\n\\nThe singleton instance of Colon is also a function used to construct ranges; see :.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.IteratorsMD.CartesianIndex\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.IteratorsMD.CartesianIndex\",\n    \"category\": \"type\",\n    \"text\": \"CartesianIndex(i, j, k...)   -> I\\nCartesianIndex((i, j, k...)) -> I\\n\\nCreate a multidimensional index I, which can be used for indexing a multidimensional array A.  In particular, A[I] is equivalent to A[i,j,k...].  One can freely mix integer and CartesianIndex indices; for example, A[Ipre, i, Ipost] (where Ipre and Ipost are CartesianIndex indices and i is an Int) can be a useful expression when writing algorithms that work along a single dimension of an array of arbitrary dimensionality.\\n\\nA CartesianIndex is sometimes produced by eachindex, and always when iterating with an explicit CartesianIndices.\\n\\nExamples\\n\\njulia> A = reshape(Vector(1:16), (2, 2, 2, 2))\\n2\u00d72\u00d72\u00d72 Array{Int64,4}:\\n[:, :, 1, 1] =\\n 1  3\\n 2  4\\n\\n[:, :, 2, 1] =\\n 5  7\\n 6  8\\n\\n[:, :, 1, 2] =\\n  9  11\\n 10  12\\n\\n[:, :, 2, 2] =\\n 13  15\\n 14  16\\n\\njulia> A[CartesianIndex((1, 1, 1, 1))]\\n1\\n\\njulia> A[CartesianIndex((1, 1, 1, 2))]\\n9\\n\\njulia> A[CartesianIndex((1, 1, 2, 1))]\\n5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.IteratorsMD.CartesianIndices\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.IteratorsMD.CartesianIndices\",\n    \"category\": \"type\",\n    \"text\": \"CartesianIndices(sz::Dims) -> R\\nCartesianIndices(istart:istop, jstart:jstop, ...) -> R\\n\\nDefine a region R spanning a multidimensional rectangular range of integer indices. These are most commonly encountered in the context of iteration, where for I in R ... end will return CartesianIndex indices I equivalent to the nested loops\\n\\nfor j = jstart:jstop\\n    for i = istart:istop\\n        ...\\n    end\\nend\\n\\nConsequently these can be useful for writing algorithms that work in arbitrary dimensions.\\n\\nCartesianIndices(A::AbstractArray) -> R\\n\\nAs a convenience, constructing a CartesianIndices from an array makes a range of its indices.\\n\\nExamples\\n\\njulia> foreach(println, CartesianIndices((2, 2, 2)))\\nCartesianIndex(1, 1, 1)\\nCartesianIndex(2, 1, 1)\\nCartesianIndex(1, 2, 1)\\nCartesianIndex(2, 2, 1)\\nCartesianIndex(1, 1, 2)\\nCartesianIndex(2, 1, 2)\\nCartesianIndex(1, 2, 2)\\nCartesianIndex(2, 2, 2)\\n\\njulia> CartesianIndices(fill(1, (2,3)))\\n2\u00d73 CartesianIndices{2,Tuple{Base.OneTo{Int64},Base.OneTo{Int64}}}:\\n CartesianIndex(1, 1)  CartesianIndex(1, 2)  CartesianIndex(1, 3)\\n CartesianIndex(2, 1)  CartesianIndex(2, 2)  CartesianIndex(2, 3)\\n\\nConversion between linear and cartesian indices\\n\\nLinear index to cartesian index conversion exploits the fact that a CartesianIndices is an AbstractArray and can be indexed linearly:\\n\\njulia> cartesian = CartesianIndices((1:3, 1:2))\\n3\u00d72 CartesianIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:\\n CartesianIndex(1, 1)  CartesianIndex(1, 2)\\n CartesianIndex(2, 1)  CartesianIndex(2, 2)\\n CartesianIndex(3, 1)  CartesianIndex(3, 2)\\n\\njulia> cartesian[4]\\nCartesianIndex(1, 2)\\n\\nFor cartesian to linear index conversion, see LinearIndices.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.Dims\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.Dims\",\n    \"category\": \"type\",\n    \"text\": \"Dims{N}\\n\\nAn NTuple of N Ints used to represent the dimensions of an AbstractArray.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.LinearIndices\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.LinearIndices\",\n    \"category\": \"type\",\n    \"text\": \"LinearIndices(A::AbstractArray)\\n\\nReturn a LinearIndices array with the same shape and axes as A, holding the linear index of each entry in A. Indexing this array with cartesian indices allows mapping them to linear indices.\\n\\nFor arrays with conventional indexing (indices start at 1), or any multidimensional array, linear indices range from 1 to length(A). However, for AbstractVectors linear indices are axes(A, 1), and therefore do not start at 1 for vectors with unconventional indexing.\\n\\nCalling this function is the \\\"safe\\\" way to write algorithms that exploit linear indexing.\\n\\nExamples\\n\\njulia> A = fill(1, (5,6,7));\\n\\njulia> b = LinearIndices(A);\\n\\njulia> extrema(b)\\n(1, 210)\\n\\nLinearIndices(inds::CartesianIndices) -> R\\nLinearIndices(sz::Dims) -> R\\nLinearIndices(istart:istop, jstart:jstop, ...) -> R\\n\\nReturn a LinearIndices array with the specified shape or axes.\\n\\nExample\\n\\nThe main purpose of this constructor is intuitive conversion from cartesian to linear indexing:\\n\\njulia> linear = LinearIndices((1:3, 1:2))\\n3\u00d72 LinearIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:\\n 1  4\\n 2  5\\n 3  6\\n\\njulia> linear[1,2]\\n4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.to_indices\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.to_indices\",\n    \"category\": \"function\",\n    \"text\": \"to_indices(A, I::Tuple)\\n\\nConvert the tuple I to a tuple of indices for use in indexing into array A.\\n\\nThe returned tuple must only contain either Ints or AbstractArrays of scalar indices that are supported by array A. It will error upon encountering a novel index type that it does not know how to process.\\n\\nFor simple index types, it defers to the unexported Base.to_index(A, i) to process each index i. While this internal function is not intended to be called directly, Base.to_index may be extended by custom array or index types to provide custom indexing behaviors.\\n\\nMore complicated index types may require more context about the dimension into which they index. To support those cases, to_indices(A, I) calls to_indices(A, axes(A), I), which then recursively walks through both the given tuple of indices and the dimensional indices of A in tandem. As such, not all index types are guaranteed to propagate to Base.to_index.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.checkbounds\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.checkbounds\",\n    \"category\": \"function\",\n    \"text\": \"checkbounds(Bool, A, I...)\\n\\nReturn true if the specified indices I are in bounds for the given array A. Subtypes of AbstractArray should specialize this method if they need to provide custom bounds checking behaviors; however, in many cases one can rely on A\\'s indices and checkindex.\\n\\nSee also checkindex.\\n\\nExamples\\n\\njulia> A = rand(3, 3);\\n\\njulia> checkbounds(Bool, A, 2)\\ntrue\\n\\njulia> checkbounds(Bool, A, 3, 4)\\nfalse\\n\\njulia> checkbounds(Bool, A, 1:3)\\ntrue\\n\\njulia> checkbounds(Bool, A, 1:3, 2:4)\\nfalse\\n\\n\\n\\n\\n\\ncheckbounds(A, I...)\\n\\nThrow an error if the specified indices I are not in bounds for the given array A.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.checkindex\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.checkindex\",\n    \"category\": \"function\",\n    \"text\": \"checkindex(Bool, inds::AbstractUnitRange, index)\\n\\nReturn true if the given index is within the bounds of inds. Custom types that would like to behave as indices for all arrays can extend this method in order to provide a specialized bounds checking implementation.\\n\\nExamples\\n\\njulia> checkindex(Bool, 1:20, 8)\\ntrue\\n\\njulia> checkindex(Bool, 1:20, 21)\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Indexing-and-assignment-1\",\n    \"page\": \"Arrays\",\n    \"title\": \"Indexing and assignment\",\n    \"category\": \"section\",\n    \"text\": \"Base.getindex(::AbstractArray, ::Any...)\\nBase.setindex!(::AbstractArray, ::Any, ::Any...)\\nBase.copyto!(::AbstractArray, ::CartesianIndices, ::AbstractArray, ::CartesianIndices)\\nBase.isassigned\\nBase.Colon\\nBase.CartesianIndex\\nBase.CartesianIndices\\nBase.Dims\\nBase.LinearIndices\\nBase.to_indices\\nBase.checkbounds\\nBase.checkindex\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.view\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.view\",\n    \"category\": \"function\",\n    \"text\": \"view(A, inds...)\\n\\nLike getindex, but returns a view into the parent array A with the given indices instead of making a copy.  Calling getindex or setindex! on the returned SubArray computes the indices to the parent array on the fly without checking bounds.\\n\\nExamples\\n\\njulia> A = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> b = view(A, :, 1)\\n2-element view(::Array{Int64,2}, :, 1) with eltype Int64:\\n 1\\n 3\\n\\njulia> fill!(b, 0)\\n2-element view(::Array{Int64,2}, :, 1) with eltype Int64:\\n 0\\n 0\\n\\njulia> A # Note A has changed even though we modified b\\n2\u00d72 Array{Int64,2}:\\n 0  2\\n 0  4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.@view\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.@view\",\n    \"category\": \"macro\",\n    \"text\": \"@view A[inds...]\\n\\nCreates a SubArray from an indexing expression. This can only be applied directly to a reference expression (e.g. @view A[1,2:end]), and should not be used as the target of an assignment (e.g. @view(A[1,2:end]) = ...).  See also @views to switch an entire block of code to use views for slicing.\\n\\nExamples\\n\\njulia> A = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> b = @view A[:, 1]\\n2-element view(::Array{Int64,2}, :, 1) with eltype Int64:\\n 1\\n 3\\n\\njulia> fill!(b, 0)\\n2-element view(::Array{Int64,2}, :, 1) with eltype Int64:\\n 0\\n 0\\n\\njulia> A\\n2\u00d72 Array{Int64,2}:\\n 0  2\\n 0  4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.@views\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.@views\",\n    \"category\": \"macro\",\n    \"text\": \"@views expression\\n\\nConvert every array-slicing operation in the given expression (which may be a begin/end block, loop, function, etc.) to return a view. Scalar indices, non-array types, and explicit getindex calls (as opposed to array[...]) are unaffected.\\n\\nnote: Note\\nThe @views macro only affects array[...] expressions that appear explicitly in the given expression, not array slicing that occurs in functions called by that code.\\n\\nExamples\\n\\njulia> A = zeros(3, 3);\\n\\njulia> @views for row in 1:3\\n           b = A[row, :]\\n           b[:] .= row\\n       end\\n\\njulia> A\\n3\u00d73 Array{Float64,2}:\\n 1.0  1.0  1.0\\n 2.0  2.0  2.0\\n 3.0  3.0  3.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.parent\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.parent\",\n    \"category\": \"function\",\n    \"text\": \"parent(A)\\n\\nReturns the \\\"parent array\\\" of an array view type (e.g., SubArray), or the array itself if it is not a view.\\n\\nExamples\\n\\njulia> A = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> V = view(A, 1:2, :)\\n2\u00d72 view(::Array{Int64,2}, 1:2, :) with eltype Int64:\\n 1  2\\n 3  4\\n\\njulia> parent(V)\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.parentindices\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.parentindices\",\n    \"category\": \"function\",\n    \"text\": \"parentindices(A)\\n\\nFrom an array view A, returns the corresponding indices in the parent.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.selectdim\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.selectdim\",\n    \"category\": \"function\",\n    \"text\": \"selectdim(A, d::Integer, i)\\n\\nReturn a view of all the data of A where the index for dimension d equals i.\\n\\nEquivalent to view(A,:,:,...,i,:,:,...) where i is in position d.\\n\\nExamples\\n\\njulia> A = [1 2 3 4; 5 6 7 8]\\n2\u00d74 Array{Int64,2}:\\n 1  2  3  4\\n 5  6  7  8\\n\\njulia> selectdim(A, 2, 3)\\n2-element view(::Array{Int64,2}, :, 3) with eltype Int64:\\n 3\\n 7\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.reinterpret\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.reinterpret\",\n    \"category\": \"function\",\n    \"text\": \"reinterpret(type, A)\\n\\nChange the type-interpretation of a block of memory. For arrays, this constructs a view of the array with the same binary data as the given array, but with the specified element type. For example, reinterpret(Float32, UInt32(7)) interprets the 4 bytes corresponding to UInt32(7) as a Float32.\\n\\nExamples\\n\\njulia> reinterpret(Float32, UInt32(7))\\n1.0f-44\\n\\njulia> reinterpret(Float32, UInt32[1 2 3 4 5])\\n1\u00d75 reinterpret(Float32, ::Array{UInt32,2}):\\n 1.4013e-45  2.8026e-45  4.2039e-45  5.60519e-45  7.00649e-45\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.reshape\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.reshape\",\n    \"category\": \"function\",\n    \"text\": \"reshape(A, dims...) -> AbstractArray\\nreshape(A, dims) -> AbstractArray\\n\\nReturn an array with the same data as A, but with different dimension sizes or number of dimensions. The two arrays share the same underlying data, so that the result is mutable if and only if A is mutable, and setting elements of one alters the values of the other.\\n\\nThe new dimensions may be specified either as a list of arguments or as a shape tuple. At most one dimension may be specified with a :, in which case its length is computed such that its product with all the specified dimensions is equal to the length of the original array A. The total number of elements must not change.\\n\\nExamples\\n\\njulia> A = Vector(1:16)\\n16-element Array{Int64,1}:\\n  1\\n  2\\n  3\\n  4\\n  5\\n  6\\n  7\\n  8\\n  9\\n 10\\n 11\\n 12\\n 13\\n 14\\n 15\\n 16\\n\\njulia> reshape(A, (4, 4))\\n4\u00d74 Array{Int64,2}:\\n 1  5   9  13\\n 2  6  10  14\\n 3  7  11  15\\n 4  8  12  16\\n\\njulia> reshape(A, 2, :)\\n2\u00d78 Array{Int64,2}:\\n 1  3  5  7   9  11  13  15\\n 2  4  6  8  10  12  14  16\\n\\njulia> reshape(1:6, 2, 3)\\n2\u00d73 reshape(::UnitRange{Int64}, 2, 3) with eltype Int64:\\n 1  3  5\\n 2  4  6\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.dropdims\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.dropdims\",\n    \"category\": \"function\",\n    \"text\": \"dropdims(A; dims)\\n\\nRemove the dimensions specified by dims from array A. Elements of dims must be unique and within the range 1:ndims(A). size(A,i) must equal 1 for all i in dims.\\n\\nExamples\\n\\njulia> a = reshape(Vector(1:4),(2,2,1,1))\\n2\u00d72\u00d71\u00d71 Array{Int64,4}:\\n[:, :, 1, 1] =\\n 1  3\\n 2  4\\n\\njulia> dropdims(a; dims=3)\\n2\u00d72\u00d71 Array{Int64,3}:\\n[:, :, 1] =\\n 1  3\\n 2  4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.vec\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.vec\",\n    \"category\": \"function\",\n    \"text\": \"vec(a::AbstractArray) -> AbstractVector\\n\\nReshape the array a as a one-dimensional column vector. Return a if it is already an AbstractVector. The resulting array shares the same underlying data as a, so it will only be mutable if a is mutable, in which case modifying one will also modify the other.\\n\\nExamples\\n\\njulia> a = [1 2 3; 4 5 6]\\n2\u00d73 Array{Int64,2}:\\n 1  2  3\\n 4  5  6\\n\\njulia> vec(a)\\n6-element Array{Int64,1}:\\n 1\\n 4\\n 2\\n 5\\n 3\\n 6\\n\\njulia> vec(1:3)\\n1:3\\n\\nSee also reshape.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Views-(SubArrays-and-other-view-types)-1\",\n    \"page\": \"Arrays\",\n    \"title\": \"Views (SubArrays and other view types)\",\n    \"category\": \"section\",\n    \"text\": \"Base.view\\nBase.@view\\nBase.@views\\nBase.parent\\nBase.parentindices\\nBase.selectdim\\nBase.reinterpret\\nBase.reshape\\nBase.dropdims\\nBase.vec\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.cat\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.cat\",\n    \"category\": \"function\",\n    \"text\": \"cat(A...; dims=dims)\\n\\nConcatenate the input arrays along the specified dimensions in the iterable dims. For dimensions not in dims, all input arrays should have the same size, which will also be the size of the output array along that dimension. For dimensions in dims, the size of the output array is the sum of the sizes of the input arrays along that dimension. If dims is a single number, the different arrays are tightly stacked along that dimension. If dims is an iterable containing several dimensions, this allows one to construct block diagonal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example, cat(matrices...; dims=(1,2)) builds a block diagonal matrix, i.e. a block matrix with matrices[1], matrices[2], ... as diagonal blocks and matching zero blocks away from the diagonal.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.vcat\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.vcat\",\n    \"category\": \"function\",\n    \"text\": \"vcat(A...)\\n\\nConcatenate along dimension 1.\\n\\nExamples\\n\\njulia> a = [1 2 3 4 5]\\n1\u00d75 Array{Int64,2}:\\n 1  2  3  4  5\\n\\njulia> b = [6 7 8 9 10; 11 12 13 14 15]\\n2\u00d75 Array{Int64,2}:\\n  6   7   8   9  10\\n 11  12  13  14  15\\n\\njulia> vcat(a,b)\\n3\u00d75 Array{Int64,2}:\\n  1   2   3   4   5\\n  6   7   8   9  10\\n 11  12  13  14  15\\n\\njulia> c = ([1 2 3], [4 5 6])\\n([1 2 3], [4 5 6])\\n\\njulia> vcat(c...)\\n2\u00d73 Array{Int64,2}:\\n 1  2  3\\n 4  5  6\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.hcat\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.hcat\",\n    \"category\": \"function\",\n    \"text\": \"hcat(A...)\\n\\nConcatenate along dimension 2.\\n\\nExamples\\n\\njulia> a = [1; 2; 3; 4; 5]\\n5-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n 4\\n 5\\n\\njulia> b = [6 7; 8 9; 10 11; 12 13; 14 15]\\n5\u00d72 Array{Int64,2}:\\n  6   7\\n  8   9\\n 10  11\\n 12  13\\n 14  15\\n\\njulia> hcat(a,b)\\n5\u00d73 Array{Int64,2}:\\n 1   6   7\\n 2   8   9\\n 3  10  11\\n 4  12  13\\n 5  14  15\\n\\njulia> c = ([1; 2; 3], [4; 5; 6])\\n([1, 2, 3], [4, 5, 6])\\n\\njulia> hcat(c...)\\n3\u00d72 Array{Int64,2}:\\n 1  4\\n 2  5\\n 3  6\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.hvcat\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.hvcat\",\n    \"category\": \"function\",\n    \"text\": \"hvcat(rows::Tuple{Vararg{Int}}, values...)\\n\\nHorizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.\\n\\nExamples\\n\\njulia> a, b, c, d, e, f = 1, 2, 3, 4, 5, 6\\n(1, 2, 3, 4, 5, 6)\\n\\njulia> [a b c; d e f]\\n2\u00d73 Array{Int64,2}:\\n 1  2  3\\n 4  5  6\\n\\njulia> hvcat((3,3), a,b,c,d,e,f)\\n2\u00d73 Array{Int64,2}:\\n 1  2  3\\n 4  5  6\\n\\njulia> [a b;c d; e f]\\n3\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n 5  6\\n\\njulia> hvcat((2,2,2), a,b,c,d,e,f)\\n3\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n 5  6\\n\\nIf the first argument is a single integer n, then all block rows are assumed to have n block columns.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.vect\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.vect\",\n    \"category\": \"function\",\n    \"text\": \"vect(X...)\\n\\nCreate a Vector with element type computed from the promote_typeof of the argument, containing the argument list.\\n\\nExamples\\n\\njulia> a = Base.vect(UInt8(1), 2.5, 1//2)\\n3-element Array{Float64,1}:\\n 1.0\\n 2.5\\n 0.5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.circshift\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.circshift\",\n    \"category\": \"function\",\n    \"text\": \"circshift(A, shifts)\\n\\nCircularly shift, i.e. rotate, the data in an array. The second argument is a tuple or vector giving the amount to shift in each dimension, or an integer to shift only in the first dimension.\\n\\nExamples\\n\\njulia> b = reshape(Vector(1:16), (4,4))\\n4\u00d74 Array{Int64,2}:\\n 1  5   9  13\\n 2  6  10  14\\n 3  7  11  15\\n 4  8  12  16\\n\\njulia> circshift(b, (0,2))\\n4\u00d74 Array{Int64,2}:\\n  9  13  1  5\\n 10  14  2  6\\n 11  15  3  7\\n 12  16  4  8\\n\\njulia> circshift(b, (-1,0))\\n4\u00d74 Array{Int64,2}:\\n 2  6  10  14\\n 3  7  11  15\\n 4  8  12  16\\n 1  5   9  13\\n\\njulia> a = BitArray([true, true, false, false, true])\\n5-element BitArray{1}:\\n  true\\n  true\\n false\\n false\\n  true\\n\\njulia> circshift(a, 1)\\n5-element BitArray{1}:\\n  true\\n  true\\n  true\\n false\\n false\\n\\njulia> circshift(a, -1)\\n5-element BitArray{1}:\\n  true\\n false\\n false\\n  true\\n  true\\n\\nSee also circshift!.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.circshift!\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.circshift!\",\n    \"category\": \"function\",\n    \"text\": \"circshift!(dest, src, shifts)\\n\\nCircularly shift, i.e. rotate, the data in src, storing the result in dest. shifts specifies the amount to shift in each dimension.\\n\\nThe dest array must be distinct from the src array (they cannot alias each other).\\n\\nSee also circshift.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.circcopy!\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.circcopy!\",\n    \"category\": \"function\",\n    \"text\": \"circcopy!(dest, src)\\n\\nCopy src to dest, indexing each dimension modulo its length. src and dest must have the same size, but can be offset in their indices; any offset results in a (circular) wraparound. If the arrays have overlapping indices, then on the domain of the overlap dest agrees with src.\\n\\nExamples\\n\\njulia> src = reshape(Vector(1:16), (4,4))\\n4\u00d74 Array{Int64,2}:\\n 1  5   9  13\\n 2  6  10  14\\n 3  7  11  15\\n 4  8  12  16\\n\\njulia> dest = OffsetArray{Int}(undef, (0:3,2:5))\\n\\njulia> circcopy!(dest, src)\\nOffsetArrays.OffsetArray{Int64,2,Array{Int64,2}} with indices 0:3\u00d72:5:\\n 8  12  16  4\\n 5   9  13  1\\n 6  10  14  2\\n 7  11  15  3\\n\\njulia> dest[1:3,2:4] == src[1:3,2:4]\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.findall-Tuple{Any}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.findall\",\n    \"category\": \"method\",\n    \"text\": \"findall(A)\\n\\nReturn a vector I of the true indices or keys of A. If there are no such elements of A, return an empty array. To search for other kinds of values, pass a predicate as the first argument.\\n\\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\\n\\nExamples\\n\\njulia> A = [true, false, false, true]\\n4-element Array{Bool,1}:\\n  true\\n false\\n false\\n  true\\n\\njulia> findall(A)\\n2-element Array{Int64,1}:\\n 1\\n 4\\n\\njulia> A = [true false; false true]\\n2\u00d72 Array{Bool,2}:\\n  true  false\\n false   true\\n\\njulia> findall(A)\\n2-element Array{CartesianIndex{2},1}:\\n CartesianIndex(1, 1)\\n CartesianIndex(2, 2)\\n\\njulia> findall(falses(3))\\n0-element Array{Int64,1}\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.findall-Tuple{Function,Any}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.findall\",\n    \"category\": \"method\",\n    \"text\": \"findall(f::Function, A)\\n\\nReturn a vector I of the indices or keys of A where f(A[I]) returns true. If there are no such elements of A, return an empty array.\\n\\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\\n\\nExamples\\n\\njulia> x = [1, 3, 4]\\n3-element Array{Int64,1}:\\n 1\\n 3\\n 4\\n\\njulia> findall(isodd, x)\\n2-element Array{Int64,1}:\\n 1\\n 2\\n\\njulia> A = [1 2 0; 3 4 0]\\n2\u00d73 Array{Int64,2}:\\n 1  2  0\\n 3  4  0\\njulia> findall(isodd, A)\\n2-element Array{CartesianIndex{2},1}:\\n CartesianIndex(1, 1)\\n CartesianIndex(2, 1)\\n\\njulia> findall(!iszero, A)\\n4-element Array{CartesianIndex{2},1}:\\n CartesianIndex(1, 1)\\n CartesianIndex(2, 1)\\n CartesianIndex(1, 2)\\n CartesianIndex(2, 2)\\n\\njulia> d = Dict(:A => 10, :B => -1, :C => 0)\\nDict{Symbol,Int64} with 3 entries:\\n  :A => 10\\n  :B => -1\\n  :C => 0\\n\\njulia> findall(x -> x >= 0, d)\\n2-element Array{Symbol,1}:\\n :A\\n :C\\n\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.findfirst-Tuple{Any}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.findfirst\",\n    \"category\": \"method\",\n    \"text\": \"findfirst(A)\\n\\nReturn the index or key of the first true value in A. Return nothing if no such value is found. To search for other kinds of values, pass a predicate as the first argument.\\n\\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\\n\\nExamples\\n\\njulia> A = [false, false, true, false]\\n4-element Array{Bool,1}:\\n false\\n false\\n  true\\n false\\n\\njulia> findfirst(A)\\n3\\n\\njulia> findfirst(falses(3)) # returns nothing, but not printed in the REPL\\n\\njulia> A = [false false; true false]\\n2\u00d72 Array{Bool,2}:\\n false  false\\n  true  false\\n\\njulia> findfirst(A)\\nCartesianIndex(2, 1)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.findfirst-Tuple{Function,Any}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.findfirst\",\n    \"category\": \"method\",\n    \"text\": \"findfirst(predicate::Function, A)\\n\\nReturn the index or key of the first element of A for which predicate returns true. Return nothing if there is no such element.\\n\\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\\n\\nExamples\\n\\njulia> A = [1, 4, 2, 2]\\n4-element Array{Int64,1}:\\n 1\\n 4\\n 2\\n 2\\n\\njulia> findfirst(iseven, A)\\n2\\n\\njulia> findfirst(x -> x>10, A) # returns nothing, but not printed in the REPL\\n\\njulia> findfirst(isequal(4), A)\\n2\\n\\njulia> A = [1 4; 2 2]\\n2\u00d72 Array{Int64,2}:\\n 1  4\\n 2  2\\n\\njulia> findfirst(iseven, A)\\nCartesianIndex(2, 1)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.findlast-Tuple{Any}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.findlast\",\n    \"category\": \"method\",\n    \"text\": \"findlast(A)\\n\\nReturn the index or key of the last true value in A. Return nothing if there is no true value in A.\\n\\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\\n\\nExamples\\n\\njulia> A = [true, false, true, false]\\n4-element Array{Bool,1}:\\n  true\\n false\\n  true\\n false\\n\\njulia> findlast(A)\\n3\\n\\njulia> A = falses(2,2);\\n\\njulia> findlast(A) # returns nothing, but not printed in the REPL\\n\\njulia> A = [true false; true false]\\n2\u00d72 Array{Bool,2}:\\n true  false\\n true  false\\n\\njulia> findlast(A)\\nCartesianIndex(2, 1)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.findlast-Tuple{Function,Any}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.findlast\",\n    \"category\": \"method\",\n    \"text\": \"findlast(predicate::Function, A)\\n\\nReturn the index or key of the last element of A for which predicate returns true. Return nothing if there is no such element.\\n\\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\\n\\nExamples\\n\\njulia> A = [1, 2, 3, 4]\\n4-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n 4\\n\\njulia> findlast(isodd, A)\\n3\\n\\njulia> findlast(x -> x > 5, A) # returns nothing, but not printed in the REPL\\n\\njulia> A = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> findlast(isodd, A)\\nCartesianIndex(2, 1)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.findnext-Tuple{Any,Integer}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.findnext\",\n    \"category\": \"method\",\n    \"text\": \"findnext(A, i)\\n\\nFind the next index after or including i of a true element of A, or nothing if not found.\\n\\nIndices are of the same type as those returned by keys(A) and pairs(A).\\n\\nExamples\\n\\njulia> A = [false, false, true, false]\\n4-element Array{Bool,1}:\\n false\\n false\\n  true\\n false\\n\\njulia> findnext(A, 1)\\n3\\n\\njulia> findnext(A, 4) # returns nothing, but not printed in the REPL\\n\\njulia> A = [false false; true false]\\n2\u00d72 Array{Bool,2}:\\n false  false\\n  true  false\\n\\njulia> findnext(A, CartesianIndex(1, 1))\\nCartesianIndex(2, 1)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.findnext-Tuple{Function,Any,Integer}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.findnext\",\n    \"category\": \"method\",\n    \"text\": \"findnext(predicate::Function, A, i)\\n\\nFind the next index after or including i of an element of A for which predicate returns true, or nothing if not found.\\n\\nIndices are of the same type as those returned by keys(A) and pairs(A).\\n\\nExamples\\n\\njulia> A = [1, 4, 2, 2];\\n\\njulia> findnext(isodd, A, 1)\\n1\\n\\njulia> findnext(isodd, A, 2) # returns nothing, but not printed in the REPL\\n\\njulia> A = [1 4; 2 2];\\n\\njulia> findnext(isodd, A, CartesianIndex(1, 1))\\nCartesianIndex(1, 1)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.findprev-Tuple{Any,Integer}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.findprev\",\n    \"category\": \"method\",\n    \"text\": \"findprev(A, i)\\n\\nFind the previous index before or including i of a true element of A, or nothing if not found.\\n\\nIndices are of the same type as those returned by keys(A) and pairs(A).\\n\\nExamples\\n\\njulia> A = [false, false, true, true]\\n4-element Array{Bool,1}:\\n false\\n false\\n  true\\n  true\\n\\njulia> findprev(A, 3)\\n3\\n\\njulia> findprev(A, 1) # returns nothing, but not printed in the REPL\\n\\njulia> A = [false false; true true]\\n2\u00d72 Array{Bool,2}:\\n false  false\\n  true   true\\n\\njulia> findprev(A, CartesianIndex(2, 1))\\nCartesianIndex(2, 1)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.findprev-Tuple{Function,Any,Integer}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.findprev\",\n    \"category\": \"method\",\n    \"text\": \"findprev(predicate::Function, A, i)\\n\\nFind the previous index before or including i of an element of A for which predicate returns true, or nothing if not found.\\n\\nIndices are of the same type as those returned by keys(A) and pairs(A).\\n\\nExamples\\n\\njulia> A = [4, 6, 1, 2]\\n4-element Array{Int64,1}:\\n 4\\n 6\\n 1\\n 2\\n\\njulia> findprev(isodd, A, 1) # returns nothing, but not printed in the REPL\\n\\njulia> findprev(isodd, A, 3)\\n3\\n\\njulia> A = [4 6; 1 2]\\n2\u00d72 Array{Int64,2}:\\n 4  6\\n 1  2\\n\\njulia> findprev(isodd, A, CartesianIndex(1, 2))\\nCartesianIndex(2, 1)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.permutedims\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.permutedims\",\n    \"category\": \"function\",\n    \"text\": \"permutedims(A::AbstractArray, perm)\\n\\nPermute the dimensions of array A. perm is a vector specifying a permutation of length ndims(A).\\n\\nSee also: PermutedDimsArray.\\n\\nExamples\\n\\njulia> A = reshape(Vector(1:8), (2,2,2))\\n2\u00d72\u00d72 Array{Int64,3}:\\n[:, :, 1] =\\n 1  3\\n 2  4\\n\\n[:, :, 2] =\\n 5  7\\n 6  8\\n\\njulia> permutedims(A, [3, 2, 1])\\n2\u00d72\u00d72 Array{Int64,3}:\\n[:, :, 1] =\\n 1  3\\n 5  7\\n\\n[:, :, 2] =\\n 2  4\\n 6  8\\n\\n\\n\\n\\n\\npermutedims(m::AbstractMatrix)\\n\\nPermute the dimensions of the matrix m, by flipping the elements across the diagonal of the matrix. Differs from LinearAlgebra\\'s transpose in that the operation is not recursive.\\n\\nExamples\\n\\njulia> a = [1 2; 3 4];\\n\\njulia> b = [5 6; 7 8];\\n\\njulia> c = [9 10; 11 12];\\n\\njulia> d = [13 14; 15 16];\\n\\njulia> X = [[a] [b]; [c] [d]]\\n2\u00d72 Array{Array{Int64,2},2}:\\n [1 2; 3 4]     [5 6; 7 8]\\n [9 10; 11 12]  [13 14; 15 16]\\n\\njulia> permutedims(X)\\n2\u00d72 Array{Array{Int64,2},2}:\\n [1 2; 3 4]  [9 10; 11 12]\\n [5 6; 7 8]  [13 14; 15 16]\\n\\njulia> transpose(X)\\n2\u00d72 Transpose{Transpose{Int64,Array{Int64,2}},Array{Array{Int64,2},2}}:\\n [1 3; 2 4]  [9 11; 10 12]\\n [5 7; 6 8]  [13 15; 14 16]\\n\\n\\n\\n\\n\\npermutedims(v::AbstractVector)\\n\\nReshape vector v into a 1 \u00d7 length(v) row matrix. Differs from LinearAlgebra\\'s transpose in that the operation is not recursive.\\n\\nExamples\\n\\njulia> permutedims([1, 2, 3, 4])\\n1\u00d74 Array{Int64,2}:\\n 1  2  3  4\\n\\njulia> V = [[[1 2; 3 4]]; [[5 6; 7 8]]]\\n2-element Array{Array{Int64,2},1}:\\n [1 2; 3 4]\\n [5 6; 7 8]\\n\\njulia> permutedims(V)\\n1\u00d72 Array{Array{Int64,2},2}:\\n [1 2; 3 4]  [5 6; 7 8]\\n\\njulia> transpose(V)\\n1\u00d72 Transpose{Transpose{Int64,Array{Int64,2}},Array{Array{Int64,2},1}}:\\n [1 3; 2 4]  [5 7; 6 8]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.permutedims!\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.permutedims!\",\n    \"category\": \"function\",\n    \"text\": \"permutedims!(dest, src, perm)\\n\\nPermute the dimensions of array src and store the result in the array dest. perm is a vector specifying a permutation of length ndims(src). The preallocated array dest should have size(dest) == size(src)[perm] and is completely overwritten. No in-place permutation is supported and unexpected results will happen if src and dest have overlapping memory regions.\\n\\nSee also permutedims.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.PermutedDimsArrays.PermutedDimsArray\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.PermutedDimsArrays.PermutedDimsArray\",\n    \"category\": \"type\",\n    \"text\": \"PermutedDimsArray(A, perm) -> B\\n\\nGiven an AbstractArray A, create a view B such that the dimensions appear to be permuted. Similar to permutedims, except that no copying occurs (B shares storage with A).\\n\\nSee also: permutedims.\\n\\nExamples\\n\\njulia> A = rand(3,5,4);\\n\\njulia> B = PermutedDimsArray(A, (3,1,2));\\n\\njulia> size(B)\\n(4, 3, 5)\\n\\njulia> B[3,1,2] == A[1,2,3]\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.promote_shape\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.promote_shape\",\n    \"category\": \"function\",\n    \"text\": \"promote_shape(s1, s2)\\n\\nCheck two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.\\n\\nExamples\\n\\njulia> a = fill(1, (3,4,1,1,1));\\n\\njulia> b = fill(1, (3,4));\\n\\njulia> promote_shape(a,b)\\n(Base.OneTo(3), Base.OneTo(4), Base.OneTo(1), Base.OneTo(1), Base.OneTo(1))\\n\\njulia> promote_shape((2,3,1,4), (2, 3, 1, 4, 1))\\n(2, 3, 1, 4, 1)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Concatenation-and-permutation-1\",\n    \"page\": \"Arrays\",\n    \"title\": \"Concatenation and permutation\",\n    \"category\": \"section\",\n    \"text\": \"Base.cat\\nBase.vcat\\nBase.hcat\\nBase.hvcat\\nBase.vect\\nBase.circshift\\nBase.circshift!\\nBase.circcopy!\\nBase.findall(::Any)\\nBase.findall(::Function, ::Any)\\nBase.findfirst(::Any)\\nBase.findfirst(::Function, ::Any)\\nBase.findlast(::Any)\\nBase.findlast(::Function, ::Any)\\nBase.findnext(::Any, ::Integer)\\nBase.findnext(::Function, ::Any, ::Integer)\\nBase.findprev(::Any, ::Integer)\\nBase.findprev(::Function, ::Any, ::Integer)\\nBase.permutedims\\nBase.permutedims!\\nBase.PermutedDimsArray\\nBase.promote_shape\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.accumulate\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.accumulate\",\n    \"category\": \"function\",\n    \"text\": \"accumulate(op, A; dims::Integer, [init])\\n\\nCumulative operation op along the dimension dims of A (providing dims is optional for vectors). An inital value init may optionally be privided by a keyword argument. See also accumulate! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow). For common operations there are specialized variants of accumulate, see: cumsum, cumprod\\n\\nExamples\\n\\njulia> accumulate(+, [1,2,3])\\n3-element Array{Int64,1}:\\n 1\\n 3\\n 6\\n\\njulia> accumulate(*, [1,2,3])\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 6\\n\\njulia> accumulate(+, [1,2,3]; init=100)\\n3-element Array{Int64,1}:\\n 101\\n 103\\n 106\\n\\njulia> accumulate(min, [1,2,-1]; init=0)\\n3-element Array{Int64,1}:\\n  0\\n  0\\n -1\\n\\njulia> accumulate(+, fill(1, 3, 3), dims=1)\\n3\u00d73 Array{Int64,2}:\\n 1  1  1\\n 2  2  2\\n 3  3  3\\n\\njulia> accumulate(+, fill(1, 3, 3), dims=2)\\n3\u00d73 Array{Int64,2}:\\n 1  2  3\\n 1  2  3\\n 1  2  3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.accumulate!\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.accumulate!\",\n    \"category\": \"function\",\n    \"text\": \"accumulate!(op, B, A; [dims], [init])\\n\\nCumulative operation op on A along the dimension dims, storing the result in B. Providing dims is optional for vectors.  If the keyword argument init is given, its value is used to instantiate the accumulation. See also accumulate.\\n\\nExamples\\n\\njulia> x = [1, 0, 2, 0, 3];\\n\\njulia> y = [0, 0, 0, 0, 0];\\n\\njulia> accumulate!(+, y, x);\\n\\njulia> y\\n5-element Array{Int64,1}:\\n 1\\n 1\\n 3\\n 3\\n 6\\n\\njulia> A = [1 2; 3 4];\\n\\njulia> B = [0 0; 0 0];\\n\\njulia> accumulate!(-, B, A, dims=1);\\n\\njulia> B\\n2\u00d72 Array{Int64,2}:\\n  1   2\\n -2  -2\\n\\njulia> accumulate!(-, B, A, dims=2);\\n\\njulia> B\\n2\u00d72 Array{Int64,2}:\\n 1  -1\\n 3  -1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.cumprod\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.cumprod\",\n    \"category\": \"function\",\n    \"text\": \"cumprod(A; dims::Integer)\\n\\nCumulative product along the dimension dim. See also cumprod! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).\\n\\nExamples\\n\\njulia> a = [1 2 3; 4 5 6]\\n2\u00d73 Array{Int64,2}:\\n 1  2  3\\n 4  5  6\\n\\njulia> cumprod(a, dims=1)\\n2\u00d73 Array{Int64,2}:\\n 1   2   3\\n 4  10  18\\n\\njulia> cumprod(a, dims=2)\\n2\u00d73 Array{Int64,2}:\\n 1   2    6\\n 4  20  120\\n\\n\\n\\n\\n\\ncumprod(x::AbstractVector)\\n\\nCumulative product of a vector. See also cumprod! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).\\n\\nExamples\\n\\njulia> cumprod(fill(1//2, 3))\\n3-element Array{Rational{Int64},1}:\\n 1//2\\n 1//4\\n 1//8\\n\\njulia> cumprod([fill(1//3, 2, 2) for i in 1:3])\\n3-element Array{Array{Rational{Int64},2},1}:\\n [1//3 1//3; 1//3 1//3]\\n [2//9 2//9; 2//9 2//9]\\n [4//27 4//27; 4//27 4//27]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.cumprod!\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.cumprod!\",\n    \"category\": \"function\",\n    \"text\": \"cumprod!(B, A; dims::Integer)\\n\\nCumulative product of A along the dimension dims, storing the result in B. See also cumprod.\\n\\n\\n\\n\\n\\ncumprod!(y::AbstractVector, x::AbstractVector)\\n\\nCumulative product of a vector x, storing the result in y. See also cumprod.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.cumsum\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.cumsum\",\n    \"category\": \"function\",\n    \"text\": \"cumsum(A; dims::Integer)\\n\\nCumulative sum along the dimension dims. See also cumsum! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).\\n\\nExamples\\n\\njulia> a = [1 2 3; 4 5 6]\\n2\u00d73 Array{Int64,2}:\\n 1  2  3\\n 4  5  6\\n\\njulia> cumsum(a, dims=1)\\n2\u00d73 Array{Int64,2}:\\n 1  2  3\\n 5  7  9\\n\\njulia> cumsum(a, dims=2)\\n2\u00d73 Array{Int64,2}:\\n 1  3   6\\n 4  9  15\\n\\n\\n\\n\\n\\ncumsum(x::AbstractVector)\\n\\nCumulative sum a vector. See also cumsum! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).\\n\\nExamples\\n\\njulia> cumsum([1, 1, 1])\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n\\njulia> cumsum([fill(1, 2) for i in 1:3])\\n3-element Array{Array{Int64,1},1}:\\n [1, 1]\\n [2, 2]\\n [3, 3]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.cumsum!\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.cumsum!\",\n    \"category\": \"function\",\n    \"text\": \"cumsum!(B, A; dims::Integer)\\n\\nCumulative sum of A along the dimension dims, storing the result in B. See also cumsum.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.diff\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.diff\",\n    \"category\": \"function\",\n    \"text\": \"diff(A::AbstractVector)\\ndiff(A::AbstractMatrix; dims::Integer)\\n\\nFinite difference operator of matrix or vector A. If A is a matrix, specify the dimension over which to operate with the dims keyword argument.\\n\\nExamples\\n\\njulia> a = [2 4; 6 16]\\n2\u00d72 Array{Int64,2}:\\n 2   4\\n 6  16\\n\\njulia> diff(a, dims=2)\\n2\u00d71 Array{Int64,2}:\\n  2\\n 10\\n\\njulia> diff(vec(a))\\n3-element Array{Int64,1}:\\n  4\\n -2\\n 12\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.repeat\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.repeat\",\n    \"category\": \"function\",\n    \"text\": \"repeat(A::AbstractArray, counts::Integer...)\\n\\nConstruct an array by repeating array A a given number of times in each dimension, specified by counts.\\n\\nExamples\\n\\njulia> repeat([1, 2, 3], 2)\\n6-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n 1\\n 2\\n 3\\n\\njulia> repeat([1, 2, 3], 2, 3)\\n6\u00d73 Array{Int64,2}:\\n 1  1  1\\n 2  2  2\\n 3  3  3\\n 1  1  1\\n 2  2  2\\n 3  3  3\\n\\n\\n\\n\\n\\nrepeat(A::AbstractArray; inner=ntuple(x->1, ndims(A)), outer=ntuple(x->1, ndims(A)))\\n\\nConstruct an array by repeating the entries of A. The i-th element of inner specifies the number of times that the individual entries of the i-th dimension of A should be repeated. The i-th element of outer specifies the number of times that a slice along the i-th dimension of A should be repeated. If inner or outer are omitted, no repetition is performed.\\n\\nExamples\\n\\njulia> repeat(1:2, inner=2)\\n4-element Array{Int64,1}:\\n 1\\n 1\\n 2\\n 2\\n\\njulia> repeat(1:2, outer=2)\\n4-element Array{Int64,1}:\\n 1\\n 2\\n 1\\n 2\\n\\njulia> repeat([1 2; 3 4], inner=(2, 1), outer=(1, 3))\\n4\u00d76 Array{Int64,2}:\\n 1  2  1  2  1  2\\n 1  2  1  2  1  2\\n 3  4  3  4  3  4\\n 3  4  3  4  3  4\\n\\n\\n\\n\\n\\nrepeat(s::AbstractString, r::Integer)\\n\\nRepeat a string r times. This can be written as s^r.\\n\\nSee also: ^\\n\\nExamples\\n\\njulia> repeat(\\\"ha\\\", 3)\\n\\\"hahaha\\\"\\n\\n\\n\\n\\n\\nrepeat(c::AbstractChar, r::Integer) -> String\\n\\nRepeat a character r times. This can equivalently be accomplished by calling c^r.\\n\\nExamples\\n\\njulia> repeat(\\'A\\', 3)\\n\\\"AAA\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.rot180\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.rot180\",\n    \"category\": \"function\",\n    \"text\": \"rot180(A)\\n\\nRotate matrix A 180 degrees.\\n\\nExamples\\n\\njulia> a = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> rot180(a)\\n2\u00d72 Array{Int64,2}:\\n 4  3\\n 2  1\\n\\n\\n\\n\\n\\nrot180(A, k)\\n\\nRotate matrix A 180 degrees an integer k number of times. If k is even, this is equivalent to a copy.\\n\\nExamples\\n\\njulia> a = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> rot180(a,1)\\n2\u00d72 Array{Int64,2}:\\n 4  3\\n 2  1\\n\\njulia> rot180(a,2)\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.rotl90\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.rotl90\",\n    \"category\": \"function\",\n    \"text\": \"rotl90(A)\\n\\nRotate matrix A left 90 degrees.\\n\\nExamples\\n\\njulia> a = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> rotl90(a)\\n2\u00d72 Array{Int64,2}:\\n 2  4\\n 1  3\\n\\n\\n\\n\\n\\nrotl90(A, k)\\n\\nRotate matrix A left 90 degrees an integer k number of times. If k is zero or a multiple of four, this is equivalent to a copy.\\n\\nExamples\\n\\njulia> a = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> rotl90(a,1)\\n2\u00d72 Array{Int64,2}:\\n 2  4\\n 1  3\\n\\njulia> rotl90(a,2)\\n2\u00d72 Array{Int64,2}:\\n 4  3\\n 2  1\\n\\njulia> rotl90(a,3)\\n2\u00d72 Array{Int64,2}:\\n 3  1\\n 4  2\\n\\njulia> rotl90(a,4)\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.rotr90\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.rotr90\",\n    \"category\": \"function\",\n    \"text\": \"rotr90(A)\\n\\nRotate matrix A right 90 degrees.\\n\\nExamples\\n\\njulia> a = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> rotr90(a)\\n2\u00d72 Array{Int64,2}:\\n 3  1\\n 4  2\\n\\n\\n\\n\\n\\nrotr90(A, k)\\n\\nRotate matrix A right 90 degrees an integer k number of times. If k is zero or a multiple of four, this is equivalent to a copy.\\n\\nExamples\\n\\njulia> a = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> rotr90(a,1)\\n2\u00d72 Array{Int64,2}:\\n 3  1\\n 4  2\\n\\njulia> rotr90(a,2)\\n2\u00d72 Array{Int64,2}:\\n 4  3\\n 2  1\\n\\njulia> rotr90(a,3)\\n2\u00d72 Array{Int64,2}:\\n 2  4\\n 1  3\\n\\njulia> rotr90(a,4)\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.mapslices\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.mapslices\",\n    \"category\": \"function\",\n    \"text\": \"mapslices(f, A; dims)\\n\\nTransform the given dimensions of array A using function f. f is called on each slice of A of the form A[...,:,...,:,...]. dims is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if dims is [1,2] and A is 4-dimensional, f is called on A[:,:,i,j] for all i and j.\\n\\nExamples\\n\\njulia> a = reshape(Vector(1:16),(2,2,2,2))\\n2\u00d72\u00d72\u00d72 Array{Int64,4}:\\n[:, :, 1, 1] =\\n 1  3\\n 2  4\\n\\n[:, :, 2, 1] =\\n 5  7\\n 6  8\\n\\n[:, :, 1, 2] =\\n  9  11\\n 10  12\\n\\n[:, :, 2, 2] =\\n 13  15\\n 14  16\\n\\njulia> mapslices(sum, a, dims = [1,2])\\n1\u00d71\u00d72\u00d72 Array{Int64,4}:\\n[:, :, 1, 1] =\\n 10\\n\\n[:, :, 2, 1] =\\n 26\\n\\n[:, :, 1, 2] =\\n 42\\n\\n[:, :, 2, 2] =\\n 58\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Array-functions-1\",\n    \"page\": \"Arrays\",\n    \"title\": \"Array functions\",\n    \"category\": \"section\",\n    \"text\": \"Base.accumulate\\nBase.accumulate!\\nBase.cumprod\\nBase.cumprod!\\nBase.cumsum\\nBase.cumsum!\\nBase.diff\\nBase.repeat\\nBase.rot180\\nBase.rotl90\\nBase.rotr90\\nBase.mapslices\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.invperm\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.invperm\",\n    \"category\": \"function\",\n    \"text\": \"invperm(v)\\n\\nReturn the inverse permutation of v. If B = A[v], then A == B[invperm(v)].\\n\\nExamples\\n\\njulia> v = [2; 4; 3; 1];\\n\\njulia> invperm(v)\\n4-element Array{Int64,1}:\\n 4\\n 1\\n 3\\n 2\\n\\njulia> A = [\\'a\\',\\'b\\',\\'c\\',\\'d\\'];\\n\\njulia> B = A[v]\\n4-element Array{Char,1}:\\n \\'b\\'\\n \\'d\\'\\n \\'c\\'\\n \\'a\\'\\n\\njulia> B[invperm(v)]\\n4-element Array{Char,1}:\\n \\'a\\'\\n \\'b\\'\\n \\'c\\'\\n \\'d\\'\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.isperm\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.isperm\",\n    \"category\": \"function\",\n    \"text\": \"isperm(v) -> Bool\\n\\nReturn true if v is a valid permutation.\\n\\nExamples\\n\\njulia> isperm([1; 2])\\ntrue\\n\\njulia> isperm([1; 3])\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.permute!-Tuple{Any,AbstractArray{T,1} where T}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.permute!\",\n    \"category\": \"method\",\n    \"text\": \"permute!(v, p)\\n\\nPermute vector v in-place, according to permutation p. No checking is done to verify that p is a permutation.\\n\\nTo return a new permutation, use v[p]. Note that this is generally faster than permute!(v,p) for large vectors.\\n\\nSee also invpermute!.\\n\\nExamples\\n\\njulia> A = [1, 1, 3, 4];\\n\\njulia> perm = [2, 4, 3, 1];\\n\\njulia> permute!(A, perm);\\n\\njulia> A\\n4-element Array{Int64,1}:\\n 1\\n 4\\n 3\\n 1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.invpermute!\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.invpermute!\",\n    \"category\": \"function\",\n    \"text\": \"invpermute!(v, p)\\n\\nLike permute!, but the inverse of the given permutation is applied.\\n\\nExamples\\n\\njulia> A = [1, 1, 3, 4];\\n\\njulia> perm = [2, 4, 3, 1];\\n\\njulia> invpermute!(A, perm);\\n\\njulia> A\\n4-element Array{Int64,1}:\\n 4\\n 1\\n 3\\n 1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.reverse-Tuple{AbstractArray{T,1} where T}\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.reverse\",\n    \"category\": \"method\",\n    \"text\": \"reverse(v [, start=1 [, stop=length(v) ]] )\\n\\nReturn a copy of v reversed from start to stop.  See also Iterators.reverse for reverse-order iteration without making a copy.\\n\\nExamples\\n\\njulia> A = Vector(1:5)\\n5-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n 4\\n 5\\n\\njulia> reverse(A)\\n5-element Array{Int64,1}:\\n 5\\n 4\\n 3\\n 2\\n 1\\n\\njulia> reverse(A, 1, 4)\\n5-element Array{Int64,1}:\\n 4\\n 3\\n 2\\n 1\\n 5\\n\\njulia> reverse(A, 3, 5)\\n5-element Array{Int64,1}:\\n 1\\n 2\\n 5\\n 4\\n 3\\n\\n\\n\\n\\n\\nreverse(A; dims::Integer)\\n\\nReverse A in dimension dims.\\n\\nExamples\\n\\njulia> b = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> reverse(b, dims=2)\\n2\u00d72 Array{Int64,2}:\\n 2  1\\n 4  3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.reverseind\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.reverseind\",\n    \"category\": \"function\",\n    \"text\": \"reverseind(v, i)\\n\\nGiven an index i in reverse(v), return the corresponding index in v so that v[reverseind(v,i)] == reverse(v)[i]. (This can be nontrivial in cases where v contains non-ASCII characters.)\\n\\nExamples\\n\\njulia> r = reverse(\\\"Julia\\\")\\n\\\"ailuJ\\\"\\n\\njulia> for i in 1:length(r)\\n           print(r[reverseind(\\\"Julia\\\", i)])\\n       end\\nJulia\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Base.reverse!\",\n    \"page\": \"Arrays\",\n    \"title\": \"Base.reverse!\",\n    \"category\": \"function\",\n    \"text\": \"reverse!(v [, start=1 [, stop=length(v) ]]) -> v\\n\\nIn-place version of reverse.\\n\\nExamples\\n\\njulia> A = Vector(1:5)\\n5-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n 4\\n 5\\n\\njulia> reverse!(A);\\n\\njulia> A\\n5-element Array{Int64,1}:\\n 5\\n 4\\n 3\\n 2\\n 1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/arrays.html#Combinatorics-1\",\n    \"page\": \"Arrays\",\n    \"title\": \"Combinatorics\",\n    \"category\": \"section\",\n    \"text\": \"Base.invperm\\nBase.isperm\\nBase.permute!(::Any, ::AbstractVector)\\nBase.invpermute!\\nBase.reverse(::AbstractVector; kwargs...)\\nBase.reverseind\\nBase.reverse!\"\n},\n\n{\n    \"location\": \"base/parallel.html#\",\n    \"page\": \"Tasks\",\n    \"title\": \"Tasks\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/parallel.html#Core.Task\",\n    \"page\": \"Tasks\",\n    \"title\": \"Core.Task\",\n    \"category\": \"type\",\n    \"text\": \"Task(func)\\n\\nCreate a Task (i.e. coroutine) to execute the given function func (which must be callable with no arguments). The task exits when this function returns.\\n\\nExamples\\n\\njulia> a() = sum(i for i in 1:1000);\\n\\njulia> b = Task(a);\\n\\nIn this example, b is a runnable Task that hasn\\'t started yet.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.current_task\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.current_task\",\n    \"category\": \"function\",\n    \"text\": \"current_task()\\n\\nGet the currently running Task.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.istaskdone\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.istaskdone\",\n    \"category\": \"function\",\n    \"text\": \"istaskdone(t::Task) -> Bool\\n\\nDetermine whether a task has exited.\\n\\nExamples\\n\\njulia> a2() = sum(i for i in 1:1000);\\n\\njulia> b = Task(a2);\\n\\njulia> istaskdone(b)\\nfalse\\n\\njulia> schedule(b);\\n\\njulia> yield();\\n\\njulia> istaskdone(b)\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.istaskstarted\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.istaskstarted\",\n    \"category\": \"function\",\n    \"text\": \"istaskstarted(t::Task) -> Bool\\n\\nDetermine whether a task has started executing.\\n\\nExamples\\n\\njulia> a3() = sum(i for i in 1:1000);\\n\\njulia> b = Task(a3);\\n\\njulia> istaskstarted(b)\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.yield\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.yield\",\n    \"category\": \"function\",\n    \"text\": \"yield()\\n\\nSwitch to the scheduler to allow another scheduled task to run. A task that calls this function is still runnable, and will be restarted immediately if there are no other runnable tasks.\\n\\n\\n\\n\\n\\nyield(t::Task, arg = nothing)\\n\\nA fast, unfair-scheduling version of schedule(t, arg); yield() which immediately yields to t before calling the scheduler.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.yieldto\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.yieldto\",\n    \"category\": \"function\",\n    \"text\": \"yieldto(t::Task, arg = nothing)\\n\\nSwitch to the given task. The first time a task is switched to, the task\\'s function is called with no arguments. On subsequent switches, arg is returned from the task\\'s last call to yieldto. This is a low-level call that only switches tasks, not considering states or scheduling in any way. Its use is discouraged.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.task_local_storage-Tuple{Any}\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.task_local_storage\",\n    \"category\": \"method\",\n    \"text\": \"task_local_storage(key)\\n\\nLook up the value of a key in the current task\\'s task-local storage.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.task_local_storage-Tuple{Any,Any}\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.task_local_storage\",\n    \"category\": \"method\",\n    \"text\": \"task_local_storage(key, value)\\n\\nAssign a value to a key in the current task\\'s task-local storage.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.task_local_storage-Tuple{Function,Any,Any}\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.task_local_storage\",\n    \"category\": \"method\",\n    \"text\": \"task_local_storage(body, key, value)\\n\\nCall the function body with a modified task-local storage, in which value is assigned to key; the previous value of key, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.Condition\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.Condition\",\n    \"category\": \"type\",\n    \"text\": \"Condition()\\n\\nCreate an edge-triggered event source that tasks can wait for. Tasks that call wait on a Condition are suspended and queued. Tasks are woken up when notify is later called on the Condition. Edge triggering means that only tasks waiting at the time notify is called can be woken up. For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The Channel type does this, and so can be used for level-triggered events.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.notify\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.notify\",\n    \"category\": \"function\",\n    \"text\": \"notify(condition, val=nothing; all=true, error=false)\\n\\nWake up tasks waiting for a condition, passing them val. If all is true (the default), all waiting tasks are woken, otherwise only one is. If error is true, the passed value is raised as an exception in the woken tasks.\\n\\nReturn the count of tasks woken up. Return 0 if no tasks are waiting on condition.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.schedule\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.schedule\",\n    \"category\": \"function\",\n    \"text\": \"schedule(t::Task, [val]; error=false)\\n\\nAdd a Task to the scheduler\\'s queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as wait.\\n\\nIf a second argument val is provided, it will be passed to the task (via the return value of yieldto) when it runs again. If error is true, the value is raised as an exception in the woken task.\\n\\nExamples\\n\\njulia> a5() = sum(i for i in 1:1000);\\n\\njulia> b = Task(a5);\\n\\njulia> istaskstarted(b)\\nfalse\\n\\njulia> schedule(b);\\n\\njulia> yield();\\n\\njulia> istaskstarted(b)\\ntrue\\n\\njulia> istaskdone(b)\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.@task\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.@task\",\n    \"category\": \"macro\",\n    \"text\": \"@task\\n\\nWrap an expression in a Task without executing it, and return the Task. This only creates a task, and does not run it.\\n\\nExamples\\n\\njulia> a1() = sum(i for i in 1:1000);\\n\\njulia> b = @task a1();\\n\\njulia> istaskstarted(b)\\nfalse\\n\\njulia> schedule(b);\\n\\njulia> yield();\\n\\njulia> istaskdone(b)\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.sleep\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.sleep\",\n    \"category\": \"function\",\n    \"text\": \"sleep(seconds)\\n\\nBlock the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of 0.001.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.Channel\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.Channel\",\n    \"category\": \"type\",\n    \"text\": \"Channel{T}(sz::Int)\\n\\nConstructs a Channel with an internal buffer that can hold a maximum of sz objects of type T. put! calls on a full channel block until an object is removed with take!.\\n\\nChannel(0) constructs an unbuffered channel. put! blocks until a matching take! is called. And vice-versa.\\n\\nOther constructors:\\n\\nChannel(Inf): equivalent to Channel{Any}(typemax(Int))\\nChannel(sz): equivalent to Channel{Any}(sz)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.put!-Tuple{Channel,Any}\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.put!\",\n    \"category\": \"method\",\n    \"text\": \"put!(c::Channel, v)\\n\\nAppend an item v to the channel c. Blocks if the channel is full.\\n\\nFor unbuffered channels, blocks until a take! is performed by a different task.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.take!-Tuple{Channel}\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.take!\",\n    \"category\": \"method\",\n    \"text\": \"take!(c::Channel)\\n\\nRemove and return a value from a Channel. Blocks until data is available.\\n\\nFor unbuffered channels, blocks until a put! is performed by a different task.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.isready-Tuple{Channel}\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.isready\",\n    \"category\": \"method\",\n    \"text\": \"isready(c::Channel)\\n\\nDetermine whether a Channel has a value stored to it. Returns immediately, does not block.\\n\\nFor unbuffered channels returns true if there are tasks waiting on a put!.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.fetch-Tuple{Channel}\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.fetch\",\n    \"category\": \"method\",\n    \"text\": \"fetch(c::Channel)\\n\\nWait for and get the first available item from the channel. Does not remove the item. fetch is unsupported on an unbuffered (0-size) channel.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.close-Tuple{Channel}\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.close\",\n    \"category\": \"method\",\n    \"text\": \"close(c::Channel)\\n\\nClose a channel. An exception is thrown by:\\n\\nput! on a closed channel.\\ntake! and fetch on an empty, closed channel.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.bind-Tuple{Channel,Task}\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.bind\",\n    \"category\": \"method\",\n    \"text\": \"bind(chnl::Channel, task::Task)\\n\\nAssociate the lifetime of chnl with a task. Channel chnl is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on chnl.\\n\\nThe chnl object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed Channel objects.\\n\\nWhen a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.\\n\\nExamples\\n\\njulia> c = Channel(0);\\n\\njulia> task = @async foreach(i->put!(c, i), 1:4);\\n\\njulia> bind(c,task);\\n\\njulia> for i in c\\n           @show i\\n       end;\\ni = 1\\ni = 2\\ni = 3\\ni = 4\\n\\njulia> isopen(c)\\nfalse\\n\\njulia> c = Channel(0);\\n\\njulia> task = @async (put!(c,1);error(\\\"foo\\\"));\\n\\njulia> bind(c,task);\\n\\njulia> take!(c)\\n1\\n\\njulia> put!(c,1);\\nERROR: foo\\nStacktrace:\\n[...]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.asyncmap\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.asyncmap\",\n    \"category\": \"function\",\n    \"text\": \"asyncmap(f, c...; ntasks=0, batch_size=nothing)\\n\\nUses multiple concurrent tasks to map f over a collection (or multiple equal length collections). For multiple collection arguments, f is applied elementwise.\\n\\nntasks specifies the number of tasks to run concurrently. Depending on the length of the collections, if ntasks is unspecified, up to 100 tasks will be used for concurrent mapping.\\n\\nntasks can also be specified as a zero-arg function. In this case, the number of tasks to run in parallel is checked before processing every element and a new task started if the value of ntasks_func is less than the current number of tasks.\\n\\nIf batch_size is specified, the collection is processed in batch mode. f must then be a function that must accept a Vector of argument tuples and must return a vector of results. The input vector will have a length of batch_size or less.\\n\\nThe following examples highlight execution in different tasks by returning the objectid of the tasks in which the mapping function is executed.\\n\\nFirst, with ntasks undefined, each element is processed in a different task.\\n\\njulia> tskoid() = objectid(current_task());\\n\\njulia> asyncmap(x->tskoid(), 1:5)\\n5-element Array{UInt64,1}:\\n 0x6e15e66c75c75853\\n 0x440f8819a1baa682\\n 0x9fb3eeadd0c83985\\n 0xebd3e35fe90d4050\\n 0x29efc93edce2b961\\n\\njulia> length(unique(asyncmap(x->tskoid(), 1:5)))\\n5\\n\\nWith ntasks=2 all elements are processed in 2 tasks.\\n\\njulia> asyncmap(x->tskoid(), 1:5; ntasks=2)\\n5-element Array{UInt64,1}:\\n 0x027ab1680df7ae94\\n 0xa23d2f80cd7cf157\\n 0x027ab1680df7ae94\\n 0xa23d2f80cd7cf157\\n 0x027ab1680df7ae94\\n\\njulia> length(unique(asyncmap(x->tskoid(), 1:5; ntasks=2)))\\n2\\n\\nWith batch_size defined, the mapping function needs to be changed to accept an array of argument tuples and return an array of results. map is used in the modified mapping function to achieve this.\\n\\njulia> batch_func(input) = map(x->string(\\\"args_tuple: \\\", x, \\\", element_val: \\\", x[1], \\\", task: \\\", tskoid()), input)\\nbatch_func (generic function with 1 method)\\n\\njulia> asyncmap(batch_func, 1:5; ntasks=2, batch_size=2)\\n5-element Array{String,1}:\\n \\\"args_tuple: (1,), element_val: 1, task: 9118321258196414413\\\"\\n \\\"args_tuple: (2,), element_val: 2, task: 4904288162898683522\\\"\\n \\\"args_tuple: (3,), element_val: 3, task: 9118321258196414413\\\"\\n \\\"args_tuple: (4,), element_val: 4, task: 4904288162898683522\\\"\\n \\\"args_tuple: (5,), element_val: 5, task: 9118321258196414413\\\"\\n\\nnote: Note\\nCurrently, all tasks in Julia are executed in a single OS thread co-operatively. Consequently, asyncmap is beneficial only when the mapping function involves any I/O - disk, network, remote worker invocation, etc.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Base.asyncmap!\",\n    \"page\": \"Tasks\",\n    \"title\": \"Base.asyncmap!\",\n    \"category\": \"function\",\n    \"text\": \"asyncmap!(f, results, c...; ntasks=0, batch_size=nothing)\\n\\nLike asyncmap, but stores output in results rather than returning a collection.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/parallel.html#Tasks-1\",\n    \"page\": \"Tasks\",\n    \"title\": \"Tasks\",\n    \"category\": \"section\",\n    \"text\": \"Core.Task\\nBase.current_task\\nBase.istaskdone\\nBase.istaskstarted\\nBase.yield\\nBase.yieldto\\nBase.task_local_storage(::Any)\\nBase.task_local_storage(::Any, ::Any)\\nBase.task_local_storage(::Function, ::Any, ::Any)\\nBase.Condition\\nBase.notify\\nBase.schedule\\nBase.@task\\nBase.sleep\\nBase.Channel\\nBase.put!(::Channel, ::Any)\\nBase.take!(::Channel)\\nBase.isready(::Channel)\\nBase.fetch(::Channel)\\nBase.close(::Channel)\\nBase.bind(c::Channel, task::Task)\\nBase.asyncmap\\nBase.asyncmap!\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Multi-Threading\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Threads.threadid\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Threads.threadid\",\n    \"category\": \"function\",\n    \"text\": \"Threads.threadid()\\n\\nGet the ID number of the current thread of execution. The master thread has ID 1.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Threads.nthreads\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Threads.nthreads\",\n    \"category\": \"function\",\n    \"text\": \"Threads.nthreads()\\n\\nGet the number of threads available to the Julia process. This is the inclusive upper bound on threadid().\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Threads.@threads\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Threads.@threads\",\n    \"category\": \"macro\",\n    \"text\": \"Threads.@threads\\n\\nA macro to parallelize a for-loop to run with multiple threads. This spawns nthreads() number of threads, splits the iteration space amongst them, and iterates in parallel. A barrier is placed at the end of the loop which waits for all the threads to finish execution, and the loop returns.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Threads.Atomic\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Threads.Atomic\",\n    \"category\": \"type\",\n    \"text\": \"Threads.Atomic{T}\\n\\nHolds a reference to an object of type T, ensuring that it is only accessed atomically, i.e. in a thread-safe manner.\\n\\nOnly certain \\\"simple\\\" types can be used atomically, namely the primitive boolean, integer, and float-point types. These are Bool, Int8...Int128, UInt8...UInt128, and Float16...Float64.\\n\\nNew atomic objects can be created from a non-atomic values; if none is specified, the atomic object is initialized with zero.\\n\\nAtomic objects can be accessed using the [] notation:\\n\\nExamples\\n\\njulia> x = Threads.Atomic{Int}(3)\\nBase.Threads.Atomic{Int64}(3)\\n\\njulia> x[] = 1\\n1\\n\\njulia> x[]\\n1\\n\\nAtomic operations use an atomic_ prefix, such as atomic_add!, atomic_xchg!, etc.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Threads.atomic_cas!\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Threads.atomic_cas!\",\n    \"category\": \"function\",\n    \"text\": \"Threads.atomic_cas!(x::Atomic{T}, cmp::T, newval::T) where T\\n\\nAtomically compare-and-set x\\n\\nAtomically compares the value in x with cmp. If equal, write newval to x. Otherwise, leaves x unmodified. Returns the old value in x. By comparing the returned value to cmp (via ===) one knows whether x was modified and now holds the new value newval.\\n\\nFor further details, see LLVM\\'s cmpxchg instruction.\\n\\nThis function can be used to implement transactional semantics. Before the transaction, one records the value in x. After the transaction, the new value is stored only if x has not been modified in the mean time.\\n\\nExamples\\n\\njulia> x = Threads.Atomic{Int}(3)\\nBase.Threads.Atomic{Int64}(3)\\n\\njulia> Threads.atomic_cas!(x, 4, 2);\\n\\njulia> x\\nBase.Threads.Atomic{Int64}(3)\\n\\njulia> Threads.atomic_cas!(x, 3, 2);\\n\\njulia> x\\nBase.Threads.Atomic{Int64}(2)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Threads.atomic_xchg!\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Threads.atomic_xchg!\",\n    \"category\": \"function\",\n    \"text\": \"Threads.atomic_xchg!(x::Atomic{T}, newval::T) where T\\n\\nAtomically exchange the value in x\\n\\nAtomically exchanges the value in x with newval. Returns the old value.\\n\\nFor further details, see LLVM\\'s atomicrmw xchg instruction.\\n\\nExamples\\n\\njulia> x = Threads.Atomic{Int}(3)\\nBase.Threads.Atomic{Int64}(3)\\n\\njulia> Threads.atomic_xchg!(x, 2)\\n3\\n\\njulia> x[]\\n2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Threads.atomic_add!\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Threads.atomic_add!\",\n    \"category\": \"function\",\n    \"text\": \"Threads.atomic_add!(x::Atomic{T}, val::T) where T <: ArithmeticTypes\\n\\nAtomically add val to x\\n\\nPerforms x[] += val atomically. Returns the old value. Not defined for Atomic{Bool}.\\n\\nFor further details, see LLVM\\'s atomicrmw add instruction.\\n\\nExamples\\n\\njulia> x = Threads.Atomic{Int}(3)\\nBase.Threads.Atomic{Int64}(3)\\n\\njulia> Threads.atomic_add!(x, 2)\\n3\\n\\njulia> x[]\\n5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Threads.atomic_sub!\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Threads.atomic_sub!\",\n    \"category\": \"function\",\n    \"text\": \"Threads.atomic_sub!(x::Atomic{T}, val::T) where T <: ArithmeticTypes\\n\\nAtomically subtract val from x\\n\\nPerforms x[] -= val atomically. Returns the old value. Not defined for Atomic{Bool}.\\n\\nFor further details, see LLVM\\'s atomicrmw sub instruction.\\n\\nExamples\\n\\njulia> x = Threads.Atomic{Int}(3)\\nBase.Threads.Atomic{Int64}(3)\\n\\njulia> Threads.atomic_sub!(x, 2)\\n3\\n\\njulia> x[]\\n1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Threads.atomic_and!\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Threads.atomic_and!\",\n    \"category\": \"function\",\n    \"text\": \"Threads.atomic_and!(x::Atomic{T}, val::T) where T\\n\\nAtomically bitwise-and x with val\\n\\nPerforms x[] &= val atomically. Returns the old value.\\n\\nFor further details, see LLVM\\'s atomicrmw and instruction.\\n\\nExamples\\n\\njulia> x = Threads.Atomic{Int}(3)\\nBase.Threads.Atomic{Int64}(3)\\n\\njulia> Threads.atomic_and!(x, 2)\\n3\\n\\njulia> x[]\\n2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Threads.atomic_nand!\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Threads.atomic_nand!\",\n    \"category\": \"function\",\n    \"text\": \"Threads.atomic_nand!(x::Atomic{T}, val::T) where T\\n\\nAtomically bitwise-nand (not-and) x with val\\n\\nPerforms x[] = ~(x[] & val) atomically. Returns the old value.\\n\\nFor further details, see LLVM\\'s atomicrmw nand instruction.\\n\\nExamples\\n\\njulia> x = Threads.Atomic{Int}(3)\\nBase.Threads.Atomic{Int64}(3)\\n\\njulia> Threads.atomic_nand!(x, 2)\\n3\\n\\njulia> x[]\\n-3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Threads.atomic_or!\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Threads.atomic_or!\",\n    \"category\": \"function\",\n    \"text\": \"Threads.atomic_or!(x::Atomic{T}, val::T) where T\\n\\nAtomically bitwise-or x with val\\n\\nPerforms x[] |= val atomically. Returns the old value.\\n\\nFor further details, see LLVM\\'s atomicrmw or instruction.\\n\\nExamples\\n\\njulia> x = Threads.Atomic{Int}(5)\\nBase.Threads.Atomic{Int64}(5)\\n\\njulia> Threads.atomic_or!(x, 7)\\n5\\n\\njulia> x[]\\n7\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Threads.atomic_xor!\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Threads.atomic_xor!\",\n    \"category\": \"function\",\n    \"text\": \"Threads.atomic_xor!(x::Atomic{T}, val::T) where T\\n\\nAtomically bitwise-xor (exclusive-or) x with val\\n\\nPerforms x[] $= val atomically. Returns the old value.\\n\\nFor further details, see LLVM\\'s atomicrmw xor instruction.\\n\\nExamples\\n\\njulia> x = Threads.Atomic{Int}(5)\\nBase.Threads.Atomic{Int64}(5)\\n\\njulia> Threads.atomic_xor!(x, 7)\\n5\\n\\njulia> x[]\\n2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Threads.atomic_max!\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Threads.atomic_max!\",\n    \"category\": \"function\",\n    \"text\": \"Threads.atomic_max!(x::Atomic{T}, val::T) where T\\n\\nAtomically store the maximum of x and val in x\\n\\nPerforms x[] = max(x[], val) atomically. Returns the old value.\\n\\nFor further details, see LLVM\\'s atomicrmw max instruction.\\n\\nExamples\\n\\njulia> x = Threads.Atomic{Int}(5)\\nBase.Threads.Atomic{Int64}(5)\\n\\njulia> Threads.atomic_max!(x, 7)\\n5\\n\\njulia> x[]\\n7\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Threads.atomic_min!\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Threads.atomic_min!\",\n    \"category\": \"function\",\n    \"text\": \"Threads.atomic_min!(x::Atomic{T}, val::T) where T\\n\\nAtomically store the minimum of x and val in x\\n\\nPerforms x[] = min(x[], val) atomically. Returns the old value.\\n\\nFor further details, see LLVM\\'s atomicrmw min instruction.\\n\\nExamples\\n\\njulia> x = Threads.Atomic{Int}(7)\\nBase.Threads.Atomic{Int64}(7)\\n\\njulia> Threads.atomic_min!(x, 5)\\n7\\n\\njulia> x[]\\n5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Threads.atomic_fence\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Threads.atomic_fence\",\n    \"category\": \"function\",\n    \"text\": \"Threads.atomic_fence()\\n\\nInsert a sequential-consistency memory fence\\n\\nInserts a memory fence with sequentially-consistent ordering semantics. There are algorithms where this is needed, i.e. where an acquire/release ordering is insufficient.\\n\\nThis is likely a very expensive operation. Given that all other atomic operations in Julia already have acquire/release semantics, explicit fences should not be necessary in most cases.\\n\\nFor further details, see LLVM\\'s fence instruction.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Multi-Threading-1\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Multi-Threading\",\n    \"category\": \"section\",\n    \"text\": \"This experimental interface supports Julia\\'s multi-threading capabilities. Types and functions described here might (and likely will) change in the future.Base.Threads.threadid\\nBase.Threads.nthreads\\nBase.Threads.@threads\\nBase.Threads.Atomic\\nBase.Threads.atomic_cas!\\nBase.Threads.atomic_xchg!\\nBase.Threads.atomic_add!\\nBase.Threads.atomic_sub!\\nBase.Threads.atomic_and!\\nBase.Threads.atomic_nand!\\nBase.Threads.atomic_or!\\nBase.Threads.atomic_xor!\\nBase.Threads.atomic_max!\\nBase.Threads.atomic_min!\\nBase.Threads.atomic_fence\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.@threadcall\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.@threadcall\",\n    \"category\": \"macro\",\n    \"text\": \"@threadcall((cfunc, clib), rettype, (argtypes...), argvals...)\\n\\nThe @threadcall macro is called in the same way as ccall but does the work in a different thread. This is useful when you want to call a blocking C function without causing the main julia thread to become blocked. Concurrency is limited by size of the libuv thread pool, which defaults to 4 threads but can be increased by setting the UV_THREADPOOL_SIZE environment variable and restarting the julia process.\\n\\nNote that the called function should never call back into Julia.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#ccall-using-a-threadpool-(Experimental)-1\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"ccall using a threadpool (Experimental)\",\n    \"category\": \"section\",\n    \"text\": \"Base.@threadcall\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Threads.AbstractLock\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Threads.AbstractLock\",\n    \"category\": \"type\",\n    \"text\": \"AbstractLock\\n\\nAbstract supertype describing types that implement the thread-safe synchronization primitives: lock, trylock, unlock, and islocked.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.lock\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.lock\",\n    \"category\": \"function\",\n    \"text\": \"lock(lock)\\n\\nAcquire the lock when it becomes available. If the lock is already locked by a different task/thread, wait for it to become available.\\n\\nEach lock must be matched by an unlock.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.unlock\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.unlock\",\n    \"category\": \"function\",\n    \"text\": \"unlock(lock)\\n\\nReleases ownership of the lock.\\n\\nIf this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.trylock\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.trylock\",\n    \"category\": \"function\",\n    \"text\": \"trylock(lock) -> Success (Boolean)\\n\\nAcquire the lock if it is available, and return true if successful. If the lock is already locked by a different task/thread, return false.\\n\\nEach successful trylock must be matched by an unlock.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.islocked\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.islocked\",\n    \"category\": \"function\",\n    \"text\": \"islocked(lock) -> Status (Boolean)\\n\\nCheck whether the lock is held by any task/thread. This should not be used for synchronization (see instead trylock).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.ReentrantLock\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.ReentrantLock\",\n    \"category\": \"type\",\n    \"text\": \"ReentrantLock()\\n\\nCreates a reentrant lock for synchronizing Tasks. The same task can acquire the lock as many times as required. Each lock must be matched with an unlock.\\n\\nThis lock is NOT threadsafe. See Threads.Mutex for a threadsafe lock.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Threads.Mutex\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Threads.Mutex\",\n    \"category\": \"type\",\n    \"text\": \"Mutex()\\n\\nThese are standard system mutexes for locking critical sections of logic.\\n\\nOn Windows, this is a critical section object, on pthreads, this is a pthread_mutex_t.\\n\\nSee also SpinLock for a lighter-weight lock.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Threads.SpinLock\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Threads.SpinLock\",\n    \"category\": \"type\",\n    \"text\": \"SpinLock()\\n\\nCreate a non-reentrant lock. Recursive use will result in a deadlock. Each lock must be matched with an unlock.\\n\\nTest-and-test-and-set spin locks are quickest up to about 30ish contending threads. If you have more contention than that, perhaps a lock is the wrong way to synchronize.\\n\\nSee also RecursiveSpinLock for a version that permits recursion.\\n\\nSee also Mutex for a more efficient version on one core or if the lock may be held for a considerable length of time.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Threads.RecursiveSpinLock\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Threads.RecursiveSpinLock\",\n    \"category\": \"type\",\n    \"text\": \"RecursiveSpinLock()\\n\\nCreates a reentrant lock. The same thread can acquire the lock as many times as required. Each lock must be matched with an unlock.\\n\\nSee also SpinLock for a slightly faster version.\\n\\nSee also Mutex for a more efficient version on one core or if the lock may be held for a considerable length of time.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.Semaphore\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.Semaphore\",\n    \"category\": \"type\",\n    \"text\": \"Semaphore(sem_size)\\n\\nCreate a counting semaphore that allows at most sem_size acquires to be in use at any time. Each acquire must be matched with a release.\\n\\nThis construct is NOT threadsafe.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.acquire\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.acquire\",\n    \"category\": \"function\",\n    \"text\": \"acquire(s::Semaphore)\\n\\nWait for one of the sem_size permits to be available, blocking until one can be acquired.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Base.release\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Base.release\",\n    \"category\": \"function\",\n    \"text\": \"release(s::Semaphore)\\n\\nReturn one permit to the pool, possibly allowing another task to acquire it and resume execution.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/multi-threading.html#Synchronization-Primitives-1\",\n    \"page\": \"Multi-Threading\",\n    \"title\": \"Synchronization Primitives\",\n    \"category\": \"section\",\n    \"text\": \"Base.Threads.AbstractLock\\nBase.lock\\nBase.unlock\\nBase.trylock\\nBase.islocked\\nBase.ReentrantLock\\nBase.Threads.Mutex\\nBase.Threads.SpinLock\\nBase.Threads.RecursiveSpinLock\\nBase.Semaphore\\nBase.acquire\\nBase.release\"\n},\n\n{\n    \"location\": \"base/constants.html#\",\n    \"page\": \"Constants\",\n    \"title\": \"Constants\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/constants.html#Core.nothing\",\n    \"page\": \"Constants\",\n    \"title\": \"Core.nothing\",\n    \"category\": \"constant\",\n    \"text\": \"nothing\\n\\nThe singleton instance of type Nothing, used by convention when there is no value to return (as in a C void function) or when a variable or field holds no value.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/constants.html#Base.PROGRAM_FILE\",\n    \"page\": \"Constants\",\n    \"title\": \"Base.PROGRAM_FILE\",\n    \"category\": \"constant\",\n    \"text\": \"PROGRAM_FILE\\n\\nA string containing the script name passed to Julia from the command line. Note that the script name remains unchanged from within included files. Alternatively see @__FILE__.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/constants.html#Base.ARGS\",\n    \"page\": \"Constants\",\n    \"title\": \"Base.ARGS\",\n    \"category\": \"constant\",\n    \"text\": \"ARGS\\n\\nAn array of the command line arguments passed to Julia, as strings.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/constants.html#Base.C_NULL\",\n    \"page\": \"Constants\",\n    \"title\": \"Base.C_NULL\",\n    \"category\": \"constant\",\n    \"text\": \"C_NULL\\n\\nThe C null pointer constant, sometimes used when calling external code.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/constants.html#Base.VERSION\",\n    \"page\": \"Constants\",\n    \"title\": \"Base.VERSION\",\n    \"category\": \"constant\",\n    \"text\": \"VERSION\\n\\nA VersionNumber object describing which version of Julia is in use. For details see Version Number Literals.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/constants.html#Base.LOAD_PATH\",\n    \"page\": \"Constants\",\n    \"title\": \"Base.LOAD_PATH\",\n    \"category\": \"constant\",\n    \"text\": \"LOAD_PATH\\n\\nAn array of paths for using and import statements to consdier as project environments or package directories when loading code. See Code Loading.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/constants.html#Base.Sys.BINDIR\",\n    \"page\": \"Constants\",\n    \"title\": \"Base.Sys.BINDIR\",\n    \"category\": \"constant\",\n    \"text\": \"Sys.BINDIR\\n\\nA string containing the full path to the directory containing the julia executable.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/constants.html#Base.Sys.CPU_THREADS\",\n    \"page\": \"Constants\",\n    \"title\": \"Base.Sys.CPU_THREADS\",\n    \"category\": \"constant\",\n    \"text\": \"Sys.CPU_THREADS\\n\\nThe number of logical CPU cores available in the system, i.e. the number of threads that the CPU can run concurrently. Note that this is not necessarily the number of CPU cores, for example, in the presence of hyper-threading.\\n\\nSee Hwloc.jl or CpuId.jl for extended information, including number of physical cores.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/constants.html#Base.Sys.WORD_SIZE\",\n    \"page\": \"Constants\",\n    \"title\": \"Base.Sys.WORD_SIZE\",\n    \"category\": \"constant\",\n    \"text\": \"Sys.WORD_SIZE\\n\\nStandard word size on the current machine, in bits.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/constants.html#Base.Sys.KERNEL\",\n    \"page\": \"Constants\",\n    \"title\": \"Base.Sys.KERNEL\",\n    \"category\": \"constant\",\n    \"text\": \"Sys.KERNEL\\n\\nA symbol representing the name of the operating system, as returned by uname of the build configuration.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/constants.html#Base.Sys.ARCH\",\n    \"page\": \"Constants\",\n    \"title\": \"Base.Sys.ARCH\",\n    \"category\": \"constant\",\n    \"text\": \"Sys.ARCH\\n\\nA symbol representing the architecture of the build configuration.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/constants.html#Base.Sys.MACHINE\",\n    \"page\": \"Constants\",\n    \"title\": \"Base.Sys.MACHINE\",\n    \"category\": \"constant\",\n    \"text\": \"Sys.MACHINE\\n\\nA string containing the build triple.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/constants.html#lib-constants-1\",\n    \"page\": \"Constants\",\n    \"title\": \"Constants\",\n    \"category\": \"section\",\n    \"text\": \"Core.nothing\\nBase.PROGRAM_FILE\\nBase.ARGS\\nBase.C_NULL\\nBase.VERSION\\nBase.LOAD_PATH\\nBase.Sys.BINDIR\\nBase.Sys.CPU_THREADS\\nBase.Sys.WORD_SIZE\\nBase.Sys.KERNEL\\nBase.Sys.ARCH\\nBase.Sys.MACHINESee also:stdin\\nstdout\\nstderr\\nENV\\nENDIAN_BOM\\nLibc.MS_ASYNC\\nLibc.MS_INVALIDATE\\nLibc.MS_SYNC\"\n},\n\n{\n    \"location\": \"base/file.html#\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Filesystem\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.pwd\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.pwd\",\n    \"category\": \"function\",\n    \"text\": \"pwd() -> AbstractString\\n\\nGet the current working directory.\\n\\nExamples\\n\\njulia> pwd()\\n\\\"/home/JuliaUser\\\"\\n\\njulia> cd(\\\"/home/JuliaUser/Projects/julia\\\")\\n\\njulia> pwd()\\n\\\"/home/JuliaUser/Projects/julia\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.cd-Tuple{AbstractString}\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.cd\",\n    \"category\": \"method\",\n    \"text\": \"cd(dir::AbstractString=homedir())\\n\\nSet the current working directory.\\n\\nExamples\\n\\njulia> cd(\\\"/home/JuliaUser/Projects/julia\\\")\\n\\njulia> pwd()\\n\\\"/home/JuliaUser/Projects/julia\\\"\\n\\njulia> cd()\\n\\njulia> pwd()\\n\\\"/home/JuliaUser\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.cd-Tuple{Function}\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.cd\",\n    \"category\": \"method\",\n    \"text\": \"cd(f::Function, dir::AbstractString=homedir())\\n\\nTemporarily change the current working directory to dir, apply function f and finally return to the original directory.\\n\\nExamples\\n\\njulia> pwd()\\n\\\"/home/JuliaUser\\\"\\n\\njulia> cd(readdir, \\\"/home/JuliaUser/Projects/julia\\\")\\n34-element Array{String,1}:\\n \\\".circleci\\\"\\n \\\".freebsdci.sh\\\"\\n \\\".git\\\"\\n \\\".gitattributes\\\"\\n \\\".github\\\"\\n \u22ee\\n \\\"test\\\"\\n \\\"ui\\\"\\n \\\"usr\\\"\\n \\\"usr-staging\\\"\\n\\njulia> pwd()\\n\\\"/home/JuliaUser\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.readdir\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.readdir\",\n    \"category\": \"function\",\n    \"text\": \"readdir(dir::AbstractString=\\\".\\\") -> Vector{String}\\n\\nReturn the files and directories in the directory dir (or the current working directory if not given).\\n\\nExamples\\n\\njulia> readdir(\\\"/home/JuliaUser/Projects/julia\\\")\\n34-element Array{String,1}:\\n \\\".circleci\\\"\\n \\\".freebsdci.sh\\\"\\n \\\".git\\\"\\n \\\".gitattributes\\\"\\n \\\".github\\\"\\n \u22ee\\n \\\"test\\\"\\n \\\"ui\\\"\\n \\\"usr\\\"\\n \\\"usr-staging\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.walkdir\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.walkdir\",\n    \"category\": \"function\",\n    \"text\": \"walkdir(dir; topdown=true, follow_symlinks=false, onerror=throw)\\n\\nReturn an iterator that walks the directory tree of a directory. The iterator returns a tuple containing (rootpath, dirs, files). The directory tree can be traversed top-down or bottom-up. If walkdir encounters a SystemError it will rethrow the error by default. A custom error handling function can be provided through onerror keyword argument. onerror is called with a SystemError as argument.\\n\\nExamples\\n\\nfor (root, dirs, files) in walkdir(\\\".\\\")\\n    println(\\\"Directories in $root\\\")\\n    for dir in dirs\\n        println(joinpath(root, dir)) # path to directories\\n    end\\n    println(\\\"Files in $root\\\")\\n    for file in files\\n        println(joinpath(root, file)) # path to files\\n    end\\nend\\n\\njulia> mkpath(\\\"my/test/dir\\\");\\n\\njulia> itr = walkdir(\\\"my\\\");\\n\\njulia> (root, dirs, files) = first(itr)\\n(\\\"my\\\", [\\\"test\\\"], String[])\\n\\njulia> (root, dirs, files) = first(itr)\\n(\\\"my/test\\\", [\\\"dir\\\"], String[])\\n\\njulia> (root, dirs, files) = first(itr)\\n(\\\"my/test/dir\\\", String[], String[])\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.mkdir\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.mkdir\",\n    \"category\": \"function\",\n    \"text\": \"mkdir(path::AbstractString; mode::Unsigned = 0o777)\\n\\nMake a new directory with name path and permissions mode. mode defaults to 0o777, modified by the current file creation mask. This function never creates more than one directory. If the directory already exists, or some intermediate directories do not exist, this function throws an error. See mkpath for a function which creates all required intermediate directories. Return path.\\n\\nExamples\\n\\njulia> mkdir(\\\"testingdir\\\")\\n\\\"testingdir\\\"\\n\\njulia> cd(\\\"testingdir\\\")\\n\\njulia> pwd()\\n\\\"/home/JuliaUser/testingdir\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.mkpath\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.mkpath\",\n    \"category\": \"function\",\n    \"text\": \"mkpath(path::AbstractString; mode::Unsigned = 0o777)\\n\\nCreate all directories in the given path, with permissions mode. mode defaults to 0o777, modified by the current file creation mask. Return path.\\n\\nExamples\\n\\njulia> mkdir(\\\"testingdir\\\")\\n\\\"testingdir\\\"\\n\\njulia> cd(\\\"testingdir\\\")\\n\\njulia> pwd()\\n\\\"/home/JuliaUser/testingdir\\\"\\n\\njulia> mkpath(\\\"my/test/dir\\\")\\n\\\"my/test/dir\\\"\\n\\njulia> readdir()\\n1-element Array{String,1}:\\n \\\"my\\\"\\n\\njulia> cd(\\\"my\\\")\\n\\njulia> readdir()\\n1-element Array{String,1}:\\n \\\"test\\\"\\n\\njulia> readdir(\\\"test\\\")\\n1-element Array{String,1}:\\n \\\"dir\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.symlink\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.symlink\",\n    \"category\": \"function\",\n    \"text\": \"symlink(target::AbstractString, link::AbstractString)\\n\\nCreates a symbolic link to target with the name link.\\n\\nnote: Note\\nThis function raises an error under operating systems that do not support soft symbolic links, such as Windows XP.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.readlink\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.readlink\",\n    \"category\": \"function\",\n    \"text\": \"readlink(path::AbstractString) -> AbstractString\\n\\nReturn the target location a symbolic link path points to.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.chmod\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.chmod\",\n    \"category\": \"function\",\n    \"text\": \"chmod(path::AbstractString, mode::Integer; recursive::Bool=false)\\n\\nChange the permissions mode of path to mode. Only integer modes (e.g. 0o777) are currently supported. If recursive=true and the path is a directory all permissions in that directory will be recursively changed. Return path.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.chown\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.chown\",\n    \"category\": \"function\",\n    \"text\": \"chown(path::AbstractString, owner::Integer, group::Integer=-1)\\n\\nChange the owner and/or group of path to owner and/or group. If the value entered for owner or group is -1 the corresponding ID will not change. Only integer owners and groups are currently supported. Return path.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Libc.RawFD\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Libc.RawFD\",\n    \"category\": \"type\",\n    \"text\": \"RawFD\\n\\nPrimitive type which wraps the native OS file descriptor. RawFDs can be passed to methods like stat to discover information about the underlying file, and can also be used to open streams, with the RawFD describing the OS file backing the stream.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.stat\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.stat\",\n    \"category\": \"function\",\n    \"text\": \"stat(file)\\n\\nReturns a structure whose fields contain information about the file. The fields of the structure are:\\n\\nName Description\\nsize The size (in bytes) of the file\\ndevice ID of the device that contains the file\\ninode The inode number of the file\\nmode The protection mode of the file\\nnlink The number of hard links to the file\\nuid The user id of the owner of the file\\ngid The group id of the file owner\\nrdev If this file refers to a device, the ID of the device it refers to\\nblksize The file-system preferred block size for the file\\nblocks The number of such blocks allocated\\nmtime Unix timestamp of when the file was last modified\\nctime Unix timestamp of when the file was created\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.lstat\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.lstat\",\n    \"category\": \"function\",\n    \"text\": \"lstat(file)\\n\\nLike stat, but for symbolic links gets the info for the link itself rather than the file it refers to. This function must be called on a file path rather than a file object or a file descriptor.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.ctime\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.ctime\",\n    \"category\": \"function\",\n    \"text\": \"ctime(file)\\n\\nEquivalent to stat(file).ctime.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.mtime\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.mtime\",\n    \"category\": \"function\",\n    \"text\": \"mtime(file)\\n\\nEquivalent to stat(file).mtime.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.filemode\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.filemode\",\n    \"category\": \"function\",\n    \"text\": \"filemode(file)\\n\\nEquivalent to stat(file).mode.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.filesize\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.filesize\",\n    \"category\": \"function\",\n    \"text\": \"filesize(path...)\\n\\nEquivalent to stat(file).size.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.uperm\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.uperm\",\n    \"category\": \"function\",\n    \"text\": \"uperm(file)\\n\\nGet the permissions of the owner of the file as a bitfield of\\n\\nValue Description\\n01 Execute Permission\\n02 Write Permission\\n04 Read Permission\\n\\nFor allowed arguments, see stat.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.gperm\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.gperm\",\n    \"category\": \"function\",\n    \"text\": \"gperm(file)\\n\\nLike uperm but gets the permissions of the group owning the file.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.operm\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.operm\",\n    \"category\": \"function\",\n    \"text\": \"operm(file)\\n\\nLike uperm but gets the permissions for people who neither own the file nor are a member of the group owning the file\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.cp\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.cp\",\n    \"category\": \"function\",\n    \"text\": \"cp(src::AbstractString, dst::AbstractString; force::Bool=false, follow_symlinks::Bool=false)\\n\\nCopy the file, link, or directory from src to dest. force=true will first remove an existing dst.\\n\\nIf follow_symlinks=false, and src is a symbolic link, dst will be created as a symbolic link. If follow_symlinks=true and src is a symbolic link, dst will be a copy of the file or directory src refers to. Return dst.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.download\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.download\",\n    \"category\": \"function\",\n    \"text\": \"download(url::AbstractString, [localfile::AbstractString])\\n\\nDownload a file from the given url, optionally renaming it to the given local file name. Note that this function relies on the availability of external tools such as curl, wget or fetch to download the file and is provided for convenience. For production use or situations in which more options are needed, please use a package that provides the desired functionality instead.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.mv\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.mv\",\n    \"category\": \"function\",\n    \"text\": \"mv(src::AbstractString, dst::AbstractString; force::Bool=false)\\n\\nMove the file, link, or directory from src to dst. force=true will first remove an existing dst. Return dst.\\n\\nExamples\\n\\njulia> write(\\\"hello.txt\\\", \\\"world\\\");\\n\\njulia> mv(\\\"hello.txt\\\", \\\"goodbye.txt\\\")\\n\\\"goodbye.txt\\\"\\n\\njulia> \\\"hello.txt\\\" in readdir()\\nfalse\\n\\njulia> readline(\\\"goodbye.txt\\\")\\n\\\"world\\\"\\n\\njulia> write(\\\"hello.txt\\\", \\\"world2\\\");\\n\\njulia> mv(\\\"hello.txt\\\", \\\"goodbye.txt\\\")\\nERROR: ArgumentError: \\'goodbye.txt\\' exists. `force=true` is required to remove \\'goodbye.txt\\' before moving.\\nStacktrace:\\n [1] #checkfor_mv_cp_cptree#10(::Bool, ::Function, ::String, ::String, ::String) at ./file.jl:293\\n[...]\\n\\njulia> mv(\\\"hello.txt\\\", \\\"goodbye.txt\\\", force=true)\\n\\\"goodbye.txt\\\"\\n\\njulia> rm(\\\"goodbye.txt\\\");\\n\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.rm\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.rm\",\n    \"category\": \"function\",\n    \"text\": \"rm(path::AbstractString; force::Bool=false, recursive::Bool=false)\\n\\nDelete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.\\n\\nExamples\\n\\njulia> mkpath(\\\"my/test/dir\\\");\\n\\njulia> rm(\\\"my\\\", recursive=true)\\n\\njulia> rm(\\\"this_file_does_not_exist\\\", force=true)\\n\\njulia> rm(\\\"this_file_does_not_exist\\\")\\nERROR: IOError: unlink: no such file or directory (ENOENT)\\nStacktrace:\\n[...]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.touch\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.touch\",\n    \"category\": \"function\",\n    \"text\": \"touch(path::AbstractString)\\n\\nUpdate the last-modified timestamp on a file to the current time. Return path.\\n\\nExamples\\n\\njulia> write(\\\"my_little_file\\\", 2);\\n\\njulia> mtime(\\\"my_little_file\\\")\\n1.5273815391135583e9\\n\\njulia> touch(\\\"my_little_file\\\");\\n\\njulia> mtime(\\\"my_little_file\\\")\\n1.527381559163435e9\\n\\nWe can see the mtime has been modified by touch.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.tempname\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.tempname\",\n    \"category\": \"function\",\n    \"text\": \"tempname()\\n\\nGenerate a temporary file path. This function only returns a path; no file is created. The path is likely to be unique, but this cannot be guaranteed.\\n\\nwarning: Warning\\nThis can lead to race conditions if another process obtains the same file name and creates the file before you are able to. Using mktemp() is recommended instead.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.tempdir\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.tempdir\",\n    \"category\": \"function\",\n    \"text\": \"tempdir()\\n\\nObtain the path of a temporary directory (possibly shared with other processes).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.mktemp-Tuple{Any}\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.mktemp\",\n    \"category\": \"method\",\n    \"text\": \"mktemp(parent=tempdir())\\n\\nReturn (path, io), where path is the path of a new temporary file in parent and io is an open file object for this path.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.mktemp-Tuple{Function,Any}\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.mktemp\",\n    \"category\": \"method\",\n    \"text\": \"mktemp(f::Function, parent=tempdir())\\n\\nApply the function f to the result of mktemp(parent) and remove the temporary file upon completion.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.mktempdir-Tuple{Any}\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.mktempdir\",\n    \"category\": \"method\",\n    \"text\": \"mktempdir(parent=tempdir())\\n\\nCreate a temporary directory in the parent directory and return its path. If parent does not exist, throw an error.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.mktempdir-Tuple{Function,Any}\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.mktempdir\",\n    \"category\": \"method\",\n    \"text\": \"mktempdir(f::Function, parent=tempdir())\\n\\nApply the function f to the result of mktempdir(parent) and remove the temporary directory upon completion.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.isblockdev\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.isblockdev\",\n    \"category\": \"function\",\n    \"text\": \"isblockdev(path) -> Bool\\n\\nReturn true if path is a block device, false otherwise.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.ischardev\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.ischardev\",\n    \"category\": \"function\",\n    \"text\": \"ischardev(path) -> Bool\\n\\nReturn true if path is a character device, false otherwise.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.isdir\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.isdir\",\n    \"category\": \"function\",\n    \"text\": \"isdir(path) -> Bool\\n\\nReturn true if path is a directory, false otherwise.\\n\\nExamples\\n\\njulia> isdir(homedir())\\ntrue\\n\\njulia> isdir(\\\"not/a/directory\\\")\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.isfifo\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.isfifo\",\n    \"category\": \"function\",\n    \"text\": \"isfifo(path) -> Bool\\n\\nReturn true if path is a FIFO, false otherwise.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.isfile\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.isfile\",\n    \"category\": \"function\",\n    \"text\": \"isfile(path) -> Bool\\n\\nReturn true if path is a regular file, false otherwise.\\n\\nExamples\\n\\njulia> isfile(homedir())\\nfalse\\n\\njulia> f = open(\\\"test_file.txt\\\", \\\"w\\\");\\n\\njulia> isfile(f)\\ntrue\\n\\njulia> close(f); rm(\\\"test_file.txt\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.islink\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.islink\",\n    \"category\": \"function\",\n    \"text\": \"islink(path) -> Bool\\n\\nReturn true if path is a symbolic link, false otherwise.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.ismount\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.ismount\",\n    \"category\": \"function\",\n    \"text\": \"ismount(path) -> Bool\\n\\nReturn true if path is a mount point, false otherwise.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.ispath\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.ispath\",\n    \"category\": \"function\",\n    \"text\": \"ispath(path) -> Bool\\n\\nReturn true if path is a valid filesystem path, false otherwise.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.issetgid\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.issetgid\",\n    \"category\": \"function\",\n    \"text\": \"issetgid(path) -> Bool\\n\\nReturn true if path has the setgid flag set, false otherwise.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.issetuid\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.issetuid\",\n    \"category\": \"function\",\n    \"text\": \"issetuid(path) -> Bool\\n\\nReturn true if path has the setuid flag set, false otherwise.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.issocket\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.issocket\",\n    \"category\": \"function\",\n    \"text\": \"issocket(path) -> Bool\\n\\nReturn true if path is a socket, false otherwise.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.issticky\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.issticky\",\n    \"category\": \"function\",\n    \"text\": \"issticky(path) -> Bool\\n\\nReturn true if path has the sticky bit set, false otherwise.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.homedir\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.homedir\",\n    \"category\": \"function\",\n    \"text\": \"homedir() -> AbstractString\\n\\nReturn the current user\\'s home directory.\\n\\nnote: Note\\nhomedir determines the home directory via libuv\\'s uv_os_homedir. For details (for example on how to specify the home directory via environment variables), see the uv_os_homedir documentation.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.dirname\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.dirname\",\n    \"category\": \"function\",\n    \"text\": \"dirname(path::AbstractString) -> AbstractString\\n\\nGet the directory part of a path.\\n\\nExamples\\n\\njulia> dirname(\\\"/home/myuser\\\")\\n\\\"/home\\\"\\n\\nSee also: basename\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.basename\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.basename\",\n    \"category\": \"function\",\n    \"text\": \"basename(path::AbstractString) -> AbstractString\\n\\nGet the file name part of a path.\\n\\nExamples\\n\\njulia> basename(\\\"/home/myuser/example.jl\\\")\\n\\\"example.jl\\\"\\n\\nSee also: dirname\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.@__FILE__\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.@__FILE__\",\n    \"category\": \"macro\",\n    \"text\": \"@__FILE__ -> AbstractString\\n\\nExpand to a string with the path to the file containing the macrocall, or an empty string if evaluated by julia -e <expr>. Return nothing if the macro was missing parser source information. Alternatively see PROGRAM_FILE.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.@__DIR__\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.@__DIR__\",\n    \"category\": \"macro\",\n    \"text\": \"@__DIR__ -> AbstractString\\n\\nExpand to a string with the absolute path to the directory of the file containing the macrocall. Return the current working directory if run from a REPL or if evaluated by julia -e <expr>.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.@__LINE__\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.@__LINE__\",\n    \"category\": \"macro\",\n    \"text\": \"@__LINE__ -> Int\\n\\nExpand to the line number of the location of the macrocall. Return 0 if the line number could not be determined.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.isabspath\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.isabspath\",\n    \"category\": \"function\",\n    \"text\": \"isabspath(path::AbstractString) -> Bool\\n\\nDetermine whether a path is absolute (begins at the root directory).\\n\\nExamples\\n\\njulia> isabspath(\\\"/home\\\")\\ntrue\\n\\njulia> isabspath(\\\"home\\\")\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.isdirpath\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.isdirpath\",\n    \"category\": \"function\",\n    \"text\": \"isdirpath(path::AbstractString) -> Bool\\n\\nDetermine whether a path refers to a directory (for example, ends with a path separator).\\n\\nExamples\\n\\njulia> isdirpath(\\\"/home\\\")\\nfalse\\n\\njulia> isdirpath(\\\"/home/\\\")\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.joinpath\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.joinpath\",\n    \"category\": \"function\",\n    \"text\": \"joinpath(parts...) -> AbstractString\\n\\nJoin path components into a full path. If some argument is an absolute path or (on Windows) has a drive specification that doesn\\'t match the drive computed for the join of the preceding paths, then prior components are dropped.\\n\\nExamples\\n\\njulia> joinpath(\\\"/home/myuser\\\", \\\"example.jl\\\")\\n\\\"/home/myuser/example.jl\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.abspath\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.abspath\",\n    \"category\": \"function\",\n    \"text\": \"abspath(path::AbstractString) -> AbstractString\\n\\nConvert a path to an absolute path by adding the current directory if necessary. Also normalizes the path as in normpath.\\n\\n\\n\\n\\n\\nabspath(path::AbstractString, paths::AbstractString...) -> AbstractString\\n\\nConvert a set of paths to an absolute path by joining them together and adding the current directory if necessary. Equivalent to abspath(joinpath(path, paths...)).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.normpath\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.normpath\",\n    \"category\": \"function\",\n    \"text\": \"normpath(path::AbstractString) -> AbstractString\\n\\nNormalize a path, removing \\\".\\\" and \\\"..\\\" entries.\\n\\nExamples\\n\\njulia> normpath(\\\"/home/myuser/../example.jl\\\")\\n\\\"/home/example.jl\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.realpath\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.realpath\",\n    \"category\": \"function\",\n    \"text\": \"realpath(path::AbstractString) -> AbstractString\\n\\nCanonicalize a path by expanding symbolic links and removing \\\".\\\" and \\\"..\\\" entries.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.relpath\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.relpath\",\n    \"category\": \"function\",\n    \"text\": \"relpath(path::AbstractString, startpath::AbstractString = \\\".\\\") -> AbstractString\\n\\nReturn a relative filepath to path either from the current directory or from an optional start directory. This is a path computation: the filesystem is not accessed to confirm the existence or nature of path or startpath.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.expanduser\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.expanduser\",\n    \"category\": \"function\",\n    \"text\": \"expanduser(path::AbstractString) -> AbstractString\\n\\nOn Unix systems, replace a tilde character at the start of a path with the current user\\'s home directory.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.splitdir\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.splitdir\",\n    \"category\": \"function\",\n    \"text\": \"splitdir(path::AbstractString) -> (AbstractString, AbstractString)\\n\\nSplit a path into a tuple of the directory name and file name.\\n\\nExamples\\n\\njulia> splitdir(\\\"/home/myuser\\\")\\n(\\\"/home\\\", \\\"myuser\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.splitdrive\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.splitdrive\",\n    \"category\": \"function\",\n    \"text\": \"splitdrive(path::AbstractString) -> (AbstractString, AbstractString)\\n\\nOn Windows, split a path into the drive letter part and the path part. On Unix systems, the first component is always the empty string.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Base.Filesystem.splitext\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Base.Filesystem.splitext\",\n    \"category\": \"function\",\n    \"text\": \"splitext(path::AbstractString) -> (AbstractString, AbstractString)\\n\\nIf the last component of a path contains a dot, split the path into everything before the dot and everything including and after the dot. Otherwise, return a tuple of the argument unmodified and the empty string.\\n\\nExamples\\n\\njulia> splitext(\\\"/home/myuser/example.jl\\\")\\n(\\\"/home/myuser/example\\\", \\\".jl\\\")\\n\\njulia> splitext(\\\"/home/myuser/example\\\")\\n(\\\"/home/myuser/example\\\", \\\"\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/file.html#Filesystem-1\",\n    \"page\": \"Filesystem\",\n    \"title\": \"Filesystem\",\n    \"category\": \"section\",\n    \"text\": \"Base.Filesystem.pwd\\nBase.Filesystem.cd(::AbstractString)\\nBase.Filesystem.cd(::Function)\\nBase.Filesystem.readdir\\nBase.Filesystem.walkdir\\nBase.Filesystem.mkdir\\nBase.Filesystem.mkpath\\nBase.Filesystem.symlink\\nBase.Filesystem.readlink\\nBase.Filesystem.chmod\\nBase.Filesystem.chown\\nBase.RawFD\\nBase.stat\\nBase.Filesystem.lstat\\nBase.Filesystem.ctime\\nBase.Filesystem.mtime\\nBase.Filesystem.filemode\\nBase.Filesystem.filesize\\nBase.Filesystem.uperm\\nBase.Filesystem.gperm\\nBase.Filesystem.operm\\nBase.Filesystem.cp\\nBase.download\\nBase.Filesystem.mv\\nBase.Filesystem.rm\\nBase.Filesystem.touch\\nBase.Filesystem.tempname\\nBase.Filesystem.tempdir\\nBase.Filesystem.mktemp(::Any)\\nBase.Filesystem.mktemp(::Function, ::Any)\\nBase.Filesystem.mktempdir(::Any)\\nBase.Filesystem.mktempdir(::Function, ::Any)\\nBase.Filesystem.isblockdev\\nBase.Filesystem.ischardev\\nBase.Filesystem.isdir\\nBase.Filesystem.isfifo\\nBase.Filesystem.isfile\\nBase.Filesystem.islink\\nBase.Filesystem.ismount\\nBase.Filesystem.ispath\\nBase.Filesystem.issetgid\\nBase.Filesystem.issetuid\\nBase.Filesystem.issocket\\nBase.Filesystem.issticky\\nBase.Filesystem.homedir\\nBase.Filesystem.dirname\\nBase.Filesystem.basename\\nBase.@__FILE__\\nBase.@__DIR__\\nBase.@__LINE__\\nBase.Filesystem.isabspath\\nBase.Filesystem.isdirpath\\nBase.Filesystem.joinpath\\nBase.Filesystem.abspath\\nBase.Filesystem.normpath\\nBase.Filesystem.realpath\\nBase.Filesystem.relpath\\nBase.Filesystem.expanduser\\nBase.Filesystem.splitdir\\nBase.Filesystem.splitdrive\\nBase.Filesystem.splitext\"\n},\n\n{\n    \"location\": \"base/io-network.html#\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"I/O and Network\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/io-network.html#I/O-and-Network-1\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"I/O and Network\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.stdout\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.stdout\",\n    \"category\": \"constant\",\n    \"text\": \"stdout\\n\\nGlobal variable referring to the standard out stream.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.stderr\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.stderr\",\n    \"category\": \"constant\",\n    \"text\": \"stderr\\n\\nGlobal variable referring to the standard error stream.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.stdin\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.stdin\",\n    \"category\": \"constant\",\n    \"text\": \"stdin\\n\\nGlobal variable referring to the standard input stream.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.open\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.open\",\n    \"category\": \"function\",\n    \"text\": \"open(filename::AbstractString; keywords...) -> IOStream\\n\\nOpen a file in a mode specified by five boolean keyword arguments:\\n\\nKeyword Description Default\\nread open for reading !write\\nwrite open for writing truncate | append\\ncreate create if non-existent !read & write | truncate | append\\ntruncate truncate to zero size !read & write\\nappend seek to end false\\n\\nThe default when no keywords are passed is to open files for reading only. Returns a stream for accessing the opened file.\\n\\n\\n\\n\\n\\nopen(filename::AbstractString, [mode::AbstractString]) -> IOStream\\n\\nAlternate syntax for open, where a string-based mode specifier is used instead of the five booleans. The values of mode correspond to those from fopen(3) or Perl open, and are equivalent to setting the following boolean groups:\\n\\nMode Description Keywords\\nr read none\\nw write, create, truncate write = true\\na write, create, append append = true\\nr+ read, write read = true, write = true\\nw+ read, write, create, truncate truncate = true, read = true\\na+ read, write, create, append append = true, read = true\\n\\nExamples\\n\\njulia> io = open(\\\"myfile.txt\\\", \\\"w\\\");\\n\\njulia> write(io, \\\"Hello world!\\\");\\n\\njulia> close(io);\\n\\njulia> io = open(\\\"myfile.txt\\\", \\\"r\\\");\\n\\njulia> read(io, String)\\n\\\"Hello world!\\\"\\n\\njulia> write(io, \\\"This file is read only\\\")\\nERROR: ArgumentError: write failed, IOStream is not writeable\\n[...]\\n\\njulia> close(io)\\n\\njulia> io = open(\\\"myfile.txt\\\", \\\"a\\\");\\n\\njulia> write(io, \\\"This stream is not read only\\\")\\n28\\n\\njulia> close(io)\\n\\njulia> rm(\\\"myfile.txt\\\")\\n\\n\\n\\n\\n\\nopen(f::Function, args...; kwargs....)\\n\\nApply the function f to the result of open(args...; kwargs...) and close the resulting file descriptor upon completion.\\n\\nExamples\\n\\njulia> open(\\\"myfile.txt\\\", \\\"w\\\") do io\\n           write(io, \\\"Hello world!\\\")\\n       end;\\n\\njulia> open(f->read(f, String), \\\"myfile.txt\\\")\\n\\\"Hello world!\\\"\\n\\njulia> rm(\\\"myfile.txt\\\")\\n\\n\\n\\n\\n\\nopen(command, stdio=devnull; write::Bool = false, read::Bool = !write)\\n\\nStart running command asynchronously, and return a tuple (stream,process).  If read is true, then stream reads from the process\\'s standard output and stdio optionally specifies the process\\'s standard input stream.  If write is true, then stream writes to the process\\'s standard input and stdio optionally specifies the process\\'s standard output stream.\\n\\n\\n\\n\\n\\nopen(f::Function, command, mode::AbstractString=\\\"r\\\", stdio=devnull)\\n\\nSimilar to open(command, mode, stdio), but calls f(stream) on the resulting process stream, then closes the input stream and waits for the process to complete. Returns the value returned by f.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.IOBuffer\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.IOBuffer\",\n    \"category\": \"type\",\n    \"text\": \"IOBuffer([data::AbstractVector{UInt8}]; keywords...) -> IOBuffer\\n\\nCreate an in-memory I/O stream, which may optionally operate on a pre-existing array.\\n\\nIt may take optional keyword arguments:\\n\\nread, write, append: restricts operations to the buffer; see open for details.\\ntruncate: truncates the buffer size to zero length.\\nmaxsize: specifies a size beyond which the buffer may not be grown.\\nsizehint: suggests a capacity of the buffer (data must implement sizehint!(data, size)).\\n\\nWhen data is not given, the buffer will be both readable and writable by default.\\n\\nExamples\\n\\njulia> io = IOBuffer();\\n\\njulia> write(io, \\\"JuliaLang is a GitHub organization.\\\", \\\" It has many members.\\\")\\n56\\n\\njulia> String(take!(io))\\n\\\"JuliaLang is a GitHub organization. It has many members.\\\"\\n\\njulia> io = IOBuffer(b\\\"JuliaLang is a GitHub organization.\\\")\\nIOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=35, maxsize=Inf, ptr=1, mark=-1)\\n\\njulia> read(io, String)\\n\\\"JuliaLang is a GitHub organization.\\\"\\n\\njulia> write(io, \\\"This isn\\'t writable.\\\")\\nERROR: ArgumentError: ensureroom failed, IOBuffer is not writeable\\n\\njulia> io = IOBuffer(UInt8[], read=true, write=true, maxsize=34)\\nIOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=0, maxsize=34, ptr=1, mark=-1)\\n\\njulia> write(io, \\\"JuliaLang is a GitHub organization.\\\")\\n34\\n\\njulia> String(take!(io))\\n\\\"JuliaLang is a GitHub organization\\\"\\n\\njulia> length(read(IOBuffer(b\\\"data\\\", read=true, truncate=false)))\\n4\\n\\njulia> length(read(IOBuffer(b\\\"data\\\", read=true, truncate=true)))\\n0\\n\\n\\n\\n\\n\\nIOBuffer(string::String)\\n\\nCreate a read-only IOBuffer on the data underlying the given string.\\n\\nExamples\\n\\njulia> io = IOBuffer(\\\"Haho\\\");\\n\\njulia> String(take!(io))\\n\\\"Haho\\\"\\n\\njulia> String(take!(io))\\n\\\"Haho\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.take!-Tuple{Base.GenericIOBuffer}\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.take!\",\n    \"category\": \"method\",\n    \"text\": \"take!(b::IOBuffer)\\n\\nObtain the contents of an IOBuffer as an array, without copying. Afterwards, the IOBuffer is reset to its initial state.\\n\\nExamples\\n\\njulia> io = IOBuffer();\\n\\njulia> write(io, \\\"JuliaLang is a GitHub organization.\\\", \\\" It has many members.\\\")\\n56\\n\\njulia> String(take!(io))\\n\\\"JuliaLang is a GitHub organization. It has many members.\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.fdio\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.fdio\",\n    \"category\": \"function\",\n    \"text\": \"fdio([name::AbstractString, ]fd::Integer[, own::Bool=false]) -> IOStream\\n\\nCreate an IOStream object from an integer file descriptor. If own is true, closing this object will close the underlying descriptor. By default, an IOStream is closed when it is garbage collected. name allows you to associate the descriptor with a named file.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.flush\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.flush\",\n    \"category\": \"function\",\n    \"text\": \"flush(stream)\\n\\nCommit all currently buffered writes to the given stream.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.close\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.close\",\n    \"category\": \"function\",\n    \"text\": \"close(stream)\\n\\nClose an I/O stream. Performs a flush first.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.write\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.write\",\n    \"category\": \"function\",\n    \"text\": \"write(io::IO, x)\\nwrite(filename::AbstractString, x)\\n\\nWrite the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream.   See also print to write a text representation (with an encoding that may depend upon io).\\n\\nYou can write multiple values with the same write call. i.e. the following are equivalent:\\n\\nwrite(io, x, y...)\\nwrite(io, x) + write(io, y...)\\n\\nExamples\\n\\njulia> io = IOBuffer();\\n\\njulia> write(io, \\\"JuliaLang is a GitHub organization.\\\", \\\" It has many members.\\\")\\n56\\n\\njulia> String(take!(io))\\n\\\"JuliaLang is a GitHub organization. It has many members.\\\"\\n\\njulia> write(io, \\\"Sometimes those members\\\") + write(io, \\\" write documentation.\\\")\\n44\\n\\njulia> String(take!(io))\\n\\\"Sometimes those members write documentation.\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.read\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.read\",\n    \"category\": \"function\",\n    \"text\": \"read(io::IO, T)\\n\\nRead a single value of type T from io, in canonical binary representation.\\n\\nread(io::IO, String)\\n\\nRead the entirety of io, as a String.\\n\\nExamples\\n\\njulia> io = IOBuffer(\\\"JuliaLang is a GitHub organization\\\");\\n\\njulia> read(io, Char)\\n\\'J\\': ASCII/Unicode U+004a (category Lu: Letter, uppercase)\\n\\njulia> io = IOBuffer(\\\"JuliaLang is a GitHub organization\\\");\\n\\njulia> read(io, String)\\n\\\"JuliaLang is a GitHub organization\\\"\\n\\n\\n\\n\\n\\nread(filename::AbstractString, args...)\\n\\nOpen a file and read its contents. args is passed to read: this is equivalent to open(io->read(io, args...), filename).\\n\\nread(filename::AbstractString, String)\\n\\nRead the entire contents of a file as a string.\\n\\n\\n\\n\\n\\nread(s::IO, nb=typemax(Int))\\n\\nRead at most nb bytes from s, returning a Vector{UInt8} of the bytes read.\\n\\n\\n\\n\\n\\nread(s::IOStream, nb::Integer; all=true)\\n\\nRead at most nb bytes from s, returning a Vector{UInt8} of the bytes read.\\n\\nIf all is true (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If all is false, at most one read call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the all option.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.read!\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.read!\",\n    \"category\": \"function\",\n    \"text\": \"read!(stream::IO, array::Union{Array, BitArray})\\nread!(filename::AbstractString, array::Union{Array, BitArray})\\n\\nRead binary data from an I/O stream or file, filling in array.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.readbytes!\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.readbytes!\",\n    \"category\": \"function\",\n    \"text\": \"readbytes!(stream::IO, b::AbstractVector{UInt8}, nb=length(b))\\n\\nRead at most nb bytes from stream into b, returning the number of bytes read. The size of b will be increased if needed (i.e. if nb is greater than length(b) and enough bytes could be read), but it will never be decreased.\\n\\n\\n\\n\\n\\nreadbytes!(stream::IOStream, b::AbstractVector{UInt8}, nb=length(b); all::Bool=true)\\n\\nRead at most nb bytes from stream into b, returning the number of bytes read. The size of b will be increased if needed (i.e. if nb is greater than length(b) and enough bytes could be read), but it will never be decreased.\\n\\nSee read for a description of the all option.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.unsafe_read\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.unsafe_read\",\n    \"category\": \"function\",\n    \"text\": \"unsafe_read(io::IO, ref, nbytes::UInt)\\n\\nCopy nbytes from the IO stream object into ref (converted to a pointer).\\n\\nIt is recommended that subtypes T<:IO override the following method signature to provide more efficient implementations: unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.unsafe_write\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.unsafe_write\",\n    \"category\": \"function\",\n    \"text\": \"unsafe_write(io::IO, ref, nbytes::UInt)\\n\\nCopy nbytes from ref (converted to a pointer) into the IO object.\\n\\nIt is recommended that subtypes T<:IO override the following method signature to provide more efficient implementations: unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.position\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.position\",\n    \"category\": \"function\",\n    \"text\": \"position(s)\\n\\nGet the current position of a stream.\\n\\nExamples\\n\\njulia> io = IOBuffer(\\\"JuliaLang is a GitHub organization.\\\");\\n\\njulia> seek(io, 5);\\n\\njulia> position(io)\\n5\\n\\njulia> skip(io, 10);\\n\\njulia> position(io)\\n15\\n\\njulia> seekend(io);\\n\\njulia> position(io)\\n35\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.seek\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.seek\",\n    \"category\": \"function\",\n    \"text\": \"seek(s, pos)\\n\\nSeek a stream to the given position.\\n\\nExamples\\n\\njulia> io = IOBuffer(\\\"JuliaLang is a GitHub organization.\\\");\\n\\njulia> seek(io, 5);\\n\\njulia> read(io, Char)\\n\\'L\\': ASCII/Unicode U+004c (category Lu: Letter, uppercase)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.seekstart\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.seekstart\",\n    \"category\": \"function\",\n    \"text\": \"seekstart(s)\\n\\nSeek a stream to its beginning.\\n\\nExamples\\n\\njulia> io = IOBuffer(\\\"JuliaLang is a GitHub organization.\\\");\\n\\njulia> seek(io, 5);\\n\\njulia> read(io, Char)\\n\\'L\\': ASCII/Unicode U+004c (category Lu: Letter, uppercase)\\n\\njulia> seekstart(io);\\n\\njulia> read(io, Char)\\n\\'J\\': ASCII/Unicode U+004a (category Lu: Letter, uppercase)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.seekend\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.seekend\",\n    \"category\": \"function\",\n    \"text\": \"seekend(s)\\n\\nSeek a stream to its end.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.skip\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.skip\",\n    \"category\": \"function\",\n    \"text\": \"skip(s, offset)\\n\\nSeek a stream relative to the current position.\\n\\nExamples\\n\\njulia> io = IOBuffer(\\\"JuliaLang is a GitHub organization.\\\");\\n\\njulia> seek(io, 5);\\n\\njulia> skip(io, 10);\\n\\njulia> read(io, Char)\\n\\'G\\': ASCII/Unicode U+0047 (category Lu: Letter, uppercase)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.mark\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.mark\",\n    \"category\": \"function\",\n    \"text\": \"mark(s)\\n\\nAdd a mark at the current position of stream s. Return the marked position.\\n\\nSee also unmark, reset, ismarked.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.unmark\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.unmark\",\n    \"category\": \"function\",\n    \"text\": \"unmark(s)\\n\\nRemove a mark from stream s. Return true if the stream was marked, false otherwise.\\n\\nSee also mark, reset, ismarked.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.reset\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.reset\",\n    \"category\": \"function\",\n    \"text\": \"reset(s)\\n\\nReset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked.\\n\\nSee also mark, unmark, ismarked.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.ismarked\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.ismarked\",\n    \"category\": \"function\",\n    \"text\": \"ismarked(s)\\n\\nReturn true if stream s is marked.\\n\\nSee also mark, unmark, reset.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.eof\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.eof\",\n    \"category\": \"function\",\n    \"text\": \"eof(stream) -> Bool\\n\\nTest whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.isreadonly\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.isreadonly\",\n    \"category\": \"function\",\n    \"text\": \"isreadonly(io) -> Bool\\n\\nDetermine whether a stream is read-only.\\n\\nExamples\\n\\njulia> io = IOBuffer(\\\"JuliaLang is a GitHub organization\\\");\\n\\njulia> isreadonly(io)\\ntrue\\n\\njulia> io = IOBuffer();\\n\\njulia> isreadonly(io)\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.iswritable\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.iswritable\",\n    \"category\": \"function\",\n    \"text\": \"iswritable(io) -> Bool\\n\\nReturn true if the specified IO object is writable (if that can be determined).\\n\\nExamples\\n\\njulia> open(\\\"myfile.txt\\\", \\\"w\\\") do io\\n           print(io, \\\"Hello world!\\\");\\n           iswritable(io)\\n       end\\ntrue\\n\\njulia> open(\\\"myfile.txt\\\", \\\"r\\\") do io\\n           iswritable(io)\\n       end\\nfalse\\n\\njulia> rm(\\\"myfile.txt\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.isreadable\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.isreadable\",\n    \"category\": \"function\",\n    \"text\": \"isreadable(io) -> Bool\\n\\nReturn true if the specified IO object is readable (if that can be determined).\\n\\nExamples\\n\\njulia> open(\\\"myfile.txt\\\", \\\"w\\\") do io\\n           print(io, \\\"Hello world!\\\");\\n           isreadable(io)\\n       end\\nfalse\\n\\njulia> open(\\\"myfile.txt\\\", \\\"r\\\") do io\\n           isreadable(io)\\n       end\\ntrue\\n\\njulia> rm(\\\"myfile.txt\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.isopen\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.isopen\",\n    \"category\": \"function\",\n    \"text\": \"isopen(object) -> Bool\\n\\nDetermine whether an object - such as a stream or timer \u2013 is not yet closed. Once an object is closed, it will never produce a new event. However, since a closed stream may still have data to read in its buffer, use eof to check for the ability to read data. Use the FileWatching package to be notified when a stream might be writable or readable.\\n\\nExamples\\n\\njulia> io = open(\\\"my_file.txt\\\", \\\"w+\\\");\\n\\njulia> isopen(io)\\ntrue\\n\\njulia> close(io)\\n\\njulia> isopen(io)\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.Grisu.print_shortest\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.Grisu.print_shortest\",\n    \"category\": \"function\",\n    \"text\": \"print_shortest(io::IO, x)\\n\\nPrint the shortest possible representation, with the minimum number of consecutive non-zero digits, of number x, ensuring that it would parse to the exact same number.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.fd\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.fd\",\n    \"category\": \"function\",\n    \"text\": \"fd(stream)\\n\\nReturn the file descriptor backing the stream or file. Note that this function only applies to synchronous File\\'s and IOStream\\'s not to any of the asynchronous streams.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.redirect_stdout\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.redirect_stdout\",\n    \"category\": \"function\",\n    \"text\": \"redirect_stdout([stream]) -> (rd, wr)\\n\\nCreate a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.\\n\\nIf called with the optional stream argument, then returns stream itself.\\n\\nnote: Note\\nstream must be a TTY, a Pipe, or a socket.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.redirect_stdout-Tuple{Function,Any}\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.redirect_stdout\",\n    \"category\": \"method\",\n    \"text\": \"redirect_stdout(f::Function, stream)\\n\\nRun the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.\\n\\nnote: Note\\nstream must be a TTY, a Pipe, or a socket.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.redirect_stderr\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.redirect_stderr\",\n    \"category\": \"function\",\n    \"text\": \"redirect_stderr([stream]) -> (rd, wr)\\n\\nLike redirect_stdout, but for stderr.\\n\\nnote: Note\\nstream must be a TTY, a Pipe, or a socket.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.redirect_stderr-Tuple{Function,Any}\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.redirect_stderr\",\n    \"category\": \"method\",\n    \"text\": \"redirect_stderr(f::Function, stream)\\n\\nRun the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.\\n\\nnote: Note\\nstream must be a TTY, a Pipe, or a socket.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.redirect_stdin\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.redirect_stdin\",\n    \"category\": \"function\",\n    \"text\": \"redirect_stdin([stream]) -> (rd, wr)\\n\\nLike redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.\\n\\nnote: Note\\nstream must be a TTY, a Pipe, or a socket.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.redirect_stdin-Tuple{Function,Any}\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.redirect_stdin\",\n    \"category\": \"method\",\n    \"text\": \"redirect_stdin(f::Function, stream)\\n\\nRun the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.\\n\\nnote: Note\\nstream must be a TTY, a Pipe, or a socket.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.readchomp\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.readchomp\",\n    \"category\": \"function\",\n    \"text\": \"readchomp(x)\\n\\nRead the entirety of x as a string and remove a single trailing newline if there is one. Equivalent to chomp(read(x, String)).\\n\\nExamples\\n\\njulia> open(\\\"my_file.txt\\\", \\\"w\\\") do io\\n           write(io, \\\"JuliaLang is a GitHub organization.\\\\nIt has many members.\\\\n\\\");\\n       end;\\n\\njulia> readchomp(\\\"my_file.txt\\\")\\n\\\"JuliaLang is a GitHub organization.\\\\nIt has many members.\\\"\\n\\njulia> rm(\\\"my_file.txt\\\");\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.truncate\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.truncate\",\n    \"category\": \"function\",\n    \"text\": \"truncate(file, n)\\n\\nResize the file or buffer given by the first argument to exactly n bytes, filling previously unallocated space with \\'\\\\0\\' if the file or buffer is grown.\\n\\nExamples\\n\\njulia> io = IOBuffer();\\n\\njulia> write(io, \\\"JuliaLang is a GitHub organization.\\\")\\n35\\n\\njulia> truncate(io, 15)\\nIOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=15, maxsize=Inf, ptr=16, mark=-1)\\n\\njulia> String(take!(io))\\n\\\"JuliaLang is a \\\"\\n\\njulia> io = IOBuffer();\\n\\njulia> write(io, \\\"JuliaLang is a GitHub organization.\\\");\\n\\njulia> truncate(io, 40);\\n\\njulia> String(take!(io))\\n\\\"JuliaLang is a GitHub organization.\\\\0\\\\0\\\\0\\\\0\\\\0\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.skipchars\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.skipchars\",\n    \"category\": \"function\",\n    \"text\": \"skipchars(predicate, io::IO; linecomment=nothing)\\n\\nAdvance the stream io such that the next-read character will be the first remaining for which predicate returns false. If the keyword argument linecomment is specified, all characters from that character until the start of the next line are ignored.\\n\\nExamples\\n\\njulia> buf = IOBuffer(\\\"    text\\\")\\nIOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=8, maxsize=Inf, ptr=1, mark=-1)\\n\\njulia> skipchars(isspace, buf)\\nIOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=8, maxsize=Inf, ptr=5, mark=-1)\\n\\njulia> String(readavailable(buf))\\n\\\"text\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.countlines\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.countlines\",\n    \"category\": \"function\",\n    \"text\": \"countlines(io::IO; eol::AbstractChar = \\'\\\\n\\')\\n\\nRead io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than \\'\\\\n\\' are supported by passing them as the second argument.  The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.\\n\\nExamples\\n\\njulia> io = IOBuffer(\\\"JuliaLang is a GitHub organization.\\\\n\\\");\\n\\njulia> countlines(io)\\n1\\n\\njulia> io = IOBuffer(\\\"JuliaLang is a GitHub organization.\\\");\\n\\njulia> countlines(io)\\n1\\n\\njulia> countlines(io, eol = \\'.\\')\\n0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.PipeBuffer\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.PipeBuffer\",\n    \"category\": \"function\",\n    \"text\": \"PipeBuffer(data::Vector{UInt8}=UInt8[]; maxsize::Integer = typemax(Int))\\n\\nAn IOBuffer that allows reading and performs writes by appending. Seeking and truncating are not supported. See IOBuffer for the available constructors. If data is given, creates a PipeBuffer to operate on a data vector, optionally specifying a size beyond which the underlying Array may not be grown.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.readavailable\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.readavailable\",\n    \"category\": \"function\",\n    \"text\": \"readavailable(stream)\\n\\nRead all available data on the stream, blocking the task only if no data is available. The result is a Vector{UInt8,1}.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.IOContext\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.IOContext\",\n    \"category\": \"type\",\n    \"text\": \"IOContext\\n\\nIOContext provides a mechanism for passing output configuration settings among show methods.\\n\\nIn short, it is an immutable dictionary that is a subclass of IO. It supports standard dictionary operations such as getindex, and can also be used as an I/O stream.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.IOContext-Tuple{IO,Pair}\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.IOContext\",\n    \"category\": \"method\",\n    \"text\": \"IOContext(io::IO, KV::Pair...)\\n\\nCreate an IOContext that wraps a given stream, adding the specified key=>value pairs to the properties of that stream (note that io can itself be an IOContext).\\n\\nuse (key => value) in io to see if this particular combination is in the properties set\\nuse get(io, key, default) to retrieve the most recent value for a particular key\\n\\nThe following properties are in common use:\\n\\n:compact: Boolean specifying that small values should be printed more compactly, e.g. that numbers should be printed with fewer digits. This is set when printing array elements.\\n:limit: Boolean specifying that containers should be truncated, e.g. showing \u2026 in place of most elements.\\n:displaysize: A Tuple{Int,Int} giving the size in rows and columns to use for text output. This can be used to override the display size for called functions, but to get the size of the screen use the displaysize function.\\n:typeinfo: a Type characterizing the information already printed concerning the type of the object about to be displayed. This is mainly useful when displaying a collection of objects of the same type, so that redundant type information can be avoided (e.g. [Float16(0)] can be shown as \\\"Float16[0.0]\\\" instead of \\\"Float16[Float16(0.0)]\\\" : while displaying the elements of the array, the :typeinfo property will be set to Float16).\\n:color: Boolean specifying whether ANSI color/escape codes are supported/expected. By default, this is determined by whether io is a compatible terminal and by any --color command-line flag when julia was launched.\\n\\nExamples\\n\\njulia> io = IOBuffer();\\n\\njulia> printstyled(IOContext(io, :color => true), \\\"string\\\", color=:red)\\n\\njulia> String(take!(io))\\n\\\"\\\\e[31mstring\\\\e[39m\\\"\\n\\njulia> printstyled(io, \\\"string\\\", color=:red)\\n\\njulia> String(take!(io))\\n\\\"string\\\"\\n\\njulia> print(IOContext(stdout, :compact => false), 1.12341234)\\n1.12341234\\njulia> print(IOContext(stdout, :compact => true), 1.12341234)\\n1.12341\\n\\njulia> function f(io::IO)\\n           if get(io, :short, false)\\n               print(io, \\\"short\\\")\\n           else\\n               print(io, \\\"loooooong\\\")\\n           end\\n       end\\nf (generic function with 1 method)\\n\\njulia> f(stdout)\\nloooooong\\njulia> f(IOContext(stdout, :short => true))\\nshort\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.IOContext-Tuple{IO,IOContext}\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.IOContext\",\n    \"category\": \"method\",\n    \"text\": \"IOContext(io::IO, context::IOContext)\\n\\nCreate an IOContext that wraps an alternate IO but inherits the properties of context.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#General-I/O-1\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"General I/O\",\n    \"category\": \"section\",\n    \"text\": \"Base.stdout\\nBase.stderr\\nBase.stdin\\nBase.open\\nBase.IOBuffer\\nBase.take!(::Base.GenericIOBuffer)\\nBase.fdio\\nBase.flush\\nBase.close\\nBase.write\\nBase.read\\nBase.read!\\nBase.readbytes!\\nBase.unsafe_read\\nBase.unsafe_write\\nBase.position\\nBase.seek\\nBase.seekstart\\nBase.seekend\\nBase.skip\\nBase.mark\\nBase.unmark\\nBase.reset\\nBase.ismarked\\nBase.eof\\nBase.isreadonly\\nBase.iswritable\\nBase.isreadable\\nBase.isopen\\nBase.Grisu.print_shortest\\nBase.fd\\nBase.redirect_stdout\\nBase.redirect_stdout(::Function, ::Any)\\nBase.redirect_stderr\\nBase.redirect_stderr(::Function, ::Any)\\nBase.redirect_stdin\\nBase.redirect_stdin(::Function, ::Any)\\nBase.readchomp\\nBase.truncate\\nBase.skipchars\\nBase.countlines\\nBase.PipeBuffer\\nBase.readavailable\\nBase.IOContext\\nBase.IOContext(::IO, ::Pair)\\nBase.IOContext(::IO, ::IOContext)\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.show-Tuple{Any}\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.show\",\n    \"category\": \"method\",\n    \"text\": \"show(x)\\n\\nWrite an informative text representation of a value to the current output stream. New types should overload show(io, x) where the first argument is a stream. The representation used by show generally includes Julia-specific formatting and type information.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.summary\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.summary\",\n    \"category\": \"function\",\n    \"text\": \"summary(io::IO, x)\\nstr = summary(x)\\n\\nPrint to a stream io, or return a string str, giving a brief description of a value. By default returns string(typeof(x)), e.g. Int64.\\n\\nFor arrays, returns a string of size and type info, e.g. 10-element Array{Int64,1}.\\n\\nExamples\\n\\njulia> summary(1)\\n\\\"Int64\\\"\\n\\njulia> summary(zeros(2))\\n\\\"2-element Array{Float64,1}\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.print\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.print\",\n    \"category\": \"function\",\n    \"text\": \"print([io::IO], xs...)\\n\\nWrite to io (or to the default output stream stdout if io is not given) a canonical (un-decorated) text representation of values xs if there is one, otherwise call show. The representation used by print includes minimal formatting and tries to avoid Julia-specific details.\\n\\nPrinting nothing is deprecated and will throw an error in the future.\\n\\nExamples\\n\\njulia> print(\\\"Hello World!\\\")\\nHello World!\\njulia> io = IOBuffer();\\n\\njulia> print(io, \\\"Hello\\\", \\' \\', :World!)\\n\\njulia> String(take!(io))\\n\\\"Hello World!\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.println\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.println\",\n    \"category\": \"function\",\n    \"text\": \"println([io::IO], xs...)\\n\\nPrint (using print) xs followed by a newline. If io is not supplied, prints to stdout.\\n\\nExamples\\n\\njulia> println(\\\"Hello, world\\\")\\nHello, world\\n\\njulia> io = IOBuffer();\\n\\njulia> println(io, \\\"Hello, world\\\")\\n\\njulia> String(take!(io))\\n\\\"Hello, world\\\\n\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.printstyled\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.printstyled\",\n    \"category\": \"function\",\n    \"text\": \"printstyled([io], xs...; bold::Bool=false, color::Union{Symbol,Int}=:normal)\\n\\nPrint xs in a color specified as a symbol or integer, optionally in bold.\\n\\ncolor may take any of the values :normal, :default, :bold, :black, :blink, :blue, :cyan, :green, :hidden, :light_black, :light_blue, :light_cyan, :light_green, :light_magenta, :light_red, :light_yellow, :magenta, :nothing, :red, :reverse, :underline, :white, or  :yellow or an integer between 0 and 255 inclusive. Note that not all terminals support 256 colors. If the keyword bold is given as true, the result will be printed in bold.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.sprint\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.sprint\",\n    \"category\": \"function\",\n    \"text\": \"sprint(f::Function, args...; context=nothing, sizehint=0)\\n\\nCall the given function with an I/O stream and the supplied extra arguments. Everything written to this I/O stream is returned as a string. context can be either an IOContext whose properties will be used, or a Pair specifying a property and its value. sizehint suggests the capacity of the buffer (in bytes).\\n\\nThe optional keyword argument context can be set to :key=>value pair or an IO or IOContext object whose attributes are used for the I/O stream passed to f.  The optional sizehint is a suggersted (in bytes) to allocate for the buffer used to write the string.\\n\\nExamples\\n\\njulia> sprint(show, 66.66666; context=:compact => true)\\n\\\"66.6667\\\"\\n\\njulia> sprint(showerror, BoundsError([1], 100))\\n\\\"BoundsError: attempt to access 1-element Array{Int64,1} at index [100]\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.showerror\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.showerror\",\n    \"category\": \"function\",\n    \"text\": \"showerror(io, e)\\n\\nShow a descriptive representation of an exception object e. This method is used to display the exception after a call to throw.\\n\\nExamples\\n\\njulia> struct MyException <: Exception\\n           msg::AbstractString\\n       end\\n\\njulia> function Base.showerror(io::IO, err::MyException)\\n           print(io, \\\"MyException: \\\")\\n           print(io, err.msg)\\n       end\\n\\njulia> err = MyException(\\\"test exception\\\")\\nMyException(\\\"test exception\\\")\\n\\njulia> sprint(showerror, err)\\n\\\"MyException: test exception\\\"\\n\\njulia> throw(MyException(\\\"test exception\\\"))\\nERROR: MyException: test exception\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.dump\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.dump\",\n    \"category\": \"function\",\n    \"text\": \"dump(x; maxdepth=8)\\n\\nShow every part of the representation of a value. The depth of the output is truncated at maxdepth.\\n\\nExamples\\n\\njulia> struct MyStruct\\n           x\\n           y\\n       end\\n\\njulia> x = MyStruct(1, (2,3));\\n\\njulia> dump(x)\\nMyStruct\\n  x: Int64 1\\n  y: Tuple{Int64,Int64}\\n    1: Int64 2\\n    2: Int64 3\\n\\njulia> dump(x; maxdepth = 1)\\nMyStruct\\n  x: Int64 1\\n  y: Tuple{Int64,Int64}\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.Meta.@dump\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.Meta.@dump\",\n    \"category\": \"macro\",\n    \"text\": \"@dump expr\\n\\nShow every part of the representation of the given expression. Equivalent to dump(:(expr)).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.readline\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.readline\",\n    \"category\": \"function\",\n    \"text\": \"readline(io::IO=stdin; keep::Bool=false)\\nreadline(filename::AbstractString; keep::Bool=false)\\n\\nRead a single line of text from the given I/O stream or file (defaults to stdin). When reading from a file, the text is assumed to be encoded in UTF-8. Lines in the input end with \\'\\\\n\\' or \\\"\\\\r\\\\n\\\" or the end of an input stream. When keep is false (as it is by default), these trailing newline characters are removed from the line before it is returned. When keep is true, they are returned as part of the line.\\n\\nExamples\\n\\njulia> open(\\\"my_file.txt\\\", \\\"w\\\") do io\\n           write(io, \\\"JuliaLang is a GitHub organization.\\\\nIt has many members.\\\\n\\\");\\n       end\\n57\\n\\njulia> readline(\\\"my_file.txt\\\")\\n\\\"JuliaLang is a GitHub organization.\\\"\\n\\njulia> readline(\\\"my_file.txt\\\", keep=true)\\n\\\"JuliaLang is a GitHub organization.\\\\n\\\"\\n\\njulia> rm(\\\"my_file.txt\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.readuntil\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.readuntil\",\n    \"category\": \"function\",\n    \"text\": \"readuntil(stream::IO, delim; keep::Bool = false)\\nreaduntil(filename::AbstractString, delim; keep::Bool = false)\\n\\nRead a string from an I/O stream or a file, up to the given delimiter. The delimiter can be a UInt8, AbstractChar, string, or vector. Keyword argument keep controls whether the delimiter is included in the result. The text is assumed to be encoded in UTF-8.\\n\\nExamples\\n\\njulia> open(\\\"my_file.txt\\\", \\\"w\\\") do io\\n           write(io, \\\"JuliaLang is a GitHub organization.\\\\nIt has many members.\\\\n\\\");\\n       end\\n57\\n\\njulia> readuntil(\\\"my_file.txt\\\", \\'L\\')\\n\\\"Julia\\\"\\n\\njulia> readuntil(\\\"my_file.txt\\\", \\'.\\', keep = true)\\n\\\"JuliaLang is a GitHub organization.\\\"\\n\\njulia> rm(\\\"my_file.txt\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.readlines\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.readlines\",\n    \"category\": \"function\",\n    \"text\": \"readlines(io::IO=stdin; keep::Bool=false)\\nreadlines(filename::AbstractString; keep::Bool=false)\\n\\nRead all lines of an I/O stream or a file as a vector of strings. Behavior is equivalent to saving the result of reading readline repeatedly with the same arguments and saving the resulting lines as a vector of strings.\\n\\nExamples\\n\\njulia> open(\\\"my_file.txt\\\", \\\"w\\\") do io\\n           write(io, \\\"JuliaLang is a GitHub organization.\\\\nIt has many members.\\\\n\\\");\\n       end\\n57\\n\\njulia> readlines(\\\"my_file.txt\\\")\\n2-element Array{String,1}:\\n \\\"JuliaLang is a GitHub organization.\\\"\\n \\\"It has many members.\\\"\\n\\njulia> readlines(\\\"my_file.txt\\\", keep=true)\\n2-element Array{String,1}:\\n \\\"JuliaLang is a GitHub organization.\\\\n\\\"\\n \\\"It has many members.\\\\n\\\"\\n\\njulia> rm(\\\"my_file.txt\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.eachline\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.eachline\",\n    \"category\": \"function\",\n    \"text\": \"eachline(io::IO=stdin; keep::Bool=false)\\neachline(filename::AbstractString; keep::Bool=false)\\n\\nCreate an iterable EachLine object that will yield each line from an I/O stream or a file. Iteration calls readline on the stream argument repeatedly with keep passed through, determining whether trailing end-of-line characters are retained. When called with a file name, the file is opened once at the beginning of iteration and closed at the end. If iteration is interrupted, the file will be closed when the EachLine object is garbage collected.\\n\\nExamples\\n\\njulia> open(\\\"my_file.txt\\\", \\\"w\\\") do io\\n           write(io, \\\"JuliaLang is a GitHub organization.\\\\n It has many members.\\\\n\\\");\\n       end;\\n\\njulia> for line in eachline(\\\"my_file.txt\\\")\\n           print(line)\\n       end\\nJuliaLang is a GitHub organization. It has many members.\\n\\njulia> rm(\\\"my_file.txt\\\");\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.displaysize\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.displaysize\",\n    \"category\": \"function\",\n    \"text\": \"displaysize([io::IO]) -> (lines, columns)\\n\\nReturn the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.\\n\\nExamples\\n\\njulia> withenv(\\\"LINES\\\" => 30, \\\"COLUMNS\\\" => 100) do\\n           displaysize()\\n       end\\n(30, 100)\\n\\nTo get your TTY size,\\n\\njulia> displaysize(stdout)\\n(34, 147)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Text-I/O-1\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Text I/O\",\n    \"category\": \"section\",\n    \"text\": \"Base.show(::Any)\\nBase.summary\\nBase.print\\nBase.println\\nBase.printstyled\\nBase.sprint\\nBase.showerror\\nBase.dump\\nMeta.@dump\\nBase.readline\\nBase.readuntil\\nBase.readlines\\nBase.eachline\\nBase.displaysize\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.Multimedia.display\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.Multimedia.display\",\n    \"category\": \"function\",\n    \"text\": \"display(x)\\ndisplay(d::AbstractDisplay, x)\\ndisplay(mime, x)\\ndisplay(d::AbstractDisplay, mime, x)\\n\\nAbstractDisplay x using the topmost applicable display in the display stack, typically using the richest supported multimedia output for x, with plain-text stdout output as a fallback. The display(d, x) variant attempts to display x on the given display d only, throwing a MethodError if d cannot display objects of this type.\\n\\nIn general, you cannot assume that display output goes to stdout (unlike print(x) or show(x)).  For example, display(x) may open up a separate window with an image. display(x) means \\\"show x in the best way you can for the current output device(s).\\\" If you want REPL-like text output that is guaranteed to go to stdout, use show(stdout, \\\"text/plain\\\", x) instead.\\n\\nThere are also two variants with a mime argument (a MIME type string, such as \\\"image/png\\\"), which attempt to display x using the requested MIME type only, throwing a MethodError if this type is not supported by either the display(s) or by x. With these variants, one can also supply the \\\"raw\\\" data in the requested MIME type by passing x::AbstractString (for MIME types with text-based storage, such as text/html or application/postscript) or x::Vector{UInt8} (for binary MIME types).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.Multimedia.redisplay\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.Multimedia.redisplay\",\n    \"category\": \"function\",\n    \"text\": \"redisplay(x)\\nredisplay(d::AbstractDisplay, x)\\nredisplay(mime, x)\\nredisplay(d::AbstractDisplay, mime, x)\\n\\nBy default, the redisplay functions simply call display. However, some display backends may override redisplay to modify an existing display of x (if any). Using redisplay is also a hint to the backend that x may be redisplayed several times, and the backend may choose to defer the display until (for example) the next interactive prompt.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.Multimedia.displayable\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.Multimedia.displayable\",\n    \"category\": \"function\",\n    \"text\": \"displayable(mime) -> Bool\\ndisplayable(d::AbstractDisplay, mime) -> Bool\\n\\nReturns a boolean value indicating whether the given mime type (string) is displayable by any of the displays in the current display stack, or specifically by the display d in the second variant.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.show-Tuple{Any,Any,Any}\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.show\",\n    \"category\": \"method\",\n    \"text\": \"show(io, mime, x)\\n\\nThe display functions ultimately call show in order to write an object x as a given mime type to a given I/O stream io (usually a memory buffer), if possible. In order to provide a rich multimedia representation of a user-defined type T, it is only necessary to define a new show method for T, via: show(io, ::MIME\\\"mime\\\", x::T) = ..., where mime is a MIME-type string and the function body calls write (or similar) to write that representation of x to io. (Note that the MIME\\\"\\\" notation only supports literal strings; to construct MIME types in a more flexible manner use MIME{Symbol(\\\"\\\")}.)\\n\\nFor example, if you define a MyImage type and know how to write it to a PNG file, you could define a function show(io, ::MIME\\\"image/png\\\", x::MyImage) = ... to allow your images to be displayed on any PNG-capable AbstractDisplay (such as IJulia). As usual, be sure to import Base.show in order to add new methods to the built-in Julia function show.\\n\\nThe default MIME type is MIME\\\"text/plain\\\". There is a fallback definition for text/plain output that calls show with 2 arguments. Therefore, this case should be handled by defining a 2-argument show(io::IO, x::MyType) method.\\n\\nTechnically, the MIME\\\"mime\\\" macro defines a singleton type for the given mime string, which allows us to exploit Julia\\'s dispatch mechanisms in determining how to display objects of any given type.\\n\\nThe first argument to show can be an IOContext specifying output format properties. See IOContext for details.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.Multimedia.showable\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.Multimedia.showable\",\n    \"category\": \"function\",\n    \"text\": \"showable(mime, x)\\n\\nReturns a boolean value indicating whether or not the object x can be written as the given mime type.\\n\\n(By default, this is determined automatically by the existence of the corresponding show method for typeof(x).  Some types provide custom showable methods; for example, if the available MIME formats depend on the value of x.)\\n\\nExamples\\n\\njulia> showable(MIME(\\\"text/plain\\\"), rand(5))\\ntrue\\n\\njulia> showable(\\\"img/png\\\", rand(5))\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.repr-Tuple{MIME,Any}\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.repr\",\n    \"category\": \"method\",\n    \"text\": \"repr(mime, x; context=nothing)\\n\\nReturns an AbstractString or Vector{UInt8} containing the representation of x in the requested mime type, as written by show(io, mime, x) (throwing a MethodError if no appropriate show is available). An AbstractString is returned for MIME types with textual representations (such as \\\"text/html\\\" or \\\"application/postscript\\\"), whereas binary data is returned as Vector{UInt8}. (The function istextmime(mime) returns whether or not Julia treats a given mime type as text.)\\n\\nThe optional keyword argument context can be set to :key=>value pair or an IO or IOContext object whose attributes are used for the I/O stream passed to show.\\n\\nAs a special case, if x is an AbstractString (for textual MIME types) or a Vector{UInt8} (for binary MIME types), the repr function assumes that x is already in the requested mime format and simply returns x. This special case does not apply to the \\\"text/plain\\\" MIME type. This is useful so that raw data can be passed to display(m::MIME, x).\\n\\nIn particular, repr(\\\"text/plain\\\", x) is typically a \\\"pretty-printed\\\" version of x designed for human consumption.  See also repr(x) to instead return a string corresponding to show(x) that may be closer to how the value of x would be entered in Julia.\\n\\nExamples\\n\\njulia> A = [1 2; 3 4];\\n\\njulia> repr(\\\"text/plain\\\", A)\\n\\\"2\u00d72 Array{Int64,2}:\\\\n 1  2\\\\n 3  4\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.Multimedia.pushdisplay\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.Multimedia.pushdisplay\",\n    \"category\": \"function\",\n    \"text\": \"pushdisplay(d::AbstractDisplay)\\n\\nPushes a new display d on top of the global display-backend stack. Calling display(x) or display(mime, x) will display x on the topmost compatible backend in the stack (i.e., the topmost backend that does not throw a MethodError).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.Multimedia.popdisplay\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.Multimedia.popdisplay\",\n    \"category\": \"function\",\n    \"text\": \"popdisplay()\\npopdisplay(d::AbstractDisplay)\\n\\nPop the topmost backend off of the display-backend stack, or the topmost copy of d in the second variant.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.Multimedia.TextDisplay\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.Multimedia.TextDisplay\",\n    \"category\": \"type\",\n    \"text\": \"TextDisplay(io::IO)\\n\\nReturns a TextDisplay <: AbstractDisplay, which displays any object as the text/plain MIME type (by default), writing the text representation to the given I/O stream. (This is how objects are printed in the Julia REPL.)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.Multimedia.istextmime\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.Multimedia.istextmime\",\n    \"category\": \"function\",\n    \"text\": \"istextmime(m::MIME)\\n\\nDetermine whether a MIME type is text data. MIME types are assumed to be binary data except for a set of types known to be text data (possibly Unicode).\\n\\nExamples\\n\\njulia> istextmime(MIME(\\\"text/plain\\\"))\\ntrue\\n\\njulia> istextmime(MIME(\\\"img/png\\\"))\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Multimedia-I/O-1\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Multimedia I/O\",\n    \"category\": \"section\",\n    \"text\": \"Just as text output is performed by print and user-defined types can indicate their textual representation by overloading show, Julia provides a standardized mechanism for rich multimedia output (such as images, formatted text, or even audio and video), consisting of three parts:A function display(x) to request the richest available multimedia display of a Julia object x (with a plain-text fallback).\\nOverloading show allows one to indicate arbitrary multimedia representations (keyed by standard MIME types) of user-defined types.\\nMultimedia-capable display backends may be registered by subclassing a generic AbstractDisplay type and pushing them onto a stack of display backends via pushdisplay.The base Julia runtime provides only plain-text display, but richer displays may be enabled by loading external modules or by using graphical Julia environments (such as the IPython-based IJulia notebook).Base.Multimedia.display\\nBase.Multimedia.redisplay\\nBase.Multimedia.displayable\\nBase.show(::Any, ::Any, ::Any)\\nBase.Multimedia.showable\\nBase.repr(::MIME, ::Any)As mentioned above, one can also define new display backends. For example, a module that can display PNG images in a window can register this capability with Julia, so that calling display(x) on types with PNG representations will automatically display the image using the module\\'s window.In order to define a new display backend, one should first create a subtype D of the abstract class AbstractDisplay.  Then, for each MIME type (mime string) that can be displayed on D, one should define a function display(d::D, ::MIME\\\"mime\\\", x) = ... that displays x as that MIME type, usually by calling show(io, mime, x) or repr(io, mime, x). A MethodError should be thrown if x cannot be displayed as that MIME type; this is automatic if one calls show or repr. Finally, one should define a function display(d::D, x) that queries showable(mime, x) for the mime types supported by D and displays the \\\"best\\\" one; a MethodError should be thrown if no supported MIME types are found for x.  Similarly, some subtypes may wish to override redisplay(d::D, ...). (Again, one should import Base.display to add new methods to display.) The return values of these functions are up to the implementation (since in some cases it may be useful to return a display \\\"handle\\\" of some type).  The display functions for D can then be called directly, but they can also be invoked automatically from display(x) simply by pushing a new display onto the display-backend stack with:Base.Multimedia.pushdisplay\\nBase.Multimedia.popdisplay\\nBase.Multimedia.TextDisplay\\nBase.Multimedia.istextmime\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.bytesavailable\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.bytesavailable\",\n    \"category\": \"function\",\n    \"text\": \"bytesavailable(io)\\n\\nReturn the number of bytes available for reading before a read from this stream or buffer will block.\\n\\nExamples\\n\\njulia> io = IOBuffer(\\\"JuliaLang is a GitHub organization\\\");\\n\\njulia> bytesavailable(io)\\n34\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.ntoh\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.ntoh\",\n    \"category\": \"function\",\n    \"text\": \"ntoh(x)\\n\\nConvert the endianness of a value from Network byte order (big-endian) to that used by the Host.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.hton\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.hton\",\n    \"category\": \"function\",\n    \"text\": \"hton(x)\\n\\nConvert the endianness of a value from that used by the Host to Network byte order (big-endian).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.ltoh\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.ltoh\",\n    \"category\": \"function\",\n    \"text\": \"ltoh(x)\\n\\nConvert the endianness of a value from Little-endian to that used by the Host.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.htol\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.htol\",\n    \"category\": \"function\",\n    \"text\": \"htol(x)\\n\\nConvert the endianness of a value from that used by the Host to Little-endian.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Base.ENDIAN_BOM\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Base.ENDIAN_BOM\",\n    \"category\": \"constant\",\n    \"text\": \"ENDIAN_BOM\\n\\nThe 32-bit byte-order-mark indicates the native byte order of the host machine. Little-endian machines will contain the value 0x04030201. Big-endian machines will contain the value 0x01020304.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/io-network.html#Network-I/O-1\",\n    \"page\": \"I/O and Network\",\n    \"title\": \"Network I/O\",\n    \"category\": \"section\",\n    \"text\": \"Base.bytesavailable\\nBase.ntoh\\nBase.hton\\nBase.ltoh\\nBase.htol\\nBase.ENDIAN_BOM\"\n},\n\n{\n    \"location\": \"base/punctuation.html#\",\n    \"page\": \"Punctuation\",\n    \"title\": \"Punctuation\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/punctuation.html#Punctuation-1\",\n    \"page\": \"Punctuation\",\n    \"title\": \"Punctuation\",\n    \"category\": \"section\",\n    \"text\": \"Extended documentation for mathematical symbols & functions is here.symbol meaning\\n@m invoke macro m; followed by space-separated expressions\\n! prefix \\\"not\\\" (logical negation) operator\\na!( ) at the end of a function name, ! is used as a convention to indicate that a function modifies its argument(s)\\n# begin single line comment\\n#= begin multi-line comment (these are nestable)\\n=# end multi-line comment\\n$ string and expression interpolation\\n% remainder operator\\n^ exponent operator\\n& bitwise and\\n&& short-circuiting boolean and\\n| bitwise or\\n|| short-circuiting boolean or\\n\u22bb bitwise xor operator\\n* multiply, or matrix multiply\\n() the empty tuple\\n~ bitwise not operator\\n\\\\ backslash operator\\n\\' complex transpose operator A\u1d34\\na[] array indexing (calling getindex or setindex!)\\n[,] vector literal constructor (calling vect)\\n[;] vertical concatenation (calling vcat or hvcat)\\n[ \u00a0  ] with space-separated expressions, horizontal concatenation (calling hcat or hvcat)\\nT{ } parametric type instantiation\\n; statement separator\\n, separate function arguments or tuple components\\n? 3-argument conditional operator (used like: conditional ? if_true : if_false)\\n\\\"\\\" delimit string literals\\n\\'\\' delimit character literals\\n` ` delimit external process (command) specifications\\n... splice arguments into a function call or declare a varargs function\\n. access named fields in objects/modules (calling getproperty or setproperty!), also prefixes elementwise function calls (calling broadcast)\\na:b range a, a+1, a+2, ..., b\\na:s:b range a, a+s, a+2s, ..., b\\n: index an entire dimension (firstindex:lastindex), see Colon)\\n:: type annotation or typeassert, depending on context\\n:( ) quoted expression\\n:a symbol a\\n<: subtype operator\\n>: supertype operator (reverse of subtype operator)\\n=== egal comparison operator\"\n},\n\n{\n    \"location\": \"base/sort.html#\",\n    \"page\": \"Sorting and Related Functions\",\n    \"title\": \"Sorting and Related Functions\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/sort.html#Sorting-and-Related-Functions-1\",\n    \"page\": \"Sorting and Related Functions\",\n    \"title\": \"Sorting and Related Functions\",\n    \"category\": \"section\",\n    \"text\": \"Julia has an extensive, flexible API for sorting and interacting with already-sorted arrays of values. By default, Julia picks reasonable algorithms and sorts in standard ascending order:julia> sort([2,3,1])\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3You can easily sort in reverse order as well:julia> sort([2,3,1], rev=true)\\n3-element Array{Int64,1}:\\n 3\\n 2\\n 1To sort an array in-place, use the \\\"bang\\\" version of the sort function:julia> a = [2,3,1];\\n\\njulia> sort!(a);\\n\\njulia> a\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3Instead of directly sorting an array, you can compute a permutation of the array\\'s indices that puts the array into sorted order:julia> v = randn(5)\\n5-element Array{Float64,1}:\\n  0.297288\\n  0.382396\\n -0.597634\\n -0.0104452\\n -0.839027\\n\\njulia> p = sortperm(v)\\n5-element Array{Int64,1}:\\n 5\\n 3\\n 4\\n 1\\n 2\\n\\njulia> v[p]\\n5-element Array{Float64,1}:\\n -0.839027\\n -0.597634\\n -0.0104452\\n  0.297288\\n  0.382396Arrays can easily be sorted according to an arbitrary transformation of their values:julia> sort(v, by=abs)\\n5-element Array{Float64,1}:\\n -0.0104452\\n  0.297288\\n  0.382396\\n -0.597634\\n -0.839027Or in reverse order by a transformation:julia> sort(v, by=abs, rev=true)\\n5-element Array{Float64,1}:\\n -0.839027\\n -0.597634\\n  0.382396\\n  0.297288\\n -0.0104452If needed, the sorting algorithm can be chosen:julia> sort(v, alg=InsertionSort)\\n5-element Array{Float64,1}:\\n -0.839027\\n -0.597634\\n -0.0104452\\n  0.297288\\n  0.382396All the sorting and order related functions rely on a \\\"less than\\\" relation defining a total order on the values to be manipulated. The isless function is invoked by default, but the relation can be specified via the lt keyword.\"\n},\n\n{\n    \"location\": \"base/sort.html#Base.sort!\",\n    \"page\": \"Sorting and Related Functions\",\n    \"title\": \"Base.sort!\",\n    \"category\": \"function\",\n    \"text\": \"sort!(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\\n\\nSort the vector v in place. QuickSort is used by default for numeric arrays while MergeSort is used for other arrays. You can specify an algorithm to use via the alg keyword (see Sorting Algorithms for available algorithms). The by keyword lets you provide a function that will be applied to each element before comparison; the lt keyword allows providing a custom \\\"less than\\\" function; use rev=true to reverse the sorting order. These options are independent and can be used together in all possible combinations: if both by and lt are specified, the lt function is applied to the result of the by function; rev=true reverses whatever ordering specified via the by and lt keywords.\\n\\nExamples\\n\\njulia> v = [3, 1, 2]; sort!(v); v\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n\\njulia> v = [3, 1, 2]; sort!(v, rev = true); v\\n3-element Array{Int64,1}:\\n 3\\n 2\\n 1\\n\\njulia> v = [(1, \\\"c\\\"), (3, \\\"a\\\"), (2, \\\"b\\\")]; sort!(v, by = x -> x[1]); v\\n3-element Array{Tuple{Int64,String},1}:\\n (1, \\\"c\\\")\\n (2, \\\"b\\\")\\n (3, \\\"a\\\")\\n\\njulia> v = [(1, \\\"c\\\"), (3, \\\"a\\\"), (2, \\\"b\\\")]; sort!(v, by = x -> x[2]); v\\n3-element Array{Tuple{Int64,String},1}:\\n (3, \\\"a\\\")\\n (2, \\\"b\\\")\\n (1, \\\"c\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/sort.html#Base.sort\",\n    \"page\": \"Sorting and Related Functions\",\n    \"title\": \"Base.sort\",\n    \"category\": \"function\",\n    \"text\": \"sort(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\\n\\nVariant of sort! that returns a sorted copy of v leaving v itself unmodified.\\n\\nExamples\\n\\njulia> v = [3, 1, 2];\\n\\njulia> sort(v)\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n\\njulia> v\\n3-element Array{Int64,1}:\\n 3\\n 1\\n 2\\n\\n\\n\\n\\n\\nsort(A; dims::Integer, alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\\n\\nSort a multidimensional array A along the given dimension. See sort! for a description of possible keyword arguments.\\n\\nExamples\\n\\njulia> A = [4 3; 1 2]\\n2\u00d72 Array{Int64,2}:\\n 4  3\\n 1  2\\n\\njulia> sort(A, dims = 1)\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 4  3\\n\\njulia> sort(A, dims = 2)\\n2\u00d72 Array{Int64,2}:\\n 3  4\\n 1  2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/sort.html#Base.sortperm\",\n    \"page\": \"Sorting and Related Functions\",\n    \"title\": \"Base.sortperm\",\n    \"category\": \"function\",\n    \"text\": \"sortperm(v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\\n\\nReturn a permutation vector I that puts v[I] in sorted order. The order is specified using the same keywords as sort!. The permutation is guaranteed to be stable even if the sorting algorithm is unstable, meaning that indices of equal elements appear in ascending order.\\n\\nSee also sortperm!.\\n\\nExamples\\n\\njulia> v = [3, 1, 2];\\n\\njulia> p = sortperm(v)\\n3-element Array{Int64,1}:\\n 2\\n 3\\n 1\\n\\njulia> v[p]\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/sort.html#Base.Sort.sortperm!\",\n    \"page\": \"Sorting and Related Functions\",\n    \"title\": \"Base.Sort.sortperm!\",\n    \"category\": \"function\",\n    \"text\": \"sortperm!(ix, v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward, initialized::Bool=false)\\n\\nLike sortperm, but accepts a preallocated index vector ix.  If initialized is false (the default), ix is initialized to contain the values 1:length(v).\\n\\nExamples\\n\\njulia> v = [3, 1, 2]; p = zeros(Int, 3);\\n\\njulia> sortperm!(p, v); p\\n3-element Array{Int64,1}:\\n 2\\n 3\\n 1\\n\\njulia> v[p]\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/sort.html#Base.sortslices\",\n    \"page\": \"Sorting and Related Functions\",\n    \"title\": \"Base.sortslices\",\n    \"category\": \"function\",\n    \"text\": \"sortslices(A; dims, alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\\n\\nSort slices of an array A. The required keyword argument dims must be either an integer or a tuple of integers. It specifies the dimension(s) over which the slices are sorted.\\n\\nE.g., if A is a matrix, dims=1 will sort rows, dims=2 will sort columns. Note that the default comparison function on one dimensional slices sorts lexicographically.\\n\\nFor the remaining keyword arguments, see the documentation of sort!.\\n\\nExamples\\n\\njulia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1) # Sort rows\\n3\u00d73 Array{Int64,2}:\\n -1   6  4\\n  7   3  5\\n  9  -2  8\\n\\njulia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, lt=(x,y)->isless(x[2],y[2]))\\n3\u00d73 Array{Int64,2}:\\n  9  -2  8\\n  7   3  5\\n -1   6  4\\n\\njulia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, rev=true)\\n3\u00d73 Array{Int64,2}:\\n  9  -2  8\\n  7   3  5\\n -1   6  4\\n\\njulia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2) # Sort columns\\n3\u00d73 Array{Int64,2}:\\n  3   5  7\\n -1  -4  6\\n -2   8  9\\n\\njulia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, alg=InsertionSort, lt=(x,y)->isless(x[2],y[2]))\\n3\u00d73 Array{Int64,2}:\\n  5   3  7\\n -4  -1  6\\n  8  -2  9\\n\\njulia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, rev=true)\\n3\u00d73 Array{Int64,2}:\\n 7   5   3\\n 6  -4  -1\\n 9   8  -2\\n\\nHigher dimensions\\n\\nsortslices extends naturally to higher dimensions. E.g., if A is a a 2x2x2 array, sortslices(A, dims=3) will sort slices within the 3rd dimension, passing the 2x2 slices A[:, :, 1] and A[:, :, 2] to the comparison function. Note that while there is no default order on higher-dimensional slices, you may use the by or lt keyword argument to specify such an order.\\n\\nIf dims is a tuple, the order of the dimensions in dims is relevant and specifies the linear order of the slices. E.g., if A is three dimensional and dims is (1, 2), the orderings of the first two dimensions are re-arranged such such that the slices (of the remaining third dimension) are sorted. If dims is (2, 1) instead, the same slices will be taken, but the result order will be row-major instead.\\n\\nHigher dimensional examples\\n\\njulia> A = permutedims(reshape([4 3; 2 1; \\'A\\' \\'B\\'; \\'C\\' \\'D\\'], (2, 2, 2)), (1, 3, 2))\\n2\u00d72\u00d72 Array{Any,3}:\\n[:, :, 1] =\\n 4  3\\n 2  1\\n\\n[:, :, 2] =\\n \\'A\\'  \\'B\\'\\n \\'C\\'  \\'D\\'\\n\\njulia> sortslices(A, dims=(1,2))\\n2\u00d72\u00d72 Array{Any,3}:\\n[:, :, 1] =\\n 1  3\\n 2  4\\n\\n[:, :, 2] =\\n \\'D\\'  \\'B\\'\\n \\'C\\'  \\'A\\'\\n\\njulia> sortslices(A, dims=(2,1))\\n2\u00d72\u00d72 Array{Any,3}:\\n[:, :, 1] =\\n 1  2\\n 3  4\\n\\n[:, :, 2] =\\n \\'D\\'  \\'C\\'\\n \\'B\\'  \\'A\\'\\n\\njulia> sortslices(reshape([5; 4; 3; 2; 1], (1,1,5)), dims=3, by=x->x[1,1])\\n1\u00d71\u00d75 Array{Int64,3}:\\n[:, :, 1] =\\n 1\\n\\n[:, :, 2] =\\n 2\\n\\n[:, :, 3] =\\n 3\\n\\n[:, :, 4] =\\n 4\\n\\n[:, :, 5] =\\n 5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/sort.html#Sorting-Functions-1\",\n    \"page\": \"Sorting and Related Functions\",\n    \"title\": \"Sorting Functions\",\n    \"category\": \"section\",\n    \"text\": \"Base.sort!\\nBase.sort\\nBase.sortperm\\nBase.Sort.sortperm!\\nBase.Sort.sortslices\"\n},\n\n{\n    \"location\": \"base/sort.html#Base.issorted\",\n    \"page\": \"Sorting and Related Functions\",\n    \"title\": \"Base.issorted\",\n    \"category\": \"function\",\n    \"text\": \"issorted(v, lt=isless, by=identity, rev:Bool=false, order::Ordering=Forward)\\n\\nTest whether a vector is in sorted order. The lt, by and rev keywords modify what order is considered to be sorted just as they do for sort.\\n\\nExamples\\n\\njulia> issorted([1, 2, 3])\\ntrue\\n\\njulia> issorted([(1, \\\"b\\\"), (2, \\\"a\\\")], by = x -> x[1])\\ntrue\\n\\njulia> issorted([(1, \\\"b\\\"), (2, \\\"a\\\")], by = x -> x[2])\\nfalse\\n\\njulia> issorted([(1, \\\"b\\\"), (2, \\\"a\\\")], by = x -> x[2], rev=true)\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/sort.html#Base.Sort.searchsorted\",\n    \"page\": \"Sorting and Related Functions\",\n    \"title\": \"Base.Sort.searchsorted\",\n    \"category\": \"function\",\n    \"text\": \"searchsorted(a, x; by=<transform>, lt=<comparison>, rev=false)\\n\\nReturn the range of indices of a which compare as equal to x (using binary search) according to the order specified by the by, lt and rev keywords, assuming that a is already sorted in that order. Return an empty range located at the insertion point if a does not contain values equal to x.\\n\\nExamples\\n\\njulia> a = [4, 3, 2, 1]\\n4-element Array{Int64,1}:\\n 4\\n 3\\n 2\\n 1\\n\\njulia> searchsorted(a, 4)\\n5:4\\n\\njulia> searchsorted(a, 4, rev=true)\\n1:1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/sort.html#Base.Sort.searchsortedfirst\",\n    \"page\": \"Sorting and Related Functions\",\n    \"title\": \"Base.Sort.searchsortedfirst\",\n    \"category\": \"function\",\n    \"text\": \"searchsortedfirst(a, x; by=<transform>, lt=<comparison>, rev=false)\\n\\nReturn the index of the first value in a greater than or equal to x, according to the specified order. Return length(a) + 1 if x is greater than all values in a. a is assumed to be sorted.\\n\\nExamples\\n\\njulia> searchsortedfirst([1, 2, 4, 5, 14], 4)\\n3\\n\\njulia> searchsortedfirst([1, 2, 4, 5, 14], 4, rev=true)\\n1\\n\\njulia> searchsortedfirst([1, 2, 4, 5, 14], 15)\\n6\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/sort.html#Base.Sort.searchsortedlast\",\n    \"page\": \"Sorting and Related Functions\",\n    \"title\": \"Base.Sort.searchsortedlast\",\n    \"category\": \"function\",\n    \"text\": \"searchsortedlast(a, x; by=<transform>, lt=<comparison>, rev=false)\\n\\nReturn the index of the last value in a less than or equal to x, according to the specified order. Return 0 if x is less than all values in a. a is assumed to be sorted.\\n\\nExamples\\n\\njulia> searchsortedlast([1, 2, 4, 5, 14], 4)\\n3\\n\\njulia> searchsortedlast([1, 2, 4, 5, 14], 4, rev=true)\\n5\\n\\njulia> searchsortedlast([1, 2, 4, 5, 14], -1)\\n0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/sort.html#Base.Sort.partialsort!\",\n    \"page\": \"Sorting and Related Functions\",\n    \"title\": \"Base.Sort.partialsort!\",\n    \"category\": \"function\",\n    \"text\": \"partialsort!(v, k; by=<transform>, lt=<comparison>, rev=false)\\n\\nPartially sort the vector v in place, according to the order specified by by, lt and rev so that the value at index k (or range of adjacent values if k is a range) occurs at the position where it would appear if the array were fully sorted via a non-stable algorithm. If k is a single index, that value is returned; if k is a range, an array of values at those indices is returned. Note that partialsort! does not fully sort the input array.\\n\\nExamples\\n\\njulia> a = [1, 2, 4, 3, 4]\\n5-element Array{Int64,1}:\\n 1\\n 2\\n 4\\n 3\\n 4\\n\\njulia> partialsort!(a, 4)\\n4\\n\\njulia> a\\n5-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n 4\\n 4\\n\\njulia> a = [1, 2, 4, 3, 4]\\n5-element Array{Int64,1}:\\n 1\\n 2\\n 4\\n 3\\n 4\\n\\njulia> partialsort!(a, 4, rev=true)\\n2\\n\\njulia> a\\n5-element Array{Int64,1}:\\n 4\\n 4\\n 3\\n 2\\n 1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/sort.html#Base.Sort.partialsort\",\n    \"page\": \"Sorting and Related Functions\",\n    \"title\": \"Base.Sort.partialsort\",\n    \"category\": \"function\",\n    \"text\": \"partialsort(v, k, by=<transform>, lt=<comparison>, rev=false)\\n\\nVariant of partialsort! which copies v before partially sorting it, thereby returning the same thing as partialsort! but leaving v unmodified.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/sort.html#Base.Sort.partialsortperm\",\n    \"page\": \"Sorting and Related Functions\",\n    \"title\": \"Base.Sort.partialsortperm\",\n    \"category\": \"function\",\n    \"text\": \"partialsortperm(v, k; by=<transform>, lt=<comparison>, rev=false)\\n\\nReturn a partial permutation I of the vector v, so that v[I] returns values of a fully sorted version of v at index k. If k is a range, a vector of indices is returned; if k is an integer, a single index is returned. The order is specified using the same keywords as sort!. The permutation is stable, meaning that indices of equal elements appear in ascending order.\\n\\nNote that this function is equivalent to, but more efficient than, calling sortperm(...)[k].\\n\\nExamples\\n\\njulia> v = [3, 1, 2, 1];\\n\\njulia> v[partialsortperm(v, 1)]\\n1\\n\\njulia> p = partialsortperm(v, 1:3)\\n3-element view(::Array{Int64,1}, 1:3) with eltype Int64:\\n 2\\n 4\\n 3\\n\\njulia> v[p]\\n3-element Array{Int64,1}:\\n 1\\n 1\\n 2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/sort.html#Base.Sort.partialsortperm!\",\n    \"page\": \"Sorting and Related Functions\",\n    \"title\": \"Base.Sort.partialsortperm!\",\n    \"category\": \"function\",\n    \"text\": \"partialsortperm!(ix, v, k; by=<transform>, lt=<comparison>, rev=false, initialized=false)\\n\\nLike partialsortperm, but accepts a preallocated index vector ix. If initialized is false (the default), ix is initialized to contain the values 1:length(ix).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/sort.html#Order-Related-Functions-1\",\n    \"page\": \"Sorting and Related Functions\",\n    \"title\": \"Order-Related Functions\",\n    \"category\": \"section\",\n    \"text\": \"Base.issorted\\nBase.Sort.searchsorted\\nBase.Sort.searchsortedfirst\\nBase.Sort.searchsortedlast\\nBase.Sort.partialsort!\\nBase.Sort.partialsort\\nBase.Sort.partialsortperm\\nBase.Sort.partialsortperm!\"\n},\n\n{\n    \"location\": \"base/sort.html#Sorting-Algorithms-1\",\n    \"page\": \"Sorting and Related Functions\",\n    \"title\": \"Sorting Algorithms\",\n    \"category\": \"section\",\n    \"text\": \"There are currently four sorting algorithms available in base Julia:InsertionSort\\nQuickSort\\nPartialQuickSort(k)\\nMergeSortInsertionSort is an O(n^2) stable sorting algorithm. It is efficient for very small n, and is used internally by QuickSort.QuickSort is an O(n log n) sorting algorithm which is in-place, very fast, but not stable \u2013 i.e. elements which are considered equal will not remain in the same order in which they originally appeared in the array to be sorted. QuickSort is the default algorithm for numeric values, including integers and floats.PartialQuickSort(k) is similar to QuickSort, but the output array is only sorted up to index k if k is an integer, or in the range of k if k is an OrdinalRange. For example:x = rand(1:500, 100)\\nk = 50\\nk2 = 50:100\\ns = sort(x; alg=QuickSort)\\nps = sort(x; alg=PartialQuickSort(k))\\nqs = sort(x; alg=PartialQuickSort(k2))\\nmap(issorted, (s, ps, qs))             # => (true, false, false)\\nmap(x->issorted(x[1:k]), (s, ps, qs))  # => (true, true, false)\\nmap(x->issorted(x[k2]), (s, ps, qs))   # => (true, false, true)\\ns[1:k] == ps[1:k]                      # => true\\ns[k2] == qs[k2]                        # => trueMergeSort is an O(n log n) stable sorting algorithm but is not in-place \u2013 it requires a temporary array of half the size of the input array \u2013 and is typically not quite as fast as QuickSort. It is the default algorithm for non-numeric data.The default sorting algorithms are chosen on the basis that they are fast and stable, or appear to be so. For numeric types indeed, QuickSort is selected as it is faster and indistinguishable in this case from a stable sort (unless the array records its mutations in some way). The stability property comes at a non-negligible cost, so if you don\\'t need it, you may want to explicitly specify your preferred algorithm, e.g. sort!(v, alg=QuickSort).The mechanism by which Julia picks default sorting algorithms is implemented via the Base.Sort.defalg function. It allows a particular algorithm to be registered as the default in all sorting functions for specific arrays. For example, here are the two default methods from sort.jl:defalg(v::AbstractArray) = MergeSort\\ndefalg(v::AbstractArray{<:Number}) = QuickSortAs for numeric arrays, choosing a non-stable default algorithm for array types for which the notion of a stable sort is meaningless (i.e. when two values comparing equal can not be distinguished) may make sense.\"\n},\n\n{\n    \"location\": \"base/iterators.html#\",\n    \"page\": \"Iteration utilities\",\n    \"title\": \"Iteration utilities\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/iterators.html#Base.Iterators.Stateful\",\n    \"page\": \"Iteration utilities\",\n    \"title\": \"Base.Iterators.Stateful\",\n    \"category\": \"type\",\n    \"text\": \"Stateful(itr)\\n\\nThere are several different ways to think about this iterator wrapper:\\n\\nIt provides a mutable wrapper around an iterator and its iteration state.\\nIt turns an iterator-like abstraction into a Channel-like abstraction.\\nIt\\'s an iterator that mutates to become its own rest iterator whenever an item is produced.\\n\\nStateful provides the regular iterator interface. Like other mutable iterators (e.g. Channel), if iteration is stopped early (e.g. by a break in a for loop), iteration can be resumed from the same spot by continuing to iterate over the same iterator object (in contrast, an immutable iterator would restart from the beginning).\\n\\nExamples\\n\\njulia> a = Iterators.Stateful(\\\"abcdef\\\");\\n\\njulia> isempty(a)\\nfalse\\n\\njulia> popfirst!(a)\\n\\'a\\': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\\n\\njulia> collect(Iterators.take(a, 3))\\n3-element Array{Char,1}:\\n \\'b\\'\\n \\'c\\'\\n \\'d\\'\\n\\njulia> collect(a)\\n2-element Array{Char,1}:\\n \\'e\\'\\n \\'f\\'\\n\\njulia> a = Iterators.Stateful([1,1,1,2,3,4]);\\n\\njulia> for x in a; x == 1 || break; end\\n\\njulia> Base.peek(a)\\n3\\n\\njulia> sum(a) # Sum the remaining elements\\n7\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/iterators.html#Base.Iterators.zip\",\n    \"page\": \"Iteration utilities\",\n    \"title\": \"Base.Iterators.zip\",\n    \"category\": \"function\",\n    \"text\": \"zip(iters...)\\n\\nFor a set of iterable objects, return an iterable of tuples, where the ith tuple contains the ith component of each input iterable.\\n\\nExamples\\n\\njulia> a = 1:5\\n1:5\\n\\njulia> b = [\\\"e\\\",\\\"d\\\",\\\"b\\\",\\\"c\\\",\\\"a\\\"]\\n5-element Array{String,1}:\\n \\\"e\\\"\\n \\\"d\\\"\\n \\\"b\\\"\\n \\\"c\\\"\\n \\\"a\\\"\\n\\njulia> c = zip(a,b)\\nBase.Iterators.Zip2{UnitRange{Int64},Array{String,1}}(1:5, [\\\"e\\\", \\\"d\\\", \\\"b\\\", \\\"c\\\", \\\"a\\\"])\\n\\njulia> length(c)\\n5\\n\\njulia> first(c)\\n(1, \\\"e\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/iterators.html#Base.Iterators.enumerate\",\n    \"page\": \"Iteration utilities\",\n    \"title\": \"Base.Iterators.enumerate\",\n    \"category\": \"function\",\n    \"text\": \"enumerate(iter)\\n\\nAn iterator that yields (i, x) where i is a counter starting at 1, and x is the ith value from the given iterator. It\\'s useful when you need not only the values x over which you are iterating, but also the number of iterations so far. Note that i may not be valid for indexing iter; it\\'s also possible that x != iter[i], if iter has indices that do not start at 1. See the enumerate(IndexLinear(), iter) method if you want to ensure that i is an index.\\n\\nExamples\\n\\njulia> a = [\\\"a\\\", \\\"b\\\", \\\"c\\\"];\\n\\njulia> for (index, value) in enumerate(a)\\n           println(\\\"$index $value\\\")\\n       end\\n1 a\\n2 b\\n3 c\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/iterators.html#Base.Iterators.rest\",\n    \"page\": \"Iteration utilities\",\n    \"title\": \"Base.Iterators.rest\",\n    \"category\": \"function\",\n    \"text\": \"rest(iter, state)\\n\\nAn iterator that yields the same elements as iter, but starting at the given state.\\n\\nExamples\\n\\njulia> collect(Iterators.rest([1,2,3,4], 2))\\n3-element Array{Int64,1}:\\n 2\\n 3\\n 4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/iterators.html#Base.Iterators.countfrom\",\n    \"page\": \"Iteration utilities\",\n    \"title\": \"Base.Iterators.countfrom\",\n    \"category\": \"function\",\n    \"text\": \"countfrom(start=1, step=1)\\n\\nAn iterator that counts forever, starting at start and incrementing by step.\\n\\nExamples\\n\\njulia> for v in Iterators.countfrom(5, 2)\\n           v > 10 && break\\n           println(v)\\n       end\\n5\\n7\\n9\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/iterators.html#Base.Iterators.take\",\n    \"page\": \"Iteration utilities\",\n    \"title\": \"Base.Iterators.take\",\n    \"category\": \"function\",\n    \"text\": \"take(iter, n)\\n\\nAn iterator that generates at most the first n elements of iter.\\n\\nExamples\\n\\njulia> a = 1:2:11\\n1:2:11\\n\\njulia> collect(a)\\n6-element Array{Int64,1}:\\n  1\\n  3\\n  5\\n  7\\n  9\\n 11\\n\\njulia> collect(Iterators.take(a,3))\\n3-element Array{Int64,1}:\\n 1\\n 3\\n 5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/iterators.html#Base.Iterators.drop\",\n    \"page\": \"Iteration utilities\",\n    \"title\": \"Base.Iterators.drop\",\n    \"category\": \"function\",\n    \"text\": \"drop(iter, n)\\n\\nAn iterator that generates all but the first n elements of iter.\\n\\nExamples\\n\\njulia> a = 1:2:11\\n1:2:11\\n\\njulia> collect(a)\\n6-element Array{Int64,1}:\\n  1\\n  3\\n  5\\n  7\\n  9\\n 11\\n\\njulia> collect(Iterators.drop(a,4))\\n2-element Array{Int64,1}:\\n  9\\n 11\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/iterators.html#Base.Iterators.cycle\",\n    \"page\": \"Iteration utilities\",\n    \"title\": \"Base.Iterators.cycle\",\n    \"category\": \"function\",\n    \"text\": \"cycle(iter)\\n\\nAn iterator that cycles through iter forever. If iter is empty, so is cycle(iter).\\n\\nExamples\\n\\njulia> for (i, v) in enumerate(Iterators.cycle(\\\"hello\\\"))\\n           print(v)\\n           i > 10 && break\\n       end\\nhellohelloh\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/iterators.html#Base.Iterators.repeated\",\n    \"page\": \"Iteration utilities\",\n    \"title\": \"Base.Iterators.repeated\",\n    \"category\": \"function\",\n    \"text\": \"repeated(x[, n::Int])\\n\\nAn iterator that generates the value x forever. If n is specified, generates x that many times (equivalent to take(repeated(x), n)).\\n\\nExamples\\n\\njulia> a = Iterators.repeated([1 2], 4);\\n\\njulia> collect(a)\\n4-element Array{Array{Int64,2},1}:\\n [1 2]\\n [1 2]\\n [1 2]\\n [1 2]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/iterators.html#Base.Iterators.product\",\n    \"page\": \"Iteration utilities\",\n    \"title\": \"Base.Iterators.product\",\n    \"category\": \"function\",\n    \"text\": \"product(iters...)\\n\\nReturn an iterator over the product of several iterators. Each generated element is a tuple whose ith element comes from the ith argument iterator. The first iterator changes the fastest.\\n\\nExamples\\n\\njulia> collect(Iterators.product(1:2, 3:5))\\n2\u00d73 Array{Tuple{Int64,Int64},2}:\\n (1, 3)  (1, 4)  (1, 5)\\n (2, 3)  (2, 4)  (2, 5)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/iterators.html#Base.Iterators.flatten\",\n    \"page\": \"Iteration utilities\",\n    \"title\": \"Base.Iterators.flatten\",\n    \"category\": \"function\",\n    \"text\": \"flatten(iter)\\n\\nGiven an iterator that yields iterators, return an iterator that yields the elements of those iterators. Put differently, the elements of the argument iterator are concatenated.\\n\\nExamples\\n\\njulia> collect(Iterators.flatten((1:2, 8:9)))\\n4-element Array{Int64,1}:\\n 1\\n 2\\n 8\\n 9\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/iterators.html#Base.Iterators.partition\",\n    \"page\": \"Iteration utilities\",\n    \"title\": \"Base.Iterators.partition\",\n    \"category\": \"function\",\n    \"text\": \"partition(collection, n)\\n\\nIterate over a collection n elements at a time.\\n\\nExamples\\n\\njulia> collect(Iterators.partition([1,2,3,4,5], 2))\\n3-element Array{Array{Int64,1},1}:\\n [1, 2]\\n [3, 4]\\n [5]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/iterators.html#Base.Iterators.filter\",\n    \"page\": \"Iteration utilities\",\n    \"title\": \"Base.Iterators.filter\",\n    \"category\": \"function\",\n    \"text\": \"Iterators.filter(flt, itr)\\n\\nGiven a predicate function flt and an iterable object itr, return an iterable object which upon iteration yields the elements x of itr that satisfy flt(x). The order of the original iterator is preserved.\\n\\nThis function is lazy; that is, it is guaranteed to return in \u0398(1) time and use \u0398(1) additional space, and flt will not be called by an invocation of filter. Calls to flt will be made when iterating over the returned iterable object. These calls are not cached and repeated calls will be made when reiterating.\\n\\nSee Base.filter for an eager implementation of filtering for arrays.\\n\\nExamples\\n\\njulia> f = Iterators.filter(isodd, [1, 2, 3, 4, 5])\\nBase.Iterators.Filter{typeof(isodd),Array{Int64,1}}(isodd, [1, 2, 3, 4, 5])\\n\\njulia> foreach(println, f)\\n1\\n3\\n5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/iterators.html#Base.Iterators.reverse\",\n    \"page\": \"Iteration utilities\",\n    \"title\": \"Base.Iterators.reverse\",\n    \"category\": \"function\",\n    \"text\": \"Iterators.reverse(itr)\\n\\nGiven an iterator itr, then reverse(itr) is an iterator over the same collection but in the reverse order.\\n\\nThis iterator is \\\"lazy\\\" in that it does not make a copy of the collection in order to reverse it; see Base.reverse for an eager implementation.\\n\\nNot all iterator types T support reverse-order iteration.  If T doesn\\'t, then iterating over Iterators.reverse(itr::T) will throw a MethodError because of the missing iterate methods for Iterators.Reverse{T}. (To implement these methods, the original iterator itr::T can be obtained from r = Iterators.reverse(itr) by r.itr.)\\n\\nExamples\\n\\njulia> foreach(println, Iterators.reverse(1:5))\\n5\\n4\\n3\\n2\\n1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/iterators.html#Iteration-utilities-1\",\n    \"page\": \"Iteration utilities\",\n    \"title\": \"Iteration utilities\",\n    \"category\": \"section\",\n    \"text\": \"Base.Iterators.Stateful\\nBase.Iterators.zip\\nBase.Iterators.enumerate\\nBase.Iterators.rest\\nBase.Iterators.countfrom\\nBase.Iterators.take\\nBase.Iterators.drop\\nBase.Iterators.cycle\\nBase.Iterators.repeated\\nBase.Iterators.product\\nBase.Iterators.flatten\\nBase.Iterators.partition\\nBase.Iterators.filter\\nBase.Iterators.reverse\"\n},\n\n{\n    \"location\": \"base/c.html#\",\n    \"page\": \"C Interface\",\n    \"title\": \"C Interface\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/c.html#ccall\",\n    \"page\": \"C Interface\",\n    \"title\": \"ccall\",\n    \"category\": \"keyword\",\n    \"text\": \"ccall((function_name, library), returntype, (argtype1, ...), argvalue1, ...)\\nccall(function_pointer, returntype, (argtype1, ...), argvalue1, ...)\\n\\nCall a function in a C-exported shared library, specified by the tuple (function_name, library), where each component is either a string or symbol. Alternatively, ccall may also be used to call a function pointer function_pointer, such as one returned by dlsym.\\n\\nNote that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.\\n\\nEach argvalue to the ccall will be converted to the corresponding argtype, by automatic insertion of calls to unsafe_convert(argtype, cconvert(argtype, argvalue)). (See also the documentation for unsafe_convert and cconvert for further details.) In most cases, this simply results in a call to convert(argtype, argvalue).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Core.Intrinsics.cglobal\",\n    \"page\": \"C Interface\",\n    \"title\": \"Core.Intrinsics.cglobal\",\n    \"category\": \"function\",\n    \"text\": \"cglobal((symbol, library) [, type=Cvoid])\\n\\nObtain a pointer to a global variable in a C-exported shared library, specified exactly as in ccall. Returns a Ptr{Type}, defaulting to Ptr{Cvoid} if no Type argument is supplied. The values can be read or written by unsafe_load or unsafe_store!, respectively.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.@cfunction\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.@cfunction\",\n    \"category\": \"macro\",\n    \"text\": \"@cfunction(callable, ReturnType, (ArgumentTypes...,)) -> Ptr{Cvoid}\\n@cfunction($callable, ReturnType, (ArgumentTypes...,)) -> CFunction\\n\\nGenerate a C-callable function pointer from the Julia function closure for the given type signature. To pass the return value to a ccall, use the argument type Ptr{Cvoid} in the signature.\\n\\nNote that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression (although it can include a splat expression). And that these arguments will be evaluated in global scope during compile-time (not deferred until runtime). Adding a \\'$\\' in front of the function argument changes this to instead create a runtime closure over the local variable callable.\\n\\nSee manual section on ccall and cfunction usage.\\n\\nExamples\\n\\njulia> function foo(x::Int, y::Int)\\n           return x + y\\n       end\\n\\njulia> @cfunction(foo, Int, (Int, Int))\\nPtr{Cvoid} @0x000000001b82fcd0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.CFunction\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.CFunction\",\n    \"category\": \"type\",\n    \"text\": \"CFunction struct\\n\\nGarbage-collection handle for the return value from @cfunction when the first argument is annotated with \\'$\\'. Like all cfunction handles, it should be passed to ccall as a Ptr{Cvoid}, and will be converted automatically at the call site to the appropriate type.\\n\\nSee @cfunction.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.unsafe_convert\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.unsafe_convert\",\n    \"category\": \"function\",\n    \"text\": \"unsafe_convert(T, x)\\n\\nConvert x to a C argument of type T where the input x must be the return value of cconvert(T, ...).\\n\\nIn cases where convert would need to take a Julia object and turn it into a Ptr, this function should be used to define and perform that conversion.\\n\\nBe careful to ensure that a Julia reference to x exists as long as the result of this function will be used. Accordingly, the argument x to this function should never be an expression, only a variable name or field reference. For example, x=a.b.c is acceptable, but x=[a,b,c] is not.\\n\\nThe unsafe prefix on this function indicates that using the result of this function after the x argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.\\n\\nSee also cconvert\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.cconvert\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.cconvert\",\n    \"category\": \"function\",\n    \"text\": \"cconvert(T,x)\\n\\nConvert x to a value to be passed to C code as type T, typically by calling convert(T, x).\\n\\nIn cases where x cannot be safely converted to T, unlike convert, cconvert may return an object of a type different from T, which however is suitable for unsafe_convert to handle. The result of this function should be kept valid (for the GC) until the result of unsafe_convert is not needed anymore. This can be used to allocate memory that will be accessed by the ccall. If multiple objects need to be allocated, a tuple of the objects can be used as return value.\\n\\nNeither convert nor cconvert should take a Julia object and turn it into a Ptr.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.unsafe_load\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.unsafe_load\",\n    \"category\": \"function\",\n    \"text\": \"unsafe_load(p::Ptr{T}, i::Integer=1)\\n\\nLoad a value of type T from the address of the ith element (1-indexed) starting at p. This is equivalent to the C expression p[i-1].\\n\\nThe unsafe prefix on this function indicates that no validation is performed on the pointer p to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.unsafe_store!\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.unsafe_store!\",\n    \"category\": \"function\",\n    \"text\": \"unsafe_store!(p::Ptr{T}, x, i::Integer=1)\\n\\nStore a value of type T to the address of the ith element (1-indexed) starting at p. This is equivalent to the C expression p[i-1] = x.\\n\\nThe unsafe prefix on this function indicates that no validation is performed on the pointer p to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.unsafe_copyto!-Union{Tuple{T}, Tuple{Ptr{T},Ptr{T},Any}} where T\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.unsafe_copyto!\",\n    \"category\": \"method\",\n    \"text\": \"unsafe_copyto!(dest::Ptr{T}, src::Ptr{T}, N)\\n\\nCopy N elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.\\n\\nThe unsafe prefix on this function indicates that no validation is performed on the pointers dest and src to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.unsafe_copyto!-Union{Tuple{T}, Tuple{Array{T,N} where N,Any,Array{T,N} where N,Any,Any}} where T\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.unsafe_copyto!\",\n    \"category\": \"method\",\n    \"text\": \"unsafe_copyto!(dest::Array, do, src::Array, so, N)\\n\\nCopy N elements from a source array to a destination, starting at offset so in the source and do in the destination (1-indexed).\\n\\nThe unsafe prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.copyto!\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.copyto!\",\n    \"category\": \"function\",\n    \"text\": \"copyto!(dest, do, src, so, N)\\n\\nCopy N elements from collection src starting at offset so, to array dest starting at offset do. Return dest.\\n\\n\\n\\n\\n\\ncopyto!(dest::AbstractArray, src) -> dest\\n\\nCopy all elements from collection src to array dest, whose length must be greater than or equal to the length n of src. The first n elements of dest are overwritten, the other elements are left untouched.\\n\\nExamples\\n\\njulia> x = [1., 0., 3., 0., 5.];\\n\\njulia> y = zeros(7);\\n\\njulia> copyto!(y, x);\\n\\njulia> y\\n7-element Array{Float64,1}:\\n 1.0\\n 0.0\\n 3.0\\n 0.0\\n 5.0\\n 0.0\\n 0.0\\n\\n\\n\\n\\n\\ncopyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices) -> dest\\n\\nCopy the block of src in the range of Rsrc to the block of dest in the range of Rdest. The sizes of the two regions must match.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.pointer\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.pointer\",\n    \"category\": \"function\",\n    \"text\": \"pointer(array [, index])\\n\\nGet the native address of an array or string, optionally at a given location index.\\n\\nThis function is \\\"unsafe\\\". Be careful to ensure that a Julia reference to array exists as long as this pointer will be used. The GC.@preserve macro should be used to protect the array argument from garbage collection within a given block of code.\\n\\nCalling Ref(array[, index]) is generally preferable to this function as it guarantees validity.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T,N} where N}, Type{Array{T,N}}},Ptr{T},Tuple{Vararg{Int64,N}}}} where N where T\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.unsafe_wrap\",\n    \"category\": \"method\",\n    \"text\": \"unsafe_wrap(Array, pointer::Ptr{T}, dims; own = false)\\n\\nWrap a Julia Array object around the data at the address given by pointer, without making a copy.  The pointer element type T determines the array element type. dims is either an integer (for a 1d array) or a tuple of the array dimensions. own optionally specifies whether Julia should take ownership of the memory, calling free on the pointer when the array is no longer referenced.\\n\\nThis function is labeled \\\"unsafe\\\" because it will crash if pointer is not a valid memory address to data of the requested length.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.pointer_from_objref\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.pointer_from_objref\",\n    \"category\": \"function\",\n    \"text\": \"pointer_from_objref(x)\\n\\nGet the memory address of a Julia object as a Ptr. The existence of the resulting Ptr will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the Ptr will be used.\\n\\nThis function may not be called on immutable objects, since they do not have stable memory addresses.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.unsafe_pointer_to_objref\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.unsafe_pointer_to_objref\",\n    \"category\": \"function\",\n    \"text\": \"unsafe_pointer_to_objref(p::Ptr)\\n\\nConvert a Ptr to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered \\\"unsafe\\\" and should be used with care.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.disable_sigint\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.disable_sigint\",\n    \"category\": \"function\",\n    \"text\": \"disable_sigint(f::Function)\\n\\nDisable Ctrl-C handler during execution of a function on the current task, for calling external code that may call julia code that is not interrupt safe. Intended to be called using do block syntax as follows:\\n\\ndisable_sigint() do\\n    # interrupt-unsafe code\\n    ...\\nend\\n\\nThis is not needed on worker threads (Threads.threadid() != 1) since the InterruptException will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.reenable_sigint\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.reenable_sigint\",\n    \"category\": \"function\",\n    \"text\": \"reenable_sigint(f::Function)\\n\\nRe-enable Ctrl-C handler during execution of a function. Temporarily reverses the effect of disable_sigint.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.systemerror\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.systemerror\",\n    \"category\": \"function\",\n    \"text\": \"systemerror(sysfunc, iftrue)\\n\\nRaises a SystemError for errno with the descriptive string sysfunc if iftrue is true\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Core.Ptr\",\n    \"page\": \"C Interface\",\n    \"title\": \"Core.Ptr\",\n    \"category\": \"type\",\n    \"text\": \"Ptr{T}\\n\\nA memory address referring to data of type T.  However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Core.Ref\",\n    \"page\": \"C Interface\",\n    \"title\": \"Core.Ref\",\n    \"category\": \"type\",\n    \"text\": \"Ref{T}\\n\\nAn object that safely references data of type T. This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the Ref itself is referenced.\\n\\nIn Julia, Ref objects are dereferenced (loaded or stored) with [].\\n\\nCreation of a Ref to a value x of type T is usually written Ref(x). Additionally, for creating interior pointers to containers (such as Array or Ptr), it can be written Ref(a, i) for creating a reference to the i-th element of a.\\n\\nWhen passed as a ccall argument (either as a Ptr or Ref type), a Ref object will be converted to a native pointer to the data it references.\\n\\nThere is no invalid (NULL) Ref in Julia, but a C_NULL instance of Ptr can be passed to a ccall Ref argument.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Cchar\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Cchar\",\n    \"category\": \"type\",\n    \"text\": \"Cchar\\n\\nEquivalent to the native char c-type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Cuchar\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Cuchar\",\n    \"category\": \"type\",\n    \"text\": \"Cuchar\\n\\nEquivalent to the native unsigned char c-type (UInt8).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Cshort\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Cshort\",\n    \"category\": \"type\",\n    \"text\": \"Cshort\\n\\nEquivalent to the native signed short c-type (Int16).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Cstring\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Cstring\",\n    \"category\": \"type\",\n    \"text\": \"Cstring\\n\\nA C-style string composed of the native character type Cchars. Cstrings are NUL-terminated. For C-style strings composed of the native wide character type, see Cwstring. For more information about string interopability with C, see the manual.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Cushort\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Cushort\",\n    \"category\": \"type\",\n    \"text\": \"Cushort\\n\\nEquivalent to the native unsigned short c-type (UInt16).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Cint\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Cint\",\n    \"category\": \"type\",\n    \"text\": \"Cint\\n\\nEquivalent to the native signed int c-type (Int32).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Cuint\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Cuint\",\n    \"category\": \"type\",\n    \"text\": \"Cuint\\n\\nEquivalent to the native unsigned int c-type (UInt32).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Clong\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Clong\",\n    \"category\": \"type\",\n    \"text\": \"Clong\\n\\nEquivalent to the native signed long c-type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Culong\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Culong\",\n    \"category\": \"type\",\n    \"text\": \"Culong\\n\\nEquivalent to the native unsigned long c-type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Clonglong\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Clonglong\",\n    \"category\": \"type\",\n    \"text\": \"Clonglong\\n\\nEquivalent to the native signed long long c-type (Int64).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Culonglong\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Culonglong\",\n    \"category\": \"type\",\n    \"text\": \"Culonglong\\n\\nEquivalent to the native unsigned long long c-type (UInt64).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Cintmax_t\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Cintmax_t\",\n    \"category\": \"type\",\n    \"text\": \"Cintmax_t\\n\\nEquivalent to the native intmax_t c-type (Int64).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Cuintmax_t\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Cuintmax_t\",\n    \"category\": \"type\",\n    \"text\": \"Cuintmax_t\\n\\nEquivalent to the native uintmax_t c-type (UInt64).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Csize_t\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Csize_t\",\n    \"category\": \"type\",\n    \"text\": \"Csize_t\\n\\nEquivalent to the native size_t c-type (UInt).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Cssize_t\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Cssize_t\",\n    \"category\": \"type\",\n    \"text\": \"Cssize_t\\n\\nEquivalent to the native ssize_t c-type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Cptrdiff_t\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Cptrdiff_t\",\n    \"category\": \"type\",\n    \"text\": \"Cptrdiff_t\\n\\nEquivalent to the native ptrdiff_t c-type (Int).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Cwchar_t\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Cwchar_t\",\n    \"category\": \"type\",\n    \"text\": \"Cwchar_t\\n\\nEquivalent to the native wchar_t c-type (Int32).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Cwstring\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Cwstring\",\n    \"category\": \"type\",\n    \"text\": \"Cwstring\\n\\nA C-style string composed of the native wide character type Cwchar_ts. Cwstrings are NUL-terminated. For C-style strings composed of the native character type, see Cstring. For more information about string interopability with C, see the manual.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Cfloat\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Cfloat\",\n    \"category\": \"type\",\n    \"text\": \"Cfloat\\n\\nEquivalent to the native float c-type (Float32).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#Base.Cdouble\",\n    \"page\": \"C Interface\",\n    \"title\": \"Base.Cdouble\",\n    \"category\": \"type\",\n    \"text\": \"Cdouble\\n\\nEquivalent to the native double c-type (Float64).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#C-Interface-1\",\n    \"page\": \"C Interface\",\n    \"title\": \"C Interface\",\n    \"category\": \"section\",\n    \"text\": \"ccall\\nCore.Intrinsics.cglobal\\nBase.@cfunction\\nBase.CFunction\\nBase.unsafe_convert\\nBase.cconvert\\nBase.unsafe_load\\nBase.unsafe_store!\\nBase.unsafe_copyto!{T}(::Ptr{T}, ::Ptr{T}, ::Any)\\nBase.unsafe_copyto!{T}(::Array{T}, ::Any, ::Array{T}, ::Any, ::Any)\\nBase.copyto!\\nBase.pointer\\nBase.unsafe_wrap{T,N}(::Union{Type{Array},Type{Array{T}},Type{Array{T,N}}}, ::Ptr{T}, ::NTuple{N,Int})\\nBase.pointer_from_objref\\nBase.unsafe_pointer_to_objref\\nBase.disable_sigint\\nBase.reenable_sigint\\nBase.systemerror\\nCore.Ptr\\nCore.Ref\\nBase.Cchar\\nBase.Cuchar\\nBase.Cshort\\nBase.Cstring\\nBase.Cushort\\nBase.Cint\\nBase.Cuint\\nBase.Clong\\nBase.Culong\\nBase.Clonglong\\nBase.Culonglong\\nBase.Cintmax_t\\nBase.Cuintmax_t\\nBase.Csize_t\\nBase.Cssize_t\\nBase.Cptrdiff_t\\nBase.Cwchar_t\\nBase.Cwstring\\nBase.Cfloat\\nBase.Cdouble\"\n},\n\n{\n    \"location\": \"base/c.html#Core.Intrinsics.llvmcall\",\n    \"page\": \"C Interface\",\n    \"title\": \"Core.Intrinsics.llvmcall\",\n    \"category\": \"function\",\n    \"text\": \"llvmcall(IR::String, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\\nllvmcall((declarations::String, IR::String), ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\\n\\nCall LLVM IR string in the first argument. Similar to an LLVM function define block, arguments are available as consecutive unnamed SSA variables (%0, %1, etc.).\\n\\nThe optional declarations string contains external functions declarations that are necessary for llvm to compile the IR string. Multiple declarations can be passed in by separating them with line breaks.\\n\\nNote that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.\\n\\nEach ArgumentValue to llvmcall will be converted to the corresponding ArgumentType, by automatic insertion of calls to unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue)). (See also the documentation for unsafe_convert and cconvert for further details.) In most cases, this simply results in a call to convert(ArgumentType, ArgumentValue).\\n\\nSee test/llvmcall.jl for usage examples.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/c.html#LLVM-Interface-1\",\n    \"page\": \"C Interface\",\n    \"title\": \"LLVM Interface\",\n    \"category\": \"section\",\n    \"text\": \"Core.Intrinsics.llvmcall\"\n},\n\n{\n    \"location\": \"base/libc.html#\",\n    \"page\": \"C Standard Library\",\n    \"title\": \"C Standard Library\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/libc.html#Base.Libc.malloc\",\n    \"page\": \"C Standard Library\",\n    \"title\": \"Base.Libc.malloc\",\n    \"category\": \"function\",\n    \"text\": \"malloc(size::Integer) -> Ptr{Cvoid}\\n\\nCall malloc from the C standard library.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/libc.html#Base.Libc.calloc\",\n    \"page\": \"C Standard Library\",\n    \"title\": \"Base.Libc.calloc\",\n    \"category\": \"function\",\n    \"text\": \"calloc(num::Integer, size::Integer) -> Ptr{Cvoid}\\n\\nCall calloc from the C standard library.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/libc.html#Base.Libc.realloc\",\n    \"page\": \"C Standard Library\",\n    \"title\": \"Base.Libc.realloc\",\n    \"category\": \"function\",\n    \"text\": \"realloc(addr::Ptr, size::Integer) -> Ptr{Cvoid}\\n\\nCall realloc from the C standard library.\\n\\nSee warning in the documentation for free regarding only using this on memory originally obtained from malloc.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/libc.html#Base.Libc.free\",\n    \"page\": \"C Standard Library\",\n    \"title\": \"Base.Libc.free\",\n    \"category\": \"function\",\n    \"text\": \"free(addr::Ptr)\\n\\nCall free from the C standard library. Only use this on memory obtained from malloc, not on pointers retrieved from other C libraries. Ptr objects obtained from C libraries should be freed by the free functions defined in that library, to avoid assertion failures if multiple libc libraries exist on the system.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/libc.html#Base.Libc.errno\",\n    \"page\": \"C Standard Library\",\n    \"title\": \"Base.Libc.errno\",\n    \"category\": \"function\",\n    \"text\": \"errno([code])\\n\\nGet the value of the C library\\'s errno. If an argument is specified, it is used to set the value of errno.\\n\\nThe value of errno is only valid immediately after a ccall to a C library routine that sets it. Specifically, you cannot call errno at the next prompt in a REPL, because lots of code is executed between prompts.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/libc.html#Base.Libc.strerror\",\n    \"page\": \"C Standard Library\",\n    \"title\": \"Base.Libc.strerror\",\n    \"category\": \"function\",\n    \"text\": \"strerror(n=errno())\\n\\nConvert a system call error code to a descriptive string\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/libc.html#Base.Libc.GetLastError\",\n    \"page\": \"C Standard Library\",\n    \"title\": \"Base.Libc.GetLastError\",\n    \"category\": \"function\",\n    \"text\": \"GetLastError()\\n\\nCall the Win32 GetLastError function [only available on Windows].\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/libc.html#Base.Libc.FormatMessage\",\n    \"page\": \"C Standard Library\",\n    \"title\": \"Base.Libc.FormatMessage\",\n    \"category\": \"function\",\n    \"text\": \"FormatMessage(n=GetLastError())\\n\\nConvert a Win32 system call error code to a descriptive string [only available on Windows].\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/libc.html#Base.Libc.time-Tuple{Base.Libc.TmStruct}\",\n    \"page\": \"C Standard Library\",\n    \"title\": \"Base.Libc.time\",\n    \"category\": \"method\",\n    \"text\": \"time(t::TmStruct)\\n\\nConverts a TmStruct struct to a number of seconds since the epoch.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/libc.html#Base.Libc.strftime\",\n    \"page\": \"C Standard Library\",\n    \"title\": \"Base.Libc.strftime\",\n    \"category\": \"function\",\n    \"text\": \"strftime([format], time)\\n\\nConvert time, given as a number of seconds since the epoch or a TmStruct, to a formatted string using the given format. Supported formats are the same as those in the standard C library.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/libc.html#Base.Libc.strptime\",\n    \"page\": \"C Standard Library\",\n    \"title\": \"Base.Libc.strptime\",\n    \"category\": \"function\",\n    \"text\": \"strptime([format], timestr)\\n\\nParse a formatted time string into a TmStruct giving the seconds, minute, hour, date, etc. Supported formats are the same as those in the standard C library. On some platforms, timezones will not be parsed correctly. If the result of this function will be passed to time to convert it to seconds since the epoch, the isdst field should be filled in manually. Setting it to -1 will tell the C library to use the current system settings to determine the timezone.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/libc.html#Base.Libc.TmStruct\",\n    \"page\": \"C Standard Library\",\n    \"title\": \"Base.Libc.TmStruct\",\n    \"category\": \"type\",\n    \"text\": \"TmStruct([seconds])\\n\\nConvert a number of seconds since the epoch to broken-down format, with fields sec, min, hour, mday, month, year, wday, yday, and isdst.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/libc.html#Base.Libc.flush_cstdio\",\n    \"page\": \"C Standard Library\",\n    \"title\": \"Base.Libc.flush_cstdio\",\n    \"category\": \"function\",\n    \"text\": \"flush_cstdio()\\n\\nFlushes the C stdout and stderr streams (which may have been written to by external C code).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/libc.html#C-Standard-Library-1\",\n    \"page\": \"C Standard Library\",\n    \"title\": \"C Standard Library\",\n    \"category\": \"section\",\n    \"text\": \"Base.Libc.malloc\\nBase.Libc.calloc\\nBase.Libc.realloc\\nBase.Libc.free\\nBase.Libc.errno\\nBase.Libc.strerror\\nBase.Libc.GetLastError\\nBase.Libc.FormatMessage\\nBase.Libc.time(::Base.Libc.TmStruct)\\nBase.Libc.strftime\\nBase.Libc.strptime\\nBase.Libc.TmStruct\\nBase.Libc.flush_cstdio\"\n},\n\n{\n    \"location\": \"base/stacktraces.html#\",\n    \"page\": \"StackTraces\",\n    \"title\": \"StackTraces\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/stacktraces.html#Base.StackTraces.StackFrame\",\n    \"page\": \"StackTraces\",\n    \"title\": \"Base.StackTraces.StackFrame\",\n    \"category\": \"type\",\n    \"text\": \"StackFrame\\n\\nStack information representing execution context, with the following fields:\\n\\nfunc::Symbol\\nThe name of the function containing the execution context.\\nlinfo::Union{Core.MethodInstance, CodeInfo, Nothing}\\nThe MethodInstance containing the execution context (if it could be found).\\nfile::Symbol\\nThe path to the file containing the execution context.\\nline::Int\\nThe line number in the file containing the execution context.\\nfrom_c::Bool\\nTrue if the code is from C.\\ninlined::Bool\\nTrue if the code is from an inlined frame.\\npointer::UInt64\\nRepresentation of the pointer to the execution context as returned by backtrace.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/stacktraces.html#Base.StackTraces.StackTrace\",\n    \"page\": \"StackTraces\",\n    \"title\": \"Base.StackTraces.StackTrace\",\n    \"category\": \"type\",\n    \"text\": \"StackTrace\\n\\nAn alias for Vector{StackFrame} provided for convenience; returned by calls to stacktrace.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/stacktraces.html#Base.StackTraces.stacktrace\",\n    \"page\": \"StackTraces\",\n    \"title\": \"Base.StackTraces.stacktrace\",\n    \"category\": \"function\",\n    \"text\": \"stacktrace([trace::Vector{Ptr{Cvoid}},] [c_funcs::Bool=false]) -> StackTrace\\n\\nReturns a stack trace in the form of a vector of StackFrames. (By default stacktrace doesn\\'t return C functions, but this can be enabled.) When called without specifying a trace, stacktrace first calls backtrace.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/stacktraces.html#Base.StackTraces.lookup\",\n    \"page\": \"StackTraces\",\n    \"title\": \"Base.StackTraces.lookup\",\n    \"category\": \"function\",\n    \"text\": \"lookup(pointer::Union{Ptr{Cvoid}, UInt}) -> Vector{StackFrame}\\n\\nGiven a pointer to an execution context (usually generated by a call to backtrace), looks up stack frame context information. Returns an array of frame information for all functions inlined at that point, innermost function first.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/stacktraces.html#Base.StackTraces.remove_frames!\",\n    \"page\": \"StackTraces\",\n    \"title\": \"Base.StackTraces.remove_frames!\",\n    \"category\": \"function\",\n    \"text\": \"remove_frames!(stack::StackTrace, name::Symbol)\\n\\nTakes a StackTrace (a vector of StackFrames) and a function name (a Symbol) and removes the StackFrame specified by the function name from the StackTrace (also removing all frames above the specified function). Primarily used to remove StackTraces functions from the StackTrace prior to returning it.\\n\\n\\n\\n\\n\\nremove_frames!(stack::StackTrace, m::Module)\\n\\nReturns the StackTrace with all StackFrames from the provided Module removed.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"base/stacktraces.html#StackTraces-1\",\n    \"page\": \"StackTraces\",\n    \"title\": \"StackTraces\",\n    \"category\": \"section\",\n    \"text\": \"Base.StackTraces.StackFrame\\nBase.StackTraces.StackTrace\\nBase.StackTraces.stacktraceThe following methods and types in Base.StackTraces are not exported and need to be called e.g. as StackTraces.lookup(ptr).Base.StackTraces.lookup\\nBase.StackTraces.remove_frames!\"\n},\n\n{\n    \"location\": \"base/simd-types.html#\",\n    \"page\": \"SIMD Support\",\n    \"title\": \"SIMD Support\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"base/simd-types.html#SIMD-Support-1\",\n    \"page\": \"SIMD Support\",\n    \"title\": \"SIMD Support\",\n    \"category\": \"section\",\n    \"text\": \"Type VecElement{T} is intended for building libraries of SIMD operations. Practical use of it requires using llvmcall. The type is defined as:struct VecElement{T}\\n    value::T\\nendIt has a special compilation rule: a homogeneous tuple of VecElement{T} maps to an LLVM vector type when T is a primitive bits type and the tuple length is in the set {2-6,8-10,16}.At -O3, the compiler might automatically vectorize operations on such tuples. For example, the following program, when compiled with julia -O3 generates two SIMD addition instructions (addps) on x86 systems:const m128 = NTuple{4,VecElement{Float32}}\\n\\nfunction add(a::m128, b::m128)\\n    (VecElement(a[1].value+b[1].value),\\n     VecElement(a[2].value+b[2].value),\\n     VecElement(a[3].value+b[3].value),\\n     VecElement(a[4].value+b[4].value))\\nend\\n\\ntriple(c::m128) = add(add(c,c),c)\\n\\ncode_native(triple,(m128,))However, since the automatic vectorization cannot be relied upon, future use will mostly be via libraries that use llvmcall.\"\n},\n\n{\n    \"location\": \"stdlib/Base64.html#\",\n    \"page\": \"Base64\",\n    \"title\": \"Base64\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Base64.html#Base64.Base64EncodePipe\",\n    \"page\": \"Base64\",\n    \"title\": \"Base64.Base64EncodePipe\",\n    \"category\": \"type\",\n    \"text\": \"Base64EncodePipe(ostream)\\n\\nReturn a new write-only I/O stream, which converts any bytes written to it into base64-encoded ASCII bytes written to ostream.  Calling close on the Base64EncodePipe stream is necessary to complete the encoding (but does not close ostream).\\n\\nExamples\\n\\njulia> io = IOBuffer();\\n\\njulia> iob64_encode = Base64EncodePipe(io);\\n\\njulia> write(iob64_encode, \\\"Hello!\\\")\\n6\\n\\njulia> close(iob64_encode);\\n\\njulia> str = String(take!(io))\\n\\\"SGVsbG8h\\\"\\n\\njulia> String(base64decode(str))\\n\\\"Hello!\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Base64.html#Base64.base64encode\",\n    \"page\": \"Base64\",\n    \"title\": \"Base64.base64encode\",\n    \"category\": \"function\",\n    \"text\": \"base64encode(writefunc, args...; context=nothing)\\nbase64encode(args...; context=nothing)\\n\\nGiven a write-like function writefunc, which takes an I/O stream as its first argument, base64encode(writefunc, args...) calls writefunc to write args... to a base64-encoded string, and returns the string. base64encode(args...) is equivalent to base64encode(write, args...): it converts its arguments into bytes using the standard write functions and returns the base64-encoded string.\\n\\nThe optional keyword argument context can be set to :key=>value pair or an IO or IOContext object whose attributes are used for the I/O stream passed to writefunc or write.\\n\\nSee also base64decode.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Base64.html#Base64.Base64DecodePipe\",\n    \"page\": \"Base64\",\n    \"title\": \"Base64.Base64DecodePipe\",\n    \"category\": \"type\",\n    \"text\": \"Base64DecodePipe(istream)\\n\\nReturn a new read-only I/O stream, which decodes base64-encoded data read from istream.\\n\\nExamples\\n\\njulia> io = IOBuffer();\\n\\njulia> iob64_decode = Base64DecodePipe(io);\\n\\njulia> write(io, \\\"SGVsbG8h\\\")\\n8\\n\\njulia> seekstart(io);\\n\\njulia> String(read(iob64_decode))\\n\\\"Hello!\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Base64.html#Base64.base64decode\",\n    \"page\": \"Base64\",\n    \"title\": \"Base64.base64decode\",\n    \"category\": \"function\",\n    \"text\": \"base64decode(string)\\n\\nDecode the base64-encoded string and returns a Vector{UInt8} of the decoded bytes.\\n\\nSee also base64encode.\\n\\nExamples\\n\\njulia> b = base64decode(\\\"SGVsbG8h\\\")\\n6-element Array{UInt8,1}:\\n 0x48\\n 0x65\\n 0x6c\\n 0x6c\\n 0x6f\\n 0x21\\n\\njulia> String(b)\\n\\\"Hello!\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Base64.html#Base64.stringmime\",\n    \"page\": \"Base64\",\n    \"title\": \"Base64.stringmime\",\n    \"category\": \"function\",\n    \"text\": \"stringmime(mime, x; context=nothing)\\n\\nReturns an AbstractString containing the representation of x in the requested mime type. This is similar to repr(mime, x) except that binary data is base64-encoded as an ASCII string.\\n\\nThe optional keyword argument context can be set to :key=>value pair or an IO or IOContext object whose attributes are used for the I/O stream passed to show.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Base64.html#Base64-1\",\n    \"page\": \"Base64\",\n    \"title\": \"Base64\",\n    \"category\": \"section\",\n    \"text\": \"DocTestSetup = :(using Base64)Base64.Base64EncodePipe\\nBase64.base64encode\\nBase64.Base64DecodePipe\\nBase64.base64decode\\nBase64.stringmimeDocTestSetup = nothing\"\n},\n\n{\n    \"location\": \"stdlib/CRC32c.html#\",\n    \"page\": \"CRC32c\",\n    \"title\": \"CRC32c\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/CRC32c.html#CRC32c.crc32c\",\n    \"page\": \"CRC32c\",\n    \"title\": \"CRC32c.crc32c\",\n    \"category\": \"function\",\n    \"text\": \"crc32c(data, crc::UInt32=0x00000000)\\n\\nCompute the CRC-32c checksum of the given data, which can be an Array{UInt8}, a contiguous subarray thereof, or a String.  Optionally, you can pass a starting crc integer to be mixed in with the checksum.  The crc parameter can be used to compute a checksum on data divided into chunks: performing crc32c(data2, crc32c(data1)) is equivalent to the checksum of [data1; data2]. (Technically, a little-endian checksum is computed.)\\n\\nThere is also a method crc32c(io, nb, crc) to checksum nb bytes from a stream io, or crc32c(io, crc) to checksum all the remaining bytes. Hence you can do open(crc32c, filename) to checksum an entire file, or crc32c(seekstart(buf)) to checksum an IOBuffer without calling take!.\\n\\nFor a String, note that the result is specific to the UTF-8 encoding (a different checksum would be obtained from a different Unicode encoding). To checksum an a::Array of some other bitstype, you can do crc32c(reinterpret(UInt8,a)), but note that the result may be endian-dependent.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/CRC32c.html#CRC32c.crc32c-Tuple{IO,Integer,UInt32}\",\n    \"page\": \"CRC32c\",\n    \"title\": \"CRC32c.crc32c\",\n    \"category\": \"method\",\n    \"text\": \"crc32c(io::IO, [nb::Integer,] crc::UInt32=0x00000000)\\n\\nRead up to nb bytes from io and return the CRC-32c checksum, optionally mixed with a starting crc integer.  If nb is not supplied, then io will be read until the end of the stream.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/CRC32c.html#CRC32c-1\",\n    \"page\": \"CRC32c\",\n    \"title\": \"CRC32c\",\n    \"category\": \"section\",\n    \"text\": \"CRC32c.crc32c\\nCRC32c.crc32c(::IO, ::Integer, ::UInt32)\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates-1\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates\",\n    \"category\": \"section\",\n    \"text\": \"DocTestSetup = :(using Dates)The Dates module provides two types for working with dates: Date and DateTime, representing day and millisecond precision, respectively; both are subtypes of the abstract TimeType. The motivation for distinct types is simple: some operations are much simpler, both in terms of code and mental reasoning, when the complexities of greater precision don\\'t have to be dealt with. For example, since the Date type only resolves to the precision of a single date (i.e. no hours, minutes, or seconds), normal considerations for time zones, daylight savings/summer time, and leap seconds are unnecessary and avoided.Both Date and DateTime are basically immutable Int64 wrappers. The single instant field of either type is actually a UTInstant{P} type, which represents a continuously increasing machine timeline based on the UT second [1]. The DateTime type is not aware of time zones (naive, in Python parlance), analogous to a LocalDateTime in Java 8. Additional time zone functionality can be added through the TimeZones.jl package, which compiles the IANA time zone database. Both Date and DateTime are based on the ISO 8601 standard, which follows the proleptic Gregorian calendar. One note is that the ISO 8601 standard is particular about BC/BCE dates. In general, the last day of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists. The ISO standard, however, states that 1 BC/BCE is year zero, so 0000-12-31 is the day before 0001-01-01, and year -0001 (yes, negative one for the year) is 2 BC/BCE, year -0002 is 3 BC/BCE, etc.[1]: The notion of the UT second is actually quite fundamental. There are basically two different notions of time generally accepted, one based on the physical rotation of the earth (one full rotation = 1 day), the other based on the SI second (a fixed, constant value). These are radically different! Think about it, a \\\"UT second\\\", as defined relative to the rotation of the earth, may have a different absolute length depending on the day! Anyway, the fact that Date and DateTime are based on UT seconds is a simplifying, yet honest assumption so that things like leap seconds and all their complexity can be avoided. This basis of time is formally called UT or UT1. Basing types on the UT second basically means that every minute has 60 seconds and every day has 24 hours and leads to more natural calculations when working with calendar dates.\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Constructors-1\",\n    \"page\": \"Dates\",\n    \"title\": \"Constructors\",\n    \"category\": \"section\",\n    \"text\": \"Date and DateTime types can be constructed by integer or Period types, by parsing, or through adjusters (more on those later):julia> DateTime(2013)\\n2013-01-01T00:00:00\\n\\njulia> DateTime(2013,7)\\n2013-07-01T00:00:00\\n\\njulia> DateTime(2013,7,1)\\n2013-07-01T00:00:00\\n\\njulia> DateTime(2013,7,1,12)\\n2013-07-01T12:00:00\\n\\njulia> DateTime(2013,7,1,12,30)\\n2013-07-01T12:30:00\\n\\njulia> DateTime(2013,7,1,12,30,59)\\n2013-07-01T12:30:59\\n\\njulia> DateTime(2013,7,1,12,30,59,1)\\n2013-07-01T12:30:59.001\\n\\njulia> Date(2013)\\n2013-01-01\\n\\njulia> Date(2013,7)\\n2013-07-01\\n\\njulia> Date(2013,7,1)\\n2013-07-01\\n\\njulia> Date(Dates.Year(2013),Dates.Month(7),Dates.Day(1))\\n2013-07-01\\n\\njulia> Date(Dates.Month(7),Dates.Year(2013))\\n2013-07-01Date or DateTime parsing is accomplished by the use of format strings. Format strings work by the notion of defining delimited or fixed-width \\\"slots\\\" that contain a period to parse and passing the text to parse and format string to a Date or DateTime constructor, of the form Date(\\\"2015-01-01\\\",\\\"y-m-d\\\") or DateTime(\\\"20150101\\\",\\\"yyyymmdd\\\").Delimited slots are marked by specifying the delimiter the parser should expect between two subsequent periods; so \\\"y-m-d\\\" lets the parser know that between the first and second slots in a date string like \\\"2014-07-16\\\", it should find the - character. The y, m, and d characters let the parser know which periods to parse in each slot.Fixed-width slots are specified by repeating the period character the number of times corresponding to the width with no delimiter between characters. So \\\"yyyymmdd\\\" would correspond to a date string like \\\"20140716\\\". The parser distinguishes a fixed-width slot by the absence of a delimiter, noting the transition \\\"yyyymm\\\" from one period character to the next.Support for text-form month parsing is also supported through the u and U characters, for abbreviated and full-length month names, respectively. By default, only English month names are supported, so u corresponds to \\\"Jan\\\", \\\"Feb\\\", \\\"Mar\\\", etc. And U corresponds to \\\"January\\\", \\\"February\\\", \\\"March\\\", etc. Similar to other name=>value mapping functions dayname and monthname, custom locales can be loaded by passing in the locale=>Dict{String,Int} mapping to the MONTHTOVALUEABBR and MONTHTOVALUE dicts for abbreviated and full-name month names, respectively.One note on parsing performance: using the Date(date_string,format_string) function is fine if only called a few times. If there are many similarly formatted date strings to parse however, it is much more efficient to first create a Dates.DateFormat, and pass it instead of a raw format string.julia> df = DateFormat(\\\"y-m-d\\\");\\n\\njulia> dt = Date(\\\"2015-01-01\\\",df)\\n2015-01-01\\n\\njulia> dt2 = Date(\\\"2015-01-02\\\",df)\\n2015-01-02You can also use the dateformat\\\"\\\" string macro. This macro creates the DateFormat object once when the macro is expanded and uses the same DateFormat object even if a code snippet is run multiple times.julia> for i = 1:10^5\\n           Date(\\\"2015-01-01\\\", dateformat\\\"y-m-d\\\")\\n       endA full suite of parsing and formatting tests and examples is available in stdlib/Dates/test/io.jl.\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Durations/Comparisons-1\",\n    \"page\": \"Dates\",\n    \"title\": \"Durations/Comparisons\",\n    \"category\": \"section\",\n    \"text\": \"Finding the length of time between two Date or DateTime is straightforward given their underlying representation as UTInstant{Day} and UTInstant{Millisecond}, respectively. The difference between Date is returned in the number of Day, and DateTime in the number of Millisecond. Similarly, comparing TimeType is a simple matter of comparing the underlying machine instants (which in turn compares the internal Int64 values).julia> dt = Date(2012,2,29)\\n2012-02-29\\n\\njulia> dt2 = Date(2000,2,1)\\n2000-02-01\\n\\njulia> dump(dt)\\nDate\\n  instant: Dates.UTInstant{Day}\\n    periods: Day\\n      value: Int64 734562\\n\\njulia> dump(dt2)\\nDate\\n  instant: Dates.UTInstant{Day}\\n    periods: Day\\n      value: Int64 730151\\n\\njulia> dt > dt2\\ntrue\\n\\njulia> dt != dt2\\ntrue\\n\\njulia> dt + dt2\\nERROR: MethodError: no method matching +(::Date, ::Date)\\n[...]\\n\\njulia> dt * dt2\\nERROR: MethodError: no method matching *(::Date, ::Date)\\n[...]\\n\\njulia> dt / dt2\\nERROR: MethodError: no method matching /(::Date, ::Date)\\n\\njulia> dt - dt2\\n4411 days\\n\\njulia> dt2 - dt\\n-4411 days\\n\\njulia> dt = DateTime(2012,2,29)\\n2012-02-29T00:00:00\\n\\njulia> dt2 = DateTime(2000,2,1)\\n2000-02-01T00:00:00\\n\\njulia> dt - dt2\\n381110400000 milliseconds\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Accessor-Functions-1\",\n    \"page\": \"Dates\",\n    \"title\": \"Accessor Functions\",\n    \"category\": \"section\",\n    \"text\": \"Because the Date and DateTime types are stored as single Int64 values, date parts or fields can be retrieved through accessor functions. The lowercase accessors return the field as an integer:julia> t = Date(2014, 1, 31)\\n2014-01-31\\n\\njulia> Dates.year(t)\\n2014\\n\\njulia> Dates.month(t)\\n1\\n\\njulia> Dates.week(t)\\n5\\n\\njulia> Dates.day(t)\\n31While propercase return the same value in the corresponding Period type:julia> Dates.Year(t)\\n2014 years\\n\\njulia> Dates.Day(t)\\n31 daysCompound methods are provided, as they provide a measure of efficiency if multiple fields are needed at the same time:julia> Dates.yearmonth(t)\\n(2014, 1)\\n\\njulia> Dates.monthday(t)\\n(1, 31)\\n\\njulia> Dates.yearmonthday(t)\\n(2014, 1, 31)One may also access the underlying UTInstant or integer value:julia> dump(t)\\nDate\\n  instant: Dates.UTInstant{Day}\\n    periods: Day\\n      value: Int64 735264\\n\\njulia> t.instant\\nDates.UTInstant{Day}(735264 days)\\n\\njulia> Dates.value(t)\\n735264\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Query-Functions-1\",\n    \"page\": \"Dates\",\n    \"title\": \"Query Functions\",\n    \"category\": \"section\",\n    \"text\": \"Query functions provide calendrical information about a TimeType. They include information about the day of the week:julia> t = Date(2014, 1, 31)\\n2014-01-31\\n\\njulia> Dates.dayofweek(t)\\n5\\n\\njulia> Dates.dayname(t)\\n\\\"Friday\\\"\\n\\njulia> Dates.dayofweekofmonth(t) # 5th Friday of January\\n5Month of the year:julia> Dates.monthname(t)\\n\\\"January\\\"\\n\\njulia> Dates.daysinmonth(t)\\n31As well as information about the TimeType\\'s year and quarter:julia> Dates.isleapyear(t)\\nfalse\\n\\njulia> Dates.dayofyear(t)\\n31\\n\\njulia> Dates.quarterofyear(t)\\n1\\n\\njulia> Dates.dayofquarter(t)\\n31The dayname and monthname methods can also take an optional locale keyword that can be used to return the name of the day or month of the year for other languages/locales. There are also versions of these functions returning the abbreviated names, namely dayabbr and monthabbr. First the mapping is loaded into the LOCALES variable:julia> french_months = [\\\"janvier\\\", \\\"f\u00e9vrier\\\", \\\"mars\\\", \\\"avril\\\", \\\"mai\\\", \\\"juin\\\",\\n                        \\\"juillet\\\", \\\"ao\u00fbt\\\", \\\"septembre\\\", \\\"octobre\\\", \\\"novembre\\\", \\\"d\u00e9cembre\\\"];\\n\\njulia> french_monts_abbrev = [\\\"janv\\\",\\\"f\u00e9vr\\\",\\\"mars\\\",\\\"avril\\\",\\\"mai\\\",\\\"juin\\\",\\n                              \\\"juil\\\",\\\"ao\u00fbt\\\",\\\"sept\\\",\\\"oct\\\",\\\"nov\\\",\\\"d\u00e9c\\\"];\\n\\njulia> french_days = [\\\"lundi\\\",\\\"mardi\\\",\\\"mercredi\\\",\\\"jeudi\\\",\\\"vendredi\\\",\\\"samedi\\\",\\\"dimanche\\\"];\\n\\njulia> Dates.LOCALES[\\\"french\\\"] = Dates.DateLocale(french_months, french_monts_abbrev, french_days, [\\\"\\\"]);The above mentioned functions can then be used to perform the queries:julia> Dates.dayname(t;locale=\\\"french\\\")\\n\\\"vendredi\\\"\\n\\njulia> Dates.monthname(t;locale=\\\"french\\\")\\n\\\"janvier\\\"\\n\\njulia> Dates.monthabbr(t;locale=\\\"french\\\")\\n\\\"janv\\\"Since the abbreviated versions of the days are not loaded, trying to use the function dayabbr will error.julia> Dates.dayabbr(t;locale=\\\"french\\\")\\nERROR: BoundsError: attempt to access 1-element Array{String,1} at index [5]\\nStacktrace:\\n[...]\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#TimeType-Period-Arithmetic-1\",\n    \"page\": \"Dates\",\n    \"title\": \"TimeType-Period Arithmetic\",\n    \"category\": \"section\",\n    \"text\": \"It\\'s good practice when using any language/date framework to be familiar with how date-period arithmetic is handled as there are some tricky issues to deal with (though much less so for day-precision types).The Dates module approach tries to follow the simple principle of trying to change as little as possible when doing Period arithmetic. This approach is also often known as calendrical arithmetic or what you would probably guess if someone were to ask you the same calculation in a conversation. Why all the fuss about this? Let\\'s take a classic example: add 1 month to January 31st, 2014. What\\'s the answer? Javascript will say March 3 (assumes 31 days). PHP says March 2 (assumes 30 days). The fact is, there is no right answer. In the Dates module, it gives the result of February 28th. How does it figure that out? I like to think of the classic 7-7-7 gambling game in casinos.Now just imagine that instead of 7-7-7, the slots are Year-Month-Day, or in our example, 2014-01-31. When you ask to add 1 month to this date, the month slot is incremented, so now we have 2014-02-31. Then the day number is checked if it is greater than the last valid day of the new month; if it is (as in the case above), the day number is adjusted down to the last valid day (28). What are the ramifications with this approach? Go ahead and add another month to our date, 2014-02-28 + Month(1) == 2014-03-28. What? Were you expecting the last day of March? Nope, sorry, remember the 7-7-7 slots. As few slots as possible are going to change, so we first increment the month slot by 1, 2014-03-28, and boom, we\\'re done because that\\'s a valid date. On the other hand, if we were to add 2 months to our original date, 2014-01-31, then we end up with 2014-03-31, as expected. The other ramification of this approach is a loss in associativity when a specific ordering is forced (i.e. adding things in different orders results in different outcomes). For example:julia> (Date(2014,1,29)+Dates.Day(1)) + Dates.Month(1)\\n2014-02-28\\n\\njulia> (Date(2014,1,29)+Dates.Month(1)) + Dates.Day(1)\\n2014-03-01What\\'s going on there? In the first line, we\\'re adding 1 day to January 29th, which results in 2014-01-30; then we add 1 month, so we get 2014-02-30, which then adjusts down to 2014-02-28. In the second example, we add 1 month first, where we get 2014-02-29, which adjusts down to 2014-02-28, and then add 1 day, which results in 2014-03-01. One design principle that helps in this case is that, in the presence of multiple Periods, the operations will be ordered by the Periods\\' types, not their value or positional order; this means Year will always be added first, then Month, then Week, etc. Hence the following does result in associativity and Just Works:julia> Date(2014,1,29) + Dates.Day(1) + Dates.Month(1)\\n2014-03-01\\n\\njulia> Date(2014,1,29) + Dates.Month(1) + Dates.Day(1)\\n2014-03-01Tricky? Perhaps. What is an innocent Dates user to do? The bottom line is to be aware that explicitly forcing a certain associativity, when dealing with months, may lead to some unexpected results, but otherwise, everything should work as expected. Thankfully, that\\'s pretty much the extent of the odd cases in date-period arithmetic when dealing with time in UT (avoiding the \\\"joys\\\" of dealing with daylight savings, leap seconds, etc.).As a bonus, all period arithmetic objects work directly with ranges:julia> dr = Date(2014,1,29):Day(1):Date(2014,2,3)\\n2014-01-29:1 day:2014-02-03\\n\\njulia> collect(dr)\\n6-element Array{Date,1}:\\n 2014-01-29\\n 2014-01-30\\n 2014-01-31\\n 2014-02-01\\n 2014-02-02\\n 2014-02-03\\n\\njulia> dr = Date(2014,1,29):Dates.Month(1):Date(2014,07,29)\\n2014-01-29:1 month:2014-07-29\\n\\njulia> collect(dr)\\n7-element Array{Date,1}:\\n 2014-01-29\\n 2014-02-28\\n 2014-03-29\\n 2014-04-29\\n 2014-05-29\\n 2014-06-29\\n 2014-07-29\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Adjuster-Functions-1\",\n    \"page\": \"Dates\",\n    \"title\": \"Adjuster Functions\",\n    \"category\": \"section\",\n    \"text\": \"As convenient as date-period arithmetic is, often the kinds of calculations needed on dates take on a calendrical or temporal nature rather than a fixed number of periods. Holidays are a perfect example; most follow rules such as \\\"Memorial Day = Last Monday of May\\\", or \\\"Thanksgiving = 4th Thursday of November\\\". These kinds of temporal expressions deal with rules relative to the calendar, like first or last of the month, next Tuesday, or the first and third Wednesdays, etc.The Dates module provides the adjuster API through several convenient methods that aid in simply and succinctly expressing temporal rules. The first group of adjuster methods deal with the first and last of weeks, months, quarters, and years. They each take a single TimeType as input and return or adjust to the first or last of the desired period relative to the input.julia> Dates.firstdayofweek(Date(2014,7,16)) # Adjusts the input to the Monday of the input\\'s week\\n2014-07-14\\n\\njulia> Dates.lastdayofmonth(Date(2014,7,16)) # Adjusts to the last day of the input\\'s month\\n2014-07-31\\n\\njulia> Dates.lastdayofquarter(Date(2014,7,16)) # Adjusts to the last day of the input\\'s quarter\\n2014-09-30The next two higher-order methods, tonext, and toprev, generalize working with temporal expressions by taking a DateFunction as first argument, along with a starting TimeType. A DateFunction is just a function, usually anonymous, that takes a single TimeType as input and returns a Bool, true indicating a satisfied adjustment criterion. For example:julia> istuesday = x->Dates.dayofweek(x) == Dates.Tuesday; # Returns true if the day of the week of x is Tuesday\\n\\njulia> Dates.tonext(istuesday, Date(2014,7,13)) # 2014-07-13 is a Sunday\\n2014-07-15\\n\\njulia> Dates.tonext(Date(2014,7,13), Dates.Tuesday) # Convenience method provided for day of the week adjustments\\n2014-07-15This is useful with the do-block syntax for more complex temporal expressions:julia> Dates.tonext(Date(2014,7,13)) do x\\n           # Return true on the 4th Thursday of November (Thanksgiving)\\n           Dates.dayofweek(x) == Dates.Thursday &&\\n           Dates.dayofweekofmonth(x) == 4 &&\\n           Dates.month(x) == Dates.November\\n       end\\n2014-11-27The Base.filter method can be used to obtain all valid dates/moments in a specified range:# Pittsburgh street cleaning; Every 2nd Tuesday from April to November\\n# Date range from January 1st, 2014 to January 1st, 2015\\njulia> dr = Dates.Date(2014):Day(1):Dates.Date(2015);\\n\\njulia> filter(dr) do x\\n           Dates.dayofweek(x) == Dates.Tue &&\\n           Dates.April <= Dates.month(x) <= Dates.Nov &&\\n           Dates.dayofweekofmonth(x) == 2\\n       end\\n8-element Array{Date,1}:\\n 2014-04-08\\n 2014-05-13\\n 2014-06-10\\n 2014-07-08\\n 2014-08-12\\n 2014-09-09\\n 2014-10-14\\n 2014-11-11Additional examples and tests are available in stdlib/Dates/test/adjusters.jl.\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Period-Types-1\",\n    \"page\": \"Dates\",\n    \"title\": \"Period Types\",\n    \"category\": \"section\",\n    \"text\": \"Periods are a human view of discrete, sometimes irregular durations of time. Consider 1 month; it could represent, in days, a value of 28, 29, 30, or 31 depending on the year and month context. Or a year could represent 365 or 366 days in the case of a leap year. Period types are simple Int64 wrappers and are constructed by wrapping any Int64 convertible type, i.e. Year(1) or Month(3.0). Arithmetic between Period of the same type behave like integers, and limited Period-Real arithmetic is available.julia> y1 = Dates.Year(1)\\n1 year\\n\\njulia> y2 = Dates.Year(2)\\n2 years\\n\\njulia> y3 = Dates.Year(10)\\n10 years\\n\\njulia> y1 + y2\\n3 years\\n\\njulia> div(y3,y2)\\n5\\n\\njulia> y3 - y2\\n8 years\\n\\njulia> y3 % y2\\n0 years\\n\\njulia> div(y3,3) # mirrors integer division\\n3 years\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Rounding-1\",\n    \"page\": \"Dates\",\n    \"title\": \"Rounding\",\n    \"category\": \"section\",\n    \"text\": \"Date and DateTime values can be rounded to a specified resolution (e.g., 1 month or 15 minutes) with floor, ceil, or round:julia> floor(Date(1985, 8, 16), Dates.Month)\\n1985-08-01\\n\\njulia> ceil(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))\\n2013-02-13T00:45:00\\n\\njulia> round(DateTime(2016, 8, 6, 20, 15), Dates.Day)\\n2016-08-07T00:00:00Unlike the numeric round method, which breaks ties toward the even number by default, the TimeTyperound method uses the RoundNearestTiesUp rounding mode. (It\\'s difficult to guess what breaking ties to nearest \\\"even\\\" TimeType would entail.) Further details on the available RoundingMode s can be found in the API reference.Rounding should generally behave as expected, but there are a few cases in which the expected behaviour is not obvious.\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Rounding-Epoch-1\",\n    \"page\": \"Dates\",\n    \"title\": \"Rounding Epoch\",\n    \"category\": \"section\",\n    \"text\": \"In many cases, the resolution specified for rounding (e.g., Dates.Second(30)) divides evenly into the next largest period (in this case, Dates.Minute(1)). But rounding behaviour in cases in which this is not true may lead to confusion. What is the expected result of rounding a DateTime to the nearest 10 hours?julia> round(DateTime(2016, 7, 17, 11, 55), Dates.Hour(10))\\n2016-07-17T12:00:00That may seem confusing, given that the hour (12) is not divisible by 10. The reason that 2016-07-17T12:00:00 was chosen is that it is 17,676,660 hours after 0000-01-01T00:00:00, and 17,676,660 is divisible by 10.As Julia Date and DateTime values are represented according to the ISO 8601 standard, 0000-01-01T00:00:00 was chosen as base (or \\\"rounding epoch\\\") from which to begin the count of days (and milliseconds) used in rounding calculations. (Note that this differs slightly from Julia\\'s internal representation of Date s using Rata Die notation; but since the ISO 8601 standard is most visible to the end user, 0000-01-01T00:00:00 was chosen as the rounding epoch instead of the 0000-12-31T00:00:00 used internally to minimize confusion.)The only exception to the use of 0000-01-01T00:00:00 as the rounding epoch is when rounding to weeks. Rounding to the nearest week will always return a Monday (the first day of the week as specified by ISO 8601). For this reason, we use 0000-01-03T00:00:00 (the first day of the first week of year 0000, as defined by ISO 8601) as the base when rounding to a number of weeks.Here is a related case in which the expected behaviour is not necessarily obvious: What happens when we round to the nearest P(2), where P is a Period type? In some cases (specifically, when P <: Dates.TimePeriod) the answer is clear:julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Hour(2))\\n2016-07-17T08:00:00\\n\\njulia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Minute(2))\\n2016-07-17T08:56:00This seems obvious, because two of each of these periods still divides evenly into the next larger order period. But in the case of two months (which still divides evenly into one year), the answer may be surprising:julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Month(2))\\n2016-07-01T00:00:00Why round to the first day in July, even though it is month 7 (an odd number)? The key is that months are 1-indexed (the first month is assigned 1), unlike hours, minutes, seconds, and milliseconds (the first of which are assigned 0).This means that rounding a DateTime to an even multiple of seconds, minutes, hours, or years (because the ISO 8601 specification includes a year zero) will result in a DateTime with an even value in that field, while rounding a DateTime to an even multiple of months will result in the months field having an odd value. Because both months and years may contain an irregular number of days, whether rounding to an even number of days will result in an even value in the days field is uncertain.See the API reference for additional information on methods exported from the Dates module.\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#stdlib-dates-api-1\",\n    \"page\": \"Dates\",\n    \"title\": \"API reference\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Period\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Period\",\n    \"category\": \"type\",\n    \"text\": \"Period\\nYear\\nMonth\\nWeek\\nDay\\nHour\\nMinute\\nSecond\\nMillisecond\\nMicrosecond\\nNanosecond\\n\\nPeriod types represent discrete, human representations of time.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.CompoundPeriod\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.CompoundPeriod\",\n    \"category\": \"type\",\n    \"text\": \"CompoundPeriod\\n\\nA CompoundPeriod is useful for expressing time periods that are not a fixed multiple of smaller periods. For example, \\\"a year and a  day\\\" is not a fixed number of days, but can be expressed using a CompoundPeriod. In fact, a CompoundPeriod is automatically generated by addition of different period types, e.g. Year(1) + Day(1) produces a CompoundPeriod result.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Instant\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Instant\",\n    \"category\": \"type\",\n    \"text\": \"Instant\\n\\nInstant types represent integer-based, machine representations of time as continuous timelines starting from an epoch.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.UTInstant\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.UTInstant\",\n    \"category\": \"type\",\n    \"text\": \"UTInstant{T}\\n\\nThe UTInstant represents a machine timeline based on UT time (1 day = one revolution of the earth). The T is a Period parameter that indicates the resolution or precision of the instant.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.TimeType\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.TimeType\",\n    \"category\": \"type\",\n    \"text\": \"TimeType\\n\\nTimeType types wrap Instant machine instances to provide human representations of the machine instant. Time, DateTime and Date are subtypes of TimeType.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.DateTime\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.DateTime\",\n    \"category\": \"type\",\n    \"text\": \"DateTime\\n\\nDateTime wraps a UTInstant{Millisecond} and interprets it according to the proleptic Gregorian calendar.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Date\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Date\",\n    \"category\": \"type\",\n    \"text\": \"Date\\n\\nDate wraps a UTInstant{Day} and interprets it according to the proleptic Gregorian calendar.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Time\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Time\",\n    \"category\": \"type\",\n    \"text\": \"Time\\n\\nTime wraps a Nanosecond and represents a specific moment in a 24-hour day.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates-and-Time-Types-1\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates and Time Types\",\n    \"category\": \"section\",\n    \"text\": \"Dates.Period\\nDates.CompoundPeriod\\nDates.Instant\\nDates.UTInstant\\nDates.TimeType\\nDates.DateTime\\nDates.Date\\nDates.Time\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.DateTime-NTuple{7,Int64}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.DateTime\",\n    \"category\": \"method\",\n    \"text\": \"DateTime(y, [m, d, h, mi, s, ms]) -> DateTime\\n\\nConstruct a DateTime type by parts. Arguments must be convertible to Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.DateTime-Tuple{Period}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.DateTime\",\n    \"category\": \"method\",\n    \"text\": \"DateTime(periods::Period...) -> DateTime\\n\\nConstruct a DateTime type by Period type parts. Arguments may be in any order. DateTime parts not provided will default to the value of Dates.default(period).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.DateTime-Tuple{Function,Vararg{Any,N} where N}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.DateTime\",\n    \"category\": \"method\",\n    \"text\": \"DateTime(f::Function, y[, m, d, h, mi, s]; step=Day(1), limit=10000) -> DateTime\\n\\nCreate a DateTime through the adjuster API. The starting point will be constructed from the provided y, m, d... arguments, and will be adjusted until f::Function returns true. The step size in adjusting can be provided manually through the step keyword. limit provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that f::Function is never satisfied).\\n\\nExamples\\n\\njulia> DateTime(dt -> Dates.second(dt) == 40, 2010, 10, 20, 10; step = Dates.Second(1))\\n2010-10-20T10:00:40\\n\\njulia> DateTime(dt -> Dates.hour(dt) == 20, 2010, 10, 20, 10; step = Dates.Hour(1), limit = 5)\\nERROR: ArgumentError: Adjustment limit reached: 5 iterations\\nStacktrace:\\n[...]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.DateTime-Tuple{TimeType}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.DateTime\",\n    \"category\": \"method\",\n    \"text\": \"DateTime(dt::Date) -> DateTime\\n\\nConvert a Date to a DateTime. The hour, minute, second, and millisecond parts of the new DateTime are assumed to be zero.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.DateTime-Tuple{AbstractString,AbstractString}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.DateTime\",\n    \"category\": \"method\",\n    \"text\": \"DateTime(dt::AbstractString, format::AbstractString; locale=\\\"english\\\") -> DateTime\\n\\nConstruct a DateTime by parsing the dt date time string following the pattern given in the format string.\\n\\nThis method creates a DateFormat object each time it is called. If you are parsing many date time strings of the same format, consider creating a DateFormat object once and using that as the second argument instead.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.format\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.format\",\n    \"category\": \"function\",\n    \"text\": \"format(io::IO, tok::AbstractDateToken, dt::TimeType, locale)\\n\\nFormat the tok token from dt and write it to io. The formatting can be based on locale.\\n\\nAll subtypes of AbstractDateToken must define this method in order to be able to print a Date / DateTime object according to a DateFormat containing that token.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.DateFormat\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.DateFormat\",\n    \"category\": \"type\",\n    \"text\": \"DateFormat(format::AbstractString, locale=\\\"english\\\") -> DateFormat\\n\\nConstruct a date formatting object that can be used for parsing date strings or formatting a date object as a string. The following character codes can be used to construct the format string:\\n\\nCode Matches Comment\\ny 1996, 96 Returns year of 1996, 0096\\nY 1996, 96 Returns year of 1996, 0096. Equivalent to y\\nm 1, 01 Matches 1 or 2-digit months\\nu Jan Matches abbreviated months according to the locale keyword\\nU January Matches full month names according to the locale keyword\\nd 1, 01 Matches 1 or 2-digit days\\nH 00 Matches hours\\nM 00 Matches minutes\\nS 00 Matches seconds\\ns .500 Matches milliseconds\\ne Mon, Tues Matches abbreviated days of the week\\nE Monday Matches full name days of the week\\nyyyymmdd 19960101 Matches fixed-width year, month, and day\\n\\nCharacters not listed above are normally treated as delimiters between date and time slots. For example a dt string of \\\"1996-01-15T00:00:00.0\\\" would have a format string like \\\"y-m-dTH:M:S.s\\\". If you need to use a code character as a delimiter you can escape it using backslash. The date \\\"1995y01m\\\" would have the format \\\"y\\\\ym\\\\m\\\".\\n\\nCreating a DateFormat object is expensive. Whenever possible, create it once and use it many times or try the dateformat\\\"\\\" string macro. Using this macro creates the DateFormat object once at macro expansion time and reuses it later. see @dateformat_str.\\n\\nSee DateTime and format for how to use a DateFormat object to parse and write Date strings respectively.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.@dateformat_str\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.@dateformat_str\",\n    \"category\": \"macro\",\n    \"text\": \"dateformat\\\"Y-m-d H:M:S\\\"\\n\\nCreate a DateFormat object. Similar to DateFormat(\\\"Y-m-d H:M:S\\\") but creates the DateFormat object once during macro expansion.\\n\\nSee DateFormat for details about format specifiers.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.DateTime-Tuple{AbstractString,DateFormat}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.DateTime\",\n    \"category\": \"method\",\n    \"text\": \"DateTime(dt::AbstractString, df::DateFormat) -> DateTime\\n\\nConstruct a DateTime by parsing the dt date time string following the pattern given in the DateFormat object. Similar to DateTime(::AbstractString, ::AbstractString) but more efficient when repeatedly parsing similarly formatted date time strings with a pre-created DateFormat object.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Date-Tuple{Int64,Int64,Int64}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Date\",\n    \"category\": \"method\",\n    \"text\": \"Date(y, [m, d]) -> Date\\n\\nConstruct a Date type by parts. Arguments must be convertible to Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Date-Tuple{Period}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Date\",\n    \"category\": \"method\",\n    \"text\": \"Date(period::Period...) -> Date\\n\\nConstruct a Date type by Period type parts. Arguments may be in any order. Date parts not provided will default to the value of Dates.default(period).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Date-Tuple{Function,Any,Any,Any}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Date\",\n    \"category\": \"method\",\n    \"text\": \"Date(f::Function, y[, m, d]; step=Day(1), limit=10000) -> Date\\n\\nCreate a Date through the adjuster API. The starting point will be constructed from the provided y, m, d arguments, and will be adjusted until f::Function returns true. The step size in adjusting can be provided manually through the step keyword. limit provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (given that f::Function is never satisfied).\\n\\nExamples\\n\\njulia> Date(date -> Dates.week(date) == 20, 2010, 01, 01)\\n2010-05-17\\n\\njulia> Date(date -> Dates.year(date) == 2010, 2000, 01, 01)\\n2010-01-01\\n\\njulia> Date(date -> Dates.month(date) == 10, 2000, 01, 01; limit = 5)\\nERROR: ArgumentError: Adjustment limit reached: 5 iterations\\nStacktrace:\\n[...]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Date-Tuple{TimeType}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Date\",\n    \"category\": \"method\",\n    \"text\": \"Date(dt::DateTime) -> Date\\n\\nConvert a DateTime to a Date. The hour, minute, second, and millisecond parts of the DateTime are truncated, so only the year, month and day parts are used in construction.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Date-Tuple{AbstractString,AbstractString}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Date\",\n    \"category\": \"method\",\n    \"text\": \"Date(d::AbstractString, format::AbstractString; locale=\\\"english\\\") -> Date\\n\\nConstruct a Date by parsing the d date string following the pattern given in the format string.\\n\\nThis method creates a DateFormat object each time it is called. If you are parsing many date strings of the same format, consider creating a DateFormat object once and using that as the second argument instead.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Date-Tuple{AbstractString,DateFormat}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Date\",\n    \"category\": \"method\",\n    \"text\": \"Date(d::AbstractString, df::DateFormat) -> Date\\n\\nParse a date from a date string d using a DateFormat object df.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Time-NTuple{5,Int64}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Time\",\n    \"category\": \"method\",\n    \"text\": \"Time(h, [mi, s, ms, us, ns]) -> Time\\n\\nConstruct a Time type by parts. Arguments must be convertible to Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Time-Tuple{TimePeriod}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Time\",\n    \"category\": \"method\",\n    \"text\": \"Time(period::TimePeriod...) -> Time\\n\\nConstruct a Time type by Period type parts. Arguments may be in any order. Time parts not provided will default to the value of Dates.default(period).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Time-Tuple{Function,Vararg{Any,N} where N}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Time\",\n    \"category\": \"method\",\n    \"text\": \"Time(f::Function, h, mi=0; step::Period=Second(1), limit::Int=10000)\\nTime(f::Function, h, mi, s; step::Period=Millisecond(1), limit::Int=10000)\\nTime(f::Function, h, mi, s, ms; step::Period=Microsecond(1), limit::Int=10000)\\nTime(f::Function, h, mi, s, ms, us; step::Period=Nanosecond(1), limit::Int=10000)\\n\\nCreate a Time through the adjuster API. The starting point will be constructed from the provided h, mi, s, ms, us arguments, and will be adjusted until f::Function returns true. The step size in adjusting can be provided manually through the step keyword. limit provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that f::Function is never satisfied). Note that the default step will adjust to allow for greater precision for the given arguments; i.e. if hour, minute, and second arguments are provided, the default step will be Millisecond(1) instead of Second(1).\\n\\nExamples\\n\\njulia> Dates.Time(t -> Dates.minute(t) == 30, 20)\\n20:30:00\\n\\njulia> Dates.Time(t -> Dates.minute(t) == 0, 20)\\n20:00:00\\n\\njulia> Dates.Time(t -> Dates.hour(t) == 10, 3; limit = 5)\\nERROR: ArgumentError: Adjustment limit reached: 5 iterations\\nStacktrace:\\n[...]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Time-Tuple{DateTime}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Time\",\n    \"category\": \"method\",\n    \"text\": \"Time(dt::DateTime) -> Time\\n\\nConvert a DateTime to a Time. The hour, minute, second, and millisecond parts of the DateTime are used to create the new Time. Microsecond and nanoseconds are zero by default.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.now-Tuple{}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.now\",\n    \"category\": \"method\",\n    \"text\": \"now() -> DateTime\\n\\nReturn a DateTime corresponding to the user\\'s system time including the system timezone locale.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.now-Tuple{Type{UTC}}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.now\",\n    \"category\": \"method\",\n    \"text\": \"now(::Type{UTC}) -> DateTime\\n\\nReturn a DateTime corresponding to the user\\'s system time as UTC/GMT.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Base.eps\",\n    \"page\": \"Dates\",\n    \"title\": \"Base.eps\",\n    \"category\": \"function\",\n    \"text\": \"eps(::DateTime) -> Millisecond\\neps(::Date) -> Day\\neps(::Time) -> Nanosecond\\n\\nReturns Millisecond(1) for DateTime values, Day(1) for Date values, and Nanosecond(1) for Time values.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates-Functions-1\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates Functions\",\n    \"category\": \"section\",\n    \"text\": \"Dates.DateTime(::Int64, ::Int64, ::Int64, ::Int64, ::Int64, ::Int64, ::Int64)\\nDates.DateTime(::Dates.Period)\\nDates.DateTime(::Function, ::Any...)\\nDates.DateTime(::Dates.TimeType)\\nDates.DateTime(::AbstractString, ::AbstractString)\\nDates.format\\nDates.DateFormat\\nDates.@dateformat_str\\nDates.DateTime(::AbstractString, ::Dates.DateFormat)\\nDates.Date(::Int64, ::Int64, ::Int64)\\nDates.Date(::Dates.Period)\\nDates.Date(::Function, ::Any, ::Any, ::Any)\\nDates.Date(::Dates.TimeType)\\nDates.Date(::AbstractString, ::AbstractString)\\nDates.Date(::AbstractString, ::Dates.DateFormat)\\nDates.Time(::Int64::Int64, ::Int64, ::Int64, ::Int64, ::Int64)\\nDates.Time(::Dates.TimePeriod)\\nDates.Time(::Function, ::Any...)\\nDates.Time(::Dates.DateTime)\\nDates.now()\\nDates.now(::Type{Dates.UTC})\\nBase.eps\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.year\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.year\",\n    \"category\": \"function\",\n    \"text\": \"year(dt::TimeType) -> Int64\\n\\nThe year of a Date or DateTime as an Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.month\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.month\",\n    \"category\": \"function\",\n    \"text\": \"month(dt::TimeType) -> Int64\\n\\nThe month of a Date or DateTime as an Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.week\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.week\",\n    \"category\": \"function\",\n    \"text\": \"week(dt::TimeType) -> Int64\\n\\nReturn the ISO week date of a Date or DateTime as an Int64. Note that the first week of a year is the week that contains the first Thursday of the year, which can result in dates prior to January 4th being in the last week of the previous year. For example, week(Date(2005, 1, 1)) is the 53rd week of 2004.\\n\\nExamples\\n\\njulia> Dates.week(Date(1989, 6, 22))\\n25\\n\\njulia> Dates.week(Date(2005, 1, 1))\\n53\\n\\njulia> Dates.week(Date(2004, 12, 31))\\n53\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.day\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.day\",\n    \"category\": \"function\",\n    \"text\": \"day(dt::TimeType) -> Int64\\n\\nThe day of month of a Date or DateTime as an Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.hour\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.hour\",\n    \"category\": \"function\",\n    \"text\": \"hour(dt::DateTime) -> Int64\\n\\nThe hour of day of a DateTime as an Int64.\\n\\n\\n\\n\\n\\nhour(t::Time) -> Int64\\n\\nThe hour of a Time as an Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.minute\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.minute\",\n    \"category\": \"function\",\n    \"text\": \"minute(dt::DateTime) -> Int64\\n\\nThe minute of a DateTime as an Int64.\\n\\n\\n\\n\\n\\nminute(t::Time) -> Int64\\n\\nThe minute of a Time as an Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.second\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.second\",\n    \"category\": \"function\",\n    \"text\": \"second(dt::DateTime) -> Int64\\n\\nThe second of a DateTime as an Int64.\\n\\n\\n\\n\\n\\nsecond(t::Time) -> Int64\\n\\nThe second of a Time as an Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.millisecond\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.millisecond\",\n    \"category\": \"function\",\n    \"text\": \"millisecond(dt::DateTime) -> Int64\\n\\nThe millisecond of a DateTime as an Int64.\\n\\n\\n\\n\\n\\nmillisecond(t::Time) -> Int64\\n\\nThe millisecond of a Time as an Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.microsecond\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.microsecond\",\n    \"category\": \"function\",\n    \"text\": \"microsecond(t::Time) -> Int64\\n\\nThe microsecond of a Time as an Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.nanosecond\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.nanosecond\",\n    \"category\": \"function\",\n    \"text\": \"nanosecond(t::Time) -> Int64\\n\\nThe nanosecond of a Time as an Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Year-Tuple{TimeType}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Year\",\n    \"category\": \"method\",\n    \"text\": \"Year(v)\\n\\nConstruct a Year object with the given v value. Input must be losslessly convertible to an Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Month-Tuple{TimeType}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Month\",\n    \"category\": \"method\",\n    \"text\": \"Month(v)\\n\\nConstruct a Month object with the given v value. Input must be losslessly convertible to an Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Week-Tuple{TimeType}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Week\",\n    \"category\": \"method\",\n    \"text\": \"Week(v)\\n\\nConstruct a Week object with the given v value. Input must be losslessly convertible to an Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Day-Tuple{TimeType}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Day\",\n    \"category\": \"method\",\n    \"text\": \"Day(v)\\n\\nConstruct a Day object with the given v value. Input must be losslessly convertible to an Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Hour-Tuple{DateTime}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Hour\",\n    \"category\": \"method\",\n    \"text\": \"Hour(dt::DateTime) -> Hour\\n\\nThe hour part of a DateTime as a Hour.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Minute-Tuple{DateTime}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Minute\",\n    \"category\": \"method\",\n    \"text\": \"Minute(dt::DateTime) -> Minute\\n\\nThe minute part of a DateTime as a Minute.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Second-Tuple{DateTime}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Second\",\n    \"category\": \"method\",\n    \"text\": \"Second(dt::DateTime) -> Second\\n\\nThe second part of a DateTime as a Second.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Millisecond-Tuple{DateTime}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Millisecond\",\n    \"category\": \"method\",\n    \"text\": \"Millisecond(dt::DateTime) -> Millisecond\\n\\nThe millisecond part of a DateTime as a Millisecond.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Microsecond-Tuple{Time}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Microsecond\",\n    \"category\": \"method\",\n    \"text\": \"Microsecond(dt::Time) -> Microsecond\\n\\nThe microsecond part of a Time as a Microsecond.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Nanosecond-Tuple{Time}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Nanosecond\",\n    \"category\": \"method\",\n    \"text\": \"Nanosecond(dt::Time) -> Nanosecond\\n\\nThe nanosecond part of a Time as a Nanosecond.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.yearmonth\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.yearmonth\",\n    \"category\": \"function\",\n    \"text\": \"yearmonth(dt::TimeType) -> (Int64, Int64)\\n\\nSimultaneously return the year and month parts of a Date or DateTime.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.monthday\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.monthday\",\n    \"category\": \"function\",\n    \"text\": \"monthday(dt::TimeType) -> (Int64, Int64)\\n\\nSimultaneously return the month and day parts of a Date or DateTime.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.yearmonthday\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.yearmonthday\",\n    \"category\": \"function\",\n    \"text\": \"yearmonthday(dt::TimeType) -> (Int64, Int64, Int64)\\n\\nSimultaneously return the year, month and day parts of a Date or DateTime.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Accessor-Functions-2\",\n    \"page\": \"Dates\",\n    \"title\": \"Accessor Functions\",\n    \"category\": \"section\",\n    \"text\": \"Dates.year\\nDates.month\\nDates.week\\nDates.day\\nDates.hour\\nDates.minute\\nDates.second\\nDates.millisecond\\nDates.microsecond\\nDates.nanosecond\\nDates.Year(::Dates.TimeType)\\nDates.Month(::Dates.TimeType)\\nDates.Week(::Dates.TimeType)\\nDates.Day(::Dates.TimeType)\\nDates.Hour(::DateTime)\\nDates.Minute(::DateTime)\\nDates.Second(::DateTime)\\nDates.Millisecond(::DateTime)\\nDates.Microsecond(::Dates.Time)\\nDates.Nanosecond(::Dates.Time)\\nDates.yearmonth\\nDates.monthday\\nDates.yearmonthday\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.dayname\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.dayname\",\n    \"category\": \"function\",\n    \"text\": \"dayname(dt::TimeType; locale=\\\"english\\\") -> String\\n\\nReturn the full day name corresponding to the day of the week of the Date or DateTime in the given locale.\\n\\nExamples\\n\\njulia> Dates.dayname(Date(\\\"2000-01-01\\\"))\\n\\\"Saturday\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.dayabbr\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.dayabbr\",\n    \"category\": \"function\",\n    \"text\": \"dayabbr(dt::TimeType; locale=\\\"english\\\") -> String\\n\\nReturn the abbreviated name corresponding to the day of the week of the Date or DateTime in the given locale.\\n\\nExamples\\n\\njulia> Dates.dayabbr(Date(\\\"2000-01-01\\\"))\\n\\\"Sat\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.dayofweek\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.dayofweek\",\n    \"category\": \"function\",\n    \"text\": \"dayofweek(dt::TimeType) -> Int64\\n\\nReturn the day of the week as an Int64 with 1 = Monday, 2 = Tuesday, etc..\\n\\nExamples\\n\\njulia> Dates.dayofweek(Date(\\\"2000-01-01\\\"))\\n6\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.dayofmonth\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.dayofmonth\",\n    \"category\": \"function\",\n    \"text\": \"dayofmonth(dt::TimeType) -> Int64\\n\\nThe day of month of a Date or DateTime as an Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.dayofweekofmonth\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.dayofweekofmonth\",\n    \"category\": \"function\",\n    \"text\": \"dayofweekofmonth(dt::TimeType) -> Int\\n\\nFor the day of week of dt, return which number it is in dt\\'s month. So if the day of the week of dt is Monday, then 1 = First Monday of the month, 2 = Second Monday of the month, etc. In the range 1:5.\\n\\nExamples\\n\\n```jldoctest julia> Dates.dayofweekofmonth(Date(\\\"2000-02-01\\\")) 1\\n\\njulia> Dates.dayofweekofmonth(Date(\\\"2000-02-08\\\")) 2\\n\\njulia> Dates.dayofweekofmonth(Date(\\\"2000-02-15\\\")) 3 ````\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.daysofweekinmonth\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.daysofweekinmonth\",\n    \"category\": \"function\",\n    \"text\": \"daysofweekinmonth(dt::TimeType) -> Int\\n\\nFor the day of week of dt, return the total number of that day of the week in dt\\'s month. Returns 4 or 5. Useful in temporal expressions for specifying the last day of a week in a month by including dayofweekofmonth(dt) == daysofweekinmonth(dt) in the adjuster function.\\n\\nExamples\\n\\njulia> Dates.daysofweekinmonth(Date(\\\"2005-01-01\\\"))\\n5\\n\\njulia> Dates.daysofweekinmonth(Date(\\\"2005-01-04\\\"))\\n4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.monthname\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.monthname\",\n    \"category\": \"function\",\n    \"text\": \"monthname(dt::TimeType; locale=\\\"english\\\") -> String\\n\\nReturn the full name of the month of the Date or DateTime in the given locale.\\n\\nExamples\\n\\njulia> Dates.monthname(Date(\\\"2005-01-04\\\"))\\n\\\"January\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.monthabbr\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.monthabbr\",\n    \"category\": \"function\",\n    \"text\": \"monthabbr(dt::TimeType; locale=\\\"english\\\") -> String\\n\\nReturn the abbreviated month name of the Date or DateTime in the given locale.\\n\\nExamples\\n\\njulia> Dates.monthabbr(Date(\\\"2005-01-04\\\"))\\n\\\"Jan\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.daysinmonth\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.daysinmonth\",\n    \"category\": \"function\",\n    \"text\": \"daysinmonth(dt::TimeType) -> Int\\n\\nReturn the number of days in the month of dt. Value will be 28, 29, 30, or 31.\\n\\nExamples\\n\\njulia> Dates.daysinmonth(Date(\\\"2000-01\\\"))\\n31\\n\\njulia> Dates.daysinmonth(Date(\\\"2001-02\\\"))\\n28\\n\\njulia> Dates.daysinmonth(Date(\\\"2000-02\\\"))\\n29\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.isleapyear\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.isleapyear\",\n    \"category\": \"function\",\n    \"text\": \"isleapyear(dt::TimeType) -> Bool\\n\\nReturn true if the year of dt is a leap year.\\n\\nExamples\\n\\njulia> Dates.isleapyear(Date(\\\"2004\\\"))\\ntrue\\n\\njulia> Dates.isleapyear(Date(\\\"2005\\\"))\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.dayofyear\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.dayofyear\",\n    \"category\": \"function\",\n    \"text\": \"dayofyear(dt::TimeType) -> Int\\n\\nReturn the day of the year for dt with January 1st being day 1.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.daysinyear\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.daysinyear\",\n    \"category\": \"function\",\n    \"text\": \"daysinyear(dt::TimeType) -> Int\\n\\nReturn 366 if the year of dt is a leap year, otherwise return 365.\\n\\nExamples\\n\\njulia> Dates.daysinyear(1999)\\n365\\n\\njulia> Dates.daysinyear(2000)\\n366\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.quarterofyear\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.quarterofyear\",\n    \"category\": \"function\",\n    \"text\": \"quarterofyear(dt::TimeType) -> Int\\n\\nReturn the quarter that dt resides in. Range of value is 1:4.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.dayofquarter\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.dayofquarter\",\n    \"category\": \"function\",\n    \"text\": \"dayofquarter(dt::TimeType) -> Int\\n\\nReturn the day of the current quarter of dt. Range of value is 1:92.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Query-Functions-2\",\n    \"page\": \"Dates\",\n    \"title\": \"Query Functions\",\n    \"category\": \"section\",\n    \"text\": \"Dates.dayname\\nDates.dayabbr\\nDates.dayofweek\\nDates.dayofmonth\\nDates.dayofweekofmonth\\nDates.daysofweekinmonth\\nDates.monthname\\nDates.monthabbr\\nDates.daysinmonth\\nDates.isleapyear\\nDates.dayofyear\\nDates.daysinyear\\nDates.quarterofyear\\nDates.dayofquarter\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Base.trunc-Tuple{TimeType,Type{Period}}\",\n    \"page\": \"Dates\",\n    \"title\": \"Base.trunc\",\n    \"category\": \"method\",\n    \"text\": \"trunc(dt::TimeType, ::Type{Period}) -> TimeType\\n\\nTruncates the value of dt according to the provided Period type.\\n\\nExamples\\n\\njulia> trunc(Dates.DateTime(\\\"1996-01-01T12:30:00\\\"), Dates.Day)\\n1996-01-01T00:00:00\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.firstdayofweek\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.firstdayofweek\",\n    \"category\": \"function\",\n    \"text\": \"firstdayofweek(dt::TimeType) -> TimeType\\n\\nAdjusts dt to the Monday of its week.\\n\\nExamples\\n\\njulia> Dates.firstdayofweek(DateTime(\\\"1996-01-05T12:30:00\\\"))\\n1996-01-01T00:00:00\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.lastdayofweek\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.lastdayofweek\",\n    \"category\": \"function\",\n    \"text\": \"lastdayofweek(dt::TimeType) -> TimeType\\n\\nAdjusts dt to the Sunday of its week.\\n\\nExamples\\n\\njulia> Dates.lastdayofweek(DateTime(\\\"1996-01-05T12:30:00\\\"))\\n1996-01-07T00:00:00\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.firstdayofmonth\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.firstdayofmonth\",\n    \"category\": \"function\",\n    \"text\": \"firstdayofmonth(dt::TimeType) -> TimeType\\n\\nAdjusts dt to the first day of its month.\\n\\nExamples\\n\\njulia> Dates.firstdayofmonth(DateTime(\\\"1996-05-20\\\"))\\n1996-05-01T00:00:00\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.lastdayofmonth\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.lastdayofmonth\",\n    \"category\": \"function\",\n    \"text\": \"lastdayofmonth(dt::TimeType) -> TimeType\\n\\nAdjusts dt to the last day of its month.\\n\\nExamples\\n\\njulia> Dates.lastdayofmonth(DateTime(\\\"1996-05-20\\\"))\\n1996-05-31T00:00:00\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.firstdayofyear\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.firstdayofyear\",\n    \"category\": \"function\",\n    \"text\": \"firstdayofyear(dt::TimeType) -> TimeType\\n\\nAdjusts dt to the first day of its year.\\n\\nExamples\\n\\njulia> Dates.firstdayofyear(DateTime(\\\"1996-05-20\\\"))\\n1996-01-01T00:00:00\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.lastdayofyear\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.lastdayofyear\",\n    \"category\": \"function\",\n    \"text\": \"lastdayofyear(dt::TimeType) -> TimeType\\n\\nAdjusts dt to the last day of its year.\\n\\nExamples\\n\\njulia> Dates.lastdayofyear(DateTime(\\\"1996-05-20\\\"))\\n1996-12-31T00:00:00\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.firstdayofquarter\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.firstdayofquarter\",\n    \"category\": \"function\",\n    \"text\": \"firstdayofquarter(dt::TimeType) -> TimeType\\n\\nAdjusts dt to the first day of its quarter.\\n\\nExamples\\n\\njulia> Dates.firstdayofquarter(DateTime(\\\"1996-05-20\\\"))\\n1996-04-01T00:00:00\\n\\njulia> Dates.firstdayofquarter(DateTime(\\\"1996-08-20\\\"))\\n1996-07-01T00:00:00\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.lastdayofquarter\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.lastdayofquarter\",\n    \"category\": \"function\",\n    \"text\": \"lastdayofquarter(dt::TimeType) -> TimeType\\n\\nAdjusts dt to the last day of its quarter.\\n\\nExamples\\n\\njulia> Dates.lastdayofquarter(DateTime(\\\"1996-05-20\\\"))\\n1996-06-30T00:00:00\\n\\njulia> Dates.lastdayofquarter(DateTime(\\\"1996-08-20\\\"))\\n1996-09-30T00:00:00\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.tonext-Tuple{TimeType,Int64}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.tonext\",\n    \"category\": \"method\",\n    \"text\": \"tonext(dt::TimeType, dow::Int; same::Bool=false) -> TimeType\\n\\nAdjusts dt to the next day of week corresponding to dow with 1 = Monday, 2 = Tuesday, etc. Setting same=true allows the current dt to be considered as the next dow, allowing for no adjustment to occur.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.toprev-Tuple{TimeType,Int64}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.toprev\",\n    \"category\": \"method\",\n    \"text\": \"toprev(dt::TimeType, dow::Int; same::Bool=false) -> TimeType\\n\\nAdjusts dt to the previous day of week corresponding to dow with 1 = Monday, 2 = Tuesday, etc. Setting same=true allows the current dt to be considered as the previous dow, allowing for no adjustment to occur.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.tofirst\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.tofirst\",\n    \"category\": \"function\",\n    \"text\": \"tofirst(dt::TimeType, dow::Int; of=Month) -> TimeType\\n\\nAdjusts dt to the first dow of its month. Alternatively, of=Year will adjust to the first dow of the year.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.tolast\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.tolast\",\n    \"category\": \"function\",\n    \"text\": \"tolast(dt::TimeType, dow::Int; of=Month) -> TimeType\\n\\nAdjusts dt to the last dow of its month. Alternatively, of=Year will adjust to the last dow of the year.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.tonext-Tuple{Function,TimeType}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.tonext\",\n    \"category\": \"method\",\n    \"text\": \"tonext(func::Function, dt::TimeType; step=Day(1), limit=10000, same=false) -> TimeType\\n\\nAdjusts dt by iterating at most limit iterations by step increments until func returns true. func must take a single TimeType argument and return a Bool. same allows dt to be considered in satisfying func.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.toprev-Tuple{Function,TimeType}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.toprev\",\n    \"category\": \"method\",\n    \"text\": \"toprev(func::Function, dt::TimeType; step=Day(-1), limit=10000, same=false) -> TimeType\\n\\nAdjusts dt by iterating at most limit iterations by step increments until func returns true. func must take a single TimeType argument and return a Bool. same allows dt to be considered in satisfying func.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Adjuster-Functions-2\",\n    \"page\": \"Dates\",\n    \"title\": \"Adjuster Functions\",\n    \"category\": \"section\",\n    \"text\": \"Base.trunc(::Dates.TimeType, ::Type{Dates.Period})\\nDates.firstdayofweek\\nDates.lastdayofweek\\nDates.firstdayofmonth\\nDates.lastdayofmonth\\nDates.firstdayofyear\\nDates.lastdayofyear\\nDates.firstdayofquarter\\nDates.lastdayofquarter\\nDates.tonext(::Dates.TimeType, ::Int)\\nDates.toprev(::Dates.TimeType, ::Int)\\nDates.tofirst\\nDates.tolast\\nDates.tonext(::Function, ::Dates.TimeType)\\nDates.toprev(::Function, ::Dates.TimeType)\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.Period-Tuple{Any}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.Period\",\n    \"category\": \"method\",\n    \"text\": \"Year(v)\\nMonth(v)\\nWeek(v)\\nDay(v)\\nHour(v)\\nMinute(v)\\nSecond(v)\\nMillisecond(v)\\nMicrosecond(v)\\nNanosecond(v)\\n\\nConstruct a Period type with the given v value. Input must be losslessly convertible to an Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.CompoundPeriod-Tuple{Array{#s37,1} where #s37<:Period}\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.CompoundPeriod\",\n    \"category\": \"method\",\n    \"text\": \"CompoundPeriod(periods) -> CompoundPeriod\\n\\nConstruct a CompoundPeriod from a Vector of Periods. All Periods of the same type will be added together.\\n\\nExamples\\n\\njulia> Dates.CompoundPeriod(Dates.Hour(12), Dates.Hour(13))\\n25 hours\\n\\njulia> Dates.CompoundPeriod(Dates.Hour(-1), Dates.Minute(1))\\n-1 hour, 1 minute\\n\\njulia> Dates.CompoundPeriod(Dates.Month(1), Dates.Week(-2))\\n1 month, -2 weeks\\n\\njulia> Dates.CompoundPeriod(Dates.Minute(50000))\\n50000 minutes\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.default\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.default\",\n    \"category\": \"function\",\n    \"text\": \"default(p::Period) -> Period\\n\\nReturns a sensible \\\"default\\\" value for the input Period by returning T(1) for Year, Month, and Day, and T(0) for Hour, Minute, Second, and Millisecond.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Periods-1\",\n    \"page\": \"Dates\",\n    \"title\": \"Periods\",\n    \"category\": \"section\",\n    \"text\": \"Dates.Period(::Any)\\nDates.CompoundPeriod(::Vector{<:Dates.Period})\\nDates.default\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Base.floor-Tuple{TimeType,Period}\",\n    \"page\": \"Dates\",\n    \"title\": \"Base.floor\",\n    \"category\": \"method\",\n    \"text\": \"floor(dt::TimeType, p::Period) -> TimeType\\n\\nReturn the nearest Date or DateTime less than or equal to dt at resolution p.\\n\\nFor convenience, p may be a type instead of a value: floor(dt, Dates.Hour) is a shortcut for floor(dt, Dates.Hour(1)).\\n\\njulia> floor(Date(1985, 8, 16), Dates.Month)\\n1985-08-01\\n\\njulia> floor(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))\\n2013-02-13T00:30:00\\n\\njulia> floor(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)\\n2016-08-06T00:00:00\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Base.ceil-Tuple{TimeType,Period}\",\n    \"page\": \"Dates\",\n    \"title\": \"Base.ceil\",\n    \"category\": \"method\",\n    \"text\": \"ceil(dt::TimeType, p::Period) -> TimeType\\n\\nReturn the nearest Date or DateTime greater than or equal to dt at resolution p.\\n\\nFor convenience, p may be a type instead of a value: ceil(dt, Dates.Hour) is a shortcut for ceil(dt, Dates.Hour(1)).\\n\\njulia> ceil(Date(1985, 8, 16), Dates.Month)\\n1985-09-01\\n\\njulia> ceil(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))\\n2013-02-13T00:45:00\\n\\njulia> ceil(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)\\n2016-08-07T00:00:00\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Base.round-Tuple{TimeType,Period,RoundingMode{:NearestTiesUp}}\",\n    \"page\": \"Dates\",\n    \"title\": \"Base.round\",\n    \"category\": \"method\",\n    \"text\": \"round(dt::TimeType, p::Period, [r::RoundingMode]) -> TimeType\\n\\nReturn the Date or DateTime nearest to dt at resolution p. By default (RoundNearestTiesUp), ties (e.g., rounding 9:30 to the nearest hour) will be rounded up.\\n\\nFor convenience, p may be a type instead of a value: round(dt, Dates.Hour) is a shortcut for round(dt, Dates.Hour(1)).\\n\\njulia> round(Date(1985, 8, 16), Dates.Month)\\n1985-08-01\\n\\njulia> round(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))\\n2013-02-13T00:30:00\\n\\njulia> round(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)\\n2016-08-07T00:00:00\\n\\nValid rounding modes for round(::TimeType, ::Period, ::RoundingMode) are RoundNearestTiesUp (default), RoundDown (floor), and RoundUp (ceil).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Base.floor-Union{Tuple{T}, Tuple{Union{Day, Week, TimePeriod},T}} where T<:Union{Day, Week, TimePeriod}\",\n    \"page\": \"Dates\",\n    \"title\": \"Base.floor\",\n    \"category\": \"method\",\n    \"text\": \"floor(x::Period, precision::T) where T <: Union{TimePeriod, Week, Day} -> T\\n\\nRound x down to the nearest multiple of precision. If x and precision are different subtypes of Period, the return value will have the same type as precision.\\n\\nFor convenience, precision may be a type instead of a value: floor(x, Dates.Hour) is a shortcut for floor(x, Dates.Hour(1)).\\n\\njulia> floor(Dates.Day(16), Dates.Week)\\n2 weeks\\n\\njulia> floor(Dates.Minute(44), Dates.Minute(15))\\n30 minutes\\n\\njulia> floor(Dates.Hour(36), Dates.Day)\\n1 day\\n\\nRounding to a precision of Months or Years is not supported, as these Periods are of inconsistent length.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Base.ceil-Tuple{Union{Day, Week, TimePeriod},Union{Day, Week, TimePeriod}}\",\n    \"page\": \"Dates\",\n    \"title\": \"Base.ceil\",\n    \"category\": \"method\",\n    \"text\": \"ceil(x::Period, precision::T) where T <: Union{TimePeriod, Week, Day} -> T\\n\\nRound x up to the nearest multiple of precision. If x and precision are different subtypes of Period, the return value will have the same type as precision.\\n\\nFor convenience, precision may be a type instead of a value: ceil(x, Dates.Hour) is a shortcut for ceil(x, Dates.Hour(1)).\\n\\njulia> ceil(Dates.Day(16), Dates.Week)\\n3 weeks\\n\\njulia> ceil(Dates.Minute(44), Dates.Minute(15))\\n45 minutes\\n\\njulia> ceil(Dates.Hour(36), Dates.Day)\\n2 days\\n\\nRounding to a precision of Months or Years is not supported, as these Periods are of inconsistent length.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Base.round-Tuple{Union{Day, Week, TimePeriod},Union{Day, Week, TimePeriod},RoundingMode{:NearestTiesUp}}\",\n    \"page\": \"Dates\",\n    \"title\": \"Base.round\",\n    \"category\": \"method\",\n    \"text\": \"round(x::Period, precision::T, [r::RoundingMode]) where T <: Union{TimePeriod, Week, Day} -> T\\n\\nRound x to the nearest multiple of precision. If x and precision are different subtypes of Period, the return value will have the same type as precision. By default (RoundNearestTiesUp), ties (e.g., rounding 90 minutes to the nearest hour) will be rounded up.\\n\\nFor convenience, precision may be a type instead of a value: round(x, Dates.Hour) is a shortcut for round(x, Dates.Hour(1)).\\n\\njulia> round(Dates.Day(16), Dates.Week)\\n2 weeks\\n\\njulia> round(Dates.Minute(44), Dates.Minute(15))\\n45 minutes\\n\\njulia> round(Dates.Hour(36), Dates.Day)\\n2 days\\n\\nValid rounding modes for round(::Period, ::T, ::RoundingMode) are RoundNearestTiesUp (default), RoundDown (floor), and RoundUp (ceil).\\n\\nRounding to a precision of Months or Years is not supported, as these Periods are of inconsistent length.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.floorceil\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.floorceil\",\n    \"category\": \"function\",\n    \"text\": \"floorceil(dt::TimeType, p::Period) -> (TimeType, TimeType)\\n\\nSimultaneously return the floor and ceil of a Date or DateTime at resolution p. More efficient than calling both floor and ceil individually.\\n\\n\\n\\n\\n\\nfloorceil(x::Period, precision::T) where T <: Union{TimePeriod, Week, Day} -> (T, T)\\n\\nSimultaneously return the floor and ceil of Period at resolution p.  More efficient than calling both floor and ceil individually.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.epochdays2date\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.epochdays2date\",\n    \"category\": \"function\",\n    \"text\": \"epochdays2date(days) -> Date\\n\\nTake the number of days since the rounding epoch (0000-01-01T00:00:00) and return the corresponding Date.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.epochms2datetime\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.epochms2datetime\",\n    \"category\": \"function\",\n    \"text\": \"epochms2datetime(milliseconds) -> DateTime\\n\\nTake the number of milliseconds since the rounding epoch (0000-01-01T00:00:00) and return the corresponding DateTime.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.date2epochdays\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.date2epochdays\",\n    \"category\": \"function\",\n    \"text\": \"date2epochdays(dt::Date) -> Int64\\n\\nTake the given Date and return the number of days since the rounding epoch (0000-01-01T00:00:00) as an Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.datetime2epochms\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.datetime2epochms\",\n    \"category\": \"function\",\n    \"text\": \"datetime2epochms(dt::DateTime) -> Int64\\n\\nTake the given DateTime and return the number of milliseconds since the rounding epoch (0000-01-01T00:00:00) as an Int64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Rounding-Functions-1\",\n    \"page\": \"Dates\",\n    \"title\": \"Rounding Functions\",\n    \"category\": \"section\",\n    \"text\": \"Date and DateTime values can be rounded to a specified resolution (e.g., 1 month or 15 minutes) with floor, ceil, or round.Base.floor(::Dates.TimeType, ::Dates.Period)\\nBase.ceil(::Dates.TimeType, ::Dates.Period)\\nBase.round(::Dates.TimeType, ::Dates.Period, ::RoundingMode{:NearestTiesUp})Most Period values can also be rounded to a specified resolution:Base.floor(::Dates.ConvertiblePeriod, ::T) where T <: Dates.ConvertiblePeriod\\nBase.ceil(::Dates.ConvertiblePeriod, ::Dates.ConvertiblePeriod)\\nBase.round(::Dates.ConvertiblePeriod, ::Dates.ConvertiblePeriod, ::RoundingMode{:NearestTiesUp})The following functions are not exported:Dates.floorceil\\nDates.epochdays2date\\nDates.epochms2datetime\\nDates.date2epochdays\\nDates.datetime2epochms\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.today\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.today\",\n    \"category\": \"function\",\n    \"text\": \"today() -> Date\\n\\nReturn the date portion of now().\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.unix2datetime\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.unix2datetime\",\n    \"category\": \"function\",\n    \"text\": \"unix2datetime(x) -> DateTime\\n\\nTake the number of seconds since unix epoch 1970-01-01T00:00:00 and convert to the corresponding DateTime.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.datetime2unix\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.datetime2unix\",\n    \"category\": \"function\",\n    \"text\": \"datetime2unix(dt::DateTime) -> Float64\\n\\nTake the given DateTime and return the number of seconds since the unix epoch 1970-01-01T00:00:00 as a Float64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.julian2datetime\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.julian2datetime\",\n    \"category\": \"function\",\n    \"text\": \"julian2datetime(julian_days) -> DateTime\\n\\nTake the number of Julian calendar days since epoch -4713-11-24T12:00:00 and return the corresponding DateTime.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.datetime2julian\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.datetime2julian\",\n    \"category\": \"function\",\n    \"text\": \"datetime2julian(dt::DateTime) -> Float64\\n\\nTake the given DateTime and return the number of Julian calendar days since the julian epoch -4713-11-24T12:00:00 as a Float64.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.rata2datetime\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.rata2datetime\",\n    \"category\": \"function\",\n    \"text\": \"rata2datetime(days) -> DateTime\\n\\nTake the number of Rata Die days since epoch 0000-12-31T00:00:00 and return the corresponding DateTime.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Dates.datetime2rata\",\n    \"page\": \"Dates\",\n    \"title\": \"Dates.datetime2rata\",\n    \"category\": \"function\",\n    \"text\": \"datetime2rata(dt::TimeType) -> Int64\\n\\nReturn the number of Rata Die days since epoch from the given Date or DateTime.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Conversion-Functions-1\",\n    \"page\": \"Dates\",\n    \"title\": \"Conversion Functions\",\n    \"category\": \"section\",\n    \"text\": \"Dates.today\\nDates.unix2datetime\\nDates.datetime2unix\\nDates.julian2datetime\\nDates.datetime2julian\\nDates.rata2datetime\\nDates.datetime2rata\"\n},\n\n{\n    \"location\": \"stdlib/Dates.html#Constants-1\",\n    \"page\": \"Dates\",\n    \"title\": \"Constants\",\n    \"category\": \"section\",\n    \"text\": \"Days of the Week:Variable Abbr. Value (Int)\\nMonday Mon 1\\nTuesday Tue 2\\nWednesday Wed 3\\nThursday Thu 4\\nFriday Fri 5\\nSaturday Sat 6\\nSunday Sun 7Months of the Year:Variable Abbr. Value (Int)\\nJanuary Jan 1\\nFebruary Feb 2\\nMarch Mar 3\\nApril Apr 4\\nMay May 5\\nJune Jun 6\\nJuly Jul 7\\nAugust Aug 8\\nSeptember Sep 9\\nOctober Oct 10\\nNovember Nov 11\\nDecember Dec 12DocTestSetup = nothing\"\n},\n\n{\n    \"location\": \"stdlib/DelimitedFiles.html#\",\n    \"page\": \"Delimited Files\",\n    \"title\": \"Delimited Files\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/DelimitedFiles.html#DelimitedFiles.readdlm-Tuple{Any,AbstractChar,Type,AbstractChar}\",\n    \"page\": \"Delimited Files\",\n    \"title\": \"DelimitedFiles.readdlm\",\n    \"category\": \"method\",\n    \"text\": \"readdlm(source, delim::AbstractChar, T::Type, eol::AbstractChar; header=false, skipstart=0, skipblanks=true, use_mmap, quotes=true, dims, comments=false, comment_char=\\'#\\')\\n\\nRead a matrix from the source where each line (separated by eol) gives one row, with elements separated by the given delimiter. The source can be a text file, stream or byte array. Memory mapped files can be used by passing the byte array representation of the mapped segment as source.\\n\\nIf T is a numeric type, the result is an array of that type, with any non-numeric elements as NaN for floating-point types, or zero. Other useful values of T include String, AbstractString, and Any.\\n\\nIf header is true, the first row of data will be read as header and the tuple (data_cells, header_cells) is returned instead of only data_cells.\\n\\nSpecifying skipstart will ignore the corresponding number of initial lines from the input.\\n\\nIf skipblanks is true, blank lines in the input will be ignored.\\n\\nIf use_mmap is true, the file specified by source is memory mapped for potential speedups. Default is true except on Windows. On Windows, you may want to specify true if the file is large, and is only read once and not written to.\\n\\nIf quotes is true, columns enclosed within double-quote (\\\") characters are allowed to contain new lines and column delimiters. Double-quote characters within a quoted field must be escaped with another double-quote.  Specifying dims as a tuple of the expected rows and columns (including header, if any) may speed up reading of large files.  If comments is true, lines beginning with comment_char and text following comment_char in any line are ignored.\\n\\nExamples\\n\\njulia> using DelimitedFiles\\n\\njulia> x = [1; 2; 3; 4];\\n\\njulia> y = [5; 6; 7; 8];\\n\\njulia> open(\\\"delim_file.txt\\\", \\\"w\\\") do io\\n           writedlm(io, [x y])\\n       end\\n\\njulia> readdlm(\\\"delim_file.txt\\\", \\'\\\\t\\', Int, \\'\\\\n\\')\\n4\u00d72 Array{Int64,2}:\\n 1  5\\n 2  6\\n 3  7\\n 4  8\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/DelimitedFiles.html#DelimitedFiles.readdlm-Tuple{Any,AbstractChar,AbstractChar}\",\n    \"page\": \"Delimited Files\",\n    \"title\": \"DelimitedFiles.readdlm\",\n    \"category\": \"method\",\n    \"text\": \"readdlm(source, delim::AbstractChar, eol::AbstractChar; options...)\\n\\nIf all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/DelimitedFiles.html#DelimitedFiles.readdlm-Tuple{Any,AbstractChar,Type}\",\n    \"page\": \"Delimited Files\",\n    \"title\": \"DelimitedFiles.readdlm\",\n    \"category\": \"method\",\n    \"text\": \"readdlm(source, delim::AbstractChar, T::Type; options...)\\n\\nThe end of line delimiter is taken as \\\\n.\\n\\nExamples\\n\\njulia> using DelimitedFiles\\n\\njulia> x = [1; 2; 3; 4];\\n\\njulia> y = [1.1; 2.2; 3.3; 4.4];\\n\\njulia> open(\\\"delim_file.txt\\\", \\\"w\\\") do io\\n           writedlm(io, [x y], \\',\\')\\n       end;\\n\\njulia> readdlm(\\\"delim_file.txt\\\", \\',\\', Float64)\\n4\u00d72 Array{Float64,2}:\\n 1.0  1.1\\n 2.0  2.2\\n 3.0  3.3\\n 4.0  4.4\\n\\njulia> rm(\\\"delim_file.txt\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/DelimitedFiles.html#DelimitedFiles.readdlm-Tuple{Any,AbstractChar}\",\n    \"page\": \"Delimited Files\",\n    \"title\": \"DelimitedFiles.readdlm\",\n    \"category\": \"method\",\n    \"text\": \"readdlm(source, delim::AbstractChar; options...)\\n\\nThe end of line delimiter is taken as \\\\n. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.\\n\\nExamples\\n\\njulia> using DelimitedFiles\\n\\njulia> x = [1; 2; 3; 4];\\n\\njulia> y = [1.1; 2.2; 3.3; 4.4];\\n\\njulia> open(\\\"delim_file.txt\\\", \\\"w\\\") do io\\n           writedlm(io, [x y], \\',\\')\\n       end;\\n\\njulia> readdlm(\\\"delim_file.txt\\\", \\',\\')\\n4\u00d72 Array{Float64,2}:\\n 1.0  1.1\\n 2.0  2.2\\n 3.0  3.3\\n 4.0  4.4\\n\\njulia> rm(\\\"delim_file.txt\\\")\\n\\njulia> z = [\\\"a\\\"; \\\"b\\\"; \\\"c\\\"; \\\"d\\\"];\\n\\njulia> open(\\\"delim_file.txt\\\", \\\"w\\\") do io\\n           writedlm(io, [x z], \\',\\')\\n       end;\\n\\njulia> readdlm(\\\"delim_file.txt\\\", \\',\\')\\n4\u00d72 Array{Any,2}:\\n 1  \\\"a\\\"\\n 2  \\\"b\\\"\\n 3  \\\"c\\\"\\n 4  \\\"d\\\"\\n\\njulia> rm(\\\"delim_file.txt\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/DelimitedFiles.html#DelimitedFiles.readdlm-Tuple{Any,Type}\",\n    \"page\": \"Delimited Files\",\n    \"title\": \"DelimitedFiles.readdlm\",\n    \"category\": \"method\",\n    \"text\": \"readdlm(source, T::Type; options...)\\n\\nThe columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as \\\\n.\\n\\nExamples\\n\\njulia> using DelimitedFiles\\n\\njulia> x = [1; 2; 3; 4];\\n\\njulia> y = [5; 6; 7; 8];\\n\\njulia> open(\\\"delim_file.txt\\\", \\\"w\\\") do io\\n           writedlm(io, [x y])\\n       end;\\n\\njulia> readdlm(\\\"delim_file.txt\\\", Int64)\\n4\u00d72 Array{Int64,2}:\\n 1  5\\n 2  6\\n 3  7\\n 4  8\\n\\njulia> readdlm(\\\"delim_file.txt\\\", Float64)\\n4\u00d72 Array{Float64,2}:\\n 1.0  5.0\\n 2.0  6.0\\n 3.0  7.0\\n 4.0  8.0\\n\\njulia> rm(\\\"delim_file.txt\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/DelimitedFiles.html#DelimitedFiles.readdlm-Tuple{Any}\",\n    \"page\": \"Delimited Files\",\n    \"title\": \"DelimitedFiles.readdlm\",\n    \"category\": \"method\",\n    \"text\": \"readdlm(source; options...)\\n\\nThe columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as \\\\n. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.\\n\\nExamples\\n\\njulia> using DelimitedFiles\\n\\njulia> x = [1; 2; 3; 4];\\n\\njulia> y = [\\\"a\\\"; \\\"b\\\"; \\\"c\\\"; \\\"d\\\"];\\n\\njulia> open(\\\"delim_file.txt\\\", \\\"w\\\") do io\\n           writedlm(io, [x y])\\n       end;\\n\\njulia> readdlm(\\\"delim_file.txt\\\")\\n4\u00d72 Array{Any,2}:\\n 1  \\\"a\\\"\\n 2  \\\"b\\\"\\n 3  \\\"c\\\"\\n 4  \\\"d\\\"\\n\\njulia> rm(\\\"delim_file.txt\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/DelimitedFiles.html#DelimitedFiles.writedlm\",\n    \"page\": \"Delimited Files\",\n    \"title\": \"DelimitedFiles.writedlm\",\n    \"category\": \"function\",\n    \"text\": \"writedlm(f, A, delim=\\'\\\\t\\'; opts)\\n\\nWrite A (a vector, matrix, or an iterable collection of iterable rows) as text to f (either a filename string or an IO stream) using the given delimiter delim (which defaults to tab, but can be any printable Julia object, typically a Char or AbstractString).\\n\\nFor example, two vectors x and y of the same length can be written as two columns of tab-delimited text to f by either writedlm(f, [x y]) or by writedlm(f, zip(x, y)).\\n\\nExamples\\n\\njulia> using DelimitedFiles\\n\\njulia> x = [1; 2; 3; 4];\\n\\njulia> y = [5; 6; 7; 8];\\n\\njulia> open(\\\"delim_file.txt\\\", \\\"w\\\") do io\\n           writedlm(io, [x y])\\n       end\\n\\njulia> readdlm(\\\"delim_file.txt\\\", \\'\\\\t\\', Int, \\'\\\\n\\')\\n4\u00d72 Array{Int64,2}:\\n 1  5\\n 2  6\\n 3  7\\n 4  8\\n\\njulia> rm(\\\"delim_file.txt\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/DelimitedFiles.html#Delimited-Files-1\",\n    \"page\": \"Delimited Files\",\n    \"title\": \"Delimited Files\",\n    \"category\": \"section\",\n    \"text\": \"DocTestSetup = :(using DelimitedFiles)DelimitedFiles.readdlm(::Any, ::AbstractChar, ::Type, ::AbstractChar)\\nDelimitedFiles.readdlm(::Any, ::AbstractChar, ::AbstractChar)\\nDelimitedFiles.readdlm(::Any, ::AbstractChar, ::Type)\\nDelimitedFiles.readdlm(::Any, ::AbstractChar)\\nDelimitedFiles.readdlm(::Any, ::Type)\\nDelimitedFiles.readdlm(::Any)\\nDelimitedFiles.writedlmDocTestSetup = nothing\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed Computing\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.addprocs\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.addprocs\",\n    \"category\": \"function\",\n    \"text\": \"addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers\\n\\nLaunches worker processes via the specified cluster manager.\\n\\nFor example, Beowulf clusters are supported via a custom cluster manager implemented in the package ClusterManagers.jl.\\n\\nThe number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable JULIA_WORKER_TIMEOUT in the worker process\\'s environment. Relevant only when using TCP/IP as transport.\\n\\n\\n\\n\\n\\naddprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers\\n\\nAdd processes on remote machines via SSH. Requires julia to be installed in the same location on each node, or to be available via a shared file system.\\n\\nmachines is a vector of machine specifications. Workers are started for each specification.\\n\\nA machine specification is either a string machine_spec or a tuple - (machine_spec, count).\\n\\nmachine_spec is a string of the form [user@]host[:port] [bind_addr[:port]]. user defaults to current user, port to the standard ssh port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified bind_addr and port.\\n\\ncount is the number of workers to be launched on the specified host. If specified as :auto it will launch as many workers as the number of CPU threads on the specific host.\\n\\nKeyword arguments:\\n\\ntunnel: if true then SSH tunneling will be used to connect to the worker from the master process. Default is false.\\nsshflags: specifies additional ssh options, e.g. sshflags=`-i /home/foo/bar.pem`\\nmax_parallel: specifies the maximum number of workers connected to in parallel at a host. Defaults to 10.\\ndir: specifies the working directory on the workers. Defaults to the host\\'s current directory (as found by pwd())\\nenable_threaded_blas: if true then  BLAS will run on multiple threads in added processes. Default is false.\\nexename: name of the julia executable. Defaults to \\\"$(Sys.BINDIR)/julia\\\" or \\\"$(Sys.BINDIR)/julia-debug\\\" as the case may be.\\nexeflags: additional flags passed to the worker processes.\\ntopology: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.\\ntopology=:all_to_all: All processes are connected to each other. The default.\\ntopology=:master_worker: Only the driver process, i.e. pid 1 connects to the workers. The workers do not connect to each other.\\ntopology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in connect_idents.\\nlazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first instance of a remote call between workers. Default is true.\\n\\nEnvironment variables :\\n\\nIf the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the master process specifies the number of seconds a newly launched worker waits for connection establishment.\\n\\n\\n\\n\\n\\naddprocs(; kwargs...) -> List of process identifiers\\n\\nEquivalent to addprocs(Sys.CPU_THREADS; kwargs...)\\n\\nNote that workers do not run a .julia/config/startup.jl startup script, nor do they synchronize their global state (such as global variables, new method definitions, and loaded modules) with any of the other running processes.\\n\\n\\n\\n\\n\\naddprocs(np::Integer; restrict=true, kwargs...) -> List of process identifiers\\n\\nLaunches workers using the in-built LocalManager which only launches workers on the local host. This can be used to take advantage of multiple cores. addprocs(4) will add 4 processes on the local machine. If restrict is true, binding is restricted to 127.0.0.1. Keyword args dir, exename, exeflags, topology, lazy and enable_threaded_blas have the same effect as documented for addprocs(machines).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.nprocs\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.nprocs\",\n    \"category\": \"function\",\n    \"text\": \"nprocs()\\n\\nGet the number of available processes.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.nworkers\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.nworkers\",\n    \"category\": \"function\",\n    \"text\": \"nworkers()\\n\\nGet the number of available worker processes. This is one less than nprocs(). Equal to nprocs() if nprocs() == 1.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.procs-Tuple{}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.procs\",\n    \"category\": \"method\",\n    \"text\": \"procs()\\n\\nReturn a list of all process identifiers.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.procs-Tuple{Integer}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.procs\",\n    \"category\": \"method\",\n    \"text\": \"procs(pid::Integer)\\n\\nReturn a list of all process identifiers on the same physical node. Specifically all workers bound to the same ip-address as pid are returned.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.workers\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.workers\",\n    \"category\": \"function\",\n    \"text\": \"workers()\\n\\nReturn a list of all worker process identifiers.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.rmprocs\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.rmprocs\",\n    \"category\": \"function\",\n    \"text\": \"rmprocs(pids...; waitfor=typemax(Int))\\n\\nRemove the specified workers. Note that only process 1 can add or remove workers.\\n\\nArgument waitfor specifies how long to wait for the workers to shut down:     - If unspecified, rmprocs will wait until all requested pids are removed.     - An ErrorException is raised if all workers cannot be terminated before       the requested waitfor seconds.     - With a waitfor value of 0, the call returns immediately with the workers       scheduled for removal in a different task. The scheduled Task object is       returned. The user should call wait on the task before invoking any other       parallel calls.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.interrupt\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.interrupt\",\n    \"category\": \"function\",\n    \"text\": \"interrupt(pids::Integer...)\\n\\nInterrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.\\n\\n\\n\\n\\n\\ninterrupt(pids::AbstractVector=workers())\\n\\nInterrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.myid\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.myid\",\n    \"category\": \"function\",\n    \"text\": \"myid()\\n\\nGet the id of the current process.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.pmap\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.pmap\",\n    \"category\": \"function\",\n    \"text\": \"pmap(f, [::AbstractWorkerPool], c...; distributed=true, batch_size=1, on_error=nothing, retry_delays=[], retry_check=nothing) -> collection\\n\\nTransform collection c by applying f to each element using available workers and tasks.\\n\\nFor multiple collection arguments, apply f elementwise.\\n\\nNote that f must be made available to all worker processes; see Code Availability and Loading Packages for details.\\n\\nIf a worker pool is not specified, all available workers, i.e., the default worker pool is used.\\n\\nBy default, pmap distributes the computation over all specified workers. To use only the local process and distribute over tasks, specify distributed=false. This is equivalent to using asyncmap. For example, pmap(f, c; distributed=false) is equivalent to asyncmap(f,c; ntasks=()->nworkers())\\n\\npmap can also use a mix of processes and tasks via the batch_size argument. For batch sizes greater than 1, the collection is processed in multiple batches, each of length batch_size or less. A batch is sent as a single request to a free worker, where a local asyncmap processes elements from the batch using multiple concurrent tasks.\\n\\nAny error stops pmap from processing the remainder of the collection. To override this behavior you can specify an error handling function via argument on_error which takes in a single argument, i.e., the exception. The function can stop the processing by rethrowing the error, or, to continue, return any value which is then returned inline with the results to the caller.\\n\\nConsider the following two examples. The first one returns the exception object inline, the second a 0 in place of any exception:\\n\\njulia> pmap(x->iseven(x) ? error(\\\"foo\\\") : x, 1:4; on_error=identity)\\n4-element Array{Any,1}:\\n 1\\n  ErrorException(\\\"foo\\\")\\n 3\\n  ErrorException(\\\"foo\\\")\\n\\njulia> pmap(x->iseven(x) ? error(\\\"foo\\\") : x, 1:4; on_error=ex->0)\\n4-element Array{Int64,1}:\\n 1\\n 0\\n 3\\n 0\\n\\nErrors can also be handled by retrying failed computations. Keyword arguments retry_delays and retry_check are passed through to retry as keyword arguments delays and check respectively. If batching is specified, and an entire batch fails, all items in the batch are retried.\\n\\nNote that if both on_error and retry_delays are specified, the on_error hook is called before retrying. If on_error does not throw (or rethrow) an exception, the element will not be retried.\\n\\nExample: On errors, retry f on an element a maximum of 3 times without any delay between retries.\\n\\npmap(f, c; retry_delays = zeros(3))\\n\\nExample: Retry f only if the exception is not of type InexactError, with exponentially increasing delays up to 3 times. Return a NaN in place for all InexactError occurrences.\\n\\npmap(f, c; on_error = e->(isa(e, InexactError) ? NaN : rethrow(e)), retry_delays = ExponentialBackOff(n = 3))\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.RemoteException\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.RemoteException\",\n    \"category\": \"type\",\n    \"text\": \"RemoteException(captured)\\n\\nExceptions on remote computations are captured and rethrown locally.  A RemoteException wraps the pid of the worker and a captured exception. A CapturedException captures the remote exception and a serializable form of the call stack when the exception was raised.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.Future\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.Future\",\n    \"category\": \"type\",\n    \"text\": \"Future(pid::Integer=myid())\\n\\nCreate a Future on process pid. The default pid is the current process.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.RemoteChannel\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.RemoteChannel\",\n    \"category\": \"type\",\n    \"text\": \"RemoteChannel(pid::Integer=myid())\\n\\nMake a reference to a Channel{Any}(1) on process pid. The default pid is the current process.\\n\\nRemoteChannel(f::Function, pid::Integer=myid())\\n\\nCreate references to remote channels of a specific size and type. f is a function that when executed on pid must return an implementation of an AbstractChannel.\\n\\nFor example, RemoteChannel(()->Channel{Int}(10), pid), will return a reference to a channel of type Int and size 10 on pid.\\n\\nThe default pid is the current process.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Base.wait\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Base.wait\",\n    \"category\": \"function\",\n    \"text\": \"wait(r::Future)\\n\\nWait for a value to become available for the specified future.\\n\\n\\n\\n\\n\\nwait(r::RemoteChannel, args...)\\n\\nWait for a value to become available on the specified remote channel.\\n\\n\\n\\n\\n\\nwait([x])\\n\\nBlock the current task until some event occurs, depending on the type of the argument:\\n\\nChannel: Wait for a value to be appended to the channel.\\nCondition: Wait for notify on a condition.\\nProcess: Wait for a process or process chain to exit. The exitcode field of a process can be used to determine success or failure.\\nTask: Wait for a Task to finish. If the task fails with an exception, the exception is propagated (re-thrown in the task that called wait).\\nRawFD: Wait for changes on a file descriptor (see the FileWatching package).\\n\\nIf no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to schedule or yieldto.\\n\\nOften wait is called within a while loop to ensure a waited-for condition is met before proceeding.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Base.fetch-Tuple{Any}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Base.fetch\",\n    \"category\": \"method\",\n    \"text\": \"fetch(x)\\n\\nWaits and fetches a value from x depending on the type of x:\\n\\nFuture: Wait for and get the value of a Future. The fetched value is cached locally. Further calls to fetch on the same reference return the cached value. If the remote value is an exception, throws a RemoteException which captures the remote exception and backtrace.\\nRemoteChannel: Wait for and get the value of a remote reference. Exceptions raised are same as for a Future .\\n\\nDoes not remove the item fetched.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.remotecall-Tuple{Any,Integer,Vararg{Any,N} where N}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.remotecall\",\n    \"category\": \"method\",\n    \"text\": \"remotecall(f, id::Integer, args...; kwargs...) -> Future\\n\\nCall a function f asynchronously on the given arguments on the specified process. Return a Future. Keyword arguments, if any, are passed through to f.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.remotecall_wait-Tuple{Any,Integer,Vararg{Any,N} where N}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.remotecall_wait\",\n    \"category\": \"method\",\n    \"text\": \"remotecall_wait(f, id::Integer, args...; kwargs...)\\n\\nPerform a faster wait(remotecall(...)) in one message on the Worker specified by worker id id. Keyword arguments, if any, are passed through to f.\\n\\nSee also wait and remotecall.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.remotecall_fetch-Tuple{Any,Integer,Vararg{Any,N} where N}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.remotecall_fetch\",\n    \"category\": \"method\",\n    \"text\": \"remotecall_fetch(f, id::Integer, args...; kwargs...)\\n\\nPerform fetch(remotecall(...)) in one message. Keyword arguments, if any, are passed through to f. Any remote exceptions are captured in a RemoteException and thrown.\\n\\nSee also fetch and remotecall.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.remote_do-Tuple{Any,Integer,Vararg{Any,N} where N}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.remote_do\",\n    \"category\": \"method\",\n    \"text\": \"remote_do(f, id::Integer, args...; kwargs...) -> nothing\\n\\nExecutes f on worker id asynchronously. Unlike remotecall, it does not store the result of computation, nor is there a way to wait for its completion.\\n\\nA successful invocation indicates that the request has been accepted for execution on the remote node.\\n\\nWhile consecutive remotecalls to the same worker are serialized in the order they are invoked, the order of executions on the remote worker is undetermined. For example, remote_do(f1, 2); remotecall(f2, 2); remote_do(f3, 2) will serialize the call to f1, followed by f2 and f3 in that order. However, it is not guaranteed that f1 is executed before f3 on worker 2.\\n\\nAny exceptions thrown by f are printed to stderr on the remote worker.\\n\\nKeyword arguments, if any, are passed through to f.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Base.put!-Tuple{RemoteChannel,Vararg{Any,N} where N}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Base.put!\",\n    \"category\": \"method\",\n    \"text\": \"put!(rr::RemoteChannel, args...)\\n\\nStore a set of values to the RemoteChannel. If the channel is full, blocks until space is available. Return the first argument.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Base.put!-Tuple{Future,Any}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Base.put!\",\n    \"category\": \"method\",\n    \"text\": \"put!(rr::Future, v)\\n\\nStore a value to a Future rr. Futures are write-once remote references. A put! on an already set Future throws an Exception. All asynchronous remote calls return Futures and set the value to the return value of the call upon completion.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Base.take!-Tuple{RemoteChannel,Vararg{Any,N} where N}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Base.take!\",\n    \"category\": \"method\",\n    \"text\": \"take!(rr::RemoteChannel, args...)\\n\\nFetch value(s) from a RemoteChannel rr, removing the value(s) in the process.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Base.isready-Tuple{RemoteChannel,Vararg{Any,N} where N}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Base.isready\",\n    \"category\": \"method\",\n    \"text\": \"isready(rr::RemoteChannel, args...)\\n\\nDetermine whether a RemoteChannel has a value stored to it. Note that this function can cause race conditions, since by the time you receive its result it may no longer be true. However, it can be safely used on a Future since they are assigned only once.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Base.isready-Tuple{Future}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Base.isready\",\n    \"category\": \"method\",\n    \"text\": \"isready(rr::Future)\\n\\nDetermine whether a Future has a value stored to it.\\n\\nIf the argument Future is owned by a different node, this call will block to wait for the answer. It is recommended to wait for rr in a separate task instead or to use a local Channel as a proxy:\\n\\nc = Channel(1)\\n@async put!(c, remotecall_fetch(long_computation, p))\\nisready(c)  # will not block\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.WorkerPool\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.WorkerPool\",\n    \"category\": \"type\",\n    \"text\": \"WorkerPool(workers::Vector{Int})\\n\\nCreate a WorkerPool from a vector of worker ids.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.CachingPool\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.CachingPool\",\n    \"category\": \"type\",\n    \"text\": \"CachingPool(workers::Vector{Int})\\n\\nAn implementation of an AbstractWorkerPool. remote, remotecall_fetch, pmap (and other remote calls which execute functions remotely) benefit from caching the serialized/deserialized functions on the worker nodes, especially closures (which may capture large amounts of data).\\n\\nThe remote cache is maintained for the lifetime of the returned CachingPool object. To clear the cache earlier, use clear!(pool).\\n\\nFor global variables, only the bindings are captured in a closure, not the data. let blocks can be used to capture global data.\\n\\nExamples\\n\\nconst foo = rand(10^8);\\nwp = CachingPool(workers())\\nlet foo = foo\\n    pmap(wp, i -> sum(foo) + i, 1:100);\\nend\\n\\nThe above would transfer foo only once to each worker.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.default_worker_pool\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.default_worker_pool\",\n    \"category\": \"function\",\n    \"text\": \"default_worker_pool()\\n\\nWorkerPool containing idle workers - used by remote(f) and pmap (by default).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.clear!-Tuple{CachingPool}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.clear!\",\n    \"category\": \"method\",\n    \"text\": \"clear!(pool::CachingPool) -> pool\\n\\nRemoves all cached functions from all participating workers.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.remote\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.remote\",\n    \"category\": \"function\",\n    \"text\": \"remote([::AbstractWorkerPool], f) -> Function\\n\\nReturn an anonymous function that executes function f on an available worker using remotecall_fetch.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.remotecall-Tuple{Any,AbstractWorkerPool,Vararg{Any,N} where N}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.remotecall\",\n    \"category\": \"method\",\n    \"text\": \"remotecall(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future\\n\\nWorkerPool variant of remotecall(f, pid, ....). Waits for and takes a free worker from pool and performs a remotecall on it.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.remotecall_wait-Tuple{Any,AbstractWorkerPool,Vararg{Any,N} where N}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.remotecall_wait\",\n    \"category\": \"method\",\n    \"text\": \"remotecall_wait(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future\\n\\nWorkerPool variant of remotecall_wait(f, pid, ....). Waits for and takes a free worker from pool and performs a remotecall_wait on it.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.remotecall_fetch-Tuple{Any,AbstractWorkerPool,Vararg{Any,N} where N}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.remotecall_fetch\",\n    \"category\": \"method\",\n    \"text\": \"remotecall_fetch(f, pool::AbstractWorkerPool, args...; kwargs...) -> result\\n\\nWorkerPool variant of remotecall_fetch(f, pid, ....). Waits for and takes a free worker from pool and performs a remotecall_fetch on it.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.remote_do-Tuple{Any,AbstractWorkerPool,Vararg{Any,N} where N}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.remote_do\",\n    \"category\": \"method\",\n    \"text\": \"remote_do(f, pool::AbstractWorkerPool, args...; kwargs...) -> nothing\\n\\nWorkerPool variant of remote_do(f, pid, ....). Waits for and takes a free worker from pool and performs a remote_do on it.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Base.timedwait\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Base.timedwait\",\n    \"category\": \"function\",\n    \"text\": \"timedwait(testcb::Function, secs::Float64; pollint::Float64=0.1)\\n\\nWaits until testcb returns true or for secs seconds, whichever is earlier. testcb is polled every pollint seconds.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.@spawn\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.@spawn\",\n    \"category\": \"macro\",\n    \"text\": \"@spawn\\n\\nCreate a closure around an expression and run it on an automatically-chosen process, returning a Future to the result.\\n\\nExamples\\n\\njulia> addprocs(3);\\n\\njulia> f = @spawn myid()\\nFuture(2, 1, 5, nothing)\\n\\njulia> fetch(f)\\n2\\n\\njulia> f = @spawn myid()\\nFuture(3, 1, 7, nothing)\\n\\njulia> fetch(f)\\n3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.@spawnat\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.@spawnat\",\n    \"category\": \"macro\",\n    \"text\": \"@spawnat\\n\\nCreate a closure around an expression and run the closure asynchronously on process p. Return a Future to the result. Accepts two arguments, p and an expression.\\n\\nExamples\\n\\njulia> addprocs(1);\\n\\njulia> f = @spawnat 2 myid()\\nFuture(2, 1, 3, nothing)\\n\\njulia> fetch(f)\\n2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.@fetch\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.@fetch\",\n    \"category\": \"macro\",\n    \"text\": \"@fetch\\n\\nEquivalent to fetch(@spawn expr). See fetch and @spawn.\\n\\nExamples\\n\\njulia> addprocs(3);\\n\\njulia> @fetch myid()\\n2\\n\\njulia> @fetch myid()\\n3\\n\\njulia> @fetch myid()\\n4\\n\\njulia> @fetch myid()\\n2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.@fetchfrom\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.@fetchfrom\",\n    \"category\": \"macro\",\n    \"text\": \"@fetchfrom\\n\\nEquivalent to fetch(@spawnat p expr). See fetch and @spawnat.\\n\\nExamples\\n\\njulia> addprocs(3);\\n\\njulia> @fetchfrom 2 myid()\\n2\\n\\njulia> @fetchfrom 4 myid()\\n4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Base.@async\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Base.@async\",\n    \"category\": \"macro\",\n    \"text\": \"@async\\n\\nWrap an expression in a Task and add it to the local machine\\'s scheduler queue.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Base.@sync\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Base.@sync\",\n    \"category\": \"macro\",\n    \"text\": \"@sync\\n\\nWait until all lexically-enclosed uses of @async, @spawn, @spawnat and @distributed are complete. All exceptions thrown by enclosed async operations are collected and thrown as a CompositeException.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.@distributed\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.@distributed\",\n    \"category\": \"macro\",\n    \"text\": \"@distributed\\n\\nA distributed memory, parallel for loop of the form :\\n\\n@distributed [reducer] for var = range\\n    body\\nend\\n\\nThe specified range is partitioned and locally executed across all workers. In case an optional reducer function is specified, @distributed performs local reductions on each worker with a final reduction on the calling process.\\n\\nNote that without a reducer function, @distributed executes asynchronously, i.e. it spawns independent tasks on all available workers and returns immediately without waiting for completion. To wait for completion, prefix the call with @sync, like :\\n\\n@sync @distributed for var = range\\n    body\\nend\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.@everywhere\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.@everywhere\",\n    \"category\": \"macro\",\n    \"text\": \"@everywhere [procs()] expr\\n\\nExecute an expression under Main on all procs. Errors on any of the processes are collected into a CompositeException and thrown. For example:\\n\\n@everywhere bar = 1\\n\\nwill define Main.bar on all processes.\\n\\nUnlike @spawn and @spawnat, @everywhere does not capture any local variables. Instead, local variables can be broadcast using interpolation:\\n\\nfoo = 1\\n@everywhere bar = $foo\\n\\nThe optional argument procs allows specifying a subset of all processes to have execute the expression.\\n\\nEquivalent to calling remotecall_eval(Main, procs, expr).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.clear!-Tuple{Any,Any}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.clear!\",\n    \"category\": \"method\",\n    \"text\": \"clear!(syms, pids=workers(); mod=Main)\\n\\nClears global bindings in modules by initializing them to nothing. syms should be of type Symbol or a collection of Symbols . pids and mod identify the processes and the module in which global variables are to be reinitialized. Only those names found to be defined under mod are cleared.\\n\\nAn exception is raised if a global constant is requested to be cleared.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.remoteref_id\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.remoteref_id\",\n    \"category\": \"function\",\n    \"text\": \"remoteref_id(r::AbstractRemoteRef) -> RRID\\n\\nFutures and RemoteChannels are identified by fields:\\n\\nwhere - refers to the node where the underlying object/storage referred to by the reference actually exists.\\nwhence - refers to the node the remote reference was created from. Note that this is different from the node where the underlying object referred to actually exists. For example calling RemoteChannel(2) from the master process would result in a where value of 2 and a whence value of 1.\\nid is unique across all references created from the worker specified by whence.\\n\\nTaken together,  whence and id uniquely identify a reference across all workers.\\n\\nremoteref_id is a low-level API which returns a RRID object that wraps whence and id values of a remote reference.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.channel_from_id\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.channel_from_id\",\n    \"category\": \"function\",\n    \"text\": \"channel_from_id(id) -> c\\n\\nA low-level API which returns the backing AbstractChannel for an id returned by remoteref_id. The call is valid only on the node where the backing channel exists.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.worker_id_from_socket\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.worker_id_from_socket\",\n    \"category\": \"function\",\n    \"text\": \"worker_id_from_socket(s) -> pid\\n\\nA low-level API which, given a IO connection or a Worker, returns the pid of the worker it is connected to. This is useful when writing custom serialize methods for a type, which optimizes the data written out depending on the receiving process id.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.cluster_cookie-Tuple{}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.cluster_cookie\",\n    \"category\": \"method\",\n    \"text\": \"cluster_cookie() -> cookie\\n\\nReturn the cluster cookie.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.cluster_cookie-Tuple{Any}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.cluster_cookie\",\n    \"category\": \"method\",\n    \"text\": \"cluster_cookie(cookie) -> cookie\\n\\nSet the passed cookie as the cluster cookie, then returns it.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed-Computing-1\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed Computing\",\n    \"category\": \"section\",\n    \"text\": \"DocTestSetup = :(using Distributed)Distributed.addprocs\\nDistributed.nprocs\\nDistributed.nworkers\\nDistributed.procs()\\nDistributed.procs(::Integer)\\nDistributed.workers\\nDistributed.rmprocs\\nDistributed.interrupt\\nDistributed.myid\\nDistributed.pmap\\nDistributed.RemoteException\\nDistributed.Future\\nDistributed.RemoteChannel\\nDistributed.wait\\nDistributed.fetch(::Any)\\nDistributed.remotecall(::Any, ::Integer, ::Any...)\\nDistributed.remotecall_wait(::Any, ::Integer, ::Any...)\\nDistributed.remotecall_fetch(::Any, ::Integer, ::Any...)\\nDistributed.remote_do(::Any, ::Integer, ::Any...)\\nDistributed.put!(::RemoteChannel, ::Any...)\\nDistributed.put!(::Future, ::Any)\\nDistributed.take!(::RemoteChannel, ::Any...)\\nDistributed.isready(::RemoteChannel, ::Any...)\\nDistributed.isready(::Future)\\nDistributed.WorkerPool\\nDistributed.CachingPool\\nDistributed.default_worker_pool\\nDistributed.clear!(::CachingPool)\\nDistributed.remote\\nDistributed.remotecall(::Any, ::AbstractWorkerPool, ::Any...)\\nDistributed.remotecall_wait(::Any, ::AbstractWorkerPool, ::Any...)\\nDistributed.remotecall_fetch(::Any, ::AbstractWorkerPool, ::Any...)\\nDistributed.remote_do(::Any, ::AbstractWorkerPool, ::Any...)\\nDistributed.timedwait\\nDistributed.@spawn\\nDistributed.@spawnat\\nDistributed.@fetch\\nDistributed.@fetchfrom\\nDistributed.@async\\nDistributed.@sync\\nDistributed.@distributed\\nDistributed.@everywhere\\nDistributed.clear!(::Any, ::Any; ::Any)\\nDistributed.remoteref_id\\nDistributed.channel_from_id\\nDistributed.worker_id_from_socket\\nDistributed.cluster_cookie()\\nDistributed.cluster_cookie(::Any)\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.launch\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.launch\",\n    \"category\": \"function\",\n    \"text\": \"launch(manager::ClusterManager, params::Dict, launched::Array, launch_ntfy::Condition)\\n\\nImplemented by cluster managers. For every Julia worker launched by this function, it should append a WorkerConfig entry to launched and notify launch_ntfy. The function MUST exit once all workers, requested by manager have been launched. params is a dictionary of all keyword arguments addprocs was called with.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.manage\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.manage\",\n    \"category\": \"function\",\n    \"text\": \"manage(manager::ClusterManager, id::Integer, config::WorkerConfig. op::Symbol)\\n\\nImplemented by cluster managers. It is called on the master process, during a worker\\'s lifetime, with appropriate op values:\\n\\nwith :register/:deregister when a worker is added / removed from the Julia worker pool.\\nwith :interrupt when interrupt(workers) is called. The ClusterManager should signal the appropriate worker with an interrupt signal.\\nwith :finalize for cleanup purposes.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Base.kill-Tuple{ClusterManager,Int64,WorkerConfig}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Base.kill\",\n    \"category\": \"method\",\n    \"text\": \"kill(manager::ClusterManager, pid::Int, config::WorkerConfig)\\n\\nImplemented by cluster managers. It is called on the master process, by rmprocs. It should cause the remote worker specified by pid to exit. kill(manager::ClusterManager.....) executes a remote exit() on pid.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Sockets.connect-Tuple{ClusterManager,Int64,WorkerConfig}\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Sockets.connect\",\n    \"category\": \"method\",\n    \"text\": \"connect(manager::ClusterManager, pid::Int, config::WorkerConfig) -> (instrm::IO, outstrm::IO)\\n\\nImplemented by cluster managers using custom transports. It should establish a logical connection to worker with id pid, specified by config and return a pair of IO objects. Messages from pid to current process will be read off instrm, while messages to be sent to pid will be written to outstrm. The custom transport implementation must ensure that messages are delivered and received completely and in order. connect(manager::ClusterManager.....) sets up TCP/IP socket connections in-between workers.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.init_worker\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.init_worker\",\n    \"category\": \"function\",\n    \"text\": \"init_worker(cookie::AbstractString, manager::ClusterManager=DefaultClusterManager())\\n\\nCalled by cluster managers implementing custom transports. It initializes a newly launched process as a worker. Command line argument --worker[=<cookie>] has the effect of initializing a process as a worker using TCP/IP sockets for transport. cookie is a cluster_cookie.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.start_worker\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.start_worker\",\n    \"category\": \"function\",\n    \"text\": \"start_worker([out::IO=stdout], cookie::AbstractString=readline(stdin))\\n\\nstart_worker is an internal function which is the default entry point for worker processes connecting via TCP/IP. It sets up the process as a Julia cluster worker.\\n\\nhost:port information is written to stream out (defaults to stdout).\\n\\nThe function closes stdin (after reading the cookie if required), redirects stderr to stdout, listens on a free port (or if specified, the port in the --bind-to command line option) and schedules tasks to process incoming TCP connections and requests.\\n\\nIt does not return.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Distributed.process_messages\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Distributed.process_messages\",\n    \"category\": \"function\",\n    \"text\": \"process_messages(r_stream::IO, w_stream::IO, incoming::Bool=true)\\n\\nCalled by cluster managers using custom transports. It should be called when the custom transport implementation receives the first message from a remote worker. The custom transport must manage a logical connection to the remote worker and provide two IO objects, one for incoming messages and the other for messages addressed to the remote worker. If incoming is true, the remote peer initiated the connection. Whichever of the pair initiates the connection sends the cluster cookie and its Julia version number to perform the authentication handshake.\\n\\nSee also cluster_cookie.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Distributed.html#Cluster-Manager-Interface-1\",\n    \"page\": \"Distributed Computing\",\n    \"title\": \"Cluster Manager Interface\",\n    \"category\": \"section\",\n    \"text\": \"This interface provides a mechanism to launch and manage Julia workers on different cluster environments. There are two types of managers present in Base: LocalManager, for launching additional workers on the same host, and SSHManager, for launching on remote hosts via ssh. TCP/IP sockets are used to connect and transport messages between processes. It is possible for Cluster Managers to provide a different transport.Distributed.launch\\nDistributed.manage\\nDistributed.kill(::ClusterManager, ::Int, ::WorkerConfig)\\nDistributed.connect(::ClusterManager, ::Int, ::WorkerConfig)\\nDistributed.init_worker\\nDistributed.start_worker\\nDistributed.process_messagesDocTestSetup = nothing\"\n},\n\n{\n    \"location\": \"stdlib/FileWatching.html#\",\n    \"page\": \"File Events\",\n    \"title\": \"File Events\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/FileWatching.html#FileWatching.poll_fd\",\n    \"page\": \"File Events\",\n    \"title\": \"FileWatching.poll_fd\",\n    \"category\": \"function\",\n    \"text\": \"poll_fd(fd, timeout_s::Real=-1; readable=false, writable=false)\\n\\nMonitor a file descriptor fd for changes in the read or write availability, and with a timeout given by timeout_s seconds.\\n\\nThe keyword arguments determine which of read and/or write status should be monitored; at least one of them must be set to true.\\n\\nThe returned value is an object with boolean fields readable, writable, and timedout, giving the result of the polling.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/FileWatching.html#FileWatching.poll_file\",\n    \"page\": \"File Events\",\n    \"title\": \"FileWatching.poll_file\",\n    \"category\": \"function\",\n    \"text\": \"poll_file(path::AbstractString, interval_s::Real=5.007, timeout_s::Real=-1) -> (previous::StatStruct, current)\\n\\nMonitor a file for changes by polling every interval_s seconds until a change occurs or timeout_s seconds have elapsed. The interval_s should be a long period; the default is 5.007 seconds.\\n\\nReturns a pair of status objects (previous, current) when a change is detected. The previous status is always a StatStruct, but it may have all of the fields zeroed (indicating the file didn\\'t previously exist, or wasn\\'t previously accessible).\\n\\nThe current status object may be a StatStruct, an EOFError (indicating the timeout elapsed), or some other Exception subtype (if the stat operation failed - for example, if the path does not exist).\\n\\nTo determine when a file was modified, compare current isa StatStruct && mtime(prev) != mtime(current) to detect notification of changes. However, using watch_file for this operation is preferred, since it is more reliable and efficient, although in some situations it may not be available.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/FileWatching.html#FileWatching.watch_file\",\n    \"page\": \"File Events\",\n    \"title\": \"FileWatching.watch_file\",\n    \"category\": \"function\",\n    \"text\": \"watch_file(path::AbstractString, timeout_s::Real=-1)\\n\\nWatch file or directory path for changes until a change occurs or timeout_s seconds have elapsed.\\n\\nThe returned value is an object with boolean fields changed, renamed, and timedout, giving the result of watching the file.\\n\\nThis behavior of this function varies slightly across platforms. See https://nodejs.org/api/fs.html#fs_caveats for more detailed information.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/FileWatching.html#FileWatching.watch_folder\",\n    \"page\": \"File Events\",\n    \"title\": \"FileWatching.watch_folder\",\n    \"category\": \"function\",\n    \"text\": \"watch_folder(path::AbstractString, timeout_s::Real=-1)\\n\\nWatches a file or directory path for changes until a change has occurred or timeout_s seconds have elapsed.\\n\\nThis will continuing tracking changes for path in the background until unwatch_folder is called on the same path.\\n\\nThe returned value is an pair where the first field is the name of the changed file (if available) and the second field is an object with boolean fields changed, renamed, and timedout, giving the event.\\n\\nThis behavior of this function varies slightly across platforms. See https://nodejs.org/api/fs.html#fs_caveats for more detailed information.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/FileWatching.html#FileWatching.unwatch_folder\",\n    \"page\": \"File Events\",\n    \"title\": \"FileWatching.unwatch_folder\",\n    \"category\": \"function\",\n    \"text\": \"unwatch_folder(path::AbstractString)\\n\\nStop background tracking of changes for path. It is not recommended to do this while another task is waiting for watch_folder to return on the same path, as the result may be unpredictable.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/FileWatching.html#lib-filewatching-1\",\n    \"page\": \"File Events\",\n    \"title\": \"File Events\",\n    \"category\": \"section\",\n    \"text\": \"FileWatching.poll_fd\\nFileWatching.poll_file\\nFileWatching.watch_file\\nFileWatching.watch_folder\\nFileWatching.unwatch_folder\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"Interactive Utilities\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#Base.Docs.apropos\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"Base.Docs.apropos\",\n    \"category\": \"function\",\n    \"text\": \"apropos(string)\\n\\nSearch through all documentation for a string, ignoring case.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.varinfo\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.varinfo\",\n    \"category\": \"function\",\n    \"text\": \"varinfo(m::Module=Main, pattern::Regex=r\\\"\\\")\\n\\nReturn a markdown table giving information about exported global variables in a module, optionally restricted to those matching pattern.\\n\\nThe memory consumption estimate is an approximate lower bound on the size of the internal structure of the object.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.versioninfo\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.versioninfo\",\n    \"category\": \"function\",\n    \"text\": \"versioninfo(io::IO=stdout; verbose::Bool=false)\\n\\nPrint information about the version of Julia in use. The output is controlled with boolean keyword arguments:\\n\\nverbose: print all additional information\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.methodswith\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.methodswith\",\n    \"category\": \"function\",\n    \"text\": \"methodswith(typ[, module or function]; supertypes::Bool=false])\\n\\nReturn an array of methods with an argument of type typ.\\n\\nThe optional second argument restricts the search to a particular module or function (the default is all top-level modules).\\n\\nIf keyword supertypes is true, also return arguments with a parent type of typ, excluding type Any.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.subtypes\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.subtypes\",\n    \"category\": \"function\",\n    \"text\": \"subtypes(T::DataType)\\n\\nReturn a list of immediate subtypes of DataType T. Note that all currently loaded subtypes are included, including those not visible in the current module.\\n\\nExamples\\n\\njulia> subtypes(Integer)\\n3-element Array{Any,1}:\\n Bool\\n Signed\\n Unsigned\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.edit-Tuple{AbstractString,Integer}\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.edit\",\n    \"category\": \"method\",\n    \"text\": \"edit(path::AbstractString, line::Integer=0)\\n\\nEdit a file or directory optionally providing a line number to edit the file at. Return to the julia prompt when you quit the editor. The editor can be changed by setting JULIA_EDITOR, VISUAL or EDITOR as an environment variable.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.edit-Tuple{Any}\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.edit\",\n    \"category\": \"method\",\n    \"text\": \"edit(function, [types])\\n\\nEdit the definition of a function, optionally specifying a tuple of types to indicate which method to edit. The editor can be changed by setting JULIA_EDITOR, VISUAL or EDITOR as an environment variable.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.@edit\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.@edit\",\n    \"category\": \"macro\",\n    \"text\": \"@edit\\n\\nEvaluates the arguments to the function or macro call, determines their types, and calls the edit function on the resulting expression.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.less-Tuple{AbstractString}\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.less\",\n    \"category\": \"method\",\n    \"text\": \"less(file::AbstractString, [line::Integer])\\n\\nShow a file using the default pager, optionally providing a starting line number. Returns to the julia prompt when you quit the pager.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.less-Tuple{Any}\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.less\",\n    \"category\": \"method\",\n    \"text\": \"less(function, [types])\\n\\nShow the definition of a function using the default pager, optionally specifying a tuple of types to indicate which method to see.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.@less\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.@less\",\n    \"category\": \"macro\",\n    \"text\": \"@less\\n\\nEvaluates the arguments to the function or macro call, determines their types, and calls the less function on the resulting expression.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.@which\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.@which\",\n    \"category\": \"macro\",\n    \"text\": \"@which\\n\\nApplied to a function or macro call, it evaluates the arguments to the specified call, and returns the Method object for the method that would be called for those arguments. Applied to a variable, it returns the module in which the variable was bound. It calls out to the which function.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.@functionloc\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.@functionloc\",\n    \"category\": \"macro\",\n    \"text\": \"@functionloc\\n\\nApplied to a function or macro call, it evaluates the arguments to the specified call, and returns a tuple (filename,line) giving the location for the method that would be called for those arguments. It calls out to the functionloc function.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.@code_lowered\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.@code_lowered\",\n    \"category\": \"macro\",\n    \"text\": \"@code_lowered\\n\\nEvaluates the arguments to the function or macro call, determines their types, and calls code_lowered on the resulting expression.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.@code_typed\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.@code_typed\",\n    \"category\": \"macro\",\n    \"text\": \"@code_typed\\n\\nEvaluates the arguments to the function or macro call, determines their types, and calls code_typed on the resulting expression. Use the optional argument optimize with\\n\\n@code_typed optimize=true foo(x)\\n\\nto control whether additional optimizations, such as inlining, are also applied.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.code_warntype\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.code_warntype\",\n    \"category\": \"function\",\n    \"text\": \"code_warntype([io::IO], f, types; verbose_linetable=false)\\n\\nPrints lowered and type-inferred ASTs for the methods matching the given generic function and type signature to io which defaults to stdout. The ASTs are annotated in such a way as to cause \\\"non-leaf\\\" types to be emphasized (if color is available, displayed in red). This serves as a warning of potential type instability. Not all non-leaf types are particularly problematic for performance, so the results need to be used judiciously. In particular, unions containing either missing or nothing are displayed in yellow, since these are often intentional. If the verbose_linetable keyword is set, the linetable will be printed in verbose mode, showing all available information (rather than applying the usual heuristics). See @code_warntype for more information.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.@code_warntype\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.@code_warntype\",\n    \"category\": \"macro\",\n    \"text\": \"@code_warntype\\n\\nEvaluates the arguments to the function or macro call, determines their types, and calls code_warntype on the resulting expression.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.code_llvm\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.code_llvm\",\n    \"category\": \"function\",\n    \"text\": \"code_llvm([io=stdout,], f, types)\\n\\nPrints the LLVM bitcodes generated for running the method matching the given generic function and type signature to io.\\n\\nIf the optimize keyword is unset, the code will be shown before LLVM optimizations. All metadata and dbg.* calls are removed from the printed bitcode. Set the raw keyword for the full IR. To dump the entire module that encapsulates the function, with debug info and metadata, set the dump_module keyword.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.@code_llvm\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.@code_llvm\",\n    \"category\": \"macro\",\n    \"text\": \"@code_llvm\\n\\nEvaluates the arguments to the function or macro call, determines their types, and calls code_llvm on the resulting expression. Set the optional keyword arguments raw, dump_module and optimize by putting them and their value before the function call, like this:\\n\\n@code_llvm raw=true dump_module=true f(x)\\n@code_llvm optimize=false f(x)\\n\\noptimize controls whether additional optimizations, such as inlining, are also applied. raw makes all metadata and dbg.* calls visible. dump_module prints the entire module that encapsulates the function, with debug info and metadata.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.code_native\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.code_native\",\n    \"category\": \"function\",\n    \"text\": \"code_native([io=stdout,], f, types; syntax = :att)\\n\\nPrints the native assembly instructions generated for running the method matching the given generic function and type signature to io. Switch assembly syntax using syntax symbol parameter set to :att for AT&T syntax or :intel for Intel syntax.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.@code_native\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.@code_native\",\n    \"category\": \"macro\",\n    \"text\": \"@code_native\\n\\nEvaluates the arguments to the function or macro call, determines their types, and calls code_native on the resulting expression.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#InteractiveUtils.clipboard\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"InteractiveUtils.clipboard\",\n    \"category\": \"function\",\n    \"text\": \"clipboard(x)\\n\\nSend a printed form of x to the operating system clipboard (\\\"copy\\\").\\n\\n\\n\\n\\n\\nclipboard() -> AbstractString\\n\\nReturn a string with the contents of the operating system clipboard (\\\"paste\\\").\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/InteractiveUtils.html#Interactive-Utilities-1\",\n    \"page\": \"Interactive Utilities\",\n    \"title\": \"Interactive Utilities\",\n    \"category\": \"section\",\n    \"text\": \"DocTestSetup = :(using InteractiveUtils)InteractiveUtils.apropos\\nInteractiveUtils.varinfo\\nInteractiveUtils.versioninfo\\nInteractiveUtils.methodswith\\nInteractiveUtils.subtypes\\nInteractiveUtils.edit(::AbstractString, ::Integer)\\nInteractiveUtils.edit(::Any)\\nInteractiveUtils.@edit\\nInteractiveUtils.less(::AbstractString)\\nInteractiveUtils.less(::Any)\\nInteractiveUtils.@less\\nInteractiveUtils.@which\\nInteractiveUtils.@functionloc\\nInteractiveUtils.@code_lowered\\nInteractiveUtils.@code_typed\\nInteractiveUtils.code_warntype\\nInteractiveUtils.@code_warntype\\nInteractiveUtils.code_llvm\\nInteractiveUtils.@code_llvm\\nInteractiveUtils.code_native\\nInteractiveUtils.@code_native\\nInteractiveUtils.clipboardDocTestSetup = nothing\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2-1\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2\",\n    \"category\": \"section\",\n    \"text\": \"DocTestSetup = :(using LibGit2)The LibGit2 module provides bindings to libgit2, a portable C library that implements core functionality for the Git version control system. These bindings are currently used to power Julia\\'s package manager. It is expected that this module will eventually be moved into a separate package.\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.Buffer\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.Buffer\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.Buffer\\n\\nA data buffer for exporting data from libgit2. Matches the git_buf struct.\\n\\nWhen fetching data from LibGit2, a typical usage would look like:\\n\\nbuf_ref = Ref(Buffer())\\n@check ccall(..., (Ptr{Buffer},), buf_ref)\\n# operation on buf_ref\\nfree(buf_ref)\\n\\nIn particular, note that LibGit2.free should be called afterward on the Ref object.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.CheckoutOptions\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.CheckoutOptions\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.CheckoutOptions\\n\\nMatches the git_checkout_options struct.\\n\\nThe fields represent:\\n\\nversion: version of the struct in use, in case this changes later. For now, always 1.\\ncheckout_strategy: determine how to handle conflicts and whether to force the  checkout/recreate missing files.\\ndisable_filters: if nonzero, do not apply filters like CLRF (to convert file newlines between UNIX and DOS).\\ndir_mode: read/write/access mode for any directories involved in the checkout. Default is 0755.\\nfile_mode: read/write/access mode for any files involved in the checkout.  Default is 0755 or 0644, depending on the blob.\\nfile_open_flags: bitflags used to open any files during the checkout.\\nnotify_flags: Flags for what sort of conflicts the user should be notified about.\\nnotify_cb: An optional callback function to notify the user if a checkout conflict occurs.  If this function returns a non-zero value, the checkout will be cancelled.\\nnotify_payload: Payload for the notify callback function.\\nprogress_cb: An optional callback function to display checkout progress.\\nprogress_payload: Payload for the progress callback.\\npaths: If not empty, describes which paths to search during the checkout.  If empty, the checkout will occur over all files in the repository.\\nbaseline: Expected content of the workdir, captured in a (pointer to a)  GitTree. Defaults to the state of the tree at HEAD.\\nbaseline_index: Expected content of the workdir, captured in a (pointer to a)  GitIndex. Defaults to the state of the index at HEAD.\\ntarget_directory: If not empty, checkout to this directory instead of the workdir.\\nancestor_label: In case of conflicts, the name of the common ancestor side.\\nour_label: In case of conflicts, the name of \\\"our\\\" side.\\ntheir_label: In case of conflicts, the name of \\\"their\\\" side.\\nperfdata_cb: An optional callback function to display performance data.\\nperfdata_payload: Payload for the performance callback.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.CloneOptions\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.CloneOptions\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.CloneOptions\\n\\nMatches the git_clone_options struct.\\n\\nThe fields represent:\\n\\nversion: version of the struct in use, in case this changes later. For now, always 1.\\ncheckout_opts: The options for performing the checkout of the remote as part of the clone.\\nfetch_opts: The options for performing the pre-checkout fetch of the remote as part of the clone.\\nbare: If 0, clone the full remote repository. If non-zero, perform a bare clone, in which  there is no local copy of the source files in the repository and the gitdir and workdir  are the same.\\nlocalclone: Flag whether to clone a local object database or do a fetch. The default is to let git decide.  It will not use the git-aware transport for a local clone, but will use it for URLs which begin with file://.\\ncheckout_branch: The name of the branch to checkout. If an empty string, the default branch of the  remote will be checked out.\\nrepository_cb: An optional callback which will be used to create the new repository into which  the clone is made.\\nrepository_cb_payload: The payload for the repository callback.\\nremote_cb: An optional callback used to create the GitRemote before making the clone from it.\\nremote_cb_payload: The payload for the remote callback.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.DescribeOptions\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.DescribeOptions\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.DescribeOptions\\n\\nMatches the git_describe_options struct.\\n\\nThe fields represent:\\n\\nversion: version of the struct in use, in case this changes later. For now, always 1.\\nmax_candidates_tags: consider this many most recent tags in refs/tags to describe a commit.  Defaults to 10 (so that the 10 most recent tags would be examined to see if they describe a commit).\\ndescribe_strategy: whether to consider all entries in refs/tags (equivalent to git-describe --tags)  or all entries in refs/ (equivalent to git-describe --all). The default is to only show annotated tags.  If Consts.DESCRIBE_TAGS is passed, all tags, annotated or not, will be considered.  If Consts.DESCRIBE_ALL is passed, any ref in refs/ will be considered.\\npattern: only consider tags which match pattern. Supports glob expansion.\\nonly_follow_first_parent: when finding the distance from a matching reference to the described  object, only consider the distance from the first parent.\\nshow_commit_oid_as_fallback: if no matching reference can be found which describes a commit, show the  commit\\'s GitHash instead of throwing an error (the default behavior).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.DescribeFormatOptions\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.DescribeFormatOptions\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.DescribeFormatOptions\\n\\nMatches the git_describe_format_options struct.\\n\\nThe fields represent:\\n\\nversion: version of the struct in use, in case this changes later. For now, always 1.\\nabbreviated_size: lower bound on the size of the abbreviated GitHash to use, defaulting to 7.\\nalways_use_long_format: set to 1 to use the long format for strings even if a short format can be used.\\ndirty_suffix: if set, this will be appended to the end of the description string if the workdir is dirty.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.DiffDelta\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.DiffDelta\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.DiffDelta\\n\\nDescription of changes to one entry. Matches the git_diff_delta struct.\\n\\nThe fields represent:\\n\\nstatus: One of Consts.DELTA_STATUS, indicating whether the file has been added/modified/deleted.\\nflags: Flags for the delta and the objects on each side. Determines whether to treat the file(s)  as binary/text, whether they exist on each side of the diff, and whether the object ids are known  to be correct.\\nsimilarity: Used to indicate if a file has been renamed or copied.\\nnfiles: The number of files in the delta (for instance, if the delta  was run on a submodule commit id, it may contain more than one file).\\nold_file: A DiffFile containing information about the file(s) before the changes.\\nnew_file: A DiffFile containing information about the file(s) after the changes.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.DiffFile\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.DiffFile\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.DiffFile\\n\\nDescription of one side of a delta. Matches the git_diff_file struct.\\n\\nThe fields represent:\\n\\nid: the GitHash of the item in the diff. If the item is empty on this  side of the diff (for instance, if the diff is of the removal of a file), this will  be GitHash(0).\\npath: a NULL terminated path to the item relative to the working directory of the repository.\\nsize: the size of the item in bytes.\\nflags: a combination of the git_diff_flag_t  flags. The ith bit of this integer sets the ith flag.\\nmode: the stat mode for the item.\\nid_abbrev: only present in LibGit2 versions newer than or equal to 0.25.0.  The length of the id field when converted using string. Usually equal to OID_HEXSZ (40).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.DiffOptionsStruct\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.DiffOptionsStruct\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.DiffOptionsStruct\\n\\nMatches the git_diff_options struct.\\n\\nThe fields represent:\\n\\nversion: version of the struct in use, in case this changes later. For now, always 1.\\nflags: flags controlling which files will appear in the diff. Defaults to DIFF_NORMAL.\\nignore_submodules: whether to look at files in submodules or not. Defaults to SUBMODULE_IGNORE_UNSPECIFIED, which means the submodule\\'s configuration will control  whether it appears in the diff or not.\\npathspec: path to files to include in the diff. Default is to use all files in the repository.\\nnotify_cb: optional callback which will notify the user of changes to the diff as file deltas are  added to it.\\nprogress_cb: optional callback which will display diff progress. Only relevant on libgit2 versions  at least as new as 0.24.0.\\npayload: the payload to pass to notify_cb and progress_cb.\\ncontext_lines: the number of unchanged lines used to define the edges of a hunk.  This is also the number of lines which will be shown before/after a hunk to provide  context. Default is 3.\\ninterhunk_lines: the maximum number of unchanged lines between two separate  hunks allowed before the hunks will be combined. Default is 0.\\nid_abbrev: sets the length of the abbreviated GitHash to print.  Default is 7.\\nmax_size: the maximum file size of a blob. Above this size, it will be treated  as a binary blob. The default is 512 MB.\\nold_prefix: the virtual file directory in which to place old files on one side  of the diff. Default is \\\"a\\\".\\nnew_prefix: the virtual file directory in which to place new files on one side  of the diff. Default is \\\"b\\\".\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.FetchHead\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.FetchHead\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.FetchHead\\n\\nContains the information about HEAD during a fetch, including the name and URL of the branch fetched from, the oid of the HEAD, and whether the fetched HEAD has been merged locally.\\n\\nThe fields represent:\\n\\nname: The name in the local reference database of the fetch head, for example,  \\\"refs/heads/master\\\".\\nurl: The URL of the fetch head.\\noid: The GitHash of the tip of the fetch head.\\nismerge: Boolean flag indicating whether the changes at the  remote have been merged into the local copy yet or not. If true, the local  copy is up to date with the remote fetch head.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.FetchOptions\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.FetchOptions\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.FetchOptions\\n\\nMatches the git_fetch_options struct.\\n\\nThe fields represent:\\n\\nversion: version of the struct in use, in case this changes later. For now, always 1.\\ncallbacks: remote callbacks to use during the fetch.\\nprune: whether to perform a prune after the fetch or not. The default is to  use the setting from the GitConfig.\\nupdate_fetchhead: whether to update the FetchHead after the fetch.  The default is to perform the update, which is the normal git behavior.\\ndownload_tags: whether to download tags present at the remote or not. The default  is to request the tags for objects which are being downloaded anyway from the server.\\nproxy_opts: options for connecting to the remote through a proxy. See ProxyOptions.  Only present on libgit2 versions newer than or equal to 0.25.0.\\ncustom_headers: any extra headers needed for the fetch. Only present on libgit2 versions  newer than or equal to 0.24.0.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.GitAnnotated\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.GitAnnotated\",\n    \"category\": \"type\",\n    \"text\": \"GitAnnotated(repo::GitRepo, commit_id::GitHash)\\nGitAnnotated(repo::GitRepo, ref::GitReference)\\nGitAnnotated(repo::GitRepo, fh::FetchHead)\\nGitAnnotated(repo::GitRepo, comittish::AbstractString)\\n\\nAn annotated git commit carries with it information about how it was looked up and why, so that rebase or merge operations have more information about the context of the commit. Conflict files contain information about the source/target branches in the merge which are conflicting, for instance. An annotated commit can refer to the tip of a remote branch, for instance when a FetchHead is passed, or to a branch head described using GitReference.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.GitBlame\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.GitBlame\",\n    \"category\": \"type\",\n    \"text\": \"GitBlame(repo::GitRepo, path::AbstractString; options::BlameOptions=BlameOptions())\\n\\nConstruct a GitBlame object for the file at path, using change information gleaned from the history of repo. The GitBlame object records who changed which chunks of the file when, and how. options controls how to separate the contents of the file and which commits to probe - see BlameOptions for more information.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.GitBlob\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.GitBlob\",\n    \"category\": \"type\",\n    \"text\": \"GitBlob(repo::GitRepo, hash::AbstractGitHash)\\nGitBlob(repo::GitRepo, spec::AbstractString)\\n\\nReturn a GitBlob object from repo specified by hash/spec.\\n\\nhash is a full (GitHash) or partial (GitShortHash) hash.\\nspec is a textual specification: see the git docs for a full list.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.GitCommit\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.GitCommit\",\n    \"category\": \"type\",\n    \"text\": \"GitCommit(repo::GitRepo, hash::AbstractGitHash)\\nGitCommit(repo::GitRepo, spec::AbstractString)\\n\\nReturn a GitCommit object from repo specified by hash/spec.\\n\\nhash is a full (GitHash) or partial (GitShortHash) hash.\\nspec is a textual specification: see the git docs for a full list.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.GitHash\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.GitHash\",\n    \"category\": \"type\",\n    \"text\": \"GitHash\\n\\nA git object identifier, based on the sha-1 hash. It is a 20 byte string (40 hex digits) used to identify a GitObject in a repository.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.GitObject\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.GitObject\",\n    \"category\": \"type\",\n    \"text\": \"GitObject(repo::GitRepo, hash::AbstractGitHash)\\nGitObject(repo::GitRepo, spec::AbstractString)\\n\\nReturn the specified object (GitCommit, GitBlob, GitTree or GitTag) from repo specified by hash/spec.\\n\\nhash is a full (GitHash) or partial (GitShortHash) hash.\\nspec is a textual specification: see the git docs for a full list.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.GitRemote\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.GitRemote\",\n    \"category\": \"type\",\n    \"text\": \"GitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString) -> GitRemote\\n\\nLook up a remote git repository using its name and URL. Uses the default fetch refspec.\\n\\nExamples\\n\\nrepo = LibGit2.init(repo_path)\\nremote = LibGit2.GitRemote(repo, \\\"upstream\\\", repo_url)\\n\\n\\n\\n\\n\\nGitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString, fetch_spec::AbstractString) -> GitRemote\\n\\nLook up a remote git repository using the repository\\'s name and URL, as well as specifications for how to fetch from the remote (e.g. which remote branch to fetch from).\\n\\nExamples\\n\\nrepo = LibGit2.init(repo_path)\\nrefspec = \\\"+refs/heads/mybranch:refs/remotes/origin/mybranch\\\"\\nremote = LibGit2.GitRemote(repo, \\\"upstream\\\", repo_url, refspec)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.GitRemoteAnon\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.GitRemoteAnon\",\n    \"category\": \"function\",\n    \"text\": \"GitRemoteAnon(repo::GitRepo, url::AbstractString) -> GitRemote\\n\\nLook up a remote git repository using only its URL, not its name.\\n\\nExamples\\n\\nrepo = LibGit2.init(repo_path)\\nremote = LibGit2.GitRemoteAnon(repo, repo_url)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.GitRepo\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.GitRepo\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.GitRepo(path::AbstractString)\\n\\nOpen a git repository at path.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.GitRepoExt\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.GitRepoExt\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.GitRepoExt(path::AbstractString, flags::Cuint = Cuint(Consts.REPOSITORY_OPEN_DEFAULT))\\n\\nOpen a git repository at path with extended controls (for instance, if the current user must be a member of a special access group to read path).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.GitRevWalker\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.GitRevWalker\",\n    \"category\": \"type\",\n    \"text\": \"GitRevWalker(repo::GitRepo)\\n\\nA GitRevWalker walks through the revisions (i.e. commits) of a git repository repo. It is a collection of the commits in the repository, and supports iteration and calls to map and count (for instance, count could be used to determine what percentage of commits in a repository were made by a certain author).\\n\\ncnt = LibGit2.with(LibGit2.GitRevWalker(repo)) do walker\\n    count((oid,repo)->(oid == commit_oid1), walker, oid=commit_oid1, by=LibGit2.Consts.SORT_TIME)\\nend\\n\\nHere, count finds the number of commits along the walk with a certain GitHash. Since the GitHash is unique to a commit, cnt will be 1.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.GitShortHash\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.GitShortHash\",\n    \"category\": \"type\",\n    \"text\": \"GitShortHash(hash::GitHash, len::Integer)\\n\\nA shortened git object identifier, which can be used to identify a git object when it is unique, consisting of the initial len hexadecimal digits of hash (the remaining digits are ignored).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.GitSignature\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.GitSignature\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.GitSignature\\n\\nThis is a Julia wrapper around a pointer to a git_signature object.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.GitStatus\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.GitStatus\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.GitStatus(repo::GitRepo; status_opts=StatusOptions())\\n\\nCollect information about the status of each file in the git repository repo (e.g. is the file modified, staged, etc.). status_opts can be used to set various options, for instance whether or not to look at untracked files or whether to include submodules or not. See StatusOptions for more information.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.GitTag\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.GitTag\",\n    \"category\": \"type\",\n    \"text\": \"GitTag(repo::GitRepo, hash::AbstractGitHash)\\nGitTag(repo::GitRepo, spec::AbstractString)\\n\\nReturn a GitTag object from repo specified by hash/spec.\\n\\nhash is a full (GitHash) or partial (GitShortHash) hash.\\nspec is a textual specification: see the git docs for a full list.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.GitTree\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.GitTree\",\n    \"category\": \"type\",\n    \"text\": \"GitTree(repo::GitRepo, hash::AbstractGitHash)\\nGitTree(repo::GitRepo, spec::AbstractString)\\n\\nReturn a GitTree object from repo specified by hash/spec.\\n\\nhash is a full (GitHash) or partial (GitShortHash) hash.\\nspec is a textual specification: see the git docs for a full list.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.IndexEntry\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.IndexEntry\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.IndexEntry\\n\\nIn-memory representation of a file entry in the index. Matches the git_index_entry struct.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.IndexTime\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.IndexTime\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.IndexTime\\n\\nMatches the git_index_time struct.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.BlameOptions\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.BlameOptions\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.BlameOptions\\n\\nMatches the git_blame_options struct.\\n\\nThe fields represent:\\n\\nversion: version of the struct in use, in case this changes later. For now, always 1.\\nflags: one of Consts.BLAME_NORMAL or Consts.BLAME_FIRST_PARENT (the other blame flags  are not yet implemented by libgit2).\\nmin_match_characters: the minimum number of alphanumeric characters which much change in a commit in order for the change to be associated with that commit. The default is 20. Only takes effect if one of the Consts.BLAME_*_COPIES flags are used, which libgit2 does not implement yet.\\nnewest_commit: the GitHash of the newest commit from which to look at changes.\\noldest_commit: the GitHash of the oldest commit from which to look at changes.\\nmin_line: the first line of the file from which to starting blaming. The default is 1.\\nmax_line: the last line of the file to which to blame. The default is 0, meaning the last line of the file.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.MergeOptions\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.MergeOptions\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.MergeOptions\\n\\nMatches the git_merge_options struct.\\n\\nThe fields represent:\\n\\nversion: version of the struct in use, in case this changes later. For now, always 1.\\nflags: an enum for flags describing merge behavior.  Defined in git_merge_flag_t.  The corresponding Julia enum is GIT_MERGE and has values:\\nMERGE_FIND_RENAMES: detect if a file has been renamed between the common ancestor and the \\\"ours\\\" or \\\"theirs\\\" side of the merge. Allows merges where a file has been renamed.\\nMERGE_FAIL_ON_CONFLICT: exit immediately if a conflict is found rather than trying to resolve it.\\nMERGE_SKIP_REUC: do not write the REUC extension on the index resulting from the merge.\\nMERGE_NO_RECURSIVE: if the commits being merged have multiple merge bases, use the first one, rather than trying to recursively merge the bases.\\nrename_threshold: how similar two files must to consider one a rename of the other. This is an integer that sets the percentage similarity. The default is 50.\\ntarget_limit: the maximum number of files to compare with to look for renames. The default is 200.\\nmetric: optional custom function to use to determine the similarity between two files for rename detection.\\nrecursion_limit: the upper limit on the number of merges of common ancestors to perform to try to build a new virtual merge base for the merge. The default is no limit. This field is only present on libgit2 versions newer than 0.24.0.\\ndefault_driver: the merge driver to use if both sides have changed. This field is only present on libgit2 versions newer than 0.25.0.\\nfile_favor: how to handle conflicting file contents for the text driver.\\nMERGE_FILE_FAVOR_NORMAL: if both sides of the merge have changes to a section,  make a note of the conflict in the index which git checkout will use to create  a merge file, which the user can then reference to resolve the conflicts. This is  the default.\\nMERGE_FILE_FAVOR_OURS: if both sides of the merge have changes to a section,  use the version in the \\\"ours\\\" side of the merge in the index.\\nMERGE_FILE_FAVOR_THEIRS: if both sides of the merge have changes to a section,  use the version in the \\\"theirs\\\" side of the merge in the index.\\nMERGE_FILE_FAVOR_UNION: if both sides of the merge have changes to a section,  include each unique line from both sides in the file which is put into the index.\\nfile_flags: guidelines for merging files.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.ProxyOptions\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.ProxyOptions\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.ProxyOptions\\n\\nOptions for connecting through a proxy.\\n\\nMatches the git_proxy_options struct.\\n\\nThe fields represent:\\n\\nversion: version of the struct in use, in case this changes later. For now, always 1.\\nproxytype: an enum for the type of proxy to use.  Defined in git_proxy_t.  The corresponding Julia enum is GIT_PROXY and has values:\\nPROXY_NONE: do not attempt the connection through a proxy.\\nPROXY_AUTO: attempt to figure out the proxy configuration from the git configuration.\\nPROXY_SPECIFIED: connect using the URL given in the url field of this struct.\\nDefault is to auto-detect the proxy type.\\nurl: the URL of the proxy.\\ncredential_cb: a pointer to a callback function which will be called if the remote requires authentication to connect.\\ncertificate_cb: a pointer to a callback function which will be called if certificate verification fails. This lets the user decide whether or not to keep connecting. If the function returns 1, connecting will be allowed. If it returns 0, the connection will not be allowed. A negative value can be used to return errors.\\npayload: the payload to be provided to the two callback functions.\\n\\nExamples\\n\\njulia> fo = LibGit2.FetchOptions(\\n           proxy_opts = LibGit2.ProxyOptions(url = Cstring(\\\"https://my_proxy_url.com\\\")))\\n\\njulia> fetch(remote, \\\"master\\\", options=fo)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.PushOptions\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.PushOptions\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.PushOptions\\n\\nMatches the git_push_options struct.\\n\\nThe fields represent:\\n\\nversion: version of the struct in use, in case this changes later. For now, always 1.\\nparallelism: if a pack file must be created, this variable sets the number of worker  threads which will be spawned by the packbuilder. If 0, the packbuilder will auto-set  the number of threads to use. The default is 1.\\ncallbacks: the callbacks (e.g. for authentication with the remote) to use for the push.\\nproxy_opts: only relevant if the LibGit2 version is greater than or equal to 0.25.0.  Sets options for using a proxy to communicate with a remote. See ProxyOptions  for more information.\\ncustom_headers: only relevant if the LibGit2 version is greater than or equal to 0.24.0.  Extra headers needed for the push operation.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.RebaseOperation\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.RebaseOperation\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.RebaseOperation\\n\\nDescribes a single instruction/operation to be performed during the rebase. Matches the git_rebase_operation struct.\\n\\nThe fields represent:\\n\\noptype: the type of rebase operation currently being performed. The options are:\\nREBASE_OPERATION_PICK: cherry-pick the commit in question.\\nREBASE_OPERATION_REWORD: cherry-pick the commit in question, but rewrite its message using the prompt.\\nREBASE_OPERATION_EDIT: cherry-pick the commit in question, but allow the user to edit the commit\\'s contents and its message.\\nREBASE_OPERATION_SQUASH: squash the commit in question into the previous commit. The commit messages of the two commits will be merged.\\nREBASE_OPERATION_FIXUP: squash the commit in question into the previous commit. Only the commit message of the previous commit will be used.\\nREBASE_OPERATION_EXEC: do not cherry-pick a commit. Run a command and continue if the command exits successfully.\\nid: the GitHash of the commit being worked on during this rebase step.\\nexec: in case REBASE_OPERATION_EXEC is used, the command to run during this step (for instance, running the test suite after each commit).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.RebaseOptions\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.RebaseOptions\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.RebaseOptions\\n\\nMatches the git_rebase_options struct.\\n\\nThe fields represent:\\n\\nversion: version of the struct in use, in case this changes later. For now, always 1.\\nquiet: inform other git clients helping with/working on the rebase that the rebase should be done \\\"quietly\\\". Used for interoperability. The default is 1.\\ninmemory: start an in-memory rebase. Callers working on the rebase can go through its steps and commit any changes, but cannot rewind HEAD or update the repository. The workdir will not be modified. Only present on libgit2 versions newer than or equal to 0.24.0.\\nrewrite_notes_ref: name of the reference to notes to use to rewrite the commit notes as the rebase is finished.\\nmerge_opts: merge options controlling how the trees will be merged at each rebase step.  Only present on libgit2 versions newer than or equal to 0.24.0.\\ncheckout_opts: checkout options for writing files when initializing the rebase, stepping through it, and aborting it. See CheckoutOptions for more information.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.RemoteCallbacks\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.RemoteCallbacks\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.RemoteCallbacks\\n\\nCallback settings. Matches the git_remote_callbacks struct.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.SignatureStruct\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.SignatureStruct\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.SignatureStruct\\n\\nAn action signature (e.g. for committers, taggers, etc). Matches the git_signature struct.\\n\\nThe fields represent:\\n\\nname: The full name of the committer or author of the commit.\\nemail: The email at which the committer/author can be contacted.\\nwhen: a TimeStruct indicating when the commit was  authored/committed into the repository.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.StatusEntry\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.StatusEntry\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.StatusEntry\\n\\nProviding the differences between the file as it exists in HEAD and the index, and providing the differences between the index and the working directory. Matches the git_status_entry struct.\\n\\nThe fields represent:\\n\\nstatus: contains the status flags for the file, indicating if it is current, or has been changed in some way in the index or work tree.\\nhead_to_index: a pointer to a DiffDelta which encapsulates the difference(s) between the file as it exists in HEAD and in the index.\\nindex_to_workdir: a pointer to a DiffDelta which encapsulates the difference(s) between the file as it exists in the index and in the workdir.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.StatusOptions\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.StatusOptions\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.StatusOptions\\n\\nOptions to control how git_status_foreach_ext() will issue callbacks. Matches the git_status_opt_t struct.\\n\\nThe fields represent:\\n\\nversion: version of the struct in use, in case this changes later. For now, always 1.\\nshow: a flag for which files to examine and in which order. The default is Consts.STATUS_SHOW_INDEX_AND_WORKDIR.\\nflags: flags for controlling any callbacks used in a status call.\\npathspec: an array of paths to use for path-matching. The behavior of the path-matching will vary depending on the values of show and flags.\\nThe baseline is the tree to be used for comparison to the working directory and index; defaults to HEAD.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.StrArrayStruct\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.StrArrayStruct\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.StrArrayStruct\\n\\nA LibGit2 representation of an array of strings. Matches the git_strarray struct.\\n\\nWhen fetching data from LibGit2, a typical usage would look like:\\n\\nsa_ref = Ref(StrArrayStruct())\\n@check ccall(..., (Ptr{StrArrayStruct},), sa_ref)\\nres = convert(Vector{String}, sa_ref[])\\nfree(sa_ref)\\n\\nIn particular, note that LibGit2.free should be called afterward on the Ref object.\\n\\nConversely, when passing a vector of strings to LibGit2, it is generally simplest to rely on implicit conversion:\\n\\nstrs = String[...]\\n@check ccall(..., (Ptr{StrArrayStruct},), strs)\\n\\nNote that no call to free is required as the data is allocated by Julia.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.TimeStruct\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.TimeStruct\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.TimeStruct\\n\\nTime in a signature. Matches the git_time struct.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.add!\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.add!\",\n    \"category\": \"function\",\n    \"text\": \"add!(repo::GitRepo, files::AbstractString...; flags::Cuint = Consts.INDEX_ADD_DEFAULT)\\nadd!(idx::GitIndex, files::AbstractString...; flags::Cuint = Consts.INDEX_ADD_DEFAULT)\\n\\nAdd all the files with paths specified by files to the index idx (or the index of the repo). If the file already exists, the index entry will be updated. If the file does not exist already, it will be newly added into the index. files may contain glob patterns which will be expanded and any matching files will be added (unless INDEX_ADD_DISABLE_PATHSPEC_MATCH is set, see below). If a file has been ignored (in .gitignore or in the config), it will not be added, unless it is already being tracked in the index, in which case it will be updated. The keyword argument flags is a set of bit-flags which control the behavior with respect to ignored files:\\n\\nConsts.INDEX_ADD_DEFAULT - default, described above.\\nConsts.INDEX_ADD_FORCE - disregard the existing ignore rules and force addition of the file to the index even if it is already ignored.\\nConsts.INDEX_ADD_CHECK_PATHSPEC - cannot be used at the same time as INDEX_ADD_FORCE. Check that each file in files which exists on disk is not in the ignore list. If one of the files is ignored, the function will return EINVALIDSPEC.\\nConsts.INDEX_ADD_DISABLE_PATHSPEC_MATCH - turn off glob matching, and only add files to the index which exactly match the paths specified in files.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.add_fetch!\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.add_fetch!\",\n    \"category\": \"function\",\n    \"text\": \"add_fetch!(repo::GitRepo, rmt::GitRemote, fetch_spec::String)\\n\\nAdd a fetch refspec for the specified rmt. This refspec will contain information about which branch(es) to fetch from.\\n\\nExamples\\n\\njulia> LibGit2.add_fetch!(repo, remote, \\\"upstream\\\");\\n\\njulia> LibGit2.fetch_refspecs(remote)\\nString[\\\"+refs/heads/*:refs/remotes/upstream/*\\\"]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.add_push!\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.add_push!\",\n    \"category\": \"function\",\n    \"text\": \"add_push!(repo::GitRepo, rmt::GitRemote, push_spec::String)\\n\\nAdd a push refspec for the specified rmt. This refspec will contain information about which branch(es) to push to.\\n\\nExamples\\n\\njulia> LibGit2.add_push!(repo, remote, \\\"refs/heads/master\\\");\\n\\njulia> remote = LibGit2.get(LibGit2.GitRemote, repo, branch);\\n\\njulia> LibGit2.push_refspecs(remote)\\nString[\\\"refs/heads/master\\\"]\\n\\nnote: Note\\nYou may need to close and reopen the GitRemote in question after updating its push refspecs in order for the change to take effect and for calls to push to work.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.addblob!\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.addblob!\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.addblob!(repo::GitRepo, path::AbstractString)\\n\\nRead the file at path and adds it to the object database of repo as a loose blob. Return the GitHash of the resulting blob.\\n\\nExamples\\n\\nhash_str = string(commit_oid)\\nblob_file = joinpath(repo_path, \\\".git\\\", \\\"objects\\\", hash_str[1:2], hash_str[3:end])\\nid = LibGit2.addblob!(repo, blob_file)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.author\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.author\",\n    \"category\": \"function\",\n    \"text\": \"author(c::GitCommit)\\n\\nReturn the Signature of the author of the commit c. The author is the person who made changes to the relevant file(s). See also committer.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.authors\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.authors\",\n    \"category\": \"function\",\n    \"text\": \"authors(repo::GitRepo) -> Vector{Signature}\\n\\nReturn all authors of commits to the repo repository.\\n\\nExamples\\n\\nrepo = LibGit2.GitRepo(repo_path)\\nrepo_file = open(joinpath(repo_path, test_file), \\\"a\\\")\\n\\nprintln(repo_file, commit_msg)\\nflush(repo_file)\\nLibGit2.add!(repo, test_file)\\nsig = LibGit2.Signature(\\\"TEST\\\", \\\"TEST@TEST.COM\\\", round(time(), 0), 0)\\ncommit_oid1 = LibGit2.commit(repo, \\\"commit1\\\"; author=sig, committer=sig)\\nprintln(repo_file, randstring(10))\\nflush(repo_file)\\nLibGit2.add!(repo, test_file)\\ncommit_oid2 = LibGit2.commit(repo, \\\"commit2\\\"; author=sig, committer=sig)\\n\\n# will be a Vector of [sig, sig]\\nauths = LibGit2.authors(repo)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.branch\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.branch\",\n    \"category\": \"function\",\n    \"text\": \"branch(repo::GitRepo)\\n\\nEquivalent to git branch. Create a new branch from the current HEAD.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.branch!\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.branch!\",\n    \"category\": \"function\",\n    \"text\": \"branch!(repo::GitRepo, branch_name::AbstractString, commit::AbstractString=\\\"\\\"; kwargs...)\\n\\nCheckout a new git branch in the repo repository. commit is the GitHash, in string form, which will be the start of the new branch. If commit is an empty string, the current HEAD will be used.\\n\\nThe keyword arguments are:\\n\\ntrack::AbstractString=\\\"\\\": the name of the remote branch this new branch should track, if any. If empty (the default), no remote branch will be tracked.\\nforce::Bool=false: if true, branch creation will be forced.\\nset_head::Bool=true: if true, after the branch creation finishes the branch head will be set as the HEAD of repo.\\n\\nEquivalent to git checkout [-b|-B] <branch_name> [<commit>] [--track <track>].\\n\\nExamples\\n\\nrepo = LibGit2.GitRepo(repo_path)\\nLibGit2.branch!(repo, \\\"new_branch\\\", set_head=false)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.checkout!\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.checkout!\",\n    \"category\": \"function\",\n    \"text\": \"checkout!(repo::GitRepo, commit::AbstractString=\\\"\\\"; force::Bool=true)\\n\\nEquivalent to git checkout [-f] --detach <commit>. Checkout the git commit commit (a GitHash in string form) in repo. If force is true, force the checkout and discard any current changes. Note that this detaches the current HEAD.\\n\\nExamples\\n\\nrepo = LibGit2.init(repo_path)\\nopen(joinpath(LibGit2.path(repo), \\\"file1\\\"), \\\"w\\\") do f\\n    write(f, \\\"111\\n\\\")\\nend\\nLibGit2.add!(repo, \\\"file1\\\")\\ncommit_oid = LibGit2.commit(repo, \\\"add file1\\\")\\nopen(joinpath(LibGit2.path(repo), \\\"file1\\\"), \\\"w\\\") do f\\n    write(f, \\\"112\\n\\\")\\nend\\n# would fail without the force=true\\n# since there are modifications to the file\\nLibGit2.checkout!(repo, string(commit_oid), force=true)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.clone\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.clone\",\n    \"category\": \"function\",\n    \"text\": \"clone(repo_url::AbstractString, repo_path::AbstractString, clone_opts::CloneOptions)\\n\\nClone the remote repository at repo_url (which can be a remote URL or a path on the local filesystem) to repo_path (which must be a path on the local filesystem). Options for the clone, such as whether to perform a bare clone or not, are set by CloneOptions.\\n\\nExamples\\n\\nrepo_url = \\\"https://github.com/JuliaLang/Example.jl\\\"\\nrepo = LibGit2.clone(repo_url, \\\"/home/me/projects/Example\\\")\\n\\n\\n\\n\\n\\nclone(repo_url::AbstractString, repo_path::AbstractString; kwargs...)\\n\\nClone a remote repository located at repo_url to the local filesystem location repo_path.\\n\\nThe keyword arguments are:\\n\\nbranch::AbstractString=\\\"\\\": which branch of the remote to clone, if not the default repository branch (usually master).\\nisbare::Bool=false: if true, clone the remote as a bare repository, which will make repo_path itself the git directory instead of repo_path/.git. This means that a working tree cannot be checked out. Plays the role of the git CLI argument --bare.\\nremote_cb::Ptr{Cvoid}=C_NULL: a callback which will be used to create the remote before it is cloned. If C_NULL (the default), no attempt will be made to create the remote - it will be assumed to already exist.\\ncredentials::Creds=nothing: provides credentials and/or settings when authenticating against a private repository.\\ncallbacks::Callbacks=Callbacks(): user provided callbacks and payloads.\\n\\nEquivalent to git clone [-b <branch>] [--bare] <repo_url> <repo_path>.\\n\\nExamples\\n\\nrepo_url = \\\"https://github.com/JuliaLang/Example.jl\\\"\\nrepo1 = LibGit2.clone(repo_url, \\\"test_path\\\")\\nrepo2 = LibGit2.clone(repo_url, \\\"test_path\\\", isbare=true)\\njulia_url = \\\"https://github.com/JuliaLang/julia\\\"\\njulia_repo = LibGit2.clone(julia_url, \\\"julia_path\\\", branch=\\\"release-0.6\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.commit\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.commit\",\n    \"category\": \"function\",\n    \"text\": \"commit(repo::GitRepo, msg::AbstractString; kwargs...) -> GitHash\\n\\nWrapper around git_commit_create. Create a commit in the repository repo. msg is the commit message. Return the OID of the new commit.\\n\\nThe keyword arguments are:\\n\\nrefname::AbstractString=Consts.HEAD_FILE: if not NULL, the name of the reference to update to point to the new commit. For example, \\\"HEAD\\\" will update the HEAD of the current branch. If the reference does not yet exist, it will be created.\\nauthor::Signature = Signature(repo) is a Signature containing information about the person who authored the commit.\\ncommitter::Signature = Signature(repo) is a Signature containing information about the person who committed the commit to the repository. Not necessarily the same as author, for instance if author emailed a patch to committer who committed it.\\ntree_id::GitHash = GitHash() is a git tree to use to create the commit, showing its ancestry and relationship with any other history. tree must belong to repo.\\nparent_ids::Vector{GitHash}=GitHash[] is a list of commits by GitHash to use as parent commits for the new one, and may be empty. A commit might have multiple parents if it is a merge commit, for example.\\n\\n\\n\\n\\n\\nLibGit2.commit(rb::GitRebase, sig::GitSignature)\\n\\nCommit the current patch to the rebase rb, using sig as the committer. Is silent if the commit has already been applied.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.committer\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.committer\",\n    \"category\": \"function\",\n    \"text\": \"committer(c::GitCommit)\\n\\nReturn the Signature of the committer of the commit c. The committer is the person who committed the changes originally authored by the author, but need not be the same as the author, for example, if the author emailed a patch to a committer who committed it.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.count\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.count\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.count(f::Function, walker::GitRevWalker; oid::GitHash=GitHash(), by::Cint=Consts.SORT_NONE, rev::Bool=false)\\n\\nUsing the GitRevWalker walker to \\\"walk\\\" over every commit in the repository\\'s history, find the number of commits which return true when f is applied to them. The keyword arguments are:     * oid: The GitHash of the commit to begin the walk from. The default is to use       push_head! and therefore the HEAD commit and all its ancestors.     * by: The sorting method. The default is not to sort. Other options are to sort by       topology (LibGit2.Consts.SORT_TOPOLOGICAL), to sort forwards in time       (LibGit2.Consts.SORT_TIME, most ancient first) or to sort backwards in time       (LibGit2.Consts.SORT_REVERSE, most recent first).     * rev: Whether to reverse the sorted order (for instance, if topological sorting is used).\\n\\nExamples\\n\\ncnt = LibGit2.with(LibGit2.GitRevWalker(repo)) do walker\\n    count((oid, repo)->(oid == commit_oid1), walker, oid=commit_oid1, by=LibGit2.Consts.SORT_TIME)\\nend\\n\\ncount finds the number of commits along the walk with a certain GitHash commit_oid1, starting the walk from that commit and moving forwards in time from it. Since the GitHash is unique to a commit, cnt will be 1.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.counthunks\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.counthunks\",\n    \"category\": \"function\",\n    \"text\": \"counthunks(blame::GitBlame)\\n\\nReturn the number of distinct \\\"hunks\\\" with a file. A hunk may contain multiple lines. A hunk is usually a piece of a file that was added/changed/removed together, for example, a function added to a source file or an inner loop that was optimized out of that function later.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.create_branch\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.create_branch\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.create_branch(repo::GitRepo, bname::AbstractString, commit_obj::GitCommit; force::Bool=false)\\n\\nCreate a new branch in the repository repo with name bname, which points to commit commit_obj (which has to be part of repo). If force is true, overwrite an existing branch named bname if it exists. If force is false and a branch already exists named bname, this function will throw an error.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.credentials_callback\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.credentials_callback\",\n    \"category\": \"function\",\n    \"text\": \"credential_callback(...) -> Cint\\n\\nA LibGit2 credential callback function which provides different credential acquisition functionality w.r.t. a connection protocol. The payload_ptr is required to contain a LibGit2.CredentialPayload object which will keep track of state and settings.\\n\\nThe allowed_types contains a bitmask of LibGit2.Consts.GIT_CREDTYPE values specifying which authentication methods should be attempted.\\n\\nCredential authentication is done in the following order (if supported):\\n\\nSSH agent\\nSSH private/public key pair\\nUsername/password plain text\\n\\nIf a user is presented with a credential prompt they can abort the prompt by typing ^D (pressing the control key together with the d key).\\n\\nNote: Due to the specifics of the libgit2 authentication procedure, when authentication fails, this function is called again without any indication whether authentication was successful or not. To avoid an infinite loop from repeatedly using the same faulty credentials, we will keep track of state using the payload.\\n\\nFor addition details see the LibGit2 guide on authenticating against a server.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.credentials_cb\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.credentials_cb\",\n    \"category\": \"function\",\n    \"text\": \"C function pointer for credentials_callback\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.default_signature\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.default_signature\",\n    \"category\": \"function\",\n    \"text\": \"Return signature object. Free it after use.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.delete_branch\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.delete_branch\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.delete_branch(branch::GitReference)\\n\\nDelete the branch pointed to by branch.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.diff_files\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.diff_files\",\n    \"category\": \"function\",\n    \"text\": \"diff_files(repo::GitRepo, branch1::AbstractString, branch2::AbstractString; kwarg...) -> Vector{AbstractString}\\n\\nShow which files have changed in the git repository repo between branches branch1 and branch2.\\n\\nThe keyword argument is:\\n\\nfilter::Set{Consts.DELTA_STATUS}=Set([Consts.DELTA_ADDED, Consts.DELTA_MODIFIED, Consts.DELTA_DELETED])), and it sets options for the diff. The default is to show files added, modified, or deleted.\\n\\nReturn only the names of the files which have changed, not their contents.\\n\\nExamples\\n\\nLibGit2.branch!(repo, \\\"branch/a\\\")\\nLibGit2.branch!(repo, \\\"branch/b\\\")\\n# add a file to repo\\nopen(joinpath(LibGit2.path(repo),\\\"file\\\"),\\\"w\\\") do f\\n    write(f, \\\"hello repo\\n\\\")\\nend\\nLibGit2.add!(repo, \\\"file\\\")\\nLibGit2.commit(repo, \\\"add file\\\")\\n# returns [\\\"file\\\"]\\nfilt = Set([LibGit2.Consts.DELTA_ADDED])\\nfiles = LibGit2.diff_files(repo, \\\"branch/a\\\", \\\"branch/b\\\", filter=filt)\\n# returns [] because existing files weren\\'t modified\\nfilt = Set([LibGit2.Consts.DELTA_MODIFIED])\\nfiles = LibGit2.diff_files(repo, \\\"branch/a\\\", \\\"branch/b\\\", filter=filt)\\n\\nEquivalent to git diff --name-only --diff-filter=<filter> <branch1> <branch2>.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.entryid\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.entryid\",\n    \"category\": \"function\",\n    \"text\": \"entryid(te::GitTreeEntry)\\n\\nReturn the GitHash of the object to which te refers.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.entrytype\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.entrytype\",\n    \"category\": \"function\",\n    \"text\": \"entrytype(te::GitTreeEntry)\\n\\nReturn the type of the object to which te refers. The result will be one of the types which objtype returns, e.g. a GitTree or GitBlob.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.fetch\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.fetch\",\n    \"category\": \"function\",\n    \"text\": \"fetch(rmt::GitRemote, refspecs; options::FetchOptions=FetchOptions(), msg=\\\"\\\")\\n\\nFetch from the specified rmt remote git repository, using refspecs to determine which remote branch(es) to fetch. The keyword arguments are:\\n\\noptions: determines the options for the fetch, e.g. whether to prune afterwards. See FetchOptions for more information.\\nmsg: a message to insert into the reflogs.\\n\\n\\n\\n\\n\\nfetch(repo::GitRepo; kwargs...)\\n\\nFetches updates from an upstream of the repository repo.\\n\\nThe keyword arguments are:\\n\\nremote::AbstractString=\\\"origin\\\": which remote, specified by name, of repo to fetch from. If this is empty, the URL will be used to construct an anonymous remote.\\nremoteurl::AbstractString=\\\"\\\": the URL of remote. If not specified, will be assumed based on the given name of remote.\\nrefspecs=AbstractString[]: determines properties of the fetch.\\ncredentials=nothing: provides credentials and/or settings when authenticating against a private remote.\\ncallbacks=Callbacks(): user provided callbacks and payloads.\\n\\nEquivalent to git fetch [<remoteurl>|<repo>] [<refspecs>].\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.fetchheads\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.fetchheads\",\n    \"category\": \"function\",\n    \"text\": \"fetchheads(repo::GitRepo) -> Vector{FetchHead}\\n\\nReturn the list of all the fetch heads for repo, each represented as a FetchHead, including their names, URLs, and merge statuses.\\n\\nExamples\\n\\njulia> fetch_heads = LibGit2.fetchheads(repo);\\n\\njulia> fetch_heads[1].name\\n\\\"refs/heads/master\\\"\\n\\njulia> fetch_heads[1].ismerge\\ntrue\\n\\njulia> fetch_heads[2].name\\n\\\"refs/heads/test_branch\\\"\\n\\njulia> fetch_heads[2].ismerge\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.fetch_refspecs\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.fetch_refspecs\",\n    \"category\": \"function\",\n    \"text\": \"fetch_refspecs(rmt::GitRemote) -> Vector{String}\\n\\nGet the fetch refspecs for the specified rmt. These refspecs contain information about which branch(es) to fetch from.\\n\\nExamples\\n\\njulia> remote = LibGit2.get(LibGit2.GitRemote, repo, \\\"upstream\\\");\\n\\njulia> LibGit2.add_fetch!(repo, remote, \\\"upstream\\\");\\n\\njulia> LibGit2.fetch_refspecs(remote)\\nString[\\\"+refs/heads/*:refs/remotes/upstream/*\\\"]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.fetchhead_foreach_cb\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.fetchhead_foreach_cb\",\n    \"category\": \"function\",\n    \"text\": \"C function pointer for fetchhead_foreach_callback\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.merge_base\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.merge_base\",\n    \"category\": \"function\",\n    \"text\": \"merge_base(repo::GitRepo, one::AbstractString, two::AbstractString) -> GitHash\\n\\nFind a merge base (a common ancestor) between the commits one and two. one and two may both be in string form. Return the GitHash of the merge base.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.merge!-Tuple{GitRepo}\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.merge!\",\n    \"category\": \"method\",\n    \"text\": \"merge!(repo::GitRepo; kwargs...) -> Bool\\n\\nPerform a git merge on the repository repo, merging commits with diverging history into the current branch. Return true if the merge succeeded, false if not.\\n\\nThe keyword arguments are:\\n\\ncommittish::AbstractString=\\\"\\\": Merge the named commit(s) in committish.\\nbranch::AbstractString=\\\"\\\": Merge the branch branch and all its commits since it diverged from the current branch.\\nfastforward::Bool=false: If fastforward is true, only merge if the merge is a fast-forward (the current branch head is an ancestor of the commits to be merged), otherwise refuse to merge and return false. This is equivalent to the git CLI option --ff-only.\\nmerge_opts::MergeOptions=MergeOptions(): merge_opts specifies options for the merge, such as merge strategy in case of conflicts.\\ncheckout_opts::CheckoutOptions=CheckoutOptions(): checkout_opts specifies options for the checkout step.\\n\\nEquivalent to git merge [--ff-only] [<committish> | <branch>].\\n\\nnote: Note\\nIf you specify a branch, this must be done in reference format, since the string will be turned into a GitReference. For example, if you wanted to merge branch branch_a, you would call merge!(repo, branch=\\\"refs/heads/branch_a\\\").\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.merge!-Tuple{GitRepo,Array{LibGit2.GitAnnotated,1}}\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.merge!\",\n    \"category\": \"method\",\n    \"text\": \"merge!(repo::GitRepo, anns::Vector{GitAnnotated}; kwargs...) -> Bool\\n\\nMerge changes from the annotated commits (captured as GitAnnotated objects) anns into the HEAD of the repository repo. The keyword arguments are:\\n\\nmerge_opts::MergeOptions = MergeOptions(): options for how to perform the merge, including whether fastforwarding is allowed. See MergeOptions for more information.\\ncheckout_opts::CheckoutOptions = CheckoutOptions(): options for how to perform the checkout. See CheckoutOptions for more information.\\n\\nanns may refer to remote or local branch heads. Return true if the merge is successful, otherwise return false (for instance, if no merge is possible because the branches have no common ancestor).\\n\\nExamples\\n\\nupst_ann = LibGit2.GitAnnotated(repo, \\\"branch/a\\\")\\n\\n# merge the branch in\\nLibGit2.merge!(repo, [upst_ann])\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.merge!-Tuple{GitRepo,Array{LibGit2.GitAnnotated,1},Bool}\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.merge!\",\n    \"category\": \"method\",\n    \"text\": \"merge!(repo::GitRepo, anns::Vector{GitAnnotated}, fastforward::Bool; kwargs...) -> Bool\\n\\nMerge changes from the annotated commits (captured as GitAnnotated objects) anns into the HEAD of the repository repo. If fastforward is true, only a fastforward merge is allowed. In this case, if conflicts occur, the merge will fail. Otherwise, if fastforward is false, the merge may produce a conflict file which the user will need to resolve.\\n\\nThe keyword arguments are:\\n\\nmerge_opts::MergeOptions = MergeOptions(): options for how to perform the merge, including whether fastforwarding is allowed. See MergeOptions for more information.\\ncheckout_opts::CheckoutOptions = CheckoutOptions(): options for how to perform the checkout. See CheckoutOptions for more information.\\n\\nanns may refer to remote or local branch heads. Return true if the merge is successful, otherwise return false (for instance, if no merge is possible because the branches have no common ancestor).\\n\\nExamples\\n\\nupst_ann_1 = LibGit2.GitAnnotated(repo, \\\"branch/a\\\")\\n\\n# merge the branch in, fastforward\\nLibGit2.merge!(repo, [upst_ann_1], true)\\n\\n# merge conflicts!\\nupst_ann_2 = LibGit2.GitAnnotated(repo, \\\"branch/b\\\")\\n# merge the branch in, try to fastforward\\nLibGit2.merge!(repo, [upst_ann_2], true) # will return false\\nLibGit2.merge!(repo, [upst_ann_2], false) # will return true\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.ffmerge!\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.ffmerge!\",\n    \"category\": \"function\",\n    \"text\": \"ffmerge!(repo::GitRepo, ann::GitAnnotated)\\n\\nFastforward merge changes into current HEAD. This is only possible if the commit referred to by ann is descended from the current HEAD (e.g. if pulling changes from a remote branch which is simply ahead of the local branch tip).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.fullname\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.fullname\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.fullname(ref::GitReference)\\n\\nReturn the name of the reference pointed to by the symbolic reference ref. If ref is not a symbolic reference, return an empty string.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.features\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.features\",\n    \"category\": \"function\",\n    \"text\": \"features()\\n\\nReturn a list of git features the current version of libgit2 supports, such as threading or using HTTPS or SSH.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.filename\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.filename\",\n    \"category\": \"function\",\n    \"text\": \"filename(te::GitTreeEntry)\\n\\nReturn the filename of the object on disk to which te refers.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.filemode\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.filemode\",\n    \"category\": \"function\",\n    \"text\": \"filemode(te::GitTreeEntry) -> Cint\\n\\nReturn the UNIX filemode of the object on disk to which te refers as an integer.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.gitdir\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.gitdir\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.gitdir(repo::GitRepo)\\n\\nReturn the location of the \\\"git\\\" files of repo:\\n\\nfor normal repositories, this is the location of the .git folder.\\nfor bare repositories, this is the location of the repository itself.\\n\\nSee also workdir, path.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.git_url\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.git_url\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.git_url(; kwargs...) -> String\\n\\nCreate a string based upon the URL components provided. When the scheme keyword is not provided the URL produced will use the alternative scp-like syntax.\\n\\nKeywords\\n\\nscheme::AbstractString=\\\"\\\": the URL scheme which identifies the protocol to be used. For HTTP use \\\"http\\\", SSH use \\\"ssh\\\", etc. When scheme is not provided the output format will be \\\"ssh\\\" but using the scp-like syntax.\\nusername::AbstractString=\\\"\\\": the username to use in the output if provided.\\npassword::AbstractString=\\\"\\\": the password to use in the output if provided.\\nhost::AbstractString=\\\"\\\": the hostname to use in the output. A hostname is required to be specified.\\nport::Union{AbstractString,Integer}=\\\"\\\": the port number to use in the output if provided. Cannot be specified when using the scp-like syntax.\\npath::AbstractString=\\\"\\\": the path to use in the output if provided.\\n\\nwarning: Warning\\nAvoid using passwords in URLs. Unlike the credential objects, Julia is not able to securely zero or destroy the sensitive data after use and the password may remain in memory; possibly to be exposed by an uninitialized memory.\\n\\nExamples\\n\\njulia> LibGit2.git_url(username=\\\"git\\\", host=\\\"github.com\\\", path=\\\"JuliaLang/julia.git\\\")\\n\\\"git@github.com:JuliaLang/julia.git\\\"\\n\\njulia> LibGit2.git_url(scheme=\\\"https\\\", host=\\\"github.com\\\", path=\\\"/JuliaLang/julia.git\\\")\\n\\\"https://github.com/JuliaLang/julia.git\\\"\\n\\njulia> LibGit2.git_url(scheme=\\\"ssh\\\", username=\\\"git\\\", host=\\\"github.com\\\", port=2222, path=\\\"JuliaLang/julia.git\\\")\\n\\\"ssh://git@github.com:2222/JuliaLang/julia.git\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.@githash_str\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.@githash_str\",\n    \"category\": \"macro\",\n    \"text\": \"@githash_str -> AbstractGitHash\\n\\nConstruct a git hash object from the given string, returning a GitShortHash if the string is shorter than 40 hexadecimal digits, otherwise a GitHash.\\n\\nExamples\\n\\njulia> LibGit2.githash\\\"d114feb74ce633\\\"\\nGitShortHash(\\\"d114feb74ce633\\\")\\n\\njulia> LibGit2.githash\\\"d114feb74ce63307afe878a5228ad014e0289a85\\\"\\nGitHash(\\\"d114feb74ce63307afe878a5228ad014e0289a85\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.head\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.head\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.head(repo::GitRepo) -> GitReference\\n\\nReturn a GitReference to the current HEAD of repo.\\n\\n\\n\\n\\n\\nhead(pkg::AbstractString) -> String\\n\\nReturn current HEAD GitHash of the pkg repo as a string.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.head!\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.head!\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.head!(repo::GitRepo, ref::GitReference) -> GitReference\\n\\nSet the HEAD of repo to the object pointed to by ref.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.head_oid\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.head_oid\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.head_oid(repo::GitRepo) -> GitHash\\n\\nLookup the object id of the current HEAD of git repository repo.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.headname\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.headname\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.headname(repo::GitRepo)\\n\\nLookup the name of the current HEAD of git repository repo. If repo is currently detached, return the name of the HEAD it\\'s detached from.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.init\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.init\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.init(path::AbstractString, bare::Bool=false) -> GitRepo\\n\\nOpen a new git repository at path. If bare is false, the working tree will be created in path/.git. If bare is true, no working directory will be created.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.is_ancestor_of\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.is_ancestor_of\",\n    \"category\": \"function\",\n    \"text\": \"is_ancestor_of(a::AbstractString, b::AbstractString, repo::GitRepo) -> Bool\\n\\nReturn true if a, a GitHash in string form, is an ancestor of b, a GitHash in string form.\\n\\nExamples\\n\\njulia> repo = LibGit2.GitRepo(repo_path);\\n\\njulia> LibGit2.add!(repo, test_file1);\\n\\njulia> commit_oid1 = LibGit2.commit(repo, \\\"commit1\\\");\\n\\njulia> LibGit2.add!(repo, test_file2);\\n\\njulia> commit_oid2 = LibGit2.commit(repo, \\\"commit2\\\");\\n\\njulia> LibGit2.is_ancestor_of(string(commit_oid1), string(commit_oid2), repo)\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.isbinary\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.isbinary\",\n    \"category\": \"function\",\n    \"text\": \"isbinary(blob::GitBlob) -> Bool\\n\\nUse a heuristic to guess if a file is binary: searching for NULL bytes and looking for a reasonable ratio of printable to non-printable characters among the first 8000 bytes.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.iscommit\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.iscommit\",\n    \"category\": \"function\",\n    \"text\": \"iscommit(id::AbstractString, repo::GitRepo) -> Bool\\n\\nCheck if commit id (which is a GitHash in string form) is in the repository.\\n\\nExamples\\n\\njulia> repo = LibGit2.GitRepo(repo_path);\\n\\njulia> LibGit2.add!(repo, test_file);\\n\\njulia> commit_oid = LibGit2.commit(repo, \\\"add test_file\\\");\\n\\njulia> LibGit2.iscommit(string(commit_oid), repo)\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.isdiff\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.isdiff\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.isdiff(repo::GitRepo, treeish::AbstractString, pathspecs::AbstractString=\\\"\\\"; cached::Bool=false)\\n\\nChecks if there are any differences between the tree specified by treeish and the tracked files in the working tree (if cached=false) or the index (if cached=true). pathspecs are the specifications for options for the diff.\\n\\nExamples\\n\\nrepo = LibGit2.GitRepo(repo_path)\\nLibGit2.isdiff(repo, \\\"HEAD\\\") # should be false\\nopen(joinpath(repo_path, new_file), \\\"a\\\") do f\\n    println(f, \\\"here\\'s my cool new file\\\")\\nend\\nLibGit2.isdiff(repo, \\\"HEAD\\\") # now true\\n\\nEquivalent to git diff-index <treeish> [-- <pathspecs>].\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.isdirty\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.isdirty\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.isdirty(repo::GitRepo, pathspecs::AbstractString=\\\"\\\"; cached::Bool=false) -> Bool\\n\\nCheck if there have been any changes to tracked files in the working tree (if cached=false) or the index (if cached=true). pathspecs are the specifications for options for the diff.\\n\\nExamples\\n\\nrepo = LibGit2.GitRepo(repo_path)\\nLibGit2.isdirty(repo) # should be false\\nopen(joinpath(repo_path, new_file), \\\"a\\\") do f\\n    println(f, \\\"here\\'s my cool new file\\\")\\nend\\nLibGit2.isdirty(repo) # now true\\nLibGit2.isdirty(repo, new_file) # now true\\n\\nEquivalent to git diff-index HEAD [-- <pathspecs>].\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.isorphan\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.isorphan\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.isorphan(repo::GitRepo)\\n\\nCheck if the current branch is an \\\"orphan\\\" branch, i.e. has no commits. The first commit to this branch will have no parents.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.isset\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.isset\",\n    \"category\": \"function\",\n    \"text\": \"isset(val::Integer, flag::Integer)\\n\\nTest whether the bits of val indexed by flag are set (1) or unset (0).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.iszero\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.iszero\",\n    \"category\": \"function\",\n    \"text\": \"iszero(id::GitHash) -> Bool\\n\\nDetermine whether all hexadecimal digits of the given GitHash are zero.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.lookup_branch\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.lookup_branch\",\n    \"category\": \"function\",\n    \"text\": \"lookup_branch(repo::GitRepo, branch_name::AbstractString, remote::Bool=false) -> Union{GitReference, Nothing}\\n\\nDetermine if the branch specified by branch_name exists in the repository repo. If remote is true, repo is assumed to be a remote git repository. Otherwise, it is part of the local filesystem.\\n\\nReturn either a GitReference to the requested branch if it exists, or nothing if not.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.map\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.map\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.map(f::Function, walker::GitRevWalker; oid::GitHash=GitHash(), range::AbstractString=\\\"\\\", by::Cint=Consts.SORT_NONE, rev::Bool=false)\\n\\nUsing the GitRevWalker walker to \\\"walk\\\" over every commit in the repository\\'s history, apply f to each commit in the walk. The keyword arguments are:     * oid: The GitHash of the commit to begin the walk from. The default is to use       push_head! and therefore the HEAD commit and all its ancestors.     * range: A range of GitHashs in the format oid1..oid2. f will be       applied to all commits between the two.     * by: The sorting method. The default is not to sort. Other options are to sort by       topology (LibGit2.Consts.SORT_TOPOLOGICAL), to sort forwards in time       (LibGit2.Consts.SORT_TIME, most ancient first) or to sort backwards in time       (LibGit2.Consts.SORT_REVERSE, most recent first).     * rev: Whether to reverse the sorted order (for instance, if topological sorting is used).\\n\\nExamples\\n\\noids = LibGit2.with(LibGit2.GitRevWalker(repo)) do walker\\n    LibGit2.map((oid, repo)->string(oid), walker, by=LibGit2.Consts.SORT_TIME)\\nend\\n\\nHere, map visits each commit using the GitRevWalker and finds its GitHash.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.mirror_callback\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.mirror_callback\",\n    \"category\": \"function\",\n    \"text\": \"Mirror callback function\\n\\nFunction sets +refs/*:refs/* refspecs and mirror flag for remote reference.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.mirror_cb\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.mirror_cb\",\n    \"category\": \"function\",\n    \"text\": \"C function pointer for mirror_callback\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.message\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.message\",\n    \"category\": \"function\",\n    \"text\": \"message(c::GitCommit, raw::Bool=false)\\n\\nReturn the commit message describing the changes made in commit c. If raw is false, return a slightly \\\"cleaned up\\\" message (which has any leading newlines removed). If raw is true, the message is not stripped of any such newlines.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.merge_analysis\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.merge_analysis\",\n    \"category\": \"function\",\n    \"text\": \"merge_analysis(repo::GitRepo, anns::Vector{GitAnnotated}) -> analysis, preference\\n\\nRun analysis on the branches pointed to by the annotated branch tips anns and determine under what circumstances they can be merged. For instance, if anns[1] is simply an ancestor of ann[2], then merge_analysis will report that a fast-forward merge is possible.\\n\\nReturn two outputs, analysis and preference. analysis has several possible values:     * MERGE_ANALYSIS_NONE: it is not possible to merge the elements of anns.     * MERGE_ANALYSIS_NORMAL: a regular merge, when HEAD and the commits that the       user wishes to merge have all diverged from a common ancestor. In this case the       changes have to be resolved and conflicts may occur.     * MERGE_ANALYSIS_UP_TO_DATE: all the input commits the user wishes to merge can       be reached from HEAD, so no merge needs to be performed.     * MERGE_ANALYSIS_FASTFORWARD: the input commit is a descendant of HEAD and so no       merge needs to be performed - instead, the user can simply checkout the       input commit(s).     * MERGE_ANALYSIS_UNBORN: the HEAD of the repository refers to a commit which does not       exist. It is not possible to merge, but it may be possible to checkout the input       commits. preference also has several possible values:     * MERGE_PREFERENCE_NONE: the user has no preference.     * MERGE_PREFERENCE_NO_FASTFORWARD: do not allow any fast-forward merges.     * MERGE_PREFERENCE_FASTFORWARD_ONLY: allow only fast-forward merges and no       other type (which may introduce conflicts). preference can be controlled through the repository or global git configuration.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.name\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.name\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.name(ref::GitReference)\\n\\nReturn the full name of ref.\\n\\n\\n\\n\\n\\nname(rmt::GitRemote)\\n\\nGet the name of a remote repository, for instance \\\"origin\\\". If the remote is anonymous (see GitRemoteAnon) the name will be an empty string \\\"\\\".\\n\\nExamples\\n\\njulia> repo_url = \\\"https://github.com/JuliaLang/Example.jl\\\";\\n\\njulia> repo = LibGit2.clone(cache_repo, \\\"test_directory\\\");\\n\\njulia> remote = LibGit2.GitRemote(repo, \\\"origin\\\", repo_url);\\n\\njulia> name(remote)\\n\\\"origin\\\"\\n\\n\\n\\n\\n\\nLibGit2.name(tag::GitTag)\\n\\nThe name of tag (e.g. \\\"v0.5\\\").\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.need_update\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.need_update\",\n    \"category\": \"function\",\n    \"text\": \"need_update(repo::GitRepo)\\n\\nEquivalent to git update-index. Return true if repo needs updating.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.objtype\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.objtype\",\n    \"category\": \"function\",\n    \"text\": \"objtype(obj_type::Consts.OBJECT)\\n\\nReturn the type corresponding to the enum value.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.path\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.path\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.path(repo::GitRepo)\\n\\nReturn the base file path of the repository repo.\\n\\nfor normal repositories, this will typically be the parent directory of the \\\".git\\\" directory (note: this may be different than the working directory, see workdir for more details).\\nfor bare repositories, this is the location of the \\\"git\\\" files.\\n\\nSee also gitdir, workdir.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.peel\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.peel\",\n    \"category\": \"function\",\n    \"text\": \"peel([T,] ref::GitReference)\\n\\nRecursively peel ref until an object of type T is obtained. If no T is provided, then ref will be peeled until an object other than a GitTag is obtained.\\n\\nA GitTag will be peeled to the object it references.\\nA GitCommit will be peeled to a GitTree.\\n\\nnote: Note\\nOnly annotated tags can be peeled to GitTag objects. Lightweight tags (the default) are references under refs/tags/ which point directly to GitCommit objects.\\n\\n\\n\\n\\n\\npeel([T,] obj::GitObject)\\n\\nRecursively peel obj until an object of type T is obtained. If no T is provided, then obj will be peeled until the type changes.\\n\\nA GitTag will be peeled to the object it references.\\nA GitCommit will be peeled to a GitTree.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.posixpath\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.posixpath\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.posixpath(path)\\n\\nStandardise the path string path to use POSIX separators.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.push\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.push\",\n    \"category\": \"function\",\n    \"text\": \"push(rmt::GitRemote, refspecs; force::Bool=false, options::PushOptions=PushOptions())\\n\\nPush to the specified rmt remote git repository, using refspecs to determine which remote branch(es) to push to. The keyword arguments are:\\n\\nforce: if true, a force-push will occur, disregarding conflicts.\\noptions: determines the options for the push, e.g. which proxy headers to use. See PushOptions for more information.\\n\\nnote: Note\\nYou can add information about the push refspecs in two other ways: by setting an option in the repository\\'s GitConfig (with push.default as the key) or by calling add_push!. Otherwise you will need to explicitly specify a push refspec in the call to push for it to have any effect, like so: LibGit2.push(repo, refspecs=[\\\"refs/heads/master\\\"]).\\n\\n\\n\\n\\n\\npush(repo::GitRepo; kwargs...)\\n\\nPushes updates to an upstream of repo.\\n\\nThe keyword arguments are:\\n\\nremote::AbstractString=\\\"origin\\\": the name of the upstream remote to push to.\\nremoteurl::AbstractString=\\\"\\\": the URL of remote.\\nrefspecs=AbstractString[]: determines properties of the push.\\nforce::Bool=false: determines if the push will be a force push,  overwriting the remote branch.\\ncredentials=nothing: provides credentials and/or settings when authenticating against  a private remote.\\ncallbacks=Callbacks(): user provided callbacks and payloads.\\n\\nEquivalent to git push [<remoteurl>|<repo>] [<refspecs>].\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.push!-Tuple{LibGit2.GitRevWalker,LibGit2.GitHash}\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.push!\",\n    \"category\": \"method\",\n    \"text\": \"LibGit2.push!(w::GitRevWalker, cid::GitHash)\\n\\nStart the GitRevWalker walker at commit cid. This function can be used to apply a function to all commits since a certain year, by passing the first commit of that year as cid and then passing the resulting w to map.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.push_head!\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.push_head!\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.push_head!(w::GitRevWalker)\\n\\nPush the HEAD commit and its ancestors onto the GitRevWalker w. This ensures that HEAD and all its ancestor commits will be encountered during the walk.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.push_refspecs\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.push_refspecs\",\n    \"category\": \"function\",\n    \"text\": \"push_refspecs(rmt::GitRemote) -> Vector{String}\\n\\nGet the push refspecs for the specified rmt. These refspecs contain information about which branch(es) to push to.\\n\\nExamples\\n\\njulia> remote = LibGit2.get(LibGit2.GitRemote, repo, \\\"upstream\\\");\\n\\njulia> LibGit2.add_push!(repo, remote, \\\"refs/heads/master\\\");\\n\\njulia> close(remote);\\n\\njulia> remote = LibGit2.get(LibGit2.GitRemote, repo, \\\"upstream\\\");\\n\\njulia> LibGit2.push_refspecs(remote)\\nString[\\\"refs/heads/master\\\"]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.raw\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.raw\",\n    \"category\": \"function\",\n    \"text\": \"raw(id::GitHash) -> Vector{UInt8}\\n\\nObtain the raw bytes of the GitHash as a vector of length 20.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.read_tree!\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.read_tree!\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.read_tree!(idx::GitIndex, tree::GitTree)\\nLibGit2.read_tree!(idx::GitIndex, treehash::AbstractGitHash)\\n\\nRead the tree tree (or the tree pointed to by treehash in the repository owned by idx) into the index idx. The current index contents will be replaced.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.rebase!\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.rebase!\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.rebase!(repo::GitRepo, upstream::AbstractString=\\\"\\\", newbase::AbstractString=\\\"\\\")\\n\\nAttempt an automatic merge rebase of the current branch, from upstream if provided, or otherwise from the upstream tracking branch. newbase is the branch to rebase onto. By default this is upstream.\\n\\nIf any conflicts arise which cannot be automatically resolved, the rebase will abort, leaving the repository and working tree in its original state, and the function will throw a GitError. This is roughly equivalent to the following command line statement:\\n\\ngit rebase --merge [<upstream>]\\nif [ -d \\\".git/rebase-merge\\\" ]; then\\n    git rebase --abort\\nfi\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.ref_list\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.ref_list\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.ref_list(repo::GitRepo) -> Vector{String}\\n\\nGet a list of all reference names in the repo repository.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.reftype\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.reftype\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.reftype(ref::GitReference) -> Cint\\n\\nReturn a Cint corresponding to the type of ref:\\n\\n0 if the reference is invalid\\n1 if the reference is an object id\\n2 if the reference is symbolic\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.remotes\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.remotes\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.remotes(repo::GitRepo)\\n\\nReturn a vector of the names of the remotes of repo.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.remove!\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.remove!\",\n    \"category\": \"function\",\n    \"text\": \"remove!(repo::GitRepo, files::AbstractString...)\\nremove!(idx::GitIndex, files::AbstractString...)\\n\\nRemove all the files with paths specified by files in the index idx (or the index of the repo).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.reset\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.reset\",\n    \"category\": \"function\",\n    \"text\": \"reset(val::Integer, flag::Integer)\\n\\nUnset the bits of val indexed by flag, returning them to 0.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.reset!\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.reset!\",\n    \"category\": \"function\",\n    \"text\": \"reset!(payload, [config]) -> CredentialPayload\\n\\nReset the payload state back to the initial values so that it can be used again within the credential callback. If a config is provided the configuration will also be updated.\\n\\n\\n\\n\\n\\nUpdates some entries, determined by the pathspecs, in the index from the target commit tree.\\n\\n\\n\\n\\n\\nSets the current head to the specified commit oid and optionally resets the index and working tree to match.\\n\\n\\n\\n\\n\\ngit reset [<committish>] [\u2013] <pathspecs>... \\n\\n\\n\\n\\n\\nreset!(repo::GitRepo, id::GitHash, mode::Cint=Consts.RESET_MIXED)\\n\\nReset the repository repo to its state at id, using one of three modes set by mode:\\n\\nConsts.RESET_SOFT - move HEAD to id.\\nConsts.RESET_MIXED - default, move HEAD to id and reset the index to id.\\nConsts.RESET_HARD - move HEAD to id, reset the index to id, and discard all working changes.\\n\\nExamples\\n\\n# fetch changes\\nLibGit2.fetch(repo)\\nisfile(joinpath(repo_path, our_file)) # will be false\\n\\n# fastforward merge the changes\\nLibGit2.merge!(repo, fastforward=true)\\n\\n# because there was not any file locally, but there is\\n# a file remotely, we need to reset the branch\\nhead_oid = LibGit2.head_oid(repo)\\nnew_head = LibGit2.reset!(repo, head_oid, LibGit2.Consts.RESET_HARD)\\n\\nIn this example, the remote which is being fetched from does have a file called our_file in its index, which is why we must reset.\\n\\nEquivalent to git reset [--soft | --mixed | --hard] <id>.\\n\\nExamples\\n\\nrepo = LibGit2.GitRepo(repo_path)\\nhead_oid = LibGit2.head_oid(repo)\\nopen(joinpath(repo_path, \\\"file1\\\"), \\\"w\\\") do f\\n    write(f, \\\"111\\n\\\")\\nend\\nLibGit2.add!(repo, \\\"file1\\\")\\nmode = LibGit2.Consts.RESET_HARD\\n# will discard the changes to file1\\n# and unstage it\\nnew_head = LibGit2.reset!(repo, head_oid, mode)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.restore\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.restore\",\n    \"category\": \"function\",\n    \"text\": \"restore(s::State, repo::GitRepo)\\n\\nReturn a repository repo to a previous State s, for example the HEAD of a branch before a merge attempt. s can be generated using the snapshot function.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.revcount\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.revcount\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.revcount(repo::GitRepo, commit1::AbstractString, commit2::AbstractString)\\n\\nList the number of revisions between commit1 and commit2 (committish OIDs in string form). Since commit1 and commit2 may be on different branches, revcount performs a \\\"left-right\\\" revision list (and count), returning a tuple of Ints - the number of left and right commits, respectively. A left (or right) commit refers to which side of a symmetric difference in a tree the commit is reachable from.\\n\\nEquivalent to git rev-list --left-right --count <commit1> <commit2>.\\n\\nExamples\\n\\nrepo = LibGit2.GitRepo(repo_path)\\nrepo_file = open(joinpath(repo_path, test_file), \\\"a\\\")\\nprintln(repo_file, \\\"hello world\\\")\\nflush(repo_file)\\nLibGit2.add!(repo, test_file)\\ncommit_oid1 = LibGit2.commit(repo, \\\"commit 1\\\")\\nprintln(repo_file, \\\"hello world again\\\")\\nflush(repo_file)\\nLibGit2.add!(repo, test_file)\\ncommit_oid2 = LibGit2.commit(repo, \\\"commit 2\\\")\\nLibGit2.revcount(repo, string(commit_oid1), string(commit_oid2))\\n\\nThis will return (-1, 0).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.set_remote_url\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.set_remote_url\",\n    \"category\": \"function\",\n    \"text\": \"set_remote_url(repo::GitRepo, remote_name, url)\\nset_remote_url(repo::String, remote_name, url)\\n\\nSet both the fetch and push url for remote_name for the GitRepo or the git repository located at path. Typically git repos use \\\"origin\\\" as the remote name.\\n\\nExamples\\n\\nrepo_path = joinpath(tempdir(), \\\"Example\\\")\\nrepo = LibGit2.init(repo_path)\\nLibGit2.set_remote_url(repo, \\\"upstream\\\", \\\"https://github.com/JuliaLang/Example.jl\\\")\\nLibGit2.set_remote_url(repo_path, \\\"upstream2\\\", \\\"https://github.com/JuliaLang/Example2.jl\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.shortname\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.shortname\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.shortname(ref::GitReference)\\n\\nReturn a shortened version of the name of ref that\\'s \\\"human-readable\\\".\\n\\njulia> repo = LibGit2.GitRepo(path_to_repo);\\n\\njulia> branch_ref = LibGit2.head(repo);\\n\\njulia> LibGit2.name(branch_ref)\\n\\\"refs/heads/master\\\"\\n\\njulia> LibGit2.shortname(branch_ref)\\n\\\"master\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.snapshot\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.snapshot\",\n    \"category\": \"function\",\n    \"text\": \"snapshot(repo::GitRepo) -> State\\n\\nTake a snapshot of the current state of the repository repo, storing the current HEAD, index, and any uncommitted work. The output State can be used later during a call to restore to return the repository to the snapshotted state.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.split_cfg_entry\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.split_cfg_entry\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.split_cfg_entry(ce::LibGit2.ConfigEntry) -> Tuple{String,String,String,String}\\n\\nBreak the ConfigEntry up to the following pieces: section, subsection, name, and value.\\n\\nExamples\\n\\nGiven the git configuration file containing:\\n\\n[credential \\\"https://example.com\\\"]\\n    username = me\\n\\nThe ConfigEntry would look like the following:\\n\\njulia> entry\\nConfigEntry(\\\"credential.https://example.com.username\\\", \\\"me\\\")\\n\\njulia> LibGit2.split_cfg_entry(entry)\\n(\\\"credential\\\", \\\"https://example.com\\\", \\\"username\\\", \\\"me\\\")\\n\\nRefer to the git config syntax documentation for more details.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.status\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.status\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.status(repo::GitRepo, path::String) -> Union{Cuint, Cvoid}\\n\\nLookup the status of the file at path in the git repository repo. For instance, this can be used to check if the file at path has been modified and needs to be staged and committed.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.stage\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.stage\",\n    \"category\": \"function\",\n    \"text\": \"stage(ie::IndexEntry) -> Cint\\n\\nGet the stage number of ie. The stage number 0 represents the current state of the working tree, but other numbers can be used in the case of a merge conflict. In such a case, the various stage numbers on an IndexEntry describe which side(s) of the conflict the current state of the file belongs to. Stage 0 is the state before the attempted merge, stage 1 is the changes which have been made locally, stages 2 and larger are for changes from other branches (for instance, in the case of a multi-branch \\\"octopus\\\" merge, stages 2, 3, and 4 might be used).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.tag_create\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.tag_create\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.tag_create(repo::GitRepo, tag::AbstractString, commit; kwargs...)\\n\\nCreate a new git tag tag (e.g. \\\"v0.5\\\") in the repository repo, at the commit commit.\\n\\nThe keyword arguments are:\\n\\nmsg::AbstractString=\\\"\\\": the message for the tag.\\nforce::Bool=false: if true, existing references will be overwritten.\\nsig::Signature=Signature(repo): the tagger\\'s signature.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.tag_delete\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.tag_delete\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.tag_delete(repo::GitRepo, tag::AbstractString)\\n\\nRemove the git tag tag from the repository repo.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.tag_list\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.tag_list\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.tag_list(repo::GitRepo) -> Vector{String}\\n\\nGet a list of all tags in the git repository repo.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.target\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.target\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.target(tag::GitTag)\\n\\nThe GitHash of the target object of tag.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.toggle\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.toggle\",\n    \"category\": \"function\",\n    \"text\": \"toggle(val::Integer, flag::Integer)\\n\\nFlip the bits of val indexed by flag, so that if a bit is 0 it will be 1 after the toggle, and vice-versa.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.transact\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.transact\",\n    \"category\": \"function\",\n    \"text\": \"transact(f::Function, repo::GitRepo)\\n\\nApply function f to the git repository repo, taking a snapshot before applying f. If an error occurs within f, repo will be returned to its snapshot state using restore. The error which occurred will be rethrown, but the state of repo will not be corrupted.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.treewalk\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.treewalk\",\n    \"category\": \"function\",\n    \"text\": \"treewalk(f, tree::GitTree, post::Bool=false)\\n\\nTraverse the entries in tree and its subtrees in post or pre order. Preorder means beginning at the root and then traversing the leftmost subtree (and recursively on down through that subtree\\'s leftmost subtrees) and moving right through the subtrees. Postorder means beginning at the bottom of the leftmost subtree, traversing upwards through it, then traversing the next right subtree (again beginning at the bottom) and finally visiting the tree root last of all.\\n\\nThe function parameter f should have following signature:\\n\\n(String, GitTreeEntry) -> Cint\\n\\nA negative value returned from f stops the tree walk. A positive value means that the entry will be skipped if post is false.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.upstream\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.upstream\",\n    \"category\": \"function\",\n    \"text\": \"upstream(ref::GitReference) -> Union{GitReference, Nothing}\\n\\nDetermine if the branch containing ref has a specified upstream branch.\\n\\nReturn either a GitReference to the upstream branch if it exists, or nothing if the requested branch does not have an upstream counterpart.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.update!\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.update!\",\n    \"category\": \"function\",\n    \"text\": \"update!(repo::GitRepo, files::AbstractString...)\\nupdate!(idx::GitIndex, files::AbstractString...)\\n\\nUpdate all the files with paths specified by files in the index idx (or the index of the repo). Match the state of each file in the index with the current state on disk, removing it if it has been removed on disk, or updating its entry in the object database.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.url\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.url\",\n    \"category\": \"function\",\n    \"text\": \"url(rmt::GitRemote)\\n\\nGet the fetch URL of a remote git repository.\\n\\nExamples\\n\\njulia> repo_url = \\\"https://github.com/JuliaLang/Example.jl\\\";\\n\\njulia> repo = LibGit2.init(mktempdir());\\n\\njulia> remote = LibGit2.GitRemote(repo, \\\"origin\\\", repo_url);\\n\\njulia> LibGit2.url(remote)\\n\\\"https://github.com/JuliaLang/Example.jl\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.version\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.version\",\n    \"category\": \"function\",\n    \"text\": \"version() -> VersionNumber\\n\\nReturn the version of libgit2 in use, as a VersionNumber.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.with\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.with\",\n    \"category\": \"function\",\n    \"text\": \"with(f::Function, obj)\\n\\nResource management helper function. Applies f to obj, making sure to call close on obj after f successfully returns or throws an error. Ensures that allocated git resources are finalized as soon as they are no longer needed.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.with_warn\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.with_warn\",\n    \"category\": \"function\",\n    \"text\": \"with_warn(f::Function, ::Type{T}, args...)\\n\\nResource management helper function. Apply f to args, first constructing an instance of type T from args. Makes sure to call close on the resulting object after f successfully returns or throws an error. Ensures that allocated git resources are finalized as soon as they are no longer needed. If an error is thrown by f, a warning is shown containing the error.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.workdir\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.workdir\",\n    \"category\": \"function\",\n    \"text\": \"LibGit2.workdir(repo::GitRepo)\\n\\nReturn the location of the working directory of repo. This will throw an error for bare repositories.\\n\\nnote: Note\\nThis will typically be the parent directory of gitdir(repo), but can be different in some cases: e.g. if either the core.worktree configuration variable or the GIT_WORK_TREE environment variable is set.\\n\\nSee also gitdir, path.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.GitObject-Tuple{LibGit2.GitTreeEntry}\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.GitObject\",\n    \"category\": \"method\",\n    \"text\": \"(::Type{T})(te::GitTreeEntry) where T<:GitObject\\n\\nGet the git object to which te refers and return it as its actual type (the type entrytype would show), for instance a GitBlob or GitTag.\\n\\nExamples\\n\\ntree = LibGit2.GitTree(repo, \\\"HEAD^{tree}\\\")\\ntree_entry = tree[1]\\nblob = LibGit2.GitBlob(tree_entry)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.UserPasswordCredential\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.UserPasswordCredential\",\n    \"category\": \"type\",\n    \"text\": \"Credential that support only user and password parameters\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.SSHCredential\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.SSHCredential\",\n    \"category\": \"type\",\n    \"text\": \"SSH credential type\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.isfilled\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.isfilled\",\n    \"category\": \"function\",\n    \"text\": \"isfilled(cred::AbstractCredential) -> Bool\\n\\nVerifies that a credential is ready for use in authentication.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.CachedCredentials\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.CachedCredentials\",\n    \"category\": \"type\",\n    \"text\": \"Caches credential information for re-use\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.CredentialPayload\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.CredentialPayload\",\n    \"category\": \"type\",\n    \"text\": \"LibGit2.CredentialPayload\\n\\nRetains the state between multiple calls to the credential callback for the same URL. A CredentialPayload instance is expected to be reset! whenever it will be used with a different URL.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.approve\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.approve\",\n    \"category\": \"function\",\n    \"text\": \"approve(payload::CredentialPayload; shred::Bool=true) -> Nothing\\n\\nStore the payload credential for re-use in a future authentication. Should only be called when authentication was successful.\\n\\nThe shred keyword controls whether sensitive information in the payload credential field should be destroyed. Should only be set to false during testing.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#LibGit2.reject\",\n    \"page\": \"LibGit2\",\n    \"title\": \"LibGit2.reject\",\n    \"category\": \"function\",\n    \"text\": \"reject(payload::CredentialPayload; shred::Bool=true) -> Nothing\\n\\nDiscard the payload credential from begin re-used in future authentication. Should only be called when authentication was unsuccessful.\\n\\nThe shred keyword controls whether sensitive information in the payload credential field should be destroyed. Should only be set to false during testing.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LibGit2.html#Functionality-1\",\n    \"page\": \"LibGit2\",\n    \"title\": \"Functionality\",\n    \"category\": \"section\",\n    \"text\": \"Some of this documentation assumes some prior knowledge of the libgit2 API. For more information on some of the objects and methods referenced here, consult the upstream libgit2 API reference.LibGit2.Buffer\\nLibGit2.CheckoutOptions\\nLibGit2.CloneOptions\\nLibGit2.DescribeOptions\\nLibGit2.DescribeFormatOptions\\nLibGit2.DiffDelta\\nLibGit2.DiffFile\\nLibGit2.DiffOptionsStruct\\nLibGit2.FetchHead\\nLibGit2.FetchOptions\\nLibGit2.GitAnnotated\\nLibGit2.GitBlame\\nLibGit2.GitBlob\\nLibGit2.GitCommit\\nLibGit2.GitHash\\nLibGit2.GitObject\\nLibGit2.GitRemote\\nLibGit2.GitRemoteAnon\\nLibGit2.GitRepo\\nLibGit2.GitRepoExt\\nLibGit2.GitRevWalker\\nLibGit2.GitShortHash\\nLibGit2.GitSignature\\nLibGit2.GitStatus\\nLibGit2.GitTag\\nLibGit2.GitTree\\nLibGit2.IndexEntry\\nLibGit2.IndexTime\\nLibGit2.BlameOptions\\nLibGit2.MergeOptions\\nLibGit2.ProxyOptions\\nLibGit2.PushOptions\\nLibGit2.RebaseOperation\\nLibGit2.RebaseOptions\\nLibGit2.RemoteCallbacks\\nLibGit2.SignatureStruct\\nLibGit2.StatusEntry\\nLibGit2.StatusOptions\\nLibGit2.StrArrayStruct\\nLibGit2.TimeStruct\\nLibGit2.add!\\nLibGit2.add_fetch!\\nLibGit2.add_push!\\nLibGit2.addblob!\\nLibGit2.author\\nLibGit2.authors\\nLibGit2.branch\\nLibGit2.branch!\\nLibGit2.checkout!\\nLibGit2.clone\\nLibGit2.commit\\nLibGit2.committer\\nLibGit2.count\\nLibGit2.counthunks\\nLibGit2.create_branch\\nLibGit2.credentials_callback\\nLibGit2.credentials_cb\\nLibGit2.default_signature\\nLibGit2.delete_branch\\nLibGit2.diff_files\\nLibGit2.entryid\\nLibGit2.entrytype\\nLibGit2.fetch\\nLibGit2.fetchheads\\nLibGit2.fetch_refspecs\\nLibGit2.fetchhead_foreach_cb\\nLibGit2.merge_base\\nLibGit2.merge!(::LibGit2.GitRepo; ::Any...)\\nLibGit2.merge!(::LibGit2.GitRepo, ::Vector{LibGit2.GitAnnotated}; ::LibGit2.MergeOptions, ::LibGit2.CheckoutOptions)\\nLibGit2.merge!(::LibGit2.GitRepo, ::Vector{LibGit2.GitAnnotated}, ::Bool; ::LibGit2.MergeOptions, ::LibGit2.CheckoutOptions)\\nLibGit2.ffmerge!\\nLibGit2.fullname\\nLibGit2.features\\nLibGit2.filename\\nLibGit2.filemode\\nLibGit2.gitdir\\nLibGit2.git_url\\nLibGit2.@githash_str\\nLibGit2.head\\nLibGit2.head!\\nLibGit2.head_oid\\nLibGit2.headname\\nLibGit2.init\\nLibGit2.is_ancestor_of\\nLibGit2.isbinary\\nLibGit2.iscommit\\nLibGit2.isdiff\\nLibGit2.isdirty\\nLibGit2.isorphan\\nLibGit2.isset\\nLibGit2.iszero\\nLibGit2.lookup_branch\\nLibGit2.map\\nLibGit2.mirror_callback\\nLibGit2.mirror_cb\\nLibGit2.message\\nLibGit2.merge_analysis\\nLibGit2.name\\nLibGit2.need_update\\nLibGit2.objtype\\nLibGit2.path\\nLibGit2.peel\\nLibGit2.posixpath\\nLibGit2.push\\nLibGit2.push!(::LibGit2.GitRevWalker, ::LibGit2.GitHash)\\nLibGit2.push_head!\\nLibGit2.push_refspecs\\nLibGit2.raw\\nLibGit2.read_tree!\\nLibGit2.rebase!\\nLibGit2.ref_list\\nLibGit2.reftype\\nLibGit2.remotes\\nLibGit2.remove!\\nLibGit2.reset\\nLibGit2.reset!\\nLibGit2.restore\\nLibGit2.revcount\\nLibGit2.set_remote_url\\nLibGit2.shortname\\nLibGit2.snapshot\\nLibGit2.split_cfg_entry\\nLibGit2.status\\nLibGit2.stage\\nLibGit2.tag_create\\nLibGit2.tag_delete\\nLibGit2.tag_list\\nLibGit2.target\\nLibGit2.toggle\\nLibGit2.transact\\nLibGit2.treewalk\\nLibGit2.upstream\\nLibGit2.update!\\nLibGit2.url\\nLibGit2.version\\nLibGit2.with\\nLibGit2.with_warn\\nLibGit2.workdir\\nLibGit2.GitObject(::LibGit2.GitTreeEntry)\\nLibGit2.UserPasswordCredential\\nLibGit2.SSHCredential\\nLibGit2.isfilled\\nLibGit2.CachedCredentials\\nLibGit2.CredentialPayload\\nLibGit2.approve\\nLibGit2.rejectDocTestSetup = nothing\"\n},\n\n{\n    \"location\": \"stdlib/Libdl.html#\",\n    \"page\": \"Dynamic Linker\",\n    \"title\": \"Dynamic Linker\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Libdl.html#Libdl.dlopen\",\n    \"page\": \"Dynamic Linker\",\n    \"title\": \"Libdl.dlopen\",\n    \"category\": \"function\",\n    \"text\": \"dlopen(libfile::AbstractString [, flags::Integer])\\n\\nLoad a shared library, returning an opaque handle.\\n\\nThe extension given by the constant dlext (.so, .dll, or .dylib) can be omitted from the libfile string, as it is automatically appended if needed.   If libfile is not an absolute path name, then the paths in the array DL_LOAD_PATH are searched for libfile, followed by the system load path.\\n\\nThe optional flags argument is a bitwise-or of zero or more of RTLD_LOCAL, RTLD_GLOBAL, RTLD_LAZY, RTLD_NOW, RTLD_NODELETE, RTLD_NOLOAD, RTLD_DEEPBIND, and RTLD_FIRST. These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default dlopen flags are RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL while on other platforms the defaults are RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL. An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL allows the library\\'s symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Libdl.html#Libdl.dlopen_e\",\n    \"page\": \"Dynamic Linker\",\n    \"title\": \"Libdl.dlopen_e\",\n    \"category\": \"function\",\n    \"text\": \"dlopen_e(libfile::AbstractString [, flags::Integer])\\n\\nSimilar to dlopen, except returns a NULL pointer instead of raising errors.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Libdl.html#Libdl.RTLD_NOW\",\n    \"page\": \"Dynamic Linker\",\n    \"title\": \"Libdl.RTLD_NOW\",\n    \"category\": \"constant\",\n    \"text\": \"RTLD_DEEPBIND\\nRTLD_FIRST\\nRTLD_GLOBAL\\nRTLD_LAZY\\nRTLD_LOCAL\\nRTLD_NODELETE\\nRTLD_NOLOAD\\nRTLD_NOW\\n\\nEnum constant for dlopen. See your platform man page for details, if applicable.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Libdl.html#Libdl.dlsym\",\n    \"page\": \"Dynamic Linker\",\n    \"title\": \"Libdl.dlsym\",\n    \"category\": \"function\",\n    \"text\": \"dlsym(handle, sym)\\n\\nLook up a symbol from a shared library handle, return callable function pointer on success.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Libdl.html#Libdl.dlsym_e\",\n    \"page\": \"Dynamic Linker\",\n    \"title\": \"Libdl.dlsym_e\",\n    \"category\": \"function\",\n    \"text\": \"dlsym_e(handle, sym)\\n\\nLook up a symbol from a shared library handle, silently return NULL pointer on lookup failure.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Libdl.html#Libdl.dlclose\",\n    \"page\": \"Dynamic Linker\",\n    \"title\": \"Libdl.dlclose\",\n    \"category\": \"function\",\n    \"text\": \"dlclose(handle)\\n\\nClose shared library referenced by handle.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Libdl.html#Libdl.dlext\",\n    \"page\": \"Dynamic Linker\",\n    \"title\": \"Libdl.dlext\",\n    \"category\": \"constant\",\n    \"text\": \"dlext\\n\\nFile extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Libdl.html#Libdl.find_library\",\n    \"page\": \"Dynamic Linker\",\n    \"title\": \"Libdl.find_library\",\n    \"category\": \"function\",\n    \"text\": \"find_library(names, locations)\\n\\nSearches for the first library in names in the paths in the locations list, DL_LOAD_PATH, or system library paths (in that order) which can successfully be dlopen\\'d. On success, the return value will be one of the names (potentially prefixed by one of the paths in locations). This string can be assigned to a global const and used as the library name in future ccall\\'s. On failure, it returns the empty string.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Libdl.html#Base.DL_LOAD_PATH\",\n    \"page\": \"Dynamic Linker\",\n    \"title\": \"Base.DL_LOAD_PATH\",\n    \"category\": \"constant\",\n    \"text\": \"DL_LOAD_PATH\\n\\nWhen calling dlopen, the paths in this list will be searched first, in order, before searching the system locations for a valid library handle.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Libdl.html#Dynamic-Linker-1\",\n    \"page\": \"Dynamic Linker\",\n    \"title\": \"Dynamic Linker\",\n    \"category\": \"section\",\n    \"text\": \"Libdl.dlopen\\nLibdl.dlopen_e\\nLibdl.RTLD_NOW\\nLibdl.dlsym\\nLibdl.dlsym_e\\nLibdl.dlclose\\nLibdl.dlext\\nLibdl.find_library\\nLibdl.DL_LOAD_PATH\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Linear Algebra\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Linear-Algebra-1\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Linear Algebra\",\n    \"category\": \"section\",\n    \"text\": \"DocTestSetup = :(using LinearAlgebra)In addition to (and as part of) its support for multi-dimensional arrays, Julia provides native implementations of many common and useful linear algebra operations. Basic operations, such as tr, det, and inv are all supported:julia> A = [1 2 3; 4 1 6; 7 8 1]\\n3\u00d73 Array{Int64,2}:\\n 1  2  3\\n 4  1  6\\n 7  8  1\\n\\njulia> tr(A)\\n3\\n\\njulia> det(A)\\n104.0\\n\\njulia> inv(A)\\n3\u00d73 Array{Float64,2}:\\n -0.451923   0.211538    0.0865385\\n  0.365385  -0.192308    0.0576923\\n  0.240385   0.0576923  -0.0673077As well as other useful operations, such as finding eigenvalues or eigenvectors:julia> A = [-4. -17.; 2. 2.]\\n2\u00d72 Array{Float64,2}:\\n -4.0  -17.0\\n  2.0    2.0\\n\\njulia> eigvals(A)\\n2-element Array{Complex{Float64},1}:\\n -1.0 + 5.0im\\n -1.0 - 5.0im\\n\\njulia> eigvecs(A)\\n2\u00d72 Array{Complex{Float64},2}:\\n  0.945905+0.0im        0.945905-0.0im\\n -0.166924-0.278207im  -0.166924+0.278207imIn addition, Julia provides many factorizations which can be used to speed up problems such as linear solve or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory reasons) to the problem. See the documentation on factorize for more information. As an example:julia> A = [1.5 2 -4; 3 -1 -6; -10 2.3 4]\\n3\u00d73 Array{Float64,2}:\\n   1.5   2.0  -4.0\\n   3.0  -1.0  -6.0\\n -10.0   2.3   4.0\\n\\njulia> factorize(A)\\nLU{Float64,Array{Float64,2}}\\nL factor:\\n3\u00d73 Array{Float64,2}:\\n  1.0    0.0       0.0\\n -0.15   1.0       0.0\\n -0.3   -0.132196  1.0\\nU factor:\\n3\u00d73 Array{Float64,2}:\\n -10.0  2.3     4.0\\n   0.0  2.345  -3.4\\n   0.0  0.0    -5.24947Since A is not Hermitian, symmetric, triangular, tridiagonal, or bidiagonal, an LU factorization may be the best we can do. Compare with:julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]\\n3\u00d73 Array{Float64,2}:\\n  1.5   2.0  -4.0\\n  2.0  -1.0  -3.0\\n -4.0  -3.0   5.0\\n\\njulia> factorize(B)\\nBunchKaufman{Float64,Array{Float64,2}}\\nD factor:\\n3\u00d73 Tridiagonal{Float64,Array{Float64,1}}:\\n -1.64286   0.0   \u22c5\\n  0.0      -2.8  0.0\\n   \u22c5        0.0  5.0\\nU factor:\\n3\u00d73 UnitUpperTriangular{Float64,Array{Float64,2}}:\\n 1.0  0.142857  -0.8\\n  \u22c5   1.0       -0.6\\n  \u22c5    \u22c5         1.0\\npermutation:\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3Here, Julia was able to detect that B is in fact symmetric, and used a more appropriate factorization. Often it\\'s possible to write more efficient code for a matrix that is known to have certain properties e.g. it is symmetric, or tridiagonal. Julia provides some special types so that you can \\\"tag\\\" matrices as having these properties. For instance:julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]\\n3\u00d73 Array{Float64,2}:\\n  1.5   2.0  -4.0\\n  2.0  -1.0  -3.0\\n -4.0  -3.0   5.0\\n\\njulia> sB = Symmetric(B)\\n3\u00d73 Symmetric{Float64,Array{Float64,2}}:\\n  1.5   2.0  -4.0\\n  2.0  -1.0  -3.0\\n -4.0  -3.0   5.0sB has been tagged as a matrix that\\'s (real) symmetric, so for later operations we might perform on it, such as eigenfactorization or computing matrix-vector products, efficiencies can be found by only referencing half of it. For example:julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]\\n3\u00d73 Array{Float64,2}:\\n  1.5   2.0  -4.0\\n  2.0  -1.0  -3.0\\n -4.0  -3.0   5.0\\n\\njulia> sB = Symmetric(B)\\n3\u00d73 Symmetric{Float64,Array{Float64,2}}:\\n  1.5   2.0  -4.0\\n  2.0  -1.0  -3.0\\n -4.0  -3.0   5.0\\n\\njulia> x = [1; 2; 3]\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n\\njulia> sB\\\\x\\n3-element Array{Float64,1}:\\n -1.7391304347826084\\n -1.1086956521739126\\n -1.4565217391304346The \\\\ operation here performs the linear solution. The left-division operator is pretty powerful and it\\'s easy to write compact, readable code that is flexible enough to solve all sorts of systems of linear equations.\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Special-matrices-1\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Special matrices\",\n    \"category\": \"section\",\n    \"text\": \"Matrices with special symmetries and structures arise often in linear algebra and are frequently associated with various matrix factorizations. Julia features a rich collection of special matrix types, which allow for fast computation with specialized routines that are specially developed for particular matrix types.The following tables summarize the types of special matrices that have been implemented in Julia, as well as whether hooks to various optimized methods for them in LAPACK are available.Type Description\\nSymmetric Symmetric matrix\\nHermitian Hermitian matrix\\nUpperTriangular Upper triangular matrix\\nLowerTriangular Lower triangular matrix\\nTridiagonal Tridiagonal matrix\\nSymTridiagonal Symmetric tridiagonal matrix\\nBidiagonal Upper/lower bidiagonal matrix\\nDiagonal Diagonal matrix\\nUniformScaling Uniform scaling operator\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Elementary-operations-1\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Elementary operations\",\n    \"category\": \"section\",\n    \"text\": \"Matrix type + - * \\\\ Other functions with optimized methods\\nSymmetric    MV inv, sqrt, exp\\nHermitian    MV inv, sqrt, exp\\nUpperTriangular   MV MV inv, det\\nLowerTriangular   MV MV inv, det\\nSymTridiagonal M M MS MV eigmax, eigmin\\nTridiagonal M M MS MV \\nBidiagonal M M MS MV \\nDiagonal M M MV MV inv, det, logdet, /\\nUniformScaling M M MVS MVS /Legend:Key Description\\nM (matrix) An optimized method for matrix-matrix operations is available\\nV (vector) An optimized method for matrix-vector operations is available\\nS (scalar) An optimized method for matrix-scalar operations is available\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Matrix-factorizations-1\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Matrix factorizations\",\n    \"category\": \"section\",\n    \"text\": \"Matrix type LAPACK eigen eigvals eigvecs svd svdvals\\nSymmetric SY  ARI   \\nHermitian HE  ARI   \\nUpperTriangular TR A A A  \\nLowerTriangular TR A A A  \\nSymTridiagonal ST A ARI AV  \\nTridiagonal GT     \\nBidiagonal BD    A A\\nDiagonal DI  A   Legend:Key Description Example\\nA (all) An optimized method to find all the characteristic values and/or vectors is available e.g. eigvals(M)\\nR (range) An optimized method to find the ilth through the ihth characteristic values are available eigvals(M, il, ih)\\nI (interval) An optimized method to find the characteristic values in the interval [vl, vh] is available eigvals(M, vl, vh)\\nV (vectors) An optimized method to find the characteristic vectors corresponding to the characteristic values x=[x1, x2,...] is available eigvecs(M, x)\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#The-uniform-scaling-operator-1\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"The uniform scaling operator\",\n    \"category\": \"section\",\n    \"text\": \"A UniformScaling operator represents a scalar times the identity operator, \u03bb*I. The identity operator I is defined as a constant and is an instance of UniformScaling. The size of these operators are generic and match the other matrix in the binary operations +, -, * and \\\\. For A+I and A-I this means that A must be square. Multiplication with the identity operator I is a noop (except for checking that the scaling factor is one) and therefore almost without overhead.To see the UniformScaling operator in action:julia> U = UniformScaling(2);\\n\\njulia> a = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> a + U\\n2\u00d72 Array{Int64,2}:\\n 3  2\\n 3  6\\n\\njulia> a * U\\n2\u00d72 Array{Int64,2}:\\n 2  4\\n 6  8\\n\\njulia> [a U]\\n2\u00d74 Array{Int64,2}:\\n 1  2  2  0\\n 3  4  0  2\\n\\njulia> b = [1 2 3; 4 5 6]\\n2\u00d73 Array{Int64,2}:\\n 1  2  3\\n 4  5  6\\n\\njulia> b - U\\nERROR: DimensionMismatch(\\\"matrix is not square: dimensions are (2, 3)\\\")\\nStacktrace:\\n[...]\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#man-linalg-factorizations-1\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Matrix factorizations\",\n    \"category\": \"section\",\n    \"text\": \"Matrix factorizations (a.k.a. matrix decompositions) compute the factorization of a matrix into a product of matrices, and are one of the central concepts in linear algebra.The following table summarizes the types of matrix factorizations that have been implemented in Julia. Details of their associated methods can be found in the Standard Functions section of the Linear Algebra documentation.Type Description\\nCholesky Cholesky factorization\\nCholeskyPivoted Pivoted Cholesky factorization\\nLU LU factorization\\nLUTridiagonal LU factorization for Tridiagonal matrices\\nQR QR factorization\\nQRCompactWY Compact WY form of the QR factorization\\nQRPivoted Pivoted QR factorization\\nHessenberg Hessenberg decomposition\\nEigen Spectral decomposition\\nSVD Singular value decomposition\\nGeneralizedSVD Generalized SVD\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.:*-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.:*\",\n    \"category\": \"method\",\n    \"text\": \"*(A::AbstractMatrix, B::AbstractMatrix)\\n\\nMatrix multiplication.\\n\\nExamples\\n\\njulia> [1 1; 0 1] * [1 0; 1 1]\\n2\u00d72 Array{Int64,2}:\\n 2  1\\n 1  1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.:\\\\-Tuple{AbstractArray{T,2} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.:\\\\\",\n    \"category\": \"method\",\n    \"text\": \"\\\\(A, B)\\n\\nMatrix division using a polyalgorithm. For input matrices A and B, the result X is such that A*X == B when A is square. The solver that is used depends upon the structure of A.  If A is upper or lower triangular (or diagonal), no factorization of A is required and the system is solved with either forward or backward substitution. For non-triangular square matrices, an LU factorization is used.\\n\\nFor rectangular A the result is the minimum-norm least squares solution computed by a pivoted QR factorization of A and a rank estimate of A based on the R factor.\\n\\nWhen A is sparse, a similar polyalgorithm is used. For indefinite matrices, the LDLt factorization does not use pivoting during the numerical factorization and therefore the procedure can fail even for invertible matrices.\\n\\nExamples\\n\\njulia> A = [1 0; 1 -2]; B = [32; -4];\\n\\njulia> X = A \\\\ B\\n2-element Array{Float64,1}:\\n 32.0\\n 18.0\\n\\njulia> A * X == B\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.dot\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.dot\",\n    \"category\": \"function\",\n    \"text\": \"dot(x, y)\\nx \u22c5 y\\n\\nFor any iterable containers x and y (including arrays of any dimension) of numbers (or any element type for which dot is defined), compute the dot product (or inner product or scalar product), i.e. the sum of dot(x[i],y[i]), as if they were vectors.\\n\\nx \u22c5 y (where \u22c5 can be typed by tab-completing \\\\cdot in the REPL) is a synonym for dot(x, y).\\n\\nExamples\\n\\njulia> dot(1:5, 2:6)\\n70\\n\\njulia> x = fill(2., (5,5));\\n\\njulia> y = fill(3., (5,5));\\n\\njulia> dot(x, y)\\n150.0\\n\\n\\n\\n\\n\\ndot(x, y)\\nx \u22c5 y\\n\\nCompute the dot product between two vectors. For complex vectors, the first vector is conjugated. When the vectors have equal lengths, calling dot is semantically equivalent to sum(dot(vx,vy) for (vx,vy) in zip(x, y)).\\n\\nExamples\\n\\njulia> dot([1; 1], [2; 3])\\n5\\n\\njulia> dot([im; im], [1; 1])\\n0 - 2im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.cross\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.cross\",\n    \"category\": \"function\",\n    \"text\": \"cross(x, y)\\n\u00d7(x,y)\\n\\nCompute the cross product of two 3-vectors.\\n\\nExamples\\n\\njulia> a = [0;1;0]\\n3-element Array{Int64,1}:\\n 0\\n 1\\n 0\\n\\njulia> b = [0;0;1]\\n3-element Array{Int64,1}:\\n 0\\n 0\\n 1\\n\\njulia> cross(a,b)\\n3-element Array{Int64,1}:\\n 1\\n 0\\n 0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.factorize\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.factorize\",\n    \"category\": \"function\",\n    \"text\": \"factorize(A)\\n\\nCompute a convenient factorization of A, based upon the type of the input matrix. factorize checks A to see if it is symmetric/triangular/etc. if A is passed as a generic matrix. factorize checks every element of A to verify/rule out each property. It will short-circuit as soon as it can rule out symmetry/triangular structure. The return value can be reused for efficient solving of multiple systems. For example: A=factorize(A); x=A\\\\b; y=A\\\\C.\\n\\nProperties of A type of factorization\\nPositive-definite Cholesky (see cholesky)\\nDense Symmetric/Hermitian Bunch-Kaufman (see bunchkaufman)\\nSparse Symmetric/Hermitian LDLt (see ldlt)\\nTriangular Triangular\\nDiagonal Diagonal\\nBidiagonal Bidiagonal\\nTridiagonal LU (see lu)\\nSymmetric real tridiagonal LDLt (see ldlt)\\nGeneral square LU (see lu)\\nGeneral non-square QR (see qr)\\n\\nIf factorize is called on a Hermitian positive-definite matrix, for instance, then factorize will return a Cholesky factorization.\\n\\nExamples\\n\\njulia> A = Array(Bidiagonal(fill(1.0, (5, 5)), :U))\\n5\u00d75 Array{Float64,2}:\\n 1.0  1.0  0.0  0.0  0.0\\n 0.0  1.0  1.0  0.0  0.0\\n 0.0  0.0  1.0  1.0  0.0\\n 0.0  0.0  0.0  1.0  1.0\\n 0.0  0.0  0.0  0.0  1.0\\n\\njulia> factorize(A) # factorize will check to see that A is already factorized\\n5\u00d75 Bidiagonal{Float64,Array{Float64,1}}:\\n 1.0  1.0   \u22c5    \u22c5    \u22c5\\n  \u22c5   1.0  1.0   \u22c5    \u22c5\\n  \u22c5    \u22c5   1.0  1.0   \u22c5\\n  \u22c5    \u22c5    \u22c5   1.0  1.0\\n  \u22c5    \u22c5    \u22c5    \u22c5   1.0\\n\\nThis returns a 5\u00d75 Bidiagonal{Float64}, which can now be passed to other linear algebra functions (e.g. eigensolvers) which will use specialized methods for Bidiagonal types.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.Diagonal\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.Diagonal\",\n    \"category\": \"type\",\n    \"text\": \"Diagonal(A::AbstractMatrix)\\n\\nConstruct a matrix from the diagonal of A.\\n\\nExamples\\n\\njulia> A = [1 2 3; 4 5 6; 7 8 9]\\n3\u00d73 Array{Int64,2}:\\n 1  2  3\\n 4  5  6\\n 7  8  9\\n\\njulia> Diagonal(A)\\n3\u00d73 Diagonal{Int64,Array{Int64,1}}:\\n 1  \u22c5  \u22c5\\n \u22c5  5  \u22c5\\n \u22c5  \u22c5  9\\n\\n\\n\\n\\n\\nDiagonal(V::AbstractVector)\\n\\nConstruct a matrix with V as its diagonal.\\n\\nExamples\\n\\njulia> V = [1, 2]\\n2-element Array{Int64,1}:\\n 1\\n 2\\n\\njulia> Diagonal(V)\\n2\u00d72 Diagonal{Int64,Array{Int64,1}}:\\n 1  \u22c5\\n \u22c5  2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.Bidiagonal\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.Bidiagonal\",\n    \"category\": \"type\",\n    \"text\": \"Bidiagonal(dv::V, ev::V, uplo::Symbol) where V <: AbstractVector\\n\\nConstructs an upper (uplo=:U) or lower (uplo=:L) bidiagonal matrix using the given diagonal (dv) and off-diagonal (ev) vectors. The result is of type Bidiagonal and provides efficient specialized linear solvers, but may be converted into a regular matrix with convert(Array, _) (or Array(_) for short). The length of ev must be one less than the length of dv.\\n\\nExamples\\n\\njulia> dv = [1, 2, 3, 4]\\n4-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n 4\\n\\njulia> ev = [7, 8, 9]\\n3-element Array{Int64,1}:\\n 7\\n 8\\n 9\\n\\njulia> Bu = Bidiagonal(dv, ev, :U) # ev is on the first superdiagonal\\n4\u00d74 Bidiagonal{Int64,Array{Int64,1}}:\\n 1  7  \u22c5  \u22c5\\n \u22c5  2  8  \u22c5\\n \u22c5  \u22c5  3  9\\n \u22c5  \u22c5  \u22c5  4\\n\\njulia> Bl = Bidiagonal(dv, ev, :L) # ev is on the first subdiagonal\\n4\u00d74 Bidiagonal{Int64,Array{Int64,1}}:\\n 1  \u22c5  \u22c5  \u22c5\\n 7  2  \u22c5  \u22c5\\n \u22c5  8  3  \u22c5\\n \u22c5  \u22c5  9  4\\n\\n\\n\\n\\n\\nBidiagonal(A, uplo::Symbol)\\n\\nConstruct a Bidiagonal matrix from the main diagonal of A and its first super- (if uplo=:U) or sub-diagonal (if uplo=:L).\\n\\nExamples\\n\\njulia> A = [1 1 1 1; 2 2 2 2; 3 3 3 3; 4 4 4 4]\\n4\u00d74 Array{Int64,2}:\\n 1  1  1  1\\n 2  2  2  2\\n 3  3  3  3\\n 4  4  4  4\\n\\njulia> Bidiagonal(A, :U) # contains the main diagonal and first superdiagonal of A\\n4\u00d74 Bidiagonal{Int64,Array{Int64,1}}:\\n 1  1  \u22c5  \u22c5\\n \u22c5  2  2  \u22c5\\n \u22c5  \u22c5  3  3\\n \u22c5  \u22c5  \u22c5  4\\n\\njulia> Bidiagonal(A, :L) # contains the main diagonal and first subdiagonal of A\\n4\u00d74 Bidiagonal{Int64,Array{Int64,1}}:\\n 1  \u22c5  \u22c5  \u22c5\\n 2  2  \u22c5  \u22c5\\n \u22c5  3  3  \u22c5\\n \u22c5  \u22c5  4  4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.SymTridiagonal\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.SymTridiagonal\",\n    \"category\": \"type\",\n    \"text\": \"SymTridiagonal(dv::V, ev::V) where V <: AbstractVector\\n\\nConstruct a symmetric tridiagonal matrix from the diagonal (dv) and first sub/super-diagonal (ev), respectively. The result is of type SymTridiagonal and provides efficient specialized eigensolvers, but may be converted into a regular matrix with convert(Array, _) (or Array(_) for short).\\n\\nExamples\\n\\njulia> dv = [1, 2, 3, 4]\\n4-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n 4\\n\\njulia> ev = [7, 8, 9]\\n3-element Array{Int64,1}:\\n 7\\n 8\\n 9\\n\\njulia> SymTridiagonal(dv, ev)\\n4\u00d74 SymTridiagonal{Int64,Array{Int64,1}}:\\n 1  7  \u22c5  \u22c5\\n 7  2  8  \u22c5\\n \u22c5  8  3  9\\n \u22c5  \u22c5  9  4\\n\\n\\n\\n\\n\\nSymTridiagonal(A::AbstractMatrix)\\n\\nConstruct a symmetric tridiagonal matrix from the diagonal and first sub/super-diagonal, of the symmetric matrix A.\\n\\nExamples\\n\\njulia> A = [1 2 3; 2 4 5; 3 5 6]\\n3\u00d73 Array{Int64,2}:\\n 1  2  3\\n 2  4  5\\n 3  5  6\\n\\njulia> SymTridiagonal(A)\\n3\u00d73 SymTridiagonal{Int64,Array{Int64,1}}:\\n 1  2  \u22c5\\n 2  4  5\\n \u22c5  5  6\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.Tridiagonal\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.Tridiagonal\",\n    \"category\": \"type\",\n    \"text\": \"Tridiagonal(dl::V, d::V, du::V) where V <: AbstractVector\\n\\nConstruct a tridiagonal matrix from the first subdiagonal, diagonal, and first superdiagonal, respectively. The result is of type Tridiagonal and provides efficient specialized linear solvers, but may be converted into a regular matrix with convert(Array, _) (or Array(_) for short). The lengths of dl and du must be one less than the length of d.\\n\\nExamples\\n\\njulia> dl = [1, 2, 3];\\n\\njulia> du = [4, 5, 6];\\n\\njulia> d = [7, 8, 9, 0];\\n\\njulia> Tridiagonal(dl, d, du)\\n4\u00d74 Tridiagonal{Int64,Array{Int64,1}}:\\n 7  4  \u22c5  \u22c5\\n 1  8  5  \u22c5\\n \u22c5  2  9  6\\n \u22c5  \u22c5  3  0\\n\\n\\n\\n\\n\\nTridiagonal(A)\\n\\nConstruct a tridiagonal matrix from the first sub-diagonal, diagonal and first super-diagonal of the matrix A.\\n\\nExamples\\n\\njulia> A = [1 2 3 4; 1 2 3 4; 1 2 3 4; 1 2 3 4]\\n4\u00d74 Array{Int64,2}:\\n 1  2  3  4\\n 1  2  3  4\\n 1  2  3  4\\n 1  2  3  4\\n\\njulia> Tridiagonal(A)\\n4\u00d74 Tridiagonal{Int64,Array{Int64,1}}:\\n 1  2  \u22c5  \u22c5\\n 1  2  3  \u22c5\\n \u22c5  2  3  4\\n \u22c5  \u22c5  3  4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.Symmetric\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.Symmetric\",\n    \"category\": \"type\",\n    \"text\": \"Symmetric(A, uplo=:U)\\n\\nConstruct a Symmetric view of the upper (if uplo = :U) or lower (if uplo = :L) triangle of the matrix A.\\n\\nExamples\\n\\njulia> A = [1 0 2 0 3; 0 4 0 5 0; 6 0 7 0 8; 0 9 0 1 0; 2 0 3 0 4]\\n5\u00d75 Array{Int64,2}:\\n 1  0  2  0  3\\n 0  4  0  5  0\\n 6  0  7  0  8\\n 0  9  0  1  0\\n 2  0  3  0  4\\n\\njulia> Supper = Symmetric(A)\\n5\u00d75 Symmetric{Int64,Array{Int64,2}}:\\n 1  0  2  0  3\\n 0  4  0  5  0\\n 2  0  7  0  8\\n 0  5  0  1  0\\n 3  0  8  0  4\\n\\njulia> Slower = Symmetric(A, :L)\\n5\u00d75 Symmetric{Int64,Array{Int64,2}}:\\n 1  0  6  0  2\\n 0  4  0  9  0\\n 6  0  7  0  3\\n 0  9  0  1  0\\n 2  0  3  0  4\\n\\nNote that Supper will not be equal to Slower unless A is itself symmetric (e.g. if A == transpose(A)).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.Hermitian\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.Hermitian\",\n    \"category\": \"type\",\n    \"text\": \"Hermitian(A, uplo=:U)\\n\\nConstruct a Hermitian view of the upper (if uplo = :U) or lower (if uplo = :L) triangle of the matrix A.\\n\\nExamples\\n\\njulia> A = [1 0 2+2im 0 3-3im; 0 4 0 5 0; 6-6im 0 7 0 8+8im; 0 9 0 1 0; 2+2im 0 3-3im 0 4];\\n\\njulia> Hupper = Hermitian(A)\\n5\u00d75 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:\\n 1+0im  0+0im  2+2im  0+0im  3-3im\\n 0+0im  4+0im  0+0im  5+0im  0+0im\\n 2-2im  0+0im  7+0im  0+0im  8+8im\\n 0+0im  5+0im  0+0im  1+0im  0+0im\\n 3+3im  0+0im  8-8im  0+0im  4+0im\\n\\njulia> Hlower = Hermitian(A, :L)\\n5\u00d75 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:\\n 1+0im  0+0im  6+6im  0+0im  2-2im\\n 0+0im  4+0im  0+0im  9+0im  0+0im\\n 6-6im  0+0im  7+0im  0+0im  3+3im\\n 0+0im  9+0im  0+0im  1+0im  0+0im\\n 2+2im  0+0im  3-3im  0+0im  4+0im\\n\\nNote that Hupper will not be equal to Hlower unless A is itself Hermitian (e.g. if A == adjoint(A)).\\n\\nAll non-real parts of the diagonal will be ignored.\\n\\nHermitian(fill(complex(1,1), 1, 1)) == fill(1, 1, 1)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LowerTriangular\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LowerTriangular\",\n    \"category\": \"type\",\n    \"text\": \"LowerTriangular(A::AbstractMatrix)\\n\\nConstruct a LowerTriangular view of the the matrix A.\\n\\nExamples\\n\\njulia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]\\n3\u00d73 Array{Float64,2}:\\n 1.0  2.0  3.0\\n 4.0  5.0  6.0\\n 7.0  8.0  9.0\\n\\njulia> LowerTriangular(A)\\n3\u00d73 LowerTriangular{Float64,Array{Float64,2}}:\\n 1.0   \u22c5    \u22c5\\n 4.0  5.0   \u22c5\\n 7.0  8.0  9.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.UpperTriangular\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.UpperTriangular\",\n    \"category\": \"type\",\n    \"text\": \"UpperTriangular(A::AbstractMatrix)\\n\\nConstruct an UpperTriangular view of the the matrix A.\\n\\nExamples\\n\\njulia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]\\n3\u00d73 Array{Float64,2}:\\n 1.0  2.0  3.0\\n 4.0  5.0  6.0\\n 7.0  8.0  9.0\\n\\njulia> UpperTriangular(A)\\n3\u00d73 UpperTriangular{Float64,Array{Float64,2}}:\\n 1.0  2.0  3.0\\n  \u22c5   5.0  6.0\\n  \u22c5    \u22c5   9.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.UniformScaling\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.UniformScaling\",\n    \"category\": \"type\",\n    \"text\": \"UniformScaling{T<:Number}\\n\\nGenerically sized uniform scaling operator defined as a scalar times the identity operator, \u03bb*I. See also I.\\n\\nExamples\\n\\njulia> J = UniformScaling(2.)\\nUniformScaling{Float64}\\n2.0*I\\n\\njulia> A = [1. 2.; 3. 4.]\\n2\u00d72 Array{Float64,2}:\\n 1.0  2.0\\n 3.0  4.0\\n\\njulia> J*A\\n2\u00d72 Array{Float64,2}:\\n 2.0  4.0\\n 6.0  8.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.lu\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.lu\",\n    \"category\": \"function\",\n    \"text\": \"lu(A, pivot=Val(true); check = true) -> F::LU\\n\\nCompute the LU factorization of A.\\n\\nWhen check = true, an error is thrown if the decomposition fails. When check = false, responsibility for checking the decomposition\\'s validity (via issuccess) lies with the user.\\n\\nIn most cases, if A is a subtype S of AbstractMatrix{T} with an element type T supporting +, -, * and /, the return type is LU{T,S{T}}. If pivoting is chosen (default) the element type should also support abs and <.\\n\\nThe individual components of the factorization F can be accessed via getproperty:\\n\\nComponent Description\\nF.L L (lower triangular) part of LU\\nF.U U (upper triangular) part of LU\\nF.p (right) permutation Vector\\nF.P (right) permutation Matrix\\n\\nIterating the factorization produces the components F.L, F.U, and F.p.\\n\\nThe relationship between F and A is\\n\\nF.L*F.U == A[F.p, :]\\n\\nF further supports the following functions:\\n\\nSupported function LU LU{T,Tridiagonal{T}}\\n/ \u2713 \\n\\\\ \u2713 \u2713\\ninv \u2713 \u2713\\ndet \u2713 \u2713\\nlogdet \u2713 \u2713\\nlogabsdet \u2713 \u2713\\nsize \u2713 \u2713\\n\\nExamples\\n\\njulia> A = [4 3; 6 3]\\n2\u00d72 Array{Int64,2}:\\n 4  3\\n 6  3\\n\\njulia> F = lu(A)\\nLU{Float64,Array{Float64,2}}\\nL factor:\\n2\u00d72 Array{Float64,2}:\\n 1.0  0.0\\n 1.5  1.0\\nU factor:\\n2\u00d72 Array{Float64,2}:\\n 4.0   3.0\\n 0.0  -1.5\\n\\njulia> F.L * F.U == A[F.p, :]\\ntrue\\n\\njulia> l, u, p = lu(A); # destructuring via iteration\\n\\njulia> l == F.L && u == F.U && p == F.p\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.lu!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.lu!\",\n    \"category\": \"function\",\n    \"text\": \"lu!(A, pivot=Val(true); check = true) -> LU\\n\\nlu! is the same as lu, but saves space by overwriting the input A, instead of creating a copy. An InexactError exception is thrown if the factorization produces a number not representable by the element type of A, e.g. for integer types.\\n\\nExamples\\n\\njulia> A = [4. 3.; 6. 3.]\\n2\u00d72 Array{Float64,2}:\\n 4.0  3.0\\n 6.0  3.0\\n\\njulia> F = lu!(A)\\nLU{Float64,Array{Float64,2}}\\nL factor:\\n2\u00d72 Array{Float64,2}:\\n 1.0       0.0\\n 0.666667  1.0\\nU factor:\\n2\u00d72 Array{Float64,2}:\\n 6.0  3.0\\n 0.0  1.0\\n\\njulia> iA = [4 3; 6 3]\\n2\u00d72 Array{Int64,2}:\\n 4  3\\n 6  3\\n\\njulia> lu!(iA)\\nERROR: InexactError: Int64(Int64, 0.6666666666666666)\\nStacktrace:\\n[...]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.cholesky\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.cholesky\",\n    \"category\": \"function\",\n    \"text\": \"cholesky(A, Val(false); check = true) -> Cholesky\\n\\nCompute the Cholesky factorization of a dense symmetric positive definite matrix A and return a Cholesky factorization. The matrix A can either be a Symmetric or Hermitian StridedMatrix or a perfectly symmetric or Hermitian StridedMatrix. The triangular Cholesky factor can be obtained from the factorization F with: F.L and F.U. The following functions are available for Cholesky objects: size, \\\\, inv, det, logdet and isposdef.\\n\\nWhen check = true, an error is thrown if the decomposition fails. When check = false, responsibility for checking the decomposition\\'s validity (via issuccess) lies with the user.\\n\\nExamples\\n\\njulia> A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]\\n3\u00d73 Array{Float64,2}:\\n   4.0   12.0  -16.0\\n  12.0   37.0  -43.0\\n -16.0  -43.0   98.0\\n\\njulia> C = cholesky(A)\\nCholesky{Float64,Array{Float64,2}}\\nU factor:\\n3\u00d73 UpperTriangular{Float64,Array{Float64,2}}:\\n 2.0  6.0  -8.0\\n  \u22c5   1.0   5.0\\n  \u22c5    \u22c5    3.0\\n\\njulia> C.U\\n3\u00d73 UpperTriangular{Float64,Array{Float64,2}}:\\n 2.0  6.0  -8.0\\n  \u22c5   1.0   5.0\\n  \u22c5    \u22c5    3.0\\n\\njulia> C.L\\n3\u00d73 LowerTriangular{Float64,Array{Float64,2}}:\\n  2.0   \u22c5    \u22c5\\n  6.0  1.0   \u22c5\\n -8.0  5.0  3.0\\n\\njulia> C.L * C.U == A\\ntrue\\n\\n\\n\\n\\n\\ncholesky(A, Val(true); tol = 0.0, check = true) -> CholeskyPivoted\\n\\nCompute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix A and return a CholeskyPivoted factorization. The matrix A can either be a Symmetric or Hermitian StridedMatrix or a perfectly symmetric or Hermitian StridedMatrix. The triangular Cholesky factor can be obtained from the factorization F with: F.L and F.U. The following functions are available for PivotedCholesky objects: size, \\\\, inv, det, and rank. The argument tol determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.\\n\\nWhen check = true, an error is thrown if the decomposition fails. When check = false, responsibility for checking the decomposition\\'s validity (via issuccess) lies with the user.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.cholesky!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.cholesky!\",\n    \"category\": \"function\",\n    \"text\": \"cholesky!(A, Val(false); check = true) -> Cholesky\\n\\nThe same as cholesky, but saves space by overwriting the input A, instead of creating a copy. An InexactError exception is thrown if the factorization produces a number not representable by the element type of A, e.g. for integer types.\\n\\nExamples\\n\\njulia> A = [1 2; 2 50]\\n2\u00d72 Array{Int64,2}:\\n 1   2\\n 2  50\\n\\njulia> cholesky!(A)\\nERROR: InexactError: Int64(Int64, 6.782329983125268)\\nStacktrace:\\n[...]\\n\\n\\n\\n\\n\\ncholesky!(A, Val(true); tol = 0.0, check = true) -> CholeskyPivoted\\n\\nThe same as cholesky, but saves space by overwriting the input A, instead of creating a copy. An InexactError exception is thrown if the factorization produces a number not representable by the element type of A, e.g. for integer types.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.lowrankupdate\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.lowrankupdate\",\n    \"category\": \"function\",\n    \"text\": \"lowrankupdate(C::Cholesky, v::StridedVector) -> CC::Cholesky\\n\\nUpdate a Cholesky factorization C with the vector v. If A = C.U\\'C.U then CC = cholesky(C.U\\'C.U + v*v\\') but the computation of CC only uses O(n^2) operations.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.lowrankdowndate\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.lowrankdowndate\",\n    \"category\": \"function\",\n    \"text\": \"lowrankdowndate(C::Cholesky, v::StridedVector) -> CC::Cholesky\\n\\nDowndate a Cholesky factorization C with the vector v. If A = C.U\\'C.U then CC = cholesky(C.U\\'C.U - v*v\\') but the computation of CC only uses O(n^2) operations.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.lowrankupdate!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.lowrankupdate!\",\n    \"category\": \"function\",\n    \"text\": \"lowrankupdate!(C::Cholesky, v::StridedVector) -> CC::Cholesky\\n\\nUpdate a Cholesky factorization C with the vector v. If A = C.U\\'C.U then CC = cholesky(C.U\\'C.U + v*v\\') but the computation of CC only uses O(n^2) operations. The input factorization C is updated in place such that on exit C == CC. The vector v is destroyed during the computation.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.lowrankdowndate!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.lowrankdowndate!\",\n    \"category\": \"function\",\n    \"text\": \"lowrankdowndate!(C::Cholesky, v::StridedVector) -> CC::Cholesky\\n\\nDowndate a Cholesky factorization C with the vector v. If A = C.U\\'C.U then CC = cholesky(C.U\\'C.U - v*v\\') but the computation of CC only uses O(n^2) operations. The input factorization C is updated in place such that on exit C == CC. The vector v is destroyed during the computation.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.ldlt\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.ldlt\",\n    \"category\": \"function\",\n    \"text\": \"ldlt(S::SymTridiagonal) -> LDLt\\n\\nCompute an LDLt factorization of the real symmetric tridiagonal matrix S such that S = L*Diagonal(d)*L\\' where L is a unit lower triangular matrix and d is a vector. The main use of an LDLt factorization F = ldlt(S) is to solve the linear system of equations Sx = b with F\\\\b.\\n\\nExamples\\n\\njulia> S = SymTridiagonal([3., 4., 5.], [1., 2.])\\n3\u00d73 SymTridiagonal{Float64,Array{Float64,1}}:\\n 3.0  1.0   \u22c5\\n 1.0  4.0  2.0\\n  \u22c5   2.0  5.0\\n\\njulia> ldltS = ldlt(S);\\n\\njulia> b = [6., 7., 8.];\\n\\njulia> ldltS \\\\ b\\n3-element Array{Float64,1}:\\n 1.7906976744186047\\n 0.627906976744186\\n 1.3488372093023255\\n\\njulia> S \\\\ b\\n3-element Array{Float64,1}:\\n 1.7906976744186047\\n 0.627906976744186\\n 1.3488372093023255\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.ldlt!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.ldlt!\",\n    \"category\": \"function\",\n    \"text\": \"ldlt!(S::SymTridiagonal) -> LDLt\\n\\nSame as ldlt, but saves space by overwriting the input S, instead of creating a copy.\\n\\nExamples\\n\\njulia> S = SymTridiagonal([3., 4., 5.], [1., 2.])\\n3\u00d73 SymTridiagonal{Float64,Array{Float64,1}}:\\n 3.0  1.0   \u22c5\\n 1.0  4.0  2.0\\n  \u22c5   2.0  5.0\\n\\njulia> ldltS = ldlt!(S);\\n\\njulia> ldltS === S\\nfalse\\n\\njulia> S\\n3\u00d73 SymTridiagonal{Float64,Array{Float64,1}}:\\n 3.0       0.333333   \u22c5\\n 0.333333  3.66667   0.545455\\n  \u22c5        0.545455  3.90909\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.qr\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.qr\",\n    \"category\": \"function\",\n    \"text\": \"qr(A, pivot=Val(false)) -> F\\n\\nCompute the QR factorization of the matrix A: an orthogonal (or unitary if A is complex-valued) matrix Q, and an upper triangular matrix R such that\\n\\nA = Q R\\n\\nThe returned object F stores the factorization in a packed format:\\n\\nif pivot == Val(true) then F is a QRPivoted object,\\notherwise if the element type of A is a BLAS type (Float32, Float64, ComplexF32 or ComplexF64), then F is a QRCompactWY object,\\notherwise F is a QR object.\\n\\nThe individual components of the decomposition F can be retrieved via property accessors:\\n\\nF.Q: the orthogonal/unitary matrix Q\\nF.R: the upper triangular matrix R\\nF.p: the permutation vector of the pivot (QRPivoted only)\\nF.P: the permutation matrix of the pivot (QRPivoted only)\\n\\nIterating the decomposition produces the components Q, R, and if extant p.\\n\\nThe following functions are available for the QR objects: inv, size, and \\\\. When A is rectangular, \\\\ will return a least squares solution and if the solution is not unique, the one with smallest norm is returned.\\n\\nMultiplication with respect to either full/square or non-full/square Q is allowed, i.e. both F.Q*F.R and F.Q*A are supported. A Q matrix can be converted into a regular matrix with Matrix.  This operation returns the \\\"thin\\\" Q factor, i.e., if A is m\u00d7n with m>=n, then Matrix(F.Q) yields an m\u00d7n matrix with orthonormal columns.  To retrieve the \\\"full\\\" Q factor, an m\u00d7m orthogonal matrix, use F.Q*Matrix(I,m,m).  If m<=n, then Matrix(F.Q) yields an m\u00d7m orthogonal matrix.\\n\\nExamples\\n\\njulia> A = [3.0 -6.0; 4.0 -8.0; 0.0 1.0]\\n3\u00d72 Array{Float64,2}:\\n 3.0  -6.0\\n 4.0  -8.0\\n 0.0   1.0\\n\\njulia> F = qr(A)\\nLinearAlgebra.QRCompactWY{Float64,Array{Float64,2}}\\nQ factor:\\n3\u00d73 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:\\n -0.6   0.0   0.8\\n -0.8   0.0  -0.6\\n  0.0  -1.0   0.0\\nR factor:\\n2\u00d72 Array{Float64,2}:\\n -5.0  10.0\\n  0.0  -1.0\\n\\njulia> F.Q * F.R == A\\ntrue\\n\\nnote: Note\\nqr returns multiple types because LAPACK uses several representations that minimize the memory storage requirements of products of Householder elementary reflectors, so that the Q and R matrices can be stored compactly rather as two separate dense matrices.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.qr!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.qr!\",\n    \"category\": \"function\",\n    \"text\": \"qr!(A, pivot=Val(false))\\n\\nqr! is the same as qr when A is a subtype of StridedMatrix, but saves space by overwriting the input A, instead of creating a copy. An InexactError exception is thrown if the factorization produces a number not representable by the element type of A, e.g. for integer types.\\n\\nExamples\\n\\njulia> a = [1. 2.; 3. 4.]\\n2\u00d72 Array{Float64,2}:\\n 1.0  2.0\\n 3.0  4.0\\n\\njulia> qr!(a)\\nLinearAlgebra.QRCompactWY{Float64,Array{Float64,2}}\\nQ factor:\\n2\u00d72 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:\\n -0.316228  -0.948683\\n -0.948683   0.316228\\nR factor:\\n2\u00d72 Array{Float64,2}:\\n -3.16228  -4.42719\\n  0.0      -0.632456\\n\\njulia> a = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> qr!(a)\\nERROR: InexactError: Int64(Int64, -3.1622776601683795)\\nStacktrace:\\n[...]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.QR\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.QR\",\n    \"category\": \"type\",\n    \"text\": \"QR <: Factorization\\n\\nA QR matrix factorization stored in a packed format, typically obtained from qr. If A is an m\u00d7n matrix, then\\n\\nA = Q R\\n\\nwhere Q is an orthogonal/unitary matrix and R is upper triangular. The matrix Q is stored as a sequence of Householder reflectors v_i and coefficients tau_i where:\\n\\nQ = prod_i=1^min(mn) (I - tau_i v_i v_i^T)\\n\\nIterating the decomposition produces the components Q and R.\\n\\nThe object has two fields:\\n\\nfactors is an m\u00d7n matrix.\\nThe upper triangular part contains the elements of R, that is R = triu(F.factors) for a QR object F.\\nThe subdiagonal part contains the reflectors v_i stored in a packed format where v_i is the ith column of the matrix V = I + tril(F.factors, -1).\\n\u03c4 is a vector  of length min(m,n) containing the coefficients au_i.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.QRCompactWY\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.QRCompactWY\",\n    \"category\": \"type\",\n    \"text\": \"QRCompactWY <: Factorization\\n\\nA QR matrix factorization stored in a compact blocked format, typically obtained from qr. If A is an m\u00d7n matrix, then\\n\\nA = Q R\\n\\nwhere Q is an orthogonal/unitary matrix and R is upper triangular. It is similar to the QR format except that the orthogonal/unitary matrix Q is stored in Compact WY format [Schreiber1989], as a lower trapezoidal matrix V and an upper triangular matrix T where\\n\\nQ = prod_i=1^min(mn) (I - tau_i v_i v_i^T) = I - V T V^T\\n\\nsuch that v_i is the ith column of V, and au_i is the ith diagonal element of T.\\n\\nIterating the decomposition produces the components Q and R.\\n\\nThe object has two fields:\\n\\nfactors, as in the QR type, is an m\u00d7n matrix.\\nThe upper triangular part contains the elements of R, that is R = triu(F.factors) for a QR object F.\\nThe subdiagonal part contains the reflectors v_i stored in a packed format such that V = I + tril(F.factors, -1).\\nT is a square matrix with min(m,n) columns, whose upper triangular part gives the matrix T above (the subdiagonal elements are ignored).\\n\\nnote: Note\\nThis format should not to be confused with the older WY representation [Bischof1987].\\n\\n[Bischof1987]: C Bischof and C Van Loan, \\\"The WY representation for products of Householder matrices\\\", SIAM J Sci Stat Comput 8 (1987), s2-s13. doi:10.1137/0908009\\n\\n[Schreiber1989]: R Schreiber and C Van Loan, \\\"A storage-efficient WY representation for products of Householder transformations\\\", SIAM J Sci Stat Comput 10 (1989), 53-57. doi:10.1137/0910005\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.QRPivoted\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.QRPivoted\",\n    \"category\": \"type\",\n    \"text\": \"QRPivoted <: Factorization\\n\\nA QR matrix factorization with column pivoting in a packed format, typically obtained from qr. If A is an m\u00d7n matrix, then\\n\\nA P = Q R\\n\\nwhere P is a permutation matrix, Q is an orthogonal/unitary matrix and R is upper triangular. The matrix Q is stored as a sequence of Householder reflectors:\\n\\nQ = prod_i=1^min(mn) (I - tau_i v_i v_i^T)\\n\\nIterating the decomposition produces the components Q, R, and p.\\n\\nThe object has three fields:\\n\\nfactors is an m\u00d7n matrix.\\nThe upper triangular part contains the elements of R, that is R = triu(F.factors) for a QR object F.\\nThe subdiagonal part contains the reflectors v_i stored in a packed format where v_i is the ith column of the matrix V = I + tril(F.factors, -1).\\n\u03c4 is a vector of length min(m,n) containing the coefficients au_i.\\njpvt is an integer vector of length n corresponding to the permutation P.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.lq!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.lq!\",\n    \"category\": \"function\",\n    \"text\": \"lq!(A) -> LQ\\n\\nCompute the LQ factorization of A, using the input matrix as a workspace. See also lq.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.lq\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.lq\",\n    \"category\": \"function\",\n    \"text\": \"lq(A) -> S::LQ\\n\\nCompute the LQ decomposition of A. The decomposition\\'s lower triangular component can be obtained from the LQ object S via S.L, and the orthogonal/unitary component via S.Q, such that A \u2248 S.L*S.Q.\\n\\nIterating the decomposition produces the components S.L and S.Q.\\n\\nThe LQ decomposition is the QR decomposition of transpose(A).\\n\\nExamples\\n\\njulia> A = [5. 7.; -2. -4.]\\n2\u00d72 Array{Float64,2}:\\n  5.0   7.0\\n -2.0  -4.0\\n\\njulia> S = lq(A)\\nLQ{Float64,Array{Float64,2}} with factors L and Q:\\n[-8.60233 0.0; 4.41741 -0.697486]\\n[-0.581238 -0.813733; -0.813733 0.581238]\\n\\njulia> S.L * S.Q\\n2\u00d72 Array{Float64,2}:\\n  5.0   7.0\\n -2.0  -4.0\\n\\njulia> l, q = S; # destructuring via iteration\\n\\njulia> l == S.L &&  q == S.Q\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.bunchkaufman\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.bunchkaufman\",\n    \"category\": \"function\",\n    \"text\": \"bunchkaufman(A, rook::Bool=false; check = true) -> S::BunchKaufman\\n\\nCompute the Bunch-Kaufman [Bunch1977] factorization of a Symmetric or Hermitian matrix A as P*U*D*U*P or P*L*D*L*P, depending on which triangle is stored in A, and return a BunchKaufman object. Note that if A is complex symmetric then U\\' and L\\' denote the unconjugated transposes, i.e. transpose(U) and transpose(L).\\n\\nIterating the decomposition produces the components S.D, S.U or S.L as appropriate given S.uplo, and S.p.\\n\\nIf rook is true, rook pivoting is used. If rook is false, rook pivoting is not used.\\n\\nWhen check = true, an error is thrown if the decomposition fails. When check = false, responsibility for checking the decomposition\\'s validity (via issuccess) lies with the user.\\n\\nThe following functions are available for BunchKaufman objects: size, \\\\, inv, issymmetric, ishermitian, getindex.\\n\\n[Bunch1977]: J R Bunch and L Kaufman, Some stable methods for calculating inertia\\n\\nand solving symmetric linear systems, Mathematics of Computation 31:137 (1977), 163-179. url.\\n\\nExamples\\n\\njulia> A = [1 2; 2 3]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 2  3\\n\\njulia> S = bunchkaufman(A)\\nBunchKaufman{Float64,Array{Float64,2}}\\nD factor:\\n2\u00d72 Tridiagonal{Float64,Array{Float64,1}}:\\n -0.333333  0.0\\n  0.0       3.0\\nU factor:\\n2\u00d72 UnitUpperTriangular{Float64,Array{Float64,2}}:\\n 1.0  0.666667\\n  \u22c5   1.0\\npermutation:\\n2-element Array{Int64,1}:\\n 1\\n 2\\n\\njulia> d, u, p = S; # destructuring via iteration\\n\\njulia> d == S.D && u == S.U && p == S.p\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.bunchkaufman!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.bunchkaufman!\",\n    \"category\": \"function\",\n    \"text\": \"bunchkaufman!(A, rook::Bool=false; check = true) -> BunchKaufman\\n\\nbunchkaufman! is the same as bunchkaufman, but saves space by overwriting the input A, instead of creating a copy.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.eigvals\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.eigvals\",\n    \"category\": \"function\",\n    \"text\": \"eigvals(A; permute::Bool=true, scale::Bool=true) -> values\\n\\nReturn the eigenvalues of A.\\n\\nFor general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvalue calculation. The option permute=true permutes the matrix to become closer to upper triangular, and scale=true scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is true for both options.\\n\\nExamples\\n\\njulia> diag_matrix = [1 0; 0 4]\\n2\u00d72 Array{Int64,2}:\\n 1  0\\n 0  4\\n\\njulia> eigvals(diag_matrix)\\n2-element Array{Float64,1}:\\n 1.0\\n 4.0\\n\\n\\n\\n\\n\\nFor a scalar input, eigvals will return a scalar.\\n\\nExample\\n\\njulia> eigvals(-2)\\n-2\\n\\n\\n\\n\\n\\neigvals(A, B) -> values\\n\\nComputes the generalized eigenvalues of A and B.\\n\\nExamples\\n\\njulia> A = [1 0; 0 -1]\\n2\u00d72 Array{Int64,2}:\\n 1   0\\n 0  -1\\n\\njulia> B = [0 1; 1 0]\\n2\u00d72 Array{Int64,2}:\\n 0  1\\n 1  0\\n\\njulia> eigvals(A,B)\\n2-element Array{Complex{Float64},1}:\\n 0.0 + 1.0im\\n 0.0 - 1.0im\\n\\n\\n\\n\\n\\neigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> values\\n\\nReturns the eigenvalues of A. It is possible to calculate only a subset of the eigenvalues by specifying a UnitRange irange covering indices of the sorted eigenvalues, e.g. the 2nd to 8th eigenvalues.\\n\\njulia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])\\n3\u00d73 SymTridiagonal{Float64,Array{Float64,1}}:\\n 1.0  2.0   \u22c5\\n 2.0  2.0  3.0\\n  \u22c5   3.0  1.0\\n\\njulia> eigvals(A, 2:2)\\n1-element Array{Float64,1}:\\n 0.9999999999999996\\n\\njulia> eigvals(A)\\n3-element Array{Float64,1}:\\n -2.1400549446402604\\n  1.0000000000000002\\n  5.140054944640259\\n\\n\\n\\n\\n\\neigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> values\\n\\nReturns the eigenvalues of A. It is possible to calculate only a subset of the eigenvalues by specifying a pair vl and vu for the lower and upper boundaries of the eigenvalues.\\n\\njulia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])\\n3\u00d73 SymTridiagonal{Float64,Array{Float64,1}}:\\n 1.0  2.0   \u22c5\\n 2.0  2.0  3.0\\n  \u22c5   3.0  1.0\\n\\njulia> eigvals(A, -1, 2)\\n1-element Array{Float64,1}:\\n 1.0000000000000009\\n\\njulia> eigvals(A)\\n3-element Array{Float64,1}:\\n -2.1400549446402604\\n  1.0000000000000002\\n  5.140054944640259\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.eigvals!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.eigvals!\",\n    \"category\": \"function\",\n    \"text\": \"eigvals!(A; permute::Bool=true, scale::Bool=true) -> values\\n\\nSame as eigvals, but saves space by overwriting the input A, instead of creating a copy. The option permute=true permutes the matrix to become closer to upper triangular, and scale=true scales the matrix by its diagonal elements to make rows and columns more equal in norm.\\n\\nnote: Note\\nThe input matrix A will not contain its eigenvalues after eigvals! is called on it - A is used as a workspace.\\n\\nExamples\\n\\njulia> A = [1. 2.; 3. 4.]\\n2\u00d72 Array{Float64,2}:\\n 1.0  2.0\\n 3.0  4.0\\n\\njulia> eigvals!(A)\\n2-element Array{Float64,1}:\\n -0.3722813232690143\\n  5.372281323269014\\n\\njulia> A\\n2\u00d72 Array{Float64,2}:\\n -0.372281  -1.0\\n  0.0        5.37228\\n\\n\\n\\n\\n\\neigvals!(A, B) -> values\\n\\nSame as eigvals, but saves space by overwriting the input A (and B), instead of creating copies.\\n\\nnote: Note\\nThe input matrices A and B will not contain their eigenvalues after eigvals! is called. They are used as workspaces.\\n\\nExamples\\n\\njulia> A = [1. 0.; 0. -1.]\\n2\u00d72 Array{Float64,2}:\\n 1.0   0.0\\n 0.0  -1.0\\n\\njulia> B = [0. 1.; 1. 0.]\\n2\u00d72 Array{Float64,2}:\\n 0.0  1.0\\n 1.0  0.0\\n\\njulia> eigvals!(A, B)\\n2-element Array{Complex{Float64},1}:\\n 0.0 + 1.0im\\n 0.0 - 1.0im\\n\\njulia> A\\n2\u00d72 Array{Float64,2}:\\n -0.0  -1.0\\n  1.0  -0.0\\n\\njulia> B\\n2\u00d72 Array{Float64,2}:\\n 1.0  0.0\\n 0.0  1.0\\n\\n\\n\\n\\n\\neigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> values\\n\\nSame as eigvals, but saves space by overwriting the input A, instead of creating a copy. irange is a range of eigenvalue indices to search for - for instance, the 2nd to 8th eigenvalues.\\n\\n\\n\\n\\n\\neigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> values\\n\\nSame as eigvals, but saves space by overwriting the input A, instead of creating a copy. vl is the lower bound of the interval to search for eigenvalues, and vu is the upper bound.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.eigmax\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.eigmax\",\n    \"category\": \"function\",\n    \"text\": \"eigmax(A; permute::Bool=true, scale::Bool=true)\\n\\nReturn the largest eigenvalue of A. The option permute=true permutes the matrix to become closer to upper triangular, and scale=true scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of A are complex, this method will fail, since complex numbers cannot be sorted.\\n\\nExamples\\n\\njulia> A = [0 im; -im 0]\\n2\u00d72 Array{Complex{Int64},2}:\\n 0+0im  0+1im\\n 0-1im  0+0im\\n\\njulia> eigmax(A)\\n1.0\\n\\njulia> A = [0 im; -1 0]\\n2\u00d72 Array{Complex{Int64},2}:\\n  0+0im  0+1im\\n -1+0im  0+0im\\n\\njulia> eigmax(A)\\nERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:\\n`A` cannot have complex eigenvalues.\\nStacktrace:\\n[...]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.eigmin\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.eigmin\",\n    \"category\": \"function\",\n    \"text\": \"eigmin(A; permute::Bool=true, scale::Bool=true)\\n\\nReturn the smallest eigenvalue of A. The option permute=true permutes the matrix to become closer to upper triangular, and scale=true scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of A are complex, this method will fail, since complex numbers cannot be sorted.\\n\\nExamples\\n\\njulia> A = [0 im; -im 0]\\n2\u00d72 Array{Complex{Int64},2}:\\n 0+0im  0+1im\\n 0-1im  0+0im\\n\\njulia> eigmin(A)\\n-1.0\\n\\njulia> A = [0 im; -1 0]\\n2\u00d72 Array{Complex{Int64},2}:\\n  0+0im  0+1im\\n -1+0im  0+0im\\n\\njulia> eigmin(A)\\nERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:\\n`A` cannot have complex eigenvalues.\\nStacktrace:\\n[...]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.eigvecs\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.eigvecs\",\n    \"category\": \"function\",\n    \"text\": \"eigvecs(A::SymTridiagonal[, eigvals]) -> Matrix\\n\\nReturn a matrix M whose columns are the eigenvectors of A. (The kth eigenvector can be obtained from the slice M[:, k].)\\n\\nIf the optional vector of eigenvalues eigvals is specified, eigvecs returns the specific corresponding eigenvectors.\\n\\nExamples\\n\\njulia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])\\n3\u00d73 SymTridiagonal{Float64,Array{Float64,1}}:\\n 1.0  2.0   \u22c5\\n 2.0  2.0  3.0\\n  \u22c5   3.0  1.0\\n\\njulia> eigvals(A)\\n3-element Array{Float64,1}:\\n -2.1400549446402604\\n  1.0000000000000002\\n  5.140054944640259\\n\\njulia> eigvecs(A)\\n3\u00d73 Array{Float64,2}:\\n  0.418304  -0.83205      0.364299\\n -0.656749  -7.39009e-16  0.754109\\n  0.627457   0.5547       0.546448\\n\\njulia> eigvecs(A, [1.])\\n3\u00d71 Array{Float64,2}:\\n  0.8320502943378438\\n  4.263514128092366e-17\\n -0.5547001962252291\\n\\n\\n\\n\\n\\neigvecs(A; permute::Bool=true, scale::Bool=true) -> Matrix\\n\\nReturn a matrix M whose columns are the eigenvectors of A. (The kth eigenvector can be obtained from the slice M[:, k].) The permute and scale keywords are the same as for eigen.\\n\\nExamples\\n\\njulia> eigvecs([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])\\n3\u00d73 Array{Float64,2}:\\n 1.0  0.0  0.0\\n 0.0  1.0  0.0\\n 0.0  0.0  1.0\\n\\n\\n\\n\\n\\neigvecs(A, B) -> Matrix\\n\\nReturn a matrix M whose columns are the generalized eigenvectors of A and B. (The kth eigenvector can be obtained from the slice M[:, k].)\\n\\nExamples\\n\\njulia> A = [1 0; 0 -1]\\n2\u00d72 Array{Int64,2}:\\n 1   0\\n 0  -1\\n\\njulia> B = [0 1; 1 0]\\n2\u00d72 Array{Int64,2}:\\n 0  1\\n 1  0\\n\\njulia> eigvecs(A, B)\\n2\u00d72 Array{Complex{Float64},2}:\\n  0.0-1.0im   0.0+1.0im\\n -1.0-0.0im  -1.0+0.0im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.eigen\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.eigen\",\n    \"category\": \"function\",\n    \"text\": \"eigen(A; permute::Bool=true, scale::Bool=true) -> Eigen\\n\\nComputes the eigenvalue decomposition of A, returning an Eigen factorization object F which contains the eigenvalues in F.values and the eigenvectors in the columns of the matrix F.vectors. (The kth eigenvector can be obtained from the slice F.vectors[:, k].)\\n\\nIterating the decomposition produces the components F.values and F.vectors.\\n\\nThe following functions are available for Eigen objects: inv, det, and isposdef.\\n\\nFor general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option permute=true permutes the matrix to become closer to upper triangular, and scale=true scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is true for both options.\\n\\nExamples\\n\\njulia> F = eigen([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])\\nEigen{Float64,Float64,Array{Float64,2},Array{Float64,1}}\\neigenvalues:\\n3-element Array{Float64,1}:\\n  1.0\\n  3.0\\n 18.0\\neigenvectors:\\n3\u00d73 Array{Float64,2}:\\n 1.0  0.0  0.0\\n 0.0  1.0  0.0\\n 0.0  0.0  1.0\\n\\njulia> F.values\\n3-element Array{Float64,1}:\\n  1.0\\n  3.0\\n 18.0\\n\\njulia> F.vectors\\n3\u00d73 Array{Float64,2}:\\n 1.0  0.0  0.0\\n 0.0  1.0  0.0\\n 0.0  0.0  1.0\\n\\njulia> vals, vecs = F; # destructuring via iteration\\n\\njulia> vals == F.values && vecs == F.vectors\\ntrue\\n\\n\\n\\n\\n\\neigen(A, B) -> GeneralizedEigen\\n\\nComputes the generalized eigenvalue decomposition of A and B, returning a GeneralizedEigen factorization object F which contains the generalized eigenvalues in F.values and the generalized eigenvectors in the columns of the matrix F.vectors. (The kth generalized eigenvector can be obtained from the slice F.vectors[:, k].)\\n\\nIterating the decomposition produces the components F.values and F.vectors.\\n\\nExamples\\n\\njulia> A = [1 0; 0 -1]\\n2\u00d72 Array{Int64,2}:\\n 1   0\\n 0  -1\\n\\njulia> B = [0 1; 1 0]\\n2\u00d72 Array{Int64,2}:\\n 0  1\\n 1  0\\n\\njulia> F = eigen(A, B);\\n\\njulia> F.values\\n2-element Array{Complex{Float64},1}:\\n 0.0 + 1.0im\\n 0.0 - 1.0im\\n\\njulia> F.vectors\\n2\u00d72 Array{Complex{Float64},2}:\\n  0.0-1.0im   0.0+1.0im\\n -1.0-0.0im  -1.0+0.0im\\n\\njulia> vals, vecs = F; # destructuring via iteration\\n\\njulia> vals == F.values && vecs == F.vectors\\ntrue\\n\\n\\n\\n\\n\\neigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> Eigen\\n\\nComputes the eigenvalue decomposition of A, returning an Eigen factorization object F which contains the eigenvalues in F.values and the eigenvectors in the columns of the matrix F.vectors. (The kth eigenvector can be obtained from the slice F.vectors[:, k].)\\n\\nIterating the decomposition produces the components F.values and F.vectors.\\n\\nThe following functions are available for Eigen objects: inv, det, and isposdef.\\n\\nThe UnitRange irange specifies indices of the sorted eigenvalues to search for.\\n\\nnote: Note\\nIf irange is not 1:n, where n is the dimension of A, then the returned factorization will be a truncated factorization.\\n\\n\\n\\n\\n\\neigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> Eigen\\n\\nComputes the eigenvalue decomposition of A, returning an Eigen factorization object F which contains the eigenvalues in F.values and the eigenvectors in the columns of the matrix F.vectors. (The kth eigenvector can be obtained from the slice F.vectors[:, k].)\\n\\nIterating the decomposition produces the components F.values and F.vectors.\\n\\nThe following functions are available for Eigen objects: inv, det, and isposdef.\\n\\nvl is the lower bound of the window of eigenvalues to search for, and vu is the upper bound.\\n\\nnote: Note\\nIf [vl, vu] does not contain all eigenvalues of A, then the returned factorization will be a truncated factorization.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.eigen!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.eigen!\",\n    \"category\": \"function\",\n    \"text\": \"eigen!(A, [B])\\n\\nSame as eigen, but saves space by overwriting the input A (and B), instead of creating a copy.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.hessenberg\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.hessenberg\",\n    \"category\": \"function\",\n    \"text\": \"hessenberg(A) -> Hessenberg\\n\\nCompute the Hessenberg decomposition of A and return a Hessenberg object. If F is the factorization object, the unitary matrix can be accessed with F.Q and the Hessenberg matrix with F.H. When Q is extracted, the resulting type is the HessenbergQ object, and may be converted to a regular matrix with convert(Array, _)  (or Array(_) for short).\\n\\nIterating the decomposition produces the factors F.Q and F.H.\\n\\nExamples\\n\\njulia> A = [4. 9. 7.; 4. 4. 1.; 4. 3. 2.]\\n3\u00d73 Array{Float64,2}:\\n 4.0  9.0  7.0\\n 4.0  4.0  1.0\\n 4.0  3.0  2.0\\n\\njulia> F = hessenberg(A);\\n\\njulia> F.Q * F.H * F.Q\\'\\n3\u00d73 Array{Float64,2}:\\n 4.0  9.0  7.0\\n 4.0  4.0  1.0\\n 4.0  3.0  2.0\\n\\njulia> q, h = F; # destructuring via iteration\\n\\njulia> q == F.Q && h == F.H\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.hessenberg!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.hessenberg!\",\n    \"category\": \"function\",\n    \"text\": \"hessenberg!(A) -> Hessenberg\\n\\nhessenberg! is the same as hessenberg, but saves space by overwriting the input A, instead of creating a copy.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.schur!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.schur!\",\n    \"category\": \"function\",\n    \"text\": \"schur!(A::StridedMatrix) -> F::Schur\\n\\nSame as schur but uses the input argument A as workspace.\\n\\nExamples\\n\\njulia> A = [5. 7.; -2. -4.]\\n2\u00d72 Array{Float64,2}:\\n  5.0   7.0\\n -2.0  -4.0\\n\\njulia> F = schur!(A)\\nSchur{Float64,Array{Float64,2}}\\nT factor:\\n2\u00d72 Array{Float64,2}:\\n 3.0   9.0\\n 0.0  -2.0\\nZ factor:\\n2\u00d72 Array{Float64,2}:\\n  0.961524  0.274721\\n -0.274721  0.961524\\neigenvalues:\\n2-element Array{Float64,1}:\\n  3.0\\n -2.0\\n\\njulia> A\\n2\u00d72 Array{Float64,2}:\\n 3.0   9.0\\n 0.0  -2.0\\n\\n\\n\\n\\n\\nschur!(A::StridedMatrix, B::StridedMatrix) -> F::GeneralizedSchur\\n\\nSame as schur but uses the input matrices A and B as workspace.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.schur\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.schur\",\n    \"category\": \"function\",\n    \"text\": \"schur(A::StridedMatrix) -> F::Schur\\n\\nComputes the Schur factorization of the matrix A. The (quasi) triangular Schur factor can be obtained from the Schur object F with either F.Schur or F.T and the orthogonal/unitary Schur vectors can be obtained with F.vectors or F.Z such that A = F.vectors * F.Schur * F.vectors\\'. The eigenvalues of A can be obtained with F.values.\\n\\nIterating the decomposition produces the components F.T, F.Z, and F.values.\\n\\nExamples\\n\\njulia> A = [5. 7.; -2. -4.]\\n2\u00d72 Array{Float64,2}:\\n  5.0   7.0\\n -2.0  -4.0\\n\\njulia> F = schur(A)\\nSchur{Float64,Array{Float64,2}}\\nT factor:\\n2\u00d72 Array{Float64,2}:\\n 3.0   9.0\\n 0.0  -2.0\\nZ factor:\\n2\u00d72 Array{Float64,2}:\\n  0.961524  0.274721\\n -0.274721  0.961524\\neigenvalues:\\n2-element Array{Float64,1}:\\n  3.0\\n -2.0\\n\\njulia> F.vectors * F.Schur * F.vectors\\'\\n2\u00d72 Array{Float64,2}:\\n  5.0   7.0\\n -2.0  -4.0\\n\\njulia> t, z, vals = F; # destructuring via iteration\\n\\njulia> t == F.T && z == F.Z && vals == F.values\\ntrue\\n\\n\\n\\n\\n\\nschur(A::StridedMatrix, B::StridedMatrix) -> F::GeneralizedSchur\\n\\nComputes the Generalized Schur (or QZ) factorization of the matrices A and B. The (quasi) triangular Schur factors can be obtained from the Schur object F with F.S and F.T, the left unitary/orthogonal Schur vectors can be obtained with F.left or F.Q and the right unitary/orthogonal Schur vectors can be obtained with F.right or F.Z such that A=F.left*F.S*F.right\\' and B=F.left*F.T*F.right\\'. The generalized eigenvalues of A and B can be obtained with F.\u03b1./F.\u03b2.\\n\\nIterating the decomposition produces the components F.S, F.T, F.Q, F.Z, F.\u03b1, and F.\u03b2.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.ordschur\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.ordschur\",\n    \"category\": \"function\",\n    \"text\": \"ordschur(F::Schur, select::Union{Vector{Bool},BitVector}) -> F::Schur\\n\\nReorders the Schur factorization F of a matrix A = Z*T*Z\\' according to the logical array select returning the reordered factorization F object. The selected eigenvalues appear in the leading diagonal of F.Schur and the corresponding leading columns of F.vectors form an orthogonal/unitary basis of the corresponding right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both included or both excluded via select.\\n\\n\\n\\n\\n\\nordschur(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -> F::GeneralizedSchur\\n\\nReorders the Generalized Schur factorization F of a matrix pair (A, B) = (Q*S*Z\\', Q*T*Z\\') according to the logical array select and returns a GeneralizedSchur object F. The selected eigenvalues appear in the leading diagonal of both F.S and F.T, and the left and right orthogonal/unitary Schur vectors are also reordered such that (A, B) = F.Q*(F.S, F.T)*F.Z\\' still holds and the generalized eigenvalues of A and B can still be obtained with F.\u03b1./F.\u03b2.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.ordschur!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.ordschur!\",\n    \"category\": \"function\",\n    \"text\": \"ordschur!(F::Schur, select::Union{Vector{Bool},BitVector}) -> F::Schur\\n\\nSame as ordschur but overwrites the factorization F.\\n\\n\\n\\n\\n\\nordschur!(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -> F::GeneralizedSchur\\n\\nSame as ordschur but overwrites the factorization F.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.svd\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.svd\",\n    \"category\": \"function\",\n    \"text\": \"svd(A; full::Bool = false) -> SVD\\n\\nCompute the singular value decomposition (SVD) of A and return an SVD object.\\n\\nU, S, V and Vt can be obtained from the factorization F with F.U, F.S, F.V and F.Vt, such that A = U * Diagonal(S) * Vt. The algorithm produces Vt and hence Vt is more efficient to extract than V. The singular values in S are sorted in descending order.\\n\\nIterating the decomposition produces the components U, S, and V.\\n\\nIf full = false (default), a \\\"thin\\\" SVD is returned. For a M times N matrix A, in the full factorization U is M \\\\times M and V is N \\\\times N, while in the thin factorization U is M \\\\times K and V is N \\\\times K, where K = \\\\min(M,N) is the number of singular values.\\n\\nExamples\\n\\njulia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]\\n4\u00d75 Array{Float64,2}:\\n 1.0  0.0  0.0  0.0  2.0\\n 0.0  0.0  3.0  0.0  0.0\\n 0.0  0.0  0.0  0.0  0.0\\n 0.0  2.0  0.0  0.0  0.0\\n\\njulia> F = svd(A);\\n\\njulia> F.U * Diagonal(F.S) * F.Vt\\n4\u00d75 Array{Float64,2}:\\n 1.0  0.0  0.0  0.0  2.0\\n 0.0  0.0  3.0  0.0  0.0\\n 0.0  0.0  0.0  0.0  0.0\\n 0.0  2.0  0.0  0.0  0.0\\n\\n\\n\\n\\n\\nsvd(A, B) -> GeneralizedSVD\\n\\nCompute the generalized SVD of A and B, returning a GeneralizedSVD factorization object F, such that A = F.U*F.D1*F.R0*F.Q\\' and B = F.V*F.D2*F.R0*F.Q\\'.\\n\\nFor an M-by-N matrix A and P-by-N matrix B,\\n\\nU is a M-by-M orthogonal matrix,\\nV is a P-by-P orthogonal matrix,\\nQ is a N-by-N orthogonal matrix,\\nD1 is a M-by-(K+L) diagonal matrix with 1s in the first K entries,\\nD2 is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,\\nR0 is a (K+L)-by-N matrix whose rightmost (K+L)-by-(K+L) block is          nonsingular upper block triangular,\\n\\nK+L is the effective numerical rank of the matrix [A; B].\\n\\nIterating the decomposition produces the components U, V, Q, D1, D2, and R0.\\n\\nThe entries of F.D1 and F.D2 are related, as explained in the LAPACK documentation for the generalized SVD and the xGGSVD3 routine which is called underneath (in LAPACK 3.6.0 and newer).\\n\\nExamples\\n\\njulia> A = [1. 0.; 0. -1.]\\n2\u00d72 Array{Float64,2}:\\n 1.0   0.0\\n 0.0  -1.0\\n\\njulia> B = [0. 1.; 1. 0.]\\n2\u00d72 Array{Float64,2}:\\n 0.0  1.0\\n 1.0  0.0\\n\\njulia> F = svd(A, B);\\n\\njulia> F.U*F.D1*F.R0*F.Q\\'\\n2\u00d72 Array{Float64,2}:\\n 1.0   0.0\\n 0.0  -1.0\\n\\njulia> F.V*F.D2*F.R0*F.Q\\'\\n2\u00d72 Array{Float64,2}:\\n 0.0  1.0\\n 1.0  0.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.svd!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.svd!\",\n    \"category\": \"function\",\n    \"text\": \"svd!(A; full::Bool = false) -> SVD\\n\\nsvd! is the same as svd, but saves space by overwriting the input A, instead of creating a copy.\\n\\nExamples\\n\\njulia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]\\n4\u00d75 Array{Float64,2}:\\n 1.0  0.0  0.0  0.0  2.0\\n 0.0  0.0  3.0  0.0  0.0\\n 0.0  0.0  0.0  0.0  0.0\\n 0.0  2.0  0.0  0.0  0.0\\n\\njulia> F = svd!(A);\\n\\njulia> F.U * Diagonal(F.S) * F.Vt\\n4\u00d75 Array{Float64,2}:\\n 1.0  0.0  0.0  0.0  2.0\\n 0.0  0.0  3.0  0.0  0.0\\n 0.0  0.0  0.0  0.0  0.0\\n 0.0  2.0  0.0  0.0  0.0\\n\\njulia> A\\n4\u00d75 Array{Float64,2}:\\n -2.23607   0.0   0.0  0.0  0.618034\\n  0.0      -3.0   1.0  0.0  0.0\\n  0.0       0.0   0.0  0.0  0.0\\n  0.0       0.0  -2.0  0.0  0.0\\n\\n\\n\\n\\n\\nsvd!(A, B) -> GeneralizedSVD\\n\\nsvd! is the same as svd, but modifies the arguments A and B in-place, instead of making copies.\\n\\nExamples\\n\\njulia> A = [1. 0.; 0. -1.]\\n2\u00d72 Array{Float64,2}:\\n 1.0   0.0\\n 0.0  -1.0\\n\\njulia> B = [0. 1.; 1. 0.]\\n2\u00d72 Array{Float64,2}:\\n 0.0  1.0\\n 1.0  0.0\\n\\njulia> F = svd!(A, B);\\n\\njulia> F.U*F.D1*F.R0*F.Q\\'\\n2\u00d72 Array{Float64,2}:\\n 1.0   0.0\\n 0.0  -1.0\\n\\njulia> F.V*F.D2*F.R0*F.Q\\'\\n2\u00d72 Array{Float64,2}:\\n 0.0  1.0\\n 1.0  0.0\\n\\njulia> A\\n2\u00d72 Array{Float64,2}:\\n 1.41421   0.0\\n 0.0      -1.41421\\n\\njulia> B\\n2\u00d72 Array{Float64,2}:\\n 1.0  -0.0\\n 0.0  -1.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.svdvals\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.svdvals\",\n    \"category\": \"function\",\n    \"text\": \"svdvals(A)\\n\\nReturn the singular values of A in descending order.\\n\\nExamples\\n\\njulia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]\\n4\u00d75 Array{Float64,2}:\\n 1.0  0.0  0.0  0.0  2.0\\n 0.0  0.0  3.0  0.0  0.0\\n 0.0  0.0  0.0  0.0  0.0\\n 0.0  2.0  0.0  0.0  0.0\\n\\njulia> svdvals(A)\\n4-element Array{Float64,1}:\\n 3.0\\n 2.23606797749979\\n 2.0\\n 0.0\\n\\n\\n\\n\\n\\nsvdvals(A, B)\\n\\nReturn the generalized singular values from the generalized singular value decomposition of A and B. See also svd.\\n\\nExamples\\n\\njulia> A = [1. 0.; 0. -1.]\\n2\u00d72 Array{Float64,2}:\\n 1.0   0.0\\n 0.0  -1.0\\n\\njulia> B = [0. 1.; 1. 0.]\\n2\u00d72 Array{Float64,2}:\\n 0.0  1.0\\n 1.0  0.0\\n\\njulia> svdvals(A, B)\\n2-element Array{Float64,1}:\\n 1.0\\n 1.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.svdvals!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.svdvals!\",\n    \"category\": \"function\",\n    \"text\": \"svdvals!(A)\\n\\nReturn the singular values of A, saving space by overwriting the input. See also svdvals and svd.\\n\\nExamples\\n\\njulia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]\\n4\u00d75 Array{Float64,2}:\\n 1.0  0.0  0.0  0.0  2.0\\n 0.0  0.0  3.0  0.0  0.0\\n 0.0  0.0  0.0  0.0  0.0\\n 0.0  2.0  0.0  0.0  0.0\\n\\njulia> svdvals!(A)\\n4-element Array{Float64,1}:\\n 3.0\\n 2.23606797749979\\n 2.0\\n 0.0\\n\\njulia> A\\n4\u00d75 Array{Float64,2}:\\n -2.23607   0.0   0.0  0.0  0.618034\\n  0.0      -3.0   1.0  0.0  0.0\\n  0.0       0.0   0.0  0.0  0.0\\n  0.0       0.0  -2.0  0.0  0.0\\n\\n\\n\\n\\n\\nsvdvals!(A, B)\\n\\nReturn the generalized singular values from the generalized singular value decomposition of A and B, saving space by overwriting A and B. See also svd and svdvals.\\n\\nExamples\\n\\njulia> A = [1. 0.; 0. -1.]\\n2\u00d72 Array{Float64,2}:\\n 1.0   0.0\\n 0.0  -1.0\\n\\njulia> B = [0. 1.; 1. 0.]\\n2\u00d72 Array{Float64,2}:\\n 0.0  1.0\\n 1.0  0.0\\n\\njulia> svdvals!(A, B)\\n2-element Array{Float64,1}:\\n 1.0\\n 1.0\\n\\njulia> A\\n2\u00d72 Array{Float64,2}:\\n 1.41421   0.0\\n 0.0      -1.41421\\n\\njulia> B\\n2\u00d72 Array{Float64,2}:\\n 1.0  -0.0\\n 0.0  -1.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.Givens\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.Givens\",\n    \"category\": \"type\",\n    \"text\": \"LinearAlgebra.Givens(i1,i2,c,s) -> G\\n\\nA Givens rotation linear operator. The fields c and s represent the cosine and sine of the rotation angle, respectively. The Givens type supports left multiplication G*A and conjugated transpose right multiplication A*G\\'. The type doesn\\'t have a size and can therefore be multiplied with matrices of arbitrary size as long as i2<=size(A,2) for G*A or i2<=size(A,1) for A*G\\'.\\n\\nSee also: givens\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.givens\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.givens\",\n    \"category\": \"function\",\n    \"text\": \"givens(f::T, g::T, i1::Integer, i2::Integer) where {T} -> (G::Givens, r::T)\\n\\nComputes the Givens rotation G and scalar r such that for any vector x where\\n\\nx[i1] = f\\nx[i2] = g\\n\\nthe result of the multiplication\\n\\ny = G*x\\n\\nhas the property that\\n\\ny[i1] = r\\ny[i2] = 0\\n\\nSee also: LinearAlgebra.Givens\\n\\n\\n\\n\\n\\ngivens(A::AbstractArray, i1::Integer, i2::Integer, j::Integer) -> (G::Givens, r)\\n\\nComputes the Givens rotation G and scalar r such that the result of the multiplication\\n\\nB = G*A\\n\\nhas the property that\\n\\nB[i1,j] = r\\nB[i2,j] = 0\\n\\nSee also: LinearAlgebra.Givens\\n\\n\\n\\n\\n\\ngivens(x::AbstractVector, i1::Integer, i2::Integer) -> (G::Givens, r)\\n\\nComputes the Givens rotation G and scalar r such that the result of the multiplication\\n\\nB = G*x\\n\\nhas the property that\\n\\nB[i1] = r\\nB[i2] = 0\\n\\nSee also: LinearAlgebra.Givens\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.triu\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.triu\",\n    \"category\": \"function\",\n    \"text\": \"triu(M)\\n\\nUpper triangle of a matrix.\\n\\nExamples\\n\\njulia> a = fill(1.0, (4,4))\\n4\u00d74 Array{Float64,2}:\\n 1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0\\n\\njulia> triu(a)\\n4\u00d74 Array{Float64,2}:\\n 1.0  1.0  1.0  1.0\\n 0.0  1.0  1.0  1.0\\n 0.0  0.0  1.0  1.0\\n 0.0  0.0  0.0  1.0\\n\\n\\n\\n\\n\\ntriu(M, k::Integer)\\n\\nReturns the upper triangle of M starting from the kth superdiagonal.\\n\\nExamples\\n\\njulia> a = fill(1.0, (4,4))\\n4\u00d74 Array{Float64,2}:\\n 1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0\\n\\njulia> triu(a,3)\\n4\u00d74 Array{Float64,2}:\\n 0.0  0.0  0.0  1.0\\n 0.0  0.0  0.0  0.0\\n 0.0  0.0  0.0  0.0\\n 0.0  0.0  0.0  0.0\\n\\njulia> triu(a,-3)\\n4\u00d74 Array{Float64,2}:\\n 1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.triu!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.triu!\",\n    \"category\": \"function\",\n    \"text\": \"triu!(M)\\n\\nUpper triangle of a matrix, overwriting M in the process. See also triu.\\n\\n\\n\\n\\n\\ntriu!(M, k::Integer)\\n\\nReturn the upper triangle of M starting from the kth superdiagonal, overwriting M in the process.\\n\\nExamples\\n\\njulia> M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]\\n5\u00d75 Array{Int64,2}:\\n 1  2  3  4  5\\n 1  2  3  4  5\\n 1  2  3  4  5\\n 1  2  3  4  5\\n 1  2  3  4  5\\n\\njulia> triu!(M, 1)\\n5\u00d75 Array{Int64,2}:\\n 0  2  3  4  5\\n 0  0  3  4  5\\n 0  0  0  4  5\\n 0  0  0  0  5\\n 0  0  0  0  0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.tril\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.tril\",\n    \"category\": \"function\",\n    \"text\": \"tril(M)\\n\\nLower triangle of a matrix.\\n\\nExamples\\n\\njulia> a = fill(1.0, (4,4))\\n4\u00d74 Array{Float64,2}:\\n 1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0\\n\\njulia> tril(a)\\n4\u00d74 Array{Float64,2}:\\n 1.0  0.0  0.0  0.0\\n 1.0  1.0  0.0  0.0\\n 1.0  1.0  1.0  0.0\\n 1.0  1.0  1.0  1.0\\n\\n\\n\\n\\n\\ntril(M, k::Integer)\\n\\nReturns the lower triangle of M starting from the kth superdiagonal.\\n\\nExamples\\n\\njulia> a = fill(1.0, (4,4))\\n4\u00d74 Array{Float64,2}:\\n 1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0\\n\\njulia> tril(a,3)\\n4\u00d74 Array{Float64,2}:\\n 1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0\\n 1.0  1.0  1.0  1.0\\n\\njulia> tril(a,-3)\\n4\u00d74 Array{Float64,2}:\\n 0.0  0.0  0.0  0.0\\n 0.0  0.0  0.0  0.0\\n 0.0  0.0  0.0  0.0\\n 1.0  0.0  0.0  0.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.tril!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.tril!\",\n    \"category\": \"function\",\n    \"text\": \"tril!(M)\\n\\nLower triangle of a matrix, overwriting M in the process. See also tril.\\n\\n\\n\\n\\n\\ntril!(M, k::Integer)\\n\\nReturn the lower triangle of M starting from the kth superdiagonal, overwriting M in the process.\\n\\nExamples\\n\\njulia> M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]\\n5\u00d75 Array{Int64,2}:\\n 1  2  3  4  5\\n 1  2  3  4  5\\n 1  2  3  4  5\\n 1  2  3  4  5\\n 1  2  3  4  5\\n\\njulia> tril!(M, 2)\\n5\u00d75 Array{Int64,2}:\\n 1  2  3  0  0\\n 1  2  3  4  0\\n 1  2  3  4  5\\n 1  2  3  4  5\\n 1  2  3  4  5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.diagind\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.diagind\",\n    \"category\": \"function\",\n    \"text\": \"diagind(M, k::Integer=0)\\n\\nAn AbstractRange giving the indices of the kth diagonal of the matrix M.\\n\\nExamples\\n\\njulia> A = [1 2 3; 4 5 6; 7 8 9]\\n3\u00d73 Array{Int64,2}:\\n 1  2  3\\n 4  5  6\\n 7  8  9\\n\\njulia> diagind(A,-1)\\n2:4:6\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.diag\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.diag\",\n    \"category\": \"function\",\n    \"text\": \"diag(M, k::Integer=0)\\n\\nThe kth diagonal of a matrix, as a vector.\\n\\nSee also: diagm\\n\\nExamples\\n\\njulia> A = [1 2 3; 4 5 6; 7 8 9]\\n3\u00d73 Array{Int64,2}:\\n 1  2  3\\n 4  5  6\\n 7  8  9\\n\\njulia> diag(A,1)\\n2-element Array{Int64,1}:\\n 2\\n 6\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.diagm\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.diagm\",\n    \"category\": \"function\",\n    \"text\": \"diagm(kv::Pair{<:Integer,<:AbstractVector}...)\\n\\nConstruct a square matrix from Pairs of diagonals and vectors. Vector kv.second will be placed on the kv.first diagonal. diagm constructs a full matrix; if you want storage-efficient versions with fast arithmetic, see Diagonal, Bidiagonal Tridiagonal and SymTridiagonal.\\n\\nExamples\\n\\njulia> diagm(1 => [1,2,3])\\n4\u00d74 Array{Int64,2}:\\n 0  1  0  0\\n 0  0  2  0\\n 0  0  0  3\\n 0  0  0  0\\n\\njulia> diagm(1 => [1,2,3], -1 => [4,5])\\n4\u00d74 Array{Int64,2}:\\n 0  1  0  0\\n 4  0  2  0\\n 0  5  0  3\\n 0  0  0  0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.rank\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.rank\",\n    \"category\": \"function\",\n    \"text\": \"rank(A[, tol::Real])\\n\\nCompute the rank of a matrix by counting how many singular values of A have magnitude greater than tol*\u03c3\u2081 where \u03c3\u2081 is A\\'s largest singular values. By default, the value of tol is the smallest dimension of A multiplied by the eps of the eltype of A.\\n\\nExamples\\n\\njulia> rank(Matrix(I, 3, 3))\\n3\\n\\njulia> rank(diagm(0 => [1, 0, 2]))\\n2\\n\\njulia> rank(diagm(0 => [1, 0.001, 2]), 0.1)\\n2\\n\\njulia> rank(diagm(0 => [1, 0.001, 2]), 0.00001)\\n3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.norm\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.norm\",\n    \"category\": \"function\",\n    \"text\": \"norm(A, p::Real=2)\\n\\nFor any iterable container A (including arrays of any dimension) of numbers (or any element type for which norm is defined), compute the p-norm (defaulting to p=2) as if A were a vector of the corresponding length.\\n\\nThe p-norm is defined as\\n\\nA_p = left( sum_i=1^n  a_i  ^p right)^1p\\n\\nwith a_i the entries of A,  a_i  the norm of a_i, and n the length of A. Since the p-norm is computed using the norms of the entries of A, the p-norm of a vector of vectors is not compatible with the interpretation of it as a block vector in general if p != 2.\\n\\np can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, norm(A, Inf) returns the largest value in abs.(A), whereas norm(A, -Inf) returns the smallest. If A is a matrix and p=2, then this is equivalent to the Frobenius norm.\\n\\nThe second argument p is not necessarily a part of the interface for norm, i.e. a custom type may only implement norm(A) without second argument.\\n\\nUse opnorm to compute the operator norm of a matrix.\\n\\nExamples\\n\\njulia> v = [3, -2, 6]\\n3-element Array{Int64,1}:\\n  3\\n -2\\n  6\\n\\njulia> norm(v)\\n7.0\\n\\njulia> norm(v, 1)\\n11.0\\n\\njulia> norm(v, Inf)\\n6.0\\n\\njulia> norm([1 2 3; 4 5 6; 7 8 9])\\n16.881943016134134\\n\\njulia> norm([1 2 3 4 5 6 7 8 9])\\n16.881943016134134\\n\\njulia> norm(1:9)\\n16.881943016134134\\n\\njulia> norm(hcat(v,v), 1) == norm(vcat(v,v), 1) != norm([v,v], 1)\\ntrue\\n\\njulia> norm(hcat(v,v), 2) == norm(vcat(v,v), 2) == norm([v,v], 2)\\ntrue\\n\\njulia> norm(hcat(v,v), Inf) == norm(vcat(v,v), Inf) != norm([v,v], Inf)\\ntrue\\n\\n\\n\\n\\n\\nnorm(x::Number, p::Real=2)\\n\\nFor numbers, return left( x^p right)^1p.\\n\\nExamples\\n\\njulia> norm(2, 1)\\n2\\n\\njulia> norm(-2, 1)\\n2\\n\\njulia> norm(2, 2)\\n2\\n\\njulia> norm(-2, 2)\\n2\\n\\njulia> norm(2, Inf)\\n2\\n\\njulia> norm(-2, Inf)\\n2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.opnorm\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.opnorm\",\n    \"category\": \"function\",\n    \"text\": \"opnorm(A::AbstractMatrix, p::Real=2)\\n\\nCompute the operator norm (or matrix norm) induced by the vector p-norm, where valid values of p are 1, 2, or Inf. (Note that for sparse matrices, p=2 is currently not implemented.) Use norm to compute the Frobenius norm.\\n\\nWhen p=1, the operator norm is the maximum absolute column sum of A:\\n\\nA_1 = max_1  j  n sum_i=1^m  a_ij \\n\\nwith a_ij the entries of A, and m and n its dimensions.\\n\\nWhen p=2, the operator norm is the spectral norm, equal to the largest singular value of A.\\n\\nWhen p=Inf, the operator norm is the maximum absolute row sum of A:\\n\\nA_infty = max_1  i  m sum _j=1^n  a_ij \\n\\nExamples\\n\\njulia> A = [1 -2 -3; 2 3 -1]\\n2\u00d73 Array{Int64,2}:\\n 1  -2  -3\\n 2   3  -1\\n\\njulia> opnorm(A, Inf)\\n6.0\\n\\njulia> opnorm(A, 1)\\n5.0\\n\\n\\n\\n\\n\\nopnorm(x::Number, p::Real=2)\\n\\nFor numbers, return left( x^p right)^1p. This is equivalent to norm.\\n\\n\\n\\n\\n\\nopnorm(A::Adjoint{<:Any,<:AbstracVector}, q::Real=2)\\nopnorm(A::Transpose{<:Any,<:AbstracVector}, q::Real=2)\\n\\nFor Adjoint/Transpose-wrapped vectors, return the operator q-norm of A, which is equivalent to the p-norm with value p = q/(q-1). They coincide at p = q = 2. Use norm to compute the p norm of A as a vector.\\n\\nThe difference in norm between a vector space and its dual arises to preserve the relationship between duality and the dot product, and the result is consistent with the operator p-norm of a 1 \u00d7 n matrix.\\n\\nExamples\\n\\njulia> v = [1; im];\\n\\njulia> vc = v\\';\\n\\njulia> opnorm(vc, 1)\\n1.0\\n\\njulia> norm(vc, 1)\\n2.0\\n\\njulia> norm(v, 1)\\n2.0\\n\\njulia> opnorm(vc, 2)\\n1.4142135623730951\\n\\njulia> norm(vc, 2)\\n1.4142135623730951\\n\\njulia> norm(v, 2)\\n1.4142135623730951\\n\\njulia> opnorm(vc, Inf)\\n2.0\\n\\njulia> norm(vc, Inf)\\n1.0\\n\\njulia> norm(v, Inf)\\n1.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.normalize!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.normalize!\",\n    \"category\": \"function\",\n    \"text\": \"normalize!(v::AbstractVector, p::Real=2)\\n\\nNormalize the vector v in-place so that its p-norm equals unity, i.e. norm(v, p) == 1. See also normalize and norm.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.normalize\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.normalize\",\n    \"category\": \"function\",\n    \"text\": \"normalize(v::AbstractVector, p::Real=2)\\n\\nNormalize the vector v so that its p-norm equals unity, i.e. norm(v, p) == vecnorm(v, p) == 1. See also normalize! and norm.\\n\\nExamples\\n\\njulia> a = [1,2,4];\\n\\njulia> b = normalize(a)\\n3-element Array{Float64,1}:\\n 0.2182178902359924\\n 0.4364357804719848\\n 0.8728715609439696\\n\\njulia> norm(b)\\n1.0\\n\\njulia> c = normalize(a, 1)\\n3-element Array{Float64,1}:\\n 0.14285714285714285\\n 0.2857142857142857\\n 0.5714285714285714\\n\\njulia> norm(c, 1)\\n1.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.cond\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.cond\",\n    \"category\": \"function\",\n    \"text\": \"cond(M, p::Real=2)\\n\\nCondition number of the matrix M, computed using the operator p-norm. Valid values for p are 1, 2 (default), or Inf.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.condskeel\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.condskeel\",\n    \"category\": \"function\",\n    \"text\": \"condskeel(M, [x, p::Real=Inf])\\n\\nkappa_S(M p) = leftVert leftvert M rightvert leftvert M^-1 rightvert rightVert_p \\nkappa_S(M x p) = leftVert leftvert M rightvert leftvert M^-1 rightvert leftvert x rightvert rightVert_p\\n\\nSkeel condition number kappa_S of the matrix M, optionally with respect to the vector x, as computed using the operator p-norm. leftvert M rightvert denotes the matrix of (entry wise) absolute values of M; leftvert M rightvert_ij = leftvert M_ij rightvert. Valid values for p are 1, 2 and Inf (default).\\n\\nThis quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.tr\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.tr\",\n    \"category\": \"function\",\n    \"text\": \"tr(M)\\n\\nMatrix trace. Sums the diagonal elements of M.\\n\\nExamples\\n\\njulia> A = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> tr(A)\\n5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.det\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.det\",\n    \"category\": \"function\",\n    \"text\": \"det(M)\\n\\nMatrix determinant.\\n\\nExamples\\n\\njulia> M = [1 0; 2 2]\\n2\u00d72 Array{Int64,2}:\\n 1  0\\n 2  2\\n\\njulia> det(M)\\n2.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.logdet\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.logdet\",\n    \"category\": \"function\",\n    \"text\": \"logdet(M)\\n\\nLog of matrix determinant. Equivalent to log(det(M)), but may provide increased accuracy and/or speed.\\n\\nExamples\\n\\njulia> M = [1 0; 2 2]\\n2\u00d72 Array{Int64,2}:\\n 1  0\\n 2  2\\n\\njulia> logdet(M)\\n0.6931471805599453\\n\\njulia> logdet(Matrix(I, 3, 3))\\n0.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.logabsdet\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.logabsdet\",\n    \"category\": \"function\",\n    \"text\": \"logabsdet(M)\\n\\nLog of absolute value of matrix determinant. Equivalent to (log(abs(det(M))), sign(det(M))), but may provide increased accuracy and/or speed.\\n\\nExamples\\n\\njulia> A = [-1. 0.; 0. 1.]\\n2\u00d72 Array{Float64,2}:\\n -1.0  0.0\\n  0.0  1.0\\n\\njulia> det(A)\\n-1.0\\n\\njulia> logabsdet(A)\\n(0.0, -1.0)\\n\\njulia> B = [2. 0.; 0. 1.]\\n2\u00d72 Array{Float64,2}:\\n 2.0  0.0\\n 0.0  1.0\\n\\njulia> det(B)\\n2.0\\n\\njulia> logabsdet(B)\\n(0.6931471805599453, 1.0)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.inv-Tuple{AbstractArray{T,2} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.inv\",\n    \"category\": \"method\",\n    \"text\": \"inv(M)\\n\\nMatrix inverse. Computes matrix N such that M * N = I, where I is the identity matrix. Computed by solving the left-division N = M \\\\ I.\\n\\nExamples\\n\\njulia> M = [2 5; 1 3]\\n2\u00d72 Array{Int64,2}:\\n 2  5\\n 1  3\\n\\njulia> N = inv(M)\\n2\u00d72 Array{Float64,2}:\\n  3.0  -5.0\\n -1.0   2.0\\n\\njulia> M*N == N*M == Matrix(I, 2, 2)\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.pinv\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.pinv\",\n    \"category\": \"function\",\n    \"text\": \"pinv(M[, tol::Real])\\n\\nComputes the Moore-Penrose pseudoinverse.\\n\\nFor matrices M with floating point elements, it is convenient to compute the pseudoinverse by inverting only singular values above a given threshold, tol.\\n\\nThe optimal choice of tol varies both with the value of M and the intended application of the pseudoinverse. The default value of tol is eps(real(float(one(eltype(M)))))*minimum(size(M)), which is essentially machine epsilon for the real part of a matrix element multiplied by the larger matrix dimension. For inverting dense ill-conditioned matrices in a least-squares sense, tol = sqrt(eps(real(float(one(eltype(M)))))) is recommended.\\n\\nFor more information, see [issue8859], [B96], [S84], [KY88].\\n\\nExamples\\n\\njulia> M = [1.5 1.3; 1.2 1.9]\\n2\u00d72 Array{Float64,2}:\\n 1.5  1.3\\n 1.2  1.9\\n\\njulia> N = pinv(M)\\n2\u00d72 Array{Float64,2}:\\n  1.47287   -1.00775\\n -0.930233   1.16279\\n\\njulia> M * N\\n2\u00d72 Array{Float64,2}:\\n 1.0          -2.22045e-16\\n 4.44089e-16   1.0\\n\\n[issue8859]: Issue 8859, \\\"Fix least squares\\\", https://github.com/JuliaLang/julia/pull/8859\\n\\n[B96]: \u00c5ke Bj\u00f6rck, \\\"Numerical Methods for Least Squares Problems\\\",  SIAM Press, Philadelphia, 1996, \\\"Other Titles in Applied Mathematics\\\", Vol. 51. doi:10.1137/1.9781611971484\\n\\n[S84]: G. W. Stewart, \\\"Rank Degeneracy\\\", SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. doi:10.1137/0905030\\n\\n[KY88]: Konstantinos Konstantinides and Kung Yao, \\\"Statistical analysis of effective singular values in matrix rank determination\\\", IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. doi:10.1109/29.1585\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.nullspace\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.nullspace\",\n    \"category\": \"function\",\n    \"text\": \"nullspace(M[, tol::Real])\\n\\nComputes a basis for the nullspace of M by including the singular vectors of A whose singular have magnitude are greater than tol*\u03c3\u2081, where \u03c3\u2081 is A\\'s largest singular values. By default, the value of tol is the smallest dimension of A multiplied by the eps of the eltype of A.\\n\\nExamples\\n\\njulia> M = [1 0 0; 0 1 0; 0 0 0]\\n3\u00d73 Array{Int64,2}:\\n 1  0  0\\n 0  1  0\\n 0  0  0\\n\\njulia> nullspace(M)\\n3\u00d71 Array{Float64,2}:\\n 0.0\\n 0.0\\n 1.0\\n\\njulia> nullspace(M, 2)\\n3\u00d73 Array{Float64,2}:\\n 0.0  1.0  0.0\\n 1.0  0.0  0.0\\n 0.0  0.0  1.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.kron\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.kron\",\n    \"category\": \"function\",\n    \"text\": \"kron(A, B)\\n\\nKronecker tensor product of two vectors or two matrices.\\n\\nExamples\\n\\njulia> A = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> B = [im 1; 1 -im]\\n2\u00d72 Array{Complex{Int64},2}:\\n 0+1im  1+0im\\n 1+0im  0-1im\\n\\njulia> kron(A, B)\\n4\u00d74 Array{Complex{Int64},2}:\\n 0+1im  1+0im  0+2im  2+0im\\n 1+0im  0-1im  2+0im  0-2im\\n 0+3im  3+0im  0+4im  4+0im\\n 3+0im  0-3im  4+0im  0-4im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.exp-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37<:Union{Complex{Float32}, Complex{Float64}, Float32, Float64}}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.exp\",\n    \"category\": \"method\",\n    \"text\": \"exp(A::AbstractMatrix)\\n\\nCompute the matrix exponential of A, defined by\\n\\ne^A = sum_n=0^infty fracA^nn\\n\\nFor symmetric or Hermitian A, an eigendecomposition (eigen) is used, otherwise the scaling and squaring algorithm (see [H05]) is chosen.\\n\\n[H05]: Nicholas J. Higham, \\\"The squaring and scaling method for the matrix exponential revisited\\\", SIAM Journal on Matrix Analysis and Applications, 26(4), 2005, 1179-1193. doi:10.1137/090768539\\n\\nExamples\\n\\njulia> A = Matrix(1.0I, 2, 2)\\n2\u00d72 Array{Float64,2}:\\n 1.0  0.0\\n 0.0  1.0\\n\\njulia> exp(A)\\n2\u00d72 Array{Float64,2}:\\n 2.71828  0.0\\n 0.0      2.71828\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.log-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.log\",\n    \"category\": \"method\",\n    \"text\": \"log(A{T}::StridedMatrix{T})\\n\\nIf A has no negative real eigenvalue, compute the principal matrix logarithm of A, i.e. the unique matrix X such that e^X = A and -pi  Im(lambda)  pi for all the eigenvalues lambda of X. If A has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.\\n\\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used, if A is triangular an improved version of the inverse scaling and squaring method is employed (see [AH12] and [AHR13]). For general matrices, the complex Schur form (schur) is computed and the triangular algorithm is used on the triangular factor.\\n\\n[AH12]: Awad H. Al-Mohy and Nicholas J. Higham, \\\"Improved inverse  scaling and squaring algorithms for the matrix logarithm\\\", SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. doi:10.1137/110852553\\n\\n[AHR13]: Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, \\\"Computing the Fr\u00e9chet derivative of the matrix logarithm and estimating the condition number\\\", SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. doi:10.1137/120885991\\n\\nExamples\\n\\njulia> A = Matrix(2.7182818*I, 2, 2)\\n2\u00d72 Array{Float64,2}:\\n 2.71828  0.0\\n 0.0      2.71828\\n\\njulia> log(A)\\n2\u00d72 Array{Float64,2}:\\n 1.0  0.0\\n 0.0  1.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.sqrt-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37<:Real}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.sqrt\",\n    \"category\": \"method\",\n    \"text\": \"sqrt(A::AbstractMatrix)\\n\\nIf A has no negative real eigenvalues, compute the principal matrix square root of A, that is the unique matrix X with eigenvalues having positive real part such that X^2 = A. Otherwise, a nonprincipal square root is returned.\\n\\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the square root. Otherwise, the square root is determined by means of the Bj\u00f6rck-Hammarling method [BH83], which computes the complex Schur form (schur) and then the complex square root of the triangular factor.\\n\\n[BH83]: \u00c5ke Bj\u00f6rck and Sven Hammarling, \\\"A Schur method for the square root of a matrix\\\", Linear Algebra and its Applications, 52-53, 1983, 127-140. doi:10.1016/0024-3795(83)80010-X\\n\\nExamples\\n\\njulia> A = [4 0; 0 4]\\n2\u00d72 Array{Int64,2}:\\n 4  0\\n 0  4\\n\\njulia> sqrt(A)\\n2\u00d72 Array{Float64,2}:\\n 2.0  0.0\\n 0.0  2.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.cos-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37<:Real}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.cos\",\n    \"category\": \"method\",\n    \"text\": \"cos(A::AbstractMatrix)\\n\\nCompute the matrix cosine of a square matrix A.\\n\\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the cosine. Otherwise, the cosine is determined by calling exp.\\n\\nExamples\\n\\njulia> cos(fill(1.0, (2,2)))\\n2\u00d72 Array{Float64,2}:\\n  0.291927  -0.708073\\n -0.708073   0.291927\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.sin-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37<:Real}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.sin\",\n    \"category\": \"method\",\n    \"text\": \"sin(A::AbstractMatrix)\\n\\nCompute the matrix sine of a square matrix A.\\n\\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the sine. Otherwise, the sine is determined by calling exp.\\n\\nExamples\\n\\njulia> sin(fill(1.0, (2,2)))\\n2\u00d72 Array{Float64,2}:\\n 0.454649  0.454649\\n 0.454649  0.454649\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.Math.sincos-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37<:Real}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.Math.sincos\",\n    \"category\": \"method\",\n    \"text\": \"sincos(A::AbstractMatrix)\\n\\nCompute the matrix sine and cosine of a square matrix A.\\n\\nExamples\\n\\njulia> S, C = sincos(fill(1.0, (2,2)));\\n\\njulia> S\\n2\u00d72 Array{Float64,2}:\\n 0.454649  0.454649\\n 0.454649  0.454649\\n\\njulia> C\\n2\u00d72 Array{Float64,2}:\\n  0.291927  -0.708073\\n -0.708073   0.291927\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.tan-Tuple{Union{DenseArray{#s37,2}, ReinterpretArray{#s37,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{#s37,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{#s37,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where #s37<:Real}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.tan\",\n    \"category\": \"method\",\n    \"text\": \"tan(A::AbstractMatrix)\\n\\nCompute the matrix tangent of a square matrix A.\\n\\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the tangent. Otherwise, the tangent is determined by calling exp.\\n\\nExamples\\n\\njulia> tan(fill(1.0, (2,2)))\\n2\u00d72 Array{Float64,2}:\\n -1.09252  -1.09252\\n -1.09252  -1.09252\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.Math.sec-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.Math.sec\",\n    \"category\": \"method\",\n    \"text\": \"sec(A::AbstractMatrix)\\n\\nCompute the matrix secant of a square matrix A.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.Math.csc-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.Math.csc\",\n    \"category\": \"method\",\n    \"text\": \"csc(A::AbstractMatrix)\\n\\nCompute the matrix cosecant of a square matrix A.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.Math.cot-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.Math.cot\",\n    \"category\": \"method\",\n    \"text\": \"cot(A::AbstractMatrix)\\n\\nCompute the matrix cotangent of a square matrix A.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.cosh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.cosh\",\n    \"category\": \"method\",\n    \"text\": \"cosh(A::AbstractMatrix)\\n\\nCompute the matrix hyperbolic cosine of a square matrix A.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.sinh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.sinh\",\n    \"category\": \"method\",\n    \"text\": \"sinh(A::AbstractMatrix)\\n\\nCompute the matrix hyperbolic sine of a square matrix A.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.tanh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.tanh\",\n    \"category\": \"method\",\n    \"text\": \"tanh(A::AbstractMatrix)\\n\\nCompute the matrix hyperbolic tangent of a square matrix A.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.Math.sech-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.Math.sech\",\n    \"category\": \"method\",\n    \"text\": \"sech(A::AbstractMatrix)\\n\\nCompute the matrix hyperbolic secant of square matrix A.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.Math.csch-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.Math.csch\",\n    \"category\": \"method\",\n    \"text\": \"csch(A::AbstractMatrix)\\n\\nCompute the matrix hyperbolic cosecant of square matrix A.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.Math.coth-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.Math.coth\",\n    \"category\": \"method\",\n    \"text\": \"coth(A::AbstractMatrix)\\n\\nCompute the matrix hyperbolic cotangent of square matrix A.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.acos-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.acos\",\n    \"category\": \"method\",\n    \"text\": \"acos(A::AbstractMatrix)\\n\\nCompute the inverse matrix cosine of a square matrix A.\\n\\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using log and sqrt.  For the theory and logarithmic formulas used to compute this function, see [AH16_1].\\n\\n[AH16_1]: Mary Aprahamian and Nicholas J. Higham, \\\"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\\\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\\n\\nExamples\\n\\njulia> acos(cos([0.5 0.1; -0.2 0.3]))\\n2\u00d72 Array{Complex{Float64},2}:\\n  0.5-5.55112e-17im  0.1-2.77556e-17im\\n -0.2+2.498e-16im    0.3-3.46945e-16im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.asin-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.asin\",\n    \"category\": \"method\",\n    \"text\": \"asin(A::AbstractMatrix)\\n\\nCompute the inverse matrix sine of a square matrix A.\\n\\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using log and sqrt.  For the theory and logarithmic formulas used to compute this function, see [AH16_2].\\n\\n[AH16_2]: Mary Aprahamian and Nicholas J. Higham, \\\"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\\\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\\n\\nExamples\\n\\njulia> asin(sin([0.5 0.1; -0.2 0.3]))\\n2\u00d72 Array{Complex{Float64},2}:\\n  0.5-4.16334e-17im  0.1-5.55112e-17im\\n -0.2+9.71445e-17im  0.3-1.249e-16im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.atan-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.atan\",\n    \"category\": \"method\",\n    \"text\": \"atan(A::AbstractMatrix)\\n\\nCompute the inverse matrix tangent of a square matrix A.\\n\\nIf A is symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using log.  For the theory and logarithmic formulas used to compute this function, see [AH16_3].\\n\\n[AH16_3]: Mary Aprahamian and Nicholas J. Higham, \\\"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\\\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\\n\\nExamples\\n\\njulia> atan(tan([0.5 0.1; -0.2 0.3]))\\n2\u00d72 Array{Complex{Float64},2}:\\n  0.5+1.38778e-17im  0.1-2.77556e-17im\\n -0.2+6.93889e-17im  0.3-4.16334e-17im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.Math.asec-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.Math.asec\",\n    \"category\": \"method\",\n    \"text\": \"asec(A::AbstractMatrix)\\n\\nCompute the inverse matrix secant of A. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.Math.acsc-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.Math.acsc\",\n    \"category\": \"method\",\n    \"text\": \"acsc(A::AbstractMatrix)\\n\\nCompute the inverse matrix cosecant of A. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.Math.acot-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.Math.acot\",\n    \"category\": \"method\",\n    \"text\": \"acot(A::AbstractMatrix)\\n\\nCompute the inverse matrix cotangent of A. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.acosh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.acosh\",\n    \"category\": \"method\",\n    \"text\": \"acosh(A::AbstractMatrix)\\n\\nCompute the inverse hyperbolic matrix cosine of a square matrix A.  For the theory and logarithmic formulas used to compute this function, see [AH16_4].\\n\\n[AH16_4]: Mary Aprahamian and Nicholas J. Higham, \\\"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\\\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.asinh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.asinh\",\n    \"category\": \"method\",\n    \"text\": \"asinh(A::AbstractMatrix)\\n\\nCompute the inverse hyperbolic matrix sine of a square matrix A.  For the theory and logarithmic formulas used to compute this function, see [AH16_5].\\n\\n[AH16_5]: Mary Aprahamian and Nicholas J. Higham, \\\"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\\\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.atanh-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.atanh\",\n    \"category\": \"method\",\n    \"text\": \"atanh(A::AbstractMatrix)\\n\\nCompute the inverse hyperbolic matrix tangent of a square matrix A.  For the theory and logarithmic formulas used to compute this function, see [AH16_6].\\n\\n[AH16_6]: Mary Aprahamian and Nicholas J. Higham, \\\"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms\\\", MIMS EPrint: 2016.4. https://doi.org/10.1137/16M1057577\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.Math.asech-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.Math.asech\",\n    \"category\": \"method\",\n    \"text\": \"asech(A::AbstractMatrix)\\n\\nCompute the inverse matrix hyperbolic secant of A. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.Math.acsch-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.Math.acsch\",\n    \"category\": \"method\",\n    \"text\": \"acsch(A::AbstractMatrix)\\n\\nCompute the inverse matrix hyperbolic cosecant of A. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.Math.acoth-Tuple{Union{DenseArray{T,2}, ReinterpretArray{T,2,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, ReshapedArray{T,2,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray}, SubArray{T,2,A,I,L} where L where I<:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, AbstractCartesianIndex},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, ReshapedArray{T,N,A,MI} where MI<:Tuple{Vararg{SignedMultiplicativeInverse{Int64},N} where N} where A<:Union{ReinterpretArray{T,N,S,A} where S where A<:Union{SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, SubArray{T,N,A,I,true} where I<:Tuple{AbstractUnitRange,Vararg{Any,N} where N} where A<:DenseArray where N where T, DenseArray} where N where T, DenseArray}} where T}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.Math.acoth\",\n    \"category\": \"method\",\n    \"text\": \"acoth(A::AbstractMatrix)\\n\\nCompute the inverse matrix hyperbolic cotangent of A. \\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.lyap\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.lyap\",\n    \"category\": \"function\",\n    \"text\": \"lyap(A, C)\\n\\nComputes the solution X to the continuous Lyapunov equation AX + XA\\' + C = 0, where no eigenvalue of A has a zero real part and no two eigenvalues are negative complex conjugates of each other.\\n\\nExamples\\n\\njulia> A = [3. 4.; 5. 6]\\n2\u00d72 Array{Float64,2}:\\n 3.0  4.0\\n 5.0  6.0\\n\\njulia> B = [1. 1.; 1. 2.]\\n2\u00d72 Array{Float64,2}:\\n 1.0  1.0\\n 1.0  2.0\\n\\njulia> X = lyap(A, B)\\n2\u00d72 Array{Float64,2}:\\n  0.5  -0.5\\n -0.5   0.25\\n\\njulia> A*X + X*A\\' + B\\n2\u00d72 Array{Float64,2}:\\n 0.0          6.66134e-16\\n 6.66134e-16  8.88178e-16\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.sylvester\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.sylvester\",\n    \"category\": \"function\",\n    \"text\": \"sylvester(A, B, C)\\n\\nComputes the solution X to the Sylvester equation AX + XB + C = 0, where A, B and C have compatible dimensions and A and -B have no eigenvalues with equal real part.\\n\\nExamples\\n\\njulia> A = [3. 4.; 5. 6]\\n2\u00d72 Array{Float64,2}:\\n 3.0  4.0\\n 5.0  6.0\\n\\njulia> B = [1. 1.; 1. 2.]\\n2\u00d72 Array{Float64,2}:\\n 1.0  1.0\\n 1.0  2.0\\n\\njulia> C = [1. 2.; -2. 1]\\n2\u00d72 Array{Float64,2}:\\n  1.0  2.0\\n -2.0  1.0\\n\\njulia> X = sylvester(A, B, C)\\n2\u00d72 Array{Float64,2}:\\n -4.46667   1.93333\\n  3.73333  -1.8\\n\\njulia> A*X + X*B + C\\n2\u00d72 Array{Float64,2}:\\n  2.66454e-15  1.77636e-15\\n -3.77476e-15  4.44089e-16\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.issuccess\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.issuccess\",\n    \"category\": \"function\",\n    \"text\": \"issuccess(F::Factorization)\\n\\nTest that a factorization of a matrix succeeded.\\n\\njulia> F = cholesky([1 0; 0 1]);\\n\\njulia> LinearAlgebra.issuccess(F)\\ntrue\\n\\njulia> F = lu([1 0; 0 0]; check = false);\\n\\njulia> LinearAlgebra.issuccess(F)\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.issymmetric\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.issymmetric\",\n    \"category\": \"function\",\n    \"text\": \"issymmetric(A) -> Bool\\n\\nTest whether a matrix is symmetric.\\n\\nExamples\\n\\njulia> a = [1 2; 2 -1]\\n2\u00d72 Array{Int64,2}:\\n 1   2\\n 2  -1\\n\\njulia> issymmetric(a)\\ntrue\\n\\njulia> b = [1 im; -im 1]\\n2\u00d72 Array{Complex{Int64},2}:\\n 1+0im  0+1im\\n 0-1im  1+0im\\n\\njulia> issymmetric(b)\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.isposdef\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.isposdef\",\n    \"category\": \"function\",\n    \"text\": \"isposdef(A) -> Bool\\n\\nTest whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of A. See also isposdef!\\n\\nExamples\\n\\njulia> A = [1 2; 2 50]\\n2\u00d72 Array{Int64,2}:\\n 1   2\\n 2  50\\n\\njulia> isposdef(A)\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.isposdef!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.isposdef!\",\n    \"category\": \"function\",\n    \"text\": \"isposdef!(A) -> Bool\\n\\nTest whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of A, overwriting A in the process. See also isposdef.\\n\\nExamples\\n\\njulia> A = [1. 2.; 2. 50.];\\n\\njulia> isposdef!(A)\\ntrue\\n\\njulia> A\\n2\u00d72 Array{Float64,2}:\\n 1.0  2.0\\n 2.0  6.78233\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.istril\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.istril\",\n    \"category\": \"function\",\n    \"text\": \"istril(A::AbstractMatrix, k::Integer = 0) -> Bool\\n\\nTest whether A is lower triangular starting from the kth superdiagonal.\\n\\nExamples\\n\\njulia> a = [1 2; 2 -1]\\n2\u00d72 Array{Int64,2}:\\n 1   2\\n 2  -1\\n\\njulia> istril(a)\\nfalse\\n\\njulia> istril(a, 1)\\ntrue\\n\\njulia> b = [1 0; -im -1]\\n2\u00d72 Array{Complex{Int64},2}:\\n 1+0im   0+0im\\n 0-1im  -1+0im\\n\\njulia> istril(b)\\ntrue\\n\\njulia> istril(b, -1)\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.istriu\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.istriu\",\n    \"category\": \"function\",\n    \"text\": \"istriu(A::AbstractMatrix, k::Integer = 0) -> Bool\\n\\nTest whether A is upper triangular starting from the kth superdiagonal.\\n\\nExamples\\n\\njulia> a = [1 2; 2 -1]\\n2\u00d72 Array{Int64,2}:\\n 1   2\\n 2  -1\\n\\njulia> istriu(a)\\nfalse\\n\\njulia> istriu(a, -1)\\ntrue\\n\\njulia> b = [1 im; 0 -1]\\n2\u00d72 Array{Complex{Int64},2}:\\n 1+0im   0+1im\\n 0+0im  -1+0im\\n\\njulia> istriu(b)\\ntrue\\n\\njulia> istriu(b, 1)\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.isdiag\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.isdiag\",\n    \"category\": \"function\",\n    \"text\": \"isdiag(A) -> Bool\\n\\nTest whether a matrix is diagonal.\\n\\nExamples\\n\\njulia> a = [1 2; 2 -1]\\n2\u00d72 Array{Int64,2}:\\n 1   2\\n 2  -1\\n\\njulia> isdiag(a)\\nfalse\\n\\njulia> b = [im 0; 0 -im]\\n2\u00d72 Array{Complex{Int64},2}:\\n 0+1im  0+0im\\n 0+0im  0-1im\\n\\njulia> isdiag(b)\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.ishermitian\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.ishermitian\",\n    \"category\": \"function\",\n    \"text\": \"ishermitian(A) -> Bool\\n\\nTest whether a matrix is Hermitian.\\n\\nExamples\\n\\njulia> a = [1 2; 2 -1]\\n2\u00d72 Array{Int64,2}:\\n 1   2\\n 2  -1\\n\\njulia> ishermitian(a)\\ntrue\\n\\njulia> b = [1 im; -im 1]\\n2\u00d72 Array{Complex{Int64},2}:\\n 1+0im  0+1im\\n 0-1im  1+0im\\n\\njulia> ishermitian(b)\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.transpose\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.transpose\",\n    \"category\": \"function\",\n    \"text\": \"transpose(A)\\n\\nLazy transpose. Mutating the returned object should appropriately mutate A. Often, but not always, yields Transpose(A), where Transpose is a lazy transpose wrapper. Note that this operation is recursive.\\n\\nThis operation is intended for linear algebra usage - for general data manipulation see permutedims, which is non-recursive.\\n\\nExamples\\n\\njulia> A = [3+2im 9+2im; 8+7im  4+6im]\\n2\u00d72 Array{Complex{Int64},2}:\\n 3+2im  9+2im\\n 8+7im  4+6im\\n\\njulia> transpose(A)\\n2\u00d72 Transpose{Complex{Int64},Array{Complex{Int64},2}}:\\n 3+2im  8+7im\\n 9+2im  4+6im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.transpose!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.transpose!\",\n    \"category\": \"function\",\n    \"text\": \"transpose!(dest,src)\\n\\nTranspose array src and store the result in the preallocated array dest, which should have a size corresponding to (size(src,2),size(src,1)). No in-place transposition is supported and unexpected results will happen if src and dest have overlapping memory regions.\\n\\nExamples\\n\\njulia> A = [3+2im 9+2im; 8+7im  4+6im]\\n2\u00d72 Array{Complex{Int64},2}:\\n 3+2im  9+2im\\n 8+7im  4+6im\\n\\njulia> B = zeros(Complex{Int64}, 2, 2)\\n2\u00d72 Array{Complex{Int64},2}:\\n 0+0im  0+0im\\n 0+0im  0+0im\\n\\njulia> transpose!(B, A);\\n\\njulia> B\\n2\u00d72 Array{Complex{Int64},2}:\\n 3+2im  8+7im\\n 9+2im  4+6im\\n\\njulia> A\\n2\u00d72 Array{Complex{Int64},2}:\\n 3+2im  9+2im\\n 8+7im  4+6im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.adjoint\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.adjoint\",\n    \"category\": \"function\",\n    \"text\": \"adjoint(A)\\n\\nLazy adjoint (conjugate transposition) (also postfix \\'). Note that adjoint is applied recursively to elements.\\n\\nThis operation is intended for linear algebra usage - for general data manipulation see permutedims.\\n\\nExamples\\n\\njulia> A = [3+2im 9+2im; 8+7im  4+6im]\\n2\u00d72 Array{Complex{Int64},2}:\\n 3+2im  9+2im\\n 8+7im  4+6im\\n\\njulia> adjoint(A)\\n2\u00d72 Adjoint{Complex{Int64},Array{Complex{Int64},2}}:\\n 3-2im  8-7im\\n 9-2im  4-6im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.adjoint!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.adjoint!\",\n    \"category\": \"function\",\n    \"text\": \"adjoint!(dest,src)\\n\\nConjugate transpose array src and store the result in the preallocated array dest, which should have a size corresponding to (size(src,2),size(src,1)). No in-place transposition is supported and unexpected results will happen if src and dest have overlapping memory regions.\\n\\nExamples\\n\\njulia> A = [3+2im 9+2im; 8+7im  4+6im]\\n2\u00d72 Array{Complex{Int64},2}:\\n 3+2im  9+2im\\n 8+7im  4+6im\\n\\njulia> B = zeros(Complex{Int64}, 2, 2)\\n2\u00d72 Array{Complex{Int64},2}:\\n 0+0im  0+0im\\n 0+0im  0+0im\\n\\njulia> adjoint!(B, A);\\n\\njulia> B\\n2\u00d72 Array{Complex{Int64},2}:\\n 3-2im  8-7im\\n 9-2im  4-6im\\n\\njulia> A\\n2\u00d72 Array{Complex{Int64},2}:\\n 3+2im  9+2im\\n 8+7im  4+6im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Base.copy-Tuple{Union{Adjoint, Transpose}}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Base.copy\",\n    \"category\": \"method\",\n    \"text\": \"copy(A::Transpose)\\ncopy(A::Adjoint)\\n\\nEagerly evaluate the lazy matrix transpose/adjoint. Note that the transposition is applied recursively to elements.\\n\\nThis operation is intended for linear algebra usage - for general data manipulation see permutedims, which is non-recursive.\\n\\nExamples\\n\\njulia> A = [1 2im; -3im 4]\\n2\u00d72 Array{Complex{Int64},2}:\\n 1+0im  0+2im\\n 0-3im  4+0im\\n\\njulia> T = transpose(A)\\n2\u00d72 Transpose{Complex{Int64},Array{Complex{Int64},2}}:\\n 1+0im  0-3im\\n 0+2im  4+0im\\n\\njulia> copy(T)\\n2\u00d72 Array{Complex{Int64},2}:\\n 1+0im  0-3im\\n 0+2im  4+0im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.stride1\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.stride1\",\n    \"category\": \"function\",\n    \"text\": \"stride1(A) -> Int\\n\\nReturn the distance between successive array elements in dimension 1 in units of element size.\\n\\nExamples\\n\\njulia> A = [1,2,3,4]\\n4-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n 4\\n\\njulia> LinearAlgebra.stride1(A)\\n1\\n\\njulia> B = view(A, 2:2:4)\\n2-element view(::Array{Int64,1}, 2:2:4) with eltype Int64:\\n 2\\n 4\\n\\njulia> LinearAlgebra.stride1(B)\\n2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.checksquare\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.checksquare\",\n    \"category\": \"function\",\n    \"text\": \"LinearAlgebra.checksquare(A)\\n\\nCheck that a matrix is square, then return its common dimension. For multiple arguments, return a vector.\\n\\nExamples\\n\\njulia> A = fill(1, (4,4)); B = fill(1, (5,5));\\n\\njulia> LinearAlgebra.checksquare(A, B)\\n2-element Array{Int64,1}:\\n 4\\n 5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Standard-Functions-1\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Standard Functions\",\n    \"category\": \"section\",\n    \"text\": \"Linear algebra functions in Julia are largely implemented by calling functions from LAPACK.  Sparse factorizations call functions from SuiteSparse.Base.:*(::AbstractMatrix, ::AbstractMatrix)\\nBase.:\\\\(::AbstractMatrix, ::AbstractVecOrMat)\\nLinearAlgebra.dot\\nLinearAlgebra.cross\\nLinearAlgebra.factorize\\nLinearAlgebra.Diagonal\\nLinearAlgebra.Bidiagonal\\nLinearAlgebra.SymTridiagonal\\nLinearAlgebra.Tridiagonal\\nLinearAlgebra.Symmetric\\nLinearAlgebra.Hermitian\\nLinearAlgebra.LowerTriangular\\nLinearAlgebra.UpperTriangular\\nLinearAlgebra.UniformScaling\\nLinearAlgebra.lu\\nLinearAlgebra.lu!\\nLinearAlgebra.cholesky\\nLinearAlgebra.cholesky!\\nLinearAlgebra.lowrankupdate\\nLinearAlgebra.lowrankdowndate\\nLinearAlgebra.lowrankupdate!\\nLinearAlgebra.lowrankdowndate!\\nLinearAlgebra.ldlt\\nLinearAlgebra.ldlt!\\nLinearAlgebra.qr\\nLinearAlgebra.qr!\\nLinearAlgebra.QR\\nLinearAlgebra.QRCompactWY\\nLinearAlgebra.QRPivoted\\nLinearAlgebra.lq!\\nLinearAlgebra.lq\\nLinearAlgebra.bunchkaufman\\nLinearAlgebra.bunchkaufman!\\nLinearAlgebra.eigvals\\nLinearAlgebra.eigvals!\\nLinearAlgebra.eigmax\\nLinearAlgebra.eigmin\\nLinearAlgebra.eigvecs\\nLinearAlgebra.eigen\\nLinearAlgebra.eigen!\\nLinearAlgebra.hessenberg\\nLinearAlgebra.hessenberg!\\nLinearAlgebra.schur!\\nLinearAlgebra.schur\\nLinearAlgebra.ordschur\\nLinearAlgebra.ordschur!\\nLinearAlgebra.svd\\nLinearAlgebra.svd!\\nLinearAlgebra.svdvals\\nLinearAlgebra.svdvals!\\nLinearAlgebra.Givens\\nLinearAlgebra.givens\\nLinearAlgebra.triu\\nLinearAlgebra.triu!\\nLinearAlgebra.tril\\nLinearAlgebra.tril!\\nLinearAlgebra.diagind\\nLinearAlgebra.diag\\nLinearAlgebra.diagm\\nLinearAlgebra.rank\\nLinearAlgebra.norm\\nLinearAlgebra.opnorm\\nLinearAlgebra.normalize!\\nLinearAlgebra.normalize\\nLinearAlgebra.cond\\nLinearAlgebra.condskeel\\nLinearAlgebra.tr\\nLinearAlgebra.det\\nLinearAlgebra.logdet\\nLinearAlgebra.logabsdet\\nBase.inv(::AbstractMatrix)\\nLinearAlgebra.pinv\\nLinearAlgebra.nullspace\\nBase.kron\\nLinearAlgebra.exp(::StridedMatrix{<:LinearAlgebra.BlasFloat})\\nLinearAlgebra.log(::StridedMatrix)\\nLinearAlgebra.sqrt(::StridedMatrix{<:Real})\\nLinearAlgebra.cos(::StridedMatrix{<:Real})\\nLinearAlgebra.sin(::StridedMatrix{<:Real})\\nLinearAlgebra.sincos(::StridedMatrix{<:Real})\\nLinearAlgebra.tan(::StridedMatrix{<:Real})\\nLinearAlgebra.sec(::StridedMatrix)\\nLinearAlgebra.csc(::StridedMatrix)\\nLinearAlgebra.cot(::StridedMatrix)\\nLinearAlgebra.cosh(::StridedMatrix)\\nLinearAlgebra.sinh(::StridedMatrix)\\nLinearAlgebra.tanh(::StridedMatrix)\\nLinearAlgebra.sech(::StridedMatrix)\\nLinearAlgebra.csch(::StridedMatrix)\\nLinearAlgebra.coth(::StridedMatrix)\\nLinearAlgebra.acos(::StridedMatrix)\\nLinearAlgebra.asin(::StridedMatrix)\\nLinearAlgebra.atan(::StridedMatrix)\\nLinearAlgebra.asec(::StridedMatrix)\\nLinearAlgebra.acsc(::StridedMatrix)\\nLinearAlgebra.acot(::StridedMatrix)\\nLinearAlgebra.acosh(::StridedMatrix)\\nLinearAlgebra.asinh(::StridedMatrix)\\nLinearAlgebra.atanh(::StridedMatrix)\\nLinearAlgebra.asech(::StridedMatrix)\\nLinearAlgebra.acsch(::StridedMatrix)\\nLinearAlgebra.acoth(::StridedMatrix)\\nLinearAlgebra.lyap\\nLinearAlgebra.sylvester\\nLinearAlgebra.issuccess\\nLinearAlgebra.issymmetric\\nLinearAlgebra.isposdef\\nLinearAlgebra.isposdef!\\nLinearAlgebra.istril\\nLinearAlgebra.istriu\\nLinearAlgebra.isdiag\\nLinearAlgebra.ishermitian\\nBase.transpose\\nLinearAlgebra.transpose!\\nBase.adjoint\\nLinearAlgebra.adjoint!\\nBase.copy(::Union{Transpose,Adjoint})\\nLinearAlgebra.stride1\\nLinearAlgebra.checksquare\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.mul!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.mul!\",\n    \"category\": \"function\",\n    \"text\": \"mul!(Y, A, B) -> Y\\n\\nCalculates the matrix-matrix or matrix-vector product AB and stores the result in Y, overwriting the existing value of Y. Note that Y must not be aliased with either A or B.\\n\\nExamples\\n\\njulia> A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; Y = similar(B); mul!(Y, A, B);\\n\\njulia> Y\\n2\u00d72 Array{Float64,2}:\\n 3.0  3.0\\n 7.0  7.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.lmul!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.lmul!\",\n    \"category\": \"function\",\n    \"text\": \"lmul!(a::Number, B::AbstractArray)\\n\\nScale an array B by a scalar a overwriting B in-place.\\n\\nExamples\\n\\njulia> B = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> lmul!(2, B)\\n2\u00d72 Array{Int64,2}:\\n 2  4\\n 6  8\\n\\n\\n\\n\\n\\nlmul!(A, B)\\n\\nCalculate the matrix-matrix product AB, overwriting B, and return the result.\\n\\nExamples\\n\\njulia> B = [0 1; 1 0];\\n\\njulia> A = LinearAlgebra.UpperTriangular([1 2; 0 3]);\\n\\njulia> LinearAlgebra.lmul!(A, B);\\n\\njulia> B\\n2\u00d72 Array{Int64,2}:\\n 2  1\\n 3  0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.rmul!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.rmul!\",\n    \"category\": \"function\",\n    \"text\": \"rmul!(A::AbstractArray, b::Number)\\n\\nScale an array A by a scalar b overwriting A in-place.\\n\\nExamples\\n\\njulia> A = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> rmul!(A, 2)\\n2\u00d72 Array{Int64,2}:\\n 2  4\\n 6  8\\n\\n\\n\\n\\n\\nrmul!(A, B)\\n\\nCalculate the matrix-matrix product AB, overwriting A, and return the result.\\n\\nExamples\\n\\njulia> A = [0 1; 1 0];\\n\\njulia> B = LinearAlgebra.UpperTriangular([1 2; 0 3]);\\n\\njulia> LinearAlgebra.rmul!(A, B);\\n\\njulia> A\\n2\u00d72 Array{Int64,2}:\\n 0  3\\n 1  2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.ldiv!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.ldiv!\",\n    \"category\": \"function\",\n    \"text\": \"ldiv!(Y, A, B) -> Y\\n\\nCompute A \\\\ B in-place and store the result in Y, returning the result.\\n\\nThe argument A should not be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by factorize or cholesky). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., lu!), and performance-critical situations requiring ldiv! usually also require fine-grained control over the factorization of A.\\n\\nExamples\\n\\njulia> A = [1 2.2 4; 3.1 0.2 3; 4 1 2];\\n\\njulia> X = [1; 2.5; 3];\\n\\njulia> Y = zero(X);\\n\\njulia> ldiv!(Y, qr(A), X);\\n\\njulia> Y\\n3-element Array{Float64,1}:\\n  0.7128099173553719\\n -0.051652892561983674\\n  0.10020661157024757\\n\\njulia> A\\\\X\\n3-element Array{Float64,1}:\\n  0.7128099173553719\\n -0.05165289256198333\\n  0.10020661157024785\\n\\n\\n\\n\\n\\nldiv!(A, B)\\n\\nCompute A \\\\ B in-place and overwriting B to store the result.\\n\\nThe argument A should not be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by factorize or cholesky). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., lu!), and performance-critical situations requiring ldiv! usually also require fine-grained control over the factorization of A.\\n\\nExamples\\n\\njulia> A = [1 2.2 4; 3.1 0.2 3; 4 1 2];\\n\\njulia> X = [1; 2.5; 3];\\n\\njulia> Y = copy(X);\\n\\njulia> ldiv!(qr(A), X);\\n\\njulia> X\\n3-element Array{Float64,1}:\\n  0.7128099173553719\\n -0.051652892561983674\\n  0.10020661157024757\\n\\njulia> A\\\\Y\\n3-element Array{Float64,1}:\\n  0.7128099173553719\\n -0.05165289256198333\\n  0.10020661157024785\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.rdiv!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.rdiv!\",\n    \"category\": \"function\",\n    \"text\": \"rdiv!(A, B)\\n\\nCompute A / B in-place and overwriting A to store the result.\\n\\nThe argument B should not be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by factorize or cholesky). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., lu!), and performance-critical situations requiring rdiv! usually also require fine-grained control over the factorization of B.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#Low-level-matrix-operations-1\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Low-level matrix operations\",\n    \"category\": \"section\",\n    \"text\": \"In many cases there are in-place versions of matrix operations that allow you to supply a pre-allocated output vector or matrix.  This is useful when optimizing critical code in order to avoid the overhead of repeated allocations. These in-place operations are suffixed with ! below (e.g. mul!) according to the usual Julia convention.LinearAlgebra.mul!\\nLinearAlgebra.lmul!\\nLinearAlgebra.rmul!\\nLinearAlgebra.ldiv!\\nLinearAlgebra.rdiv!\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#BLAS-Functions-1\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"BLAS Functions\",\n    \"category\": \"section\",\n    \"text\": \"In Julia (as in much of scientific computation), dense linear-algebra operations are based on the LAPACK library, which in turn is built on top of basic linear-algebra building-blocks known as the BLAS. There are highly optimized implementations of BLAS available for every computer architecture, and sometimes in high-performance linear algebra routines it is useful to call the BLAS functions directly.LinearAlgebra.BLAS provides wrappers for some of the BLAS functions. Those BLAS functions that overwrite one of the input arrays have names ending in \\'!\\'.  Usually, a BLAS function has four methods defined, for Float64, Float32, ComplexF64, and ComplexF32 arrays.\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#stdlib-blas-chars-1\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"BLAS Character Arguments\",\n    \"category\": \"section\",\n    \"text\": \"Many BLAS functions accept arguments that determine whether to transpose an argument (trans), which triangle of a matrix to reference (uplo or ul), whether the diagonal of a triangular matrix can be assumed to be all ones (dA) or which side of a matrix multiplication the input argument belongs on (side). The possibilities are:\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#stdlib-blas-side-1\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Multplication Order\",\n    \"category\": \"section\",\n    \"text\": \"side Meaning\\n\\'L\\' The argument goes on the left side of a matrix-matrix operation.\\n\\'R\\' The argument goes on the right side of a matrix-matrix operation.\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#stdlib-blas-uplo-1\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Triangle Referencing\",\n    \"category\": \"section\",\n    \"text\": \"uplo/ul Meaning\\n\\'U\\' Only the upper triangle of the matrix will be used.\\n\\'L\\' Only the lower triangle of the matrix will be used.\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#stdlib-blas-trans-1\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Transposition Operation\",\n    \"category\": \"section\",\n    \"text\": \"trans/tX Meaning\\n\\'N\\' The input matrix X is not transposed or conjugated.\\n\\'T\\' The input matrix X will be transposed.\\n\\'C\\' The input matrix X will be conjugated and transposed.\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS\",\n    \"category\": \"module\",\n    \"text\": \"Interface to BLAS subroutines.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.dotu\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.dotu\",\n    \"category\": \"function\",\n    \"text\": \"dotu(n, X, incx, Y, incy)\\n\\nDot function for two complex vectors consisting of n elements of array X with stride incx and n elements of array Y with stride incy.\\n\\nExamples\\n\\njulia> BLAS.dotu(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)\\n-10.0 + 10.0im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.dotc\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.dotc\",\n    \"category\": \"function\",\n    \"text\": \"dotc(n, X, incx, U, incy)\\n\\nDot function for two complex vectors, consisting of n elements of array X with stride incx and n elements of array U with stride incy, conjugating the first vector.\\n\\nExamples\\n\\njulia> BLAS.dotc(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)\\n10.0 - 10.0im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.blascopy!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.blascopy!\",\n    \"category\": \"function\",\n    \"text\": \"blascopy!(n, X, incx, Y, incy)\\n\\nCopy n elements of array X with stride incx to array Y with stride incy. Returns Y.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.nrm2\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.nrm2\",\n    \"category\": \"function\",\n    \"text\": \"nrm2(n, X, incx)\\n\\n2-norm of a vector consisting of n elements of array X with stride incx.\\n\\nExamples\\n\\njulia> BLAS.nrm2(4, fill(1.0, 8), 2)\\n2.0\\n\\njulia> BLAS.nrm2(1, fill(1.0, 8), 2)\\n1.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.asum\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.asum\",\n    \"category\": \"function\",\n    \"text\": \"asum(n, X, incx)\\n\\nSum of the absolute values of the first n elements of array X with stride incx.\\n\\nExamples\\n\\njulia> BLAS.asum(5, fill(1.0im, 10), 2)\\n5.0\\n\\njulia> BLAS.asum(2, fill(1.0im, 10), 5)\\n2.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.axpy!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.axpy!\",\n    \"category\": \"function\",\n    \"text\": \"axpy!(a, X, Y)\\n\\nOverwrite Y with a*X + Y, where a is a scalar. Return Y.\\n\\nExamples\\n\\njulia> x = [1; 2; 3];\\n\\njulia> y = [4; 5; 6];\\n\\njulia> BLAS.axpy!(2, x, y)\\n3-element Array{Int64,1}:\\n  6\\n  9\\n 12\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.scal!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.scal!\",\n    \"category\": \"function\",\n    \"text\": \"scal!(n, a, X, incx)\\n\\nOverwrite X with a*X for the first n elements of array X with stride incx. Returns X.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.scal\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.scal\",\n    \"category\": \"function\",\n    \"text\": \"scal(n, a, X, incx)\\n\\nReturn X scaled by a for the first n elements of array X with stride incx.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.ger!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.ger!\",\n    \"category\": \"function\",\n    \"text\": \"ger!(alpha, x, y, A)\\n\\nRank-1 update of the matrix A with vectors x and y as alpha*x*y\\' + A.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.syr!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.syr!\",\n    \"category\": \"function\",\n    \"text\": \"syr!(uplo, alpha, x, A)\\n\\nRank-1 update of the symmetric matrix A with vector x as alpha*x*transpose(x) + A. uplo controls which triangle of A is updated. Returns A.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.syrk!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.syrk!\",\n    \"category\": \"function\",\n    \"text\": \"syrk!(uplo, trans, alpha, A, beta, C)\\n\\nRank-k update of the symmetric matrix C as alpha*A*transpose(A) + beta*C or alpha*transpose(A)*A + beta*C according to trans. Only the uplo triangle of C is used. Returns C.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.syrk\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.syrk\",\n    \"category\": \"function\",\n    \"text\": \"syrk(uplo, trans, alpha, A)\\n\\nReturns either the upper triangle or the lower triangle of A, according to uplo, of alpha*A*transpose(A) or alpha*transpose(A)*A, according to trans.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.her!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.her!\",\n    \"category\": \"function\",\n    \"text\": \"her!(uplo, alpha, x, A)\\n\\nMethods for complex arrays only. Rank-1 update of the Hermitian matrix A with vector x as alpha*x*x\\' + A. uplo controls which triangle of A is updated. Returns A.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.herk!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.herk!\",\n    \"category\": \"function\",\n    \"text\": \"herk!(uplo, trans, alpha, A, beta, C)\\n\\nMethods for complex arrays only. Rank-k update of the Hermitian matrix C as alpha*A*A\\' + beta*C or alpha*A\\'*A + beta*C according to trans. Only the uplo triangle of C is updated. Returns C.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.herk\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.herk\",\n    \"category\": \"function\",\n    \"text\": \"herk(uplo, trans, alpha, A)\\n\\nMethods for complex arrays only. Returns the uplo triangle of alpha*A*A\\' or alpha*A\\'*A, according to trans.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gbmv!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.gbmv!\",\n    \"category\": \"function\",\n    \"text\": \"gbmv!(trans, m, kl, ku, alpha, A, x, beta, y)\\n\\nUpdate vector y as alpha*A*x + beta*y or alpha*A\\'*x + beta*y according to trans. The matrix A is a general band matrix of dimension m by size(A,2) with kl sub-diagonals and ku super-diagonals. alpha and beta are scalars. Return the updated y.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gbmv\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.gbmv\",\n    \"category\": \"function\",\n    \"text\": \"gbmv(trans, m, kl, ku, alpha, A, x)\\n\\nReturn alpha*A*x or alpha*A\\'*x according to trans. The matrix A is a general band matrix of dimension m by size(A,2) with kl sub-diagonals and ku super-diagonals, and alpha is a scalar.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.sbmv!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.sbmv!\",\n    \"category\": \"function\",\n    \"text\": \"sbmv!(uplo, k, alpha, A, x, beta, y)\\n\\nUpdate vector y as alpha*A*x + beta*y where A is a a symmetric band matrix of order size(A,2) with k super-diagonals stored in the argument A. The storage layout for A is described the reference BLAS module, level-2 BLAS at http://www.netlib.org/lapack/explore-html/. Only the uplo triangle of A is used.\\n\\nReturn the updated y.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.sbmv-NTuple{5,Any}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.sbmv\",\n    \"category\": \"method\",\n    \"text\": \"sbmv(uplo, k, alpha, A, x)\\n\\nReturn alpha*A*x where A is a symmetric band matrix of order size(A,2) with k super-diagonals stored in the argument A. Only the uplo triangle of A is used.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.sbmv-NTuple{4,Any}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.sbmv\",\n    \"category\": \"method\",\n    \"text\": \"sbmv(uplo, k, A, x)\\n\\nReturn A*x where A is a symmetric band matrix of order size(A,2) with k super-diagonals stored in the argument A. Only the uplo triangle of A is used.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemm!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.gemm!\",\n    \"category\": \"function\",\n    \"text\": \"gemm!(tA, tB, alpha, A, B, beta, C)\\n\\nUpdate C as alpha*A*B + beta*C or the other three variants according to tA and tB. Return the updated C.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemm-NTuple{5,Any}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.gemm\",\n    \"category\": \"method\",\n    \"text\": \"gemm(tA, tB, alpha, A, B)\\n\\nReturn alpha*A*B or the other three variants according to tA and tB.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemm-NTuple{4,Any}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.gemm\",\n    \"category\": \"method\",\n    \"text\": \"gemm(tA, tB, A, B)\\n\\nReturn A*B or the other three variants according to tA and tB.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemv!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.gemv!\",\n    \"category\": \"function\",\n    \"text\": \"gemv!(tA, alpha, A, x, beta, y)\\n\\nUpdate the vector y as alpha*A*x + beta*y or alpha*A\\'x + beta*y according to tA. alpha and beta are scalars. Return the updated y.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemv-NTuple{4,Any}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.gemv\",\n    \"category\": \"method\",\n    \"text\": \"gemv(tA, alpha, A, x)\\n\\nReturn alpha*A*x or alpha*A\\'x according to tA. alpha is a scalar.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.gemv-Tuple{Any,Any,Any}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.gemv\",\n    \"category\": \"method\",\n    \"text\": \"gemv(tA, A, x)\\n\\nReturn A*x or A\\'x according to tA.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.symm!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.symm!\",\n    \"category\": \"function\",\n    \"text\": \"symm!(side, ul, alpha, A, B, beta, C)\\n\\nUpdate C as alpha*A*B + beta*C or alpha*B*A + beta*C according to side. A is assumed to be symmetric. Only the ul triangle of A is used. Return the updated C.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.symm-NTuple{5,Any}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.symm\",\n    \"category\": \"method\",\n    \"text\": \"symm(side, ul, alpha, A, B)\\n\\nReturn alpha*A*B or alpha*B*A according to side. A is assumed to be symmetric. Only the ul triangle of A is used.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.symm-NTuple{4,Any}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.symm\",\n    \"category\": \"method\",\n    \"text\": \"symm(side, ul, A, B)\\n\\nReturn A*B or B*A according to side. A is assumed to be symmetric. Only the ul triangle of A is used.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.symv!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.symv!\",\n    \"category\": \"function\",\n    \"text\": \"symv!(ul, alpha, A, x, beta, y)\\n\\nUpdate the vector y as alpha*A*x + beta*y. A is assumed to be symmetric. Only the ul triangle of A is used. alpha and beta are scalars. Return the updated y.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.symv-NTuple{4,Any}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.symv\",\n    \"category\": \"method\",\n    \"text\": \"symv(ul, alpha, A, x)\\n\\nReturn alpha*A*x. A is assumed to be symmetric. Only the ul triangle of A is used. alpha is a scalar.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.symv-Tuple{Any,Any,Any}\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.symv\",\n    \"category\": \"method\",\n    \"text\": \"symv(ul, A, x)\\n\\nReturn A*x. A is assumed to be symmetric. Only the ul triangle of A is used.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trmm!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.trmm!\",\n    \"category\": \"function\",\n    \"text\": \"trmm!(side, ul, tA, dA, alpha, A, B)\\n\\nUpdate B as alpha*A*B or one of the other three variants determined by side and tA. Only the ul triangle of A is used. dA determines if the diagonal values are read or are assumed to be all ones. Returns the updated B.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trmm\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.trmm\",\n    \"category\": \"function\",\n    \"text\": \"trmm(side, ul, tA, dA, alpha, A, B)\\n\\nReturns alpha*A*B or one of the other three variants determined by side and tA. Only the ul triangle of A is used. dA determines if the diagonal values are read or are assumed to be all ones.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trsm!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.trsm!\",\n    \"category\": \"function\",\n    \"text\": \"trsm!(side, ul, tA, dA, alpha, A, B)\\n\\nOverwrite B with the solution to A*X = alpha*B or one of the other three variants determined by side and tA. Only the ul triangle of A is used. dA determines if the diagonal values are read or are assumed to be all ones. Returns the updated B.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trsm\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.trsm\",\n    \"category\": \"function\",\n    \"text\": \"trsm(side, ul, tA, dA, alpha, A, B)\\n\\nReturn the solution to A*X = alpha*B or one of the other three variants determined by determined by side and tA. Only the ul triangle of A is used. dA determines if the diagonal values are read or are assumed to be all ones.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trmv!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.trmv!\",\n    \"category\": \"function\",\n    \"text\": \"trmv!(ul, tA, dA, A, b)\\n\\nReturn op(A)*b, where op is determined by tA. Only the ul triangle of A is used. dA determines if the diagonal values are read or are assumed to be all ones. The multiplication occurs in-place on b.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trmv\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.trmv\",\n    \"category\": \"function\",\n    \"text\": \"trmv(ul, tA, dA, A, b)\\n\\nReturn op(A)*b, where op is determined by tA. Only the ul triangle of A is used. dA determines if the diagonal values are read or are assumed to be all ones.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trsv!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.trsv!\",\n    \"category\": \"function\",\n    \"text\": \"trsv!(ul, tA, dA, A, b)\\n\\nOverwrite b with the solution to A*x = b or one of the other two variants determined by tA and ul. dA determines if the diagonal values are read or are assumed to be all ones. Return the updated b.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.trsv\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.trsv\",\n    \"category\": \"function\",\n    \"text\": \"trsv(ul, tA, dA, A, b)\\n\\nReturn the solution to A*x = b or one of the other two variants determined by tA and ul. dA determines if the diagonal values are read or are assumed to be all ones.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.BLAS.set_num_threads\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.BLAS.set_num_threads\",\n    \"category\": \"function\",\n    \"text\": \"set_num_threads(n)\\n\\nSet the number of threads the BLAS library should use.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.I\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.I\",\n    \"category\": \"constant\",\n    \"text\": \"I\\n\\nAn object of type UniformScaling, representing an identity matrix of any size.\\n\\nExamples\\n\\njulia> fill(1, (5,6)) * I == fill(1, (5,6))\\ntrue\\n\\njulia> [1 2im 3; 1im 2 3] * I\\n2\u00d73 Array{Complex{Int64},2}:\\n 1+0im  0+2im  3+0im\\n 0+1im  2+0im  3+0im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#stdlib-blas-diag-1\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"Unit Diagonal\",\n    \"category\": \"section\",\n    \"text\": \"diag/dX Meaning\\n\\'N\\' The diagonal values of the matrix X will be read.\\n\\'U\\' The diagonal of the matrix X is assumed to be all ones.LinearAlgebra.BLAS\\nLinearAlgebra.BLAS.dotu\\nLinearAlgebra.BLAS.dotc\\nLinearAlgebra.BLAS.blascopy!\\nLinearAlgebra.BLAS.nrm2\\nLinearAlgebra.BLAS.asum\\nLinearAlgebra.axpy!\\nLinearAlgebra.BLAS.scal!\\nLinearAlgebra.BLAS.scal\\nLinearAlgebra.BLAS.ger!\\nLinearAlgebra.BLAS.syr!\\nLinearAlgebra.BLAS.syrk!\\nLinearAlgebra.BLAS.syrk\\nLinearAlgebra.BLAS.her!\\nLinearAlgebra.BLAS.herk!\\nLinearAlgebra.BLAS.herk\\nLinearAlgebra.BLAS.gbmv!\\nLinearAlgebra.BLAS.gbmv\\nLinearAlgebra.BLAS.sbmv!\\nLinearAlgebra.BLAS.sbmv(::Any, ::Any, ::Any, ::Any, ::Any)\\nLinearAlgebra.BLAS.sbmv(::Any, ::Any, ::Any, ::Any)\\nLinearAlgebra.BLAS.gemm!\\nLinearAlgebra.BLAS.gemm(::Any, ::Any, ::Any, ::Any, ::Any)\\nLinearAlgebra.BLAS.gemm(::Any, ::Any, ::Any, ::Any)\\nLinearAlgebra.BLAS.gemv!\\nLinearAlgebra.BLAS.gemv(::Any, ::Any, ::Any, ::Any)\\nLinearAlgebra.BLAS.gemv(::Any, ::Any, ::Any)\\nLinearAlgebra.BLAS.symm!\\nLinearAlgebra.BLAS.symm(::Any, ::Any, ::Any, ::Any, ::Any)\\nLinearAlgebra.BLAS.symm(::Any, ::Any, ::Any, ::Any)\\nLinearAlgebra.BLAS.symv!\\nLinearAlgebra.BLAS.symv(::Any, ::Any, ::Any, ::Any)\\nLinearAlgebra.BLAS.symv(::Any, ::Any, ::Any)\\nLinearAlgebra.BLAS.trmm!\\nLinearAlgebra.BLAS.trmm\\nLinearAlgebra.BLAS.trsm!\\nLinearAlgebra.BLAS.trsm\\nLinearAlgebra.BLAS.trmv!\\nLinearAlgebra.BLAS.trmv\\nLinearAlgebra.BLAS.trsv!\\nLinearAlgebra.BLAS.trsv\\nLinearAlgebra.BLAS.set_num_threads\\nLinearAlgebra.I\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK\",\n    \"category\": \"module\",\n    \"text\": \"Interfaces to LAPACK subroutines.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gbtrf!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gbtrf!\",\n    \"category\": \"function\",\n    \"text\": \"gbtrf!(kl, ku, m, AB) -> (AB, ipiv)\\n\\nCompute the LU factorization of a banded matrix AB. kl is the first subdiagonal containing a nonzero band, ku is the last superdiagonal containing one, and m is the first dimension of the matrix AB. Returns the LU factorization in-place and ipiv, the vector of pivots used.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gbtrs!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gbtrs!\",\n    \"category\": \"function\",\n    \"text\": \"gbtrs!(trans, kl, ku, m, AB, ipiv, B)\\n\\nSolve the equation AB * X = B. trans determines the orientation of AB. It may be N (no transpose), T (transpose), or C (conjugate transpose). kl is the first subdiagonal containing a nonzero band, ku is the last superdiagonal containing one, and m is the first dimension of the matrix AB. ipiv is the vector of pivots returned from gbtrf!. Returns the vector or matrix X, overwriting B in-place.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gebal!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gebal!\",\n    \"category\": \"function\",\n    \"text\": \"gebal!(job, A) -> (ilo, ihi, scale)\\n\\nBalance the matrix A before computing its eigensystem or Schur factorization. job can be one of N (A will not be permuted or scaled), P (A will only be permuted), S (A will only be scaled), or B (A will be both permuted and scaled). Modifies A in-place and returns ilo, ihi, and scale. If permuting was turned on, A[i,j] = 0 if j > i and 1 < j < ilo or j > ihi. scale contains information about the scaling/permutations performed.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gebak!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gebak!\",\n    \"category\": \"function\",\n    \"text\": \"gebak!(job, side, ilo, ihi, scale, V)\\n\\nTransform the eigenvectors V of a matrix balanced using gebal! to the unscaled/unpermuted eigenvectors of the original matrix. Modifies V in-place. side can be L (left eigenvectors are transformed) or R (right eigenvectors are transformed).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gebrd!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gebrd!\",\n    \"category\": \"function\",\n    \"text\": \"gebrd!(A) -> (A, d, e, tauq, taup)\\n\\nReduce A in-place to bidiagonal form A = QBP\\'. Returns A, containing the bidiagonal matrix B; d, containing the diagonal elements of B; e, containing the off-diagonal elements of B; tauq, containing the elementary reflectors representing Q; and taup, containing the elementary reflectors representing P.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gelqf!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gelqf!\",\n    \"category\": \"function\",\n    \"text\": \"gelqf!(A, tau)\\n\\nCompute the LQ factorization of A, A = LQ. tau contains scalars which parameterize the elementary reflectors of the factorization. tau must have length greater than or equal to the smallest dimension of A.\\n\\nReturns A and tau modified in-place.\\n\\n\\n\\n\\n\\ngelqf!(A) -> (A, tau)\\n\\nCompute the LQ factorization of A, A = LQ.\\n\\nReturns A, modified in-place, and tau, which contains scalars which parameterize the elementary reflectors of the factorization.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geqlf!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.geqlf!\",\n    \"category\": \"function\",\n    \"text\": \"geqlf!(A, tau)\\n\\nCompute the QL factorization of A, A = QL. tau contains scalars which parameterize the elementary reflectors of the factorization. tau must have length greater than or equal to the smallest dimension of A.\\n\\nReturns A and tau modified in-place.\\n\\n\\n\\n\\n\\ngeqlf!(A) -> (A, tau)\\n\\nCompute the QL factorization of A, A = QL.\\n\\nReturns A, modified in-place, and tau, which contains scalars which parameterize the elementary reflectors of the factorization.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geqrf!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.geqrf!\",\n    \"category\": \"function\",\n    \"text\": \"geqrf!(A, tau)\\n\\nCompute the QR factorization of A, A = QR. tau contains scalars which parameterize the elementary reflectors of the factorization. tau must have length greater than or equal to the smallest dimension of A.\\n\\nReturns A and tau modified in-place.\\n\\n\\n\\n\\n\\ngeqrf!(A) -> (A, tau)\\n\\nCompute the QR factorization of A, A = QR.\\n\\nReturns A, modified in-place, and tau, which contains scalars which parameterize the elementary reflectors of the factorization.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geqp3!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.geqp3!\",\n    \"category\": \"function\",\n    \"text\": \"geqp3!(A, jpvt, tau)\\n\\nCompute the pivoted QR factorization of A, AP = QR using BLAS level 3. P is a pivoting matrix, represented by jpvt. tau stores the elementary reflectors. jpvt must have length length greater than or equal to n if A is an (m x n) matrix. tau must have length greater than or equal to the smallest dimension of A.\\n\\nA, jpvt, and tau are modified in-place.\\n\\n\\n\\n\\n\\ngeqp3!(A, jpvt) -> (A, jpvt, tau)\\n\\nCompute the pivoted QR factorization of A, AP = QR using BLAS level 3. P is a pivoting matrix, represented by jpvt. jpvt must have length greater than or equal to n if A is an (m x n) matrix.\\n\\nReturns A and jpvt, modified in-place, and tau, which stores the elementary reflectors.\\n\\n\\n\\n\\n\\ngeqp3!(A) -> (A, jpvt, tau)\\n\\nCompute the pivoted QR factorization of A, AP = QR using BLAS level 3.\\n\\nReturns A, modified in-place, jpvt, which represents the pivoting matrix P, and tau, which stores the elementary reflectors.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gerqf!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gerqf!\",\n    \"category\": \"function\",\n    \"text\": \"gerqf!(A, tau)\\n\\nCompute the RQ factorization of A, A = RQ. tau contains scalars which parameterize the elementary reflectors of the factorization. tau must have length greater than or equal to the smallest dimension of A.\\n\\nReturns A and tau modified in-place.\\n\\n\\n\\n\\n\\ngerqf!(A) -> (A, tau)\\n\\nCompute the RQ factorization of A, A = RQ.\\n\\nReturns A, modified in-place, and tau, which contains scalars which parameterize the elementary reflectors of the factorization.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geqrt!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.geqrt!\",\n    \"category\": \"function\",\n    \"text\": \"geqrt!(A, T)\\n\\nCompute the blocked QR factorization of A, A = QR. T contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization. The first dimension of T sets the block size and it must be between 1 and n. The second dimension of T must equal the smallest dimension of A.\\n\\nReturns A and T modified in-place.\\n\\n\\n\\n\\n\\ngeqrt!(A, nb) -> (A, T)\\n\\nCompute the blocked QR factorization of A, A = QR. nb sets the block size and it must be between 1 and n, the second dimension of A.\\n\\nReturns A, modified in-place, and T, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geqrt3!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.geqrt3!\",\n    \"category\": \"function\",\n    \"text\": \"geqrt3!(A, T)\\n\\nRecursively computes the blocked QR factorization of A, A = QR. T contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.  The first dimension of T sets the block size and it must be between 1 and n. The second dimension of T must equal the smallest dimension of A.\\n\\nReturns A and T modified in-place.\\n\\n\\n\\n\\n\\ngeqrt3!(A) -> (A, T)\\n\\nRecursively computes the blocked QR factorization of A, A = QR.\\n\\nReturns A, modified in-place, and T, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.getrf!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.getrf!\",\n    \"category\": \"function\",\n    \"text\": \"getrf!(A) -> (A, ipiv, info)\\n\\nCompute the pivoted LU factorization of A, A = LU.\\n\\nReturns A, modified in-place, ipiv, the pivoting information, and an info code which indicates success (info = 0), a singular value in U (info = i, in which case U[i,i] is singular), or an error code (info < 0).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.tzrzf!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.tzrzf!\",\n    \"category\": \"function\",\n    \"text\": \"tzrzf!(A) -> (A, tau)\\n\\nTransforms the upper trapezoidal matrix A to upper triangular form in-place. Returns A and tau, the scalar parameters for the elementary reflectors of the transformation.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ormrz!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.ormrz!\",\n    \"category\": \"function\",\n    \"text\": \"ormrz!(side, trans, A, tau, C)\\n\\nMultiplies the matrix C by Q from the transformation supplied by tzrzf!. Depending on side or trans the multiplication can be left-sided (side = L, Q*C) or right-sided (side = R, C*Q) and Q can be unmodified (trans = N), transposed (trans = T), or conjugate transposed (trans = C). Returns matrix C which is modified in-place with the result of the multiplication.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gels!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gels!\",\n    \"category\": \"function\",\n    \"text\": \"gels!(trans, A, B) -> (F, B, ssr)\\n\\nSolves the linear equation A * X = B, transpose(A) * X = B, or adjoint(A) * X = B using a QR or LQ factorization. Modifies the matrix/vector B in place with the solution. A is overwritten with its QR or LQ factorization. trans may be one of N (no modification), T (transpose), or C (conjugate transpose). gels! searches for the minimum norm/least squares solution. A may be under or over determined. The solution is returned in B.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gesv!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gesv!\",\n    \"category\": \"function\",\n    \"text\": \"gesv!(A, B) -> (B, A, ipiv)\\n\\nSolves the linear equation A * X = B where A is a square matrix using the LU factorization of A. A is overwritten with its LU factorization and B is overwritten with the solution X. ipiv contains the pivoting information for the LU factorization of A.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.getrs!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.getrs!\",\n    \"category\": \"function\",\n    \"text\": \"getrs!(trans, A, ipiv, B)\\n\\nSolves the linear equation A * X = B, transpose(A) * X = B, or adjoint(A) * X = B for square A. Modifies the matrix/vector B in place with the solution. A is the LU factorization from getrf!, with ipiv the pivoting information. trans may be one of N (no modification), T (transpose), or C (conjugate transpose).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.getri!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.getri!\",\n    \"category\": \"function\",\n    \"text\": \"getri!(A, ipiv)\\n\\nComputes the inverse of A, using its LU factorization found by getrf!. ipiv is the pivot information output and A contains the LU factorization of getrf!. A is overwritten with its inverse.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gesvx!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gesvx!\",\n    \"category\": \"function\",\n    \"text\": \"gesvx!(fact, trans, A, AF, ipiv, equed, R, C, B) -> (X, equed, R, C, B, rcond, ferr, berr, work)\\n\\nSolves the linear equation A * X = B (trans = N), transpose(A) * X = B (trans = T), or adjoint(A) * X = B (trans = C) using the LU factorization of A. fact may be E, in which case A will be equilibrated and copied to AF; F, in which case AF and ipiv from a previous LU factorization are inputs; or N, in which case A will be copied to AF and then factored. If fact = F, equed may be N, meaning A has not been equilibrated; R, meaning A was multiplied by Diagonal(R) from the left; C, meaning A was multiplied by Diagonal(C) from the right; or B, meaning A was multiplied by Diagonal(R) from the left and Diagonal(C) from the right. If fact = F and equed = R or B the elements of R must all be positive. If fact = F and equed = C or B the elements of C must all be positive.\\n\\nReturns the solution X; equed, which is an output if fact is not N, and describes the equilibration that was performed; R, the row equilibration diagonal; C, the column equilibration diagonal; B, which may be overwritten with its equilibrated form Diagonal(R)*B (if trans = N and equed = R,B) or Diagonal(C)*B (if trans = T,C and equed = C,B); rcond, the reciprocal condition number of A after equilbrating; ferr, the forward error bound for each solution vector in X; berr, the forward error bound for each solution vector in X; and work, the reciprocal pivot growth factor.\\n\\n\\n\\n\\n\\ngesvx!(A, B)\\n\\nThe no-equilibration, no-transpose simplification of gesvx!.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gelsd!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gelsd!\",\n    \"category\": \"function\",\n    \"text\": \"gelsd!(A, B, rcond) -> (B, rnk)\\n\\nComputes the least norm solution of A * X = B by finding the SVD factorization of A, then dividing-and-conquering the problem. B is overwritten with the solution X. Singular values below rcond will be treated as zero. Returns the solution in B and the effective rank of A in rnk.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gelsy!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gelsy!\",\n    \"category\": \"function\",\n    \"text\": \"gelsy!(A, B, rcond) -> (B, rnk)\\n\\nComputes the least norm solution of A * X = B by finding the full QR factorization of A, then dividing-and-conquering the problem. B is overwritten with the solution X. Singular values below rcond will be treated as zero. Returns the solution in B and the effective rank of A in rnk.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gglse!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gglse!\",\n    \"category\": \"function\",\n    \"text\": \"gglse!(A, c, B, d) -> (X,res)\\n\\nSolves the equation A * x = c where x is subject to the equality constraint B * x = d. Uses the formula ||c - A*x||^2 = 0 to solve. Returns X and the residual sum-of-squares.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geev!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.geev!\",\n    \"category\": \"function\",\n    \"text\": \"geev!(jobvl, jobvr, A) -> (W, VL, VR)\\n\\nFinds the eigensystem of A. If jobvl = N, the left eigenvectors of A aren\\'t computed. If jobvr = N, the right eigenvectors of A aren\\'t computed. If jobvl = V or jobvr = V, the corresponding eigenvectors are computed. Returns the eigenvalues in W, the right eigenvectors in VR, and the left eigenvectors in VL.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gesdd!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gesdd!\",\n    \"category\": \"function\",\n    \"text\": \"gesdd!(job, A) -> (U, S, VT)\\n\\nFinds the singular value decomposition of A, A = U * S * V\\', using a divide and conquer approach. If job = A, all the columns of U and the rows of V\\' are computed. If job = N, no columns of U or rows of V\\' are computed. If job = O, A is overwritten with the columns of (thin) U and the rows of (thin) V\\'. If job = S, the columns of (thin) U and the rows of (thin) V\\' are computed and returned separately.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gesvd!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gesvd!\",\n    \"category\": \"function\",\n    \"text\": \"gesvd!(jobu, jobvt, A) -> (U, S, VT)\\n\\nFinds the singular value decomposition of A, A = U * S * V\\'. If jobu = A, all the columns of U are computed. If jobvt = A all the rows of V\\' are computed. If jobu = N, no columns of U are computed. If jobvt = N no rows of V\\' are computed. If jobu = O, A is overwritten with the columns of (thin) U. If jobvt = O, A is overwritten with the rows of (thin) V\\'. If jobu = S, the columns of (thin) U are computed and returned separately. If jobvt = S the rows of (thin) V\\' are computed and returned separately. jobu and jobvt can\\'t both be O.\\n\\nReturns U, S, and Vt, where S are the singular values of A.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ggsvd!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.ggsvd!\",\n    \"category\": \"function\",\n    \"text\": \"ggsvd!(jobu, jobv, jobq, A, B) -> (U, V, Q, alpha, beta, k, l, R)\\n\\nFinds the generalized singular value decomposition of A and B, U\\'*A*Q = D1*R and V\\'*B*Q = D2*R. D1 has alpha on its diagonal and D2 has beta on its diagonal. If jobu = U, the orthogonal/unitary matrix U is computed. If jobv = V the orthogonal/unitary matrix V is computed. If jobq = Q, the orthogonal/unitary matrix Q is computed. If jobu, jobv or jobq is N, that matrix is not computed. This function is only available in LAPACK versions prior to 3.6.0.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ggsvd3!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.ggsvd3!\",\n    \"category\": \"function\",\n    \"text\": \"ggsvd3!(jobu, jobv, jobq, A, B) -> (U, V, Q, alpha, beta, k, l, R)\\n\\nFinds the generalized singular value decomposition of A and B, U\\'*A*Q = D1*R and V\\'*B*Q = D2*R. D1 has alpha on its diagonal and D2 has beta on its diagonal. If jobu = U, the orthogonal/unitary matrix U is computed. If jobv = V the orthogonal/unitary matrix V is computed. If jobq = Q, the orthogonal/unitary matrix Q is computed. If jobu, jobv, or jobq is N, that matrix is not computed. This function requires LAPACK 3.6.0.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.geevx!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.geevx!\",\n    \"category\": \"function\",\n    \"text\": \"geevx!(balanc, jobvl, jobvr, sense, A) -> (A, w, VL, VR, ilo, ihi, scale, abnrm, rconde, rcondv)\\n\\nFinds the eigensystem of A with matrix balancing. If jobvl = N, the left eigenvectors of A aren\\'t computed. If jobvr = N, the right eigenvectors of A aren\\'t computed. If jobvl = V or jobvr = V, the corresponding eigenvectors are computed. If balanc = N, no balancing is performed. If balanc = P, A is permuted but not scaled. If balanc = S, A is scaled but not permuted. If balanc = B, A is permuted and scaled. If sense = N, no reciprocal condition numbers are computed. If sense = E, reciprocal condition numbers are computed for the eigenvalues only. If sense = V, reciprocal condition numbers are computed for the right eigenvectors only. If sense = B, reciprocal condition numbers are computed for the right eigenvectors and the eigenvectors. If sense = E,B, the right and left eigenvectors must be computed.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ggev!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.ggev!\",\n    \"category\": \"function\",\n    \"text\": \"ggev!(jobvl, jobvr, A, B) -> (alpha, beta, vl, vr)\\n\\nFinds the generalized eigendecomposition of A and B. If jobvl = N, the left eigenvectors aren\\'t computed. If jobvr = N, the right eigenvectors aren\\'t computed. If jobvl = V or jobvr = V, the corresponding eigenvectors are computed.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gtsv!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gtsv!\",\n    \"category\": \"function\",\n    \"text\": \"gtsv!(dl, d, du, B)\\n\\nSolves the equation A * X = B where A is a tridiagonal matrix with dl on the subdiagonal, d on the diagonal, and du on the superdiagonal.\\n\\nOverwrites B with the solution X and returns it.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gttrf!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gttrf!\",\n    \"category\": \"function\",\n    \"text\": \"gttrf!(dl, d, du) -> (dl, d, du, du2, ipiv)\\n\\nFinds the LU factorization of a tridiagonal matrix with dl on the subdiagonal, d on the diagonal, and du on the superdiagonal.\\n\\nModifies dl, d, and du in-place and returns them and the second superdiagonal du2 and the pivoting vector ipiv.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gttrs!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gttrs!\",\n    \"category\": \"function\",\n    \"text\": \"gttrs!(trans, dl, d, du, du2, ipiv, B)\\n\\nSolves the equation A * X = B (trans = N), transpose(A) * X = B (trans = T), or adjoint(A) * X = B (trans = C) using the LU factorization computed by gttrf!. B is overwritten with the solution X.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.orglq!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.orglq!\",\n    \"category\": \"function\",\n    \"text\": \"orglq!(A, tau, k = length(tau))\\n\\nExplicitly finds the matrix Q of a LQ factorization after calling gelqf! on A. Uses the output of gelqf!. A is overwritten by Q.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.orgqr!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.orgqr!\",\n    \"category\": \"function\",\n    \"text\": \"orgqr!(A, tau, k = length(tau))\\n\\nExplicitly finds the matrix Q of a QR factorization after calling geqrf! on A. Uses the output of geqrf!. A is overwritten by Q.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.orgql!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.orgql!\",\n    \"category\": \"function\",\n    \"text\": \"orgql!(A, tau, k = length(tau))\\n\\nExplicitly finds the matrix Q of a QL factorization after calling geqlf! on A. Uses the output of geqlf!. A is overwritten by Q.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.orgrq!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.orgrq!\",\n    \"category\": \"function\",\n    \"text\": \"orgrq!(A, tau, k = length(tau))\\n\\nExplicitly finds the matrix Q of a RQ factorization after calling gerqf! on A. Uses the output of gerqf!. A is overwritten by Q.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ormlq!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.ormlq!\",\n    \"category\": \"function\",\n    \"text\": \"ormlq!(side, trans, A, tau, C)\\n\\nComputes Q * C (trans = N), transpose(Q) * C (trans = T), adjoint(Q) * C (trans = C) for side = L or the equivalent right-sided multiplication for side = R using Q from a LQ factorization of A computed using gelqf!. C is overwritten.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ormqr!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.ormqr!\",\n    \"category\": \"function\",\n    \"text\": \"ormqr!(side, trans, A, tau, C)\\n\\nComputes Q * C (trans = N), transpose(Q) * C (trans = T), adjoint(Q) * C (trans = C) for side = L or the equivalent right-sided multiplication for side = R using Q from a QR factorization of A computed using geqrf!. C is overwritten.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ormql!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.ormql!\",\n    \"category\": \"function\",\n    \"text\": \"ormql!(side, trans, A, tau, C)\\n\\nComputes Q * C (trans = N), transpose(Q) * C (trans = T), adjoint(Q) * C (trans = C) for side = L or the equivalent right-sided multiplication for side = R using Q from a QL factorization of A computed using geqlf!. C is overwritten.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ormrq!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.ormrq!\",\n    \"category\": \"function\",\n    \"text\": \"ormrq!(side, trans, A, tau, C)\\n\\nComputes Q * C (trans = N), transpose(Q) * C (trans = T), adjoint(Q) * C (trans = C) for side = L or the equivalent right-sided multiplication for side = R using Q from a RQ factorization of A computed using gerqf!. C is overwritten.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gemqrt!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gemqrt!\",\n    \"category\": \"function\",\n    \"text\": \"gemqrt!(side, trans, V, T, C)\\n\\nComputes Q * C (trans = N), transpose(Q) * C (trans = T), adjoint(Q) * C (trans = C) for side = L or the equivalent right-sided multiplication for side = R using Q from a QR factorization of A computed using geqrt!. C is overwritten.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.posv!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.posv!\",\n    \"category\": \"function\",\n    \"text\": \"posv!(uplo, A, B) -> (A, B)\\n\\nFinds the solution to A * X = B where A is a symmetric or Hermitian positive definite matrix. If uplo = U the upper Cholesky decomposition of A is computed. If uplo = L the lower Cholesky decomposition of A is computed. A is overwritten by its Cholesky decomposition. B is overwritten with the solution X.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.potrf!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.potrf!\",\n    \"category\": \"function\",\n    \"text\": \"potrf!(uplo, A)\\n\\nComputes the Cholesky (upper if uplo = U, lower if uplo = L) decomposition of positive-definite matrix A. A is overwritten and returned with an info code.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.potri!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.potri!\",\n    \"category\": \"function\",\n    \"text\": \"potri!(uplo, A)\\n\\nComputes the inverse of positive-definite matrix A after calling potrf! to find its (upper if uplo = U, lower if uplo = L) Cholesky decomposition.\\n\\nA is overwritten by its inverse and returned.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.potrs!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.potrs!\",\n    \"category\": \"function\",\n    \"text\": \"potrs!(uplo, A, B)\\n\\nFinds the solution to A * X = B where A is a symmetric or Hermitian positive definite matrix whose Cholesky decomposition was computed by potrf!. If uplo = U the upper Cholesky decomposition of A was computed. If uplo = L the lower Cholesky decomposition of A was computed. B is overwritten with the solution X.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.pstrf!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.pstrf!\",\n    \"category\": \"function\",\n    \"text\": \"pstrf!(uplo, A, tol) -> (A, piv, rank, info)\\n\\nComputes the (upper if uplo = U, lower if uplo = L) pivoted Cholesky decomposition of positive-definite matrix A with a user-set tolerance tol. A is overwritten by its Cholesky decomposition.\\n\\nReturns A, the pivots piv, the rank of A, and an info code. If info = 0, the factorization succeeded. If info = i > 0, then A is indefinite or rank-deficient.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.ptsv!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.ptsv!\",\n    \"category\": \"function\",\n    \"text\": \"ptsv!(D, E, B)\\n\\nSolves A * X = B for positive-definite tridiagonal A. D is the diagonal of A and E is the off-diagonal. B is overwritten with the solution X and returned.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.pttrf!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.pttrf!\",\n    \"category\": \"function\",\n    \"text\": \"pttrf!(D, E)\\n\\nComputes the LDLt factorization of a positive-definite tridiagonal matrix with D as diagonal and E as off-diagonal. D and E are overwritten and returned.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.pttrs!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.pttrs!\",\n    \"category\": \"function\",\n    \"text\": \"pttrs!(D, E, B)\\n\\nSolves A * X = B for positive-definite tridiagonal A with diagonal D and off-diagonal E after computing A\\'s LDLt factorization using pttrf!. B is overwritten with the solution X.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trtri!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.trtri!\",\n    \"category\": \"function\",\n    \"text\": \"trtri!(uplo, diag, A)\\n\\nFinds the inverse of (upper if uplo = U, lower if uplo = L) triangular matrix A. If diag = N, A has non-unit diagonal elements. If diag = U, all diagonal elements of A are one. A is overwritten with its inverse.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trtrs!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.trtrs!\",\n    \"category\": \"function\",\n    \"text\": \"trtrs!(uplo, trans, diag, A, B)\\n\\nSolves A * X = B (trans = N), transpose(A) * X = B (trans = T), or adjoint(A) * X = B (trans = C) for (upper if uplo = U, lower if uplo = L) triangular matrix A. If diag = N, A has non-unit diagonal elements. If diag = U, all diagonal elements of A are one. B is overwritten with the solution X.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trcon!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.trcon!\",\n    \"category\": \"function\",\n    \"text\": \"trcon!(norm, uplo, diag, A)\\n\\nFinds the reciprocal condition number of (upper if uplo = U, lower if uplo = L) triangular matrix A. If diag = N, A has non-unit diagonal elements. If diag = U, all diagonal elements of A are one. If norm = I, the condition number is found in the infinity norm. If norm = O or 1, the condition number is found in the one norm.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trevc!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.trevc!\",\n    \"category\": \"function\",\n    \"text\": \"trevc!(side, howmny, select, T, VL = similar(T), VR = similar(T))\\n\\nFinds the eigensystem of an upper triangular matrix T. If side = R, the right eigenvectors are computed. If side = L, the left eigenvectors are computed. If side = B, both sets are computed. If howmny = A, all eigenvectors are found. If howmny = B, all eigenvectors are found and backtransformed using VL and VR. If howmny = S, only the eigenvectors corresponding to the values in select are computed.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trrfs!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.trrfs!\",\n    \"category\": \"function\",\n    \"text\": \"trrfs!(uplo, trans, diag, A, B, X, Ferr, Berr) -> (Ferr, Berr)\\n\\nEstimates the error in the solution to A * X = B (trans = N), transpose(A) * X = B (trans = T), adjoint(A) * X = B (trans = C) for side = L, or the equivalent equations a right-handed side = R X * A after computing X using trtrs!. If uplo = U, A is upper triangular. If uplo = L, A is lower triangular. If diag = N, A has non-unit diagonal elements. If diag = U, all diagonal elements of A are one. Ferr and Berr are optional inputs. Ferr is the forward error and Berr is the backward error, each component-wise.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.stev!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.stev!\",\n    \"category\": \"function\",\n    \"text\": \"stev!(job, dv, ev) -> (dv, Zmat)\\n\\nComputes the eigensystem for a symmetric tridiagonal matrix with dv as diagonal and ev as off-diagonal. If job = N only the eigenvalues are found and returned in dv. If job = V then the eigenvectors are also found and returned in Zmat.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.stebz!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.stebz!\",\n    \"category\": \"function\",\n    \"text\": \"stebz!(range, order, vl, vu, il, iu, abstol, dv, ev) -> (dv, iblock, isplit)\\n\\nComputes the eigenvalues for a symmetric tridiagonal matrix with dv as diagonal and ev as off-diagonal. If range = A, all the eigenvalues are found. If range = V, the eigenvalues in the half-open interval (vl, vu] are found. If range = I, the eigenvalues with indices between il and iu are found. If order = B, eigvalues are ordered within a block. If order = E, they are ordered across all the blocks. abstol can be set as a tolerance for convergence.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.stegr!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.stegr!\",\n    \"category\": \"function\",\n    \"text\": \"stegr!(jobz, range, dv, ev, vl, vu, il, iu) -> (w, Z)\\n\\nComputes the eigenvalues (jobz = N) or eigenvalues and eigenvectors (jobz = V) for a symmetric tridiagonal matrix with dv as diagonal and ev as off-diagonal. If range = A, all the eigenvalues are found. If range = V, the eigenvalues in the half-open interval (vl, vu] are found. If range = I, the eigenvalues with indices between il and iu are found. The eigenvalues are returned in w and the eigenvectors in Z.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.stein!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.stein!\",\n    \"category\": \"function\",\n    \"text\": \"stein!(dv, ev_in, w_in, iblock_in, isplit_in)\\n\\nComputes the eigenvectors for a symmetric tridiagonal matrix with dv as diagonal and ev_in as off-diagonal. w_in specifies the input eigenvalues for which to find corresponding eigenvectors. iblock_in specifies the submatrices corresponding to the eigenvalues in w_in. isplit_in specifies the splitting points between the submatrix blocks.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.syconv!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.syconv!\",\n    \"category\": \"function\",\n    \"text\": \"syconv!(uplo, A, ipiv) -> (A, work)\\n\\nConverts a symmetric matrix A (which has been factorized into a triangular matrix) into two matrices L and D. If uplo = U, A is upper triangular. If uplo = L, it is lower triangular. ipiv is the pivot vector from the triangular factorization. A is overwritten by L and D.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.sysv!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.sysv!\",\n    \"category\": \"function\",\n    \"text\": \"sysv!(uplo, A, B) -> (B, A, ipiv)\\n\\nFinds the solution to A * X = B for symmetric matrix A. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored. B is overwritten by the solution X. A is overwritten by its Bunch-Kaufman factorization. ipiv contains pivoting information about the factorization.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.sytrf!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.sytrf!\",\n    \"category\": \"function\",\n    \"text\": \"sytrf!(uplo, A) -> (A, ipiv, info)\\n\\nComputes the Bunch-Kaufman factorization of a symmetric matrix A. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored.\\n\\nReturns A, overwritten by the factorization, a pivot vector ipiv, and the error code info which is a non-negative integer. If info is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position info.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.sytri!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.sytri!\",\n    \"category\": \"function\",\n    \"text\": \"sytri!(uplo, A, ipiv)\\n\\nComputes the inverse of a symmetric matrix A using the results of sytrf!. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored. A is overwritten by its inverse.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.sytrs!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.sytrs!\",\n    \"category\": \"function\",\n    \"text\": \"sytrs!(uplo, A, ipiv, B)\\n\\nSolves the equation A * X = B for a symmetric matrix A using the results of sytrf!. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored. B is overwritten by the solution X.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.hesv!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.hesv!\",\n    \"category\": \"function\",\n    \"text\": \"hesv!(uplo, A, B) -> (B, A, ipiv)\\n\\nFinds the solution to A * X = B for Hermitian matrix A. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored. B is overwritten by the solution X. A is overwritten by its Bunch-Kaufman factorization. ipiv contains pivoting information about the factorization.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.hetrf!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.hetrf!\",\n    \"category\": \"function\",\n    \"text\": \"hetrf!(uplo, A) -> (A, ipiv, info)\\n\\nComputes the Bunch-Kaufman factorization of a Hermitian matrix A. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored.\\n\\nReturns A, overwritten by the factorization, a pivot vector ipiv, and the error code info which is a non-negative integer. If info is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position info.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.hetri!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.hetri!\",\n    \"category\": \"function\",\n    \"text\": \"hetri!(uplo, A, ipiv)\\n\\nComputes the inverse of a Hermitian matrix A using the results of sytrf!. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored. A is overwritten by its inverse.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.hetrs!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.hetrs!\",\n    \"category\": \"function\",\n    \"text\": \"hetrs!(uplo, A, ipiv, B)\\n\\nSolves the equation A * X = B for a Hermitian matrix A using the results of sytrf!. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored. B is overwritten by the solution X.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.syev!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.syev!\",\n    \"category\": \"function\",\n    \"text\": \"syev!(jobz, uplo, A)\\n\\nFinds the eigenvalues (jobz = N) or eigenvalues and eigenvectors (jobz = V) of a symmetric matrix A. If uplo = U, the upper triangle of A is used. If uplo = L, the lower triangle of A is used.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.syevr!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.syevr!\",\n    \"category\": \"function\",\n    \"text\": \"syevr!(jobz, range, uplo, A, vl, vu, il, iu, abstol) -> (W, Z)\\n\\nFinds the eigenvalues (jobz = N) or eigenvalues and eigenvectors (jobz = V) of a symmetric matrix A. If uplo = U, the upper triangle of A is used. If uplo = L, the lower triangle of A is used. If range = A, all the eigenvalues are found. If range = V, the eigenvalues in the half-open interval (vl, vu] are found. If range = I, the eigenvalues with indices between il and iu are found. abstol can be set as a tolerance for convergence.\\n\\nThe eigenvalues are returned in W and the eigenvectors in Z.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.sygvd!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.sygvd!\",\n    \"category\": \"function\",\n    \"text\": \"sygvd!(itype, jobz, uplo, A, B) -> (w, A, B)\\n\\nFinds the generalized eigenvalues (jobz = N) or eigenvalues and eigenvectors (jobz = V) of a symmetric matrix A and symmetric positive-definite matrix B. If uplo = U, the upper triangles of A and B are used. If uplo = L, the lower triangles of A and B are used. If itype = 1, the problem to solve is A * x = lambda * B * x. If itype = 2, the problem to solve is A * B * x = lambda * x. If itype = 3, the problem to solve is B * A * x = lambda * x.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.bdsqr!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.bdsqr!\",\n    \"category\": \"function\",\n    \"text\": \"bdsqr!(uplo, d, e_, Vt, U, C) -> (d, Vt, U, C)\\n\\nComputes the singular value decomposition of a bidiagonal matrix with d on the diagonal and e_ on the off-diagonal. If uplo = U, e_ is the superdiagonal. If uplo = L, e_ is the subdiagonal. Can optionally also compute the product Q\\' * C.\\n\\nReturns the singular values in d, and the matrix C overwritten with Q\\' * C.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.bdsdc!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.bdsdc!\",\n    \"category\": \"function\",\n    \"text\": \"bdsdc!(uplo, compq, d, e_) -> (d, e, u, vt, q, iq)\\n\\nComputes the singular value decomposition of a bidiagonal matrix with d on the diagonal and e_ on the off-diagonal using a divide and conqueq method. If uplo = U, e_ is the superdiagonal. If uplo = L, e_ is the subdiagonal. If compq = N, only the singular values are found. If compq = I, the singular values and vectors are found. If compq = P, the singular values and vectors are found in compact form. Only works for real types.\\n\\nReturns the singular values in d, and if compq = P, the compact singular vectors in iq.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gecon!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gecon!\",\n    \"category\": \"function\",\n    \"text\": \"gecon!(normtype, A, anorm)\\n\\nFinds the reciprocal condition number of matrix A. If normtype = I, the condition number is found in the infinity norm. If normtype = O or 1, the condition number is found in the one norm. A must be the result of getrf! and anorm is the norm of A in the relevant norm.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gehrd!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gehrd!\",\n    \"category\": \"function\",\n    \"text\": \"gehrd!(ilo, ihi, A) -> (A, tau)\\n\\nConverts a matrix A to Hessenberg form. If A is balanced with gebal! then ilo and ihi are the outputs of gebal!. Otherwise they should be ilo = 1 and ihi = size(A,2). tau contains the elementary reflectors of the factorization.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.orghr!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.orghr!\",\n    \"category\": \"function\",\n    \"text\": \"orghr!(ilo, ihi, A, tau)\\n\\nExplicitly finds Q, the orthogonal/unitary matrix from gehrd!. ilo, ihi, A, and tau must correspond to the input/output to gehrd!.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gees!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gees!\",\n    \"category\": \"function\",\n    \"text\": \"gees!(jobvs, A) -> (A, vs, w)\\n\\nComputes the eigenvalues (jobvs = N) or the eigenvalues and Schur vectors (jobvs = V) of matrix A. A is overwritten by its Schur form.\\n\\nReturns A, vs containing the Schur vectors, and w, containing the eigenvalues.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.gges!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.gges!\",\n    \"category\": \"function\",\n    \"text\": \"gges!(jobvsl, jobvsr, A, B) -> (A, B, alpha, beta, vsl, vsr)\\n\\nComputes the generalized eigenvalues, generalized Schur form, left Schur vectors (jobsvl = V), or right Schur vectors (jobvsr = V) of A and B.\\n\\nThe generalized eigenvalues are returned in alpha and beta. The left Schur vectors are returned in vsl and the right Schur vectors are returned in vsr.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trexc!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.trexc!\",\n    \"category\": \"function\",\n    \"text\": \"trexc!(compq, ifst, ilst, T, Q) -> (T, Q)\\n\\nReorder the Schur factorization of a matrix. If compq = V, the Schur vectors Q are reordered. If compq = N they are not modified. ifst and ilst specify the reordering of the vectors.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trsen!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.trsen!\",\n    \"category\": \"function\",\n    \"text\": \"trsen!(compq, job, select, T, Q) -> (T, Q, w, s, sep)\\n\\nReorder the Schur factorization of a matrix and optionally finds reciprocal condition numbers. If job = N, no condition numbers are found. If job = E, only the condition number for this cluster of eigenvalues is found. If job = V, only the condition number for the invariant subspace is found. If job = B then the condition numbers for the cluster and subspace are found. If compq = V the Schur vectors Q are updated. If compq = N the Schur vectors are not modified. select determines which eigenvalues are in the cluster.\\n\\nReturns T, Q, reordered eigenvalues in w, the condition number of the cluster of eigenvalues s, and the condition number of the invariant subspace sep.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.tgsen!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.tgsen!\",\n    \"category\": \"function\",\n    \"text\": \"tgsen!(select, S, T, Q, Z) -> (S, T, alpha, beta, Q, Z)\\n\\nReorders the vectors of a generalized Schur decomposition. select specifies the eigenvalues in each cluster.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LinearAlgebra.LAPACK.trsyl!\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LinearAlgebra.LAPACK.trsyl!\",\n    \"category\": \"function\",\n    \"text\": \"trsyl!(transa, transb, A, B, C, isgn=1) -> (C, scale)\\n\\nSolves the Sylvester matrix equation A * X +/- X * B = scale*C where A and B are both quasi-upper triangular. If transa = N, A is not modified. If transa = T, A is transposed. If transa = C, A is conjugate transposed. Similarly for transb and B. If isgn = 1, the equation A * X + X * B = scale * C is solved. If isgn = -1, the equation A * X - X * B = scale * C is solved.\\n\\nReturns X (overwriting C) and scale.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/LinearAlgebra.html#LAPACK-Functions-1\",\n    \"page\": \"Linear Algebra\",\n    \"title\": \"LAPACK Functions\",\n    \"category\": \"section\",\n    \"text\": \"LinearAlgebra.LAPACK provides wrappers for some of the LAPACK functions for linear algebra.  Those functions that overwrite one of the input arrays have names ending in \\'!\\'.Usually a function has 4 methods defined, one each for Float64, Float32, ComplexF64 and ComplexF32 arrays.Note that the LAPACK API provided by Julia can and will change in the future. Since this API is not user-facing, there is no commitment to support/deprecate this specific set of functions in future releases.LinearAlgebra.LAPACK\\nLinearAlgebra.LAPACK.gbtrf!\\nLinearAlgebra.LAPACK.gbtrs!\\nLinearAlgebra.LAPACK.gebal!\\nLinearAlgebra.LAPACK.gebak!\\nLinearAlgebra.LAPACK.gebrd!\\nLinearAlgebra.LAPACK.gelqf!\\nLinearAlgebra.LAPACK.geqlf!\\nLinearAlgebra.LAPACK.geqrf!\\nLinearAlgebra.LAPACK.geqp3!\\nLinearAlgebra.LAPACK.gerqf!\\nLinearAlgebra.LAPACK.geqrt!\\nLinearAlgebra.LAPACK.geqrt3!\\nLinearAlgebra.LAPACK.getrf!\\nLinearAlgebra.LAPACK.tzrzf!\\nLinearAlgebra.LAPACK.ormrz!\\nLinearAlgebra.LAPACK.gels!\\nLinearAlgebra.LAPACK.gesv!\\nLinearAlgebra.LAPACK.getrs!\\nLinearAlgebra.LAPACK.getri!\\nLinearAlgebra.LAPACK.gesvx!\\nLinearAlgebra.LAPACK.gelsd!\\nLinearAlgebra.LAPACK.gelsy!\\nLinearAlgebra.LAPACK.gglse!\\nLinearAlgebra.LAPACK.geev!\\nLinearAlgebra.LAPACK.gesdd!\\nLinearAlgebra.LAPACK.gesvd!\\nLinearAlgebra.LAPACK.ggsvd!\\nLinearAlgebra.LAPACK.ggsvd3!\\nLinearAlgebra.LAPACK.geevx!\\nLinearAlgebra.LAPACK.ggev!\\nLinearAlgebra.LAPACK.gtsv!\\nLinearAlgebra.LAPACK.gttrf!\\nLinearAlgebra.LAPACK.gttrs!\\nLinearAlgebra.LAPACK.orglq!\\nLinearAlgebra.LAPACK.orgqr!\\nLinearAlgebra.LAPACK.orgql!\\nLinearAlgebra.LAPACK.orgrq!\\nLinearAlgebra.LAPACK.ormlq!\\nLinearAlgebra.LAPACK.ormqr!\\nLinearAlgebra.LAPACK.ormql!\\nLinearAlgebra.LAPACK.ormrq!\\nLinearAlgebra.LAPACK.gemqrt!\\nLinearAlgebra.LAPACK.posv!\\nLinearAlgebra.LAPACK.potrf!\\nLinearAlgebra.LAPACK.potri!\\nLinearAlgebra.LAPACK.potrs!\\nLinearAlgebra.LAPACK.pstrf!\\nLinearAlgebra.LAPACK.ptsv!\\nLinearAlgebra.LAPACK.pttrf!\\nLinearAlgebra.LAPACK.pttrs!\\nLinearAlgebra.LAPACK.trtri!\\nLinearAlgebra.LAPACK.trtrs!\\nLinearAlgebra.LAPACK.trcon!\\nLinearAlgebra.LAPACK.trevc!\\nLinearAlgebra.LAPACK.trrfs!\\nLinearAlgebra.LAPACK.stev!\\nLinearAlgebra.LAPACK.stebz!\\nLinearAlgebra.LAPACK.stegr!\\nLinearAlgebra.LAPACK.stein!\\nLinearAlgebra.LAPACK.syconv!\\nLinearAlgebra.LAPACK.sysv!\\nLinearAlgebra.LAPACK.sytrf!\\nLinearAlgebra.LAPACK.sytri!\\nLinearAlgebra.LAPACK.sytrs!\\nLinearAlgebra.LAPACK.hesv!\\nLinearAlgebra.LAPACK.hetrf!\\nLinearAlgebra.LAPACK.hetri!\\nLinearAlgebra.LAPACK.hetrs!\\nLinearAlgebra.LAPACK.syev!\\nLinearAlgebra.LAPACK.syevr!\\nLinearAlgebra.LAPACK.sygvd!\\nLinearAlgebra.LAPACK.bdsqr!\\nLinearAlgebra.LAPACK.bdsdc!\\nLinearAlgebra.LAPACK.gecon!\\nLinearAlgebra.LAPACK.gehrd!\\nLinearAlgebra.LAPACK.orghr!\\nLinearAlgebra.LAPACK.gees!\\nLinearAlgebra.LAPACK.gges!\\nLinearAlgebra.LAPACK.trexc!\\nLinearAlgebra.LAPACK.trsen!\\nLinearAlgebra.LAPACK.tgsen!\\nLinearAlgebra.LAPACK.trsyl!DocTestSetup = nothing\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#\",\n    \"page\": \"Logging\",\n    \"title\": \"Logging\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Logging-1\",\n    \"page\": \"Logging\",\n    \"title\": \"Logging\",\n    \"category\": \"section\",\n    \"text\": \"The Logging module provides a way to record the history and progress of a computation as a log of events.  Events are created by inserting a logging statement into the source code, for example:@warn \\\"Abandon printf debugging, all ye who enter here!\\\"\\n\u250c Warning: Abandon printf debugging, all ye who enter here!\\n\u2514 @ Main REPL[1]:1The system provides several advantages over peppering your source code with calls to println().  First, it allows you to control the visibility and presentation of messages without editing the source code.  For example, in contrast to the @warn above@debug \\\"The sum of some values $(sum(rand(100)))\\\"will produce no output by default.  Furthermore, it\\'s very cheap to leave debug statements like this in the source code because the system avoids evaluating the message if it would later be ignored.  In this case sum(rand(100)) and the associated string processing will never be executed unless debug logging is enabled.Second, the logging tools allow you to attach arbitrary data to each event as a set of key\u2013value pairs. This allows you to capture local variables and other program state for later analysis. For example, to attach the local array variable A and the sum of a vector v as the key s you can useA = ones(Int, 4, 4)\\nv = ones(100)\\n@info \\\"Some variables\\\"  A  s=sum(v)\\n\\n# output\\n\u250c Info: Some variables\\n\u2502   A =\\n\u2502    4\u00d74 Array{Int64,2}:\\n\u2502     1  1  1  1\\n\u2502     1  1  1  1\\n\u2502     1  1  1  1\\n\u2502     1  1  1  1\\n\u2514   s = 100.0All of the logging macros @debug, @info, @warn and @error share common features that are described in detail in the documentation for the more general macro @logmsg.\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Log-event-structure-1\",\n    \"page\": \"Logging\",\n    \"title\": \"Log event structure\",\n    \"category\": \"section\",\n    \"text\": \"Each event generates several pieces of data, some provided by the user and some automatically extracted. Let\\'s examine the user-defined data first:The log level is a broad category for the message that is used for early filtering. There are several standard levels of type LogLevel; user-defined levels are also possible.\\nUse Debug for verbose information that could be useful when debugging an application or module. These events are disabled by default.\\nUse Info to inform the user about the normal operation of the program.\\nUse Warn when a potential problem is detected.\\nUse Error to report errors where the code has enough context to recover and continue.  (When the code doesn\\'t have enough context, an exception or early return is more appropriate.)\\nThe message  is an object describing the event. By convention AbstractStrings passed as messages are assumed to be in markdown format. Other types will be displayed using show(io,mime,obj) according to the display capabilities of the installed logger.\\nOptional key\u2013value pairs allow arbitrary data to be attached to each event. Some keys have conventional meaning that can affect the way an event is interpreted (see @logmsg).The system also generates some standard information for each event:The module in which the logging macro was expanded.\\nThe file and line where the logging macro occurs in the source code.\\nA message id that is unique for each logging macro invocation. This is very useful as a key for caching information or actions associated with an event. For instance, it can be used to limit the number of times a message is presented to the user.\\nA group for the event, which is set to the base name of the file by default, without extension.  This can be used to group messages into categories more finely than the log level (for example, all deprecation warnings have group :depwarn), or into logical groupings across or within modules.Notice that some useful information such as the event time is not included by default. This is because such information can be expensive to extract and is also dynamically available to the current logger. It\\'s simple to define a custom logger to augment event data with the time, backtrace, values of global variables and other useful information as required.\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Processing-log-events-1\",\n    \"page\": \"Logging\",\n    \"title\": \"Processing log events\",\n    \"category\": \"section\",\n    \"text\": \"As you can see in the examples, logging statements make no mention of where log events go or how they are processed. This is a key design feature that makes the system composable and natural for concurrent use. It does this by separating two different concerns:Creating log events is the concern of the module author who needs to decide where events are triggered and which information to include.\\nProcessing of log events \u2014 that is, display, filtering, aggregation and recording \u2014 is the concern of the application author who needs to bring multiple modules together into a cooperating application.\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Loggers-1\",\n    \"page\": \"Logging\",\n    \"title\": \"Loggers\",\n    \"category\": \"section\",\n    \"text\": \"Processing of events is performed by a logger, which is the first piece of user configurable code to see the event. All loggers must be subtypes of AbstractLogger.When an event is triggered, the appropriate logger is found by looking for a task-local logger with the global logger as fallback.  The idea here is that the application code knows how log events should be processed and exists somewhere at the top of the call stack. So we should look up through the call stack to discover the logger \u2014 that is, the logger should be dynamically scoped. (This is a point of contrast with logging frameworks where the logger is lexically scoped; provided explicitly by the module author or as a simple global variable. In such a system it\\'s awkward to control logging while composing functionality from multiple modules.)The global logger may be set with global_logger, and task-local loggers controlled using with_logger.  Newly spawned tasks inherit the logger of the parent task.There are three logger types provided by the library.  ConsoleLogger is the default logger you see when starting the REPL.  It displays events in a readable text format and tries to give simple but user friendly control over formatting and filtering.  NullLogger is a convenient way to drop all messages where necessary; it is the logging equivalent of the devnull stream.  SimpleLogger is a very simplistic text formatting logger, mainly useful for debugging the logging system itself.Custom loggers should come with overloads for the functions described in the reference section.\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Early-filtering-and-message-handling-1\",\n    \"page\": \"Logging\",\n    \"title\": \"Early filtering and message handling\",\n    \"category\": \"section\",\n    \"text\": \"When an event occurs, a few steps of early filtering occur to avoid generating messages that will be discarded:The message log level is checked against a global minimum level (set via disable_logging).  This is a crude but extremely cheap global setting.\\nThe current logger state is looked up and the message level checked against the logger\\'s cached minimum level, as found by calling Logging.min_enabled_level. This behavior can be overridden via environment variables (more on this later).\\nThe Logging.shouldlog function is called with the current logger, taking some minimal information (level, module, group, id) which can be computed statically.  Most usefully, shouldlog is passed an event id which can be used to discard events early based on a cached predicate.If all these checks pass, the message and key\u2013value pairs are evaluated in full and passed to the current logger via the Logging.handle_message function. handle_message() may perform additional filtering as required and display the event to the screen, save it to a file, etc.Exceptions that occur while generating the log event are captured and logged by default.  This prevents individual broken events from crashing the application, which is helpful when enabling little-used debug events in a production system.  This behavior can be customized per logger type by extending Logging.catch_exceptions.\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Testing-log-events-1\",\n    \"page\": \"Logging\",\n    \"title\": \"Testing log events\",\n    \"category\": \"section\",\n    \"text\": \"Log events are a side effect of running normal code, but you might find yourself wanting to test particular informational messages and warnings. The Test module provides a @test_logs macro that can be used to pattern match against the log event stream.\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Environment-variables-1\",\n    \"page\": \"Logging\",\n    \"title\": \"Environment variables\",\n    \"category\": \"section\",\n    \"text\": \"Message filtering can be influenced through the JULIA_DEBUG environment variable, and serves as an easy way to enable debug logging for a file or module. For example, loading julia with JULIA_DEBUG=loading will activate @debug log messages in loading.jl:$ JULIA_DEBUG=loading julia -e \\'using OhMyREPL\\'\\n\u250c Debug: Rejecting cache file /home/user/.julia/compiled/v0.7/OhMyREPL.ji due to it containing an invalid cache header\\n\u2514 @ Base loading.jl:1328\\n[ Info: Recompiling stale cache file /home/user/.julia/compiled/v0.7/OhMyREPL.ji for module OhMyREPL\\n\u250c Debug: Rejecting cache file /home/user/.julia/compiled/v0.7/Tokenize.ji due to it containing an invalid cache header\\n\u2514 @ Base loading.jl:1328\\n...Similarly, the environment variable can be used to enable debug logging of modules, such as Pkg, or module roots (see Base.moduleroot). To enable all debug logging, use the special value all.\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Reference-1\",\n    \"page\": \"Logging\",\n    \"title\": \"Reference\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Base.CoreLogging.@logmsg\",\n    \"page\": \"Logging\",\n    \"title\": \"Base.CoreLogging.@logmsg\",\n    \"category\": \"macro\",\n    \"text\": \"@debug message  [key=value | value ...]\\n@info  message  [key=value | value ...]\\n@warn  message  [key=value | value ...]\\n@error message  [key=value | value ...]\\n\\n@logmsg level message [key=value | value ...]\\n\\nCreate a log record with an informational message.  For convenience, four logging macros @debug, @info, @warn and @error are defined which log at the standard severity levels Debug, Info, Warn and Error.  @logmsg allows level to be set programmatically to any LogLevel or custom log level types.\\n\\nmessage should be an expression which evaluates to a string which is a human readable description of the log event.  By convention, this string will be formatted as markdown when presented.\\n\\nThe optional list of key=value pairs supports arbitrary user defined metadata which will be passed through to the logging backend as part of the log record.  If only a value expression is supplied, a key representing the expression will be generated using Symbol. For example, x becomes x=x, and foo(10) becomes Symbol(\\\"foo(10)\\\")=foo(10).  For splatting a list of key value pairs, use the normal splatting syntax, @info \\\"blah\\\" kws....\\n\\nThere are some keys which allow automatically generated log data to be overridden:\\n\\n_module=mod can be used to specify a different originating module from the source location of the message.\\n_group=symbol can be used to override the message group (this is normally derived from the base name of the source file).\\n_id=symbol can be used to override the automatically generated unique message identifier.  This is useful if you need to very closely associate messages generated on different source lines.\\n_file=string and _line=integer can be used to override the apparent source location of a log message.\\n\\nThere\\'s also some key value pairs which have conventional meaning:\\n\\nmaxlog=integer should be used as a hint to the backend that the message should be displayed no more than maxlog times.\\nexception=ex should be used to transport an exception with a log message, often used with @error. An associated backtrace bt may be attached using the tuple exception=(ex,bt).\\n\\nExamples\\n\\n@debug \\\"Verbose debugging information.  Invisible by default\\\"\\n@info  \\\"An informational message\\\"\\n@warn  \\\"Something was odd.  You should pay attention\\\"\\n@error \\\"A non fatal error occurred\\\"\\n\\nx = 10\\n@info \\\"Some variables attached to the message\\\" x a=42.0\\n\\n@debug begin\\n    sA = sum(A)\\n    \\\"sum(A) = $sA is an expensive operation, evaluated only when `shouldlog` returns true\\\"\\nend\\n\\nfor i=1:10000\\n    @info \\\"With the default backend, you will only see (i = $i) ten times\\\"  maxlog=10\\n    @debug \\\"Algorithm1\\\" i progress=i/10000\\nend\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Base.CoreLogging.LogLevel\",\n    \"page\": \"Logging\",\n    \"title\": \"Base.CoreLogging.LogLevel\",\n    \"category\": \"type\",\n    \"text\": \"LogLevel(level)\\n\\nSeverity/verbosity of a log record.\\n\\nThe log level provides a key against which potential log records may be filtered, before any other work is done to construct the log record data structure itself.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Creating-events-1\",\n    \"page\": \"Logging\",\n    \"title\": \"Creating events\",\n    \"category\": \"section\",\n    \"text\": \"Logging.@logmsg\\nLogging.LogLevel\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Base.CoreLogging.AbstractLogger\",\n    \"page\": \"Logging\",\n    \"title\": \"Base.CoreLogging.AbstractLogger\",\n    \"category\": \"type\",\n    \"text\": \"A logger controls how log records are filtered and dispatched.  When a log record is generated, the logger is the first piece of user configurable code which gets to inspect the record and decide what to do with it.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Base.CoreLogging.handle_message\",\n    \"page\": \"Logging\",\n    \"title\": \"Base.CoreLogging.handle_message\",\n    \"category\": \"function\",\n    \"text\": \"handle_message(logger, level, message, _module, group, id, file, line; key1=val1, ...)\\n\\nLog a message to logger at level.  The logical location at which the message was generated is given by module _module and group; the source location by file and line. id is an arbitrary unique Symbol to be used as a key to identify the log statement when filtering.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Base.CoreLogging.shouldlog\",\n    \"page\": \"Logging\",\n    \"title\": \"Base.CoreLogging.shouldlog\",\n    \"category\": \"function\",\n    \"text\": \"shouldlog(logger, level, _module, group, id)\\n\\nReturn true when logger accepts a message at level, generated for _module, group and with unique log identifier id.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Base.CoreLogging.min_enabled_level\",\n    \"page\": \"Logging\",\n    \"title\": \"Base.CoreLogging.min_enabled_level\",\n    \"category\": \"function\",\n    \"text\": \"min_enabled_level(logger)\\n\\nReturn the maximum disabled level for logger for early filtering.  That is, the log level below or equal to which all messages are filtered.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Base.CoreLogging.catch_exceptions\",\n    \"page\": \"Logging\",\n    \"title\": \"Base.CoreLogging.catch_exceptions\",\n    \"category\": \"function\",\n    \"text\": \"catch_exceptions(logger)\\n\\nReturn true if the logger should catch exceptions which happen during log record construction.  By default, messages are caught\\n\\nBy default all exceptions are caught to prevent log message generation from crashing the program.  This lets users confidently toggle little-used functionality - such as debug logging - in a production system.\\n\\nIf you want to use logging as an audit trail you should disable this for your logger type.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Base.CoreLogging.disable_logging\",\n    \"page\": \"Logging\",\n    \"title\": \"Base.CoreLogging.disable_logging\",\n    \"category\": \"function\",\n    \"text\": \"disable_logging(level)\\n\\nDisable all log messages at log levels equal to or less than level.  This is a global setting, intended to make debug logging extremely cheap when disabled.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#AbstractLogger-interface-1\",\n    \"page\": \"Logging\",\n    \"title\": \"Processing events with AbstractLogger\",\n    \"category\": \"section\",\n    \"text\": \"Event processing is controlled by overriding functions associated with AbstractLogger:Methods to implement  Brief description\\nLogging.handle_message  Handle a log event\\nLogging.shouldlog  Early filtering of events\\nLogging.min_enabled_level  Lower bound for log level of accepted events\\nOptional methods Default definition Brief description\\nLogging.catch_exceptions true Catch exceptions during event evaluationLogging.AbstractLogger\\nLogging.handle_message\\nLogging.shouldlog\\nLogging.min_enabled_level\\nLogging.catch_exceptions\\nLogging.disable_logging\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Base.CoreLogging.global_logger\",\n    \"page\": \"Logging\",\n    \"title\": \"Base.CoreLogging.global_logger\",\n    \"category\": \"function\",\n    \"text\": \"global_logger()\\n\\nReturn the global logger, used to receive messages when no specific logger exists for the current task.\\n\\nglobal_logger(logger)\\n\\nSet the global logger to logger, and return the previous global logger.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Base.CoreLogging.with_logger\",\n    \"page\": \"Logging\",\n    \"title\": \"Base.CoreLogging.with_logger\",\n    \"category\": \"function\",\n    \"text\": \"with_logger(function, logger)\\n\\nExecute function, directing all log messages to logger.\\n\\nExample\\n\\nfunction test(x)\\n    @info \\\"x = $x\\\"\\nend\\n\\nwith_logger(logger) do\\n    test(1)\\n    test([1,2])\\nend\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Base.CoreLogging.current_logger\",\n    \"page\": \"Logging\",\n    \"title\": \"Base.CoreLogging.current_logger\",\n    \"category\": \"function\",\n    \"text\": \"current_logger()\\n\\nReturn the logger for the current task, or the global logger if none is is attached to the task.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Base.CoreLogging.NullLogger\",\n    \"page\": \"Logging\",\n    \"title\": \"Base.CoreLogging.NullLogger\",\n    \"category\": \"type\",\n    \"text\": \"NullLogger()\\n\\nLogger which disables all messages and produces no output - the logger equivalent of /dev/null.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Logging.ConsoleLogger\",\n    \"page\": \"Logging\",\n    \"title\": \"Logging.ConsoleLogger\",\n    \"category\": \"type\",\n    \"text\": \"ConsoleLogger(stream=stderr, min_level=Info; meta_formatter=default_metafmt,\\n              show_limited=true, right_justify=0)\\n\\nLogger with formatting optimized for readability in a text console, for example interactive work with the Julia REPL.\\n\\nLog levels less than min_level are filtered out.\\n\\nMessage formatting can be controlled by setting keyword arguments:\\n\\nmeta_formatter is a function which takes the log event metadata (level, _module, group, id, file, line) and returns a color (as would be passed to printstyled), prefix and suffix for the log message.  The default is to prefix with the log level and a suffix containing the module, file and line location.\\nshow_limited limits the printing of large data structures to something which can fit on the screen by setting the :limit IOContext key during formatting.\\nright_justify is the integer column which log metadata is right justified at. The default is zero (metadata goes on its own line).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Base.CoreLogging.SimpleLogger\",\n    \"page\": \"Logging\",\n    \"title\": \"Base.CoreLogging.SimpleLogger\",\n    \"category\": \"type\",\n    \"text\": \"SimpleLogger(stream=stderr, min_level=Info)\\n\\nSimplistic logger for logging all messages with level greater than or equal to min_level to stream.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Logging.html#Using-Loggers-1\",\n    \"page\": \"Logging\",\n    \"title\": \"Using Loggers\",\n    \"category\": \"section\",\n    \"text\": \"Logger installation and inspection:Logging.global_logger\\nLogging.with_logger\\nLogging.current_loggerLoggers that are supplied with the system:Logging.NullLogger\\nLogging.ConsoleLogger\\nLogging.SimpleLogger\"\n},\n\n{\n    \"location\": \"stdlib/Markdown.html#\",\n    \"page\": \"Markdown\",\n    \"title\": \"Markdown\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Markdown.html#Markdown-1\",\n    \"page\": \"Markdown\",\n    \"title\": \"Markdown\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Mmap.html#\",\n    \"page\": \"Memory-mapped I/O\",\n    \"title\": \"Memory-mapped I/O\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Mmap.html#Mmap.Anonymous\",\n    \"page\": \"Memory-mapped I/O\",\n    \"title\": \"Mmap.Anonymous\",\n    \"category\": \"type\",\n    \"text\": \"Mmap.Anonymous(name::AbstractString=\\\"\\\", readonly::Bool=false, create::Bool=true)\\n\\nCreate an IO-like object for creating zeroed-out mmapped-memory that is not tied to a file for use in Mmap.mmap. Used by SharedArray for creating shared memory arrays.\\n\\nExamples\\n\\njulia> anon = Mmap.Anonymous();\\n\\njulia> isreadable(anon)\\ntrue\\n\\njulia> iswritable(anon)\\ntrue\\n\\njulia> isopen(anon)\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Mmap.html#Mmap.mmap\",\n    \"page\": \"Memory-mapped I/O\",\n    \"title\": \"Mmap.mmap\",\n    \"category\": \"function\",\n    \"text\": \"Mmap.mmap(io::Union{IOStream,AbstractString,Mmap.AnonymousMmap}[, type::Type{Array{T,N}}, dims, offset]; grow::Bool=true, shared::Bool=true)\\n       Mmap.mmap(type::Type{Array{T,N}}, dims)\\n\\nCreate an Array whose values are linked to a file, using memory-mapping. This provides a convenient way of working with data too large to fit in the computer\\'s memory.\\n\\nThe type is an Array{T,N} with a bits-type element of T and dimension N that determines how the bytes of the array are interpreted. Note that the file must be stored in binary format, and no format conversions are possible (this is a limitation of operating systems, not Julia).\\n\\ndims is a tuple or single Integer specifying the size or length of the array.\\n\\nThe file is passed via the stream argument, either as an open IOStream or filename string. When you initialize the stream, use \\\"r\\\" for a \\\"read-only\\\" array, and \\\"w+\\\" to create a new array used to write values to disk.\\n\\nIf no type argument is specified, the default is Vector{UInt8}.\\n\\nOptionally, you can specify an offset (in bytes) if, for example, you want to skip over a header in the file. The default value for the offset is the current stream position for an IOStream.\\n\\nThe grow keyword argument specifies whether the disk file should be grown to accommodate the requested size of array (if the total file size is < requested array size). Write privileges are required to grow the file.\\n\\nThe shared keyword argument specifies whether the resulting Array and changes made to it will be visible to other processes mapping the same file.\\n\\nFor example, the following code\\n\\n# Create a file for mmapping\\n# (you could alternatively use mmap to do this step, too)\\nA = rand(1:20, 5, 30)\\ns = open(\\\"/tmp/mmap.bin\\\", \\\"w+\\\")\\n# We\\'ll write the dimensions of the array as the first two Ints in the file\\nwrite(s, size(A,1))\\nwrite(s, size(A,2))\\n# Now write the data\\nwrite(s, A)\\nclose(s)\\n\\n# Test by reading it back in\\ns = open(\\\"/tmp/mmap.bin\\\")   # default is read-only\\nm = read(s, Int)\\nn = read(s, Int)\\nA2 = Mmap.mmap(s, Matrix{Int}, (m,n))\\n\\ncreates a m-by-n Matrix{Int}, linked to the file associated with stream s.\\n\\nA more portable file would need to encode the word size \u2013 32 bit or 64 bit \u2013 and endianness information in the header. In practice, consider encoding binary data using standard formats like HDF5 (which can be used with memory-mapping).\\n\\n\\n\\n\\n\\nMmap.mmap(io, BitArray, [dims, offset])\\n\\nCreate a BitArray whose values are linked to a file, using memory-mapping; it has the same purpose, works in the same way, and has the same arguments, as mmap, but the byte representation is different.\\n\\nExamples\\n\\njulia> io = open(\\\"mmap.bin\\\", \\\"w+\\\");\\n\\njulia> B = Mmap.mmap(io, BitArray, (25,30000));\\n\\njulia> B[3, 4000] = true;\\n\\njulia> Mmap.sync!(B);\\n\\njulia> close(io);\\n\\njulia> io = open(\\\"mmap.bin\\\", \\\"r+\\\");\\n\\njulia> C = Mmap.mmap(io, BitArray, (25,30000));\\n\\njulia> C[3, 4000]\\ntrue\\n\\njulia> C[2, 4000]\\nfalse\\n\\njulia> close(io)\\n\\njulia> rm(\\\"mmap.bin\\\")\\n\\nThis creates a 25-by-30000 BitArray, linked to the file associated with stream io.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Mmap.html#Mmap.sync!\",\n    \"page\": \"Memory-mapped I/O\",\n    \"title\": \"Mmap.sync!\",\n    \"category\": \"function\",\n    \"text\": \"Mmap.sync!(array)\\n\\nForces synchronization between the in-memory version of a memory-mapped Array or BitArray and the on-disk version.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Mmap.html#Memory-mapped-I/O-1\",\n    \"page\": \"Memory-mapped I/O\",\n    \"title\": \"Memory-mapped I/O\",\n    \"category\": \"section\",\n    \"text\": \"DocTestSetup = :(using Mmap)Mmap.Anonymous\\nMmap.mmap\\nMmap.sync!DocTestSetup = nothing\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#\",\n    \"page\": \"Pkg\",\n    \"title\": \"Pkg\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Pkg-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Pkg\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Introduction-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Introduction\",\n    \"category\": \"section\",\n    \"text\": \"Pkg is the standard package manager for Julia 1.0 and newer. Unlike traditional package managers, which install and manage a single global set of packages, Pkg is designed around \u201cenvironments\u201d: independent sets of packages that can be local to an individual project or shared and selected by name. The exact set of packages and versions in an environment is captured in a manifest file which can be checked into a project repository and tracked in version control, significantly improving reproducibility of projects. If you\u2019ve ever tried to run code you haven\u2019t used in a while only to find that you can\u2019t get anything to work because you\u2019ve updated or uninstalled some of the packages your project was using, you\u2019ll understand the motivation for this approach. In Pkg, since each project maintains its own independent set of package versions, you\u2019ll never have this problem again. Moreover, if you check out a project on a new system, you can simply materialize the environment described by its manifest file and immediately be up and running with a known-good set of dependencies.Since environments are managed and updated independently from each other, \u201cdependency hell\u201d is significantly alleviated in Pkg. If you want to use the latest and greatest version of some package in a new project but you\u2019re stuck on an older version in a different project, that\u2019s no problem \u2013\u00a0since they have separate environments they can just use different versions, which are both installed at the same time in different locations on your system. The location of each package version is canonical, so when environments use the same versions of packages, they can share installations, avoiding unnecessary duplication of the package. Old package versions that are no longer used by any environments are periodically \u201cgarbage collected\u201d by the package manager.Pkg\u2019s approach to local environments may be familiar to people who have used Python\u2019s virtualenv or Ruby\u2019s bundler. In Julia, instead of hacking the language\u2019s code loading mechanisms to support environments, we have the benefit that Julia natively understands them. In addition, Julia environments are \u201cstackable\u201d: you can overlay one environment with another and thereby have access to additional packages outside of the primary environment. This makes it easy to work on a project, which provides the primary environment, while still having access to all your usual dev tools like profilers, debuggers, and so on, just by having an environment including these dev tools later in the load path.Last but not least, Pkg is designed to support federated package registries. This means that\u00a0it allows multiple registries managed by different parties to interact seamlessly. In particular, this includes private registries which can live behind corporate firewalls. You can install and update your own packages from a private registry with exactly the same tools and workflows that you use to install and manage official Julia packages. If you urgently need to apply a hotfix for a public package that\u2019s critical to your company\u2019s product, you can tag a private version of it in your company\u2019s internal registry and get a fix to your developers and ops teams quickly and easily without having to wait for an upstream patch to be accepted and published. Once an official fix is published, however, you can just upgrade your dependencies and you\\'ll be back on an official release again.\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Glossary-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Glossary\",\n    \"category\": \"section\",\n    \"text\": \"Project: a source tree with a standard layout, including a src directory for the main body of Julia code, a test directory for testing the project, docs for documentation files, and optionally a deps directory for a build script and its outputs. A project will typically also have a project file and may optionally have a manifest file:Project file: a file in the root directory of a project, named Project.toml (or JuliaProject.toml) describing metadata about the project, including its name, UUID (for packages), authors, license, and the names and UUIDs of packages and libraries that it depends on.\\nManifest file: a file in the root directory of a project, named Manifest.toml (or JuliaManifest.toml) describing a complete dependency graph and exact versions of each package and library used by a project.Package: a project which provides reusable functionality that can be used by other Julia projects via import X or using X. A package should have a project file with a uuid entry giving its package UUID. This UUID is used to identify the package in projects that depend on it.note: Note\\nFor legacy reasons it is possible to load a package without a project file or UUID from the REPL or the top-level of a script. It is not possible, however, to load a package without a project file or UUID from a project with them. Once you\\'ve loaded from a project file, everything needs a project file and UUID.Application: a project which provides standalone functionality not intended to be reused by other Julia projects. For example a web application or a commmand-line utility, or simulation/analytics code accompanying a scientific paper. An application may have a UUID but does not need one. An application may also provide global configuration options for packages it depends on. Packages, on the other hand, may not provide global configuration since that could conflict with the configuration of the main application.note: Note\\nProjects vs. Packages vs. Applications:Project is an umbrella term: packages and applications are kinds of projects.\\nPackages should have UUIDs, applications can have a UUIDs but don\\'t need them.\\nApplications can provide global configuration, whereas packages cannot.Library (future work): a compiled binary dependency (not written in Julia) packaged to be used by a Julia project. These are currently typically built in- place by a deps/build.jl script in a project\u2019s source tree, but in the future we plan to make libraries first-class entities directly installed and upgraded by the package manager.Environment: the combination of the top-level name map provided by a project file combined with the dependency graph and map from packages to their entry points provided by a manifest file. For more detail see the manual section on code loading.Explicit environment: an environment in the form of an explicit project file and an optional corresponding manifest file together in a directory. If the manifest file is absent then the implied dependency graph and location maps are empty.\\nImplicit environment: an environment provided as a directory (without a project file or manifest file) containing packages with entry points of the form X.jl, X.jl/src/X.jl or X/src/X.jl. The top-level name map is implied by these entry points. The dependency graph is implied by the existence of project files inside of these package directories, e.g. X.jl/Project.toml or X/Project.toml. The dependencies of the X package are the dependencies in the corresponding project file if there is one. The location map is implied by the entry points themselves.Registry: a source tree with a standard layout recording metadata about a registered set of packages, the tagged versions of them which are available, and which versions of packages are compatible or incompatible with each other. A registry is indexed by package name and UUID, and has a directory for each registered package providing the following metadata about it:name \u2013\u00a0e.g. DataFrames\\nUUID \u2013\u00a0e.g. a93c6f00-e57d-5684-b7b6-d8193f3e46c0\\nauthors \u2013\u00a0e.g. Jane Q. Developer <jane@example.com>\\nlicense \u2013\u00a0e.g. MIT, BSD3, or GPLv2\\nrepository \u2013\u00a0e.g. https://github.com/JuliaData/DataFrames.jl.git\\ndescription \u2013\u00a0a block of text summarizing the functionality of a package\\nkeywords \u2013\u00a0e.g. data, tabular, analysis, statistics\\nversions \u2013\u00a0a list of all registered version tagsFor each registered version of a package, the following information is provided:its semantic version number \u2013 e.g. v1.2.3\\nits git tree SHA-1 hash \u2013\u00a0e.g. 7ffb18ea3245ef98e368b02b81e8a86543a11103\\na map from names to UUIDs of dependencies\\nwhich versions of other packages it is compatible/incompatible withDependencies and compatibility are stored in a compressed but human-readable format using ranges of package versions.Depot: a directory on a system where various package-related resources live, including:environments: shared named environments (e.g. v0.7, devtools)\\nclones: bare clones of package repositories\\ncompiled: cached compiled package images (.ji files)\\nconfig: global configuration files (e.g. startup.jl)\\ndev: default directory for package development\\nlogs: log files (e.g. manifest_usage.toml, repl_history.jl)\\npackages: installed package versions\\nregistries: clones of registries (e.g. General)Load path: a stack of environments where package identities, their dependencies, and entry-points are searched for. The load path is controlled in Julia by the LOAD_PATH global variable which is populated at startup based on the value of the JULIA_LOAD_PATH environment variable. The first entry is your primary environment, often the current project, while later entries provide additional packages one may want to use from the REPL or top-level scripts.Depot path: a stack of depot locations where the package manager, as well as Julia\\'s code loading mechanisms, look for registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files. The depot path is controlled by the Julia DEPOT_PATH global variable which is populated at startup based on the value of the JULIA_DEPOT_PATH environment variable. The first entry is the \u201cuser depot\u201d and should be writable by and owned by the current user. The user depot is where: registries are cloned, new package versions are installed, named environments are created and updated, package repos are cloned, newly compiled package image files are saved, log files are written, development packages are checked out by default, and global configuration data is saved. Later entries in the depot path are treated as read-only and are appropriate for registries, packages, etc. installed and managed by system administrators.\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Getting-Started-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Getting Started\",\n    \"category\": \"section\",\n    \"text\": \"The Pkg REPL-mode is entered from the Julia REPL using the key ].(v0.7) pkg>The part inside the parenthesis of the prompt shows the name of the current project. Since we haven\\'t created our own project yet, we are in the default project, located at ~/.julia/environments/v0.7 (or whatever version of Julia you happen to run).To return to the julia> prompt, either press backspace when the input line is empty or press Ctrl+C. Help is available by calling pkg> help. If you are in an environment that does not have access to a REPL you can still use the REPL mode commands using the string macro pkg available after using Pkg. The command pkg\\\"cmd\\\" would be equivalent to executing cmd in the REPL mode.The documentation here describes using Pkg from the REPL mode. Documentation of using the Pkg API (by calling Pkg. functions) is in progress of being written.\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Adding-packages-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Adding packages\",\n    \"category\": \"section\",\n    \"text\": \"There are two ways of adding packages, either using the add command or the dev command. The most frequently used one is add and its usage is described first.\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Adding-registered-packages-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Adding registered packages\",\n    \"category\": \"section\",\n    \"text\": \"In the Pkg REPL packages can be added with the add command followed by the name of the package, for example:(v0.7) pkg> add Example\\n   Cloning default registries into /Users/kristoffer/.julia/registries\\n   Cloning registry General from \\\"https://github.com/JuliaRegistries/General.git\\\"\\n  Updating registry at `~/.julia/registries/General`\\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\\n Resolving package versions...\\n  Updating `~/.julia/environments/v0.7/Project.toml`\\n  [7876af07] + Example v0.5.1\\n  Updating `~/.julia/environments/v0.7/Manifest.toml`\\n  [7876af07] + Example v0.5.1\\n  [8dfed614] + TestHere we added the package Example to the current project. In this example, we are using a fresh Julia installation, and this is our first time adding a package using Pkg. By default, Pkg clones Julia\\'s General registry, and uses this registry to look up packages requested for inclusion in the current environment. The status update shows a short form of the package UUID to the left, then the package name, and the version. Since standard libraries (e.g. Test) are shipped with Julia, they do not have a version. The project status contains the packages you have added yourself, in this case, Example:(v0.7) pkg> st\\n    Status `Project.toml`\\n  [7876af07] Example v0.5.1The manifest status, in addition, includes the dependencies of explicitly added packages.(v0.7) pkg> st --manifest\\n    Status `Manifest.toml`\\n  [7876af07] Example v0.5.1\\n  [8dfed614] TestIt is possible to add multiple packages in one command as pkg> add A B C.After a package is added to the project, it can be loaded in Julia:julia> using Example\\n\\njulia> Example.hello(\\\"User\\\")\\n\\\"Hello, User\\\"A specific version can be installed by appending a version after a @ symbol, e.g. @v0.4, to the package name:(v0.7) pkg> add Example@0.4\\n Resolving package versions...\\n  Updating `~/.julia/environments/v0.7/Project.toml`\\n  [7876af07] + Example v0.4.1\\n  Updating `~/.julia/environments/v0.7/Manifest.toml`\\n  [7876af07] + Example v0.4.1If the master branch (or a certain commit SHA) of Example has a hotfix that has not yet included in a registered version, we can explicitly track a branch (or commit) by appending #branch (or #commit) to the package name:(v0.7) pkg> add Example#master\\n  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`\\n Resolving package versions...\\n  Updating `~/.julia/environments/v0.7/Project.toml`\\n  [7876af07] ~ Example v0.5.1 \u21d2 v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git)\\n  Updating `~/.julia/environments/v0.7/Manifest.toml`\\n  [7876af07] ~ Example v0.5.1 \u21d2 v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git)The status output now shows that we are tracking the master branch of Example. When updating packages, we will pull updates from that branch.To go back to tracking the registry version of Example, the command free is used:(v0.7) pkg> free Example\\n Resolving package versions...\\n  Updating `~/.julia/environments/v0.7/Project.toml`\\n  [7876af07] ~ Example v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git) \u21d2 v0.5.1\\n  Updating `~/.julia/environments/v0.7/Manifest.toml`\\n  [7876af07] ~ Example v0.5.1+ #master )https://github.com/JuliaLang/Example.jl.git) \u21d2 v0.5.1\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Adding-unregistered-packages-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Adding unregistered packages\",\n    \"category\": \"section\",\n    \"text\": \"If a package is not in a registry, it can still be added by instead of the package name giving the URL to the repository to add.(v0.7) pkg> add https://github.com/fredrikekre/ImportMacros.jl\\n  Updating git-repo `https://github.com/fredrikekre/ImportMacros.jl`\\n Resolving package versions...\\nDownloaded MacroTools \u2500 v0.4.1\\n  Updating `~/.julia/environments/v0.7/Project.toml`\\n  [e6797606] + ImportMacros v0.0.0 # (https://github.com/fredrikekre/ImportMacros.jl)\\n  Updating `~/.julia/environments/v0.7/Manifest.toml`\\n  [e6797606] + ImportMacros v0.0.0 # (https://github.com/fredrikekre/ImportMacros.jl)\\n  [1914dd2f] + MacroTools v0.4.1The dependencies of the unregistered package (here MacroTools) got installed. For unregistered packages we could have given a branch (or commit SHA) to track using #, just like for registered packages.\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Adding-a-local-package-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Adding a local package\",\n    \"category\": \"section\",\n    \"text\": \"Instead of giving a URL of a git repo to add we could instead have given a local path to a git repo. This works similarly to adding a URL. The local repository will be tracked (at some branch) and updates from that local repo are pulled when packages are updated. Note that changes to files in the local package repository will not immediately be reflected when loading that package. The changes would have to be committed and the packages updated in order to pull in the changes.\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Developing-packages-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Developing packages\",\n    \"category\": \"section\",\n    \"text\": \"By only using add your Manifest will always have a \\\"reproducible state\\\", in other words, as long as the repositories and registries used are still accessible it is possible to retrieve the exact state of all the dependencies in the project. This has the advantage that you can send your project (Project.toml and Manifest.toml) to someone else and they can \\\"instantiate\\\" that project in the same state as you had it locally. However, when you are developing a package, it is more convenient to load packages at their current state at some path. For this reason, the dev command exists.Let\\'s try to dev a registered package:(v0.7) pkg> dev Example\\n  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`\\n Resolving package versions...\\n  Updating `~/.julia/environments/v0.7/Project.toml`\\n  [7876af07] + Example v0.5.1+ [`~/.julia/dev/Example`]\\n  Updating `~/.julia/environments/v0.7/Manifest.toml`\\n  [7876af07] + Example v0.5.1+ [`~/.julia/dev/Example`]The dev command fetches a full clone of the package to ~/.julia/dev/ (the path can be changed by setting the environment variable JULIA_PKG_DEVDIR). When importing Example julia will now import it from ~/.julia/dev/Example and whatever local changes have been made to the files in that path are consequently reflected in the code loaded. When we used add we said that we tracked the package repository, we here say that we track the path itself. Note that the package manager will never touch any of the files at a tracked path. It is therefore up to you to pull updates, change branches etc. If we try to dev a package at some branch that already exists at ~/.julia/dev/ the package manager we will simply use the existing path. For example:(v0.7) pkg> dev Example\\n  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`\\n[ Info: Path `/Users/kristoffer/.julia/dev/Example` exists and looks like the correct package, using existing path instead of cloningNote the info message saying that it is using the existing path. As a general rule, the package manager will never touch files that are tracking a path.If dev is used on a local path, that path to that package is recorded and used when loading that package. The path will be recorded relative to the project file, unless it is given as an absolute path.To stop tracking a path and use the registered version again, use free(v0.7) pkg> free Example\\n Resolving package versions...\\n  Updating `~/.julia/environments/v0.7/Project.toml`\\n  [7876af07] \u2193 Example v0.5.1+ [`~/.julia/dev/Example`] \u21d2 v0.5.1\\n  Updating `~/.julia/environments/v0.7/Manifest.toml`\\n  [7876af07] \u2193 Example v0.5.1+ [`~/.julia/dev/Example`] \u21d2 v0.5.1It should be pointed out that by using dev your project is now inherently stateful. Its state depends on the current content of the files at the path and the manifest cannot be \\\"instantiated\\\" by someone else without knowing the exact content of all the packages that are tracking a path.Note that if you add a dependency to a package that tracks a local path, the Manifest (which contains the whole dependency graph) will become out of sync with the actual dependency graph. This means that the package will not be able to load that dependency since it is not recorded in the Manifest. To update sync the Manifest, use the REPL command resolve.\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Removing-packages-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Removing packages\",\n    \"category\": \"section\",\n    \"text\": \"Packages can be removed from the current project by using pkg> rm Package. This will only remove packages that exist in the project, to remove a package that only exists as a dependency use pkg> rm --manifest DepPackage. Note that this will remove all packages that depends on DepPackage.\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Updating-packages-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Updating packages\",\n    \"category\": \"section\",\n    \"text\": \"When new versions of packages the project is using are released, it is a good idea to update. Simply calling up will try to update all the dependencies of the project to the latest compatible version. Sometimes this is not what you want. You can specify a subset of the dependencies to upgrade by giving them as arguments to up, e.g:(v0.7) pkg> up ExampleThe version of all other packages direct dependencies will stay the same. If you only want to update the minor version of packages, to reduce the risk that your project breaks, you can give the --minor flag, e.g:(v0.7) pkg> up --minor ExamplePackages that track a repository are not updated when a minor upgrade is done. Packages that track a path are never touched by the package manager.\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Pinning-a-package-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Pinning a package\",\n    \"category\": \"section\",\n    \"text\": \"A pinned package will never be updated. A package can be pinned using pin as for example(v0.7) pkg> pin Example\\n Resolving package versions...\\n  Updating `~/.julia/environments/v0.7/Project.toml`\\n  [7876af07] ~ Example v0.5.1 \u21d2 v0.5.1 \u26b2\\n  Updating `~/.julia/environments/v0.7/Manifest.toml`\\n  [7876af07] ~ Example v0.5.1 \u21d2 v0.5.1 \u26b2Note the pin symbol \u26b2 showing that the package is pinned. Removing the pin is done using free(v0.7) pkg> free Example\\n  Updating `~/.julia/environments/v0.7/Project.toml`\\n  [7876af07] ~ Example v0.5.1 \u26b2 \u21d2 v0.5.1\\n  Updating `~/.julia/environments/v0.7/Manifest.toml`\\n  [7876af07] ~ Example v0.5.1 \u26b2 \u21d2 v0.5.1\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Testing-packages-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Testing packages\",\n    \"category\": \"section\",\n    \"text\": \"The tests for a package can be run using testcommand:(v0.7) pkg> test Example\\n   Testing Example\\n   Testing Example tests passed\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Building-packages-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Building packages\",\n    \"category\": \"section\",\n    \"text\": \"The build step of a package is automatically run when a package is first installed. The output of the build process is directed to a file. To explicitly run the build step for a package the build command is used:(v0.7) pkg> build MbedTLS\\n  Building MbedTLS \u2192 `~/.julia/packages/MbedTLS/h1Vu/deps/build.log`\\n\\nshell> cat ~/.julia/packages/MbedTLS/h1Vu/deps/build.log\\n\u250c Warning: `wait(t::Task)` is deprecated, use `fetch(t)` instead.\\n\u2502   caller = macro expansion at OutputCollector.jl:63 [inlined]\\n\u2514 @ Core OutputCollector.jl:63\\n...\\n[ Info: using prebuilt binaries\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Creating-your-own-projects-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Creating your own projects\",\n    \"category\": \"section\",\n    \"text\": \"So far we have added packages to the default project at ~/.julia/environments/v0.7, it is, however, easy to create other, independent, projects. It should be pointed out if two projects uses the same package at the same version, the content of this package is not duplicated. In order to create a new project, create a directory for it and then activate that directory to make it the \\\"active project\\\" which package operations manipulate:shell> mkdir MyProject\\n\\nshell> cd MyProject\\n/Users/kristoffer/MyProject\\n\\n(v0.7) pkg> activate .\\n\\n(MyProject) pkg> st\\n    Status `Project.toml`Note that the REPL prompt changed when the new project is activated. Since this is a newly created project, the status command show it contains no packages, and in fact, it has no project or manifest file until we add a package to it:shell> ls -l\\ntotal 0\\n\\n(MyProject) pkg> add Example\\n  Updating registry at `~/.julia/registries/General`\\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\\n Resolving package versions...\\n  Updating `Project.toml`\\n  [7876af07] + Example v0.5.1\\n  Updating `Manifest.toml`\\n  [7876af07] + Example v0.5.1\\n  [8dfed614] + Test\\n\\nshell> ls -l\\ntotal 8\\n-rw-r--r-- 1 stefan staff 207 Jul  3 16:35 Manifest.toml\\n-rw-r--r-- 1 stefan staff  56 Jul  3 16:35 Project.toml\\n\\nshell> cat Project.toml\\n[deps]\\nExample = \\\"7876af07-990d-54b4-ab0e-23690620f79a\\\"\\n\\nshell> cat Manifest.toml\\n[[Example]]\\ndeps = [\\\"Test\\\"]\\ngit-tree-sha1 = \\\"8eb7b4d4ca487caade9ba3e85932e28ce6d6e1f8\\\"\\nuuid = \\\"7876af07-990d-54b4-ab0e-23690620f79a\\\"\\nversion = \\\"0.5.1\\\"\\n\\n[[Test]]\\nuuid = \\\"8dfed614-e22c-5e08-85e1-65c5234f0b40\\\"This new environment is completely separate from the one we used earlier.\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Garbage-collecting-old,-unused-packages-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Garbage collecting old, unused packages\",\n    \"category\": \"section\",\n    \"text\": \"As packages are updated and projects are deleted, installed packages that were once used will inevitably become old and not used from any existing project. Pkg keeps a log of all projects used so it can go through the log and see exactly which projects still exist and what packages those projects used. The rest can be deleted. This is done with the gc command:(v0.7) pkg> gc\\n    Active manifests at:\\n        `/Users/kristoffer/BinaryProvider/Manifest.toml`\\n        ...\\n        `/Users/kristoffer/Compat.jl/Manifest.toml`\\n   Deleted /Users/kristoffer/.julia/packages/BenchmarkTools/1cAj: 146.302 KiB\\n   Deleted /Users/kristoffer/.julia/packages/Cassette/BXVB: 795.557 KiB\\n   ...\\n   Deleted /Users/kristoffer/.julia/packages/WeakRefStrings/YrK6: 27.328 KiB\\n   Deleted 36 package installations: 113.205 MiBNote that only packages in ~/.julia/packages are deleted.\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Creating-your-own-packages-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Creating your own packages\",\n    \"category\": \"section\",\n    \"text\": \"A package is a project with a name, uuid and version entry in the Project.toml file src/PackageName.jl file that defines the module PackageName. This file is executed when the package is loaded.\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Generating-files-for-a-package-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Generating files for a package\",\n    \"category\": \"section\",\n    \"text\": \"To generate files for a new package, use pkg> generate.(v0.7) pkg> generate HelloWorldThis creates a new project HelloWorld with the following files (visualized with the external tree command):shell> cd HelloWorld\\n\\nshell> tree .\\n.\\n\u251c\u2500\u2500 Project.toml\\n\u2514\u2500\u2500 src\\n    \u2514\u2500\u2500 HelloWorld.jl\\n\\n1 directory, 2 filesThe Project.toml file contains the name of the package, its unique UUID, its version, the author and eventual dependencies:name = \\\"HelloWorld\\\"\\nuuid = \\\"b4cd1eb8-1e24-11e8-3319-93036a3eb9f3\\\"\\nversion = \\\"0.1.0\\\"\\nauthor = [\\\"Some One <someone@email.com>\\\"]\\n\\n[deps]The content of src/HelloWorld.jl is:module HelloWorld\\n\\ngreet() = print(\\\"Hello World!\\\")\\n\\nend # moduleWe can now activate the project and load the package:pkg> activate .\\n\\njulia> import HelloWorld\\n\\njulia> HelloWorld.greet()\\nHello World!\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Adding-dependencies-to-the-project-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Adding dependencies to the project\",\n    \"category\": \"section\",\n    \"text\": \"Let\u2019s say we want to use the standard library package Random and the registered package JSON in our project. We simply add these packages (note how the prompt now shows the name of the newly generated project, since we are inside the HelloWorld project directory):(HelloWorld) pkg> add Random JSON\\n Resolving package versions...\\n  Updating \\\"~/Documents/HelloWorld/Project.toml\\\"\\n [682c06a0] + JSON v0.17.1\\n [9a3f8284] + Random\\n  Updating \\\"~/Documents/HelloWorld/Manifest.toml\\\"\\n [34da2185] + Compat v0.57.0\\n [682c06a0] + JSON v0.17.1\\n [4d1e1d77] + Nullables v0.0.4\\n ...Both Random and JSON got added to the project\u2019s Project.toml file, and the resulting dependencies got added to the Manifest.toml file. The resolver has installed each package with the highest possible version, while still respecting the compatibility that each package enforce on its dependencies.We can now use both Random and JSON in our project. Changing src/HelloWorld.jl tomodule HelloWorld\\n\\nimport Random\\nimport JSON\\n\\ngreet() = print(\\\"Hello World!\\\")\\ngreet_alien() = print(\\\"Hello \\\", Random.randstring(8))\\n\\nend # moduleand reloading the package, the new greet_alien function that uses Random can be used:julia> HelloWorld.greet_alien()\\nHello aT157rHV\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Adding-a-build-step-to-the-package.-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Adding a build step to the package.\",\n    \"category\": \"section\",\n    \"text\": \"The build step is executed the first time a package is installed or when explicitly invoked with build. A package is built by executing the file deps/build.jl.shell> cat deps/build.log\\nI am being built...\\n\\n(HelloWorld) pkg> build\\n  Building HelloWorld \u2192 `deps/build.log`\\n Resolving package versions...\\n\\nshell> cat deps/build.log\\nI am being built...If the build step fails, the output of the build step is printed to the consoleshell> cat deps/build.jl\\nerror(\\\"Ooops\\\")\\n\\n(HelloWorld) pkg> build\\n  Building HelloWorld \u2192 `deps/build.log`\\n Resolving package versions...\\n\u250c Error: Error building `HelloWorld`:\\n\u2502 ERROR: LoadError: Ooops\\n\u2502 Stacktrace:\\n\u2502  [1] error(::String) at ./error.jl:33\\n\u2502  [2] top-level scope at none:0\\n\u2502  [3] include at ./boot.jl:317 [inlined]\\n\u2502  [4] include_relative(::Module, ::String) at ./loading.jl:1071\\n\u2502  [5] include(::Module, ::String) at ./sysimg.jl:29\\n\u2502  [6] include(::String) at ./client.jl:393\\n\u2502  [7] top-level scope at none:0\\n\u2502 in expression starting at /Users/kristoffer/.julia/dev/Pkg/HelloWorld/deps/build.jl:1\\n\u2514 @ Pkg.Operations Operations.jl:938\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Adding-tests-to-the-package-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Adding tests to the package\",\n    \"category\": \"section\",\n    \"text\": \"When a package is tested the file test/runtests.jl is executed.shell> cat test/runtests.jl\\nprintln(\\\"Testing...\\\")\\n(HelloWorld) pkg> test\\n   Testing HelloWorld\\n Resolving package versions...\\nTesting...\\n   Testing HelloWorld tests passed\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Test-specific-dependencies-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Test-specific dependencies\",\n    \"category\": \"section\",\n    \"text\": \"Sometimes one might want to use some packages only at testing time but not enforce a dependency on them when the package is used. This is possible by adding dependencies to [extras] and a test target in [targets] to the Project file. Here we add the Test standard library as a test-only dependency by adding the following to the Project file:[extras]\\nTest = \\\"8dfed614-e22c-5e08-85e1-65c5234f0b40\\\"\\n\\n[targets]\\ntest = [\\\"Test\\\"]We can now use Test in the test script and we can see that it gets installed on testing:shell> cat test/runtests.jl\\nusing Test\\n@test 1 == 1\\n\\n(HelloWorld) pkg> test\\n   Testing HelloWorld\\n Resolving package versions...\\n  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Project.toml`\\n  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]\\n  [8dfed614] + Test\\n  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Manifest.toml`\\n  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]\\n   Testing HelloWorld tests passed```\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Compatibility-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Compatibility\",\n    \"category\": \"section\",\n    \"text\": \"Compatibility refers to the ability to restrict what version of the dependencies that your project is compatible with. If the compatibility for a dependency is not given, the project is assumed to be compatible with all versions of that dependency.Compatibility for a dependency is entered in the Project.toml file as for example:[compat]\\nExample = \\\"0.4.3\\\"After a compatibility entry is put into the project file, up can be used to apply it.The format of the version specifier is described in detail below.info: Info\\nThere is currently no way to give compatibility from the Pkg REPL mode so for now, one has to manually edit the project file.\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Version-specifier-format-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Version specifier format\",\n    \"category\": \"section\",\n    \"text\": \"Similar to other package managers, the Julia package manager respects semantic versioning (semver). As an example, a version specifier is given as e.g. 1.2.3 is therefore assumed to be compatible with the versions [1.2.3 - 2.0.0) where ) is a non-inclusive upper bound. More specifically, a version specifier is either given as a caret specifier, e.g. ^1.2.3  or a tilde specifier ~1.2.3. Caret specifiers are the default and hence 1.2.3 == ^1.2.3. The difference between a caret and tilde is described in the next section. The intersection of multiple version specifiers can be formed by comma separating indiviual version specifiers.\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Caret-specifiers-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Caret specifiers\",\n    \"category\": \"section\",\n    \"text\": \"A caret specifier allows upgrade that would be compatible according to semver. An updated dependency is considered compatible if the new version does not modify the left-most non zero digit in the version specifier.Some examples are shown below.^1.2.3 = [1.2.3, 2.0.0)\\n^1.2 = [1.2.0, 2.0.0)\\n^1 =  [1.0.0, 2.0.0)\\n^0.2.3 = [0.2.3, 0.3.0)\\n^0.0.3 = [0.0.3, 0.0.4)\\n^0.0 = [0.0.0, 0.1.0)\\n^0 = [0.0.0, 1.0.0)While the semver specification says that all versions with a major version of 0 are incompatible with each other, we have made that choice that a version given as 0.a.b is considered compatible with 0.a.c if a != 0 and  c >= b.\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Tilde-specifiers-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Tilde specifiers\",\n    \"category\": \"section\",\n    \"text\": \"A tilde specifier provides more limited upgrade possibilities. With a tilde, only the last specified digit is allowed to increment by one. This gives the following example.~1.2.3 = [1.2.3, 1.2.4)\\n~1.2 = [1.2.0, 1.3.0)\\n~1 = [1.0.0, 2.0.0)\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Inequality-specifiers-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Inequality specifiers\",\n    \"category\": \"section\",\n    \"text\": \"Inequalities can also be used to specify version ranges:>= 1.2.3 = [1.2.3,  \u221e)\\n\u2265 1.2.3 = [1.2.3,  \u221e)\\n= 1.2.3 = [1.2.3, 1.2.3]\\n< 1.2.3 = [0.0.0, 1.2.2]\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Precompiling-a-project-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Precompiling a project\",\n    \"category\": \"section\",\n    \"text\": \"The REPL command precompile can be used to precompile all the dependencies in the project. You can for example do(HelloWorld) pkg> update; precompileto update the dependencies and then precompile them.\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Preview-mode-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Preview mode\",\n    \"category\": \"section\",\n    \"text\": \"If you just want to see the effects of running a command, but not change your state you can preview a command. For example:(HelloWorld) pkg> preview add Plotsor(HelloWorld) pkg> preview upwill show you the effects of adding Plots, or doing a full upgrade, respectively, would have on your project. However, nothing would be installed and your Project.toml and Manifest.toml are untouched.\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Using-someone-else\\'s-project-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"Using someone else\\'s project\",\n    \"category\": \"section\",\n    \"text\": \"Simply clone their project using e.g. git clone, cd to the project directory and call(v0.7) pkg> activate .\\n\\n(SomeProject) pkg> instantiateIf the project contains a manifest, this will install the packages in the same state that is given by that manifest. Otherwise, it will resolve the latest versions of the dependencies compatible with the project.\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Pkg.PackageSpec\",\n    \"page\": \"Pkg\",\n    \"title\": \"Pkg.PackageSpec\",\n    \"category\": \"type\",\n    \"text\": \"PackageSpec(name::String, [uuid::UUID, version::VersionNumber])\\nPackageSpec(; name, url, path, rev, version, mode, level)\\n\\nA PackageSpec is a representation of a package with various metadata. This includes:\\n\\nThe name of the package.\\nThe package unique uuid.\\nA version (for example when adding a package. When upgrading, can also be an instance of\\n\\nthe enum UpgradeLevel\\n\\nA url and an optional git revision. rev could be a branch name or a git commit SHA.\\nA local path path. This is equivalent to using the url argument but can be more descriptive.\\nA mode, which is an instance of the enum PackageMode which can be either PKGMODE_PROJECT or\\n\\nPKGMODE_MANIFEST, defaults to PKGMODE_PROJECT. Used in e.g. Pkg.rm.\\n\\nMost functions in Pkg take a Vector of PackageSpec and do the operation on all the packages in the vector.\\n\\nBelow is a comparison between the REPL version and the PackageSpec version:\\n\\nREPL API\\nPackage PackageSpec(\\\"Package\\\")\\nPackage@0.2 PackageSpec(name=\\\"Package\\\", version=\\\"0.2\\\")\\nPackage=a67d... PackageSpec(name=\\\"Package\\\", uuid=\\\"a67d...\\\"\\nPackage#master PackageSpec(name=\\\"Package\\\", rev=\\\"master\\\")\\nlocal/path#feature PackageSpec(path=\\\"local/path\\\"; rev=\\\"feature)\\nwww.mypkg.com PackageSpec(url=\\\"www.mypkg.com\\\")\\n--manifest Package PackageSpec(name=\\\"Package\\\", mode=PKGSPEC_MANIFEST)\\n--major Package PackageSpec(name=\\\"Package\\\", version=PKGLEVEL_MAJOR)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Pkg.PackageMode\",\n    \"page\": \"Pkg\",\n    \"title\": \"Pkg.PackageMode\",\n    \"category\": \"type\",\n    \"text\": \"PackageMode\\n\\nAn enum with the instances\\n\\nPKGMODE_MANIFEST\\nPKGMODE_PROJECT\\n\\nDetermines if operations should be made on a project or manifest level. Used as an argument to  PackageSpec or as an argument to Pkg.rm.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Pkg.UpgradeLevel\",\n    \"page\": \"Pkg\",\n    \"title\": \"Pkg.UpgradeLevel\",\n    \"category\": \"type\",\n    \"text\": \"UpgradeLevel\\n\\nAn enum with the instances\\n\\nUPLEVEL_FIXED\\nUPLEVEL_PATCH\\nUPLEVEL_MINOR\\nUPLEVEL_MAJOR\\n\\nDetermines how much a package is allowed to be updated. Used as an argument to  PackageSpec or as an argument to Pkg.update.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Pkg.add\",\n    \"page\": \"Pkg\",\n    \"title\": \"Pkg.add\",\n    \"category\": \"function\",\n    \"text\": \"Pkg.add(pkg::Union{String, Vector{String})\\nPkg.add(pkg::Union{PackageSpec, Vector{PackageSpec}})\\n\\nAdd a package to the current project. This package will be available using the import and using keywords in the Julia REPL and if the current project is a package, also inside that package.\\n\\nExamples\\n\\nPkg.add(\\\"Example\\\") # Add a package from registry\\nPkg.add(PackageSpec(name=\\\"Example\\\", version=\\\"0.3\\\")) # Specify version\\nPkg.add(PackageSpec(url=\\\"https://github.com/JuliaLang/Example.jl\\\", rev=\\\"master\\\")) # From url\\nPkg.add(PackageSpec(url=\\\"/remote/mycompany/juliapackages/OurPackage\\\"))` # From path (has to be a gitrepo)\\n\\nSee also PackageSpec.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Pkg.develop\",\n    \"page\": \"Pkg\",\n    \"title\": \"Pkg.develop\",\n    \"category\": \"function\",\n    \"text\": \"Pkg.develop(pkg::Union{String, Vector{String})\\nPkg.develop(pkgs::Union{Packagespec, Vector{Packagespec}})\\n\\nMake a package available for development by tracking it by path. If pkg is given with only a name or by a URL the packages will be downloaded to the location by the environment variable JULIA_PKG_DEVDIR with .julia/dev as the default.\\n\\nIf pkg is given as a local path, the package at that path will be tracked.\\n\\nExamples\\n\\n# By name\\nPkg.develop(\\\"Example\\\")\\n\\n# By url\\nPkg.develop(PackageSpec(url=\\\"https://github.com/JuliaLang/Compat.jl\\\", rev=\\\"master\\\"))\\n\\n# By path (also uses url keyword to PackageSpec)\\nPkg.develop(PackageSpec(url=\\\"MyJuliaPackages/Package.jl\\\")\\n\\nSee also PackageSpec\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Pkg.activate\",\n    \"page\": \"Pkg\",\n    \"title\": \"Pkg.activate\",\n    \"category\": \"function\",\n    \"text\": \"Pkg.activate([s::String]; shared::Bool=false)\\n\\nActivate the environment at s. The active environment is the environment that is modified by executing package commands. The logic for what path is activated is as follows:\\n\\nIf shared is true, the first existing environment named s from the depots in the depot stack will be activated. If no such environment exists yet, activate it in the first depot.\\nIf s is a path that exist, that environment will be activated.\\nIf s is a package name in the current project activate that is tracking a path, activate the environment at that path.\\nIf s is a non-existing path, activate that path.\\n\\nIf no argument is given to activate, activate the home project, which is the one specified by either --project command line when starting julia, or JULIA_PROJECT environment variable.\\n\\nExamples\\n\\nPkg.activate()\\nPkg.activate(\\\"local/path\\\")\\nPkg.activate(\\\"MyDependency\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Pkg.rm\",\n    \"page\": \"Pkg\",\n    \"title\": \"Pkg.rm\",\n    \"category\": \"function\",\n    \"text\": \"Pkg.rm(pkg::Union{String, Vector{String})\\nPkg.rm(pkg::Union{PackageSpec, Vector{PackageSpec}})\\n\\nRemove a package from the current project. If the mode of pkg is PKGMODE_MANIFEST also remove it from the manifest including all recursive dependencies of pkg.\\n\\nSee also PackageSpec, PackageMode.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Pkg.update\",\n    \"page\": \"Pkg\",\n    \"title\": \"Pkg.update\",\n    \"category\": \"function\",\n    \"text\": \"Pkg.update(; level::UpgradeLevel=UPLEVEL_MAJOR, mode::PackageMode = PKGMODE_PROJECT)\\nPkg.update(pkg::Union{String, Vector{String})\\nPkg.update(pkg::Union{PackageSpec, Vector{PackageSpec}})\\n\\nUpdate a package pkg. If no posistional argument is given, update all packages in the manifest if mode is PKGMODE_MANIFEST and packages in both manifest and project if mode is PKGMODE_PROJECT. If no positional argument is given level can be used to control what how much packages are allowed to be upgraded (major, minor, patch, fixed).\\n\\nSee also PackageSpec, PackageMode, UpgradeLevel.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Pkg.test\",\n    \"page\": \"Pkg\",\n    \"title\": \"Pkg.test\",\n    \"category\": \"function\",\n    \"text\": \"Pkg.test(; coverage::Bool=true)\\nPkg.test(pkg::Union{String, Vector{String}; coverage::Bool=true)\\nPkg.test(pkgs::Union{PackageSpec, Vector{PackageSpec}}; coverage::Bool=true)\\n\\nRun the tests for package pkg or if no positional argument is given to test, the current project is tested (which thus needs to be a package). A package is tested by running its test/runtests.jl file.\\n\\nThe tests are run by generating a temporary environment with only pkg and its (recursive) dependencies (recursively) in it. If a manifest exist, the versions in that manifest is used, otherwise a feasible set of package are resolved and installed.\\n\\nDuring the test, test-specific dependencies are active, which are given in the project file as e.g.\\n\\n[extras]\\nTest = \\\"8dfed614-e22c-5e08-85e1-65c5234f0b40\\\"\\n\\n[targets]\\ntest = [Test]\\n\\nCoverage statistics for the packages may be generated by passing coverage=true. The default behavior is not to run coverage.\\n\\nThe tests are executed in a new process with check-bounds=yes and by default startup-file=no. If using the startup file (~/.julia/config/startup.jl) is desired, start julia with --startup-file=yes.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Pkg.build\",\n    \"page\": \"Pkg\",\n    \"title\": \"Pkg.build\",\n    \"category\": \"function\",\n    \"text\": \"Pkg.build()\\nPkg.build(pkg::Union{String, Vector{String})\\nPkg.build(pkgs::Union{PackageSpec, Vector{PackageSpec}})\\n\\nRun the build script in deps/build.jl for pkg and all of the dependencies in depth-first recursive order. If no argument is given to build, the current project is built, which thus needs to be a package. This function is called automatically one any package that gets installed for the first time.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Pkg.pin\",\n    \"page\": \"Pkg\",\n    \"title\": \"Pkg.pin\",\n    \"category\": \"function\",\n    \"text\": \"Pkg.pin(pkg::Union{String, Vector{String})\\nPkg.pin(pkgs::Union{Packagespec, Vector{Packagespec}})\\n\\nPin a package to the current version (or the one given in the packagespec or a certain git revision. A pinned package is never updated.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Pkg.free\",\n    \"page\": \"Pkg\",\n    \"title\": \"Pkg.free\",\n    \"category\": \"function\",\n    \"text\": \"Pkg.free(pkg::Union{String, Vector{String})\\nPkg.free(pkgs::Union{Packagespec, Vector{Packagespec}})\\n\\nFree a package which removes a pin if it exists, or if the package is tracking a path, e.g. after Pkg.develop, go back to tracking registered versions.\\n\\nExamples\\n\\nPkg.free(\\\"Package\\\")\\nPkg.free(PackageSpec(\\\"Package\\\"))\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Pkg.instantiate\",\n    \"page\": \"Pkg\",\n    \"title\": \"Pkg.instantiate\",\n    \"category\": \"function\",\n    \"text\": \"Pkg.instantiate()\\n\\nIf a Manifest.toml file exist in the current project, download all the packages declared in that manifest. Else, resolve a set of feasible packages from the Project.toml files and install them.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Pkg.resolve\",\n    \"page\": \"Pkg\",\n    \"title\": \"Pkg.resolve\",\n    \"category\": \"function\",\n    \"text\": \"Pkg.resolve()\\n\\nUpdate the current manifest with eventual changes to the dependency graph from packages that are tracking a path.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#Pkg.setprotocol!\",\n    \"page\": \"Pkg\",\n    \"title\": \"Pkg.setprotocol!\",\n    \"category\": \"function\",\n    \"text\": \"Pkg.setprotocol!(proto::Union{Nothing, AbstractString}=nothing)\\n\\nSet the protocol used to access GitHub-hosted packages when adding a url or developing a package. Defaults to \\'https\\', with proto == nothing delegating the choice to the package developer.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Pkg.html#References-1\",\n    \"page\": \"Pkg\",\n    \"title\": \"References\",\n    \"category\": \"section\",\n    \"text\": \"This section describes the \\\"API mode\\\" of interacting with Pkg.jl which is recommended for non-interactive usage, in i.e. scripts. In the REPL mode packages (with associated version, UUID, URL etc) are parsed from strings, for example, \\\"Package#master\\\",\\\"Package@v0.1\\\", \\\"www.mypkg.com/MyPkg#my/feature\\\". It is possible to use strings as arguments for simple commands in the API mode (like Pkg.add([\\\"PackageA\\\", \\\"PackageB\\\"]), more complicated commands, that e.g. specify URLs or version range, uses a more structured format over strings. This is done by creating an instance of a PackageSpec which are passed in to functions.PackageSpec\\nPackageMode\\nUpgradeLevel\\nPkg.add\\nPkg.develop\\nPkg.activate\\nPkg.rm\\nPkg.update\\nPkg.test\\nPkg.build\\nPkg.pin\\nPkg.free\\nPkg.instantiate\\nPkg.resolve\\nPkg.setprotocol!\"\n},\n\n{\n    \"location\": \"stdlib/Printf.html#\",\n    \"page\": \"Printf\",\n    \"title\": \"Printf\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Printf.html#Printf.@printf\",\n    \"page\": \"Printf\",\n    \"title\": \"Printf.@printf\",\n    \"category\": \"macro\",\n    \"text\": \"@printf([io::IOStream], \\\"%Fmt\\\", args...)\\n\\nPrint args using C printf style format specification string, with some caveats: Inf and NaN are printed consistently as Inf and NaN for flags %a, %A, %e, %E, %f, %F, %g, and %G. Furthermore, if a floating point number is equally close to the numeric values of two possible output strings, the output string further away from zero is chosen.\\n\\nOptionally, an IOStream may be passed as the first argument to redirect output.\\n\\nExamples\\n\\njulia> @printf(\\\"%f %F %f %F\\\\n\\\", Inf, Inf, NaN, NaN)\\nInf Inf NaN NaN\\n\\n\\njulia> @printf \\\"%.0f %.1f %f\\\\n\\\" 0.5 0.025 -0.0078125\\n1 0.0 -0.007813\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Printf.html#Printf.@sprintf\",\n    \"page\": \"Printf\",\n    \"title\": \"Printf.@sprintf\",\n    \"category\": \"macro\",\n    \"text\": \"@sprintf(\\\"%Fmt\\\", args...)\\n\\nReturn @printf formatted output as string.\\n\\nExamples\\n\\njulia> s = @sprintf \\\"this is a %s %15.1f\\\" \\\"test\\\" 34.567;\\n\\njulia> println(s)\\nthis is a test            34.6\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Printf.html#Printf-1\",\n    \"page\": \"Printf\",\n    \"title\": \"Printf\",\n    \"category\": \"section\",\n    \"text\": \"DocTestSetup = :(using Printf)Printf.@printf\\nPrintf.@sprintfDocTestSetup = nothing\"\n},\n\n{\n    \"location\": \"stdlib/Profile.html#\",\n    \"page\": \"Profiling\",\n    \"title\": \"Profiling\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Profile.html#Profile.@profile\",\n    \"page\": \"Profiling\",\n    \"title\": \"Profile.@profile\",\n    \"category\": \"macro\",\n    \"text\": \"@profile\\n\\n@profile <expression> runs your expression while taking periodic backtraces. These are appended to an internal buffer of backtraces.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Profile.html#Profile.clear\",\n    \"page\": \"Profiling\",\n    \"title\": \"Profile.clear\",\n    \"category\": \"function\",\n    \"text\": \"clear()\\n\\nClear any existing backtraces from the internal buffer.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Profile.html#Profile.print\",\n    \"page\": \"Profiling\",\n    \"title\": \"Profile.print\",\n    \"category\": \"function\",\n    \"text\": \"print([io::IO = stdout,] [data::Vector]; kwargs...)\\n\\nPrints profiling results to io (by default, stdout). If you do not supply a data vector, the internal buffer of accumulated backtraces will be used.\\n\\nThe keyword arguments can be any combination of:\\n\\nformat \u2013 Determines whether backtraces are printed with (default, :tree) or without (:flat) indentation indicating tree structure.\\nC \u2013 If true, backtraces from C and Fortran code are shown (normally they are excluded).\\ncombine \u2013 If true (default), instruction pointers are merged that correspond to the same line of code.\\nmaxdepth \u2013 Limits the depth higher than maxdepth in the :tree format.\\nsortedby \u2013 Controls the order in :flat format. :filefuncline (default) sorts by the source  line, whereas :count sorts in order of number of collected samples.\\nnoisefloor \u2013 Limits frames that exceed the heuristic noise floor of the sample (only applies to format :tree).  A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which n <= noisefloor * \u221aN,  where n is the number of samples on this line, and N is the number of samples for the callee.\\nmincount \u2013 Limits the printout to only those lines with at least mincount occurrences.\\n\\n\\n\\n\\n\\nprint([io::IO = stdout,] data::Vector, lidict::LineInfoDict; kwargs...)\\n\\nPrints profiling results to io. This variant is used to examine results exported by a previous call to retrieve. Supply the vector data of backtraces and a dictionary lidict of line information.\\n\\nSee Profile.print([io], data) for an explanation of the valid keyword arguments.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Profile.html#Profile.init\",\n    \"page\": \"Profiling\",\n    \"title\": \"Profile.init\",\n    \"category\": \"function\",\n    \"text\": \"init(; n::Integer, delay::Float64)\\n\\nConfigure the delay between backtraces (measured in seconds), and the number n of instruction pointers that may be stored. Each instruction pointer corresponds to a single line of code; backtraces generally consist of a long list of instruction pointers. Default settings can be obtained by calling this function with no arguments, and each can be set independently using keywords or in the order (n, delay).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Profile.html#Profile.fetch\",\n    \"page\": \"Profiling\",\n    \"title\": \"Profile.fetch\",\n    \"category\": \"function\",\n    \"text\": \"fetch() -> data\\n\\nReturns a reference to the internal buffer of backtraces. Note that subsequent operations, like clear, can affect data unless you first make a copy. Note that the values in data have meaning only on this machine in the current session, because it depends on the exact memory addresses used in JIT-compiling. This function is primarily for internal use; retrieve may be a better choice for most users.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Profile.html#Profile.retrieve\",\n    \"page\": \"Profiling\",\n    \"title\": \"Profile.retrieve\",\n    \"category\": \"function\",\n    \"text\": \"retrieve() -> data, lidict\\n\\n\\\"Exports\\\" profiling results in a portable format, returning the set of all backtraces (data) and a dictionary that maps the (session-specific) instruction pointers in data to LineInfo values that store the file name, function name, and line number. This function allows you to save profiling results for future analysis.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Profile.html#Profile.callers\",\n    \"page\": \"Profiling\",\n    \"title\": \"Profile.callers\",\n    \"category\": \"function\",\n    \"text\": \"callers(funcname, [data, lidict], [filename=<filename>], [linerange=<start:stop>]) -> Vector{Tuple{count, lineinfo}}\\n\\nGiven a previous profiling run, determine who called a particular function. Supplying the filename (and optionally, range of line numbers over which the function is defined) allows you to disambiguate an overloaded method. The returned value is a vector containing a count of the number of calls and line information about the caller. One can optionally supply backtrace data obtained from retrieve; otherwise, the current internal profile buffer is used.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Profile.html#Profile.clear_malloc_data\",\n    \"page\": \"Profiling\",\n    \"title\": \"Profile.clear_malloc_data\",\n    \"category\": \"function\",\n    \"text\": \"clear_malloc_data()\\n\\nClears any stored memory allocation data when running julia with --track-allocation. Execute the command(s) you want to test (to force JIT-compilation), then call clear_malloc_data. Then execute your command(s) again, quit Julia, and examine the resulting *.mem files.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Profile.html#lib-profiling-1\",\n    \"page\": \"Profiling\",\n    \"title\": \"Profiling\",\n    \"category\": \"section\",\n    \"text\": \"Profile.@profileThe methods in Profile are not exported and need to be called e.g. as Profile.print().Profile.clear\\nProfile.print\\nProfile.init\\nProfile.fetch\\nProfile.retrieve\\nProfile.callers\\nProfile.clear_malloc_data\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"The Julia REPL\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#The-Julia-REPL-1\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"The Julia REPL\",\n    \"category\": \"section\",\n    \"text\": \"Julia comes with a full-featured interactive command-line REPL (read-eval-print loop) built into the julia executable. In addition to allowing quick and easy evaluation of Julia statements, it has a searchable history, tab-completion, many helpful keybindings, and dedicated help and shell modes. The REPL can be started by simply calling julia with no arguments or double-clicking on the executable:$ julia\\n               _\\n   _       _ _(_)_     |  A fresh approach to technical computing\\n  (_)     | (_) (_)    |  Documentation: https://docs.julialang.org\\n   _ _   _| |_  __ _   |  Type \\\"?help\\\" for help.\\n  | | | | | | |/ _` |  |\\n  | | |_| | | | (_| |  |  Version 0.6.0-dev.2493 (2017-01-31 18:53 UTC)\\n _/ |\\\\__\\'_|_|_|\\\\__\\'_|  |  Commit c99e12c* (0 days old master)\\n|__/                   |  x86_64-linux-gnu\\n\\njulia>To exit the interactive session, type ^D \u2013 the control key together with the d key on a blank line \u2013 or type quit() followed by the return or enter key. The REPL greets you with a banner and a julia> prompt.\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#The-different-prompt-modes-1\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"The different prompt modes\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#The-Julian-mode-1\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"The Julian mode\",\n    \"category\": \"section\",\n    \"text\": \"The REPL has four main modes of operation. The first and most common is the Julian prompt. It is the default mode of operation; each new line initially starts with julia>. It is here that you can enter Julia expressions. Hitting return or enter after a complete expression has been entered will evaluate the entry and show the result of the last expression.julia> string(1 + 2)\\n\\\"3\\\"There are a number useful features unique to interactive work. In addition to showing the result, the REPL also binds the result to the variable ans. A trailing semicolon on the line can be used as a flag to suppress showing the result.julia> string(3 * 4);\\n\\njulia> ans\\n\\\"12\\\"In Julia mode, the REPL supports something called prompt pasting. This activates when pasting text that starts with julia> into the REPL. In that case, only expressions starting with julia> are parsed, others are removed. This makes it is possible to paste a chunk of code that has been copied from a REPL session without having to scrub away prompts and outputs. This feature is enabled by default but can be disabled or enabled at will with Base.REPL.enable_promptpaste(::Bool). If it is enabled, you can try it out by pasting the code block above this paragraph straight into the REPL. This feature does not work on the standard Windows command prompt due to its limitation at detecting when a paste occurs.\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#Help-mode-1\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"Help mode\",\n    \"category\": \"section\",\n    \"text\": \"When the cursor is at the beginning of the line, the prompt can be changed to a help mode by typing ?. Julia will attempt to print help or documentation for anything entered in help mode:julia> ? # upon typing ?, the prompt changes (in place) to: help?>\\n\\nhelp?> string\\nsearch: string String Cstring Cwstring RevString randstring bytestring SubString\\n\\n  string(xs...)\\n\\n  Create a string from any values using the print function.Macros, types and variables can also be queried:help?> @time\\n  @time\\n\\n  A macro to execute an expression, printing the time it took to execute, the number of allocations,\\n  and the total number of bytes its execution caused to be allocated, before returning the value of the\\n  expression.\\n\\n  See also @timev, @timed, @elapsed, and @allocated.\\n\\nhelp?> Int32\\nsearch: Int32 UInt32\\n\\n  Int32 <: Signed\\n\\n  32-bit signed integer type.Help mode can be exited by pressing backspace at the beginning of the line.\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#man-shell-mode-1\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"Shell mode\",\n    \"category\": \"section\",\n    \"text\": \"Just as help mode is useful for quick access to documentation, another common task is to use the system shell to execute system commands. Just as ? entered help mode when at the beginning of the line, a semicolon (;) will enter the shell mode. And it can be exited by pressing backspace at the beginning of the line.julia> ; # upon typing ;, the prompt changes (in place) to: shell>\\n\\nshell> echo hello\\nhello\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#Search-modes-1\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"Search modes\",\n    \"category\": \"section\",\n    \"text\": \"In all of the above modes, the executed lines get saved to a history file, which can be searched.  To initiate an incremental search through the previous history, type ^R \u2013 the control key together with the r key. The prompt will change to (reverse-i-search)`\\':, and as you type the search query will appear in the quotes. The most recent result that matches the query will dynamically update to the right of the colon as more is typed. To find an older result using the same query, simply type ^R again.Just as ^R is a reverse search, ^S is a forward search, with the prompt (i-search)`\\':.  The two may be used in conjunction with each other to move through the previous or next matching results, respectively.\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#Key-bindings-1\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"Key bindings\",\n    \"category\": \"section\",\n    \"text\": \"The Julia REPL makes great use of key bindings. Several control-key bindings were already introduced above (^D to exit, ^R and ^S for searching), but there are many more. In addition to the control-key, there are also meta-key bindings. These vary more by platform, but most terminals default to using alt- or option- held down with a key to send the meta-key (or can be configured to do so).Keybinding Description\\nProgram control \\n^D Exit (when buffer is empty)\\n^C Interrupt or cancel\\n^L Clear console screen\\nReturn/Enter, ^J New line, executing if it is complete\\nmeta-Return/Enter Insert new line without executing it\\n? or ; Enter help or shell mode (when at start of a line)\\n^R, ^S Incremental history search, described above\\nCursor movement \\nRight arrow, ^F Move right one character\\nLeft arrow, ^B Move left one character\\nctrl-Right, meta-F Move right one word\\nctrl-Left, meta-B Move left one word\\nHome, ^A Move to beginning of line\\nEnd, ^E Move to end of line\\nUp arrow, ^P Move up one line (or change to the previous history entry that matches the text before the cursor)\\nDown arrow, ^N Move down one line (or change to the next history entry that matches the text before the cursor)\\nShift-Arrow Key Move cursor according to the direction of the Arrow key, while activating the region (\\\"shift selection\\\")\\nPage-up, meta-P Change to the previous history entry\\nPage-down, meta-N Change to the next history entry\\nmeta-< Change to the first history entry (of the current session if it is before the current position in history)\\nmeta-> Change to the last history entry\\n^-Space Set the \\\"mark\\\" in the editing region (and de-activate the region if it\\'s active)\\n^-Space ^-Space Set the \\\"mark\\\" in the editing region and make the region \\\"active\\\", i.e. highlighted\\n^G De-activate the region (i.e. make it not highlighted)\\n^X^X Exchange the current position with the mark\\nEditing \\nBackspace, ^H Delete the previous character, or the whole region when it\\'s active\\nDelete, ^D Forward delete one character (when buffer has text)\\nmeta-Backspace Delete the previous word\\nmeta-d Forward delete the next word\\n^W Delete previous text up to the nearest whitespace\\nmeta-w Copy the current region in the kill ring\\nmeta-W \\\"Kill\\\" the current region, placing the text in the kill ring\\n^K \\\"Kill\\\" to end of line, placing the text in the kill ring\\n^Y \\\"Yank\\\" insert the text from the kill ring\\nmeta-y Replace a previously yanked text with an older entry from the kill ring\\n^T Transpose the characters about the cursor\\nmeta-Up arrow Transpose current line with line above\\nmeta-Down arrow Transpose current line with line below\\nmeta-u Change the next word to uppercase\\nmeta-c Change the next word to titlecase\\nmeta-l Change the next word to lowercase\\n^/, ^_ Undo previous editing action\\n^Q Write a number in REPL and press ^Q to open editor at corresponding stackframe or method\\nmeta-Left Arrow indent the current line on the left\\nmeta-Right Arrow indent the current line on the right\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#Customizing-keybindings-1\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"Customizing keybindings\",\n    \"category\": \"section\",\n    \"text\": \"Julia\\'s REPL keybindings may be fully customized to a user\\'s preferences by passing a dictionary to REPL.setup_interface. The keys of this dictionary may be characters or strings. The key \\'*\\' refers to the default action. Control plus character x bindings are indicated with \\\"^x\\\". Meta plus x can be written \\\"\\\\\\\\Mx\\\". The values of the custom keymap must be nothing (indicating that the input should be ignored) or functions that accept the signature (PromptState, AbstractREPL, Char). The REPL.setup_interface function must be called before the REPL is initialized, by registering the operation with atreplinit . For example, to bind the up and down arrow keys to move through history without prefix search, one could put the following code in ~/.julia/config/startup.jl:import REPL\\nimport REPL.LineEdit\\n\\nconst mykeys = Dict{Any,Any}(\\n    # Up Arrow\\n    \\\"\\\\e[A\\\" => (s,o...)->(LineEdit.edit_move_up(s) || LineEdit.history_prev(s, LineEdit.mode(s).hist)),\\n    # Down Arrow\\n    \\\"\\\\e[B\\\" => (s,o...)->(LineEdit.edit_move_up(s) || LineEdit.history_next(s, LineEdit.mode(s).hist))\\n)\\n\\nfunction customize_keys(repl)\\n    repl.interface = REPL.setup_interface(repl; extra_repl_keymap = mykeys)\\nend\\n\\natreplinit(customize_keys)Users should refer to LineEdit.jl to discover the available actions on key input.\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#Tab-completion-1\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"Tab completion\",\n    \"category\": \"section\",\n    \"text\": \"In both the Julian and help modes of the REPL, one can enter the first few characters of a function or type and then press the tab key to get a list all matches:julia> stri[TAB]\\nstride     strides     string      strip\\n\\njulia> Stri[TAB]\\nStridedArray    StridedMatrix    StridedVecOrMat  StridedVector    StringThe tab key can also be used to substitute LaTeX math symbols with their Unicode equivalents, and get a list of LaTeX matches as well:julia> \\\\pi[TAB]\\njulia> \u03c0\\n\u03c0 = 3.1415926535897...\\n\\njulia> e\\\\_1[TAB] = [1,0]\\njulia> e\u2081 = [1,0]\\n2-element Array{Int64,1}:\\n 1\\n 0\\n\\njulia> e\\\\^1[TAB] = [1 0]\\njulia> e\u00b9 = [1 0]\\n1\u00d72 Array{Int64,2}:\\n 1  0\\n\\njulia> \\\\sqrt[TAB]2     # \u221a is equivalent to the sqrt function\\njulia> \u221a2\\n1.4142135623730951\\n\\njulia> \\\\hbar[TAB](h) = h / 2\\\\pi[TAB]\\njulia> \u0127(h) = h / 2\u03c0\\n\u0127 (generic function with 1 method)\\n\\njulia> \\\\h[TAB]\\n\\\\hat              \\\\hermitconjmatrix  \\\\hkswarow          \\\\hrectangle\\n\\\\hatapprox        \\\\hexagon           \\\\hookleftarrow     \\\\hrectangleblack\\n\\\\hbar             \\\\hexagonblack      \\\\hookrightarrow    \\\\hslash\\n\\\\heartsuit        \\\\hksearow          \\\\house             \\\\hspace\\n\\njulia> \u03b1=\\\"\\\\alpha[TAB]\\\"   # LaTeX completion also works in strings\\njulia> \u03b1=\\\"\u03b1\\\"A full list of tab-completions can be found in the Unicode Input section of the manual.Completion of paths works for strings and julia\\'s shell mode:julia> path=\\\"/[TAB]\\\"\\n.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/\\n.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/\\nshell> /[TAB]\\n.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/\\n.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/Tab completion can help with investigation of the available methods matching the input arguments:julia> max([TAB] # All methods are displayed, not shown here due to size of the list\\n\\njulia> max([1, 2], [TAB] # All methods where `Vector{Int}` matches as first argument\\nmax(x, y) in Base at operators.jl:215\\nmax(a, b, c, xs...) in Base at operators.jl:281\\n\\njulia> max([1, 2], max(1, 2), [TAB] # All methods matching the arguments.\\nmax(x, y) in Base at operators.jl:215\\nmax(a, b, c, xs...) in Base at operators.jl:281Keywords are also displayed in the suggested methods after ;, see below line where limit and keepempty are keyword arguments:julia> split(\\\"1 1 1\\\", [TAB]\\nsplit(str::AbstractString; limit, keepempty) in Base at strings/util.jl:302\\nsplit(str::T, splitter; limit, keepempty) where T<:AbstractString in Base at strings/util.jl:277The completion of the methods uses type inference and can therefore see if the arguments match even if the arguments are output from functions. The function needs to be type stable for the completion to be able to remove non-matching methods.Tab completion can also help completing fields:julia> import UUIDs\\n\\njulia> UUIDs.uuid[TAB]\\nuuid1        uuid4         uuid_versionFields for output from functions can also be completed:julia> split(\\\"\\\",\\\"\\\")[1].[TAB]\\nlastindex  offset  stringThe completion of fields for output from functions uses type inference, and it can only suggest fields if the function is type stable.\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#Customizing-Colors-1\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"Customizing Colors\",\n    \"category\": \"section\",\n    \"text\": \"The colors used by Julia and the REPL can be customized, as well. To change the color of the Julia prompt you can add something like the following to your ~/.julia/config/startup.jl file, which is to be placed inside your home directory:function customize_colors(repl)\\n    repl.prompt_color = Base.text_colors[:cyan]\\nend\\n\\natreplinit(customize_colors)The available color keys can be seen by typing Base.text_colors in the help mode of the REPL. In addition, the integers 0 to 255 can be used as color keys for terminals with 256 color support.You can also change the colors for the help and shell prompts and input and answer text by setting the appropriate field of repl in the customize_colors function above (respectively, help_color, shell_color, input_color, and answer_color). For the latter two, be sure that the envcolors field is also set to false.It is also possible to apply boldface formatting by using Base.text_colors[:bold] as a color. For instance, to print answers in boldface font, one can use the following as a ~/.julia/config/startup.jl:function customize_colors(repl)\\n    repl.envcolors = false\\n    repl.answer_color = Base.text_colors[:bold]\\nend\\n\\natreplinit(customize_colors)You can also customize the color used to render warning and informational messages by setting the appropriate environment variables. For instance, to render error, warning, and informational messages respectively in magenta, yellow, and cyan you can add the following to your ~/.julia/config/startup.jl file:ENV[\\\"JULIA_ERROR_COLOR\\\"] = :magenta\\nENV[\\\"JULIA_WARN_COLOR\\\"] = :yellow\\nENV[\\\"JULIA_INFO_COLOR\\\"] = :cyan\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#TerminalMenus-1\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"TerminalMenus\",\n    \"category\": \"section\",\n    \"text\": \"TerminalMenus is a submodule of the Julia REPL and enables small, low-profile interactive menus in the terminal.\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#Examples-1\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"Examples\",\n    \"category\": \"section\",\n    \"text\": \"import REPL\\nusing REPL.TerminalMenus\\n\\noptions = [\\\"apple\\\", \\\"orange\\\", \\\"grape\\\", \\\"strawberry\\\",\\n            \\\"blueberry\\\", \\\"peach\\\", \\\"lemon\\\", \\\"lime\\\"]\\n\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#RadioMenu-1\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"RadioMenu\",\n    \"category\": \"section\",\n    \"text\": \"The RadioMenu allows the user to select one option from the list. The request function displays the interactive menu and returns the index of the selected choice. If a user presses \\'q\\' or ctrl-c, request will return a -1.# `pagesize` is the number of items to be displayed at a time.\\n#  The UI will scroll if the number of options is greater\\n#   than the `pagesize`\\nmenu = RadioMenu(options, pagesize=4)\\n\\n# `request` displays the menu and returns the index after the\\n#   user has selected a choice\\nchoice = request(\\\"Choose your favorite fruit:\\\", menu)\\n\\nif choice != -1\\n    println(\\\"Your favorite fruit is \\\", options[choice], \\\"!\\\")\\nelse\\n    println(\\\"Menu canceled.\\\")\\nend\\nOutput:Choose your favorite fruit:\\n^  grape\\n   strawberry\\n > blueberry\\nv  peach\\nYour favorite fruit is blueberry!\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#MultiSelectMenu-1\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"MultiSelectMenu\",\n    \"category\": \"section\",\n    \"text\": \"The MultiSelectMenu allows users to select many choices from a list.# here we use the default `pagesize` 10\\nmenu = MultiSelectMenu(options)\\n\\n# `request` returns a `Set` of selected indices\\n# if the menu us canceled (ctrl-c or q), return an empty set\\nchoices = request(\\\"Select the fruits you like:\\\", menu)\\n\\nif length(choices) > 0\\n    println(\\\"You like the following fruits:\\\")\\n    for i in choices\\n        println(\\\"  - \\\", options[i])\\n    end\\nelse\\n    println(\\\"Menu canceled.\\\")\\nendOutput:Select the fruits you like:\\n[press: d=done, a=all, n=none]\\n   [ ] apple\\n > [X] orange\\n   [X] grape\\n   [ ] strawberry\\n   [ ] blueberry\\n   [X] peach\\n   [ ] lemon\\n   [ ] lime\\nYou like the following fruits:\\n  - orange\\n  - grape\\n  - peach\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#Customization-/-Configuration-1\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"Customization / Configuration\",\n    \"category\": \"section\",\n    \"text\": \"All interface customization is done through the keyword only TerminalMenus.config() function.\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#Arguments-1\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"Arguments\",\n    \"category\": \"section\",\n    \"text\": \"charset::Symbol=:na: ui characters to use (:ascii or :unicode); overridden by other arguments\\ncursor::Char=\\'>\\'|\\'\u2192\\': character to use for cursor\\nup_arrow::Char=\\'^\\'|\\'\u2191\\': character to use for up arrow\\ndown_arrow::Char=\\'v\\'|\\'\u2193\\': character to use for down arrow\\nchecked::String=\\\"[X]\\\"|\\\"\u2713\\\": string to use for checked\\nunchecked::String=\\\"[ ]\\\"|\\\"\u2b1a\\\"): string to use for unchecked\\nscroll::Symbol=:na: If :wrap then wrap the cursor around top and bottom, if :nowrap do not wrap cursor\\nsupress_output::Bool=false: For testing. If true, menu will not be printed to console.\\nctrl_c_interrupt::Bool=true: If false, return empty on ^C, if true throw InterruptException() on ^C\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#Examples-2\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"Examples\",\n    \"category\": \"section\",\n    \"text\": \"julia> menu = MultiSelectMenu(options, pagesize=5);\\n\\njulia> request(menu) # ASCII is used by default\\n[press: d=done, a=all, n=none]\\n   [ ] apple\\n   [X] orange\\n   [ ] grape\\n > [X] strawberry\\nv  [ ] blueberry\\nSet([4, 2])\\n\\njulia> TerminalMenus.config(charset=:unicode)\\n\\njulia> request(menu)\\n[press: d=done, a=all, n=none]\\n   \u2b1a apple\\n   \u2713 orange\\n   \u2b1a grape\\n \u2192 \u2713 strawberry\\n\u2193  \u2b1a blueberry\\nSet([4, 2])\\n\\njulia> TerminalMenus.config(checked=\\\"YEP!\\\", unchecked=\\\"NOPE\\\", cursor=\\'\u29d0\\')\\n\\njulia> request(menu)\\n[press: d=done, a=all, n=none]\\n   NOPE apple\\n   YEP! orange\\n   NOPE grape\\n \u29d0 YEP! strawberry\\n\u2193  NOPE blueberry\\nSet([4, 2])\\n\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#Base.atreplinit\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"Base.atreplinit\",\n    \"category\": \"function\",\n    \"text\": \"atreplinit(f)\\n\\nRegister a one-argument function to be called before the REPL interface is initialized in interactive sessions; this is useful to customize the interface. The argument of f is the REPL object. This function should be called from within the .julia/config/startup.jl initialization file.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/REPL.html#References-1\",\n    \"page\": \"The Julia REPL\",\n    \"title\": \"References\",\n    \"category\": \"section\",\n    \"text\": \"Base.atreplinit\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random Numbers\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Random-Numbers-1\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random Numbers\",\n    \"category\": \"section\",\n    \"text\": \"DocTestSetup = :(using Random)Random number generation in Julia uses the Mersenne Twister library via MersenneTwister objects. Julia has a global RNG, which is used by default. Other RNG types can be plugged in by inheriting the AbstractRNG type; they can then be used to have multiple streams of random numbers. Besides MersenneTwister, Julia also provides the RandomDevice RNG type, which is a wrapper over the OS provided entropy.Most functions related to random generation accept an optional AbstractRNG object as first argument, which defaults to the global one if not provided. Moreover, some of them accept optionally dimension specifications dims... (which can be given as a tuple) to generate arrays of random values.A MersenneTwister or RandomDevice RNG can generate uniformly random numbers of the following types: Float16, Float32, Float64, BigFloat, Bool, Int8, UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64, Int128, UInt128, BigInt (or complex numbers of those types). Random floating point numbers are generated uniformly in 0 1). As BigInt represents unbounded integers, the interval must be specified (e.g. rand(big.(1:6))).Additionally, normal and exponential distributions are implemented for some AbstractFloat and Complex types, see randn and randexp for details.\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Base.rand\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Base.rand\",\n    \"category\": \"function\",\n    \"text\": \"rand([rng=GLOBAL_RNG], [S], [dims...])\\n\\nPick a random element or array of random elements from the set of values specified by S; S can be\\n\\nan indexable collection (for example 1:n or [\\'x\\',\\'y\\',\\'z\\']),\\nan AbstractDict or AbstractSet object,\\na string (considered as a collection of characters), or\\na type: the set of values to pick from is then equivalent to typemin(S):typemax(S) for integers (this is not applicable to BigInt), and to 0 1) for floating point numbers;\\n\\nS defaults to Float64 (except when dims is a tuple of integers, in which case S must be specified).\\n\\nExamples\\n\\njulia> rand(Int, 2)\\n2-element Array{Int64,1}:\\n 1339893410598768192\\n 1575814717733606317\\n\\njulia> rand(MersenneTwister(0), Dict(1=>2, 3=>4))\\n1=>2\\n\\nnote: Note\\nThe complexity of rand(rng, s::Union{AbstractDict,AbstractSet}) is linear in the length of s, unless an optimized method with constant complexity is available, which is the case for Dict, Set and BitSet. For more than a few calls, use rand(rng, collect(s)) instead, or either rand(rng, Dict(s)) or rand(rng, Set(s)) as appropriate.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Random.rand!\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random.rand!\",\n    \"category\": \"function\",\n    \"text\": \"rand!([rng=GLOBAL_RNG], A, [S=eltype(A)])\\n\\nPopulate the array A with random values. If S is specified (S can be a type or a collection, cf. rand for details), the values are picked randomly from S. This is equivalent to copyto!(A, rand(rng, S, size(A))) but without allocating a new array.\\n\\nExamples\\n\\njulia> rng = MersenneTwister(1234);\\n\\njulia> rand!(rng, zeros(5))\\n5-element Array{Float64,1}:\\n 0.5908446386657102\\n 0.7667970365022592\\n 0.5662374165061859\\n 0.4600853424625171\\n 0.7940257103317943\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Random.bitrand\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random.bitrand\",\n    \"category\": \"function\",\n    \"text\": \"bitrand([rng=GLOBAL_RNG], [dims...])\\n\\nGenerate a BitArray of random boolean values.\\n\\nExamples\\n\\njulia> rng = MersenneTwister(1234);\\n\\njulia> bitrand(rng, 10)\\n10-element BitArray{1}:\\n false\\n  true\\n  true\\n  true\\n  true\\n false\\n  true\\n false\\n false\\n  true\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Base.randn\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Base.randn\",\n    \"category\": \"function\",\n    \"text\": \"randn([rng=GLOBAL_RNG], [T=Float64], [dims...])\\n\\nGenerate a normally-distributed random number of type T with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers. The Base module currently provides an implementation for the types Float16, Float32, and Float64 (the default), and their Complex counterparts. When the type argument is complex, the values are drawn from the circularly symmetric complex normal distribution.\\n\\nExamples\\n\\njulia> rng = MersenneTwister(1234);\\n\\njulia> randn(rng, ComplexF64)\\n0.6133070881429037 - 0.6376291670853887im\\n\\njulia> randn(rng, ComplexF32, (2, 3))\\n2\u00d73 Array{Complex{Float32},2}:\\n -0.349649-0.638457im  0.376756-0.192146im  -0.396334-0.0136413im\\n  0.611224+1.56403im   0.355204-0.365563im  0.0905552+1.31012im\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Random.randn!\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random.randn!\",\n    \"category\": \"function\",\n    \"text\": \"randn!([rng=GLOBAL_RNG], A::AbstractArray) -> A\\n\\nFill the array A with normally-distributed (mean 0, standard deviation 1) random numbers. Also see the rand function.\\n\\nExamples\\n\\njulia> rng = MersenneTwister(1234);\\n\\njulia> randn!(rng, zeros(5))\\n5-element Array{Float64,1}:\\n  0.8673472019512456\\n -0.9017438158568171\\n -0.4944787535042339\\n -0.9029142938652416\\n  0.8644013132535154\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Random.randexp\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random.randexp\",\n    \"category\": \"function\",\n    \"text\": \"randexp([rng=GLOBAL_RNG], [T=Float64], [dims...])\\n\\nGenerate a random number of type T according to the exponential distribution with scale 1. Optionally generate an array of such random numbers. The Base module currently provides an implementation for the types Float16, Float32, and Float64 (the default).\\n\\nExamples\\n\\njulia> rng = MersenneTwister(1234);\\n\\njulia> randexp(rng, Float32)\\n2.4835055f0\\n\\njulia> randexp(rng, 3, 3)\\n3\u00d73 Array{Float64,2}:\\n 1.5167    1.30652   0.344435\\n 0.604436  2.78029   0.418516\\n 0.695867  0.693292  0.643644\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Random.randexp!\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random.randexp!\",\n    \"category\": \"function\",\n    \"text\": \"randexp!([rng=GLOBAL_RNG], A::AbstractArray) -> A\\n\\nFill the array A with random numbers following the exponential distribution (with scale 1).\\n\\nExamples\\n\\njulia> rng = MersenneTwister(1234);\\n\\njulia> randexp!(rng, zeros(5))\\n5-element Array{Float64,1}:\\n 2.4835053723904896\\n 1.516703605376473\\n 0.6044364871025417\\n 0.6958665886385867\\n 1.3065196315496677\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Random.randstring\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random.randstring\",\n    \"category\": \"function\",\n    \"text\": \"randstring([rng=GLOBAL_RNG], [chars], [len=8])\\n\\nCreate a random string of length len, consisting of characters from chars, which defaults to the set of upper- and lower-case letters and the digits 0-9. The optional rng argument specifies a random number generator, see Random Numbers.\\n\\nExamples\\n\\njulia> Random.seed!(0); randstring()\\n\\\"0IPrGg0J\\\"\\n\\njulia> randstring(MersenneTwister(0), \\'a\\':\\'z\\', 6)\\n\\\"aszvqk\\\"\\n\\njulia> randstring(\\\"ACGT\\\")\\n\\\"TATCGGTC\\\"\\n\\nnote: Note\\nchars can be any collection of characters, of type Char or UInt8 (more efficient), provided rand can randomly pick characters from it.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Random-generation-functions-1\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random generation functions\",\n    \"category\": \"section\",\n    \"text\": \"Random.rand\\nRandom.rand!\\nRandom.bitrand\\nRandom.randn\\nRandom.randn!\\nRandom.randexp\\nRandom.randexp!\\nRandom.randstring\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Random.randsubseq\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random.randsubseq\",\n    \"category\": \"function\",\n    \"text\": \"randsubseq(A, p) -> Vector\\n\\nReturn a vector consisting of a random subsequence of the given array A, where each element of A is included (in order) with independent probability p. (Complexity is linear in p*length(A), so this function is efficient even if p is small and A is large.) Technically, this process is known as \\\"Bernoulli sampling\\\" of A.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Random.randsubseq!\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random.randsubseq!\",\n    \"category\": \"function\",\n    \"text\": \"randsubseq!(S, A, p)\\n\\nLike randsubseq, but the results are stored in S (which is resized as needed).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Random.randperm\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random.randperm\",\n    \"category\": \"function\",\n    \"text\": \"randperm([rng=GLOBAL_RNG,] n::Integer)\\n\\nConstruct a random permutation of length n. The optional rng argument specifies a random number generator (see Random Numbers). To randomly permute an arbitrary vector, see shuffle or shuffle!.\\n\\nExamples\\n\\njulia> randperm(MersenneTwister(1234), 4)\\n4-element Array{Int64,1}:\\n 2\\n 1\\n 4\\n 3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Random.randperm!\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random.randperm!\",\n    \"category\": \"function\",\n    \"text\": \"randperm!([rng=GLOBAL_RNG,] A::Array{<:Integer})\\n\\nConstruct in A a random permutation of length length(A). The optional rng argument specifies a random number generator (see Random Numbers). To randomly permute an arbitrary vector, see shuffle or shuffle!.\\n\\nExamples\\n\\njulia> randperm!(MersenneTwister(1234), Vector{Int}(undef, 4))\\n4-element Array{Int64,1}:\\n 2\\n 1\\n 4\\n 3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Random.randcycle\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random.randcycle\",\n    \"category\": \"function\",\n    \"text\": \"randcycle([rng=GLOBAL_RNG,] n::Integer)\\n\\nConstruct a random cyclic permutation of length n. The optional rng argument specifies a random number generator, see Random Numbers.\\n\\nExamples\\n\\njulia> randcycle(MersenneTwister(1234), 6)\\n6-element Array{Int64,1}:\\n 3\\n 5\\n 4\\n 6\\n 1\\n 2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Random.randcycle!\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random.randcycle!\",\n    \"category\": \"function\",\n    \"text\": \"randcycle!([rng=GLOBAL_RNG,] A::Array{<:Integer})\\n\\nConstruct in A a random cyclic permutation of length length(A). The optional rng argument specifies a random number generator, see Random Numbers.\\n\\nExamples\\n\\njulia> randcycle!(MersenneTwister(1234), Vector{Int}(undef, 6))\\n6-element Array{Int64,1}:\\n 3\\n 5\\n 4\\n 6\\n 1\\n 2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Random.shuffle\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random.shuffle\",\n    \"category\": \"function\",\n    \"text\": \"shuffle([rng=GLOBAL_RNG,] v::AbstractArray)\\n\\nReturn a randomly permuted copy of v. The optional rng argument specifies a random number generator (see Random Numbers). To permute v in-place, see shuffle!. To obtain randomly permuted indices, see randperm.\\n\\nExamples\\n\\njulia> rng = MersenneTwister(1234);\\n\\njulia> shuffle(rng, Vector(1:10))\\n10-element Array{Int64,1}:\\n  6\\n  1\\n 10\\n  2\\n  3\\n  9\\n  5\\n  7\\n  4\\n  8\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Random.shuffle!\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random.shuffle!\",\n    \"category\": \"function\",\n    \"text\": \"shuffle!([rng=GLOBAL_RNG,] v::AbstractArray)\\n\\nIn-place version of shuffle: randomly permute v in-place, optionally supplying the random-number generator rng.\\n\\nExamples\\n\\njulia> rng = MersenneTwister(1234);\\n\\njulia> shuffle!(rng, Vector(1:16))\\n16-element Array{Int64,1}:\\n  2\\n 15\\n  5\\n 14\\n  1\\n  9\\n 10\\n  6\\n 11\\n  3\\n 16\\n  7\\n  4\\n 12\\n  8\\n 13\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Subsequences,-permutations-and-shuffling-1\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Subsequences, permutations and shuffling\",\n    \"category\": \"section\",\n    \"text\": \"Random.randsubseq\\nRandom.randsubseq!\\nRandom.randperm\\nRandom.randperm!\\nRandom.randcycle\\nRandom.randcycle!\\nRandom.shuffle\\nRandom.shuffle!\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Random.seed!\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random.seed!\",\n    \"category\": \"function\",\n    \"text\": \"seed!([rng=GLOBAL_RNG], seed) -> rng\\nseed!([rng=GLOBAL_RNG]) -> rng\\n\\nReseed the random number generator: rng will give a reproducible sequence of numbers if and only if a seed is provided. Some RNGs don\\'t accept a seed, like RandomDevice. After the call to seed!, rng is equivalent to a newly created object initialized with the same seed.\\n\\nExamples\\n\\njulia> Random.seed!(1234);\\n\\njulia> x1 = rand(2)\\n2-element Array{Float64,1}:\\n 0.590845\\n 0.766797\\n\\njulia> Random.seed!(1234);\\n\\njulia> x2 = rand(2)\\n2-element Array{Float64,1}:\\n 0.590845\\n 0.766797\\n\\njulia> x1 == x2\\ntrue\\n\\njulia> rng = MersenneTwister(1234); rand(rng, 2) == x1\\ntrue\\n\\njulia> MersenneTwister(1) == Random.seed!(rng, 1)\\ntrue\\n\\njulia> rand(Random.seed!(rng), Bool) # not reproducible\\ntrue\\n\\njulia> rand(Random.seed!(rng), Bool)\\nfalse\\n\\njulia> rand(MersenneTwister(), Bool) # not reproducible either\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Random.MersenneTwister\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random.MersenneTwister\",\n    \"category\": \"type\",\n    \"text\": \"MersenneTwister(seed)\\nMersenneTwister()\\n\\nCreate a MersenneTwister RNG object. Different RNG objects can have their own seeds, which may be useful for generating different streams of random numbers. The seed may be a non-negative integer or a vector of UInt32 integers. If no seed is provided, a randomly generated one is created (using entropy from the system). See the seed! function for reseeding an already existing MersenneTwister object.\\n\\nExamples\\n\\njulia> rng = MersenneTwister(1234);\\n\\njulia> x1 = rand(rng, 2)\\n2-element Array{Float64,1}:\\n 0.5908446386657102\\n 0.7667970365022592\\n\\njulia> rng = MersenneTwister(1234);\\n\\njulia> x2 = rand(rng, 2)\\n2-element Array{Float64,1}:\\n 0.5908446386657102\\n 0.7667970365022592\\n\\njulia> x1 == x2\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Random.RandomDevice\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Random.RandomDevice\",\n    \"category\": \"type\",\n    \"text\": \"RandomDevice()\\n\\nCreate a RandomDevice RNG object. Two such objects will always generate different streams of random numbers. The entropy is obtained from the operating system.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Generators-(creation-and-seeding)-1\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Generators (creation and seeding)\",\n    \"category\": \"section\",\n    \"text\": \"Random.seed!\\nRandom.MersenneTwister\\nRandom.RandomDevice\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Hooking-into-the-Random-API-1\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Hooking into the Random API\",\n    \"category\": \"section\",\n    \"text\": \"There are two mostly orthogonal ways to extend Random functionalities:generating random values of custom types\\ncreating new generatorsThe API for 1) is quite functional, but is relatively recent so it may still have to evolve in subsequent releases of the Random module. For example, it\\'s typically sufficient to implement one rand method in order to have all other usual methods work automatically.The API for 2) is still rudimentary, and may require more work than strictly necessary from the implementor, in order to support usual types of generated values.\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Generating-random-values-of-custom-types-1\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Generating random values of custom types\",\n    \"category\": \"section\",\n    \"text\": \"There are two categories: generating values from a type (e.g. rand(Int)), or from a collection (e.g. rand(1:3)). The simple cases are explained first, and more advanced usage is presented later. We assume here that the choice of algorithm is independent of the RNG, so we use AbstractRNG in our signatures.\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Generating-values-from-a-type-1\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Generating values from a type\",\n    \"category\": \"section\",\n    \"text\": \"Given a type T, it\\'s currently assumed that if rand(T) is defined, an object of type T will be produced. In order to define random generation of values of type T, the following method can be defined: rand(rng::AbstractRNG, ::Random.SamplerType{T}) (this should return what rand(rng, T) is expected to return).Let\\'s take the following example: we implement a Die type, with a variable number n of sides, numbered from 1 to n. We want rand(Die) to produce a die with a random number of up to 20 sides (and at least 4):struct Die\\n    nsides::Int # number of sides\\nend\\n\\nRandom.rand(rng::AbstractRNG, ::Random.SamplerType{Die}) = Die(rand(rng, 4:20))\\n\\n# output\\nScalar and array methods for Die now work as expected:julia> rand(Die)\\nDie(18)\\n\\njulia> rand(MersenneTwister(0), Die)\\nDie(4)\\n\\njulia> rand(Die, 3)\\n3-element Array{Die,1}:\\n Die(6)\\n Die(11)\\n Die(5)\\n\\njulia> a = Vector{Die}(undef, 3); rand!(a)\\n3-element Array{Die,1}:\\n Die(18)\\n Die(6)\\n Die(8)\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Generating-values-from-a-collection-1\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Generating values from a collection\",\n    \"category\": \"section\",\n    \"text\": \"Given a collection type S, it\\'s currently assumed that if rand(::S) is defined, an object of type eltype(S) will be produced. In order to define random generation out of objects of type S, the following method can be defined: rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S}). Here, sp simply wraps an object of type S, which can be accessed via sp[]. Continuing the Die example, we want now to define rand(d::Die) to produce an Int corresponding to one of d\\'s sides:julia> Random.rand(rng::AbstractRNG, d::Random.SamplerTrivial{Die}) = rand(rng, 1:d[].nsides);\\n\\njulia> rand(Die(4))\\n3\\n\\njulia> rand(Die(4), 3)\\n3-element Array{Any,1}:\\n 3\\n 4\\n 2In the last example, a Vector{Any} is produced; the reason is that eltype(Die) == Any. The remedy is to define Base.eltype(::Type{Die}) = Int.\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Generating-values-for-an-AbstractFloat-type-1\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Generating values for an AbstractFloat type\",\n    \"category\": \"section\",\n    \"text\": \"AbstractFloat types are special-cased, because by default random values are not produced in the whole type domain, but rather in [0,1). The following method should be implemented for T <: AbstractFloat: Random.rand(::AbstractRNG, ::Random.SamplerTrivial{Random.CloseOpen01{T}})\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Optimizing-generation-with-cached-computation-between-calls-1\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Optimizing generation with cached computation between calls\",\n    \"category\": \"section\",\n    \"text\": \"When repeatedly generating random values (with the same rand parameters), it happens for some types that the result of a computation is used for each call. In this case, the computation can be decoupled from actually generating the values. This is the case for example with the default implementation for AbstractArray. Assume that rand(rng, 1:20) has to be called repeatedly in a loop: the way to take advantage of this decoupling is as follows:rng = MersenneTwister()\\nsp = Random.Sampler(rng, 1:20) # or Random.Sampler(MersenneTwister,1:20)\\nfor x in X\\n    n = rand(rng, sp) # similar to n = rand(rng, 1:20)\\n    # use n\\nendThis mechanism is of course used by the default implementation of random array generation (like in rand(1:20, 10)). In order to implement this decoupling for a custom type, a helper type can be used. Going back to our Die example: rand(::Die) uses random generation from a range, so there is an opportunity for this optimization:import Random: Sampler, rand\\n\\nstruct SamplerDie <: Sampler{Int} # generates values of type Int\\n    die::Die\\n    sp::Sampler{Int} # this is an abstract type, so this could be improved\\nend\\n\\nSampler(RNG::Type{<:AbstractRNG}, die::Die, r::Random.Repetition) =\\n    SamplerDie(die, Sampler(RNG, 1:die.nsides, r))\\n# the `r` parameter will be explained later on\\n\\nrand(rng::AbstractRNG, sp::SamplerDie) = rand(rng, sp.sp)It\\'s now possible to get a sampler with sp = Sampler(rng, die), and use sp instead of die in any rand call involving rng. In the simplistic example above, die doesn\\'t need to be stored in SamplerDie but this is often the case in practice.This pattern is so frequent that a helper type named Random.SamplerSimple is available, saving us the definition of SamplerDie: we could have implemented our decoupling with:Sampler(RNG::Type{<:AbstractRNG}, die::Die, r::Random.Repetition) =\\n    SamplerSimple(die, Sampler(RNG, 1:die.nsides, r))\\n\\nrand(rng::AbstractRNG, sp::SamplerSimple{Die}) = rand(rng, sp.data)Here, sp.data refers to the second parameter in the call to the SamplerSimple constructor (in this case equal to Sampler(rng, 1:die.nsides, r)), while the Die object can be accessed via sp[].Another helper type is currently available for other cases, Random.SamplerTag, but is considered as internal API, and can break at any time without proper deprecations.\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Using-distinct-algorithms-for-scalar-or-array-generation-1\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Using distinct algorithms for scalar or array generation\",\n    \"category\": \"section\",\n    \"text\": \"In some cases, whether one wants to generate only a handful of values or a large number of values will have an impact on the choice of algorithm. This is handled with the third parameter of the Sampler constructor. Let\\'s assume we defined two helper types for Die, say SamplerDie1 which should be used to generate only few random values, and SamplerDieMany for many values. We can use those types as follows:Sampler(RNG::Type{<:AbstractRNG}, die::Die, ::Val{1}) = SamplerDie1(...)\\nSampler(RNG::Type{<:AbstractRNG}, die::Die, ::Val{Inf}) = SamplerDieMany(...)Of course, rand must also be defined on those types (i.e. rand(::AbstractRNG, ::SamplerDie1) and rand(::AbstractRNG, ::SamplerDieMany)).Note: Sampler(rng, x) is simply a shorthand for Sampler(rng, x, Val(Inf)), and Random.Repetition is an alias for Union{Val{1}, Val{Inf}}.\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Creating-new-generators-1\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Creating new generators\",\n    \"category\": \"section\",\n    \"text\": \"The API is not clearly defined yet, but as a rule of thumb:any rand method producing \\\"basic\\\" types (isbitstype integer and floating types in Base) should be defined for this specific RNG, if they are needed;\\nother documented rand methods accepting an AbstractRNG should work out of the box, (provided the methods from 1) what are relied on are implemented), but can of course be specialized for this RNG if there is room for optimization.Concerning 1), a rand method may happen to work automatically, but it\\'s not officially supported and may break without warnings in a subsequent release.To define a new rand method for an hypothetical MyRNG generator, and a value specification s (e.g. s == Int, or s == 1:10) of type S==typeof(s) or S==Type{s} if s is a type, the same two methods as we saw before must be defined:Sampler(::Type{MyRNG}, ::S, ::Repetition), which returns an object of type say SamplerS\\nrand(rng::MyRNG, sp::SamplerS)It can happen that Sampler(rng::AbstractRNG, ::S, ::Repetition) is already defined in the Random module. It would then be possible to skip step 1) in practice (if one wants to specialize generation for this particular RNG type), but the corresponding SamplerS type is considered as internal detail, and may be changed without warning.\"\n},\n\n{\n    \"location\": \"stdlib/Random.html#Specializing-array-generation-1\",\n    \"page\": \"Random Numbers\",\n    \"title\": \"Specializing array generation\",\n    \"category\": \"section\",\n    \"text\": \"In some cases, for a given RNG type, generating an array of random values can be more efficient with a specialized method than by merely using the decoupling technique explained before. This is for example the case for MersenneTwister, which natively writes random values in an array.To implement this specialization for MyRNG and for a specification s, producing elements of type S, the following method can be defined: rand!(rng::MyRNG, a::AbstractArray{S}, ::SamplerS), where SamplerS is the type of the sampler returned by Sampler(MyRNG, s, Val(Inf)). Instead of AbstractArray, it\\'s possible to implement the functionality only for a subtype, e.g. Array{S}. The non-mutating array method of rand will automatically call this specialization internally.DocTestSetup = nothing\"\n},\n\n{\n    \"location\": \"stdlib/SHA.html#\",\n    \"page\": \"SHA\",\n    \"title\": \"SHA\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/SHA.html#SHA-1\",\n    \"page\": \"SHA\",\n    \"title\": \"SHA\",\n    \"category\": \"section\",\n    \"text\": \"Usage is very straightforward:julia> using SHA\\n\\njulia> bytes2hex(sha256(\\\"test\\\"))\\n\\\"9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08\\\"Each exported function (at the time of this writing, SHA-1, SHA-2 224, 256, 384 and 512, and SHA-3 224, 256, 384 and 512 functions are implemented) takes in either an Array{UInt8}, a ByteString or an IO object.  This makes it trivial to checksum a file:shell> cat /tmp/test.txt\\ntest\\njulia> using SHA\\n\\njulia> open(\\\"/tmp/test.txt\\\") do f\\n           sha2_256(f)\\n       end\\n32-element Array{UInt8,1}:\\n 0x9f\\n 0x86\\n 0xd0\\n 0x81\\n 0x88\\n 0x4c\\n 0x7d\\n 0x65\\n    \u22ee\\n 0x5d\\n 0x6c\\n 0x15\\n 0xb0\\n 0xf0\\n 0x0a\\n 0x08Note the lack of a newline at the end of /tmp/text.txt.  Julia automatically inserts a newline before the julia> prompt.Due to the colloquial usage of sha256 to refer to sha2_256, convenience functions are provided, mapping shaxxx() function calls to sha2_xxx().  For SHA-3, no such colloquialisms exist and the user must use the full sha3_xxx() names.shaxxx() takes AbstractString and array-like objects (NTuple and Array) with elements of type UInt8.Note that, at the time of this writing, the SHA3 code is not optimized, and as such is roughly an order of magnitude slower than SHA2.\"\n},\n\n{\n    \"location\": \"stdlib/Serialization.html#\",\n    \"page\": \"Serialization\",\n    \"title\": \"Serialization\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Serialization.html#Serialization.serialize\",\n    \"page\": \"Serialization\",\n    \"title\": \"Serialization.serialize\",\n    \"category\": \"function\",\n    \"text\": \"serialize(stream::IO, value)\\n\\nWrite an arbitrary value to a stream in an opaque format, such that it can be read back by deserialize. The read-back value will be as identical as possible to the original. In general, this process will not work if the reading and writing are done by different versions of Julia, or an instance of Julia with a different system image. Ptr values are serialized as all-zero bit patterns (NULL).\\n\\nAn 8-byte identifying header is written to the stream first. To avoid writing the header, construct a Serializer and use it as the first argument to serialize instead. See also Serialization.writeheader.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Serialization.html#Serialization.deserialize\",\n    \"page\": \"Serialization\",\n    \"title\": \"Serialization.deserialize\",\n    \"category\": \"function\",\n    \"text\": \"deserialize(stream)\\n\\nRead a value written by serialize. deserialize assumes the binary data read from stream is correct and has been serialized by a compatible implementation of serialize. It has been designed with simplicity and performance as a goal and does not validate the data read. Malformed data can result in process termination. The caller has to ensure the integrity and correctness of data read from stream.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Serialization.html#Serialization.writeheader\",\n    \"page\": \"Serialization\",\n    \"title\": \"Serialization.writeheader\",\n    \"category\": \"function\",\n    \"text\": \"Serialization.writeheader(s::AbstractSerializer)\\n\\nWrite an identifying header to the specified serializer. The header consists of 8 bytes as follows:\\n\\nOffset Description\\n0 tag byte (0x37)\\n1-2 signature bytes \\\"JL\\\"\\n3 protocol version\\n4 bits 0-1: endianness: 0 = little, 1 = big\\n4 bits 2-3: platform: 0 = 32-bit, 1 = 64-bit\\n5-7 reserved\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Serialization.html#Serialization-1\",\n    \"page\": \"Serialization\",\n    \"title\": \"Serialization\",\n    \"category\": \"section\",\n    \"text\": \"Serialization.serialize\\nSerialization.deserialize\\nSerialization.writeheader\"\n},\n\n{\n    \"location\": \"stdlib/SharedArrays.html#\",\n    \"page\": \"Shared Arrays\",\n    \"title\": \"Shared Arrays\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/SharedArrays.html#SharedArrays.SharedArray\",\n    \"page\": \"Shared Arrays\",\n    \"title\": \"SharedArrays.SharedArray\",\n    \"category\": \"type\",\n    \"text\": \"SharedArray{T}(dims::NTuple; init=false, pids=Int[])\\nSharedArray{T,N}(...)\\n\\nConstruct a SharedArray of a bits type T and size dims across the processes specified by pids - all of which have to be on the same host.  If N is specified by calling SharedArray{T,N}(dims), then N must match the length of dims.\\n\\nIf pids is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, localindices and indexpids will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.\\n\\nIf an init function of the type initfn(S::SharedArray) is specified, it is called on all the participating workers.\\n\\nThe shared array is valid as long as a reference to the SharedArray object exists on the node which created the mapping.\\n\\nSharedArray{T}(filename::AbstractString, dims::NTuple, [offset=0]; mode=nothing, init=false, pids=Int[])\\nSharedArray{T,N}(...)\\n\\nConstruct a SharedArray backed by the file filename, with element type T (must be a bits type) and size dims, across the processes specified by pids - all of which have to be on the same host. This file is mmapped into the host memory, with the following consequences:\\n\\nThe array data must be represented in binary format (e.g., an ASCII format like CSV cannot be supported)\\nAny changes you make to the array values (e.g., A[3] = 0) will also change the values on disk\\n\\nIf pids is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, localindices and indexpids will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.\\n\\nmode must be one of \\\"r\\\", \\\"r+\\\", \\\"w+\\\", or \\\"a+\\\", and defaults to \\\"r+\\\" if the file specified by filename already exists, or \\\"w+\\\" if not. If an init function of the type initfn(S::SharedArray) is specified, it is called on all the participating workers. You cannot specify an init function if the file is not writable.\\n\\noffset allows you to skip the specified number of bytes at the beginning of the file.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SharedArrays.html#Distributed.procs-Tuple{SharedArray}\",\n    \"page\": \"Shared Arrays\",\n    \"title\": \"Distributed.procs\",\n    \"category\": \"method\",\n    \"text\": \"procs(S::SharedArray)\\n\\nGet the vector of processes mapping the shared array.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SharedArrays.html#SharedArrays.sdata\",\n    \"page\": \"Shared Arrays\",\n    \"title\": \"SharedArrays.sdata\",\n    \"category\": \"function\",\n    \"text\": \"sdata(S::SharedArray)\\n\\nReturns the actual Array object backing S.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SharedArrays.html#SharedArrays.indexpids\",\n    \"page\": \"Shared Arrays\",\n    \"title\": \"SharedArrays.indexpids\",\n    \"category\": \"function\",\n    \"text\": \"indexpids(S::SharedArray)\\n\\nReturns the current worker\\'s index in the list of workers mapping the SharedArray (i.e. in the same list returned by procs(S)), or 0 if the SharedArray is not mapped locally.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SharedArrays.html#SharedArrays.localindices\",\n    \"page\": \"Shared Arrays\",\n    \"title\": \"SharedArrays.localindices\",\n    \"category\": \"function\",\n    \"text\": \"localindices(S::SharedArray)\\n\\nReturns a range describing the \\\"default\\\" indices to be handled by the current process.  This range should be interpreted in the sense of linear indexing, i.e., as a sub-range of 1:length(S).  In multi-process contexts, returns an empty range in the parent process (or any process for which indexpids returns 0).\\n\\nIt\\'s worth emphasizing that localindices exists purely as a convenience, and you can partition work on the array among workers any way you wish. For a SharedArray, all indices should be equally fast for each worker process.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SharedArrays.html#Shared-Arrays-1\",\n    \"page\": \"Shared Arrays\",\n    \"title\": \"Shared Arrays\",\n    \"category\": \"section\",\n    \"text\": \"SharedArrays.SharedArray\\nSharedArrays.procs(::SharedArray)\\nSharedArrays.sdata\\nSharedArrays.indexpids\\nSharedArrays.localindices\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.connect-Tuple{TCPSocket,Integer}\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.connect\",\n    \"category\": \"method\",\n    \"text\": \"connect([host], port::Integer) -> TCPSocket\\n\\nConnect to the host host on port port.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.connect-Tuple{AbstractString}\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.connect\",\n    \"category\": \"method\",\n    \"text\": \"connect(path::AbstractString) -> PipeEndpoint\\n\\nConnect to the named pipe / UNIX domain socket at path.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.listen-Tuple{Any}\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.listen\",\n    \"category\": \"method\",\n    \"text\": \"listen([addr, ]port::Integer; backlog::Integer=BACKLOG_DEFAULT) -> TCPServer\\n\\nListen on port on the address specified by addr. By default this listens on localhost only. To listen on all interfaces pass IPv4(0) or IPv6(0) as appropriate. backlog determines how many connections can be pending (not having called accept) before the server will begin to reject them. The default value of backlog is 511.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.listen-Tuple{AbstractString}\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.listen\",\n    \"category\": \"method\",\n    \"text\": \"listen(path::AbstractString) -> PipeServer\\n\\nCreate and listen on a named pipe / UNIX domain socket.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.getaddrinfo\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.getaddrinfo\",\n    \"category\": \"function\",\n    \"text\": \"getalladdrinfo(host::AbstractString, IPAddr=IPv4) -> IPAddr\\n\\nGets the first IP address of the host of the specified IPAddr type. Uses the operating system\\'s underlying getaddrinfo implementation, which may do a DNS lookup.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.getipaddr\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.getipaddr\",\n    \"category\": \"function\",\n    \"text\": \"getipaddr() -> IPAddr\\n\\nGet the IP address of the local machine.\\n\\nExamples\\n\\njulia> getipaddr()\\nip\\\"192.168.1.28\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.getalladdrinfo\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.getalladdrinfo\",\n    \"category\": \"function\",\n    \"text\": \"getalladdrinfo(host::AbstractString) -> Vector{IPAddr}\\n\\nGets all of the IP addresses of the host. Uses the operating system\\'s underlying getaddrinfo implementation, which may do a DNS lookup.\\n\\nExample\\n\\njulia> getalladdrinfo(\\\"google.com\\\")\\n2-element Array{IPAddr,1}:\\n ip\\\"172.217.6.174\\\"\\n ip\\\"2607:f8b0:4000:804::200e\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.getnameinfo\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.getnameinfo\",\n    \"category\": \"function\",\n    \"text\": \"getnameinfo(host::IPAddr) -> String\\n\\nPerforms a reverse-lookup for IP address to return a hostname and service using the operating system\\'s underlying getnameinfo implementation.\\n\\nExamples\\n\\njulia> getnameinfo(Sockets.IPv4(\\\"8.8.8.8\\\"))\\n\\\"google-public-dns-a.google.com\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.getsockname\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.getsockname\",\n    \"category\": \"function\",\n    \"text\": \"getsockname(sock::Union{TCPServer, TCPSocket}) -> (IPAddr, UInt16)\\n\\nGet the IP address and port that the given socket is bound to.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.getpeername\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.getpeername\",\n    \"category\": \"function\",\n    \"text\": \"getpeername(sock::TCPSocket) -> (IPAddr, UInt16)\\n\\nGet the IP address and port of the remote endpoint that the given socket is connected to. Valid only for connected TCP sockets.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.IPv4\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.IPv4\",\n    \"category\": \"type\",\n    \"text\": \"IPv4(host::Integer) -> IPv4\\n\\nReturns an IPv4 object from ip address host formatted as an Integer.\\n\\njulia> IPv4(3223256218)\\nip\\\"192.30.252.154\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.IPv6\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.IPv6\",\n    \"category\": \"type\",\n    \"text\": \"IPv6(host::Integer) -> IPv6\\n\\nReturns an IPv6 object from ip address host formatted as an Integer.\\n\\njulia> IPv6(3223256218)\\nip\\\"::c01e:fc9a\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.TCPSocket\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.TCPSocket\",\n    \"category\": \"type\",\n    \"text\": \"TCPSocket(; delay=true)\\n\\nOpen a TCP socket using libuv. If delay is true, libuv delays creation of the socket\\'s file descriptor till the first bind call. TCPSocket has various fields to denote the state of the socket as well as its send/receive buffers.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.UDPSocket\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.UDPSocket\",\n    \"category\": \"type\",\n    \"text\": \"UDPSocket()\\n\\nOpen a UDP socket using libuv. UDPSocket has various fields to denote the state of the socket.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.accept\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.accept\",\n    \"category\": \"function\",\n    \"text\": \"accept(server[,client])\\n\\nAccepts a connection on the given server and returns a connection to the client. An uninitialized client stream may be provided, in which case it will be used instead of creating a new stream.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.listenany\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.listenany\",\n    \"category\": \"function\",\n    \"text\": \"listenany([host::IPAddr,] port_hint) -> (UInt16, TCPServer)\\n\\nCreate a TCPServer on any port, using hint as a starting point. Returns a tuple of the actual port that the server was created on and the server itself.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Base.bind\",\n    \"page\": \"Sockets\",\n    \"title\": \"Base.bind\",\n    \"category\": \"function\",\n    \"text\": \"bind(chnl::Channel, task::Task)\\n\\nAssociate the lifetime of chnl with a task. Channel chnl is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on chnl.\\n\\nThe chnl object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed Channel objects.\\n\\nWhen a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.\\n\\nExamples\\n\\njulia> c = Channel(0);\\n\\njulia> task = @async foreach(i->put!(c, i), 1:4);\\n\\njulia> bind(c,task);\\n\\njulia> for i in c\\n           @show i\\n       end;\\ni = 1\\ni = 2\\ni = 3\\ni = 4\\n\\njulia> isopen(c)\\nfalse\\n\\njulia> c = Channel(0);\\n\\njulia> task = @async (put!(c,1);error(\\\"foo\\\"));\\n\\njulia> bind(c,task);\\n\\njulia> take!(c)\\n1\\n\\njulia> put!(c,1);\\nERROR: foo\\nStacktrace:\\n[...]\\n\\n\\n\\n\\n\\nbind(socket::Union{UDPSocket, TCPSocket}, host::IPAddr, port::Integer; ipv6only=false, reuseaddr=false, kws...)\\n\\nBind socket to the given host:port. Note that 0.0.0.0 will listen on all devices.\\n\\nThe ipv6only parameter disables dual stack mode. If ipv6only=true, only an IPv6 stack is created.\\nIf reuseaddr=true, multiple threads or processes can bind to the same address without error if they all set reuseaddr=true, but only the last to bind will receive any traffic.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.send\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.send\",\n    \"category\": \"function\",\n    \"text\": \"send(socket::UDPSocket, host, port::Integer, msg)\\n\\nSend msg over socket to host:port.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.recv\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.recv\",\n    \"category\": \"function\",\n    \"text\": \"recv(socket::UDPSocket)\\n\\nRead a UDP packet from the specified socket, and return the bytes received. This call blocks.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.recvfrom\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.recvfrom\",\n    \"category\": \"function\",\n    \"text\": \"recvfrom(socket::UDPSocket) -> (address, data)\\n\\nRead a UDP packet from the specified socket, returning a tuple of (address, data), where address will be either IPv4 or IPv6 as appropriate.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets.setopt\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets.setopt\",\n    \"category\": \"function\",\n    \"text\": \"setopt(sock::UDPSocket; multicast_loop = nothing, multicast_ttl=nothing, enable_broadcast=nothing, ttl=nothing)\\n\\nSet UDP socket options.\\n\\nmulticast_loop: loopback for multicast packets (default: true).\\nmulticast_ttl: TTL for multicast packets (default: nothing).\\nenable_broadcast: flag must be set to true if socket will be used for broadcast messages, or else the UDP system will return an access error (default: false).\\nttl: Time-to-live of packets sent on the socket (default: nothing).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Sockets.html#Sockets-1\",\n    \"page\": \"Sockets\",\n    \"title\": \"Sockets\",\n    \"category\": \"section\",\n    \"text\": \"DocTestSetup = :(using Sockets)Sockets.connect(::TCPSocket, ::Integer)\\nSockets.connect(::AbstractString)\\nSockets.listen(::Any)\\nSockets.listen(::AbstractString)\\nSockets.getaddrinfo\\nSockets.getipaddr\\nSockets.getalladdrinfo\\nSockets.getnameinfo\\nSockets.getsockname\\nSockets.getpeername\\nSockets.IPv4\\nSockets.IPv6\\nSockets.TCPSocket\\nSockets.UDPSocket\\nSockets.accept\\nSockets.listenany\\nSockets.bind\\nSockets.send\\nSockets.recv\\nSockets.recvfrom\\nSockets.setoptDocTestSetup = nothing\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"Sparse Arrays\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#Sparse-Arrays-1\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"Sparse Arrays\",\n    \"category\": \"section\",\n    \"text\": \"DocTestSetup = :(using SparseArrays, LinearAlgebra)Julia has support for sparse vectors and sparse matrices in the SparseArrays stdlib module. Sparse arrays are arrays that contain enough zeros that storing them in a special data structure leads to savings in space and execution time, compared to dense arrays.\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#man-csc-1\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"Compressed Sparse Column (CSC) Sparse Matrix Storage\",\n    \"category\": \"section\",\n    \"text\": \"In Julia, sparse matrices are stored in the Compressed Sparse Column (CSC) format. Julia sparse matrices have the type SparseMatrixCSC{Tv,Ti}, where Tv is the type of the stored values, and Ti is the integer type for storing column pointers and row indices. The internal representation of SparseMatrixCSC is as follows:struct SparseMatrixCSC{Tv,Ti<:Integer} <: AbstractSparseMatrix{Tv,Ti}\\n    m::Int                  # Number of rows\\n    n::Int                  # Number of columns\\n    colptr::Vector{Ti}      # Column i is in colptr[i]:(colptr[i+1]-1)\\n    rowval::Vector{Ti}      # Row indices of stored values\\n    nzval::Vector{Tv}       # Stored values, typically nonzeros\\nendThe compressed sparse column storage makes it easy and quick to access the elements in the column of a sparse matrix, whereas accessing the sparse matrix by rows is considerably slower. Operations such as insertion of previously unstored entries one at a time in the CSC structure tend to be slow. This is because all elements of the sparse matrix that are beyond the point of insertion have to be moved one place over.All operations on sparse matrices are carefully implemented to exploit the CSC data structure for performance, and to avoid expensive operations.If you have data in CSC format from a different application or library, and wish to import it in Julia, make sure that you use 1-based indexing. The row indices in every column need to be sorted. If your SparseMatrixCSC object contains unsorted row indices, one quick way to sort them is by doing a double transpose.In some applications, it is convenient to store explicit zero values in a SparseMatrixCSC. These are accepted by functions in Base (but there is no guarantee that they will be preserved in mutating operations). Such explicitly stored zeros are treated as structural nonzeros by many routines. The nnz function returns the number of elements explicitly stored in the sparse data structure, including structural nonzeros. In order to count the exact number of numerical nonzeros, use count(!iszero, x), which inspects every stored element of a sparse matrix. dropzeros, and the in-place dropzeros!, can be used to remove stored zeros from the sparse matrix.julia> A = sparse([1, 2, 3], [1, 2, 3], [0, 2, 0])\\n3\u00d73 SparseMatrixCSC{Int64,Int64} with 3 stored entries:\\n  [1, 1]  =  0\\n  [2, 2]  =  2\\n  [3, 3]  =  0\\n\\njulia> dropzeros(A)\\n3\u00d73 SparseMatrixCSC{Int64,Int64} with 1 stored entry:\\n  [2, 2]  =  2\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#Sparse-Vector-Storage-1\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"Sparse Vector Storage\",\n    \"category\": \"section\",\n    \"text\": \"Sparse vectors are stored in a close analog to compressed sparse column format for sparse matrices. In Julia, sparse vectors have the type SparseVector{Tv,Ti} where Tv is the type of the stored values and Ti the integer type for the indices. The internal representation is as follows:struct SparseVector{Tv,Ti<:Integer} <: AbstractSparseVector{Tv,Ti}\\n    n::Int              # Length of the sparse vector\\n    nzind::Vector{Ti}   # Indices of stored values\\n    nzval::Vector{Tv}   # Stored values, typically nonzeros\\nendAs for SparseMatrixCSC, the SparseVector type can also contain explicitly stored zeros. (See Sparse Matrix Storage.).\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#Sparse-Vector-and-Matrix-Constructors-1\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"Sparse Vector and Matrix Constructors\",\n    \"category\": \"section\",\n    \"text\": \"The simplest way to create a sparse array is to use a function equivalent to the zeros function that Julia provides for working with dense arrays. To produce a sparse array instead, you can use the same name with an sp prefix:julia> spzeros(3)\\n3-element SparseVector{Float64,Int64} with 0 stored entriesThe sparse function is often a handy way to construct sparse arrays. For example, to construct a sparse matrix we can input a vector I of row indices, a vector J of column indices, and a vector V of stored values (this is also known as the COO (coordinate) format). sparse(I,J,V) then constructs a sparse matrix such that S[I[k], J[k]] = V[k]. The equivalent sparse vector constructor is sparsevec, which takes the (row) index vector I and the vector V with the stored values and constructs a sparse vector R such that R[I[k]] = V[k].julia> I = [1, 4, 3, 5]; J = [4, 7, 18, 9]; V = [1, 2, -5, 3];\\n\\njulia> S = sparse(I,J,V)\\n5\u00d718 SparseMatrixCSC{Int64,Int64} with 4 stored entries:\\n  [1 ,  4]  =  1\\n  [4 ,  7]  =  2\\n  [5 ,  9]  =  3\\n  [3 , 18]  =  -5\\n\\njulia> R = sparsevec(I,V)\\n5-element SparseVector{Int64,Int64} with 4 stored entries:\\n  [1]  =  1\\n  [3]  =  -5\\n  [4]  =  2\\n  [5]  =  3The inverse of the sparse and sparsevec functions is findnz, which retrieves the inputs used to create the sparse array. findall(!iszero, x) returns the cartesian indices of non-zero entries in x (including stored entries equal to zero).julia> findnz(S)\\n([1, 4, 5, 3], [4, 7, 9, 18], [1, 2, 3, -5])\\n\\njulia> findall(!iszero, S)\\n4-element Array{CartesianIndex{2},1}:\\n CartesianIndex(1, 4)\\n CartesianIndex(4, 7)\\n CartesianIndex(5, 9)\\n CartesianIndex(3, 18)\\n\\njulia> findnz(R)\\n([1, 3, 4, 5], [1, -5, 2, 3])\\n\\njulia> findall(!iszero, R)\\n4-element Array{Int64,1}:\\n 1\\n 3\\n 4\\n 5Another way to create a sparse array is to convert a dense array into a sparse array using the sparse function:julia> sparse(Matrix(1.0I, 5, 5))\\n5\u00d75 SparseMatrixCSC{Float64,Int64} with 5 stored entries:\\n  [1, 1]  =  1.0\\n  [2, 2]  =  1.0\\n  [3, 3]  =  1.0\\n  [4, 4]  =  1.0\\n  [5, 5]  =  1.0\\n\\njulia> sparse([1.0, 0.0, 1.0])\\n3-element SparseVector{Float64,Int64} with 2 stored entries:\\n  [1]  =  1.0\\n  [3]  =  1.0You can go in the other direction using the Array constructor. The issparse function can be used to query if a matrix is sparse.julia> issparse(spzeros(5))\\ntrue\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#Sparse-matrix-operations-1\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"Sparse matrix operations\",\n    \"category\": \"section\",\n    \"text\": \"Arithmetic operations on sparse matrices also work as they do on dense matrices. Indexing of, assignment into, and concatenation of sparse matrices work in the same way as dense matrices. Indexing operations, especially assignment, are expensive, when carried out one element at a time. In many cases it may be better to convert the sparse matrix into (I,J,V) format using findnz, manipulate the values or the structure in the dense vectors (I,J,V), and then reconstruct the sparse matrix.\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#Correspondence-of-dense-and-sparse-methods-1\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"Correspondence of dense and sparse methods\",\n    \"category\": \"section\",\n    \"text\": \"The following table gives a correspondence between built-in methods on sparse matrices and their corresponding methods on dense matrix types. In general, methods that generate sparse matrices differ from their dense counterparts in that the resulting matrix follows the same sparsity pattern as a given sparse matrix S, or that the resulting sparse matrix has density d, i.e. each matrix element has a probability d of being non-zero.Details can be found in the Sparse Vectors and Matrices section of the standard library reference.Sparse Dense Description\\nspzeros(m,n) zeros(m,n) Creates a m-by-n matrix of zeros. (spzeros(m,n) is empty.)\\nsparse(I, n, n) Matrix(I,n,n) Creates a n-by-n identity matrix.\\nArray(S) sparse(A) Interconverts between dense and sparse formats.\\nsprand(m,n,d) rand(m,n) Creates a m-by-n random matrix (of density d) with iid non-zero elements distributed uniformly on the half-open interval 0 1).\\nsprandn(m,n,d) randn(m,n) Creates a m-by-n random matrix (of density d) with iid non-zero elements distributed according to the standard normal (Gaussian) distribution.\\nsprandn(m,n,d,X) randn(m,n,X) Creates a m-by-n random matrix (of density d) with iid non-zero elements distributed according to the X distribution. (Requires the Distributions package.)\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#SparseArrays.SparseVector\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"SparseArrays.SparseVector\",\n    \"category\": \"type\",\n    \"text\": \"SparseVector{Tv,Ti<:Integer} <: AbstractSparseVector{Tv,Ti}\\n\\nVector type for storing sparse vectors.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#SparseArrays.SparseMatrixCSC\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"SparseArrays.SparseMatrixCSC\",\n    \"category\": \"type\",\n    \"text\": \"SparseMatrixCSC{Tv,Ti<:Integer} <: AbstractSparseMatrix{Tv,Ti}\\n\\nMatrix type for storing sparse matrices in the Compressed Sparse Column format.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#SparseArrays.sparse\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"SparseArrays.sparse\",\n    \"category\": \"function\",\n    \"text\": \"sparse(A)\\n\\nConvert an AbstractMatrix A into a sparse matrix.\\n\\nExamples\\n\\njulia> A = Matrix(1.0I, 3, 3)\\n3\u00d73 Array{Float64,2}:\\n 1.0  0.0  0.0\\n 0.0  1.0  0.0\\n 0.0  0.0  1.0\\n\\njulia> sparse(A)\\n3\u00d73 SparseMatrixCSC{Float64,Int64} with 3 stored entries:\\n  [1, 1]  =  1.0\\n  [2, 2]  =  1.0\\n  [3, 3]  =  1.0\\n\\n\\n\\n\\n\\nsparse(I, J, V,[ m, n, combine])\\n\\nCreate a sparse matrix S of dimensions m x n such that S[I[k], J[k]] = V[k]. The combine function is used to combine duplicates. If m and n are not specified, they are set to maximum(I) and maximum(J) respectively. If the combine function is not supplied, combine defaults to + unless the elements of V are Booleans in which case combine defaults to |. All elements of I must satisfy 1 <= I[k] <= m, and all elements of J must satisfy 1 <= J[k] <= n. Numerical zeros in (I, J, V) are retained as structural nonzeros; to drop numerical zeros, use dropzeros!.\\n\\nFor additional documentation and an expert driver, see Base.SparseArrays.sparse!.\\n\\nExamples\\n\\njulia> Is = [1; 2; 3];\\n\\njulia> Js = [1; 2; 3];\\n\\njulia> Vs = [1; 2; 3];\\n\\njulia> sparse(Is, Js, Vs)\\n3\u00d73 SparseMatrixCSC{Int64,Int64} with 3 stored entries:\\n  [1, 1]  =  1\\n  [2, 2]  =  2\\n  [3, 3]  =  3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#SparseArrays.sparsevec\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"SparseArrays.sparsevec\",\n    \"category\": \"function\",\n    \"text\": \"sparsevec(I, V, [m, combine])\\n\\nCreate a sparse vector S of length m such that S[I[k]] = V[k]. Duplicates are combined using the combine function, which defaults to + if no combine argument is provided, unless the elements of V are Booleans in which case combine defaults to |.\\n\\nExamples\\n\\njulia> II = [1, 3, 3, 5]; V = [0.1, 0.2, 0.3, 0.2];\\n\\njulia> sparsevec(II, V)\\n5-element SparseVector{Float64,Int64} with 3 stored entries:\\n  [1]  =  0.1\\n  [3]  =  0.5\\n  [5]  =  0.2\\n\\njulia> sparsevec(II, V, 8, -)\\n8-element SparseVector{Float64,Int64} with 3 stored entries:\\n  [1]  =  0.1\\n  [3]  =  -0.1\\n  [5]  =  0.2\\n\\njulia> sparsevec([1, 3, 1, 2, 2], [true, true, false, false, false])\\n3-element SparseVector{Bool,Int64} with 3 stored entries:\\n  [1]  =  true\\n  [2]  =  false\\n  [3]  =  true\\n\\n\\n\\n\\n\\nsparsevec(d::Dict, [m])\\n\\nCreate a sparse vector of length m where the nonzero indices are keys from the dictionary, and the nonzero values are the values from the dictionary.\\n\\nExamples\\n\\njulia> sparsevec(Dict(1 => 3, 2 => 2))\\n2-element SparseVector{Int64,Int64} with 2 stored entries:\\n  [1]  =  3\\n  [2]  =  2\\n\\n\\n\\n\\n\\nsparsevec(A)\\n\\nConvert a vector A into a sparse vector of length m.\\n\\nExamples\\n\\njulia> sparsevec([1.0, 2.0, 0.0, 0.0, 3.0, 0.0])\\n6-element SparseVector{Float64,Int64} with 3 stored entries:\\n  [1]  =  1.0\\n  [2]  =  2.0\\n  [5]  =  3.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#SparseArrays.issparse\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"SparseArrays.issparse\",\n    \"category\": \"function\",\n    \"text\": \"issparse(S)\\n\\nReturns true if S is sparse, and false otherwise.\\n\\nExamples\\n\\njulia> sv = sparsevec([1, 4], [2.3, 2.2], 10)\\n10-element SparseVector{Float64,Int64} with 2 stored entries:\\n  [1 ]  =  2.3\\n  [4 ]  =  2.2\\n\\njulia> issparse(sv)\\ntrue\\n\\njulia> issparse(Array(sv))\\nfalse\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#SparseArrays.nnz\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"SparseArrays.nnz\",\n    \"category\": \"function\",\n    \"text\": \"nnz(A)\\n\\nReturns the number of stored (filled) elements in a sparse array.\\n\\nExamples\\n\\njulia> A = sparse(2I, 3, 3)\\n3\u00d73 SparseMatrixCSC{Int64,Int64} with 3 stored entries:\\n  [1, 1]  =  2\\n  [2, 2]  =  2\\n  [3, 3]  =  2\\n\\njulia> nnz(A)\\n3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#SparseArrays.findnz\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"SparseArrays.findnz\",\n    \"category\": \"function\",\n    \"text\": \"findnz(A)\\n\\nReturn a tuple (I, J, V) where I and J are the row and column indices of the stored (\\\"structurally non-zero\\\") values in sparse matrix A, and V is a vector of the values.\\n\\nExamples\\n\\njulia> A = sparse([1 2 0; 0 0 3; 0 4 0])\\n3\u00d73 SparseMatrixCSC{Int64,Int64} with 4 stored entries:\\n  [1, 1]  =  1\\n  [1, 2]  =  2\\n  [3, 2]  =  4\\n  [2, 3]  =  3\\n\\njulia> findnz(A)\\n([1, 1, 3, 2], [1, 2, 2, 3], [1, 2, 4, 3])\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#SparseArrays.spzeros\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"SparseArrays.spzeros\",\n    \"category\": \"function\",\n    \"text\": \"spzeros([type,]m[,n])\\n\\nCreate a sparse vector of length m or sparse matrix of size m x n. This sparse array will not contain any nonzero values. No storage will be allocated for nonzero values during construction. The type defaults to Float64 if not specified.\\n\\nExamples\\n\\njulia> spzeros(3, 3)\\n3\u00d73 SparseMatrixCSC{Float64,Int64} with 0 stored entries\\n\\njulia> spzeros(Float32, 4)\\n4-element SparseVector{Float32,Int64} with 0 stored entries\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#SparseArrays.spdiagm\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"SparseArrays.spdiagm\",\n    \"category\": \"function\",\n    \"text\": \"spdiagm(kv::Pair{<:Integer,<:AbstractVector}...)\\n\\nConstruct a square sparse diagonal matrix from Pairs of vectors and diagonals. Vector kv.second will be placed on the kv.first diagonal.\\n\\nExamples\\n\\njulia> spdiagm(-1 => [1,2,3,4], 1 => [4,3,2,1])\\n5\u00d75 SparseMatrixCSC{Int64,Int64} with 8 stored entries:\\n  [2, 1]  =  1\\n  [1, 2]  =  4\\n  [3, 2]  =  2\\n  [2, 3]  =  3\\n  [4, 3]  =  3\\n  [3, 4]  =  2\\n  [5, 4]  =  4\\n  [4, 5]  =  1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#SparseArrays.blockdiag\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"SparseArrays.blockdiag\",\n    \"category\": \"function\",\n    \"text\": \"blockdiag(A...)\\n\\nConcatenate matrices block-diagonally. Currently only implemented for sparse matrices.\\n\\nExamples\\n\\njulia> blockdiag(sparse(2I, 3, 3), sparse(4I, 2, 2))\\n5\u00d75 SparseMatrixCSC{Int64,Int64} with 5 stored entries:\\n  [1, 1]  =  2\\n  [2, 2]  =  2\\n  [3, 3]  =  2\\n  [4, 4]  =  4\\n  [5, 5]  =  4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#SparseArrays.sprand\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"SparseArrays.sprand\",\n    \"category\": \"function\",\n    \"text\": \"sprand([rng],[type],m,[n],p::AbstractFloat,[rfn])\\n\\nCreate a random length m sparse vector or m by n sparse matrix, in which the probability of any element being nonzero is independently given by p (and hence the mean density of nonzeros is also exactly p). Nonzero values are sampled from the distribution specified by rfn and have the type type. The uniform distribution is used in case rfn is not specified. The optional rng argument specifies a random number generator, see Random Numbers.\\n\\nExamples\\n\\njulia> sprand(Bool, 2, 2, 0.5)\\n2\u00d72 SparseMatrixCSC{Bool,Int64} with 2 stored entries:\\n  [1, 1]  =  true\\n  [2, 1]  =  true\\n\\njulia> sprand(Float64, 3, 0.75)\\n3-element SparseVector{Float64,Int64} with 1 stored entry:\\n  [3]  =  0.298614\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#SparseArrays.sprandn\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"SparseArrays.sprandn\",\n    \"category\": \"function\",\n    \"text\": \"sprandn([rng], m[,n],p::AbstractFloat)\\n\\nCreate a random sparse vector of length m or sparse matrix of size m by n with the specified (independent) probability p of any entry being nonzero, where nonzero values are sampled from the normal distribution. The optional rng argument specifies a random number generator, see Random Numbers.\\n\\nExamples\\n\\njulia> sprandn(2, 2, 0.75)\\n2\u00d72 SparseMatrixCSC{Float64,Int64} with 2 stored entries:\\n  [1, 1]  =  0.586617\\n  [1, 2]  =  0.297336\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#SparseArrays.nonzeros\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"SparseArrays.nonzeros\",\n    \"category\": \"function\",\n    \"text\": \"nonzeros(A)\\n\\nReturn a vector of the structural nonzero values in sparse array A. This includes zeros that are explicitly stored in the sparse array. The returned vector points directly to the internal nonzero storage of A, and any modifications to the returned vector will mutate A as well. See rowvals and nzrange.\\n\\nExamples\\n\\njulia> A = sparse(2I, 3, 3)\\n3\u00d73 SparseMatrixCSC{Int64,Int64} with 3 stored entries:\\n  [1, 1]  =  2\\n  [2, 2]  =  2\\n  [3, 3]  =  2\\n\\njulia> nonzeros(A)\\n3-element Array{Int64,1}:\\n 2\\n 2\\n 2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#SparseArrays.rowvals\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"SparseArrays.rowvals\",\n    \"category\": \"function\",\n    \"text\": \"rowvals(A::SparseMatrixCSC)\\n\\nReturn a vector of the row indices of A. Any modifications to the returned vector will mutate A as well. Providing access to how the row indices are stored internally can be useful in conjunction with iterating over structural nonzero values. See also nonzeros and nzrange.\\n\\nExamples\\n\\njulia> A = sparse(2I, 3, 3)\\n3\u00d73 SparseMatrixCSC{Int64,Int64} with 3 stored entries:\\n  [1, 1]  =  2\\n  [2, 2]  =  2\\n  [3, 3]  =  2\\n\\njulia> rowvals(A)\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#SparseArrays.nzrange\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"SparseArrays.nzrange\",\n    \"category\": \"function\",\n    \"text\": \"nzrange(A::SparseMatrixCSC, col::Integer)\\n\\nReturn the range of indices to the structural nonzero values of a sparse matrix column. In conjunction with nonzeros and rowvals, this allows for convenient iterating over a sparse matrix :\\n\\nA = sparse(I,J,V)\\nrows = rowvals(A)\\nvals = nonzeros(A)\\nm, n = size(A)\\nfor i = 1:n\\n   for j in nzrange(A, i)\\n      row = rows[j]\\n      val = vals[j]\\n      # perform sparse wizardry...\\n   end\\nend\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#SparseArrays.dropzeros!\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"SparseArrays.dropzeros!\",\n    \"category\": \"function\",\n    \"text\": \"dropzeros!(A::SparseMatrixCSC; trim::Bool = true)\\n\\nRemoves stored numerical zeros from A, optionally trimming resulting excess space from A.rowval and A.nzval when trim is true.\\n\\nFor an out-of-place version, see dropzeros. For algorithmic information, see fkeep!.\\n\\n\\n\\n\\n\\ndropzeros!(x::SparseVector; trim::Bool = true)\\n\\nRemoves stored numerical zeros from x, optionally trimming resulting excess space from x.nzind and x.nzval when trim is true.\\n\\nFor an out-of-place version, see dropzeros. For algorithmic information, see fkeep!.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#SparseArrays.dropzeros\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"SparseArrays.dropzeros\",\n    \"category\": \"function\",\n    \"text\": \"dropzeros(A::SparseMatrixCSC; trim::Bool = true)\\n\\nGenerates a copy of A and removes stored numerical zeros from that copy, optionally trimming excess space from the result\\'s rowval and nzval arrays when trim is true.\\n\\nFor an in-place version and algorithmic information, see dropzeros!.\\n\\nExamples\\n\\njulia> A = sparse([1, 2, 3], [1, 2, 3], [1.0, 0.0, 1.0])\\n3\u00d73 SparseMatrixCSC{Float64,Int64} with 3 stored entries:\\n  [1, 1]  =  1.0\\n  [2, 2]  =  0.0\\n  [3, 3]  =  1.0\\n\\njulia> dropzeros(A)\\n3\u00d73 SparseMatrixCSC{Float64,Int64} with 2 stored entries:\\n  [1, 1]  =  1.0\\n  [3, 3]  =  1.0\\n\\n\\n\\n\\n\\ndropzeros(x::SparseVector; trim::Bool = true)\\n\\nGenerates a copy of x and removes numerical zeros from that copy, optionally trimming excess space from the result\\'s nzind and nzval arrays when trim is true.\\n\\nFor an in-place version and algorithmic information, see dropzeros!.\\n\\nExamples\\n\\njulia> A = sparsevec([1, 2, 3], [1.0, 0.0, 1.0])\\n3-element SparseVector{Float64,Int64} with 3 stored entries:\\n  [1]  =  1.0\\n  [2]  =  0.0\\n  [3]  =  1.0\\n\\njulia> dropzeros(A)\\n3-element SparseVector{Float64,Int64} with 2 stored entries:\\n  [1]  =  1.0\\n  [3]  =  1.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#SparseArrays.permute\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"SparseArrays.permute\",\n    \"category\": \"function\",\n    \"text\": \"permute(A::SparseMatrixCSC{Tv,Ti}, p::AbstractVector{<:Integer},\\n        q::AbstractVector{<:Integer}) where {Tv,Ti}\\n\\nBilaterally permute A, returning PAQ (A[p,q]). Column-permutation q\\'s length must match A\\'s column count (length(q) == A.n). Row-permutation p\\'s length must match A\\'s row count (length(p) == A.m).\\n\\nFor expert drivers and additional information, see permute!.\\n\\nExamples\\n\\njulia> A = spdiagm(0 => [1, 2, 3, 4], 1 => [5, 6, 7])\\n4\u00d74 SparseMatrixCSC{Int64,Int64} with 7 stored entries:\\n  [1, 1]  =  1\\n  [1, 2]  =  5\\n  [2, 2]  =  2\\n  [2, 3]  =  6\\n  [3, 3]  =  3\\n  [3, 4]  =  7\\n  [4, 4]  =  4\\n\\njulia> permute(A, [4, 3, 2, 1], [1, 2, 3, 4])\\n4\u00d74 SparseMatrixCSC{Int64,Int64} with 7 stored entries:\\n  [4, 1]  =  1\\n  [3, 2]  =  2\\n  [4, 2]  =  5\\n  [2, 3]  =  3\\n  [3, 3]  =  6\\n  [1, 4]  =  4\\n  [2, 4]  =  7\\n\\njulia> permute(A, [1, 2, 3, 4], [4, 3, 2, 1])\\n4\u00d74 SparseMatrixCSC{Int64,Int64} with 7 stored entries:\\n  [3, 1]  =  7\\n  [4, 1]  =  4\\n  [2, 2]  =  6\\n  [3, 2]  =  3\\n  [1, 3]  =  5\\n  [2, 3]  =  2\\n  [1, 4]  =  1\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#Base.permute!-Union{Tuple{Tq}, Tuple{Tp}, Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixCSC{Tv,Ti},SparseMatrixCSC{Tv,Ti},AbstractArray{Tp,1},AbstractArray{Tq,1}}} where Tq<:Integer where Tp<:Integer where Ti where Tv\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"Base.permute!\",\n    \"category\": \"method\",\n    \"text\": \"permute!(X::SparseMatrixCSC{Tv,Ti}, A::SparseMatrixCSC{Tv,Ti},\\n         p::AbstractVector{<:Integer}, q::AbstractVector{<:Integer},\\n         [C::SparseMatrixCSC{Tv,Ti}]) where {Tv,Ti}\\n\\nBilaterally permute A, storing result PAQ (A[p,q]) in X. Stores intermediate result (AQ)^T (transpose(A[:,q])) in optional argument C if present. Requires that none of X, A, and, if present, C alias each other; to store result PAQ back into A, use the following method lacking X:\\n\\npermute!(A::SparseMatrixCSC{Tv,Ti}, p::AbstractVector{<:Integer},\\n         q::AbstractVector{<:Integer}[, C::SparseMatrixCSC{Tv,Ti},\\n         [workcolptr::Vector{Ti}]]) where {Tv,Ti}\\n\\nX\\'s dimensions must match those of A (X.m == A.m and X.n == A.n), and X must have enough storage to accommodate all allocated entries in A (length(X.rowval) >= nnz(A) and length(X.nzval) >= nnz(A)). Column-permutation q\\'s length must match A\\'s column count (length(q) == A.n). Row-permutation p\\'s length must match A\\'s row count (length(p) == A.m).\\n\\nC\\'s dimensions must match those of transpose(A) (C.m == A.n and C.n == A.m), and C must have enough storage to accommodate all allocated entries in A (length(C.rowval) >= nnz(A) and length(C.nzval) >= nnz(A)).\\n\\nFor additional (algorithmic) information, and for versions of these methods that forgo argument checking, see (unexported) parent methods unchecked_noalias_permute! and unchecked_aliasing_permute!.\\n\\nSee also: permute.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/SparseArrays.html#stdlib-sparse-arrays-1\",\n    \"page\": \"Sparse Arrays\",\n    \"title\": \"Sparse Arrays\",\n    \"category\": \"section\",\n    \"text\": \"SparseArrays.SparseVector\\nSparseArrays.SparseMatrixCSC\\nSparseArrays.sparse\\nSparseArrays.sparsevec\\nSparseArrays.issparse\\nSparseArrays.nnz\\nSparseArrays.findnz\\nSparseArrays.spzeros\\nSparseArrays.spdiagm\\nSparseArrays.blockdiag\\nSparseArrays.sprand\\nSparseArrays.sprandn\\nSparseArrays.nonzeros\\nSparseArrays.rowvals\\nSparseArrays.nzrange\\nSparseArrays.dropzeros!\\nSparseArrays.dropzeros\\nSparseArrays.permute\\npermute!{Tv, Ti, Tp <: Integer, Tq <: Integer}(::SparseMatrixCSC{Tv,Ti}, ::SparseMatrixCSC{Tv,Ti}, ::AbstractArray{Tp,1}, ::AbstractArray{Tq,1})DocTestSetup = nothing\"\n},\n\n{\n    \"location\": \"stdlib/Statistics.html#\",\n    \"page\": \"Statistics\",\n    \"title\": \"Statistics\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Statistics.html#Statistics.std\",\n    \"page\": \"Statistics\",\n    \"title\": \"Statistics.std\",\n    \"category\": \"function\",\n    \"text\": \"std(v; corrected::Bool=true, mean=nothing, dims)\\n\\nCompute the sample standard deviation of a vector or array v, optionally along the given dimensions. The algorithm returns an estimator of the generative distribution\\'s standard deviation under the assumption that each entry of v is an IID drawn from that generative distribution. This computation is equivalent to calculating sqrt(sum((v - mean(v)).^2) / (length(v) - 1)). A pre-computed mean may be provided. If corrected is true, then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n = length(x).\\n\\nnote: Note\\nIf array contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the standard deviation of non-missing values.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Statistics.html#Statistics.stdm\",\n    \"page\": \"Statistics\",\n    \"title\": \"Statistics.stdm\",\n    \"category\": \"function\",\n    \"text\": \"stdm(v, m; corrected::Bool=true)\\n\\nCompute the sample standard deviation of a vector v with known mean m. If corrected is true, then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n = length(x).\\n\\nnote: Note\\nIf array contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the standard deviation of non-missing values.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Statistics.html#Statistics.var\",\n    \"page\": \"Statistics\",\n    \"title\": \"Statistics.var\",\n    \"category\": \"function\",\n    \"text\": \"var(v; dims, corrected::Bool=true, mean=nothing)\\n\\nCompute the sample variance of a vector or array v, optionally along the given dimensions. The algorithm will return an estimator of the generative distribution\\'s variance under the assumption that each entry of v is an IID drawn from that generative distribution. This computation is equivalent to calculating sum(abs2, v - mean(v)) / (length(v) - 1). If corrected is true, then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n = length(x). The mean mean over the region may be provided.\\n\\nnote: Note\\nIf array contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the variance of non-missing values.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Statistics.html#Statistics.varm\",\n    \"page\": \"Statistics\",\n    \"title\": \"Statistics.varm\",\n    \"category\": \"function\",\n    \"text\": \"varm(v, m; dims, corrected::Bool=true)\\n\\nCompute the sample variance of a collection v with known mean(s) m, optionally over the given dimensions. m may contain means for each dimension of v. If corrected is true, then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n = length(x).\\n\\nnote: Note\\nIf array contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the variance of non-missing values.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Statistics.html#Statistics.cor\",\n    \"page\": \"Statistics\",\n    \"title\": \"Statistics.cor\",\n    \"category\": \"function\",\n    \"text\": \"cor(x::AbstractVector)\\n\\nReturn the number one.\\n\\n\\n\\n\\n\\ncor(X::AbstractMatrix; dims::Int=1)\\n\\nCompute the Pearson correlation matrix of the matrix X along the dimension dims.\\n\\n\\n\\n\\n\\ncor(x::AbstractVector, y::AbstractVector)\\n\\nCompute the Pearson correlation between the vectors x and y.\\n\\n\\n\\n\\n\\ncor(X::AbstractVecOrMat, Y::AbstractVecOrMat; dims=1)\\n\\nCompute the Pearson correlation between the vectors or matrices X and Y along the dimension dims.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Statistics.html#Statistics.cov\",\n    \"page\": \"Statistics\",\n    \"title\": \"Statistics.cov\",\n    \"category\": \"function\",\n    \"text\": \"cov(x::AbstractVector; corrected::Bool=true)\\n\\nCompute the variance of the vector x. If corrected is true (the default) then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n = length(x).\\n\\n\\n\\n\\n\\ncov(X::AbstractMatrix; dims::Int=1, corrected::Bool=true)\\n\\nCompute the covariance matrix of the matrix X along the dimension dims. If corrected is true (the default) then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n = size(X, dims).\\n\\n\\n\\n\\n\\ncov(x::AbstractVector, y::AbstractVector; corrected::Bool=true)\\n\\nCompute the covariance between the vectors x and y. If corrected is true (the default), computes frac1n-1sum_i=1^n (x_i-bar x) (y_i-bar y)^* where * denotes the complex conjugate and n = length(x) = length(y). If corrected is false, computes frac1nsum_i=1^n (x_i-bar x) (y_i-bar y)^*.\\n\\n\\n\\n\\n\\ncov(X::AbstractVecOrMat, Y::AbstractVecOrMat; dims::Int=1, corrected::Bool=true)\\n\\nCompute the covariance between the vectors or matrices X and Y along the dimension dims. If corrected is true (the default) then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n = size(X, dims) = size(Y, dims).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Statistics.html#Statistics.mean!\",\n    \"page\": \"Statistics\",\n    \"title\": \"Statistics.mean!\",\n    \"category\": \"function\",\n    \"text\": \"mean!(r, v)\\n\\nCompute the mean of v over the singleton dimensions of r, and write results to r.\\n\\nExamples\\n\\njulia> v = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> mean!([1., 1.], v)\\n2-element Array{Float64,1}:\\n 1.5\\n 3.5\\n\\njulia> mean!([1. 1.], v)\\n1\u00d72 Array{Float64,2}:\\n 2.0  3.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Statistics.html#Statistics.mean\",\n    \"page\": \"Statistics\",\n    \"title\": \"Statistics.mean\",\n    \"category\": \"function\",\n    \"text\": \"mean(itr)\\n\\nCompute the mean of all elements in a collection.\\n\\nnote: Note\\nIf itr contains NaN or missing values, the result is also NaN or missing (missing takes precedence if array contains both). Use the skipmissing function to omit missing entries and compute the mean of non-missing values.\\n\\nExamples\\n\\njulia> mean(1:20)\\n10.5\\n\\njulia> mean([1, missing, 3])\\nmissing\\n\\njulia> mean(skipmissing([1, missing, 3]))\\n2.0\\n\\n\\n\\n\\n\\nmean(f::Function, itr)\\n\\nApply the function f to each element of collection itr and take the mean.\\n\\njulia> mean(\u221a, [1, 2, 3])\\n1.3820881233139908\\n\\njulia> mean([\u221a1, \u221a2, \u221a3])\\n1.3820881233139908\\n\\n\\n\\n\\n\\nmean(A::AbstractArray; dims)\\n\\nCompute the mean of an array over the given dimensions.\\n\\nExamples\\n\\njulia> A = [1 2; 3 4]\\n2\u00d72 Array{Int64,2}:\\n 1  2\\n 3  4\\n\\njulia> mean(A, dims=1)\\n1\u00d72 Array{Float64,2}:\\n 2.0  3.0\\n\\njulia> mean(A, dims=2)\\n2\u00d71 Array{Float64,2}:\\n 1.5\\n 3.5\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Statistics.html#Statistics.median!\",\n    \"page\": \"Statistics\",\n    \"title\": \"Statistics.median!\",\n    \"category\": \"function\",\n    \"text\": \"median!(v)\\n\\nLike median, but may overwrite the input vector.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Statistics.html#Statistics.median\",\n    \"page\": \"Statistics\",\n    \"title\": \"Statistics.median\",\n    \"category\": \"function\",\n    \"text\": \"median(itr)\\n\\nCompute the median of all elements in a collection. For an even number of elements no exact median element exists, so the result is equivalent to calculating mean of two median elements.\\n\\nnote: Note\\nIf itr contains NaN or missing values, the result is also NaN or missing (missing takes precedence if itr contains both). Use the skipmissing function to omit missing entries and compute the median of non-missing values.\\n\\nExamples\\n\\njulia> median([1, 2, 3])\\n2.0\\n\\njulia> median([1, 2, 3, 4])\\n2.5\\n\\njulia> median([1, 2, missing, 4])\\nmissing\\n\\njulia> median(skipmissing([1, 2, missing, 4]))\\n2.0\\n\\n\\n\\n\\n\\nmedian(A::AbstractArray; dims)\\n\\nCompute the median of an array along the given dimensions.\\n\\nExamples\\n\\njulia> median([1 2; 3 4], dims=1)\\n1\u00d72 Array{Float64,2}:\\n 2.0  3.0\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Statistics.html#Statistics.middle\",\n    \"page\": \"Statistics\",\n    \"title\": \"Statistics.middle\",\n    \"category\": \"function\",\n    \"text\": \"middle(x)\\n\\nCompute the middle of a scalar value, which is equivalent to x itself, but of the type of middle(x, x) for consistency.\\n\\n\\n\\n\\n\\nmiddle(x, y)\\n\\nCompute the middle of two reals x and y, which is equivalent in both value and type to computing their mean ((x + y) / 2).\\n\\n\\n\\n\\n\\nmiddle(range)\\n\\nCompute the middle of a range, which consists of computing the mean of its extrema. Since a range is sorted, the mean is performed with the first and last element.\\n\\njulia> middle(1:10)\\n5.5\\n\\n\\n\\n\\n\\nmiddle(a)\\n\\nCompute the middle of an array a, which consists of finding its extrema and then computing their mean.\\n\\njulia> a = [1,2,3.6,10.9]\\n4-element Array{Float64,1}:\\n  1.0\\n  2.0\\n  3.6\\n 10.9\\n\\njulia> middle(a)\\n5.95\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Statistics.html#Statistics.quantile!\",\n    \"page\": \"Statistics\",\n    \"title\": \"Statistics.quantile!\",\n    \"category\": \"function\",\n    \"text\": \"quantile!([q::AbstractArray, ] v::AbstractVector, p; sorted=false)\\n\\nCompute the quantile(s) of a vector v at a specified probability or vector or tuple of probabilities p on the interval [0,1]. If p is a vector, an optional output array q may also be specified. (If not provided, a new output array is created.) The keyword argument sorted indicates whether v can be assumed to be sorted; if false (the default), then the elements of v will be partially sorted in-place.\\n\\nQuantiles are computed via linear interpolation between the points ((k-1)/(n-1), v[k]), for k = 1:n where n = length(v). This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.\\n\\nnote: Note\\nAn ArgumentError is thrown if v contains NaN or missing values.\\n\\nHyndman, R.J and Fan, Y. (1996) \\\"Sample Quantiles in Statistical Packages\\\", The American Statistician, Vol. 50, No. 4, pp. 361-365\\n\\nExamples\\n\\njulia> x = [3, 2, 1];\\n\\njulia> quantile!(x, 0.5)\\n2.0\\n\\njulia> x\\n3-element Array{Int64,1}:\\n 1\\n 2\\n 3\\n\\njulia> y = zeros(3);\\n\\njulia> quantile!(y, x, [0.1, 0.5, 0.9]) === y\\ntrue\\n\\njulia> y\\n3-element Array{Float64,1}:\\n 1.2\\n 2.0\\n 2.8\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Statistics.html#Statistics.quantile\",\n    \"page\": \"Statistics\",\n    \"title\": \"Statistics.quantile\",\n    \"category\": \"function\",\n    \"text\": \"quantile(itr, p; sorted=false)\\n\\nCompute the quantile(s) of a collection itr at a specified probability or vector or tuple of probabilities p on the interval [0,1]. The keyword argument sorted indicates whether itr can be assumed to be sorted.\\n\\nQuantiles are computed via linear interpolation between the points ((k-1)/(n-1), v[k]), for k = 1:n where n = length(v). This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.\\n\\nnote: Note\\nAn ArgumentError is thrown if itr contains NaN or missing values. Use the skipmissing function to omit missing entries and compute the quantiles of non-missing values.\\n\\nHyndman, R.J and Fan, Y. (1996) \\\"Sample Quantiles in Statistical Packages\\\", The American Statistician, Vol. 50, No. 4, pp. 361-365\\n\\nExamples\\n\\n```jldoctest julia> quantile(0:20, 0.5) 10.0\\n\\njulia> quantile(0:20, [0.1, 0.5, 0.9]) 3-element Array{Float64,1}:   2.0  10.0  18.0\\n\\njulia> quantile(skipmissing([1, 10, missing]), 0.5) 5.5  ```\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Statistics.html#Statistics-1\",\n    \"page\": \"Statistics\",\n    \"title\": \"Statistics\",\n    \"category\": \"section\",\n    \"text\": \"DocTestSetup = :(using Statistics)The Statistics module contains basic statistics functionality.Statistics.std\\nStatistics.stdm\\nStatistics.var\\nStatistics.varm\\nStatistics.cor\\nStatistics.cov\\nStatistics.mean!\\nStatistics.mean\\nStatistics.median!\\nStatistics.median\\nStatistics.middle\\nStatistics.quantile!\\nStatistics.quantileDocTestSetup = nothing\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Unit Testing\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Unit-Testing-1\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Unit Testing\",\n    \"category\": \"section\",\n    \"text\": \"DocTestSetup = :(using Test)\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Base.runtests\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Base.runtests\",\n    \"category\": \"function\",\n    \"text\": \"Base.runtests(tests=[\\\"all\\\"]; ncores=ceil(Int, Sys.CPU_THREADS / 2),\\n              exit_on_error=false, [seed])\\n\\nRun the Julia unit tests listed in tests, which can be either a string or an array of strings, using ncores processors. If exit_on_error is false, when one test fails, all remaining tests in other files will still be run; they are otherwise discarded, when exit_on_error == true. If a seed is provided via the keyword argument, it is used to seed the global RNG in the context where the tests are run; otherwise the seed is chosen randomly.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Testing-Base-Julia-1\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Testing Base Julia\",\n    \"category\": \"section\",\n    \"text\": \"Julia is under rapid development and has an extensive test suite to verify functionality across multiple platforms. If you build Julia from source, you can run this test suite with make test. In a binary install, you can run the test suite using Base.runtests().Base.runtests\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Test.@test\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Test.@test\",\n    \"category\": \"macro\",\n    \"text\": \"@test ex\\n@test f(args...) key=val ...\\n\\nTests that the expression ex evaluates to true. Returns a Pass Result if it does, a Fail Result if it is false, and an Error Result if it could not be evaluated.\\n\\nExamples\\n\\njulia> @test true\\nTest Passed\\n\\njulia> @test [1, 2] + [2, 1] == [3, 3]\\nTest Passed\\n\\nThe @test f(args...) key=val... form is equivalent to writing @test f(args..., key=val...) which can be useful when the expression is a call using infix syntax such as approximate comparisons:\\n\\njulia> @test \u03c0 \u2248 3.14 atol=0.01\\nTest Passed\\n\\nThis is equivalent to the uglier test @test \u2248(\u03c0, 3.14, atol=0.01). It is an error to supply more than one expression unless the first is a call expression and the rest are assignments (k=v).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Test.@test_throws\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Test.@test_throws\",\n    \"category\": \"macro\",\n    \"text\": \"@test_throws exception expr\\n\\nTests that the expression expr throws exception. The exception may specify either a type, or a value (which will be tested for equality by comparing fields). Note that @test_throws does not support a trailing keyword form.\\n\\nExamples\\n\\njulia> @test_throws BoundsError [1, 2, 3][4]\\nTest Passed\\n      Thrown: BoundsError\\n\\njulia> @test_throws DimensionMismatch [1, 2, 3] + [1, 2]\\nTest Passed\\n      Thrown: DimensionMismatch\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Basic-Unit-Tests-1\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Basic Unit Tests\",\n    \"category\": \"section\",\n    \"text\": \"The Test module provides simple unit testing functionality. Unit testing is a way to see if your code is correct by checking that the results are what you expect. It can be helpful to ensure your code still works after you make changes, and can be used when developing as a way of specifying the behaviors your code should have when complete.Simple unit testing can be performed with the @test and @test_throws macros:Test.@test\\nTest.@test_throwsFor example, suppose we want to check our new function foo(x) works as expected:julia> using Test\\n\\njulia> foo(x) = length(x)^2\\nfoo (generic function with 1 method)If the condition is true, a Pass is returned:julia> @test foo(\\\"bar\\\") == 9\\nTest Passed\\n\\njulia> @test foo(\\\"fizz\\\") >= 10\\nTest PassedIf the condition is false, then a Fail is returned and an exception is thrown:julia> @test foo(\\\"f\\\") == 20\\nTest Failed at none:1\\n  Expression: foo(\\\"f\\\") == 20\\n   Evaluated: 1 == 20\\nERROR: There was an error during testingIf the condition could not be evaluated because an exception was thrown, which occurs in this case because length is not defined for symbols, an Error object is returned and an exception is thrown:julia> @test foo(:cat) == 1\\nError During Test\\n  Test threw an exception of type MethodError\\n  Expression: foo(:cat) == 1\\n  MethodError: no method matching length(::Symbol)\\n  Closest candidates are:\\n    length(::SimpleVector) at essentials.jl:256\\n    length(::Base.MethodList) at reflection.jl:521\\n    length(::MethodTable) at reflection.jl:597\\n    ...\\n  Stacktrace:\\n  [...]\\nERROR: There was an error during testingIf we expect that evaluating an expression should throw an exception, then we can use @test_throws to check that this occurs:julia> @test_throws MethodError foo(:cat)\\nTest Passed\\n      Thrown: MethodError\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Test.@testset\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Test.@testset\",\n    \"category\": \"macro\",\n    \"text\": \"@testset [CustomTestSet] [option=val  ...] [\\\"description\\\"] begin ... end\\n@testset [CustomTestSet] [option=val  ...] [\\\"description $v\\\"] for v in (...) ... end\\n@testset [CustomTestSet] [option=val  ...] [\\\"description $v, $w\\\"] for v in (...), w in (...) ... end\\n\\nStarts a new test set, or multiple test sets if a for loop is provided.\\n\\nIf no custom testset type is given it defaults to creating a DefaultTestSet. DefaultTestSet records all the results and, if there are any Fails or Errors, throws an exception at the end of the top-level (non-nested) test set, along with a summary of the test results.\\n\\nAny custom testset type (subtype of AbstractTestSet) can be given and it will also be used for any nested @testset invocations. The given options are only applied to the test set where they are given. The default test set type does not take any options.\\n\\nThe description string accepts interpolation from the loop indices. If no description is provided, one is constructed based on the variables.\\n\\nBy default the @testset macro will return the testset object itself, though this behavior can be customized in other testset types. If a for loop is used then the macro collects and returns a list of the return values of the finish method, which by default will return a list of the testset objects used in each iteration.\\n\\nBefore the execution of the body of a @testset, there is an implicit call to Random.seed!(seed) where seed is the current seed of the global RNG. Moreover, after the execution of the body, the state of the global RNG is restored to what it was before the @testset. This is meant to ease reproducibility in case of failure, and to allow seamless re-arrangements of @testsets regardless of their side-effect on the global RNG state.\\n\\nExamples\\n\\njulia> @testset \\\"trigonometric identities\\\" begin\\n           \u03b8 = 2/3*\u03c0\\n           @test sin(-\u03b8) \u2248 -sin(\u03b8)\\n           @test cos(-\u03b8) \u2248 cos(\u03b8)\\n           @test sin(2\u03b8) \u2248 2*sin(\u03b8)*cos(\u03b8)\\n           @test cos(2\u03b8) \u2248 cos(\u03b8)^2 - sin(\u03b8)^2\\n       end;\\nTest Summary:            | Pass  Total\\ntrigonometric identities |    4      4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Working-with-Test-Sets-1\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Working with Test Sets\",\n    \"category\": \"section\",\n    \"text\": \"Typically a large number of tests are used to make sure functions work correctly over a range of inputs. In the event a test fails, the default behavior is to throw an exception immediately. However, it is normally preferable to run the rest of the tests first to get a better picture of how many errors there are in the code being tested.The @testset macro can be used to group tests into sets. All the tests in a test set will be run, and at the end of the test set a summary will be printed. If any of the tests failed, or could not be evaluated due to an error, the test set will then throw a TestSetException.Test.@testsetWe can put our tests for the foo(x) function in a test set:julia> @testset \\\"Foo Tests\\\" begin\\n           @test foo(\\\"a\\\")   == 1\\n           @test foo(\\\"ab\\\")  == 4\\n           @test foo(\\\"abc\\\") == 9\\n       end;\\nTest Summary: | Pass  Total\\nFoo Tests     |    3      3Test sets can also be nested:julia> @testset \\\"Foo Tests\\\" begin\\n           @testset \\\"Animals\\\" begin\\n               @test foo(\\\"cat\\\") == 9\\n               @test foo(\\\"dog\\\") == foo(\\\"cat\\\")\\n           end\\n           @testset \\\"Arrays $i\\\" for i in 1:3\\n               @test foo(zeros(i)) == i^2\\n               @test foo(fill(1.0, i)) == i^2\\n           end\\n       end;\\nTest Summary: | Pass  Total\\nFoo Tests     |    8      8In the event that a nested test set has no failures, as happened here, it will be hidden in the summary. If we do have a test failure, only the details for the failed test sets will be shown:julia> @testset \\\"Foo Tests\\\" begin\\n           @testset \\\"Animals\\\" begin\\n               @testset \\\"Felines\\\" begin\\n                   @test foo(\\\"cat\\\") == 9\\n               end\\n               @testset \\\"Canines\\\" begin\\n                   @test foo(\\\"dog\\\") == 9\\n               end\\n           end\\n           @testset \\\"Arrays\\\" begin\\n               @test foo(zeros(2)) == 4\\n               @test foo(fill(1.0, 4)) == 15\\n           end\\n       end\\n\\nArrays: Test Failed\\n  Expression: foo(fill(1.0, 4)) == 15\\n   Evaluated: 16 == 15\\n[...]\\nTest Summary: | Pass  Fail  Total\\nFoo Tests     |    3     1      4\\n  Animals     |    2            2\\n  Arrays      |    1     1      2\\nERROR: Some tests did not pass: 3 passed, 1 failed, 0 errored, 0 broken.\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Test.@inferred\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Test.@inferred\",\n    \"category\": \"macro\",\n    \"text\": \"@inferred f(x)\\n\\nTests that the call expression f(x) returns a value of the same type inferred by the compiler. It is useful to check for type stability.\\n\\nf(x) can be any call expression. Returns the result of f(x) if the types match, and an Error Result if it finds different types.\\n\\njulia> f(a, b, c) = b > 1 ? 1 : 1.0\\nf (generic function with 1 method)\\n\\njulia> typeof(f(1, 2, 3))\\nInt64\\n\\njulia> @code_warntype f(1, 2, 3)\\nBody::UNION{FLOAT64, INT64}\\n1 1 \u2500 %1 = (Base.slt_int)(1, b)::Bool\\n  \u2514\u2500\u2500      goto #3 if not %1\\n  2 \u2500      return 1\\n  3 \u2500      return 1.0\\n\\njulia> @inferred f(1, 2, 3)\\nERROR: return type Int64 does not match inferred return type Union{Float64, Int64}\\nStacktrace:\\n[...]\\n\\njulia> @inferred max(1, 2)\\n2\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Test.@test_logs\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Test.@test_logs\",\n    \"category\": \"macro\",\n    \"text\": \"@test_logs [log_patterns...] [keywords] expression\\n\\nCollect a list of log records generated by expression using collect_test_logs, check that they match the sequence log_patterns, and return the value of expression.  The keywords provide some simple filtering of log records: the min_level keyword controls the minimum log level which will be collected for the test, the match_mode keyword defines how matching will be performed (the default :all checks that all logs and patterns match pairwise; use :any to check that the pattern matches at least once somewhere in the sequence.)\\n\\nThe most useful log pattern is a simple tuple of the form (level,message). A different number of tuple elements may be used to match other log metadata, corresponding to the arguments to passed to AbstractLogger via the handle_message function: (level,message,module,group,id,file,line). Elements which are present will be matched pairwise with the log record fields using == by default, with the special cases that Symbols may be used for the standard log levels, and Regexs in the pattern will match string or Symbol fields using occursin.\\n\\nExamples\\n\\nConsider a function which logs a warning, and several debug messages:\\n\\nfunction foo(n)\\n    @info \\\"Doing foo with n=$n\\\"\\n    for i=1:n\\n        @debug \\\"Iteration $i\\\"\\n    end\\n    42\\nend\\n\\nWe can test the info message using\\n\\n@test_logs (:info,\\\"Doing foo with n=2\\\") foo(2)\\n\\nIf we also wanted to test the debug messages, these need to be enabled with the min_level keyword:\\n\\n@test_logs (:info,\\\"Doing foo with n=2\\\") (:debug,\\\"Iteration 1\\\") (:debug,\\\"Iteration 2\\\") min_level=Debug foo(2)\\n\\nThe macro may be chained with @test to also test the returned value:\\n\\n@test (@test_logs (:info,\\\"Doing foo with n=2\\\") foo(2)) == 42\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Test.@test_deprecated\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Test.@test_deprecated\",\n    \"category\": \"macro\",\n    \"text\": \"@test_deprecated [pattern] expression\\n\\nWhen --depwarn=yes, test that expression emits a deprecation warning and return the value of expression.  The log message string will be matched against pattern which defaults to r\\\"deprecated\\\"i.\\n\\nWhen --depwarn=no, simply return the result of executing expression.  When --depwarn=error, check that an ErrorException is thrown.\\n\\nExamples\\n\\n# Deprecated in julia 0.7\\n@test_deprecated num2hex(1)\\n\\n# The returned value can be tested by chaining with @test:\\n@test (@test_deprecated num2hex(1)) == \\\"0000000000000001\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Test.@test_warn\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Test.@test_warn\",\n    \"category\": \"macro\",\n    \"text\": \"@test_warn msg expr\\n\\nTest whether evaluating expr results in stderr output that contains the msg string or matches the msg regular expression.  If msg is a boolean function, tests whether msg(output) returns true.  If msg is a tuple or array, checks that the error output contains/matches each item in msg. Returns the result of evaluating expr.\\n\\nSee also @test_nowarn to check for the absence of error output.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Test.@test_nowarn\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Test.@test_nowarn\",\n    \"category\": \"macro\",\n    \"text\": \"@test_nowarn expr\\n\\nTest whether evaluating expr results in empty stderr output (no warnings or other messages).  Returns the result of evaluating expr.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Other-Test-Macros-1\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Other Test Macros\",\n    \"category\": \"section\",\n    \"text\": \"As calculations on floating-point values can be imprecise, you can perform approximate equality checks using either @test a \u2248 b (where \u2248, typed via tab completion of \\\\approx, is the isapprox function) or use isapprox directly.julia> @test 1 \u2248 0.999999999\\nTest Passed\\n\\njulia> @test 1 \u2248 0.999999\\nTest Failed at none:1\\n  Expression: 1 \u2248 0.999999\\n   Evaluated: 1 \u2248 0.999999\\nERROR: There was an error during testingTest.@inferred\\nTest.@test_logs\\nTest.@test_deprecated\\nTest.@test_warn\\nTest.@test_nowarn\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Test.@test_broken\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Test.@test_broken\",\n    \"category\": \"macro\",\n    \"text\": \"@test_broken ex\\n@test_broken f(args...) key=val ...\\n\\nIndicates a test that should pass but currently consistently fails. Tests that the expression ex evaluates to false or causes an exception. Returns a Broken Result if it does, or an Error Result if the expression evaluates to true.\\n\\nThe @test_broken f(args...) key=val... form works as for the @test macro.\\n\\nExamples\\n\\njulia> @test_broken 1 == 2\\nTest Broken\\n  Expression: 1 == 2\\n\\njulia> @test_broken 1 == 2 atol=0.1\\nTest Broken\\n  Expression: ==(1, 2, atol=0.1)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Test.@test_skip\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Test.@test_skip\",\n    \"category\": \"macro\",\n    \"text\": \"@test_skip ex\\n@test_skip f(args...) key=val ...\\n\\nMarks a test that should not be executed but should be included in test summary reporting as Broken. This can be useful for tests that intermittently fail, or tests of not-yet-implemented functionality.\\n\\nThe @test_skip f(args...) key=val... form works as for the @test macro.\\n\\nExamples\\n\\njulia> @test_skip 1 == 2\\nTest Broken\\n  Skipped: 1 == 2\\n\\njulia> @test_skip 1 == 2 atol=0.1\\nTest Broken\\n  Skipped: ==(1, 2, atol=0.1)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Broken-Tests-1\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Broken Tests\",\n    \"category\": \"section\",\n    \"text\": \"If a test fails consistently it can be changed to use the @test_broken macro. This will denote the test as Broken if the test continues to fail and alerts the user via an Error if the test succeeds.Test.@test_broken@test_skip is also available to skip a test without evaluation, but counting the skipped test in the test set reporting. The test will not run but gives a Broken Result.Test.@test_skip\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Test.record\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Test.record\",\n    \"category\": \"function\",\n    \"text\": \"record(ts::AbstractTestSet, res::Result)\\n\\nRecord a result to a testset. This function is called by the @testset infrastructure each time a contained @test macro completes, and is given the test result (which could be an Error). This will also be called with an Error if an exception is thrown inside the test block but outside of a @test context.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Test.finish\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Test.finish\",\n    \"category\": \"function\",\n    \"text\": \"finish(ts::AbstractTestSet)\\n\\nDo any final processing necessary for the given testset. This is called by the @testset infrastructure after a test block executes. One common use for this function is to record the testset to the parent\\'s results list, using get_testset.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Test.get_testset\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Test.get_testset\",\n    \"category\": \"function\",\n    \"text\": \"get_testset()\\n\\nRetrieve the active test set from the task\\'s local storage. If no test set is active, use the fallback default test set.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Test.get_testset_depth\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Test.get_testset_depth\",\n    \"category\": \"function\",\n    \"text\": \"get_testset_depth()\\n\\nReturns the number of active test sets, not including the default test set\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Test.html#Creating-Custom-AbstractTestSet-Types-1\",\n    \"page\": \"Unit Testing\",\n    \"title\": \"Creating Custom AbstractTestSet Types\",\n    \"category\": \"section\",\n    \"text\": \"Packages can create their own AbstractTestSet subtypes by implementing the record and finish methods. The subtype should have a one-argument constructor taking a description string, with any options passed in as keyword arguments.Test.record\\nTest.finishTest takes responsibility for maintaining a stack of nested testsets as they are executed, but any result accumulation is the responsibility of the AbstractTestSet subtype. You can access this stack with the get_testset and get_testset_depth methods. Note that these functions are not exported.Test.get_testset\\nTest.get_testset_depthTest also makes sure that nested @testset invocations use the same AbstractTestSet subtype as their parent unless it is set explicitly. It does not propagate any properties of the testset. Option inheritance behavior can be implemented by packages using the stack infrastructure that Test provides.Defining a basic AbstractTestSet subtype might look like:import Test: record, finish\\nusing Test: AbstractTestSet, Result, Pass, Fail, Error\\nusing Test: get_testset_depth, get_testset\\nstruct CustomTestSet <: Test.AbstractTestSet\\n    description::AbstractString\\n    foo::Int\\n    results::Vector\\n    # constructor takes a description string and options keyword arguments\\n    CustomTestSet(desc; foo=1) = new(desc, foo, [])\\nend\\n\\nrecord(ts::CustomTestSet, child::AbstractTestSet) = push!(ts.results, child)\\nrecord(ts::CustomTestSet, res::Result) = push!(ts.results, res)\\nfunction finish(ts::CustomTestSet)\\n    # just record if we\\'re not the top-level parent\\n    if get_testset_depth() > 0\\n        record(get_testset(), ts)\\n    end\\n    ts\\nendAnd using that testset looks like:@testset CustomTestSet foo=4 \\\"custom testset inner 2\\\" begin\\n    # this testset should inherit the type, but not the argument.\\n    @testset \\\"custom testset inner\\\" begin\\n        @test true\\n    end\\nendDocTestSetup = nothing\"\n},\n\n{\n    \"location\": \"stdlib/UUIDs.html#\",\n    \"page\": \"UUIDs\",\n    \"title\": \"UUIDs\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/UUIDs.html#UUIDs.uuid1\",\n    \"page\": \"UUIDs\",\n    \"title\": \"UUIDs.uuid1\",\n    \"category\": \"function\",\n    \"text\": \"uuid1([rng::AbstractRNG=GLOBAL_RNG]) -> UUID\\n\\nGenerates a version 1 (time-based) universally unique identifier (UUID), as specified by RFC 4122. Note that the Node ID is randomly generated (does not identify the host) according to section 4.5 of the RFC.\\n\\nExamples\\n\\njulia> rng = MersenneTwister(1234);\\n\\njulia> uuid1(rng)\\nUUID(\\\"cfc395e8-590f-11e8-1f13-43a2532b2fa8\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/UUIDs.html#UUIDs.uuid4\",\n    \"page\": \"UUIDs\",\n    \"title\": \"UUIDs.uuid4\",\n    \"category\": \"function\",\n    \"text\": \"uuid4([rng::AbstractRNG=GLOBAL_RNG]) -> UUID\\n\\nGenerates a version 4 (random or pseudo-random) universally unique identifier (UUID), as specified by RFC 4122.\\n\\nExamples\\n\\njulia> rng = MersenneTwister(1234);\\n\\njulia> uuid4(rng)\\nUUID(\\\"196f2941-2d58-45ba-9f13-43a2532b2fa8\\\")\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/UUIDs.html#UUIDs.uuid_version\",\n    \"page\": \"UUIDs\",\n    \"title\": \"UUIDs.uuid_version\",\n    \"category\": \"function\",\n    \"text\": \"uuid_version(u::UUID) -> Int\\n\\nInspects the given UUID and returns its version (see RFC 4122).\\n\\nExamples\\n\\njulia> uuid_version(uuid4())\\n4\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/UUIDs.html#UUIDs-1\",\n    \"page\": \"UUIDs\",\n    \"title\": \"UUIDs\",\n    \"category\": \"section\",\n    \"text\": \"DocTestSetup = :(using UUIDs, Random)UUIDs.uuid1\\nUUIDs.uuid4\\nUUIDs.uuid_versionDocTestSetup = nothing\"\n},\n\n{\n    \"location\": \"stdlib/Unicode.html#\",\n    \"page\": \"Unicode\",\n    \"title\": \"Unicode\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"stdlib/Unicode.html#Unicode.isassigned\",\n    \"page\": \"Unicode\",\n    \"title\": \"Unicode.isassigned\",\n    \"category\": \"function\",\n    \"text\": \"Unicode.isassigned(c) -> Bool\\n\\nReturns true if the given char or integer is an assigned Unicode code point.\\n\\nExamples\\n\\njulia> Unicode.isassigned(101)\\ntrue\\n\\njulia> Unicode.isassigned(\\'\\\\x01\\')\\ntrue\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Unicode.html#Unicode.normalize\",\n    \"page\": \"Unicode\",\n    \"title\": \"Unicode.normalize\",\n    \"category\": \"function\",\n    \"text\": \"Unicode.normalize(s::AbstractString, normalform::Symbol)\\n\\nNormalize the string s according to one of the four \\\"normal forms\\\" of the Unicode standard: normalform can be :NFC, :NFD, :NFKC, or :NFKD.  Normal forms C (canonical composition) and D (canonical decomposition) convert different visually identical representations of the same abstract string into a single canonical form, with form C being more compact.  Normal forms KC and KD additionally canonicalize \\\"compatibility equivalents\\\": they convert characters that are abstractly similar but visually distinct into a single canonical choice (e.g. they expand ligatures into the individual characters), with form KC being more compact.\\n\\nAlternatively, finer control and additional transformations may be be obtained by calling Unicode.normalize(s; keywords...), where any number of the following boolean keywords options (which all default to false except for compose) are specified:\\n\\ncompose=false: do not perform canonical composition\\ndecompose=true: do canonical decomposition instead of canonical composition (compose=true is ignored if present)\\ncompat=true: compatibility equivalents are canonicalized\\ncasefold=true: perform Unicode case folding, e.g. for case-insensitive string comparison\\nnewline2lf=true, newline2ls=true, or newline2ps=true: convert various newline sequences (LF, CRLF, CR, NEL) into a linefeed (LF), line-separation (LS), or paragraph-separation (PS) character, respectively\\nstripmark=true: strip diacritical marks (e.g. accents)\\nstripignore=true: strip Unicode\\'s \\\"default ignorable\\\" characters (e.g. the soft hyphen or the left-to-right marker)\\nstripcc=true: strip control characters; horizontal tabs and form feeds are converted to spaces; newlines are also converted to spaces unless a newline-conversion flag was specified\\nrejectna=true: throw an error if unassigned code points are found\\nstable=true: enforce Unicode Versioning Stability\\n\\nFor example, NFKC corresponds to the options compose=true, compat=true, stable=true.\\n\\nExamples\\n\\njulia> \\\"\u03bc\\\" == Unicode.normalize(\\\"\u00b5\\\", compat=true) #LHS: Unicode U+03bc, RHS: Unicode U+00b5\\ntrue\\n\\njulia> Unicode.normalize(\\\"JuLiA\\\", casefold=true)\\n\\\"julia\\\"\\n\\njulia> Unicode.normalize(\\\"J\u00faLiA\\\", stripmark=true)\\n\\\"JuLiA\\\"\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Unicode.html#Unicode.graphemes\",\n    \"page\": \"Unicode\",\n    \"title\": \"Unicode.graphemes\",\n    \"category\": \"function\",\n    \"text\": \"graphemes(s::AbstractString) -> GraphemeIterator\\n\\nReturns an iterator over substrings of s that correspond to the extended graphemes in the string, as defined by Unicode UAX #29. (Roughly, these are what users would perceive as single characters, even though they may contain more than one codepoint; for example a letter combined with an accent mark is a single grapheme.)\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"stdlib/Unicode.html#Unicode-1\",\n    \"page\": \"Unicode\",\n    \"title\": \"Unicode\",\n    \"category\": \"section\",\n    \"text\": \"DocTestSetup = :(using Unicode)Unicode.isassigned\\nUnicode.normalize\\nUnicode.graphemesDocTestSetup = nothing\"\n},\n\n{\n    \"location\": \"devdocs/reflection.html#\",\n    \"page\": \"Reflection and introspection\",\n    \"title\": \"Reflection and introspection\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/reflection.html#Reflection-and-introspection-1\",\n    \"page\": \"Reflection and introspection\",\n    \"title\": \"Reflection and introspection\",\n    \"category\": \"section\",\n    \"text\": \"Julia provides a variety of runtime reflection capabilities.\"\n},\n\n{\n    \"location\": \"devdocs/reflection.html#Module-bindings-1\",\n    \"page\": \"Reflection and introspection\",\n    \"title\": \"Module bindings\",\n    \"category\": \"section\",\n    \"text\": \"The exported names for a Module are available using names(m::Module), which will return an array of Symbol elements representing the exported bindings. names(m::Module, all = true) returns symbols for all bindings in m, regardless of export status.\"\n},\n\n{\n    \"location\": \"devdocs/reflection.html#DataType-fields-1\",\n    \"page\": \"Reflection and introspection\",\n    \"title\": \"DataType fields\",\n    \"category\": \"section\",\n    \"text\": \"The names of DataType fields may be interrogated using fieldnames. For example, given the following type, fieldnames(Point) returns a tuple of Symbols representing the field names:julia> struct Point\\n           x::Int\\n           y\\n       end\\n\\njulia> fieldnames(Point)\\n(:x, :y)The type of each field in a Point object is stored in the types field of the Point variable itself:julia> Point.types\\nsvec(Int64, Any)While x is annotated as an Int, y was unannotated in the type definition, therefore y defaults to the Any type.Types are themselves represented as a structure called DataType:julia> typeof(Point)\\nDataTypeNote that fieldnames(DataType) gives the names for each field of DataType itself, and one of these fields is the types field observed in the example above.\"\n},\n\n{\n    \"location\": \"devdocs/reflection.html#Subtypes-1\",\n    \"page\": \"Reflection and introspection\",\n    \"title\": \"Subtypes\",\n    \"category\": \"section\",\n    \"text\": \"The direct subtypes of any DataType may be listed using subtypes. For example, the abstract DataType AbstractFloat has four (concrete) subtypes:julia> subtypes(AbstractFloat)\\n4-element Array{Any,1}:\\n BigFloat\\n Float16\\n Float32\\n Float64Any abstract subtype will also be included in this list, but further subtypes thereof will not; recursive application of subtypes may be used to inspect the full type tree.\"\n},\n\n{\n    \"location\": \"devdocs/reflection.html#DataType-layout-1\",\n    \"page\": \"Reflection and introspection\",\n    \"title\": \"DataType layout\",\n    \"category\": \"section\",\n    \"text\": \"The internal representation of a DataType is critically important when interfacing with C code and several functions are available to inspect these details. isbits(T::DataType) returns true if T is stored with C-compatible alignment. fieldoffset(T::DataType, i::Integer) returns the (byte) offset for field i relative to the start of the type.\"\n},\n\n{\n    \"location\": \"devdocs/reflection.html#Function-methods-1\",\n    \"page\": \"Reflection and introspection\",\n    \"title\": \"Function methods\",\n    \"category\": \"section\",\n    \"text\": \"The methods of any generic function may be listed using methods. The method dispatch table may be searched for methods accepting a given type using methodswith.\"\n},\n\n{\n    \"location\": \"devdocs/reflection.html#Expansion-and-lowering-1\",\n    \"page\": \"Reflection and introspection\",\n    \"title\": \"Expansion and lowering\",\n    \"category\": \"section\",\n    \"text\": \"As discussed in the Metaprogramming section, the macroexpand function gives the unquoted and interpolated expression (Expr) form for a given macro. To use macroexpand, quote the expression block itself (otherwise, the macro will be evaluated and the result will be passed instead!). For example:julia> macroexpand(@__MODULE__, :(@edit println(\\\"\\\")) )\\n:((InteractiveUtils.edit)(println, (Base.typesof)(\\\"\\\")))The functions Base.Meta.show_sexpr and dump are used to display S-expr style views and depth-nested detail views for any expression.Finally, the Meta.lower function gives the lowered form of any expression and is of particular interest for understanding how language constructs map to primitive operations such as assignments, branches, and calls:julia> Meta.lower(@__MODULE__, :([1+2, sin(0.5)]) )\\n:($(Expr(:thunk, CodeInfo(\\n 1 \u2500 %1 = 1 + 2\\n \u2502   %2 = sin(0.5)\\n \u2502   %3 = (Base.vect)(%1, %2)\\n \u2514\u2500\u2500      return %3\\n))))\"\n},\n\n{\n    \"location\": \"devdocs/reflection.html#Intermediate-and-compiled-representations-1\",\n    \"page\": \"Reflection and introspection\",\n    \"title\": \"Intermediate and compiled representations\",\n    \"category\": \"section\",\n    \"text\": \"Inspecting the lowered form for functions requires selection of the specific method to display, because generic functions may have many methods with different type signatures. For this purpose, method-specific code-lowering is available using code_lowered, and the type-inferred form is available using code_typed. code_warntype adds highlighting to the output of code_typed.Closer to the machine, the LLVM intermediate representation of a function may be printed using by code_llvm, and finally the compiled machine code is available using code_native (this will trigger JIT compilation/code generation for any function which has not previously been called).For convenience, there are macro versions of the above functions which take standard function calls and expand argument types automatically:julia> @code_llvm +(1,1)\\n\\n; Function Attrs: sspreq\\ndefine i64 @\\\"julia_+_130862\\\"(i64, i64) #0 {\\ntop:\\n    %2 = add i64 %1, %0, !dbg !8\\n    ret i64 %2, !dbg !8\\n}See @code_lowered, @code_typed, @code_warntype, @code_llvm, and @code_native.\"\n},\n\n{\n    \"location\": \"devdocs/init.html#\",\n    \"page\": \"Initialization of the Julia runtime\",\n    \"title\": \"Initialization of the Julia runtime\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/init.html#Initialization-of-the-Julia-runtime-1\",\n    \"page\": \"Initialization of the Julia runtime\",\n    \"title\": \"Initialization of the Julia runtime\",\n    \"category\": \"section\",\n    \"text\": \"How does the Julia runtime execute julia -e \\'println(\\\"Hello World!\\\")\\' ?\"\n},\n\n{\n    \"location\": \"devdocs/init.html#main()-1\",\n    \"page\": \"Initialization of the Julia runtime\",\n    \"title\": \"main()\",\n    \"category\": \"section\",\n    \"text\": \"Execution starts at main() in ui/repl.c.main() calls libsupport_init() to set the C library locale and to initialize the \\\"ios\\\" library (see ios_init_stdstreams() and Legacy ios.c library).Next jl_parse_opts() is called to process command line options. Note that jl_parse_opts() only deals with options that affect code generation or early initialization. Other options are handled later by process_options() in base/client.jl.jl_parse_opts() stores command line options in the global jl_options struct.\"\n},\n\n{\n    \"location\": \"devdocs/init.html#julia_init()-1\",\n    \"page\": \"Initialization of the Julia runtime\",\n    \"title\": \"julia_init()\",\n    \"category\": \"section\",\n    \"text\": \"julia_init() in task.c is called by main() and calls _julia_init() in init.c._julia_init() begins by calling libsupport_init() again (it does nothing the second time).restore_signals() is called to zero the signal handler mask.jl_resolve_sysimg_location() searches configured paths for the base system image. See Building the Julia system image.jl_gc_init() sets up allocation pools and lists for weak refs, preserved values and finalization.jl_init_frontend() loads and initializes a pre-compiled femtolisp image containing the scanner/parser.jl_init_types() creates jl_datatype_t type description objects for the built-in types defined in julia.h. e.g.jl_any_type = jl_new_abstracttype(jl_symbol(\\\"Any\\\"), core, NULL, jl_emptysvec);\\njl_any_type->super = jl_any_type;\\n\\njl_type_type = jl_new_abstracttype(jl_symbol(\\\"Type\\\"), core, jl_any_type, jl_emptysvec);\\n\\njl_int32_type = jl_new_primitivetype(jl_symbol(\\\"Int32\\\"), core,\\n                                     jl_any_type, jl_emptysvec, 32);jl_init_tasks() creates the jl_datatype_t* jl_task_type object; initializes the global jl_root_task struct; and sets jl_current_task to the root task.jl_init_codegen() initializes the LLVM library.jl_init_serializer() initializes 8-bit serialization tags for builtin jl_value_t values.If there is no sysimg file (!jl_options.image_file) then the Core and Main modules are created and boot.jl is evaluated:jl_core_module = jl_new_module(jl_symbol(\\\"Core\\\")) creates the Julia Core module.jl_init_intrinsic_functions() creates a new Julia module Intrinsics containing constant jl_intrinsic_type symbols. These define an integer code for each intrinsic function. emit_intrinsic() translates these symbols into LLVM instructions during code generation.jl_init_primitives() hooks C functions up to Julia function symbols. e.g. the symbol Core.:(===)() is bound to C function pointer jl_f_is() by calling add_builtin_func(\\\"===\\\", jl_f_is).jl_new_main_module() creates the global \\\"Main\\\" module and sets jl_current_task->current_module = jl_main_module.Note: _julia_init() then sets jl_root_task->current_module = jl_core_module. jl_root_task is an alias of jl_current_task at this point, so the current_module set by jl_new_main_module() above is overwritten.jl_load(\\\"boot.jl\\\", sizeof(\\\"boot.jl\\\")) calls jl_parse_eval_all which repeatedly calls jl_toplevel_eval_flex() to execute boot.jl. <!\u2013 TODO \u2013 drill down into eval? \u2013>jl_get_builtin_hooks() initializes global C pointers to Julia globals defined in boot.jl.jl_init_box_caches() pre-allocates global boxed integer value objects for values up to 1024. This speeds up allocation of boxed ints later on. e.g.:jl_value_t *jl_box_uint8(uint32_t x)\\n{\\n    return boxed_uint8_cache[(uint8_t)x];\\n}_julia_init() iterates over the jl_core_module->bindings.table looking for jl_datatype_t values and sets the type name\\'s module prefix to jl_core_module.jl_add_standard_imports(jl_main_module) does \\\"using Base\\\" in the \\\"Main\\\" module.Note: _julia_init() now reverts to jl_root_task->current_module = jl_main_module as it was before being set to jl_core_module above.Platform specific signal handlers are initialized for SIGSEGV (OSX, Linux), and SIGFPE (Windows).Other signals (SIGINFO, SIGBUS, SIGILL, SIGTERM, SIGABRT, SIGQUIT, SIGSYS and SIGPIPE) are hooked up to sigdie_handler() which prints a backtrace.jl_init_restored_modules() calls jl_module_run_initializer() for each deserialized module to run the __init__() function.Finally sigint_handler() is hooked up to SIGINT and calls jl_throw(jl_interrupt_exception)._julia_init() then returns back to main() in ui/repl.c and main() calls true_main(argc, (char**)argv).sidebar: sysimg\\nIf there is a sysimg file, it contains a pre-cooked image of the Core and Main modules (and whatever else is created by boot.jl). See Building the Julia system image.jl_restore_system_image() deserializes the saved sysimg into the current Julia runtime environment and initialization continues after jl_init_box_caches() below...Note: jl_restore_system_image() (and staticdata.c in general) uses the Legacy ios.c library.\"\n},\n\n{\n    \"location\": \"devdocs/init.html#true_main()-1\",\n    \"page\": \"Initialization of the Julia runtime\",\n    \"title\": \"true_main()\",\n    \"category\": \"section\",\n    \"text\": \"true_main() loads the contents of argv[] into Base.ARGS.If a .jl \\\"program\\\" file was supplied on the command line, then exec_program() calls jl_load(program,len) which calls jl_parse_eval_all which repeatedly calls jl_toplevel_eval_flex() to execute the program.However, in our example (julia -e \\'println(\\\"Hello World!\\\")\\'), jl_get_global(jl_base_module, jl_symbol(\\\"_start\\\")) looks up Base._start and jl_apply() executes it.\"\n},\n\n{\n    \"location\": \"devdocs/init.html#Base._start-1\",\n    \"page\": \"Initialization of the Julia runtime\",\n    \"title\": \"Base._start\",\n    \"category\": \"section\",\n    \"text\": \"Base._start calls Base.process_options which calls jl_parse_input_line(\\\"println(\\\"Hello World!\\\")\\\") to create an expression object and Base.eval() to execute it.\"\n},\n\n{\n    \"location\": \"devdocs/init.html#Base.eval-1\",\n    \"page\": \"Initialization of the Julia runtime\",\n    \"title\": \"Base.eval\",\n    \"category\": \"section\",\n    \"text\": \"Base.eval() was mapped to jl_f_top_eval by jl_init_primitives().jl_f_top_eval() calls jl_toplevel_eval_in(jl_main_module, ex), where ex is the parsed expression println(\\\"Hello World!\\\").jl_toplevel_eval_in() calls jl_toplevel_eval_flex() which calls eval() in interpreter.c.The stack dump below shows how the interpreter works its way through various methods of Base.println() and Base.print() before arriving at write(s::IO, a::Array{T}) where T  which does ccall(jl_uv_write()).jl_uv_write() calls uv_write() to write \\\"Hello World!\\\" to JL_STDOUT. See Libuv wrappers for stdio.:Hello World!Stack frame Source code Notes\\njl_uv_write() jl_uv.c called though ccall\\njulia_write_282942 stream.jl function write!(s::IO, a::Array{T}) where T\\njulia_print_284639 ascii.jl print(io::IO, s::String) = (write(io, s); nothing)\\njlcall_print_284639  \\njl_apply() julia.h \\njl_trampoline() builtins.c \\njl_apply() julia.h \\njl_apply_generic() gf.c Base.print(Base.TTY, String)\\njl_apply() julia.h \\njl_trampoline() builtins.c \\njl_apply() julia.h \\njl_apply_generic() gf.c Base.print(Base.TTY, String, Char, Char...)\\njl_apply() julia.h \\njl_f_apply() builtins.c \\njl_apply() julia.h \\njl_trampoline() builtins.c \\njl_apply() julia.h \\njl_apply_generic() gf.c Base.println(Base.TTY, String, String...)\\njl_apply() julia.h \\njl_trampoline() builtins.c \\njl_apply() julia.h \\njl_apply_generic() gf.c Base.println(String,)\\njl_apply() julia.h \\ndo_call() interpreter.c \\neval() interpreter.c \\njl_interpret_toplevel_expr() interpreter.c \\njl_toplevel_eval_flex() toplevel.c \\njl_toplevel_eval() toplevel.c \\njl_toplevel_eval_in() builtins.c \\njl_f_top_eval() builtins.c Since our example has just one function call, which has done its job of printing \\\"Hello World!\\\", the stack now rapidly unwinds back to main().\"\n},\n\n{\n    \"location\": \"devdocs/init.html#jl*atexit*hook()-1\",\n    \"page\": \"Initialization of the Julia runtime\",\n    \"title\": \"jlatexithook()\",\n    \"category\": \"section\",\n    \"text\": \"main() calls jl_atexit_hook(). This calls _atexit for each module, then calls jl_gc_run_all_finalizers() and cleans up libuv handles.\"\n},\n\n{\n    \"location\": \"devdocs/init.html#julia_save()-1\",\n    \"page\": \"Initialization of the Julia runtime\",\n    \"title\": \"julia_save()\",\n    \"category\": \"section\",\n    \"text\": \"Finally, main() calls julia_save(), which if requested on the command line, saves the runtime state to a new system image. See jl_compile_all() and jl_save_system_image().\"\n},\n\n{\n    \"location\": \"devdocs/ast.html#\",\n    \"page\": \"Julia ASTs\",\n    \"title\": \"Julia ASTs\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/ast.html#Julia-ASTs-1\",\n    \"page\": \"Julia ASTs\",\n    \"title\": \"Julia ASTs\",\n    \"category\": \"section\",\n    \"text\": \"Julia has two representations of code. First there is a surface syntax AST returned by the parser (e.g. the Meta.parse function), and manipulated by macros. It is a structured representation of code as it is written, constructed by julia-parser.scm from a character stream. Next there is a lowered form, or IR (intermediate representation), which is used by type inference and code generation. In the lowered form there are fewer types of nodes, all macros are expanded, and all control flow is converted to explicit branches and sequences of statements. The lowered form is constructed by julia-syntax.scm.First we will focus on the lowered form, since it is more important to the compiler. It is also less obvious to the human, since it results from a significant rearrangement of the input syntax.\"\n},\n\n{\n    \"location\": \"devdocs/ast.html#Lowered-form-1\",\n    \"page\": \"Julia ASTs\",\n    \"title\": \"Lowered form\",\n    \"category\": \"section\",\n    \"text\": \"The following data types exist in lowered form:Expr\\nHas a node type indicated by the head field, and an args field which is a Vector{Any} of subexpressions. While almost every part of a surface AST is represented by an Expr, the IR uses only a limited number of Exprs, mostly for calls, conditional branches (gotoifnot), and returns.\\nSlot\\nIdentifies arguments and local variables by consecutive numbering. Slot is an abstract type with subtypes SlotNumber and TypedSlot. Both types have an integer-valued id field giving the slot index. Most slots have the same type at all uses, and so are represented with SlotNumber. The types of these slots are found in the slottypes field of their MethodInstance object. Slots that require per-use type annotations are represented with TypedSlot, which has a typ field.\\nCodeInfo\\nWraps the IR of a method. Its code field is an array of expressions to execute.\\nGotoNode\\nUnconditional branch. The argument is the branch target, represented as an index in the code array to jump to.\\nQuoteNode\\nWraps an arbitrary value to reference as data. For example, the function f() = :a contains a QuoteNode whose value field is the symbol a, in order to return the symbol itself instead of evaluating it.\\nGlobalRef\\nRefers to global variable name in module mod.\\nSSAValue\\nRefers to a consecutively-numbered (starting at 1) static single assignment (SSA) variable inserted by the compiler. The number (id) of an SSAValue is the code array index of the expression whose value it represents.\\nNewvarNode\\nMarks a point where a variable (slot) is created. This has the effect of resetting a variable to undefined.\"\n},\n\n{\n    \"location\": \"devdocs/ast.html#Expr-types-1\",\n    \"page\": \"Julia ASTs\",\n    \"title\": \"Expr types\",\n    \"category\": \"section\",\n    \"text\": \"These symbols appear in the head field of Exprs in lowered form.call\\nFunction call (dynamic dispatch). args[1] is the function to call, args[2:end] are the arguments.\\ninvoke\\nFunction call (static dispatch). args[1] is the MethodInstance to call, args[2:end] are the arguments (including the function that is being called, at args[2]).\\nstatic_parameter\\nReference a static parameter by index.\\ngotoifnot\\nConditional branch. If args[1] is false, goes to the index identified in args[2].\\n=\\nAssignment. In the IR, the first argument is always a Slot or a GlobalRef.\\nmethod\\nAdds a method to a generic function and assigns the result if necessary.\\nHas a 1-argument form and a 4-argument form. The 1-argument form arises from the syntax function foo end. In the 1-argument form, the argument is a symbol. If this symbol already names a function in the current scope, nothing happens. If the symbol is undefined, a new function is created and assigned to the identifier specified by the symbol. If the symbol is defined but names a non-function, an error is raised. The definition of \\\"names a function\\\" is that the binding is constant, and refers to an object of singleton type. The rationale for this is that an instance of a singleton type uniquely identifies the type to add the method to. When the type has fields, it wouldn\\'t be clear whether the method was being added to the instance or its type.\\nThe 4-argument form has the following arguments:\\nargs[1]\\nA function name, or false if unknown. If a symbol, then the expression first behaves like the 1-argument form above. This argument is ignored from then on. When this is false, it means a method is being added strictly by type, (::T)(x) = x.\\nargs[2]\\nA SimpleVector of argument type data. args[2][1] is a SimpleVector of the argument types, and args[2][2] is a SimpleVector of type variables corresponding to the method\\'s static parameters.\\nargs[3]\\nA CodeInfo of the method itself. For \\\"out of scope\\\" method definitions (adding a method to a function that also has methods defined in different scopes) this is an expression that evaluates to a :lambda expression.\\nargs[4]\\ntrue or false, identifying whether the method is staged (@generated function).\\nconst\\nDeclares a (global) variable as constant.\\nnull\\nHas no arguments; simply yields the value nothing.\\nnew\\nAllocates a new struct-like object. First argument is the type. The new pseudo-function is lowered to this, and the type is always inserted by the compiler.  This is very much an internal-only feature, and does no checking. Evaluating arbitrary new expressions can easily segfault.\\nreturn\\nReturns its argument as the value of the enclosing function.\\nthe_exception\\nYields the caught exception inside a catch block. This is the value of the run time system variable jl_exception_in_transit.\\nenter\\nEnters an exception handler (setjmp). args[1] is the label of the catch block to jump to on error.\\nleave\\nPop exception handlers. args[1] is the number of handlers to pop.\\ninbounds\\nControls turning bounds checks on or off. A stack is maintained; if the first argument of this expression is true or false (true means bounds checks are disabled), it is pushed onto the stack. If the first argument is :pop, the stack is popped.\\nboundscheck\\nHas the value false if inlined into a section of code marked with @inbounds, otherwise has the value true.\\ncopyast\\nPart of the implementation of quasi-quote. The argument is a surface syntax AST that is simply copied recursively and returned at run time.\\nmeta\\nMetadata. args[1] is typically a symbol specifying the kind of metadata, and the rest of the arguments are free-form. The following kinds of metadata are commonly used:\\n:inline and :noinline: Inlining hints.\"\n},\n\n{\n    \"location\": \"devdocs/ast.html#Method-1\",\n    \"page\": \"Julia ASTs\",\n    \"title\": \"Method\",\n    \"category\": \"section\",\n    \"text\": \"A unique\\'d container describing the shared metadata for a single method.name, module, file, line, sig\\nMetadata to uniquely identify the method for the computer and the human.\\nambig\\nCache of other methods that may be ambiguous with this one.\\nspecializations\\nCache of all MethodInstance ever created for this Method, used to ensure uniqueness. Uniqueness is required for efficiency, especially for incremental precompile and tracking of method invalidation.\\nsource\\nThe original source code (usually compressed).\\nroots\\nPointers to non-AST things that have been interpolated into the AST, required by compression of the AST, type-inference, or the generation of native code.\\nnargs, isva, called, isstaged, pure\\nDescriptive bit-fields for the source code of this Method.\\nmin_world / max_world\\nThe range of world ages for which this method is visible to dispatch.\"\n},\n\n{\n    \"location\": \"devdocs/ast.html#MethodInstance-1\",\n    \"page\": \"Julia ASTs\",\n    \"title\": \"MethodInstance\",\n    \"category\": \"section\",\n    \"text\": \"A unique\\'d container describing a single callable signature for a Method. See especially Proper maintenance and care of multi-threading locks for important details on how to modify these fields safely.specTypes\\nThe primary key for this MethodInstance. Uniqueness is guaranteed through a def.specializations lookup.\\ndef\\nThe Method that this function describes a specialization of. Or a Module, if this is a top-level Lambda expanded in Module, and which is not part of a Method.\\nsparam_vals\\nThe values of the static parameters in specTypes indexed by def.sparam_syms. For the MethodInstance at Method.unspecialized, this is the empty SimpleVector. But for a runtime MethodInstance from the MethodTable cache, this will always be defined and indexable.\\nrettype\\nThe inferred return type for the specFunctionObject field, which (in most cases) is also the computed return type for the function in general.\\ninferred\\nMay contain a cache of the inferred source for this function, or other information about the inference result such as a constant return value may be put here (if jlcall_api == 2), or it could be set to nothing to just indicate rettype is inferred.\\nftpr\\nThe generic jlcall entry point.\\njlcall_api\\nThe ABI to use when calling fptr. Some significant ones include:\\n0 - Not compiled yet\\n1 - JLCALLABLE `jlvaluet ()(jlfunctiont *f, jlvaluet *args[nargs], uint32t nargs)`\\n2 - Constant (value stored in inferred)\\n3 - With Static-parameters forwarded jl_value_t *(*)(jl_svec_t *sparams, jl_function_t *f, jl_value_t *args[nargs], uint32_t nargs)\\n4 - Run in interpreter jl_value_t *(*)(jl_method_instance_t *meth, jl_function_t *f, jl_value_t *args[nargs], uint32_t nargs)\\nmin_world / max_world\\nThe range of world ages for which this method instance is valid to be called.\"\n},\n\n{\n    \"location\": \"devdocs/ast.html#CodeInfo-1\",\n    \"page\": \"Julia ASTs\",\n    \"title\": \"CodeInfo\",\n    \"category\": \"section\",\n    \"text\": \"A temporary container for holding lowered source code.code\\nAn Any array of statements\\nslotnames\\nAn array of symbols giving the name of each slot (argument or local variable).\\nslottypes\\nAn array of types for the slots.\\nslotflags\\nA UInt8 array of slot properties, represented as bit flags:\\n2  - assigned (only false if there are no assignment statements with this var on the left)\\n8  - const (currently unused for local variables)\\n16 - statically assigned once\\n32 - might be used before assigned. This flag is only valid after type inference.\\nssavaluetypes\\nEither an array or an Int.\\nIf an Int, it gives the number of compiler-inserted temporary locations in the function. If an array, specifies a type for each location.\\nlinetable\\nAn array of source location objects\\ncodelocs\\nAn array of integer indices into the linetable, giving the location associated with each statement.Boolean properties:inferred\\nWhether this has been produced by type inference.\\ninlineable\\nWhether this should be inlined.\\npropagate_inbounds\\nWhether this should should propagate @inbounds when inlined for the purpose of eliding @boundscheck blocks.\\npure\\nWhether this is known to be a pure function of its arguments, without respect to the state of the method caches or other mutable global state.\"\n},\n\n{\n    \"location\": \"devdocs/ast.html#Surface-syntax-AST-1\",\n    \"page\": \"Julia ASTs\",\n    \"title\": \"Surface syntax AST\",\n    \"category\": \"section\",\n    \"text\": \"Front end ASTs consist almost entirely of Exprs and atoms (e.g. symbols, numbers). There is generally a different expression head for each visually distinct syntactic form. Examples will be given in s-expression syntax. Each parenthesized list corresponds to an Expr, where the first element is the head. For example (call f x) corresponds to Expr(:call, :f, :x) in Julia.\"\n},\n\n{\n    \"location\": \"devdocs/ast.html#Calls-1\",\n    \"page\": \"Julia ASTs\",\n    \"title\": \"Calls\",\n    \"category\": \"section\",\n    \"text\": \"Input AST\\nf(x) (call f x)\\nf(x, y=1, z=2) (call f x (kw y 1) (kw z 2))\\nf(x; y=1) (call f (parameters (kw y 1)) x)\\nf(x...) (call f (... x))do syntax:f(x) do a,b\\n    body\\nendparses as (do (call f x) (-> (tuple a b) (block body))).\"\n},\n\n{\n    \"location\": \"devdocs/ast.html#Operators-1\",\n    \"page\": \"Julia ASTs\",\n    \"title\": \"Operators\",\n    \"category\": \"section\",\n    \"text\": \"Most uses of operators are just function calls, so they are parsed with the head call. However some operators are special forms (not necessarily function calls), and in those cases the operator itself is the expression head. In julia-parser.scm these are referred to as \\\"syntactic operators\\\". Some operators (+ and *) use N-ary parsing; chained calls are parsed as a single N-argument call. Finally, chains of comparisons have their own special expression structure.Input AST\\nx+y (call + x y)\\na+b+c+d (call + a b c d)\\n2x (call * 2 x)\\na&&b (&& a b)\\nx += 1 (+= x 1)\\na ? 1 : 2 (if a 1 2)\\na:b (: a b)\\na:b:c (: a b c)\\na,b (tuple a b)\\na==b (call == a b)\\n1<i<=n (comparison 1 < i <= n)\\na.b (. a (quote b))\\na.(b) (. a b)\"\n},\n\n{\n    \"location\": \"devdocs/ast.html#Bracketed-forms-1\",\n    \"page\": \"Julia ASTs\",\n    \"title\": \"Bracketed forms\",\n    \"category\": \"section\",\n    \"text\": \"Input AST\\na[i] (ref a i)\\nt[i;j] (typed_vcat t i j)\\nt[i j] (typed_hcat t i j)\\nt[a b; c d] (typed_vcat t (row a b) (row c d))\\na{b} (curly a b)\\na{b;c} (curly a (parameters c) b)\\n[x] (vect x)\\n[x,y] (vect x y)\\n[x;y] (vcat x y)\\n[x y] (hcat x y)\\n[x y; z t] (vcat (row x y) (row z t))\\n[x for y in z, a in b] (comprehension x (= y z) (= a b))\\nT[x for y in z] (typed_comprehension T x (= y z))\\n(a, b, c) (tuple a b c)\\n(a; b; c) (block a (block b c))\"\n},\n\n{\n    \"location\": \"devdocs/ast.html#Macros-1\",\n    \"page\": \"Julia ASTs\",\n    \"title\": \"Macros\",\n    \"category\": \"section\",\n    \"text\": \"Input AST\\n@m x y (macrocall @m (line) x y)\\nBase.@m x y (macrocall (. Base (quote @m)) (line) x y)\\n@Base.m x y (macrocall (. Base (quote @m)) (line) x y)\"\n},\n\n{\n    \"location\": \"devdocs/ast.html#Strings-1\",\n    \"page\": \"Julia ASTs\",\n    \"title\": \"Strings\",\n    \"category\": \"section\",\n    \"text\": \"Input AST\\n\\\"a\\\" \\\"a\\\"\\nx\\\"y\\\" (macrocall @x_str (line) \\\"y\\\")\\nx\\\"y\\\"z (macrocall @x_str (line) \\\"y\\\" \\\"z\\\")\\n\\\"x = $x\\\" (string \\\"x = \\\" x)\\n`a b c` (macrocall @cmd (line) \\\"a b c\\\")Doc string syntax:\\\"some docs\\\"\\nf(x) = xparses as (macrocall (|.| Core \\'@doc) (line) \\\"some docs\\\" (= (call f x) (block x))).\"\n},\n\n{\n    \"location\": \"devdocs/ast.html#Imports-and-such-1\",\n    \"page\": \"Julia ASTs\",\n    \"title\": \"Imports and such\",\n    \"category\": \"section\",\n    \"text\": \"Input AST\\nimport a (import (. a))\\nimport a.b.c (import (. a b c))\\nimport ...a (import (. . . . a))\\nimport a.b, c.d (import (. a b) (. c d))\\nimport Base: x (import (: (. Base) (. x)))\\nimport Base: x, y (import (: (. Base) (. x) (. y)))\\nexport a, b (export a b)\"\n},\n\n{\n    \"location\": \"devdocs/ast.html#Numbers-1\",\n    \"page\": \"Julia ASTs\",\n    \"title\": \"Numbers\",\n    \"category\": \"section\",\n    \"text\": \"Julia supports more number types than many scheme implementations, so not all numbers are represented directly as scheme numbers in the AST.Input AST\\n11111111111111111111 (macrocall @int128_str (null) \\\"11111111111111111111\\\")\\n0xfffffffffffffffff (macrocall @uint128_str (null) \\\"0xfffffffffffffffff\\\")\\n1111...many digits... (macrocall @big_str (null) \\\"1111....\\\")\"\n},\n\n{\n    \"location\": \"devdocs/ast.html#Block-forms-1\",\n    \"page\": \"Julia ASTs\",\n    \"title\": \"Block forms\",\n    \"category\": \"section\",\n    \"text\": \"A block of statements is parsed as (block stmt1 stmt2 ...).If statement:if a\\n    b\\nelseif c\\n    d\\nelse\\n    e\\nendparses as:(if a (block (line 2) b)\\n    (elseif (block (line 3) c) (block (line 4) d)\\n            (block (line 5 e))))A while loop parses as (while condition body).A for loop parses as (for (= var iter) body). If there is more than one iteration specification, they are parsed as a block: (for (block (= v1 iter1) (= v2 iter2)) body).break and continue are parsed as 0-argument expressions (break) and (continue).let is parsed as (let (= var val) body) or (let (block (= var1 val1) (= var2 val2) ...) body), like for loops.A basic function definition is parsed as (function (call f x) body). A more complex example:function f(x::T; k = 1) where T\\n    return x+1\\nendparses as:(function (where (call f (parameters (kw k 1))\\n                       (:: x T))\\n                 T)\\n          (block (line 2) (return (call + x 1))))Type definition:mutable struct Foo{T<:S}\\n    x::T\\nendparses as:(struct true (curly Foo (<: T S))\\n        (block (line 2) (:: x T)))The first argument is a boolean telling whether the type is mutable.try blocks parse as (try try_block var catch_block finally_block). If no variable is present after catch, var is #f. If there is no finally clause, then the last argument is not present.\"\n},\n\n{\n    \"location\": \"devdocs/ast.html#Quote-expressions-1\",\n    \"page\": \"Julia ASTs\",\n    \"title\": \"Quote expressions\",\n    \"category\": \"section\",\n    \"text\": \"Julia source syntax forms for code quoting (quote and :( )) support interpolation with $. In Lisp terminology, this means they are actually \\\"backquote\\\" or \\\"quasiquote\\\" forms. Internally, there is also a need for code quoting without interpolation. In Julia\\'s scheme code, non-interpolating quote is represented with the expression head inert.inert expressions are converted to Julia QuoteNode objects. These objects wrap a single value of any type, and when evaluated simply return that value.A quote expression whose argument is an atom also gets converted to a QuoteNode.\"\n},\n\n{\n    \"location\": \"devdocs/ast.html#Line-numbers-1\",\n    \"page\": \"Julia ASTs\",\n    \"title\": \"Line numbers\",\n    \"category\": \"section\",\n    \"text\": \"Source location information is represented as (line line_num file_name) where the third component is optional (and omitted when the current line number, but not file name, changes).These expressions are represented as LineNumberNodes in Julia.\"\n},\n\n{\n    \"location\": \"devdocs/ast.html#Macros-2\",\n    \"page\": \"Julia ASTs\",\n    \"title\": \"Macros\",\n    \"category\": \"section\",\n    \"text\": \"Macro hygiene is represented through the expression head pair escape and hygienic-scope. The result of a macro expansion is automatically wrapped in (hygienic-scope block module), to represent the result of the new scope. The user can insert (escape block) inside to interpolate code from the caller.\"\n},\n\n{\n    \"location\": \"devdocs/types.html#\",\n    \"page\": \"More about types\",\n    \"title\": \"More about types\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/types.html#More-about-types-1\",\n    \"page\": \"More about types\",\n    \"title\": \"More about types\",\n    \"category\": \"section\",\n    \"text\": \"If you\\'ve used Julia for a while, you understand the fundamental role that types play.  Here we try to get under the hood, focusing particularly on Parametric Types.\"\n},\n\n{\n    \"location\": \"devdocs/types.html#Types-and-sets-(and-Any-and-Union{}/Bottom)-1\",\n    \"page\": \"More about types\",\n    \"title\": \"Types and sets (and Any and Union{}/Bottom)\",\n    \"category\": \"section\",\n    \"text\": \"It\\'s perhaps easiest to conceive of Julia\\'s type system in terms of sets. While programs manipulate individual values, a type refers to a set of values. This is not the same thing as a collection; for example a Set of values is itself a single Set value. Rather, a type describes a set of possible values, expressing uncertainty about which value we have.A concrete type T describes the set of values whose direct tag, as returned by the typeof function, is T. An abstract type describes some possibly-larger set of values.Any describes the entire universe of possible values. Integer is a subset of Any that includes Int, Int8, and other concrete types. Internally, Julia also makes heavy use of another type known as Bottom, which can also be written as Union{}. This corresponds to the empty set.Julia\\'s types support the standard operations of set theory: you can ask whether T1 is a \\\"subset\\\" (subtype) of T2 with T1 <: T2. Likewise, you intersect two types using typeintersect, take their union with Union, and compute a type that contains their union with typejoin:julia> typeintersect(Int, Float64)\\nUnion{}\\n\\njulia> Union{Int, Float64}\\nUnion{Float64, Int64}\\n\\njulia> typejoin(Int, Float64)\\nReal\\n\\njulia> typeintersect(Signed, Union{UInt8, Int8})\\nInt8\\n\\njulia> Union{Signed, Union{UInt8, Int8}}\\nUnion{UInt8, Signed}\\n\\njulia> typejoin(Signed, Union{UInt8, Int8})\\nInteger\\n\\njulia> typeintersect(Tuple{Integer,Float64}, Tuple{Int,Real})\\nTuple{Int64,Float64}\\n\\njulia> Union{Tuple{Integer,Float64}, Tuple{Int,Real}}\\nUnion{Tuple{Int64,Real}, Tuple{Integer,Float64}}\\n\\njulia> typejoin(Tuple{Integer,Float64}, Tuple{Int,Real})\\nTuple{Integer,Real}While these operations may seem abstract, they lie at the heart of Julia.  For example, method dispatch is implemented by stepping through the items in a method list until reaching one for which the type of the argument tuple is a subtype of the method signature. For this algorithm to work, it\\'s important that methods be sorted by their specificity, and that the search begins with the most specific methods. Consequently, Julia also implements a partial order on types; this is achieved by functionality that is similar to <:, but with differences that will be discussed below.\"\n},\n\n{\n    \"location\": \"devdocs/types.html#UnionAll-types-1\",\n    \"page\": \"More about types\",\n    \"title\": \"UnionAll types\",\n    \"category\": \"section\",\n    \"text\": \"Julia\\'s type system can also express an iterated union of types: a union of types over all values of some variable. This is needed to describe parametric types where the values of some parameters are not known.For example, :obj:Array has two parameters as in Array{Int,2}. If we did not know the element type, we could write Array{T,2} where T, which is the union of Array{T,2} for all values of T: Union{Array{Int8,2}, Array{Int16,2}, ...}.Such a type is represented by a UnionAll object, which contains a variable (T in this example, of type TypeVar), and a wrapped type (Array{T,2} in this example).Consider the following methods:f1(A::Array) = 1\\nf2(A::Array{Int}) = 2\\nf3(A::Array{T}) where {T<:Any} = 3\\nf4(A::Array{Any}) = 4The signature of f3 is a UnionAll type wrapping a tuple type. All but f4 can be called with a = [1,2]; all but f2 can be called with b = Any[1,2].Let\\'s look at these types a little more closely:julia> dump(Array)\\nUnionAll\\n  var: TypeVar\\n    name: Symbol T\\n    lb: Core.TypeofBottom Union{}\\n    ub: Any\\n  body: UnionAll\\n    var: TypeVar\\n      name: Symbol N\\n      lb: Core.TypeofBottom Union{}\\n      ub: Any\\n    body: Array{T,N} <: DenseArray{T,N}This indicates that Array actually names a UnionAll type. There is one UnionAll type for each parameter, nested. The syntax Array{Int,2} is equivalent to Array{Int}{2}; internally each UnionAll is instantiated with a particular variable value, one at a time, outermost-first. This gives a natural meaning to the omission of trailing type parameters; Array{Int} gives a type equivalent to Array{Int,N} where N.A TypeVar is not itself a type, but rather should be considered part of the structure of a UnionAll type. Type variables have lower and upper bounds on their values (in the fields lb and ub). The symbol name is purely cosmetic. Internally, TypeVars are compared by address, so they are defined as mutable types to ensure that \\\"different\\\" type variables can be distinguished. However, by convention they should not be mutated.One can construct TypeVars manually:julia> TypeVar(:V, Signed, Real)\\nSigned<:V<:RealThere are convenience versions that allow you to omit any of these arguments except the name symbol.The syntax Array{T} where T<:Integer is lowered tolet T = TypeVar(:T,Integer)\\n    UnionAll(T, Array{T})\\nendso it is seldom necessary to construct a TypeVar manually (indeed, this is to be avoided).\"\n},\n\n{\n    \"location\": \"devdocs/types.html#Free-variables-1\",\n    \"page\": \"More about types\",\n    \"title\": \"Free variables\",\n    \"category\": \"section\",\n    \"text\": \"The concept of a free type variable is extremely important in the type system. We say that a variable V is free in type T if T does not contain the UnionAll that introduces variable V. For example, the type Array{Array{V} where V<:Integer} has no free variables, but the Array{V} part inside of it does have a free variable, V.A type with free variables is, in some sense, not really a type at all. Consider the type Array{Array{T}} where T, which refers to all homogeneous arrays of arrays. The inner type Array{T}, seen by itself, might seem to refer to any kind of array. However, every element of the outer array must have the same array type, so Array{T} cannot refer to just any old array. One could say that Array{T} effectively \\\"occurs\\\" multiple times, and T must have the same value each \\\"time\\\".For this reason, the function jl_has_free_typevars in the C API is very important. Types for which it returns true will not give meaningful answers in subtyping and other type functions.\"\n},\n\n{\n    \"location\": \"devdocs/types.html#TypeNames-1\",\n    \"page\": \"More about types\",\n    \"title\": \"TypeNames\",\n    \"category\": \"section\",\n    \"text\": \"The following two Array types are functionally equivalent, yet print differently:julia> TV, NV = TypeVar(:T), TypeVar(:N)\\n(T, N)\\n\\njulia> Array\\nArray\\n\\njulia> Array{TV,NV}\\nArray{T,N}These can be distinguished by examining the name field of the type, which is an object of type TypeName:julia> dump(Array{Int,1}.name)\\nTypeName\\n  name: Symbol Array\\n  module: Module Core\\n  names: empty SimpleVector\\n  wrapper: UnionAll\\n    var: TypeVar\\n      name: Symbol T\\n      lb: Core.TypeofBottom Union{}\\n      ub: Any\\n    body: UnionAll\\n      var: TypeVar\\n        name: Symbol N\\n        lb: Core.TypeofBottom Union{}\\n        ub: Any\\n      body: Array{T,N} <: DenseArray{T,N}\\n  cache: SimpleVector\\n    ...\\n\\n  linearcache: SimpleVector\\n    ...\\n\\n  hash: Int64 -7900426068641098781\\n  mt: MethodTable\\n    name: Symbol Array\\n    defs: Nothing nothing\\n    cache: Nothing nothing\\n    max_args: Int64 0\\n    kwsorter: #undef\\n    module: Module Core\\n    : Int64 0\\n    : Int64 0In this case, the relevant field is wrapper, which holds a reference to the top-level type used to make new Array types.julia> pointer_from_objref(Array)\\nPtr{Cvoid} @0x00007fcc7de64850\\n\\njulia> pointer_from_objref(Array.body.body.name.wrapper)\\nPtr{Cvoid} @0x00007fcc7de64850\\n\\njulia> pointer_from_objref(Array{TV,NV})\\nPtr{Cvoid} @0x00007fcc80c4d930\\n\\njulia> pointer_from_objref(Array{TV,NV}.name.wrapper)\\nPtr{Cvoid} @0x00007fcc7de64850The wrapper field of Array points to itself, but for Array{TV,NV} it points back to the original definition of the type.What about the other fields? hash assigns an integer to each type.  To examine the cache field, it\\'s helpful to pick a type that is less heavily used than Array. Let\\'s first create our own type:julia> struct MyType{T,N} end\\n\\njulia> MyType{Int,2}\\nMyType{Int64,2}\\n\\njulia> MyType{Float32, 5}\\nMyType{Float32,5}\\n\\njulia> MyType.body.body.name.cache\\nsvec(MyType{Int64,2}, MyType{Float32,5}, #undef, #undef, #undef, #undef, #undef, #undef)(The cache is pre-allocated to have length 8, but only the first two entries are populated.) Consequently, when you instantiate a parametric type, each concrete type gets saved in a type cache.  However, instances containing free type variables are not cached.\"\n},\n\n{\n    \"location\": \"devdocs/types.html#Tuple-types-1\",\n    \"page\": \"More about types\",\n    \"title\": \"Tuple types\",\n    \"category\": \"section\",\n    \"text\": \"Tuple types constitute an interesting special case.  For dispatch to work on declarations like x::Tuple, the type has to be able to accommodate any tuple.  Let\\'s check the parameters:julia> Tuple\\nTuple\\n\\njulia> Tuple.parameters\\nsvec(Vararg{Any,N} where N)Unlike other types, tuple types are covariant in their parameters, so this definition permits Tuple to match any type of tuple:julia> typeintersect(Tuple, Tuple{Int,Float64})\\nTuple{Int64,Float64}\\n\\njulia> typeintersect(Tuple{Vararg{Any}}, Tuple{Int,Float64})\\nTuple{Int64,Float64}However, if a variadic (Vararg) tuple type has free variables it can describe different kinds of tuples:julia> typeintersect(Tuple{Vararg{T} where T}, Tuple{Int,Float64})\\nTuple{Int64,Float64}\\n\\njulia> typeintersect(Tuple{Vararg{T}} where T, Tuple{Int,Float64})\\nUnion{}Notice that when T is free with respect to the Tuple type (i.e. its binding UnionAll type is outside the Tuple type), only one T value must work over the whole type. Therefore a heterogeneous tuple does not match.Finally, it\\'s worth noting that Tuple{} is distinct:julia> Tuple{}\\nTuple{}\\n\\njulia> Tuple{}.parameters\\nsvec()\\n\\njulia> typeintersect(Tuple{}, Tuple{Int})\\nUnion{}What is the \\\"primary\\\" tuple-type?julia> pointer_from_objref(Tuple)\\nPtr{Cvoid} @0x00007f5998a04370\\n\\njulia> pointer_from_objref(Tuple{})\\nPtr{Cvoid} @0x00007f5998a570d0\\n\\njulia> pointer_from_objref(Tuple.name.wrapper)\\nPtr{Cvoid} @0x00007f5998a04370\\n\\njulia> pointer_from_objref(Tuple{}.name.wrapper)\\nPtr{Cvoid} @0x00007f5998a04370so Tuple == Tuple{Vararg{Any}} is indeed the primary type.\"\n},\n\n{\n    \"location\": \"devdocs/types.html#Diagonal-types-1\",\n    \"page\": \"More about types\",\n    \"title\": \"Diagonal types\",\n    \"category\": \"section\",\n    \"text\": \"Consider the type Tuple{T,T} where T. A method with this signature would look like:f(x::T, y::T) where {T} = ...According to the usual interpretation of a UnionAll type, this T ranges over all types, including Any, so this type should be equivalent to Tuple{Any,Any}. However, this interpretation causes some practical problems.First, a value of T needs to be available inside the method definition. For a call like f(1, 1.0), it\\'s not clear what T should be. It could be Union{Int,Float64}, or perhaps Real. Intuitively, we expect the declaration x::T to mean T === typeof(x). To make sure that invariant holds, we need typeof(x) === typeof(y) === T in this method. That implies the method should only be called for arguments of the exact same type.It turns out that being able to dispatch on whether two values have the same type is very useful (this is used by the promotion system for example), so we have multiple reasons to want a different interpretation of Tuple{T,T} where T. To make this work we add the following rule to subtyping: if a variable occurs more than once in covariant position, it is restricted to ranging over only concrete types. (\\\"Covariant position\\\" means that only Tuple and Union types occur between an occurrence of a variable and the UnionAll type that introduces it.) Such variables are called \\\"diagonal variables\\\" or \\\"concrete variables\\\".So for example, Tuple{T,T} where T can be seen as Union{Tuple{Int8,Int8}, Tuple{Int16,Int16}, ...}, where T ranges over all concrete types. This gives rise to some interesting subtyping results. For example Tuple{Real,Real} is not a subtype of Tuple{T,T} where T, because it includes some types like Tuple{Int8,Int16} where the two elements have different types. Tuple{Real,Real} and Tuple{T,T} where T have the non-trivial intersection Tuple{T,T} where T<:Real. However, Tuple{Real} is a subtype of Tuple{T} where T, because in that case T occurs only once and so is not diagonal.Next consider a signature like the following:f(a::Array{T}, x::T, y::T) where {T} = ...In this case, T occurs in invariant position inside Array{T}. That means whatever type of array is passed unambiguously determines the value of T \u2013- we say T has an equality constraint on it. Therefore in this case the diagonal rule is not really necessary, since the array determines T and we can then allow x and y to be of any subtypes of T. So variables that occur in invariant position are never considered diagonal. This choice of behavior is slightly controversial \u2013- some feel this definition should be written asf(a::Array{T}, x::S, y::S) where {T, S<:T} = ...to clarify whether x and y need to have the same type. In this version of the signature they would, or we could introduce a third variable for the type of y if x and y can have different types.The next complication is the interaction of unions and diagonal variables, e.g.f(x::Union{Nothing,T}, y::T) where {T} = ...Consider what this declaration means. y has type T. x then can have either the same type T, or else be of type Nothing. So all of the following calls should match:f(1, 1)\\nf(\\\"\\\", \\\"\\\")\\nf(2.0, 2.0)\\nf(nothing, 1)\\nf(nothing, \\\"\\\")\\nf(nothing, 2.0)These examples are telling us something: when x is nothing::Nothing, there are no extra constraints on y. It is as if the method signature had y::Any. This means that whether a variable is diagonal is not a static property based on where it appears in a type. Rather, it depends on where a variable appears when the subtyping algorithm uses it. When x has type Nothing, we don\\'t need to use the T in Union{Nothing,T}, so T does not \\\"occur\\\". Indeed, we have the following type equivalence:(Tuple{Union{Nothing,T},T} where T) == Union{Tuple{Nothing,Any}, Tuple{T,T} where T}\"\n},\n\n{\n    \"location\": \"devdocs/types.html#Subtyping-diagonal-variables-1\",\n    \"page\": \"More about types\",\n    \"title\": \"Subtyping diagonal variables\",\n    \"category\": \"section\",\n    \"text\": \"The subtyping algorithm for diagonal variables has two components: (1) identifying variable occurrences, and (2) ensuring that diagonal variables range over concrete types only.The first task is accomplished by keeping counters occurs_inv and occurs_cov (in src/subtype.c) for each variable in the environment, tracking the number of invariant and covariant occurrences, respectively. A variable is diagonal when occurs_inv == 0 && occurs_cov > 1.The second task is accomplished by imposing a condition on a variable\\'s lower bound. As the subtyping algorithm runs, it narrows the bounds of each variable (raising lower bounds and lowering upper bounds) to keep track of the range of variable values for which the subtype relation would hold. When we are done evaluating the body of a UnionAll type whose variable is diagonal, we look at the final values of the bounds. Since the variable must be concrete, a contradiction occurs if its lower bound could not be a subtype of a concrete type. For example, an abstract type like AbstractArray cannot be a subtype of a concrete type, but a concrete type like Int can be, and the empty type Bottom can be as well. If a lower bound fails this test the algorithm stops with the answer false.For example, in the problem Tuple{Int,String} <: Tuple{T,T} where T, we derive that this would be true if T were a supertype of Union{Int,String}. However, Union{Int,String} is an abstract type, so the relation does not hold.This concreteness test is done by the function is_leaf_bound. Note that this test is slightly different from jl_is_leaf_type, since it also returns true for Bottom. Currently this function is heuristic, and does not catch all possible concrete types. The difficulty is that whether a lower bound is concrete might depend on the values of other type variable bounds. For example, Vector{T} is equivalent to the concrete type Vector{Int} only if both the upper and lower bounds of T equal Int. We have not yet worked out a complete algorithm for this.\"\n},\n\n{\n    \"location\": \"devdocs/types.html#Introduction-to-the-internal-machinery-1\",\n    \"page\": \"More about types\",\n    \"title\": \"Introduction to the internal machinery\",\n    \"category\": \"section\",\n    \"text\": \"Most operations for dealing with types are found in the files jltypes.c and subtype.c. A good way to start is to watch subtyping in action. Build Julia with make debug and fire up Julia within a debugger. gdb debugging tips has some tips which may be useful.Because the subtyping code is used heavily in the REPL itself\u2013and hence breakpoints in this code get triggered often\u2013it will be easiest if you make the following definition:julia> function mysubtype(a,b)\\n           ccall(:jl_breakpoint, Cvoid, (Any,), nothing)\\n           a <: b\\n       endand then set a breakpoint in jl_breakpoint.  Once this breakpoint gets triggered, you can set breakpoints in other functions.As a warm-up, try the following:mysubtype(Tuple{Int,Float64}, Tuple{Integer,Real})We can make it more interesting by trying a more complex case:mysubtype(Tuple{Array{Int,2}, Int8}, Tuple{Array{T}, T} where T)\"\n},\n\n{\n    \"location\": \"devdocs/types.html#Subtyping-and-method-sorting-1\",\n    \"page\": \"More about types\",\n    \"title\": \"Subtyping and method sorting\",\n    \"category\": \"section\",\n    \"text\": \"The type_morespecific functions are used for imposing a partial order on functions in method tables (from most-to-least specific). Specificity is strict; if a is more specific than b, then a does not equal b and b is not more specific than a.If a is a strict subtype of b, then it is automatically considered more specific. From there, type_morespecific employs some less formal rules. For example, subtype is sensitive to the number of arguments, but type_morespecific may not be. In particular, Tuple{Int,AbstractFloat} is more specific than Tuple{Integer}, even though it is not a subtype.  (Of Tuple{Int,AbstractFloat} and Tuple{Integer,Float64}, neither is more specific than the other.)  Likewise, Tuple{Int,Vararg{Int}} is not a subtype of Tuple{Integer}, but it is considered more specific. However, morespecific does get a bonus for length: in particular, Tuple{Int,Int} is more specific than Tuple{Int,Vararg{Int}}.If you\\'re debugging how methods get sorted, it can be convenient to define the function:type_morespecific(a, b) = ccall(:jl_type_morespecific, Cint, (Any,Any), a, b)which allows you to test whether tuple type a is more specific than tuple type b.\"\n},\n\n{\n    \"location\": \"devdocs/object.html#\",\n    \"page\": \"Memory layout of Julia Objects\",\n    \"title\": \"Memory layout of Julia Objects\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/object.html#Memory-layout-of-Julia-Objects-1\",\n    \"page\": \"Memory layout of Julia Objects\",\n    \"title\": \"Memory layout of Julia Objects\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/object.html#Object-layout-(jl*value*t)-1\",\n    \"page\": \"Memory layout of Julia Objects\",\n    \"title\": \"Object layout (jlvaluet)\",\n    \"category\": \"section\",\n    \"text\": \"The jl_value_t struct is the name for a block of memory owned by the Julia Garbage Collector, representing the data associated with a Julia object in memory. Absent any type information, it is simply an opaque pointer:typedef struct jl_value_t* jl_pvalue_t;Each jl_value_t struct is contained in a jl_typetag_t struct that contains metadata information about the Julia object, such as its type and garbage collector (gc) reachability:typedef struct {\\n    opaque metadata;\\n    jl_value_t value;\\n} jl_typetag_t;The type of any Julia object is an instance of a leaf jl_datatype_t object. The jl_typeof() function can be used to query for it:jl_value_t *jl_typeof(jl_value_t *v);The layout of the object depends on its type. Reflection methods can be used to inspect that layout. A field can be accessed by calling one of the get-field methods:jl_value_t *jl_get_nth_field_checked(jl_value_t *v, size_t i);\\njl_value_t *jl_get_field(jl_value_t *o, char *fld);If the field types are known, a priori, to be all pointers, the values can also be extracted directly as an array access:jl_value_t *v = value->fieldptr[n];As an example, a \\\"boxed\\\" uint16_t is stored as follows:struct {\\n    opaque metadata;\\n    struct {\\n        uint16_t data;        // -- 2 bytes\\n    } jl_value_t;\\n};This object is created by jl_box_uint16(). Note that the jl_value_t pointer references the data portion, not the metadata at the top of the struct.A value may be stored \\\"unboxed\\\" in many circumstances (just the data, without the metadata, and possibly not even stored but just kept in registers), so it is unsafe to assume that the address of a box is a unique identifier. The \\\"egal\\\" test (corresponding to the === function in Julia), should instead be used to compare two unknown objects for equivalence:int jl_egal(jl_value_t *a, jl_value_t *b);This optimization should be relatively transparent to the API, since the object will be \\\"boxed\\\" on-demand, whenever a jl_value_t pointer is needed.Note that modification of a jl_value_t pointer in memory is permitted only if the object is mutable. Otherwise, modification of the value may corrupt the program and the result will be undefined. The mutability property of a value can be queried for with:int jl_is_mutable(jl_value_t *v);If the object being stored is a jl_value_t, the Julia garbage collector must be notified also:void jl_gc_wb(jl_value_t *parent, jl_value_t *ptr);However, the Embedding Julia section of the manual is also required reading at this point, for covering other details of boxing and unboxing various types, and understanding the gc interactions.Mirror structs for some of the built-in types are defined in julia.h. The corresponding global jl_datatype_t objects are created by jl_init_types in jltypes.c.\"\n},\n\n{\n    \"location\": \"devdocs/object.html#Garbage-collector-mark-bits-1\",\n    \"page\": \"Memory layout of Julia Objects\",\n    \"title\": \"Garbage collector mark bits\",\n    \"category\": \"section\",\n    \"text\": \"The garbage collector uses several bits from the metadata portion of the jl_typetag_t to track each object in the system. Further details about this algorithm can be found in the comments of the garbage collector implementation in gc.c.\"\n},\n\n{\n    \"location\": \"devdocs/object.html#Object-allocation-1\",\n    \"page\": \"Memory layout of Julia Objects\",\n    \"title\": \"Object allocation\",\n    \"category\": \"section\",\n    \"text\": \"Most new objects are allocated by jl_new_structv():jl_value_t *jl_new_struct(jl_datatype_t *type, ...);\\njl_value_t *jl_new_structv(jl_datatype_t *type, jl_value_t **args, uint32_t na);Although, isbits objects can be also constructed directly from memory:jl_value_t *jl_new_bits(jl_value_t *bt, void *data)And some objects have special constructors that must be used instead of the above functions:Types:jl_datatype_t *jl_apply_type(jl_datatype_t *tc, jl_tuple_t *params);\\njl_datatype_t *jl_apply_array_type(jl_datatype_t *type, size_t dim);\\njl_uniontype_t *jl_new_uniontype(jl_tuple_t *types);While these are the most commonly used options, there are more low-level constructors too, which you can find declared in julia.h. These are used in jl_init_types() to create the initial types needed to bootstrap the creation of the Julia system image.Tuples:jl_tuple_t *jl_tuple(size_t n, ...);\\njl_tuple_t *jl_tuplev(size_t n, jl_value_t **v);\\njl_tuple_t *jl_alloc_tuple(size_t n);The representation of tuples is highly unique in the Julia object representation ecosystem. In some cases, a Base.tuple() object may be an array of pointers to the objects contained by the tuple equivalent to:typedef struct {\\n    size_t length;\\n    jl_value_t *data[length];\\n} jl_tuple_t;However, in other cases, the tuple may be converted to an anonymous isbits type and stored unboxed, or it may not stored at all (if it is not being used in a generic context as a jl_value_t*).Symbols:jl_sym_t *jl_symbol(const char *str);Functions and MethodInstance:jl_function_t *jl_new_generic_function(jl_sym_t *name);\\njl_method_instance_t *jl_new_method_instance(jl_value_t *ast, jl_tuple_t *sparams);Arrays:jl_array_t *jl_new_array(jl_value_t *atype, jl_tuple_t *dims);\\njl_array_t *jl_new_arrayv(jl_value_t *atype, ...);\\njl_array_t *jl_alloc_array_1d(jl_value_t *atype, size_t nr);\\njl_array_t *jl_alloc_array_2d(jl_value_t *atype, size_t nr, size_t nc);\\njl_array_t *jl_alloc_array_3d(jl_value_t *atype, size_t nr, size_t nc, size_t z);\\njl_array_t *jl_alloc_vec_any(size_t n);Note that many of these have alternative allocation functions for various special-purposes. The list here reflects the more common usages, but a more complete list can be found by reading the julia.h header file.Internal to Julia, storage is typically allocated by newstruct() (or newobj() for the special types):jl_value_t *newstruct(jl_value_t *type);\\njl_value_t *newobj(jl_value_t *type, size_t nfields);And at the lowest level, memory is getting allocated by a call to the garbage collector (in gc.c), then tagged with its type:jl_value_t *jl_gc_allocobj(size_t nbytes);\\nvoid jl_set_typeof(jl_value_t *v, jl_datatype_t *type);Note that all objects are allocated in multiples of 4 bytes and aligned to the platform pointer size. Memory is allocated from a pool for smaller objects, or directly with malloc() for large objects.sidebar: Singleton Types\\nSingleton types have only one instance and no data fields. Singleton instances have a size of 0 bytes, and consist only of their metadata. e.g. nothing::Nothing.See Singleton Types and Nothingness and missing values\"\n},\n\n{\n    \"location\": \"devdocs/eval.html#\",\n    \"page\": \"Eval of Julia code\",\n    \"title\": \"Eval of Julia code\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/eval.html#Eval-of-Julia-code-1\",\n    \"page\": \"Eval of Julia code\",\n    \"title\": \"Eval of Julia code\",\n    \"category\": \"section\",\n    \"text\": \"One of the hardest parts about learning how the Julia Language runs code is learning how all of the pieces work together to execute a block of code.Each chunk of code typically makes a trip through many steps with potentially unfamiliar names, such as (in no particular order): flisp, AST, C++, LLVM, eval, typeinf, macroexpand, sysimg (or system image), bootstrapping, compile, parse, execute, JIT, interpret, box, unbox, intrinsic function, and primitive function, before turning into the desired result (hopefully).sidebar: Definitions\\nREPL\\nREPL stands for Read-Eval-Print Loop. It\\'s just what we call the command line environment for short.\\nAST\\nAbstract Syntax Tree The AST is the digital representation of the code structure. In this form the code has been tokenized for meaning so that it is more suitable for manipulation and execution.\"\n},\n\n{\n    \"location\": \"devdocs/eval.html#Julia-Execution-1\",\n    \"page\": \"Eval of Julia code\",\n    \"title\": \"Julia Execution\",\n    \"category\": \"section\",\n    \"text\": \"The 10,000 foot view of the whole process is as follows:The user starts julia.\\nThe C function main() from ui/repl.c gets called. This function processes the command line arguments, filling in the jl_options struct and setting the variable ARGS. It then initializes Julia (by calling julia_init in task.c, which may load a previously compiled sysimg). Finally, it passes off control to Julia by calling Base._start().\\nWhen _start() takes over control, the subsequent sequence of commands depends on the command line arguments given. For example, if a filename was supplied, it will proceed to execute that file. Otherwise, it will start an interactive REPL.\\nSkipping the details about how the REPL interacts with the user, let\\'s just say the program ends up with a block of code that it wants to run.\\nIf the block of code to run is in a file, jl_load(char *filename) gets invoked to load the file and parse it. Each fragment of code is then passed to eval to execute.\\nEach fragment of code (or AST), is handed off to eval() to turn into results.\\neval() takes each code fragment and tries to run it in jl_toplevel_eval_flex().\\njl_toplevel_eval_flex() decides whether the code is a \\\"toplevel\\\" action (such as using or module), which would be invalid inside a function. If so, it passes off the code to the toplevel interpreter.\\njl_toplevel_eval_flex() then expands the code to eliminate any macros and to \\\"lower\\\" the AST to make it simpler to execute.\\njl_toplevel_eval_flex() then uses some simple heuristics to decide whether to JIT compiler the  AST or to interpret it directly.\\nThe bulk of the work to interpret code is handled by eval in interpreter.c.\\nIf instead, the code is compiled, the bulk of the work is handled by codegen.cpp. Whenever a  Julia function is called for the first time with a given set of argument types, type inference  will be run on that function. This information is used by the codegen step to generate  faster code.\\nEventually, the user quits the REPL, or the end of the program is reached, and the _start()  method returns.\\nJust before exiting, main() calls jl_atexit_hook(exit_code).  This calls Base._atexit() (which calls any functions registered to atexit() inside  Julia). Then it calls jl_gc_run_all_finalizers().  Finally, it gracefully cleans up all libuv handles and waits for them to flush and close.\"\n},\n\n{\n    \"location\": \"devdocs/eval.html#dev-parsing-1\",\n    \"page\": \"Eval of Julia code\",\n    \"title\": \"Parsing\",\n    \"category\": \"section\",\n    \"text\": \"The Julia parser is a small lisp program written in femtolisp, the source-code for which is distributed inside Julia in src/flisp.The interface functions for this are primarily defined in jlfrontend.scm. The code in ast.c handles this handoff on the Julia side.The other relevant files at this stage are julia-parser.scm, which handles tokenizing Julia code and turning it into an AST, and julia-syntax.scm, which handles transforming complex AST representations into simpler, \\\"lowered\\\" AST representations which are more suitable for analysis and execution.\"\n},\n\n{\n    \"location\": \"devdocs/eval.html#dev-macro-expansion-1\",\n    \"page\": \"Eval of Julia code\",\n    \"title\": \"Macro Expansion\",\n    \"category\": \"section\",\n    \"text\": \"When eval() encounters a macro, it expands that AST node before attempting to evaluate the expression. Macro expansion involves a handoff from eval() (in Julia), to the parser function jl_macroexpand() (written in flisp) to the Julia macro itself (written in - what else - Julia) via fl_invoke_julia_macro(), and back.Typically, macro expansion is invoked as a first step during a call to Meta.lower()/jl_expand(), although it can also be invoked directly by a call to macroexpand()/jl_macroexpand().\"\n},\n\n{\n    \"location\": \"devdocs/eval.html#dev-type-inference-1\",\n    \"page\": \"Eval of Julia code\",\n    \"title\": \"Type Inference\",\n    \"category\": \"section\",\n    \"text\": \"Type inference is implemented in Julia by typeinf() in compiler/typeinfer.jl. Type inference is the process of examining a Julia function and determining bounds for the types of each of its variables, as well as bounds on the type of the return value from the function. This enables many future optimizations, such as unboxing of known immutable values, and compile-time hoisting of various run-time operations such as computing field offsets and function pointers. Type inference may also include other steps such as constant propagation and inlining.sidebar: More Definitions\\nJIT\\nJust-In-Time Compilation The process of generating native-machine code into memory right when it is needed.\\nLLVM\\nLow-Level Virtual Machine (a compiler) The Julia JIT compiler is a program/library called libLLVM. Codegen in Julia refers both to the process of taking a Julia AST and turning it into LLVM instructions, and the process of LLVM optimizing that and turning it into native assembly instructions.\\nC++\\nThe programming language that LLVM is implemented in, which means that codegen is also implemented in this language. The rest of Julia\\'s library is implemented in C, in part because its smaller feature set makes it more usable as a cross-language interface layer.\\nbox\\nThis term is used to describe the process of taking a value and allocating a wrapper around the data that is tracked by the garbage collector (gc) and is tagged with the object\\'s type.\\nunbox\\nThe reverse of boxing a value. This operation enables more efficient manipulation of data when the type of that data is fully known at compile-time (through type inference).\\ngeneric function\\nA Julia function composed of multiple \\\"methods\\\" that are selected for dynamic dispatch based on the argument type-signature\\nanonymous function or \\\"method\\\"\\nA Julia function without a name and without type-dispatch capabilities\\nprimitive function\\nA function implemented in C but exposed in Julia as a named function \\\"method\\\" (albeit without generic function dispatch capabilities, similar to a anonymous function)\\nintrinsic function\\nA low-level operation exposed as a function in Julia. These pseudo-functions implement operations on raw bits such as add and sign extend that cannot be expressed directly in any other way. Since they operate on bits directly, they must be compiled into a function and surrounded by a call to Core.Intrinsics.box(T, ...) to reassign type information to the value.\"\n},\n\n{\n    \"location\": \"devdocs/eval.html#dev-codegen-1\",\n    \"page\": \"Eval of Julia code\",\n    \"title\": \"JIT Code Generation\",\n    \"category\": \"section\",\n    \"text\": \"Codegen is the process of turning a Julia AST into native machine code.The JIT environment is initialized by an early call to jl_init_codegen in codegen.cpp.On demand, a Julia method is converted into a native function by the function emit_function(jl_method_instance_t*). (note, when using the MCJIT (in LLVM v3.4+), each function must be JIT into a new module.) This function recursively calls emit_expr() until the entire function has been emitted.Much of the remaining bulk of this file is devoted to various manual optimizations of specific code patterns. For example, emit_known_call() knows how to inline many of the primitive functions (defined in builtins.c) for various combinations of argument types.Other parts of codegen are handled by various helper files:debuginfo.cpp\\nHandles backtraces for JIT functions\\nccall.cpp\\nHandles the ccall and llvmcall FFI, along with various abi_*.cpp files\\nintrinsics.cpp\\nHandles the emission of various low-level intrinsic functionssidebar: Bootstrapping\\nThe process of creating a new system image is called \\\"bootstrapping\\\".The etymology of this word comes from the phrase \\\"pulling oneself up by the bootstraps\\\", and refers to the idea of starting from a very limited set of available functions and definitions and ending with the creation of a full-featured environment.\"\n},\n\n{\n    \"location\": \"devdocs/eval.html#dev-sysimg-1\",\n    \"page\": \"Eval of Julia code\",\n    \"title\": \"System Image\",\n    \"category\": \"section\",\n    \"text\": \"The system image is a precompiled archive of a set of Julia files. The sys.ji file distributed with Julia is one such system image, generated by executing the file sysimg.jl, and serializing the resulting environment (including Types, Functions, Modules, and all other defined values) into a file. Therefore, it contains a frozen version of the Main, Core, and Base modules (and whatever else was in the environment at the end of bootstrapping). This serializer/deserializer is implemented by jl_save_system_image/jl_restore_system_image in staticdata.c.If there is no sysimg file (jl_options.image_file == NULL), this also implies that --build was given on the command line, so the final result should be a new sysimg file. During Julia initialization, minimal Core and Main modules are created. Then a file named boot.jl is evaluated from the current directory. Julia then evaluates any file given as a command line argument until it reaches the end. Finally, it saves the resulting environment to a \\\"sysimg\\\" file for use as a starting point for a future Julia run.\"\n},\n\n{\n    \"location\": \"devdocs/callconv.html#\",\n    \"page\": \"Calling Conventions\",\n    \"title\": \"Calling Conventions\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/callconv.html#Calling-Conventions-1\",\n    \"page\": \"Calling Conventions\",\n    \"title\": \"Calling Conventions\",\n    \"category\": \"section\",\n    \"text\": \"Julia uses three calling conventions for four distinct purposes:Name Prefix Purpose\\nNative julia_ Speed via specialized signatures\\nJL Call jlcall_ Wrapper for generic calls\\nJL Call jl_ Builtins\\nC ABI jlcapi_ Wrapper callable from C\"\n},\n\n{\n    \"location\": \"devdocs/callconv.html#Julia-Native-Calling-Convention-1\",\n    \"page\": \"Calling Conventions\",\n    \"title\": \"Julia Native Calling Convention\",\n    \"category\": \"section\",\n    \"text\": \"The native calling convention is designed for fast non-generic calls. It usually uses a specialized signature.LLVM ghosts (zero-length types) are omitted.\\nLLVM scalars and vectors are passed by value.\\nLLVM aggregates (arrays and structs) are passed by reference.A small return values is returned as LLVM return values. A large return values is returned via the \\\"structure return\\\" (sret) convention, where the caller provides a pointer to a return slot.An argument or return values that is a homogeneous tuple is sometimes represented as an LLVM vector instead of an LLVM array.\"\n},\n\n{\n    \"location\": \"devdocs/callconv.html#JL-Call-Convention-1\",\n    \"page\": \"Calling Conventions\",\n    \"title\": \"JL Call Convention\",\n    \"category\": \"section\",\n    \"text\": \"The JL Call convention is for builtins and generic dispatch. Hand-written functions using this convention are declared via the macro JL_CALLABLE. The convention uses exactly 3 parameters:F  - Julia representation of function that is being applied\\nargs - pointer to array of pointers to boxes\\nnargs - length of the arrayThe return value is a pointer to a box.\"\n},\n\n{\n    \"location\": \"devdocs/callconv.html#C-ABI-1\",\n    \"page\": \"Calling Conventions\",\n    \"title\": \"C ABI\",\n    \"category\": \"section\",\n    \"text\": \"C ABI wrappers enable calling Julia from C. The wrapper calls a function using the native calling convention.Tuples are always represented as C arrays.\"\n},\n\n{\n    \"location\": \"devdocs/compiler.html#\",\n    \"page\": \"High-level Overview of the Native-Code Generation Process\",\n    \"title\": \"High-level Overview of the Native-Code Generation Process\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/compiler.html#High-level-Overview-of-the-Native-Code-Generation-Process-1\",\n    \"page\": \"High-level Overview of the Native-Code Generation Process\",\n    \"title\": \"High-level Overview of the Native-Code Generation Process\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/compiler.html#Representation-of-Pointers-1\",\n    \"page\": \"High-level Overview of the Native-Code Generation Process\",\n    \"title\": \"Representation of Pointers\",\n    \"category\": \"section\",\n    \"text\": \"When emitting code to an object file, pointers will be emitted as relocations. The deserialization code will ensure any object that pointed to one of these constants gets recreated and contains the right runtime pointer.Otherwise, they will be emitted as literal constants.To emit one of these objects, call literal_pointer_val. It\\'ll handle tracking the Julia value and the LLVM global, ensuring they are valid both for the current runtime and after deserialization.When emitted into the object file, these globals are stored as references in a large gvals table. This allows the deserializer to reference them by index, and implement a custom manual mechanism similar to a Global Offset Table (GOT) to restore them.Function pointers are handled similarly. They are stored as values in a large fvals table. Like globals, this allows the deserializer to reference them by index.Note that extern functions are handled separately, with names, via the usual symbol resolution mechanism in the linker.Note too that ccall functions are also handled separately, via a manual GOT and Procedure Linkage Table (PLT).\"\n},\n\n{\n    \"location\": \"devdocs/compiler.html#Representation-of-Intermediate-Values-1\",\n    \"page\": \"High-level Overview of the Native-Code Generation Process\",\n    \"title\": \"Representation of Intermediate Values\",\n    \"category\": \"section\",\n    \"text\": \"Values are passed around in a jl_cgval_t struct. This represents an R-value, and includes enough information to determine how to assign or pass it somewhere.They are created via one of the helper constructors, usually: mark_julia_type (for immediate values) and mark_julia_slot (for pointers to values).The function convert_julia_type can transform between any two types. It returns an R-value with cgval.typ set to typ. It\\'ll cast the object to the requested representation, making heap boxes, allocating stack copies, and computing tagged unions as needed to change the representation.By contrast update_julia_type will change cgval.typ to typ, only if it can be done at zero-cost (i.e. without emitting any code).\"\n},\n\n{\n    \"location\": \"devdocs/compiler.html#Union-representation-1\",\n    \"page\": \"High-level Overview of the Native-Code Generation Process\",\n    \"title\": \"Union representation\",\n    \"category\": \"section\",\n    \"text\": \"Inferred union types may be stack allocated via a tagged type representation.The primitive routines that need to be able to handle tagged unions are:mark-type\\nload-local\\nstore-local\\nisa\\nis\\nemit_typeof\\nemit_sizeof\\nboxed\\nunbox\\nspecialized cc-retEverything else should be possible to handle in inference by using these primitives to implement union-splitting.The representation of the tagged-union is as a pair of < void* union, byte selector >. The selector is fixed-size as byte & 0x7f, and will union-tag the first 126 isbits. It records the one-based depth-first count into the type-union of the isbits objects inside. An index of zero indicates that the union* is actually a tagged heap-allocated jl_value_t*, and needs to be treated as normal for a boxed object rather than as a tagged union.The high bit of the selector (byte & 0x80) can be tested to determine if the void* is actually a heap-allocated (jl_value_t*) box, thus avoiding the cost of re-allocating a box, while maintaining the ability to efficiently handle union-splitting based on the low bits.It is guaranteed that byte & 0x7f is an exact test for the type, if the value can be represented by a tag \u2013 it will never be marked byte = 0x80. It is not necessary to also test the type-tag when testing isa.The union* memory region may be allocated at any size. The only constraint is that it is big enough to contain the data currently specified by selector. It might not be big enough to contain the union of all types that could be stored there according to the associated Union type field. Use appropriate care when copying.\"\n},\n\n{\n    \"location\": \"devdocs/compiler.html#Specialized-Calling-Convention-Signature-Representation-1\",\n    \"page\": \"High-level Overview of the Native-Code Generation Process\",\n    \"title\": \"Specialized Calling Convention Signature Representation\",\n    \"category\": \"section\",\n    \"text\": \"A jl_returninfo_t object describes the calling convention details of any callable.If any of the arguments or return type of a method can be represented unboxed, and the method is not varargs, it\\'ll be given an optimized calling convention signature based on its specTypes and rettype fields.The general principles are that:Primitive types get passed in int/float registers.\\nTuples of VecElement types get passed in vector registers.\\nStructs get passed on the stack.\\nReturn values are handle similarly to arguments, with a size-cutoff at which they will instead be returned via a hidden sret argument.The total logic for this is implemented by get_specsig_function and deserves_sret.Additionally, if the return type is a union, it may be returned as a pair of values (a pointer and a tag). If the union values can be stack-allocated, then sufficient space to store them will also be passed as a hidden first argument. It is up to the callee whether the returned pointer will point to this space, a boxed object, or even other constant memory.\"\n},\n\n{\n    \"location\": \"devdocs/functions.html#\",\n    \"page\": \"Julia Functions\",\n    \"title\": \"Julia Functions\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/functions.html#Julia-Functions-1\",\n    \"page\": \"Julia Functions\",\n    \"title\": \"Julia Functions\",\n    \"category\": \"section\",\n    \"text\": \"This document will explain how functions, method definitions, and method tables work.\"\n},\n\n{\n    \"location\": \"devdocs/functions.html#Method-Tables-1\",\n    \"page\": \"Julia Functions\",\n    \"title\": \"Method Tables\",\n    \"category\": \"section\",\n    \"text\": \"Every function in Julia is a generic function. A generic function is conceptually a single function, but consists of many definitions, or methods. The methods of a generic function are stored in a method table. Method tables (type MethodTable) are associated with TypeNames. A TypeName describes a family of parameterized types. For example Complex{Float32} and Complex{Float64} share the same Complex type name object.All objects in Julia are potentially callable, because every object has a type, which in turn has a TypeName.\"\n},\n\n{\n    \"location\": \"devdocs/functions.html#Function-calls-1\",\n    \"page\": \"Julia Functions\",\n    \"title\": \"Function calls\",\n    \"category\": \"section\",\n    \"text\": \"Given the call f(x,y), the following steps are performed: first, the method table to use is accessed as typeof(f).name.mt. Second, an argument tuple type is formed, Tuple{typeof(f), typeof(x), typeof(y)}. Note that the type of the function itself is the first element. This is because the type might have parameters, and so needs to take part in dispatch. This tuple type is looked up in the method table.This dispatch process is performed by jl_apply_generic, which takes two arguments: a pointer to an array of the values f, x, and y, and the number of values (in this case 3).Throughout the system, there are two kinds of APIs that handle functions and argument lists: those that accept the function and arguments separately, and those that accept a single argument structure. In the first kind of API, the \\\"arguments\\\" part does not contain information about the function, since that is passed separately. In the second kind of API, the function is the first element of the argument structure.For example, the following function for performing a call accepts just an args pointer, so the first element of the args array will be the function to call:jl_value_t *jl_apply(jl_value_t **args, uint32_t nargs)This entry point for the same functionality accepts the function separately, so the args array does not contain the function:jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs);\"\n},\n\n{\n    \"location\": \"devdocs/functions.html#Adding-methods-1\",\n    \"page\": \"Julia Functions\",\n    \"title\": \"Adding methods\",\n    \"category\": \"section\",\n    \"text\": \"Given the above dispatch process, conceptually all that is needed to add a new method is (1) a tuple type, and (2) code for the body of the method. jl_method_def implements this operation. jl_first_argument_datatype is called to extract the relevant method table from what would be the type of the first argument. This is much more complicated than the corresponding procedure during dispatch, since the argument tuple type might be abstract. For example, we can define:(::Union{Foo{Int},Foo{Int8}})(x) = 0which works since all possible matching methods would belong to the same method table.\"\n},\n\n{\n    \"location\": \"devdocs/functions.html#Creating-generic-functions-1\",\n    \"page\": \"Julia Functions\",\n    \"title\": \"Creating generic functions\",\n    \"category\": \"section\",\n    \"text\": \"Since every object is callable, nothing special is needed to create a generic function. Therefore jl_new_generic_function simply creates a new singleton (0 size) subtype of Function and returns its instance. A function can have a mnemonic \\\"display name\\\" which is used in debug info and when printing objects. For example the name of Base.sin is sin. By convention, the name of the created type is the same as the function name, with a # prepended. So typeof(sin) is Base.#sin.\"\n},\n\n{\n    \"location\": \"devdocs/functions.html#Closures-1\",\n    \"page\": \"Julia Functions\",\n    \"title\": \"Closures\",\n    \"category\": \"section\",\n    \"text\": \"A closure is simply a callable object with field names corresponding to captured variables. For example, the following code:function adder(x)\\n    return y->x+y\\nendis lowered to (roughly):struct ##1{T}\\n    x::T\\nend\\n\\n(_::##1)(y) = _.x + y\\n\\nfunction adder(x)\\n    return ##1(x)\\nend\"\n},\n\n{\n    \"location\": \"devdocs/functions.html#Constructors-1\",\n    \"page\": \"Julia Functions\",\n    \"title\": \"Constructors\",\n    \"category\": \"section\",\n    \"text\": \"A constructor call is just a call to a type. The method table for Type contains all constructor definitions. All subtypes of Type (Type, UnionAll, Union, and DataType) currently share a method table via special arrangement.\"\n},\n\n{\n    \"location\": \"devdocs/functions.html#Builtins-1\",\n    \"page\": \"Julia Functions\",\n    \"title\": \"Builtins\",\n    \"category\": \"section\",\n    \"text\": \"The \\\"builtin\\\" functions, defined in the Core module, are:=== typeof sizeof <: isa typeassert throw tuple getfield setfield! fieldtype\\nnfields isdefined arrayref arrayset arraysize applicable invoke apply_type _apply\\n_expr svecThese are all singleton objects whose types are subtypes of Builtin, which is a subtype of Function. Their purpose is to expose entry points in the run time that use the \\\"jlcall\\\" calling convention:jl_value_t *(jl_value_t*, jl_value_t**, uint32_t)The method tables of builtins are empty. Instead, they have a single catch-all method cache entry (Tuple{Vararg{Any}}) whose jlcall fptr points to the correct function. This is kind of a hack but works reasonably well.\"\n},\n\n{\n    \"location\": \"devdocs/functions.html#Keyword-arguments-1\",\n    \"page\": \"Julia Functions\",\n    \"title\": \"Keyword arguments\",\n    \"category\": \"section\",\n    \"text\": \"Keyword arguments work by associating a special, hidden function object with each method table that has definitions with keyword arguments. This function is called the \\\"keyword argument sorter\\\" or \\\"keyword sorter\\\", or \\\"kwsorter\\\", and is stored in the kwsorter field of MethodTable objects. Every definition in the kwsorter function has the same arguments as some definition in the normal method table, except with a single NamedTuple argument prepended, which gives the names and values of passed keyword arguments. The kwsorter\\'s job is to move keyword arguments into their canonical positions based on name, plus evaluate and substitute any needed default value expressions. The result is a normal positional argument list, which is then passed to yet another compiler-generated function.The easiest way to understand the process is to look at how a keyword argument method definition is lowered. The code:function circle(center, radius; color = black, fill::Bool = true, options...)\\n    # draw\\nendactually produces three method definitions. The first is a function that accepts all arguments (including keyword arguments) as positional arguments, and includes the code for the method body. It has an auto-generated name:function #circle#1(color, fill::Bool, options, circle, center, radius)\\n    # draw\\nendThe second method is an ordinary definition for the original circle function, which handles the case where no keyword arguments are passed:function circle(center, radius)\\n    #circle#1(black, true, pairs(NamedTuple()), circle, center, radius)\\nendThis simply dispatches to the first method, passing along default values. pairs is applied to the named tuple of rest arguments to provide key-value pair iteration. Note that if the method doesn\\'t accept rest keyword arguments then this argument is absent.Finally there is the kwsorter definition:function (::Core.kwftype(typeof(circle)))(kws, circle, center, radius)\\n    if haskey(kws, :color)\\n        color = kws.color\\n    else\\n        color = black\\n    end\\n    # etc.\\n\\n    # put remaining kwargs in `options`\\n    options = structdiff(kws, NamedTuple{(:color, :fill)})\\n\\n    # if the method doesn\\'t accept rest keywords, throw an error\\n    # unless `options` is empty\\n\\n    #circle#1(color, fill, pairs(options), circle, center, radius)\\nendThe function Core.kwftype(t) creates the field t.name.mt.kwsorter (if it hasn\\'t been created yet), and returns the type of that function.This design has the feature that call sites that don\\'t use keyword arguments require no special handling; everything works as if they were not part of the language at all. Call sites that do use keyword arguments are dispatched directly to the called function\\'s kwsorter. For example the call:circle((0,0), 1.0, color = red; other...)is lowered to:kwfunc(circle)(merge((color = red,), other), circle, (0,0), 1.0)kwfunc (also inCore) fetches the kwsorter for the called function. The keyword splatting operation (written as other...) calls the named tuple merge function. This function further unpacks each element of other, expecting each one to contain two values (a symbol and a value). Naturally, a more efficient implementation is available if all splatted arguments are named tuples. Notice that the original circle function is passed through, to handle closures.\"\n},\n\n{\n    \"location\": \"devdocs/functions.html#Compiler-efficiency-issues-1\",\n    \"page\": \"Julia Functions\",\n    \"title\": \"Compiler efficiency issues\",\n    \"category\": \"section\",\n    \"text\": \"Generating a new type for every function has potentially serious consequences for compiler resource use when combined with Julia\\'s \\\"specialize on all arguments by default\\\" design. Indeed, the initial implementation of this design suffered from much longer build and test times, higher memory use, and a system image nearly 2x larger than the baseline. In a naive implementation, the problem is bad enough to make the system nearly unusable. Several significant optimizations were needed to make the design practical.The first issue is excessive specialization of functions for different values of function-valued arguments. Many functions simply \\\"pass through\\\" an argument to somewhere else, e.g. to another function or to a storage location. Such functions do not need to be specialized for every closure that might be passed in. Fortunately this case is easy to distinguish by simply considering whether a function calls one of its arguments (i.e. the argument appears in \\\"head position\\\" somewhere). Performance-critical higher-order functions like map certainly call their argument function and so will still be specialized as expected. This optimization is implemented by recording which arguments are called during the analyze-variables pass in the front end. When cache_method sees an argument in the Function type hierarchy passed to a slot declared as Any or Function, it behaves as if the @nospecialize annotation were applied. This heuristic seems to be extremely effective in practice.The next issue concerns the structure of method cache hash tables. Empirical studies show that the vast majority of dynamically-dispatched calls involve one or two arguments. In turn, many of these cases can be resolved by considering only the first argument. (Aside: proponents of single dispatch would not be surprised by this at all. However, this argument means \\\"multiple dispatch is easy to optimize in practice\\\", and that we should therefore use it, not \\\"we should use single dispatch\\\"!) So the method cache uses the type of the first argument as its primary key. Note, however, that this corresponds to the second element of the tuple type for a function call (the first element being the type of the function itself). Typically, type variation in head position is extremely low \u2013 indeed, the majority of functions belong to singleton types with no parameters. However, this is not the case for constructors, where a single method table holds constructors for every type. Therefore the Type method table is special-cased to use the first tuple type element instead of the second.The front end generates type declarations for all closures. Initially, this was implemented by generating normal type declarations. However, this produced an extremely large number of constructors, all of which were trivial (simply passing all arguments through to new). Since methods are partially ordered, inserting all of these methods is O(n^2), plus there are just too many of them to keep around. This was optimized by generating struct_type expressions directly (bypassing default constructor generation), and using new directly to create closure instances. Not the prettiest thing ever, but you do what you gotta do.The next problem was the @test macro, which generated a 0-argument closure for each test case. This is not really necessary, since each test case is simply run once in place. Therefore, @test was modified to expand to a try-catch block that records the test result (true, false, or exception raised) and calls the test suite handler on it.\"\n},\n\n{\n    \"location\": \"devdocs/cartesian.html#\",\n    \"page\": \"Base.Cartesian\",\n    \"title\": \"Base.Cartesian\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/cartesian.html#Base.Cartesian-1\",\n    \"page\": \"Base.Cartesian\",\n    \"title\": \"Base.Cartesian\",\n    \"category\": \"section\",\n    \"text\": \"The (non-exported) Cartesian module provides macros that facilitate writing multidimensional algorithms. It is hoped that Cartesian will not, in the long term, be necessary; however, at present it is one of the few ways to write compact and performant multidimensional code.\"\n},\n\n{\n    \"location\": \"devdocs/cartesian.html#Principles-of-usage-1\",\n    \"page\": \"Base.Cartesian\",\n    \"title\": \"Principles of usage\",\n    \"category\": \"section\",\n    \"text\": \"A simple example of usage is:@nloops 3 i A begin\\n    s += @nref 3 A i\\nendwhich generates the following code:for i_3 = 1:size(A,3)\\n    for i_2 = 1:size(A,2)\\n        for i_1 = 1:size(A,1)\\n            s += A[i_1,i_2,i_3]\\n        end\\n    end\\nendIn general, Cartesian allows you to write generic code that contains repetitive elements, like the nested loops in this example.  Other applications include repeated expressions (e.g., loop unwinding) or creating function calls with variable numbers of arguments without using the \\\"splat\\\" construct (i...).\"\n},\n\n{\n    \"location\": \"devdocs/cartesian.html#Basic-syntax-1\",\n    \"page\": \"Base.Cartesian\",\n    \"title\": \"Basic syntax\",\n    \"category\": \"section\",\n    \"text\": \"The (basic) syntax of @nloops is as follows:The first argument must be an integer (not a variable) specifying the number of loops.\\nThe second argument is the symbol-prefix used for the iterator variable. Here we used i, and variables i_1, i_2, i_3 were generated.\\nThe third argument specifies the range for each iterator variable. If you use a variable (symbol) here, it\\'s taken as 1:size(A,dim). More flexibly, you can use the anonymous-function expression syntax described below.\\nThe last argument is the body of the loop. Here, that\\'s what appears between the begin...end.There are some additional features of @nloops described in the reference section.@nref follows a similar pattern, generating A[i_1,i_2,i_3] from @nref 3 A i. The general practice is to read from left to right, which is why @nloops is @nloops 3 i A expr (as in for i_2 = 1:size(A,2), where i_2 is to the left and the range is to the right) whereas @nref is @nref 3 A i (as in A[i_1,i_2,i_3], where the array comes first).If you\\'re developing code with Cartesian, you may find that debugging is easier when you examine the generated code, using @macroexpand:DocTestSetup = quote\\n    import Base.Cartesian: @nref\\nendjulia> @macroexpand @nref 2 A i\\n:(A[i_1, i_2])DocTestSetup = nothing\"\n},\n\n{\n    \"location\": \"devdocs/cartesian.html#Supplying-the-number-of-expressions-1\",\n    \"page\": \"Base.Cartesian\",\n    \"title\": \"Supplying the number of expressions\",\n    \"category\": \"section\",\n    \"text\": \"The first argument to both of these macros is the number of expressions, which must be an integer. When you\\'re writing a function that you intend to work in multiple dimensions, this may not be something you want to hard-code. If you\\'re writing code that you need to work with older Julia versions, currently you should use the @ngenerate macro described in an older version of this documentation.Starting in Julia 0.4-pre, the recommended approach is to use a @generated function.  Here\\'s an example:@generated function mysum(A::Array{T,N}) where {T,N}\\n    quote\\n        s = zero(T)\\n        @nloops $N i A begin\\n            s += @nref $N A i\\n        end\\n        s\\n    end\\nendNaturally, you can also prepare expressions or perform calculations before the quote block.\"\n},\n\n{\n    \"location\": \"devdocs/cartesian.html#Anonymous-function-expressions-as-macro-arguments-1\",\n    \"page\": \"Base.Cartesian\",\n    \"title\": \"Anonymous-function expressions as macro arguments\",\n    \"category\": \"section\",\n    \"text\": \"Perhaps the single most powerful feature in Cartesian is the ability to supply anonymous-function expressions that get evaluated at parsing time.  Let\\'s consider a simple example:@nexprs 2 j->(i_j = 1)@nexprs generates n expressions that follow a pattern. This code would generate the following statements:i_1 = 1\\ni_2 = 1In each generated statement, an \\\"isolated\\\" j (the variable of the anonymous function) gets replaced by values in the range 1:2. Generally speaking, Cartesian employs a LaTeX-like syntax.  This allows you to do math on the index j.  Here\\'s an example computing the strides of an array:s_1 = 1\\n@nexprs 3 j->(s_{j+1} = s_j * size(A, j))would generate expressionss_1 = 1\\ns_2 = s_1 * size(A, 1)\\ns_3 = s_2 * size(A, 2)\\ns_4 = s_3 * size(A, 3)Anonymous-function expressions have many uses in practice.\"\n},\n\n{\n    \"location\": \"devdocs/cartesian.html#Base.Cartesian.@nloops\",\n    \"page\": \"Base.Cartesian\",\n    \"title\": \"Base.Cartesian.@nloops\",\n    \"category\": \"macro\",\n    \"text\": \"@nloops N itersym rangeexpr bodyexpr\\n@nloops N itersym rangeexpr preexpr bodyexpr\\n@nloops N itersym rangeexpr preexpr postexpr bodyexpr\\n\\nGenerate N nested loops, using itersym as the prefix for the iteration variables. rangeexpr may be an anonymous-function expression, or a simple symbol var in which case the range is axes(var, d) for dimension d.\\n\\nOptionally, you can provide \\\"pre\\\" and \\\"post\\\" expressions. These get executed first and last, respectively, in the body of each loop. For example:\\n\\n@nloops 2 i A d -> j_d = min(i_d, 5) begin\\n    s += @nref 2 A j\\nend\\n\\nwould generate:\\n\\nfor i_2 = axes(A, 2)\\n    j_2 = min(i_2, 5)\\n    for i_1 = axes(A, 1)\\n        j_1 = min(i_1, 5)\\n        s += A[j_1, j_2]\\n    end\\nend\\n\\nIf you want just a post-expression, supply nothing for the pre-expression. Using parentheses and semicolons, you can supply multi-statement expressions.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"devdocs/cartesian.html#Base.Cartesian.@nref\",\n    \"page\": \"Base.Cartesian\",\n    \"title\": \"Base.Cartesian.@nref\",\n    \"category\": \"macro\",\n    \"text\": \"@nref N A indexexpr\\n\\nGenerate expressions like A[i_1, i_2, ...]. indexexpr can either be an iteration-symbol prefix, or an anonymous-function expression.\\n\\nExamples\\n\\njulia> @macroexpand Base.Cartesian.@nref 3 A i\\n:(A[i_1, i_2, i_3])\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"devdocs/cartesian.html#Base.Cartesian.@nextract\",\n    \"page\": \"Base.Cartesian\",\n    \"title\": \"Base.Cartesian.@nextract\",\n    \"category\": \"macro\",\n    \"text\": \"@nextract N esym isym\\n\\nGenerate N variables esym_1, esym_2, ..., esym_N to extract values from isym. isym can be either a Symbol or anonymous-function expression.\\n\\n@nextract 2 x y would generate\\n\\nx_1 = y[1]\\nx_2 = y[2]\\n\\nwhile @nextract 3 x d->y[2d-1] yields\\n\\nx_1 = y[1]\\nx_2 = y[3]\\nx_3 = y[5]\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"devdocs/cartesian.html#Base.Cartesian.@nexprs\",\n    \"page\": \"Base.Cartesian\",\n    \"title\": \"Base.Cartesian.@nexprs\",\n    \"category\": \"macro\",\n    \"text\": \"@nexprs N expr\\n\\nGenerate N expressions. expr should be an anonymous-function expression.\\n\\nExamples\\n\\njulia> @macroexpand Base.Cartesian.@nexprs 4 i -> y[i] = A[i+j]\\nquote\\n    y[1] = A[1 + j]\\n    y[2] = A[2 + j]\\n    y[3] = A[3 + j]\\n    y[4] = A[4 + j]\\nend\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"devdocs/cartesian.html#Base.Cartesian.@ncall\",\n    \"page\": \"Base.Cartesian\",\n    \"title\": \"Base.Cartesian.@ncall\",\n    \"category\": \"macro\",\n    \"text\": \"@ncall N f sym...\\n\\nGenerate a function call expression. sym represents any number of function arguments, the last of which may be an anonymous-function expression and is expanded into N arguments.\\n\\nFor example, @ncall 3 func a generates\\n\\nfunc(a_1, a_2, a_3)\\n\\nwhile @ncall 2 func a b i->c[i] yields\\n\\nfunc(a, b, c[1], c[2])\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"devdocs/cartesian.html#Base.Cartesian.@ntuple\",\n    \"page\": \"Base.Cartesian\",\n    \"title\": \"Base.Cartesian.@ntuple\",\n    \"category\": \"macro\",\n    \"text\": \"@ntuple N expr\\n\\nGenerates an N-tuple. @ntuple 2 i would generate (i_1, i_2), and @ntuple 2 k->k+1 would generate (2,3).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"devdocs/cartesian.html#Base.Cartesian.@nall\",\n    \"page\": \"Base.Cartesian\",\n    \"title\": \"Base.Cartesian.@nall\",\n    \"category\": \"macro\",\n    \"text\": \"@nall N expr\\n\\nCheck whether all of the expressions generated by the anonymous-function expression expr evaluate to true.\\n\\n@nall 3 d->(i_d > 1) would generate the expression (i_1 > 1 && i_2 > 1 && i_3 > 1). This can be convenient for bounds-checking.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"devdocs/cartesian.html#Base.Cartesian.@nany\",\n    \"page\": \"Base.Cartesian\",\n    \"title\": \"Base.Cartesian.@nany\",\n    \"category\": \"macro\",\n    \"text\": \"@nany N expr\\n\\nCheck whether any of the expressions generated by the anonymous-function expression expr evaluate to true.\\n\\n@nany 3 d->(i_d > 1) would generate the expression (i_1 > 1 || i_2 > 1 || i_3 > 1).\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"devdocs/cartesian.html#Base.Cartesian.@nif\",\n    \"page\": \"Base.Cartesian\",\n    \"title\": \"Base.Cartesian.@nif\",\n    \"category\": \"macro\",\n    \"text\": \"@nif N conditionexpr expr\\n@nif N conditionexpr expr elseexpr\\n\\nGenerates a sequence of if ... elseif ... else ... end statements. For example:\\n\\n@nif 3 d->(i_d >= size(A,d)) d->(error(\\\"Dimension \\\", d, \\\" too big\\\")) d->println(\\\"All OK\\\")\\n\\nwould generate:\\n\\nif i_1 > size(A, 1)\\n    error(\\\"Dimension \\\", 1, \\\" too big\\\")\\nelseif i_2 > size(A, 2)\\n    error(\\\"Dimension \\\", 2, \\\" too big\\\")\\nelse\\n    println(\\\"All OK\\\")\\nend\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"devdocs/cartesian.html#dev-cartesian-reference-1\",\n    \"page\": \"Base.Cartesian\",\n    \"title\": \"Macro reference\",\n    \"category\": \"section\",\n    \"text\": \"Base.Cartesian.@nloops\\nBase.Cartesian.@nref\\nBase.Cartesian.@nextract\\nBase.Cartesian.@nexprs\\nBase.Cartesian.@ncall\\nBase.Cartesian.@ntuple\\nBase.Cartesian.@nall\\nBase.Cartesian.@nany\\nBase.Cartesian.@nif\"\n},\n\n{\n    \"location\": \"devdocs/meta.html#\",\n    \"page\": \"Talking to the compiler (the :meta mechanism)\",\n    \"title\": \"Talking to the compiler (the :meta mechanism)\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/meta.html#Talking-to-the-compiler-(the-:meta-mechanism)-1\",\n    \"page\": \"Talking to the compiler (the :meta mechanism)\",\n    \"title\": \"Talking to the compiler (the :meta mechanism)\",\n    \"category\": \"section\",\n    \"text\": \"In some circumstances, one might wish to provide hints or instructions that a given block of code has special properties: you might always want to inline it, or you might want to turn on special compiler optimization passes.  Starting with version 0.4, Julia has a convention that these instructions can be placed inside a :meta expression, which is typically (but not necessarily) the first expression in the body of a function.:meta expressions are created with macros. As an example, consider the implementation of the @inline macro:macro inline(ex)\\n    esc(isa(ex, Expr) ? pushmeta!(ex, :inline) : ex)\\nendHere, ex is expected to be an expression defining a function. A statement like this:@inline function myfunction(x)\\n    x*(x+3)\\nendgets turned into an expression like this:quote\\n    function myfunction(x)\\n        Expr(:meta, :inline)\\n        x*(x+3)\\n    end\\nendBase.pushmeta!(ex, :symbol, args...) appends :symbol to the end of the :meta expression, creating a new :meta expression if necessary. If args is specified, a nested expression containing :symbol and these arguments is appended instead, which can be used to specify additional information.To use the metadata, you have to parse these :meta expressions. If your implementation can be performed within Julia, Base.popmeta! is very handy: Base.popmeta!(body, :symbol) will scan a function body expression (one without the function signature) for the first :meta expression containing :symbol, extract any arguments, and return a tuple (found::Bool, args::Array{Any}). If the metadata did not have any arguments, or :symbol was not found, the args array will be empty.Not yet provided is a convenient infrastructure for parsing :meta expressions from C++.\"\n},\n\n{\n    \"location\": \"devdocs/subarrays.html#\",\n    \"page\": \"SubArrays\",\n    \"title\": \"SubArrays\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/subarrays.html#SubArrays-1\",\n    \"page\": \"SubArrays\",\n    \"title\": \"SubArrays\",\n    \"category\": \"section\",\n    \"text\": \"Julia\\'s SubArray type is a container encoding a \\\"view\\\" of a parent AbstractArray.  This page documents some of the design principles and implementation of SubArrays.\"\n},\n\n{\n    \"location\": \"devdocs/subarrays.html#Indexing:-cartesian-vs.-linear-indexing-1\",\n    \"page\": \"SubArrays\",\n    \"title\": \"Indexing: cartesian vs. linear indexing\",\n    \"category\": \"section\",\n    \"text\": \"Broadly speaking, there are two main ways to access data in an array. The first, often called cartesian indexing, uses N indices for an N -dimensional AbstractArray.  For example, a matrix A (2-dimensional) can be indexed in cartesian style as A[i,j].  The second indexing method, referred to as linear indexing, uses a single index even for higher-dimensional objects.  For example, if A = reshape(1:12, 3, 4), then the expression A[5] returns the value 5.  Julia allows you to combine these styles of indexing: for example, a 3d array A3 can be indexed as A3[i,j], in which case i is interpreted as a cartesian index for the first dimension, and j is a linear index over dimensions 2 and 3.For Arrays, linear indexing appeals to the underlying storage format: an array is laid out as a contiguous block of memory, and hence the linear index is just the offset (+1) of the corresponding entry relative to the beginning of the array.  However, this is not true for many other AbstractArray types: examples include SparseMatrixCSC from the SparseArrays standard library module, arrays that require some kind of computation (such as interpolation), and the type under discussion here, SubArray. For these types, the underlying information is more naturally described in terms of cartesian indices.The getindex and setindex! functions for AbstractArray types may include automatic conversion between indexing types. For explicit conversion, CartesianIndices can be used.While converting from a cartesian index to a linear index is fast (it\\'s just multiplication and addition), converting from a linear index to a cartesian index is very slow: it relies on the div operation, which is one of the slowest low-level operations you can perform with a CPU.  For this reason, any code that deals with AbstractArray types is best designed in terms of cartesian, rather than linear, indexing.\"\n},\n\n{\n    \"location\": \"devdocs/subarrays.html#Index-replacement-1\",\n    \"page\": \"SubArrays\",\n    \"title\": \"Index replacement\",\n    \"category\": \"section\",\n    \"text\": \"Consider making 2d slices of a 3d array:DocTestSetup = :(import Random; Random.seed!(1234))julia> A = rand(2,3,4);\\n\\njulia> S1 = view(A, :, 1, 2:3)\\n2\u00d72 view(::Array{Float64,3}, :, 1, 2:3) with eltype Float64:\\n 0.200586  0.066423\\n 0.298614  0.956753\\n\\njulia> S2 = view(A, 1, :, 2:3)\\n3\u00d72 view(::Array{Float64,3}, 1, :, 2:3) with eltype Float64:\\n 0.200586  0.066423\\n 0.246837  0.646691\\n 0.648882  0.276021DocTestSetup = nothingview drops \\\"singleton\\\" dimensions (ones that are specified by an Int), so both S1 and S2 are two-dimensional SubArrays. Consequently, the natural way to index these is with S1[i,j]. To extract the value from the parent array A, the natural approach is to replace S1[i,j] with A[i,1,(2:3)[j]] and S2[i,j] with A[1,i,(2:3)[j]].The key feature of the design of SubArrays is that this index replacement can be performed without any runtime overhead.\"\n},\n\n{\n    \"location\": \"devdocs/subarrays.html#SubArray-design-1\",\n    \"page\": \"SubArrays\",\n    \"title\": \"SubArray design\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/subarrays.html#Type-parameters-and-fields-1\",\n    \"page\": \"SubArrays\",\n    \"title\": \"Type parameters and fields\",\n    \"category\": \"section\",\n    \"text\": \"The strategy adopted is first and foremost expressed in the definition of the type:struct SubArray{T,N,P,I,L} <: AbstractArray{T,N}\\n    parent::P\\n    indices::I\\n    offset1::Int       # for linear indexing and pointer, only valid when L==true\\n    stride1::Int       # used only for linear indexing\\n    ...\\nendSubArray has 5 type parameters.  The first two are the standard element type and dimensionality.  The next is the type of the parent AbstractArray.  The most heavily-used is the fourth parameter, a Tuple of the types of the indices for each dimension. The final one, L, is only provided as a convenience for dispatch; it\\'s a boolean that represents whether the index types support fast linear indexing. More on that later.If in our example above A is a Array{Float64, 3}, our S1 case above would be a SubArray{Float64,2,Array{Float64,3},Tuple{Base.Slice{Base.OneTo{Int64}},Int64,UnitRange{Int64}},false}. Note in particular the tuple parameter, which stores the types of the indices used to create S1. Likewise,julia> S1.indices\\n(Base.Slice(Base.OneTo(2)), 1, 2:3)Storing these values allows index replacement, and having the types encoded as parameters allows one to dispatch to efficient algorithms.\"\n},\n\n{\n    \"location\": \"devdocs/subarrays.html#Index-translation-1\",\n    \"page\": \"SubArrays\",\n    \"title\": \"Index translation\",\n    \"category\": \"section\",\n    \"text\": \"Performing index translation requires that you do different things for different concrete SubArray types.  For example, for S1, one needs to apply the i,j indices to the first and third dimensions of the parent array, whereas for S2 one needs to apply them to the second and third.  The simplest approach to indexing would be to do the type-analysis at runtime:parentindices = Vector{Any}()\\nfor thisindex in S.indices\\n    ...\\n    if isa(thisindex, Int)\\n        # Don\\'t consume one of the input indices\\n        push!(parentindices, thisindex)\\n    elseif isa(thisindex, AbstractVector)\\n        # Consume an input index\\n        push!(parentindices, thisindex[inputindex[j]])\\n        j += 1\\n    elseif isa(thisindex, AbstractMatrix)\\n        # Consume two input indices\\n        push!(parentindices, thisindex[inputindex[j], inputindex[j+1]])\\n        j += 2\\n    elseif ...\\nend\\nS.parent[parentindices...]Unfortunately, this would be disastrous in terms of performance: each element access would allocate memory, and involves the running of a lot of poorly-typed code.The better approach is to dispatch to specific methods to handle each type of stored index. That\\'s what reindex does: it dispatches on the type of the first stored index and consumes the appropriate number of input indices, and then it recurses on the remaining indices. In the case of S1, this expands toBase.reindex(S1, S1.indices, (i, j)) == (i, S1.indices[2], S1.indices[3][j])for any pair of indices (i,j) (except CartesianIndexs and arrays thereof, see below).This is the core of a SubArray; indexing methods depend upon reindex to do this index translation. Sometimes, though, we can avoid the indirection and make it even faster.\"\n},\n\n{\n    \"location\": \"devdocs/subarrays.html#Linear-indexing-1\",\n    \"page\": \"SubArrays\",\n    \"title\": \"Linear indexing\",\n    \"category\": \"section\",\n    \"text\": \"Linear indexing can be implemented efficiently when the entire array has a single stride that separates successive elements, starting from some offset. This means that we can pre-compute these values and represent linear indexing simply as an addition and multiplication, avoiding the indirection of reindex and (more importantly) the slow computation of the cartesian coordinates entirely.For SubArray types, the availability of efficient linear indexing is based purely on the types of the indices, and does not depend on values like the size of the parent array. You can ask whether a given set of indices supports fast linear indexing with the internal Base.viewindexing function:julia> Base.viewindexing(S1.indices)\\nIndexCartesian()\\n\\njulia> Base.viewindexing(S2.indices)\\nIndexLinear()This is computed during construction of the SubArray and stored in the L type parameter as a boolean that encodes fast linear indexing support. While not strictly necessary, it means that we can define dispatch directly on SubArray{T,N,A,I,true} without any intermediaries.Since this computation doesn\\'t depend on runtime values, it can miss some cases in which the stride happens to be uniform:julia> A = reshape(1:4*2, 4, 2)\\n4\u00d72 reshape(::UnitRange{Int64}, 4, 2) with eltype Int64:\\n 1  5\\n 2  6\\n 3  7\\n 4  8\\n\\njulia> diff(A[2:2:4,:][:])\\n3-element Array{Int64,1}:\\n 2\\n 2\\n 2A view constructed as view(A, 2:2:4, :) happens to have uniform stride, and therefore linear indexing indeed could be performed efficiently.  However, success in this case depends on the size of the array: if the first dimension instead were odd,julia> A = reshape(1:5*2, 5, 2)\\n5\u00d72 reshape(::UnitRange{Int64}, 5, 2) with eltype Int64:\\n 1   6\\n 2   7\\n 3   8\\n 4   9\\n 5  10\\n\\njulia> diff(A[2:2:4,:][:])\\n3-element Array{Int64,1}:\\n 2\\n 3\\n 2then A[2:2:4,:] does not have uniform stride, so we cannot guarantee efficient linear indexing.  Since we have to base this decision based purely on types encoded in the parameters of the SubArray, S = view(A, 2:2:4, :) cannot implement efficient linear indexing.\"\n},\n\n{\n    \"location\": \"devdocs/subarrays.html#A-few-details-1\",\n    \"page\": \"SubArrays\",\n    \"title\": \"A few details\",\n    \"category\": \"section\",\n    \"text\": \"Note that the Base.reindex function is agnostic to the types of the input indices; it simply determines how and where the stored indices should be reindexed. It not only supports integer indices, but it supports non-scalar indexing, too. This means that views of views don\\'t need two levels of indirection; they can simply re-compute the indices into the original parent array!\\nHopefully by now it\\'s fairly clear that supporting slices means that the dimensionality, given by the parameter N, is not necessarily equal to the dimensionality of the parent array or the length of the indices tuple.  Neither do user-supplied indices necessarily line up with entries in the indices tuple (e.g., the second user-supplied index might correspond to the third dimension of the parent array, and the third element in the indices tuple).\\nWhat might be less obvious is that the dimensionality of the stored parent array must be equal to the number of effective indices in the indices tuple. Some examples:\\nA = reshape(1:35, 5, 7) # A 2d parent Array\\nS = view(A, 2:7)         # A 1d view created by linear indexing\\nS = view(A, :, :, 1:1)   # Appending extra indices is supported\\nNaively, you\\'d think you could just set S.parent = A and S.indices = (:,:,1:1), but supporting this dramatically complicates the reindexing process, especially for views of views. Not only do you need to dispatch on the types of the stored indices, but you need to examine whether a given index is the final one and \\\"merge\\\" any remaining stored indices together. This is not an easy task, and even worse: it\\'s slow since it implicitly depends upon linear indexing.\\nFortunately, this is precisely the computation that ReshapedArray performs, and it does so linearly if possible. Consequently, view ensures that the parent array is the appropriate dimensionality for the given indices by reshaping it if needed. The inner SubArray constructor ensures that this invariant is satisfied.\\nCartesianIndex and arrays thereof throw a nasty wrench into the reindex scheme. Recall that reindex simply dispatches on the type of the stored indices in order to determine how many passed indices should be used and where they should go. But with CartesianIndex, there\\'s no longer a one-to-one correspondence between the number of passed arguments and the number of dimensions that they index into. If we return to the above example of Base.reindex(S1, S1.indices, (i, j)), you can see that the expansion is incorrect for i, j = CartesianIndex(), CartesianIndex(2,1). It should skip the CartesianIndex() entirely and return:\\n(CartesianIndex(2,1)[1], S1.indices[2], S1.indices[3][CartesianIndex(2,1)[2]])\\nInstead, though, we get:\\n(CartesianIndex(), S1.indices[2], S1.indices[3][CartesianIndex(2,1)])\\nDoing this correctly would require combined dispatch on both the stored and passed indices across all combinations of dimensionalities in an intractable manner. As such, reindex must never be called with CartesianIndex indices. Fortunately, the scalar case is easily handled by first flattening the CartesianIndex arguments to plain integers. Arrays of CartesianIndex, however, cannot be split apart into orthogonal pieces so easily. Before attempting to use reindex, view must ensure that there are no arrays of CartesianIndex in the argument list. If there are, it can simply \\\"punt\\\" by avoiding the reindex calculation entirely, constructing a nested SubArray with two levels of indirection instead.\"\n},\n\n{\n    \"location\": \"devdocs/isbitsunionarrays.html#\",\n    \"page\": \"isbits Union Optimizations\",\n    \"title\": \"isbits Union Optimizations\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/isbitsunionarrays.html#isbits-Union-Optimizations-1\",\n    \"page\": \"isbits Union Optimizations\",\n    \"title\": \"isbits Union Optimizations\",\n    \"category\": \"section\",\n    \"text\": \"In Julia, the Array type holds both \\\"bits\\\" values as well as heap-allocated \\\"boxed\\\" values. The distinction is whether the value itself is stored inline (in the direct allocated memory of the array), or if the memory of the array is simply a collection of pointers to objects allocated elsewhere. In terms of performance, accessing values inline is clearly an advantage over having to follow a pointer to the actual value. The definition of \\\"isbits\\\" generally means any Julia type with a fixed, determinate size, meaning no \\\"pointer\\\" fields, see ?isbitstype.Julia also supports Union types, quite literally the union of a set of types. Custom Union type definitions can be extremely handy for applications wishing to \\\"cut across\\\" the nominal type system (i.e. explicit subtype relationships) and define methods or functionality on these, otherwise unrelated, set of types. A compiler challenge, however, is in determining how to treat these Union types. The naive approach (and indeed, what Julia itself did pre-0.7), is to simply make a \\\"box\\\" and then a pointer in the box to the actual value, similar to the previously mentioned \\\"boxed\\\" values. This is unfortunate, however, because of the number of small, primitive \\\"bits\\\" types (think UInt8, Int32, Float64, etc.) that would easily fit themselves inline in this \\\"box\\\" without needing any indirection for value access. There are two main ways Julia can take advantage of this optimization as of 0.7: isbits Union fields in types, and isbits Union Arrays.\"\n},\n\n{\n    \"location\": \"devdocs/isbitsunionarrays.html#isbits-Union-Structs-1\",\n    \"page\": \"isbits Union Optimizations\",\n    \"title\": \"isbits Union Structs\",\n    \"category\": \"section\",\n    \"text\": \"Julia now includes an optimization wherein \\\"isbits Union\\\" fields in types (mutable struct, struct, etc.) will be stored inline. This is accomplished by determining the \\\"inline size\\\" of the Union type (e.g. Union{UInt8, Int16} will have a size of 16 bytes, which represents the size needed of the largest Union type Int16), and in addition, allocating an extra \\\"type tag byte\\\" (UInt8), whose value signals the type of the actual value stored inline of the \\\"Union bytes\\\". The type tag byte value is the index of the actual value\\'s type in the Union type\\'s order of types. For example, a type tag value of 0x02 for a field with type Union{Nothing, UInt8, Int16} would indicate that an Int16 value is stored in the 16 bytes of the field in the structure\\'s memory; a 0x01 value would indicate that a UInt8 value was stored in the first 8 bytes of the 16 bytes of the field\\'s memory. Lastly, a value of 0x00 signals that the nothing value will be returned for this field, even though, as a singleton type with a single type instance, it technically has a size of 0. The type tag byte for a type\\'s Union field is stored directly after the field\\'s computed Union memory.\"\n},\n\n{\n    \"location\": \"devdocs/isbitsunionarrays.html#isbits-Union-Arrays-1\",\n    \"page\": \"isbits Union Optimizations\",\n    \"title\": \"isbits Union Arrays\",\n    \"category\": \"section\",\n    \"text\": \"Julia can now also store \\\"isbits Union\\\" values inline in an Array, as opposed to requiring an indirection box. The optimization is accomplished by storing an extra \\\"type tag array\\\" of bytes, one byte per array element, alongside the bytes of the actual array data. This type tag array serves the same function as the type field case: it\\'s value signals the type of the actual stored Union value in the array. In terms of layout, a Julia Array can include extra \\\"buffer\\\" space before and after it\\'s actual data values, which are tracked in the a->offset and a->maxsize fields of the jl_array_t* type. The \\\"type tag array\\\" is treated exactly as another jl_array_t*, but which shares the same a->offset, a->maxsize, and a->len fields. So the formula to access an isbits Union Array\\'s type tag bytes is a->data + (a->maxsize - a->offset) * a->elsize + a->offset; i.e. the Array\\'s a->data pointer is already shifted by a->offset, so correcting for that, we follow the data all the way to the max of what it can hold a->maxsize, then adjust by a->ofset more bytes to account for any present \\\"front buffering\\\" the array might be doing. This layout in particular allows for very efficient resizing operations as the type tag data only ever has to move when the actual array\\'s data has to move.\"\n},\n\n{\n    \"location\": \"devdocs/sysimg.html#\",\n    \"page\": \"System Image Building\",\n    \"title\": \"System Image Building\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/sysimg.html#System-Image-Building-1\",\n    \"page\": \"System Image Building\",\n    \"title\": \"System Image Building\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/sysimg.html#Main.BuildSysImg.build_sysimg\",\n    \"page\": \"System Image Building\",\n    \"title\": \"Main.BuildSysImg.build_sysimg\",\n    \"category\": \"function\",\n    \"text\": \"build_sysimg(sysimg_path=default_sysimg_path(), cpu_target=\\\"native\\\", userimg_path=nothing; force=false)\\n\\nRebuild the system image. Store it in sysimg_path, which defaults to a file named sys.ji that sits in the same folder as libjulia.{so,dylib}, except on Windows where it defaults to Sys.BINDIR/../lib/julia/sys.ji.  Use the cpu instruction set given by cpu_target. Valid CPU targets are the same as for the -C option to julia, or the -march option to gcc.  Defaults to native, which means to use all CPU instructions available on the current processor. Include the user image file given by userimg_path, which should contain directives such as using MyPackage to include that package in the new system image. New system image will not replace an older image unless force is set to true.\\n\\n\\n\\n\\n\\n\"\n},\n\n{\n    \"location\": \"devdocs/sysimg.html#Building-the-Julia-system-image-1\",\n    \"page\": \"System Image Building\",\n    \"title\": \"Building the Julia system image\",\n    \"category\": \"section\",\n    \"text\": \"Julia ships with a preparsed system image containing the contents of the Base module, named sys.ji.  This file is also precompiled into a shared library called sys.{so,dll,dylib} on as many platforms as possible, so as to give vastly improved startup times.  On systems that do not ship with a precompiled system image file, one can be generated from the source files shipped in Julia\\'s DATAROOTDIR/julia/base folder.This operation is useful for multiple reasons.  A user may:Build a precompiled shared library system image on a platform that did not ship with one, thereby improving startup times.\\nModify Base, rebuild the system image and use the new Base next time Julia is started.\\nInclude a userimg.jl file that includes packages into the system image, thereby creating a system image that has packages embedded into the startup environment.Julia now ships with a script that automates the tasks of building the system image, wittingly named build_sysimg.jl that lives in DATAROOTDIR/julia/.  That is, to include it into a current Julia session, type:include(joinpath(Sys.BINDIR, Base.DATAROOTDIR, \\\"julia\\\", \\\"build_sysimg.jl\\\"))This will include a build_sysimg function:BuildSysImg.build_sysimgNote that this file can also be run as a script itself, with command line arguments taking the place of arguments passed to the build_sysimg function.  For example, to build a system image in /tmp/sys.{so,dll,dylib}, with the core2 CPU instruction set, a user image of ~/userimg.jl and force set to true, one would execute:julia build_sysimg.jl /tmp/sys core2 ~/userimg.jl --force\"\n},\n\n{\n    \"location\": \"devdocs/sysimg.html#System-image-optimized-for-multiple-microarchitectures-1\",\n    \"page\": \"System Image Building\",\n    \"title\": \"System image optimized for multiple microarchitectures\",\n    \"category\": \"section\",\n    \"text\": \"The system image can be compiled simultaneously for multiple CPU microarchitectures under the same instruction set architecture (ISA). Multiple versions of the same function may be created with minimum dispatch point inserted into shared functions in order to take advantage of different ISA extensions or other microarchitecture features. The version that offers the best performance will be selected automatically at runtime based on available features.\"\n},\n\n{\n    \"location\": \"devdocs/sysimg.html#Specifying-multiple-system-image-targets-1\",\n    \"page\": \"System Image Building\",\n    \"title\": \"Specifying multiple system image targets\",\n    \"category\": \"section\",\n    \"text\": \"Multi-microarch system image can be enabled by passing multiple targets during system image compilation. This can be done either with the JULIA_CPU_TARGET make option or with the -C command line option when running the compilation command manually. Multiple targets are separated by ; in the option. The syntax for each target is a CPU name followed by multiple features separated by ,. All features supported by LLVM is supported and a feature can be disabled with a - prefix. (+ prefix is also allowed and ignored to be consistent with LLVM syntax). Additionally, a few special features are supported to control the function cloning behavior.clone_all\\nBy default, only functions that are the most likely to benefit from  the microarchitecture features will be cloned.  When clone_all is specified for a target, however,  all functions in the system image will be cloned for the target.  The negative form -clone_all can be used to prevent the built-in  heuristic from cloning all functions.\\nbase(<n>)\\nWhere <n> is a placeholder for a non-negative number (e.g. base(0), base(1)).  By default, a partially cloned (i.e. not clone_all) target will use functions  from the default target (first one specified) if a function is not cloned.  This behavior can be changed by specifying a different base with the base(<n>) option.  The nth target (0-based) will be used as the base target instead of the default (0th) one.  The base target has to be either 0 or another clone_all target.  Specifying a non default clone_all target as the base target will cause an error.\\nopt_size\\nThis cause the function for the targe to be optimize for size when there isn\\'t a significant  runtime performance impact. This corresponds to -Os GCC and Clang option.\\nmin_size\\nThis cause the function for the targe to be optimize for size that might have  a significant runtime performance impact. This corresponds to -Oz Clang option.\"\n},\n\n{\n    \"location\": \"devdocs/sysimg.html#Implementation-overview-1\",\n    \"page\": \"System Image Building\",\n    \"title\": \"Implementation overview\",\n    \"category\": \"section\",\n    \"text\": \"This is a brief overview of different part involved in the implementation. See code comments for each components for more implementation details.System image compilation\\nThe parsing and cloning decision are done in src/processor*.  We currently support cloning of function based on the present of loops, simd instructions,  or other math operations (e.g. fastmath, fma, muladd).  This information is passed on to src/llvm-multiversioning.cpp which does the actual cloning.  In addition to doing the cloning and insert dispatch slots  (see comments in MultiVersioning::runOnModule for how this is done),  the pass also generates metadata so that the runtime can load and initialize the  system image correctly.  A detail description of the metadata is available in src/processor.h.\\nSystem image loading\\nThe loading and initialization of the system image is done in src/processor* by  parsing the metadata saved during system image generation.  Host feature detection and selection decision are done in src/processor_*.cpp  depending on the ISA. The target selection will prefer exact CPU name match,  larger vector register size, and larget number of features.  An overview of this process is in src/processor.cpp.\"\n},\n\n{\n    \"location\": \"devdocs/llvm.html#\",\n    \"page\": \"Working with LLVM\",\n    \"title\": \"Working with LLVM\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/llvm.html#Working-with-LLVM-1\",\n    \"page\": \"Working with LLVM\",\n    \"title\": \"Working with LLVM\",\n    \"category\": \"section\",\n    \"text\": \"This is not a replacement for the LLVM documentation, but a collection of tips for working on LLVM for Julia.\"\n},\n\n{\n    \"location\": \"devdocs/llvm.html#Overview-of-Julia-to-LLVM-Interface-1\",\n    \"page\": \"Working with LLVM\",\n    \"title\": \"Overview of Julia to LLVM Interface\",\n    \"category\": \"section\",\n    \"text\": \"Julia dynamically links against LLVM by default. Build with USE_LLVM_SHLIB=0 to link statically.The code for lowering Julia AST to LLVM IR or interpreting it directly is in directory src/.File Description\\nbuiltins.c Builtin functions\\nccall.cpp Lowering ccall\\ncgutils.cpp Lowering utilities, notably for array and tuple accesses\\ncodegen.cpp Top-level of code generation, pass list, lowering builtins\\ndebuginfo.cpp Tracks debug information for JIT code\\ndisasm.cpp Handles native object file and JIT code diassembly\\ngf.c Generic functions\\nintrinsics.cpp Lowering intrinsics\\nllvm-simdloop.cpp Custom LLVM pass for @simd\\nsys.c I/O and operating system utility functionsSome of the .cpp files form a group that compile to a single object.The difference between an intrinsic and a builtin is that a builtin is a first class function that can be used like any other Julia function.  An intrinsic can operate only on unboxed data, and therefore its arguments must be statically typed.\"\n},\n\n{\n    \"location\": \"devdocs/llvm.html#Alias-Analysis-1\",\n    \"page\": \"Working with LLVM\",\n    \"title\": \"Alias Analysis\",\n    \"category\": \"section\",\n    \"text\": \"Julia currently uses LLVM\\'s Type Based Alias Analysis. To find the comments that document the inclusion relationships, look for static MDNode* in src/codegen.cpp.The -O option enables LLVM\\'s Basic Alias Analysis.\"\n},\n\n{\n    \"location\": \"devdocs/llvm.html#Building-Julia-with-a-different-version-of-LLVM-1\",\n    \"page\": \"Working with LLVM\",\n    \"title\": \"Building Julia with a different version of LLVM\",\n    \"category\": \"section\",\n    \"text\": \"The default version of LLVM is specified in deps/Versions.make. You can override it by creating a file called Make.user in the top-level directory and adding a line to it such as:LLVM_VER = 3.5.0Besides the LLVM release numerals, you can also use LLVM_VER = svn to build against the latest development version of LLVM.You can also specify to build a debug version of LLVM, by setting either LLVM_DEBUG = 1 or LLVM_DEBUG = Release in your Make.user file. The former will be a fully unoptimized build of LLVM and the latter will produce an optimized build of LLVM. Depending on your needs the latter will suffice and it quite a bit faster. If you use LLVM_DEBUG = Release you will also want to set LLVM_ASSERTIONS = 1 to enable diagonstics for different passes. Only LLVM_DEBUG = 1 implies that option by default.\"\n},\n\n{\n    \"location\": \"devdocs/llvm.html#Passing-options-to-LLVM-1\",\n    \"page\": \"Working with LLVM\",\n    \"title\": \"Passing options to LLVM\",\n    \"category\": \"section\",\n    \"text\": \"You can pass options to LLVM via the environment variable JULIA_LLVM_ARGS. Here are example settings using bash syntax:export JULIA_LLVM_ARGS = -print-after-all dumps IR after each pass.\\nexport JULIA_LLVM_ARGS = -debug-only=loop-vectorize dumps LLVM DEBUG(...) diagnostics for loop vectorizer. If you get warnings about \\\"Unknown command line argument\\\", rebuild LLVM with LLVM_ASSERTIONS = 1.\"\n},\n\n{\n    \"location\": \"devdocs/llvm.html#Debugging-LLVM-transformations-in-isolation-1\",\n    \"page\": \"Working with LLVM\",\n    \"title\": \"Debugging LLVM transformations in isolation\",\n    \"category\": \"section\",\n    \"text\": \"On occasion, it can be useful to debug LLVM\\'s transformations in isolation from the rest of the Julia system, e.g. because reproducing the issue inside julia would take too long, or because one wants to take advantage of LLVM\\'s tooling (e.g. bugpoint). To get unoptimized IR for the entire system image, pass the --output-unopt-bc unopt.bc option to the system image build process, which will output the unoptimized IR to an unopt.bc file. This file can then be passed to LLVM tools as usual. libjulia can function as an LLVM pass plugin and can be loaded into LLVM tools, to make julia-specific passes available in this environment. In addition, it exposes the -julia meta-pass, which runs the entire Julia pass-pipeline over the IR. As an example, to generate a system image, one could do:opt -load libjulia.so -julia -o opt.bc unopt.bc\\nllc -o sys.o opt.bc\\ncc -shared -o sys.so sys.oThis system image can then be loaded by julia as usual.Alternatively, you can use --output-jit-bc jit.bc to obtain a trace of all IR passed to the JIT. This is useful for code that cannot be run as part of the sysimg generation process (e.g. because it creates unserializable state). However, the resulting jit.bc does not include sysimage data, and can thus not be used as such.It is also possible to dump an LLVM IR module for just one Julia function, using:f, T = +, Tuple{Int,Int} # Substitute your function of interest here\\noptimize = false\\nopen(\\\"plus.ll\\\", \\\"w\\\") do f\\n    println(f, Base._dump_function(f, T, false, false, false, true, :att, optimize))\\nendThese files can be processed the same way as the unoptimized sysimg IR shown above.\"\n},\n\n{\n    \"location\": \"devdocs/llvm.html#Improving-LLVM-optimizations-for-Julia-1\",\n    \"page\": \"Working with LLVM\",\n    \"title\": \"Improving LLVM optimizations for Julia\",\n    \"category\": \"section\",\n    \"text\": \"Improving LLVM code generation usually involves either changing Julia lowering to be more friendly to LLVM\\'s passes, or improving a pass.If you are planning to improve a pass, be sure to read the LLVM developer policy. The best strategy is to create a code example in a form where you can use LLVM\\'s opt tool to study it and the pass of interest in isolation.Create an example Julia code of interest.\\nUse JULIA_LLVM_ARGS = -print-after-all to dump the IR.\\nPick out the IR at the point just before the pass of interest runs.\\nStrip the debug metadata and fix up the TBAA metadata by hand.The last step is labor intensive.  Suggestions on a better way would be appreciated.\"\n},\n\n{\n    \"location\": \"devdocs/llvm.html#The-jlcall-calling-convention-1\",\n    \"page\": \"Working with LLVM\",\n    \"title\": \"The jlcall calling convention\",\n    \"category\": \"section\",\n    \"text\": \"Julia has a generic calling convention for unoptimized code, which looks somewhat as follows:jl_value_t *any_unoptimized_call(jl_value_t *, jl_value_t **, int);where the first argument is the boxed function object, the second argument is an on-stack array of arguments and the third is the number of arguments. Now, we could perform a straightforward lowering and emit an alloca for the argument array. However, this would betray the SSA nature of the uses at the call site, making optimizations (including GC root placement), significantly harder. Instead, we emit it as follows:%bitcast = bitcast @any_unoptimized_call to %jl_value_t *(*)(%jl_value_t *, %jl_value_t *)\\ncall cc 37 %jl_value_t *%bitcast(%jl_value_t *%arg1, %jl_value_t *%arg2)The special cc 37 annotation marks the fact that this call site is really using the jlcall calling convention. This allows us to retain the SSA-ness of the uses throughout the optimizer. GC root placement will later lower this call to the original C ABI. In the code the calling convention number is represented by the JLCALL_F_CC constant. In addition, there is the JLCALL_CC calling convention which functions similarly, but omits the first argument.\"\n},\n\n{\n    \"location\": \"devdocs/llvm.html#GC-root-placement-1\",\n    \"page\": \"Working with LLVM\",\n    \"title\": \"GC root placement\",\n    \"category\": \"section\",\n    \"text\": \"GC root placement is done by an LLVM pass late in the pass pipeline. Doing GC root placement this late enables LLVM to make more aggressive optimizations around code that requires GC roots, as well as allowing us to reduce the number of required GC roots and GC root store operations (since LLVM doesn\\'t understand our GC, it wouldn\\'t otherwise know what it is and is not allowed to do with values stored to the GC frame, so it\\'ll conservatively do very little). As an example, consider an error pathif some_condition()\\n    #= Use some variables maybe =#\\n    error(\\\"An error occurred\\\")\\nendDuring constant folding, LLVM may discover that the condition is always false, and can remove the basic block. However, if GC root lowering is done early, the GC root slots used in the deleted block, as well as any values kept alive in those slots only because they were used in the error path, would be kept alive by LLVM. By doing GC root lowering late, we give LLVM the license to do any of its usual optimizations (constant folding, dead code elimination, etc.), without having to worry (too much) about which values may or may not be GC tracked.However, in order to be able to do late GC root placement, we need to be able to identify a) which pointers are GC tracked and b) all uses of such pointers. The goal of the GC placement pass is thus simple:Minimize the number of needed GC roots/stores to them subject to the constraint that at every safepoint, any live GC-tracked pointer (i.e. for which there is a path after this point that contains a use of this pointer) is in some GC slot.\"\n},\n\n{\n    \"location\": \"devdocs/llvm.html#Representation-1\",\n    \"page\": \"Working with LLVM\",\n    \"title\": \"Representation\",\n    \"category\": \"section\",\n    \"text\": \"The primary difficulty is thus choosing an IR representation that allows us to identify GC-tracked pointers and their uses, even after the program has been run through the optimizer. Our design makes use of three LLVM features to achieve this:Custom address spaces\\nOperand Bundles\\nNon-integral pointersCustom address spaces allow us to tag every point with an integer that needs to be preserved through optimizations. The compiler may not insert casts between address spaces that did not exist in the original program and it must never change the address space of a pointer on a load/store/etc operation. This allows us to annotate which pointers are GC-tracked in an optimizer-resistant way. Note that metadata would not be able to achieve the same purpose. Metadata is supposed to always be discardable without altering the semantics of the program. However, failing to identify a GC-tracked pointer alters the resulting program behavior dramatically - it\\'ll probably crash or return wrong results. We currently use three different address spaces (their numbers are defined in src/codegen_shared.cpp):GC Tracked Pointers (currently 10): These are pointers to boxed values that may be put into a GC frame. It is loosely equivalent to a jl_value_t* pointer on the C side. N.B. It is illegal to ever have a pointer in this address space that may not be stored to a GC slot.\\nDerived Pointers (currently 11): These are pointers that are derived from some GC tracked pointer. Uses of these pointers generate uses of the original pointer. However, they need not themselves be known to the GC. The GC root placement pass MUST always find the GC tracked pointer from which this pointer is derived and use that as the pointer to root.\\nCallee Rooted Pointers (currently 12): This is a utility address space to express the notion of a callee rooted value. All values of this address space MUST be storable to a GC root (though it is possible to relax this condition in the future), but unlike the other pointers need not be rooted if passed to a call (they do still need to be rooted if they are live across another safepoint between the definition and the call).\\nPointers loaded from tracked object (currently 13): This is used by arrays, which themselves contain a pointer to the managed data. This data area is owned by the array, but is not a GC-tracked object by itself. The compiler guarantees that as long as this pointer is live, the object that this pointer was loaded from will keep being live.\"\n},\n\n{\n    \"location\": \"devdocs/llvm.html#Invariants-1\",\n    \"page\": \"Working with LLVM\",\n    \"title\": \"Invariants\",\n    \"category\": \"section\",\n    \"text\": \"The GC root placement pass makes use of several invariants, which need to be observed by the frontend and are preserved by the optimizer.First, only the following address space casts are allowed:0->{Tracked,Derived,CalleeRooted}: It is allowable to decay an untracked pointer to any of the others. However, do note that the optimizer has broad license to not root such a value. It is never safe to have a value in address space 0 in any part of the program if it is (or is derived from) a value that requires a GC root.\\nTracked->Derived: This is the standard decay route for interior values. The placement pass will look for these to identify the base pointer for any use.\\nTracked->CalleeRooted: Addrspace CalleeRooted serves merely as a hint that a GC root is not required. However, do note that the Derived->CalleeRooted decay is prohibited, since pointers should generally be storable to a GC slot, even in this address space.Now let us consider what constitutes a use:Loads whose loaded values is in one of the address spaces\\nStores of a value in one of the address spaces to a location\\nStores to a pointer in one of the address spaces\\nCalls for which a value in one of the address spaces is an operand\\nCalls in jlcall ABI, for which the argument array contains a value\\nReturn instructions.We explicitly allow load/stores and simple calls in address spaces Tracked/Derived. Elements of jlcall argument arrays must always be in address space Tracked (it is required by the ABI that they are valid jl_value_t* pointers). The same is true for return instructions (though note that struct return arguments are allowed to have any of the address spaces). The only allowable use of an address space CalleeRooted pointer is to pass it to a call (which must have an appropriately typed operand).Further, we disallow getelementptr in addrspace Tracked. This is because unless the operation is a noop, the resulting pointer will not be validly storable to a GC slot and may thus not be in this address space. If such a pointer is required, it should be decayed to addrspace Derived first.Lastly, we disallow inttoptr/ptrtoint instructions in these address spaces. Having these instructions would mean that some i64 values are really GC tracked. This is problematic, because it breaks that stated requirement that we\\'re able to identify GC-relevant pointers. This invariant is accomplished using the LLVM \\\"non-integral pointers\\\" feature, which is new in LLVM 5.0. It prohibits the optimizer from making optimizations that would introduce these operations. Note we can still insert static constants at JIT time by using inttoptr in address space 0 and then decaying to the appropriate address space afterwards.\"\n},\n\n{\n    \"location\": \"devdocs/llvm.html#Supporting-[ccall](@ref)-1\",\n    \"page\": \"Working with LLVM\",\n    \"title\": \"Supporting ccall\",\n    \"category\": \"section\",\n    \"text\": \"One important aspect missing from the discussion so far is the handling of ccall. ccall has the peculiar feature that the location and scope of a use do not coincide. As an example consider:A = randn(1024)\\nccall(:foo, Cvoid, (Ptr{Float64},), A)In lowering, the compiler will insert a conversion from the array to the pointer which drops the reference to the array value. However, we of course need to make sure that the array does stay alive while we\\'re doing the ccall. To understand how this is done, first recall the lowering of the above code:return $(Expr(:foreigncall, :(:foo), Cvoid, svec(Ptr{Float64}), :(:ccall), 1, :($(Expr(:foreigncall, :(:jl_array_ptr), Ptr{Float64}, svec(Any), :(:ccall), 1, :(A)))), :(A)))The last :(A), is an extra argument list inserted during lowering that informs the code generator which Julia level values need to be kept alive for the duration of this ccall. We then take this information and represent it in an \\\"operand bundle\\\" at the IR level. An operand bundle is essentially a fake use that is attached to the call site. At the IR level, this looks like so:call void inttoptr (i64 ... to void (double*)*)(double* %5) [ \\\"jl_roots\\\"(%jl_value_t addrspace(10)* %A) ]The GC root placement pass will treat the jl_roots operand bundle as if it were a regular operand. However, as a final step, after the GC roots are inserted, it will drop the operand bundle to avoid confusing instruction selection.\"\n},\n\n{\n    \"location\": \"devdocs/llvm.html#Supporting-[pointer_from_objref](@ref)-1\",\n    \"page\": \"Working with LLVM\",\n    \"title\": \"Supporting pointer_from_objref\",\n    \"category\": \"section\",\n    \"text\": \"pointer_from_objref is special because it requires the user to take explicit control of GC rooting. By our above invariants, this function is illegal, because it performs an address space cast from 10 to 0. However, it can be useful, in certain situations, so we provide a special intrinsic:declared %jl_value_t *julia.pointer_from_objref(%jl_value_t addrspace(10)*)which is lowered to the corresponding address space cast after GC root lowering. Do note however that by using this intrinsic, the caller assumes all responsibility for making sure that the value in question is rooted. Further this intrinsic is not considered a use, so the GC root placement pass will not provide a GC root for the function. As a result, the external rooting must be arranged while the value is still tracked by the system. I.e. it is not valid to attempt to use the result of this operation to establish a global root - the optimizer may have already dropped the value.\"\n},\n\n{\n    \"location\": \"devdocs/llvm.html#Keeping-values-alive-in-the-absence-of-uses-1\",\n    \"page\": \"Working with LLVM\",\n    \"title\": \"Keeping values alive in the absence of uses\",\n    \"category\": \"section\",\n    \"text\": \"In certain cases it is necessary to keep an object alive, even though there is no compiler-visible use of said object. This may be case for low level code that operates on the memory-representation of an object directly or code that needs to interface with C code. In order to allow this, we provide the following intrinsics at the LLVM level:token @llvm.julia.gc_preserve_begin(...)\\nvoid @llvm.julia.gc_preserve_end(token)(The llvm. in the name is required in order to be able to use the token type). The semantics of these intrinsics are as follows: At any safepoint that is dominated by a gc_preserve_begin call, but that is not not dominated by a corresponding gc_preserve_end call (i.e. a call whose argument is the token returned by a gc_preserve_begin call), the values passed as arguments to that gc_preserve_begin will be kept live. Note that the gc_preserve_begin still counts as a regular use of those values, so the standard lifetime semantics will ensure that the values will be kept alive before entering the preserve region.\"\n},\n\n{\n    \"location\": \"devdocs/stdio.html#\",\n    \"page\": \"printf() and stdio in the Julia runtime\",\n    \"title\": \"printf() and stdio in the Julia runtime\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/stdio.html#printf()-and-stdio-in-the-Julia-runtime-1\",\n    \"page\": \"printf() and stdio in the Julia runtime\",\n    \"title\": \"printf() and stdio in the Julia runtime\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/stdio.html#Libuv-wrappers-for-stdio-1\",\n    \"page\": \"printf() and stdio in the Julia runtime\",\n    \"title\": \"Libuv wrappers for stdio\",\n    \"category\": \"section\",\n    \"text\": \"julia.h defines libuv wrappers for the stdio.h streams:uv_stream_t *JL_STDIN;\\nuv_stream_t *JL_STDOUT;\\nuv_stream_t *JL_STDERR;... and corresponding output functions:int jl_printf(uv_stream_t *s, const char *format, ...);\\nint jl_vprintf(uv_stream_t *s, const char *format, va_list args);These printf functions are used by the .c files in the src/ and ui/ directories wherever stdio is needed to ensure that output buffering is handled in a unified way.In special cases, like signal handlers, where the full libuv infrastructure is too heavy, jl_safe_printf() can be used to write(2) directly to STDERR_FILENO:void jl_safe_printf(const char *str, ...);\"\n},\n\n{\n    \"location\": \"devdocs/stdio.html#Interface-between-JL_STD*-and-Julia-code-1\",\n    \"page\": \"printf() and stdio in the Julia runtime\",\n    \"title\": \"Interface between JL_STD* and Julia code\",\n    \"category\": \"section\",\n    \"text\": \"Base.stdin, Base.stdout and Base.stderr are bound to the JL_STD* libuv streams defined in the runtime.Julia\\'s __init__() function (in base/sysimg.jl) calls reinit_stdio() (in base/stream.jl) to create Julia objects for Base.stdin, Base.stdout and Base.stderr.reinit_stdio() uses ccall to retrieve pointers to JL_STD* and calls jl_uv_handle_type() to inspect the type of each stream.  It then creates a Julia Base.IOStream, Base.TTY or Base.PipeEndpoint object to represent each stream, e.g.:$ julia -e \\'println(typeof((stdin, stdout, stderr)))\\'\\nTuple{Base.TTY,Base.TTY,Base.TTY}\\n\\n$ julia -e \\'println(typeof((stdin, stdout, stderr)))\\' < /dev/null 2>/dev/null\\nTuple{IOStream,Base.TTY,IOStream}\\n\\n$ echo hello | julia -e \\'println(typeof((stdin, stdout, stderr)))\\' | cat\\nTuple{Base.PipeEndpoint,Base.PipeEndpoint,Base.TTY}The Base.read and Base.write methods for these streams use ccall to call libuv wrappers in src/jl_uv.c, e.g.:stream.jl: function write(s::IO, p::Ptr, nb::Integer)\\n               -> ccall(:jl_uv_write, ...)\\n  jl_uv.c:          -> int jl_uv_write(uv_stream_t *stream, ...)\\n                        -> uv_write(uvw, stream, buf, ...)\"\n},\n\n{\n    \"location\": \"devdocs/stdio.html#printf()-during-initialization-1\",\n    \"page\": \"printf() and stdio in the Julia runtime\",\n    \"title\": \"printf() during initialization\",\n    \"category\": \"section\",\n    \"text\": \"The libuv streams relied upon by jl_printf() etc., are not available until midway through initialization of the runtime (see init.c, init_stdio()).  Error messages or warnings that need to be printed before this are routed to the standard C library fwrite() function by the following mechanism:In sys.c, the JL_STD* stream pointers are statically initialized to integer constants: STD*_FILENO (0, 1 and 2). In jl_uv.c the jl_uv_puts() function checks its uv_stream_t* stream argument and calls fwrite() if stream is set to STDOUT_FILENO or STDERR_FILENO.This allows for uniform use of jl_printf() throughout the runtime regardless of whether or not any particular piece of code is reachable before initialization is complete.\"\n},\n\n{\n    \"location\": \"devdocs/stdio.html#Legacy-ios.c-library-1\",\n    \"page\": \"printf() and stdio in the Julia runtime\",\n    \"title\": \"Legacy ios.c library\",\n    \"category\": \"section\",\n    \"text\": \"The src/support/ios.c library is inherited from femtolisp. It provides cross-platform buffered file IO and in-memory temporary buffers.ios.c is still used by:src/flisp/*.c\\nsrc/dump.c \u2013 for serialization file IO and for memory buffers.\\nsrc/staticdata.c \u2013 for serialization file IO and for memory buffers.\\nbase/iostream.jl \u2013 for file IO (see base/fs.jl for libuv equivalent).Use of ios.c in these modules is mostly self-contained and separated from the libuv I/O system. However, there is one place where femtolisp calls through to jl_printf() with a legacy ios_t stream.There is a hack in ios.h that makes the ios_t.bm field line up with the uv_stream_t.type and ensures that the values used for ios_t.bm to not overlap with valid UV_HANDLE_TYPE values.  This allows uv_stream_t pointers to point to ios_t streams.This is needed because jl_printf() caller jl_static_show() is passed an ios_t stream by femtolisp\\'s fl_print() function. Julia\\'s jl_uv_puts() function has special handling for this:if (stream->type > UV_HANDLE_TYPE_MAX) {\\n    return ios_write((ios_t*)stream, str, n);\\n}\"\n},\n\n{\n    \"location\": \"devdocs/boundscheck.html#\",\n    \"page\": \"Bounds checking\",\n    \"title\": \"Bounds checking\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/boundscheck.html#Bounds-checking-1\",\n    \"page\": \"Bounds checking\",\n    \"title\": \"Bounds checking\",\n    \"category\": \"section\",\n    \"text\": \"Like many modern programming languages, Julia uses bounds checking to ensure program safety when accessing arrays. In tight inner loops or other performance critical situations, you may wish to skip these bounds checks to improve runtime performance. For instance, in order to emit vectorized (SIMD) instructions, your loop body cannot contain branches, and thus cannot contain bounds checks. Consequently, Julia includes an @inbounds(...) macro to tell the compiler to skip such bounds checks within the given block. User-defined array types can use the @boundscheck(...) macro to achieve context-sensitive code selection.\"\n},\n\n{\n    \"location\": \"devdocs/boundscheck.html#Eliding-bounds-checks-1\",\n    \"page\": \"Bounds checking\",\n    \"title\": \"Eliding bounds checks\",\n    \"category\": \"section\",\n    \"text\": \"The @boundscheck(...) macro marks blocks of code that perform bounds checking. When such blocks are inlined into an @inbounds(...) block, the compiler may remove these blocks. The compiler removes the @boundscheck block only if it is inlined into the calling function. For example, you might write the method sum as:function sum(A::AbstractArray)\\n    r = zero(eltype(A))\\n    for i = 1:length(A)\\n        @inbounds r += A[i]\\n    end\\n    return r\\nendWith a custom array-like type MyArray having:@inline getindex(A::MyArray, i::Real) = (@boundscheck checkbounds(A,i); A.data[to_index(i)])Then when getindex is inlined into sum, the call to checkbounds(A,i) will be elided. If your function contains multiple layers of inlining, only @boundscheck blocks at most one level of inlining deeper are eliminated. The rule prevents unintended changes in program behavior from code further up the stack.\"\n},\n\n{\n    \"location\": \"devdocs/boundscheck.html#Propagating-inbounds-1\",\n    \"page\": \"Bounds checking\",\n    \"title\": \"Propagating inbounds\",\n    \"category\": \"section\",\n    \"text\": \"There may be certain scenarios where for code-organization reasons you want more than one layer between the @inbounds and @boundscheck declarations. For instance, the default getindex methods have the chain getindex(A::AbstractArray, i::Real) calls getindex(IndexStyle(A), A, i) calls _getindex(::IndexLinear, A, i).To override the \\\"one layer of inlining\\\" rule, a function may be marked with @propagate_inbounds to propagate an inbounds context (or out of bounds context) through one additional layer of inlining.\"\n},\n\n{\n    \"location\": \"devdocs/boundscheck.html#The-bounds-checking-call-hierarchy-1\",\n    \"page\": \"Bounds checking\",\n    \"title\": \"The bounds checking call hierarchy\",\n    \"category\": \"section\",\n    \"text\": \"The overall hierarchy is:checkbounds(A, I...) which calls\\ncheckbounds(Bool, A, I...) which calls\\ncheckbounds_indices(Bool, axes(A), I) which recursively calls\\ncheckindex for each dimensionHere A is the array, and I contains the \\\"requested\\\" indices. axes(A) returns a tuple of \\\"permitted\\\" indices of A.checkbounds(A, I...) throws an error if the indices are invalid, whereas checkbounds(Bool, A, I...) returns false in that circumstance.  checkbounds_indices discards any information about the array other than its axes tuple, and performs a pure indices-vs-indices comparison: this allows relatively few compiled methods to serve a huge variety of array types. Indices are specified as tuples, and are usually compared in a 1-1 fashion with individual dimensions handled by calling another important function, checkindex: typically,checkbounds_indices(Bool, (IA1, IA...), (I1, I...)) = checkindex(Bool, IA1, I1) &\\n                                                      checkbounds_indices(Bool, IA, I)so checkindex checks a single dimension.  All of these functions, including the unexported checkbounds_indices have docstrings accessible with ? .If you have to customize bounds checking for a specific array type, you should specialize checkbounds(Bool, A, I...). However, in most cases you should be able to rely on checkbounds_indices as long as you supply useful axes for your array type.If you have novel index types, first consider specializing checkindex, which handles a single index for a particular dimension of an array.  If you have a custom multidimensional index type (similar to CartesianIndex), then you may have to consider specializing checkbounds_indices.Note this hierarchy has been designed to reduce the likelihood of method ambiguities.  We try to make checkbounds the place to specialize on array type, and try to avoid specializations on index types; conversely, checkindex is intended to be specialized only on index type (especially, the last argument).\"\n},\n\n{\n    \"location\": \"devdocs/locks.html#\",\n    \"page\": \"Proper maintenance and care of multi-threading locks\",\n    \"title\": \"Proper maintenance and care of multi-threading locks\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/locks.html#Proper-maintenance-and-care-of-multi-threading-locks-1\",\n    \"page\": \"Proper maintenance and care of multi-threading locks\",\n    \"title\": \"Proper maintenance and care of multi-threading locks\",\n    \"category\": \"section\",\n    \"text\": \"The following strategies are used to ensure that the code is dead-lock free (generally by addressing the 4th Coffman condition: circular wait).structure code such that only one lock will need to be acquired at a time\\nalways acquire shared locks in the same order, as given by the table below\\navoid constructs that expect to need unrestricted recursion\"\n},\n\n{\n    \"location\": \"devdocs/locks.html#Locks-1\",\n    \"page\": \"Proper maintenance and care of multi-threading locks\",\n    \"title\": \"Locks\",\n    \"category\": \"section\",\n    \"text\": \"Below are all of the locks that exist in the system and the mechanisms for using them that avoid the potential for deadlocks (no Ostrich algorithm allowed here):The following are definitely leaf locks (level 1), and must not try to acquire any other lock:safepoint\\nNote that this lock is acquired implicitly by JL_LOCK and JL_UNLOCK. use the _NOGC variants to avoid that for level 1 locks.While holding this lock, the code must not do any allocation or hit any safepoints. Note that there are safepoints when doing allocation, enabling / disabling GC, entering / restoring exception frames, and taking / releasing locks.\\nshared_map\\nfinalizers\\npagealloc\\ngcpermlock\\nflisp\\nflisp itself is already threadsafe, this lock only protects the jl_ast_context_list_t poolThe following is a leaf lock (level 2), and only acquires level 1 locks (safepoint) internally:typecacheThe following is a level 3 lock, which can only acquire level 1 or level 2 locks internally:Method->writelockThe following is a level 4 lock, which can only recurse to acquire level 1, 2, or 3 locks:MethodTable->writelockNo Julia code may be called while holding a lock above this point.The following is a level 6 lock, which can only recurse to acquire locks at lower levels:codegenThe following is an almost root lock (level end-1), meaning only the root look may be held when trying to acquire it:typeinf\\nthis one is perhaps one of the most tricky ones, since type-inference can be invoked from many pointscurrently the lock is merged with the codegen lock, since they call each other recursivelyThe following is the root lock, meaning no other lock shall be held when trying to acquire it:toplevel\\nthis should be held while attempting a top-level action (such as making a new type or defining a new method): trying to obtain this lock inside a staged function will cause a deadlock condition!additionally, it\\'s unclear if any code can safely run in parallel with an arbitrary toplevel expression, so it may require all threads to get to a safepoint first\"\n},\n\n{\n    \"location\": \"devdocs/locks.html#Broken-Locks-1\",\n    \"page\": \"Proper maintenance and care of multi-threading locks\",\n    \"title\": \"Broken Locks\",\n    \"category\": \"section\",\n    \"text\": \"The following locks are broken:toplevel\\ndoesn\\'t exist right nowfix: create it\"\n},\n\n{\n    \"location\": \"devdocs/locks.html#Shared-Global-Data-Structures-1\",\n    \"page\": \"Proper maintenance and care of multi-threading locks\",\n    \"title\": \"Shared Global Data Structures\",\n    \"category\": \"section\",\n    \"text\": \"These data structures each need locks due to being shared mutable global state. It is the inverse list for the above lock priority list. This list does not include level 1 leaf resources due to their simplicity.MethodTable modifications (def, cache, kwsorter type) : MethodTable->writelockType declarations : toplevel lockType application : typecache lockModule serializer : toplevel lockJIT & type-inference : codegen lockMethodInstance updates : codegen lockThese fields are generally lazy initialized, using the test-and-test-and-set pattern.\\nThese are set at construction and immutable:\\nspecTypes\\nsparam_vals\\ndef\\nThese are set by jl_type_infer (while holding codegen lock):\\nrettype\\ninferred\\nthese can also be reset, see jl_set_lambda_rettype for that logic as it needs to keep functionObjectsDecls in sync\\ninInference flag:\\noptimization to quickly avoid recurring into jl_type_infer while it is already running\\nactual state (of setting inferred, then fptr) is protected by codegen lock\\nFunction pointers (jlcall_api and fptr, unspecialized_ducttape):\\nthese transition once, from NULL to a value, while the codegen lock is held\\nCode-generator cache (the contents of functionObjectsDecls):\\nthese can transition multiple times, but only while the codegen lock is held\\nit is valid to use old version of this, or block for new versions of this, so races are benign, as long as the code is careful not to reference other data in the method instance (such as rettype) and assume it is coordinated, unless also holding the codegen lock\\ncompile_traced flag:\\nunknownLLVMContext : codegen lockMethod : Method->writelockroots array (serializer and codegen)\\ninvoke / specializations / tfunc modifications\"\n},\n\n{\n    \"location\": \"devdocs/offset-arrays.html#\",\n    \"page\": \"Arrays with custom indices\",\n    \"title\": \"Arrays with custom indices\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/offset-arrays.html#man-custom-indices-1\",\n    \"page\": \"Arrays with custom indices\",\n    \"title\": \"Arrays with custom indices\",\n    \"category\": \"section\",\n    \"text\": \"Conventionally, Julia\\'s arrays are indexed starting at 1, whereas some other languages start numbering at 0, and yet others (e.g., Fortran) allow you to specify arbitrary starting indices.  While there is much merit in picking a standard (i.e., 1 for Julia), there are some algorithms which simplify considerably if you can index outside the range 1:size(A,d) (and not just 0:size(A,d)-1, either). To facilitate such computations, Julia supports arrays with arbitrary indices.The purpose of this page is to address the question, \\\"what do I have to do to support such arrays in my own code?\\\"  First, let\\'s address the simplest case: if you know that your code will never need to handle arrays with unconventional indexing, hopefully the answer is \\\"nothing.\\\" Old code, on conventional arrays, should function essentially without alteration as long as it was using the exported interfaces of Julia. If you find it more convenient to just force your users to supply traditional arrays where indexing starts at one, you can add@assert !Base.has_offset_axes(arrays...)where arrays... is a list of the array objects that you wish to check for anything that violates 1-based indexing.\"\n},\n\n{\n    \"location\": \"devdocs/offset-arrays.html#Generalizing-existing-code-1\",\n    \"page\": \"Arrays with custom indices\",\n    \"title\": \"Generalizing existing code\",\n    \"category\": \"section\",\n    \"text\": \"As an overview, the steps are:replace many uses of size with axes\\nreplace 1:length(A) with eachindex(A), or in some cases LinearIndices(A)\\nreplace explicit allocations like Array{Int}(size(B)) with similar(Array{Int}, axes(B))These are described in more detail below.\"\n},\n\n{\n    \"location\": \"devdocs/offset-arrays.html#Things-to-watch-out-for-1\",\n    \"page\": \"Arrays with custom indices\",\n    \"title\": \"Things to watch out for\",\n    \"category\": \"section\",\n    \"text\": \"Because unconventional indexing breaks many people\\'s assumptions that all arrays start indexing with 1, there is always the chance that using such arrays will trigger errors. The most frustrating bugs would be incorrect results or segfaults (total crashes of Julia). For example, consider the following function:function mycopy!(dest::AbstractVector, src::AbstractVector)\\n    length(dest) == length(src) || throw(DimensionMismatch(\\\"vectors must match\\\"))\\n    # OK, now we\\'re safe to use @inbounds, right? (not anymore!)\\n    for i = 1:length(src)\\n        @inbounds dest[i] = src[i]\\n    end\\n    dest\\nendThis code implicitly assumes that vectors are indexed from 1; if dest starts at a different index than src, there is a chance that this code would trigger a segfault. (If you do get segfaults, to help locate the cause try running julia with the option --check-bounds=yes.)\"\n},\n\n{\n    \"location\": \"devdocs/offset-arrays.html#Using-axes-for-bounds-checks-and-loop-iteration-1\",\n    \"page\": \"Arrays with custom indices\",\n    \"title\": \"Using axes for bounds checks and loop iteration\",\n    \"category\": \"section\",\n    \"text\": \"axes(A) (reminiscent of size(A)) returns a tuple of AbstractUnitRange objects, specifying the range of valid indices along each dimension of A.  When A has unconventional indexing, the ranges may not start at 1.  If you just want the range for a particular dimension d, there is axes(A, d).Base implements a custom range type, OneTo, where OneTo(n) means the same thing as 1:n but in a form that guarantees (via the type system) that the lower index is 1. For any new AbstractArray type, this is the default returned by axes, and it indicates that this array type uses \\\"conventional\\\" 1-based indexing.For bounds checking, note that there are dedicated functions checkbounds and checkindex which can sometimes simplify such tests.\"\n},\n\n{\n    \"location\": \"devdocs/offset-arrays.html#Linear-indexing-(LinearIndices)-1\",\n    \"page\": \"Arrays with custom indices\",\n    \"title\": \"Linear indexing (LinearIndices)\",\n    \"category\": \"section\",\n    \"text\": \"Some algorithms are most conveniently (or efficiently) written in terms of a single linear index, A[i] even if A is multi-dimensional. Regardless of the array\\'s native indices, linear indices always range from 1:length(A). However, this raises an ambiguity for one-dimensional arrays (a.k.a., AbstractVector): does v[i] mean linear indexing , or Cartesian indexing with the array\\'s native indices?For this reason, your best option may be to iterate over the array with eachindex(A), or, if you require the indices to be sequential integers, to get the index range by calling LinearIndices(A). This will return axes(A, 1) if A is an AbstractVector, and the equivalent of 1:length(A) otherwise.By this definition, 1-dimensional arrays always use Cartesian indexing with the array\\'s native indices. To help enforce this, it\\'s worth noting that the index conversion functions will throw an error if shape indicates a 1-dimensional array with unconventional indexing (i.e., is a Tuple{UnitRange} rather than a tuple of OneTo). For arrays with conventional indexing, these functions continue to work the same as always.Using axes and LinearIndices, here is one way you could rewrite mycopy!:function mycopy!(dest::AbstractVector, src::AbstractVector)\\n    axes(dest) == axes(src) || throw(DimensionMismatch(\\\"vectors must match\\\"))\\n    for i in LinearIndices(src)\\n        @inbounds dest[i] = src[i]\\n    end\\n    dest\\nend\"\n},\n\n{\n    \"location\": \"devdocs/offset-arrays.html#Allocating-storage-using-generalizations-of-similar-1\",\n    \"page\": \"Arrays with custom indices\",\n    \"title\": \"Allocating storage using generalizations of similar\",\n    \"category\": \"section\",\n    \"text\": \"Storage is often allocated with Array{Int}(undef, dims) or similar(A, args...). When the result needs to match the indices of some other array, this may not always suffice. The generic replacement for such patterns is to use similar(storagetype, shape).  storagetype indicates the kind of underlying \\\"conventional\\\" behavior you\\'d like, e.g., Array{Int} or BitArray or even dims->zeros(Float32, dims) (which would allocate an all-zeros array). shape is a tuple of Integer or AbstractUnitRange values, specifying the indices that you want the result to use. Note that a convenient way of producing an all-zeros array that matches the indices of A is simply zeros(A).Let\\'s walk through a couple of explicit examples. First, if A has conventional indices, then similar(Array{Int}, axes(A)) would end up calling Array{Int}(size(A)), and thus return an array.  If A is an AbstractArray type with unconventional indexing, then similar(Array{Int}, axes(A)) should return something that \\\"behaves like\\\" an Array{Int} but with a shape (including indices) that matches A.  (The most obvious implementation is to allocate an Array{Int}(undef, size(A)) and then \\\"wrap\\\" it in a type that shifts the indices.)Note also that similar(Array{Int}, (axes(A, 2),)) would allocate an AbstractVector{Int} (i.e., 1-dimensional array) that matches the indices of the columns of A.\"\n},\n\n{\n    \"location\": \"devdocs/offset-arrays.html#Writing-custom-array-types-with-non-1-indexing-1\",\n    \"page\": \"Arrays with custom indices\",\n    \"title\": \"Writing custom array types with non-1 indexing\",\n    \"category\": \"section\",\n    \"text\": \"Most of the methods you\\'ll need to define are standard for any AbstractArray type, see Abstract Arrays. This page focuses on the steps needed to define unconventional indexing.\"\n},\n\n{\n    \"location\": \"devdocs/offset-arrays.html#Custom-AbstractUnitRange-types-1\",\n    \"page\": \"Arrays with custom indices\",\n    \"title\": \"Custom AbstractUnitRange types\",\n    \"category\": \"section\",\n    \"text\": \"If you\\'re writing a non-1 indexed array type, you will want to specialize axes so it returns a UnitRange, or (perhaps better) a custom AbstractUnitRange.  The advantage of a custom type is that it \\\"signals\\\" the allocation type for functions like similar. If we\\'re writing an array type for which indexing will start at 0, we likely want to begin by creating a new AbstractUnitRange, ZeroRange, where ZeroRange(n) is equivalent to 0:n-1.In general, you should probably not export ZeroRange from your package: there may be other packages that implement their own ZeroRange, and having multiple distinct ZeroRange types is (perhaps counterintuitively) an advantage: ModuleA.ZeroRange indicates that similar should create a ModuleA.ZeroArray, whereas ModuleB.ZeroRange indicates a ModuleB.ZeroArray type.  This design allows peaceful coexistence among many different custom array types.Note that the Julia package CustomUnitRanges.jl can sometimes be used to avoid the need to write your own ZeroRange type.\"\n},\n\n{\n    \"location\": \"devdocs/offset-arrays.html#Specializing-axes-1\",\n    \"page\": \"Arrays with custom indices\",\n    \"title\": \"Specializing axes\",\n    \"category\": \"section\",\n    \"text\": \"Once you have your AbstractUnitRange type, then specialize axes:Base.axes(A::ZeroArray) = map(n->ZeroRange(n), A.size)where here we imagine that ZeroArray has a field called size (there would be other ways to implement this).In some cases, the fallback definition for axes(A, d):axes(A::AbstractArray{T,N}, d) where {T,N} = d <= N ? axes(A)[d] : OneTo(1)may not be what you want: you may need to specialize it to return something other than OneTo(1) when d > ndims(A).  Likewise, in Base there is a dedicated function indices1 which is equivalent to axes(A, 1) but which avoids checking (at runtime) whether ndims(A) > 0. (This is purely a performance optimization.)  It is defined as:indices1(A::AbstractArray{T,0}) where {T} = OneTo(1)\\nindices1(A::AbstractArray) = axes(A)[1]If the first of these (the zero-dimensional case) is problematic for your custom array type, be sure to specialize it appropriately.\"\n},\n\n{\n    \"location\": \"devdocs/offset-arrays.html#Specializing-similar-1\",\n    \"page\": \"Arrays with custom indices\",\n    \"title\": \"Specializing similar\",\n    \"category\": \"section\",\n    \"text\": \"Given your custom ZeroRange type, then you should also add the following two specializations for similar:function Base.similar(A::AbstractArray, T::Type, shape::Tuple{ZeroRange,Vararg{ZeroRange}})\\n    # body\\nend\\n\\nfunction Base.similar(f::Union{Function,DataType}, shape::Tuple{ZeroRange,Vararg{ZeroRange}})\\n    # body\\nendBoth of these should allocate your custom array type.\"\n},\n\n{\n    \"location\": \"devdocs/offset-arrays.html#Specializing-reshape-1\",\n    \"page\": \"Arrays with custom indices\",\n    \"title\": \"Specializing reshape\",\n    \"category\": \"section\",\n    \"text\": \"Optionally, define a methodBase.reshape(A::AbstractArray, shape::Tuple{ZeroRange,Vararg{ZeroRange}}) = ...and you can reshape an array so that the result has custom indices.\"\n},\n\n{\n    \"location\": \"devdocs/offset-arrays.html#For-objects-that-mimic-AbstractArray-but-are-not-subtypes-1\",\n    \"page\": \"Arrays with custom indices\",\n    \"title\": \"For objects that mimic AbstractArray but are not subtypes\",\n    \"category\": \"section\",\n    \"text\": \"has_offset_axes depends on having axes defined for the objects you call it on. If there is some reason you don\\'t have an axes method defined for your object, consider defining a methodBase.has_offset_axes(obj::MyNon1IndexedArraylikeObject) = trueThis will allow code that assumes 1-based indexing to detect a problem and throw a helpful error, rather than returning incorrect results or segfaulting julia.\"\n},\n\n{\n    \"location\": \"devdocs/offset-arrays.html#Catching-errors-1\",\n    \"page\": \"Arrays with custom indices\",\n    \"title\": \"Catching errors\",\n    \"category\": \"section\",\n    \"text\": \"If your new array type triggers errors in other code, one helpful debugging step can be to comment out @boundscheck in your getindex and setindex! implementation. This will ensure that every element access checks bounds. Or, restart julia with --check-bounds=yes.In some cases it may also be helpful to temporarily disable size and length for your new array type, since code that makes incorrect assumptions frequently uses these functions.\"\n},\n\n{\n    \"location\": \"devdocs/require.html#\",\n    \"page\": \"Module loading\",\n    \"title\": \"Module loading\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/require.html#Module-loading-1\",\n    \"page\": \"Module loading\",\n    \"title\": \"Module loading\",\n    \"category\": \"section\",\n    \"text\": \"Base.require is responsible for loading modules and it also manages the precompilation cache. It is the implementation of the import statement.\"\n},\n\n{\n    \"location\": \"devdocs/require.html#Experimental-features-1\",\n    \"page\": \"Module loading\",\n    \"title\": \"Experimental features\",\n    \"category\": \"section\",\n    \"text\": \"The features below are experimental and not part of the stable Julia API. Before building upon them inform yourself about the current thinking and whether they might change soon.\"\n},\n\n{\n    \"location\": \"devdocs/require.html#Module-loading-callbacks-1\",\n    \"page\": \"Module loading\",\n    \"title\": \"Module loading callbacks\",\n    \"category\": \"section\",\n    \"text\": \"It is possible to listen to the modules loaded by Base.require, by registering a callback.loaded_packages = Channel{Symbol}()\\ncallback = (mod::Symbol) -> put!(loaded_packages, mod)\\npush!(Base.package_callbacks, callback)Please note that the symbol given to the callback is a non-unique identifier and it is the responsibility of the callback provider to walk the module chain to determine the fully qualified name of the loaded binding.The callback below is an example of how to do that:# Get the fully-qualified name of a module.\\nfunction module_fqn(name::Symbol)\\n    fqn = fullname(Base.root_module(name))\\n    return join(fqn, \\'.\\')\\nend\"\n},\n\n{\n    \"location\": \"devdocs/inference.html#\",\n    \"page\": \"Inference\",\n    \"title\": \"Inference\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/inference.html#Inference-1\",\n    \"page\": \"Inference\",\n    \"title\": \"Inference\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/inference.html#How-inference-works-1\",\n    \"page\": \"Inference\",\n    \"title\": \"How inference works\",\n    \"category\": \"section\",\n    \"text\": \"Type inference refers to the process of deducing the types of later values from the types of input values. Julia\\'s approach to inference has been described in blog posts (1, 2).\"\n},\n\n{\n    \"location\": \"devdocs/inference.html#Debugging-compiler.jl-1\",\n    \"page\": \"Inference\",\n    \"title\": \"Debugging compiler.jl\",\n    \"category\": \"section\",\n    \"text\": \"You can start a Julia session, edit compiler/*.jl (for example to insert print statements), and then replace Core.Compiler in your running session by navigating to base/compiler and executing include(\\\"compiler.jl\\\"). This trick typically leads to much faster development than if you rebuild Julia for each change.A convenient entry point into inference is typeinf_code. Here\\'s a demo running inference on convert(Int, UInt(1)):# Get the method\\natypes = Tuple{Type{Int}, UInt}  # argument types\\nmths = methods(convert, atypes)  # worth checking that there is only one\\nm = first(mths)\\n\\n# Create variables needed to call `typeinf_code`\\nparams = Core.Compiler.Params(typemax(UInt))  # parameter is the world age,\\n                                                        #   typemax(UInt) -> most recent\\nsparams = Core.svec()      # this particular method doesn\\'t have type-parameters\\noptimize = true            # run all inference optimizations\\ncached = false             # force inference to happen (do not use cached results)\\nCore.Compiler.typeinf_code(m, atypes, sparams, optimize, cached, params)If your debugging adventures require a MethodInstance, you can look it up by calling Core.Compiler.code_for_method using many of the variables above. A CodeInfo object may be obtained with# Returns the CodeInfo object for `convert(Int, ::UInt)`:\\nci = (@code_typed convert(Int, UInt(1)))[1]\"\n},\n\n{\n    \"location\": \"devdocs/inference.html#The-inlining-algorithm-(inline_worthy)-1\",\n    \"page\": \"Inference\",\n    \"title\": \"The inlining algorithm (inline_worthy)\",\n    \"category\": \"section\",\n    \"text\": \"Much of the hardest work for inlining runs in inlining_pass. However, if your question is \\\"why didn\\'t my function inline?\\\" then you will most likely be interested in isinlineable and its primary callee, inline_worthy. isinlineable handles a number of special cases (e.g., critical functions like next and done, incorporating a bonus for functions that return tuples, etc.). The main decision-making happens in inline_worthy, which returns true if the function should be inlined.inline_worthy implements a cost-model, where \\\"cheap\\\" functions get inlined; more specifically, we inline functions if their anticipated run-time is not large compared to the time it would take to issue a call to them if they were not inlined. The cost-model is extremely simple and ignores many important details: for example, all for loops are analyzed as if they will be executed once, and the cost of an if...else...end includes the summed cost of all branches. It\\'s also worth acknowledging that we currently lack a suite of functions suitable for testing how well the cost model predicts the actual run-time cost, although BaseBenchmarks provides a great deal of indirect information about the successes and failures of any modification to the inlining algorithm.The foundation of the cost-model is a lookup table, implemented in add_tfunc and its callers, that assigns an estimated cost (measured in CPU cycles) to each of Julia\\'s intrinsic functions. These costs are based on standard ranges for common architectures (see Agner Fog\\'s analysis for more detail).We supplement this low-level lookup table with a number of special cases. For example, an :invoke expression (a call for which all input and output types were inferred in advance) is assigned a fixed cost (currently 20 cycles). In contrast, a :call expression, for functions other than intrinsics/builtins, indicates that the call will require dynamic dispatch, in which case we assign a cost set by Params.inline_nonleaf_penalty (currently set at 1000). Note that this is not a \\\"first-principles\\\" estimate of the raw cost of dynamic dispatch, but a mere heuristic indicating that dynamic dispatch is extremely expensive.Each statement gets analyzed for its total cost in a function called statement_cost. You can run this yourself by following this example:params = Core.Compiler.Params(typemax(UInt))\\n# Get the CodeInfo object\\nci = (@code_typed fill(3, (5, 5)))[1]  # we\\'ll try this on the code for `fill(3, (5, 5))`\\n# Calculate cost of each statement\\ncost(stmt) = Core.Compiler.statement_cost(stmt, ci, Base, params)\\ncst = map(cost, ci.code)The output is a Vector{Int} holding the estimated cost of each statement in ci.code.  Note that ci includes the consequences of inlining callees, and consequently the costs do too.\"\n},\n\n{\n    \"location\": \"devdocs/backtraces.html#\",\n    \"page\": \"Reporting and analyzing crashes (segfaults)\",\n    \"title\": \"Reporting and analyzing crashes (segfaults)\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/backtraces.html#Reporting-and-analyzing-crashes-(segfaults)-1\",\n    \"page\": \"Reporting and analyzing crashes (segfaults)\",\n    \"title\": \"Reporting and analyzing crashes (segfaults)\",\n    \"category\": \"section\",\n    \"text\": \"So you managed to break Julia.  Congratulations!  Collected here are some general procedures you can undergo for common symptoms encountered when something goes awry.  Including the information from these debugging steps can greatly help the maintainers when tracking down a segfault or trying to figure out why your script is running slower than expected.If you\\'ve been directed to this page, find the symptom that best matches what you\\'re experiencing and follow the instructions to generate the debugging information requested.  Table of symptoms:Segfaults during bootstrap (sysimg.jl)\\nSegfaults when running a script\\nErrors during Julia startup\"\n},\n\n{\n    \"location\": \"devdocs/backtraces.html#dev-version-info-1\",\n    \"page\": \"Reporting and analyzing crashes (segfaults)\",\n    \"title\": \"Version/Environment info\",\n    \"category\": \"section\",\n    \"text\": \"No matter the error, we will always need to know what version of Julia you are running. When Julia first starts up, a header is printed out with a version number and date. Please also include the output of versioninfo() in any report you create:versioninfo()\"\n},\n\n{\n    \"location\": \"devdocs/backtraces.html#Segfaults-during-bootstrap-(sysimg.jl)-1\",\n    \"page\": \"Reporting and analyzing crashes (segfaults)\",\n    \"title\": \"Segfaults during bootstrap (sysimg.jl)\",\n    \"category\": \"section\",\n    \"text\": \"Segfaults toward the end of the make process of building Julia are a common symptom of something going wrong while Julia is preparsing the corpus of code in the base/ folder.  Many factors can contribute toward this process dying unexpectedly, however it is as often as not due to an error in the C-code portion of Julia, and as such must typically be debugged with a debug build inside of gdb.  Explicitly:Create a debug build of Julia:$ cd <julia_root>\\n$ make debugNote that this process will likely fail with the same error as a normal make incantation, however this will create a debug executable that will offer gdb the debugging symbols needed to get accurate backtraces.  Next, manually run the bootstrap process inside of gdb:$ cd base/\\n$ gdb -x ../contrib/debug_bootstrap.gdbThis will start gdb, attempt to run the bootstrap process using the debug build of Julia, and print out a backtrace if (when) it segfaults.  You may need to hit <enter> a few times to get the full backtrace.  Create a gist with the backtrace, the version info, and any other pertinent information you can think of and open a new issue on Github with a link to the gist.\"\n},\n\n{\n    \"location\": \"devdocs/backtraces.html#Segfaults-when-running-a-script-1\",\n    \"page\": \"Reporting and analyzing crashes (segfaults)\",\n    \"title\": \"Segfaults when running a script\",\n    \"category\": \"section\",\n    \"text\": \"The procedure is very similar to Segfaults during bootstrap (sysimg.jl).  Create a debug build of Julia, and run your script inside of a debugged Julia process:$ cd <julia_root>\\n$ make debug\\n$ gdb --args usr/bin/julia-debug <path_to_your_script>Note that gdb will sit there, waiting for instructions.  Type r to run the process, and bt to generate a backtrace once it segfaults:(gdb) r\\nStarting program: /home/sabae/src/julia/usr/bin/julia-debug ./test.jl\\n...\\n(gdb) btCreate a gist with the backtrace, the version info, and any other pertinent information you can think of and open a new issue on Github with a link to the gist.\"\n},\n\n{\n    \"location\": \"devdocs/backtraces.html#Errors-during-Julia-startup-1\",\n    \"page\": \"Reporting and analyzing crashes (segfaults)\",\n    \"title\": \"Errors during Julia startup\",\n    \"category\": \"section\",\n    \"text\": \"Occasionally errors occur during Julia\\'s startup process (especially when using binary distributions, as opposed to compiling from source) such as the following:$ julia\\nexec: error -5These errors typically indicate something is not getting loaded properly very early on in the bootup phase, and our best bet in determining what\\'s going wrong is to use external tools to audit the disk activity of the julia process:On Linux, use strace:\\n$ strace julia\\nOn OSX, use dtruss:\\n$ dtruss -f juliaCreate a gist with the strace/ dtruss output, the version info, and any other pertinent information and open a new issue on Github with a link to the gist.\"\n},\n\n{\n    \"location\": \"devdocs/backtraces.html#Glossary-1\",\n    \"page\": \"Reporting and analyzing crashes (segfaults)\",\n    \"title\": \"Glossary\",\n    \"category\": \"section\",\n    \"text\": \"A few terms have been used as shorthand in this guide:<julia_root> refers to the root directory of the Julia source tree; e.g. it should contain folders such as base, deps, src, test, etc.....\"\n},\n\n{\n    \"location\": \"devdocs/debuggingtips.html#\",\n    \"page\": \"gdb debugging tips\",\n    \"title\": \"gdb debugging tips\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/debuggingtips.html#gdb-debugging-tips-1\",\n    \"page\": \"gdb debugging tips\",\n    \"title\": \"gdb debugging tips\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/debuggingtips.html#Displaying-Julia-variables-1\",\n    \"page\": \"gdb debugging tips\",\n    \"title\": \"Displaying Julia variables\",\n    \"category\": \"section\",\n    \"text\": \"Within gdb, any jl_value_t* object obj can be displayed using(gdb) call jl_(obj)The object will be displayed in the julia session, not in the gdb session. This is a useful way to discover the types and values of objects being manipulated by Julia\\'s C code.Similarly, if you\\'re debugging some of Julia\\'s internals (e.g., compiler.jl), you can print obj usingccall(:jl_, Cvoid, (Any,), obj)This is a good way to circumvent problems that arise from the order in which julia\\'s output streams are initialized.Julia\\'s flisp interpreter uses value_t objects; these can be displayed with call fl_print(fl_ctx, ios_stdout, obj).\"\n},\n\n{\n    \"location\": \"devdocs/debuggingtips.html#Useful-Julia-variables-for-Inspecting-1\",\n    \"page\": \"gdb debugging tips\",\n    \"title\": \"Useful Julia variables for Inspecting\",\n    \"category\": \"section\",\n    \"text\": \"While the addresses of many variables, like singletons, can be be useful to print for many failures, there are a number of additional variables (see julia.h for a complete list) that are even more useful.(when in jl_apply_generic) mfunc and jl_uncompress_ast(mfunc->def, mfunc->code) :: for figuring out a bit about the call-stack\\njl_lineno and jl_filename :: for figuring out what line in a test to go start debugging from (or figure out how far into a file has been parsed)\\n$1 :: not really a variable, but still a useful shorthand for referring to the result of the last gdb command (such as print)\\njl_options :: sometimes useful, since it lists all of the command line options that were successfully parsed\\njl_uv_stderr :: because who doesn\\'t like to be able to interact with stdio\"\n},\n\n{\n    \"location\": \"devdocs/debuggingtips.html#Useful-Julia-functions-for-Inspecting-those-variables-1\",\n    \"page\": \"gdb debugging tips\",\n    \"title\": \"Useful Julia functions for Inspecting those variables\",\n    \"category\": \"section\",\n    \"text\": \"jl_gdblookup($rip) :: For looking up the current function and line. (use $eip on i686 platforms)\\njlbacktrace() :: For dumping the current Julia backtrace stack to stderr. Only usable after record_backtrace() has been called.\\njl_dump_llvm_value(Value*) :: For invoking Value->dump() in gdb, where it doesn\\'t work natively. For example, f->linfo->functionObject, f->linfo->specFunctionObject, and to_function(f->linfo).\\nType->dump() :: only works in lldb. Note: add something like ;1 to prevent lldb from printing its prompt over the output\\njl_eval_string(\\\"expr\\\") :: for invoking side-effects to modify the current state or to lookup symbols\\njl_typeof(jl_value_t*) :: for extracting the type tag of a Julia value (in gdb, call macro define jl_typeof jl_typeof first, or pick something short like ty for the first arg to define a shorthand)\"\n},\n\n{\n    \"location\": \"devdocs/debuggingtips.html#Inserting-breakpoints-for-inspection-from-gdb-1\",\n    \"page\": \"gdb debugging tips\",\n    \"title\": \"Inserting breakpoints for inspection from gdb\",\n    \"category\": \"section\",\n    \"text\": \"In your gdb session, set a breakpoint in jl_breakpoint like so:(gdb) break jl_breakpointThen within your Julia code, insert a call to jl_breakpoint by addingccall(:jl_breakpoint, Cvoid, (Any,), obj)where obj can be any variable or tuple you want to be accessible in the breakpoint.It\\'s particularly helpful to back up to the jl_apply frame, from which you can display the arguments to a function using, e.g.,(gdb) call jl_(args[0])Another useful frame is to_function(jl_method_instance_t *li, bool cstyle). The jl_method_instance_t* argument is a struct with a reference to the final AST sent into the compiler. However, the AST at this point will usually be compressed; to view the AST, call jl_uncompress_ast and then pass the result to jl_:#2  0x00007ffff7928bf7 in to_function (li=0x2812060, cstyle=false) at codegen.cpp:584\\n584          abort();\\n(gdb) p jl_(jl_uncompress_ast(li, li->ast))\"\n},\n\n{\n    \"location\": \"devdocs/debuggingtips.html#Inserting-breakpoints-upon-certain-conditions-1\",\n    \"page\": \"gdb debugging tips\",\n    \"title\": \"Inserting breakpoints upon certain conditions\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/debuggingtips.html#Loading-a-particular-file-1\",\n    \"page\": \"gdb debugging tips\",\n    \"title\": \"Loading a particular file\",\n    \"category\": \"section\",\n    \"text\": \"Let\\'s say the file is sysimg.jl:(gdb) break jl_load if strcmp(fname, \\\"sysimg.jl\\\")==0\"\n},\n\n{\n    \"location\": \"devdocs/debuggingtips.html#Calling-a-particular-method-1\",\n    \"page\": \"gdb debugging tips\",\n    \"title\": \"Calling a particular method\",\n    \"category\": \"section\",\n    \"text\": \"(gdb) break jl_apply_generic if strcmp((char*)(jl_symbol_name)(jl_gf_mtable(F)->name), \\\"method_to_break\\\")==0Since this function is used for every call, you will make everything 1000x slower if you do this.\"\n},\n\n{\n    \"location\": \"devdocs/debuggingtips.html#Dealing-with-signals-1\",\n    \"page\": \"gdb debugging tips\",\n    \"title\": \"Dealing with signals\",\n    \"category\": \"section\",\n    \"text\": \"Julia requires a few signal to function property. The profiler uses SIGUSR2 for sampling and the garbage collector uses SIGSEGV for threads synchronization. If you are debugging some code that uses the profiler or multiple threads, you may want to let the debugger ignore these signals since they can be triggered very often during normal operations. The command to do this in GDB is (replace SIGSEGV with SIGUSRS or other signals you want to ignore):(gdb) handle SIGSEGV noprint nostop passThe corresponding LLDB command is (after the process is started):(lldb) pro hand -p true -s false -n false SIGSEGVIf you are debugging a segfault with threaded code, you can set a breakpoint on jl_critical_error (sigdie_handler should also work on Linux and BSD) in order to only catch the actual segfault rather than the GC synchronization points.\"\n},\n\n{\n    \"location\": \"devdocs/debuggingtips.html#Debugging-during-Julia\\'s-build-process-(bootstrap)-1\",\n    \"page\": \"gdb debugging tips\",\n    \"title\": \"Debugging during Julia\\'s build process (bootstrap)\",\n    \"category\": \"section\",\n    \"text\": \"Errors that occur during make need special handling. Julia is built in two stages, constructing sys0 and sys.ji. To see what commands are running at the time of failure, use make VERBOSE=1.At the time of this writing, you can debug build errors during the sys0 phase from the base directory using:julia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys0 sysimg.jlYou might need to delete all the files in usr/lib/julia/ to get this to work.You can debug the sys.ji phase using:julia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys -J ../usr/lib/julia/sys0.ji sysimg.jlBy default, any errors will cause Julia to exit, even under gdb. To catch an error \\\"in the act\\\", set a breakpoint in jl_error (there are several other useful spots, for specific kinds of failures, including: jl_too_few_args, jl_too_many_args, and jl_throw).Once an error is caught, a useful technique is to walk up the stack and examine the function by inspecting the related call to jl_apply. To take a real-world example:Breakpoint 1, jl_throw (e=0x7ffdf42de400) at task.c:802\\n802 {\\n(gdb) p jl_(e)\\nErrorException(\\\"auto_unbox: unable to determine argument type\\\")\\n$2 = void\\n(gdb) bt 10\\n#0  jl_throw (e=0x7ffdf42de400) at task.c:802\\n#1  0x00007ffff65412fe in jl_error (str=0x7ffde56be000 <_j_str267> \\\"auto_unbox:\\n   unable to determine argument type\\\")\\n   at builtins.c:39\\n#2  0x00007ffde56bd01a in julia_convert_16886 ()\\n#3  0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281\\n...The most recent jl_apply is at frame #3, so we can go back there and look at the AST for the function julia_convert_16886. This is the uniqued name for some method of convert. f in this frame is a jl_function_t*, so we can look at the type signature, if any, from the specTypes field:(gdb) f 3\\n#3  0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281\\n1281            return f->fptr((jl_value_t*)f, args, nargs);\\n(gdb) p f->linfo->specTypes\\n$4 = (jl_tupletype_t *) 0x7ffdf39b1030\\n(gdb) p jl_( f->linfo->specTypes )\\nTuple{Type{Float32}, Float64}           # <-- type signature for julia_convert_16886Then, we can look at the AST for this function:(gdb) p jl_( jl_uncompress_ast(f->linfo, f->linfo->ast) )\\nExpr(:lambda, Array{Any, 1}[:#s29, :x], Array{Any, 1}[Array{Any, 1}[], Array{Any, 1}[Array{Any, 1}[:#s29, :Any, 0], Array{Any, 1}[:x, :Any, 0]], Array{Any, 1}[], 0], Expr(:body,\\nExpr(:line, 90, :float.jl)::Any,\\nExpr(:return, Expr(:call, :box, :Float32, Expr(:call, :fptrunc, :Float32, :x)::Any)::Any)::Any)::Any)::AnyFinally, and perhaps most usefully, we can force the function to be recompiled in order to step through the codegen process. To do this, clear the cached functionObject from the jl_lamdbda_info_t*:(gdb) p f->linfo->functionObject\\n$8 = (void *) 0x1289d070\\n(gdb) set f->linfo->functionObject = NULLThen, set a breakpoint somewhere useful (e.g. emit_function, emit_expr, emit_call, etc.), and run codegen:(gdb) p jl_compile(f)\\n... # your breakpoint here\"\n},\n\n{\n    \"location\": \"devdocs/debuggingtips.html#Debugging-precompilation-errors-1\",\n    \"page\": \"gdb debugging tips\",\n    \"title\": \"Debugging precompilation errors\",\n    \"category\": \"section\",\n    \"text\": \"Module precompilation spawns a separate Julia process to precompile each module. Setting a breakpoint or catching failures in a precompile worker requires attaching a debugger to the worker. The easiest approach is to set the debugger watch for new process launches matching a given name. For example:(gdb) attach -w -n julia-debugor:(lldb) process attach -w -n julia-debugThen run a script/command to start precompilation. As described earlier, use conditional breakpoints in the parent process to catch specific file-loading events and narrow the debugging window. (some operating systems may require alternative approaches, such as following each fork from the parent process)\"\n},\n\n{\n    \"location\": \"devdocs/debuggingtips.html#Mozilla\\'s-Record-and-Replay-Framework-(rr)-1\",\n    \"page\": \"gdb debugging tips\",\n    \"title\": \"Mozilla\\'s Record and Replay Framework (rr)\",\n    \"category\": \"section\",\n    \"text\": \"Julia now works out of the box with rr, the lightweight recording and deterministic debugging framework from Mozilla. This allows you to replay the trace of an execution deterministically.  The replayed execution\\'s address spaces, register contents, syscall data etc are exactly the same in every run.A recent version of rr (3.1.0 or higher) is required.\"\n},\n\n{\n    \"location\": \"devdocs/valgrind.html#\",\n    \"page\": \"Using Valgrind with Julia\",\n    \"title\": \"Using Valgrind with Julia\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/valgrind.html#Using-Valgrind-with-Julia-1\",\n    \"page\": \"Using Valgrind with Julia\",\n    \"title\": \"Using Valgrind with Julia\",\n    \"category\": \"section\",\n    \"text\": \"Valgrind is a tool for memory debugging, memory leak detection, and profiling.  This section describes things to keep in mind when using Valgrind to debug memory issues with Julia.\"\n},\n\n{\n    \"location\": \"devdocs/valgrind.html#General-considerations-1\",\n    \"page\": \"Using Valgrind with Julia\",\n    \"title\": \"General considerations\",\n    \"category\": \"section\",\n    \"text\": \"By default, Valgrind assumes that there is no self modifying code in the programs it runs.  This assumption works fine in most instances but fails miserably for a just-in-time compiler like julia.  For this reason it is crucial to pass --smc-check=all-non-file to valgrind, else code may crash or behave unexpectedly (often in subtle ways).In some cases, to better detect memory errors using Valgrind it can help to compile julia with memory pools disabled.  The compile-time flag MEMDEBUG disables memory pools in Julia, and MEMDEBUG2 disables memory pools in FemtoLisp.  To build julia with both flags, add the following line to Make.user:CFLAGS = -DMEMDEBUG -DMEMDEBUG2Another thing to note: if your program uses multiple workers processes, it is likely that you want all such worker processes to run under Valgrind, not just the parent process.  To do this, pass --trace-children=yes to valgrind.\"\n},\n\n{\n    \"location\": \"devdocs/valgrind.html#Suppressions-1\",\n    \"page\": \"Using Valgrind with Julia\",\n    \"title\": \"Suppressions\",\n    \"category\": \"section\",\n    \"text\": \"Valgrind will typically display spurious warnings as it runs.  To reduce the number of such warnings, it helps to provide a suppressions file to Valgrind.  A sample suppressions file is included in the Julia source distribution at contrib/valgrind-julia.supp.The suppressions file can be used from the julia/ source directory as follows:$ valgrind --smc-check=all-non-file --suppressions=contrib/valgrind-julia.supp ./julia progname.jlAny memory errors that are displayed should either be reported as bugs or contributed as additional suppressions.  Note that some versions of Valgrind are shipped with insufficient default suppressions, so that may be one thing to consider before submitting any bugs.\"\n},\n\n{\n    \"location\": \"devdocs/valgrind.html#Running-the-Julia-test-suite-under-Valgrind-1\",\n    \"page\": \"Using Valgrind with Julia\",\n    \"title\": \"Running the Julia test suite under Valgrind\",\n    \"category\": \"section\",\n    \"text\": \"It is possible to run the entire Julia test suite under Valgrind, but it does take quite some time (typically several hours).  To do so, run the following command from the julia/test/ directory:valgrind --smc-check=all-non-file --trace-children=yes --suppressions=$PWD/../contrib/valgrind-julia.supp ../julia runtests.jl allIf you would like to see a report of \\\"definite\\\" memory leaks, pass the flags --leak-check=full --show-leak-kinds=definite to valgrind as well.\"\n},\n\n{\n    \"location\": \"devdocs/valgrind.html#Caveats-1\",\n    \"page\": \"Using Valgrind with Julia\",\n    \"title\": \"Caveats\",\n    \"category\": \"section\",\n    \"text\": \"Valgrind currently does not support multiple rounding modes, so code that adjusts the rounding mode will behave differently when run under Valgrind.In general, if after setting --smc-check=all-non-file you find that your program behaves differently when run under Valgrind, it may help to pass --tool=none to valgrind as you investigate further.  This will enable the minimal Valgrind machinery but will also run much faster than when the full memory checker is enabled.\"\n},\n\n{\n    \"location\": \"devdocs/sanitizers.html#\",\n    \"page\": \"Sanitizer support\",\n    \"title\": \"Sanitizer support\",\n    \"category\": \"page\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/sanitizers.html#Sanitizer-support-1\",\n    \"page\": \"Sanitizer support\",\n    \"title\": \"Sanitizer support\",\n    \"category\": \"section\",\n    \"text\": \"\"\n},\n\n{\n    \"location\": \"devdocs/sanitizers.html#General-considerations-1\",\n    \"page\": \"Sanitizer support\",\n    \"title\": \"General considerations\",\n    \"category\": \"section\",\n    \"text\": \"Using Clang\\'s sanitizers obviously require you to use Clang (USECLANG=1), but there\\'s another catch: most sanitizers require a run-time library, provided by the host compiler, while the instrumented code generated by Julia\\'s JIT relies on functionality from that library. This implies that the LLVM version of your host compiler matches that of the LLVM library used within Julia.An easy solution is to have an dedicated build folder for providing a matching toolchain, by building with BUILD_LLVM_CLANG=1. You can then refer to this toolchain from another build folder by specifying USECLANG=1 while overriding the CC and CXX variables.\"\n},\n\n{\n    \"location\": \"devdocs/sanitizers.html#Address-Sanitizer-(ASAN)-1\",\n    \"page\": \"Sanitizer support\",\n    \"title\": \"Address Sanitizer (ASAN)\",\n    \"category\": \"section\",\n    \"text\": \"For detecting or debugging memory bugs, you can use Clang\\'s address sanitizer (ASAN). By compiling with SANITIZE=1 you enable ASAN for the Julia compiler and its generated code. In addition, you can specify LLVM_SANITIZE=1 to sanitize the LLVM library as well. Note that these options incur a high performance and memory cost. For example, using ASAN for Julia and LLVM makes testall1 takes 8-10 times as long while using 20 times as much memory (this can be reduced to respectively a factor of 3 and 4 by using the options described below).By default, Julia sets the allow_user_segv_handler=1 ASAN flag, which is required for signal delivery to work properly. You can define other options using the ASAN_OPTIONS environment flag, in which case you\\'ll need to repeat the default option mentioned before. For example, memory usage can be reduced by specifying fast_unwind_on_malloc=0 and malloc_context_size=2, at the cost of backtrace accuracy. For now, Julia also sets detect_leaks=0, but this should be removed in the future.\"\n},\n\n{\n    \"location\": \"devdocs/sanitizers.html#Memory-Sanitizer-(MSAN)-1\",\n    \"page\": \"Sanitizer support\",\n    \"title\": \"Memory Sanitizer (MSAN)\",\n    \"category\": \"section\",\n    \"text\": \"For detecting use of uninitialized memory, you can use Clang\\'s memory sanitizer (MSAN) by compiling with SANITIZE_MEMORY=1.\"\n},\n\n]}\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/doc/_build/html/en/manual/calling-c-and-fortran-code.html": "<!DOCTYPE html>\n<html lang=\"en\"><head><meta charset=\"UTF-8\"/><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/><title>Calling C and Fortran Code \u00b7 The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\nm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\n\nga('create', 'UA-28835595-6', 'auto');\nga('send', 'pageview');\n</script><link href=\"https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css\" rel=\"stylesheet\" type=\"text/css\"/><link href=\"https://fonts.googleapis.com/css?family=Lato|Roboto+Mono\" rel=\"stylesheet\" type=\"text/css\"/><link href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css\" rel=\"stylesheet\" type=\"text/css\"/><link href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css\" rel=\"stylesheet\" type=\"text/css\"/><script>documenterBaseURL=\"..\"</script><script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js\" data-main=\"../assets/documenter.js\"></script><script src=\"../siteinfo.js\"></script><script src=\"../../versions.js\"></script><link href=\"../assets/documenter.css\" rel=\"stylesheet\" type=\"text/css\"/><link href=\"../assets/julia-manual.css\" rel=\"stylesheet\" type=\"text/css\"/></head><body><nav class=\"toc\"><a href=\"../index.html\"><img class=\"logo\" src=\"../assets/logo.png\" alt=\"The Julia Language logo\"/></a><h1>The Julia Language</h1><select id=\"version-selector\" onChange=\"window.location.href=this.value\" style=\"visibility: hidden\"></select><form class=\"search\" id=\"search-form\" action=\"../search.html\"><input id=\"search-query\" name=\"q\" type=\"text\" placeholder=\"Search docs\"/></form><ul><li><a class=\"toctext\" href=\"../index.html\">Home</a></li><li><span class=\"toctext\">Manual</span><ul><li><a class=\"toctext\" href=\"getting-started.html\">Getting Started</a></li><li><a class=\"toctext\" href=\"variables.html\">Variables</a></li><li><a class=\"toctext\" href=\"integers-and-floating-point-numbers.html\">Integers and Floating-Point Numbers</a></li><li><a class=\"toctext\" href=\"mathematical-operations.html\">Mathematical Operations and Elementary Functions</a></li><li><a class=\"toctext\" href=\"complex-and-rational-numbers.html\">Complex and Rational Numbers</a></li><li><a class=\"toctext\" href=\"strings.html\">Strings</a></li><li><a class=\"toctext\" href=\"functions.html\">Functions</a></li><li><a class=\"toctext\" href=\"control-flow.html\">Control Flow</a></li><li><a class=\"toctext\" href=\"variables-and-scoping.html\">Scope of Variables</a></li><li><a class=\"toctext\" href=\"types.html\">Types</a></li><li><a class=\"toctext\" href=\"methods.html\">Methods</a></li><li><a class=\"toctext\" href=\"constructors.html\">Constructors</a></li><li><a class=\"toctext\" href=\"conversion-and-promotion.html\">Conversion and Promotion</a></li><li><a class=\"toctext\" href=\"interfaces.html\">Interfaces</a></li><li><a class=\"toctext\" href=\"modules.html\">Modules</a></li><li><a class=\"toctext\" href=\"documentation.html\">Documentation</a></li><li><a class=\"toctext\" href=\"metaprogramming.html\">Metaprogramming</a></li><li><a class=\"toctext\" href=\"arrays.html\">Multi-dimensional Arrays</a></li><li><a class=\"toctext\" href=\"missing.html\">Missing Values</a></li><li><a class=\"toctext\" href=\"networking-and-streams.html\">Networking and Streams</a></li><li><a class=\"toctext\" href=\"parallel-computing.html\">Parallel Computing</a></li><li><a class=\"toctext\" href=\"running-external-programs.html\">Running External Programs</a></li><li class=\"current\"><a class=\"toctext\" href=\"calling-c-and-fortran-code.html\">Calling C and Fortran Code</a><ul class=\"internal\"><li><a class=\"toctext\" href=\"#Creating-C-Compatible-Julia-Function-Pointers-1\">Creating C-Compatible Julia Function Pointers</a></li><li><a class=\"toctext\" href=\"#Mapping-C-Types-to-Julia-1\">Mapping C Types to Julia</a></li><li><a class=\"toctext\" href=\"#Mapping-C-Functions-to-Julia-1\">Mapping C Functions to Julia</a></li><li><a class=\"toctext\" href=\"#Some-Examples-of-C-Wrappers-1\">Some Examples of C Wrappers</a></li><li><a class=\"toctext\" href=\"#Garbage-Collection-Safety-1\">Garbage Collection Safety</a></li><li><a class=\"toctext\" href=\"#Non-constant-Function-Specifications-1\">Non-constant Function Specifications</a></li><li><a class=\"toctext\" href=\"#Indirect-Calls-1\">Indirect Calls</a></li><li><a class=\"toctext\" href=\"#Closure-cfunctions-1\">Closure cfunctions</a></li><li><a class=\"toctext\" href=\"#Closing-a-Library-1\">Closing a Library</a></li><li><a class=\"toctext\" href=\"#Calling-Convention-1\">Calling Convention</a></li><li><a class=\"toctext\" href=\"#Accessing-Global-Variables-1\">Accessing Global Variables</a></li><li><a class=\"toctext\" href=\"#Accessing-Data-through-a-Pointer-1\">Accessing Data through a Pointer</a></li><li><a class=\"toctext\" href=\"#Thread-safety-1\">Thread-safety</a></li><li><a class=\"toctext\" href=\"#More-About-Callbacks-1\">More About Callbacks</a></li><li><a class=\"toctext\" href=\"#C-1\">C++</a></li></ul></li><li><a class=\"toctext\" href=\"handling-operating-system-variation.html\">Handling Operating System Variation</a></li><li><a class=\"toctext\" href=\"environment-variables.html\">Environment Variables</a></li><li><a class=\"toctext\" href=\"embedding.html\">Embedding Julia</a></li><li><a class=\"toctext\" href=\"code-loading.html\">Code Loading</a></li><li><a class=\"toctext\" href=\"profile.html\">Profiling</a></li><li><a class=\"toctext\" href=\"stacktraces.html\">Stack Traces</a></li><li><a class=\"toctext\" href=\"performance-tips.html\">Performance Tips</a></li><li><a class=\"toctext\" href=\"workflow-tips.html\">Workflow Tips</a></li><li><a class=\"toctext\" href=\"style-guide.html\">Style Guide</a></li><li><a class=\"toctext\" href=\"faq.html\">Frequently Asked Questions</a></li><li><a class=\"toctext\" href=\"noteworthy-differences.html\">Noteworthy Differences from other Languages</a></li><li><a class=\"toctext\" href=\"unicode-input.html\">Unicode Input</a></li></ul></li><li><span class=\"toctext\">Base</span><ul><li><a class=\"toctext\" href=\"../base/base.html\">Essentials</a></li><li><a class=\"toctext\" href=\"../base/collections.html\">Collections and Data Structures</a></li><li><a class=\"toctext\" href=\"../base/math.html\">Mathematics</a></li><li><a class=\"toctext\" href=\"../base/numbers.html\">Numbers</a></li><li><a class=\"toctext\" href=\"../base/strings.html\">Strings</a></li><li><a class=\"toctext\" href=\"../base/arrays.html\">Arrays</a></li><li><a class=\"toctext\" href=\"../base/parallel.html\">Tasks</a></li><li><a class=\"toctext\" href=\"../base/multi-threading.html\">Multi-Threading</a></li><li><a class=\"toctext\" href=\"../base/constants.html\">Constants</a></li><li><a class=\"toctext\" href=\"../base/file.html\">Filesystem</a></li><li><a class=\"toctext\" href=\"../base/io-network.html\">I/O and Network</a></li><li><a class=\"toctext\" href=\"../base/punctuation.html\">Punctuation</a></li><li><a class=\"toctext\" href=\"../base/sort.html\">Sorting and Related Functions</a></li><li><a class=\"toctext\" href=\"../base/iterators.html\">Iteration utilities</a></li><li><a class=\"toctext\" href=\"../base/c.html\">C Interface</a></li><li><a class=\"toctext\" href=\"../base/libc.html\">C Standard Library</a></li><li><a class=\"toctext\" href=\"../base/stacktraces.html\">StackTraces</a></li><li><a class=\"toctext\" href=\"../base/simd-types.html\">SIMD Support</a></li></ul></li><li><span class=\"toctext\">Standard Library</span><ul><li><a class=\"toctext\" href=\"../stdlib/Base64.html\">Base64</a></li><li><a class=\"toctext\" href=\"../stdlib/CRC32c.html\">CRC32c</a></li><li><a class=\"toctext\" href=\"../stdlib/Dates.html\">Dates</a></li><li><a class=\"toctext\" href=\"../stdlib/DelimitedFiles.html\">Delimited Files</a></li><li><a class=\"toctext\" href=\"../stdlib/Distributed.html\">Distributed Computing</a></li><li><a class=\"toctext\" href=\"../stdlib/FileWatching.html\">File Events</a></li><li><a class=\"toctext\" href=\"../stdlib/InteractiveUtils.html\">Interactive Utilities</a></li><li><a class=\"toctext\" href=\"../stdlib/LibGit2.html\">LibGit2</a></li><li><a class=\"toctext\" href=\"../stdlib/Libdl.html\">Dynamic Linker</a></li><li><a class=\"toctext\" href=\"../stdlib/LinearAlgebra.html\">Linear Algebra</a></li><li><a class=\"toctext\" href=\"../stdlib/Logging.html\">Logging</a></li><li><a class=\"toctext\" href=\"../stdlib/Markdown.html\">Markdown</a></li><li><a class=\"toctext\" href=\"../stdlib/Mmap.html\">Memory-mapped I/O</a></li><li><a class=\"toctext\" href=\"../stdlib/Pkg.html\">Pkg</a></li><li><a class=\"toctext\" href=\"../stdlib/Printf.html\">Printf</a></li><li><a class=\"toctext\" href=\"../stdlib/Profile.html\">Profiling</a></li><li><a class=\"toctext\" href=\"../stdlib/REPL.html\">The Julia REPL</a></li><li><a class=\"toctext\" href=\"../stdlib/Random.html\">Random Numbers</a></li><li><a class=\"toctext\" href=\"../stdlib/SHA.html\">SHA</a></li><li><a class=\"toctext\" href=\"../stdlib/Serialization.html\">Serialization</a></li><li><a class=\"toctext\" href=\"../stdlib/SharedArrays.html\">Shared Arrays</a></li><li><a class=\"toctext\" href=\"../stdlib/Sockets.html\">Sockets</a></li><li><a class=\"toctext\" href=\"../stdlib/SparseArrays.html\">Sparse Arrays</a></li><li><a class=\"toctext\" href=\"../stdlib/Statistics.html\">Statistics</a></li><li><a class=\"toctext\" href=\"../stdlib/Test.html\">Unit Testing</a></li><li><a class=\"toctext\" href=\"../stdlib/UUIDs.html\">UUIDs</a></li><li><a class=\"toctext\" href=\"../stdlib/Unicode.html\">Unicode</a></li></ul></li><li><span class=\"toctext\">Developer Documentation</span><ul><li><a class=\"toctext\" href=\"../devdocs/reflection.html\">Reflection and introspection</a></li><li><span class=\"toctext\">Documentation of Julia&#39;s Internals</span><ul><li><a class=\"toctext\" href=\"../devdocs/init.html\">Initialization of the Julia runtime</a></li><li><a class=\"toctext\" href=\"../devdocs/ast.html\">Julia ASTs</a></li><li><a class=\"toctext\" href=\"../devdocs/types.html\">More about types</a></li><li><a class=\"toctext\" href=\"../devdocs/object.html\">Memory layout of Julia Objects</a></li><li><a class=\"toctext\" href=\"../devdocs/eval.html\">Eval of Julia code</a></li><li><a class=\"toctext\" href=\"../devdocs/callconv.html\">Calling Conventions</a></li><li><a class=\"toctext\" href=\"../devdocs/compiler.html\">High-level Overview of the Native-Code Generation Process</a></li><li><a class=\"toctext\" href=\"../devdocs/functions.html\">Julia Functions</a></li><li><a class=\"toctext\" href=\"../devdocs/cartesian.html\">Base.Cartesian</a></li><li><a class=\"toctext\" href=\"../devdocs/meta.html\">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class=\"toctext\" href=\"../devdocs/subarrays.html\">SubArrays</a></li><li><a class=\"toctext\" href=\"../devdocs/isbitsunionarrays.html\">isbits Union Optimizations</a></li><li><a class=\"toctext\" href=\"../devdocs/sysimg.html\">System Image Building</a></li><li><a class=\"toctext\" href=\"../devdocs/llvm.html\">Working with LLVM</a></li><li><a class=\"toctext\" href=\"../devdocs/stdio.html\">printf() and stdio in the Julia runtime</a></li><li><a class=\"toctext\" href=\"../devdocs/boundscheck.html\">Bounds checking</a></li><li><a class=\"toctext\" href=\"../devdocs/locks.html\">Proper maintenance and care of multi-threading locks</a></li><li><a class=\"toctext\" href=\"../devdocs/offset-arrays.html\">Arrays with custom indices</a></li><li><a class=\"toctext\" href=\"../devdocs/require.html\">Module loading</a></li><li><a class=\"toctext\" href=\"../devdocs/inference.html\">Inference</a></li></ul></li><li><span class=\"toctext\">Developing/debugging Julia&#39;s C code</span><ul><li><a class=\"toctext\" href=\"../devdocs/backtraces.html\">Reporting and analyzing crashes (segfaults)</a></li><li><a class=\"toctext\" href=\"../devdocs/debuggingtips.html\">gdb debugging tips</a></li><li><a class=\"toctext\" href=\"../devdocs/valgrind.html\">Using Valgrind with Julia</a></li><li><a class=\"toctext\" href=\"../devdocs/sanitizers.html\">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id=\"docs\"><header><nav><ul><li>Manual</li><li><a href=\"calling-c-and-fortran-code.html\">Calling C and Fortran Code</a></li></ul><a class=\"edit-page\" href=\"https://github.com/JuliaLang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md\"><span class=\"fa\">\uf09b</span> Edit on GitHub</a></nav><hr/><div id=\"topbar\"><span>Calling C and Fortran Code</span><a class=\"fa fa-bars\" href=\"#\"></a></div></header><h1><a class=\"nav-anchor\" id=\"Calling-C-and-Fortran-Code-1\" href=\"#Calling-C-and-Fortran-Code-1\">Calling C and Fortran Code</a></h1><p>Though most code can be written in Julia, there are many high-quality, mature libraries for numerical computing already written in C and Fortran. To allow easy use of this existing code, Julia makes it simple and efficient to call C and Fortran functions. Julia has a &quot;no boilerplate&quot; philosophy: functions can be called directly from Julia without any &quot;glue&quot; code, code generation, or compilation \u2013 even from the interactive prompt. This is accomplished just by making an appropriate call with <a href=\"../base/c.html#ccall\"><code>ccall</code></a> syntax, which looks like an ordinary function call.</p><p>The code to be called must be available as a shared library. Most C and Fortran libraries ship compiled as shared libraries already, but if you are compiling the code yourself using GCC (or Clang), you will need to use the <code>-shared</code> and <code>-fPIC</code> options. The machine instructions generated by Julia&#39;s JIT are the same as a native C call would be, so the resulting overhead is the same as calling a library function from C code. (Non-library function calls in both C and Julia can be inlined and thus may have even less overhead than calls to shared library functions. When both libraries and executables are generated by LLVM, it is possible to perform whole-program optimizations that can even optimize across this boundary, but Julia does not yet support that. In the future, however, it may do so, yielding even greater performance gains.)</p><p>Shared libraries and functions are referenced by a tuple of the form <code>(:function, &quot;library&quot;)</code> or <code>(&quot;function&quot;, &quot;library&quot;)</code> where <code>function</code> is the C-exported function name. <code>library</code> refers to the shared library name: shared libraries available in the (platform-specific) load path will be resolved by name, and if necessary a direct path may be specified.</p><p>A function name may be used alone in place of the tuple (just <code>:function</code> or <code>&quot;function&quot;</code>). In this case the name is resolved within the current process. This form can be used to call C library functions, functions in the Julia runtime, or functions in an application linked to Julia.</p><p>By default, Fortran compilers <a href=\"https://en.wikipedia.org/wiki/Name_mangling#Fortran\">generate mangled names</a> (for example, converting function names to lowercase or uppercase, often appending an underscore), and so to call a Fortran function via <a href=\"../base/c.html#ccall\"><code>ccall</code></a> you must pass the mangled identifier corresponding to the rule followed by your Fortran compiler.  Also, when calling a Fortran function, all inputs must be passed as pointers to allocated values on the heap or stack. This applies not only to arrays and other mutable objects which are normally heap-allocated, but also to scalar values such as integers and floats which are normally stack-allocated and commonly passed in registers when using C or Julia calling conventions.</p><p>Finally, you can use <a href=\"../base/c.html#ccall\"><code>ccall</code></a> to actually generate a call to the library function. Arguments to <a href=\"../base/c.html#ccall\"><code>ccall</code></a> are as follows:</p><ol><li><p>A <code>(:function, &quot;library&quot;)</code> pair, which must be written as a literal constant,</p><p>OR</p><p>a function pointer (for example, from <code>dlsym</code>).</p></li><li><p>Return type (see below for mapping the declared C type to Julia)</p><ul><li>This argument will be evaluated at compile-time, when the containing method is defined.</li></ul></li><li><p>A tuple of input types. The input types must be written as a literal tuple, not a tuple-valued variable or expression.</p><ul><li>This argument will be evaluated at compile-time, when the containing method is defined.</li></ul></li><li><p>The following arguments, if any, are the actual argument values passed to the function.</p></li></ol><p>As a complete but simple example, the following calls the <code>clock</code> function from the standard C library:</p><pre><code class=\"language-julia-repl\">julia&gt; t = ccall((:clock, &quot;libc&quot;), Int32, ())\n2292761\n\njulia&gt; t\n2292761\n\njulia&gt; typeof(ans)\nInt32</code></pre><p><code>clock</code> takes no arguments and returns an <a href=\"../base/numbers.html#Core.Int32\"><code>Int32</code></a>. One common gotcha is that a 1-tuple must be written with a trailing comma. For example, to call the <code>getenv</code> function to get a pointer to the value of an environment variable, one makes a call like this:</p><pre><code class=\"language-julia-repl\">julia&gt; path = ccall((:getenv, &quot;libc&quot;), Cstring, (Cstring,), &quot;SHELL&quot;)\nCstring(@0x00007fff5fbffc45)\n\njulia&gt; unsafe_string(path)\n&quot;/bin/bash&quot;</code></pre><p>Note that the argument type tuple must be written as <code>(Cstring,)</code>, rather than <code>(Cstring)</code>. This is because <code>(Cstring)</code> is just the expression <code>Cstring</code> surrounded by parentheses, rather than a 1-tuple containing <code>Cstring</code>:</p><pre><code class=\"language-julia-repl\">julia&gt; (Cstring)\nCstring\n\njulia&gt; (Cstring,)\n(Cstring,)</code></pre><p>In practice, especially when providing reusable functionality, one generally wraps <a href=\"../base/c.html#ccall\"><code>ccall</code></a> uses in Julia functions that set up arguments and then check for errors in whatever manner the C or Fortran function indicates them, propagating to the Julia caller as exceptions. This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. For example, the <code>getenv</code> C library function is wrapped in the following Julia function, which is a simplified version of the actual definition from <a href=\"https://github.com/JuliaLang/julia/blob/master/base/env.jl\"><code>env.jl</code></a>:</p><pre><code class=\"language-julia\">function getenv(var::AbstractString)\n    val = ccall((:getenv, &quot;libc&quot;),\n                Cstring, (Cstring,), var)\n    if val == C_NULL\n        error(&quot;getenv: undefined variable: &quot;, var)\n    end\n    unsafe_string(val)\nend</code></pre><p>The C <code>getenv</code> function indicates an error by returning <code>NULL</code>, but other standard C functions indicate errors in various different ways, including by returning -1, 0, 1 and other special values. This wrapper throws an exception clearly indicating the problem if the caller tries to get a non-existent environment variable:</p><pre><code class=\"language-julia-repl\">julia&gt; getenv(&quot;SHELL&quot;)\n&quot;/bin/bash&quot;\n\njulia&gt; getenv(&quot;FOOBAR&quot;)\ngetenv: undefined variable: FOOBAR</code></pre><p>Here is a slightly more complex example that discovers the local machine&#39;s hostname:</p><pre><code class=\"language-julia\">function gethostname()\n    hostname = Vector{UInt8}(128)\n    ccall((:gethostname, &quot;libc&quot;), Int32,\n          (Ptr{UInt8}, Csize_t),\n          hostname, sizeof(hostname))\n    hostname[end] = 0; # ensure null-termination\n    return unsafe_string(pointer(hostname))\nend</code></pre><p>This example first allocates an array of bytes, then calls the C library function <code>gethostname</code> to fill the array in with the hostname, takes a pointer to the hostname buffer, and converts the pointer to a Julia string, assuming that it is a NUL-terminated C string. It is common for C libraries to use this pattern of requiring the caller to allocate memory to be passed to the callee and filled in. Allocation of memory from Julia like this is generally accomplished by creating an uninitialized array and passing a pointer to its data to the C function. This is why we don&#39;t use the <code>Cstring</code> type here: as the array is uninitialized, it could contain NUL bytes. Converting to a <code>Cstring</code> as part of the <a href=\"../base/c.html#ccall\"><code>ccall</code></a> checks for contained NUL bytes and could therefore throw a conversion error.</p><h2><a class=\"nav-anchor\" id=\"Creating-C-Compatible-Julia-Function-Pointers-1\" href=\"#Creating-C-Compatible-Julia-Function-Pointers-1\">Creating C-Compatible Julia Function Pointers</a></h2><p>It is possible to pass Julia functions to native C functions that accept function pointer arguments. For example, to match C prototypes of the form:</p><pre><code class=\"language-c\">typedef returntype (*functiontype)(argumenttype, ...)</code></pre><p>The macro <a href=\"../base/c.html#Base.@cfunction\"><code>@cfunction</code></a> generates the C-compatible function pointer for a call to a Julia function. Arguments to <a href=\"../base/c.html#Base.@cfunction\"><code>@cfunction</code></a> are as follows:</p><ol><li>A Julia Function</li><li>Return type</li><li>A literal tuple of input types</li></ol><p>Like ccall, all of these arguments will be evaluated at compile-time, when the containing method is defined.</p><p>Currently, only the platform-default C calling convention is supported. This means that <code>@cfunction</code>-generated pointers cannot be used in calls where WINAPI expects <code>stdcall</code> function on 32-bit windows, but can be used on WIN64 (where <code>stdcall</code> is unified with the C calling convention).</p><p>A classic example is the standard C library <code>qsort</code> function, declared as:</p><pre><code class=\"language-c\">void qsort(void *base, size_t nmemb, size_t size,\n           int (*compare)(const void*, const void*));</code></pre><p>The <code>base</code> argument is a pointer to an array of length <code>nmemb</code>, with elements of <code>size</code> bytes each. <code>compare</code> is a callback function which takes pointers to two elements <code>a</code> and <code>b</code> and returns an integer less/greater than zero if <code>a</code> should appear before/after <code>b</code> (or zero if any order is permitted). Now, suppose that we have a 1d array <code>A</code> of values in Julia that we want to sort using the <code>qsort</code> function (rather than Julia&#39;s built-in <code>sort</code> function). Before we worry about calling <code>qsort</code> and passing arguments, we need to write a comparison function that works for some arbitrary objects (which define <code>&lt;</code>):</p><pre><code class=\"language-julia-repl\">julia&gt; function mycompare(a, b)::Cint\n           return (a &lt; b) ? -1 : ((a &gt; b) ? +1 : 0)\n       end\nmycompare (generic function with 1 method)</code></pre><p>Notice that we have to be careful about the return type: <code>qsort</code> expects a function returning a C <code>int</code>, so we annotate the return type of the function to be sure it returns a <code>Cint</code>.</p><p>In order to pass this function to C, we obtain its address using the macro <code>@cfunction</code>:</p><pre><code class=\"language-julia-repl\">julia&gt; mycompare_c = @cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));</code></pre><p><a href=\"../base/c.html#Base.@cfunction\"><code>@cfunction</code></a> requires three arguments: the Julia function (<code>mycompare</code>), the return type (<code>Cint</code>), and a literal tuple of the input argument types, in this case to sort an array of <code>Cdouble</code> (<a href=\"../base/numbers.html#Core.Float64\"><code>Float64</code></a>) elements.</p><p>The final call to <code>qsort</code> looks like this:</p><pre><code class=\"language-julia-repl\">julia&gt; A = [1.3, -2.7, 4.4, 3.1]\n4-element Array{Float64,1}:\n  1.3\n -2.7\n  4.4\n  3.1\n\njulia&gt; ccall(:qsort, Cvoid, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Cvoid}),\n             A, length(A), sizeof(eltype(A)), mycompare_c)\n\njulia&gt; A\n4-element Array{Float64,1}:\n -2.7\n  1.3\n  3.1\n  4.4</code></pre><p>As can be seen, <code>A</code> is changed to the sorted array <code>[-2.7, 1.3, 3.1, 4.4]</code>. Note that Julia knows how to convert an array into a <code>Ptr{Cdouble}</code>, how to compute the size of a type in bytes (identical to C&#39;s <code>sizeof</code> operator), and so on. For fun, try inserting a <code>println(&quot;mycompare($a, $b)&quot;)</code> line into <code>mycompare</code>, which will allow you to see the comparisons that <code>qsort</code> is performing (and to verify that it is really calling the Julia function that you passed to it).</p><h2><a class=\"nav-anchor\" id=\"Mapping-C-Types-to-Julia-1\" href=\"#Mapping-C-Types-to-Julia-1\">Mapping C Types to Julia</a></h2><p>It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies can cause code that works correctly on one system to fail or produce indeterminate results on a different system.</p><p>Note that no C header files are used anywhere in the process of calling C functions: you are responsible for making sure that your Julia types and call signatures accurately reflect those in the C header file. (The <a href=\"https://github.com/ihnorton/Clang.jl\">Clang package</a> can be used to auto-generate Julia code from a C header file.)</p><h3><a class=\"nav-anchor\" id=\"Auto-conversion:-1\" href=\"#Auto-conversion:-1\">Auto-conversion:</a></h3><p>Julia automatically inserts calls to the <a href=\"../base/c.html#Base.cconvert\"><code>Base.cconvert</code></a> function to convert each argument to the specified type. For example, the following call:</p><pre><code class=\"language-julia\">ccall((:foo, &quot;libfoo&quot;), Cvoid, (Int32, Float64), x, y)</code></pre><p>will behave as if the following were written:</p><pre><code class=\"language-julia\">ccall((:foo, &quot;libfoo&quot;), Cvoid, (Int32, Float64),\n      Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),\n      Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))</code></pre><p><a href=\"../base/c.html#Base.cconvert\"><code>Base.cconvert</code></a> normally just calls <a href=\"../base/base.html#Base.convert\"><code>convert</code></a>, but can be defined to return an arbitrary new object more appropriate for passing to C. This should be used to perform all allocations of memory that will be accessed by the C code. For example, this is used to convert an <code>Array</code> of objects (e.g. strings) to an array of pointers.</p><p><a href=\"../base/c.html#Base.unsafe_convert\"><code>Base.unsafe_convert</code></a> handles conversion to <a href=\"../base/c.html#Core.Ptr\"><code>Ptr</code></a> types. It is considered unsafe because converting an object to a native pointer can hide the object from the garbage collector, causing it to be freed prematurely.</p><h3><a class=\"nav-anchor\" id=\"Type-Correspondences:-1\" href=\"#Type-Correspondences:-1\">Type Correspondences:</a></h3><p>First, a review of some relevant Julia type terminology:</p><table><tr><th>Syntax / Keyword</th><th>Example</th><th>Description</th></tr><tr><td><code>mutable struct</code></td><td><code>String</code></td><td>&quot;Leaf Type&quot; :: A group of related data that includes a type-tag, is managed by the Julia GC, and is defined by object-identity. The type parameters of a leaf type must be fully defined (no <code>TypeVars</code> are allowed) in order for the instance to be constructed.</td></tr><tr><td><code>abstract type</code></td><td><code>Any</code>, <code>AbstractArray{T, N}</code>, <code>Complex{T}</code></td><td>&quot;Super Type&quot; :: A super-type (not a leaf-type) that cannot be instantiated, but can be used to describe a group of types.</td></tr><tr><td><code>T{A}</code></td><td><code>Vector{Int}</code></td><td>&quot;Type Parameter&quot; :: A specialization of a type (typically used for dispatch or storage optimization).</td></tr><tr><td></td><td></td><td>&quot;TypeVar&quot; :: The <code>T</code> in the type parameter declaration is referred to as a TypeVar (short for type variable).</td></tr><tr><td><code>primitive type</code></td><td><code>Int</code>, <code>Float64</code></td><td>&quot;Primitive Type&quot; :: A type with no fields, but a size. It is stored and defined by-value.</td></tr><tr><td><code>struct</code></td><td><code>Pair{Int, Int}</code></td><td>&quot;Struct&quot; :: A type with all fields defined to be constant. It is defined by-value, and may be stored with a type-tag.</td></tr><tr><td></td><td><code>ComplexF64</code> (<code>isbits</code>)</td><td>&quot;Is-Bits&quot;   :: A <code>primitive type</code>, or a <code>struct</code> type where all fields are other <code>isbits</code> types. It is defined by-value, and is stored without a type-tag.</td></tr><tr><td><code>struct ...; end</code></td><td><code>nothing</code></td><td>&quot;Singleton&quot; :: a Leaf Type or Struct with no fields.</td></tr><tr><td><code>(...)</code> or <code>tuple(...)</code></td><td><code>(1, 2, 3)</code></td><td>&quot;Tuple&quot; :: an immutable data-structure similar to an anonymous struct type, or a constant array. Represented as either an array or a struct.</td></tr></table><h3><a class=\"nav-anchor\" id=\"man-bits-types-1\" href=\"#man-bits-types-1\">Bits Types</a></h3><p>There are several special types to be aware of, as no other type can be defined to behave the same:</p><ul><li><p><code>Float32</code></p><p>Exactly corresponds to the <code>float</code> type in C (or <code>REAL*4</code> in Fortran).</p></li><li><p><code>Float64</code></p><p>Exactly corresponds to the <code>double</code> type in C (or <code>REAL*8</code> in Fortran).</p></li><li><p><code>ComplexF32</code></p><p>Exactly corresponds to the <code>complex float</code> type in C (or <code>COMPLEX*8</code> in Fortran).</p></li><li><p><code>ComplexF64</code></p><p>Exactly corresponds to the <code>complex double</code> type in C (or <code>COMPLEX*16</code> in Fortran).</p></li><li><p><code>Signed</code></p><p>Exactly corresponds to the <code>signed</code> type annotation in C (or any <code>INTEGER</code> type in Fortran). Any Julia type that is not a subtype of <a href=\"../base/numbers.html#Core.Signed\"><code>Signed</code></a> is assumed to be unsigned.</p></li></ul><ul><li><p><code>Ref{T}</code></p><p>Behaves like a <code>Ptr{T}</code> that can manage its memory via the Julia GC.</p></li></ul><ul><li><p><code>Array{T,N}</code></p><p>When an array is passed to C as a <code>Ptr{T}</code> argument, it is not reinterpret-cast: Julia requires that the element type of the array matches <code>T</code>, and the address of the first element is passed.</p><p>Therefore, if an <code>Array</code> contains data in the wrong format, it will have to be explicitly converted using a call such as <code>trunc(Int32, a)</code>.</p><p>To pass an array <code>A</code> as a pointer of a different type <em>without</em> converting the data beforehand (for example, to pass a <code>Float64</code> array to a function that operates on uninterpreted bytes), you can declare the argument as <code>Ptr{Cvoid}</code>.</p><p>If an array of eltype <code>Ptr{T}</code> is passed as a <code>Ptr{Ptr{T}}</code> argument, <a href=\"../base/c.html#Base.cconvert\"><code>Base.cconvert</code></a> will attempt to first make a null-terminated copy of the array with each element replaced by its <a href=\"../base/c.html#Base.cconvert\"><code>Base.cconvert</code></a> version. This allows, for example, passing an <code>argv</code> pointer array of type <code>Vector{String}</code> to an argument of type <code>Ptr{Ptr{Cchar}}</code>.</p></li></ul><p>On all systems we currently support, basic C/C++ value types may be translated to Julia types as follows. Every C type also has a corresponding Julia type with the same name, prefixed by C. This can help for writing portable code (and remembering that an <code>int</code> in C is not the same as an <code>Int</code> in Julia).</p><p><strong>System Independent:</strong></p><table><tr><th>C name</th><th>Fortran name</th><th>Standard Julia Alias</th><th>Julia Base Type</th></tr><tr><td><code>unsigned char</code></td><td><code>CHARACTER</code></td><td><code>Cuchar</code></td><td><code>UInt8</code></td></tr><tr><td><code>bool</code> (only in C++)</td><td></td><td><code>Cuchar</code></td><td><code>UInt8</code></td></tr><tr><td><code>short</code></td><td><code>INTEGER*2</code>, <code>LOGICAL*2</code></td><td><code>Cshort</code></td><td><code>Int16</code></td></tr><tr><td><code>unsigned short</code></td><td></td><td><code>Cushort</code></td><td><code>UInt16</code></td></tr><tr><td><code>int</code>, <code>BOOL</code> (C, typical)</td><td><code>INTEGER*4</code>, <code>LOGICAL*4</code></td><td><code>Cint</code></td><td><code>Int32</code></td></tr><tr><td><code>unsigned int</code></td><td></td><td><code>Cuint</code></td><td><code>UInt32</code></td></tr><tr><td><code>long long</code></td><td><code>INTEGER*8</code>, <code>LOGICAL*8</code></td><td><code>Clonglong</code></td><td><code>Int64</code></td></tr><tr><td><code>unsigned long long</code></td><td></td><td><code>Culonglong</code></td><td><code>UInt64</code></td></tr><tr><td><code>intmax_t</code></td><td></td><td><code>Cintmax_t</code></td><td><code>Int64</code></td></tr><tr><td><code>uintmax_t</code></td><td></td><td><code>Cuintmax_t</code></td><td><code>UInt64</code></td></tr><tr><td><code>float</code></td><td><code>REAL*4i</code></td><td><code>Cfloat</code></td><td><code>Float32</code></td></tr><tr><td><code>double</code></td><td><code>REAL*8</code></td><td><code>Cdouble</code></td><td><code>Float64</code></td></tr><tr><td><code>complex float</code></td><td><code>COMPLEX*8</code></td><td><code>ComplexF32</code></td><td><code>Complex{Float32}</code></td></tr><tr><td><code>complex double</code></td><td><code>COMPLEX*16</code></td><td><code>ComplexF64</code></td><td><code>Complex{Float64}</code></td></tr><tr><td><code>ptrdiff_t</code></td><td></td><td><code>Cptrdiff_t</code></td><td><code>Int</code></td></tr><tr><td><code>ssize_t</code></td><td></td><td><code>Cssize_t</code></td><td><code>Int</code></td></tr><tr><td><code>size_t</code></td><td></td><td><code>Csize_t</code></td><td><code>UInt</code></td></tr><tr><td><code>void</code></td><td></td><td></td><td><code>Cvoid</code></td></tr><tr><td><code>void</code> and <code>[[noreturn]]</code> or <code>_Noreturn</code></td><td></td><td></td><td><code>Union{}</code></td></tr><tr><td><code>void*</code></td><td></td><td></td><td><code>Ptr{Cvoid}</code></td></tr><tr><td><code>T*</code> (where T represents an appropriately defined type)</td><td></td><td></td><td><code>Ref{T}</code></td></tr><tr><td><code>char*</code> (or <code>char[]</code>, e.g. a string)</td><td><code>CHARACTER*N</code></td><td></td><td><code>Cstring</code> if NUL-terminated, or <code>Ptr{UInt8}</code> if not</td></tr><tr><td><code>char**</code> (or <code>*char[]</code>)</td><td></td><td></td><td><code>Ptr{Ptr{UInt8}}</code></td></tr><tr><td><code>jl_value_t*</code> (any Julia Type)</td><td></td><td></td><td><code>Any</code></td></tr><tr><td><code>jl_value_t**</code> (a reference to a Julia Type)</td><td></td><td></td><td><code>Ref{Any}</code></td></tr><tr><td><code>va_arg</code></td><td></td><td></td><td>Not supported</td></tr><tr><td><code>...</code> (variadic function specification)</td><td></td><td></td><td><code>T...</code> (where <code>T</code> is one of the above types, variadic functions of different argument types are not supported)</td></tr></table><p>The <a href=\"../base/c.html#Base.Cstring\"><code>Cstring</code></a> type is essentially a synonym for <code>Ptr{UInt8}</code>, except the conversion to <code>Cstring</code> throws an error if the Julia string contains any embedded NUL characters (which would cause the string to be silently truncated if the C routine treats NUL as the terminator).  If you are passing a <code>char*</code> to a C routine that does not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that your Julia string does not contain NUL and want to skip the check, you can use <code>Ptr{UInt8}</code> as the argument type. <code>Cstring</code> can also be used as the <a href=\"../base/c.html#ccall\"><code>ccall</code></a> return type, but in that case it obviously does not introduce any extra checks and is only meant to improve readability of the call.</p><p><strong>System-dependent:</strong></p><table><tr><th>C name</th><th>Standard Julia Alias</th><th>Julia Base Type</th></tr><tr><td><code>char</code></td><td><code>Cchar</code></td><td><code>Int8</code> (x86, x86_64), <code>UInt8</code> (powerpc, arm)</td></tr><tr><td><code>long</code></td><td><code>Clong</code></td><td><code>Int</code> (UNIX), <code>Int32</code> (Windows)</td></tr><tr><td><code>unsigned long</code></td><td><code>Culong</code></td><td><code>UInt</code> (UNIX), <code>UInt32</code> (Windows)</td></tr><tr><td><code>wchar_t</code></td><td><code>Cwchar_t</code></td><td><code>Int32</code> (UNIX), <code>UInt16</code> (Windows)</td></tr></table><div class=\"admonition note\"><div class=\"admonition-title\">Note</div><div class=\"admonition-text\"><p>When calling Fortran, all inputs must be passed by pointers to heap- or stack-allocated values, so all type correspondences above should contain an additional <code>Ptr{..}</code> or <code>Ref{..}</code> wrapper around their type specification.</p></div></div><div class=\"admonition warning\"><div class=\"admonition-title\">Warning</div><div class=\"admonition-text\"><p>For string arguments (<code>char*</code>) the Julia type should be <code>Cstring</code> (if NUL- terminated data is expected) or either <code>Ptr{Cchar}</code> or <code>Ptr{UInt8}</code> otherwise (these two pointer types have the same effect), as described above, not <code>String</code>. Similarly, for array arguments (<code>T[]</code> or <code>T*</code>), the Julia type should again be <code>Ptr{T}</code>, not <code>Vector{T}</code>.</p></div></div><div class=\"admonition warning\"><div class=\"admonition-title\">Warning</div><div class=\"admonition-text\"><p>Julia&#39;s <code>Char</code> type is 32 bits, which is not the same as the wide character type (<code>wchar_t</code> or <code>wint_t</code>) on all platforms.</p></div></div><div class=\"admonition warning\"><div class=\"admonition-title\">Warning</div><div class=\"admonition-text\"><p>A return type of <code>Union{}</code> means the function will not return i.e. C++11 <code>[[noreturn]]</code> or C11 <code>_Noreturn</code> (e.g. <code>jl_throw</code> or <code>longjmp</code>). Do not use this for functions that return no value (<code>void</code>) but do return, use <code>Cvoid</code> instead.</p></div></div><div class=\"admonition note\"><div class=\"admonition-title\">Note</div><div class=\"admonition-text\"><p>For <code>wchar_t*</code> arguments, the Julia type should be <a href=\"../base/c.html#Base.Cwstring\"><code>Cwstring</code></a> (if the C routine expects a NUL-terminated string) or <code>Ptr{Cwchar_t}</code> otherwise. Note also that UTF-8 string data in Julia is internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making a copy (but using the <code>Cwstring</code> type will cause an error to be thrown if the string itself contains NUL characters).</p></div></div><div class=\"admonition note\"><div class=\"admonition-title\">Note</div><div class=\"admonition-text\"><p>C functions that take an argument of the type <code>char**</code> can be called by using a <code>Ptr{Ptr{UInt8}}</code> type within Julia. For example, C functions of the form:</p><pre><code class=\"language-c\">int main(int argc, char **argv);</code></pre><p>can be called via the following Julia code:</p><pre><code class=\"language-julia\">argv = [ &quot;a.out&quot;, &quot;arg1&quot;, &quot;arg2&quot; ]\nccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)</code></pre></div></div><div class=\"admonition note\"><div class=\"admonition-title\">Note</div><div class=\"admonition-text\"><p>For Fortran functions taking variable length strings of type <code>character(len=*)</code> the string lengths are provided as <em>hidden arguments</em>. Type and position of these arguments in the list are compiler specific, where compiler vendors usually default to using <code>Csize_t</code> as type and append the hidden arguments at the end of the argument list. While this behaviour is fixed for some compilers (GNU), others <em>optionally</em> permit placing hidden arguments directly after the character argument (Intel,PGI). For example, Fortran subroutines of the form</p><pre><code class=\"language-fortran\">subroutine test(str1, str2)\ncharacter(len=*) :: str1,str2</code></pre><p>can be called via the following Julia code, where the lengths are appended</p><pre><code class=\"language-julia\">str1 = &quot;foo&quot;\nstr2 = &quot;bar&quot;\nccall(:test, Void, (Ptr{UInt8}, Ptr{UInt8}, Csize_t, Csize_t),\n                    str1, str2, sizeof(str1), sizeof(str2))</code></pre></div></div><div class=\"admonition warning\"><div class=\"admonition-title\">Warning</div><div class=\"admonition-text\"><p>Fortran compilers <em>may</em> also add other hidden arguments for pointers, assumed-shape (<code>:</code>) and assumed-size (<code>*</code>) arrays. Such behaviour can be avoided by using <code>ISO_C_BINDING</code> and including <code>bind(c)</code> in the definition of the subroutine, which is strongly recommended for interoperable code. In this case there will be no hidden arguments, at the cost of some language features (e.g. only <code>character(len=1)</code> will be permitted to pass strings).</p></div></div><div class=\"admonition note\"><div class=\"admonition-title\">Note</div><div class=\"admonition-text\"><p>A C function declared to return <code>Cvoid</code> will return the value <code>nothing</code> in Julia.</p></div></div><h3><a class=\"nav-anchor\" id=\"Struct-Type-correspondences-1\" href=\"#Struct-Type-correspondences-1\">Struct Type correspondences</a></h3><p>Composite types, aka <code>struct</code> in C or <code>TYPE</code> in Fortran90 (or <code>STRUCTURE</code> / <code>RECORD</code> in some variants of F77), can be mirrored in Julia by creating a <code>struct</code> definition with the same field layout.</p><p>When used recursively, <code>isbits</code> types are stored inline. All other types are stored as a pointer to the data. When mirroring a struct used by-value inside another struct in C, it is imperative that you do not attempt to manually copy the fields over, as this will not preserve the correct field alignment. Instead, declare an <code>isbits</code> struct type and use that instead. Unnamed structs are not possible in the translation to Julia.</p><p>Packed structs and union declarations are not supported by Julia.</p><p>You can get a near approximation of a <code>union</code> if you know, a priori, the field that will have the greatest size (potentially including padding). When translating your fields to Julia, declare the Julia field to be only of that type.</p><p>Arrays of parameters can be expressed with <code>NTuple</code>:</p><pre><code class=\"language-none\">in C:\nstruct B {\n    int A[3];\n};\nb_a_2 = B.A[2];\n\nin Julia:\nstruct B\n    A::NTuple{3, CInt}\nend\nb_a_2 = B.A[3]  # note the difference in indexing (1-based in Julia, 0-based in C)</code></pre><p>Arrays of unknown size (C99-compliant variable length structs specified by <code>[]</code> or <code>[0]</code>) are not directly supported. Often the best way to deal with these is to deal with the byte offsets directly. For example, if a C library declared a proper string type and returned a pointer to it:</p><pre><code class=\"language-c\">struct String {\n    int strlen;\n    char data[];\n};</code></pre><p>In Julia, we can access the parts independently to make a copy of that string:</p><pre><code class=\"language-julia\">str = from_c::Ptr{Cvoid}\nlen = unsafe_load(Ptr{Cint}(str))\nunsafe_string(str + Core.sizeof(Cint), len)</code></pre><h3><a class=\"nav-anchor\" id=\"Type-Parameters-1\" href=\"#Type-Parameters-1\">Type Parameters</a></h3><p>The type arguments to <code>ccall</code> and <code>@cfunction</code> are evaluated statically, when the method containing the usage is defined. They therefore must take the form of a literal tuple, not a variable, and cannot reference local variables.</p><p>This may sound like a strange restriction, but remember that since C is not a dynamic language like Julia, its functions can only accept argument types with a statically-known, fixed signature.</p><p>However, while the type layout must be known statically to compute the intended C ABI, the static parameters of the function are considered to be part of this static environment. The static parameters of the function may be used as type parameters in the call signature, as long as they don&#39;t affect the layout of the type. For example, <code>f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)</code> is valid, since <code>Ptr</code> is always a word-size primitive type. But, <code>g(x::T) where {T} = ccall(:notvalid, T, (T,), x)</code> is not valid, since the type layout of <code>T</code> is not known statically.</p><h3><a class=\"nav-anchor\" id=\"SIMD-Values-1\" href=\"#SIMD-Values-1\">SIMD Values</a></h3><p>Note: This feature is currently implemented on 64-bit x86 and AArch64 platforms only.</p><p>If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of <code>VecElement</code> that naturally maps to the SIMD type.  Specifically:</p><blockquote><ul><li>The tuple must be the same size as the SIMD type. For example, a tuple representing an <code>__m128</code> on x86 must have a size of 16 bytes.</li><li>The element type of the tuple must be an instance of <code>VecElement{T}</code> where <code>T</code> is a primitive type that is 1, 2, 4 or 8 bytes.</li></ul></blockquote><p>For instance, consider this C routine that uses AVX intrinsics:</p><pre><code class=\"language-c\">#include &lt;immintrin.h&gt;\n\n__m256 dist( __m256 a, __m256 b ) {\n    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),\n                                        _mm256_mul_ps(b, b)));\n}</code></pre><p>The following Julia code calls <code>dist</code> using <code>ccall</code>:</p><pre><code class=\"language-julia\">const m256 = NTuple{8, VecElement{Float32}}\n\na = m256(ntuple(i -&gt; VecElement(sin(Float32(i))), 8))\nb = m256(ntuple(i -&gt; VecElement(cos(Float32(i))), 8))\n\nfunction call_dist(a::m256, b::m256)\n    ccall((:dist, &quot;libdist&quot;), m256, (m256, m256), a, b)\nend\n\nprintln(call_dist(a,b))</code></pre><p>The host machine must have the requisite SIMD registers.  For example, the code above will not work on hosts without AVX support.</p><h3><a class=\"nav-anchor\" id=\"Memory-Ownership-1\" href=\"#Memory-Ownership-1\">Memory Ownership</a></h3><p><strong>malloc/free</strong></p><p>Memory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, just like in any C program. Do not try to free an object received from a C library with <a href=\"../base/libc.html#Base.Libc.free\"><code>Libc.free</code></a> in Julia, as this may result in the <code>free</code> function being called via the wrong <code>libc</code> library and cause Julia to crash. The reverse (passing an object allocated in Julia to be freed by an external library) is equally invalid.</p><h3><a class=\"nav-anchor\" id=\"When-to-use-T,-Ptr{T}-and-Ref{T}-1\" href=\"#When-to-use-T,-Ptr{T}-and-Ref{T}-1\">When to use T, Ptr{T} and Ref{T}</a></h3><p>In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type <code>T</code> inside the <a href=\"../base/c.html#ccall\"><code>ccall</code></a>, as they are passed by value.  For C code accepting pointers, <a href=\"../base/c.html#Core.Ref\"><code>Ref{T}</code></a> should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to <a href=\"../base/c.html#Base.cconvert\"><code>Base.cconvert</code></a>.  In contrast, pointers returned by the C function called should be declared to be of output type <a href=\"../base/c.html#Core.Ptr\"><code>Ptr{T}</code></a>, reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type <code>Ptr{T}</code> within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.</p><p>In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type <code>Ref{T}</code>, as Fortran passes all variables by pointers to memory locations. The return type should either be <code>Cvoid</code> for Fortran subroutines, or a <code>T</code> for Fortran functions returning the type <code>T</code>.</p><h2><a class=\"nav-anchor\" id=\"Mapping-C-Functions-to-Julia-1\" href=\"#Mapping-C-Functions-to-Julia-1\">Mapping C Functions to Julia</a></h2><h3><a class=\"nav-anchor\" id=\"ccall-/-@cfunction-argument-translation-guide-1\" href=\"#ccall-/-@cfunction-argument-translation-guide-1\"><code>ccall</code> / <code>@cfunction</code> argument translation guide</a></h3><p>For translating a C argument list to Julia:</p><ul><li><p><code>T</code>, where <code>T</code> is one of the primitive types: <code>char</code>, <code>int</code>, <code>long</code>, <code>short</code>, <code>float</code>, <code>double</code>, <code>complex</code>, <code>enum</code> or any of their <code>typedef</code> equivalents</p><ul><li><code>T</code>, where <code>T</code> is an equivalent Julia Bits Type (per the table above)</li><li>if <code>T</code> is an <code>enum</code>, the argument type should be equivalent to <code>Cint</code> or <code>Cuint</code></li><li>argument value will be copied (passed by value)</li></ul></li><li><p><code>struct T</code> (including typedef to a struct)</p><ul><li><code>T</code>, where <code>T</code> is a Julia leaf type</li><li>argument value will be copied (passed by value)</li></ul></li><li><p><code>void*</code></p><ul><li>depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list</li><li>this argument may be declared as <code>Ptr{Cvoid}</code>, if it really is just an unknown pointer</li></ul></li><li><p><code>jl_value_t*</code></p><ul><li><code>Any</code></li><li>argument value must be a valid Julia object</li></ul></li><li><p><code>jl_value_t**</code></p><ul><li><code>Ref{Any}</code></li><li>argument value must be a valid Julia object (or <code>C_NULL</code>)</li></ul></li><li><p><code>T*</code></p><ul><li><code>Ref{T}</code>, where <code>T</code> is the Julia type corresponding to <code>T</code></li><li>argument value will be copied if it is an <code>isbits</code> type otherwise, the value must be a valid Julia object</li></ul></li><li><p><code>T (*)(...)</code> (e.g. a pointer to a function)</p><ul><li><code>Ptr{Cvoid}</code> (you may need to use <a href=\"../base/c.html#Base.@cfunction\"><code>@cfunction</code></a> explicitly to create this pointer)</li></ul></li><li><p><code>...</code> (e.g. a vararg)</p><ul><li><code>T...</code>, where <code>T</code> is the Julia type</li><li>currently unsupported by <code>@cfunction</code></li></ul></li><li><p><code>va_arg</code></p><ul><li>not supported by <code>ccall</code> or <code>@cfunction</code></li></ul></li></ul><h3><a class=\"nav-anchor\" id=\"ccall-/-@cfunction-return-type-translation-guide-1\" href=\"#ccall-/-@cfunction-return-type-translation-guide-1\"><code>ccall</code> / <code>@cfunction</code> return type translation guide</a></h3><p>For translating a C return type to Julia:</p><ul><li><p><code>void</code></p><ul><li><code>Cvoid</code> (this will return the singleton instance <code>nothing::Cvoid</code>)</li></ul></li><li><p><code>T</code>, where <code>T</code> is one of the primitive types: <code>char</code>, <code>int</code>, <code>long</code>, <code>short</code>, <code>float</code>, <code>double</code>, <code>complex</code>, <code>enum</code> or any of their <code>typedef</code> equivalents</p><ul><li><code>T</code>, where <code>T</code> is an equivalent Julia Bits Type (per the table above)</li><li>if <code>T</code> is an <code>enum</code>, the argument type should be equivalent to <code>Cint</code> or <code>Cuint</code></li><li>argument value will be copied (returned by-value)</li></ul></li><li><p><code>struct T</code> (including typedef to a struct)</p><ul><li><code>T</code>, where <code>T</code> is a Julia Leaf Type</li><li>argument value will be copied (returned by-value)</li></ul></li><li><p><code>void*</code></p><ul><li>depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list</li><li>this argument may be declared as <code>Ptr{Cvoid}</code>, if it really is just an unknown pointer</li></ul></li><li><p><code>jl_value_t*</code></p><ul><li><code>Any</code></li><li>argument value must be a valid Julia object</li></ul></li><li><p><code>jl_value_t**</code></p><ul><li><code>Ptr{Any}</code> (<code>Ref{Any}</code> is invalid as a return type)</li><li>argument value must be a valid Julia object (or <code>C_NULL</code>)</li></ul></li><li><p><code>T*</code></p><ul><li><p>If the memory is already owned by Julia, or is an <code>isbits</code> type, and is known to be non-null:</p><ul><li><code>Ref{T}</code>, where <code>T</code> is the Julia type corresponding to <code>T</code></li><li>a return type of <code>Ref{Any}</code> is invalid, it should either be <code>Any</code> (corresponding to <code>jl_value_t*</code>) or <code>Ptr{Any}</code> (corresponding to <code>jl_value_t**</code>)</li><li>C <strong>MUST NOT</strong> modify the memory returned via <code>Ref{T}</code> if <code>T</code> is an <code>isbits</code> type</li></ul></li><li><p>If the memory is owned by C:</p><ul><li><code>Ptr{T}</code>, where <code>T</code> is the Julia type corresponding to <code>T</code></li></ul></li></ul></li><li><p><code>T (*)(...)</code> (e.g. a pointer to a function)</p><ul><li><code>Ptr{Cvoid}</code> (you may need to use <a href=\"../base/c.html#Base.@cfunction\"><code>@cfunction</code></a> explicitly to create this pointer)</li></ul></li></ul><h3><a class=\"nav-anchor\" id=\"Passing-Pointers-for-Modifying-Inputs-1\" href=\"#Passing-Pointers-for-Modifying-Inputs-1\">Passing Pointers for Modifying Inputs</a></h3><p>Because C doesn&#39;t support multiple return values, often C functions will take pointers to data that the function will modify. To accomplish this within a <a href=\"../base/c.html#ccall\"><code>ccall</code></a>, you need to first encapsulate the value inside a <a href=\"../base/c.html#Core.Ref\"><code>Ref{T}</code></a> of the appropriate type. When you pass this <code>Ref</code> object as an argument, Julia will automatically pass a C pointer to the encapsulated data:</p><pre><code class=\"language-julia\">width = Ref{Cint}(0)\nrange = Ref{Cfloat}(0)\nccall(:foo, Cvoid, (Ref{Cint}, Ref{Cfloat}), width, range)</code></pre><p>Upon return, the contents of <code>width</code> and <code>range</code> can be retrieved (if they were changed by <code>foo</code>) by <code>width[]</code> and <code>range[]</code>; that is, they act like zero-dimensional arrays.</p><h3><a class=\"nav-anchor\" id=\"Special-Reference-Syntax-for-ccall-(deprecated):-1\" href=\"#Special-Reference-Syntax-for-ccall-(deprecated):-1\">Special Reference Syntax for ccall (deprecated):</a></h3><p>The <code>&amp;</code> syntax is deprecated, use the <code>Ref{T}</code> argument type instead.</p><p>A prefix <code>&amp;</code> is used on an argument to <a href=\"../base/c.html#ccall\"><code>ccall</code></a> to indicate that a pointer to a scalar argument should be passed instead of the scalar value itself (required for all Fortran function arguments, as noted above). The following example computes a dot product using a BLAS function.</p><pre><code class=\"language-julia\">function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})\n    @assert length(DX) == length(DY)\n    n = length(DX)\n    incx = incy = 1\n    product = ccall((:ddot_, &quot;libLAPACK&quot;),\n                    Float64,\n                    (Ref{Int32}, Ptr{Float64}, Ref{Int32}, Ptr{Float64}, Ref{Int32}),\n                    n, DX, incx, DY, incy)\n    return product\nend</code></pre><p>The meaning of prefix <code>&amp;</code> is not quite the same as in C. In particular, any changes to the referenced variables will not be visible in Julia unless the type is mutable (declared via <code>mutable struct</code>). However, even for immutable structs it will not cause any harm for called functions to attempt such modifications (that is, writing through the passed pointers). Moreover, <code>&amp;</code> may be used with any expression, such as <code>&amp;0</code> or <code>&amp;f(x)</code>.</p><p>When a scalar value is passed with <code>&amp;</code> as an argument of type <code>Ptr{T}</code>, the value will first be converted to type <code>T</code>.</p><h2><a class=\"nav-anchor\" id=\"Some-Examples-of-C-Wrappers-1\" href=\"#Some-Examples-of-C-Wrappers-1\">Some Examples of C Wrappers</a></h2><p>Here is a simple example of a C wrapper that returns a <code>Ptr</code> type:</p><pre><code class=\"language-julia\">mutable struct gsl_permutation\nend\n\n# The corresponding C signature is\n#     gsl_permutation * gsl_permutation_alloc (size_t n);\nfunction permutation_alloc(n::Integer)\n    output_ptr = ccall(\n        (:gsl_permutation_alloc, :libgsl), # name of C function and library\n        Ptr{gsl_permutation},              # output type\n        (Csize_t,),                        # tuple of input types\n        n                                  # name of Julia variable to pass in\n    )\n    if output_ptr == C_NULL # Could not allocate memory\n        throw(OutOfMemoryError())\n    end\n    return output_ptr\nend</code></pre><p>The <a href=\"https://www.gnu.org/software/gsl/\">GNU Scientific Library</a> (here assumed to be accessible through <code>:libgsl</code>) defines an opaque pointer, <code>gsl_permutation *</code>, as the return type of the C function <code>gsl_permutation_alloc</code>. As user code never has to look inside the <code>gsl_permutation</code> struct, the corresponding Julia wrapper simply needs a new type declaration, <code>gsl_permutation</code>, that has no internal fields and whose sole purpose is to be placed in the type parameter of a <code>Ptr</code> type.  The return type of the <a href=\"../base/c.html#ccall\"><code>ccall</code></a> is declared as <code>Ptr{gsl_permutation}</code>, since the memory allocated and pointed to by <code>output_ptr</code> is controlled by C (and not Julia).</p><p>The input <code>n</code> is passed by value, and so the function&#39;s input signature is simply declared as <code>(Csize_t,)</code> without any <code>Ref</code> or <code>Ptr</code> necessary. (If the wrapper was calling a Fortran function instead, the corresponding function input signature should instead be <code>(Ref{Csize_t},)</code>, since Fortran variables are passed by pointers.) Furthermore, <code>n</code> can be any type that is convertible to a <code>Csize_t</code> integer; the <a href=\"../base/c.html#ccall\"><code>ccall</code></a> implicitly calls <a href=\"../base/c.html#Base.cconvert\"><code>Base.cconvert(Csize_t, n)</code></a>.</p><p>Here is a second example wrapping the corresponding destructor:</p><pre><code class=\"language-julia\"># The corresponding C signature is\n#     void gsl_permutation_free (gsl_permutation * p);\nfunction permutation_free(p::Ref{gsl_permutation})\n    ccall(\n        (:gsl_permutation_free, :libgsl), # name of C function and library\n        Cvoid,                             # output type\n        (Ref{gsl_permutation},),          # tuple of input types\n        p                                 # name of Julia variable to pass in\n    )\nend</code></pre><p>Here, the input <code>p</code> is declared to be of type <code>Ref{gsl_permutation}</code>, meaning that the memory that <code>p</code> points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type <code>Ptr{gsl_permutation}</code>, but it is convertible using <a href=\"../base/c.html#Base.cconvert\"><code>Base.cconvert</code></a> and therefore can be used in the same (covariant) context of the input argument to a <a href=\"../base/c.html#ccall\"><code>ccall</code></a>. A pointer to memory allocated by Julia must be of type <code>Ref{gsl_permutation}</code>, to ensure that the memory address pointed to is valid and that Julia&#39;s garbage collector manages the chunk of memory pointed to correctly. Therefore, the <code>Ref{gsl_permutation}</code> declaration allows pointers managed by C or Julia to be used.</p><p>If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using <code>p::Ptr{gsl_permutation}</code> for the method signature of the wrapper and similarly in the <a href=\"../base/c.html#ccall\"><code>ccall</code></a> is also acceptable.</p><p>Here is a third example passing Julia arrays:</p><pre><code class=\"language-julia\"># The corresponding C signature is\n#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,\n#                                double result_array[])\nfunction sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)\n    if nmax &lt; nmin\n        throw(DomainError())\n    end\n    result_array = Vector{Cdouble}(nmax - nmin + 1)\n    errorcode = ccall(\n        (:gsl_sf_bessel_Jn_array, :libgsl), # name of C function and library\n        Cint,                               # output type\n        (Cint, Cint, Cdouble, Ref{Cdouble}),# tuple of input types\n        nmin, nmax, x, result_array         # names of Julia variables to pass in\n    )\n    if errorcode != 0\n        error(&quot;GSL error code $errorcode&quot;)\n    end\n    return result_array\nend</code></pre><p>The C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array <code>result_array</code>. This variable can only be used with corresponding input type declaration <code>Ref{Cdouble}</code>, since its memory is allocated and managed by Julia, not C. The implicit call to <a href=\"../base/c.html#Base.cconvert\"><code>Base.cconvert(Ref{Cdouble}, result_array)</code></a> unpacks the Julia pointer to a Julia array data structure into a form understandable by C.</p><p>Note that for this code to work correctly, <code>result_array</code> must be declared to be of type <code>Ref{Cdouble}</code> and not <code>Ptr{Cdouble}</code>. The memory is managed by Julia and the <code>Ref</code> signature alerts Julia&#39;s garbage collector to keep managing the memory for <code>result_array</code> while the <a href=\"../base/c.html#ccall\"><code>ccall</code></a> executes. If <code>Ptr{Cdouble}</code> were used instead, the <a href=\"../base/c.html#ccall\"><code>ccall</code></a> may still work, but Julia&#39;s garbage collector would not be aware that the memory declared for <code>result_array</code> is being used by the external C function. As a result, the code may produce a memory leak if <code>result_array</code> never gets freed by the garbage collector, or if the garbage collector prematurely frees <code>result_array</code>, the C function may end up throwing an invalid memory access exception.</p><h2><a class=\"nav-anchor\" id=\"Garbage-Collection-Safety-1\" href=\"#Garbage-Collection-Safety-1\">Garbage Collection Safety</a></h2><p>When passing data to a <a href=\"../base/c.html#ccall\"><code>ccall</code></a>, it is best to avoid using the <a href=\"../base/c.html#Base.pointer\"><code>pointer</code></a> function. Instead define a convert method and pass the variables directly to the <a href=\"../base/c.html#ccall\"><code>ccall</code></a>. <a href=\"../base/c.html#ccall\"><code>ccall</code></a> automatically arranges that all of its arguments will be preserved from garbage collection until the call returns. If a C API will store a reference to memory allocated by Julia, after the <a href=\"../base/c.html#ccall\"><code>ccall</code></a> returns, you must arrange that the object remains visible to the garbage collector. The suggested way to handle this is to make a global variable of type <code>Array{Ref,1}</code> to hold these values, until the C library notifies you that it is finished with them.</p><p>Whenever you have created a pointer to Julia data, you must ensure the original data exists until you are done with using the pointer. Many methods in Julia such as <a href=\"../base/c.html#Base.unsafe_load\"><code>unsafe_load</code></a> and <a href=\"../base/strings.html#Core.String-Tuple{AbstractString}\"><code>String</code></a> make copies of data instead of taking ownership of the buffer, so that it is safe to free (or alter) the original data without affecting Julia. A notable exception is <a href=\"../base/c.html#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T,N} where N}, Type{Array{T,N}}},Ptr{T},Tuple{Vararg{Int64,N}}}} where N where T\"><code>unsafe_wrap</code></a> which, for performance reasons, shares (or can be told to take ownership of) the underlying buffer.</p><p>The garbage collector does not guarantee any order of finalization. That is, if <code>a</code> contained a reference to <code>b</code> and both <code>a</code> and <code>b</code> are due for garbage collection, there is no guarantee that <code>b</code> would be finalized after <code>a</code>. If proper finalization of <code>a</code> depends on <code>b</code> being valid, it must be handled in other ways.</p><h2><a class=\"nav-anchor\" id=\"Non-constant-Function-Specifications-1\" href=\"#Non-constant-Function-Specifications-1\">Non-constant Function Specifications</a></h2><p>A <code>(name, library)</code> function specification must be a constant expression. However, it is possible to use computed values as function names by staging through <a href=\"../base/base.html#Base.MainInclude.eval\"><code>eval</code></a> as follows:</p><pre><code class=\"language-none\">@eval ccall(($(string(&quot;a&quot;, &quot;b&quot;)), &quot;lib&quot;), ...</code></pre><p>This expression constructs a name using <code>string</code>, then substitutes this name into a new <a href=\"../base/c.html#ccall\"><code>ccall</code></a> expression, which is then evaluated. Keep in mind that <code>eval</code> only operates at the top level, so within this expression local variables will not be available (unless their values are substituted with <code>$</code>). For this reason, <code>eval</code> is typically only used to form top-level definitions, for example when wrapping libraries that contain many similar functions. A similar example can be constructed for <a href=\"../base/c.html#Base.@cfunction\"><code>@cfunction</code></a>.</p><p>However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading. The next section discusses how to use indirect calls to efficiently accomplish a similar effect.</p><h2><a class=\"nav-anchor\" id=\"Indirect-Calls-1\" href=\"#Indirect-Calls-1\">Indirect Calls</a></h2><p>The first argument to <a href=\"../base/c.html#ccall\"><code>ccall</code></a> can also be an expression evaluated at run time. In this case, the expression must evaluate to a <code>Ptr</code>, which will be used as the address of the native function to call. This behavior occurs when the first <a href=\"../base/c.html#ccall\"><code>ccall</code></a> argument contains references to non-constants, such as local variables, function arguments, or non-constant globals.</p><p>For example, you might look up the function via <code>dlsym</code>, then cache it in a shared reference for that session. For example:</p><pre><code class=\"language-julia\">macro dlsym(func, lib)\n    z = Ref{Ptr{Cvoid}}(C_NULL)\n    quote\n        let zlocal = $z[]\n            if zlocal == C_NULL\n                zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}\n                $z[] = $zlocal\n            end\n            zlocal\n        end\n    end\nend\n\nmylibvar = Libdl.dlopen(&quot;mylib&quot;)\nccall(@dlsym(&quot;myfunc&quot;, mylibvar), Cvoid, ())</code></pre><h2><a class=\"nav-anchor\" id=\"Closure-cfunctions-1\" href=\"#Closure-cfunctions-1\">Closure cfunctions</a></h2><p>The first argument to <a href=\"../base/c.html#Base.@cfunction\"><code>@cfunction</code></a> can be marked with a <code>$</code>, in which case the return value will instead be a <code>struct CFunction</code> which closes over the argument. You must ensure that this return object is kept alive until all uses of it are done. The contents and code at the cfunction pointer will be erased via a <a href=\"../base/base.html#Base.finalizer\"><code>finalizer</code></a> when this reference is dropped and atexit. This is not usually needed, since this functionality is not present in C, but can be useful for dealing with ill-designed APIs which don&#39;t provide a separate closure environment parameter.</p><pre><code class=\"language-julia\">function qsort(a::Vector{T}, cmp) where T\n    isbits(T) || throw(ArgumentError(&quot;this method can only qsort isbits arrays&quot;))\n    callback = @cfunction $cmp Cint (Ref{T}, Ref{T})\n    # Here, `callback` isa Base.CFunction, which will be converted to Ptr{Cvoid}\n    # (and protected against finalization) by the ccall\n    ccall(:qsort, Cvoid, (Ptr{T}, Csize_t, Csize_t, Ptr{Cvoid}),\n        a, length(a), Base.elsize(a), callback)\n    # We could instead use:\n    #    GC.@preserve callback begin\n    #        use(Base.unsafe_convert(Ptr{Cvoid}, callback))\n    #    end\n    # if we needed to use it outside of a `ccall`\n    return a\nend</code></pre><h2><a class=\"nav-anchor\" id=\"Closing-a-Library-1\" href=\"#Closing-a-Library-1\">Closing a Library</a></h2><p>It is sometimes useful to close (unload) a library so that it can be reloaded. For instance, when developing C code for use with Julia, one may need to compile, call the C code from Julia, then close the library, make an edit, recompile, and load in the new changes. One can either restart Julia or use the <code>Libdl</code> functions to manage the library explicitly, such as:</p><pre><code class=\"language-julia\">lib = Libdl.dlopen(&quot;./my_lib.so&quot;) # Open the library explicitly.\nsym = Libdl.dlsym(lib, :my_fcn)   # Get a symbol for the function to call.\nccall(sym, ...) # Use the pointer `sym` instead of the (symbol, library) tuple (remaining arguments are the same).\nLibdl.dlclose(lib) # Close the library explicitly.</code></pre><p>Note that when using <code>ccall</code> with the tuple input (e.g., <code>ccall((:my_fcn, &quot;./my_lib.so&quot;), ...)</code>), the library is opened implicitly and it may not be explicitly closed.</p><h2><a class=\"nav-anchor\" id=\"Calling-Convention-1\" href=\"#Calling-Convention-1\">Calling Convention</a></h2><p>The second argument to <a href=\"../base/c.html#ccall\"><code>ccall</code></a> can optionally be a calling convention specifier (immediately preceding return type). Without any specifier, the platform-default C calling convention is used. Other supported conventions are: <code>stdcall</code>, <code>cdecl</code>, <code>fastcall</code>, and <code>thiscall</code> (no-op on 64-bit Windows). For example (from <code>base/libc.jl</code>) we see the same <code>gethostname</code><a href=\"../base/c.html#ccall\"><code>ccall</code></a> as above, but with the correct signature for Windows:</p><pre><code class=\"language-julia\">hn = Vector{UInt8}(256)\nerr = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))</code></pre><p>For more information, please see the <a href=\"http://llvm.org/docs/LangRef.html#calling-conventions\">LLVM Language Reference</a>.</p><p>There is one additional special calling convention <a href=\"../base/c.html#Core.Intrinsics.llvmcall\"><code>llvmcall</code></a>, which allows inserting calls to LLVM intrinsics directly. This can be especially useful when targeting unusual platforms such as GPGPUs. For example, for <a href=\"http://llvm.org/docs/NVPTXUsage.html\">CUDA</a>, we need to be able to read the thread index:</p><pre><code class=\"language-julia\">ccall(&quot;llvm.nvvm.read.ptx.sreg.tid.x&quot;, llvmcall, Int32, ())</code></pre><p>As with any <code>ccall</code>, it is essential to get the argument signature exactly correct. Also, note that there is no compatibility layer that ensures the intrinsic makes sense and works on the current target, unlike the equivalent Julia functions exposed by <code>Core.Intrinsics</code>.</p><h2><a class=\"nav-anchor\" id=\"Accessing-Global-Variables-1\" href=\"#Accessing-Global-Variables-1\">Accessing Global Variables</a></h2><p>Global variables exported by native libraries can be accessed by name using the <a href=\"../base/c.html#Core.Intrinsics.cglobal\"><code>cglobal</code></a> function. The arguments to <a href=\"../base/c.html#Core.Intrinsics.cglobal\"><code>cglobal</code></a> are a symbol specification identical to that used by <a href=\"../base/c.html#ccall\"><code>ccall</code></a>, and a type describing the value stored in the variable:</p><pre><code class=\"language-julia-repl\">julia&gt; cglobal((:errno, :libc), Int32)\nPtr{Int32} @0x00007f418d0816b8</code></pre><p>The result is a pointer giving the address of the value. The value can be manipulated through this pointer using <a href=\"../base/c.html#Base.unsafe_load\"><code>unsafe_load</code></a> and <a href=\"../base/c.html#Base.unsafe_store!\"><code>unsafe_store!</code></a>.</p><h2><a class=\"nav-anchor\" id=\"Accessing-Data-through-a-Pointer-1\" href=\"#Accessing-Data-through-a-Pointer-1\">Accessing Data through a Pointer</a></h2><p>The following methods are described as &quot;unsafe&quot; because a bad pointer or type declaration can cause Julia to terminate abruptly.</p><p>Given a <code>Ptr{T}</code>, the contents of type <code>T</code> can generally be copied from the referenced memory into a Julia object using <code>unsafe_load(ptr, [index])</code>. The index argument is optional (default is 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar to the behavior of <a href=\"../base/collections.html#Base.getindex\"><code>getindex</code></a> and <a href=\"../base/collections.html#Base.setindex!\"><code>setindex!</code></a> (e.g. <code>[]</code> access syntax).</p><p>The return value will be a new object initialized to contain a copy of the contents of the referenced memory. The referenced memory can safely be freed or released.</p><p>If <code>T</code> is <code>Any</code>, then the memory is assumed to contain a reference to a Julia object (a <code>jl_value_t*</code>), the result will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia&#39;s garbage collector.  If the <code>Ptr</code> itself is actually a <code>jl_value_t*</code>, it can be converted back to a Julia object reference by <a href=\"../base/c.html#Base.unsafe_pointer_to_objref\"><code>unsafe_pointer_to_objref(ptr)</code></a>. (Julia values <code>v</code> can be converted to <code>jl_value_t*</code> pointers, as <code>Ptr{Cvoid}</code>, by calling <a href=\"../base/c.html#Base.pointer_from_objref\"><code>pointer_from_objref(v)</code></a>.)</p><p>The reverse operation (writing data to a <code>Ptr{T}</code>), can be performed using <a href=\"../base/c.html#Base.unsafe_store!\"><code>unsafe_store!(ptr, value, [index])</code></a>. Currently, this is only supported for primitive types or other pointer-free (<code>isbits</code>) immutable struct types.</p><p>Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved.</p><p>If the pointer of interest is a plain-data array (primitive type or immutable struct), the function <a href=\"../base/c.html#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T,N} where N}, Type{Array{T,N}}},Ptr{T},Tuple{Vararg{Int64,N}}}} where N where T\"><code>unsafe_wrap(Array, ptr,dims, own = false)</code></a> may be more useful. The final parameter should be true if Julia should &quot;take ownership&quot; of the underlying buffer and call <code>free(ptr)</code> when the returned <code>Array</code> object is finalized.  If the <code>own</code> parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.</p><p>Arithmetic on the <code>Ptr</code> type in Julia (e.g. using <code>+</code>) does not behave the same as C&#39;s pointer arithmetic. Adding an integer to a <code>Ptr</code> in Julia always moves the pointer by some number of <em>bytes</em>, not elements. This way, the address values obtained from pointer arithmetic do not depend on the element types of pointers.</p><h2><a class=\"nav-anchor\" id=\"Thread-safety-1\" href=\"#Thread-safety-1\">Thread-safety</a></h2><p>Some C libraries execute their callbacks from a different thread, and since Julia isn&#39;t thread-safe you&#39;ll need to take some extra precautions. In particular, you&#39;ll need to set up a two-layered system: the C callback should only <em>schedule</em> (via Julia&#39;s event loop) the execution of your &quot;real&quot; callback. To do this, create an <a href=\"../base/base.html#Base.AsyncCondition\"><code>AsyncCondition</code></a> object and <a href=\"../stdlib/Distributed.html#Base.wait\"><code>wait</code></a> on it:</p><pre><code class=\"language-julia\">cond = Base.AsyncCondition()\nwait(cond)</code></pre><p>The callback you pass to C should only execute a <a href=\"../base/c.html#ccall\"><code>ccall</code></a> to <code>:uv_async_send</code>, passing <code>cond.handle</code> as the argument, taking care to avoid any allocations or other interactions with the Julia runtime.</p><p>Note that events may be coalesced, so multiple calls to <code>uv_async_send</code> may result in a single wakeup notification to the condition.</p><h2><a class=\"nav-anchor\" id=\"More-About-Callbacks-1\" href=\"#More-About-Callbacks-1\">More About Callbacks</a></h2><p>For more details on how to pass callbacks to C libraries, see this <a href=\"https://julialang.org/blog/2013/05/callback\">blog post</a>.</p><h2><a class=\"nav-anchor\" id=\"C-1\" href=\"#C-1\">C++</a></h2><p>For direct C++ interfacing, see the <a href=\"https://github.com/Keno/Cxx.jl\">Cxx</a> package. For tools to create C++ bindings, see the <a href=\"https://github.com/JuliaInterop/CxxWrap.jl\">CxxWrap</a> package.</p><footer><hr/><a class=\"previous\" href=\"running-external-programs.html\"><span class=\"direction\">Previous</span><span class=\"title\">Running External Programs</span></a><a class=\"next\" href=\"handling-operating-system-variation.html\"><span class=\"direction\">Next</span><span class=\"title\">Handling Operating System Variation</span></a></footer></article></body></html>\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/doc/_build/html/en/base/c.html": "<!DOCTYPE html>\n<html lang=\"en\"><head><meta charset=\"UTF-8\"/><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/><title>C Interface \u00b7 The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\nm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\n\nga('create', 'UA-28835595-6', 'auto');\nga('send', 'pageview');\n</script><link href=\"https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css\" rel=\"stylesheet\" type=\"text/css\"/><link href=\"https://fonts.googleapis.com/css?family=Lato|Roboto+Mono\" rel=\"stylesheet\" type=\"text/css\"/><link href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css\" rel=\"stylesheet\" type=\"text/css\"/><link href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css\" rel=\"stylesheet\" type=\"text/css\"/><script>documenterBaseURL=\"..\"</script><script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js\" data-main=\"../assets/documenter.js\"></script><script src=\"../siteinfo.js\"></script><script src=\"../../versions.js\"></script><link href=\"../assets/documenter.css\" rel=\"stylesheet\" type=\"text/css\"/><link href=\"../assets/julia-manual.css\" rel=\"stylesheet\" type=\"text/css\"/></head><body><nav class=\"toc\"><a href=\"../index.html\"><img class=\"logo\" src=\"../assets/logo.png\" alt=\"The Julia Language logo\"/></a><h1>The Julia Language</h1><select id=\"version-selector\" onChange=\"window.location.href=this.value\" style=\"visibility: hidden\"></select><form class=\"search\" id=\"search-form\" action=\"../search.html\"><input id=\"search-query\" name=\"q\" type=\"text\" placeholder=\"Search docs\"/></form><ul><li><a class=\"toctext\" href=\"../index.html\">Home</a></li><li><span class=\"toctext\">Manual</span><ul><li><a class=\"toctext\" href=\"../manual/getting-started.html\">Getting Started</a></li><li><a class=\"toctext\" href=\"../manual/variables.html\">Variables</a></li><li><a class=\"toctext\" href=\"../manual/integers-and-floating-point-numbers.html\">Integers and Floating-Point Numbers</a></li><li><a class=\"toctext\" href=\"../manual/mathematical-operations.html\">Mathematical Operations and Elementary Functions</a></li><li><a class=\"toctext\" href=\"../manual/complex-and-rational-numbers.html\">Complex and Rational Numbers</a></li><li><a class=\"toctext\" href=\"../manual/strings.html\">Strings</a></li><li><a class=\"toctext\" href=\"../manual/functions.html\">Functions</a></li><li><a class=\"toctext\" href=\"../manual/control-flow.html\">Control Flow</a></li><li><a class=\"toctext\" href=\"../manual/variables-and-scoping.html\">Scope of Variables</a></li><li><a class=\"toctext\" href=\"../manual/types.html\">Types</a></li><li><a class=\"toctext\" href=\"../manual/methods.html\">Methods</a></li><li><a class=\"toctext\" href=\"../manual/constructors.html\">Constructors</a></li><li><a class=\"toctext\" href=\"../manual/conversion-and-promotion.html\">Conversion and Promotion</a></li><li><a class=\"toctext\" href=\"../manual/interfaces.html\">Interfaces</a></li><li><a class=\"toctext\" href=\"../manual/modules.html\">Modules</a></li><li><a class=\"toctext\" href=\"../manual/documentation.html\">Documentation</a></li><li><a class=\"toctext\" href=\"../manual/metaprogramming.html\">Metaprogramming</a></li><li><a class=\"toctext\" href=\"../manual/arrays.html\">Multi-dimensional Arrays</a></li><li><a class=\"toctext\" href=\"../manual/missing.html\">Missing Values</a></li><li><a class=\"toctext\" href=\"../manual/networking-and-streams.html\">Networking and Streams</a></li><li><a class=\"toctext\" href=\"../manual/parallel-computing.html\">Parallel Computing</a></li><li><a class=\"toctext\" href=\"../manual/running-external-programs.html\">Running External Programs</a></li><li><a class=\"toctext\" href=\"../manual/calling-c-and-fortran-code.html\">Calling C and Fortran Code</a></li><li><a class=\"toctext\" href=\"../manual/handling-operating-system-variation.html\">Handling Operating System Variation</a></li><li><a class=\"toctext\" href=\"../manual/environment-variables.html\">Environment Variables</a></li><li><a class=\"toctext\" href=\"../manual/embedding.html\">Embedding Julia</a></li><li><a class=\"toctext\" href=\"../manual/code-loading.html\">Code Loading</a></li><li><a class=\"toctext\" href=\"../manual/profile.html\">Profiling</a></li><li><a class=\"toctext\" href=\"../manual/stacktraces.html\">Stack Traces</a></li><li><a class=\"toctext\" href=\"../manual/performance-tips.html\">Performance Tips</a></li><li><a class=\"toctext\" href=\"../manual/workflow-tips.html\">Workflow Tips</a></li><li><a class=\"toctext\" href=\"../manual/style-guide.html\">Style Guide</a></li><li><a class=\"toctext\" href=\"../manual/faq.html\">Frequently Asked Questions</a></li><li><a class=\"toctext\" href=\"../manual/noteworthy-differences.html\">Noteworthy Differences from other Languages</a></li><li><a class=\"toctext\" href=\"../manual/unicode-input.html\">Unicode Input</a></li></ul></li><li><span class=\"toctext\">Base</span><ul><li><a class=\"toctext\" href=\"base.html\">Essentials</a></li><li><a class=\"toctext\" href=\"collections.html\">Collections and Data Structures</a></li><li><a class=\"toctext\" href=\"math.html\">Mathematics</a></li><li><a class=\"toctext\" href=\"numbers.html\">Numbers</a></li><li><a class=\"toctext\" href=\"strings.html\">Strings</a></li><li><a class=\"toctext\" href=\"arrays.html\">Arrays</a></li><li><a class=\"toctext\" href=\"parallel.html\">Tasks</a></li><li><a class=\"toctext\" href=\"multi-threading.html\">Multi-Threading</a></li><li><a class=\"toctext\" href=\"constants.html\">Constants</a></li><li><a class=\"toctext\" href=\"file.html\">Filesystem</a></li><li><a class=\"toctext\" href=\"io-network.html\">I/O and Network</a></li><li><a class=\"toctext\" href=\"punctuation.html\">Punctuation</a></li><li><a class=\"toctext\" href=\"sort.html\">Sorting and Related Functions</a></li><li><a class=\"toctext\" href=\"iterators.html\">Iteration utilities</a></li><li class=\"current\"><a class=\"toctext\" href=\"c.html\">C Interface</a><ul class=\"internal\"><li class=\"toplevel\"><a class=\"toctext\" href=\"#LLVM-Interface-1\">LLVM Interface</a></li></ul></li><li><a class=\"toctext\" href=\"libc.html\">C Standard Library</a></li><li><a class=\"toctext\" href=\"stacktraces.html\">StackTraces</a></li><li><a class=\"toctext\" href=\"simd-types.html\">SIMD Support</a></li></ul></li><li><span class=\"toctext\">Standard Library</span><ul><li><a class=\"toctext\" href=\"../stdlib/Base64.html\">Base64</a></li><li><a class=\"toctext\" href=\"../stdlib/CRC32c.html\">CRC32c</a></li><li><a class=\"toctext\" href=\"../stdlib/Dates.html\">Dates</a></li><li><a class=\"toctext\" href=\"../stdlib/DelimitedFiles.html\">Delimited Files</a></li><li><a class=\"toctext\" href=\"../stdlib/Distributed.html\">Distributed Computing</a></li><li><a class=\"toctext\" href=\"../stdlib/FileWatching.html\">File Events</a></li><li><a class=\"toctext\" href=\"../stdlib/InteractiveUtils.html\">Interactive Utilities</a></li><li><a class=\"toctext\" href=\"../stdlib/LibGit2.html\">LibGit2</a></li><li><a class=\"toctext\" href=\"../stdlib/Libdl.html\">Dynamic Linker</a></li><li><a class=\"toctext\" href=\"../stdlib/LinearAlgebra.html\">Linear Algebra</a></li><li><a class=\"toctext\" href=\"../stdlib/Logging.html\">Logging</a></li><li><a class=\"toctext\" href=\"../stdlib/Markdown.html\">Markdown</a></li><li><a class=\"toctext\" href=\"../stdlib/Mmap.html\">Memory-mapped I/O</a></li><li><a class=\"toctext\" href=\"../stdlib/Pkg.html\">Pkg</a></li><li><a class=\"toctext\" href=\"../stdlib/Printf.html\">Printf</a></li><li><a class=\"toctext\" href=\"../stdlib/Profile.html\">Profiling</a></li><li><a class=\"toctext\" href=\"../stdlib/REPL.html\">The Julia REPL</a></li><li><a class=\"toctext\" href=\"../stdlib/Random.html\">Random Numbers</a></li><li><a class=\"toctext\" href=\"../stdlib/SHA.html\">SHA</a></li><li><a class=\"toctext\" href=\"../stdlib/Serialization.html\">Serialization</a></li><li><a class=\"toctext\" href=\"../stdlib/SharedArrays.html\">Shared Arrays</a></li><li><a class=\"toctext\" href=\"../stdlib/Sockets.html\">Sockets</a></li><li><a class=\"toctext\" href=\"../stdlib/SparseArrays.html\">Sparse Arrays</a></li><li><a class=\"toctext\" href=\"../stdlib/Statistics.html\">Statistics</a></li><li><a class=\"toctext\" href=\"../stdlib/Test.html\">Unit Testing</a></li><li><a class=\"toctext\" href=\"../stdlib/UUIDs.html\">UUIDs</a></li><li><a class=\"toctext\" href=\"../stdlib/Unicode.html\">Unicode</a></li></ul></li><li><span class=\"toctext\">Developer Documentation</span><ul><li><a class=\"toctext\" href=\"../devdocs/reflection.html\">Reflection and introspection</a></li><li><span class=\"toctext\">Documentation of Julia&#39;s Internals</span><ul><li><a class=\"toctext\" href=\"../devdocs/init.html\">Initialization of the Julia runtime</a></li><li><a class=\"toctext\" href=\"../devdocs/ast.html\">Julia ASTs</a></li><li><a class=\"toctext\" href=\"../devdocs/types.html\">More about types</a></li><li><a class=\"toctext\" href=\"../devdocs/object.html\">Memory layout of Julia Objects</a></li><li><a class=\"toctext\" href=\"../devdocs/eval.html\">Eval of Julia code</a></li><li><a class=\"toctext\" href=\"../devdocs/callconv.html\">Calling Conventions</a></li><li><a class=\"toctext\" href=\"../devdocs/compiler.html\">High-level Overview of the Native-Code Generation Process</a></li><li><a class=\"toctext\" href=\"../devdocs/functions.html\">Julia Functions</a></li><li><a class=\"toctext\" href=\"../devdocs/cartesian.html\">Base.Cartesian</a></li><li><a class=\"toctext\" href=\"../devdocs/meta.html\">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class=\"toctext\" href=\"../devdocs/subarrays.html\">SubArrays</a></li><li><a class=\"toctext\" href=\"../devdocs/isbitsunionarrays.html\">isbits Union Optimizations</a></li><li><a class=\"toctext\" href=\"../devdocs/sysimg.html\">System Image Building</a></li><li><a class=\"toctext\" href=\"../devdocs/llvm.html\">Working with LLVM</a></li><li><a class=\"toctext\" href=\"../devdocs/stdio.html\">printf() and stdio in the Julia runtime</a></li><li><a class=\"toctext\" href=\"../devdocs/boundscheck.html\">Bounds checking</a></li><li><a class=\"toctext\" href=\"../devdocs/locks.html\">Proper maintenance and care of multi-threading locks</a></li><li><a class=\"toctext\" href=\"../devdocs/offset-arrays.html\">Arrays with custom indices</a></li><li><a class=\"toctext\" href=\"../devdocs/require.html\">Module loading</a></li><li><a class=\"toctext\" href=\"../devdocs/inference.html\">Inference</a></li></ul></li><li><span class=\"toctext\">Developing/debugging Julia&#39;s C code</span><ul><li><a class=\"toctext\" href=\"../devdocs/backtraces.html\">Reporting and analyzing crashes (segfaults)</a></li><li><a class=\"toctext\" href=\"../devdocs/debuggingtips.html\">gdb debugging tips</a></li><li><a class=\"toctext\" href=\"../devdocs/valgrind.html\">Using Valgrind with Julia</a></li><li><a class=\"toctext\" href=\"../devdocs/sanitizers.html\">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id=\"docs\"><header><nav><ul><li>Base</li><li><a href=\"c.html\">C Interface</a></li></ul><a class=\"edit-page\" href=\"https://github.com/JuliaLang/julia/blob/master/doc/src/base/c.md\"><span class=\"fa\">\uf09b</span> Edit on GitHub</a></nav><hr/><div id=\"topbar\"><span>C Interface</span><a class=\"fa fa-bars\" href=\"#\"></a></div></header><h1><a class=\"nav-anchor\" id=\"C-Interface-1\" href=\"#C-Interface-1\">C Interface</a></h1><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"ccall\" href=\"#ccall\"><code>ccall</code></a> \u2014 <span class=\"docstring-category\">Keyword</span>.</div><div><div><pre><code class=\"language-none\">ccall((function_name, library), returntype, (argtype1, ...), argvalue1, ...)\nccall(function_pointer, returntype, (argtype1, ...), argvalue1, ...)</code></pre><p>Call a function in a C-exported shared library, specified by the tuple <code>(function_name, library)</code>, where each component is either a string or symbol. Alternatively, <code>ccall</code> may also be used to call a function pointer <code>function_pointer</code>, such as one returned by <code>dlsym</code>.</p><p>Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.</p><p>Each <code>argvalue</code> to the <code>ccall</code> will be converted to the corresponding <code>argtype</code>, by automatic insertion of calls to <code>unsafe_convert(argtype, cconvert(argtype, argvalue))</code>. (See also the documentation for <a href=\"c.html#Base.unsafe_convert\"><code>unsafe_convert</code></a> and <a href=\"c.html#Base.cconvert\"><code>cconvert</code></a> for further details.) In most cases, this simply results in a call to <code>convert(argtype, argvalue)</code>.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/docs/basedocs.jl#L617-L633\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Core.Intrinsics.cglobal\" href=\"#Core.Intrinsics.cglobal\"><code>Core.Intrinsics.cglobal</code></a> \u2014 <span class=\"docstring-category\">Function</span>.</div><div><div><pre><code class=\"language-none\">cglobal((symbol, library) [, type=Cvoid])</code></pre><p>Obtain a pointer to a global variable in a C-exported shared library, specified exactly as in <a href=\"c.html#ccall\"><code>ccall</code></a>. Returns a <code>Ptr{Type}</code>, defaulting to <code>Ptr{Cvoid}</code> if no <code>Type</code> argument is supplied. The values can be read or written by <a href=\"c.html#Base.unsafe_load\"><code>unsafe_load</code></a> or <a href=\"c.html#Base.unsafe_store!\"><code>unsafe_store!</code></a>, respectively.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/c.jl#L7-L16\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.@cfunction\" href=\"#Base.@cfunction\"><code>Base.@cfunction</code></a> \u2014 <span class=\"docstring-category\">Macro</span>.</div><div><div><pre><code class=\"language-none\">@cfunction(callable, ReturnType, (ArgumentTypes...,)) -&gt; Ptr{Cvoid}\n@cfunction($callable, ReturnType, (ArgumentTypes...,)) -&gt; CFunction</code></pre><p>Generate a C-callable function pointer from the Julia function <code>closure</code> for the given type signature. To pass the return value to a <code>ccall</code>, use the argument type <code>Ptr{Cvoid}</code> in the signature.</p><p>Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression (although it can include a splat expression). And that these arguments will be evaluated in global scope during compile-time (not deferred until runtime). Adding a &#39;$&#39; in front of the function argument changes this to instead create a runtime closure over the local variable <code>callable</code>.</p><p>See <a href=\"../manual/calling-c-and-fortran-code.html#Calling-C-and-Fortran-Code-1\">manual section on ccall and cfunction usage</a>.</p><p><strong>Examples</strong></p><pre><code class=\"language-julia-repl\">julia&gt; function foo(x::Int, y::Int)\n           return x + y\n       end\n\njulia&gt; @cfunction(foo, Int, (Int, Int))\nPtr{Cvoid} @0x000000001b82fcd0</code></pre></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/c.jl#L38-L63\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.CFunction\" href=\"#Base.CFunction\"><code>Base.CFunction</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">CFunction struct</code></pre><p>Garbage-collection handle for the return value from <code>@cfunction</code> when the first argument is annotated with &#39;$&#39;. Like all <code>cfunction</code> handles, it should be passed to <code>ccall</code> as a <code>Ptr{Cvoid}</code>, and will be converted automatically at the call site to the appropriate type.</p><p>See <a href=\"c.html#Base.@cfunction\"><code>@cfunction</code></a>.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/c.jl#L19-L28\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.unsafe_convert\" href=\"#Base.unsafe_convert\"><code>Base.unsafe_convert</code></a> \u2014 <span class=\"docstring-category\">Function</span>.</div><div><div><pre><code class=\"language-none\">unsafe_convert(T, x)</code></pre><p>Convert <code>x</code> to a C argument of type <code>T</code> where the input <code>x</code> must be the return value of <code>cconvert(T, ...)</code>.</p><p>In cases where <a href=\"base.html#Base.convert\"><code>convert</code></a> would need to take a Julia object and turn it into a <code>Ptr</code>, this function should be used to define and perform that conversion.</p><p>Be careful to ensure that a Julia reference to <code>x</code> exists as long as the result of this function will be used. Accordingly, the argument <code>x</code> to this function should never be an expression, only a variable name or field reference. For example, <code>x=a.b.c</code> is acceptable, but <code>x=[a,b,c]</code> is not.</p><p>The <code>unsafe</code> prefix on this function indicates that using the result of this function after the <code>x</code> argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.</p><p>See also <a href=\"c.html#Base.cconvert\"><code>cconvert</code></a></p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/pointer.jl#L34-L54\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.cconvert\" href=\"#Base.cconvert\"><code>Base.cconvert</code></a> \u2014 <span class=\"docstring-category\">Function</span>.</div><div><div><pre><code class=\"language-none\">cconvert(T,x)</code></pre><p>Convert <code>x</code> to a value to be passed to C code as type <code>T</code>, typically by calling <code>convert(T, x)</code>.</p><p>In cases where <code>x</code> cannot be safely converted to <code>T</code>, unlike <a href=\"base.html#Base.convert\"><code>convert</code></a>, <code>cconvert</code> may return an object of a type different from <code>T</code>, which however is suitable for <a href=\"c.html#Base.unsafe_convert\"><code>unsafe_convert</code></a> to handle. The result of this function should be kept valid (for the GC) until the result of <a href=\"c.html#Base.unsafe_convert\"><code>unsafe_convert</code></a> is not needed anymore. This can be used to allocate memory that will be accessed by the <code>ccall</code>. If multiple objects need to be allocated, a tuple of the objects can be used as return value.</p><p>Neither <code>convert</code> nor <code>cconvert</code> should take a Julia object and turn it into a <code>Ptr</code>.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/essentials.jl#L328-L341\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.unsafe_load\" href=\"#Base.unsafe_load\"><code>Base.unsafe_load</code></a> \u2014 <span class=\"docstring-category\">Function</span>.</div><div><div><pre><code class=\"language-none\">unsafe_load(p::Ptr{T}, i::Integer=1)</code></pre><p>Load a value of type <code>T</code> from the address of the <code>i</code>th element (1-indexed) starting at <code>p</code>. This is equivalent to the C expression <code>p[i-1]</code>.</p><p>The <code>unsafe</code> prefix on this function indicates that no validation is performed on the pointer <code>p</code> to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/pointer.jl#L95-L104\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.unsafe_store!\" href=\"#Base.unsafe_store!\"><code>Base.unsafe_store!</code></a> \u2014 <span class=\"docstring-category\">Function</span>.</div><div><div><pre><code class=\"language-none\">unsafe_store!(p::Ptr{T}, x, i::Integer=1)</code></pre><p>Store a value of type <code>T</code> to the address of the <code>i</code>th element (1-indexed) starting at <code>p</code>. This is equivalent to the C expression <code>p[i-1] = x</code>.</p><p>The <code>unsafe</code> prefix on this function indicates that no validation is performed on the pointer <code>p</code> to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/pointer.jl#L107-L116\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.unsafe_copyto!-Union{Tuple{T}, Tuple{Ptr{T},Ptr{T},Any}} where T\" href=\"#Base.unsafe_copyto!-Union{Tuple{T}, Tuple{Ptr{T},Ptr{T},Any}} where T\"><code>Base.unsafe_copyto!</code></a> \u2014 <span class=\"docstring-category\">Method</span>.</div><div><div><pre><code class=\"language-none\">unsafe_copyto!(dest::Ptr{T}, src::Ptr{T}, N)</code></pre><p>Copy <code>N</code> elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.</p><p>The <code>unsafe</code> prefix on this function indicates that no validation is performed on the pointers <code>dest</code> and <code>src</code> to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/array.jl#L212-L221\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.unsafe_copyto!-Union{Tuple{T}, Tuple{Array{T,N} where N,Any,Array{T,N} where N,Any,Any}} where T\" href=\"#Base.unsafe_copyto!-Union{Tuple{T}, Tuple{Array{T,N} where N,Any,Array{T,N} where N,Any,Any}} where T\"><code>Base.unsafe_copyto!</code></a> \u2014 <span class=\"docstring-category\">Method</span>.</div><div><div><pre><code class=\"language-none\">unsafe_copyto!(dest::Array, do, src::Array, so, N)</code></pre><p>Copy <code>N</code> elements from a source array to a destination, starting at offset <code>so</code> in the source and <code>do</code> in the destination (1-indexed).</p><p>The <code>unsafe</code> prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/array.jl#L230-L239\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.copyto!\" href=\"#Base.copyto!\"><code>Base.copyto!</code></a> \u2014 <span class=\"docstring-category\">Function</span>.</div><div><div><pre><code class=\"language-none\">copyto!(dest, do, src, so, N)</code></pre><p>Copy <code>N</code> elements from collection <code>src</code> starting at offset <code>so</code>, to array <code>dest</code> starting at offset <code>do</code>. Return <code>dest</code>.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/array.jl#L262-L267\">source</a><div><div><pre><code class=\"language-none\">copyto!(dest::AbstractArray, src) -&gt; dest</code></pre><p>Copy all elements from collection <code>src</code> to array <code>dest</code>, whose length must be greater than or equal to the length <code>n</code> of <code>src</code>. The first <code>n</code> elements of <code>dest</code> are overwritten, the other elements are left untouched.</p><p><strong>Examples</strong></p><pre><code class=\"language-julia-repl\">julia&gt; x = [1., 0., 3., 0., 5.];\n\njulia&gt; y = zeros(7);\n\njulia&gt; copyto!(y, x);\n\njulia&gt; y\n7-element Array{Float64,1}:\n 1.0\n 0.0\n 3.0\n 0.0\n 5.0\n 0.0\n 0.0</code></pre></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/multidimensional.jl#L789-L815\">source</a><div><div><pre><code class=\"language-none\">copyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices) -&gt; dest</code></pre><p>Copy the block of <code>src</code> in the range of <code>Rsrc</code> to the block of <code>dest</code> in the range of <code>Rdest</code>. The sizes of the two regions must match.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/multidimensional.jl#L853-L858\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.pointer\" href=\"#Base.pointer\"><code>Base.pointer</code></a> \u2014 <span class=\"docstring-category\">Function</span>.</div><div><div><pre><code class=\"language-none\">pointer(array [, index])</code></pre><p>Get the native address of an array or string, optionally at a given location <code>index</code>.</p><p>This function is &quot;unsafe&quot;. Be careful to ensure that a Julia reference to <code>array</code> exists as long as this pointer will be used. The <a href=\"base.html#Base.GC.@preserve\"><code>GC.@preserve</code></a> macro should be used to protect the <code>array</code> argument from garbage collection within a given block of code.</p><p>Calling <a href=\"c.html#Core.Ref\"><code>Ref(array[, index])</code></a> is generally preferable to this function as it guarantees validity.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/c.jl#L172-L183\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T,N} where N}, Type{Array{T,N}}},Ptr{T},Tuple{Vararg{Int64,N}}}} where N where T\" href=\"#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T,N} where N}, Type{Array{T,N}}},Ptr{T},Tuple{Vararg{Int64,N}}}} where N where T\"><code>Base.unsafe_wrap</code></a> \u2014 <span class=\"docstring-category\">Method</span>.</div><div><div><pre><code class=\"language-none\">unsafe_wrap(Array, pointer::Ptr{T}, dims; own = false)</code></pre><p>Wrap a Julia <code>Array</code> object around the data at the address given by <code>pointer</code>, without making a copy.  The pointer element type <code>T</code> determines the array element type. <code>dims</code> is either an integer (for a 1d array) or a tuple of the array dimensions. <code>own</code> optionally specifies whether Julia should take ownership of the memory, calling <code>free</code> on the pointer when the array is no longer referenced.</p><p>This function is labeled &quot;unsafe&quot; because it will crash if <code>pointer</code> is not a valid memory address to data of the requested length.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/pointer.jl#L70-L81\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.pointer_from_objref\" href=\"#Base.pointer_from_objref\"><code>Base.pointer_from_objref</code></a> \u2014 <span class=\"docstring-category\">Function</span>.</div><div><div><pre><code class=\"language-none\">pointer_from_objref(x)</code></pre><p>Get the memory address of a Julia object as a <code>Ptr</code>. The existence of the resulting <code>Ptr</code> will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the <code>Ptr</code> will be used.</p><p>This function may not be called on immutable objects, since they do not have stable memory addresses.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/pointer.jl#L130-L139\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.unsafe_pointer_to_objref\" href=\"#Base.unsafe_pointer_to_objref\"><code>Base.unsafe_pointer_to_objref</code></a> \u2014 <span class=\"docstring-category\">Function</span>.</div><div><div><pre><code class=\"language-none\">unsafe_pointer_to_objref(p::Ptr)</code></pre><p>Convert a <code>Ptr</code> to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered &quot;unsafe&quot; and should be used with care.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/pointer.jl#L121-L127\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.disable_sigint\" href=\"#Base.disable_sigint\"><code>Base.disable_sigint</code></a> \u2014 <span class=\"docstring-category\">Function</span>.</div><div><div><pre><code class=\"language-none\">disable_sigint(f::Function)</code></pre><p>Disable Ctrl-C handler during execution of a function on the current task, for calling external code that may call julia code that is not interrupt safe. Intended to be called using <code>do</code> block syntax as follows:</p><pre><code class=\"language-none\">disable_sigint() do\n    # interrupt-unsafe code\n    ...\nend</code></pre><p>This is not needed on worker threads (<code>Threads.threadid() != 1</code>) since the <code>InterruptException</code> will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/c.jl#L427-L443\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.reenable_sigint\" href=\"#Base.reenable_sigint\"><code>Base.reenable_sigint</code></a> \u2014 <span class=\"docstring-category\">Function</span>.</div><div><div><pre><code class=\"language-none\">reenable_sigint(f::Function)</code></pre><p>Re-enable Ctrl-C handler during execution of a function. Temporarily reverses the effect of <a href=\"c.html#Base.disable_sigint\"><code>disable_sigint</code></a>.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/c.jl#L452-L457\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.systemerror\" href=\"#Base.systemerror\"><code>Base.systemerror</code></a> \u2014 <span class=\"docstring-category\">Function</span>.</div><div><div><pre><code class=\"language-none\">systemerror(sysfunc, iftrue)</code></pre><p>Raises a <code>SystemError</code> for <code>errno</code> with the descriptive string <code>sysfunc</code> if <code>iftrue</code> is <code>true</code></p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/error.jl#L101-L105\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Core.Ptr\" href=\"#Core.Ptr\"><code>Core.Ptr</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Ptr{T}</code></pre><p>A memory address referring to data of type <code>T</code>.  However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/pointer.jl#L3-L8\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Core.Ref\" href=\"#Core.Ref\"><code>Core.Ref</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Ref{T}</code></pre><p>An object that safely references data of type <code>T</code>. This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the <code>Ref</code> itself is referenced.</p><p>In Julia, <code>Ref</code> objects are dereferenced (loaded or stored) with <code>[]</code>.</p><p>Creation of a <code>Ref</code> to a value <code>x</code> of type <code>T</code> is usually written <code>Ref(x)</code>. Additionally, for creating interior pointers to containers (such as Array or Ptr), it can be written <code>Ref(a, i)</code> for creating a reference to the <code>i</code>-th element of <code>a</code>.</p><p>When passed as a <code>ccall</code> argument (either as a <code>Ptr</code> or <code>Ref</code> type), a <code>Ref</code> object will be converted to a native pointer to the data it references.</p><p>There is no invalid (NULL) <code>Ref</code> in Julia, but a <code>C_NULL</code> instance of <code>Ptr</code> can be passed to a <code>ccall</code> Ref argument.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/refpointer.jl#L3-L20\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Cchar\" href=\"#Base.Cchar\"><code>Base.Cchar</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Cchar</code></pre><p>Equivalent to the native <code>char</code> c-type.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/c.jl#L86-L90\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Cuchar\" href=\"#Base.Cuchar\"><code>Base.Cuchar</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Cuchar</code></pre><p>Equivalent to the native <code>unsigned char</code> c-type (<a href=\"numbers.html#Core.UInt8\"><code>UInt8</code></a>).</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/ctypes.jl#L6-L10\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Cshort\" href=\"#Base.Cshort\"><code>Base.Cshort</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Cshort</code></pre><p>Equivalent to the native <code>signed short</code> c-type (<a href=\"numbers.html#Core.Int16\"><code>Int16</code></a>).</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/ctypes.jl#L14-L18\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Cstring\" href=\"#Base.Cstring\"><code>Base.Cstring</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Cstring</code></pre><p>A C-style string composed of the native character type <a href=\"c.html#Base.Cchar\"><code>Cchar</code></a>s. <code>Cstring</code>s are NUL-terminated. For C-style strings composed of the native wide character type, see <a href=\"c.html#Base.Cwstring\"><code>Cwstring</code></a>. For more information about string interopability with C, see the <a href=\"../manual/calling-c-and-fortran-code.html#man-bits-types-1\">manual</a>.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/c.jl#L138-L147\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Cushort\" href=\"#Base.Cushort\"><code>Base.Cushort</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Cushort</code></pre><p>Equivalent to the native <code>unsigned short</code> c-type (<a href=\"numbers.html#Core.UInt16\"><code>UInt16</code></a>).</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/ctypes.jl#L22-L26\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Cint\" href=\"#Base.Cint\"><code>Base.Cint</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Cint</code></pre><p>Equivalent to the native <code>signed int</code> c-type (<a href=\"numbers.html#Core.Int32\"><code>Int32</code></a>).</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/ctypes.jl#L30-L34\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Cuint\" href=\"#Base.Cuint\"><code>Base.Cuint</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Cuint</code></pre><p>Equivalent to the native <code>unsigned int</code> c-type (<a href=\"numbers.html#Core.UInt32\"><code>UInt32</code></a>).</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/ctypes.jl#L38-L42\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Clong\" href=\"#Base.Clong\"><code>Base.Clong</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Clong</code></pre><p>Equivalent to the native <code>signed long</code> c-type.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/c.jl#L104-L108\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Culong\" href=\"#Base.Culong\"><code>Base.Culong</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Culong</code></pre><p>Equivalent to the native <code>unsigned long</code> c-type.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/c.jl#L111-L115\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Clonglong\" href=\"#Base.Clonglong\"><code>Base.Clonglong</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Clonglong</code></pre><p>Equivalent to the native <code>signed long long</code> c-type (<a href=\"numbers.html#Core.Int64\"><code>Int64</code></a>).</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/ctypes.jl#L86-L90\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Culonglong\" href=\"#Base.Culonglong\"><code>Base.Culonglong</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Culonglong</code></pre><p>Equivalent to the native <code>unsigned long long</code> c-type (<a href=\"numbers.html#Core.UInt64\"><code>UInt64</code></a>).</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/ctypes.jl#L94-L98\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Cintmax_t\" href=\"#Base.Cintmax_t\"><code>Base.Cintmax_t</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Cintmax_t</code></pre><p>Equivalent to the native <code>intmax_t</code> c-type (<a href=\"numbers.html#Core.Int64\"><code>Int64</code></a>).</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/ctypes.jl#L70-L74\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Cuintmax_t\" href=\"#Base.Cuintmax_t\"><code>Base.Cuintmax_t</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Cuintmax_t</code></pre><p>Equivalent to the native <code>uintmax_t</code> c-type (<a href=\"numbers.html#Core.UInt64\"><code>UInt64</code></a>).</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/ctypes.jl#L78-L82\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Csize_t\" href=\"#Base.Csize_t\"><code>Base.Csize_t</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Csize_t</code></pre><p>Equivalent to the native <code>size_t</code> c-type (<code>UInt</code>).</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/ctypes.jl#L54-L58\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Cssize_t\" href=\"#Base.Cssize_t\"><code>Base.Cssize_t</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Cssize_t</code></pre><p>Equivalent to the native <code>ssize_t</code> c-type.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/ctypes.jl#L62-L66\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Cptrdiff_t\" href=\"#Base.Cptrdiff_t\"><code>Base.Cptrdiff_t</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Cptrdiff_t</code></pre><p>Equivalent to the native <code>ptrdiff_t</code> c-type (<code>Int</code>).</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/ctypes.jl#L46-L50\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Cwchar_t\" href=\"#Base.Cwchar_t\"><code>Base.Cwchar_t</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Cwchar_t</code></pre><p>Equivalent to the native <code>wchar_t</code> c-type (<a href=\"numbers.html#Core.Int32\"><code>Int32</code></a>).</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/c.jl#L118-L122\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Cwstring\" href=\"#Base.Cwstring\"><code>Base.Cwstring</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Cwstring</code></pre><p>A C-style string composed of the native wide character type <a href=\"c.html#Base.Cwchar_t\"><code>Cwchar_t</code></a>s. <code>Cwstring</code>s are NUL-terminated. For C-style strings composed of the native character type, see <a href=\"c.html#Base.Cstring\"><code>Cstring</code></a>. For more information about string interopability with C, see the <a href=\"../manual/calling-c-and-fortran-code.html#man-bits-types-1\">manual</a>.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/c.jl#L125-L135\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Cfloat\" href=\"#Base.Cfloat\"><code>Base.Cfloat</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Cfloat</code></pre><p>Equivalent to the native <code>float</code> c-type (<a href=\"numbers.html#Core.Float32\"><code>Float32</code></a>).</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/ctypes.jl#L102-L106\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.Cdouble\" href=\"#Base.Cdouble\"><code>Base.Cdouble</code></a> \u2014 <span class=\"docstring-category\">Type</span>.</div><div><div><pre><code class=\"language-none\">Cdouble</code></pre><p>Equivalent to the native <code>double</code> c-type (<a href=\"numbers.html#Core.Float64\"><code>Float64</code></a>).</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/ctypes.jl#L110-L114\">source</a></section><h1><a class=\"nav-anchor\" id=\"LLVM-Interface-1\" href=\"#LLVM-Interface-1\">LLVM Interface</a></h1><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Core.Intrinsics.llvmcall\" href=\"#Core.Intrinsics.llvmcall\"><code>Core.Intrinsics.llvmcall</code></a> \u2014 <span class=\"docstring-category\">Function</span>.</div><div><div><pre><code class=\"language-none\">llvmcall(IR::String, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\nllvmcall((declarations::String, IR::String), ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)</code></pre><p>Call LLVM IR string in the first argument. Similar to an LLVM function <code>define</code> block, arguments are available as consecutive unnamed SSA variables (%0, %1, etc.).</p><p>The optional declarations string contains external functions declarations that are necessary for llvm to compile the IR string. Multiple declarations can be passed in by separating them with line breaks.</p><p>Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.</p><p>Each <code>ArgumentValue</code> to <code>llvmcall</code> will be converted to the corresponding <code>ArgumentType</code>, by automatic insertion of calls to <code>unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))</code>. (See also the documentation for <a href=\"c.html#Base.unsafe_convert\"><code>unsafe_convert</code></a> and <a href=\"c.html#Base.cconvert\"><code>cconvert</code></a> for further details.) In most cases, this simply results in a call to <code>convert(ArgumentType, ArgumentValue)</code>.</p><p>See <code>test/llvmcall.jl</code> for usage examples.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/base/docs/basedocs.jl#L636-L657\">source</a></section><footer><hr/><a class=\"previous\" href=\"iterators.html\"><span class=\"direction\">Previous</span><span class=\"title\">Iteration utilities</span></a><a class=\"next\" href=\"libc.html\"><span class=\"direction\">Next</span><span class=\"title\">C Standard Library</span></a></footer></article></body></html>\n",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/doc/_build/html/en/stdlib/Libdl.html": "<!DOCTYPE html>\n<html lang=\"en\"><head><meta charset=\"UTF-8\"/><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/><title>Dynamic Linker \u00b7 The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\nm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\n\nga('create', 'UA-28835595-6', 'auto');\nga('send', 'pageview');\n</script><link href=\"https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css\" rel=\"stylesheet\" type=\"text/css\"/><link href=\"https://fonts.googleapis.com/css?family=Lato|Roboto+Mono\" rel=\"stylesheet\" type=\"text/css\"/><link href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css\" rel=\"stylesheet\" type=\"text/css\"/><link href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css\" rel=\"stylesheet\" type=\"text/css\"/><script>documenterBaseURL=\"..\"</script><script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js\" data-main=\"../assets/documenter.js\"></script><script src=\"../siteinfo.js\"></script><script src=\"../../versions.js\"></script><link href=\"../assets/documenter.css\" rel=\"stylesheet\" type=\"text/css\"/><link href=\"../assets/julia-manual.css\" rel=\"stylesheet\" type=\"text/css\"/></head><body><nav class=\"toc\"><a href=\"../index.html\"><img class=\"logo\" src=\"../assets/logo.png\" alt=\"The Julia Language logo\"/></a><h1>The Julia Language</h1><select id=\"version-selector\" onChange=\"window.location.href=this.value\" style=\"visibility: hidden\"></select><form class=\"search\" id=\"search-form\" action=\"../search.html\"><input id=\"search-query\" name=\"q\" type=\"text\" placeholder=\"Search docs\"/></form><ul><li><a class=\"toctext\" href=\"../index.html\">Home</a></li><li><span class=\"toctext\">Manual</span><ul><li><a class=\"toctext\" href=\"../manual/getting-started.html\">Getting Started</a></li><li><a class=\"toctext\" href=\"../manual/variables.html\">Variables</a></li><li><a class=\"toctext\" href=\"../manual/integers-and-floating-point-numbers.html\">Integers and Floating-Point Numbers</a></li><li><a class=\"toctext\" href=\"../manual/mathematical-operations.html\">Mathematical Operations and Elementary Functions</a></li><li><a class=\"toctext\" href=\"../manual/complex-and-rational-numbers.html\">Complex and Rational Numbers</a></li><li><a class=\"toctext\" href=\"../manual/strings.html\">Strings</a></li><li><a class=\"toctext\" href=\"../manual/functions.html\">Functions</a></li><li><a class=\"toctext\" href=\"../manual/control-flow.html\">Control Flow</a></li><li><a class=\"toctext\" href=\"../manual/variables-and-scoping.html\">Scope of Variables</a></li><li><a class=\"toctext\" href=\"../manual/types.html\">Types</a></li><li><a class=\"toctext\" href=\"../manual/methods.html\">Methods</a></li><li><a class=\"toctext\" href=\"../manual/constructors.html\">Constructors</a></li><li><a class=\"toctext\" href=\"../manual/conversion-and-promotion.html\">Conversion and Promotion</a></li><li><a class=\"toctext\" href=\"../manual/interfaces.html\">Interfaces</a></li><li><a class=\"toctext\" href=\"../manual/modules.html\">Modules</a></li><li><a class=\"toctext\" href=\"../manual/documentation.html\">Documentation</a></li><li><a class=\"toctext\" href=\"../manual/metaprogramming.html\">Metaprogramming</a></li><li><a class=\"toctext\" href=\"../manual/arrays.html\">Multi-dimensional Arrays</a></li><li><a class=\"toctext\" href=\"../manual/missing.html\">Missing Values</a></li><li><a class=\"toctext\" href=\"../manual/networking-and-streams.html\">Networking and Streams</a></li><li><a class=\"toctext\" href=\"../manual/parallel-computing.html\">Parallel Computing</a></li><li><a class=\"toctext\" href=\"../manual/running-external-programs.html\">Running External Programs</a></li><li><a class=\"toctext\" href=\"../manual/calling-c-and-fortran-code.html\">Calling C and Fortran Code</a></li><li><a class=\"toctext\" href=\"../manual/handling-operating-system-variation.html\">Handling Operating System Variation</a></li><li><a class=\"toctext\" href=\"../manual/environment-variables.html\">Environment Variables</a></li><li><a class=\"toctext\" href=\"../manual/embedding.html\">Embedding Julia</a></li><li><a class=\"toctext\" href=\"../manual/code-loading.html\">Code Loading</a></li><li><a class=\"toctext\" href=\"../manual/profile.html\">Profiling</a></li><li><a class=\"toctext\" href=\"../manual/stacktraces.html\">Stack Traces</a></li><li><a class=\"toctext\" href=\"../manual/performance-tips.html\">Performance Tips</a></li><li><a class=\"toctext\" href=\"../manual/workflow-tips.html\">Workflow Tips</a></li><li><a class=\"toctext\" href=\"../manual/style-guide.html\">Style Guide</a></li><li><a class=\"toctext\" href=\"../manual/faq.html\">Frequently Asked Questions</a></li><li><a class=\"toctext\" href=\"../manual/noteworthy-differences.html\">Noteworthy Differences from other Languages</a></li><li><a class=\"toctext\" href=\"../manual/unicode-input.html\">Unicode Input</a></li></ul></li><li><span class=\"toctext\">Base</span><ul><li><a class=\"toctext\" href=\"../base/base.html\">Essentials</a></li><li><a class=\"toctext\" href=\"../base/collections.html\">Collections and Data Structures</a></li><li><a class=\"toctext\" href=\"../base/math.html\">Mathematics</a></li><li><a class=\"toctext\" href=\"../base/numbers.html\">Numbers</a></li><li><a class=\"toctext\" href=\"../base/strings.html\">Strings</a></li><li><a class=\"toctext\" href=\"../base/arrays.html\">Arrays</a></li><li><a class=\"toctext\" href=\"../base/parallel.html\">Tasks</a></li><li><a class=\"toctext\" href=\"../base/multi-threading.html\">Multi-Threading</a></li><li><a class=\"toctext\" href=\"../base/constants.html\">Constants</a></li><li><a class=\"toctext\" href=\"../base/file.html\">Filesystem</a></li><li><a class=\"toctext\" href=\"../base/io-network.html\">I/O and Network</a></li><li><a class=\"toctext\" href=\"../base/punctuation.html\">Punctuation</a></li><li><a class=\"toctext\" href=\"../base/sort.html\">Sorting and Related Functions</a></li><li><a class=\"toctext\" href=\"../base/iterators.html\">Iteration utilities</a></li><li><a class=\"toctext\" href=\"../base/c.html\">C Interface</a></li><li><a class=\"toctext\" href=\"../base/libc.html\">C Standard Library</a></li><li><a class=\"toctext\" href=\"../base/stacktraces.html\">StackTraces</a></li><li><a class=\"toctext\" href=\"../base/simd-types.html\">SIMD Support</a></li></ul></li><li><span class=\"toctext\">Standard Library</span><ul><li><a class=\"toctext\" href=\"Base64.html\">Base64</a></li><li><a class=\"toctext\" href=\"CRC32c.html\">CRC32c</a></li><li><a class=\"toctext\" href=\"Dates.html\">Dates</a></li><li><a class=\"toctext\" href=\"DelimitedFiles.html\">Delimited Files</a></li><li><a class=\"toctext\" href=\"Distributed.html\">Distributed Computing</a></li><li><a class=\"toctext\" href=\"FileWatching.html\">File Events</a></li><li><a class=\"toctext\" href=\"InteractiveUtils.html\">Interactive Utilities</a></li><li><a class=\"toctext\" href=\"LibGit2.html\">LibGit2</a></li><li class=\"current\"><a class=\"toctext\" href=\"Libdl.html\">Dynamic Linker</a><ul class=\"internal\"></ul></li><li><a class=\"toctext\" href=\"LinearAlgebra.html\">Linear Algebra</a></li><li><a class=\"toctext\" href=\"Logging.html\">Logging</a></li><li><a class=\"toctext\" href=\"Markdown.html\">Markdown</a></li><li><a class=\"toctext\" href=\"Mmap.html\">Memory-mapped I/O</a></li><li><a class=\"toctext\" href=\"Pkg.html\">Pkg</a></li><li><a class=\"toctext\" href=\"Printf.html\">Printf</a></li><li><a class=\"toctext\" href=\"Profile.html\">Profiling</a></li><li><a class=\"toctext\" href=\"REPL.html\">The Julia REPL</a></li><li><a class=\"toctext\" href=\"Random.html\">Random Numbers</a></li><li><a class=\"toctext\" href=\"SHA.html\">SHA</a></li><li><a class=\"toctext\" href=\"Serialization.html\">Serialization</a></li><li><a class=\"toctext\" href=\"SharedArrays.html\">Shared Arrays</a></li><li><a class=\"toctext\" href=\"Sockets.html\">Sockets</a></li><li><a class=\"toctext\" href=\"SparseArrays.html\">Sparse Arrays</a></li><li><a class=\"toctext\" href=\"Statistics.html\">Statistics</a></li><li><a class=\"toctext\" href=\"Test.html\">Unit Testing</a></li><li><a class=\"toctext\" href=\"UUIDs.html\">UUIDs</a></li><li><a class=\"toctext\" href=\"Unicode.html\">Unicode</a></li></ul></li><li><span class=\"toctext\">Developer Documentation</span><ul><li><a class=\"toctext\" href=\"../devdocs/reflection.html\">Reflection and introspection</a></li><li><span class=\"toctext\">Documentation of Julia&#39;s Internals</span><ul><li><a class=\"toctext\" href=\"../devdocs/init.html\">Initialization of the Julia runtime</a></li><li><a class=\"toctext\" href=\"../devdocs/ast.html\">Julia ASTs</a></li><li><a class=\"toctext\" href=\"../devdocs/types.html\">More about types</a></li><li><a class=\"toctext\" href=\"../devdocs/object.html\">Memory layout of Julia Objects</a></li><li><a class=\"toctext\" href=\"../devdocs/eval.html\">Eval of Julia code</a></li><li><a class=\"toctext\" href=\"../devdocs/callconv.html\">Calling Conventions</a></li><li><a class=\"toctext\" href=\"../devdocs/compiler.html\">High-level Overview of the Native-Code Generation Process</a></li><li><a class=\"toctext\" href=\"../devdocs/functions.html\">Julia Functions</a></li><li><a class=\"toctext\" href=\"../devdocs/cartesian.html\">Base.Cartesian</a></li><li><a class=\"toctext\" href=\"../devdocs/meta.html\">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class=\"toctext\" href=\"../devdocs/subarrays.html\">SubArrays</a></li><li><a class=\"toctext\" href=\"../devdocs/isbitsunionarrays.html\">isbits Union Optimizations</a></li><li><a class=\"toctext\" href=\"../devdocs/sysimg.html\">System Image Building</a></li><li><a class=\"toctext\" href=\"../devdocs/llvm.html\">Working with LLVM</a></li><li><a class=\"toctext\" href=\"../devdocs/stdio.html\">printf() and stdio in the Julia runtime</a></li><li><a class=\"toctext\" href=\"../devdocs/boundscheck.html\">Bounds checking</a></li><li><a class=\"toctext\" href=\"../devdocs/locks.html\">Proper maintenance and care of multi-threading locks</a></li><li><a class=\"toctext\" href=\"../devdocs/offset-arrays.html\">Arrays with custom indices</a></li><li><a class=\"toctext\" href=\"../devdocs/require.html\">Module loading</a></li><li><a class=\"toctext\" href=\"../devdocs/inference.html\">Inference</a></li></ul></li><li><span class=\"toctext\">Developing/debugging Julia&#39;s C code</span><ul><li><a class=\"toctext\" href=\"../devdocs/backtraces.html\">Reporting and analyzing crashes (segfaults)</a></li><li><a class=\"toctext\" href=\"../devdocs/debuggingtips.html\">gdb debugging tips</a></li><li><a class=\"toctext\" href=\"../devdocs/valgrind.html\">Using Valgrind with Julia</a></li><li><a class=\"toctext\" href=\"../devdocs/sanitizers.html\">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id=\"docs\"><header><nav><ul><li>Standard Library</li><li><a href=\"Libdl.html\">Dynamic Linker</a></li></ul><a class=\"edit-page\" href=\"https://github.com/JuliaLang/julia/blob/master/stdlib/Libdl/docs/src/index.md\"><span class=\"fa\">\uf09b</span> Edit on GitHub</a></nav><hr/><div id=\"topbar\"><span>Dynamic Linker</span><a class=\"fa fa-bars\" href=\"#\"></a></div></header><h1><a class=\"nav-anchor\" id=\"Dynamic-Linker-1\" href=\"#Dynamic-Linker-1\">Dynamic Linker</a></h1><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Libdl.dlopen\" href=\"#Libdl.dlopen\"><code>Libdl.dlopen</code></a> \u2014 <span class=\"docstring-category\">Function</span>.</div><div><div><pre><code class=\"language-none\">dlopen(libfile::AbstractString [, flags::Integer])</code></pre><p>Load a shared library, returning an opaque handle.</p><p>The extension given by the constant <code>dlext</code> (<code>.so</code>, <code>.dll</code>, or <code>.dylib</code>) can be omitted from the <code>libfile</code> string, as it is automatically appended if needed.   If <code>libfile</code> is not an absolute path name, then the paths in the array <code>DL_LOAD_PATH</code> are searched for <code>libfile</code>, followed by the system load path.</p><p>The optional flags argument is a bitwise-or of zero or more of <code>RTLD_LOCAL</code>, <code>RTLD_GLOBAL</code>, <code>RTLD_LAZY</code>, <code>RTLD_NOW</code>, <code>RTLD_NODELETE</code>, <code>RTLD_NOLOAD</code>, <code>RTLD_DEEPBIND</code>, and <code>RTLD_FIRST</code>. These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default <code>dlopen</code> flags are <code>RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL</code> while on other platforms the defaults are <code>RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL</code>. An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance <code>RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL</code> allows the library&#39;s symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/stdlib/Libdl/src/Libdl.jl#L68-L91\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Libdl.dlopen_e\" href=\"#Libdl.dlopen_e\"><code>Libdl.dlopen_e</code></a> \u2014 <span class=\"docstring-category\">Function</span>.</div><div><div><pre><code class=\"language-none\">dlopen_e(libfile::AbstractString [, flags::Integer])</code></pre><p>Similar to <a href=\"Libdl.html#Libdl.dlopen\"><code>dlopen</code></a>, except returns a <code>NULL</code> pointer instead of raising errors.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/stdlib/Libdl/src/Libdl.jl#L100-L104\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Libdl.RTLD_NOW\" href=\"#Libdl.RTLD_NOW\"><code>Libdl.RTLD_NOW</code></a> \u2014 <span class=\"docstring-category\">Constant</span>.</div><div><div><pre><code class=\"language-none\">RTLD_DEEPBIND\nRTLD_FIRST\nRTLD_GLOBAL\nRTLD_LAZY\nRTLD_LOCAL\nRTLD_NODELETE\nRTLD_NOLOAD\nRTLD_NOW</code></pre><p>Enum constant for <a href=\"Libdl.html#Libdl.dlopen\"><code>dlopen</code></a>. See your platform man page for details, if applicable.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/stdlib/Libdl/src/Libdl.jl#L33-L45\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Libdl.dlsym\" href=\"#Libdl.dlsym\"><code>Libdl.dlsym</code></a> \u2014 <span class=\"docstring-category\">Function</span>.</div><div><div><pre><code class=\"language-none\">dlsym(handle, sym)</code></pre><p>Look up a symbol from a shared library handle, return callable function pointer on success.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/stdlib/Libdl/src/Libdl.jl#L48-L52\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Libdl.dlsym_e\" href=\"#Libdl.dlsym_e\"><code>Libdl.dlsym_e</code></a> \u2014 <span class=\"docstring-category\">Function</span>.</div><div><div><pre><code class=\"language-none\">dlsym_e(handle, sym)</code></pre><p>Look up a symbol from a shared library handle, silently return <code>NULL</code> pointer on lookup failure.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/stdlib/Libdl/src/Libdl.jl#L58-L62\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Libdl.dlclose\" href=\"#Libdl.dlclose\"><code>Libdl.dlclose</code></a> \u2014 <span class=\"docstring-category\">Function</span>.</div><div><div><pre><code class=\"language-none\">dlclose(handle)</code></pre><p>Close shared library referenced by handle.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/stdlib/Libdl/src/Libdl.jl#L113-L117\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Libdl.dlext\" href=\"#Libdl.dlext\"><code>Libdl.dlext</code></a> \u2014 <span class=\"docstring-category\">Constant</span>.</div><div><div><pre><code class=\"language-none\">dlext</code></pre><p>File extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/stdlib/Libdl/src/Libdl.jl#L175-L179\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Libdl.find_library\" href=\"#Libdl.find_library\"><code>Libdl.find_library</code></a> \u2014 <span class=\"docstring-category\">Function</span>.</div><div><div><pre><code class=\"language-none\">find_library(names, locations)</code></pre><p>Searches for the first library in <code>names</code> in the paths in the <code>locations</code> list, <code>DL_LOAD_PATH</code>, or system library paths (in that order) which can successfully be dlopen&#39;d. On success, the return value will be one of the names (potentially prefixed by one of the paths in locations). This string can be assigned to a <code>global const</code> and used as the library name in future <code>ccall</code>&#39;s. On failure, it returns the empty string.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/stdlib/Libdl/src/Libdl.jl#L122-L130\">source</a></section><section class=\"docstring\"><div class=\"docstring-header\"><a class=\"docstring-binding\" id=\"Base.DL_LOAD_PATH\" href=\"#Base.DL_LOAD_PATH\"><code>Base.DL_LOAD_PATH</code></a> \u2014 <span class=\"docstring-category\">Constant</span>.</div><div><div><pre><code class=\"language-none\">DL_LOAD_PATH</code></pre><p>When calling <a href=\"Libdl.html#Libdl.dlopen\"><code>dlopen</code></a>, the paths in this list will be searched first, in order, before searching the system locations for a valid library handle.</p></div></div><a class=\"source-link\" target=\"_blank\" href=\"https://github.com/JuliaLang/julia/blob/5d4eaca0c9fa3d555c79dbacdccb9169fdf64b65/stdlib/Libdl/src/Libdl.jl#L14-L19\">source</a></section><footer><hr/><a class=\"previous\" href=\"LibGit2.html\"><span class=\"direction\">Previous</span><span class=\"title\">LibGit2</span></a><a class=\"next\" href=\"LinearAlgebra.html\"><span class=\"direction\">Next</span><span class=\"title\">Linear Algebra</span></a></footer></article></body></html>\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/openlibm-ce69bf1f32d3e2e9791da36c9e33ba38670d5576.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/dsfmt-2.2.3.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/libssh2-30e9c1347e3b8baa2951db612f05e6d87fc8e2f2.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/pcre2-10.30.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/mpfr-4.0.1.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/mbedtls-2.6.0-gpl.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/utf8proc-97ef668b312b96382714dbb8eaac4affce0816e6.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/libwhich-81e9723c0273d78493dc8c8ed570f68d9ce7e89e.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/lapack-3.5.0.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/openblas-e8a68ef261a33568b0f0cf53e0e2287e9f12e69e.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/libunwind-1.1-julia2.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/libuv-ed3700c849289ed01fe04273a7bf865340b2bd7e.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/curl-7.56.0.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/objconv.zip",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/libosxunwind-0.0.3.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/patchelf-0.9.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/gmp-6.1.2.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/llvm-6.0.0.src.tar.xz",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/libgit2-8d36dc62ba1b5d7deb66b6f982e005ddbc2ce343.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/deps/srccache/SuiteSparse-4.4.5.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/contrib/windows/julia.ico",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/contrib/windows/7zS.sfx",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/contrib/mac/app/julia.icns",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/doc/images/travis-icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/doc/images/github_metadata_pullrequest.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/doc/images/jltypes.ai",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/doc/images/github_metadata_develbranch.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/doc/images/github_metadata_fork.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/doc/src/assets/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-julia-1.0.0-oed7rh3dnkcxjbl4yg4sixqth72cubje/spack-src/doc/_build/html/en/assets/logo.png"
    ],
    "total_files": 1337
}