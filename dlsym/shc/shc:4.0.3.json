{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-shc-4.0.3-cgzqeuf6ij57kykogjbsqwdfj4a4xxau/spack-src/src/shc.c": "/* shc.c */\n\n/**\n * This software contains an ad hoc version of the 'Alleged RC4' algorithm,\n * which was anonymously posted on sci.crypt news by cypherpunks on Sep 1994.\n *\n * My implementation is a complete rewrite of the one found in\n * an unknown-copyright (283 characters) version picked up from:\n *    From: allen@gateway.grumman.com (John L. Allen)\n *    Newsgroups: comp.lang.c\n *    Subject: Shrink this C code for fame and fun\n *    Date: 21 May 1996 10:49:37 -0400\n * And it is licensed also under GPL.\n *\n *That's where I got it, now I am going to do some work on it\n *It will reside here: http://github.com/neurobin/shc\n */\n\nstatic const char my_name[] = \"shc\";\nstatic const char version[] = \"Version 4.0.3\";\nstatic const char subject[] = \"Generic Shell Script Compiler\";\nstatic const char cpright[] = \"GNU GPL Version 3\";\nstatic const struct { const char * f, * s, * e; }\n\tprovider = { \"Md Jahidul\", \"Hamid\", \"<jahidulhamid@yahoo.com>\" };          \n\n/* \nstatic const struct { const char * f, * s, * e; }\n\tauthor = { \"Francisco\", \"Garcia\", \"<frosal@fi.upm.es>\" };\n*/\n/*This is the original author who first came up with this*/\n\nstatic const char * copying[] = {\n\"Copying:\",\n\"\",\n\"    This program is free software; you can redistribute it and/or modify\",\n\"    it under the terms of the GNU General Public License as published by\",\n\"    the Free Software Foundation; either version 3 of the License, or\",\n\"    (at your option) any later version.\",\n\"\",\n\"    This program is distributed in the hope that it will be useful,\",\n\"    but WITHOUT ANY WARRANTY; without even the implied warranty of\",\n\"    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\",\n\"    GNU General Public License for more details.\",\n\"\",\n\"    You should have received a copy of the GNU General Public License\",\n\"    along with this program; if not, write to the Free Software\",\n\"    @Neurobin, Dhaka, Bangladesh\",\n\"\",\n\"    Report problems and questions to:http://github.com/neurobin/shc\",\n\"\",\n0};\n\nstatic const char * abstract[] = {\n\"Abstract:\",\n\"\",\n\"    This tool generates a stripped binary executable version\",\n\"    of the script specified at command line.\",\n\"\",\n\"    Binary version will be saved with a .x extension by default.\",\n\"    You can specify output file name too with [-o filname] option.\",\n\"\",\n\"    You can specify expiration date [-e] too, after which binary will\",\n\"    refuse to be executed, displaying \\\"[-m]\\\" instead.\",\n\"\",\n\"    You can compile whatever interpreted script, but valid [-i], [-x]\",\n\"    and [-l] options must be given.\",\n\"\",\n0};\n\nstatic const char usage[] = \n\"Usage: shc [-e date] [-m addr] [-i iopt] [-x cmnd] [-l lopt] [-o outfile] [-rvDSUHCABh] -f script\";\n\nstatic const char * help[] = {\n\"\",\n\"    -e %s  Expiration date in dd/mm/yyyy format [none]\",\n\"    -m %s  Message to display upon expiration [\\\"Please contact your provider\\\"]\",\n\"    -f %s  File name of the script to compile\",\n\"    -i %s  Inline option for the shell interpreter i.e: -e\",\n\"    -x %s  eXec command, as a printf format i.e: exec('%s',@ARGV);\",\n\"    -l %s  Last shell option i.e: --\",\n\"    -o %s  output filename\",\n\"    -r     Relax security. Make a redistributable binary\",\n\"    -v     Verbose compilation\",\n\"    -S     Switch ON setuid for root callable programs [OFF]\",\n\"    -D     Switch ON debug exec calls [OFF]\",\n\"    -U     Make binary untraceable [no]\",\n\"    -H     Hardening : extra security protection [no]\",\n\"           Require bourne shell (sh) and parameters are not supported\",\n\"    -C     Display license and exit\",\n\"    -A     Display abstract and exit\",\n\"    -B     Compile for busybox\",\n\"    -h     Display help and exit\",\n\"\",\n\"    Environment variables used:\",\n\"    Name    Default  Usage\",\n\"    CC      cc       C compiler command\",\n\"    CFLAGS  <none>   C compiler flags\",\n\"    LDFLAGS <none>   Linker flags\",\n\"\",\n\"    Please consult the shc man page.\",\n\"\",\n0};\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#define SIZE 4096\n\nstatic char * file;\nstatic char * file2;\nstatic char   date[21];\nstatic char * mail = \"Please contact your provider jahidulhamid@yahoo.com\";\nstatic char   rlax[1];\nstatic char * shll;\nstatic char * inlo;\nstatic char * xecc;\nstatic char * lsto;\nstatic char * opts;\nstatic char * text;\nstatic int verbose;\nstatic const char SETUID_line[] =\n\"#define SETUID %d\t/* Define as 1 to call setuid(0) at start of script */\\n\";\nstatic int SETUID_flag = 0;\nstatic const char DEBUGEXEC_line[] =\n\"#define DEBUGEXEC\t%d\t/* Define as 1 to debug execvp calls */\\n\";\nstatic int DEBUGEXEC_flag = 0;\nstatic const char TRACEABLE_line[] =\n\"#define TRACEABLE\t%d\t/* Define as 1 to enable ptrace the executable */\\n\";\nstatic int TRACEABLE_flag = 1;\nstatic const char HARDENING_line[] =\n\"#define HARDENING\t%d\t/* Define as 1 to disable ptrace/dump the executable */\\n\";\nstatic int HARDENING_flag = 0;\nstatic const char BUSYBOXON_line[] =\n\"#define BUSYBOXON\t%d\t/* Define as 1 to enable work with busybox */\\n\";\nstatic int BUSYBOXON_flag = 0;\n\nstatic const char * RTC[] = {\n\"\",\n\"#if HARDENING\",\n\"static const char * shc_x[] = {\",\n\"\\\"/*\\\",\",\n\"\\\" * Copyright 2019 - Intika <intika@librefox.org>\\\",\",\n\"\\\" * Replace ******** with secret read from fd 21\\\",\",\n\"\\\" * Also change arguments location of sub commands (sh script commands)\\\",\",\n\"\\\" * gcc -Wall -fpic -shared -o shc_secret.so shc_secret.c -ldl\\\",\",\n\"\\\" */\\\",\",\n\"\\\"\\\",\",\n\"\\\"#define _GNU_SOURCE /* needed to get RTLD_NEXT defined in dlfcn.h */\\\",\",\n\"\\\"#define PLACEHOLDER \\\\\\\"********\\\\\\\"\\\",\",\n\"\\\"#include <dlfcn.h>\\\",\",\n\"\\\"#include <stdlib.h>\\\",\",\n\"\\\"#include <string.h>\\\",\",\n\"\\\"#include <unistd.h>\\\",\",\n\"\\\"#include <stdio.h>\\\",\",\n\"\\\"#include <signal.h>\\\",\",\n\"\\\"\\\",\",\n\"\\\"static char secret[128000]; //max size\\\",\",\n\"\\\"typedef int (*pfi)(int, char **, char **);\\\",\",\n\"\\\"static pfi real_main;\\\",\",\n\"\\\"\\\",\",\n\"\\\"// copy argv to new location\\\",\",\n\"\\\"char **copyargs(int argc, char** argv){\\\",\",\n\"\\\"    char **newargv = malloc((argc+1)*sizeof(*argv));\\\",\",\n\"\\\"    char *from,*to;\\\",\",\n\"\\\"    int i,len;\\\",\",\n\"\\\"\\\",\",\n\"\\\"    for(i = 0; i<argc; i++){\\\",\",\n\"\\\"        from = argv[i];\\\",\",\n\"\\\"        len = strlen(from)+1;\\\",\",\n\"\\\"        to = malloc(len);\\\",\",\n\"\\\"        memcpy(to,from,len);\\\",\",\n\"\\\"        // zap old argv space\\\",\",\n\"\\\"        memset(from,'\\\\\\\\0',len);\\\",\",\n\"\\\"        newargv[i] = to;\\\",\",\n\"\\\"        argv[i] = 0;\\\",\",\n\"\\\"    }\\\",\",\n\"\\\"    newargv[argc] = 0;\\\",\",\n\"\\\"    return newargv;\\\",\",\n\"\\\"}\\\",\",\n\"\\\"\\\",\",\n\"\\\"static int mymain(int argc, char** argv, char** env) {\\\",\",\n\"\\\"    //fprintf(stderr, \\\\\\\"Inject main argc = %d\\\\\\\\n\\\\\\\", argc);\\\",\",\n\"\\\"    return real_main(argc, copyargs(argc,argv), env);\\\",\",\n\"\\\"}\\\",\",\n\"\\\"\\\",\",\n\"\\\"int __libc_start_main(int (*main) (int, char**, char**),\\\",\",\n\"\\\"                      int argc,\\\",\",\n\"\\\"                      char **argv,\\\",\",\n\"\\\"                      void (*init) (void),\\\",\",\n\"\\\"                      void (*fini)(void),\\\",\",\n\"\\\"                      void (*rtld_fini)(void),\\\",\",\n\"\\\"                      void (*stack_end)){\\\",\",\n\"\\\"    static int (*real___libc_start_main)() = NULL;\\\",\",\n\"\\\"    int n;\\\",\",\n\"\\\"\\\",\",\n\"\\\"    if (!real___libc_start_main) {\\\",\",\n\"\\\"        real___libc_start_main = dlsym(RTLD_NEXT, \\\\\\\"__libc_start_main\\\\\\\");\\\",\",\n\"\\\"        if (!real___libc_start_main) abort();\\\",\",\n\"\\\"    }\\\",\",\n\"\\\"\\\",\",\n\"\\\"    n = read(21, secret, sizeof(secret));\\\",\",\n\"\\\"    if (n > 0) {\\\",\",\n\"\\\"      int i;\\\",\",\n\"\\\"\\\",\",\n\"\\\"    if (secret[n - 1] == '\\\\\\\\n') secret[--n] = '\\\\\\\\0';\\\",\",\n\"\\\"    for (i = 1; i < argc; i++)\\\",\",\n\"\\\"        if (strcmp(argv[i], PLACEHOLDER) == 0)\\\",\",\n\"\\\"          argv[i] = secret;\\\",\",\n\"\\\"    }\\\",\",\n\"\\\"\\\",\",\n\"\\\"    real_main = main;\\\",\",\n\"\\\"\\\",\",\n\"\\\"    return real___libc_start_main(mymain, argc, argv, init, fini, rtld_fini, stack_end);\\\",\",\n\"\\\"}\\\",\",\n\"\\\"\\\",\",\n\"0};\",\n\"#endif /* HARDENING */\",\n\"\",\n\"/* rtc.c */\",\n\"\",\n\"#include <sys/stat.h>\",\n\"#include <sys/types.h>\",\n\"\",\n\"#include <errno.h>\",\n\"#include <stdio.h>\",\n\"#include <stdlib.h>\",\n\"#include <string.h>\",\n\"#include <time.h>\",\n\"#include <unistd.h>\",\n\"\",\n\"/* 'Alleged RC4' */\",\n\"\",\n\"static unsigned char stte[256], indx, jndx, kndx;\",\n\"\",\n\"/*\",\n\" * Reset arc4 stte. \",\n\" */\",\n\"void stte_0(void)\",\n\"{\",\n\"\tindx = jndx = kndx = 0;\",\n\"\tdo {\",\n\"\t\tstte[indx] = indx;\",\n\"\t} while (++indx);\",\n\"}\",\n\"\",\n\"/*\",\n\" * Set key. Can be used more than once. \",\n\" */\",\n\"void key(void * str, int len)\",\n\"{\",\n\"\tunsigned char tmp, * ptr = (unsigned char *)str;\",\n\"\twhile (len > 0) {\",\n\"\t\tdo {\",\n\"\t\t\ttmp = stte[indx];\",\n\"\t\t\tkndx += tmp;\",\n\"\t\t\tkndx += ptr[(int)indx % len];\",\n\"\t\t\tstte[indx] = stte[kndx];\",\n\"\t\t\tstte[kndx] = tmp;\",\n\"\t\t} while (++indx);\",\n\"\t\tptr += 256;\",\n\"\t\tlen -= 256;\",\n\"\t}\",\n\"}\",\n\"\",\n\"/*\",\n\" * Crypt data. \",\n\" */\",\n\"void arc4(void * str, int len)\",\n\"{\",\n\"\tunsigned char tmp, * ptr = (unsigned char *)str;\",\n\"\twhile (len > 0) {\",\n\"\t\tindx++;\",\n\"\t\ttmp = stte[indx];\",\n\"\t\tjndx += tmp;\",\n\"\t\tstte[indx] = stte[jndx];\",\n\"\t\tstte[jndx] = tmp;\",\n\"\t\ttmp += stte[indx];\",\n\"\t\t*ptr ^= stte[tmp];\",\n\"\t\tptr++;\",\n\"\t\tlen--;\",\n\"\t}\",\n\"}\",\n\"\",\n\"/* End of ARC4 */\",\n\"\",\n\"#if HARDENING\",\n\"\",\n\"#include <sys/ptrace.h>\",\n\"#include <sys/wait.h>\",\n\"#include <signal.h>\",\n\"#include <sys/prctl.h>\",\n\"#define PR_SET_PTRACER 0x59616d61\",\n\"\",\n\"/* Seccomp Sandboxing Init */\",\n\"#include <stdlib.h>\",\n\"#include <stdio.h>\",\n\"#include <stddef.h>\",\n\"#include <string.h>\",\n\"#include <unistd.h>\",\n\"#include <errno.h>\",\n\"\",\n\"#include <sys/types.h>\",\n\"#include <sys/prctl.h>\",\n\"#include <sys/syscall.h>\",\n\"#include <sys/socket.h>\",\n\"\",\n\"#include <linux/filter.h>\",\n\"#include <linux/seccomp.h>\",\n\"#include <linux/audit.h>\",\n\"\",\n\"#define ArchField offsetof(struct seccomp_data, arch)\",\n\"\",\n\"#define Allow(syscall) \\\\\",\n\"    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_##syscall, 0, 1), \\\\\",\n\"    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)\",\n\"\",\n\"struct sock_filter filter[] = {\",\n\"    /* validate arch */\",\n\"    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, ArchField),\",\n\"    BPF_JUMP( BPF_JMP+BPF_JEQ+BPF_K, AUDIT_ARCH_X86_64, 1, 0),\",\n\"    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),\",\n\"\",\n\"    /* load syscall */\",\n\"    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, offsetof(struct seccomp_data, nr)),\",\n\"\",\n\"    /* list of allowed syscalls */\",\n\"    Allow(exit_group),  /* exits a process */\",\n\"    Allow(brk),         /* for malloc(), inside libc */\",\n\"    Allow(mmap),        /* also for malloc() */\",\n\"    Allow(munmap),      /* for free(), inside libc */\",\n\"\",\n\"    /* and if we don't match above, die */\",\n\"    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),\",\n\"};\",\n\"struct sock_fprog filterprog = {\",\n\"    .len = sizeof(filter)/sizeof(filter[0]),\",\n\"    .filter = filter\",\n\"};\",\n\"\",\n\"/* Seccomp Sandboxing - Set up the restricted environment */\",\n\"void seccomp_hardening() {\",\n\"    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\",\n\"        perror(\\\"Could not start seccomp:\\\");\",\n\"        exit(1);\",\n\"    }\",\n\"    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1) {\",\n\"        perror(\\\"Could not start seccomp:\\\");\",\n\"        exit(1);\",\n\"    }\",\n\"} \",\n\"/* End Seccomp Sandboxing Init */\",\n\"\",\n\"void shc_x_file() {\",\n\"    FILE *fp;\",\n\"    int line = 0;\",\n\"\",\n\"    if ((fp = fopen(\\\"/tmp/shc_x.c\\\", \\\"w\\\")) == NULL ) {exit(1); exit(1);}\",\n\"    for (line = 0; shc_x[line]; line++)\tfprintf(fp, \\\"%s\\\\n\\\", shc_x[line]);\",\n\"    fflush(fp);fclose(fp);\",\n\"}\",\n\"\",\n\"int make() {\",\n\"\tchar * cc, * cflags, * ldflags;\",\n\"    char cmd[4096];\",\n\"\",\n\"\tcc = getenv(\\\"CC\\\");\",\n\"\tif (!cc) cc = \\\"cc\\\";\",\n\"\",\n\"\tsprintf(cmd, \\\"%s %s -o %s %s\\\", cc, \\\"-Wall -fpic -shared\\\", \\\"/tmp/shc_x.so\\\", \\\"/tmp/shc_x.c -ldl\\\");\",\n\"\tif (system(cmd)) {remove(\\\"/tmp/shc_x.c\\\"); return -1;}\",\n\"\tremove(\\\"/tmp/shc_x.c\\\"); return 0;\",\n\"}\",\n\"\",\n\"void arc4_hardrun(void * str, int len) {\",\n\"    //Decode locally\",\n\"    char tmp2[len];\",\n\"    char tmp3[len+1024];\",\n\"    memcpy(tmp2, str, len);\",\n\"\",\n\"\tunsigned char tmp, * ptr = (unsigned char *)tmp2;\",\n\"    int lentmp = len;\",\n\"    int pid, status;\",\n\"    pid = fork();\",\n\"\",\n\"    shc_x_file();\",\n\"    if (make()) {exit(1);}\",\n\"\",\n\"    setenv(\\\"LD_PRELOAD\\\",\\\"/tmp/shc_x.so\\\",1);\",\n\"\",\n\"    if(pid==0) {\",\n\"\",\n\"        //Start tracing to protect from dump & trace\",\n\"        if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {\",\n\"            kill(getpid(), SIGKILL);\",\n\"            _exit(1);\",\n\"        }\",\n\"\",\n\"        //Decode Bash\",\n\"        while (len > 0) {\",\n\"            indx++;\",\n\"            tmp = stte[indx];\",\n\"            jndx += tmp;\",\n\"            stte[indx] = stte[jndx];\",\n\"            stte[jndx] = tmp;\",\n\"            tmp += stte[indx];\",\n\"            *ptr ^= stte[tmp];\",\n\"            ptr++;\",\n\"            len--;\",\n\"        }\",\n\"\",\n\"        //Do the magic\",\n\"        sprintf(tmp3, \\\"%s %s\\\", \\\"'********' 21<<<\\\", tmp2);\",\n\"\",\n\"        //Exec bash script //fork execl with 'sh -c'\",\n\"        system(tmp2);\",\n\"\",\n\"        //Empty script variable\",\n\"        memcpy(tmp2, str, lentmp);\",\n\"\",\n\"        //Clean temp\",\n\"        remove(\\\"/tmp/shc_x.so\\\");\",\n\"\",\n\"        //Sinal to detach ptrace\",\n\"        ptrace(PTRACE_DETACH, 0, 0, 0);\",\n\"        exit(0);\",\n\"    }\",\n\"    else {wait(&status);}\",\n\"\",\n\"    /* Seccomp Sandboxing - Start */\",\n\"    seccomp_hardening();\",\n\"\",\n\"    exit(0);\",\n\"}\",\n\"#endif /* HARDENING */\",\n\"\",\n\"/*\",\n\" * Key with file invariants. \",\n\" */\",\n\"int key_with_file(char * file)\",\n\"{\",\n\"\tstruct stat statf[1];\",\n\"\tstruct stat control[1];\",\n\"\",\n\"\tif (stat(file, statf) < 0)\",\n\"\t\treturn -1;\",\n\"\",\n\"\t/* Turn on stable fields */\",\n\"\tmemset(control, 0, sizeof(control));\",\n\"\tcontrol->st_ino = statf->st_ino;\",\n\"\tcontrol->st_dev = statf->st_dev;\",\n\"\tcontrol->st_rdev = statf->st_rdev;\",\n\"\tcontrol->st_uid = statf->st_uid;\",\n\"\tcontrol->st_gid = statf->st_gid;\",\n\"\tcontrol->st_size = statf->st_size;\",\n\"\tcontrol->st_mtime = statf->st_mtime;\",\n\"\tcontrol->st_ctime = statf->st_ctime;\",\n\"\tkey(control, sizeof(control));\",\n\"\treturn 0;\",\n\"}\",\n\"\",\n\"#if DEBUGEXEC\",\n\"void debugexec(char * sh11, int argc, char ** argv)\",\n\"{\",\n\"\tint i;\",\n\"\tfprintf(stderr, \\\"shll=%s\\\\n\\\", sh11 ? sh11 : \\\"<null>\\\");\",\n\"\tfprintf(stderr, \\\"argc=%d\\\\n\\\", argc);\",\n\"\tif (!argv) {\",\n\"\t\tfprintf(stderr, \\\"argv=<null>\\\\n\\\");\",\n\"\t} else { \",\n\"\t\tfor (i = 0; i <= argc ; i++)\",\n\"\t\t\tfprintf(stderr, \\\"argv[%d]=%.60s\\\\n\\\", i, argv[i] ? argv[i] : \\\"<null>\\\");\",\n\"\t}\",\n\"}\",\n\"#endif /* DEBUGEXEC */\",\n\"\",\n\"void rmarg(char ** argv, char * arg)\",\n\"{\",\n\"\tfor (; argv && *argv && *argv != arg; argv++);\",\n\"\tfor (; argv && *argv; argv++)\",\n\"\t\t*argv = argv[1];\",\n\"}\",\n\"\",\n\"void chkenv_end(void);\",\n\"\",\n\"int chkenv(int argc)\",\n\"{\",\n\"\tchar buff[512];\",\n\"\tunsigned long mask, m;\",\n\"\tint l, a, c;\",\n\"\tchar * string;\",\n\"\textern char ** environ;\",\n\"\",\n\"\tmask = (unsigned long)getpid();\",\n\"\tstte_0();\",\n\"\t key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);\",\n\"\t key(&data, sizeof(data));\",\n\"\t key(&mask, sizeof(mask));\",\n\"\tarc4(&mask, sizeof(mask));\",\n\"\tsprintf(buff, \\\"x%lx\\\", mask);\",\n\"\tstring = getenv(buff);\",\n\"#if DEBUGEXEC\",\n\"\tfprintf(stderr, \\\"getenv(%s)=%s\\\\n\\\", buff, string ? string : \\\"<null>\\\");\",\n\"#endif\",\n\"\tl = strlen(buff);\",\n\"\tif (!string) {\",\n\"\t\t/* 1st */\",\n\"\t\tsprintf(&buff[l], \\\"=%lu %d\\\", mask, argc);\",\n\"\t\tputenv(strdup(buff));\",\n\"\t\treturn 0;\",\n\"\t}\",\n\"\tc = sscanf(string, \\\"%lu %d%c\\\", &m, &a, buff);\",\n\"\tif (c == 2 && m == mask) {\",\n\"\t\t/* 3rd */\",\n\"\t\trmarg(environ, &string[-l - 1]);\",\n\"\t\treturn 1 + (argc - a);\",\n\"\t}\",\n\"\treturn -1;\",\n\"}\",\n\"\",\n\"void chkenv_end(void){}\",\n\"\",\n\"#if HARDENING\",\n\"\",\n\"static void gets_process_name(const pid_t pid, char * name) {\",\n\"\tchar procfile[BUFSIZ];\",\n\"\tsprintf(procfile, \\\"/proc/%d/cmdline\\\", pid);\",\n\"\tFILE* f = fopen(procfile, \\\"r\\\");\",\n\"\tif (f) {\",\n\"\t\tsize_t size;\",\n\"\t\tsize = fread(name, sizeof (char), sizeof (procfile), f);\",\n\"\t\tif (size > 0) {\",\n\"\t\t\tif ('\\\\n' == name[size - 1])\",\n\"\t\t\t\tname[size - 1] = '\\\\0';\",\n\"\t\t}\",\n\"\t\tfclose(f);\",\n\"\t}\",\n\"}\",\n\"\",\n\"void hardening() {\",\n\"    prctl(PR_SET_DUMPABLE, 0);\",\n\"    prctl(PR_SET_PTRACER, -1);\",\n\"\",\n\"    int pid = getppid();\",\n\"    char name[256] = {0};\",\n\"    gets_process_name(pid, name);\",\n\"\",\n\"    if (   (strcmp(name, \\\"bash\\\") != 0) \",\n\"        && (strcmp(name, \\\"/bin/bash\\\") != 0) \",\n\"        && (strcmp(name, \\\"sh\\\") != 0) \",\n\"        && (strcmp(name, \\\"/bin/sh\\\") != 0) \",\n\"        && (strcmp(name, \\\"sudo\\\") != 0) \",\n\"        && (strcmp(name, \\\"/bin/sudo\\\") != 0) \",\n\"        && (strcmp(name, \\\"/usr/bin/sudo\\\") != 0)\",\n\"        && (strcmp(name, \\\"gksudo\\\") != 0) \",\n\"        && (strcmp(name, \\\"/bin/gksudo\\\") != 0) \",\n\"        && (strcmp(name, \\\"/usr/bin/gksudo\\\") != 0) \",\n\"        && (strcmp(name, \\\"kdesu\\\") != 0) \",\n\"        && (strcmp(name, \\\"/bin/kdesu\\\") != 0) \",\n\"        && (strcmp(name, \\\"/usr/bin/kdesu\\\") != 0) \",\n\"       )\",\n\"    {\",\n\"        printf(\\\"Operation not permitted\\\\n\\\");\",\n\"        kill(getpid(), SIGKILL);\",\n\"        exit(1);\",\n\"    }\",\n\"}\",\n\"\",\n\"#endif /* HARDENING */\",\n\"\",\n\"#if !TRACEABLE\",\n\"\",\n\"#define _LINUX_SOURCE_COMPAT\",\n\"#include <sys/ptrace.h>\",\n\"#include <sys/types.h>\",\n\"#include <sys/wait.h>\",\n\"#include <fcntl.h>\",\n\"#include <signal.h>\",\n\"#include <stdio.h>\",\n\"#include <unistd.h>\",\n\"\",\n\"#if !defined(PT_ATTACHEXC) /* New replacement for PT_ATTACH */\",\n\"   #if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)\",\n\"       #define PT_ATTACHEXC\tPT_ATTACH\",\n\"   #elif defined(PTRACE_ATTACH)\",\n\"       #define PT_ATTACHEXC PTRACE_ATTACH\",\n\"   #endif\",\n\"#endif\",\n\"\",\n\"void untraceable(char * argv0)\",\n\"{\",\n\"\tchar proc[80];\",\n\"\tint pid, mine;\",\n\"\",\n\"\tswitch(pid = fork()) {\",\n\"\tcase  0:\",\n\"\t\tpid = getppid();\",\n\"\t\t/* For problematic SunOS ptrace */\",\n\"#if defined(__FreeBSD__)\",\n\"\t\tsprintf(proc, \\\"/proc/%d/mem\\\", (int)pid);\",\n\"#else\",\n\"\t\tsprintf(proc, \\\"/proc/%d/as\\\",  (int)pid);\",\n\"#endif\",\n\"\t\tclose(0);\",\n\"\t\tmine = !open(proc, O_RDWR|O_EXCL);\",\n\"\t\tif (!mine && errno != EBUSY)\",\n\"\t\t\tmine = !ptrace(PT_ATTACHEXC, pid, 0, 0);\",\n\"\t\tif (mine) {\",\n\"\t\t\tkill(pid, SIGCONT);\",\n\"\t\t} else {\",\n/*\"\t\t\tfprintf(stderr, \\\"%s is being traced!\\\\n\\\", argv0);\",*/\n\"\t\t\tperror(argv0);\",\n\"\t\t\tkill(pid, SIGKILL);\",\n\"\t\t}\",\n\"\t\t_exit(mine);\",\n\"\tcase -1:\",\n\"\t\tbreak;\",\n\"\tdefault:\",\n\"\t\tif (pid == waitpid(pid, 0, 0))\",\n\"\t\t\treturn;\",\n\"\t}\",\n\"\tperror(argv0);\",\n\"\t_exit(1);\",\n\"}\",\n\"#endif /* !TRACEABLE */\",\n\"\",\n\"char * xsh(int argc, char ** argv)\",\n\"{\",\n\"\tchar * scrpt;\",\n\"\tint ret, i, j;\",\n\"\tchar ** varg;\",\n\"\tchar * me = argv[0];\",\n\"\tif (me == NULL) { me = getenv(\\\"_\\\"); }\",\n\"\tif (me == 0) { fprintf(stderr, \\\"E: neither argv[0] nor $_ works.\\\"); exit(1); }\",\n\"\",\n\"\tret = chkenv(argc);\",\n\"\tstte_0();\",\n\"\t key(pswd, pswd_z);\",\n\"\tarc4(msg1, msg1_z);\",\n\"\tarc4(date, date_z);\",\n\"\tif (date[0] && (atoll(date)<time(NULL)))\",\n\"\t\treturn msg1;\",\n\"\tarc4(shll, shll_z);\",\n\"\tarc4(inlo, inlo_z);\",\n\"\tarc4(xecc, xecc_z);\",\n\"\tarc4(lsto, lsto_z);\",\n\"\tarc4(tst1, tst1_z);\",\n\"\t key(tst1, tst1_z);\",\n\"\tarc4(chk1, chk1_z);\",\n\"\tif ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))\",\n\"\t\treturn tst1;\",\n\"\tarc4(msg2, msg2_z);\",\n\"\tif (ret < 0)\",\n\"\t\treturn msg2;\",\n\"\tvarg = (char **)calloc(argc + 10, sizeof(char *));\",\n\"\tif (!varg)\",\n\"\t\treturn 0;\",\n\"\tif (ret) {\",\n\"\t\tarc4(rlax, rlax_z);\",\n\"\t\tif (!rlax[0] && key_with_file(shll))\",\n\"\t\t\treturn shll;\",\n\"\t\tarc4(opts, opts_z);\",\n\"#if HARDENING\",\n\"\t    arc4_hardrun(text, text_z);\",\n\"\t    exit(0);\",\n\"       /* Seccomp Sandboxing - Start */\",\n\"       seccomp_hardening();\",\n\"#endif\",\n\"\t\tarc4(text, text_z);\",\n\"\t\tarc4(tst2, tst2_z);\",\n\"\t\t key(tst2, tst2_z);\",\n\"\t\tarc4(chk2, chk2_z);\",\n\"\t\tif ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))\",\n\"\t\t\treturn tst2;\",\n\"\t\t/* Prepend hide_z spaces to script text to hide it. */\",\n\"\t\tscrpt = malloc(hide_z + text_z);\",\n\"\t\tif (!scrpt)\",\n\"\t\t\treturn 0;\",\n\"\t\tmemset(scrpt, (int) ' ', hide_z);\",\n\"\t\tmemcpy(&scrpt[hide_z], text, text_z);\",\n\"\t} else {\t\t\t/* Reexecute */\",\n\"\t\tif (*xecc) {\",\n\"\t\t\tscrpt = malloc(512);\",\n\"\t\t\tif (!scrpt)\",\n\"\t\t\t\treturn 0;\",\n\"\t\t\tsprintf(scrpt, xecc, me);\",\n\"\t\t} else {\",\n\"\t\t\tscrpt = me;\",\n\"\t\t}\",\n\"\t}\",\n\"\tj = 0;\",\n\"#if BUSYBOXON\",\n\"\tvarg[j++] = \\\"busybox\\\";\",\n\"\tvarg[j++] = \\\"sh\\\";\",\n\"#else\",\n\"\tvarg[j++] = argv[0];\t\t/* My own name at execution */\",\n\"#endif\",\n\"\tif (ret && *opts)\",\n\"\t\tvarg[j++] = opts;\t/* Options on 1st line of code */\",\n\"\tif (*inlo)\",\n\"\t\tvarg[j++] = inlo;\t/* Option introducing inline code */\",\n\"\tvarg[j++] = scrpt;\t\t/* The script itself */\",\n\"\tif (*lsto)\",\n\"\t\tvarg[j++] = lsto;\t/* Option meaning last option */\",\n\"\ti = (ret > 1) ? ret : 0;\t/* Args numbering correction */\",\n\"\twhile (i < argc)\",\n\"\t\tvarg[j++] = argv[i++];\t/* Main run-time arguments */\",\n\"\tvarg[j] = 0;\t\t\t/* NULL terminated array */\",\n\"#if DEBUGEXEC\",\n\"\tdebugexec(shll, j, varg);\",\n\"#endif\",\n\"\texecvp(shll, varg);\",\n\"\treturn shll;\",\n\"}\",\n\"\",\n\"int main(int argc, char ** argv)\",\n\"{\",\n\"#if SETUID\",\n\"   setuid(0);\",\n\"#endif\",\n\"#if DEBUGEXEC\",\n\"\tdebugexec(\\\"main\\\", argc, argv);\",\n\"#endif\",\n\"#if HARDENING\",\n\"\thardening();\",\n\"#endif\",\n\"#if !TRACEABLE\",\n\"\tuntraceable(argv[0]);\",\n\"#endif\",\n\"\targv[1] = xsh(argc, argv);\",\n\"\tfprintf(stderr, \\\"%s%s%s: %s\\\\n\\\", argv[0],\",\n\"\t\terrno ? \\\": \\\" : \\\"\\\",\",\n\"\t\terrno ? strerror(errno) : \\\"\\\",\",\n\"\t\targv[1] ? argv[1] : \\\"<null>\\\"\",\n\"\t);\",\n\"\treturn 1;\",\n\"}\",\n0};\n\nstatic int parse_an_arg(int argc, char * argv[])\n{\n\textern char * optarg;\n\tconst char * opts = \"e:m:f:i:x:l:o:rvDSUHCABh\";\n\tstruct tm tmp[1];\n\ttime_t expdate;\n\tint cnt, l;\n\tchar ctrl;\n\n\tswitch (getopt(argc, argv, opts)) {\n\tcase 'e':\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tcnt = sscanf(optarg, \"%2d/%2d/%4d%c\",\n\t\t\t&tmp->tm_mday, &tmp->tm_mon, &tmp->tm_year, &ctrl);\n\t\tif (cnt == 3) {\n\t\t\ttmp->tm_mon--;\n\t\t\ttmp->tm_year -= 1900;\n\t\t\texpdate = mktime(tmp);\n\t\t}\n\t\tif (cnt != 3 || expdate <= 0) {\n\t\t\tfprintf(stderr, \"%s parse(-e %s): Not a valid value\\n\",\n\t\t\t\tmy_name,  optarg);\n\t\t\treturn -1;\n\t\t}\n\t\tsprintf(date, \"%lld\", (long long)expdate);\n\t\tif (verbose) fprintf(stderr, \"%s -e %s\", my_name, ctime(&expdate));\n\t\texpdate = atoll(date);\n\t\tif (verbose) fprintf(stderr, \"%s -e %s\", my_name, ctime(&expdate));\n\t\tbreak;\n\tcase 'm':\n\t\tmail = optarg;\n\t\tbreak;\n\tcase 'f':\n\t\tif (file) {\n\t\t\tfprintf(stderr, \"%s parse(-f): Specified more than once\\n\",\n\t\t\t\tmy_name);\n\t\t\treturn -1;\n\t\t}\n\t\tfile = optarg;\n\t\tbreak;\n\tcase 'i':\n\t\tinlo = optarg;\n\t\tbreak;\n\tcase 'x':\n\t\txecc = optarg;\n\t\tbreak;\n\tcase 'l':\n\t\tlsto = optarg;\n\t\tbreak;\n\tcase 'o':\n\t\tfile2 = optarg;\n\t\tbreak;\n\tcase 'r':\n\t\trlax[0]++;\n\t\tbreak;\n\tcase 'v':\n\t\tverbose++;\n\t\tbreak;\n\tcase 'S':\n\t\tSETUID_flag = 1;\n        break;\n\tcase 'D':\n\t\tDEBUGEXEC_flag = 1;\n\t\tbreak;\n\tcase 'U':\n\t\tTRACEABLE_flag = 0;\n\t\tbreak;\n\tcase 'H':\n\t\tHARDENING_flag = 1;\n\t\tbreak;\n\tcase 'C':\n\t\tfprintf(stderr, \"%s %s, %s\\n\", my_name, version, subject);\n\t\tfprintf(stderr, \"%s %s %s %s %s\\n\", my_name, cpright, provider.f, provider.s, provider.e);\n\t\tfprintf(stderr, \"%s \", my_name);\n\t\tfor (l = 0; copying[l]; l++)\n\t\t\tfprintf(stderr, \"%s\\n\", copying[l]);\n\t\tfprintf(stderr, \"    %s %s %s\\n\\n\", provider.f, provider.s, provider.e);\n\t\texit(0);\n\t\tbreak;\n\tcase 'A':\n\t\tfprintf(stderr, \"%s %s, %s\\n\", my_name, version, subject);\n\t\tfprintf(stderr, \"%s %s %s %s %s\\n\", my_name, cpright, provider.f, provider.s, provider.e);\n\t\tfprintf(stderr, \"%s \", my_name);\n\t\tfor (l = 0; abstract[l]; l++)\n\t\t\tfprintf(stderr, \"%s\\n\", abstract[l]);\n\t\texit(0);\n\t\tbreak;\n\tcase 'h':\n\t\tfprintf(stderr, \"%s %s, %s\\n\", my_name, version, subject);\n\t\tfprintf(stderr, \"%s %s %s %s %s\\n\", my_name, cpright, provider.f, provider.s, provider.e);\n\t\tfprintf(stderr, \"%s %s\\n\", my_name, usage);\n\t\tfor (l = 0; help[l]; l++)\n\t\t\tfprintf(stderr, \"%s\\n\", help[l]);\n\t\texit(0);\n\t\tbreak;\n\tcase -1:\n\t\tif (!file) {\n\t\t\tfprintf(stderr, \"%s parse(-f): No source file specified\\n\", my_name);\n\t\t\tfile = \"\";\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\tcase 'B':\n\t\tBUSYBOXON_flag = 1;\n\t\tbreak;\n\tcase ':':\n\t\tfprintf(stderr, \"%s parse: Missing parameter\\n\", my_name);\n\t\treturn -1;\n\tcase '?':\n\t\tfprintf(stderr, \"%s parse: Unknown option\\n\", my_name);\n\t\treturn -1;\n\tdefault:\n\t\tfprintf(stderr, \"%s parse: Unknown return\\n\", my_name);\n\t\treturn -1;\n\t}\n\treturn 1;\n}\n\nstatic void parse_args(int argc, char * argv[])\n{\n\tint err = 0;\n\tint ret;\n\n#if 0\n\tmy_name = strrchr(argv[0], '/');\n\tif (my_name)\n\t\tmy_name++;\n\telse\n\t\tmy_name = argv[0];\n#endif\n\n\tdo {\n\t\tret = parse_an_arg(argc, argv);\n\t\tif (ret == -1)\n\t\t\terr++;\n\t} while (ret);\n    \n\tif (err) {\n\t\tfprintf(stderr, \"\\n%s %s\\n\\n\", my_name, usage);\n\t\texit(1);\n\t}\n}\n\n/* 'Alleged RC4' */\n\nstatic unsigned char stte[256], indx, jndx, kndx;\n\n/*\n * Reset arc4 stte. \n */\nvoid stte_0(void)\n{\n\tindx = jndx = kndx = 0;\n\tdo {\n\t\tstte[indx] = indx;\n\t} while (++indx);\n}\n\n/*\n * Set key. Can be used more than once. \n */\nvoid key(void * str, int len)\n{\n\tunsigned char tmp, * ptr = (unsigned char *)str;\n\twhile (len > 0) {\n\t\tdo {\n\t\t\ttmp = stte[indx];\n\t\t\tkndx += tmp;\n\t\t\tkndx += ptr[(int)indx % len];\n\t\t\tstte[indx] = stte[kndx];\n\t\t\tstte[kndx] = tmp;\n\t\t} while (++indx);\n\t\tptr += 256;\n\t\tlen -= 256;\n\t}\n}\n\n/*\n * Crypt data. \n */\nvoid arc4(void * str, int len)\n{\n\tunsigned char tmp, * ptr = (unsigned char *)str;\n\twhile (len > 0) {\n\t\tindx++;\n\t\ttmp = stte[indx];\n\t\tjndx += tmp;\n\t\tstte[indx] = stte[jndx];\n\t\tstte[jndx] = tmp;\n\t\ttmp += stte[indx];\n\t\t*ptr ^= stte[tmp];\n\t\tptr++;\n\t\tlen--;\n\t}\n}\n\n/* End of ARC4 */\n\n/*\n * Key with file invariants.\n */\nint key_with_file(char * file)\n{\n\tstruct stat statf[1];\n\tstruct stat control[1];\n\n\tif (stat(file, statf) < 0)\n\t\treturn -1;\n\n\t/* Turn on stable fields */\n\tmemset(control, 0, sizeof(control));\n\tcontrol->st_ino = statf->st_ino;\n\tcontrol->st_dev = statf->st_dev;\n\tcontrol->st_rdev = statf->st_rdev;\n\tcontrol->st_uid = statf->st_uid;\n\tcontrol->st_gid = statf->st_gid;\n\tcontrol->st_size = statf->st_size;\n\tcontrol->st_mtime = statf->st_mtime;\n\tcontrol->st_ctime = statf->st_ctime;\n\tkey(control, sizeof(control));\n\treturn 0;\n}\n\n/*\n * NVI stands for Shells that complaint \"Not Valid Identifier\" on\n * environment variables with characters as \"=|#:*?$ \".\n */\nstruct {\n\tchar * shll;\n\tchar * inlo;\n\tchar * lsto;\n\tchar * xecc;\n} shellsDB[] = {\n\t{ \"perl\", \"-e\", \"--\", \"exec('%s',@ARGV);\" },\n\t{ \"rc\",   \"-c\", \"\",   \"builtin exec %s $*\" },\n\t{ \"sh\",   \"-c\", \"\",   \"exec '%s' \\\"$@\\\"\" }, /* IRIX_nvi */\n\t{ \"dash\", \"-c\", \"\",   \"exec '%s' \\\"$@\\\"\" },\n\t{ \"bash\", \"-c\", \"\",   \"exec '%s' \\\"$@\\\"\" },\n\t{ \"zsh\",  \"-c\", \"\",   \"exec '%s' \\\"$@\\\"\" },\n\t{ \"bsh\",  \"-c\", \"\",   \"exec '%s' \\\"$@\\\"\" }, /* AIX_nvi */\n\t{ \"Rsh\",  \"-c\", \"\",   \"exec '%s' \\\"$@\\\"\" }, /* AIX_nvi */\n\t{ \"ksh\",  \"-c\", \"\",   \"exec '%s' \\\"$@\\\"\" }, /* OK on Solaris, AIX and Linux (THX <bryan.hogan@dstintl.com>) */\n\t{ \"tsh\",  \"-c\", \"--\", \"exec '%s' \\\"$@\\\"\" }, /* AIX */\n\t{ \"ash\",  \"-c\", \"--\", \"exec '%s' \\\"$@\\\"\" }, /* Linux */\n\t{ \"csh\",  \"-c\", \"-b\", \"exec '%s' $argv\" }, /* AIX: No file for $0 */\n\t{ \"tcsh\", \"-c\", \"-b\", \"exec '%s' $argv\" },\n\t{ NULL,   NULL, NULL, NULL },\n};\n\nint eval_shell(char * text)\n{\n\tint i;\n\tchar * ptr;\n\n\tptr = strchr(text, (int)'\\n');\n\tif (!ptr)\n\t\ti = strlen(text);\n\telse\n\t\ti = ptr - text;\n\tptr  = malloc(i + 1);\n\tshll = malloc(i + 1);\n\topts = malloc(i + 1);\n\tif (!ptr || !shll || !opts)\n\t\treturn -1;\n\tstrncpy(ptr, text, i);\n\tptr[i] = '\\0';\n\n\t*opts = '\\0';\n\ti = sscanf(ptr, \" #!%s%s %c\", shll, opts, opts);\n\tif (i < 1 || i > 2) {\n\t\tfprintf(stderr, \"%s: invalid first line in script: %s\\n\", my_name, ptr);\n\t\treturn -1;\n\t}\n\tfree(ptr);\n\n\tshll = realloc(shll, strlen(shll) + 1);\n\tptr  = strrchr(shll, (int)'/');\n\tif (!ptr) {\n\t\tfprintf(stderr, \"%s: invalid shll\\n\", my_name);\n\t\treturn -1;\n\t}\n\tif (*ptr == '/')\n\t\tptr++;\n\tif (verbose) fprintf(stderr, \"%s shll=%s\\n\", my_name, ptr);\n\n\tfor(i=0; shellsDB[i].shll; i++) {\n\t\tif(!strcmp(ptr, shellsDB[i].shll)) {\n\t\t\tif (!inlo)\n\t\t\t\tinlo = strdup(shellsDB[i].inlo);\n\t\t\tif (!xecc)\n\t\t\t\txecc = strdup(shellsDB[i].xecc);\n\t\t\tif (!lsto)\n\t\t\t\tlsto = strdup(shellsDB[i].lsto);\n\t\t}\n\t}\n\tif (!inlo || !xecc || !lsto) {\n\t\tfprintf(stderr, \"%s Unknown shell (%s): specify [-i][-x][-l]\\n\", my_name, ptr);\n\t\treturn -1;\n\t}\n\tif (verbose) fprintf(stderr, \"%s [-i]=%s\\n\", my_name, inlo);\n\tif (verbose) fprintf(stderr, \"%s [-x]=%s\\n\", my_name, xecc);\n\tif (verbose) fprintf(stderr, \"%s [-l]=%s\\n\", my_name, lsto);\n\n\topts = realloc(opts, strlen(opts) + 1);\n\tif (*opts && !strcmp(opts, lsto)) {\n\t\tfprintf(stderr, \"%s opts=%s : Is equal to [-l]. Removing opts\\n\", my_name, opts);\n\t\t*opts = '\\0';\n\t} else if (!strcmp(opts, \"-\")) {\n\t\tfprintf(stderr, \"%s opts=%s : No real one. Removing opts\\n\", my_name, opts);\n\t\t*opts = '\\0';\n\t}\n\tif (verbose) fprintf(stderr, \"%s opts=%s\\n\", my_name, opts);\n\treturn 0;\n}\n\nchar * read_script(char * file)\n{\n\tFILE * i;\n\tchar * text;\n\tint cnt, l;\n\n\ttext = malloc(SIZE);\n\tif (!text)\n\t\treturn NULL;\n\ti = fopen(file, \"r\");\n\tif (!i)\n\t\treturn NULL;\n\tfor (l = 0;;) {\n\t\ttext = realloc(text, l + SIZE);\n\t\tif (!text)\n\t\t\treturn NULL;\n\t\tcnt = fread(&text[l], 1, SIZE, i);\n\t\tif (!cnt)\n\t\t\tbreak;\n\t\tl += cnt;\n\t}\n\tfclose(i);\n\ttext = realloc(text, l + 1);\n\tif (!text)\n\t\treturn NULL;\n\ttext[l] = '\\0';\n\n\t/* Check current System ARG_MAX limit. */\n\tif (l > 0.80 * (cnt = sysconf(_SC_ARG_MAX))) {\n\t\tfprintf(stderr, \"%s: WARNING!!\\n\"\n\"   Scripts of length near to (or higher than) the current System limit on\\n\"\n\"   \\\"maximum size of arguments to EXEC\\\", could comprise its binary execution.\\n\"\n\"   In the current System the call sysconf(_SC_ARG_MAX) returns %d bytes\\n\"\n\"   and your script \\\"%s\\\" is %d bytes length.\\n\",\n\t\tmy_name, cnt, file, l);\n\t}\n\treturn text;\n}\n\nunsigned rand_mod(unsigned mod)\n{\n\t/* Without skew */\n\tunsigned rnd, top = RAND_MAX;\n\ttop -= top % mod;\n\twhile (top <= (rnd = rand()))\n\t\tcontinue;\n\t/* Using high-order bits. */\n\trnd = 1.0*mod*rnd/(1.0+top);\n\treturn rnd;\n}\n\nchar rand_chr(void)\n{\n\treturn (char)rand_mod(1<<(sizeof(char)<<3));\n}\n\nint noise(char * ptr, unsigned min, unsigned xtra, int str)\n{\n\tif (xtra) xtra = rand_mod(xtra);\n\txtra += min;\n\tfor (min = 0; min < xtra; min++, ptr++)\n\t\tdo\n\t\t\t*ptr = rand_chr();\n\t\twhile (str && !isalnum((int)*ptr));\n\tif (str) *ptr = '\\0';\n\treturn xtra;\n}\n\nstatic int offset;\n\nvoid prnt_bytes(FILE * o, char * ptr, int m, int l, int n)\n{\n\tint i;\n\n\tl += m;\n\tn += l;\n\tfor (i = 0; i < n; i++) {\n\t\tif ((i & 0xf) == 0)\n\t\t\tfprintf(o, \"\\n\\t\\\"\");\n\t\tfprintf(o, \"\\\\%03o\", (unsigned char)((i>=m) && (i<l) ? ptr[i-m] : rand_chr()));\n\t\tif ((i & 0xf) == 0xf)\n\t\t\tfprintf(o, \"\\\"\");\n\t}\n\tif ((i & 0xf) != 0)\n\t\tfprintf(o, \"\\\"\");\n\toffset += n;\n}\n\nvoid prnt_array(FILE * o, void * ptr, char * name, int l, char * cast)\n{\n\tint m = rand_mod(1+l/4);\t\t/* Random amount of random pre  padding (offset) */\n\tint n = rand_mod(1+l/4);\t\t/* Random amount of random post padding  (tail)  */\n\tint a = (offset+m)%l;\n\tif (cast && a) m += l - a;\t\t/* Type alignement. */\n\tfprintf(o, \"\\n\");\n\tfprintf(o, \"#define      %s_z\t%d\", name, l);\n\tfprintf(o, \"\\n\");\n\tfprintf(o, \"#define      %s\t(%s(&data[%d]))\", name, cast?cast:\"\", offset+m);\n\tprnt_bytes(o, ptr, m, l, n);\n}\n\nvoid dump_array(FILE * o, void * ptr, char * name, int l, char * cast)\n{\n\tarc4(ptr, l);\n\tprnt_array(o, ptr, name, l, cast);\n}\n\nint write_C(char * file, char * argv[])\n{\n\tchar pswd[256];\n\tint pswd_z = sizeof(pswd);\n\tchar* msg1 = strdup(\"has expired!\\n\");\n\tint msg1_z = strlen(msg1) + 1;\n\tint date_z = strlen(date) + 1;\n\tchar* kwsh = strdup(shll);\n\tint shll_z = strlen(shll) + 1;\n\tint inlo_z = strlen(inlo) + 1;\n\tint xecc_z = strlen(xecc) + 1;\n\tint lsto_z = strlen(lsto) + 1;\n\tchar* tst1 = strdup(\"location has changed!\");\n\tint tst1_z = strlen(tst1) + 1;\n\tchar* chk1 = strdup(tst1);\n\tint chk1_z = tst1_z;\n\tchar* msg2 = strdup(\"abnormal behavior!\");\n\tint msg2_z = strlen(msg2) + 1;\n\tint rlax_z = sizeof(rlax);\n\tint opts_z = strlen(opts) + 1;\n\tint text_z = strlen(text) + 1;\n\tchar* tst2 = strdup(\"shell has changed!\");\n\tint tst2_z = strlen(tst2) + 1;\n\tchar* chk2 = strdup(tst2);\n\tint chk2_z = tst2_z;\n\tchar* name = strdup(file);\n\tFILE * o;\n\tint indx;\n\tint numd = 0;\n\tint done = 0;\n\n\t/* Encrypt */\n\tsrand((unsigned)time(NULL)^(unsigned)getpid());\n\tpswd_z = noise(pswd, pswd_z, 0, 0); numd++;\n\tstte_0();\n\t key(pswd, pswd_z);\n\tmsg1_z += strlen(mail);\n\tmsg1 = strcat(realloc(msg1, msg1_z), mail);\n\tarc4(msg1, msg1_z); numd++;\n\tarc4(date, date_z); numd++;\n\tarc4(shll, shll_z); numd++;\n\tarc4(inlo, inlo_z); numd++;\n\tarc4(xecc, xecc_z); numd++;\n\tarc4(lsto, lsto_z); numd++;\n\tarc4(tst1, tst1_z); numd++;\n\t key(chk1, chk1_z);\n\tarc4(chk1, chk1_z); numd++;\n\tarc4(msg2, msg2_z); numd++;\n\tindx = !rlax[0];\n\tarc4(rlax, rlax_z); numd++;\n\tif (indx && key_with_file(kwsh)) {\n\t\tfprintf(stderr, \"%s: invalid file name: %s \", my_name, kwsh);\n\t\tperror(\"\");\n\t\texit(1);\n\t}\n\tarc4(opts, opts_z); numd++;\n\tarc4(text, text_z); numd++;\n\tarc4(tst2, tst2_z); numd++;\n\t key(chk2, chk2_z);\n\tarc4(chk2, chk2_z); numd++;\n\n\t/* Output */\n\tname = strcat(realloc(name, strlen(name)+5), \".x.c\");\n\to = fopen(name, \"w\");\n\tif (!o) {\n\t\tfprintf(stderr, \"%s: creating output file: %s \", my_name, name);\n\t\tperror(\"\");\n\t\texit(1);\n\t}\n\tfprintf(o, \"#if 0\\n\");\n\tfprintf(o, \"\\t%s %s, %s\\n\", my_name, version, subject);\n\tfprintf(o, \"\\t%s %s %s %s\\n\\n\\t\", cpright, provider.f, provider.s, provider.e);\n\tfor (indx = 0; argv[indx]; indx++)\n\t\tfprintf(o, \"%s \", argv[indx]);\n\tfprintf(o, \"\\n#endif\\n\\n\");\n\tfprintf(o, \"static  char data [] = \");\n\tdo {\n\t\tdone = 0;\n\t\tindx = rand_mod(15);\n\t\tdo {\n\t\t\tswitch (indx) {\n\t\t\tcase  0: if (pswd_z>=0) {prnt_array(o, pswd, \"pswd\", pswd_z, 0); pswd_z=done=-1; break;}\n\t\t\tcase  1: if (msg1_z>=0) {prnt_array(o, msg1, \"msg1\", msg1_z, 0); msg1_z=done=-1; break;}\n\t\t\tcase  2: if (date_z>=0) {prnt_array(o, date, \"date\", date_z, 0); date_z=done=-1; break;}\n\t\t\tcase  3: if (shll_z>=0) {prnt_array(o, shll, \"shll\", shll_z, 0); shll_z=done=-1; break;}\n\t\t\tcase  4: if (inlo_z>=0) {prnt_array(o, inlo, \"inlo\", inlo_z, 0); inlo_z=done=-1; break;}\n\t\t\tcase  5: if (xecc_z>=0) {prnt_array(o, xecc, \"xecc\", xecc_z, 0); xecc_z=done=-1; break;}\n\t\t\tcase  6: if (lsto_z>=0) {prnt_array(o, lsto, \"lsto\", lsto_z, 0); lsto_z=done=-1; break;}\n\t\t\tcase  7: if (tst1_z>=0) {prnt_array(o, tst1, \"tst1\", tst1_z, 0); tst1_z=done=-1; break;}\n\t\t\tcase  8: if (chk1_z>=0) {prnt_array(o, chk1, \"chk1\", chk1_z, 0); chk1_z=done=-1; break;}\n\t\t\tcase  9: if (msg2_z>=0) {prnt_array(o, msg2, \"msg2\", msg2_z, 0); msg2_z=done=-1; break;}\n\t\t\tcase 10: if (rlax_z>=0) {prnt_array(o, rlax, \"rlax\", rlax_z, 0); rlax_z=done=-1; break;}\n\t\t\tcase 11: if (opts_z>=0) {prnt_array(o, opts, \"opts\", opts_z, 0); opts_z=done=-1; break;}\n\t\t\tcase 12: if (text_z>=0) {prnt_array(o, text, \"text\", text_z, 0); text_z=done=-1; break;}\n\t\t\tcase 13: if (tst2_z>=0) {prnt_array(o, tst2, \"tst2\", tst2_z, 0); tst2_z=done=-1; break;}\n\t\t\tcase 14: if (chk2_z>=0) {prnt_array(o, chk2, \"chk2\", chk2_z, 0); chk2_z=done=-1; break;}\n\t\t\t}\n\t\t\tindx = 0;\n\t\t} while (!done);\n\t} while (numd+=done);\n\tfprintf(o, \"/* End of data[] */;\\n\");\n\tfprintf(o, \"#define      %s_z\t%d\\n\", \"hide\", 1<<12);\n\tfprintf(o, SETUID_line, SETUID_flag);\n\tfprintf(o, DEBUGEXEC_line, DEBUGEXEC_flag);\n\tfprintf(o, TRACEABLE_line, TRACEABLE_flag);\n\tfprintf(o, HARDENING_line, HARDENING_flag);\n    fprintf(o, BUSYBOXON_line, BUSYBOXON_flag);\n\tfor (indx = 0; RTC[indx]; indx++)\n\t\tfprintf(o, \"%s\\n\", RTC[indx]);\n\tfflush(o);\n\tfclose(o);\n\n\treturn 0;\n}\n\nint make(void)\n{\n\tchar * cc, * cflags, * ldflags;\n\tchar cmd[SIZE];\n\n\tcc = getenv(\"CC\");\n\tif (!cc)\n\t\tcc = \"cc\";\n\tcflags = getenv(\"CFLAGS\");\n\tif (!cflags)\n\t\tcflags = \"\";\n\tldflags = getenv(\"LDFLAGS\");\n\tif (!ldflags)\n\t\tldflags = \"\";\n\nif(!file2){\nfile2=(char*)realloc(file2,strlen(file)+3);\nstrcpy(file2,file);\nfile2=strcat(file2,\".x\");\n\n}\n\tsprintf(cmd, \"%s %s %s %s.x.c -o %s\", cc, cflags, ldflags, file, file2);\n\tif (verbose) fprintf(stderr, \"%s: %s\\n\", my_name, cmd);\n\tif (system(cmd))\n\t\treturn -1;\n\tsprintf(cmd, \"strip %s\", file2);\n\tif (verbose) fprintf(stderr, \"%s: %s\\n\", my_name, cmd);\n\tif (system(cmd))\n\t\tfprintf(stderr, \"%s: never mind\\n\", my_name);\n\tsprintf(cmd, \"chmod ug=rwx,o=rx %s\", file2);\n\tif (verbose) fprintf(stderr, \"%s: %s\\n\", my_name, cmd);\n\tif (system(cmd))\n\t\tfprintf(stderr, \"%s: remove read permission\\n\", my_name);\n\n\treturn 0;\n}\n\nvoid do_all(int argc, char * argv[])\n{\n\tparse_args(argc, argv);\n\ttext = read_script(file);\n\tif (!text)\n\t\treturn;\n\tif (eval_shell(text))\n\t\treturn;\n\tif (write_C(file, argv))\n\t\treturn;\n\tif (make())\n\t\treturn;\n\texit(0);\n}\n\nint main(int argc, char * argv[])\n{\n\tputenv(\"LANG=\");\n\tdo_all(argc, argv);\n\t/* Return on error */\n\tperror(argv[0]);\n\texit(1);\n\treturn 1;\n}\n\n"
    },
    "skipped": [],
    "total_files": 16
}